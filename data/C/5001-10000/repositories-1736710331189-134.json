{
  "metadata": {
    "timestamp": 1736710331189,
    "page": 134,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "maharmstone/btrfs",
      "stars": 6101,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.154296875,
          "content": "[submodule \"src/zstd\"]\n\tpath = src/zstd\n\turl = https://github.com/facebook/zstd\n[submodule \"src/zlib\"]\n\tpath = src/zlib\n\turl = https://github.com/madler/zlib\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 12.1748046875,
          "content": "cmake_minimum_required(VERSION 3.15)\n\nproject(btrfs VERSION 1.9.0)\n\noption(WITH_TEST \"Compile test program\" ON)\n\nif(MSVC) # cmake bug 15170\n    if(MSVC_C_ARCHITECTURE_ID STREQUAL \"X86\")\n        set(CMAKE_SYSTEM_PROCESSOR \"x86\")\n    elseif(MSVC_C_ARCHITECTURE_ID STREQUAL \"x64\")\n        set(CMAKE_SYSTEM_PROCESSOR \"x86_64\")\n    elseif(MSVC_C_ARCHITECTURE_ID STREQUAL \"ARMV7\")\n        set(CMAKE_SYSTEM_PROCESSOR \"arm\")\n    elseif(MSVC_C_ARCHITECTURE_ID STREQUAL \"ARM64\")\n        set(CMAKE_SYSTEM_PROCESSOR \"aarch64\")\n    endif()\nendif()\n\n# zstd\n\nset(ZSTD_SRC_FILES src/zstd/lib/common/entropy_common.c\n    src/zstd/lib/common/error_private.c\n    src/zstd/lib/compress/fse_compress.c\n    src/zstd/lib/common/fse_decompress.c\n    src/zstd/lib/compress/hist.c\n    src/zstd/lib/compress/huf_compress.c\n    src/zstd/lib/decompress/huf_decompress.c\n    src/zstd/lib/common/zstd_common.c\n    src/zstd/lib/compress/zstd_compress.c\n    src/zstd/lib/compress/zstd_compress_literals.c\n    src/zstd/lib/compress/zstd_compress_sequences.c\n    src/zstd/lib/compress/zstd_compress_superblock.c\n    src/zstd/lib/decompress/zstd_ddict.c\n    src/zstd/lib/decompress/zstd_decompress.c\n    src/zstd/lib/decompress/zstd_decompress_block.c\n    src/zstd/lib/compress/zstd_double_fast.c\n    src/zstd/lib/compress/zstd_fast.c\n    src/zstd/lib/compress/zstd_lazy.c\n    src/zstd/lib/compress/zstd_ldm.c\n    src/zstd/lib/compress/zstd_opt.c\n    src/zstd/lib/common/xxhash.c)\n\nadd_library(zstd STATIC ${ZSTD_SRC_FILES})\ntarget_compile_definitions(zstd PRIVATE -DZSTD_DEPS_MALLOC -DXXH_NO_STDLIB)\n\nif(NOT MSVC)\n    target_compile_options(zstd PRIVATE -ffunction-sections -include ${CMAKE_SOURCE_DIR}/src/zstd-shim.h)\nelse()\n    target_compile_options(zstd PRIVATE /Gy /FI ${CMAKE_SOURCE_DIR}/src/zstd-shim.h)\n    set_property(TARGET zstd PROPERTY MSVC_RUNTIME_LIBRARY \"MultiThreaded$<$<CONFIG:Debug>:Debug>\")\nendif()\n\nif(MSVC AND CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86\")\n    target_compile_options(zstd PUBLIC /Gz) # stdcall\nendif()\n\n# zlib\n\nset(ZLIB_SRC_FILES src/zlib/adler32.c\n    src/zlib/deflate.c\n    src/zlib/inffast.c\n    src/zlib/inflate.c\n    src/zlib/inftrees.c\n    src/zlib/trees.c\n    src/zlib/zutil.c)\n\nadd_library(zlib STATIC ${ZLIB_SRC_FILES})\ntarget_compile_definitions(zlib PRIVATE -DNO_GZIP -DZ_SOLO)\n\nif(NOT MSVC)\n    target_compile_options(zlib PRIVATE -ffunction-sections)\nelse()\n    target_compile_options(zlib PRIVATE /Gy)\nendif()\n\nif(MSVC AND CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86\")\n    target_compile_options(zlib PUBLIC /Gz) # stdcall\nendif()\n\n# btrfs.sys\n\nset(SRC_FILES src/balance.c\n    src/blake2b-ref.c\n    src/boot.c\n    src/btrfs.c\n    src/cache.c\n    src/calcthread.c\n    src/compress.c\n    src/crc32c.c\n    src/create.c\n    src/devctrl.c\n    src/dirctrl.c\n    src/extent-tree.c\n    src/fastio.c\n    src/fileinfo.c\n    src/flushthread.c\n    src/free-space.c\n    src/fsctl.c\n    src/fsrtl.c\n    src/galois.c\n    src/pnp.c\n    src/read.c\n    src/registry.c\n    src/reparse.c\n    src/scrub.c\n    src/search.c\n    src/security.c\n    src/send.c\n    src/sha256.c\n    src/treefuncs.c\n    src/volume.c\n    src/worker-thread.c\n    src/write.c\n    ${CMAKE_CURRENT_BINARY_DIR}/btrfs.rc)\n\n# Work around bug in MSVC version of cmake - see https://gitlab.kitware.com/cmake/cmake/-/merge_requests/4257\nset(CMAKE_ASM_MASM_COMPILE_OPTIONS_MSVC_RUNTIME_LIBRARY_MultiThreaded         \"\")\nset(CMAKE_ASM_MASM_COMPILE_OPTIONS_MSVC_RUNTIME_LIBRARY_MultiThreadedDLL      \"\")\nset(CMAKE_ASM_MASM_COMPILE_OPTIONS_MSVC_RUNTIME_LIBRARY_MultiThreadedDebug    \"\")\nset(CMAKE_ASM_MASM_COMPILE_OPTIONS_MSVC_RUNTIME_LIBRARY_MultiThreadedDebugDLL \"\")\n\nset(CMAKE_ASM_MASM_FLAGS \"/Zd\")\n\nif(CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86_64\" OR CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86\")\n    if(MSVC)\n        enable_language(ASM_MASM)\n        set(SRC_FILES ${SRC_FILES}\n            src/crc32c-masm.asm\n            src/xor-masm.asm)\n    else()\n        enable_language(ASM)\n        set(SRC_FILES ${SRC_FILES}\n            src/crc32c-gas.S\n            src/xor-gas.S)\n    endif()\nendif()\n\nif(MSVC AND (CMAKE_SYSTEM_PROCESSOR STREQUAL \"aarch64\"))\n    # see cmake bug 24317 if armasm64 fails (should be fixed in CMake 3.29)\n    enable_language(ASM_MARMASM)\n    set(SRC_FILES ${SRC_FILES}\n        src/crc32c-aarch64.asm)\nendif()\n\nconfigure_file(src/btrfs.rc.in btrfs.rc)\n\nif(CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86_64\")\n    add_definitions(-D_AMD64_)\n    set(MS_ARCH \"x64\")\nelseif(CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86\")\n    add_definitions(-D_X86_)\n    set(MS_ARCH \"x86\")\nelseif(CMAKE_SYSTEM_PROCESSOR STREQUAL \"arm\")\n    add_definitions(-D_ARM_)\n    set(MS_ARCH \"arm\")\nelseif(CMAKE_SYSTEM_PROCESSOR STREQUAL \"aarch64\")\n    add_definitions(-D_ARM64_)\n    set(MS_ARCH \"arm64\")\nendif()\n\nif(MSVC)\n    include_directories(\"$ENV{WindowsSdkDir}Include\\\\$ENV{WindowsSDKLibVersion}km\")\n    link_directories(\"$ENV{WindowsSdkDir}Lib\\\\$ENV{WindowsSDKLibVersion}km\\\\${MS_ARCH}\")\nelseif(CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\" AND WIN32)\n    include_directories(\"${CMAKE_FIND_ROOT_PATH}/usr/include/ddk\")\nendif()\n\nadd_library(btrfs SHARED ${SRC_FILES})\ntarget_link_libraries(btrfs zstd zlib)\n\nif(CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n    add_definitions(-D_DEBUG)\nendif()\n\nif(NOT MSVC)\n    target_compile_options(btrfs PUBLIC -U__NO_INLINE__)\n    add_definitions(-D__USE_MINGW_ANSI_STDIO=0)\nendif()\n\ntarget_compile_definitions(btrfs PUBLIC _KERNEL_MODE WIN9X_COMPAT_SPINLOCK)\n\nif(MSVC)\n    if(CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86\")\n        target_compile_options(btrfs PUBLIC /Gz) # stdcall\n    endif()\n\n    target_link_libraries(btrfs ntoskrnl hal)\n\n    if(CMAKE_SYSTEM_PROCESSOR STREQUAL \"arm\" OR CMAKE_SYSTEM_PROCESSOR STREQUAL \"aarch64\")\n        target_link_libraries(btrfs bufferoverflowfastfailk)\n    else()\n        target_link_libraries(btrfs BufferOverflowK)\n    endif()\n\n    if(CMAKE_SYSTEM_PROCESSOR STREQUAL \"arm\")\n        target_link_libraries(btrfs armrt)\n    elseif(CMAKE_SYSTEM_PROCESSOR STREQUAL \"aarch64\")\n        target_link_libraries(btrfs arm64rt)\n    endif()\n\n    target_link_libraries(btrfs rtlver)\n    target_link_options(btrfs PUBLIC /SUBSYSTEM:NATIVE /NODEFAULTLIB /MANIFEST:NO /Driver /ENTRY:DriverEntry)\n\n    # strip out flags for MSVC's runtime checks\n    string(REGEX REPLACE \"/RTC(su|[1su])\" \"\" CMAKE_C_FLAGS \"${CMAKE_C_FLAGS}\")\n    string(REGEX REPLACE \"/RTC(su|[1su])\" \"\" CMAKE_C_FLAGS_DEBUG \"${CMAKE_C_FLAGS_DEBUG}\")\nelse()\n    target_compile_options(btrfs PUBLIC -Wall -Werror-implicit-function-declaration -Werror=incompatible-pointer-types -Wno-expansion-to-defined -Wunused-parameter -Wtype-limits -Wextra)\n\n    if (CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\")\n        target_compile_options(btrfs PUBLIC -Werror=cast-function-type -Wold-style-declaration)\n    elseif (CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n        target_compile_options(btrfs PUBLIC -Wno-pragma-pack) # ignore warning in mingw headers\n    endif()\n\n    target_link_libraries(btrfs ntoskrnl hal gcc)\n    target_link_options(btrfs PUBLIC -nostdlib -Wl,--subsystem,native -Wl,--file-alignment,0x1000 -Wl,--section-alignment,0x1000 -Wl,--exclude-all-symbols)\n\n    if(CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86\")\n        target_link_options(btrfs PUBLIC -Wl,--entry,_DriverEntry@8)\n    else()\n        target_link_options(btrfs PUBLIC -Wl,--entry,DriverEntry)\n    endif()\nendif()\n\nset_target_properties(btrfs PROPERTIES PREFIX \"\")\nset_target_properties(btrfs PROPERTIES SUFFIX \".sys\")\n\n# --------------------------------------\n\n# shellbtrfs.dll\n\nset(SHELLEXT_SRC_FILES src/shellext/balance.cpp\n    src/shellext/contextmenu.cpp\n    src/shellext/devices.cpp\n    src/shellext/factory.cpp\n    src/shellext/iconoverlay.cpp\n    src/shellext/main.cpp\n    src/shellext/mountmgr.cpp\n    src/shellext/propsheet.cpp\n    src/shellext/recv.cpp\n    src/shellext/scrub.cpp\n    src/shellext/send.cpp\n    src/shellext/volpropsheet.cpp\n    src/crc32c.c\n    src/shellext/shellbtrfs.def\n    ${CMAKE_CURRENT_BINARY_DIR}/shellbtrfs.rc)\n\nif(CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86_64\" OR CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86\")\n    if(MSVC)\n        enable_language(ASM_MASM)\n        set(SHELLEXT_SRC_FILES ${SHELLEXT_SRC_FILES} src/crc32c-masm.asm)\n    else()\n        enable_language(ASM)\n        set(SHELLEXT_SRC_FILES ${SHELLEXT_SRC_FILES} src/crc32c-gas.S)\n    endif()\nendif()\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_VISIBILITY_PRESET hidden)\n\nconfigure_file(src/shellext/shellbtrfs.rc.in shellbtrfs.rc)\n\nadd_library(shellbtrfs SHARED ${SHELLEXT_SRC_FILES})\n\nif(NOT MSVC)\n    target_link_options(shellbtrfs PUBLIC -static -static-libgcc)\n    target_link_libraries(shellbtrfs pthread)\n\n    target_compile_options(shellbtrfs PUBLIC -Wall -Wno-expansion-to-defined -Wunused-parameter -Wtype-limits -Wextra)\nelse()\n    target_compile_options(shellbtrfs PUBLIC /EHsc)\n    target_link_options(shellbtrfs PUBLIC /MANIFEST:NO)\nendif()\n\ntarget_link_libraries(shellbtrfs comctl32 ntdll setupapi uxtheme shlwapi windowscodecs gdi32 advapi32 shell32 ole32)\n\nif(MSVC AND CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86\")\n    target_compile_options(shellbtrfs PUBLIC /Gz) # stdcall\nendif()\n\nset_target_properties(shellbtrfs PROPERTIES PREFIX \"\")\n\nif(MSVC)\n    set_property(TARGET shellbtrfs PROPERTY MSVC_RUNTIME_LIBRARY \"MultiThreaded$<$<CONFIG:Debug>:Debug>\")\nendif()\n\n# --------------------------------------\n\n# ubtrfs.dll\n\nset(UBTRFS_SRC_FILES src/ubtrfs/ubtrfs.c\n    src/crc32c.c\n    src/sha256.c\n    src/blake2b-ref.c\n    src/ubtrfs/ubtrfs.def\n    ${CMAKE_CURRENT_BINARY_DIR}/ubtrfs.rc)\n\nif(CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86_64\" OR CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86\")\n    if(MSVC)\n        enable_language(ASM_MASM)\n        set(UBTRFS_SRC_FILES ${UBTRFS_SRC_FILES} src/crc32c-masm.asm)\n    else()\n        enable_language(ASM)\n        set(UBTRFS_SRC_FILES ${UBTRFS_SRC_FILES} src/crc32c-gas.S)\n    endif()\nendif()\n\nconfigure_file(src/ubtrfs/ubtrfs.rc.in ubtrfs.rc)\n\nadd_library(ubtrfs SHARED ${UBTRFS_SRC_FILES})\n\nif(MSVC)\n    set_property(TARGET ubtrfs PROPERTY MSVC_RUNTIME_LIBRARY \"MultiThreaded$<$<CONFIG:Debug>:Debug>\")\nendif()\n\ntarget_compile_definitions(ubtrfs PUBLIC _USRDLL)\ntarget_link_libraries(ubtrfs ntdll advapi32)\ntarget_link_libraries(ubtrfs zstd)\n\nif (CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n    target_compile_options(ubtrfs PUBLIC -Wno-pragma-pack) # ignore warning in mingw headers\nendif()\n\nif(MSVC AND CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86\")\n    target_compile_options(ubtrfs PUBLIC /Gz) # stdcall\nendif()\n\nif(NOT MSVC)\n    target_compile_options(ubtrfs PUBLIC -Werror-implicit-function-declaration)\n    target_link_options(ubtrfs PUBLIC -static -static-libgcc -static-libstdc++)\nendif()\n\nset_target_properties(ubtrfs PROPERTIES PREFIX \"\")\n\n# --------------------------------------\n\n# mkbtrfs.exe\n\nset(MKBTRFS_SRC_FILES src/mkbtrfs/mkbtrfs.c\n    ${CMAKE_CURRENT_BINARY_DIR}/mkbtrfs.rc)\n\nconfigure_file(src/mkbtrfs/mkbtrfs.rc.in mkbtrfs.rc)\n\nadd_executable(mkbtrfs ${MKBTRFS_SRC_FILES})\n\nif(MSVC)\n    set_property(TARGET mkbtrfs PROPERTY MSVC_RUNTIME_LIBRARY \"MultiThreaded$<$<CONFIG:Debug>:Debug>\")\nelse()\n    target_link_options(mkbtrfs PUBLIC -static -static-libgcc)\nendif()\n\n# --------------------------------------\n\n# test.exe\n\nif(WITH_TEST)\n    set(CMAKE_CXX_STANDARD 20)\n    set(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n    configure_file(src/tests/test.rc.in test.rc)\n\n    set(TEST_SRC_FILES src/tests/test.cpp\n        ${CMAKE_CURRENT_BINARY_DIR}/test.rc\n        src/tests/create.cpp\n        src/tests/supersede.cpp\n        src/tests/overwrite.cpp\n        src/tests/io.cpp\n        src/tests/mmap.cpp\n        src/tests/rename.cpp\n        src/tests/delete.cpp\n        src/tests/links.cpp\n        src/tests/oplock.cpp\n        src/tests/cs.cpp\n        src/tests/reparse.cpp\n        src/tests/streams.cpp\n        src/tests/ea.cpp\n        src/tests/fileinfo.cpp\n        src/tests/security.cpp)\n\n    add_executable(test ${TEST_SRC_FILES})\n\n    if(MSVC)\n        set_property(TARGET test PROPERTY MSVC_RUNTIME_LIBRARY \"MultiThreaded$<$<CONFIG:Debug>:Debug>\")\n    else()\n        target_link_options(test PUBLIC -static -static-libgcc -municode)\n        target_compile_options(test PUBLIC -Wall -Wno-expansion-to-defined -Wunused-parameter -Wtype-limits -Wextra)\n    endif()\n\n    target_link_libraries(test ntdll version advapi32)\nendif()\n\n# --------------------------------------\n\n# install\n\ninstall(TARGETS btrfs DESTINATION bin)\ninstall(TARGETS shellbtrfs DESTINATION bin)\ninstall(TARGETS ubtrfs DESTINATION bin)\ninstall(TARGETS mkbtrfs DESTINATION bin)\n"
        },
        {
          "name": "CMakeSettings.json",
          "type": "blob",
          "size": 3.08984375,
          "content": "﻿{\n  \"configurations\": [\n    {\n      \"name\": \"x64-Debug\",\n      \"generator\": \"Ninja\",\n      \"configurationType\": \"Debug\",\n      \"buildRoot\": \"${projectDir}\\\\out\\\\build\\\\${name}\",\n      \"installRoot\": \"${projectDir}\\\\out\\\\install\\\\${name}\",\n      \"cmakeCommandArgs\": \"\",\n      \"buildCommandArgs\": \"-v\",\n      \"ctestCommandArgs\": \"\",\n      \"inheritEnvironments\": [ \"msvc_x64_x64\" ],\n      \"variables\": []\n    },\n    {\n      \"name\": \"x86-Debug\",\n      \"generator\": \"Ninja\",\n      \"configurationType\": \"Debug\",\n      \"buildRoot\": \"${projectDir}\\\\out\\\\build\\\\${name}\",\n      \"installRoot\": \"${projectDir}\\\\out\\\\install\\\\${name}\",\n      \"cmakeCommandArgs\": \"\",\n      \"buildCommandArgs\": \"-v\",\n      \"ctestCommandArgs\": \"\",\n      \"inheritEnvironments\": [ \"msvc_x86_x64\" ],\n      \"variables\": []\n    },\n    {\n      \"name\": \"arm-Debug\",\n      \"generator\": \"Ninja\",\n      \"configurationType\": \"Debug\",\n      \"buildRoot\": \"${projectDir}\\\\out\\\\build\\\\${name}\",\n      \"installRoot\": \"${projectDir}\\\\out\\\\install\\\\${name}\",\n      \"cmakeCommandArgs\": \"\",\n      \"buildCommandArgs\": \"-v\",\n      \"ctestCommandArgs\": \"\",\n      \"inheritEnvironments\": [ \"msvc_arm_x64\" ],\n      \"variables\": []\n    },\n    {\n      \"name\": \"arm64-Debug\",\n      \"generator\": \"Ninja\",\n      \"configurationType\": \"Debug\",\n      \"buildRoot\": \"${projectDir}\\\\out\\\\build\\\\${name}\",\n      \"installRoot\": \"${projectDir}\\\\out\\\\install\\\\${name}\",\n      \"cmakeCommandArgs\": \"\",\n      \"buildCommandArgs\": \"-v\",\n      \"ctestCommandArgs\": \"\",\n      \"inheritEnvironments\": [ \"msvc_arm64_x64\" ],\n      \"variables\": []\n    },\n    {\n      \"name\": \"x64-Release\",\n      \"generator\": \"Ninja\",\n      \"configurationType\": \"RelWithDebInfo\",\n      \"buildRoot\": \"${projectDir}\\\\out\\\\build\\\\${name}\",\n      \"installRoot\": \"${projectDir}\\\\out\\\\install\\\\${name}\",\n      \"cmakeCommandArgs\": \"\",\n      \"buildCommandArgs\": \"-v\",\n      \"ctestCommandArgs\": \"\",\n      \"inheritEnvironments\": [ \"msvc_x64_x64\" ],\n      \"variables\": []\n    },\n    {\n      \"name\": \"x86-Release\",\n      \"generator\": \"Ninja\",\n      \"configurationType\": \"RelWithDebInfo\",\n      \"buildRoot\": \"${projectDir}\\\\out\\\\build\\\\${name}\",\n      \"installRoot\": \"${projectDir}\\\\out\\\\install\\\\${name}\",\n      \"cmakeCommandArgs\": \"\",\n      \"buildCommandArgs\": \"-v\",\n      \"ctestCommandArgs\": \"\",\n      \"inheritEnvironments\": [ \"msvc_x86_x64\" ],\n      \"variables\": []\n    },\n    {\n      \"name\": \"arm-Release\",\n      \"generator\": \"Ninja\",\n      \"configurationType\": \"RelWithDebInfo\",\n      \"buildRoot\": \"${projectDir}\\\\out\\\\build\\\\${name}\",\n      \"installRoot\": \"${projectDir}\\\\out\\\\install\\\\${name}\",\n      \"cmakeCommandArgs\": \"\",\n      \"buildCommandArgs\": \"-v\",\n      \"ctestCommandArgs\": \"\",\n      \"inheritEnvironments\": [ \"msvc_arm_x64\" ],\n      \"variables\": []\n    },\n    {\n      \"name\": \"arm64-Release\",\n      \"generator\": \"Ninja\",\n      \"configurationType\": \"RelWithDebInfo\",\n      \"buildRoot\": \"${projectDir}\\\\out\\\\build\\\\${name}\",\n      \"installRoot\": \"${projectDir}\\\\out\\\\install\\\\${name}\",\n      \"cmakeCommandArgs\": \"\",\n      \"buildCommandArgs\": \"-v\",\n      \"ctestCommandArgs\": \"\",\n      \"inheritEnvironments\": [ \"msvc_arm64_x64\" ],\n      \"variables\": []\n    }\n  ]\n}\n"
        },
        {
          "name": "LICENCE",
          "type": "blob",
          "size": 7.4716796875,
          "content": "                   GNU LESSER GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\n  This version of the GNU Lesser General Public License incorporates\nthe terms and conditions of version 3 of the GNU General Public\nLicense, supplemented by the additional permissions listed below.\n\n  0. Additional Definitions.\n\n  As used herein, \"this License\" refers to version 3 of the GNU Lesser\nGeneral Public License, and the \"GNU GPL\" refers to version 3 of the GNU\nGeneral Public License.\n\n  \"The Library\" refers to a covered work governed by this License,\nother than an Application or a Combined Work as defined below.\n\n  An \"Application\" is any work that makes use of an interface provided\nby the Library, but which is not otherwise based on the Library.\nDefining a subclass of a class defined by the Library is deemed a mode\nof using an interface provided by the Library.\n\n  A \"Combined Work\" is a work produced by combining or linking an\nApplication with the Library.  The particular version of the Library\nwith which the Combined Work was made is also called the \"Linked\nVersion\".\n\n  The \"Minimal Corresponding Source\" for a Combined Work means the\nCorresponding Source for the Combined Work, excluding any source code\nfor portions of the Combined Work that, considered in isolation, are\nbased on the Application, and not on the Linked Version.\n\n  The \"Corresponding Application Code\" for a Combined Work means the\nobject code and/or source code for the Application, including any data\nand utility programs needed for reproducing the Combined Work from the\nApplication, but excluding the System Libraries of the Combined Work.\n\n  1. Exception to Section 3 of the GNU GPL.\n\n  You may convey a covered work under sections 3 and 4 of this License\nwithout being bound by section 3 of the GNU GPL.\n\n  2. Conveying Modified Versions.\n\n  If you modify a copy of the Library, and, in your modifications, a\nfacility refers to a function or data to be supplied by an Application\nthat uses the facility (other than as an argument passed when the\nfacility is invoked), then you may convey a copy of the modified\nversion:\n\n   a) under this License, provided that you make a good faith effort to\n   ensure that, in the event an Application does not supply the\n   function or data, the facility still operates, and performs\n   whatever part of its purpose remains meaningful, or\n\n   b) under the GNU GPL, with none of the additional permissions of\n   this License applicable to that copy.\n\n  3. Object Code Incorporating Material from Library Header Files.\n\n  The object code form of an Application may incorporate material from\na header file that is part of the Library.  You may convey such object\ncode under terms of your choice, provided that, if the incorporated\nmaterial is not limited to numerical parameters, data structure\nlayouts and accessors, or small macros, inline functions and templates\n(ten or fewer lines in length), you do both of the following:\n\n   a) Give prominent notice with each copy of the object code that the\n   Library is used in it and that the Library and its use are\n   covered by this License.\n\n   b) Accompany the object code with a copy of the GNU GPL and this license\n   document.\n\n  4. Combined Works.\n\n  You may convey a Combined Work under terms of your choice that,\ntaken together, effectively do not restrict modification of the\nportions of the Library contained in the Combined Work and reverse\nengineering for debugging such modifications, if you also do each of\nthe following:\n\n   a) Give prominent notice with each copy of the Combined Work that\n   the Library is used in it and that the Library and its use are\n   covered by this License.\n\n   b) Accompany the Combined Work with a copy of the GNU GPL and this license\n   document.\n\n   c) For a Combined Work that displays copyright notices during\n   execution, include the copyright notice for the Library among\n   these notices, as well as a reference directing the user to the\n   copies of the GNU GPL and this license document.\n\n   d) Do one of the following:\n\n       0) Convey the Minimal Corresponding Source under the terms of this\n       License, and the Corresponding Application Code in a form\n       suitable for, and under terms that permit, the user to\n       recombine or relink the Application with a modified version of\n       the Linked Version to produce a modified Combined Work, in the\n       manner specified by section 6 of the GNU GPL for conveying\n       Corresponding Source.\n\n       1) Use a suitable shared library mechanism for linking with the\n       Library.  A suitable mechanism is one that (a) uses at run time\n       a copy of the Library already present on the user's computer\n       system, and (b) will operate properly with a modified version\n       of the Library that is interface-compatible with the Linked\n       Version.\n\n   e) Provide Installation Information, but only if you would otherwise\n   be required to provide such information under section 6 of the\n   GNU GPL, and only to the extent that such information is\n   necessary to install and execute a modified version of the\n   Combined Work produced by recombining or relinking the\n   Application with a modified version of the Linked Version. (If\n   you use option 4d0, the Installation Information must accompany\n   the Minimal Corresponding Source and Corresponding Application\n   Code. If you use option 4d1, you must provide the Installation\n   Information in the manner specified by section 6 of the GNU GPL\n   for conveying Corresponding Source.)\n\n  5. Combined Libraries.\n\n  You may place library facilities that are a work based on the\nLibrary side by side in a single library together with other library\nfacilities that are not Applications and are not covered by this\nLicense, and convey such a combined library under terms of your\nchoice, if you do both of the following:\n\n   a) Accompany the combined library with a copy of the same work based\n   on the Library, uncombined with any other library facilities,\n   conveyed under the terms of this License.\n\n   b) Give prominent notice with the combined library that part of it\n   is a work based on the Library, and explaining where to find the\n   accompanying uncombined form of the same work.\n\n  6. Revised Versions of the GNU Lesser General Public License.\n\n  The Free Software Foundation may publish revised and/or new versions\nof the GNU Lesser General Public License from time to time. Such new\nversions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\n  Each version is given a distinguishing version number. If the\nLibrary as you received it specifies that a certain numbered version\nof the GNU Lesser General Public License \"or any later version\"\napplies to it, you have the option of following the terms and\nconditions either of that published version or of any later version\npublished by the Free Software Foundation. If the Library as you\nreceived it does not specify a version number of the GNU Lesser\nGeneral Public License, you may choose any version of the GNU Lesser\nGeneral Public License ever published by the Free Software Foundation.\n\n  If the Library as you received it specifies that a proxy can decide\nwhether future versions of the GNU Lesser General Public License shall\napply, that proxy's public statement of acceptance of any version is\npermanent authorization for you to choose that version for the\nLibrary.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 28.9658203125,
          "content": "WinBtrfs v1.9\n-------------\n\nWinBtrfs is a Windows driver for the next-generation Linux filesystem Btrfs.\nA reimplementation from scratch, it contains no code from the Linux kernel,\nand should work on any version from Windows XP onwards. It is also included\nas part of the free operating system [ReactOS](https://www.reactos.org/).\n\nIf your Btrfs filesystem is on a MD software RAID device created by Linux, you\nwill also need [WinMD](https://github.com/maharmstone/winmd) to get this to appear\nunder Windows.\n\nSee also [Quibble](https://github.com/maharmstone/quibble), an experimental\nbootloader allowing Windows to boot from Btrfs, and [Ntfs2btrfs](https://github.com/maharmstone/ntfs2btrfs),\na tool which allows in-place conversion of NTFS filesystems.\n\nFirst, a disclaimer:\n\nYou use this software at your own risk. I take no responsibility for any damage\nit may do to your filesystem. It ought to be suitable for day-to-day use, but\nmake sure you take backups anyway.\n\nEverything here is released under the GNU Lesser General Public Licence (LGPL);\nsee the file LICENCE for more info. You are encouraged to play about with the\nsource code as you will, and I'd appreciate a note (mark@harmstone.com) if you\ncome up with anything nifty.\n\nSee at the end of this document for copyright details of third-party code that's\nincluded here.\n\nFeatures\n--------\n\n* Reading and writing of Btrfs filesystems\n* Basic RAID: RAID0, RAID1, and RAID10\n* Advanced RAID: RAID5 and RAID6\n* Caching\n* Discovery of Btrfs partitions, even if Windows would normally ignore them\n* Getting and setting of Access Control Lists (ACLs), using the xattr\n  security.NTACL\n* Alternate Data Streams (e.g. :Zone.Identifier is stored as the xattr\n  user.Zone.Identifier)\n* Mappings from Linux users to Windows ones (see below)\n* Symlinks and other reparse points\n* Shell extension to identify and create subvolumes, including snapshots\n* Hard links\n* Sparse files\n* Free-space cache\n* Preallocation\n* Asynchronous reading and writing\n* Partition-less Btrfs volumes\n* Per-volume registry mount options (see below)\n* zlib compression\n* LZO compression\n* LXSS (\"Ubuntu on Windows\") support\n* Balancing (including resuming balances started on Linux)\n* Device addition and removal\n* Creation of new filesystems with `mkbtrfs.exe` and `ubtrfs.dll`\n* Scrubbing\n* TRIM/DISCARD\n* Reflink copy\n* Subvol send and receive\n* Degraded mounts\n* Free space tree (compat_ro flag `free_space_cache`)\n* Shrinking and expanding\n* Passthrough of permissions etc. for LXSS\n* Zstd compression\n* Windows 10 case-sensitive directory flag\n* Oplocks\n* Metadata UUID incompat flag (Linux 5.0)\n* Three- and four-disk RAID1 (Linux 5.5)\n* New checksum types (xxhash, sha256, blake2) (Linux 5.5)\n* Block group tree (Linux 6.1)\n\nTodo\n----\n\n* Full fs-verity support (Linux 5.15)\n* Zoned support (Linux 5.11) (HM-SMR not supported on Windows?)\n* Defragmentation\n* Support for Btrfs quotas\n* Full transaction log support\n* Support for Windows transactions (TxF)\n\nInstallation\n------------\n\nTo install the driver, [download and extract the latest release](https://github.com/maharmstone/btrfs/releases),\nright-click btrfs.inf, and choose Install. The driver is signed, so should work out\nof the box on modern versions of Windows.\n\nIf you using Windows 10 or 11 and have Secure Boot enabled, you may have to make a Registry\nchange in order for the driver to be loaded - see [below](#secureboot). It's easier though\njust to turn off Secure Boot in your BIOS, unless you have a particular need for it. Bear in\nmind that Windows 11 soft-requires Secure Boot to be installed, but will work fine afterwords\nwith it turned off.\n\nWinBtrfs is also available on the following package managers:\n\n* [Chocolatey](https://chocolatey.org/packages/winbtrfs)\n```\nchoco install winbtrfs\n```\n* [Scoop](https://scoop.sh/#/apps?q=%22winbtrfs-np%22&s=0&d=1&o=true)\n```\nscoop bucket add nonportable\nscoop install winbtrfs-np -g\n```\n\nUninstalling\n------------\n\nIf you want to uninstall, from a command prompt run:\n\n```\nRUNDLL32.EXE SETUPAPI.DLL,InstallHinfSection DefaultUninstall 132 btrfs.inf\n```\n\nYou may need to give the full path to btrfs.inf.\n\nYou can also go to Device Manager, find \"Btrfs controller\" under\n\"Storage volumes\", right click and choose \"Uninstall\". Tick the checkbox to\nuninstall the driver as well, and let Windows reboot itself.\n\nIf you need to uninstall via the registry, open regedit and set the value of\nHKLM\\SYSTEM\\CurrentControlSet\\services\\btrfs\\Start to 4, to disable the service.\nAfter you reboot, you can then delete the btrfs key and remove\nC:\\Windows\\System32\\drivers\\btrfs.sys.\n\nCompilation\n-----------\n\nTo compile with Visual C++ 2019, open the directory and let CMake do its thing.\nIf you have the Windows DDK installed correctly, it should just work.\n\nTo compile with GCC on Linux, you will need a cross-compiler set up, for either\n`i686-w64-mingw32` or `x86_64-w64-mingw32`. Create a build directory, then use\neither `mingw-x86.cmake` or `mingw-amd64.cmake` as CMake toolchain files to\ngenerate your Makefile.\n\nMappings\n--------\n\nThe user mappings are stored in the registry key\nHKLM\\SYSTEM\\CurrentControlSet\\services\\btrfs\\Mappings. Create a DWORD with the\nname of your Windows SID (e.g. S-1-5-21-1379886684-2432464051-424789967-1001),\nand the value of your Linux uid (e.g. 1000). It will take effect next time the\ndriver is loaded.\n\nYou can find your current SID by running `wmic useraccount get name,sid`.\n\nSimilarly, the group mappings are stored in under GroupMappings. The default\nentry maps Windows' Users group to gid 100, which is usually \"users\" on Linux.\nYou can also specify user SIDs here to force files created by a user to belong\nto a certain group. The setgid flag also works as on Linux.\n\nNote that processes running under User Access Control tokens create files as\nthe BUILTIN\\Administrators SID (S-1-5-32-544), rather as a user account.\n\nLXSS (\"Ubuntu on Windows\" / \"Windows Subsystem for Linux\")\n----------------------------------------------------------\n\nThe driver will passthrough Linux metadata to recent versions of LXSS, but you\nwill have to let Windows know that you wish to do this. From a Bash prompt on\nWindows, edit `/etc/wsl.conf` to look like the following:\n\n```\n[automount]\nenabled = true\noptions = \"metadata\"\nmountFsTab = false\n```\n\nIt will then take effect next time you reboot. Yes, you should be able to chroot\ninto an actual Linux installation, if you wish.\n\nCommands\n--------\n\nThe DLL file shellbtrfs.dll provides the GUI interface, but it can also be used\nwith rundll32.exe to carry out some tasks from the command line, which may be\nuseful if you wish to schedule something to run periodically.\n\nBear in mind that rundll32 provides no mechanism to return any error codes, so\nany of these commands may fail silently.\n\n* `rundll32.exe shellbtrfs.dll,CreateSubvol <path>`\n\n* `rundll32.exe shellbtrfs.dll,CreateSnapshot <source> <destination>`\n\n* `rundll32.exe shellbtrfs.dll,ReflinkCopy <source> <destination>`\nThis also accepts wildcards, and any number of source files.\n\nThe following commands need various privileges, and so must be run as Administrator\nto work:\n\n* `rundll32.exe shellbtrfs.dll,SendSubvol <source> [-p <parent>] [-c <clone subvol>] <stream file>`\nThe -p and -c flags are as `btrfs send` on Linux. You can specify any number of\nclone subvolumes.\n\n* `rundll32.exe shellbtrfs.dll,RecvSubvol <stream file> <destination>`\n\n* `rundll32.exe shellbtrfs.dll,StartScrub <drive>`\n\n* `rundll32.exe shellbtrfs.dll,StopScrub <drive>`\n\nTroubleshooting\n---------------\n\n* How do I debug this?\n\nOn the releases page, there's zip files to download containing the PDBs. Or you\ncan try the symbols server http://symbols.burntcomma.com/ - in windbg, set your\nsymbol path to something like this:\n\n```symsrv*symsrv.dll*C:\\symbols*http://msdl.microsoft.com/download/symbols;symsrv*symsrv.dll*C:\\symbols*http://symbols.burntcomma.com```\n\n* The filenames are weird!\nor\n* I get strange errors on certain files or directories!\n\nThe driver assumes that all filenames are encoded in UTF-8. This should be the\ndefault on most setups nowadays - if you're not using UTF-8, it's probably worth\nlooking into converting your files.\n\n* <a name=\"secureboot\"></a>How do I get this working with Secure Boot turned on?\n\nFor the later versions of Windows 10, Microsoft introduced more onerous\nrequirements for signing, which seemingly aren't available for open-source drivers.\n\nTo work around this, go to `HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\CI\\Policy` in Regedit,\ncreate a new DWORD value called `UpgradedSystem` and set to 1, and reboot.\n\nOr you could always just turn off Secure Boot in your BIOS settings.\n\n* The root of the drive isn't case-sensitive in LXSS\n\nThis is something Microsoft hardcoded into LXSS, presumably to stop people hosing\ntheir systems by running `mkdir /mnt/c/WiNdOwS`.\n\n* How do I change the drive letter?\n\nWith the shell extension installed, right-click the drive in Explorer, click Properties,\nand go to the Btrfs tab. There should be a button which allows you to change the drive\nletter.\n\n* I'm still having problems with drive letters\n\nIn Regedit, try deleting the relevant entries in `HKEY_LOCAL_MACHINE\\SYSTEM\\MountedDevices`,\nthen rebooting.\n\n* How do I format a partition as Btrfs?\n\nUse the included command line program mkbtrfs.exe. We can't add Btrfs to Windows' own\ndialog box, unfortunately, as its list of filesystems has been hardcoded. You can also\nrun `format /fs:btrfs`, if you don't need to set any Btrfs-specific options.\n\n* I can't reformat a mounted Btrfs filesystem\n\nIf Windows' Format dialog box refuses to appear, try running format.com with the /fs\nflag, e.g. `format /fs:ntfs D:`.\n\n* I can't mount a Synology NAS\n\nSynology seems to use LVM for its block devices. Until somebody writes an LVM driver\nfor Windows, you're out of luck.\n\n* I can't mount a Thecus NAS\n\nThecus uses Linux's MD raid for its block devices. You will need to install [WinMD](https://github.com/maharmstone/winmd)\nas well.\n\n* 64-bit Windows 7 won't load the driver\n\nMake sure that you have [KB3033929](https://www.microsoft.com/en-gb/download/details.aspx?id=46148) installed.\nOr consider installing from an \"escrow\" ISO which includes all updates.\n\n* The drive doesn't show up and Paragon software has been installed\n\nParagon's filesystem-reading software is known to disable automount. Disable or\nuninstall Paragon, then re-enable automount by running `diskpart` and typing\n`automount enable`.\n\n* The drive doesn't show up on very old versions of Windows\n\nOn very old versions of Windows (XP, Server 2003?), Windows ignores Linux partitions\nentirely. If this is the case for you, try running `fdisk` on Linux and changing your\npartition type from 83 to 7.\n\n* I can edit files on Windows that I shouldn't be able to\n\nThere's no mapping between Windows and POSIX permission models, they're too\ndifferent for this to be practical. If this bothers you, you can create a\nWindows ACL on files that you don't want to be able to edit.\n\nChangelog\n---------\n\nv1.9 (2024-03-15):\n* Added support for block group tree (Linux 6.1)\n* Fixed hang when system under heavy load\n* Added /blockgrouptree and /freespacetree options to mkbtrfs\n* Follow Linux in defaulting /noholes to on in mkbtrfs\n* Added support for CRC32C instructions on aarch64\n\nv1.8.2 (2023-01-10):\n* Fixed UAC not working\n* Fixed Smartlocker crash on Windows 11 22H2\n* Rejigged INF file to work better on Windows 11\n* Files now signed with SHA256 hash rather than SHA1\n\nv1.8.1 (2022-08-23):\n* Fixed use-after-free when flushing\n* Fixed crash when opening volume when AppLocker installed\n* Compression now disabled for no-COW files, as on Linux\n* Flushing now scales better on very fast drives\n* Fixed small files getting padded to 4,096 bytes by lazy writer\n* Added NoDataCOW registry option\n\nv1.8 (2022-03-12):\n* Added minimal support for fs-verity\n* Added test suite\n* Fixed incorrect disk usage statistics\n* Fixed potential crashes when renaming stream to file or file to stream\n* Fixed potential crashes when querying hard links on file\n* Fixed potential hang when opening oplocked file\n* Fixed minor issues also uncovered by test suite\n\nv1.7.9 (2021-10-02):\n* Fixed deadlock when mounting on Windows 11\n* Added support for BitLocker-encrypted volumes\n* Improved filename checks when renaming or creating hard links\n* Miscellaneous bug fixes\n\nv1.7.8.1 (2021-06-13):\n* Fixed bug preventing new directories from appearing in listings\n* Fixed Release version of driver still not working on XP\n\nv1.7.8 (2021-06-09):\n* Upgraded zstd to version 1.5.0\n* Fixed regression stopping driver from working under XP\n* Fixed compilation on clang\n* Fixed corruption issue when Linux mount option `inode_cache` had been used\n* Fixed recursion issue involving virtual directory \\\\$Root\n\nv1.7.7 (2021-04-12):\n* Fixed deadlock on high load\n* Fixed free space issue when installing Genshin Impact\n* Fixed issue when copying files with wildcards in command prompt\n* Increased speed of directory lookups\n\nv1.7.6 (2021-01-14):\n* Fixed race condition when booting with Quibble\n* No longer need to restart Windows after initial installation\n* Forced maximum file name to 255 UTF-8 characters, to match Linux driver\n* Fixed issue where directories could be created with trailing backslash\n* Fixed potential deadlock when Windows calls NtCreateSection during flush\n* Miscellaneous bug fixes\n\nv1.7.5 (2020-10-31):\n* Fixed text display issue in shell extension\n* Added support for mingw 8\n* Fixed LXSS permissions not working in new versions of Windows\n* Fixed issue where truncating an inline file wouldn't change its size\n* Fixed crash with Quibble where driver would try to use AVX2 before Windows had enabled it\n\nv1.7.4 (2020-08-23):\n* Fixed issue when running compressed EXEs\n* Changed build system to cmake\n* Upgraded zstd to version 1.4.5\n* Added support for FSCTL_GET_RETRIEVAL_POINTERS\n* Miscellaneous bug fixes\n\nv1.7.3 (2020-05-24):\n* Fixed crash when sending file change notifications\n* Improved symlink handling with LXSS\n* Added support for undocumented flag SL_IGNORE_READONLY_ATTRIBUTE\n* Fixed corruption caused by edge case, where address allocated and freed in same flush\n* Improved handling of free space tree\n* Improved handling of very full volumes\n* Fixed spurious warnings raised by GCC 10 static analyser\n* Replaced multiplications and divisions with bit shift operations where appropriate\n* Fixed combobox stylings in shell extension\n\nv1.7.2 (2020-04-10):\n* Added more fixes for booting from Btrfs on Windows 10\n* Fixed occasional deadlock when deleting or closing files on Windows 10 1909\n* Fixed crash when reading large ADSes\n* Fixed occasional crash when writing files on RAID5/6\n* Miscellaneous bug fixes\n\nv1.7.1 (2020-03-02):\n* Fixed crash when reading beyond end of file\n* Fixed spurious checksum errors when doing unaligned read\n\nv1.7 (2020-02-26):\n* Added support for metadata_uuid incompat flag (Linux 5.0)\n* Added support for three- and four-disk RAID1 (Linux 5.5)\n* Added support for new checksum types: xxhash, sha256, blake2 (Linux 5.5)\n* Greatly increased checksumming speed\n* Greatly increased compression and decompression speed\n* Fixed bug causing incorrect free-space reporting when data is DUP\n* Fixed issue creating directories on LXSS when `case=dir` option set\n\nv1.6 (2020-02-04):\n* Added experimental (i.e. untested) ARM support (thanks to [DjArt](https://github.com/DjArt) for this)\n* Added fixes for booting from Btrfs on Windows 10\n* Volumes will now get remounted if changed while Windows is asleep or hibernating\n* Fixed corruption when mounting volume that hasn't been unmounted cleanly by Linux\n* Fixed crash when deleting subvolume\n\nv1.5 (2019-11-10):\n* More fixes for booting from Btrfs\n* Added virtual $Root directory (see \"NoRootDir\" below)\n* Added support for Windows XP\n* Added support for renaming alternative data streams\n* Added oplock support\n* Fixed potential deadlock on boot\n* Fixed possible crash on shutdown\n* Fixed a bunch of memory leaks\n* Many other miscellaneous bug fixes\n\nv1.4 (2019-08-31):\n* Added fragmentation percentage to property sheet\n* Added support for Windows Server 2003 and Windows Vista\n* Added pagefile support\n* Improved support for file locking\n* Added support for booting from Btrfs on Windows Server 2003 (see https://www.youtube.com/watch?v=-5E2CHmHEUs)\n* Fixed issue where driver could open same inode twice\n* Other miscellaneous bug fixes\n\nv1.3 (2019-06-10):\n* Added support for new rename and delete functions introduced to Windows 10\n* Added support for Windows 10's flag for case-sensitive directories\n* Changed free-space calculation method to be more like that of the Linux driver\n* Added more support for 128-bit file IDs\n* Fixed bug causing outdated root items\n* Fixed bug preventing writing to VHDs\n\nv1.2.1 (2019-05-06):\n* Reverted commit affecting the creation of streams\n\nv1.2 (2019-05-05):\n* Dramatic speed increase when opening many small files, such as with a Git repository\n* Fixed crash on surprise removals of removable devices\n* Added ability to change drive letters easily\n* No longer creates free-space cache for very small chunks, so as not to confuse the Linux driver\n* Fixed corruption when very large file created and then immediately deleted\n* Minor bug fixes\n\nv1.1 (2018-12-15):\n* Support for Zstd compression\n* Passthrough of Linux metadata to LXSS\n* Refactored shell extension\n* Fixed memory leaks\n* Many other bug fixes\n\nv1.0.2 (2018-05-19):\n* Minor bug fixes\n\nv1.0.1 (2017-10-15):\n* Fixed deadlock\n* Binaries now signed\n* Minor bug fixes\n\nv1.0 (2017-09-04):\n* First non-beta release!\n* Degraded mounts\n* New free space cache (compat_ro flag `free_space_cache`)\n* Shrinking and expanding of volumes\n* Registry options now re-read when changed, rather than just on startup\n* Improved balancing on very full filesystems\n* Fixed problem preventing user profile directory being stored on btrfs on Windows 8 and above\n* Better Plug and Play support\n* Miscellaneous bug fixes\n\nv0.10 (2017-05-02):\n* Reflink copy\n* Sending and receiving subvolumes\n* Group mappings (see Mappings section above)\n* Added commands for scripting etc. (see Commands section above)\n* Fixed an issue preventing mounting on non-PNP devices, such as VeraCrypt\n* Fixed an issue preventing new versions of LXSS from working\n* Fixed problem with the ordering of extent refs, which caused problems on Linux but wasn't picked up by `btrfs check`\n* Added support for reading compressed inline extents\n* Many miscellaneous bug fixes\n\nv0.9 (2017-03-05):\n* Scrubbing\n* TRIM/DISCARD\n* Better handling of multi-device volumes\n* Performance increases when reading from RAID filesystems\n* No longer lies about being NTFS, except when it has to\n* Volumes will now go readonly if there is an unrecoverable error, rather than blue-screening\n* Filesystems can now be created with Windows' inbuilt format.com\n* Zlib upgraded to version 1.2.11\n* Miscellaneous performance increases\n* Miscellaneous bug fixes\n\nv0.8 (2016-12-30):\n* Volume property sheet, for:\n * Balances\n * Adding and removing devices\n * Showing disk usage, i.e. the equivalent to `btrfs fi usage`\n* Checksums now calculated in parallel where appropriate\n* Creation of new filesystems, with mkbtrfs.exe\n* Plug and play support for RAID devices\n* Disk usage now correctly allocated to processes in taskmgr\n* Performance increases\n* Miscellaneous bug fixes\n\nv0.7 (2016-10-24):\n* Support for RAID5/6 (incompat flag `raid56`)\n* Seeding support\n* LXSS (\"Ubuntu on Windows\") support\n* Support for Windows Extended Attributes\n* Improved removable device support\n* Better snapshot support\n* Recovery from RAID checksum errors\n* Fixed issue where creating a lot of new files was taking a long time\n* Miscellaneous speed increases and bug fixes\n\nv0.6 (2016-08-21):\n* Compression support (both zlib and lzo)\n* Mixed groups support\n* No-holes support\n* Added inode property sheet to shell extension\n* Many more mount options (see below)\n* Better support for removable devices\n* Page file support\n* Many miscellaneous bug fixes\n\nv0.5 (2016-07-24):\n* Massive speed increases (from \"sluggish\" to \"blistering\")\n* Massive stability improvements\n* RAID support: RAID0, RAID1, and RAID10\n* Asynchronous reading and writing\n* Partition-less Btrfs volumes\n* Windows sparse file support\n* Object ID support\n* Beginnings of per-volume mount options\n* Security improvements\n* Notification improvements\n* Miscellaneous bug fixes\n\nv0.4 (2016-05-02):\n* Subvolume creation and deletion\n* Snapshots\n* Preallocation\n* Reparse points\n* Hard links\n* Plug and play\n* Free-space cache\n* Fix problems preventing volume from being shared over the network\n* Miscellaneous bug fixes\n\nv0.3 (2016-03-25):\n* Bug fixes:\n * Fixed crashes when metadata blocks were SINGLE, such as on SSDs\n * Fixed crash when splitting an internal tree\n * Fixed tree traversal failing when first item in tree had been deleted\n * Fixed emptying out of whole tree (probably only relevant to checksum tree)\n * Fixed \"incorrect local backref count\" message appearing in `btrfs check`\n * Miscellaneous other fixes\n* Added beginnings of shell extension, which currently only changes the icon of subvolumes\n\nv0.2 (2016-03-13):\n* Bug fix release:\n * Check memory allocations succeed\n * Check tree items are the size we're expecting\n * Added rollbacks, so failed operations are completely undone\n * Fixed driver claiming all unrecognized partitions (thanks Pierre Schweitzer)\n * Fixed deadlock within `CcCopyRead`\n * Fixed changing properties of a JPEG within Explorer\n * Lie about FS type, so UAC works\n * Many, many miscellaneous bug fixes\n* Rudimentary security support\n* Debug log support (see below)\n\nv0.1 (2016-02-21):\n* Initial alpha release.\n\nDebug log\n---------\n\nWinBtrfs has three levels of debug messages: errors and FIXMEs, warnings, and traces.\nThe release version of the driver only displays the errors and FIXMEs, which it logs\nvia `DbgPrint`. You can view these messages via the Microsoft program DebugView, available\nat https://technet.microsoft.com/en-gb/sysinternals/debugview.\n\nIf you want to report a problem, it'd be of great help if you could also attach a full\ndebug log. To do this, you will need to use the debug versions of the drivers; copy the files\nin Debug\\x64 or Debug\\x86 into x64 or x86. You will also need to set the registry entries in\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\btrfs:\n\n* `DebugLogLevel` (DWORD): 0 for no messages, 1 for errors and FIXMEs, 2 for warnings also,\nand 3 for absolutely everything, including traces.\n* `LogDevice` (string, optional): the serial device you want to output to, such as\n`\\Device\\Serial0`. This is probably only useful on virtual machines.\n* `LogFile` (string, optional): the file you wish to output to, if `LogDevice` isn't set.\nBear in mind this is a kernel filename, so you'll have to prefix it with \"\\\\??\\\\\" (e.g.,\n\"\\\\??\\\\C:\\\\btrfs.log\"). It probably goes without saying, but don't store this on a volume the\ndriver itself is using, or you'll cause an infinite loop.\n\nMount options\n-------------\n\nThe driver will create subkeys in the registry under HKLM\\SYSTEM\\CurrentControlSet\\Services\\btrfs\nfor each mounted filesystem, named after its UUID. If you're unsure which UUID refers to which\nvolume, you can check using `btrfs fi show` on Linux. You can add per-volume mount options to this\nsubkey, which will take effect on reboot. If a value is set in the key above this, it will use this\nby default.\n\n* `Ignore` (DWORD): set this to 1 to tell the driver not to attempt loading this filesystem. With the\n`Readonly` flag, this is probably redundant.\n\n* `Readonly` (DWORD): set this to 1 to tell the driver not to allow writing to this volume. This is\nthe equivalent of the `ro` flag on Linux.\n\n* `Compress` (DWORD): set this to 1 to tell the driver to write files as compressed by default. This is\nthe equivalent of the `compress` flag on Linux.\n\n* `CompressForce` (DWORD): set this to 1 to force compression, i.e. to ignore the `nocompress` inode\nflag and even attempt compression of incompressible files. This isn't a good idea, but is the equivalent\nof the `compress-force` flag on Linux.\n\n* `CompressType` (DWORD): set this to 1 to prefer zlib compression, 2 to prefer lzo compression, or 3\nto prefer zstd compression. The default is 0, which uses zstd or lzo compression if the incompat flags\nare set, and zlib otherwise.\n\n* `FlushInterval` (DWORD): the interval in seconds between metadata flushes. The default is 30, as on Linux -\nthe parameter is called `commit` there.\n\n* `ZlibLevel` (DWORD): a number between -1 and 9, which determines how much CPU time is spent trying to\ncompress files. You might want to fiddle with this if you have a fast CPU but a slow disk, or vice versa.\nThe default is 3, which is the hard-coded value on Linux.\n\n* `MaxInline` (DWORD): the maximum size that will be allowed for \"inline\" files, i.e. those stored in the\nmetadata. The default is 2048, which is also the default on modern versions of Linux - the parameter is\ncalled `max_inline` there. It will be clipped to the maximum value, which unless you've changed your node\nsize will be a shade under 16 KB.\n\n* `SubvolId` (QWORD): the ID of the subvolume that we will attempt to mount as the root. If it doesn't\nexist, this parameter will be silently ignored. The subvolume ID can be found on the inode property\nsheet; it's in hex there, as opposed to decimal on the Linux tools. The default is whatever has been set\nvia `btrfs subvolume set-default`; or, failing that, subvolume 5. The equivalent parameter on Linux is\ncalled `subvolid`.\n\n* `SkipBalance` (DWORD): set to 1 to tell the driver not to attempt resuming a balance which was running\nwhen the system last powered down. The default is 0. The equivalent parameter on Linux is `skip_balance`.\n\n* `NoPNP` (DWORD): useful for debugging only, this forces any volumes to appear rather than exposing them\nvia the usual Plug and Play method.\n\n* `ZstdLevel` (DWORD): Zstd compression level, default 3.\n\n* `NoTrim` (DWORD): set this to 1 to disable TRIM support.\n\n* `AllowDegraded` (DWORD): set this to 1 to allow mounting a degraded volume, i.e. one with a device\nmissing. You are strongly advised not to enable this unless you need to.\n\n* `NoRootDir` (DWORD): if you have changed your default subvolume, either natively or by a registry option,\nthere will be a hidden directory called $Root which points to where the root would normally be. Set this\nvalue to 1 to prevent this appearing.\n\n* `NoDataCOW` (DWORD): set this to 1 to disable copy-on-write for new files. This is the equivalent of the\n`nodatacow` flag on Linux.\n\nContact\n-------\n\nI'd appreciate any feedback you might have, positive or negative:\nmark@harmstone.com.\n\nCopyright\n---------\n\nThis code contains portions of the following software:\n\n### Zlib\n\n  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n### LZO\n\nWinBtrfs contains portions of an early version of lzo, which is copyright 1996\nMarkus Oberhumer. Modern versions are licensed under the GPL, but this was\nlicensed under the LGPL, so I believe it is okay to use.\n\n### Zstd\n\nCopyright (c) 2016-present, Facebook, Inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n * Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n * Neither the name Facebook nor the names of its contributors may be used to\n   endorse or promote products derived from this software without specific\n   prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n### BLAKE2\n\n[https://github.com/BLAKE2/BLAKE2](https://github.com/BLAKE2/BLAKE2) (public domain)\n\n### SHA256\n\n[https://github.com/amosnier/sha-2](https://github.com/amosnier/sha-2) (public domain)\n"
        },
        {
          "name": "btrfs-dump.pl",
          "type": "blob",
          "size": 26.01953125,
          "content": "#!/usr/bin/perl\n\n# Quick and dirty btrfs tree dumper. Great for diff'ing, which btrfs-debug-tree isn't...\n# Do something like:\n#\n# qemu-nbd -r -n -c /dev/nbd0 ~/vms/win7/win7-32.img ; sleep 1 ; chmod 666 /dev/nbd0p3\n# ./btrfs-dump.pl /dev/nbd0p3 > dump2.txt\n# diff -u dump1.txt dump2.txt > diff2.txt\n\n# Like btrfs.h, I'm disclaiming any copyright on this file, but I'd appreciate\n# hearing about what you do with it: mark@harmstone.com.\n\nuse Data::Dumper;\nuse strict;\n\nif (scalar(@ARGV) < 1) {\n    my @dp=split(/\\//,$0);\n\n    print \"Usage: \".$dp[$#dp].\" [BLOCKDEVICE]\\n\";\n    exit;\n}\n\nmy %devs=();\nfor (my $i = 1; $i <= $#ARGV; $i++) {\n    my ($file,$sb);\n\n    open($file, $ARGV[$i]) || die \"Error opening \".$ARGV[$i].\": $!\";\n    binmode($file);\n\n    seek($file,0x10000,0);\n    read($file,$sb,0x1000);\n    my @b=unpack(\"Vx28A16QQA8QQQQQQQQQVVVVVQQQQvCCCA98A256QQx240a2048a672\",$sb);\n\n    if ($b[4] ne \"_BHRfS_M\") {\n        die $ARGV[$i].\": not Btrfs\";\n    }\n\n    my @di = unpack(\"QQQVVVQQQVCCA16A16\",$b[27]);\n    $devs{$di[0]}=$file;\n}\n\nmy ($f,$chunktree,$roottree,$logtree,$nodesize);\n\nopen($f,$ARGV[0]) || die \"Error opening \".$ARGV[0].\": $!\";\nbinmode($f);\n\nmy %roots=();\nmy %logroots=();\nmy @l2p=();\nmy @l2p_bs=();\nmy $csum_type;\n\nread_superblock($f);\n\nprint \"CHUNK: \\n\";\ndump_tree($chunktree, \"\", 1);\nprint \"\\n\";\n\nprint \"ROOT: \\n\";\ndump_tree($roottree, \"\", 0);\nprint \"\\n\";\n\nif ($logtree != 0) {\n    print \"LOG: \\n\";\n    dump_tree($logtree, \"\", 0);\n    print \"\\n\";\n}\n\nmy @rs=sort { $a <=> $b } (keys(%roots));\n\nforeach my $r (@rs) {\n\tprintf(\"Tree %x:\\n\",$r);\n\tdump_tree($roots{$r}, \"\");\n\tprint \"\\n\";\n}\n\nmy @lrs=sort { $a <=> $b } (keys(%logroots));\n\nforeach my $lr (@lrs) {\n\tprintf(\"Tree %x (log):\\n\",$lr);\n\tdump_tree($logroots{$lr}, \"\");\n\tprint \"\\n\";\n}\n\nclose($f);\n\nsub incompat_flags {\n    my ($f)=@_;\n    my @l;\n\n    if ($f & 0x1) {\n        push @l,\"mixed_backref\";\n        $f &= ~0x1;\n    }\n\n    if ($f & 0x2) {\n        push @l,\"default_subvol\";\n        $f &= ~0x2;\n    }\n\n    if ($f & 0x4) {\n        push @l,\"mixed_groups\";\n        $f &= ~0x4;\n    }\n\n    if ($f & 0x8) {\n        push @l,\"compress_lzo\";\n        $f &= ~0x8;\n    }\n\n    if ($f & 0x10) {\n        push @l,\"compress_zstd\";\n        $f &= ~0x10;\n    }\n\n    if ($f & 0x20) {\n        push @l,\"big_metadata\";\n        $f &= ~0x20;\n    }\n\n    if ($f & 0x40) {\n        push @l,\"extended_iref\";\n        $f &= ~0x40;\n    }\n\n    if ($f & 0x80) {\n        push @l,\"raid56\";\n        $f &= ~0x80;\n    }\n\n    if ($f & 0x100) {\n        push @l,\"skinny_metadata\";\n        $f &= ~0x100;\n    }\n\n    if ($f & 0x200) {\n        push @l,\"no_holes\";\n        $f &= ~0x200;\n    }\n\n    if ($f & 0x400) {\n        push @l,\"metadata_uuid\";\n        $f &= ~0x400;\n    }\n\n    if ($f & 0x800) {\n        push @l,\"raid1c34\";\n        $f &= ~0x800;\n    }\n\n    if ($f & 0x1000) {\n        push @l,\"zoned\";\n        $f &= ~0x1000;\n    }\n\n    if ($f & 0x2000) {\n        push @l,\"extent_tree_v2\";\n        $f &= ~0x2000;\n    }\n\n    if ($f & 0x4000) {\n        push @l,\"raid_stripe_tree\";\n        $f &= ~0x4000;\n    }\n\n    if ($f & 0x10000) {\n        push @l,\"squota\";\n        $f &= ~0x10000;\n    }\n\n    if ($f!=0 || $#l==-1) {\n        push @l,sprintf(\"%x\",$f);\n    }\n\n    return join(',',@l);\n}\n\nsub compat_ro_flags {\n    my ($f)=@_;\n    my @l;\n\n    if ($f&1) {\n        push @l,\"space_tree\";\n        $f&=~1;\n    }\n\n    if ($f&2) {\n        push @l,\"space_tree_valid\";\n        $f&=~2;\n    }\n\n    if ($f&4) {\n        push @l,\"verity\";\n        $f&=~4;\n    }\n\n    if ($f&8) {\n        push @l,\"block_group_tree\";\n        $f&=~8;\n    }\n\n    if ($f!=0 || $#l==-1) {\n        push @l,sprintf(\"%x\",$f);\n    }\n\n    return join(',',@l);\n}\n\nsub read_superblock {\n\tmy ($f)=@_;\n\tmy ($sb, @b, @b2, @di, $csum);\n\n\tseek($f,0x10000,0);\n\tread($f,$sb,0x1000);\n\t($roottree, $chunktree, $logtree)=unpack(\"x80QQQ\",$sb);\n\t@b = unpack(\"A32A16QQA8QQQQQQQQQVVVVVQQQQvCCCA98A256QQA16x224a2048a672\",$sb);\n    @di = unpack(\"QQQVVVQQQVCCA16A16\",$b[27]);\n\n\t$csum_type = $b[23];\n\n\tif ($csum_type == 1) {\n\t\t$csum = sprintf(\"%016x\", unpack(\"Q\", $b[0]));\n\t} elsif ($csum_type == 2 || $csum_type == 3) {\n\t\t$csum = sprintf(\"%016x%016x%016x%016x\", unpack(\"QQQQ\", $b[0]));\n\t} else {\n\t\t$csum = sprintf(\"%08x\", unpack(\"V\", $b[0]));\n\t}\n\n\tprintf(\"superblock csum=%s fsuuid=%s physaddr=%x flags=%x magic=%s gen=%x roottree=%x chunktree=%x logtree=%x log_root_transid=%x total_bytes=%x bytes_used=%x root_dir_objectid=%x num_devices=%x sectorsize=%x nodesize=%x leafsize=%x stripesize=%x n=%x chunk_root_generation=%x compat_flags=%x compat_ro_flags=%s incompat_flags=%s csum_type=%x root_level=%x chunk_root_level=%x log_root_level=%x (dev_item id=%x numbytes=%x bytesused=%x ioalign=%x iowidth=%x sectorsize=%x type=%x gen=%x startoff=%x devgroup=%x seekspeed=%x bandwidth=%x devid=%s fsid=%s) label=%s cache_gen=%x uuid_tree_gen=%x metadata_uuid=%s\\n\", $csum, format_uuid($b[1]), $b[2], $b[3], $b[4], $b[5], $b[6], $b[7], $b[8], $b[9], $b[10], $b[11], $b[12], $b[13], $b[14], $b[15], $b[16], $b[17], $b[18], $b[19], $b[20], compat_ro_flags($b[21]), incompat_flags($b[22]), $b[23], $b[24], $b[25], $b[26], $di[0], $di[1], $di[2], $di[3], $di[4], $di[5], $di[6], $di[7], $di[8], $di[9], $di[10], $di[11], format_uuid($di[12]), format_uuid($di[13]), $b[28], $b[29], $b[30], format_uuid($b[31]));\n\n\tmy $devid=format_uuid($di[12]);\n\n\t$nodesize = $b[15];\n\n\t$devs{$di[0]}=$f;\n\n\tmy $bootstrap=substr($b[32],0,$b[18]);\n\n\twhile (length($bootstrap)>0) {\n\t\t#print Dumper($bootstrap).\"\\n\";\n\t\t@b2=unpack(\"QCQ\",$bootstrap);\n\t\tprintf(\"bootstrap %x,%x,%x\\n\", @b2[0], @b2[1], @b2[2]);\n\t\t$bootstrap=substr($bootstrap,0x11);\n\n\t\tmy @c=unpack(\"QQQQVVVvvQQA16\",$bootstrap);\n\t\tdump_item(0xe4, substr($bootstrap,0,0x30+($c[7]*0x20)), \"\", 0);\n\n\t\t$bootstrap=substr($bootstrap,0x30+($c[7]*0x20));\n\n\t\tmy %obj;\n\n\t\t$obj{'physoffset'}=$c[10];\n\t\t$obj{'offset'}=$b2[2];\n\t\t$obj{'size'}=$c[0];\n\t\t$obj{'type'}=$c[3];\n\t\t$obj{'num_stripes'}=$c[7];\n\t\t$obj{'devid'}=$c[9];\n\n\t\t# FIXME - second stripes etc.\n\n\t\tpush @l2p_bs,\\%obj;\n\t}\n\n\tmy $backups=$b[33];\n\n    while (length($backups)>0) {\n        my $backup=substr($backups,0,168);\n        $backups=substr($backups,168);\n\n        my @b3=unpack(\"QQQQQQQQQQQQQQQx32CCCCCCx10\",$backup);\n\n        printf(\"backup tree_root=%x tree_root_gen=%x chunk_root=%x chunk_root_gen=%x extent_root=%x extent_root_gen=%x fs_root=%x fs_root_gen=%x dev_root=%x dev_root_gen=%x csum_root=%x csum_root_gen=%x total_bytes=%x bytes_used=%x num_devices=%x tree_root_level=%x chunk_root_level=%x extent_root_level=%x fs_root_level=%x dev_root_level=%x csum_root_level=%x\\n\", @b3);\n    }\n\n\tprint \"\\n\";\n}\n\nsub format_uuid {\n\tmy ($s)=@_;\n\tmy @b=unpack(\"VVVV\",$s);\n\n\treturn sprintf(\"%08x%08x%08x%08x\", $b[3], $b[2], $b[1], $b[0]);\n}\n\nsub format_time {\n\tmy ($t,$ns)=@_;\n\n\tmy @tb=gmtime($t);\n\n\treturn sprintf(\"%04u-%02u-%02uT%02u:%02u:%02u\",$tb[5]+1900,$tb[4]+1,$tb[3],$tb[2],$tb[1],$tb[0]);\n}\n\nsub inode_flags {\n    my ($flags)=@_;\n    my @l=();\n\n    if ($flags & 1) {\n        push @l,\"nodatasum\";\n        $flags &= ~1;\n    }\n\n    if ($flags & 2) {\n        push @l,\"nodatacow\";\n        $flags &= ~2;\n    }\n\n    if ($flags & 4) {\n        push @l,\"readonly\";\n        $flags &= ~4;\n    }\n\n    if ($flags & 8) {\n        push @l,\"nocompress\";\n        $flags &= ~8;\n    }\n\n    if ($flags & 16) {\n        push @l,\"prealloc\";\n        $flags &= ~16;\n    }\n\n    if ($flags & 32) {\n        push @l,\"sync\";\n        $flags &= ~32;\n    }\n\n    if ($flags & 64) {\n        push @l,\"immutable\";\n        $flags &= ~64;\n    }\n\n    if ($flags & 128) {\n        push @l,\"append\";\n        $flags &= ~128;\n    }\n\n    if ($flags & 256) {\n        push @l,\"nodump\";\n        $flags &= ~256;\n    }\n\n    if ($flags & 512) {\n        push @l,\"noatime\";\n        $flags &= ~512;\n    }\n\n    if ($flags & 1024) {\n        push @l,\"dirsync\";\n        $flags &= ~1024;\n    }\n\n    if ($flags & 2048) {\n        push @l,\"compress\";\n        $flags &= ~2048;\n    }\n\n    if ($flags & 4294967296) {\n        push @l,\"ro_verity\";\n        $flags &= ~4294967296;\n    }\n\n    if ($flags != 0) {\n        push @l,sprintf(\"%x\",$flags);\n    }\n\n    if ($#l > -1) {\n        return join(',',@l);\n    } else {\n        return 0;\n    }\n}\n\nsub format_balance {\n\tmy ($s)=@_;\n\tmy (@b,$flags,@f,$fl,$t);\n\n\t@b=unpack(\"QVVQQQQQQQVVVV\",$s);\n\n\t$flags=$b[9];\n\n# #define BTRFS_BALANCE_ARGS_PROFILES\t(1ULL << 0)\n# #define BTRFS_BALANCE_ARGS_USAGE\t(1ULL << 1)\n# #define BTRFS_BALANCE_ARGS_DEVID\t(1ULL << 2)\n# #define BTRFS_BALANCE_ARGS_DRANGE\t(1ULL << 3)\n# #define BTRFS_BALANCE_ARGS_VRANGE\t(1ULL << 4)\n# #define BTRFS_BALANCE_ARGS_LIMIT\t(1ULL << 5)\n# #define BTRFS_BALANCE_ARGS_LIMIT_RANGE\t(1ULL << 6)\n# #define BTRFS_BALANCE_ARGS_STRIPES_RANGE (1ULL << 7)\n# #define BTRFS_BALANCE_ARGS_USAGE_RANGE\t(1ULL << 10)\n\n\t$t=sprintf(\"profiles=%x\",$b[0]);\n\n\tif ($flags & (1 << 10)) {\n\t\t$t.=sprintf(\" usage=%x\",($b[2] << 32) | $b[1]);\n\t} elsif ($flags & (1 << 1)) {\n\t\t$t.=sprintf(\" usage=%x..%x\",$b[1],$b[2]);\n\t}\n\n\t$t.=sprintf(\" devid=%x pstart=%x pend=%x vstart=%x vend=%x target=%x\",$b[3],$b[4],$b[5],$b[6],$b[7],$b[8]);\n\n\t@f=();\n\t$fl=$flags;\n\tif ($fl & (1 << 0)) {\n\t\tpush @f,\"profiles\";\n\t\t$fl &= ~(1 << 0);\n\t}\n\tif ($fl & (1 << 1)) {\n\t\tpush @f,\"usage\";\n\t\t$fl &= ~(1 << 1);\n\t}\n\tif ($fl & (1 << 2)) {\n\t\tpush @f,\"devid\";\n\t\t$fl &= ~(1 << 2);\n\t}\n\tif ($fl & (1 << 3)) {\n\t\tpush @f,\"drange\";\n\t\t$fl &= ~(1 << 3);\n\t}\n\tif ($fl & (1 << 4)) {\n\t\tpush @f,\"vrange\";\n\t\t$fl &= ~(1 << 4);\n\t}\n\tif ($fl & (1 << 5)) {\n\t\tpush @f,\"limit\";\n\t\t$fl &= ~(1 << 5);\n\t}\n\tif ($fl & (1 << 6)) {\n\t\tpush @f,\"limitrange\";\n\t\t$fl &= ~(1 << 6);\n\t}\n\tif ($fl & (1 << 7)) {\n\t\tpush @f,\"stripesrange\";\n\t\t$fl &= ~(1 << 7);\n\t}\n\tif ($fl & (1 << 8)) {\n\t\tpush @f,\"convert\";\n\t\t$fl &= ~(1 << 8);\n\t}\n\tif ($fl & (1 << 9)) {\n\t\tpush @f,\"soft\";\n\t\t$fl &= ~(1 << 9);\n\t}\n\tif ($fl & (1 << 10)) {\n\t\tpush @f,\"usagerange\";\n\t\t$fl &= ~(1 << 10);\n\t}\n\n\tif ($fl != 0 || $#f == -1) {\n\t\tpush @f,$fl;\n\t}\n\n\t$t.=sprintf(\" flags=%s\",join(',',@f));\n\n\tif ($flags & (1 << 5)) {\n\t\t$t.=sprintf(\" limit=%x\",($b[11] << 32) | $b[10]);\n\t} elsif ($flags & (1 << 6)) {\n\t\t$t.=sprintf(\" limit=%x..%x\",$b[11],$b[10]);\n\t}\n\n\tif ($flags & (1 << 7)) {\n\t\t$t.=sprintf(\" stripes=%x..%x\",$b[12],$b[13]);\n\t}\n\n\treturn $t;\n}\n\nsub qgroup_status_flags {\n\tmy ($f)=@_;\n\tmy (@l);\n\n\tif ($f & 1) {\n\t\tpush @l, \"on\";\n\t\t$f &= ~1;\n\t}\n\n\tif ($f & 2) {\n\t\tpush @l, \"rescan\";\n\t\t$f &= ~2;\n\t}\n\n\tif ($f & 4) {\n\t\tpush @l, \"inconsistent\";\n\t\t$f &= ~4;\n\t}\n\n\tif ($f & 8) {\n\t\tpush @l, \"simple\";\n\t\t$f &= ~8;\n\t}\n\n\tif ($f != 0) {\n\t\tpush @l, $f;\n\t}\n\n\treturn join(',',@l);\n}\n\nsub dump_item {\n\tmy ($type,$s,$pref,$id,$off)=@_;\n\tmy (@b);\n\n\tmy $unrecog = 0;\n\n\tprint $pref;\n\tif ($type == 0x1 || $type == 0x84) { # INODE_ITEM or ROOT_ITEM\n\t\tif (length($s) < 0xa0) {\n\t\t\t$s.= chr(0) x (0xa0 - length($s));\n\t\t}\n\t\t@b=unpack(\"QQQQQVVVVQQQx32QVQVQVQV\",$s);\n\t\t$s=substr($s,0xa0);\n\n\t\tif ($type==0x84) {\n\t\t\tprint \"root_item\";\n\t\t} else {\n\t\t\tprint \"inode_item\";\n\t\t}\n\n\t\tprintf(\" gen=%x transid=%x size=%x blocks=%x blockgroup=%x nlink=%x uid=%x gid=%x mode=%o rdev=%x flags=%s seq=%x atime=%s ctime=%s mtime=%s otime=%s\", $b[0], $b[1], $b[2], $b[3], $b[4], $b[5], $b[6], $b[7], $b[8], $b[9], inode_flags($b[10]), $b[11], format_time($b[12], $b[13]), format_time($b[14], $b[15]), format_time($b[16], $b[17]), format_time($b[18], $b[19]));\n\n\t\tif ($type != 0x1) {\n\t\t\t@b=unpack(\"QQQQQQQVQCQCC\",$s);\n\t\t\t$s=substr($s,0x4f);\n\n\t\t\t#print Dumper(@b).\"\\n\";\n\t\t\tprintf(\"; expgen=%x objid=%x blocknum=%x bytelimit=%x bytesused=%x snapshotgen=%x flags=%x numrefs=%x dropprogress=%x,%x,%x droplevel=%x rootlevel=%x\", @b);\n\n\t\t\t@b=unpack(\"QA16A16A16QQQQQVQVQVQV\",$s);\n\t\t\t$s=substr($s,0xc8); # above + 64 blank bytes\n\n\t\t\tprintf(\" gen2=%x uuid=%s par_uuid=%s rec_uuid=%s ctransid=%x otransid=%x stransid=%x rtransid=%x ctime=%s otime=%s stime=%s rtime=%s\", $b[0], format_uuid($b[1]), format_uuid($b[2]), format_uuid($b[3]), $b[4], $b[5], $b[6], $b[7], format_time($b[8],$b[9]), format_time($b[10],$b[11]), format_time($b[12],$b[13]), format_time($b[14],$b[15]));\n\t\t}\n\t} elsif ($type == 0xc) { # INODE_REF\n\t\tprintf(\"inode_ref\");\n\n\t\tdo {\n\t\t\t@b=unpack(\"Qv\",$s);\n\t\t\t$s=substr($s,0xa);\n\t\t\tmy $name=substr($s,0,$b[1]);\n\t\t\t$s=substr($s,$b[1]);\n\n\t\t\tprintf(\" index=%x n=%x name=%s\",$b[0],$b[1],$name);\n\t\t} while (length($s)>0);\n\t} elsif ($type == 0xd) { # INODE_EXTREF\n\t\tprintf(\"inode_extref\");\n\n\t\tdo {\n\t\t\t@b=unpack(\"QQv\",$s);\n\t\t\t$s=substr($s,0x12);\n\t\t\tmy $name=substr($s,0,$b[2]);\n\t\t\t$s=substr($s,$b[2]);\n\n\t\t\tprintf(\" dir=%x index=%x n=%x name=%s\",$b[0],$b[1],$b[2],$name);\n\t\t} while (length($s)>0);\n\t} elsif ($type == 0x18 || $type == 0x54 || $type == 0x60) { # XATTR_ITEM, DIR_ITEM or DIR_INDEX\n\t\tprint $type==0x54?\"dir_item\":($type==0x18?\"xattr_item\":\"dir_index\");\n\n\t\twhile (length($s)>0) {\n\t\t\t@b=unpack(\"QCQQvvC\",$s);\n\t\t\t$s=substr($s,0x1e);\n\n\t\t\tmy $name=substr($s,0,$b[5]);\n\t\t\t$s=substr($s,$b[5]);\n\n\t\t\tmy $name2=substr($s,0,$b[4]);\n\t\t\t$s=substr($s,$b[4]);\n\n\t\t\tprintf(\" key=%x,%x,%x transid=%x m=%x n=%x type=%x name=%s%s\",$b[0],$b[1],$b[2],$b[3],$b[4],$b[5],$b[6],$name,$name2 eq \"\"?\"\":(\" name2=\".$name2));\n\t\t}\n    } elsif ($type == 0x24) { # VERITY_DESC_ITEM\n\t\tprintf(\"verity_desc_item\");\n\n\t\tif ($off == 0) {\n\t\t\t@b=unpack(\"Qx16C\",$s);\n\t\t\t$s=substr($s,25);\n\n\t\t\tprintf(\" size=%x enc=%x\", $b[0], $b[1]);\n\t\t} else {\n\t\t\twhile (length($s)>0) {\n\t\t\t\t@b=unpack(\"C\",$s);\n\t\t\t\tprintf(\" %02x\", $b[0]);\n\t\t\t\t$s = substr($s,1);\n\t\t\t}\n\t\t}\n\t} elsif ($type == 0x25) { # VERITY_MERKLE_ITEM\n\t\twhile (length($s)>0) {\n\t\t\t@b=unpack(\"NNNNNNNN\",$s);\n\t\t\tprintf(\" %008x%008x%008x%008x%008x%008x%008x%008x\", $b[0], $b[1], $b[2], $b[3], $b[4], $b[5], $b[6], $b[7]);\n\t\t\t$s = substr($s,32);\n\t\t}\n\t} elsif ($type == 0x30) { # ORPHAN_ITEM\n\t\tprintf(\"orphan_item\");\n\t} elsif ($type == 0x48) { # LOG_INDEX\n\t\t@b=unpack(\"Q\",$s);\n\t\t$s=substr($s,8);\n\n\t\tprintf(\"log_index end=%x\", $b[0]);\n\t} elsif ($type == 0x6c) { # EXTENT_DATA\n\t\t@b=unpack(\"QQCCvC\",$s);\n\t\t$s=substr($s,0x15);\n\n\t\tprintf(\"extent_data gen=%x size=%x comp=%s enc=%s otherenc=%s type=%s\", $b[0], $b[1], $b[2], $b[3], $b[4], $b[5]);\n\n\t\tif ($b[5] != 0) {\n\t\t\t@b=unpack(\"QQQQ\",$s);\n\t\t\t$s=substr($s,0x20);\n\n\t\t\tprintf(\" ea=%x es=%x o=%x s=%x\",@b);\n\t\t} else {\n\t\t\t$s=substr($s,$b[1]);\n\t\t}\n\t} elsif ($type == 0x80) { # EXTENT_CSUM\n\t\tprint \"extent_csum\";\n\n\t\tif ($csum_type == 1) { # xxhash\n\t\t\twhile (length($s)>0) {\n\t\t\t\tprintf(\" %016x\",unpack(\"Q\",$s));\n\t\t\t\t$s=substr($s,8);\n\t\t\t}\n\t\t} elsif ($csum_type == 2 || $csum_type == 3) { # sha256 or blake2\n\t\t\twhile (length($s)>0) {\n\t\t\t\tprintf(\" %016x%016x%016x%016x\",unpack(\"QQQQ\",$s));\n\t\t\t\t$s=substr($s,32);\n\t\t\t}\n\t\t} else {\n\t\t\twhile (length($s)>0) {\n\t\t\t\tprintf(\" %08x\",unpack(\"V\",$s));\n\t\t\t\t$s=substr($s,4);\n\t\t\t}\n\t\t}\n\t} elsif ($type == 0x90 || $type == 0x9c) { # ROOT_BACKREF or ROOT_REF\n\t\t@b=unpack(\"QQv\",$s);\n\t\t$s=substr($s,18);\n\n\t\tmy $name=substr($s,0,$b[2]);\n\t\t$s=substr($s,$b[2]);\n\n\t\tprintf(\"%s id=%x seq=%x n=%x name=%s\", $type==0x90?\"root_backref\":\"root_ref\", $b[0], $b[1], $b[2], $name);\n\t} elsif ($type == 0xa8 || $type == 0xa9) { # EXTENT_ITEM_KEY or METADATA_ITEM_KEY\n\t\t# FIXME - TREE_BLOCK is out by one byte (why?)\n\t\tif (length($s)==4) {\n\t\t\t@b=unpack(\"L\",$s);\n\t\t\t$s=substr($s,4);\n\t\t\tprintf(\"extent_item_v0 refcount=%x\",$b[0]);\n\t\t} else {\n\t\t\t@b=unpack(\"QQQ\",$s);\n\t\t\tprintf(\"%s refcount=%x gen=%x flags=%x \",$type == 0xa9 ? \"metadata_item_key\" : \"extent_item_key\",$b[0],$b[1],$b[2]);\n\n\t\t\t$s=substr($s,24);\n\n\t\t\tmy $refcount=$b[0];\n\t\t\tif ($b[2]&2 && $type != 0xa9) {\n\t\t\t\t@b=unpack(\"QCQC\",$s);\n\t\t\t\tprintf(\"key=%x,%x,%x level=%u \",$b[0],$b[1],$b[2],$b[3]);\n\t\t\t\t$s=substr($s,18);\n\t\t\t}\n\n\t\t\twhile (length($s)>0) {\n\t\t\t\tmy $irt=unpack(\"C\",$s);\n\t\t\t\t$s = substr($s,1);\n\n\t\t\t\tif ($irt == 0xac) {\n\t\t\t\t\t@b=unpack(\"Q\",$s);\n\t\t\t\t\t$s=substr($s,8);\n\t\t\t\t\tprintf(\"extent_owner_ref root=%x \",$b[0]);\n\t\t\t\t} elsif ($irt == 0xb0) {\n\t\t\t\t\t@b=unpack(\"Q\",$s);\n\t\t\t\t\t$s=substr($s,8);\n\t\t\t\t\tprintf(\"tree_block_ref root=%x \",$b[0]);\n\t\t\t\t} elsif ($irt == 0xb2) {\n\t\t\t\t\t@b=unpack(\"QQQv\",$s);\n\t\t\t\t\t$s=substr($s,28);\n\t\t\t\t\tprintf(\"extent_data_ref root=%x objid=%x offset=%x count=%x \",@b);\n\t\t\t\t\t$refcount-=$b[3]-1;\n\t\t\t\t} elsif ($irt == 0xb6) {\n\t\t\t\t\t@b=unpack(\"Q\",$s);\n\t\t\t\t\t$s=substr($s,8);\n\t\t\t\t\tprintf(\"shared_block_ref offset=%x\",$b[0]);\n\t\t\t\t} elsif ($irt == 0xb8) {\n\t\t\t\t\t@b=unpack(\"Qv\",$s);\n\t\t\t\t\t$s=substr($s,12);\n\t\t\t\t\tprintf(\"shared_data_ref offset=%x count=%x \",@b);\n\t\t\t\t\t$refcount-=$b[1]-1;\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"unknown %x (length %u)\", $irt, length($s));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} elsif ($type == 0xb0) { # TREE_BLOCK_REF\n\t\tprintf(\"tree_block_ref \");\n\t} elsif ($type == 0xb2) { # EXTENT_DATA_REF\n\t\t@b=unpack(\"QQQv\",$s);\n\t\t$s=substr($s,28);\n\t\tprintf(\"extent_data_ref root=%x objid=%x offset=%x count=%x \",@b);\n\t} elsif ($type == 0xb4) { # EXTENT_REF_V0\n\t\t@b=unpack(\"QQQv\",$s);\n\t\t$s=substr($s,28);\n\n\t\tprintf(\"extent_ref_v0 root=%x gen=%x objid=%x count=%x\",@b);\n\t} elsif ($type == 0xb6) { # SHARED_BLOCK_REF\n\t\tprintf(\"shared_block_ref \");\n\t} elsif ($type == 0xb8) { # SHARED_DATA_REF\n\t\t@b=unpack(\"v\",$s);\n\t\t$s=substr($s,4);\n\n\t\tprintf(\"shared_data_ref count=%x\",@b);\n\t} elsif ($type == 0xc0) { # BLOCK_GROUP_ITEM\n\t\t@b=unpack(\"QQQ\",$s);\n\t\t$s=substr($s,0x18);\n\t\tprintf(\"block_group_item size=%x chunktreeid=%x flags=%x\",$b[0],$b[1],$b[2]);\n        } elsif ($type == 0xc6) { # FREE_SPACE_INFO\n\t\t@b=unpack(\"VV\",$s);\n\t\t$s=substr($s,0x8);\n\t\tprintf(\"free_space_info count=%x flags=%x\",$b[0],$b[1]);\n\t} elsif ($type == 0xc7) { # FREE_SPACE_EXTENT\n\t\tprintf(\"free_space_extent\");\n\t} elsif ($type == 0xc8) { # FREE_SPACE_BITMAP\n\t\tprintf(\"free_space_bitmap\"); # FIXME - print contents\n\t} elsif ($type == 0xcc) { # DEV_EXTENT\n\t\t@b=unpack(\"QQQQA16\",$s);\n\t\t$s=substr($s,0x30);\n\t\tprintf(\"dev_extent chunktree=%x, chunkobjid=%x, logaddr=%x, size=%x, chunktreeuuid=%s\", $b[0], $b[1], $b[2], $b[3], format_uuid($b[4]));\n\t} elsif ($type == 0xd8) { # DEV_ITEM\n\t\t@b=unpack(\"QQQVVVQQQVCCA16A16\",$s);\n\t\tprintf(\"dev_item id=%x numbytes=%x bytesused=%x ioalign=%x iowidth=%x sectorsize=%x type=%x gen=%x startoff=%x devgroup=%x seekspeed=%x bandwidth=%x devid=%s fsid=%s\", $b[0], $b[1], $b[2], $b[3], $b[4], $b[5], $b[6], $b[7], $b[8], $b[9], $b[10], $b[11], format_uuid($b[12]), format_uuid($b[13]));\n\t\t$s=substr($s,0x62);\n\t} elsif ($type == 0xe4) { # CHUNK_ITEM\n\t\t@b=unpack(\"QQQQVVVvv\",$s);\n\t\tprintf(\"chunk_item size=%x root=%x stripelength=%x type=%x ioalign=%x iowidth=%x sectorsize=%x numstripes=%x substripes=%x\",$b[0],$b[1],$b[2],$b[3],$b[4],$b[5],$b[6],$b[7],$b[8]);\n\t\t$s=substr($s,0x30);\n\n\t\tmy $numstripes=$b[7];\n\t\tfor (my $i=0;$i<$numstripes;$i++) {\n\t\t\t@b=unpack(\"QQA16\",$s);\n\t\t\t$s=substr($s,0x20);\n\n\t\t\tprintf(\" stripe(%u) devid=%x offset=%x devuuid=%s\",$i,$b[0],$b[1],format_uuid($b[2]));\n\t\t}\n\t} elsif ($type == 0xf0) { # QGROUP_STATUS\n\t\t@b=unpack(\"QQQQQ\", $s);\n\t\tprintf(\"qgroup_status version=%x generation=%x flags=%s rescan=%x enable_gen=%x\",$b[0],$b[1],qgroup_status_flags($b[2]),$b[3],$b[4]);\n\t\t$s=substr($s,0x28);\n\t} elsif ($type == 0xf2) { # QGROUP_INFO\n\t\t@b=unpack(\"QQQQQ\", $s);\n\t\tprintf(\"qgroup_info generation=%x rfer=%x rfer_cmpr=%x excl=%x excl_cmpr=%x\",$b[0],$b[1],$b[2],$b[3],$b[4]);\n\t\t$s=substr($s,0x28);\n\t} elsif ($type == 0xf4) { # QGROUP_LIMIT\n\t\t@b=unpack(\"QQQQQ\", $s);\n\t\tprintf(\"qgroup_limit flags=%x max_rfer=%x max_excl=%x rsv_rfer=%x rsv_excl=%x\",$b[0],$b[1],$b[2],$b[3],$b[4]);\n\t\t$s=substr($s,0x28);\n\t} elsif ($type == 0xf6) { # QGROUP_RELATION\n\t\tprintf(\"qgroup_relation\");\n\t} elsif ($type == 0xf8 && $id == 0xfffffffffffffffc) { # balance\n\t\tmy ($fl,@f);\n\n\t\t@b=unpack(\"Q\",$s);\n\t\t$s=substr($s,8);\n\n\t\t$fl=$b[0];\n\t\t@f=();\n\t\tif ($fl & (1 << 0)) {\n\t\t\tpush @f,\"data\";\n\t\t\t$fl &= ~(1 << 0);\n\t\t}\n\t\tif ($fl & (1 << 1)) {\n\t\t\tpush @f,\"system\";\n\t\t\t$fl &= ~(1 << 1);\n\t\t}\n\t\tif ($fl & (1 << 2)) {\n\t\t\tpush @f,\"metadata\";\n\t\t\t$fl &= ~(1 << 2);\n\t\t}\n\t\tif ($fl!=0 || $#f==-1) {\n\t\t\tpush @f,$fl;\n\t\t}\n\n\t\tprintf(\"balance flags=%s data=(%s) metadata=(%s) sys=(%s)\",join(',',@f),format_balance(substr($s,0,0x88)),format_balance(substr($s,0x88,0x88)),format_balance(substr($s,0x110,0x88)));\n\n\t\t$s=substr($s,0x1b8);\n\t} elsif ($type == 0xf9) { # DEV_STATS\n\t\tprint \"dev_stats\";\n\n\t\twhile (length($s)>0) {\n\t\t\tprintf(\" %x\",unpack(\"Q\",$s));\n\t\t\t$s=substr($s,8);\n\t\t}\n\t} elsif ($type == 0xfb) { # UUID_SUBVOL\n\t\tprint \"uuid_subvol\";\n\n\t\twhile (length($s)>0) {\n\t\t\tprintf(\" %x\",unpack(\"Q\",$s));\n\t\t\t$s=substr($s,8);\n\t\t}\n\t} elsif ($type == 0xfc) { # UUID_REC_SUBVOL\n\t\tprint \"uuid_rec_subvol\";\n\n\t\twhile (length($s)>0) {\n\t\t\tprintf(\" %x\",unpack(\"Q\",$s));\n\t\t\t$s=substr($s,8);\n\t\t}\n    } elsif ($type == 0 && $id == 0xfffffffffffffff5) { # free space\n        @b=unpack(\"QCQQQQ\",$s);\n        $s=substr($s,0x29);\n\n        printf(\"free_space key=(%x,%x,%x) gen=%x num_entries=%x num_bitmaps=%x\",@b);\n\t} else {\n\t\tprintf STDERR (\"ERROR - unknown type %x (size=%x, tell=%x)\\n\", $type, length($s), tell($f));\n\t\tprintf(\"unknown (size=%x)\", length($s));\n\t\t$unrecog = 1;\n\t}\n\n\tif ($unrecog == 0 && length($s) > 0) {\n\t\tprintf(\" (left=%x)\",length($s));\n\t}\n\n\tprint \"\\n\";\n}\n\nsub read_data {\n\tmy ($addr,$size,$bs)=@_;\n\tmy (@arr,$f,$data,$stripeoff,$parity,$stripe,$physstripe,$physoff);\n\n\tif ($bs==1) {\n\t\t@arr=@l2p_bs;\n\t} else {\n\t\t@arr=@l2p;\n\t}\n\n\tforeach my $obj (@arr) {\n\t\tif ($obj->{'offset'}<=$addr&&($addr-$obj->{'offset'})<$obj->{'size'}) {\n\t\t\tif ($obj->{'type'} & 0x80) { # RAID5\n\t\t\t\t$stripeoff=($addr-$obj->{'offset'})%0x20000;\n\t\t\t\t$parity=(int(($addr-$obj->{'offset'})/0x20000)+2)%3;\n\t\t\t\t$stripe=int($stripeoff/0x10000);\n\t\t\t\t$physstripe=($parity+$stripe+1)%3;\n\n\t\t\t\tif ($physstripe==0) {\n\t\t\t\t\t$f=$devs{$obj->{'devid'}};\n\t\t\t\t\t$physoff=$obj->{'physoffset'}+(int(($addr-$obj->{'offset'})/0x20000)*0x10000)+($stripeoff%0x10000);\n\t\t\t\t} elsif ($physstripe==1) {\n\t\t\t\t\t$f=$devs{$obj->{'devid2'}};\n\t\t\t\t\t$physoff=$obj->{'physoffset2'}+(int(($addr-$obj->{'offset'})/0x20000)*0x10000)+($stripeoff%0x10000);\n\t\t\t\t} elsif ($physstripe==2) {\n\t\t\t\t\t$f=$devs{$obj->{'devid3'}};\n\t\t\t\t\t$physoff=$obj->{'physoffset3'}+(int(($addr-$obj->{'offset'})/0x20000)*0x10000)+($stripeoff%0x10000);\n\t\t\t\t}\n\n\t\t\t\tseek($f,$physoff,0);\n\t\t\t\tread($f,$data,$size);\n\t\t\t} elsif ($obj->{'type'} & 0x100) { # RAID6\n\t\t\t\t$stripeoff=($addr-$obj->{'offset'})%0x20000;\n\t\t\t\t$parity=(int(($addr-$obj->{'offset'})/0x20000)+3)%4;\n\t\t\t\t$stripe=int($stripeoff/0x10000);\n\t\t\t\t$physstripe=($parity+$stripe+1)%4;\n\n\t\t\t\tif ($physstripe==0) {\n\t\t\t\t\t$f=$devs{$obj->{'devid'}};\n\t\t\t\t\t$physoff=$obj->{'physoffset'}+(int(($addr-$obj->{'offset'})/0x20000)*0x10000)+($stripeoff%0x10000);\n\t\t\t\t} elsif ($physstripe==1) {\n\t\t\t\t\t$f=$devs{$obj->{'devid2'}};\n\t\t\t\t\t$physoff=$obj->{'physoffset2'}+(int(($addr-$obj->{'offset'})/0x20000)*0x10000)+($stripeoff%0x10000);\n\t\t\t\t} elsif ($physstripe==2) {\n\t\t\t\t\t$f=$devs{$obj->{'devid3'}};\n\t\t\t\t\t$physoff=$obj->{'physoffset3'}+(int(($addr-$obj->{'offset'})/0x20000)*0x10000)+($stripeoff%0x10000);\n\t\t\t\t} elsif ($physstripe==3) {\n\t\t\t\t\t$f=$devs{$obj->{'devid4'}};\n\t\t\t\t\t$physoff=$obj->{'physoffset4'}+(int(($addr-$obj->{'offset'})/0x20000)*0x10000)+($stripeoff%0x10000);\n\t\t\t\t}\n\n\t\t\t\tseek($f,$physoff,0);\n\t\t\t\tread($f,$data,$size);\n\t\t\t} elsif ($obj->{'type'} & 0x40) { # RAID10\n\t\t\t\t$stripeoff=($addr-$obj->{'offset'})%0x20000;\n\t\t\t\t$stripe=int($stripeoff/0x10000);\n\n\t\t\t\tif ($stripe==0) {\n\t\t\t\t\t$f=$devs{$obj->{'devid'}};\n\t\t\t\t\t$physoff=$obj->{'physoffset'}+(int(($addr-$obj->{'offset'})/0x20000)*0x10000)+($stripeoff%0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t$f=$devs{$obj->{'devid3'}};\n\t\t\t\t\t$physoff=$obj->{'physoffset3'}+(int(($addr-$obj->{'offset'})/0x20000)*0x10000)+($stripeoff%0x10000);\n\t\t\t\t}\n\n\t\t\t\tseek($f,$physoff,0);\n\t\t\t\tread($f,$data,$size);\n\t\t\t} elsif ($obj->{'type'} & 0x8) { # RAID0\n\t\t\t\t$stripeoff=($addr-$obj->{'offset'})%0x20000;\n\t\t\t\t$stripe=int($stripeoff/0x10000);\n\n\t\t\t\tif ($stripe==0) {\n\t\t\t\t\t$f=$devs{$obj->{'devid'}};\n\t\t\t\t\t$physoff=$obj->{'physoffset'}+(int(($addr-$obj->{'offset'})/0x20000)*0x10000)+($stripeoff%0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t$f=$devs{$obj->{'devid2'}};\n\t\t\t\t\t$physoff=$obj->{'physoffset2'}+(int(($addr-$obj->{'offset'})/0x20000)*0x10000)+($stripeoff%0x10000);\n\t\t\t\t}\n\n\t\t\t\tseek($f,$physoff,0);\n\t\t\t\tread($f,$data,$size);\n\t\t\t} else { # SINGLE, DUP, RAID1\n\t\t\t\tseek($devs{$obj->{'devid'}},$obj->{'physoffset'}+$addr-$obj->{'offset'},0);\n\t\t\t\tread($devs{$obj->{'devid'}},$data,$size);\n\t\t\t}\n\n\t\t\treturn $data;\n\t\t}\n\t}\n}\n\nsub dump_tree {\n\tmy ($addr, $pref, $bs)=@_;\n\tmy ($head, @headbits, $level, $treenum, $tree, $csum);\n\n\t$tree = read_data($addr, $nodesize, $bs);\n\n\t@headbits=unpack(\"A32A16QQA16QQVC\",$tree);\n\tif ($headbits[2] != $addr) {\n\t\tprintf STDERR sprintf(\"Address mismatch: expected %llx, got %llx\\n\", $addr, $headbits[2]);\n\t\texit;\n\t}\n\n\tif ($csum_type == 1) {\n\t\t$csum = sprintf(\"%016x\", unpack(\"Q\", $headbits[0]));\n\t} elsif ($csum_type == 2 || $csum_type == 3) {\n\t\t$csum = sprintf(\"%016x%016x%016x%016x\", unpack(\"QQQQ\", $headbits[0]));\n\t} else {\n\t\t$csum = sprintf(\"%08x\", unpack(\"V\", $headbits[0]));\n\t}\n\n\tprint $pref;\n\tprintf(\"header csum=%s fsid=%s addr=%x flags=%x chunk=%s gen=%x tree=%x numitems=%x level=%x\\n\", $csum, format_uuid($headbits[1]), $headbits[2], $headbits[3], format_uuid($headbits[4]), $headbits[5], $headbits[6], $headbits[7], $headbits[8]);\n\n\t$level=$headbits[8];\n\t$treenum=$headbits[6];\n\n\tmy $numitems=$headbits[7];\n\n\tif ($level==0) {\n\t\tmy $headaddr=tell($f);\n\t\tfor (my $i=0;$i<$numitems;$i++) {\n# \t\t\tread($f, my $itemhead, 0x19);\n\t\t\tmy $itemhead=substr($tree,0x65+($i*0x19),0x19);\n\n\t\t\tmy @ihb=unpack(\"QCQVV\",$itemhead);\n\n\t\t\t#print Dumper(@ihb).\"\\n\";\n\t\t\tprint $pref;\n\t\t\tprintf(\"%x,%x,%x\\n\",$ihb[0],$ihb[1],$ihb[2]);\n\n\t\t\tmy $item=substr($tree,0x65+$ihb[3],$ihb[4]);\n\t\t\tdump_item($ihb[1],$item,$pref,$ihb[0],$ihb[2]);\n\n\t\t\tif ($treenum==3&&$ihb[1]==0xe4) {\n\t\t\t\tmy @b=unpack(\"QQQQVVVvv\",$item);\n\t\t\t\tmy $stripes=substr($item,48);\n\t\t\t\tmy %obj;\n\n\t\t\t\tmy $numstripes=$b[7];\n\n\t\t\t\tmy @cis=unpack(\"QQA16\",$stripes);\n\t\t\t\t$stripes=substr($stripes,32);\n\n\t\t\t\t$obj{'physoffset'}=$cis[1];\n\t\t\t\t$obj{'offset'}=$ihb[2];\n\t\t\t\t$obj{'size'}=$b[0];\n\t\t\t\t$obj{'type'}=$b[3];\n\t\t\t\t$obj{'num_stripes'}=$b[7];\n\t\t\t\t$obj{'devid'}=$cis[0];\n\n\t\t\t\tif ($b[7] > 1) {\n\t\t\t\t\tmy @cis=unpack(\"QQA16\",$stripes);\n\t\t\t\t\t$stripes=substr($stripes,32);\n\n\t\t\t\t\t$obj{'physoffset2'}=$cis[1];\n\t\t\t\t\t$obj{'devid2'}=$cis[0];\n\t\t\t\t}\n\n\t\t\t\tif ($b[7] > 2) {\n\t\t\t\t\tmy @cis=unpack(\"QQA16\",$stripes);\n\t\t\t\t\t$stripes=substr($stripes,32);\n\n\t\t\t\t\t$obj{'physoffset3'}=$cis[1];\n\t\t\t\t\t$obj{'devid3'}=$cis[0];\n\t\t\t\t}\n\n\t\t\t\tif ($b[7] > 3) {\n\t\t\t\t\tmy @cis=unpack(\"QQA16\",$stripes);\n\t\t\t\t\t$stripes=substr($stripes,32);\n\n\t\t\t\t\t$obj{'physoffset4'}=$cis[1];\n\t\t\t\t\t$obj{'devid4'}=$cis[0];\n\t\t\t\t}\n\n\t\t\t\tpush @l2p,\\%obj;\n\n# \t\t\t\tprint Dumper(@l2p);\n            }\n\n\t\t\tif ($ihb[1] == 0x84) {\n\t\t\t\tif ($treenum == 1) {\n\t\t\t\t\t$roots{$ihb[0]}=unpack(\"x176Q\",$item);\n\t\t\t\t} elsif ($treenum == 0xfffffffffffffffa && $ihb[0] == 0xfffffffffffffffa) {\n\t\t\t\t\t$logroots{$ihb[2]}=unpack(\"x176Q\",$item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (my $i=0;$i<$numitems;$i++) {\n\t\t\tmy $itemhead=substr($tree,0x65+($i*0x21),0x21);\n\n\t\t\tmy @ihb=unpack(\"QCQQQ\",$itemhead);\n\n\t\t\tprint $pref;\n\t\t\tprintf(\"%x,%x,%x block=%x gen=%x\\n\",$ihb[0],$ihb[1],$ihb[2],$ihb[3],$ihb[4]);\n\n\t\t\tdump_tree($ihb[3], \" \".$pref, $bs);\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "mingw-amd64.cmake",
          "type": "blob",
          "size": 0.7978515625,
          "content": "#\n# To Cross-compile, use:\n#  cmake -DCMAKE_TOOLCHAIN_FILE=../mingw.cmake ..\n#\n# the name of the target operating system\nSET(CMAKE_SYSTEM_NAME Windows)\n\n# which compilers to use for C and C++\nSET(CMAKE_C_COMPILER x86_64-w64-mingw32-gcc)\nSET(CMAKE_CXX_COMPILER x86_64-w64-mingw32-g++)\nSET(CMAKE_RC_COMPILER x86_64-w64-mingw32-windres)\n\n# here is the target environment located\nSET(CMAKE_FIND_ROOT_PATH /usr/x86_64-w64-mingw32)\n\n# adjust the default behaviour of the FIND_XXX() commands:\n# search headers and libraries in the target environment, search\n# programs in the host environment\nset(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\nset(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\n\nset(CMAKE_PREFIX_PATH /usr/x86_64-w64-mingw32/usr/lib/cmake)\n\nset(CMAKE_SYSTEM_PROCESSOR x86_64)\n"
        },
        {
          "name": "mingw-x86.cmake",
          "type": "blob",
          "size": 0.8984375,
          "content": "#\n# To Cross-compile, use:\n#  cmake -DCMAKE_TOOLCHAIN_FILE=../mingw.cmake ..\n#\n# the name of the target operating system\nSET(CMAKE_SYSTEM_NAME Windows)\n\n# which compilers to use for C and C++\nSET(CMAKE_C_COMPILER i686-w64-mingw32-gcc)\nSET(CMAKE_CXX_COMPILER i686-w64-mingw32-g++)\nSET(CMAKE_RC_COMPILER i686-w64-mingw32-windres)\n\nSET(CMAKE_C_FLAGS \"-m32\")\nSET(CMAKE_CXX_FLAGS \"-m32\")\nSET(CMAKE_RC_FLAGS \"-F pe-i386\")\nSET(CMAKE_ASM_FLAGS \"-m32\")\n\n# here is the target environment located\nSET(CMAKE_FIND_ROOT_PATH /usr/i686-w64-mingw32)\n\n# adjust the default behaviour of the FIND_XXX() commands:\n# search headers and libraries in the target environment, search\n# programs in the host environment\nset(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\nset(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\n\nset(CMAKE_PREFIX_PATH /usr/i686-w64-mingw32/usr/lib/cmake)\n\nset(CMAKE_SYSTEM_PROCESSOR x86)\n"
        },
        {
          "name": "msvc-aarch64.cmake",
          "type": "blob",
          "size": 0.380859375,
          "content": "set(CMAKE_SYSTEM_NAME Windows)\n\nSET(CMAKE_C_COMPILER /opt/msvc/bin/arm64/cl)\nSET(CMAKE_CXX_COMPILER /opt/msvc/bin/arm64/cl)\nSET(CMAKE_RC_COMPILER /opt/msvc/bin/arm64/rc)\n\nset(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} /MANIFEST:NO\")\nset(CMAKE_MODULE_LINKER_FLAGS \"${CMAKE_MODULE_LINKER_FLAGS} /MANIFEST:NO\")\nset(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} /MANIFEST:NO\")\n"
        },
        {
          "name": "msvc-amd64.cmake",
          "type": "blob",
          "size": 0.375,
          "content": "set(CMAKE_SYSTEM_NAME Windows)\n\nSET(CMAKE_C_COMPILER /opt/msvc/bin/x64/cl)\nSET(CMAKE_CXX_COMPILER /opt/msvc/bin/x64/cl)\nSET(CMAKE_RC_COMPILER /opt/msvc/bin/x64/rc)\n\nset(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} /MANIFEST:NO\")\nset(CMAKE_MODULE_LINKER_FLAGS \"${CMAKE_MODULE_LINKER_FLAGS} /MANIFEST:NO\")\nset(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} /MANIFEST:NO\")\n"
        },
        {
          "name": "msvc-armv7.cmake",
          "type": "blob",
          "size": 0.375,
          "content": "set(CMAKE_SYSTEM_NAME Windows)\n\nSET(CMAKE_C_COMPILER /opt/msvc/bin/arm/cl)\nSET(CMAKE_CXX_COMPILER /opt/msvc/bin/arm/cl)\nSET(CMAKE_RC_COMPILER /opt/msvc/bin/arm/rc)\n\nset(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} /MANIFEST:NO\")\nset(CMAKE_MODULE_LINKER_FLAGS \"${CMAKE_MODULE_LINKER_FLAGS} /MANIFEST:NO\")\nset(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} /MANIFEST:NO\")\n"
        },
        {
          "name": "msvc-x86.cmake",
          "type": "blob",
          "size": 0.4453125,
          "content": "set(CMAKE_SYSTEM_NAME Windows)\n\nSET(CMAKE_C_COMPILER /opt/msvc/bin/x86/cl)\nSET(CMAKE_CXX_COMPILER /opt/msvc/bin/x86/cl)\nSET(CMAKE_RC_COMPILER /opt/msvc/bin/x86/rc)\n\nset(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} /MANIFEST:NO\")\nset(CMAKE_MODULE_LINKER_FLAGS \"${CMAKE_MODULE_LINKER_FLAGS} /MANIFEST:NO\")\nset(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} /MANIFEST:NO\")\n\nset(CMAKE_PREFIX_PATH \"/home/hellas/wine/vcpkg/installed/x64-windows\")\n"
        },
        {
          "name": "send-dump.pl",
          "type": "blob",
          "size": 7.5185546875,
          "content": "#!/usr/bin/perl\n\n# Dumper for btrfs send streams.\n# Released under the same terms, or lack thereof, as btrfs-dump.pl.\n\nopen($f,$ARGV[0]) or die \"Error opening \".$ARGV[0].\": \".$!;\nbinmode($f);\n\nwhile (!eof($f)) {\n    do_stream($f);\n\n    if (!eof($f)) {\n        print \"---\\n\";\n    }\n}\n\nclose($f);\n\nsub do_stream {\n    my ($f)=@_;\n\n    read($f,$a,0x11);\n    ($magic,$ver)=unpack(\"a13V\",$a);\n\n    if ($magic ne \"btrfs-stream\\0\") {\n        printf STDERR \"Not a send file.\\n\";\n        close($f);\n        exit;\n    }\n\n    if ($ver != 1 && $ver != 2) {\n        printf STDERR \"Version $ver not supported.\\n\";\n        close($f);\n        exit;\n    }\n\n    $type = 0;\n    while (!eof($f) && $type != 21) {\n        read($f,$a,0xa);\n        ($len,$type,$crc)=unpack(\"VvV\",$a);\n\n        if ($type == 1) {\n            printf(\"subvol, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 2) {\n            printf(\"snapshot, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 3) {\n            printf(\"mkfile, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 4) {\n            printf(\"mkdir, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 5) {\n            printf(\"mknod, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 6) {\n            printf(\"mkfifo, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 7) {\n            printf(\"mksock, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 8) {\n            printf(\"symlink, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 9) {\n            printf(\"rename, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 10) {\n            printf(\"link, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 11) {\n            printf(\"unlink, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 12) {\n            printf(\"rmdir, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 13) {\n            printf(\"set_xattr, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 14) {\n            printf(\"remove_xattr, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 15) {\n            printf(\"write, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 16) {\n            printf(\"clone, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 17) {\n            printf(\"truncate, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 18) {\n            printf(\"chmod, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 19) {\n            printf(\"chown, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 20) {\n            printf(\"utimes, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 21) {\n            printf(\"end, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 22) {\n            printf(\"update-extent, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 23) {\n            printf(\"fallocate, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 24) {\n            printf(\"fileattr, %x, %08x\\n\", $len, $crc);\n        } elsif ($type == 25) {\n            printf(\"encoded-write, %x, %08x\\n\", $len, $crc);\n        } else {\n            printf(\"unknown(%x), %x, %08x\\n\", $type, $len, $crc);\n        }\n\n        read($f,$b,$len);\n        print_tlvs($b);\n    }\n}\n\nsub btrfstime {\n    my ($t)=@_;\n\n    my $ut = unpack(\"Q\",$t);\n    my @lt = localtime($ut);\n\n    return sprintf(\"%04u-%02u-%02u %02u:%02u:%02u\",$lt[5]+1900,$lt[4]+1,$lt[3],$lt[2],$lt[1],$lt[0]);\n}\n\nsub print_tlvs {\n    my ($b)=@_;\n\n    while (length($b)>0) {\n        my ($t,$l)=unpack(\"vv\",$b);\n\n        if ($t == 1) {\n            printf(\"  uuid: %08x-%04x-%04x-%04x-%02x%02x%02x%02x%02x%02x\\n\", unpack(\"NnnnCCCCCC\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 2) {\n            printf(\"  transid: %x\\n\", unpack(\"Q\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 3) {\n            printf(\"  inode: %x\\n\", unpack(\"Q\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 4) {\n            printf(\"  size: %x\\n\", unpack(\"Q\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 5) {\n            printf(\"  mode: %o\\n\", unpack(\"Q\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 6) {\n            printf(\"  uid: %u\\n\", unpack(\"Q\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 7) {\n            printf(\"  gid: %u\\n\", unpack(\"Q\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 8) {\n            printf(\"  rdev: %x\\n\", unpack(\"Q\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 9) {\n            printf(\"  ctime: %s\\n\", btrfstime(substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 10) {\n            printf(\"  mtime: %s\\n\", btrfstime(substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 11) {\n            printf(\"  atime: %s\\n\", btrfstime(substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 12) {\n            printf(\"  otime: %s\\n\", btrfstime(substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 13) {\n            printf(\"  xattr_name: \\\"%s\\\"\\n\", substr($b,4,$l));\n            $b=substr($b,$l+4);\n        } elsif ($t == 14) {\n            printf(\"  xattr_data: \\\"%s\\\"\\n\", substr($b,4,$l));\n            $b=substr($b,$l+4);\n        } elsif ($t == 15) {\n            printf(\"  path: \\\"%s\\\"\\n\", substr($b,4,$l));\n            $b=substr($b,$l+4);\n        } elsif ($t == 16) {\n            printf(\"  path_to: \\\"%s\\\"\\n\", substr($b,4,$l));\n            $b=substr($b,$l+4);\n        } elsif ($t == 17) {\n            printf(\"  path_link: \\\"%s\\\"\\n\", substr($b,4,$l));\n            $b=substr($b,$l+4);\n        } elsif ($t == 18) {\n            printf(\"  offset: %x\\n\", unpack(\"Q\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 19) {\n            if ($ver == 2) {\n                printf(\"  data: (%x bytes)\\n\", length($b) - 2); # FIXME\n                $b=\"\";\n            } else {\n                printf(\"  data: (%x bytes)\\n\", $l);\n                $b=substr($b,$l+4);\n            }\n        } elsif ($t == 20) {\n            printf(\"  clone_uuid: %08x-%04x-%04x-%04x-%02x%02x%02x%02x%02x%02x\\n\", unpack(\"NnnnCCCCCC\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 21) {\n            printf(\"  clone_transid: %x\\n\", unpack(\"Q\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 22) {\n            printf(\"  clone_path: \\\"%s\\\"\\n\", substr($b,4,$l));\n            $b=substr($b,$l+4);\n        } elsif ($t == 23) {\n            printf(\"  clone_offset: %x\\n\", unpack(\"Q\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 24) {\n            printf(\"  clone_len: %x\\n\", unpack(\"Q\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 25) {\n            printf(\"  fallocate_mode: %x\\n\", unpack(\"V\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 26) {\n            printf(\"  fileattr: %x\\n\", unpack(\"Q\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 27) {\n            printf(\"  unencoded_file_len: %x\\n\", unpack(\"Q\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 28) {\n            printf(\"  unencoded_len: %x\\n\", unpack(\"Q\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 29) {\n            printf(\"  unencoded_offset: %x\\n\", unpack(\"Q\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 30) {\n            printf(\"  compression: %x\\n\", unpack(\"V\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } elsif ($t == 31) {\n            printf(\"  encryption: %x\\n\", unpack(\"V\",substr($b,4,$l)));\n            $b=substr($b,$l+4);\n        } else {\n            printf(\"  unknown(%u),%x\\n\",$t,$l);\n            $b=substr($b,$l+4);\n        }\n    }\n}\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}