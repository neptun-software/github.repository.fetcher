{
  "metadata": {
    "timestamp": 1736710312914,
    "page": 106,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "beanstalkd/beanstalkd",
      "stars": 6574,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".codecov.yml",
          "type": "blob",
          "size": 0.740234375,
          "content": "codecov:\n  notify:\n    require_ci_to_pass: yes\n\ncoverage:\n  precision: 2\n  round: down\n  range: \"65...90\"\n\n  status:\n    project:\n      default:\n        threshold: 0.5 # Allow the coverage to drop by threshold %, and posting a success status.\n    patch:\n      default:\n        target: 0% # trial operation\n    changes: no\n\nparsers:\n  gcov:\n    branch_detection:\n      conditional: yes\n      loop: yes\n      method: no\n      macro: no\n\ncomment:\n  layout: \"header, diff\"\n  behavior: default\n  require_changes: no\n\nignore:\n  - \".git\"\n  - \"*.yml\"\n  - \"*.md\"\n  # ignore test files\n  - \"test*.c\"\n  # ignore sd-daemon.* since it's vendored as external lib\n  - \"sd-daemon.*\"\n  # ignore folders and all its contents\n  - \"adm/.*\"\n  - \"ct/.*\"\n  - \"doc/.*\"\n  - \"pkg/.*\"\n"
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.04296875,
          "content": "*.gcda\n*.gcno\n*.o\n/vers.c\n/beanstalkd\n/News\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.04296875,
          "content": "*.gcda\n*.gcno\n*.o\n/vers.c\n/beanstalkd\n/News\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.822265625,
          "content": "branches:\n    only:\n        - master\n\ngit:\n    quiet: true\n    depth: 5\n\nlanguage: c\n\naddons:\n    apt:\n      packages:\n          - lcov\n\ncompiler:\n    - clang\n    - gcc\n\nos:\n    - linux\n    - osx\n\nenv:\n    global:\n        - MAKEJOBS=\"-j$(getconf _NPROCESSORS_ONLN)\"\n        - TRAVIS_COMMIT_LOG=`git log --format=fuller -2`\n        - COVERAGE=OFF # Currently works only with gcc on linux\n\nbefore_script:\n    - '[[ \"${TRAVIS_OS_NAME}-${TRAVIS_COMPILER}\" != \"linux-gcc\" ]] || export COVERAGE=\"ON\"'\n\nscript:\n    - |\n      if [ $COVERAGE = \"ON\" ]; then\n          export LDFLAGS=\" -lgcov --coverage\"\n          export CFLAGS=\"-O0 -ggdb -fprofile-arcs -ftest-coverage\"\n      fi\n    - make $MAKEJOBS || ( echo \"Build failure. Verbose build follows.\" && make V=1 ; false )\n    - make check -j1 VERBOSE=1\n\njobs:\n  include:\n    - stage: Benchmark\n      os: linux\n      compiler: gcc\n      before_script:\n          - export COVERAGE=OFF\n      script:\n          - make $MAKEJOBS\n          - make $MAKEJOBS bench\n    - stage: Benchmark\n      os: linux\n      compiler: gcc\n      env:\n          - CFLAGS=\"-march=native -mtune=native -O3\"\n      before_script:\n          - export COVERAGE=OFF\n      script:\n          - make $MAKEJOBS\n          - make $MAKEJOBS bench\n    - stage: Benchmark\n      os: osx\n      compiler: clang\n      env:\n          - CFLAGS=\"-march=native -mtune=native -O3\"\n      before_script:\n          - export COVERAGE=OFF\n      script:\n          - make $MAKEJOBS\n          - make $MAKEJOBS bench\n    - stage: Benchmark\n      os: osx\n      compiler: clang\n      before_script:\n          - export COVERAGE=OFF\n      script:\n          - make $MAKEJOBS\n          - make $MAKEJOBS bench\n\nafter_success:\n    - '[[ \"$COVERAGE\" != \"ON\" ]] || bash <(curl -s https://codecov.io/bash)'\n\nafter_script:\n    - printf \"$TRAVIS_COMMIT_RANGE\\n\"\n    - printf \"$TRAVIS_COMMIT_LOG\\n\"\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 1.68359375,
          "content": "# Changelog\nAll notable changes to this project will be documented in this file.\n\n## [Unreleased]\n\n## [1.13] - 2023-03-12\n\n- maintenace fixes\n- set up CI using GH actions \n- quote string values in yaml dictionaries\n- use read_u32 to safely read reserve-with-timeout argument (#607)\n- fix pause-tube parameter (#604)\n- refactor code using tube_find and remove_ready_job functions (#600)\n- testserv: fix endianness issue (#594)\n- Make sure to quote os value in stats cmd (#592)\n- add dockerfile (#586)\n- exit when SIGTERM is received and pid is 1 (#585)\n- server: remove redundant listen (#583)\n\n## [1.12] - 2020-06-04\n\n- add support of UNIX domain sockets\n- add support of Solaris/illumos\n- add the \"reserve-job\" command\n- add draining status to the \"stats\" command\n- make fsync turned on by default when binlog is used: it's synced every 50ms instead of never\n- replace vendored systemd files with libsystemd\n- systemd usage can be controlled with USE_SYSTEMD=yes/no\n- specify C99 as required compiler\n\n## [1.11] - 2019-06-29\n\n- add automated testing via TravisCI\n- add System V init script\n- enable code coverage\n- misc. fixes and documentation improvements\n\n## [1.10] - 2014-08-05\n\n- fix crash on suspend or other EINTR (#220)\n- document touch command’s TTR reset (#188)\n- add some basic benchmark tests\n- add DESTDIR support to Makefile\n\n\n[unreleased]: https://github.com/beanstalkd/beanstalkd/compare/v1.12...HEAD\n[1.13]:\t\t  https://github.com/beanstalkd/beanstalkd/compare/v1.12...v1.13\n[1.12]:       https://github.com/beanstalkd/beanstalkd/compare/v1.11...v1.12\n[1.11]:       https://github.com/beanstalkd/beanstalkd/compare/v1.10...v1.11\n[1.10]:       https://github.com/beanstalkd/beanstalkd/compare/v1.9...v1.10\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.57421875,
          "content": "# Contributing to beanstalkd\n\nGreetings. Firstly, if you're thinking of contributing to\nbeanstalkd, thank you! It's the hard work of people like you that\nkeeps beanstalkd a high-quality codebase and running smoothly in\nthe demanding, high-volume production environment of the servers\nof many organizations around the world.\n\nPlease note that this project is released with a Contributor\nCode of Conduct. By participating in this project you agree\nto abide by its terms. See CodeOfConduct.txt for details.\n\n## General\n\nThis is a mature project, so it rarely takes on new features. We\nmostly focus on stability, bug fixing, clarity, and performance,\nin that order.\n\n## Issues\n\nWhen reporting a bug, please describe:\n\n- which version of beanstalkd you're using\n- steps to reproduce the bug\n- the behavior you saw\n- the behavior you expected\n\nIf you're not using the latest version, please consider also\ntesting with the latest. There's a good chance the bug you found\nhas already been fixed.\n\n## Good commit messages\n\nPlease see how to write good commit messages in the Go contributing guide\n[here](https://golang.org/doc/contribute.html#commit_messages).\n\n\n## Pull Requests\n\nWhen opening a pull request, try to keep the changes focused on\none topic and avoid unrelated changes (even small things, like\nediting punctuation or whitespace in comments).\n\nIf you're making big changes, consider discussing it on the\nmailing list first. You might save yourself a lot of time if it\nturns out that the changes you want to make aren't a good fit for\nthe project. This is especially true if you are adding new\nfunctionality.\n"
        },
        {
          "name": "CodeOfConduct.txt",
          "type": "blob",
          "size": 3.224609375,
          "content": "Contributor Covenant Code of Conduct\n\nOur Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\nOur Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\n\nExamples of unacceptable behavior by participants include:\n\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\nadvances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others’ private information, such as a physical or electronic\naddress, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\nprofessional setting\n\n\nOur Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\nScope\n\nThis Code of Conduct applies within all project spaces, and it also applies when\nan individual is representing the project or its community in public spaces.\nExamples of representing a project or community include using an official\nproject e-mail address, posting via an official social media account, or acting\nas an appointed representative at an online or offline event. Representation of\na project may be further defined and clarified by project maintainers.\n\nEnforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at beanstalk-team@googlegroups.com. All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project’s leadership.\n\nAttribution\n\nThis Code of Conduct is adapted from the Contributor Covenant, version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\nFor answers to common questions about this code of conduct, see\nhttps://www.contributor-covenant.org/faq\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.2861328125,
          "content": "ARG BASE=alpine\nFROM alpine as builder\nRUN apk add --no-cache build-base git\nCOPY . /tmp/beanstalkd\nRUN cd /tmp/beanstalkd && make\n\n################################\nARG BASE\nFROM ${BASE}\n\nCOPY --from=builder /tmp/beanstalkd/beanstalkd /usr/bin/\nEXPOSE 11300\nENTRYPOINT [\"/usr/bin/beanstalkd\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.1513671875,
          "content": "Copyright (c) 2007 The authors of beanstalkd.\n\nCopyright in contributions to beanstalkd is retained\nby the original copyright holder of each contribution.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.9541015625,
          "content": "PREFIX?=/usr/local\nBINDIR=$(DESTDIR)$(PREFIX)/bin\n\noverride CFLAGS+=-Wall -Werror -Wformat=2 -g\noverride LDFLAGS?=\n\nLDLIBS?=\n\nOS?=$(shell uname | tr 'A-Z' 'a-z')\nINSTALL?=install\nPKG_CONFIG?=pkg-config\n\nifeq ($(OS),sunos)\noverride LDFLAGS += -lxnet -lsocket -lnsl\nendif\n\nVERS=$(shell ./vers.sh)\nTARG=beanstalkd\nMOFILE=main.o\nOFILES=\\\n\t$(OS).o\\\n\tconn.o\\\n\tfile.o\\\n\theap.o\\\n\tjob.o\\\n\tms.o\\\n\tnet.o\\\n\tprimes.o\\\n\tprot.o\\\n\tserv.o\\\n\ttime.o\\\n\ttube.o\\\n\tutil.o\\\n\tvers.o\\\n\twalg.o\\\n\nTOFILES=\\\n\ttestheap.o\\\n\ttestjobs.o\\\n\ttestms.o\\\n\ttestserv.o\\\n\ttestutil.o\\\n\nHFILES=\\\n\tdat.h\\\n\nifeq ($(OS),linux)\n   LDLIBS+=-lrt\nendif\n\n# systemd support can be configured via USE_SYSTEMD:\n#        no: disabled\n#       yes: enabled, build fails if libsystemd is not found\n# otherwise: enabled if libsystemd is found\nifneq ($(USE_SYSTEMD),no)\nifeq ($(shell $(PKG_CONFIG) --exists libsystemd && echo $$?),0)\n\tLDLIBS+=$(shell $(PKG_CONFIG) --libs libsystemd)\n\tCPPFLAGS+=-DHAVE_LIBSYSTEMD\nelse\nifeq ($(USE_SYSTEMD),yes)\n$(error USE_SYSTEMD is set to \"$(USE_SYSTEMD)\", but $(PKG_CONFIG) cannot find libsystemd)\nendif\nendif\nendif\n\nCLEANFILES=\\\n\tvers.c\\\n\t$(wildcard *.gc*)\n\n.PHONY: all\nall: $(TARG)\n\n$(TARG): $(OFILES) $(MOFILE)\n\t$(LINK.o) -o $@ $^ $(LDLIBS)\n\n.PHONY: install\ninstall: $(BINDIR)/$(TARG)\n\n$(BINDIR)/%: %\n\t$(INSTALL) -d $(dir $@)\n\t$(INSTALL) $< $@\n\nCLEANFILES+=$(TARG)\n\n$(OFILES) $(MOFILE): $(HFILES)\n\nCLEANFILES+=$(wildcard *.o)\n\n.PHONY: clean\nclean:\n\trm -f $(CLEANFILES)\n\n.PHONY: check\ncheck: ct/_ctcheck\n\tct/_ctcheck\n\n.PHONY: bench\nbench: ct/_ctcheck\n\tct/_ctcheck -b\n\nct/_ctcheck: ct/_ctcheck.o ct/ct.o $(OFILES) $(TOFILES)\n\nct/_ctcheck.c: $(TOFILES) ct/gen\n\tct/gen $(TOFILES) >$@.part\n\tmv $@.part $@\n\nct/ct.o ct/_ctcheck.o: ct/ct.h ct/internal.h\n\n$(TOFILES): $(HFILES) ct/ct.h\n\nCLEANFILES+=$(wildcard ct/_* ct/*.o ct/*.gc*)\n\nifneq ($(shell ./verc.sh),$(shell cat vers.c 2>/dev/null))\n.PHONY: vers.c\nendif\nvers.c:\n\t./verc.sh >vers.c\n\ndoc/beanstalkd.1 doc/beanstalkd.1.html: doc/beanstalkd.ronn\n\tronn $<\n\nfreebsd.o: darwin.c\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.443359375,
          "content": "[![Build Status](https://github.com/beanstalkd/beanstalkd/actions/workflows/build-latest.yaml/badge.svg)](https://github.com/beanstalkd/beanstalkd/actions/workflows/build-latest.yaml)\n[![codecov](https://codecov.io/gh/beanstalkd/beanstalkd/branch/master/graph/badge.svg)](https://codecov.io/gh/beanstalkd/beanstalkd)\n\n# beanstalkd\n\nSimple and fast general purpose work queue.\n\nhttps://beanstalkd.github.io/\n\nSee [doc/protocol.txt](https://github.com/beanstalkd/beanstalkd/blob/master/doc/protocol.txt)\nfor details of the network protocol.\n\nPlease note that this project is released with a Contributor\nCode of Conduct. By participating in this project you agree\nto abide by its terms. See CodeOfConduct.txt for details.\n\n## Quick Start\n\n    $ make\n    $ ./beanstalkd\n\n\nalso try,\n\n    $ ./beanstalkd -h\n    $ ./beanstalkd -VVV\n    $ make CFLAGS=-O2\n    $ make CC=clang\n    $ make check\n    $ make install\n    $ make install PREFIX=/usr\n\nRequires Linux (2.6.17 or later), Mac OS X, FreeBSD, or Illumos.\n\nCurrently beanstalkd is tested with GCC and clang, but it should work\nwith any compiler that supports C99.\n\nUses ronn to generate the manual.\nSee http://github.com/rtomayko/ronn.\n\n\n## Subdirectories\n\n- `adm`\t- files useful for system administrators\n- `ct`\t- testing tool; vendored from https://github.com/kr/ct\n- `doc`\t- documentation\n- `pkg`\t- scripts to make releases\n\n\n## Tests\n\nUnit tests are in test*.c. See https://github.com/kr/ct for\ninformation on how to write them.\n\n"
        },
        {
          "name": "adm",
          "type": "tree",
          "content": null
        },
        {
          "name": "conn.c",
          "type": "blob",
          "size": 5.1416015625,
          "content": "#include \"dat.h\"\n#include <errno.h>\n#include <limits.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define SAFETY_MARGIN (1000000000) /* 1 second */\n\nstatic int cur_conn_ct = 0, cur_worker_ct = 0, cur_producer_ct = 0;\nstatic uint tot_conn_ct = 0;\nint verbose = 0;\n\nstatic void\non_watch(Ms *a, Tube *t, size_t i)\n{\n    UNUSED_PARAMETER(a);\n    UNUSED_PARAMETER(i);\n    tube_iref(t);\n    t->watching_ct++;\n}\n\nstatic void\non_ignore(Ms *a, Tube *t, size_t i)\n{\n    UNUSED_PARAMETER(a);\n    UNUSED_PARAMETER(i);\n    t->watching_ct--;\n    tube_dref(t);\n}\n\nConn *\nmake_conn(int fd, char start_state, Tube *use, Tube *watch)\n{\n    Conn *c = new(Conn);\n    if (!c) {\n        twarn(\"OOM\");\n        return NULL;\n    }\n\n    ms_init(&c->watch, (ms_event_fn) on_watch, (ms_event_fn) on_ignore);\n    if (!ms_append(&c->watch, watch)) {\n        free(c);\n        twarn(\"OOM\");\n        return NULL;\n    }\n\n    TUBE_ASSIGN(c->use, use);\n    use->using_ct++;\n\n    c->state = start_state;\n    c->pending_timeout = -1;\n    c->tickpos = 0; // Does not mean anything if in_conns is set to 0.\n    c->in_conns = 0;\n\n    // The list is empty.\n    job_list_reset(&c->reserved_jobs);\n\n    /* stats */\n    cur_conn_ct++;\n    tot_conn_ct++;\n\n    return c;\n}\n\nvoid\nconnsetproducer(Conn *c)\n{\n    if (c->type & CONN_TYPE_PRODUCER) return;\n    c->type |= CONN_TYPE_PRODUCER;\n    cur_producer_ct++; /* stats */\n}\n\nvoid\nconnsetworker(Conn *c)\n{\n    if (c->type & CONN_TYPE_WORKER) return;\n    c->type |= CONN_TYPE_WORKER;\n    cur_worker_ct++; /* stats */\n}\n\nint\ncount_cur_conns()\n{\n    return cur_conn_ct;\n}\n\nuint\ncount_tot_conns()\n{\n    return tot_conn_ct;\n}\n\nint\ncount_cur_producers()\n{\n    return cur_producer_ct;\n}\n\nint\ncount_cur_workers()\n{\n    return cur_worker_ct;\n}\n\nstatic int\nhas_reserved_job(Conn *c)\n{\n    return !job_list_is_empty(&c->reserved_jobs);\n}\n\n\n// Returns positive nanoseconds when c should tick, 0 otherwise.\nstatic int64\nconntickat(Conn *c)\n{\n    int margin = 0, should_timeout = 0;\n    int64 t = INT64_MAX;\n\n    if (conn_waiting(c)) {\n        margin = SAFETY_MARGIN;\n    }\n\n    if (has_reserved_job(c)) {\n        t = connsoonestjob(c)->r.deadline_at - nanoseconds() - margin;\n        should_timeout = 1;\n    }\n    if (c->pending_timeout >= 0) {\n        t = min(t, ((int64)c->pending_timeout) * 1000000000);\n        should_timeout = 1;\n    }\n\n    if (should_timeout) {\n        return nanoseconds() + t;\n    }\n    return 0;\n}\n\n\n// Remove c from the c->srv heap and reschedule it using the value\n// returned by conntickat if there is an outstanding timeout in the c.\nvoid\nconnsched(Conn *c)\n{\n    if (c->in_conns) {\n        heapremove(&c->srv->conns, c->tickpos);\n        c->in_conns = 0;\n    }\n    c->tickat = conntickat(c);\n    if (c->tickat) {\n        heapinsert(&c->srv->conns, c);\n        c->in_conns = 1;\n    }\n}\n\n// conn_set_soonestjob updates c->soonest_job with j\n// if j should be handled sooner than c->soonest_job.\nstatic void\nconn_set_soonestjob(Conn *c, Job *j) {\n    if (!c->soonest_job || j->r.deadline_at < c->soonest_job->r.deadline_at) {\n        c->soonest_job = j;\n    }\n}\n\n// Return the reserved job with the earliest deadline,\n// or NULL if there's no reserved job.\nJob *\nconnsoonestjob(Conn *c)\n{\n    // use cached value and bail out.\n    if (c->soonest_job != NULL)\n        return c->soonest_job;\n\n    Job *j = NULL;\n    for (j = c->reserved_jobs.next; j != &c->reserved_jobs; j = j->next) {\n        conn_set_soonestjob(c, j);\n    }\n    return c->soonest_job;\n}\n\nvoid\nconn_reserve_job(Conn *c, Job *j) {\n    j->tube->stat.reserved_ct++;\n    j->r.reserve_ct++;\n\n    j->r.deadline_at = nanoseconds() + j->r.ttr;\n    j->r.state = Reserved;\n    job_list_insert(&c->reserved_jobs, j);\n    j->reserver = c;\n    c->pending_timeout = -1;\n    conn_set_soonestjob(c, j);\n}\n\n// Return true if c has a reserved job with less than one second until its\n// deadline.\nint\nconndeadlinesoon(Conn *c)\n{\n    int64 t = nanoseconds();\n    Job *j = connsoonestjob(c);\n\n    return j && t >= j->r.deadline_at - SAFETY_MARGIN;\n}\n\nint\nconn_ready(Conn *c)\n{\n    size_t i;\n\n    for (i = 0; i < c->watch.len; i++) {\n        if (((Tube *) c->watch.items[i])->ready.len)\n            return 1;\n    }\n    return 0;\n}\n\n\nint\nconn_less(void *ca, void *cb)\n{\n    Conn *a = (Conn *)ca;\n    Conn *b = (Conn *)cb;\n    return a->tickat < b->tickat;\n}\n\n\nvoid\nconn_setpos(void *c, size_t i)\n{\n    ((Conn *)c)->tickpos = i;\n}\n\n\nvoid\nconnclose(Conn *c)\n{\n    sockwant(&c->sock, 0);\n    close(c->sock.fd);\n    if (verbose) {\n        printf(\"close %d\\n\", c->sock.fd);\n    }\n\n    job_free(c->in_job);\n\n    /* was this a peek or stats command? */\n    if (c->out_job && c->out_job->r.state == Copy)\n        job_free(c->out_job);\n\n    c->in_job = c->out_job = NULL;\n    c->in_job_read = 0;\n\n    if (c->type & CONN_TYPE_PRODUCER) cur_producer_ct--; /* stats */\n    if (c->type & CONN_TYPE_WORKER) cur_worker_ct--; /* stats */\n\n    cur_conn_ct--; /* stats */\n\n    remove_waiting_conn(c);\n    if (has_reserved_job(c))\n        enqueue_reserved_jobs(c);\n\n    ms_clear(&c->watch);\n    c->use->using_ct--;\n    TUBE_ASSIGN(c->use, NULL);\n\n    if (c->in_conns) {\n        heapremove(&c->srv->conns, c->tickpos);\n        c->in_conns = 0;\n    }\n\n    free(c);\n}\n"
        },
        {
          "name": "ct",
          "type": "tree",
          "content": null
        },
        {
          "name": "darwin.c",
          "type": "blob",
          "size": 1.765625,
          "content": "#include \"dat.h\"\n#include <stdint.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/event.h>\n#include <sys/time.h>\n\nenum\n{\n    Infinity = 1 << 30\n};\n\nstatic int  kq;\n\n\nint\nsockinit(void)\n{\n    kq = kqueue();\n    if (kq == -1) {\n        twarn(\"kqueue\");\n        return -1;\n    }\n    return 0;\n}\n\n\nint\nsockwant(Socket *s, int rw)\n{\n    int n = 0;\n    struct kevent evs[2] = {{0}};\n    struct kevent *ev = evs;\n    struct timespec ts = {.tv_sec = 0, .tv_nsec = 0};\n\n    if (s->added) {\n        ev->ident = s->fd;\n        ev->filter = s->added;\n        ev->flags = EV_DELETE;\n        ev++;\n        n++;\n    }\n\n    if (rw) {\n        ev->ident = s->fd;\n        switch (rw) {\n        case 'r':\n            ev->filter = EVFILT_READ;\n            break;\n        case 'w':\n            ev->filter = EVFILT_WRITE;\n            break;\n        default:\n            // check only for hangup\n            ev->filter = EVFILT_READ;\n            ev->fflags = NOTE_LOWAT;\n            ev->data = Infinity;\n        }\n        ev->flags = EV_ADD;\n        ev->udata = s;\n        s->added = ev->filter;\n        ev++;\n        n++;\n    }\n\n    return kevent(kq, evs, n, NULL, 0, &ts);\n}\n\n\nint\nsocknext(Socket **s, int64 timeout)\n{\n    int r;\n    struct kevent ev;\n    static struct timespec ts;\n\n    ts.tv_sec = timeout / 1000000000;\n    ts.tv_nsec = timeout % 1000000000;\n    r = kevent(kq, NULL, 0, &ev, 1, &ts);\n    if (r == -1 && errno != EINTR) {\n        twarn(\"kevent\");\n        return -1;\n    }\n\n    if (r > 0) {\n        *s = ev.udata;\n        if (ev.flags & EV_EOF) {\n            return 'h';\n        }\n        switch (ev.filter) {\n        case EVFILT_READ:\n            return 'r';\n        case EVFILT_WRITE:\n            return 'w';\n        }\n    }\n    return 0;\n}\n"
        },
        {
          "name": "dat.h",
          "type": "blob",
          "size": 13.806640625,
          "content": "#include <stdint.h>\n#include <stdlib.h>\n\ntypedef unsigned char uchar;\ntypedef uchar         byte;\ntypedef unsigned int  uint;\ntypedef int32_t       int32;\ntypedef uint32_t      uint32;\ntypedef int64_t       int64;\ntypedef uint64_t      uint64;\n\ntypedef struct Ms     Ms;\ntypedef struct Job    Job;\ntypedef struct Tube   Tube;\ntypedef struct Conn   Conn;\ntypedef struct Heap   Heap;\ntypedef struct Jobrec Jobrec;\ntypedef struct File   File;\ntypedef struct Socket Socket;\ntypedef struct Server Server;\ntypedef struct Wal    Wal;\n\ntypedef void(*Handle)(void*, int rw);\ntypedef int(FAlloc)(int, int);\n\n\n// NUM_PRIMES is used in the jobs hashing.\n#if _LP64\n#define NUM_PRIMES 48\n#else\n#define NUM_PRIMES 19\n#endif\n\n/* Some compilers (e.g. gcc on SmartOS) define NULL as 0.\n * This is allowed by the C standard, but is unhelpful when\n * using NULL in most pointer contexts with errors turned on. */\n#if (defined(sun) || defined(__sun)) && (defined(__SVR4) || defined(__svr4__))\n#ifdef NULL\n#undef NULL\n#endif\n#define NULL ((void*)0)\n#endif\n\n// The name of a tube cannot be longer than MAX_TUBE_NAME_LEN-1\n#define MAX_TUBE_NAME_LEN 201\n\n// A command can be at most LINE_BUF_SIZE chars, including \"\\r\\n\". This value\n// MUST be enough to hold the longest possible command (\"pause-tube a{200} 4294967295\\r\\n\")\n// or reply line (\"USING a{200}\\r\\n\").\n#define LINE_BUF_SIZE (11 + MAX_TUBE_NAME_LEN + 12)\n\n#define min(a,b) ((a)<(b)?(a):(b))\n\n// Jobs with priority less than URGENT_THRESHOLD are counted as urgent.\n#define URGENT_THRESHOLD 1024\n\n// The default maximum job size.\n#define JOB_DATA_SIZE_LIMIT_DEFAULT ((1 << 16) - 1)\n\n// The maximum value that job_data_size_limit can be set to via \"-z\".\n// It could be up to INT32_MAX-2 (~2GB), but set it to 1024^3 (1GB).\n// The width is restricted by Jobrec.body_size that is int32.\n#define JOB_DATA_SIZE_LIMIT_MAX 1073741824\n\n// The default value for the fsync (-f) parameter, milliseconds.\n#define DEFAULT_FSYNC_MS 50\n\n// Use this macro to designate unused parameters in functions.\n#define UNUSED_PARAMETER(x) (void)(x)\n\n// version is defined in vers.c, see vers.sh for details.\nextern const char version[];\n\n// verbose holds the count of -V parameters; it's a verbosity level.\nextern int verbose;\n\nextern struct Server srv;\n\n// Replaced by tests to simulate failures.\nextern FAlloc *falloc;\n\n// stats structure holds counters for operations, both globally and per tube.\nstruct stats {\n    uint64 urgent_ct;\n    uint64 waiting_ct;\n    uint64 buried_ct;\n    uint64 reserved_ct;\n    uint64 pause_ct;\n    uint64 total_delete_ct;\n    uint64 total_jobs_ct;\n};\n\n\n// less_fn is used by the binary heap to determine the order of elements.\ntypedef int(*less_fn)(void*, void*);\n\n// setpos_fn is used by the binary heap to record the new positions of elements\n// whenever they get moved or inserted.\ntypedef void(*setpos_fn)(void*, size_t);\n\nstruct Heap {\n    size_t  cap;                // capacity of the heap\n    size_t  len;                // amount of elements in the heap\n    void    **data;             // actual elements\n\n    less_fn   less;\n    setpos_fn setpos;\n};\nint   heapinsert(Heap *h, void *x);\nvoid* heapremove(Heap *h, size_t k);\n\n\nstruct Socket {\n    // Descriptor for the socket.\n    int    fd;\n\n    // f can point to srvaccept or prothandle.\n    Handle f;\n\n    // x is passed as first parameter to f.\n    void   *x;\n\n    // added value is platform dependend: on OSX it can be > 1.\n    // Value of 1 - socket was already added to event notifications,\n    // otherwise it is 0.\n    int    added;\n};\n\nint sockinit(void);\n\n// sockwant updates event filter for the socket s. rw designates\n// the kind of event we should be notified about:\n// 'r' - read\n// 'w' - write\n// 'h' - hangup (closed connection)\n// 0   - ignore this socket\nint sockwant(Socket *s, int rw);\n\n// socknext waits for the next event at most timeout nanoseconds.\n// If event happens before timeout then s points to the corresponding socket,\n// and the kind of event is returned. In case of timeout, 0 is returned.\nint socknext(Socket **s, int64 timeout);\n\n\n// ms_event_fn is called with the element being inserted/removed and its position.\ntypedef void(*ms_event_fn)(Ms *a, void *item, size_t i);\n\n// Resizable multiset\nstruct Ms {\n    size_t len;                // amount of stored elements\n    size_t cap;                // capacity\n    size_t last;               // position of last taken element\n    void **items;\n\n    ms_event_fn oninsert;      // called on insertion of an element\n    ms_event_fn onremove;      // called on removal of an element\n};\n\nvoid ms_init(Ms *a, ms_event_fn oninsert, ms_event_fn onremove);\nvoid ms_clear(Ms *a);\nint ms_append(Ms *a, void *item);\nint ms_remove(Ms *a, void *item);\nint ms_contains(Ms *a, void *item);\nvoid *ms_take(Ms *a);\n\n\nenum // Jobrec.state\n{\n    Invalid,\n    Ready,\n    Reserved,\n    Buried,\n    Delayed,\n    Copy\n};\n\nenum\n{\n    Walver = 7\n};\n\n// If you modify Jobrec struct, you must increment Walver above.\n//\n// This workflow is expected:\n// 1. If any change needs to be made to the format, first increment Walver.\n// 2. If and only if this is the first such change since the last release:\n//    a. Copy-paste relevant file-reading functions in file.c and\n//       add the old version number to their names. For example,\n//       if you are incrementing Walver from 7 to 8, copy readrec to readrec7.\n//       (Currently, there is only one such function, readrec. But if\n//       a future readrec calls other version-specific functions,\n//       those will have to be copied too.)\n// 3. Add a switch case to fileread for the old version.\n// 4. Modify the current reading function (readrec) to reflect your change.\n//\n// Incrementing Walver for every change, even if not every version\n// will be released, is helpful even if it \"wastes\" version numbers.\n// It is a really easy thing to do and it means during development\n// you won't have to worry about misinterpreting the contents of a binlog\n// that you generated with a dev copy of beanstalkd.\n\nstruct Jobrec {\n    uint64 id;\n    uint32 pri;\n    int64  delay;\n    int64  ttr;\n    int32  body_size;\n    int64  created_at;\n\n    // deadline_at is a timestamp, in nsec, that points to:\n    // * time when job will become ready for delayed job,\n    // * time when TTR is about to expire for reserved job,\n    // * undefined otherwise.\n    int64  deadline_at;\n\n    uint32 reserve_ct;\n    uint32 timeout_ct;\n    uint32 release_ct;\n    uint32 bury_ct;\n    uint32 kick_ct;\n    byte   state;\n};\n\nstruct Job {\n     // persistent fields; these get written to the wal\n    Jobrec r;\n\n    // bookeeping fields; these are in-memory only\n    char pad[6];\n    Tube *tube;\n    Job *prev, *next;           // linked list of jobs\n    Job *ht_next;               // Next job in a hash table list\n    size_t heap_index;          // where is this job in its current heap\n    File *file;\n    Job  *fnext;\n    Job  *fprev;\n    void *reserver;\n    int walresv;\n    int walused;\n\n    char *body;                 // written separately to the wal\n};\n\nstruct Tube {\n    uint refs;\n    char name[MAX_TUBE_NAME_LEN];\n    Heap ready;\n    Heap delay;\n    Ms waiting_conns;           // conns waiting for the job at this moment\n    struct stats stat;\n    uint using_ct;\n    uint watching_ct;\n\n    // pause is set to the duration of the current pause, otherwise 0, in nsec.\n    int64 pause;\n\n    // unpause_at is a timestamp when to unpause the tube, in nsec.\n    int64 unpause_at;\n\n    Job buried;                 // linked list header\n};\n\n\n// Prints warning message on stderr in the format:\n// <progname>: FILE:LINE in FUNC: <fmt>: <errno_msg>\n#define twarn(...) __twarn(__VA_ARGS__, \"\")\n\n// Hack to quiet the compiler. When VA_ARGS in twarn() has one element,\n// e.g. twarn(\"OOM\"), its replaced with __twarn(\"OOM\", \"\"),\n// thus VA_ARGS is expanded to at least one element in warn().\n#define __twarn(fmt, ...) \\\n    warn(\"%s:%d in %s: \" fmt \"%s\", __FILE__, __LINE__, __func__, __VA_ARGS__)\n\n// Prints warning message on stderr in the format:\n// <progname>: FILE:LINE in FUNC: <fmt>\n#define twarnx(...) __twarnx(__VA_ARGS__, \"\")\n\n// See __twarn macro.\n#define __twarnx(fmt, ...) \\\n    warnx(\"%s:%d in %s: \" fmt \"%s\", __FILE__, __LINE__, __func__, __VA_ARGS__)\n\nvoid warn(const char *fmt, ...) __attribute__((format(printf, 1, 2)));\nvoid warnx(const char *fmt, ...) __attribute__((format(printf, 1, 2)));\nchar* fmtalloc(char *fmt, ...) __attribute__((format(printf, 1, 2)));\nvoid* zalloc(int n);\n#define new(T) zalloc(sizeof(T))\nvoid optparse(Server*, char**);\n\nextern const char *progname;\n\nint64 nanoseconds(void);\nint   rawfalloc(int fd, int len);\n\n// Take ID for a jobs from next_id and allocate and store the job.\n#define make_job(pri,delay,ttr,body_size,tube) \\\n    make_job_with_id(pri,delay,ttr,body_size,tube,0)\n\nJob *allocate_job(int body_size);\nJob *make_job_with_id(uint pri, int64 delay, int64 ttr,\n                      int body_size, Tube *tube, uint64 id);\nvoid job_free(Job *j);\n\n/* Lookup a job by job ID */\nJob *job_find(uint64 job_id);\n\n/* the void* parameters are really job pointers */\nvoid job_setpos(void *j, size_t pos);\nint job_pri_less(void *ja, void *jb);\nint job_delay_less(void *ja, void *jb);\n\nJob *job_copy(Job *j);\n\nconst char * job_state(Job *j);\n\nvoid job_list_reset(Job *head);\nint job_list_is_empty(Job *head);\nJob *job_list_remove(Job *j);\nvoid job_list_insert(Job *head, Job *j);\n\n/* for unit tests */\nsize_t get_all_jobs_used(void);\n\n\nextern struct Ms tubes;\n\nTube *make_tube(const char *name);\nvoid  tube_dref(Tube *t);\nvoid  tube_iref(Tube *t);\nTube *tube_find(Ms *tubeset, const char *name);\nTube *tube_find_or_make(const char *name);\n#define TUBE_ASSIGN(a,b) (tube_dref(a), (a) = (b), tube_iref(a))\n\n\nConn *make_conn(int fd, char start_state, Tube *use, Tube *watch);\n\nint count_cur_conns(void);\nuint count_tot_conns(void);\nint count_cur_producers(void);\nint count_cur_workers(void);\n\n\nextern size_t primes[];\n\n\nextern size_t job_data_size_limit;\n\nvoid prot_init(void);\nint64 prottick(Server *s);\n\nvoid remove_waiting_conn(Conn *c);\n\nvoid enqueue_reserved_jobs(Conn *c);\n\nvoid enter_drain_mode(int sig);\nvoid h_accept(const int fd, const short which, Server *s);\nint  prot_replay(Server *s, Job *list);\n\n\nint make_server_socket(char *host, char *port);\n\n\n// CONN_TYPE_* are bit masks used to track the type of connection.\n// A put command adds the PRODUCER type, \"reserve*\" adds the WORKER type.\n// If connection awaits for data, then it has WAITING type.\n#define CONN_TYPE_PRODUCER 1\n#define CONN_TYPE_WORKER   2\n#define CONN_TYPE_WAITING  4\n\nstruct Conn {\n    Server *srv;\n    Socket sock;\n    char   state;       // see the STATE_* description\n    char   type;        // combination of CONN_TYPE_* values\n    Conn   *next;       // only used in epollq functions\n    Tube   *use;        // tube currently in use\n    int64  tickat;      // time at which to do more work; determines pos in heap\n    size_t tickpos;     // position in srv->conns, stale when in_conns=0\n    byte   in_conns;    // 1 if the conn is in srv->conns heap, 0 otherwise\n    Job    *soonest_job;// memoization of the soonest job\n    int    rw;          // currently want: 'r', 'w', or 'h'\n\n    // How long client should \"wait\" for the next job; -1 means forever.\n    int    pending_timeout;\n\n    // Used to inform state machine that client no longer waits for the data.\n    char   halfclosed;\n\n    char   cmd[LINE_BUF_SIZE];     // this string is NOT NUL-terminated\n    size_t cmd_len;\n    int    cmd_read;\n\n    char *reply;\n    int  reply_len;\n    int  reply_sent;\n    char reply_buf[LINE_BUF_SIZE]; // this string IS NUL-terminated\n\n    // How many bytes of in_job->body have been read so far. If in_job is NULL\n    // while in_job_read is nonzero, we are in bit bucket mode and\n    // in_job_read's meaning is inverted -- then it counts the bytes that\n    // remain to be thrown away.\n    int64 in_job_read;\n    Job   *in_job;              // a job to be read from the client\n\n    Job *out_job;               // a job to be sent to the client\n    int out_job_sent;           // how many bytes of *out_job were sent already\n\n    Ms  watch;                  // the set of watched tubes by the connection\n    Job reserved_jobs;          // linked list header\n};\nint  conn_less(void *ca, void *cb);\nvoid conn_setpos(void *c, size_t i);\nvoid connsched(Conn *c);\nvoid connclose(Conn *c);\nvoid connsetproducer(Conn *c);\nvoid connsetworker(Conn *c);\nJob *connsoonestjob(Conn *c);\nint  conndeadlinesoon(Conn *c);\nint conn_ready(Conn *c);\nvoid conn_reserve_job(Conn *c, Job *j);\n#define conn_waiting(c) ((c)->type & CONN_TYPE_WAITING)\n\n\n\n\nenum\n{\n    Filesizedef = (10 << 20)\n};\n\nstruct Wal {\n    int    filesize;\n    int    use;\n    char   *dir;\n    File   *head;\n    File   *cur;\n    File   *tail;\n    int    nfile;\n    int    next;\n    int64  resv;  // bytes reserved\n    int64  alive; // bytes in use\n    int64  nmig;  // migrations\n    int64  nrec;  // records written ever\n    int    wantsync; // do we sync to disk?\n    int64  syncrate; // how often we sync to disk, in nanoseconds\n    int64  lastsync;\n};\nint  waldirlock(Wal*);\nvoid walinit(Wal*, Job *list);\nint  walwrite(Wal*, Job*);\nvoid walmaint(Wal*);\nint  walresvput(Wal*, Job*);\nint  walresvupdate(Wal*);\nvoid walgc(Wal*);\n\n\nstruct File {\n    File *next;\n    uint refs;\n    int  seq;\n    int  iswopen; // is open for writing\n    int  fd;\n    int  free;\n    int  resv;\n    char *path;\n    Wal  *w;\n\n    Job jlist;    // jobs written in this file\n};\nint  fileinit(File*, Wal*, int);\nWal* fileadd(File*, Wal*);\nvoid fileincref(File*);\nvoid filedecref(File*);\nvoid fileaddjob(File*, Job*);\nvoid filermjob(File*, Job*);\nint  fileread(File*, Job *list);\nvoid filewopen(File*);\nvoid filewclose(File*);\nint  filewrjobshort(File*, Job*);\nint  filewrjobfull(File*, Job*);\n\n\n#define Portdef \"11300\"\n\nstruct Server {\n    char *port;\n    char *addr;\n    char *user;\n\n    Wal    wal;\n    Socket sock;\n\n    // Connections that must produce deadline or timeout, ordered by the time.\n    Heap   conns;\n};\nvoid srv_acquire_wal(Server *s);\nvoid srvserve(Server *s);\nvoid srvaccept(Server *s, int ev);\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "file.c",
          "type": "blob",
          "size": 12.8759765625,
          "content": "#include \"dat.h\"\n#include <stdint.h>\n#include <inttypes.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <string.h>\n\nstatic int  readrec(File*, Job *, int*);\nstatic int  readrec5(File*, Job *, int*);\nstatic int  readfull(File*, void*, int, int*, char*);\nstatic void warnpos(File*, int, char*, ...)\n__attribute__((format(printf, 3, 4)));\n\nFAlloc *falloc = &rawfalloc;\n\nenum\n{\n    Walver5 = 5\n};\n\ntypedef struct Jobrec5 Jobrec5;\n\nstruct Jobrec5 {\n    uint64 id;\n    uint32 pri;\n    uint64 delay; // usec\n    uint64 ttr; // usec\n    int32  body_size;\n    uint64 created_at; // usec\n    uint64 deadline_at; // usec\n    uint32 reserve_ct;\n    uint32 timeout_ct;\n    uint32 release_ct;\n    uint32 bury_ct;\n    uint32 kick_ct;\n    byte   state;\n\n    char pad[1];\n};\n\nenum\n{\n\tJobrec5size = offsetof(Jobrec5, pad)\n};\n\n// rawfalloc allocates disk space of len bytes.\n// It expects fd's offset to be 0; may also reset fd's offset to 0.\n// Returns 0 on success, and a positive errno otherwise.\nint\nrawfalloc(int fd, int len)\n{\n    // We do not use ftruncate() because it might extend the file\n    // with a sequence of null bytes or a hole.\n    // posix_fallocate() is not portable enough, might fail for NFS.\n    static char buf[4096] = {0};\n    int i, w;\n\n    for (i = 0; i < len; i += w) {\n        w = write(fd, buf, sizeof buf);\n        if (w == -1)\n            return errno;\n    }\n    lseek(fd, 0, 0);            // do not care if this fails\n    return 0;\n}\n\nvoid\nfileincref(File *f)\n{\n    if (!f) return;\n    f->refs++;\n}\n\n\nvoid\nfiledecref(File *f)\n{\n    if (!f) return;\n    f->refs--;\n    if (f->refs < 1) {\n        walgc(f->w);\n    }\n}\n\n\nvoid\nfileaddjob(File *f, Job *j)\n{\n    Job *h;\n\n    h = &f->jlist;\n    if (!h->fprev) h->fprev = h;\n    j->file = f;\n    j->fprev = h->fprev;\n    j->fnext = h;\n    h->fprev->fnext = j;\n    h->fprev = j;\n    fileincref(f);\n}\n\n\nvoid\nfilermjob(File *f, Job *j)\n{\n    if (!f) return;\n    if (f != j->file) return;\n    j->fnext->fprev = j->fprev;\n    j->fprev->fnext = j->fnext;\n    j->fnext = 0;\n    j->fprev = 0;\n    j->file = NULL;\n    f->w->alive -= j->walused;\n    j->walused = 0;\n    filedecref(f);\n}\n\n\n// Fileread reads jobs from f->path into list.\n// It returns 0 on success, or 1 if any errors occurred.\nint\nfileread(File *f, Job *list)\n{\n    int err = 0, v;\n\n    if (!readfull(f, &v, sizeof(v), &err, \"version\")) {\n        return err;\n    }\n    switch (v) {\n    case Walver:\n        fileincref(f);\n        while (readrec(f, list, &err));\n        filedecref(f);\n        return err;\n    case Walver5:\n        fileincref(f);\n        while (readrec5(f, list, &err));\n        filedecref(f);\n        return err;\n    }\n\n    warnx(\"%s: unknown version: %d\", f->path, v);\n    return 1;\n}\n\n\n// Readrec reads a record from f->fd into linked list l.\n// If an error occurs, it sets *err to 1.\n// Readrec returns the number of records read, either 1 or 0.\nstatic int\nreadrec(File *f, Job *l, int *err)\n{\n    int r, sz = 0;\n    int namelen;\n    Jobrec jr;\n    Job *j;\n    Tube *t;\n    char tubename[MAX_TUBE_NAME_LEN];\n\n    r = read(f->fd, &namelen, sizeof(int));\n    if (r == -1) {\n        twarn(\"read\");\n        warnpos(f, 0, \"error\");\n        *err = 1;\n        return 0;\n    }\n    if (r != sizeof(int)) {\n        return 0;\n    }\n    sz += r;\n    if (namelen >= MAX_TUBE_NAME_LEN) {\n        warnpos(f, -r, \"namelen %d exceeds maximum of %d\", namelen, MAX_TUBE_NAME_LEN - 1);\n        *err = 1;\n        return 0;\n    }\n\n    if (namelen < 0) {\n        warnpos(f, -r, \"namelen %d is negative\", namelen);\n        *err = 1;\n        return 0;\n    }\n\n    if (namelen) {\n        r = readfull(f, tubename, namelen, err, \"tube name\");\n        if (!r) {\n            return 0;\n        }\n        sz += r;\n    }\n    tubename[namelen] = '\\0';\n\n    r = readfull(f, &jr, sizeof(Jobrec), err, \"job struct\");\n    if (!r) {\n        return 0;\n    }\n    sz += r;\n\n    // are we reading trailing zeroes?\n    if (!jr.id) return 0;\n\n    j = job_find(jr.id);\n    if (!(j || namelen)) {\n        // We read a short record without having seen a\n        // full record for this job, so the full record\n        // was in an earlier file that has been deleted.\n        // Therefore the job itself has either been\n        // deleted or migrated; either way, this record\n        // should be ignored.\n        return 1;\n    }\n\n    switch (jr.state) {\n    case Reserved:\n        jr.state = Ready;\n        /* Falls through */\n    case Ready:\n    case Buried:\n    case Delayed:\n        if (!j) {\n            if ((size_t)jr.body_size > job_data_size_limit) {\n                warnpos(f, -r, \"job %\"PRIu64\" is too big (%\"PRId32\" > %zu)\",\n                        jr.id,\n                        jr.body_size,\n                        job_data_size_limit);\n                goto Error;\n            }\n            t = tube_find_or_make(tubename);\n            j = make_job_with_id(jr.pri, jr.delay, jr.ttr, jr.body_size,\n                                 t, jr.id);\n            job_list_reset(j);\n            j->r.created_at = jr.created_at;\n        }\n        j->r = jr;\n        job_list_insert(l, j);\n\n        // full record; read the job body\n        if (namelen) {\n            if (jr.body_size != j->r.body_size) {\n                warnpos(f, -r, \"job %\"PRIu64\" size changed\", j->r.id);\n                warnpos(f, -r, \"was %d, now %d\", j->r.body_size, jr.body_size);\n                goto Error;\n            }\n            r = readfull(f, j->body, j->r.body_size, err, \"job body\");\n            if (!r) {\n                goto Error;\n            }\n            sz += r;\n\n            // since this is a full record, we can move\n            // the file pointer and decref the old\n            // file, if any\n            filermjob(j->file, j);\n            fileaddjob(f, j);\n        }\n        j->walused += sz;\n        f->w->alive += sz;\n\n        return 1;\n    case Invalid:\n        if (j) {\n            job_list_remove(j);\n            filermjob(j->file, j);\n            job_free(j);\n        }\n        return 1;\n    }\n\nError:\n    *err = 1;\n    if (j) {\n        job_list_remove(j);\n        filermjob(j->file, j);\n        job_free(j);\n    }\n    return 0;\n}\n\n\n// Readrec5 is like readrec, but it reads a record in \"version 5\"\n// of the log format.\nstatic int\nreadrec5(File *f, Job *l, int *err)\n{\n    int r, sz = 0;\n    size_t namelen;\n    Jobrec5 jr;\n    Job *j;\n    Tube *t;\n    char tubename[MAX_TUBE_NAME_LEN];\n\n    r = read(f->fd, &namelen, sizeof(namelen));\n    if (r == -1) {\n        twarn(\"read\");\n        warnpos(f, 0, \"error\");\n        *err = 1;\n        return 0;\n    }\n    if (r != sizeof(namelen)) {\n        return 0;\n    }\n    sz += r;\n    if (namelen >= MAX_TUBE_NAME_LEN) {\n        warnpos(f, -r, \"namelen %zu exceeds maximum of %d\", namelen, MAX_TUBE_NAME_LEN - 1);\n        *err = 1;\n        return 0;\n    }\n\n    if (namelen) {\n        r = readfull(f, tubename, namelen, err, \"v5 tube name\");\n        if (!r) {\n            return 0;\n        }\n        sz += r;\n    }\n    tubename[namelen] = '\\0';\n\n    r = readfull(f, &jr, Jobrec5size, err, \"v5 job struct\");\n    if (!r) {\n        return 0;\n    }\n    sz += r;\n\n    // are we reading trailing zeroes?\n    if (!jr.id) return 0;\n\n    j = job_find(jr.id);\n    if (!(j || namelen)) {\n        // We read a short record without having seen a\n        // full record for this job, so the full record\n        // was in an eariler file that has been deleted.\n        // Therefore the job itself has either been\n        // deleted or migrated; either way, this record\n        // should be ignored.\n        return 1;\n    }\n\n    switch (jr.state) {\n    case Reserved:\n        jr.state = Ready;\n        /* Falls through */\n    case Ready:\n    case Buried:\n    case Delayed:\n        if (!j) {\n            if ((size_t)jr.body_size > job_data_size_limit) {\n                warnpos(f, -r, \"job %\"PRIu64\" is too big (%\"PRId32\" > %zu)\",\n                        jr.id,\n                        jr.body_size,\n                        job_data_size_limit);\n                goto Error;\n            }\n            t = tube_find_or_make(tubename);\n            j = make_job_with_id(jr.pri, jr.delay, jr.ttr, jr.body_size,\n                                 t, jr.id);\n            job_list_reset(j);\n        }\n        j->r.id = jr.id;\n        j->r.pri = jr.pri;\n        j->r.delay = jr.delay * 1000; // us => ns\n        j->r.ttr = jr.ttr * 1000; // us => ns\n        j->r.body_size = jr.body_size;\n        j->r.created_at = jr.created_at * 1000; // us => ns\n        j->r.deadline_at = jr.deadline_at * 1000; // us => ns\n        j->r.reserve_ct = jr.reserve_ct;\n        j->r.timeout_ct = jr.timeout_ct;\n        j->r.release_ct = jr.release_ct;\n        j->r.bury_ct = jr.bury_ct;\n        j->r.kick_ct = jr.kick_ct;\n        j->r.state = jr.state;\n        job_list_insert(l, j);\n\n        // full record; read the job body\n        if (namelen) {\n            if (jr.body_size != j->r.body_size) {\n                warnpos(f, -r, \"job %\"PRIu64\" size changed\", j->r.id);\n                warnpos(f, -r, \"was %\"PRId32\", now %\"PRId32, j->r.body_size, jr.body_size);\n                goto Error;\n            }\n            r = readfull(f, j->body, j->r.body_size, err, \"v5 job body\");\n            if (!r) {\n                goto Error;\n            }\n            sz += r;\n\n            // since this is a full record, we can move\n            // the file pointer and decref the old\n            // file, if any\n            filermjob(j->file, j);\n            fileaddjob(f, j);\n        }\n        j->walused += sz;\n        f->w->alive += sz;\n\n        return 1;\n    case Invalid:\n        if (j) {\n            job_list_remove(j);\n            filermjob(j->file, j);\n            job_free(j);\n        }\n        return 1;\n    }\n\nError:\n    *err = 1;\n    if (j) {\n        job_list_remove(j);\n        filermjob(j->file, j);\n        job_free(j);\n    }\n    return 0;\n}\n\n\nstatic int\nreadfull(File *f, void *c, int n, int *err, char *desc)\n{\n    int r;\n\n    r = read(f->fd, c, n);\n    if (r == -1) {\n        twarn(\"read\");\n        warnpos(f, 0, \"error reading %s\", desc);\n        *err = 1;\n        return 0;\n    }\n    if (r != n) {\n        warnpos(f, -r, \"unexpected EOF reading %d bytes (got %d): %s\", n, r, desc);\n        *err = 1;\n        return 0;\n    }\n    return r;\n}\n\nstatic void\nwarnpos(File *f, int adj, char *fmt, ...)\n{\n    int off;\n    va_list ap;\n\n    off = lseek(f->fd, 0, SEEK_CUR);\n    fprintf(stderr, \"%s:%d: \", f->path, off+adj);\n    va_start(ap, fmt);\n    vfprintf(stderr, fmt, ap);\n    va_end(ap);\n    fputc('\\n', stderr);\n}\n\n\n// Opens f for writing, writes a header, and initializes\n// f->free and f->resv.\n// Sets f->iswopen if successful.\nvoid\nfilewopen(File *f)\n{\n    int fd, r;\n    int n;\n    int ver = Walver;\n\n    fd = open(f->path, O_WRONLY|O_CREAT, 0400);\n    if (fd < 0) {\n        twarn(\"open %s\", f->path);\n        return;\n    }\n\n    r = falloc(fd, f->w->filesize);\n    if (r) {\n        if (close(fd) == -1)\n            twarn(\"close\");\n        errno = r;\n        twarn(\"falloc %s\", f->path);\n        r = unlink(f->path);\n        if (r) {\n            twarn(\"unlink %s\", f->path);\n        }\n        return;\n    }\n\n    n = write(fd, &ver, sizeof(int));\n    if (n < 0 || (size_t)n < sizeof(int)) {\n        twarn(\"write %s\", f->path);\n        if (close(fd) == -1)\n            twarn(\"close\");\n        return;\n    }\n\n    f->fd = fd;\n    f->iswopen = 1;\n    fileincref(f);\n    f->free = f->w->filesize - n;\n    f->resv = 0;\n}\n\n\nstatic int\nfilewrite(File *f, Job *j, void *buf, int len)\n{\n    int r;\n\n    r = write(f->fd, buf, len);\n    if (r != len) {\n        twarn(\"write\");\n        return 0;\n    }\n\n    f->w->resv -= r;\n    f->resv -= r;\n    j->walresv -= r;\n    j->walused += r;\n    f->w->alive += r;\n    return 1;\n}\n\n\nint\nfilewrjobshort(File *f, Job *j)\n{\n    int r, nl;\n\n    nl = 0; // name len 0 indicates short record\n    r = filewrite(f, j, &nl, sizeof nl) &&\n        filewrite(f, j, &j->r, sizeof j->r);\n    if (!r) return 0;\n\n    if (j->r.state == Invalid) {\n        filermjob(j->file, j);\n    }\n\n    return r;\n}\n\n\nint\nfilewrjobfull(File *f, Job *j)\n{\n    int nl;\n\n    fileaddjob(f, j);\n    nl = strlen(j->tube->name);\n    return\n        filewrite(f, j, &nl, sizeof nl) &&\n        filewrite(f, j, j->tube->name, nl) &&\n        filewrite(f, j, &j->r, sizeof j->r) &&\n        filewrite(f, j, j->body, j->r.body_size);\n}\n\n\nvoid\nfilewclose(File *f)\n{\n    if (!f) return;\n    if (!f->iswopen) return;\n    if (f->free) {\n        errno = 0;\n        if (ftruncate(f->fd, f->w->filesize - f->free) != 0) {\n            twarn(\"ftruncate\");\n        }\n    }\n    if (close(f->fd) == -1)\n        twarn(\"close\");\n    f->iswopen = 0;\n    filedecref(f);\n}\n\n\nint\nfileinit(File *f, Wal *w, int n)\n{\n    f->w = w;\n    f->seq = n;\n    f->path = fmtalloc(\"%s/binlog.%d\", w->dir, n);\n    return !!f->path;\n}\n\n\n// Adds f to the linked list in w,\n// updating w->tail and w->head as necessary.\nWal*\nfileadd(File *f, Wal *w)\n{\n    if (w->tail) {\n        w->tail->next = f;\n    }\n    w->tail = f;\n    if (!w->head) {\n        w->head = f;\n    }\n    w->nfile++;\n    return w;\n}\n"
        },
        {
          "name": "freebsd.c",
          "type": "blob",
          "size": 0.01953125,
          "content": "#include \"darwin.c\"\n"
        },
        {
          "name": "heap.c",
          "type": "blob",
          "size": 1.8212890625,
          "content": "#include \"dat.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nstatic void\nset(Heap *h, size_t k, void *x)\n{\n    h->data[k] = x;\n    h->setpos(x, k);\n}\n\n\nstatic void\nswap(Heap *h, size_t a, size_t b)\n{\n    void *tmp;\n\n    tmp = h->data[a];\n    set(h, a, h->data[b]);\n    set(h, b, tmp);\n}\n\n\nstatic int\nless(Heap *h, size_t a, size_t b)\n{\n    return h->less(h->data[a], h->data[b]);\n}\n\n\nstatic void\nsiftdown(Heap *h, size_t k)\n{\n    for (;;) {\n        size_t p = (k-1) / 2; /* parent */\n\n        if (k == 0 || less(h, p, k)) {\n            return;\n        }\n\n        swap(h, k, p);\n        k = p;\n    }\n}\n\n\nstatic void\nsiftup(Heap *h, size_t k)\n{\n    for (;;) {\n        size_t l = k*2 + 1; /* left child */\n        size_t r = k*2 + 2; /* right child */\n\n        /* find the smallest of the three */\n        size_t s = k;\n        if (l < h->len && less(h, l, s)) s = l;\n        if (r < h->len && less(h, r, s)) s = r;\n\n        if (s == k) {\n            return; /* satisfies the heap property */\n        }\n\n        swap(h, k, s);\n        k = s;\n    }\n}\n\n\n// Heapinsert inserts x into heap h according to h->less.\n// It returns 1 on success, otherwise 0.\nint\nheapinsert(Heap *h, void *x)\n{\n    if (h->len == h->cap) {\n        void **ndata;\n        size_t ncap = (h->len+1) * 2; /* allocate twice what we need */\n\n        ndata = malloc(sizeof(void*) * ncap);\n        if (!ndata) {\n            return 0;\n        }\n\n        memcpy(ndata, h->data, sizeof(void*) * h->len);\n        free(h->data);\n        h->data = ndata;\n        h->cap = ncap;\n    }\n\n    size_t k = h->len;\n    h->len++;\n    set(h, k, x);\n    siftdown(h, k);\n    return 1;\n}\n\n\nvoid *\nheapremove(Heap *h, size_t k)\n{\n    if (k >= h->len) {\n        return 0;\n    }\n\n    void *x = h->data[k];\n    h->len--;\n    set(h, k, h->data[h->len]);\n    siftdown(h, k);\n    siftup(h, k);\n    return x;\n}\n"
        },
        {
          "name": "job.c",
          "type": "blob",
          "size": 5.2216796875,
          "content": "#include \"dat.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic uint64 next_id = 1;\n\nstatic int cur_prime = 0;\n\nstatic Job *all_jobs_init[12289] = {0};\nstatic Job **all_jobs = all_jobs_init;\nstatic size_t all_jobs_cap = 12289; /* == primes[0] */\nstatic size_t all_jobs_used = 0;\n\nstatic int hash_table_was_oom = 0;\n\nstatic void rehash(int);\n\nstatic int\n_get_job_hash_index(uint64 job_id)\n{\n    return job_id % all_jobs_cap;\n}\n\nstatic void\nstore_job(Job *j)\n{\n    int index = 0;\n\n    index = _get_job_hash_index(j->r.id);\n\n    j->ht_next = all_jobs[index];\n    all_jobs[index] = j;\n    all_jobs_used++;\n\n    /* accept a load factor of 4 */\n    if (all_jobs_used > (all_jobs_cap << 2)) rehash(1);\n}\n\nstatic void\nrehash(int is_upscaling)\n{\n    Job **old = all_jobs;\n    size_t old_cap = all_jobs_cap, old_used = all_jobs_used, i;\n    int old_prime = cur_prime;\n    int d = is_upscaling ? 1 : -1;\n\n    if (cur_prime + d >= NUM_PRIMES) return;\n    if (cur_prime + d < 0) return;\n    if (is_upscaling && hash_table_was_oom) return;\n\n    cur_prime += d;\n\n    all_jobs_cap = primes[cur_prime];\n    all_jobs = calloc(all_jobs_cap, sizeof(Job *));\n    if (!all_jobs) {\n        twarnx(\"Failed to allocate %zu new hash buckets\", all_jobs_cap);\n        hash_table_was_oom = 1;\n        cur_prime = old_prime;\n        all_jobs = old;\n        all_jobs_cap = old_cap;\n        all_jobs_used = old_used;\n        return;\n    }\n    all_jobs_used = 0;\n    hash_table_was_oom = 0;\n\n    for (i = 0; i < old_cap; i++) {\n        while (old[i]) {\n            Job *j = old[i];\n            old[i] = j->ht_next;\n            j->ht_next = NULL;\n            store_job(j);\n        }\n    }\n    if (old != all_jobs_init) {\n        free(old);\n    }\n}\n\nJob *\njob_find(uint64 job_id)\n{\n    int index = _get_job_hash_index(job_id);\n    Job *jh = all_jobs[index];\n\n    while (jh && jh->r.id != job_id)\n        jh = jh->ht_next;\n\n    return jh;\n}\n\nJob *\nallocate_job(int body_size)\n{\n    Job *j;\n\n    j = malloc(sizeof(Job) + body_size);\n    if (!j) {\n        twarnx(\"OOM\");\n        return (Job *) 0;\n    }\n\n    memset(j, 0, sizeof(Job));\n    j->r.created_at = nanoseconds();\n    j->r.body_size = body_size;\n    j->body = (char *)j + sizeof(Job);\n    job_list_reset(j);\n    return j;\n}\n\nJob *\nmake_job_with_id(uint32 pri, int64 delay, int64 ttr,\n                 int body_size, Tube *tube, uint64 id)\n{\n    Job *j;\n\n    j = allocate_job(body_size);\n    if (!j) {\n        twarnx(\"OOM\");\n        return (Job *) 0;\n    }\n\n    if (id) {\n        j->r.id = id;\n        if (id >= next_id) next_id = id + 1;\n    } else {\n        j->r.id = next_id++;\n    }\n    j->r.pri = pri;\n    j->r.delay = delay;\n    j->r.ttr = ttr;\n\n    store_job(j);\n\n    TUBE_ASSIGN(j->tube, tube);\n\n    return j;\n}\n\nstatic void\njob_hash_free(Job *j)\n{\n    Job **slot;\n\n    slot = &all_jobs[_get_job_hash_index(j->r.id)];\n    while (*slot && *slot != j) slot = &(*slot)->ht_next;\n    if (*slot) {\n        *slot = (*slot)->ht_next;\n        --all_jobs_used;\n    }\n\n    // Downscale when the hashmap is too sparse\n    if (all_jobs_used < (all_jobs_cap >> 4)) rehash(0);\n}\n\nvoid\njob_free(Job *j)\n{\n    if (j) {\n        TUBE_ASSIGN(j->tube, NULL);\n        if (j->r.state != Copy) job_hash_free(j);\n    }\n\n    free(j);\n}\n\nvoid\njob_setpos(void *j, size_t pos)\n{\n    ((Job *)j)->heap_index = pos;\n}\n\nint\njob_pri_less(void *ja, void *jb)\n{\n    Job *a = (Job *)ja;\n    Job *b = (Job *)jb;\n    if (a->r.pri < b->r.pri) return 1;\n    if (a->r.pri > b->r.pri) return 0;\n    return a->r.id < b->r.id;\n}\n\nint\njob_delay_less(void *ja, void *jb)\n{\n    Job *a = ja;\n    Job *b = jb;\n    if (a->r.deadline_at < b->r.deadline_at) return 1;\n    if (a->r.deadline_at > b->r.deadline_at) return 0;\n    return a->r.id < b->r.id;\n}\n\nJob *\njob_copy(Job *j)\n{\n    if (!j)\n        return NULL;\n\n    Job *n = malloc(sizeof(Job) + j->r.body_size);\n    if (!n) {\n        twarnx(\"OOM\");\n        return (Job *) 0;\n    }\n\n    memcpy(n, j, sizeof(Job) + j->r.body_size);\n    job_list_reset(n);\n\n    n->file = NULL; /* copies do not have refcnt on the wal */\n\n    n->tube = 0; /* Don't use memcpy for the tube, which we must refcount. */\n    TUBE_ASSIGN(n->tube, j->tube);\n\n    /* Mark this job as a copy so it can be appropriately freed later on */\n    n->r.state = Copy;\n\n    return n;\n}\n\nconst char *\njob_state(Job *j)\n{\n    if (j->r.state == Ready) return \"ready\";\n    if (j->r.state == Reserved) return \"reserved\";\n    if (j->r.state == Buried) return \"buried\";\n    if (j->r.state == Delayed) return \"delayed\";\n    return \"invalid\";\n}\n\n// job_list_reset detaches head from the list,\n// marking the list starting in head pointing to itself.\nvoid\njob_list_reset(Job *head)\n{\n    head->prev = head;\n    head->next = head;\n}\n\nint\njob_list_is_empty(Job *head)\n{\n    return head->next == head && head->prev == head;\n}\n\nJob *\njob_list_remove(Job *j)\n{\n    if (!j) return NULL;\n    if (job_list_is_empty(j)) return NULL; /* not in a doubly-linked list */\n\n    j->next->prev = j->prev;\n    j->prev->next = j->next;\n\n    job_list_reset(j);\n\n    return j;\n}\n\nvoid\njob_list_insert(Job *head, Job *j)\n{\n    if (!job_list_is_empty(j)) return; /* already in a linked list */\n\n    j->prev = head->prev;\n    j->next = head;\n    head->prev->next = j;\n    head->prev = j;\n}\n\n/* for unit tests */\nsize_t\nget_all_jobs_used()\n{\n    return all_jobs_used;\n}\n"
        },
        {
          "name": "linux.c",
          "type": "blob",
          "size": 1.4619140625,
          "content": "#define _XOPEN_SOURCE 600\n\n#include \"dat.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <stdint.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/epoll.h>\n\n#ifndef EPOLLRDHUP\n#define EPOLLRDHUP 0x2000\n#endif\n\nstatic int epfd;\n\n\nint\nsockinit(void)\n{\n    epfd = epoll_create(1);\n    if (epfd == -1) {\n        twarn(\"epoll_create\");\n        return -1;\n    }\n    return 0;\n}\n\n\nint\nsockwant(Socket *s, int rw)\n{\n    int op;\n\n    if (!s->added && !rw) {\n        return 0;\n    } else if (!s->added && rw) {\n        s->added = 1;\n        op = EPOLL_CTL_ADD;\n    } else if (!rw) {\n        op = EPOLL_CTL_DEL;\n    } else {\n        op = EPOLL_CTL_MOD;\n    }\n\n    struct epoll_event ev = {.events=0};\n    switch (rw) {\n    case 'r':\n        ev.events = EPOLLIN;\n        break;\n    case 'w':\n        ev.events = EPOLLOUT;\n        break;\n    }\n    ev.events |= EPOLLRDHUP | EPOLLPRI;\n    ev.data.ptr = s;\n\n    return epoll_ctl(epfd, op, s->fd, &ev);\n}\n\n\nint\nsocknext(Socket **s, int64 timeout)\n{\n    int r;\n    struct epoll_event ev = {.events=0};\n\n    r = epoll_wait(epfd, &ev, 1, (int)(timeout/1000000));\n    if (r == -1 && errno != EINTR) {\n        twarn(\"epoll_wait\");\n        exit(1);\n    }\n\n    if (r > 0) {\n        *s = ev.data.ptr;\n        if (ev.events & (EPOLLHUP|EPOLLRDHUP)) {\n            return 'h';\n        } else if (ev.events & EPOLLIN) {\n            return 'r';\n        } else if (ev.events & EPOLLOUT) {\n            return 'w';\n        }\n    }\n    return 0;\n}\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 2.1416015625,
          "content": "#include \"dat.h\"\n#include <stdint.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <fcntl.h>\n\nstatic void\nsu(const char *user) \n{\n    errno = 0;\n    struct passwd *pwent = getpwnam(user);\n    if (errno) {\n        twarn(\"getpwnam(\\\"%s\\\")\", user);\n        exit(32);\n    }\n    if (!pwent) {\n        twarnx(\"getpwnam(\\\"%s\\\"): no such user\", user);\n        exit(33);\n    }\n\n    int r = setgid(pwent->pw_gid);\n    if (r == -1) {\n        twarn(\"setgid(%d \\\"%s\\\")\", pwent->pw_gid, user);\n        exit(34);\n    }\n\n    r = setuid(pwent->pw_uid);\n    if (r == -1) {\n        twarn(\"setuid(%d \\\"%s\\\")\", pwent->pw_uid, user);\n        exit(34);\n    }\n}\n\nstatic void\nhandle_sigterm_pid1()\n{\n    exit(143);\n}\n\nstatic void\nset_sig_handlers()\n{\n    struct sigaction sa;\n\n    sa.sa_handler = SIG_IGN;\n    sa.sa_flags = 0;\n    int r = sigemptyset(&sa.sa_mask);\n    if (r == -1) {\n        twarn(\"sigemptyset()\");\n        exit(111);\n    }\n\n    r = sigaction(SIGPIPE, &sa, 0);\n    if (r == -1) {\n        twarn(\"sigaction(SIGPIPE)\");\n        exit(111);\n    }\n\n    sa.sa_handler = enter_drain_mode;\n    r = sigaction(SIGUSR1, &sa, 0);\n    if (r == -1) {\n        twarn(\"sigaction(SIGUSR1)\");\n        exit(111);\n    }\n\n    // Workaround for running the server with pid=1 in Docker.\n    // Handle SIGTERM so the server is killed immediately and\n    // not after 10 seconds timeout. See issue #527.\n    if (getpid() == 1) {\n        sa.sa_handler = handle_sigterm_pid1;\n        r = sigaction(SIGTERM, &sa, 0);\n        if (r == -1) {\n            twarn(\"sigaction(SIGTERM)\");\n            exit(111);\n        }\n    }\n}\n\nint\nmain(int argc, char **argv)\n{\n    UNUSED_PARAMETER(argc);\n\n    progname = argv[0];\n    setlinebuf(stdout);\n    optparse(&srv, argv+1);\n\n    if (verbose) {\n        printf(\"pid %d\\n\", getpid());\n    }\n\n    int r = make_server_socket(srv.addr, srv.port);\n    if (r == -1) {\n        twarnx(\"make_server_socket()\");\n        exit(111);\n    }\n\n    srv.sock.fd = r;\n\n    prot_init();\n\n    if (srv.user)\n        su(srv.user);\n    set_sig_handlers();\n\n    srv_acquire_wal(&srv);\n    srvserve(&srv);\n    exit(0);\n}\n"
        },
        {
          "name": "ms.c",
          "type": "blob",
          "size": 1.880859375,
          "content": "#include \"dat.h\"\n#include <stdint.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid\nms_init(Ms *a, ms_event_fn oninsert, ms_event_fn onremove)\n{\n    a->len = a->cap = a->last = 0;\n    a->items = NULL;\n    a->oninsert = oninsert;\n    a->onremove = onremove;\n}\n\nstatic int\ngrow(Ms *a)\n{\n    void **nitems;\n    size_t ncap = a->cap << 1;\n    if (!ncap)\n        ncap = 1;\n\n    nitems = malloc(ncap * sizeof(void *));\n    if (!nitems)\n        return 0;\n\n    memcpy(nitems, a->items, a->len * sizeof(void *));\n    free(a->items);\n    a->items = nitems;\n    a->cap = ncap;\n    return 1;\n}\n\nint\nms_append(Ms *a, void *item)\n{\n    if (a->len >= a->cap && !grow(a))\n        return 0;\n\n    a->items[a->len++] = item;\n    if (a->oninsert)\n        a->oninsert(a, item, a->len - 1);\n    return 1;\n}\n\nstatic int\nms_delete(Ms *a, size_t i)\n{\n    void *item;\n\n    if (i >= a->len)\n        return 0;\n    item = a->items[i];\n    a->items[i] = a->items[--a->len];\n\n    /* it has already been removed now */\n    if (a->onremove)\n        a->onremove(a, item, i);\n    return 1;\n}\n\nvoid\nms_clear(Ms *a)\n{\n    while (ms_delete(a, 0));\n    free(a->items);\n    ms_init(a, a->oninsert, a->onremove);\n}\n\nint\nms_remove(Ms *a, void *item)\n{\n    size_t i;\n\n    for (i = 0; i < a->len; i++) {\n        if (a->items[i] == item)\n            return ms_delete(a, i);\n    }\n    return 0;\n}\n\nint\nms_contains(Ms *a, void *item)\n{\n    size_t i;\n\n    for (i = 0; i < a->len; i++) {\n        if (a->items[i] == item)\n            return 1;\n    }\n    return 0;\n}\n\nvoid *\nms_take(Ms *a)\n{\n    void *item;\n\n    if (!a->len)\n        return NULL;\n\n    // The result of last behaviour is that ms_take returns the oldest elements\n    // first, exception is a row of multiple take calls without inserts on ms\n    // of even number of elements. See the test.\n    a->last = a->last % a->len;\n    item = a->items[a->last];\n    ms_delete(a, a->last);\n    ++a->last;\n    return item;\n}\n"
        },
        {
          "name": "net.c",
          "type": "blob",
          "size": 6.46484375,
          "content": "#include \"dat.h\"\n#include <netdb.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n\n#ifdef HAVE_LIBSYSTEMD\n#include <systemd/sd-daemon.h>\n#endif\n\nstatic int\nset_nonblocking(int fd)\n{\n    int flags, r;\n\n    flags = fcntl(fd, F_GETFL, 0);\n    if (flags < 0) {\n        twarn(\"getting flags\");\n        return -1;\n    }\n    r = fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n    if (r == -1) {\n        twarn(\"setting O_NONBLOCK\");\n        return -1;\n    }\n    return 0;\n}\n\nstatic int\nmake_inet_socket(char *host, char *port)\n{\n    int fd = -1, flags, r;\n    struct linger linger = {0, 0};\n    struct addrinfo *airoot, *ai, hints;\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;\n    r = getaddrinfo(host, port, &hints, &airoot);\n    if (r != 0) {\n        twarnx(\"getaddrinfo(): %s\", gai_strerror(r));\n        return -1;\n    }\n\n    for (ai = airoot; ai; ai = ai->ai_next) {\n        fd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n        if (fd == -1) {\n            twarn(\"socket()\");\n            continue;\n        }\n\n        r = set_nonblocking(fd);\n        if (r == -1) {\n            close(fd);\n            continue;\n        }\n\n        flags = 1;\n        r = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &flags, sizeof flags);\n        if (r == -1) {\n            twarn(\"setting SO_REUSEADDR on fd %d\", fd);\n            close(fd);\n            continue;\n        }\n        r = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &flags, sizeof flags);\n        if (r == -1) {\n            twarn(\"setting SO_KEEPALIVE on fd %d\", fd);\n            close(fd);\n            continue;\n        }\n        r = setsockopt(fd, SOL_SOCKET, SO_LINGER, &linger, sizeof linger);\n        if (r == -1) {\n            twarn(\"setting SO_LINGER on fd %d\", fd);\n            close(fd);\n            continue;\n        }\n        r = setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flags, sizeof flags);\n        if (r == -1) {\n            twarn(\"setting TCP_NODELAY on fd %d\", fd);\n            close(fd);\n            continue;\n        }\n\n        if (host == NULL && ai->ai_family == AF_INET6) {\n            flags = 0;\n            r = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &flags, sizeof(flags));\n            if (r == -1) {\n                twarn(\"setting IPV6_V6ONLY on fd %d\", fd);\n                close(fd);\n                continue;\n            }\n        }\n\n        r = bind(fd, ai->ai_addr, ai->ai_addrlen);\n        if (r == -1) {\n            twarn(\"bind()\");\n            close(fd);\n            continue;\n        }\n        if (verbose) {\n            char hbuf[NI_MAXHOST], pbuf[NI_MAXSERV], *h = host, *p = port;\n            struct sockaddr_in addr;\n            socklen_t addrlen;\n\n            addrlen = sizeof(addr);\n            r = getsockname(fd, (struct sockaddr *) &addr, &addrlen);\n            if (!r) {\n                r = getnameinfo((struct sockaddr *) &addr, addrlen,\n                                hbuf, sizeof(hbuf),\n                                pbuf, sizeof(pbuf),\n                                NI_NUMERICHOST|NI_NUMERICSERV);\n                if (!r) {\n                    h = hbuf;\n                    p = pbuf;\n                }\n            }\n            if (ai->ai_family == AF_INET6) {\n                printf(\"bind %d [%s]:%s\\n\", fd, h, p);\n            } else {\n                printf(\"bind %d %s:%s\\n\", fd, h, p);\n            }\n        }\n\n        r = listen(fd, 1024);\n        if (r == -1) {\n            twarn(\"listen()\");\n            close(fd);\n            continue;\n        }\n\n        break;\n    }\n\n    freeaddrinfo(airoot);\n\n    if(ai == NULL)\n        fd = -1;\n\n    return fd;\n}\n\nstatic int\nmake_unix_socket(char *path)\n{\n    int fd = -1, r;\n    struct stat st;\n    struct sockaddr_un addr;\n    const size_t maxlen = sizeof(addr.sun_path) - 1; // Reserve the last position for '\\0'\n\n    memset(&addr, 0, sizeof(struct sockaddr_un));\n    addr.sun_family = AF_UNIX;\n    if (strlen(path) > maxlen) {\n        warnx(\"socket path %s is too long (%ld characters), where maximum allowed is %ld\",\n              path, strlen(path), maxlen);\n        return -1;\n    }\n    strncpy(addr.sun_path, path, maxlen);\n\n    r = stat(path, &st);\n    if (r == 0) {\n        if (S_ISSOCK(st.st_mode)) {\n            warnx(\"removing existing local socket to replace it\");\n            r = unlink(path);\n            if (r == -1) {\n                twarn(\"unlink\");\n                return -1;\n            }\n        } else {\n            twarnx(\"another file already exists in the given path\");\n            return -1;\n        }\n    }\n\n    fd = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd == -1) {\n        twarn(\"socket()\");\n        return -1;\n    }\n\n    r = set_nonblocking(fd);\n    if (r == -1) {\n        close(fd);\n        return -1;\n    }\n\n    r = bind(fd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un));\n    if (r == -1) {\n        twarn(\"bind()\");\n        close(fd);\n        return -1;\n    }\n    if (verbose) {\n        printf(\"bind %d %s\\n\", fd, path);\n    }\n\n    r = listen(fd, 1024);\n    if (r == -1) {\n        twarn(\"listen()\");\n        close(fd);\n        return -1;\n    }\n\n    return fd;\n}\n\nint\nmake_server_socket(char *host, char *port)\n{\n#ifdef HAVE_LIBSYSTEMD\n    int fd = -1, r;\n\n    /* See if we got a listen fd from systemd. If so, all socket options etc\n     * are already set, so we check that the fd is a TCP or UNIX listen socket\n     * and return. */\n    r = sd_listen_fds(1);\n    if (r < 0) {\n        twarn(\"sd_listen_fds\");\n        return -1;\n    }\n    if (r > 0) {\n        if (r > 1) {\n            twarnx(\"inherited more than one listen socket;\"\n                   \" ignoring all but the first\");\n        }\n        fd = SD_LISTEN_FDS_START;\n        r = sd_is_socket_inet(fd, 0, SOCK_STREAM, 1, 0);\n        if (r < 0) {\n            twarn(\"sd_is_socket_inet\");\n            errno = -r;\n            return -1;\n        }\n        if (r == 0) {\n            r = sd_is_socket_unix(fd, SOCK_STREAM, 1, NULL, 0);\n            if (r < 0) {\n                twarn(\"sd_is_socket_unix\");\n                errno = -r;\n                return -1;\n            }\n            if (r == 0) {\n                twarnx(\"inherited fd is not a TCP or UNIX listening socket\");\n                return -1;\n            }\n        }\n        return fd;\n    }\n#endif\n\n    if (host && !strncmp(host, \"unix:\", 5)) {\n        return make_unix_socket(&host[5]);\n    } else {\n        return make_inet_socket(host, port);\n    }\n}\n"
        },
        {
          "name": "pkg",
          "type": "tree",
          "content": null
        },
        {
          "name": "primes.c",
          "type": "blob",
          "size": 1.0068359375,
          "content": "#include <stdlib.h>\n\n// prime // downscale treshold / upscale treshold\n\nsize_t primes[] = {\n    12289, // NA / 3072\n    24593, // 1537 / 6148\n    49193, // 3074 / 12298\n    98387, // 6149 / 24596\n    196799, // etc\n    393611,\n    787243,\n    1574491,\n    3148987,\n    6297979,\n    12595991,\n    25191989,\n    50383981,\n    100767977,\n    201535967,\n    403071937,\n    806143879,\n    1612287763,\n    3224575537UL,\n#if _LP64\n    6449151103,\n    12898302233,\n    25796604473,\n    51593208973,\n    103186417951,\n    206372835917,\n    412745671837,\n    825491343683,\n    1650982687391,\n    3301965374803,\n    6603930749621,\n    13207861499251,\n    26415722998507,\n    52831445997037,\n    105662891994103,\n    211325783988211,\n    422651567976461,\n    845303135952931,\n    1690606271905871,\n    3381212543811743,\n    6762425087623523,\n    13524850175247127,\n    27049700350494287,\n    54099400700988593,\n    108198801401977301,\n    216397602803954641,\n    432795205607909293,\n    865590411215818597,\n    1731180822431637217,\n#endif\n};\n\n"
        },
        {
          "name": "prot.c",
          "type": "blob",
          "size": 59.87109375,
          "content": "#include \"dat.h\"\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/resource.h>\n#include <sys/uio.h>\n#include <sys/types.h>\n#include <sys/utsname.h>\n#include <sys/socket.h>\n#include <inttypes.h>\n#include <stdarg.h>\n#include <signal.h>\n#include <limits.h>\n\n/* job body cannot be greater than this many bytes long */\nsize_t job_data_size_limit = JOB_DATA_SIZE_LIMIT_DEFAULT;\n\n#define NAME_CHARS \\\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \\\n    \"abcdefghijklmnopqrstuvwxyz\" \\\n    \"0123456789-+/;.$_()\"\n\n#define CMD_PUT \"put \"\n#define CMD_PEEKJOB \"peek \"\n#define CMD_PEEK_READY \"peek-ready\"\n#define CMD_PEEK_DELAYED \"peek-delayed\"\n#define CMD_PEEK_BURIED \"peek-buried\"\n#define CMD_RESERVE \"reserve\"\n#define CMD_RESERVE_TIMEOUT \"reserve-with-timeout \"\n#define CMD_RESERVE_JOB \"reserve-job \"\n#define CMD_DELETE \"delete \"\n#define CMD_RELEASE \"release \"\n#define CMD_BURY \"bury \"\n#define CMD_KICK \"kick \"\n#define CMD_KICKJOB \"kick-job \"\n#define CMD_TOUCH \"touch \"\n#define CMD_STATS \"stats\"\n#define CMD_STATSJOB \"stats-job \"\n#define CMD_USE \"use \"\n#define CMD_WATCH \"watch \"\n#define CMD_IGNORE \"ignore \"\n#define CMD_LIST_TUBES \"list-tubes\"\n#define CMD_LIST_TUBE_USED \"list-tube-used\"\n#define CMD_LIST_TUBES_WATCHED \"list-tubes-watched\"\n#define CMD_STATS_TUBE \"stats-tube \"\n#define CMD_QUIT \"quit\"\n#define CMD_PAUSE_TUBE \"pause-tube\"\n\n#define CONSTSTRLEN(m) (sizeof(m) - 1)\n\n#define CMD_PEEK_READY_LEN CONSTSTRLEN(CMD_PEEK_READY)\n#define CMD_PEEK_DELAYED_LEN CONSTSTRLEN(CMD_PEEK_DELAYED)\n#define CMD_PEEK_BURIED_LEN CONSTSTRLEN(CMD_PEEK_BURIED)\n#define CMD_PEEKJOB_LEN CONSTSTRLEN(CMD_PEEKJOB)\n#define CMD_RESERVE_LEN CONSTSTRLEN(CMD_RESERVE)\n#define CMD_RESERVE_TIMEOUT_LEN CONSTSTRLEN(CMD_RESERVE_TIMEOUT)\n#define CMD_RESERVE_JOB_LEN CONSTSTRLEN(CMD_RESERVE_JOB)\n#define CMD_DELETE_LEN CONSTSTRLEN(CMD_DELETE)\n#define CMD_RELEASE_LEN CONSTSTRLEN(CMD_RELEASE)\n#define CMD_BURY_LEN CONSTSTRLEN(CMD_BURY)\n#define CMD_KICK_LEN CONSTSTRLEN(CMD_KICK)\n#define CMD_KICKJOB_LEN CONSTSTRLEN(CMD_KICKJOB)\n#define CMD_TOUCH_LEN CONSTSTRLEN(CMD_TOUCH)\n#define CMD_STATS_LEN CONSTSTRLEN(CMD_STATS)\n#define CMD_STATSJOB_LEN CONSTSTRLEN(CMD_STATSJOB)\n#define CMD_USE_LEN CONSTSTRLEN(CMD_USE)\n#define CMD_WATCH_LEN CONSTSTRLEN(CMD_WATCH)\n#define CMD_IGNORE_LEN CONSTSTRLEN(CMD_IGNORE)\n#define CMD_LIST_TUBES_LEN CONSTSTRLEN(CMD_LIST_TUBES)\n#define CMD_LIST_TUBE_USED_LEN CONSTSTRLEN(CMD_LIST_TUBE_USED)\n#define CMD_LIST_TUBES_WATCHED_LEN CONSTSTRLEN(CMD_LIST_TUBES_WATCHED)\n#define CMD_STATS_TUBE_LEN CONSTSTRLEN(CMD_STATS_TUBE)\n#define CMD_PAUSE_TUBE_LEN CONSTSTRLEN(CMD_PAUSE_TUBE)\n\n#define MSG_FOUND \"FOUND\"\n#define MSG_NOTFOUND \"NOT_FOUND\\r\\n\"\n#define MSG_RESERVED \"RESERVED\"\n#define MSG_DEADLINE_SOON \"DEADLINE_SOON\\r\\n\"\n#define MSG_TIMED_OUT \"TIMED_OUT\\r\\n\"\n#define MSG_DELETED \"DELETED\\r\\n\"\n#define MSG_RELEASED \"RELEASED\\r\\n\"\n#define MSG_BURIED \"BURIED\\r\\n\"\n#define MSG_KICKED \"KICKED\\r\\n\"\n#define MSG_TOUCHED \"TOUCHED\\r\\n\"\n#define MSG_BURIED_FMT \"BURIED %\"PRIu64\"\\r\\n\"\n#define MSG_INSERTED_FMT \"INSERTED %\"PRIu64\"\\r\\n\"\n#define MSG_NOT_IGNORED \"NOT_IGNORED\\r\\n\"\n\n#define MSG_OUT_OF_MEMORY \"OUT_OF_MEMORY\\r\\n\"\n#define MSG_INTERNAL_ERROR \"INTERNAL_ERROR\\r\\n\"\n#define MSG_DRAINING \"DRAINING\\r\\n\"\n#define MSG_BAD_FORMAT \"BAD_FORMAT\\r\\n\"\n#define MSG_UNKNOWN_COMMAND \"UNKNOWN_COMMAND\\r\\n\"\n#define MSG_EXPECTED_CRLF \"EXPECTED_CRLF\\r\\n\"\n#define MSG_JOB_TOO_BIG \"JOB_TOO_BIG\\r\\n\"\n\n// Connection can be in one of these states:\n#define STATE_WANT_COMMAND  0  // conn expects a command from the client\n#define STATE_WANT_DATA     1  // conn expects a job data\n#define STATE_SEND_JOB      2  // conn sends job to the client\n#define STATE_SEND_WORD     3  // conn sends a line reply\n#define STATE_WAIT          4  // client awaits for the job reservation\n#define STATE_BITBUCKET     5  // conn discards content\n#define STATE_CLOSE         6  // conn should be closed\n#define STATE_WANT_ENDLINE  7  // skip until the end of a line\n\n#define OP_UNKNOWN 0\n#define OP_PUT 1\n#define OP_PEEKJOB 2\n#define OP_RESERVE 3\n#define OP_DELETE 4\n#define OP_RELEASE 5\n#define OP_BURY 6\n#define OP_KICK 7\n#define OP_STATS 8\n#define OP_STATSJOB 9\n#define OP_PEEK_BURIED 10\n#define OP_USE 11\n#define OP_WATCH 12\n#define OP_IGNORE 13\n#define OP_LIST_TUBES 14\n#define OP_LIST_TUBE_USED 15\n#define OP_LIST_TUBES_WATCHED 16\n#define OP_STATS_TUBE 17\n#define OP_PEEK_READY 18\n#define OP_PEEK_DELAYED 19\n#define OP_RESERVE_TIMEOUT 20\n#define OP_TOUCH 21\n#define OP_QUIT 22\n#define OP_PAUSE_TUBE 23\n#define OP_KICKJOB 24\n#define OP_RESERVE_JOB 25\n#define TOTAL_OPS 26\n\n#define STATS_FMT \"---\\n\" \\\n    \"current-jobs-urgent: %\" PRIu64 \"\\n\" \\\n    \"current-jobs-ready: %\" PRIu64 \"\\n\" \\\n    \"current-jobs-reserved: %\" PRIu64 \"\\n\" \\\n    \"current-jobs-delayed: %u\\n\" \\\n    \"current-jobs-buried: %\" PRIu64 \"\\n\" \\\n    \"cmd-put: %\" PRIu64 \"\\n\" \\\n    \"cmd-peek: %\" PRIu64 \"\\n\" \\\n    \"cmd-peek-ready: %\" PRIu64 \"\\n\" \\\n    \"cmd-peek-delayed: %\" PRIu64 \"\\n\" \\\n    \"cmd-peek-buried: %\" PRIu64 \"\\n\" \\\n    \"cmd-reserve: %\" PRIu64 \"\\n\" \\\n    \"cmd-reserve-with-timeout: %\" PRIu64 \"\\n\" \\\n    \"cmd-delete: %\" PRIu64 \"\\n\" \\\n    \"cmd-release: %\" PRIu64 \"\\n\" \\\n    \"cmd-use: %\" PRIu64 \"\\n\" \\\n    \"cmd-watch: %\" PRIu64 \"\\n\" \\\n    \"cmd-ignore: %\" PRIu64 \"\\n\" \\\n    \"cmd-bury: %\" PRIu64 \"\\n\" \\\n    \"cmd-kick: %\" PRIu64 \"\\n\" \\\n    \"cmd-touch: %\" PRIu64 \"\\n\" \\\n    \"cmd-stats: %\" PRIu64 \"\\n\" \\\n    \"cmd-stats-job: %\" PRIu64 \"\\n\" \\\n    \"cmd-stats-tube: %\" PRIu64 \"\\n\" \\\n    \"cmd-list-tubes: %\" PRIu64 \"\\n\" \\\n    \"cmd-list-tube-used: %\" PRIu64 \"\\n\" \\\n    \"cmd-list-tubes-watched: %\" PRIu64 \"\\n\" \\\n    \"cmd-pause-tube: %\" PRIu64 \"\\n\" \\\n    \"job-timeouts: %\" PRIu64 \"\\n\" \\\n    \"total-jobs: %\" PRIu64 \"\\n\" \\\n    \"max-job-size: %zu\\n\" \\\n    \"current-tubes: %zu\\n\" \\\n    \"current-connections: %u\\n\" \\\n    \"current-producers: %u\\n\" \\\n    \"current-workers: %u\\n\" \\\n    \"current-waiting: %\" PRIu64 \"\\n\" \\\n    \"total-connections: %u\\n\" \\\n    \"pid: %ld\\n\" \\\n    \"version: \\\"%s\\\"\\n\" \\\n    \"rusage-utime: %d.%06d\\n\" \\\n    \"rusage-stime: %d.%06d\\n\" \\\n    \"uptime: %u\\n\" \\\n    \"binlog-oldest-index: %d\\n\" \\\n    \"binlog-current-index: %d\\n\" \\\n    \"binlog-records-migrated: %\" PRId64 \"\\n\" \\\n    \"binlog-records-written: %\" PRId64 \"\\n\" \\\n    \"binlog-max-size: %d\\n\" \\\n    \"draining: %s\\n\" \\\n    \"id: %s\\n\" \\\n    \"hostname: \\\"%s\\\"\\n\" \\\n    \"os: \\\"%s\\\"\\n\" \\\n    \"platform: \\\"%s\\\"\\n\" \\\n    \"\\r\\n\"\n\n#define STATS_TUBE_FMT \"---\\n\" \\\n    \"name: \\\"%s\\\"\\n\" \\\n    \"current-jobs-urgent: %\" PRIu64 \"\\n\" \\\n    \"current-jobs-ready: %zu\\n\" \\\n    \"current-jobs-reserved: %\" PRIu64 \"\\n\" \\\n    \"current-jobs-delayed: %zu\\n\" \\\n    \"current-jobs-buried: %\" PRIu64 \"\\n\" \\\n    \"total-jobs: %\" PRIu64 \"\\n\" \\\n    \"current-using: %u\\n\" \\\n    \"current-watching: %u\\n\" \\\n    \"current-waiting: %\" PRIu64 \"\\n\" \\\n    \"cmd-delete: %\" PRIu64 \"\\n\" \\\n    \"cmd-pause-tube: %\" PRIu64 \"\\n\" \\\n    \"pause: %\" PRIu64 \"\\n\" \\\n    \"pause-time-left: %\" PRId64 \"\\n\" \\\n    \"\\r\\n\"\n\n#define STATS_JOB_FMT \"---\\n\" \\\n    \"id: %\" PRIu64 \"\\n\" \\\n    \"tube: \\\"%s\\\"\\n\" \\\n    \"state: %s\\n\" \\\n    \"pri: %u\\n\" \\\n    \"age: %\" PRId64 \"\\n\" \\\n    \"delay: %\" PRId64 \"\\n\" \\\n    \"ttr: %\" PRId64 \"\\n\" \\\n    \"time-left: %\" PRId64 \"\\n\" \\\n    \"file: %d\\n\" \\\n    \"reserves: %u\\n\" \\\n    \"timeouts: %u\\n\" \\\n    \"releases: %u\\n\" \\\n    \"buries: %u\\n\" \\\n    \"kicks: %u\\n\" \\\n    \"\\r\\n\"\n\n// The size of the throw-away (BITBUCKET) buffer. Arbitrary.\n#define BUCKET_BUF_SIZE 1024\n\nstatic uint64 ready_ct = 0;\nstatic uint64 timeout_ct = 0;\nstatic uint64 op_ct[TOTAL_OPS] = {0};\nstatic struct stats global_stat = {0};\n\nstatic Tube *default_tube;\n\n// If drain_mode is 1, then server does not accept new jobs.\n// Variable is set by the SIGUSR1 handler.\nstatic volatile sig_atomic_t drain_mode = 0;\n\nstatic int64 started_at;\n\nenum { instance_id_bytes = 8 };\nstatic char instance_hex[instance_id_bytes * 2 + 1]; // hex-encoded len of instance_id_bytes\n\nstatic struct utsname node_info;\n\n// Single linked list with connections that require updates\n// in the event notification mechanism.\nstatic Conn *epollq;\n\nstatic const char * op_names[] = {\n    \"<unknown>\",\n    CMD_PUT,\n    CMD_PEEKJOB,\n    CMD_RESERVE,\n    CMD_DELETE,\n    CMD_RELEASE,\n    CMD_BURY,\n    CMD_KICK,\n    CMD_STATS,\n    CMD_STATSJOB,\n    CMD_PEEK_BURIED,\n    CMD_USE,\n    CMD_WATCH,\n    CMD_IGNORE,\n    CMD_LIST_TUBES,\n    CMD_LIST_TUBE_USED,\n    CMD_LIST_TUBES_WATCHED,\n    CMD_STATS_TUBE,\n    CMD_PEEK_READY,\n    CMD_PEEK_DELAYED,\n    CMD_RESERVE_TIMEOUT,\n    CMD_TOUCH,\n    CMD_QUIT,\n    CMD_PAUSE_TUBE,\n    CMD_KICKJOB,\n    CMD_RESERVE_JOB,\n};\n\nstatic Job *remove_ready_job(Job *j);\nstatic Job *remove_buried_job(Job *j);\n\n// epollq_add schedules connection c in the s->conns heap, adds c\n// to the epollq list to change expected operation in event notifications.\n// rw='w' means to notify when socket is writeable, 'r' - readable, 'h' - closed.\nstatic void\nepollq_add(Conn *c, char rw) {\n    c->rw = rw;\n    connsched(c);\n    c->next = epollq;\n    epollq = c;\n}\n\n// epollq_rmconn removes connection c from the epollq.\nstatic void\nepollq_rmconn(Conn *c)\n{\n    Conn *x, *newhead = NULL;\n\n    while (epollq) {\n        // x as next element from epollq.\n        x = epollq;\n        epollq = epollq->next;\n        x->next = NULL;\n\n        // put x back into newhead list.\n        if (x != c) {\n            x->next = newhead;\n            newhead = x;\n        }\n    }\n    epollq = newhead;\n}\n\n// Propagate changes to event notification mechanism about expected operations\n// in connections' sockets. Clear the epollq list.\nstatic void\nepollq_apply()\n{\n    Conn *c;\n\n    while (epollq) {\n        c = epollq;\n        epollq = epollq->next;\n        c->next = NULL;\n        int r = sockwant(&c->sock, c->rw);\n        if (r == -1) {\n            twarn(\"sockwant\");\n            connclose(c);\n        }\n    }\n}\n\n#define reply_msg(c, m) \\\n    reply((c), (m), CONSTSTRLEN(m), STATE_SEND_WORD)\n\n#define reply_serr(c, e) \\\n    (twarnx(\"server error: %s\", (e)), reply_msg((c), (e)))\n\nstatic void\nreply(Conn *c, char *line, int len, int state)\n{\n    if (!c)\n        return;\n\n    epollq_add(c, 'w');\n\n    c->reply = line;\n    c->reply_len = len;\n    c->reply_sent = 0;\n    c->state = state;\n    if (verbose >= 2) {\n        printf(\">%d reply %.*s\\n\", c->sock.fd, len-2, line);\n    }\n}\n\nstatic void\nreply_line(Conn*, int, const char*, ...)\n__attribute__((format(printf, 3, 4)));\n\n// reply_line prints *fmt into c->reply_buffer and\n// calls reply() for the string and state.\nstatic void\nreply_line(Conn *c, int state, const char *fmt, ...)\n{\n    int r;\n    va_list ap;\n\n    va_start(ap, fmt);\n    r = vsnprintf(c->reply_buf, LINE_BUF_SIZE, fmt, ap);\n    va_end(ap);\n\n    /* Make sure the buffer was big enough. If not, we have a bug. */\n    if (r >= LINE_BUF_SIZE) {\n        reply_serr(c, MSG_INTERNAL_ERROR);\n        return;\n    }\n\n    reply(c, c->reply_buf, r, state);\n}\n\n// reply_job tells the connection c which job to send,\n// and replies with this line: <msg> <job_id> <job_size>.\nstatic void\nreply_job(Conn *c, Job *j, const char *msg)\n{\n    c->out_job = j;\n    c->out_job_sent = 0;\n    reply_line(c, STATE_SEND_JOB, \"%s %\"PRIu64\" %u\\r\\n\",\n               msg, j->r.id, j->r.body_size - 2);\n}\n\n// remove_waiting_conn unsets CONN_TYPE_WAITING for the connection,\n// removes it from the waiting_conns set of every tube it's watching.\n// Noop if connection is not waiting.\nvoid\nremove_waiting_conn(Conn *c)\n{\n    if (!conn_waiting(c))\n        return;\n\n    c->type &= ~CONN_TYPE_WAITING;\n    global_stat.waiting_ct--;\n    size_t i;\n    for (i = 0; i < c->watch.len; i++) {\n        Tube *t = c->watch.items[i];\n        t->stat.waiting_ct--;\n        ms_remove(&t->waiting_conns, c);\n    }\n}\n\n// enqueue_waiting_conn sets CONN_TYPE_WAITING for the connection,\n// adds it to the waiting_conns set of every tube it's watching.\nstatic void\nenqueue_waiting_conn(Conn *c)\n{\n    c->type |= CONN_TYPE_WAITING;\n    global_stat.waiting_ct++;\n    size_t i;\n    for (i = 0; i < c->watch.len; i++) {\n        Tube *t = c->watch.items[i];\n        t->stat.waiting_ct++;\n        ms_append(&t->waiting_conns, c);\n    }\n}\n\n// next_awaited_job iterates through all the tubes with awaiting connections,\n// returns the next ready job with the smallest priority.\n// If jobs has the same priority it picks the job with smaller id.\n// All tubes with expired pause are unpaused.\nstatic Job *\nnext_awaited_job(int64 now)\n{\n    size_t i;\n    Job *j = NULL;\n\n    for (i = 0; i < tubes.len; i++) {\n        Tube *t = tubes.items[i];\n        if (t->pause) {\n            if (t->unpause_at > now)\n                continue;\n            t->pause = 0;\n        }\n        if (t->waiting_conns.len && t->ready.len) {\n            Job *candidate = t->ready.data[0];\n            if (!j || job_pri_less(candidate, j)) {\n                j = candidate;\n            }\n        }\n    }\n    return j;\n}\n\n// process_queue performs reservation for every jobs that is awaited for.\nstatic void\nprocess_queue()\n{\n    Job *j = NULL;\n    int64 now = nanoseconds();\n\n    while ((j = next_awaited_job(now))) {\n        j = remove_ready_job(j);\n        if (j == NULL) {\n            twarnx(\"job not ready\");\n            continue;\n        }\n        Conn *c = ms_take(&j->tube->waiting_conns);\n        if (c == NULL) {\n            twarnx(\"waiting_conns is empty\");\n            continue;\n        }\n        global_stat.reserved_ct++;\n\n        remove_waiting_conn(c);\n        conn_reserve_job(c, j);\n        reply_job(c, j, MSG_RESERVED);\n    }\n}\n\n// soonest_delayed_job returns the delayed job\n// with the smallest deadline_at among all tubes.\nstatic Job *\nsoonest_delayed_job()\n{\n    Job *j = NULL;\n    size_t i;\n\n    for (i = 0; i < tubes.len; i++) {\n        Tube *t = tubes.items[i];\n        if (t->delay.len == 0) {\n            continue;\n        }\n        Job *nj = t->delay.data[0];\n        if (!j || nj->r.deadline_at < j->r.deadline_at)\n            j = nj;\n    }\n    return j;\n}\n\n// enqueue_job inserts job j in the tube, returns 1 on success, otherwise 0.\n// If update_store then it writes an entry to WAL.\n// On success it processes the queue.\n// BUG: If maintenance of WAL has failed, it is not reported as error.\nstatic int\nenqueue_job(Server *s, Job *j, int64 delay, char update_store)\n{\n    int r;\n\n    j->reserver = NULL;\n    if (delay) {\n        j->r.deadline_at = nanoseconds() + delay;\n        r = heapinsert(&j->tube->delay, j);\n        if (!r)\n            return 0;\n        j->r.state = Delayed;\n    } else {\n        r = heapinsert(&j->tube->ready, j);\n        if (!r)\n            return 0;\n        j->r.state = Ready;\n        ready_ct++;\n        if (j->r.pri < URGENT_THRESHOLD) {\n            global_stat.urgent_ct++;\n            j->tube->stat.urgent_ct++;\n        }\n    }\n\n    if (update_store) {\n        if (!walwrite(&s->wal, j)) {\n            return 0;\n        }\n        walmaint(&s->wal);\n    }\n\n    // The call below makes this function do too much.\n    // TODO: refactor this call outside so the call is explicit (not hidden)?\n    process_queue();\n    return 1;\n}\n\nstatic int\nbury_job(Server *s, Job *j, char update_store)\n{\n    if (update_store) {\n        int z = walresvupdate(&s->wal);\n        if (!z)\n            return 0;\n        j->walresv += z;\n    }\n\n    job_list_insert(&j->tube->buried, j);\n    global_stat.buried_ct++;\n    j->tube->stat.buried_ct++;\n    j->r.state = Buried;\n    j->reserver = NULL;\n    j->r.bury_ct++;\n\n    if (update_store) {\n        if (!walwrite(&s->wal, j)) {\n            return 0;\n        }\n        walmaint(&s->wal);\n    }\n\n    return 1;\n}\n\nvoid\nenqueue_reserved_jobs(Conn *c)\n{\n    while (!job_list_is_empty(&c->reserved_jobs)) {\n        Job *j = job_list_remove(c->reserved_jobs.next);\n        int r = enqueue_job(c->srv, j, 0, 0);\n        if (r < 1)\n            bury_job(c->srv, j, 0);\n        global_stat.reserved_ct--;\n        j->tube->stat.reserved_ct--;\n        c->soonest_job = NULL;\n    }\n}\n\nstatic int\nkick_buried_job(Server *s, Job *j)\n{\n    int r;\n    int z;\n\n    z = walresvupdate(&s->wal);\n    if (!z)\n        return 0;\n    j->walresv += z;\n\n    remove_buried_job(j);\n\n    j->r.kick_ct++;\n    r = enqueue_job(s, j, 0, 1);\n    if (r == 1)\n        return 1;\n\n    /* ready queue is full, so bury it */\n    bury_job(s, j, 0);\n    return 0;\n}\n\nstatic uint\nget_delayed_job_ct()\n{\n    size_t i;\n    uint count = 0;\n\n    for (i = 0; i < tubes.len; i++) {\n        Tube *t = tubes.items[i];\n        count += t->delay.len;\n    }\n    return count;\n}\n\nstatic int\nkick_delayed_job(Server *s, Job *j)\n{\n    int r;\n    int z;\n\n    z = walresvupdate(&s->wal);\n    if (!z)\n        return 0;\n    j->walresv += z;\n\n    heapremove(&j->tube->delay, j->heap_index);\n\n    j->r.kick_ct++;\n    r = enqueue_job(s, j, 0, 1);\n    if (r == 1)\n        return 1;\n\n    /* ready queue is full, so delay it again */\n    r = enqueue_job(s, j, j->r.delay, 0);\n    if (r == 1)\n        return 0;\n\n    /* last resort */\n    bury_job(s, j, 0);\n    return 0;\n}\n\nstatic int\nburied_job_p(Tube *t)\n{\n    // this function does not do much. inline?\n    return !job_list_is_empty(&t->buried);\n}\n\n/* return the number of jobs successfully kicked */\nstatic uint\nkick_buried_jobs(Server *s, Tube *t, uint n)\n{\n    uint i;\n    for (i = 0; (i < n) && buried_job_p(t); ++i) {\n        kick_buried_job(s, t->buried.next);\n    }\n    return i;\n}\n\n/* return the number of jobs successfully kicked */\nstatic uint\nkick_delayed_jobs(Server *s, Tube *t, uint n)\n{\n    uint i;\n    for (i = 0; (i < n) && (t->delay.len > 0); ++i) {\n        kick_delayed_job(s, (Job *)t->delay.data[0]);\n    }\n    return i;\n}\n\nstatic uint\nkick_jobs(Server *s, Tube *t, uint n)\n{\n    if (buried_job_p(t))\n        return kick_buried_jobs(s, t, n);\n    return kick_delayed_jobs(s, t, n);\n}\n\n// remove_buried_job returns non-NULL value if job j was in the buried state.\n// It excludes the job from the buried list and updates counters.\nstatic Job *\nremove_buried_job(Job *j)\n{\n    if (!j || j->r.state != Buried)\n        return NULL;\n    j = job_list_remove(j);\n    if (j) {\n        global_stat.buried_ct--;\n        j->tube->stat.buried_ct--;\n    }\n    return j;\n}\n\n// remove_delayed_job returns non-NULL value if job j was in the delayed state.\n// It removes the job from the tube delayed heap.\nstatic Job *\nremove_delayed_job(Job *j)\n{\n    if (!j || j->r.state != Delayed)\n        return NULL;\n    heapremove(&j->tube->delay, j->heap_index);\n\n    return j;\n}\n\n// remove_ready_job returns non-NULL value if job j was in the ready state.\n// It removes the job from the tube ready heap and updates counters.\nstatic Job *\nremove_ready_job(Job *j)\n{\n    if (!j || j->r.state != Ready)\n        return NULL;\n    heapremove(&j->tube->ready, j->heap_index);\n    ready_ct--;\n    if (j->r.pri < URGENT_THRESHOLD) {\n        global_stat.urgent_ct--;\n        j->tube->stat.urgent_ct--;\n    }\n    return j;\n}\n\nstatic bool\nis_job_reserved_by_conn(Conn *c, Job *j)\n{\n    return j && j->reserver == c && j->r.state == Reserved;\n}\n\nstatic bool\ntouch_job(Conn *c, Job *j)\n{\n    if (is_job_reserved_by_conn(c, j)) {\n        j->r.deadline_at = nanoseconds() + j->r.ttr;\n        c->soonest_job = NULL;\n        return true;\n    }\n    return false;\n}\n\nstatic void\ncheck_err(Conn *c, const char *s)\n{\n    if (errno == EAGAIN)\n        return;\n    if (errno == EINTR)\n        return;\n    if (errno == EWOULDBLOCK)\n        return;\n\n    twarn(\"%s\", s);\n    c->state = STATE_CLOSE;\n}\n\n/* Scan the given string for the sequence \"\\r\\n\" and return the line length.\n * Always returns at least 2 if a match is found. Returns 0 if no match. */\nstatic size_t\nscan_line_end(const char *s, int size)\n{\n    char *match;\n\n    match = memchr(s, '\\r', size - 1);\n    if (!match)\n        return 0;\n\n    /* this is safe because we only scan size - 1 chars above */\n    if (match[1] == '\\n')\n        return match - s + 2;\n\n    return 0;\n}\n\n/* parse the command line */\nstatic int\nwhich_cmd(Conn *c)\n{\n#define TEST_CMD(s,c,o) if (strncmp((s), (c), CONSTSTRLEN(c)) == 0) return (o);\n    TEST_CMD(c->cmd, CMD_PUT, OP_PUT);\n    TEST_CMD(c->cmd, CMD_PEEKJOB, OP_PEEKJOB);\n    TEST_CMD(c->cmd, CMD_PEEK_READY, OP_PEEK_READY);\n    TEST_CMD(c->cmd, CMD_PEEK_DELAYED, OP_PEEK_DELAYED);\n    TEST_CMD(c->cmd, CMD_PEEK_BURIED, OP_PEEK_BURIED);\n    TEST_CMD(c->cmd, CMD_RESERVE_TIMEOUT, OP_RESERVE_TIMEOUT);\n    TEST_CMD(c->cmd, CMD_RESERVE_JOB, OP_RESERVE_JOB);\n    TEST_CMD(c->cmd, CMD_RESERVE, OP_RESERVE);\n    TEST_CMD(c->cmd, CMD_DELETE, OP_DELETE);\n    TEST_CMD(c->cmd, CMD_RELEASE, OP_RELEASE);\n    TEST_CMD(c->cmd, CMD_BURY, OP_BURY);\n    TEST_CMD(c->cmd, CMD_KICK, OP_KICK);\n    TEST_CMD(c->cmd, CMD_KICKJOB, OP_KICKJOB);\n    TEST_CMD(c->cmd, CMD_TOUCH, OP_TOUCH);\n    TEST_CMD(c->cmd, CMD_STATSJOB, OP_STATSJOB);\n    TEST_CMD(c->cmd, CMD_STATS_TUBE, OP_STATS_TUBE);\n    TEST_CMD(c->cmd, CMD_STATS, OP_STATS);\n    TEST_CMD(c->cmd, CMD_USE, OP_USE);\n    TEST_CMD(c->cmd, CMD_WATCH, OP_WATCH);\n    TEST_CMD(c->cmd, CMD_IGNORE, OP_IGNORE);\n    TEST_CMD(c->cmd, CMD_LIST_TUBES_WATCHED, OP_LIST_TUBES_WATCHED);\n    TEST_CMD(c->cmd, CMD_LIST_TUBE_USED, OP_LIST_TUBE_USED);\n    TEST_CMD(c->cmd, CMD_LIST_TUBES, OP_LIST_TUBES);\n    TEST_CMD(c->cmd, CMD_QUIT, OP_QUIT);\n    TEST_CMD(c->cmd, CMD_PAUSE_TUBE, OP_PAUSE_TUBE);\n    return OP_UNKNOWN;\n}\n\n/* Copy up to body_size trailing bytes into the job, then the rest into the cmd\n * buffer. If c->in_job exists, this assumes that c->in_job->body is empty.\n * This function is idempotent(). */\nstatic void\nfill_extra_data(Conn *c)\n{\n    if (!c->sock.fd)\n        return; /* the connection was closed */\n    if (!c->cmd_len)\n        return; /* we don't have a complete command */\n\n    /* how many extra bytes did we read? */\n    int64 extra_bytes = c->cmd_read - c->cmd_len;\n\n    int64 job_data_bytes = 0;\n    /* how many bytes should we put into the job body? */\n    if (c->in_job) {\n        job_data_bytes = min(extra_bytes, c->in_job->r.body_size);\n        memcpy(c->in_job->body, c->cmd + c->cmd_len, job_data_bytes);\n        c->in_job_read = job_data_bytes;\n    } else if (c->in_job_read) {\n        /* we are in bit-bucket mode, throwing away data */\n        job_data_bytes = min(extra_bytes, c->in_job_read);\n        c->in_job_read -= job_data_bytes;\n    }\n\n    /* how many bytes are left to go into the future cmd? */\n    int64 cmd_bytes = extra_bytes - job_data_bytes;\n    memmove(c->cmd, c->cmd + c->cmd_len + job_data_bytes, cmd_bytes);\n    c->cmd_read = cmd_bytes;\n    c->cmd_len = 0; /* we no longer know the length of the new command */\n}\n\n#define skip(conn,n,msg) (_skip(conn, n, msg, CONSTSTRLEN(msg)))\n\nstatic void\n_skip(Conn *c, int64 n, char *msg, int msglen)\n{\n    /* Invert the meaning of in_job_read while throwing away data -- it\n     * counts the bytes that remain to be thrown away. */\n    c->in_job = 0;\n    c->in_job_read = n;\n    fill_extra_data(c);\n\n    if (c->in_job_read == 0) {\n        reply(c, msg, msglen, STATE_SEND_WORD);\n        return;\n    }\n\n    c->reply = msg;\n    c->reply_len = msglen;\n    c->reply_sent = 0;\n    c->state = STATE_BITBUCKET;\n}\n\nstatic void\nenqueue_incoming_job(Conn *c)\n{\n    int r;\n    Job *j = c->in_job;\n\n    c->in_job = NULL; /* the connection no longer owns this job */\n    c->in_job_read = 0;\n\n    /* check if the trailer is present and correct */\n    if (memcmp(j->body + j->r.body_size - 2, \"\\r\\n\", 2)) {\n        job_free(j);\n        reply_msg(c, MSG_EXPECTED_CRLF);\n        return;\n    }\n\n    if (verbose >= 2) {\n        printf(\"<%d job %\"PRIu64\"\\n\", c->sock.fd, j->r.id);\n    }\n\n    if (drain_mode) {\n        job_free(j);\n        reply_serr(c, MSG_DRAINING);\n        return;\n    }\n\n    if (j->walresv) {\n        reply_serr(c, MSG_INTERNAL_ERROR);\n        return;\n    }\n    j->walresv = walresvput(&c->srv->wal, j);\n    if (!j->walresv) {\n        reply_serr(c, MSG_OUT_OF_MEMORY);\n        return;\n    }\n\n    /* we have a complete job, so let's stick it in the pqueue */\n    r = enqueue_job(c->srv, j, j->r.delay, 1);\n\n    // Dead code: condition cannot happen, r can take 1 or 0 values only.\n    if (r < 0) {\n        reply_serr(c, MSG_INTERNAL_ERROR);\n        return;\n    }\n\n    global_stat.total_jobs_ct++;\n    j->tube->stat.total_jobs_ct++;\n\n    if (r == 1) {\n        reply_line(c, STATE_SEND_WORD, MSG_INSERTED_FMT, j->r.id);\n        return;\n    }\n\n    /* out of memory trying to grow the queue, so it gets buried */\n    bury_job(c->srv, j, 0);\n    reply_line(c, STATE_SEND_WORD, MSG_BURIED_FMT, j->r.id);\n}\n\nstatic uint\nuptime()\n{\n    return (nanoseconds() - started_at) / 1000000000;\n}\n\nstatic int\nfmt_stats(char *buf, size_t size, void *x)\n{\n    int whead = 0, wcur = 0;\n    Server *s = x;\n    struct rusage ru;\n\n    s = x;\n\n    if (s->wal.head) {\n        whead = s->wal.head->seq;\n    }\n\n    if (s->wal.cur) {\n        wcur = s->wal.cur->seq;\n    }\n\n    getrusage(RUSAGE_SELF, &ru); /* don't care if it fails */\n    return snprintf(buf, size, STATS_FMT,\n                    global_stat.urgent_ct,\n                    ready_ct,\n                    global_stat.reserved_ct,\n                    get_delayed_job_ct(),\n                    global_stat.buried_ct,\n                    op_ct[OP_PUT],\n                    op_ct[OP_PEEKJOB],\n                    op_ct[OP_PEEK_READY],\n                    op_ct[OP_PEEK_DELAYED],\n                    op_ct[OP_PEEK_BURIED],\n                    op_ct[OP_RESERVE],\n                    op_ct[OP_RESERVE_TIMEOUT],\n                    op_ct[OP_DELETE],\n                    op_ct[OP_RELEASE],\n                    op_ct[OP_USE],\n                    op_ct[OP_WATCH],\n                    op_ct[OP_IGNORE],\n                    op_ct[OP_BURY],\n                    op_ct[OP_KICK],\n                    op_ct[OP_TOUCH],\n                    op_ct[OP_STATS],\n                    op_ct[OP_STATSJOB],\n                    op_ct[OP_STATS_TUBE],\n                    op_ct[OP_LIST_TUBES],\n                    op_ct[OP_LIST_TUBE_USED],\n                    op_ct[OP_LIST_TUBES_WATCHED],\n                    op_ct[OP_PAUSE_TUBE],\n                    timeout_ct,\n                    global_stat.total_jobs_ct,\n                    job_data_size_limit,\n                    tubes.len,\n                    count_cur_conns(),\n                    count_cur_producers(),\n                    count_cur_workers(),\n                    global_stat.waiting_ct,\n                    count_tot_conns(),\n                    (long) getpid(),\n                    version,\n                    (int) ru.ru_utime.tv_sec, (int) ru.ru_utime.tv_usec,\n                    (int) ru.ru_stime.tv_sec, (int) ru.ru_stime.tv_usec,\n                    uptime(),\n                    whead,\n                    wcur,\n                    s->wal.nmig,\n                    s->wal.nrec,\n                    s->wal.filesize,\n                    drain_mode ? \"true\" : \"false\",\n                    instance_hex,\n                    node_info.nodename,\n                    node_info.version,\n                    node_info.machine);\n}\n\n/* Read an integer from the given buffer and place it in num.\n * Parsed integer should fit into uint64.\n * Update end to point to the address after the last character consumed.\n * num and end can be NULL. If they are both NULL, read_u64() will do the\n * conversion and return the status code but not update any values.\n * This is an easy way to check for errors.\n * If end is NULL, read_u64() will also check that the entire input string\n * was consumed and return an error code otherwise.\n * Return 0 on success, or nonzero on failure.\n * If a failure occurs, num and end are not modified. */\nstatic int\nread_u64(uint64 *num, const char *buf, char **end)\n{\n    uintmax_t tnum;\n    char *tend;\n\n    errno = 0;\n    while (buf[0] == ' ')\n        buf++;\n    if (buf[0] < '0' || '9' < buf[0])\n        return -1;\n    tnum = strtoumax(buf, &tend, 10);\n    if (tend == buf)\n        return -1;\n    if (errno)\n        return -1;\n    if (!end && tend[0] != '\\0')\n        return -1;\n    if (tnum > UINT64_MAX)\n        return -1;\n\n    if (num) *num = (uint64)tnum;\n    if (end) *end = tend;\n    return 0;\n}\n\n// Indentical to read_u64() but instead reads into uint32.\nstatic int\nread_u32(uint32 *num, const char *buf, char **end)\n{\n    uintmax_t tnum;\n    char *tend;\n\n    errno = 0;\n    while (buf[0] == ' ')\n        buf++;\n    if (buf[0] < '0' || '9' < buf[0])\n        return -1;\n    tnum = strtoumax(buf, &tend, 10);\n    if (tend == buf)\n        return -1;\n    if (errno)\n        return -1;\n    if (!end && tend[0] != '\\0')\n        return -1;\n    if (tnum > UINT32_MAX)\n        return -1;\n\n    if (num) *num = (uint32)tnum;\n    if (end) *end = tend;\n    return 0;\n}\n\n/* Read a delay value in seconds from the given buffer and\n   place it in duration in nanoseconds.\n   The interface and behavior are analogous to read_u32(). */\nstatic int\nread_duration(int64 *duration, const char *buf, char **end)\n{\n    int r;\n    uint32 dur_sec;\n\n    r = read_u32(&dur_sec, buf, end);\n    if (r)\n        return r;\n    *duration = ((int64) dur_sec) * 1000000000;\n    return 0;\n}\n\n/* Read a tube name from the given buffer moving the buffer to the name start */\nstatic int\nread_tube_name(char **tubename, char *buf, char **end)\n{\n    size_t len;\n\n    while (buf[0] == ' ')\n        buf++;\n    len = strspn(buf, NAME_CHARS);\n    if (len == 0)\n        return -1;\n    if (tubename)\n        *tubename = buf;\n    if (end)\n        *end = buf + len;\n    return 0;\n}\n\nstatic void\nwait_for_job(Conn *c, int timeout)\n{\n    c->state = STATE_WAIT;\n    enqueue_waiting_conn(c);\n\n    /* Set the pending timeout to the requested timeout amount */\n    c->pending_timeout = timeout;\n\n    // only care if they hang up\n    epollq_add(c, 'h');\n}\n\ntypedef int(*fmt_fn)(char *, size_t, void *);\n\nstatic void\ndo_stats(Conn *c, fmt_fn fmt, void *data)\n{\n    int r, stats_len;\n\n    /* first, measure how big a buffer we will need */\n    stats_len = fmt(NULL, 0, data) + 16;\n\n    c->out_job = allocate_job(stats_len); /* fake job to hold stats data */\n    if (!c->out_job) {\n        reply_serr(c, MSG_OUT_OF_MEMORY);\n        return;\n    }\n\n    /* Mark this job as a copy so it can be appropriately freed later on */\n    c->out_job->r.state = Copy;\n\n    /* now actually format the stats data */\n    r = fmt(c->out_job->body, stats_len, data);\n    /* and set the actual body size */\n    c->out_job->r.body_size = r;\n    if (r > stats_len) {\n        reply_serr(c, MSG_INTERNAL_ERROR);\n        return;\n    }\n\n    c->out_job_sent = 0;\n    reply_line(c, STATE_SEND_JOB, \"OK %d\\r\\n\", r - 2);\n}\n\nstatic void\ndo_list_tubes(Conn *c, Ms *l)\n{\n    char *buf;\n    Tube *t;\n    size_t i, resp_z;\n\n    /* first, measure how big a buffer we will need */\n    resp_z = 6; /* initial \"---\\n\" and final \"\\r\\n\" */\n    for (i = 0; i < l->len; i++) {\n        t = l->items[i];\n        resp_z += 3 + strlen(t->name); /* including \"- \" and \"\\n\" */\n    }\n\n    c->out_job = allocate_job(resp_z); /* fake job to hold response data */\n    if (!c->out_job) {\n        reply_serr(c, MSG_OUT_OF_MEMORY);\n        return;\n    }\n\n    /* Mark this job as a copy so it can be appropriately freed later on */\n    c->out_job->r.state = Copy;\n\n    /* now actually format the response */\n    buf = c->out_job->body;\n    buf += snprintf(buf, 5, \"---\\n\");\n    for (i = 0; i < l->len; i++) {\n        t = l->items[i];\n        buf += snprintf(buf, 4 + strlen(t->name), \"- %s\\n\", t->name);\n    }\n    buf[0] = '\\r';\n    buf[1] = '\\n';\n\n    c->out_job_sent = 0;\n    reply_line(c, STATE_SEND_JOB, \"OK %zu\\r\\n\", resp_z - 2);\n}\n\nstatic int\nfmt_job_stats(char *buf, size_t size, Job *j)\n{\n    int64 t;\n    int64 time_left;\n    int file = 0;\n\n    t = nanoseconds();\n    if (j->r.state == Reserved || j->r.state == Delayed) {\n        time_left = (j->r.deadline_at - t) / 1000000000;\n    } else {\n        time_left = 0;\n    }\n    if (j->file) {\n        file = j->file->seq;\n    }\n    return snprintf(buf, size, STATS_JOB_FMT,\n            j->r.id,\n            j->tube->name,\n            job_state(j),\n            j->r.pri,\n            (t - j->r.created_at) / 1000000000,\n            j->r.delay / 1000000000,\n            j->r.ttr / 1000000000,\n            time_left,\n            file,\n            j->r.reserve_ct,\n            j->r.timeout_ct,\n            j->r.release_ct,\n            j->r.bury_ct,\n            j->r.kick_ct);\n}\n\nstatic int\nfmt_stats_tube(char *buf, size_t size, Tube *t)\n{\n    uint64 time_left;\n\n    if (t->pause > 0) {\n        time_left = (t->unpause_at - nanoseconds()) / 1000000000;\n    } else {\n        time_left = 0;\n    }\n    return snprintf(buf, size, STATS_TUBE_FMT,\n            t->name,\n            t->stat.urgent_ct,\n            t->ready.len,\n            t->stat.reserved_ct,\n            t->delay.len,\n            t->stat.buried_ct,\n            t->stat.total_jobs_ct,\n            t->using_ct,\n            t->watching_ct,\n            t->stat.waiting_ct,\n            t->stat.total_delete_ct,\n            t->stat.pause_ct,\n            t->pause / 1000000000,\n            time_left);\n}\n\nstatic void\nmaybe_enqueue_incoming_job(Conn *c)\n{\n    Job *j = c->in_job;\n\n    /* do we have a complete job? */\n    if (c->in_job_read == j->r.body_size) {\n        enqueue_incoming_job(c);\n        return;\n    }\n\n    /* otherwise we have incomplete data, so just keep waiting */\n    c->state = STATE_WANT_DATA;\n}\n\n/* j can be NULL */\nstatic Job *\nremove_this_reserved_job(Conn *c, Job *j)\n{\n    j = job_list_remove(j);\n    if (j) {\n        global_stat.reserved_ct--;\n        j->tube->stat.reserved_ct--;\n        j->reserver = NULL;\n    }\n    c->soonest_job = NULL;\n    return j;\n}\n\nstatic Job *\nremove_reserved_job(Conn *c, Job *j)\n{\n    if (!is_job_reserved_by_conn(c, j))\n        return NULL;\n    return remove_this_reserved_job(c, j);\n}\n\nstatic bool\nis_valid_tube(const char *name, size_t max)\n{\n    size_t len = strlen(name);\n    return 0 < len && len <= max &&\n        strspn(name, NAME_CHARS) == len &&\n        name[0] != '-';\n}\n\nstatic void\ndispatch_cmd(Conn *c)\n{\n    int r, timeout = -1;\n    uint i;\n    uint count;\n    Job *j = 0;\n    byte type;\n    char *size_buf, *delay_buf, *ttr_buf, *pri_buf, *end_buf, *name;\n    uint32 pri;\n    uint32 body_size;\n    int64 delay, ttr;\n    uint64 id;\n    Tube *t = NULL;\n\n    /* NUL-terminate this string so we can use strtol and friends */\n    c->cmd[c->cmd_len - 2] = '\\0';\n\n    /* check for possible maliciousness */\n    if (strlen(c->cmd) != c->cmd_len - 2) {\n        reply_msg(c, MSG_BAD_FORMAT);\n        return;\n    }\n\n    type = which_cmd(c);\n    if (verbose >= 2) {\n        printf(\"<%d command %s\\n\", c->sock.fd, op_names[type]);\n    }\n\n    switch (type) {\n    case OP_PUT:\n        if (read_u32(&pri, c->cmd + 4, &delay_buf) ||\n            read_duration(&delay, delay_buf, &ttr_buf) ||\n            read_duration(&ttr, ttr_buf, &size_buf) ||\n            read_u32(&body_size, size_buf, &end_buf)) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        if (body_size > job_data_size_limit) {\n            /* throw away the job body and respond with JOB_TOO_BIG */\n            skip(c, (int64)body_size + 2, MSG_JOB_TOO_BIG);\n            return;\n        }\n\n        /* don't allow trailing garbage */\n        if (end_buf[0] != '\\0') {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n\n        connsetproducer(c);\n\n        if (ttr < 1000000000) {\n            ttr = 1000000000;\n        }\n\n        c->in_job = make_job(pri, delay, ttr, body_size + 2, c->use);\n\n        /* OOM? */\n        if (!c->in_job) {\n            /* throw away the job body and respond with OUT_OF_MEMORY */\n            twarnx(\"server error: \" MSG_OUT_OF_MEMORY);\n            skip(c, body_size + 2, MSG_OUT_OF_MEMORY);\n            return;\n        }\n\n        fill_extra_data(c);\n\n        /* it's possible we already have a complete job */\n        maybe_enqueue_incoming_job(c);\n        return;\n\n    case OP_PEEK_READY:\n        /* don't allow trailing garbage */\n        if (c->cmd_len != CMD_PEEK_READY_LEN + 2) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        if (c->use->ready.len) {\n            j = job_copy(c->use->ready.data[0]);\n        }\n\n        if (!j) {\n            reply_msg(c, MSG_NOTFOUND);\n            return;\n        }\n        reply_job(c, j, MSG_FOUND);\n        return;\n\n    case OP_PEEK_DELAYED:\n        /* don't allow trailing garbage */\n        if (c->cmd_len != CMD_PEEK_DELAYED_LEN + 2) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        if (c->use->delay.len) {\n            j = job_copy(c->use->delay.data[0]);\n        }\n\n        if (!j) {\n            reply_msg(c, MSG_NOTFOUND);\n            return;\n        }\n        reply_job(c, j, MSG_FOUND);\n        return;\n\n    case OP_PEEK_BURIED:\n        /* don't allow trailing garbage */\n        if (c->cmd_len != CMD_PEEK_BURIED_LEN + 2) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        if (buried_job_p(c->use))\n            j = job_copy(c->use->buried.next);\n        else\n            j = NULL;\n\n        if (!j) {\n            reply_msg(c, MSG_NOTFOUND);\n            return;\n        }\n        reply_job(c, j, MSG_FOUND);\n        return;\n\n    case OP_PEEKJOB:\n        if (read_u64(&id, c->cmd + CMD_PEEKJOB_LEN, NULL)) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        /* So, peek is annoying, because some other connection might free the\n         * job while we are still trying to write it out. So we copy it and\n         * free the copy when it's done sending, in the \"conn_want_command\" function. */\n        j = job_copy(job_find(id));\n\n        if (!j) {\n            reply_msg(c, MSG_NOTFOUND);\n            return;\n        }\n        reply_job(c, j, MSG_FOUND);\n        return;\n\n    case OP_RESERVE_TIMEOUT:\n        errno = 0;\n        uint32 utimeout = 0;\n        if (read_u32(&utimeout, c->cmd + CMD_RESERVE_TIMEOUT_LEN, &end_buf) != 0 || utimeout > INT_MAX) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        timeout = (int)utimeout;\n        /* Falls through */\n\n    case OP_RESERVE:\n        /* don't allow trailing garbage */\n        if (type == OP_RESERVE && c->cmd_len != CMD_RESERVE_LEN + 2) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n        connsetworker(c);\n\n        if (conndeadlinesoon(c) && !conn_ready(c)) {\n            reply_msg(c, MSG_DEADLINE_SOON);\n            return;\n        }\n\n        /* try to get a new job for this guy */\n        wait_for_job(c, timeout);\n        process_queue();\n        return;\n\n    case OP_RESERVE_JOB:\n        if (read_u64(&id, c->cmd + CMD_RESERVE_JOB_LEN, NULL)) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        // This command could produce \"deadline soon\" if\n        // the connection has a reservation about to expire.\n        // We choose not to do it, because this command does not block\n        // for an arbitrary amount of time as reserve and reserve-with-timeout.\n\n        j = job_find(id);\n        if (!j) {\n            reply_msg(c, MSG_NOTFOUND);\n            return;\n        }\n        // Check if this job is already reserved.\n        if (j->r.state == Reserved || j->r.state == Invalid) {\n            reply_msg(c, MSG_NOTFOUND);\n            return;\n        }\n\n        // Job can be in ready, buried or delayed states.\n        if (j->r.state == Ready) {\n            j = remove_ready_job(j);\n        } else if (j->r.state == Buried) {\n            j = remove_buried_job(j);\n        } else if (j->r.state == Delayed) {\n            j = remove_delayed_job(j);\n        } else {\n            reply_serr(c, MSG_INTERNAL_ERROR);\n            return;\n        }\n\n        connsetworker(c);\n        global_stat.reserved_ct++;\n\n        conn_reserve_job(c, j);\n        reply_job(c, j, MSG_RESERVED);\n        return;\n\n    case OP_DELETE:\n        if (read_u64(&id, c->cmd + CMD_DELETE_LEN, NULL)) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        {\n            Job *jf = job_find(id);\n            j = remove_reserved_job(c, jf);\n            if (!j)\n                j = remove_ready_job(jf);\n            if (!j)\n                j = remove_buried_job(jf);\n            if (!j)\n                j = remove_delayed_job(jf);\n        }\n\n        if (!j) {\n            reply_msg(c, MSG_NOTFOUND);\n            return;\n        }\n\n        j->tube->stat.total_delete_ct++;\n\n        j->r.state = Invalid;\n        r = walwrite(&c->srv->wal, j);\n        walmaint(&c->srv->wal);\n        job_free(j);\n\n        if (!r) {\n            reply_serr(c, MSG_INTERNAL_ERROR);\n            return;\n        }\n        reply_msg(c, MSG_DELETED);\n        return;\n\n    case OP_RELEASE:\n        if (read_u64(&id, c->cmd + CMD_RELEASE_LEN, &pri_buf) ||\n            read_u32(&pri, pri_buf, &delay_buf) ||\n            read_duration(&delay, delay_buf, NULL)) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        j = remove_reserved_job(c, job_find(id));\n\n        if (!j) {\n            reply_msg(c, MSG_NOTFOUND);\n            return;\n        }\n\n        /* We want to update the delay deadline on disk, so reserve space for\n         * that. */\n        if (delay) {\n            int z = walresvupdate(&c->srv->wal);\n            if (!z) {\n                reply_serr(c, MSG_OUT_OF_MEMORY);\n                return;\n            }\n            j->walresv += z;\n        }\n\n        j->r.pri = pri;\n        j->r.delay = delay;\n        j->r.release_ct++;\n\n        r = enqueue_job(c->srv, j, delay, !!delay);\n        if (r < 0) {\n            reply_serr(c, MSG_INTERNAL_ERROR);\n            return;\n        }\n        if (r == 1) {\n            reply_msg(c, MSG_RELEASED);\n            return;\n        }\n\n        /* out of memory trying to grow the queue, so it gets buried */\n        bury_job(c->srv, j, 0);\n        reply_msg(c, MSG_BURIED);\n        return;\n\n    case OP_BURY:\n        if (read_u64(&id, c->cmd + CMD_BURY_LEN, &pri_buf) ||\n            read_u32(&pri, pri_buf, NULL)) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n\n        op_ct[type]++;\n\n        j = remove_reserved_job(c, job_find(id));\n\n        if (!j) {\n            reply_msg(c, MSG_NOTFOUND);\n            return;\n        }\n\n        j->r.pri = pri;\n        r = bury_job(c->srv, j, 1);\n        if (!r) {\n            reply_serr(c, MSG_INTERNAL_ERROR);\n            return;\n        }\n        reply_msg(c, MSG_BURIED);\n        return;\n\n    case OP_KICK:\n        errno = 0;\n        count = strtoul(c->cmd + CMD_KICK_LEN, &end_buf, 10);\n        if (end_buf == c->cmd + CMD_KICK_LEN || errno) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n\n        op_ct[type]++;\n\n        i = kick_jobs(c->srv, c->use, count);\n        reply_line(c, STATE_SEND_WORD, \"KICKED %u\\r\\n\", i);\n        return;\n\n    case OP_KICKJOB:\n        if (read_u64(&id, c->cmd + CMD_KICKJOB_LEN, NULL)) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n\n        op_ct[type]++;\n\n        j = job_find(id);\n        if (!j) {\n            reply_msg(c, MSG_NOTFOUND);\n            return;\n        }\n\n        if ((j->r.state == Buried && kick_buried_job(c->srv, j)) ||\n            (j->r.state == Delayed && kick_delayed_job(c->srv, j))) {\n            reply_msg(c, MSG_KICKED);\n        } else {\n            reply_msg(c, MSG_NOTFOUND);\n        }\n        return;\n\n    case OP_TOUCH:\n        if (read_u64(&id, c->cmd + CMD_TOUCH_LEN, NULL)) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        if (touch_job(c, job_find(id))) {\n            reply_msg(c, MSG_TOUCHED);\n        } else {\n            reply_msg(c, MSG_NOTFOUND);\n        }\n        return;\n\n    case OP_STATS:\n        /* don't allow trailing garbage */\n        if (c->cmd_len != CMD_STATS_LEN + 2) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        do_stats(c, fmt_stats, c->srv);\n        return;\n\n    case OP_STATSJOB:\n        if (read_u64(&id, c->cmd + CMD_STATSJOB_LEN, NULL)) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        j = job_find(id);\n        if (!j) {\n            reply_msg(c, MSG_NOTFOUND);\n            return;\n        }\n\n        if (!j->tube) {\n            reply_serr(c, MSG_INTERNAL_ERROR);\n            return;\n        }\n        do_stats(c, (fmt_fn) fmt_job_stats, j);\n        return;\n\n    case OP_STATS_TUBE:\n        name = c->cmd + CMD_STATS_TUBE_LEN;\n        if (!is_valid_tube(name, MAX_TUBE_NAME_LEN - 1)) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        t = tube_find(&tubes, name);\n        if (!t) {\n            reply_msg(c, MSG_NOTFOUND);\n            return;\n        }\n        do_stats(c, (fmt_fn) fmt_stats_tube, t);\n        t = NULL;\n        return;\n\n    case OP_LIST_TUBES:\n        /* don't allow trailing garbage */\n        if (c->cmd_len != CMD_LIST_TUBES_LEN + 2) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n        do_list_tubes(c, &tubes);\n        return;\n\n    case OP_LIST_TUBE_USED:\n        /* don't allow trailing garbage */\n        if (c->cmd_len != CMD_LIST_TUBE_USED_LEN + 2) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n        reply_line(c, STATE_SEND_WORD, \"USING %s\\r\\n\", c->use->name);\n        return;\n\n    case OP_LIST_TUBES_WATCHED:\n        /* don't allow trailing garbage */\n        if (c->cmd_len != CMD_LIST_TUBES_WATCHED_LEN + 2) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n        do_list_tubes(c, &c->watch);\n        return;\n\n    case OP_USE:\n        name = c->cmd + CMD_USE_LEN;\n        if (!is_valid_tube(name, MAX_TUBE_NAME_LEN - 1)) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        TUBE_ASSIGN(t, tube_find_or_make(name));\n        if (!t) {\n            reply_serr(c, MSG_OUT_OF_MEMORY);\n            return;\n        }\n\n        c->use->using_ct--;\n        TUBE_ASSIGN(c->use, t);\n        TUBE_ASSIGN(t, NULL);\n        c->use->using_ct++;\n\n        reply_line(c, STATE_SEND_WORD, \"USING %s\\r\\n\", c->use->name);\n        return;\n\n    case OP_WATCH:\n        name = c->cmd + CMD_WATCH_LEN;\n        if (!is_valid_tube(name, MAX_TUBE_NAME_LEN - 1)) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        TUBE_ASSIGN(t, tube_find_or_make(name));\n        if (!t) {\n            reply_serr(c, MSG_OUT_OF_MEMORY);\n            return;\n        }\n\n        r = 1;\n        if (!ms_contains(&c->watch, t))\n            r = ms_append(&c->watch, t);\n        TUBE_ASSIGN(t, NULL);\n        if (!r) {\n            reply_serr(c, MSG_OUT_OF_MEMORY);\n            return;\n        }\n        reply_line(c, STATE_SEND_WORD, \"WATCHING %zu\\r\\n\", c->watch.len);\n        return;\n\n    case OP_IGNORE:\n        name = c->cmd + CMD_IGNORE_LEN;\n        if (!is_valid_tube(name, MAX_TUBE_NAME_LEN - 1)) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        t = tube_find(&c->watch, name);\n        if (t && c->watch.len < 2) {\n            reply_msg(c, MSG_NOT_IGNORED);\n            return;\n        }\n\n        if (t)\n            ms_remove(&c->watch, t); /* may free t if refcount => 0 */\n        t = NULL;\n        reply_line(c, STATE_SEND_WORD, \"WATCHING %zu\\r\\n\", c->watch.len);\n        return;\n\n    case OP_QUIT:\n        c->state = STATE_CLOSE;\n        return;\n\n    case OP_PAUSE_TUBE:\n        if (read_tube_name(&name, c->cmd + CMD_PAUSE_TUBE_LEN, &delay_buf) ||\n            read_duration(&delay, delay_buf, NULL)) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        op_ct[type]++;\n\n        *delay_buf = '\\0';\n        if (!is_valid_tube(name, MAX_TUBE_NAME_LEN - 1)) {\n            reply_msg(c, MSG_BAD_FORMAT);\n            return;\n        }\n        t = tube_find(&tubes, name);\n        if (!t) {\n            reply_msg(c, MSG_NOTFOUND);\n            return;\n        }\n\n        // Always pause for a positive amount of time, to make sure\n        // that waiting clients wake up when the deadline arrives.\n        if (delay == 0) {\n            delay = 1;\n        }\n\n        t->unpause_at = nanoseconds() + delay;\n        t->pause = delay;\n        t->stat.pause_ct++;\n\n        reply_line(c, STATE_SEND_WORD, \"PAUSED\\r\\n\");\n        return;\n\n    default:\n        reply_msg(c, MSG_UNKNOWN_COMMAND);\n    }\n}\n\n/* There are three reasons this function may be called. We need to check for\n * all of them.\n *\n *  1. A reserved job has run out of time.\n *  2. A waiting client's reserved job has entered the safety margin.\n *  3. A waiting client's requested timeout has occurred.\n *\n * If any of these happen, we must do the appropriate thing. */\nstatic void\nconn_timeout(Conn *c)\n{\n    int should_timeout = 0;\n    Job *j;\n\n    /* Check if the client was trying to reserve a job. */\n    if (conn_waiting(c) && conndeadlinesoon(c))\n        should_timeout = 1;\n\n    /* Check if any reserved jobs have run out of time. We should do this\n     * whether or not the client is waiting for a new reservation. */\n    while ((j = connsoonestjob(c))) {\n        if (j->r.deadline_at >= nanoseconds())\n            break;\n\n        /* This job is in the middle of being written out. If we return it to\n         * the ready queue, someone might free it before we finish writing it\n         * out to the socket. So we'll copy it here and free the copy when it's\n         * done sending. */\n        if (j == c->out_job) {\n            c->out_job = job_copy(c->out_job);\n        }\n\n        timeout_ct++; /* stats */\n        j->r.timeout_ct++;\n        int r = enqueue_job(c->srv, remove_this_reserved_job(c, j), 0, 0);\n        if (r < 1)\n            bury_job(c->srv, j, 0); /* out of memory, so bury it */\n        connsched(c);\n    }\n\n    if (should_timeout) {\n        remove_waiting_conn(c);\n        reply_msg(c, MSG_DEADLINE_SOON);\n    } else if (conn_waiting(c) && c->pending_timeout >= 0) {\n        c->pending_timeout = -1;\n        remove_waiting_conn(c);\n        reply_msg(c, MSG_TIMED_OUT);\n    }\n}\n\nvoid\nenter_drain_mode(int sig)\n{\n    UNUSED_PARAMETER(sig);\n    drain_mode = 1;\n}\n\nstatic void\nconn_want_command(Conn *c)\n{\n    epollq_add(c, 'r');\n\n    /* was this a peek or stats command? */\n    if (c->out_job && c->out_job->r.state == Copy)\n        job_free(c->out_job);\n    c->out_job = NULL;\n\n    c->reply_sent = 0; /* now that we're done, reset this */\n    c->state = STATE_WANT_COMMAND;\n}\n\nstatic void\nconn_process_io(Conn *c)\n{\n    int r;\n    int64 to_read;\n    Job *j;\n    struct iovec iov[2];\n\n    switch (c->state) {\n    case STATE_WANT_COMMAND:\n        r = read(c->sock.fd, c->cmd + c->cmd_read, LINE_BUF_SIZE - c->cmd_read);\n        if (r == -1) {\n            check_err(c, \"read()\");\n            return;\n        }\n        if (r == 0) {\n            c->state = STATE_CLOSE;\n            return;\n        }\n\n        c->cmd_read += r;\n        c->cmd_len = scan_line_end(c->cmd, c->cmd_read);\n        if (c->cmd_len) {\n            // We found complete command line. Bail out to h_conn.\n            return;\n        }\n\n        // c->cmd_read > LINE_BUF_SIZE can't happen\n\n        if (c->cmd_read == LINE_BUF_SIZE) {\n            // Command line too long.\n            // Put connection into special state that discards\n            // the command line until the end line is found.\n            c->cmd_read = 0; // discard the input so far\n            c->state = STATE_WANT_ENDLINE;\n        }\n        // We have an incomplete line, so just keep waiting.\n        return;\n\n    case STATE_WANT_ENDLINE:\n        r = read(c->sock.fd, c->cmd + c->cmd_read, LINE_BUF_SIZE - c->cmd_read);\n        if (r == -1) {\n            check_err(c, \"read()\");\n            return;\n        }\n        if (r == 0) {\n            c->state = STATE_CLOSE;\n            return;\n        }\n\n        c->cmd_read += r;\n        c->cmd_len = scan_line_end(c->cmd, c->cmd_read);\n        if (c->cmd_len) {\n            // Found the EOL. Reply and reuse whatever was read afer the EOL.\n            reply_msg(c, MSG_BAD_FORMAT);\n            fill_extra_data(c);\n            return;\n        }\n\n        // c->cmd_read > LINE_BUF_SIZE can't happen\n\n        if (c->cmd_read == LINE_BUF_SIZE) {\n            // Keep discarding the input since no EOL was found.\n            c->cmd_read = 0;\n        }\n        return;\n\n    case STATE_BITBUCKET: {\n        /* Invert the meaning of in_job_read while throwing away data -- it\n         * counts the bytes that remain to be thrown away. */\n        static char bucket[BUCKET_BUF_SIZE];\n        to_read = min(c->in_job_read, BUCKET_BUF_SIZE);\n        r = read(c->sock.fd, bucket, to_read);\n        if (r == -1) {\n            check_err(c, \"read()\");\n            return;\n        }\n        if (r == 0) {\n            c->state = STATE_CLOSE;\n            return;\n        }\n\n        c->in_job_read -= r; /* we got some bytes */\n\n        /* (c->in_job_read < 0) can't happen */\n\n        if (c->in_job_read == 0) {\n            reply(c, c->reply, c->reply_len, STATE_SEND_WORD);\n        }\n        return;\n    }\n    case STATE_WANT_DATA:\n        j = c->in_job;\n\n        r = read(c->sock.fd, j->body + c->in_job_read, j->r.body_size -c->in_job_read);\n        if (r == -1) {\n            check_err(c, \"read()\");\n            return;\n        }\n        if (r == 0) {\n            c->state = STATE_CLOSE;\n            return;\n        }\n\n        c->in_job_read += r; /* we got some bytes */\n\n        /* (j->in_job_read > j->r.body_size) can't happen */\n\n        maybe_enqueue_incoming_job(c);\n        return;\n    case STATE_SEND_WORD:\n        r= write(c->sock.fd, c->reply + c->reply_sent, c->reply_len - c->reply_sent);\n        if (r == -1) {\n            check_err(c, \"write()\");\n            return;\n        }\n        if (r == 0) {\n            c->state = STATE_CLOSE;\n            return;\n        }\n\n        c->reply_sent += r; /* we got some bytes */\n\n        /* (c->reply_sent > c->reply_len) can't happen */\n\n        if (c->reply_sent == c->reply_len) {\n            conn_want_command(c);\n            return;\n        }\n\n        /* otherwise we sent an incomplete reply, so just keep waiting */\n        break;\n    case STATE_SEND_JOB:\n        j = c->out_job;\n\n        iov[0].iov_base = (void *)(c->reply + c->reply_sent);\n        iov[0].iov_len = c->reply_len - c->reply_sent; /* maybe 0 */\n        iov[1].iov_base = j->body + c->out_job_sent;\n        iov[1].iov_len = j->r.body_size - c->out_job_sent;\n\n        r = writev(c->sock.fd, iov, 2);\n        if (r == -1) {\n            check_err(c, \"writev()\");\n            return;\n        }\n        if (r == 0) {\n            c->state = STATE_CLOSE;\n            return;\n        }\n\n        /* update the sent values */\n        c->reply_sent += r;\n        if (c->reply_sent >= c->reply_len) {\n            c->out_job_sent += c->reply_sent - c->reply_len;\n            c->reply_sent = c->reply_len;\n        }\n\n        /* (c->out_job_sent > j->r.body_size) can't happen */\n\n        /* are we done? */\n        if (c->out_job_sent == j->r.body_size) {\n            if (verbose >= 2) {\n                printf(\">%d job %\"PRIu64\"\\n\", c->sock.fd, j->r.id);\n            }\n            conn_want_command(c);\n            return;\n        }\n\n        /* otherwise we sent incomplete data, so just keep waiting */\n        break;\n    case STATE_WAIT:\n        if (c->halfclosed) {\n            c->pending_timeout = -1;\n            remove_waiting_conn(c);\n            reply_msg(c, MSG_TIMED_OUT);\n            return;\n        }\n        break;\n    }\n}\n\n#define want_command(c) ((c)->sock.fd && ((c)->state == STATE_WANT_COMMAND))\n#define cmd_data_ready(c) (want_command(c) && (c)->cmd_read)\n\nstatic void\nh_conn(const int fd, const short which, Conn *c)\n{\n    if (fd != c->sock.fd) {\n        twarnx(\"Argh! event fd doesn't match conn fd.\");\n        close(fd);\n        connclose(c);\n        epollq_apply();\n        return;\n    }\n\n    if (which == 'h') {\n        c->halfclosed = 1;\n    }\n\n    conn_process_io(c);\n    while (cmd_data_ready(c) && (c->cmd_len = scan_line_end(c->cmd, c->cmd_read))) {\n        dispatch_cmd(c);\n        fill_extra_data(c);\n    }\n    if (c->state == STATE_CLOSE) {\n        epollq_rmconn(c);\n        connclose(c);\n    }\n    epollq_apply();\n}\n\nstatic void\nprothandle(Conn *c, int ev)\n{\n    h_conn(c->sock.fd, ev, c);\n}\n\n// prottick returns nanoseconds till the next work.\nint64\nprottick(Server *s)\n{\n    Job *j;\n    int64 now;\n    Tube *t;\n    int64 period = 0x34630B8A000LL; /* 1 hour in nanoseconds */\n    int64 d;\n\n    now = nanoseconds();\n\n    // Enqueue all jobs that are no longer delayed.\n    // Capture the smallest period from the soonest delayed job.\n    while ((j = soonest_delayed_job())) {\n        d = j->r.deadline_at - now;\n        if (d > 0) {\n            period = min(period, d);\n            break;\n        }\n        heapremove(&j->tube->delay, j->heap_index);\n        int r = enqueue_job(s, j, 0, 0);\n        if (r < 1)\n            bury_job(s, j, 0);  /* out of memory */\n    }\n\n    // Unpause every possible tube and process the queue.\n    // Capture the smallest period from the soonest pause deadline.\n    size_t i;\n    for (i = 0; i < tubes.len; i++) {\n        t = tubes.items[i];\n        d = t->unpause_at - now;\n        if (t->pause && d <= 0) {\n            t->pause = 0;\n            process_queue();\n        }\n        else if (d > 0) {\n            period = min(period, d);\n        }\n    }\n\n    // Process connections with pending timeouts. Release jobs with expired ttr.\n    // Capture the smallest period from the soonest connection.\n    while (s->conns.len) {\n        Conn *c = s->conns.data[0];\n        d = c->tickat - now;\n        if (d > 0) {\n            period = min(period, d);\n            break;\n        }\n        heapremove(&s->conns, 0);\n        c->in_conns = 0;\n        conn_timeout(c);\n    }\n\n    epollq_apply();\n\n    return period;\n}\n\nvoid\nh_accept(const int fd, const short which, Server *s)\n{\n    UNUSED_PARAMETER(which);\n    struct sockaddr_storage addr;\n\n    socklen_t addrlen = sizeof addr;\n    int cfd = accept(fd, (struct sockaddr *)&addr, &addrlen);\n    if (cfd == -1) {\n        if (errno != EAGAIN && errno != EWOULDBLOCK) twarn(\"accept()\");\n        epollq_apply();\n        return;\n    }\n    if (verbose) {\n        printf(\"accept %d\\n\", cfd);\n    }\n\n    int flags = fcntl(cfd, F_GETFL, 0);\n    if (flags < 0) {\n        twarn(\"getting flags\");\n        close(cfd);\n        if (verbose) {\n            printf(\"close %d\\n\", cfd);\n        }\n        epollq_apply();\n        return;\n    }\n\n    int r = fcntl(cfd, F_SETFL, flags | O_NONBLOCK);\n    if (r < 0) {\n        twarn(\"setting O_NONBLOCK\");\n        close(cfd);\n        if (verbose) {\n            printf(\"close %d\\n\", cfd);\n        }\n        epollq_apply();\n        return;\n    }\n\n    Conn *c = make_conn(cfd, STATE_WANT_COMMAND, default_tube, default_tube);\n    if (!c) {\n        twarnx(\"make_conn() failed\");\n        close(cfd);\n        if (verbose) {\n            printf(\"close %d\\n\", cfd);\n        }\n        epollq_apply();\n        return;\n    }\n    c->srv = s;\n    c->sock.x = c;\n    c->sock.f = (Handle)prothandle;\n    c->sock.fd = cfd;\n\n    r = sockwant(&c->sock, 'r');\n    if (r == -1) {\n        twarn(\"sockwant\");\n        close(cfd);\n        if (verbose) {\n            printf(\"close %d\\n\", cfd);\n        }\n    }\n    epollq_apply();\n}\n\nvoid\nprot_init()\n{\n    started_at = nanoseconds();\n    memset(op_ct, 0, sizeof(op_ct));\n\n    int dev_random = open(\"/dev/urandom\", O_RDONLY);\n    if (dev_random < 0) {\n        twarn(\"open /dev/urandom\");\n        exit(50);\n    }\n\n    int i, r;\n    byte rand_data[instance_id_bytes];\n    r = read(dev_random, &rand_data, instance_id_bytes);\n    if (r != instance_id_bytes) {\n        twarn(\"read /dev/urandom\");\n        exit(50);\n    }\n    for (i = 0; i < instance_id_bytes; i++) {\n        sprintf(instance_hex + (i * 2), \"%02x\", rand_data[i]);\n    }\n    close(dev_random);\n\n    if (uname(&node_info) == -1) {\n        warn(\"uname\");\n        exit(50);\n    }\n\n    ms_init(&tubes, NULL, NULL);\n\n    TUBE_ASSIGN(default_tube, tube_find_or_make(\"default\"));\n    if (!default_tube)\n        twarnx(\"Out of memory during startup!\");\n}\n\n// For each job in list, inserts the job into the appropriate data\n// structures and adds it to the log.\n//\n// Returns 1 on success, 0 on failure.\nint\nprot_replay(Server *s, Job *list)\n{\n    Job *j, *nj;\n    int64 t;\n    int r;\n\n    for (j = list->next ; j != list ; j = nj) {\n        nj = j->next;\n        job_list_remove(j);\n        int z = walresvupdate(&s->wal);\n        if (!z) {\n            twarnx(\"failed to reserve space\");\n            return 0;\n        }\n        int64 delay = 0;\n        switch (j->r.state) {\n        case Buried: {\n            bury_job(s, j, 0);\n            break;\n        }\n        case Delayed:\n            t = nanoseconds();\n            if (t < j->r.deadline_at) {\n                delay = j->r.deadline_at - t;\n            }\n            /* Falls through */\n        default:\n            r = enqueue_job(s, j, delay, 0);\n            if (r < 1)\n                twarnx(\"error recovering job %\"PRIu64, j->r.id);\n        }\n    }\n    return 1;\n}\n"
        },
        {
          "name": "serv.c",
          "type": "blob",
          "size": 1.6611328125,
          "content": "#include \"dat.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n\nstruct Server srv = {\n    .port = Portdef,\n    .wal = {\n        .filesize = Filesizedef,\n        .wantsync = 1,\n        .syncrate = DEFAULT_FSYNC_MS * 1000000,\n    },\n};\n\n// srv_acquire_wal tries to lock the wal dir specified by s->wal and\n// replay entries from it to initialize the s state with jobs.\n// On errors it exits from the program.\nvoid srv_acquire_wal(Server *s) {\n    if (s->wal.use) {\n        // We want to make sure that only one beanstalkd tries\n        // to use the wal directory at a time. So acquire a lock\n        // now and never release it.\n        if (!waldirlock(&s->wal)) {\n            twarnx(\"failed to lock wal dir %s\", s->wal.dir);\n            exit(10);\n        }\n\n        Job list = {.prev=NULL, .next=NULL};\n        list.prev = list.next = &list;\n        walinit(&s->wal, &list);\n        int ok = prot_replay(s, &list);\n        if (!ok) {\n            twarnx(\"failed to replay log\");\n            exit(1);\n        }\n    }\n}\n\nvoid\nsrvserve(Server *s)\n{\n    Socket *sock;\n\n    if (sockinit() == -1) {\n        twarnx(\"sockinit\");\n        exit(1);\n    }\n\n    s->sock.x = s;\n    s->sock.f = (Handle)srvaccept;\n    s->conns.less = conn_less;\n    s->conns.setpos = conn_setpos;\n\n    if (sockwant(&s->sock, 'r') == -1) {\n        twarn(\"sockwant\");\n        exit(2);\n    }\n\n\n    for (;;) {\n        int64 period = prottick(s);\n\n        int rw = socknext(&sock, period);\n        if (rw == -1) {\n            twarnx(\"socknext\");\n            exit(1);\n        }\n\n        if (rw) {\n            sock->f(sock->x, rw);\n        }\n    }\n}\n\n\nvoid\nsrvaccept(Server *s, int ev)\n{\n    h_accept(s->sock.fd, ev, s);\n}\n"
        },
        {
          "name": "sunos.c",
          "type": "blob",
          "size": 1.8037109375,
          "content": "#include <stdint.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <errno.h>\n#include <poll.h>\n#include <port.h>\n#include \"dat.h\"\n\nstatic int portfd;\n\nint\nsockinit(void)\n{\n    portfd = port_create();\n    if (portfd == -1) {\n        twarn(\"port_create\");\n        return -1;\n    }\n    return 0;\n}\n\n\nint\nsockwant(Socket *s, int rw)\n{\n    int events = 0;\n\n    if (rw) {\n        switch (rw) {\n        case 'r':\n            events |= POLLIN;\n            break;\n        case 'w':\n            events |= POLLOUT;\n            break;\n        }\n    }\n\n    events |= POLLPRI;\n\n    if (!s->added && !rw) {\n        return 0;\n    } else if (!s->added && rw) {\n        s->added = 1;\n        return port_associate(portfd, PORT_SOURCE_FD, s->fd, events, (void *)s);\n    } else if (!rw) {\n        return port_dissociate(portfd, PORT_SOURCE_FD, s->fd);\n    } else {\n        port_dissociate(portfd, PORT_SOURCE_FD, s->fd);\n        return port_associate(portfd, PORT_SOURCE_FD, s->fd, events, (void *)s);\n    }\n}\n\n\nint\nsocknext(Socket **s, int64 timeout)\n{\n    int r;\n    uint_t n = 1;\n    struct port_event pe;\n    struct timespec ts;\n\n    ts.tv_sec = timeout / 1000000000;\n    ts.tv_nsec = timeout % 1000000000;\n    r = port_getn(portfd, &pe, 1, &n, &ts);\n    if (r == -1 && errno != ETIME && errno != EINTR) {\n        twarn(\"port_getn\");\n        return -1;\n    }\n\n    if (r == 0) {\n        *s = pe.portev_user;\n        if (pe.portev_events & POLLHUP) {\n            return 'h';\n        } else if (pe.portev_events & POLLIN) {\n            if (sockwant(*s, 'r') == -1) {\n                return -1;\n            }\n            return 'r';\n        } else if (pe.portev_events & POLLOUT) {\n            if (sockwant(*s, 'w') == -1) {\n                return -1;\n            }\n            return 'w';\n        }\n    }\n\n    return 0;\n}\n"
        },
        {
          "name": "testheap.c",
          "type": "blob",
          "size": 6.267578125,
          "content": "#include \"dat.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/time.h>\n#include \"ct/ct.h\"\n\n\nvoid\ncttest_heap_insert_one()\n{\n    Heap h = {\n        .less = job_pri_less,\n        .setpos = job_setpos,\n    };\n\n    Job *j = make_job(1, 0, 1, 0, 0);\n    assertf(j, \"allocate job\");\n\n    heapinsert(&h, j);\n    assertf(h.len == 1, \"h should contain one item.\");\n    assertf(j->heap_index == 0, \"should match\");\n\n    assert(heapremove(&h, 0));\n    job_free(j);\n    free(h.data);\n}\n\nvoid\ncttest_heap_insert_and_remove_one()\n{\n    Heap h = {\n        .less = job_pri_less,\n        .setpos = job_setpos,\n    };\n\n    Job *j1 = make_job(1, 0, 1, 0, 0);\n    assertf(j1, \"allocate job\");\n\n    int r = heapinsert(&h, j1);\n    assertf(r, \"insert should succeed\");\n\n    Job *got = heapremove(&h, 0);\n    assertf(got == j1, \"j1 should come back out\");\n    assertf(h.len == 0, \"h should be empty.\");\n\n    free(h.data);\n    job_free(j1);\n}\n\nvoid\ncttest_heap_priority()\n{\n    Heap h = {\n        .less = job_pri_less,\n        .setpos = job_setpos,\n    };\n    Job *j, *j1, *j2, *j3;\n\n    j1 = make_job(1, 0, 1, 0, 0);\n    j2 = make_job(2, 0, 1, 0, 0);\n    j3 = make_job(3, 0, 1, 0, 0);\n    assertf(j1, \"allocate job\");\n    assertf(j2, \"allocate job\");\n    assertf(j3, \"allocate job\");\n\n    int r = heapinsert(&h, j2);\n    assertf(r, \"insert should succeed\");\n    assertf(j2->heap_index == 0, \"should match\");\n\n    r = heapinsert(&h, j3);\n    assertf(r, \"insert should succeed\");\n    assertf(j2->heap_index == 0, \"should match\");\n    assertf(j3->heap_index == 1, \"should match\");\n\n    r = heapinsert(&h, j1);\n    assertf(r, \"insert should succeed\");\n    assertf(j1->heap_index == 0, \"should match\");\n    assertf(j2->heap_index == 2, \"should match\");\n    assertf(j3->heap_index == 1, \"should match\");\n\n    j = heapremove(&h, 0);\n    assertf(j == j1, \"j1 should come out first.\");\n    assertf(j2->heap_index == 0, \"should match\");\n    assertf(j3->heap_index == 1, \"should match\");\n\n    j = heapremove(&h, 0);\n    assertf(j == j2, \"j2 should come out second.\");\n    assertf(j3->heap_index == 0, \"should match\");\n\n    j = heapremove(&h, 0);\n    assertf(j == j3, \"j3 should come out third.\");\n\n    free(h.data);\n    job_free(j1);\n    job_free(j2);\n    job_free(j3);\n}\n\nvoid\ncttest_heap_fifo_property()\n{\n    Heap h = {\n        .less = job_pri_less,\n        .setpos = job_setpos,\n    };\n    Job *j, *j3a, *j3b, *j3c;\n\n    j3a = make_job(3, 0, 1, 0, 0);\n    j3b = make_job(3, 0, 1, 0, 0);\n    j3c = make_job(3, 0, 1, 0, 0);\n    assertf(j3a, \"allocate job\");\n    assertf(j3b, \"allocate job\");\n    assertf(j3c, \"allocate job\");\n\n    int r = heapinsert(&h, j3a);\n    assertf(r, \"insert should succeed\");\n    assertf(h.data[0] == j3a, \"j3a should be in pos 0\");\n    assertf(j3a->heap_index == 0, \"should match\");\n\n    r = heapinsert(&h, j3b);\n    assertf(r, \"insert should succeed\");\n    assertf(h.data[1] == j3b, \"j3b should be in pos 1\");\n    assertf(j3a->heap_index == 0, \"should match\");\n    assertf(j3b->heap_index == 1, \"should match\");\n\n    r = heapinsert(&h, j3c);\n    assertf(r, \"insert should succeed\");\n    assertf(h.data[2] == j3c, \"j3c should be in pos 2\");\n    assertf(j3a->heap_index == 0, \"should match\");\n    assertf(j3b->heap_index == 1, \"should match\");\n    assertf(j3c->heap_index == 2, \"should match\");\n\n    j = heapremove(&h, 0);\n    assertf(j == j3a, \"j3a should come out first.\");\n    assertf(j3b->heap_index == 0, \"should match\");\n    assertf(j3c->heap_index == 1, \"should match\");\n\n    j = heapremove(&h, 0);\n    assertf(j == j3b, \"j3b should come out second.\");\n    assertf(j3c->heap_index == 0, \"should match\");\n\n    j = heapremove(&h, 0);\n    assertf(j == j3c, \"j3c should come out third.\");\n\n    free(h.data);\n    job_free(j3a);\n    job_free(j3b);\n    job_free(j3c);\n}\n\nvoid\ncttest_heap_many_jobs()\n{\n    Heap h = {\n        .less = job_pri_less,\n        .setpos = job_setpos,\n    };\n    const int n = 20;\n    Job *j;\n\n    int i;\n    for (i = 0; i < n; i++) {\n        j = make_job(1 + rand() % 8192, 0, 1, 0, 0);\n        assertf(j, \"allocation\");\n        int r = heapinsert(&h, j);\n        assertf(r, \"heapinsert\");\n    }\n\n    uint last_pri = 0;\n    for (i = 0; i < n; i++) {\n        j = heapremove(&h, 0);\n        assertf(j->r.pri >= last_pri, \"should come out in order\");\n        last_pri = j->r.pri;\n        assert(j);\n        job_free(j);\n    }\n    free(h.data);\n}\n\nvoid\ncttest_heap_remove_k()\n{\n    Heap h = {\n        .less = job_pri_less,\n        .setpos = job_setpos,\n    };\n    const int n = 50;\n    const int mid = 25;\n\n    int c, i;\n    for (c = 0; c < 50; c++) {\n        for (i = 0; i < n; i++) {\n            Job *j = make_job(1 + rand() % 8192, 0, 1, 0, 0);\n            assertf(j, \"allocation\");\n            int r = heapinsert(&h, j);\n            assertf(r, \"heapinsert\");\n        }\n\n        /* remove one from the middle */\n        Job *j0 = heapremove(&h, mid);\n        assertf(j0, \"j0 should not be NULL\");\n        job_free(j0);\n\n        /* now make sure the rest are still a valid heap */\n        uint last_pri = 0;\n        for (i = 1; i < n; i++) {\n            Job *j = heapremove(&h, 0);\n            assertf(j->r.pri >= last_pri, \"should come out in order\");\n            last_pri = j->r.pri;\n            assertf(j, \"j should not be NULL\");\n            job_free(j);\n        }\n    }\n    free(h.data);\n}\n\nvoid\nctbench_heap_insert(int n)\n{\n    Job **j = calloc(n, sizeof *j);\n    int i;\n    for (i = 0; i < n; i++) {\n        j[i] = make_job(1, 0, 1, 0, 0);\n        assert(j[i]);\n        j[i]->r.pri = -j[i]->r.id;\n    }\n    Heap h = {\n        .less = job_pri_less,\n        .setpos = job_setpos,\n    };\n\n    ctresettimer();\n    for (i = 0; i < n; i++) {\n        heapinsert(&h, j[i]);\n    }\n    ctstoptimer();\n\n    for (i = 0; i < n; i++)\n        job_free(heapremove(&h, 0));\n    free(h.data);\n    free(j);\n}\n\nvoid\nctbench_heap_remove(int n)\n{\n    Heap h = {\n        .less = job_pri_less,\n        .setpos = job_setpos,\n    };\n    int i;\n    for (i = 0; i < n; i++) {\n        Job *j = make_job(1, 0, 1, 0, 0);\n        assertf(j, \"allocate job\");\n        heapinsert(&h, j);\n    }\n    Job **jj = calloc(n, sizeof(Job *)); // temp storage to deallocate jobs later\n\n    ctresettimer();\n    for (i = 0; i < n; i++) {\n        jj[i] = (Job *)heapremove(&h, 0);\n    }\n    ctstoptimer();\n\n    free(h.data);\n    for (i = 0; i < n; i++)\n        job_free(jj[i]);\n    free(jj);\n}\n"
        },
        {
          "name": "testjobs.c",
          "type": "blob",
          "size": 3.3740234375,
          "content": "#include \"ct/ct.h\"\n#include \"dat.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/time.h>\n\nstatic Tube *default_tube;\n\nvoid\ncttest_job_creation()\n{\n    Job *j;\n\n    TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n    j = make_job(1, 0, 1, 0, default_tube);\n    assertf(j->r.pri == 1, \"priority should match\");\n}\n\nvoid\ncttest_job_cmp_pris()\n{\n    Job *a, *b;\n\n    TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n    a = make_job(1, 0, 1, 0, default_tube);\n    b = make_job(1 << 27, 0, 1, 0, default_tube);\n\n    assertf(job_pri_less(a, b), \"should be less\");\n}\n\nvoid\ncttest_job_cmp_ids()\n{\n    Job *a, *b;\n\n    TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n    a = make_job(1, 0, 1, 0, default_tube);\n    b = make_job(1, 0, 1, 0, default_tube);\n\n    b->r.id <<= 49;\n    assertf(job_pri_less(a, b), \"should be less\");\n}\n\nvoid\ncttest_job_large_pris()\n{\n    Job *a, *b;\n\n    TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n    a = make_job(1, 0, 1, 0, default_tube);\n    b = make_job(-5, 0, 1, 0, default_tube);\n\n    assertf(job_pri_less(a, b), \"should be less\");\n\n    a = make_job(-5, 0, 1, 0, default_tube);\n    b = make_job(1, 0, 1, 0, default_tube);\n\n    assertf(!job_pri_less(a, b), \"should not be less\");\n}\n\nvoid\ncttest_job_hash_free()\n{\n    Job *j;\n    uint64 jid = 83;\n\n    TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n    j = make_job_with_id(0, 0, 1, 0, default_tube, jid);\n    job_free(j);\n\n    assertf(!job_find(jid), \"job should be missing\");\n}\n\nvoid\ncttest_job_hash_free_next()\n{\n    Job *a, *b;\n    uint64 aid = 97, bid = 12386;\n\n    TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n    b = make_job_with_id(0, 0, 1, 0, default_tube, bid);\n    a = make_job_with_id(0, 0, 1, 0, default_tube, aid);\n\n    assertf(a->ht_next == b, \"b should be chained to a\");\n\n    job_free(b);\n\n    assertf(a->ht_next == NULL, \"job should be missing\");\n}\n\nvoid\ncttest_job_all_jobs_used()\n{\n    Job *j, *x;\n\n    TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n    j = make_job(0, 0, 1, 0, default_tube);\n    assertf(get_all_jobs_used() == 1, \"should match\");\n\n    x = allocate_job(10);\n    assertf(get_all_jobs_used() == 1, \"should match\");\n\n    job_free(x);\n    assertf(get_all_jobs_used() == 1, \"should match\");\n\n    job_free(j);\n    assertf(get_all_jobs_used() == 0, \"should match\");\n}\n\nvoid\ncttest_job_100_000_jobs()\n{\n    int i;\n\n    TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n    for (i = 0; i < 100000; i++) {\n        make_job(0, 0, 1, 0, default_tube);\n    }\n    assertf(get_all_jobs_used() == 100000, \"should match\");\n\n    for (i = 1; i <= 100000; i++) {\n        job_free(job_find(i));\n    }\n    fprintf(stderr, \"get_all_jobs_used() => %zu\\n\", get_all_jobs_used());\n    assertf(get_all_jobs_used() == 0, \"should match\");\n}\n\nvoid\nctbench_job_make(int n)\n{\n    int i;\n    Job **j = calloc(n, sizeof *j);\n    TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n\n    ctresettimer();\n    for (i = 0; i < n; i++) {\n        j[i] = make_job(0, 0, 1, 0, default_tube);\n    }\n    ctstoptimer();\n\n    for (i = 0; i < n; i++) {\n        job_free(j[i]);\n    }\n    free(j);\n}\n\nvoid\nctbench_job_free(int n)\n{\n    int i;\n    Job **j = calloc(n, sizeof *j);\n    TUBE_ASSIGN(default_tube, make_tube(\"default\"));\n    for (i = 0; i < n; i++) {\n        j[i] = make_job(0, 0, 1, 0, default_tube);\n    }\n\n    ctresettimer();\n    for (i = 0; i < n; i++) {\n        job_free(j[i]);\n    }\n    ctstoptimer();\n\n    free(j);\n}\n"
        },
        {
          "name": "testms.c",
          "type": "blob",
          "size": 2.333984375,
          "content": "#include \"dat.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/time.h>\n#include \"ct/ct.h\"\n\n\nvoid\ncttest_ms_append()\n{\n    Ms *a = new(struct Ms);\n    ms_init(a, NULL, NULL);\n\n    int i = 10;\n\n    int ok = ms_append(a, &i);\n    assertf(a->len == 1, \"a should contain one item\");\n    assertf(ok, \"should be added\");\n\n    ok = ms_append(a, &i);\n    assertf(a->len == 2, \"a should contain two items\");\n    assertf(ok, \"should be added\");\n\n    ms_clear(a);\n    assertf(a->len == 0, \"a should be empty\");\n    free(a->items);\n    free(a);\n}\n\nvoid\ncttest_ms_remove()\n{\n\n    Ms *a = new(struct Ms);\n    ms_init(a, NULL, NULL);\n\n    int i = 1;\n    ms_append(a, &i);\n\n    int j = 2;\n    int ok = ms_remove(a, &j);\n    assertf(!ok, \"j should not be removed\");\n\n    ok = ms_remove(a, &i);\n    assertf(ok, \"i should be removed\");\n\n    ok = ms_remove(a, &i);\n    assertf(!ok, \"i was already removed\");\n\n    assertf(a->len == 0, \"a should be empty\");\n    free(a->items);\n    free(a);\n}\n\nvoid\ncttest_ms_contains()\n{\n\n    Ms *a = new(struct Ms);\n    ms_init(a, NULL, NULL);\n\n    int i = 1;\n    ms_append(a, &i);\n    int ok = ms_contains(a, &i);\n    assertf(ok, \"i should be in a\");\n\n    int j = 2;\n    ok = ms_contains(a, &j);\n    assertf(!ok, \"j should not be in a\");\n\n    ms_clear(a);\n    free(a->items);\n    free(a);\n}\n\nvoid\ncttest_ms_clear_empty()\n{\n\n    Ms *a = new(struct Ms);\n    ms_init(a, NULL, NULL);\n\n    ms_clear(a);\n    assertf(a->len == 0, \"a should be empty\");\n    free(a->items);\n    free(a);\n}\n\nvoid\ncttest_ms_take()\n{\n    Ms *a = new(struct Ms);\n    ms_init(a, NULL, NULL);\n\n    int i = 10;\n    int j = 20;\n\n    ms_append(a, &i);\n    ms_append(a, &j);\n\n    int *n;\n    n = (int *)ms_take(a);\n    assertf(n == &i, \"n should point to i\");\n\n    n = (int *)ms_take(a);\n    assertf(n == &j, \"n should point to j\");\n\n    n = (int *)ms_take(a);\n    assertf(n == NULL, \"n should be NULL; ms is empty\");\n\n    free(a->items);\n    free(a);\n}\n\nvoid\ncttest_ms_take_sequence()\n{\n    size_t i;\n    int s[] = {1, 2, 3, 4, 5, 6};\n    int e[] = {1, 2, 3, 6, 5, 4};\n\n    Ms *a = new(struct Ms);\n    ms_init(a, NULL, NULL);\n\n    size_t n = sizeof(s)/sizeof(s[0]);\n    for (i = 0; i < n; i++)\n        ms_append(a, &s[i]);\n\n    for (i = 0; i < n; i++) {\n        int *got = (int *)ms_take(a);\n        assert(*got == e[i]);\n    }\n\n    free(a->items);\n    free(a);\n}\n\n"
        },
        {
          "name": "testserv.c",
          "type": "blob",
          "size": 51.892578125,
          "content": "#include \"ct/ct.h\"\n#include \"dat.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/select.h>\n#include <sys/un.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <errno.h>\n\nstatic int srvpid, size;\n\n// Global timeout set for reading response in tests; 5sec.\nstatic int64 timeout = 5000000000LL;\n\n// Allocation pattern for wrapfalloc that replaces falloc in tests.\n// Zero value at N-th element means that N-th call to the falloc\n// should fail with ENOSPC result.\nstatic byte fallocpat[3];\n\n\nstatic int\nexist(char *path)\n{\n    struct stat s;\n\n    int r = stat(path, &s);\n    return r != -1;\n}\n\nstatic int\nwrapfalloc(int fd, int size)\n{\n    static size_t c = 0;\n\n    printf(\"\\nwrapfalloc: fd=%d size=%d\\n\", fd, size);\n    if (c >= sizeof(fallocpat) || !fallocpat[c++]) {\n        return ENOSPC;\n    }\n    return rawfalloc(fd, size);\n}\n\nstatic void\nmuststart(char *a0, char *a1, char *a2, char *a3, char *a4)\n{\n    srvpid = fork();\n    if (srvpid < 0) {\n        twarn(\"fork\");\n        exit(1);\n    }\n\n    if (srvpid > 0) {\n        printf(\"%s %s %s %s %s\\n\", a0, a1, a2, a3, a4);\n        printf(\"start server pid=%d\\n\", srvpid);\n        usleep(100000); // .1s; time for the child to bind to its port\n        return;\n    }\n\n    /* now in child */\n\n    execlp(a0, a0, a1, a2, a3, a4, NULL);\n}\n\nstatic int\nmustdiallocal(int port)\n{\n    struct sockaddr_in addr = {\n        .sin_family = AF_INET,\n        .sin_port = htons(port),\n    };\n\n    int r = inet_aton(\"127.0.0.1\", &addr.sin_addr);\n    if (!r) {\n        errno = EINVAL;\n        twarn(\"inet_aton\");\n        exit(1);\n    }\n\n    int fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (fd == -1) {\n        twarn(\"socket\");\n        exit(1);\n    }\n\n    // Fix of the benchmarking issue on Linux. See issue #430.\n    int flags = 1;\n    if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &flags, sizeof(int))) {\n        twarn(\"setting TCP_NODELAY on fd %d\", fd);\n        exit(1);\n    }\n\n    r = connect(fd, (struct sockaddr *)&addr, sizeof addr);\n    if (r == -1) {\n        twarn(\"connect\");\n        exit(1);\n    }\n\n    return fd;\n}\n\nstatic int\nmustdialunix(char *socket_file)\n{\n    struct sockaddr_un addr;\n    const size_t maxlen = sizeof(addr.sun_path);\n    addr.sun_family = AF_UNIX;\n    snprintf(addr.sun_path, maxlen, \"%s\", socket_file);\n\n    int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd == -1) {\n        twarn(\"socket\");\n        exit(1);\n    }\n\n    int r = connect(fd, (struct sockaddr *)&addr, sizeof addr);\n    if (r == -1) {\n        twarn(\"connect\");\n        exit(1);\n    }\n\n    return fd;\n}\n\nstatic void\nexit_process(int signum)\n{\n    UNUSED_PARAMETER(signum);\n    exit(0);\n}\n\nstatic void\nset_sig_handler()\n{\n    struct sigaction sa;\n\n    sa.sa_flags = 0;\n    int r = sigemptyset(&sa.sa_mask);\n    if (r == -1) {\n        twarn(\"sigemptyset()\");\n        exit(111);\n    }\n\n    // This is required to trigger gcov on exit. See issue #443.\n    sa.sa_handler = exit_process;\n    r = sigaction(SIGTERM, &sa, 0);\n    if (r == -1) {\n        twarn(\"sigaction(SIGTERM)\");\n        exit(111);\n    }\n}\n\n// Kill the srvpid (child process) with SIGTERM to give it a chance\n// to write gcov data to the filesystem before ct kills it with SIGKILL.\n// Do nothing in case of srvpid==0; child was already killed.\nstatic void\nkill_srvpid(void)\n{\n    if (!srvpid)\n        return;\n    kill(srvpid, SIGTERM);\n    waitpid(srvpid, 0, 0);\n    srvpid = 0;\n}\n\n#define SERVER() (progname=__func__, mustforksrv())\n#define SERVER_UNIX() (progname=__func__, mustforksrv_unix())\n\n// Forks the server storing the pid in srvpid.\n// The parent process returns port assigned.\n// The child process serves until the SIGTERM is received by it.\nstatic int\nmustforksrv(void)\n{\n    struct sockaddr_in addr;\n\n    srv.sock.fd = make_server_socket(\"127.0.0.1\", \"0\");\n    if (srv.sock.fd == -1) {\n        puts(\"mustforksrv failed\");\n        exit(1);\n    }\n\n    socklen_t len = sizeof(addr);\n    int r = getsockname(srv.sock.fd, (struct sockaddr *)&addr, &len);\n    if (r == -1 || len > sizeof(addr)) {\n        puts(\"mustforksrv failed\");\n        exit(1);\n    }\n\n    int port = ntohs(addr.sin_port);\n    srvpid = fork();\n    if (srvpid < 0) {\n        twarn(\"fork\");\n        exit(1);\n    }\n\n    if (srvpid > 0) {\n        // On exit the parent (test) sends SIGTERM to the child.\n        atexit(kill_srvpid);\n        printf(\"start server port=%d pid=%d\\n\", port, srvpid);\n        return port;\n    }\n\n    /* now in child */\n\n    set_sig_handler();\n    prot_init();\n\n    srv_acquire_wal(&srv);\n\n    srvserve(&srv); /* does not return */\n    exit(1); /* satisfy the compiler */\n}\n\nstatic char *\nmustforksrv_unix(void)\n{\n    static char path[90];\n    char name[95];\n    snprintf(path, sizeof(path), \"%s/socket\", ctdir());\n    snprintf(name, sizeof(name), \"unix:%s\", path);\n    srv.sock.fd = make_server_socket(name, NULL);\n    if (srv.sock.fd == -1) {\n        puts(\"mustforksrv_unix failed\");\n        exit(1);\n    }\n\n    srvpid = fork();\n    if (srvpid < 0) {\n        twarn(\"fork\");\n        exit(1);\n    }\n\n    if (srvpid > 0) {\n        // On exit the parent (test) sends SIGTERM to the child.\n        atexit(kill_srvpid);\n        printf(\"start server socket=%s\\n\", path);\n        assert(exist(path));\n        return path;\n    }\n\n    /* now in child */\n\n    set_sig_handler();\n    prot_init();\n\n    srv_acquire_wal(&srv);\n\n    srvserve(&srv); /* does not return */\n    exit(1); /* satisfy the compiler */\n}\n\nstatic char *\nreadline(int fd)\n{\n    char c = 0, p = 0;\n    static char buf[1024];\n    fd_set rfd;\n    struct timeval tv;\n\n    printf(\"<%d \", fd);\n    fflush(stdout);\n\n    size_t i = 0;\n    for (;;) {\n        FD_ZERO(&rfd);\n        FD_SET(fd, &rfd);\n        tv.tv_sec = timeout / 1000000000;\n        tv.tv_usec = (timeout/1000) % 1000000;\n        int r = select(fd+1, &rfd, NULL, NULL, &tv);\n        switch (r) {\n        case 1:\n            break;\n        case 0:\n            fputs(\"timeout\", stderr);\n            exit(8);\n        case -1:\n            perror(\"select\");\n            exit(1);\n        default:\n            fputs(\"unknown error\", stderr);\n            exit(3);\n        }\n\n        // TODO: try reading into a buffer to improve performance.\n        // See related issue #430.\n        r = read(fd, &c, 1);\n        if (r == -1) {\n            perror(\"write\");\n            exit(1);\n        }\n        if (i >= sizeof(buf)-1) {\n            fputs(\"response too big\", stderr);\n            exit(4);\n        }\n        putc(c, stdout);\n        fflush(stdout);\n        buf[i++] = c;\n        if (p == '\\r' && c == '\\n') {\n            break;\n        }\n        p = c;\n    }\n    buf[i] = '\\0';\n    return buf;\n}\n\nstatic void\nckresp(int fd, char *exp)\n{\n    char *line = readline(fd);\n    assertf(strcmp(exp, line) == 0, \"\\\"%s\\\" != \\\"%s\\\"\", exp, line);\n}\n\nstatic void\nckrespsub(int fd, char *sub)\n{\n    char *line = readline(fd);\n    assertf(strstr(line, sub), \"\\\"%s\\\" not in \\\"%s\\\"\", sub, line);\n}\n\nstatic void\nwritefull(int fd, char *s, int n)\n{\n    int c;\n    for (; n; n -= c) {\n        c = write(fd, s, n);\n        if (c == -1) {\n            perror(\"write\");\n            exit(1);\n        }\n        s += c;\n    }\n}\n\nstatic void\nmustsend(int fd, char *s)\n{\n    writefull(fd, s, strlen(s));\n    printf(\">%d %s\", fd, s);\n    fflush(stdout);\n}\n\nstatic int\nfilesize(char *path)\n{\n    struct stat s;\n\n    int r = stat(path, &s);\n    if (r == -1) {\n        twarn(\"stat\");\n        exit(1);\n    }\n    return s.st_size;\n}\n\nvoid\ncttest_unknown_command()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"nont10knowncommand\\r\\n\");\n    ckresp(fd, \"UNKNOWN_COMMAND\\r\\n\");\n}\n\nvoid\ncttest_too_long_commandline()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    int i;\n    for (i = 0; i < 10; i++)\n        mustsend(fd, \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"); // 50 bytes\n    mustsend(fd, \"\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    // Issue another command and check that reponse is not \"UNKNOWN_COMMAND\"\n    // as described in issue #337\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"A\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n}\n\nvoid\ncttest_put_in_drain()\n{\n    enter_drain_mode(SIGUSR1);\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"x\\r\\n\");\n    ckresp(fd, \"DRAINING\\r\\n\");\n}\n\nvoid\ncttest_peek_ok()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n\n    mustsend(fd, \"peek 1\\r\\n\");\n    ckresp(fd, \"FOUND 1 1\\r\\n\");\n    ckresp(fd, \"a\\r\\n\");\n}\n\nvoid\ncttest_peek_not_found()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n\n    mustsend(fd, \"peek 2\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n    mustsend(fd, \"peek 18446744073709551615\\r\\n\");  // UINT64_MAX\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n}\n\nvoid\ncttest_peek_ok_unix()\n{\n    char *name = SERVER_UNIX();\n    int fd = mustdialunix(name);\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n\n    mustsend(fd, \"peek 1\\r\\n\");\n    ckresp(fd, \"FOUND 1 1\\r\\n\");\n    ckresp(fd, \"a\\r\\n\");\n\n    unlink(name);\n}\n\nvoid\ncttest_unix_auto_removal()\n{\n    // Twice, to trigger autoremoval\n    SERVER_UNIX();\n    kill_srvpid();\n    SERVER_UNIX();\n}\n\nvoid\ncttest_peek_bad_format()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"peek 18446744073709551616\\r\\n\"); // UINT64_MAX+1\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"peek 184467440737095516160000000000000000000000000000\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"peek foo111\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"peek 111foo\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n}\n\nvoid\ncttest_peek_delayed()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"peek-delayed\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"A\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"put 0 99 1 1\\r\\n\");\n    mustsend(fd, \"B\\r\\n\");\n    ckresp(fd, \"INSERTED 2\\r\\n\");\n    mustsend(fd, \"put 0 1 1 1\\r\\n\");\n    mustsend(fd, \"C\\r\\n\");\n    ckresp(fd, \"INSERTED 3\\r\\n\");\n\n    mustsend(fd, \"peek-delayed\\r\\n\");\n    ckresp(fd, \"FOUND 3 1\\r\\n\");\n    ckresp(fd, \"C\\r\\n\");\n\n    mustsend(fd, \"delete 3\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n\n    mustsend(fd, \"peek-delayed\\r\\n\");\n    ckresp(fd, \"FOUND 2 1\\r\\n\");\n    ckresp(fd, \"B\\r\\n\");\n\n    mustsend(fd, \"delete 2\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n\n    mustsend(fd, \"peek-delayed\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n}\n\nvoid\ncttest_peek_buried_kick()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"A\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n\n    // cannot bury unreserved job\n    mustsend(fd, \"bury 1 0\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n    mustsend(fd, \"peek-buried\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n\n    mustsend(fd, \"reserve-with-timeout 0\\r\\n\");\n    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n    ckresp(fd, \"A\\r\\n\");\n\n    // now we can bury\n    mustsend(fd, \"bury 1 0\\r\\n\");\n    ckresp(fd, \"BURIED\\r\\n\");\n    mustsend(fd, \"peek-buried\\r\\n\");\n    ckresp(fd, \"FOUND 1 1\\r\\n\");\n    ckresp(fd, \"A\\r\\n\");\n\n    // kick and verify the job is ready\n    mustsend(fd, \"kick 1\\r\\n\");\n    ckresp(fd, \"KICKED 1\\r\\n\");\n    mustsend(fd, \"peek-buried\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n    mustsend(fd, \"peek-ready\\r\\n\");\n    ckresp(fd, \"FOUND 1 1\\r\\n\");\n    ckresp(fd, \"A\\r\\n\");\n\n    // nothing is left to kick\n    mustsend(fd, \"kick 1\\r\\n\");\n    ckresp(fd, \"KICKED 0\\r\\n\");\n}\n\nvoid\ncttest_touch_bad_format()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"touch a111\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"touch 111a\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"touch !@#!@#\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n}\n\nvoid\ncttest_touch_not_found()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"touch 1\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n    mustsend(fd, \"touch 100000000000000\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n}\n\nvoid\ncttest_bury_bad_format()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"bury 111abc 2\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"bury 111\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"bury 111 222abc\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n}\n\nvoid\ncttest_kickjob_bad_format()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"kick-job a111\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"kick-job 111a\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"kick-job !@#!@#\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n}\n\nvoid\ncttest_kickjob_buried()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"A\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n\n    mustsend(fd, \"reserve\\r\\n\");\n    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n    ckresp(fd, \"A\\r\\n\");\n    mustsend(fd, \"bury 1 0\\r\\n\");\n    ckresp(fd, \"BURIED\\r\\n\");\n\n    mustsend(fd, \"kick-job 100\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n    mustsend(fd, \"kick-job 1\\r\\n\");\n    ckresp(fd, \"KICKED\\r\\n\");\n    mustsend(fd, \"kick-job 1\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n}\n\nvoid\ncttest_kickjob_delayed()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    // jid=1 - no delay, jid=2 - delay\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"A\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"put 0 10 1 1\\r\\n\");\n    mustsend(fd, \"B\\r\\n\");\n    ckresp(fd, \"INSERTED 2\\r\\n\");\n\n    mustsend(fd, \"kick-job 1\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n    mustsend(fd, \"kick-job 2\\r\\n\");\n    ckresp(fd, \"KICKED\\r\\n\");\n    mustsend(fd, \"kick-job 2\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n}\n\nvoid\ncttest_pause()\n{\n    int64 s;\n\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 0 1\\r\\n\");\n    mustsend(fd, \"x\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    s = nanoseconds();\n    mustsend(fd, \"pause-tube default 1\\r\\n\");\n    ckresp(fd, \"PAUSED\\r\\n\");\n    mustsend(fd, \"reserve\\r\\n\");\n    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n    ckresp(fd, \"x\\r\\n\");\n    assert(nanoseconds() - s >= 1000000000); // 1s\n}\n\nvoid\ncttest_underscore()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"use x_y\\r\\n\");\n    ckresp(fd, \"USING x_y\\r\\n\");\n}\n\nvoid\ncttest_2cmdpacket()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"use a\\r\\nuse b\\r\\n\");\n    ckresp(fd, \"USING a\\r\\n\");\n    ckresp(fd, \"USING b\\r\\n\");\n}\n\nvoid\ncttest_too_big()\n{\n    job_data_size_limit = 10;\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 0 11\\r\\n\");\n    mustsend(fd, \"delete 9999\\r\\n\");\n    mustsend(fd, \"put 0 0 0 1\\r\\n\");\n    mustsend(fd, \"x\\r\\n\");\n    ckresp(fd, \"JOB_TOO_BIG\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n}\n\nvoid\ncttest_job_size_invalid()\n{\n    job_data_size_limit = JOB_DATA_SIZE_LIMIT_MAX;\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 0 4294967296\\r\\n\");\n    mustsend(fd, \"put 0 0 0 10b\\r\\n\");\n    mustsend(fd, \"put 0 0 0 --!@#$%^&&**()0b\\r\\n\");\n    mustsend(fd, \"put 0 0 0 1\\r\\n\");\n    mustsend(fd, \"x\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n}\n\nvoid\ncttest_job_size_max_plus_1()\n{\n    /* verify that server reject the job larger than maximum allowed. */\n    job_data_size_limit = JOB_DATA_SIZE_LIMIT_MAX;\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 0 1073741825\\r\\n\");\n\n    const int len = 1024*1024;\n    char body[len+1];\n    memset(body, 'a', len);\n    body[len] = 0;\n\n    int i;\n    for (i=0; i<JOB_DATA_SIZE_LIMIT_MAX; i+=len) {\n        mustsend(fd, body);\n    }\n    mustsend(fd, \"x\");\n    mustsend(fd, \"\\r\\n\");\n    ckresp(fd, \"JOB_TOO_BIG\\r\\n\");\n}\n\nvoid\ncttest_delete_ready()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 0 0\\r\\n\");\n    mustsend(fd, \"\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"delete 1\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n}\n\nvoid\ncttest_delete_reserved_by_other()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n\n    int o = mustdiallocal(port);\n    mustsend(o, \"reserve\\r\\n\");\n    ckresp(o, \"RESERVED 1 1\\r\\n\");\n    ckresp(o, \"a\\r\\n\");\n\n    mustsend(fd, \"delete 1\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n}\n\nvoid\ncttest_delete_bad_format()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"delete 18446744073709551616\\r\\n\"); // UINT64_MAX+1\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"delete 184467440737095516160000000000000000000000000000\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"delete foo111\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"delete 111foo\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n}\n\nvoid\ncttest_multi_tube()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"use abc\\r\\n\");\n    ckresp(fd, \"USING abc\\r\\n\");\n    mustsend(fd, \"put 999999 0 0 0\\r\\n\");\n    mustsend(fd, \"\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"use def\\r\\n\");\n    ckresp(fd, \"USING def\\r\\n\");\n    mustsend(fd, \"put 99 0 0 0\\r\\n\");\n    mustsend(fd, \"\\r\\n\");\n    ckresp(fd, \"INSERTED 2\\r\\n\");\n    mustsend(fd, \"watch abc\\r\\n\");\n    ckresp(fd, \"WATCHING 2\\r\\n\");\n    mustsend(fd, \"watch def\\r\\n\");\n    ckresp(fd, \"WATCHING 3\\r\\n\");\n    mustsend(fd, \"reserve\\r\\n\");\n    ckresp(fd, \"RESERVED 2 0\\r\\n\");\n}\n\nvoid\ncttest_negative_delay()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 512 -1 100 0\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n}\n\n/* TODO: add more edge cases tests for delay and ttr */\n\nvoid\ncttest_garbage_priority()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put -1kkdj9djjkd9 0 100 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n}\n\nvoid\ncttest_negative_priority()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put -1 0 100 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n}\n\nvoid\ncttest_max_priority()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 4294967295 0 100 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n}\n\nvoid\ncttest_too_big_priority()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 4294967296 0 100 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n}\n\nvoid\ncttest_omit_time_left()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 5 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ntime-left: 0\\n\");\n}\n\nvoid\ncttest_small_delay()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 1 1 0\\r\\n\");\n    mustsend(fd, \"\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n}\n\nvoid\ncttest_delayed_to_ready()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 1 1 0\\r\\n\");\n    mustsend(fd, \"\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-jobs-ready: 0\\n\");\n\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-jobs-delayed: 1\\n\");\n\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ntotal-jobs: 1\\n\");\n\n    usleep(1010000); // 1.01 sec\n\n    // check that after 1 sec the delayed job is ready again\n\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-jobs-ready: 1\\n\");\n\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-jobs-delayed: 0\\n\");\n\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ntotal-jobs: 1\\n\");\n}\n\nvoid\ncttest_statsjob_ck_format()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"stats-job 111ABC\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"stats-job 111 222\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"stats-job 111\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n}\n\nvoid\ncttest_stats_tube()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"use tubea\\r\\n\");\n    ckresp(fd, \"USING tubea\\r\\n\");\n    mustsend(fd, \"put 0 0 0 1\\r\\n\");\n    mustsend(fd, \"x\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"delete 1\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n\n    mustsend(fd, \"stats-tube tubea\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nname: \\\"tubea\\\"\\n\");\n    mustsend(fd, \"stats-tube tubea\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-jobs-urgent: 0\\n\");\n    mustsend(fd, \"stats-tube tubea\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-jobs-ready: 0\\n\");\n    mustsend(fd, \"stats-tube tubea\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-jobs-reserved: 0\\n\");\n    mustsend(fd, \"stats-tube tubea\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-jobs-delayed: 0\\n\");\n    mustsend(fd, \"stats-tube tubea\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-jobs-buried: 0\\n\");\n    mustsend(fd, \"stats-tube tubea\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ntotal-jobs: 1\\n\");\n    mustsend(fd, \"stats-tube tubea\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-using: 1\\n\");\n    mustsend(fd, \"stats-tube tubea\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-watching: 0\\n\");\n    mustsend(fd, \"stats-tube tubea\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-waiting: 0\\n\");\n    mustsend(fd, \"stats-tube tubea\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncmd-delete: 1\\n\");\n    mustsend(fd, \"stats-tube tubea\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncmd-pause-tube: 0\\n\");\n    mustsend(fd, \"stats-tube tubea\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\npause: 0\\n\");\n    mustsend(fd, \"stats-tube tubea\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\npause-time-left: 0\\n\");\n\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nname: \\\"default\\\"\\n\");\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-jobs-urgent: 0\\n\");\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-jobs-ready: 0\\n\");\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-jobs-reserved: 0\\n\");\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-jobs-delayed: 0\\n\");\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-jobs-buried: 0\\n\");\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ntotal-jobs: 0\\n\");\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-using: 0\\n\");\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-watching: 1\\n\");\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncurrent-waiting: 0\\n\");\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncmd-delete: 0\\n\");\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ncmd-pause-tube: 0\\n\");\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\npause: 0\\n\");\n    mustsend(fd, \"stats-tube default\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\npause-time-left: 0\\n\");\n}\n\nvoid\ncttest_ttrlarge()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 120 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"put 0 0 4294 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 2\\r\\n\");\n    mustsend(fd, \"put 0 0 4295 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 3\\r\\n\");\n    mustsend(fd, \"put 0 0 4296 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 4\\r\\n\");\n    mustsend(fd, \"put 0 0 4297 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 5\\r\\n\");\n    mustsend(fd, \"put 0 0 5000 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 6\\r\\n\");\n    mustsend(fd, \"put 0 0 21600 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 7\\r\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nttr: 120\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nttr: 4294\\n\");\n    mustsend(fd, \"stats-job 3\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nttr: 4295\\n\");\n    mustsend(fd, \"stats-job 4\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nttr: 4296\\n\");\n    mustsend(fd, \"stats-job 5\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nttr: 4297\\n\");\n    mustsend(fd, \"stats-job 6\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nttr: 5000\\n\");\n    mustsend(fd, \"stats-job 7\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nttr: 21600\\n\");\n}\n\nvoid\ncttest_ttr_small()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 0 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nttr: 1\\n\");\n}\n\nvoid\ncttest_zero_delay()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 1 0\\r\\n\");\n    mustsend(fd, \"\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n}\n\nvoid\ncttest_reserve_with_timeout_2conns()\n{\n    int fd0, fd1;\n\n    job_data_size_limit = 10;\n\n    int port = SERVER();\n    fd0 = mustdiallocal(port);\n    fd1 = mustdiallocal(port);\n    mustsend(fd0, \"watch foo\\r\\n\");\n    ckresp(fd0, \"WATCHING 2\\r\\n\");\n    mustsend(fd0, \"reserve-with-timeout 1\\r\\n\");\n    mustsend(fd1, \"watch foo\\r\\n\");\n    ckresp(fd1, \"WATCHING 2\\r\\n\");\n    timeout = 1100000000; // 1.1s\n    ckresp(fd0, \"TIMED_OUT\\r\\n\");\n}\n\nvoid\ncttest_reserve_ttr_deadline_soon()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n\n    mustsend(fd, \"reserve-with-timeout 1\\r\\n\");\n    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n    ckresp(fd, \"a\\r\\n\");\n\n    // After 0.2s the job should be still reserved.\n    usleep(200000);\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nstate: reserved\\n\");\n\n    mustsend(fd, \"reserve-with-timeout 1\\r\\n\");\n    ckresp(fd, \"DEADLINE_SOON\\r\\n\");\n\n    // Job should be reserved; last \"reserve\" took less than 1s.\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nstate: reserved\\n\");\n\n    // We don't want to process the job, so release it and check that it's ready.\n    mustsend(fd, \"release 1 0 0\\r\\n\");\n    ckresp(fd, \"RELEASED\\r\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nstate: ready\\n\");\n}\n\nvoid\ncttest_reserve_job_ttr_deadline_soon()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n\n    mustsend(fd, \"put 0 5 1 1\\r\\n\");\n    mustsend(fd, \"a\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nstate: delayed\\n\");\n\n    mustsend(fd, \"reserve-job 1\\r\\n\");\n    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n    ckresp(fd, \"a\\r\\n\");\n\n    // After 0.1s the job should be still reserved.\n    usleep(100000);\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nstate: reserved\\n\");\n\n    // Reservation made with reserve-job should behave the same way as other\n    // reserve commands, e.g. produce \"deadline soon\" message, and get released\n    // when ttr ends.\n    mustsend(fd, \"reserve-with-timeout 1\\r\\n\");\n    ckresp(fd, \"DEADLINE_SOON\\r\\n\");\n\n    // Job should be reserved; last \"reserve\" took less than 1s.\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nstate: reserved\\n\");\n\n    // We are not able to process the job in time. Check that it gets released.\n    // The job was in delayed state. It becomes ready when it gets auto-released.\n    usleep(1000000); // 1.0s\n    // put a dummy job\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"B\\r\\n\");\n    ckresp(fd, \"INSERTED 2\\r\\n\");\n    // check that ID=1 gets released\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nstate: ready\\n\");\n}\n\nvoid\ncttest_reserve_job_already_reserved()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"A\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n\n    mustsend(fd, \"reserve-job 1\\r\\n\");\n    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n    ckresp(fd, \"A\\r\\n\");\n\n    // Job should not be reserved twice.\n    mustsend(fd, \"reserve-job 1\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n}\n\nvoid\ncttest_reserve_job_ready()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"A\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"B\\r\\n\");\n    ckresp(fd, \"INSERTED 2\\r\\n\");\n\n    mustsend(fd, \"reserve-job 2\\r\\n\");\n    ckresp(fd, \"RESERVED 2 1\\r\\n\");\n    ckresp(fd, \"B\\r\\n\");\n\n    // Non-existing job.\n    mustsend(fd, \"reserve-job 3\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n\n    // id=1 was not reserved.\n    mustsend(fd, \"release 1 1 0\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n\n    mustsend(fd, \"release 2 1 0\\r\\n\");\n    ckresp(fd, \"RELEASED\\r\\n\");\n}\n\nvoid\ncttest_reserve_job_delayed()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n\n    mustsend(fd, \"put 0 100 1 1\\r\\n\");\n    mustsend(fd, \"A\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"put 0 100 1 1\\r\\n\");\n    mustsend(fd, \"B\\r\\n\");\n    ckresp(fd, \"INSERTED 2\\r\\n\");\n    mustsend(fd, \"put 0 100 1 1\\r\\n\");\n    mustsend(fd, \"C\\r\\n\");\n    ckresp(fd, \"INSERTED 3\\r\\n\");\n\n    mustsend(fd, \"reserve-job 2\\r\\n\");\n    ckresp(fd, \"RESERVED 2 1\\r\\n\");\n    ckresp(fd, \"B\\r\\n\");\n\n    mustsend(fd, \"release 2 1 0\\r\\n\");\n    ckresp(fd, \"RELEASED\\r\\n\");\n\n    // verify that job was released in ready state.\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nstate: ready\\n\");\n}\n\nvoid\ncttest_reserve_job_buried()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n\n    // put, reserve and bury\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"A\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"reserve-job 1\\r\\n\");\n    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n    ckresp(fd, \"A\\r\\n\");\n    mustsend(fd, \"bury 1 1\\r\\n\");\n    ckresp(fd, \"BURIED\\r\\n\");\n\n    // put, reserve and bury\n    mustsend(fd, \"put 0 0 1 1\\r\\n\");\n    mustsend(fd, \"B\\r\\n\");\n    ckresp(fd, \"INSERTED 2\\r\\n\");\n    mustsend(fd, \"reserve-job 2\\r\\n\");\n    ckresp(fd, \"RESERVED 2 1\\r\\n\");\n    ckresp(fd, \"B\\r\\n\");\n    mustsend(fd, \"bury 2 1\\r\\n\");\n    ckresp(fd, \"BURIED\\r\\n\");\n\n    // reserve by ids\n    mustsend(fd, \"reserve-job 2\\r\\n\");\n    ckresp(fd, \"RESERVED 2 1\\r\\n\");\n    ckresp(fd, \"B\\r\\n\");\n    mustsend(fd, \"reserve-job 1\\r\\n\");\n    ckresp(fd, \"RESERVED 1 1\\r\\n\");\n    ckresp(fd, \"A\\r\\n\");\n\n    // release back and check if jobs are ready.\n    mustsend(fd, \"release 1 1 0\\r\\n\");\n    ckresp(fd, \"RELEASED\\r\\n\");\n    mustsend(fd, \"release 2 1 0\\r\\n\");\n    ckresp(fd, \"RELEASED\\r\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nstate: ready\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nstate: ready\\n\");\n\n}\n\nvoid\ncttest_release_bad_format()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n\n    // bad id\n    mustsend(fd, \"release 18446744073709551616 1 1\\r\\n\"); // UINT64_MAX+1\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"release 184467440737095516160000000000000000000000000000 1 1\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"release foo111\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n    mustsend(fd, \"release 111foo\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n\n    // bad priority\n    mustsend(fd, \"release 18446744073709551615 abc 1\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n\n    // bad duration\n    mustsend(fd, \"release 18446744073709551615 1 abc\\r\\n\");\n    ckresp(fd, \"BAD_FORMAT\\r\\n\");\n}\n\nvoid\ncttest_release_not_found()\n{\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"release 1 1 1\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n}\n\nvoid\ncttest_close_releases_job()\n{\n    int port = SERVER();\n    int cons = mustdiallocal(port);\n    int prod = mustdiallocal(port);\n    mustsend(cons, \"reserve-with-timeout 1\\r\\n\");\n\n    mustsend(prod, \"put 0 0 100 1\\r\\n\");\n    mustsend(prod, \"a\\r\\n\");\n    ckresp(prod, \"INSERTED 1\\r\\n\");\n\n    ckresp(cons, \"RESERVED 1 1\\r\\n\");\n    ckresp(cons, \"a\\r\\n\");\n\n    mustsend(prod, \"stats-job 1\\r\\n\");\n    ckrespsub(prod, \"OK \");\n    ckrespsub(prod, \"\\nstate: reserved\\n\");\n\n    // Closed consumer connection should make the job ready sooner than ttr=100.\n    close(cons);\n\n    // Job should be released in less than 1s. It is not instantly;\n    // we do not make guarantees about how soon jobs should be released.\n    mustsend(prod, \"reserve-with-timeout 1\\r\\n\");\n    ckresp(prod, \"RESERVED 1 1\\r\\n\");\n    ckresp(prod, \"a\\r\\n\");\n}\n\nvoid\ncttest_quit_releases_job()\n{\n    // This test is similar to the close_releases_job test, except that\n    // connection is not closed, but command quit is sent.\n    int port = SERVER();\n    int cons = mustdiallocal(port);\n    int prod = mustdiallocal(port);\n    mustsend(cons, \"reserve-with-timeout 1\\r\\n\");\n\n    mustsend(prod, \"put 0 0 100 1\\r\\n\");\n    mustsend(prod, \"a\\r\\n\");\n    ckresp(prod, \"INSERTED 1\\r\\n\");\n\n    ckresp(cons, \"RESERVED 1 1\\r\\n\");\n    ckresp(cons, \"a\\r\\n\");\n\n    mustsend(prod, \"stats-job 1\\r\\n\");\n    ckrespsub(prod, \"OK \");\n    ckrespsub(prod, \"\\nstate: reserved\\n\");\n\n    // Quitting consumer should make the job ready sooner than ttr=100.\n    mustsend(cons, \"quit\\r\\n\");\n\n    // Job should be released in less than 1s. It is not instantly;\n    // we do not make guarantees about how soon jobs should be released.\n    mustsend(prod, \"reserve-with-timeout 1\\r\\n\");\n    ckresp(prod, \"RESERVED 1 1\\r\\n\");\n    ckresp(prod, \"a\\r\\n\");\n}\n\nvoid\ncttest_unpause_tube()\n{\n    int fd0, fd1;\n\n    int port = SERVER();\n    fd0 = mustdiallocal(port);\n    fd1 = mustdiallocal(port);\n\n    mustsend(fd0, \"put 0 0 0 0\\r\\n\");\n    mustsend(fd0, \"\\r\\n\");\n    ckresp(fd0, \"INSERTED 1\\r\\n\");\n\n    mustsend(fd0, \"pause-tube default 86400\\r\\n\");\n    ckresp(fd0, \"PAUSED\\r\\n\");\n\n    mustsend(fd1, \"reserve\\r\\n\");\n\n    mustsend(fd0, \"pause-tube default 0\\r\\n\");\n    ckresp(fd0, \"PAUSED\\r\\n\");\n\n    // ckresp will time out if this takes too long, so the\n    // test will not pass.\n    ckresp(fd1, \"RESERVED 1 0\\r\\n\");\n    ckresp(fd1, \"\\r\\n\");\n}\n\nvoid\ncttest_list_tube()\n{\n    int port = SERVER();\n    int fd0 = mustdiallocal(port);\n\n    mustsend(fd0, \"watch w\\r\\n\");\n    ckresp(fd0, \"WATCHING 2\\r\\n\");\n\n    mustsend(fd0, \"use u\\r\\n\");\n    ckresp(fd0, \"USING u\\r\\n\");\n\n    mustsend(fd0, \"list-tubes\\r\\n\");\n    ckrespsub(fd0, \"OK \");\n    ckresp(fd0,\n           \"---\\n\"\n           \"- default\\n\"\n           \"- w\\n\"\n           \"- u\\n\\r\\n\");\n\n    mustsend(fd0, \"list-tube-used\\r\\n\");\n    ckresp(fd0, \"USING u\\r\\n\");\n\n    mustsend(fd0, \"list-tubes-watched\\r\\n\");\n    ckrespsub(fd0, \"OK \");\n    ckresp(fd0,\n           \"---\\n\"\n           \"- default\\n\"\n           \"- w\\n\\r\\n\");\n\n    mustsend(fd0, \"ignore default\\r\\n\");\n    ckresp(fd0, \"WATCHING 1\\r\\n\");\n\n    mustsend(fd0, \"list-tubes-watched\\r\\n\");\n    ckrespsub(fd0, \"OK \");\n    ckresp(fd0,\n           \"---\\n\"\n           \"- w\\n\\r\\n\");\n\n    mustsend(fd0, \"ignore w\\r\\n\");\n    ckresp(fd0, \"NOT_IGNORED\\r\\n\");\n}\n\n#define STRING_LEN_200  \\\n    \"0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\" \\\n    \"0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\"\n\nvoid\ncttest_use_tube_long()\n{\n    int port = SERVER();\n    int fd0 = mustdiallocal(port);\n    // 200 chars is okay\n    mustsend(fd0, \"use \" STRING_LEN_200 \"\\r\\n\");\n    ckresp(fd0, \"USING \" STRING_LEN_200 \"\\r\\n\");\n    // 201 chars is too much\n    mustsend(fd0, \"use \" STRING_LEN_200 \"Z\\r\\n\");\n    ckresp(fd0, \"BAD_FORMAT\\r\\n\");\n}\n\nvoid\ncttest_longest_command()\n{\n    int port = SERVER();\n    int fd0 = mustdiallocal(port);\n    mustsend(fd0, \"use \" STRING_LEN_200 \"\\r\\n\");\n    ckresp(fd0, \"USING \" STRING_LEN_200 \"\\r\\n\");\n    mustsend(fd0, \"pause-tube \" STRING_LEN_200 \" 4294967295\\r\\n\");\n    ckresp(fd0, \"PAUSED\\r\\n\");\n}\n\nvoid\ncttest_binlog_empty_exit()\n{\n    srv.wal.dir = ctdir();\n    srv.wal.use = 1;\n    job_data_size_limit = 10;\n\n    int port = SERVER();\n    kill_srvpid();\n\n    port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 0 0\\r\\n\");\n    mustsend(fd, \"\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n}\n\nvoid\ncttest_binlog_bury()\n{\n    srv.wal.dir = ctdir();\n    srv.wal.use = 1;\n    job_data_size_limit = 10;\n\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 100 0\\r\\n\");\n    mustsend(fd, \"\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"reserve\\r\\n\");\n    ckresp(fd, \"RESERVED 1 0\\r\\n\");\n    ckresp(fd, \"\\r\\n\");\n    mustsend(fd, \"bury 1 0\\r\\n\");\n    ckresp(fd, \"BURIED\\r\\n\");\n}\n\nvoid\ncttest_binlog_basic()\n{\n    srv.wal.dir = ctdir();\n    srv.wal.use = 1;\n    job_data_size_limit = 10;\n\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 100 0\\r\\n\");\n    mustsend(fd, \"\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n\n    kill_srvpid();\n\n    port = SERVER();\n    fd = mustdiallocal(port);\n    mustsend(fd, \"delete 1\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n}\n\nvoid\ncttest_binlog_size_limit()\n{\n    int i = 0;\n    int gotsize;\n\n    size = 4096;\n    srv.wal.dir = ctdir();\n    srv.wal.use = 1;\n    srv.wal.filesize = size;\n    srv.wal.syncrate = 0;\n    srv.wal.wantsync = 1;\n\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    char *b2 = fmtalloc(\"%s/binlog.2\", ctdir());\n    while (!exist(b2)) {\n        char *exp = fmtalloc(\"INSERTED %d\\r\\n\", ++i);\n        mustsend(fd, \"put 0 0 100 50\\r\\n\");\n        mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n        ckresp(fd, exp);\n        free(exp);\n    }\n\n    char *b1 = fmtalloc(\"%s/binlog.1\", ctdir());\n    gotsize = filesize(b1);\n    assertf(gotsize == size, \"binlog.1 %d != %d\", gotsize, size);\n    gotsize = filesize(b2);\n    assertf(gotsize == size, \"binlog.2 %d != %d\", gotsize, size);\n    free(b1);\n    free(b2);\n}\n\nvoid\ncttest_binlog_allocation()\n{\n    int i = 0;\n\n    size = 601;\n    srv.wal.dir = ctdir();\n    srv.wal.use = 1;\n    srv.wal.filesize = size;\n    srv.wal.syncrate = 0;\n    srv.wal.wantsync = 1;\n\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    for (i = 1; i <= 96; i++) {\n        char *exp = fmtalloc(\"INSERTED %d\\r\\n\", i);\n        mustsend(fd, \"put 0 0 120 22\\r\\n\");\n        mustsend(fd, \"job payload xxxxxxxxxx\\r\\n\");\n        ckresp(fd, exp);\n        free(exp);\n    }\n    for (i = 1; i <= 96; i++) {\n        char *exp = fmtalloc(\"delete %d\\r\\n\", i);\n        mustsend(fd, exp);\n        ckresp(fd, \"DELETED\\r\\n\");\n        free(exp);\n    }\n}\n\nvoid\ncttest_binlog_read()\n{\n    srv.wal.dir = ctdir();\n    srv.wal.use = 1;\n    srv.wal.syncrate = 0;\n    srv.wal.wantsync = 1;\n\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"use test\\r\\n\");\n    ckresp(fd, \"USING test\\r\\n\");\n    mustsend(fd, \"put 0 0 120 4\\r\\n\");\n    mustsend(fd, \"test\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"put 0 0 120 4\\r\\n\");\n    mustsend(fd, \"tes1\\r\\n\");\n    ckresp(fd, \"INSERTED 2\\r\\n\");\n    mustsend(fd, \"watch test\\r\\n\");\n    ckresp(fd, \"WATCHING 2\\r\\n\");\n    mustsend(fd, \"reserve\\r\\n\");\n    ckresp(fd, \"RESERVED 1 4\\r\\n\");\n    ckresp(fd, \"test\\r\\n\");\n    mustsend(fd, \"release 1 1 1\\r\\n\");\n    ckresp(fd, \"RELEASED\\r\\n\");\n    mustsend(fd, \"reserve\\r\\n\");\n    ckresp(fd, \"RESERVED 2 4\\r\\n\");\n    ckresp(fd, \"tes1\\r\\n\");\n    mustsend(fd, \"delete 2\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n\n    kill_srvpid();\n\n    port = SERVER();\n    fd = mustdiallocal(port);\n    mustsend(fd, \"watch test\\r\\n\");\n    ckresp(fd, \"WATCHING 2\\r\\n\");\n    mustsend(fd, \"reserve\\r\\n\");\n    ckresp(fd, \"RESERVED 1 4\\r\\n\");\n    ckresp(fd, \"test\\r\\n\");\n    mustsend(fd, \"delete 1\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n    mustsend(fd, \"delete 2\\r\\n\");\n    ckresp(fd, \"NOT_FOUND\\r\\n\");\n}\n\nvoid\ncttest_binlog_disk_full()\n{\n    size = 1000;\n    falloc = &wrapfalloc;\n    fallocpat[0] = 1;\n    fallocpat[2] = 1;\n\n    srv.wal.dir = ctdir();\n    srv.wal.use = 1;\n    srv.wal.filesize = size;\n    srv.wal.syncrate = 0;\n    srv.wal.wantsync = 1;\n\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 2\\r\\n\");\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 3\\r\\n\");\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 4\\r\\n\");\n\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"OUT_OF_MEMORY\\r\\n\");\n\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 6\\r\\n\");\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 7\\r\\n\");\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 8\\r\\n\");\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 9\\r\\n\");\n\n    mustsend(fd, \"delete 1\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n    mustsend(fd, \"delete 2\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n    mustsend(fd, \"delete 3\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n    mustsend(fd, \"delete 4\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n    mustsend(fd, \"delete 6\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n    mustsend(fd, \"delete 7\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n    mustsend(fd, \"delete 8\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n    mustsend(fd, \"delete 9\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n}\n\nvoid\ncttest_binlog_disk_full_delete()\n{\n    size = 1000;\n    falloc = &wrapfalloc;\n    fallocpat[0] = 1;\n    fallocpat[1] = 1;\n\n    srv.wal.dir = ctdir();\n    srv.wal.use = 1;\n    srv.wal.filesize = size;\n    srv.wal.syncrate = 0;\n    srv.wal.wantsync = 1;\n\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 2\\r\\n\");\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 3\\r\\n\");\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 4\\r\\n\");\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 5\\r\\n\");\n\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 6\\r\\n\");\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 7\\r\\n\");\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"INSERTED 8\\r\\n\");\n\n    mustsend(fd, \"put 0 0 100 50\\r\\n\");\n    mustsend(fd, \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n\");\n    ckresp(fd, \"OUT_OF_MEMORY\\r\\n\");\n\n    char *b1 = fmtalloc(\"%s/binlog.1\", ctdir());\n    assert(exist(b1));\n    free(b1);\n\n    mustsend(fd, \"delete 1\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n    mustsend(fd, \"delete 2\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n    mustsend(fd, \"delete 3\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n    mustsend(fd, \"delete 4\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n    mustsend(fd, \"delete 5\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n    mustsend(fd, \"delete 6\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n    mustsend(fd, \"delete 7\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n    mustsend(fd, \"delete 8\\r\\n\");\n    ckresp(fd, \"DELETED\\r\\n\");\n}\n\nvoid\ncttest_binlog_v5()\n{\n    char portstr[10];\n\n    if (system(\"which beanstalkd-1.4.6\") != 0) {\n        puts(\"beanstalkd 1.4.6 not found, skipping\");\n        exit(0);\n    }\n\n    progname = __func__;\n    int port = (rand() & 0xfbff) + 1024;\n    sprintf(portstr, \"%d\", port);\n    muststart(\"beanstalkd-1.4.6\", \"-b\", ctdir(), \"-p\", portstr);\n    int fd = mustdiallocal(port);\n    mustsend(fd, \"use test\\r\\n\");\n    ckresp(fd, \"USING test\\r\\n\");\n    mustsend(fd, \"put 1 2 3 4\\r\\n\");\n    mustsend(fd, \"test\\r\\n\");\n    ckresp(fd, \"INSERTED 1\\r\\n\");\n    mustsend(fd, \"put 4 3 2 1\\r\\n\");\n    mustsend(fd, \"x\\r\\n\");\n    ckresp(fd, \"INSERTED 2\\r\\n\");\n\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nid: 1\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ntube: test\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nstate: delayed\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\npri: 1\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ndelay: 2\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nttr: 3\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nreserves: 0\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ntimeouts: 0\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nreleases: 0\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nburies: 0\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nkicks: 0\\n\");\n\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nid: 2\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ntube: test\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nstate: delayed\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\npri: 4\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ndelay: 3\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nttr: 2\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nreserves: 0\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ntimeouts: 0\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nreleases: 0\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nburies: 0\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nkicks: 0\\n\");\n\n    kill(srvpid, SIGTERM);\n    waitpid(srvpid, NULL, 0);\n\n    srv.wal.dir = ctdir();\n    srv.wal.use = 1;\n    srv.wal.syncrate = 0;\n    srv.wal.wantsync = 1;\n\n    port = SERVER();\n    fd = mustdiallocal(port);\n\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nid: 1\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ntube: test\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nstate: delayed\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\npri: 1\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ndelay: 2\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nttr: 3\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nreserves: 0\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ntimeouts: 0\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nreleases: 0\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nburies: 0\\n\");\n    mustsend(fd, \"stats-job 1\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nkicks: 0\\n\");\n\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nid: 2\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ntube: test\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nstate: delayed\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\npri: 4\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ndelay: 3\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nttr: 2\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nreserves: 0\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\ntimeouts: 0\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nreleases: 0\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nburies: 0\\n\");\n    mustsend(fd, \"stats-job 2\\r\\n\");\n    ckrespsub(fd, \"OK \");\n    ckrespsub(fd, \"\\nkicks: 0\\n\");\n}\n\nstatic void\nbench_put_delete_size(int n, int size, int walsize, int sync, int64 syncrate_ms)\n{\n    if (walsize > 0) {\n        srv.wal.dir = ctdir();\n        srv.wal.use = 1;\n        srv.wal.filesize = walsize;\n        srv.wal.syncrate = syncrate_ms * 1000000;\n        srv.wal.wantsync = sync;\n    }\n\n    job_data_size_limit = JOB_DATA_SIZE_LIMIT_MAX;\n    int port = SERVER();\n    int fd = mustdiallocal(port);\n    char buf[50], put[50];\n    char body[size+1];\n    memset(body, 'a', size);\n    body[size] = 0;\n    ctsetbytes(size);\n    sprintf(put, \"put 0 0 0 %d\\r\\n\", size);\n    ctresettimer();\n    int i;\n    for (i = 0; i < n; i++) {\n        mustsend(fd, put);\n        mustsend(fd, body);\n        mustsend(fd, \"\\r\\n\");\n        ckrespsub(fd, \"INSERTED \");\n        sprintf(buf, \"delete %d\\r\\n\", i + 1);\n        mustsend(fd, buf);\n        ckresp(fd, \"DELETED\\r\\n\");\n    }\n    ctstoptimer();\n}\n\nvoid\nctbench_put_delete_0008(int n)\n{\n    bench_put_delete_size(n, 8, 0, 0, 0);\n}\n\nvoid\nctbench_put_delete_1024(int n)\n{\n    bench_put_delete_size(n, 1024, 0, 0, 0);\n}\n\nvoid\nctbench_put_delete_8192(int n)\n{\n    bench_put_delete_size(n, 8192, 0, 0, 0);\n}\n\nvoid\nctbench_put_delete_81920(int n)\n{\n    bench_put_delete_size(n, 81920, 0, 0, 0);\n}\n\nvoid\nctbench_put_delete_wal_1024_fsync_000ms(int n)\n{\n    bench_put_delete_size(n, 1024, 512000, 1, 0);\n}\n\nvoid\nctbench_put_delete_wal_1024_fsync_050ms(int n)\n{\n    bench_put_delete_size(n, 1024, 512000, 1, 50);\n}\n\nvoid\nctbench_put_delete_wal_1024_fsync_200ms(int n)\n{\n    bench_put_delete_size(n, 1024, 512000, 1, 200);\n}\n\nvoid\nctbench_put_delete_wal_1024_no_fsync(int n)\n{\n    bench_put_delete_size(n, 1024, 512000, 0, 0);\n}\n\nvoid\nctbench_put_delete_wal_8192_fsync_000ms(int n)\n{\n    bench_put_delete_size(n, 8192, 512000, 1, 0);\n}\n\nvoid\nctbench_put_delete_wal_8192_fsync_050ms(int n)\n{\n    bench_put_delete_size(n, 8192, 512000, 1, 50);\n}\n\nvoid\nctbench_put_delete_wal_8192_fsync_200ms(int n)\n{\n    bench_put_delete_size(n, 8192, 512000, 1, 200);\n}\n\nvoid\nctbench_put_delete_wal_8192_no_fsync(int n)\n{\n    bench_put_delete_size(n, 8192, 512000, 0, 0);\n}\n"
        },
        {
          "name": "testutil.c",
          "type": "blob",
          "size": 3.26953125,
          "content": "#include \"ct/ct.h\"\n#include \"dat.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <sys/time.h>\n#include <unistd.h>\n\nvoid\ncttest_allocf()\n{\n    char *got;\n\n    got = fmtalloc(\"hello, %s %d\", \"world\", 5);\n    assertf(strcmp(\"hello, world 5\", got) == 0, \"got \\\"%s\\\"\", got);\n    free(got);\n}\n\nvoid\ncttest_opt_none()\n{\n    char *args[] = {\n        NULL,\n    };\n\n    optparse(&srv, args);\n    assert(strcmp(srv.port, Portdef) == 0);\n    assert(srv.addr == NULL);\n    assert(job_data_size_limit == JOB_DATA_SIZE_LIMIT_DEFAULT);\n    assert(srv.wal.filesize == Filesizedef);\n    assert(srv.wal.wantsync == 1);\n    assert(srv.wal.syncrate == DEFAULT_FSYNC_MS*1000000);\n    assert(srv.user == NULL);\n    assert(srv.wal.dir == NULL);\n    assert(srv.wal.use == 0);\n    assert(verbose == 0);\n}\n\nstatic void\nsuccess(void)\n{\n    _exit(0);\n}\n\nvoid\ncttest_optminus()\n{\n    char *args[] = {\n        \"-\",\n        NULL,\n    };\n\n    atexit(success);\n    optparse(&srv, args);\n    assertf(0, \"optparse failed to call exit\");\n}\n\nvoid\ncttest_optp()\n{\n    char *args[] = {\n        \"-p1234\",\n        NULL,\n    };\n\n    optparse(&srv, args);\n    assert(strcmp(srv.port, \"1234\") == 0);\n}\n\nvoid\ncttest_optl()\n{\n    char *args[] = {\n        \"-llocalhost\",\n        NULL,\n    };\n\n    optparse(&srv, args);\n    assert(strcmp(srv.addr, \"localhost\") == 0);\n}\n\nvoid\ncttest_optlseparate()\n{\n    char *args[] = {\n        \"-l\",\n        \"localhost\",\n        NULL,\n    };\n\n    optparse(&srv, args);\n    assert(strcmp(srv.addr, \"localhost\") == 0);\n}\n\nvoid\ncttest_optz()\n{\n    char *args[] = {\n        \"-z1234\",\n        NULL,\n    };\n\n    optparse(&srv, args);\n    assert(job_data_size_limit == 1234);\n}\n\nvoid\ncttest_optz_more_than_max()\n{\n    char *args[] = {\n        \"-z1073741825\",\n        NULL,\n    };\n\n    optparse(&srv, args);\n    assert(job_data_size_limit == 1073741824);\n}\n\nvoid\ncttest_opts()\n{\n    char *args[] = {\n        \"-s1234\",\n        NULL,\n    };\n\n    optparse(&srv, args);\n    assert(srv.wal.filesize == 1234);\n}\n\nvoid\ncttest_optf()\n{\n    char *args[] = {\n        \"-f1234\",\n        NULL,\n    };\n\n    optparse(&srv, args);\n    assert(srv.wal.syncrate == 1234000000);\n    assert(srv.wal.wantsync == 1);\n}\n\nvoid\ncttest_optF()\n{\n    char *args[] = {\n        \"-f1234\",\n        \"-F\",\n        NULL,\n    };\n\n    optparse(&srv, args);\n    assert(srv.wal.wantsync == 0);\n}\n\nvoid\ncttest_optu()\n{\n    char *args[] = {\n        \"-ukr\",\n        NULL,\n    };\n\n    optparse(&srv, args);\n    assert(strcmp(srv.user, \"kr\") == 0);\n}\n\nvoid\ncttest_optb()\n{\n    char *args[] = {\n        \"-bfoo\",\n        NULL,\n    };\n\n    optparse(&srv, args);\n    assert(strcmp(srv.wal.dir, \"foo\") == 0);\n    assert(srv.wal.use == 1);\n}\n\nvoid\ncttest_optV()\n{\n    char *args[] = {\n        \"-V\",\n        NULL,\n    };\n\n    optparse(&srv, args);\n    assert(verbose == 1);\n}\n\nvoid\ncttest_optV_V()\n{\n    char *args[] = {\n        \"-V\",\n        \"-V\",\n        NULL,\n    };\n\n    optparse(&srv, args);\n    assert(verbose == 2);\n}\n\nvoid\ncttest_optVVV()\n{\n    char *args[] = {\n        \"-VVV\",\n        NULL,\n    };\n\n    optparse(&srv, args);\n    assert(verbose == 3);\n}\n\nvoid\ncttest_optVFVu()\n{\n    char *args[] = {\n        \"-VFVukr\",\n        NULL,\n    };\n\n    optparse(&srv, args);\n    assert(verbose == 2);\n    assert(srv.wal.wantsync == 0);\n    assert(strcmp(srv.user, \"kr\") == 0);\n}\n"
        },
        {
          "name": "time.c",
          "type": "blob",
          "size": 0.3017578125,
          "content": "#include \"dat.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <sys/time.h>\n\nint64\nnanoseconds(void)\n{\n    int r;\n    struct timeval tv;\n\n    r = gettimeofday(&tv, 0);\n    if (r != 0) return warnx(\"gettimeofday\"), -1; // can't happen\n\n    return ((int64)tv.tv_sec)*1000000000 + ((int64)tv.tv_usec)*1000;\n}\n"
        },
        {
          "name": "tube.c",
          "type": "blob",
          "size": 1.828125,
          "content": "#include \"dat.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct Ms tubes;\n\nTube *\nmake_tube(const char *name)\n{\n    Tube *t = new(Tube);\n    if (!t)\n        return NULL;\n\n    strncpy(t->name, name, MAX_TUBE_NAME_LEN);\n    if (t->name[MAX_TUBE_NAME_LEN - 1] != '\\0') {\n        t->name[MAX_TUBE_NAME_LEN - 1] = '\\0';\n        twarnx(\"truncating tube name\");\n    }\n\n    t->ready.less = job_pri_less;\n    t->delay.less = job_delay_less;\n    t->ready.setpos = job_setpos;\n    t->delay.setpos = job_setpos;\n\n    Job j = {.tube = NULL};\n    t->buried = j;\n    t->buried.prev = t->buried.next = &t->buried;\n    ms_init(&t->waiting_conns, NULL, NULL);\n\n    return t;\n}\n\nstatic void\ntube_free(Tube *t)\n{\n    ms_remove(&tubes, t);\n    free(t->ready.data);\n    free(t->delay.data);\n    ms_clear(&t->waiting_conns);\n    free(t);\n}\n\nvoid\ntube_dref(Tube *t)\n{\n    if (!t) return;\n    if (t->refs < 1) {\n        twarnx(\"refs is zero for tube: %s\", t->name);\n        return;\n    }\n\n    --t->refs;\n    if (t->refs < 1)\n        tube_free(t);\n}\n\nvoid\ntube_iref(Tube *t)\n{\n    if (!t) return;\n    ++t->refs;\n}\n\nstatic Tube *\nmake_and_insert_tube(const char *name)\n{\n    int r;\n    Tube *t = NULL;\n\n    t = make_tube(name);\n    if (!t)\n        return NULL;\n\n    /* We want this global tube list to behave like \"weak\" refs, so don't\n     * increment the ref count. */\n    r = ms_append(&tubes, t);\n    if (!r)\n        return tube_dref(t), (Tube *) 0;\n\n    return t;\n}\n\nTube *\ntube_find(Ms *tubeset, const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < tubeset->len; i++) {\n        Tube *t = tubeset->items[i];\n        if (strncmp(t->name, name, MAX_TUBE_NAME_LEN) == 0)\n            return t;\n    }\n    return NULL;\n}\n\nTube *\ntube_find_or_make(const char *name)\n{\n    Tube *t = tube_find(&tubes, name);\n    if (t)\n        return t;\n    return make_and_insert_tube(name);\n}\n\n"
        },
        {
          "name": "util.c",
          "type": "blob",
          "size": 5.5947265625,
          "content": "#include \"dat.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n\n#ifdef HAVE_LIBSYSTEMD\n#include <systemd/sd-daemon.h>\n#endif\n\nconst char *progname;\n\nstatic void\nvwarnx(const char *err, const char *fmt, va_list args)\n__attribute__((format(printf, 2, 0)));\n\nstatic void\nvwarnx(const char *err, const char *fmt, va_list args)\n{\n    fprintf(stderr, \"%s: \", progname);\n    if (fmt) {\n        vfprintf(stderr, fmt, args);\n        if (err) fprintf(stderr, \": %s\", err);\n    }\n    fputc('\\n', stderr);\n}\n\nvoid\nwarn(const char *fmt, ...)\n{\n    char *err = strerror(errno); /* must be done first thing */\n    va_list args;\n\n    va_start(args, fmt);\n    vwarnx(err, fmt, args);\n    va_end(args);\n}\n\nvoid\nwarnx(const char *fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n    vwarnx(NULL, fmt, args);\n    va_end(args);\n}\n\n\nchar*\nfmtalloc(char *fmt, ...)\n{\n    int n;\n    char *buf;\n    va_list ap;\n\n    // find out how much space is needed\n    va_start(ap, fmt);\n    n = vsnprintf(0, 0, fmt, ap) + 1; // include space for trailing NUL\n    va_end(ap);\n\n    buf = malloc(n);\n    if (buf) {\n        va_start(ap, fmt);\n        vsnprintf(buf, n, fmt, ap);\n        va_end(ap);\n    }\n    return buf;\n}\n\n\n// Zalloc allocates n bytes of zeroed memory and\n// returns a pointer to it.\n// If insufficient memory is available, zalloc returns 0.\nvoid*\nzalloc(int n)\n{\n    void *p;\n\n    p = malloc(n);\n    if (p) {\n        memset(p, 0, n);\n    }\n    return p;\n}\n\n\nstatic void\nwarn_systemd_ignored_option(char *opt, char *arg)\n{\n#ifdef HAVE_LIBSYSTEMD\n    if (sd_listen_fds(0) > 0) {\n        warnx(\"inherited listen fd; ignoring option: %s %s\", opt, arg);\n    }\n#endif\n}\n\n\nstatic void usage(int code) __attribute__ ((noreturn));\nstatic void\nusage(int code)\n{\n    fprintf(stderr, \"Use: %s [OPTIONS]\\n\"\n            \"\\n\"\n            \"Options:\\n\"\n            \" -b DIR   write-ahead log directory\\n\"\n            \" -f MS    fsync at most once every MS milliseconds (default is %dms);\\n\"\n            \"          use -f0 for \\\"always fsync\\\"\\n\"\n            \" -F       never fsync\\n\"\n            \" -l ADDR  listen on address (default is 0.0.0.0)\\n\"\n            \" -p PORT  listen on port (default is \" Portdef \")\\n\"\n            \" -u USER  become user and group\\n\"\n            \" -z BYTES set the maximum job size in bytes (default is %d);\\n\"\n            \"          max allowed is %d bytes\\n\"\n            \" -s BYTES set the size of each write-ahead log file (default is %d);\\n\"\n            \"          will be rounded up to a multiple of 4096 bytes\\n\"\n            \" -v       show version information\\n\"\n            \" -V       increase verbosity\\n\"\n            \" -h       show this help\\n\",\n            progname,\n            DEFAULT_FSYNC_MS,\n            JOB_DATA_SIZE_LIMIT_DEFAULT,\n            JOB_DATA_SIZE_LIMIT_MAX,\n            Filesizedef);\n    exit(code);\n}\n\n\nstatic char *flagusage(char *flag) __attribute__ ((noreturn));\nstatic char *\nflagusage(char *flag)\n{\n    warnx(\"flag requires an argument: %s\", flag);\n    usage(5);\n}\n\n\nstatic size_t\nparse_size_t(char *str)\n{\n    char r, x;\n    size_t size;\n\n    r = sscanf(str, \"%zu%c\", &size, &x);\n    if (1 != r) {\n        warnx(\"invalid size: %s\", str);\n        usage(5);\n    }\n    return size;\n}\n\n\nvoid\noptparse(Server *s, char **argv)\n{\n    int64 ms;\n    char *arg, *tmp;\n#   define EARGF(x) (*arg ? (tmp=arg,arg=\"\",tmp) : *argv ? *argv++ : (x))\n\n    while ((arg = *argv++) && *arg++ == '-' && *arg) {\n        char c;\n        while ((c = *arg++)) {\n            switch (c) {\n                case 'p':\n                    s->port = EARGF(flagusage(\"-p\"));\n                    warn_systemd_ignored_option(\"-p\", s->port);\n                    break;\n                case 'l':\n                    s->addr = EARGF(flagusage(\"-l\"));\n                    warn_systemd_ignored_option(\"-l\", s->addr);\n                    break;\n                case 'z':\n                    job_data_size_limit = parse_size_t(EARGF(flagusage(\"-z\")));\n                    if (job_data_size_limit > JOB_DATA_SIZE_LIMIT_MAX) {\n                        warnx(\"maximum job size was set to %d\", JOB_DATA_SIZE_LIMIT_MAX);\n                        job_data_size_limit = JOB_DATA_SIZE_LIMIT_MAX;\n                    }\n                    break;\n                case 's':\n                    s->wal.filesize = parse_size_t(EARGF(flagusage(\"-s\")));\n                    break;\n                case 'c':\n                    warnx(\"-c flag was removed. binlog is always compacted.\");\n                    break;\n                case 'n':\n                    warnx(\"-n flag was removed. binlog is always compacted.\");\n                    break;\n                case 'f':\n                    ms = (int64)parse_size_t(EARGF(flagusage(\"-f\")));\n                    s->wal.syncrate = ms * 1000000;\n                    s->wal.wantsync = 1;\n                    break;\n                case 'F':\n                    s->wal.wantsync = 0;\n                    break;\n                case 'u':\n                    s->user = EARGF(flagusage(\"-u\"));\n                    break;\n                case 'b':\n                    s->wal.dir = EARGF(flagusage(\"-b\"));\n                    s->wal.use = 1;\n                    break;\n                case 'h':\n                    usage(0);\n                case 'v':\n                    printf(\"beanstalkd %s\\n\", version);\n                    exit(0);\n                case 'V':\n                    verbose++;\n                    break;\n                default:\n                    warnx(\"unknown flag: %s\", arg-2);\n                    usage(5);\n            }\n        }\n    }\n    if (arg) {\n        warnx(\"unknown argument: %s\", arg-1);\n        usage(5);\n    }\n}\n"
        },
        {
          "name": "verc.sh",
          "type": "blob",
          "size": 0.0673828125,
          "content": "#!/bin/sh\n\nprintf 'const char version[] = \"'\n./vers.sh\nprintf '\";\\n'\n"
        },
        {
          "name": "vers.sh",
          "type": "blob",
          "size": 0.203125,
          "content": "#!/bin/sh\n\nif git describe >/dev/null 2>&1\nthen\n    git describe --tags --match=dev* | sed s/^dev// | tr - + | tr -d '\\n'\n    if ! git diff --quiet HEAD\n    then printf +mod\n    fi\nelse\n    printf unknown\nfi\n"
        },
        {
          "name": "walg.c",
          "type": "blob",
          "size": 9.041015625,
          "content": "#include \"dat.h\"\n#include <stdint.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <limits.h>\n\nstatic int reserve(Wal *w, int n);\n\n\n// Reads w->dir for files matching binlog.NNN,\n// sets w->next to the next unused number, and\n// returns the minimum number.\n// If no files are found, sets w->next to 1 and\n// returns a large number.\nstatic int\nwalscandir(Wal *w)\n{\n    static char base[] = \"binlog.\";\n    static const int len = sizeof(base) - 1;\n    DIR *d;\n    struct dirent *e;\n    int min = 1<<30;\n    int max = 0;\n    int n;\n    char *p;\n\n    d = opendir(w->dir);\n    if (!d) return min;\n\n    while ((e = readdir(d))) {\n        if (strncmp(e->d_name, base, len) == 0) {\n            n = strtol(e->d_name+len, &p, 10);\n            if (p && *p == '\\0') {\n                if (n > max) max = n;\n                if (n < min) min = n;\n            }\n        }\n    }\n\n    closedir(d);\n    w->next = max + 1;\n    return min;\n}\n\n\nvoid\nwalgc(Wal *w)\n{\n    File *f;\n\n    while (w->head && !w->head->refs) {\n        f = w->head;\n        w->head = f->next;\n        if (w->tail == f) {\n            w->tail = f->next; // also, f->next == NULL\n        }\n\n        w->nfile--;\n        unlink(f->path);\n        free(f->path);\n        free(f);\n    }\n}\n\n\n// returns 1 on success, 0 on error.\nstatic int\nusenext(Wal *w)\n{\n    File *f;\n\n    f = w->cur;\n    if (!f->next) {\n        twarnx(\"there is no next wal file\");\n        return 0;\n    }\n\n    w->cur = f->next;\n    filewclose(f);\n    return 1;\n}\n\n\nstatic int\nratio(Wal *w)\n{\n    int64 n, d;\n\n    d = w->alive + w->resv;\n    n = (int64)w->nfile * (int64)w->filesize - d;\n    if (!d) return 0;\n    return n / d;\n}\n\n\n// Returns the number of bytes reserved or 0 on error.\nstatic int\nwalresvmigrate(Wal *w, Job *j)\n{\n    int z = 0;\n\n    // reserve only space for the migrated full job record\n    // space for the delete is already reserved\n    z += sizeof(int);\n    z += strlen(j->tube->name);\n    z += sizeof(Jobrec);\n    z += j->r.body_size;\n\n    return reserve(w, z);\n}\n\n\nstatic void\nmoveone(Wal *w)\n{\n    Job *j;\n\n    if (w->head == w->cur || w->head->next == w->cur) {\n        // no point in moving a job\n        return;\n    }\n\n    j = w->head->jlist.fnext;\n    if (!j || j == &w->head->jlist) {\n        // head holds no jlist; can't happen\n        twarnx(\"head holds no jlist\");\n        return;\n    }\n\n    if (!walresvmigrate(w, j)) {\n        // it will not fit, so we'll try again later\n        return;\n    }\n\n    filermjob(w->head, j);\n    w->nmig++;\n    walwrite(w, j);\n}\n\n\nstatic void\nwalcompact(Wal *w)\n{\n    int r;\n\n    for (r=ratio(w); r>=2; r--) {\n        moveone(w);\n    }\n}\n\n\nstatic void\nwalsync(Wal *w)\n{\n    int64 now;\n\n    now = nanoseconds();\n    if (w->wantsync && now >= w->lastsync+w->syncrate) {\n        w->lastsync = now;\n        if (fsync(w->cur->fd) == -1) {\n            twarn(\"fsync\");\n        }\n    }\n}\n\n\n// Walwrite writes j to the log w (if w is enabled).\n// On failure, walwrite disables w and returns 0; on success, it returns 1.\n// Unlke walresv*, walwrite should never fail because of a full disk.\n// If w is disabled, then walwrite takes no action and returns 1.\nint\nwalwrite(Wal *w, Job *j)\n{\n    int r = 0;\n\n    if (!w->use) return 1;\n    if (w->cur->resv > 0 || usenext(w)) {\n        if (j->file) {\n            r = filewrjobshort(w->cur, j);\n        } else {\n            r = filewrjobfull(w->cur, j);\n        }\n    }\n    if (!r) {\n        filewclose(w->cur);\n        w->use = 0;\n    }\n    w->nrec++;\n    return r;\n}\n\n\nvoid\nwalmaint(Wal *w)\n{\n    if (w->use) {\n        walcompact(w);\n        walsync(w);\n    }\n}\n\n\nstatic int\nmakenextfile(Wal *w)\n{\n    File *f;\n\n    f = new(File);\n    if (!f) {\n        twarnx(\"OOM\");\n        return 0;\n    }\n\n    if (!fileinit(f, w, w->next)) {\n        free(f);\n        twarnx(\"OOM\");\n        return 0;\n    }\n\n    filewopen(f);\n    if (!f->iswopen) {\n        free(f->path);\n        free(f);\n        return 0;\n    }\n\n    w->next++;\n    fileadd(f, w);\n    return 1;\n}\n\n\nstatic void\nmoveresv(File *to, File *from, int n)\n{\n    from->resv -= n;\n    from->free += n;\n    to->resv += n;\n    to->free -= n;\n}\n\n\nstatic int\nneedfree(Wal *w, int n)\n{\n    if (w->tail->free >= n) return n;\n    if (makenextfile(w)) return n;\n    return 0;\n}\n\n\n// Ensures:\n//  1. b->resv is congruent to n (mod z).\n//  2. x->resv is congruent to 0 (mod z) for each future file x.\n// Assumes (and preserves) that b->resv >= n.\n// Reserved space is conserved (neither created nor destroyed);\n// we just move it around to preserve the invariant.\n// We might have to allocate a new file.\n// Returns 1 on success, otherwise 0. If there was a failure,\n// w->tail is not updated.\nstatic int\nbalancerest(Wal *w, File *b, int n)\n{\n    int rest, c, r;\n    static const int z = sizeof(int) + sizeof(Jobrec);\n\n    if (!b) return 1;\n\n    rest = b->resv - n;\n    r = rest % z;\n    if (r == 0) return balancerest(w, b->next, 0);\n\n    c = z - r;\n    if (w->tail->resv >= c && b->free >= c) {\n        moveresv(b, w->tail, c);\n        return balancerest(w, b->next, 0);\n    }\n\n    if (needfree(w, r) != r) {\n        twarnx(\"needfree\");\n        return 0;\n    }\n    moveresv(w->tail, b, r);\n    return balancerest(w, b->next, 0);\n}\n\n\n// Ensures:\n//  1. w->cur->resv >= n.\n//  2. w->cur->resv is congruent to n (mod z).\n//  3. x->resv is congruent to 0 (mod z) for each future file x.\n// (where z is the size of a delete record in the wal).\n// Reserved space is conserved (neither created nor destroyed);\n// we just move it around to preserve the invariant.\n// We might have to allocate a new file.\n// Returns 1 on success, otherwise 0. If there was a failure,\n// w->tail is not updated.\nstatic int\nbalance(Wal *w, int n)\n{\n    // Invariant 1\n    // (this loop will run at most once)\n    while (w->cur->resv < n) {\n        int m = w->cur->resv;\n\n        int r = needfree(w, m);\n        if (r != m) {\n            twarnx(\"needfree\");\n            return 0;\n        }\n\n        moveresv(w->tail, w->cur, m);\n        usenext(w);\n    }\n\n    // Invariants 2 and 3\n    return balancerest(w, w->cur, n);\n}\n\n\n// Returns the number of bytes successfully reserved: either 0 or n.\nstatic int\nreserve(Wal *w, int n)\n{\n    int r;\n\n    // return value must be nonzero but is otherwise ignored\n    if (!w->use) return 1;\n\n    if (w->cur->free >= n) {\n        w->cur->free -= n;\n        w->cur->resv += n;\n        w->resv += n;\n        return n;\n    }\n\n    r = needfree(w, n);\n    if (r != n) {\n        twarnx(\"needfree\");\n        return 0;\n    }\n\n    w->tail->free -= n;\n    w->tail->resv += n;\n    w->resv += n;\n    if (!balance(w, n)) {\n        // error; undo the reservation\n        w->resv -= n;\n        w->tail->resv -= n;\n        w->tail->free += n;\n        return 0;\n    }\n\n    return n;\n}\n\n\n// Returns the number of bytes reserved or 0 on error.\nint\nwalresvput(Wal *w, Job *j)\n{\n    int z = 0;\n\n    // reserve space for the initial job record\n    z += sizeof(int);\n    z += strlen(j->tube->name);\n    z += sizeof(Jobrec);\n    z += j->r.body_size;\n\n    // plus space for a delete to come later\n    z += sizeof(int);\n    z += sizeof(Jobrec);\n\n    return reserve(w, z);\n}\n\n\n// Returns the number of bytes reserved or 0 on error.\nint\nwalresvupdate(Wal *w)\n{\n    int z = 0;\n    z +=sizeof(int);\n    z +=sizeof(Jobrec);\n    return reserve(w, z);\n}\n\n\n// Returns the number of locks acquired: either 0 or 1.\nint\nwaldirlock(Wal *w)\n{\n    int r;\n    int fd;\n    struct flock lk;\n    char *path;\n    size_t path_length;\n\n    path_length = strlen(w->dir) + strlen(\"/lock\") + 1;\n    if ((path = malloc(path_length)) == NULL) {\n        twarn(\"malloc\");\n        return 0;\n    }\n    snprintf(path, path_length, \"%s/lock\", w->dir);\n\n    fd = open(path, O_WRONLY|O_CREAT, 0600);\n    free(path);\n    if (fd == -1) {\n        twarn(\"open\");\n        return 0;\n    }\n\n    lk.l_type = F_WRLCK;\n    lk.l_whence = SEEK_SET;\n    lk.l_start = 0;\n    lk.l_len = 0;\n    r = fcntl(fd, F_SETLK, &lk);\n    if (r) {\n        twarn(\"fcntl\");\n        return 0;\n    }\n\n    // intentionally leak fd, since we never want to close it\n    // and we'll never need it again\n    return 1;\n}\n\n\nvoid\nwalread(Wal *w, Job *list, int min)\n{\n    int i;\n    int err = 0;\n\n    for (i = min; i < w->next; i++) {\n        File *f = new(File);\n        if (!f) {\n            twarnx(\"OOM\");\n            exit(1);\n        }\n\n        if (!fileinit(f, w, i)) {\n            free(f);\n            twarnx(\"OOM\");\n            exit(1);\n        }\n\n        int fd = open(f->path, O_RDONLY);\n        if (fd < 0) {\n            twarn(\"open %s\", f->path);\n            free(f->path);\n            free(f);\n            continue;\n        }\n\n        f->fd = fd;\n        fileadd(f, w);\n        err |= fileread(f, list);\n        if (close(fd) == -1)\n            twarn(\"close\");\n    }\n\n    if (err) {\n        warnx(\"Errors reading one or more WAL files.\");\n        warnx(\"Continuing. You may be missing data.\");\n    }\n}\n\n\nvoid\nwalinit(Wal *w, Job *list)\n{\n    int min;\n\n    min = walscandir(w);\n    walread(w, list, min);\n\n    // first writable file\n    if (!makenextfile(w)) {\n        twarnx(\"makenextfile\");\n        exit(1);\n    }\n\n    w->cur = w->tail;\n}\n"
        }
      ]
    }
  ]
}