{
  "metadata": {
    "timestamp": 1736710342022,
    "page": 149,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hishamhm/htop",
      "stars": 5853,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.34375,
          "content": "# EditorConfig configuration for htop\n# http://EditorConfig.org\n\n# top-most EditorConfig file\nroot = true\n\n# Unix-style newlines with a newline ending every file, utf-8 charset\n[*]\nend_of_line = lf\ninsert_final_newline = true\ncharset = utf-8\n\n# match C source and header files, set indent to three spaces\n[*.{c,h}]\nindent_style = space\nindent_size = 3\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.375,
          "content": "# the binary:\nhtop\n\n# all object files\n*.o\n\n# skip all backups\n*.bak\n*~\n.*.sw?\n\n# skip coverage files\n*.gcda\n*/*.gcda\n*.gcno\n*/*.gcno\n*.h.gch\n*/.dirstamp\n\n.deps/\nMakefile\nMakefile.in\nINSTALL\naclocal.m4\nautom4te.cache/\ncompile\nconfig.guess\nconfig.h\nconfig.h.in\nconfig.log\nconfig.status\nconfig.cache\nconfig.sub\nconfigure\ndepcomp\nhtop.1\ninstall-sh\nlibtool\nltmain.sh\nm4/\nmissing\nstamp-h1\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.1064453125,
          "content": "language: c\n\ncompiler:\n  - clang\n  - gcc\n\nos:\n  - linux\n  - osx\n\nscript: ./autogen.sh && ./configure && make\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.0185546875,
          "content": "Hisham H. Muhammad\n"
        },
        {
          "name": "Action.c",
          "type": "blob",
          "size": 19.908203125,
          "content": "/*\nhtop - Action.c\n(C) 2015 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\"\n\n#include \"Action.h\"\n#include \"Affinity.h\"\n#include \"AffinityPanel.h\"\n#include \"CategoriesPanel.h\"\n#include \"CRT.h\"\n#include \"EnvScreen.h\"\n#include \"MainPanel.h\"\n#include \"OpenFilesScreen.h\"\n#include \"Process.h\"\n#include \"ScreenManager.h\"\n#include \"SignalsPanel.h\"\n#include \"StringUtils.h\"\n#include \"TraceScreen.h\"\n#include \"Platform.h\"\n\n#include <ctype.h>\n#include <math.h>\n#include <pwd.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <sys/param.h>\n#include <sys/time.h>\n\n/*{\n\n#include \"IncSet.h\"\n#include \"Settings.h\"\n#include \"Header.h\"\n#include \"UsersTable.h\"\n#include \"ProcessList.h\"\n#include \"Panel.h\"\n\ntypedef enum {\n   HTOP_OK = 0x00,\n   HTOP_REFRESH = 0x01,\n   HTOP_RECALCULATE = 0x03, // implies HTOP_REFRESH\n   HTOP_SAVE_SETTINGS = 0x04,\n   HTOP_KEEP_FOLLOWING = 0x08,\n   HTOP_QUIT = 0x10,\n   HTOP_REDRAW_BAR = 0x20,\n   HTOP_UPDATE_PANELHDR = 0x41, // implies HTOP_REFRESH\n} Htop_Reaction;\n\ntypedef Htop_Reaction (*Htop_Action)();\n\ntypedef struct State_ {\n   Settings* settings;\n   UsersTable* ut;\n   ProcessList* pl;\n   Panel* panel;\n   Header* header;\n} State;\n\n}*/\n\nObject* Action_pickFromVector(State* st, Panel* list, int x) {\n   Panel* panel = st->panel;\n   Header* header = st->header;\n   Settings* settings = st->settings;\n   \n   int y = panel->y;\n   ScreenManager* scr = ScreenManager_new(0, header->height, 0, -1, HORIZONTAL, header, settings, false);\n   scr->allowFocusChange = false;\n   ScreenManager_add(scr, list, x - 1);\n   ScreenManager_add(scr, panel, -1);\n   Panel* panelFocus;\n   int ch;\n   bool unfollow = false;\n   int pid = MainPanel_selectedPid((MainPanel*)panel);\n   if (header->pl->following == -1) {\n      header->pl->following = pid;\n      unfollow = true;\n   }\n   ScreenManager_run(scr, &panelFocus, &ch);\n   if (unfollow) {\n      header->pl->following = -1;\n   }\n   ScreenManager_delete(scr);\n   Panel_move(panel, 0, y);\n   Panel_resize(panel, COLS, LINES-y-1);\n   if (panelFocus == list && ch == 13) {\n      Process* selected = (Process*)Panel_getSelected(panel);\n      if (selected && selected->pid == pid)\n         return Panel_getSelected(list);\n      else\n         beep();\n   }\n   return NULL;\n}\n\n// ----------------------------------------\n\nstatic void Action_runSetup(Settings* settings, const Header* header, ProcessList* pl) {\n   ScreenManager* scr = ScreenManager_new(0, header->height, 0, -1, HORIZONTAL, header, settings, true);\n   CategoriesPanel* panelCategories = CategoriesPanel_new(scr, settings, (Header*) header, pl);\n   ScreenManager_add(scr, (Panel*) panelCategories, 16);\n   CategoriesPanel_makeMetersPage(panelCategories);\n   Panel* panelFocus;\n   int ch;\n   ScreenManager_run(scr, &panelFocus, &ch);\n   ScreenManager_delete(scr);\n   if (settings->changed) {\n      Header_writeBackToSettings(header);\n   }\n}\n\nstatic bool changePriority(MainPanel* panel, int delta) {\n   bool anyTagged;\n   bool ok = MainPanel_foreachProcess(panel, (MainPanel_ForeachProcessFn) Process_changePriorityBy, (Arg){ .i = delta }, &anyTagged);\n   if (!ok)\n      beep();\n   return anyTagged;\n}\n\nstatic void addUserToVector(int key, void* userCast, void* panelCast) {\n   char* user = (char*) userCast;\n   Panel* panel = (Panel*) panelCast;\n   Panel_add(panel, (Object*) ListItem_new(user, key));\n}\n\nbool Action_setUserOnly(const char* userName, uid_t* userId) {\n   struct passwd* user = getpwnam(userName);\n   if (user) {\n      *userId = user->pw_uid;\n      return true;\n   }\n   *userId = -1;\n   return false;\n}\n\nstatic void tagAllChildren(Panel* panel, Process* parent) {\n   parent->tag = true;\n   pid_t ppid = parent->pid;\n   for (int i = 0; i < Panel_size(panel); i++) {\n      Process* p = (Process*) Panel_get(panel, i);\n      if (!p->tag && Process_isChildOf(p, ppid)) {\n         tagAllChildren(panel, p);\n      }\n   }\n}\n\nstatic bool expandCollapse(Panel* panel) {\n   Process* p = (Process*) Panel_getSelected(panel);\n   if (!p) return false;\n   p->showChildren = !p->showChildren;\n   return true;\n}\n\nstatic bool collapseIntoParent(Panel* panel) {\n   Process* p = (Process*) Panel_getSelected(panel);\n   if (!p) return false;\n   pid_t ppid = Process_getParentPid(p);\n   for (int i = 0; i < Panel_size(panel); i++) {\n      Process* q = (Process*) Panel_get(panel, i);\n      if (q->pid == ppid) {\n         q->showChildren = false;\n         Panel_setSelected(panel, i);\n         return true;\n      }\n   }\n   return false;\n}\n\nHtop_Reaction Action_setSortKey(Settings* settings, ProcessField sortKey) {\n   settings->sortKey = sortKey;\n   settings->direction = 1;\n   settings->treeView = false;\n   return HTOP_REFRESH | HTOP_SAVE_SETTINGS | HTOP_UPDATE_PANELHDR | HTOP_KEEP_FOLLOWING;\n}\n\nstatic Htop_Reaction sortBy(State* st) {\n   Htop_Reaction reaction = HTOP_OK;\n   Panel* sortPanel = Panel_new(0, 0, 0, 0, true, Class(ListItem), FunctionBar_newEnterEsc(\"Sort   \", \"Cancel \"));\n   Panel_setHeader(sortPanel, \"Sort by\");\n   ProcessField* fields = st->settings->fields;\n   for (int i = 0; fields[i]; i++) {\n      char* name = String_trim(Process_fields[fields[i]].name);\n      Panel_add(sortPanel, (Object*) ListItem_new(name, fields[i]));\n      if (fields[i] == st->settings->sortKey)\n         Panel_setSelected(sortPanel, i);\n      free(name);\n   }\n   ListItem* field = (ListItem*) Action_pickFromVector(st, sortPanel, 15);\n   if (field) {\n      reaction |= Action_setSortKey(st->settings, field->key);\n   }\n   Object_delete(sortPanel);\n   return reaction | HTOP_REFRESH | HTOP_REDRAW_BAR | HTOP_UPDATE_PANELHDR;\n}\n\n// ----------------------------------------\n\nstatic Htop_Reaction actionResize(State* st) {\n   clear();\n   Panel_resize(st->panel, COLS, LINES-(st->panel->y)-1);\n   return HTOP_REDRAW_BAR;\n}\n\nstatic Htop_Reaction actionSortByMemory(State* st) {\n   return Action_setSortKey(st->settings, PERCENT_MEM);\n}\n\nstatic Htop_Reaction actionSortByCPU(State* st) {\n   return Action_setSortKey(st->settings, PERCENT_CPU);\n}\n\nstatic Htop_Reaction actionSortByTime(State* st) {\n   return Action_setSortKey(st->settings, TIME);\n}\n\nstatic Htop_Reaction actionToggleKernelThreads(State* st) {\n   st->settings->hideKernelThreads = !st->settings->hideKernelThreads;\n   return HTOP_RECALCULATE | HTOP_SAVE_SETTINGS;\n}\n\nstatic Htop_Reaction actionToggleUserlandThreads(State* st) {\n   st->settings->hideUserlandThreads = !st->settings->hideUserlandThreads;\n   st->settings->hideThreads = st->settings->hideUserlandThreads;\n   return HTOP_RECALCULATE | HTOP_SAVE_SETTINGS;\n}\n\nstatic Htop_Reaction actionToggleProgramPath(State* st) {\n   st->settings->showProgramPath = !st->settings->showProgramPath;\n   return HTOP_REFRESH | HTOP_SAVE_SETTINGS;\n}\n\nstatic Htop_Reaction actionToggleTreeView(State* st) {\n   st->settings->treeView = !st->settings->treeView;\n   if (st->settings->treeView) st->settings->direction = 1;\n   ProcessList_expandTree(st->pl);\n   return HTOP_REFRESH | HTOP_SAVE_SETTINGS | HTOP_KEEP_FOLLOWING | HTOP_REDRAW_BAR | HTOP_UPDATE_PANELHDR;\n}\n\nstatic Htop_Reaction actionIncFilter(State* st) {\n   IncSet* inc = ((MainPanel*)st->panel)->inc;\n   IncSet_activate(inc, INC_FILTER, st->panel);\n   st->pl->incFilter = IncSet_filter(inc);\n   return HTOP_REFRESH | HTOP_KEEP_FOLLOWING;\n}\n\nstatic Htop_Reaction actionIncSearch(State* st) {\n   IncSet_activate(((MainPanel*)st->panel)->inc, INC_SEARCH, st->panel);\n   return HTOP_REFRESH | HTOP_KEEP_FOLLOWING;\n}\n\nstatic Htop_Reaction actionHigherPriority(State* st) {\n   bool changed = changePriority((MainPanel*)st->panel, -1);\n   return changed ? HTOP_REFRESH : HTOP_OK;\n}\n\nstatic Htop_Reaction actionLowerPriority(State* st) {\n   bool changed = changePriority((MainPanel*)st->panel, 1);\n   return changed ? HTOP_REFRESH : HTOP_OK;\n}\n\nstatic Htop_Reaction actionInvertSortOrder(State* st) {\n   Settings_invertSortOrder(st->settings);\n   return HTOP_REFRESH | HTOP_SAVE_SETTINGS;\n}\n\nstatic Htop_Reaction actionSetSortColumn(State* st) {\n   return sortBy(st);\n}\n\nstatic Htop_Reaction actionExpandOrCollapse(State* st) {\n   bool changed = expandCollapse(st->panel);\n   return changed ? HTOP_RECALCULATE : HTOP_OK;\n}\n\nstatic Htop_Reaction actionCollapseIntoParent(State* st) {\n   if (!st->settings->treeView) {\n      return HTOP_OK;\n   }\n   bool changed = collapseIntoParent(st->panel);\n   return changed ? HTOP_RECALCULATE : HTOP_OK;\n}\n\nstatic Htop_Reaction actionExpandCollapseOrSortColumn(State* st) {\n   return st->settings->treeView ? actionExpandOrCollapse(st) : actionSetSortColumn(st);\n}\n\nstatic Htop_Reaction actionQuit() {\n   return HTOP_QUIT;\n}\n\nstatic Htop_Reaction actionSetAffinity(State* st) {\n   if (st->pl->cpuCount == 1)\n      return HTOP_OK;\n#if (HAVE_LIBHWLOC || HAVE_LINUX_AFFINITY)\n   Panel* panel = st->panel;\n   \n   Process* p = (Process*) Panel_getSelected(panel);\n   if (!p) return HTOP_OK;\n   Affinity* affinity = Affinity_get(p, st->pl);\n   if (!affinity) return HTOP_OK;\n   Panel* affinityPanel = AffinityPanel_new(st->pl, affinity);\n   Affinity_delete(affinity);\n\n   void* set = Action_pickFromVector(st, affinityPanel, 15);\n   if (set) {\n      Affinity* affinity = AffinityPanel_getAffinity(affinityPanel, st->pl);\n      bool ok = MainPanel_foreachProcess((MainPanel*)panel, (MainPanel_ForeachProcessFn) Affinity_set, (Arg){ .v = affinity }, NULL);\n      if (!ok) beep();\n      Affinity_delete(affinity);\n   }\n   Panel_delete((Object*)affinityPanel);\n#endif\n   return HTOP_REFRESH | HTOP_REDRAW_BAR | HTOP_UPDATE_PANELHDR;\n}\n\nstatic Htop_Reaction actionKill(State* st) {\n   Panel* signalsPanel = (Panel*) SignalsPanel_new();\n   ListItem* sgn = (ListItem*) Action_pickFromVector(st, signalsPanel, 15);\n   if (sgn) {\n      if (sgn->key != 0) {\n         Panel_setHeader(st->panel, \"Sending...\");\n         Panel_draw(st->panel, true);\n         refresh();\n         MainPanel_foreachProcess((MainPanel*)st->panel, (MainPanel_ForeachProcessFn) Process_sendSignal, (Arg){ .i = sgn->key }, NULL);\n         napms(500);\n      }\n   }\n   Panel_delete((Object*)signalsPanel);\n   return HTOP_REFRESH | HTOP_REDRAW_BAR | HTOP_UPDATE_PANELHDR;\n}\n\nstatic Htop_Reaction actionFilterByUser(State* st) {\n   Panel* usersPanel = Panel_new(0, 0, 0, 0, true, Class(ListItem), FunctionBar_newEnterEsc(\"Show   \", \"Cancel \"));\n   Panel_setHeader(usersPanel, \"Show processes of:\");\n   UsersTable_foreach(st->ut, addUserToVector, usersPanel);\n   Vector_insertionSort(usersPanel->items);\n   ListItem* allUsers = ListItem_new(\"All users\", -1);\n   Panel_insert(usersPanel, 0, (Object*) allUsers);\n   ListItem* picked = (ListItem*) Action_pickFromVector(st, usersPanel, 20);\n   if (picked) {\n      if (picked == allUsers) {\n         st->pl->userId = -1;\n      } else {\n         Action_setUserOnly(ListItem_getRef(picked), &(st->pl->userId));\n      }\n   }\n   Panel_delete((Object*)usersPanel);\n   return HTOP_REFRESH | HTOP_REDRAW_BAR | HTOP_UPDATE_PANELHDR;\n}\n\nHtop_Reaction Action_follow(State* st) {\n   st->pl->following = MainPanel_selectedPid((MainPanel*)st->panel);\n   Panel_setSelectionColor(st->panel, CRT_colors[PANEL_SELECTION_FOLLOW]);\n   return HTOP_KEEP_FOLLOWING;\n}\n\nstatic Htop_Reaction actionSetup(State* st) {\n   Action_runSetup(st->settings, st->header, st->pl);\n   // TODO: shouldn't need this, colors should be dynamic\n   int headerHeight = Header_calculateHeight(st->header);\n   Panel_move(st->panel, 0, headerHeight);\n   Panel_resize(st->panel, COLS, LINES-headerHeight-1);\n   return HTOP_REFRESH | HTOP_REDRAW_BAR | HTOP_UPDATE_PANELHDR;\n}\n\nstatic Htop_Reaction actionLsof(State* st) {\n   Process* p = (Process*) Panel_getSelected(st->panel);\n   if (!p) return HTOP_OK;\n   OpenFilesScreen* ofs = OpenFilesScreen_new(p);\n   InfoScreen_run((InfoScreen*)ofs);\n   OpenFilesScreen_delete((Object*)ofs);\n   clear();\n   CRT_enableDelay();\n   return HTOP_REFRESH | HTOP_REDRAW_BAR;\n}\n\nstatic Htop_Reaction actionStrace(State* st) {\n   Process* p = (Process*) Panel_getSelected(st->panel);\n   if (!p) return HTOP_OK;\n   TraceScreen* ts = TraceScreen_new(p);\n   bool ok = TraceScreen_forkTracer(ts);\n   if (ok) {\n      InfoScreen_run((InfoScreen*)ts);\n   }\n   TraceScreen_delete((Object*)ts);\n   clear();\n   CRT_enableDelay();\n   return HTOP_REFRESH | HTOP_REDRAW_BAR;\n}\n\nstatic Htop_Reaction actionTag(State* st) {\n   Process* p = (Process*) Panel_getSelected(st->panel);\n   if (!p) return HTOP_OK;\n   Process_toggleTag(p);\n   Panel_onKey(st->panel, KEY_DOWN);\n   return HTOP_OK;\n}\n\nstatic Htop_Reaction actionRedraw() {\n   clear();\n   return HTOP_REFRESH | HTOP_REDRAW_BAR;\n}\n\nstatic const struct { const char* key; const char* info; } helpLeft[] = {\n   { .key = \" Arrows: \", .info = \"scroll process list\" },\n   { .key = \" Digits: \", .info = \"incremental PID search\" },\n   { .key = \"   F3 /: \", .info = \"incremental name search\" },\n   { .key = \"   F4 \\\\: \",.info = \"incremental name filtering\" },\n   { .key = \"   F5 t: \", .info = \"tree view\" },\n   { .key = \"      p: \", .info = \"toggle program path\" },\n   { .key = \"      u: \", .info = \"show processes of a single user\" },\n   { .key = \"      H: \", .info = \"hide/show user process threads\" },\n   { .key = \"      K: \", .info = \"hide/show kernel threads\" },\n   { .key = \"      F: \", .info = \"cursor follows process\" },\n   { .key = \" F6 + -: \", .info = \"expand/collapse tree\" },\n   { .key = \"  P M T: \", .info = \"sort by CPU%, MEM% or TIME\" },\n   { .key = \"      I: \", .info = \"invert sort order\" },\n   { .key = \" F6 > .: \", .info = \"select sort column\" },\n   { .key = NULL, .info = NULL }\n};\n\nstatic const struct { const char* key; const char* info; } helpRight[] = {\n   { .key = \"  Space: \", .info = \"tag process\" },\n   { .key = \"      c: \", .info = \"tag process and its children\" },\n   { .key = \"      U: \", .info = \"untag all processes\" },\n   { .key = \"   F9 k: \", .info = \"kill process/tagged processes\" },\n   { .key = \"   F7 ]: \", .info = \"higher priority (root only)\" },\n   { .key = \"   F8 [: \", .info = \"lower priority (+ nice)\" },\n#if (HAVE_LIBHWLOC || HAVE_LINUX_AFFINITY)\n   { .key = \"      a: \", .info = \"set CPU affinity\" },\n#endif\n   { .key = \"      e: \", .info = \"show process environment\" },\n   { .key = \"      i: \", .info = \"set IO priority\" },\n   { .key = \"      l: \", .info = \"list open files with lsof\" },\n   { .key = \"      s: \", .info = \"trace syscalls with strace\" },\n   { .key = \"         \", .info = \"\" },\n   { .key = \" F2 C S: \", .info = \"setup\" },\n   { .key = \"   F1 h: \", .info = \"show this help screen\" },\n   { .key = \"  F10 q: \", .info = \"quit\" },\n   { .key = NULL, .info = NULL }\n};\n\nstatic Htop_Reaction actionHelp(State* st) {\n   Settings* settings = st->settings;\n\n   clear();\n   attrset(CRT_colors[HELP_BOLD]);\n\n   for (int i = 0; i < LINES-1; i++)\n      mvhline(i, 0, ' ', COLS);\n\n   mvaddstr(0, 0, \"htop \" VERSION \" - \" COPYRIGHT);\n   mvaddstr(1, 0, \"Released under the GNU GPL. See 'man' page for more info.\");\n\n   attrset(CRT_colors[DEFAULT_COLOR]);\n   mvaddstr(3, 0, \"CPU usage bar: \");\n   #define addattrstr(a,s) attrset(a);addstr(s)\n   addattrstr(CRT_colors[BAR_BORDER], \"[\");\n   if (settings->detailedCPUTime) {\n      addattrstr(CRT_colors[CPU_NICE_TEXT], \"low\"); addstr(\"/\");\n      addattrstr(CRT_colors[CPU_NORMAL], \"normal\"); addstr(\"/\");\n      addattrstr(CRT_colors[CPU_KERNEL], \"kernel\"); addstr(\"/\");\n      addattrstr(CRT_colors[CPU_IRQ], \"irq\"); addstr(\"/\");\n      addattrstr(CRT_colors[CPU_SOFTIRQ], \"soft-irq\"); addstr(\"/\");\n      addattrstr(CRT_colors[CPU_STEAL], \"steal\"); addstr(\"/\");\n      addattrstr(CRT_colors[CPU_GUEST], \"guest\"); addstr(\"/\");\n      addattrstr(CRT_colors[CPU_IOWAIT], \"io-wait\");\n      addattrstr(CRT_colors[BAR_SHADOW], \" used%\");\n   } else {\n      addattrstr(CRT_colors[CPU_NICE_TEXT], \"low-priority\"); addstr(\"/\");\n      addattrstr(CRT_colors[CPU_NORMAL], \"normal\"); addstr(\"/\");\n      addattrstr(CRT_colors[CPU_KERNEL], \"kernel\"); addstr(\"/\");\n      addattrstr(CRT_colors[CPU_GUEST], \"virtualiz\");\n      addattrstr(CRT_colors[BAR_SHADOW], \"               used%\");\n   }\n   addattrstr(CRT_colors[BAR_BORDER], \"]\");\n   attrset(CRT_colors[DEFAULT_COLOR]);\n   mvaddstr(4, 0, \"Memory bar:    \");\n   addattrstr(CRT_colors[BAR_BORDER], \"[\");\n   addattrstr(CRT_colors[MEMORY_USED], \"used\"); addstr(\"/\");\n   addattrstr(CRT_colors[MEMORY_BUFFERS_TEXT], \"buffers\"); addstr(\"/\");\n   addattrstr(CRT_colors[MEMORY_CACHE], \"cache\");\n   addattrstr(CRT_colors[BAR_SHADOW], \"                            used/total\");\n   addattrstr(CRT_colors[BAR_BORDER], \"]\");\n   attrset(CRT_colors[DEFAULT_COLOR]);\n   mvaddstr(5, 0, \"Swap bar:      \");\n   addattrstr(CRT_colors[BAR_BORDER], \"[\");\n   addattrstr(CRT_colors[SWAP], \"used\");\n   addattrstr(CRT_colors[BAR_SHADOW], \"                                          used/total\");\n   addattrstr(CRT_colors[BAR_BORDER], \"]\");\n   attrset(CRT_colors[DEFAULT_COLOR]);\n   mvaddstr(6,0, \"Type and layout of header meters are configurable in the setup screen.\");\n   if (CRT_colorScheme == COLORSCHEME_MONOCHROME) {\n      mvaddstr(7, 0, \"In monochrome, meters display as different chars, in order: |#*@$%&.\");\n   }\n   mvaddstr( 8, 0, \" Status: R: running; S: sleeping; T: traced/stopped; Z: zombie; D: disk sleep\");\n   for (int i = 0; helpLeft[i].info; i++) { mvaddstr(9+i, 9,  helpLeft[i].info); }\n   for (int i = 0; helpRight[i].info; i++) { mvaddstr(9+i, 49, helpRight[i].info); }\n   attrset(CRT_colors[HELP_BOLD]);\n   for (int i = 0; helpLeft[i].key;  i++) { mvaddstr(9+i, 0,  helpLeft[i].key); }\n   for (int i = 0; helpRight[i].key; i++) { mvaddstr(9+i, 40, helpRight[i].key); }\n   attrset(CRT_colors[PROCESS_THREAD]);\n   mvaddstr(16, 32, \"threads\");\n   mvaddstr(17, 26, \"threads\");\n   attrset(CRT_colors[DEFAULT_COLOR]);\n\n   attrset(CRT_colors[HELP_BOLD]);\n   mvaddstr(23,0, \"Press any key to return.\");\n   attrset(CRT_colors[DEFAULT_COLOR]);\n   refresh();\n   CRT_readKey();\n   clear();\n\n   return HTOP_RECALCULATE | HTOP_REDRAW_BAR;\n}\n\nstatic Htop_Reaction actionUntagAll(State* st) {\n   for (int i = 0; i < Panel_size(st->panel); i++) {\n      Process* p = (Process*) Panel_get(st->panel, i);\n      p->tag = false;\n   }\n   return HTOP_REFRESH;\n}\n\nstatic Htop_Reaction actionTagAllChildren(State* st) {\n   Process* p = (Process*) Panel_getSelected(st->panel);\n   if (!p) return HTOP_OK;\n   tagAllChildren(st->panel, p);\n   return HTOP_OK;\n}\n\nstatic Htop_Reaction actionShowEnvScreen(State* st) {\n   Process* p = (Process*) Panel_getSelected(st->panel);\n   if (!p) return HTOP_OK;\n   EnvScreen* es = EnvScreen_new(p);\n   InfoScreen_run((InfoScreen*)es);\n   EnvScreen_delete((Object*)es);\n   clear();\n   CRT_enableDelay();\n   return HTOP_REFRESH | HTOP_REDRAW_BAR;\n}\n\n\nvoid Action_setBindings(Htop_Action* keys) {\n   keys[KEY_RESIZE] = actionResize;\n   keys['M'] = actionSortByMemory;\n   keys['T'] = actionSortByTime;\n   keys['P'] = actionSortByCPU;\n   keys['H'] = actionToggleUserlandThreads;\n   keys['K'] = actionToggleKernelThreads;\n   keys['p'] = actionToggleProgramPath;\n   keys['t'] = actionToggleTreeView;\n   keys[KEY_F(5)] = actionToggleTreeView;\n   keys[KEY_F(4)] = actionIncFilter;\n   keys['\\\\'] = actionIncFilter;\n   keys[KEY_F(3)] = actionIncSearch;\n   keys['/'] = actionIncSearch;\n\n   keys[']'] = actionHigherPriority;\n   keys[KEY_F(7)] = actionHigherPriority;\n   keys['['] = actionLowerPriority;\n   keys[KEY_F(8)] = actionLowerPriority;\n   keys['I'] = actionInvertSortOrder;\n   keys[KEY_F(6)] = actionExpandCollapseOrSortColumn;\n   keys[KEY_F(18)] = actionExpandCollapseOrSortColumn;\n   keys['<'] = actionSetSortColumn;\n   keys[','] = actionSetSortColumn;\n   keys['>'] = actionSetSortColumn;\n   keys['.'] = actionSetSortColumn;\n   keys[KEY_F(10)] = actionQuit;\n   keys['q'] = actionQuit;\n   keys['a'] = actionSetAffinity;\n   keys[KEY_F(9)] = actionKill;\n   keys['k'] = actionKill;\n   keys[KEY_RECLICK] = actionExpandOrCollapse;\n   keys['+'] = actionExpandOrCollapse;\n   keys['='] = actionExpandOrCollapse;\n   keys['-'] = actionExpandOrCollapse;\n   keys['\\177'] = actionCollapseIntoParent;\n   keys['u'] = actionFilterByUser;\n   keys['F'] = Action_follow;\n   keys['S'] = actionSetup;\n   keys['C'] = actionSetup;\n   keys[KEY_F(2)] = actionSetup;\n   keys['l'] = actionLsof;\n   keys['s'] = actionStrace;\n   keys[' '] = actionTag;\n   keys['\\014'] = actionRedraw; // Ctrl+L\n   keys[KEY_F(1)] = actionHelp;\n   keys['h'] = actionHelp;\n   keys['?'] = actionHelp;\n   keys['U'] = actionUntagAll;\n   keys['c'] = actionTagAllChildren;\n   keys['e'] = actionShowEnvScreen;\n}\n\n"
        },
        {
          "name": "Action.h",
          "type": "blob",
          "size": 1.208984375,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_Action\n#define HEADER_Action\n/*\nhtop - Action.h\n(C) 2015 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n\n#include \"IncSet.h\"\n#include \"Settings.h\"\n#include \"Header.h\"\n#include \"UsersTable.h\"\n#include \"ProcessList.h\"\n#include \"Panel.h\"\n\ntypedef enum {\n   HTOP_OK = 0x00,\n   HTOP_REFRESH = 0x01,\n   HTOP_RECALCULATE = 0x03, // implies HTOP_REFRESH\n   HTOP_SAVE_SETTINGS = 0x04,\n   HTOP_KEEP_FOLLOWING = 0x08,\n   HTOP_QUIT = 0x10,\n   HTOP_REDRAW_BAR = 0x20,\n   HTOP_UPDATE_PANELHDR = 0x41, // implies HTOP_REFRESH\n} Htop_Reaction;\n\ntypedef Htop_Reaction (*Htop_Action)();\n\ntypedef struct State_ {\n   Settings* settings;\n   UsersTable* ut;\n   ProcessList* pl;\n   Panel* panel;\n   Header* header;\n} State;\n\n\nObject* Action_pickFromVector(State* st, Panel* list, int x);\n\n// ----------------------------------------\n\nbool Action_setUserOnly(const char* userName, uid_t* userId);\n\nHtop_Reaction Action_setSortKey(Settings* settings, ProcessField sortKey);\n\n// ----------------------------------------\n\nHtop_Reaction Action_follow(State* st);\n\n\nvoid Action_setBindings(Htop_Action* keys);\n\n\n#endif\n"
        },
        {
          "name": "Affinity.c",
          "type": "blob",
          "size": 2.7294921875,
          "content": "/*\nhtop - Affinity.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Affinity.h\"\n\n#include <stdlib.h>\n\n#ifdef HAVE_LIBHWLOC\n#include <hwloc.h>\n#if __linux__\n#define HTOP_HWLOC_CPUBIND_FLAG HWLOC_CPUBIND_THREAD\n#else\n#define HTOP_HWLOC_CPUBIND_FLAG HWLOC_CPUBIND_PROCESS\n#endif\n#elif HAVE_LINUX_AFFINITY\n#include <sched.h>\n#endif\n\n/*{\n#include \"Process.h\"\n#include \"ProcessList.h\"\n\ntypedef struct Affinity_ {\n   ProcessList* pl;\n   int size;\n   int used;\n   int* cpus;\n} Affinity;\n\n}*/\n\nAffinity* Affinity_new(ProcessList* pl) {\n   Affinity* this = xCalloc(1, sizeof(Affinity));\n   this->size = 8;\n   this->cpus = xCalloc(this->size, sizeof(int));\n   this->pl = pl;\n   return this;\n}\n\nvoid Affinity_delete(Affinity* this) {\n   free(this->cpus);\n   free(this);\n}\n\nvoid Affinity_add(Affinity* this, int id) {\n   if (this->used == this->size) {\n      this->size *= 2;\n      this->cpus = xRealloc(this->cpus, sizeof(int) * this->size);\n   }\n   this->cpus[this->used] = id;\n   this->used++;\n}\n\n\n#ifdef HAVE_LIBHWLOC\n\nAffinity* Affinity_get(Process* proc, ProcessList* pl) {\n   hwloc_cpuset_t cpuset = hwloc_bitmap_alloc();\n   bool ok = (hwloc_get_proc_cpubind(pl->topology, proc->pid, cpuset, HTOP_HWLOC_CPUBIND_FLAG) == 0);\n   Affinity* affinity = NULL;\n   if (ok) {\n      affinity = Affinity_new(pl);\n      if (hwloc_bitmap_last(cpuset) == -1) {\n         for (int i = 0; i < pl->cpuCount; i++) {\n            Affinity_add(affinity, i);\n         }\n      } else {\n         unsigned int id;\n         hwloc_bitmap_foreach_begin(id, cpuset);\n            Affinity_add(affinity, id);\n         hwloc_bitmap_foreach_end();\n      }\n   }\n   hwloc_bitmap_free(cpuset);\n   return affinity;\n}\n\nbool Affinity_set(Process* proc, Affinity* this) {\n   hwloc_cpuset_t cpuset = hwloc_bitmap_alloc();\n   for (int i = 0; i < this->used; i++) {\n      hwloc_bitmap_set(cpuset, this->cpus[i]);\n   }\n   bool ok = (hwloc_set_proc_cpubind(this->pl->topology, proc->pid, cpuset, HTOP_HWLOC_CPUBIND_FLAG) == 0);\n   hwloc_bitmap_free(cpuset);\n   return ok;\n}\n\n#elif HAVE_LINUX_AFFINITY\n\nAffinity* Affinity_get(Process* proc, ProcessList* pl) {\n   cpu_set_t cpuset;\n   bool ok = (sched_getaffinity(proc->pid, sizeof(cpu_set_t), &cpuset) == 0);\n   if (!ok) return NULL;\n   Affinity* affinity = Affinity_new(pl);\n   for (int i = 0; i < pl->cpuCount; i++) {\n      if (CPU_ISSET(i, &cpuset))\n         Affinity_add(affinity, i);\n   }\n   return affinity;\n}\n\nbool Affinity_set(Process* proc, Affinity* this) {\n   cpu_set_t cpuset;\n   CPU_ZERO(&cpuset);\n   for (int i = 0; i < this->used; i++) {\n      CPU_SET(this->cpus[i], &cpuset);\n   }\n   bool ok = (sched_setaffinity(proc->pid, sizeof(unsigned long), &cpuset) == 0);\n   return ok;\n}\n\n#endif\n"
        },
        {
          "name": "Affinity.h",
          "type": "blob",
          "size": 0.9814453125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_Affinity\n#define HEADER_Affinity\n/*\nhtop - Affinity.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#ifdef HAVE_LIBHWLOC\n#if __linux__\n#define HTOP_HWLOC_CPUBIND_FLAG HWLOC_CPUBIND_THREAD\n#else\n#define HTOP_HWLOC_CPUBIND_FLAG HWLOC_CPUBIND_PROCESS\n#endif\n#elif HAVE_LINUX_AFFINITY\n#endif\n\n#include \"Process.h\"\n#include \"ProcessList.h\"\n\ntypedef struct Affinity_ {\n   ProcessList* pl;\n   int size;\n   int used;\n   int* cpus;\n} Affinity;\n\n\nAffinity* Affinity_new(ProcessList* pl);\n\nvoid Affinity_delete(Affinity* this);\n\nvoid Affinity_add(Affinity* this, int id);\n\n#ifdef HAVE_LIBHWLOC\n\nAffinity* Affinity_get(Process* proc, ProcessList* pl);\n\nbool Affinity_set(Process* proc, Affinity* this);\n\n#elif HAVE_LINUX_AFFINITY\n\nAffinity* Affinity_get(Process* proc, ProcessList* pl);\n\nbool Affinity_set(Process* proc, Affinity* this);\n\n#endif\n\n#endif\n"
        },
        {
          "name": "AffinityPanel.c",
          "type": "blob",
          "size": 1.8564453125,
          "content": "/*\nhtop - AffinityPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"AffinityPanel.h\"\n#include \"CRT.h\"\n\n#include \"CheckItem.h\"\n\n#include <assert.h>\n#include <string.h>\n\n/*{\n#include \"Panel.h\"\n#include \"Affinity.h\"\n#include \"ProcessList.h\"\n#include \"ListItem.h\"\n}*/\n\nstatic HandlerResult AffinityPanel_eventHandler(Panel* this, int ch) {\n   CheckItem* selected = (CheckItem*) Panel_getSelected(this);\n   switch(ch) {\n   case KEY_MOUSE:\n   case KEY_RECLICK:\n   case ' ':\n      CheckItem_set(selected, ! (CheckItem_get(selected)) );\n      return HANDLED;\n   case 0x0a:\n   case 0x0d:\n   case KEY_ENTER:\n      return BREAK_LOOP;\n   }\n   return IGNORED;\n}\n\nPanelClass AffinityPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = Panel_delete\n   },\n   .eventHandler = AffinityPanel_eventHandler\n};\n\nPanel* AffinityPanel_new(ProcessList* pl, Affinity* affinity) {\n   Panel* this = Panel_new(1, 1, 1, 1, true, Class(CheckItem), FunctionBar_newEnterEsc(\"Set    \", \"Cancel \"));\n   Object_setClass(this, Class(AffinityPanel));\n\n   Panel_setHeader(this, \"Use CPUs:\");\n   int curCpu = 0;\n   for (int i = 0; i < pl->cpuCount; i++) {\n      char number[10];\n      xSnprintf(number, 9, \"%d\", Settings_cpuId(pl->settings, i));\n      bool mode;\n      if (curCpu < affinity->used && affinity->cpus[curCpu] == i) {\n         mode = true;\n         curCpu++;\n      } else {\n         mode = false;\n      }\n      Panel_add(this, (Object*) CheckItem_newByVal(xStrdup(number), mode));\n   }\n   return this;\n}\n\nAffinity* AffinityPanel_getAffinity(Panel* this, ProcessList* pl) {\n   Affinity* affinity = Affinity_new(pl);\n   int size = Panel_size(this);\n   for (int i = 0; i < size; i++) {\n      if (CheckItem_get((CheckItem*)Panel_get(this, i)))\n         Affinity_add(affinity, i);\n   }\n   return affinity;\n}\n"
        },
        {
          "name": "AffinityPanel.h",
          "type": "blob",
          "size": 0.533203125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_AffinityPanel\n#define HEADER_AffinityPanel\n/*\nhtop - AffinityPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Panel.h\"\n#include \"Affinity.h\"\n#include \"ProcessList.h\"\n#include \"ListItem.h\"\n\nextern PanelClass AffinityPanel_class;\n\nPanel* AffinityPanel_new(ProcessList* pl, Affinity* affinity);\n\nAffinity* AffinityPanel_getAffinity(Panel* this, ProcessList* pl);\n\n#endif\n"
        },
        {
          "name": "AvailableColumnsPanel.c",
          "type": "blob",
          "size": 2.5166015625,
          "content": "/*\nhtop - AvailableColumnsPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"AvailableColumnsPanel.h\"\n#include \"Platform.h\"\n\n#include \"Header.h\"\n#include \"ColumnsPanel.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n\n/*{\n#include \"Panel.h\"\n\ntypedef struct AvailableColumnsPanel_ {\n   Panel super;\n   Panel* columns;\n} AvailableColumnsPanel;\n\n}*/\n\nstatic const char* const AvailableColumnsFunctions[] = {\"      \", \"      \", \"      \", \"      \", \"Add   \", \"      \", \"      \", \"      \", \"      \", \"Done  \", NULL};\n\nstatic void AvailableColumnsPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   AvailableColumnsPanel* this = (AvailableColumnsPanel*) object;\n   Panel_done(super);\n   free(this);\n}\n\nstatic HandlerResult AvailableColumnsPanel_eventHandler(Panel* super, int ch) {\n   AvailableColumnsPanel* this = (AvailableColumnsPanel*) super;\n   int key = ((ListItem*) Panel_getSelected(super))->key;\n   HandlerResult result = IGNORED;\n\n   switch(ch) {\n      case 13:\n      case KEY_ENTER:\n      case KEY_F(5):\n      {\n         int at = Panel_getSelectedIndex(this->columns);\n         Panel_insert(this->columns, at, (Object*) ListItem_new(Process_fields[key].name, key));\n         Panel_setSelected(this->columns, at+1);\n         ColumnsPanel_update(this->columns);\n         result = HANDLED;\n         break;\n      }\n      default:\n      {\n         if (ch < 255 && isalpha(ch))\n            result = Panel_selectByTyping(super, ch);\n         break;\n      }\n   }\n   return result;\n}\n\nPanelClass AvailableColumnsPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = AvailableColumnsPanel_delete\n   },\n   .eventHandler = AvailableColumnsPanel_eventHandler\n};\n\nAvailableColumnsPanel* AvailableColumnsPanel_new(Panel* columns) {\n   AvailableColumnsPanel* this = AllocThis(AvailableColumnsPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_new(AvailableColumnsFunctions, NULL, NULL);\n   Panel_init(super, 1, 1, 1, 1, Class(ListItem), true, fuBar);\n\n   Panel_setHeader(super, \"Available Columns\");\n\n   for (int i = 1; i < Platform_numberOfFields; i++) {\n      if (i != COMM && Process_fields[i].description) {\n         char description[256];\n         xSnprintf(description, sizeof(description), \"%s - %s\", Process_fields[i].name, Process_fields[i].description);\n         Panel_add(super, (Object*) ListItem_new(description, i));\n      }\n   }\n   this->columns = columns;\n   return this;\n}\n"
        },
        {
          "name": "AvailableColumnsPanel.h",
          "type": "blob",
          "size": 0.533203125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_AvailableColumnsPanel\n#define HEADER_AvailableColumnsPanel\n/*\nhtop - AvailableColumnsPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Panel.h\"\n\ntypedef struct AvailableColumnsPanel_ {\n   Panel super;\n   Panel* columns;\n} AvailableColumnsPanel;\n\n\nextern PanelClass AvailableColumnsPanel_class;\n\nAvailableColumnsPanel* AvailableColumnsPanel_new(Panel* columns);\n\n#endif\n"
        },
        {
          "name": "AvailableMetersPanel.c",
          "type": "blob",
          "size": 4.021484375,
          "content": "/*\nhtop - AvailableMetersPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"AvailableMetersPanel.h\"\n#include \"MetersPanel.h\"\n\n#include \"CPUMeter.h\"\n#include \"Header.h\"\n#include \"ListItem.h\"\n#include \"Platform.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n\n/*{\n#include \"Settings.h\"\n#include \"Panel.h\"\n#include \"ScreenManager.h\"\n#include \"ProcessList.h\"\n\ntypedef struct AvailableMetersPanel_ {\n   Panel super;\n   ScreenManager* scr;\n\n   Settings* settings;\n   Header* header;\n   Panel* leftPanel;\n   Panel* rightPanel;\n} AvailableMetersPanel;\n\n}*/\n\nstatic void AvailableMetersPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   AvailableMetersPanel* this = (AvailableMetersPanel*) object;\n   Panel_done(super);\n   free(this);\n}\n\nstatic inline void AvailableMetersPanel_addMeter(Header* header, Panel* panel, MeterClass* type, int param, int column) {\n   Meter* meter = (Meter*) Header_addMeterByClass(header, type, param, column);\n   Panel_add(panel, (Object*) Meter_toListItem(meter, false));\n   Panel_setSelected(panel, Panel_size(panel) - 1);\n   MetersPanel_setMoving((MetersPanel*)panel, true);\n   FunctionBar_draw(panel->currentBar, NULL);\n}\n\nstatic HandlerResult AvailableMetersPanel_eventHandler(Panel* super, int ch) {\n   AvailableMetersPanel* this = (AvailableMetersPanel*) super;\n   Header* header = this->header;\n   \n   ListItem* selected = (ListItem*) Panel_getSelected(super);\n   int param = selected->key & 0xff;\n   int type = selected->key >> 16;\n   HandlerResult result = IGNORED;\n   bool update = false;\n\n   switch(ch) {\n      case KEY_F(5):\n      case 'l':\n      case 'L':\n      {\n         AvailableMetersPanel_addMeter(header, this->leftPanel, Platform_meterTypes[type], param, 0);\n         result = HANDLED;\n         update = true;\n         break;\n      }\n      case 0x0a:\n      case 0x0d:\n      case KEY_ENTER:\n      case KEY_F(6):\n      case 'r':\n      case 'R':\n      {\n         AvailableMetersPanel_addMeter(header, this->rightPanel, Platform_meterTypes[type], param, 1);\n         result = (KEY_LEFT << 16) | SYNTH_KEY;\n         update = true;\n         break;\n      }\n   }\n   if (update) {\n      this->settings->changed = true;\n      Header_calculateHeight(header);\n      Header_draw(header);\n      ScreenManager_resize(this->scr, this->scr->x1, header->height, this->scr->x2, this->scr->y2);\n   }\n   return result;\n}\n\nPanelClass AvailableMetersPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = AvailableMetersPanel_delete\n   },\n   .eventHandler = AvailableMetersPanel_eventHandler\n};\n\nAvailableMetersPanel* AvailableMetersPanel_new(Settings* settings, Header* header, Panel* leftMeters, Panel* rightMeters, ScreenManager* scr, ProcessList* pl) {\n   AvailableMetersPanel* this = AllocThis(AvailableMetersPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_newEnterEsc(\"Add   \", \"Done   \");\n   Panel_init(super, 1, 1, 1, 1, Class(ListItem), true, fuBar);\n   \n   this->settings = settings;\n   this->header = header;\n   this->leftPanel = leftMeters;\n   this->rightPanel = rightMeters;\n   this->scr = scr;\n\n   Panel_setHeader(super, \"Available meters\");\n   // Platform_meterTypes[0] should be always (&CPUMeter_class), which we will\n   // handle separately in the code below.\n   for (int i = 1; Platform_meterTypes[i]; i++) {\n      MeterClass* type = Platform_meterTypes[i];\n      assert(type != &CPUMeter_class);\n      const char* label = type->description ? type->description : type->uiName;\n      Panel_add(super, (Object*) ListItem_new(label, i << 16));\n   }\n   // Handle (&CPUMeter_class)\n   MeterClass* type = &CPUMeter_class;\n   int cpus = pl->cpuCount;\n   if (cpus > 1) {\n      Panel_add(super, (Object*) ListItem_new(\"CPU average\", 0));\n      for (int i = 1; i <= cpus; i++) {\n         char buffer[50];\n         xSnprintf(buffer, 50, \"%s %d\", type->uiName, i);\n         Panel_add(super, (Object*) ListItem_new(buffer, i));\n      }\n   } else {\n      Panel_add(super, (Object*) ListItem_new(\"CPU\", 1));\n   }\n   return this;\n}\n"
        },
        {
          "name": "AvailableMetersPanel.h",
          "type": "blob",
          "size": 0.779296875,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_AvailableMetersPanel\n#define HEADER_AvailableMetersPanel\n/*\nhtop - AvailableMetersPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Settings.h\"\n#include \"Panel.h\"\n#include \"ScreenManager.h\"\n#include \"ProcessList.h\"\n\ntypedef struct AvailableMetersPanel_ {\n   Panel super;\n   ScreenManager* scr;\n\n   Settings* settings;\n   Header* header;\n   Panel* leftPanel;\n   Panel* rightPanel;\n} AvailableMetersPanel;\n\n\nextern PanelClass AvailableMetersPanel_class;\n\nAvailableMetersPanel* AvailableMetersPanel_new(Settings* settings, Header* header, Panel* leftMeters, Panel* rightMeters, ScreenManager* scr, ProcessList* pl);\n\n#endif\n"
        },
        {
          "name": "BatteryMeter.c",
          "type": "blob",
          "size": 1.740234375,
          "content": "/*\nhtop - BatteryMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n\nThis meter written by Ian P. Hands (iphands@gmail.com, ihands@redhat.com).\n*/\n\n#include \"BatteryMeter.h\"\n\n#include \"Battery.h\"\n#include \"ProcessList.h\"\n#include \"CRT.h\"\n#include \"StringUtils.h\"\n#include \"Platform.h\"\n\n#include <string.h>\n#include <stdlib.h>\n\n/*{\n#include \"Meter.h\"\n\ntypedef enum ACPresence_ {\n   AC_ABSENT,\n   AC_PRESENT,\n   AC_ERROR\n} ACPresence;\n}*/\n\nint BatteryMeter_attributes[] = {\n   BATTERY\n};\n\nstatic void BatteryMeter_updateValues(Meter * this, char *buffer, int len) {\n   ACPresence isOnAC;\n   double percent;\n   \n   Battery_getData(&percent, &isOnAC);\n\n   if (percent == -1) {\n      this->values[0] = 0;\n      xSnprintf(buffer, len, \"n/a\");\n      return;\n   }\n\n   this->values[0] = percent;\n\n   const char *onAcText, *onBatteryText, *unknownText;\n\n   unknownText = \"%.1f%%\";\n   if (this->mode == TEXT_METERMODE) {\n      onAcText = \"%.1f%% (Running on A/C)\";\n      onBatteryText = \"%.1f%% (Running on battery)\";\n   } else {\n      onAcText = \"%.1f%%(A/C)\";\n      onBatteryText = \"%.1f%%(bat)\";\n   }\n\n   if (isOnAC == AC_PRESENT) {\n      xSnprintf(buffer, len, onAcText, percent);\n   } else if (isOnAC == AC_ABSENT) {\n      xSnprintf(buffer, len, onBatteryText, percent);\n   } else {\n      xSnprintf(buffer, len, unknownText, percent);\n   }\n\n   return;\n}\n\nMeterClass BatteryMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete\n   },\n   .updateValues = BatteryMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .maxItems = 1,\n   .total = 100.0,\n   .attributes = BatteryMeter_attributes,\n   .name = \"Battery\",\n   .uiName = \"Battery\",\n   .caption = \"Battery: \"\n};\n"
        },
        {
          "name": "BatteryMeter.h",
          "type": "blob",
          "size": 0.5263671875,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_BatteryMeter\n#define HEADER_BatteryMeter\n/*\nhtop - BatteryMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n\nThis meter written by Ian P. Hands (iphands@gmail.com, ihands@redhat.com).\n*/\n\n#include \"Meter.h\"\n\ntypedef enum ACPresence_ {\n   AC_ABSENT,\n   AC_PRESENT,\n   AC_ERROR\n} ACPresence;\n\nextern int BatteryMeter_attributes[];\n\nextern MeterClass BatteryMeter_class;\n\n#endif\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.3623046875,
          "content": "\nContributing Guide\n==================\n\nHello, and thank you so much for taking your time to contribute in any way to\nhtop! There are many ways to contribute, and I'll try to list them below. The\nsupport from the free software community has been amazing over the years and\nit is the number one thing that keeps me going, maintaining and improving\nsomething that started as a tiny pet project back in 2004 and that nowadays is\na piece of software used all over the world, in both reality [and\nfiction!](http://hisham.hm/htop/index.php?page=sightings). Cheers!\n\n-- Hisham Muhammad\n\nBug Reports\n-----------\n\nBug reports should be posted in the [Github issue\ntracker](http://github.com/hishamhm/htop/issues). (I reply to them all, but I\nusually do it in batches! :) ) Bug reports are extremely important since it's\nimpossible for me to test htop in every possible system, distribution and\nscenario. Your feedback is what keeps the tool stable and always improving!\nThank you!\n\nPull Requests\n-------------\n\nCode contributions are most welcome! Just [fork the\nrepo](http://github.com/hishamhm/htop) and send a [pull\nrequest](https://github.com/hishamhm/htop/pulls). Help is especially\nappreciated for support of platforms other than Linux. If proposing new\nfeatures, please be mindful that htop is a system tool that needs to keep a\nsmall footprint and perform well on systems under stress -- so unfortunately I\ncan't accept every new feature proposed, as I need to keep the tool slim and\nmaintainable. Great ideas backed by a PR are always carefully considered for\ninclusion, though! Also, PRs containing bug fixes and portability tweaks are a\nno-brainer, please send those in!\n\nFeature Requests\n----------------\n\nBack when htop was hosted in SourceForge, there used to be separate Bug\nTracker and Feature Request pages. These go all lumped together under \"Issues\"\nin Github, which is a bit confusing. For this reason, I close Feature Requests\nand file them with the [`feature\nrequest`](https://github.com/hishamhm/htop/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22feature+request%22+)\nlabel, where they remain accessible, but not mixed with actual bug reports.\nThis doesn't mean I'm dismissing or ignoring feature requests right away! It's\njust an organizational issue (with Github, really!).\n\nDonations\n---------\n\nIf you like htop, feel free to [buy the author a\nbeer](http://hisham.hm/htop/index.php?page=donate). :-) \n\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 18.314453125,
          "content": "\t\t    GNU GENERAL PUBLIC LICENSE\n\t\t       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n                          675 Mass Ave, Cambridge, MA 02139, USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\t\t\t    Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Library General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\f\n\t\t    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\f\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\f\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\f\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n\t\t\t    NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n\t\t     END OF TERMS AND CONDITIONS\n\f\n\tAppendix: How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) 19yy  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) 19yy name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Library General\nPublic License instead of this License.\n\n\f\n\tAppendix 2: Special exception concerning PLPA\n\n In the following exception, \"PLPA\" means (i) code released by the\n Portable Linux Processor Affinity Project, or (ii) derivative works of\n such code, in both cases provided that the code is covered entirely by\n free software licensing terms.\n\n As a special exception to the GNU GPL, the licensors of htop give you\n permission to combine GNU GPL-licensed code in htop (and derivative\n works of such code) with PLPA. You may copy and distribute such a\n combined work following the terms of the GNU GPL for htop and the\n applicable licenses of the version of PLPA used in your combined work,\n provided that you include the source code of such version of PLPA when\n and as the GNU GPL requires distribution of source code.\n\n"
        },
        {
          "name": "CPUMeter.c",
          "type": "blob",
          "size": 10.2294921875,
          "content": "/*\nhtop - CPUMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"CPUMeter.h\"\n\n#include \"CRT.h\"\n#include \"Settings.h\"\n#include \"Platform.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n/*{\n#include \"Meter.h\"\n\ntypedef enum {\n   CPU_METER_NICE = 0,\n   CPU_METER_NORMAL = 1,\n   CPU_METER_KERNEL = 2,\n   CPU_METER_IRQ = 3,\n   CPU_METER_SOFTIRQ = 4,\n   CPU_METER_STEAL = 5,\n   CPU_METER_GUEST = 6,\n   CPU_METER_IOWAIT = 7,\n   CPU_METER_ITEMCOUNT = 8, // number of entries in this enum\n} CPUMeterValues;\n\n}*/\n\nint CPUMeter_attributes[] = {\n   CPU_NICE, CPU_NORMAL, CPU_KERNEL, CPU_IRQ, CPU_SOFTIRQ, CPU_STEAL, CPU_GUEST, CPU_IOWAIT\n};\n\n#ifndef MIN\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#endif\n#ifndef MAX\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#endif\n\nstatic void CPUMeter_init(Meter* this) {\n   int cpu = this->param;\n   if (this->pl->cpuCount > 1) {\n      char caption[10];\n      xSnprintf(caption, sizeof(caption), \"%-3d\", Settings_cpuId(this->pl->settings, cpu - 1));\n      Meter_setCaption(this, caption);\n   }\n   if (this->param == 0)\n      Meter_setCaption(this, \"Avg\");\n}\n\nstatic void CPUMeter_updateValues(Meter* this, char* buffer, int size) {\n   int cpu = this->param;\n   if (cpu > this->pl->cpuCount) {\n      xSnprintf(buffer, size, \"absent\");\n      return;\n   }\n   memset(this->values, 0, sizeof(double) * CPU_METER_ITEMCOUNT);\n   double percent = Platform_setCPUValues(this, cpu);\n   xSnprintf(buffer, size, \"%5.1f%%\", percent);\n}\n\nstatic void CPUMeter_display(Object* cast, RichString* out) {\n   char buffer[50];\n   Meter* this = (Meter*)cast;\n   RichString_prune(out);\n   if (this->param > this->pl->cpuCount) {\n      RichString_append(out, CRT_colors[METER_TEXT], \"absent\");\n      return;\n   }\n   xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_NORMAL]);\n   RichString_append(out, CRT_colors[METER_TEXT], \":\");\n   RichString_append(out, CRT_colors[CPU_NORMAL], buffer);\n   if (this->pl->settings->detailedCPUTime) {\n      xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_KERNEL]);\n      RichString_append(out, CRT_colors[METER_TEXT], \"sy:\");\n      RichString_append(out, CRT_colors[CPU_KERNEL], buffer);\n      xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_NICE]);\n      RichString_append(out, CRT_colors[METER_TEXT], \"ni:\");\n      RichString_append(out, CRT_colors[CPU_NICE_TEXT], buffer);\n      xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_IRQ]);\n      RichString_append(out, CRT_colors[METER_TEXT], \"hi:\");\n      RichString_append(out, CRT_colors[CPU_IRQ], buffer);\n      xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_SOFTIRQ]);\n      RichString_append(out, CRT_colors[METER_TEXT], \"si:\");\n      RichString_append(out, CRT_colors[CPU_SOFTIRQ], buffer);\n      if (this->values[CPU_METER_STEAL]) {\n         xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_STEAL]);\n         RichString_append(out, CRT_colors[METER_TEXT], \"st:\");\n         RichString_append(out, CRT_colors[CPU_STEAL], buffer);\n      }\n      if (this->values[CPU_METER_GUEST]) {\n         xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_GUEST]);\n         RichString_append(out, CRT_colors[METER_TEXT], \"gu:\");\n         RichString_append(out, CRT_colors[CPU_GUEST], buffer);\n      }\n      xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_IOWAIT]);\n      RichString_append(out, CRT_colors[METER_TEXT], \"wa:\");\n      RichString_append(out, CRT_colors[CPU_IOWAIT], buffer);\n   } else {\n      xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_KERNEL]);\n      RichString_append(out, CRT_colors[METER_TEXT], \"sys:\");\n      RichString_append(out, CRT_colors[CPU_KERNEL], buffer);\n      xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_NICE]);\n      RichString_append(out, CRT_colors[METER_TEXT], \"low:\");\n      RichString_append(out, CRT_colors[CPU_NICE_TEXT], buffer);\n      if (this->values[CPU_METER_IRQ]) {\n         xSnprintf(buffer, sizeof(buffer), \"%5.1f%% \", this->values[CPU_METER_IRQ]);\n         RichString_append(out, CRT_colors[METER_TEXT], \"vir:\");\n         RichString_append(out, CRT_colors[CPU_GUEST], buffer);\n      }\n   }\n}\n\nstatic void AllCPUsMeter_getRange(Meter* this, int* start, int* count) {\n   int cpus = this->pl->cpuCount;\n   switch(Meter_name(this)[0]) {\n      default:\n      case 'A': // All\n         *start = 0;\n         *count = cpus;\n         break;\n      case 'L': // First Half\n         *start = 0;\n         *count = (cpus+1) / 2;\n         break;\n      case 'R': // Second Half\n         *start = (cpus+1) / 2;\n         *count = cpus / 2;\n         break;\n   }\n}\n\nstatic void AllCPUsMeter_init(Meter* this) {\n   int cpus = this->pl->cpuCount;\n   if (!this->drawData)\n      this->drawData = xCalloc(cpus, sizeof(Meter*));\n   Meter** meters = (Meter**) this->drawData;\n   int start, count;\n   AllCPUsMeter_getRange(this, &start, &count);\n   for (int i = 0; i < count; i++) {\n      if (!meters[i])\n         meters[i] = Meter_new(this->pl, start+i+1, (MeterClass*) Class(CPUMeter));\n      Meter_init(meters[i]);\n   }\n   if (this->mode == 0)\n      this->mode = BAR_METERMODE;\n   int h = Meter_modes[this->mode]->h;\n   if (strchr(Meter_name(this), '2'))\n      this->h = h * ((count+1) / 2);\n   else\n      this->h = h * count;\n}\n\nstatic void AllCPUsMeter_done(Meter* this) {\n   Meter** meters = (Meter**) this->drawData;\n   int start, count;\n   AllCPUsMeter_getRange(this, &start, &count);\n   for (int i = 0; i < count; i++)\n      Meter_delete((Object*)meters[i]);\n}\n\nstatic void AllCPUsMeter_updateMode(Meter* this, int mode) {\n   Meter** meters = (Meter**) this->drawData;\n   this->mode = mode;\n   int h = Meter_modes[mode]->h;\n   int start, count;\n   AllCPUsMeter_getRange(this, &start, &count);\n   for (int i = 0; i < count; i++) {\n      Meter_setMode(meters[i], mode);\n   }\n   if (strchr(Meter_name(this), '2'))\n      this->h = h * ((count+1) / 2);\n   else\n      this->h = h * count;\n}\n\nstatic void DualColCPUsMeter_draw(Meter* this, int x, int y, int w) {\n   Meter** meters = (Meter**) this->drawData;\n   int start, count;\n   int pad = this->pl->settings->headerMargin ? 2 : 0;\n   AllCPUsMeter_getRange(this, &start, &count);\n   int height = (count+1)/2;\n   int startY = y;\n   for (int i = 0; i < height; i++) {\n      meters[i]->draw(meters[i], x, y, (w-pad)/2);\n      y += meters[i]->h;\n   }\n   y = startY;\n   for (int i = height; i < count; i++) {\n      meters[i]->draw(meters[i], x+(w-1)/2+1+(pad/2), y, (w-pad)/2);\n      y += meters[i]->h;\n   }\n}\n\nstatic void SingleColCPUsMeter_draw(Meter* this, int x, int y, int w) {\n   Meter** meters = (Meter**) this->drawData;\n   int start, count;\n   AllCPUsMeter_getRange(this, &start, &count);\n   for (int i = 0; i < count; i++) {\n      meters[i]->draw(meters[i], x, y, w);\n      y += meters[i]->h;\n   }\n}\n\nMeterClass CPUMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .updateValues = CPUMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .maxItems = CPU_METER_ITEMCOUNT,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes, \n   .name = \"CPU\",\n   .uiName = \"CPU\",\n   .caption = \"CPU\",\n   .init = CPUMeter_init\n};\n\nMeterClass AllCPUsMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .defaultMode = CUSTOM_METERMODE,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes, \n   .name = \"AllCPUs\",\n   .uiName = \"CPUs (1/1)\",\n   .description = \"CPUs (1/1): all CPUs\",\n   .caption = \"CPU\",\n   .draw = SingleColCPUsMeter_draw,\n   .init = AllCPUsMeter_init,\n   .updateMode = AllCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nMeterClass AllCPUs2Meter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .defaultMode = CUSTOM_METERMODE,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes, \n   .name = \"AllCPUs2\",\n   .uiName = \"CPUs (1&2/2)\",\n   .description = \"CPUs (1&2/2): all CPUs in 2 shorter columns\",\n   .caption = \"CPU\",\n   .draw = DualColCPUsMeter_draw,\n   .init = AllCPUsMeter_init,\n   .updateMode = AllCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nMeterClass LeftCPUsMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .defaultMode = CUSTOM_METERMODE,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes, \n   .name = \"LeftCPUs\",\n   .uiName = \"CPUs (1/2)\",\n   .description = \"CPUs (1/2): first half of list\",\n   .caption = \"CPU\",\n   .draw = SingleColCPUsMeter_draw,\n   .init = AllCPUsMeter_init,\n   .updateMode = AllCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nMeterClass RightCPUsMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .defaultMode = CUSTOM_METERMODE,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes, \n   .name = \"RightCPUs\",\n   .uiName = \"CPUs (2/2)\",\n   .description = \"CPUs (2/2): second half of list\",\n   .caption = \"CPU\",\n   .draw = SingleColCPUsMeter_draw,\n   .init = AllCPUsMeter_init,\n   .updateMode = AllCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nMeterClass LeftCPUs2Meter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .defaultMode = CUSTOM_METERMODE,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes, \n   .name = \"LeftCPUs2\",\n   .uiName = \"CPUs (1&2/4)\",\n   .description = \"CPUs (1&2/4): first half in 2 shorter columns\",\n   .caption = \"CPU\",\n   .draw = DualColCPUsMeter_draw,\n   .init = AllCPUsMeter_init,\n   .updateMode = AllCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\nMeterClass RightCPUs2Meter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = CPUMeter_display\n   },\n   .defaultMode = CUSTOM_METERMODE,\n   .total = 100.0,\n   .attributes = CPUMeter_attributes, \n   .name = \"RightCPUs2\",\n   .uiName = \"CPUs (3&4/4)\",\n   .description = \"CPUs (3&4/4): second half in 2 shorter columns\",\n   .caption = \"CPU\",\n   .draw = DualColCPUsMeter_draw,\n   .init = AllCPUsMeter_init,\n   .updateMode = AllCPUsMeter_updateMode,\n   .done = AllCPUsMeter_done\n};\n\n"
        },
        {
          "name": "CPUMeter.h",
          "type": "blob",
          "size": 0.98046875,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_CPUMeter\n#define HEADER_CPUMeter\n/*\nhtop - CPUMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\ntypedef enum {\n   CPU_METER_NICE = 0,\n   CPU_METER_NORMAL = 1,\n   CPU_METER_KERNEL = 2,\n   CPU_METER_IRQ = 3,\n   CPU_METER_SOFTIRQ = 4,\n   CPU_METER_STEAL = 5,\n   CPU_METER_GUEST = 6,\n   CPU_METER_IOWAIT = 7,\n   CPU_METER_ITEMCOUNT = 8, // number of entries in this enum\n} CPUMeterValues;\n\n\nextern int CPUMeter_attributes[];\n\n#ifndef MIN\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#endif\n#ifndef MAX\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#endif\n\nextern MeterClass CPUMeter_class;\n\nextern MeterClass AllCPUsMeter_class;\n\nextern MeterClass AllCPUs2Meter_class;\n\nextern MeterClass LeftCPUsMeter_class;\n\nextern MeterClass RightCPUsMeter_class;\n\nextern MeterClass LeftCPUs2Meter_class;\n\nextern MeterClass RightCPUs2Meter_class;\n\n\n#endif\n"
        },
        {
          "name": "CRT.c",
          "type": "blob",
          "size": 23.63671875,
          "content": "/*\nhtop - CRT.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\"\n#include \"CRT.h\"\n\n#include \"StringUtils.h\"\n#include \"RichString.h\"\n\n#include <stdio.h>\n#include <errno.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <locale.h>\n#include <langinfo.h>\n#if HAVE_SETUID_ENABLED\n#include <unistd.h>\n#include <sys/types.h>\n#endif\n\n#define ColorIndex(i,j) ((7-i)*8+j)\n\n#define ColorPair(i,j) COLOR_PAIR(ColorIndex(i,j))\n\n#define Black COLOR_BLACK\n#define Red COLOR_RED\n#define Green COLOR_GREEN\n#define Yellow COLOR_YELLOW\n#define Blue COLOR_BLUE\n#define Magenta COLOR_MAGENTA\n#define Cyan COLOR_CYAN\n#define White COLOR_WHITE\n\n#define ColorPairGrayBlack ColorPair(Magenta,Magenta)\n#define ColorIndexGrayBlack ColorIndex(Magenta,Magenta)\n\n#define KEY_WHEELUP KEY_F(20)\n#define KEY_WHEELDOWN KEY_F(21)\n#define KEY_RECLICK KEY_F(22)\n\n//#link curses\n\n/*{\n#include <stdbool.h>\n\ntypedef enum TreeStr_ {\n   TREE_STR_HORZ,\n   TREE_STR_VERT,\n   TREE_STR_RTEE,\n   TREE_STR_BEND,\n   TREE_STR_TEND,\n   TREE_STR_OPEN,\n   TREE_STR_SHUT,\n   TREE_STR_COUNT\n} TreeStr;\n\ntypedef enum ColorSchemes_ {\n   COLORSCHEME_DEFAULT = 0,\n   COLORSCHEME_MONOCHROME = 1,\n   COLORSCHEME_BLACKONWHITE = 2,\n   COLORSCHEME_LIGHTTERMINAL = 3,\n   COLORSCHEME_MIDNIGHT = 4,\n   COLORSCHEME_BLACKNIGHT = 5,\n   COLORSCHEME_BROKENGRAY = 6,\n   LAST_COLORSCHEME = 7,\n} ColorSchemes;\n\ntypedef enum ColorElements_ {\n   RESET_COLOR,\n   DEFAULT_COLOR,\n   FUNCTION_BAR,\n   FUNCTION_KEY,\n   FAILED_SEARCH,\n   PANEL_HEADER_FOCUS,\n   PANEL_HEADER_UNFOCUS,\n   PANEL_SELECTION_FOCUS,\n   PANEL_SELECTION_FOLLOW,\n   PANEL_SELECTION_UNFOCUS,\n   LARGE_NUMBER,\n   METER_TEXT,\n   METER_VALUE,\n   LED_COLOR,\n   UPTIME,\n   BATTERY,\n   TASKS_RUNNING,\n   SWAP,\n   PROCESS,\n   PROCESS_SHADOW,\n   PROCESS_TAG,\n   PROCESS_MEGABYTES,\n   PROCESS_TREE,\n   PROCESS_R_STATE,\n   PROCESS_D_STATE,\n   PROCESS_BASENAME,\n   PROCESS_HIGH_PRIORITY,\n   PROCESS_LOW_PRIORITY,\n   PROCESS_THREAD,\n   PROCESS_THREAD_BASENAME,\n   BAR_BORDER,\n   BAR_SHADOW,\n   GRAPH_1,\n   GRAPH_2,\n   MEMORY_USED,\n   MEMORY_BUFFERS,\n   MEMORY_BUFFERS_TEXT,\n   MEMORY_CACHE,\n   LOAD,\n   LOAD_AVERAGE_FIFTEEN,\n   LOAD_AVERAGE_FIVE,\n   LOAD_AVERAGE_ONE,\n   CHECK_BOX,\n   CHECK_MARK,\n   CHECK_TEXT,\n   CLOCK,\n   HELP_BOLD,\n   HOSTNAME,\n   CPU_NICE,\n   CPU_NICE_TEXT,\n   CPU_NORMAL,\n   CPU_KERNEL,\n   CPU_IOWAIT,\n   CPU_IRQ,\n   CPU_SOFTIRQ,\n   CPU_STEAL,\n   CPU_GUEST,\n   LAST_COLORELEMENT\n} ColorElements;\n\nvoid CRT_fatalError(const char* note) __attribute__ ((noreturn));\n\nvoid CRT_handleSIGSEGV(int sgn);\n\n#define KEY_ALT(x) (KEY_F(64 - 26) + (x - 'A'))\n\n}*/\n\nconst char *CRT_treeStrAscii[TREE_STR_COUNT] = {\n   \"-\", // TREE_STR_HORZ\n   \"|\", // TREE_STR_VERT\n   \"`\", // TREE_STR_RTEE\n   \"`\", // TREE_STR_BEND\n   \",\", // TREE_STR_TEND\n   \"+\", // TREE_STR_OPEN\n   \"-\", // TREE_STR_SHUT\n};\n\n#ifdef HAVE_LIBNCURSESW\n\nconst char *CRT_treeStrUtf8[TREE_STR_COUNT] = {\n   \"\\xe2\\x94\\x80\", // TREE_STR_HORZ \n   \"\\xe2\\x94\\x82\", // TREE_STR_VERT \n   \"\\xe2\\x94\\x9c\", // TREE_STR_RTEE \n   \"\\xe2\\x94\\x94\", // TREE_STR_BEND \n   \"\\xe2\\x94\\x8c\", // TREE_STR_TEND \n   \"+\",            // TREE_STR_OPEN +\n   \"\\xe2\\x94\\x80\", // TREE_STR_SHUT \n};\n\nbool CRT_utf8 = false;\n\n#endif\n\nconst char **CRT_treeStr = CRT_treeStrAscii;\n\nstatic bool CRT_hasColors;\n\nint CRT_delay = 0;\n\nint* CRT_colors;\n\nint CRT_colorSchemes[LAST_COLORSCHEME][LAST_COLORELEMENT] = {\n   [COLORSCHEME_DEFAULT] = {\n      [RESET_COLOR] = ColorPair(White,Black),\n      [DEFAULT_COLOR] = ColorPair(White,Black),\n      [FUNCTION_BAR] = ColorPair(Black,Cyan),\n      [FUNCTION_KEY] = ColorPair(White,Black),\n      [PANEL_HEADER_FOCUS] = ColorPair(Black,Green),\n      [PANEL_HEADER_UNFOCUS] = ColorPair(Black,Green),\n      [PANEL_SELECTION_FOCUS] = ColorPair(Black,Cyan),\n      [PANEL_SELECTION_FOLLOW] = ColorPair(Black,Yellow),\n      [PANEL_SELECTION_UNFOCUS] = ColorPair(Black,White),\n      [FAILED_SEARCH] = ColorPair(Red,Cyan),\n      [UPTIME] = A_BOLD | ColorPair(Cyan,Black),\n      [BATTERY] = A_BOLD | ColorPair(Cyan,Black),\n      [LARGE_NUMBER] = A_BOLD | ColorPair(Red,Black),\n      [METER_TEXT] = ColorPair(Cyan,Black),\n      [METER_VALUE] = A_BOLD | ColorPair(Cyan,Black),\n      [LED_COLOR] = ColorPair(Green,Black),\n      [TASKS_RUNNING] = A_BOLD | ColorPair(Green,Black),\n      [PROCESS] = A_NORMAL,\n      [PROCESS_SHADOW] = A_BOLD | ColorPairGrayBlack,\n      [PROCESS_TAG] = A_BOLD | ColorPair(Yellow,Black),\n      [PROCESS_MEGABYTES] = ColorPair(Cyan,Black),\n      [PROCESS_BASENAME] = A_BOLD | ColorPair(Cyan,Black),\n      [PROCESS_TREE] = ColorPair(Cyan,Black),\n      [PROCESS_R_STATE] = ColorPair(Green,Black),\n      [PROCESS_D_STATE] = A_BOLD | ColorPair(Red,Black),\n      [PROCESS_HIGH_PRIORITY] = ColorPair(Red,Black),\n      [PROCESS_LOW_PRIORITY] = ColorPair(Green,Black),\n      [PROCESS_THREAD] = ColorPair(Green,Black),\n      [PROCESS_THREAD_BASENAME] = A_BOLD | ColorPair(Green,Black),\n      [BAR_BORDER] = A_BOLD,\n      [BAR_SHADOW] = A_BOLD | ColorPairGrayBlack,\n      [SWAP] = ColorPair(Red,Black),\n      [GRAPH_1] = A_BOLD | ColorPair(Cyan,Black),\n      [GRAPH_2] = ColorPair(Cyan,Black),\n      [MEMORY_USED] = ColorPair(Green,Black),\n      [MEMORY_BUFFERS] = ColorPair(Blue,Black),\n      [MEMORY_BUFFERS_TEXT] = A_BOLD | ColorPair(Blue,Black),\n      [MEMORY_CACHE] = ColorPair(Yellow,Black),\n      [LOAD_AVERAGE_FIFTEEN] = ColorPair(Cyan,Black),\n      [LOAD_AVERAGE_FIVE] = A_BOLD | ColorPair(Cyan,Black),\n      [LOAD_AVERAGE_ONE] = A_BOLD | ColorPair(White,Black),\n      [LOAD] = A_BOLD,\n      [HELP_BOLD] = A_BOLD | ColorPair(Cyan,Black),\n      [CLOCK] = A_BOLD,\n      [CHECK_BOX] = ColorPair(Cyan,Black),\n      [CHECK_MARK] = A_BOLD,\n      [CHECK_TEXT] = A_NORMAL,\n      [HOSTNAME] = A_BOLD,\n      [CPU_NICE] = ColorPair(Blue,Black),\n      [CPU_NICE_TEXT] = A_BOLD | ColorPair(Blue,Black),\n      [CPU_NORMAL] = ColorPair(Green,Black),\n      [CPU_KERNEL] = ColorPair(Red,Black),\n      [CPU_IOWAIT] = A_BOLD | ColorPair(Black, Black),\n      [CPU_IRQ] = ColorPair(Yellow,Black),\n      [CPU_SOFTIRQ] = ColorPair(Magenta,Black),\n      [CPU_STEAL] = ColorPair(Cyan,Black),\n      [CPU_GUEST] = ColorPair(Cyan,Black),\n   },\n   [COLORSCHEME_MONOCHROME] = {\n      [RESET_COLOR] = A_NORMAL,\n      [DEFAULT_COLOR] = A_NORMAL,\n      [FUNCTION_BAR] = A_REVERSE,\n      [FUNCTION_KEY] = A_NORMAL,\n      [PANEL_HEADER_FOCUS] = A_REVERSE,\n      [PANEL_HEADER_UNFOCUS] = A_REVERSE,\n      [PANEL_SELECTION_FOCUS] = A_REVERSE,\n      [PANEL_SELECTION_FOLLOW] = A_REVERSE,\n      [PANEL_SELECTION_UNFOCUS] = A_BOLD,\n      [FAILED_SEARCH] = A_REVERSE | A_BOLD,\n      [UPTIME] = A_BOLD,\n      [BATTERY] = A_BOLD,\n      [LARGE_NUMBER] = A_BOLD,\n      [METER_TEXT] = A_NORMAL,\n      [METER_VALUE] = A_BOLD,\n      [LED_COLOR] = A_NORMAL,\n      [TASKS_RUNNING] = A_BOLD,\n      [PROCESS] = A_NORMAL,\n      [PROCESS_SHADOW] = A_DIM,\n      [PROCESS_TAG] = A_BOLD,\n      [PROCESS_MEGABYTES] = A_BOLD,\n      [PROCESS_BASENAME] = A_BOLD,\n      [PROCESS_TREE] = A_BOLD,\n      [PROCESS_R_STATE] = A_BOLD,\n      [PROCESS_D_STATE] = A_BOLD,\n      [PROCESS_HIGH_PRIORITY] = A_BOLD,\n      [PROCESS_LOW_PRIORITY] = A_DIM,\n      [PROCESS_THREAD] = A_BOLD,\n      [PROCESS_THREAD_BASENAME] = A_REVERSE,\n      [BAR_BORDER] = A_BOLD,\n      [BAR_SHADOW] = A_DIM,\n      [SWAP] = A_BOLD,\n      [GRAPH_1] = A_BOLD,\n      [GRAPH_2] = A_NORMAL,\n      [MEMORY_USED] = A_BOLD,\n      [MEMORY_BUFFERS] = A_NORMAL,\n      [MEMORY_BUFFERS_TEXT] = A_NORMAL,\n      [MEMORY_CACHE] = A_NORMAL,\n      [LOAD_AVERAGE_FIFTEEN] = A_DIM,\n      [LOAD_AVERAGE_FIVE] = A_NORMAL,\n      [LOAD_AVERAGE_ONE] = A_BOLD,\n      [LOAD] = A_BOLD,\n      [HELP_BOLD] = A_BOLD,\n      [CLOCK] = A_BOLD,\n      [CHECK_BOX] = A_BOLD,\n      [CHECK_MARK] = A_NORMAL,\n      [CHECK_TEXT] = A_NORMAL,\n      [HOSTNAME] = A_BOLD,\n      [CPU_NICE] = A_NORMAL,\n      [CPU_NICE_TEXT] = A_NORMAL,\n      [CPU_NORMAL] = A_BOLD,\n      [CPU_KERNEL] = A_BOLD,\n      [CPU_IOWAIT] = A_NORMAL,\n      [CPU_IRQ] = A_BOLD,\n      [CPU_SOFTIRQ] = A_BOLD,\n      [CPU_STEAL] = A_REVERSE,\n      [CPU_GUEST] = A_REVERSE,\n   },\n   [COLORSCHEME_BLACKONWHITE] = {\n      [RESET_COLOR] = ColorPair(Black,White),\n      [DEFAULT_COLOR] = ColorPair(Black,White),\n      [FUNCTION_BAR] = ColorPair(Black,Cyan),\n      [FUNCTION_KEY] = ColorPair(Black,White),\n      [PANEL_HEADER_FOCUS] = ColorPair(Black,Green),\n      [PANEL_HEADER_UNFOCUS] = ColorPair(Black,Green),\n      [PANEL_SELECTION_FOCUS] = ColorPair(Black,Cyan),\n      [PANEL_SELECTION_FOLLOW] = ColorPair(Black,Yellow),\n      [PANEL_SELECTION_UNFOCUS] = ColorPair(Blue,White),\n      [FAILED_SEARCH] = ColorPair(Red,Cyan),\n      [UPTIME] = ColorPair(Yellow,White),\n      [BATTERY] = ColorPair(Yellow,White),\n      [LARGE_NUMBER] = ColorPair(Red,White),\n      [METER_TEXT] = ColorPair(Blue,White),\n      [METER_VALUE] = ColorPair(Black,White),\n      [LED_COLOR] = ColorPair(Green,White),\n      [TASKS_RUNNING] = ColorPair(Green,White),\n      [PROCESS] = ColorPair(Black,White),\n      [PROCESS_SHADOW] = A_BOLD | ColorPair(Black,White),\n      [PROCESS_TAG] = ColorPair(White,Blue),\n      [PROCESS_MEGABYTES] = ColorPair(Blue,White),\n      [PROCESS_BASENAME] = ColorPair(Blue,White),\n      [PROCESS_TREE] = ColorPair(Green,White),\n      [PROCESS_R_STATE] = ColorPair(Green,White),\n      [PROCESS_D_STATE] = A_BOLD | ColorPair(Red,White),\n      [PROCESS_HIGH_PRIORITY] = ColorPair(Red,White),\n      [PROCESS_LOW_PRIORITY] = ColorPair(Green,White),\n      [PROCESS_THREAD] = ColorPair(Blue,White),\n      [PROCESS_THREAD_BASENAME] = A_BOLD | ColorPair(Blue,White),\n      [BAR_BORDER] = ColorPair(Blue,White),\n      [BAR_SHADOW] = ColorPair(Black,White),\n      [SWAP] = ColorPair(Red,White),\n      [GRAPH_1] = A_BOLD | ColorPair(Blue,White),\n      [GRAPH_2] = ColorPair(Blue,White),\n      [MEMORY_USED] = ColorPair(Green,White),\n      [MEMORY_BUFFERS] = ColorPair(Cyan,White),\n      [MEMORY_BUFFERS_TEXT] = ColorPair(Cyan,White),\n      [MEMORY_CACHE] = ColorPair(Yellow,White),\n      [LOAD_AVERAGE_FIFTEEN] = ColorPair(Black,White),\n      [LOAD_AVERAGE_FIVE] = ColorPair(Black,White),\n      [LOAD_AVERAGE_ONE] = ColorPair(Black,White),\n      [LOAD] = ColorPair(Black,White),\n      [HELP_BOLD] = ColorPair(Blue,White),\n      [CLOCK] = ColorPair(Black,White),\n      [CHECK_BOX] = ColorPair(Blue,White),\n      [CHECK_MARK] = ColorPair(Black,White),\n      [CHECK_TEXT] = ColorPair(Black,White),\n      [HOSTNAME] = ColorPair(Black,White),\n      [CPU_NICE] = ColorPair(Cyan,White),\n      [CPU_NICE_TEXT] = ColorPair(Cyan,White),\n      [CPU_NORMAL] = ColorPair(Green,White),\n      [CPU_KERNEL] = ColorPair(Red,White),\n      [CPU_IOWAIT] = A_BOLD | ColorPair(Black, White),\n      [CPU_IRQ] = ColorPair(Blue,White),\n      [CPU_SOFTIRQ] = ColorPair(Blue,White),\n      [CPU_STEAL] = ColorPair(Cyan,White),\n      [CPU_GUEST] = ColorPair(Cyan,White),\n   },\n   [COLORSCHEME_LIGHTTERMINAL] = {\n      [RESET_COLOR] = ColorPair(Black,Black),\n      [DEFAULT_COLOR] = ColorPair(Black,Black),\n      [FUNCTION_BAR] = ColorPair(Black,Cyan),\n      [FUNCTION_KEY] = ColorPair(Black,Black),\n      [PANEL_HEADER_FOCUS] = ColorPair(Black,Green),\n      [PANEL_HEADER_UNFOCUS] = ColorPair(Black,Green),\n      [PANEL_SELECTION_FOCUS] = ColorPair(Black,Cyan),\n      [PANEL_SELECTION_FOLLOW] = ColorPair(Black,Yellow),\n      [PANEL_SELECTION_UNFOCUS] = ColorPair(Blue,Black),\n      [FAILED_SEARCH] = ColorPair(Red,Cyan),\n      [UPTIME] = ColorPair(Yellow,Black),\n      [BATTERY] = ColorPair(Yellow,Black),\n      [LARGE_NUMBER] = ColorPair(Red,Black),\n      [METER_TEXT] = ColorPair(Blue,Black),\n      [METER_VALUE] = ColorPair(Black,Black),\n      [LED_COLOR] = ColorPair(Green,Black),\n      [TASKS_RUNNING] = ColorPair(Green,Black),\n      [PROCESS] = ColorPair(Black,Black),\n      [PROCESS_SHADOW] = A_BOLD | ColorPairGrayBlack,\n      [PROCESS_TAG] = ColorPair(White,Blue),\n      [PROCESS_MEGABYTES] = ColorPair(Blue,Black),\n      [PROCESS_BASENAME] = ColorPair(Green,Black),\n      [PROCESS_TREE] = ColorPair(Blue,Black),\n      [PROCESS_R_STATE] = ColorPair(Green,Black),\n      [PROCESS_D_STATE] = A_BOLD | ColorPair(Red,Black),\n      [PROCESS_HIGH_PRIORITY] = ColorPair(Red,Black),\n      [PROCESS_LOW_PRIORITY] = ColorPair(Green,Black),\n      [PROCESS_THREAD] = ColorPair(Blue,Black),\n      [PROCESS_THREAD_BASENAME] = A_BOLD | ColorPair(Blue,Black),\n      [BAR_BORDER] = ColorPair(Blue,Black),\n      [BAR_SHADOW] = ColorPairGrayBlack,\n      [SWAP] = ColorPair(Red,Black),\n      [GRAPH_1] = A_BOLD | ColorPair(Cyan,Black),\n      [GRAPH_2] = ColorPair(Cyan,Black),\n      [MEMORY_USED] = ColorPair(Green,Black),\n      [MEMORY_BUFFERS] = ColorPair(Cyan,Black),\n      [MEMORY_BUFFERS_TEXT] = ColorPair(Cyan,Black),\n      [MEMORY_CACHE] = ColorPair(Yellow,Black),\n      [LOAD_AVERAGE_FIFTEEN] = ColorPair(Black,Black),\n      [LOAD_AVERAGE_FIVE] = ColorPair(Black,Black),\n      [LOAD_AVERAGE_ONE] = ColorPair(Black,Black),\n      [LOAD] = ColorPair(White,Black),\n      [HELP_BOLD] = ColorPair(Blue,Black),\n      [CLOCK] = ColorPair(White,Black),\n      [CHECK_BOX] = ColorPair(Blue,Black),\n      [CHECK_MARK] = ColorPair(Black,Black),\n      [CHECK_TEXT] = ColorPair(Black,Black),\n      [HOSTNAME] = ColorPair(White,Black),\n      [CPU_NICE] = ColorPair(Cyan,Black),\n      [CPU_NICE_TEXT] = ColorPair(Cyan,Black),\n      [CPU_NORMAL] = ColorPair(Green,Black),\n      [CPU_KERNEL] = ColorPair(Red,Black),\n      [CPU_IOWAIT] = A_BOLD | ColorPair(Black, Black),\n      [CPU_IRQ] = A_BOLD | ColorPair(Blue,Black),\n      [CPU_SOFTIRQ] = ColorPair(Blue,Black),\n      [CPU_STEAL] = ColorPair(Black,Black),\n      [CPU_GUEST] = ColorPair(Black,Black),\n   },\n   [COLORSCHEME_MIDNIGHT] = {\n      [RESET_COLOR] = ColorPair(White,Blue),\n      [DEFAULT_COLOR] = ColorPair(White,Blue),\n      [FUNCTION_BAR] = ColorPair(Black,Cyan),\n      [FUNCTION_KEY] = A_NORMAL,\n      [PANEL_HEADER_FOCUS] = ColorPair(Black,Cyan),\n      [PANEL_HEADER_UNFOCUS] = ColorPair(Black,Cyan),\n      [PANEL_SELECTION_FOCUS] = ColorPair(Black,White),\n      [PANEL_SELECTION_FOLLOW] = ColorPair(Black,Yellow),\n      [PANEL_SELECTION_UNFOCUS] = A_BOLD | ColorPair(Yellow,Blue),\n      [FAILED_SEARCH] = ColorPair(Red,Cyan),\n      [UPTIME] = A_BOLD | ColorPair(Yellow,Blue),\n      [BATTERY] = A_BOLD | ColorPair(Yellow,Blue),\n      [LARGE_NUMBER] = A_BOLD | ColorPair(Red,Blue),\n      [METER_TEXT] = ColorPair(Cyan,Blue),\n      [METER_VALUE] = A_BOLD | ColorPair(Cyan,Blue),\n      [LED_COLOR] = ColorPair(Green,Blue),\n      [TASKS_RUNNING] = A_BOLD | ColorPair(Green,Blue),\n      [PROCESS] = ColorPair(White,Blue),\n      [PROCESS_SHADOW] = A_BOLD | ColorPair(Black,Blue),\n      [PROCESS_TAG] = A_BOLD | ColorPair(Yellow,Blue),\n      [PROCESS_MEGABYTES] = ColorPair(Cyan,Blue),\n      [PROCESS_BASENAME] = A_BOLD | ColorPair(Cyan,Blue),\n      [PROCESS_TREE] = ColorPair(Cyan,Blue),\n      [PROCESS_R_STATE] = ColorPair(Green,Blue),\n      [PROCESS_D_STATE] = A_BOLD | ColorPair(Red,Blue),\n      [PROCESS_HIGH_PRIORITY] = ColorPair(Red,Blue),\n      [PROCESS_LOW_PRIORITY] = ColorPair(Green,Blue),\n      [PROCESS_THREAD] = ColorPair(Green,Blue),\n      [PROCESS_THREAD_BASENAME] = A_BOLD | ColorPair(Green,Blue),\n      [BAR_BORDER] = A_BOLD | ColorPair(Yellow,Blue),\n      [BAR_SHADOW] = ColorPair(Cyan,Blue),\n      [SWAP] = ColorPair(Red,Blue),\n      [GRAPH_1] = A_BOLD | ColorPair(Cyan,Blue),\n      [GRAPH_2] = ColorPair(Cyan,Blue),\n      [MEMORY_USED] = A_BOLD | ColorPair(Green,Blue),\n      [MEMORY_BUFFERS] = A_BOLD | ColorPair(Cyan,Blue),\n      [MEMORY_BUFFERS_TEXT] = A_BOLD | ColorPair(Cyan,Blue),\n      [MEMORY_CACHE] = A_BOLD | ColorPair(Yellow,Blue),\n      [LOAD_AVERAGE_FIFTEEN] = A_BOLD | ColorPair(Black,Blue),\n      [LOAD_AVERAGE_FIVE] = A_NORMAL | ColorPair(White,Blue),\n      [LOAD_AVERAGE_ONE] = A_BOLD | ColorPair(White,Blue),\n      [LOAD] = A_BOLD | ColorPair(White,Blue),\n      [HELP_BOLD] = A_BOLD | ColorPair(Cyan,Blue),\n      [CLOCK] = ColorPair(White,Blue),\n      [CHECK_BOX] = ColorPair(Cyan,Blue),\n      [CHECK_MARK] = A_BOLD | ColorPair(White,Blue),\n      [CHECK_TEXT] = A_NORMAL | ColorPair(White,Blue),\n      [HOSTNAME] = ColorPair(White,Blue),\n      [CPU_NICE] = A_BOLD | ColorPair(Cyan,Blue),\n      [CPU_NICE_TEXT] = A_BOLD | ColorPair(Cyan,Blue),\n      [CPU_NORMAL] = A_BOLD | ColorPair(Green,Blue),\n      [CPU_KERNEL] = A_BOLD | ColorPair(Red,Blue),\n      [CPU_IOWAIT] = A_BOLD | ColorPair(Blue,Blue),\n      [CPU_IRQ] = A_BOLD | ColorPair(Black,Blue),\n      [CPU_SOFTIRQ] = ColorPair(Black,Blue),\n      [CPU_STEAL] = ColorPair(White,Blue),\n      [CPU_GUEST] = ColorPair(White,Blue),\n   },\n   [COLORSCHEME_BLACKNIGHT] = {\n      [RESET_COLOR] = ColorPair(Cyan,Black),\n      [DEFAULT_COLOR] = ColorPair(Cyan,Black),\n      [FUNCTION_BAR] = ColorPair(Black,Green),\n      [FUNCTION_KEY] = ColorPair(Cyan,Black),\n      [PANEL_HEADER_FOCUS] = ColorPair(Black,Green),\n      [PANEL_HEADER_UNFOCUS] = ColorPair(Black,Green),\n      [PANEL_SELECTION_FOCUS] = ColorPair(Black,Cyan),\n      [PANEL_SELECTION_FOLLOW] = ColorPair(Black,Yellow),\n      [PANEL_SELECTION_UNFOCUS] = ColorPair(Black,White),\n      [FAILED_SEARCH] = ColorPair(Red,Cyan),\n      [UPTIME] = ColorPair(Green,Black),\n      [BATTERY] = ColorPair(Green,Black),\n      [LARGE_NUMBER] = A_BOLD | ColorPair(Red,Black),\n      [METER_TEXT] = ColorPair(Cyan,Black),\n      [METER_VALUE] = ColorPair(Green,Black),\n      [LED_COLOR] = ColorPair(Green,Black),\n      [TASKS_RUNNING] = A_BOLD | ColorPair(Green,Black),\n      [PROCESS] = ColorPair(Cyan,Black),\n      [PROCESS_SHADOW] = A_BOLD | ColorPairGrayBlack,\n      [PROCESS_TAG] = A_BOLD | ColorPair(Yellow,Black),\n      [PROCESS_MEGABYTES] = A_BOLD | ColorPair(Green,Black),\n      [PROCESS_BASENAME] = A_BOLD | ColorPair(Green,Black),\n      [PROCESS_TREE] = ColorPair(Cyan,Black),\n      [PROCESS_THREAD] = ColorPair(Green,Black),\n      [PROCESS_THREAD_BASENAME] = A_BOLD | ColorPair(Blue,Black),\n      [PROCESS_R_STATE] = ColorPair(Green,Black),\n      [PROCESS_D_STATE] = A_BOLD | ColorPair(Red,Black),\n      [PROCESS_HIGH_PRIORITY] = ColorPair(Red,Black),\n      [PROCESS_LOW_PRIORITY] = ColorPair(Green,Black),\n      [BAR_BORDER] = A_BOLD | ColorPair(Green,Black),\n      [BAR_SHADOW] = ColorPair(Cyan,Black),\n      [SWAP] = ColorPair(Red,Black),\n      [GRAPH_1] = A_BOLD | ColorPair(Green,Black),\n      [GRAPH_2] = ColorPair(Green,Black),\n      [MEMORY_USED] = ColorPair(Green,Black),\n      [MEMORY_BUFFERS] = ColorPair(Blue,Black),\n      [MEMORY_BUFFERS_TEXT] = A_BOLD | ColorPair(Blue,Black),\n      [MEMORY_CACHE] = ColorPair(Yellow,Black),\n      [LOAD_AVERAGE_FIFTEEN] = ColorPair(Green,Black),\n      [LOAD_AVERAGE_FIVE] = ColorPair(Green,Black),\n      [LOAD_AVERAGE_ONE] = A_BOLD | ColorPair(Green,Black),\n      [LOAD] = A_BOLD,\n      [HELP_BOLD] = A_BOLD | ColorPair(Cyan,Black),\n      [CLOCK] = ColorPair(Green,Black),\n      [CHECK_BOX] = ColorPair(Green,Black),\n      [CHECK_MARK] = A_BOLD | ColorPair(Green,Black),\n      [CHECK_TEXT] = ColorPair(Cyan,Black),\n      [HOSTNAME] = ColorPair(Green,Black),\n      [CPU_NICE] = ColorPair(Blue,Black),\n      [CPU_NICE_TEXT] = A_BOLD | ColorPair(Blue,Black),\n      [CPU_NORMAL] = ColorPair(Green,Black),\n      [CPU_KERNEL] = ColorPair(Red,Black),\n      [CPU_IOWAIT] = ColorPair(Yellow,Black),\n      [CPU_IRQ] = A_BOLD | ColorPair(Blue,Black),\n      [CPU_SOFTIRQ] = ColorPair(Blue,Black),\n      [CPU_STEAL] = ColorPair(Cyan,Black),\n      [CPU_GUEST] = ColorPair(Cyan,Black),\n   },\n   [COLORSCHEME_BROKENGRAY] = { 0 } // dynamically generated.\n};\n\nint CRT_cursorX = 0;\n\nint CRT_scrollHAmount = 5;\n\nint CRT_scrollWheelVAmount = 10;\n\nchar* CRT_termType;\n\n// TODO move color scheme to Settings, perhaps?\n\nint CRT_colorScheme = 0;\n\nvoid *backtraceArray[128];\n\nstatic void CRT_handleSIGTERM(int sgn) {\n   (void) sgn;\n   CRT_done();\n   exit(0);\n}\n\n#if HAVE_SETUID_ENABLED\n\nstatic int CRT_euid = -1;\n\nstatic int CRT_egid = -1;\n\n#define DIE(msg) do { CRT_done(); fprintf(stderr, msg); exit(1); } while(0)\n\nvoid CRT_dropPrivileges() {\n   CRT_egid = getegid();\n   CRT_euid = geteuid();\n   if (setegid(getgid()) == -1) {\n      DIE(\"Fatal error: failed dropping group privileges.\\n\");\n   }\n   if (seteuid(getuid()) == -1) {\n      DIE(\"Fatal error: failed dropping user privileges.\\n\");\n   }\n}\n\nvoid CRT_restorePrivileges() {\n   if (CRT_egid == -1 || CRT_euid == -1) {\n      DIE(\"Fatal error: internal inconsistency.\\n\");\n   }\n   if (setegid(CRT_egid) == -1) {\n      DIE(\"Fatal error: failed restoring group privileges.\\n\");\n   }\n   if (seteuid(CRT_euid) == -1) {\n      DIE(\"Fatal error: failed restoring user privileges.\\n\");\n   }\n}\n\n#else\n\n/* Turn setuid operations into NOPs */\n\n#ifndef CRT_dropPrivileges\n#define CRT_dropPrivileges()\n#define CRT_restorePrivileges()\n#endif\n\n#endif\n\n// TODO: pass an instance of Settings instead.\n\nvoid CRT_init(int delay, int colorScheme) {\n   initscr();\n   noecho();\n   CRT_delay = delay;\n   if (CRT_delay == 0) {\n      CRT_delay = 1;\n   }\n   CRT_colors = CRT_colorSchemes[colorScheme];\n   CRT_colorScheme = colorScheme;\n   \n   for (int i = 0; i < LAST_COLORELEMENT; i++) {\n      unsigned int color = CRT_colorSchemes[COLORSCHEME_DEFAULT][i];\n      CRT_colorSchemes[COLORSCHEME_BROKENGRAY][i] = color == (A_BOLD | ColorPairGrayBlack) ? ColorPair(White,Black) : color;\n   }\n   \n   halfdelay(CRT_delay);\n   nonl();\n   intrflush(stdscr, false);\n   keypad(stdscr, true);\n   mouseinterval(0);\n   curs_set(0);\n   if (has_colors()) {\n      start_color();\n      CRT_hasColors = true;\n   } else {\n      CRT_hasColors = false;\n   }\n   CRT_termType = getenv(\"TERM\");\n   if (String_eq(CRT_termType, \"linux\"))\n      CRT_scrollHAmount = 20;\n   else\n      CRT_scrollHAmount = 5;\n   if (String_startsWith(CRT_termType, \"xterm\") || String_eq(CRT_termType, \"vt220\")) {\n      define_key(\"\\033[H\", KEY_HOME);\n      define_key(\"\\033[F\", KEY_END);\n      define_key(\"\\033[7~\", KEY_HOME);\n      define_key(\"\\033[8~\", KEY_END);\n      define_key(\"\\033OP\", KEY_F(1));\n      define_key(\"\\033OQ\", KEY_F(2));\n      define_key(\"\\033OR\", KEY_F(3));\n      define_key(\"\\033OS\", KEY_F(4));\n      define_key(\"\\033[11~\", KEY_F(1));\n      define_key(\"\\033[12~\", KEY_F(2));\n      define_key(\"\\033[13~\", KEY_F(3));\n      define_key(\"\\033[14~\", KEY_F(4));\n      define_key(\"\\033[17;2~\", KEY_F(18));\n      char sequence[3] = \"\\033a\";\n      for (char c = 'a'; c <= 'z'; c++) {\n         sequence[1] = c;\n         define_key(sequence, KEY_ALT('A' + (c - 'a')));\n      }\n   }\n#ifndef DEBUG\n   signal(11, CRT_handleSIGSEGV);\n#endif\n   signal(SIGTERM, CRT_handleSIGTERM);\n   signal(SIGQUIT, CRT_handleSIGTERM);\n   use_default_colors();\n   if (!has_colors())\n      CRT_colorScheme = 1;\n   CRT_setColors(CRT_colorScheme);\n\n   /* initialize locale */\n   setlocale(LC_CTYPE, \"\");\n\n#ifdef HAVE_LIBNCURSESW\n   if(strcmp(nl_langinfo(CODESET), \"UTF-8\") == 0)\n      CRT_utf8 = true;\n   else\n      CRT_utf8 = false;\n#endif\n\n   CRT_treeStr =\n#ifdef HAVE_LIBNCURSESW\n      CRT_utf8 ? CRT_treeStrUtf8 :\n#endif\n      CRT_treeStrAscii;\n\n#if NCURSES_MOUSE_VERSION > 1\n   mousemask(BUTTON1_RELEASED | BUTTON4_PRESSED | BUTTON5_PRESSED, NULL);\n#else\n   mousemask(BUTTON1_RELEASED, NULL);\n#endif\n\n}\n\nvoid CRT_done() {\n   curs_set(1);\n   endwin();\n}\n\nvoid CRT_fatalError(const char* note) {\n   char* sysMsg = strerror(errno);\n   CRT_done();\n   fprintf(stderr, \"%s: %s\\n\", note, sysMsg);\n   exit(2);\n}\n\nint CRT_readKey() {\n   nocbreak();\n   cbreak();\n   nodelay(stdscr, FALSE);\n   int ret = getch();\n   halfdelay(CRT_delay);\n   return ret;\n}\n\nvoid CRT_disableDelay() {\n   nocbreak();\n   cbreak();\n   nodelay(stdscr, TRUE);\n}\n\nvoid CRT_enableDelay() {\n   halfdelay(CRT_delay);\n}\n\nvoid CRT_setColors(int colorScheme) {\n   CRT_colorScheme = colorScheme;\n\n   for (int i = 0; i < 8; i++) {\n      for (int j = 0; j < 8; j++) {\n         if (ColorIndex(i,j) != ColorPairGrayBlack) {\n            int bg = (colorScheme != COLORSCHEME_BLACKNIGHT)\n                     ? (j==0 ? -1 : j)\n                     : j;\n            init_pair(ColorIndex(i,j), i, bg);\n         }\n      }\n   }\n\n   int grayBlackFg = COLORS > 8 ? 8 : 0;\n   int grayBlackBg = (colorScheme != COLORSCHEME_BLACKNIGHT)\n                     ? -1\n                     : 0;\n   init_pair(ColorIndexGrayBlack, grayBlackFg, grayBlackBg);\n\n   CRT_colors = CRT_colorSchemes[colorScheme];\n}\n"
        },
        {
          "name": "CRT.h",
          "type": "blob",
          "size": 3.515625,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_CRT\n#define HEADER_CRT\n/*\nhtop - CRT.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#if HAVE_SETUID_ENABLED\n#endif\n\n#define ColorIndex(i,j) ((7-i)*8+j)\n\n#define ColorPair(i,j) COLOR_PAIR(ColorIndex(i,j))\n\n#define Black COLOR_BLACK\n#define Red COLOR_RED\n#define Green COLOR_GREEN\n#define Yellow COLOR_YELLOW\n#define Blue COLOR_BLUE\n#define Magenta COLOR_MAGENTA\n#define Cyan COLOR_CYAN\n#define White COLOR_WHITE\n\n#define ColorPairGrayBlack ColorPair(Magenta,Magenta)\n#define ColorIndexGrayBlack ColorIndex(Magenta,Magenta)\n\n#define KEY_WHEELUP KEY_F(20)\n#define KEY_WHEELDOWN KEY_F(21)\n#define KEY_RECLICK KEY_F(22)\n\n//#link curses\n\n#include <stdbool.h>\n\ntypedef enum TreeStr_ {\n   TREE_STR_HORZ,\n   TREE_STR_VERT,\n   TREE_STR_RTEE,\n   TREE_STR_BEND,\n   TREE_STR_TEND,\n   TREE_STR_OPEN,\n   TREE_STR_SHUT,\n   TREE_STR_COUNT\n} TreeStr;\n\ntypedef enum ColorSchemes_ {\n   COLORSCHEME_DEFAULT = 0,\n   COLORSCHEME_MONOCHROME = 1,\n   COLORSCHEME_BLACKONWHITE = 2,\n   COLORSCHEME_LIGHTTERMINAL = 3,\n   COLORSCHEME_MIDNIGHT = 4,\n   COLORSCHEME_BLACKNIGHT = 5,\n   COLORSCHEME_BROKENGRAY = 6,\n   LAST_COLORSCHEME = 7,\n} ColorSchemes;\n\ntypedef enum ColorElements_ {\n   RESET_COLOR,\n   DEFAULT_COLOR,\n   FUNCTION_BAR,\n   FUNCTION_KEY,\n   FAILED_SEARCH,\n   PANEL_HEADER_FOCUS,\n   PANEL_HEADER_UNFOCUS,\n   PANEL_SELECTION_FOCUS,\n   PANEL_SELECTION_FOLLOW,\n   PANEL_SELECTION_UNFOCUS,\n   LARGE_NUMBER,\n   METER_TEXT,\n   METER_VALUE,\n   LED_COLOR,\n   UPTIME,\n   BATTERY,\n   TASKS_RUNNING,\n   SWAP,\n   PROCESS,\n   PROCESS_SHADOW,\n   PROCESS_TAG,\n   PROCESS_MEGABYTES,\n   PROCESS_TREE,\n   PROCESS_R_STATE,\n   PROCESS_D_STATE,\n   PROCESS_BASENAME,\n   PROCESS_HIGH_PRIORITY,\n   PROCESS_LOW_PRIORITY,\n   PROCESS_THREAD,\n   PROCESS_THREAD_BASENAME,\n   BAR_BORDER,\n   BAR_SHADOW,\n   GRAPH_1,\n   GRAPH_2,\n   MEMORY_USED,\n   MEMORY_BUFFERS,\n   MEMORY_BUFFERS_TEXT,\n   MEMORY_CACHE,\n   LOAD,\n   LOAD_AVERAGE_FIFTEEN,\n   LOAD_AVERAGE_FIVE,\n   LOAD_AVERAGE_ONE,\n   CHECK_BOX,\n   CHECK_MARK,\n   CHECK_TEXT,\n   CLOCK,\n   HELP_BOLD,\n   HOSTNAME,\n   CPU_NICE,\n   CPU_NICE_TEXT,\n   CPU_NORMAL,\n   CPU_KERNEL,\n   CPU_IOWAIT,\n   CPU_IRQ,\n   CPU_SOFTIRQ,\n   CPU_STEAL,\n   CPU_GUEST,\n   LAST_COLORELEMENT\n} ColorElements;\n\nvoid CRT_fatalError(const char* note) __attribute__ ((noreturn));\n\nvoid CRT_handleSIGSEGV(int sgn);\n\n#define KEY_ALT(x) (KEY_F(64 - 26) + (x - 'A'))\n\n\nextern const char *CRT_treeStrAscii[TREE_STR_COUNT];\n\n#ifdef HAVE_LIBNCURSESW\n\nextern const char *CRT_treeStrUtf8[TREE_STR_COUNT];\n\nextern bool CRT_utf8;\n\n#endif\n\nextern const char **CRT_treeStr;\n\nextern int CRT_delay;\n\nint* CRT_colors;\n\nextern int CRT_colorSchemes[LAST_COLORSCHEME][LAST_COLORELEMENT];\n\nextern int CRT_cursorX;\n\nextern int CRT_scrollHAmount;\n\nextern int CRT_scrollWheelVAmount;\n\nchar* CRT_termType;\n\n// TODO move color scheme to Settings, perhaps?\n\nextern int CRT_colorScheme;\n\nvoid *backtraceArray[128];\n\n#if HAVE_SETUID_ENABLED\n\n#define DIE(msg) do { CRT_done(); fprintf(stderr, msg); exit(1); } while(0)\n\nvoid CRT_dropPrivileges();\n\nvoid CRT_restorePrivileges();\n\n#else\n\n/* Turn setuid operations into NOPs */\n\n#ifndef CRT_dropPrivileges\n#define CRT_dropPrivileges()\n#define CRT_restorePrivileges()\n#endif\n\n#endif\n\n// TODO: pass an instance of Settings instead.\n\nvoid CRT_init(int delay, int colorScheme);\n\nvoid CRT_done();\n\nvoid CRT_fatalError(const char* note);\n\nint CRT_readKey();\n\nvoid CRT_disableDelay();\n\nvoid CRT_enableDelay();\n\nvoid CRT_setColors(int colorScheme);\n\n#endif\n"
        },
        {
          "name": "CategoriesPanel.c",
          "type": "blob",
          "size": 4.685546875,
          "content": "/*\nhtop - CategoriesPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"CategoriesPanel.h\"\n\n#include \"AvailableMetersPanel.h\"\n#include \"MetersPanel.h\"\n#include \"DisplayOptionsPanel.h\"\n#include \"ColumnsPanel.h\"\n#include \"ColorsPanel.h\"\n#include \"AvailableColumnsPanel.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n\n/*{\n#include \"Panel.h\"\n#include \"Settings.h\"\n#include \"ScreenManager.h\"\n#include \"ProcessList.h\"\n\ntypedef struct CategoriesPanel_ {\n   Panel super;\n   ScreenManager* scr;\n\n   Settings* settings;\n   Header* header;\n   ProcessList* pl;\n} CategoriesPanel;\n\n}*/\n\nstatic const char* const CategoriesFunctions[] = {\"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"Done  \", NULL};\n\nstatic void CategoriesPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   CategoriesPanel* this = (CategoriesPanel*) object;\n   Panel_done(super);\n   free(this);\n}\n\nvoid CategoriesPanel_makeMetersPage(CategoriesPanel* this) {\n   MetersPanel* leftMeters = MetersPanel_new(this->settings, \"Left column\", this->header->columns[0], this->scr);\n   MetersPanel* rightMeters = MetersPanel_new(this->settings, \"Right column\", this->header->columns[1], this->scr);\n   leftMeters->rightNeighbor = rightMeters;\n   rightMeters->leftNeighbor = leftMeters;\n   Panel* availableMeters = (Panel*) AvailableMetersPanel_new(this->settings, this->header, (Panel*) leftMeters, (Panel*) rightMeters, this->scr, this->pl);\n   ScreenManager_add(this->scr, (Panel*) leftMeters, 20);\n   ScreenManager_add(this->scr, (Panel*) rightMeters, 20);\n   ScreenManager_add(this->scr, availableMeters, -1);\n}\n\nstatic void CategoriesPanel_makeDisplayOptionsPage(CategoriesPanel* this) {\n   Panel* displayOptions = (Panel*) DisplayOptionsPanel_new(this->settings, this->scr);\n   ScreenManager_add(this->scr, displayOptions, -1);\n}\n\nstatic void CategoriesPanel_makeColorsPage(CategoriesPanel* this) {\n   Panel* colors = (Panel*) ColorsPanel_new(this->settings, this->scr);\n   ScreenManager_add(this->scr, colors, -1);\n}\n\nstatic void CategoriesPanel_makeColumnsPage(CategoriesPanel* this) {\n   Panel* columns = (Panel*) ColumnsPanel_new(this->settings);\n   Panel* availableColumns = (Panel*) AvailableColumnsPanel_new(columns);\n   ScreenManager_add(this->scr, columns, 20);\n   ScreenManager_add(this->scr, availableColumns, -1);\n}\n\nstatic HandlerResult CategoriesPanel_eventHandler(Panel* super, int ch) {\n   CategoriesPanel* this = (CategoriesPanel*) super;\n\n   HandlerResult result = IGNORED;\n\n   int selected = Panel_getSelectedIndex(super);\n   switch (ch) {\n      case EVENT_SET_SELECTED:\n         result = HANDLED;\n         break;\n      case KEY_UP:\n      case KEY_CTRL('P'):\n      case KEY_DOWN:\n      case KEY_CTRL('N'):\n      case KEY_NPAGE:\n      case KEY_PPAGE:\n      case KEY_HOME:\n      case KEY_END: {\n         int previous = selected;\n         Panel_onKey(super, ch);\n         selected = Panel_getSelectedIndex(super);\n         if (previous != selected)\n            result = HANDLED;\n         break;\n      }\n      default:\n         if (ch < 255 && isalpha(ch))\n            result = Panel_selectByTyping(super, ch);\n         if (result == BREAK_LOOP)\n            result = IGNORED;\n         break;\n   }\n   if (result == HANDLED) {\n      int size = ScreenManager_size(this->scr);\n      for (int i = 1; i < size; i++)\n         ScreenManager_remove(this->scr, 1);\n      switch (selected) {\n         case 0:\n            CategoriesPanel_makeMetersPage(this);\n            break;\n         case 1:\n            CategoriesPanel_makeDisplayOptionsPage(this);\n            break;\n         case 2:\n            CategoriesPanel_makeColorsPage(this);\n            break;\n         case 3:\n            CategoriesPanel_makeColumnsPage(this);\n            break;\n      }\n   }\n   return result;\n}\n\nPanelClass CategoriesPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = CategoriesPanel_delete\n   },\n   .eventHandler = CategoriesPanel_eventHandler\n};\n\nCategoriesPanel* CategoriesPanel_new(ScreenManager* scr, Settings* settings, Header* header, ProcessList* pl) {\n   CategoriesPanel* this = AllocThis(CategoriesPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_new(CategoriesFunctions, NULL, NULL);\n   Panel_init(super, 1, 1, 1, 1, Class(ListItem), true, fuBar);\n\n   this->scr = scr;\n   this->settings = settings;\n   this->header = header;\n   this->pl = pl;\n   Panel_setHeader(super, \"Setup\");\n   Panel_add(super, (Object*) ListItem_new(\"Meters\", 0));\n   Panel_add(super, (Object*) ListItem_new(\"Display options\", 0));\n   Panel_add(super, (Object*) ListItem_new(\"Colors\", 0));\n   Panel_add(super, (Object*) ListItem_new(\"Columns\", 0));\n   return this;\n}\n"
        },
        {
          "name": "CategoriesPanel.h",
          "type": "blob",
          "size": 0.7392578125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_CategoriesPanel\n#define HEADER_CategoriesPanel\n/*\nhtop - CategoriesPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Panel.h\"\n#include \"Settings.h\"\n#include \"ScreenManager.h\"\n#include \"ProcessList.h\"\n\ntypedef struct CategoriesPanel_ {\n   Panel super;\n   ScreenManager* scr;\n\n   Settings* settings;\n   Header* header;\n   ProcessList* pl;\n} CategoriesPanel;\n\n\nvoid CategoriesPanel_makeMetersPage(CategoriesPanel* this);\n\nextern PanelClass CategoriesPanel_class;\n\nCategoriesPanel* CategoriesPanel_new(ScreenManager* scr, Settings* settings, Header* header, ProcessList* pl);\n\n#endif\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 20.6826171875,
          "content": "What's new in version 2.2.0\n\n* Solaris/Illumos/OpenIndiana support\n  (thanks to Guy M. Broome)\n* -t/--tree flag for starting in tree-view mode\n  (thanks to Daniel Flanagan)\n* macOS: detects High Sierra version to avoid OS bug\n  (thanks to Pierre Malhaire)\n* OpenBSD: read battery data\n  (thanks to @nerd972)\n* Various automake and build improvements\n  (thanks to Kang-Che Sung)\n* Check for pkg-config when building with --enable-delayacct\n  (thanks to @florian2833z for the report)\n* Avoid some bashisms in configure script\n  (thanks to Jesin)\n* Use CFLAGS from ncurses*-config if present\n  (thanks to Michael Klein)\n* Header generator supports non-UTF-8 environments\n  (thanks to @volkov-am)\n* Linux: changed detection of kernel threads\n* Collapse current subtree pressing Backspace\n* BUGFIX: fix behavior of SYSCR column\n  (thanks to Marc Kleine-Budde)\n* BUGFIX: obtain exit code of lsof correctly\n  (thanks to @wangqr)\n* BUGFIX: fix crash with particular keycodes\n  (thanks to Wellington Torrejais da Silva for the report)\n* BUGFIX: fix issue with small terminals\n  (thanks to Daniel Elf for the report)\n* BUGFIX: fix terminal color issues\n  (thanks to Kang-Che Sung for the report)\n* BUGFIX: preserve LDFLAGS when building\n  (thanks to Lance Frederickson for the report)\n* BUGFIX: fixed overflow for systems with >= 100 signals\n\nWhat's new in version 2.1.0\n\n* Linux: Delay accounting metrics\n  (thanks to Andr Carvalho)\n* DragonFlyBSD support\n  (thanks to Diederik de Groot)\n* Support for real-time signals\n  (thanks to Kang-Che Sung)\n* 'c' key now works with threads as well\n* Session column renamed from SESN to SID\n  (thanks to Kamyar Rasta)\n* Improved UI for meter style selection\n  (thanks to Kang-Che Sung)\n* Improved code for constructing process tree\n  (thanks to wangqr)\n* Compile-time option to disable setuid\n* Error checking of various standard library operations\n* Replacement of sprintf with snprintf\n  (thanks to Tomasz Kramkowski)\n* Linux: performance improvements in battery meter\n* Linux: update process TTY device\n* Linux: add support for sorting TASK_IDLE\n  (thanks to Vladimir Panteleev)\n* Linux: add upper-bound to running process counter\n  (thanks to Lucas Correia Villa Real)\n* BUGFIX: avoid crash when battery is removed\n  (thanks to Jan Chren)\n* BUGFIX: macOS: fix infinite loop in tree view\n  (thanks to Wataru Ashihara)\n\nWhat's new in version 2.0.2\n\n* Mac OS X: stop trying when task_for_pid fails for a process,\n  stops spamming logs with errors.\n* Add Ctrl+A and Ctrl+E to go to beginning and end of line\n* FreeBSD: fixes for CPU calculation\n  (thanks to Tim Creech, Andy Pilate)\n* Usability: auto-follow process after a search.\n* Use Linux backend on GNU Hurd\n* Improvement for reproducible builds.\n* BUGFIX: Fix behavior of Alt-key combinations\n  (thanks to Kang-Che Sung)\n* Various code tweaks and cleanups\n  (thanks to Kang-Che Sung)\n\nWhat's new in version 2.0.1\n\n* OpenBSD: Various fixes and improvements\n  (thanks to Michael McConville and Juan Francisco Cantero Hurtado)\n* FreeBSD: fix CPU and memory readings\n  (thanks to Tim Creech, Hung-Yi Chen, Bernard Spil, Greg V)\n* FreeBSD: add battery support\n  (thanks to Greg V)\n* Linux: Retain last-obtained name of a zombie process\n* Mac OS X: Improve portability for OS X versions\n  (thanks to Michael Klein)\n* Mac OS X: Fix reading command-line arguments and basename\n* Mac OS X: Fix process state information\n* Mac OS X: Fix tree view collapsing/expanding\n* Mac OS X: Fix tree organization\n* Mac OS X: Fix memory accounting\n* Fix crash when emptying a column of meters\n* Make Esc key more responsive\n\nWhat's new in version 2.0.0\n\n* Platform abstraction layer\n* Initial FreeBSD support\n* Initial Mac OS X support\n  (thanks to David Hunt)\n* Swap meter for Mac OSX\n  (thanks to tefan Rusu)\n* OpenBSD port\n  (thanks to Michael McConville)\n* FreeBSD support improvements\n  (thanks to Martin Misuth)\n* Support for NCurses 6 ABI, including mouse wheel support\n* Much improved mouse responsiveness\n* Process environment variables screen\n  (thanks to Michael Klein)\n* Higher-resolution UTF-8 based Graph mode\n  (Thanks to James Hall from vtop for the idea!)\n* Show program path settings\n  (thanks to Tobias Geerinckx-Rice)\n* BUGFIX: Fix crash when scrolling an empty filtered list.\n* Use dynamic units for text display, and several fixes\n  (thanks to Christian Hesse)\n* BUGFIX: fix error caused by overflow in usertime calculation.\n  (thanks to Patrick Marlier)\n* Catch all memory allocation errors\n  (thanks to Michael McConville for the push)\n* Several tweaks and bugfixes\n  (See the Git log for details and contributors!)\n\nWhat's new in version 1.0.3\n\n* Tag all children ('c' key)\n* Fixes in accounting of guest time when using virtualization\n  (thanks to Patrick Marlier)\n* Performance improvements\n  (thanks to Jann Horn)\n* Further performance improvements due to conditional parsing\n  of IO data depending on selected fields.\n* Better consistency in coloring.\n* Increase limit of buffer when tracing a deep nested process tree.\n* Display pagefault stats.\n* BUGFIX: Fix crash when adding meters and toggling detailed CPU time.\n  (thanks to Dawid Gajownik)\n* Add column to track the OOM-killer score of processes\n  (thanks to Leigh Simpson)\n\nWhat's new in version 1.0.2\n\n* Add IO priority support ('i' key)\n* Avoid deleting .htoprc if it is a symlink\n* Fail gracefully when /proc is not mounted\n  (thanks to Philipp Hagemeister)\n* Option to update process names on every refresh\n  (thanks to Rob Hoelz)\n* BUGFIX: Fix crashes when process list is empty\n\nWhat's new in version 1.0.1\n\n* Move .htoprc to XDG-compliant path ~/.config/htop/htoprc,\n  respecting $XDG_CONFIG_HOME \n  (thanks to Hadzhimurad Ustarkhan for the suggestion.)\n* Safer behavior on the kill screen, to make it harder to kill the wrong process.\n* Fix for building in FreeBSD 8.2\n  (thanks to Trond Endrestol)\n* BUGFIX: behavior of 'F' (follow) key was broken, also affecting the\n  persistence of mouse selections.\n* BUGFIX: keep main panel up-to-date when running the screen manager,\n  to fix crash when processes die while on the F9/Kill screen.\n\nWhat's new in version 1.0\n\n* Performance improvements\n* Support for splitting CPU meters into two or four columns\n  (thanks to Wim Heirman)\n* Switch from PLPA, which is now deprecated, to HWLOC.\n* Bring back support for native Linux sched_setaffinity,\n  so we don't have to use HWLOC where we don't need to.\n* Support for typing in user names and column fields in selection panels.\n* Support for UTF-8 tree drawing\n  (thanks to Bin Guo)\n* Option for counting CPUs from zero\n  (thanks to Sean Noonan)\n* Meters update in every screen (no longer halting while on Setup, etc.)\n* Stricter checks for command-line options\n  (thanks to Sebastian Pipping)\n* Incremental filtering\n  (thanks to Seth Heeren for the idea and initial implementation)\n* Try harder to find the ncurses header\n  (thanks to Moritz Barsnick)\n* Man page updates\n  (thanks to Vincent Launchbury)\n* BUGFIX: Support larger numbers for process times.\n  (thanks to Tristan Nakagawa for the report.)\n* BUGFIX: Segfault in BarMeterMode_draw() for small terminal widths\n  (patch by Sebastian Pipping)\n\nWhat's new in version 0.9\n\n* Add support for \"steal\"/guest CPU time measurement\n  in virtualization environments\n* Expand and collapse subtrees using '+' and '-' when in tree-view\n* Support for cgroups\n  (thanks to Guillaume Zitta and Daniel Lezcano)\n* Show custom thread names\n  (thanks to Anders Torger)\n* Add support for STARTTIME field\n* Upgrade PLPA to version 1.3.2\n* Fix license terms with regard to PLPA\n  (thanks to Tom Callaway)\n* getopt-based long options and --no-color\n  (thanks to Vincent Launchbury)\n* BUGFIX: Fix display of nan% in CPU meters\n  (thanks to Steven Hampson)\n* BUGFIX: Fix memory leak\n  (thanks to Pavol Rusnak)\n* Add Bash/emacs style navigation keys\n  (thanks to Daniel Schuler)\n* Improve battery meter support\n  (thanks to Richard W.)\n* BUGFIX: Fix IO-wait color in \"Black on White\" scheme\n* BUGFIX: Fix search by process name when list is filtered by user.\n  (thanks to Sergej Pupykin for the report.)\n* BUGFIX: Fix alignment for display of memory values above 100G (sign of the times!)\n  (thanks to Jan van Haarst for the report.)\n\nWhat's new in version 0.8.3\n\n* BUGFIX: Fix crash on F6 key\n  (thanks to Rainer Suhm)\n* BUGFIX: Fix a minor bug which affected the build process.\n\nWhat's new in version 0.8.2\n\n* Integrated lsof (press 'l')\n* Fix display of gigabyte-sized values\n  (thanks to Andika Triwidada)\n* Option to display hostname in the meters area\n* Rename VEID to CTID in OpenVZ systems\n  (thanks to Thorsten Schifferdecker)\n* Corrections to the desktop entry file\n  (thanks by Samuli Suominen)\n* BUGFIX: Correct page size calculation for FreeBSD systems\n  (thanks to Andrew Paulsen)\n* Allow compilation without PLPA on systems that don't support it\n  (thanks to Timothy Redaelli)\n* BUGFIX: Fix missing tree view when userland threads are hidden\n  (thanks to Josh Stone)\n* BUGFIX: Fix for VPID on OpenVZ systems\n  (thanks to Wolfgang Frisch)\n\nWhat's new in version 0.8.1\n\n* Linux-VServer support\n  (thanks to Jonathan Sambrook and Benedikt Bohm)\n* Battery meter\n  (thanks to Ian Page Hands)\n* BUGFIX: Fix collection of IO stats in multithreaded processes\n  (thanks to Gerhard Heift)\n* Remove assertion that fails on hardened kernels\n  (thanks to Wolfram Schlich for the report)\n\nWhat's new in version 0.8\n\n* Ability to change sort column with the mouse by\n  clicking column titles (click again to invert order)\n* Add support for Linux per-process IO statistics,\n  enabled with the --enable-taskstats flag, which\n  requires a kernel compiled with taskstats support.\n  (thanks to Tobias Oetiker)\n* Add Unicode support, enabled with the --enable-unicode\n  flag, which requires libncursesw.\n  (thanks to Sergej Pupykin)\n* BUGFIX: Fix display of CPU count for threaded processes.\n  When user threads are hidden, process now shows the\n  sum of processor usage for all processors. When user\n  threads are displayed, each thread shows its own\n  processor usage, including the root thread.\n  (thanks to Bert Wesarg for the report)\n* BUGFIX: avoid crashing when using many meters\n  (thanks to David Cho for the report)\n\nWhat's new in version 0.7\n\n* CPU affinity configuration ('a' key)\n* Improve display of tree view, properly nesting\n  threads of the same app based on TGID.\n* IO-wait time now counts as idle time, which is a more\n  accurate description. It is still available in\n  split time, now called detailed CPU time.\n  (thanks to Samuel Thibault for the report)\n* BUGFIX: Correct display of TPGID field\n* Add TGID field\n* BUGFIX: Don't crash with invalid command-line flags\n  (thanks to Nico Golde for the report)\n* Fix GCC 4.3 compilation issues\n  (thanks to Martin Michlmayr for the report)\n* OpenVZ support, enabled at compile-time with\n  the --enable-openvz flag.\n  (thanks to Sergey Lychko)\n\nWhat's new in version 0.6.6\n\n* Add support of NLWP field\n  (thanks to Bert Wesarg)\n* BUGFIX: Fix use of configurable /proc location\n  (thanks to Florent Thoumie)\n* Fix memory percentage calculation and make it saner\n  (thanks to Olev Kartau for the report)\n* Added display of DRS, DT, LRS and TRS\n  (thanks to Matthias Lederhofer)\n* BUGFIX: LRS and DRS memory values were flipped\n  (thanks to Matthias Lederhofer)\n* BUGFIX: Don't crash on very high UIDs\n  (thanks to Egmont Koblinger)\n\nWhat's new in version 0.6.5\n\n* Add hardened-debug flags for debugging with Hardened GCC\n* BUGFIX: Handle error condition when a directory vanishes\n  from /proc\n* BUGFIX: Fix leak of process command line\n* BUGFIX: Collect orphaned items when arranging the tree view.\n  (thanks to Wolfram Schlich for assistance with debugging)\n* Separate proc and memory debugging into separate #defines.\n* BUGFIX: Fix message when configure fails due to\n  missing libraries\n  (thanks to Jon)\n* BUGFIX: Don't truncate value when displaying a very large\n  process\n  (thanks to Bo Liu)\n\nWhat's new in version 0.6.4\n\n* Add an option to split the display of kernel time\n  in the CPU meter into system, IO-wait, IRQ and soft-IRQ.\n  (thanks to Philipp Richter)\n* --sort-key flag in the command-line, overriding the\n  saved setting in .htoprc for the session.\n  (thanks to Rodolfo Borges)\n* BUGFIX: Fixed string overflow on uptime display.\n  (thanks to Marc Cahalan)\n\nWhat's new in version 0.6.3\n\n* Performance improvements: uses much less CPU than the\n  previous release with the default setup.\n* Use 64-bit values when storing processor times to\n  avoid overflow.\n* Memory consumption improvements, compensating storage\n  of 64-bit values.\n* Internal change: rename TypedVector to Vector and\n  ListBox (and related classes) to Panel.\n* Have configure actually fail when needed libraries or\n  headers are not found.\n* Horizontally scroll in larger increments when on the\n  Linux console because of slow update of unaccelerated fb\n* No longer untag processes after sending a signal\n  (useful for when SIGTERM fails and one wants to try again\n  with SIGKILL). All processes can be untagged at once with 'U'.\n  (thanks to A. Costa for the suggestion)\n\nWhat's new in version 0.6.2\n\n* BUGFIX: Fixed crash when using some .htoprc files from 0.6\n  (thanks to Wolfram Schlich and John Thomas for the reports)\n* BUGFIX: Ensure changes to color scheme are saved\n* BUGFIX: Make configure behave correctly with --with-proc\n* Minor addition to .desktop file.\n\nWhat's new in version 0.6.1\n\n* New meter type: \"All CPUs\", which dynamically adjusts\n  to the number of CPUs present in the machine. Note that\n  because of this, older versions of htop may crash when\n  using an .htoprc file modified my the newer version.\n* Accept --with-proc=<dir> in configure, to specify\n  alternative procfs locations (making htop friendlier\n  to the Linux compatibility layer in FreeBSD)\n* Included icon .desktop and desktop entry\n  (thanks to Peter Hyman)\n* Added a check to make sure that a root-user htop closes\n  when its parent non-root terminal is closed.\n  (thanks to Ilya Evseev for the report)\n* BUGFIX: does not crash anymore when $HOME is not set\n  (thanks to Henning Schild for the report)\n* Wait for strace child process to die properly.\n  (thanks to Marcus Fritzsch)\n* Support $HTOPRC\n  (thanks to Luis Limon)\n\nWhat's new in version 0.6\n\n* Configuration of columns merged into the Setup screen\n* Integrated strace (press 's')\n  (thanks to Marinho Barcellos for the help)\n* BUGFIX: some fixes, aided by Valgrind\n  (thanks to Wolfram Schlich for the report)\n* BUGFIX: fixed bug when switching meter modes\n  (thanks to Eduardo Righes for the report)\n* Show processes of a single user\n* \"SortBy\" function now menu-based\n* Improved mouse handling\n* ...and on top of that reduced memory consumption!\n\nWhat's new in version 0.5.4\n\n* Color schemes\n* -d flag, to configure delay between updates.\n  Note that the delay value is saved in ~/.htoprc.\n* BUGFIX: Update of meters was halting after help screen.\n  (thanks to Matt Moore)\n* BUGFIX: No longer display incorrect information\n  in first frame.\n* BUGFIX: Fix auto-detection of /proc/stat,\n  correcting CPU usage information on multiprocessor\n  systems.\n\nWhat's new in version 0.5.3\n\n* Read new field \"steal\" on newer /proc/stat files\n* Auto-detects format of /proc/stat, to cope\n  with patched 2.4 kernels which display 2.6-style\n  information (most notably those on RHEL 3)\n  (thanks to Fernando Dotta for the report)\n* Support $HOME_ETC initiative\n  (see http://www.pld-linux.org/Docs/home-etc)\n  (thanks to Roman Barczynski for the tip)\n* The configure script now tests for /proc, so\n  that it fails early on unsupported platforms\n  instead of during compilation/execution.\n* Made presentation of the function keys in the\n  status bar consistent across views\n  (thanks to David Mathog for the report)\n* Minor changes to make the codebase more friendly\n  to possible future ports\n  (thanks to Jari Aalto and David Mathog for the reports)\n\nWhat's new in version 0.5.2\n\n* BUGFIX: Correct display of user field\n  (thanks to Marcin Miroslaw for the report)\n* Keyboard support improvements\n  (thanks to Aury Fink Filho for the report)\n\nWhat's new in version 0.5.1\n\n* BUGFIX: Correctly displays NPTL threads from\n  /proc/<pid>/task subdirectories\n  (thanks to Mike Pot for the report)\n* BUGFIX: Fixes key handling on Signals listbox\n  (thanks to Ondrej Vlach)\n* Renicing no longer displays temporary illegal values\n  (thanks to Ondrej Vlach)\n* 'Hide userland threads' feature for NPTL threads\n\nWhat's new in version 0.5\n\n* Tree view\n* New column, TIME (user + system time,\n  like in top, 'T' switches to \"sort by time\")\n* Major reorganization of the underlying code of the\n  setup screen, to manage setup pages\n* New setup page: Display options\n* Hide kernel threads ('K' key)\n* Colorized memory numbers\n* Vastly improved support for monochromatic terminals\n* Shadow processes that do not belong to user ('U' key)\n* Header margin configuration accessible via setup screen\n* Visual feedback on failing incremental search\n* BUGFIX: fixed keyboard input issues on 64-bit machines\n* BUGFIX: hopefully fixed the incorrect values\n  that show on status bars in some systems\n* BUGFIX: doesn't mess with fields list anymore when\n  canceling after changing the number of items\n* Uptime meter no longer says \"1 days\" ;)\n\nWhat's new in version 0.4.1\n\n* BUGFIX: compiles on 64-bit architectures again\n  (thanks to Bartosz Fenski for the report)\n* BUGFIX: multi-processor support fixed on kernels 2.6\n  (thanks to Wolfram Schlich for the report)\n\nWhat's new in version 0.4\n\n* Support for multiple processors!\n* Basic mouse support\n* Modular header based on configurable meters;\n  supports 4 view modes: bar, text, LED, graph\n* Uptime, load average meters\n  (thanks to Marc Calahan)\n* Meters setup screen; should eventually evolve into a\n  general setup screen, with column setup, keybindings, etc.\n* Thread hiding toggleable\n  (press 'T' to hide the nonstandard dotfiles in /proc)\n* BUGFIX: Do not flicker screen on column configuration screen\n* Clock and load average meters\n  (thanks to Marc Calahan)\n* BUGFIX: numeric swap indicator was printing bogus value\n* BUGFIX: internal fixes on Panel widget\n* Clear the bottom line when exiting\n* Press \"F3\" during search to walk through the results\n* Improved navigation on column configuration screen\n* BUGFIX: fix segfault on kernels with restricted /proc\n  enabled\n* BUGFIX: a few last-minute bugfixes in the setup UI\n  (thanks to Gaspare Bruno for the reports)\n\n\nWhat's new in version 0.3.3\n\n* Saves column and sorting configuration in ~/.htoprc\n* Displays \"hidden\" threads on RedHat 9\n  (Thanks to Leonardo Godinho)\n* BUGFIX: supports process names with spaces\n  (Thanks to Marc Calahan)\n* BUGFIX: ...and parentheses :)\n* BUGFIX: long process names overflowed RichString\n  (Thanks to Marc Calahan)\n\nWhat's new in version 0.3.2\n\n* Performance and memory usage improvements, aided by gprof\n* BUGFIX: quite a few fixes, aided by Valgrind\n* Header preview on column configuration screen\n  (Thanks to Marc Calahan)\n\nWhat's new in version 0.3.1\n\n* BUGFIX: crash fixes related to process list handling\n  (thanks to Marc Calahan)\n* Man page\n  (thanks to Bartosz Fenski)\n* Tag processes with the space bar\n* Kill multiple process based on tag\n* BUGFIX: corrected processing order of updates in list\n* Screen refresh function on Ctrl-L\n* Large numbers are shown in MB/GB notation in order to fit screen\n  (thanks to Marc Calahan)\n* Realtime priority is correctly displayed\n  (thanks to Marc Calahan)\n* Preliminary support for configurable columns, with 'C'\n  (thanks to Marc Calahan)\n  -- not all columns display properly yet\n\nWhat's new in version 0.3\n\n* BUGFIX: no dirt left on screen on horizontal scrolling \n* Signal selection on \"kill\" command\n* Color-coding for users, nice and process status\n* \"Follow\" function\n* Fully selectable sort order\n* Function bar on last line\n* Build system now uses autotools\n\nWhat's new in version 0.2.1\n\n* Sorting by process or memory usage ('P' and 'M', like top)\n* Quicker default update (1.5 second, not yet configurable)\n* Now the order of the elements in the process list stay\n  'locked' for a while after you move the cursor to ease\n  selecting a process\n* Corrected the installation instructions in README\n  (Thanks to Jeremy Eglen)\n* Should now compile cleanly on Conectiva 9 and similar systems\n  (Thanks to Adriano Frare for the report)\n* Friendlier Makefile\n* Help screen ('h')\n\nWhat's new in version 0.2\n\n* Memory indicators in header now show used and total, in MB\n* Preliminary support for sorting (CPU% only)\n* Memory percentage field (resident memory / used memory)\n* BUGFIX: identified source of spurious crashes\n* Can search names containing numbers\n  (Thanks to Rafael Jeffman)\n* Correctly calculates memory page size\n  (Thanks to Rafael Jeffman)\n\nWhat's new in version 0.13\n\n* Handles terminal resize\n* Display all user names (not only those in /etc/passwd)\n  (Thanks to Julio Biason)\n\nWhat's new in version 0.12\n\n* Support for 2.6 kernels\n* Uses terminal default colors as a background\n\nWhat's new in version 0.11\n\n* BUGFIX: does not crash when UID is not in /etc/passwd\n\nWhat's new in version 0.1\n\n* Everything!\n"
        },
        {
          "name": "CheckItem.c",
          "type": "blob",
          "size": 1.66015625,
          "content": "/*\nhtop - CheckItem.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"CheckItem.h\"\n\n#include \"CRT.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n\n/*{\n#include \"Object.h\"\n\ntypedef struct CheckItem_ {\n   Object super;\n   char* text;\n   bool* ref;\n   bool value;\n} CheckItem;\n\n}*/\n\nstatic void CheckItem_delete(Object* cast) {\n   CheckItem* this = (CheckItem*)cast;\n   assert (this != NULL);\n\n   free(this->text);\n   free(this);\n}\n\nstatic void CheckItem_display(Object* cast, RichString* out) {\n   CheckItem* this = (CheckItem*)cast;\n   assert (this != NULL);\n   RichString_write(out, CRT_colors[CHECK_BOX], \"[\");\n   if (CheckItem_get(this))\n      RichString_append(out, CRT_colors[CHECK_MARK], \"x\");\n   else\n      RichString_append(out, CRT_colors[CHECK_MARK], \" \");\n   RichString_append(out, CRT_colors[CHECK_BOX], \"] \");\n   RichString_append(out, CRT_colors[CHECK_TEXT], this->text);\n}\n\nObjectClass CheckItem_class = {\n   .display = CheckItem_display,\n   .delete = CheckItem_delete\n};\n\nCheckItem* CheckItem_newByRef(char* text, bool* ref) {\n   CheckItem* this = AllocThis(CheckItem);\n   this->text = text;\n   this->value = false;\n   this->ref = ref;\n   return this;\n}\n\nCheckItem* CheckItem_newByVal(char* text, bool value) {\n   CheckItem* this = AllocThis(CheckItem);\n   this->text = text;\n   this->value = value;\n   this->ref = NULL;\n   return this;\n}\n\nvoid CheckItem_set(CheckItem* this, bool value) {\n   if (this->ref) \n      *(this->ref) = value;\n   else\n      this->value = value;\n}\n\nbool CheckItem_get(CheckItem* this) {\n   if (this->ref) \n      return *(this->ref);\n   else\n      return this->value;\n}\n"
        },
        {
          "name": "CheckItem.h",
          "type": "blob",
          "size": 0.619140625,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_CheckItem\n#define HEADER_CheckItem\n/*\nhtop - CheckItem.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Object.h\"\n\ntypedef struct CheckItem_ {\n   Object super;\n   char* text;\n   bool* ref;\n   bool value;\n} CheckItem;\n\n\nextern ObjectClass CheckItem_class;\n\nCheckItem* CheckItem_newByRef(char* text, bool* ref);\n\nCheckItem* CheckItem_newByVal(char* text, bool value);\n\nvoid CheckItem_set(CheckItem* this, bool value);\n\nbool CheckItem_get(CheckItem* this);\n\n#endif\n"
        },
        {
          "name": "ClockMeter.c",
          "type": "blob",
          "size": 0.880859375,
          "content": "/*\nhtop - ClockMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"ClockMeter.h\"\n\n#include \"CRT.h\"\n\n#include <time.h>\n\n/*{\n#include \"Meter.h\"\n}*/\n\nint ClockMeter_attributes[] = {\n   CLOCK\n};\n\nstatic void ClockMeter_updateValues(Meter* this, char* buffer, int size) {\n   time_t t = time(NULL);\n   struct tm result;\n   struct tm *lt = localtime_r(&t, &result);\n   this->values[0] = lt->tm_hour * 60 + lt->tm_min;\n   strftime(buffer, size, \"%H:%M:%S\", lt);\n}\n\nMeterClass ClockMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete\n   },\n   .updateValues = ClockMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .maxItems = 1,\n   .total = 1440, /* 24*60 */\n   .attributes = ClockMeter_attributes,\n   .name = \"Clock\",\n   .uiName = \"Clock\",\n   .caption = \"Time: \",\n};\n"
        },
        {
          "name": "ClockMeter.h",
          "type": "blob",
          "size": 0.361328125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_ClockMeter\n#define HEADER_ClockMeter\n/*\nhtop - ClockMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\nextern int ClockMeter_attributes[];\n\nextern MeterClass ClockMeter_class;\n\n#endif\n"
        },
        {
          "name": "ColorsPanel.c",
          "type": "blob",
          "size": 3.0341796875,
          "content": "/*\nhtop - ColorsPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"ColorsPanel.h\"\n\n#include \"CRT.h\"\n#include \"CheckItem.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\n// TO ADD A NEW SCHEME:\n// * Increment the size of bool check in ColorsPanel.h\n// * Add the entry in the ColorSchemeNames array below in the file\n// * Add a define in CRT.h that matches the order of the array\n// * Add the colors in CRT_setColors\n\n/*{\n#include \"Panel.h\"\n#include \"Settings.h\"\n#include \"ScreenManager.h\"\n\ntypedef struct ColorsPanel_ {\n   Panel super;\n\n   Settings* settings;\n   ScreenManager* scr;\n} ColorsPanel;\n\n}*/\n\nstatic const char* const ColorsFunctions[] = {\"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"Done  \", NULL};\n\nstatic const char* const ColorSchemeNames[] = {\n   \"Default\",\n   \"Monochromatic\",\n   \"Black on White\",\n   \"Light Terminal\",\n   \"MC\",\n   \"Black Night\",\n   \"Broken Gray\",\n   NULL\n};\n\nstatic void ColorsPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   ColorsPanel* this = (ColorsPanel*) object;\n   Panel_done(super);\n   free(this);\n}\n\nstatic HandlerResult ColorsPanel_eventHandler(Panel* super, int ch) {\n   ColorsPanel* this = (ColorsPanel*) super;\n   \n   HandlerResult result = IGNORED;\n   int mark = Panel_getSelectedIndex(super);\n\n   switch(ch) {\n   case 0x0a:\n   case 0x0d:\n   case KEY_ENTER:\n   case KEY_MOUSE:\n   case KEY_RECLICK:\n   case ' ':\n      for (int i = 0; ColorSchemeNames[i] != NULL; i++)\n         CheckItem_set((CheckItem*)Panel_get(super, i), false);\n      CheckItem_set((CheckItem*)Panel_get(super, mark), true);\n      this->settings->colorScheme = mark;\n      result = HANDLED;\n   }\n\n   if (result == HANDLED) {\n      this->settings->changed = true;\n      const Header* header = this->scr->header;\n      CRT_setColors(mark);\n      clear();\n      Panel* menu = (Panel*) Vector_get(this->scr->panels, 0);\n      Header_draw(header);\n      RichString_setAttr(&(super->header), CRT_colors[PANEL_HEADER_FOCUS]);\n      RichString_setAttr(&(menu->header), CRT_colors[PANEL_HEADER_UNFOCUS]);\n      ScreenManager_resize(this->scr, this->scr->x1, header->height, this->scr->x2, this->scr->y2);\n   }\n   return result;\n}\n\nPanelClass ColorsPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = ColorsPanel_delete\n   },\n   .eventHandler = ColorsPanel_eventHandler\n};\n\nColorsPanel* ColorsPanel_new(Settings* settings, ScreenManager* scr) {\n   ColorsPanel* this = AllocThis(ColorsPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_new(ColorsFunctions, NULL, NULL);\n   Panel_init(super, 1, 1, 1, 1, Class(CheckItem), true, fuBar);\n\n   this->settings = settings;\n   this->scr = scr;\n\n   Panel_setHeader(super, \"Colors\");\n   for (int i = 0; ColorSchemeNames[i] != NULL; i++) {\n      Panel_add(super, (Object*) CheckItem_newByVal(xStrdup(ColorSchemeNames[i]), false));\n   }\n   CheckItem_set((CheckItem*)Panel_get(super, settings->colorScheme), true);\n   return this;\n}\n"
        },
        {
          "name": "ColorsPanel.h",
          "type": "blob",
          "size": 0.794921875,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_ColorsPanel\n#define HEADER_ColorsPanel\n/*\nhtop - ColorsPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n// TO ADD A NEW SCHEME:\n// * Increment the size of bool check in ColorsPanel.h\n// * Add the entry in the ColorSchemeNames array below in the file\n// * Add a define in CRT.h that matches the order of the array\n// * Add the colors in CRT_setColors\n\n#include \"Panel.h\"\n#include \"Settings.h\"\n#include \"ScreenManager.h\"\n\ntypedef struct ColorsPanel_ {\n   Panel super;\n\n   Settings* settings;\n   ScreenManager* scr;\n} ColorsPanel;\n\n\nextern PanelClass ColorsPanel_class;\n\nColorsPanel* ColorsPanel_new(Settings* settings, ScreenManager* scr);\n\n#endif\n"
        },
        {
          "name": "ColumnsPanel.c",
          "type": "blob",
          "size": 4.064453125,
          "content": "/*\nhtop - ColumnsPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"ColumnsPanel.h\"\n#include \"Platform.h\"\n\n#include \"StringUtils.h\"\n#include \"ListItem.h\"\n#include \"CRT.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n#include <ctype.h>\n\n/*{\n#include \"Panel.h\"\n#include \"Settings.h\"\n\ntypedef struct ColumnsPanel_ {\n   Panel super;\n\n   Settings* settings;\n   bool moving;\n} ColumnsPanel;\n\n}*/\n\nstatic const char* const ColumnsFunctions[] = {\"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"MoveUp\", \"MoveDn\", \"Remove\", \"Done  \", NULL};\n\nstatic void ColumnsPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   ColumnsPanel* this = (ColumnsPanel*) object;\n   Panel_done(super);\n   free(this);\n}\n\nstatic HandlerResult ColumnsPanel_eventHandler(Panel* super, int ch) {\n   ColumnsPanel* const this = (ColumnsPanel*) super;\n   \n   int selected = Panel_getSelectedIndex(super);\n   HandlerResult result = IGNORED;\n   int size = Panel_size(super);\n\n   switch(ch) {\n      case 0x0a:\n      case 0x0d:\n      case KEY_ENTER:\n      case KEY_MOUSE:\n      case KEY_RECLICK:\n      {\n         if (selected < size - 1) {\n            this->moving = !(this->moving);\n            Panel_setSelectionColor(super, this->moving ? CRT_colors[PANEL_SELECTION_FOLLOW] : CRT_colors[PANEL_SELECTION_FOCUS]);\n            ((ListItem*)Panel_getSelected(super))->moving = this->moving;\n            result = HANDLED;\n         }\n         break;\n      }\n      case KEY_UP:\n      {\n         if (!this->moving) {\n            break;\n         }\n      }\n         /* else fallthrough */\n      case KEY_F(7):\n      case '[':\n      case '-':\n      {\n         if (selected < size - 1)\n            Panel_moveSelectedUp(super);\n         result = HANDLED;\n         break;\n      }\n      case KEY_DOWN:\n      {\n         if (!this->moving) {\n            break;\n         }\n      }\n         /* else fallthrough */\n      case KEY_F(8):\n      case ']':\n      case '+':\n      {\n         if (selected < size - 2) \n            Panel_moveSelectedDown(super);\n         result = HANDLED;\n         break;\n      }\n      case KEY_F(9):\n      case KEY_DC:\n      {\n         if (selected < size - 1) {\n            Panel_remove(super, selected);\n         }\n         result = HANDLED;\n         break;\n      }\n      default:\n      {\n         if (ch < 255 && isalpha(ch))\n            result = Panel_selectByTyping(super, ch);\n         if (result == BREAK_LOOP)\n            result = IGNORED;\n         break;\n      }\n   }\n   if (result == HANDLED)\n      ColumnsPanel_update(super);\n   return result;\n}\n\nPanelClass ColumnsPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = ColumnsPanel_delete\n   },\n   .eventHandler = ColumnsPanel_eventHandler\n};\n\nColumnsPanel* ColumnsPanel_new(Settings* settings) {\n   ColumnsPanel* this = AllocThis(ColumnsPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_new(ColumnsFunctions, NULL, NULL);\n   Panel_init(super, 1, 1, 1, 1, Class(ListItem), true, fuBar);\n\n   this->settings = settings;\n   this->moving = false;\n   Panel_setHeader(super, \"Active Columns\");\n\n   ProcessField* fields = this->settings->fields;\n   for (; *fields; fields++) {\n      if (Process_fields[*fields].name) {\n         Panel_add(super, (Object*) ListItem_new(Process_fields[*fields].name, *fields));\n      }\n   }\n   return this;\n}\n\nint ColumnsPanel_fieldNameToIndex(const char* name) {\n   for (int j = 1; j <= Platform_numberOfFields; j++) {\n      if (String_eq(name, Process_fields[j].name)) {\n         return j;\n      }\n   }\n   return -1;\n}\n\nvoid ColumnsPanel_update(Panel* super) {\n   ColumnsPanel* this = (ColumnsPanel*) super;\n   int size = Panel_size(super);\n   this->settings->changed = true;\n   this->settings->fields = xRealloc(this->settings->fields, sizeof(ProcessField) * (size+1));\n   this->settings->flags = 0;\n   for (int i = 0; i < size; i++) {\n      int key = ((ListItem*) Panel_get(super, i))->key;\n      this->settings->fields[i] = key;\n      this->settings->flags |= Process_fields[key].flags;\n   }\n   this->settings->fields[size] = 0;\n}\n\n"
        },
        {
          "name": "ColumnsPanel.h",
          "type": "blob",
          "size": 0.6025390625,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_ColumnsPanel\n#define HEADER_ColumnsPanel\n/*\nhtop - ColumnsPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Panel.h\"\n#include \"Settings.h\"\n\ntypedef struct ColumnsPanel_ {\n   Panel super;\n\n   Settings* settings;\n   bool moving;\n} ColumnsPanel;\n\n\nextern PanelClass ColumnsPanel_class;\n\nColumnsPanel* ColumnsPanel_new(Settings* settings);\n\nint ColumnsPanel_fieldNameToIndex(const char* name);\n\nvoid ColumnsPanel_update(Panel* super);\n\n\n#endif\n"
        },
        {
          "name": "DisplayOptionsPanel.c",
          "type": "blob",
          "size": 3.9638671875,
          "content": "/*\nhtop - DisplayOptionsPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"DisplayOptionsPanel.h\"\n\n#include \"CheckItem.h\"\n#include \"CRT.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*{\n#include \"Panel.h\"\n#include \"Settings.h\"\n#include \"ScreenManager.h\"\n\ntypedef struct DisplayOptionsPanel_ {\n   Panel super;\n\n   Settings* settings;\n   ScreenManager* scr;\n} DisplayOptionsPanel;\n\n}*/\n\nstatic const char* const DisplayOptionsFunctions[] = {\"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"Done  \", NULL};\n\nstatic void DisplayOptionsPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   DisplayOptionsPanel* this = (DisplayOptionsPanel*) object;\n   Panel_done(super);\n   free(this);\n}\n\nstatic HandlerResult DisplayOptionsPanel_eventHandler(Panel* super, int ch) {\n   DisplayOptionsPanel* this = (DisplayOptionsPanel*) super;\n   \n   HandlerResult result = IGNORED;\n   CheckItem* selected = (CheckItem*) Panel_getSelected(super);\n\n   switch(ch) {\n   case 0x0a:\n   case 0x0d:\n   case KEY_ENTER:\n   case KEY_MOUSE:\n   case KEY_RECLICK:\n   case ' ':\n      CheckItem_set(selected, ! (CheckItem_get(selected)) );\n      result = HANDLED;\n   }\n\n   if (result == HANDLED) {\n      this->settings->changed = true;\n      const Header* header = this->scr->header;\n      Header_calculateHeight((Header*) header);\n      Header_reinit((Header*) header);\n      Header_draw(header);\n      ScreenManager_resize(this->scr, this->scr->x1, header->height, this->scr->x2, this->scr->y2);\n   }\n   return result;\n}\n\nPanelClass DisplayOptionsPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = DisplayOptionsPanel_delete\n   },\n   .eventHandler = DisplayOptionsPanel_eventHandler\n};\n\nDisplayOptionsPanel* DisplayOptionsPanel_new(Settings* settings, ScreenManager* scr) {\n   DisplayOptionsPanel* this = AllocThis(DisplayOptionsPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_new(DisplayOptionsFunctions, NULL, NULL);\n   Panel_init(super, 1, 1, 1, 1, Class(CheckItem), true, fuBar);\n\n   this->settings = settings;\n   this->scr = scr;\n\n   Panel_setHeader(super, \"Display options\");\n   Panel_add(super, (Object*) CheckItem_newByRef(xStrdup(\"Tree view\"), &(settings->treeView)));\n   Panel_add(super, (Object*) CheckItem_newByRef(xStrdup(\"Shadow other users' processes\"), &(settings->shadowOtherUsers)));\n   Panel_add(super, (Object*) CheckItem_newByRef(xStrdup(\"Hide kernel threads\"), &(settings->hideKernelThreads)));\n   Panel_add(super, (Object*) CheckItem_newByRef(xStrdup(\"Hide userland process threads\"), &(settings->hideUserlandThreads)));\n   Panel_add(super, (Object*) CheckItem_newByRef(xStrdup(\"Display threads in a different color\"), &(settings->highlightThreads)));\n   Panel_add(super, (Object*) CheckItem_newByRef(xStrdup(\"Show custom thread names\"), &(settings->showThreadNames)));\n   Panel_add(super, (Object*) CheckItem_newByRef(xStrdup(\"Show program path\"), &(settings->showProgramPath)));\n   Panel_add(super, (Object*) CheckItem_newByRef(xStrdup(\"Highlight program \\\"basename\\\"\"), &(settings->highlightBaseName)));\n   Panel_add(super, (Object*) CheckItem_newByRef(xStrdup(\"Highlight large numbers in memory counters\"), &(settings->highlightMegabytes)));\n   Panel_add(super, (Object*) CheckItem_newByRef(xStrdup(\"Leave a margin around header\"), &(settings->headerMargin)));\n   Panel_add(super, (Object*) CheckItem_newByRef(xStrdup(\"Detailed CPU time (System/IO-Wait/Hard-IRQ/Soft-IRQ/Steal/Guest)\"), &(settings->detailedCPUTime)));\n   Panel_add(super, (Object*) CheckItem_newByRef(xStrdup(\"Count CPUs from 0 instead of 1\"), &(settings->countCPUsFromZero)));\n   Panel_add(super, (Object*) CheckItem_newByRef(xStrdup(\"Update process names on every refresh\"), &(settings->updateProcessNames)));\n   Panel_add(super, (Object*) CheckItem_newByRef(xStrdup(\"Add guest time in CPU meter percentage\"), &(settings->accountGuestInCPUMeter)));\n   return this;\n}\n"
        },
        {
          "name": "DisplayOptionsPanel.h",
          "type": "blob",
          "size": 0.6162109375,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_DisplayOptionsPanel\n#define HEADER_DisplayOptionsPanel\n/*\nhtop - DisplayOptionsPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Panel.h\"\n#include \"Settings.h\"\n#include \"ScreenManager.h\"\n\ntypedef struct DisplayOptionsPanel_ {\n   Panel super;\n\n   Settings* settings;\n   ScreenManager* scr;\n} DisplayOptionsPanel;\n\n\nextern PanelClass DisplayOptionsPanel_class;\n\nDisplayOptionsPanel* DisplayOptionsPanel_new(Settings* settings, ScreenManager* scr);\n\n#endif\n"
        },
        {
          "name": "EnvScreen.c",
          "type": "blob",
          "size": 1.4970703125,
          "content": "#include \"EnvScreen.h\"\n\n#include \"config.h\"\n#include \"CRT.h\"\n#include \"IncSet.h\"\n#include \"ListItem.h\"\n#include \"Platform.h\"\n#include \"StringUtils.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n/*{\n#include \"InfoScreen.h\"\n\ntypedef struct EnvScreen_ {\n   InfoScreen super;\n} EnvScreen;\n}*/\n\nInfoScreenClass EnvScreen_class = {\n   .super = {\n      .extends = Class(Object),\n      .delete = EnvScreen_delete\n   },\n   .scan = EnvScreen_scan,\n   .draw = EnvScreen_draw\n};\n\nEnvScreen* EnvScreen_new(Process* process) {\n   EnvScreen* this = xMalloc(sizeof(EnvScreen));\n   Object_setClass(this, Class(EnvScreen));\n   return (EnvScreen*) InfoScreen_init(&this->super, process, NULL, LINES-3, \" \");\n}\n\nvoid EnvScreen_delete(Object* this) {\n   free(InfoScreen_done((InfoScreen*)this));\n}\n\nvoid EnvScreen_draw(InfoScreen* this) {\n   InfoScreen_drawTitled(this, \"Environment of process %d - %s\", this->process->pid, this->process->comm);\n}\n\nvoid EnvScreen_scan(InfoScreen* this) {\n   Panel* panel = this->display;\n   int idx = MAX(Panel_getSelectedIndex(panel), 0);\n\n   Panel_prune(panel);\n\n   CRT_dropPrivileges();\n   char* env = Platform_getProcessEnv(this->process->pid);\n   CRT_restorePrivileges();\n   if (env) {\n      for (char *p = env; *p; p = strrchr(p, 0)+1)\n         InfoScreen_addLine(this, p);\n      free(env);\n   }\n   else {\n      InfoScreen_addLine(this, \"Could not read process environment.\");\n   }\n\n   Vector_insertionSort(this->lines);\n   Vector_insertionSort(panel->items);\n   Panel_setSelected(panel, idx);\n}\n"
        },
        {
          "name": "EnvScreen.h",
          "type": "blob",
          "size": 0.40234375,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_EnvScreen\n#define HEADER_EnvScreen\n\n#include \"InfoScreen.h\"\n\ntypedef struct EnvScreen_ {\n   InfoScreen super;\n} EnvScreen;\n\nextern InfoScreenClass EnvScreen_class;\n\nEnvScreen* EnvScreen_new(Process* process);\n\nvoid EnvScreen_delete(Object* this);\n\nvoid EnvScreen_draw(InfoScreen* this);\n\nvoid EnvScreen_scan(InfoScreen* this);\n\n#endif\n"
        },
        {
          "name": "FunctionBar.c",
          "type": "blob",
          "size": 3.734375,
          "content": "/*\nhtop - FunctionBar.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"FunctionBar.h\"\n#include \"CRT.h\"\n#include \"RichString.h\"\n#include \"XAlloc.h\"\n\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\n/*{\n\n#include <stdbool.h>\n\ntypedef struct FunctionBar_ {\n   int size;\n   char** functions;\n   char** keys;\n   int* events;\n   bool staticData;\n} FunctionBar;\n\n}*/\n\nstatic const char* const FunctionBar_FKeys[] = {\"F1\", \"F2\", \"F3\", \"F4\", \"F5\", \"F6\", \"F7\", \"F8\", \"F9\", \"F10\", NULL};\n\nstatic const char* const FunctionBar_FLabels[] = {\"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", \"      \", NULL};\n\nstatic int FunctionBar_FEvents[] = {KEY_F(1), KEY_F(2), KEY_F(3), KEY_F(4), KEY_F(5), KEY_F(6), KEY_F(7), KEY_F(8), KEY_F(9), KEY_F(10)};\n\nstatic const char* const FunctionBar_EnterEscKeys[] = {\"Enter\", \"Esc\", NULL};\nstatic const int FunctionBar_EnterEscEvents[] = {13, 27};\n\nFunctionBar* FunctionBar_newEnterEsc(const char* enter, const char* esc) {\n   const char* functions[] = {enter, esc, NULL};\n   return FunctionBar_new(functions, FunctionBar_EnterEscKeys, FunctionBar_EnterEscEvents);\n}\n\nFunctionBar* FunctionBar_new(const char* const* functions, const char* const* keys, const int* events) {\n   FunctionBar* this = xCalloc(1, sizeof(FunctionBar));\n   this->functions = xCalloc(16, sizeof(char*));\n   if (!functions) {\n      functions = FunctionBar_FLabels;\n   }\n   for (int i = 0; i < 15 && functions[i]; i++) {\n      this->functions[i] = xStrdup(functions[i]);\n   }\n   if (keys && events) {\n      this->staticData = false; \n      this->keys = xCalloc(15, sizeof(char*));\n      this->events = xCalloc(15, sizeof(int));\n      int i = 0;\n      while (i < 15 && functions[i]) {\n         this->keys[i] = xStrdup(keys[i]);\n         this->events[i] = events[i];\n         i++;\n      }\n      this->size = i;\n   } else {\n      this->staticData = true;\n      this->keys = (char**) FunctionBar_FKeys;\n      this->events = FunctionBar_FEvents;\n      this->size = 10;\n   }\n   return this;\n}\n\nvoid FunctionBar_delete(FunctionBar* this) {\n   for (int i = 0; i < 15 && this->functions[i]; i++) {\n      free(this->functions[i]);\n   }\n   free(this->functions);\n   if (!this->staticData) {\n      for (int i = 0; i < this->size; i++) {\n         free(this->keys[i]);\n      }\n      free(this->keys);\n      free(this->events);\n   }\n   free(this);\n}\n\nvoid FunctionBar_setLabel(FunctionBar* this, int event, const char* text) {\n   for (int i = 0; i < this->size; i++) {\n      if (this->events[i] == event) {\n         free(this->functions[i]);\n         this->functions[i] = xStrdup(text);\n         break;\n      }\n   }\n}\n\nvoid FunctionBar_draw(const FunctionBar* this, char* buffer) {\n   FunctionBar_drawAttr(this, buffer, CRT_colors[FUNCTION_BAR]);\n}\n\nvoid FunctionBar_drawAttr(const FunctionBar* this, char* buffer, int attr) {\n   attrset(CRT_colors[FUNCTION_BAR]);\n   mvhline(LINES-1, 0, ' ', COLS);\n   int x = 0;\n   for (int i = 0; i < this->size; i++) {\n      attrset(CRT_colors[FUNCTION_KEY]);\n      mvaddstr(LINES-1, x, this->keys[i]);\n      x += strlen(this->keys[i]);\n      attrset(CRT_colors[FUNCTION_BAR]);\n      mvaddstr(LINES-1, x, this->functions[i]);\n      x += strlen(this->functions[i]);\n   }\n   if (buffer) {\n      attrset(attr);\n      mvaddstr(LINES-1, x, buffer);\n      CRT_cursorX = x + strlen(buffer);\n      curs_set(1);\n   } else {\n      curs_set(0);\n   }\n   attrset(CRT_colors[RESET_COLOR]);\n}\n\nint FunctionBar_synthesizeEvent(const FunctionBar* this, int pos) {\n   int x = 0;\n   for (int i = 0; i < this->size; i++) {\n      x += strlen(this->keys[i]);\n      x += strlen(this->functions[i]);\n      if (pos < x) {\n         return this->events[i];\n      }\n   }\n   return ERR;\n}\n"
        },
        {
          "name": "FunctionBar.h",
          "type": "blob",
          "size": 0.9228515625,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_FunctionBar\n#define HEADER_FunctionBar\n/*\nhtop - FunctionBar.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n\n#include <stdbool.h>\n\ntypedef struct FunctionBar_ {\n   int size;\n   char** functions;\n   char** keys;\n   int* events;\n   bool staticData;\n} FunctionBar;\n\n\n\nFunctionBar* FunctionBar_newEnterEsc(const char* enter, const char* esc);\n\nFunctionBar* FunctionBar_new(const char* const* functions, const char* const* keys, const int* events);\n\nvoid FunctionBar_delete(FunctionBar* this);\n\nvoid FunctionBar_setLabel(FunctionBar* this, int event, const char* text);\n\nvoid FunctionBar_draw(const FunctionBar* this, char* buffer);\n\nvoid FunctionBar_drawAttr(const FunctionBar* this, char* buffer, int attr);\n\nint FunctionBar_synthesizeEvent(const FunctionBar* this, int pos);\n\n#endif\n"
        },
        {
          "name": "Hashtable.c",
          "type": "blob",
          "size": 4.1875,
          "content": "/*\nhtop - Hashtable.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Hashtable.h\"\n#include \"XAlloc.h\"\n\n#include <stdlib.h>\n#include <assert.h>\n\n/*{\n#include <stdbool.h>\n\ntypedef struct Hashtable_ Hashtable;\n\ntypedef void(*Hashtable_PairFunction)(int, void*, void*);\n\ntypedef struct HashtableItem {\n   unsigned int key;\n   void* value;\n   struct HashtableItem* next;\n} HashtableItem;\n\nstruct Hashtable_ {\n   int size;\n   HashtableItem** buckets;\n   int items;\n   bool owner;\n};\n}*/\n\n#ifdef DEBUG\n\nstatic bool Hashtable_isConsistent(Hashtable* this) {\n   int items = 0;\n   for (int i = 0; i < this->size; i++) {\n      HashtableItem* bucket = this->buckets[i];\n      while (bucket) {\n         items++;\n         bucket = bucket->next;\n      }\n   }\n   return items == this->items;\n}\n\nint Hashtable_count(Hashtable* this) {\n   int items = 0;\n   for (int i = 0; i < this->size; i++) {\n      HashtableItem* bucket = this->buckets[i];\n      while (bucket) {\n         items++;\n         bucket = bucket->next;\n      }\n   }\n   assert(items == this->items);\n   return items;\n}\n\n#endif\n\nstatic HashtableItem* HashtableItem_new(unsigned int key, void* value) {\n   HashtableItem* this;\n   \n   this = xMalloc(sizeof(HashtableItem));\n   this->key = key;\n   this->value = value;\n   this->next = NULL;\n   return this;\n}\n\nHashtable* Hashtable_new(int size, bool owner) {\n   Hashtable* this;\n   \n   this = xMalloc(sizeof(Hashtable));\n   this->items = 0;\n   this->size = size;\n   this->buckets = (HashtableItem**) xCalloc(size, sizeof(HashtableItem*));\n   this->owner = owner;\n   assert(Hashtable_isConsistent(this));\n   return this;\n}\n\nvoid Hashtable_delete(Hashtable* this) {\n   assert(Hashtable_isConsistent(this));\n   for (int i = 0; i < this->size; i++) {\n      HashtableItem* walk = this->buckets[i];\n      while (walk != NULL) {\n         if (this->owner)\n            free(walk->value);\n         HashtableItem* savedWalk = walk;\n         walk = savedWalk->next;\n         free(savedWalk);\n      }\n   }\n   free(this->buckets);\n   free(this);\n}\n\nvoid Hashtable_put(Hashtable* this, unsigned int key, void* value) {\n   unsigned int index = key % this->size;\n   HashtableItem** bucketPtr = &(this->buckets[index]);\n   while (true)\n      if (*bucketPtr == NULL) {\n         *bucketPtr = HashtableItem_new(key, value);\n         this->items++;\n         break;\n      } else if ((*bucketPtr)->key == key) {\n         if (this->owner)\n            free((*bucketPtr)->value);\n         (*bucketPtr)->value = value;\n         break;\n      } else\n         bucketPtr = &((*bucketPtr)->next);\n   assert(Hashtable_isConsistent(this));\n}\n\nvoid* Hashtable_remove(Hashtable* this, unsigned int key) {\n   unsigned int index = key % this->size;\n   \n   assert(Hashtable_isConsistent(this));\n\n   HashtableItem** bucket; \n   for (bucket = &(this->buckets[index]); *bucket; bucket = &((*bucket)->next) ) {\n      if ((*bucket)->key == key) {\n         void* value = (*bucket)->value;\n         HashtableItem* next = (*bucket)->next;\n         free(*bucket);\n         (*bucket) = next;\n         this->items--;\n         if (this->owner) {\n            free(value);\n            assert(Hashtable_isConsistent(this));\n            return NULL;\n         } else {\n            assert(Hashtable_isConsistent(this));\n            return value;\n         }\n      }\n   }\n   assert(Hashtable_isConsistent(this));\n   return NULL;\n}\n\ninline void* Hashtable_get(Hashtable* this, unsigned int key) {\n   unsigned int index = key % this->size;\n   HashtableItem* bucketPtr = this->buckets[index];\n   while (true) {\n      if (bucketPtr == NULL) {\n         assert(Hashtable_isConsistent(this));\n         return NULL;\n      } else if (bucketPtr->key == key) {\n         assert(Hashtable_isConsistent(this));\n         return bucketPtr->value;\n      } else\n         bucketPtr = bucketPtr->next;\n   }\n}\n\nvoid Hashtable_foreach(Hashtable* this, Hashtable_PairFunction f, void* userData) {\n   assert(Hashtable_isConsistent(this));\n   for (int i = 0; i < this->size; i++) {\n      HashtableItem* walk = this->buckets[i];\n      while (walk != NULL) {\n         f(walk->key, walk->value, userData);\n         walk = walk->next;\n      }\n   }\n   assert(Hashtable_isConsistent(this));\n}\n"
        },
        {
          "name": "Hashtable.h",
          "type": "blob",
          "size": 1.0068359375,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_Hashtable\n#define HEADER_Hashtable\n/*\nhtop - Hashtable.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdbool.h>\n\ntypedef struct Hashtable_ Hashtable;\n\ntypedef void(*Hashtable_PairFunction)(int, void*, void*);\n\ntypedef struct HashtableItem {\n   unsigned int key;\n   void* value;\n   struct HashtableItem* next;\n} HashtableItem;\n\nstruct Hashtable_ {\n   int size;\n   HashtableItem** buckets;\n   int items;\n   bool owner;\n};\n\n#ifdef DEBUG\n\nint Hashtable_count(Hashtable* this);\n\n#endif\n\nHashtable* Hashtable_new(int size, bool owner);\n\nvoid Hashtable_delete(Hashtable* this);\n\nvoid Hashtable_put(Hashtable* this, unsigned int key, void* value);\n\nvoid* Hashtable_remove(Hashtable* this, unsigned int key);\n\nextern void* Hashtable_get(Hashtable* this, unsigned int key);\n\nvoid Hashtable_foreach(Hashtable* this, Hashtable_PairFunction f, void* userData);\n\n#endif\n"
        },
        {
          "name": "Header.c",
          "type": "blob",
          "size": 5.7255859375,
          "content": "/*\nhtop - Header.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Header.h\"\n\n#include \"CRT.h\"\n#include \"StringUtils.h\"\n#include \"Platform.h\"\n\n#include <assert.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n\n/*{\n#include \"Meter.h\"\n#include \"Settings.h\"\n#include \"Vector.h\"\n\ntypedef struct Header_ {\n   Vector** columns;\n   Settings* settings;\n   struct ProcessList_* pl;\n   int nrColumns;\n   int pad;\n   int height;\n} Header;\n\n}*/\n\n#ifndef MAX\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#endif\n\n#ifndef Header_forEachColumn\n#define Header_forEachColumn(this_, i_) for (int (i_)=0; (i_) < (this_)->nrColumns; ++(i_))\n#endif\n\nHeader* Header_new(struct ProcessList_* pl, Settings* settings, int nrColumns) {\n   Header* this = xCalloc(1, sizeof(Header));\n   this->columns = xCalloc(nrColumns, sizeof(Vector*));\n   this->settings = settings;\n   this->pl = pl;\n   this->nrColumns = nrColumns;\n   Header_forEachColumn(this, i) {\n      this->columns[i] = Vector_new(Class(Meter), true, DEFAULT_SIZE);\n   }\n   return this;\n}\n\nvoid Header_delete(Header* this) {\n   Header_forEachColumn(this, i) {\n      Vector_delete(this->columns[i]);\n   }\n   free(this->columns);\n   free(this);\n}\n\nvoid Header_populateFromSettings(Header* this) {\n   Header_forEachColumn(this, col) {\n      MeterColumnSettings* colSettings = &this->settings->columns[col];\n      for (int i = 0; i < colSettings->len; i++) {\n         Header_addMeterByName(this, colSettings->names[i], col);\n         if (colSettings->modes[i] != 0) {\n            Header_setMode(this, i, colSettings->modes[i], col);\n         }\n      }\n   }\n   Header_calculateHeight(this);\n}\n\nvoid Header_writeBackToSettings(const Header* this) {\n   Header_forEachColumn(this, col) {\n      MeterColumnSettings* colSettings = &this->settings->columns[col];\n      \n      String_freeArray(colSettings->names);\n      free(colSettings->modes);\n      \n      Vector* vec = this->columns[col];\n      int len = Vector_size(vec);\n      \n      colSettings->names = xCalloc(len+1, sizeof(char*));\n      colSettings->modes = xCalloc(len, sizeof(int));\n      colSettings->len = len;\n      \n      for (int i = 0; i < len; i++) {\n         Meter* meter = (Meter*) Vector_get(vec, i);\n         char* name = xCalloc(64, sizeof(char));\n         if (meter->param) {\n            xSnprintf(name, 63, \"%s(%d)\", As_Meter(meter)->name, meter->param);\n         } else {\n            xSnprintf(name, 63, \"%s\", As_Meter(meter)->name);\n         }\n         colSettings->names[i] = name;\n         colSettings->modes[i] = meter->mode;\n      }\n   }\n}\n\nMeterModeId Header_addMeterByName(Header* this, char* name, int column) {\n   Vector* meters = this->columns[column];\n\n   char* paren = strchr(name, '(');\n   int param = 0;\n   if (paren) {\n      int ok = sscanf(paren, \"(%10d)\", &param);\n      if (!ok) param = 0;\n      *paren = '\\0';\n   }\n   MeterModeId mode = TEXT_METERMODE;\n   for (MeterClass** type = Platform_meterTypes; *type; type++) {\n      if (String_eq(name, (*type)->name)) {\n         Meter* meter = Meter_new(this->pl, param, *type);\n         Vector_add(meters, meter);\n         mode = meter->mode;\n         break;\n      }\n   }\n   return mode;\n}\n\nvoid Header_setMode(Header* this, int i, MeterModeId mode, int column) {\n   Vector* meters = this->columns[column];\n\n   if (i >= Vector_size(meters))\n      return;\n   Meter* meter = (Meter*) Vector_get(meters, i);\n   Meter_setMode(meter, mode);\n}\n\nMeter* Header_addMeterByClass(Header* this, MeterClass* type, int param, int column) {\n   Vector* meters = this->columns[column];\n\n   Meter* meter = Meter_new(this->pl, param, type);\n   Vector_add(meters, meter);\n   return meter;\n}\n\nint Header_size(Header* this, int column) {\n   Vector* meters = this->columns[column];\n   return Vector_size(meters);\n}\n\nchar* Header_readMeterName(Header* this, int i, int column) {\n   Vector* meters = this->columns[column];\n   Meter* meter = (Meter*) Vector_get(meters, i);\n\n   int nameLen = strlen(Meter_name(meter));\n   int len = nameLen + 100;\n   char* name = xMalloc(len);\n   strncpy(name, Meter_name(meter), nameLen);\n   name[nameLen] = '\\0';\n   if (meter->param)\n      xSnprintf(name + nameLen, len - nameLen, \"(%d)\", meter->param);\n\n   return name;\n}\n\nMeterModeId Header_readMeterMode(Header* this, int i, int column) {\n   Vector* meters = this->columns[column];\n\n   Meter* meter = (Meter*) Vector_get(meters, i);\n   return meter->mode;\n}\n\nvoid Header_reinit(Header* this) {\n   Header_forEachColumn(this, col) {\n      for (int i = 0; i < Vector_size(this->columns[col]); i++) {\n         Meter* meter = (Meter*) Vector_get(this->columns[col], i);\n         if (Meter_initFn(meter))\n            Meter_init(meter);\n      }\n   }\n}\n\nvoid Header_draw(const Header* this) {\n   int height = this->height;\n   int pad = this->pad;\n   attrset(CRT_colors[RESET_COLOR]);\n   for (int y = 0; y < height; y++) {\n      mvhline(y, 0, ' ', COLS);\n   }\n   int width = COLS / this->nrColumns - (pad * this->nrColumns - 1) - 1;\n   int x = pad;\n   \n   Header_forEachColumn(this, col) {\n      Vector* meters = this->columns[col];\n      for (int y = (pad / 2), i = 0; i < Vector_size(meters); i++) {\n         Meter* meter = (Meter*) Vector_get(meters, i);\n         meter->draw(meter, x, y, width);\n         y += meter->h;\n      }\n      x += width + pad;\n   }\n}\n\nint Header_calculateHeight(Header* this) {\n   int pad = this->settings->headerMargin ? 2 : 0;\n   int maxHeight = pad;\n\n   Header_forEachColumn(this, col) {\n      Vector* meters = this->columns[col];\n      int height = pad;\n      for (int i = 0; i < Vector_size(meters); i++) {\n         Meter* meter = (Meter*) Vector_get(meters, i);\n         height += meter->h;\n      }\n      maxHeight = MAX(maxHeight, height);\n   }\n   this->height = maxHeight;\n   this->pad = pad;\n   return maxHeight;\n}\n"
        },
        {
          "name": "Header.h",
          "type": "blob",
          "size": 1.375,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_Header\n#define HEADER_Header\n/*\nhtop - Header.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n#include \"Settings.h\"\n#include \"Vector.h\"\n\ntypedef struct Header_ {\n   Vector** columns;\n   Settings* settings;\n   struct ProcessList_* pl;\n   int nrColumns;\n   int pad;\n   int height;\n} Header;\n\n\n#ifndef MAX\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#endif\n\n#ifndef Header_forEachColumn\n#define Header_forEachColumn(this_, i_) for (int (i_)=0; (i_) < (this_)->nrColumns; ++(i_))\n#endif\n\nHeader* Header_new(struct ProcessList_* pl, Settings* settings, int nrColumns);\n\nvoid Header_delete(Header* this);\n\nvoid Header_populateFromSettings(Header* this);\n\nvoid Header_writeBackToSettings(const Header* this);\n\nMeterModeId Header_addMeterByName(Header* this, char* name, int column);\n\nvoid Header_setMode(Header* this, int i, MeterModeId mode, int column);\n\nMeter* Header_addMeterByClass(Header* this, MeterClass* type, int param, int column);\n\nint Header_size(Header* this, int column);\n\nchar* Header_readMeterName(Header* this, int i, int column);\n\nMeterModeId Header_readMeterMode(Header* this, int i, int column);\n\nvoid Header_reinit(Header* this);\n\nvoid Header_draw(const Header* this);\n\nint Header_calculateHeight(Header* this);\n\n#endif\n"
        },
        {
          "name": "HostnameMeter.c",
          "type": "blob",
          "size": 0.76953125,
          "content": "/*\nhtop - HostnameMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"HostnameMeter.h\"\n\n#include \"CRT.h\"\n\n#include <unistd.h>\n\n/*{\n#include \"Meter.h\"\n}*/\n\nint HostnameMeter_attributes[] = {\n   HOSTNAME\n};\n\nstatic void HostnameMeter_updateValues(Meter* this, char* buffer, int size) {\n   (void) this;\n   gethostname(buffer, size-1);\n}\n\nMeterClass HostnameMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete\n   },\n   .updateValues = HostnameMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .maxItems = 0,\n   .total = 100.0,\n   .attributes = HostnameMeter_attributes,\n   .name = \"Hostname\",\n   .uiName = \"Hostname\",\n   .caption = \"Hostname: \",\n};\n"
        },
        {
          "name": "HostnameMeter.h",
          "type": "blob",
          "size": 0.3759765625,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_HostnameMeter\n#define HEADER_HostnameMeter\n/*\nhtop - HostnameMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\nextern int HostnameMeter_attributes[];\n\nextern MeterClass HostnameMeter_class;\n\n#endif\n"
        },
        {
          "name": "IncSet.c",
          "type": "blob",
          "size": 6.2255859375,
          "content": "/*\nhtop - IncSet.c\n(C) 2005-2012 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"IncSet.h\"\n#include \"StringUtils.h\"\n#include \"Panel.h\"\n#include \"ListItem.h\"\n#include \"CRT.h\"\n#include <string.h>\n#include <stdlib.h>\n\n/*{\n\n#include \"FunctionBar.h\"\n#include \"Panel.h\"\n#include <stdbool.h>\n\n#define INCMODE_MAX 40\n\ntypedef enum {\n   INC_SEARCH = 0,\n   INC_FILTER = 1\n} IncType;\n\n#define IncSet_filter(inc_) (inc_->filtering ? inc_->modes[INC_FILTER].buffer : NULL)\n\ntypedef struct IncMode_ {\n   char buffer[INCMODE_MAX+1];\n   int index;\n   FunctionBar* bar;\n   bool isFilter;\n} IncMode;\n\ntypedef struct IncSet_ {\n   IncMode modes[2];\n   IncMode* active;\n   FunctionBar* defaultBar;\n   bool filtering;\n   bool found;\n} IncSet;\n\ntypedef const char* (*IncMode_GetPanelValue)(Panel*, int);\n\n}*/\n\nstatic void IncMode_reset(IncMode* mode) {\n   mode->index = 0;\n   mode->buffer[0] = 0;\n}\n\nstatic const char* const searchFunctions[] = {\"Next  \", \"Cancel \", \" Search: \", NULL};\nstatic const char* const searchKeys[] = {\"F3\", \"Esc\", \"  \"};\nstatic int searchEvents[] = {KEY_F(3), 27, ERR};\n\nstatic inline void IncMode_initSearch(IncMode* search) {\n   memset(search, 0, sizeof(IncMode));\n   search->bar = FunctionBar_new(searchFunctions, searchKeys, searchEvents);\n   search->isFilter = false;\n}\n\nstatic const char* const filterFunctions[] = {\"Done  \", \"Clear \", \" Filter: \", NULL};\nstatic const char* const filterKeys[] = {\"Enter\", \"Esc\", \"  \"};\nstatic int filterEvents[] = {13, 27, ERR};\n\nstatic inline void IncMode_initFilter(IncMode* filter) {\n   memset(filter, 0, sizeof(IncMode));\n   filter->bar = FunctionBar_new(filterFunctions, filterKeys, filterEvents);\n   filter->isFilter = true;\n}\n\nstatic inline void IncMode_done(IncMode* mode) {\n   FunctionBar_delete(mode->bar);\n}\n\nIncSet* IncSet_new(FunctionBar* bar) {\n   IncSet* this = xCalloc(1, sizeof(IncSet));\n   IncMode_initSearch(&(this->modes[INC_SEARCH]));\n   IncMode_initFilter(&(this->modes[INC_FILTER]));\n   this->active = NULL;\n   this->filtering = false;\n   this->defaultBar = bar;\n   return this;\n}\n\nvoid IncSet_delete(IncSet* this) {\n   IncMode_done(&(this->modes[0]));\n   IncMode_done(&(this->modes[1]));\n   free(this);\n}\n\nstatic void updateWeakPanel(IncSet* this, Panel* panel, Vector* lines) {\n   Object* selected = Panel_getSelected(panel);\n   Panel_prune(panel);\n   if (this->filtering) {\n      int n = 0;\n      const char* incFilter = this->modes[INC_FILTER].buffer;\n      for (int i = 0; i < Vector_size(lines); i++) {\n         ListItem* line = (ListItem*)Vector_get(lines, i);\n         if (String_contains_i(line->value, incFilter)) {\n            Panel_add(panel, (Object*)line);\n            if (selected == (Object*)line) Panel_setSelected(panel, n);\n            n++;\n         }\n      }\n   } else {\n      for (int i = 0; i < Vector_size(lines); i++) {\n         Object* line = Vector_get(lines, i);\n         Panel_add(panel, line);\n         if (selected == line) Panel_setSelected(panel, i);\n      }\n   }\n}\n\nstatic bool search(IncMode* mode, Panel* panel, IncMode_GetPanelValue getPanelValue) {\n   int size = Panel_size(panel);\n   bool found = false;\n   for (int i = 0; i < size; i++) {\n      if (String_contains_i(getPanelValue(panel, i), mode->buffer)) {\n         Panel_setSelected(panel, i);\n         found = true;\n         break;\n      }\n   }\n   if (found)\n      FunctionBar_draw(mode->bar, mode->buffer);\n   else\n      FunctionBar_drawAttr(mode->bar, mode->buffer, CRT_colors[FAILED_SEARCH]);\n   return found;\n}\n\nbool IncSet_handleKey(IncSet* this, int ch, Panel* panel, IncMode_GetPanelValue getPanelValue, Vector* lines) {\n   if (ch == ERR)\n      return true;\n   IncMode* mode = this->active;\n   int size = Panel_size(panel);\n   bool filterChanged = false;\n   bool doSearch = true;\n   if (ch == KEY_F(3)) {\n      if (size == 0) return true;\n      int here = Panel_getSelectedIndex(panel);\n      int i = here;\n      for(;;) {\n         i++;\n         if (i == size) i = 0;\n         if (i == here) break;\n         if (String_contains_i(getPanelValue(panel, i), mode->buffer)) {\n            Panel_setSelected(panel, i);\n            break;\n         }\n      }\n      doSearch = false;\n   } else if (ch < 255 && isprint((char)ch)) {\n      if (mode->index < INCMODE_MAX) {\n         mode->buffer[mode->index] = ch;\n         mode->index++;\n         mode->buffer[mode->index] = 0;\n         if (mode->isFilter) {\n            filterChanged = true;\n            if (mode->index == 1) this->filtering = true;\n         }\n      }\n   } else if ((ch == KEY_BACKSPACE || ch == 127)) {\n      if (mode->index > 0) {\n         mode->index--;\n         mode->buffer[mode->index] = 0;\n         if (mode->isFilter) {\n            filterChanged = true;\n            if (mode->index == 0) {\n               this->filtering = false;\n               IncMode_reset(mode);\n            }\n         }\n      } else {\n         doSearch = false;\n      }\n   } else if (ch == KEY_RESIZE) {\n     Panel_resize(panel, COLS, LINES-panel->y-1);\n   } else {\n      if (mode->isFilter) {\n         filterChanged = true;\n         if (ch == 27) {\n            this->filtering = false;\n            IncMode_reset(mode);\n         }\n      } else {\n         IncMode_reset(mode);\n      }\n      this->active = NULL;\n      Panel_setDefaultBar(panel);\n      FunctionBar_draw(this->defaultBar, NULL);\n      doSearch = false;\n   }\n   if (doSearch) {\n      this->found = search(mode, panel, getPanelValue);\n   }\n   if (filterChanged && lines) {\n      updateWeakPanel(this, panel, lines);\n   }\n   return filterChanged;\n}\n\nconst char* IncSet_getListItemValue(Panel* panel, int i) {\n   ListItem* l = (ListItem*) Panel_get(panel, i);\n   if (l)\n      return l->value;\n   return \"\";\n}\n\nvoid IncSet_activate(IncSet* this, IncType type, Panel* panel) {\n   this->active = &(this->modes[type]);\n   FunctionBar_draw(this->active->bar, this->active->buffer);\n   panel->currentBar = this->active->bar;\n}\n\nvoid IncSet_drawBar(IncSet* this) {\n   if (this->active) {\n      FunctionBar_draw(this->active->bar, this->active->buffer);\n   } else {\n      FunctionBar_draw(this->defaultBar, NULL);\n   }\n}\n\nint IncSet_synthesizeEvent(IncSet* this, int x) {\n   if (this->active) {\n      return FunctionBar_synthesizeEvent(this->active->bar, x);\n   } else {\n      return FunctionBar_synthesizeEvent(this->defaultBar, x);\n   }\n}\n"
        },
        {
          "name": "IncSet.h",
          "type": "blob",
          "size": 1.1953125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_IncSet\n#define HEADER_IncSet\n/*\nhtop - IncSet.h\n(C) 2005-2012 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n\n#include \"FunctionBar.h\"\n#include \"Panel.h\"\n#include <stdbool.h>\n\n#define INCMODE_MAX 40\n\ntypedef enum {\n   INC_SEARCH = 0,\n   INC_FILTER = 1\n} IncType;\n\n#define IncSet_filter(inc_) (inc_->filtering ? inc_->modes[INC_FILTER].buffer : NULL)\n\ntypedef struct IncMode_ {\n   char buffer[INCMODE_MAX+1];\n   int index;\n   FunctionBar* bar;\n   bool isFilter;\n} IncMode;\n\ntypedef struct IncSet_ {\n   IncMode modes[2];\n   IncMode* active;\n   FunctionBar* defaultBar;\n   bool filtering;\n   bool found;\n} IncSet;\n\ntypedef const char* (*IncMode_GetPanelValue)(Panel*, int);\n\n\nIncSet* IncSet_new(FunctionBar* bar);\n\nvoid IncSet_delete(IncSet* this);\n\nbool IncSet_handleKey(IncSet* this, int ch, Panel* panel, IncMode_GetPanelValue getPanelValue, Vector* lines);\n\nconst char* IncSet_getListItemValue(Panel* panel, int i);\n\nvoid IncSet_activate(IncSet* this, IncType type, Panel* panel);\n\nvoid IncSet_drawBar(IncSet* this);\n\nint IncSet_synthesizeEvent(IncSet* this, int x);\n\n#endif\n"
        },
        {
          "name": "InfoScreen.c",
          "type": "blob",
          "size": 5.2421875,
          "content": "#include \"InfoScreen.h\"\n\n#include \"config.h\"\n#include \"Object.h\"\n#include \"CRT.h\"\n#include \"IncSet.h\"\n#include \"ListItem.h\"\n#include \"Platform.h\"\n#include \"StringUtils.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdarg.h>\n\n/*{\n#include \"Process.h\"\n#include \"Panel.h\"\n#include \"FunctionBar.h\"\n#include \"IncSet.h\"\n\ntypedef struct InfoScreen_ InfoScreen;\n\ntypedef void(*InfoScreen_Scan)(InfoScreen*);\ntypedef void(*InfoScreen_Draw)(InfoScreen*);\ntypedef void(*InfoScreen_OnErr)(InfoScreen*);\ntypedef bool(*InfoScreen_OnKey)(InfoScreen*, int);\n\ntypedef struct InfoScreenClass_ {\n   ObjectClass super;\n   const InfoScreen_Scan scan;\n   const InfoScreen_Draw draw;\n   const InfoScreen_OnErr onErr;\n   const InfoScreen_OnKey onKey;\n} InfoScreenClass;\n\n#define As_InfoScreen(this_)          ((InfoScreenClass*)(((InfoScreen*)(this_))->super.klass))\n#define InfoScreen_scan(this_)        As_InfoScreen(this_)->scan((InfoScreen*)(this_))\n#define InfoScreen_draw(this_)        As_InfoScreen(this_)->draw((InfoScreen*)(this_))\n#define InfoScreen_onErr(this_)       As_InfoScreen(this_)->onErr((InfoScreen*)(this_))\n#define InfoScreen_onKey(this_, ch_)  As_InfoScreen(this_)->onKey((InfoScreen*)(this_), ch_)\n\nstruct InfoScreen_ {\n   Object super;\n   Process* process;\n   Panel* display;\n   FunctionBar* bar;\n   IncSet* inc;\n   Vector* lines;\n};\n}*/\n\nstatic const char* const InfoScreenFunctions[] = {\"Search \", \"Filter \", \"Refresh\", \"Done   \", NULL};\n\nstatic const char* const InfoScreenKeys[] = {\"F3\", \"F4\", \"F5\", \"Esc\"};\n\nstatic int InfoScreenEvents[] = {KEY_F(3), KEY_F(4), KEY_F(5), 27};\n\nInfoScreen* InfoScreen_init(InfoScreen* this, Process* process, FunctionBar* bar, int height, char* panelHeader) {\n   this->process = process;\n   if (!bar) {\n      bar = FunctionBar_new(InfoScreenFunctions, InfoScreenKeys, InfoScreenEvents);\n   }\n   this->display = Panel_new(0, 1, COLS, height, false, Class(ListItem), bar);\n   this->inc = IncSet_new(bar);\n   this->lines = Vector_new(this->display->items->type, true, DEFAULT_SIZE);\n   Panel_setHeader(this->display, panelHeader);\n   return this;\n}\n\nInfoScreen* InfoScreen_done(InfoScreen* this) {\n   Panel_delete((Object*)this->display);\n   IncSet_delete(this->inc);\n   Vector_delete(this->lines);\n   return this;\n}\n\nvoid InfoScreen_drawTitled(InfoScreen* this, char* fmt, ...) {\n   va_list ap;\n   va_start(ap, fmt);\n   attrset(CRT_colors[METER_TEXT]);\n   mvhline(0, 0, ' ', COLS);\n   wmove(stdscr, 0, 0);\n   vw_printw(stdscr, fmt, ap);\n   attrset(CRT_colors[DEFAULT_COLOR]);\n   this->display->needsRedraw = true;\n   Panel_draw(this->display, true);\n   IncSet_drawBar(this->inc);\n   va_end(ap);\n}\n\nvoid InfoScreen_addLine(InfoScreen* this, const char* line) {\n   Vector_add(this->lines, (Object*) ListItem_new(line, 0));\n   const char* incFilter = IncSet_filter(this->inc);\n   if (!incFilter || String_contains_i(line, incFilter))\n      Panel_add(this->display, (Object*)Vector_get(this->lines, Vector_size(this->lines)-1));\n}\n\nvoid InfoScreen_appendLine(InfoScreen* this, const char* line) {\n   ListItem* last = (ListItem*)Vector_get(this->lines, Vector_size(this->lines)-1);\n   ListItem_append(last, line);\n   const char* incFilter = IncSet_filter(this->inc);\n   if (incFilter && Panel_get(this->display, Panel_size(this->display)-1) != (Object*)last && String_contains_i(line, incFilter))\n      Panel_add(this->display, (Object*)last);\n}\n\nvoid InfoScreen_run(InfoScreen* this) {\n   Panel* panel = this->display;\n\n   if (As_InfoScreen(this)->scan) InfoScreen_scan(this);\n   InfoScreen_draw(this);\n\n   bool looping = true;\n   while (looping) {\n\n      Panel_draw(panel, true);\n\n      if (this->inc->active) {\n         (void) move(LINES-1, CRT_cursorX);\n      }\n      set_escdelay(25);\n      int ch = getch();\n      \n      if (ch == ERR) {\n         if (As_InfoScreen(this)->onErr) {\n            InfoScreen_onErr(this);\n            continue;\n         }\n      }\n\n      if (ch == KEY_MOUSE) {\n         MEVENT mevent;\n         int ok = getmouse(&mevent);\n         if (ok == OK)\n            if (mevent.y >= panel->y && mevent.y < LINES - 1) {\n               Panel_setSelected(panel, mevent.y - panel->y + panel->scrollV);\n               ch = 0;\n            } if (mevent.y == LINES - 1)\n               ch = IncSet_synthesizeEvent(this->inc, mevent.x);\n      }\n\n      if (this->inc->active) {\n         IncSet_handleKey(this->inc, ch, panel, IncSet_getListItemValue, this->lines);\n         continue;\n      }\n      \n      switch(ch) {\n      case ERR:\n         continue;\n      case KEY_F(3):\n      case '/':\n         IncSet_activate(this->inc, INC_SEARCH, panel);\n         break;\n      case KEY_F(4):\n      case '\\\\':\n         IncSet_activate(this->inc, INC_FILTER, panel);\n         break;\n      case KEY_F(5):\n         clear();\n         if (As_InfoScreen(this)->scan) InfoScreen_scan(this);\n         InfoScreen_draw(this);\n         break;\n      case '\\014': // Ctrl+L\n         clear();\n         InfoScreen_draw(this);\n         break;\n      case 'q':\n      case 27:\n      case KEY_F(10):\n         looping = false;\n         break;\n      case KEY_RESIZE:\n         Panel_resize(panel, COLS, LINES-2);\n         InfoScreen_draw(this);\n         break;\n      default:\n         if (As_InfoScreen(this)->onKey && InfoScreen_onKey(this, ch)) {\n            continue;\n         }\n         Panel_onKey(panel, ch);\n      }\n   }\n}\n"
        },
        {
          "name": "InfoScreen.h",
          "type": "blob",
          "size": 1.583984375,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_InfoScreen\n#define HEADER_InfoScreen\n\n#include \"Process.h\"\n#include \"Panel.h\"\n#include \"FunctionBar.h\"\n#include \"IncSet.h\"\n\ntypedef struct InfoScreen_ InfoScreen;\n\ntypedef void(*InfoScreen_Scan)(InfoScreen*);\ntypedef void(*InfoScreen_Draw)(InfoScreen*);\ntypedef void(*InfoScreen_OnErr)(InfoScreen*);\ntypedef bool(*InfoScreen_OnKey)(InfoScreen*, int);\n\ntypedef struct InfoScreenClass_ {\n   ObjectClass super;\n   const InfoScreen_Scan scan;\n   const InfoScreen_Draw draw;\n   const InfoScreen_OnErr onErr;\n   const InfoScreen_OnKey onKey;\n} InfoScreenClass;\n\n#define As_InfoScreen(this_)          ((InfoScreenClass*)(((InfoScreen*)(this_))->super.klass))\n#define InfoScreen_scan(this_)        As_InfoScreen(this_)->scan((InfoScreen*)(this_))\n#define InfoScreen_draw(this_)        As_InfoScreen(this_)->draw((InfoScreen*)(this_))\n#define InfoScreen_onErr(this_)       As_InfoScreen(this_)->onErr((InfoScreen*)(this_))\n#define InfoScreen_onKey(this_, ch_)  As_InfoScreen(this_)->onKey((InfoScreen*)(this_), ch_)\n\nstruct InfoScreen_ {\n   Object super;\n   Process* process;\n   Panel* display;\n   FunctionBar* bar;\n   IncSet* inc;\n   Vector* lines;\n};\n\nInfoScreen* InfoScreen_init(InfoScreen* this, Process* process, FunctionBar* bar, int height, char* panelHeader);\n\nInfoScreen* InfoScreen_done(InfoScreen* this);\n\nvoid InfoScreen_drawTitled(InfoScreen* this, char* fmt, ...);\n\nvoid InfoScreen_addLine(InfoScreen* this, const char* line);\n\nvoid InfoScreen_appendLine(InfoScreen* this, const char* line);\n\nvoid InfoScreen_run(InfoScreen* this);\n\n#endif\n"
        },
        {
          "name": "ListItem.c",
          "type": "blob",
          "size": 1.927734375,
          "content": "/*\nhtop - ListItem.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"ListItem.h\"\n\n#include \"CRT.h\"\n#include \"StringUtils.h\"\n#include \"RichString.h\"\n\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n\n/*{\n#include \"Object.h\"\n\ntypedef struct ListItem_ {\n   Object super;\n   char* value;\n   int key;\n   bool moving;\n} ListItem;\n\n}*/\n\nstatic void ListItem_delete(Object* cast) {\n   ListItem* this = (ListItem*)cast;\n   free(this->value);\n   free(this);\n}\n\nstatic void ListItem_display(Object* cast, RichString* out) {\n   ListItem* const this = (ListItem*)cast;\n   assert (this != NULL);\n   /*\n   int len = strlen(this->value)+1;\n   char buffer[len+1];\n   xSnprintf(buffer, len, \"%s\", this->value);\n   */\n   if (this->moving) {\n      RichString_write(out, CRT_colors[DEFAULT_COLOR],\n#ifdef HAVE_LIBNCURSESW\n            CRT_utf8 ? \" \" :\n#endif\n            \"+ \");\n   } else {\n      RichString_prune(out);\n   }\n   RichString_append(out, CRT_colors[DEFAULT_COLOR], this->value/*buffer*/);\n}\n\nObjectClass ListItem_class = {\n   .display = ListItem_display,\n   .delete = ListItem_delete,\n   .compare = ListItem_compare\n};\n\nListItem* ListItem_new(const char* value, int key) {\n   ListItem* this = AllocThis(ListItem);\n   this->value = xStrdup(value);\n   this->key = key;\n   this->moving = false;\n   return this;\n}\n\nvoid ListItem_append(ListItem* this, const char* text) {\n   int oldLen = strlen(this->value);\n   int textLen = strlen(text);\n   int newLen = strlen(this->value) + textLen;\n   this->value = xRealloc(this->value, newLen + 1);\n   memcpy(this->value + oldLen, text, textLen);\n   this->value[newLen] = '\\0';\n}\n\nconst char* ListItem_getRef(ListItem* this) {\n   return this->value;\n}\n\nlong ListItem_compare(const void* cast1, const void* cast2) {\n   ListItem* obj1 = (ListItem*) cast1;\n   ListItem* obj2 = (ListItem*) cast2;\n   return strcmp(obj1->value, obj2->value);\n}\n\n"
        },
        {
          "name": "ListItem.h",
          "type": "blob",
          "size": 0.6328125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_ListItem\n#define HEADER_ListItem\n/*\nhtop - ListItem.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Object.h\"\n\ntypedef struct ListItem_ {\n   Object super;\n   char* value;\n   int key;\n   bool moving;\n} ListItem;\n\n\nextern ObjectClass ListItem_class;\n\nListItem* ListItem_new(const char* value, int key);\n\nvoid ListItem_append(ListItem* this, const char* text);\n\nconst char* ListItem_getRef(ListItem* this);\n\nlong ListItem_compare(const void* cast1, const void* cast2);\n\n\n#endif\n"
        },
        {
          "name": "LoadAverageMeter.c",
          "type": "blob",
          "size": 2.5888671875,
          "content": "/*\nhtop - LoadAverageMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"LoadAverageMeter.h\"\n\n#include \"CRT.h\"\n#include \"Platform.h\"\n\n/*{\n#include \"Meter.h\"\n}*/\n\nint LoadAverageMeter_attributes[] = {\n   LOAD_AVERAGE_ONE, LOAD_AVERAGE_FIVE, LOAD_AVERAGE_FIFTEEN\n};\n\nint LoadMeter_attributes[] = { LOAD };\n\nstatic void LoadAverageMeter_updateValues(Meter* this, char* buffer, int size) {\n   Platform_getLoadAverage(&this->values[0], &this->values[1], &this->values[2]);\n   xSnprintf(buffer, size, \"%.2f/%.2f/%.2f\", this->values[0], this->values[1], this->values[2]);\n}\n\nstatic void LoadAverageMeter_display(Object* cast, RichString* out) {\n   Meter* this = (Meter*)cast;\n   char buffer[20];\n   xSnprintf(buffer, sizeof(buffer), \"%.2f \", this->values[0]);\n   RichString_write(out, CRT_colors[LOAD_AVERAGE_ONE], buffer);\n   xSnprintf(buffer, sizeof(buffer), \"%.2f \", this->values[1]);\n   RichString_append(out, CRT_colors[LOAD_AVERAGE_FIVE], buffer);\n   xSnprintf(buffer, sizeof(buffer), \"%.2f \", this->values[2]);\n   RichString_append(out, CRT_colors[LOAD_AVERAGE_FIFTEEN], buffer);\n}\n\nstatic void LoadMeter_updateValues(Meter* this, char* buffer, int size) {\n   double five, fifteen;\n   Platform_getLoadAverage(&this->values[0], &five, &fifteen);\n   if (this->values[0] > this->total) {\n      this->total = this->values[0];\n   }\n   xSnprintf(buffer, size, \"%.2f\", this->values[0]);\n}\n\nstatic void LoadMeter_display(Object* cast, RichString* out) {\n   Meter* this = (Meter*)cast;\n   char buffer[20];\n   xSnprintf(buffer, sizeof(buffer), \"%.2f \", ((Meter*)this)->values[0]);\n   RichString_write(out, CRT_colors[LOAD], buffer);\n}\n\nMeterClass LoadAverageMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = LoadAverageMeter_display,\n   },\n   .updateValues = LoadAverageMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .maxItems = 3,\n   .total = 100.0,\n   .attributes = LoadAverageMeter_attributes,\n   .name = \"LoadAverage\",\n   .uiName = \"Load average\",\n   .description = \"Load averages: 1 minute, 5 minutes, 15 minutes\",\n   .caption = \"Load average: \"\n};\n\nMeterClass LoadMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = LoadMeter_display,\n   },\n   .updateValues = LoadMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .maxItems = 1,\n   .total = 100.0,\n   .attributes = LoadMeter_attributes,\n   .name = \"Load\",\n   .uiName = \"Load\",\n   .description = \"Load: average of ready processes in the last minute\",\n   .caption = \"Load: \"\n};\n"
        },
        {
          "name": "LoadAverageMeter.h",
          "type": "blob",
          "size": 0.4609375,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_LoadAverageMeter\n#define HEADER_LoadAverageMeter\n/*\nhtop - LoadAverageMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\nextern int LoadAverageMeter_attributes[];\n\nextern int LoadMeter_attributes[];\n\nextern MeterClass LoadAverageMeter_class;\n\nextern MeterClass LoadMeter_class;\n\n#endif\n"
        },
        {
          "name": "MainPanel.c",
          "type": "blob",
          "size": 5.541015625,
          "content": "/*\nhtop - ColumnsPanel.c\n(C) 2004-2015 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"MainPanel.h\"\n#include \"Process.h\"\n#include \"Platform.h\"\n#include \"CRT.h\"\n\n#include <stdlib.h>\n\n/*{\n#include \"Panel.h\"\n#include \"Action.h\"\n#include \"Settings.h\"\n\ntypedef struct MainPanel_ {\n   Panel super;\n   State* state;\n   IncSet* inc;\n   Htop_Action *keys;\n   pid_t pidSearch;\n} MainPanel;\n\ntypedef union {\n   int i;\n   void* v;\n} Arg;\n\ntypedef bool(*MainPanel_ForeachProcessFn)(Process*, Arg);\n\n#define MainPanel_getFunctionBar(this_) (((Panel*)(this_))->defaultBar)\n\n}*/\n\nstatic const char* const MainFunctions[]  = {\"Help  \", \"Setup \", \"Search\", \"Filter\", \"Tree  \", \"SortBy\", \"Nice -\", \"Nice +\", \"Kill  \", \"Quit  \", NULL};\n\nvoid MainPanel_updateTreeFunctions(MainPanel* this, bool mode) {\n   FunctionBar* bar = MainPanel_getFunctionBar(this);\n   if (mode) {\n      FunctionBar_setLabel(bar, KEY_F(5), \"Sorted\");\n      FunctionBar_setLabel(bar, KEY_F(6), \"Collap\");\n   } else {\n      FunctionBar_setLabel(bar, KEY_F(5), \"Tree  \");\n      FunctionBar_setLabel(bar, KEY_F(6), \"SortBy\");\n   }\n}\n\nvoid MainPanel_pidSearch(MainPanel* this, int ch) {\n   Panel* super = (Panel*) this;\n   pid_t pid = ch-48 + this->pidSearch;\n   for (int i = 0; i < Panel_size(super); i++) {\n      Process* p = (Process*) Panel_get(super, i);\n      if (p && p->pid == pid) {\n         Panel_setSelected(super, i);\n         break;\n      }\n   }\n   this->pidSearch = pid * 10;\n   if (this->pidSearch > 10000000) {\n      this->pidSearch = 0;\n   }\n}\n\nstatic HandlerResult MainPanel_eventHandler(Panel* super, int ch) {\n   MainPanel* this = (MainPanel*) super;\n\n   HandlerResult result = IGNORED;\n   \n   Htop_Reaction reaction = HTOP_OK;\n\n   if (EVENT_IS_HEADER_CLICK(ch)) {\n      int x = EVENT_HEADER_CLICK_GET_X(ch);\n      ProcessList* pl = this->state->pl;\n      Settings* settings = this->state->settings;\n      int hx = super->scrollH + x + 1;\n      ProcessField field = ProcessList_keyAt(pl, hx);\n      if (field == settings->sortKey) {\n         Settings_invertSortOrder(settings);\n         settings->treeView = false;\n      } else {\n         reaction |= Action_setSortKey(settings, field);\n      }\n      reaction |= HTOP_RECALCULATE | HTOP_REDRAW_BAR | HTOP_SAVE_SETTINGS; \n      result = HANDLED;\n   } else if (ch != ERR && this->inc->active) {\n      bool filterChanged = IncSet_handleKey(this->inc, ch, super, (IncMode_GetPanelValue) MainPanel_getValue, NULL);\n      if (filterChanged) {\n         this->state->pl->incFilter = IncSet_filter(this->inc);\n         reaction = HTOP_REFRESH | HTOP_REDRAW_BAR;\n      }\n      if (this->inc->found) {\n         reaction |= Action_follow(this->state);\n         reaction |= HTOP_KEEP_FOLLOWING;\n      }\n      result = HANDLED;\n   } else if (ch == 27) {\n      return HANDLED;\n   } else if (ch != ERR && ch > 0 && ch < KEY_MAX && this->keys[ch]) {\n      reaction |= (this->keys[ch])(this->state);\n      result = HANDLED;\n   } else if (isdigit(ch)) {\n      MainPanel_pidSearch(this, ch);\n   } else {\n      if (ch != ERR) {\n         this->pidSearch = 0;\n      } else {\n         reaction |= HTOP_KEEP_FOLLOWING;\n      }\n   }\n\n   if (reaction & HTOP_REDRAW_BAR) {\n      MainPanel_updateTreeFunctions(this, this->state->settings->treeView);\n      IncSet_drawBar(this->inc);\n   }\n   if (reaction & HTOP_UPDATE_PANELHDR) {\n      ProcessList_printHeader(this->state->pl, Panel_getHeader(super));\n   }\n   if (reaction & HTOP_REFRESH) {\n      result |= REDRAW;\n   }      \n   if (reaction & HTOP_RECALCULATE) {\n      result |= RESCAN;\n   }\n   if (reaction & HTOP_SAVE_SETTINGS) {\n      this->state->settings->changed = true;\n   }\n   if (reaction & HTOP_QUIT) {\n      return BREAK_LOOP;\n   }\n   if (!(reaction & HTOP_KEEP_FOLLOWING)) {\n      this->state->pl->following = -1;\n      Panel_setSelectionColor(super, CRT_colors[PANEL_SELECTION_FOCUS]);\n   }\n   return result;\n}\n\nint MainPanel_selectedPid(MainPanel* this) {\n   Process* p = (Process*) Panel_getSelected((Panel*)this);\n   if (p) {\n      return p->pid;\n   }\n   return -1;\n}\n\nconst char* MainPanel_getValue(MainPanel* this, int i) {\n   Process* p = (Process*) Panel_get((Panel*)this, i);\n   if (p)\n      return p->comm;\n   return \"\";\n}\n\nbool MainPanel_foreachProcess(MainPanel* this, MainPanel_ForeachProcessFn fn, Arg arg, bool* wasAnyTagged) {\n   Panel* super = (Panel*) this;\n   bool ok = true;\n   bool anyTagged = false;\n   for (int i = 0; i < Panel_size(super); i++) {\n      Process* p = (Process*) Panel_get(super, i);\n      if (p->tag) {\n         ok = fn(p, arg) && ok;\n         anyTagged = true;\n      }\n   }\n   if (!anyTagged) {\n      Process* p = (Process*) Panel_getSelected(super);\n      if (p) ok = fn(p, arg) && ok;\n   }\n   if (wasAnyTagged)\n      *wasAnyTagged = anyTagged;\n   return ok;\n}\n\nPanelClass MainPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = MainPanel_delete\n   },\n   .eventHandler = MainPanel_eventHandler\n};\n\nMainPanel* MainPanel_new() {\n   MainPanel* this = AllocThis(MainPanel);\n   Panel_init((Panel*) this, 1, 1, 1, 1, Class(Process), false, FunctionBar_new(MainFunctions, NULL, NULL));\n   this->keys = xCalloc(KEY_MAX, sizeof(Htop_Action));\n   this->inc = IncSet_new(MainPanel_getFunctionBar(this));\n\n   Action_setBindings(this->keys);\n   Platform_setBindings(this->keys);\n\n   return this;\n}\n\nvoid MainPanel_setState(MainPanel* this, State* state) {\n   this->state = state;\n}\n\nvoid MainPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   MainPanel* this = (MainPanel*) object;\n   Panel_done(super);\n   IncSet_delete(this->inc);\n   free(this->keys);\n   free(this);\n}\n"
        },
        {
          "name": "MainPanel.h",
          "type": "blob",
          "size": 1.11328125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_MainPanel\n#define HEADER_MainPanel\n/*\nhtop - ColumnsPanel.h\n(C) 2004-2015 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Panel.h\"\n#include \"Action.h\"\n#include \"Settings.h\"\n\ntypedef struct MainPanel_ {\n   Panel super;\n   State* state;\n   IncSet* inc;\n   Htop_Action *keys;\n   pid_t pidSearch;\n} MainPanel;\n\ntypedef union {\n   int i;\n   void* v;\n} Arg;\n\ntypedef bool(*MainPanel_ForeachProcessFn)(Process*, Arg);\n\n#define MainPanel_getFunctionBar(this_) (((Panel*)(this_))->defaultBar)\n\n\nvoid MainPanel_updateTreeFunctions(MainPanel* this, bool mode);\n\nvoid MainPanel_pidSearch(MainPanel* this, int ch);\n\nint MainPanel_selectedPid(MainPanel* this);\n\nconst char* MainPanel_getValue(MainPanel* this, int i);\n\nbool MainPanel_foreachProcess(MainPanel* this, MainPanel_ForeachProcessFn fn, Arg arg, bool* wasAnyTagged);\n\nextern PanelClass MainPanel_class;\n\nMainPanel* MainPanel_new();\n\nvoid MainPanel_setState(MainPanel* this, State* state);\n\nvoid MainPanel_delete(Object* object);\n\n#endif\n"
        },
        {
          "name": "Makefile.am",
          "type": "blob",
          "size": 6.1748046875,
          "content": "\nACLOCAL_AMFLAGS = -I m4\nAUTOMAKE_OPTIONS = subdir-objects\n\nbin_PROGRAMS = htop\n\ndist_man_MANS = htop.1\nEXTRA_DIST = $(dist_man_MANS) htop.desktop htop.png scripts/MakeHeader.py \\\ninstall-sh autogen.sh missing\napplicationsdir = $(datadir)/applications\napplications_DATA = htop.desktop\npixmapdir = $(datadir)/pixmaps\npixmap_DATA = htop.png\n\nAM_CFLAGS = -pedantic -Wall $(wextra_flag) -std=c99 -D_XOPEN_SOURCE_EXTENDED -DSYSCONFDIR=\\\"$(sysconfdir)\\\" -I\"$(top_srcdir)/$(my_htop_platform)\"\nAM_LDFLAGS =\nAM_CPPFLAGS = -DNDEBUG\n\nmyhtopsources = AvailableMetersPanel.c CategoriesPanel.c CheckItem.c \\\nClockMeter.c ColorsPanel.c ColumnsPanel.c CPUMeter.c CRT.c MainPanel.c \\\nDisplayOptionsPanel.c FunctionBar.c Hashtable.c Header.c htop.c ListItem.c \\\nLoadAverageMeter.c MemoryMeter.c Meter.c MetersPanel.c Object.c Panel.c \\\nBatteryMeter.c Process.c ProcessList.c RichString.c ScreenManager.c Settings.c \\\nSignalsPanel.c StringUtils.c SwapMeter.c TasksMeter.c UptimeMeter.c \\\nTraceScreen.c UsersTable.c Vector.c AvailableColumnsPanel.c AffinityPanel.c \\\nHostnameMeter.c OpenFilesScreen.c Affinity.c IncSet.c Action.c EnvScreen.c \\\nInfoScreen.c XAlloc.c\n\nmyhtopheaders = AvailableColumnsPanel.h AvailableMetersPanel.h \\\nCategoriesPanel.h CheckItem.h ClockMeter.h ColorsPanel.h ColumnsPanel.h \\\nCPUMeter.h CRT.h MainPanel.h DisplayOptionsPanel.h FunctionBar.h \\\nHashtable.h Header.h htop.h ListItem.h LoadAverageMeter.h MemoryMeter.h \\\nBatteryMeter.h Meter.h MetersPanel.h Object.h Panel.h ProcessList.h RichString.h \\\nScreenManager.h Settings.h SignalsPanel.h StringUtils.h SwapMeter.h \\\nTasksMeter.h UptimeMeter.h TraceScreen.h UsersTable.h Vector.h Process.h \\\nAffinityPanel.h HostnameMeter.h OpenFilesScreen.h Affinity.h IncSet.h Action.h \\\nEnvScreen.h InfoScreen.h XAlloc.h\n\nall_platform_headers =\n\n# Linux\n# -----\n\nlinux_platform_headers = \\\n\tlinux/Platform.h \\\n\tlinux/IOPriorityPanel.h \\\n\tlinux/IOPriority.h \\\n\tlinux/LinuxProcess.h \\\n\tlinux/LinuxProcessList.h \\\n\tlinux/LinuxCRT.h \\\n\tlinux/Battery.h\n\nall_platform_headers += $(linux_platform_headers)\n\nif HTOP_LINUX\nAM_CFLAGS += -rdynamic\nmyhtopplatsources = linux/Platform.c linux/IOPriorityPanel.c linux/IOPriority.c \\\nlinux/LinuxProcess.c linux/LinuxProcessList.c linux/LinuxCRT.c linux/Battery.c\n\nmyhtopplatheaders = $(linux_platform_headers)\nendif\n\n# FreeBSD\n# -------\n\nfreebsd_platform_headers = \\\n\tfreebsd/Platform.h \\\n\tfreebsd/FreeBSDProcessList.h \\\n\tfreebsd/FreeBSDProcess.h \\\n\tfreebsd/FreeBSDCRT.h \\\n\tfreebsd/Battery.h\n\nall_platform_headers += $(freebsd_platform_headers)\n\nif HTOP_FREEBSD\nmyhtopplatsources = freebsd/Platform.c freebsd/FreeBSDProcessList.c \\\nfreebsd/FreeBSDProcess.c freebsd/FreeBSDCRT.c freebsd/Battery.c\n\nmyhtopplatheaders = $(freebsd_platform_headers)\nendif\n\n# DragonFlyBSD\n# ------------\n\ndragonflybsd_platform_headers = \\\n\tdragonflybsd/Platform.h \\\n\tdragonflybsd/DragonFlyBSDProcessList.h \\\n\tdragonflybsd/DragonFlyBSDProcess.h \\\n\tdragonflybsd/DragonFlyBSDCRT.h \\\n\tdragonflybsd/Battery.h\n\nall_platform_headers += $(dragonflybsd_platform_headers)\n\nif HTOP_DRAGONFLYBSD\nAM_LDFLAGS += -lkvm -lkinfo -lexecinfo\nmyhtopplatsources = dragonflybsd/Platform.c dragonflybsd/DragonFlyBSDProcessList.c \\\ndragonflybsd/DragonFlyBSDProcess.c dragonflybsd/DragonFlyBSDCRT.c dragonflybsd/Battery.c\n\nmyhtopplatheaders = $(dragonflybsd_platform_headers)\nendif\n\n# OpenBSD\n# -------\n\nopenbsd_platform_headers = \\\n\topenbsd/Platform.h \\\n\topenbsd/OpenBSDProcessList.h \\\n\topenbsd/OpenBSDProcess.h \\\n\topenbsd/OpenBSDCRT.h \\\n\topenbsd/Battery.h\n\nall_platform_headers += $(openbsd_platform_headers)\n\nif HTOP_OPENBSD\nmyhtopplatsources = openbsd/Platform.c openbsd/OpenBSDProcessList.c \\\nopenbsd/OpenBSDProcess.c openbsd/OpenBSDCRT.c openbsd/Battery.c\n\nmyhtopplatheaders = $(openbsd_platform_headers)\nendif\n\n# Darwin\n# ------\n\ndarwin_platform_headers = \\\n\tdarwin/Platform.h \\\n\tdarwin/DarwinProcess.h \\\n\tdarwin/DarwinProcessList.h \\\n\tdarwin/DarwinCRT.h \\\n\tdarwin/Battery.h\n\nall_platform_headers += $(darwin_platform_headers)\n\nif HTOP_DARWIN\nAM_LDFLAGS += -framework IOKit -framework CoreFoundation\nmyhtopplatsources = darwin/Platform.c darwin/DarwinProcess.c \\\ndarwin/DarwinProcessList.c darwin/DarwinCRT.c darwin/Battery.c\n\nmyhtopplatheaders = $(darwin_platform_headers)\nendif\n\n# Solaris\n# -------\n\nsolaris_platform_headers = \\\n\tsolaris/Platform.h \\\n\tsolaris/SolarisProcess.h \\\n\tsolaris/SolarisProcessList.h \\\n\tsolaris/SolarisCRT.h \\\n\tsolaris/Battery.h\n\nall_platform_headers += $(solaris_platform_headers)\n\nif HTOP_SOLARIS\nmyhtopplatsources = solaris/Platform.c \\\nsolaris/SolarisProcess.c solaris/SolarisProcessList.c \\\nsolaris/SolarisCRT.c solaris/Battery.c\n\nmyhtopplatheaders = $(solaris_platform_headers)\nendif\n\n# Unsupported\n# -----------\n\nunsupported_platform_headers = \\\n\tunsupported/Platform.h \\\n\tunsupported/UnsupportedProcess.h \\\n\tunsupported/UnsupportedProcessList.h \\\n\tunsupported/UnsupportedCRT.h \\\n\tunsupported/Battery.h\n\nall_platform_headers += $(unsupported_platform_headers)\n\nif HTOP_UNSUPPORTED\nmyhtopplatsources = unsupported/Platform.c \\\nunsupported/UnsupportedProcess.c unsupported/UnsupportedProcessList.c \\\nunsupported/UnsupportedCRT.c unsupported/Battery.c\n\nmyhtopplatheaders = $(unsupported_platform_headers)\nendif\n\n# ----\n\nSUFFIXES = .h\n\nBUILT_SOURCES = $(myhtopheaders) $(myhtopplatheaders)\nhtop_SOURCES  = $(myhtopheaders) $(myhtopplatheaders) $(myhtopsources) $(myhtopplatsources) config.h\n\n.PHONY: htop-headers clean-htop-headers\n\nhtop-headers: $(myhtopheaders) $(all_platform_headers)\n\nclean-htop-headers:\n\t-rm -f $(myhtopheaders) $(all_platform_headers)\n\ntarget:\n\techo $(htop_SOURCES)\n\nprofile:\n\t$(MAKE) all CFLAGS=\"-pg\" AM_CPPFLAGS=\"-pg -O2 -DNDEBUG\"\n\ndebug:\n\t$(MAKE) all CFLAGS=\"\" AM_CPPFLAGS=\"-ggdb -DDEBUG\"\n\ncoverage:\n\t$(MAKE) all CFLAGS=\"\" AM_CPPFLAGS=\"-fprofile-arcs -ftest-coverage -DDEBUG\" LDFLAGS=\"-lgcov\"\n\n.c.h:\n\t@srcdir@/scripts/MakeHeader.py $<\n\ncppcheck:\n\tcppcheck -q -v . --enable=all -DHAVE_CGROUP -DHAVE_OPENVZ -DHAVE_TASKSTATS\n\ndist-hook: $(top_distdir)/configure\n\t@if grep 'pkg_m4_absent' '$(top_distdir)/configure'; then \\\n\t   echo 'configure is generated without pkg.m4. Please supply pkg.m4 and run ./autogen.sh to rebuild the configure script.'>&2; \\\n\t   (exit 1); \\\n\telse :; \\\n\tfi\n\n.PHONY: lcov\n\nlcov:\n\tmkdir -p lcov\n\tlcov --capture --directory . --output-file coverage.info\n\tgenhtml coverage.info --output-directory lcov\n"
        },
        {
          "name": "MemoryMeter.c",
          "type": "blob",
          "size": 1.904296875,
          "content": "/*\nhtop - MemoryMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"MemoryMeter.h\"\n\n#include \"CRT.h\"\n#include \"Platform.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <sys/param.h>\n#include <assert.h>\n\n/*{\n#include \"Meter.h\"\n}*/\n\nint MemoryMeter_attributes[] = {\n   MEMORY_USED, MEMORY_BUFFERS, MEMORY_CACHE\n};\n\nstatic void MemoryMeter_updateValues(Meter* this, char* buffer, int size) {\n   int written;\n   Platform_setMemoryValues(this);\n\n   written = Meter_humanUnit(buffer, this->values[0], size);\n   buffer += written;\n   if ((size -= written) > 0) {\n      *buffer++ = '/';\n      size--;\n      Meter_humanUnit(buffer, this->total, size);\n   }\n}\n\nstatic void MemoryMeter_display(Object* cast, RichString* out) {\n   char buffer[50];\n   Meter* this = (Meter*)cast;\n   RichString_write(out, CRT_colors[METER_TEXT], \":\");\n   Meter_humanUnit(buffer, this->total, 50);\n   RichString_append(out, CRT_colors[METER_VALUE], buffer);\n   Meter_humanUnit(buffer, this->values[0], 50);\n   RichString_append(out, CRT_colors[METER_TEXT], \" used:\");\n   RichString_append(out, CRT_colors[MEMORY_USED], buffer);\n   Meter_humanUnit(buffer, this->values[1], 50);\n   RichString_append(out, CRT_colors[METER_TEXT], \" buffers:\");\n   RichString_append(out, CRT_colors[MEMORY_BUFFERS_TEXT], buffer);\n   Meter_humanUnit(buffer, this->values[2], 50);\n   RichString_append(out, CRT_colors[METER_TEXT], \" cache:\");\n   RichString_append(out, CRT_colors[MEMORY_CACHE], buffer);\n}\n\nMeterClass MemoryMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = MemoryMeter_display,\n   },\n   .updateValues = MemoryMeter_updateValues, \n   .defaultMode = BAR_METERMODE,\n   .maxItems = 3,\n   .total = 100.0,\n   .attributes = MemoryMeter_attributes,\n   .name = \"Memory\",\n   .uiName = \"Memory\",\n   .caption = \"Mem\"\n};\n"
        },
        {
          "name": "MemoryMeter.h",
          "type": "blob",
          "size": 0.3662109375,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_MemoryMeter\n#define HEADER_MemoryMeter\n/*\nhtop - MemoryMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\nextern int MemoryMeter_attributes[];\n\nextern MeterClass MemoryMeter_class;\n\n#endif\n"
        },
        {
          "name": "Meter.c",
          "type": "blob",
          "size": 14.3095703125,
          "content": "/*\nhtop - Meter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\n#include \"RichString.h\"\n#include \"Object.h\"\n#include \"CRT.h\"\n#include \"StringUtils.h\"\n#include \"ListItem.h\"\n#include \"Settings.h\"\n\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <sys/time.h>\n\n#define METER_BUFFER_LEN 256\n\n#define GRAPH_DELAY (DEFAULT_DELAY/2)\n\n#define GRAPH_HEIGHT 4 /* Unit: rows (lines) */\n\n/*{\n#include \"ListItem.h\"\n\n#include <sys/time.h>\n\ntypedef struct Meter_ Meter;\n\ntypedef void(*Meter_Init)(Meter*);\ntypedef void(*Meter_Done)(Meter*);\ntypedef void(*Meter_UpdateMode)(Meter*, int);\ntypedef void(*Meter_UpdateValues)(Meter*, char*, int);\ntypedef void(*Meter_Draw)(Meter*, int, int, int);\n\ntypedef struct MeterClass_ {\n   ObjectClass super;\n   const Meter_Init init;\n   const Meter_Done done;\n   const Meter_UpdateMode updateMode;\n   const Meter_Draw draw;\n   const Meter_UpdateValues updateValues;\n   const int defaultMode;\n   const double total;\n   const int* attributes;\n   const char* name;\n   const char* uiName;\n   const char* caption;\n   const char* description;\n   const char maxItems;\n   char curItems;\n} MeterClass;\n\n#define As_Meter(this_)                ((MeterClass*)((this_)->super.klass))\n#define Meter_initFn(this_)            As_Meter(this_)->init\n#define Meter_init(this_)              As_Meter(this_)->init((Meter*)(this_))\n#define Meter_done(this_)              As_Meter(this_)->done((Meter*)(this_))\n#define Meter_updateModeFn(this_)      As_Meter(this_)->updateMode\n#define Meter_updateMode(this_, m_)    As_Meter(this_)->updateMode((Meter*)(this_), m_)\n#define Meter_drawFn(this_)            As_Meter(this_)->draw\n#define Meter_doneFn(this_)            As_Meter(this_)->done\n#define Meter_updateValues(this_, buf_, sz_) \\\n                                       As_Meter(this_)->updateValues((Meter*)(this_), buf_, sz_)\n#define Meter_defaultMode(this_)       As_Meter(this_)->defaultMode\n#define Meter_getItems(this_)          As_Meter(this_)->curItems\n#define Meter_setItems(this_, n_)      As_Meter(this_)->curItems = (n_)\n#define Meter_attributes(this_)        As_Meter(this_)->attributes\n#define Meter_name(this_)              As_Meter(this_)->name\n#define Meter_uiName(this_)            As_Meter(this_)->uiName\n\nstruct Meter_ {\n   Object super;\n   Meter_Draw draw;\n   \n   char* caption;\n   int mode;\n   int param;\n   void* drawData;\n   int h;\n   struct ProcessList_* pl;\n   double* values;\n   double total;\n};\n\ntypedef struct MeterMode_ {\n   Meter_Draw draw;\n   const char* uiName;\n   int h;\n} MeterMode;\n\ntypedef enum {\n   CUSTOM_METERMODE = 0,\n   BAR_METERMODE,\n   TEXT_METERMODE,\n   GRAPH_METERMODE,\n   LED_METERMODE,\n   LAST_METERMODE\n} MeterModeId;\n\ntypedef struct GraphData_ {\n   struct timeval time;\n   double values[METER_BUFFER_LEN];\n} GraphData;\n\n}*/\n\n#ifndef MIN\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#endif\n#ifndef MAX\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#endif\n#ifndef CLAMP\n#define CLAMP(x,low,high) (((x)>(high))?(high):(((x)<(low))?(low):(x)))\n#endif\n\nMeterClass Meter_class = {\n   .super = {\n      .extends = Class(Object)\n   }\n};\n\nMeter* Meter_new(struct ProcessList_* pl, int param, MeterClass* type) {\n   Meter* this = xCalloc(1, sizeof(Meter));\n   Object_setClass(this, type);\n   this->h = 1;\n   this->param = param;\n   this->pl = pl;\n   type->curItems = type->maxItems;\n   this->values = xCalloc(type->maxItems, sizeof(double));\n   this->total = type->total;\n   this->caption = xStrdup(type->caption);\n   if (Meter_initFn(this))\n      Meter_init(this);\n   Meter_setMode(this, type->defaultMode);\n   return this;\n}\n\nint Meter_humanUnit(char* buffer, unsigned long int value, int size) {\n   const char * prefix = \"KMGTPEZY\";\n   unsigned long int powi = 1;\n   unsigned int written, powj = 1, precision = 2;\n\n   for(;;) {\n      if (value / 1024 < powi)\n         break;\n\n      if (prefix[1] == '\\0')\n         break;\n\n      powi *= 1024;\n      ++prefix;\n   }\n\n   if (*prefix == 'K')\n      precision = 0;\n\n   for (; precision > 0; precision--) {\n      powj *= 10;\n      if (value / powi < powj)\n         break;\n   }\n\n   written = snprintf(buffer, size, \"%.*f%c\",\n      precision, (double) value / powi, *prefix);\n\n   return written;\n}\n\nvoid Meter_delete(Object* cast) {\n   if (!cast)\n      return;\n   Meter* this = (Meter*) cast;\n   if (Meter_doneFn(this)) {\n      Meter_done(this);\n   }\n   free(this->drawData);\n   free(this->caption);\n   free(this->values);\n   free(this);\n}\n\nvoid Meter_setCaption(Meter* this, const char* caption) {\n   free(this->caption);\n   this->caption = xStrdup(caption);\n}\n\nstatic inline void Meter_displayBuffer(Meter* this, char* buffer, RichString* out) {\n   if (Object_displayFn(this)) {\n      Object_display(this, out);\n   } else {\n      RichString_write(out, CRT_colors[Meter_attributes(this)[0]], buffer);\n   }\n}\n\nvoid Meter_setMode(Meter* this, int modeIndex) {\n   if (modeIndex > 0 && modeIndex == this->mode)\n      return;\n   if (!modeIndex)\n      modeIndex = 1;\n   assert(modeIndex < LAST_METERMODE);\n   if (Meter_defaultMode(this) == CUSTOM_METERMODE) {\n      this->draw = Meter_drawFn(this);\n      if (Meter_updateModeFn(this))\n         Meter_updateMode(this, modeIndex);\n   } else {\n      assert(modeIndex >= 1);\n      free(this->drawData);\n      this->drawData = NULL;\n\n      MeterMode* mode = Meter_modes[modeIndex];\n      this->draw = mode->draw;\n      this->h = mode->h;\n   }\n   this->mode = modeIndex;\n}\n\nListItem* Meter_toListItem(Meter* this, bool moving) {\n   char mode[21];\n   if (this->mode)\n      xSnprintf(mode, 20, \" [%s]\", Meter_modes[this->mode]->uiName);\n   else\n      mode[0] = '\\0';\n   char number[11];\n   if (this->param > 0)\n      xSnprintf(number, 10, \" %d\", this->param);\n   else\n      number[0] = '\\0';\n   char buffer[51];\n   xSnprintf(buffer, 50, \"%s%s%s\", Meter_uiName(this), number, mode);\n   ListItem* li = ListItem_new(buffer, 0);\n   li->moving = moving;\n   return li;\n}\n\n/* ---------- TextMeterMode ---------- */\n\nstatic void TextMeterMode_draw(Meter* this, int x, int y, int w) {\n   char buffer[METER_BUFFER_LEN];\n   Meter_updateValues(this, buffer, METER_BUFFER_LEN - 1);\n   (void) w;\n\n   attrset(CRT_colors[METER_TEXT]);\n   mvaddstr(y, x, this->caption);\n   int captionLen = strlen(this->caption);\n   x += captionLen;\n   attrset(CRT_colors[RESET_COLOR]);\n   RichString_begin(out);\n   Meter_displayBuffer(this, buffer, &out);\n   RichString_printVal(out, y, x);\n   RichString_end(out);\n}\n\n/* ---------- BarMeterMode ---------- */\n\nstatic const char BarMeterMode_characters[] = \"|#*@$%&.\";\n\nstatic void BarMeterMode_draw(Meter* this, int x, int y, int w) {\n   char buffer[METER_BUFFER_LEN];\n   Meter_updateValues(this, buffer, METER_BUFFER_LEN - 1);\n\n   w -= 2;\n   attrset(CRT_colors[METER_TEXT]);\n   int captionLen = 3;\n   mvaddnstr(y, x, this->caption, captionLen);\n   x += captionLen;\n   w -= captionLen;\n   attrset(CRT_colors[BAR_BORDER]);\n   mvaddch(y, x, '[');\n   mvaddch(y, x + w, ']');\n   \n   w--;\n   x++;\n\n   if (w < 1) {\n      attrset(CRT_colors[RESET_COLOR]);\n      return;\n   }\n   char bar[w + 1];\n   \n   int blockSizes[10];\n\n   xSnprintf(bar, w + 1, \"%*.*s\", w, w, buffer);\n\n   // First draw in the bar[] buffer...\n   int offset = 0;\n   int items = Meter_getItems(this);\n   for (int i = 0; i < items; i++) {\n      double value = this->values[i];\n      value = CLAMP(value, 0.0, this->total);\n      if (value > 0) {\n         blockSizes[i] = ceil((value/this->total) * w);\n      } else {\n         blockSizes[i] = 0;\n      }\n      int nextOffset = offset + blockSizes[i];\n      // (Control against invalid values)\n      nextOffset = CLAMP(nextOffset, 0, w);\n      for (int j = offset; j < nextOffset; j++)\n         if (bar[j] == ' ') {\n            if (CRT_colorScheme == COLORSCHEME_MONOCHROME) {\n               bar[j] = BarMeterMode_characters[i];\n            } else {\n               bar[j] = '|';\n            }\n         }\n      offset = nextOffset;\n   }\n\n   // ...then print the buffer.\n   offset = 0;\n   for (int i = 0; i < items; i++) {\n      attrset(CRT_colors[Meter_attributes(this)[i]]);\n      mvaddnstr(y, x + offset, bar + offset, blockSizes[i]);\n      offset += blockSizes[i];\n      offset = CLAMP(offset, 0, w);\n   }\n   if (offset < w) {\n      attrset(CRT_colors[BAR_SHADOW]);\n      mvaddnstr(y, x + offset, bar + offset, w - offset);\n   }\n\n   move(y, x + w + 1);\n   attrset(CRT_colors[RESET_COLOR]);\n}\n\n/* ---------- GraphMeterMode ---------- */\n\n#ifdef HAVE_LIBNCURSESW\n\n#define PIXPERROW_UTF8 4\nstatic const char* const GraphMeterMode_dotsUtf8[] = {\n   /*00*/\" \", /*01*/\"\", /*02*/\"\", /*03*/\"\", /*04*/ \"\",\n   /*10*/\"\", /*11*/\"\", /*12*/\"\", /*13*/\"\", /*14*/ \"\",\n   /*20*/\"\", /*21*/\"\", /*22*/\"\", /*23*/\"\", /*24*/ \"\",\n   /*30*/\"\", /*31*/\"\", /*32*/\"\", /*33*/\"\", /*34*/ \"\",\n   /*40*/\"\", /*41*/\"\", /*42*/\"\", /*43*/\"\", /*44*/ \"\"\n};\n\n#endif\n\n#define PIXPERROW_ASCII 2\nstatic const char* const GraphMeterMode_dotsAscii[] = {\n   /*00*/\" \", /*01*/\".\", /*02*/\":\",\n   /*10*/\".\", /*11*/\".\", /*12*/\":\",\n   /*20*/\":\", /*21*/\":\", /*22*/\":\"\n};\n\nstatic const char* const* GraphMeterMode_dots;\nstatic int GraphMeterMode_pixPerRow;\n\nstatic void GraphMeterMode_draw(Meter* this, int x, int y, int w) {\n\n   if (!this->drawData) this->drawData = xCalloc(1, sizeof(GraphData));\n   GraphData* data = (GraphData*) this->drawData;\n   const int nValues = METER_BUFFER_LEN;\n\n#ifdef HAVE_LIBNCURSESW\n   if (CRT_utf8) {\n      GraphMeterMode_dots = GraphMeterMode_dotsUtf8;\n      GraphMeterMode_pixPerRow = PIXPERROW_UTF8;\n   } else\n#endif\n   {\n      GraphMeterMode_dots = GraphMeterMode_dotsAscii;\n      GraphMeterMode_pixPerRow = PIXPERROW_ASCII;\n   }\n\n   attrset(CRT_colors[METER_TEXT]);\n   int captionLen = 3;\n   mvaddnstr(y, x, this->caption, captionLen);\n   x += captionLen;\n   w -= captionLen;\n   \n   struct timeval now;\n   gettimeofday(&now, NULL);\n   if (!timercmp(&now, &(data->time), <)) {\n      struct timeval delay = { .tv_sec = (int)(CRT_delay/10), .tv_usec = (CRT_delay-((int)(CRT_delay/10)*10)) * 100000 };\n      timeradd(&now, &delay, &(data->time));\n\n      for (int i = 0; i < nValues - 1; i++)\n         data->values[i] = data->values[i+1];\n   \n      char buffer[nValues];\n      Meter_updateValues(this, buffer, nValues - 1);\n   \n      double value = 0.0;\n      int items = Meter_getItems(this);\n      for (int i = 0; i < items; i++)\n         value += this->values[i];\n      value /= this->total;\n      data->values[nValues - 1] = value;\n   }\n   \n   int i = nValues - (w*2) + 2, k = 0;\n   if (i < 0) {\n      k = -i/2;\n      i = 0;\n   }\n   for (; i < nValues - 1; i+=2, k++) {\n      int pix = GraphMeterMode_pixPerRow * GRAPH_HEIGHT;\n      int v1 = CLAMP((int) lround(data->values[i] * pix), 1, pix);\n      int v2 = CLAMP((int) lround(data->values[i+1] * pix), 1, pix);\n\n      int colorIdx = GRAPH_1;\n      for (int line = 0; line < GRAPH_HEIGHT; line++) {\n         int line1 = CLAMP(v1 - (GraphMeterMode_pixPerRow * (GRAPH_HEIGHT - 1 - line)), 0, GraphMeterMode_pixPerRow);\n         int line2 = CLAMP(v2 - (GraphMeterMode_pixPerRow * (GRAPH_HEIGHT - 1 - line)), 0, GraphMeterMode_pixPerRow);\n\n         attrset(CRT_colors[colorIdx]);\n         mvaddstr(y+line, x+k, GraphMeterMode_dots[line1 * (GraphMeterMode_pixPerRow + 1) + line2]);\n         colorIdx = GRAPH_2;\n      }\n   }\n   attrset(CRT_colors[RESET_COLOR]);\n}\n\n/* ---------- LEDMeterMode ---------- */\n\nstatic const char* const LEDMeterMode_digitsAscii[] = {\n   \" __ \",\"    \",\" __ \",\" __ \",\"    \",\" __ \",\" __ \",\" __ \",\" __ \",\" __ \",\n   \"|  |\",\"   |\",\" __|\",\" __|\",\"|__|\",\"|__ \",\"|__ \",\"   |\",\"|__|\",\"|__|\",\n   \"|__|\",\"   |\",\"|__ \",\" __|\",\"   |\",\" __|\",\"|__|\",\"   |\",\"|__|\",\" __|\"\n};\n\n#ifdef HAVE_LIBNCURSESW\n\nstatic const char* const LEDMeterMode_digitsUtf8[] = {\n   \"\",\"   \",\"\",\"\",\"  \",\"\",\"\",\"\",\"\",\"\",\n   \"  \",\"   \",\"\",\" \",\"\",\"\",\"\",\"   \",\"\",\"\",\n   \"\",\"   \",\"\",\"\",\"   \",\"\",\"\",\"   \",\"\",\" \"\n};\n\n#endif\n\nstatic const char* const* LEDMeterMode_digits;\n\nstatic void LEDMeterMode_drawDigit(int x, int y, int n) {\n   for (int i = 0; i < 3; i++)\n      mvaddstr(y+i, x, LEDMeterMode_digits[i * 10 + n]);\n}\n\nstatic void LEDMeterMode_draw(Meter* this, int x, int y, int w) {\n   (void) w;\n\n#ifdef HAVE_LIBNCURSESW\n   if (CRT_utf8)\n      LEDMeterMode_digits = LEDMeterMode_digitsUtf8;\n   else\n#endif\n      LEDMeterMode_digits = LEDMeterMode_digitsAscii;\n\n   char buffer[METER_BUFFER_LEN];\n   Meter_updateValues(this, buffer, METER_BUFFER_LEN - 1);\n   \n   RichString_begin(out);\n   Meter_displayBuffer(this, buffer, &out);\n\n   int yText =\n#ifdef HAVE_LIBNCURSESW\n      CRT_utf8 ? y+1 :\n#endif\n      y+2;\n   attrset(CRT_colors[LED_COLOR]);\n   mvaddstr(yText, x, this->caption);\n   int xx = x + strlen(this->caption);\n   int len = RichString_sizeVal(out);\n   for (int i = 0; i < len; i++) {\n      char c = RichString_getCharVal(out, i);\n      if (c >= '0' && c <= '9') {\n         LEDMeterMode_drawDigit(xx, y, c-48);\n         xx += 4;\n      } else {\n         mvaddch(yText, xx, c);\n         xx += 1;\n      }\n   }\n   attrset(CRT_colors[RESET_COLOR]);\n   RichString_end(out);\n}\n\nstatic MeterMode BarMeterMode = {\n   .uiName = \"Bar\",\n   .h = 1,\n   .draw = BarMeterMode_draw,\n};\n\nstatic MeterMode TextMeterMode = {\n   .uiName = \"Text\",\n   .h = 1,\n   .draw = TextMeterMode_draw,\n};\n\nstatic MeterMode GraphMeterMode = {\n   .uiName = \"Graph\",\n   .h = GRAPH_HEIGHT,\n   .draw = GraphMeterMode_draw,\n};\n\nstatic MeterMode LEDMeterMode = {\n   .uiName = \"LED\",\n   .h = 3,\n   .draw = LEDMeterMode_draw,\n};\n\nMeterMode* Meter_modes[] = {\n   NULL,\n   &BarMeterMode,\n   &TextMeterMode,\n   &GraphMeterMode,\n   &LEDMeterMode,\n   NULL\n};\n\n/* Blank meter */\n\nstatic void BlankMeter_updateValues(Meter* this, char* buffer, int size) {\n   (void) this; (void) buffer; (void) size;\n}\n\nstatic void BlankMeter_display(Object* cast, RichString* out) {\n   (void) cast;\n   RichString_prune(out);\n}\n\nint BlankMeter_attributes[] = {\n   DEFAULT_COLOR\n};\n\nMeterClass BlankMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = BlankMeter_display,\n   },\n   .updateValues = BlankMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .maxItems = 0,\n   .total = 100.0,\n   .attributes = BlankMeter_attributes,\n   .name = \"Blank\",\n   .uiName = \"Blank\",\n   .caption = \"\"\n};\n"
        },
        {
          "name": "Meter.h",
          "type": "blob",
          "size": 3.673828125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_Meter\n#define HEADER_Meter\n/*\nhtop - Meter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#define METER_BUFFER_LEN 256\n\n#define GRAPH_DELAY (DEFAULT_DELAY/2)\n\n#define GRAPH_HEIGHT 4 /* Unit: rows (lines) */\n\n#include \"ListItem.h\"\n\n#include <sys/time.h>\n\ntypedef struct Meter_ Meter;\n\ntypedef void(*Meter_Init)(Meter*);\ntypedef void(*Meter_Done)(Meter*);\ntypedef void(*Meter_UpdateMode)(Meter*, int);\ntypedef void(*Meter_UpdateValues)(Meter*, char*, int);\ntypedef void(*Meter_Draw)(Meter*, int, int, int);\n\ntypedef struct MeterClass_ {\n   ObjectClass super;\n   const Meter_Init init;\n   const Meter_Done done;\n   const Meter_UpdateMode updateMode;\n   const Meter_Draw draw;\n   const Meter_UpdateValues updateValues;\n   const int defaultMode;\n   const double total;\n   const int* attributes;\n   const char* name;\n   const char* uiName;\n   const char* caption;\n   const char* description;\n   const char maxItems;\n   char curItems;\n} MeterClass;\n\n#define As_Meter(this_)                ((MeterClass*)((this_)->super.klass))\n#define Meter_initFn(this_)            As_Meter(this_)->init\n#define Meter_init(this_)              As_Meter(this_)->init((Meter*)(this_))\n#define Meter_done(this_)              As_Meter(this_)->done((Meter*)(this_))\n#define Meter_updateModeFn(this_)      As_Meter(this_)->updateMode\n#define Meter_updateMode(this_, m_)    As_Meter(this_)->updateMode((Meter*)(this_), m_)\n#define Meter_drawFn(this_)            As_Meter(this_)->draw\n#define Meter_doneFn(this_)            As_Meter(this_)->done\n#define Meter_updateValues(this_, buf_, sz_) \\\n                                       As_Meter(this_)->updateValues((Meter*)(this_), buf_, sz_)\n#define Meter_defaultMode(this_)       As_Meter(this_)->defaultMode\n#define Meter_getItems(this_)          As_Meter(this_)->curItems\n#define Meter_setItems(this_, n_)      As_Meter(this_)->curItems = (n_)\n#define Meter_attributes(this_)        As_Meter(this_)->attributes\n#define Meter_name(this_)              As_Meter(this_)->name\n#define Meter_uiName(this_)            As_Meter(this_)->uiName\n\nstruct Meter_ {\n   Object super;\n   Meter_Draw draw;\n   \n   char* caption;\n   int mode;\n   int param;\n   void* drawData;\n   int h;\n   struct ProcessList_* pl;\n   double* values;\n   double total;\n};\n\ntypedef struct MeterMode_ {\n   Meter_Draw draw;\n   const char* uiName;\n   int h;\n} MeterMode;\n\ntypedef enum {\n   CUSTOM_METERMODE = 0,\n   BAR_METERMODE,\n   TEXT_METERMODE,\n   GRAPH_METERMODE,\n   LED_METERMODE,\n   LAST_METERMODE\n} MeterModeId;\n\ntypedef struct GraphData_ {\n   struct timeval time;\n   double values[METER_BUFFER_LEN];\n} GraphData;\n\n\n#ifndef MIN\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#endif\n#ifndef MAX\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#endif\n#ifndef CLAMP\n#define CLAMP(x,low,high) (((x)>(high))?(high):(((x)<(low))?(low):(x)))\n#endif\n\nextern MeterClass Meter_class;\n\nMeter* Meter_new(struct ProcessList_* pl, int param, MeterClass* type);\n\nint Meter_humanUnit(char* buffer, unsigned long int value, int size);\n\nvoid Meter_delete(Object* cast);\n\nvoid Meter_setCaption(Meter* this, const char* caption);\n\nvoid Meter_setMode(Meter* this, int modeIndex);\n\nListItem* Meter_toListItem(Meter* this, bool moving);\n\n/* ---------- TextMeterMode ---------- */\n\n/* ---------- BarMeterMode ---------- */\n\n/* ---------- GraphMeterMode ---------- */\n\n#ifdef HAVE_LIBNCURSESW\n\n#define PIXPERROW_UTF8 4\n#endif\n\n#define PIXPERROW_ASCII 2\n\n/* ---------- LEDMeterMode ---------- */\n\n#ifdef HAVE_LIBNCURSESW\n\n#endif\n\nextern MeterMode* Meter_modes[];\n\n/* Blank meter */\n\nextern int BlankMeter_attributes[];\n\nextern MeterClass BlankMeter_class;\n\n#endif\n"
        },
        {
          "name": "MetersPanel.c",
          "type": "blob",
          "size": 6.7314453125,
          "content": "/*\nhtop - MetersPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"MetersPanel.h\"\n\n#include <stdlib.h>\n#include <assert.h>\n#include \"CRT.h\"\n\n/*{\n#include \"Panel.h\"\n#include \"Settings.h\"\n#include \"ScreenManager.h\"\n\ntypedef struct MetersPanel_ MetersPanel;\n\nstruct MetersPanel_ {\n   Panel super;\n\n   Settings* settings;\n   Vector* meters;\n   ScreenManager* scr;\n   MetersPanel* leftNeighbor;\n   MetersPanel* rightNeighbor;\n   bool moving;\n};\n\n}*/\n\n// Note: In code the meters are known to have bar/text/graph \"Modes\", but in UI\n// we call them \"Styles\".\nstatic const char* const MetersFunctions[] = {\"Style \", \"Move  \", \"                                       \", \"Delete\", \"Done  \", NULL};\nstatic const char* const MetersKeys[] = {\"Space\", \"Enter\", \"  \", \"Del\", \"F10\"};\nstatic int MetersEvents[] = {' ', 13, ERR, KEY_DC, KEY_F(10)};\n\n// We avoid UTF-8 arrows   here as they might display full-width on Chinese\n// terminals, breaking our aligning.\n// In <http://unicode.org/reports/tr11/>, arrows (U+2019..U+2199) are\n// considered \"Ambiguous characters\".\nstatic const char* const MetersMovingFunctions[] = {\"Style \", \"Lock  \", \"Up    \", \"Down  \", \"Left  \", \"Right \", \"       \", \"Delete\", \"Done  \", NULL};\nstatic const char* const MetersMovingKeys[] = {\"Space\", \"Enter\", \"Up\", \"Dn\", \"<-\", \"->\", \"  \", \"Del\", \"F10\"};\nstatic int MetersMovingEvents[] = {' ', 13, KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, ERR, KEY_DC, KEY_F(10)};\nstatic FunctionBar* Meters_movingBar = NULL;\n\nstatic void MetersPanel_delete(Object* object) {\n   Panel* super = (Panel*) object;\n   MetersPanel* this = (MetersPanel*) object;\n   Panel_done(super);\n   free(this);\n}\n\nvoid MetersPanel_setMoving(MetersPanel* this, bool moving) {\n   Panel* super = (Panel*) this;\n   this->moving = moving;\n   ListItem* selected = (ListItem*)Panel_getSelected(super);\n   if (selected) {\n      selected->moving = moving;\n   }\n   if (!moving) {\n      Panel_setSelectionColor(super, CRT_colors[PANEL_SELECTION_FOCUS]);\n      Panel_setDefaultBar(super);\n   } else {\n      Panel_setSelectionColor(super, CRT_colors[PANEL_SELECTION_FOLLOW]);\n      super->currentBar = Meters_movingBar;\n   }\n   FunctionBar_draw(this->super.currentBar, NULL);\n}\n\nstatic inline bool moveToNeighbor(MetersPanel* this, MetersPanel* neighbor, int selected) {\n   Panel* super = (Panel*) this;\n   if (this->moving) {\n      if (neighbor) {\n         if (selected < Vector_size(this->meters)) {\n            MetersPanel_setMoving(this, false);\n\n            Meter* meter = (Meter*) Vector_take(this->meters, selected);\n            Panel_remove(super, selected);\n            Vector_insert(neighbor->meters, selected, meter);\n            Panel_insert(&(neighbor->super), selected, (Object*) Meter_toListItem(meter, false));\n            Panel_setSelected(&(neighbor->super), selected);\n\n            MetersPanel_setMoving(neighbor, true);\n            return true;\n         }\n      }\n   }\n   return false;\n}\n\nstatic HandlerResult MetersPanel_eventHandler(Panel* super, int ch) {\n   MetersPanel* this = (MetersPanel*) super;\n   \n   int selected = Panel_getSelectedIndex(super);\n   HandlerResult result = IGNORED;\n   bool sideMove = false;\n\n   switch(ch) {\n      case 0x0a:\n      case 0x0d:\n      case KEY_ENTER:\n      {\n         if (!Vector_size(this->meters))\n            break;\n         MetersPanel_setMoving(this, !(this->moving));\n         result = HANDLED;\n         break;\n      }\n      case ' ':\n      case KEY_F(4):\n      case 't':\n      {\n         if (!Vector_size(this->meters))\n            break;\n         Meter* meter = (Meter*) Vector_get(this->meters, selected);\n         int mode = meter->mode + 1;\n         if (mode == LAST_METERMODE) mode = 1;\n         Meter_setMode(meter, mode);\n         Panel_set(super, selected, (Object*) Meter_toListItem(meter, this->moving));\n         result = HANDLED;\n         break;\n      }\n      case KEY_UP:\n      {\n         if (!this->moving) {\n            break;\n         }\n      }\n         /* else fallthrough */\n      case KEY_F(7):\n      case '[':\n      case '-':\n      {\n         Vector_moveUp(this->meters, selected);\n         Panel_moveSelectedUp(super);\n         result = HANDLED;\n         break;\n      }\n      case KEY_DOWN:\n      {\n         if (!this->moving) {\n            break;\n         }\n      }\n         /* else fallthrough */\n      case KEY_F(8):\n      case ']':\n      case '+':\n      {\n         Vector_moveDown(this->meters, selected);\n         Panel_moveSelectedDown(super);\n         result = HANDLED;\n         break;\n      }\n      case KEY_RIGHT:\n      {\n         sideMove = moveToNeighbor(this, this->rightNeighbor, selected);\n         if (this->moving && !sideMove) {\n            // lock user here until it exits positioning-mode\n            result = HANDLED;\n         }\n         // if user is free, don't set HANDLED;\n         // let ScreenManager handle focus.\n         break;\n      }\n      case KEY_LEFT:\n      {\n         sideMove = moveToNeighbor(this, this->leftNeighbor, selected);\n         if (this->moving && !sideMove) {\n            result = HANDLED;\n         }\n         break;\n      }\n      case KEY_F(9):\n      case KEY_DC:\n      {\n         if (!Vector_size(this->meters))\n            break;\n         if (selected < Vector_size(this->meters)) {\n            Vector_remove(this->meters, selected);\n            Panel_remove(super, selected);\n         }\n         MetersPanel_setMoving(this, false);\n         result = HANDLED;\n         break;\n      }\n   }\n   if (result == HANDLED || sideMove) {\n      Header* header = (Header*) this->scr->header;\n      this->settings->changed = true;\n      Header_calculateHeight(header);\n      Header_draw(header);\n      ScreenManager_resize(this->scr, this->scr->x1, header->height, this->scr->x2, this->scr->y2);\n   }\n   return result;\n}\n\nPanelClass MetersPanel_class = {\n   .super = {\n      .extends = Class(Panel),\n      .delete = MetersPanel_delete\n   },\n   .eventHandler = MetersPanel_eventHandler\n};\n\nMetersPanel* MetersPanel_new(Settings* settings, const char* header, Vector* meters, ScreenManager* scr) {\n   MetersPanel* this = AllocThis(MetersPanel);\n   Panel* super = (Panel*) this;\n   FunctionBar* fuBar = FunctionBar_new(MetersFunctions, MetersKeys, MetersEvents);\n   if (!Meters_movingBar) {\n      Meters_movingBar = FunctionBar_new(MetersMovingFunctions, MetersMovingKeys, MetersMovingEvents);\n   }\n   Panel_init(super, 1, 1, 1, 1, Class(ListItem), true, fuBar);\n\n   this->settings = settings;\n   this->meters = meters;\n   this->scr = scr;\n   this->moving = false;\n   this->rightNeighbor = NULL;\n   this->leftNeighbor = NULL;\n   Panel_setHeader(super, header);\n   for (int i = 0; i < Vector_size(meters); i++) {\n      Meter* meter = (Meter*) Vector_get(meters, i);\n      Panel_add(super, (Object*) Meter_toListItem(meter, false));\n   }\n   return this;\n}\n"
        },
        {
          "name": "MetersPanel.h",
          "type": "blob",
          "size": 1.08984375,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_MetersPanel\n#define HEADER_MetersPanel\n/*\nhtop - MetersPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Panel.h\"\n#include \"Settings.h\"\n#include \"ScreenManager.h\"\n\ntypedef struct MetersPanel_ MetersPanel;\n\nstruct MetersPanel_ {\n   Panel super;\n\n   Settings* settings;\n   Vector* meters;\n   ScreenManager* scr;\n   MetersPanel* leftNeighbor;\n   MetersPanel* rightNeighbor;\n   bool moving;\n};\n\n\n// Note: In code the meters are known to have bar/text/graph \"Modes\", but in UI\n// we call them \"Styles\".\n// We avoid UTF-8 arrows   here as they might display full-width on Chinese\n// terminals, breaking our aligning.\n// In <http://unicode.org/reports/tr11/>, arrows (U+2019..U+2199) are\n// considered \"Ambiguous characters\".\n\nvoid MetersPanel_setMoving(MetersPanel* this, bool moving);\n\nextern PanelClass MetersPanel_class;\n\nMetersPanel* MetersPanel_new(Settings* settings, const char* header, Vector* meters, ScreenManager* scr);\n\n#endif\n"
        },
        {
          "name": "NEWS",
          "type": "blob",
          "size": 0.12890625,
          "content": "\nSee the commit history for news of the past.\nSee the bug tracker for news of the future.\nRun the program for news of the present.\n\n"
        },
        {
          "name": "Object.c",
          "type": "blob",
          "size": 1.568359375,
          "content": "/*\nhtop - Object.c\n(C) 2004-2012 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Object.h\"\n\n/*{\n#include \"RichString.h\"\n#include \"XAlloc.h\"\n\ntypedef struct Object_ Object;\n\ntypedef void(*Object_Display)(Object*, RichString*);\ntypedef long(*Object_Compare)(const void*, const void*);\ntypedef void(*Object_Delete)(Object*);\n\n#define Object_getClass(obj_)         ((Object*)(obj_))->klass\n#define Object_setClass(obj_, class_) Object_getClass(obj_) = (ObjectClass*) class_\n\n#define Object_delete(obj_)           Object_getClass(obj_)->delete((Object*)(obj_))\n#define Object_displayFn(obj_)        Object_getClass(obj_)->display\n#define Object_display(obj_, str_)    Object_getClass(obj_)->display((Object*)(obj_), str_)\n#define Object_compare(obj_, other_)  Object_getClass(obj_)->compare((const void*)(obj_), other_)\n\n#define Class(class_)                 ((ObjectClass*)(&(class_ ## _class)))\n\n#define AllocThis(class_) (class_*) xMalloc(sizeof(class_)); Object_setClass(this, Class(class_));\n \ntypedef struct ObjectClass_ {\n   const void* extends;\n   const Object_Display display;\n   const Object_Delete delete;\n   const Object_Compare compare;\n} ObjectClass;\n\nstruct Object_ {\n   ObjectClass* klass;\n};\n\n}*/\n\nObjectClass Object_class = {\n   .extends = NULL\n};\n\n#ifdef DEBUG\n\nbool Object_isA(Object* o, const ObjectClass* klass) {\n   if (!o)\n      return false;\n   const ObjectClass* type = o->klass;\n   while (type) {\n      if (type == klass)\n         return true;\n      type = type->extends;\n   }\n   return false;\n}\n\n#endif\n"
        },
        {
          "name": "Object.h",
          "type": "blob",
          "size": 1.4501953125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_Object\n#define HEADER_Object\n/*\nhtop - Object.h\n(C) 2004-2012 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"RichString.h\"\n#include \"XAlloc.h\"\n\ntypedef struct Object_ Object;\n\ntypedef void(*Object_Display)(Object*, RichString*);\ntypedef long(*Object_Compare)(const void*, const void*);\ntypedef void(*Object_Delete)(Object*);\n\n#define Object_getClass(obj_)         ((Object*)(obj_))->klass\n#define Object_setClass(obj_, class_) Object_getClass(obj_) = (ObjectClass*) class_\n\n#define Object_delete(obj_)           Object_getClass(obj_)->delete((Object*)(obj_))\n#define Object_displayFn(obj_)        Object_getClass(obj_)->display\n#define Object_display(obj_, str_)    Object_getClass(obj_)->display((Object*)(obj_), str_)\n#define Object_compare(obj_, other_)  Object_getClass(obj_)->compare((const void*)(obj_), other_)\n\n#define Class(class_)                 ((ObjectClass*)(&(class_ ## _class)))\n\n#define AllocThis(class_) (class_*) xMalloc(sizeof(class_)); Object_setClass(this, Class(class_));\n \ntypedef struct ObjectClass_ {\n   const void* extends;\n   const Object_Display display;\n   const Object_Delete delete;\n   const Object_Compare compare;\n} ObjectClass;\n\nstruct Object_ {\n   ObjectClass* klass;\n};\n\n\nextern ObjectClass Object_class;\n\n#ifdef DEBUG\n\nbool Object_isA(Object* o, const ObjectClass* klass);\n\n#endif\n\n#endif\n"
        },
        {
          "name": "OpenFilesScreen.c",
          "type": "blob",
          "size": 4.9326171875,
          "content": "/*\nhtop - OpenFilesScreen.c\n(C) 2005-2006 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"OpenFilesScreen.h\"\n\n#include \"CRT.h\"\n#include \"ProcessList.h\"\n#include \"IncSet.h\"\n#include \"StringUtils.h\"\n#include \"FunctionBar.h\"\n\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n/*{\n#include \"InfoScreen.h\"\n\ntypedef struct OpenFiles_Data_ {\n   char* data[256];\n} OpenFiles_Data;\n\ntypedef struct OpenFiles_ProcessData_ {\n   OpenFiles_Data data;\n   int error;\n   struct OpenFiles_FileData_* files;\n} OpenFiles_ProcessData;\n\ntypedef struct OpenFiles_FileData_ {\n   OpenFiles_Data data;\n   struct OpenFiles_FileData_* next;\n} OpenFiles_FileData;\n\ntypedef struct OpenFilesScreen_ {\n   InfoScreen super;\n   pid_t pid;\n} OpenFilesScreen;\n\n}*/\n\nInfoScreenClass OpenFilesScreen_class = {\n   .super = {\n      .extends = Class(Object),\n      .delete = OpenFilesScreen_delete\n   },\n   .scan = OpenFilesScreen_scan,\n   .draw = OpenFilesScreen_draw\n};\n\nOpenFilesScreen* OpenFilesScreen_new(Process* process) {\n   OpenFilesScreen* this = xMalloc(sizeof(OpenFilesScreen));\n   Object_setClass(this, Class(OpenFilesScreen));\n   if (Process_isThread(process))\n      this->pid = process->tgid;\n   else\n      this->pid = process->pid;\n   return (OpenFilesScreen*) InfoScreen_init(&this->super, process, NULL, LINES-3, \"   FD TYPE     DEVICE       SIZE       NODE NAME\");\n}\n\nvoid OpenFilesScreen_delete(Object* this) {\n   free(InfoScreen_done((InfoScreen*)this));\n}\n\nvoid OpenFilesScreen_draw(InfoScreen* this) {\n   InfoScreen_drawTitled(this, \"Snapshot of files open in process %d - %s\", ((OpenFilesScreen*)this)->pid, this->process->comm);\n}\n\nstatic OpenFiles_ProcessData* OpenFilesScreen_getProcessData(pid_t pid) {\n   char buffer[1025];\n   xSnprintf(buffer, 1024, \"%d\", pid);\n   OpenFiles_ProcessData* pdata = xCalloc(1, sizeof(OpenFiles_ProcessData));\n   OpenFiles_FileData* fdata = NULL;\n   OpenFiles_Data* item = &(pdata->data);\n   int fdpair[2];\n   if (pipe(fdpair) == -1) {\n      pdata->error = 1;\n      return pdata;\n   }\n   pid_t child = fork();\n   if (child == -1) {\n      pdata->error = 1;\n      return pdata;\n   }\n   if (child == 0) {\n      close(fdpair[0]);\n      dup2(fdpair[1], STDOUT_FILENO);\n      close(fdpair[1]);\n      int fdnull = open(\"/dev/null\", O_WRONLY);\n      if (fdnull < 0)\n         exit(1);\n      dup2(fdnull, STDERR_FILENO);\n      close(fdnull);\n      execlp(\"lsof\", \"lsof\", \"-P\", \"-p\", buffer, \"-F\", NULL);\n      exit(127);\n   }\n   close(fdpair[1]);\n   FILE* fd = fdopen(fdpair[0], \"r\");\n   for (;;) {\n      char* line = String_readLine(fd);\n      if (!line) {\n         break;\n      }\n      unsigned char cmd = line[0];\n      if (cmd == 'f') {\n         OpenFiles_FileData* nextFile = xCalloc(1, sizeof(OpenFiles_FileData));\n         if (fdata == NULL) {\n            pdata->files = nextFile;\n         } else {\n            fdata->next = nextFile;\n         }\n         fdata = nextFile;\n         item = &(fdata->data);\n      }\n      item->data[cmd] = xStrdup(line + 1);\n      free(line);\n   }\n   int wstatus;\n   if (waitpid(child, &wstatus, 0) == -1) {\n      pdata->error = 1;\n      return pdata;\n   }\n   if (!WIFEXITED(wstatus))\n      pdata->error = 1;\n   else\n      pdata->error = WEXITSTATUS(wstatus);\n   return pdata;\n}\n\nstatic inline void OpenFiles_Data_clear(OpenFiles_Data* data) {\n   for (int i = 0; i < 255; i++)\n      if (data->data[i])\n         free(data->data[i]);\n}\n\nvoid OpenFilesScreen_scan(InfoScreen* this) {\n   Panel* panel = this->display;\n   int idx = Panel_getSelectedIndex(panel);\n   Panel_prune(panel);\n   OpenFiles_ProcessData* pdata = OpenFilesScreen_getProcessData(((OpenFilesScreen*)this)->pid);\n   if (pdata->error == 127) {\n      InfoScreen_addLine(this, \"Could not execute 'lsof'. Please make sure it is available in your $PATH.\");\n   } else if (pdata->error == 1) {\n      InfoScreen_addLine(this, \"Failed listing open files.\");\n   } else {\n      OpenFiles_FileData* fdata = pdata->files;\n      while (fdata) {\n         char** data = fdata->data.data;\n         int lenN = data['n'] ? strlen(data['n']) : 0;\n         int sizeEntry = 5 + 7 + 10 + 10 + 10 + lenN + 5 /*spaces*/ + 1 /*null*/;\n         char entry[sizeEntry];\n         xSnprintf(entry, sizeEntry, \"%5.5s %7.7s %10.10s %10.10s %10.10s %s\",\n            data['f'] ? data['f'] : \"\",\n            data['t'] ? data['t'] : \"\",\n            data['D'] ? data['D'] : \"\",\n            data['s'] ? data['s'] : \"\",\n            data['i'] ? data['i'] : \"\",\n            data['n'] ? data['n'] : \"\");\n         InfoScreen_addLine(this, entry);\n         OpenFiles_Data_clear(&fdata->data);\n         OpenFiles_FileData* old = fdata;\n         fdata = fdata->next;\n         free(old);\n      }\n      OpenFiles_Data_clear(&pdata->data);\n   }\n   free(pdata);\n   Vector_insertionSort(this->lines);\n   Vector_insertionSort(panel->items);\n   Panel_setSelected(panel, idx);\n}\n"
        },
        {
          "name": "OpenFilesScreen.h",
          "type": "blob",
          "size": 0.9580078125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_OpenFilesScreen\n#define HEADER_OpenFilesScreen\n/*\nhtop - OpenFilesScreen.h\n(C) 2005-2006 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"InfoScreen.h\"\n\ntypedef struct OpenFiles_Data_ {\n   char* data[256];\n} OpenFiles_Data;\n\ntypedef struct OpenFiles_ProcessData_ {\n   OpenFiles_Data data;\n   int error;\n   struct OpenFiles_FileData_* files;\n} OpenFiles_ProcessData;\n\ntypedef struct OpenFiles_FileData_ {\n   OpenFiles_Data data;\n   struct OpenFiles_FileData_* next;\n} OpenFiles_FileData;\n\ntypedef struct OpenFilesScreen_ {\n   InfoScreen super;\n   pid_t pid;\n} OpenFilesScreen;\n\n\nextern InfoScreenClass OpenFilesScreen_class;\n\nOpenFilesScreen* OpenFilesScreen_new(Process* process);\n\nvoid OpenFilesScreen_delete(Object* this);\n\nvoid OpenFilesScreen_draw(InfoScreen* this);\n\nvoid OpenFilesScreen_scan(InfoScreen* this);\n\n#endif\n"
        },
        {
          "name": "Panel.c",
          "type": "blob",
          "size": 12.4462890625,
          "content": "/*\nhtop - Panel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Panel.h\"\n\n#include \"CRT.h\"\n#include \"RichString.h\"\n#include \"ListItem.h\"\n#include \"StringUtils.h\"\n\n#include <math.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <assert.h>\n\n//#link curses\n\n/*{\n#include \"Object.h\"\n#include \"Vector.h\"\n#include \"FunctionBar.h\"\n\ntypedef struct Panel_ Panel;\n\ntypedef enum HandlerResult_ {\n   HANDLED     = 0x01,\n   IGNORED     = 0x02,\n   BREAK_LOOP  = 0x04,\n   REDRAW      = 0x08,\n   RESCAN      = 0x10,\n   SYNTH_KEY   = 0x20,\n} HandlerResult;\n\n#define EVENT_SET_SELECTED -1\n\n#define EVENT_HEADER_CLICK(x_) (-10000 + x_)\n#define EVENT_IS_HEADER_CLICK(ev_) (ev_ >= -10000 && ev_ <= -9000)\n#define EVENT_HEADER_CLICK_GET_X(ev_) (ev_ + 10000)\n\ntypedef HandlerResult(*Panel_EventHandler)(Panel*, int);\n\ntypedef struct PanelClass_ {\n   const ObjectClass super;\n   const Panel_EventHandler eventHandler;\n} PanelClass;\n\n#define As_Panel(this_)                ((PanelClass*)((this_)->super.klass))\n#define Panel_eventHandlerFn(this_)    As_Panel(this_)->eventHandler\n#define Panel_eventHandler(this_, ev_) As_Panel(this_)->eventHandler((Panel*)(this_), ev_)\n\nstruct Panel_ {\n   Object super;\n   int x, y, w, h;\n   WINDOW* window;\n   Vector* items;\n   int selected;\n   int oldSelected;\n   int selectedLen;\n   void* eventHandlerState;\n   int scrollV;\n   short scrollH;\n   bool needsRedraw;\n   FunctionBar* currentBar;\n   FunctionBar* defaultBar;\n   RichString header;\n   int selectionColor;\n};\n\n#define Panel_setDefaultBar(this_) do{ (this_)->currentBar = (this_)->defaultBar; }while(0)\n\n}*/\n\n#ifndef MIN\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#endif\n#ifndef MAX\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#endif\n\n#define KEY_CTRL(l) ((l)-'A'+1)\n\nPanelClass Panel_class = {\n   .super = {\n      .extends = Class(Object),\n      .delete = Panel_delete\n   },\n   .eventHandler = Panel_selectByTyping,\n};\n\nPanel* Panel_new(int x, int y, int w, int h, bool owner, ObjectClass* type, FunctionBar* fuBar) {\n   Panel* this;\n   this = xMalloc(sizeof(Panel));\n   Object_setClass(this, Class(Panel));\n   Panel_init(this, x, y, w, h, type, owner, fuBar);\n   return this;\n}\n\nvoid Panel_delete(Object* cast) {\n   Panel* this = (Panel*)cast;\n   Panel_done(this);\n   free(this);\n}\n\nvoid Panel_init(Panel* this, int x, int y, int w, int h, ObjectClass* type, bool owner, FunctionBar* fuBar) {\n   this->x = x;\n   this->y = y;\n   this->w = w;\n   this->h = h;\n   this->eventHandlerState = NULL;\n   this->items = Vector_new(type, owner, DEFAULT_SIZE);\n   this->scrollV = 0;\n   this->scrollH = 0;\n   this->selected = 0;\n   this->oldSelected = 0;\n   this->needsRedraw = true;\n   RichString_beginAllocated(this->header);\n   this->defaultBar = fuBar;\n   this->currentBar = fuBar;\n   this->selectionColor = CRT_colors[PANEL_SELECTION_FOCUS];\n}\n\nvoid Panel_done(Panel* this) {\n   assert (this != NULL);\n   free(this->eventHandlerState);\n   Vector_delete(this->items);\n   FunctionBar_delete(this->defaultBar);\n   RichString_end(this->header);\n}\n\nvoid Panel_setSelectionColor(Panel* this, int color) {\n   this->selectionColor = color;\n}\n\nRichString* Panel_getHeader(Panel* this) {\n   assert (this != NULL);\n\n   this->needsRedraw = true;\n   return &(this->header);\n}\n\ninline void Panel_setHeader(Panel* this, const char* header) {\n   RichString_write(&(this->header), CRT_colors[PANEL_HEADER_FOCUS], header);\n   this->needsRedraw = true;\n}\n\nvoid Panel_move(Panel* this, int x, int y) {\n   assert (this != NULL);\n\n   this->x = x;\n   this->y = y;\n   this->needsRedraw = true;\n}\n\nvoid Panel_resize(Panel* this, int w, int h) {\n   assert (this != NULL);\n\n   if (RichString_sizeVal(this->header) > 0)\n      h--;\n   this->w = w;\n   this->h = h;\n   this->needsRedraw = true;\n}\n\nvoid Panel_prune(Panel* this) {\n   assert (this != NULL);\n\n   Vector_prune(this->items);\n   this->scrollV = 0;\n   this->selected = 0;\n   this->oldSelected = 0;\n   this->needsRedraw = true;\n}\n\nvoid Panel_add(Panel* this, Object* o) {\n   assert (this != NULL);\n\n   Vector_add(this->items, o);\n   this->needsRedraw = true;\n}\n\nvoid Panel_insert(Panel* this, int i, Object* o) {\n   assert (this != NULL);\n\n   Vector_insert(this->items, i, o);\n   this->needsRedraw = true;\n}\n\nvoid Panel_set(Panel* this, int i, Object* o) {\n   assert (this != NULL);\n\n   Vector_set(this->items, i, o);\n}\n\nObject* Panel_get(Panel* this, int i) {\n   assert (this != NULL);\n\n   return Vector_get(this->items, i);\n}\n\nObject* Panel_remove(Panel* this, int i) {\n   assert (this != NULL);\n\n   this->needsRedraw = true;\n   Object* removed = Vector_remove(this->items, i);\n   if (this->selected > 0 && this->selected >= Vector_size(this->items))\n      this->selected--;\n   return removed;\n}\n\nObject* Panel_getSelected(Panel* this) {\n   assert (this != NULL);\n   if (Vector_size(this->items) > 0)\n      return Vector_get(this->items, this->selected);\n   else\n      return NULL;\n}\n\nvoid Panel_moveSelectedUp(Panel* this) {\n   assert (this != NULL);\n\n   Vector_moveUp(this->items, this->selected);\n   if (this->selected > 0)\n      this->selected--;\n}\n\nvoid Panel_moveSelectedDown(Panel* this) {\n   assert (this != NULL);\n\n   Vector_moveDown(this->items, this->selected);\n   if (this->selected + 1 < Vector_size(this->items))\n      this->selected++;\n}\n\nint Panel_getSelectedIndex(Panel* this) {\n   assert (this != NULL);\n\n   return this->selected;\n}\n\nint Panel_size(Panel* this) {\n   assert (this != NULL);\n\n   return Vector_size(this->items);\n}\n\nvoid Panel_setSelected(Panel* this, int selected) {\n   assert (this != NULL);\n\n   int size = Vector_size(this->items);\n   if (selected >= size) {\n      selected = size - 1;\n   }\n   if (selected < 0)\n      selected = 0;\n   this->selected = selected;\n   if (Panel_eventHandlerFn(this)) {\n      Panel_eventHandler(this, EVENT_SET_SELECTED);\n   }\n}\n\nvoid Panel_draw(Panel* this, bool focus) {\n   assert (this != NULL);\n\n   int size = Vector_size(this->items);\n   int scrollH = this->scrollH;\n   int y = this->y;\n   int x = this->x;\n   int h = this->h;\n\n   int headerLen = RichString_sizeVal(this->header);\n   if (headerLen > 0) {\n      int attr = focus\n               ? CRT_colors[PANEL_HEADER_FOCUS]\n               : CRT_colors[PANEL_HEADER_UNFOCUS];\n      attrset(attr);\n      mvhline(y, x, ' ', this->w);\n      if (scrollH < headerLen) {\n         RichString_printoffnVal(this->header, y, x, scrollH,\n            MIN(headerLen - scrollH, this->w));\n      }\n      attrset(CRT_colors[RESET_COLOR]);\n      y++;\n   }\n\n   // ensure scroll area is on screen\n   if (this->scrollV < 0) {\n      this->scrollV = 0;\n      this->needsRedraw = true;\n   } else if (this->scrollV >= size) {\n      this->scrollV = MAX(size - 1, 0);\n      this->needsRedraw = true;\n   }\n   // ensure selection is on screen\n   if (this->selected < this->scrollV) {\n      this->scrollV = this->selected;\n      this->needsRedraw = true;\n   } else if (this->selected >= this->scrollV + h) {\n      this->scrollV = this->selected - h + 1;\n      this->needsRedraw = true;\n   }\n\n   int first = this->scrollV;\n   int upTo = MIN(first + h, size);\n\n   int selectionColor = focus\n                 ? this->selectionColor\n                 : CRT_colors[PANEL_SELECTION_UNFOCUS];\n\n   if (this->needsRedraw) {\n      int line = 0;\n      for(int i = first; line < h && i < upTo; i++) {\n         Object* itemObj = Vector_get(this->items, i);\n         assert(itemObj); if(!itemObj) continue;\n         RichString_begin(item);\n         Object_display(itemObj, &item);\n         int itemLen = RichString_sizeVal(item);\n         int amt = MIN(itemLen - scrollH, this->w);\n         bool selected = (i == this->selected);\n         if (selected) {\n            attrset(selectionColor);\n            RichString_setAttr(&item, selectionColor);\n            this->selectedLen = itemLen;\n         }\n         mvhline(y + line, x, ' ', this->w);\n         if (amt > 0)\n            RichString_printoffnVal(item, y + line, x, scrollH, amt);\n         if (selected)\n            attrset(CRT_colors[RESET_COLOR]);\n         RichString_end(item);\n         line++;\n      }\n      while (line < h) {\n         mvhline(y + line, x, ' ', this->w);\n         line++;\n      }\n      this->needsRedraw = false;\n\n   } else {\n      Object* oldObj = Vector_get(this->items, this->oldSelected);\n      assert(oldObj);\n      RichString_begin(old);\n      Object_display(oldObj, &old);\n      int oldLen = RichString_sizeVal(old);\n      Object* newObj = Vector_get(this->items, this->selected);\n      RichString_begin(new);\n      Object_display(newObj, &new);\n      int newLen = RichString_sizeVal(new);\n      this->selectedLen = newLen;\n      mvhline(y+ this->oldSelected - first, x+0, ' ', this->w);\n      if (scrollH < oldLen)\n         RichString_printoffnVal(old, y+this->oldSelected - first, x,\n            scrollH, MIN(oldLen - scrollH, this->w));\n      attrset(selectionColor);\n      mvhline(y+this->selected - first, x+0, ' ', this->w);\n      RichString_setAttr(&new, selectionColor);\n      if (scrollH < newLen)\n         RichString_printoffnVal(new, y+this->selected - first, x,\n            scrollH, MIN(newLen - scrollH, this->w));\n      attrset(CRT_colors[RESET_COLOR]);\n      RichString_end(new);\n      RichString_end(old);\n   }\n   this->oldSelected = this->selected;\n   move(0, 0);\n}\n\nbool Panel_onKey(Panel* this, int key) {\n   assert (this != NULL);\n   \n   int size = Vector_size(this->items);\n   switch (key) {\n   case KEY_DOWN:\n   case KEY_CTRL('N'):\n      this->selected++;\n      break;\n   case KEY_UP:\n   case KEY_CTRL('P'):\n      this->selected--;\n      break;\n   #ifdef KEY_C_DOWN\n   case KEY_C_DOWN:\n      this->selected++;\n      break;\n   #endif\n   #ifdef KEY_C_UP\n   case KEY_C_UP:\n      this->selected--;\n      break;\n   #endif\n   case KEY_LEFT:\n   case KEY_CTRL('B'):\n      if (this->scrollH > 0) {\n         this->scrollH -= MAX(CRT_scrollHAmount, 0);\n         this->needsRedraw = true;\n      }\n      break;\n   case KEY_RIGHT:\n   case KEY_CTRL('F'):\n      this->scrollH += CRT_scrollHAmount;\n      this->needsRedraw = true;\n      break;\n   case KEY_PPAGE:\n      this->selected -= (this->h - 1);\n      this->scrollV = MAX(0, this->scrollV - this->h + 1);\n      this->needsRedraw = true;\n      break;\n   case KEY_NPAGE:\n      this->selected += (this->h - 1);\n      this->scrollV = MAX(0, MIN(Vector_size(this->items) - this->h,\n                                 this->scrollV + this->h - 1));\n      this->needsRedraw = true;\n      break;\n   case KEY_WHEELUP:\n      this->selected -= CRT_scrollWheelVAmount;\n      this->scrollV -= CRT_scrollWheelVAmount;\n      this->needsRedraw = true;\n      break;\n   case KEY_WHEELDOWN:\n   {\n      this->selected += CRT_scrollWheelVAmount;\n      this->scrollV += CRT_scrollWheelVAmount;\n      if (this->scrollV > Vector_size(this->items) - this->h) {\n         this->scrollV = Vector_size(this->items) - this->h;\n      }\n      this->needsRedraw = true;\n      break;\n   }\n   case KEY_HOME:\n      this->selected = 0;\n      break;\n   case KEY_END:\n      this->selected = size - 1;\n      break;\n   case KEY_CTRL('A'):\n   case '^':\n      this->scrollH = 0;\n      this->needsRedraw = true;\n      break;\n   case KEY_CTRL('E'):\n   case '$':\n      this->scrollH = MAX(this->selectedLen - this->w, 0);\n      this->needsRedraw = true;\n      break;\n   default:\n      return false;\n   }\n\n   // ensure selection within bounds\n   if (this->selected < 0 || size == 0) {\n      this->selected = 0;\n      this->needsRedraw = true;\n   } else if (this->selected >= size) {   \n      this->selected = size - 1;\n      this->needsRedraw = true;\n   }\n   return true;\n}\n\n\nHandlerResult Panel_selectByTyping(Panel* this, int ch) {\n   int size = Panel_size(this);\n   if (!this->eventHandlerState)\n      this->eventHandlerState = xCalloc(100, sizeof(char));\n   char* buffer = this->eventHandlerState;\n\n   if (ch > 0 && ch < 255 && isalnum(ch)) {\n      int len = strlen(buffer);\n      if (len < 99) {\n         buffer[len] = ch;\n         buffer[len+1] = '\\0';\n      }\n      for (int try = 0; try < 2; try++) {\n         len = strlen(buffer);\n         for (int i = 0; i < size; i++) {\n            char* cur = ((ListItem*) Panel_get(this, i))->value;\n            while (*cur == ' ') cur++;\n            if (strncasecmp(cur, buffer, len) == 0) {\n               Panel_setSelected(this, i);\n               return HANDLED;\n            }\n         }\n         // if current word did not match,\n         // retry considering the character the start of a new word.\n         buffer[0] = ch;\n         buffer[1] = '\\0';\n      }\n      return HANDLED;\n   } else if (ch != ERR) {\n      buffer[0] = '\\0';\n   }\n   if (ch == 13) {\n      return BREAK_LOOP;\n   }\n   return IGNORED;\n}\n"
        },
        {
          "name": "Panel.h",
          "type": "blob",
          "size": 2.8701171875,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_Panel\n#define HEADER_Panel\n/*\nhtop - Panel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n//#link curses\n\n#include \"Object.h\"\n#include \"Vector.h\"\n#include \"FunctionBar.h\"\n\ntypedef struct Panel_ Panel;\n\ntypedef enum HandlerResult_ {\n   HANDLED     = 0x01,\n   IGNORED     = 0x02,\n   BREAK_LOOP  = 0x04,\n   REDRAW      = 0x08,\n   RESCAN      = 0x10,\n   SYNTH_KEY   = 0x20,\n} HandlerResult;\n\n#define EVENT_SET_SELECTED -1\n\n#define EVENT_HEADER_CLICK(x_) (-10000 + x_)\n#define EVENT_IS_HEADER_CLICK(ev_) (ev_ >= -10000 && ev_ <= -9000)\n#define EVENT_HEADER_CLICK_GET_X(ev_) (ev_ + 10000)\n\ntypedef HandlerResult(*Panel_EventHandler)(Panel*, int);\n\ntypedef struct PanelClass_ {\n   const ObjectClass super;\n   const Panel_EventHandler eventHandler;\n} PanelClass;\n\n#define As_Panel(this_)                ((PanelClass*)((this_)->super.klass))\n#define Panel_eventHandlerFn(this_)    As_Panel(this_)->eventHandler\n#define Panel_eventHandler(this_, ev_) As_Panel(this_)->eventHandler((Panel*)(this_), ev_)\n\nstruct Panel_ {\n   Object super;\n   int x, y, w, h;\n   WINDOW* window;\n   Vector* items;\n   int selected;\n   int oldSelected;\n   int selectedLen;\n   void* eventHandlerState;\n   int scrollV;\n   short scrollH;\n   bool needsRedraw;\n   FunctionBar* currentBar;\n   FunctionBar* defaultBar;\n   RichString header;\n   int selectionColor;\n};\n\n#define Panel_setDefaultBar(this_) do{ (this_)->currentBar = (this_)->defaultBar; }while(0)\n\n\n#ifndef MIN\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#endif\n#ifndef MAX\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#endif\n\n#define KEY_CTRL(l) ((l)-'A'+1)\n\nextern PanelClass Panel_class;\n\nPanel* Panel_new(int x, int y, int w, int h, bool owner, ObjectClass* type, FunctionBar* fuBar);\n\nvoid Panel_delete(Object* cast);\n\nvoid Panel_init(Panel* this, int x, int y, int w, int h, ObjectClass* type, bool owner, FunctionBar* fuBar);\n\nvoid Panel_done(Panel* this);\n\nvoid Panel_setSelectionColor(Panel* this, int color);\n\nRichString* Panel_getHeader(Panel* this);\n\nextern void Panel_setHeader(Panel* this, const char* header);\n\nvoid Panel_move(Panel* this, int x, int y);\n\nvoid Panel_resize(Panel* this, int w, int h);\n\nvoid Panel_prune(Panel* this);\n\nvoid Panel_add(Panel* this, Object* o);\n\nvoid Panel_insert(Panel* this, int i, Object* o);\n\nvoid Panel_set(Panel* this, int i, Object* o);\n\nObject* Panel_get(Panel* this, int i);\n\nObject* Panel_remove(Panel* this, int i);\n\nObject* Panel_getSelected(Panel* this);\n\nvoid Panel_moveSelectedUp(Panel* this);\n\nvoid Panel_moveSelectedDown(Panel* this);\n\nint Panel_getSelectedIndex(Panel* this);\n\nint Panel_size(Panel* this);\n\nvoid Panel_setSelected(Panel* this, int selected);\n\nvoid Panel_draw(Panel* this, bool focus);\n\nbool Panel_onKey(Panel* this, int key);\n\nHandlerResult Panel_selectByTyping(Panel* this, int ch);\n\n#endif\n"
        },
        {
          "name": "Process.c",
          "type": "blob",
          "size": 19.0615234375,
          "content": "/*\nhtop - Process.c\n(C) 2004-2015 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Process.h\"\n#include \"Settings.h\"\n\n#include \"CRT.h\"\n#include \"StringUtils.h\"\n#include \"RichString.h\"\n#include \"Platform.h\"\n\n#include <stdio.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <string.h>\n#include <stdbool.h>\n#include <pwd.h>\n#include <time.h>\n#include <assert.h>\n#include <math.h>\n#ifdef MAJOR_IN_MKDEV\n#include <sys/mkdev.h>\n#elif defined(MAJOR_IN_SYSMACROS) || \\\n   (defined(HAVE_SYS_SYSMACROS_H) && HAVE_SYS_SYSMACROS_H)\n#include <sys/sysmacros.h>\n#endif\n\n#ifdef __ANDROID__\n#define SYS_ioprio_get __NR_ioprio_get\n#define SYS_ioprio_set __NR_ioprio_set\n#endif\n\n// On Linux, this works only with glibc 2.1+. On earlier versions\n// the behavior is similar to have a hardcoded page size.\n#ifndef PAGE_SIZE\n#define PAGE_SIZE ( sysconf(_SC_PAGESIZE) )\n#endif\n#define PAGE_SIZE_KB ( PAGE_SIZE / ONE_K )\n\n/*{\n#include \"Object.h\"\n\n#include <sys/types.h>\n\n#define PROCESS_FLAG_IO 0x0001\n\ntypedef enum ProcessFields {\n   NULL_PROCESSFIELD = 0,\n   PID = 1,\n   COMM = 2,\n   STATE = 3,\n   PPID = 4,\n   PGRP = 5,\n   SESSION = 6,\n   TTY_NR = 7,\n   TPGID = 8,\n   MINFLT = 10,\n   MAJFLT = 12,\n   PRIORITY = 18,\n   NICE = 19,\n   STARTTIME = 21,\n   PROCESSOR = 38,\n   M_SIZE = 39,\n   M_RESIDENT = 40,\n   ST_UID = 46,\n   PERCENT_CPU = 47,\n   PERCENT_MEM = 48,\n   USER = 49,\n   TIME = 50,\n   NLWP = 51,\n   TGID = 52,\n} ProcessField;\n\ntypedef struct ProcessPidColumn_ {\n   int id;\n   char* label;\n} ProcessPidColumn;\n\ntypedef struct Process_ {\n   Object super;\n\n   struct Settings_* settings;\n\n   unsigned long long int time;\n   pid_t pid;\n   pid_t ppid;\n   pid_t tgid;\n   char* comm;\n   int commLen;\n   int indent;\n\n   int basenameOffset;\n   bool updated;\n\n   char state;\n   bool tag;\n   bool showChildren;\n   bool show;\n   unsigned int pgrp;\n   unsigned int session;\n   unsigned int tty_nr;\n   int tpgid;\n   uid_t st_uid;\n   unsigned long int flags;\n   int processor;\n\n   float percent_cpu;\n   float percent_mem;\n   char* user;\n\n   long int priority;\n   long int nice;\n   long int nlwp;\n   char starttime_show[8];\n   time_t starttime_ctime;\n\n   long m_size;\n   long m_resident;\n\n   int exit_signal;\n\n   unsigned long int minflt;\n   unsigned long int majflt;\n   #ifdef DEBUG\n   long int itrealvalue;\n   unsigned long int vsize;\n   long int rss;\n   unsigned long int rlim;\n   unsigned long int startcode;\n   unsigned long int endcode;\n   unsigned long int startstack;\n   unsigned long int kstkesp;\n   unsigned long int kstkeip;\n   unsigned long int signal;\n   unsigned long int blocked;\n   unsigned long int sigignore;\n   unsigned long int sigcatch;\n   unsigned long int wchan;\n   unsigned long int nswap;\n   unsigned long int cnswap;\n   #endif\n\n} Process;\n\ntypedef struct ProcessFieldData_ {\n   const char* name;\n   const char* title;\n   const char* description;\n   int flags;\n} ProcessFieldData;\n\n// Implemented in platform-specific code:\nvoid Process_writeField(Process* this, RichString* str, ProcessField field);\nlong Process_compare(const void* v1, const void* v2);\nvoid Process_delete(Object* cast);\nbool Process_isThread(Process* this);\nextern ProcessFieldData Process_fields[];\nextern ProcessPidColumn Process_pidColumns[];\nextern char Process_pidFormat[20];\n\ntypedef Process*(*Process_New)(struct Settings_*);\ntypedef void (*Process_WriteField)(Process*, RichString*, ProcessField);\n\ntypedef struct ProcessClass_ {\n   const ObjectClass super;\n   const Process_WriteField writeField;\n} ProcessClass;\n\n#define As_Process(this_)              ((ProcessClass*)((this_)->super.klass))\n\n#define Process_getParentPid(process_)    (process_->tgid == process_->pid ? process_->ppid : process_->tgid)\n\n#define Process_isChildOf(process_, pid_) (process_->tgid == pid_ || (process_->tgid == process_->pid && process_->ppid == pid_))\n\n#define Process_sortState(state) ((state) == 'I' ? 0x100 : (state))\n\n}*/\n\nstatic int Process_getuid = -1;\n\n#define ONE_K 1024L\n#define ONE_M (ONE_K * ONE_K)\n#define ONE_G (ONE_M * ONE_K)\n\n#define ONE_DECIMAL_K 1000L\n#define ONE_DECIMAL_M (ONE_DECIMAL_K * ONE_DECIMAL_K)\n#define ONE_DECIMAL_G (ONE_DECIMAL_M * ONE_DECIMAL_K)\n\nchar Process_pidFormat[20] = \"%7d \";\n\nstatic char Process_titleBuffer[20][20];\n\nvoid Process_setupColumnWidths() {\n   int maxPid = Platform_getMaxPid();\n   if (maxPid == -1) return;\n   int digits = ceil(log10(maxPid));\n   assert(digits < 20);\n   for (int i = 0; Process_pidColumns[i].label; i++) {\n      assert(i < 20);\n      xSnprintf(Process_titleBuffer[i], 20, \"%*s \", digits, Process_pidColumns[i].label);\n      Process_fields[Process_pidColumns[i].id].title = Process_titleBuffer[i];\n   }\n   xSnprintf(Process_pidFormat, sizeof(Process_pidFormat), \"%%%dd \", digits);\n}\n\nvoid Process_humanNumber(RichString* str, unsigned long number, bool coloring) {\n   char buffer[11];\n   int len;\n   \n   int largeNumberColor = CRT_colors[LARGE_NUMBER];\n   int processMegabytesColor = CRT_colors[PROCESS_MEGABYTES];\n   int processColor = CRT_colors[PROCESS];\n   if (!coloring) {\n      largeNumberColor = CRT_colors[PROCESS];\n      processMegabytesColor = CRT_colors[PROCESS];\n   }\n \n   if(number >= (10 * ONE_DECIMAL_M)) {\n      #ifdef __LP64__\n      if(number >= (100 * ONE_DECIMAL_G)) {\n         len = snprintf(buffer, 10, \"%4luT \", number / ONE_G);\n         RichString_appendn(str, largeNumberColor, buffer, len);\n         return;\n      } else if (number >= (1000 * ONE_DECIMAL_M)) {\n         len = snprintf(buffer, 10, \"%4.1lfT \", (double)number / ONE_G);\n         RichString_appendn(str, largeNumberColor, buffer, len);\n         return;\n      }\n      #endif\n      if(number >= (100 * ONE_DECIMAL_M)) {\n         len = snprintf(buffer, 10, \"%4luG \", number / ONE_M);\n         RichString_appendn(str, largeNumberColor, buffer, len);\n         return;\n      }\n      len = snprintf(buffer, 10, \"%4.1lfG \", (double)number / ONE_M);\n      RichString_appendn(str, largeNumberColor, buffer, len);\n      return;\n   } else if (number >= 100000) {\n      len = snprintf(buffer, 10, \"%4luM \", number / ONE_K);\n      RichString_appendn(str, processMegabytesColor, buffer, len);\n      return;\n   } else if (number >= 1000) {\n      len = snprintf(buffer, 10, \"%2lu\", number/1000);\n      RichString_appendn(str, processMegabytesColor, buffer, len);\n      number %= 1000;\n      len = snprintf(buffer, 10, \"%03lu \", number);\n      RichString_appendn(str, processColor, buffer, len);\n      return;\n   }\n   len = snprintf(buffer, 10, \"%5lu \", number);\n   RichString_appendn(str, processColor, buffer, len);\n}\n\nvoid Process_colorNumber(RichString* str, unsigned long long number, bool coloring) {\n   char buffer[14];\n\n   int largeNumberColor = CRT_colors[LARGE_NUMBER];\n   int processMegabytesColor = CRT_colors[PROCESS_MEGABYTES];\n   int processColor = CRT_colors[PROCESS];\n   int processShadowColor = CRT_colors[PROCESS_SHADOW];\n   if (!coloring) {\n      largeNumberColor = CRT_colors[PROCESS];\n      processMegabytesColor = CRT_colors[PROCESS];\n      processShadowColor = CRT_colors[PROCESS];\n   }\n\n   if ((long long) number == -1LL) {\n      int len = snprintf(buffer, 13, \"    no perm \");\n      RichString_appendn(str, CRT_colors[PROCESS_SHADOW], buffer, len);\n   } else if (number > 10000000000) {\n      xSnprintf(buffer, 13, \"%11llu \", number / 1000);\n      RichString_appendn(str, largeNumberColor, buffer, 5);\n      RichString_appendn(str, processMegabytesColor, buffer+5, 3);\n      RichString_appendn(str, processColor, buffer+8, 4);\n   } else {\n      xSnprintf(buffer, 13, \"%11llu \", number);\n      RichString_appendn(str, largeNumberColor, buffer, 2);\n      RichString_appendn(str, processMegabytesColor, buffer+2, 3);\n      RichString_appendn(str, processColor, buffer+5, 3);\n      RichString_appendn(str, processShadowColor, buffer+8, 4);\n   }\n}\n\nvoid Process_printTime(RichString* str, unsigned long long totalHundredths) {\n   unsigned long long totalSeconds = totalHundredths / 100;\n\n   unsigned long long hours = totalSeconds / 3600;\n   int minutes = (totalSeconds / 60) % 60;\n   int seconds = totalSeconds % 60;\n   int hundredths = totalHundredths - (totalSeconds * 100);\n   char buffer[11];\n   if (hours >= 100) {\n      xSnprintf(buffer, 10, \"%7lluh \", hours);\n      RichString_append(str, CRT_colors[LARGE_NUMBER], buffer);\n   } else {\n      if (hours) {\n         xSnprintf(buffer, 10, \"%2lluh\", hours);\n         RichString_append(str, CRT_colors[LARGE_NUMBER], buffer);\n         xSnprintf(buffer, 10, \"%02d:%02d \", minutes, seconds);\n      } else {\n         xSnprintf(buffer, 10, \"%2d:%02d.%02d \", minutes, seconds, hundredths);\n      }\n      RichString_append(str, CRT_colors[DEFAULT_COLOR], buffer);\n   }\n}\n\nstatic inline void Process_writeCommand(Process* this, int attr, int baseattr, RichString* str) {\n   int start = RichString_size(str), finish = 0;\n   char* comm = this->comm;\n\n   if (this->settings->highlightBaseName || !this->settings->showProgramPath) {\n      int i, basename = 0;\n      for (i = 0; i < this->basenameOffset; i++) {\n         if (comm[i] == '/') {\n            basename = i + 1;\n         } else if (comm[i] == ':') {\n            finish = i + 1;\n            break;\n         }\n      }\n      if (!finish) {\n         if (this->settings->showProgramPath)\n            start += basename;\n         else\n            comm += basename;\n         finish = this->basenameOffset - basename;\n      }\n      finish += start - 1;\n   }\n\n   RichString_append(str, attr, comm);\n\n   if (this->settings->highlightBaseName)\n      RichString_setAttrn(str, baseattr, start, finish);\n}\n\nvoid Process_outputRate(RichString* str, char* buffer, int n, double rate, int coloring) {\n   int largeNumberColor = CRT_colors[LARGE_NUMBER];\n   int processMegabytesColor = CRT_colors[PROCESS_MEGABYTES];\n   int processColor = CRT_colors[PROCESS];\n   if (!coloring) {\n      largeNumberColor = CRT_colors[PROCESS];\n      processMegabytesColor = CRT_colors[PROCESS];\n   }\n   if (rate == -1) {\n      int len = snprintf(buffer, n, \"    no perm \");\n      RichString_appendn(str, CRT_colors[PROCESS_SHADOW], buffer, len);\n   } else if (rate < ONE_K) {\n      int len = snprintf(buffer, n, \"%7.2f B/s \", rate);\n      RichString_appendn(str, processColor, buffer, len);\n   } else if (rate < ONE_K * ONE_K) {\n      int len = snprintf(buffer, n, \"%7.2f K/s \", rate / ONE_K);\n      RichString_appendn(str, processColor, buffer, len);\n   } else if (rate < ONE_K * ONE_K * ONE_K) {\n      int len = snprintf(buffer, n, \"%7.2f M/s \", rate / ONE_K / ONE_K);\n      RichString_appendn(str, processMegabytesColor, buffer, len);\n   } else {\n      int len = snprintf(buffer, n, \"%7.2f G/s \", rate / ONE_K / ONE_K / ONE_K);\n      RichString_appendn(str, largeNumberColor, buffer, len);\n   }\n}\n\nvoid Process_writeField(Process* this, RichString* str, ProcessField field) {\n   char buffer[256]; buffer[255] = '\\0';\n   int attr = CRT_colors[DEFAULT_COLOR];\n   int baseattr = CRT_colors[PROCESS_BASENAME];\n   int n = sizeof(buffer) - 1;\n   bool coloring = this->settings->highlightMegabytes;\n\n   switch (field) {\n   case PERCENT_CPU: {\n      if (this->percent_cpu > 999.9) {\n         xSnprintf(buffer, n, \"%4u \", (unsigned int)this->percent_cpu); \n      } else if (this->percent_cpu > 99.9) {\n         xSnprintf(buffer, n, \"%3u. \", (unsigned int)this->percent_cpu); \n      } else {\n         xSnprintf(buffer, n, \"%4.1f \", this->percent_cpu);\n      }\n      break;\n   }\n   case PERCENT_MEM: {\n      if (this->percent_mem > 99.9) {\n         xSnprintf(buffer, n, \"100. \"); \n      } else {\n         xSnprintf(buffer, n, \"%4.1f \", this->percent_mem);\n      }\n      break;\n   }\n   case COMM: {\n      if (this->settings->highlightThreads && Process_isThread(this)) {\n         attr = CRT_colors[PROCESS_THREAD];\n         baseattr = CRT_colors[PROCESS_THREAD_BASENAME];\n      }\n      if (!this->settings->treeView || this->indent == 0) {\n         Process_writeCommand(this, attr, baseattr, str);\n         return;\n      } else {\n         char* buf = buffer;\n         int maxIndent = 0;\n         bool lastItem = (this->indent < 0);\n         int indent = (this->indent < 0 ? -this->indent : this->indent);\n\n         for (int i = 0; i < 32; i++)\n            if (indent & (1U << i))\n               maxIndent = i+1;\n          for (int i = 0; i < maxIndent - 1; i++) {\n            int written, ret;\n            if (indent & (1 << i))\n               ret = snprintf(buf, n, \"%s  \", CRT_treeStr[TREE_STR_VERT]);\n            else\n               ret = snprintf(buf, n, \"   \");\n            if (ret < 0 || ret >= n) {\n               written = n;\n            } else {\n               written = ret;\n            }\n            buf += written;\n            n -= written;\n         }\n         const char* draw = CRT_treeStr[lastItem ? (this->settings->direction == 1 ? TREE_STR_BEND : TREE_STR_TEND) : TREE_STR_RTEE];\n         xSnprintf(buf, n, \"%s%s \", draw, this->showChildren ? CRT_treeStr[TREE_STR_SHUT] : CRT_treeStr[TREE_STR_OPEN] );\n         RichString_append(str, CRT_colors[PROCESS_TREE], buffer);\n         Process_writeCommand(this, attr, baseattr, str);\n         return;\n      }\n   }\n   case MAJFLT: Process_colorNumber(str, this->majflt, coloring); return;\n   case MINFLT: Process_colorNumber(str, this->minflt, coloring); return;\n   case M_RESIDENT: Process_humanNumber(str, this->m_resident * PAGE_SIZE_KB, coloring); return;\n   case M_SIZE: Process_humanNumber(str, this->m_size * PAGE_SIZE_KB, coloring); return;\n   case NICE: {\n      xSnprintf(buffer, n, \"%3ld \", this->nice);\n      attr = this->nice < 0 ? CRT_colors[PROCESS_HIGH_PRIORITY]\n           : this->nice > 0 ? CRT_colors[PROCESS_LOW_PRIORITY]\n           : attr;\n      break;\n   }\n   case NLWP: xSnprintf(buffer, n, \"%4ld \", this->nlwp); break;\n   case PGRP: xSnprintf(buffer, n, Process_pidFormat, this->pgrp); break;\n   case PID: xSnprintf(buffer, n, Process_pidFormat, this->pid); break;\n   case PPID: xSnprintf(buffer, n, Process_pidFormat, this->ppid); break;\n   case PRIORITY: {\n      if(this->priority <= -100)\n         xSnprintf(buffer, n, \" RT \");\n      else\n         xSnprintf(buffer, n, \"%3ld \", this->priority);\n      break;\n   }\n   case PROCESSOR: xSnprintf(buffer, n, \"%3d \", Settings_cpuId(this->settings, this->processor)); break;\n   case SESSION: xSnprintf(buffer, n, Process_pidFormat, this->session); break;\n   case STARTTIME: xSnprintf(buffer, n, \"%s\", this->starttime_show); break;\n   case STATE: {\n      xSnprintf(buffer, n, \"%c \", this->state);\n      switch(this->state) {\n          case 'R':\n              attr = CRT_colors[PROCESS_R_STATE];\n              break;\n          case 'D':\n              attr = CRT_colors[PROCESS_D_STATE];\n              break;\n      }\n      break;\n   }\n   case ST_UID: xSnprintf(buffer, n, \"%4d \", this->st_uid); break;\n   case TIME: Process_printTime(str, this->time); return;\n   case TGID: xSnprintf(buffer, n, Process_pidFormat, this->tgid); break;\n   case TPGID: xSnprintf(buffer, n, Process_pidFormat, this->tpgid); break;\n   case TTY_NR: xSnprintf(buffer, n, \"%3u:%3u \", major(this->tty_nr), minor(this->tty_nr)); break;\n   case USER: {\n      if (Process_getuid != (int) this->st_uid)\n         attr = CRT_colors[PROCESS_SHADOW];\n      if (this->user) {\n         xSnprintf(buffer, n, \"%-9s \", this->user);\n      } else {\n         xSnprintf(buffer, n, \"%-9d \", this->st_uid);\n      }\n      if (buffer[9] != '\\0') {\n         buffer[9] = ' ';\n         buffer[10] = '\\0';\n      }\n      break;\n   }\n   default:\n      xSnprintf(buffer, n, \"- \");\n   }\n   RichString_append(str, attr, buffer);\n}\n\nvoid Process_display(Object* cast, RichString* out) {\n   Process* this = (Process*) cast;\n   ProcessField* fields = this->settings->fields;\n   RichString_prune(out);\n   for (int i = 0; fields[i]; i++)\n      As_Process(this)->writeField(this, out, fields[i]);\n   if (this->settings->shadowOtherUsers && (int)this->st_uid != Process_getuid)\n      RichString_setAttr(out, CRT_colors[PROCESS_SHADOW]);\n   if (this->tag == true)\n      RichString_setAttr(out, CRT_colors[PROCESS_TAG]);\n   assert(out->chlen > 0);\n}\n\nvoid Process_done(Process* this) {\n   assert (this != NULL);\n   free(this->comm);\n}\n\nProcessClass Process_class = {\n   .super = {\n      .extends = Class(Object),\n      .display = Process_display,\n      .delete = Process_delete,\n      .compare = Process_compare\n   },\n   .writeField = Process_writeField,\n};\n\nvoid Process_init(Process* this, struct Settings_* settings) {\n   this->settings = settings;\n   this->tag = false;\n   this->showChildren = true;\n   this->show = true;\n   this->updated = false;\n   this->basenameOffset = -1;\n   if (Process_getuid == -1) Process_getuid = getuid();\n}\n\nvoid Process_toggleTag(Process* this) {\n   this->tag = this->tag == true ? false : true;\n}\n\nbool Process_setPriority(Process* this, int priority) {\n   CRT_dropPrivileges();\n   int old_prio = getpriority(PRIO_PROCESS, this->pid);\n   int err = setpriority(PRIO_PROCESS, this->pid, priority);\n   CRT_restorePrivileges();\n   if (err == 0 && old_prio != getpriority(PRIO_PROCESS, this->pid)) {\n      this->nice = priority;\n   }\n   return (err == 0);\n}\n\nbool Process_changePriorityBy(Process* this, int delta) {\n   return Process_setPriority(this, this->nice + delta);\n}\n\nvoid Process_sendSignal(Process* this, int sgn) {\n   CRT_dropPrivileges();\n   kill(this->pid, (int) sgn);\n   CRT_restorePrivileges();\n}\n\nlong Process_pidCompare(const void* v1, const void* v2) {\n   Process* p1 = (Process*)v1;\n   Process* p2 = (Process*)v2;\n   return (p1->pid - p2->pid);\n}\n\nlong Process_compare(const void* v1, const void* v2) {\n   Process *p1, *p2;\n   Settings *settings = ((Process*)v1)->settings;\n   if (settings->direction == 1) {\n      p1 = (Process*)v1;\n      p2 = (Process*)v2;\n   } else {\n      p2 = (Process*)v1;\n      p1 = (Process*)v2;\n   }\n   switch (settings->sortKey) {\n   case PERCENT_CPU:\n      return (p2->percent_cpu > p1->percent_cpu ? 1 : -1);\n   case PERCENT_MEM:\n      return (p2->m_resident - p1->m_resident);\n   case COMM:\n      return strcmp(p1->comm, p2->comm);\n   case MAJFLT:\n      return (p2->majflt - p1->majflt);\n   case MINFLT:\n      return (p2->minflt - p1->minflt);\n   case M_RESIDENT:\n      return (p2->m_resident - p1->m_resident);\n   case M_SIZE:\n      return (p2->m_size - p1->m_size);\n   case NICE:\n      return (p1->nice - p2->nice);\n   case NLWP:\n      return (p1->nlwp - p2->nlwp);\n   case PGRP:\n      return (p1->pgrp - p2->pgrp);\n   case PID:\n      return (p1->pid - p2->pid);\n   case PPID:\n      return (p1->ppid - p2->ppid);\n   case PRIORITY:\n      return (p1->priority - p2->priority);\n   case PROCESSOR:\n      return (p1->processor - p2->processor);\n   case SESSION:\n      return (p1->session - p2->session);\n   case STARTTIME: {\n      if (p1->starttime_ctime == p2->starttime_ctime)\n         return (p1->pid - p2->pid);\n      else\n         return (p1->starttime_ctime - p2->starttime_ctime);\n   }\n   case STATE:\n      return (Process_sortState(p1->state) - Process_sortState(p2->state));\n   case ST_UID:\n      return (p1->st_uid - p2->st_uid);\n   case TIME:\n      return ((p2->time) - (p1->time));\n   case TGID:\n      return (p1->tgid - p2->tgid);\n   case TPGID:\n      return (p1->tpgid - p2->tpgid);\n   case TTY_NR:\n      return (p1->tty_nr - p2->tty_nr);\n   case USER:\n      return strcmp(p1->user ? p1->user : \"\", p2->user ? p2->user : \"\");\n   default:\n      return (p1->pid - p2->pid);\n   }\n}\n"
        },
        {
          "name": "Process.h",
          "type": "blob",
          "size": 4.8076171875,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_Process\n#define HEADER_Process\n/*\nhtop - Process.h\n(C) 2004-2015 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#ifdef MAJOR_IN_MKDEV\n#elif defined(MAJOR_IN_SYSMACROS) || \\\n   (defined(HAVE_SYS_SYSMACROS_H) && HAVE_SYS_SYSMACROS_H)\n#endif\n\n#ifdef __ANDROID__\n#define SYS_ioprio_get __NR_ioprio_get\n#define SYS_ioprio_set __NR_ioprio_set\n#endif\n\n// On Linux, this works only with glibc 2.1+. On earlier versions\n// the behavior is similar to have a hardcoded page size.\n#ifndef PAGE_SIZE\n#define PAGE_SIZE ( sysconf(_SC_PAGESIZE) )\n#endif\n#define PAGE_SIZE_KB ( PAGE_SIZE / ONE_K )\n\n#include \"Object.h\"\n\n#include <sys/types.h>\n\n#define PROCESS_FLAG_IO 0x0001\n\ntypedef enum ProcessFields {\n   NULL_PROCESSFIELD = 0,\n   PID = 1,\n   COMM = 2,\n   STATE = 3,\n   PPID = 4,\n   PGRP = 5,\n   SESSION = 6,\n   TTY_NR = 7,\n   TPGID = 8,\n   MINFLT = 10,\n   MAJFLT = 12,\n   PRIORITY = 18,\n   NICE = 19,\n   STARTTIME = 21,\n   PROCESSOR = 38,\n   M_SIZE = 39,\n   M_RESIDENT = 40,\n   ST_UID = 46,\n   PERCENT_CPU = 47,\n   PERCENT_MEM = 48,\n   USER = 49,\n   TIME = 50,\n   NLWP = 51,\n   TGID = 52,\n} ProcessField;\n\ntypedef struct ProcessPidColumn_ {\n   int id;\n   char* label;\n} ProcessPidColumn;\n\ntypedef struct Process_ {\n   Object super;\n\n   struct Settings_* settings;\n\n   unsigned long long int time;\n   pid_t pid;\n   pid_t ppid;\n   pid_t tgid;\n   char* comm;\n   int commLen;\n   int indent;\n\n   int basenameOffset;\n   bool updated;\n\n   char state;\n   bool tag;\n   bool showChildren;\n   bool show;\n   unsigned int pgrp;\n   unsigned int session;\n   unsigned int tty_nr;\n   int tpgid;\n   uid_t st_uid;\n   unsigned long int flags;\n   int processor;\n\n   float percent_cpu;\n   float percent_mem;\n   char* user;\n\n   long int priority;\n   long int nice;\n   long int nlwp;\n   char starttime_show[8];\n   time_t starttime_ctime;\n\n   long m_size;\n   long m_resident;\n\n   int exit_signal;\n\n   unsigned long int minflt;\n   unsigned long int majflt;\n   #ifdef DEBUG\n   long int itrealvalue;\n   unsigned long int vsize;\n   long int rss;\n   unsigned long int rlim;\n   unsigned long int startcode;\n   unsigned long int endcode;\n   unsigned long int startstack;\n   unsigned long int kstkesp;\n   unsigned long int kstkeip;\n   unsigned long int signal;\n   unsigned long int blocked;\n   unsigned long int sigignore;\n   unsigned long int sigcatch;\n   unsigned long int wchan;\n   unsigned long int nswap;\n   unsigned long int cnswap;\n   #endif\n\n} Process;\n\ntypedef struct ProcessFieldData_ {\n   const char* name;\n   const char* title;\n   const char* description;\n   int flags;\n} ProcessFieldData;\n\n// Implemented in platform-specific code:\nvoid Process_writeField(Process* this, RichString* str, ProcessField field);\nlong Process_compare(const void* v1, const void* v2);\nvoid Process_delete(Object* cast);\nbool Process_isThread(Process* this);\nextern ProcessFieldData Process_fields[];\nextern ProcessPidColumn Process_pidColumns[];\nextern char Process_pidFormat[20];\n\ntypedef Process*(*Process_New)(struct Settings_*);\ntypedef void (*Process_WriteField)(Process*, RichString*, ProcessField);\n\ntypedef struct ProcessClass_ {\n   const ObjectClass super;\n   const Process_WriteField writeField;\n} ProcessClass;\n\n#define As_Process(this_)              ((ProcessClass*)((this_)->super.klass))\n\n#define Process_getParentPid(process_)    (process_->tgid == process_->pid ? process_->ppid : process_->tgid)\n\n#define Process_isChildOf(process_, pid_) (process_->tgid == pid_ || (process_->tgid == process_->pid && process_->ppid == pid_))\n\n#define Process_sortState(state) ((state) == 'I' ? 0x100 : (state))\n\n\n#define ONE_K 1024L\n#define ONE_M (ONE_K * ONE_K)\n#define ONE_G (ONE_M * ONE_K)\n\n#define ONE_DECIMAL_K 1000L\n#define ONE_DECIMAL_M (ONE_DECIMAL_K * ONE_DECIMAL_K)\n#define ONE_DECIMAL_G (ONE_DECIMAL_M * ONE_DECIMAL_K)\n\nextern char Process_pidFormat[20];\n\nvoid Process_setupColumnWidths();\n\nvoid Process_humanNumber(RichString* str, unsigned long number, bool coloring);\n\nvoid Process_colorNumber(RichString* str, unsigned long long number, bool coloring);\n\nvoid Process_printTime(RichString* str, unsigned long long totalHundredths);\n\nvoid Process_outputRate(RichString* str, char* buffer, int n, double rate, int coloring);\n\nvoid Process_writeField(Process* this, RichString* str, ProcessField field);\n\nvoid Process_display(Object* cast, RichString* out);\n\nvoid Process_done(Process* this);\n\nextern ProcessClass Process_class;\n\nvoid Process_init(Process* this, struct Settings_* settings);\n\nvoid Process_toggleTag(Process* this);\n\nbool Process_setPriority(Process* this, int priority);\n\nbool Process_changePriorityBy(Process* this, int delta);\n\nvoid Process_sendSignal(Process* this, int sgn);\n\nlong Process_pidCompare(const void* v1, const void* v2);\n\nlong Process_compare(const void* v1, const void* v2);\n\n#endif\n"
        },
        {
          "name": "ProcessList.c",
          "type": "blob",
          "size": 11.0205078125,
          "content": "/*\nhtop - ProcessList.c\n(C) 2004,2005 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"ProcessList.h\"\n#include \"Platform.h\"\n\n#include \"CRT.h\"\n#include \"StringUtils.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n/*{\n#include \"Vector.h\"\n#include \"Hashtable.h\"\n#include \"UsersTable.h\"\n#include \"Panel.h\"\n#include \"Process.h\"\n#include \"Settings.h\"\n\n#ifdef HAVE_LIBHWLOC\n#include <hwloc.h>\n#endif\n\n#ifndef MAX_NAME\n#define MAX_NAME 128\n#endif\n\n#ifndef MAX_READ\n#define MAX_READ 2048\n#endif\n\ntypedef struct ProcessList_ {\n   Settings* settings;\n\n   Vector* processes;\n   Vector* processes2;\n   Hashtable* processTable;\n   UsersTable* usersTable;\n\n   Panel* panel;\n   int following;\n   uid_t userId;\n   const char* incFilter;\n   Hashtable* pidWhiteList;\n\n   #ifdef HAVE_LIBHWLOC\n   hwloc_topology_t topology;\n   bool topologyOk;\n   #endif\n\n   int totalTasks;\n   int runningTasks;\n   int userlandThreads;\n   int kernelThreads;\n\n   unsigned long long int totalMem;\n   unsigned long long int usedMem;\n   unsigned long long int freeMem;\n   unsigned long long int sharedMem;\n   unsigned long long int buffersMem;\n   unsigned long long int cachedMem;\n   unsigned long long int totalSwap;\n   unsigned long long int usedSwap;\n   unsigned long long int freeSwap;\n\n   int cpuCount;\n\n} ProcessList;\n\nProcessList* ProcessList_new(UsersTable* ut, Hashtable* pidWhiteList, uid_t userId);\nvoid ProcessList_delete(ProcessList* pl);\nvoid ProcessList_goThroughEntries(ProcessList* pl);\n\n}*/\n\nProcessList* ProcessList_init(ProcessList* this, ObjectClass* klass, UsersTable* usersTable, Hashtable* pidWhiteList, uid_t userId) {\n   this->processes = Vector_new(klass, true, DEFAULT_SIZE);\n   this->processTable = Hashtable_new(140, false);\n   this->usersTable = usersTable;\n   this->pidWhiteList = pidWhiteList;\n   this->userId = userId;\n   \n   // tree-view auxiliary buffer\n   this->processes2 = Vector_new(klass, true, DEFAULT_SIZE);\n   \n   // set later by platform-specific code\n   this->cpuCount = 0;\n\n#ifdef HAVE_LIBHWLOC\n   this->topologyOk = false;\n   int topoErr = hwloc_topology_init(&this->topology);\n   if (topoErr == 0) {\n      topoErr = hwloc_topology_load(this->topology);\n   }\n   if (topoErr == 0) {\n      this->topologyOk = true;\n   }\n#endif\n\n   this->following = -1;\n\n   return this;\n}\n\nvoid ProcessList_done(ProcessList* this) {\n#ifdef HAVE_LIBHWLOC\n   if (this->topologyOk) {\n      hwloc_topology_destroy(this->topology);\n   }\n#endif\n   Hashtable_delete(this->processTable);\n   Vector_delete(this->processes);\n   Vector_delete(this->processes2);\n}\n\nvoid ProcessList_setPanel(ProcessList* this, Panel* panel) {\n   this->panel = panel;\n}\n\nvoid ProcessList_printHeader(ProcessList* this, RichString* header) {\n   RichString_prune(header);\n   ProcessField* fields = this->settings->fields;\n   for (int i = 0; fields[i]; i++) {\n      const char* field = Process_fields[fields[i]].title;\n      if (!field) field = \"- \";\n      if (!this->settings->treeView && this->settings->sortKey == fields[i])\n         RichString_append(header, CRT_colors[PANEL_SELECTION_FOCUS], field);\n      else\n         RichString_append(header, CRT_colors[PANEL_HEADER_FOCUS], field);\n   }\n}\n\nvoid ProcessList_add(ProcessList* this, Process* p) {\n   assert(Vector_indexOf(this->processes, p, Process_pidCompare) == -1);\n   assert(Hashtable_get(this->processTable, p->pid) == NULL);\n   \n   Vector_add(this->processes, p);\n   Hashtable_put(this->processTable, p->pid, p);\n   \n   assert(Vector_indexOf(this->processes, p, Process_pidCompare) != -1);\n   assert(Hashtable_get(this->processTable, p->pid) != NULL);\n   assert(Hashtable_count(this->processTable) == Vector_count(this->processes));\n}\n\nvoid ProcessList_remove(ProcessList* this, Process* p) {\n   assert(Vector_indexOf(this->processes, p, Process_pidCompare) != -1);\n   assert(Hashtable_get(this->processTable, p->pid) != NULL);\n   Process* pp = Hashtable_remove(this->processTable, p->pid);\n   assert(pp == p); (void)pp;\n   unsigned int pid = p->pid;\n   int idx = Vector_indexOf(this->processes, p, Process_pidCompare);\n   assert(idx != -1);\n   if (idx >= 0) Vector_remove(this->processes, idx);\n   assert(Hashtable_get(this->processTable, pid) == NULL); (void)pid;\n   assert(Hashtable_count(this->processTable) == Vector_count(this->processes));\n}\n\nProcess* ProcessList_get(ProcessList* this, int idx) {\n   return (Process*) (Vector_get(this->processes, idx));\n}\n\nint ProcessList_size(ProcessList* this) {\n   return (Vector_size(this->processes));\n}\n\nstatic void ProcessList_buildTree(ProcessList* this, pid_t pid, int level, int indent, int direction, bool show) {\n   Vector* children = Vector_new(Class(Process), false, DEFAULT_SIZE);\n\n   for (int i = Vector_size(this->processes) - 1; i >= 0; i--) {\n      Process* process = (Process*) (Vector_get(this->processes, i));\n      if (process->show && Process_isChildOf(process, pid)) {\n         process = (Process*) (Vector_take(this->processes, i));\n         Vector_add(children, process);\n      }\n   }\n   int size = Vector_size(children);\n   for (int i = 0; i < size; i++) {\n      Process* process = (Process*) (Vector_get(children, i));\n      if (!show)\n         process->show = false;\n      int s = this->processes2->items;\n      if (direction == 1)\n         Vector_add(this->processes2, process);\n      else\n         Vector_insert(this->processes2, 0, process);\n      assert(this->processes2->items == s+1); (void)s;\n      int nextIndent = indent | (1 << level);\n      ProcessList_buildTree(this, process->pid, level+1, (i < size - 1) ? nextIndent : indent, direction, show ? process->showChildren : false);\n      if (i == size - 1)\n         process->indent = -nextIndent;\n      else\n         process->indent = nextIndent;\n   }\n   Vector_delete(children);\n}\n\nvoid ProcessList_sort(ProcessList* this) {\n   if (!this->settings->treeView) {\n      Vector_insertionSort(this->processes);\n   } else {\n      // Save settings\n      int direction = this->settings->direction;\n      int sortKey = this->settings->sortKey;\n      // Sort by PID\n      this->settings->sortKey = PID;\n      this->settings->direction = 1;\n      Vector_quickSort(this->processes);\n      // Restore settings\n      this->settings->sortKey = sortKey;\n      this->settings->direction = direction;\n      int vsize = Vector_size(this->processes);\n      // Find all processes whose parent is not visible\n      int size;\n      while ((size = Vector_size(this->processes))) {\n         int i;\n         for (i = 0; i < size; i++) {\n            Process* process = (Process*)(Vector_get(this->processes, i));\n            // Immediately consume not shown processes\n            if (!process->show) {\n               process = (Process*)(Vector_take(this->processes, i));\n               process->indent = 0;\n               Vector_add(this->processes2, process);\n               ProcessList_buildTree(this, process->pid, 0, 0, direction, false);\n               break;\n            }\n            pid_t ppid = Process_getParentPid(process);\n            // Bisect the process vector to find parent\n            int l = 0, r = size;\n            // If PID corresponds with PPID (e.g. \"kernel_task\" (PID:0, PPID:0)\n            // on Mac OS X 10.11.6) cancel bisecting and regard this process as\n            // root.\n            if (process->pid == ppid)\n               r = 0;\n            while (l < r) {\n               int c = (l + r) / 2;\n               pid_t pid = ((Process*)(Vector_get(this->processes, c)))->pid;\n               if (ppid == pid) {\n                  break;\n               } else if (ppid < pid) {\n                  r = c;\n               } else {\n                  l = c + 1;\n               }\n            }\n            // If parent not found, then construct the tree with this root\n            if (l >= r) {\n               process = (Process*)(Vector_take(this->processes, i));\n               process->indent = 0;\n               Vector_add(this->processes2, process);\n               ProcessList_buildTree(this, process->pid, 0, 0, direction, process->showChildren);\n               break;\n            }\n         }\n         // There should be no loop in the process tree\n         assert(i < size);\n      }\n      assert(Vector_size(this->processes2) == vsize); (void)vsize;\n      assert(Vector_size(this->processes) == 0);\n      // Swap listings around\n      Vector* t = this->processes;\n      this->processes = this->processes2;\n      this->processes2 = t;\n   }\n}\n\n\nProcessField ProcessList_keyAt(ProcessList* this, int at) {\n   int x = 0;\n   ProcessField* fields = this->settings->fields;\n   ProcessField field;\n   for (int i = 0; (field = fields[i]); i++) {\n      const char* title = Process_fields[field].title;\n      if (!title) title = \"- \";\n      int len = strlen(title);\n      if (at >= x && at <= x + len) {\n         return field;\n      }\n      x += len;\n   }\n   return COMM;\n}\n\nvoid ProcessList_expandTree(ProcessList* this) {\n   int size = Vector_size(this->processes);\n   for (int i = 0; i < size; i++) {\n      Process* process = (Process*) Vector_get(this->processes, i);\n      process->showChildren = true;\n   }\n}\n\nvoid ProcessList_rebuildPanel(ProcessList* this) {\n   const char* incFilter = this->incFilter;\n\n   int currPos = Panel_getSelectedIndex(this->panel);\n   pid_t currPid = this->following != -1 ? this->following : 0;\n   int currScrollV = this->panel->scrollV;\n\n   Panel_prune(this->panel);\n   int size = ProcessList_size(this);\n   int idx = 0;\n   for (int i = 0; i < size; i++) {\n      bool hidden = false;\n      Process* p = ProcessList_get(this, i);\n\n      if ( (!p->show)\n         || (this->userId != (uid_t) -1 && (p->st_uid != this->userId))\n         || (incFilter && !(String_contains_i(p->comm, incFilter)))\n         || (this->pidWhiteList && !Hashtable_get(this->pidWhiteList, p->tgid)) )\n         hidden = true;\n\n      if (!hidden) {\n         Panel_set(this->panel, idx, (Object*)p);\n         if ((this->following == -1 && idx == currPos) || (this->following != -1 && p->pid == currPid)) {\n            Panel_setSelected(this->panel, idx);\n            this->panel->scrollV = currScrollV;\n         }\n         idx++;\n      }\n   }\n}\n\nProcess* ProcessList_getProcess(ProcessList* this, pid_t pid, bool* preExisting, Process_New constructor) {\n   Process* proc = (Process*) Hashtable_get(this->processTable, pid);\n   *preExisting = proc;\n   if (proc) {\n      assert(Vector_indexOf(this->processes, proc, Process_pidCompare) != -1);\n      assert(proc->pid == pid);\n   } else {\n      proc = constructor(this->settings);\n      assert(proc->comm == NULL);\n      proc->pid = pid;\n   }\n   return proc;\n}\n\nvoid ProcessList_scan(ProcessList* this) {\n\n   // mark all process as \"dirty\"\n   for (int i = 0; i < Vector_size(this->processes); i++) {\n      Process* p = (Process*) Vector_get(this->processes, i);\n      p->updated = false;\n      p->show = true;\n   }\n\n   this->totalTasks = 0;\n   this->userlandThreads = 0;\n   this->kernelThreads = 0;\n   this->runningTasks = 0;\n\n   ProcessList_goThroughEntries(this);\n   \n   for (int i = Vector_size(this->processes) - 1; i >= 0; i--) {\n      Process* p = (Process*) Vector_get(this->processes, i);\n      if (p->updated == false)\n         ProcessList_remove(this, p);\n      else\n         p->updated = false;\n   }\n}\n"
        },
        {
          "name": "ProcessList.h",
          "type": "blob",
          "size": 2.3408203125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_ProcessList\n#define HEADER_ProcessList\n/*\nhtop - ProcessList.h\n(C) 2004,2005 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Vector.h\"\n#include \"Hashtable.h\"\n#include \"UsersTable.h\"\n#include \"Panel.h\"\n#include \"Process.h\"\n#include \"Settings.h\"\n\n#ifdef HAVE_LIBHWLOC\n#include <hwloc.h>\n#endif\n\n#ifndef MAX_NAME\n#define MAX_NAME 128\n#endif\n\n#ifndef MAX_READ\n#define MAX_READ 2048\n#endif\n\ntypedef struct ProcessList_ {\n   Settings* settings;\n\n   Vector* processes;\n   Vector* processes2;\n   Hashtable* processTable;\n   UsersTable* usersTable;\n\n   Panel* panel;\n   int following;\n   uid_t userId;\n   const char* incFilter;\n   Hashtable* pidWhiteList;\n\n   #ifdef HAVE_LIBHWLOC\n   hwloc_topology_t topology;\n   bool topologyOk;\n   #endif\n\n   int totalTasks;\n   int runningTasks;\n   int userlandThreads;\n   int kernelThreads;\n\n   unsigned long long int totalMem;\n   unsigned long long int usedMem;\n   unsigned long long int freeMem;\n   unsigned long long int sharedMem;\n   unsigned long long int buffersMem;\n   unsigned long long int cachedMem;\n   unsigned long long int totalSwap;\n   unsigned long long int usedSwap;\n   unsigned long long int freeSwap;\n\n   int cpuCount;\n\n} ProcessList;\n\nProcessList* ProcessList_new(UsersTable* ut, Hashtable* pidWhiteList, uid_t userId);\nvoid ProcessList_delete(ProcessList* pl);\nvoid ProcessList_goThroughEntries(ProcessList* pl);\n\n\nProcessList* ProcessList_init(ProcessList* this, ObjectClass* klass, UsersTable* usersTable, Hashtable* pidWhiteList, uid_t userId);\n\nvoid ProcessList_done(ProcessList* this);\n\nvoid ProcessList_setPanel(ProcessList* this, Panel* panel);\n\nvoid ProcessList_printHeader(ProcessList* this, RichString* header);\n\nvoid ProcessList_add(ProcessList* this, Process* p);\n\nvoid ProcessList_remove(ProcessList* this, Process* p);\n\nProcess* ProcessList_get(ProcessList* this, int idx);\n\nint ProcessList_size(ProcessList* this);\n\nvoid ProcessList_sort(ProcessList* this);\n\nProcessField ProcessList_keyAt(ProcessList* this, int at);\n\nvoid ProcessList_expandTree(ProcessList* this);\n\nvoid ProcessList_rebuildPanel(ProcessList* this);\n\nProcess* ProcessList_getProcess(ProcessList* this, pid_t pid, bool* preExisting, Process_New constructor);\n\nvoid ProcessList_scan(ProcessList* this);\n\n#endif\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 0.3037109375,
          "content": "htop\n====\n\nby Hisham Muhammad <hisham@gobolinux.org>\n\n**This repository is archived as htop is now maintained by a team of\nvolunteers at [htop.dev](https://htop.dev/) using an organisation-based\ngit [repository](https://github.com/htop-dev/htop/)**.\n\n## License\n\nGNU General Public License, version 2 (GPL-2.0)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.005859375,
          "content": "README"
        },
        {
          "name": "RichString.c",
          "type": "blob",
          "size": 5.2529296875,
          "content": "/*\nhtop - RichString.c\n(C) 2004,2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"RichString.h\"\n#include \"XAlloc.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#define RICHSTRING_MAXLEN 350\n\n/*{\n#include \"config.h\"\n#include <ctype.h>\n\n#include <assert.h>\n#ifdef HAVE_NCURSESW_CURSES_H\n#include <ncursesw/curses.h>\n#elif HAVE_NCURSES_NCURSES_H\n#include <ncurses/ncurses.h>\n#elif HAVE_NCURSES_CURSES_H\n#include <ncurses/curses.h>\n#elif HAVE_NCURSES_H\n#include <ncurses.h>\n#elif HAVE_CURSES_H\n#include <curses.h>\n#endif\n\n#ifdef HAVE_LIBNCURSESW\n#include <wctype.h>\n#endif\n\n#define RichString_size(this) ((this)->chlen)\n#define RichString_sizeVal(this) ((this).chlen)\n\n#define RichString_begin(this) RichString (this); memset(&this, 0, sizeof(RichString)); (this).chptr = (this).chstr;\n#define RichString_beginAllocated(this) memset(&this, 0, sizeof(RichString)); (this).chptr = (this).chstr;\n#define RichString_end(this) RichString_prune(&(this));\n\n#ifdef HAVE_LIBNCURSESW\n#define RichString_printVal(this, y, x) mvadd_wchstr(y, x, (this).chptr)\n#define RichString_printoffnVal(this, y, x, off, n) mvadd_wchnstr(y, x, (this).chptr + off, n)\n#define RichString_getCharVal(this, i) ((this).chptr[i].chars[0] & 255)\n#define RichString_setChar(this, at, ch) do{ (this)->chptr[(at)] = (CharType) { .chars = { ch, 0 } }; } while(0)\n#define CharType cchar_t\n#else\n#define RichString_printVal(this, y, x) mvaddchstr(y, x, (this).chptr)\n#define RichString_printoffnVal(this, y, x, off, n) mvaddchnstr(y, x, (this).chptr + off, n)\n#define RichString_getCharVal(this, i) ((this).chptr[i])\n#define RichString_setChar(this, at, ch) do{ (this)->chptr[(at)] = ch; } while(0)\n#define CharType chtype\n#endif\n\ntypedef struct RichString_ {\n   int chlen;\n   CharType* chptr;\n   CharType chstr[RICHSTRING_MAXLEN+1];\n} RichString;\n\n}*/\n\n#ifndef CLAMP\n#define CLAMP(x,low,high) (((x)>(high))?(high):(((x)<(low))?(low):(x)))\n#endif\n\n#define charBytes(n) (sizeof(CharType) * (n)) \n\nstatic void RichString_extendLen(RichString* this, int len) {\n   if (this->chlen <= RICHSTRING_MAXLEN) {\n      if (len > RICHSTRING_MAXLEN) {\n         this->chptr = xMalloc(charBytes(len + 1));\n         memcpy(this->chptr, this->chstr, charBytes(this->chlen));\n      }\n   } else {\n      if (len <= RICHSTRING_MAXLEN) {\n         memcpy(this->chstr, this->chptr, charBytes(len));\n         free(this->chptr);\n         this->chptr = this->chstr;\n      } else {\n         this->chptr = xRealloc(this->chptr, charBytes(len + 1));\n      }\n   }\n\n   RichString_setChar(this, len, 0);\n   this->chlen = len;\n}\n\n#define RichString_setLen(this, len) do{ if(len < RICHSTRING_MAXLEN && this->chlen < RICHSTRING_MAXLEN) { RichString_setChar(this,len,0); this->chlen=len; } else RichString_extendLen(this,len); }while(0)\n\n#ifdef HAVE_LIBNCURSESW\n\nstatic inline void RichString_writeFrom(RichString* this, int attrs, const char* data_c, int from, int len) {\n   wchar_t data[len+1];\n   len = mbstowcs(data, data_c, len);\n   if (len < 0)\n      return;\n   int newLen = from + len;\n   RichString_setLen(this, newLen);\n   for (int i = from, j = 0; i < newLen; i++, j++) {\n      this->chptr[i] = (CharType) { .attr = attrs & 0xffffff, .chars = { (iswprint(data[j]) ? data[j] : '?') } };\n   }\n}\n\ninline void RichString_setAttrn(RichString* this, int attrs, int start, int finish) {\n   cchar_t* ch = this->chptr + start;\n   finish = CLAMP(finish, 0, this->chlen - 1);\n   for (int i = start; i <= finish; i++) {\n      ch->attr = attrs;\n      ch++;\n   }\n}\n\nint RichString_findChar(RichString* this, char c, int start) {\n   wchar_t wc = btowc(c);\n   cchar_t* ch = this->chptr + start;\n   for (int i = start; i < this->chlen; i++) {\n      if (ch->chars[0] == wc)\n         return i;\n      ch++;\n   }\n   return -1;\n}\n\n#else\n\nstatic inline void RichString_writeFrom(RichString* this, int attrs, const char* data_c, int from, int len) {\n   int newLen = from + len;\n   RichString_setLen(this, newLen);\n   for (int i = from, j = 0; i < newLen; i++, j++)\n      this->chptr[i] = (data_c[j] >= 32 ? data_c[j] : '?') | attrs;\n   this->chptr[newLen] = 0;\n}\n\nvoid RichString_setAttrn(RichString* this, int attrs, int start, int finish) {\n   chtype* ch = this->chptr + start;\n   finish = CLAMP(finish, 0, this->chlen - 1);\n   for (int i = start; i <= finish; i++) {\n      *ch = (*ch & 0xff) | attrs;\n      ch++;\n   }\n}\n\nint RichString_findChar(RichString* this, char c, int start) {\n   chtype* ch = this->chptr + start;\n   for (int i = start; i < this->chlen; i++) {\n      if ((*ch & 0xff) == (chtype) c)\n         return i;\n      ch++;\n   }\n   return -1;\n}\n\n#endif\n\nvoid RichString_prune(RichString* this) {\n   if (this->chlen > RICHSTRING_MAXLEN)\n      free(this->chptr);\n   memset(this, 0, sizeof(RichString));\n   this->chptr = this->chstr;\n}\n\nvoid RichString_setAttr(RichString* this, int attrs) {\n   RichString_setAttrn(this, attrs, 0, this->chlen - 1);\n}\n\nvoid RichString_append(RichString* this, int attrs, const char* data) {\n   RichString_writeFrom(this, attrs, data, this->chlen, strlen(data));\n}\n\nvoid RichString_appendn(RichString* this, int attrs, const char* data, int len) {\n   RichString_writeFrom(this, attrs, data, this->chlen, len);\n}\n\nvoid RichString_write(RichString* this, int attrs, const char* data) {\n   RichString_writeFrom(this, attrs, data, 0, strlen(data));\n}\n"
        },
        {
          "name": "RichString.h",
          "type": "blob",
          "size": 2.8515625,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_RichString\n#define HEADER_RichString\n/*\nhtop - RichString.h\n(C) 2004,2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#define RICHSTRING_MAXLEN 350\n\n#include \"config.h\"\n#include <ctype.h>\n\n#include <assert.h>\n#ifdef HAVE_NCURSESW_CURSES_H\n#include <ncursesw/curses.h>\n#elif HAVE_NCURSES_NCURSES_H\n#include <ncurses/ncurses.h>\n#elif HAVE_NCURSES_CURSES_H\n#include <ncurses/curses.h>\n#elif HAVE_NCURSES_H\n#include <ncurses.h>\n#elif HAVE_CURSES_H\n#include <curses.h>\n#endif\n\n#ifdef HAVE_LIBNCURSESW\n#include <wctype.h>\n#endif\n\n#define RichString_size(this) ((this)->chlen)\n#define RichString_sizeVal(this) ((this).chlen)\n\n#define RichString_begin(this) RichString (this); memset(&this, 0, sizeof(RichString)); (this).chptr = (this).chstr;\n#define RichString_beginAllocated(this) memset(&this, 0, sizeof(RichString)); (this).chptr = (this).chstr;\n#define RichString_end(this) RichString_prune(&(this));\n\n#ifdef HAVE_LIBNCURSESW\n#define RichString_printVal(this, y, x) mvadd_wchstr(y, x, (this).chptr)\n#define RichString_printoffnVal(this, y, x, off, n) mvadd_wchnstr(y, x, (this).chptr + off, n)\n#define RichString_getCharVal(this, i) ((this).chptr[i].chars[0] & 255)\n#define RichString_setChar(this, at, ch) do{ (this)->chptr[(at)] = (CharType) { .chars = { ch, 0 } }; } while(0)\n#define CharType cchar_t\n#else\n#define RichString_printVal(this, y, x) mvaddchstr(y, x, (this).chptr)\n#define RichString_printoffnVal(this, y, x, off, n) mvaddchnstr(y, x, (this).chptr + off, n)\n#define RichString_getCharVal(this, i) ((this).chptr[i])\n#define RichString_setChar(this, at, ch) do{ (this)->chptr[(at)] = ch; } while(0)\n#define CharType chtype\n#endif\n\ntypedef struct RichString_ {\n   int chlen;\n   CharType* chptr;\n   CharType chstr[RICHSTRING_MAXLEN+1];\n} RichString;\n\n\n#ifndef CLAMP\n#define CLAMP(x,low,high) (((x)>(high))?(high):(((x)<(low))?(low):(x)))\n#endif\n\n#define charBytes(n) (sizeof(CharType) * (n)) \n\n#define RichString_setLen(this, len) do{ if(len < RICHSTRING_MAXLEN && this->chlen < RICHSTRING_MAXLEN) { RichString_setChar(this,len,0); this->chlen=len; } else RichString_extendLen(this,len); }while(0)\n\n#ifdef HAVE_LIBNCURSESW\n\nextern void RichString_setAttrn(RichString* this, int attrs, int start, int finish);\n\nint RichString_findChar(RichString* this, char c, int start);\n\n#else\n\nvoid RichString_setAttrn(RichString* this, int attrs, int start, int finish);\n\nint RichString_findChar(RichString* this, char c, int start);\n\n#endif\n\nvoid RichString_prune(RichString* this);\n\nvoid RichString_setAttr(RichString* this, int attrs);\n\nvoid RichString_append(RichString* this, int attrs, const char* data);\n\nvoid RichString_appendn(RichString* this, int attrs, const char* data, int len);\n\nvoid RichString_write(RichString* this, int attrs, const char* data);\n\n#endif\n"
        },
        {
          "name": "ScreenManager.c",
          "type": "blob",
          "size": 9.0517578125,
          "content": "/*\nhtop - ScreenManager.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"ScreenManager.h\"\n#include \"ProcessList.h\"\n\n#include \"Object.h\"\n#include \"CRT.h\"\n\n#include <assert.h>\n#include <time.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n/*{\n#include \"FunctionBar.h\"\n#include \"Vector.h\"\n#include \"Header.h\"\n#include \"Settings.h\"\n#include \"Panel.h\"\n\ntypedef enum Orientation_ {\n   VERTICAL,\n   HORIZONTAL\n} Orientation;\n\ntypedef struct ScreenManager_ {\n   int x1;\n   int y1;\n   int x2;\n   int y2;\n   Orientation orientation;\n   Vector* panels;\n   int panelCount;\n   const Header* header;\n   const Settings* settings;\n   bool owner;\n   bool allowFocusChange;\n} ScreenManager;\n\n}*/\n\nScreenManager* ScreenManager_new(int x1, int y1, int x2, int y2, Orientation orientation, const Header* header, const Settings* settings, bool owner) {\n   ScreenManager* this;\n   this = xMalloc(sizeof(ScreenManager));\n   this->x1 = x1;\n   this->y1 = y1;\n   this->x2 = x2;\n   this->y2 = y2;\n   this->orientation = orientation;\n   this->panels = Vector_new(Class(Panel), owner, DEFAULT_SIZE);\n   this->panelCount = 0;\n   this->header = header;\n   this->settings = settings;\n   this->owner = owner;\n   this->allowFocusChange = true;\n   return this;\n}\n\nvoid ScreenManager_delete(ScreenManager* this) {\n   Vector_delete(this->panels);\n   free(this);\n}\n\ninline int ScreenManager_size(ScreenManager* this) {\n   return this->panelCount;\n}\n\nvoid ScreenManager_add(ScreenManager* this, Panel* item, int size) {\n   if (this->orientation == HORIZONTAL) {\n      int lastX = 0;\n      if (this->panelCount > 0) {\n         Panel* last = (Panel*) Vector_get(this->panels, this->panelCount - 1);\n         lastX = last->x + last->w + 1;\n      }\n      int height = LINES - this->y1 + this->y2;\n      if (size > 0) {\n         Panel_resize(item, size, height);\n      } else {\n         Panel_resize(item, COLS-this->x1+this->x2-lastX, height);\n      }\n      Panel_move(item, lastX, this->y1);\n   }\n   // TODO: VERTICAL\n   Vector_add(this->panels, item);\n   item->needsRedraw = true;\n   this->panelCount++;\n}\n\nPanel* ScreenManager_remove(ScreenManager* this, int idx) {\n   assert(this->panelCount > idx);\n   Panel* panel = (Panel*) Vector_remove(this->panels, idx);\n   this->panelCount--;\n   return panel;\n}\n\nvoid ScreenManager_resize(ScreenManager* this, int x1, int y1, int x2, int y2) {\n   this->x1 = x1;\n   this->y1 = y1;\n   this->x2 = x2;\n   this->y2 = y2;\n   int panels = this->panelCount;\n   if (this->orientation == HORIZONTAL) {\n      int lastX = 0;\n      for (int i = 0; i < panels - 1; i++) {\n         Panel* panel = (Panel*) Vector_get(this->panels, i);\n         Panel_resize(panel, panel->w, LINES-y1+y2);\n         Panel_move(panel, lastX, y1);\n         lastX = panel->x + panel->w + 1;\n      }\n      Panel* panel = (Panel*) Vector_get(this->panels, panels-1);\n      Panel_resize(panel, COLS-x1+x2-lastX, LINES-y1+y2);\n      Panel_move(panel, lastX, y1);\n   }\n   // TODO: VERTICAL\n}\n\nstatic void checkRecalculation(ScreenManager* this, double* oldTime, int* sortTimeout, bool* redraw, bool *rescan, bool *timedOut) {\n   ProcessList* pl = this->header->pl;\n\n   struct timeval tv;\n   gettimeofday(&tv, NULL);\n   double newTime = ((double)tv.tv_sec * 10) + ((double)tv.tv_usec / 100000);\n   *timedOut = (newTime - *oldTime > this->settings->delay);\n   *rescan = *rescan || *timedOut;\n   if (newTime < *oldTime) *rescan = true; // clock was adjusted?\n   if (*rescan) {\n      *oldTime = newTime;\n      ProcessList_scan(pl);\n      if (*sortTimeout == 0 || this->settings->treeView) {\n         ProcessList_sort(pl);\n         *sortTimeout = 1;\n      }\n      *redraw = true;\n   }\n   if (*redraw) {\n      ProcessList_rebuildPanel(pl);\n      Header_draw(this->header);\n   }\n   *rescan = false;\n}\n\nstatic void ScreenManager_drawPanels(ScreenManager* this, int focus) {\n   const int nPanels = this->panelCount;\n   for (int i = 0; i < nPanels; i++) {\n      Panel* panel = (Panel*) Vector_get(this->panels, i);\n      Panel_draw(panel, i == focus);\n      if (this->orientation == HORIZONTAL) {\n         mvvline(panel->y, panel->x+panel->w, ' ', panel->h+1);\n      }\n   }\n}\n\nstatic Panel* setCurrentPanel(Panel* panel) {\n   FunctionBar_draw(panel->currentBar, NULL);\n   return panel;\n}\n\nvoid ScreenManager_run(ScreenManager* this, Panel** lastFocus, int* lastKey) {\n   bool quit = false;\n   int focus = 0;\n   \n   Panel* panelFocus = setCurrentPanel((Panel*) Vector_get(this->panels, focus));\n\n   double oldTime = 0.0;\n\n   int ch = ERR;\n   int closeTimeout = 0;\n\n   bool timedOut = true;\n   bool redraw = true;\n   bool rescan = false;\n   int sortTimeout = 0;\n   int resetSortTimeout = 5;\n\n   while (!quit) {\n      if (this->header) {\n         checkRecalculation(this, &oldTime, &sortTimeout, &redraw, &rescan, &timedOut);\n      }\n      \n      if (redraw) {\n         ScreenManager_drawPanels(this, focus);\n      }\n\n      int prevCh = ch;\n      set_escdelay(25);\n      ch = getch();\n\n      HandlerResult result = IGNORED;\n      if (ch == KEY_MOUSE) {\n         ch = ERR;\n         MEVENT mevent;\n         int ok = getmouse(&mevent);\n         if (ok == OK) {\n            if (mevent.bstate & BUTTON1_RELEASED) {\n               if (mevent.y == LINES - 1) {\n                  ch = FunctionBar_synthesizeEvent(panelFocus->currentBar, mevent.x);\n               } else {\n                  for (int i = 0; i < this->panelCount; i++) {\n                     Panel* panel = (Panel*) Vector_get(this->panels, i);\n                     if (mevent.x >= panel->x && mevent.x <= panel->x+panel->w) {\n                        if (mevent.y == panel->y) {\n                           ch = EVENT_HEADER_CLICK(mevent.x - panel->x);\n                           break;\n                        } else if (mevent.y > panel->y && mevent.y <= panel->y+panel->h) {\n                           ch = KEY_MOUSE;\n                           if (panel == panelFocus || this->allowFocusChange) {\n                              focus = i;\n                              panelFocus = setCurrentPanel(panel);\n                              Object* oldSelection = Panel_getSelected(panel);\n                              Panel_setSelected(panel, mevent.y - panel->y + panel->scrollV - 1);\n                              if (Panel_getSelected(panel) == oldSelection) {\n                                 ch = KEY_RECLICK;\n                              }\n                           }\n                           break;\n                        }\n                     }\n                  }\n               }\n            #if NCURSES_MOUSE_VERSION > 1\n            } else if (mevent.bstate & BUTTON4_PRESSED) {\n               ch = KEY_WHEELUP;\n            } else if (mevent.bstate & BUTTON5_PRESSED) {\n               ch = KEY_WHEELDOWN;\n            #endif\n            }\n         }\n      }\n      if (ch == ERR) {\n         sortTimeout--;\n         if (prevCh == ch && !timedOut) {\n            closeTimeout++;\n            if (closeTimeout == 100) {\n               break;\n            }\n         } else\n            closeTimeout = 0;\n         redraw = false;\n         continue;\n      }\n      switch (ch) {\n         case KEY_ALT('H'): ch = KEY_LEFT; break;\n         case KEY_ALT('J'): ch = KEY_DOWN; break;\n         case KEY_ALT('K'): ch = KEY_UP; break;\n         case KEY_ALT('L'): ch = KEY_RIGHT; break;\n      }\n      redraw = true;\n      if (Panel_eventHandlerFn(panelFocus)) {\n         result = Panel_eventHandler(panelFocus, ch);\n      }\n      if (result & SYNTH_KEY) {\n         ch = result >> 16;\n      }\n      if (result & REDRAW) {\n         sortTimeout = 0;\n      }\n      if (result & RESCAN) {\n         rescan = true;\n         sortTimeout = 0;\n      }\n      if (result & HANDLED) {\n         continue;\n      } else if (result & BREAK_LOOP) {\n         quit = true;\n         continue;\n      }\n      \n      switch (ch) {\n      case KEY_RESIZE:\n      {\n         ScreenManager_resize(this, this->x1, this->y1, this->x2, this->y2);\n         continue;\n      }\n      case KEY_LEFT:\n      case KEY_CTRL('B'):\n         if (this->panelCount < 2) {\n            goto defaultHandler;\n         }\n         if (!this->allowFocusChange)\n            break;\n         tryLeft:\n         if (focus > 0)\n            focus--;\n         panelFocus = setCurrentPanel((Panel*) Vector_get(this->panels, focus));\n         if (Panel_size(panelFocus) == 0 && focus > 0)\n            goto tryLeft;\n         break;\n      case KEY_RIGHT:\n      case KEY_CTRL('F'):\n      case 9:\n         if (this->panelCount < 2) {\n            goto defaultHandler;\n         }\n         if (!this->allowFocusChange)\n            break;\n         tryRight:\n         if (focus < this->panelCount - 1)\n            focus++;\n         panelFocus = setCurrentPanel((Panel*) Vector_get(this->panels, focus));\n         if (Panel_size(panelFocus) == 0 && focus < this->panelCount - 1)\n            goto tryRight;\n         break;\n      case KEY_F(10):\n      case 'q':\n      case 27:\n         quit = true;\n         continue;\n      default:\n         defaultHandler:\n         sortTimeout = resetSortTimeout;\n         Panel_onKey(panelFocus, ch);\n         break;\n      }\n   }\n\n   if (lastFocus)\n      *lastFocus = panelFocus;\n   if (lastKey)\n      *lastKey = ch;\n}\n"
        },
        {
          "name": "ScreenManager.h",
          "type": "blob",
          "size": 1.232421875,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_ScreenManager\n#define HEADER_ScreenManager\n/*\nhtop - ScreenManager.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"FunctionBar.h\"\n#include \"Vector.h\"\n#include \"Header.h\"\n#include \"Settings.h\"\n#include \"Panel.h\"\n\ntypedef enum Orientation_ {\n   VERTICAL,\n   HORIZONTAL\n} Orientation;\n\ntypedef struct ScreenManager_ {\n   int x1;\n   int y1;\n   int x2;\n   int y2;\n   Orientation orientation;\n   Vector* panels;\n   int panelCount;\n   const Header* header;\n   const Settings* settings;\n   bool owner;\n   bool allowFocusChange;\n} ScreenManager;\n\n\nScreenManager* ScreenManager_new(int x1, int y1, int x2, int y2, Orientation orientation, const Header* header, const Settings* settings, bool owner);\n\nvoid ScreenManager_delete(ScreenManager* this);\n\nextern int ScreenManager_size(ScreenManager* this);\n\nvoid ScreenManager_add(ScreenManager* this, Panel* item, int size);\n\nPanel* ScreenManager_remove(ScreenManager* this, int idx);\n\nvoid ScreenManager_resize(ScreenManager* this, int x1, int y1, int x2, int y2);\n\nvoid ScreenManager_run(ScreenManager* this, Panel** lastFocus, int* lastKey);\n\n#endif\n"
        },
        {
          "name": "Settings.c",
          "type": "blob",
          "size": 13.9482421875,
          "content": "/*\nhtop - Settings.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Settings.h\"\n#include \"Platform.h\"\n\n#include \"StringUtils.h\"\n#include \"Vector.h\"\n#include \"CRT.h\"\n\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define DEFAULT_DELAY 15\n\n/*{\n#include \"Process.h\"\n#include <stdbool.h>\n\ntypedef struct {\n   int len;\n   char** names;\n   int* modes;\n} MeterColumnSettings;\n\ntypedef struct Settings_ {\n   char* filename;\n   \n   MeterColumnSettings columns[2];\n\n   ProcessField* fields;\n   int flags;\n   int colorScheme;\n   int delay;\n\n   int cpuCount;\n   int direction;\n   ProcessField sortKey;\n\n   bool countCPUsFromZero;\n   bool detailedCPUTime;\n   bool treeView;\n   bool showProgramPath;\n   bool hideThreads;\n   bool shadowOtherUsers;\n   bool showThreadNames;\n   bool hideKernelThreads;\n   bool hideUserlandThreads;\n   bool highlightBaseName;\n   bool highlightMegabytes;\n   bool highlightThreads;\n   bool updateProcessNames;\n   bool accountGuestInCPUMeter;\n   bool headerMargin;\n\n   bool changed;\n} Settings;\n\n#ifndef Settings_cpuId\n#define Settings_cpuId(settings, cpu) ((settings)->countCPUsFromZero ? (cpu) : (cpu)+1)\n#endif\n\n}*/\n\nvoid Settings_delete(Settings* this) {\n   free(this->filename);\n   free(this->fields);\n   for (unsigned int i = 0; i < (sizeof(this->columns)/sizeof(MeterColumnSettings)); i++) {\n      String_freeArray(this->columns[i].names);\n      free(this->columns[i].modes);\n   }\n   free(this);\n}\n\nstatic void Settings_readMeters(Settings* this, char* line, int column) {\n   char* trim = String_trim(line);\n   int nIds;\n   char** ids = String_split(trim, ' ', &nIds);\n   free(trim);\n   this->columns[column].names = ids;\n}\n\nstatic void Settings_readMeterModes(Settings* this, char* line, int column) {\n   char* trim = String_trim(line);\n   int nIds;\n   char** ids = String_split(trim, ' ', &nIds);\n   free(trim);\n   int len = 0;\n   for (int i = 0; ids[i]; i++) {\n      len++;\n   }\n   this->columns[column].len = len;\n   int* modes = xCalloc(len, sizeof(int));\n   for (int i = 0; i < len; i++) {\n      modes[i] = atoi(ids[i]);\n   }\n   String_freeArray(ids);\n   this->columns[column].modes = modes;\n}\n\nstatic void Settings_defaultMeters(Settings* this) {\n   int sizes[] = { 3, 3 };\n   if (this->cpuCount > 4) {\n      sizes[1]++;\n   }\n   for (int i = 0; i < 2; i++) {\n      this->columns[i].names = xCalloc(sizes[i] + 1, sizeof(char*));\n      this->columns[i].modes = xCalloc(sizes[i], sizeof(int));\n      this->columns[i].len = sizes[i];\n   }\n   \n   int r = 0;\n   if (this->cpuCount > 8) {\n      this->columns[0].names[0] = xStrdup(\"LeftCPUs2\");\n      this->columns[0].modes[0] = BAR_METERMODE;\n      this->columns[1].names[r] = xStrdup(\"RightCPUs2\");\n      this->columns[1].modes[r++] = BAR_METERMODE;\n   } else if (this->cpuCount > 4) {\n      this->columns[0].names[0] = xStrdup(\"LeftCPUs\");\n      this->columns[0].modes[0] = BAR_METERMODE;\n      this->columns[1].names[r] = xStrdup(\"RightCPUs\");\n      this->columns[1].modes[r++] = BAR_METERMODE;\n   } else {\n      this->columns[0].names[0] = xStrdup(\"AllCPUs\");\n      this->columns[0].modes[0] = BAR_METERMODE;\n   }\n   this->columns[0].names[1] = xStrdup(\"Memory\");\n   this->columns[0].modes[1] = BAR_METERMODE;\n   this->columns[0].names[2] = xStrdup(\"Swap\");\n   this->columns[0].modes[2] = BAR_METERMODE;\n   \n   this->columns[1].names[r] = xStrdup(\"Tasks\");\n   this->columns[1].modes[r++] = TEXT_METERMODE;\n   this->columns[1].names[r] = xStrdup(\"LoadAverage\");\n   this->columns[1].modes[r++] = TEXT_METERMODE;\n   this->columns[1].names[r] = xStrdup(\"Uptime\");\n   this->columns[1].modes[r++] = TEXT_METERMODE;\n}\n\nstatic void readFields(ProcessField* fields, int* flags, const char* line) {\n   char* trim = String_trim(line);\n   int nIds;\n   char** ids = String_split(trim, ' ', &nIds);\n   free(trim);\n   int i, j;\n   *flags = 0;\n   for (j = 0, i = 0; i < Platform_numberOfFields && ids[i]; i++) {\n      // This \"+1\" is for compatibility with the older enum format.\n      int id = atoi(ids[i]) + 1;\n      if (id > 0 && Process_fields[id].name && id < Platform_numberOfFields) {\n         fields[j] = id;\n         *flags |= Process_fields[id].flags;\n         j++;\n      }\n   }\n   fields[j] = NULL_PROCESSFIELD;\n   String_freeArray(ids);\n}\n\nstatic bool Settings_read(Settings* this, const char* fileName) {\n   FILE* fd;\n   \n   CRT_dropPrivileges();\n   fd = fopen(fileName, \"r\");\n   CRT_restorePrivileges();\n   if (!fd)\n      return false;\n   \n   bool didReadMeters = false;\n   bool didReadFields = false;\n   for (;;) {\n      char* line = String_readLine(fd);\n      if (!line) {\n         break;\n      }\n      int nOptions;\n      char** option = String_split(line, '=', &nOptions);\n      free (line);\n      if (nOptions < 2) {\n         String_freeArray(option);\n         continue;\n      }\n      if (String_eq(option[0], \"fields\")) {\n         readFields(this->fields, &(this->flags), option[1]);\n         didReadFields = true;\n      } else if (String_eq(option[0], \"sort_key\")) {\n         // This \"+1\" is for compatibility with the older enum format.\n         this->sortKey = atoi(option[1]) + 1;\n      } else if (String_eq(option[0], \"sort_direction\")) {\n         this->direction = atoi(option[1]);\n      } else if (String_eq(option[0], \"tree_view\")) {\n         this->treeView = atoi(option[1]);\n      } else if (String_eq(option[0], \"hide_threads\")) {\n         this->hideThreads = atoi(option[1]);\n      } else if (String_eq(option[0], \"hide_kernel_threads\")) {\n         this->hideKernelThreads = atoi(option[1]);\n      } else if (String_eq(option[0], \"hide_userland_threads\")) {\n         this->hideUserlandThreads = atoi(option[1]);\n      } else if (String_eq(option[0], \"shadow_other_users\")) {\n         this->shadowOtherUsers = atoi(option[1]);\n      } else if (String_eq(option[0], \"show_thread_names\")) {\n         this->showThreadNames = atoi(option[1]);\n      } else if (String_eq(option[0], \"show_program_path\")) {\n         this->showProgramPath = atoi(option[1]);\n      } else if (String_eq(option[0], \"highlight_base_name\")) {\n         this->highlightBaseName = atoi(option[1]);\n      } else if (String_eq(option[0], \"highlight_megabytes\")) {\n         this->highlightMegabytes = atoi(option[1]);\n      } else if (String_eq(option[0], \"highlight_threads\")) {\n         this->highlightThreads = atoi(option[1]);\n      } else if (String_eq(option[0], \"header_margin\")) {\n         this->headerMargin = atoi(option[1]);\n      } else if (String_eq(option[0], \"expand_system_time\")) {\n         // Compatibility option.\n         this->detailedCPUTime = atoi(option[1]);\n      } else if (String_eq(option[0], \"detailed_cpu_time\")) {\n         this->detailedCPUTime = atoi(option[1]);\n      } else if (String_eq(option[0], \"cpu_count_from_zero\")) {\n         this->countCPUsFromZero = atoi(option[1]);\n      } else if (String_eq(option[0], \"update_process_names\")) {\n         this->updateProcessNames = atoi(option[1]);\n      } else if (String_eq(option[0], \"account_guest_in_cpu_meter\")) {\n         this->accountGuestInCPUMeter = atoi(option[1]);\n      } else if (String_eq(option[0], \"delay\")) {\n         this->delay = atoi(option[1]);\n      } else if (String_eq(option[0], \"color_scheme\")) {\n         this->colorScheme = atoi(option[1]);\n         if (this->colorScheme < 0 || this->colorScheme >= LAST_COLORSCHEME) this->colorScheme = 0;\n      } else if (String_eq(option[0], \"left_meters\")) {\n         Settings_readMeters(this, option[1], 0);\n         didReadMeters = true;\n      } else if (String_eq(option[0], \"right_meters\")) {\n         Settings_readMeters(this, option[1], 1);\n         didReadMeters = true;\n      } else if (String_eq(option[0], \"left_meter_modes\")) {\n         Settings_readMeterModes(this, option[1], 0);\n         didReadMeters = true;\n      } else if (String_eq(option[0], \"right_meter_modes\")) {\n         Settings_readMeterModes(this, option[1], 1);\n         didReadMeters = true;\n      }\n      String_freeArray(option);\n   }\n   fclose(fd);\n   if (!didReadMeters) {\n      Settings_defaultMeters(this);\n   }\n   return didReadFields;\n}\n\nstatic void writeFields(FILE* fd, ProcessField* fields, const char* name) {\n   fprintf(fd, \"%s=\", name);\n   const char* sep = \"\";\n   for (int i = 0; fields[i]; i++) {\n      // This \"-1\" is for compatibility with the older enum format.\n      fprintf(fd, \"%s%d\", sep, (int) fields[i]-1);\n      sep = \" \";\n   }\n   fprintf(fd, \"\\n\");\n}\n\nstatic void writeMeters(Settings* this, FILE* fd, int column) {\n   const char* sep = \"\";\n   for (int i = 0; i < this->columns[column].len; i++) {\n      fprintf(fd, \"%s%s\", sep, this->columns[column].names[i]);\n      sep = \" \";\n   }\n   fprintf(fd, \"\\n\");\n}\n\nstatic void writeMeterModes(Settings* this, FILE* fd, int column) {\n   const char* sep = \"\";\n   for (int i = 0; i < this->columns[column].len; i++) {\n      fprintf(fd, \"%s%d\", sep, this->columns[column].modes[i]);\n      sep = \" \";\n   }\n   fprintf(fd, \"\\n\");\n}\n\nbool Settings_write(Settings* this) {\n   FILE* fd;\n\n   CRT_dropPrivileges();\n   fd = fopen(this->filename, \"w\");\n   CRT_restorePrivileges();\n\n   if (fd == NULL) {\n      return false;\n   }\n   fprintf(fd, \"# Beware! This file is rewritten by htop when settings are changed in the interface.\\n\");\n   fprintf(fd, \"# The parser is also very primitive, and not human-friendly.\\n\");\n   writeFields(fd, this->fields, \"fields\");\n   // This \"-1\" is for compatibility with the older enum format.\n   fprintf(fd, \"sort_key=%d\\n\", (int) this->sortKey-1);\n   fprintf(fd, \"sort_direction=%d\\n\", (int) this->direction);\n   fprintf(fd, \"hide_threads=%d\\n\", (int) this->hideThreads);\n   fprintf(fd, \"hide_kernel_threads=%d\\n\", (int) this->hideKernelThreads);\n   fprintf(fd, \"hide_userland_threads=%d\\n\", (int) this->hideUserlandThreads);\n   fprintf(fd, \"shadow_other_users=%d\\n\", (int) this->shadowOtherUsers);\n   fprintf(fd, \"show_thread_names=%d\\n\", (int) this->showThreadNames);\n   fprintf(fd, \"show_program_path=%d\\n\", (int) this->showProgramPath);\n   fprintf(fd, \"highlight_base_name=%d\\n\", (int) this->highlightBaseName);\n   fprintf(fd, \"highlight_megabytes=%d\\n\", (int) this->highlightMegabytes);\n   fprintf(fd, \"highlight_threads=%d\\n\", (int) this->highlightThreads);\n   fprintf(fd, \"tree_view=%d\\n\", (int) this->treeView);\n   fprintf(fd, \"header_margin=%d\\n\", (int) this->headerMargin);\n   fprintf(fd, \"detailed_cpu_time=%d\\n\", (int) this->detailedCPUTime);\n   fprintf(fd, \"cpu_count_from_zero=%d\\n\", (int) this->countCPUsFromZero);\n   fprintf(fd, \"update_process_names=%d\\n\", (int) this->updateProcessNames);\n   fprintf(fd, \"account_guest_in_cpu_meter=%d\\n\", (int) this->accountGuestInCPUMeter);\n   fprintf(fd, \"color_scheme=%d\\n\", (int) this->colorScheme);\n   fprintf(fd, \"delay=%d\\n\", (int) this->delay);\n   fprintf(fd, \"left_meters=\"); writeMeters(this, fd, 0);\n   fprintf(fd, \"left_meter_modes=\"); writeMeterModes(this, fd, 0);\n   fprintf(fd, \"right_meters=\"); writeMeters(this, fd, 1);\n   fprintf(fd, \"right_meter_modes=\"); writeMeterModes(this, fd, 1);\n   fclose(fd);\n   return true;\n}\n\nSettings* Settings_new(int cpuCount) {\n  \n   Settings* this = xCalloc(1, sizeof(Settings));\n\n   this->sortKey = PERCENT_CPU;\n   this->direction = 1;\n   this->hideThreads = false;\n   this->shadowOtherUsers = false;\n   this->showThreadNames = false;\n   this->hideKernelThreads = false;\n   this->hideUserlandThreads = false;\n   this->treeView = false;\n   this->highlightBaseName = false;\n   this->highlightMegabytes = false;\n   this->detailedCPUTime = false;\n   this->countCPUsFromZero = false;\n   this->updateProcessNames = false;\n   this->cpuCount = cpuCount;\n   this->showProgramPath = true;\n   this->highlightThreads = true;\n   \n   this->fields = xCalloc(Platform_numberOfFields+1, sizeof(ProcessField));\n   // TODO: turn 'fields' into a Vector,\n   // (and ProcessFields into proper objects).\n   this->flags = 0;\n   ProcessField* defaults = Platform_defaultFields;\n   for (int i = 0; defaults[i]; i++) {\n      this->fields[i] = defaults[i];\n      this->flags |= Process_fields[defaults[i]].flags;\n   }\n\n   char* legacyDotfile = NULL;\n   char* rcfile = getenv(\"HTOPRC\");\n   if (rcfile) {\n      this->filename = xStrdup(rcfile);\n   } else {\n      const char* home = getenv(\"HOME\");\n      if (!home) home = \"\";\n      const char* xdgConfigHome = getenv(\"XDG_CONFIG_HOME\");\n      char* configDir = NULL;\n      char* htopDir = NULL;\n      if (xdgConfigHome) {\n         this->filename = String_cat(xdgConfigHome, \"/htop/htoprc\");\n         configDir = xStrdup(xdgConfigHome);\n         htopDir = String_cat(xdgConfigHome, \"/htop\");\n      } else {\n         this->filename = String_cat(home, \"/.config/htop/htoprc\");\n         configDir = String_cat(home, \"/.config\");\n         htopDir = String_cat(home, \"/.config/htop\");\n      }\n      legacyDotfile = String_cat(home, \"/.htoprc\");\n      \n      CRT_dropPrivileges();\n      (void) mkdir(configDir, 0700);\n      (void) mkdir(htopDir, 0700);\n      free(htopDir);\n      free(configDir);\n      struct stat st;\n      int err = lstat(legacyDotfile, &st);\n      if (err || S_ISLNK(st.st_mode)) {\n         free(legacyDotfile);\n         legacyDotfile = NULL;\n      }\n      CRT_restorePrivileges();\n   }\n   this->colorScheme = 0;\n   this->changed = false;\n   this->delay = DEFAULT_DELAY;\n   bool ok = false;\n   if (legacyDotfile) {\n      ok = Settings_read(this, legacyDotfile);\n      if (ok) {\n         // Transition to new location and delete old configuration file\n         if (Settings_write(this))\n            unlink(legacyDotfile);\n      }\n      free(legacyDotfile);\n   }\n   if (!ok) {\n      ok = Settings_read(this, this->filename);\n   }\n   if (!ok) {\n      this->changed = true;\n      // TODO: how to get SYSCONFDIR correctly through Autoconf?\n      char* systemSettings = String_cat(SYSCONFDIR, \"/htoprc\");\n      ok = Settings_read(this, systemSettings);\n      free(systemSettings);\n   }\n   if (!ok) {\n      Settings_defaultMeters(this);\n      this->hideKernelThreads = true;\n      this->highlightMegabytes = true;\n      this->highlightThreads = true;\n      this->headerMargin = true;\n   }\n   return this;\n}\n\nvoid Settings_invertSortOrder(Settings* this) {\n   if (this->direction == 1)\n      this->direction = -1;\n   else\n      this->direction = 1;\n}\n"
        },
        {
          "name": "Settings.h",
          "type": "blob",
          "size": 1.314453125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_Settings\n#define HEADER_Settings\n/*\nhtop - Settings.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#define DEFAULT_DELAY 15\n\n#include \"Process.h\"\n#include <stdbool.h>\n\ntypedef struct {\n   int len;\n   char** names;\n   int* modes;\n} MeterColumnSettings;\n\ntypedef struct Settings_ {\n   char* filename;\n   \n   MeterColumnSettings columns[2];\n\n   ProcessField* fields;\n   int flags;\n   int colorScheme;\n   int delay;\n\n   int cpuCount;\n   int direction;\n   ProcessField sortKey;\n\n   bool countCPUsFromZero;\n   bool detailedCPUTime;\n   bool treeView;\n   bool showProgramPath;\n   bool hideThreads;\n   bool shadowOtherUsers;\n   bool showThreadNames;\n   bool hideKernelThreads;\n   bool hideUserlandThreads;\n   bool highlightBaseName;\n   bool highlightMegabytes;\n   bool highlightThreads;\n   bool updateProcessNames;\n   bool accountGuestInCPUMeter;\n   bool headerMargin;\n\n   bool changed;\n} Settings;\n\n#ifndef Settings_cpuId\n#define Settings_cpuId(settings, cpu) ((settings)->countCPUsFromZero ? (cpu) : (cpu)+1)\n#endif\n\n\nvoid Settings_delete(Settings* this);\n\nbool Settings_write(Settings* this);\n\nSettings* Settings_new(int cpuCount);\n\nvoid Settings_invertSortOrder(Settings* this);\n\n#endif\n"
        },
        {
          "name": "SignalsPanel.c",
          "type": "blob",
          "size": 1.4677734375,
          "content": "/*\nhtop - SignalsPanel.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Panel.h\"\n#include \"SignalsPanel.h\"\n#include \"Platform.h\"\n\n#include \"ListItem.h\"\n#include \"RichString.h\"\n\n#include <stdlib.h>\n#include <assert.h>\n#include <signal.h>\n\n#include <ctype.h>\n\n/*{\n\ntypedef struct SignalItem_ {\n   const char* name;\n   int number;\n} SignalItem;\n\n}*/\n\nPanel* SignalsPanel_new() {\n   Panel* this = Panel_new(1, 1, 1, 1, true, Class(ListItem), FunctionBar_newEnterEsc(\"Send   \", \"Cancel \"));\n   const int defaultSignal = SIGTERM;\n   int defaultPosition = 15;\n   unsigned int i;\n   for (i = 0; i < Platform_numberOfSignals; i++) {\n      Panel_set(this, i, (Object*) ListItem_new(Platform_signals[i].name, Platform_signals[i].number));\n      // signal 15 is not always the 15th signal in the table\n      if (Platform_signals[i].number == defaultSignal) {\n         defaultPosition = i;\n      }\n   }\n   #if (defined(SIGRTMIN) && defined(SIGRTMAX))\n   if (SIGRTMAX - SIGRTMIN <= 100) {\n      static char buf[16];\n      for (int sig = SIGRTMIN; sig <= SIGRTMAX; i++, sig++) {\n         int n = sig - SIGRTMIN;\n         xSnprintf(buf, 16, \"%2d SIGRTMIN%-+3d\", sig, n);\n         if (n == 0) {\n            buf[11] = '\\0';\n         }\n         Panel_set(this, i, (Object*) ListItem_new(buf, sig));\n      }\n   }\n   #endif\n   Panel_setHeader(this, \"Send signal:\");\n   Panel_setSelected(this, defaultPosition);\n   return this;\n}\n"
        },
        {
          "name": "SignalsPanel.h",
          "type": "blob",
          "size": 0.3828125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_SignalsPanel\n#define HEADER_SignalsPanel\n/*\nhtop - SignalsPanel.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n\ntypedef struct SignalItem_ {\n   const char* name;\n   int number;\n} SignalItem;\n\n\nPanel* SignalsPanel_new();\n\n#endif\n"
        },
        {
          "name": "StringUtils.c",
          "type": "blob",
          "size": 3.5400390625,
          "content": "/*\nhtop - StringUtils.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"StringUtils.h\"\n#include \"XAlloc.h\"\n\n#include \"config.h\"\n\n#include <string.h>\n#include <strings.h>\n#include <stdlib.h>\n\n/*{\n#include <stdio.h>\n\n#define String_startsWith(s, match) (strncmp((s),(match),strlen(match)) == 0)\n#define String_contains_i(s1, s2) (strcasestr(s1, s2) != NULL)\n}*/\n\n/*\n * String_startsWith gives better performance if strlen(match) can be computed\n * at compile time (e.g. when they are immutable string literals). :)\n */\n\nchar* String_cat(const char* s1, const char* s2) {\n   int l1 = strlen(s1);\n   int l2 = strlen(s2);\n   char* out = xMalloc(l1 + l2 + 1);\n   strncpy(out, s1, l1);\n   strncpy(out+l1, s2, l2+1);\n   return out;\n}\n\nchar* String_trim(const char* in) {\n   while (in[0] == ' ' || in[0] == '\\t' || in[0] == '\\n') {\n      in++;\n   }\n   int len = strlen(in);\n   while (len > 0 && (in[len-1] == ' ' || in[len-1] == '\\t' || in[len-1] == '\\n')) {\n      len--;\n   }\n   char* out = xMalloc(len+1);\n   strncpy(out, in, len);\n   out[len] = '\\0';\n   return out;\n}\n\ninline int String_eq(const char* s1, const char* s2) {\n   if (s1 == NULL || s2 == NULL) {\n      if (s1 == NULL && s2 == NULL)\n         return 1;\n      else\n         return 0;\n   }\n   return (strcmp(s1, s2) == 0);\n}\n\nchar** String_split(const char* s, char sep, int* n) {\n   *n = 0;\n   const int rate = 10;\n   char** out = xCalloc(rate, sizeof(char*));\n   int ctr = 0;\n   int blocks = rate;\n   char* where;\n   while ((where = strchr(s, sep)) != NULL) {\n      int size = where - s;\n      char* token = xMalloc(size + 1);\n      strncpy(token, s, size);\n      token[size] = '\\0';\n      out[ctr] = token;\n      ctr++;\n      if (ctr == blocks) {\n         blocks += rate;\n         out = (char**) xRealloc(out, sizeof(char*) * blocks);\n      }\n      s += size + 1;\n   }\n   if (s[0] != '\\0') {\n      int size = strlen(s);\n      char* token = xMalloc(size + 1);\n      strncpy(token, s, size + 1);\n      out[ctr] = token;\n      ctr++;\n   }\n   out = xRealloc(out, sizeof(char*) * (ctr + 1));\n   out[ctr] = NULL;\n   *n = ctr;\n   return out;\n}\n\nvoid String_freeArray(char** s) {\n   if (!s) {\n      return;\n   }\n   for (int i = 0; s[i] != NULL; i++) {\n      free(s[i]);\n   }\n   free(s);\n}\n\nchar* String_getToken(const char* line, const unsigned short int numMatch) {\n   const unsigned short int len = strlen(line);\n   char inWord = 0;\n   unsigned short int count = 0;\n   char match[50];\n\n   unsigned short int foundCount = 0;\n\n   for (unsigned short int i = 0; i < len; i++) {\n      char lastState = inWord;\n      inWord = line[i] == ' ' ? 0:1;\n\n      if (lastState == 0 && inWord == 1)\n         count++;\n    \n      if(inWord == 1){\n         if (count == numMatch && line[i] != ' ' && line[i] != '\\0' && line[i] != '\\n' && line[i] != (char)EOF) {\n            match[foundCount] = line[i];\n            foundCount++;\n         }\n      }\n   }\n\n   match[foundCount] = '\\0';\n   return((char*)xStrdup(match));\n}\n\nchar* String_readLine(FILE* fd) {\n   const int step = 1024;\n   int bufSize = step;\n   char* buffer = xMalloc(step + 1);\n   char* at = buffer;\n   for (;;) {\n      char* ok = fgets(at, step + 1, fd);\n      if (!ok) {\n         free(buffer);\n         return NULL;\n      }\n      char* newLine = strrchr(at, '\\n');\n      if (newLine) {\n         *newLine = '\\0';\n         return buffer;\n      } else {\n         if (feof(fd)) {\n            return buffer;\n         }\n      }\n      bufSize += step;\n      buffer = xRealloc(buffer, bufSize + 1);\n      at = buffer + bufSize - step;\n   }\n}\n"
        },
        {
          "name": "StringUtils.h",
          "type": "blob",
          "size": 0.91796875,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_StringUtils\n#define HEADER_StringUtils\n/*\nhtop - StringUtils.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include <stdio.h>\n\n#define String_startsWith(s, match) (strncmp((s),(match),strlen(match)) == 0)\n#define String_contains_i(s1, s2) (strcasestr(s1, s2) != NULL)\n\n/*\n * String_startsWith gives better performance if strlen(match) can be computed\n * at compile time (e.g. when they are immutable string literals). :)\n */\n\nchar* String_cat(const char* s1, const char* s2);\n\nchar* String_trim(const char* in);\n\nextern int String_eq(const char* s1, const char* s2);\n\nchar** String_split(const char* s, char sep, int* n);\n\nvoid String_freeArray(char** s);\n\nchar* String_getToken(const char* line, const unsigned short int numMatch);\n\nchar* String_readLine(FILE* fd);\n\n#endif\n"
        },
        {
          "name": "SwapMeter.c",
          "type": "blob",
          "size": 1.4990234375,
          "content": "/*\nhtop - SwapMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"SwapMeter.h\"\n\n#include \"CRT.h\"\n#include \"Platform.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <sys/param.h>\n#include <assert.h>\n\n/*{\n#include \"Meter.h\"\n}*/\n\nint SwapMeter_attributes[] = {\n   SWAP\n};\n\nstatic void SwapMeter_updateValues(Meter* this, char* buffer, int size) {\n   int written;\n   Platform_setSwapValues(this);\n\n   written = Meter_humanUnit(buffer, this->values[0], size);\n   buffer += written;\n   if ((size -= written) > 0) {\n      *buffer++ = '/';\n      size--;\n      Meter_humanUnit(buffer, this->total, size);\n   }\n}\n\nstatic void SwapMeter_display(Object* cast, RichString* out) {\n   char buffer[50];\n   Meter* this = (Meter*)cast;\n   RichString_write(out, CRT_colors[METER_TEXT], \":\");\n   Meter_humanUnit(buffer, this->total, 50);\n   RichString_append(out, CRT_colors[METER_VALUE], buffer);\n   Meter_humanUnit(buffer, this->values[0], 50);\n   RichString_append(out, CRT_colors[METER_TEXT], \" used:\");\n   RichString_append(out, CRT_colors[METER_VALUE], buffer);\n}\n\nMeterClass SwapMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = SwapMeter_display,\n   },\n   .updateValues = SwapMeter_updateValues,\n   .defaultMode = BAR_METERMODE,\n   .maxItems = 1,\n   .total = 100.0,\n   .attributes = SwapMeter_attributes,\n   .name = \"Swap\",\n   .uiName = \"Swap\",\n   .caption = \"Swp\"\n};\n"
        },
        {
          "name": "SwapMeter.h",
          "type": "blob",
          "size": 0.3564453125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_SwapMeter\n#define HEADER_SwapMeter\n/*\nhtop - SwapMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\nextern int SwapMeter_attributes[];\n\nextern MeterClass SwapMeter_class;\n\n#endif\n"
        },
        {
          "name": "TESTPLAN",
          "type": "blob",
          "size": 2.94140625,
          "content": "\nMain screen:\n\n   For all views, all modes:\n\n      Mouse click header - nothing happens.\n      \n      Mouse click on ProcessList title bar - exit Tree view, update FunctionBar, title bar updates, sort by clicked field.\n*** FAILING: wrong FB update depending on mode; does not change sort in wip branch\n         click on same entry - invert sort.\n            click on another entry - sort another field.\n      \n      Mouse click on a process - select that process.\n      \n      for each entry in FunctionBar:\n         Mouse click entry - perform action of associated key.\n      \n   In Normal mode, Sorted view:\n   \n      <+> or <-> - do nothing.\n      \n      <F6> - enter SortBy screen.\n   \n   In Normal mode, Tree view:\n\n      select process - update F6 in FunctionBar if subtree is collapsed or expanded.\n      \n      <F6>, <+> or <-> - expand/collapse subtree.\n   \n   In Normal mode, either Sorted or Tree view:\n\n      <F3>, </> - activate Search mode.\n   \n      <F4>, <\\> - activate Filter mode.\n\n      <F7>, <]> - as root only, decrease process NICE value.\n      \n      <F8>, <[> - increase process NICE value.\n\n      <a> - enter Affinity screen.\n\n      <b> - do nothing.\n      \n      <c> - select process and all its children.\n      \n      <d>, <e>, <f>, <g> - do nothing.\n      \n      <F1>, <h>, <?> - enter Help screen.\n\n      <i> - on Linux, enter IOPriority screen.\n\n      <j> - do nothing.\n\n      <F9>, <k> - enter Kill screen.\n\n      <l> - enter LSOF screen.\n\n      <m>, <n>, <o>, <p> - do nothing.\n\n      <F10>, <q> - quit program.\n\n      <r> - do nothing.\n\n      <s> - enter STrace screen.\n\n      <F5>, <t> - toggle between Tree and Sorted view, update F5 in FunctionBar, follow process\n      \n      <u> - enter User screen.\n\n      <v>, <w>, <x>, <y>, <z> - do nothing.\n      \n      <A>, <B> - do nothing.\n      \n      <F2>, <C>, <S> - enter Setup screen.\n\n      <D>, <E> - do nothing.\n      \n      <F> - follow process.\n\n      <G> - do nothing.\n      \n      <H> - toggle show/hide userland threads.\n      \n      <I> - invert sort order.\n      \n      <J> - do nothing.\n      \n      <K> - toggle show/hide kernel threads.\n\n      <L> - do nothing.\n\n      <M> - enter Sorted view, update function bar, sort by MEM%.\n      \n      <N>, <O> - do nothing.\n\n      <P> - enter Sorted view, update function bar, sort by CPU%.\n\n      <Q>, <R> - do nothing.\n      \n      <T> - enter Sorted view, update function bar, sort by TIME.\n      \n      <U> - untag all processes.\n      \n      <V>, <W>, <X>, <Y>, <Z> - do nothing.\n      \n      <<>, <>>, <,>, <.> - enter SortBy screen.\n      \n      space - tag current process, move down cursor.\n\n      numbers - incremental PID search.\n   \n   In Search mode:\n\n      TODO\n  \n   In Filter mode:\n   \n      TODO\n\nSetup screen:\n\n   TODO\n   \nSortBy screen:\n\n   TODO\n   \nUser screen:\n\n   TODO\n\nKill screen:\n\n   TODO\n\nAffinity screen:\n\n   TODO\n   \nHelp screen:\n\n   any key - back to Main screen.\n\nIOPriority screen:\n\n   TODO\n\nSTrace screen:\n\n   TODO\n\nLSOF screen:\n\n   TODO\n   \n"
        },
        {
          "name": "TasksMeter.c",
          "type": "blob",
          "size": 2.634765625,
          "content": "/*\nhtop - TasksMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"TasksMeter.h\"\n\n#include \"Platform.h\"\n#include \"CRT.h\"\n\n/*{\n#include \"Meter.h\"\n}*/\n\nint TasksMeter_attributes[] = {\n   CPU_KERNEL, PROCESS_THREAD, PROCESS, TASKS_RUNNING\n};\n\nstatic void TasksMeter_updateValues(Meter* this, char* buffer, int len) {\n   ProcessList* pl = this->pl;\n   this->values[0] = pl->kernelThreads;\n   this->values[1] = pl->userlandThreads;\n   this->values[2] = pl->totalTasks - pl->kernelThreads - pl->userlandThreads;\n   this->values[3] = MIN(pl->runningTasks, pl->cpuCount);\n   if (pl->totalTasks > this->total) {\n      this->total = pl->totalTasks;\n   }\n   if (this->pl->settings->hideKernelThreads) {\n      this->values[0] = 0;\n   }\n   xSnprintf(buffer, len, \"%d/%d\", (int) this->values[3], (int) this->total);\n}\n\nstatic void TasksMeter_display(Object* cast, RichString* out) {\n   Meter* this = (Meter*)cast;\n   Settings* settings = this->pl->settings;\n   char buffer[20];\n   \n   int processes = (int) this->values[2];\n   \n   xSnprintf(buffer, sizeof(buffer), \"%d\", processes);\n   RichString_write(out, CRT_colors[METER_VALUE], buffer);\n   int threadValueColor = CRT_colors[METER_VALUE];\n   int threadCaptionColor = CRT_colors[METER_TEXT];\n   if (settings->highlightThreads) {\n      threadValueColor = CRT_colors[PROCESS_THREAD_BASENAME];\n      threadCaptionColor = CRT_colors[PROCESS_THREAD];\n   }\n   if (!settings->hideUserlandThreads) {\n      RichString_append(out, CRT_colors[METER_TEXT], \", \");\n      xSnprintf(buffer, sizeof(buffer), \"%d\", (int)this->values[1]);\n      RichString_append(out, threadValueColor, buffer);\n      RichString_append(out, threadCaptionColor, \" thr\");\n   }\n   if (!settings->hideKernelThreads) {\n      RichString_append(out, CRT_colors[METER_TEXT], \", \");\n      xSnprintf(buffer, sizeof(buffer), \"%d\", (int)this->values[0]);\n      RichString_append(out, threadValueColor, buffer);\n      RichString_append(out, threadCaptionColor, \" kthr\");\n   }\n   RichString_append(out, CRT_colors[METER_TEXT], \"; \");\n   xSnprintf(buffer, sizeof(buffer), \"%d\", (int)this->values[3]);\n   RichString_append(out, CRT_colors[TASKS_RUNNING], buffer);\n   RichString_append(out, CRT_colors[METER_TEXT], \" running\");\n}\n\nMeterClass TasksMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete,\n      .display = TasksMeter_display,\n   },\n   .updateValues = TasksMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .maxItems = 4,\n   .total = 100.0,\n   .attributes = TasksMeter_attributes, \n   .name = \"Tasks\",\n   .uiName = \"Task counter\",\n   .caption = \"Tasks: \"\n};\n"
        },
        {
          "name": "TasksMeter.h",
          "type": "blob",
          "size": 0.361328125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_TasksMeter\n#define HEADER_TasksMeter\n/*\nhtop - TasksMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\nextern int TasksMeter_attributes[];\n\nextern MeterClass TasksMeter_class;\n\n#endif\n"
        },
        {
          "name": "TraceScreen.c",
          "type": "blob",
          "size": 4.9453125,
          "content": "/*\nhtop - TraceScreen.c\n(C) 2005-2006 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"TraceScreen.h\"\n\n#include \"CRT.h\"\n#include \"InfoScreen.h\"\n#include \"ProcessList.h\"\n#include \"ListItem.h\"\n#include \"IncSet.h\"\n#include \"StringUtils.h\"\n#include \"FunctionBar.h\"\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <signal.h>\n\n/*{\n#include \"InfoScreen.h\"\n\ntypedef struct TraceScreen_ {\n   InfoScreen super;\n   bool tracing;\n   int fdpair[2];\n   int child;\n   FILE* strace;\n   int fd_strace;\n   bool contLine;\n   bool follow;\n} TraceScreen;\n\n}*/\n\nstatic const char* const TraceScreenFunctions[] = {\"Search \", \"Filter \", \"AutoScroll \", \"Stop Tracing   \", \"Done   \", NULL};\n\nstatic const char* const TraceScreenKeys[] = {\"F3\", \"F4\", \"F8\", \"F9\", \"Esc\"};\n\nstatic int TraceScreenEvents[] = {KEY_F(3), KEY_F(4), KEY_F(8), KEY_F(9), 27};\n\nInfoScreenClass TraceScreen_class = {\n   .super = {\n      .extends = Class(Object),\n      .delete = TraceScreen_delete\n   },\n   .draw = TraceScreen_draw,\n   .onErr = TraceScreen_updateTrace,\n   .onKey = TraceScreen_onKey,\n};\n\nTraceScreen* TraceScreen_new(Process* process) {\n   TraceScreen* this = xMalloc(sizeof(TraceScreen));\n   Object_setClass(this, Class(TraceScreen));\n   this->tracing = true;\n   this->contLine = false;\n   this->follow = false;\n   FunctionBar* fuBar = FunctionBar_new(TraceScreenFunctions, TraceScreenKeys, TraceScreenEvents);\n   CRT_disableDelay();\n   return (TraceScreen*) InfoScreen_init(&this->super, process, fuBar, LINES-2, \"\");\n}\n\nvoid TraceScreen_delete(Object* cast) {\n   TraceScreen* this = (TraceScreen*) cast;\n   if (this->child > 0) {\n      kill(this->child, SIGTERM);\n      waitpid(this->child, NULL, 0);\n      fclose(this->strace);\n   }\n   CRT_enableDelay();\n   free(InfoScreen_done((InfoScreen*)cast));\n}\n\nvoid TraceScreen_draw(InfoScreen* this) {\n   attrset(CRT_colors[PANEL_HEADER_FOCUS]);\n   mvhline(0, 0, ' ', COLS);\n   mvprintw(0, 0, \"Trace of process %d - %s\", this->process->pid, this->process->comm);\n   attrset(CRT_colors[DEFAULT_COLOR]);\n   IncSet_drawBar(this->inc);\n}\n\nbool TraceScreen_forkTracer(TraceScreen* this) {\n   char buffer[1001];\n   int error = pipe(this->fdpair);\n   if (error == -1) return false;\n   this->child = fork();\n   if (this->child == -1) return false;\n   if (this->child == 0) {\n      CRT_dropPrivileges();\n      dup2(this->fdpair[1], STDERR_FILENO);\n      int ok = fcntl(this->fdpair[1], F_SETFL, O_NONBLOCK);\n      if (ok != -1) {\n         xSnprintf(buffer, sizeof(buffer), \"%d\", this->super.process->pid);\n         execlp(\"strace\", \"strace\", \"-s\", \"512\", \"-p\", buffer, NULL);\n      }\n      const char* message = \"Could not execute 'strace'. Please make sure it is available in your $PATH.\";\n      ssize_t written = write(this->fdpair[1], message, strlen(message));\n      (void) written;\n      exit(1);\n   }\n   int ok = fcntl(this->fdpair[0], F_SETFL, O_NONBLOCK);\n   if (ok == -1) return false;\n   this->strace = fdopen(this->fdpair[0], \"r\");\n   this->fd_strace = fileno(this->strace);\n   return true;\n}\n\nvoid TraceScreen_updateTrace(InfoScreen* super) {\n   TraceScreen* this = (TraceScreen*) super;\n   char buffer[1001];\n   fd_set fds;\n   FD_ZERO(&fds);\n// FD_SET(STDIN_FILENO, &fds);\n   FD_SET(this->fd_strace, &fds);\n   struct timeval tv;\n   tv.tv_sec = 0; tv.tv_usec = 500;\n   int ready = select(this->fd_strace+1, &fds, NULL, NULL, &tv);\n   int nread = 0;\n   if (ready > 0 && FD_ISSET(this->fd_strace, &fds))\n      nread = fread(buffer, 1, 1000, this->strace);\n   if (nread && this->tracing) {\n      char* line = buffer;\n      buffer[nread] = '\\0';\n      for (int i = 0; i < nread; i++) {\n         if (buffer[i] == '\\n') {\n            buffer[i] = '\\0';\n            if (this->contLine) {\n               InfoScreen_appendLine(&this->super, line);\n               this->contLine = false;\n            } else {\n               InfoScreen_addLine(&this->super, line);\n            }\n            line = buffer+i+1;\n         }\n      }\n      if (line < buffer+nread) {\n         InfoScreen_addLine(&this->super, line);\n         buffer[nread] = '\\0';\n         this->contLine = true;\n      }\n      if (this->follow)\n         Panel_setSelected(this->super.display, Panel_size(this->super.display)-1);\n   }\n}\n\nbool TraceScreen_onKey(InfoScreen* super, int ch) {\n   TraceScreen* this = (TraceScreen*) super;\n   switch(ch) {\n      case 'f':\n      case KEY_F(8):\n         this->follow = !(this->follow);\n         if (this->follow)\n            Panel_setSelected(super->display, Panel_size(super->display)-1);\n         return true;\n      case 't':\n      case KEY_F(9):\n         this->tracing = !this->tracing;\n         FunctionBar_setLabel(super->display->defaultBar, KEY_F(9), this->tracing?\"Stop Tracing   \":\"Resume Tracing \");\n         InfoScreen_draw(this);\n         return true;\n   }\n   this->follow = false;\n   return false;\n}\n"
        },
        {
          "name": "TraceScreen.h",
          "type": "blob",
          "size": 0.7958984375,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_TraceScreen\n#define HEADER_TraceScreen\n/*\nhtop - TraceScreen.h\n(C) 2005-2006 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"InfoScreen.h\"\n\ntypedef struct TraceScreen_ {\n   InfoScreen super;\n   bool tracing;\n   int fdpair[2];\n   int child;\n   FILE* strace;\n   int fd_strace;\n   bool contLine;\n   bool follow;\n} TraceScreen;\n\n\nextern InfoScreenClass TraceScreen_class;\n\nTraceScreen* TraceScreen_new(Process* process);\n\nvoid TraceScreen_delete(Object* cast);\n\nvoid TraceScreen_draw(InfoScreen* this);\n\nbool TraceScreen_forkTracer(TraceScreen* this);\n\nvoid TraceScreen_updateTrace(InfoScreen* super);\n\nbool TraceScreen_onKey(InfoScreen* super, int ch);\n\n#endif\n"
        },
        {
          "name": "UptimeMeter.c",
          "type": "blob",
          "size": 1.4560546875,
          "content": "/*\nhtop - UptimeMeter.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"UptimeMeter.h\"\n#include \"Platform.h\"\n#include \"CRT.h\"\n\n/*{\n#include \"Meter.h\"\n}*/\n\nint UptimeMeter_attributes[] = {\n   UPTIME\n};\n\nstatic void UptimeMeter_updateValues(Meter* this, char* buffer, int len) {\n   int totalseconds = Platform_getUptime();\n   if (totalseconds == -1) {\n      xSnprintf(buffer, len, \"(unknown)\");\n      return;\n   }\n   int seconds = totalseconds % 60;\n   int minutes = (totalseconds/60) % 60;\n   int hours = (totalseconds/3600) % 24;\n   int days = (totalseconds/86400);\n   this->values[0] = days;\n   if (days > this->total) {\n      this->total = days;\n   }\n   char daysbuf[32];\n   if (days > 100) {\n      xSnprintf(daysbuf, sizeof(daysbuf), \"%d days(!), \", days);\n   } else if (days > 1) {\n      xSnprintf(daysbuf, sizeof(daysbuf), \"%d days, \", days);\n   } else if (days == 1) {\n      xSnprintf(daysbuf, sizeof(daysbuf), \"1 day, \");\n   } else {\n      daysbuf[0] = '\\0';\n   }\n   xSnprintf(buffer, len, \"%s%02d:%02d:%02d\", daysbuf, hours, minutes, seconds);\n}\n\nMeterClass UptimeMeter_class = {\n   .super = {\n      .extends = Class(Meter),\n      .delete = Meter_delete\n   },\n   .updateValues = UptimeMeter_updateValues,\n   .defaultMode = TEXT_METERMODE,\n   .maxItems = 1,\n   .total = 100.0,\n   .attributes = UptimeMeter_attributes,\n   .name = \"Uptime\",\n   .uiName = \"Uptime\",\n   .caption = \"Uptime: \"\n};\n"
        },
        {
          "name": "UptimeMeter.h",
          "type": "blob",
          "size": 0.3662109375,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_UptimeMeter\n#define HEADER_UptimeMeter\n/*\nhtop - UptimeMeter.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Meter.h\"\n\nextern int UptimeMeter_attributes[];\n\nextern MeterClass UptimeMeter_class;\n\n#endif\n"
        },
        {
          "name": "UsersTable.c",
          "type": "blob",
          "size": 1.166015625,
          "content": "/*\nhtop - UsersTable.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"UsersTable.h\"\n#include \"XAlloc.h\"\n\n#include \"config.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <strings.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <assert.h>\n\n/*{\n#include \"Hashtable.h\"\n\ntypedef struct UsersTable_ {\n   Hashtable* users;\n} UsersTable;\n}*/\n\nUsersTable* UsersTable_new() {\n   UsersTable* this;\n   this = xMalloc(sizeof(UsersTable));\n   this->users = Hashtable_new(20, true);\n   return this;\n}\n\nvoid UsersTable_delete(UsersTable* this) {\n   Hashtable_delete(this->users);\n   free(this);\n}\n\nchar* UsersTable_getRef(UsersTable* this, unsigned int uid) {\n   char* name = (char*) (Hashtable_get(this->users, uid));\n   if (name == NULL) {\n      struct passwd* userData = getpwuid(uid);\n      if (userData != NULL) {\n         name = xStrdup(userData->pw_name);\n         Hashtable_put(this->users, uid, name);\n      }\n   }\n   return name;\n}\n\ninline void UsersTable_foreach(UsersTable* this, Hashtable_PairFunction f, void* userData) {\n   Hashtable_foreach(this->users, f, userData);\n}\n"
        },
        {
          "name": "UsersTable.h",
          "type": "blob",
          "size": 0.580078125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_UsersTable\n#define HEADER_UsersTable\n/*\nhtop - UsersTable.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Hashtable.h\"\n\ntypedef struct UsersTable_ {\n   Hashtable* users;\n} UsersTable;\n\nUsersTable* UsersTable_new();\n\nvoid UsersTable_delete(UsersTable* this);\n\nchar* UsersTable_getRef(UsersTable* this, unsigned int uid);\n\nextern void UsersTable_foreach(UsersTable* this, Hashtable_PairFunction f, void* userData);\n\n#endif\n"
        },
        {
          "name": "Vector.c",
          "type": "blob",
          "size": 8.0234375,
          "content": "/*\nhtop - Vector.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Vector.h\"\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n/*{\n#include \"Object.h\"\n\n#define swap(a_,x_,y_) do{ void* tmp_ = a_[x_]; a_[x_] = a_[y_]; a_[y_] = tmp_; }while(0)\n\n#ifndef DEFAULT_SIZE\n#define DEFAULT_SIZE -1\n#endif\n\ntypedef struct Vector_ {\n   Object **array;\n   ObjectClass* type;\n   int arraySize;\n   int growthRate;\n   int items;\n   bool owner;\n} Vector;\n\n}*/\n\nVector* Vector_new(ObjectClass* type, bool owner, int size) {\n   Vector* this;\n\n   if (size == DEFAULT_SIZE)\n      size = 10;\n   this = xMalloc(sizeof(Vector));\n   this->growthRate = size;\n   this->array = (Object**) xCalloc(size, sizeof(Object*));\n   this->arraySize = size;\n   this->items = 0;\n   this->type = type;\n   this->owner = owner;\n   return this;\n}\n\nvoid Vector_delete(Vector* this) {\n   if (this->owner) {\n      for (int i = 0; i < this->items; i++)\n         if (this->array[i])\n            Object_delete(this->array[i]);\n   }\n   free(this->array);\n   free(this);\n}\n\n#ifdef DEBUG\n\nstatic inline bool Vector_isConsistent(Vector* this) {\n   assert(this->items <= this->arraySize);\n   if (this->owner) {\n      for (int i = 0; i < this->items; i++)\n         if (this->array[i] && !Object_isA(this->array[i], this->type))\n            return false;\n      return true;\n   } else {\n      return true;\n   }\n}\n\nint Vector_count(Vector* this) {\n   int items = 0;\n   for (int i = 0; i < this->items; i++) {\n      if (this->array[i])\n         items++;\n   }\n   assert(items == this->items);\n   return items;\n}\n\n#endif\n\nvoid Vector_prune(Vector* this) {\n   assert(Vector_isConsistent(this));\n   if (this->owner) {\n      for (int i = 0; i < this->items; i++)\n         if (this->array[i]) {\n            Object_delete(this->array[i]);\n            //this->array[i] = NULL;\n         }\n   }\n   this->items = 0;\n}\n\nstatic int comparisons = 0;\n\nstatic int partition(Object** array, int left, int right, int pivotIndex, Object_Compare compare) {\n   void* pivotValue = array[pivotIndex];\n   swap(array, pivotIndex, right);\n   int storeIndex = left;\n   for (int i = left; i < right; i++) {\n      comparisons++;\n      if (compare(array[i], pivotValue) <= 0) {\n         swap(array, i, storeIndex);\n         storeIndex++;\n      }\n   }\n   swap(array, storeIndex, right);\n   return storeIndex;\n}\n\nstatic void quickSort(Object** array, int left, int right, Object_Compare compare) {\n   if (left >= right)\n      return;\n   int pivotIndex = (left+right) / 2;\n   int pivotNewIndex = partition(array, left, right, pivotIndex, compare);\n   quickSort(array, left, pivotNewIndex - 1, compare);\n   quickSort(array, pivotNewIndex + 1, right, compare);\n}\n\n// If I were to use only one sorting algorithm for both cases, it would probably be this one:\n/*\n\nstatic void combSort(Object** array, int left, int right, Object_Compare compare) {\n   int gap = right - left;\n   bool swapped = true;\n   while ((gap > 1) || swapped) {\n      if (gap > 1) {\n         gap = (int)((double)gap / 1.247330950103979);\n      }\n      swapped = false;\n      for (int i = left; gap + i <= right; i++) {\n         comparisons++;\n         if (compare(array[i], array[i+gap]) > 0) {\n            swap(array, i, i+gap);\n            swapped = true;\n         }\n      }\n   }\n}\n\n*/\n\nstatic void insertionSort(Object** array, int left, int right, Object_Compare compare) {\n   for (int i = left+1; i <= right; i++) {\n      void* t = array[i];\n      int j = i - 1;\n      while (j >= left) {\n         comparisons++;\n         if (compare(array[j], t) <= 0)\n            break;\n         array[j+1] = array[j];\n         j--;\n      }\n      array[j+1] = t;\n   }\n}\n\nvoid Vector_quickSort(Vector* this) {\n   assert(this->type->compare);\n   assert(Vector_isConsistent(this));\n   quickSort(this->array, 0, this->items - 1, this->type->compare);\n   assert(Vector_isConsistent(this));\n}\n\nvoid Vector_insertionSort(Vector* this) {\n   assert(this->type->compare);\n   assert(Vector_isConsistent(this));\n   insertionSort(this->array, 0, this->items - 1, this->type->compare);\n   assert(Vector_isConsistent(this));\n}\n\nstatic void Vector_checkArraySize(Vector* this) {\n   assert(Vector_isConsistent(this));\n   if (this->items >= this->arraySize) {\n      //int i;\n      //i = this->arraySize;\n      this->arraySize = this->items + this->growthRate;\n      this->array = (Object**) xRealloc(this->array, sizeof(Object*) * this->arraySize);\n      //for (; i < this->arraySize; i++)\n      //   this->array[i] = NULL;\n   }\n   assert(Vector_isConsistent(this));\n}\n\nvoid Vector_insert(Vector* this, int idx, void* data_) {\n   Object* data = data_;\n   assert(idx >= 0);\n   assert(Object_isA(data, this->type));\n   assert(Vector_isConsistent(this));\n\n   if (idx > this->items) {\n      idx = this->items;\n   }\n   \n   Vector_checkArraySize(this);\n   //assert(this->array[this->items] == NULL);\n   for (int i = this->items; i > idx; i--) {\n      this->array[i] = this->array[i-1];\n   }\n   this->array[idx] = data;\n   this->items++;\n   assert(Vector_isConsistent(this));\n}\n\nObject* Vector_take(Vector* this, int idx) {\n   assert(idx >= 0 && idx < this->items);\n   assert(Vector_isConsistent(this));\n   Object* removed = this->array[idx];\n   //assert (removed != NULL);\n   this->items--;\n   for (int i = idx; i < this->items; i++)\n      this->array[i] = this->array[i+1];\n   //this->array[this->items] = NULL;\n   assert(Vector_isConsistent(this));\n   return removed;\n}\n\nObject* Vector_remove(Vector* this, int idx) {\n   Object* removed = Vector_take(this, idx);\n   if (this->owner) {\n      Object_delete(removed);\n      return NULL;\n   } else\n      return removed;\n}\n\nvoid Vector_moveUp(Vector* this, int idx) {\n   assert(idx >= 0 && idx < this->items);\n   assert(Vector_isConsistent(this));\n   if (idx == 0)\n      return;\n   Object* temp = this->array[idx];\n   this->array[idx] = this->array[idx - 1];\n   this->array[idx - 1] = temp;\n}\n\nvoid Vector_moveDown(Vector* this, int idx) {\n   assert(idx >= 0 && idx < this->items);\n   assert(Vector_isConsistent(this));\n   if (idx == this->items - 1)\n      return;\n   Object* temp = this->array[idx];\n   this->array[idx] = this->array[idx + 1];\n   this->array[idx + 1] = temp;\n}\n\nvoid Vector_set(Vector* this, int idx, void* data_) {\n   Object* data = data_;\n   assert(idx >= 0);\n   assert(Object_isA((Object*)data, this->type));\n   assert(Vector_isConsistent(this));\n\n   Vector_checkArraySize(this);\n   if (idx >= this->items) {\n      this->items = idx+1;\n   } else {\n      if (this->owner) {\n         Object* removed = this->array[idx];\n         assert (removed != NULL);\n         if (this->owner) {\n            Object_delete(removed);\n         }\n      }\n   }\n   this->array[idx] = data;\n   assert(Vector_isConsistent(this));\n}\n\n#ifdef DEBUG\n\ninline Object* Vector_get(Vector* this, int idx) {\n   assert(idx < this->items);\n   assert(Vector_isConsistent(this));\n   return this->array[idx];\n}\n\n#else\n\n#define Vector_get(v_, idx_) ((v_)->array[idx_])\n\n#endif\n\n#ifdef DEBUG\n\ninline int Vector_size(Vector* this) {\n   assert(Vector_isConsistent(this));\n   return this->items;\n}\n\n#else\n\n#define Vector_size(v_) ((v_)->items)\n\n#endif\n\n/*\n\nstatic void Vector_merge(Vector* this, Vector* v2) {\n   int i;\n   assert(Vector_isConsistent(this));\n   \n   for (i = 0; i < v2->items; i++)\n      Vector_add(this, v2->array[i]);\n   v2->items = 0;\n   Vector_delete(v2);\n   assert(Vector_isConsistent(this));\n}\n\n*/\n\nvoid Vector_add(Vector* this, void* data_) {\n   Object* data = data_;\n   assert(Object_isA((Object*)data, this->type));\n   assert(Vector_isConsistent(this));\n   int i = this->items;\n   Vector_set(this, this->items, data);\n   assert(this->items == i+1); (void)(i);\n   assert(Vector_isConsistent(this));\n}\n\ninline int Vector_indexOf(Vector* this, void* search_, Object_Compare compare) {\n   Object* search = search_;\n   assert(Object_isA((Object*)search, this->type));\n   assert(compare);\n   assert(Vector_isConsistent(this));\n   for (int i = 0; i < this->items; i++) {\n      Object* o = (Object*)this->array[i];\n      assert(o);\n      if (compare(search, o) == 0)\n         return i;\n   }\n   return -1;\n}\n"
        },
        {
          "name": "Vector.h",
          "type": "blob",
          "size": 1.5673828125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_Vector\n#define HEADER_Vector\n/*\nhtop - Vector.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"Object.h\"\n\n#define swap(a_,x_,y_) do{ void* tmp_ = a_[x_]; a_[x_] = a_[y_]; a_[y_] = tmp_; }while(0)\n\n#ifndef DEFAULT_SIZE\n#define DEFAULT_SIZE -1\n#endif\n\ntypedef struct Vector_ {\n   Object **array;\n   ObjectClass* type;\n   int arraySize;\n   int growthRate;\n   int items;\n   bool owner;\n} Vector;\n\n\nVector* Vector_new(ObjectClass* type, bool owner, int size);\n\nvoid Vector_delete(Vector* this);\n\n#ifdef DEBUG\n\nint Vector_count(Vector* this);\n\n#endif\n\nvoid Vector_prune(Vector* this);\n\n// If I were to use only one sorting algorithm for both cases, it would probably be this one:\n/*\n\n*/\n\nvoid Vector_quickSort(Vector* this);\n\nvoid Vector_insertionSort(Vector* this);\n\nvoid Vector_insert(Vector* this, int idx, void* data_);\n\nObject* Vector_take(Vector* this, int idx);\n\nObject* Vector_remove(Vector* this, int idx);\n\nvoid Vector_moveUp(Vector* this, int idx);\n\nvoid Vector_moveDown(Vector* this, int idx);\n\nvoid Vector_set(Vector* this, int idx, void* data_);\n\n#ifdef DEBUG\n\nextern Object* Vector_get(Vector* this, int idx);\n\n#else\n\n#define Vector_get(v_, idx_) ((v_)->array[idx_])\n\n#endif\n\n#ifdef DEBUG\n\nextern int Vector_size(Vector* this);\n\n#else\n\n#define Vector_size(v_) ((v_)->items)\n\n#endif\n\n/*\n\n*/\n\nvoid Vector_add(Vector* this, void* data_);\n\nextern int Vector_indexOf(Vector* this, void* search_, Object_Compare compare);\n\n#endif\n"
        },
        {
          "name": "XAlloc.c",
          "type": "blob",
          "size": 1.3876953125,
          "content": "\n#include \"XAlloc.h\"\n#include \"RichString.h\"\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <stdlib.h>\n#include <string.h>\n\n/*{\n#include <err.h>\n#include <assert.h>\n#include <stdlib.h>\n}*/\n\nstatic inline void fail() {\n   curs_set(1);\n   endwin();\n   err(1, NULL);\n}\n\nvoid* xMalloc(size_t size) {\n   void* data = malloc(size);\n   if (!data && size > 0) {\n      fail();\n   }\n   return data;\n}\n\nvoid* xCalloc(size_t nmemb, size_t size) {\n   void* data = calloc(nmemb, size);\n   if (!data && nmemb > 0 && size > 0) {\n      fail();\n   }\n   return data;\n}\n\nvoid* xRealloc(void* ptr, size_t size) {\n   void* data = realloc(ptr, size);\n   if (!data && size > 0) {\n      fail();\n   }\n   return data;\n}\n\n#define xSnprintf(fmt, len, ...) do { int _l=len; int _n=snprintf(fmt, _l, __VA_ARGS__); if (!(_n > -1 && _n < _l)) { curs_set(1); endwin(); err(1, NULL); } } while(0)\n\n#undef xStrdup\n#undef xStrdup_\n#ifdef NDEBUG\n# define xStrdup_ xStrdup\n#else\n# define xStrdup(str_) (assert(str_), xStrdup_(str_))\n#endif\n\n#ifndef __has_attribute // Clang's macro\n# define __has_attribute(x) 0\n#endif\n#if (__has_attribute(nonnull) || \\\n    ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)))\nchar* xStrdup_(const char* str) __attribute__((nonnull));\n#endif // __has_attribute(nonnull) || GNU C 3.3 or later\n\nchar* xStrdup_(const char* str) {\n   char* data = strdup(str);\n   if (!data) {\n      fail();\n   }\n   return data;\n}\n"
        },
        {
          "name": "XAlloc.h",
          "type": "blob",
          "size": 0.9453125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_XAlloc\n#define HEADER_XAlloc\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#include <err.h>\n#include <assert.h>\n#include <stdlib.h>\n\nvoid* xMalloc(size_t size);\n\nvoid* xCalloc(size_t nmemb, size_t size);\n\nvoid* xRealloc(void* ptr, size_t size);\n\n#define xSnprintf(fmt, len, ...) do { int _l=len; int _n=snprintf(fmt, _l, __VA_ARGS__); if (!(_n > -1 && _n < _l)) { curs_set(1); endwin(); err(1, NULL); } } while(0)\n\n#undef xStrdup\n#undef xStrdup_\n#ifdef NDEBUG\n# define xStrdup_ xStrdup\n#else\n# define xStrdup(str_) (assert(str_), xStrdup_(str_))\n#endif\n\n#ifndef __has_attribute // Clang's macro\n# define __has_attribute(x) 0\n#endif\n#if (__has_attribute(nonnull) || \\\n    ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)))\nchar* xStrdup_(const char* str) __attribute__((nonnull));\n#endif // __has_attribute(nonnull) || GNU C 3.3 or later\n\nchar* xStrdup_(const char* str);\n\n#endif\n"
        },
        {
          "name": "autogen.sh",
          "type": "blob",
          "size": 0.0498046875,
          "content": "#!/bin/sh\nmkdir -p m4\nautoreconf --install --force\n"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 13.06640625,
          "content": "#                                               -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\n\nAC_PREREQ(2.65)\nAC_INIT([htop],[2.2.0],[hisham@gobolinux.org])\n\nSOURCE_DATE_EPOCH=\"${SOURCE_DATE_EPOCH:-$(date +%s)}\"\nyear=$(date -u -d \"@$SOURCE_DATE_EPOCH\" \"+%Y\" 2>/dev/null || date -u -r \"$SOURCE_DATE_EPOCH\" \"+%Y\" 2>/dev/null || date -u \"+%Y\")\n\nAC_CONFIG_SRCDIR([htop.c])\nAC_CONFIG_AUX_DIR([.])\nAC_CONFIG_HEADERS([config.h])\nAC_CONFIG_MACRO_DIR([m4])\n\n# Required by hwloc scripts\nAC_CANONICAL_TARGET\n\nAM_INIT_AUTOMAKE([1.11])\n\n# Checks for programs.\n# ----------------------------------------------------------------------\nAC_PROG_CC\nAM_PROG_CC_C_O\n\n# Required by hwloc scripts\nAC_USE_SYSTEM_EXTENSIONS\n\n# Checks for platform.\n# ----------------------------------------------------------------------\ncase \"$target_os\" in\nlinux*|gnu*)\n   my_htop_platform=linux\n   ;;\nfreebsd*|kfreebsd*)\n   my_htop_platform=freebsd\n   ;;\nopenbsd*)\n   my_htop_platform=openbsd\n   ;;\ndragonfly*)\n   my_htop_platform=dragonflybsd\n   ;;\ndarwin*)\n   my_htop_platform=darwin\n   ;;\nsolaris*)\n   my_htop_platform=solaris\n   ;;\n*)\n   my_htop_platform=unsupported\n   ;;\nesac\n\n# Checks for libraries.\n# ----------------------------------------------------------------------\nAC_CHECK_LIB([m], [ceil], [], [missing_libraries=\"$missing_libraries libm\"])\n\n# Checks for header files.\n# ----------------------------------------------------------------------\nAC_HEADER_DIRENT\nAC_HEADER_STDC\nAC_CHECK_HEADERS([stdlib.h string.h strings.h sys/param.h sys/time.h unistd.h],[:],[\n  missing_headers=\"$missing_headers $ac_header\"\n])\nAC_CHECK_HEADERS([execinfo.h],[:],[:])\n\nAC_HEADER_MAJOR\ndnl glibc 2.25 deprecates 'major' and 'minor' in <sys/types.h> and requires to\ndnl include <sys/sysmacros.h>. However the logic in AC_HEADER_MAJOR has not yet\ndnl been updated in Autoconf 2.69, so use a workaround:\nm4_version_prereq([2.70], [],\n[if test \"x$ac_cv_header_sys_mkdev_h\" = xno; then\n   AC_CHECK_HEADER(sys/sysmacros.h, [AC_DEFINE(MAJOR_IN_SYSMACROS, 1,\n      [Define to 1 if `major', `minor', and `makedev' are declared in <sys/sysmacros.h>.])])\nfi])\n\n# Checks for typedefs, structures, and compiler characteristics.\n# ----------------------------------------------------------------------\nAC_HEADER_STDBOOL\nAC_C_CONST\nAC_TYPE_PID_T\nAC_TYPE_UID_T\n\n# Checks for library functions and compiler features.\n# ----------------------------------------------------------------------\nAC_FUNC_CLOSEDIR_VOID\nAC_TYPE_SIGNAL\nAC_FUNC_STAT\nAC_CHECK_FUNCS([memmove strncasecmp strstr strdup])\n\nsave_cflags=\"${CFLAGS}\"\nCFLAGS=\"${CFLAGS} -std=c99\"\nAC_MSG_CHECKING([whether gcc -std=c99 option works])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n   [AC_INCLUDES_DEFAULT], [[char *a; a = strdup(\"foo\"); int i = 0; i++; // C99]])],\n   [AC_MSG_RESULT([yes])],\n   [AC_MSG_ERROR([htop is written in C99. A newer version of gcc is required.])])\nCFLAGS=\"$save_cflags\"\n\nsave_cflags=\"${CFLAGS}\"\nCFLAGS=\"$CFLAGS -Wextra\"\nAC_MSG_CHECKING([if compiler supports -Wextra])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([], [])],[\n   wextra_flag=-Wextra\n   AC_MSG_RESULT([yes])\n],[\n   wextra_flag=\n   AC_MSG_RESULT([no])\n])\nCFLAGS=\"$save_cflags\"\nAC_SUBST(wextra_flag)\n\n# Checks for features and flags.\n# ----------------------------------------------------------------------\nPROCDIR=/proc\n\nAC_ARG_ENABLE(proc, [AS_HELP_STRING([--enable-proc], [use Linux-compatible proc filesystem])], enable_proc=\"yes\", enable_proc=\"no\")\nif test \"x$enable_proc\" = xyes; then\n   # An enabled proc assumes we're emulating Linux.\n   my_htop_platform=linux\n   AC_DEFINE(HAVE_PROC, 1, [Define if using a Linux-compatible proc filesystem.])\nfi\n\nAC_ARG_WITH(proc, [AS_HELP_STRING([--with-proc=DIR], [Location of a Linux-compatible proc filesystem (default=/proc).])],\n\nif test -n \"$withval\"; then\n   AC_DEFINE_UNQUOTED(PROCDIR, \"$withval\", [Path of proc filesystem])\n   PROCDIR=\"$withval\"\nfi,\nAC_DEFINE(PROCDIR, \"/proc\", [Path of proc filesystem]))\n\nif test \"x$cross_compiling\" = xno; then\n   if test \"x$enable_proc\" = xyes; then\n      AC_CHECK_FILE($PROCDIR/stat,,AC_MSG_ERROR(Cannot find $PROCDIR/stat. Make sure you have a Linux-compatible /proc filesystem mounted. See the file README for help.))\n      AC_CHECK_FILE($PROCDIR/meminfo,,AC_MSG_ERROR(Cannot find $PROCDIR/meminfo. Make sure you have a Linux-compatible /proc filesystem mounted. See the file README for help.))\n   fi\nfi\n\nAC_ARG_ENABLE(openvz, [AS_HELP_STRING([--enable-openvz], [enable OpenVZ support])], ,enable_openvz=\"no\")\nif test \"x$enable_openvz\" = xyes; then\n   AC_DEFINE(HAVE_OPENVZ, 1, [Define if openvz support enabled.])\nfi\n\nAC_ARG_ENABLE(cgroup, [AS_HELP_STRING([--enable-cgroup], [enable cgroups support])], ,enable_cgroup=\"no\")\nif test \"x$enable_cgroup\" = xyes; then\n   AC_DEFINE(HAVE_CGROUP, 1, [Define if cgroup support enabled.])\nfi\n\nAC_ARG_ENABLE(vserver, [AS_HELP_STRING([--enable-vserver], [enable VServer support])], ,enable_vserver=\"no\")\nif test \"x$enable_vserver\" = xyes; then\n    AC_DEFINE(HAVE_VSERVER, 1, [Define if vserver support enabled.])\nfi\n\nAC_ARG_ENABLE(ancient_vserver, [AS_HELP_STRING([--enable-ancient-vserver], [enable ancient VServer support (implies --enable-vserver)])], ,enable_ancient_vserver=\"no\")\nif test \"x$enable_ancient_vserver\" = xyes; then\n    AC_DEFINE(HAVE_VSERVER, 1, [Define if vserver support enabled.])\n    AC_DEFINE(HAVE_ANCIENT_VSERVER, 1, [Define if ancient vserver support enabled.])\nfi\n\nAC_ARG_ENABLE(taskstats, [AS_HELP_STRING([--enable-taskstats], [enable per-task IO Stats (taskstats kernel sup required)])], ,enable_taskstats=\"yes\")\nif test \"x$enable_taskstats\" = xyes; then\n    AC_DEFINE(HAVE_TASKSTATS, 1, [Define if taskstats support enabled.])\nfi\n\n# HTOP_CHECK_SCRIPT(LIBNAME, FUNCTION, DEFINE, CONFIG_SCRIPT, ELSE_PART)\nm4_define([HTOP_CHECK_SCRIPT],\n[\n   if test ! -z \"m4_toupper($HTOP_[$1]_CONFIG_SCRIPT)\"; then\n      # to be used to set the path to ncurses*-config when cross-compiling\n      htop_config_script_libs=$(m4_toupper($HTOP_[$1]_CONFIG_SCRIPT) --libs 2> /dev/null)\n      htop_config_script_cflags=$(m4_toupper($HTOP_[$1]_CONFIG_SCRIPT) --cflags 2> /dev/null)\n   else\n      htop_config_script_libs=$([$4] --libs 2> /dev/null)\n      htop_config_script_cflags=$([$4] --cflags 2> /dev/null)\n   fi\n   htop_script_success=no\n   htop_save_LDFLAGS=\"$LDFLAGS\"\n   htop_save_CFLAGS=\"$CFLAGS\"\n   if test ! \"x$htop_config_script_libs\" = x; then\n      LDFLAGS=\"$htop_config_script_libs $LDFLAGS\"\n      CFLAGS=\"$htop_config_script_cflags $CFLAGS\"\n      AC_CHECK_LIB([$1], [$2], [\n         AC_DEFINE([$3], 1, [The library is present.])\n         LIBS=\"$htop_config_script_libs $LIBS \"\n         htop_script_success=yes\n      ], [\n        CFLAGS=\"$htop_save_CFLAGS\"\n      ])\n      LDFLAGS=\"$htop_save_LDFLAGS\"\n   fi\n   if test \"x$htop_script_success\" = xno; then\n      [$5]\n   fi\n])\n\n# HTOP_CHECK_LIB(LIBNAME, FUNCTION, DEFINE, ELSE_PART)\nm4_define([HTOP_CHECK_LIB],\n[\n   AC_CHECK_LIB([$1], [$2], [\n      AC_DEFINE([$3], 1, [The library is present.])\n      LIBS=\"-l[$1] $LIBS \"\n   ], [$4])\n])\n\nAC_ARG_ENABLE(unicode, [AS_HELP_STRING([--enable-unicode], [enable Unicode support])], ,enable_unicode=\"yes\")\nif test \"x$enable_unicode\" = xyes; then\n   HTOP_CHECK_SCRIPT([ncursesw6], [addnwstr], [HAVE_LIBNCURSESW], \"ncursesw6-config\",\n    HTOP_CHECK_SCRIPT([ncursesw], [addnwstr], [HAVE_LIBNCURSESW], \"ncursesw6-config\",\n     HTOP_CHECK_SCRIPT([ncursesw], [addnwstr], [HAVE_LIBNCURSESW], \"ncursesw5-config\",\n      HTOP_CHECK_SCRIPT([ncurses], [addnwstr], [HAVE_LIBNCURSESW], \"ncurses5-config\",\n       HTOP_CHECK_LIB([ncursesw6], [addnwstr], [HAVE_LIBNCURSESW],\n        HTOP_CHECK_LIB([ncursesw], [addnwstr], [HAVE_LIBNCURSESW],\n         HTOP_CHECK_LIB([ncurses], [addnwstr], [HAVE_LIBNCURSESW],\n       missing_libraries=\"$missing_libraries libncursesw\"\n       AC_MSG_ERROR([You may want to use --disable-unicode or install libncursesw.])\n   )))))))\n\n   AC_CHECK_HEADERS([ncursesw/curses.h],[:],\n      [AC_CHECK_HEADERS([ncurses/ncurses.h],[:],\n         [AC_CHECK_HEADERS([ncurses/curses.h],[:],\n            [AC_CHECK_HEADERS([ncurses.h],[:],[missing_headers=\"$missing_headers $ac_header\"])])])])\nelse\n   HTOP_CHECK_SCRIPT([ncurses6], [refresh], [HAVE_LIBNCURSES], \"ncurses6-config\",\n    HTOP_CHECK_SCRIPT([ncurses], [refresh], [HAVE_LIBNCURSES], \"ncurses5-config\",\n     HTOP_CHECK_LIB([ncurses6],  [refresh], [HAVE_LIBNCURSES],\n      HTOP_CHECK_LIB([ncurses],  [refresh], [HAVE_LIBNCURSES],\n      missing_libraries=\"$missing_libraries libncurses\"\n   ))))\n   \n   AC_CHECK_HEADERS([curses.h],[:],\n      [AC_CHECK_HEADERS([ncurses/curses.h],[:],\n         [AC_CHECK_HEADERS([ncurses/ncurses.h],[:],\n            [AC_CHECK_HEADERS([ncurses.h],[:],[missing_headers=\"$missing_headers $ac_header\"])])])])\nfi\n\nif test \"$my_htop_platform\" = \"freebsd\"; then\n   AC_CHECK_LIB([kvm], [kvm_open], [], [missing_libraries=\"$missing_libraries libkvm\"])\nfi\n\nif test \"$my_htop_platform\" = \"openbsd\"; then\n   AC_CHECK_LIB([kvm], [kvm_open], [], [missing_libraries=\"$missing_libraries libkvm\"])\nfi\n\nif test \"$my_htop_platform\" = \"solaris\"; then\n   AC_CHECK_LIB([kstat], [kstat_open], [], [missing_libraries=\"$missing_libraries libkstat\"])\n   AC_CHECK_LIB([proc], [Pgrab_error], [], [missing_libraries=\"$missing_libraries libproc\"])\n   AC_CHECK_LIB([malloc], [free], [], [missing_libraries=\"$missing_libraries libmalloc\"])\nfi\n\nAC_ARG_ENABLE(linux_affinity, [AS_HELP_STRING([--enable-linux-affinity], [enable Linux sched_setaffinity and sched_getaffinity for affinity support, disables hwloc])], ,enable_linux_affinity=\"yes\")\nif test \"x$enable_linux_affinity\" = xyes -a \"x$cross_compiling\" = xno; then\n   AC_MSG_CHECKING([for usable sched_setaffinity])\n   AC_RUN_IFELSE([\n     AC_LANG_PROGRAM([[\n       #include <sched.h>\n       #include <errno.h>\n       static cpu_set_t cpuset;\n       ]], [[\n       CPU_ZERO(&cpuset);\n       sched_setaffinity(0, sizeof(cpu_set_t), &cpuset);\n       if (errno == ENOSYS) return 1;\n       ]])],\n     [AC_MSG_RESULT([yes])],\n     [enable_linux_affinity=no\n      AC_MSG_RESULT([no])])\nfi\nif test \"x$enable_linux_affinity\" = xyes; then\n   AC_DEFINE(HAVE_LINUX_AFFINITY, 1, [Define if Linux sched_setaffinity and sched_getaffinity are to be used.])\nfi\n\nAC_ARG_ENABLE(hwloc, [AS_HELP_STRING([--enable-hwloc], [enable hwloc support for CPU affinity])],, enable_hwloc=\"no\")\nif test \"x$enable_hwloc\" = xyes\nthen\n   AC_CHECK_LIB([hwloc], [hwloc_get_proc_cpubind], [], [missing_libraries=\"$missing_libraries libhwloc\"])\n   AC_CHECK_HEADERS([hwloc.h],[:], [missing_headers=\"$missing_headers $ac_header\"])\nfi\n\nAC_ARG_ENABLE(setuid, [AS_HELP_STRING([--enable-setuid], [enable setuid support for platforms that need it])],, enable_setuid=\"no\")\nif test \"x$enable_setuid\" = xyes\nthen\n   AC_DEFINE(HAVE_SETUID_ENABLED, 1, [Define if setuid support should be enabled.])\nfi\n\nAC_ARG_ENABLE(delayacct, [AS_HELP_STRING([--enable-delayacct], [enable Linux delay accounting])],, enable_delayacct=\"no\")\nif test \"x$enable_delayacct\" = xyes\nthen\n   m4_ifdef([PKG_PROG_PKG_CONFIG], [\n      PKG_PROG_PKG_CONFIG()\n      PKG_CHECK_MODULES(LIBNL3, libnl-3.0, [], [missing_libraries=\"$missing_libraries libnl-3\"])\n      PKG_CHECK_MODULES(LIBNL3GENL, libnl-genl-3.0, [], [missing_libraries=\"$missing_libraries libnl-genl-3\"])\n      CFLAGS=\"$CFLAGS $LIBNL3_CFLAGS $LIBNL3GENL_CFLAGS\"\n      LIBS=\"$LIBS $LIBNL3_LIBS $LIBNL3GENL_LIBS\"\n      AC_DEFINE(HAVE_DELAYACCT, 1, [Define if delay accounting support should be enabled.])\n   ], [\n      pkg_m4_absent=1\n      m4_warning([configure is generated without pkg.m4. 'make dist' target will be disabled.])\n      AC_MSG_ERROR([htop on Linux requires pkg-config for checking delayacct requirements. Please install pkg-config and run ./autogen.sh to rebuild the configure script.])\n   ])\nfi\n\n\n# Bail out on errors.\n# ----------------------------------------------------------------------\nif test ! -z \"$missing_libraries\"; then\n  AC_MSG_ERROR([missing libraries: $missing_libraries])\nfi\nif test ! -z \"$missing_headers\"; then\n  AC_MSG_ERROR([missing headers: $missing_headers])\nfi\n\nAC_DEFINE_UNQUOTED(COPYRIGHT, \"(C) 2004-$year Hisham Muhammad\", [Copyright message.])\n\n# We're done, let's go!\n# ----------------------------------------------------------------------\nAM_CONDITIONAL([HTOP_LINUX], [test \"$my_htop_platform\" = linux])\nAM_CONDITIONAL([HTOP_FREEBSD], [test \"$my_htop_platform\" = freebsd])\nAM_CONDITIONAL([HTOP_DRAGONFLYBSD], [test \"$my_htop_platform\" = dragonflybsd])\nAM_CONDITIONAL([HTOP_OPENBSD], [test \"$my_htop_platform\" = openbsd])\nAM_CONDITIONAL([HTOP_DARWIN], [test \"$my_htop_platform\" = darwin])\nAM_CONDITIONAL([HTOP_SOLARIS], [test \"$my_htop_platform\" = solaris])\nAM_CONDITIONAL([HTOP_UNSUPPORTED], [test \"$my_htop_platform\" = unsupported])\nAC_SUBST(my_htop_platform)\nAC_CONFIG_FILES([Makefile htop.1])\nAC_OUTPUT\n\nif test \"$my_htop_platform\" = \"unsupported\"\nthen\n   echo \"\"\n   echo \"****************************************************************\"\n   echo \"WARNING! This platform is not currently supported by htop.\"\n   echo \"\"\n   echo \"The code will build, but it will produce a dummy version of htop\"\n   echo \"which shows no processes, using the files from the unsupported/\"\n   echo \"directory. This is meant to be a skeleton, to be used as a\"\n   echo \"starting point if you are porting htop to a new platform.\"\n   echo \"****************************************************************\"\n   echo \"\"\nfi\n"
        },
        {
          "name": "darwin",
          "type": "tree",
          "content": null
        },
        {
          "name": "dragonflybsd",
          "type": "tree",
          "content": null
        },
        {
          "name": "freebsd",
          "type": "tree",
          "content": null
        },
        {
          "name": "htop.1.in",
          "type": "blob",
          "size": 12.51171875,
          "content": ".TH \"HTOP\" \"1\" \"2015\" \"@PACKAGE_STRING@\" \"Utils\"\n.SH \"NAME\"\nhtop \\- interactive process viewer\n.SH \"SYNOPSIS\"\n.LP \n.B htop [\\fI\\-dChustv\\fR]\n.SH \"DESCRIPTION\"\n.LP \nHtop is a free (GPL) ncurses-based process viewer for Linux.\n.LP\nIt is similar to top, but allows you to scroll vertically and horizontally,\nso you can see all the processes running on the system, along with their full\ncommand lines, as well as viewing them as a process tree, selecting multiple\nprocesses and acting on them all at once.\n.LP\nTasks related to processes (killing, renicing) can be done without\nentering their PIDs.\n.br \n.SH \"COMMAND-LINE OPTIONS\"\n.LP\nMandatory arguments to long options are mandatory for short options too.\n.LP \n.TP\n\\fB\\-d \\-\\-delay=DELAY\\fR\nDelay between updates, in tenths of seconds\n.TP\n\\fB\\-C \\-\\-no-color \\-\\-no-colour\\fR\nStart htop in monochrome mode\n.TP\n\\fB\\-h \\-\\-help\nDisplay a help message and exit\n.TP\n\\fB\\-p \\-\\-pid=PID,PID...\\fR\nShow only the given PIDs\n.TP\n\\fB\\-s \\-\\-sort\\-key COLUMN\\fR\nSort by this column (use \\-\\-sort\\-key help for a column list)\n.TP\n\\fB\\-u \\-\\-user=USERNAME\\fR\nShow only the processes of a given user\n.TP\n\\fB\\-v \\-\\-version\nOutput version information and exit\n.TP\n\\fB\\-t \\-\\-tree\nShow processes in tree view\n.PP\n.br \n.SH \"INTERACTIVE COMMANDS\"\n.LP \nThe following commands are supported while in htop:\n.LP \n.TP 5\n.B Up, Alt-k\nSelect (highlight) the previous process in the process list. Scroll the list\nif necessary.\n.TP\n.B Down, Alt-j\nSelect (highlight) the next process in the process list. Scroll the list if\nnecessary.\n.TP\n.B Left, Alt-h\nScroll the process list left.\n.TP\n.B Right, Alt-l\nScroll the process list right.\n.TP\n.B PgUp, PgDn\nScroll the process list up or down one window.\n.TP\n.B Home\nScroll to the top of the process list and select the first process.\n.TP\n.B End\nScroll to the bottom of the process list and select the last process.\n.TP\n.B Ctrl-A, ^\nScroll left to the beginning of the process entry (i.e. beginning of line).\n.TP\n.B Ctrl-E, $\nScroll right to the end of the process entry (i.e. end of line).\n.TP\n.B Space\nTag or untag a process. Commands that can operate on multiple processes,\nlike \"kill\", will then apply over the list of tagged processes, instead\nof the currently highlighted one.\n.TP\n.B c\nTag the current process and its children. Commands that can operate on multiple\nprocesses, like \"kill\", will then apply over the list of tagged processes,\ninstead of the currently highlighted one.\n.TP\n.B U\nUntag all processes (remove all tags added with the Space or c keys).\n.TP\n.B s\nTrace process system calls: if strace(1) is installed, pressing this key\nwill attach it to the currently selected process, presenting a live\nupdate of system calls issued by the process.\n.TP\n.B l\nDisplay open files for a process: if lsof(1) is installed, pressing this key\nwill display the list of file descriptors opened by the process.\n.TP\n.B F1, h, ?\nGo to the help screen\n.TP\n.B F2, S\nGo to the setup screen, where you can configure the meters displayed at the top\nof the screen, set various display options, choose among color schemes, and\nselect which columns are displayed, in which order.\n.TP\n.B F3, /\nIncrementally search the command lines of all the displayed processes. The\ncurrently selected (highlighted) command will update as you type. While in\nsearch mode, pressing F3 will cycle through matching occurrences.\n.TP\n.B F4, \\\\\\\\\nIncremental process filtering: type in part of a process command line and\nonly processes whose names match will be shown. To cancel filtering,\nenter the Filter option again and press Esc.\n.TP\n.B F5, t\nTree view: organize processes by parenthood, and layout the relations\nbetween them as a tree. Toggling the key will switch between tree and\nyour previously selected sort view. Selecting a sort view will exit\ntree view.\n.TP\n.B F6\nOn sorted view, select a field for sorting, also accessible through < and >.\nThe current sort field is indicated by a highlight in the header.\nOn tree view, expand or collapse the current subtree. A \"+\" indicator in the\ntree node indicates that it is collapsed.\n.TP\n.B F7, ]\nIncrease the selected process's priority (subtract from 'nice' value).\nThis can only be done by the superuser.\n.TP\n.B F8, [\nDecrease the selected process's priority (add to 'nice' value)\n.TP\n.B F9, k\n\"Kill\" process: sends a signal which is selected in a menu, to one or a group\nof processes. If processes were tagged, sends the signal to all tagged processes.\nIf none is tagged, sends to the currently selected process.\n.TP\n.B F10, q\nQuit\n.TP\n.B I\nInvert the sort order: if sort order is increasing, switch to decreasing, and\nvice-versa.\n.TP\n.B +, \\- \nWhen in tree view mode, expand or collapse subtree. When a subtree is collapsed\na \"+\" sign shows to the left of the process name.\n.TP\n.B a (on multiprocessor machines)\nSet CPU affinity: mark which CPUs a process is allowed to use.\n.TP\n.B u\nShow only processes owned by a specified user.\n.TP\n.B M\nSort by memory usage (top compatibility key).\n.TP\n.B P\nSort by processor usage (top compatibility key).\n.TP\n.B T\nSort by time (top compatibility key).\n.TP\n.B F\n\"Follow\" process: if the sort order causes the currently selected process\nto move in the list, make the selection bar follow it. This is useful for\nmonitoring a process: this way, you can keep a process always visible on\nscreen. When a movement key is used, \"follow\" loses effect.\n.TP\n.B K\nHide kernel threads: prevent the threads belonging the kernel to be\ndisplayed in the process list. (This is a toggle key.)\n.TP\n.B H\nHide user threads: on systems that represent them differently than ordinary\nprocesses (such as recent NPTL-based systems), this can hide threads from\nuserspace processes in the process list. (This is a toggle key.)\n.TP\n.B p\nShow full paths to running programs, where applicable. (This is a toggle key.)\n.TP\n.B Ctrl-L\nRefresh: redraw screen and recalculate values.\n.TP\n.B Numbers\nPID search: type in process ID and the selection highlight will be moved to it.\n.PD\n\n.SH \"COLUMNS\"\n.LP \nThe following columns can display data about each process. A value of '\\-' in\nall the rows indicates that a column is unsupported on your system, or\ncurrently unimplemented in htop. The names below are the ones used in the\n\"Available Columns\" section of the setup screen. If a different name is\nshown in htop's main screen, it is shown below in parenthesis.\n.LP \n.TP 5\n.B Command\nThe full command line of the process (i.e. program name and arguments).\n.TP \n.B PID\nThe process ID.\n.TP\n.B STATE (S)\nThe state of the process:\n   \\fBS\\fR for sleeping (idle)\n   \\fBR\\fR for running\n   \\fBD\\fR for disk sleep (uninterruptible)\n   \\fBZ\\fR for zombie (waiting for parent to read its exit status)\n   \\fBT\\fR for traced or suspended (e.g by SIGTSTP)\n   \\fBW\\fR for paging\n.TP\n.B PPID\nThe parent process ID.\n.TP\n.B PGRP\nThe process's group ID.\n.TP\n.B SESSION (SID)\nThe process's session ID.\n.TP \n.B TTY_NR (TTY)\nThe controlling terminal of the process.\n.TP\n.B TPGID\nThe process ID of the foreground process group of the controlling terminal.\n.TP\n.B MINFLT\nThe number of page faults happening in the main memory.\n.TP\n.B CMINFLT\nThe number of minor faults for the process's waited-for children (see MINFLT above).\n.TP\n.B MAJFLT\nThe number of page faults happening out of the main memory.\n.TP\n.B CMAJFLT\nThe number of major faults for the process's waited-for children (see MAJFLT above).\n.TP\n.B UTIME (UTIME+)\nThe user CPU time, which is the amount of time the process has spent executing\non the CPU in user mode (i.e. everything but system calls), measured in clock\nticks.\n.TP\n.B STIME (STIME+)\nThe system CPU time, which is the amount of time the kernel has spent\nexecuting system calls on behalf of the process, measured in clock ticks.\n.TP\n.B CUTIME (CUTIME+)\nThe children's user CPU time, which is the amount of time the process's\nwaited-for children have spent executing in user mode (see UTIME above).\n.TP\n.B CSTIME (CSTIME+)\nThe children's system CPU time, which is the amount of time the kernel has spent\nexecuting system calls on behalf of all the process's waited-for children (see\nSTIME above).\n.TP\n.B PRIORITY (PRI)\nThe kernel's internal priority for the process, usually just its nice value\nplus twenty. Different for real-time processes.\n.TP\n.B NICE (NI)\nThe nice value of a process, from 19 (low priority) to -20 (high priority). A\nhigh value means the process is being nice, letting others have a higher\nrelative priority. The usual OS permission restrictions for adjusting priority apply.\n.TP\n.B STARTTIME (START)\nThe time the process was started.\n.TP\n.B PROCESSOR (CPU)\nThe ID of the CPU the process last executed on.\n.TP\n.B M_SIZE (VIRT)\nThe size of the virtual memory of the process.\n.TP\n.B M_RESIDENT (RES)\nThe resident set size (text + data + stack) of the process (i.e. the size of the\nprocess's used physical memory).\n.TP\n.B M_SHARE (SHR)\nThe size of the process's shared pages.\n.TP\n.B M_TRS (CODE)\nThe text resident set size of the process (i.e. the size of the process's\nexecutable instructions).\n.TP\n.B M_DRS (DATA)\nThe data resident set size (data + stack) of the process (i.e. the size of anything\nexcept the process's executable instructions).\n.TP\n.B M_LRS (LIB)\nThe library size of the process.\n.TP\n.B M_DT (DIRTY)\nThe size of the dirty pages of the process.\n.TP\n.B ST_UID (UID)\nThe user ID of the process owner.\n.TP\n.B PERCENT_CPU (CPU%)\nThe percentage of the CPU time that the process is currently using.\n.TP\n.B PERCENT_MEM (MEM%)\nThe percentage of memory the process is currently using (based on the process's\nresident memory size, see M_RESIDENT above).\n.TP\n.B USER\nThe username of the process owner, or the user ID if the name can't be\ndetermined.\n.TP\n.B TIME (TIME+)\nThe time, measured in clock ticks that the process has spent in user and system\ntime (see UTIME, STIME above).\n.TP\n.B NLWP\nThe number of threads in the process.\n.TP\n.B TGID\nThe thread group ID.\n.TP\n.B CTID\nOpenVZ container ID, a.k.a virtual environment ID.\n.TP\n.B VPID\nOpenVZ process ID.\n.TP\n.B VXID\nVServer process ID.\n.TP\n.B RCHAR (RD_CHAR)\nThe number of bytes the process has read.\n.TP\n.B WCHAR (WR_CHAR)\nThe number of bytes the process has written.\n.TP\n.B SYSCR (RD_SYSC)\nThe number of read(2) syscalls for the process.\n.TP\n.B SYSCW (WR_SYSC)\nThe number of write(2) syscalls for the process.\n.TP\n.B RBYTES (IO_RBYTES)\nBytes of read(2) I/O for the process.\n.TP\n.B WBYTES (IO_WBYTES)\nBytes of write(2) I/O for the process.\n.TP\n.B CNCLWB (IO_CANCEL)\nBytes of cancelled write(2) I/O.\n.TP\n.B IO_READ_RATE (DISK READ)\nThe I/O rate of read(2) in bytes per second, for the process.\n.TP\n.B IO_WRITE_RATE (DISK WRITE)\nThe I/O rate of write(2) in bytes per second, for the process.\n.TP\n.B IO_RATE (DISK R/W)\nThe I/O rate, IO_READ_RATE + IO_WRITE_RATE (see above).\n.TP\n.B CGROUP\nWhich cgroup the process is in.\n.TP\n.B OOM\nOOM killer score.\n.TP\n.B IO_PRIORITY (IO)\nThe I/O scheduling class followed by the priority if the class supports it:\n   \\fBR\\fR for Realtime\n   \\fBB\\fR for Best-effort\n   \\fBid\\fR for Idle\n.TP\n.B PERCENT_CPU_DELAY (CPUD%)\nThe percentage of time spent waiting for a CPU (while runnable). Requires CAP_NET_ADMIN.\n.TP\n.B PERCENT_IO_DELAY (IOD%)\nThe percentage of time spent waiting for the completion of synchronous block I/O. Requires CAP_NET_ADMIN.\n.TP\n.B PERCENT_SWAP_DELAY (SWAPD%)\nThe percentage of time spent swapping in pages. Requires CAP_NET_ADMIN.\n.TP\n.B All other flags\nCurrently unsupported (always displays '-').\n\n.SH \"CONFIG FILE\"\n.LP \nBy default htop reads its configuration from the XDG-compliant path\n~/.config/htop/htoprc -- the configuration file is overwritten by htop's\nin-program Setup configuration, so it should not be hand-edited. If no\nuser configuration exists htop tries to read the system-wide configuration\nfrom @sysconfdir@/htoprc and as a last resort, falls back to its\nhard coded defaults.\n.LP\nYou may override the location of the configuration file using the $HTOPRC\nenvironment variable (so you can have multiple configurations for different\nmachines that share the same home directory, for example).\n\n.SH \"MEMORY SIZES\"\n.LP\nMemory sizes in htop are displayed as they are in tools from the GNU Coreutils\n(when ran with the --human-readable option). This means that sizes are printed\nin powers of 1024. (e.g., 1023M = 1072693248 Bytes)\n.LP\nThe decision to use this convention was made in order to conserve screen space\nand make memory size representations consistent throughout htop.\n\n.SH \"SEE ALSO\"\nproc(5), top(1), free(1), ps(1), uptime(1), limits.conf(5)\n\n.SH \"AUTHORS\"\n.LP \nhtop is developed by Hisham Muhammad <hisham@gobolinux.org>.\n.LP\nThis man page was written by Bartosz Fenski <fenio@o2.pl> for the Debian\nGNU/Linux distribution (but it may be used by others). It was updated by Hisham\nMuhammad, and later by Vincent Launchbury, who wrote the 'Columns' section.\n"
        },
        {
          "name": "htop.c",
          "type": "blob",
          "size": 7.126953125,
          "content": "/*\nhtop - htop.c\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n#include \"config.h\"\n\n#include \"FunctionBar.h\"\n#include \"Hashtable.h\"\n#include \"ColumnsPanel.h\"\n#include \"CRT.h\"\n#include \"MainPanel.h\"\n#include \"ProcessList.h\"\n#include \"ScreenManager.h\"\n#include \"Settings.h\"\n#include \"UsersTable.h\"\n#include \"Platform.h\"\n\n#include <getopt.h>\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n//#link m\n\nstatic void printVersionFlag() {\n   fputs(\"htop \" VERSION \" - \" COPYRIGHT \"\\n\"\n         \"Released under the GNU GPL.\\n\\n\",\n         stdout);\n   exit(0);\n}\n \nstatic void printHelpFlag() {\n   fputs(\"htop \" VERSION \" - \" COPYRIGHT \"\\n\"\n         \"Released under the GNU GPL.\\n\\n\"\n         \"-C --no-color               Use a monochrome color scheme\\n\"\n         \"-d --delay=DELAY            Set the delay between updates, in tenths of seconds\\n\"\n         \"-h --help                   Print this help screen\\n\"\n         \"-s --sort-key=COLUMN        Sort by COLUMN (try --sort-key=help for a list)\\n\"\n         \"-t --tree                   Show the tree view by default\\n\"\n         \"-u --user=USERNAME          Show only processes of a given user\\n\"\n         \"-p --pid=PID,[,PID,PID...]  Show only the given PIDs\\n\"\n         \"-v --version                Print version info\\n\"\n         \"\\n\"\n         \"Long options may be passed with a single dash.\\n\\n\"\n         \"Press F1 inside htop for online help.\\n\"\n         \"See 'man htop' for more information.\\n\",\n         stdout);\n   exit(0);\n}\n\n// ----------------------------------------\n\ntypedef struct CommandLineSettings_ {\n   Hashtable* pidWhiteList;\n   uid_t userId;\n   int sortKey;\n   int delay;\n   bool useColors;\n   bool treeView;\n} CommandLineSettings;\n\nstatic CommandLineSettings parseArguments(int argc, char** argv) {\n\n   CommandLineSettings flags = {\n      .pidWhiteList = NULL,\n      .userId = -1, // -1 is guaranteed to be an invalid uid_t (see setreuid(2))\n      .sortKey = 0,\n      .delay = -1,\n      .useColors = true,\n      .treeView = false,\n   };\n\n   static struct option long_opts[] =\n   {\n      {\"help\",     no_argument,         0, 'h'},\n      {\"version\",  no_argument,         0, 'v'},\n      {\"delay\",    required_argument,   0, 'd'},\n      {\"sort-key\", required_argument,   0, 's'},\n      {\"user\",     required_argument,   0, 'u'},\n      {\"no-color\", no_argument,         0, 'C'},\n      {\"no-colour\",no_argument,         0, 'C'},\n      {\"tree\",     no_argument,         0, 't'},\n      {\"pid\",      required_argument,   0, 'p'},\n      {0,0,0,0}\n   };\n\n   int opt, opti=0;\n   /* Parse arguments */\n   while ((opt = getopt_long(argc, argv, \"hvCs:td:u:p:\", long_opts, &opti))) {\n      if (opt == EOF) break;\n      switch (opt) {\n         case 'h':\n            printHelpFlag();\n            break;\n         case 'v':\n            printVersionFlag();\n            break;\n         case 's':\n            if (strcmp(optarg, \"help\") == 0) {\n               for (int j = 1; j < Platform_numberOfFields; j++) {\n                  const char* name = Process_fields[j].name;\n                  if (name) printf (\"%s\\n\", name);\n               }\n               exit(0);\n            }\n            flags.sortKey = ColumnsPanel_fieldNameToIndex(optarg);\n            if (flags.sortKey == -1) {\n               fprintf(stderr, \"Error: invalid column \\\"%s\\\".\\n\", optarg);\n            }\n            break;\n         case 'd':\n            if (sscanf(optarg, \"%16d\", &(flags.delay)) == 1) {\n               if (flags.delay < 1) flags.delay = 1;\n               if (flags.delay > 100) flags.delay = 100;\n            } else {\n               fprintf(stderr, \"Error: invalid delay value \\\"%s\\\".\\n\", optarg);\n            }\n            break;\n         case 'u':\n            if (!Action_setUserOnly(optarg, &(flags.userId))) {\n               fprintf(stderr, \"Error: invalid user \\\"%s\\\".\\n\", optarg);\n            }\n            break;\n         case 'C':\n            flags.useColors = false;\n            break;\n         case 't':\n            flags.treeView = true;\n            break;\n         case 'p': {\n            char* argCopy = xStrdup(optarg);\n            char* saveptr;\n            char* pid = strtok_r(argCopy, \",\", &saveptr);\n\n            if(!flags.pidWhiteList) {\n               flags.pidWhiteList = Hashtable_new(8, false);\n            }\n\n            while(pid) {\n                unsigned int num_pid = atoi(pid);\n                Hashtable_put(flags.pidWhiteList, num_pid, (void *) 1);\n                pid = strtok_r(NULL, \",\", &saveptr);\n            }\n            free(argCopy);\n\n            break;\n         }\n         default:\n            exit(1);\n      }\n   }\n   return flags;\n}\n\nstatic void millisleep(unsigned long millisec) {\n   struct timespec req = {\n      .tv_sec = 0,\n      .tv_nsec = millisec * 1000000L\n   };\n   while(nanosleep(&req,&req)==-1) {\n      continue;\n   }\n}\n\nint main(int argc, char** argv) {\n\n   char *lc_ctype = getenv(\"LC_CTYPE\");\n   if(lc_ctype != NULL)\n      setlocale(LC_CTYPE, lc_ctype);\n   else if ((lc_ctype = getenv(\"LC_ALL\")))\n      setlocale(LC_CTYPE, lc_ctype);\n   else\n      setlocale(LC_CTYPE, \"\");\n\n   CommandLineSettings flags = parseArguments(argc, argv); // may exit()\n\n#ifdef HAVE_PROC\n   if (access(PROCDIR, R_OK) != 0) {\n      fprintf(stderr, \"Error: could not read procfs (compiled to look in %s).\\n\", PROCDIR);\n      exit(1);\n   }\n#endif\n   \n   Process_setupColumnWidths();\n   \n   UsersTable* ut = UsersTable_new();\n   ProcessList* pl = ProcessList_new(ut, flags.pidWhiteList, flags.userId);\n   \n   Settings* settings = Settings_new(pl->cpuCount);\n   pl->settings = settings;\n\n   Header* header = Header_new(pl, settings, 2);\n\n   Header_populateFromSettings(header);\n\n   if (flags.delay != -1)\n      settings->delay = flags.delay;\n   if (!flags.useColors) \n      settings->colorScheme = COLORSCHEME_MONOCHROME;\n   if (flags.treeView)\n      settings->treeView = true;\n\n   CRT_init(settings->delay, settings->colorScheme);\n   \n   MainPanel* panel = MainPanel_new();\n   ProcessList_setPanel(pl, (Panel*) panel);\n\n   MainPanel_updateTreeFunctions(panel, settings->treeView);\n      \n   if (flags.sortKey > 0) {\n      settings->sortKey = flags.sortKey;\n      settings->treeView = false;\n      settings->direction = 1;\n   }\n   ProcessList_printHeader(pl, Panel_getHeader((Panel*)panel));\n\n   State state = {\n      .settings = settings,\n      .ut = ut,\n      .pl = pl,\n      .panel = (Panel*) panel,\n      .header = header,\n   };\n   MainPanel_setState(panel, &state);\n   \n   ScreenManager* scr = ScreenManager_new(0, header->height, 0, -1, HORIZONTAL, header, settings, true);\n   ScreenManager_add(scr, (Panel*) panel, -1);\n\n   ProcessList_scan(pl);\n   millisleep(75);\n   ProcessList_scan(pl);\n\n   ScreenManager_run(scr, NULL, NULL);   \n   \n   attron(CRT_colors[RESET_COLOR]);\n   mvhline(LINES-1, 0, ' ', COLS);\n   attroff(CRT_colors[RESET_COLOR]);\n   refresh();\n   \n   CRT_done();\n   if (settings->changed)\n      Settings_write(settings);\n   Header_delete(header);\n   ProcessList_delete(pl);\n\n   ScreenManager_delete(scr);\n   \n   UsersTable_delete(ut);\n   Settings_delete(settings);\n   \n   if(flags.pidWhiteList) {\n      Hashtable_delete(flags.pidWhiteList);\n   }\n   return 0;\n}\n"
        },
        {
          "name": "htop.desktop",
          "type": "blob",
          "size": 2.423828125,
          "content": "[Desktop Entry]\nType=Application\nVersion=1.0\nName=Htop\nGenericName=Process Viewer\nGenericName[ca]=Visualitzador de processos\nGenericName[de]=Prozessanzeige\nGenericName[en_GB]=Process Viewer\nGenericName[es]=Visor de procesos\nGenericName[fi]=Prosessikatselin\nGenericName[fr]=Visualiseur de processus\nGenericName[gl]=Visor de procesos\nGenericName[it]=Visore dei processi\nGenericName[ko]= \nGenericName[nb]=Prosessviser\nGenericName[nl]=Viewer van processen\nGenericName[nn]=Prosessvisar\nGenericName[pl]=Przegldarka procesw\nGenericName[pt]=Visualizador de Processos\nGenericName[pt_BR]=Visualizador de processos\nGenericName[ru]= \nGenericName[sk]=Prehliada procesov\nGenericName[sl]=Pregledovalnik opravil\nGenericName[sr@ijekavian]= \nGenericName[sr@ijekavianlatin]=Prikaziva procesa\nGenericName[sr@latin]=Prikaziva procesa\nGenericName[sr]= \nGenericName[sv]=Processvisning\nGenericName[tr]=Sre Grntleyici\nGenericName[uk]= \nGenericName[zh_CN]=\nGenericName[zh_TW]=\nComment=Show System Processes\nComment[ca]=Visualitzeu els processos del sistema\nComment[de]=Systemprozesse anzeigen\nComment[en_GB]=Show System Processes\nComment[es]=Mostrar procesos del sistema\nComment[fi]=Katsele jrjestelmn prosesseja\nComment[fr]=Affiche les processus systme\nComment[gl]=Mostrar os procesos do sistema.\nComment[it]=Mostra processi di sistema\nComment[ko]=  \nComment[nb]=Vis systemprosesser\nComment[nl]=Systeemprocessen tonen\nComment[nn]=Vis systemprosessar\nComment[pl]=Poka procesy systemowe\nComment[pt]=Mostrar os Processos do Sistema\nComment[pt_BR]=Mostra os processos do sistema\nComment[ru]=    \nComment[sk]=Zobrazi systmov procesy\nComment[sl]=Prikaz sistemskih opravil\nComment[sr@ijekavian]=  \nComment[sr@ijekavianlatin]=Prikaz sistemskih procesa\nComment[sr@latin]=Prikaz sistemskih procesa\nComment[sr]=  \nComment[sv]=Visa systemprocesser\nComment[tr]=Sistem Srelerini Gster\nComment[uk]=  \nComment[zh_CN]=\nComment[zh_TW]=\nIcon=htop\nExec=htop\nTerminal=true\nCategories=System;Monitor;ConsoleOnly;\nKeywords=system;process;task\n"
        },
        {
          "name": "htop.h",
          "type": "blob",
          "size": 0.3408203125,
          "content": "/* Do not edit this file. It was automatically generated. */\n\n#ifndef HEADER_htop\n#define HEADER_htop\n/*\nhtop - htop.h\n(C) 2004-2011 Hisham H. Muhammad\nReleased under the GNU GPL, see the COPYING file\nin the source distribution for its full text.\n*/\n\n//#link m\n\n// ----------------------------------------\n\n\nint main(int argc, char** argv);\n\n#endif\n"
        },
        {
          "name": "htop.png",
          "type": "blob",
          "size": 3.5712890625,
          "content": null
        },
        {
          "name": "linux",
          "type": "tree",
          "content": null
        },
        {
          "name": "openbsd",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "solaris",
          "type": "tree",
          "content": null
        },
        {
          "name": "test_spec.lua",
          "type": "blob",
          "size": 17.478515625,
          "content": "#!/usr/bin/env lua\n\nlocal VISUALDELAY = os.getenv(\"VISUALDELAY\")\n \nlocal visual = VISUALDELAY or false\nlocal visual_delay = VISUALDELAY and (tonumber(VISUALDELAY)) or 0.1\nlocal short_delay = 0.3\nlocal long_delay = 1\n\nlocal unistd = require(\"posix.unistd\")\nlocal time = require(\"posix.time\")\nlocal curses = require(\"posix.curses\")\nlocal rote = require(\"rote\")\n\nlocal rt = rote.RoteTerm(24, 80)\n\n--[[\nlocal function os_execread(cmd)\n   local fd = io.popen(cmd, \"r\")\n   local out = fd:read(\"*a\")\n   fd:close()\n   return (out:gsub(\"\\n$\", \"\"))\nend\n]]\n--local branch = os_execread(\"git branch | grep '*'\"):sub(3)\n--print(\"Running in branch \"..branch)\n\nos.execute(\"make coverage\")\nos.execute(\"rm -f *.gcda */*.gcda\")\nos.execute(\"rm -f coverage.info test.htoprc\")\nos.execute(\"rm -rf lcov\")\nos.execute(\"killall htop\")\nos.execute(\"ps aux | grep '[s]leep 12345' | awk '{print $2}' | xargs kill 2> /dev/null\")\n\nos.execute(\"cp ./default.htoprc ./test.htoprc\")\nrt:forkPty(\"LC_ALL=C HTOPRC=./test.htoprc ./htop 2> htop-valgrind.txt\")\n\nlocal stdscr, term_win\n-- Curses initialization needed even when not in visual mode\n-- because luaposix only initializes KEY_* constants after initscr().\nstdscr = curses.initscr()\nif visual then\n   curses.echo(false)\n   curses.start_color()\n   curses.raw(true)\n   curses.halfdelay(1)\n   stdscr:keypad(true)\n   term_win = curses.newwin(24, 80, 0, 0)\n   local function makePair(foreground, background)\n      return background * 8 + 7 - foreground\n   end\n   -- initialize the color pairs the way rt:draw() expects it\n   for foreground = 0, 7 do\n      for background = 0, 7 do\n         if foreground ~= 7 or background ~= 0 then\n            local pair = makePair(foreground, background)\n            curses.init_pair(pair, foreground, background)\n         end\n      end\n   end\nelse\n   curses.endwin()\nend\n\nlocal function show(key)\n   rt:update()\n   if visual then\n      rt:draw(term_win, 0, 0)\n      if key then\n         term_win:mvaddstr(0, 0, tostring(key))\n      end\n      term_win:refresh()\n      \n      delay(visual_delay)\n   end\nend\n\nlocal function send(key, times, quick)\n   if times == 0 then return end\n   for _ = 1, times or 1 do\n      delay(0.003) -- 30ms delay to avoid clobbering Esc sequences\n      if type(key) == \"string\" then\n         for c in key:gmatch('.') do\n            rt:keyPress(string.byte(c))\n         end\n      else\n         rt:keyPress(key)\n      end\n      if not quick then\n         show(key)\n      end\n   end\n   if quick then\n      show(key)\n   end\nend\n\nlocal function string_at(x, y, len)\n   rt:update()\n   local out = {}\n   for i = 1, len do\n      out[#out+1] = rt:cellChar(y-1, x+i-2)\n   end\n   return table.concat(out)\nend\n\nlocal function is_string_at(x, y, str)\n   return string_at(x, y, #str) == str\nend\n\nlocal function check_string_at(x, y, str)\n   return { str, string_at(x, y, #str) }\nend\n\nlocal ESC = \"\\27\\27\"\n\nfunction delay(t)\n   time.nanosleep({ tv_sec = math.floor(t), tv_nsec = (t - math.floor(t)) * 1000000000 })\nend\n\ndelay(2) -- give some time for htop to initialize.\nrt:update()\n\nlocal y_panelhdr = (function()\n   for y = 1, 24 do\n      if is_string_at(3, y, \"PID\") then\n         return y\n      end\n   end\nend)() or 1\n\nassert.not_equal(y_panelhdr, 1)\n\nlocal x_metercol2 = 41\n\nshow()\n\nos.execute(\"sleep 12345 &\")\n\nlocal function terminated()\n   return not os.execute(\"ps aux | grep -q '\\\\./[h]top'\")\nend\n\nlocal function running_it(desc, fn)\n   it(desc, function()\n      assert(not terminated())\n      show()\n      fn()\n      assert(not terminated())\n   end)\nend\n\nlocal function check(t)\n   return t[1], t[2]\nend\n\nlocal attrs = {\n   black_on_cyan = 6,\n   red_on_cyan = 22,\n   white_on_black = 176,\n   yellow_on_black = 112,\n}\n\nlocal function find_selected_y(from)\n   rt:update()\n   for y = from or (y_panelhdr + 1), rt:rows() - 1 do\n      local attr = rt:cellAttr(y-1, 1)\n      if attr == attrs.black_on_cyan then\n         return y\n      end\n   end\n   return y_panelhdr + 1\nend\n\nlocal function find_command_x()\n   for x = 1, 80 do\n      if is_string_at(x, y_panelhdr, \"Command\") then\n         return x\n      end\n   end\n   return 64\nend\n\nlocal function set_display_option(n)\n   send(\"S\")\n   send(curses.KEY_DOWN)\n   send(curses.KEY_RIGHT)\n   send(curses.KEY_DOWN, n, \"quick\")\n   send(\"\\n\")\n   send(curses.KEY_F10)\nend\n\ndescribe(\"htop test suite\", function()\n   \n   running_it(\"performs incremental filter\", function()\n      send(\"\\\\\")\n      send(\"x\\127bux\\127sted\") -- test backspace\n      send(\"\\n\")\n      delay(short_delay)\n      rt:update()\n      local pid = (\"      \"..tostring(unistd.getpid())):sub(-5)\n      local ourpid = check_string_at(1, y_panelhdr + 1, pid)\n      send(\"\\\\\")\n      send(ESC)\n      send(curses.KEY_F5)\n      send(curses.KEY_HOME)\n      delay(short_delay)\n      rt:update()\n      local initpid = check_string_at(1, y_panelhdr + 1, \"    1\")\n      delay(short_delay)\n      rt:update()\n      send(curses.KEY_F5)\n      assert.equal(check(ourpid))\n      assert.equal(check(initpid))\n   end)\n\n   running_it(\"performs incremental search\", function()\n      send(curses.KEY_HOME)\n      send(\"/\")\n      send(\"busted\")\n      local attr = rt:cellAttr(rt:rows() - 1, 30)\n      delay(short_delay)\n      local line = find_selected_y()\n      local pid = (\"      \"..tostring(unistd.getpid())):sub(-5)\n      assert.equal(attr, attrs.black_on_cyan)\n      local ourpid = check_string_at(1, line, pid)\n      send(\"\\n\")\n      send(curses.KEY_HOME)\n      assert.equal(check(ourpid))\n   end)\n\n   running_it(\"performs pid search\", function()\n      send(curses.KEY_F5)\n      send(curses.KEY_END)\n      send(\"1\")\n      delay(short_delay)\n      local line = find_selected_y()\n      local initpid = check_string_at(1, line, \"    1\")\n      send(curses.KEY_F5)\n      assert.equal(check(initpid))\n   end)\n\n\n   running_it(\"horizontal scroll\", function()\n      local h_scroll = 20\n      send(curses.KEY_F5)\n      delay(short_delay)\n      local str1 = string_at(1+h_scroll, y_panelhdr+1, 5)\n      send(curses.KEY_RIGHT)\n      delay(short_delay)\n      local str2 = string_at(1, y_panelhdr+1, 5)\n      send(curses.KEY_LEFT)\n      delay(short_delay)\n      local str3 = string_at(1+h_scroll, y_panelhdr+1, 5)\n      send(curses.KEY_LEFT)\n      delay(short_delay)\n      local str4 = string_at(1+h_scroll, y_panelhdr+1, 5)\n      send(curses.KEY_F5)\n      assert.equal(str1, str2)\n      assert.equal(str2, str3)\n      assert.equal(str3, str4)\n   end)\n\n   running_it(\"kills a process\", function()\n      send(curses.KEY_HOME)\n      send(\"\\\\\")\n      send(\"sleep 12345\")\n      local attr = rt:cellAttr(rt:rows() - 1, 30)\n      assert.equal(attr, attrs.black_on_cyan)\n      send(\"\\n\")\n      delay(short_delay)\n      rt:update()\n      local col = find_command_x()\n      local procname = check_string_at(col, y_panelhdr + 1, \"sleep 12345\")\n      send(\"k\")\n      send(\"\\n\")\n      send(\"\\\\\")\n      send(ESC)\n      delay(short_delay)\n      assert.equal(check(procname))\n      assert.not_equal((os.execute(\"ps aux | grep -q '[s]leep 12345'\")), true)\n   end)\n\n   running_it(\"runs strace\", function()\n      send(curses.KEY_HOME)\n      send(\"/\")\n      send(\"busted\")\n      send(\"\\n\")\n      send(\"s\")\n      delay(long_delay)\n      send(ESC)\n   end)\n\n   running_it(\"runs lsof\", function()\n      send(curses.KEY_HOME)\n      send(\"/\")\n      send(\"busted\")\n      send(\"\\n\")\n      send(\"l\")\n      delay(long_delay)\n      send(ESC)\n   end)\n\n   running_it(\"performs filtering in lsof\", function()\n      send(curses.KEY_HOME)\n      send(\"/\")\n      send(\"htop\")\n      send(\"\\n\")\n      send(\"l\")\n      send(curses.KEY_F4)\n      send(\"pipe\")\n      delay(long_delay)\n      local pipefd = check_string_at(1, 3, \"    3\")\n      send(ESC)\n      assert.equal(check(pipefd))\n   end)\n\n   running_it(\"performs search in lsof\", function()\n      send(curses.KEY_HOME)\n      send(\"/\")\n      send(\"htop\")\n      send(\"\\n\")\n      send(\"l\")\n      send(curses.KEY_F3)\n      send(\"pipe\")\n      delay(long_delay)\n      local line = find_selected_y(3)\n      local pipefd = check_string_at(1, line, \"    3\")\n      send(ESC)\n      assert.equal(check(pipefd))\n   end)\n\n\n   running_it(\"cycles through meter modes in the default meters\", function()\n      send(\"S\")\n      for _ = 1, 2 do\n         send(curses.KEY_RIGHT)\n         for _ = 1, 3 do\n            send(\"\\n\", 4)\n            send(curses.KEY_DOWN)\n         end\n      end\n      send(ESC)\n   end)\n\n   running_it(\"show process of a user\", function()\n      send(curses.KEY_F5)\n      send(\"u\")\n      send(curses.KEY_DOWN)\n      delay(short_delay)\n      rt:update()\n      local chosen = string_at(1, y_panelhdr + 2, 9)\n      send(\"\\n\")\n      send(curses.KEY_HOME)\n      delay(short_delay)\n      rt:update()\n      local shown = string_at(7, y_panelhdr + 1, 9)\n      send(\"u\")\n      send(\"\\n\")\n      send(curses.KEY_HOME)\n      delay(short_delay)\n      rt:update()\n      local inituser = string_at(7, y_panelhdr + 1, 9)\n      send(curses.KEY_F5)\n      assert.equal(shown, chosen)\n      assert.equal(inituser, \"root     \")\n   end)\n\n   running_it(\"performs failing search\", function()\n      send(curses.KEY_HOME)\n      send(\"/\")\n      send(\"xxxxxxxxxx\")\n      delay(short_delay)\n      rt:update()\n      local attr = rt:cellAttr(rt:rows() - 1, 30)\n      assert.equal(attr, attrs.red_on_cyan)\n      send(\"\\n\")\n   end)\n\n   running_it(\"cycles through search\", function()\n      send(curses.KEY_HOME)\n      send(\"/\")\n      send(\"sh\")\n      local lastpid\n      local pidpairs = {}\n      for _ = 1, 3 do\n         send(curses.KEY_F3)\n         local line = find_selected_y()\n         local pid = string_at(1, line, 5)\n         if lastpid then\n            pidpairs[#pidpairs + 1] = { lastpid, pid }\n            lastpid = pid\n         end\n      end\n      send(curses.KEY_HOME)\n      for _, pair in pairs(pidpairs) do\n         assert.not_equal(pair[1], pair[2])\n      end\n   end)\n   \n   running_it(\"visits each setup screen\", function()\n      send(\"S\")\n      send(curses.KEY_DOWN, 3)\n      send(curses.KEY_F10)\n   end)\n   \n   running_it(\"adds and removes PPID column\", function()\n      send(\"S\")\n      send(curses.KEY_DOWN, 3)\n      send(curses.KEY_RIGHT, 2)\n      send(curses.KEY_DOWN, 2)\n      send(\"\\n\")\n      send(curses.KEY_F10)\n      delay(short_delay)\n      local ppid = check_string_at(2, y_panelhdr, \"PPID\")\n      send(\"S\")\n      send(curses.KEY_DOWN, 3)\n      send(curses.KEY_RIGHT, 1)\n      send(curses.KEY_DC)\n      send(curses.KEY_F10)\n      delay(short_delay)\n      local not_ppid = check_string_at(2, y_panelhdr, \"PPID\")\n      assert.equal(check(ppid))\n      assert.not_equal(check(not_ppid))\n   end)\n   \n   running_it(\"changes CPU affinity for a process\", function()\n      send(\"a\")\n      send(\" \\n\")\n      send(ESC)\n   end)\n\n   running_it(\"renices for a process\", function()\n      send(\"/\")\n      send(\"busted\")\n      send(\"\\n\")\n      local line = find_selected_y()\n      local before = check_string_at(22, line, \" 0\")\n      send(curses.KEY_F8)\n      delay(short_delay)\n      local after = check_string_at(22, line, \" 1\")\n      assert.equal(check(before))\n      assert.equal(check(after))\n   end)\n\n   running_it(\"tries to lower nice for a process\", function()\n      send(\"/\")\n      send(\"busted\")\n      send(\"\\n\")\n      local line = find_selected_y()\n      local before = string_at(22, line, 2)\n      send(curses.KEY_F7)\n      delay(short_delay)\n      local after = string_at(22, line, 2)\n      assert.equal(before, after) -- no permissions\n   end)\n\n   running_it(\"invert sort order\", function()\n      local cpu_col = 45\n      send(\"P\")\n      send(\"I\")\n      send(curses.KEY_HOME)\n      delay(short_delay)\n      local zerocpu = check_string_at(cpu_col, y_panelhdr + 1, \" 0.0\")\n      send(\"I\")\n      delay(short_delay)\n      local nonzerocpu = check_string_at(cpu_col, y_panelhdr + 1, \" 0.0\")\n      assert.equal(check(zerocpu))\n      assert.not_equal(check(nonzerocpu))\n   end)\n   \n   running_it(\"changes IO priority for a process\", function()\n      send(\"/\")\n      send(\"htop\")\n      send(\"\\n\")\n      send(\"i\")\n      send(curses.KEY_END)\n      send(\"\\n\")\n      send(ESC)\n   end)\n\n   running_it(\"shows help\", function()\n      send(curses.KEY_F1)\n      send(\"\\n\")\n      set_display_option(9)\n      send(curses.KEY_F1)\n      send(\"\\n\")\n      set_display_option(9)\n   end)\n\n   running_it(\"moves meters around\", function()\n      send(\"S\")\n      send(curses.KEY_RIGHT)\n      send(curses.KEY_UP)\n      send(\"\\n\")\n      send(curses.KEY_DOWN)\n      send(curses.KEY_UP)\n      send(curses.KEY_RIGHT)\n      send(curses.KEY_RIGHT)\n      send(curses.KEY_LEFT)\n      send(curses.KEY_LEFT)\n      send(\"\\n\")\n      send(curses.KEY_F10)\n   end)\n   \n   local meters = {\n      { name = \"clock\", down = 0, string = \"Time\" },\n      { name = \"load\", down = 2, string = \"Load\" },\n      { name = \"battery\", down = 7, string = \"Battery\" },\n      { name = \"hostname\", down = 8, string = \"Hostname\" },\n      { name = \"memory\", down = 3, string = \"Mem\" },\n      { name = \"CPU average\", down = 16, string = \"Avg\" },\n   }\n\n   running_it(\"checks various CPU meters\", function()\n      send(\"S\")\n      send(curses.KEY_RIGHT, 3)\n      send(curses.KEY_DOWN, 9, \"quick\")\n      for _ = 9, 14 do\n         send(\"\\n\")\n         send(\"\\n\")\n         send(curses.KEY_DC)\n         send(curses.KEY_RIGHT)\n         send(curses.KEY_DOWN)\n      end\n   end)\n\n   for _, item in ipairs(meters) do\n      running_it(\"adds and removes a \"..item.name..\" widget\", function()\n         send(\"S\")\n         send(curses.KEY_RIGHT, 3)\n         send(curses.KEY_DOWN, item.down)\n         send(\"\\n\")\n         send(curses.KEY_UP, 4)\n         send(\"\\n\")\n         send(curses.KEY_F4, 4) -- cycle through meter modes\n         delay(short_delay)\n         rt:update()\n         local with = check_string_at(x_metercol2, 2, item.string)\n         send(curses.KEY_DC)\n         delay(short_delay)\n         local without = check_string_at(x_metercol2, 2, item.string)\n         send(curses.KEY_F10)\n         assert.equal(check(with))\n         assert.not_equal(check(without))\n      end)\n   end\n\n   running_it(\"goes through themes\", function()\n      send(curses.KEY_F2)\n      send(curses.KEY_DOWN, 2)\n      send(curses.KEY_RIGHT)\n      for _ = 1, 6 do\n         send(\"\\n\")\n         send(curses.KEY_DOWN)\n      end\n      send(curses.KEY_UP, 6)\n      send(\"\\n\")\n      send(curses.KEY_F10)\n   end)\n   \n   local display_options = {\n      { name = \"tree view\", down = 0 },\n      { name = \"shadow other user's process\", down = 1 },\n      { name = \"hide kernel threads\", down = 2 },\n      { name = \"hide userland threads\", down = 3 },\n      { name = \"display threads in different color\", down = 4 },\n      { name = \"show custom thread names\", down = 5 },\n      { name = \"highlight basename\", down = 6 },\n      { name = \"highlight large numbers\", down = 7 },\n      { name = \"leave margin around header\", down = 8 },\n      { name = \"use detailed CPU time\", down = 9 },\n      { name = \"count from zero\", down = 10 },\n      { name = \"update process names\", down = 11 },\n      { name = \"guest time in CPU%\", down = 12 },\n   }\n   \n   for _, item in ipairs(display_options) do\n      running_it(\"checks display option to \"..item.name, function()\n         for _ = 1, 2 do\n            set_display_option(item.down)\n            delay(short_delay)\n         end\n      end)\n   end\n\n   running_it(\"shows detailed CPU with guest time\", function()\n      for _ = 1, 2 do\n         send(\"S\")\n         send(curses.KEY_DOWN)\n         send(curses.KEY_RIGHT)\n         send(curses.KEY_DOWN, 9)\n         send(\"\\n\")\n         send(curses.KEY_DOWN, 3)\n         send(\"\\n\")\n         send(curses.KEY_LEFT)\n         send(curses.KEY_UP)\n         send(curses.KEY_RIGHT)\n         send(curses.KEY_F4, 4) -- cycle through CPU meter modes\n         send(curses.KEY_F10)\n         delay(short_delay)\n      end\n   end)\n\n   running_it(\"expands and collapses tree\", function()\n      send(curses.KEY_F5) -- tree view\n      send(curses.KEY_HOME)\n      send(curses.KEY_DOWN) -- second process in the tree\n      send(\"-\")\n      send(\"+\")\n      send(curses.KEY_F5)\n   end)\n\n   running_it(\"sets sort key\", function()\n      send(\".\")\n      send(\"\\n\")\n   end)\n\n   running_it(\"tags all children\", function()\n      send(curses.KEY_F5) -- tree view\n      send(curses.KEY_HOME) -- ensure we're at init\n      send(\"c\")\n      local taggedattrs = {}\n      rt:update()\n      for y = y_panelhdr + 2, 23 do\n         table.insert(taggedattrs, rt:cellAttr(y-1, 4))\n      end\n      delay(short_delay)\n      send(\"U\")\n      local untaggedattrs = {}\n      rt:update()\n      for y = y_panelhdr + 2, 23 do\n         table.insert(untaggedattrs, rt:cellAttr(y-1, 4))\n      end\n      send(curses.KEY_F5)\n\n      for _, taggedattr in ipairs(taggedattrs) do\n         assert.equal(attrs.yellow_on_black, taggedattr)\n      end\n      for _, untaggedattr in ipairs(untaggedattrs) do\n         assert.equal(attrs.white_on_black, untaggedattr)\n      end\n   end)\n   \n   for i = 1, 62 do\n      running_it(\"show column \"..i, function()\n         send(\"S\")\n         send(curses.KEY_END)\n         send(curses.KEY_RIGHT, 1)\n         if i > 1 then\n            send(curses.KEY_DC)\n         end\n         send(curses.KEY_RIGHT, 1)\n         local down = i\n         while down > 13 do\n            send(curses.KEY_NPAGE)\n            down = down - 13\n         end\n         send(curses.KEY_DOWN, down, \"quick\")\n         send(\"\\n\")\n         send(curses.KEY_F10)\n         if i == 62 then\n            send(\"S\")\n            send(curses.KEY_END)\n            send(curses.KEY_RIGHT, 1)\n            if i > 1 then\n               send(curses.KEY_DC)\n            end\n            send(curses.KEY_F10)\n         end\n      end)\n   end\n   \n   it(\"finally quits\", function()\n      assert(not terminated())\n      send(\"q\")\n      while not terminated() do\n         unistd.sleep(1)\n         send(\"q\")\n      end\n      assert(terminated())\n      if visual then\n         curses.endwin()\n      end\n      os.execute(\"make lcov && xdg-open lcov/index.html\")\n   end)\nend)\n\n"
        },
        {
          "name": "unsupported",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}