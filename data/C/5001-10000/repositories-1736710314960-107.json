{
  "metadata": {
    "timestamp": 1736710314960,
    "page": 107,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "vysheng/tg",
      "stars": 6562,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2587890625,
          "content": "telegram\n*.o\nMakefile\naclocal.m4\nautom4te.cache\nconfig.h\nconfig.log\nconfig.status\n.idea/\nnbproject/\nbin/\nobjs/\ndep/\nauto/\nlibs/\ndebian/telegram-cli.[a-z]\ndebian/files\ndebian/telegram-cli/*\ndebian/telegram-cli.debhelper.log\ndebian/telegram-cli.substvars\n__pycache__\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.0703125,
          "content": "[submodule \"tgl\"]\n\tpath = tgl\n\turl = https://github.com/vysheng/tgl.git\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.4208984375,
          "content": "language: c\n\ncompiler:\n  - gcc\n  - clang\n\ninstall:\n - sudo apt-get update\n - sudo apt-get install libconfig8-dev\n - sudo apt-get install libreadline6-dev\n - sudo apt-get install libssl-dev\n - sudo apt-get install liblua5.2-dev lua5.2\n - sudo apt-get install python-dev python\n - sudo apt-get install libevent-dev\n - sudo apt-get install libjansson-dev\n\nscript:\n  - git submodule update --init --recursive\n  - ./configure\n  - make\n\n"
        },
        {
          "name": "CHANGELOG",
          "type": "blob",
          "size": 1.0625,
          "content": "1.3.3\n* support for sending custom keyboard \n* fixed contact_search\n* TGL-2.0.3\n1.3.2\n* use TGL-2.0.2\n* add block/unblock user methods\n* support for autocomplete for bot's commands\n1.3.1\n* added error codes\n1.3.0\n* layer 28 support (passwords, replies, webpages, other changes)\n* output in json format\n* support for lua functions in CLI mode (register_interface_function)\n* bugfixes\n* output error codes to socket\n* allow [reply=<num>], [disable_preview] and [enable_preview] prefixes to query\n1.2.1\n* fixed registration/login problem\n* added extension to downloads\n1.2.0\n* layer 22 support\n* new authorization code\n* fixed time-related problems\n* fixed crash after hibernation\n1.0.6\n* layer 18 support\n1.0.5\n* listening socket (tcp and unix) for commands\n1.0.4\n* changed create_group_chat format\n* changed search query\n* rewritten interface code. Support for escaped characters in quotes\n1.0.3\n* options to help to run telegram-cli as daemon\n1.0.2\n* Bug fixes\n1.0.1\n* Added pfs support. To use it you should add 'pfs_enabled=true' line to config.\n* Added export_card/import_card methods\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "LICENSE.h",
          "type": "blob",
          "size": 19.0078125,
          "content": "\"                    GNU GENERAL PUBLIC LICENSE\\n\"\n\"                       Version 2, June 1991\\n\"\n\"\\n\"\n\" Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\\n\"\n\" 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\"\n\" Everyone is permitted to copy and distribute verbatim copies\\n\"\n\" of this license document, but changing it is not allowed.\\n\"\n\"\\n\"\n\"                            Preamble\\n\"\n\"\\n\"\n\"  The licenses for most software are designed to take away your\\n\"\n\"freedom to share and change it.  By contrast, the GNU General Public\\n\"\n\"License is intended to guarantee your freedom to share and change free\\n\"\n\"software--to make sure the software is free for all its users.  This\\n\"\n\"General Public License applies to most of the Free Software\\n\"\n\"Foundation's software and to any other program whose authors commit to\\n\"\n\"using it.  (Some other Free Software Foundation software is covered by\\n\"\n\"the GNU Lesser General Public License instead.)  You can apply it to\\n\"\n\"your programs, too.\\n\"\n\"\\n\"\n\"  When we speak of free software, we are referring to freedom, not\\n\"\n\"price.  Our General Public Licenses are designed to make sure that you\\n\"\n\"have the freedom to distribute copies of free software (and charge for\\n\"\n\"this service if you wish), that you receive source code or can get it\\n\"\n\"if you want it, that you can change the software or use pieces of it\\n\"\n\"in new free programs; and that you know you can do these things.\\n\"\n\"\\n\"\n\"  To protect your rights, we need to make restrictions that forbid\\n\"\n\"anyone to deny you these rights or to ask you to surrender the rights.\\n\"\n\"These restrictions translate to certain responsibilities for you if you\\n\"\n\"distribute copies of the software, or if you modify it.\\n\"\n\"\\n\"\n\"  For example, if you distribute copies of such a program, whether\\n\"\n\"gratis or for a fee, you must give the recipients all the rights that\\n\"\n\"you have.  You must make sure that they, too, receive or can get the\\n\"\n\"source code.  And you must show them these terms so they know their\\n\"\n\"rights.\\n\"\n\"\\n\"\n\"  We protect your rights with two steps: (1) copyright the software, and\\n\"\n\"(2) offer you this license which gives you legal permission to copy,\\n\"\n\"distribute and/or modify the software.\\n\"\n\"\\n\"\n\"  Also, for each author's protection and ours, we want to make certain\\n\"\n\"that everyone understands that there is no warranty for this free\\n\"\n\"software.  If the software is modified by someone else and passed on, we\\n\"\n\"want its recipients to know that what they have is not the original, so\\n\"\n\"that any problems introduced by others will not reflect on the original\\n\"\n\"authors' reputations.\\n\"\n\"\\n\"\n\"  Finally, any free program is threatened constantly by software\\n\"\n\"patents.  We wish to avoid the danger that redistributors of a free\\n\"\n\"program will individually obtain patent licenses, in effect making the\\n\"\n\"program proprietary.  To prevent this, we have made it clear that any\\n\"\n\"patent must be licensed for everyone's free use or not licensed at all.\\n\"\n\"\\n\"\n\"  The precise terms and conditions for copying, distribution and\\n\"\n\"modification follow.\\n\"\n\"\\n\"\n\"                    GNU GENERAL PUBLIC LICENSE\\n\"\n\"   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\\n\"\n\"\\n\"\n\"  0. This License applies to any program or other work which contains\\n\"\n\"a notice placed by the copyright holder saying it may be distributed\\n\"\n\"under the terms of this General Public License.  The \\\"Program\\\", below,\\n\"\n\"refers to any such program or work, and a \\\"work based on the Program\\\"\\n\"\n\"means either the Program or any derivative work under copyright law:\\n\"\n\"that is to say, a work containing the Program or a portion of it,\\n\"\n\"either verbatim or with modifications and/or translated into another\\n\"\n\"language.  (Hereinafter, translation is included without limitation in\\n\"\n\"the term \\\"modification\\\".)  Each licensee is addressed as \\\"you\\\".\\n\"\n\"\\n\"\n\"Activities other than copying, distribution and modification are not\\n\"\n\"covered by this License; they are outside its scope.  The act of\\n\"\n\"running the Program is not restricted, and the output from the Program\\n\"\n\"is covered only if its contents constitute a work based on the\\n\"\n\"Program (independent of having been made by running the Program).\\n\"\n\"Whether that is true depends on what the Program does.\\n\"\n\"\\n\"\n\"  1. You may copy and distribute verbatim copies of the Program's\\n\"\n\"source code as you receive it, in any medium, provided that you\\n\"\n\"conspicuously and appropriately publish on each copy an appropriate\\n\"\n\"copyright notice and disclaimer of warranty; keep intact all the\\n\"\n\"notices that refer to this License and to the absence of any warranty;\\n\"\n\"and give any other recipients of the Program a copy of this License\\n\"\n\"along with the Program.\\n\"\n\"\\n\"\n\"You may charge a fee for the physical act of transferring a copy, and\\n\"\n\"you may at your option offer warranty protection in exchange for a fee.\\n\"\n\"\\n\"\n\"  2. You may modify your copy or copies of the Program or any portion\\n\"\n\"of it, thus forming a work based on the Program, and copy and\\n\"\n\"distribute such modifications or work under the terms of Section 1\\n\"\n\"above, provided that you also meet all of these conditions:\\n\"\n\"\\n\"\n\"    a) You must cause the modified files to carry prominent notices\\n\"\n\"    stating that you changed the files and the date of any change.\\n\"\n\"\\n\"\n\"    b) You must cause any work that you distribute or publish, that in\\n\"\n\"    whole or in part contains or is derived from the Program or any\\n\"\n\"    part thereof, to be licensed as a whole at no charge to all third\\n\"\n\"    parties under the terms of this License.\\n\"\n\"\\n\"\n\"    c) If the modified program normally reads commands interactively\\n\"\n\"    when run, you must cause it, when started running for such\\n\"\n\"    interactive use in the most ordinary way, to print or display an\\n\"\n\"    announcement including an appropriate copyright notice and a\\n\"\n\"    notice that there is no warranty (or else, saying that you provide\\n\"\n\"    a warranty) and that users may redistribute the program under\\n\"\n\"    these conditions, and telling the user how to view a copy of this\\n\"\n\"    License.  (Exception: if the Program itself is interactive but\\n\"\n\"    does not normally print such an announcement, your work based on\\n\"\n\"    the Program is not required to print an announcement.)\\n\"\n\"\\n\"\n\"These requirements apply to the modified work as a whole.  If\\n\"\n\"identifiable sections of that work are not derived from the Program,\\n\"\n\"and can be reasonably considered independent and separate works in\\n\"\n\"themselves, then this License, and its terms, do not apply to those\\n\"\n\"sections when you distribute them as separate works.  But when you\\n\"\n\"distribute the same sections as part of a whole which is a work based\\n\"\n\"on the Program, the distribution of the whole must be on the terms of\\n\"\n\"this License, whose permissions for other licensees extend to the\\n\"\n\"entire whole, and thus to each and every part regardless of who wrote it.\\n\"\n\"\\n\"\n\"Thus, it is not the intent of this section to claim rights or contest\\n\"\n\"your rights to work written entirely by you; rather, the intent is to\\n\"\n\"exercise the right to control the distribution of derivative or\\n\"\n\"collective works based on the Program.\\n\"\n\"\\n\"\n\"In addition, mere aggregation of another work not based on the Program\\n\"\n\"with the Program (or with a work based on the Program) on a volume of\\n\"\n\"a storage or distribution medium does not bring the other work under\\n\"\n\"the scope of this License.\\n\"\n\"\\n\"\n\"  3. You may copy and distribute the Program (or a work based on it,\\n\"\n\"under Section 2) in object code or executable form under the terms of\\n\"\n\"Sections 1 and 2 above provided that you also do one of the following:\\n\"\n\"\\n\"\n\"    a) Accompany it with the complete corresponding machine-readable\\n\"\n\"    source code, which must be distributed under the terms of Sections\\n\"\n\"    1 and 2 above on a medium customarily used for software interchange; or,\\n\"\n\"\\n\"\n\"    b) Accompany it with a written offer, valid for at least three\\n\"\n\"    years, to give any third party, for a charge no more than your\\n\"\n\"    cost of physically performing source distribution, a complete\\n\"\n\"    machine-readable copy of the corresponding source code, to be\\n\"\n\"    distributed under the terms of Sections 1 and 2 above on a medium\\n\"\n\"    customarily used for software interchange; or,\\n\"\n\"\\n\"\n\"    c) Accompany it with the information you received as to the offer\\n\"\n\"    to distribute corresponding source code.  (This alternative is\\n\"\n\"    allowed only for noncommercial distribution and only if you\\n\"\n\"    received the program in object code or executable form with such\\n\"\n\"    an offer, in accord with Subsection b above.)\\n\"\n\"\\n\"\n\"The source code for a work means the preferred form of the work for\\n\"\n\"making modifications to it.  For an executable work, complete source\\n\"\n\"code means all the source code for all modules it contains, plus any\\n\"\n\"associated interface definition files, plus the scripts used to\\n\"\n\"control compilation and installation of the executable.  However, as a\\n\"\n\"special exception, the source code distributed need not include\\n\"\n\"anything that is normally distributed (in either source or binary\\n\"\n\"form) with the major components (compiler, kernel, and so on) of the\\n\"\n\"operating system on which the executable runs, unless that component\\n\"\n\"itself accompanies the executable.\\n\"\n\"\\n\"\n\"If distribution of executable or object code is made by offering\\n\"\n\"access to copy from a designated place, then offering equivalent\\n\"\n\"access to copy the source code from the same place counts as\\n\"\n\"distribution of the source code, even though third parties are not\\n\"\n\"compelled to copy the source along with the object code.\\n\"\n\"\\n\"\n\"  4. You may not copy, modify, sublicense, or distribute the Program\\n\"\n\"except as expressly provided under this License.  Any attempt\\n\"\n\"otherwise to copy, modify, sublicense or distribute the Program is\\n\"\n\"void, and will automatically terminate your rights under this License.\\n\"\n\"However, parties who have received copies, or rights, from you under\\n\"\n\"this License will not have their licenses terminated so long as such\\n\"\n\"parties remain in full compliance.\\n\"\n\"\\n\"\n\"  5. You are not required to accept this License, since you have not\\n\"\n\"signed it.  However, nothing else grants you permission to modify or\\n\"\n\"distribute the Program or its derivative works.  These actions are\\n\"\n\"prohibited by law if you do not accept this License.  Therefore, by\\n\"\n\"modifying or distributing the Program (or any work based on the\\n\"\n\"Program), you indicate your acceptance of this License to do so, and\\n\"\n\"all its terms and conditions for copying, distributing or modifying\\n\"\n\"the Program or works based on it.\\n\"\n\"\\n\"\n\"  6. Each time you redistribute the Program (or any work based on the\\n\"\n\"Program), the recipient automatically receives a license from the\\n\"\n\"original licensor to copy, distribute or modify the Program subject to\\n\"\n\"these terms and conditions.  You may not impose any further\\n\"\n\"restrictions on the recipients' exercise of the rights granted herein.\\n\"\n\"You are not responsible for enforcing compliance by third parties to\\n\"\n\"this License.\\n\"\n\"\\n\"\n\"  7. If, as a consequence of a court judgment or allegation of patent\\n\"\n\"infringement or for any other reason (not limited to patent issues),\\n\"\n\"conditions are imposed on you (whether by court order, agreement or\\n\"\n\"otherwise) that contradict the conditions of this License, they do not\\n\"\n\"excuse you from the conditions of this License.  If you cannot\\n\"\n\"distribute so as to satisfy simultaneously your obligations under this\\n\"\n\"License and any other pertinent obligations, then as a consequence you\\n\"\n\"may not distribute the Program at all.  For example, if a patent\\n\"\n\"license would not permit royalty-free redistribution of the Program by\\n\"\n\"all those who receive copies directly or indirectly through you, then\\n\"\n\"the only way you could satisfy both it and this License would be to\\n\"\n\"refrain entirely from distribution of the Program.\\n\"\n\"\\n\"\n\"If any portion of this section is held invalid or unenforceable under\\n\"\n\"any particular circumstance, the balance of the section is intended to\\n\"\n\"apply and the section as a whole is intended to apply in other\\n\"\n\"circumstances.\\n\"\n\"\\n\"\n\"It is not the purpose of this section to induce you to infringe any\\n\"\n\"patents or other property right claims or to contest validity of any\\n\"\n\"such claims; this section has the sole purpose of protecting the\\n\"\n\"integrity of the free software distribution system, which is\\n\"\n\"implemented by public license practices.  Many people have made\\n\"\n\"generous contributions to the wide range of software distributed\\n\"\n\"through that system in reliance on consistent application of that\\n\"\n\"system; it is up to the author/donor to decide if he or she is willing\\n\"\n\"to distribute software through any other system and a licensee cannot\\n\"\n\"impose that choice.\\n\"\n\"\\n\"\n\"This section is intended to make thoroughly clear what is believed to\\n\"\n\"be a consequence of the rest of this License.\\n\"\n\"\\n\"\n\"  8. If the distribution and/or use of the Program is restricted in\\n\"\n\"certain countries either by patents or by copyrighted interfaces, the\\n\"\n\"original copyright holder who places the Program under this License\\n\"\n\"may add an explicit geographical distribution limitation excluding\\n\"\n\"those countries, so that distribution is permitted only in or among\\n\"\n\"countries not thus excluded.  In such case, this License incorporates\\n\"\n\"the limitation as if written in the body of this License.\\n\"\n\"\\n\"\n\"  9. The Free Software Foundation may publish revised and/or new versions\\n\"\n\"of the General Public License from time to time.  Such new versions will\\n\"\n\"be similar in spirit to the present version, but may differ in detail to\\n\"\n\"address new problems or concerns.\\n\"\n\"\\n\"\n\"Each version is given a distinguishing version number.  If the Program\\n\"\n\"specifies a version number of this License which applies to it and \\\"any\\n\"\n\"later version\\\", you have the option of following the terms and conditions\\n\"\n\"either of that version or of any later version published by the Free\\n\"\n\"Software Foundation.  If the Program does not specify a version number of\\n\"\n\"this License, you may choose any version ever published by the Free Software\\n\"\n\"Foundation.\\n\"\n\"\\n\"\n\"  10. If you wish to incorporate parts of the Program into other free\\n\"\n\"programs whose distribution conditions are different, write to the author\\n\"\n\"to ask for permission.  For software which is copyrighted by the Free\\n\"\n\"Software Foundation, write to the Free Software Foundation; we sometimes\\n\"\n\"make exceptions for this.  Our decision will be guided by the two goals\\n\"\n\"of preserving the free status of all derivatives of our free software and\\n\"\n\"of promoting the sharing and reuse of software generally.\\n\"\n\"\\n\"\n\"                            NO WARRANTY\\n\"\n\"\\n\"\n\"  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\\n\"\n\"FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\\n\"\n\"OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\\n\"\n\"PROVIDE THE PROGRAM \\\"AS IS\\\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\\n\"\n\"OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\\n\"\n\"MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\\n\"\n\"TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\\n\"\n\"PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\\n\"\n\"REPAIR OR CORRECTION.\\n\"\n\"\\n\"\n\"  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\\n\"\n\"WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\\n\"\n\"REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\\n\"\n\"INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\\n\"\n\"OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\\n\"\n\"TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\\n\"\n\"YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\\n\"\n\"PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\\n\"\n\"POSSIBILITY OF SUCH DAMAGES.\\n\"\n\"\\n\"\n\"                     END OF TERMS AND CONDITIONS\\n\"\n\"\\n\"\n\"            How to Apply These Terms to Your New Programs\\n\"\n\"\\n\"\n\"  If you develop a new program, and you want it to be of the greatest\\n\"\n\"possible use to the public, the best way to achieve this is to make it\\n\"\n\"free software which everyone can redistribute and change under these terms.\\n\"\n\"\\n\"\n\"  To do so, attach the following notices to the program.  It is safest\\n\"\n\"to attach them to the start of each source file to most effectively\\n\"\n\"convey the exclusion of warranty; and each file should have at least\\n\"\n\"the \\\"copyright\\\" line and a pointer to where the full notice is found.\\n\"\n\"\\n\"\n\"    <one line to give the program's name and a brief idea of what it does.>\\n\"\n\"    Copyright (C) <year>  <name of author>\\n\"\n\"\\n\"\n\"    This program is free software; you can redistribute it and/or modify\\n\"\n\"    it under the terms of the GNU General Public License as published by\\n\"\n\"    the Free Software Foundation; either version 2 of the License, or\\n\"\n\"    (at your option) any later version.\\n\"\n\"\\n\"\n\"    This program is distributed in the hope that it will be useful,\\n\"\n\"    but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\"    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\"    GNU General Public License for more details.\\n\"\n\"\\n\"\n\"    You should have received a copy of the GNU General Public License along\\n\"\n\"    with this program; if not, write to the Free Software Foundation, Inc.,\\n\"\n\"    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\\n\"\n\"\\n\"\n\"Also add information on how to contact you by electronic and paper mail.\\n\"\n\"\\n\"\n\"If the program is interactive, make it output a short notice like this\\n\"\n\"when it starts in an interactive mode:\\n\"\n\"\\n\"\n\"    Gnomovision version 69, Copyright (C) year name of author\\n\"\n\"    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\\n\"\n\"    This is free software, and you are welcome to redistribute it\\n\"\n\"    under certain conditions; type `show c' for details.\\n\"\n\"\\n\"\n\"The hypothetical commands `show w' and `show c' should show the appropriate\\n\"\n\"parts of the General Public License.  Of course, the commands you use may\\n\"\n\"be called something other than `show w' and `show c'; they could even be\\n\"\n\"mouse-clicks or menu items--whatever suits your program.\\n\"\n\"\\n\"\n\"You should also get your employer (if you work as a programmer) or your\\n\"\n\"school, if any, to sign a \\\"copyright disclaimer\\\" for the program, if\\n\"\n\"necessary.  Here is a sample; alter the names:\\n\"\n\"\\n\"\n\"  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\\n\"\n\"  `Gnomovision' (which makes passes at compilers) written by James Hacker.\\n\"\n\"\\n\"\n\"  <signature of Ty Coon>, 1 April 1989\\n\"\n\"  Ty Coon, President of Vice\\n\"\n\"\\n\"\n\"This General Public License does not permit incorporating your program into\\n\"\n\"proprietary programs.  If your program is a subroutine library, you may\\n\"\n\"consider it more useful to permit linking proprietary applications with the\\n\"\n\"library.  If this is what you want to do, use the GNU Lesser General\\n\"\n\"Public License instead of this License.\\n\"\n"
        },
        {
          "name": "Makefile.in",
          "type": "blob",
          "size": 2.0048828125,
          "content": "srcdir=@srcdir@\n\nCFLAGS=@CFLAGS@\nLDFLAGS=@LDFLAGS@ @OPENSSL_LDFLAGS@\nCPPFLAGS=@CPPFLAGS@ @OPENSSL_INCLUDES@\nDEFS=@DEFS@\nCOMPILE_FLAGS=${CFLAGS} ${CPFLAGS} ${CPPFLAGS} ${DEFS} -Wall -Werror -Wextra -Wno-missing-field-initializers -Wno-deprecated-declarations -fno-strict-aliasing -fno-omit-frame-pointer -ggdb -Wno-unused-parameter -fPIC\nEXTRA_LIBS=@LIBS@ @EXTRA_LIBS@ @OPENSSL_LIBS@\nLOCAL_LDFLAGS=-rdynamic -ggdb -levent ${EXTRA_LIBS} -ldl -lpthread -lutil\nLINK_FLAGS=${LDFLAGS} ${LOCAL_LDFLAGS}\n\nDEP=dep\nAUTO=auto\nEXE=bin\nOBJ=objs\nLIB=libs\nDIR_LIST=${DEP} ${AUTO} ${EXE} ${OBJ} ${LIB} ${DEP}/auto ${OBJ}/auto ${OBJ}/crypto ${DEP}/crypto\n\nEXE_LIST=${EXE}/telegram-cli\n\nTG_OBJECTS=${OBJ}/main.o ${OBJ}/loop.o ${OBJ}/interface.o ${OBJ}/lua-tg.o ${OBJ}/json-tg.o ${OBJ}/python-tg.o ${OBJ}/python-types.o\n\nINCLUDE=-I. -I${srcdir} -I${srcdir}/tgl\nCC=@CC@\n\n.SUFFIXES:\n\n.SUFFIXES: .c .h .o\n\nall: ${EXE_LIST} ${DIR_LIST}\ncreate_dirs_and_headers: ${DIR_LIST} ${AUTO}/auto-skip.h ${AUTO}/auto-fetch.h ${AUTO}/auto-store.h ${AUTO}/auto-autocomplete.h ${AUTO}/auto-types.h ${AUTO}/constants.h ${AUTO}/constants.h ${AUTO}/auto-skip.h ${AUTO}/auto-fetch.h ${AUTO}/auto-store.h ${AUTO}/auto-autocomplete.h ${AUTO}/auto-types.h ${AUTO}/auto-fetch-ds.h ${AUTO}/auto-free-ds.h ${AUTO}/auto-store-ds.h ${AUTO}/auto-print-ds.h\ncreate_dirs: ${DIR_LIST}\ndump-tl: ${EXE}/dump-tl-file\n\ninclude ${srcdir}/Makefile.tl-parser\ninclude ${srcdir}/Makefile.tgl\n\n${DIR_LIST}:\n\t@test -d $@ || mkdir -p $@\n\nOBJ_LIST=${TG_OBJECTS} ${TGL_OBJECTS} ${TGL_COMMON_OBJECTS} ${GENERATE_OBJECTS} ${TL_PARSER_OBJECTS} ${TGL_OBJECTS_AUTO}\nDEPENDENCE=$(subst ${OBJ}/,${DEP}/,$(patsubst %.o,%.d,${OBJ_LIST}))\nDEPENDENCE_LIST=${DEPENDENCE}\n\n-include ${DEPENDENCE_LIST}\n\n${TG_OBJECTS}: ${OBJ}/%.o: ${srcdir}/%.c | create_dirs_and_headers\n\t${CC} ${INCLUDE} ${COMPILE_FLAGS} -c -MP -MD -MF ${DEP}/$*.d -MQ ${OBJ}/$*.o -o $@ $<\n\n${EXE}/telegram-cli: ${TG_OBJECTS} ${LIB}/libtgl.a\n\t${CC} $^ ${LINK_FLAGS} -o $@\n\nclean:\n\trm -rf ${DIR_LIST}\n\ndistclean:\n\trm -rf ${DIR_LIST} config.h config.log config.status\n\n"
        },
        {
          "name": "Makefile.tgl",
          "type": "blob",
          "size": 3.08203125,
          "content": "TGL_OBJECTS=${OBJ}/mtproto-common.o ${OBJ}/mtproto-client.o ${OBJ}/mtproto-key.o ${OBJ}/queries.o ${OBJ}/structures.o ${OBJ}/binlog.o ${OBJ}/tgl.o ${OBJ}/updates.o ${OBJ}/tgl-net.o ${OBJ}/tgl-timers.o ${OBJ}/tg-mime-types.o ${OBJ}/mtproto-utils.o  ${OBJ}/crypto/bn_openssl.o ${OBJ}/crypto/bn_altern.o ${OBJ}/crypto/rsa_pem_openssl.o ${OBJ}/crypto/rsa_pem_altern.o ${OBJ}/crypto/md5_openssl.o ${OBJ}/crypto/md5_altern.o ${OBJ}/crypto/sha_openssl.o ${OBJ}/crypto/sha_altern.o ${OBJ}/crypto/aes_openssl.o ${OBJ}/crypto/aes_altern.o \n\nTGL_OBJECTS_AUTO=${OBJ}/auto/auto-skip.o ${OBJ}/auto/auto-fetch.o ${OBJ}/auto/auto-store.o ${OBJ}/auto/auto-autocomplete.o ${OBJ}/auto/auto-types.o ${OBJ}/auto/auto-fetch-ds.o  ${OBJ}/auto/auto-free-ds.o ${OBJ}/auto/auto-store-ds.o ${OBJ}/auto/auto-print-ds.o\n\n\nTLD_OBJECTS=${OBJ}/dump-tl-file.o\nGENERATE_OBJECTS=${OBJ}/generate.o\nTGL_COMMON_OBJECTS=${OBJ}/tools.o ${OBJ}/crypto/rand_openssl.o ${OBJ}/crypto/rand_altern.o ${OBJ}/crypto/err_openssl.o ${OBJ}/crypto/err_altern.o\nTGL_OBJ_C=${GENERATE_OBJECTS} ${TGL_COMMON_OBJECTS} ${TGL_OBJECTS} ${TLD_OBJECTS}\n\n.SUFFIXES:\n\n.SUFFIXES: .c .h .o\n\ndump-tl: ${EXE}/dump-tl-file\n\n${TGL_OBJECTS}: ${AUTO}/constants.h ${AUTO}/auto-skip.h ${AUTO}/auto-fetch.h ${AUTO}/auto-store.h ${AUTO}/auto-autocomplete.h ${AUTO}/auto-types.h ${AUTO}/auto-fetch-ds.h ${AUTO}/auto-free-ds.h ${AUTO}/auto-store-ds.h ${AUTO}/auto-print-ds.h\n\n${TGL_OBJ_C}: ${OBJ}/%.o: ${srcdir}/tgl/%.c | create_dirs\n\t${CC} ${INCLUDE} ${COMPILE_FLAGS} -iquote ${srcdir}/tgl -c -MP -MD -MF ${DEP}/$*.d -MQ ${OBJ}/$*.o -o $@ $<\n\n${TGL_OBJECTS_AUTO}: ${OBJ}/auto/%.o: ${AUTO}/%.c | create_dirs\n\t${CC} ${INCLUDE} ${COMPILE_FLAGS} -iquote ${srcdir}/tgl -c -MP -MD -MF ${DEP}/$*.d -MQ ${OBJ}/$*.o -o $@ $<\n\n#${OBJ}/auto/auto.o: ${AUTO}/auto.c\n#\t${CC} ${INCLUDE} ${COMPILE_FLAGS} -iquote ${srcdir}/tgl -c -MP -MD -MF ${DEP}/auto/auto.d -MQ ${OBJ}/auto/auto.o -o $@ $<\n\n${LIB}/libtgl.a: ${TGL_OBJECTS} ${TGL_COMMON_OBJECTS} ${TGL_OBJECTS_AUTO}\n\trm -f $@ && ar ruv $@ $^\n\n${EXE}/generate: ${GENERATE_OBJECTS} ${TGL_COMMON_OBJECTS}\n\t${CC} ${GENERATE_OBJECTS} ${TGL_COMMON_OBJECTS} ${LINK_FLAGS} -o $@\n\n${AUTO}/scheme.tlo: ${AUTO}/scheme.tl ${EXE}/tl-parser\n\t${EXE}/tl-parser -e $@ ${AUTO}/scheme.tl\n\n${AUTO}/scheme.tl: ${srcdir}/tgl/scheme.tl ${srcdir}/tgl/encrypted_scheme.tl ${srcdir}/tgl/binlog.tl ${srcdir}/tgl/append.tl ${srcdir}/tgl/mtproto.tl | ${AUTO}\n\tcat $^ > $@\n\n${AUTO}/scheme2.tl: ${AUTO}/scheme.tl ${EXE}/tl-parser\n\t${EXE}/tl-parser -E ${AUTO}/scheme.tl 2> $@  || ( cat $@ && rm $@ && false )\n\n${AUTO}/auto-%.c: ${AUTO}/scheme.tlo ${EXE}/generate auto/constants.h ${AUTO}/auto-%.h | create_dirs_and_headers\n\t${EXE}/generate -g $(patsubst ${AUTO}/auto-%.c,%,$@) ${AUTO}/scheme.tlo > $@ || ( rm $@ && false )\n\n${AUTO}/auto-%.h: ${AUTO}/scheme.tlo ${EXE}/generate\n\t${EXE}/generate -g $(patsubst ${AUTO}/auto-%.h,%-header,$@) ${AUTO}/scheme.tlo > $@  || ( rm $@ && false )\n\n${AUTO}/constants.h: ${AUTO}/scheme2.tl ${srcdir}/tgl/gen_constants_h.awk\n\tawk -f ${srcdir}/tgl/gen_constants_h.awk < $< > $@\n\n${EXE}/dump-tl-file: ${OBJ}/auto/auto.o ${TLD_OBJECTS}\n\t${CC} ${OBJ}/auto/auto.o ${TLD_OBJECTS} ${LINK_FLAGS} -o $@\n\n"
        },
        {
          "name": "Makefile.tl-parser",
          "type": "blob",
          "size": 0.30859375,
          "content": "TL_PARSER_OBJECTS=${OBJ}/tl-parser.o ${OBJ}/tlc.o\n\n${TL_PARSER_OBJECTS}: ${OBJ}/%.o: ${srcdir}/tgl/tl-parser/%.c | create_dirs\n\t${CC} ${INCLUDE} ${COMPILE_FLAGS} -iquote ${srcdir}/tgl/tl-parser -c -MP -MD -MF ${DEP}/$*.d -MQ ${OBJ}/$*.o -o $@ $<\n\n${EXE}/tl-parser: ${TL_PARSER_OBJECTS}\n\t${CC} $^ ${LINK_FLAGS} -o $@\n"
        },
        {
          "name": "README-Cygwin.md",
          "type": "blob",
          "size": 1.875,
          "content": "### Installation on Windows\nTo use telegram-cli in Windows, you should compile with Cygwin which has POSIX API functionality.\n\nInstall [Cygwin](https://www.cygwin.com/) and cygwin's package manager, [apt-cyg](https://github.com/transcode-open/apt-cyg).\n\nIn Cygwin Terminal, install compiler and tools :\n\n     apt-cyg install cygwin32-gcc-core cygwin32-gcc-g++ gcc-core gcc-g++ make wget patch diffutils grep tar gzip\n\nNow you have a compiler, but no libraries. You need readline, openssl, libconfig, liblua, python and libjansson to use telegram-cli's full functionality.\n\n\nThen Clone GitHub Repository in Cygwin Terminal\n\n     git clone --recursive https://github.com/vysheng/tg.git\n\n\nIn Cygwin Terminal, type: \n\n     apt-cyg install libevent-devel openssl-devel libreadline-devel lua-devel python3\n(Install package 'python' to use Python 2.7, or install package 'python3' to use Python 3)\n\nlibconfig and libjansson is not in cygwin's package, so you should compile yourself.\n\nCompile libconfig\n     \n     wget http://www.hyperrealm.com/libconfig/libconfig-1.5.tar.gz\n     tar xvf libconfig-1.5.tar.gz && cd libconfig-1.5\n     ./configure\n     make && make install && cd ..\n\nCompile libjansson\n\n     wget http://www.digip.org/jansson/releases/jansson-2.7.tar.gz\n     tar xvf jansson-2.7.tar.gz && cd jansson-2.7\n     ./configure\n     make && make install && cd ..\n\nThen, go to tg directory then generate Makefile.\n\n     cd tg\n     ./configure\n     \nWe need to patch Makefile and loop.c to compile in cygwin. Download this [patch](https://gist.github.com/ied206/d774a445f36004d263ab) then untar. Then, patch in tg directory.\n\n     patch -p1 < telegram-cli-cygwin.patch\n\nThen\n     make\n\nAfter compile is done, **telegram-cli.exe** will be generated in **bin** directory.\n\nTo run telegram-cli, type\n     \n     bin/telegram-cli -k tg-server.pub\n\n**Caution**: A binary compiled with Cygwin should be run in Cygwin Terminal.\n"
        },
        {
          "name": "README-LUA",
          "type": "blob",
          "size": 2.9931640625,
          "content": "To use lua with client you should write lua script. You can specify it from config (\"lua_script\" option) or from command_line [-s].\n\nIt should have several functions:\n  on_binlog_replay_end() - it is called when replay of old events end. Any updates prior this call were already received by this client\n                           some time ago. \n  \n  on_get_difference_end() - it is called after first get_difference call. So we received all updates after last client execute.\n\n  on_our_id(our_id) - Informs about id of currently logged in user.\n\n  on_msg_receive(msg) - it is called when we receive new msg (!! may be called before on_binlog_replay_end, than it is old msg).\n\n  on_user_update(user,what_changed) - updated info about user. what_changed is array of strings.\n  on_chat_update(user,what_changed) - updated info about user. what_changed is array of strings.\n  on_secret_chat_update(user,what_changed) - updated info about user. what_changed is array of strings.\n\n\n\nAlso, you can call several functions. Each this function last two arguments, are cb_function and cb_extra.\nThese functions may return false immidiately if something is bad with args, or return true and call cb_function in future.\ncb_function would have two or three arguments: first cb_extra, second success (1 or 0), third result (if applicable).\n\nIf you want to pass msg to function, you should pass it's id.\nIf you want to pass peer to function, you should pass it's print_name.\nOr, you can pass string user#id<id> chat#id<id> and secret_chat#id<id> as peer. It is in some cases better. For example if you want to postpone and you are afraid, that print_name would be changed in the meantime. \n\nFunction_list (arguments are listed aside from cb_function and cb_extra, :\n  get_contact_list ()\n  get_dialog_list ()\n  \n  rename_chat (chat, new_name)\n  chat_set_photo (chat, file)\n  \n  send_typing (peer)\n  send_typing_abort (peer)\n  \n  send_msg (peer, text)\n  fwd_msg (peer, msg)\n  \n  send_photo (peer, file)\n  send_video (peer, file)\n  send_audio (peer, file)\n  send_document (peer, file)\n  send_text (peer, file)\n\n  load_photo(msg)\n  load_video(msg)\n  load_video_thumb(msg)\n  load_audio(msg)\n  load_document(msg)\n  load_document_thumb(msg)\n\n  chat_info (chat)\n  channel_info (channel)\n  user_info (user)\n\n  get_history (peer, limit)\n  \n  chat_add_user (chat, user)\n  chat_del_user (chat, user)\n  \n  add_contact (phone, first_name, last_name)\n  rename_contact (phone, first_name, last_name) \n  \n  msg_search (peer, text)\n  msg_global_search (text)\n\n  mark_read (peer)\n\n  set_profile_photo (file)\n  \n  create_secret_chat (user)\n  create_group_chat (user, name)\n  \n  delete_msg (msg)\n  restore_msg (number)\n\n  status_online ()\n  status_offline ()\n\n  send_location (peer, latitude, longitude)\n\nAlso, you have function \n  postpone (cb_function, cb_extra, timeout). It will call your cb_function in specified number of seconds (number of seconds may be double).\n  register_interface_function (name, cb_function, cb_arg, description, arg1_type, arg2_type, ...) adds function to CLI interface\n"
        },
        {
          "name": "README-PY.md",
          "type": "blob",
          "size": 12.17578125,
          "content": "Python Bindings\n====================\nAll of the functions and methods are executed in the network loop of tg, ***NOT IMMEDIATELY***. What this means is all calls should be considered async, and so there is an optional callback parameter for every function/method as the last parameter. For many uses, you won't care about the return value, so you can leave out the callback. Note there are a few cases where the callback is considered mandatory when the function is considered an information query and has no functionality without returned data. These will explicitly have the callback in the parameter list and will be noted in the description.\n\nYou can specify the python script from config (\"python_script\" option) or from command_line [-Z].\n\nVersion Notes\n=====================\nThe python integration is written with Python 2/3 in mind, however, there is a bias to Python 3. Because of this, there are a few caveats:\n- I am only testing against Python 2.7, and have no intention to support/test < 2.7 but am more than happy to accept PRs for fixes as long as it does not break 2.7/3\n- repr/print of native types is dumbed down for < 2.7.9, I highly recommend using this version or newer. (This is due to a [bug](http://bugs.python.org/issue22023) in python)\n\nTGL Callbacks\n=============\nAssign python fuctions to the following tgl attributes to set callbacks from TG.\n\n| Callback | Description          |\n|--------- | ---------------------|\n|`tgl.on_binlog_replay_end()` | This is called when replay of old events end. Any updates prior this call were already received by this client some time ago.|\n|`tgl.on_get_difference_end()`| This is called after first get_difference call. So we received all updates after last client execute.|\n|`tgl.on_our_id(our_id)`|Informs about id of currently logged in user.|\n|`tgl.on_msg_receive(msg)`| This is called when we receive new `tgl.Msg` object (*may be called before on_binlog_replay_end, than it is old msg*).|\n|`tgl.on_user_update(peer, what_changed)`|updated info about user. peer is a `tgl.Peer` object representing the user, and what_changed is array of strings.|\n|`tgl.on_chat_update(peer, what_changed)`|updated info about chat. peer is a `tgl.Peer` object representing the chat, and what_changed is array of strings.|\n|`tgl.on_secret_chat_update(peer, what_changed)`|updated info about secret chat. peer is a `tgl.Peer` object representing the secret chat, and  what_changed is array of strings.|\n\nPython Callback Signatures\n=========================\nAs mentioned, all methods and functions have callbacks. The following are the different signatures that may be required (*The description of the method will mention which is used*)\n\n| Type | Signature          | Description |\n|----- | ------------------ | ------------|\n|empty_cb|`(success)`|This just indicated the success of the call. All other callback types have this as well.|\n|contact_list_cb|`(success, peer_list)`|`peer_list` is a list of `tgl.Peer` objects|\n|dialog_list_cb|`(success, dialog_list)`|`dialog_list` is a list of dicts, with keys: 'peer': `tgl.Peer`, 'message': `tgl.Msg`|\n|msg_cb|`(success, msg)`|`msg` is a `tgl.Msg`|\n|msg_list_cb|`(success, msg_list)`|`msg_list` is a list of `tgl.Msg` objects|\n|file_cb|`(success, file_path)`|`file_path` is a string with an absolute path|\n|chat_cb|`(success, peer)`|`peer` is a `tgl.Peer` that will have the type of `tgl.PEER_CHAT`|\n|peer_cb|`(success, peer)`|`peer` is a `tgl.Peer`|\n|secret_chat_cb|`(success, peer)`|`peer` is a `tgl.Peer` that will have the type of `tgl.PEER_ENCR_CHAT`|\n|user_cb|`(success, peer)`|`peer` is a `tgl.Peer` that will have the type of `tgl.PEER_USER`|\n|str_cb|`(success, string)`|`string` is a simple string|\n\nTGL Module Level Fuctions\n=========================\nAll of these functions are accessed by importing the `tgl` module.\n\n| Function | Description          | Callback Type |\n|--------- | ---------------------| ------------- |\n|`tgl.get_contact_list (callback)`|Retrieve peers stored in the contact list. *requires callback*|`contact_list_cb`|\n|`tgl.get_dialog_list (callback)`|Get a list of current conversations with the `tgl.Peer` and the most recent `tgl.Msg`. *requires callback*|`dialog_list_cb`|\n|`tgl.add_contact (phone, first_name, last_name)`|Adds contact to contact list, last name is optional|`contact_list_cb`|\n|`tgl.del_contact (peer)`|Removes contact from contact list|`empty_cb`|\n|`tgl.rename_contact (phone, first_name, last_name) `|Renaming a contact means sending the first/last name with the same phone number of an existing contact|`contact_list_cb`|\n|`tgl.msg_global_search (text, callback)`|Get all messages that match the search text. *requires callback*|`msg_list_cb`|\n|`tgl.set_profile_photo (file_path)`|Sets avatar to image found at `file_path`, no checking on the file.|`empty_cb`|\n|`tgl.create_secret_chat (user)`|Creates secret chat with user, callback recommended to get new peer for the secret chat.|`secret_chat_cb`|\n|`tgl.create_group_chat (peer_list, name)`|`peer_list` contains users to create group with, must be more than 1 peer.|`empty_cb`|\n|`tgl.restore_msg (msg_id)`|Restore a deleted message by message id.|`empty_cb`|\n|`tgl.status_online ()`|Sets status as online|`empty_cb`|\n|`tgl.status_offline ()`|Sets status as offline|`empty_cb`|\n|`tgl.import_chat_link (link)`|Join channel using the `link`.|`empty_cb`|\n|`tgl.safe_exit (exit_status)`|Exception to the rule about callbacks, no callback parameter is accepted. Causes the bot to quit after cleaning up. `exit_status` is an optional parameter with the exit status (On glibc, this must be 0-255)|NONE|\n\nPeer\n====\n## Attributes\n| Attribute | Type |  Description          |\n|---------- | ---- | ----------------------|\n|`id`|`int`|Telegram peer id|\n|`type`|`int`|Peer type, you can compare this with `tgl.PEER_CHAT`, `tgl.PEER_USER`, or `tgl.PEER_ENCR_CHAT`|\n|`type_name`|`string`|Text representation of the type of the peer, `'chat'`, `'user'`, or `'secret_chat'`|\n|`name`|`string`|Returns the tg print version of the name. Usually `FirstName_LastName` for user, and the chatname with spaces replaced with `_`|\n|`user_id`|`int`|Used in secret chats, since a secret chat has it's own id, this is the id of the user at the endpoint.|\n|`user_list`|`peer_list`|Only used in `tgl.PEER_CHAT` peers, contains list of users. This currently does not work, it is not populating properly.|\n|`user_status`|`dict`|Only used in `tgl.PEER_USER` peers. Dictionary with the current status, keys: 'online': `bool`, 'when': `datetime`|\n|`phone`|`string`|Only used in `tgl.PEER_USER` peers. Phone number, only available if user is on contact list.|\n|`username`|`string`|Only used in `tgl.PEER_USER` peers. Will be `None` if username is not set.|\n|`first_name`|`string`|Only used in `tgl.PEER_USER` peers.|\n|`last_name`|`string`|Only used in `tgl.PEER_USER` peers.|\n\n## Methods\n| Method | Description          | Callback Type |\n|------- | ---------------------| ------------- |\n|`peer.rename_chat (new_name)`||`empty_cb`|\n|`peer.chat_set_photo (file)`|Sets avatar for the group to image found at `file_path`, no checking on the file. The calling peer must be of type `tgl.PEER_CHAT`.|`msg_cb`|\n|`peer.send_typing ()`|Tell peer that you are typing.|`empty_cb`|\n|`peer.send_typing_abort ()`|Tell peer you are done typing.|`empty_cb`|\n|`peer.send_msg (text, reply=msg_id, preview=bool)`|Sends message to peer. Optional keyword arguments: reply is the message id we are replying to, preview is a boolean that forces URL preview on or off.|`msg_cb`|\n|`peer.fwd_msg (msg_id)`|Forwards msg with message id to peer.|`msg_cb`|\n|`peer.fwd_media (msg_id)`|Forwards media with message id to peer.|`msg_cb`|\n|`peer.send_photo (file)`|Send media to peer using `file`. No checking is done on the contents of the file.|`msg_cb`|\n|`peer.send_video (file)`|Send media to peer using `file`. No checking is done on the contents of the file.|`msg_cb`|\n|`peer.send_audio (file)`|Send media to peer using `file`. No checking is done on the contents of the file.|`msg_cb`|\n|`peer.send_document (file)`|Send media to peer using `file`. No checking is done on the contents of the file.|`msg_cb`|\n|`peer.send_text (file)`|Send media to peer using `file`. No checking is done on the contents of the file.|`msg_cb`|\n|`peer.send_location (latitude, longitude)`|Sends location media message to peer, `longitude` and `latitude` should be specified as double.|`msg_cb`|\n|`peer.chat_add_user (user)`|Adds `user`(`tgl.Peer`) to the group. The calling peer must be of type `tgl.PEER_CHAT`|`empty_cb`|\n|`peer.chat_del_user (user)`|Removes `user`(`tgl.Peer`) from the group. The calling peer must be of type `tgl.PEER_CHAT`|`empty_cb`|\n|`peer.mark_read ()`|Marks the dialog with the peer as read. This cannot be done on message level.|`empty_cb`|\n|`peer.msg_search (text, callback)`|Get all messages that match the search text with the peer. *requires callback*|`msg_list_cb`|\n|`peer.get_history (offset, limit, callback)`|Get all messages with the peer. `offset` specifies what message to start at, and `limit` specifies how many messages to retrieve. See example below for one method to get the entire history. *requires callback*|`msg_list_cb`|\n|`peer.info ()`|Gets peer info.|`peer_cb`|\n\nExample usage for `peer.get_history`:\n```\nfrom functools import partial\nhistory = []\n# Get all the history, 100 msgs at a time\npeer.get_history(0, 100, partial(history_callback, 100, peer))\n\ndef history_callback(msg_count, peer, success, msgs)\n    history.extend(msgs)\n    if len(msgs) == msg_count:\n        peer.get_history(len(history), msg_count, partial(history_callback, msg_count, peer))\n```\n\nMsg\n====\n## Attributes\n| Attribute | Type |  Description          |\n|---------- | ---- | ----------------------|\n|`id`|`int`|Message id|\n|`flags`|`int`|tgl flags, see source code for tgl for various possible flags. This is a bitfield in an int.|\n|`mention`|`bool`|`True` if you are @mentioned.|\n|`out`|`bool`|`True` if you sent this message.|\n|`unread`|`bool`|`True` if you have not marked this as read.|\n|`service`|`bool`|`True` if the message is a service messages, see tgl.Msg.action for the type.|\n|`src`|`tgl.Peer`|Peer who sent the message|\n|`dest`|`tgl.Peer`|Peer who the message was sent too. In a group, this will be the chat peer. Otherwise it will be you.|\n|`text`|`string`|Text contents of the message. This may be `None` if it's media without caption.|\n|`media`|`dict`|Dictionary that varies based on the media type.|\n|`date`|`datetime`|When the message was sent.|\n|`fwd_src`|`tgl.Peer`|The user that sent the forwarded message.|\n|`fwd_date`|`datetime`|When the forwarded message was originally sent.|\n|`reply`|`tgl.Msg`|Message that this message is replying to.|\n|`reply_id`|`int`|Message id that this message is replying to.|\n|`action`|`int`|Action enum for the message if `msg.service == True`. See all the possible values below|\n\n## Action Type Constants\n- tgl.ACTION_NONE\n- tgl.ACTION_GEO_CHAT_CREATE\n- tgl.ACTION_GEO_CHAT_CHECKIN\n- tgl.ACTION_CHAT_CREATE\n- tgl.ACTION_CHAT_EDIT_TITLE\n- tgl.ACTION_CHAT_EDIT_PHOTO\n- tgl.ACTION_CHAT_DELETE_PHOTO\n- tgl.ACTION_CHAT_ADD_USER\n- tgl.ACTION_CHAT_ADD_USER_BY_LINK\n- tgl.ACTION_CHAT_DELETE_USER\n- tgl.ACTION_SET_MESSAGE_TTL\n- tgl.ACTION_READ_MESSAGES\n- tgl.ACTION_DELETE_MESSAGES\n- tgl.ACTION_SCREENSHOT_MESSAGES\n- tgl.ACTION_FLUSH_HISTORY\n- tgl.ACTION_RESEND\n- tgl.ACTION_NOTIFY_LAYER\n- tgl.ACTION_TYPING\n- tgl.ACTION_NOOP\n- tgl.ACTION_COMMIT_KEY\n- tgl.ACTION_ABORT_KEY\n- tgl.ACTION_REQUEST_KEY\n- tgl.ACTION_ACCEPT_KEY\n\n## Methods\n| Method | Description          | Callback Type |\n|------- | ---------------------| ------------- |\n|`msg.load_photo(callback)`|Saves the media and returns the path to the file in the callback. *requires callback*|`file_cb`|\n|`msg.load_video(callback)`|Saves the media and returns the path to the file in the callback. *requires callback*|`file_cb`|\n|`msg.load_video_thumb(callback)`|Saves the media and returns the path to the file in the callback. *requires callback*|`file_cb`|\n|`msg.load_audio(callback)`|Saves the media and returns the path to the file in the callback. *requires callback*|`file_cb`|\n|`msg.load_document(callback)`|Saves the media and returns the path to the file in the callback. *requires callback*|`file_cb`|\n|`msg.load_document_thumb(callback)`|Saves the media and returns the path to the file in the callback. *requires callback*|`file_cb`|\n|`msg.delete_msg ()`|Deletes the message from the local history|`empty_cb`|\n"
        },
        {
          "name": "README.es",
          "type": "blob",
          "size": 5.8212890625,
          "content": "## Telegram messenger CLI [![Build Status](https://travis-ci.org/vysheng/tg.png)](https://travis-ci.org/vysheng/tg)\n\n!!!! May be outdated. Please refer to english README as more actual. \n\n\nInterfaz de línea de comandos para: [Telegram](http://telegram.org). Usa interfaz readline.\n\n### Documentación del API y el protocolo\n\nLa documentación del APi de Telegram está disponible aquí: http://core.telegram.org/api\n\nLa documentación del protocolo MTproto está disponible aquí: http://core.telegram.org/mtproto\n\n### Instalación\n\nClona el Repositorio GitHub\n\n    $ git clone https://github.com/vysheng/tg.git && cd tg\n    \no descarga y descomprime el zip\n\n    $ wget https://github.com/vysheng/tg/archive/master.zip -O tg-master.zip\n    $ unzip tg-master.zip && cd tg-master\n    \n#### Linux\n\nLibrerías requeridas: readline openssl y (si desea usar config) libconfig y liblua.\nSi no deseas usarlo, pasa las siguientes opciones --disable-libconfig y --disable-liblua respectivamente.\n\nEn Ubuntu usa:\n\n    $ sudo apt-get install libreadline-dev libconfig-dev libssl-dev lua5.2 liblua5.2-dev\n\nEn gentoo:\n    \n    $ sudo emerge -av sys-libs/readline dev-libs/libconfig dev-libs/openssl dev-lang/lua\n    \nEn Fedora:\n\n    $ sudo yum install lua-devel openssl-devel libconfig-devel readline-devel\n\nPor defecto Makefile utiliza liblua5.2 de ubuntu. Si utilizas una versión diferente de liblua o linux, tienes que ejecutar el script ./configure o recibirás un error de compilación extraño.\n\nEntonces\n\n    $ ./configure\n    $ make\n\n\n#### Mac OS X\n\nEl cliente depende de [librería readline](http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html) y [libconfig](http://www.hyperrealm.com/libconfig/), las cuales no están incluídas en OS X por defecto. Debes instalar estas librerías de forma manual, usando por ejemplo [Homebrew](http://brew.sh/).\n\n    $ brew install libconfig\n    $ brew install readline\n    $ brew install lua\n    $ export CFLAGS=\"-I/usr/local/include -I/usr/local/Cellar/readline/6.2.4/include\"\n    $ export LDFLAGS=\"-L/usr/local/lib -L/usr/local/Cellar/readline/6.2.4/lib\"\n    $ ./configure && make\n    \nGracias a [@jfontan](https://github.com/vysheng/tg/issues/3#issuecomment-28293731) por esta solución.\n\n#### FreeBSD\n\nInstalar estos puertos:\n\n* devel/libconfig\n* devel/libexecinfo\n\nEntonces construir:\n\n    $ env CC=clang CFLAGS=-I/usr/local/include LDFLAGS=-L/usr/local/lib ./configure\n    $ make\n    \n#### Otros UNIX\n\nSi logras ejecutarlo en otros UNIX, por favor házmelo saber.\n\n\n### Uso\n\n    ./telegram -k <clave-servidor-público>\n    \n\nPor defecto la clave pública se almacena en la misma carpeta con el nombre tg-server.pub o en /etc/telegram/server.pub, si no lo es, indica dónde encontrarlo:\n\n    ./telegram -k tg-server.pub\n\nEl Cliente soporta completamiento con TAB e historial de comandos.\n\nPeer se refiere al nombre del contacto o de diálogo y se puede acceder por completamiento con Tab.\nPara los contactos de usuario el peer es el Nombre <guión bajo> Apellido con todos los espacios cambiados a guiones bajos.\nPara los chats es su título con todos los espacios cambiados a guiones bajos.\nPara los chats encriptados es <marca de exclamación> <guión bajo> Nombre <guión bajo> Apellido con todos los espacios cambiados a guiones bajos. \n\nSi dos o más peers tienen el mismo nombre, una almohadilla y un número es añadido al nombre. (por ejemplo A_B,A_B#1,A_B#2 y así sucesivamente).\n  \n### Comandos soportados\n\n#### Mensajería\n\n\n* **msg** \\<peer\\> texto - envía el mensaje a este usuario.\n* **fwd** \\<usuario\\> \\<numero-mensaje\\> - reenviar un mensaje al usuario. Puedes ver los número de mensajes iniciando el Cliente con -N.\n* **chat_with_peer** \\<peer\\> - inicia un chat con este usuario. /exit o /quit para salir de este modo.\n* **add_contact** \\<numero-teléfono\\> \\<nombre\\> \\<apellido\\> - intenta añadir este contacto a la lista de contactos.\n* **rename_contact** \\<usuario\\> \\<nombre\\> \\<apellido\\> - intenta renombrar el contacto. Si tienes otro dispositivo será una pelea.\n* **mark_read** \\<peer\\> - marca todos los mensajes como recibidos de ese usuario.\n\n#### Multimedia\n\n* **send_photo** \\<peer\\> \\<nombre-archivo-foto\\> - manda una foto al usuario.\n* **send_video** \\<peer\\> \\<nombre-archivo-video\\> - envia un video al usuario.\n* **send_text** \\<peer\\> \\<nombre-archivo-texto> - envia un archivo de texto como un mensaje en plano.\n* **load_photo**/load_video/load_video_thumb \\<numero-mensaje\\> - carga foto/video indicado del directorio de descarga.\n* **view_photo**/view_video/view_video_thumb \\<numero-mensaje\\> - carga foto/video indicado del directorio de descarga y lo abre con el visor por defecto del sistema.\n\n\n#### Opciones de chat de grupo\n\n* **chat_info** \\<chat\\> - imprime información del chat.\n* **chat_add_user** \\<chat\\> \\<usuario\\> - agrega un usuario al chat.\n* **chat_del_user** \\<chat\\> \\<usuario\\> - elimina un usuario del chat.\n* **rename_chat** \\<chat\\> \\<nuevo-nombre\\> - cambia el nombre al chat.\n\n#### Search\n\n* **search** \\<peer\\> patrón - busca el patrón indicado en los mensajes con ese usuario.\n* **global_search** patrón - busca el patrón indicado en todos los mensajes.\n\n#### Chat secreto\n\n* **create_secret_chat** \\<user\\> - crea un chat secreto con el usuario indicado.\n* **visualize_key** \\<secret_chat\\> - Muestra la clave de cifrado. Debes compararla con la del otro usuario.\n\n#### Estadísticas e información varia.\n\n* **user_info** \\<user\\> - muestra información sobre el usuario.\n* **history** \\<peer\\> [limit] - muestra el historial (y la marca como leído). Limite por defecto = 40.\n* **dialog_list** - muestra información acerca del dialogo\n* **contact_list** - muestra información acerca de tu lista de contactos.\n* **suggested_contacts** - muestra información sobre sus contactos, tiene un máximo de amigos comunes.\n* **stats** - solo para depuración.\n* **show_license** - muestra la licencia GPLv2.\n* **help** - imprime esta ayuda.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.1376953125,
          "content": "## Telegram messenger CLI [![Build Status](https://travis-ci.org/vysheng/tg.png)](https://travis-ci.org/vysheng/tg)\n\nCommand-line interface for [Telegram](http://telegram.org). Uses readline interface.\n\n### API, Protocol documentation\n\nDocumentation for Telegram API is available here: http://core.telegram.org/api\n\nDocumentation for MTproto protocol is available here: http://core.telegram.org/mtproto\n\n### Upgrading to version 1.0\n\nFirst of all, the binary is now in ./bin folder and is named telegram-cli. So be careful, not to use old binary.\n\nSecond, config folder is now ${HOME}/.telegram-cli\n\nThird, database is not compatible with older versions, so you'll have to login again.\n\nFourth, in peer_name '#' are substitued to '@'. (Not applied to appending of '#%d' in case of two peers having same name).\n\n### Installation\n\nClone GitHub Repository\n\n     git clone --recursive https://github.com/vysheng/tg.git && cd tg\n\n### Python Support\n\nPython support is currently limited to Python 2.7 or Python 3.1+. Other versions may work but are not tested.\n\n#### Linux and BSDs\n\nInstall libs: readline, openssl and (if you want to use config) libconfig, liblua, python and libjansson.\nIf you do not want to use them pass options --disable-libconfig, --disable-liblua, --disable-python and --disable-json respectively.\n\nOn Ubuntu/Debian use: \n\n     sudo apt-get install libreadline-dev libconfig-dev libssl-dev lua5.2 liblua5.2-dev libevent-dev libjansson-dev libpython-dev make \n\nOn gentoo:\n\n     sudo emerge -av sys-libs/readline dev-libs/libconfig dev-libs/openssl dev-lang/lua dev-libs/libevent dev-libs/jansson dev-lang/python\n\nOn Fedora:\n\n     sudo dnf install lua-devel openssl-devel libconfig-devel readline-devel libevent-devel libjansson-devel python-devel\n\nOn Archlinux:\n\n     yaourt -S telegram-cli-git\n\nOn FreeBSD:\n\n     pkg install libconfig libexecinfo lua52 python\n\nOn OpenBSD:\n\n     pkg_add libconfig libexecinfo lua python\n\nOn openSUSE:\n\n     sudo zypper in lua-devel libconfig-devel readline-devel libevent-devel libjansson-devel python-devel libopenssl-devel\n\nThen,\n\n     ./configure\n     make\n\n#### Other methods to install on linux\n\nOn Gentoo: use ebuild provided.\n\nOn Arch: https://aur.archlinux.org/packages/telegram-cli-git\n\n#### Mac OS X\n\nThe client depends on [readline library](http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html) and [libconfig](http://www.hyperrealm.com/libconfig/), which are not included in OS X by default. You have to install these libraries manually.\n\nIf using [Homebrew](http://brew.sh/):\n\n     brew install libconfig readline lua python libevent jansson\n     export CFLAGS=\"-I/usr/local/include -I/usr/local/Cellar/readline/6.3.8/include\"\n     export LDFLAGS=\"-L/usr/local/lib -L/usr/local/Cellar/readline/6.3.8/lib\"\n     ./configure && make\n\nThanks to [@jfontan](https://github.com/vysheng/tg/issues/3#issuecomment-28293731) for this solution.\n\nIf using [MacPorts](https://www.macports.org):\n     \n     sudo port install libconfig-hr\n     sudo port install readline\n     sudo port install lua51\n     sudo port install python34\n     sudo port install libevent\n     export CFLAGS=\"-I/usr/local/include -I/opt/local/include -I/opt/local/include/lua-5.1\"\n     export LDFLAGS=\"-L/usr/local/lib -L/opt/local/lib -L/opt/local/lib/lua-5.1\"\n     ./configure && make\n\nInstall these ports:\n\n* devel/libconfig\n* devel/libexecinfo\n* lang/lua52\n\nThen build:\n\n     env CC=clang CFLAGS=-I/usr/local/include LDFLAGS=-L/usr/local/lib LUA=/usr/local/bin/lua52 LUA_INCLUDE=-I/usr/local/include/lua52 LUA_LIB=-llua-5.2 ./configure\n     make\n\n#### Other UNIX\n\nIf you manage to launch it on other UNIX, please let me know.\n\n### Contacts \nIf you would like to ask a question, you can write to my telegram or to the github (or both). To contact me via telegram, you should use import_card method with argument 000653bf:0738ca5d:5521fbac:29246815:a27d0cda\n\n\n### Usage\n\n    bin/telegram-cli -k <public-server-key>\n    \nBy default, the public key is stored in tg-server.pub in the same folder or in /etc/telegram-cli/server.pub. If not, specify where to find it:\n\n    bin/telegram-cli -k tg-server.pub\n\nClient support TAB completion and command history.\n\nPeer refers to the name of the contact or dialog and can be accessed by TAB completion.\nFor user contacts peer name is Name <underscore> Lastname with all spaces changed to underscores.\nFor chats it is it's title with all spaces changed to underscores\nFor encrypted chats it is <Exсlamation mark> <underscore> Name <underscore> Lastname with all spaces changed to underscores. \n\nIf two or more peers have same name, <sharp>number is appended to the name. (for example A_B, A_B#1, A_B#2 and so on)\n  \n### Supported commands\n\n#### Messaging\n\n* **msg** \\<peer\\> Text - sends message to this peer\n* **fwd** \\<user\\> \\<msg-seqno\\> - forward message to user. You can see message numbers starting client with -N\n* **chat_with_peer** \\<peer\\> starts one on one chat session with this peer. /exit or /quit to end this mode.\n* **add_contact** \\<phone-number\\> \\<first-name\\> \\<last-name\\> - tries to add contact to contact-list by phone\n* **rename_contact** \\<user\\> \\<first-name\\> \\<last-name\\> - tries to rename contact. If you have another device it will be a fight\n* **mark_read** \\<peer\\> - mark read all received messages with peer\n* **delete_msg** \\<msg-seqno\\> - deletes message (not completly, though)\n* **restore_msg** \\<msg-seqno\\> - restores delete message. Impossible for secret chats. Only possible short time (one hour, I think) after deletion\n\n#### Multimedia\n\n* **send_photo** \\<peer\\> \\<photo-file-name\\> - sends photo to peer\n* **send_video** \\<peer\\> \\<video-file-name\\> - sends video to peer\n* **send_text** \\<peer\\> \\<text-file-name> - sends text file as plain messages\n* **load_photo**/load_video/load_video_thumb/load_audio/load_document/load_document_thumb \\<msg-seqno\\> - loads photo/video/audio/document to download dir\n* **view_photo**/view_video/view_video_thumb/view_audio/view_document/view_document_thumb \\<msg-seqno\\> - loads photo/video to download dir and starts system default viewer\n* **fwd_media** \\<msg-seqno\\> send media in your message. Use this to prevent sharing info about author of media (though, it is possible to determine user_id from media itself, it is not possible get access_hash of this user)\n* **set_profile_photo** \\<photo-file-name\\> - sets userpic. Photo should be square, or server will cut biggest central square part\n\n\n#### Group chat options\n\n* **chat_info** \\<chat\\> - prints info about chat\n* **chat_add_user** \\<chat\\> \\<user\\> - add user to chat\n* **chat_del_user** \\<chat\\> \\<user\\> - remove user from chat\n* **rename_chat** \\<chat\\> \\<new-name\\>\n* **create_group_chat** \\<chat topic\\> \\<user1\\> \\<user2\\> \\<user3\\> ... - creates a groupchat with users, use chat_add_user to add more users\n* **chat_set_photo** \\<chat\\> \\<photo-file-name\\> - sets group chat photo. Same limits as for profile photos.\n\n#### Search\n\n* **search** \\<peer\\> pattern - searches pattern in messages with peer\n* **global_search** pattern - searches pattern in all messages\n\n#### Secret chat\n\n* **create_secret_chat** \\<user\\> - creates secret chat with this user\n* **visualize_key** \\<secret_chat\\> - prints visualization of encryption key. You should compare it to your partner's one\n* **set_ttl** \\<secret_chat\\> \\<ttl\\> - sets ttl to secret chat. Though client does ignore it, client on other end can make use of it\n* **accept_secret_chat** \\<secret_chat\\> - manually accept secret chat (only useful when starting with -E key)\n\n#### Stats and various info\n\n* **user_info** \\<user\\> - prints info about user\n* **history** \\<peer\\> [limit] - prints history (and marks it as read). Default limit = 40\n* **dialog_list** - prints info about your dialogs\n* **contact_list** - prints info about users in your contact list\n* **suggested_contacts** - print info about contacts, you have max common friends\n* **stats** - just for debugging\n* **show_license** - prints contents of GPLv2\n* **help** - prints this help\n* **get_self** - get our user info\n\n#### Card\n* **export_card** - print your 'card' that anyone can later use to import your contact\n* **import_card** \\<card\\> - gets user by card. You can write messages to him after that.\n\n#### Other\n* **quit** - quit\n* **safe_quit** - wait for all queries to end then quit\n"
        },
        {
          "name": "ax_lua.m4",
          "type": "blob",
          "size": 24.2236328125,
          "content": "# ===========================================================================\n#          http://www.gnu.org/software/autoconf-archive/ax_lua.html\n# ===========================================================================\n#\n# SYNOPSIS\n#\n#   AX_PROG_LUA[([MINIMUM-VERSION], [TOO-BIG-VERSION], [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])]\n#   AX_LUA_HEADERS[([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])]\n#   AX_LUA_LIBS[([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])]\n#   AX_LUA_READLINE[([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])]\n#\n# DESCRIPTION\n#\n#   Detect a Lua interpreter, optionally specifying a minimum and maximum\n#   version number. Set up important Lua paths, such as the directories in\n#   which to install scripts and modules (shared libraries).\n#\n#   Also detect Lua headers and libraries. The Lua version contained in the\n#   header is checked to match the Lua interpreter version exactly. When\n#   searching for Lua libraries, the version number is used as a suffix.\n#   This is done with the goal of supporting multiple Lua installs (5.1 and\n#   5.2 side-by-side).\n#\n#   A note on compatibility with previous versions: This file has been\n#   mostly rewritten for serial 18. Most developers should be able to use\n#   these macros without needing to modify configure.ac. Care has been taken\n#   to preserve each macro's behavior, but there are some differences:\n#\n#   1) AX_WITH_LUA is deprecated; it now expands to the exact same thing as\n#   AX_PROG_LUA with no arguments.\n#\n#   2) AX_LUA_HEADERS now checks that the version number defined in lua.h\n#   matches the interpreter version. AX_LUA_HEADERS_VERSION is therefore\n#   unnecessary, so it is deprecated and does not expand to anything.\n#\n#   3) The configure flag --with-lua-suffix no longer exists; the user\n#   should instead specify the LUA precious variable on the command line.\n#   See the AX_PROG_LUA description for details.\n#\n#   Please read the macro descriptions below for more information.\n#\n#   This file was inspired by Andrew Dalke's and James Henstridge's\n#   python.m4 and Tom Payne's, Matthieu Moy's, and Reuben Thomas's ax_lua.m4\n#   (serial 17). Basically, this file is a mash-up of those two files. I\n#   like to think it combines the best of the two!\n#\n#   AX_PROG_LUA: Search for the Lua interpreter, and set up important Lua\n#   paths. Adds precious variable LUA, which may contain the path of the Lua\n#   interpreter. If LUA is blank, the user's path is searched for an\n#   suitable interpreter.\n#\n#   If MINIMUM-VERSION is supplied, then only Lua interpreters with a\n#   version number greater or equal to MINIMUM-VERSION will be accepted. If\n#   TOO-BIG- VERSION is also supplied, then only Lua interpreters with a\n#   version number greater or equal to MINIMUM-VERSION and less than\n#   TOO-BIG-VERSION will be accepted.\n#\n#   Version comparisons require the AX_COMPARE_VERSION macro, which is\n#   provided by ax_compare_version.m4 from the Autoconf Archive.\n#\n#   The Lua version number, LUA_VERSION, is found from the interpreter, and\n#   substituted. LUA_PLATFORM is also found, but not currently supported (no\n#   standard representation).\n#\n#   Finally, the macro finds four paths:\n#\n#     luadir             Directory to install Lua scripts.\n#     pkgluadir          $luadir/$PACKAGE\n#     luaexecdir         Directory to install Lua modules.\n#     pkgluaexecdir      $luaexecdir/$PACKAGE\n#\n#   These paths a found based on $prefix, $exec_prefix, Lua's package.path,\n#   and package.cpath. The first path of package.path beginning with $prefix\n#   is selected as luadir. The first path of package.cpath beginning with\n#   $exec_prefix is used as luaexecdir. This should work on all reasonable\n#   Lua installations. If a path cannot be determined, a default path is\n#   used. Of course, the user can override these later when invoking make.\n#\n#     luadir             Default: $prefix/share/lua/$LUA_VERSION\n#     luaexecdir         Default: $exec_prefix/lib/lua/$LUA_VERSION\n#\n#   These directories can be used by Automake as install destinations. The\n#   variable name minus 'dir' needs to be used as a prefix to the\n#   appropriate Automake primary, e.g. lua_SCRIPS or luaexec_LIBRARIES.\n#\n#   If an acceptable Lua interpreter is found, then ACTION-IF-FOUND is\n#   performed, otherwise ACTION-IF-NOT-FOUND is preformed. If ACTION-IF-NOT-\n#   FOUND is blank, then it will default to printing an error. To prevent\n#   the default behavior, give ':' as an action.\n#\n#   AX_LUA_HEADERS: Search for Lua headers. Requires that AX_PROG_LUA be\n#   expanded before this macro. Adds precious variable LUA_INCLUDE, which\n#   may contain Lua specific include flags, e.g. -I/usr/include/lua5.1. If\n#   LUA_INCLUDE is blank, then this macro will attempt to find suitable\n#   flags.\n#\n#   LUA_INCLUDE can be used by Automake to compile Lua modules or\n#   executables with embedded interpreters. The *_CPPFLAGS variables should\n#   be used for this purpose, e.g. myprog_CPPFLAGS = $(LUA_INCLUDE).\n#\n#   This macro searches for the header lua.h (and others). The search is\n#   performed with a combination of CPPFLAGS, CPATH, etc, and LUA_INCLUDE.\n#   If the search is unsuccessful, then some common directories are tried.\n#   If the headers are then found, then LUA_INCLUDE is set accordingly.\n#\n#   The paths automatically searched are:\n#\n#     * /usr/include/luaX.Y\n#     * /usr/include/lua/X.Y\n#     * /usr/include/luaXY\n#     * /usr/local/include/luaX.Y\n#     * /usr/local/include/lua-X.Y\n#     * /usr/local/include/lua/X.Y\n#     * /usr/local/include/luaXY\n#\n#   (Where X.Y is the Lua version number, e.g. 5.1.)\n#\n#   The Lua version number found in the headers is always checked to match\n#   the Lua interpreter's version number. Lua headers with mismatched\n#   version numbers are not accepted.\n#\n#   If headers are found, then ACTION-IF-FOUND is performed, otherwise\n#   ACTION-IF-NOT-FOUND is performed. If ACTION-IF-NOT-FOUND is blank, then\n#   it will default to printing an error. To prevent the default behavior,\n#   set the action to ':'.\n#\n#   AX_LUA_LIBS: Search for Lua libraries. Requires that AX_PROG_LUA be\n#   expanded before this macro. Adds precious variable LUA_LIB, which may\n#   contain Lua specific linker flags, e.g. -llua5.1. If LUA_LIB is blank,\n#   then this macro will attempt to find suitable flags.\n#\n#   LUA_LIB can be used by Automake to link Lua modules or executables with\n#   embedded interpreters. The *_LIBADD and *_LDADD variables should be used\n#   for this purpose, e.g. mymod_LIBADD = $(LUA_LIB).\n#\n#   This macro searches for the Lua library. More technically, it searches\n#   for a library containing the function lua_load. The search is performed\n#   with a combination of LIBS, LIBRARY_PATH, and LUA_LIB.\n#\n#   If the search determines that some linker flags are missing, then those\n#   flags will be added to LUA_LIB.\n#\n#   If libraries are found, then ACTION-IF-FOUND is performed, otherwise\n#   ACTION-IF-NOT-FOUND is performed. If ACTION-IF-NOT-FOUND is blank, then\n#   it will default to printing an error. To prevent the default behavior,\n#   set the action to ':'.\n#\n#   AX_LUA_READLINE: Search for readline headers and libraries. Requires the\n#   AX_LIB_READLINE macro, which is provided by ax_lib_readline.m4 from the\n#   Autoconf Archive.\n#\n#   If a readline compatible library is found, then ACTION-IF-FOUND is\n#   performed, otherwise ACTION-IF-NOT-FOUND is performed.\n#\n# LICENSE\n#\n#   Copyright (c) 2013 Tim Perkins <tprk77@gmail.com>\n#   Copyright (c) 2013 Reuben Thomas <rrt@sc3d.org>\n#\n#   This program is free software: you can redistribute it and/or modify it\n#   under the terms of the GNU General Public License as published by the\n#   Free Software Foundation, either version 3 of the License, or (at your\n#   option) any later version.\n#\n#   This program is distributed in the hope that it will be useful, but\n#   WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n#   Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License along\n#   with this program. If not, see <http://www.gnu.org/licenses/>.\n#\n#   As a special exception, the respective Autoconf Macro's copyright owner\n#   gives unlimited permission to copy, distribute and modify the configure\n#   scripts that are the output of Autoconf when processing the Macro. You\n#   need not follow the terms of the GNU General Public License when using\n#   or distributing such scripts, even though portions of the text of the\n#   Macro appear in them. The GNU General Public License (GPL) does govern\n#   all other use of the material that constitutes the Autoconf Macro.\n#\n#   This special exception to the GPL applies to versions of the Autoconf\n#   Macro released by the Autoconf Archive. When you make and distribute a\n#   modified version of the Autoconf Macro, you may extend this special\n#   exception to the GPL to apply to your modified version as well.\n\n#serial 21\n\ndnl =========================================================================\ndnl AX_PROG_LUA([MINIMUM-VERSION], [TOO-BIG-VERSION],\ndnl             [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])\ndnl =========================================================================\nAC_DEFUN([AX_PROG_LUA],\n[\n  dnl Make LUA a precious variable.\n  AC_ARG_VAR([LUA], [The Lua interpreter, e.g. /usr/bin/lua5.1])\n\n  dnl Find a Lua interpreter.\n  m4_define_default([_AX_LUA_INTERPRETER_LIST],\n    [lua lua5.2 lua52 lua5.1 lua51 lua50])\n\n  m4_if([$1], [],\n  [ dnl No version check is needed. Find any Lua interpreter.\n    AS_IF([test \"x$LUA\" = 'x'],\n      [AC_PATH_PROGS([LUA], [_AX_LUA_INTERPRETER_LIST], [:])])\n    ax_display_LUA='lua'\n\n    dnl At least check if this is a Lua interpreter.\n    AC_MSG_CHECKING([if $LUA is a Lua interpreter])\n    _AX_LUA_CHK_IS_INTRP([$LUA],\n      [AC_MSG_RESULT([yes])],\n      [ AC_MSG_RESULT([no])\n        AC_MSG_ERROR([not a Lua interpreter])\n      ])\n  ],\n  [ dnl A version check is needed.\n    AS_IF([test \"x$LUA\" != 'x'],\n    [ dnl Check if this is a Lua interpreter.\n      AC_MSG_CHECKING([if $LUA is a Lua interpreter])\n      _AX_LUA_CHK_IS_INTRP([$LUA],\n        [AC_MSG_RESULT([yes])],\n        [ AC_MSG_RESULT([no])\n          AC_MSG_ERROR([not a Lua interpreter])\n        ])\n      dnl Check the version.\n      m4_if([$2], [],\n        [_ax_check_text=\"whether $LUA version >= $1\"],\n        [_ax_check_text=\"whether $LUA version >= $1, < $2\"])\n      AC_MSG_CHECKING([$_ax_check_text])\n      _AX_LUA_CHK_VER([$LUA], [$1], [$2],\n        [AC_MSG_RESULT([yes])],\n        [ AC_MSG_RESULT([no])\n          AC_MSG_ERROR([version is out of range for specified LUA])])\n      ax_display_LUA=$LUA\n    ],\n    [ dnl Try each interpreter until we find one that satisfies VERSION.\n      m4_if([$2], [],\n        [_ax_check_text=\"for a Lua interpreter with version >= $1\"],\n        [_ax_check_text=\"for a Lua interpreter with version >= $1, < $2\"])\n      AC_CACHE_CHECK([$_ax_check_text],\n        [ax_cv_pathless_LUA],\n        [ for ax_cv_pathless_LUA in _AX_LUA_INTERPRETER_LIST none; do\n            test \"x$ax_cv_pathless_LUA\" = 'xnone' && break\n            _AX_LUA_CHK_IS_INTRP([$ax_cv_pathless_LUA], [], [continue])\n            _AX_LUA_CHK_VER([$ax_cv_pathless_LUA], [$1], [$2], [break])\n          done\n        ])\n      dnl Set $LUA to the absolute path of $ax_cv_pathless_LUA.\n      AS_IF([test \"x$ax_cv_pathless_LUA\" = 'xnone'],\n        [LUA=':'],\n        [AC_PATH_PROG([LUA], [$ax_cv_pathless_LUA])])\n      ax_display_LUA=$ax_cv_pathless_LUA\n    ])\n  ])\n\n  AS_IF([test \"x$LUA\" = 'x:'],\n  [ dnl Run any user-specified action, or abort.\n    m4_default([$4], [AC_MSG_ERROR([cannot find suitable Lua interpreter])])\n  ],\n  [ dnl Query Lua for its version number.\n    AC_CACHE_CHECK([for $ax_display_LUA version], [ax_cv_lua_version],\n      [ ax_cv_lua_version=`$LUA -e \"print(_VERSION)\" | \\\n          sed \"s|^Lua \\(.*\\)|\\1|\" | \\\n          grep -E -o \"^@<:@0-9@:>@+\\.@<:@0-9@:>@+\"`\n      ])\n    AS_IF([test \"x$ax_cv_lua_version\" = 'x'],\n      [AC_MSG_ERROR([invalid Lua version number])])\n    AC_SUBST([LUA_VERSION], [$ax_cv_lua_version])\n    AC_SUBST([LUA_SHORT_VERSION], [`echo \"$LUA_VERSION\" | sed 's|\\.||'`])\n\n    dnl The following check is not supported:\n    dnl At times (like when building shared libraries) you may want to know\n    dnl which OS platform Lua thinks this is.\n    AC_CACHE_CHECK([for $ax_display_LUA platform], [ax_cv_lua_platform],\n      [ax_cv_lua_platform=`$LUA -e \"print('unknown')\"`])\n    AC_SUBST([LUA_PLATFORM], [$ax_cv_lua_platform])\n\n    dnl Use the values of $prefix and $exec_prefix for the corresponding\n    dnl values of LUA_PREFIX and LUA_EXEC_PREFIX. These are made distinct\n    dnl variables so they can be overridden if need be. However, the general\n    dnl consensus is that you shouldn't need this ability.\n    AC_SUBST([LUA_PREFIX], ['${prefix}'])\n    AC_SUBST([LUA_EXEC_PREFIX], ['${exec_prefix}'])\n\n    dnl Lua provides no way to query the script directory, and instead\n    dnl provides LUA_PATH. However, we should be able to make a safe educated\n    dnl guess. If the built-in search path contains a directory which is\n    dnl prefixed by $prefix, then we can store scripts there. The first\n    dnl matching path will be used.\n    AC_CACHE_CHECK([for $ax_display_LUA script directory],\n      [ax_cv_lua_luadir],\n      [ AS_IF([test \"x$prefix\" = 'xNONE'],\n          [ax_lua_prefix=$ac_default_prefix],\n          [ax_lua_prefix=$prefix])\n\n        dnl Initialize to the default path.\n        ax_cv_lua_luadir=\"$LUA_PREFIX/share/lua/$LUA_VERSION\"\n\n        dnl Try to find a path with the prefix.\n        _AX_LUA_FND_PRFX_PTH([$LUA], [$ax_lua_prefix], [package.path])\n        AS_IF([test \"x$ax_lua_prefixed_path\" != 'x'],\n        [ dnl Fix the prefix.\n          _ax_strip_prefix=`echo \"$ax_lua_prefix\" | sed 's|.|.|g'`\n          ax_cv_lua_luadir=`echo \"$ax_lua_prefixed_path\" | \\\n            sed \"s,^$_ax_strip_prefix,$LUA_PREFIX,\"`\n        ])\n      ])\n    AC_SUBST([luadir], [$ax_cv_lua_luadir])\n    AC_SUBST([pkgluadir], [\\${luadir}/$PACKAGE])\n\n    dnl Lua provides no way to query the module directory, and instead\n    dnl provides LUA_PATH. However, we should be able to make a safe educated\n    dnl guess. If the built-in search path contains a directory which is\n    dnl prefixed by $exec_prefix, then we can store modules there. The first\n    dnl matching path will be used.\n    AC_CACHE_CHECK([for $ax_display_LUA module directory],\n      [ax_cv_lua_luaexecdir],\n      [ AS_IF([test \"x$exec_prefix\" = 'xNONE'],\n          [ax_lua_exec_prefix=$ax_lua_prefix],\n          [ax_lua_exec_prefix=$exec_prefix])\n\n        dnl Initialize to the default path.\n        ax_cv_lua_luaexecdir=\"$LUA_EXEC_PREFIX/lib/lua/$LUA_VERSION\"\n\n        dnl Try to find a path with the prefix.\n        _AX_LUA_FND_PRFX_PTH([$LUA],\n          [$ax_lua_exec_prefix], [package.cpathd])\n        AS_IF([test \"x$ax_lua_prefixed_path\" != 'x'],\n        [ dnl Fix the prefix.\n          _ax_strip_prefix=`echo \"$ax_lua_exec_prefix\" | sed 's|.|.|g'`\n          ax_cv_lua_luaexecdir=`echo \"$ax_lua_prefixed_path\" | \\\n            sed \"s,^$_ax_strip_prefix,$LUA_EXEC_PREFIX,\"`\n        ])\n      ])\n    AC_SUBST([luaexecdir], [$ax_cv_lua_luaexecdir])\n    AC_SUBST([pkgluaexecdir], [\\${luaexecdir}/$PACKAGE])\n\n    dnl Run any user specified action.\n    $3\n  ])\n])\n\ndnl AX_WITH_LUA is now the same thing as AX_PROG_LUA.\nAC_DEFUN([AX_WITH_LUA],\n[\n  AC_MSG_WARN([[$0 is deprecated, please use AX_PROG_LUA]])\n  AX_PROG_LUA\n])\n\n\ndnl =========================================================================\ndnl _AX_LUA_CHK_IS_INTRP(PROG, [ACTION-IF-TRUE], [ACTION-IF-FALSE])\ndnl =========================================================================\nAC_DEFUN([_AX_LUA_CHK_IS_INTRP],\n[\n  dnl Just print _VERSION because all Lua interpreters have this global.\n  AS_IF([$1 -e \"print('Hello ' .. _VERSION .. '!')\" &>/dev/null],\n    [$2], [$3])\n])\n\n\ndnl =========================================================================\ndnl _AX_LUA_CHK_VER(PROG, MINIMUM-VERSION, [TOO-BIG-VERSION],\ndnl                 [ACTION-IF-TRUE], [ACTION-IF-FALSE])\ndnl =========================================================================\nAC_DEFUN([_AX_LUA_CHK_VER],\n[\n  _ax_test_ver=`$1 -e \"print(_VERSION)\" 2>/dev/null | \\\n    sed \"s|^Lua \\(.*\\)|\\1|\" | grep -E -o \"^@<:@0-9@:>@+\\.@<:@0-9@:>@+\"`\n  AS_IF([test \"x$_ax_test_ver\" = 'x'],\n    [_ax_test_ver='0'])\n  AX_COMPARE_VERSION([$_ax_test_ver], [ge], [$2])\n  m4_if([$3], [], [],\n    [ AS_IF([$ax_compare_version],\n        [AX_COMPARE_VERSION([$_ax_test_ver], [lt], [$3])])\n    ])\n  AS_IF([$ax_compare_version], [$4], [$5])\n])\n\n\ndnl =========================================================================\ndnl _AX_LUA_FND_PRFX_PTH(PROG, PREFIX, LUA-PATH-VARIABLE)\ndnl =========================================================================\nAC_DEFUN([_AX_LUA_FND_PRFX_PTH],\n[\n  dnl Invokes the Lua interpreter PROG to print the path variable\n  dnl LUA-PATH-VARIABLE, usually package.path or package.cpath. Paths are\n  dnl then matched against PREFIX. The first path to begin with PREFIX is set\n  dnl to ax_lua_prefixed_path.\n\n  ax_lua_prefixed_path=''\n  _ax_package_paths=`$1 -e 'print($3)' 2>/dev/null | sed 's|;|\\n|g'`\n  dnl Try the paths in order, looking for the prefix.\n  for _ax_package_path in $_ax_package_paths; do\n    dnl Copy the path, up to the use of a Lua wildcard.\n    _ax_path_parts=`echo \"$_ax_package_path\" | sed 's|/|\\n|g'`\n    _ax_reassembled=''\n    for _ax_path_part in $_ax_path_parts; do\n      echo \"$_ax_path_part\" | grep '\\?' >/dev/null && break\n      _ax_reassembled=\"$_ax_reassembled/$_ax_path_part\"\n    done\n    dnl Check the path against the prefix.\n    _ax_package_path=$_ax_reassembled\n    if echo \"$_ax_package_path\" | grep \"^$2\" >/dev/null; then\n      dnl Found it.\n      ax_lua_prefixed_path=$_ax_package_path\n      break\n    fi\n  done\n])\n\n\ndnl =========================================================================\ndnl AX_LUA_HEADERS([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])\ndnl =========================================================================\nAC_DEFUN([AX_LUA_HEADERS],\n[\n  dnl Check for LUA_VERSION.\n  AC_MSG_CHECKING([if LUA_VERSION is defined])\n  AS_IF([test \"x$LUA_VERSION\" != 'x'],\n    [AC_MSG_RESULT([yes])],\n    [ AC_MSG_RESULT([no])\n      AC_MSG_ERROR([cannot check Lua headers without knowing LUA_VERSION])\n    ])\n\n  dnl Make LUA_INCLUDE a precious variable.\n  AC_ARG_VAR([LUA_INCLUDE], [The Lua includes, e.g. -I/usr/include/lua5.1])\n\n  dnl Some default directories to search.\n  LUA_SHORT_VERSION=`echo \"$LUA_VERSION\" | sed 's|\\.||'`\n  m4_define_default([_AX_LUA_INCLUDE_LIST],\n    [ /usr/include/lua$LUA_VERSION \\\n      /usr/include/lua/$LUA_VERSION \\\n      /usr/include/lua$LUA_SHORT_VERSION \\\n      /usr/local/include/lua$LUA_VERSION \\\n      /usr/local/include/lua-$LUA_VERSION \\\n      /usr/local/include/lua/$LUA_VERSION \\\n      /usr/local/include/lua$LUA_SHORT_VERSION \\\n    ])\n\n  dnl Try to find the headers.\n  _ax_lua_saved_cppflags=$CPPFLAGS\n  CPPFLAGS=\"$CPPFLAGS $LUA_INCLUDE\"\n  AC_CHECK_HEADERS([lua.h lualib.h lauxlib.h luaconf.h])\n  CPPFLAGS=$_ax_lua_saved_cppflags\n\n  dnl Try some other directories if LUA_INCLUDE was not set.\n  AS_IF([test \"x$LUA_INCLUDE\" = 'x' &&\n         test \"x$ac_cv_header_lua_h\" != 'xyes'],\n    [ dnl Try some common include paths.\n      for _ax_include_path in _AX_LUA_INCLUDE_LIST; do\n        test ! -d \"$_ax_include_path\" && continue\n\n        AC_MSG_CHECKING([for Lua headers in])\n        AC_MSG_RESULT([$_ax_include_path])\n\n        AS_UNSET([ac_cv_header_lua_h])\n        AS_UNSET([ac_cv_header_lualib_h])\n        AS_UNSET([ac_cv_header_lauxlib_h])\n        AS_UNSET([ac_cv_header_luaconf_h])\n\n        _ax_lua_saved_cppflags=$CPPFLAGS\n        CPPFLAGS=\"$CPPFLAGS -I$_ax_include_path\"\n        AC_CHECK_HEADERS([lua.h lualib.h lauxlib.h luaconf.h])\n        CPPFLAGS=$_ax_lua_saved_cppflags\n\n        AS_IF([test \"x$ac_cv_header_lua_h\" = 'xyes'],\n          [ LUA_INCLUDE=\"-I$_ax_include_path\"\n            break\n          ])\n      done\n    ])\n\n  AS_IF([test \"x$ac_cv_header_lua_h\" = 'xyes'],\n    [ dnl Make a program to print LUA_VERSION defined in the header.\n      dnl TODO This probably shouldn't be a runtime test.\n\n      AC_CACHE_CHECK([for Lua header version],\n        [ax_cv_lua_header_version],\n        [ _ax_lua_saved_cppflags=$CPPFLAGS\n          CPPFLAGS=\"$CPPFLAGS $LUA_INCLUDE\"\n          AC_RUN_IFELSE(\n            [ AC_LANG_SOURCE([[\n#include <lua.h>\n#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char ** argv)\n{\n  if(argc > 1) printf(\"%s\", LUA_VERSION);\n  exit(EXIT_SUCCESS);\n}\n]])\n            ],\n            [ ax_cv_lua_header_version=`./conftest$EXEEXT p | \\\n                sed \"s|^Lua \\(.*\\)|\\1|\" | \\\n                grep -E -o \"^@<:@0-9@:>@+\\.@<:@0-9@:>@+\"`\n            ],\n            [ax_cv_lua_header_version='unknown'])\n          CPPFLAGS=$_ax_lua_saved_cppflags\n        ])\n\n      dnl Compare this to the previously found LUA_VERSION.\n      AC_MSG_CHECKING([if Lua header version matches $LUA_VERSION])\n      AS_IF([test \"x$ax_cv_lua_header_version\" = \"x$LUA_VERSION\"],\n        [ AC_MSG_RESULT([yes])\n          ax_header_version_match='yes'\n        ],\n        [ AC_MSG_RESULT([no])\n          ax_header_version_match='no'\n        ])\n    ])\n\n  dnl Was LUA_INCLUDE specified?\n  AS_IF([test \"x$ax_header_version_match\" != 'xyes' &&\n         test \"x$LUA_INCLUDE\" != 'x'],\n    [AC_MSG_ERROR([cannot find headers for specified LUA_INCLUDE])])\n\n  dnl Test the final result and run user code.\n  AS_IF([test \"x$ax_header_version_match\" = 'xyes'], [$1],\n    [m4_default([$2], [AC_MSG_ERROR([cannot find Lua includes])])])\n])\n\ndnl AX_LUA_HEADERS_VERSION no longer exists, use AX_LUA_HEADERS.\nAC_DEFUN([AX_LUA_HEADERS_VERSION],\n[\n  AC_MSG_WARN([[$0 is deprecated, please use AX_LUA_HEADERS]])\n])\n\n\ndnl =========================================================================\ndnl AX_LUA_LIBS([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])\ndnl =========================================================================\nAC_DEFUN([AX_LUA_LIBS],\n[\n  dnl TODO Should this macro also check various -L flags?\n\n  dnl Check for LUA_VERSION.\n  AC_MSG_CHECKING([if LUA_VERSION is defined])\n  AS_IF([test \"x$LUA_VERSION\" != 'x'],\n    [AC_MSG_RESULT([yes])],\n    [ AC_MSG_RESULT([no])\n      AC_MSG_ERROR([cannot check Lua libs without knowing LUA_VERSION])\n    ])\n\n  dnl Make LUA_LIB a precious variable.\n  AC_ARG_VAR([LUA_LIB], [The Lua library, e.g. -llua5.1])\n\n  AS_IF([test \"x$LUA_LIB\" != 'x'],\n  [ dnl Check that LUA_LIBS works.\n    _ax_lua_saved_libs=$LIBS\n    LIBS=\"$LIBS $LUA_LIB\"\n    AC_SEARCH_LIBS([lua_load], [],\n      [_ax_found_lua_libs='yes'],\n      [_ax_found_lua_libs='no'])\n    LIBS=$_ax_lua_saved_libs\n\n    dnl Check the result.\n    AS_IF([test \"x$_ax_found_lua_libs\" != 'xyes'],\n      [AC_MSG_ERROR([cannot find libs for specified LUA_LIB])])\n  ],\n  [ dnl First search for extra libs.\n    _ax_lua_extra_libs=''\n\n    _ax_lua_saved_libs=$LIBS\n    LIBS=\"$LIBS $LUA_LIB\"\n    AC_SEARCH_LIBS([exp], [m])\n    AC_SEARCH_LIBS([dlopen], [dl])\n    LIBS=$_ax_lua_saved_libs\n\n    AS_IF([test \"x$ac_cv_search_exp\" != 'xno' &&\n           test \"x$ac_cv_search_exp\" != 'xnone required'],\n      [_ax_lua_extra_libs=\"$_ax_lua_extra_libs $ac_cv_search_exp\"])\n\n    AS_IF([test \"x$ac_cv_search_dlopen\" != 'xno' &&\n           test \"x$ac_cv_search_dlopen\" != 'xnone required'],\n      [_ax_lua_extra_libs=\"$_ax_lua_extra_libs $ac_cv_search_dlopen\"])\n\n    dnl Try to find the Lua libs.\n    _ax_lua_saved_libs=$LIBS\n    LIBS=\"$LIBS $LUA_LIB\"\n    AC_SEARCH_LIBS([lua_load],\n                   [ lua$LUA_VERSION \\\n                     lua$LUA_SHORT_VERSION \\\n                     lua-$LUA_VERSION \\\n                     lua-$LUA_SHORT_VERSION \\\n                     lua],\n                   [_ax_found_lua_libs='yes'],\n                   [_ax_found_lua_libs='no'],\n                   [$_ax_lua_extra_libs])\n    LIBS=$_ax_lua_saved_libs\n\n    AS_IF([test \"x$ac_cv_search_lua_load\" != 'xno' &&\n           test \"x$ac_cv_search_lua_load\" != 'xnone required'],\n      [LUA_LIB=\"$ac_cv_search_lua_load $_ax_lua_extra_libs\"])\n  ])\n\n  dnl Test the result and run user code.\n  AS_IF([test \"x$_ax_found_lua_libs\" = 'xyes'], [$1],\n    [m4_default([$2], [AC_MSG_ERROR([cannot find Lua libs])])])\n])\n\n\ndnl =========================================================================\ndnl AX_LUA_READLINE([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])\ndnl =========================================================================\nAC_DEFUN([AX_LUA_READLINE],\n[\n  AX_LIB_READLINE\n  AS_IF([test \"x$ac_cv_header_readline_readline_h\" != 'x' &&\n         test \"x$ac_cv_header_readline_history_h\" != 'x'],\n    [ LUA_LIBS_CFLAGS=\"-DLUA_USE_READLINE $LUA_LIBS_CFLAGS\"\n      $1\n    ],\n    [$2])\n])\n"
        },
        {
          "name": "ax_python.m4",
          "type": "blob",
          "size": 3.8916015625,
          "content": "# ===========================================================================\n#         http://www.gnu.org/software/autoconf-archive/ax_python.html\n# ===========================================================================\n#\n# SYNOPSIS\n#\n#   AX_PYTHON\n#\n# DESCRIPTION\n#\n#   This macro does a complete Python development environment check.\n#\n#   It recurses through several python versions (from 2.1 to 2.6 in this\n#   version), looking for an executable. When it finds an executable, it\n#   looks to find the header files and library.\n#\n#   It sets PYTHON_BIN to the name of the python executable,\n#   PYTHON_INCLUDE_DIR to the directory holding the header files, and\n#   PYTHON_LIB to the name of the Python library.\n#\n#   This macro calls AC_SUBST on PYTHON_BIN (via AC_CHECK_PROG),\n#   PYTHON_INCLUDE_DIR and PYTHON_LIB.\n#\n# LICENSE\n#\n#   Copyright (c) 2008 Michael Tindal\n#\n#   This program is free software; you can redistribute it and/or modify it\n#   under the terms of the GNU General Public License as published by the\n#   Free Software Foundation; either version 2 of the License, or (at your\n#   option) any later version.\n#\n#   This program is distributed in the hope that it will be useful, but\n#   WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n#   Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License along\n#   with this program. If not, see <http://www.gnu.org/licenses/>.\n#\n#   As a special exception, the respective Autoconf Macro's copyright owner\n#   gives unlimited permission to copy, distribute and modify the configure\n#   scripts that are the output of Autoconf when processing the Macro. You\n#   need not follow the terms of the GNU General Public License when using\n#   or distributing such scripts, even though portions of the text of the\n#   Macro appear in them. The GNU General Public License (GPL) does govern\n#   all other use of the material that constitutes the Autoconf Macro.\n#\n#   This special exception to the GPL applies to versions of the Autoconf\n#   Macro released by the Autoconf Archive. When you make and distribute a\n#   modified version of the Autoconf Macro, you may extend this special\n#   exception to the GPL to apply to your modified version as well.\n\n#serial 14\n\nAC_DEFUN([AX_PYTHON],\n[AC_MSG_CHECKING(for python build information)\nAC_MSG_RESULT([])\nfor python in python3.5 python3.4 python3.3 python3.2 python3.1 python3 python2.7 python2.6 python2 python; do\nAC_CHECK_PROGS(PYTHON_BIN, [$python])\nax_python_bin=$PYTHON_BIN\nif test x$ax_python_bin != x; then\n   AC_CHECK_LIB($ax_python_bin, main, ax_python_lib=$ax_python_bin, ax_python_lib=no)\n   if test x$ax_python_lib == xno; then\n     AC_CHECK_LIB(${ax_python_bin}m, main, ax_python_lib=${ax_python_bin}m, ax_python_lib=no)\n   fi\n   if test x$ax_python_lib == xno; then\n     AC_CHECK_LIB(${ax_python_bin}mu, main, ax_python_lib=${ax_python_bin}mu, ax_python_lib=no)\n   fi\n   if test x$ax_python_lib != xno; then\n     ax_python_header=`$ax_python_bin -c \"from distutils.sysconfig import *; print(get_config_var('CONFINCLUDEPY'))\"`\n     if test x$ax_python_header != x; then\n       break;\n     fi\n   fi\nfi\nunset ac_cv_prog_PYTHON_BIN\nunset PYTHON_BIN\ndone\nif test x$ax_python_bin = x; then\n   ax_python_bin=no\nfi\nif test x$ax_python_header = x; then\n   ax_python_header=no\nfi\nif test x$ax_python_lib = x; then\n   ax_python_lib=no\nfi\n\nAC_MSG_RESULT([  results of the Python check:])\nAC_MSG_RESULT([    Binary:      $ax_python_bin])\nAC_MSG_RESULT([    Library:     $ax_python_lib])\nAC_MSG_RESULT([    Include Dir: $ax_python_header])\n\n\nPYTHON_FOUND=yes\nif test x$ax_python_header != xno; then\n  PYTHON_INCLUDE_DIR=$ax_python_header\n  AC_SUBST(PYTHON_INCLUDE_DIR)\nelse \n  PYTHON_FOUND=no\nfi\n\nif test x$ax_python_lib != xno; then\n  PYTHON_LIB=$ax_python_lib\n  AC_SUBST(PYTHON_LIB)\nelse\n  PYTHON_FOUND=no\nfi\nAC_SUBST(PYTHON_FOUND)\n\n])dnl\n"
        },
        {
          "name": "bootstrap",
          "type": "blob",
          "size": 0.0693359375,
          "content": "#! /bin/sh\n\naclocal \nautoheader\nautomake --gnu --add-missing \nautoconf\n"
        },
        {
          "name": "config.h.in",
          "type": "blob",
          "size": 4.91015625,
          "content": "/* config.h.in.  Generated from configure.ac by autoheader.  */\n\n/* disable extf queries */\n#undef DISABLE_EXTF\n\n/* Use libevent v1 */\n#undef EVENT_V1\n\n/* Use libevent v2 */\n#undef EVENT_V2\n\n/* Define to 1 if you have the `alarm' function. */\n#undef HAVE_ALARM\n\n/* Define to 1 if you have the <arpa/inet.h> header file. */\n#undef HAVE_ARPA_INET_H\n\n/* Define to 1 if you have the `endpwent' function. */\n#undef HAVE_ENDPWENT\n\n/* Define to 1 if you have the <execinfo.h> header file. */\n#undef HAVE_EXECINFO_H\n\n/* Define to 1 if you have the <fcntl.h> header file. */\n#undef HAVE_FCNTL_H\n\n/* Define to 1 if you have the <inttypes.h> header file. */\n#undef HAVE_INTTYPES_H\n\n/* Define to 1 if you have the <lauxlib.h> header file. */\n#undef HAVE_LAUXLIB_H\n\n/* Define to 1 if you have the `config' library (-lconfig). */\n#undef HAVE_LIBCONFIG\n\n/* Define to 1 if you have the `event' library (-levent). */\n#undef HAVE_LIBEVENT\n\n/* Define to 1 if you have the `gcrypt' library (-lgcrypt). */\n#undef HAVE_LIBGCRYPT\n\n/* Define to 1 if you have the `jansson' library (-ljansson). */\n#undef HAVE_LIBJANSSON\n\n/* Define to 1 if you have `z' library (-lz) */\n#undef HAVE_LIBZ\n\n/* Define to 1 if you have the <luaconf.h> header file. */\n#undef HAVE_LUACONF_H\n\n/* Define to 1 if you have the <lualib.h> header file. */\n#undef HAVE_LUALIB_H\n\n/* Define to 1 if you have the <lua.h> header file. */\n#undef HAVE_LUA_H\n\n/* Define to 1 if you have the <mach/mach.h> header file. */\n#undef HAVE_MACH_MACH_H\n\n/* Define to 1 if your system has a GNU libc compatible `malloc' function, and\n   to 0 otherwise. */\n#undef HAVE_MALLOC\n\n/* Define to 1 if you have the <malloc.h> header file. */\n#undef HAVE_MALLOC_H\n\n/* Define to 1 if you have the `memmove' function. */\n#undef HAVE_MEMMOVE\n\n/* Define to 1 if you have the <memory.h> header file. */\n#undef HAVE_MEMORY_H\n\n/* Define to 1 if you have the `memset' function. */\n#undef HAVE_MEMSET\n\n/* Define to 1 if you have the `mkdir' function. */\n#undef HAVE_MKDIR\n\n/* Define to 1 if you have the <netdb.h> header file. */\n#undef HAVE_NETDB_H\n\n/* Define to 1 if you have the <netinet/in.h> header file. */\n#undef HAVE_NETINET_IN_H\n\n/* Define to 1 if your system has a GNU libc compatible `realloc' function,\n   and to 0 otherwise. */\n#undef HAVE_REALLOC\n\n/* Define to 1 if you have the `select' function. */\n#undef HAVE_SELECT\n\n/* Define to 1 if you have the `socket' function. */\n#undef HAVE_SOCKET\n\n/* Define to 1 if you have the <stdint.h> header file. */\n#undef HAVE_STDINT_H\n\n/* Define to 1 if you have the <stdlib.h> header file. */\n#undef HAVE_STDLIB_H\n\n/* Define to 1 if you have the `strdup' function. */\n#undef HAVE_STRDUP\n\n/* Define to 1 if you have the <strings.h> header file. */\n#undef HAVE_STRINGS_H\n\n/* Define to 1 if you have the <string.h> header file. */\n#undef HAVE_STRING_H\n\n/* Define to 1 if you have the `strndup' function. */\n#undef HAVE_STRNDUP\n\n/* Define to 1 if you have the <sys/file.h> header file. */\n#undef HAVE_SYS_FILE_H\n\n/* Define to 1 if you have the <sys/socket.h> header file. */\n#undef HAVE_SYS_SOCKET_H\n\n/* Define to 1 if you have the <sys/stat.h> header file. */\n#undef HAVE_SYS_STAT_H\n\n/* Define to 1 if you have the <sys/types.h> header file. */\n#undef HAVE_SYS_TYPES_H\n\n/* Define to 1 if you have the <termios.h> header file. */\n#undef HAVE_TERMIOS_H\n\n/* Define to 1 if you have the `uname' function. */\n#undef HAVE_UNAME\n\n/* Define to 1 if you have the <unistd.h> header file. */\n#undef HAVE_UNISTD_H\n\n/* Define to 1 if the system has the `__builtin_bswap32' built-in function */\n#undef HAVE___BUILTIN_BSWAP32\n\n/* Define to the address where bug reports for this package should be sent. */\n#undef PACKAGE_BUGREPORT\n\n/* Define to the full name of this package. */\n#undef PACKAGE_NAME\n\n/* Define to the full name and version of this package. */\n#undef PACKAGE_STRING\n\n/* Define to the one symbol short name of this package. */\n#undef PACKAGE_TARNAME\n\n/* Define to the home page for this package. */\n#undef PACKAGE_URL\n\n/* Define to the version of this package. */\n#undef PACKAGE_VERSION\n\n/* Use custom prog name */\n#undef PROG_NAME\n\n/* Define to 1 if you have the ANSI C header files. */\n#undef STDC_HEADERS\n\n/* avoid OpenSSL entirely, use libgcrypt instead (this can't read *.pub files,\n   though.) */\n#undef TGL_AVOID_OPENSSL\n\n/* use json */\n#undef USE_JSON\n\n/* use lua */\n#undef USE_LUA\n\n/* use python */\n#undef USE_PYTHON\n\n/* fixed for correct valgrind work */\n#undef VALGRIND_FIXES\n\n/* Define to `int' if <sys/types.h> doesn't define. */\n#undef gid_t\n\n/* Define to `__inline__' or `__inline' if that's what the C compiler\n   calls it, or to nothing if 'inline' is not supported under any name.  */\n#ifndef __cplusplus\n#undef inline\n#endif\n\n/* Define to rpl_malloc if the replacement function should be used. */\n#undef malloc\n\n/* Define to rpl_realloc if the replacement function should be used. */\n#undef realloc\n\n/* Define to `unsigned int' if <sys/types.h> does not define. */\n#undef size_t\n\n/* Define to `int' if <sys/types.h> doesn't define. */\n#undef uid_t\n"
        },
        {
          "name": "config.sample",
          "type": "blob",
          "size": 0.923828125,
          "content": "# This is an empty config file\n# Feel free to put something here\n\ndefault_profile = \"binlog\";\n\ntest_dc1 = {\n  config_directory = \".telegram/test_dc1\";\n  test = true;\n  msg_num = true;\n};\n\nbinlog = {\n  config_directory = \".telegram/binlog\";\n  test = false;\n  msg_num = true;\n  log_level = 2;\n};\n\nbinlog_mts = {\n  config_directory = \".telegram/binlog_mts\";\n  test = false;\n  msg_num = true;\n  log_level = 2;\n};\n\nmega = {\n  config_directory = \".telegram/mega\";\n  test = false;\n  msg_num = true;\n  log_level = 2;\n};\n\nnew = {\n  config_directory = \".telegram/new\";\n  test = false;\n  msg_num = true;\n};\n\nproduction = {\n  config_directory = \".telegram/production\";\n  test = false;\n  msg_num = true;\n};\n\ntest = {\n  config_directory = \".telegram/test\";\n  test = true;\n  msg_num = true;\n};\n\ntest1 = {\n  config_directory = \".telegram/test1\";\n  msg_num = true;\n};\n\ntest2 = {\n  config_directory = \".telegram/test2\";\n  msg_num = true;\n  pfs_enabled = true;\n};\n\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 229.1982421875,
          "content": "#! /bin/sh\n# Guess values for system-dependent variables and create Makefiles.\n# Generated by GNU Autoconf 2.69 for telegram-cli 1.0.\n#\n#\n# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.\n#\n#\n# This configure script is free software; the Free Software Foundation\n# gives unlimited permission to copy, distribute and modify it.\n## -------------------- ##\n## M4sh Initialization. ##\n## -------------------- ##\n\n# Be more Bourne compatible\nDUALCASE=1; export DUALCASE # for MKS sh\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in #(\n  *posix*) :\n    set -o posix ;; #(\n  *) :\n     ;;\nesac\nfi\n\n\nas_nl='\n'\nexport as_nl\n# Printing a long string crashes Solaris 7 /usr/bin/printf.\nas_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\nas_echo=$as_echo$as_echo$as_echo$as_echo$as_echo\nas_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo\n# Prefer a ksh shell builtin over an external printf program on Solaris,\n# but without wasting forks for bash or zsh.\nif test -z \"$BASH_VERSION$ZSH_VERSION\" \\\n    && (test \"X`print -r -- $as_echo`\" = \"X$as_echo\") 2>/dev/null; then\n  as_echo='print -r --'\n  as_echo_n='print -rn --'\nelif (test \"X`printf %s $as_echo`\" = \"X$as_echo\") 2>/dev/null; then\n  as_echo='printf %s\\n'\n  as_echo_n='printf %s'\nelse\n  if test \"X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`\" = \"X-n $as_echo\"; then\n    as_echo_body='eval /usr/ucb/echo -n \"$1$as_nl\"'\n    as_echo_n='/usr/ucb/echo -n'\n  else\n    as_echo_body='eval expr \"X$1\" : \"X\\\\(.*\\\\)\"'\n    as_echo_n_body='eval\n      arg=$1;\n      case $arg in #(\n      *\"$as_nl\"*)\n\texpr \"X$arg\" : \"X\\\\(.*\\\\)$as_nl\";\n\targ=`expr \"X$arg\" : \".*$as_nl\\\\(.*\\\\)\"`;;\n      esac;\n      expr \"X$arg\" : \"X\\\\(.*\\\\)\" | tr -d \"$as_nl\"\n    '\n    export as_echo_n_body\n    as_echo_n='sh -c $as_echo_n_body as_echo'\n  fi\n  export as_echo_body\n  as_echo='sh -c $as_echo_body as_echo'\nfi\n\n# The user is always right.\nif test \"${PATH_SEPARATOR+set}\" != set; then\n  PATH_SEPARATOR=:\n  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {\n    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||\n      PATH_SEPARATOR=';'\n  }\nfi\n\n\n# IFS\n# We need space, tab and new line, in precisely that order.  Quoting is\n# there to prevent editors from complaining about space-tab.\n# (If _AS_PATH_WALK were called with IFS unset, it would disable word\n# splitting by setting IFS to empty value.)\nIFS=\" \"\"\t$as_nl\"\n\n# Find who we are.  Look in the path if we contain no directory separator.\nas_myself=\ncase $0 in #((\n  *[\\\\/]* ) as_myself=$0 ;;\n  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    test -r \"$as_dir/$0\" && as_myself=$as_dir/$0 && break\n  done\nIFS=$as_save_IFS\n\n     ;;\nesac\n# We did not find ourselves, most probably we were run as `sh COMMAND'\n# in which case we are not to be found in the path.\nif test \"x$as_myself\" = x; then\n  as_myself=$0\nfi\nif test ! -f \"$as_myself\"; then\n  $as_echo \"$as_myself: error: cannot find myself; rerun with an absolute file name\" >&2\n  exit 1\nfi\n\n# Unset variables that we do not need and which cause bugs (e.g. in\n# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the \"|| exit 1\"\n# suppresses any \"Segmentation fault\" message there.  '((' could\n# trigger a bug in pdksh 5.2.14.\nfor as_var in BASH_ENV ENV MAIL MAILPATH\ndo eval test x\\${$as_var+set} = xset \\\n  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :\ndone\nPS1='$ '\nPS2='> '\nPS4='+ '\n\n# NLS nuisances.\nLC_ALL=C\nexport LC_ALL\nLANGUAGE=C\nexport LANGUAGE\n\n# CDPATH.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\n# Use a proper internal environment variable to ensure we don't fall\n  # into an infinite loop, continuously re-executing ourselves.\n  if test x\"${_as_can_reexec}\" != xno && test \"x$CONFIG_SHELL\" != x; then\n    _as_can_reexec=no; export _as_can_reexec;\n    # We cannot yet assume a decent shell, so we have to provide a\n# neutralization value for shells without unset; and this also\n# works around shells that cannot unset nonexistent variables.\n# Preserve -v and -x to the replacement shell.\nBASH_ENV=/dev/null\nENV=/dev/null\n(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV\ncase $- in # ((((\n  *v*x* | *x*v* ) as_opts=-vx ;;\n  *v* ) as_opts=-v ;;\n  *x* ) as_opts=-x ;;\n  * ) as_opts= ;;\nesac\nexec $CONFIG_SHELL $as_opts \"$as_myself\" ${1+\"$@\"}\n# Admittedly, this is quite paranoid, since all the known shells bail\n# out after a failed `exec'.\n$as_echo \"$0: could not re-execute with $CONFIG_SHELL\" >&2\nas_fn_exit 255\n  fi\n  # We don't want this to propagate to other subprocesses.\n          { _as_can_reexec=; unset _as_can_reexec;}\nif test \"x$CONFIG_SHELL\" = x; then\n  as_bourne_compatible=\"if test -n \\\"\\${ZSH_VERSION+set}\\\" && (emulate sh) >/dev/null 2>&1; then :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse\n  case \\`(set -o) 2>/dev/null\\` in #(\n  *posix*) :\n    set -o posix ;; #(\n  *) :\n     ;;\nesac\nfi\n\"\n  as_required=\"as_fn_return () { (exit \\$1); }\nas_fn_success () { as_fn_return 0; }\nas_fn_failure () { as_fn_return 1; }\nas_fn_ret_success () { return 0; }\nas_fn_ret_failure () { return 1; }\n\nexitcode=0\nas_fn_success || { exitcode=1; echo as_fn_success failed.; }\nas_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }\nas_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }\nas_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }\nif ( set x; as_fn_ret_success y && test x = \\\"\\$1\\\" ); then :\n\nelse\n  exitcode=1; echo positional parameters were not saved.\nfi\ntest x\\$exitcode = x0 || exit 1\ntest -x / || exit 1\"\n  as_suggested=\"  as_lineno_1=\";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested\" as_lineno_1a=\\$LINENO\n  as_lineno_2=\";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested\" as_lineno_2a=\\$LINENO\n  eval 'test \\\"x\\$as_lineno_1'\\$as_run'\\\" != \\\"x\\$as_lineno_2'\\$as_run'\\\" &&\n  test \\\"x\\`expr \\$as_lineno_1'\\$as_run' + 1\\`\\\" = \\\"x\\$as_lineno_2'\\$as_run'\\\"' || exit 1\ntest \\$(( 1 + 1 )) = 2 || exit 1\"\n  if (eval \"$as_required\") 2>/dev/null; then :\n  as_have_required=yes\nelse\n  as_have_required=no\nfi\n  if test x$as_have_required = xyes && (eval \"$as_suggested\") 2>/dev/null; then :\n\nelse\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nas_found=false\nfor as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n  as_found=:\n  case $as_dir in #(\n\t /*)\n\t   for as_base in sh bash ksh sh5; do\n\t     # Try only shells that exist, to save several forks.\n\t     as_shell=$as_dir/$as_base\n\t     if { test -f \"$as_shell\" || test -f \"$as_shell.exe\"; } &&\n\t\t    { $as_echo \"$as_bourne_compatible\"\"$as_required\" | as_run=a \"$as_shell\"; } 2>/dev/null; then :\n  CONFIG_SHELL=$as_shell as_have_required=yes\n\t\t   if { $as_echo \"$as_bourne_compatible\"\"$as_suggested\" | as_run=a \"$as_shell\"; } 2>/dev/null; then :\n  break 2\nfi\nfi\n\t   done;;\n       esac\n  as_found=false\ndone\n$as_found || { if { test -f \"$SHELL\" || test -f \"$SHELL.exe\"; } &&\n\t      { $as_echo \"$as_bourne_compatible\"\"$as_required\" | as_run=a \"$SHELL\"; } 2>/dev/null; then :\n  CONFIG_SHELL=$SHELL as_have_required=yes\nfi; }\nIFS=$as_save_IFS\n\n\n      if test \"x$CONFIG_SHELL\" != x; then :\n  export CONFIG_SHELL\n             # We cannot yet assume a decent shell, so we have to provide a\n# neutralization value for shells without unset; and this also\n# works around shells that cannot unset nonexistent variables.\n# Preserve -v and -x to the replacement shell.\nBASH_ENV=/dev/null\nENV=/dev/null\n(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV\ncase $- in # ((((\n  *v*x* | *x*v* ) as_opts=-vx ;;\n  *v* ) as_opts=-v ;;\n  *x* ) as_opts=-x ;;\n  * ) as_opts= ;;\nesac\nexec $CONFIG_SHELL $as_opts \"$as_myself\" ${1+\"$@\"}\n# Admittedly, this is quite paranoid, since all the known shells bail\n# out after a failed `exec'.\n$as_echo \"$0: could not re-execute with $CONFIG_SHELL\" >&2\nexit 255\nfi\n\n    if test x$as_have_required = xno; then :\n  $as_echo \"$0: This script requires a shell more modern than all\"\n  $as_echo \"$0: the shells that I found on your system.\"\n  if test x${ZSH_VERSION+set} = xset ; then\n    $as_echo \"$0: In particular, zsh $ZSH_VERSION has bugs and should\"\n    $as_echo \"$0: be upgraded to zsh 4.3.4 or later.\"\n  else\n    $as_echo \"$0: Please tell bug-autoconf@gnu.org about your system,\n$0: including any error possibly output before this\n$0: message. Then install a modern shell, or manually run\n$0: the script under such a shell if you do have one.\"\n  fi\n  exit 1\nfi\nfi\nfi\nSHELL=${CONFIG_SHELL-/bin/sh}\nexport SHELL\n# Unset more variables known to interfere with behavior of common tools.\nCLICOLOR_FORCE= GREP_OPTIONS=\nunset CLICOLOR_FORCE GREP_OPTIONS\n\n## --------------------- ##\n## M4sh Shell Functions. ##\n## --------------------- ##\n# as_fn_unset VAR\n# ---------------\n# Portably unset VAR.\nas_fn_unset ()\n{\n  { eval $1=; unset $1;}\n}\nas_unset=as_fn_unset\n\n# as_fn_set_status STATUS\n# -----------------------\n# Set $? to STATUS, without forking.\nas_fn_set_status ()\n{\n  return $1\n} # as_fn_set_status\n\n# as_fn_exit STATUS\n# -----------------\n# Exit the shell with STATUS, even in a \"trap 0\" or \"set -e\" context.\nas_fn_exit ()\n{\n  set +e\n  as_fn_set_status $1\n  exit $1\n} # as_fn_exit\n\n# as_fn_mkdir_p\n# -------------\n# Create \"$as_dir\" as a directory, including parents if necessary.\nas_fn_mkdir_p ()\n{\n\n  case $as_dir in #(\n  -*) as_dir=./$as_dir;;\n  esac\n  test -d \"$as_dir\" || eval $as_mkdir_p || {\n    as_dirs=\n    while :; do\n      case $as_dir in #(\n      *\\'*) as_qdir=`$as_echo \"$as_dir\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;; #'(\n      *) as_qdir=$as_dir;;\n      esac\n      as_dirs=\"'$as_qdir' $as_dirs\"\n      as_dir=`$as_dirname -- \"$as_dir\" ||\n$as_expr X\"$as_dir\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)$' \\| \\\n\t X\"$as_dir\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n$as_echo X\"$as_dir\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n      test -d \"$as_dir\" && break\n    done\n    test -z \"$as_dirs\" || eval \"mkdir $as_dirs\"\n  } || test -d \"$as_dir\" || as_fn_error $? \"cannot create directory $as_dir\"\n\n\n} # as_fn_mkdir_p\n\n# as_fn_executable_p FILE\n# -----------------------\n# Test if FILE is an executable regular file.\nas_fn_executable_p ()\n{\n  test -f \"$1\" && test -x \"$1\"\n} # as_fn_executable_p\n# as_fn_append VAR VALUE\n# ----------------------\n# Append the text in VALUE to the end of the definition contained in VAR. Take\n# advantage of any shell optimizations that allow amortized linear growth over\n# repeated appends, instead of the typical quadratic growth present in naive\n# implementations.\nif (eval \"as_var=1; as_var+=2; test x\\$as_var = x12\") 2>/dev/null; then :\n  eval 'as_fn_append ()\n  {\n    eval $1+=\\$2\n  }'\nelse\n  as_fn_append ()\n  {\n    eval $1=\\$$1\\$2\n  }\nfi # as_fn_append\n\n# as_fn_arith ARG...\n# ------------------\n# Perform arithmetic evaluation on the ARGs, and store the result in the\n# global $as_val. Take advantage of shells that can avoid forks. The arguments\n# must be portable across $(()) and expr.\nif (eval \"test \\$(( 1 + 1 )) = 2\") 2>/dev/null; then :\n  eval 'as_fn_arith ()\n  {\n    as_val=$(( $* ))\n  }'\nelse\n  as_fn_arith ()\n  {\n    as_val=`expr \"$@\" || test $? -eq 1`\n  }\nfi # as_fn_arith\n\n\n# as_fn_error STATUS ERROR [LINENO LOG_FD]\n# ----------------------------------------\n# Output \"`basename $0`: error: ERROR\" to stderr. If LINENO and LOG_FD are\n# provided, also output the error to LOG_FD, referencing LINENO. Then exit the\n# script with STATUS, using 1 if that was 0.\nas_fn_error ()\n{\n  as_status=$1; test $as_status -eq 0 && as_status=1\n  if test \"$4\"; then\n    as_lineno=${as_lineno-\"$3\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n    $as_echo \"$as_me:${as_lineno-$LINENO}: error: $2\" >&$4\n  fi\n  $as_echo \"$as_me: error: $2\" >&2\n  as_fn_exit $as_status\n} # as_fn_error\n\nif expr a : '\\(a\\)' >/dev/null 2>&1 &&\n   test \"X`expr 00001 : '.*\\(...\\)'`\" = X001; then\n  as_expr=expr\nelse\n  as_expr=false\nfi\n\nif (basename -- /) >/dev/null 2>&1 && test \"X`basename -- / 2>&1`\" = \"X/\"; then\n  as_basename=basename\nelse\n  as_basename=false\nfi\n\nif (as_dir=`dirname -- /` && test \"X$as_dir\" = X/) >/dev/null 2>&1; then\n  as_dirname=dirname\nelse\n  as_dirname=false\nfi\n\nas_me=`$as_basename -- \"$0\" ||\n$as_expr X/\"$0\" : '.*/\\([^/][^/]*\\)/*$' \\| \\\n\t X\"$0\" : 'X\\(//\\)$' \\| \\\n\t X\"$0\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n$as_echo X/\"$0\" |\n    sed '/^.*\\/\\([^/][^/]*\\)\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n\n# Avoid depending upon Character Ranges.\nas_cr_letters='abcdefghijklmnopqrstuvwxyz'\nas_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nas_cr_Letters=$as_cr_letters$as_cr_LETTERS\nas_cr_digits='0123456789'\nas_cr_alnum=$as_cr_Letters$as_cr_digits\n\n\n  as_lineno_1=$LINENO as_lineno_1a=$LINENO\n  as_lineno_2=$LINENO as_lineno_2a=$LINENO\n  eval 'test \"x$as_lineno_1'$as_run'\" != \"x$as_lineno_2'$as_run'\" &&\n  test \"x`expr $as_lineno_1'$as_run' + 1`\" = \"x$as_lineno_2'$as_run'\"' || {\n  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)\n  sed -n '\n    p\n    /[$]LINENO/=\n  ' <$as_myself |\n    sed '\n      s/[$]LINENO.*/&-/\n      t lineno\n      b\n      :lineno\n      N\n      :loop\n      s/[$]LINENO\\([^'$as_cr_alnum'_].*\\n\\)\\(.*\\)/\\2\\1\\2/\n      t loop\n      s/-\\n.*//\n    ' >$as_me.lineno &&\n  chmod +x \"$as_me.lineno\" ||\n    { $as_echo \"$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell\" >&2; as_fn_exit 1; }\n\n  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have\n  # already done that, so ensure we don't try to do so again and fall\n  # in an infinite loop.  This has already happened in practice.\n  _as_can_reexec=no; export _as_can_reexec\n  # Don't try to exec as it changes $[0], causing all sort of problems\n  # (the dirname of $[0] is not the place where we might find the\n  # original and so on.  Autoconf is especially sensitive to this).\n  . \"./$as_me.lineno\"\n  # Exit status is that of the last command.\n  exit\n}\n\nECHO_C= ECHO_N= ECHO_T=\ncase `echo -n x` in #(((((\n-n*)\n  case `echo 'xy\\c'` in\n  *c*) ECHO_T='\t';;\t# ECHO_T is single tab character.\n  xy)  ECHO_C='\\c';;\n  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null\n       ECHO_T='\t';;\n  esac;;\n*)\n  ECHO_N='-n';;\nesac\n\nrm -f conf$$ conf$$.exe conf$$.file\nif test -d conf$$.dir; then\n  rm -f conf$$.dir/conf$$.file\nelse\n  rm -f conf$$.dir\n  mkdir conf$$.dir 2>/dev/null\nfi\nif (echo >conf$$.file) 2>/dev/null; then\n  if ln -s conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s='ln -s'\n    # ... but there are two gotchas:\n    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.\n    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.\n    # In both cases, we have to default to `cp -pR'.\n    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||\n      as_ln_s='cp -pR'\n  elif ln conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s=ln\n  else\n    as_ln_s='cp -pR'\n  fi\nelse\n  as_ln_s='cp -pR'\nfi\nrm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file\nrmdir conf$$.dir 2>/dev/null\n\nif mkdir -p . 2>/dev/null; then\n  as_mkdir_p='mkdir -p \"$as_dir\"'\nelse\n  test -d ./-p && rmdir ./-p\n  as_mkdir_p=false\nfi\n\nas_test_x='test -x'\nas_executable_p=as_fn_executable_p\n\n# Sed expression to map a string onto a valid CPP name.\nas_tr_cpp=\"eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'\"\n\n# Sed expression to map a string onto a valid variable name.\nas_tr_sh=\"eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'\"\n\n\ntest -n \"$DJDIR\" || exec 7<&0 </dev/null\nexec 6>&1\n\n# Name of the host.\n# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,\n# so uname gets run too.\nac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`\n\n#\n# Initializations.\n#\nac_default_prefix=/usr/local\nac_clean_files=\nac_config_libobj_dir=.\nLIBOBJS=\ncross_compiling=no\nsubdirs=\nMFLAGS=\nMAKEFLAGS=\n\n# Identity of this package.\nPACKAGE_NAME='telegram-cli'\nPACKAGE_TARNAME='telegram-cli'\nPACKAGE_VERSION='1.0'\nPACKAGE_STRING='telegram-cli 1.0'\nPACKAGE_BUGREPORT=''\nPACKAGE_URL=''\n\nac_unique_file=\"config.h.in\"\n# Factoring default headers for most tests.\nac_includes_default=\"\\\n#include <stdio.h>\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#ifdef STDC_HEADERS\n# include <stdlib.h>\n# include <stddef.h>\n#else\n# ifdef HAVE_STDLIB_H\n#  include <stdlib.h>\n# endif\n#endif\n#ifdef HAVE_STRING_H\n# if !defined STDC_HEADERS && defined HAVE_MEMORY_H\n#  include <memory.h>\n# endif\n# include <string.h>\n#endif\n#ifdef HAVE_STRINGS_H\n# include <strings.h>\n#endif\n#ifdef HAVE_INTTYPES_H\n# include <inttypes.h>\n#endif\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\"\n\nac_subst_vars='LTLIBOBJS\nEXTRA_LIBS\nLIBOBJS\nPYTHON_CFLAGS\nPYTHON_LIBS\nPYTHON_FOUND\nPYTHON_LIB\nPYTHON_INCLUDE_DIR\nPYTHON_BIN\nLUA_LIB\nLUA_INCLUDE\npkgluaexecdir\nluaexecdir\npkgluadir\nluadir\nLUA_EXEC_PREFIX\nLUA_PREFIX\nLUA_PLATFORM\nLUA_SHORT_VERSION\nLUA_VERSION\nLUA\nOPENSSL_LDFLAGS\nOPENSSL_LIBS\nOPENSSL_INCLUDES\nPKG_CONFIG\nEGREP\nGREP\nCPP\nOBJEXT\nEXEEXT\nac_ct_CC\nCPPFLAGS\nLDFLAGS\nCFLAGS\nCC\ntarget_alias\nhost_alias\nbuild_alias\nLIBS\nECHO_T\nECHO_N\nECHO_C\nDEFS\nmandir\nlocaledir\nlibdir\npsdir\npdfdir\ndvidir\nhtmldir\ninfodir\ndocdir\noldincludedir\nincludedir\nlocalstatedir\nsharedstatedir\nsysconfdir\ndatadir\ndatarootdir\nlibexecdir\nsbindir\nbindir\nprogram_transform_name\nprefix\nexec_prefix\nPACKAGE_URL\nPACKAGE_BUGREPORT\nPACKAGE_STRING\nPACKAGE_VERSION\nPACKAGE_TARNAME\nPACKAGE_NAME\nPATH_SEPARATOR\nSHELL'\nac_subst_files=''\nac_user_opts='\nenable_option_checking\nenable_openssl\nwith_openssl\nwith_zlib\nenable_libconfig\nenable_extf\nenable_liblua\nenable_python\nenable_json\nwith_progname\nenable_valgrind\n'\n      ac_precious_vars='build_alias\nhost_alias\ntarget_alias\nCC\nCFLAGS\nLDFLAGS\nLIBS\nCPPFLAGS\nCPP\nLUA\nLUA_INCLUDE\nLUA_LIB'\n\n\n# Initialize some variables set by options.\nac_init_help=\nac_init_version=false\nac_unrecognized_opts=\nac_unrecognized_sep=\n# The variables have the same names as the options, with\n# dashes changed to underlines.\ncache_file=/dev/null\nexec_prefix=NONE\nno_create=\nno_recursion=\nprefix=NONE\nprogram_prefix=NONE\nprogram_suffix=NONE\nprogram_transform_name=s,x,x,\nsilent=\nsite=\nsrcdir=\nverbose=\nx_includes=NONE\nx_libraries=NONE\n\n# Installation directory options.\n# These are left unexpanded so users can \"make install exec_prefix=/foo\"\n# and all the variables that are supposed to be based on exec_prefix\n# by default will actually change.\n# Use braces instead of parens because sh, perl, etc. also accept them.\n# (The list follows the same order as the GNU Coding Standards.)\nbindir='${exec_prefix}/bin'\nsbindir='${exec_prefix}/sbin'\nlibexecdir='${exec_prefix}/libexec'\ndatarootdir='${prefix}/share'\ndatadir='${datarootdir}'\nsysconfdir='${prefix}/etc'\nsharedstatedir='${prefix}/com'\nlocalstatedir='${prefix}/var'\nincludedir='${prefix}/include'\noldincludedir='/usr/include'\ndocdir='${datarootdir}/doc/${PACKAGE_TARNAME}'\ninfodir='${datarootdir}/info'\nhtmldir='${docdir}'\ndvidir='${docdir}'\npdfdir='${docdir}'\npsdir='${docdir}'\nlibdir='${exec_prefix}/lib'\nlocaledir='${datarootdir}/locale'\nmandir='${datarootdir}/man'\n\nac_prev=\nac_dashdash=\nfor ac_option\ndo\n  # If the previous option needs an argument, assign it.\n  if test -n \"$ac_prev\"; then\n    eval $ac_prev=\\$ac_option\n    ac_prev=\n    continue\n  fi\n\n  case $ac_option in\n  *=?*) ac_optarg=`expr \"X$ac_option\" : '[^=]*=\\(.*\\)'` ;;\n  *=)   ac_optarg= ;;\n  *)    ac_optarg=yes ;;\n  esac\n\n  # Accept the important Cygnus configure options, so we can diagnose typos.\n\n  case $ac_dashdash$ac_option in\n  --)\n    ac_dashdash=yes ;;\n\n  -bindir | --bindir | --bindi | --bind | --bin | --bi)\n    ac_prev=bindir ;;\n  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)\n    bindir=$ac_optarg ;;\n\n  -build | --build | --buil | --bui | --bu)\n    ac_prev=build_alias ;;\n  -build=* | --build=* | --buil=* | --bui=* | --bu=*)\n    build_alias=$ac_optarg ;;\n\n  -cache-file | --cache-file | --cache-fil | --cache-fi \\\n  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)\n    ac_prev=cache_file ;;\n  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \\\n  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)\n    cache_file=$ac_optarg ;;\n\n  --config-cache | -C)\n    cache_file=config.cache ;;\n\n  -datadir | --datadir | --datadi | --datad)\n    ac_prev=datadir ;;\n  -datadir=* | --datadir=* | --datadi=* | --datad=*)\n    datadir=$ac_optarg ;;\n\n  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \\\n  | --dataroo | --dataro | --datar)\n    ac_prev=datarootdir ;;\n  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \\\n  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)\n    datarootdir=$ac_optarg ;;\n\n  -disable-* | --disable-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*disable-\\(.*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid feature name: $ac_useropt\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`$as_echo \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"enable_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval enable_$ac_useropt=no ;;\n\n  -docdir | --docdir | --docdi | --doc | --do)\n    ac_prev=docdir ;;\n  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)\n    docdir=$ac_optarg ;;\n\n  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)\n    ac_prev=dvidir ;;\n  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)\n    dvidir=$ac_optarg ;;\n\n  -enable-* | --enable-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*enable-\\([^=]*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid feature name: $ac_useropt\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`$as_echo \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"enable_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval enable_$ac_useropt=\\$ac_optarg ;;\n\n  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \\\n  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \\\n  | --exec | --exe | --ex)\n    ac_prev=exec_prefix ;;\n  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \\\n  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \\\n  | --exec=* | --exe=* | --ex=*)\n    exec_prefix=$ac_optarg ;;\n\n  -gas | --gas | --ga | --g)\n    # Obsolete; use --with-gas.\n    with_gas=yes ;;\n\n  -help | --help | --hel | --he | -h)\n    ac_init_help=long ;;\n  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)\n    ac_init_help=recursive ;;\n  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)\n    ac_init_help=short ;;\n\n  -host | --host | --hos | --ho)\n    ac_prev=host_alias ;;\n  -host=* | --host=* | --hos=* | --ho=*)\n    host_alias=$ac_optarg ;;\n\n  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)\n    ac_prev=htmldir ;;\n  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \\\n  | --ht=*)\n    htmldir=$ac_optarg ;;\n\n  -includedir | --includedir | --includedi | --included | --include \\\n  | --includ | --inclu | --incl | --inc)\n    ac_prev=includedir ;;\n  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \\\n  | --includ=* | --inclu=* | --incl=* | --inc=*)\n    includedir=$ac_optarg ;;\n\n  -infodir | --infodir | --infodi | --infod | --info | --inf)\n    ac_prev=infodir ;;\n  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)\n    infodir=$ac_optarg ;;\n\n  -libdir | --libdir | --libdi | --libd)\n    ac_prev=libdir ;;\n  -libdir=* | --libdir=* | --libdi=* | --libd=*)\n    libdir=$ac_optarg ;;\n\n  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \\\n  | --libexe | --libex | --libe)\n    ac_prev=libexecdir ;;\n  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \\\n  | --libexe=* | --libex=* | --libe=*)\n    libexecdir=$ac_optarg ;;\n\n  -localedir | --localedir | --localedi | --localed | --locale)\n    ac_prev=localedir ;;\n  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)\n    localedir=$ac_optarg ;;\n\n  -localstatedir | --localstatedir | --localstatedi | --localstated \\\n  | --localstate | --localstat | --localsta | --localst | --locals)\n    ac_prev=localstatedir ;;\n  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \\\n  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)\n    localstatedir=$ac_optarg ;;\n\n  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)\n    ac_prev=mandir ;;\n  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)\n    mandir=$ac_optarg ;;\n\n  -nfp | --nfp | --nf)\n    # Obsolete; use --without-fp.\n    with_fp=no ;;\n\n  -no-create | --no-create | --no-creat | --no-crea | --no-cre \\\n  | --no-cr | --no-c | -n)\n    no_create=yes ;;\n\n  -no-recursion | --no-recursion | --no-recursio | --no-recursi \\\n  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)\n    no_recursion=yes ;;\n\n  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \\\n  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \\\n  | --oldin | --oldi | --old | --ol | --o)\n    ac_prev=oldincludedir ;;\n  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \\\n  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \\\n  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)\n    oldincludedir=$ac_optarg ;;\n\n  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)\n    ac_prev=prefix ;;\n  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)\n    prefix=$ac_optarg ;;\n\n  -program-prefix | --program-prefix | --program-prefi | --program-pref \\\n  | --program-pre | --program-pr | --program-p)\n    ac_prev=program_prefix ;;\n  -program-prefix=* | --program-prefix=* | --program-prefi=* \\\n  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)\n    program_prefix=$ac_optarg ;;\n\n  -program-suffix | --program-suffix | --program-suffi | --program-suff \\\n  | --program-suf | --program-su | --program-s)\n    ac_prev=program_suffix ;;\n  -program-suffix=* | --program-suffix=* | --program-suffi=* \\\n  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)\n    program_suffix=$ac_optarg ;;\n\n  -program-transform-name | --program-transform-name \\\n  | --program-transform-nam | --program-transform-na \\\n  | --program-transform-n | --program-transform- \\\n  | --program-transform | --program-transfor \\\n  | --program-transfo | --program-transf \\\n  | --program-trans | --program-tran \\\n  | --progr-tra | --program-tr | --program-t)\n    ac_prev=program_transform_name ;;\n  -program-transform-name=* | --program-transform-name=* \\\n  | --program-transform-nam=* | --program-transform-na=* \\\n  | --program-transform-n=* | --program-transform-=* \\\n  | --program-transform=* | --program-transfor=* \\\n  | --program-transfo=* | --program-transf=* \\\n  | --program-trans=* | --program-tran=* \\\n  | --progr-tra=* | --program-tr=* | --program-t=*)\n    program_transform_name=$ac_optarg ;;\n\n  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)\n    ac_prev=pdfdir ;;\n  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)\n    pdfdir=$ac_optarg ;;\n\n  -psdir | --psdir | --psdi | --psd | --ps)\n    ac_prev=psdir ;;\n  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)\n    psdir=$ac_optarg ;;\n\n  -q | -quiet | --quiet | --quie | --qui | --qu | --q \\\n  | -silent | --silent | --silen | --sile | --sil)\n    silent=yes ;;\n\n  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)\n    ac_prev=sbindir ;;\n  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \\\n  | --sbi=* | --sb=*)\n    sbindir=$ac_optarg ;;\n\n  -sharedstatedir | --sharedstatedir | --sharedstatedi \\\n  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \\\n  | --sharedst | --shareds | --shared | --share | --shar \\\n  | --sha | --sh)\n    ac_prev=sharedstatedir ;;\n  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \\\n  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \\\n  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \\\n  | --sha=* | --sh=*)\n    sharedstatedir=$ac_optarg ;;\n\n  -site | --site | --sit)\n    ac_prev=site ;;\n  -site=* | --site=* | --sit=*)\n    site=$ac_optarg ;;\n\n  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)\n    ac_prev=srcdir ;;\n  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)\n    srcdir=$ac_optarg ;;\n\n  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \\\n  | --syscon | --sysco | --sysc | --sys | --sy)\n    ac_prev=sysconfdir ;;\n  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \\\n  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)\n    sysconfdir=$ac_optarg ;;\n\n  -target | --target | --targe | --targ | --tar | --ta | --t)\n    ac_prev=target_alias ;;\n  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)\n    target_alias=$ac_optarg ;;\n\n  -v | -verbose | --verbose | --verbos | --verbo | --verb)\n    verbose=yes ;;\n\n  -version | --version | --versio | --versi | --vers | -V)\n    ac_init_version=: ;;\n\n  -with-* | --with-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*with-\\([^=]*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid package name: $ac_useropt\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`$as_echo \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"with_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval with_$ac_useropt=\\$ac_optarg ;;\n\n  -without-* | --without-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*without-\\(.*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid package name: $ac_useropt\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`$as_echo \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"with_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval with_$ac_useropt=no ;;\n\n  --x)\n    # Obsolete; use --with-x.\n    with_x=yes ;;\n\n  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \\\n  | --x-incl | --x-inc | --x-in | --x-i)\n    ac_prev=x_includes ;;\n  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \\\n  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)\n    x_includes=$ac_optarg ;;\n\n  -x-libraries | --x-libraries | --x-librarie | --x-librari \\\n  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)\n    ac_prev=x_libraries ;;\n  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \\\n  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)\n    x_libraries=$ac_optarg ;;\n\n  -*) as_fn_error $? \"unrecognized option: \\`$ac_option'\nTry \\`$0 --help' for more information\"\n    ;;\n\n  *=*)\n    ac_envvar=`expr \"x$ac_option\" : 'x\\([^=]*\\)='`\n    # Reject names that are not valid shell variable names.\n    case $ac_envvar in #(\n      '' | [0-9]* | *[!_$as_cr_alnum]* )\n      as_fn_error $? \"invalid variable name: \\`$ac_envvar'\" ;;\n    esac\n    eval $ac_envvar=\\$ac_optarg\n    export $ac_envvar ;;\n\n  *)\n    # FIXME: should be removed in autoconf 3.0.\n    $as_echo \"$as_me: WARNING: you should use --build, --host, --target\" >&2\n    expr \"x$ac_option\" : \".*[^-._$as_cr_alnum]\" >/dev/null &&\n      $as_echo \"$as_me: WARNING: invalid host type: $ac_option\" >&2\n    : \"${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}\"\n    ;;\n\n  esac\ndone\n\nif test -n \"$ac_prev\"; then\n  ac_option=--`echo $ac_prev | sed 's/_/-/g'`\n  as_fn_error $? \"missing argument to $ac_option\"\nfi\n\nif test -n \"$ac_unrecognized_opts\"; then\n  case $enable_option_checking in\n    no) ;;\n    fatal) as_fn_error $? \"unrecognized options: $ac_unrecognized_opts\" ;;\n    *)     $as_echo \"$as_me: WARNING: unrecognized options: $ac_unrecognized_opts\" >&2 ;;\n  esac\nfi\n\n# Check all directory arguments for consistency.\nfor ac_var in\texec_prefix prefix bindir sbindir libexecdir datarootdir \\\n\t\tdatadir sysconfdir sharedstatedir localstatedir includedir \\\n\t\toldincludedir docdir infodir htmldir dvidir pdfdir psdir \\\n\t\tlibdir localedir mandir\ndo\n  eval ac_val=\\$$ac_var\n  # Remove trailing slashes.\n  case $ac_val in\n    */ )\n      ac_val=`expr \"X$ac_val\" : 'X\\(.*[^/]\\)' \\| \"X$ac_val\" : 'X\\(.*\\)'`\n      eval $ac_var=\\$ac_val;;\n  esac\n  # Be sure to have absolute directory names.\n  case $ac_val in\n    [\\\\/$]* | ?:[\\\\/]* )  continue;;\n    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;\n  esac\n  as_fn_error $? \"expected an absolute directory name for --$ac_var: $ac_val\"\ndone\n\n# There might be people who depend on the old broken behavior: `$host'\n# used to hold the argument of --host etc.\n# FIXME: To remove some day.\nbuild=$build_alias\nhost=$host_alias\ntarget=$target_alias\n\n# FIXME: To remove some day.\nif test \"x$host_alias\" != x; then\n  if test \"x$build_alias\" = x; then\n    cross_compiling=maybe\n  elif test \"x$build_alias\" != \"x$host_alias\"; then\n    cross_compiling=yes\n  fi\nfi\n\nac_tool_prefix=\ntest -n \"$host_alias\" && ac_tool_prefix=$host_alias-\n\ntest \"$silent\" = yes && exec 6>/dev/null\n\n\nac_pwd=`pwd` && test -n \"$ac_pwd\" &&\nac_ls_di=`ls -di .` &&\nac_pwd_ls_di=`cd \"$ac_pwd\" && ls -di .` ||\n  as_fn_error $? \"working directory cannot be determined\"\ntest \"X$ac_ls_di\" = \"X$ac_pwd_ls_di\" ||\n  as_fn_error $? \"pwd does not report name of working directory\"\n\n\n# Find the source files, if location was not specified.\nif test -z \"$srcdir\"; then\n  ac_srcdir_defaulted=yes\n  # Try the directory containing this script, then the parent directory.\n  ac_confdir=`$as_dirname -- \"$as_myself\" ||\n$as_expr X\"$as_myself\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$as_myself\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$as_myself\" : 'X\\(//\\)$' \\| \\\n\t X\"$as_myself\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n$as_echo X\"$as_myself\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n  srcdir=$ac_confdir\n  if test ! -r \"$srcdir/$ac_unique_file\"; then\n    srcdir=..\n  fi\nelse\n  ac_srcdir_defaulted=no\nfi\nif test ! -r \"$srcdir/$ac_unique_file\"; then\n  test \"$ac_srcdir_defaulted\" = yes && srcdir=\"$ac_confdir or ..\"\n  as_fn_error $? \"cannot find sources ($ac_unique_file) in $srcdir\"\nfi\nac_msg=\"sources are in $srcdir, but \\`cd $srcdir' does not work\"\nac_abs_confdir=`(\n\tcd \"$srcdir\" && test -r \"./$ac_unique_file\" || as_fn_error $? \"$ac_msg\"\n\tpwd)`\n# When building in place, set srcdir=.\nif test \"$ac_abs_confdir\" = \"$ac_pwd\"; then\n  srcdir=.\nfi\n# Remove unnecessary trailing slashes from srcdir.\n# Double slashes in file names in object file debugging info\n# mess up M-x gdb in Emacs.\ncase $srcdir in\n*/) srcdir=`expr \"X$srcdir\" : 'X\\(.*[^/]\\)' \\| \"X$srcdir\" : 'X\\(.*\\)'`;;\nesac\nfor ac_var in $ac_precious_vars; do\n  eval ac_env_${ac_var}_set=\\${${ac_var}+set}\n  eval ac_env_${ac_var}_value=\\$${ac_var}\n  eval ac_cv_env_${ac_var}_set=\\${${ac_var}+set}\n  eval ac_cv_env_${ac_var}_value=\\$${ac_var}\ndone\n\n#\n# Report the --help message.\n#\nif test \"$ac_init_help\" = \"long\"; then\n  # Omit some internal or obsolete options to make the list less imposing.\n  # This message is too long to be a string in the A/UX 3.1 sh.\n  cat <<_ACEOF\n\\`configure' configures telegram-cli 1.0 to adapt to many kinds of systems.\n\nUsage: $0 [OPTION]... [VAR=VALUE]...\n\nTo assign environment variables (e.g., CC, CFLAGS...), specify them as\nVAR=VALUE.  See below for descriptions of some of the useful variables.\n\nDefaults for the options are specified in brackets.\n\nConfiguration:\n  -h, --help              display this help and exit\n      --help=short        display options specific to this package\n      --help=recursive    display the short help of all the included packages\n  -V, --version           display version information and exit\n  -q, --quiet, --silent   do not print \\`checking ...' messages\n      --cache-file=FILE   cache test results in FILE [disabled]\n  -C, --config-cache      alias for \\`--cache-file=config.cache'\n  -n, --no-create         do not create output files\n      --srcdir=DIR        find the sources in DIR [configure dir or \\`..']\n\nInstallation directories:\n  --prefix=PREFIX         install architecture-independent files in PREFIX\n                          [$ac_default_prefix]\n  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX\n                          [PREFIX]\n\nBy default, \\`make install' will install all the files in\n\\`$ac_default_prefix/bin', \\`$ac_default_prefix/lib' etc.  You can specify\nan installation prefix other than \\`$ac_default_prefix' using \\`--prefix',\nfor instance \\`--prefix=\\$HOME'.\n\nFor better control, use the options below.\n\nFine tuning of the installation directories:\n  --bindir=DIR            user executables [EPREFIX/bin]\n  --sbindir=DIR           system admin executables [EPREFIX/sbin]\n  --libexecdir=DIR        program executables [EPREFIX/libexec]\n  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]\n  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]\n  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]\n  --libdir=DIR            object code libraries [EPREFIX/lib]\n  --includedir=DIR        C header files [PREFIX/include]\n  --oldincludedir=DIR     C header files for non-gcc [/usr/include]\n  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]\n  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]\n  --infodir=DIR           info documentation [DATAROOTDIR/info]\n  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]\n  --mandir=DIR            man documentation [DATAROOTDIR/man]\n  --docdir=DIR            documentation root [DATAROOTDIR/doc/telegram-cli]\n  --htmldir=DIR           html documentation [DOCDIR]\n  --dvidir=DIR            dvi documentation [DOCDIR]\n  --pdfdir=DIR            pdf documentation [DOCDIR]\n  --psdir=DIR             ps documentation [DOCDIR]\n_ACEOF\n\n  cat <<\\_ACEOF\n_ACEOF\nfi\n\nif test -n \"$ac_init_help\"; then\n  case $ac_init_help in\n     short | recursive ) echo \"Configuration of telegram-cli 1.0:\";;\n   esac\n  cat <<\\_ACEOF\n\nOptional Features:\n  --disable-option-checking  ignore unrecognized --enable/--with options\n  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)\n  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]\n  --disable-openssl\t  disables OpenSSL, and don't link against it\n\t\t\t  (this can't read *.pub files, though.)\n--enable-libconfig/--disable-libconfig\n--enable-extf/--disable-extf\n--enable-liblua/--disable-liblua\n--enable-python/--disable-python\n--enable-json/--disable-json\n--enable-valgrind/--disable-valgrind\n\nOptional Packages:\n  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]\n  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)\n  --with-openssl=DIR      root of the OpenSSL directory\n  --with-zlib=DIR         root directory path of zlib installation [defaults to\n                          /usr/local or /usr if not found in /usr/local]\n  --without-zlib          to disable zlib usage completely\n--with-progname=<name>\n\nSome influential environment variables:\n  CC          C compiler command\n  CFLAGS      C compiler flags\n  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a\n              nonstandard directory <lib dir>\n  LIBS        libraries to pass to the linker, e.g. -l<library>\n  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if\n              you have headers in a nonstandard directory <include dir>\n  CPP         C preprocessor\n  LUA         The Lua interpreter, e.g. /usr/bin/lua5.1\n  LUA_INCLUDE The Lua includes, e.g. -I/usr/include/lua5.1\n  LUA_LIB     The Lua library, e.g. -llua5.1\n\nUse these variables to override the choices made by `configure' or to help\nit to find libraries and programs with nonstandard names/locations.\n\nReport bugs to the package provider.\n_ACEOF\nac_status=$?\nfi\n\nif test \"$ac_init_help\" = \"recursive\"; then\n  # If there are subdirs, report their specific --help.\n  for ac_dir in : $ac_subdirs_all; do test \"x$ac_dir\" = x: && continue\n    test -d \"$ac_dir\" ||\n      { cd \"$srcdir\" && ac_pwd=`pwd` && srcdir=. && test -d \"$ac_dir\"; } ||\n      continue\n    ac_builddir=.\n\ncase \"$ac_dir\" in\n.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;\n*)\n  ac_dir_suffix=/`$as_echo \"$ac_dir\" | sed 's|^\\.[\\\\/]||'`\n  # A \"..\" for each directory in $ac_dir_suffix.\n  ac_top_builddir_sub=`$as_echo \"$ac_dir_suffix\" | sed 's|/[^\\\\/]*|/..|g;s|/||'`\n  case $ac_top_builddir_sub in\n  \"\") ac_top_builddir_sub=. ac_top_build_prefix= ;;\n  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;\n  esac ;;\nesac\nac_abs_top_builddir=$ac_pwd\nac_abs_builddir=$ac_pwd$ac_dir_suffix\n# for backward compatibility:\nac_top_builddir=$ac_top_build_prefix\n\ncase $srcdir in\n  .)  # We are building in place.\n    ac_srcdir=.\n    ac_top_srcdir=$ac_top_builddir_sub\n    ac_abs_top_srcdir=$ac_pwd ;;\n  [\\\\/]* | ?:[\\\\/]* )  # Absolute name.\n    ac_srcdir=$srcdir$ac_dir_suffix;\n    ac_top_srcdir=$srcdir\n    ac_abs_top_srcdir=$srcdir ;;\n  *) # Relative name.\n    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix\n    ac_top_srcdir=$ac_top_build_prefix$srcdir\n    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;\nesac\nac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix\n\n    cd \"$ac_dir\" || { ac_status=$?; continue; }\n    # Check for guested configure.\n    if test -f \"$ac_srcdir/configure.gnu\"; then\n      echo &&\n      $SHELL \"$ac_srcdir/configure.gnu\" --help=recursive\n    elif test -f \"$ac_srcdir/configure\"; then\n      echo &&\n      $SHELL \"$ac_srcdir/configure\" --help=recursive\n    else\n      $as_echo \"$as_me: WARNING: no configuration information is in $ac_dir\" >&2\n    fi || ac_status=$?\n    cd \"$ac_pwd\" || { ac_status=$?; break; }\n  done\nfi\n\ntest -n \"$ac_init_help\" && exit $ac_status\nif $ac_init_version; then\n  cat <<\\_ACEOF\ntelegram-cli configure 1.0\ngenerated by GNU Autoconf 2.69\n\nCopyright (C) 2012 Free Software Foundation, Inc.\nThis configure script is free software; the Free Software Foundation\ngives unlimited permission to copy, distribute and modify it.\n_ACEOF\n  exit\nfi\n\n## ------------------------ ##\n## Autoconf initialization. ##\n## ------------------------ ##\n\n# ac_fn_c_try_compile LINENO\n# --------------------------\n# Try to compile conftest.$ac_ext, and return whether this succeeded.\nac_fn_c_try_compile ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  rm -f conftest.$ac_objext\n  if { { ac_try=\"$ac_compile\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n$as_echo \"$ac_try_echo\"; } >&5\n  (eval \"$ac_compile\") 2>conftest.err\n  ac_status=$?\n  if test -s conftest.err; then\n    grep -v '^ *+' conftest.err >conftest.er1\n    cat conftest.er1 >&5\n    mv -f conftest.er1 conftest.err\n  fi\n  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; } && {\n\t test -z \"$ac_c_werror_flag\" ||\n\t test ! -s conftest.err\n       } && test -s conftest.$ac_objext; then :\n  ac_retval=0\nelse\n  $as_echo \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n\tac_retval=1\nfi\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n  as_fn_set_status $ac_retval\n\n} # ac_fn_c_try_compile\n\n# ac_fn_c_try_link LINENO\n# -----------------------\n# Try to link conftest.$ac_ext, and return whether this succeeded.\nac_fn_c_try_link ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  rm -f conftest.$ac_objext conftest$ac_exeext\n  if { { ac_try=\"$ac_link\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n$as_echo \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link\") 2>conftest.err\n  ac_status=$?\n  if test -s conftest.err; then\n    grep -v '^ *+' conftest.err >conftest.er1\n    cat conftest.er1 >&5\n    mv -f conftest.er1 conftest.err\n  fi\n  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; } && {\n\t test -z \"$ac_c_werror_flag\" ||\n\t test ! -s conftest.err\n       } && test -s conftest$ac_exeext && {\n\t test \"$cross_compiling\" = yes ||\n\t test -x conftest$ac_exeext\n       }; then :\n  ac_retval=0\nelse\n  $as_echo \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n\tac_retval=1\nfi\n  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information\n  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would\n  # interfere with the next link command; also delete a directory that is\n  # left behind by Apple's compiler.  We do this before executing the actions.\n  rm -rf conftest.dSYM conftest_ipa8_conftest.oo\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n  as_fn_set_status $ac_retval\n\n} # ac_fn_c_try_link\n\n# ac_fn_c_try_cpp LINENO\n# ----------------------\n# Try to preprocess conftest.$ac_ext, and return whether this succeeded.\nac_fn_c_try_cpp ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  if { { ac_try=\"$ac_cpp conftest.$ac_ext\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n$as_echo \"$ac_try_echo\"; } >&5\n  (eval \"$ac_cpp conftest.$ac_ext\") 2>conftest.err\n  ac_status=$?\n  if test -s conftest.err; then\n    grep -v '^ *+' conftest.err >conftest.er1\n    cat conftest.er1 >&5\n    mv -f conftest.er1 conftest.err\n  fi\n  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; } > conftest.i && {\n\t test -z \"$ac_c_preproc_warn_flag$ac_c_werror_flag\" ||\n\t test ! -s conftest.err\n       }; then :\n  ac_retval=0\nelse\n  $as_echo \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n    ac_retval=1\nfi\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n  as_fn_set_status $ac_retval\n\n} # ac_fn_c_try_cpp\n\n# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES\n# -------------------------------------------------------\n# Tests whether HEADER exists, giving a warning if it cannot be compiled using\n# the include files in INCLUDES and setting the cache variable VAR\n# accordingly.\nac_fn_c_check_header_mongrel ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  if eval \\${$3+:} false; then :\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\n$as_echo_n \"checking for $2... \" >&6; }\nif eval \\${$3+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nfi\neval ac_res=\\$$3\n\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n$as_echo \"$ac_res\" >&6; }\nelse\n  # Is the header compilable?\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking $2 usability\" >&5\n$as_echo_n \"checking $2 usability... \" >&6; }\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$4\n#include <$2>\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"; then :\n  ac_header_compiler=yes\nelse\n  ac_header_compiler=no\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler\" >&5\n$as_echo \"$ac_header_compiler\" >&6; }\n\n# Is the header present?\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking $2 presence\" >&5\n$as_echo_n \"checking $2 presence... \" >&6; }\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <$2>\n_ACEOF\nif ac_fn_c_try_cpp \"$LINENO\"; then :\n  ac_header_preproc=yes\nelse\n  ac_header_preproc=no\nfi\nrm -f conftest.err conftest.i conftest.$ac_ext\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc\" >&5\n$as_echo \"$ac_header_preproc\" >&6; }\n\n# So?  What about this header?\ncase $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((\n  yes:no: )\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!\" >&5\n$as_echo \"$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!\" >&2;}\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result\" >&5\n$as_echo \"$as_me: WARNING: $2: proceeding with the compiler's result\" >&2;}\n    ;;\n  no:yes:* )\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled\" >&5\n$as_echo \"$as_me: WARNING: $2: present but cannot be compiled\" >&2;}\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?\" >&5\n$as_echo \"$as_me: WARNING: $2:     check for missing prerequisite headers?\" >&2;}\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation\" >&5\n$as_echo \"$as_me: WARNING: $2: see the Autoconf documentation\" >&2;}\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \\\"Present But Cannot Be Compiled\\\"\" >&5\n$as_echo \"$as_me: WARNING: $2:     section \\\"Present But Cannot Be Compiled\\\"\" >&2;}\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result\" >&5\n$as_echo \"$as_me: WARNING: $2: proceeding with the compiler's result\" >&2;}\n    ;;\nesac\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\n$as_echo_n \"checking for $2... \" >&6; }\nif eval \\${$3+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  eval \"$3=\\$ac_header_compiler\"\nfi\neval ac_res=\\$$3\n\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n$as_echo \"$ac_res\" >&6; }\nfi\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n\n} # ac_fn_c_check_header_mongrel\n\n# ac_fn_c_try_run LINENO\n# ----------------------\n# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes\n# that executables *can* be run.\nac_fn_c_try_run ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  if { { ac_try=\"$ac_link\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n$as_echo \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link\") 2>&5\n  ac_status=$?\n  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'\n  { { case \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n$as_echo \"$ac_try_echo\"; } >&5\n  (eval \"$ac_try\") 2>&5\n  ac_status=$?\n  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }; }; then :\n  ac_retval=0\nelse\n  $as_echo \"$as_me: program exited with status $ac_status\" >&5\n       $as_echo \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n       ac_retval=$ac_status\nfi\n  rm -rf conftest.dSYM conftest_ipa8_conftest.oo\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n  as_fn_set_status $ac_retval\n\n} # ac_fn_c_try_run\n\n# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES\n# -------------------------------------------------------\n# Tests whether HEADER exists and can be compiled using the include files in\n# INCLUDES, setting the cache variable VAR accordingly.\nac_fn_c_check_header_compile ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\n$as_echo_n \"checking for $2... \" >&6; }\nif eval \\${$3+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$4\n#include <$2>\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"; then :\n  eval \"$3=yes\"\nelse\n  eval \"$3=no\"\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\nfi\neval ac_res=\\$$3\n\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n$as_echo \"$ac_res\" >&6; }\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n\n} # ac_fn_c_check_header_compile\n\n# ac_fn_c_check_type LINENO TYPE VAR INCLUDES\n# -------------------------------------------\n# Tests whether TYPE exists after having included INCLUDES, setting cache\n# variable VAR accordingly.\nac_fn_c_check_type ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\n$as_echo_n \"checking for $2... \" >&6; }\nif eval \\${$3+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  eval \"$3=no\"\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$4\nint\nmain ()\n{\nif (sizeof ($2))\n\t return 0;\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"; then :\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$4\nint\nmain ()\n{\nif (sizeof (($2)))\n\t    return 0;\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"; then :\n\nelse\n  eval \"$3=yes\"\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\nfi\neval ac_res=\\$$3\n\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n$as_echo \"$ac_res\" >&6; }\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n\n} # ac_fn_c_check_type\n\n# ac_fn_c_check_func LINENO FUNC VAR\n# ----------------------------------\n# Tests whether FUNC exists, setting the cache variable VAR accordingly\nac_fn_c_check_func ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\n$as_echo_n \"checking for $2... \" >&6; }\nif eval \\${$3+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n/* Define $2 to an innocuous variant, in case <limits.h> declares $2.\n   For example, HP-UX 11i <limits.h> declares gettimeofday.  */\n#define $2 innocuous_$2\n\n/* System header to define __stub macros and hopefully few prototypes,\n    which can conflict with char $2 (); below.\n    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since\n    <limits.h> exists even on freestanding compilers.  */\n\n#ifdef __STDC__\n# include <limits.h>\n#else\n# include <assert.h>\n#endif\n\n#undef $2\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar $2 ();\n/* The GNU C library defines this for functions which it implements\n    to always fail with ENOSYS.  Some functions are actually named\n    something starting with __ and the normal name is an alias.  */\n#if defined __stub_$2 || defined __stub___$2\nchoke me\n#endif\n\nint\nmain ()\n{\nreturn $2 ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"; then :\n  eval \"$3=yes\"\nelse\n  eval \"$3=no\"\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext conftest.$ac_ext\nfi\neval ac_res=\\$$3\n\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n$as_echo \"$ac_res\" >&6; }\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n\n} # ac_fn_c_check_func\ncat >config.log <<_ACEOF\nThis file contains any messages produced by compilers while\nrunning configure, to aid debugging if configure makes a mistake.\n\nIt was created by telegram-cli $as_me 1.0, which was\ngenerated by GNU Autoconf 2.69.  Invocation command line was\n\n  $ $0 $@\n\n_ACEOF\nexec 5>>config.log\n{\ncat <<_ASUNAME\n## --------- ##\n## Platform. ##\n## --------- ##\n\nhostname = `(hostname || uname -n) 2>/dev/null | sed 1q`\nuname -m = `(uname -m) 2>/dev/null || echo unknown`\nuname -r = `(uname -r) 2>/dev/null || echo unknown`\nuname -s = `(uname -s) 2>/dev/null || echo unknown`\nuname -v = `(uname -v) 2>/dev/null || echo unknown`\n\n/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`\n/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`\n\n/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`\n/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`\n/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`\n/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`\n/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`\n/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`\n/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`\n\n_ASUNAME\n\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    $as_echo \"PATH: $as_dir\"\n  done\nIFS=$as_save_IFS\n\n} >&5\n\ncat >&5 <<_ACEOF\n\n\n## ----------- ##\n## Core tests. ##\n## ----------- ##\n\n_ACEOF\n\n\n# Keep a trace of the command line.\n# Strip out --no-create and --no-recursion so they do not pile up.\n# Strip out --silent because we don't want to record it for future runs.\n# Also quote any args containing shell meta-characters.\n# Make two passes to allow for proper duplicate-argument suppression.\nac_configure_args=\nac_configure_args0=\nac_configure_args1=\nac_must_keep_next=false\nfor ac_pass in 1 2\ndo\n  for ac_arg\n  do\n    case $ac_arg in\n    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;\n    -q | -quiet | --quiet | --quie | --qui | --qu | --q \\\n    | -silent | --silent | --silen | --sile | --sil)\n      continue ;;\n    *\\'*)\n      ac_arg=`$as_echo \"$ac_arg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    esac\n    case $ac_pass in\n    1) as_fn_append ac_configure_args0 \" '$ac_arg'\" ;;\n    2)\n      as_fn_append ac_configure_args1 \" '$ac_arg'\"\n      if test $ac_must_keep_next = true; then\n\tac_must_keep_next=false # Got value, back to normal.\n      else\n\tcase $ac_arg in\n\t  *=* | --config-cache | -C | -disable-* | --disable-* \\\n\t  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \\\n\t  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \\\n\t  | -with-* | --with-* | -without-* | --without-* | --x)\n\t    case \"$ac_configure_args0 \" in\n\t      \"$ac_configure_args1\"*\" '$ac_arg' \"* ) continue ;;\n\t    esac\n\t    ;;\n\t  -* ) ac_must_keep_next=true ;;\n\tesac\n      fi\n      as_fn_append ac_configure_args \" '$ac_arg'\"\n      ;;\n    esac\n  done\ndone\n{ ac_configure_args0=; unset ac_configure_args0;}\n{ ac_configure_args1=; unset ac_configure_args1;}\n\n# When interrupted or exit'd, cleanup temporary files, and complete\n# config.log.  We remove comments because anyway the quotes in there\n# would cause problems or look ugly.\n# WARNING: Use '\\'' to represent an apostrophe within the trap.\n# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.\ntrap 'exit_status=$?\n  # Save into config.log some information that might help in debugging.\n  {\n    echo\n\n    $as_echo \"## ---------------- ##\n## Cache variables. ##\n## ---------------- ##\"\n    echo\n    # The following way of writing the cache mishandles newlines in values,\n(\n  for ac_var in `(set) 2>&1 | sed -n '\\''s/^\\([a-zA-Z_][a-zA-Z0-9_]*\\)=.*/\\1/p'\\''`; do\n    eval ac_val=\\$$ac_var\n    case $ac_val in #(\n    *${as_nl}*)\n      case $ac_var in #(\n      *_cv_*) { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline\" >&5\n$as_echo \"$as_me: WARNING: cache variable $ac_var contains a newline\" >&2;} ;;\n      esac\n      case $ac_var in #(\n      _ | IFS | as_nl) ;; #(\n      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(\n      *) { eval $ac_var=; unset $ac_var;} ;;\n      esac ;;\n    esac\n  done\n  (set) 2>&1 |\n    case $as_nl`(ac_space='\\'' '\\''; set) 2>&1` in #(\n    *${as_nl}ac_space=\\ *)\n      sed -n \\\n\t\"s/'\\''/'\\''\\\\\\\\'\\'''\\''/g;\n\t  s/^\\\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\\\)=\\\\(.*\\\\)/\\\\1='\\''\\\\2'\\''/p\"\n      ;; #(\n    *)\n      sed -n \"/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p\"\n      ;;\n    esac |\n    sort\n)\n    echo\n\n    $as_echo \"## ----------------- ##\n## Output variables. ##\n## ----------------- ##\"\n    echo\n    for ac_var in $ac_subst_vars\n    do\n      eval ac_val=\\$$ac_var\n      case $ac_val in\n      *\\'\\''*) ac_val=`$as_echo \"$ac_val\" | sed \"s/'\\''/'\\''\\\\\\\\\\\\\\\\'\\'''\\''/g\"`;;\n      esac\n      $as_echo \"$ac_var='\\''$ac_val'\\''\"\n    done | sort\n    echo\n\n    if test -n \"$ac_subst_files\"; then\n      $as_echo \"## ------------------- ##\n## File substitutions. ##\n## ------------------- ##\"\n      echo\n      for ac_var in $ac_subst_files\n      do\n\teval ac_val=\\$$ac_var\n\tcase $ac_val in\n\t*\\'\\''*) ac_val=`$as_echo \"$ac_val\" | sed \"s/'\\''/'\\''\\\\\\\\\\\\\\\\'\\'''\\''/g\"`;;\n\tesac\n\t$as_echo \"$ac_var='\\''$ac_val'\\''\"\n      done | sort\n      echo\n    fi\n\n    if test -s confdefs.h; then\n      $as_echo \"## ----------- ##\n## confdefs.h. ##\n## ----------- ##\"\n      echo\n      cat confdefs.h\n      echo\n    fi\n    test \"$ac_signal\" != 0 &&\n      $as_echo \"$as_me: caught signal $ac_signal\"\n    $as_echo \"$as_me: exit $exit_status\"\n  } >&5\n  rm -f core *.core core.conftest.* &&\n    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&\n    exit $exit_status\n' 0\nfor ac_signal in 1 2 13 15; do\n  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal\ndone\nac_signal=0\n\n# confdefs.h avoids OS command line length limits that DEFS can exceed.\nrm -f -r conftest* confdefs.h\n\n$as_echo \"/* confdefs.h */\" > confdefs.h\n\n# Predefined preprocessor variables.\n\ncat >>confdefs.h <<_ACEOF\n#define PACKAGE_NAME \"$PACKAGE_NAME\"\n_ACEOF\n\ncat >>confdefs.h <<_ACEOF\n#define PACKAGE_TARNAME \"$PACKAGE_TARNAME\"\n_ACEOF\n\ncat >>confdefs.h <<_ACEOF\n#define PACKAGE_VERSION \"$PACKAGE_VERSION\"\n_ACEOF\n\ncat >>confdefs.h <<_ACEOF\n#define PACKAGE_STRING \"$PACKAGE_STRING\"\n_ACEOF\n\ncat >>confdefs.h <<_ACEOF\n#define PACKAGE_BUGREPORT \"$PACKAGE_BUGREPORT\"\n_ACEOF\n\ncat >>confdefs.h <<_ACEOF\n#define PACKAGE_URL \"$PACKAGE_URL\"\n_ACEOF\n\n\n# Let the site file select an alternate cache file if it wants to.\n# Prefer an explicitly selected file to automatically selected ones.\nac_site_file1=NONE\nac_site_file2=NONE\nif test -n \"$CONFIG_SITE\"; then\n  # We do not want a PATH search for config.site.\n  case $CONFIG_SITE in #((\n    -*)  ac_site_file1=./$CONFIG_SITE;;\n    */*) ac_site_file1=$CONFIG_SITE;;\n    *)   ac_site_file1=./$CONFIG_SITE;;\n  esac\nelif test \"x$prefix\" != xNONE; then\n  ac_site_file1=$prefix/share/config.site\n  ac_site_file2=$prefix/etc/config.site\nelse\n  ac_site_file1=$ac_default_prefix/share/config.site\n  ac_site_file2=$ac_default_prefix/etc/config.site\nfi\nfor ac_site_file in \"$ac_site_file1\" \"$ac_site_file2\"\ndo\n  test \"x$ac_site_file\" = xNONE && continue\n  if test /dev/null != \"$ac_site_file\" && test -r \"$ac_site_file\"; then\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file\" >&5\n$as_echo \"$as_me: loading site script $ac_site_file\" >&6;}\n    sed 's/^/| /' \"$ac_site_file\" >&5\n    . \"$ac_site_file\" \\\n      || { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"failed to load site script $ac_site_file\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\n  fi\ndone\n\nif test -r \"$cache_file\"; then\n  # Some versions of bash will fail to source /dev/null (special files\n  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.\n  if test /dev/null != \"$cache_file\" && test -f \"$cache_file\"; then\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: loading cache $cache_file\" >&5\n$as_echo \"$as_me: loading cache $cache_file\" >&6;}\n    case $cache_file in\n      [\\\\/]* | ?:[\\\\/]* ) . \"$cache_file\";;\n      *)                      . \"./$cache_file\";;\n    esac\n  fi\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: creating cache $cache_file\" >&5\n$as_echo \"$as_me: creating cache $cache_file\" >&6;}\n  >$cache_file\nfi\n\n# Check that the precious variables saved in the cache have kept the same\n# value.\nac_cache_corrupted=false\nfor ac_var in $ac_precious_vars; do\n  eval ac_old_set=\\$ac_cv_env_${ac_var}_set\n  eval ac_new_set=\\$ac_env_${ac_var}_set\n  eval ac_old_val=\\$ac_cv_env_${ac_var}_value\n  eval ac_new_val=\\$ac_env_${ac_var}_value\n  case $ac_old_set,$ac_new_set in\n    set,)\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: error: \\`$ac_var' was set to \\`$ac_old_val' in the previous run\" >&5\n$as_echo \"$as_me: error: \\`$ac_var' was set to \\`$ac_old_val' in the previous run\" >&2;}\n      ac_cache_corrupted=: ;;\n    ,set)\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: error: \\`$ac_var' was not set in the previous run\" >&5\n$as_echo \"$as_me: error: \\`$ac_var' was not set in the previous run\" >&2;}\n      ac_cache_corrupted=: ;;\n    ,);;\n    *)\n      if test \"x$ac_old_val\" != \"x$ac_new_val\"; then\n\t# differences in whitespace do not lead to failure.\n\tac_old_val_w=`echo x $ac_old_val`\n\tac_new_val_w=`echo x $ac_new_val`\n\tif test \"$ac_old_val_w\" != \"$ac_new_val_w\"; then\n\t  { $as_echo \"$as_me:${as_lineno-$LINENO}: error: \\`$ac_var' has changed since the previous run:\" >&5\n$as_echo \"$as_me: error: \\`$ac_var' has changed since the previous run:\" >&2;}\n\t  ac_cache_corrupted=:\n\telse\n\t  { $as_echo \"$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \\`$ac_var' since the previous run:\" >&5\n$as_echo \"$as_me: warning: ignoring whitespace changes in \\`$ac_var' since the previous run:\" >&2;}\n\t  eval $ac_var=\\$ac_old_val\n\tfi\n\t{ $as_echo \"$as_me:${as_lineno-$LINENO}:   former value:  \\`$ac_old_val'\" >&5\n$as_echo \"$as_me:   former value:  \\`$ac_old_val'\" >&2;}\n\t{ $as_echo \"$as_me:${as_lineno-$LINENO}:   current value: \\`$ac_new_val'\" >&5\n$as_echo \"$as_me:   current value: \\`$ac_new_val'\" >&2;}\n      fi;;\n  esac\n  # Pass precious variables to config.status.\n  if test \"$ac_new_set\" = set; then\n    case $ac_new_val in\n    *\\'*) ac_arg=$ac_var=`$as_echo \"$ac_new_val\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    *) ac_arg=$ac_var=$ac_new_val ;;\n    esac\n    case \" $ac_configure_args \" in\n      *\" '$ac_arg' \"*) ;; # Avoid dups.  Use of quotes ensures accuracy.\n      *) as_fn_append ac_configure_args \" '$ac_arg'\" ;;\n    esac\n  fi\ndone\nif $ac_cache_corrupted; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build\" >&5\n$as_echo \"$as_me: error: changes in the environment can compromise the build\" >&2;}\n  as_fn_error $? \"run \\`make distclean' and/or \\`rm $cache_file' and start over\" \"$LINENO\" 5\nfi\n## -------------------- ##\n## Main body of script. ##\n## -------------------- ##\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\n\n\nac_config_headers=\"$ac_config_headers config.h\"\n\n\n# ===========================================================================\n#          http://www.gnu.org/software/autoconf-archive/ax_lua.html\n# ===========================================================================\n#\n# SYNOPSIS\n#\n#   AX_PROG_LUA[([MINIMUM-VERSION], [TOO-BIG-VERSION], [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])]\n#   AX_LUA_HEADERS[([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])]\n#   AX_LUA_LIBS[([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])]\n#   AX_LUA_READLINE[([ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])]\n#\n# DESCRIPTION\n#\n#   Detect a Lua interpreter, optionally specifying a minimum and maximum\n#   version number. Set up important Lua paths, such as the directories in\n#   which to install scripts and modules (shared libraries).\n#\n#   Also detect Lua headers and libraries. The Lua version contained in the\n#   header is checked to match the Lua interpreter version exactly. When\n#   searching for Lua libraries, the version number is used as a suffix.\n#   This is done with the goal of supporting multiple Lua installs (5.1 and\n#   5.2 side-by-side).\n#\n#   A note on compatibility with previous versions: This file has been\n#   mostly rewritten for serial 18. Most developers should be able to use\n#   these macros without needing to modify configure.ac. Care has been taken\n#   to preserve each macro's behavior, but there are some differences:\n#\n#   1) AX_WITH_LUA is deprecated; it now expands to the exact same thing as\n#   AX_PROG_LUA with no arguments.\n#\n#   2) AX_LUA_HEADERS now checks that the version number defined in lua.h\n#   matches the interpreter version. AX_LUA_HEADERS_VERSION is therefore\n#   unnecessary, so it is deprecated and does not expand to anything.\n#\n#   3) The configure flag --with-lua-suffix no longer exists; the user\n#   should instead specify the LUA precious variable on the command line.\n#   See the AX_PROG_LUA description for details.\n#\n#   Please read the macro descriptions below for more information.\n#\n#   This file was inspired by Andrew Dalke's and James Henstridge's\n#   python.m4 and Tom Payne's, Matthieu Moy's, and Reuben Thomas's ax_lua.m4\n#   (serial 17). Basically, this file is a mash-up of those two files. I\n#   like to think it combines the best of the two!\n#\n#   AX_PROG_LUA: Search for the Lua interpreter, and set up important Lua\n#   paths. Adds precious variable LUA, which may contain the path of the Lua\n#   interpreter. If LUA is blank, the user's path is searched for an\n#   suitable interpreter.\n#\n#   If MINIMUM-VERSION is supplied, then only Lua interpreters with a\n#   version number greater or equal to MINIMUM-VERSION will be accepted. If\n#   TOO-BIG- VERSION is also supplied, then only Lua interpreters with a\n#   version number greater or equal to MINIMUM-VERSION and less than\n#   TOO-BIG-VERSION will be accepted.\n#\n#   Version comparisons require the AX_COMPARE_VERSION macro, which is\n#   provided by ax_compare_version.m4 from the Autoconf Archive.\n#\n#   The Lua version number, LUA_VERSION, is found from the interpreter, and\n#   substituted. LUA_PLATFORM is also found, but not currently supported (no\n#   standard representation).\n#\n#   Finally, the macro finds four paths:\n#\n#     luadir             Directory to install Lua scripts.\n#     pkgluadir          $luadir/$PACKAGE\n#     luaexecdir         Directory to install Lua modules.\n#     pkgluaexecdir      $luaexecdir/$PACKAGE\n#\n#   These paths a found based on $prefix, $exec_prefix, Lua's package.path,\n#   and package.cpath. The first path of package.path beginning with $prefix\n#   is selected as luadir. The first path of package.cpath beginning with\n#   $exec_prefix is used as luaexecdir. This should work on all reasonable\n#   Lua installations. If a path cannot be determined, a default path is\n#   used. Of course, the user can override these later when invoking make.\n#\n#     luadir             Default: $prefix/share/lua/$LUA_VERSION\n#     luaexecdir         Default: $exec_prefix/lib/lua/$LUA_VERSION\n#\n#   These directories can be used by Automake as install destinations. The\n#   variable name minus 'dir' needs to be used as a prefix to the\n#   appropriate Automake primary, e.g. lua_SCRIPS or luaexec_LIBRARIES.\n#\n#   If an acceptable Lua interpreter is found, then ACTION-IF-FOUND is\n#   performed, otherwise ACTION-IF-NOT-FOUND is preformed. If ACTION-IF-NOT-\n#   FOUND is blank, then it will default to printing an error. To prevent\n#   the default behavior, give ':' as an action.\n#\n#   AX_LUA_HEADERS: Search for Lua headers. Requires that AX_PROG_LUA be\n#   expanded before this macro. Adds precious variable LUA_INCLUDE, which\n#   may contain Lua specific include flags, e.g. -I/usr/include/lua5.1. If\n#   LUA_INCLUDE is blank, then this macro will attempt to find suitable\n#   flags.\n#\n#   LUA_INCLUDE can be used by Automake to compile Lua modules or\n#   executables with embedded interpreters. The *_CPPFLAGS variables should\n#   be used for this purpose, e.g. myprog_CPPFLAGS = $(LUA_INCLUDE).\n#\n#   This macro searches for the header lua.h (and others). The search is\n#   performed with a combination of CPPFLAGS, CPATH, etc, and LUA_INCLUDE.\n#   If the search is unsuccessful, then some common directories are tried.\n#   If the headers are then found, then LUA_INCLUDE is set accordingly.\n#\n#   The paths automatically searched are:\n#\n#     * /usr/include/luaX.Y\n#     * /usr/include/lua/X.Y\n#     * /usr/include/luaXY\n#     * /usr/local/include/luaX.Y\n#     * /usr/local/include/lua-X.Y\n#     * /usr/local/include/lua/X.Y\n#     * /usr/local/include/luaXY\n#\n#   (Where X.Y is the Lua version number, e.g. 5.1.)\n#\n#   The Lua version number found in the headers is always checked to match\n#   the Lua interpreter's version number. Lua headers with mismatched\n#   version numbers are not accepted.\n#\n#   If headers are found, then ACTION-IF-FOUND is performed, otherwise\n#   ACTION-IF-NOT-FOUND is performed. If ACTION-IF-NOT-FOUND is blank, then\n#   it will default to printing an error. To prevent the default behavior,\n#   set the action to ':'.\n#\n#   AX_LUA_LIBS: Search for Lua libraries. Requires that AX_PROG_LUA be\n#   expanded before this macro. Adds precious variable LUA_LIB, which may\n#   contain Lua specific linker flags, e.g. -llua5.1. If LUA_LIB is blank,\n#   then this macro will attempt to find suitable flags.\n#\n#   LUA_LIB can be used by Automake to link Lua modules or executables with\n#   embedded interpreters. The *_LIBADD and *_LDADD variables should be used\n#   for this purpose, e.g. mymod_LIBADD = $(LUA_LIB).\n#\n#   This macro searches for the Lua library. More technically, it searches\n#   for a library containing the function lua_load. The search is performed\n#   with a combination of LIBS, LIBRARY_PATH, and LUA_LIB.\n#\n#   If the search determines that some linker flags are missing, then those\n#   flags will be added to LUA_LIB.\n#\n#   If libraries are found, then ACTION-IF-FOUND is performed, otherwise\n#   ACTION-IF-NOT-FOUND is performed. If ACTION-IF-NOT-FOUND is blank, then\n#   it will default to printing an error. To prevent the default behavior,\n#   set the action to ':'.\n#\n#   AX_LUA_READLINE: Search for readline headers and libraries. Requires the\n#   AX_LIB_READLINE macro, which is provided by ax_lib_readline.m4 from the\n#   Autoconf Archive.\n#\n#   If a readline compatible library is found, then ACTION-IF-FOUND is\n#   performed, otherwise ACTION-IF-NOT-FOUND is performed.\n#\n# LICENSE\n#\n#   Copyright (c) 2013 Tim Perkins <tprk77@gmail.com>\n#   Copyright (c) 2013 Reuben Thomas <rrt@sc3d.org>\n#\n#   This program is free software: you can redistribute it and/or modify it\n#   under the terms of the GNU General Public License as published by the\n#   Free Software Foundation, either version 3 of the License, or (at your\n#   option) any later version.\n#\n#   This program is distributed in the hope that it will be useful, but\n#   WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n#   Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License along\n#   with this program. If not, see <http://www.gnu.org/licenses/>.\n#\n#   As a special exception, the respective Autoconf Macro's copyright owner\n#   gives unlimited permission to copy, distribute and modify the configure\n#   scripts that are the output of Autoconf when processing the Macro. You\n#   need not follow the terms of the GNU General Public License when using\n#   or distributing such scripts, even though portions of the text of the\n#   Macro appear in them. The GNU General Public License (GPL) does govern\n#   all other use of the material that constitutes the Autoconf Macro.\n#\n#   This special exception to the GPL applies to versions of the Autoconf\n#   Macro released by the Autoconf Archive. When you make and distribute a\n#   modified version of the Autoconf Macro, you may extend this special\n#   exception to the GPL to apply to your modified version as well.\n\n#serial 21\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# ===========================================================================\n#         http://www.gnu.org/software/autoconf-archive/ax_python.html\n# ===========================================================================\n#\n# SYNOPSIS\n#\n#   AX_PYTHON\n#\n# DESCRIPTION\n#\n#   This macro does a complete Python development environment check.\n#\n#   It recurses through several python versions (from 2.1 to 2.6 in this\n#   version), looking for an executable. When it finds an executable, it\n#   looks to find the header files and library.\n#\n#   It sets PYTHON_BIN to the name of the python executable,\n#   PYTHON_INCLUDE_DIR to the directory holding the header files, and\n#   PYTHON_LIB to the name of the Python library.\n#\n#   This macro calls AC_SUBST on PYTHON_BIN (via AC_CHECK_PROG),\n#   PYTHON_INCLUDE_DIR and PYTHON_LIB.\n#\n# LICENSE\n#\n#   Copyright (c) 2008 Michael Tindal\n#\n#   This program is free software; you can redistribute it and/or modify it\n#   under the terms of the GNU General Public License as published by the\n#   Free Software Foundation; either version 2 of the License, or (at your\n#   option) any later version.\n#\n#   This program is distributed in the hope that it will be useful, but\n#   WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n#   Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License along\n#   with this program. If not, see <http://www.gnu.org/licenses/>.\n#\n#   As a special exception, the respective Autoconf Macro's copyright owner\n#   gives unlimited permission to copy, distribute and modify the configure\n#   scripts that are the output of Autoconf when processing the Macro. You\n#   need not follow the terms of the GNU General Public License when using\n#   or distributing such scripts, even though portions of the text of the\n#   Macro appear in them. The GNU General Public License (GPL) does govern\n#   all other use of the material that constitutes the Autoconf Macro.\n#\n#   This special exception to the GPL applies to versions of the Autoconf\n#   Macro released by the Autoconf Archive. When you make and distribute a\n#   modified version of the Autoconf Macro, you may extend this special\n#   exception to the GPL to apply to your modified version as well.\n\n#serial 14\n\n\n# ===========================================================================\n#     http://www.gnu.org/software/autoconf-archive/ax_check_openssl.html\n# ===========================================================================\n#\n# SYNOPSIS\n#\n#   AX_CHECK_OPENSSL([action-if-found[, action-if-not-found]])\n#\n# DESCRIPTION\n#\n#   Look for OpenSSL in a number of default spots, or in a user-selected\n#   spot (via --with-openssl).  Sets\n#\n#     OPENSSL_INCLUDES to the include directives required\n#     OPENSSL_LIBS to the -l directives required\n#     OPENSSL_LDFLAGS to the -L or -R flags required\n#\n#   and calls ACTION-IF-FOUND or ACTION-IF-NOT-FOUND appropriately\n#\n#   This macro sets OPENSSL_INCLUDES such that source files should use the\n#   openssl/ directory in include directives:\n#\n#     #include <openssl/hmac.h>\n#\n# LICENSE\n#\n#   Copyright (c) 2009,2010 Zmanda Inc. <http://www.zmanda.com/>\n#   Copyright (c) 2009,2010 Dustin J. Mitchell <dustin@zmanda.com>\n#\n#   Copying and distribution of this file, with or without modification, are\n#   permitted in any medium without royalty provided the copyright notice\n#   and this notice are preserved. This file is offered as-is, without any\n#   warranty.\n\n#serial 8\n\n# This is what autoupdate's m4 run will expand.  It fires\n# the warning (with _au_warn_XXX), outputs it into the\n# updated configure.ac (with AC_DIAGNOSE), and then outputs\n# the replacement expansion.\n\n\n# This is an auxiliary macro that is also run when\n# autoupdate runs m4.  It simply calls m4_warning, but\n# we need a wrapper so that each warning is emitted only\n# once.  We break the quoting in m4_warning's argument in\n# order to expand this macro's arguments, not AU_DEFUN's.\n\n\n# Finally, this is the expansion that is picked up by\n# autoconf.  It tells the user to run autoupdate, and\n# then outputs the replacement expansion.  We do not care\n# about autoupdate's warning because that contains\n# information on what to do *after* running autoupdate.\n\n\n\n# ===========================================================================\n#       http://www.gnu.org/software/autoconf-archive/ax_check_zlib.html\n# ===========================================================================\n#\n# SYNOPSIS\n#\n#   AX_CHECK_ZLIB([action-if-found], [action-if-not-found])\n#\n# DESCRIPTION\n#\n#   This macro searches for an installed zlib library. If nothing was\n#   specified when calling configure, it searches first in /usr/local and\n#   then in /usr, /opt/local and /sw. If the --with-zlib=DIR is specified,\n#   it will try to find it in DIR/include/zlib.h and DIR/lib/libz.a. If\n#   --without-zlib is specified, the library is not searched at all.\n#\n#   If either the header file (zlib.h) or the library (libz) is not found,\n#   shell commands 'action-if-not-found' is run. If 'action-if-not-found' is\n#   not specified, the configuration exits on error, asking for a valid zlib\n#   installation directory or --without-zlib.\n#\n#   If both header file and library are found, shell commands\n#   'action-if-found' is run. If 'action-if-found' is not specified, the\n#   default action appends '-I${ZLIB_HOME}/include' to CPFLAGS, appends\n#   '-L$ZLIB_HOME}/lib' to LDFLAGS, prepends '-lz' to LIBS, and calls\n#   AC_DEFINE(HAVE_LIBZ). You should use autoheader to include a definition\n#   for this symbol in a config.h file. Sample usage in a C/C++ source is as\n#   follows:\n#\n#     #ifdef HAVE_LIBZ\n#     #include <zlib.h>\n#     #endif /* HAVE_LIBZ */\n#\n# LICENSE\n#\n#   Copyright (c) 2008 Loic Dachary <loic@senga.org>\n#   Copyright (c) 2010 Bastien Chevreux <bach@chevreux.org>\n#\n#   This program is free software; you can redistribute it and/or modify it\n#   under the terms of the GNU General Public License as published by the\n#   Free Software Foundation; either version 2 of the License, or (at your\n#   option) any later version.\n#\n#   This program is distributed in the hope that it will be useful, but\n#   WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n#   Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License along\n#   with this program. If not, see <http://www.gnu.org/licenses/>.\n#\n#   As a special exception, the respective Autoconf Macro's copyright owner\n#   gives unlimited permission to copy, distribute and modify the configure\n#   scripts that are the output of Autoconf when processing the Macro. You\n#   need not follow the terms of the GNU General Public License when using\n#   or distributing such scripts, even though portions of the text of the\n#   Macro appear in them. The GNU General Public License (GPL) does govern\n#   all other use of the material that constitutes the Autoconf Macro.\n#\n#   This special exception to the GPL applies to versions of the Autoconf\n#   Macro released by the Autoconf Archive. When you make and distribute a\n#   modified version of the Autoconf Macro, you may extend this special\n#   exception to the GPL to apply to your modified version as well.\n\n#serial 14\n\n# This is what autoupdate's m4 run will expand.  It fires\n# the warning (with _au_warn_XXX), outputs it into the\n# updated configure.ac (with AC_DIAGNOSE), and then outputs\n# the replacement expansion.\n\n\n# This is an auxiliary macro that is also run when\n# autoupdate runs m4.  It simply calls m4_warning, but\n# we need a wrapper so that each warning is emitted only\n# once.  We break the quoting in m4_warning's argument in\n# order to expand this macro's arguments, not AU_DEFUN's.\n\n\n# Finally, this is the expansion that is picked up by\n# autoconf.  It tells the user to run autoupdate, and\n# then outputs the replacement expansion.  We do not care\n# about autoupdate's warning because that contains\n# information on what to do *after* running autoupdate.\n\n\n\n# ===========================================================================\n#      http://www.gnu.org/software/autoconf-archive/ax_gcc_builtin.html\n# ===========================================================================\n#\n# SYNOPSIS\n#\n#   AX_GCC_BUILTIN(BUILTIN)\n#\n# DESCRIPTION\n#\n#   This macro checks if the compiler supports one of GCC's built-in\n#   functions; many other compilers also provide those same built-ins.\n#\n#   The BUILTIN parameter is the name of the built-in function.\n#\n#   If BUILTIN is supported define HAVE_<BUILTIN>. Keep in mind that since\n#   builtins usually start with two underscores they will be copied over\n#   into the HAVE_<BUILTIN> definition (e.g. HAVE___BUILTIN_EXPECT for\n#   __builtin_expect()).\n#\n#   The macro caches its result in the ax_cv_have_<BUILTIN> variable (e.g.\n#   ax_cv_have___builtin_expect).\n#\n#   The macro currently supports the following built-in functions:\n#\n#    __builtin_assume_aligned\n#    __builtin_bswap32\n#    __builtin_bswap64\n#    __builtin_choose_expr\n#    __builtin___clear_cache\n#    __builtin_clrsb\n#    __builtin_clrsbl\n#    __builtin_clrsbll\n#    __builtin_clz\n#    __builtin_clzl\n#    __builtin_clzll\n#    __builtin_complex\n#    __builtin_constant_p\n#    __builtin_ctz\n#    __builtin_ctzl\n#    __builtin_ctzll\n#    __builtin_expect\n#    __builtin_ffs\n#    __builtin_ffsl\n#    __builtin_ffsll\n#    __builtin_fpclassify\n#    __builtin_huge_val\n#    __builtin_huge_valf\n#    __builtin_huge_vall\n#    __builtin_inf\n#    __builtin_infd128\n#    __builtin_infd32\n#    __builtin_infd64\n#    __builtin_inff\n#    __builtin_infl\n#    __builtin_isinf_sign\n#    __builtin_nan\n#    __builtin_nand128\n#    __builtin_nand32\n#    __builtin_nand64\n#    __builtin_nanf\n#    __builtin_nanl\n#    __builtin_nans\n#    __builtin_nansf\n#    __builtin_nansl\n#    __builtin_object_size\n#    __builtin_parity\n#    __builtin_parityl\n#    __builtin_parityll\n#    __builtin_popcount\n#    __builtin_popcountl\n#    __builtin_popcountll\n#    __builtin_powi\n#    __builtin_powif\n#    __builtin_powil\n#    __builtin_prefetch\n#    __builtin_trap\n#    __builtin_types_compatible_p\n#    __builtin_unreachable\n#\n#   Unsuppored built-ins will be tested with an empty parameter set and the\n#   result of the check might be wrong or meaningless so use with care.\n#\n# LICENSE\n#\n#   Copyright (c) 2013 Gabriele Svelto <gabriele.svelto@gmail.com>\n#\n#   Copying and distribution of this file, with or without modification, are\n#   permitted in any medium without royalty provided the copyright notice\n#   and this notice are preserved.  This file is offered as-is, without any\n#   warranty.\n\n#serial 2\n\n\n\n\n# Checks for programs.\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\nif test -n \"$ac_tool_prefix\"; then\n  # Extract the first word of \"${ac_tool_prefix}gcc\", so it can be a program name with args.\nset dummy ${ac_tool_prefix}gcc; ac_word=$2\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n$as_echo_n \"checking for $ac_word... \" >&6; }\nif ${ac_cv_prog_CC+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"${ac_tool_prefix}gcc\"\n    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\n$as_echo \"$CC\" >&6; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\n\n\nfi\nif test -z \"$ac_cv_prog_CC\"; then\n  ac_ct_CC=$CC\n  # Extract the first word of \"gcc\", so it can be a program name with args.\nset dummy gcc; ac_word=$2\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n$as_echo_n \"checking for $ac_word... \" >&6; }\nif ${ac_cv_prog_ac_ct_CC+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  if test -n \"$ac_ct_CC\"; then\n  ac_cv_prog_ac_ct_CC=\"$ac_ct_CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ac_ct_CC=\"gcc\"\n    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nac_ct_CC=$ac_cv_prog_ac_ct_CC\nif test -n \"$ac_ct_CC\"; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC\" >&5\n$as_echo \"$ac_ct_CC\" >&6; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\n\n  if test \"x$ac_ct_CC\" = x; then\n    CC=\"\"\n  else\n    case $cross_compiling:$ac_tool_warned in\nyes:)\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\n$as_echo \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\nac_tool_warned=yes ;;\nesac\n    CC=$ac_ct_CC\n  fi\nelse\n  CC=\"$ac_cv_prog_CC\"\nfi\n\nif test -z \"$CC\"; then\n          if test -n \"$ac_tool_prefix\"; then\n    # Extract the first word of \"${ac_tool_prefix}cc\", so it can be a program name with args.\nset dummy ${ac_tool_prefix}cc; ac_word=$2\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n$as_echo_n \"checking for $ac_word... \" >&6; }\nif ${ac_cv_prog_CC+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"${ac_tool_prefix}cc\"\n    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\n$as_echo \"$CC\" >&6; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\n\n\n  fi\nfi\nif test -z \"$CC\"; then\n  # Extract the first word of \"cc\", so it can be a program name with args.\nset dummy cc; ac_word=$2\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n$as_echo_n \"checking for $ac_word... \" >&6; }\nif ${ac_cv_prog_CC+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\n  ac_prog_rejected=no\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n    if test \"$as_dir/$ac_word$ac_exec_ext\" = \"/usr/ucb/cc\"; then\n       ac_prog_rejected=yes\n       continue\n     fi\n    ac_cv_prog_CC=\"cc\"\n    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nif test $ac_prog_rejected = yes; then\n  # We found a bogon in the path, so make sure we never use it.\n  set dummy $ac_cv_prog_CC\n  shift\n  if test $# != 0; then\n    # We chose a different compiler from the bogus one.\n    # However, it has the same basename, so the bogon will be chosen\n    # first if we set CC to just the basename; use the full file name.\n    shift\n    ac_cv_prog_CC=\"$as_dir/$ac_word${1+' '}$@\"\n  fi\nfi\nfi\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\n$as_echo \"$CC\" >&6; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\n\n\nfi\nif test -z \"$CC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n  for ac_prog in cl.exe\n  do\n    # Extract the first word of \"$ac_tool_prefix$ac_prog\", so it can be a program name with args.\nset dummy $ac_tool_prefix$ac_prog; ac_word=$2\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n$as_echo_n \"checking for $ac_word... \" >&6; }\nif ${ac_cv_prog_CC+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"$ac_tool_prefix$ac_prog\"\n    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\n$as_echo \"$CC\" >&6; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\n\n\n    test -n \"$CC\" && break\n  done\nfi\nif test -z \"$CC\"; then\n  ac_ct_CC=$CC\n  for ac_prog in cl.exe\ndo\n  # Extract the first word of \"$ac_prog\", so it can be a program name with args.\nset dummy $ac_prog; ac_word=$2\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n$as_echo_n \"checking for $ac_word... \" >&6; }\nif ${ac_cv_prog_ac_ct_CC+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  if test -n \"$ac_ct_CC\"; then\n  ac_cv_prog_ac_ct_CC=\"$ac_ct_CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ac_ct_CC=\"$ac_prog\"\n    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nac_ct_CC=$ac_cv_prog_ac_ct_CC\nif test -n \"$ac_ct_CC\"; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC\" >&5\n$as_echo \"$ac_ct_CC\" >&6; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\n\n\n  test -n \"$ac_ct_CC\" && break\ndone\n\n  if test \"x$ac_ct_CC\" = x; then\n    CC=\"\"\n  else\n    case $cross_compiling:$ac_tool_warned in\nyes:)\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\n$as_echo \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\nac_tool_warned=yes ;;\nesac\n    CC=$ac_ct_CC\n  fi\nfi\n\nfi\n\n\ntest -z \"$CC\" && { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"no acceptable C compiler found in \\$PATH\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\n\n# Provide some information about the compiler.\n$as_echo \"$as_me:${as_lineno-$LINENO}: checking for C compiler version\" >&5\nset X $ac_compile\nac_compiler=$2\nfor ac_option in --version -v -V -qversion; do\n  { { ac_try=\"$ac_compiler $ac_option >&5\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n$as_echo \"$ac_try_echo\"; } >&5\n  (eval \"$ac_compiler $ac_option >&5\") 2>conftest.err\n  ac_status=$?\n  if test -s conftest.err; then\n    sed '10a\\\n... rest of stderr output deleted ...\n         10q' conftest.err >conftest.er1\n    cat conftest.er1 >&5\n  fi\n  rm -f conftest.er1 conftest.err\n  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\ndone\n\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain ()\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nac_clean_files_save=$ac_clean_files\nac_clean_files=\"$ac_clean_files a.out a.out.dSYM a.exe b.out\"\n# Try to create an executable without -o first, disregard a.out.\n# It will help us diagnose broken compilers, and finding out an intuition\n# of exeext.\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether the C compiler works\" >&5\n$as_echo_n \"checking whether the C compiler works... \" >&6; }\nac_link_default=`$as_echo \"$ac_link\" | sed 's/ -o *conftest[^ ]*//'`\n\n# The possible output files:\nac_files=\"a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*\"\n\nac_rmfiles=\nfor ac_file in $ac_files\ndo\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;\n    * ) ac_rmfiles=\"$ac_rmfiles $ac_file\";;\n  esac\ndone\nrm -f $ac_rmfiles\n\nif { { ac_try=\"$ac_link_default\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n$as_echo \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link_default\") 2>&5\n  ac_status=$?\n  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }; then :\n  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.\n# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'\n# in a Makefile.  We should not override ac_cv_exeext if it was cached,\n# so that the user can short-circuit this test for compilers unknown to\n# Autoconf.\nfor ac_file in $ac_files ''\ndo\n  test -f \"$ac_file\" || continue\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )\n\t;;\n    [ab].out )\n\t# We found the default executable, but exeext='' is most\n\t# certainly right.\n\tbreak;;\n    *.* )\n\tif test \"${ac_cv_exeext+set}\" = set && test \"$ac_cv_exeext\" != no;\n\tthen :; else\n\t   ac_cv_exeext=`expr \"$ac_file\" : '[^.]*\\(\\..*\\)'`\n\tfi\n\t# We set ac_cv_exeext here because the later test for it is not\n\t# safe: cross compilers may not add the suffix if given an `-o'\n\t# argument, so we may need to know it at that point already.\n\t# Even if this section looks crufty: it has the advantage of\n\t# actually working.\n\tbreak;;\n    * )\n\tbreak;;\n  esac\ndone\ntest \"$ac_cv_exeext\" = no && ac_cv_exeext=\n\nelse\n  ac_file=''\nfi\nif test -z \"$ac_file\"; then :\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\n$as_echo \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n{ { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error 77 \"C compiler cannot create executables\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n$as_echo \"yes\" >&6; }\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name\" >&5\n$as_echo_n \"checking for C compiler default output file name... \" >&6; }\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_file\" >&5\n$as_echo \"$ac_file\" >&6; }\nac_exeext=$ac_cv_exeext\n\nrm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out\nac_clean_files=$ac_clean_files_save\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for suffix of executables\" >&5\n$as_echo_n \"checking for suffix of executables... \" >&6; }\nif { { ac_try=\"$ac_link\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n$as_echo \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link\") 2>&5\n  ac_status=$?\n  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }; then :\n  # If both `conftest.exe' and `conftest' are `present' (well, observable)\n# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will\n# work properly (i.e., refer to `conftest.exe'), while it won't with\n# `rm'.\nfor ac_file in conftest.exe conftest conftest.*; do\n  test -f \"$ac_file\" || continue\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;\n    *.* ) ac_cv_exeext=`expr \"$ac_file\" : '[^.]*\\(\\..*\\)'`\n\t  break;;\n    * ) break;;\n  esac\ndone\nelse\n  { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"cannot compute suffix of executables: cannot compile and link\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\nfi\nrm -f conftest conftest$ac_cv_exeext\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext\" >&5\n$as_echo \"$ac_cv_exeext\" >&6; }\n\nrm -f conftest.$ac_ext\nEXEEXT=$ac_cv_exeext\nac_exeext=$EXEEXT\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <stdio.h>\nint\nmain ()\n{\nFILE *f = fopen (\"conftest.out\", \"w\");\n return ferror (f) || fclose (f) != 0;\n\n  ;\n  return 0;\n}\n_ACEOF\nac_clean_files=\"$ac_clean_files conftest.out\"\n# Check that the compiler produces executables we can run.  If not, either\n# the compiler is broken, or we cross compile.\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling\" >&5\n$as_echo_n \"checking whether we are cross compiling... \" >&6; }\nif test \"$cross_compiling\" != yes; then\n  { { ac_try=\"$ac_link\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n$as_echo \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link\") 2>&5\n  ac_status=$?\n  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\n  if { ac_try='./conftest$ac_cv_exeext'\n  { { case \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n$as_echo \"$ac_try_echo\"; } >&5\n  (eval \"$ac_try\") 2>&5\n  ac_status=$?\n  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }; }; then\n    cross_compiling=no\n  else\n    if test \"$cross_compiling\" = maybe; then\n\tcross_compiling=yes\n    else\n\t{ { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"cannot run C compiled programs.\nIf you meant to cross compile, use \\`--host'.\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\n    fi\n  fi\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $cross_compiling\" >&5\n$as_echo \"$cross_compiling\" >&6; }\n\nrm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out\nac_clean_files=$ac_clean_files_save\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for suffix of object files\" >&5\n$as_echo_n \"checking for suffix of object files... \" >&6; }\nif ${ac_cv_objext+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain ()\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nrm -f conftest.o conftest.obj\nif { { ac_try=\"$ac_compile\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\n$as_echo \"$ac_try_echo\"; } >&5\n  (eval \"$ac_compile\") 2>&5\n  ac_status=$?\n  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }; then :\n  for ac_file in conftest.o conftest.obj conftest.*; do\n  test -f \"$ac_file\" || continue;\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;\n    *) ac_cv_objext=`expr \"$ac_file\" : '.*\\.\\(.*\\)'`\n       break;;\n  esac\ndone\nelse\n  $as_echo \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n{ { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"cannot compute suffix of object files: cannot compile\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\nfi\nrm -f conftest.$ac_cv_objext conftest.$ac_ext\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext\" >&5\n$as_echo \"$ac_cv_objext\" >&6; }\nOBJEXT=$ac_cv_objext\nac_objext=$OBJEXT\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler\" >&5\n$as_echo_n \"checking whether we are using the GNU C compiler... \" >&6; }\nif ${ac_cv_c_compiler_gnu+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain ()\n{\n#ifndef __GNUC__\n       choke me\n#endif\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"; then :\n  ac_compiler_gnu=yes\nelse\n  ac_compiler_gnu=no\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\nac_cv_c_compiler_gnu=$ac_compiler_gnu\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu\" >&5\n$as_echo \"$ac_cv_c_compiler_gnu\" >&6; }\nif test $ac_compiler_gnu = yes; then\n  GCC=yes\nelse\n  GCC=\nfi\nac_test_CFLAGS=${CFLAGS+set}\nac_save_CFLAGS=$CFLAGS\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g\" >&5\n$as_echo_n \"checking whether $CC accepts -g... \" >&6; }\nif ${ac_cv_prog_cc_g+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_save_c_werror_flag=$ac_c_werror_flag\n   ac_c_werror_flag=yes\n   ac_cv_prog_cc_g=no\n   CFLAGS=\"-g\"\n   cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain ()\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"; then :\n  ac_cv_prog_cc_g=yes\nelse\n  CFLAGS=\"\"\n      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain ()\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"; then :\n\nelse\n  ac_c_werror_flag=$ac_save_c_werror_flag\n\t CFLAGS=\"-g\"\n\t cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain ()\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"; then :\n  ac_cv_prog_cc_g=yes\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n   ac_c_werror_flag=$ac_save_c_werror_flag\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g\" >&5\n$as_echo \"$ac_cv_prog_cc_g\" >&6; }\nif test \"$ac_test_CFLAGS\" = set; then\n  CFLAGS=$ac_save_CFLAGS\nelif test $ac_cv_prog_cc_g = yes; then\n  if test \"$GCC\" = yes; then\n    CFLAGS=\"-g -O2\"\n  else\n    CFLAGS=\"-g\"\n  fi\nelse\n  if test \"$GCC\" = yes; then\n    CFLAGS=\"-O2\"\n  else\n    CFLAGS=\n  fi\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89\" >&5\n$as_echo_n \"checking for $CC option to accept ISO C89... \" >&6; }\nif ${ac_cv_prog_cc_c89+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_cv_prog_cc_c89=no\nac_save_CC=$CC\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <stdarg.h>\n#include <stdio.h>\nstruct stat;\n/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */\nstruct buf { int x; };\nFILE * (*rcsopen) (struct buf *, struct stat *, int);\nstatic char *e (p, i)\n     char **p;\n     int i;\n{\n  return p[i];\n}\nstatic char *f (char * (*g) (char **, int), char **p, ...)\n{\n  char *s;\n  va_list v;\n  va_start (v,p);\n  s = g (p, va_arg (v,int));\n  va_end (v);\n  return s;\n}\n\n/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has\n   function prototypes and stuff, but not '\\xHH' hex character constants.\n   These don't provoke an error unfortunately, instead are silently treated\n   as 'x'.  The following induces an error, until -std is added to get\n   proper ANSI mode.  Curiously '\\x00'!='x' always comes out true, for an\n   array size at least.  It's necessary to write '\\x00'==0 to get something\n   that's true only with -std.  */\nint osf4_cc_array ['\\x00' == 0 ? 1 : -1];\n\n/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters\n   inside strings and character constants.  */\n#define FOO(x) 'x'\nint xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];\n\nint test (int i, double x);\nstruct s1 {int (*f) (int a);};\nstruct s2 {int (*f) (double a);};\nint pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);\nint argc;\nchar **argv;\nint\nmain ()\n{\nreturn f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];\n  ;\n  return 0;\n}\n_ACEOF\nfor ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \\\n\t-Ae \"-Aa -D_HPUX_SOURCE\" \"-Xc -D__EXTENSIONS__\"\ndo\n  CC=\"$ac_save_CC $ac_arg\"\n  if ac_fn_c_try_compile \"$LINENO\"; then :\n  ac_cv_prog_cc_c89=$ac_arg\nfi\nrm -f core conftest.err conftest.$ac_objext\n  test \"x$ac_cv_prog_cc_c89\" != \"xno\" && break\ndone\nrm -f conftest.$ac_ext\nCC=$ac_save_CC\n\nfi\n# AC_CACHE_VAL\ncase \"x$ac_cv_prog_cc_c89\" in\n  x)\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: none needed\" >&5\n$as_echo \"none needed\" >&6; } ;;\n  xno)\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: unsupported\" >&5\n$as_echo \"unsupported\" >&6; } ;;\n  *)\n    CC=\"$CC $ac_cv_prog_cc_c89\"\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89\" >&5\n$as_echo \"$ac_cv_prog_cc_c89\" >&6; } ;;\nesac\nif test \"x$ac_cv_prog_cc_c89\" != xno; then :\n\nfi\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\n\n# BSD locations for headers and libraries from packages, Linux locations for self-compiled stuff.\nCPPFLAGS=\"$CPPFLAGS -I/usr/local/include\"\nLDFLAGS=\"$LDFLAGS -L/usr/local/lib\"\n\n# Checks for libraries.\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for library containing clock_gettime\" >&5\n$as_echo_n \"checking for library containing clock_gettime... \" >&6; }\nif ${ac_cv_search_clock_gettime+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_func_search_save_LIBS=$LIBS\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar clock_gettime ();\nint\nmain ()\n{\nreturn clock_gettime ();\n  ;\n  return 0;\n}\n_ACEOF\nfor ac_lib in '' rt; do\n  if test -z \"$ac_lib\"; then\n    ac_res=\"none required\"\n  else\n    ac_res=-l$ac_lib\n    LIBS=\"-l$ac_lib  $ac_func_search_save_LIBS\"\n  fi\n  if ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_search_clock_gettime=$ac_res\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext\n  if ${ac_cv_search_clock_gettime+:} false; then :\n  break\nfi\ndone\nif ${ac_cv_search_clock_gettime+:} false; then :\n\nelse\n  ac_cv_search_clock_gettime=no\nfi\nrm conftest.$ac_ext\nLIBS=$ac_func_search_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_clock_gettime\" >&5\n$as_echo \"$ac_cv_search_clock_gettime\" >&6; }\nac_res=$ac_cv_search_clock_gettime\nif test \"$ac_res\" != no; then :\n  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n\nfi\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for library containing backtrace\" >&5\n$as_echo_n \"checking for library containing backtrace... \" >&6; }\nif ${ac_cv_search_backtrace+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_func_search_save_LIBS=$LIBS\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar backtrace ();\nint\nmain ()\n{\nreturn backtrace ();\n  ;\n  return 0;\n}\n_ACEOF\nfor ac_lib in '' execinfo; do\n  if test -z \"$ac_lib\"; then\n    ac_res=\"none required\"\n  else\n    ac_res=-l$ac_lib\n    LIBS=\"-l$ac_lib  $ac_func_search_save_LIBS\"\n  fi\n  if ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_search_backtrace=$ac_res\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext\n  if ${ac_cv_search_backtrace+:} false; then :\n  break\nfi\ndone\nif ${ac_cv_search_backtrace+:} false; then :\n\nelse\n  ac_cv_search_backtrace=no\nfi\nrm conftest.$ac_ext\nLIBS=$ac_func_search_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_backtrace\" >&5\n$as_echo \"$ac_cv_search_backtrace\" >&6; }\nac_res=$ac_cv_search_backtrace\nif test \"$ac_res\" != no; then :\n  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n\nfi\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for event_base_new in -levent\" >&5\n$as_echo_n \"checking for event_base_new in -levent... \" >&6; }\nif ${ac_cv_lib_event_event_base_new+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_check_lib_save_LIBS=$LIBS\nLIBS=\"-levent  $LIBS\"\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar event_base_new ();\nint\nmain ()\n{\nreturn event_base_new ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_lib_event_event_base_new=yes\nelse\n  ac_cv_lib_event_event_base_new=no\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext conftest.$ac_ext\nLIBS=$ac_check_lib_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_event_event_base_new\" >&5\n$as_echo \"$ac_cv_lib_event_event_base_new\" >&6; }\nif test \"x$ac_cv_lib_event_event_base_new\" = xyes; then :\n  cat >>confdefs.h <<_ACEOF\n#define HAVE_LIBEVENT 1\n_ACEOF\n\n  LIBS=\"-levent $LIBS\"\n\nelse\n  as_fn_error $? \"no libevent found\" \"$LINENO\" 5\nfi\n\n\nEVENT_VER=\"\"\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor\" >&5\n$as_echo_n \"checking how to run the C preprocessor... \" >&6; }\n# On Suns, sometimes $CPP names a directory.\nif test -n \"$CPP\" && test -d \"$CPP\"; then\n  CPP=\nfi\nif test -z \"$CPP\"; then\n  if ${ac_cv_prog_CPP+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n      # Double quotes because CPP needs to be expanded\n    for CPP in \"$CC -E\" \"$CC -E -traditional-cpp\" \"/lib/cpp\"\n    do\n      ac_preproc_ok=false\nfor ac_c_preproc_warn_flag in '' yes\ndo\n  # Use a header file that comes with gcc, so configuring glibc\n  # with a fresh cross-compiler works.\n  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since\n  # <limits.h> exists even on freestanding compilers.\n  # On the NeXT, cc -E runs the code through the compiler's parser,\n  # not just through cpp. \"Syntax error\" is here to catch this case.\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#ifdef __STDC__\n# include <limits.h>\n#else\n# include <assert.h>\n#endif\n\t\t     Syntax error\n_ACEOF\nif ac_fn_c_try_cpp \"$LINENO\"; then :\n\nelse\n  # Broken: fails on valid input.\ncontinue\nfi\nrm -f conftest.err conftest.i conftest.$ac_ext\n\n  # OK, works on sane cases.  Now check whether nonexistent headers\n  # can be detected and how.\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <ac_nonexistent.h>\n_ACEOF\nif ac_fn_c_try_cpp \"$LINENO\"; then :\n  # Broken: success on invalid input.\ncontinue\nelse\n  # Passes both tests.\nac_preproc_ok=:\nbreak\nfi\nrm -f conftest.err conftest.i conftest.$ac_ext\n\ndone\n# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.\nrm -f conftest.i conftest.err conftest.$ac_ext\nif $ac_preproc_ok; then :\n  break\nfi\n\n    done\n    ac_cv_prog_CPP=$CPP\n\nfi\n  CPP=$ac_cv_prog_CPP\nelse\n  ac_cv_prog_CPP=$CPP\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $CPP\" >&5\n$as_echo \"$CPP\" >&6; }\nac_preproc_ok=false\nfor ac_c_preproc_warn_flag in '' yes\ndo\n  # Use a header file that comes with gcc, so configuring glibc\n  # with a fresh cross-compiler works.\n  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since\n  # <limits.h> exists even on freestanding compilers.\n  # On the NeXT, cc -E runs the code through the compiler's parser,\n  # not just through cpp. \"Syntax error\" is here to catch this case.\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#ifdef __STDC__\n# include <limits.h>\n#else\n# include <assert.h>\n#endif\n\t\t     Syntax error\n_ACEOF\nif ac_fn_c_try_cpp \"$LINENO\"; then :\n\nelse\n  # Broken: fails on valid input.\ncontinue\nfi\nrm -f conftest.err conftest.i conftest.$ac_ext\n\n  # OK, works on sane cases.  Now check whether nonexistent headers\n  # can be detected and how.\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <ac_nonexistent.h>\n_ACEOF\nif ac_fn_c_try_cpp \"$LINENO\"; then :\n  # Broken: success on invalid input.\ncontinue\nelse\n  # Passes both tests.\nac_preproc_ok=:\nbreak\nfi\nrm -f conftest.err conftest.i conftest.$ac_ext\n\ndone\n# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.\nrm -f conftest.i conftest.err conftest.$ac_ext\nif $ac_preproc_ok; then :\n\nelse\n  { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"C preprocessor \\\"$CPP\\\" fails sanity check\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\nfi\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e\" >&5\n$as_echo_n \"checking for grep that handles long lines and -e... \" >&6; }\nif ${ac_cv_path_GREP+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  if test -z \"$GREP\"; then\n  ac_path_GREP_found=false\n  # Loop through the user's path and test for each of PROGNAME-LIST\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_prog in grep ggrep; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      ac_path_GREP=\"$as_dir/$ac_prog$ac_exec_ext\"\n      as_fn_executable_p \"$ac_path_GREP\" || continue\n# Check for GNU ac_path_GREP and select it if it is found.\n  # Check for GNU $ac_path_GREP\ncase `\"$ac_path_GREP\" --version 2>&1` in\n*GNU*)\n  ac_cv_path_GREP=\"$ac_path_GREP\" ac_path_GREP_found=:;;\n*)\n  ac_count=0\n  $as_echo_n 0123456789 >\"conftest.in\"\n  while :\n  do\n    cat \"conftest.in\" \"conftest.in\" >\"conftest.tmp\"\n    mv \"conftest.tmp\" \"conftest.in\"\n    cp \"conftest.in\" \"conftest.nl\"\n    $as_echo 'GREP' >> \"conftest.nl\"\n    \"$ac_path_GREP\" -e 'GREP$' -e '-(cannot match)-' < \"conftest.nl\" >\"conftest.out\" 2>/dev/null || break\n    diff \"conftest.out\" \"conftest.nl\" >/dev/null 2>&1 || break\n    as_fn_arith $ac_count + 1 && ac_count=$as_val\n    if test $ac_count -gt ${ac_path_GREP_max-0}; then\n      # Best one so far, save it but keep looking for a better one\n      ac_cv_path_GREP=\"$ac_path_GREP\"\n      ac_path_GREP_max=$ac_count\n    fi\n    # 10*(2^10) chars as input seems more than enough\n    test $ac_count -gt 10 && break\n  done\n  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;\nesac\n\n      $ac_path_GREP_found && break 3\n    done\n  done\n  done\nIFS=$as_save_IFS\n  if test -z \"$ac_cv_path_GREP\"; then\n    as_fn_error $? \"no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin\" \"$LINENO\" 5\n  fi\nelse\n  ac_cv_path_GREP=$GREP\nfi\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP\" >&5\n$as_echo \"$ac_cv_path_GREP\" >&6; }\n GREP=\"$ac_cv_path_GREP\"\n\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for egrep\" >&5\n$as_echo_n \"checking for egrep... \" >&6; }\nif ${ac_cv_path_EGREP+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1\n   then ac_cv_path_EGREP=\"$GREP -E\"\n   else\n     if test -z \"$EGREP\"; then\n  ac_path_EGREP_found=false\n  # Loop through the user's path and test for each of PROGNAME-LIST\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_prog in egrep; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      ac_path_EGREP=\"$as_dir/$ac_prog$ac_exec_ext\"\n      as_fn_executable_p \"$ac_path_EGREP\" || continue\n# Check for GNU ac_path_EGREP and select it if it is found.\n  # Check for GNU $ac_path_EGREP\ncase `\"$ac_path_EGREP\" --version 2>&1` in\n*GNU*)\n  ac_cv_path_EGREP=\"$ac_path_EGREP\" ac_path_EGREP_found=:;;\n*)\n  ac_count=0\n  $as_echo_n 0123456789 >\"conftest.in\"\n  while :\n  do\n    cat \"conftest.in\" \"conftest.in\" >\"conftest.tmp\"\n    mv \"conftest.tmp\" \"conftest.in\"\n    cp \"conftest.in\" \"conftest.nl\"\n    $as_echo 'EGREP' >> \"conftest.nl\"\n    \"$ac_path_EGREP\" 'EGREP$' < \"conftest.nl\" >\"conftest.out\" 2>/dev/null || break\n    diff \"conftest.out\" \"conftest.nl\" >/dev/null 2>&1 || break\n    as_fn_arith $ac_count + 1 && ac_count=$as_val\n    if test $ac_count -gt ${ac_path_EGREP_max-0}; then\n      # Best one so far, save it but keep looking for a better one\n      ac_cv_path_EGREP=\"$ac_path_EGREP\"\n      ac_path_EGREP_max=$ac_count\n    fi\n    # 10*(2^10) chars as input seems more than enough\n    test $ac_count -gt 10 && break\n  done\n  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;\nesac\n\n      $ac_path_EGREP_found && break 3\n    done\n  done\n  done\nIFS=$as_save_IFS\n  if test -z \"$ac_cv_path_EGREP\"; then\n    as_fn_error $? \"no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin\" \"$LINENO\" 5\n  fi\nelse\n  ac_cv_path_EGREP=$EGREP\nfi\n\n   fi\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP\" >&5\n$as_echo \"$ac_cv_path_EGREP\" >&6; }\n EGREP=\"$ac_cv_path_EGREP\"\n\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for ANSI C header files\" >&5\n$as_echo_n \"checking for ANSI C header files... \" >&6; }\nif ${ac_cv_header_stdc+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n#include <float.h>\n\nint\nmain ()\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"; then :\n  ac_cv_header_stdc=yes\nelse\n  ac_cv_header_stdc=no\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n\nif test $ac_cv_header_stdc = yes; then\n  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <string.h>\n\n_ACEOF\nif (eval \"$ac_cpp conftest.$ac_ext\") 2>&5 |\n  $EGREP \"memchr\" >/dev/null 2>&1; then :\n\nelse\n  ac_cv_header_stdc=no\nfi\nrm -f conftest*\n\nfi\n\nif test $ac_cv_header_stdc = yes; then\n  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <stdlib.h>\n\n_ACEOF\nif (eval \"$ac_cpp conftest.$ac_ext\") 2>&5 |\n  $EGREP \"free\" >/dev/null 2>&1; then :\n\nelse\n  ac_cv_header_stdc=no\nfi\nrm -f conftest*\n\nfi\n\nif test $ac_cv_header_stdc = yes; then\n  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.\n  if test \"$cross_compiling\" = yes; then :\n  :\nelse\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <ctype.h>\n#include <stdlib.h>\n#if ((' ' & 0x0FF) == 0x020)\n# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')\n# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))\n#else\n# define ISLOWER(c) \\\n\t\t   (('a' <= (c) && (c) <= 'i') \\\n\t\t     || ('j' <= (c) && (c) <= 'r') \\\n\t\t     || ('s' <= (c) && (c) <= 'z'))\n# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))\n#endif\n\n#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))\nint\nmain ()\n{\n  int i;\n  for (i = 0; i < 256; i++)\n    if (XOR (islower (i), ISLOWER (i))\n\t|| toupper (i) != TOUPPER (i))\n      return 2;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_run \"$LINENO\"; then :\n\nelse\n  ac_cv_header_stdc=no\nfi\nrm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n  conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\n\nfi\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc\" >&5\n$as_echo \"$ac_cv_header_stdc\" >&6; }\nif test $ac_cv_header_stdc = yes; then\n\n$as_echo \"#define STDC_HEADERS 1\" >>confdefs.h\n\nfi\n\n# On IRIX 5.3, sys/types and inttypes.h are conflicting.\nfor ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \\\n\t\t  inttypes.h stdint.h unistd.h\ndo :\n  as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\nac_fn_c_check_header_compile \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\n\"\nif eval test \\\"x\\$\"$as_ac_Header\"\\\" = x\"yes\"; then :\n  cat >>confdefs.h <<_ACEOF\n#define `$as_echo \"HAVE_$ac_header\" | $as_tr_cpp` 1\n_ACEOF\n\nfi\n\ndone\n\n\nac_fn_c_check_header_mongrel \"$LINENO\" \"event2/event.h\" \"ac_cv_header_event2_event_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_event2_event_h\" = xyes; then :\n\n$as_echo \"#define EVENT_V2 1\" >>confdefs.h\n\nelse\n\n  ac_fn_c_check_header_mongrel \"$LINENO\" \"event.h\" \"ac_cv_header_event_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_event_h\" = xyes; then :\n\n$as_echo \"#define EVENT_V1 1\" >>confdefs.h\n\nelse\n  as_fn_error $? \"no libevent found\" \"$LINENO\" 5\nfi\n\n\n\nfi\n\n\n\nEXTRA_LIBS=\"\"\n\n#     OPENSSL_INCLUDES to the include directives required\n#     OPENSSL_LIBS to the -l directives required\n#     OPENSSL_LDFLAGS to the -L or -R flags required\n\n# Check whether --enable-openssl was given.\nif test \"${enable_openssl+set}\" = set; then :\n  enableval=$enable_openssl;\n  if test \"x$enableval\" = \"xno\" ; then\n\n$as_echo \"#define TGL_AVOID_OPENSSL 1\" >>confdefs.h\n\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for gcry_mpi_snatch in -lgcrypt\" >&5\n$as_echo_n \"checking for gcry_mpi_snatch in -lgcrypt... \" >&6; }\nif ${ac_cv_lib_gcrypt_gcry_mpi_snatch+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_check_lib_save_LIBS=$LIBS\nLIBS=\"-lgcrypt  $LIBS\"\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar gcry_mpi_snatch ();\nint\nmain ()\n{\nreturn gcry_mpi_snatch ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_lib_gcrypt_gcry_mpi_snatch=yes\nelse\n  ac_cv_lib_gcrypt_gcry_mpi_snatch=no\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext conftest.$ac_ext\nLIBS=$ac_check_lib_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gcrypt_gcry_mpi_snatch\" >&5\n$as_echo \"$ac_cv_lib_gcrypt_gcry_mpi_snatch\" >&6; }\nif test \"x$ac_cv_lib_gcrypt_gcry_mpi_snatch\" = xyes; then :\n  cat >>confdefs.h <<_ACEOF\n#define HAVE_LIBGCRYPT 1\n_ACEOF\n\n  LIBS=\"-lgcrypt $LIBS\"\n\nelse\n  as_fn_error $? \"\\\"Need libgcrypt >= 1.60\\\"\" \"$LINENO\" 5\nfi\n\n  else\n    # Don't be annoying, so don't inform the user about --disable-openssl\n\n    found=false\n\n# Check whether --with-openssl was given.\nif test \"${with_openssl+set}\" = set; then :\n  withval=$with_openssl;\n            case \"$withval\" in\n            \"\" | y | ye | yes | n | no)\n            as_fn_error $? \"Invalid --with-openssl value\" \"$LINENO\" 5\n              ;;\n            *) ssldirs=\"$withval\"\n              ;;\n            esac\n\nelse\n\n            # if pkg-config is installed and openssl has installed a .pc file,\n            # then use that information and don't search ssldirs\n            # Extract the first word of \"pkg-config\", so it can be a program name with args.\nset dummy pkg-config; ac_word=$2\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n$as_echo_n \"checking for $ac_word... \" >&6; }\nif ${ac_cv_path_PKG_CONFIG+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  case $PKG_CONFIG in\n  [\\\\/]* | ?:[\\\\/]*)\n  ac_cv_path_PKG_CONFIG=\"$PKG_CONFIG\" # Let the user override the test with a path.\n  ;;\n  *)\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n    ac_cv_path_PKG_CONFIG=\"$as_dir/$ac_word$ac_exec_ext\"\n    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\n  ;;\nesac\nfi\nPKG_CONFIG=$ac_cv_path_PKG_CONFIG\nif test -n \"$PKG_CONFIG\"; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG\" >&5\n$as_echo \"$PKG_CONFIG\" >&6; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\n\n\n            if test x\"$PKG_CONFIG\" != x\"\"; then\n                OPENSSL_LDFLAGS=`$PKG_CONFIG openssl --libs-only-L 2>/dev/null`\n                if test $? = 0; then\n                    OPENSSL_LIBS=`$PKG_CONFIG openssl --libs-only-l 2>/dev/null`\n                    OPENSSL_INCLUDES=`$PKG_CONFIG openssl --cflags-only-I 2>/dev/null`\n                    found=true\n                fi\n            fi\n\n            # no such luck; use some default ssldirs\n            if ! $found; then\n                ssldirs=\"/usr/local/ssl /usr/lib/ssl /usr/ssl /usr/pkg /usr/local /usr\"\n            fi\n\n\nfi\n\n\n\n    # note that we #include <openssl/foo.h>, so the OpenSSL headers have to be in\n    # an 'openssl' subdirectory\n\n    if ! $found; then\n        OPENSSL_INCLUDES=\n        for ssldir in $ssldirs; do\n            { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for openssl/ssl.h in $ssldir\" >&5\n$as_echo_n \"checking for openssl/ssl.h in $ssldir... \" >&6; }\n            if test -f \"$ssldir/include/openssl/ssl.h\"; then\n                OPENSSL_INCLUDES=\"-I$ssldir/include\"\n                OPENSSL_LDFLAGS=\"-L$ssldir/lib\"\n                OPENSSL_LIBS=\"-lssl -lcrypto\"\n                found=true\n                { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n$as_echo \"yes\" >&6; }\n                break\n            else\n                { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\n            fi\n        done\n\n        # if the file wasn't found, well, go ahead and try the link anyway -- maybe\n        # it will just work!\n    fi\n\n    # try the preprocessor and linker with our new flags,\n    # being careful not to pollute the global LIBS, LDFLAGS, and CPPFLAGS\n\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether compiling and linking against OpenSSL works\" >&5\n$as_echo_n \"checking whether compiling and linking against OpenSSL works... \" >&6; }\n    echo \"Trying link with OPENSSL_LDFLAGS=$OPENSSL_LDFLAGS;\" \\\n        \"OPENSSL_LIBS=$OPENSSL_LIBS; OPENSSL_INCLUDES=$OPENSSL_INCLUDES\" >&5\n\n    save_LIBS=\"$LIBS\"\n    save_LDFLAGS=\"$LDFLAGS\"\n    save_CPPFLAGS=\"$CPPFLAGS\"\n    LDFLAGS=\"$LDFLAGS $OPENSSL_LDFLAGS\"\n    LIBS=\"$OPENSSL_LIBS $LIBS\"\n    CPPFLAGS=\"$OPENSSL_INCLUDES $CPPFLAGS\"\n    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <openssl/ssl.h>\nint\nmain ()\n{\nSSL_new(NULL)\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"; then :\n\n            { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n$as_echo \"yes\" >&6; }\n\n\nelse\n\n            { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\n            as_fn_error $? \"No openssl found.\" \"$LINENO\" 5\n\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext conftest.$ac_ext\n    CPPFLAGS=\"$save_CPPFLAGS\"\n    LDFLAGS=\"$save_LDFLAGS\"\n    LIBS=\"$save_LIBS\"\n\n\n\n\n\n  fi\n\nelse\n\n\n    found=false\n\n# Check whether --with-openssl was given.\nif test \"${with_openssl+set}\" = set; then :\n  withval=$with_openssl;\n            case \"$withval\" in\n            \"\" | y | ye | yes | n | no)\n            as_fn_error $? \"Invalid --with-openssl value\" \"$LINENO\" 5\n              ;;\n            *) ssldirs=\"$withval\"\n              ;;\n            esac\n\nelse\n\n            # if pkg-config is installed and openssl has installed a .pc file,\n            # then use that information and don't search ssldirs\n            # Extract the first word of \"pkg-config\", so it can be a program name with args.\nset dummy pkg-config; ac_word=$2\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n$as_echo_n \"checking for $ac_word... \" >&6; }\nif ${ac_cv_path_PKG_CONFIG+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  case $PKG_CONFIG in\n  [\\\\/]* | ?:[\\\\/]*)\n  ac_cv_path_PKG_CONFIG=\"$PKG_CONFIG\" # Let the user override the test with a path.\n  ;;\n  *)\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n    ac_cv_path_PKG_CONFIG=\"$as_dir/$ac_word$ac_exec_ext\"\n    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\n  ;;\nesac\nfi\nPKG_CONFIG=$ac_cv_path_PKG_CONFIG\nif test -n \"$PKG_CONFIG\"; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG\" >&5\n$as_echo \"$PKG_CONFIG\" >&6; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\n\n\n            if test x\"$PKG_CONFIG\" != x\"\"; then\n                OPENSSL_LDFLAGS=`$PKG_CONFIG openssl --libs-only-L 2>/dev/null`\n                if test $? = 0; then\n                    OPENSSL_LIBS=`$PKG_CONFIG openssl --libs-only-l 2>/dev/null`\n                    OPENSSL_INCLUDES=`$PKG_CONFIG openssl --cflags-only-I 2>/dev/null`\n                    found=true\n                fi\n            fi\n\n            # no such luck; use some default ssldirs\n            if ! $found; then\n                ssldirs=\"/usr/local/ssl /usr/lib/ssl /usr/ssl /usr/pkg /usr/local /usr\"\n            fi\n\n\nfi\n\n\n\n    # note that we #include <openssl/foo.h>, so the OpenSSL headers have to be in\n    # an 'openssl' subdirectory\n\n    if ! $found; then\n        OPENSSL_INCLUDES=\n        for ssldir in $ssldirs; do\n            { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for openssl/ssl.h in $ssldir\" >&5\n$as_echo_n \"checking for openssl/ssl.h in $ssldir... \" >&6; }\n            if test -f \"$ssldir/include/openssl/ssl.h\"; then\n                OPENSSL_INCLUDES=\"-I$ssldir/include\"\n                OPENSSL_LDFLAGS=\"-L$ssldir/lib\"\n                OPENSSL_LIBS=\"-lssl -lcrypto\"\n                found=true\n                { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n$as_echo \"yes\" >&6; }\n                break\n            else\n                { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\n            fi\n        done\n\n        # if the file wasn't found, well, go ahead and try the link anyway -- maybe\n        # it will just work!\n    fi\n\n    # try the preprocessor and linker with our new flags,\n    # being careful not to pollute the global LIBS, LDFLAGS, and CPPFLAGS\n\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether compiling and linking against OpenSSL works\" >&5\n$as_echo_n \"checking whether compiling and linking against OpenSSL works... \" >&6; }\n    echo \"Trying link with OPENSSL_LDFLAGS=$OPENSSL_LDFLAGS;\" \\\n        \"OPENSSL_LIBS=$OPENSSL_LIBS; OPENSSL_INCLUDES=$OPENSSL_INCLUDES\" >&5\n\n    save_LIBS=\"$LIBS\"\n    save_LDFLAGS=\"$LDFLAGS\"\n    save_CPPFLAGS=\"$CPPFLAGS\"\n    LDFLAGS=\"$LDFLAGS $OPENSSL_LDFLAGS\"\n    LIBS=\"$OPENSSL_LIBS $LIBS\"\n    CPPFLAGS=\"$OPENSSL_INCLUDES $CPPFLAGS\"\n    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <openssl/ssl.h>\nint\nmain ()\n{\nSSL_new(NULL)\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"; then :\n\n            { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n$as_echo \"yes\" >&6; }\n\n\nelse\n\n            { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\n            as_fn_error $? \"No openssl found. With --disable-openssl, libtgl will use libgcrypt instead.\" \"$LINENO\" 5\n\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext conftest.$ac_ext\n    CPPFLAGS=\"$save_CPPFLAGS\"\n    LDFLAGS=\"$save_LDFLAGS\"\n    LIBS=\"$save_LIBS\"\n\n\n\n\n\n\nfi\n\n#\n# Handle user hints\n#\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking if zlib is wanted\" >&5\n$as_echo_n \"checking if zlib is wanted... \" >&6; }\nzlib_places=\"/usr/local /usr /opt/local /sw\"\n\n# Check whether --with-zlib was given.\nif test \"${with_zlib+set}\" = set; then :\n  withval=$with_zlib; if test \"$withval\" != no ; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n$as_echo \"yes\" >&6; }\n  if test -d \"$withval\"\n  then\n    zlib_places=\"$withval $zlib_places\"\n  else\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: Sorry, $withval does not exist, checking usual places\" >&5\n$as_echo \"$as_me: WARNING: Sorry, $withval does not exist, checking usual places\" >&2;}\n  fi\nelse\n  zlib_places=\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n$as_echo \"yes\" >&6; }\nfi\n\n\n#\n# Locate zlib, if wanted\n#\nif test -n \"${zlib_places}\"\nthen\n\t# check the user supplied or any other more or less 'standard' place:\n\t#   Most UNIX systems      : /usr/local and /usr\n\t#   MacPorts / Fink on OSX : /opt/local respectively /sw\n\tfor ZLIB_HOME in ${zlib_places} ; do\n\t  if test -f \"${ZLIB_HOME}/include/zlib.h\"; then break; fi\n\t  ZLIB_HOME=\"\"\n\tdone\n\n  ZLIB_OLD_LDFLAGS=$LDFLAGS\n  ZLIB_OLD_CPPFLAGS=$CPPFLAGS\n  if test -n \"${ZLIB_HOME}\"; then\n        LDFLAGS=\"$LDFLAGS -L${ZLIB_HOME}/lib\"\n        CPPFLAGS=\"$CPPFLAGS -I${ZLIB_HOME}/include\"\n  fi\n\n  ac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for inflateEnd in -lz\" >&5\n$as_echo_n \"checking for inflateEnd in -lz... \" >&6; }\nif ${ac_cv_lib_z_inflateEnd+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_check_lib_save_LIBS=$LIBS\nLIBS=\"-lz  $LIBS\"\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar inflateEnd ();\nint\nmain ()\n{\nreturn inflateEnd ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_lib_z_inflateEnd=yes\nelse\n  ac_cv_lib_z_inflateEnd=no\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext conftest.$ac_ext\nLIBS=$ac_check_lib_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_z_inflateEnd\" >&5\n$as_echo \"$ac_cv_lib_z_inflateEnd\" >&6; }\nif test \"x$ac_cv_lib_z_inflateEnd\" = xyes; then :\n  zlib_cv_libz=yes\nelse\n  zlib_cv_libz=no\nfi\n\n  ac_fn_c_check_header_mongrel \"$LINENO\" \"zlib.h\" \"ac_cv_header_zlib_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_zlib_h\" = xyes; then :\n  zlib_cv_zlib_h=yes\nelse\n  zlib_cv_zlib_h=no\nfi\n\n\n  ac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\n  if test \"$zlib_cv_libz\" = \"yes\" && test \"$zlib_cv_zlib_h\" = \"yes\"\n  then\n    #\n    # If both library and header were found, action-if-found\n    #\n\n                CPPFLAGS=\"$CPPFLAGS -I${ZLIB_HOME}/include\"\n                LDFLAGS=\"$LDFLAGS -L${ZLIB_HOME}/lib\"\n                LIBS=\"-lz $LIBS\"\n\n$as_echo \"#define HAVE_LIBZ 1\" >>confdefs.h\n\n\n  else\n    #\n    # If either header or library was not found, action-if-not-found\n    #\n    as_fn_error $? \"No zlib found\" \"$LINENO\" 5\n  fi\nfi\n\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for rl_save_prompt in -lreadline\" >&5\n$as_echo_n \"checking for rl_save_prompt in -lreadline... \" >&6; }\nif ${ac_cv_lib_readline_rl_save_prompt+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_check_lib_save_LIBS=$LIBS\nLIBS=\"-lreadline  $LIBS\"\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar rl_save_prompt ();\nint\nmain ()\n{\nreturn rl_save_prompt ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_lib_readline_rl_save_prompt=yes\nelse\n  ac_cv_lib_readline_rl_save_prompt=no\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext conftest.$ac_ext\nLIBS=$ac_check_lib_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_readline_rl_save_prompt\" >&5\n$as_echo \"$ac_cv_lib_readline_rl_save_prompt\" >&6; }\nif test \"x$ac_cv_lib_readline_rl_save_prompt\" = xyes; then :\n   EXTRA_LIBS=\"${EXTRA_LIBS} -lreadline\" ;\nelse\n  as_fn_error $? \"no libreadline found\" \"$LINENO\" 5\nfi\n\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for libconfig\" >&5\n$as_echo_n \"checking for libconfig... \" >&6; }\n# Check whether --enable-libconfig was given.\nif test \"${enable_libconfig+set}\" = set; then :\n  enableval=$enable_libconfig;\n  if test \"x$enableval\" = \"xno\" ; then\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: disabled\" >&5\n$as_echo \"disabled\" >&6; }\n  else\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: enabled\" >&5\n$as_echo \"enabled\" >&6; }\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for config_init in -lconfig\" >&5\n$as_echo_n \"checking for config_init in -lconfig... \" >&6; }\nif ${ac_cv_lib_config_config_init+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_check_lib_save_LIBS=$LIBS\nLIBS=\"-lconfig  $LIBS\"\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar config_init ();\nint\nmain ()\n{\nreturn config_init ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_lib_config_config_init=yes\nelse\n  ac_cv_lib_config_config_init=no\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext conftest.$ac_ext\nLIBS=$ac_check_lib_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_config_config_init\" >&5\n$as_echo \"$ac_cv_lib_config_config_init\" >&6; }\nif test \"x$ac_cv_lib_config_config_init\" = xyes; then :\n  cat >>confdefs.h <<_ACEOF\n#define HAVE_LIBCONFIG 1\n_ACEOF\n\n  LIBS=\"-lconfig $LIBS\"\n\nelse\n  as_fn_error $? \"No libconfig found. Try --disable-libconfig\" \"$LINENO\" 5\nfi\n\n  fi\n\nelse\n\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: enabled\" >&5\n$as_echo \"enabled\" >&6; }\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for config_init in -lconfig\" >&5\n$as_echo_n \"checking for config_init in -lconfig... \" >&6; }\nif ${ac_cv_lib_config_config_init+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_check_lib_save_LIBS=$LIBS\nLIBS=\"-lconfig  $LIBS\"\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar config_init ();\nint\nmain ()\n{\nreturn config_init ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_lib_config_config_init=yes\nelse\n  ac_cv_lib_config_config_init=no\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext conftest.$ac_ext\nLIBS=$ac_check_lib_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_config_config_init\" >&5\n$as_echo \"$ac_cv_lib_config_config_init\" >&6; }\nif test \"x$ac_cv_lib_config_config_init\" = xyes; then :\n  cat >>confdefs.h <<_ACEOF\n#define HAVE_LIBCONFIG 1\n_ACEOF\n\n  LIBS=\"-lconfig $LIBS\"\n\nelse\n  as_fn_error $? \"No libconfig found. Try --disable-libconfig\" \"$LINENO\" 5\nfi\n\n\nfi\n\n\n# Check whether --enable-extf was given.\nif test \"${enable_extf+set}\" = set; then :\n  enableval=$enable_extf;\n  if test \"x$enableval\" = \"xno\" ; then\n\n$as_echo \"#define DISABLE_EXTF 1\" >>confdefs.h\n\n  fi\n\nfi\n\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for liblua\" >&5\n$as_echo_n \"checking for liblua... \" >&6; }\n# Check whether --enable-liblua was given.\nif test \"${enable_liblua+set}\" = set; then :\n  enableval=$enable_liblua;\n  if test \"x$enableval\" = \"xno\" ; then\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: disabled\" >&5\n$as_echo \"disabled\" >&6; }\n  else\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: enabled\" >&5\n$as_echo \"enabled\" >&6; }\n\n\n\n\n\n       if test \"x$LUA\" = 'x'; then :\n  for ac_prog in lua lua5.2 lua52 lua5.1 lua51 lua50\ndo\n  # Extract the first word of \"$ac_prog\", so it can be a program name with args.\nset dummy $ac_prog; ac_word=$2\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n$as_echo_n \"checking for $ac_word... \" >&6; }\nif ${ac_cv_path_LUA+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  case $LUA in\n  [\\\\/]* | ?:[\\\\/]*)\n  ac_cv_path_LUA=\"$LUA\" # Let the user override the test with a path.\n  ;;\n  *)\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n    ac_cv_path_LUA=\"$as_dir/$ac_word$ac_exec_ext\"\n    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\n  ;;\nesac\nfi\nLUA=$ac_cv_path_LUA\nif test -n \"$LUA\"; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $LUA\" >&5\n$as_echo \"$LUA\" >&6; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\n\n\n  test -n \"$LUA\" && break\ndone\ntest -n \"$LUA\" || LUA=\":\"\n\nfi\n    ax_display_LUA='lua'\n\n        { $as_echo \"$as_me:${as_lineno-$LINENO}: checking if $LUA is a Lua interpreter\" >&5\n$as_echo_n \"checking if $LUA is a Lua interpreter... \" >&6; }\n\n    if $LUA -e \"print('Hello ' .. _VERSION .. '!')\" &>/dev/null; then :\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n$as_echo \"yes\" >&6; }\nelse\n   { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\n        as_fn_error $? \"not a Lua interpreter\" \"$LINENO\" 5\n\nfi\n\n\n\n  if test \"x$LUA\" = 'x:'; then :\n\n        as_fn_error $? \"No lua found. Try --disable-liblua\" \"$LINENO\" 5\n\n\nelse\n       { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ax_display_LUA version\" >&5\n$as_echo_n \"checking for $ax_display_LUA version... \" >&6; }\nif ${ax_cv_lua_version+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n   ax_cv_lua_version=`$LUA -e \"print(_VERSION)\" | \\\n          sed \"s|^Lua \\(.*\\)|\\1|\" | \\\n          grep -E -o \"^[0-9]+\\.[0-9]+\"`\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ax_cv_lua_version\" >&5\n$as_echo \"$ax_cv_lua_version\" >&6; }\n    if test \"x$ax_cv_lua_version\" = 'x'; then :\n  as_fn_error $? \"invalid Lua version number\" \"$LINENO\" 5\nfi\n    LUA_VERSION=$ax_cv_lua_version\n\n    LUA_SHORT_VERSION=`echo \"$LUA_VERSION\" | sed 's|\\.||'`\n\n\n                { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ax_display_LUA platform\" >&5\n$as_echo_n \"checking for $ax_display_LUA platform... \" >&6; }\nif ${ax_cv_lua_platform+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ax_cv_lua_platform=`$LUA -e \"print('unknown')\"`\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ax_cv_lua_platform\" >&5\n$as_echo \"$ax_cv_lua_platform\" >&6; }\n    LUA_PLATFORM=$ax_cv_lua_platform\n\n\n                    LUA_PREFIX='${prefix}'\n\n    LUA_EXEC_PREFIX='${exec_prefix}'\n\n\n                        { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ax_display_LUA script directory\" >&5\n$as_echo_n \"checking for $ax_display_LUA script directory... \" >&6; }\nif ${ax_cv_lua_luadir+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n   if test \"x$prefix\" = 'xNONE'; then :\n  ax_lua_prefix=$ac_default_prefix\nelse\n  ax_lua_prefix=$prefix\nfi\n\n                ax_cv_lua_luadir=\"$LUA_PREFIX/share/lua/$LUA_VERSION\"\n\n\n\n  ax_lua_prefixed_path=''\n  _ax_package_paths=`$LUA -e 'print(package.path)' 2>/dev/null | sed 's|;|\\n|g'`\n    for _ax_package_path in $_ax_package_paths; do\n        _ax_path_parts=`echo \"$_ax_package_path\" | sed 's|/|\\n|g'`\n    _ax_reassembled=''\n    for _ax_path_part in $_ax_path_parts; do\n      echo \"$_ax_path_part\" | grep '\\?' >/dev/null && break\n      _ax_reassembled=\"$_ax_reassembled/$_ax_path_part\"\n    done\n        _ax_package_path=$_ax_reassembled\n    if echo \"$_ax_package_path\" | grep \"^$ax_lua_prefix\" >/dev/null; then\n            ax_lua_prefixed_path=$_ax_package_path\n      break\n    fi\n  done\n\n        if test \"x$ax_lua_prefixed_path\" != 'x'; then :\n             _ax_strip_prefix=`echo \"$ax_lua_prefix\" | sed 's|.|.|g'`\n          ax_cv_lua_luadir=`echo \"$ax_lua_prefixed_path\" | \\\n            sed \"s,^$_ax_strip_prefix,$LUA_PREFIX,\"`\n\nfi\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ax_cv_lua_luadir\" >&5\n$as_echo \"$ax_cv_lua_luadir\" >&6; }\n    luadir=$ax_cv_lua_luadir\n\n    pkgluadir=\\${luadir}/$PACKAGE\n\n\n                        { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ax_display_LUA module directory\" >&5\n$as_echo_n \"checking for $ax_display_LUA module directory... \" >&6; }\nif ${ax_cv_lua_luaexecdir+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n   if test \"x$exec_prefix\" = 'xNONE'; then :\n  ax_lua_exec_prefix=$ax_lua_prefix\nelse\n  ax_lua_exec_prefix=$exec_prefix\nfi\n\n                ax_cv_lua_luaexecdir=\"$LUA_EXEC_PREFIX/lib/lua/$LUA_VERSION\"\n\n\n\n  ax_lua_prefixed_path=''\n  _ax_package_paths=`$LUA -e 'print(package.cpathd)' 2>/dev/null | sed 's|;|\\n|g'`\n    for _ax_package_path in $_ax_package_paths; do\n        _ax_path_parts=`echo \"$_ax_package_path\" | sed 's|/|\\n|g'`\n    _ax_reassembled=''\n    for _ax_path_part in $_ax_path_parts; do\n      echo \"$_ax_path_part\" | grep '\\?' >/dev/null && break\n      _ax_reassembled=\"$_ax_reassembled/$_ax_path_part\"\n    done\n        _ax_package_path=$_ax_reassembled\n    if echo \"$_ax_package_path\" | grep \"^$ax_lua_exec_prefix\" >/dev/null; then\n            ax_lua_prefixed_path=$_ax_package_path\n      break\n    fi\n  done\n\n        if test \"x$ax_lua_prefixed_path\" != 'x'; then :\n             _ax_strip_prefix=`echo \"$ax_lua_exec_prefix\" | sed 's|.|.|g'`\n          ax_cv_lua_luaexecdir=`echo \"$ax_lua_prefixed_path\" | \\\n            sed \"s,^$_ax_strip_prefix,$LUA_EXEC_PREFIX,\"`\n\nfi\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ax_cv_lua_luaexecdir\" >&5\n$as_echo \"$ax_cv_lua_luaexecdir\" >&6; }\n    luaexecdir=$ax_cv_lua_luaexecdir\n\n    pkgluaexecdir=\\${luaexecdir}/$PACKAGE\n\n\n\n\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking if LUA_VERSION is defined\" >&5\n$as_echo_n \"checking if LUA_VERSION is defined... \" >&6; }\n  if test \"x$LUA_VERSION\" != 'x'; then :\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n$as_echo \"yes\" >&6; }\nelse\n   { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\n      as_fn_error $? \"cannot check Lua headers without knowing LUA_VERSION\" \"$LINENO\" 5\n\nfi\n\n\n\n    LUA_SHORT_VERSION=`echo \"$LUA_VERSION\" | sed 's|\\.||'`\n\n\n    _ax_lua_saved_cppflags=$CPPFLAGS\n  CPPFLAGS=\"$CPPFLAGS $LUA_INCLUDE\"\n  for ac_header in lua.h lualib.h lauxlib.h luaconf.h\ndo :\n  as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\nac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\"\nif eval test \\\"x\\$\"$as_ac_Header\"\\\" = x\"yes\"; then :\n  cat >>confdefs.h <<_ACEOF\n#define `$as_echo \"HAVE_$ac_header\" | $as_tr_cpp` 1\n_ACEOF\n\nfi\n\ndone\n\n  CPPFLAGS=$_ax_lua_saved_cppflags\n\n    if test \"x$LUA_INCLUDE\" = 'x' &&\n         test \"x$ac_cv_header_lua_h\" != 'xyes'; then :\n         for _ax_include_path in  /usr/include/lua$LUA_VERSION \\\n      /usr/include/lua/$LUA_VERSION \\\n      /usr/include/lua$LUA_SHORT_VERSION \\\n      /usr/local/include/lua$LUA_VERSION \\\n      /usr/local/include/lua-$LUA_VERSION \\\n      /usr/local/include/lua/$LUA_VERSION \\\n      /usr/local/include/lua$LUA_SHORT_VERSION \\\n    ; do\n        test ! -d \"$_ax_include_path\" && continue\n\n        { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for Lua headers in\" >&5\n$as_echo_n \"checking for Lua headers in... \" >&6; }\n        { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $_ax_include_path\" >&5\n$as_echo \"$_ax_include_path\" >&6; }\n\n        { ac_cv_header_lua_h=; unset ac_cv_header_lua_h;}\n        { ac_cv_header_lualib_h=; unset ac_cv_header_lualib_h;}\n        { ac_cv_header_lauxlib_h=; unset ac_cv_header_lauxlib_h;}\n        { ac_cv_header_luaconf_h=; unset ac_cv_header_luaconf_h;}\n\n        _ax_lua_saved_cppflags=$CPPFLAGS\n        CPPFLAGS=\"$CPPFLAGS -I$_ax_include_path\"\n        for ac_header in lua.h lualib.h lauxlib.h luaconf.h\ndo :\n  as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\nac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\"\nif eval test \\\"x\\$\"$as_ac_Header\"\\\" = x\"yes\"; then :\n  cat >>confdefs.h <<_ACEOF\n#define `$as_echo \"HAVE_$ac_header\" | $as_tr_cpp` 1\n_ACEOF\n\nfi\n\ndone\n\n        CPPFLAGS=$_ax_lua_saved_cppflags\n\n        if test \"x$ac_cv_header_lua_h\" = 'xyes'; then :\n   LUA_INCLUDE=\"-I$_ax_include_path\"\n            break\n\nfi\n      done\n\nfi\n\n  if test \"x$ac_cv_header_lua_h\" = 'xyes'; then :\n\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for Lua header version\" >&5\n$as_echo_n \"checking for Lua header version... \" >&6; }\nif ${ax_cv_lua_header_version+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n   _ax_lua_saved_cppflags=$CPPFLAGS\n          CPPFLAGS=\"$CPPFLAGS $LUA_INCLUDE\"\n          if test \"$cross_compiling\" = yes; then :\n  { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"cannot run test program while cross compiling\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\nelse\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n#include <lua.h>\n#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char ** argv)\n{\n  if(argc > 1) printf(\"%s\", LUA_VERSION);\n  exit(EXIT_SUCCESS);\n}\n\n\n_ACEOF\nif ac_fn_c_try_run \"$LINENO\"; then :\n   ax_cv_lua_header_version=`./conftest$EXEEXT p | \\\n                sed \"s|^Lua \\(.*\\)|\\1|\" | \\\n                grep -E -o \"^[0-9]+\\.[0-9]+\"`\n\nelse\n  ax_cv_lua_header_version='unknown'\nfi\nrm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n  conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\n\n          CPPFLAGS=$_ax_lua_saved_cppflags\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ax_cv_lua_header_version\" >&5\n$as_echo \"$ax_cv_lua_header_version\" >&6; }\n\n            { $as_echo \"$as_me:${as_lineno-$LINENO}: checking if Lua header version matches $LUA_VERSION\" >&5\n$as_echo_n \"checking if Lua header version matches $LUA_VERSION... \" >&6; }\n      if test \"x$ax_cv_lua_header_version\" = \"x$LUA_VERSION\"; then :\n   { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n$as_echo \"yes\" >&6; }\n          ax_header_version_match='yes'\n\nelse\n   { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\n          ax_header_version_match='no'\n\nfi\n\nfi\n\n    if test \"x$ax_header_version_match\" != 'xyes' &&\n         test \"x$LUA_INCLUDE\" != 'x'; then :\n  as_fn_error $? \"cannot find headers for specified LUA_INCLUDE\" \"$LINENO\" 5\nfi\n\n    if test \"x$ax_header_version_match\" = 'xyes'; then :\n\nelse\n  as_fn_error $? \"No lua headers found. Try --disable-liblua\" \"$LINENO\" 5\nfi\n\n\n\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking if LUA_VERSION is defined\" >&5\n$as_echo_n \"checking if LUA_VERSION is defined... \" >&6; }\n  if test \"x$LUA_VERSION\" != 'x'; then :\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n$as_echo \"yes\" >&6; }\nelse\n   { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\n      as_fn_error $? \"cannot check Lua libs without knowing LUA_VERSION\" \"$LINENO\" 5\n\nfi\n\n\n\n  if test \"x$LUA_LIB\" != 'x'; then :\n       _ax_lua_saved_libs=$LIBS\n    LIBS=\"$LIBS $LUA_LIB\"\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for library containing lua_load\" >&5\n$as_echo_n \"checking for library containing lua_load... \" >&6; }\nif ${ac_cv_search_lua_load+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_func_search_save_LIBS=$LIBS\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar lua_load ();\nint\nmain ()\n{\nreturn lua_load ();\n  ;\n  return 0;\n}\n_ACEOF\nfor ac_lib in '' ; do\n  if test -z \"$ac_lib\"; then\n    ac_res=\"none required\"\n  else\n    ac_res=-l$ac_lib\n    LIBS=\"-l$ac_lib  $ac_func_search_save_LIBS\"\n  fi\n  if ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_search_lua_load=$ac_res\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext\n  if ${ac_cv_search_lua_load+:} false; then :\n  break\nfi\ndone\nif ${ac_cv_search_lua_load+:} false; then :\n\nelse\n  ac_cv_search_lua_load=no\nfi\nrm conftest.$ac_ext\nLIBS=$ac_func_search_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_lua_load\" >&5\n$as_echo \"$ac_cv_search_lua_load\" >&6; }\nac_res=$ac_cv_search_lua_load\nif test \"$ac_res\" != no; then :\n  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n  _ax_found_lua_libs='yes'\nelse\n  _ax_found_lua_libs='no'\nfi\n\n    LIBS=$_ax_lua_saved_libs\n\n        if test \"x$_ax_found_lua_libs\" != 'xyes'; then :\n  as_fn_error $? \"cannot find libs for specified LUA_LIB\" \"$LINENO\" 5\nfi\n\nelse\n       _ax_lua_extra_libs=''\n\n    _ax_lua_saved_libs=$LIBS\n    LIBS=\"$LIBS $LUA_LIB\"\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for library containing exp\" >&5\n$as_echo_n \"checking for library containing exp... \" >&6; }\nif ${ac_cv_search_exp+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_func_search_save_LIBS=$LIBS\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar exp ();\nint\nmain ()\n{\nreturn exp ();\n  ;\n  return 0;\n}\n_ACEOF\nfor ac_lib in '' m; do\n  if test -z \"$ac_lib\"; then\n    ac_res=\"none required\"\n  else\n    ac_res=-l$ac_lib\n    LIBS=\"-l$ac_lib  $ac_func_search_save_LIBS\"\n  fi\n  if ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_search_exp=$ac_res\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext\n  if ${ac_cv_search_exp+:} false; then :\n  break\nfi\ndone\nif ${ac_cv_search_exp+:} false; then :\n\nelse\n  ac_cv_search_exp=no\nfi\nrm conftest.$ac_ext\nLIBS=$ac_func_search_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_exp\" >&5\n$as_echo \"$ac_cv_search_exp\" >&6; }\nac_res=$ac_cv_search_exp\nif test \"$ac_res\" != no; then :\n  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n\nfi\n\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for library containing dlopen\" >&5\n$as_echo_n \"checking for library containing dlopen... \" >&6; }\nif ${ac_cv_search_dlopen+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_func_search_save_LIBS=$LIBS\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar dlopen ();\nint\nmain ()\n{\nreturn dlopen ();\n  ;\n  return 0;\n}\n_ACEOF\nfor ac_lib in '' dl; do\n  if test -z \"$ac_lib\"; then\n    ac_res=\"none required\"\n  else\n    ac_res=-l$ac_lib\n    LIBS=\"-l$ac_lib  $ac_func_search_save_LIBS\"\n  fi\n  if ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_search_dlopen=$ac_res\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext\n  if ${ac_cv_search_dlopen+:} false; then :\n  break\nfi\ndone\nif ${ac_cv_search_dlopen+:} false; then :\n\nelse\n  ac_cv_search_dlopen=no\nfi\nrm conftest.$ac_ext\nLIBS=$ac_func_search_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_dlopen\" >&5\n$as_echo \"$ac_cv_search_dlopen\" >&6; }\nac_res=$ac_cv_search_dlopen\nif test \"$ac_res\" != no; then :\n  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n\nfi\n\n    LIBS=$_ax_lua_saved_libs\n\n    if test \"x$ac_cv_search_exp\" != 'xno' &&\n           test \"x$ac_cv_search_exp\" != 'xnone required'; then :\n  _ax_lua_extra_libs=\"$_ax_lua_extra_libs $ac_cv_search_exp\"\nfi\n\n    if test \"x$ac_cv_search_dlopen\" != 'xno' &&\n           test \"x$ac_cv_search_dlopen\" != 'xnone required'; then :\n  _ax_lua_extra_libs=\"$_ax_lua_extra_libs $ac_cv_search_dlopen\"\nfi\n\n        _ax_lua_saved_libs=$LIBS\n    LIBS=\"$LIBS $LUA_LIB\"\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for library containing lua_load\" >&5\n$as_echo_n \"checking for library containing lua_load... \" >&6; }\nif ${ac_cv_search_lua_load+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_func_search_save_LIBS=$LIBS\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar lua_load ();\nint\nmain ()\n{\nreturn lua_load ();\n  ;\n  return 0;\n}\n_ACEOF\nfor ac_lib in ''  lua$LUA_VERSION \\\n                     lua$LUA_SHORT_VERSION \\\n                     lua-$LUA_VERSION \\\n                     lua-$LUA_SHORT_VERSION \\\n                     lua; do\n  if test -z \"$ac_lib\"; then\n    ac_res=\"none required\"\n  else\n    ac_res=-l$ac_lib\n    LIBS=\"-l$ac_lib $_ax_lua_extra_libs $ac_func_search_save_LIBS\"\n  fi\n  if ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_search_lua_load=$ac_res\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext\n  if ${ac_cv_search_lua_load+:} false; then :\n  break\nfi\ndone\nif ${ac_cv_search_lua_load+:} false; then :\n\nelse\n  ac_cv_search_lua_load=no\nfi\nrm conftest.$ac_ext\nLIBS=$ac_func_search_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_lua_load\" >&5\n$as_echo \"$ac_cv_search_lua_load\" >&6; }\nac_res=$ac_cv_search_lua_load\nif test \"$ac_res\" != no; then :\n  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n  _ax_found_lua_libs='yes'\nelse\n  _ax_found_lua_libs='no'\nfi\n\n    LIBS=$_ax_lua_saved_libs\n\n    if test \"x$ac_cv_search_lua_load\" != 'xno' &&\n           test \"x$ac_cv_search_lua_load\" != 'xnone required'; then :\n  LUA_LIB=\"$ac_cv_search_lua_load $_ax_lua_extra_libs\"\nfi\n\nfi\n\n    if test \"x$_ax_found_lua_libs\" = 'xyes'; then :\n\nelse\n  as_fn_error $? \"No lua libs found. Try --disable-liblua\" \"$LINENO\" 5\nfi\n\n        EXTRA_LIBS=\"${EXTRA_LIBS} ${LUA_LIB}\" ;\n        CPPFLAGS=\"${CPPFLAGS} ${LUA_INCLUDE}\" ;\n\n$as_echo \"#define USE_LUA 1\" >>confdefs.h\n\n\n\nfi\n\n  fi\n\nelse\n\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: enabled\" >&5\n$as_echo \"enabled\" >&6; }\n\n\n\n\n\n       if test \"x$LUA\" = 'x'; then :\n  for ac_prog in lua lua5.2 lua52 lua5.1 lua51 lua50\ndo\n  # Extract the first word of \"$ac_prog\", so it can be a program name with args.\nset dummy $ac_prog; ac_word=$2\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n$as_echo_n \"checking for $ac_word... \" >&6; }\nif ${ac_cv_path_LUA+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  case $LUA in\n  [\\\\/]* | ?:[\\\\/]*)\n  ac_cv_path_LUA=\"$LUA\" # Let the user override the test with a path.\n  ;;\n  *)\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n    ac_cv_path_LUA=\"$as_dir/$ac_word$ac_exec_ext\"\n    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\n  ;;\nesac\nfi\nLUA=$ac_cv_path_LUA\nif test -n \"$LUA\"; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $LUA\" >&5\n$as_echo \"$LUA\" >&6; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\n\n\n  test -n \"$LUA\" && break\ndone\ntest -n \"$LUA\" || LUA=\":\"\n\nfi\n    ax_display_LUA='lua'\n\n        { $as_echo \"$as_me:${as_lineno-$LINENO}: checking if $LUA is a Lua interpreter\" >&5\n$as_echo_n \"checking if $LUA is a Lua interpreter... \" >&6; }\n\n    if $LUA -e \"print('Hello ' .. _VERSION .. '!')\" &>/dev/null; then :\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n$as_echo \"yes\" >&6; }\nelse\n   { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\n        as_fn_error $? \"not a Lua interpreter\" \"$LINENO\" 5\n\nfi\n\n\n\n  if test \"x$LUA\" = 'x:'; then :\n\n        as_fn_error $? \"No lua found. Try --disable-liblua\" \"$LINENO\" 5\n\n\nelse\n       { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ax_display_LUA version\" >&5\n$as_echo_n \"checking for $ax_display_LUA version... \" >&6; }\nif ${ax_cv_lua_version+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n   ax_cv_lua_version=`$LUA -e \"print(_VERSION)\" | \\\n          sed \"s|^Lua \\(.*\\)|\\1|\" | \\\n          grep -E -o \"^[0-9]+\\.[0-9]+\"`\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ax_cv_lua_version\" >&5\n$as_echo \"$ax_cv_lua_version\" >&6; }\n    if test \"x$ax_cv_lua_version\" = 'x'; then :\n  as_fn_error $? \"invalid Lua version number\" \"$LINENO\" 5\nfi\n    LUA_VERSION=$ax_cv_lua_version\n\n    LUA_SHORT_VERSION=`echo \"$LUA_VERSION\" | sed 's|\\.||'`\n\n\n                { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ax_display_LUA platform\" >&5\n$as_echo_n \"checking for $ax_display_LUA platform... \" >&6; }\nif ${ax_cv_lua_platform+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ax_cv_lua_platform=`$LUA -e \"print('unknown')\"`\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ax_cv_lua_platform\" >&5\n$as_echo \"$ax_cv_lua_platform\" >&6; }\n    LUA_PLATFORM=$ax_cv_lua_platform\n\n\n                    LUA_PREFIX='${prefix}'\n\n    LUA_EXEC_PREFIX='${exec_prefix}'\n\n\n                        { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ax_display_LUA script directory\" >&5\n$as_echo_n \"checking for $ax_display_LUA script directory... \" >&6; }\nif ${ax_cv_lua_luadir+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n   if test \"x$prefix\" = 'xNONE'; then :\n  ax_lua_prefix=$ac_default_prefix\nelse\n  ax_lua_prefix=$prefix\nfi\n\n                ax_cv_lua_luadir=\"$LUA_PREFIX/share/lua/$LUA_VERSION\"\n\n\n\n  ax_lua_prefixed_path=''\n  _ax_package_paths=`$LUA -e 'print(package.path)' 2>/dev/null | sed 's|;|\\n|g'`\n    for _ax_package_path in $_ax_package_paths; do\n        _ax_path_parts=`echo \"$_ax_package_path\" | sed 's|/|\\n|g'`\n    _ax_reassembled=''\n    for _ax_path_part in $_ax_path_parts; do\n      echo \"$_ax_path_part\" | grep '\\?' >/dev/null && break\n      _ax_reassembled=\"$_ax_reassembled/$_ax_path_part\"\n    done\n        _ax_package_path=$_ax_reassembled\n    if echo \"$_ax_package_path\" | grep \"^$ax_lua_prefix\" >/dev/null; then\n            ax_lua_prefixed_path=$_ax_package_path\n      break\n    fi\n  done\n\n        if test \"x$ax_lua_prefixed_path\" != 'x'; then :\n             _ax_strip_prefix=`echo \"$ax_lua_prefix\" | sed 's|.|.|g'`\n          ax_cv_lua_luadir=`echo \"$ax_lua_prefixed_path\" | \\\n            sed \"s,^$_ax_strip_prefix,$LUA_PREFIX,\"`\n\nfi\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ax_cv_lua_luadir\" >&5\n$as_echo \"$ax_cv_lua_luadir\" >&6; }\n    luadir=$ax_cv_lua_luadir\n\n    pkgluadir=\\${luadir}/$PACKAGE\n\n\n                        { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ax_display_LUA module directory\" >&5\n$as_echo_n \"checking for $ax_display_LUA module directory... \" >&6; }\nif ${ax_cv_lua_luaexecdir+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n   if test \"x$exec_prefix\" = 'xNONE'; then :\n  ax_lua_exec_prefix=$ax_lua_prefix\nelse\n  ax_lua_exec_prefix=$exec_prefix\nfi\n\n                ax_cv_lua_luaexecdir=\"$LUA_EXEC_PREFIX/lib/lua/$LUA_VERSION\"\n\n\n\n  ax_lua_prefixed_path=''\n  _ax_package_paths=`$LUA -e 'print(package.cpathd)' 2>/dev/null | sed 's|;|\\n|g'`\n    for _ax_package_path in $_ax_package_paths; do\n        _ax_path_parts=`echo \"$_ax_package_path\" | sed 's|/|\\n|g'`\n    _ax_reassembled=''\n    for _ax_path_part in $_ax_path_parts; do\n      echo \"$_ax_path_part\" | grep '\\?' >/dev/null && break\n      _ax_reassembled=\"$_ax_reassembled/$_ax_path_part\"\n    done\n        _ax_package_path=$_ax_reassembled\n    if echo \"$_ax_package_path\" | grep \"^$ax_lua_exec_prefix\" >/dev/null; then\n            ax_lua_prefixed_path=$_ax_package_path\n      break\n    fi\n  done\n\n        if test \"x$ax_lua_prefixed_path\" != 'x'; then :\n             _ax_strip_prefix=`echo \"$ax_lua_exec_prefix\" | sed 's|.|.|g'`\n          ax_cv_lua_luaexecdir=`echo \"$ax_lua_prefixed_path\" | \\\n            sed \"s,^$_ax_strip_prefix,$LUA_EXEC_PREFIX,\"`\n\nfi\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ax_cv_lua_luaexecdir\" >&5\n$as_echo \"$ax_cv_lua_luaexecdir\" >&6; }\n    luaexecdir=$ax_cv_lua_luaexecdir\n\n    pkgluaexecdir=\\${luaexecdir}/$PACKAGE\n\n\n\n\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking if LUA_VERSION is defined\" >&5\n$as_echo_n \"checking if LUA_VERSION is defined... \" >&6; }\n  if test \"x$LUA_VERSION\" != 'x'; then :\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n$as_echo \"yes\" >&6; }\nelse\n   { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\n      as_fn_error $? \"cannot check Lua headers without knowing LUA_VERSION\" \"$LINENO\" 5\n\nfi\n\n\n\n    LUA_SHORT_VERSION=`echo \"$LUA_VERSION\" | sed 's|\\.||'`\n\n\n    _ax_lua_saved_cppflags=$CPPFLAGS\n  CPPFLAGS=\"$CPPFLAGS $LUA_INCLUDE\"\n  for ac_header in lua.h lualib.h lauxlib.h luaconf.h\ndo :\n  as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\nac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\"\nif eval test \\\"x\\$\"$as_ac_Header\"\\\" = x\"yes\"; then :\n  cat >>confdefs.h <<_ACEOF\n#define `$as_echo \"HAVE_$ac_header\" | $as_tr_cpp` 1\n_ACEOF\n\nfi\n\ndone\n\n  CPPFLAGS=$_ax_lua_saved_cppflags\n\n    if test \"x$LUA_INCLUDE\" = 'x' &&\n         test \"x$ac_cv_header_lua_h\" != 'xyes'; then :\n         for _ax_include_path in  /usr/include/lua$LUA_VERSION \\\n      /usr/include/lua/$LUA_VERSION \\\n      /usr/include/lua$LUA_SHORT_VERSION \\\n      /usr/local/include/lua$LUA_VERSION \\\n      /usr/local/include/lua-$LUA_VERSION \\\n      /usr/local/include/lua/$LUA_VERSION \\\n      /usr/local/include/lua$LUA_SHORT_VERSION \\\n    ; do\n        test ! -d \"$_ax_include_path\" && continue\n\n        { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for Lua headers in\" >&5\n$as_echo_n \"checking for Lua headers in... \" >&6; }\n        { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $_ax_include_path\" >&5\n$as_echo \"$_ax_include_path\" >&6; }\n\n        { ac_cv_header_lua_h=; unset ac_cv_header_lua_h;}\n        { ac_cv_header_lualib_h=; unset ac_cv_header_lualib_h;}\n        { ac_cv_header_lauxlib_h=; unset ac_cv_header_lauxlib_h;}\n        { ac_cv_header_luaconf_h=; unset ac_cv_header_luaconf_h;}\n\n        _ax_lua_saved_cppflags=$CPPFLAGS\n        CPPFLAGS=\"$CPPFLAGS -I$_ax_include_path\"\n        for ac_header in lua.h lualib.h lauxlib.h luaconf.h\ndo :\n  as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\nac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\"\nif eval test \\\"x\\$\"$as_ac_Header\"\\\" = x\"yes\"; then :\n  cat >>confdefs.h <<_ACEOF\n#define `$as_echo \"HAVE_$ac_header\" | $as_tr_cpp` 1\n_ACEOF\n\nfi\n\ndone\n\n        CPPFLAGS=$_ax_lua_saved_cppflags\n\n        if test \"x$ac_cv_header_lua_h\" = 'xyes'; then :\n   LUA_INCLUDE=\"-I$_ax_include_path\"\n            break\n\nfi\n      done\n\nfi\n\n  if test \"x$ac_cv_header_lua_h\" = 'xyes'; then :\n\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for Lua header version\" >&5\n$as_echo_n \"checking for Lua header version... \" >&6; }\nif ${ax_cv_lua_header_version+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n   _ax_lua_saved_cppflags=$CPPFLAGS\n          CPPFLAGS=\"$CPPFLAGS $LUA_INCLUDE\"\n          if test \"$cross_compiling\" = yes; then :\n  { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"cannot run test program while cross compiling\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\nelse\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n#include <lua.h>\n#include <stdlib.h>\n#include <stdio.h>\nint main(int argc, char ** argv)\n{\n  if(argc > 1) printf(\"%s\", LUA_VERSION);\n  exit(EXIT_SUCCESS);\n}\n\n\n_ACEOF\nif ac_fn_c_try_run \"$LINENO\"; then :\n   ax_cv_lua_header_version=`./conftest$EXEEXT p | \\\n                sed \"s|^Lua \\(.*\\)|\\1|\" | \\\n                grep -E -o \"^[0-9]+\\.[0-9]+\"`\n\nelse\n  ax_cv_lua_header_version='unknown'\nfi\nrm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n  conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\n\n          CPPFLAGS=$_ax_lua_saved_cppflags\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ax_cv_lua_header_version\" >&5\n$as_echo \"$ax_cv_lua_header_version\" >&6; }\n\n            { $as_echo \"$as_me:${as_lineno-$LINENO}: checking if Lua header version matches $LUA_VERSION\" >&5\n$as_echo_n \"checking if Lua header version matches $LUA_VERSION... \" >&6; }\n      if test \"x$ax_cv_lua_header_version\" = \"x$LUA_VERSION\"; then :\n   { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n$as_echo \"yes\" >&6; }\n          ax_header_version_match='yes'\n\nelse\n   { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\n          ax_header_version_match='no'\n\nfi\n\nfi\n\n    if test \"x$ax_header_version_match\" != 'xyes' &&\n         test \"x$LUA_INCLUDE\" != 'x'; then :\n  as_fn_error $? \"cannot find headers for specified LUA_INCLUDE\" \"$LINENO\" 5\nfi\n\n    if test \"x$ax_header_version_match\" = 'xyes'; then :\n\nelse\n  as_fn_error $? \"No lua headers found. Try --disable-liblua\" \"$LINENO\" 5\nfi\n\n\n\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking if LUA_VERSION is defined\" >&5\n$as_echo_n \"checking if LUA_VERSION is defined... \" >&6; }\n  if test \"x$LUA_VERSION\" != 'x'; then :\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n$as_echo \"yes\" >&6; }\nelse\n   { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\n      as_fn_error $? \"cannot check Lua libs without knowing LUA_VERSION\" \"$LINENO\" 5\n\nfi\n\n\n\n  if test \"x$LUA_LIB\" != 'x'; then :\n       _ax_lua_saved_libs=$LIBS\n    LIBS=\"$LIBS $LUA_LIB\"\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for library containing lua_load\" >&5\n$as_echo_n \"checking for library containing lua_load... \" >&6; }\nif ${ac_cv_search_lua_load+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_func_search_save_LIBS=$LIBS\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar lua_load ();\nint\nmain ()\n{\nreturn lua_load ();\n  ;\n  return 0;\n}\n_ACEOF\nfor ac_lib in '' ; do\n  if test -z \"$ac_lib\"; then\n    ac_res=\"none required\"\n  else\n    ac_res=-l$ac_lib\n    LIBS=\"-l$ac_lib  $ac_func_search_save_LIBS\"\n  fi\n  if ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_search_lua_load=$ac_res\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext\n  if ${ac_cv_search_lua_load+:} false; then :\n  break\nfi\ndone\nif ${ac_cv_search_lua_load+:} false; then :\n\nelse\n  ac_cv_search_lua_load=no\nfi\nrm conftest.$ac_ext\nLIBS=$ac_func_search_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_lua_load\" >&5\n$as_echo \"$ac_cv_search_lua_load\" >&6; }\nac_res=$ac_cv_search_lua_load\nif test \"$ac_res\" != no; then :\n  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n  _ax_found_lua_libs='yes'\nelse\n  _ax_found_lua_libs='no'\nfi\n\n    LIBS=$_ax_lua_saved_libs\n\n        if test \"x$_ax_found_lua_libs\" != 'xyes'; then :\n  as_fn_error $? \"cannot find libs for specified LUA_LIB\" \"$LINENO\" 5\nfi\n\nelse\n       _ax_lua_extra_libs=''\n\n    _ax_lua_saved_libs=$LIBS\n    LIBS=\"$LIBS $LUA_LIB\"\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for library containing exp\" >&5\n$as_echo_n \"checking for library containing exp... \" >&6; }\nif ${ac_cv_search_exp+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_func_search_save_LIBS=$LIBS\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar exp ();\nint\nmain ()\n{\nreturn exp ();\n  ;\n  return 0;\n}\n_ACEOF\nfor ac_lib in '' m; do\n  if test -z \"$ac_lib\"; then\n    ac_res=\"none required\"\n  else\n    ac_res=-l$ac_lib\n    LIBS=\"-l$ac_lib  $ac_func_search_save_LIBS\"\n  fi\n  if ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_search_exp=$ac_res\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext\n  if ${ac_cv_search_exp+:} false; then :\n  break\nfi\ndone\nif ${ac_cv_search_exp+:} false; then :\n\nelse\n  ac_cv_search_exp=no\nfi\nrm conftest.$ac_ext\nLIBS=$ac_func_search_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_exp\" >&5\n$as_echo \"$ac_cv_search_exp\" >&6; }\nac_res=$ac_cv_search_exp\nif test \"$ac_res\" != no; then :\n  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n\nfi\n\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for library containing dlopen\" >&5\n$as_echo_n \"checking for library containing dlopen... \" >&6; }\nif ${ac_cv_search_dlopen+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_func_search_save_LIBS=$LIBS\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar dlopen ();\nint\nmain ()\n{\nreturn dlopen ();\n  ;\n  return 0;\n}\n_ACEOF\nfor ac_lib in '' dl; do\n  if test -z \"$ac_lib\"; then\n    ac_res=\"none required\"\n  else\n    ac_res=-l$ac_lib\n    LIBS=\"-l$ac_lib  $ac_func_search_save_LIBS\"\n  fi\n  if ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_search_dlopen=$ac_res\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext\n  if ${ac_cv_search_dlopen+:} false; then :\n  break\nfi\ndone\nif ${ac_cv_search_dlopen+:} false; then :\n\nelse\n  ac_cv_search_dlopen=no\nfi\nrm conftest.$ac_ext\nLIBS=$ac_func_search_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_dlopen\" >&5\n$as_echo \"$ac_cv_search_dlopen\" >&6; }\nac_res=$ac_cv_search_dlopen\nif test \"$ac_res\" != no; then :\n  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n\nfi\n\n    LIBS=$_ax_lua_saved_libs\n\n    if test \"x$ac_cv_search_exp\" != 'xno' &&\n           test \"x$ac_cv_search_exp\" != 'xnone required'; then :\n  _ax_lua_extra_libs=\"$_ax_lua_extra_libs $ac_cv_search_exp\"\nfi\n\n    if test \"x$ac_cv_search_dlopen\" != 'xno' &&\n           test \"x$ac_cv_search_dlopen\" != 'xnone required'; then :\n  _ax_lua_extra_libs=\"$_ax_lua_extra_libs $ac_cv_search_dlopen\"\nfi\n\n        _ax_lua_saved_libs=$LIBS\n    LIBS=\"$LIBS $LUA_LIB\"\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for library containing lua_load\" >&5\n$as_echo_n \"checking for library containing lua_load... \" >&6; }\nif ${ac_cv_search_lua_load+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_func_search_save_LIBS=$LIBS\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar lua_load ();\nint\nmain ()\n{\nreturn lua_load ();\n  ;\n  return 0;\n}\n_ACEOF\nfor ac_lib in ''  lua$LUA_VERSION \\\n                     lua$LUA_SHORT_VERSION \\\n                     lua-$LUA_VERSION \\\n                     lua-$LUA_SHORT_VERSION \\\n                     lua; do\n  if test -z \"$ac_lib\"; then\n    ac_res=\"none required\"\n  else\n    ac_res=-l$ac_lib\n    LIBS=\"-l$ac_lib $_ax_lua_extra_libs $ac_func_search_save_LIBS\"\n  fi\n  if ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_search_lua_load=$ac_res\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext\n  if ${ac_cv_search_lua_load+:} false; then :\n  break\nfi\ndone\nif ${ac_cv_search_lua_load+:} false; then :\n\nelse\n  ac_cv_search_lua_load=no\nfi\nrm conftest.$ac_ext\nLIBS=$ac_func_search_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_lua_load\" >&5\n$as_echo \"$ac_cv_search_lua_load\" >&6; }\nac_res=$ac_cv_search_lua_load\nif test \"$ac_res\" != no; then :\n  test \"$ac_res\" = \"none required\" || LIBS=\"$ac_res $LIBS\"\n  _ax_found_lua_libs='yes'\nelse\n  _ax_found_lua_libs='no'\nfi\n\n    LIBS=$_ax_lua_saved_libs\n\n    if test \"x$ac_cv_search_lua_load\" != 'xno' &&\n           test \"x$ac_cv_search_lua_load\" != 'xnone required'; then :\n  LUA_LIB=\"$ac_cv_search_lua_load $_ax_lua_extra_libs\"\nfi\n\nfi\n\n    if test \"x$_ax_found_lua_libs\" = 'xyes'; then :\n\nelse\n  as_fn_error $? \"No lua libs found. Try --disable-liblua\" \"$LINENO\" 5\nfi\n\n        EXTRA_LIBS=\"${EXTRA_LIBS} ${LUA_LIB}\" ;\n        CPPFLAGS=\"${CPPFLAGS} ${LUA_INCLUDE}\" ;\n\n$as_echo \"#define USE_LUA 1\" >>confdefs.h\n\n\n\nfi\n\n\nfi\n\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for python\" >&5\n$as_echo_n \"checking for python... \" >&6; }\n# Check whether --enable-python was given.\nif test \"${enable_python+set}\" = set; then :\n  enableval=$enable_python;\n    if test \"x$enableval\" = \"xyes\" ; then\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: disabled\" >&5\n$as_echo \"disabled\" >&6; }\n    else\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: enabled\" >&5\n$as_echo \"enabled\" >&6; }\n\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for python build information\" >&5\n$as_echo_n \"checking for python build information... \" >&6; }\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: \" >&5\n$as_echo \"\" >&6; }\nfor python in python3.5 python3.4 python3.3 python3.2 python3.1 python3 python2.7 python2.6 python2 python; do\nfor ac_prog in $python\ndo\n  # Extract the first word of \"$ac_prog\", so it can be a program name with args.\nset dummy $ac_prog; ac_word=$2\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n$as_echo_n \"checking for $ac_word... \" >&6; }\nif ${ac_cv_prog_PYTHON_BIN+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  if test -n \"$PYTHON_BIN\"; then\n  ac_cv_prog_PYTHON_BIN=\"$PYTHON_BIN\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_PYTHON_BIN=\"$ac_prog\"\n    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nPYTHON_BIN=$ac_cv_prog_PYTHON_BIN\nif test -n \"$PYTHON_BIN\"; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $PYTHON_BIN\" >&5\n$as_echo \"$PYTHON_BIN\" >&6; }\nelse\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n$as_echo \"no\" >&6; }\nfi\n\n\n  test -n \"$PYTHON_BIN\" && break\ndone\n\nax_python_bin=$PYTHON_BIN\nif test x$ax_python_bin != x; then\n   as_ac_Lib=`$as_echo \"ac_cv_lib_$ax_python_bin''_main\" | $as_tr_sh`\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for main in -l$ax_python_bin\" >&5\n$as_echo_n \"checking for main in -l$ax_python_bin... \" >&6; }\nif eval \\${$as_ac_Lib+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_check_lib_save_LIBS=$LIBS\nLIBS=\"-l$ax_python_bin  $LIBS\"\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n\nint\nmain ()\n{\nreturn main ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"; then :\n  eval \"$as_ac_Lib=yes\"\nelse\n  eval \"$as_ac_Lib=no\"\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext conftest.$ac_ext\nLIBS=$ac_check_lib_save_LIBS\nfi\neval ac_res=\\$$as_ac_Lib\n\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n$as_echo \"$ac_res\" >&6; }\nif eval test \\\"x\\$\"$as_ac_Lib\"\\\" = x\"yes\"; then :\n  ax_python_lib=$ax_python_bin\nelse\n  ax_python_lib=no\nfi\n\n   if test x$ax_python_lib == xno; then\n     as_ac_Lib=`$as_echo \"ac_cv_lib_${ax_python_bin}m''_main\" | $as_tr_sh`\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for main in -l${ax_python_bin}m\" >&5\n$as_echo_n \"checking for main in -l${ax_python_bin}m... \" >&6; }\nif eval \\${$as_ac_Lib+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_check_lib_save_LIBS=$LIBS\nLIBS=\"-l${ax_python_bin}m  $LIBS\"\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n\nint\nmain ()\n{\nreturn main ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"; then :\n  eval \"$as_ac_Lib=yes\"\nelse\n  eval \"$as_ac_Lib=no\"\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext conftest.$ac_ext\nLIBS=$ac_check_lib_save_LIBS\nfi\neval ac_res=\\$$as_ac_Lib\n\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n$as_echo \"$ac_res\" >&6; }\nif eval test \\\"x\\$\"$as_ac_Lib\"\\\" = x\"yes\"; then :\n  ax_python_lib=${ax_python_bin}m\nelse\n  ax_python_lib=no\nfi\n\n   fi\n   if test x$ax_python_lib == xno; then\n     as_ac_Lib=`$as_echo \"ac_cv_lib_${ax_python_bin}mu''_main\" | $as_tr_sh`\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for main in -l${ax_python_bin}mu\" >&5\n$as_echo_n \"checking for main in -l${ax_python_bin}mu... \" >&6; }\nif eval \\${$as_ac_Lib+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_check_lib_save_LIBS=$LIBS\nLIBS=\"-l${ax_python_bin}mu  $LIBS\"\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n\nint\nmain ()\n{\nreturn main ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"; then :\n  eval \"$as_ac_Lib=yes\"\nelse\n  eval \"$as_ac_Lib=no\"\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext conftest.$ac_ext\nLIBS=$ac_check_lib_save_LIBS\nfi\neval ac_res=\\$$as_ac_Lib\n\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n$as_echo \"$ac_res\" >&6; }\nif eval test \\\"x\\$\"$as_ac_Lib\"\\\" = x\"yes\"; then :\n  ax_python_lib=${ax_python_bin}mu\nelse\n  ax_python_lib=no\nfi\n\n   fi\n   if test x$ax_python_lib != xno; then\n     ax_python_header=`$ax_python_bin -c \"from distutils.sysconfig import *; print(get_config_var('CONFINCLUDEPY'))\"`\n     if test x$ax_python_header != x; then\n       break;\n     fi\n   fi\nfi\nunset ac_cv_prog_PYTHON_BIN\nunset PYTHON_BIN\ndone\nif test x$ax_python_bin = x; then\n   ax_python_bin=no\nfi\nif test x$ax_python_header = x; then\n   ax_python_header=no\nfi\nif test x$ax_python_lib = x; then\n   ax_python_lib=no\nfi\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result:   results of the Python check:\" >&5\n$as_echo \"  results of the Python check:\" >&6; }\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result:     Binary:      $ax_python_bin\" >&5\n$as_echo \"    Binary:      $ax_python_bin\" >&6; }\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result:     Library:     $ax_python_lib\" >&5\n$as_echo \"    Library:     $ax_python_lib\" >&6; }\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result:     Include Dir: $ax_python_header\" >&5\n$as_echo \"    Include Dir: $ax_python_header\" >&6; }\n\n\nPYTHON_FOUND=yes\nif test x$ax_python_header != xno; then\n  PYTHON_INCLUDE_DIR=$ax_python_header\n\nelse\n  PYTHON_FOUND=no\nfi\n\nif test x$ax_python_lib != xno; then\n  PYTHON_LIB=$ax_python_lib\n\nelse\n  PYTHON_FOUND=no\nfi\n\n\n\n\n      if test $PYTHON_FOUND = no ; then\n        as_fn_error $? \"No supported python lib version found. Try --disable-python\" \"$LINENO\" 5\n      else\n\n\n        EXTRA_LIBS=\"${EXTRA_LIBS} -l${PYTHON_LIB}\"\n        CPPFLAGS=\"${CPPFLAGS} -I${PYTHON_INCLUDE_DIR}\"\n\n$as_echo \"#define USE_PYTHON 1\" >>confdefs.h\n\n      fi\n    fi\n\nelse\n\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: disabled\" >&5\n$as_echo \"disabled\" >&6; }\n\nfi\n\n\n\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for libjansson\" >&5\n$as_echo_n \"checking for libjansson... \" >&6; }\n# Check whether --enable-json was given.\nif test \"${enable_json+set}\" = set; then :\n  enableval=$enable_json;\n  if test \"x$enableval\" = \"xno\" ; then\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: disabled\" >&5\n$as_echo \"disabled\" >&6; }\n  else\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: enabled\" >&5\n$as_echo \"enabled\" >&6; }\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for json_array_set_new in -ljansson\" >&5\n$as_echo_n \"checking for json_array_set_new in -ljansson... \" >&6; }\nif ${ac_cv_lib_jansson_json_array_set_new+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_check_lib_save_LIBS=$LIBS\nLIBS=\"-ljansson  $LIBS\"\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar json_array_set_new ();\nint\nmain ()\n{\nreturn json_array_set_new ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_lib_jansson_json_array_set_new=yes\nelse\n  ac_cv_lib_jansson_json_array_set_new=no\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext conftest.$ac_ext\nLIBS=$ac_check_lib_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_jansson_json_array_set_new\" >&5\n$as_echo \"$ac_cv_lib_jansson_json_array_set_new\" >&6; }\nif test \"x$ac_cv_lib_jansson_json_array_set_new\" = xyes; then :\n  cat >>confdefs.h <<_ACEOF\n#define HAVE_LIBJANSSON 1\n_ACEOF\n\n  LIBS=\"-ljansson $LIBS\"\n\nelse\n  as_fn_error $? \"No libjansson found. Try --disable-json\" \"$LINENO\" 5\nfi\n\n\n$as_echo \"#define USE_JSON 1\" >>confdefs.h\n\n  fi\n\nelse\n\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: enabled\" >&5\n$as_echo \"enabled\" >&6; }\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for json_array_set_new in -ljansson\" >&5\n$as_echo_n \"checking for json_array_set_new in -ljansson... \" >&6; }\nif ${ac_cv_lib_jansson_json_array_set_new+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_check_lib_save_LIBS=$LIBS\nLIBS=\"-ljansson  $LIBS\"\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\n/* Override any GCC internal prototype to avoid an error.\n   Use char because int might match the return type of a GCC\n   builtin and then its argument prototype would still apply.  */\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar json_array_set_new ();\nint\nmain ()\n{\nreturn json_array_set_new ();\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"; then :\n  ac_cv_lib_jansson_json_array_set_new=yes\nelse\n  ac_cv_lib_jansson_json_array_set_new=no\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext conftest.$ac_ext\nLIBS=$ac_check_lib_save_LIBS\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_jansson_json_array_set_new\" >&5\n$as_echo \"$ac_cv_lib_jansson_json_array_set_new\" >&6; }\nif test \"x$ac_cv_lib_jansson_json_array_set_new\" = xyes; then :\n  cat >>confdefs.h <<_ACEOF\n#define HAVE_LIBJANSSON 1\n_ACEOF\n\n  LIBS=\"-ljansson $LIBS\"\n\nelse\n  as_fn_error $? \"No libjansson found. Try --disable-json\" \"$LINENO\" 5\nfi\n\n\n$as_echo \"#define USE_JSON 1\" >>confdefs.h\n\n\nfi\n\n\n#check for custom prog name\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking progname\" >&5\n$as_echo_n \"checking progname... \" >&6; }\n\n# Check whether --with-progname was given.\nif test \"${with_progname+set}\" = set; then :\n  withval=$with_progname;\n  if test \"x$with_progname\" = \"xno\" ; then\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: default\" >&5\n$as_echo \"default\" >&6; }\n  elif test \"x$with_progname\" = \"xyes\" ; then\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: default\" >&5\n$as_echo \"default\" >&6; }\n  else\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: \\\"$with_progname\\\"\" >&5\n$as_echo \"\\\"$with_progname\\\"\" >&6; }\n\ncat >>confdefs.h <<_ACEOF\n#define PROG_NAME \"$with_progname\"\n_ACEOF\n\n  fi\n\nelse\n\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: default\" >&5\n$as_echo \"default\" >&6; }\n\nfi\n\n\n# Check whether --enable-valgrind was given.\nif test \"${enable_valgrind+set}\" = set; then :\n  enableval=$enable_valgrind;\n  if test \"x$enableval\" = \"xyes\" ; then\n    ac_fn_c_check_header_mongrel \"$LINENO\" \"valgrind/memcheck.h\" \"ac_cv_header_valgrind_memcheck_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_valgrind_memcheck_h\" = xyes; then :\n\n$as_echo \"#define VALGRIND_FIXES 1\" >>confdefs.h\n\nfi\n\n\n  fi\n\nfi\n\n\n\n# Checks for header files.\nfor ac_header in execinfo.h fcntl.h malloc.h netdb.h stdlib.h string.h unistd.h arpa/inet.h mach/mach.h netinet/in.h sys/file.h sys/socket.h termios.h\ndo :\n  as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\nac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\"\nif eval test \\\"x\\$\"$as_ac_Header\"\\\" = x\"yes\"; then :\n  cat >>confdefs.h <<_ACEOF\n#define `$as_echo \"HAVE_$ac_header\" | $as_tr_cpp` 1\n_ACEOF\n\nfi\n\ndone\n\n\n# Checks for typedefs, structures, and compiler characteristics.\nac_fn_c_check_type \"$LINENO\" \"size_t\" \"ac_cv_type_size_t\" \"$ac_includes_default\"\nif test \"x$ac_cv_type_size_t\" = xyes; then :\n\nelse\n\ncat >>confdefs.h <<_ACEOF\n#define size_t unsigned int\n_ACEOF\n\nfi\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for uid_t in sys/types.h\" >&5\n$as_echo_n \"checking for uid_t in sys/types.h... \" >&6; }\nif ${ac_cv_type_uid_t+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <sys/types.h>\n\n_ACEOF\nif (eval \"$ac_cpp conftest.$ac_ext\") 2>&5 |\n  $EGREP \"uid_t\" >/dev/null 2>&1; then :\n  ac_cv_type_uid_t=yes\nelse\n  ac_cv_type_uid_t=no\nfi\nrm -f conftest*\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_type_uid_t\" >&5\n$as_echo \"$ac_cv_type_uid_t\" >&6; }\nif test $ac_cv_type_uid_t = no; then\n\n$as_echo \"#define uid_t int\" >>confdefs.h\n\n\n$as_echo \"#define gid_t int\" >>confdefs.h\n\nfi\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for inline\" >&5\n$as_echo_n \"checking for inline... \" >&6; }\nif ${ac_cv_c_inline+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  ac_cv_c_inline=no\nfor ac_kw in inline __inline__ __inline; do\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#ifndef __cplusplus\ntypedef int foo_t;\nstatic $ac_kw foo_t static_foo () {return 0; }\n$ac_kw foo_t foo () {return 0; }\n#endif\n\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"; then :\n  ac_cv_c_inline=$ac_kw\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n  test \"$ac_cv_c_inline\" != no && break\ndone\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_inline\" >&5\n$as_echo \"$ac_cv_c_inline\" >&6; }\n\ncase $ac_cv_c_inline in\n  inline | yes) ;;\n  *)\n    case $ac_cv_c_inline in\n      no) ac_val=;;\n      *) ac_val=$ac_cv_c_inline;;\n    esac\n    cat >>confdefs.h <<_ACEOF\n#ifndef __cplusplus\n#define inline $ac_val\n#endif\n_ACEOF\n    ;;\nesac\n\n\n# Checks for library functions.\nfor ac_header in stdlib.h\ndo :\n  ac_fn_c_check_header_mongrel \"$LINENO\" \"stdlib.h\" \"ac_cv_header_stdlib_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_stdlib_h\" = xyes; then :\n  cat >>confdefs.h <<_ACEOF\n#define HAVE_STDLIB_H 1\n_ACEOF\n\nfi\n\ndone\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for GNU libc compatible malloc\" >&5\n$as_echo_n \"checking for GNU libc compatible malloc... \" >&6; }\nif ${ac_cv_func_malloc_0_nonnull+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  if test \"$cross_compiling\" = yes; then :\n  ac_cv_func_malloc_0_nonnull=no\nelse\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#if defined STDC_HEADERS || defined HAVE_STDLIB_H\n# include <stdlib.h>\n#else\nchar *malloc ();\n#endif\n\nint\nmain ()\n{\nreturn ! malloc (0);\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_run \"$LINENO\"; then :\n  ac_cv_func_malloc_0_nonnull=yes\nelse\n  ac_cv_func_malloc_0_nonnull=no\nfi\nrm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n  conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_malloc_0_nonnull\" >&5\n$as_echo \"$ac_cv_func_malloc_0_nonnull\" >&6; }\nif test $ac_cv_func_malloc_0_nonnull = yes; then :\n\n$as_echo \"#define HAVE_MALLOC 1\" >>confdefs.h\n\nelse\n  $as_echo \"#define HAVE_MALLOC 0\" >>confdefs.h\n\n   case \" $LIBOBJS \" in\n  *\" malloc.$ac_objext \"* ) ;;\n  *) LIBOBJS=\"$LIBOBJS malloc.$ac_objext\"\n ;;\nesac\n\n\n$as_echo \"#define malloc rpl_malloc\" >>confdefs.h\n\nfi\n\n\nfor ac_header in stdlib.h\ndo :\n  ac_fn_c_check_header_mongrel \"$LINENO\" \"stdlib.h\" \"ac_cv_header_stdlib_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_stdlib_h\" = xyes; then :\n  cat >>confdefs.h <<_ACEOF\n#define HAVE_STDLIB_H 1\n_ACEOF\n\nfi\n\ndone\n\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for GNU libc compatible realloc\" >&5\n$as_echo_n \"checking for GNU libc compatible realloc... \" >&6; }\nif ${ac_cv_func_realloc_0_nonnull+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n  if test \"$cross_compiling\" = yes; then :\n  ac_cv_func_realloc_0_nonnull=no\nelse\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#if defined STDC_HEADERS || defined HAVE_STDLIB_H\n# include <stdlib.h>\n#else\nchar *realloc ();\n#endif\n\nint\nmain ()\n{\nreturn ! realloc (0, 0);\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_run \"$LINENO\"; then :\n  ac_cv_func_realloc_0_nonnull=yes\nelse\n  ac_cv_func_realloc_0_nonnull=no\nfi\nrm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n  conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_realloc_0_nonnull\" >&5\n$as_echo \"$ac_cv_func_realloc_0_nonnull\" >&6; }\nif test $ac_cv_func_realloc_0_nonnull = yes; then :\n\n$as_echo \"#define HAVE_REALLOC 1\" >>confdefs.h\n\nelse\n  $as_echo \"#define HAVE_REALLOC 0\" >>confdefs.h\n\n   case \" $LIBOBJS \" in\n  *\" realloc.$ac_objext \"* ) ;;\n  *) LIBOBJS=\"$LIBOBJS realloc.$ac_objext\"\n ;;\nesac\n\n\n$as_echo \"#define realloc rpl_realloc\" >>confdefs.h\n\nfi\n\n\nfor ac_func in alarm endpwent memset memmove mkdir select socket strdup strndup uname\ndo :\n  as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\nac_fn_c_check_func \"$LINENO\" \"$ac_func\" \"$as_ac_var\"\nif eval test \\\"x\\$\"$as_ac_var\"\\\" = x\"yes\"; then :\n  cat >>confdefs.h <<_ACEOF\n#define `$as_echo \"HAVE_$ac_func\" | $as_tr_cpp` 1\n_ACEOF\n\nfi\ndone\n\n\n\n\n\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for __builtin_bswap32\" >&5\n$as_echo_n \"checking for __builtin_bswap32... \" >&6; }\nif ${ax_cv_have___builtin_bswap32+:} false; then :\n  $as_echo_n \"(cached) \" >&6\nelse\n\n        cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain ()\n{\n\n            __builtin_bswap32(0)\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_link \"$LINENO\"; then :\n  ax_cv_have___builtin_bswap32=yes\nelse\n  ax_cv_have___builtin_bswap32=no\nfi\nrm -f core conftest.err conftest.$ac_objext \\\n    conftest$ac_exeext conftest.$ac_ext\n\nfi\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ax_cv_have___builtin_bswap32\" >&5\n$as_echo \"$ax_cv_have___builtin_bswap32\" >&6; }\n\n    if test yes = $ax_cv_have___builtin_bswap32; then :\n\ncat >>confdefs.h <<_ACEOF\n#define HAVE___BUILTIN_BSWAP32 1\n_ACEOF\n\nfi\n\n\n\n\n\nac_config_files=\"$ac_config_files Makefile\"\n\ncat >confcache <<\\_ACEOF\n# This file is a shell script that caches the results of configure\n# tests run on this system so they can be shared between configure\n# scripts and configure runs, see configure's option --config-cache.\n# It is not useful on other systems.  If it contains results you don't\n# want to keep, you may remove or edit it.\n#\n# config.status only pays attention to the cache file if you give it\n# the --recheck option to rerun configure.\n#\n# `ac_cv_env_foo' variables (set or unset) will be overridden when\n# loading this file, other *unset* `ac_cv_foo' will be assigned the\n# following values.\n\n_ACEOF\n\n# The following way of writing the cache mishandles newlines in values,\n# but we know of no workaround that is simple, portable, and efficient.\n# So, we kill variables containing newlines.\n# Ultrix sh set writes to stderr and can't be redirected directly,\n# and sets the high bit in the cache file unless we assign to the vars.\n(\n  for ac_var in `(set) 2>&1 | sed -n 's/^\\([a-zA-Z_][a-zA-Z0-9_]*\\)=.*/\\1/p'`; do\n    eval ac_val=\\$$ac_var\n    case $ac_val in #(\n    *${as_nl}*)\n      case $ac_var in #(\n      *_cv_*) { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline\" >&5\n$as_echo \"$as_me: WARNING: cache variable $ac_var contains a newline\" >&2;} ;;\n      esac\n      case $ac_var in #(\n      _ | IFS | as_nl) ;; #(\n      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(\n      *) { eval $ac_var=; unset $ac_var;} ;;\n      esac ;;\n    esac\n  done\n\n  (set) 2>&1 |\n    case $as_nl`(ac_space=' '; set) 2>&1` in #(\n    *${as_nl}ac_space=\\ *)\n      # `set' does not quote correctly, so add quotes: double-quote\n      # substitution turns \\\\\\\\ into \\\\, and sed turns \\\\ into \\.\n      sed -n \\\n\t\"s/'/'\\\\\\\\''/g;\n\t  s/^\\\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\\\)=\\\\(.*\\\\)/\\\\1='\\\\2'/p\"\n      ;; #(\n    *)\n      # `set' quotes correctly as required by POSIX, so do not add quotes.\n      sed -n \"/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p\"\n      ;;\n    esac |\n    sort\n) |\n  sed '\n     /^ac_cv_env_/b end\n     t clear\n     :clear\n     s/^\\([^=]*\\)=\\(.*[{}].*\\)$/test \"${\\1+set}\" = set || &/\n     t end\n     s/^\\([^=]*\\)=\\(.*\\)$/\\1=${\\1=\\2}/\n     :end' >>confcache\nif diff \"$cache_file\" confcache >/dev/null 2>&1; then :; else\n  if test -w \"$cache_file\"; then\n    if test \"x$cache_file\" != \"x/dev/null\"; then\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: updating cache $cache_file\" >&5\n$as_echo \"$as_me: updating cache $cache_file\" >&6;}\n      if test ! -f \"$cache_file\" || test -h \"$cache_file\"; then\n\tcat confcache >\"$cache_file\"\n      else\n        case $cache_file in #(\n        */* | ?:*)\n\t  mv -f confcache \"$cache_file\"$$ &&\n\t  mv -f \"$cache_file\"$$ \"$cache_file\" ;; #(\n        *)\n\t  mv -f confcache \"$cache_file\" ;;\n\tesac\n      fi\n    fi\n  else\n    { $as_echo \"$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file\" >&5\n$as_echo \"$as_me: not updating unwritable cache $cache_file\" >&6;}\n  fi\nfi\nrm -f confcache\n\ntest \"x$prefix\" = xNONE && prefix=$ac_default_prefix\n# Let make expand exec_prefix.\ntest \"x$exec_prefix\" = xNONE && exec_prefix='${prefix}'\n\nDEFS=-DHAVE_CONFIG_H\n\nac_libobjs=\nac_ltlibobjs=\nU=\nfor ac_i in : $LIBOBJS; do test \"x$ac_i\" = x: && continue\n  # 1. Remove the extension, and $U if already installed.\n  ac_script='s/\\$U\\././;s/\\.o$//;s/\\.obj$//'\n  ac_i=`$as_echo \"$ac_i\" | sed \"$ac_script\"`\n  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR\n  #    will be set to the directory where LIBOBJS objects are built.\n  as_fn_append ac_libobjs \" \\${LIBOBJDIR}$ac_i\\$U.$ac_objext\"\n  as_fn_append ac_ltlibobjs \" \\${LIBOBJDIR}$ac_i\"'$U.lo'\ndone\nLIBOBJS=$ac_libobjs\n\nLTLIBOBJS=$ac_ltlibobjs\n\n\n\n: \"${CONFIG_STATUS=./config.status}\"\nac_write_fail=0\nac_clean_files_save=$ac_clean_files\nac_clean_files=\"$ac_clean_files $CONFIG_STATUS\"\n{ $as_echo \"$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS\" >&5\n$as_echo \"$as_me: creating $CONFIG_STATUS\" >&6;}\nas_write_fail=0\ncat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1\n#! $SHELL\n# Generated by $as_me.\n# Run this file to recreate the current configuration.\n# Compiler output produced by configure, useful for debugging\n# configure, is in config.log if it exists.\n\ndebug=false\nac_cs_recheck=false\nac_cs_silent=false\n\nSHELL=\\${CONFIG_SHELL-$SHELL}\nexport SHELL\n_ASEOF\ncat >>$CONFIG_STATUS <<\\_ASEOF || as_write_fail=1\n## -------------------- ##\n## M4sh Initialization. ##\n## -------------------- ##\n\n# Be more Bourne compatible\nDUALCASE=1; export DUALCASE # for MKS sh\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in #(\n  *posix*) :\n    set -o posix ;; #(\n  *) :\n     ;;\nesac\nfi\n\n\nas_nl='\n'\nexport as_nl\n# Printing a long string crashes Solaris 7 /usr/bin/printf.\nas_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\nas_echo=$as_echo$as_echo$as_echo$as_echo$as_echo\nas_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo\n# Prefer a ksh shell builtin over an external printf program on Solaris,\n# but without wasting forks for bash or zsh.\nif test -z \"$BASH_VERSION$ZSH_VERSION\" \\\n    && (test \"X`print -r -- $as_echo`\" = \"X$as_echo\") 2>/dev/null; then\n  as_echo='print -r --'\n  as_echo_n='print -rn --'\nelif (test \"X`printf %s $as_echo`\" = \"X$as_echo\") 2>/dev/null; then\n  as_echo='printf %s\\n'\n  as_echo_n='printf %s'\nelse\n  if test \"X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`\" = \"X-n $as_echo\"; then\n    as_echo_body='eval /usr/ucb/echo -n \"$1$as_nl\"'\n    as_echo_n='/usr/ucb/echo -n'\n  else\n    as_echo_body='eval expr \"X$1\" : \"X\\\\(.*\\\\)\"'\n    as_echo_n_body='eval\n      arg=$1;\n      case $arg in #(\n      *\"$as_nl\"*)\n\texpr \"X$arg\" : \"X\\\\(.*\\\\)$as_nl\";\n\targ=`expr \"X$arg\" : \".*$as_nl\\\\(.*\\\\)\"`;;\n      esac;\n      expr \"X$arg\" : \"X\\\\(.*\\\\)\" | tr -d \"$as_nl\"\n    '\n    export as_echo_n_body\n    as_echo_n='sh -c $as_echo_n_body as_echo'\n  fi\n  export as_echo_body\n  as_echo='sh -c $as_echo_body as_echo'\nfi\n\n# The user is always right.\nif test \"${PATH_SEPARATOR+set}\" != set; then\n  PATH_SEPARATOR=:\n  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {\n    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||\n      PATH_SEPARATOR=';'\n  }\nfi\n\n\n# IFS\n# We need space, tab and new line, in precisely that order.  Quoting is\n# there to prevent editors from complaining about space-tab.\n# (If _AS_PATH_WALK were called with IFS unset, it would disable word\n# splitting by setting IFS to empty value.)\nIFS=\" \"\"\t$as_nl\"\n\n# Find who we are.  Look in the path if we contain no directory separator.\nas_myself=\ncase $0 in #((\n  *[\\\\/]* ) as_myself=$0 ;;\n  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n    test -r \"$as_dir/$0\" && as_myself=$as_dir/$0 && break\n  done\nIFS=$as_save_IFS\n\n     ;;\nesac\n# We did not find ourselves, most probably we were run as `sh COMMAND'\n# in which case we are not to be found in the path.\nif test \"x$as_myself\" = x; then\n  as_myself=$0\nfi\nif test ! -f \"$as_myself\"; then\n  $as_echo \"$as_myself: error: cannot find myself; rerun with an absolute file name\" >&2\n  exit 1\nfi\n\n# Unset variables that we do not need and which cause bugs (e.g. in\n# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the \"|| exit 1\"\n# suppresses any \"Segmentation fault\" message there.  '((' could\n# trigger a bug in pdksh 5.2.14.\nfor as_var in BASH_ENV ENV MAIL MAILPATH\ndo eval test x\\${$as_var+set} = xset \\\n  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :\ndone\nPS1='$ '\nPS2='> '\nPS4='+ '\n\n# NLS nuisances.\nLC_ALL=C\nexport LC_ALL\nLANGUAGE=C\nexport LANGUAGE\n\n# CDPATH.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\n\n# as_fn_error STATUS ERROR [LINENO LOG_FD]\n# ----------------------------------------\n# Output \"`basename $0`: error: ERROR\" to stderr. If LINENO and LOG_FD are\n# provided, also output the error to LOG_FD, referencing LINENO. Then exit the\n# script with STATUS, using 1 if that was 0.\nas_fn_error ()\n{\n  as_status=$1; test $as_status -eq 0 && as_status=1\n  if test \"$4\"; then\n    as_lineno=${as_lineno-\"$3\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n    $as_echo \"$as_me:${as_lineno-$LINENO}: error: $2\" >&$4\n  fi\n  $as_echo \"$as_me: error: $2\" >&2\n  as_fn_exit $as_status\n} # as_fn_error\n\n\n# as_fn_set_status STATUS\n# -----------------------\n# Set $? to STATUS, without forking.\nas_fn_set_status ()\n{\n  return $1\n} # as_fn_set_status\n\n# as_fn_exit STATUS\n# -----------------\n# Exit the shell with STATUS, even in a \"trap 0\" or \"set -e\" context.\nas_fn_exit ()\n{\n  set +e\n  as_fn_set_status $1\n  exit $1\n} # as_fn_exit\n\n# as_fn_unset VAR\n# ---------------\n# Portably unset VAR.\nas_fn_unset ()\n{\n  { eval $1=; unset $1;}\n}\nas_unset=as_fn_unset\n# as_fn_append VAR VALUE\n# ----------------------\n# Append the text in VALUE to the end of the definition contained in VAR. Take\n# advantage of any shell optimizations that allow amortized linear growth over\n# repeated appends, instead of the typical quadratic growth present in naive\n# implementations.\nif (eval \"as_var=1; as_var+=2; test x\\$as_var = x12\") 2>/dev/null; then :\n  eval 'as_fn_append ()\n  {\n    eval $1+=\\$2\n  }'\nelse\n  as_fn_append ()\n  {\n    eval $1=\\$$1\\$2\n  }\nfi # as_fn_append\n\n# as_fn_arith ARG...\n# ------------------\n# Perform arithmetic evaluation on the ARGs, and store the result in the\n# global $as_val. Take advantage of shells that can avoid forks. The arguments\n# must be portable across $(()) and expr.\nif (eval \"test \\$(( 1 + 1 )) = 2\") 2>/dev/null; then :\n  eval 'as_fn_arith ()\n  {\n    as_val=$(( $* ))\n  }'\nelse\n  as_fn_arith ()\n  {\n    as_val=`expr \"$@\" || test $? -eq 1`\n  }\nfi # as_fn_arith\n\n\nif expr a : '\\(a\\)' >/dev/null 2>&1 &&\n   test \"X`expr 00001 : '.*\\(...\\)'`\" = X001; then\n  as_expr=expr\nelse\n  as_expr=false\nfi\n\nif (basename -- /) >/dev/null 2>&1 && test \"X`basename -- / 2>&1`\" = \"X/\"; then\n  as_basename=basename\nelse\n  as_basename=false\nfi\n\nif (as_dir=`dirname -- /` && test \"X$as_dir\" = X/) >/dev/null 2>&1; then\n  as_dirname=dirname\nelse\n  as_dirname=false\nfi\n\nas_me=`$as_basename -- \"$0\" ||\n$as_expr X/\"$0\" : '.*/\\([^/][^/]*\\)/*$' \\| \\\n\t X\"$0\" : 'X\\(//\\)$' \\| \\\n\t X\"$0\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n$as_echo X/\"$0\" |\n    sed '/^.*\\/\\([^/][^/]*\\)\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n\n# Avoid depending upon Character Ranges.\nas_cr_letters='abcdefghijklmnopqrstuvwxyz'\nas_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nas_cr_Letters=$as_cr_letters$as_cr_LETTERS\nas_cr_digits='0123456789'\nas_cr_alnum=$as_cr_Letters$as_cr_digits\n\nECHO_C= ECHO_N= ECHO_T=\ncase `echo -n x` in #(((((\n-n*)\n  case `echo 'xy\\c'` in\n  *c*) ECHO_T='\t';;\t# ECHO_T is single tab character.\n  xy)  ECHO_C='\\c';;\n  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null\n       ECHO_T='\t';;\n  esac;;\n*)\n  ECHO_N='-n';;\nesac\n\nrm -f conf$$ conf$$.exe conf$$.file\nif test -d conf$$.dir; then\n  rm -f conf$$.dir/conf$$.file\nelse\n  rm -f conf$$.dir\n  mkdir conf$$.dir 2>/dev/null\nfi\nif (echo >conf$$.file) 2>/dev/null; then\n  if ln -s conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s='ln -s'\n    # ... but there are two gotchas:\n    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.\n    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.\n    # In both cases, we have to default to `cp -pR'.\n    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||\n      as_ln_s='cp -pR'\n  elif ln conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s=ln\n  else\n    as_ln_s='cp -pR'\n  fi\nelse\n  as_ln_s='cp -pR'\nfi\nrm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file\nrmdir conf$$.dir 2>/dev/null\n\n\n# as_fn_mkdir_p\n# -------------\n# Create \"$as_dir\" as a directory, including parents if necessary.\nas_fn_mkdir_p ()\n{\n\n  case $as_dir in #(\n  -*) as_dir=./$as_dir;;\n  esac\n  test -d \"$as_dir\" || eval $as_mkdir_p || {\n    as_dirs=\n    while :; do\n      case $as_dir in #(\n      *\\'*) as_qdir=`$as_echo \"$as_dir\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;; #'(\n      *) as_qdir=$as_dir;;\n      esac\n      as_dirs=\"'$as_qdir' $as_dirs\"\n      as_dir=`$as_dirname -- \"$as_dir\" ||\n$as_expr X\"$as_dir\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)$' \\| \\\n\t X\"$as_dir\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n$as_echo X\"$as_dir\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n      test -d \"$as_dir\" && break\n    done\n    test -z \"$as_dirs\" || eval \"mkdir $as_dirs\"\n  } || test -d \"$as_dir\" || as_fn_error $? \"cannot create directory $as_dir\"\n\n\n} # as_fn_mkdir_p\nif mkdir -p . 2>/dev/null; then\n  as_mkdir_p='mkdir -p \"$as_dir\"'\nelse\n  test -d ./-p && rmdir ./-p\n  as_mkdir_p=false\nfi\n\n\n# as_fn_executable_p FILE\n# -----------------------\n# Test if FILE is an executable regular file.\nas_fn_executable_p ()\n{\n  test -f \"$1\" && test -x \"$1\"\n} # as_fn_executable_p\nas_test_x='test -x'\nas_executable_p=as_fn_executable_p\n\n# Sed expression to map a string onto a valid CPP name.\nas_tr_cpp=\"eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'\"\n\n# Sed expression to map a string onto a valid variable name.\nas_tr_sh=\"eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'\"\n\n\nexec 6>&1\n## ----------------------------------- ##\n## Main body of $CONFIG_STATUS script. ##\n## ----------------------------------- ##\n_ASEOF\ntest $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n# Save the log message, to keep $0 and so on meaningful, and to\n# report actual input values of CONFIG_FILES etc. instead of their\n# values after options handling.\nac_log=\"\nThis file was extended by telegram-cli $as_me 1.0, which was\ngenerated by GNU Autoconf 2.69.  Invocation command line was\n\n  CONFIG_FILES    = $CONFIG_FILES\n  CONFIG_HEADERS  = $CONFIG_HEADERS\n  CONFIG_LINKS    = $CONFIG_LINKS\n  CONFIG_COMMANDS = $CONFIG_COMMANDS\n  $ $0 $@\n\non `(hostname || uname -n) 2>/dev/null | sed 1q`\n\"\n\n_ACEOF\n\ncase $ac_config_files in *\"\n\"*) set x $ac_config_files; shift; ac_config_files=$*;;\nesac\n\ncase $ac_config_headers in *\"\n\"*) set x $ac_config_headers; shift; ac_config_headers=$*;;\nesac\n\n\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n# Files that config.status was made for.\nconfig_files=\"$ac_config_files\"\nconfig_headers=\"$ac_config_headers\"\n\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nac_cs_usage=\"\\\n\\`$as_me' instantiates files and other configuration actions\nfrom templates according to the current configuration.  Unless the files\nand actions are specified as TAGs, all are instantiated by default.\n\nUsage: $0 [OPTION]... [TAG]...\n\n  -h, --help       print this help, then exit\n  -V, --version    print version number and configuration settings, then exit\n      --config     print configuration, then exit\n  -q, --quiet, --silent\n                   do not print progress messages\n  -d, --debug      don't remove temporary files\n      --recheck    update $as_me by reconfiguring in the same conditions\n      --file=FILE[:TEMPLATE]\n                   instantiate the configuration file FILE\n      --header=FILE[:TEMPLATE]\n                   instantiate the configuration header FILE\n\nConfiguration files:\n$config_files\n\nConfiguration headers:\n$config_headers\n\nReport bugs to the package provider.\"\n\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\nac_cs_config=\"`$as_echo \"$ac_configure_args\" | sed 's/^ //; s/[\\\\\"\"\\`\\$]/\\\\\\\\&/g'`\"\nac_cs_version=\"\\\\\ntelegram-cli config.status 1.0\nconfigured by $0, generated by GNU Autoconf 2.69,\n  with options \\\\\"\\$ac_cs_config\\\\\"\n\nCopyright (C) 2012 Free Software Foundation, Inc.\nThis config.status script is free software; the Free Software Foundation\ngives unlimited permission to copy, distribute and modify it.\"\n\nac_pwd='$ac_pwd'\nsrcdir='$srcdir'\ntest -n \"\\$AWK\" || AWK=awk\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n# The default lists apply if the user does not specify any file.\nac_need_defaults=:\nwhile test $# != 0\ndo\n  case $1 in\n  --*=?*)\n    ac_option=`expr \"X$1\" : 'X\\([^=]*\\)='`\n    ac_optarg=`expr \"X$1\" : 'X[^=]*=\\(.*\\)'`\n    ac_shift=:\n    ;;\n  --*=)\n    ac_option=`expr \"X$1\" : 'X\\([^=]*\\)='`\n    ac_optarg=\n    ac_shift=:\n    ;;\n  *)\n    ac_option=$1\n    ac_optarg=$2\n    ac_shift=shift\n    ;;\n  esac\n\n  case $ac_option in\n  # Handling of the options.\n  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)\n    ac_cs_recheck=: ;;\n  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )\n    $as_echo \"$ac_cs_version\"; exit ;;\n  --config | --confi | --conf | --con | --co | --c )\n    $as_echo \"$ac_cs_config\"; exit ;;\n  --debug | --debu | --deb | --de | --d | -d )\n    debug=: ;;\n  --file | --fil | --fi | --f )\n    $ac_shift\n    case $ac_optarg in\n    *\\'*) ac_optarg=`$as_echo \"$ac_optarg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    '') as_fn_error $? \"missing file argument\" ;;\n    esac\n    as_fn_append CONFIG_FILES \" '$ac_optarg'\"\n    ac_need_defaults=false;;\n  --header | --heade | --head | --hea )\n    $ac_shift\n    case $ac_optarg in\n    *\\'*) ac_optarg=`$as_echo \"$ac_optarg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    esac\n    as_fn_append CONFIG_HEADERS \" '$ac_optarg'\"\n    ac_need_defaults=false;;\n  --he | --h)\n    # Conflict between --help and --header\n    as_fn_error $? \"ambiguous option: \\`$1'\nTry \\`$0 --help' for more information.\";;\n  --help | --hel | -h )\n    $as_echo \"$ac_cs_usage\"; exit ;;\n  -q | -quiet | --quiet | --quie | --qui | --qu | --q \\\n  | -silent | --silent | --silen | --sile | --sil | --si | --s)\n    ac_cs_silent=: ;;\n\n  # This is an error.\n  -*) as_fn_error $? \"unrecognized option: \\`$1'\nTry \\`$0 --help' for more information.\" ;;\n\n  *) as_fn_append ac_config_targets \" $1\"\n     ac_need_defaults=false ;;\n\n  esac\n  shift\ndone\n\nac_configure_extra_args=\n\nif $ac_cs_silent; then\n  exec 6>/dev/null\n  ac_configure_extra_args=\"$ac_configure_extra_args --silent\"\nfi\n\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\nif \\$ac_cs_recheck; then\n  set X $SHELL '$0' $ac_configure_args \\$ac_configure_extra_args --no-create --no-recursion\n  shift\n  \\$as_echo \"running CONFIG_SHELL=$SHELL \\$*\" >&6\n  CONFIG_SHELL='$SHELL'\n  export CONFIG_SHELL\n  exec \"\\$@\"\nfi\n\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nexec 5>>config.log\n{\n  echo\n  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX\n## Running $as_me. ##\n_ASBOX\n  $as_echo \"$ac_log\"\n} >&5\n\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n\n# Handling of arguments.\nfor ac_config_target in $ac_config_targets\ndo\n  case $ac_config_target in\n    \"config.h\") CONFIG_HEADERS=\"$CONFIG_HEADERS config.h\" ;;\n    \"Makefile\") CONFIG_FILES=\"$CONFIG_FILES Makefile\" ;;\n\n  *) as_fn_error $? \"invalid argument: \\`$ac_config_target'\" \"$LINENO\" 5;;\n  esac\ndone\n\n\n# If the user did not use the arguments to specify the items to instantiate,\n# then the envvar interface is used.  Set only those that are not.\n# We use the long form for the default assignment because of an extremely\n# bizarre bug on SunOS 4.1.3.\nif $ac_need_defaults; then\n  test \"${CONFIG_FILES+set}\" = set || CONFIG_FILES=$config_files\n  test \"${CONFIG_HEADERS+set}\" = set || CONFIG_HEADERS=$config_headers\nfi\n\n# Have a temporary directory for convenience.  Make it in the build tree\n# simply because there is no reason against having it here, and in addition,\n# creating and moving files from /tmp can sometimes cause problems.\n# Hook for its removal unless debugging.\n# Note that there is a small window in which the directory will not be cleaned:\n# after its creation but before its name has been assigned to `$tmp'.\n$debug ||\n{\n  tmp= ac_tmp=\n  trap 'exit_status=$?\n  : \"${ac_tmp:=$tmp}\"\n  { test ! -d \"$ac_tmp\" || rm -fr \"$ac_tmp\"; } && exit $exit_status\n' 0\n  trap 'as_fn_exit 1' 1 2 13 15\n}\n# Create a (secure) tmp directory for tmp files.\n\n{\n  tmp=`(umask 077 && mktemp -d \"./confXXXXXX\") 2>/dev/null` &&\n  test -d \"$tmp\"\n}  ||\n{\n  tmp=./conf$$-$RANDOM\n  (umask 077 && mkdir \"$tmp\")\n} || as_fn_error $? \"cannot create a temporary directory in .\" \"$LINENO\" 5\nac_tmp=$tmp\n\n# Set up the scripts for CONFIG_FILES section.\n# No need to generate them if there are no CONFIG_FILES.\n# This happens for instance with `./config.status config.h'.\nif test -n \"$CONFIG_FILES\"; then\n\n\nac_cr=`echo X | tr X '\\015'`\n# On cygwin, bash can eat \\r inside `` if the user requested igncr.\n# But we know of no other shell where ac_cr would be empty at this\n# point, so we can use a bashism as a fallback.\nif test \"x$ac_cr\" = x; then\n  eval ac_cr=\\$\\'\\\\r\\'\nfi\nac_cs_awk_cr=`$AWK 'BEGIN { print \"a\\rb\" }' </dev/null 2>/dev/null`\nif test \"$ac_cs_awk_cr\" = \"a${ac_cr}b\"; then\n  ac_cs_awk_cr='\\\\r'\nelse\n  ac_cs_awk_cr=$ac_cr\nfi\n\necho 'BEGIN {' >\"$ac_tmp/subs1.awk\" &&\n_ACEOF\n\n\n{\n  echo \"cat >conf$$subs.awk <<_ACEOF\" &&\n  echo \"$ac_subst_vars\" | sed 's/.*/&!$&$ac_delim/' &&\n  echo \"_ACEOF\"\n} >conf$$subs.sh ||\n  as_fn_error $? \"could not make $CONFIG_STATUS\" \"$LINENO\" 5\nac_delim_num=`echo \"$ac_subst_vars\" | grep -c '^'`\nac_delim='%!_!# '\nfor ac_last_try in false false false false false :; do\n  . ./conf$$subs.sh ||\n    as_fn_error $? \"could not make $CONFIG_STATUS\" \"$LINENO\" 5\n\n  ac_delim_n=`sed -n \"s/.*$ac_delim\\$/X/p\" conf$$subs.awk | grep -c X`\n  if test $ac_delim_n = $ac_delim_num; then\n    break\n  elif $ac_last_try; then\n    as_fn_error $? \"could not make $CONFIG_STATUS\" \"$LINENO\" 5\n  else\n    ac_delim=\"$ac_delim!$ac_delim _$ac_delim!! \"\n  fi\ndone\nrm -f conf$$subs.sh\n\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\ncat >>\"\\$ac_tmp/subs1.awk\" <<\\\\_ACAWK &&\n_ACEOF\nsed -n '\nh\ns/^/S[\"/; s/!.*/\"]=/\np\ng\ns/^[^!]*!//\n:repl\nt repl\ns/'\"$ac_delim\"'$//\nt delim\n:nl\nh\ns/\\(.\\{148\\}\\)..*/\\1/\nt more1\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\\\\n\"\\\\/\np\nn\nb repl\n:more1\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"\\\\/\np\ng\ns/.\\{148\\}//\nt nl\n:delim\nh\ns/\\(.\\{148\\}\\)..*/\\1/\nt more2\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"/\np\nb\n:more2\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"\\\\/\np\ng\ns/.\\{148\\}//\nt delim\n' <conf$$subs.awk | sed '\n/^[^\"\"]/{\n  N\n  s/\\n//\n}\n' >>$CONFIG_STATUS || ac_write_fail=1\nrm -f conf$$subs.awk\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n_ACAWK\ncat >>\"\\$ac_tmp/subs1.awk\" <<_ACAWK &&\n  for (key in S) S_is_set[key] = 1\n  FS = \"\u0007\"\n\n}\n{\n  line = $ 0\n  nfields = split(line, field, \"@\")\n  substed = 0\n  len = length(field[1])\n  for (i = 2; i < nfields; i++) {\n    key = field[i]\n    keylen = length(key)\n    if (S_is_set[key]) {\n      value = S[key]\n      line = substr(line, 1, len) \"\" value \"\" substr(line, len + keylen + 3)\n      len += length(value) + length(field[++i])\n      substed = 1\n    } else\n      len += 1 + keylen\n  }\n\n  print line\n}\n\n_ACAWK\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nif sed \"s/$ac_cr//\" < /dev/null > /dev/null 2>&1; then\n  sed \"s/$ac_cr\\$//; s/$ac_cr/$ac_cs_awk_cr/g\"\nelse\n  cat\nfi < \"$ac_tmp/subs1.awk\" > \"$ac_tmp/subs.awk\" \\\n  || as_fn_error $? \"could not setup config files machinery\" \"$LINENO\" 5\n_ACEOF\n\n# VPATH may cause trouble with some makes, so we remove sole $(srcdir),\n# ${srcdir} and @srcdir@ entries from VPATH if srcdir is \".\", strip leading and\n# trailing colons and then remove the whole line if VPATH becomes empty\n# (actually we leave an empty line to preserve line numbers).\nif test \"x$srcdir\" = x.; then\n  ac_vpsub='/^[\t ]*VPATH[\t ]*=[\t ]*/{\nh\ns///\ns/^/:/\ns/[\t ]*$/:/\ns/:\\$(srcdir):/:/g\ns/:\\${srcdir}:/:/g\ns/:@srcdir@:/:/g\ns/^:*//\ns/:*$//\nx\ns/\\(=[\t ]*\\).*/\\1/\nG\ns/\\n//\ns/^[^=]*=[\t ]*$//\n}'\nfi\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nfi # test -n \"$CONFIG_FILES\"\n\n# Set up the scripts for CONFIG_HEADERS section.\n# No need to generate them if there are no CONFIG_HEADERS.\n# This happens for instance with `./config.status Makefile'.\nif test -n \"$CONFIG_HEADERS\"; then\ncat >\"$ac_tmp/defines.awk\" <<\\_ACAWK ||\nBEGIN {\n_ACEOF\n\n# Transform confdefs.h into an awk script `defines.awk', embedded as\n# here-document in config.status, that substitutes the proper values into\n# config.h.in to produce config.h.\n\n# Create a delimiter string that does not exist in confdefs.h, to ease\n# handling of long lines.\nac_delim='%!_!# '\nfor ac_last_try in false false :; do\n  ac_tt=`sed -n \"/$ac_delim/p\" confdefs.h`\n  if test -z \"$ac_tt\"; then\n    break\n  elif $ac_last_try; then\n    as_fn_error $? \"could not make $CONFIG_HEADERS\" \"$LINENO\" 5\n  else\n    ac_delim=\"$ac_delim!$ac_delim _$ac_delim!! \"\n  fi\ndone\n\n# For the awk script, D is an array of macro values keyed by name,\n# likewise P contains macro parameters if any.  Preserve backslash\n# newline sequences.\n\nac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*\nsed -n '\ns/.\\{148\\}/&'\"$ac_delim\"'/g\nt rset\n:rset\ns/^[\t ]*#[\t ]*define[\t ][\t ]*/ /\nt def\nd\n:def\ns/\\\\$//\nt bsnl\ns/[\"\\\\]/\\\\&/g\ns/^ \\('\"$ac_word_re\"'\\)\\(([^()]*)\\)[\t ]*\\(.*\\)/P[\"\\1\"]=\"\\2\"\\\nD[\"\\1\"]=\" \\3\"/p\ns/^ \\('\"$ac_word_re\"'\\)[\t ]*\\(.*\\)/D[\"\\1\"]=\" \\2\"/p\nd\n:bsnl\ns/[\"\\\\]/\\\\&/g\ns/^ \\('\"$ac_word_re\"'\\)\\(([^()]*)\\)[\t ]*\\(.*\\)/P[\"\\1\"]=\"\\2\"\\\nD[\"\\1\"]=\" \\3\\\\\\\\\\\\n\"\\\\/p\nt cont\ns/^ \\('\"$ac_word_re\"'\\)[\t ]*\\(.*\\)/D[\"\\1\"]=\" \\2\\\\\\\\\\\\n\"\\\\/p\nt cont\nd\n:cont\nn\ns/.\\{148\\}/&'\"$ac_delim\"'/g\nt clear\n:clear\ns/\\\\$//\nt bsnlc\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"/p\nd\n:bsnlc\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\\\\\\\\\\\\n\"\\\\/p\nb cont\n' <confdefs.h | sed '\ns/'\"$ac_delim\"'/\"\\\\\\\n\"/g' >>$CONFIG_STATUS || ac_write_fail=1\n\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n  for (key in D) D_is_set[key] = 1\n  FS = \"\u0007\"\n}\n/^[\\t ]*#[\\t ]*(define|undef)[\\t ]+$ac_word_re([\\t (]|\\$)/ {\n  line = \\$ 0\n  split(line, arg, \" \")\n  if (arg[1] == \"#\") {\n    defundef = arg[2]\n    mac1 = arg[3]\n  } else {\n    defundef = substr(arg[1], 2)\n    mac1 = arg[2]\n  }\n  split(mac1, mac2, \"(\") #)\n  macro = mac2[1]\n  prefix = substr(line, 1, index(line, defundef) - 1)\n  if (D_is_set[macro]) {\n    # Preserve the white space surrounding the \"#\".\n    print prefix \"define\", macro P[macro] D[macro]\n    next\n  } else {\n    # Replace #undef with comments.  This is necessary, for example,\n    # in the case of _POSIX_SOURCE, which is predefined and required\n    # on some systems where configure will not decide to define it.\n    if (defundef == \"undef\") {\n      print \"/*\", prefix defundef, macro, \"*/\"\n      next\n    }\n  }\n}\n{ print }\n_ACAWK\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n  as_fn_error $? \"could not setup config headers machinery\" \"$LINENO\" 5\nfi # test -n \"$CONFIG_HEADERS\"\n\n\neval set X \"  :F $CONFIG_FILES  :H $CONFIG_HEADERS    \"\nshift\nfor ac_tag\ndo\n  case $ac_tag in\n  :[FHLC]) ac_mode=$ac_tag; continue;;\n  esac\n  case $ac_mode$ac_tag in\n  :[FHL]*:*);;\n  :L* | :C*:*) as_fn_error $? \"invalid tag \\`$ac_tag'\" \"$LINENO\" 5;;\n  :[FH]-) ac_tag=-:-;;\n  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;\n  esac\n  ac_save_IFS=$IFS\n  IFS=:\n  set x $ac_tag\n  IFS=$ac_save_IFS\n  shift\n  ac_file=$1\n  shift\n\n  case $ac_mode in\n  :L) ac_source=$1;;\n  :[FH])\n    ac_file_inputs=\n    for ac_f\n    do\n      case $ac_f in\n      -) ac_f=\"$ac_tmp/stdin\";;\n      *) # Look for the file first in the build tree, then in the source tree\n\t # (if the path is not absolute).  The absolute path cannot be DOS-style,\n\t # because $ac_f cannot contain `:'.\n\t test -f \"$ac_f\" ||\n\t   case $ac_f in\n\t   [\\\\/$]*) false;;\n\t   *) test -f \"$srcdir/$ac_f\" && ac_f=\"$srcdir/$ac_f\";;\n\t   esac ||\n\t   as_fn_error 1 \"cannot find input file: \\`$ac_f'\" \"$LINENO\" 5;;\n      esac\n      case $ac_f in *\\'*) ac_f=`$as_echo \"$ac_f\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;; esac\n      as_fn_append ac_file_inputs \" '$ac_f'\"\n    done\n\n    # Let's still pretend it is `configure' which instantiates (i.e., don't\n    # use $as_me), people would be surprised to read:\n    #    /* config.h.  Generated by config.status.  */\n    configure_input='Generated from '`\n\t  $as_echo \"$*\" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'\n\t`' by configure.'\n    if test x\"$ac_file\" != x-; then\n      configure_input=\"$ac_file.  $configure_input\"\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: creating $ac_file\" >&5\n$as_echo \"$as_me: creating $ac_file\" >&6;}\n    fi\n    # Neutralize special characters interpreted by sed in replacement strings.\n    case $configure_input in #(\n    *\\&* | *\\|* | *\\\\* )\n       ac_sed_conf_input=`$as_echo \"$configure_input\" |\n       sed 's/[\\\\\\\\&|]/\\\\\\\\&/g'`;; #(\n    *) ac_sed_conf_input=$configure_input;;\n    esac\n\n    case $ac_tag in\n    *:-:* | *:-) cat >\"$ac_tmp/stdin\" \\\n      || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5 ;;\n    esac\n    ;;\n  esac\n\n  ac_dir=`$as_dirname -- \"$ac_file\" ||\n$as_expr X\"$ac_file\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$ac_file\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$ac_file\" : 'X\\(//\\)$' \\| \\\n\t X\"$ac_file\" : 'X\\(/\\)' \\| . 2>/dev/null ||\n$as_echo X\"$ac_file\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n  as_dir=\"$ac_dir\"; as_fn_mkdir_p\n  ac_builddir=.\n\ncase \"$ac_dir\" in\n.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;\n*)\n  ac_dir_suffix=/`$as_echo \"$ac_dir\" | sed 's|^\\.[\\\\/]||'`\n  # A \"..\" for each directory in $ac_dir_suffix.\n  ac_top_builddir_sub=`$as_echo \"$ac_dir_suffix\" | sed 's|/[^\\\\/]*|/..|g;s|/||'`\n  case $ac_top_builddir_sub in\n  \"\") ac_top_builddir_sub=. ac_top_build_prefix= ;;\n  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;\n  esac ;;\nesac\nac_abs_top_builddir=$ac_pwd\nac_abs_builddir=$ac_pwd$ac_dir_suffix\n# for backward compatibility:\nac_top_builddir=$ac_top_build_prefix\n\ncase $srcdir in\n  .)  # We are building in place.\n    ac_srcdir=.\n    ac_top_srcdir=$ac_top_builddir_sub\n    ac_abs_top_srcdir=$ac_pwd ;;\n  [\\\\/]* | ?:[\\\\/]* )  # Absolute name.\n    ac_srcdir=$srcdir$ac_dir_suffix;\n    ac_top_srcdir=$srcdir\n    ac_abs_top_srcdir=$srcdir ;;\n  *) # Relative name.\n    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix\n    ac_top_srcdir=$ac_top_build_prefix$srcdir\n    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;\nesac\nac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix\n\n\n  case $ac_mode in\n  :F)\n  #\n  # CONFIG_FILE\n  #\n\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n# If the template does not know about datarootdir, expand it.\n# FIXME: This hack should be removed a few years after 2.60.\nac_datarootdir_hack=; ac_datarootdir_seen=\nac_sed_dataroot='\n/datarootdir/ {\n  p\n  q\n}\n/@datadir@/p\n/@docdir@/p\n/@infodir@/p\n/@localedir@/p\n/@mandir@/p'\ncase `eval \"sed -n \\\"\\$ac_sed_dataroot\\\" $ac_file_inputs\"` in\n*datarootdir*) ac_datarootdir_seen=yes;;\n*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting\" >&5\n$as_echo \"$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting\" >&2;}\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n  ac_datarootdir_hack='\n  s&@datadir@&$datadir&g\n  s&@docdir@&$docdir&g\n  s&@infodir@&$infodir&g\n  s&@localedir@&$localedir&g\n  s&@mandir@&$mandir&g\n  s&\\\\\\${datarootdir}&$datarootdir&g' ;;\nesac\n_ACEOF\n\n# Neutralize VPATH when `$srcdir' = `.'.\n# Shell code in configure.ac might set extrasub.\n# FIXME: do we really want to maintain this feature?\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\nac_sed_extra=\"$ac_vpsub\n$extrasub\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n:t\n/@[a-zA-Z_][a-zA-Z_0-9]*@/!b\ns|@configure_input@|$ac_sed_conf_input|;t t\ns&@top_builddir@&$ac_top_builddir_sub&;t t\ns&@top_build_prefix@&$ac_top_build_prefix&;t t\ns&@srcdir@&$ac_srcdir&;t t\ns&@abs_srcdir@&$ac_abs_srcdir&;t t\ns&@top_srcdir@&$ac_top_srcdir&;t t\ns&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t\ns&@builddir@&$ac_builddir&;t t\ns&@abs_builddir@&$ac_abs_builddir&;t t\ns&@abs_top_builddir@&$ac_abs_top_builddir&;t t\n$ac_datarootdir_hack\n\"\neval sed \\\"\\$ac_sed_extra\\\" \"$ac_file_inputs\" | $AWK -f \"$ac_tmp/subs.awk\" \\\n  >$ac_tmp/out || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n\ntest -z \"$ac_datarootdir_hack$ac_datarootdir_seen\" &&\n  { ac_out=`sed -n '/\\${datarootdir}/p' \"$ac_tmp/out\"`; test -n \"$ac_out\"; } &&\n  { ac_out=`sed -n '/^[\t ]*datarootdir[\t ]*:*=/p' \\\n      \"$ac_tmp/out\"`; test -z \"$ac_out\"; } &&\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \\`datarootdir'\nwhich seems to be undefined.  Please make sure it is defined\" >&5\n$as_echo \"$as_me: WARNING: $ac_file contains a reference to the variable \\`datarootdir'\nwhich seems to be undefined.  Please make sure it is defined\" >&2;}\n\n  rm -f \"$ac_tmp/stdin\"\n  case $ac_file in\n  -) cat \"$ac_tmp/out\" && rm -f \"$ac_tmp/out\";;\n  *) rm -f \"$ac_file\" && mv \"$ac_tmp/out\" \"$ac_file\";;\n  esac \\\n  || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n ;;\n  :H)\n  #\n  # CONFIG_HEADER\n  #\n  if test x\"$ac_file\" != x-; then\n    {\n      $as_echo \"/* $configure_input  */\" \\\n      && eval '$AWK -f \"$ac_tmp/defines.awk\"' \"$ac_file_inputs\"\n    } >\"$ac_tmp/config.h\" \\\n      || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n    if diff \"$ac_file\" \"$ac_tmp/config.h\" >/dev/null 2>&1; then\n      { $as_echo \"$as_me:${as_lineno-$LINENO}: $ac_file is unchanged\" >&5\n$as_echo \"$as_me: $ac_file is unchanged\" >&6;}\n    else\n      rm -f \"$ac_file\"\n      mv \"$ac_tmp/config.h\" \"$ac_file\" \\\n\t|| as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n    fi\n  else\n    $as_echo \"/* $configure_input  */\" \\\n      && eval '$AWK -f \"$ac_tmp/defines.awk\"' \"$ac_file_inputs\" \\\n      || as_fn_error $? \"could not create -\" \"$LINENO\" 5\n  fi\n ;;\n\n\n  esac\n\ndone # for ac_tag\n\n\nas_fn_exit 0\n_ACEOF\nac_clean_files=$ac_clean_files_save\n\ntest $ac_write_fail = 0 ||\n  as_fn_error $? \"write failure creating $CONFIG_STATUS\" \"$LINENO\" 5\n\n\n# configure is writing to config.log, and then calls config.status.\n# config.status does its own redirection, appending to config.log.\n# Unfortunately, on DOS this fails, as config.log is still kept open\n# by configure, so config.status won't be able to write to it; its\n# output is simply discarded.  So we exec the FD to /dev/null,\n# effectively closing config.log, so it can be properly (re)opened and\n# appended to by config.status.  When coming back to configure, we\n# need to make the FD available again.\nif test \"$no_create\" != yes; then\n  ac_cs_success=:\n  ac_config_status_args=\n  test \"$silent\" = yes &&\n    ac_config_status_args=\"$ac_config_status_args --quiet\"\n  exec 5>/dev/null\n  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false\n  exec 5>>config.log\n  # Use ||, not &&, to avoid exiting from the if with $? = 1, which\n  # would make configure fail if this is the last instruction.\n  $ac_cs_success || as_fn_exit 1\nfi\nif test -n \"$ac_unrecognized_opts\" && test \"$enable_option_checking\" != no; then\n  { $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts\" >&5\n$as_echo \"$as_me: WARNING: unrecognized options: $ac_unrecognized_opts\" >&2;}\nfi\n\n\n"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 5.9248046875,
          "content": "AC_PREREQ([2.68])\nAC_INIT([telegram-cli], [1.0])\nAC_CONFIG_SRCDIR([config.h.in])\nAC_CONFIG_HEADERS([config.h])\n\nm4_include([ax_lua.m4])\nm4_include([ax_python.m4])\nm4_include([m4_ax_check_openssl.m4])\nm4_include([m4_ax_check_zlib.m4])\nm4_include([m4-ax_gcc_builtin.m4])\n\n# Checks for programs.\nAC_PROG_CC\n\n# BSD locations for headers and libraries from packages, Linux locations for self-compiled stuff.\nCPPFLAGS=\"$CPPFLAGS -I/usr/local/include\"\nLDFLAGS=\"$LDFLAGS -L/usr/local/lib\"\n\n# Checks for libraries.\nAC_SEARCH_LIBS([clock_gettime], [rt])\nAC_SEARCH_LIBS([backtrace], [execinfo])\nAC_CHECK_LIB([event], [event_base_new], [], [AC_MSG_ERROR([no libevent found])])\n\nEVENT_VER=\"\"\n\nAC_CHECK_HEADER(event2/event.h, [AC_DEFINE([EVENT_V2], [1], [Use libevent v2])], [\n  AC_CHECK_HEADER(event.h, [AC_DEFINE([EVENT_V1], [1], [Use libevent v1])], [AC_MSG_ERROR([no libevent found])])\n  ])\n\nEXTRA_LIBS=\"\"\n\n#     OPENSSL_INCLUDES to the include directives required\n#     OPENSSL_LIBS to the -l directives required\n#     OPENSSL_LDFLAGS to the -L or -R flags required\n\nAC_ARG_ENABLE(openssl,[  --disable-openssl\t  disables OpenSSL, and don't link against it\n\t\t\t  (this can't read *.pub files, though.)],\n  [ \n  if test \"x$enableval\" = \"xno\" ; then    \n  \tAC_DEFINE([TGL_AVOID_OPENSSL],[1],[avoid OpenSSL entirely, use libgcrypt instead (this can't read *.pub files, though.)])\n    AC_CHECK_LIB([gcrypt], [gcry_mpi_snatch], [], [AC_MSG_ERROR([\"Need libgcrypt >= 1.60\"])])\n  else\n    # Don't be annoying, so don't inform the user about --disable-openssl\n    AX_CHECK_OPENSSL(,[AC_MSG_ERROR([No openssl found.])])\n  fi \n  ],[\n  AX_CHECK_OPENSSL(,[AC_MSG_ERROR([No openssl found. With --disable-openssl, libtgl will use libgcrypt instead.])])\n  ])\nAX_CHECK_ZLIB(, [AC_MSG_ERROR([No zlib found])])\n\nAC_CHECK_LIB([readline], [rl_save_prompt], [ EXTRA_LIBS=\"${EXTRA_LIBS} -lreadline\" ; ], [AC_MSG_ERROR([no libreadline found])])\n\nAC_MSG_CHECKING([for libconfig])\nAC_ARG_ENABLE(libconfig,[--enable-libconfig/--disable-libconfig],\n  [ \n  if test \"x$enableval\" = \"xno\" ; then\n    AC_MSG_RESULT([disabled])\n  else\n    AC_MSG_RESULT([enabled])\n    AC_CHECK_LIB([config],[config_init],[],AC_MSG_ERROR([No libconfig found. Try --disable-libconfig]))\n  fi \n  ],[\n    AC_MSG_RESULT([enabled])\n    AC_CHECK_LIB([config],[config_init],[],AC_MSG_ERROR([No libconfig found. Try --disable-libconfig]))\n  ])\n\nAC_ARG_ENABLE(extf,[--enable-extf/--disable-extf],\n  [ \n  if test \"x$enableval\" = \"xno\" ; then    \n    AC_DEFINE([DISABLE_EXTF],[1],[disable extf queries])\n  fi \n  ],[\n  ])\n\nAC_MSG_CHECKING([for liblua])\nAC_ARG_ENABLE(liblua,[--enable-liblua/--disable-liblua],\n  [ \n  if test \"x$enableval\" = \"xno\" ; then\n    AC_MSG_RESULT([disabled])\n  else\n    AC_MSG_RESULT([enabled])\n    AX_PROG_LUA([],[],\n      [\n        AX_LUA_HEADERS([],[AC_MSG_ERROR([No lua headers found. Try --disable-liblua])])\n        AX_LUA_LIBS([],[AC_MSG_ERROR([No lua libs found. Try --disable-liblua])])\n        [EXTRA_LIBS=\"${EXTRA_LIBS} ${LUA_LIB}\" ; ]\n        [CPPFLAGS=\"${CPPFLAGS} ${LUA_INCLUDE}\" ; ]\n        AC_DEFINE(USE_LUA,1,[use lua])\n      ],\n      [\n        AC_MSG_ERROR([No lua found. Try --disable-liblua])\n      ])\n  fi \n  ],[\n    AC_MSG_RESULT([enabled])\n    AX_PROG_LUA([],[],\n      [\n        AX_LUA_HEADERS([],[AC_MSG_ERROR([No lua headers found. Try --disable-liblua])])\n        AX_LUA_LIBS([],[AC_MSG_ERROR([No lua libs found. Try --disable-liblua])])\n        [EXTRA_LIBS=\"${EXTRA_LIBS} ${LUA_LIB}\" ; ]\n        [CPPFLAGS=\"${CPPFLAGS} ${LUA_INCLUDE}\" ; ]\n        AC_DEFINE(USE_LUA,1,[use lua])\n      ],\n      [\n        AC_MSG_ERROR([No lua found. Try --disable-liblua])\n      ])\n  ])\n\nAC_MSG_CHECKING([for python])\nAC_ARG_ENABLE(python,[--enable-python/--disable-python],\n  [\n    if test \"x$enableval\" = \"xyes\" ; then\n      AC_MSG_RESULT([disabled])\n    else\n      AC_MSG_RESULT([enabled])\n\n      AX_PYTHON()\n      AC_SUBST([PYTHON_FOUND])\n      if test $PYTHON_FOUND = no ; then\n        AC_MSG_ERROR([No supported python lib version found. Try --disable-python])\n      else\n        AC_SUBST([PYTHON_LIBS])\n        AC_SUBST([PYTHON_CFLAGS])\n        EXTRA_LIBS=\"${EXTRA_LIBS} -l${PYTHON_LIB}\"\n        CPPFLAGS=\"${CPPFLAGS} -I${PYTHON_INCLUDE_DIR}\"\n        AC_DEFINE(USE_PYTHON,1,[use python])\n      fi\n    fi\n  ],[\n      AC_MSG_RESULT([disabled])\n  ])\n\n\n\nAC_MSG_CHECKING([for libjansson])\nAC_ARG_ENABLE(json,[--enable-json/--disable-json],\n  [ \n  if test \"x$enableval\" = \"xno\" ; then\n    AC_MSG_RESULT([disabled])\n  else\n    AC_MSG_RESULT([enabled])\n    AC_CHECK_LIB([jansson],[json_array_set_new],[],AC_MSG_ERROR([No libjansson found. Try --disable-json]))\n    AC_DEFINE(USE_JSON,1,[use json])\n  fi \n  ],[\n    AC_MSG_RESULT([enabled])\n    AC_CHECK_LIB([jansson],[json_array_set_new],[],AC_MSG_ERROR([No libjansson found. Try --disable-json]))\n    AC_DEFINE(USE_JSON,1,[use json])\n  ])\n\n#check for custom prog name\nAC_MSG_CHECKING([progname])\nAC_ARG_WITH(progname,[--with-progname=<name>],\n  [ \n  if test \"x$with_progname\" = \"xno\" ; then\n    AC_MSG_RESULT([default])\n  elif test \"x$with_progname\" = \"xyes\" ; then\n    AC_MSG_RESULT([default])\n  else\n    AC_MSG_RESULT([\"$with_progname\"])\n    AC_DEFINE_UNQUOTED([PROG_NAME], [\"$with_progname\"], [Use custom prog name])\n  fi\n  ],[\n    AC_MSG_RESULT([default])\n  ])\n\nAC_ARG_ENABLE(valgrind,[--enable-valgrind/--disable-valgrind],\n  [ \n  if test \"x$enableval\" = \"xyes\" ; then\n    AC_CHECK_HEADER(valgrind/memcheck.h, [AC_DEFINE([VALGRIND_FIXES], [1], [fixed for correct valgrind work])], [\n    ])\n  fi\n  ],[\n  ])\n    \n    \n# Checks for header files.\nAC_CHECK_HEADERS([execinfo.h fcntl.h malloc.h netdb.h stdlib.h string.h unistd.h arpa/inet.h mach/mach.h netinet/in.h sys/file.h sys/socket.h termios.h])\n\n# Checks for typedefs, structures, and compiler characteristics.\nAC_TYPE_SIZE_T\nAC_TYPE_UID_T\nAC_C_INLINE\n\n# Checks for library functions.\nAC_FUNC_MALLOC\nAC_FUNC_REALLOC\nAC_CHECK_FUNCS([alarm endpwent memset memmove mkdir select socket strdup strndup uname])\n\nAX_GCC_BUILTIN(__builtin_bswap32)\n\nAC_SUBST(EXTRA_LIBS)\nAC_CONFIG_FILES([Makefile])\nAC_OUTPUT\n\n"
        },
        {
          "name": "debian",
          "type": "tree",
          "content": null
        },
        {
          "name": "event-old.h",
          "type": "blob",
          "size": 1.6806640625,
          "content": "#ifndef __EVENT_OLD_H__\n#define __EVENT_OLD_H__\n\n#include <assert.h>\n#include <stdlib.h>\n\n#define BEV_EVENT_READ EVBUFFER_READ\n#define BEV_EVENT_WRITE EVBUFFER_WRITE\n#define BEV_EVENT_EOF EVBUFFER_EOF\n#define BEV_EVENT_ERROR EVBUFFER_ERROR\n#define BEV_EVENT_TIMEOUT EVBUFFER_TIMEOUT\n\ntypedef int evutil_socket_t;\n  \nstatic inline struct event *event_new (struct event_base *base, int fd, int what, void(*callback)(int, short, void *), void *arg) __attribute__ ((unused));\nstatic inline struct event *event_new (struct event_base *base, int fd, int what, void(*callback)(int, short, void *), void *arg) {\n  struct event *ev = malloc (sizeof (*ev));  \n  event_set (ev, fd, what, callback, arg);\n  event_base_set (base, ev);\n  return ev;\n}\n  \nstatic inline struct event *evtimer_new (struct event_base *base, void(*callback)(int, short, void *), void *arg) __attribute__ ((unused));\nstatic inline struct event *evtimer_new (struct event_base *base, void(*callback)(int, short, void *), void *arg) {\n  struct event *ev = malloc (sizeof (*ev));\n  event_set (ev, -1, 0, callback, arg);\n  event_base_set (base, ev);\n  return ev;\n}\n\nstatic void event_free (struct event *ev) __attribute__ ((unused));\nstatic void event_free (struct event *ev) {\n  event_del (ev);\n  free (ev);\n}\n\nstatic struct bufferevent *bufferevent_socket_new (struct event_base *base, int fd, int flags) __attribute__ ((unused));\nstatic struct bufferevent *bufferevent_socket_new (struct event_base *base, int fd, int flags) {\n  assert (!flags);\n  struct bufferevent *bev = bufferevent_new(fd, 0, 0, 0, 0);\n  bufferevent_base_set (base, bev);\n  return bev;\n}\n\nstatic inline void *event_get_callback_arg(const struct event *ev) {\n  return ev->ev_arg;\n}\n#endif\n"
        },
        {
          "name": "gentoo",
          "type": "tree",
          "content": null
        },
        {
          "name": "interface.c",
          "type": "blob",
          "size": 141.8193359375,
          "content": "/*\n    This file is part of telegram-cli.\n\n    Telegram-cli is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n\n    Telegram-cli is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this telegram-cli.  If not, see <http://www.gnu.org/licenses/>.\n\n    Copyright Vitaly Valtman 2013-2015\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef USE_PYTHON\n#  include \"python-tg.h\"\n#endif\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef READLINE_GNU\n#include <readline/readline.h>\n#include <readline/history.h>\n#else\n#include <readline/readline.h>\n#include <readline/history.h>\n#endif\n#include <unistd.h>\n\n//#include \"queries.h\"\n\n#include \"interface.h\"\n#include \"telegram.h\"\n\n#ifdef EVENT_V2\n#include <event2/event.h>\n#include <event2/bufferevent.h>\n#include <event2/buffer.h>\n#else\n#include <event.h>\n#include \"event-old.h\"\n#endif\n//#include \"auto/constants.h\"\n//#include \"tools.h\"\n//#include \"structures.h\"\n\n#ifdef USE_LUA\n#  include \"lua-tg.h\"\n#endif\n\n\n//#include \"mtproto-common.h\"\n\n#include <tgl/tgl.h>\n#include <tgl/tgl-queries.h>\n#include \"loop.h\"\n\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\n#ifdef __APPLE__\n#define OPEN_BIN \"open %s\"\n#else\n#define OPEN_BIN \"xdg-open %s\"\n#endif\n\n#ifdef USE_JSON\n#  include <jansson.h>\n#  include \"json-tg.h\"\n#endif\n\n#include \"tgl/mtproto-common.h\"\n#include \"auto/auto-store.h\"\n#include \"auto/auto-fetch-ds.h\"\n#include \"auto/auto-types.h\"\n#include \"auto/auto-free-ds.h\"\n\n#include <errno.h>\n\n#include \"tgl/tree.h\"\n\nstruct username_peer_pair {\n  const char *username;\n  tgl_peer_t *peer;\n};\n\n#define username_peer_pair_cmp(a,b) strcmp (a->username, b->username)\nDEFINE_TREE (username_peer_pair, struct username_peer_pair *, username_peer_pair_cmp, NULL)\nstruct tree_username_peer_pair *username_peer_pair;\n\nstruct username_peer_pair *current_map;\n\n#define ALLOW_MULT 1\nchar *default_prompt = \"> \";\n\nextern int read_one_string;\nextern char one_string[];\nextern int one_string_len;\nextern char *one_string_prompt;\nextern int one_string_flags;\nextern int enable_json;\nint disable_auto_accept;\nint msg_num_mode;\nint permanent_msg_id_mode;\nint permanent_peer_id_mode;\nint disable_colors;\nextern int alert_sound;\nextern int binlog_read;\nextern char *home_directory;\nint do_html;\n\nint safe_quit;\n\nint in_readline;\nint readline_active;\n\nint log_level;\n\nchar *line_ptr;\n\nint in_chat_mode;\ntgl_peer_id_t chat_mode_id;\nextern int readline_disabled;\n\nextern int disable_output;\n\nstruct in_ev *notify_ev;\n\nextern int usfd;\nextern int sfd;\nextern int use_ids;\n\nextern int daemonize;\n\nextern struct tgl_state *TLS;\nint readline_deactivated;\n\nvoid fail_interface (struct tgl_state *TLS, struct in_ev *ev, int error_code, const char *format, ...) __attribute__ (( format (printf, 4, 5)));\nvoid event_incoming (struct bufferevent *bev, short what, void *_arg);\n\nint is_same_word (const char *s, size_t l, const char *word) {\n  return s && word && strlen (word) == l && !memcmp (s, word, l);\n}\n\nstatic void skip_wspc (void) {\n  while (*line_ptr && ((unsigned char)*line_ptr) <= ' ') {\n    line_ptr ++;\n  }\n}\n\nstatic char *cur_token;\nstatic int cur_token_len;\nstatic int cur_token_end_str;\nstatic int cur_token_quoted;\n\n#define SOCKET_ANSWER_MAX_SIZE (1 << 25)\nstatic char socket_answer[SOCKET_ANSWER_MAX_SIZE + 1];\nstatic int socket_answer_pos = -1;\n\nvoid socket_answer_start (void) {\n  socket_answer_pos = 0;\n}\n\nstatic void socket_answer_add_printf (const char *format, ...) __attribute__ ((format (printf, 1, 2)));\nvoid socket_answer_add_printf (const char *format, ...) {\n  if (socket_answer_pos < 0) { return; }\n  va_list ap;\n  va_start (ap, format);\n  socket_answer_pos += vsnprintf (socket_answer + socket_answer_pos, SOCKET_ANSWER_MAX_SIZE - socket_answer_pos, format, ap);\n  va_end (ap);\n  if (socket_answer_pos > SOCKET_ANSWER_MAX_SIZE) { socket_answer_pos = -1; }\n}\n\nvoid socket_answer_end (struct in_ev *ev) {\n  if (ev->bev) {\n    static char s[100];\n    sprintf (s, \"ANSWER %d\\n\", socket_answer_pos);\n    bufferevent_write (ev->bev, s, strlen (s));\n    bufferevent_write (ev->bev, socket_answer, socket_answer_pos);\n    bufferevent_write (ev->bev, \"\\n\", 1);\n  }\n  socket_answer_pos = -1;\n}\n\n#define mprintf(ev,...) \\\n  if (ev) { socket_answer_add_printf (__VA_ARGS__); } \\\n  else { printf (__VA_ARGS__); } \n\n#define mprint_start(ev,...) \\\n  if (!ev) { print_start (__VA_ARGS__); } \\\n  else { socket_answer_start (); }\n  \n#define mprint_end(ev,...) \\\n  if (!ev) { print_end (__VA_ARGS__); } \\\n  else { socket_answer_end (ev); }\n\n#define mpush_color(ev,...) \\\n  if (!ev) { push_color (__VA_ARGS__); }\n\n#define mpop_color(ev,...) \\\n  if (!ev) { pop_color (__VA_ARGS__); }\n\nstatic void unescape_token (char *start, char *end) {\n  static char cur_token_buff[(1 << 20) + 1];\n  cur_token_len = 0;\n  cur_token = cur_token_buff;\n  while (start < end) {\n    assert (cur_token_len < (1 << 20));\n    switch (*start) {\n    case '\\\\':\n      start ++;\n      switch (*start) {\n      case 'n':\n        cur_token[cur_token_len ++] = '\\n';\n        break;\n      case 'r':\n        cur_token[cur_token_len ++] = '\\r';\n        break;\n      case 't':\n        cur_token[cur_token_len ++] = '\\t';\n        break;\n      case 'b':\n        cur_token[cur_token_len ++] = '\\b';\n        break;\n      case 'a':\n        cur_token[cur_token_len ++] = '\\a';\n        break;\n      default:\n        cur_token[cur_token_len ++] = *start;\n        break;\n      }\n      break;\n    default:\n      cur_token[cur_token_len ++] = *start;;\n      break;\n    }\n    start ++;\n  }\n  cur_token[cur_token_len] = 0;\n}\n\nint force_end_mode;\nstatic void next_token (void) {\n  skip_wspc ();\n  cur_token_end_str = 0;\n  cur_token_quoted = 0;\n  if (!*line_ptr) {\n    cur_token_len = 0;\n    cur_token_end_str = 1;\n    return;\n  }\n  char c = *line_ptr;\n  char *start = line_ptr;\n  if (c == '\"' || c == '\\'') {\n    cur_token_quoted = 1;\n    line_ptr ++;\n    int esc = 0;\n    while (*line_ptr && (esc || *line_ptr != c)) {\n      if (*line_ptr == '\\\\') {\n        esc = 1 - esc;\n      } else {\n        esc = 0;\n      }\n      line_ptr ++;\n    }\n    if (!*line_ptr) {\n      cur_token_len = -2;\n    } else {\n      unescape_token (start + 1, line_ptr);\n      line_ptr ++;\n    }\n  } else {\n    while (*line_ptr && ((unsigned char)*line_ptr) > ' ') {\n      line_ptr ++;\n    }\n    cur_token = start;\n    cur_token_len = line_ptr - start;\n    cur_token_end_str = (!force_end_mode) && (*line_ptr == 0);\n  }\n}\n\nvoid next_token_end (void) {\n  skip_wspc ();\n  \n  if (*line_ptr && *line_ptr != '\"' && *line_ptr != '\\'') {\n    cur_token_quoted = 0;\n    cur_token = line_ptr;\n    while (*line_ptr) { line_ptr ++; }\n    cur_token_len = line_ptr - cur_token;\n    while (((unsigned char)cur_token[cur_token_len - 1]) <= ' ' && cur_token_len >= 0) { \n      cur_token_len --;\n    }\n    assert (cur_token_len > 0);\n    cur_token_end_str = !force_end_mode;\n    return;\n  } else {\n    if (*line_ptr) {\n      next_token ();\n      skip_wspc ();\n      if (*line_ptr) {\n        cur_token_len = -1; \n      }\n    } else {\n      next_token ();\n    }\n  }\n}\n\nvoid next_token_end_ac (void) {\n  skip_wspc ();\n  \n  if (*line_ptr && *line_ptr != '\"' && *line_ptr != '\\'') {\n    cur_token_quoted = 0;\n    cur_token = line_ptr;\n    while (*line_ptr) { line_ptr ++; }\n    cur_token_len = line_ptr - cur_token;\n    assert (cur_token_len > 0);\n    cur_token_end_str = !force_end_mode;\n    return;\n  } else {\n    if (*line_ptr) {\n      next_token ();\n      skip_wspc ();\n      if (*line_ptr) {\n        cur_token_len = -1; \n      }\n    } else {\n      next_token ();\n    }\n  }\n}\n\n#define NOT_FOUND (int)0x80000000\ntgl_peer_id_t TGL_PEER_NOT_FOUND = {.peer_id = NOT_FOUND};\n\nlong long cur_token_int (void) {\n  if (cur_token_len <= 0) {\n    return NOT_FOUND;\n  } else {\n    char c = cur_token[cur_token_len];\n    cur_token[cur_token_len] = 0;\n    char *end = 0;\n    long long x = strtoll (cur_token, &end, 0);\n    cur_token[cur_token_len] = c;\n    if (end != cur_token + cur_token_len) {\n      return NOT_FOUND;\n    } else {\n      return x;\n    }\n  }\n}\n\nint hex2int (char c) {\n  if (c >= '0' && c <= '9') { return c - '0'; }\n  if (c >= 'a' && c <= 'f') { return c - 'a' + 10; }\n  assert (0);\n  return 0;\n}\n\nchar *print_permanent_msg_id (tgl_message_id_t id) {\n  static char buf[2 * sizeof (tgl_message_id_t) + 1];\n  \n  unsigned char *s = (void *)&id;\n  int i;\n  for (i = 0; i < (int)sizeof (tgl_message_id_t); i++) {\n    sprintf (buf + 2 * i, \"%02x\", (unsigned)s[i]);\n  }\n  return buf;\n}\n\nchar *print_permanent_peer_id (tgl_peer_id_t id) {\n  static char buf[2 * sizeof (tgl_peer_id_t) + 2];\n  buf[0] = '$';\n  \n  unsigned char *s = (void *)&id;\n  int i;\n  for (i = 0; i < (int)sizeof (tgl_peer_id_t); i++) {\n    sprintf (buf + 1 + 2 * i, \"%02x\", (unsigned)s[i]);\n  }\n  return buf;\n}\n\ntgl_message_id_t parse_input_msg_id (const char *s, int l) {\n  if (!s || l <= 0) {\n    tgl_message_id_t id;\n    memset (&id, 0, sizeof (id));\n    id.peer_type = 0;\n    return id;\n  } else {    \n    tgl_message_id_t id;\n    memset (&id, 0, sizeof (id));\n\n    if (l == 2 * sizeof (tgl_message_id_t)) {\n      int i;\n      for (i = 0; i < (int)sizeof (tgl_message_id_t); i++) {\n        if (\n          (s[i] < '0' || s[i] > '9') &&\n          (s[i] < 'a' || s[i] > 'f')\n        ) { \n          id.peer_type = 0;\n          return id;\n        }\n      }\n      unsigned char *d = (void *)&id;\n      for (i = 0; i < (int)sizeof (tgl_message_id_t); i++) {\n        d[i] = hex2int (s[2 * i]) * 16 + hex2int (s[2 * i + 1]);\n      }     \n      return id;\n    } else {\n      char *sc = tstrndup (s, l);\n      char *end = 0;\n      long long x = strtoll (sc, &end, 0);\n      tfree_str (sc);\n      if (end != sc + l) {\n        id.peer_type = 0;  \n      } else {\n        id.peer_type = TGL_PEER_TEMP_ID;\n        id.id = x;\n      }\n      return id;\n    }\n  }\n}\n\ntgl_message_id_t cur_token_msg_id (void) {\n  return parse_input_msg_id (cur_token, cur_token_len);\n}\n\ndouble cur_token_double (void) {\n  if (cur_token_len <= 0) {\n    return NOT_FOUND;\n  } else {\n    char c = cur_token[cur_token_len];\n    cur_token[cur_token_len] = 0;\n    char *end = 0;\n    double x = strtod (cur_token, &end);\n    cur_token[cur_token_len] = c;\n    if (end != cur_token + cur_token_len) {\n      return NOT_FOUND;\n    } else {\n      return x;\n    }\n  }\n}\n\ntgl_peer_id_t parse_input_peer_id (const char *s, int l, int mask) {\n  if (!s || l <= 0) { return TGL_PEER_NOT_FOUND; }\n\n  if (*s == '$') {\n    s ++;\n    l --;\n    if (l != 2 * sizeof (tgl_peer_id_t)) {\n      return TGL_PEER_NOT_FOUND;\n    }\n\n    tgl_peer_id_t res;\n    unsigned char *r = (void *)&res;\n    int i;\n    for (i = 0; i < l; i++) {\n      if ((s[i] < '0' || s[i] > '9') && \n          (s[i] < 'a' || s[i] > 'f')) {\n        return TGL_PEER_NOT_FOUND;\n      }\n    }\n    for (i = 0; i < (int)sizeof (tgl_peer_id_t); i++) {\n      r[i] = hex2int (s[2 * i]) * 16 + hex2int (s[2 * i + 1]);\n    }\n\n    if (mask && tgl_get_peer_type (res) != mask) {\n      return TGL_PEER_NOT_FOUND;\n    }\n\n    return res;\n  }\n\n  if (*s == '@') {\n    s ++;\n    l --;\n    char *tmp = tstrndup (s, l);\n    struct username_peer_pair *p = tree_lookup_username_peer_pair (username_peer_pair, (void *)&tmp);\n    tfree_str (tmp);\n    if (p && (!mask || tgl_get_peer_type (p->peer->id) == mask)) {\n      return p->peer->id;\n    } else {\n      return TGL_PEER_NOT_FOUND;\n    }\n  }\n\n  const char *ss[] = {\"user#id\", \"user#\", \"chat#id\", \"chat#\", \"secret_chat#id\", \"secret_chat#\", \"channel#id\", \"channel#\"};\n  int tt[] = {TGL_PEER_USER, TGL_PEER_USER, TGL_PEER_CHAT, TGL_PEER_CHAT, TGL_PEER_ENCR_CHAT, TGL_PEER_ENCR_CHAT, TGL_PEER_CHANNEL, TGL_PEER_CHANNEL};\n\n  char *sc = tstrndup (s, l);\n\n  int i;\n  for (i = 0; i < 8; i++) if (!mask || mask == tt[i]) {\n    int x = strlen (ss[i]);\n    if (l > x && !memcmp (s, ss[i], x)) {\n      int r = atoi (sc + x);\n      tfree_str (sc);\n      if (r < 0) { return TGL_PEER_NOT_FOUND; }\n      tgl_peer_t *P = tgl_peer_get (TLS, tgl_set_peer_id (tt[i], r));\n      if (!P) { return TGL_PEER_NOT_FOUND; }\n      return P->id;\n    }\n  }\n\n  tgl_peer_t *P = tgl_peer_get_by_name (TLS, sc); \n  tfree_str (sc);\n  \n  if (P && (!mask || tgl_get_peer_type (P->id) == mask)) {\n    return P->id;\n  } else {\n    return TGL_PEER_NOT_FOUND;\n  }\n}\n\ntgl_peer_id_t cur_token_user (void) {\n  return parse_input_peer_id (cur_token, cur_token_len, TGL_PEER_USER);\n}\n\ntgl_peer_id_t cur_token_chat (void) {\n  return parse_input_peer_id (cur_token, cur_token_len, TGL_PEER_CHAT);\n}\n\ntgl_peer_id_t cur_token_encr_chat (void) {\n  return parse_input_peer_id (cur_token, cur_token_len, TGL_PEER_ENCR_CHAT);\n}\n\ntgl_peer_id_t cur_token_channel (void) {\n  return parse_input_peer_id (cur_token, cur_token_len, TGL_PEER_CHANNEL);\n}\n\ntgl_peer_id_t cur_token_peer (void) {\n  return parse_input_peer_id (cur_token, cur_token_len, 0);\n}\n/*\nstatic tgl_peer_t *mk_peer (tgl_peer_id_t id) {\n  if (tgl_get_peer_type (id) == NOT_FOUND) { return 0; }\n  tgl_peer_t *P = tgl_peer_get (TLS, id);\n  if (!P) {\n    if (tgl_get_peer_type (id) == TGL_PEER_USER) {\n      tgl_insert_empty_user (TLS, tgl_get_peer_id (id));\n    }\n    if (tgl_get_peer_type (id) == TGL_PEER_CHAT) {\n      tgl_insert_empty_chat (TLS, tgl_get_peer_id (id));\n    }\n    P = tgl_peer_get (TLS, id);\n  }\n  return P;\n}*/\n\nchar *get_default_prompt (void) {\n  static char buf[1000];\n  int l = 0;\n  if (in_chat_mode) {\n    tgl_peer_t *U = tgl_peer_get (TLS, chat_mode_id);\n    assert (U && U->print_name);\n    l += snprintf (buf + l, 999 - l, COLOR_RED \"%.*s \" COLOR_NORMAL, 100, U->print_name);\n  }\n  if (TLS->unread_messages || TLS->cur_uploading_bytes || TLS->cur_downloading_bytes) {\n    l += snprintf (buf + l, 999 - l, COLOR_RED \"[\");\n    int ok = 0;\n    if (TLS->unread_messages) {\n      l += snprintf (buf + l, 999 - l, \"%d unread\", TLS->unread_messages);\n      ok = 1;\n    }\n    if (TLS->cur_uploading_bytes) {\n      if (ok) { *(buf + l) = ' '; l ++; }\n      ok = 1;\n      l += snprintf (buf + l, 999 - l, \"%lld%%Up\", 100 * TLS->cur_uploaded_bytes / TLS->cur_uploading_bytes);\n    }\n    if (TLS->cur_downloading_bytes) {\n      if (ok) { *(buf + l) = ' '; l ++; }\n      ok = 1;\n      l += snprintf (buf + l, 999 - l, \"%lld%%Down\", 100 * TLS->cur_downloaded_bytes / TLS->cur_downloading_bytes);\n    }\n    l += snprintf (buf + l, 999 - l, \"]\" COLOR_NORMAL);\n    l += snprintf (buf + l, 999 - l, \"%s\", default_prompt);\n    return buf;\n  } \n  l += snprintf (buf + l, 999 - l, \"%s\", default_prompt);\n  return buf;\n}\n\nchar *complete_none (const char *text, int state) {\n  return 0;\n}\n\n\nvoid set_prompt (const char *s) {\n  if (readline_disabled) { return; }\n  rl_set_prompt (s);\n}\n\nvoid update_prompt (void) {\n  if (readline_disabled) {\n    fflush (stdout);\n    return;\n  }\n  if (read_one_string) { return; }\n  print_start ();\n  set_prompt (get_default_prompt ());\n  if (readline_active) {\n    rl_redisplay ();\n  }\n  print_end ();\n}\n\nchar *modifiers[] = {\n  \"[offline]\",\n  \"[enable_preview]\",\n  \"[disable_preview]\",\n  \"[html]\",\n  \"[reply=\",\n  0\n};\n\nchar *in_chat_commands[] = {\n  \"/exit\",\n  \"/quit\",\n  \"/history\",\n  \"/read\",\n  0\n};\n\nenum command_argument {\n  ca_none,\n  ca_user,\n  ca_chat,\n  ca_secret_chat,\n  ca_channel,\n  ca_peer,\n  ca_file_name,\n  ca_file_name_end,\n  ca_period,\n  ca_number,\n  ca_double,\n  ca_string_end,\n  ca_msg_string_end,\n  ca_string,\n  ca_modifier,\n  ca_command,\n  ca_extf,\n  ca_msg_id,\n\n\n  ca_optional = 256\n};\n\nstruct arg {\n  int flags;\n  union {\n    //tgl_peer_t *P;\n    //struct tgl_message *M;\n    char *str;\n    long long num;\n    double dval;\n    tgl_message_id_t msg_id;\n    tgl_peer_id_t peer_id;\n  };\n};\n\nstruct command {\n  char *name;\n  enum command_argument args[10];\n  void (*fun)(struct command *command, int arg_num, struct arg args[], struct in_ev *ev);\n  char *desc;\n  void *arg;\n};\n\n\nint offline_mode;\nint reply_id;\nint disable_msg_preview;\n\nvoid print_user_list_gw (struct tgl_state *TLS, void *extra, int success, int num, struct tgl_user *UL[]);\nvoid print_msg_list_gw (struct tgl_state *TLS, void *extra, int success, int num, struct tgl_message *ML[]);\nvoid print_msg_list_history_gw (struct tgl_state *TLS, void *extra, int success, int num, struct tgl_message *ML[]);\nvoid print_msg_list_success_gw (struct tgl_state *TLS, void *extra, int success, int num, struct tgl_message *ML[]);\nvoid print_dialog_list_gw (struct tgl_state *TLS, void *extra, int success, int size, tgl_peer_id_t peers[], tgl_message_id_t *last_msg_id[], int unread_count[]);\nvoid print_chat_info_gw (struct tgl_state *TLS, void *extra, int success, struct tgl_chat *C);\nvoid print_channel_info_gw (struct tgl_state *TLS, void *extra, int success, struct tgl_channel *C);\nvoid print_user_info_gw (struct tgl_state *TLS, void *extra, int success, struct tgl_user *C);\nvoid print_filename_gw (struct tgl_state *TLS, void *extra, int success, const char *name);\nvoid print_string_gw (struct tgl_state *TLS, void *extra, int success, const char *name);\nvoid open_filename_gw (struct tgl_state *TLS, void *extra, int success, const char *name);\nvoid print_secret_chat_gw (struct tgl_state *TLS, void *extra, int success, struct tgl_secret_chat *E);\nvoid print_card_gw (struct tgl_state *TLS, void *extra, int success, int size, int *card);\nvoid print_user_gw (struct tgl_state *TLS, void *extra, int success, struct tgl_user *U);\nvoid print_peer_gw (struct tgl_state *TLS, void *extra, int success, tgl_peer_t *U);\nvoid print_msg_gw (struct tgl_state *TLS, void *extra, int success, struct tgl_message *M);\nvoid print_msg_success_gw (struct tgl_state *TLS, void *extra, int success, struct tgl_message *M);\nvoid print_encr_chat_success_gw (struct tgl_state *TLS, void *extra, int success, struct tgl_secret_chat *E);;\nvoid print_success_gw (struct tgl_state *TLS, void *extra, int success);\n\nstruct command commands[];\n\n/* {{{ client methods */\nvoid do_help (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { mprint_start (ev); }\n  int total = 0;\n  mpush_color (ev, COLOR_YELLOW);\n  struct command *cmd = commands;\n  while (cmd->name) {\n    if (!args[0].str || !strcmp (args[0].str, cmd->name)) {\n      mprintf (ev, \"%s\\n\", cmd->desc);\n      total ++;\n    }\n    cmd ++;\n  }\n  if (!total) {\n    assert (arg_num == 1);\n    mprintf (ev, \"Unknown command '%s'\\n\", args[0].str);\n  }\n  mpop_color (ev);\n  if (ev) { mprint_end (ev); }\n  if (!ev) {\n    fflush (stdout);\n  }\n}\n\nvoid do_get_terms_of_service (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (!arg_num);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_get_terms_of_service (TLS, print_string_gw, ev);\n}\n\nvoid do_stats (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (!arg_num);\n  static char stat_buf[1 << 15];\n  tgl_print_stat (TLS, stat_buf, (1 << 15) - 1);\n  if (ev) { mprint_start (ev); }\n  mprintf (ev, \"%s\\n\", stat_buf);\n  if (ev) { mprint_end (ev); }\n  if (!ev) {\n    fflush (stdout);\n  }\n}\n\nvoid do_show_license (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (!arg_num);\n  static char *b = \n#include \"LICENSE.h\"\n  ;\n  if (ev) { mprint_start (ev); }\n  mprintf (ev, \"%s\", b);\n  if (ev) { mprint_end (ev); }\n}\n\nvoid do_quit (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  if (daemonize) {\n    event_incoming (ev->bev, BEV_EVENT_EOF, ev);\n  }\n  do_halt (0);\n}\n\nvoid do_safe_quit (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  if (daemonize) {\n    event_incoming (ev->bev, BEV_EVENT_EOF, ev);\n  }\n  safe_quit = 1;\n}\n\nvoid do_set (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  int num = args[1].num;\n  if (!strcmp (args[0].str, \"debug_verbosity\")) {\n    tgl_set_verbosity (TLS, num); \n  } else if (!strcmp (args[0].str, \"log_level\")) {\n    log_level = num;\n  } else if (!strcmp (args[0].str, \"msg_num\")) {\n    msg_num_mode = num;\n  } else if (!strcmp (args[0].str, \"alert\")) {\n    alert_sound = num;\n  }\n}\n\nvoid do_chat_with_peer (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  if (!ev) {\n    in_chat_mode = 1;\n    chat_mode_id = args[0].peer_id;\n  }\n}\n\nvoid do_main_session (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  if (notify_ev && !--notify_ev->refcnt) {\n    free (notify_ev);\n  }\n  notify_ev = ev;\n  if (ev) { ev->refcnt ++; }\n}\n\nvoid do_version (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (!arg_num);\n  if (ev) { mprint_start (ev); }\n  mpush_color (ev, COLOR_YELLOW);\n  mprintf (ev, \"Telegram-cli version %s (uses tgl version %s)\\n\", TELEGRAM_CLI_VERSION, TGL_VERSION);\n  #ifdef TGL_AVOID_OPENSSL \n    mprintf (ev, \"uses libgcrypt for encryption\\n\");\n  #else\n    mprintf (ev, \"uses libopenssl for encryption\\n\");\n  #endif\n  mpop_color (ev);\n  if (ev) { mprint_end (ev); }\n  if (!ev) {\n    fflush (stdout);\n  }\n\n}\n/* }}} */\n\n#define ARG2STR_DEF(n,def) args[n].str ? args[n].str : def, args[n].str ? strlen (args[n].str) : strlen (def)\n#define ARG2STR(n) args[n].str, args[n].str ? strlen (args[n].str) : 0\n\n/* {{{ WORK WITH ACCOUNT */\n\nvoid do_set_password (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_set_password (TLS, ARG2STR_DEF(0, \"empty\"), print_success_gw, ev);\n}\n/* }}} */\n\n/* {{{ SENDING MESSAGES */\n\nvoid do_msg (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  vlogprintf (E_DEBUG, \"reply_id=%d, disable=%d\\n\", reply_id, disable_msg_preview);\n  tgl_do_send_message (TLS, args[0].peer_id, ARG2STR(1), TGL_SEND_MSG_FLAG_REPLY(reply_id) | disable_msg_preview | do_html, NULL, print_msg_success_gw, ev);\n}\n\nvoid do_post (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  vlogprintf (E_DEBUG, \"reply_id=%d, disable=%d\\n\", reply_id, disable_msg_preview);\n  tgl_do_send_message (TLS, args[0].peer_id, ARG2STR(1), TGL_SEND_MSG_FLAG_REPLY(reply_id) | disable_msg_preview | TGLMF_POST_AS_CHANNEL | do_html, NULL, print_msg_success_gw, ev);\n}\n\nvoid do_msg_kbd (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 3);\n  if (ev) { ev->refcnt ++; }\n\n  clear_packet ();  \n  if (tglf_store_type (TLS, ARG2STR(1), TYPE_TO_PARAM (reply_markup)) < 0) {\n    fail_interface (TLS, ev, ENOSYS, \"can not parse reply markup\");    \n    return;\n  }\n  in_ptr = packet_buffer;\n  in_end = packet_ptr;\n\n  struct tl_ds_reply_markup *DS_RM = fetch_ds_type_reply_markup (TYPE_TO_PARAM (reply_markup));\n  assert (DS_RM);\n\n  tgl_do_send_message (TLS, args[0].peer_id, ARG2STR(2), TGL_SEND_MSG_FLAG_REPLY(reply_id) | disable_msg_preview | do_html, DS_RM, print_msg_success_gw, ev);\n\n  free_ds_type_reply_markup (DS_RM, TYPE_TO_PARAM (reply_markup));\n}\n\nvoid do_reply (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_reply_message (TLS, &args[0].msg_id, ARG2STR(1), disable_msg_preview | do_html, print_msg_success_gw, ev);\n}\n\nvoid do_send_text (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_send_text (TLS, args[0].peer_id, args[1].str, TGL_SEND_MSG_FLAG_REPLY(reply_id) | disable_msg_preview | do_html, print_msg_success_gw, ev);\n}\n \nvoid do_post_text (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_send_text (TLS, args[0].peer_id, args[1].str, TGL_SEND_MSG_FLAG_REPLY(reply_id) | disable_msg_preview | TGLMF_POST_AS_CHANNEL | do_html, print_msg_success_gw, ev);\n}\nvoid do_reply_text (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_reply_text (TLS, &args[0].msg_id, args[1].str, disable_msg_preview | do_html, print_msg_success_gw, ev);\n}\n\nstatic void _do_send_file (struct command *command, int arg_num, struct arg args[], struct in_ev *ev, unsigned long long flags) {\n  assert (arg_num >= 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_send_document (TLS, args[0].peer_id, args[1].str, arg_num == 2 ? NULL : args[2].str, arg_num == 2 ? 0 : strlen (args[2].str), flags | TGL_SEND_MSG_FLAG_REPLY (reply_id), print_msg_success_gw, ev);\n}\n\n\nvoid do_send_photo (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  _do_send_file (command, arg_num, args, ev, TGL_SEND_MSG_FLAG_DOCUMENT_PHOTO);\n}\n\nvoid do_send_file (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  _do_send_file (command, arg_num, args, ev, TGL_SEND_MSG_FLAG_DOCUMENT_AUTO);\n}\n\nvoid do_send_audio (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  _do_send_file (command, arg_num, args, ev, TGL_SEND_MSG_FLAG_DOCUMENT_AUDIO);\n}\n\nvoid do_send_video (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  _do_send_file (command, arg_num, args, ev, TGL_SEND_MSG_FLAG_DOCUMENT_VIDEO);\n}\n\nvoid do_send_document (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  _do_send_file (command, arg_num, args, ev, 0);\n}\n\nvoid do_post_photo (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  _do_send_file (command, arg_num, args, ev, TGL_SEND_MSG_FLAG_DOCUMENT_PHOTO | TGLMF_POST_AS_CHANNEL);\n}\n\nvoid do_post_file (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  _do_send_file (command, arg_num, args, ev, TGL_SEND_MSG_FLAG_DOCUMENT_AUTO | TGLMF_POST_AS_CHANNEL);\n}\n\nvoid do_post_audio (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  _do_send_file (command, arg_num, args, ev, TGL_SEND_MSG_FLAG_DOCUMENT_AUDIO | TGLMF_POST_AS_CHANNEL);\n}\n\nvoid do_post_video (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  _do_send_file (command, arg_num, args, ev, TGL_SEND_MSG_FLAG_DOCUMENT_VIDEO | TGLMF_POST_AS_CHANNEL);\n}\n\nvoid do_post_document (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  _do_send_file (command, arg_num, args, ev, TGLMF_POST_AS_CHANNEL);\n}\n\nvoid _do_reply_file (struct command *command, int arg_num, struct arg args[], struct in_ev *ev, unsigned long long flags) {\n  assert (arg_num >= 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_reply_document (TLS, &args[0].msg_id, args[1].str, arg_num == 2 ? NULL : args[2].str, arg_num == 2 ? 0 : strlen (args[2].str), flags, print_msg_success_gw, ev);\n}\n\nvoid do_reply_photo (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  _do_reply_file (command, arg_num, args, ev, TGL_SEND_MSG_FLAG_DOCUMENT_PHOTO);\n}\n\nvoid do_reply_file (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  _do_reply_file (command, arg_num, args, ev, TGL_SEND_MSG_FLAG_DOCUMENT_AUTO);\n}\n\nvoid do_reply_audio (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  _do_reply_file (command, arg_num, args, ev, TGL_SEND_MSG_FLAG_DOCUMENT_AUDIO);\n}\n\nvoid do_reply_video (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  _do_reply_file (command, arg_num, args, ev, TGL_SEND_MSG_FLAG_DOCUMENT_VIDEO);\n}\n\nvoid do_reply_document (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  _do_reply_file (command, arg_num, args, ev, 0);\n}\n\nvoid do_fwd (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num >= 2);\n  if (ev) { ev->refcnt ++; }\n  assert (arg_num <= 1000);\n  //if (arg_num == 2) {\n  //  tgl_do_forward_message (TLS, args[0].P->id, &args[1].msg_id, 0, print_msg_success_gw, ev);\n  //} else {\n    static tgl_message_id_t *list[1000];\n    int i;\n    for (i = 0; i < arg_num - 1; i++) {\n      list[i] = &args[i + 1].msg_id;\n    }\n    tgl_do_forward_messages (TLS, args[0].peer_id, arg_num - 1, (void *)list, 0, print_msg_list_success_gw, ev);\n  //}\n}\n\nvoid do_fwd_media (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_forward_media (TLS, args[0].peer_id, &args[1].msg_id, 0, print_msg_success_gw, ev);\n}\n\nvoid do_send_contact (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 4);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_send_contact (TLS, args[0].peer_id, ARG2STR (1), ARG2STR (2), ARG2STR (3), TGL_SEND_MSG_FLAG_REPLY(reply_id), print_msg_success_gw, ev);\n}\n\nvoid do_reply_contact (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 4);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_reply_contact (TLS, &args[0].msg_id, ARG2STR (1), ARG2STR (2), ARG2STR (3), 0, print_msg_success_gw, ev);\n}\n\nvoid do_send_location (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 3);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_send_location (TLS, args[0].peer_id, args[1].dval, args[2].dval, TGL_SEND_MSG_FLAG_REPLY(reply_id), print_msg_success_gw, ev);\n}\n\nvoid do_post_location (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 3);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_send_location (TLS, args[0].peer_id, args[1].dval, args[2].dval, TGL_SEND_MSG_FLAG_REPLY(reply_id) | TGLMF_POST_AS_CHANNEL, print_msg_success_gw, ev);\n}\n\nvoid do_reply_location (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 3);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_reply_location (TLS, &args[0].msg_id, args[1].dval, args[2].dval, 0, print_msg_success_gw, ev);\n}\n\nvoid do_broadcast (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num >= 1 && arg_num <= 1000);\n  static tgl_peer_id_t ids[1000];\n  int i;\n  for (i = 0; i < arg_num - 1; i++) {\n    ids[i] = args[i].peer_id;\n  }  \n  if (ev) { ev->refcnt ++; }\n  tgl_do_send_broadcast (TLS, arg_num - 1, ids, args[arg_num - 1].str, strlen (args[arg_num - 1].str), disable_msg_preview | do_html, print_msg_list_success_gw, ev);\n}\n\n/* }}} */\n\n/* {{{ EDITING SELF PROFILE */\n\nvoid do_get_self(struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  if (ev) { ev->refcnt ++; }\n  tgl_do_get_user_info (TLS, TLS->our_id, 0, print_user_info_gw, ev);\n}\n\nvoid do_set_profile_photo (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_set_profile_photo (TLS, args[0].str, print_success_gw, ev);\n}\n\nvoid do_set_profile_name (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_set_profile_name (TLS, ARG2STR (0), ARG2STR (1), print_user_gw, ev);\n}\n\nvoid do_set_username (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_set_username (TLS, ARG2STR (0), print_user_gw, ev);\n}\n\nvoid do_set_phone_number (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_set_phone_number (TLS, ARG2STR (0), print_success_gw, ev);\n}\n\nvoid do_status_online (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (!arg_num);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_update_status (TLS, 1, print_success_gw, ev);\n}\n\nvoid do_status_offline (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (!arg_num);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_update_status (TLS, 0, print_success_gw, ev);\n}\n\nvoid do_export_card (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (!arg_num);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_export_card (TLS, print_card_gw, ev);\n}\n\n/* }}} */\n\n/* {{{ WORKING WITH GROUP CHATS */\n\nvoid do_chat_set_photo (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_set_chat_photo (TLS, args[0].peer_id, args[1].str, print_success_gw, ev); \n}\n\nvoid do_rename_chat (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_rename_chat (TLS, args[0].peer_id, ARG2STR (1), print_success_gw, ev);\n}\n\nvoid do_chat_info (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_get_chat_info (TLS, args[0].peer_id, offline_mode, print_chat_info_gw, ev);\n}\n\nvoid do_channel_info (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_get_channel_info (TLS, args[0].peer_id, offline_mode, print_channel_info_gw, ev);\n}\n\nvoid do_chat_add_user (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 3);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_add_user_to_chat (TLS, args[0].peer_id, args[1].peer_id, args[2].num != NOT_FOUND ? args[2].num : 100, print_success_gw, ev);\n}\n\nvoid do_chat_del_user (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_del_user_from_chat (TLS, args[0].peer_id, args[1].peer_id, print_success_gw, ev);\n}\n    \nvoid do_create_group_chat (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num >= 1 && arg_num <= 1000);\n  static tgl_peer_id_t ids[1000];\n  int i;\n  for (i = 0; i < arg_num - 1; i++) {\n    ids[i] = args[i + 1].peer_id;\n  }\n\n  if (ev) { ev->refcnt ++; }\n  tgl_do_create_group_chat (TLS, arg_num - 1, ids, ARG2STR (0), print_success_gw, ev);  \n}\n\nvoid do_export_chat_link (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_export_chat_link (TLS, args[0].peer_id, print_string_gw, ev);\n}\n\nvoid do_import_chat_link (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_import_chat_link (TLS, ARG2STR (0), print_success_gw, ev);\n}\n\nvoid do_channel_invite (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_channel_invite_user (TLS, args[0].peer_id, args[1].peer_id, print_success_gw, ev);\n}\n\nvoid do_channel_kick (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_channel_kick_user (TLS, args[0].peer_id, args[1].peer_id, print_success_gw, ev);\n}\n\nvoid do_channel_get_members (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 3);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_channel_get_members (TLS, args[0].peer_id, args[1].num == NOT_FOUND ? 100 : args[1].num, args[2].num == NOT_FOUND ? 0 : args[2].num, 0, print_user_list_gw, ev);\n}\n\nvoid do_channel_get_admins (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 3);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_channel_get_members (TLS, args[0].peer_id, args[1].num == NOT_FOUND ? 100 : args[1].num, args[2].num == NOT_FOUND ? 0 : args[2].num, 1, print_user_list_gw, ev);\n}\n\nvoid do_chat_upgrade (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_upgrade_group (TLS, args[0].peer_id, print_success_gw, ev);\n}\n\n\n/* }}} */\n\n /* {{{ WORKING WITH USERS */\n\n\nvoid do_user_info (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_get_user_info (TLS, args[0].peer_id, offline_mode, print_user_info_gw, ev);\n}\n\nvoid do_add_contact (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 3);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_add_contact (TLS, ARG2STR (0), ARG2STR (1), ARG2STR (2), 0, print_user_list_gw, ev);\n}\n\nvoid do_rename_contact (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 3);\n  \n  tgl_peer_t *P = tgl_peer_get (TLS, args[0].peer_id);\n  if (P && P->user.phone) {\n    if (ev) { ev->refcnt ++; }\n    tgl_do_add_contact (TLS, P->user.phone, strlen (P->user.phone), args[1].str, strlen (args[1].str), args[2].str, strlen (args[2].str), 0, print_user_list_gw, ev);\n  } else {\n    if (ev) { ev->refcnt ++; }\n    print_success_gw (TLS, ev, 0);\n  }\n}\n\nvoid do_del_contact (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_del_contact (TLS, args[0].peer_id, print_success_gw, ev);\n}\n\n\nvoid do_import_card (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  char *s = args[0].str;\n  int l = strlen (s);\n  if (l > 0) {\n    int i;\n    static int p[10];\n    int pp = 0;\n    int cur = 0;\n    int ok = 1;\n    for (i = 0; i < l; i ++) {\n      if (s[i] >= '0' && s[i] <= '9') {\n        cur = cur * 16 + s[i] - '0';\n      } else if (s[i] >= 'a' && s[i] <= 'f') {\n        cur = cur * 16 + s[i] - 'a' + 10;\n      } else if (s[i] == ':') {\n        if (pp >= 9) { \n          ok = 0;\n          break;\n        }\n        p[pp ++] = cur;\n        cur = 0;\n      }\n    }\n    if (ok) {\n      p[pp ++] = cur;\n      if (ev) { ev->refcnt ++; }\n      tgl_do_import_card (TLS, pp, p, print_user_gw, ev);\n    }\n  }\n}\n\nvoid do_block_user (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_block_user (TLS, args[0].peer_id, print_success_gw, ev);\n}\n\nvoid do_unblock_user (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_unblock_user (TLS, args[0].peer_id, print_success_gw, ev);\n}\n/* }}} */\n\n/* {{{ WORKING WITH SECRET CHATS */\n\nvoid do_accept_secret_chat (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n\n  tgl_peer_t *P = tgl_peer_get (TLS, args[0].peer_id);\n  if (P) {\n    tgl_do_accept_encr_chat_request (TLS, &P->encr_chat, print_encr_chat_success_gw, ev);\n  } else {\n    print_success_gw (TLS, ev, 0);\n  }\n}\n\nvoid do_set_ttl (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_peer_t *P = tgl_peer_get (TLS, args[0].peer_id);\n  if (P && P->encr_chat.state == sc_ok) {\n    tgl_do_set_encr_chat_ttl (TLS, &P->encr_chat, args[1].num, print_msg_success_gw, ev);\n  } else {\n    print_success_gw (TLS, ev, 0);\n  }\n}\n\nvoid do_visualize_key (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  static char *colors[4] = {COLOR_GREY, COLOR_CYAN, COLOR_BLUE, COLOR_GREEN};\n  static unsigned char buf[16];\n  memset (buf, 0, sizeof (buf));\n  tgl_do_visualize_key (TLS, args[0].peer_id, buf);\n  mprint_start (ev);\n  int i;\n  for (i = 0; i < 16; i++) {\n    int x = buf[i];\n    int j;\n    for (j = 0; j < 4; j ++) {    \n      if (!ev) {\n        mpush_color (ev, colors[x & 3]);\n        mpush_color (ev, COLOR_INVERSE);\n      }\n      if (!disable_colors && !ev) {\n        mprintf (ev, \"  \");\n      } else {\n        switch (x & 3) {\n        case 0:\n          mprintf (ev, \"  \");\n          break;\n        case 1:\n          mprintf (ev, \"--\");\n          break;\n        case 2:\n          mprintf (ev, \"==\");\n          break;\n        case 3:\n          mprintf (ev, \"||\");\n          break;\n        }\n      }\n      if (!ev) {\n        mpop_color (ev);\n        mpop_color (ev);\n      }\n      x = x >> 2;\n    }\n    if (i & 1) { \n      mprintf (ev, \"\\n\"); \n    }\n  }\n  mprint_end (ev);\n}\n\n\nvoid do_create_secret_chat (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_create_secret_chat (TLS, args[0].peer_id, print_secret_chat_gw, ev);\n}\n\n/* }}} */\n\n/* WORKING WITH CHANNELS {{{ */\n\nvoid do_rename_channel (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_rename_channel (TLS, args[0].peer_id, ARG2STR (1), print_success_gw, ev);\n}\n\nvoid do_channel_set_photo (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_set_channel_photo (TLS, args[0].peer_id, args[1].str, print_success_gw, ev); \n}\n\nvoid do_channel_set_about (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_channel_set_about (TLS, args[0].peer_id, ARG2STR (1), print_success_gw, ev);\n}\n\nvoid do_channel_set_admin (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 3);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_channel_set_admin (TLS, args[0].peer_id, args[1].peer_id, args[2].num, print_success_gw, ev);\n}\n\nvoid do_channel_set_username (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_channel_set_username (TLS, args[0].peer_id, ARG2STR (1), print_success_gw, ev);\n}\n    \nvoid do_create_channel (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num >= 2 && arg_num <= 1000);\n  static tgl_peer_id_t ids[1000];\n  int i;\n  for (i = 0; i < arg_num - 2; i++) {\n    ids[i] = args[i + 2].peer_id;\n  }\n\n  if (ev) { ev->refcnt ++; }\n  tgl_do_create_channel (TLS, arg_num - 2, ids, ARG2STR (0), ARG2STR (1), 1, print_success_gw, ev);  \n}\n\nvoid do_join_channel (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_join_channel (TLS, args[0].peer_id, print_success_gw, ev);\n}\n\nvoid do_leave_channel (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_leave_channel (TLS, args[0].peer_id, print_success_gw, ev);\n}\n\nvoid do_export_channel_link (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_export_channel_link (TLS, args[0].peer_id, print_string_gw, ev);\n}\n\n/* }}} */\n\n/* {{{ WORKING WITH DIALOG LIST */\n\nvoid do_dialog_list (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num <= 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_get_dialog_list (TLS, args[0].num != NOT_FOUND ? args[0].num : 100, args[1].num != NOT_FOUND ? args[1].num : 0, print_dialog_list_gw, ev);\n}\n\nvoid do_channel_list (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num <= 2);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_get_channels_dialog_list (TLS, args[0].num != NOT_FOUND ? args[0].num : 100, args[1].num != NOT_FOUND ? args[1].num : 0, print_dialog_list_gw, ev);\n}\n\nvoid do_resolve_username (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_contact_search (TLS, args[0].str, strlen (args[0].str), print_peer_gw, ev);\n}\n\nvoid do_contact_list (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (!arg_num);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_update_contact_list (TLS, print_user_list_gw, ev);  \n}\n\n/* }}} */\n\n/* {{{ WORKING WITH ONE DIALOG */\n\nvoid do_mark_read (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_mark_read (TLS, args[0].peer_id, print_success_gw, ev);\n}\n\nvoid do_history (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 3);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_get_history (TLS, args[0].peer_id, args[2].num != NOT_FOUND ? args[2].num : 0, args[1].num != NOT_FOUND ? args[1].num : 40, offline_mode, print_msg_list_history_gw, ev);\n}\n\nvoid print_fail (struct in_ev *ev);\n\nvoid do_send_typing (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 2);\n  enum tgl_typing_status status = tgl_typing_typing; //de\n  if (args[1].num != NOT_FOUND) {\n    if (args[1].num > 0 && args[1].num > 10) {\n      fail_interface (TLS, ev, ENOSYS, \"illegal typing status\");\n      return;\n    }\n    status = (enum tgl_typing_status) args[1].num;  // if the status parameter is given, and is in range.\n  }\n  if (ev) { ev->refcnt ++; }\n  tgl_do_send_typing (TLS, args[0].peer_id, status, print_success_gw, ev);\n}\n\nvoid do_send_typing_abort (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_send_typing (TLS, args[0].peer_id, tgl_typing_cancel, print_success_gw, ev);\n}\n\n/* }}} */\n\n/* {{{ WORKING WITH MEDIA */\n\n#define DO_LOAD_PHOTO(tp,act,actf) \\\nvoid do_ ## act ## _ ## tp (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) { \\\n  assert (arg_num == 1);\\\n  struct tgl_message *M = tgl_message_get (TLS, &args[0].msg_id);\\\n  if (M && !(M->flags & TGLMF_SERVICE)) {\\\n    if (ev) { ev->refcnt ++; } \\\n    if (M->media.type == tgl_message_media_photo) { \\\n      tgl_do_load_photo (TLS, M->media.photo, actf, ev);\\\n    } else if (M->media.type == tgl_message_media_document) {\\\n      tgl_do_load_document (TLS, M->media.document, actf, ev);\\\n    } else if (M->media.type == tgl_message_media_video) {\\\n      tgl_do_load_video (TLS, M->media.document, actf, ev);\\\n    } else if (M->media.type == tgl_message_media_audio) {\\\n      tgl_do_load_audio (TLS, M->media.document, actf, ev);\\\n    } else if (M->media.type == tgl_message_media_document_encr) {\\\n      tgl_do_load_encr_document (TLS, M->media.encr_document, actf, ev); \\\n    } else if (M->media.type == tgl_message_media_webpage) {\\\n      actf (TLS, ev, 1, M->media.webpage->url);\\\n    } else if (M->media.type == tgl_message_media_geo || M->media.type == tgl_message_media_venue) { \\\n      static char s[1000]; \\\n      sprintf (s, \"https://maps.google.com/?q=%.6lf,%.6lf\", M->media.geo.latitude, M->media.geo.longitude);\\\n      actf (TLS, ev, 1, s);\\\n    }\\\n  }\\\n}\n\n#define DO_LOAD_PHOTO_THUMB(tp,act,actf) \\\nvoid do_ ## act ## _ ## tp ## _thumb (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) { \\\n  assert (arg_num == 1);\\\n  struct tgl_message *M = tgl_message_get (TLS, &args[0].msg_id);\\\n  if (M && !(M->flags & TGLMF_SERVICE)) {\\\n    if (M->media.type == tgl_message_media_document) {\\\n      if (ev) { ev->refcnt ++; } \\\n      tgl_do_load_document_thumb (TLS, M->media.document, actf, ev);\\\n    }\\\n  }\\\n}\n\nDO_LOAD_PHOTO(photo, load, print_filename_gw)\nDO_LOAD_PHOTO(video, load, print_filename_gw)\nDO_LOAD_PHOTO(audio, load, print_filename_gw)\nDO_LOAD_PHOTO(document, load, print_filename_gw)\nDO_LOAD_PHOTO(file, load, print_filename_gw)\nDO_LOAD_PHOTO_THUMB(video, load, print_filename_gw)\nDO_LOAD_PHOTO_THUMB(document, load, print_filename_gw)\nDO_LOAD_PHOTO_THUMB(file, load, print_filename_gw)\nDO_LOAD_PHOTO(photo, open, open_filename_gw)\nDO_LOAD_PHOTO(video, open, open_filename_gw)\nDO_LOAD_PHOTO(audio, open, open_filename_gw)\nDO_LOAD_PHOTO(document, open, open_filename_gw)\nDO_LOAD_PHOTO(file, open, open_filename_gw)\nDO_LOAD_PHOTO_THUMB(video, open, open_filename_gw)\nDO_LOAD_PHOTO_THUMB(document, open, open_filename_gw)\nDO_LOAD_PHOTO_THUMB(file, open, open_filename_gw)\nDO_LOAD_PHOTO(any, open, open_filename_gw)\n\nvoid do_load_user_photo  (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n\n  tgl_peer_t *P = tgl_peer_get (TLS, args[0].peer_id);\n  if (P) {\n    tgl_do_load_file_location (TLS, &P->user.photo_big, print_filename_gw, ev);\n  } else {\n    print_filename_gw (TLS, ev, 0, NULL);\n  }\n}\n\nvoid do_view_user_photo  (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  \n  tgl_peer_t *P = tgl_peer_get (TLS, args[0].peer_id);\n  if (P) {\n    tgl_do_load_file_location (TLS, &P->user.photo_big, print_filename_gw, ev);\n  } else {\n    open_filename_gw (TLS, ev, 0, NULL);\n  }\n}\n\n/* }}} */\n\n/* {{{ ANOTHER MESSAGES FUNCTIONS */\n\nvoid do_search (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 6);\n  int limit;\n  if (args[1].num != NOT_FOUND) {\n    limit = args[1].num; \n  } else {\n    limit = 40;\n  }\n  int from;\n  if (args[2].num != NOT_FOUND) {\n    from = args[2].num; \n  } else {\n    from = 0;\n  }\n  int to;\n  if (args[3].num != NOT_FOUND) {\n    to = args[3].num; \n  } else {\n    to = 0;\n  }\n  int offset;\n  if (args[4].num != NOT_FOUND) {\n    offset = args[4].num; \n  } else {\n    offset = 0;\n  }\n  if (ev) { ev->refcnt ++; }\n  tgl_do_msg_search (TLS, args[0].peer_id, from, to, limit, offset, args[5].str, strlen (args[5].str), print_msg_list_gw, ev);\n}\n\nvoid do_delete_msg (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  if (ev) { ev->refcnt ++; }\n  tgl_do_delete_msg (TLS, &args[0].msg_id, print_success_gw, ev);\n}\n\nvoid do_get_message (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 1);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_get_message (TLS, &args[0].msg_id, print_msg_gw, ev);\n}\n\n/* }}} */\n\n/* {{{ BOT */\n\nvoid do_start_bot (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  assert (arg_num == 3);\n  if (ev) { ev->refcnt ++; }\n  tgl_do_start_bot (TLS, args[0].peer_id, args[1].peer_id, ARG2STR(2), print_success_gw, ev);\n}\n/* }}} */\n\nextern char *default_username;\nextern char *config_filename;\nextern char *prefix;\nextern char *auth_file_name;\nextern char *state_file_name;\nextern char *secret_chat_file_name;\nextern char *downloads_directory;\nextern char *config_directory;\nextern char *binlog_file_name;\nextern char *lua_file;\nextern char *python_file;\nextern struct event *term_ev;\n\nvoid do_clear (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  logprintf (\"Do_clear\\n\");\n  free (default_username);\n  tfree_str (config_filename);\n  //free (prefix);\n  tfree_str (auth_file_name);\n  tfree_str (state_file_name);\n  tfree_str (secret_chat_file_name);\n  tfree_str (downloads_directory);\n  //tfree_str (config_directory);\n  tfree_str (binlog_file_name);\n  tfree_str (lua_file);\n  tfree_str (python_file);\n  if (home_directory) {\n    tfree_str (home_directory);\n  }\n  clear_history ();\n  event_free (term_ev);\n  struct event_base *ev_base = TLS->ev_base;\n  tgl_free_all (TLS);\n  event_base_free (ev_base);\n  logprintf (\"Bytes left allocated: %lld\\n\", tgl_get_allocated_bytes ());\n  do_halt (0);\n}\n\n\n#define MAX_COMMANDS_SIZE 1000\nstruct command commands[MAX_COMMANDS_SIZE] = {\n  {\"accept_secret_chat\", {ca_secret_chat, ca_none}, do_accept_secret_chat, \"accept_secret_chat <secret chat>\\tAccepts secret chat. Only useful with -E option\", NULL},\n  {\"add_contact\", {ca_string, ca_string, ca_string, ca_none}, do_add_contact, \"add_contact <phone> <first name> <last name>\\tTries to add user to contact list\", NULL},\n  {\"block_user\", {ca_user, ca_none}, do_block_user, \"block_user <user>\\tBlocks user\", NULL},\n  {\"broadcast\", {ca_user, ca_period, ca_string_end, ca_none}, do_broadcast, \"broadcast <user>+ <text>\\tSends text to several users at once\", NULL},\n  {\"channel_get_admins\", {ca_channel, ca_number | ca_optional, ca_number | ca_optional, ca_none}, do_channel_get_admins, \"channel_get_admins <channel> [limit=100] [offset=0]\\tGets channel admins\", NULL},\n  {\"channel_get_members\", {ca_channel, ca_number | ca_optional, ca_number | ca_optional, ca_none}, do_channel_get_members, \"channel_get_members <channel> [limit=100] [offset=0]\\tGets channel members\", NULL},\n  {\"channel_info\", {ca_channel, ca_none}, do_channel_info, \"channel_info <channel>\\tPrints info about channel (id, members, admin, etc.)\", NULL},\n  {\"channel_invite\", {ca_channel, ca_user, ca_none}, do_channel_invite, \"channel_invite <channel> <user>\\tInvites user to channel\", NULL},\n  {\"channel_join\", {ca_channel, ca_none}, do_join_channel, \"channel_join <channel>\\tJoins to channel\", NULL},\n  {\"channel_kick\", {ca_channel, ca_user, ca_none}, do_channel_kick, \"channel_kick <channel> <user>\\tKicks user from channel\", NULL},\n  {\"channel_leave\", {ca_channel, ca_none}, do_leave_channel, \"channel_leave <channel>\\tLeaves from channel\", NULL},\n  {\"channel_list\", {ca_number | ca_optional, ca_number | ca_optional, ca_none}, do_channel_list, \"channel_list [limit=100] [offset=0]\\tList of last channels\", NULL},\n  {\"channel_set_about\", {ca_channel, ca_string, ca_none}, do_channel_set_about, \"channel_set_about <channel> <about>\\tSets channel about info.\", NULL},\n  {\"channel_set_admin\", {ca_channel, ca_user, ca_number, ca_none}, do_channel_set_admin, \"channel_set_admin <channel> <admin> <type>\\tSets channel admin. 0 - not admin, 1 - moderator, 2 - editor\", NULL},\n  {\"channel_set_username\", {ca_channel, ca_string, ca_none}, do_channel_set_username, \"channel_set_username <channel> <username>\\tSets channel username info.\", NULL},\n  {\"channel_set_photo\", {ca_channel, ca_file_name_end, ca_none}, do_channel_set_photo, \"channel_set_photo <channel> <filename>\\tSets channel photo. Photo will be cropped to square\", NULL},\n  {\"chat_add_user\", {ca_chat, ca_user, ca_number | ca_optional, ca_none}, do_chat_add_user, \"chat_add_user <chat> <user> [msgs-to-forward]\\tAdds user to chat. Sends him last msgs-to-forward message from this chat. Default 100\", NULL},\n  {\"chat_del_user\", {ca_chat, ca_user, ca_none}, do_chat_del_user, \"chat_del_user <chat> <user>\\tDeletes user from chat\", NULL},\n  {\"chat_info\", {ca_chat, ca_none}, do_chat_info, \"chat_info <chat>\\tPrints info about chat (id, members, admin, etc.)\", NULL},\n  {\"chat_set_photo\", {ca_chat, ca_file_name_end, ca_none}, do_chat_set_photo, \"chat_set_photo <chat> <filename>\\tSets chat photo. Photo will be cropped to square\", NULL},\n  {\"chat_upgrade\", {ca_chat, ca_none}, do_chat_upgrade, \"chat_upgrade <chat>\\tUpgrades chat to megagroup\", NULL},\n  {\"chat_with_peer\", {ca_peer, ca_none}, do_chat_with_peer, \"chat_with_peer <peer>\\tInterface option. All input will be treated as messages to this peer. Type /quit to end this mode\", NULL},\n  {\"clear\", {ca_none}, do_clear, \"clear\\tClears all data and exits. For debug.\", NULL},\n  {\"contact_list\", {ca_none}, do_contact_list, \"contact_list\\tPrints contact list\", NULL},\n  {\"contact_search\", {ca_string, ca_none}, do_resolve_username, \"contact_search username\\tSearches user by username\", NULL},\n  {\"create_channel\", {ca_string, ca_string, ca_user | ca_optional, ca_period, ca_none}, do_create_channel, \"create_channel <name> <about> <user>+\\tCreates channel with users\", NULL},\n  {\"create_group_chat\", {ca_string, ca_user, ca_period, ca_none}, do_create_group_chat, \"create_group_chat <name> <user>+\\tCreates group chat with users\", NULL},\n  {\"create_secret_chat\", {ca_user, ca_none}, do_create_secret_chat, \"create_secret_chat <user>\\tStarts creation of secret chat\", NULL},\n  {\"del_contact\", {ca_user, ca_none}, do_del_contact, \"del_contact <user>\\tDeletes contact from contact list\", NULL},\n  {\"delete_msg\", {ca_msg_id, ca_none}, do_delete_msg, \"delete_msg <msg-id>\\tDeletes message\", NULL},\n  {\"dialog_list\", {ca_number | ca_optional, ca_number | ca_optional, ca_none}, do_dialog_list, \"dialog_list [limit=100] [offset=0]\\tList of last conversations\", NULL},\n  {\"export_card\", {ca_none}, do_export_card, \"export_card\\tPrints card that can be imported by another user with import_card method\", NULL},\n  {\"export_channel_link\", {ca_channel, ca_none}, do_export_channel_link, \"export_channel_link\\tPrints channel link that can be used to join to channel\", NULL},\n  {\"export_chat_link\", {ca_chat, ca_none}, do_export_chat_link, \"export_chat_link\\tPrints chat link that can be used to join to chat\", NULL},\n  {\"fwd\", {ca_peer, ca_msg_id, ca_period, ca_none}, do_fwd, \"fwd <peer> <msg-id>+\\tForwards message to peer. Forward to secret chats is forbidden\", NULL},\n  {\"fwd_media\", {ca_peer, ca_msg_id, ca_none}, do_fwd_media, \"fwd_media <peer> <msg-id>\\tForwards message media to peer. Forward to secret chats is forbidden. Result slightly differs from fwd\", NULL},\n  {\"get_terms_of_service\", {ca_none}, do_get_terms_of_service, \"get_terms_of_service\\tPrints telegram's terms of service\", NULL},\n  {\"get_message\", {ca_msg_id, ca_none}, do_get_message, \"get_message <msg-id>\\tGet message by id\", NULL},\n  {\"get_self\", {ca_none}, do_get_self, \"get_self \\tGet our user info\", NULL},\n  {\"help\", {ca_command | ca_optional, ca_none}, do_help, \"help [command]\\tPrints this help\", NULL},\n  {\"history\", {ca_peer, ca_number | ca_optional, ca_number | ca_optional, ca_none}, do_history, \"history <peer> [limit] [offset]\\tPrints messages with this peer (most recent message lower). Also marks messages as read\", NULL},\n  {\"import_card\", {ca_string, ca_none}, do_import_card, \"import_card <card>\\tGets user by card and prints it name. You can then send messages to him as usual\", NULL},\n  {\"import_chat_link\", {ca_string, ca_none}, do_import_chat_link, \"import_chat_link <hash>\\tJoins to chat by link\", NULL},\n  {\"import_channel_link\", {ca_string, ca_none}, do_import_chat_link, \"import_channel_link <hash>\\tJoins to channel by link\", NULL},\n  {\"load_audio\", {ca_msg_id, ca_none}, do_load_audio, \"load_audio <msg-id>\\tDownloads file to downloads dirs. Prints file name after download end\", NULL},\n  {\"load_channel_photo\", {ca_channel, ca_none}, do_load_user_photo, \"load_channel_photo <channel>\\tDownloads file to downloads dirs. Prints file name after download end\", NULL},\n  {\"load_chat_photo\", {ca_chat, ca_none}, do_load_user_photo, \"load_chat_photo <chat>\\tDownloads file to downloads dirs. Prints file name after download end\", NULL},\n  {\"load_document\", {ca_msg_id, ca_none}, do_load_document, \"load_document <msg-id>\\tDownloads file to downloads dirs. Prints file name after download end\", NULL},\n  {\"load_document_thumb\", {ca_msg_id, ca_none}, do_load_document_thumb, \"load_document_thumb <msg-id>\\tDownloads file to downloads dirs. Prints file name after download end\", NULL},\n  {\"load_file\", {ca_msg_id, ca_none}, do_load_file, \"load_file <msg-id>\\tDownloads file to downloads dirs. Prints file name after download end\", NULL},\n  {\"load_file_thumb\", {ca_msg_id, ca_none}, do_load_file_thumb, \"load_file_thumb <msg-id>\\tDownloads file to downloads dirs. Prints file name after download end\", NULL},\n  {\"load_photo\", {ca_msg_id, ca_none}, do_load_photo, \"load_photo <msg-id>\\tDownloads file to downloads dirs. Prints file name after download end\", NULL},\n  {\"load_user_photo\", {ca_user, ca_none}, do_load_user_photo, \"load_user_photo <user>\\tDownloads file to downloads dirs. Prints file name after download end\", NULL},\n  {\"load_video\", {ca_msg_id, ca_none}, do_load_video, \"load_video <msg-id>\\tDownloads file to downloads dirs. Prints file name after download end\", NULL},\n  {\"load_video_thumb\", {ca_msg_id, ca_none}, do_load_video_thumb, \"load_video_thumb <msg-id>\\tDownloads file to downloads dirs. Prints file name after download end\", NULL},\n  {\"main_session\", {ca_none}, do_main_session, \"main_session\\tSends updates to this connection (or terminal). Useful only with listening socket\", NULL},\n  {\"mark_read\", {ca_peer, ca_none}, do_mark_read, \"mark_read <peer>\\tMarks messages with peer as read\", NULL},\n  {\"msg\", {ca_peer, ca_msg_string_end, ca_none}, do_msg, \"msg <peer> <text>\\tSends text message to peer\", NULL},\n  {\"msg_kbd\", {ca_peer, ca_string, ca_msg_string_end, ca_none}, do_msg_kbd, \"msg <peer> <kbd> <text>\\tSends text message to peer with custom kbd\", NULL},\n  {\"post\", {ca_peer, ca_msg_string_end, ca_none}, do_post, \"post <peer> <text>\\tSends text message to peer as admin\", NULL},\n  {\"post_audio\", {ca_peer, ca_file_name, ca_none}, do_post_audio, \"post_audio <peer> <file>\\tPosts audio to peer\", NULL},\n  {\"post_document\", {ca_peer, ca_file_name, ca_none}, do_post_document, \"post_document <peer> <file>\\tPosts document to peer\", NULL},\n  {\"post_file\", {ca_peer, ca_file_name, ca_none}, do_post_file, \"post_file <peer> <file>\\tSends document to peer\", NULL},\n  {\"post_location\", {ca_peer, ca_double, ca_double, ca_none}, do_post_location, \"post_location <peer> <latitude> <longitude>\\tSends geo location\", NULL},\n  {\"post_photo\", {ca_peer, ca_file_name, ca_string_end | ca_optional, ca_none}, do_post_photo, \"post_photo <peer> <file> [caption]\\tSends photo to peer\", NULL},\n  {\"post_text\", {ca_peer, ca_file_name_end, ca_none}, do_post_text, \"post_text <peer> <file>\\tSends contents of text file as plain text message\", NULL},\n  {\"post_video\", {ca_peer, ca_file_name, ca_string_end | ca_optional, ca_none}, do_post_video, \"post_video <peer> <file> [caption]\\tSends video to peer\", NULL},\n  {\"quit\", {ca_none}, do_quit, \"quit\\tQuits immediately\", NULL},\n  {\"rename_channel\", {ca_channel, ca_string_end, ca_none}, do_rename_channel, \"rename_channel <channel> <new name>\\tRenames channel\", NULL},\n  {\"rename_chat\", {ca_chat, ca_string_end, ca_none}, do_rename_chat, \"rename_chat <chat> <new name>\\tRenames chat\", NULL},\n  {\"rename_contact\", {ca_user, ca_string, ca_string, ca_none}, do_rename_contact, \"rename_contact <user> <first name> <last name>\\tRenames contact\", NULL},\n  {\"reply\", {ca_msg_id, ca_msg_string_end, ca_none}, do_reply, \"reply <msg-id> <text>\\tSends text reply to message\", NULL},\n  {\"reply_audio\", {ca_msg_id, ca_file_name, ca_none}, do_send_audio, \"reply_audio <msg-id> <file>\\tSends audio to peer\", NULL},\n  {\"reply_contact\", {ca_msg_id, ca_string, ca_string, ca_string, ca_none}, do_reply_contact, \"reply_contact <msg-id> <phone> <first-name> <last-name>\\tSends contact (not necessary telegram user)\", NULL},\n  {\"reply_document\", {ca_msg_id, ca_file_name, ca_none}, do_reply_document, \"reply_document <msg-id> <file>\\tSends document to peer\", NULL},\n  {\"reply_file\", {ca_msg_id, ca_file_name, ca_none}, do_reply_file, \"reply_file <msg-id> <file>\\tSends document to peer\", NULL},\n  {\"reply_location\", {ca_msg_id, ca_double, ca_double, ca_none}, do_reply_location, \"reply_location <msg-id> <latitude> <longitude>\\tSends geo location\", NULL},\n  {\"reply_photo\", {ca_msg_id, ca_file_name, ca_string_end | ca_optional, ca_none}, do_reply_photo, \"reply_photo <msg-id> <file> [caption]\\tSends photo to peer\", NULL},\n  //{\"reply_text\", {ca_number, ca_file_name_end, ca_none}, do_reply_text, \"reply_text <msg-id> <file>\\tSends contents of text file as plain text message\", NULL},\n  {\"reply_video\", {ca_msg_id, ca_file_name, ca_none}, do_reply_video, \"reply_video <msg-id> <file>\\tSends video to peer\", NULL},\n  {\"resolve_username\", {ca_string, ca_none}, do_resolve_username, \"resolve_username username\\tSearches user by username\", NULL},\n  //{\"restore_msg\", {ca_number, ca_none}, do_restore_msg, \"restore_msg <msg-id>\\tRestores message. Only available shortly (one hour?) after deletion\", NULL},\n  {\"safe_quit\", {ca_none}, do_safe_quit, \"safe_quit\\tWaits for all queries to end, then quits\", NULL},\n  {\"search\", {ca_peer | ca_optional, ca_number | ca_optional, ca_number | ca_optional, ca_number | ca_optional, ca_number | ca_optional, ca_string_end}, do_search, \"search [peer] [limit] [from] [to] [offset] pattern\\tSearch for pattern in messages from date from to date to (unixtime) in messages with peer (if peer not present, in all messages)\", NULL},\n  //{\"secret_chat_rekey\", { ca_secret_chat, ca_none}, do_secret_chat_rekey, \"generate new key for active secret chat\", NULL},\n  {\"send_audio\", {ca_peer, ca_file_name, ca_string_end | ca_optional, ca_none}, do_send_audio, \"send_audio <peer> <file>\\tSends audio to peer\", NULL},\n  {\"send_contact\", {ca_peer, ca_string, ca_string, ca_string, ca_none}, do_send_contact, \"send_contact <peer> <phone> <first-name> <last-name>\\tSends contact (not necessary telegram user)\", NULL},\n  {\"send_document\", {ca_peer, ca_file_name, ca_string_end | ca_optional, ca_none}, do_send_document, \"send_document <peer> <file>\\tSends document to peer\", NULL},\n  {\"send_file\", {ca_peer, ca_file_name, ca_string_end | ca_optional, ca_none}, do_send_file, \"send_file <peer> <file>\\tSends document to peer\", NULL},\n  {\"send_location\", {ca_peer, ca_double, ca_double, ca_none}, do_send_location, \"send_location <peer> <latitude> <longitude>\\tSends geo location\", NULL},\n  {\"send_photo\", {ca_peer, ca_file_name, ca_string_end | ca_optional, ca_none}, do_send_photo, \"send_photo <peer> <file> [caption]\\tSends photo to peer\", NULL},\n  {\"send_text\", {ca_peer, ca_file_name_end, ca_none}, do_send_text, \"send_text <peer> <file>\\tSends contents of text file as plain text message\", NULL},\n  {\"send_typing\", {ca_peer, ca_number | ca_optional, ca_none}, do_send_typing, \"send_typing <peer> [status]\\tSends typing notification. You can supply a custom status (range 0-10): none, typing, cancel, record video, upload video, record audio, upload audio, upload photo, upload document, geo, choose contact.\", NULL},\n  {\"send_typing_abort\", {ca_peer, ca_none}, do_send_typing_abort, \"send_typing_abort <peer>\\tSends typing notification abort\", NULL},\n  {\"send_video\", {ca_peer, ca_file_name, ca_string_end | ca_optional, ca_none}, do_send_video, \"send_video <peer> <file> [caption]\\tSends video to peer\", NULL},\n  {\"set\", {ca_string, ca_number, ca_none}, do_set, \"set <param> <value>\\tSets value of param. Currently available: log_level, debug_verbosity, alarm, msg_num\", NULL},\n  {\"set_password\", {ca_string | ca_optional, ca_none}, do_set_password, \"set_password <hint>\\tSets password\", NULL},\n  {\"set_profile_name\", {ca_string, ca_string, ca_none}, do_set_profile_name, \"set_profile_name <first-name> <last-name>\\tSets profile name.\", NULL},\n  {\"set_profile_photo\", {ca_file_name_end, ca_none}, do_set_profile_photo, \"set_profile_photo <filename>\\tSets profile photo. Photo will be cropped to square\", NULL},\n  {\"set_ttl\", {ca_secret_chat, ca_number,  ca_none}, do_set_ttl, \"set_ttl <secret chat>\\tSets secret chat ttl. Client itself ignores ttl\", NULL},\n  {\"set_username\", {ca_string, ca_none}, do_set_username, \"set_username <name>\\tSets username.\", NULL},\n  {\"set_phone_number\", {ca_string, ca_none}, do_set_phone_number, \"set_phone_number <phone>\\tChanges the phone number of this account\", NULL},\n  {\"show_license\", {ca_none}, do_show_license, \"show_license\\tPrints contents of GPL license\", NULL},\n  {\"start_bot\", {ca_user, ca_chat, ca_string, ca_none}, do_start_bot, \"start_bot <bot> <chat> <data>\\tAdds bot to chat\", NULL},\n  {\"stats\", {ca_none}, do_stats, \"stats\\tFor debug purpose\", NULL},\n  {\"status_online\", {ca_none}, do_status_online, \"status_online\\tSets status as online\", NULL},\n  {\"status_offline\", {ca_none}, do_status_offline, \"status_offline\\tSets status as offline\", NULL},\n  {\"unblock_user\", {ca_user, ca_none}, do_unblock_user, \"unblock_user <user>\\tUnblocks user\", NULL},\n  {\"user_info\", {ca_user, ca_none}, do_user_info, \"user_info <user>\\tPrints info about user (id, last online, phone)\", NULL},\n  {\"version\", {ca_none}, do_version, \"version\\tPrints client and library version\", NULL},\n  {\"view_audio\", {ca_msg_id, ca_none}, do_open_audio, \"view_audio <msg-id>\\tDownloads file to downloads dirs. Then tries to open it with system default action\", NULL},\n  {\"view_channel_photo\", {ca_channel, ca_none}, do_view_user_photo, \"view_channel_photo <channel>\\tDownloads file to downloads dirs. Then tries to open it with system default action\", NULL},\n  {\"view_chat_photo\", {ca_chat, ca_none}, do_view_user_photo, \"view_chat_photo <chat>\\tDownloads file to downloads dirs. Then tries to open it with system default action\", NULL},\n  {\"view_document\", {ca_msg_id, ca_none}, do_open_document, \"view_document <msg-id>\\tDownloads file to downloads dirs. Then tries to open it with system default action\", NULL},\n  {\"view_document_thumb\", {ca_msg_id, ca_none}, do_open_document_thumb, \"view_document_thumb <msg-id>\\tDownloads file to downloads dirs. Then tries to open it with system default action\", NULL},\n  {\"view_file\", {ca_msg_id, ca_none}, do_open_file, \"view_file <msg-id>\\tDownloads file to downloads dirs. Then tries to open it with system default action\", NULL},\n  {\"view_file_thumb\", {ca_msg_id, ca_none}, do_open_file_thumb, \"view_file_thumb <msg-id>\\tDownloads file to downloads dirs. Then tries to open it with system default action\", NULL},\n  {\"view_photo\", {ca_msg_id, ca_none}, do_open_photo, \"view_photo <msg-id>\\tDownloads file to downloads dirs. Then tries to open it with system default action\", NULL},\n  {\"view_user_photo\", {ca_user, ca_none}, do_view_user_photo, \"view_user_photo <user>\\tDownloads file to downloads dirs. Then tries to open it with system default action\", NULL},\n  {\"view_video\", {ca_msg_id, ca_none}, do_open_video, \"view_video <msg-id>\\tDownloads file to downloads dirs. Then tries to open it with system default action\", NULL},\n  {\"view_video_thumb\", {ca_msg_id, ca_none}, do_open_video_thumb, \"view_video_thumb <msg-id>\\tDownloads file to downloads dirs. Then tries to open it with system default action\", NULL},\n  {\"view\", {ca_msg_id, ca_none}, do_open_any, \"view <msg-id>\\tTries to view message contents\", NULL},\n  {\"visualize_key\", {ca_secret_chat, ca_none}, do_visualize_key, \"visualize_key <secret chat>\\tPrints visualization of encryption key (first 16 bytes sha1 of it in fact)\", NULL}\n};\n\nvoid register_new_command (struct command *cmd) {\n  int i = 0;\n  while (commands[i].name) {\n    i ++;\n  }\n  assert (i < MAX_COMMANDS_SIZE - 1);\n  commands[i] = *cmd;\n}\n\ntgl_peer_t *autocomplete_peer;\ntgl_message_id_t autocomplete_id;\n\nenum command_argument get_complete_mode (void) {\n  force_end_mode = 0;\n  line_ptr = rl_line_buffer;\n  autocomplete_peer = NULL;\n  autocomplete_id.peer_type = NOT_FOUND;\n\n  while (1) {\n    next_token ();\n    if (cur_token_quoted) { return ca_none; }\n    if (cur_token_len <= 0) { return ca_command; }\n    if (*cur_token == '[') {\n      if (cur_token_end_str) {\n        return ca_modifier; \n      }\n      if (cur_token[cur_token_len - 1] != ']') {\n        return ca_none;\n      }\n      continue;\n    }\n    break;\n  }\n  if (cur_token_quoted) { return ca_none; }\n  if (cur_token_end_str) { return ca_command; }\n  if (*cur_token == '(') { return ca_extf; }\n  \n  struct command *command = commands;\n  int n = 0;\n  struct tgl_command;\n  while (command->name) {\n    if (is_same_word (cur_token, cur_token_len, command->name)) {\n      break;\n    }\n    n ++;\n    command ++;\n  }\n  \n  if (!command->name) {\n    return ca_none;\n  }\n\n  enum command_argument *flags = command->args;\n  while (1) {\n    int period = 0;\n    if (*flags == ca_period) {\n      flags --;\n      period = 1;\n    }\n    enum command_argument op = (*flags) & 255;\n    int opt = (*flags) & ca_optional;\n\n    if (op == ca_none) { return ca_none; }\n    if (op == ca_string_end || op == ca_file_name_end || op == ca_msg_string_end) {\n      next_token_end_ac ();\n\n      if (cur_token_len < 0 || !cur_token_end_str) { \n        return ca_none;\n      } else {\n        return op;\n      }\n    }\n    \n    char *save = line_ptr;\n    next_token ();\n    if (op == ca_user || op == ca_chat || op == ca_secret_chat || op == ca_peer || op == ca_number || op == ca_double || op == ca_msg_id || op == ca_command || op == ca_channel) {\n      if (cur_token_quoted) {\n        if (opt) {\n          line_ptr = save;\n          flags ++;\n          continue;\n        } else if (period) {\n          line_ptr = save;\n          flags += 2;\n          continue;\n        } else {\n          return ca_none;\n        }\n      } else {\n        if (cur_token_end_str) { return op; }\n        \n        int ok = 1;\n        switch (op) {\n        case ca_user:\n          ok = (tgl_get_peer_type (cur_token_user ()) != NOT_FOUND);\n          break;\n        case ca_chat:\n          ok = (tgl_get_peer_type (cur_token_chat ()) != NOT_FOUND);\n          break;\n        case ca_secret_chat:\n          ok = (tgl_get_peer_type (cur_token_encr_chat ()) != NOT_FOUND);\n          break;\n        case ca_channel:\n          ok = (tgl_get_peer_type (cur_token_channel ()) != NOT_FOUND);\n          break;\n        case ca_peer:\n          ok = (tgl_get_peer_type (cur_token_peer ()) != NOT_FOUND);\n          if (ok) {\n            autocomplete_peer = tgl_peer_get (TLS, cur_token_peer ());\n            autocomplete_id.peer_type = NOT_FOUND;\n          }\n          break;\n        case ca_number:\n          ok = (cur_token_int () != NOT_FOUND);\n          break;\n        case ca_msg_id:\n          ok = (cur_token_msg_id ().peer_type != 0);\n          if (ok) {\n            autocomplete_peer = NULL;\n            autocomplete_id = cur_token_msg_id ();\n          }\n          break;\n        case ca_double:\n          ok = (cur_token_double () != NOT_FOUND);\n          break;\n        case ca_command:\n          ok = cur_token_len > 0;\n          break;\n        default:\n          assert (0);\n        }\n\n        if (opt && !ok) {\n          line_ptr = save;\n          flags ++;\n          continue;\n        }\n        if (period && !ok) {\n          line_ptr = save;\n          flags += 2;\n          continue;\n        }\n        if (!ok) {\n          return ca_none;\n        }\n\n        flags ++;\n        continue;\n      }\n    }\n    if (op == ca_string || op == ca_file_name) {\n      if (cur_token_end_str) {\n        return op;\n      } else {\n        flags ++;\n        continue;\n      }\n    }\n    assert (0);\n  }\n}\n\nint complete_string_list (char **list, int index, const char *text, int len, char **R) {\n  index ++;\n  while (list[index] && strncmp (list[index], text, len)) {\n    index ++;\n  }\n  if (list[index]) {\n    *R = strdup (list[index]);\n    assert (*R);\n    return index;\n  } else {\n    *R = 0;\n    return -1;\n  }\n}\nvoid print_msg_success_gw (struct tgl_state *TLS, void *extra, int success, struct tgl_message *M);\nvoid print_encr_chat_success_gw (struct tgl_state *TLS, void *extra, int success, struct tgl_secret_chat *E);;\nvoid print_success_gw (struct tgl_state *TLS, void *extra, int success);\n\nint complete_command_list (int index, const char *text, int len, char **R) {\n  index ++;\n  while (commands[index].name && strncmp (commands[index].name, text, len)) {\n    index ++;\n  }\n  if (commands[index].name) {\n    *R = strdup (commands[index].name);\n    assert (*R);\n    return index;\n  } else {\n    *R = 0;\n    return -1;\n  }\n}\n\n\nint complete_spec_message_answer (struct tgl_message *M, int index, const char *text, int len, char **R) {\n  if (!M || !M->reply_markup || !M->reply_markup->rows) {\n    *R = NULL;\n    return -1;\n  }\n  index ++;\n\n  int total = M->reply_markup->row_start[M->reply_markup->rows];\n  while (index < total && strncmp (M->reply_markup->buttons[index], text, len)) {\n    index ++;\n  }\n  \n  if (index < total) {\n    *R = strdup (M->reply_markup->buttons[index]);\n    assert (*R);\n    return index;\n  } else {\n    *R = NULL;\n    return -1;\n  }\n}\n\nint complete_message_answer (tgl_peer_t *P, int index, const char *text, int len, char **R) {\n  struct tgl_message *M = P->last;\n  while (M && (M->flags & TGLMF_OUT)) {\n    M = M->next;\n  }\n\n\n  return complete_spec_message_answer (M, index, text, len, R);\n}\n\nint complete_user_command (tgl_peer_t *P, int index, const char *text, int len, char **R) {\n  if (len <= 0 || *text != '/') {\n    return complete_message_answer (P, index, text, len, R);\n  }\n  text ++;\n  len --;\n  struct tgl_user *U = (void *)P;\n  if (!U->bot_info) {\n    *R = NULL;\n    return -1;\n  }\n  if (index >= U->bot_info->commands_num) {\n    return U->bot_info->commands_num + complete_message_answer (P, index - U->bot_info->commands_num, text - 1, len + 1, R);\n  }\n  \n  index ++;\n  while (index < U->bot_info->commands_num && strncmp (U->bot_info->commands[index].command, text, len)) {\n    index ++;\n  }\n  if (index < U->bot_info->commands_num) {\n    *R = NULL;\n    assert (asprintf (R, \"/%s\", U->bot_info->commands[index].command) >= 0);\n    assert (*R);\n    return index;\n  } else {\n    return U->bot_info->commands_num + complete_message_answer (P, index - U->bot_info->commands_num, text - 1, len + 1, R);\n  }\n}\n\nint complete_chat_command (tgl_peer_t *P, int index, const char *text, int len, char **R) {\n  if (len <= 0 || *text != '/') {\n    return complete_message_answer (P, index, text, len, R);\n  }\n  text ++;\n  len --;\n\n  index ++;\n\n  int tot = 0;\n  int i;\n  for (i = 0; i < P->chat.user_list_size; i++) { \n    struct tgl_user *U = (void *)tgl_peer_get (TLS, TGL_MK_USER (P->chat.user_list[i].user_id));\n    if (!U) { continue; }\n    if (!U->bot_info) { continue; }\n    int p = len - 1;\n    while (p >= 0 && text[p] != '@') { p --; }\n    if (p < 0) { p = len; }\n    while (index - tot < U->bot_info->commands_num && strncmp (U->bot_info->commands[index - tot].command, text, p)) {\n      index ++;\n    }\n    if (index - tot < U->bot_info->commands_num) {\n      *R = NULL;\n      if (U->username) {\n        assert (asprintf (R, \"/%s@%s\", U->bot_info->commands[index].command, U->username) >= 0);\n      } else {\n        assert (asprintf (R, \"/%s\", U->bot_info->commands[index].command) >= 0);\n      }\n\n      assert (*R);\n      return index;\n    }\n    tot += U->bot_info->commands_num;\n  }\n\n  if (index == tot) {\n    return tot + complete_message_answer (P, index - tot, text - 1, len + 1, R);\n  } else {\n    return tot + complete_message_answer (P, index - tot - 1, text - 1, len + 1, R);\n  }\n}\n\nint complete_username (int mode, int index, const char *text, int len, char **R) {\n  *R = NULL;\n  if (len > 0 && *text == '@') {\n    text ++;\n    len --;\n  }\n  index ++;\n  while (index < TLS->peer_num) {\n    tgl_peer_t *P = TLS->Peers[index];\n    if (mode && tgl_get_peer_type (P->id) != mode) {\n      index ++;\n      continue;\n    }\n    char *u = NULL;\n    if (tgl_get_peer_type (P->id) == TGL_PEER_USER) {\n      u = P->user.username;\n    } else if (tgl_get_peer_type (P->id) == TGL_PEER_CHANNEL) {\n      u = P->channel.username;\n    }\n    if (!u) {\n      index ++;\n      continue;\n    }\n    if ((int)strlen (u) < len || memcmp (u, text, len)) {\n      index ++;\n      continue;\n    }\n    *R = malloc (strlen (u) + 2);\n    *R[0] = '@';\n    memcpy (*R + 1, u, strlen (u) + 1);\n    break;\n  }\n  if (index == TLS->peer_num) {\n    return -1;\n  }\n  return index;\n}\n\nchar *command_generator (const char *text, int state) {  \n#ifndef DISABLE_EXTF\n  static int len;\n#endif\n  static int index;\n  static enum command_argument mode;\n  static char *command_pos;\n  static int command_len;\n\n  if (in_chat_mode) {\n    char *R = 0;\n    index = complete_string_list (in_chat_commands, index, text, rl_point, &R);\n    return R;\n  }\n \n  char c = 0;\n  c = rl_line_buffer[rl_point];\n  rl_line_buffer[rl_point] = 0;\n  if (!state) {\n#ifndef DISABLE_EXTF\n    len = strlen (text);\n#endif\n    index = -1;\n    \n    mode = get_complete_mode ();\n    command_pos = cur_token;\n    command_len = cur_token_len;\n  } else {\n    if (mode != ca_file_name && mode != ca_file_name_end && index == -1) { return 0; }\n  }\n  \n  if (mode == ca_none || mode == ca_string || mode == ca_string_end || mode == ca_number || mode == ca_double || mode == ca_msg_id) {   \n    if (c) { rl_line_buffer[rl_point] = c; }\n    return 0; \n  }\n  assert (command_len >= 0);\n\n  char *R = 0;\n  switch (mode & 255) {\n  case ca_command:\n    index = complete_command_list (index, command_pos, command_len, &R);\n    if (c) { rl_line_buffer[rl_point] = c; }\n    return R;\n  case ca_user:\n    if (command_len && command_pos[0] == '@') {\n      index = complete_username (TGL_PEER_USER, index, command_pos, command_len, &R);\n    } else {\n      index = tgl_complete_user_list (TLS, index, command_pos, command_len, &R);    \n    }\n    if (c) { rl_line_buffer[rl_point] = c; }\n    return R;\n  case ca_peer:\n    if (command_len && command_pos[0] == '@') {\n      index = complete_username (0, index, command_pos, command_len, &R);\n    } else {\n      index = tgl_complete_peer_list (TLS, index, command_pos, command_len, &R);\n    }\n    if (c) { rl_line_buffer[rl_point] = c; }\n    return R;\n  case ca_file_name:\n  case ca_file_name_end:\n    if (c) { rl_line_buffer[rl_point] = c; }\n    R = rl_filename_completion_function (command_pos, state);\n    return R;\n  case ca_chat:\n    index = tgl_complete_chat_list (TLS, index, command_pos, command_len, &R);\n    if (c) { rl_line_buffer[rl_point] = c; }\n    return R;\n  case ca_secret_chat:\n    index = tgl_complete_encr_chat_list (TLS, index, command_pos, command_len, &R);\n    if (c) { rl_line_buffer[rl_point] = c; }\n    return R;\n  case ca_channel:\n    if (command_len && command_pos[0] == '@') {\n      index = complete_username (TGL_PEER_CHANNEL, index, command_pos, command_len, &R);\n    } else {\n      index = tgl_complete_channel_list (TLS, index, command_pos, command_len, &R);    \n    }\n    if (c) { rl_line_buffer[rl_point] = c; }\n    return R;\n  case ca_modifier:\n    index = complete_string_list (modifiers, index, command_pos, command_len, &R);\n    if (c) { rl_line_buffer[rl_point] = c; }\n    return R;\n  case ca_msg_string_end:\n    if (autocomplete_peer) {\n      if (tgl_get_peer_type (autocomplete_peer->id) == TGL_PEER_USER) {\n        index = complete_user_command (autocomplete_peer, index, command_pos, command_len, &R);\n      }\n      if (tgl_get_peer_type (autocomplete_peer->id) == TGL_PEER_CHAT) {\n        index = complete_chat_command (autocomplete_peer, index, command_pos, command_len, &R);\n      }\n    }\n    if (autocomplete_id.peer_type != (unsigned)NOT_FOUND) {\n      struct tgl_message *M = tgl_message_get (TLS, &autocomplete_id);\n      if (M) {\n        if (command_len > 0 && *command_pos == '/') {\n          tgl_peer_t *P = tgl_peer_get (TLS, M->from_id);\n          if (P) {\n            index = complete_user_command (autocomplete_peer, index, command_pos, command_len, &R);\n          }\n        } else {\n          index = complete_spec_message_answer (M, index, command_pos, command_len, &R);\n        }\n      }\n    }\n    if (c) { rl_line_buffer[rl_point] = c; }\n    return R;\n#ifndef DISABLE_EXTF\n  case ca_extf:\n    index = tglf_extf_autocomplete (TLS, text, len, index, &R, rl_line_buffer, rl_point);\n    if (c) { rl_line_buffer[rl_point] = c; }\n    return R;\n#endif\n  default:\n    if (c) { rl_line_buffer[rl_point] = c; }\n    return 0;\n  }\n}\n\nint count = 1;\nvoid work_modifier (const char *s, int l) {\n  if (is_same_word (s, l, \"[offline]\")) {\n    offline_mode = 1;\n  }\n  if (sscanf (s, \"[reply=%d]\", &reply_id) >= 1) {\n  }\n  \n  if (is_same_word (s, l, \"[html]\")) {\n    do_html = TGLMF_HTML;\n  }\n  if (is_same_word (s, l, \"[disable_preview]\")) {\n    disable_msg_preview = TGL_SEND_MSG_FLAG_DISABLE_PREVIEW;\n  }\n  if (is_same_word (s, l, \"[enable_preview]\")) {\n    disable_msg_preview = TGL_SEND_MSG_FLAG_ENABLE_PREVIEW;\n  }\n#ifdef ALLOW_MULT\n  if (sscanf (s, \"[x%d]\", &count) >= 1) {\n  }\n#endif\n}\n\nvoid print_fail (struct in_ev *ev) {\n  mprint_start (ev);\n  if (!enable_json) {\n    mprintf (ev, \"FAIL: %d: %s\\n\", TLS->error_code, TLS->error);\n  } else {\n  #ifdef USE_JSON\n    json_t *res = json_object ();\n    assert (json_object_set (res, \"result\", json_string (\"FAIL\")) >= 0);\n    assert (json_object_set (res, \"error_code\", json_integer (TLS->error_code)) >= 0);\n    assert (json_object_set (res, \"error\", json_string (TLS->error)) >= 0);\n    char *s = json_dumps (res, 0);\n    mprintf (ev, \"%s\\n\", s);\n    json_decref (res);\n    free (s);\n  #endif\n  }\n  mprint_end (ev);\n}\n\nvoid fail_interface (struct tgl_state *TLS, struct in_ev *ev, int error_code, const char *format, ...) {\n  static char error[1001];\n\n  va_list ap;\n  va_start (ap, format);\n  int error_len = vsnprintf (error, 1000, format, ap);\n  va_end (ap);\n  if (error_len > 1000) { error_len = 1000; }\n  error[error_len] = 0;\n\n  mprint_start (ev);\n  if (!enable_json) {\n    mprintf (ev, \"FAIL: %d: %s\\n\", error_code, error);\n  } else {\n  #ifdef USE_JSON\n    json_t *res = json_object ();\n    assert (json_object_set (res, \"result\", json_string (\"FAIL\")) >= 0);\n    assert (json_object_set (res, \"error_code\", json_integer (error_code)) >= 0);\n    assert (json_object_set (res, \"error\", json_string (error)) >= 0);\n    char *s = json_dumps (res, 0);\n    mprintf (ev, \"%s\\n\", s);\n    json_decref (res);\n    free (s);\n  #endif\n  }\n  mprint_end (ev);\n}\n\nvoid print_success (struct in_ev *ev) {\n  if (ev || enable_json) {\n    mprint_start (ev);\n    if (!enable_json) {\n      mprintf (ev, \"SUCCESS\\n\");\n    } else {\n      #ifdef USE_JSON\n        json_t *res = json_object ();\n        assert (json_object_set (res, \"result\", json_string (\"SUCCESS\")) >= 0);\n        char *s = json_dumps (res, 0);\n        mprintf (ev, \"%s\\n\", s);\n        json_decref (res);\n        free (s);\n      #endif\n    }\n    mprint_end (ev);\n  }\n}\n\nvoid print_success_gw (struct tgl_state *TLSR, void *extra, int success) {\n  assert (TLS == TLSR);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n  else { print_success (ev); return; }\n}\n\nvoid print_msg_success_gw (struct tgl_state *TLS, void *extra, int success, struct tgl_message *M) {\n  write_secret_chat_file ();\n  print_success_gw (TLS, extra, success);\n}\n\nvoid print_msg_list_success_gw (struct tgl_state *TLSR, void *extra, int success, int num, struct tgl_message *ML[]) {\n  assert (TLS == TLSR);\n  print_success_gw (TLSR, extra, success);\n}\n\nvoid print_encr_chat_success_gw (struct tgl_state *TLS, void *extra, int success, struct tgl_secret_chat *E) {\n  write_secret_chat_file ();\n  print_success_gw (TLS, extra, success);\n}\n\nvoid print_msg_list_gw (struct tgl_state *TLSR, void *extra, int success, int num, struct tgl_message *ML[]) {\n  assert (TLS == TLSR);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n\n  mprint_start (ev);\n  if (!enable_json) {\n    int i;\n    for (i = num - 1; i >= 0; i--) {\n      print_message (ev, ML[i]);\n    }\n  } else {\n    #ifdef USE_JSON\n      json_t *res = json_array ();\n      int i;\n      for (i = num - 1; i >= 0; i--) {\n        json_t *a = json_pack_message (ML[i]);\n        assert (json_array_append (res, a) >= 0);        \n      }\n      char *s = json_dumps (res, 0);\n      mprintf (ev, \"%s\\n\", s);\n      json_decref (res);\n      free (s);\n    #endif\n  }\n  mprint_end (ev);\n}\n\nvoid print_msg_list_history_gw (struct tgl_state *TLSR, void *extra, int success, int num, struct tgl_message *ML[]) {\n  print_msg_list_gw (TLSR, extra, success, num, ML);\n  if (num > 0) {\n    if (tgl_cmp_peer_id (ML[0]->to_id, TLS->our_id)) {\n      tgl_do_messages_mark_read (TLS, ML[0]->to_id, ML[0]->server_id, 0, NULL, NULL);\n    } else {\n      tgl_do_messages_mark_read (TLS, ML[0]->from_id, ML[0]->server_id, 0, NULL, NULL);\n    }\n  }\n}\n\nvoid print_msg_gw (struct tgl_state *TLSR, void *extra, int success, struct tgl_message *M) {\n  assert (TLS == TLSR);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n  mprint_start (ev);\n  if (!enable_json) {\n    print_message (ev, M);\n  } else {\n    #ifdef USE_JSON\n      json_t *res = json_pack_message (M);\n      char *s = json_dumps (res, 0);\n      mprintf (ev, \"%s\\n\", s);\n      json_decref (res);\n      free (s);\n    #endif\n  }\n  mprint_end (ev);\n}\n\nvoid print_user_list_gw (struct tgl_state *TLSR, void *extra, int success, int num, struct tgl_user *UL[]) {\n  assert (TLS == TLSR);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n  mprint_start (ev);\n  if (!enable_json) {\n    int i;\n    for (i = num - 1; i >= 0; i--) {\n      print_user_name (ev, UL[i]->id, (void *)UL[i]);\n      mprintf (ev, \"\\n\");\n    }\n  } else {\n    #ifdef USE_JSON\n      json_t *res = json_array ();\n      int i;\n      for (i = num - 1; i >= 0; i--) {\n        json_t *a = json_pack_peer (UL[i]->id);\n        assert (json_array_append (res, a) >= 0);\n      }\n      char *s = json_dumps (res, 0);\n      mprintf (ev, \"%s\\n\", s);\n      json_decref (res);\n      free (s);\n    #endif\n  }\n  mprint_end (ev);\n}\n\nvoid print_user_gw (struct tgl_state *TLSR, void *extra, int success, struct tgl_user *U) {\n  assert (TLS == TLSR);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n  mprint_start (ev);\n  if (!enable_json) {\n    print_user_name (ev, U->id, (void *)U);\n    mprintf (ev, \"\\n\");\n  } else {\n    #ifdef USE_JSON\n      json_t *res = json_pack_peer (U->id);\n      char *s = json_dumps (res, 0);\n      mprintf (ev, \"%s\\n\", s);\n      json_decref (res);\n      free (s);\n    #endif\n  }\n  mprint_end (ev);\n}\n\nvoid print_chat_gw (struct tgl_state *TLSR, void *extra, int success, struct tgl_chat *U) {\n  assert (TLS == TLSR);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n  mprint_start (ev);\n  if (!enable_json) {\n    print_chat_name (ev, U->id, (void *)U);\n    mprintf (ev, \"\\n\");\n  } else {\n    #ifdef USE_JSON\n      json_t *res = json_pack_peer (U->id);\n      char *s = json_dumps (res, 0);\n      mprintf (ev, \"%s\\n\", s);\n      json_decref (res);\n      free (s);\n    #endif\n  }\n  mprint_end (ev);\n}\n\nvoid print_channel_gw (struct tgl_state *TLSR, void *extra, int success, struct tgl_channel *U) {\n  assert (TLS == TLSR);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n  mprint_start (ev);\n  if (!enable_json) {\n    print_channel_name (ev, U->id, (void *)U);\n    mprintf (ev, \"\\n\");\n  } else {\n    #ifdef USE_JSON\n      json_t *res = json_pack_peer (U->id);\n      char *s = json_dumps (res, 0);\n      mprintf (ev, \"%s\\n\", s);\n      json_decref (res);\n      free (s);\n    #endif\n  }\n  mprint_end (ev);\n}\n\n\nvoid print_peer_gw (struct tgl_state *TLSR, void *extra, int success, tgl_peer_t *U) {\n  if (!success) { \n    print_user_gw (TLSR, extra, success, (void *)U);\n    return;\n  }\n  switch (tgl_get_peer_type (U->id)) {\n  case TGL_PEER_USER:\n    print_user_gw (TLSR, extra, success, (void *)U);\n    break;\n  case TGL_PEER_CHAT:\n    print_chat_gw (TLSR, extra, success, (void *)U);\n    break;\n  case TGL_PEER_CHANNEL:\n    print_channel_gw (TLSR, extra, success, (void *)U);\n    break;\n  default:\n    assert (0);\n  }\n}\n\nvoid print_filename_gw (struct tgl_state *TLSR, void *extra, int success, const char *name) {\n  assert (TLS == TLSR);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n  mprint_start (ev);\n  if (!enable_json) {\n    mprintf (ev, \"Saved to %s\\n\", name);\n  } else {\n    #ifdef USE_JSON\n      json_t *res = json_object ();\n      assert (json_object_set (res, \"result\", json_string (name)) >= 0);\n      assert (json_object_set (res, \"event\", json_string (\"download\")) >= 0);\n      char *s = json_dumps (res, 0);\n      mprintf (ev, \"%s\\n\", s);\n      json_decref (res);\n      free (s);\n    #endif\n  }\n  mprint_end (ev);\n}\n\nvoid print_string_gw (struct tgl_state *TLSR, void *extra, int success, const char *name) {\n  assert (TLS == TLSR);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n  mprint_start (ev);\n  if (!enable_json) {\n    mprintf (ev, \"%s\\n\", name);\n  } else {\n    #ifdef USE_JSON\n      json_t *res = json_object ();\n      assert (json_object_set (res, \"result\", json_string (name)) >= 0);\n      char *s = json_dumps (res, 0);\n      mprintf (ev, \"%s\\n\", s);\n      json_decref (res);\n      free (s);\n    #endif\n  }\n  mprint_end (ev);\n}\n\nvoid open_filename_gw (struct tgl_state *TLSR, void *extra, int success, const char *name) {\n  assert (TLS == TLSR);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (ev) { return; }\n  if (!success) { print_fail (ev); return; }\n  static char buf[PATH_MAX];\n  if (snprintf (buf, sizeof (buf), OPEN_BIN, name) >= (int) sizeof (buf)) {\n    logprintf (\"Open image command buffer overflow\\n\");\n  } else {\n    int pid = fork ();\n    if (!pid) {\n      execl(\"/bin/sh\", \"sh\", \"-c\", buf, (char *) 0);\n      exit (0);\n    }\n  }\n}\n\nvoid print_chat_info_gw (struct tgl_state *TLSR, void *extra, int success, struct tgl_chat *C) {\n  assert (TLS == TLSR);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n  mprint_start (ev);\n  \n  if (!enable_json) {\n    tgl_peer_t *U = (void *)C;\n    mpush_color (ev, COLOR_YELLOW);\n    mprintf (ev, \"Chat \");\n    print_chat_name (ev, U->id, U);\n    mprintf (ev, \" (id %d) members:\\n\", tgl_get_peer_id (U->id));\n    int i;\n    for (i = 0; i < C->user_list_size; i++) {\n      mprintf (ev, \"\\t\\t\");\n      print_user_name (ev, TGL_MK_USER (C->user_list[i].user_id), tgl_peer_get (TLS, TGL_MK_USER (C->user_list[i].user_id)));\n      mprintf (ev, \" invited by \");\n      print_user_name (ev, TGL_MK_USER (C->user_list[i].inviter_id), tgl_peer_get (TLS, TGL_MK_USER (C->user_list[i].inviter_id)));\n      mprintf (ev, \" at \");\n      print_date_full (ev, C->user_list[i].date);\n      if (C->user_list[i].user_id == C->admin_id) {\n        mprintf (ev, \" admin\");\n      }\n      mprintf (ev, \"\\n\");\n    }\n    mpop_color (ev);\n  } else {\n    #ifdef USE_JSON\n      json_t *res = json_pack_peer (C->id);\n      char *s = json_dumps (res, 0);\n      mprintf (ev, \"%s\\n\", s);\n      json_decref (res);\n      free (s);\n    #endif\n  }\n\n  mprint_end (ev);\n}\n\nvoid print_channel_info_gw (struct tgl_state *TLSR, void *extra, int success, struct tgl_channel *C) {\n  assert (TLS == TLSR);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n  mprint_start (ev);\n  \n  if (!enable_json) {\n    tgl_peer_t *U = (void *)C;\n    mpush_color (ev, COLOR_YELLOW);\n    mprintf (ev, \"Channel \");\n    if (U->flags & TGLCHF_OFFICIAL) {\n      mprintf (ev, \"[verified] \");\n    }\n    if (U->flags & TGLCHF_BROADCAST) {\n      mprintf (ev, \"[broadcast] \");\n    }\n    if (U->flags & TGLCHF_MEGAGROUP) {\n      mprintf (ev, \"[megagroup] \");\n    }\n    if (U->flags & TGLCHF_DEACTIVATED) {\n      mprintf (ev, \"[deactivated] \");\n    }\n    print_channel_name (ev, U->id, U);\n    if (C->username) {\n      mprintf (ev, \" @%s\", C->username);\n    }\n    mprintf (ev, \" (#%d):\\n\", tgl_get_peer_id (U->id));\n    mprintf (ev, \"\\tabout: %s\\n\", C->about);\n    mprintf (ev, \"\\t%d participants, %d admins, %d kicked\\n\", C->participants_count, C->admins_count, C->kicked_count);\n    mpop_color (ev);\n  } else {\n    #ifdef USE_JSON\n      json_t *res = json_pack_peer (C->id);\n      char *s = json_dumps (res, 0);\n      mprintf (ev, \"%s\\n\", s);\n      json_decref (res);\n      free (s);\n    #endif\n  }\n\n  mprint_end (ev);\n}\n\nvoid print_user_status (struct tgl_user_status *S, struct in_ev *ev) {\n  assert(!enable_json); //calling functions print_user_info_gw() and user_status_upd() already check.\n  if (S->online > 0) {\n    mprintf (ev, \"online (was online \");\n    print_date_full (ev, S->when);\n    mprintf (ev, \")\");\n  } else {\n    if (S->online == 0) {\n      mprintf (ev, \"offline\");\n    } else if (S->online == -1) {\n      mprintf (ev, \"offline (was online \");\n      print_date_full (ev, S->when);\n      mprintf (ev, \")\");\n    } else if (S->online == -2) {\n      mprintf (ev, \"offline (was online recently)\");\n    } else if (S->online == -3) {\n      mprintf (ev, \"offline (was online last week)\");\n    } else if (S->online == -4) {\n      mprintf (ev, \"offline (was online last month)\");\n    }\n  }\n}\n\nvoid print_user_info_gw (struct tgl_state *TLSR, void *extra, int success, struct tgl_user *U) {\n  assert (TLS == TLSR);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n  mprint_start (ev);\n  tgl_peer_t *C = (void *)U;\n  if (!enable_json) {\n    mpush_color (ev, COLOR_YELLOW);\n    mprintf (ev, \"User \");\n    print_user_name (ev, U->id, C);\n    if (U->username) {\n      mprintf (ev, \" @%s\", U->username);\n    }\n    mprintf (ev, \" (#%d):\\n\", tgl_get_peer_id (U->id));\n    mprintf (ev, \"\\tphone: %s\\n\", U->phone);\n    mprintf (ev, \"\\t\");\n    print_user_status (&U->status, ev);\n    mprintf (ev, \"\\n\");\n\n    if (U->bot_info) {\n      mprintf (ev, \"\\tshare_text:  %s\\n\", U->bot_info->share_text);\n      mprintf (ev, \"\\tdescription: %s\\n\", U->bot_info->description);\n      mprintf (ev, \"\\tcommands:\\n\");\n\n      int i;\n      for (i = 0; i < U->bot_info->commands_num; i++) {\n        mprintf (ev, \"\\t\\t/%s: %s\\n\", U->bot_info->commands[i].command, U->bot_info->commands[i].description);\n      }\n    }\n    mpop_color (ev);\n  } else {\n    #ifdef USE_JSON\n      json_t *res = json_pack_peer (U->id);\n      char *s = json_dumps (res, 0);\n      mprintf (ev, \"%s\\n\", s);\n      json_decref (res);\n      free (s);\n    #endif\n  }\n  mprint_end (ev);\n}\n\nvoid print_secret_chat_gw (struct tgl_state *TLSR, void *extra, int success, struct tgl_secret_chat *E) {\n  assert (TLS == TLSR);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n  mprint_start (ev);\n  if (!enable_json) {\n    mpush_color (ev, COLOR_YELLOW);\n    mprintf (ev, \" Encrypted chat \");\n    print_encr_chat_name (ev, E->id, (void *)E);\n    mprintf (ev, \" is now in wait state\\n\");\n    mpop_color (ev);\n  } else {\n    #ifdef USE_JSON\n      json_t *res = json_pack_peer (E->id);\n      char *s = json_dumps (res, 0);\n      mprintf (ev, \"%s\\n\", s);\n      json_decref (res);\n      free (s);\n    #endif\n  }\n  mprint_end (ev);\n}\n\nvoid print_dialog_list_gw (struct tgl_state *TLSR, void *extra, int success, int size, tgl_peer_id_t peers[], tgl_message_id_t *last_msg_id[], int unread_count[]) {\n  assert (TLS == TLSR);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n  mprint_start (ev);\n  if (!enable_json)  {\n    mpush_color (ev, COLOR_YELLOW);\n    int i;\n    for (i = size - 1; i >= 0; i--) {\n      tgl_peer_t *UC;\n      switch (tgl_get_peer_type (peers[i])) {\n        case TGL_PEER_USER:\n          UC = tgl_peer_get (TLS, peers[i]);\n          mprintf (ev, \"User \");\n          print_user_name (ev, peers[i], UC);\n          mprintf (ev, \": %d unread\\n\", unread_count[i]);\n          break;\n        case TGL_PEER_CHAT:\n          UC = tgl_peer_get (TLS, peers[i]);\n          mprintf (ev, \"Chat \");\n          print_chat_name (ev, peers[i], UC);\n          mprintf (ev, \": %d unread\\n\", unread_count[i]);\n          break;\n        case TGL_PEER_CHANNEL:\n          UC = tgl_peer_get (TLS, peers[i]);\n          mprintf (ev, \"Channel \");\n          print_channel_name (ev, peers[i], UC);\n          mprintf (ev, \": %d unread\\n\", unread_count[i]);\n          break;\n      }\n    }\n    mpop_color (ev);\n  } else {\n    #ifdef USE_JSON\n      json_t *res = json_array ();\n      int i;\n      for (i = size - 1; i >= 0; i--) {\n        json_t *a = json_pack_peer (peers[i]);\n        assert (json_array_append (res, a) >= 0);\n      }\n      char *s = json_dumps (res, 0);\n      mprintf (ev, \"%s\\n\", s);\n      json_decref (res);\n      free (s);\n    #endif\n  }\n  mprint_end (ev);\n}\n\nvoid interpreter_chat_mode (char *line) {\n  if (line == NULL || /* EOF received */\n          !strncmp (line, \"/exit\", 5) || !strncmp (line, \"/quit\", 5)) {\n    in_chat_mode = 0;\n    update_prompt ();\n    return;\n  }\n  if (!strncmp (line, \"/history\", 8)) {\n    int limit = 40;\n    sscanf (line, \"/history %99d\", &limit);\n    if (limit < 0 || limit > 1000) { limit = 40; }\n    tgl_do_get_history (TLS, chat_mode_id, 0, limit, offline_mode, print_msg_list_gw, 0);\n    return;\n  }\n  if (!strncmp (line, \"/read\", 5)) {\n    tgl_do_mark_read (TLS, chat_mode_id, 0, 0);\n    return;\n  }\n  if (strlen (line) > 0) {\n    tgl_do_send_message (TLS, chat_mode_id, line, strlen (line), 0, NULL, 0, 0);\n  }\n}\n\n#define MAX_UNREAD_MESSAGE_COUNT 10000\nstruct tgl_message *unread_message_list[MAX_UNREAD_MESSAGE_COUNT];\nint unread_message_count;\nstruct event *unread_message_event;\n\n\nvoid print_read_list (int num, struct tgl_message *list[]) {\n  struct in_ev *ev = notify_ev;\n  int i;\n  mprint_start (ev);\n  for (i = 0; i < num; i++) if (list[i]) {\n    if (enable_json) {\n      #ifdef USE_JSON\n        json_t *res = json_pack_read (list[i]);\n        char *s = json_dumps (res, 0);\n        mprintf (ev, \"%s\\n\", s);\n        json_decref (res);\n        free (s);\n      #endif\n    }\n    tgl_peer_id_t to_id;\n    if (!tgl_cmp_peer_id (list[i]->to_id, TLS->our_id)) {\n      to_id = list[i]->from_id;\n    } else {\n      to_id = list[i]->to_id;\n    }\n    int j;\n    int c1 = 0;\n    int c2 = 0;\n    for (j = i; j < num; j++) if (list[j]) {\n      tgl_peer_id_t end_id;\n      if (!tgl_cmp_peer_id (list[j]->to_id, TLS->our_id)) {\n        end_id = list[j]->from_id;\n      } else {\n        end_id = list[j]->to_id;\n      }\n      if (!tgl_cmp_peer_id (to_id, end_id)) {\n        if (list[j]->flags & TGLMF_OUT) {\n          c1 ++;\n        } else {\n          c2 ++;\n        }\n        list[j] = 0;\n      }\n    }\n\n    assert (c1 + c2 > 0);\n    if (!enable_json)  {\n      mpush_color (ev, COLOR_YELLOW);\n      switch (tgl_get_peer_type (to_id)) {\n      case TGL_PEER_USER:\n        mprintf (ev, \"User \");\n        print_user_name (ev, to_id, tgl_peer_get (TLS, to_id));\n        break;\n      case TGL_PEER_CHAT:\n        mprintf (ev, \"Chat \");\n        print_chat_name (ev, to_id, tgl_peer_get (TLS, to_id));\n        break;\n      case TGL_PEER_ENCR_CHAT:\n        mprintf (ev, \"Secret chat \");\n        print_encr_chat_name (ev, to_id, tgl_peer_get (TLS, to_id));\n        break;\n      default:\n        assert (0);\n      }\n      mprintf (ev, \" marked read %d outbox and %d inbox messages\\n\", c1, c2);\n      mpop_color (ev);\n    }\n  }\n  mprint_end (ev);\n}\n\nvoid unread_message_alarm (evutil_socket_t fd, short what, void *arg) {\n  print_read_list (unread_message_count, unread_message_list);\n  unread_message_count = 0;\n  event_free (unread_message_event);\n  unread_message_event = 0;\n}\n\nvoid mark_read_upd (struct tgl_state *TLSR, int num, struct tgl_message *list[]) {\n  assert (TLSR == TLS);\n  if (!binlog_read) { return; }\n  if (log_level < 1) { return; }\n\n  if (unread_message_count + num <= MAX_UNREAD_MESSAGE_COUNT) {\n    memcpy (unread_message_list + unread_message_count, list, num * sizeof (void *));\n    unread_message_count += num;\n\n    if (!unread_message_event) {\n      unread_message_event = evtimer_new (TLS->ev_base, unread_message_alarm, 0);\n      static struct timeval ptimeout = { 1, 0};\n      event_add (unread_message_event, &ptimeout);\n    }\n  } else {\n    print_read_list (unread_message_count, unread_message_list);\n    print_read_list (num, list);\n    unread_message_count = 0;\n    if (unread_message_event) {\n      event_free (unread_message_event);\n      unread_message_event = 0;\n    }\n  }\n}\n\nvoid print_typing (struct in_ev *ev, enum tgl_typing_status status) {\n  switch (status) {\n  case tgl_typing_none:\n    mprintf (ev, \"doing nothing\");\n    break;\n  case tgl_typing_typing:\n    mprintf (ev, \"typing\");\n    break;\n  case tgl_typing_cancel:\n    mprintf (ev, \"deleting typed message\");\n    break;\n  case tgl_typing_record_video:\n    mprintf (ev, \"recording video\");\n    break;\n  case tgl_typing_upload_video:\n    mprintf (ev, \"uploading video\");\n    break;\n  case tgl_typing_record_audio:\n    mprintf (ev, \"recording audio\");\n    break;\n  case tgl_typing_upload_audio:\n    mprintf (ev, \"uploading audio\");\n    break;\n  case tgl_typing_upload_photo:\n    mprintf (ev, \"uploading photo\");\n    break;\n  case tgl_typing_upload_document:\n    mprintf (ev, \"uploading document\");\n    break;\n  case tgl_typing_geo:\n    mprintf (ev, \"choosing location\");\n    break;\n  case tgl_typing_choose_contact:\n    mprintf (ev, \"choosing contact\");\n    break;\n  }\n}\n\nvoid type_notification_upd (struct tgl_state *TLSR, struct tgl_user *U, enum tgl_typing_status status) {\n  assert (TLSR == TLS);\n  if (log_level < 2 || (disable_output && !notify_ev)) { return; }\n  if (enable_json) { return; }\n  struct in_ev *ev = notify_ev;\n  mprint_start (ev);\n  mpush_color (ev, COLOR_YELLOW);\n  mprintf (ev, \"User \");\n  print_user_name (ev, U->id, (void *)U);\n  mprintf (ev, \" is \");\n  print_typing (ev, status);\n  mprintf (ev, \"\\n\");\n  mpop_color (ev);\n  mprint_end (ev);\n}\n\nvoid type_in_chat_notification_upd (struct tgl_state *TLSR, struct tgl_user *U, struct tgl_chat *C, enum tgl_typing_status status) {\n  assert (TLSR == TLS);\n  if (log_level < 2 || (disable_output && !notify_ev)) { return; }\n  if (enable_json) { return; }\n  struct in_ev *ev = notify_ev;\n  mprint_start (ev);\n  mpush_color (ev, COLOR_YELLOW);\n  mprintf (ev, \"User \");\n  print_user_name (ev, U->id, (void *)U);\n  mprintf (ev, \" is \");\n  print_typing (ev, status);\n  mprintf (ev, \" in chat \");\n  print_chat_name (ev, C->id, (void *)C);\n  mprintf (ev, \"\\n\");\n  mpop_color (ev);\n  mprint_end (ev);\n}\n\n\nvoid print_message_gw (struct tgl_state *TLSR, struct tgl_message *M) {\n  assert (TLSR == TLS);\n  #ifdef USE_LUA\n    lua_new_msg (M);\n  #endif\n  #ifdef USE_PYTHON\n    py_new_msg (M);\n  #endif\n  if (!binlog_read) { return; }\n  if (tgl_get_peer_type (M->to_id) == TGL_PEER_ENCR_CHAT) { \n    write_secret_chat_file ();\n  }\n  if (alert_sound) {\n    play_sound ();\n  }\n  if (disable_output && !notify_ev) { return; }\n  struct in_ev *ev = notify_ev;\n  mprint_start (ev);\n  if (!enable_json) {\n    print_message (ev, M);\n  } else {\n    #ifdef USE_JSON\n      json_t *res = json_pack_message (M);\n      char *s = json_dumps (res, 0);\n      mprintf (ev, \"%s\\n\", s);\n      json_decref (res);\n      free (s);\n    #endif\n  }\n  mprint_end (ev);\n}\n\nvoid our_id_gw (struct tgl_state *TLSR, tgl_peer_id_t id) {\n  assert (TLSR == TLS);\n  #ifdef USE_LUA\n    lua_our_id (id);\n  #endif\n  #ifdef USE_PYTHON\n    py_our_id (id);\n  #endif\n}\n\nvoid print_peer_updates (struct in_ev *ev, int flags) {\n  if (flags & TGL_UPDATE_PHONE) {\n    mprintf (ev, \" phone\");\n  }\n  if (flags & TGL_UPDATE_CONTACT) {\n    mprintf (ev, \" contact\");\n  }\n  if (flags & TGL_UPDATE_PHOTO) {\n    mprintf (ev, \" photo\");\n  }\n  if (flags & TGL_UPDATE_BLOCKED) {\n    mprintf (ev, \" blocked\");\n  }\n  if (flags & TGL_UPDATE_REAL_NAME) {\n    mprintf (ev, \" name\");\n  }\n  if (flags & TGL_UPDATE_NAME) {\n    mprintf (ev, \" contact_name\");\n  }\n  if (flags & TGL_UPDATE_REQUESTED) {\n    mprintf (ev, \" status\");\n  }\n  if (flags & TGL_UPDATE_WORKING) {\n    mprintf (ev, \" status\");\n  }\n  if (flags & TGL_UPDATE_FLAGS) {\n    mprintf (ev, \" flags\");\n  }\n  if (flags & TGL_UPDATE_TITLE) {\n    mprintf (ev, \" title\");\n  }\n  if (flags & TGL_UPDATE_ADMIN) {\n    mprintf (ev, \" admin\");\n  }\n  if (flags & TGL_UPDATE_MEMBERS) {\n    mprintf (ev, \" members\");\n  }\n  if (flags & TGL_UPDATE_ACCESS_HASH) {\n    mprintf (ev, \" access_hash\");\n  }\n  if (flags & TGL_UPDATE_USERNAME) {\n    mprintf (ev, \" username\");\n  }\n}\n\nvoid json_peer_update (struct in_ev *ev, tgl_peer_t *P, unsigned flags) {\n  #ifdef USE_JSON\n    json_t *res = json_object ();\n    assert (json_object_set (res, \"event\", json_string (\"updates\")) >= 0);\n    assert (json_object_set (res, \"peer\", json_pack_peer (P->id)) >= 0);\n    assert (json_object_set (res, \"updates\", json_pack_updates (flags)) >= 0);\n    char *s = json_dumps (res, 0);\n    mprintf (ev, \"%s\\n\", s);\n    json_decref (res);\n    free (s);\n  #endif\n}\n\nvoid peer_update_username (tgl_peer_t *P, const char *username) {\n  if (!username) {\n    if (P->extra) {\n      struct username_peer_pair *p = tree_lookup_username_peer_pair (username_peer_pair, (void *)&P->extra);      \n      assert (p);\n      username_peer_pair = tree_delete_username_peer_pair (username_peer_pair, p);\n      tfree_str (P->extra);\n      tfree (p, sizeof (*p));\n      P->extra = NULL;\n    }\n    return;\n  }\n  assert (username);\n  if (P->extra && !strcmp (P->extra, username)) {\n    return;\n  }\n  if (P->extra) {\n    struct username_peer_pair *p = tree_lookup_username_peer_pair (username_peer_pair, (void *)&P->extra);\n    assert (p);\n    username_peer_pair = tree_delete_username_peer_pair (username_peer_pair, p);\n    tfree_str (P->extra);\n    tfree (p, sizeof (*p));\n    P->extra = NULL;\n  }\n\n  P->extra = tstrdup (username);\n  struct username_peer_pair *p = talloc (sizeof (*p));\n  p->peer = P;\n  p->username = P->extra;\n  \n  username_peer_pair = tree_insert_username_peer_pair (username_peer_pair, p, rand ());\n}\n\nvoid user_update_gw (struct tgl_state *TLSR, struct tgl_user *U, unsigned flags) {\n  assert (TLSR == TLS);\n  #ifdef USE_LUA\n    lua_user_update (U, flags);\n  #endif\n  #ifdef USE_PYTHON\n    py_user_update (U, flags);\n  #endif\n\n  peer_update_username ((void *)U, U->username);\n \n  if (disable_output && !notify_ev) { return; }\n  if (!binlog_read) { return; }\n  struct in_ev *ev = notify_ev;\n\n  if (!(flags & TGL_UPDATE_CREATED)) {\n    mprint_start (ev);\n    if (!enable_json) {\n      mpush_color (ev, COLOR_YELLOW);\n      mprintf (ev, \"User \");\n      print_user_name (ev, U->id, (void *)U);\n      if (!(flags & TGL_UPDATE_DELETED)) {\n        mprintf (ev, \" updated\");\n        print_peer_updates (ev, flags);\n      } else {\n        mprintf (ev, \" deleted\");\n      }\n      mprintf (ev, \"\\n\");\n      mpop_color (ev);\n    } else {\n      json_peer_update (ev, (void *)U, flags);\n    }\n    mprint_end (ev);\n  }\n}\n\nvoid chat_update_gw (struct tgl_state *TLSR, struct tgl_chat *U, unsigned flags) {\n  assert (TLSR == TLS);\n  #ifdef USE_LUA\n    lua_chat_update (U, flags);\n  #endif\n  #ifdef USE_PYTHON\n    py_chat_update (U, flags);\n  #endif\n \n  if (disable_output && !notify_ev) { return; }\n  if (!binlog_read) { return; }\n  struct in_ev *ev = notify_ev;\n\n  if (!(flags & TGL_UPDATE_CREATED)) {\n    mprint_start (ev);\n    if (!enable_json) {\n      mpush_color (ev, COLOR_YELLOW);\n      mprintf (ev, \"Chat \");\n      print_chat_name (ev, U->id, (void *)U);\n      if (!(flags & TGL_UPDATE_DELETED)) {\n        mprintf (ev, \" updated\");\n        print_peer_updates (ev, flags);\n      } else {\n        mprintf (ev, \" deleted\");\n      }\n      mprintf (ev, \"\\n\");\n      mpop_color (ev);\n    } else {\n      json_peer_update (ev, (void *)U, flags);\n    }\n    mprint_end (ev);\n  }\n}\n\nvoid secret_chat_update_gw (struct tgl_state *TLSR, struct tgl_secret_chat *U, unsigned flags) {\n  assert (TLSR == TLS);\n  #ifdef USE_LUA\n    lua_secret_chat_update (U, flags);\n  #endif\n  #ifdef USE_PYTHON\n    py_secret_chat_update (U, flags);\n  #endif\n\n  if ((flags & TGL_UPDATE_WORKING) || (flags & TGL_UPDATE_DELETED)) {\n    write_secret_chat_file ();\n  }\n  \n  if (!binlog_read) { return; }\n\n  if ((flags & TGL_UPDATE_REQUESTED) && !disable_auto_accept)  {\n    //tgl_do_accept_encr_chat_request (TLS, U, 0, 0);\n    tgl_do_accept_encr_chat_request (TLS, U, print_encr_chat_success_gw, 0);\n  }\n  \n  if (disable_output && !notify_ev) { return; }\n  struct in_ev *ev = notify_ev;\n\n\n  if (!(flags & TGL_UPDATE_CREATED)) {\n    mprint_start (ev);\n    if (!enable_json) {\n      mpush_color (ev, COLOR_YELLOW);\n      mprintf (ev, \"Secret chat \");\n      print_encr_chat_name (ev, U->id, (void *)U);\n      if (!(flags & TGL_UPDATE_DELETED)) {\n        mprintf (ev, \" updated\");\n        print_peer_updates (ev, flags);\n      } else {\n        mprintf (ev, \" deleted\");\n      }\n      mprintf (ev, \"\\n\");\n      mpop_color (ev);\n    } else {\n      json_peer_update (ev, (void *)U, flags);\n    }\n    mprint_end (ev);\n  }\n}\n\nvoid channel_update_gw (struct tgl_state *TLSR, struct tgl_channel *U, unsigned flags) {\n  assert (TLSR == TLS);\n  \n  peer_update_username ((void *)U, U->username);\n \n  if (disable_output && !notify_ev) { return; }\n  if (!binlog_read) { return; }\n}\n\nvoid print_card_gw (struct tgl_state *TLSR, void *extra, int success, int size, int *card) {\n  assert (TLSR == TLS);\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n  mprint_start (ev);\n  if (!enable_json) {\n    mprintf (ev, \"Card: \");\n    int i;\n    for (i = 0; i < size; i++) {\n      mprintf (ev, \"%08x%c\", card[i], i == size - 1 ? '\\n' : ':');\n    }\n  } else {\n    #ifdef USE_JSON\n    static char q[1000];\n    int pos = 0;\n    int i;\n    for (i = 0; i < size; i++) {\n      pos += sprintf (q + pos, \"%08x%s\", card[i], i == size - 1 ? \"\" : \":\");\n    }\n    json_t *res = json_object ();\n    assert (json_object_set (res, \"result\", json_string (q)) >= 0);\n    char *s = json_dumps (res, 0);\n    mprintf (ev, \"%s\\n\", s);\n    json_decref (res);\n    free (s);\n    #endif\n  }\n  mprint_end (ev);\n}\n\nvoid callback_extf (struct tgl_state *TLS, void *extra, int success, const char *buf) {\n  struct in_ev *ev = extra;\n  if (ev && !--ev->refcnt) {\n    free (ev);\n    return;\n  }\n  if (!success) { print_fail (ev); return; }\n  mprint_start (ev);\n  if (!enable_json) {\n    mprintf (ev, \"%s\\n\", buf);\n  } else {\n    #ifdef USE_JSON\n    json_t *res = json_object ();\n    assert (json_object_set (res, \"result\", json_string (buf)) >= 0);\n    char *s = json_dumps (res, 0);\n    mprintf (ev, \"%s\\n\", s);\n    json_decref (res);\n    free (s);\n    #endif\n  }\n  mprint_end (ev);\n}\n\nvoid user_status_upd (struct tgl_state *TLS, struct tgl_user *U) {\n  if (disable_output && !notify_ev) { return; }\n  if (!binlog_read) { return; }\n  if (log_level < 3) { return; }\n  struct in_ev *ev = notify_ev;\n  mprint_start (ev);\n  if (!enable_json)\n  {\n    mpush_color (ev, COLOR_YELLOW);\n    mprintf (ev, \"User \");\n    print_user_name(ev, U->id, (void *) U);\n    mprintf (ev, \" \");\n    print_user_status(&U->status, ev);\n    mprintf (ev, \"\\n\");\n    mpop_color (ev);\n  } else {\n    #ifdef USE_JSON\n      json_t *res = json_pack_user_status(U);\n      char *s = json_dumps (res, 0);\n      mprintf (ev, \"%s\\n\", s);\n      json_decref (res);\n      free (s);\n    #endif\n  }\n  mprint_end (ev);\n}\n\nvoid on_login (struct tgl_state *TLS);\nvoid on_failed_login (struct tgl_state *TLS);\nvoid on_started (struct tgl_state *TLS);\nvoid do_get_values (struct tgl_state *TLS, enum tgl_value_type type, const char *prompt, int num_values,\n          void (*callback)(struct tgl_state *TLS, const char *string[], void *arg), void *arg);\n\nstruct tgl_update_callback upd_cb = {\n  .new_msg = print_message_gw,\n  .marked_read = mark_read_upd,\n  .logprintf = logprintf,\n  .get_values = do_get_values,\n  .logged_in = on_login,\n  .started = on_started,\n  .type_notification = type_notification_upd,\n  .type_in_chat_notification = type_in_chat_notification_upd,\n  .type_in_secret_chat_notification = 0,\n  .status_notification = 0,\n  .user_registered = 0,\n  .user_activated = 0,\n  .new_authorization = 0,\n  .user_update = user_update_gw,\n  .chat_update = chat_update_gw,\n  .secret_chat_update = secret_chat_update_gw,\n  .channel_update = channel_update_gw,\n  .msg_receive = print_message_gw,\n  .our_id = our_id_gw,\n  .user_status_update = user_status_upd,\n  .on_failed_login = on_failed_login\n};\n\n\nvoid interpreter_ex (char *line, void *ex) {  \n  force_end_mode = 1;\n  assert (!in_readline);\n  in_readline = 1;\n  if (in_chat_mode) {\n    interpreter_chat_mode (line);\n    in_readline = 0;\n    return;\n  }\n\n  do_html = 0;\n  line_ptr = line;\n  offline_mode = 0;\n  reply_id = 0;\n  disable_msg_preview = 0;\n  count = 1;\n  if (!line) { \n    do_safe_quit (NULL, 0, NULL, NULL);\n    in_readline = 0;\n    return; \n  }\n  if (!*line) {\n    in_readline = 0;\n    return;\n  }\n\n  if (line && *line) {\n    add_history (line);\n  }\n  \n  if (*line == '(') { \n    struct in_ev *ev = ex;\n    if (ev) { ev->refcnt ++; }\n    tgl_do_send_extf (TLS, line, strlen (line), callback_extf, ev);\n    in_readline = 0;\n    return; \n  }\n\n  while (1) {\n    next_token ();\n    if (cur_token_quoted) { \n      in_readline = 0;\n      fail_interface (TLS, ex, ENOSYS, \"can not parse modifier\");\n      return; \n    }\n\n    if (cur_token_len <= 0) { \n      in_readline = 0;\n      fail_interface (TLS, ex, ENOSYS, \"can not parse modifier\");\n      return; \n    }\n    \n    if (*cur_token == '[') {\n      if (cur_token_end_str) {\n        in_readline = 0;\n        fail_interface (TLS, ex, ENOSYS, \"can not parse modifier\");\n        return; \n      }\n      if (cur_token[cur_token_len - 1] != ']') {\n        in_readline = 0;\n        fail_interface (TLS, ex, ENOSYS, \"can not parse modifier\");\n        return; \n      }\n      work_modifier (cur_token, cur_token_len);\n      continue;\n    }\n    break;\n  }\n  if (cur_token_quoted || cur_token_end_str) { \n    fail_interface (TLS, ex, ENOSYS, \"can not parse command name\");\n    in_readline = 0;\n    return; \n  }\n    \n    \n  \n  struct command *command = commands;\n  int n = 0;\n  struct tgl_command;\n  while (command->name) {\n    if (is_same_word (cur_token, cur_token_len, command->name)) {\n      break;\n    }\n    n ++;\n    command ++;\n  }\n  \n  if (!command->name) {\n    fail_interface (TLS, ex, ENOSYS, \"can not find command '%.*s'\", cur_token_len, cur_token);\n    in_readline = 0;\n    return; \n  }\n\n  enum command_argument *flags = command->args;\n  void (*fun)(struct command *, int, struct arg[], struct in_ev *) = command->fun;\n  int args_num = 0;\n  static struct arg args[1000];\n  while (1) {\n    assert (args_num < 1000);\n    args[args_num].flags = 0;\n    int period = 0;\n    if (*flags == ca_period) {\n      flags --;\n    }\n    if (*flags != ca_none && *(flags + 1) == ca_period) {\n      period = 1;\n    }\n    enum command_argument op = (*flags) & 255;\n    int opt = (*flags) & ca_optional;\n\n    if (op == ca_none) { \n      next_token ();\n      if (cur_token_end_str) {\n        int z;\n        for (z = 0; z < count; z ++) {\n          fun (command, args_num, args, ex);\n        }\n      } else {\n        fail_interface (TLS, ex, ENOSYS, \"too many args #%d\", args_num);\n      }\n      break;\n    }\n      \n    if (op == ca_string_end || op == ca_file_name_end || op == ca_msg_string_end) {\n      next_token_end ();\n      if (cur_token_len < 0) { \n        fail_interface (TLS, ex, ENOSYS, \"can not parse string_end arg #%d\", args_num);\n        break;\n      } else {\n        args[args_num].flags = 1;\n        args[args_num ++].str = strndup (cur_token, cur_token_len);\n        int z;\n        for (z = 0; z < count; z ++) {\n          fun (command, args_num, args, ex);\n        }\n        break;\n      }\n    }\n\n    char *save = line_ptr;\n    next_token ();\n\n    if (period && cur_token_end_str) {\n      int z;\n      for (z = 0; z < count; z ++) {\n        fun (command, args_num, args, ex);\n      }\n      break;\n    }\n\n    if (op == ca_user || op == ca_chat || op == ca_secret_chat || op == ca_peer || op == ca_number || op == ca_double || op == ca_msg_id || op == ca_channel) {\n      if (cur_token_quoted) {\n        if (opt) {\n          if (op != ca_number && op != ca_double && op != ca_msg_id) {\n            args[args_num ++].peer_id = TGL_PEER_NOT_FOUND;\n          } else {\n            if (op == ca_number) {\n              args[args_num ++].num = NOT_FOUND;\n            } else if (op == ca_msg_id) {\n              args[args_num ++].msg_id.peer_type = 0;\n            } else {\n              args[args_num ++].dval = NOT_FOUND;\n            }\n          }\n          line_ptr = save;\n          flags ++;\n          continue;\n        } else if (period) {\n          line_ptr = save;\n          flags += 2;\n          continue;\n        } else {\n          break;\n        }\n      } else {\n        if (cur_token_end_str) { \n          if (opt) {\n            if (op != ca_number && op != ca_double && op != ca_msg_id) {\n              args[args_num ++].peer_id = TGL_PEER_NOT_FOUND;\n            } else {\n              if (op == ca_number) {\n                args[args_num ++].num = NOT_FOUND;\n              } else if (op == ca_msg_id) {\n                args[args_num ++].msg_id.peer_type = 0;\n              } else {\n                args[args_num ++].dval = NOT_FOUND;\n              }\n            }\n            line_ptr = save;\n            flags ++;\n            continue;\n          } else if (period) {\n            line_ptr = save;\n            flags += 2;\n            continue;\n          } else {\n            break;\n          }\n        }\n        int ok = 1;\n        switch (op) {\n        case ca_user:\n          args[args_num ++].peer_id = cur_token_user (); \n          ok = tgl_get_peer_id (args[args_num - 1].peer_id) != NOT_FOUND;\n          break;\n        case ca_chat:\n          args[args_num ++].peer_id = cur_token_chat (); \n          ok = tgl_get_peer_id (args[args_num - 1].peer_id) != NOT_FOUND;\n          break;\n        case ca_secret_chat:\n          args[args_num ++].peer_id = cur_token_encr_chat (); \n          ok = tgl_get_peer_id (args[args_num - 1].peer_id) != NOT_FOUND;\n          break;\n        case ca_channel:\n          args[args_num ++].peer_id = cur_token_channel (); \n          ok = tgl_get_peer_id (args[args_num - 1].peer_id) != NOT_FOUND;\n          break;\n        case ca_peer:\n          args[args_num ++].peer_id = cur_token_peer (); \n          ok = tgl_get_peer_id (args[args_num - 1].peer_id) != NOT_FOUND;\n          break;\n        case ca_number:\n          args[args_num ++].num = cur_token_int ();\n          ok = (args[args_num - 1].num != NOT_FOUND);\n          break;\n        case ca_msg_id:\n          args[args_num ++].msg_id = cur_token_msg_id ();\n          ok = (args[args_num - 1].msg_id.peer_type != 0);\n          break;\n        case ca_double:\n          args[args_num ++].dval = cur_token_double ();\n          ok = (args[args_num - 1].dval != NOT_FOUND);\n          break;\n        default:\n          assert (0);\n        }\n\n        if (period && !ok) {\n          line_ptr = save;\n          flags += 2;\n          args_num --;\n          continue;\n        }\n        if (opt && !ok) {\n          line_ptr = save;\n          flags ++;\n          continue;\n        }\n        if (!ok) {\n          fail_interface (TLS, ex, ENOSYS, \"can not parse arg #%d\", args_num);\n          break;\n        }\n\n        flags ++;\n        continue;\n      }\n    }\n    if (op == ca_string || op == ca_file_name || op == ca_command) {\n      if (cur_token_end_str || cur_token_len < 0) {\n        if (opt) {\n          args[args_num ++].str = NULL;\n          flags ++;\n          continue;\n        }\n        fail_interface (TLS, ex, ENOSYS, \"can not parse string arg #%d\", args_num);\n        break;\n      } else {\n        args[args_num].flags = 1;\n        args[args_num ++].str = strndup (cur_token, cur_token_len);\n        flags ++;\n        continue;\n      }\n    }\n    //assert (0);\n  }\n  int i;\n  for (i = 0; i < args_num; i++) {\n    if (args[i].flags & 1) {\n      free (args[i].str);\n    }\n  }\n  \n  update_prompt ();\n  in_readline = 0;\n}\n\nvoid interpreter (char *line) {\n  interpreter_ex (line, 0);\n}\n\nint readline_active;\n/*void rprintf (const char *format, ...) {\n  mprint_start (ev);\n  va_list ap;\n  va_start (ap, format);\n  vfprintf (stdout, format, ap);\n  va_end (ap);\n  print_end();\n}*/\n\nint saved_point;\nchar *saved_line;\nstatic int prompt_was;\n\n\nvoid deactivate_readline (void) {\n  if (read_one_string) {\n    printf (\"\\033[2K\\r\");\n    fflush (stdout);\n  } else {\n    saved_point = rl_point;\n    saved_line = malloc (rl_end + 1);\n    assert (saved_line);\n    saved_line[rl_end] = 0;\n    memcpy (saved_line, rl_line_buffer, rl_end);\n\n    rl_save_prompt();\n    rl_replace_line(\"\", 0);\n    rl_redisplay();\n  }\n}\n\n\nvoid reactivate_readline (void) {\n  if (read_one_string) {\n    printf (\"%s \", one_string_prompt);\n    if (!(one_string_flags & 1)) {\n      printf (\"%.*s\", one_string_len, one_string);\n    }\n    fflush (stdout);\n  } else {\n    set_prompt (get_default_prompt ());\n    rl_replace_line(saved_line, 0);\n    rl_point = saved_point;\n    rl_redisplay();\n    free (saved_line);\n  }\n}\n\nvoid print_start (void) {\n  if (in_readline) { return; }\n  if (readline_disabled) { return; }\n  assert (!prompt_was);\n  if (readline_active) {\n    deactivate_readline ();\n  }\n  prompt_was = 1;\n}\n\nvoid print_end (void) {\n  if (in_readline) { return; }\n  if (readline_disabled) { \n    fflush (stdout);\n    return; \n  }\n  assert (prompt_was);\n  if (readline_active) {\n    reactivate_readline ();\n  }\n  prompt_was = 0;\n}\n\n/*void hexdump (int *in_ptr, int *in_end) {\n  mprint_start (ev);\n  int *ptr = in_ptr;\n  while (ptr < in_end) { mprintf (ev, \" %08x\", *(ptr ++)); }\n  mprintf (ev, \"\\n\");\n  mprint_end (ev); \n}*/\n\nvoid logprintf (const char *format, ...) {\n  int x = 0;\n  if (!prompt_was) {\n    x = 1;\n    print_start ();\n  }\n  if (!disable_colors) {\n    printf (COLOR_GREY);\n  }\n  printf (\" *** \");\n\n\n  double T = tglt_get_double_time ();\n  printf (\"%.6lf \", T);\n\n  va_list ap;\n  va_start (ap, format);\n  vfprintf (stdout, format, ap);\n  va_end (ap);\n  if (!disable_colors) {\n    printf (COLOR_NORMAL);\n  }\n  if (x) {\n    print_end ();\n  }\n}\n\nint color_stack_pos;\nconst char *color_stack[10];\n\nvoid push_color (const char *color) {\n  if (disable_colors) { return; }\n  assert (color_stack_pos < 10);\n  color_stack[color_stack_pos ++] = color;\n  printf (\"%s\", color);\n}\n\nvoid pop_color (void) {\n  if (disable_colors) { return; }\n  assert (color_stack_pos > 0);\n  color_stack_pos --;\n  if (color_stack_pos >= 1) {\n    printf (\"%s\", color_stack[color_stack_pos - 1]);\n  } else {\n    printf (\"%s\", COLOR_NORMAL);\n  }\n}\n\nvoid print_media (struct in_ev *ev, struct tgl_message_media *M) {\n  assert (M);\n  switch (M->type) {\n    case tgl_message_media_none:\n      return;\n    case tgl_message_media_photo:\n      if (!M->photo) {\n        mprintf (ev, \"[photo bad]\");\n      } else if (M->photo->caption && strlen (M->photo->caption)) {\n        mprintf (ev, \"[photo %s]\", M->photo->caption);\n      } else {\n        mprintf (ev, \"[photo]\");\n      }\n      if (M->caption) {\n        mprintf (ev, \" %s\", M->caption);\n      }\n      return;\n    case tgl_message_media_document:\n    case tgl_message_media_audio:\n    case tgl_message_media_video:\n      mprintf (ev, \"[\");\n      assert (M->document);\n      if (M->document->flags & TGLDF_IMAGE) {\n        mprintf (ev, \"image\");\n      } else if (M->document->flags & TGLDF_AUDIO) {\n        mprintf (ev, \"audio\");\n      } else if (M->document->flags & TGLDF_VIDEO) {\n        mprintf (ev, \"video\");\n      } else if (M->document->flags & TGLDF_STICKER) {\n        mprintf (ev, \"sticker\");\n      } else {\n        mprintf (ev, \"document\");\n      }\n\n      if (M->document->caption && strlen (M->document->caption)) {\n        mprintf (ev, \" %s:\", M->document->caption);\n      } else {\n        mprintf (ev, \":\");\n      }\n      \n      if (M->document->mime_type) {\n        mprintf (ev, \" type=%s\", M->document->mime_type);\n      }\n\n      if (M->document->w && M->document->h) {\n        mprintf (ev, \" size=%dx%d\", M->document->w, M->document->h);\n      }\n\n      if (M->document->duration) {\n        mprintf (ev, \" duration=%d\", M->document->duration);\n      }\n      \n      mprintf (ev, \" size=\");\n      if (M->document->size < (1 << 10)) {\n        mprintf (ev, \"%dB\", M->document->size);\n      } else if (M->document->size < (1 << 20)) {\n        mprintf (ev, \"%dKiB\", M->document->size >> 10);\n      } else if (M->document->size < (1 << 30)) {\n        mprintf (ev, \"%dMiB\", M->document->size >> 20);\n      } else {\n        mprintf (ev, \"%dGiB\", M->document->size >> 30);\n      }\n      \n      mprintf (ev, \"]\");\n      \n      if (M->caption) {\n        mprintf (ev, \" %s\", M->caption);\n      }\n\n      return;\n    case tgl_message_media_document_encr:\n      mprintf (ev, \"[\");\n      if (M->encr_document->flags & TGLDF_IMAGE) {\n        mprintf (ev, \"image\");\n      } else if (M->encr_document->flags & TGLDF_AUDIO) {\n        mprintf (ev, \"audio\");\n      } else if (M->encr_document->flags & TGLDF_VIDEO) {\n        mprintf (ev, \"video\");\n      } else if (M->encr_document->flags & TGLDF_STICKER) {\n        mprintf (ev, \"sticker\");\n      } else {\n        mprintf (ev, \"document\");\n      }\n\n      if (M->encr_document->caption && strlen (M->encr_document->caption)) {\n        mprintf (ev, \" %s:\", M->encr_document->caption);\n      } else {\n        mprintf (ev, \":\");\n      }\n      \n      if (M->encr_document->mime_type) {\n        mprintf (ev, \" type=%s\", M->encr_document->mime_type);\n      }\n\n      if (M->encr_document->w && M->encr_document->h) {\n        mprintf (ev, \" size=%dx%d\", M->encr_document->w, M->encr_document->h);\n      }\n\n      if (M->encr_document->duration) {\n        mprintf (ev, \" duration=%d\", M->encr_document->duration);\n      }\n      \n      mprintf (ev, \" size=\");\n      if (M->encr_document->size < (1 << 10)) {\n        mprintf (ev, \"%dB\", M->encr_document->size);\n      } else if (M->encr_document->size < (1 << 20)) {\n        mprintf (ev, \"%dKiB\", M->encr_document->size >> 10);\n      } else if (M->encr_document->size < (1 << 30)) {\n        mprintf (ev, \"%dMiB\", M->encr_document->size >> 20);\n      } else {\n        mprintf (ev, \"%dGiB\", M->encr_document->size >> 30);\n      }\n      \n      mprintf (ev, \"]\");\n\n      return;\n    case tgl_message_media_geo:\n      mprintf (ev, \"[geo https://maps.google.com/?q=%.6lf,%.6lf]\", M->geo.latitude, M->geo.longitude);\n      return;\n    case tgl_message_media_contact:\n      mprintf (ev, \"[contact] \");\n      mpush_color (ev, COLOR_RED);\n      mprintf (ev, \"%s %s \", M->first_name, M->last_name);\n      mpop_color (ev);\n      mprintf (ev, \"%s\", M->phone);\n      return;\n    case tgl_message_media_unsupported:\n      mprintf (ev, \"[unsupported]\");\n      return;\n    case tgl_message_media_webpage:\n      mprintf (ev, \"[webpage:\");\n      assert (M->webpage);\n      if (M->webpage->url) {\n        mprintf (ev, \" url:'%s'\", M->webpage->url);\n      }\n      if (M->webpage->title) {\n        mprintf (ev, \" title:'%s'\", M->webpage->title);\n      }\n      if (M->webpage->description) {\n        mprintf (ev, \" description:'%s'\", M->webpage->description);\n      }\n      if (M->webpage->author) {\n        mprintf (ev, \" author:'%s'\", M->webpage->author);\n      }\n      mprintf (ev, \"]\");\n      break;\n    case tgl_message_media_venue:\n      mprintf (ev, \"[geo https://maps.google.com/?q=%.6lf,%.6lf\", M->venue.geo.latitude, M->venue.geo.longitude);\n      \n      if (M->venue.title) {\n        mprintf (ev, \" title:'%s'\", M->venue.title);\n      }\n      \n      if (M->venue.address) {\n        mprintf (ev, \" address:'%s'\", M->venue.address);\n      }\n      if (M->venue.provider) {\n        mprintf (ev, \" provider:'%s'\", M->venue.provider);\n      }\n      if (M->venue.venue_id) {\n        mprintf (ev, \" id:'%s'\", M->venue.venue_id);\n      }\n\n      mprintf (ev, \"]\");\n      return;\n      \n    default:\n      mprintf (ev, \"x = %d\\n\", M->type);\n      assert (0);\n  }\n}\n\nint unknown_user_list_pos;\nint unknown_user_list[1000];\n\nvoid print_peer_permanent_name (struct in_ev *ev, tgl_peer_id_t id) {\n  mprintf (ev, \"%s\", print_permanent_peer_id (id));\n}\n\nvoid print_user_name (struct in_ev *ev, tgl_peer_id_t id, tgl_peer_t *U) {\n  assert (tgl_get_peer_type (id) == TGL_PEER_USER);\n  mpush_color (ev, COLOR_RED);\n  if (permanent_peer_id_mode) {\n    print_peer_permanent_name (ev, id);\n    mpop_color (ev);\n    return;\n  }\n  if (!U) {\n    mprintf (ev, \"user#%d\", tgl_get_peer_id (id));\n    int i;\n    int ok = 1;\n    for (i = 0; i < unknown_user_list_pos; i++) {\n      if (unknown_user_list[i] == tgl_get_peer_id (id)) {\n        ok = 0;\n        break;\n      }\n    }\n    if (ok) {\n      assert (unknown_user_list_pos < 1000);\n      unknown_user_list[unknown_user_list_pos ++] = tgl_get_peer_id (id);\n    }\n  } else {\n    if (U->flags & (TGLUF_SELF | TGLUF_CONTACT)) {\n      mpush_color (ev, COLOR_REDB);\n    }\n    if ((U->flags & TGLUF_DELETED)) {\n      mprintf (ev, \"deleted user#%d\", tgl_get_peer_id (id));\n    } else if (!(U->flags & TGLUF_CREATED)) {\n      mprintf (ev, \"user#%d\", tgl_get_peer_id (id));\n    } else if (use_ids) {\n      mprintf (ev, \"user#%d\", tgl_get_peer_id (id));\n    } else if (!U->user.first_name || !strlen (U->user.first_name)) {\n      mprintf (ev, \"%s\", U->user.last_name);\n    } else if (!U->user.last_name || !strlen (U->user.last_name)) {\n      mprintf (ev, \"%s\", U->user.first_name);\n    } else {\n      mprintf (ev, \"%s %s\", U->user.first_name, U->user.last_name); \n    }\n    if (U->flags & (TGLUF_SELF | TGLUF_CONTACT)) {\n      mpop_color (ev);\n    }\n  }\n  mpop_color (ev);\n}\n\nvoid print_chat_name (struct in_ev *ev, tgl_peer_id_t id, tgl_peer_t *C) {\n  assert (tgl_get_peer_type (id) == TGL_PEER_CHAT);\n  mpush_color (ev, COLOR_MAGENTA);\n  if (permanent_peer_id_mode) {\n    print_peer_permanent_name (ev, id);\n    mpop_color (ev);\n    return;\n  }\n  if (!C || use_ids) {\n    mprintf (ev, \"chat#%d\", tgl_get_peer_id (id));\n  } else {\n    mprintf (ev, \"%s\", C->chat.title);\n  }\n  mpop_color (ev);\n}\n\nvoid print_channel_name (struct in_ev *ev, tgl_peer_id_t id, tgl_peer_t *C) {\n  assert (tgl_get_peer_type (id) == TGL_PEER_CHANNEL);\n  mpush_color (ev, COLOR_CYAN);\n  if (permanent_peer_id_mode) {\n    print_peer_permanent_name (ev, id);\n    mpop_color (ev);\n    return;\n  }\n  if (!C || use_ids) {\n    mprintf (ev, \"channel#%d\", tgl_get_peer_id (id));\n  } else {\n    mprintf (ev, \"%s\", C->channel.title);\n  }\n  mpop_color (ev);\n}\n\nvoid print_encr_chat_name (struct in_ev *ev, tgl_peer_id_t id, tgl_peer_t *C) {\n  assert (tgl_get_peer_type (id) == TGL_PEER_ENCR_CHAT);\n  mpush_color (ev, COLOR_MAGENTA);\n  if (permanent_peer_id_mode) {\n    print_peer_permanent_name (ev, id);\n    mpop_color (ev);\n    return;\n  }\n  if (!C || use_ids) {\n    mprintf (ev, \"encr_chat#%d\", tgl_get_peer_id (id));\n  } else {\n    mprintf (ev, \"%s\", C->print_name);\n  }\n  mpop_color (ev);\n}\n\nvoid print_peer_name  (struct in_ev *ev, tgl_peer_id_t id, tgl_peer_t *C) {\n  switch (tgl_get_peer_type (id)) {\n  case TGL_PEER_USER:\n    print_user_name (ev, id, C);\n    return;\n  case TGL_PEER_CHAT:\n    print_chat_name (ev, id, C);\n    return;\n  case TGL_PEER_CHANNEL:\n    print_channel_name (ev, id, C);\n    return;\n  case TGL_PEER_ENCR_CHAT:\n    print_encr_chat_name (ev, id, C);\n    return;\n  default:\n    assert (0);\n  }\n}\n\nstatic char *monthes[] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\nvoid print_date (struct in_ev *ev, long t) {\n  struct tm *tm = localtime ((void *)&t);\n  if (time (0) - t < 12 * 60 * 60) {\n    mprintf (ev, \"[%02d:%02d] \", tm->tm_hour, tm->tm_min);\n  } else if (time (0) - t < 24 * 60 * 60 * 180) {\n    mprintf (ev, \"[%02d %s]\", tm->tm_mday, monthes[tm->tm_mon]);\n  } else {\n    mprintf (ev, \"[%02d %s %d]\", tm->tm_mday, monthes[tm->tm_mon], tm->tm_year + 1900);\n  }\n}\n\nvoid print_date_full (struct in_ev *ev, long t) {\n  struct tm *tm = localtime ((void *)&t);\n  mprintf (ev, \"[%04d/%02d/%02d %02d:%02d:%02d]\", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);\n}\n\nvoid print_msg_id (struct in_ev *ev, tgl_message_id_t msg_id, struct tgl_message *M) {\n  if (msg_num_mode) {\n    if (!permanent_msg_id_mode) {\n      if (M) {\n        mprintf (ev, \"%d\", M->temp_id);\n      } else {\n        mprintf (ev, \"???\");\n      }\n    } else {\n      mprintf (ev, \"%s\", print_permanent_msg_id (msg_id));\n    }\n  }\n}\n\nvoid print_service_message (struct in_ev *ev, struct tgl_message *M) {\n  assert (M);\n  //print_start ();\n  mpush_color (ev, COLOR_GREY);\n\n  if (tgl_get_peer_type (M->to_id) == TGL_PEER_CHANNEL) {\n    mpush_color (ev, COLOR_CYAN);\n  } else {\n    mpush_color (ev, COLOR_MAGENTA);\n  }\n  print_msg_id (ev, M->permanent_id, M);\n  mprintf (ev, \" \");\n  print_date (ev, M->date);\n  mpop_color (ev);\n  mprintf (ev, \" \");\n  if (tgl_get_peer_type (M->to_id) == TGL_PEER_CHAT) {\n    print_chat_name (ev, M->to_id, tgl_peer_get (TLS, M->to_id));\n  } else if (tgl_get_peer_type (M->to_id) == TGL_PEER_CHANNEL) {\n    print_channel_name (ev, M->to_id, tgl_peer_get (TLS, M->to_id));\n  } else {\n    assert (tgl_get_peer_type (M->to_id) == TGL_PEER_ENCR_CHAT);\n    print_encr_chat_name (ev, M->to_id, tgl_peer_get (TLS, M->to_id));\n  }\n\n  if (tgl_get_peer_type (M->from_id) == TGL_PEER_USER) {\n    mprintf (ev, \" \");\n    print_user_name (ev, M->from_id, tgl_peer_get (TLS, M->from_id));\n  }\n \n  switch (M->action.type) {\n  case tgl_message_action_none:\n    mprintf (ev, \"\\n\");\n    break;\n  case tgl_message_action_geo_chat_create:\n    mprintf (ev, \"Created geo chat\\n\");\n    break;\n  case tgl_message_action_geo_chat_checkin:\n    mprintf (ev, \"Checkin in geochat\\n\");\n    break;\n  case tgl_message_action_chat_create:\n    mprintf (ev, \" created chat %s. %d users\\n\", M->action.title, M->action.user_num);\n    break;\n  case tgl_message_action_chat_edit_title:\n    mprintf (ev, \" changed title to %s\\n\", \n      M->action.new_title);\n    break;\n  case tgl_message_action_chat_edit_photo:\n    mprintf (ev, \" changed photo\\n\");\n    break;\n  case tgl_message_action_chat_delete_photo:\n    mprintf (ev, \" deleted photo\\n\");\n    break;\n  case tgl_message_action_chat_add_users:\n    mprintf (ev, \" added users:\");\n    {\n      int i;\n      for (i = 0; i < M->action.user_num; i++) {\n        print_user_name (ev, tgl_set_peer_id (TGL_PEER_USER, M->action.users[i]), tgl_peer_get (TLS, tgl_set_peer_id (TGL_PEER_USER, M->action.users[i])));\n      }\n    }\n    mprintf (ev, \"\\n\");\n    break;\n  case tgl_message_action_chat_add_user_by_link:\n    mprintf (ev, \" added by link from \");\n    print_user_name (ev, tgl_set_peer_id (TGL_PEER_USER, M->action.user), tgl_peer_get (TLS, tgl_set_peer_id (TGL_PEER_USER, M->action.user)));\n    mprintf (ev, \"\\n\");\n    break;\n  case tgl_message_action_chat_delete_user:\n    mprintf (ev, \" deleted user \");\n    print_user_name (ev, tgl_set_peer_id (TGL_PEER_USER, M->action.user), tgl_peer_get (TLS, tgl_set_peer_id (TGL_PEER_USER, M->action.user)));\n    mprintf (ev, \"\\n\");\n    break;\n  case tgl_message_action_set_message_ttl:\n    mprintf (ev, \" set ttl to %d seconds. Unsupported yet\\n\", M->action.ttl);\n    break;\n  case tgl_message_action_read_messages:\n    mprintf (ev, \" %d messages marked read\\n\", M->action.read_cnt);\n    break;\n  case tgl_message_action_delete_messages:\n    mprintf (ev, \" %d messages deleted\\n\", M->action.delete_cnt);\n    break;\n  case tgl_message_action_screenshot_messages:\n    mprintf (ev, \" %d messages screenshoted\\n\", M->action.screenshot_cnt);\n    break;\n  case tgl_message_action_flush_history:\n    mprintf (ev, \" cleared history\\n\");\n    break;\n  case tgl_message_action_resend:\n    mprintf (ev, \" resend query\\n\");\n    break;\n  case tgl_message_action_notify_layer:\n    mprintf (ev, \" updated layer to %d\\n\", M->action.layer);\n    break;\n  case tgl_message_action_typing:\n    mprintf (ev, \" is \");\n    print_typing (ev, M->action.typing);\n    break;\n  case tgl_message_action_noop:\n    mprintf (ev, \" noop\\n\");\n    break;\n  case tgl_message_action_request_key:\n    mprintf (ev, \" request rekey #%016llx\\n\", M->action.exchange_id);\n    break;\n  case tgl_message_action_accept_key:\n    mprintf (ev, \" accept rekey #%016llx\\n\", M->action.exchange_id);\n    break;\n  case tgl_message_action_commit_key:\n    mprintf (ev, \" commit rekey #%016llx\\n\", M->action.exchange_id);\n    break;\n  case tgl_message_action_abort_key:\n    mprintf (ev, \" abort rekey #%016llx\\n\", M->action.exchange_id);\n    break;\n  case tgl_message_action_channel_create:\n    mprintf (ev, \" created channel %s\\n\", M->action.title);\n    break;\n  case tgl_message_action_migrated_to:\n    mprintf (ev, \" migrated to channel\\n\");\n    break;\n  case tgl_message_action_migrated_from:\n    mprintf (ev, \" migrated from group '%s'\\n\", M->action.title);\n    break;\n  }\n  mpop_color (ev);\n  //print_end ();\n}\n\ntgl_peer_id_t last_from_id;\ntgl_peer_id_t last_to_id;\n\nvoid print_message (struct in_ev *ev, struct tgl_message *M) {\n  assert (M);\n  if (M->flags & (TGLMF_EMPTY | TGLMF_DELETED)) {\n    return;\n  }\n  if (!(M->flags & TGLMF_CREATED)) { return; }\n  if (M->flags & TGLMF_SERVICE) {\n    print_service_message (ev, M);\n    return;\n  }\n  if (!tgl_get_peer_type (M->to_id)) {\n    logprintf (\"Bad msg\\n\");\n    return;\n  }\n\n  last_from_id = M->from_id;\n  last_to_id = M->to_id;\n\n  //print_start ();\n  if (tgl_get_peer_type (M->to_id) == TGL_PEER_USER) {\n    if (M->flags & TGLMF_OUT) {\n      mpush_color (ev, COLOR_GREEN);\n      print_msg_id (ev, M->permanent_id, M);\n      mprintf (ev, \" \");\n      print_date (ev, M->date);\n      mpop_color (ev);\n      mprintf (ev, \" \");\n      print_user_name (ev, M->to_id, tgl_peer_get (TLS, M->to_id));\n      mpush_color (ev, COLOR_GREEN);\n      if (M->flags & TGLMF_UNREAD) {\n        mprintf (ev, \" <<< \");\n      } else {\n        mprintf (ev, \" ««« \");\n      }\n    } else {\n      mpush_color (ev, COLOR_BLUE);\n      print_msg_id (ev, M->permanent_id, M);\n      mprintf (ev, \" \");\n      print_date (ev, M->date);\n      mpop_color (ev);\n      mprintf (ev, \" \");\n      print_user_name (ev, M->from_id, tgl_peer_get (TLS, M->from_id));\n      mpush_color (ev, COLOR_BLUE);\n      if (M->flags & TGLMF_UNREAD) {\n        mprintf (ev, \" >>> \");\n      } else {\n        mprintf (ev, \" »»» \");\n      }\n    }\n  } else if (tgl_get_peer_type (M->to_id) == TGL_PEER_ENCR_CHAT) {\n    tgl_peer_t *P = tgl_peer_get (TLS, M->to_id);\n    assert (P);\n    if (M->flags & TGLMF_UNREAD) {\n      mpush_color (ev, COLOR_GREEN);\n      print_msg_id (ev, M->permanent_id, M);\n      mprintf (ev, \" \");\n      print_date (ev, M->date);\n      mprintf (ev, \" \");\n      mpush_color (ev, COLOR_CYAN);\n      mprintf (ev, \" %s\", P->print_name);\n      mpop_color (ev);\n      if (M->flags & TGLMF_UNREAD) {\n        mprintf (ev, \" <<< \");\n      } else {\n        mprintf (ev, \" ««« \");\n      }\n    } else {\n      mpush_color (ev, COLOR_BLUE);\n      print_msg_id (ev, M->permanent_id, M);\n      mprintf (ev, \" \");\n      print_date (ev, M->date);\n      mpush_color (ev, COLOR_CYAN);\n      mprintf (ev, \" %s\", P->print_name);\n      mpop_color (ev);\n      if (M->flags & TGLMF_UNREAD) {\n        mprintf (ev, \" >>> \");\n      } else {\n        mprintf (ev, \" »»» \");\n      }\n    }\n  } else if (tgl_get_peer_type (M->to_id) == TGL_PEER_CHAT) {\n    mpush_color (ev, COLOR_MAGENTA);\n    print_msg_id (ev, M->permanent_id, M);\n    mprintf (ev, \" \");\n    print_date (ev, M->date);\n    mpop_color (ev);\n    mprintf (ev, \" \");\n    print_chat_name (ev, M->to_id, tgl_peer_get (TLS, M->to_id));\n    mprintf (ev, \" \");\n    print_user_name (ev, M->from_id, tgl_peer_get (TLS, M->from_id));\n    if (!tgl_cmp_peer_id (M->from_id, TLS->our_id)) {\n      mpush_color (ev, COLOR_GREEN);\n    } else {\n      mpush_color (ev, COLOR_BLUE);\n    }\n    if (M->flags & TGLMF_UNREAD) {\n      mprintf (ev, \" >>> \");\n    } else {\n      mprintf (ev, \" »»» \");\n    }\n  } else {\n    assert (tgl_get_peer_type (M->to_id) == TGL_PEER_CHANNEL);\n    \n    mpush_color (ev, COLOR_CYAN);\n    print_msg_id (ev, M->permanent_id, M);\n    mprintf (ev, \" \");\n    print_date (ev, M->date);\n    mpop_color (ev);\n    mprintf (ev, \" \");\n    print_channel_name (ev, M->to_id, tgl_peer_get (TLS, M->to_id));\n\n    if (tgl_get_peer_type (M->from_id) == TGL_PEER_USER) {\n      mprintf (ev, \" \");\n      print_user_name (ev, M->from_id, tgl_peer_get (TLS, M->from_id));\n      if (!tgl_cmp_peer_id (M->from_id, TLS->our_id)) {\n        mpush_color (ev, COLOR_GREEN);\n      } else {\n        mpush_color (ev, COLOR_BLUE);\n      }\n    } else {\n      mpush_color (ev, COLOR_BLUE);\n    }\n    if (M->flags & TGLMF_UNREAD) {\n      mprintf (ev, \" >>> \");\n    } else {\n      mprintf (ev, \" »»» \");\n    }\n  }\n  if (tgl_get_peer_type (M->fwd_from_id) > 0) {\n    mprintf (ev, \"[fwd from \");\n    print_peer_name (ev, M->fwd_from_id, tgl_peer_get (TLS, M->fwd_from_id));\n    mprintf (ev, \" \");\n    print_date (ev, M->date);\n    mprintf (ev, \"] \");\n  }\n  if (M->reply_id) {\n    mprintf (ev, \"[reply to \");\n    tgl_message_id_t msg_id = M->permanent_id;\n    msg_id.id = M->reply_id;\n    struct tgl_message *N = tgl_message_get (TLS, &msg_id);\n    print_msg_id (ev, msg_id, N);\n    mprintf (ev, \"] \");\n  }\n  if (M->flags & TGLMF_MENTION) {\n    mprintf (ev, \"[mention] \");\n  }\n  if (M->message && strlen (M->message)) {\n    mprintf (ev, \"%s\", M->message);\n  }\n  if (M->media.type != tgl_message_media_none) {\n    if (M->message && strlen (M->message)) {\n      mprintf (ev, \" \");\n    }\n    print_media (ev, &M->media);\n  }\n  mpop_color (ev);\n  assert (!color_stack_pos);\n  mprintf (ev, \"\\n\");\n  //print_end();\n}\n\nvoid play_sound (void) {\n  printf (\"\\a\");\n}\n\nvoid set_interface_callbacks (void) {\n  if (readline_disabled) { return; }\n  readline_active = 1;\n  rl_filename_quote_characters = strdup (\" \");\n  rl_basic_word_break_characters = strdup (\" \");\n  \n  \n  rl_callback_handler_install (get_default_prompt (), interpreter);\n  rl_completion_entry_function = command_generator;\n}\n"
        },
        {
          "name": "interface.h",
          "type": "blob",
          "size": 2.8994140625,
          "content": "/*\n    This file is part of telegram-cli.\n\n    Telegram-cli is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n\n    Telegram-cli is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this telegram-cli.  If not, see <http://www.gnu.org/licenses/>.\n\n    Copyright Vitaly Valtman 2013-2015\n*/\n#ifndef __INTERFACE_H__\n#define __INTERFACE_H__\n#include <tgl/tgl-structures.h>\n#include <tgl/tgl-layout.h>\n\n#define COLOR_RED \"\\033[0;31m\"\n#define COLOR_REDB \"\\033[1;31m\"\n#define COLOR_NORMAL \"\\033[0m\"\n#define COLOR_GREEN \"\\033[32;1m\"\n#define COLOR_GREY \"\\033[37;1m\"\n#define COLOR_YELLOW \"\\033[33;1m\"\n#define COLOR_BLUE \"\\033[34;1m\"\n#define COLOR_MAGENTA \"\\033[35;1m\"\n#define COLOR_CYAN \"\\033[36;1m\"\n#define COLOR_LCYAN \"\\033[0;36m\"\n\n#define COLOR_INVERSE \"\\033[7m\"\n\nchar *get_default_prompt (void);\nchar *complete_none (const char *text, int state);\nchar **complete_text (char *text, int start, int end);\nvoid interpreter (char *line);\nvoid interpreter_ex (char *line, void *ex);\n\nvoid rprintf (const char *format, ...) __attribute__ ((format (printf, 1, 2)));\nvoid logprintf (const char *format, ...) __attribute__ ((format (printf, 1, 2)));\n\n#define vlogprintf(v,...) \\\n  do { \\\n    if (TLS->verbosity >= (v)) {\\\n      logprintf (__VA_ARGS__);\\\n    }\\\n  } while (0);\\\n\n\n//void hexdump (int *in_ptr, int *in_end);\n\nstruct bufferevent;\nstruct in_ev {\n  struct bufferevent *bev;\n  char in_buf[4096];\n  int in_buf_pos;\n  int refcnt;\n  int error;\n  int fd;\n};\n\n\nstruct tgl_message;\nstruct in_ev;\nvoid print_message (struct in_ev *ev, struct tgl_message *M);\nvoid print_chat_name (struct in_ev *ev, tgl_peer_id_t id, tgl_peer_t *C);\nvoid print_channel_name (struct in_ev *ev, tgl_peer_id_t id, tgl_peer_t *C);\nvoid print_user_name (struct in_ev *ev, tgl_peer_id_t id, tgl_peer_t *U);\nvoid print_encr_chat_name_full (struct in_ev *ev, tgl_peer_id_t id, tgl_peer_t *C);\nvoid print_encr_chat_name (struct in_ev *ev, tgl_peer_id_t id, tgl_peer_t *C);\n//void print_media (struct tgl_message_media *M);\n//\nvoid pop_color (void);\nvoid push_color (const char *color);\nvoid print_start (void);\nvoid print_end (void);\nvoid print_date_full (struct in_ev *ev, long t);\nvoid print_date (struct in_ev *ev, long t);\n\nvoid play_sound (void);\nvoid update_prompt (void);\nvoid set_interface_callbacks (void);\n\nchar *print_permanent_msg_id (tgl_message_id_t id);\nchar *print_permanent_peer_id (tgl_peer_id_t id);\ntgl_peer_id_t parse_input_peer_id (const char *s, int l, int mask);\ntgl_message_id_t parse_input_msg_id (const char *s, int l);\n#endif\n"
        },
        {
          "name": "json-tg.c",
          "type": "blob",
          "size": 18.9091796875,
          "content": "#include \"config.h\"\n#ifdef USE_JSON\n\n#include <jansson.h>\n#include \"json-tg.h\"\n#include <tgl/tgl.h>\n#include <tgl/tgl-layout.h>\n#include \"interface.h\"\n#include <assert.h>\n//format time:\n#include <time.h>\n\n#ifndef json_boolean\n#define json_boolean(val)      ((val) ? json_true() : json_false())\n#endif\n\nextern struct tgl_state *TLS;\n\nvoid json_pack_peer_type (json_t *res, tgl_peer_id_t id) {\n  int x = tgl_get_peer_type (id);\n  switch (x) {\n  case TGL_PEER_USER:\n    assert (json_object_set (res, \"peer_type\", json_string (\"user\")) >= 0);\n    break;\n  case TGL_PEER_CHAT:\n    assert (json_object_set (res, \"peer_type\", json_string (\"chat\")) >= 0);\n    break;\n  case TGL_PEER_ENCR_CHAT:\n    assert (json_object_set (res, \"peer_type\", json_string (\"encr_chat\")) >= 0);\n    break;\n  case TGL_PEER_CHANNEL:\n    assert (json_object_set (res, \"peer_type\", json_string (\"channel\")) >= 0);\n    break;\n  default:\n    assert (0);\n  }\n}\n\nint str_format_time(long when, char* string)\n{\n  struct tm *tm = localtime ((void *)&when);\n  return sprintf (string, \"%04d-%02d-%02d %02d:%02d:%02d\", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);\n}\n\nvoid json_pack_user (json_t *res, tgl_peer_t *P) {\n  if (P->user.first_name) {\n    assert (json_object_set (res, \"first_name\", json_string (P->user.first_name)) >= 0);\n  }\n\n  if (P->user.status.when) {\n    static char s[20];\n    str_format_time(P->user.status.when, s);\n    assert (json_object_set (res, \"when\", json_string (s)) >= 0);\n  }\n\n  if (P->user.last_name) {\n    assert (json_object_set (res, \"last_name\", json_string (P->user.last_name)) >= 0);\n  }\n  if (P->user.real_first_name) {\n    assert (json_object_set (res, \"real_first_name\", json_string (P->user.real_first_name)) >= 0);\n  }\n  if (P->user.real_last_name) {\n    assert (json_object_set (res, \"real_last_name\", json_string (P->user.real_last_name)) >= 0);\n  }\n  if (P->user.phone) {\n    assert (json_object_set (res, \"phone\", json_string (P->user.phone)) >= 0);\n  }\n  if (P->user.username) {\n    assert (json_object_set (res, \"username\", json_string (P->user.username)) >= 0);\n  }\n}\n\nvoid json_pack_chat (json_t *res, tgl_peer_t *P) {\n  assert (P->chat.title);\n  assert (json_object_set (res, \"title\", json_string (P->chat.title)) >= 0);\n  tgl_peer_id_t admin_id = TGL_MK_USER (P->chat.admin_id);\n  assert (json_object_set (res, \"admin\", json_pack_peer (admin_id)) >= 0);\n  assert (json_object_set (res, \"members_num\", json_integer (P->chat.users_num)) >= 0);\n  if (P->chat.user_list) {\n    json_t *m = json_array ();\n    assert (m);\n\n    int i;\n    for (i = 0; i < P->chat.users_num; i++) {\n      tgl_peer_id_t user_id = TGL_MK_USER (P->chat.user_list[i].user_id);\n      tgl_peer_id_t inviter_id = TGL_MK_USER (P->chat.user_list[i].inviter_id);\n      json_t *peer = json_pack_peer (user_id);\n      assert (json_object_set (peer, \"inviter\", json_pack_peer (inviter_id)) >= 0);\n      assert (json_array_append (m, peer) >= 0);\n    }\n\n    assert (json_object_set (res, \"members\", m) >= 0);\n  }\n}\n\nvoid json_pack_channel (json_t *res, tgl_peer_t *P) {\n  assert (P->channel.title);\n  assert (json_object_set (res, \"title\", json_string (P->channel.title)) >= 0);\n  assert (json_object_set (res, \"participants_count\", json_integer (P->channel.participants_count)) >= 0);\n  assert (json_object_set (res, \"admins_count\", json_integer (P->channel.admins_count)) >= 0);\n  assert (json_object_set (res, \"kicked_count\", json_integer (P->channel.kicked_count)) >= 0);\n}\n\n\nvoid json_pack_encr_chat (json_t *res, tgl_peer_t *P) {\n  assert (json_object_set (res, \"user\", json_pack_peer (TGL_MK_USER (P->encr_chat.user_id))) >= 0);\n}\n\njson_t *json_pack_peer (tgl_peer_id_t id) {\n  tgl_peer_t *P = tgl_peer_get (TLS, id);\n  //assert (P);\n  json_t *res = json_object ();\n  assert (json_object_set (res, \"id\", json_string (print_permanent_peer_id (id))) >= 0);\n\n  json_pack_peer_type (res, id);\n  assert (json_object_set (res, \"peer_id\", json_integer (tgl_get_peer_id (id))) >= 0);\n\n  assert (res);\n    \n  if (!P || !(P->flags & TGLPF_CREATED)) {\n    static char s[100];\n    switch (tgl_get_peer_type (id)) {\n    case TGL_PEER_USER:\n      sprintf (s, \"user#%d\", tgl_get_peer_id (id));\n      break;\n    case TGL_PEER_CHAT:\n      sprintf (s, \"chat#%d\", tgl_get_peer_id (id));\n      break;\n    case TGL_PEER_CHANNEL:\n      sprintf (s, \"channel#%d\", tgl_get_peer_id (id));\n      break;\n    case TGL_PEER_ENCR_CHAT:\n      sprintf (s, \"encr_chat#%d\", tgl_get_peer_id (id));\n      break;\n    default:\n      assert (0);\n    }\n    \n    assert (json_object_set (res, \"print_name\", json_string (s)) >= 0);\n    return res;\n  }\n  if(P->print_name != NULL){\n    assert (json_object_set (res, \"print_name\", json_string (P->print_name)) >= 0);\n  } else {\n    assert (json_object_set (res, \"print_name\", json_string (\"\")) >= 0);\n  }\n  assert (json_object_set (res, \"flags\", json_integer (P->flags)) >= 0);\n  \n  switch (tgl_get_peer_type (id)) {\n  case TGL_PEER_USER:\n    json_pack_user (res, P);\n    break;\n  case TGL_PEER_CHAT:\n    json_pack_chat (res, P);\n    break;\n  case TGL_PEER_ENCR_CHAT:\n    json_pack_encr_chat (res, P);\n    break;\n  case TGL_PEER_CHANNEL:\n    json_pack_channel (res, P);\n    break;\n  default:\n    assert (0);\n  }\n  return res;\n}\n\njson_t *json_pack_updates (unsigned flags) {\n  json_t *a = json_array ();\n  \n  if (flags & TGL_UPDATE_CREATED) {\n    assert (json_array_append (a, json_string (\"created\")) >= 0);\n  }  \n  if (flags & TGL_UPDATE_DELETED) {\n    assert (json_array_append (a, json_string (\"deleted\")) >= 0);\n  }  \n  if (flags & TGL_UPDATE_PHONE) {\n    assert (json_array_append (a, json_string (\"phone\")) >= 0);\n  }\n  if (flags & TGL_UPDATE_CONTACT) {\n    assert (json_array_append (a, json_string (\"contact\")) >= 0);\n  }\n  if (flags & TGL_UPDATE_PHOTO) {\n    assert (json_array_append (a, json_string (\"photo\")) >= 0);\n  }\n  if (flags & TGL_UPDATE_BLOCKED) {\n    assert (json_array_append (a, json_string (\"blocked\")) >= 0);\n  }\n  if (flags & TGL_UPDATE_REAL_NAME) {\n    assert (json_array_append (a, json_string (\"real_name\")) >= 0);\n  }\n  if (flags & TGL_UPDATE_NAME) {\n    assert (json_array_append (a, json_string (\"name\")) >= 0);\n  }\n  if (flags & TGL_UPDATE_REQUESTED) {\n    assert (json_array_append (a, json_string (\"requested\")) >= 0);\n  }\n  if (flags & TGL_UPDATE_WORKING) {\n    assert (json_array_append (a, json_string (\"working\")) >= 0);\n  }\n  if (flags & TGL_UPDATE_FLAGS) {\n    assert (json_array_append (a, json_string (\"flags\")) >= 0);\n  }\n  if (flags & TGL_UPDATE_TITLE) {\n    assert (json_array_append (a, json_string (\"title\")) >= 0);\n  }\n  if (flags & TGL_UPDATE_ADMIN) {\n    assert (json_array_append (a, json_string (\"admin\")) >= 0);\n  }\n  if (flags & TGL_UPDATE_MEMBERS) {\n    assert (json_array_append (a, json_string (\"members\")) >= 0);\n  }\n  if (flags & TGL_UPDATE_USERNAME) {\n    assert (json_array_append (a, json_string (\"username\")) >= 0);\n  }\n\n  return a;\n}\n\n\njson_t *json_pack_media (struct tgl_message_media *M) {\n  json_t *res = json_object ();\n\n  switch (M->type) {\n  case tgl_message_media_photo:\n    assert (json_object_set (res, \"type\", json_string (\"photo\")) >= 0);\n    if (M->caption) {\n      assert (json_object_set (res, \"caption\", json_string (M->caption)) >= 0);\n    }\n    break;\n  case tgl_message_media_document:\n  case tgl_message_media_audio:\n  case tgl_message_media_video:\n  case tgl_message_media_document_encr:\n    assert (json_object_set (res, \"type\", json_string (\"document\")) >= 0);\n    break;\n  case tgl_message_media_unsupported:\n    assert (json_object_set (res, \"type\", json_string (\"unsupported\")) >= 0);\n    break;\n  case tgl_message_media_geo:\n    assert (json_object_set (res, \"type\", json_string (\"geo\")) >= 0);\n    assert (json_object_set (res, \"longitude\", json_real (M->geo.longitude)) >= 0);\n    assert (json_object_set (res, \"latitude\", json_real (M->geo.latitude)) >= 0);\n    break;\n  case tgl_message_media_contact:\n    assert (json_object_set (res, \"type\", json_string (\"contact\")) >= 0);\n    assert (json_object_set (res, \"phone\", json_string (M->phone)) >= 0);\n    assert (json_object_set (res, \"first_name\", json_string (M->first_name)) >= 0);\n    assert (json_object_set (res, \"last_name\", json_string (M->last_name)) >= 0);\n    assert (json_object_set (res, \"user_id\", json_integer (M->user_id)) >= 0);\n    break;\n  case tgl_message_media_webpage:\n    assert (json_object_set (res, \"type\", json_string (\"webpage\")) >= 0);\n    if (M->webpage->url) {\n      assert (json_object_set (res, \"url\", json_string (M->webpage->url)) >= 0);\n    }\n    if (M->webpage->title) {\n      assert (json_object_set (res, \"title\", json_string (M->webpage->title)) >= 0);\n    }\n    if (M->webpage->description) {\n      assert (json_object_set (res, \"description\", json_string (M->webpage->description)) >= 0);\n    }\n    if (M->webpage->author) {\n      assert (json_object_set (res, \"author\", json_string (M->webpage->author)) >= 0);\n    }\n    break;\n  case tgl_message_media_venue:\n    assert (json_object_set (res, \"type\", json_string (\"venue\")) >= 0);\n    assert (json_object_set (res, \"longitude\", json_real (M->venue.geo.longitude)) >= 0);\n    assert (json_object_set (res, \"latitude\", json_real (M->venue.geo.latitude)) >= 0);\n    if (M->venue.title) {\n      assert (json_object_set (res, \"type\", json_string (M->venue.title)) >= 0);\n    }\n    if (M->venue.address) {\n      assert (json_object_set (res, \"address\", json_string (M->venue.address)) >= 0);\n    }\n    if (M->venue.provider) {\n      assert (json_object_set (res, \"provider\", json_string (M->venue.provider)) >= 0);\n    }\n    if (M->venue.venue_id) {\n      assert (json_object_set (res, \"venue_id\", json_string (M->venue.venue_id)) >= 0);\n    }\n    break;\n  default:\n    assert (json_object_set (res, \"type\", json_string (\"???\")) >= 0);\n  }\n  return res;\n}\n\njson_t *json_pack_typing (enum tgl_typing_status status) {\n  json_t *res = json_object ();\n  switch (status) {\n    case tgl_typing_none:\n      assert (json_object_set (res, \"status\", json_string (\"doing nothing\")) >= 0);\n      break;\n    case tgl_typing_typing:\n      assert (json_object_set (res, \"status\", json_string (\"typing\")) >= 0);\n      break;\n    case tgl_typing_cancel:\n       assert (json_object_set (res, \"status\", json_string (\"deleting typed message\")) >= 0);\n       break;\n    case tgl_typing_record_video:\n       assert (json_object_set (res, \"status\", json_string (\"recording video\")) >= 0);\n       break;\n    case tgl_typing_upload_video:\n       assert (json_object_set (res, \"status\", json_string (\"uploading video\")) >= 0);\n       break;\n    case tgl_typing_record_audio:\n       assert (json_object_set (res, \"status\", json_string (\"recording audio\")) >= 0);\n       break;\n    case tgl_typing_upload_audio:\n       assert (json_object_set (res, \"status\", json_string (\"uploading audio\")) >= 0);\n       break;\n    case tgl_typing_upload_photo:\n       assert (json_object_set (res, \"status\", json_string (\"uploading photo\")) >= 0);\n       break;\n    case tgl_typing_upload_document:\n       assert (json_object_set (res, \"status\", json_string (\"uploading document\")) >= 0);\n       break;\n    case tgl_typing_geo:\n       assert (json_object_set (res, \"status\", json_string (\"choosing location\")) >= 0);\n       break;\n    case tgl_typing_choose_contact:\n       assert (json_object_set (res, \"status\", json_string (\"choosing contact\")) >= 0);\n       break;\n    default:\n       assert (json_object_set (res, \"status\", json_string (\"???\")) >= 0);\n       break;\n  }\n  return res;\n}\n\njson_t *json_pack_service (struct tgl_message *M) {\n  json_t *res = json_object ();\n  switch (M->action.type) {\n  case tgl_message_action_geo_chat_create:\n    assert (json_object_set (res, \"type\", json_string (\"geo_created\")) >= 0);\n    break;\n  case tgl_message_action_geo_chat_checkin:\n    assert (json_object_set (res, \"type\", json_string (\"geo_checkin\")) >= 0);\n    break;\n  case tgl_message_action_chat_create:\n    assert (json_object_set (res, \"type\", json_string (\"chat_created\")) >= 0);\n    assert (json_object_set (res, \"title\", json_string (M->action.title)) >= 0);\n    break;\n  case tgl_message_action_chat_edit_title:\n    assert (json_object_set (res, \"type\", json_string (\"chat_rename\")) >= 0);\n    assert (json_object_set (res, \"title\", json_string (M->action.title)) >= 0);\n    break;\n  case tgl_message_action_chat_edit_photo:\n    assert (json_object_set (res, \"type\", json_string (\"chat_change_photo\")) >= 0);\n    break;\n  case tgl_message_action_chat_delete_photo:\n    assert (json_object_set (res, \"type\", json_string (\"chat_delete_photo\")) >= 0);\n    break;\n  case tgl_message_action_chat_add_users:\n    assert (json_object_set (res, \"type\", json_string (\"chat_add_user\")) >= 0);\n    assert (json_object_set (res, \"user\", json_pack_peer (tgl_set_peer_id (TGL_PEER_USER, M->action.users[0]))) >= 0);\n    break;\n  case tgl_message_action_chat_add_user_by_link:\n    assert (json_object_set (res, \"type\", json_string (\"chat_add_user_link\")) >= 0);\n    assert (json_object_set (res, \"user\", json_pack_peer (tgl_set_peer_id (TGL_PEER_USER, M->action.user))) >= 0);\n    break;\n  case tgl_message_action_chat_delete_user:\n    assert (json_object_set (res, \"type\", json_string (\"chat_del_user\")) >= 0);\n    assert (json_object_set (res, \"user\", json_pack_peer (tgl_set_peer_id (TGL_PEER_USER, M->action.user))) >= 0);\n    break;\n  case tgl_message_action_set_message_ttl:\n    assert (json_object_set (res, \"type\", json_string (\"set_ttl\")) >= 0);\n    assert (json_object_set (res, \"ttl\", json_integer (M->action.ttl)) >= 0);\n    break;\n  case tgl_message_action_read_messages:\n    assert (json_object_set (res, \"type\", json_string (\"read\")) >= 0);\n    assert (json_object_set (res, \"count\", json_integer (M->action.read_cnt)) >= 0);\n    break;\n  case tgl_message_action_delete_messages:\n    assert (json_object_set (res, \"type\", json_string (\"delete\")) >= 0);\n    assert (json_object_set (res, \"count\", json_integer (M->action.delete_cnt)) >= 0);\n    break;\n  case tgl_message_action_screenshot_messages:\n    assert (json_object_set (res, \"type\", json_string (\"screenshot\")) >= 0);\n    assert (json_object_set (res, \"count\", json_integer (M->action.screenshot_cnt)) >= 0);\n    break;\n  case tgl_message_action_flush_history:\n    assert (json_object_set (res, \"type\", json_string (\"flush\")) >= 0);\n    break;\n  case tgl_message_action_resend:\n    assert (json_object_set (res, \"type\", json_string (\"resend\")) >= 0);\n    break;\n  case tgl_message_action_notify_layer:\n    assert (json_object_set (res, \"type\", json_string (\"notify_layer\")) >= 0);\n    assert (json_object_set (res, \"layer\", json_integer (M->action.layer)) >= 0);\n    break;\n  case tgl_message_action_typing:    \n    assert (json_object_set (res, \"type\", json_string (\"typing\")) >= 0);\n    assert (json_array_append (res, json_pack_typing (M->action.typing)) >= 0);\n    break;\n  case tgl_message_action_noop:\n    assert (json_object_set (res, \"type\", json_string (\"noop\")) >= 0);\n    break;\n  case tgl_message_action_request_key:\n    assert (json_object_set (res, \"type\", json_string (\"request_key\")) >= 0);\n    break;\n  case tgl_message_action_accept_key:\n    assert (json_object_set (res, \"type\", json_string (\"accept_key\")) >= 0);\n    break;\n  case tgl_message_action_commit_key:\n    assert (json_object_set (res, \"type\", json_string (\"commit_key\")) >= 0);\n    break;\n  case tgl_message_action_abort_key:\n    assert (json_object_set (res, \"type\", json_string (\"abort_key\")) >= 0);\n    break;\n  case tgl_message_action_channel_create:\n    assert (json_object_set (res, \"type\", json_string (\"channel_created\")) >= 0);\n    assert (json_object_set (res, \"title\", json_string (M->action.title)) >= 0);\n    break;\n  case tgl_message_action_migrated_to:\n    assert (json_object_set (res, \"type\", json_string (\"migrated_to\")) >= 0);\n    break;\n  case tgl_message_action_migrated_from:\n    assert (json_object_set (res, \"type\", json_string (\"migrated_from\")) >= 0);\n    break;\n  default:\n    assert (json_object_set (res, \"type\", json_string (\"???\")) >= 0);\n    break;\n  }\n  return res;\n}\n\njson_t *json_pack_message (struct tgl_message *M) {  \n  json_t *res = json_object ();\n  assert (json_object_set (res, \"event\", json_string (\"message\")) >= 0);\n  //will overwriten to service, if service.\n\n  assert (json_object_set (res, \"id\", json_string (print_permanent_msg_id (M->permanent_id))) >= 0);\n  if (!(M->flags & TGLMF_CREATED)) { return res; }\n\n  assert (json_object_set (res, \"flags\", json_integer (M->flags)) >= 0);\n \n  if (tgl_get_peer_type (M->fwd_from_id)) {\n    assert (json_object_set (res, \"fwd_from\", json_pack_peer (M->fwd_from_id)) >= 0);\n    assert (json_object_set (res, \"fwd_date\", json_integer (M->fwd_date)) >= 0);\n  }\n\n  if (M->reply_id) {\n    tgl_message_id_t msg_id = M->permanent_id;\n    msg_id.id = M->reply_id;\n    \n    assert (json_object_set (res, \"reply_id\", json_string (print_permanent_msg_id (msg_id))) >= 0);\n  }\n\n  if (M->flags & TGLMF_MENTION) {\n    assert (json_object_set (res, \"mention\", json_true ()) >= 0);\n  }\n \n  assert (json_object_set (res, \"from\", json_pack_peer (M->from_id)) >= 0);\n  assert (json_object_set (res, \"to\", json_pack_peer (M->to_id)) >= 0);\n  \n  assert (json_object_set (res, \"out\", json_boolean (M->flags & TGLMF_OUT)) >= 0);\n  assert (json_object_set (res, \"unread\", json_boolean (M->flags & TGLMF_UNREAD)) >= 0);\n  assert (json_object_set (res, \"service\", json_boolean (M->flags & TGLMF_SERVICE)) >= 0);\n  assert (json_object_set (res, \"date\", json_integer (M->date)) >= 0);\n  \n  if (!(M->flags & TGLMF_SERVICE)) {  \n    if (M->message_len && M->message) {\n      assert (json_object_set (res, \"text\", json_string (M->message)) >= 0);\n    }\n    if (M->media.type && M->media.type != tgl_message_media_none) {\n      assert (json_object_set (res, \"media\", json_pack_media (&M->media)) >= 0);\n    }\n  } else {\n    assert (json_object_set (res, \"event\", json_string (\"service\")) >= 0);\n    assert (json_object_set (res, \"action\", json_pack_service (M)) >= 0);\n  }\n  return res;\n}\n\njson_t *json_pack_read (struct tgl_message *M) {\n  json_t *res = json_pack_message (M);\n  assert (json_object_set (res, \"event\", json_string (\"read\")) >= 0);\n  //this will overwrite \"event\":\"message\" to \"event\":\"read\".\n  return res;\n}\n\njson_t *json_pack_user_status (struct tgl_user *U) {\n  json_t *res = json_object ();\n  assert (json_object_set (res, \"user\",  json_pack_peer (U->id)) >= 0);\n  struct tgl_user_status *S = &U->status;\n  assert (json_object_set (res, \"online\", json_boolean (S->online == 1)) >= 0);\n  assert (json_object_set (res, \"state\", json_integer (S->online)) >= 0);\n  if (S->online > 0 || S->online == -1) {\n    static char s[20];\n    str_format_time(S->when, s);\n    assert (json_object_set (res, \"when\", json_string (s)) >= 0);\n  } else if (S->online == 0) {\n    assert (json_object_set(res, \"when\", json_string(\"long time ago\")) >= 0);\n  } else if (S->online == -2) {\n    assert (json_object_set(res, \"when\", json_string(\"recently\")) >= 0);\n  } else if (S->online == -3) {\n    assert (json_object_set(res, \"when\", json_string(\"last week\")) >= 0);\n  } else if (S->online == -4) {\n    assert (json_object_set (res, \"when\", json_string (\"last month\")) >= 0);\n  }\n  assert (json_object_set (res, \"event\", json_string (\"online-status\")) >= 0);\n  //this will overwrite \"event\":\"message\" to \"event\":\"read\".\n  return res;\n}\n\n#endif\n"
        },
        {
          "name": "json-tg.h",
          "type": "blob",
          "size": 0.392578125,
          "content": "#ifndef __JSON_TG_H__\n#define __JSON_TG_H__\n#include \"config.h\"\n#ifdef USE_JSON\n#include <jansson.h>\n#include <tgl/tgl.h>\n#include <tgl/tgl-layout.h>\njson_t *json_pack_message (struct tgl_message *M);\njson_t *json_pack_updates (unsigned flags);\njson_t *json_pack_peer (tgl_peer_id_t id);\njson_t *json_pack_read (struct tgl_message *M);\njson_t *json_pack_user_status (struct tgl_user *U);\n#endif\n#endif\n"
        },
        {
          "name": "loop.c",
          "type": "blob",
          "size": 22.6455078125,
          "content": "/*\n    This file is part of telegram-cli.\n\n    Telegram-cli is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n\n    Telegram-cli is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this telegram-cli.  If not, see <http://www.gnu.org/licenses/>.\n\n    Copyright Vitaly Valtman 2013-2015\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#if USE_PYTHON\n#include \"python-tg.h\"\n#endif\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#define READLINE_CALLBACKS\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef READLINE_GNU\n#include <readline/readline.h>\n#include <readline/history.h>\n#else\n#include <readline/readline.h>\n#include <readline/history.h>\n#endif\n\n#include <errno.h>\n#include <poll.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <fcntl.h>\n#include <netinet/in.h>\n\n#ifdef EVENT_V2\n#include <event2/event.h>\n#include <event2/bufferevent.h>\n#else\n#include <event.h>\n#include \"event-old.h\"\n#endif\n\n#include \"interface.h\"\n#include \"telegram.h\"\n#include \"loop.h\"\n#if USE_LUA\n#include \"lua-tg.h\"\n#endif\n\n#include <tgl/tgl.h>\n#include <tgl/tgl-binlog.h>\n#include <tgl/tgl-net.h>\n#include <tgl/tgl-timers.h>\n#include <tgl/tgl-queries.h>\n\n#include <openssl/sha.h>\n\nint verbosity;\nextern int readline_disabled;\nextern char *bot_hash;\n\nextern int bot_mode;\nint binlog_read;\nextern char *default_username;\nextern char *auth_token;\nvoid set_default_username (const char *s);\nextern int binlog_enabled;\n\nextern int unknown_user_list_pos;\nextern int unknown_user_list[];\nint register_mode;\nextern int safe_quit;\nextern int sync_from_start;\n\nextern int disable_output;\nextern int reset_authorization;\n\nextern int sfd;\nextern int usfd;\n\nvoid got_it (char *line, int len);\nvoid write_state_file (void);\n\nstatic char *line_buffer;\nstatic int line_buffer_size;\nstatic int line_buffer_pos;\nstatic int delete_stdin_event;\n\nextern volatile int sigterm_cnt;\n\nextern char *start_command;\nextern struct tgl_state *TLS;\nextern int ipv6_enabled;\n\nstruct event *term_ev = 0;\nint read_one_string;\n#define MAX_ONE_STRING_LEN 511\nchar one_string[MAX_ONE_STRING_LEN + 1];\nint one_string_len;\nvoid (*one_string_cb)(struct tgl_state *TLS, const char *string[], void *arg);\nenum tgl_value_type one_string_type;\nint one_string_num;\nint one_string_total_args;\nchar *one_string_results[10];\n\nvoid *string_cb_arg;\nchar *one_string_prompt;\nint one_string_flags;\nextern int disable_link_preview;\n\nvoid deactivate_readline (void);\nvoid reactivate_readline (void);\n\nvoid do_get_string (struct tgl_state *TLS);\nstatic void one_string_read_end (void) {\n  printf (\"\\n\");\n  fflush (stdout);\n\n  read_one_string = 0;\n  tfree_str (one_string_prompt);\n  one_string_prompt = NULL;\n  reactivate_readline ();\n\n  one_string_results[one_string_num] = tstrdup (one_string);\n  ++one_string_num;\n\n  if (one_string_num < one_string_total_args) {\n    do_get_string (TLS);\n  } else {\n    one_string_cb (TLS, (void *)one_string_results, string_cb_arg);\n    int i;\n    for (i = 0; i < one_string_total_args; i++) {\n      tfree_str (one_string_results[i]);\n    }\n  }\n}\n\nvoid generate_prompt (enum tgl_value_type type, int num) {\n  switch (type) {\n  case tgl_phone_number:\n    assert (!num);\n    one_string_prompt = tstrdup (\"phone number: \");\n    one_string_flags = 0;\n    return;\n  case tgl_code:\n    assert (!num);\n    one_string_prompt = tstrdup (\"code ('CALL' for phone code): \");\n    one_string_flags = 0;\n    return;\n  case tgl_register_info:\n    one_string_flags = 0;\n    switch (num) {\n    case 0:\n      one_string_prompt = tstrdup (\"register (Y/n): \");\n      return;\n    case 1:\n      one_string_prompt = tstrdup (\"first name: \");\n      return;\n    case 2:\n      one_string_prompt = tstrdup (\"last name: \");\n      return;\n    default:\n      assert (0);\n    }\n    return;\n  case tgl_new_password:\n    one_string_flags = 1;\n    switch (num) {\n    case 0:\n      one_string_prompt = tstrdup (\"new password: \");\n      return;\n    case 1:\n      one_string_prompt = tstrdup (\"retype new password: \");\n      return;\n    default:\n      assert (0);\n    }\n    return;\n  case tgl_cur_and_new_password:\n    one_string_flags = 1;\n    switch (num) {\n    case 0:\n      one_string_prompt = tstrdup (\"old password: \");\n      return;\n    case 1:\n      one_string_prompt = tstrdup (\"new password: \");\n      return;\n    case 2:\n      one_string_prompt = tstrdup (\"retype new password: \");\n      return;\n    default:\n      assert (0);\n    }\n    return;\n  case tgl_cur_password:\n    one_string_flags = 1;\n    assert (!num);\n    one_string_prompt = tstrdup (\"password: \");\n    return;\n  case tgl_bot_hash:\n    one_string_flags = 0;\n    assert (!num);\n    one_string_prompt = tstrdup (\"hash: \");\n    return;\n  default:\n    assert (0);\n  }\n}\n\nvoid do_get_string (struct tgl_state *TLS) {\n  deactivate_readline ();\n  generate_prompt (one_string_type, one_string_num);  \n  printf (\"%s\", one_string_prompt);\n  fflush (stdout);\n  read_one_string = 1;\n  one_string_len = 0;  \n}\n\nvoid do_get_values (struct tgl_state *TLS, enum tgl_value_type type, const char *prompt, int num_values,\n          void (*callback)(struct tgl_state *TLS, const char *string[], void *arg), void *arg) {\n  if (type == tgl_bot_hash && bot_hash) {\n    assert (num_values == 1);\n    one_string_results[0] = bot_hash;\n    callback (TLS, (void *)one_string_results, arg);\n    return;\n  }\n  one_string_cb = callback;\n  one_string_num = 0;\n  one_string_total_args = num_values;\n  one_string_type = type;\n  string_cb_arg = arg;\n  do_get_string (TLS); \n}\n\nstatic void stdin_read_callback (evutil_socket_t fd, short what, void *arg) {\n  if (!readline_disabled && !read_one_string) {\n    rl_callback_read_char ();\n    return;\n  }\n  if (read_one_string) {\n    char c;\n    int r = read (0, &c, 1);\n    if (r <= 0) {\n      perror (\"read\");\n      delete_stdin_event = 1;\n      return;\n    }\n    if (c == '\\n' || c == '\\r') {\n      one_string[one_string_len] = 0;\n      one_string_read_end ();\n      return;\n    }\n    if (one_string_len < MAX_ONE_STRING_LEN) {\n      one_string[one_string_len ++] = c;\n      if (!(one_string_flags & 1)) {\n        printf (\"%c\", c);\n        fflush (stdout);\n      }\n    }\n    return;\n  }\n\n  if (line_buffer_pos == line_buffer_size) {\n    line_buffer = realloc (line_buffer, line_buffer_size * 2 + 100);\n    assert (line_buffer);\n    line_buffer_size = line_buffer_size * 2 + 100;\n    assert (line_buffer);\n  }\n  int r = read (0, line_buffer + line_buffer_pos, line_buffer_size - line_buffer_pos);\n  if (r <= 0) {\n    perror (\"read\");\n    delete_stdin_event = 1;\n    return;\n  }\n  line_buffer_pos += r;\n\n  while (1) {\n    int p = 0;\n    while (p < line_buffer_pos && line_buffer[p] != '\\n') { p ++; }\n    if (p < line_buffer_pos) {\n      line_buffer[p] = 0;\n      interpreter (line_buffer);\n      memmove (line_buffer, line_buffer + p + 1, line_buffer_pos - p - 1);\n      line_buffer_pos -= (p + 1);\n    } else {\n      break;\n    }\n  }\n}\n\n\nvoid net_loop (void) {\n  delete_stdin_event = 0;\n  if (verbosity >= E_DEBUG) {\n    logprintf (\"Starting netloop\\n\");\n  }\n  term_ev = event_new (TLS->ev_base, 0, EV_READ | EV_PERSIST, stdin_read_callback, 0);\n  event_add (term_ev, 0);\n  \n  int last_get_state = time (0);\n  while (1) {\n    event_base_loop (TLS->ev_base, EVLOOP_ONCE);\n\n    if (term_ev && delete_stdin_event) {\n      logprintf (\"delete stdin\\n\");\n      event_free (term_ev);\n      term_ev = 0;\n    }\n\n    #ifdef USE_LUA\n      lua_do_all ();\n    #endif\n    \n    #ifdef USE_PYTHON\n      py_do_all ();\n    #endif\n\n    if (safe_quit && !TLS->active_queries) {\n      printf (\"All done. Exit\\n\");\n      do_halt (0);\n      safe_quit = 0;\n    }\n    if (sigterm_cnt > 0) {\n      do_halt (0);\n    }\n    if (time (0) - last_get_state > 3600) {\n      tgl_do_lookup_state (TLS);\n      last_get_state = time (0);\n    }\n    \n    write_state_file ();\n    update_prompt ();\n    \n/*    if (unknown_user_list_pos) {\n      int i;\n      for (i = 0; i < unknown_user_list_pos; i++) {\n        tgl_do_get_user_info (TLS, TGL_MK_USER (unknown_user_list[i]), 0, 0, 0);\n      }\n      unknown_user_list_pos = 0;\n    }   */\n  }\n\n  if (term_ev) {\n    event_free (term_ev);\n    term_ev = 0;\n  }\n  \n  if (verbosity >= E_DEBUG) {\n    logprintf (\"End of netloop\\n\");\n  }\n}\n\nstruct tgl_dc *cur_a_dc;\nint is_authorized (void) {\n  return tgl_authorized_dc (TLS, cur_a_dc);\n}\n\nint all_authorized (void) {\n  int i;\n  for (i = 0; i <= TLS->max_dc_num; i++) if (TLS->DC_list[i]) {\n    if (!tgl_authorized_dc (TLS, TLS->DC_list[i])) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nint zero[512];\n\n\nint readline_active;\nint new_dc_num;\nint wait_dialog_list;\n\nextern struct tgl_update_callback upd_cb;\n\n#define DC_SERIALIZED_MAGIC 0x868aa81d\n#define STATE_FILE_MAGIC 0x28949a93\n#define SECRET_CHAT_FILE_MAGIC 0x37a1988a\n\nchar *get_auth_key_filename (void);\nchar *get_state_filename (void);\nchar *get_secret_chat_filename (void);\n\nvoid read_state_file (void) {\n  if (binlog_enabled) { return; }\n  int state_file_fd = open (get_state_filename (), O_CREAT | O_RDWR, 0600);\n  if (state_file_fd < 0) {\n    return;\n  }\n  int version, magic;\n  if (read (state_file_fd, &magic, 4) < 4) { close (state_file_fd); return; }\n  if (magic != (int)STATE_FILE_MAGIC) { close (state_file_fd); return; }\n  if (read (state_file_fd, &version, 4) < 4) { close (state_file_fd); return; }\n  assert (version >= 0);\n  int x[4];\n  if (read (state_file_fd, x, 16) < 16) {\n    close (state_file_fd); \n    return;\n  }\n  int pts = x[0];\n  int qts = x[1];\n  int seq = x[2];\n  int date = x[3];\n  close (state_file_fd); \n  bl_do_set_seq (TLS, seq);\n  bl_do_set_pts (TLS, pts);\n  bl_do_set_qts (TLS, qts);\n  bl_do_set_date (TLS, date);\n}\n\n\nvoid write_state_file (void) {\n  if (binlog_enabled) { return; }\n  static int wseq;\n  static int wpts;\n  static int wqts;\n  static int wdate;\n  if (wseq >= TLS->seq && wpts >= TLS->pts && wqts >= TLS->qts && wdate >= TLS->date) { return; }\n  wseq = TLS->seq; wpts = TLS->pts; wqts = TLS->qts; wdate = TLS->date;\n  int state_file_fd = open (get_state_filename (), O_CREAT | O_RDWR, 0600);\n  if (state_file_fd < 0) {\n    logprintf (\"Can not write state file '%s': %m\\n\", get_state_filename ());\n    do_halt (1);\n  }\n  int x[6];\n  x[0] = STATE_FILE_MAGIC;\n  x[1] = 0;\n  x[2] = wpts;\n  x[3] = wqts;\n  x[4] = wseq;\n  x[5] = wdate;\n  assert (write (state_file_fd, x, 24) == 24);\n  close (state_file_fd); \n}\n\nvoid write_dc (struct tgl_dc *DC, void *extra) {\n  int auth_file_fd = *(int *)extra;\n  if (!DC) { \n    int x = 0;\n    assert (write (auth_file_fd, &x, 4) == 4);\n    return;\n  } else {\n    int x = 1;\n    assert (write (auth_file_fd, &x, 4) == 4);\n  }\n\n  assert (DC->flags & TGLDCF_LOGGED_IN);\n\n  assert (write (auth_file_fd, &DC->options[0]->port, 4) == 4);\n  int l = strlen (DC->options[0]->ip);\n  assert (write (auth_file_fd, &l, 4) == 4);\n  assert (write (auth_file_fd, DC->options[0]->ip, l) == l);\n  assert (write (auth_file_fd, &DC->auth_key_id, 8) == 8);\n  assert (write (auth_file_fd, DC->auth_key, 256) == 256);\n}\n\nvoid write_auth_file (void) {\n  if (binlog_enabled) { return; }\n  int auth_file_fd = open (get_auth_key_filename (), O_CREAT | O_RDWR, 0600);\n  assert (auth_file_fd >= 0);\n  int x = DC_SERIALIZED_MAGIC;\n  assert (write (auth_file_fd, &x, 4) == 4);\n  assert (write (auth_file_fd, &TLS->max_dc_num, 4) == 4);\n  assert (write (auth_file_fd, &TLS->dc_working_num, 4) == 4);\n\n  tgl_dc_iterator_ex (TLS, write_dc, &auth_file_fd);\n\n  assert (write (auth_file_fd, &TLS->our_id.peer_id, 4) == 4);\n  close (auth_file_fd);\n}\n\nvoid write_secret_chat (tgl_peer_t *Peer, void *extra) {\n  struct tgl_secret_chat *P = (void *)Peer;\n  if (tgl_get_peer_type (P->id) != TGL_PEER_ENCR_CHAT) { return; }\n  if (P->state != sc_ok) { return; }\n  int *a = extra;\n  int fd = a[0];\n  a[1] ++;\n\n  int id = tgl_get_peer_id (P->id);\n  assert (write (fd, &id, 4) == 4);\n  //assert (write (fd, &P->flags, 4) == 4);\n  int l = strlen (P->print_name);\n  assert (write (fd, &l, 4) == 4);\n  assert (write (fd, P->print_name, l) == l);\n  assert (write (fd, &P->user_id, 4) == 4);\n  assert (write (fd, &P->admin_id, 4) == 4);\n  assert (write (fd, &P->date, 4) == 4);\n  assert (write (fd, &P->ttl, 4) == 4);\n  assert (write (fd, &P->layer, 4) == 4);\n  assert (write (fd, &P->access_hash, 8) == 8);\n  assert (write (fd, &P->state, 4) == 4);\n  assert (write (fd, &P->key_fingerprint, 8) == 8);\n  assert (write (fd, &P->key, 256) == 256);\n  assert (write (fd, &P->first_key_sha, 20) == 20);\n  assert (write (fd, &P->in_seq_no, 4) == 4);\n  assert (write (fd, &P->last_in_seq_no, 4) == 4);\n  assert (write (fd, &P->out_seq_no, 4) == 4);\n}\n\nvoid write_secret_chat_file (void) {\n  if (binlog_enabled) { return; }\n  int secret_chat_fd = open (get_secret_chat_filename (), O_CREAT | O_RDWR, 0600);\n  assert (secret_chat_fd >= 0);\n  int x = SECRET_CHAT_FILE_MAGIC;\n  assert (write (secret_chat_fd, &x, 4) == 4);\n  x = 2; \n  assert (write (secret_chat_fd, &x, 4) == 4); // version\n  assert (write (secret_chat_fd, &x, 4) == 4); // num\n\n  int y[2];\n  y[0] = secret_chat_fd;\n  y[1] = 0;\n\n  tgl_peer_iterator_ex (TLS, write_secret_chat, y);\n\n  lseek (secret_chat_fd, 8, SEEK_SET);\n  assert (write (secret_chat_fd, &y[1], 4) == 4);\n  close (secret_chat_fd);\n}\n\nvoid read_dc (int auth_file_fd, int id, unsigned ver) {\n  int port = 0;\n  assert (read (auth_file_fd, &port, 4) == 4);\n  int l = 0;\n  assert (read (auth_file_fd, &l, 4) == 4);\n  assert (l >= 0 && l < 100);\n  char ip[100];\n  assert (read (auth_file_fd, ip, l) == l);\n  ip[l] = 0;\n\n  long long auth_key_id;\n  static unsigned char auth_key[256];\n  assert (read (auth_file_fd, &auth_key_id, 8) == 8);\n  assert (read (auth_file_fd, auth_key, 256) == 256);\n\n  //bl_do_add_dc (id, ip, l, port, auth_key_id, auth_key);\n  bl_do_dc_option (TLS, 0, id, \"DC\", 2, ip, l, port);\n  bl_do_set_auth_key (TLS, id, auth_key);\n  bl_do_dc_signed (TLS, id);\n}\n\nvoid empty_auth_file (void) {\n  if (TLS->test_mode) {\n    bl_do_dc_option (TLS, 0, 1, \"\", 0, TG_SERVER_TEST_1, strlen (TG_SERVER_TEST_1), 443);\n    bl_do_dc_option (TLS, 0, 2, \"\", 0, TG_SERVER_TEST_2, strlen (TG_SERVER_TEST_2), 443);\n    bl_do_dc_option (TLS, 0, 3, \"\", 0, TG_SERVER_TEST_3, strlen (TG_SERVER_TEST_3), 443);\n    bl_do_set_working_dc (TLS, TG_SERVER_TEST_DEFAULT);\n  } else {\n    bl_do_dc_option (TLS, 0, 1, \"\", 0, TG_SERVER_1, strlen (TG_SERVER_1), 443);\n    bl_do_dc_option (TLS, 0, 2, \"\", 0, TG_SERVER_2, strlen (TG_SERVER_2), 443);\n    bl_do_dc_option (TLS, 0, 3, \"\", 0, TG_SERVER_3, strlen (TG_SERVER_3), 443);\n    bl_do_dc_option (TLS, 0, 4, \"\", 0, TG_SERVER_4, strlen (TG_SERVER_4), 443);\n    bl_do_dc_option (TLS, 0, 5, \"\", 0, TG_SERVER_5, strlen (TG_SERVER_5), 443);\n    bl_do_set_working_dc (TLS, TG_SERVER_DEFAULT);\n  }\n}\n\nint need_dc_list_update;\nvoid read_auth_file (void) {\n  if (binlog_enabled) { return; }\n  int auth_file_fd = open (get_auth_key_filename (), O_CREAT | O_RDWR, 0600);\n  if (auth_file_fd < 0) {\n    empty_auth_file ();\n    return;\n  }\n  assert (auth_file_fd >= 0);\n  unsigned x;\n  unsigned m;\n  if (read (auth_file_fd, &m, 4) < 4 || (m != DC_SERIALIZED_MAGIC)) {\n    close (auth_file_fd);\n    empty_auth_file ();\n    return;\n  }\n  assert (read (auth_file_fd, &x, 4) == 4);\n  assert (x > 0);\n  int dc_working_num;\n  assert (read (auth_file_fd, &dc_working_num, 4) == 4);\n  \n  int i;\n  for (i = 0; i <= (int)x; i++) {\n    int y;\n    assert (read (auth_file_fd, &y, 4) == 4);\n    if (y) {\n      read_dc (auth_file_fd, i, m);\n    }\n  }\n  bl_do_set_working_dc (TLS, dc_working_num);\n  int our_id;\n  int l = read (auth_file_fd, &our_id, 4);\n  if (l < 4) {\n    assert (!l);\n  }\n  if (our_id) {\n    bl_do_set_our_id (TLS, TGL_MK_USER (our_id));\n  }\n  close (auth_file_fd);\n}\n\nvoid read_secret_chat (int fd, int v) {\n  int id, l, user_id, admin_id, date, ttl, layer, state;\n  long long access_hash, key_fingerprint;\n  static char s[1000];\n  static unsigned char key[256];\n  static unsigned char sha[20];\n  assert (read (fd, &id, 4) == 4);\n  //assert (read (fd, &flags, 4) == 4);\n  assert (read (fd, &l, 4) == 4);\n  assert (l > 0 && l < 1000);\n  assert (read (fd, s, l) == l);\n  assert (read (fd, &user_id, 4) == 4);\n  assert (read (fd, &admin_id, 4) == 4);\n  assert (read (fd, &date, 4) == 4);\n  assert (read (fd, &ttl, 4) == 4);\n  assert (read (fd, &layer, 4) == 4);\n  assert (read (fd, &access_hash, 8) == 8);\n  assert (read (fd, &state, 4) == 4);\n  assert (read (fd, &key_fingerprint, 8) == 8);\n  assert (read (fd, &key, 256) == 256);\n  assert (read (fd, sha, 20) == 20);\n  int in_seq_no = 0, out_seq_no = 0, last_in_seq_no = 0;\n  if (v >= 1) {\n    assert (read (fd, &in_seq_no, 4) == 4);\n    assert (read (fd, &last_in_seq_no, 4) == 4);\n    assert (read (fd, &out_seq_no, 4) == 4);\n  }\n\n  bl_do_encr_chat (TLS, id, \n    &access_hash,\n    &date,\n    &admin_id,\n    &user_id,\n    key,\n    NULL,\n    sha,\n    &state,\n    &ttl,\n    &layer,\n    &in_seq_no,\n    &last_in_seq_no,\n    &out_seq_no,\n    &key_fingerprint,\n    TGLECF_CREATE | TGLECF_CREATED,\n    NULL, 0\n  );\n    \n}\n\nvoid read_secret_chat_file (void) {\n  if (binlog_enabled) { return; }\n  int secret_chat_fd = open (get_secret_chat_filename (), O_RDWR, 0600);\n  if (secret_chat_fd < 0) { return; }\n  //assert (secret_chat_fd >= 0);\n  int x;\n  if (read (secret_chat_fd, &x, 4) < 4) { close (secret_chat_fd); return; }\n  if (x != SECRET_CHAT_FILE_MAGIC) { close (secret_chat_fd); return; }\n  int v = 0;\n  assert (read (secret_chat_fd, &v, 4) == 4);\n  assert (v == 0 || v == 1 || v == 2); // version  \n  assert (read (secret_chat_fd, &x, 4) == 4);\n  assert (x >= 0);\n  while (x --> 0) {\n    read_secret_chat (secret_chat_fd, v);\n  }\n  close (secret_chat_fd);\n}\n\nstatic void read_incoming (struct bufferevent *bev, void *_arg) {\n  vlogprintf (E_WARNING, \"Read from incoming connection\\n\");\n  struct in_ev *ev = _arg;\n  assert (ev->bev == bev);\n  ev->in_buf_pos += bufferevent_read (bev, ev->in_buf + ev->in_buf_pos, 4096 - ev->in_buf_pos);\n\n  while (1) {\n    int pos = 0;\n    int ok = 0;\n    while (pos < ev->in_buf_pos) {\n      if (ev->in_buf[pos] == '\\n') {\n        if (!ev->error) {\n          ev->in_buf[pos] = 0;\n          interpreter_ex (ev->in_buf, ev);\n        } else {\n          ev->error = 0;\n        }\n        ok = 1;\n        ev->in_buf_pos -= (pos + 1);\n        memmove (ev->in_buf, ev->in_buf + pos + 1, ev->in_buf_pos);\n        pos = 0;\n      } else {\n        pos ++;\n      }\n    }\n    if (ok) {\n      ev->in_buf_pos += bufferevent_read (bev, ev->in_buf + ev->in_buf_pos, 4096 - ev->in_buf_pos);\n    } else {\n      if (ev->in_buf_pos == 4096) {\n        ev->error = 1;\n      }\n      break;\n    }\n  }\n}\n\nvoid event_incoming (struct bufferevent *bev, short what, void *_arg) {\n  struct in_ev *ev = _arg;\n  if (what & (BEV_EVENT_EOF | BEV_EVENT_ERROR)) {\n    vlogprintf (E_WARNING, \"Closing incoming connection\\n\");\n    assert (ev->fd >= 0);\n    close (ev->fd);\n    bufferevent_free (bev);\n    ev->bev = 0;\n    if (!--ev->refcnt) { free (ev); }\n  }\n}\n\nstatic void accept_incoming (evutil_socket_t efd, short what, void *arg) {\n  vlogprintf (E_WARNING, \"Accepting incoming connection\\n\");\n  socklen_t clilen = 0;\n  struct sockaddr_in cli_addr;\n  int fd = accept (efd, (struct sockaddr *)&cli_addr, &clilen);\n\n  assert (fd >= 0);\n  struct bufferevent *bev = bufferevent_socket_new (TLS->ev_base, fd, 0);\n  struct in_ev *e = malloc (sizeof (*e));\n  e->bev = bev;\n  e->refcnt = 1;\n  e->in_buf_pos = 0;\n  e->error = 0;\n  e->fd = fd;\n  bufferevent_setcb (bev, read_incoming, 0, event_incoming, e);\n  bufferevent_enable (bev, EV_READ | EV_WRITE);\n}\n\nchar *get_downloads_directory (void);\nvoid on_login (struct tgl_state *TLS) {\n  write_auth_file ();\n}\n\nvoid on_failed_login (struct tgl_state *TLS) {\n  logprintf (\"login failed\\n\");\n  logprintf (\"login error #%d: %s\\n\", TLS->error_code, TLS->error);\n  logprintf (\"you can relogin by deleting auth file or running telegram-cli with '-q' flag\\n\");\n  exit (2);\n}\n\nvoid on_started (struct tgl_state *TLS);\nvoid clist_cb (struct tgl_state *TLSR, void *callback_extra, int success, int size, tgl_peer_id_t peers[], tgl_message_id_t *last_msg_id[], int unread_count[]) {\n  on_started (TLS);\n}\n\nvoid dlist_cb (struct tgl_state *TLSR, void *callback_extra, int success, int size, tgl_peer_id_t peers[], tgl_message_id_t *last_msg_id[], int unread_count[])  {\n  tgl_do_get_channels_dialog_list (TLS, 100, 0, clist_cb, 0);\n}\n\nvoid on_started (struct tgl_state *TLS) {\n  if (wait_dialog_list) {\n    wait_dialog_list = 0;\n    tgl_do_get_dialog_list (TLS, 100, 0, dlist_cb, 0);\n    return;\n  }\n  #ifdef USE_LUA\n    lua_diff_end ();\n  #endif\n\n  #ifdef USE_PYTHON\n    py_diff_end ();\n  #endif\n  \n  if (start_command) {\n    safe_quit = 1;\n    while (*start_command) {\n      char *start = start_command;\n      while (*start_command && *start_command != '\\n') {\n        start_command ++;\n      }\n      if (*start_command) {\n        *start_command = 0;\n        start_command ++;\n      } \n      interpreter_ex (start, 0);\n    }\n  }\n}\n\nint loop (void) {\n  tgl_set_callback (TLS, &upd_cb);\n  struct event_base *ev = event_base_new ();\n  tgl_set_ev_base (TLS, ev);\n  tgl_set_net_methods (TLS, &tgl_conn_methods);\n  tgl_set_timer_methods (TLS, &tgl_libevent_timers);\n  assert (TLS->timer_methods);\n  tgl_set_download_directory (TLS, get_downloads_directory ());\n  tgl_register_app_id (TLS, TELEGRAM_CLI_APP_ID, TELEGRAM_CLI_APP_HASH); \n  tgl_set_app_version (TLS, \"Telegram-cli \" TELEGRAM_CLI_VERSION);\n  if (ipv6_enabled) {\n    tgl_enable_ipv6 (TLS);\n  }\n  if (bot_mode) {\n    tgl_enable_bot (TLS);\n  }\n  if (disable_link_preview) {\n    tgl_disable_link_preview (TLS);\n  }\n  assert (tgl_init (TLS) >= 0);\n \n  /*if (binlog_enabled) {\n    double t = tglt_get_double_time ();\n    if (verbosity >= E_DEBUG) {\n      logprintf (\"replay log start\\n\");\n    }\n    tgl_replay_log (TLS);\n    if (verbosity >= E_DEBUG) {\n      logprintf (\"replay log end in %lf seconds\\n\", tglt_get_double_time () - t);\n    }\n    tgl_reopen_binlog_for_writing (TLS);\n  } else {*/\n    read_auth_file ();\n    read_state_file ();\n    read_secret_chat_file ();\n  //}\n\n  binlog_read = 1;\n  #ifdef USE_LUA\n    lua_binlog_end ();\n  #endif\n  \n  #ifdef USE_PYTHON\n    py_binlog_end ();\n  #endif\n  \n  if (sfd >= 0) {\n    struct event *ev = event_new (TLS->ev_base, sfd, EV_READ | EV_PERSIST, accept_incoming, 0);\n    event_add (ev, 0);\n  }\n  if (usfd >= 0) {\n    struct event *ev = event_new (TLS->ev_base, usfd, EV_READ | EV_PERSIST, accept_incoming, 0);\n    event_add (ev, 0);\n  }\n  update_prompt ();\n   \n  if (reset_authorization) {\n    tgl_peer_t *P = tgl_peer_get (TLS, TLS->our_id);\n    if (P && P->user.phone && reset_authorization == 1) {\n      set_default_username (P->user.phone);\n    }\n    bl_do_reset_authorization (TLS);\n  }\n\n  set_interface_callbacks ();\n  tgl_login (TLS);\n  net_loop ();\n  return 0;\n}\n\n"
        },
        {
          "name": "loop.h",
          "type": "blob",
          "size": 1.0009765625,
          "content": "/*\n    This file is part of telegram-cli.\n\n    Telegram-cli is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n\n    Telegram-cli is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this telegram-cli.  If not, see <http://www.gnu.org/licenses/>.\n\n    Copyright Vitaly Valtman 2013-2015\n*/\n#ifndef __LOOP_H__\n#define __LOOP_H__\n#define TELEGRAM_CLI_APP_HASH \"36722c72256a24c1225de00eb6a1ca74\"\n#define TELEGRAM_CLI_APP_ID 2899\n\nint loop (void);\nvoid do_halt (int error);\nvoid write_auth_file (void);\nvoid write_state_file (void);\nvoid write_secret_chat_file (void);\n#endif\n"
        },
        {
          "name": "lua-tg.c",
          "type": "blob",
          "size": 53.7373046875,
          "content": "/*\n    This file is part of telegram-cli.\n\n    Telegram-cli is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n\n    Telegram-cli is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this telegram-cli.  If not, see <http://www.gnu.org/licenses/>.\n\n    Copyright Vitaly Valtman 2013-2015\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef USE_LUA\n#include \"lua-tg.h\"\n\n#include <string.h>\n#include <stdlib.h>\n\n\n#include <lua.h>\n#include <lualib.h>\n#include <lauxlib.h>\n#ifdef EVENT_V2\n#include <event2/event.h>\n#else\n#include <event.h>\n#include \"event-old.h\"\n#endif\nlua_State *luaState;\n\n//#include \"interface.h\"\n//#include \"auto/constants.h\"\n#include <tgl/tgl.h>\n#include <tgl/tgl-queries.h>\n#include \"interface.h\"\n\n#include <assert.h>\nextern int verbosity;\nextern struct tgl_state *TLS;\n\nstatic int have_file;\n\nvoid print_start (void);\nvoid print_end (void);\n\nint ps_lua_pcall (lua_State *l, int a, int b, int c) {\n  print_start ();\n  int r = lua_pcall (l, a, b, c);\n  print_end ();\n  return r;\n}\n\n#define my_lua_checkstack(L,x) assert (lua_checkstack (L, x))\nvoid push_user (tgl_peer_t *P);\nvoid push_peer (tgl_peer_id_t id, tgl_peer_t *P);\n\nvoid lua_add_string_field (const char *name, const char *value) {\n  assert (name && strlen (name));\n  if (!value || !strlen (value)) { return; }\n  my_lua_checkstack (luaState, 3);\n  lua_pushstring (luaState, name);\n  lua_pushstring (luaState, value);\n  lua_settable (luaState, -3);\n}\n\nvoid lua_add_lstring_field (const char *name, const char *value, int len) {\n  assert (name && strlen (name));\n  if (!value || !len) { return; }\n  my_lua_checkstack (luaState, 3);\n  lua_pushstring (luaState, name);\n  lua_pushlstring (luaState, value, len);\n  lua_settable (luaState, -3);\n}\n\nvoid lua_add_string_field_arr (int num, const char *value) {\n  if (!value || !strlen (value)) { return; }\n  my_lua_checkstack (luaState, 3);\n  lua_pushnumber (luaState, num);\n  lua_pushstring (luaState, value);\n  lua_settable (luaState, -3);\n}\n\nvoid lua_add_num_field (const char *name, double value) {\n  assert (name && strlen (name));\n  my_lua_checkstack (luaState, 3);\n  lua_pushstring (luaState, name);\n  lua_pushnumber (luaState, value);\n  lua_settable (luaState, -3);\n}\n\nvoid push_tgl_peer_type (int x) {\n  switch (x) {\n  case TGL_PEER_USER:\n    lua_pushstring (luaState, \"user\");\n    break;\n  case TGL_PEER_CHAT:\n    lua_pushstring (luaState, \"chat\");\n    break;\n  case TGL_PEER_ENCR_CHAT:\n    lua_pushstring (luaState, \"encr_chat\");\n    break;\n  case TGL_PEER_CHANNEL:\n    lua_pushstring (luaState, \"channel\");\n    break;\n  default:\n    assert (0);\n  }\n}\n\nvoid push_user (tgl_peer_t *P) {\n  my_lua_checkstack (luaState, 4);\n  lua_add_string_field (\"first_name\", P->user.first_name);\n  lua_add_string_field (\"last_name\", P->user.last_name);\n  lua_add_string_field (\"real_first_name\", P->user.real_first_name);\n  lua_add_string_field (\"real_last_name\", P->user.real_last_name);\n  lua_add_string_field (\"phone\", P->user.phone);\n  lua_add_string_field (\"username\", P->user.username);\n  if (P->user.access_hash) {\n    lua_add_num_field (\"access_hash\", 1);\n  }\n}\n\nvoid push_chat (tgl_peer_t *P) {\n  my_lua_checkstack (luaState, 4);\n  assert (P->chat.title);\n  lua_add_string_field (\"title\", P->chat.title);\n  lua_add_num_field (\"members_num\", P->chat.users_num);\n  if (P->chat.user_list) {\n    lua_pushstring (luaState, \"members\");\n    lua_newtable (luaState);\n    int i;\n    for (i = 0; i < P->chat.users_num; i++) {\n      lua_pushnumber (luaState, i);\n      tgl_peer_id_t id = TGL_MK_USER (P->chat.user_list[i].user_id);\n      push_peer (id, tgl_peer_get (TLS, id));\n      lua_settable (luaState, -3);\n    }\n    lua_settable (luaState, -3);\n  }\n}\n\nvoid push_encr_chat (tgl_peer_t *P) {\n  my_lua_checkstack (luaState, 4);\n  lua_pushstring (luaState, \"user\");\n  push_peer (TGL_MK_USER (P->encr_chat.user_id), tgl_peer_get (TLS, TGL_MK_USER (P->encr_chat.user_id)));\n  lua_settable (luaState, -3);\n}\n\nvoid push_channel (tgl_peer_t *P) {\n  my_lua_checkstack (luaState, 4);\n  lua_add_string_field (\"title\", P->channel.title);\n  lua_add_string_field (\"about\", P->channel.about);\n  lua_add_num_field (\"participants_count\", P->channel.participants_count);\n  lua_add_num_field (\"admins_count\", P->channel.admins_count);\n  lua_add_num_field (\"kicked_count\", P->channel.kicked_count);\n}\n\nvoid push_update_types (unsigned flags) {\n  my_lua_checkstack (luaState, 4);\n  lua_newtable (luaState);\n  int cc = 0;\n  \n  \n  if (flags & TGL_UPDATE_CREATED) {\n    lua_add_string_field_arr (cc++, \"created\");\n  }  \n  if (flags & TGL_UPDATE_DELETED) {\n    lua_add_string_field_arr (cc++, \"deleted\");\n  }  \n  if (flags & TGL_UPDATE_PHONE) {\n    lua_add_string_field_arr (cc++, \"phone\");\n  }\n  if (flags & TGL_UPDATE_CONTACT) {\n    lua_add_string_field_arr (cc++, \"contact\");\n  }\n  if (flags & TGL_UPDATE_PHOTO) {\n    lua_add_string_field_arr (cc++, \"photo\");\n  }\n  if (flags & TGL_UPDATE_BLOCKED) {\n    lua_add_string_field_arr (cc++, \"blocked\");\n  }\n  if (flags & TGL_UPDATE_REAL_NAME) {\n    lua_add_string_field_arr (cc++, \"real_name\");\n  }\n  if (flags & TGL_UPDATE_NAME) {\n    lua_add_string_field_arr (cc++, \"name\");\n  }\n  if (flags & TGL_UPDATE_REQUESTED) {\n    lua_add_string_field_arr (cc++, \"requested\");\n  }\n  if (flags & TGL_UPDATE_WORKING) {\n    lua_add_string_field_arr (cc++, \"working\");\n  }\n  if (flags & TGL_UPDATE_FLAGS) {\n    lua_add_string_field_arr (cc++, \"flags\");\n  }\n  if (flags & TGL_UPDATE_TITLE) {\n    lua_add_string_field_arr (cc++, \"title\");\n  }\n  if (flags & TGL_UPDATE_ADMIN) {\n    lua_add_string_field_arr (cc++, \"admin\");\n  }\n  if (flags & TGL_UPDATE_MEMBERS) {\n    lua_add_string_field_arr (cc++, \"members\");\n  }\n  if (flags & TGL_UPDATE_ACCESS_HASH) {\n    lua_add_string_field_arr (cc++, \"access_hash\");\n  }\n  if (flags & TGL_UPDATE_USERNAME) {\n    lua_add_string_field_arr (cc++, \"username\");\n  }\n\n}\n\nvoid push_peer (tgl_peer_id_t id, tgl_peer_t *P) {\n  lua_newtable (luaState);\n  \n  lua_add_string_field (\"id\", print_permanent_peer_id (P ? P->id : id));\n  lua_pushstring (luaState, \"peer_type\");\n  push_tgl_peer_type (tgl_get_peer_type (id));\n  lua_settable (luaState, -3);\n  lua_add_num_field (\"peer_id\", tgl_get_peer_id (id));\n\n  if (!P || !(P->flags & TGLPF_CREATED)) {\n    lua_pushstring (luaState, \"print_name\"); \n    static char s[100];\n    switch (tgl_get_peer_type (id)) {\n    case TGL_PEER_USER:\n      sprintf (s, \"user#%d\", tgl_get_peer_id (id));\n      break;\n    case TGL_PEER_CHAT:\n      sprintf (s, \"chat#%d\", tgl_get_peer_id (id));\n      break;\n    case TGL_PEER_ENCR_CHAT:\n      sprintf (s, \"encr_chat#%d\", tgl_get_peer_id (id));\n      break;\n    case TGL_PEER_CHANNEL:\n      sprintf (s, \"channel#%d\", tgl_get_peer_id (id));\n      break;\n    default:\n      assert (0);\n    }\n    lua_pushstring (luaState, s); \n    lua_settable (luaState, -3); // flags\n  \n    return;\n  }\n  \n  lua_add_string_field (\"print_name\", P->print_name);\n  lua_add_num_field (\"flags\", P->flags);\n  \n  switch (tgl_get_peer_type (id)) {\n  case TGL_PEER_USER:\n    push_user (P);\n    break;\n  case TGL_PEER_CHAT:\n    push_chat (P);\n    break;\n  case TGL_PEER_ENCR_CHAT:\n    push_encr_chat (P);\n    break;\n  case TGL_PEER_CHANNEL:\n    push_channel (P);\n    break;\n  default:\n    assert (0);\n  }\n}\n\nvoid push_media (struct tgl_message_media *M) {\n  my_lua_checkstack (luaState, 4);\n\n  switch (M->type) {\n  case tgl_message_media_photo:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"photo\");\n    lua_add_string_field (\"caption\", M->caption);\n    break;\n  case tgl_message_media_document:\n  case tgl_message_media_audio:\n  case tgl_message_media_video:\n  case tgl_message_media_document_encr:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"document\");\n    break;\n  case tgl_message_media_unsupported:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"unsupported\");\n    break;\n  case tgl_message_media_geo:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"geo\");\n    lua_add_num_field (\"longitude\", M->geo.longitude);\n    lua_add_num_field (\"latitude\", M->geo.latitude);\n    break;\n  case tgl_message_media_contact:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"contact\");\n    lua_add_string_field (\"phone\", M->phone);\n    lua_add_string_field (\"first_name\", M->first_name);\n    lua_add_string_field (\"last_name\", M->last_name);\n    lua_add_num_field (\"user_id\", M->user_id);\n    break;\n  case tgl_message_media_webpage:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"webpage\");\n    lua_add_string_field (\"url\", M->webpage->url);\n    lua_add_string_field (\"title\", M->webpage->title);\n    lua_add_string_field (\"description\", M->webpage->description);\n    lua_add_string_field (\"author\", M->webpage->author);\n    break;\n  case tgl_message_media_venue:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"venue\");\n    lua_add_num_field (\"longitude\", M->venue.geo.longitude);\n    lua_add_num_field (\"latitude\", M->venue.geo.latitude);\n    lua_add_string_field (\"title\", M->venue.title);\n    lua_add_string_field (\"address\", M->venue.address);\n    lua_add_string_field (\"provider\", M->venue.provider);\n    lua_add_string_field (\"venue_id\", M->venue.venue_id);\n    break;\n  default:\n    lua_pushstring (luaState, \"???\");\n  }\n}\n\nvoid push_service (struct tgl_message *M) {\n  my_lua_checkstack (luaState, 4);\n  switch (M->action.type) {\n  case tgl_message_action_geo_chat_create:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"geo_created\");\n    break;\n  case tgl_message_action_geo_chat_checkin:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"geo_checkin\");\n    break;\n  case tgl_message_action_chat_create:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"chat_created\");\n    lua_add_string_field (\"title\", M->action.title);\n    break;\n  case tgl_message_action_chat_edit_title:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"chat_rename\");\n    lua_add_string_field (\"title\", M->action.title);\n    break;\n  case tgl_message_action_chat_edit_photo:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"chat_change_photo\");\n    break;\n  case tgl_message_action_chat_delete_photo:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"chat_delete_photo\");\n    break;\n  case tgl_message_action_chat_add_users:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"chat_add_user\");\n    \n    lua_pushstring (luaState, \"user\");\n    push_peer (tgl_set_peer_id (TGL_PEER_USER, M->action.users[0]), tgl_peer_get (TLS, tgl_set_peer_id (TGL_PEER_USER, M->action.users[0])));\n    lua_settable (luaState, -3);\n    break;\n  case tgl_message_action_chat_add_user_by_link:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"chat_add_user_link\");\n    \n    lua_pushstring (luaState, \"link_issuer\");\n    push_peer (tgl_set_peer_id (TGL_PEER_USER, M->action.user), tgl_peer_get (TLS, tgl_set_peer_id (TGL_PEER_USER, M->action.user)));\n    lua_settable (luaState, -3);\n    break;\n  case tgl_message_action_chat_delete_user:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"chat_del_user\");\n    \n    lua_pushstring (luaState, \"user\");\n    push_peer (tgl_set_peer_id (TGL_PEER_USER, M->action.user), tgl_peer_get (TLS, tgl_set_peer_id (TGL_PEER_USER, M->action.user)));\n    lua_settable (luaState, -3);\n    break;\n  case tgl_message_action_set_message_ttl:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"set_ttl\");\n    lua_add_num_field (\"ttl\", M->action.ttl);\n    break;\n  case tgl_message_action_read_messages:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"read\");\n    lua_add_num_field (\"count\", M->action.read_cnt);\n    break;\n  case tgl_message_action_delete_messages:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"delete\");\n    lua_add_num_field (\"count\", M->action.delete_cnt);\n    break;\n  case tgl_message_action_screenshot_messages:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"screenshot\");\n    lua_add_num_field (\"count\", M->action.screenshot_cnt);\n    break;\n  case tgl_message_action_flush_history:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"flush\");\n    break;\n  case tgl_message_action_resend:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"resend\");\n    break;\n  case tgl_message_action_notify_layer:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"set_layer\");\n    lua_add_num_field (\"layer\", M->action.layer);\n    break;\n  case tgl_message_action_typing:    \n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"typing\");\n    break;\n  case tgl_message_action_noop:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"nop\");\n    break;\n  case tgl_message_action_request_key:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"request_rekey\");\n    break;\n  case tgl_message_action_accept_key:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"accept_rekey\");\n    break;\n  case tgl_message_action_commit_key:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"commit_rekey\");\n    break;\n  case tgl_message_action_abort_key:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"abort_rekey\");\n    break;\n  case tgl_message_action_channel_create:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"channel_created\");\n    lua_add_string_field (\"title\", M->action.title);\n    break;\n  case tgl_message_action_migrated_to:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"migrated_to\");\n    break;\n  case tgl_message_action_migrated_from:\n    lua_newtable (luaState);\n    lua_add_string_field (\"type\", \"migrated_from\");\n    break;\n  default:\n    lua_pushstring (luaState, \"???\");\n    break;\n  }\n}\n\nvoid push_message (struct tgl_message *M) {  \n  assert (M);\n  my_lua_checkstack (luaState, 10);\n  lua_newtable (luaState);\n\n  lua_add_string_field (\"id\", print_permanent_msg_id (M->permanent_id));\n  if (!(M->flags & TGLMF_CREATED)) { return; }\n  lua_add_num_field (\"flags\", M->flags);\n \n  if (tgl_get_peer_type (M->fwd_from_id)) {\n    lua_pushstring (luaState, \"fwd_from\");\n    push_peer (M->fwd_from_id, tgl_peer_get (TLS, M->fwd_from_id));\n    lua_settable (luaState, -3); // fwd_from\n\n    lua_add_num_field (\"fwd_date\", M->fwd_date);\n  }\n\n  if (M->reply_id) {\n    tgl_message_id_t msg_id = M->permanent_id;\n    msg_id.id = M->reply_id;\n    \n    lua_add_string_field (\"reply_id\", print_permanent_msg_id (msg_id));\n  }\n\n  if (M->flags & TGLMF_MENTION) {\n    lua_pushstring (luaState, \"mention\");\n    lua_pushboolean (luaState, 1);\n    lua_settable (luaState, -3); \n  }\n \n  lua_pushstring (luaState, \"from\");\n  push_peer (M->from_id, tgl_peer_get (TLS, M->from_id));\n  lua_settable (luaState, -3); \n  \n  lua_pushstring (luaState, \"to\");\n  push_peer (M->to_id, tgl_peer_get (TLS, M->to_id));\n  lua_settable (luaState, -3); \n  \n  lua_pushstring (luaState, \"out\");\n  lua_pushboolean (luaState, (M->flags & TGLMF_OUT) != 0);\n  lua_settable (luaState, -3); \n  \n  lua_pushstring (luaState, \"unread\");\n  lua_pushboolean (luaState, (M->flags & TGLMF_UNREAD) != 0);\n  lua_settable (luaState, -3); \n  \n  lua_pushstring (luaState, \"date\");\n  lua_pushnumber (luaState, M->date);\n  lua_settable (luaState, -3); \n  \n  lua_pushstring (luaState, \"service\");\n  lua_pushboolean (luaState, (M->flags & TGLMF_SERVICE) != 0);\n  lua_settable (luaState, -3); \n\n  if (!(M->flags & TGLMF_SERVICE)) {  \n    if (M->message_len && M->message) {\n      lua_pushstring (luaState, \"text\");\n      lua_pushlstring (luaState, M->message, M->message_len);\n      lua_settable (luaState, -3); \n    }\n    if (M->media.type && M->media.type != tgl_message_media_none) {\n      lua_pushstring (luaState, \"media\");\n      push_media (&M->media);\n      lua_settable (luaState, -3); \n    }\n  } else {\n    lua_pushstring (luaState, \"action\");\n    push_service (M);\n    lua_settable (luaState, -3); \n  }\n}\n\nvoid lua_binlog_end (void) {\n  if (!have_file) { return; }\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n  lua_getglobal (luaState, \"on_binlog_replay_end\");\n  assert (lua_gettop (luaState) == 1);\n\n  int r = ps_lua_pcall (luaState, 0, 0, 0);\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n}\n\nvoid lua_diff_end (void) {\n  if (!have_file) { return; }\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n  lua_getglobal (luaState, \"on_get_difference_end\");\n  assert (lua_gettop (luaState) == 1);\n\n  int r = ps_lua_pcall (luaState, 0, 0, 0);\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n}\n\nvoid lua_our_id (tgl_peer_id_t id) {\n  if (!have_file) { return; }\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n  lua_getglobal (luaState, \"on_our_id\");\n  lua_pushnumber (luaState, tgl_get_peer_id (id));\n  assert (lua_gettop (luaState) == 2);\n\n  int r = ps_lua_pcall (luaState, 1, 0, 0);\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n}\n\nvoid lua_new_msg (struct tgl_message *M) {\n  if (!have_file) { return; }\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n  lua_getglobal (luaState, \"on_msg_receive\");\n  push_message (M);\n  assert (lua_gettop (luaState) == 2);\n\n  int r = ps_lua_pcall (luaState, 1, 0, 0);\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n}\n\nvoid lua_secret_chat_update (struct tgl_secret_chat *C, unsigned flags) {\n  if (!have_file) { return; }\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n  lua_getglobal (luaState, \"on_secret_chat_update\");\n  push_peer (C->id, (void *)C);\n  push_update_types (flags);\n  assert (lua_gettop (luaState) == 3);\n\n  int r = ps_lua_pcall (luaState, 2, 0, 0);\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n}\n\nvoid lua_user_update (struct tgl_user *U, unsigned flags) {\n  if (!have_file) { return; }\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n  lua_getglobal (luaState, \"on_user_update\");\n  push_peer (U->id, (void *)U);\n  push_update_types (flags);\n  assert (lua_gettop (luaState) == 3);\n\n  int r = ps_lua_pcall (luaState, 2, 0, 0);\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n}\n\nvoid lua_chat_update (struct tgl_chat *C, unsigned flags) {\n  if (!have_file) { return; }\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n  lua_getglobal (luaState, \"on_chat_update\");\n  push_peer (C->id, (void *)C);\n  push_update_types (flags);\n  assert (lua_gettop (luaState) == 3);\n\n  int r = ps_lua_pcall (luaState, 2, 0, 0);\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n}\n\n//extern tgl_peer_t *Peers[];\n//extern int peer_num;\n\n#define MAX_LUA_COMMANDS 1000\n\nstruct lua_arg {\n  int flags;\n  union {\n    tgl_message_id_t msg_id;\n    tgl_peer_id_t peer_id;\n    char *str;\n    long long num;\n    double dnum;\n    void *ptr;\n  };\n};\nstruct lua_arg lua_ptr[MAX_LUA_COMMANDS];\nstatic int pos;\n\nstatic inline tgl_peer_t *get_peer (const char *s) { \n  return tgl_peer_get_by_name (TLS, s);\n}\n  \nenum lua_query_type {\n  lq_contact_list,\n  lq_dialog_list,\n  lq_msg,\n  lq_msg_channel,\n  lq_send_typing,\n  lq_send_typing_abort,\n  lq_rename_chat,\n  lq_send_photo,\n  lq_chat_set_photo,\n  lq_set_profile_photo,\n  lq_set_profile_name,\n  lq_send_video,\n  lq_send_text,\n  lq_reply,\n  lq_fwd,\n  lq_fwd_media,\n  lq_load_photo,\n  lq_load_video_thumb,\n  lq_load_video,\n  lq_chat_info,\n  lq_channel_info,\n  lq_user_info,\n  lq_history,\n  lq_chat_add_user,\n  lq_chat_del_user,\n  lq_add_contact,\n  lq_del_contact,\n  lq_rename_contact,\n  lq_search,\n  lq_global_search,\n  lq_mark_read,\n  lq_create_secret_chat,\n  lq_create_group_chat,\n  lq_send_audio,\n  lq_send_document,\n  lq_send_file,\n  lq_load_audio,\n  lq_load_document,\n  lq_load_document_thumb,\n  lq_delete_msg,\n  lq_restore_msg,\n  lq_accept_secret_chat,\n  lq_send_contact,\n  lq_status_online,\n  lq_status_offline,\n  lq_send_location,\n  lq_extf,\n  lq_import_chat_link,\n  lq_export_chat_link,\n  lq_channel_invite_user,\n  lq_channel_kick_user,\n  lq_channel_get_admins,\n  lq_channel_get_users\n};\n\nstruct lua_query_extra {\n  int func;\n  int param;\n};\n\nvoid lua_empty_cb (struct tgl_state *TLSR, void *cb_extra, int success) {\n  assert (TLSR == TLS);\n  struct lua_query_extra *cb = cb_extra;\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->func);\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  lua_pushnumber (luaState, success);\n\n  assert (lua_gettop (luaState) == 3);\n\n  int r = ps_lua_pcall (luaState, 2, 0, 0);\n\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->func);\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n\n  free (cb);\n}\n\nvoid lua_contact_list_cb (struct tgl_state *TLSR, void *cb_extra, int success, int num, struct tgl_user **UL) {\n  assert (TLSR == TLS);\n  struct lua_query_extra *cb = cb_extra;\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->func);\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  lua_pushnumber (luaState, success);\n\n  if (success) {\n    lua_newtable (luaState);\n    int i;\n    for (i = 0; i < num; i++) {\n      lua_pushnumber (luaState, i);\n      push_peer (UL[i]->id, (void *)UL[i]);\n      lua_settable (luaState, -3);\n    }\n  } else {\n    lua_pushboolean (luaState, 0);\n  }\n\n  assert (lua_gettop (luaState) == 4);\n\n  int r = ps_lua_pcall (luaState, 3, 0, 0);\n\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->func);\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n\n  free (cb);\n}\n\nvoid lua_dialog_list_cb (struct tgl_state *TLSR, void *cb_extra, int success, int num, tgl_peer_id_t peers[], tgl_message_id_t *msgs[], int unread[]) {\n  assert (TLSR == TLS);\n  struct lua_query_extra *cb = cb_extra;\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->func);\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  lua_pushnumber (luaState, success);\n  if (success) {\n    lua_newtable (luaState);\n    int i;\n    for (i = 0; i < num; i++) {\n      lua_pushnumber (luaState, i);\n\n      lua_newtable (luaState);\n\n      lua_pushstring (luaState, \"peer\");\n      push_peer (peers[i], tgl_peer_get (TLS, peers[i]));\n      lua_settable (luaState, -3);\n\n      struct tgl_message *M = tgl_message_get (TLS, msgs[i]);\n      if (M && (M->flags & TGLMF_CREATED)) {\n        lua_pushstring (luaState, \"message\");\n        push_message (M);\n        lua_settable (luaState, -3);\n      }\n\n      lua_pushstring (luaState, \"unread\");\n      lua_pushnumber (luaState, unread[i]);\n      lua_settable (luaState, -3);\n\n      lua_settable (luaState, -3);\n    }\n  } else {\n    lua_pushboolean (luaState, 0);\n  }\n  assert (lua_gettop (luaState) == 4);\n\n\n  int r = ps_lua_pcall (luaState, 3, 0, 0);\n\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->func);\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n\n  free (cb);\n}\n\nvoid lua_msg_cb (struct tgl_state *TLSR, void *cb_extra, int success, struct tgl_message *M) {\n  assert (TLSR == TLS);\n  struct lua_query_extra *cb = cb_extra;\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->func);\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  lua_pushnumber (luaState, success);\n\n  if (success && M && (M->flags & TGLMF_CREATED)) {\n    push_message (M);\n  } else {\n    lua_pushboolean (luaState, 0);\n  }\n\n  assert (lua_gettop (luaState) == 4);\n\n  int r = ps_lua_pcall (luaState, 3, 0, 0);\n\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->func);\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n\n  free (cb);\n}\n\nvoid lua_one_msg_cb (struct tgl_state *TLSR, void *cb_extra, int success, int size, struct tgl_message *M[]) {\n  assert (TLSR == TLS);\n  struct lua_query_extra *cb = cb_extra;\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->func);\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  lua_pushnumber (luaState, success);\n\n  if (success && size > 0 && M[0] && (M[0]->flags & TGLMF_CREATED)) {\n    push_message (M[0]);\n  } else {\n    lua_pushboolean (luaState, 0);\n  }\n\n  assert (lua_gettop (luaState) == 4);\n\n  int r = ps_lua_pcall (luaState, 3, 0, 0);\n\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->func);\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n\n  free (cb);\n}\n\nvoid lua_msg_list_cb (struct tgl_state *TLSR, void *cb_extra, int success, int num, struct tgl_message *M[]) {\n  assert (TLSR == TLS);\n  struct lua_query_extra *cb = cb_extra;\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->func);\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  lua_pushnumber (luaState, success);\n\n  if (success) {\n    lua_newtable (luaState);\n    int i;\n    for (i = 0; i < num; i++) {\n      lua_pushnumber (luaState, i);\n      push_message (M[i]);\n      lua_settable (luaState, -3);\n    }\n  } else {\n    lua_pushboolean (luaState, 0);\n  }\n\n  assert (lua_gettop (luaState) == 4);\n\n  int r = ps_lua_pcall (luaState, 3, 0, 0);\n\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->func);\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n\n  free (cb);\n}\n\nvoid lua_file_cb (struct tgl_state *TLSR, void *cb_extra, int success, const char *file_name) {\n  assert (TLSR == TLS);\n  struct lua_query_extra *cb = cb_extra;\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->func);\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  lua_pushnumber (luaState, success);\n\n  if (success) {\n    lua_pushstring (luaState, file_name);\n  } else {\n    lua_pushboolean (luaState, 0);\n  }\n\n  assert (lua_gettop (luaState) == 4);\n\n  int r = ps_lua_pcall (luaState, 3, 0, 0);\n\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->func);\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n\n  free (cb);\n}\n\nvoid lua_chat_cb (struct tgl_state *TLSR, void *cb_extra, int success, struct tgl_chat *C) {\n  assert (TLSR == TLS);\n  struct lua_query_extra *cb = cb_extra;\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->func);\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  lua_pushnumber (luaState, success);\n\n  if (success) {\n    push_peer (C->id, (void *)C);\n  } else {\n    lua_pushboolean (luaState, 0);\n  }\n\n  assert (lua_gettop (luaState) == 4);\n\n  int r = ps_lua_pcall (luaState, 3, 0, 0);\n\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->func);\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n\n  free (cb);\n}\n\nvoid lua_secret_chat_cb (struct tgl_state *TLSR, void *cb_extra, int success, struct tgl_secret_chat *C) {\n  assert (TLSR == TLS);\n  struct lua_query_extra *cb = cb_extra;\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->func);\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  lua_pushnumber (luaState, success);\n\n  if (success) {\n    push_peer (C->id, (void *)C);\n  } else {\n    lua_pushboolean (luaState, 0);\n  }\n\n  assert (lua_gettop (luaState) == 4);\n\n  int r = ps_lua_pcall (luaState, 3, 0, 0);\n\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->func);\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n\n  free (cb);\n}\n\nvoid lua_channel_cb (struct tgl_state *TLSR, void *cb_extra, int success, struct tgl_channel *C) {\n  assert (TLSR == TLS);\n  struct lua_query_extra *cb = cb_extra;\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->func);\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  lua_pushnumber (luaState, success);\n\n  if (success) {\n    push_peer (C->id, (void *)C);\n  } else {\n    lua_pushboolean (luaState, 0);\n  }\n\n  assert (lua_gettop (luaState) == 4);\n\n  int r = ps_lua_pcall (luaState, 3, 0, 0);\n\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->func);\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n\n  free (cb);\n}\n\nvoid lua_user_cb (struct tgl_state *TLSR, void *cb_extra, int success, struct tgl_user *C) {\n  assert (TLSR == TLS);\n  struct lua_query_extra *cb = cb_extra;\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->func);\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  lua_pushnumber (luaState, success);\n\n  if (success) {\n    push_peer (C->id, (void *)C);\n  } else {\n    lua_pushboolean (luaState, 0);\n  }\n\n  assert (lua_gettop (luaState) == 4);\n\n  int r = ps_lua_pcall (luaState, 3, 0, 0);\n\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->func);\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n\n  free (cb);\n}\n\nvoid lua_str_cb (struct tgl_state *TLSR, void *cb_extra, int success, const char *data) {\n  assert (TLSR == TLS);\n  struct lua_query_extra *cb = cb_extra;\n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->func);\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  lua_pushnumber (luaState, success);\n\n  if (success) {\n    lua_pushstring (luaState, data);\n  } else {\n    lua_pushboolean (luaState, 0);\n  }\n\n  assert (lua_gettop (luaState) == 4);\n\n  int r = ps_lua_pcall (luaState, 3, 0, 0);\n\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->func);\n  luaL_unref (luaState, LUA_REGISTRYINDEX, cb->param);\n\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n\n  free (cb);\n}\n\n#define LUA_STR_ARG(n) lua_ptr[n].str, strlen (lua_ptr[n].str)\n\nvoid lua_do_all (void) {\n  int p = 0;\n  while (p < pos) {\n    int l = lua_ptr[p ++].num;\n    assert (p + l + 1 <= pos);\n    enum lua_query_type f = lua_ptr[p ++].num;\n    struct tgl_message *M;\n    int q = p;\n    tgl_message_id_t *tmp_msg_id;\n    switch (f) {\n    case lq_contact_list:\n      tgl_do_update_contact_list (TLS, lua_contact_list_cb, lua_ptr[p ++].ptr);\n      break;\n    case lq_dialog_list:\n      tgl_do_get_dialog_list (TLS, 100, 0, lua_dialog_list_cb, lua_ptr[p ++].ptr);\n      break;\n    case lq_msg:\n      tgl_do_send_message (TLS, lua_ptr[p + 1].peer_id, LUA_STR_ARG (p + 2), 0, NULL, lua_msg_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_msg_channel:\n      tgl_do_send_message (TLS, lua_ptr[p + 1].peer_id, LUA_STR_ARG (p + 2), 256, NULL, lua_msg_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_send_typing:\n      tgl_do_send_typing (TLS, lua_ptr[p + 1].peer_id, tgl_typing_typing, lua_empty_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_send_typing_abort:\n      tgl_do_send_typing (TLS, lua_ptr[p + 1].peer_id, tgl_typing_cancel, lua_empty_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_rename_chat:\n      tgl_do_rename_chat (TLS, lua_ptr[p + 1].peer_id, LUA_STR_ARG (p + 2), lua_empty_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_send_photo:\n      tgl_do_send_document (TLS, lua_ptr[p + 1].peer_id, lua_ptr[p + 2].str, NULL, 0, TGL_SEND_MSG_FLAG_DOCUMENT_PHOTO, lua_msg_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_send_video:\n      tgl_do_send_document (TLS, lua_ptr[p + 1].peer_id, lua_ptr[p + 2].str, NULL, 0, TGL_SEND_MSG_FLAG_DOCUMENT_VIDEO, lua_msg_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_send_audio:\n      tgl_do_send_document (TLS, lua_ptr[p + 1].peer_id, lua_ptr[p + 2].str, NULL, 0, TGL_SEND_MSG_FLAG_DOCUMENT_AUDIO, lua_msg_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_send_document:\n      tgl_do_send_document (TLS, lua_ptr[p + 1].peer_id, lua_ptr[p + 2].str, NULL, 0, 0, lua_msg_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_send_file:\n      tgl_do_send_document (TLS, lua_ptr[p + 1].peer_id, lua_ptr[p + 2].str, NULL, 0, TGL_SEND_MSG_FLAG_DOCUMENT_AUTO, lua_msg_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_send_text:\n      tgl_do_send_text (TLS, lua_ptr[p + 1].peer_id, lua_ptr[p + 2].str, 0, lua_msg_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_chat_set_photo:\n      tgl_do_set_chat_photo (TLS, lua_ptr[p + 1].peer_id, lua_ptr[p + 2].str, lua_empty_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_load_photo:\n    case lq_load_video:\n    case lq_load_audio:\n    case lq_load_document:\n      M = tgl_message_get (TLS, &lua_ptr[p + 1].msg_id);\n      if (!M || (M->media.type != tgl_message_media_photo && M->media.type != tgl_message_media_document && M->media.type != tgl_message_media_document_encr)) {\n        lua_file_cb (TLS, lua_ptr[p].ptr, 0, 0);\n      } else {\n        if (M->media.type == tgl_message_media_photo) {\n          assert (M->media.photo);\n          tgl_do_load_photo (TLS, M->media.photo, lua_file_cb, lua_ptr[p].ptr);\n        } else if (M->media.type == tgl_message_media_document) {\n          assert (M->media.document);\n          tgl_do_load_document (TLS, M->media.document, lua_file_cb, lua_ptr[p].ptr);\n        } else {\n          tgl_do_load_encr_document (TLS, M->media.encr_document, lua_file_cb, lua_ptr[p].ptr);\n        }\n      }\n      p += 2;\n      break;\n    case lq_load_video_thumb:\n    case lq_load_document_thumb:\n      M = tgl_message_get (TLS, &lua_ptr[p + 1].msg_id);\n      if (!M || (M->media.type != tgl_message_media_document)) {\n        lua_file_cb (TLS, lua_ptr[p].ptr, 0, 0);\n      } else {\n        tgl_do_load_document_thumb (TLS, M->media.document, lua_file_cb, lua_ptr[p].ptr);\n      }\n      p += 2;\n      break;\n    case lq_reply:\n      tgl_do_reply_message (TLS, &lua_ptr[p + 1].msg_id, LUA_STR_ARG (p + 2), 0, lua_msg_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_fwd:\n      tmp_msg_id = &lua_ptr[p + 2].msg_id;\n      tgl_do_forward_messages (TLS, lua_ptr[p + 1].peer_id, 1, (void *)&tmp_msg_id, 0, lua_one_msg_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_fwd_media:\n      tgl_do_forward_media (TLS, lua_ptr[p + 1].peer_id, &lua_ptr[p + 2].msg_id, 0, lua_msg_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_chat_info:\n      tgl_do_get_chat_info (TLS, lua_ptr[p + 1].peer_id, 0, lua_chat_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_channel_info:\n      tgl_do_get_channel_info (TLS, lua_ptr[p + 1].peer_id, 0, lua_channel_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_user_info:\n      tgl_do_get_user_info (TLS, lua_ptr[p + 1].peer_id, 0, lua_user_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_history:\n      tgl_do_get_history (TLS, lua_ptr[p + 1].peer_id, 0, lua_ptr[p + 2].num, 0, lua_msg_list_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_chat_add_user:\n      tgl_do_add_user_to_chat (TLS, lua_ptr[p + 1].peer_id, lua_ptr[p + 2].peer_id, 10, lua_empty_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_chat_del_user:\n      tgl_do_del_user_from_chat (TLS, lua_ptr[p + 1].peer_id, lua_ptr[p + 2].peer_id, lua_empty_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_add_contact:\n      tgl_do_add_contact (TLS, LUA_STR_ARG (p + 1), LUA_STR_ARG (p + 2), LUA_STR_ARG (p + 3), 0, lua_contact_list_cb, lua_ptr[p].ptr);\n      p += 4;\n      break;\n    case lq_del_contact:\n      tgl_do_del_contact (TLS, lua_ptr[p + 1].peer_id, lua_empty_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_rename_contact:\n      tgl_do_add_contact (TLS, LUA_STR_ARG (p + 1), LUA_STR_ARG (p + 2), LUA_STR_ARG (p + 3), 1, lua_contact_list_cb, lua_ptr[p].ptr);\n      p += 4;\n      break;\n    case lq_search:\n      tgl_do_msg_search (TLS, lua_ptr[p + 1].peer_id, 0, 0, 40, 0, LUA_STR_ARG (p + 2), lua_msg_list_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_global_search:\n      tgl_do_msg_search (TLS, tgl_set_peer_id (TGL_PEER_UNKNOWN, 0), 0, 0, 40, 0, LUA_STR_ARG (p + 1), lua_msg_list_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_mark_read:\n      tgl_do_mark_read (TLS, lua_ptr[p + 1].peer_id, lua_empty_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_set_profile_photo:\n      tgl_do_set_profile_photo (TLS, lua_ptr[p + 1].str, lua_empty_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_set_profile_name:\n      tgl_do_set_profile_name (TLS, LUA_STR_ARG (p + 1), LUA_STR_ARG (p + 2), lua_user_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_create_secret_chat:\n      tgl_do_create_secret_chat (TLS, lua_ptr[p + 1].peer_id, lua_secret_chat_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_create_group_chat:\n      tgl_do_create_group_chat (TLS, 1, &lua_ptr[p + 1].peer_id, LUA_STR_ARG (p + 2), lua_empty_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_delete_msg:\n      tgl_do_delete_msg (TLS, &lua_ptr[p + 1].msg_id, lua_empty_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_accept_secret_chat:\n      tgl_do_accept_encr_chat_request (TLS, (void *)tgl_peer_get (TLS, lua_ptr[p + 1].peer_id), lua_secret_chat_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_send_contact:\n      tgl_do_send_contact (TLS, lua_ptr[p + 1].peer_id, LUA_STR_ARG (p + 2), LUA_STR_ARG (p + 3), LUA_STR_ARG (p + 4), 0, lua_msg_cb, lua_ptr[p].ptr);\n      p += 5;\n      break;\n    case lq_status_online:\n      tgl_do_update_status (TLS, 1, lua_empty_cb, lua_ptr[p].ptr);\n      p ++;\n      break;\n    case lq_status_offline:\n      tgl_do_update_status (TLS, 0, lua_empty_cb, lua_ptr[p].ptr);\n      p ++;\n      break;\n    case lq_extf:\n      tgl_do_send_extf (TLS, LUA_STR_ARG (p + 1), lua_str_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_import_chat_link:\n      tgl_do_import_chat_link (TLS, LUA_STR_ARG (p + 1), lua_empty_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_export_chat_link:\n      tgl_do_export_chat_link (TLS, lua_ptr[p + 1].peer_id, lua_str_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_send_location:\n      tgl_do_send_location (TLS, lua_ptr[p + 1].peer_id, lua_ptr[p + 2].dnum, lua_ptr[p + 3].dnum, 0, lua_msg_cb, lua_ptr[p].ptr);\n      p += 4;\n      break;\n    case lq_channel_invite_user:\n      tgl_do_channel_invite_user (TLS, lua_ptr[p + 1].peer_id, lua_ptr[p + 2].peer_id, lua_empty_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_channel_kick_user:\n      tgl_do_channel_kick_user (TLS, lua_ptr[p + 1].peer_id, lua_ptr[p + 2].peer_id, lua_empty_cb, lua_ptr[p].ptr);\n      p += 3;\n      break;\n    case lq_channel_get_admins:\n      tgl_do_channel_get_members (TLS, lua_ptr[p + 1].peer_id, 100, 0, 1, lua_contact_list_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n    case lq_channel_get_users:\n      tgl_do_channel_get_members (TLS, lua_ptr[p + 1].peer_id, 100, 0, 0, lua_contact_list_cb, lua_ptr[p].ptr);\n      p += 2;\n      break;\n  /*\n  lq_delete_msg,\n  lq_restore_msg,\n    case 0:\n      tgl_do_send_message (((tgl_peer_t *)lua_ptr[p])->id, lua_ptr[p + 1], strlen (lua_ptr[p + 1]), 0, 0);\n      free (lua_ptr[p + 1]);\n      p += 2;\n      break;\n    case 1:\n      tgl_do_forward_message (((tgl_peer_t *)lua_ptr[p])->id, (long)lua_ptr[p + 1], 0, 0);\n      p += 2;\n      break;\n    case 2:\n      tgl_do_mark_read (((tgl_peer_t *)lua_ptr[p])->id, 0, 0);\n      p += 1;\n      break;*/\n    default:\n      assert (0);\n    }\n    while (q < p) {\n      if (lua_ptr[q].flags & 1) {\n        tfree_str (lua_ptr[q].str);\n      }\n      q ++;\n    }\n  }\n  pos = 0;\n}\n\n\nenum lua_function_param {\n  lfp_none,\n  lfp_peer,\n  lfp_chat,\n  lfp_channel,\n  lfp_user,\n  lfp_secret_chat,\n  lfp_string,\n  lfp_number,\n  lfp_positive_number,\n  lfp_nonnegative_number,\n  lfp_msg,\n  lfp_double\n};\n\nstruct lua_function {\n  char *name;\n  enum lua_query_type type;\n  enum lua_function_param params[10];\n};\n\nstruct lua_function functions[] = {\n  {\"get_contact_list\", lq_contact_list, { lfp_none }},\n  {\"get_dialog_list\", lq_dialog_list, { lfp_none }},\n  {\"rename_chat\", lq_rename_chat, { lfp_chat, lfp_string, lfp_none }},\n  {\"send_msg\", lq_msg, { lfp_peer, lfp_string, lfp_none }},\n  {\"post_msg\", lq_msg_channel, { lfp_channel, lfp_string, lfp_none }},\n  {\"send_typing\", lq_send_typing, { lfp_peer, lfp_none }},\n  {\"send_typing_abort\", lq_send_typing_abort, { lfp_peer, lfp_none }},\n  {\"send_photo\", lq_send_photo, { lfp_peer, lfp_string, lfp_none }},\n  {\"send_video\", lq_send_video, { lfp_peer, lfp_string, lfp_none }},\n  {\"send_audio\", lq_send_audio, { lfp_peer, lfp_string, lfp_none }},\n  {\"send_document\", lq_send_document, { lfp_peer, lfp_string, lfp_none }},\n  {\"send_file\", lq_send_file, { lfp_peer, lfp_string, lfp_none }},\n  {\"send_text\", lq_send_text, { lfp_peer, lfp_string, lfp_none }},\n  {\"chat_set_photo\", lq_chat_set_photo, { lfp_chat, lfp_string, lfp_none }},\n  {\"load_photo\", lq_load_photo, { lfp_msg, lfp_none }},\n  {\"load_video\", lq_load_video, { lfp_msg, lfp_none }},\n  {\"load_video_thumb\", lq_load_video_thumb, { lfp_msg, lfp_none }},\n  {\"load_audio\", lq_load_audio, { lfp_msg, lfp_none }},\n  {\"load_document\", lq_load_document, { lfp_msg, lfp_none }},\n  {\"load_document_thumb\", lq_load_document_thumb, { lfp_msg, lfp_none }},\n  {\"reply_msg\", lq_reply, { lfp_msg, lfp_string, lfp_none }},\n  {\"fwd_msg\", lq_fwd, { lfp_peer, lfp_msg, lfp_none }},\n  {\"fwd_media\", lq_fwd_media, { lfp_peer, lfp_msg, lfp_none }},\n  {\"chat_info\", lq_chat_info, { lfp_chat, lfp_none }},\n  {\"channel_info\", lq_channel_info, { lfp_channel, lfp_none }},\n  {\"user_info\", lq_user_info, { lfp_user, lfp_none }},\n  {\"get_history\", lq_history, { lfp_peer, lfp_nonnegative_number, lfp_none }},\n  {\"chat_add_user\", lq_chat_add_user, { lfp_chat, lfp_user, lfp_none }},\n  {\"chat_del_user\", lq_chat_del_user, { lfp_chat, lfp_user, lfp_none }},\n  {\"add_contact\", lq_add_contact, { lfp_string, lfp_string, lfp_string, lfp_none }},\n  {\"del_contact\", lq_del_contact, { lfp_user, lfp_none }},\n  {\"rename_contact\", lq_rename_contact, { lfp_string, lfp_string, lfp_string, lfp_none }},\n  {\"msg_search\", lq_search, { lfp_peer, lfp_string, lfp_none }},\n  {\"msg_global_search\", lq_global_search, { lfp_string, lfp_none }},\n  {\"mark_read\", lq_mark_read, { lfp_peer, lfp_none }},\n  {\"set_profile_photo\", lq_set_profile_photo, { lfp_string, lfp_none }},\n  {\"set_profile_name\", lq_set_profile_name, { lfp_string, lfp_none }},\n  {\"create_secret_chat\", lq_create_secret_chat, { lfp_user, lfp_none }},\n  {\"create_group_chat\", lq_create_group_chat, { lfp_user, lfp_string, lfp_none }},\n  {\"delete_msg\", lq_delete_msg, { lfp_msg, lfp_none }},\n  {\"restore_msg\", lq_restore_msg, { lfp_positive_number, lfp_none }},\n  {\"accept_secret_chat\", lq_accept_secret_chat, { lfp_secret_chat, lfp_none }},\n  {\"send_contact\", lq_send_contact, { lfp_peer, lfp_string, lfp_string, lfp_string, lfp_none }},\n  {\"status_online\", lq_status_online, { lfp_none }},\n  {\"status_offline\", lq_status_offline, { lfp_none }},\n  {\"send_location\", lq_send_location, { lfp_peer, lfp_double, lfp_double, lfp_none }},  \n  {\"ext_function\", lq_extf, { lfp_string, lfp_none }},\n  {\"import_chat_link\", lq_import_chat_link, { lfp_string, lfp_none }},\n  {\"export_chat_link\", lq_export_chat_link, { lfp_chat, lfp_none }},\n  {\"channel_invite_user\", lq_channel_invite_user, { lfp_channel, lfp_user, lfp_none }},\n  {\"channel_kick_user\", lq_channel_kick_user, { lfp_channel, lfp_user, lfp_none }},\n  {\"channel_get_admins\", lq_channel_get_admins, { lfp_channel, lfp_none }},\n  {\"channel_get_users\", lq_channel_get_users, { lfp_channel, lfp_none }},\n  { 0, 0, { lfp_none}}\n};\n\nstatic int parse_lua_function (lua_State *L, struct lua_function *F) {\n  int p = 0;\n  while (F->params[p] != lfp_none) { p ++; }\n  if (lua_gettop (L) != p + 2) {\n    lua_pushboolean (L, 0);\n    return 1;\n  }\n  \n  int a1 = luaL_ref (L, LUA_REGISTRYINDEX);\n  int a2 = luaL_ref (L, LUA_REGISTRYINDEX);\n  \n  struct lua_query_extra *e = malloc (sizeof (*e));\n  assert (e);\n  e->func = a2;\n  e->param = a1;\n\n  assert (pos + 3 + p < MAX_LUA_COMMANDS);\n\n  lua_ptr[pos ++].num = (p + 1);\n  lua_ptr[pos ++].num = F->type;\n  lua_ptr[pos ++].ptr = e;\n\n  int sp = p;\n  int ok = 1;\n  int cc = 0;\n  while (p > 0) {\n    p --;\n    cc ++;\n    const char *s;\n    long long num;\n    double dval;\n    tgl_peer_id_t peer_id;\n    lua_ptr[pos + p].flags = 0;\n    switch (F->params[p]) {\n    case lfp_none:\n      assert (0);\n      break;\n    case lfp_peer:\n    case lfp_user:\n    case lfp_chat:\n    case lfp_channel:\n    case lfp_secret_chat:\n      s = lua_tostring (L, -cc);\n      if (!s) {\n        ok = 0;\n        break;\n      }\n      \n      if (F->params[p] == lfp_user) {\n        peer_id = parse_input_peer_id (s, strlen (s), TGL_PEER_USER);\n      } else if (F->params[p] == lfp_chat) {\n        peer_id = parse_input_peer_id (s, strlen (s), TGL_PEER_CHAT);\n      } else if (F->params[p] == lfp_secret_chat) {\n        peer_id = parse_input_peer_id (s, strlen (s), TGL_PEER_ENCR_CHAT);\n      } else if (F->params[p] == lfp_channel) {\n        peer_id = parse_input_peer_id (s, strlen (s), TGL_PEER_CHANNEL);\n      } else {\n        peer_id = parse_input_peer_id (s, strlen (s), 0);\n      }\n      \n      if (!peer_id.peer_type) {\n        ok = 0;\n        break;\n      }\n      \n      lua_ptr[pos + p].peer_id = peer_id;\n      break;\n\n    case lfp_string:\n      s = lua_tostring (L, -cc);\n      if (!s) {\n        ok = 0;\n        break;\n      }\n      lua_ptr[pos + p].str = (void *)s;\n      lua_ptr[pos + p].flags |= 1;\n      break;\n\n    case lfp_number:\n      num = lua_tonumber (L, -cc);\n      \n      lua_ptr[pos + p].num = num;\n      break;\n    \n    case lfp_double:\n      dval = lua_tonumber (L, -cc);\n      lua_ptr[pos + p].dnum = dval;\n      break;\n\n    case lfp_msg:\n      s = lua_tostring (L, -cc);\n      if (!s) {\n        ok = 0;\n        break;\n      }\n      lua_ptr[pos + p].msg_id = parse_input_msg_id (s, strlen (s));\n      if (lua_ptr[pos + p].msg_id.peer_type == 0) {\n        ok = 0;\n        break;\n      }\n      break;\n    \n    case lfp_positive_number:\n      num = lua_tonumber (L, -cc);\n      if (num <= 0) {\n        ok = 0;\n        break;\n      }\n      \n      lua_ptr[pos + p].num = num;\n      break;\n    \n    case lfp_nonnegative_number:\n      num = lua_tonumber (L, -cc);\n      if (num < 0) {\n        ok = 0;\n        break;\n      }\n      \n      lua_ptr[pos + p].num = num;\n      break;\n    \n    default:\n      assert (0);\n    }\n  }\n  if (!ok) {\n    luaL_unref (luaState, LUA_REGISTRYINDEX, a1);\n    luaL_unref (luaState, LUA_REGISTRYINDEX, a2);\n    free (e);\n    pos -= 3;\n    lua_pushboolean (L, 0);\n    return 1;\n  }\n  \n  for (p = 0; p < sp; p++) {\n    if (F->params[p] == lfp_string) {\n      lua_ptr[pos + p].str = tstrdup (lua_ptr[pos + p].str);\n    }\n  }\n  pos += p;\n\n  lua_pushboolean (L, 1);\n  return 1;\n}\n\n\nstatic void lua_postpone_alarm (evutil_socket_t fd, short what, void *arg) {\n  int *t = arg;\n  \n  lua_settop (luaState, 0);\n  //lua_checkstack (luaState, 20);\n  my_lua_checkstack (luaState, 20);\n\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, t[1]);\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, t[0]);\n  assert (lua_gettop (luaState) == 2);\n  \n  int r = ps_lua_pcall (luaState, 1, 0, 0);\n\n  luaL_unref (luaState, LUA_REGISTRYINDEX, t[0]);\n  luaL_unref (luaState, LUA_REGISTRYINDEX, t[1]);\n\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n\n}\n\nstatic int postpone_from_lua (lua_State *L) {\n  int n = lua_gettop (L);\n  if (n != 3) {\n    lua_pushboolean (L, 0);\n    return 1;\n  }\n\n  double timeout = lua_tonumber (L, -1);\n  if (timeout < 0) {\n    lua_pushboolean (L, 0);\n    return 1;\n  }\n\n  lua_pop (L, 1);\n  int a1 = luaL_ref (L, LUA_REGISTRYINDEX);\n  int a2 = luaL_ref (L, LUA_REGISTRYINDEX);\n\n\n  int *t = malloc (16);\n  assert (t);\n  struct event *ev = evtimer_new (TLS->ev_base, lua_postpone_alarm, t);\n  t[0] = a1;\n  t[1] = a2;\n  *(void **)(t + 2) = ev;\n  \n  struct timeval ts= {\n    .tv_sec = (long)timeout,\n    .tv_usec = (timeout - ((long)timeout)) * 1000000\n  };\n  event_add (ev, &ts);\n  \n  lua_pushboolean (L, 1);\n  return 1;\n}\n\nextern int safe_quit;\nstatic int safe_quit_from_lua (lua_State *L) {\n  int n = lua_gettop (L);\n  if (n != 0) {\n    lua_pushboolean (L, 0);\n    return 1;\n  }\n  safe_quit = 1;\n  \n  lua_pushboolean (L, 1);\n  return 1;\n}\n\nstatic int universal_from_lua (lua_State *L) {\n  const char *s = lua_tostring(L, lua_upvalueindex(1));\n  if (!s) {\n    lua_pushboolean (L, 0);\n    return 1;\n  }\n  int i = 0;\n  while (functions[i].name) {\n    if (!strcmp (functions[i].name, s)) {\n      return parse_lua_function (L, &functions[i]);\n    }\n    i ++;\n  }\n  lua_pushboolean (L, 0);\n  return 1;\n}\n\n\nstatic void my_lua_register (lua_State *L, const char *name, lua_CFunction f) {\n  lua_pushstring(L, name);\n  lua_pushcclosure(L, f, 1);\n  lua_setglobal(L, name);\n}\n\nenum command_argument {\n  ca_none,\n  ca_user,\n  ca_chat,\n  ca_secret_chat,\n  ca_channel,\n  ca_peer,\n  ca_file_name,\n  ca_file_name_end,\n  ca_period,\n  ca_number,\n  ca_double,\n  ca_string_end,\n  ca_string,\n  ca_modifier,\n  ca_command,\n  ca_extf,\n\n\n  ca_optional = 256\n};\n\n\nstruct arg {\n  int flags;\n  struct {\n    tgl_peer_t *P;\n    struct tgl_message *M;\n    char *str;\n    long long num;\n    double dval;\n  };\n};\n\nstruct in_ev;\nstruct command {\n  char *name;\n  enum command_argument args[10];\n  void (*fun)(struct command *command, int arg_num, struct arg args[], struct in_ev *ev);\n  char *desc;\n  void *arg;\n};\n\n#define NOT_FOUND (int)0x80000000\n\nstatic void do_interface_from_lua (struct command *command, int arg_num, struct arg args[], struct in_ev *ev) {\n  lua_settop (luaState, 0);\n  my_lua_checkstack (luaState, 20);\n  \n  struct lua_query_extra *e = command->arg;  \n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, e->func);\n  lua_rawgeti (luaState, LUA_REGISTRYINDEX, e->param);\n \n  int i;\n  for (i = 0; i < arg_num; i ++) {\n    int j = i;\n    if (j > 9) { j = 9; }\n    while (j >= 0) {\n      if (command->args[j] == ca_period) { j --; continue; }\n      if (command->args[j] == ca_none) { j --; continue; }\n      break;\n    }\n    assert (j >= 0);\n\n    switch (command->args[j] & 0xff) {\n    case ca_none:\n    case ca_period:\n      assert (0);      \n      break;\n    case ca_user:\n    case ca_chat:\n    case ca_secret_chat:\n    case ca_peer:\n      if (args[i].P) {\n        push_peer (args[i].P->id, args[i].P);\n      } else {\n        lua_pushnil (luaState);\n      }\n      break;\n    case ca_file_name:\n    case ca_file_name_end:\n    case ca_string_end:\n    case ca_string:\n      if (args[i].str) {\n        lua_pushstring (luaState, args[i].str);\n      } else {\n        lua_pushnil (luaState);\n      }\n      break;\n    case ca_number:\n      if (args[i].num != NOT_FOUND) {\n        lua_pushnumber (luaState, args[i].num);\n      } else {\n        lua_pushnil (luaState);\n      }\n      break;\n    case ca_double:\n      if (args[i].dval != NOT_FOUND) {\n        lua_pushnumber (luaState, args[i].dval);\n      } else {\n        lua_pushnil (luaState);\n      }\n      break;\n    }\n  }\n  \n\n  \n  int r = ps_lua_pcall (luaState, 1 + arg_num, 0, 0);\n\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n  }\n}\n\nvoid register_new_command (struct command *cmd);\nstatic int register_interface_from_lua (lua_State *L) {\n  int n = lua_gettop (L);\n  if (n <= 4 || n >= 13) {\n    lua_pushboolean (L, 0);\n    return 1;\n  }\n\n  static struct command cmd;\n  memset (&cmd, 0, sizeof (struct command));\n\n  int i;\n  for (i = 0; i < n - 4; i++) {\n    const char *s = lua_tostring (L, -1);\n    lua_pop (L, 1);\n    \n    if (!s || !strlen (s)) {\n      lua_pushboolean (L, 0);\n      return 1;\n    }\n\n    int len = strlen (s);\n    int optional = 0;\n    if (len > 9 && !strcmp (s + len - 9, \" optional\")) {\n      optional = ca_optional;\n      len -= 9;\n    }\n\n    int ok = 0;\n    #define VARIANT(name) \\\n      if (len == strlen (#name) && !strncmp (s, #name, len)) {\\\n        cmd.args[n - 5 - i] = ca_ ## name | optional; \\\n        ok = 1; \\\n      }\n\n    VARIANT (user)\n    VARIANT (chat)\n    VARIANT (secret_chat)\n    VARIANT (peer)\n    VARIANT (file_name)\n    VARIANT (file_name_end)\n    VARIANT (period)\n    VARIANT (number)\n    VARIANT (double)\n    VARIANT (string_end)\n    VARIANT (string)\n    \n    #undef VARTIANT\n\n    if (!ok) {\n      lua_pushboolean (L, 0);\n      return 1;\n    }\n  }\n  \n  const char *s = lua_tostring (L, -1);\n  lua_pop (L, 1);\n  \n  cmd.desc = s ? tstrdup (s) : tstrdup (\"no help provided\");\n  \n  int a1 = luaL_ref (L, LUA_REGISTRYINDEX);\n  int a2 = luaL_ref (L, LUA_REGISTRYINDEX);\n\n  struct lua_query_extra *e = malloc (sizeof (*e));\n  assert (e);\n  e->func = a2;\n  e->param = a1;\n\n  cmd.arg = e;\n    \n  cmd.fun = do_interface_from_lua;\n  \n  s = lua_tostring (L, -1);\n  lua_pop (L, 1);\n\n  cmd.name = tstrdup (s ? s : \"none\");\n\n  register_new_command (&cmd);\n\n  lua_pushboolean (L, 1);\n  return 1;\n}\n\n\nvoid lua_init (const char *file) {\n  if (!file) { return; }\n  have_file = 1;\n  luaState = luaL_newstate ();\n  luaL_openlibs (luaState);\n\n  int i = 0;\n  while (functions[i].name) {\n    my_lua_register (luaState, functions[i].name, universal_from_lua);\n    i ++;\n  }\n  \n  lua_register (luaState, \"postpone\", postpone_from_lua);\n  lua_register (luaState, \"safe_quit\", safe_quit_from_lua);\n  lua_register (luaState, \"register_interface_function\", register_interface_from_lua);\n\n  print_start ();\n  int r = luaL_dofile (luaState, file);\n  print_end ();\n\n  if (r) {\n    logprintf (\"lua: %s\\n\",  lua_tostring (luaState, -1));\n    exit (1);\n  }\n}\n\n#endif\n"
        },
        {
          "name": "lua-tg.h",
          "type": "blob",
          "size": 1.1875,
          "content": "/*\n    This file is part of telegram-cli.\n\n    Telegram-cli is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n\n    Telegram-cli is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this telegram-cli.  If not, see <http://www.gnu.org/licenses/>.\n\n    Copyright Vitaly Valtman 2013-2015\n*/\n#ifndef __LUA_TG_H__\n#define __LUA_TG_H__\n\n#include <string.h>\n#include <tgl/tgl.h>\n\nvoid lua_init (const char *file);\nvoid lua_new_msg (struct tgl_message *M);\nvoid lua_our_id (tgl_peer_id_t id);\nvoid lua_secret_chat_update (struct tgl_secret_chat *U, unsigned flags);\nvoid lua_user_update (struct tgl_user *U, unsigned flags);\nvoid lua_chat_update (struct tgl_chat *C, unsigned flags);\nvoid lua_binlog_end (void);\nvoid lua_diff_end (void);\nvoid lua_do_all (void);\n#endif\n"
        },
        {
          "name": "m4-ax_gcc_builtin.m4",
          "type": "blob",
          "size": 5.6552734375,
          "content": "# ===========================================================================\n#      http://www.gnu.org/software/autoconf-archive/ax_gcc_builtin.html\n# ===========================================================================\n#\n# SYNOPSIS\n#\n#   AX_GCC_BUILTIN(BUILTIN)\n#\n# DESCRIPTION\n#\n#   This macro checks if the compiler supports one of GCC's built-in\n#   functions; many other compilers also provide those same built-ins.\n#\n#   The BUILTIN parameter is the name of the built-in function.\n#\n#   If BUILTIN is supported define HAVE_<BUILTIN>. Keep in mind that since\n#   builtins usually start with two underscores they will be copied over\n#   into the HAVE_<BUILTIN> definition (e.g. HAVE___BUILTIN_EXPECT for\n#   __builtin_expect()).\n#\n#   The macro caches its result in the ax_cv_have_<BUILTIN> variable (e.g.\n#   ax_cv_have___builtin_expect).\n#\n#   The macro currently supports the following built-in functions:\n#\n#    __builtin_assume_aligned\n#    __builtin_bswap32\n#    __builtin_bswap64\n#    __builtin_choose_expr\n#    __builtin___clear_cache\n#    __builtin_clrsb\n#    __builtin_clrsbl\n#    __builtin_clrsbll\n#    __builtin_clz\n#    __builtin_clzl\n#    __builtin_clzll\n#    __builtin_complex\n#    __builtin_constant_p\n#    __builtin_ctz\n#    __builtin_ctzl\n#    __builtin_ctzll\n#    __builtin_expect\n#    __builtin_ffs\n#    __builtin_ffsl\n#    __builtin_ffsll\n#    __builtin_fpclassify\n#    __builtin_huge_val\n#    __builtin_huge_valf\n#    __builtin_huge_vall\n#    __builtin_inf\n#    __builtin_infd128\n#    __builtin_infd32\n#    __builtin_infd64\n#    __builtin_inff\n#    __builtin_infl\n#    __builtin_isinf_sign\n#    __builtin_nan\n#    __builtin_nand128\n#    __builtin_nand32\n#    __builtin_nand64\n#    __builtin_nanf\n#    __builtin_nanl\n#    __builtin_nans\n#    __builtin_nansf\n#    __builtin_nansl\n#    __builtin_object_size\n#    __builtin_parity\n#    __builtin_parityl\n#    __builtin_parityll\n#    __builtin_popcount\n#    __builtin_popcountl\n#    __builtin_popcountll\n#    __builtin_powi\n#    __builtin_powif\n#    __builtin_powil\n#    __builtin_prefetch\n#    __builtin_trap\n#    __builtin_types_compatible_p\n#    __builtin_unreachable\n#\n#   Unsuppored built-ins will be tested with an empty parameter set and the\n#   result of the check might be wrong or meaningless so use with care.\n#\n# LICENSE\n#\n#   Copyright (c) 2013 Gabriele Svelto <gabriele.svelto@gmail.com>\n#\n#   Copying and distribution of this file, with or without modification, are\n#   permitted in any medium without royalty provided the copyright notice\n#   and this notice are preserved.  This file is offered as-is, without any\n#   warranty.\n\n#serial 2\n\nAC_DEFUN([AX_GCC_BUILTIN], [\n    AS_VAR_PUSHDEF([ac_var], [ax_cv_have_$1])\n\n    AC_CACHE_CHECK([for $1], [ac_var], [\n        AC_LINK_IFELSE([AC_LANG_PROGRAM([], [\n            m4_case([$1],\n                [__builtin_assume_aligned], [$1(\"\", 0)],\n                [__builtin_bswap32], [$1(0)],\n                [__builtin_bswap64], [$1(0)],\n                [__builtin_choose_expr], [$1(0, 0, 0)],\n                [__builtin___clear_cache], [$1(\"\", \"\")],\n                [__builtin_clrsb], [$1(0)],\n                [__builtin_clrsbl], [$1(0)],\n                [__builtin_clrsbll], [$1(0)],\n                [__builtin_clz], [$1(0)],\n                [__builtin_clzl], [$1(0)],\n                [__builtin_clzll], [$1(0)],\n                [__builtin_complex], [$1(0.0, 0.0)],\n                [__builtin_constant_p], [$1(0)],\n                [__builtin_ctz], [$1(0)],\n                [__builtin_ctzl], [$1(0)],\n                [__builtin_ctzll], [$1(0)],\n                [__builtin_expect], [$1(0, 0)],\n                [__builtin_ffs], [$1(0)],\n                [__builtin_ffsl], [$1(0)],\n                [__builtin_ffsll], [$1(0)],\n                [__builtin_fpclassify], [$1(0, 1, 2, 3, 4, 0.0)],\n                [__builtin_huge_val], [$1()],\n                [__builtin_huge_valf], [$1()],\n                [__builtin_huge_vall], [$1()],\n                [__builtin_inf], [$1()],\n                [__builtin_infd128], [$1()],\n                [__builtin_infd32], [$1()],\n                [__builtin_infd64], [$1()],\n                [__builtin_inff], [$1()],\n                [__builtin_infl], [$1()],\n                [__builtin_isinf_sign], [$1(0.0)],\n                [__builtin_nan], [$1(\"\")],\n                [__builtin_nand128], [$1(\"\")],\n                [__builtin_nand32], [$1(\"\")],\n                [__builtin_nand64], [$1(\"\")],\n                [__builtin_nanf], [$1(\"\")],\n                [__builtin_nanl], [$1(\"\")],\n                [__builtin_nans], [$1(\"\")],\n                [__builtin_nansf], [$1(\"\")],\n                [__builtin_nansl], [$1(\"\")],\n                [__builtin_object_size], [$1(\"\", 0)],\n                [__builtin_parity], [$1(0)],\n                [__builtin_parityl], [$1(0)],\n                [__builtin_parityll], [$1(0)],\n                [__builtin_popcount], [$1(0)],\n                [__builtin_popcountl], [$1(0)],\n                [__builtin_popcountll], [$1(0)],\n                [__builtin_powi], [$1(0, 0)],\n                [__builtin_powif], [$1(0, 0)],\n                [__builtin_powil], [$1(0, 0)],\n                [__builtin_prefetch], [$1(\"\")],\n                [__builtin_trap], [$1()],\n                [__builtin_types_compatible_p], [$1(int, int)],\n                [__builtin_unreachable], [$1()],\n                [m4_warn([syntax], [Unsupported built-in $1, the test may fail])\n                 $1()]\n            )\n            ])],\n            [AS_VAR_SET([ac_var], [yes])],\n            [AS_VAR_SET([ac_var], [no])])\n    ])\n\n    AS_IF([test yes = AS_VAR_GET([ac_var])],\n        [AC_DEFINE_UNQUOTED(AS_TR_CPP(HAVE_$1), 1,\n            [Define to 1 if the system has the `$1' built-in function])], [])\n\n    AS_VAR_POPDEF([ac_var])\n])\n"
        },
        {
          "name": "m4_ax_check_openssl.m4",
          "type": "blob",
          "size": 4.087890625,
          "content": "# ===========================================================================\n#     http://www.gnu.org/software/autoconf-archive/ax_check_openssl.html\n# ===========================================================================\n#\n# SYNOPSIS\n#\n#   AX_CHECK_OPENSSL([action-if-found[, action-if-not-found]])\n#\n# DESCRIPTION\n#\n#   Look for OpenSSL in a number of default spots, or in a user-selected\n#   spot (via --with-openssl).  Sets\n#\n#     OPENSSL_INCLUDES to the include directives required\n#     OPENSSL_LIBS to the -l directives required\n#     OPENSSL_LDFLAGS to the -L or -R flags required\n#\n#   and calls ACTION-IF-FOUND or ACTION-IF-NOT-FOUND appropriately\n#\n#   This macro sets OPENSSL_INCLUDES such that source files should use the\n#   openssl/ directory in include directives:\n#\n#     #include <openssl/hmac.h>\n#\n# LICENSE\n#\n#   Copyright (c) 2009,2010 Zmanda Inc. <http://www.zmanda.com/>\n#   Copyright (c) 2009,2010 Dustin J. Mitchell <dustin@zmanda.com>\n#\n#   Copying and distribution of this file, with or without modification, are\n#   permitted in any medium without royalty provided the copyright notice\n#   and this notice are preserved. This file is offered as-is, without any\n#   warranty.\n\n#serial 8\n\nAU_ALIAS([CHECK_SSL], [AX_CHECK_OPENSSL])\nAC_DEFUN([AX_CHECK_OPENSSL], [\n    found=false\n    AC_ARG_WITH([openssl],\n        [AS_HELP_STRING([--with-openssl=DIR],\n            [root of the OpenSSL directory])],\n        [\n            case \"$withval\" in\n            \"\" | y | ye | yes | n | no)\n            AC_MSG_ERROR([Invalid --with-openssl value])\n              ;;\n            *) ssldirs=\"$withval\"\n              ;;\n            esac\n        ], [\n            # if pkg-config is installed and openssl has installed a .pc file,\n            # then use that information and don't search ssldirs\n            AC_PATH_PROG([PKG_CONFIG], [pkg-config])\n            if test x\"$PKG_CONFIG\" != x\"\"; then\n                OPENSSL_LDFLAGS=`$PKG_CONFIG openssl --libs-only-L 2>/dev/null`\n                if test $? = 0; then\n                    OPENSSL_LIBS=`$PKG_CONFIG openssl --libs-only-l 2>/dev/null`\n                    OPENSSL_INCLUDES=`$PKG_CONFIG openssl --cflags-only-I 2>/dev/null`\n                    found=true\n                fi\n            fi\n\n            # no such luck; use some default ssldirs\n            if ! $found; then\n                ssldirs=\"/usr/local/ssl /usr/lib/ssl /usr/ssl /usr/pkg /usr/local /usr\"\n            fi\n        ]\n        )\n\n\n    # note that we #include <openssl/foo.h>, so the OpenSSL headers have to be in\n    # an 'openssl' subdirectory\n\n    if ! $found; then\n        OPENSSL_INCLUDES=\n        for ssldir in $ssldirs; do\n            AC_MSG_CHECKING([for openssl/ssl.h in $ssldir])\n            if test -f \"$ssldir/include/openssl/ssl.h\"; then\n                OPENSSL_INCLUDES=\"-I$ssldir/include\"\n                OPENSSL_LDFLAGS=\"-L$ssldir/lib\"\n                OPENSSL_LIBS=\"-lssl -lcrypto\"\n                found=true\n                AC_MSG_RESULT([yes])\n                break\n            else\n                AC_MSG_RESULT([no])\n            fi\n        done\n\n        # if the file wasn't found, well, go ahead and try the link anyway -- maybe\n        # it will just work!\n    fi\n\n    # try the preprocessor and linker with our new flags,\n    # being careful not to pollute the global LIBS, LDFLAGS, and CPPFLAGS\n\n    AC_MSG_CHECKING([whether compiling and linking against OpenSSL works])\n    echo \"Trying link with OPENSSL_LDFLAGS=$OPENSSL_LDFLAGS;\" \\\n        \"OPENSSL_LIBS=$OPENSSL_LIBS; OPENSSL_INCLUDES=$OPENSSL_INCLUDES\" >&AS_MESSAGE_LOG_FD\n\n    save_LIBS=\"$LIBS\"\n    save_LDFLAGS=\"$LDFLAGS\"\n    save_CPPFLAGS=\"$CPPFLAGS\"\n    LDFLAGS=\"$LDFLAGS $OPENSSL_LDFLAGS\"\n    LIBS=\"$OPENSSL_LIBS $LIBS\"\n    CPPFLAGS=\"$OPENSSL_INCLUDES $CPPFLAGS\"\n    AC_LINK_IFELSE(\n        [AC_LANG_PROGRAM([#include <openssl/ssl.h>], [SSL_new(NULL)])],\n        [\n            AC_MSG_RESULT([yes])\n            $1\n        ], [\n            AC_MSG_RESULT([no])\n            $2\n        ])\n    CPPFLAGS=\"$save_CPPFLAGS\"\n    LDFLAGS=\"$save_LDFLAGS\"\n    LIBS=\"$save_LIBS\"\n\n    AC_SUBST([OPENSSL_INCLUDES])\n    AC_SUBST([OPENSSL_LIBS])\n    AC_SUBST([OPENSSL_LDFLAGS])\n])\n"
        },
        {
          "name": "m4_ax_check_zlib.m4",
          "type": "blob",
          "size": 5.2890625,
          "content": "# ===========================================================================\n#       http://www.gnu.org/software/autoconf-archive/ax_check_zlib.html\n# ===========================================================================\n#\n# SYNOPSIS\n#\n#   AX_CHECK_ZLIB([action-if-found], [action-if-not-found])\n#\n# DESCRIPTION\n#\n#   This macro searches for an installed zlib library. If nothing was\n#   specified when calling configure, it searches first in /usr/local and\n#   then in /usr, /opt/local and /sw. If the --with-zlib=DIR is specified,\n#   it will try to find it in DIR/include/zlib.h and DIR/lib/libz.a. If\n#   --without-zlib is specified, the library is not searched at all.\n#\n#   If either the header file (zlib.h) or the library (libz) is not found,\n#   shell commands 'action-if-not-found' is run. If 'action-if-not-found' is\n#   not specified, the configuration exits on error, asking for a valid zlib\n#   installation directory or --without-zlib.\n#\n#   If both header file and library are found, shell commands\n#   'action-if-found' is run. If 'action-if-found' is not specified, the\n#   default action appends '-I${ZLIB_HOME}/include' to CPFLAGS, appends\n#   '-L$ZLIB_HOME}/lib' to LDFLAGS, prepends '-lz' to LIBS, and calls\n#   AC_DEFINE(HAVE_LIBZ). You should use autoheader to include a definition\n#   for this symbol in a config.h file. Sample usage in a C/C++ source is as\n#   follows:\n#\n#     #ifdef HAVE_LIBZ\n#     #include <zlib.h>\n#     #endif /* HAVE_LIBZ */\n#\n# LICENSE\n#\n#   Copyright (c) 2008 Loic Dachary <loic@senga.org>\n#   Copyright (c) 2010 Bastien Chevreux <bach@chevreux.org>\n#\n#   This program is free software; you can redistribute it and/or modify it\n#   under the terms of the GNU General Public License as published by the\n#   Free Software Foundation; either version 2 of the License, or (at your\n#   option) any later version.\n#\n#   This program is distributed in the hope that it will be useful, but\n#   WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\n#   Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License along\n#   with this program. If not, see <http://www.gnu.org/licenses/>.\n#\n#   As a special exception, the respective Autoconf Macro's copyright owner\n#   gives unlimited permission to copy, distribute and modify the configure\n#   scripts that are the output of Autoconf when processing the Macro. You\n#   need not follow the terms of the GNU General Public License when using\n#   or distributing such scripts, even though portions of the text of the\n#   Macro appear in them. The GNU General Public License (GPL) does govern\n#   all other use of the material that constitutes the Autoconf Macro.\n#\n#   This special exception to the GPL applies to versions of the Autoconf\n#   Macro released by the Autoconf Archive. When you make and distribute a\n#   modified version of the Autoconf Macro, you may extend this special\n#   exception to the GPL to apply to your modified version as well.\n\n#serial 14\n\nAU_ALIAS([CHECK_ZLIB], [AX_CHECK_ZLIB])\nAC_DEFUN([AX_CHECK_ZLIB],\n#\n# Handle user hints\n#\n[AC_MSG_CHECKING(if zlib is wanted)\nzlib_places=\"/usr/local /usr /opt/local /sw\"\nAC_ARG_WITH([zlib],\n[  --with-zlib=DIR         root directory path of zlib installation @<:@defaults to\n                          /usr/local or /usr if not found in /usr/local@:>@\n  --without-zlib          to disable zlib usage completely],\n[if test \"$withval\" != no ; then\n  AC_MSG_RESULT(yes)\n  if test -d \"$withval\"\n  then\n    zlib_places=\"$withval $zlib_places\"\n  else\n    AC_MSG_WARN([Sorry, $withval does not exist, checking usual places])\n  fi\nelse\n  zlib_places=\n  AC_MSG_RESULT(no)\nfi],\n[AC_MSG_RESULT(yes)])\n\n#\n# Locate zlib, if wanted\n#\nif test -n \"${zlib_places}\"\nthen\n\t# check the user supplied or any other more or less 'standard' place:\n\t#   Most UNIX systems      : /usr/local and /usr\n\t#   MacPorts / Fink on OSX : /opt/local respectively /sw\n\tfor ZLIB_HOME in ${zlib_places} ; do\n\t  if test -f \"${ZLIB_HOME}/include/zlib.h\"; then break; fi\n\t  ZLIB_HOME=\"\"\n\tdone\n\n  ZLIB_OLD_LDFLAGS=$LDFLAGS\n  ZLIB_OLD_CPPFLAGS=$CPPFLAGS\n  if test -n \"${ZLIB_HOME}\"; then\n        LDFLAGS=\"$LDFLAGS -L${ZLIB_HOME}/lib\"\n        CPPFLAGS=\"$CPPFLAGS -I${ZLIB_HOME}/include\"\n  fi\n  AC_LANG_SAVE\n  AC_LANG_C\n  AC_CHECK_LIB([z], [inflateEnd], [zlib_cv_libz=yes], [zlib_cv_libz=no])\n  AC_CHECK_HEADER([zlib.h], [zlib_cv_zlib_h=yes], [zlib_cv_zlib_h=no])\n  AC_LANG_RESTORE\n  if test \"$zlib_cv_libz\" = \"yes\" && test \"$zlib_cv_zlib_h\" = \"yes\"\n  then\n    #\n    # If both library and header were found, action-if-found\n    #\n    m4_ifblank([$1],[\n                CPPFLAGS=\"$CPPFLAGS -I${ZLIB_HOME}/include\"\n                LDFLAGS=\"$LDFLAGS -L${ZLIB_HOME}/lib\"\n                LIBS=\"-lz $LIBS\"\n                AC_DEFINE([HAVE_LIBZ], [1],\n                          [Define to 1 if you have `z' library (-lz)])\n               ],[\n                # Restore variables\n                LDFLAGS=\"$ZLIB_OLD_LDFLAGS\"\n                CPPFLAGS=\"$ZLIB_OLD_CPPFLAGS\"\n                $1\n               ])\n  else\n    #\n    # If either header or library was not found, action-if-not-found\n    #\n    m4_default([$2],[\n                AC_MSG_ERROR([either specify a valid zlib installation with --with-zlib=DIR or disable zlib usage with --without-zlib])\n                ])\n  fi\nfi\n])\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 25.65625,
          "content": "/*\n    This file is part of telegram-cli.\n\n    Telegram-cli is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n\n    Telegram-cli is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this telegram-cli.  If not, see <http://www.gnu.org/licenses/>.\n\n    Copyright Vitaly Valtman 2013-2015\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef USE_PYTHON\n#  include \"python-tg.h\"\n#endif\n\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <pwd.h>\n#include <termios.h>\n#include <unistd.h>\n#include <assert.h>\n#ifdef __FreeBSD__\n#include <sys/socket.h>\n#include <netinet/in.h>\n#endif\n#include <readline/readline.h>\n\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <time.h>\n#include <fcntl.h>\n\n#ifdef HAVE_EXECINFO_H\n#include <execinfo.h>\n#endif\n#include <signal.h>\n#ifdef HAVE_LIBCONFIG\n#include <libconfig.h>\n#endif\n\n#include <grp.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n\n#include \"telegram.h\"\n#include \"loop.h\"\n#include \"interface.h\"\n#include <tgl/tools.h>\n#include <getopt.h>\n#include <tgl/mtproto-key.h>\n\n#ifdef USE_LUA\n#  include \"lua-tg.h\"\n#endif\n\n\n#include <tgl/tgl.h>\n\n#define PROGNAME \"telegram-cli\"\n#define VERSION \"0.07\"\n\n#define CONFIG_DIRECTORY \".\" PROG_NAME\n#define CONFIG_FILE \"config\"\n#define AUTH_KEY_FILE \"auth\"\n#define STATE_FILE \"state\"\n#define SECRET_CHAT_FILE \"secret\"\n#define DOWNLOADS_DIRECTORY \"downloads\"\n#define BINLOG_FILE \"binlog\"\n\n\n#define CONFIG_DIRECTORY_MODE 0700\n\n#define DEFAULT_CONFIG_CONTENTS     \\\n  \"# This is an empty config file\\n\" \\\n  \"# Feel free to put something here\\n\"\n\nint bot_mode;\nint verbosity;\nint msg_num_mode;\nchar *default_username;\nchar *config_filename;\nchar *prefix;\nchar *auth_file_name;\nchar *state_file_name;\nchar *secret_chat_file_name;\nchar *downloads_directory;\nchar *config_directory;\nchar *binlog_file_name;\nchar *lua_file;\nchar *python_file;\nint binlog_enabled;\nextern int log_level;\nint sync_from_start;\nint allow_weak_random;\nint disable_colors;\nint readline_disabled;\nint disable_output;\nint reset_authorization;\nint port;\nint use_ids;\nint ipv6_enabled;\nchar *start_command;\nint disable_link_preview;\nint enable_json;\nint alert_sound;\nint exit_code;\nint permanent_msg_id_mode;\nint permanent_peer_id_mode;\nchar *home_directory;\n\nstruct tgl_state *TLS;\n\nvoid set_default_username (const char *s) {\n  if (default_username) { \n    tfree_str (default_username);\n  }\n  default_username = tstrdup (s);\n}\n\n\n/* {{{ TERMINAL */\nstatic struct termios term_in, term_out;\nstatic int term_set_in;\nstatic int term_set_out;\n\nvoid get_terminal_attributes (void) {\n  if (tcgetattr (STDIN_FILENO, &term_in) < 0) {\n  } else {\n    term_set_in = 1;\n  }\n  if (tcgetattr (STDOUT_FILENO, &term_out) < 0) {\n  } else {\n    term_set_out = 1;\n  }\n}\n\nvoid set_terminal_attributes (void) {\n  if (term_set_in) {\n    if (tcsetattr (STDIN_FILENO, 0, &term_in) < 0) {\n      perror (\"tcsetattr()\");\n    }\n  }\n  if (term_set_out) {\n    if (tcsetattr (STDOUT_FILENO, 0, &term_out) < 0) {\n      perror (\"tcsetattr()\");\n    }\n  }\n}\n/* }}} */\n\nint str_empty (char *str) {\n  return ((str == NULL) || (strlen(str) < 1));\n}\n\nchar *get_home_directory (void) {\n  if (home_directory) { return home_directory; }\n  home_directory = getenv(\"TELEGRAM_HOME\");\n  if (!str_empty (home_directory)) { return home_directory = tstrdup (home_directory); }\n  home_directory = getenv(\"HOME\");\n  if (!str_empty (home_directory)) { return home_directory = tstrdup (home_directory); }\n  struct passwd *current_passwd;\n  uid_t user_id;\n  setpwent ();\n  user_id = getuid ();\n  while ((current_passwd = getpwent ())) {\n    if (current_passwd->pw_uid == user_id) {\n      home_directory = tstrdup (current_passwd->pw_dir);\n      break;\n    }\n  }\n  endpwent ();\n  if (str_empty (home_directory)) { home_directory = tstrdup (\".\"); }\n  return home_directory;\n}\n\nchar *get_config_directory (void) {\n  char *config_directory;\n  config_directory = getenv(\"TELEGRAM_CONFIG_DIR\");\n  if (!str_empty (config_directory)) { return tstrdup (config_directory); }\n  // XDG: http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html\n  config_directory = getenv(\"XDG_CONFIG_HOME\");\n  if (!str_empty (config_directory)) {\n    tasprintf (&config_directory, \"%s/\" PROG_NAME, config_directory);\n    // :TODO: someone check whether it could be required to pass tasprintf\n    //        a tstrdup()ed config_directory instead; works for me without.\n    //        should work b/c this scope's lifespan encompasses tasprintf()\n    return config_directory;\n  }\n  tasprintf (&config_directory, \"%s/\" CONFIG_DIRECTORY, get_home_directory ());\n  return config_directory;\n}\n\nchar *get_config_filename (void) {\n  return config_filename;\n}\n\nchar *get_auth_key_filename (void) {\n  return auth_file_name;\n}\n\nchar *get_state_filename (void) {\n  return state_file_name;\n}\n\nchar *get_secret_chat_filename (void) {\n  return secret_chat_file_name;\n}\n\nchar *get_downloads_directory (void) {\n  return downloads_directory;\n}\n\nchar *get_binlog_file_name (void) {\n  return binlog_file_name;\n}\n\nchar *make_full_path (char *s) {\n  if (*s != '/') {\n    char *t = s;\n    tasprintf (&s, \"%s/%s\", get_home_directory (), s);\n    tfree_str (t);\n  }\n  return s;\n}\n\nvoid check_type_sizes (void) {\n  if (sizeof (int) != 4u) {\n    logprintf (\"sizeof (int) isn't equal 4.\\n\");\n    exit (1);\n  }\n  if (sizeof (char) != 1u) {\n    logprintf (\"sizeof (char) isn't equal 1.\\n\");\n    exit (1);\n  }\n}\n\nvoid running_for_first_time (void) {\n  check_type_sizes ();\n  if (!str_empty (config_filename)) {\n    return; // Do not create custom config file\n  }\n  if (str_empty (config_directory)) {\n    config_directory = get_config_directory ();\n  }\n  tasprintf (&config_filename, \"%s/%s\", config_directory, CONFIG_FILE);\n  config_filename = make_full_path (config_filename);\n  if (!disable_output) {\n    printf (\"I: config dir=[%s]\\n\", config_directory);\n  }\n  // printf (\"I: config file=[%s]\\n\", config_filename);\n\n  int config_file_fd;\n  //char *config_directory = get_config_directory ();\n  //char *downloads_directory = get_downloads_directory ();\n\n  if (!mkdir (config_directory, CONFIG_DIRECTORY_MODE)) {\n    if (!disable_output) {\n      printf (\"[%s] created\\n\", config_directory);\n    }\n  }\n\n  tfree_str (config_directory);\n  config_directory = NULL;\n  // see if config file is there\n  if (access (config_filename, R_OK) != 0) {\n    // config file missing, so touch it\n    config_file_fd = open (config_filename, O_CREAT | O_RDWR, 0600);\n    if (config_file_fd == -1)  {\n      perror (\"open[config_file]\");\n      printf (\"I: config_file=[%s]\\n\", config_filename);\n      exit (EXIT_FAILURE);\n    }\n    if (write (config_file_fd, DEFAULT_CONFIG_CONTENTS, strlen (DEFAULT_CONFIG_CONTENTS)) <= 0) {\n      perror (\"write[config_file]\");\n      exit (EXIT_FAILURE);\n    }\n    close (config_file_fd);\n  }\n}\n\n#ifdef HAVE_LIBCONFIG\nvoid parse_config_val (config_t *conf, char **s, char *param_name, const char *default_name, const char *path) {\n  static char buf[1000]; \n  int l = 0;\n  if (prefix) {\n    l = strlen (prefix);\n    memcpy (buf, prefix, l);\n    buf[l ++] = '.';\n  }\n  *s = 0;\n  const char *r = 0;\n  strcpy (buf + l, param_name);\n  config_lookup_string (conf, buf, &r);\n  if (r) {\n    if (path && *r != '/') {\n      tasprintf (s, \"%s/%s\", path, r);\n    } else {\n      *s = tstrdup (r);\n    }\n  } else {\n    if (path && default_name) {\n      tasprintf (s, \"%s/%s\", path, default_name);\n    } else {\n      *s  = default_name ? tstrdup (default_name) : 0;\n    }\n  }\n}\n\nvoid parse_config (void) {\n  //config_filename = make_full_path (config_filename);\n  \n  config_t conf;\n  config_init (&conf);\n  if (config_read_file (&conf, config_filename) != CONFIG_TRUE) {\n    fprintf (stderr, \"Can not read config '%s': error '%s' on the line %d\\n\", config_filename, config_error_text (&conf), config_error_line (&conf));\n    exit (2);\n  }\n\n  if (!prefix) {\n    config_lookup_string (&conf, \"default_profile\", (void *)&prefix);\n  }\n\n  static char buf[1000];\n  int l = 0;\n  if (prefix) {\n    l = strlen (prefix);\n    memcpy (buf, prefix, l);\n    buf[l ++] = '.';\n  }\n  \n  int test_mode = 0;\n  strcpy (buf + l, \"test\");\n  config_lookup_bool (&conf, buf, &test_mode);\n  if (test_mode) {\n    tgl_set_test_mode (TLS);\n  }\n  \n  strcpy (buf + l, \"log_level\");\n  long long t = log_level;\n  config_lookup_int (&conf, buf, (void *)&t);\n  log_level = t;\n  \n  if (!msg_num_mode) {\n    strcpy (buf + l, \"msg_num\");\n    config_lookup_bool (&conf, buf, &msg_num_mode);\n  }\n\n  parse_config_val (&conf, &config_directory, \"config_directory\", CONFIG_DIRECTORY, 0);\n  config_directory = make_full_path (config_directory);\n\n  parse_config_val (&conf, &auth_file_name, \"auth_file\", AUTH_KEY_FILE, config_directory);\n  parse_config_val (&conf, &downloads_directory, \"downloads\", DOWNLOADS_DIRECTORY, config_directory);\n  \n  if (!lua_file) {\n    parse_config_val (&conf, &lua_file, \"lua_script\", 0, config_directory);\n  }\n  \n  if (!python_file) {\n    parse_config_val (&conf, &python_file, \"python_script\", 0, config_directory);\n  }\n \n  #if 0\n  strcpy (buf + l, \"binlog_enabled\");\n  config_lookup_bool (&conf, buf, &binlog_enabled);\n  #else\n  binlog_enabled = 0;\n  #endif\n  \n  int pfs_enabled = 0;\n  strcpy (buf + l, \"pfs_enabled\");\n  config_lookup_bool (&conf, buf, &pfs_enabled);\n  if (pfs_enabled) {\n    tgl_enable_pfs (TLS);\n  }\n\n  if (binlog_enabled) {\n    parse_config_val (&conf, &binlog_file_name, \"binlog\", BINLOG_FILE, config_directory);\n    tgl_set_binlog_mode (TLS, 1);\n    tgl_set_binlog_path (TLS, binlog_file_name);\n  } else {\n    tgl_set_binlog_mode (TLS, 0);\n    parse_config_val (&conf, &state_file_name, \"state_file\", STATE_FILE, config_directory);\n    parse_config_val (&conf, &secret_chat_file_name, \"secret\", SECRET_CHAT_FILE, config_directory);\n    //tgl_set_auth_file_path (auth_file_name);\n  }\n  tgl_set_download_directory (TLS, downloads_directory);\n  \n  if (!mkdir (config_directory, CONFIG_DIRECTORY_MODE)) {\n    if (!disable_output) {\n      printf (\"[%s] created\\n\", config_directory);\n    }\n  }\n  if (!mkdir (downloads_directory, CONFIG_DIRECTORY_MODE)) {\n    if (!disable_output) {\n      printf (\"[%s] created\\n\", downloads_directory);\n    }\n  }\n  tfree_str (config_directory);\n  config_directory = NULL;\n  config_destroy (&conf);\n}\n#else\nvoid parse_config (void) {\n  if (!disable_output) {\n    printf (\"libconfig not enabled\\n\");\n  }\n  tasprintf (&downloads_directory, \"%s/%s/%s\", get_home_directory (), CONFIG_DIRECTORY, DOWNLOADS_DIRECTORY);\n\n  if (binlog_enabled) {\n    tasprintf (&binlog_file_name, \"%s/%s/%s\", get_home_directory (), CONFIG_DIRECTORY, BINLOG_FILE);\n    tgl_set_binlog_mode (TLS, 1);\n    tgl_set_binlog_path (TLS, binlog_file_name);\n  } else {\n    tgl_set_binlog_mode (TLS, 0);\n    //tgl_set_auth_file_path (auth_file_name;\n    tasprintf (&auth_file_name, \"%s/%s/%s\", get_home_directory (), CONFIG_DIRECTORY, AUTH_KEY_FILE);\n    tasprintf (&state_file_name, \"%s/%s/%s\", get_home_directory (), CONFIG_DIRECTORY, STATE_FILE);\n    tasprintf (&secret_chat_file_name, \"%s/%s/%s\", get_home_directory (), CONFIG_DIRECTORY, SECRET_CHAT_FILE);\n  }\n  tgl_set_download_directory (TLS, downloads_directory);\n  if (!mkdir (downloads_directory, CONFIG_DIRECTORY_MODE)) {\n    if (!disable_output) {\n      printf (\"[%s] created\\n\", downloads_directory);\n    }\n  }\n}\n#endif\n\nvoid inner_main (void) {\n  loop ();\n}\n\nvoid usage (void) {\n  printf (\"%s Usage\\n\", PROGNAME);\n    \n  printf (\"  --phone/-u                           specify username (would not be asked during authorization)\\n\");\n  printf (\"  --rsa-key/-k                         specify location of public key (possible multiple entries)\\n\");\n  printf (\"  --verbosity/-v                       increase verbosity (0-ERROR 1-WARNIN 2-NOTICE 3+-DEBUG-levels)\\n\");\n  printf (\"  --enable-msg-id/-N                   message num mode\\n\");\n  #ifdef HAVE_LIBCONFIG\n  printf (\"  --config/-c                          config file name\\n\");\n  printf (\"  --profile/-p                         use specified profile\\n\");\n  #else\n  #if 0\n  printf (\"  --enable-binlog/-B                   enable binlog\\n\");\n  #endif\n  #endif\n  printf (\"  --log-level/-l                       log level\\n\");\n  printf (\"  --sync-from-start/-f                 during authorization fetch all messages since registration\\n\");\n  printf (\"  --disable-auto-accept/-E             disable auto accept of encrypted chats\\n\");\n  #ifdef USE_LUA\n  printf (\"  --lua-script/-s                      lua script file\\n\");\n  #endif\n  printf (\"  --wait-dialog-list/-W                send dialog_list query and wait for answer before reading input\\n\");\n  printf (\"  --disable-colors/-C                  disable color output\\n\");\n  printf (\"  --disable-readline/-R                disable readline\\n\");\n  printf (\"  --alert/-A                           enable bell notifications\\n\");\n  printf (\"  --daemonize/-d                       daemon mode\\n\");\n  printf (\"  --logname/-L <log-name>              log file name\\n\");\n  printf (\"  --username/-U <user-name>            change uid after start\\n\");\n  printf (\"  --groupname/-G <group-name>          change gid after start\\n\");\n  printf (\"  --disable-output/-D                  disable output\\n\");\n  printf (\"  --tcp-port/-P <port>                 port to listen for input commands\\n\");\n  printf (\"  --udp-socket/-S <socket-name>        unix socket to create\\n\");\n  printf (\"  --exec/-e <commands>                 make commands end exit\\n\");\n  printf (\"  --disable-names/-I                   use user and chat IDs in updates instead of names\\n\");\n  printf (\"  --enable-ipv6/-6                     use ipv6 (may be unstable)\\n\");\n  printf (\"  --help/-h                            prints this help\\n\");\n  printf (\"  --accept-any-tcp                     accepts tcp connections from any src (only loopback by default)\\n\");\n  printf (\"  --disable-link-preview               disables server-side previews to links\\n\");\n  printf (\"  --bot/-b                             bot mode\\n\");  \n  #ifdef USE_JSON\n  printf (\"  --json                               prints answers and values in json format\\n\");\n  #endif\n  #ifdef USE_PYTHON\n  printf (\"  --python-script/-Z <script-name>     python script file\\n\");\n  #endif\n  printf (\"  --permanent-msg-ids                  use permanent msg ids\\n\");\n  printf (\"  --permanent-peer-ids                 use permanent peer ids\\n\");\n\n  exit (1);\n}\n\n//extern char *rsa_public_key_name;\n//extern int default_dc_num;\n\n\n\n\nchar *log_net_file;\nFILE *log_net_f;\n\nint register_mode;\nint disable_auto_accept;\nint wait_dialog_list;\n\nchar *logname;\nint daemonize=0;\n\n\nvoid reopen_logs (void) {\n  int fd;\n  fflush (stdout);\n  fflush (stderr);\n  if ((fd = open (\"/dev/null\", O_RDWR, 0)) != -1) {\n    dup2 (fd, 0);\n    dup2 (fd, 1);\n    dup2 (fd, 2);\n    if (fd > 2) {\n      close (fd);\n    }\n  }\n  if (logname && (fd = open (logname, O_WRONLY|O_APPEND|O_CREAT, 0640)) != -1) {\n    dup2 (fd, 1);\n    dup2 (fd, 2);\n    if (fd > 2) {\n      close (fd);\n    }\n  }\n}\n\n\nstatic void sigusr1_handler (const int sig) {\n  fprintf(stderr, \"got SIGUSR1, rotate logs.\\n\");\n  reopen_logs ();\n  signal (SIGUSR1, sigusr1_handler);\n}\n\nstatic void sighup_handler (const int sig) {\n  fprintf(stderr, \"got SIGHUP.\\n\");\n  signal (SIGHUP, sighup_handler);\n}\n\nchar *set_user_name;\nchar *set_group_name;\nint accept_any_tcp;\nchar *bot_hash;\n\nint change_user_group () {\n  char *username = set_user_name;\n  char *groupname = set_group_name;\n  struct passwd *pw;\n  /* lose root privileges if we have them */\n  if (getuid() == 0 || geteuid() == 0) {\n    if (username == 0 || *username == '\\0') {\n      username = \"telegramd\";\n    }\n    if ((pw = getpwnam (username)) == 0) {\n      fprintf (stderr, \"change_user_group: can't find the user %s to switch to\\n\", username);\n      return -1;\n    }\n    gid_t gid = pw->pw_gid;\n    if (setgroups (1, &gid) < 0) {\n      fprintf (stderr, \"change_user_group: failed to clear supplementary groups list: %m\\n\");\n      return -1;\n    }\n\n    if (groupname) {\n      struct group *g = getgrnam (groupname);\n      if (g == NULL) {\n        fprintf (stderr, \"change_user_group: can't find the group %s to switch to\\n\", groupname);\n        return -1;\n      }\n      gid = g->gr_gid;\n    }\n\n    if (setgid (gid) < 0) {\n      fprintf (stderr, \"change_user_group: setgid (%d) failed. %m\\n\", (int) gid);\n      return -1;\n    }\n\n    if (setuid (pw->pw_uid) < 0) {\n      fprintf (stderr, \"change_user_group: failed to assume identity of user %s\\n\", username);\n      return -1;\n    } else {\n      pw = getpwuid(getuid());\n      setenv(\"USER\", pw->pw_name, 1);\n      setenv(\"HOME\", pw->pw_dir, 1);\n      setenv(\"SHELL\", pw->pw_shell, 1);\n    }\n  }\n  return 0;\n}\n\nchar *unix_socket;\n\nvoid args_parse (int argc, char **argv) {\n  TLS = tgl_state_alloc ();\n\n  static struct option long_options[] = {\n    {\"debug-allocator\", no_argument, 0,  1000 },\n    {\"phone\", required_argument, 0, 'u'}, \n    {\"rsa-key\", required_argument, 0, 'k'},\n    {\"verbosity\", no_argument, 0, 'v'},\n    {\"enable-msg-id\", no_argument, 0, 'N'},\n#ifdef HAVE_LIBCONFIG\n    {\"config\", required_argument, 0, 'c'},\n    {\"profile\", required_argument, 0, 'p'},\n#else\n    #if 0\n    {\"enable-binlog\", no_argument, 0, 'B'},\n    #endif\n#endif\n    {\"log-level\", required_argument, 0, 'l'},\n    {\"sync-from-start\", no_argument, 0, 'f'},\n    {\"disable-auto-accept\", no_argument, 0, 'E'},\n    {\"allow-weak-random\", no_argument, 0, 'w'},\n#ifdef USE_LUA\n    {\"lua-script\", required_argument, 0, 's'},\n#endif\n    {\"wait-dialog-list\", no_argument, 0, 'W'},\n    {\"disable-colors\", no_argument, 0, 'C'},\n    {\"disable-readline\", no_argument, 0, 'R'},\n    {\"alert\", no_argument, 0, 'A'},\n    {\"daemonize\", no_argument, 0, 'd'},\n    {\"logname\", required_argument, 0, 'L'},\n    {\"username\", required_argument, 0, 'U'},\n    {\"groupname\", required_argument, 0, 'G'},\n    {\"disable-output\", no_argument, 0, 'D'},\n    {\"reset-authorization\", no_argument, 0, 'q'},\n    {\"tcp-port\", required_argument, 0, 'P'},\n    {\"unix-socket\", required_argument, 0, 'S'},\n    {\"exec\", required_argument, 0, 'e'},\n    {\"disable-names\", no_argument, 0, 'I'},\n    {\"enable-ipv6\", no_argument, 0, '6'},\n    {\"bot\", optional_argument, 0, 'b'},\n    {\"help\", no_argument, 0, 'h'},\n    {\"accept-any-tcp\", no_argument, 0,  1001},\n    {\"disable-link-preview\", no_argument, 0, 1002},\n    {\"json\", no_argument, 0, 1003},\n    {\"python-script\", required_argument, 0, 'Z'},\n    {\"permanent-msg-ids\", no_argument, 0, 1004},\n    {\"permanent-peer-ids\", no_argument, 0, 1005},\n    {0,         0,                 0,  0 }\n  };\n\n\n\n  int opt = 0;\n  while ((opt = getopt_long (argc, argv, \"u:hk:vNl:fEwWCRAdL:DU:G:qP:S:e:I6b\"\n#ifdef HAVE_LIBCONFIG\n  \"c:p:\"\n#else\n  #if 0\n  \"B\"\n  #endif\n#endif\n#ifdef USE_LUA\n  \"s:\"\n#endif\n#ifdef USE_PYTHON\n  \"Z:\"\n#endif\n  , long_options, NULL\n  \n  )) != -1) {\n    switch (opt) {\n    case 'b':\n      bot_mode ++;\n      if (optarg) {\n        bot_hash = optarg;\n      }\n      break;\n    case 1000:\n      tgl_allocator = &tgl_allocator_debug;\n      break;\n    case 1001:\n      accept_any_tcp = 1;\n      break;\n    case 'u':\n      set_default_username (optarg);\n      break;\n    case 'k':\n      //rsa_public_key_name = tstrdup (optarg);\n      tgl_set_rsa_key (TLS, optarg);\n      break;\n    case 'v':\n      tgl_incr_verbosity (TLS);\n      verbosity ++;\n      break;\n    case 'N':\n      msg_num_mode ++;\n      break;\n#ifdef HAVE_LIBCONFIG\n    case 'c':\n      config_filename = tstrdup (optarg);\n      break;\n    case 'p':\n      prefix = optarg;\n      assert (strlen (prefix) <= 100);\n      break;\n#else\n    #if 0\n    case 'B':\n      binlog_enabled = 1;\n      break;\n    #endif\n#endif\n    case 'l':\n      log_level = atoi (optarg);\n      break;\n    case 'f':\n      sync_from_start = 1;\n      break;\n    case 'E':\n      disable_auto_accept = 1;\n      break;\n    case 'w':\n      allow_weak_random = 1;\n      break;\n#ifdef USE_LUA\n    case 's':\n      lua_file = strdup (optarg);\n      break;\n#endif\n    case 'W':\n      wait_dialog_list = 1;\n      break;\n#ifdef USE_PYTHON\n    case 'Z':\n      python_file = strdup (optarg);\n      break;\n#endif\n    case 'C':\n      disable_colors ++;\n      break;\n    case 'R':\n      readline_disabled ++;\n      break;\n    case 'A':\n      alert_sound = 1;\n      break;\n    case 'd':\n      daemonize ++;\n      break;\n    case 'L':\n      logname = optarg;\n      break;\n    case 'U':\n      set_user_name = optarg;\n      break;\n    case 'G':\n      set_group_name = optarg;\n      break;\n    case 'D':\n      disable_output ++;\n      break;\n    case 'q':\n      reset_authorization ++;\n      break;\n    case 'P':\n      port = atoi (optarg);\n      break;\n    case 'S':\n      unix_socket = optarg;\n      break;\n    case 'e':\n      start_command = optarg;\n      break;\n    case 'I':\n      use_ids ++;\n      break;\n    case '6':\n      ipv6_enabled = 1;\n      break;\n    case 1002:\n      disable_link_preview = 2;\n      break;\n    case 1003:\n      enable_json = 1;\n      break;\n    case 1004:\n      permanent_msg_id_mode = 1;\n      break;\n    case 1005:\n      permanent_peer_id_mode = 1;\n      break;\n    case 'h':\n    default:\n      usage ();\n      break;\n    }\n  }\n}\n\n#ifdef HAVE_EXECINFO_H\nvoid print_backtrace (void) {\n  void *buffer[255];\n  const int calls = backtrace (buffer, sizeof (buffer) / sizeof (void *));\n  backtrace_symbols_fd (buffer, calls, 1);\n}\n#else\nvoid print_backtrace (void) {\n  if (write (1, \"No libexec. Backtrace disabled\\n\", 32) < 0) {\n    // Sad thing\n  }\n}\n#endif\n\nint sfd;\nint usfd;\n\nvoid termination_signal_handler (int signum) {\n  if (!readline_disabled) {\n    rl_free_line_state ();\n    rl_cleanup_after_signal ();\n  }\n  \n  if (write (1, \"SIGNAL received\\n\", 18) < 0) { \n    // Sad thing\n  }\n \n  if (unix_socket) {\n    unlink (unix_socket);\n  }\n  \n  if (usfd > 0) {\n    close (usfd);\n  }\n  if (sfd > 0) {\n    close (sfd);\n  }\n  print_backtrace ();\n  \n  exit (EXIT_FAILURE);\n}\n\nvolatile int sigterm_cnt;\n\nvoid sig_term_handler (int signum __attribute__ ((unused))) {\n  signal (signum, termination_signal_handler);\n  //set_terminal_attributes ();\n  if (write (1, \"SIGTERM/SIGINT received\\n\", 25) < 0) { \n    // Sad thing\n  }\n  //if (TLS && TLS->ev_base) {\n  //  event_base_loopbreak (TLS->ev_base);\n  //}\n  sigterm_cnt ++;\n}\n\nvoid do_halt (int error) {\n  int retval;\n  if (daemonize) {\n    return;\n  }\n\n  if (!readline_disabled) {\n    rl_free_line_state ();\n    rl_cleanup_after_signal ();\n  }\n\n  if (write (1, \"halt\\n\", 5) < 0) { \n    // Sad thing\n  }\n \n  if (unix_socket) {\n    unlink (unix_socket);\n  }\n  \n  if (usfd > 0) {\n    close (usfd);\n  }\n  if (sfd > 0) {\n    close (sfd);\n  }\n \n  if (exit_code) {\n    retval = exit_code;\n  } else {\n    retval = error ? EXIT_FAILURE : EXIT_SUCCESS;\n  }\n\n  exit (retval);\n}\n\nint main (int argc, char **argv) {\n  signal (SIGSEGV, termination_signal_handler);\n  signal (SIGABRT, termination_signal_handler);\n  signal (SIGBUS, termination_signal_handler);\n  signal (SIGQUIT, termination_signal_handler);\n  signal (SIGFPE, termination_signal_handler);\n\n  signal (SIGPIPE, SIG_IGN);\n  \n  signal (SIGTERM, sig_term_handler);\n  signal (SIGINT, sig_term_handler);\n\n  rl_catch_signals = 0;\n\n\n  log_level = 10;\n  \n  args_parse (argc, argv);\n  \n  change_user_group ();\n\n  if (port > 0) {\n    struct sockaddr_in serv_addr;\n    int yes = 1;\n    sfd = socket (AF_INET, SOCK_STREAM, 0);\n    if (sfd < 0) {\n      perror (\"socket\");\n      exit(1);\n    }\n\n    if(setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) < 0) {\n      perror(\"setsockopt\");\n      exit(1);\n    }\n    memset (&serv_addr, 0, sizeof (serv_addr));\n    \n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_addr.s_addr = accept_any_tcp ? INADDR_ANY : htonl (0x7f000001);\n    serv_addr.sin_port = htons (port);\n \n    if (bind (sfd, (struct sockaddr *) &serv_addr, sizeof (serv_addr)) < 0) {\n      perror (\"bind\");\n      exit(1);\n    }\n\n    listen (sfd, 5);\n  } else {\n    sfd = -1;\n  }\n  \n  if (unix_socket) {\n    assert (strlen (unix_socket) < 100);\n    struct sockaddr_un serv_addr;\n\n    usfd = socket (AF_UNIX, SOCK_STREAM, 0);\n    if (usfd < 0) {\n      perror (\"socket\");\n      exit(1);\n    }\n\n    memset (&serv_addr, 0, sizeof (serv_addr));\n    \n    serv_addr.sun_family = AF_UNIX;\n\n    snprintf (serv_addr.sun_path, sizeof(serv_addr.sun_path), \"%s\", unix_socket);\n \n    if (bind (usfd, (struct sockaddr *) &serv_addr, sizeof (serv_addr)) < 0) {\n      perror (\"bind\");\n      exit(1);\n    }\n\n    listen (usfd, 5);    \n  } else {\n    usfd = -1;\n  }\n\n  if (daemonize) {\n    signal (SIGHUP, sighup_handler);\n    reopen_logs ();\n  }\n  signal (SIGUSR1, sigusr1_handler);\n\n  if (!disable_output) {\n    printf (\n      \"Telegram-cli version \" TELEGRAM_CLI_VERSION \", Copyright (C) 2013-2015 Vitaly Valtman\\n\"\n      \"Telegram-cli comes with ABSOLUTELY NO WARRANTY; for details type `show_license'.\\n\"\n      \"This is free software, and you are welcome to redistribute it\\n\"\n      \"under certain conditions; type `show_license' for details.\\n\"\n      \"Telegram-cli uses libtgl version \" TGL_VERSION \"\\n\"\n#ifndef TGL_AVOID_OPENSSL \n      \"Telegram-cli includes software developed by the OpenSSL Project\\n\"\n      \"for use in the OpenSSL Toolkit. (http://www.openssl.org/)\\n\"\n#endif\n#ifdef USE_PYTHON\n      \"Telegram-cli uses libpython version \" PY_VERSION \"\\n\"\n#endif\n    );\n  }\n  running_for_first_time ();\n  parse_config ();\n\n  #ifdef __FreeBSD__\n  tgl_set_rsa_key (TLS, \"/usr/local/etc/\" PROG_NAME \"/server.pub\");\n  #else\n  tgl_set_rsa_key (TLS, \"/etc/\" PROG_NAME \"/server.pub\");\n  #endif\n  tgl_set_rsa_key (TLS, \"tg-server.pub\");\n\n  tgl_set_rsa_key_direct (TLS, tglmp_get_default_e (), tglmp_get_default_key_len (), tglmp_get_default_key ());\n\n  get_terminal_attributes ();\n\n  #ifdef USE_LUA\n  if (lua_file) {\n    lua_init (lua_file);\n  }\n  #endif\n  #ifdef USE_PYTHON\n  if (python_file) {\n    py_init (python_file);\n  }\n  #endif\n\n\n  inner_main ();\n  \n  return 0;\n}\n"
        },
        {
          "name": "mime.types",
          "type": "blob",
          "size": 0.013671875,
          "content": "tgl/mime.types"
        },
        {
          "name": "python-tg.c",
          "type": "blob",
          "size": 43.73828125,
          "content": "/*\n    This file is part of telegram-cli.\n\n    Telegram-cli is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n\n    Telegram-cli is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this telegram-cli.  If not, see <http://www.gnu.org/licenses/>.\n\n    Copyright Vitaly Valtman 2013-2015\n    Copyright Vincent Castellano 2015\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef USE_PYTHON\n#include \"python-tg.h\"\n\n#include <string.h>\n#include <stdlib.h>\n#include <libgen.h>\n\n#include <Python.h>\n#include \"bytesobject.h\"\n\n// Python 2/3 compat macros\n#if PY_MAJOR_VERSION >= 3\n  #define MOD_ERROR_VAL NULL\n  #define MOD_SUCCESS_VAL(val) val\n  #define MOD_INIT(name) PyMODINIT_FUNC PyInit_##name(void)\n  #define MOD_DEF(ob, name, doc, methods) \\\n          static struct PyModuleDef moduledef = { \\\n          PyModuleDef_HEAD_INIT, name, doc, -1, methods, NULL, NULL, NULL, NULL,}; \\\n          ob = PyModule_Create(&moduledef);\n  #define PyInt_FromLong PyLong_FromLong\n#else\n  #define MOD_ERROR_VAL\n  #define MOD_SUCCESS_VAL(val)\n  #define MOD_INIT(name) void init##name(void)\n  #define MOD_DEF(ob, name, doc, methods) \\\n          ob = Py_InitModule3(name, methods, doc);\n#endif\n\n#define TGL_PYTHON_CALLBACK(name, func) \\\n      PyObject *set##func(PyObject *dummy, PyObject *args) { \\\n      PyObject *result = NULL; \\\n      PyObject *temp; \\\n      if (PyArg_ParseTuple(args, \"O:set_##name\", &temp)) { \\\n        if (!PyCallable_Check(temp)) { \\\n          PyErr_SetString(PyExc_TypeError, \"parameter must be callable\");\\\n          return NULL;\\\n        }\\\n        Py_XINCREF(temp);\\\n        Py_XDECREF(func);\\\n        func = temp;\\\n        Py_INCREF(Py_None);\\\n        result = Py_None;\\\n        }\\\n        return result;\\\n      }\n\n\n// Python Imports\n#include \"datetime.h\"\n\n// Custom Types\n#include \"python-types.h\"\n\n\nextern PyTypeObject tgl_PeerType;\nextern PyTypeObject tgl_MsgType;\n\n//#include \"interface.h\"\n//#include \"auto/constants.h\"\n#include <tgl/tgl.h>\n#include \"interface.h\"\n\n#include <assert.h>\nextern int verbosity;\nextern struct tgl_state *TLS;\n\n\nstatic int python_loaded;\n\n// TGL Python Exceptions\nPyObject *TglError;\nPyObject *PeerError;\nPyObject *MsgError;\n\n\n// Python update function callables\nPyObject *_py_binlog_end;\nPyObject *_py_diff_end;\nPyObject *_py_our_id;\nPyObject *_py_new_msg;\nPyObject *_py_secret_chat_update;\nPyObject *_py_user_update;\nPyObject *_py_chat_update;\nPyObject *_py_on_loop;\n\nPyObject* get_peer (tgl_peer_id_t id, tgl_peer_t *P);\n\nvoid py_add_string_field (PyObject* dict, char *name, const char *value) {\n  assert (PyDict_Check(dict));\n  assert (name && strlen (name));\n  if (!value || !strlen (value)) { return; }\n  PyObject *str = PyUnicode_FromString(value);\n\n  if(PyUnicode_Check(str))\n    PyDict_SetItemString (dict, name, str);\n}\n\nvoid py_add_string_field_arr (PyObject* list, int num, const char *value) {\n  assert(PyList_Check(list));\n  if (!value || !strlen (value)) { return; }\n  if(num >= 0)\n    PyList_SetItem (list, num, PyUnicode_FromString (value));\n  else // Append\n    PyList_Append  (list, PyUnicode_FromString (value));\n}\n\nvoid py_add_num_field (PyObject* dict, const char *name, double value) {\n  assert (PyDict_Check(dict));\n  assert (name && strlen (name));\n  PyDict_SetItemString (dict, name, PyFloat_FromDouble(value));\n}\n\nPyObject* get_tgl_peer_type (int x) {\n  PyObject *type;\n\n  switch (x) {\n  case TGL_PEER_USER:\n    type = PyUnicode_FromString(\"user\");\n    break;\n  case TGL_PEER_CHAT:\n    type = PyUnicode_FromString(\"chat\");\n    break;\n  case TGL_PEER_ENCR_CHAT:\n    type = PyUnicode_FromString(\"encr_chat\");\n    break;\n  default:\n    assert (0);\n  }\n\n  return type;\n}\n\nPyObject* get_update_types (unsigned flags) {\n  PyObject* types;\n  types = PyList_New(0); \n  if(types == NULL)\n    assert(0); // TODO handle python exception\n  \n  if (flags & TGL_UPDATE_CREATED) {\n    py_add_string_field_arr(types, -1, \"created\");\n  }  \n  if (flags & TGL_UPDATE_DELETED) {\n    py_add_string_field_arr(types, -1, \"deleted\");\n  }  \n  if (flags & TGL_UPDATE_PHONE) {\n    py_add_string_field_arr(types, -1, \"phone\");\n  }\n  if (flags & TGL_UPDATE_CONTACT) {\n    py_add_string_field_arr(types, -1, \"contact\");\n  }\n  if (flags & TGL_UPDATE_PHOTO) {\n    py_add_string_field_arr(types, -1, \"photo\");\n  }\n  if (flags & TGL_UPDATE_BLOCKED) {\n    py_add_string_field_arr(types, -1, \"blocked\");\n  }\n  if (flags & TGL_UPDATE_REAL_NAME) {\n    py_add_string_field_arr(types, -1, \"real_name\");\n  }\n  if (flags & TGL_UPDATE_NAME) {\n    py_add_string_field_arr(types, -1, \"name\");\n  }\n  if (flags & TGL_UPDATE_REQUESTED) {\n    py_add_string_field_arr(types, -1, \"requested\");\n  }\n  if (flags & TGL_UPDATE_WORKING) {\n    py_add_string_field_arr(types, -1, \"working\");\n  }\n  if (flags & TGL_UPDATE_FLAGS) {\n    py_add_string_field_arr(types, -1, \"flags\");\n  }\n  if (flags & TGL_UPDATE_TITLE) {\n    py_add_string_field_arr(types, -1, \"title\");\n  }\n  if (flags & TGL_UPDATE_ADMIN) {\n    py_add_string_field_arr(types, -1, \"admin\");\n  }\n  if (flags & TGL_UPDATE_MEMBERS) {\n    py_add_string_field_arr(types, -1, \"members\");\n  }\n  if (flags & TGL_UPDATE_ACCESS_HASH) {\n    py_add_string_field_arr(types, -1, \"access_hash\");\n  }\n  if (flags & TGL_UPDATE_USERNAME) {\n    py_add_string_field_arr(types, -1, \"username\");\n  }\n  return types;\n}\n\nPyObject* get_peer (tgl_peer_id_t id, tgl_peer_t *P) {\n  PyObject *peer;\n\n  peer = tgl_Peer_FromTglPeer(P);\n  return peer;\n}\n\nPyObject* get_message (struct tgl_message *M) {  \n  assert (M);\n  PyObject *msg;\n  \n  msg = tgl_Msg_FromTglMsg(M);\n  return msg;\n}\n\nvoid py_binlog_end (void) {\n  if (!python_loaded) { return; }\n\n  PyObject *arglist, *result;\n\n  if(_py_binlog_end == NULL) {\n    logprintf(\"Callback not set for on_binlog_end\");\n    return;\n  }\n \n  arglist = Py_BuildValue(\"()\");\n  result = PyEval_CallObject(_py_binlog_end, arglist);\n  Py_DECREF(arglist);\n  \n  if(result == NULL)\n    PyErr_Print();\n  else if(PyUnicode_Check(result))\n    logprintf (\"python: %s\\n\", PyBytes_AsString(PyUnicode_AsASCIIString(result)));\n\n  Py_XDECREF(result);\n}\n\nvoid py_diff_end (void) {\n  if (!python_loaded) { return; }\n\n  PyObject *arglist, *result;\n\n  if(_py_diff_end == NULL) {\n    logprintf(\"Callback not set for on_diff_end\");\n    return;\n  }\n \n  arglist = Py_BuildValue(\"()\");\n  result = PyEval_CallObject(_py_diff_end, arglist);\n  Py_DECREF(arglist);\n  if(result == NULL)\n    PyErr_Print();\n  else if(PyUnicode_Check(result))\n    logprintf (\"python: %s\\n\", PyBytes_AsString(PyUnicode_AsASCIIString(result)));\n\n  Py_XDECREF(result);\n}\n\nvoid py_our_id (int id) {\n  if (!python_loaded) { return; }\n\n  PyObject *arglist, *result;\n\n  if(_py_our_id == NULL) {\n    logprintf(\"Callback not set for on_our_id\");\n    return;\n  }\n\n  arglist = Py_BuildValue(\"(i)\", id);\n  result = PyEval_CallObject(_py_our_id, arglist);\n  Py_DECREF(arglist);\n  if(result == NULL)\n    PyErr_Print();\n  else if(PyUnicode_Check(result))\n    logprintf (\"python: %s\\n\", PyBytes_AsString(PyUnicode_AsASCIIString(result)));\n\n  Py_XDECREF(result);\n}\n\nvoid py_new_msg (struct tgl_message *M) {\n  if (!python_loaded) { return; }\n  PyObject *msg;\n  PyObject *arglist, *result;\n\n  if(_py_new_msg == NULL) {\n    logprintf(\"Callback not set for on_new_msg\");\n    return;\n  }\n\n  msg = get_message (M);\n\n  arglist = Py_BuildValue(\"(O)\", msg);\n  result = PyEval_CallObject(_py_new_msg, arglist);\n  Py_DECREF(arglist);\n\n  if(result == NULL)  \n    PyErr_Print();\n  else if(PyUnicode_Check(result))\n    logprintf (\"python: %s\\n\", PyBytes_AsString(PyUnicode_AsASCIIString(result)));\n\n  Py_XDECREF(result);\n}\n\nvoid py_secret_chat_update (struct tgl_secret_chat *C, unsigned flags) {\n  if (!python_loaded) { return; }\n  PyObject *peer, *types;\n  PyObject *arglist, *result; \n\n  if(_py_secret_chat_update == NULL) {\n    logprintf(\"Callback not set for on_secret_chat_update\");\n    return;\n  }\n\n  peer = get_peer (C->id, (void *)C);\n  types = get_update_types (flags);\n\n  arglist = Py_BuildValue(\"(OO)\", peer, types);\n  result = PyEval_CallObject(_py_secret_chat_update, arglist);\n  Py_DECREF(arglist);\n\n  if(result == NULL)\n    PyErr_Print();\n  else if(PyUnicode_Check(result))\n    logprintf (\"python: %s\\n\", PyBytes_AsString(PyUnicode_AsASCIIString(result)));\n\n  Py_XDECREF(result);\n}\n\n\nvoid py_user_update (struct tgl_user *U, unsigned flags) {\n  if (!python_loaded) { return; }\n  PyObject *peer, *types;\n  PyObject *arglist, *result;\n\n  if(_py_user_update == NULL) {\n    logprintf(\"Callback not set for on_user_update\");\n    return;\n  }\n\n  peer = get_peer (U->id, (void *)U);\n  types = get_update_types (flags);\n\n  arglist = Py_BuildValue(\"(OO)\", peer, types);\n  result = PyEval_CallObject(_py_user_update, arglist);\n  Py_DECREF(arglist);\n\n  if(result == NULL)\n    PyErr_Print();\n  else if(PyUnicode_Check(result))\n    logprintf (\"python: %s\\n\", PyBytes_AsString(PyUnicode_AsASCIIString(result)));\n\n  Py_XDECREF(result);\n}\n\nvoid py_chat_update (struct tgl_chat *C, unsigned flags) {\n  if (!python_loaded) { return; }\n\n  PyObject *peer, *types;\n  PyObject *arglist, *result;\n\n  if(_py_chat_update == NULL) {\n    logprintf(\"Callback not set for on_chat_update\");\n    return;\n  }\n\n  peer = get_peer (C->id, (void *)C);\n  types = get_update_types (flags);\n\n  arglist = Py_BuildValue(\"(OO)\", peer, types);\n  result = PyEval_CallObject(_py_chat_update, arglist);\n  Py_DECREF(arglist);\n\n  if(result == NULL)\n    PyErr_Print();\n  else if(PyUnicode_Check(result))\n    logprintf (\"python: %s\\n\", PyBytes_AsString(PyUnicode_AsASCIIString(result)));\n\n  Py_XDECREF(result);\n}\n\nvoid py_on_loop () {\n  if (!python_loaded) { return; }\n\n  PyObject *result;\n\n  if(_py_on_loop == NULL) {\n    logprintf(\"Callback not set for on_chat_update\");\n    return;\n  }\n\n  result = PyEval_CallObject(_py_on_loop, Py_BuildValue(\"()\"));\n\n  if(result == NULL)\n    PyErr_Print();\n  else if(PyUnicode_Check(result))\n    logprintf (\"python: %s\\n\", PyBytes_AsString(PyUnicode_AsASCIIString(result)));\n\n  Py_XDECREF(result);\n}\n\n\n////extern tgl_peer_t *Peers[];\n////extern int peer_num;\n//\n#define MAX_PY_COMMANDS 1000\nvoid *py_ptr[MAX_PY_COMMANDS];\nstatic int pos;\n//\n//static inline tgl_peer_t *get_peer (const char *s) { \n//  return tgl_peer_get_by_name (TLS, s);\n//}\n  \nenum py_query_type {\n  pq_contact_list,\n  pq_dialog_list,\n  pq_msg,\n  pq_send_typing,\n  pq_send_typing_abort,\n  pq_rename_chat,\n  pq_send_photo,\n  pq_chat_set_photo,\n  pq_set_profile_photo,\n  pq_set_profile_name,\n  pq_send_video,\n  pq_send_text,\n  pq_fwd,\n  pq_fwd_media,\n  pq_load_photo,\n  pq_load_video_thumb,\n  pq_load_video,\n  pq_chat_info,\n  pq_user_info,\n  pq_history,\n  pq_chat_add_user,\n  pq_chat_del_user,\n  pq_add_contact,\n  pq_del_contact,\n  pq_rename_contact,\n  pq_search,\n  pq_global_search,\n  pq_mark_read,\n  pq_create_secret_chat,\n  pq_create_group_chat,\n  pq_send_audio,\n  pq_send_document,\n  pq_send_file,\n  pq_load_audio,\n  pq_load_document,\n  pq_load_document_thumb,\n  pq_delete_msg,\n  pq_restore_msg,\n  pq_accept_secret_chat,\n  pq_send_contact,\n  pq_status_online,\n  pq_status_offline,\n  pq_send_location,\n  pq_extf,\n  pq_import_chat_link\n};\n\nvoid py_empty_cb (struct tgl_state *TLSR, void *cb_extra, int success) {\n  assert (TLSR == TLS);\n  PyObject *callable = cb_extra;\n  PyObject *arglist = NULL;\n  PyObject *result = NULL;\n\n  if(PyCallable_Check(callable)) {\n    arglist = Py_BuildValue(\"(O)\", success ? Py_True : Py_False);\n    result = PyEval_CallObject(callable, arglist);\n    Py_DECREF(arglist);\n    \n    if(result == NULL)\n      PyErr_Print();\n    \n    Py_XDECREF(result);\n  }\n  \n  Py_XDECREF(callable);\n}\n\nvoid py_contact_list_cb (struct tgl_state *TLSR, void *cb_extra, int success, int num, struct tgl_user **UL) {\n  assert (TLSR == TLS);\n  PyObject *callable = cb_extra;\n  PyObject *arglist = NULL;\n  PyObject *peers = NULL; \n  PyObject *result = NULL;\n   \n  if(PyCallable_Check(callable)) {\n    peers = PyList_New(0);\n    if (success) {\n      int i;\n      for (i = 0; i < num; i++) {\n        PyList_Append(peers, get_peer (UL[i]->id, (void *)UL[i]));\n      }\n    }\n\n    arglist = Py_BuildValue(\"(OO)\", success ? Py_True : Py_False, peers);\n    result = PyEval_CallObject(callable, arglist);\n    Py_DECREF(arglist);\n    \n    if(result == NULL)\n      PyErr_Print();\n    \n    Py_XDECREF(result);\n  }\n\n  Py_XDECREF(callable);\n}\n\nvoid py_dialog_list_cb (struct tgl_state *TLSR, void *cb_extra, int success, int num, tgl_peer_id_t peers[], int msgs[], int unread[]) {\n  assert (TLSR == TLS);\n  PyObject *callable = cb_extra;\n  PyObject *arglist = NULL;\n  PyObject *dialog_list = NULL; \n  PyObject *dialog = NULL;\n  PyObject *result = NULL;\n   \n  if(PyCallable_Check(callable)) {\n    dialog_list = PyList_New(0);\n    if (success) {\n      int i;\n      for (i = 0; i < num; i++) {\n        dialog = PyDict_New();\n        PyDict_SetItemString(dialog, \"peer\", get_peer(peers[i], tgl_peer_get (TLS, peers[i])));\n                \n        struct tgl_message *M = tgl_message_get (TLS, msgs[i]);\n        if (M && (M->flags & TGLMF_CREATED)) {\n          PyDict_SetItemString(dialog, \"message\", get_message(M));\n        }\n        PyDict_SetItemString(dialog, \"unread\", unread[i] ? Py_True : Py_False);\n\n        PyList_Append(dialog_list, dialog);\n      }\n    }\n\n    arglist = Py_BuildValue(\"(OO)\", success ? Py_True : Py_False, dialog_list);\n    result = PyEval_CallObject(callable, arglist);\n    Py_DECREF(arglist);\n    \n    if(result == NULL)\n      PyErr_Print();\n    \n    Py_XDECREF(result);\n  }\n\n  Py_XDECREF(callable);\n}\n\nvoid py_msg_cb (struct tgl_state *TLSR, void *cb_extra, int success, struct tgl_message *M) {\n  assert (TLSR == TLS);\n  PyObject *callable = cb_extra;\n  PyObject *arglist = NULL;\n  PyObject *msg = NULL; \n  PyObject *result = NULL;\n   \n  if(PyCallable_Check(callable)) {\n    if (success && M && (M->flags & TGLMF_CREATED)) {\n      msg = get_message(M);\n    } else {\n      Py_INCREF(Py_None);\n      msg = Py_None;\n    }\n\n    arglist = Py_BuildValue(\"(OO)\", success ? Py_True : Py_False, msg);\n    result = PyEval_CallObject(callable, arglist);\n    Py_DECREF(arglist);\n    \n    if(result == NULL)\n      PyErr_Print();\n    \n    Py_XDECREF(result);\n  }\n\n  Py_XDECREF(callable);\n}\n\nvoid py_msg_list_cb (struct tgl_state *TLSR, void *cb_extra, int success, int num, struct tgl_message *M[]) {\n  assert (TLSR == TLS);\n  PyObject *callable = cb_extra;\n  PyObject *arglist = NULL;\n  PyObject *msgs = NULL; \n  PyObject *result = NULL;\n   \n  if(PyCallable_Check(callable)) {\n    msgs = PyList_New(0);\n    if (success) {\n      int i;\n      for (i = 0; i < num; i++) {\n        PyList_Append(msgs, get_message (M[i]));\n      }\n    }\n\n    arglist = Py_BuildValue(\"(OO)\", success ? Py_True : Py_False, msgs);\n    result = PyEval_CallObject(callable, arglist);\n    Py_DECREF(arglist);\n    \n    if(result == NULL)\n      PyErr_Print();\n    \n    Py_XDECREF(result);\n  }\n\n  Py_XDECREF(callable);\n}\n\nvoid py_file_cb (struct tgl_state *TLSR, void *cb_extra, int success, const char *file_name) {\n  assert (TLSR == TLS);\n  PyObject *callable = cb_extra;\n  PyObject *arglist = NULL;\n  PyObject *filename = NULL; \n  PyObject *result = NULL;\n   \n  if(PyCallable_Check(callable)) {\n    if(success)\n      filename = PyUnicode_FromString(file_name);\n    else {\n      Py_INCREF(Py_None);\n      filename = Py_None;\n    }\n\n    arglist = Py_BuildValue(\"(OO)\", success ? Py_True : Py_False, filename);\n    result = PyEval_CallObject(callable, arglist);\n    Py_DECREF(arglist);\n    \n    if(result == NULL)\n      PyErr_Print();\n    \n    Py_XDECREF(result);\n  }\n\n  Py_XDECREF(callable);\n}\n\nvoid py_chat_cb (struct tgl_state *TLSR, void *cb_extra, int success, struct tgl_chat *C) {\n  assert (TLSR == TLS);\n  PyObject *callable = cb_extra;\n  PyObject *arglist = NULL;\n  PyObject *peer = NULL; \n  PyObject *result = NULL;\n   \n  if(PyCallable_Check(callable)) {\n    if (success) {\n      peer = get_peer(C->id, (void *)C);\n    } else {\n      Py_INCREF(Py_None);\n      peer = Py_None;\n    }\n\n    arglist = Py_BuildValue(\"(OO)\", success ? Py_True : Py_False, peer);\n    result = PyEval_CallObject(callable, arglist);\n    Py_DECREF(arglist);\n    \n    if(result == NULL)\n      PyErr_Print();\n    \n    Py_XDECREF(result);\n  }\n\n  Py_XDECREF(callable);\n}\n\nvoid py_secret_chat_cb (struct tgl_state *TLSR, void *cb_extra, int success, struct tgl_secret_chat *C) {\n  assert (TLSR == TLS);\n  PyObject *callable = cb_extra;\n  PyObject *arglist = NULL;\n  PyObject *peer = NULL; \n  PyObject *result = NULL;\n   \n  if(PyCallable_Check(callable)) {\n    if (success) {\n      peer = get_peer(C->id, (void *)C);\n    } else {\n      Py_INCREF(Py_None);\n      peer = Py_None;\n    }\n\n    arglist = Py_BuildValue(\"(OO)\", success ? Py_True : Py_False, peer);\n    result = PyEval_CallObject(callable, arglist);\n    Py_DECREF(arglist);\n    \n    if(result == NULL)\n      PyErr_Print();\n    \n    Py_XDECREF(result);\n  }\n\n  Py_XDECREF(callable);\n}\n\nvoid py_user_cb (struct tgl_state *TLSR, void *cb_extra, int success, struct tgl_user *C) {\n  assert (TLSR == TLS);\n  PyObject *callable = cb_extra;\n  PyObject *arglist = NULL;\n  PyObject *peer = NULL; \n  PyObject *result = NULL;\n   \n  if(PyCallable_Check(callable)) {\n    if (success) {\n      peer = get_peer(C->id, (void *)C);\n    } else {\n      Py_INCREF(Py_None);\n      peer = Py_None;\n    }\n\n    arglist = Py_BuildValue(\"(OO)\", success ? Py_True : Py_False, peer);\n    result = PyEval_CallObject(callable, arglist);\n    Py_DECREF(arglist);\n    \n    if(result == NULL)\n      PyErr_Print();\n    \n    Py_XDECREF(result);\n  }\n\n  Py_XDECREF(callable);\n}\n\nvoid py_str_cb (struct tgl_state *TLSR, void *cb_extra, int success, const char *data) {\n  assert (TLSR == TLS);\n  PyObject *callable = cb_extra;\n  PyObject *arglist = NULL;\n  PyObject *str = NULL; \n  PyObject *result = NULL;\n   \n  if(PyCallable_Check(callable)) {\n    if(success)\n      str = PyUnicode_FromString(data);\n    else {\n      Py_INCREF(Py_None);\n      str = Py_None;\n    }\n\n    arglist = Py_BuildValue(\"(OO)\", success ? Py_True : Py_False, str);\n    result = PyEval_CallObject(callable, arglist);\n    Py_DECREF(arglist);\n    \n    if(result == NULL)\n      PyErr_Print();\n    \n    Py_XDECREF(result);\n  }\n\n  Py_XDECREF(callable);\n}\n\n#define PY_PEER_ID(x) (tgl_peer_id_t)((tgl_Peer*)x)->peer->id\n\nvoid py_do_all (void) {\n  int p = 0;\n\n  // ping the python thread that we're doing the loop\n  py_on_loop();\n\n  while (p < pos) {\n    assert (p + 2 <= pos);\n\n    enum py_query_type f = (long)py_ptr[p ++];\n    PyObject *args = (PyObject *)py_ptr[p ++];\n\n    const char *str, *str1, *str2, *str3;\n\n    int preview = 0;\n    int reply_id = 0;\n    unsigned long long flags = 0;\n\n    Py_ssize_t i;\n    tgl_user_id_t *ids;\n\n    struct tgl_message *M;\n\n    int len, len1, len2, len3;\n    int limit, offset;\n    long msg_id = 0;\n\n    PyObject *pyObj1 = NULL;\n    PyObject *pyObj2 = NULL;\n    PyObject *cb_extra = NULL;\n\n    PyObject *msg = NULL;\n    PyObject *peer = NULL;\n    PyObject *peer1 = NULL;\n\n    switch (f) {\n    case pq_contact_list:\n      if(PyArg_ParseTuple(args, \"|O\", &cb_extra))\n        tgl_do_update_contact_list (TLS, py_contact_list_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_dialog_list:\n      if(PyArg_ParseTuple(args, \"|O\", &cb_extra))\n        tgl_do_get_dialog_list (TLS, 100, 0, py_dialog_list_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_msg:\n      if(PyArg_ParseTuple(args, \"O!s#|OO\", &tgl_PeerType, &peer, &str, &len, &cb_extra, &pyObj1)) {\n        if(pyObj1 && PyArg_ParseTuple(pyObj1, \"ii\", &preview, &reply_id)) {\n          if(preview != -1) {\n            if(preview)\n              flags |= TGL_SEND_MSG_FLAG_ENABLE_PREVIEW;\n            else\n              flags |= TGL_SEND_MSG_FLAG_DISABLE_PREVIEW;\n          }\n          flags |= TGL_SEND_MSG_FLAG_REPLY (reply_id);\n        }\n        tgl_do_send_message (TLS, PY_PEER_ID(peer), str, len, flags, NULL, py_msg_cb, cb_extra);\n      } else\n        PyErr_Print();\n\n      Py_XDECREF(pyObj1);\n      break;\n    case pq_send_typing:\n      if(PyArg_ParseTuple(args, \"O!|O\", &tgl_PeerType, &peer, &cb_extra))\n        tgl_do_send_typing (TLS, PY_PEER_ID(peer), tgl_typing_typing, py_empty_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_send_typing_abort:\n      if(PyArg_ParseTuple(args, \"O!|O\", &tgl_PeerType, &peer, &cb_extra))\n        tgl_do_send_typing (TLS, PY_PEER_ID(peer), tgl_typing_cancel, py_empty_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_rename_chat:\n      if(PyArg_ParseTuple(args, \"O!s#|O\", &tgl_PeerType, &peer, &str, &len, &cb_extra))\n        tgl_do_rename_chat (TLS, PY_PEER_ID(peer), str, len, py_empty_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_send_photo:\n      if(PyArg_ParseTuple(args, \"O!s|O\", &tgl_PeerType, &peer, &str, &cb_extra))\n        tgl_do_send_document (TLS, PY_PEER_ID(peer), str, NULL, 0, TGL_SEND_MSG_FLAG_DOCUMENT_PHOTO, py_msg_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_send_video:\n      if(PyArg_ParseTuple(args, \"O!s|O\", &tgl_PeerType, &peer, &str, &cb_extra))\n        tgl_do_send_document (TLS, PY_PEER_ID(peer), str, NULL, 0, TGL_SEND_MSG_FLAG_DOCUMENT_VIDEO, py_msg_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_send_audio:\n      if(PyArg_ParseTuple(args, \"O!s|O\", &tgl_PeerType, &peer, &str, &cb_extra))\n        tgl_do_send_document (TLS, PY_PEER_ID(peer), str, NULL, 0, TGL_SEND_MSG_FLAG_DOCUMENT_AUDIO, py_msg_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_send_document:\n      if(PyArg_ParseTuple(args, \"O!s|O\", &tgl_PeerType, &peer, &str, &cb_extra))\n        tgl_do_send_document (TLS, PY_PEER_ID(peer), str, NULL, 0, 0, py_msg_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_send_file:\n      if(PyArg_ParseTuple(args, \"O!s|O\", &tgl_PeerType, &peer, &str, &cb_extra))\n        tgl_do_send_document (TLS, PY_PEER_ID(peer), str, NULL, 0, TGL_SEND_MSG_FLAG_DOCUMENT_AUTO, py_msg_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_send_text:\n      if(PyArg_ParseTuple(args, \"O!s|O\", &tgl_PeerType, &peer, &str, &cb_extra))\n        tgl_do_send_text (TLS, PY_PEER_ID(peer), str, 0, py_msg_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_chat_set_photo:\n      if(PyArg_ParseTuple(args, \"O!s|O\", &tgl_PeerType, &peer, &str, &cb_extra))\n        tgl_do_set_chat_photo (TLS, PY_PEER_ID(peer), str, py_empty_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_load_photo:\n    case pq_load_video:\n    case pq_load_audio:\n    case pq_load_document:\n      if(PyArg_ParseTuple(args, \"O!O\", &tgl_MsgType, &msg, &cb_extra))\n      {\n        M = ((tgl_Msg*)msg)->msg;\n        if (!M || (M->media.type != tgl_message_media_photo && M->media.type != tgl_message_media_document && M->media.type != tgl_message_media_document_encr)) {\n          py_file_cb (TLS, cb_extra, 0, 0);\n        } else {\n          if (M->media.type == tgl_message_media_photo) {\n            assert (M->media.photo);\n            tgl_do_load_photo (TLS, M->media.photo, py_file_cb, cb_extra);\n          } else if (M->media.type == tgl_message_media_document) {\n            tgl_do_load_document (TLS, M->media.document, py_file_cb, cb_extra);\n          } else {\n            tgl_do_load_encr_document (TLS, M->media.encr_document, py_file_cb, cb_extra);\n          }\n        }\n      }\n      break;\n    case pq_load_video_thumb:\n    case pq_load_document_thumb:\n      if(PyArg_ParseTuple(args, \"O!O\", &tgl_MsgType, &msg, &cb_extra))\n      {\n        M = ((tgl_Msg*)msg)->msg;\n        if (!M || (M->media.type != tgl_message_media_document)) {\n          py_file_cb (TLS, cb_extra, 0, 0);\n        } else {\n          tgl_do_load_document_thumb (TLS, M->media.document, py_file_cb, cb_extra);\n        }\n      }\n      break;\n\n    case pq_fwd:\n      if(PyArg_ParseTuple(args, \"O!l|O\", &tgl_PeerType, &peer, &msg_id, &cb_extra))\n        tgl_do_forward_message (TLS, PY_PEER_ID(peer), msg_id, 0, py_msg_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_fwd_media:\n      if(PyArg_ParseTuple(args, \"O!l|O\", &tgl_PeerType, &peer, &msg_id, &cb_extra))\n        tgl_do_forward_media (TLS, PY_PEER_ID(peer), msg_id, 0, py_msg_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_chat_info:\n      if(PyArg_ParseTuple(args, \"O!|O\", &tgl_PeerType, &peer, &cb_extra))\n        tgl_do_get_chat_info (TLS, PY_PEER_ID(peer), 0, py_chat_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_user_info:\n      if(PyArg_ParseTuple(args, \"O!|O\", &tgl_PeerType, &peer, &cb_extra))\n        tgl_do_get_user_info (TLS, PY_PEER_ID(peer), 0, py_user_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_history:\n      if(PyArg_ParseTuple(args, \"O!ii|O\", &tgl_PeerType, &peer, &offset, &limit, &cb_extra))\n        tgl_do_get_history (TLS, PY_PEER_ID(peer), offset, limit, 0, py_msg_list_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_chat_add_user:\n      if(PyArg_ParseTuple(args, \"O!O!|O\", &tgl_PeerType, &peer, &tgl_PeerType, &peer1, &cb_extra))\n        tgl_do_add_user_to_chat (TLS, PY_PEER_ID(peer), PY_PEER_ID(peer1), 100, py_empty_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_chat_del_user:\n      if(PyArg_ParseTuple(args, \"O!O!|O\", &tgl_PeerType, &peer, &tgl_PeerType, &peer1, &cb_extra))\n        tgl_do_del_user_from_chat (TLS, PY_PEER_ID(peer), PY_PEER_ID(peer1), py_empty_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_add_contact:\n      if(PyArg_ParseTuple(args, \"s#s#s#|O\", &str1, &len1, &str2, &len2, &str3, &len3, &cb_extra))\n        tgl_do_add_contact (TLS, str1, len1, str2, len2, str3, len3, 0, py_contact_list_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_del_contact:\n      if(PyArg_ParseTuple(args, \"O!|O\", &tgl_PeerType, &peer, &cb_extra))\n        tgl_do_del_contact (TLS, PY_PEER_ID(peer), py_empty_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_rename_contact:\n      if(PyArg_ParseTuple(args, \"s#s#s#|O\", &str1, &len1, &str2, &len2, &str3, &len3, &cb_extra))\n        tgl_do_add_contact (TLS, str1, len1, str2, len2, str3, len3, 1, py_contact_list_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_search:\n      if(PyArg_ParseTuple(args, \"O!s#|O\", &tgl_PeerType, &peer, &str, &len, &cb_extra))\n        tgl_do_msg_search (TLS, PY_PEER_ID(peer), 0, 0, 40, 0, str, len, py_msg_list_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_global_search:\n      if(PyArg_ParseTuple(args, \"s#|O\", &str, &len, &cb_extra))\n        tgl_do_msg_search (TLS, tgl_set_peer_id (TGL_PEER_UNKNOWN, 0), 0, 0, 40, 0, str, len, py_msg_list_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_mark_read:\n      if(PyArg_ParseTuple(args, \"O!|O\", &tgl_PeerType, &peer, &cb_extra))\n        tgl_do_mark_read (TLS, PY_PEER_ID(peer), py_empty_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_set_profile_photo:\n      if(PyArg_ParseTuple(args, \"s|O\", &str, &cb_extra))\n        tgl_do_set_profile_photo (TLS, str, py_empty_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_set_profile_name:\n      if(PyArg_ParseTuple(args, \"s#s#|O\", &str1, &len1, &str2, &len2, &cb_extra))\n        tgl_do_set_profile_name (TLS, str1, len1, str2, len2, py_user_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_create_secret_chat:\n      if(PyArg_ParseTuple(args, \"O!|O\", &tgl_PeerType, &peer, &cb_extra))\n        tgl_do_create_secret_chat (TLS, PY_PEER_ID(peer), py_secret_chat_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_create_group_chat:\n      if(PyArg_ParseTuple(args, \"O!s#|O\", &PyList_Type, &pyObj1, &str, &len, &cb_extra)) {\n        if(PyList_GET_SIZE(pyObj1) > 2) {\n          ids = (tgl_user_id_t *)malloc(PyList_GET_SIZE(pyObj1) * sizeof(tgl_user_id_t));\n          for(i = 0; i < PyList_GET_SIZE(pyObj1); i++) {\n            peer = PyList_GetItem(pyObj1, i);\n            *(ids+i) = PY_PEER_ID(peer);\n          }\n          tgl_do_create_group_chat (TLS, PyList_GET_SIZE(pyObj1), ids, str, len, py_empty_cb, cb_extra);\n\n          tfree(ids, PyList_GET_SIZE(pyObj1) * sizeof(tgl_user_id_t));\n        } else {\n            logprintf(\"create_group_chat: Argument 1 must be a list of at least 3 peers\");\n        }\n      }\n      Py_XDECREF(pyObj1);\n      break;\n    case pq_delete_msg:\n    case pq_restore_msg:\n      if(PyArg_ParseTuple(args, \"l|O\", &msg_id, &cb_extra))\n        tgl_do_delete_msg (TLS, msg_id, py_empty_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n/*\n    case pq_accept_secret_chat:\n      tgl_do_accept_encr_chat_request (TLS, py_ptr[p + 1], py_secret_chat_cb, py_ptr[p]);\n      break;\n*/\n    case pq_send_contact:\n      if(PyArg_ParseTuple(args, \"O!s#s#s#|O\",  &tgl_PeerType, &peer, &str1, &len1, &str2, &len2, \n                                               &str3, &len3, &cb_extra))\n        tgl_do_send_contact (TLS, PY_PEER_ID(peer), str1, len1, str2, len2, str3, len3, 0, py_msg_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_status_online:\n      if(PyArg_ParseTuple(args, \"|O\", &cb_extra))\n        tgl_do_update_status (TLS, 1, py_empty_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_status_offline:\n      if(PyArg_ParseTuple(args, \"|O\", &cb_extra))\n        tgl_do_update_status (TLS, 0, py_empty_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_extf:\n      if(PyArg_ParseTuple(args, \"s#|O\", &str, &len, &cb_extra))\n        tgl_do_send_extf (TLS, str, len, py_str_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_import_chat_link:\n      if(PyArg_ParseTuple(args, \"s#|O\", &str, &len, &cb_extra))\n        tgl_do_import_chat_link  (TLS, str, len, py_empty_cb, cb_extra);\n      else\n        PyErr_Print();\n      break;\n    case pq_send_location:\n      if(PyArg_ParseTuple(args, \"O!O!O!|O\", &tgl_PeerType, &peer, &PyFloat_Type, &pyObj1, &PyFloat_Type, &pyObj2, &cb_extra)){\n        tgl_do_send_location (TLS, PY_PEER_ID(peer), \n                              PyFloat_AsDouble(pyObj1), PyFloat_AsDouble(pyObj2), 0, py_msg_cb, cb_extra);\n        Py_XDECREF(pyObj1);\n        Py_XDECREF(pyObj2);\n      } else\n        PyErr_Print();\n      break;\n    default:\n      assert (0);\n    }\n\n    // Increment reference on cb_extra as it is passed on to the callback to use\n    Py_XINCREF(cb_extra);\n    \n    // Clean up any arg variables we could have used.\n    //Py_XDECREF(args); // TODO: this is going negative ref and causing segfaults\n    Py_XDECREF(peer);\n    Py_XDECREF(peer1);\n\n  }\n  pos = 0;\n}\n\nPyObject* push_py_func(enum py_query_type type, PyObject *args) {\n  assert(pos + 2 < MAX_PY_COMMANDS);\n\n  py_ptr[pos ++] = (void *)(long)type;\n  py_ptr[pos ++] = (void *)args;\n\n  Py_INCREF(args);\n  Py_RETURN_TRUE;\n}\n\n// Register functions to push commands on the queue\nPyObject* py_contact_list(PyObject *self, PyObject *args) { return push_py_func(pq_contact_list, args); }\nPyObject* py_dialog_list(PyObject *self, PyObject *args) { return push_py_func(pq_dialog_list, args); }\nPyObject* py_rename_chat(PyObject *self, PyObject *args) { return push_py_func(pq_rename_chat, args); }\nPyObject* py_send_msg(PyObject *self, PyObject *args) { return push_py_func(pq_msg, args); }\nPyObject* py_send_typing(PyObject *self, PyObject *args) { return push_py_func(pq_send_typing, args); }\nPyObject* py_send_typing_abort(PyObject *self, PyObject *args) { return push_py_func(pq_send_typing_abort, args); }\nPyObject* py_send_photo(PyObject *self, PyObject *args) { return push_py_func(pq_send_photo, args); }\nPyObject* py_send_video(PyObject *self, PyObject *args) { return push_py_func(pq_send_video, args); }\nPyObject* py_send_audio(PyObject *self, PyObject *args) { return push_py_func(pq_send_audio, args); }\nPyObject* py_send_document(PyObject *self, PyObject *args) { return push_py_func(pq_send_document, args); }\nPyObject* py_send_file(PyObject *self, PyObject *args) { return push_py_func(pq_send_file, args); }\nPyObject* py_send_text(PyObject *self, PyObject *args) { return push_py_func(pq_send_text, args); }\nPyObject* py_chat_set_photo(PyObject *self, PyObject *args) { return push_py_func(pq_chat_set_photo, args); }\nPyObject* py_load_photo(PyObject *self, PyObject *args) { return push_py_func(pq_load_photo, args); }\nPyObject* py_load_video(PyObject *self, PyObject *args) { return push_py_func(pq_load_video, args); }\nPyObject* py_load_video_thumb(PyObject *self, PyObject *args) { return push_py_func(pq_load_video_thumb, args); }\nPyObject* py_load_audio(PyObject *self, PyObject *args) { return push_py_func(pq_load_audio, args); }\nPyObject* py_load_document(PyObject *self, PyObject *args) { return push_py_func(pq_load_document, args); }\nPyObject* py_load_document_thumb(PyObject *self, PyObject *args) { return push_py_func(pq_load_document_thumb, args); }\nPyObject* py_fwd(PyObject *self, PyObject *args) { return push_py_func(pq_fwd, args); }\nPyObject* py_fwd_media(PyObject *self, PyObject *args) { return push_py_func(pq_fwd_media, args); }\nPyObject* py_chat_info(PyObject *self, PyObject *args) { return push_py_func(pq_chat_info, args); }\nPyObject* py_user_info(PyObject *self, PyObject *args) { return push_py_func(pq_chat_info, args); }\nPyObject* py_history(PyObject *self, PyObject *args) { return push_py_func(pq_history, args); }\nPyObject* py_chat_add_user(PyObject *self, PyObject *args) { return push_py_func(pq_chat_add_user, args); }\nPyObject* py_chat_del_user(PyObject *self, PyObject *args) { return push_py_func(pq_chat_del_user, args); }\nPyObject* py_add_contact(PyObject *self, PyObject *args) { return push_py_func(pq_add_contact, args); }\nPyObject* py_del_contact(PyObject *self, PyObject *args) { return push_py_func(pq_del_contact, args); }\nPyObject* py_rename_contact(PyObject *self, PyObject *args) { return push_py_func(pq_rename_contact, args); }\nPyObject* py_search(PyObject *self, PyObject *args) { return push_py_func(pq_search, args); }\nPyObject* py_global_search(PyObject *self, PyObject *args) { return push_py_func(pq_global_search, args); }\nPyObject* py_mark_read(PyObject *self, PyObject *args) { return push_py_func(pq_mark_read, args); }\nPyObject* py_set_profile_photo(PyObject *self, PyObject *args) { return push_py_func(pq_set_profile_photo, args); }\nPyObject* py_set_profile_name(PyObject *self, PyObject *args) { return push_py_func(pq_set_profile_name, args); }\nPyObject* py_create_secret_chat(PyObject *self, PyObject *args) { return push_py_func(pq_create_secret_chat, args); }\nPyObject* py_create_group_chat(PyObject *self, PyObject *args) { return push_py_func(pq_create_group_chat, args); }\nPyObject* py_delete_msg(PyObject *self, PyObject *args) { return push_py_func(pq_delete_msg, args); }\nPyObject* py_restore_msg(PyObject *self, PyObject *args) { return push_py_func(pq_restore_msg, args); }\nPyObject* py_accept_secret_chat(PyObject *self, PyObject *args) { return push_py_func(pq_accept_secret_chat, args); }\nPyObject* py_send_contact(PyObject *self, PyObject *args) { return push_py_func(pq_send_contact, args); }\nPyObject* py_status_online(PyObject *self, PyObject *args) { return push_py_func(pq_status_online, args); }\nPyObject* py_status_offline(PyObject *self, PyObject *args) { return push_py_func(pq_status_offline, args); }\nPyObject* py_send_location(PyObject *self, PyObject *args) { return push_py_func(pq_send_location, args); }\nPyObject* py_extf(PyObject *self, PyObject *args) { return push_py_func(pq_extf, args); }\nPyObject* py_import_chat_link(PyObject *self, PyObject *args) { return push_py_func(pq_import_chat_link, args); }\n\nextern int safe_quit;\nextern int exit_code;\nPyObject* py_safe_quit(PyObject *self, PyObject *args)\n{\n  int exit_val = 0;\n  if(PyArg_ParseTuple(args, \"|i\", &exit_val)) {\n    safe_quit = 1;\n    exit_code = exit_val;\n  } else {\n    PyErr_Print();\n  }\n\n  Py_RETURN_NONE;\n}\n\nPyObject* py_set_preview(PyObject *self, PyObject *args)\n{\n  int preview = 0;\n  if(PyArg_ParseTuple(args, \"p\", &preview)) {\n    if(preview)\n      TLS->disable_link_preview = 0;\n    else\n      TLS->disable_link_preview = 1;\n  } else {\n    PyErr_Print();\n  }\n\n  Py_RETURN_NONE;\n}\n\n// Store callables for python functions\nTGL_PYTHON_CALLBACK(\"on_binlog_replay_end\", _py_binlog_end);\nTGL_PYTHON_CALLBACK(\"on_get_difference_end\", _py_diff_end);\nTGL_PYTHON_CALLBACK(\"on_our_id\", _py_our_id);\nTGL_PYTHON_CALLBACK(\"on_msg_receive\", _py_new_msg);\nTGL_PYTHON_CALLBACK(\"on_secret_chat_update\", _py_secret_chat_update);\nTGL_PYTHON_CALLBACK(\"on_user_update\", _py_user_update);\nTGL_PYTHON_CALLBACK(\"on_chat_update\", _py_chat_update);\nTGL_PYTHON_CALLBACK(\"on_loop\", _py_on_loop);\n\nstatic PyMethodDef py_tgl_methods[] = {\n  {\"get_contact_list\", py_contact_list, METH_VARARGS, \"retrieve contact list\"},\n  {\"get_dialog_list\", py_dialog_list, METH_VARARGS, \"\"},\n  {\"rename_chat\", py_rename_chat, METH_VARARGS, \"\"},\n  {\"send_msg\", py_send_msg, METH_VARARGS, \"send message to user or chat\"},\n  {\"send_typing\", py_send_typing, METH_VARARGS, \"\"},\n  {\"send_typing_abort\", py_send_typing_abort, METH_VARARGS, \"\"},\n  {\"send_photo\", py_send_photo, METH_VARARGS, \"\"},\n  {\"send_video\", py_send_video, METH_VARARGS, \"\"},\n  {\"send_audio\", py_send_audio, METH_VARARGS, \"\"},\n  {\"send_document\", py_send_document, METH_VARARGS, \"\"},\n  {\"send_file\", py_send_file, METH_VARARGS, \"\"},\n  {\"send_text\", py_send_text, METH_VARARGS, \"\"},\n  {\"chat_set_photo\", py_chat_set_photo, METH_VARARGS, \"\"},\n  {\"load_photo\", py_load_photo, METH_VARARGS, \"\"},\n  {\"load_video\", py_load_video, METH_VARARGS, \"\"},\n  {\"load_video_thumb\", py_load_video_thumb, METH_VARARGS, \"\"},\n  {\"load_audio\", py_load_audio, METH_VARARGS, \"\"},\n  {\"load_document\", py_load_document, METH_VARARGS, \"\"},\n  {\"load_document_thumb\", py_load_document_thumb, METH_VARARGS, \"\"},\n  {\"fwd_msg\", py_fwd, METH_VARARGS, \"\"},\n  {\"fwd_media\", py_fwd_media, METH_VARARGS, \"\"},\n  {\"chat_info\", py_chat_info, METH_VARARGS, \"\"},\n  {\"user_info\", py_user_info, METH_VARARGS, \"\"},\n  {\"get_history\", py_history, METH_VARARGS, \"\"},\n  {\"chat_add_user\", py_chat_add_user, METH_VARARGS, \"\"},\n  {\"chat_del_user\", py_chat_del_user, METH_VARARGS, \"\"},\n  {\"add_contact\", py_add_contact, METH_VARARGS, \"\"},\n  {\"del_contact\", py_del_contact, METH_VARARGS, \"\"},\n  {\"rename_contact\", py_rename_contact, METH_VARARGS, \"\"},\n  {\"msg_search\", py_search, METH_VARARGS, \"\"},\n  {\"msg_global_search\", py_global_search, METH_VARARGS, \"\"},\n  {\"mark_read\", py_mark_read, METH_VARARGS, \"\"},\n  {\"set_profile_photo\", py_set_profile_photo, METH_VARARGS, \"\"},\n  {\"set_profile_name\", py_set_profile_name, METH_VARARGS, \"\"},\n  {\"create_secret_chat\", py_create_secret_chat, METH_VARARGS, \"\"},\n  {\"create_group_chat\", py_create_group_chat, METH_VARARGS, \"\"},\n  {\"delete_msg\", py_delete_msg, METH_VARARGS, \"\"},\n  {\"restore_msg\", py_restore_msg, METH_VARARGS, \"\"},\n  {\"accept_secret_chat\", py_accept_secret_chat, METH_VARARGS, \"\"},\n  {\"send_contact\", py_send_contact, METH_VARARGS, \"\"},\n  {\"status_online\", py_status_online, METH_VARARGS, \"\"},\n  {\"status_offline\", py_status_offline, METH_VARARGS, \"\"},\n  {\"send_location\", py_send_location, METH_VARARGS, \"\"},  \n  {\"ext_function\", py_extf, METH_VARARGS, \"\"},\n  {\"import_chat_link\", py_import_chat_link, METH_VARARGS, \"\"},\n  {\"set_on_binlog_replay_end\", set_py_binlog_end, METH_VARARGS, \"\"},\n  {\"set_on_get_difference_end\", set_py_diff_end, METH_VARARGS, \"\"},\n  {\"set_on_our_id\", set_py_our_id, METH_VARARGS, \"\"},\n  {\"set_on_msg_receive\", set_py_new_msg, METH_VARARGS, \"\"},\n  {\"set_on_secret_chat_update\", set_py_secret_chat_update, METH_VARARGS, \"\"},\n  {\"set_on_user_update\", set_py_user_update, METH_VARARGS, \"\"},\n  {\"set_on_chat_update\", set_py_chat_update, METH_VARARGS, \"\"},\n  {\"set_on_loop\", set_py_on_loop, METH_VARARGS, \"\"},\n  {\"set_link_preview\", py_set_preview, METH_VARARGS, \"\"},\n  {\"safe_quit\", py_safe_quit, METH_VARARGS, \"\"},\n  {\"safe_exit\", py_safe_quit, METH_VARARGS, \"\"}, // Alias to safe_quit for naming consistancy in python.\n  { NULL, NULL, 0, NULL }\n};\n\nvoid py_add_action_enums(PyObject *m)\n{\n  PyModule_AddIntConstant(m, \"ACTION_NONE\", tgl_message_action_none);\n  PyModule_AddIntConstant(m, \"ACTION_GEO_CHAT_CREATE\", tgl_message_action_geo_chat_create);\n  PyModule_AddIntConstant(m, \"ACTION_GEO_CHAT_CHECKIN\", tgl_message_action_geo_chat_checkin);\n  PyModule_AddIntConstant(m, \"ACTION_CHAT_CREATE\", tgl_message_action_chat_create);\n  PyModule_AddIntConstant(m, \"ACTION_CHAT_EDIT_TITLE\", tgl_message_action_chat_edit_title);\n  PyModule_AddIntConstant(m, \"ACTION_CHAT_EDIT_PHOTO\", tgl_message_action_chat_edit_photo);\n  PyModule_AddIntConstant(m, \"ACTION_CHAT_DELETE_PHOTO\", tgl_message_action_chat_delete_photo);\n  PyModule_AddIntConstant(m, \"ACTION_CHAT_ADD_USER\", tgl_message_action_chat_add_user);\n  PyModule_AddIntConstant(m, \"ACTION_CHAT_ADD_USER_BY_LINK\", tgl_message_action_chat_add_user_by_link);\n  PyModule_AddIntConstant(m, \"ACTION_CHAT_DELETE_USER\", tgl_message_action_chat_delete_user);\n  PyModule_AddIntConstant(m, \"ACTION_SET_MESSAGE_TTL\", tgl_message_action_set_message_ttl);\n  PyModule_AddIntConstant(m, \"ACTION_READ_MESSAGES\", tgl_message_action_read_messages);\n  PyModule_AddIntConstant(m, \"ACTION_DELETE_MESSAGES\", tgl_message_action_delete_messages);\n  PyModule_AddIntConstant(m, \"ACTION_SCREENSHOT_MESSAGES\", tgl_message_action_screenshot_messages);\n  PyModule_AddIntConstant(m, \"ACTION_FLUSH_HISTORY\", tgl_message_action_flush_history);\n  PyModule_AddIntConstant(m, \"ACTION_RESEND\", tgl_message_action_resend);\n  PyModule_AddIntConstant(m, \"ACTION_NOTIFY_LAYER\", tgl_message_action_notify_layer);\n  PyModule_AddIntConstant(m, \"ACTION_TYPING\", tgl_message_action_typing);\n  PyModule_AddIntConstant(m, \"ACTION_NOOP\", tgl_message_action_noop);\n  PyModule_AddIntConstant(m, \"ACTION_COMMIT_KEY\", tgl_message_action_commit_key);\n  PyModule_AddIntConstant(m, \"ACTION_ABORT_KEY\", tgl_message_action_abort_key);\n  PyModule_AddIntConstant(m, \"ACTION_REQUEST_KEY\", tgl_message_action_request_key);\n  PyModule_AddIntConstant(m, \"ACTION_ACCEPT_KEY\", tgl_message_action_accept_key);\n}\n\nvoid py_add_peer_type_enums(PyObject *m)\n{\n  PyModule_AddIntConstant(m, \"PEER_USER\", TGL_PEER_USER);\n  PyModule_AddIntConstant(m, \"PEER_CHAT\", TGL_PEER_CHAT);\n  PyModule_AddIntConstant(m, \"PEER_ENCR_CHAT\", TGL_PEER_ENCR_CHAT);\n}\n\n\nMOD_INIT(tgl)\n{\n  PyObject *m;\n\n  MOD_DEF(m, \"tgl\", NULL, py_tgl_methods)\n\n  if (m == NULL)\n    return MOD_ERROR_VAL;\n\n  py_add_action_enums(m);\n  py_add_peer_type_enums(m);\n\n  if (PyType_Ready(&tgl_PeerType) < 0)\n    return MOD_ERROR_VAL;\n\n  Py_INCREF(&tgl_PeerType);\n  PyModule_AddObject(m, \"Peer\", (PyObject *)&tgl_PeerType);\n\n  if (PyType_Ready(&tgl_MsgType) < 0)\n    return MOD_ERROR_VAL;\n  \n  Py_INCREF(&tgl_MsgType);\n  PyModule_AddObject(m, \"Msg\", (PyObject *)&tgl_MsgType);\n\n  TglError = PyErr_NewException(\"tgl.Error\", NULL, NULL);\n  Py_INCREF(TglError);\n  PyModule_AddObject(m, \"TglError\", TglError);\n  \n  PeerError = PyErr_NewException(\"tgl.PeerError\", NULL, NULL);\n  Py_INCREF(PeerError);\n  PyModule_AddObject(m, \"PeerError\", PeerError);\n  \n  MsgError = PyErr_NewException(\"tgl.MsgError\", NULL, NULL);\n  Py_INCREF(MsgError);\n  PyModule_AddObject(m, \"MsgError\", MsgError);\n  \n  return MOD_SUCCESS_VAL(m);  \n}\n\n\nvoid py_init (const char *file) {\n  if (!file) { return; }\n  python_loaded = 0;\n  \n  PyObject *pModule;\n\n  // Get a copy of the filename for dirname/basename, which may modify the string, and break const correctness\n  char filename[1024];\n  strncpy(filename, file, 1024);\n\n\n   \n#if PY_MAJOR_VERSION >= 3\n  PyImport_AppendInittab(\"tgl\", &PyInit_tgl);\n  Py_Initialize();\n#else\n  Py_Initialize();\n  inittgl();\n#endif\n\n\n  PyObject* sysPath = PySys_GetObject((char*)\"path\");\n  PyList_Append(sysPath, PyUnicode_FromString(dirname(filename)));\n  \n  // Recopy the string in, since dirname modified it.\n  strncpy(filename, file, 1024);\n  \n  // remove .py extension from file, if any\n  char* dot = strrchr(filename, '.');\n  if (dot && strcmp(dot, \".py\") == 0) \n    *dot = 0;\n  pModule = PyImport_Import(PyUnicode_FromString(basename(filename)));\n  \n  if(pModule == NULL || PyErr_Occurred()) { // Error loading script\n    logprintf(\"Failed to load python script\\n\");\n    PyErr_Print();\n    exit(1);\n  }\n\n\n  python_loaded = 1;\n  PyDateTime_IMPORT;\n  logprintf(\"Python Initialized\\n\");\n}\n\n#endif\n"
        },
        {
          "name": "python-tg.h",
          "type": "blob",
          "size": 4.0283203125,
          "content": "/*\n    This file is part of telegram-cli.\n\n    Telegram-cli is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n\n    Telegram-cli is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this telegram-cli.  If not, see <http://www.gnu.org/licenses/>.\n\n    Copyright Vitaly Valtman 2013-2015\n    Copyright Vincent Castellano 2015\n*/\n#ifndef __PYTHON_TG_H__\n#define __PYTHON_TG_H__\n\n#include <Python.h>\n#include <string.h>\n#include <tgl/tgl.h>\n\n// Python functions\nvoid py_init (const char *file);\nvoid py_new_msg (struct tgl_message *M);\nvoid py_our_id (int id);\nvoid py_secret_chat_update (struct tgl_secret_chat *U, unsigned flags);\nvoid py_user_update (struct tgl_user *U, unsigned flags);\nvoid py_chat_update (struct tgl_chat *C, unsigned flags);\nvoid py_binlog_end (void);\nvoid py_diff_end (void);\nvoid py_do_all (void);\n\n// Binding functions\nPyObject* py_contact_list(PyObject *self, PyObject *args);\nPyObject* py_dialog_list(PyObject *self, PyObject *args);\nPyObject* py_rename_chat(PyObject *self, PyObject *args);\nPyObject* py_send_msg(PyObject *self, PyObject *args);\nPyObject* py_send_typing(PyObject *self, PyObject *args);\nPyObject* py_send_typing_abort(PyObject *self, PyObject *args);\nPyObject* py_send_photo(PyObject *self, PyObject *args);\nPyObject* py_send_video(PyObject *self, PyObject *args);\nPyObject* py_send_audio(PyObject *self, PyObject *args);\nPyObject* py_send_document(PyObject *self, PyObject *args);\nPyObject* py_send_file(PyObject *self, PyObject *args);\nPyObject* py_send_text(PyObject *self, PyObject *args);\nPyObject* py_chat_set_photo(PyObject *self, PyObject *args);\nPyObject* py_load_photo(PyObject *self, PyObject *args);\nPyObject* py_load_video(PyObject *self, PyObject *args);\nPyObject* py_load_video_thumb(PyObject *self, PyObject *args);\nPyObject* py_load_audio(PyObject *self, PyObject *args);\nPyObject* py_load_document(PyObject *self, PyObject *args);\nPyObject* py_load_document_thumb(PyObject *self, PyObject *args);\nPyObject* py_fwd(PyObject *self, PyObject *args);\nPyObject* py_fwd_media(PyObject *self, PyObject *args);\nPyObject* py_chat_info(PyObject *self, PyObject *args);\nPyObject* py_user_info(PyObject *self, PyObject *args);\nPyObject* py_history(PyObject *self, PyObject *args);\nPyObject* py_chat_add_user(PyObject *self, PyObject *args);\nPyObject* py_chat_del_user(PyObject *self, PyObject *args);\nPyObject* py_add_contact(PyObject *self, PyObject *args);\nPyObject* py_del_contact(PyObject *self, PyObject *args);\nPyObject* py_rename_contact(PyObject *self, PyObject *args);\nPyObject* py_search(PyObject *self, PyObject *args);\nPyObject* py_global_search(PyObject *self, PyObject *args);\nPyObject* py_mark_read(PyObject *self, PyObject *args);\nPyObject* py_set_profile_photo(PyObject *self, PyObject *args);\nPyObject* py_set_profile_name(PyObject *self, PyObject *args);\nPyObject* py_create_secret_chat(PyObject *self, PyObject *args);\nPyObject* py_create_group_chat(PyObject *self, PyObject *args);\nPyObject* py_delete_msg(PyObject *self, PyObject *args);\nPyObject* py_restore_msg(PyObject *self, PyObject *args);\nPyObject* py_accept_secret_chat(PyObject *self, PyObject *args);\nPyObject* py_send_contact(PyObject *self, PyObject *args);\nPyObject* py_status_online(PyObject *self, PyObject *args);\nPyObject* py_status_offline(PyObject *self, PyObject *args);\nPyObject* py_send_location(PyObject *self, PyObject *args);\nPyObject* py_extf(PyObject *self, PyObject *args);\n\n\n// Util Functions\nvoid py_add_string_field (PyObject* dict, char *name, const char *value);\nvoid py_add_string_field_arr (PyObject* list, int num, const char *value);\nvoid py_add_num_field (PyObject* dict, const char *name, double value);\n#endif\n"
        },
        {
          "name": "python-types.c",
          "type": "blob",
          "size": 41.48828125,
          "content": "\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef USE_PYTHON\n#include <Python.h>\n#include <tgl/tgl.h>\n#include <tgl/tools.h>\n#include <tgl/updates.h>\n#include <tgl/tgl-structures.h>\n#include <stdlib.h>\n#include \"structmember.h\"\n\n// Python Imports\n#include \"datetime.h\"\n\n#include \"python-types.h\"\n#include \"python-tg.h\"\n\nextern struct tgl_state *TLS;\n// TGL Python Exceptions\nextern PyObject *TglError;\nextern PyObject *PeerError;\nextern PyObject *MsgError;\n\n// Forward type declarations\nPyTypeObject tgl_PeerType;\n\n// Utility functions\nPyObject* get_datetime(long datetime)\n{\n  return PyDateTime_FromTimestamp(Py_BuildValue(\"(O)\", PyLong_FromLong(datetime)));\n}\n\n\n//\n// tgl_peer_t wrapper\n//\nstatic void\ntgl_Peer_dealloc(tgl_Peer* self)\n{\n  Py_TYPE(self)->tp_free((PyObject*)self);\n}\n\nstatic PyObject *\ntgl_Peer_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n  tgl_Peer *self;\n\n  PyDateTime_IMPORT;\n  self = (tgl_Peer *)type->tp_alloc(type, 0);\n  return (PyObject *)self;\n}\n\nstatic int\ntgl_Peer_init(tgl_Peer *self, PyObject *args, PyObject *kwds)\n{\n  static char *kwlist[] = {\"type\", \"id\", NULL};\n  tgl_peer_id_t peer_id;\n  if(!PyArg_ParseTupleAndKeywords(args, kwds, \"ii\", kwlist, \n                                  &peer_id.type,\n                                  &peer_id.id))\n  {\n    PyErr_Format(PeerError, \"Peer must specify type and id\");\n    return -1;\n  }\n  self->peer = tgl_peer_get(TLS, peer_id);\n  if(self->peer == NULL)\n    return -1;\n\n  return 0;\n}\n\nstatic PyObject *\ntgl_Peer_getname (tgl_Peer *self, void *closure)\n{\n  PyObject *ret;\n\n  switch(self->peer->id.type) {\n    case TGL_PEER_USER:\n      ret = PyUnicode_FromString(self->peer->user.print_name);\n      break;\n    case TGL_PEER_CHAT:\n      ret = PyUnicode_FromString(self->peer->chat.print_title);\n      break;\n    case TGL_PEER_ENCR_CHAT:\n      ret = PyUnicode_FromString(self->peer->encr_chat.print_name);\n      break;\n    default:\n     PyErr_SetString(PeerError, \"peer.type_name not supported!\");\n     Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\n\nstatic PyObject *\ntgl_Peer_getuser_id (tgl_Peer *self, void *closure)\n{\n  PyObject *ret;\n\n  switch(self->peer->id.type) {\n    case TGL_PEER_USER:\n      ret = PyLong_FromLong(self->peer->id.id);\n      break;\n    case TGL_PEER_CHAT:\n      PyErr_SetString(PeerError, \"peer.type_name == 'chat' has no user_id\");\n      Py_RETURN_NONE;\n \n      break;\n    case TGL_PEER_ENCR_CHAT:\n      ret = PyLong_FromLong(self->peer->encr_chat.user_id);\n      break;\n    default:\n     PyErr_SetString(PeerError, \"peer.type_name not supported!\");\n     Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Peer_getuser_list (tgl_Peer *self, void *closure)\n{\n  PyObject *ret;\n  int i;\n  struct tgl_chat_user *user_list;\n\n  switch(self->peer->id.type) {\n    case TGL_PEER_CHAT:\n      ret = PyList_New(0);\n        for(i = 0; i < self->peer->chat.user_list_size; i++) {\n        // TODO: Sort tgl_user objects, maybe offline mode is enoug?\n        user_list = self->peer->chat.user_list + i;\n        PyList_Append(ret, PyLong_FromLong(user_list->user_id));\n      }\n      break;\n    case TGL_PEER_ENCR_CHAT:\n    case TGL_PEER_USER:\n      PyErr_SetString(PeerError, \"Only peer.type_name == 'chat' has user_list\");\n      Py_RETURN_NONE;\n      break;\n    default:\n     PyErr_SetString(PeerError, \"peer.type_name not supported!\");\n     Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Peer_getuser_status(tgl_Peer *self, void *closure)\n{\n  PyObject *ret;\n\n  switch(self->peer->id.type) {\n    case TGL_PEER_USER:\n      ret = PyDict_New();\n      PyDict_SetItemString(ret, \"online\", self->peer->user.status.online? Py_True : Py_False);\n      PyDict_SetItemString(ret, \"when\", get_datetime(self->peer->user.status.when));\n\n      break;\n    case TGL_PEER_CHAT:\n    case TGL_PEER_ENCR_CHAT:\n      PyErr_SetString(PeerError, \"Only peer.type_name == 'user' has user_status\");\n      Py_RETURN_NONE;\n      break;\n    default:\n     PyErr_SetString(PeerError, \"peer.type_name not supported!\");\n     Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Peer_getphone (tgl_Peer *self, void *closure)\n{\n  PyObject *ret;\n\n  switch(self->peer->id.type) {\n    case TGL_PEER_USER:\n      if(self->peer->user.phone)\n        ret = PyUnicode_FromString(self->peer->user.phone);\n      else\n        Py_RETURN_NONE;\n      break;\n    case TGL_PEER_CHAT:\n    case TGL_PEER_ENCR_CHAT:\n      PyErr_SetString(PeerError, \"Only peer.type_name == 'user' has phone\");\n      Py_RETURN_NONE;\n      break;\n    default:\n     PyErr_SetString(PeerError, \"peer.type_name not supported!\");\n     Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Peer_getusername (tgl_Peer *self, void *closure)\n{\n  PyObject *ret;\n\n  switch(self->peer->id.type) {\n    case TGL_PEER_USER:\n      if(self->peer->user.username)\n        ret = PyUnicode_FromString(self->peer->user.username);\n      else\n        Py_RETURN_NONE;\n      break;\n    case TGL_PEER_CHAT:\n    case TGL_PEER_ENCR_CHAT:\n      PyErr_SetString(PeerError, \"Only peer.type_name == 'user' has username\");\n      Py_RETURN_NONE;\n      break;\n    default:\n     PyErr_SetString(PeerError, \"peer.type_name not supported!\");\n     Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Peer_getfirst_name (tgl_Peer *self, void *closure)\n{\n  PyObject *ret;\n\n  switch(self->peer->id.type) {\n    case TGL_PEER_USER:\n      if(self->peer->user.first_name)\n        ret = PyUnicode_FromString(self->peer->user.first_name);\n      else\n        Py_RETURN_NONE;\n      break;\n    case TGL_PEER_CHAT:\n    case TGL_PEER_ENCR_CHAT:\n      PyErr_SetString(PeerError, \"Only peer.type_name == 'user' has first_name\");\n      Py_RETURN_NONE;\n      break;\n    default:\n     PyErr_SetString(PeerError, \"peer.type_name not supported!\");\n     Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Peer_getlast_name (tgl_Peer *self, void *closure)\n{\n  PyObject *ret;\n\n  switch(self->peer->id.type) {\n    case TGL_PEER_USER:\n      if(self->peer->user.last_name)\n        ret = PyUnicode_FromString(self->peer->user.last_name);\n      else\n        Py_RETURN_NONE;\n      break;\n    case TGL_PEER_CHAT:\n    case TGL_PEER_ENCR_CHAT:\n      PyErr_SetString(PeerError, \"Only peer.type_name == 'user' has last_name\");\n      Py_RETURN_NONE;\n      break;\n    default:\n     PyErr_SetString(PeerError, \"peer.type_name not supported!\");\n     Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Peer_getuser (tgl_Peer *self, void *closure)\n{\n  PyObject *ret;\n\n  switch(self->peer->id.type) {\n    case TGL_PEER_ENCR_CHAT:\n      ret = tgl_Peer_FromTglPeer(tgl_peer_get(TLS, TGL_MK_USER (self->peer->encr_chat.user_id)));\n      break;\n    case TGL_PEER_USER:\n      ret = (PyObject*)self;\n      break;\n    case TGL_PEER_CHAT:\n      PyErr_SetString(PeerError, \"Only peer.type_name == 'chat' does not have user\");\n      Py_RETURN_NONE;\n      break;\n    default:\n     PyErr_SetString(PeerError, \"peer.type_name not supported!\");\n     Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Peer_gettype_name(tgl_Peer* self)\n{\n  PyObject *name;\n\n  switch(self->peer->id.type) {\n    case TGL_PEER_USER:\n      name = PyUnicode_FromString(\"user\");\n      break;\n    case TGL_PEER_CHAT:\n      name = PyUnicode_FromString(\"chat\");\n      break;\n    case TGL_PEER_ENCR_CHAT:\n      name = PyUnicode_FromString(\"secret_chat\");\n      break;\n    default:\n      name = PyUnicode_FromString(\"unknown\");\n    }\n  return name;\n}\n\nstatic PyObject *\ntgl_Peer_getid (tgl_Peer *self, void *closure)\n{\n  PyObject *ret;\n\n  ret = PyLong_FromLong(self->peer->id.id);\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Peer_gettype (tgl_Peer *self, void *closure)\n{\n  PyObject *ret;\n\n  ret = PyLong_FromLong(self->peer->id.type); \n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyGetSetDef tgl_Peer_getseters[] = {\n  {\"id\", (getter)tgl_Peer_getid, NULL, \"\", NULL},\n  {\"type\", (getter)tgl_Peer_gettype, NULL, \"\", NULL},\n  {\"type_name\", (getter)tgl_Peer_gettype_name, NULL, \"\", NULL},\n  {\"name\", (getter)tgl_Peer_getname, NULL, \"\", NULL},\n  {\"user_id\", (getter)tgl_Peer_getuser_id, NULL, \"\", NULL},\n  {\"user\", (getter)tgl_Peer_getuser, NULL, \"\", NULL},\n  {\"user_list\", (getter)tgl_Peer_getuser_list, NULL, \"\", NULL},\n  {\"user_status\", (getter)tgl_Peer_getuser_status, NULL, \"\", NULL},\n  {\"phone\", (getter)tgl_Peer_getphone, NULL, \"\", NULL},\n  {\"username\", (getter)tgl_Peer_getusername, NULL, \"\", NULL},\n  {\"first_name\", (getter)tgl_Peer_getfirst_name, NULL, \"\", NULL},\n  {\"last_name\", (getter)tgl_Peer_getlast_name, NULL, \"\", NULL},\n  {NULL}  /* Sentinel */\n};\n\nstatic PyMemberDef tgl_Peer_members[] = {\n  {NULL}  /* Sentinel */\n};\n\nstatic PyObject *\ntgl_Peer_send_msg (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"message\", \"callback\", \"preview\", \"reply\", NULL};\n\n  char *message;\n  int preview = -1;\n  int reply = 0;\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"s|Opi\", kwlist, &message, &callback, &preview, &reply)) {\n    PyObject *api_call;\n    PyObject *flags;\n\n    flags = Py_BuildValue(\"(ii)\", preview, reply);\n\n\n    if(callback)\n      api_call = Py_BuildValue(\"OsOO\", (PyObject*) self, message, callback, flags);\n    else\n      api_call = Py_BuildValue(\"OsOO\", (PyObject*) self, message, Py_None, flags);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n    Py_XINCREF(flags);\n\n    return py_send_msg(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_fwd_msg (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"callback\", NULL};\n\n  int fwd_id = 0;\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"i|O\", kwlist, &fwd_id, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OiO\", (PyObject*) self, fwd_id, callback);\n    else\n      api_call = Py_BuildValue(\"Oi\", (PyObject*) self, fwd_id);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_fwd(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_send_typing (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"callback\", NULL};\n\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"|O\", kwlist, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OO\", (PyObject*) self, callback);\n    else\n      api_call = Py_BuildValue(\"O\", (PyObject*) self);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_send_typing(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_send_typing_abort (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"callback\", NULL};\n\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"|O\", kwlist, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OO\", (PyObject*) self, callback);\n    else\n      api_call = Py_BuildValue(\"O\", (PyObject*) self);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_send_typing_abort(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_rename_chat (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"title\", \"callback\", NULL};\n\n  char * title;\n  PyObject *callback = NULL;\n\n  if(self->peer->id.type != TGL_PEER_CHAT) {\n    PyErr_SetString(PeerError, \"Only a chat peer can be renamed\");\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"s|O\", kwlist, &title, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OsO\", (PyObject*) self, title, callback);\n    else\n      api_call = Py_BuildValue(\"Os\", (PyObject*) self, title);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_rename_chat(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_send_photo (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"filename\", \"callback\", NULL};\n\n  char *filename;\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"s|O\", kwlist, &filename, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OsO\", (PyObject*) self, filename, callback);\n    else\n      api_call = Py_BuildValue(\"Os\", (PyObject*) self, filename);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_send_photo(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_send_video (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"filename\", \"callback\", NULL};\n\n  char *filename;\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"s|O\", kwlist, &filename, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OsO\", (PyObject*) self, filename, callback);\n    else\n      api_call = Py_BuildValue(\"Os\", (PyObject*) self, filename);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_send_video(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_send_audio (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"filename\", \"callback\", NULL};\n\n  char *filename;\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"s|O\", kwlist, &filename, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OsO\", (PyObject*) self, filename, callback);\n    else\n      api_call = Py_BuildValue(\"Os\", (PyObject*) self, filename);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_send_audio(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_send_document (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"filename\", \"callback\", NULL};\n\n  char *filename;\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"s|O\", kwlist, &filename, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OsO\", (PyObject*) self, filename, callback);\n    else\n      api_call = Py_BuildValue(\"Os\", (PyObject*) self, filename);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_send_document(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_send_file (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"filename\", \"callback\", NULL};\n\n  char *filename;\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"s|O\", kwlist, &filename, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OsO\", (PyObject*) self, filename, callback);\n    else\n      api_call = Py_BuildValue(\"Os\", (PyObject*) self, filename);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_send_file(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_send_text (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"filename\", \"callback\", NULL};\n\n  char *filename;\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"s|O\", kwlist, &filename, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OsO\", (PyObject*) self, filename, callback);\n    else\n      api_call = Py_BuildValue(\"Os\", (PyObject*) self, filename);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_send_text(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_chat_set_photo (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"filename\", \"callback\", NULL};\n\n  char * filename;\n  PyObject *callback = NULL;\n\n  if(self->peer->id.type != TGL_PEER_CHAT) {\n    PyErr_SetString(PeerError, \"Only a chat peer can have a chat photo set.\");\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"s|O\", kwlist, &filename, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OsO\", (PyObject*) self, filename, callback);\n    else\n      api_call = Py_BuildValue(\"Os\", (PyObject*) self, filename);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_chat_set_photo(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_chat_add_user (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"peer\", \"callback\", NULL};\n\n  PyObject *peer;\n  PyObject *callback = NULL;\n\n  if(self->peer->id.type != TGL_PEER_CHAT) {\n    PyErr_SetString(PeerError, \"Only a chat peer can have a user added.\");\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"O!|O\", kwlist, &tgl_PeerType, &peer, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OOO\", (PyObject*) self, peer, callback);\n    else\n      api_call = Py_BuildValue(\"OO\", (PyObject*) self, peer);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_chat_add_user(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_chat_del_user (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"peer\", \"callback\", NULL};\n\n  PyObject *peer;\n  PyObject *callback = NULL;\n\n  if(self->peer->id.type != TGL_PEER_CHAT) {\n    PyErr_SetString(PeerError, \"Only a chat peer can have a user deleted.\");\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"O!|O\", kwlist, &tgl_PeerType, &peer, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OOO\", (PyObject*) self, peer, callback);\n    else\n      api_call = Py_BuildValue(\"OO\", (PyObject*) self, peer);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_chat_del_user(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_history (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"offset\", \"limit\", \"callback\", NULL};\n\n  int offset, limit;\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"ii|O\", kwlist, &offset, &limit, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OiiO\", (PyObject*) self, offset, limit, callback);\n    else\n      api_call = Py_BuildValue(\"Oii\", (PyObject*) self, offset, limit);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_history(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_info (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"callback\", NULL};\n\n  PyObject *callback = NULL;\n\n  if(self->peer->id.type == TGL_PEER_ENCR_CHAT) {\n    PyErr_SetString(PeerError, \"Secret chats currently have no info.\");\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"O\", kwlist, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OO\", (PyObject*) self, callback);\n    else\n      api_call = Py_None;\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n    if(self->peer->id.type == TGL_PEER_USER)\n      return py_user_info(Py_None, api_call);\n    else\n      return py_chat_info(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_send_contact (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"phone\", \"first_name\", \"last_name\", \"callback\", NULL};\n\n  char *phone, *first_name, *last_name;\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"sss|O\", kwlist, &phone, &first_name, &last_name, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"Osss\", (PyObject*) self, phone, first_name, last_name, callback);\n    else\n      api_call = Py_BuildValue(\"Os\", (PyObject*) self, phone, first_name, last_name);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_send_contact(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\n\nstatic PyObject *\ntgl_Peer_send_location (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"latitude\", \"longitude\", \"callback\", NULL};\n\n  PyObject *latitude, *longitude;\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"O!O!|O\", kwlist, &PyFloat_Type,\n        &latitude, &PyFloat_Type, &longitude, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OOOO\", (PyObject*) self, latitude, longitude, callback);\n    else\n      api_call = Py_BuildValue(\"OOO\", (PyObject*) self, latitude, longitude);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_send_location(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Peer_mark_read (tgl_Peer *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"callback\", NULL};\n\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"|O\", kwlist, &callback)) {\n    PyObject *api_call;\n\n    if(callback)\n      api_call = Py_BuildValue(\"OO\", (PyObject*) self, callback);\n    else\n      api_call = Py_BuildValue(\"O\", (PyObject*) self);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_mark_read(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyMethodDef tgl_Peer_methods[] = {\n  {\"send_msg\",          (PyCFunction)tgl_Peer_send_msg, METH_VARARGS | METH_KEYWORDS,\n    \"Send a message to peer object\"},\n  {\"send_typing\",       (PyCFunction)tgl_Peer_send_typing, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"send_typing_abort\", (PyCFunction)tgl_Peer_send_typing_abort, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"rename_chat\",       (PyCFunction)tgl_Peer_rename_chat, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"send_photo\",        (PyCFunction)tgl_Peer_send_photo, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"send_video\",        (PyCFunction)tgl_Peer_send_video, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"send_audio\",        (PyCFunction)tgl_Peer_send_audio, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"send_file\",         (PyCFunction)tgl_Peer_send_file, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"send_document\",     (PyCFunction)tgl_Peer_send_document, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"send_text\",         (PyCFunction)tgl_Peer_send_text, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"chat_set_photo\",    (PyCFunction)tgl_Peer_chat_set_photo, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"info\",              (PyCFunction)tgl_Peer_info, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"history\",           (PyCFunction)tgl_Peer_history, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"chat_add_user\",     (PyCFunction)tgl_Peer_chat_add_user, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"chat_del_user\",     (PyCFunction)tgl_Peer_chat_del_user, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"send_contact\",      (PyCFunction)tgl_Peer_send_contact, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"send_location\",     (PyCFunction)tgl_Peer_send_location, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"mark_read\",         (PyCFunction)tgl_Peer_mark_read, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"fwd_msg\",           (PyCFunction)tgl_Peer_fwd_msg, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {NULL}  /* Sentinel */\n};\n\n\nstatic PyObject *\ntgl_Peer_repr(tgl_Peer *self)\n{\n  PyObject *ret;\n\n  switch(self->peer->id.type) {\n    case TGL_PEER_USER:\n#if PY_VERSION_HEX < 0x02070900\n       ret = PyUnicode_FromFormat(\"<tgl.Peer: id=%ld>\", self->peer->id.id);\n#else\n       ret = PyUnicode_FromFormat(\"<tgl.Peer: type=user, id=%ld, username=%R, name=%R, first_name=%R, last_name=%R, phone=%R>\",\n                                  self->peer->id.id,\n                                  PyObject_GetAttrString((PyObject*)self, \"username\"),\n                                  PyObject_GetAttrString((PyObject*)self, \"name\"),\n                                  PyObject_GetAttrString((PyObject*)self, \"first_name\"),\n                                  PyObject_GetAttrString((PyObject*)self, \"last_name\"),\n                                  PyObject_GetAttrString((PyObject*)self, \"phone\")\n            );\n#endif\n      break;\n    case TGL_PEER_CHAT:\n      ret = PyUnicode_FromFormat(\"<tgl.Peer: type=chat, id=%ld, name=%s>\",\n                                  self->peer->id.id,  self->peer->chat.print_title);\n      break;\n    case TGL_PEER_ENCR_CHAT:\n      ret = PyUnicode_FromFormat(\"<tgl.Peer: type=secret_chat, id=%ld, name=%s, user=%R>\",\n                                  self->peer->id.id,  self->peer->encr_chat.print_name,\n                                  PyObject_GetAttrString((PyObject*)self, \"user\"));\n      break;\n    default:\n      ret = PyUnicode_FromFormat(\"<tgl.Peer: Type Unknown>\");\n    }\n\n  return ret;\n}\n\nint\ntgl_Peer_hash(PyObject *self)\n{\n  return PyObject_Hash(PyObject_GetAttrString(self, \"id\"));\n}\n\nPyObject *\ntgl_Peer_RichCompare(PyObject *self, PyObject *other, int cmp)\n{\n  PyObject *result = NULL;\n\n  if(!PyObject_TypeCheck(other, &tgl_PeerType)) {\n    result = Py_False;\n  } else {\n    if(((tgl_Peer*)self)->peer == NULL ||\n       ((tgl_Peer*)other)->peer == NULL) {\n      result = Py_False; // If either object is not properly instantiated, compare is false\n    } else {\n      switch (cmp) {\n      case Py_EQ:\n        result = ((tgl_Peer*)self)->peer->id.id == ((tgl_Peer*)other)->peer->id.id ? Py_True : Py_False;\n        break;\n      case Py_NE:\n        result = ((tgl_Peer*)self)->peer->id.id == ((tgl_Peer*)other)->peer->id.id ? Py_False : Py_True;\n        break;\n      case Py_LE:\n      case Py_GE:\n      case Py_GT:\n      case Py_LT:\n      default:\n        return Py_INCREF(Py_NotImplemented), Py_NotImplemented;\n      }\n    }\n  }\n  Py_XINCREF(result);\n  return result;\n}\n\n\nPyTypeObject tgl_PeerType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"tgl.Peer\",                   /* tp_name */\n    sizeof(tgl_Peer),             /* tp_basicsize */\n    0,                            /* tp_itemsize */\n    (destructor)tgl_Peer_dealloc, /* tp_dealloc */\n    0,                            /* tp_print */\n    0,                            /* tp_getattr */\n    0,                            /* tp_setattr */\n    0,                            /* tp_reserved */\n    (reprfunc)tgl_Peer_repr,      /* tp_repr */\n    0,                            /* tp_as_number */\n    0,                            /* tp_as_sequence */\n    0,                            /* tp_as_mapping */\n    (hashfunc)tgl_Peer_hash,      /* tp_hash  */\n    0,                            /* tp_call */\n    0,                            /* tp_str */\n    0,                            /* tp_getattro */\n    0,                            /* tp_setattro */\n    0,                            /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,           /* tp_flags */\n    \"tgl Peer\",                   /* tp_doc */\n    0,                            /* tp_traverse */\n    0,                            /* tp_clear */\n    (richcmpfunc)tgl_Peer_RichCompare, /* tp_richcompare */\n    0,                            /* tp_weaklistoffset */\n    0,                            /* tp_iter */\n    0,                            /* tp_iternext */\n    tgl_Peer_methods,             /* tp_methods */\n    tgl_Peer_members,             /* tp_members */\n    tgl_Peer_getseters,           /* tp_getset */\n    0,                            /* tp_base */\n    0,                            /* tp_dict */\n    0,                            /* tp_descr_get */\n    0,                            /* tp_descr_set */\n    0,                            /* tp_dictoffset */\n    (initproc)tgl_Peer_init,      /* tp_init */\n    0,                            /* tp_alloc */\n    tgl_Peer_new,                 /* tp_new */\n};\n\n\nPyObject *\ntgl_Peer_FromTglPeer(tgl_peer_t *peer) {\n  tgl_Peer *self = (tgl_Peer *) tgl_Peer_new((PyTypeObject *)&tgl_PeerType, Py_None, Py_None);\n\n  self->peer = peer;\n  return (PyObject *) self;\n}\n\n//\n// struct tgl_message wrapper\n//\n\nstatic void\ntgl_Msg_dealloc(tgl_Msg* self)\n{\n  Py_TYPE(self)->tp_free((PyObject*)self);\n}\n\nstatic PyObject *\ntgl_Msg_new(PyTypeObject *type, PyObject *args, PyObject *kwds)\n{\n  tgl_Msg *self;\n\n  PyDateTime_IMPORT;\n  self = (tgl_Msg *)type->tp_alloc(type, 0);\n  return (PyObject *)self;\n}\n\nstatic int\ntgl_Msg_init(tgl_Msg *self, PyObject *args, PyObject *kwds)\n{\n  PyErr_SetString(MsgError, \"You cannot instantiate a tgl.Msg object, only the API can send them.\");\n  return -1;\n}\n\nstatic PyObject *\ntgl_Msg_getid (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n\n  ret = PyLong_FromLong(self->msg->id);\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Msg_getflags (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n\n  ret = PyLong_FromLong(self->msg->flags);\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Msg_getmention (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n\n  ret = ((self->msg->flags & TGLMF_MENTION) ? Py_True : Py_False);\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Msg_getout (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n\n  ret = ((self->msg->flags & TGLMF_OUT) ? Py_True : Py_False);\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Msg_getunread (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n\n  ret = ((self->msg->flags & TGLMF_UNREAD) ? Py_True : Py_False);\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Msg_getservice (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n\n  ret = ((self->msg->flags & TGLMF_SERVICE) ? Py_True : Py_False);\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Msg_getaction (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n\n  ret = PyLong_FromLong(self->msg->action.type);\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\n\nstatic PyObject *\ntgl_Msg_getsrc (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n\n  if(tgl_get_peer_type (self->msg->from_id)) {\n    tgl_peer_t *peer = tgl_peer_get (TLS, self->msg->from_id);\n    if(peer)\n      ret = tgl_Peer_FromTglPeer(peer);\n    else {\n      PyErr_SetString(PeerError, \"Cannot Retrieve Peer. Internal tgl error\");\n      Py_RETURN_NONE;\n    }\n\n  } else {\n    Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Msg_getdest (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n\n  if(tgl_get_peer_type (self->msg->to_id)) {\n    tgl_peer_t *peer = tgl_peer_get (TLS, self->msg->to_id);\n    if(peer)\n      ret = tgl_Peer_FromTglPeer(peer);\n    else {\n      PyErr_SetString(PeerError, \"Cannot Retrieve Peer. Internal tgl error\");\n      Py_RETURN_NONE;\n    }\n  } else {\n    Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Msg_gettext (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n\n  if(self->msg->message_len && self->msg->message && !(self->msg->flags & TGLMF_SERVICE)) {\n    ret = PyUnicode_FromStringAndSize(self->msg->message, self->msg->message_len);\n  } else {\n    Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\n\n\nstatic PyObject *\ntgl_Msg_getmedia (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n  \n  // TODO probably want a custom class for media, but it's not too important right now.\n  if(self->msg->media.type && self->msg->media.type != tgl_message_media_none && !(self->msg->flags & TGLMF_SERVICE)) {\n    \n    ret = PyDict_New();\n    switch (self->msg->media.type) {\n    case tgl_message_media_photo:\n      py_add_string_field (ret, \"type\", \"photo\");\n      py_add_string_field (ret, \"caption\", self->msg->media.caption);\n      break;\n    case tgl_message_media_document:\n    case tgl_message_media_document_encr:\n      py_add_string_field (ret, \"type\", \"document\");\n      break;\n    case tgl_message_media_unsupported:\n      py_add_string_field (ret, \"type\", \"unsupported\");\n      break;\n    case tgl_message_media_geo:\n      py_add_string_field (ret, \"type\", \"geo\");\n      py_add_num_field (ret, \"longitude\", self->msg->media.geo.longitude);\n      py_add_num_field (ret, \"latitude\", self->msg->media.geo.latitude);\n      break;\n    case tgl_message_media_contact:\n      py_add_string_field (ret, \"type\", \"contact\");\n      py_add_string_field (ret, \"phone\", self->msg->media.phone);\n      py_add_string_field (ret, \"first_name\", self->msg->media.first_name);\n      py_add_string_field (ret, \"last_name\", self->msg->media.last_name);\n      py_add_num_field (ret, \"user_id\", self->msg->media.user_id);\n      break;\n    case tgl_message_media_webpage:\n      py_add_string_field (ret, \"type\", \"webpage\");\n      py_add_string_field (ret, \"type\", \"webpage\");\n      py_add_string_field (ret, \"url\", self->msg->media.webpage->url);\n      py_add_string_field (ret, \"title\", self->msg->media.webpage->title);\n      py_add_string_field (ret, \"description\", self->msg->media.webpage->description);\n      py_add_string_field (ret, \"author\", self->msg->media.webpage->author);\n      break;\n    case tgl_message_media_venue:\n      py_add_string_field (ret, \"type\", \"venue\");\n      py_add_num_field (ret, \"longitude\", self->msg->media.venue.geo.longitude);\n      py_add_num_field (ret, \"latitude\", self->msg->media.venue.geo.latitude);\n      py_add_string_field (ret, \"title\", self->msg->media.venue.title);\n      py_add_string_field (ret, \"address\", self->msg->media.venue.address);\n      py_add_string_field (ret, \"provider\", self->msg->media.venue.provider);\n      py_add_string_field (ret, \"venue_id\", self->msg->media.venue.venue_id);\n      break;\n    default:\n      py_add_string_field (ret, \"type\", \"unknown\");\n    }\n  } else {\n    Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Msg_getdate (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n\n  if(self->msg->date) {\n    ret = get_datetime(self->msg->date);\n  } else {\n    Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Msg_getfwd_src (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n\n  if(tgl_get_peer_type (self->msg->fwd_from_id)) {\n    tgl_peer_t *peer = tgl_peer_get (TLS, self->msg->fwd_from_id);\n    if(peer)\n      ret = tgl_Peer_FromTglPeer(peer);\n    else {\n      PyErr_SetString(PeerError, \"Cannot Retrieve Peer. Internal tgl error\");\n      Py_RETURN_NONE;\n    }\n  } else {\n    Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Msg_getfwd_date (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n\n  if(tgl_get_peer_type (self->msg->fwd_from_id)) {\n    ret = get_datetime(self->msg->fwd_date);\n  } else {\n    Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Msg_getreply (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n\n  if(self->msg->reply_id) {\n    struct tgl_message *MR = tgl_message_get (TLS, self->msg->reply_id);\n    if(MR) {\n      ret = tgl_Msg_FromTglMsg(MR);\n    } else {\n      Py_RETURN_NONE;\n    }\n  } else {\n    Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\nstatic PyObject *\ntgl_Msg_getreply_id (tgl_Msg *self, void *closure)\n{\n  PyObject *ret;\n\n  if(self->msg->reply_id) {\n    ret = PyLong_FromLong(self->msg->reply_id);\n  } else {\n    Py_RETURN_NONE;\n  }\n\n  Py_XINCREF(ret);\n  return ret;\n}\n\n// All load methods are implemented the same, just alias load_document\nstatic PyObject *\ntgl_Msg_load_document (tgl_Msg *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"callback\", NULL};\n\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"O\", kwlist, &callback)) {\n    PyObject *api_call;\n\n    api_call = Py_BuildValue(\"OO\", (PyObject*) self, callback);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_load_document(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Msg_load_document_thumb (tgl_Msg *self, PyObject *args, PyObject *kwargs)\n{\n  static char *kwlist[] = {\"callback\", NULL};\n\n  PyObject *callback = NULL;\n\n  if(PyArg_ParseTupleAndKeywords(args, kwargs, \"O\", kwlist, &callback)) {\n    PyObject *api_call;\n\n    api_call = Py_BuildValue(\"OO\", (PyObject*) self, callback);\n\n    Py_INCREF(Py_None);\n    Py_XINCREF(api_call);\n\n    return py_load_document_thumb(Py_None, api_call);\n  } else {\n    PyErr_Print();\n    Py_XINCREF(Py_False);\n    return Py_False;\n  }\n\n}\n\nstatic PyObject *\ntgl_Msg_repr(tgl_Msg *self)\n{\n  PyObject *ret;\n#if PY_VERSION_HEX < 0x02070900\n  ret = PyUnicode_FromFormat(\"<tgl.Msg id=%ld>\", self->msg->id);\n#else\n  ret = PyUnicode_FromFormat(\"<tgl.Msg id=%ld, flags=%d, mention=%R, out=%R, unread=%R, service=%R, src=%R, \"\n                             \"dest=%R, text=%R, media=%R, date=%R, fwd_src=%R, fwd_date=%R, reply_id=%R, reply=%R>\",\n                             self->msg->id, self->msg->flags,\n                             PyObject_GetAttrString((PyObject*)self, \"mention\"),\n                             PyObject_GetAttrString((PyObject*)self, \"out\"),\n                             PyObject_GetAttrString((PyObject*)self, \"unread\"),\n                             PyObject_GetAttrString((PyObject*)self, \"service\"),\n                             PyObject_GetAttrString((PyObject*)self, \"src\"),\n                             PyObject_GetAttrString((PyObject*)self, \"dest\"),\n                             PyObject_GetAttrString((PyObject*)self, \"text\"),\n                             PyObject_GetAttrString((PyObject*)self, \"media\"),\n                             PyObject_GetAttrString((PyObject*)self, \"date\"),\n                             PyObject_GetAttrString((PyObject*)self, \"fwd_src\"),\n                             PyObject_GetAttrString((PyObject*)self, \"fwd_date\"),\n                             PyObject_GetAttrString((PyObject*)self, \"reply_id\"),\n                             PyObject_GetAttrString((PyObject*)self, \"reply\")\n        );\n#endif\n  return ret;\n}\n\n\nstatic PyGetSetDef tgl_Msg_getseters[] = {\n  {\"id\", (getter)tgl_Msg_getid, NULL, \"\", NULL},\n  {\"flags\", (getter)tgl_Msg_getflags, NULL, \"\", NULL},\n  {\"mention\", (getter)tgl_Msg_getmention, NULL, \"\", NULL},\n  {\"out\", (getter)tgl_Msg_getout, NULL, \"\", NULL}, \n  {\"unread\", (getter)tgl_Msg_getunread, NULL, \"\", NULL},\n  {\"service\", (getter)tgl_Msg_getservice, NULL, \"\", NULL},\n  {\"src\", (getter)tgl_Msg_getsrc, NULL, \"\", NULL},\n  {\"dest\", (getter)tgl_Msg_getdest, NULL, \"\", NULL},\n  {\"text\", (getter)tgl_Msg_gettext, NULL, \"\", NULL},\n  {\"media\", (getter)tgl_Msg_getmedia, NULL, \"\", NULL},\n  {\"date\", (getter)tgl_Msg_getdate, NULL, \"\", NULL},\n  {\"fwd_src\", (getter)tgl_Msg_getfwd_src, NULL, \"\", NULL},\n  {\"fwd_date\", (getter)tgl_Msg_getfwd_date, NULL, \"\", NULL},\n  {\"reply\", (getter)tgl_Msg_getreply, NULL, \"\", NULL},\n  {\"reply_id\", (getter)tgl_Msg_getreply_id, NULL, \"\", NULL},\n  {\"action\", (getter)tgl_Msg_getaction, NULL, \"\", NULL},\n  {NULL}  /* Sentinel */\n};\n\nstatic PyMemberDef tgl_Msg_members[] = {\n  {NULL}  /* Sentinel */\n};\n\n\n\nstatic PyMethodDef tgl_Msg_methods[] = {\n  {\"load_document\", (PyCFunction)tgl_Msg_load_document, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"load_photo\", (PyCFunction)tgl_Msg_load_document, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"load_audio\", (PyCFunction)tgl_Msg_load_document, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"load_video\", (PyCFunction)tgl_Msg_load_document, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"load_document_thumb\", (PyCFunction)tgl_Msg_load_document_thumb, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {\"load_video_thumb\", (PyCFunction)tgl_Msg_load_document_thumb, METH_VARARGS | METH_KEYWORDS, \"\"},\n  {NULL}  /* Sentinel */\n};\n\n\nPyTypeObject tgl_MsgType = {\n    PyVarObject_HEAD_INIT(NULL, 0)\n    \"tgl.Msg\",                   /* tp_name */\n    sizeof(tgl_Msg),              /* tp_basicsize */\n    0,                            /* tp_itemsize */\n    (destructor)tgl_Msg_dealloc,  /* tp_dealloc */\n    0,                            /* tp_print */\n    0,                            /* tp_getattr */\n    0,                            /* tp_setattr */\n    0,                            /* tp_reserved */\n    (reprfunc)tgl_Msg_repr,      /* tp_repr */\n    0,                            /* tp_as_number */\n    0,                            /* tp_as_sequence */\n    0,                            /* tp_as_mapping */\n    0,                            /* tp_hash  */\n    0,                            /* tp_call */\n    0,                            /* tp_str */\n    0,                            /* tp_getattro */\n    0,                            /* tp_setattro */\n    0,                            /* tp_as_buffer */\n    Py_TPFLAGS_DEFAULT,           /* tp_flags */\n    \"tgl Message\",                /* tp_doc */\n    0,                            /* tp_traverse */\n    0,                            /* tp_clear */\n    0,                            /* tp_richcompare */\n    0,                            /* tp_weaklistoffset */\n    0,                            /* tp_iter */\n    0,                            /* tp_iternext */\n    tgl_Msg_methods,              /* tp_methods */\n    tgl_Msg_members,              /* tp_members */\n    tgl_Msg_getseters,            /* tp_getset */\n    0,                            /* tp_base */\n    0,                            /* tp_dict */\n    0,                            /* tp_descr_get */\n    0,                            /* tp_descr_set */\n    0,                            /* tp_dictoffset */\n    (initproc)tgl_Msg_init,       /* tp_init */\n    0,                            /* tp_alloc */\n    tgl_Msg_new,                  /* tp_new */\n};\n\n\nPyObject *\ntgl_Msg_FromTglMsg(struct tgl_message *msg) {\n  tgl_Msg *self = (tgl_Msg *) tgl_Msg_new((PyTypeObject *)&tgl_MsgType, Py_None, Py_None);\n\n  self->msg = msg;\n  return (PyObject *) self;\n}\n\n#endif\n"
        },
        {
          "name": "python-types.h",
          "type": "blob",
          "size": 0.34375,
          "content": "#ifndef __PYTHON_TYPES_H__\n#define __PYTHON_TYPES_H__\n\n#include <Python.h>\n#include <tgl/tgl.h>\n\ntypedef struct {\n  PyObject_HEAD\n  tgl_peer_t *peer;\n} tgl_Peer;\n\ntypedef struct {\n  PyObject_HEAD\n  struct tgl_message *msg;\n} tgl_Msg;\n\n\nPyObject * tgl_Peer_FromTglPeer(tgl_peer_t *peer);\nPyObject * tgl_Msg_FromTglMsg(struct tgl_message *peer);\n\n#endif\n"
        },
        {
          "name": "rpm",
          "type": "tree",
          "content": null
        },
        {
          "name": "server.pub",
          "type": "blob",
          "size": 0.416015625,
          "content": "-----BEGIN RSA PUBLIC KEY-----\nMIIBCgKCAQEAwVACPi9w23mF3tBkdZz+zwrzKOaaQdr01vAbU4E1pvkfj4sqDsm6\nlyDONS789sVoD/xCS9Y0hkkC3gtL1tSfTlgCMOOul9lcixlEKzwKENj1Yz/s7daS\nan9tqw3bfUV/nqgbhGX81v/+7RFAEd+RwFnK7a+XYl9sluzHRyVVaTTveB2GazTw\nEfzk2DWgkBluml8OREmvfraX3bkHZJTKX4EQSjBbbdJ2ZXIsRrYOXfaA+xayEGB+\n8hdlLmAjbCVfaigxX0CDqWeR1yFL9kwd9P0NsZRPsmoqVwMbMu7mStFai6aIhc3n\nSlv8kg9qv1m6XHVQY3PnEw+QQtqSIXklHwIDAQAB\n-----END RSA PUBLIC KEY-----\n"
        },
        {
          "name": "start-telegram-daemon",
          "type": "blob",
          "size": 5.1689453125,
          "content": "#!/usr/bin/perl -w\n\n# start-engine\n# derived from start-memcached\n# 2003/2004 - Jay Bonci <jaybonci@debian.org>\n# This script handles the parsing of the /etc/memcached.conf file\n# and was originally created for the Debian distribution.\n# Anyone may use this little script under the same terms as\n# memcached itself.\n\n# a bit changed it for telegram-daemon to generate config before start (Vitaly Valtman)\n\nuse POSIX qw(strftime);\nuse strict;\n\nmy $id = defined($ARGV[0]) ? $ARGV[0] : '';\nmy $idx = $id eq '' ? '' : \" '$id'\";\nmy $idl = ($id =~ /^\\.(.*)$/ ? \"-$1\" : $id);\n\nmy $root = \"\";\n\nmy $params; my $etchandle; my $etcfile = \"$root/etc/telegram-daemon/telegram-daemon$id.conf\";\n\n# This script assumes that engine is located at /usr/bin/engine, and\n# that the pidfile is writable at /var/run/engine.pid\n\nmy $engine_pfx = \"$root/usr/share/telegram-daemon/bin/\";\nmy $pidfile = \"$root/var/run/telegram-daemon$id.pid\";\n\n# If we don't get a valid logfile parameter in the /etc/engine.conf file,\n# we'll just throw away all of our in-daemon output. We need to re-tie it so\n# that non-bash shells will not hang on logout. Thanks to Michael Renner for \n# the tip\nmy $fd_reopened = \"/dev/null\";\n$fd_reopened = \"$root/var/log/telegram-daemon/telegram-daemon$idl.log\" if -d \"$root/var/log/telegram-daemon/\";\n\nsub handle_logfile\n{\n    my ($logfile) = @_;\n    $logfile = \"$root/var/log/telegram-daemon/$logfile\" unless $logfile =~ /\\//;\n    $fd_reopened = $logfile;\n}\n\nsub reopen_logfile\n{\n    my ($logfile) = @_;\n    \n    open *STDERR, \">>$logfile\";\n    open *STDOUT, \">>$logfile\";\n    open *STDIN, \">>/dev/null\";\n    chown 239, 239, $logfile;\n    $fd_reopened = $logfile;\n}\n\nsub adjust_arg\n{\n    my ($arg) = @_;\n    if ($arg =~ /^newest:(.*)$/) {\n        my @L = split /:/, $1;\n        my $x = $arg;\n        my $xt = 0;\n        for my $y (@L) {\n            my @S = stat($y);\n            if (scalar @S && $S[9] > $xt) {\n                $x = $y;\n                $xt = $S[9];\n            }\n        }\n        return $x;\n    }\n    return $arg;\n}\n\n# This is set up in place here to support other non -[a-z] directives\n\nmy $conf_directives = {\n        \"logfile\" => \\&handle_logfile,\n};\n\nmy %Vars = ( \n             \"execute\" => \"msg-search-engine\",\n             \"work_dir\"   => \"$root/var/lib/telegram-daemon\"\n             );\n\nmy $have_c = 0;\nmy $have_l = 0;\nmy $have_u = 0;\nmy $have_aes = 0;\n\nif(open $etchandle, $etcfile)\n{\n        foreach my $line (<$etchandle>)\n        {\n                $line ||= \"\";\n                $line =~ s/\\#.*//g;\n                $line =~ s/\\s+$//g;\n                $line =~ s/^\\s+//g;\n                next unless $line;\n                next if $line =~ /^\\-[h]/;\n\n                if($line =~ /^[^\\-]/)\n                {\n                        my ($directive, $int, $arg) = $line =~ /^(.*?)(\\s+|\\s*=\\s*)(.*)/; \n                        next unless $directive;\n                        if (exists $conf_directives->{$directive}) {\n                            $conf_directives->{$directive}->($arg);\n                        } else {\n                            $Vars{$directive} = $arg;\n                        }\n                        next;\n                }\n\n                $have_l = 1 if $line =~ /^-L\\s/;\n                $have_c = 1 if $line =~ /^-c\\s/;\n                $have_u = 1 if $line =~ /^-U\\s/;\n                push @$params, $line;                \n        }\n\n}else{\n        $params = [];\n}\n\npush @$params, \"-U telegramd\" unless($have_u);\npush @$params, \"-L $fd_reopened\" unless($have_l);\npush @$params, \"-c config$idl\" unless($have_c);\n$params = join \" \", @$params;\n\nif(-e $pidfile)\n{\n        open PIDHANDLE, \"$pidfile\";\n        my $localpid = <PIDHANDLE>;\n        close PIDHANDLE;\n\n        if ($localpid && $localpid =~ /(\\d+)/) { $localpid = $1; } else { $localpid = -1; }\n        if (-d \"/proc/$localpid\")\n        {\n                print STDERR \"telegram-daemon$idl is already running.\\n\"; \n                exit;                \n        } else {\n                print STDERR \"removing stale $pidfile.\\n\"; \n                `rm -f $pidfile`;\n        }\n\n}\n\nif (exists $Vars{'quit'}) {\n    print STDERR \"telegram-daemon$idl disabled\\n\";\n    exit(0);\n}\n\nmy $engine = $engine_pfx.$Vars{'execute'};\nmy $wdir = $Vars{'work_dir'};\nchdir $wdir if -d $wdir;\n\nunless (-x $engine) {\n    print STDERR \"executable $engine not found\\n\";\n    exit(1);\n}\n\nunless (-d $wdir) {\n    print STDERR \"work directory $wdir not found\\n\";\n    exit(1);\n}\n\nfor my $x ('s', 0 .. 9) {\n    if (defined($Vars{\"arg$x\"})) {\n        $params .= \" \".adjust_arg($Vars{\"arg$x\"});\n    }\n}\n\nmy $pid = fork();\n\n\n\nif (!$pid) {\n    reopen_logfile ($fd_reopened);\n    chdir $wdir;\n    open(my $fh, '>', \"config$idl\");\n\n    my $text = <<\"END_MSG\"\nconfig_directory=\"$wdir\";\ntest=false;\nmsg_num=true;\nbinlog_enabled=true;\nbinlog=\"binlog$idl.bin\";\npfs_enabled=true;\nlog_level = 0;\nlua_script=\"script$idl.lua\";\nEND_MSG\n;\n    print $fh $text;\n    close $fh;\n    my $t;\n    $t = strftime (\"%Y-%m-%d %H:%M:%S %Z\", localtime);\n    print STDERR \"[$t] invoking telegram-daemon$idl: $engine $params\\n\";\n    exec \"$engine $params\";\n    exit (0);\n} else {\n    if (open PIDHANDLE,\">$pidfile\") {\n        print PIDHANDLE $pid;\n        close PIDHANDLE;\n    } else {\n        print STDERR \"Can't write pidfile to $pidfile.\\n\";\n    }\n}\n\n"
        },
        {
          "name": "telegram-cli-cygwin.patch",
          "type": "blob",
          "size": 1.1064453125,
          "content": "Binary files tg/.git/index and tg-cygwin/.git/index differ\ndiff -urN tg/Makefile tg-cygwin/Makefile\n--- tg/Makefile\t2015-06-16 12:39:34.931053900 +0900\n+++ tg-cygwin/Makefile\t2015-06-16 12:44:12.584342300 +0900\n@@ -4,9 +4,9 @@\n LDFLAGS= -L/usr/local/lib -L/usr/lib -L/usr/lib -L/usr/lib\n CPPFLAGS= -I/usr/local/include -I/usr/include -I/usr/include  -I/usr/include/python3.4m -I/usr/include\n DEFS=-DHAVE_CONFIG_H\n-COMPILE_FLAGS=${CFLAGS} ${CPFLAGS} ${CPPFLAGS} ${DEFS} -Wall -Werror -Wextra -Wno-missing-field-initializers -Wno-deprecated-declarations -fno-strict-aliasing -fno-omit-frame-pointer -ggdb -Wno-unused-parameter -fPIC\n+COMPILE_FLAGS=${CFLAGS} ${CPFLAGS} ${CPPFLAGS} ${DEFS} -Wall -Werror -Wextra -Wno-missing-field-initializers -Wno-deprecated-declarations -fno-strict-aliasing -fno-omit-frame-pointer -ggdb -Wno-unused-parameter\n EXTRA_LIBS=-ljansson -lconfig -lz -levent -lm   -lreadline -llua-5.2  -lpython3.4m -lssl -lcrypto\n-LOCAL_LDFLAGS=-rdynamic -ggdb -levent ${EXTRA_LIBS} -ldl -lpthread -lutil\n+LOCAL_LDFLAGS=-ggdb -levent ${EXTRA_LIBS} -ldl -lpthread -lutil\n LINK_FLAGS=${LDFLAGS} ${LOCAL_LDFLAGS}\n \n DEP=dep\n"
        },
        {
          "name": "telegram-cli.spec",
          "type": "blob",
          "size": 1.0576171875,
          "content": "Name:       \ttelegram-cli\nVersion:\tBeta\nRelease:\t2%{?dist}\nSummary:\tPrivate fast and open platform for instant messaging\n\nPackager: \tPablo Iranzo Gómez (Pablo.Iranzo@gmail.com)\nGroup:\t\tInternet/Messaging\nLicense:\tGPL\nURL:\t\thttps://github.com/vysheng/tg\nSource:\t\tmaster.zip\n\nBuildRequires:\tlua-devel, openssl-devel, libconfig-devel, readline-devel, wget\n#Requires:\twget\n\n%description\nTelegram is an Open Source messaging platform for mobile, desktop focused on privacy.\n\n\n\n\n%prep\n[ -d %{name} ] && rm -Rfv %{name}\nmkdir %{name}\ncd %{name}\nwget -O master.zip https://github.com/vysheng/tg/archive/master.zip\nunzip master.zip\ncd tg-master\n./configure\nmake %{?_smp_mflags}\n\n\n%install\ncd %{name}\ncd tg-master\n%{__install} -D -m0755 telegram %{buildroot}/usr/bin/telegram\n%{__install} -D -m0644 tg-server.pub %{buildroot}/etc/telegram/server.pub\n\n%files\n/usr/bin/telegram\n/etc/telegram/server.pub\n\n%changelog\n* Tue Feb 4 2014 Pablo Iranzo Gómez (Pablo.Iranzo@gmail.com)\n- Add server key to /etc/telegram/\n* Sat Feb 1 2014 Pablo Iranzo Gómez (Pablo.Iranzo@gmail.com)\n- Initial SPEC file\n"
        },
        {
          "name": "telegram-daemon",
          "type": "blob",
          "size": 8.1552734375,
          "content": "#!/bin/bash\n\n### BEGIN INIT INFO\n# Provides:\t\tengine\n# Required-Start:\t$local_fs $syslog\n# Required-Stop:\t$local_fs $syslog\n# Default-Start:\t2 3 4 5\n# Default-Stop:\t\t0 1 6\n# Short-Description:\tKittenDB Meta Engine\n### END INIT INFO\n\n#\n# run script for KittenDB Engine\n# author: kot\n# author: burunduk\n# author: burunduk\n#\n# Version: 2013-06-06\n#\n\n# Features added:\n# -- flock to avoid parallel execution\n# -- checks to avoid creating empty engine configuration files\n\n\n# a bit changed it for telegram-daemon to use different folders \n# and to have posiiblilities to have fake root\n# Vitaly Valtman\n\nROOT=\"\"\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\nDAEMONDIR=$ROOT/usr/share/telegram-daemon/bin\nDAEMONBOOTSTRAP=$ROOT/usr/share/telegram-daemon/bin/start-telegram-daemon\nNAME=telegram-daemon\nDESC=\"KOT's meta engine\"\nPIDFILE=$ROOT/var/run/$NAME\nLOCKFILE=$ROOT/var/lock/$NAME\nCONFFILE=$ROOT/etc/telegram-daemon/$NAME\nLOCK_WAIT=5\nSTOP_TIMEOUT=5\nKILL_TIMEOUT=5\n\ntest -x $DAEMONDIR || exit 0\ntest -x $DAEMONBOOTSTRAP || exit 0\n\nset -e\n\n## Utilitary functions\n\n# Send information to stderr\nfunction echo_stderr() {\n    echo \"$*\" 1>&2\n}\n\n# Get engine status. Returns 0 on running engine, 1 otherwise.\nfunction engine_status() {\n    local id=\"$1\"\n    local pif=\"$PIDFILE.$id.pid\"\n    if ! [ -f \"$pif\" ] ; then\n        echo \"stopped\"\n        return 1\n    fi\n    local pid=\"$(<$pif)\"\n    if [ -z \"$pid\" ]; then\n        echo \"corrupt pid file\"\n        return 1\n    fi\n    if [ -d \"/proc/$pid/\" ]; then\n        echo \"$pid\"\n        return 0\n    else\n        echo \"failed (pid $pid)\"\n        return 1\n    fi\n}\n\n# Start engine. Usage: engine_start <eid>\nfunction engine_start() {\n    local eid=\"$1\"\n    local r=''\n    local pid=''\n    pid=\"$(engine_status \"$eid\")\" && r='ok' || r='fail'\n    if [ \"$r\" == 'ok' ] ; then\n        echo_stderr \"telegram-daemon-$eid: already running ($pid)\"\n    else\n        start-stop-daemon --start --quiet --exec $DAEMONBOOTSTRAP -- .$eid 100> /dev/null\n    fi\n    return 0\n}\n\n# Stop engine. Usage: engine_stop <eid>\nfunction engine_stop() {\n    local eid=\"$1\"\n    local r=''\n    local status=\"$(engine_status \"$eid\")\" && r='ok' || r='fail'\n    local pif=\"$PIDFILE.$eid.pid\"\n    if [ \"$r\" == 'ok' ] ; then\n        start-stop-daemon --stop --quiet --oknodo --pidfile \"$pif\"\n        local ti=0\n        while [ $ti -lt $((10 * $STOP_TIMEOUT)) ] ; do\n            status=\"$(engine_status \"$eid\")\" && r='ok' || r='fail'\n            if [ \"$r\" == 'fail' ]; then\n                break\n            fi\n            sleep 0.1\n            ti=$(($ti + 1))\n        done\n        if [ \"$r\" == 'ok' ] ; then\n            echo_stderr \"telegram-daemon-$eid: not stopped, sending SIGKILL...\"\n            start-stop-daemon --stop --quiet --oknodo --pidfile \"$pif\" --signal KILL\n            ti=0\n            while [ $ti -lt $((10 * $KILL_TIMEOUT)) ] ; do\n                status=\"$(engine_status \"$eid\")\" && r='ok' || r='fail'\n                if [ \"$r\" == 'fail' ]; then\n                    break\n                fi\n                sleep 0.1\n                ti=$(($ti + 1))\n            done\n        fi\n        if [ \"$r\" == 'ok' ] ; then\n            echo_stderr \"telegram-daemon-$eid: not stopped with SIGKILL, giving up\"\n            return 1\n        else\n            if [ -f \"$pif\" ] ; then\n              rm \"$pif\"\n            fi\n            echo \"telegram-daemon-$eid: stopped\"\n        fi\n    else\n        echo_stderr \"telegram-daemon-$eid: not running: $status\"\n    fi\n    return 0\n}\n\n# usage: engine_disable <id>\nfunction engine_disable() {\n    local eid=\"$1\"\n    local conf=\"$CONFFILE.$eid.conf\"\n    [ -e \"$conf\" ] || return 1 # work only with existing engines\n    if grep -E '^quit 1$' \"$conf\" > /dev/null ; then\n        echo_stderr \"telegram-daemon-$eid: already disabled\"\n    else\n        echo 'quit 1' >> \"$conf\"\n    fi\n    return 0\n}\n\n# usage: engine_enable <id>\nfunction engine_enable() {\n    local eid=\"$1\"\n    local conf=\"$CONFFILE.$eid.conf\"\n    [ -e \"$conf\" ] || return 1 # work only with existing engines\n    if ! grep -E '^quit' \"$conf\" > /dev/null ; then\n        echo_stderr \"telegram-daemon-$eid: already enabled\"\n    else\n        sed -i~ -e '/^quit/d' -- \"$conf\"\n    fi\n    return 0\n}\n\n# Wait for engine's command to be completed\nfunction engine_wait() {\n    local eid=\"$1\"\n    (\n        flock -x -w $(($LOCK_WAIT + $STOP_TIMEOUT + $KILL_TIMEOUT)) 100 || exit 1\n    ) 100> $LOCKFILE.$eid.lock || echo \"Unable to wait for $eid\"\n    return 0\n}\n\n# Run a single command\n# Only one instance of this command per engine is supposed to work\nfunction run_one() {\n    local eid=\"$1\"\n    shift\n    local command=\"$*\"\n    [ \"${#eid}\" -gt 5 ] && return 0 # avoid long engine ids\n    (\n        flock -x -w $LOCK_WAIT 100 || exit 1\n        $command \"$eid\"\n    ) 100> $LOCKFILE.$eid.lock\n    return 0\n}\n\n# Run commands\nfunction run() {\n    local mode=\"$1\"\n    shift\n    local command=\"$*\"\n    local eid=''\n    if [ \"$mode\" == 'parallel' ] ; then\n        for eid in $arguments ; do\n            run_one \"$eid\" \"$command\" &\n        done\n        sleep 0.1\n        for eid in $arguments ; do\n            engine_wait \"$eid\"\n        done\n    else\n        for eid in $arguments ; do\n            run_one \"$eid\" \"$command\"\n        done\n    fi\n    return 0\n}\n\n# Get all actual engine ids\nfunction arguments_all() {\n    local file=''\n    local id=''\n    local list=''\n    for file in $(ls $CONFFILE.?*.conf 2> /dev/null) ; do\n        id=${file#$CONFFILE.}\n        id=${id%.conf}\n        list=\"$list $id\"\n    done\n    for file in $(ls $PIDFILE.?*.pid 2> /dev/null) ; do\n        id=${file#$PIDFILE.}\n        id=${id%.pid}\n        list=\"$list $id\"\n    done\n    local f=''\n    for f in $list ; do echo \"$f\" ; done | sort -u\n    return 0\n}\n\n## Commands\n\n# Start engine.\nfunction engine_command_start() {\n    local eid=\"$1\"\n    engine_start \"$eid\"\n}\n\n# Stop engine.\nfunction engine_command_stop() {\n    local eid=\"$1\"\n    engine_stop \"$eid\"\n}\n\n# Enable engine.\nfunction engine_command_enable() {\n    local eid=\"$1\"\n    engine_enable \"$eid\"\n    engine_start \"$eid\"\n}\n\n# Disable engine.\nfunction engine_command_disable() {\n    local eid=\"$1\"\n    engine_disable \"$eid\"\n    engine_stop \"$eid\"\n}\n\n# Restart engine.\nfunction engine_command_restart() {\n    local eid=\"$1\"\n    engine_stop \"$eid\"\n    echo \"restarting telegram-daemon-$eid...\"\n    engine_start \"$eid\"\n}\n\n# Send signal to engine. Usage: engine_command_signal <signal> <id>\nfunction engine_command_signal() {\n    local id=\"$2\"\n    local signal=\"$1\"\n    local r=''\n    local comment=\"$(engine_status \"$id\")\" && r='ok' || r='fail'\n    local res=''\n    if [ \"$r\" == 'ok' ]; then\n        start-stop-daemon --stop --quiet --oknodo --pidfile $PIDFILE.$id.pid --signal \"$signal\"\n    else\n        echo_stderr \"telegram-daemon-$id: not running: $comment\"\n    fi\n    return 0\n}\n\n# Get engine status\nfunction engine_command_status() {\n    local id=\"$1\"\n    local res=\"telegram-daemon-$id: \"\n    local r=''\n    local pid=''\n    pid=\"$(engine_status \"$id\")\" && r='ok' || r='fail'\n    if [ \"$r\" == 'ok' ]; then\n        res=\"$res $(COLUMNS=10000 ps -o pid,c,stime,time,cmd --no-header --pid $pid | sed -e 's/\\/usr\\/share\\/telegram-daemon\\/bin\\///')\"\n    else\n        res=\"$res $pid\"\n    fi\n    echo \"$res\"\n    return 0\n}\n\n## Entry point\n\ncommand=\"$1\"\nshift\n\narguments=\"$*\"\nif [ -z \"$arguments\" ] ; then\n    if [ \"$command\" == \"status\" -o \"$command\" == \"start\" -o \"$command\" == \"rotate-logs\" -o \"$command\" == \"stop\" ] ; then\n        arguments=\"$(arguments_all)\"\n    fi\nelif [ \"$arguments\" == \"all\" ] ; then\n    arguments=\"$(arguments_all)\"\nfi\nif [ -z \"$arguments\" ] ; then\n    echo \"nothing to do\"\n    exit 0\nfi\n\ncase \"$command\" in\n    ('disable') run parallel engine_command_disable ;;\n    ('enable') run parallel engine_command_enable ;;\n    #\n    ('start') run parallel engine_command_start ;;\n    ('status') run normal engine_command_status ;;\n    ('stop') run parallel engine_command_stop ;;\n    #\n    ('rotate-logs') run parallel engine_command_signal USR1 ;;\n    #\n    ('restart'|'force-reload') run parallel engine_command_restart ;;\n    (*)\n        N=/etc/init.d/$NAME\n        echo \"Usage: $N {start|stop|restart|rotate-logs|status} [<ids...>|all]\" >&2\n        echo \"  additional commands: disable <ids...>, enable <ids...>, reindex <ids...> (use with caution)\" >&2\n        exit 1\n        ;;\nesac\n\nexit 0\n\n"
        },
        {
          "name": "telegram.h",
          "type": "blob",
          "size": 0.8203125,
          "content": "/*\n    This file is part of telegram-cli.\n\n    Telegram-cli is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 2 of the License, or\n    (at your option) any later version.\n\n    Telegram-cli is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this telegram-cli.  If not, see <http://www.gnu.org/licenses/>.\n\n    Copyright Vitaly Valtman 2013-2015\n*/\n\n#ifndef PROG_NAME\n#define PROG_NAME \"telegram-cli\"\n#endif\n\n#define TELEGRAM_CLI_VERSION \"1.4.1\"\n"
        },
        {
          "name": "test.lua",
          "type": "blob",
          "size": 2.5107421875,
          "content": "started = 0\nour_id = 0\n\nfunction vardump(value, depth, key)\n  local linePrefix = \"\"\n  local spaces = \"\"\n  \n  if key ~= nil then\n    linePrefix = \"[\"..key..\"] = \"\n  end\n  \n  if depth == nil then\n    depth = 0\n  else\n    depth = depth + 1\n    for i=1, depth do spaces = spaces .. \"  \" end\n  end\n  \n  if type(value) == 'table' then\n    mTable = getmetatable(value)\n    if mTable == nil then\n      print(spaces ..linePrefix..\"(table) \")\n    else\n      print(spaces ..\"(metatable) \")\n        value = mTable\n    end\t\t\n    for tableKey, tableValue in pairs(value) do\n      vardump(tableValue, depth, tableKey)\n    end\n  elseif type(value)\t== 'function' or \n      type(value)\t== 'thread' or \n      type(value)\t== 'userdata' or\n      value\t\t== nil\n  then\n    print(spaces..tostring(value))\n  else\n    print(spaces..linePrefix..\"(\"..type(value)..\") \"..tostring(value))\n  end\nend\n\nprint (\"HI, this is lua script\")\n\nfunction ok_cb(extra, success, result)\nend\n\n-- Notification code {{{\n\nfunction get_title (P, Q)\n  if (Q.type == 'user') then\n    return P.first_name .. \" \" .. P.last_name\n  elseif (Q.type == 'chat') then\n    return Q.title\n  elseif (Q.type == 'encr_chat') then\n    return 'Secret chat with ' .. P.first_name .. ' ' .. P.last_name\n  else\n    return ''\n  end\nend\n\nlocal lgi = require ('lgi')\nlocal notify = lgi.require('Notify')\nnotify.init (\"Telegram updates\")\nlocal icon = os.getenv(\"HOME\") .. \"/.telegram-cli/telegram-pics/telegram_64.png\"\n\nfunction do_notify (user, msg)\n  local n = notify.Notification.new(user, msg, icon)\n  n:show ()\nend\n\n-- }}}\n\nfunction on_msg_receive (msg)\n  if started == 0 then\n    return\n  end\n  if msg.out then\n    return\n  end\n  do_notify (get_title (msg.from, msg.to), msg.text)\n\n  if (msg.text == 'ping') then\n    if (msg.to.id == our_id) then\n      send_msg (msg.from.print_name, 'pong', ok_cb, false)\n    else\n      send_msg (msg.to.print_name, 'pong', ok_cb, false)\n    end\n    return\n  end\n  if (msg.text == 'PING') then\n    if (msg.to.id == our_id) then\n      fwd_msg (msg.from.print_name, msg.id, ok_cb, false)\n    else\n      fwd_msg (msg.to.print_name, msg.id, ok_cb, false)\n    end\n    return\n  end\nend\n\nfunction on_our_id (id)\n  our_id = id\nend\n\nfunction on_user_update (user, what)\n  --vardump (user)\nend\n\nfunction on_chat_update (chat, what)\n  --vardump (chat)\nend\n\nfunction on_secret_chat_update (schat, what)\n  --vardump (schat)\nend\n\nfunction on_get_difference_end ()\nend\n\nfunction cron()\n  -- do something\n  postpone (cron, false, 1.0)\nend\n\nfunction on_binlog_replay_end ()\n  started = 1\n  postpone (cron, false, 1.0)\nend\n"
        },
        {
          "name": "tg-server.pub",
          "type": "blob",
          "size": 0.4169921875,
          "content": "-----BEGIN RSA PUBLIC KEY-----\nMIIBCgKCAQEAwVACPi9w23mF3tBkdZz+zwrzKOaaQdr01vAbU4E1pvkfj4sqDsm6\nlyDONS789sVoD/xCS9Y0hkkC3gtL1tSfTlgCMOOul9lcixlEKzwKENj1Yz/s7daS\nan9tqw3bfUV/nqgbhGX81v/+7RFAEd+RwFnK7a+XYl9sluzHRyVVaTTveB2GazTw\nEfzk2DWgkBluml8OREmvfraX3bkHZJTKX4EQSjBbbdJ2ZXIsRrYOXfaA+xayEGB+\n8hdlLmAjbCVfaigxX0CDqWeR1yFL9kwd9P0NsZRPsmoqVwMbMu7mStFai6aIhc3n\nSlv8kg9qv1m6XHVQY3PnEw+QQtqSIXklHwIDAQAB\n-----END RSA PUBLIC KEY-----\n\n"
        },
        {
          "name": "tg-test.py",
          "type": "blob",
          "size": 1.416015625,
          "content": "import tgl\nimport pprint\nfrom functools import partial\n\n\nour_id = 0\npp = pprint.PrettyPrinter(indent=4)\n\nbinlog_done = False;\n\ndef on_binlog_replay_end():\n    binlog_done = True;\n\ndef on_get_difference_end():\n    pass\n\ndef on_our_id(id):\n    our_id = id\n    return \"Set ID: \" + str(our_id)\n\ndef msg_cb(success, msg):\n    pp.pprint(success)\n    pp.pprint(msg)\n\nHISTORY_QUERY_SIZE = 100\n\ndef history_cb(msg_list, peer, success, msgs):\n  print(len(msgs))\n  msg_list.extend(msgs)\n  print(len(msg_list))\n  if len(msgs) == HISTORY_QUERY_SIZE:\n    tgl.get_history(peer, len(msg_list), HISTORY_QUERY_SIZE, partial(history_cb, msg_list, peer));\n\n\ndef cb(success):\n    print(success)\n\ndef on_msg_receive(msg):\n    if msg.out and not binlog_done:\n      return;\n\n    if msg.dest.id == our_id: # direct message\n      peer = msg.src\n    else: # chatroom\n      peer = msg.dest\n\n    pp.pprint(msg)\n    if msg.text.startswith(\"!ping\"):\n      peer.send_msg(\"PONG! google.com\", preview=False, reply=msg.id)\n\n\ndef on_secret_chat_update(peer, types):\n    return \"on_secret_chat_update\"\n\ndef on_user_update():\n    pass\n\ndef on_chat_update():\n    pass\n\n# Set callbacks\ntgl.set_on_binlog_replay_end(on_binlog_replay_end)\ntgl.set_on_get_difference_end(on_get_difference_end)\ntgl.set_on_our_id(on_our_id)\ntgl.set_on_msg_receive(on_msg_receive)\ntgl.set_on_secret_chat_update(on_secret_chat_update)\ntgl.set_on_user_update(on_user_update)\ntgl.set_on_chat_update(on_chat_update)\n\n"
        },
        {
          "name": "tgl",
          "type": "commit",
          "content": null
        }
      ]
    }
  ]
}