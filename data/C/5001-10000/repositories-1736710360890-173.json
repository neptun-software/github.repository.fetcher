{
  "metadata": {
    "timestamp": 1736710360890,
    "page": 173,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "libfuse/libfuse",
      "stars": 5438,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".ackrc",
          "type": "blob",
          "size": 0.0400390625,
          "content": "--ignore-dir=build\n--ignore-dir=doc/html\n"
        },
        {
          "name": ".cirrus.yml",
          "type": "blob",
          "size": 0.333984375,
          "content": "# Build libfuse on FreeBSD, but don't run the tests.\n# More work is required to make the tests work.\ntask:\n  name: FreeBSD\n  freebsd_instance:\n    image: freebsd-12-1-release-amd64\n  install_script: ASSUME_ALWAYS_YES=yes pkg bootstrap -f; pkg install -y meson ninja\n  script:\n    - mkdir build\n    - cd build\n    - meson setup ..\n    - ninja\n"
        },
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 3.23828125,
          "content": "# SPDX-License-Identifier: GPL-2.0\n#\n# clang-format configuration file. Intended for clang-format >= 11.\n#\n# For more information, see:\n#\n#   Documentation/process/clang-format.rst\n#   https://clang.llvm.org/docs/ClangFormat.html\n#   https://clang.llvm.org/docs/ClangFormatStyleOptions.html\n#\n---\nAccessModifierOffset: -4\nAlignAfterOpenBracket: Align\nAlignConsecutiveAssignments: false\nAlignConsecutiveDeclarations: false\nAlignEscapedNewlines: Left\nAlignOperands: true\nAlignTrailingComments: false\nAllowAllParametersOfDeclarationOnNextLine: false\nAllowShortBlocksOnASingleLine: false\nAllowShortCaseLabelsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: None\nAllowShortIfStatementsOnASingleLine: false\nAllowShortLoopsOnASingleLine: false\nAlwaysBreakAfterDefinitionReturnType: None\nAlwaysBreakAfterReturnType: None\nAlwaysBreakBeforeMultilineStrings: false\nAlwaysBreakTemplateDeclarations: false\nBinPackArguments: true\nBinPackParameters: true\nBraceWrapping:\n  AfterClass: false\n  AfterControlStatement: false\n  AfterEnum: false\n  AfterFunction: true\n  AfterNamespace: true\n  AfterObjCDeclaration: false\n  AfterStruct: false\n  AfterUnion: false\n  AfterExternBlock: false\n  BeforeCatch: false\n  BeforeElse: false\n  IndentBraces: false\n  SplitEmptyFunction: true\n  SplitEmptyRecord: true\n  SplitEmptyNamespace: true\nBreakBeforeBinaryOperators: None\nBreakBeforeBraces: Custom\nBreakBeforeInheritanceComma: false\nBreakBeforeTernaryOperators: false\nBreakConstructorInitializersBeforeComma: false\nBreakConstructorInitializers: BeforeComma\nBreakAfterJavaFieldAnnotations: false\nBreakStringLiterals: false\nColumnLimit: 80\nCommentPragmas: '^ IWYU pragma:'\nCompactNamespaces: false\nConstructorInitializerAllOnOneLineOrOnePerLine: false\nConstructorInitializerIndentWidth: 8\nContinuationIndentWidth: 8\nCpp11BracedListStyle: false\nDerivePointerAlignment: false\nDisableFormat: false\nExperimentalAutoDetectBinPacking: false\nFixNamespaceComments: false\n\nIncludeBlocks: Preserve\nIncludeCategories:\n  - Regex: '.*'\n    Priority: 1\nIncludeIsMainRegex: '(Test)?$'\nIndentCaseLabels: false\nIndentGotoLabels: false\nIndentPPDirectives: None\nIndentWidth: 8\nIndentWrappedFunctionNames: false\nJavaScriptQuotes: Leave\nJavaScriptWrapImports: true\nKeepEmptyLinesAtTheStartOfBlocks: false\nMacroBlockBegin: ''\nMacroBlockEnd: ''\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nObjCBinPackProtocolList: Auto\nObjCBlockIndentWidth: 8\nObjCSpaceAfterProperty: true\nObjCSpaceBeforeProtocolList: true\n\n# Taken from git's rules\nPenaltyBreakAssignment: 10\nPenaltyBreakBeforeFirstCallParameter: 30\nPenaltyBreakComment: 10\nPenaltyBreakFirstLessLess: 0\nPenaltyBreakString: 10\nPenaltyExcessCharacter: 100\nPenaltyReturnTypeOnItsOwnLine: 60\n\nPointerAlignment: Right\nReflowComments: false\nSortIncludes: false\nSortUsingDeclarations: false\nSpaceAfterCStyleCast: false\nSpaceAfterTemplateKeyword: true\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeCtorInitializerColon: true\nSpaceBeforeInheritanceColon: true\nSpaceBeforeParens: ControlStatementsExceptForEachMacros\nSpaceBeforeRangeBasedForLoopColon: true\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 1\nSpacesInAngles: false\nSpacesInContainerLiterals: false\nSpacesInCStyleCastParentheses: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard: Cpp03\nTabWidth: 8\nUseTab: Always\n...\n"
        },
        {
          "name": ".codespellrc",
          "type": "blob",
          "size": 0.4228515625,
          "content": "[codespell]\nskip = .git,*.pdf,*.svg,AUTHORS\n\n# The following strings shouldn't actually be accepted, but they're wrongly\n# identified as words and there is currently no way to exclude them on\n# a by-line basis (https://github.com/codespell-project/codespell/pull/2400).\n# Therefore, pretend that they are correctly spelled words:\n# - alse: used in regex\n# - siz:  wanted short\n# - fiter:  variable\nignore-words-list = alse,siz,fiter\n"
        },
        {
          "name": ".dir-locals.el",
          "type": "blob",
          "size": 1.751953125,
          "content": "((python-mode . ((indent-tabs-mode . nil)))\n (autoconf-mode . ((indent-tabs-mode . t)))\n (c++-mode . ((c-file-style . \"k&r\")\n              (indent-tabs-mode . nil)\n              (c-basic-offset . 4)\n              (c-file-offsets .\n                              ((block-close . 0)\n                               (brace-list-close . 0)\n                               (brace-list-entry . 0)\n                               (brace-list-intro . +)\n                               (case-label . 0)\n                               (class-close . 0)\n                               (defun-block-intro . +)\n                               (defun-close . 0)\n                               (defun-open . 0)\n                               (else-clause . 0)\n                               (inclass . +)\n                               (label . 0)\n                               (statement . 0)\n                               (statement-block-intro . +)\n                               (statement-case-intro . +)\n                               (statement-cont . +)\n                               (substatement . +)\n                               (topmost-intro . 0)))))\n (c-mode . ((c-file-style . \"stroustrup\")\n\t    (indent-tabs-mode . t)\n\t    (tab-width . 8)\n\t    (c-basic-offset . 8)\n\t    (c-file-offsets .\n\t\t\t    ((block-close . 0)\n\t\t\t     (brace-list-close . 0)\n\t\t\t     (brace-list-entry . 0)\n\t\t\t     (brace-list-intro . +)\n\t\t\t     (case-label . 0)\n\t\t\t     (class-close . 0)\n\t\t\t     (defun-block-intro . +)\n\t\t\t     (defun-close . 0)\n\t\t\t     (defun-open . 0)\n\t\t\t     (else-clause . 0)\n\t\t\t     (inclass . +)\n\t\t\t     (label . 0)\n\t\t\t     (statement . 0)\n\t\t\t     (statement-block-intro . +)\n\t\t\t     (statement-case-intro . +)\n\t\t\t     (statement-cont . +)\n\t\t\t     (substatement . +)\n\t\t\t     (topmost-intro . 0))))))\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.5693359375,
          "content": "#\n# NOTE! Don't add files that are generated in specific\n# subdirectories here. Add them in the \".gitignore\" file\n# in that subdirectory instead.\n#\n# NOTE! Please use 'git ls-files -i --exclude-standard'\n# command after changing this file, to see if there are\n# any tracked files which get ignored after the change.\n*.o\n*.lo\n*.la\n*.gz\n\\#*#\n*.orig\n*~\nMakefile.in\nMakefile\n*.m4\nstamp-h*\nconfig.*\n/ltmain.sh\n/configure\n/install-sh\n/mkinstalldirs\n/missing\n/*.cache\n/depcomp\n/compile\n/libtool\n/INSTALL\n/*.pc\n/.pc\n/patches*\n/m4\nTAGS\n/GPATH\n/GRTAGS\n/GSYMS\n/GTAGS\n/test/test_setattr\n/build/\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 9.59765625,
          "content": "Current Maintainers\n------------------\n\nBernd Schubert <bernd.schubert@fastmail.fm>\nAshley Pittman <ashley@pittman.co.uk>\nAntonio SJ Musumeci <trapexit@spawn.link>\n\n\nPast Maintainers\n----------------\n\nNikolaus Rath <Nikolaus@rath.org> (until 02/2024)\nMiklos Szeredi <miklos@szeredi.hu> (until 12/2015)\n\n\nContributors\n------------\n\nCUSE has been written by Tejun Heo <teheo@suse.de>. Furthermore, the\nfollowing people have contributed patches (autogenerated list):\n\n\n1c7718e7 <shirokovMartin@gmail.com>\na1346054 <36859588+a1346054@users.noreply.github.com>\nadmorgan <admorgan@morgancomputers.net>\nAhmed Masud <ahmed.masud@trustifier.com>\nAKowshik <AKowshik@users.noreply.github.com>\nAlan Somers <asomers@gmail.com>\nAlbert Chen <58009229+hselin-kalista-io@users.noreply.github.com>\nAlbert Chen <hselin.chen@gmail.com>\nAleksandr Mikhailov <AM5800@users.noreply.github.com>\nAlexander <aleksandr.rvachev@eltex-co.ru>\nalex <devkral@web.de>\nAlex Richman <alex@richman.io>\nAmir Goldstein <amir73il@gmail.com>\namosonn <amosonn@gmail.com>\nAnatol Pomozov <anatol.pomozov@gmail.com>\nAndré Schröder <andre.schroeder@andresco.de>\nAndrew Gaul <andrew@gaul.org>\nAndrew Gaul <gaul@google.com>\nAngelo G. Del Regno <kholk11@gmail.com>\nAnthony Rebello <rebello.anthony@gmail.com>\nAntonio SJ Musumeci <trapexit@spawn.link>\nArunav Sanyal <Khalian@users.noreply.github.com>\nasafkahlon <35964924+asafkahlon@users.noreply.github.com>\nAshley Pittman <ashleypittman@users.noreply.github.com>\nAsumFace <asumface@gmail.com>\nBanglang <banglang.huang@foxmail.com>\nBaptiste Daroussin <bapt@FreeBSD.org>\nBenjamin Barenblat <bbaren@google.com>\nBernd Schubert <bernd.schubert@fastmail.fm>\nBernd Schubert <bschubert@ddn.com>\nBill Zissimooulos <billziss@navimatics.com>\nBill Zissimopoulos <billziss@navimatics.com>\nbobrofon <ifbossfor@ya.ru>\nBrian Naylor <bnaylor@netapp.com>\nCarl Edquist <edquist@cs.wisc.edu>\nCarlos Maiolino <cmaiolino-H+wXaHxf7aLQT0dZR+AlfA@public.gmane.org>\nChad Austin <chad@chadaustin.me>\nChangli Gao <xiaosuo@gmail.com>\nChristian Menges <christian.menges@tum.de>\nChristopher Harrison <ch12@sanger.ac.uk>\nCiaran <ciaran@hypokrites.me>\nConsus <consus@gmx.com>\nCraig Chi <craig08@users.noreply.github.com>\nCsaba Henk <csaba.henk@creo.hu>\nCsaba Henk <csaba@lowlife.hu>\ncvs2git <>\nDalvik Khertel <khertel@outlook.com>\nDaniel Fullmer <danielrf12@gmail.com>\nDaniel Thau <danthau@bedrocklinux.org>\nDavid Galeano <davidgaleano@gmail.com>\nDavid McNab <david@rebirthing.co.nz>\nDavid Sheets <sheets@alum.mit.edu>\ndependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>\nDharmendra singh <dsingh@ddn.com>\nDharmendra Singh <dsingh@ddn.com>\ndivinity76 <divinity76@gmail.com>\nDrDaveD <2129743+DrDaveD@users.noreply.github.com>\nDr. David Alan Gilbert <dgilbert@redhat.com>\nEmily Herbert <emilyherbert@cs.umass.edu>\nEmmanuel Dreyfus <manu@netbsd.org>\nEnke Chen <enkechen@yahoo.com>\nEric Engestrom <eric@engestrom.ch>\nEric Wong <normalperson@yhbt.net>\nEtienne Dublé <etienne.duble@imag.fr>\nFabian Vogt <fabian@ritter-vogt.de>\nFabrice Bauzac <fbauzac@amadeus.com>\nFabrice Fontaine <fontaine.fabrice@gmail.com>\nFedor Korotkov <fedor.korotkov@gmail.com>\nFeng Shuo <steve.shuo.feng@gmail.com>\nferivoz <72023087+ferivoz@users.noreply.github.com>\nFeverfew <Feverfew@users.noreply.github.com>\nFina Wilke <code@felinira.net>\nFlorian Weimer <fw@deneb.enyo.de>\nForty-Bot <Forty-Bot@users.noreply.github.com>\nFrank Dinoff <fdinoff@google.com>\nGiulio Benetti <giulio.benetti@benettiengineering.com>\nGiuseppe Scrivano <giuseppe@scrivano.org>\nGoswin von Brederlow <goswin-v-b@web.de>\nguraga <rulumasi@dodsi.com>\nHazelFZ <xfzfygz@gmail.com>\nHeiko Becker <heirecka@exherbo.org>\nHendrik Brueckner <brueckner@linux.vnet.ibm.com>\nHereThereBeDragons <HereThereBeDragons@users.noreply.github.com>\nHookey <Hookey@users.noreply.github.com>\nhuman <human@neet.fi>\nikbenlike <ikbenlike@users.noreply.github.com>\nIkey Doherty <michael.i.doherty@intel.com>\nitsdeepak <deepak.sn@samsung.com>\nJan Blumschein <jan@jan-blumschein.de>\nJann Horn <jannh@google.com>\nJay Hankins <jay-hankins@users.noreply.github.com>\nJean-Pierre André <jpandre@users.noreply.github.com>\nJean-Yves VET <jyvet@users.noreply.github.com>\nJérémie Galarneau <jeremie.galarneau@gmail.com>\nJoachim Schiele <joachim.schiele@daimler.com>\nJoachim Schiele <js@lastlog.de>\nJoerg Thalheim <joerg@thalheim.io>\nJohn Baber-Lucero <github@frundle.com>\nJohn Muir <john@jmuir.com>\nJoseph Dodge <joseph.dodge@veritas.com>\nJosh Soref <jsoref@users.noreply.github.com>\nJunichi Uekawa <dancer@debian.org>\nJunichi Uekawa <dancerj@gmail.com>\nJunichi Uekawa <dancer@netfort.gr.jp>\nKangjing \"Chaser\" Huang <huangkangjing@gmail.com>\nKen Schalk <kcs-github@xorian.net>\nKevin Vigor <kvigor@fb.com>\nKirill Smelkov <kirr@nexedi.com>\nKyle Lippincott <spectral@google.com>\nLaszlo Boszormenyi (GCS) <gcs@debian.org>\nLaszlo Papp <ext-laszlo.papp@nokia.com>\nLaurent Bigonville <bigon@users.noreply.github.com>\nLilo Huang <lilohuang@users.noreply.github.com>\nLiu Bo <liub.liubo@gmail.com>\nLi-Wen Hsu <lwhsu.github@lwhsu.org>\nlixiaokeng <63774002+lixiaokeng@users.noreply.github.com>\nlixiaokeng <lixiaokeng@huawei.com>\nLuis Henriques <luis-henrix@users.noreply.github.com>\nMadan Valluri <mvalluri@cumulus-systems.com>\nManuel Jacob <me@manueljacob.de>\nMarcin Sulikowski <marcin.sulikowski@editshare.com>\nMark Glines <mark@glines.org>\nMartin Blanchard <tchaik@gmx.com>\nMartin Pärtel <martin.partel@gmail.com>\nMateusz Urbańczyk <murbanczyk@qed.ai>\nMatthias Goergens <matthias.goergens@gmail.com>\nMatthias Görgens <matthias.goergens@gmail.com>\nMattias Nissler <mnissler@chromium.org>\nmaxice8 <30738253+maxice8@users.noreply.github.com>\nMaximilian Heinzler <m.heinzler@heinzler.de>\nMax Krasnyansky <maxk@kernel.org>\nMichael Forney <mforney@mforney.org>\nMichael Grigoriev <mag@luminal.org>\nMihail Konev <k.mvc@ya.ru>\nMiklos Szeredi <miklos@szeredi.hu>\nMiklos Szeredi <mszeredi@redhat.com>\nMiklos Szeredi <mszeredi@suse.cz>\nMiklos Szeredi <szmi@users.noreply.github.com>\nMisono Tomohiro <misono.tm@gmail.com>\nmkmm@gmx-topmail.de <mkmm@gmx-topmail.de>\nmrdvdrm <mrdvdrm@gmail.com>\nNatanael Copa <ncopa@alpinelinux.org>\nNiels de Vos <ndevos@redhat.com>\nNikola Petrov <73067824+Petrov22Nikola@users.noreply.github.com>\nNikolaus Rath <Nikolaus@rath.org>\nNozomi Miyamori <99280467+nm004@users.noreply.github.com>\nOded Arbel <oded@geek.co.il>\nOlivier Blin <olivier.blin@softathome.com>\npablomh <pablomh@gmail.com>\nPedro Kaj Kjellerup Nacht <pnacht@google.com>\nPedro Nacht <pnacht@google.com>\nPeri <peri@srdi.org>\nPeter Lemenkov <lemenkov@gmail.com>\nphilmd <philmd@users.noreply.github.com>\nPierre Labastie <pierre.labastie@neuf.fr>\nPrzemyslaw Pawelczyk <przemoc@gmail.com>\nPrzemysław Pawełczyk <przemoc@gmail.com>\npsykose <alice@ayaya.dev>\nRatna_Bolla@dell.com <Ratna_Bolla@dell.com>\nRethan <359062468@qq.con>\nReuben Hawkins <reubenhwk@gmail.com>\nrfjakob <jakobunt@gmail.com>\nrichardweinberger <richard@nod.at>\nRichard W.M. Jones <rjones@redhat.com>\nRiku Voipio <riku.voipio@linaro.org>\nRobo Shimmer <roboshim@users.noreply.github.com>\nRoland Bauerschmidt <rb@debian.org>\nRoman Bogorodskiy <bogorodskiy@gmail.com>\nRosen Penev <rosenp@gmail.com>\nRostislav <rostislav@users.noreply.github.com>\nRostislav Skudnov <rostislav@tuxera.com>\nRudi Heitbaum <rudi@heitbaum.com>\nSam Huffman <40582525+samh-sifive@users.noreply.github.com>\nSam James <sam@gentoo.org>\nSam Stuewe <halosghost@archlinux.info>\nSangwoo Moon <swmoon00@gmail.com>\nSarath Lakshman <sarath@couchbase.com>\nSargun Dhillon <sargun@sargun.me>\nscosu <mpargmann@allfex.org>\nScott Worley <scottworley@scottworley.com>\nSebastian Pipping <sebastian@pipping.org>\nSergey Fedoseev <fedoseev.sergey@gmail.com>\nSeunghoon Yeon <yeonsh@gmail.com>\nSławek Rudnicki <slawek.rudnicki@editshare.com>\nStefan Hajnoczi <stefanha@gmail.com>\nStefan Hajnoczi <stefanha@redhat.com>\nStephen Kitt <steve@sk2.org>\nTej Chajed <tchajed@mit.edu>\ntenzap <46226844+tenzap@users.noreply.github.com>\ntherealneworld@gmail.com <therealneworld@gmail.com>\nTobias Nießen <tniessen@users.noreply.github.com>\nTofik Sonono <tofik.sonono@intel.com>\nTomasz Kulasek <34129113+tkulasek@users.noreply.github.com>\nTom Callaway <spot@fedoraproject.org>\nTom Callaway <spotrh@gmail.com>\nTomohiro Kusumi <kusumi.tomohiro@gmail.com>\nuserwithuid <userwithuid@gmail.com>\nValentin Plugaru <valentin.plugaru@uni.lu>\nVivek Goyal <vgoyal@redhat.com>\nWaldir Pimenta <waldyrious@gmail.com>\nwdlkmpx <wdlkmpx@gmail.com>\nWilliam Woodruff <william@yossarian.net>\nWinfried Koehler <w_scan@gmx-topmail.de>\nwinndows <winndows@163.com>\nXiubo Li <xiubli@redhat.com>\nYaroslav Halchenko <debian@onerussian.com>\ny <tofik.sonono@intel.com>\nYuri Per <yuri@acronis.com>\nZhansong Gao <zhsgao@hotmail.com>\nZhiqiang Liu <liuzhiqiang26@huawei.com>\nzsugabubus <zsugabubus@users.noreply.github.com>\n\n# New authors since fuse-3.16.2\nfarlongsignal <141166749+farlongsignal@users.noreply.github.com>\nyangyun50 <149988609+yangyun50@users.noreply.github.com>\nbigbrotherwei <1965867461@qq.com>\nCaian Benedicto <2220062+Caian@users.noreply.github.com>\ndesertwitch <24509509+desertwitch@users.noreply.github.com>\nSteveYang <40466358+SteveY4ng@users.noreply.github.com>\nFredyVia <942513309@qq.com>\nlegezywzh <94814730+legezywzh@users.noreply.github.com>\nCismonX <admin@cismon.net>\namitgeron <amit.geron@gmail.com>\nBernd Schubert <bernd@bsbernd.com>\nDaniel Rosenberg <drosen@google.com>\nHorst Birthelmer <hbirthelmer@ddn.com>\nJoanne Koong <joannelkoong@gmail.com>\nJosef Bacik <josef@toxicpanda.com>\nMatthew <matthew@matthew-cash.com>\ngandalfs_cat <meow@kittcat.dev>\nMJ Harvey <mharvey@jumptrading.com>\nNils <nils@nilsand.re>\nNorman Wilson <norman@teach.cs.toronto.edu>\nleipeng <peng@topling.cn>\nVladimir Serbinenko <phcoder@gmail.com>\nGeorge Hilliard <thirtythreeforty@gmail.com>\nTyler Hall <tylerwhall@gmail.com>\nyangyun <yangyun50@huawei.com>\nAbhishek <abhi_45645@yahoo.com>\n"
        },
        {
          "name": "ChangeLog.rst",
          "type": "blob",
          "size": 29.6298828125,
          "content": "libfuse 3.17 (2024-01-01)\n=========================\n\n* 3.11 and 3.14.2 introduced ABI incompatibilities, the ABI is restored\n  to 3.10, .so version was increased since there were releases with\n  the incompatible ABI\n\n* The libfuse version a program was compiled against is now encoded into\n  that program, using inlined functions in fuse_lowlevel.h and fuse.h\n* Allows to handle fatal signals and to print a backtrace.\n  New API function: fuse_set_fail_signal_handlers()\n\n* Allows fuse_log() messages to be send to syslog instead of stderr\n  New API functions: fuse_log_enable_syslog() and fuse_log_close_syslog()\n\n* Handle buffer misalignment for FUSE_WRITE\n\n* Added support for filesystem passthrough read/write of files when\n  FUSE_PASSTHROUGH capability is enabled\n  New API functions:  fuse_passthrough_open() and fuse_passthrough_close(),\n                      also see example/passthrough_hp.cc\n\n* Added fmask and dmask options to high-level API\n  - dmask: umask applied to directories\n  - fmask: umask applied to non-directories\n\n* Added FUSE_FILL_DIR_DEFAULTS enum to support C++ programs using\n  fuse_fill_dir_t function\n\n* Added support for FUSE_CAP_HANDLE_KILLPRIV_V2\n\nFixes:\n* Fixed compilation failure on FreeBSD (mount_bsd.c now points to correct\n  header)\n\nlibfuse 3.16.2 (2023-10-10)\n===========================\n\n* Various small fixes and improvements.\n\nlibfuse 3.16.1 (2023-08-08)\n===========================\n\n* Readdir kernel cache can be enabled from high-level API.\n\nlibfuse 3.15.1 (2023-07-05)\n===========================\n\nFuture libfuse releases will be signed with `signify`_ rather than PGP (rationale_). This\nrelease is the last to be signed with PGP and contains the signify public key for current\n(3.15.X) and upcoming  (3.16.X) minor release cycle.\n\n.. _signify:  https://www.openbsd.org/papers/bsdcan-signify.html\n.. _rationale: https://latacora.micro.blog/2019/07/16/the-pgp-problem.html\n\n\nlibfuse 3.15.0 (2023-06-09)\n===========================\n\n* Improved support for some less common systems (32 bit, alternative libcs)\n\n* Unsupported mount options are no longer silently accepted.\n\n* auto_unmount is now compatible with allow_other.\n\n\nlibfuse 3.14.1 (2023-03-26)\n===========================\n\n* The extended attribute name passed to the setxattr() handler is no longer\n  truncated at the beginning (bug introduced in 3.13.0).\n  \n* As a result of the above, the additional setattr() flags introduced in 3.14 are no\n  longer available for now. They will hopefully be reintroduced in the next release.\n\n* Further improvements of configuration header handling.\n\n\nlibfuse 3.14.0 (2023-02-17)\n===========================\n\n* Properly fix the header installation issue. The fix in 3.13.1 resulted\n  in conflicts with other packages.\n\n* Introduce additional setattr() flags (FORCE, KILL_SUID, KILL_SGID, FILE, KILL_PRIV,\n  OPEN, TIMES_SET)\n\n\nlibfuse 3.13.1 (2023-02-03)\n===========================\n\n* Fixed an issue that resulted in errors when attempting to compile against\n  installed libfuse headers (because libc symbol versioning support was not\n  detected correctly in this case).\n\nlibfuse 3.13.0 (2023-01-13)\n===========================\n\n* There is a new low-level API function `fuse_session_custom_io` that allows to implement\n  a daemon with a custom io. This can be used to create a daemon that can process incoming\n  FUSE requests to other destinations than `/dev/fuse`.\n\n* A segfault when loading custom FUSE modules has been fixed.\n\n* There is a new `fuse_notify_expire_entry` function.\n\n* A deadlock when resolving paths in the high-level API has been fixed.\n\n* libfuse can now be build explicitly for C libraries without symbol versioning support.\n\nlibfuse 3.12.0 (2022-09-08)\n===========================\n\n* There is a new build parameter to specify where the SysV init script should be\n  installed.\n  \n* The *max_idle_threads* parameter has been deprecated in favor of the new max_threads*\n  parameter (which avoids the excessive overhead of creating and destructing threads).\n  Using max_threads == 1 and calling fuse_session_loop_mt() will run single threaded\n  similar to fuse_session_loop().\n\nThe following changes apply when using the most recent API (-DFUSE_USE_VERSION=312,\nsee `example/passthrough_hp.cc` for an example for how to usse the new API):\n\n* `struct fuse_loop_config` is now private and has to be constructed using\n  *fuse_loop_cfg_create()* and destroyed with *fuse_loop_cfg_destroy()*.  Parameters can be\n  changed using `fuse_loop_cfg_set_*()` functions.\n\n* *fuse_session_loop_mt()* now accepts `struct fuse_loop_config *` as NULL pointer.\n\n* *fuse_parse_cmdline()* now accepts a *max_threads* option.\n\n\nlibfuse 3.11.0 (2022-05-02)\n===========================\n\n* Add support for flag FOPEN_NOFLUSH for avoiding flush on close.\n* Fixed returning an error condition to ioctl(2)\n\n\nlibfuse 3.10.5 (2021-09-06)\n===========================\n\n* Various improvements to make unit tests more robust.\n\n\nlibfuse 3.10.4 (2021-06-09)\n===========================\n\n* Building of unit tests is now optional.\n* Fixed a test failure when running tests under XFS.\n* Fixed memory leaks in examples.\n* Minor documentation fixes.  \n\nlibfuse 3.10.3 (2021-04-12)\n===========================\n\n* Fix returning d_ino and d_type from readdir(3) in non-plus mode\n  \nlibfuse 3.10.2 (2021-02-05)\n===========================\n\n* Allow \"nonempty\" as a mount option, for backwards compatibility with fusermount 2. The\n  option has no effect since mounting over non-empty directories is allowed by default.\n* Fix returning inode numbers from readdir() in offset==0 mode.\n* FUSE filesystems can now be mounted underneath EXFAT mountpoints.\n* Various minor bugfixes.  \n\nlibfuse 3.10.1 (2020-12-07)\n===========================\n\n* Various minor bugfixes.\n\nlibfuse 3.10.0 (2020-10-09)\n===========================\n\n* Add FUSE_CAP_CACHE_SYMLINKS: allow caching symlinks in kernel page cache.\n* Various minor bugfixes and improvements.  \n\nlibfuse 3.9.4 (2020-08-09)\n==========================\n\nThis was an \"accidental\" release, it is equivalent to 3.9.3.\n\nlibfuse 3.9.3 (2020-08-09)\n==========================\n\n* Fixed compilation under OS X and µClibc.\n* Minor bugfixes and doc updates.\n\nlibfuse 3.9.2 (2020-06-12)\n==========================\n\n* Remove obsolete workarounds in examples.\n* Do not require C++ compiler for building.\n* Minor bugfixes.\n\nlibfuse 3.9.1 (2020-03-19)\n===========================\n\n* Fixed memory leak in fuse_session_new().\n* Fixed an issue with the linker version script.\n* Make ioctl prototype conditional on FUSE_USE_VERSION.  Define FUSE_USE_VERSION < 35 to\n  get old ioctl prototype with int commands; define FUSE_USE_VERSION >= 35 to get new\n  ioctl prototype with unsigned int commands.\n* Various small bugfixes.\n\nlibfuse 3.9.0 (2019-12-14)\n==========================\n\n* Added support for FUSE_EXPLICIT_INVAL_DATA to enable\n  only invalidate cached pages on explicit request.\n\nlibfuse 3.8.0 (2019-11-03)\n==========================\n\n* Added support for FUSE_LSEEK operation which can be used to report holes\n  in sparse files.\n\nlibfuse 3.7.0 (2019-09-27)\n==========================\n\n* Added UFSD to whitelist (so users can now mount FUSE filesystems\n  on mountpoints within UFSD filesystems).\n* Added custom log message handler function support so that libfuse\n  applications can direct messages to syslog(3) or other logging systems.\n  stderr remains the default.  See `fuse_log.h` for the new API.\n\nlibfuse 3.6.2 (2019-07-09)\n==========================\n\n* The init script is now installed to /etc/ rather than /usr/local/etc\n  by default.\n\nlibfuse 3.6.1 (2019-06-13)\n==========================\n\n* Fixed version number (release 3.6.0 was shipped with a declared\n  version of 3.0.0).\n\nlibfuse 3.6.0 (2019-06-13)\n==========================\n\n* Added a new example (passthrough_hp). The functionality is similar\n  to passthrough_ll, but the implementation focuses on performance and\n  correctness rather than simplicity.\n* Added support for fuse kernel feature `max_pages` which allows to increase\n  the maximum number of pages that can be used per request. This feature was\n  introduced in kernel 4.20. `max_pages` is set based on the value in\n  `max_write`. By default `max_write` will be 1MiB now for kernels that support\n  `max_pages`. If you want smaller buffers or writes you have to set\n  `max_write` manually.\n\nlibfuse 3.5.0 (2019-04-16)\n==========================\n\n* Changed ioctl commands to \"unsigned int\" in order to support commands\n  which do not fit into a signed int. Commands issued by applications\n  are still truncated to 32 bits.\n* Added SMB2 to whitelist (so users can now mount FUSE filesystems\n  on mountpoints within SMB 2.0 filesystems).\n* Added a new `cache_readdir` flag to `fuse_file_info` to enable\n  caching of readdir results. Supported by kernels 4.20 and newer.\n* Add support and documentation for FUSE_CAP_NO_OPENDIR_SUPPORT.\n\nlibfuse 3.4.2 (2019-03-09)\n==========================\n\n* Fixed a memory leak in `examples/passthrough_ll.c`.\n* Added OpenAFS to whitelist (so users can now mount FUSE filesystems\n  on mountpoints within OpenAFS filesystems).\n* Added HFS+ to whitelist (so users can now mount FUSE filesystems\n  on mountpoints within HFS+ filesystems).\n* Documentation improvements.\n\nlibfuse 3.4.1 (2018-12-22)\n==========================\n\n* The `examples/passthrough_ll.c` example filesystem has been\n  significantly extended.\n* Support for `copy_file_range` has been added.\n* Build system updates for non-Linux systems.\n\nlibfuse 3.4.0\n=============\n\n* Add `copy_file_range()` to support efficient copying of data from one file to\n  an other.\n\nlibfuse 3.3.0 (2018-11-06)\n==========================\n\n* The `auto_unmount` mode now works correctly in combination with\n  autofs.\n\n* The FUSE_CAP_READDIRPLUS_AUTO capability is no longer enabled by\n  default unless the file system defines both a readdir() and a\n  readdirplus() handler.\n\n* The description of the FUSE_CAP_READDIRPLUS_AUTO flag has been\n  improved.\n\n* Allow open `/dev/fuse` file descriptors to be passed via mountpoints of the\n  special format `/dev/fd/%u`. This allows mounting to be handled by the parent\n  so the FUSE filesystem process can run fully unprivileged.\n\n* Add a `drop_privileges` option to mount.fuse3 which causes it to open\n  `/dev/fuse` and mount the file system itself, then run the FUSE file\n  filesystem fully unprivileged and unable to re-acquire privilege via setuid,\n  fscaps, etc.\n\n* Documented under which conditions the `fuse_lowlevel_notify_*`\n  functions may block.\n\nlibfuse 3.2.6 (2018-08-31)\n==========================\n\n* The fuse_main() function now returns more fine-grained error codes.\n* FUSE filesystems may now be mounted on mountpoint within\n  bcachefs, aufs and FAT filesystems.\n* libfuse may now be used as a Meson subproject.\n* Fix a few low-impact memory leaks.\n* The `fuse.conf` file is no longer looked for in `/etc`, but in the\n  *sysconfdir* directory (which can be set with `meson configure`). By\n  default, the location is thus `/usr/local/etc/fuse.conf`.\n\nlibfuse 3.2.5 (2018-07-24)\n==========================\n\n* SECURITY UPDATE: In previous versions of libfuse it was possible to\n  for unprivileged users to specify the `allow_other` option even when\n  this was forbidden in `/etc/fuse.conf`.  The vulnerability is\n  present only on systems where SELinux is active (including in\n  permissive mode).\n* The fusermount binary has been hardened in several ways to reduce\n  potential attack surface. Most importantly, mountpoints and mount\n  options must now match a hard-coded whitelist. It is expected that\n  this whitelist covers all regular use-cases.\n* Added a test of `seekdir` to test_syscalls.\n* Fixed `readdir` bug when non-zero offsets are given to filler and the\n  filesystem client, after reading a whole directory, re-reads it from a\n  non-zero offset e. g. by calling `seekdir` followed by `readdir`.\n\nlibfuse 3.2.4 (2018-07-11)\n==========================\n\n* Fixed `rename` deadlock on FreeBSD.\n\nlibfuse 3.2.3 (2018-05-11)\n==========================\n\n* Fixed a number of compiler warnings.  \n\nlibfuse 3.2.2 (2018-03-31)\n==========================\n\n* Added example fuse.conf file.\n* Added \"support\" for -o nofail mount option (the option is accepted\n  and ignored).\n* Various small bugfixes.  \n\nlibfuse 3.2.1 (2017-11-14)\n==========================\n\n* Various small bugfixes.\n\nlibfuse 3.2.0 (2017-09-12)\n==========================\n\n* Support for building with autotools has been dropped.\n\n* Added new `fuse_invalidate_path()` routine for cache invalidation\n  from the high-level FUSE API, along with an example and tests.\n\n* There's a new `printcap` example that can be used to determine the\n  capabilities of the running kernel.\n\n* `fuse_loop_mt()` now returns the minus the actual errno if there was\n  an error (instead of just -1).\n\n* `fuse_loop()` no longer returns a positive value if the filesystem\n  loop was terminated without errors or signals.\n\n* Improved documentation of `fuse_lowlevel_notify_*` functions.\n\n* `fuse_lowlevel_notify_inval_inode()` and\n  `fuse_lowlevel_notify_inval_entry()` now return -ENOSYS instead of\n  an undefined error if the function is not supported by the kernel.\n\n* Documented the special meaning of the *zero* offset for the\n  fuse_fill_dir_t function.\n\n* The `passthrough_fh` example now works under FreeBSD.\n\n* libfuse can now be build without libiconv.\n\n* Fixed support for `FUSE_CAP_POSIX_ACL`: setting this capability\n  flag had no effect in the previous versions of libfuse 3.x;\n  now ACLs should actually work.\n\n* Fixed a number of compilation problems under FreeBSD.\n\n* Fixed installation directory for udev rules.\n\n* Fixed compilation with LTO.\n\nlibfuse 3.1.1 (2017-08-06)\n==========================\n\n* Documentation: clarified how filesystems are supposed to process\n  open() and create() flags (see include/fuse_lowlevel.h).\n\n* Fixed a compilation problem of the passthrough_ll example on\n  32 bit systems (wrong check and wrong error message).\n\n* pkg-config is now used to determine the proper directory for\n  udev rules.\n\n* Fixed a symbol versioning problem that resulted in very strange\n  failures (segfaults, unexpected behavior) in different situations.\n\n* Fixed a test failure when /tmp is on btrfs.\n\n* The maximum number of idle worker threads used by `fuse_loop_mt()`\n  is now configurable.\n\n* `fuse_loop_mt()` and `fuse_session_loop_mt()` now take a\n  `struct fuse_loop_config` parameter that supersedes the *clone_fd*\n  parameter.\n\n* Incorporated several patches from the FreeBSD port. libfuse should\n  now compile under FreeBSD without the need for patches.\n\n* The passthrough_ll example now supports writeback caching.\n\nlibfuse 3.1.0 (2017-07-08)\n==========================\n\n* Added new `fuse_lib_help()` function. File-systems that previously\n  passed a ``--help`` option to `fuse_new()` must now process the\n  ``--help`` option internally and call `fuse_lib_help()` to print the\n  help for generic FUSE options.\n* Fixed description of the `fuse_conn_info->time_gran`. The default\n  value of zero actually corresponds to full nanosecond resolution,\n  not one second resolution.\n* The init script is now installed into the right location\n  (``$DESTDIR/etc/init.d`` rather than ``$prefix/$sysconfdir/init.d``)\n* The `example/passthrough_ll` filesystem now supports creating\n  and writing to files.\n* `fuse_main()` / `fuse_remove_signal_handlers()`: do not reset\n  `SIGPIPE` handler to `SIG_DFL` if it was not set by us.\n* Documented the `RENAME_EXCHANGE` and `RENAME_NOREPLACE` flags that\n  may be passed to the `rename` handler of both the high- and\n  low-level API. Filesystem authors are strongly encouraged to check\n  that these flags are handled correctly.\n\nlibfuse 3.0.2 (2017-05-24)\n==========================\n\n* Option parsing for the high-level API now works correctly\n  (previously, default values would override specified values).\n* Tests should now build (and run) under FreeBSD.\n* Improved documentation of `struct fuse_context`\n* Internal: calculate request buffer size from page size and kernel\n  page limit instead of using hardcoded 128 kB limit.\n\n\nlibfuse 3.0.1 (2017-04-10)\n==========================\n\n* Re-introduced *examples/null.c*.\n* Added experimental support for building with Meson.\n* Document that `-o auto_unmount` implies `-o nodev,nosuid`.\n* Document that the *use_ino* option of the high-level interface does\n  not affect the inode that libfuse and the kernel use internally.\n* Fixed test cases for passthrough* examples (they weren't actually\n  testing the examples).\n* Fixed several bugs in the passthrough* examples.\n\nlibfuse 3.0.0 (2016-12-08)\n==========================\n\n* NOTE TO PACKAGERS:\n\n  libfuse 3 is designed to be co-installable with libfuse 2. However,\n  some files will be installed by both libfuse 2 and libfuse 3\n  (e.g. /etc/fuse.conf, the udev and init scripts, and the\n  mount.fuse(8) manpage). These files should be taken from\n  libfuse 3. The format/content is guaranteed to remain backwards\n  compatible with libfuse 2.\n\n  We recommend to ship libfuse2 and libfuse3 in three separate\n  packages: a libfuse-common package that contains files shared by\n  libfuse 2+3 (taken from the libfuse3 tarball), and libfuse2 and\n  libfuse3 packages that contain the shared library and helper\n  programs for the respective version.\n\n* Fixed test errors when running tests as root.\n\n* Made check for util-linux version more robust.\n\n* Added documentation for all fuse capability flags (`FUSE_CAP_*`) and\n  `struct fuse_conn_info` fields.\n\n* fuse_loop(), fuse_loop_mt(), fuse_session_loop() and\n  fuse_session_loop_mt() now return more detailed error codes instead\n  of just -1. See the documentation of fuse_session_loop() for details.\n\n* The FUSE main loop is now aborted if the file-system requests\n  capabilities that are not supported by the kernel. In this case, the\n  session loop is exited with a return code of ``-EPROTO``.\n\n* Most file-system capabilities that were opt-in in libfuse2 are now\n  enabled by default. Filesystem developers are encouraged to review\n  the documentation of the FUSE_CAP_* features to ensure that their\n  filesystem is compatible with the new semantics. As before, a\n  particular capability can still be disabled by unsetting the\n  corresponding bit of `fuse_conn_info.wants` in the init() handler.\n\n* Added FUSE_CAP_PARALLEL_DIROPS and FUSE_CAP_POSIX_ACL,\n  FUSE_HANDLE_KILLPRIV feature flags.\n\n* FUSE filesystems are now responsible for unsetting the setuid/setgid\n  flags when a file is written, truncated, or its owner\n  changed. Previously, this was handled by the kernel but subject to\n  race conditions.\n\n* The fusermount and mount.fuse binaries have been renamed to\n  fusermount3 and mount.fuse3 to allow co-installation of libfuse 2.x\n  and 3.x\n\n* Added a `max_read` field to `struct fuse_conn_info`. For the time\n  being, the maximum size of read requests has to be specified both\n  there *and* passed to fuse_session_new() using the ``-o\n  max_read=<n>`` mount option. At some point in the future, specifying\n  the mount option will no longer be necessary.\n\n* Documentation: clarified that the fuse_argv structure that is passed\n  to `fuse_new()` and `fuse_lowlevel_new()` must always contain at\n  least one element.\n\n* The high-level init() handler now receives an additional struct\n  fuse_config pointer that can be used to adjust high-level API\n  specific configuration options.\n\n* The `nopath_flag` field of struct fuse_operations has been\n  removed. Instead, a new `nullpath_ok` flag can now be set\n  in struct fuse_config.\n\n* File systems that use the low-level API and support lookup requests\n  for '.' and '..' should continue make sure to set the\n  FUSE_CAP_EXPORT_SUPPORT bit in fuse_conn_info->want.\n\n  (This has actually always been the case, but was not very obvious\n  from the documentation).\n\n* The help text generated by fuse_lowlevel_help(), fuse_new() (and\n  indirectly fuse_main()) no longer includes options that are unlikely\n  to be of interest to end-users. The full list of accepted options is\n  now included in the respective function's documentation (located in\n  the fuse.h/fuse_lowlevel.h and doc/html).\n\n* The ``-o nopath`` option has been dropped - it never actually did\n  anything (since it is unconditionally overwritten with the value of\n  the `nopath` flag in `struct fuse_operations`).\n\n* The ``-o large_read`` mount option has been dropped. Hopefully no\n  one uses a Linux 2.4 kernel anymore.\n\n* The `-o nonempty` mount point has been removed, mounting over\n  non-empty directories is now always allowed. This brings the\n  behavior of FUSE file systems in-line with the behavior of the\n  regular `mount` command.\n\n  File systems that do not want to allow mounting to non-empty\n  directories should perform this check themselves before handing\n  control to libfuse.\n\n* The chmod, chown, truncate, utimens and getattr handlers of the\n  high-level API now all receive an additional struct fuse_file_info\n  pointer (which, however, may be NULL even if the file is currently\n  open).\n\n  The fgetattr and ftruncate handlers have become obsolete and have\n  been removed.\n\n* The `fuse_session_new` function no longer accepts the ``-o\n  clone_fd`` option. Instead, this has become a parameter of the\n  `fuse_session_loop_mt` and `fuse_loop_mt` functions.\n\n* For low-level file systems that implement the `write_buf` handler,\n  the `splice_read` option is now enabled by default. As usual, this\n  can be changed in the file system's `init` handler.\n\n* The treatment of low-level options has been made more consistent:\n\n  Options that can be set in the init() handler (via the\n  fuse_conn_info parameter) can now be set only here,\n  i.e. fuse_session_new() no longer accepts arguments that change the\n  fuse_conn_info object before or after the call do init(). As a side\n  effect, this removes the ambiguity where some options can be\n  overwritten by init(), while others overwrite the choices made by\n  init().\n\n  For file systems that wish to offer command line options for these\n  settings, the new fuse_parse_conn_info_opts() and\n  fuse_apply_conn_info_opts() functions are available.\n\n  Consequently, the fuse_lowlevel_help() method has been dropped.\n\n* The `async_read` field in `struct fuse_conn_info` has been\n  removed. To determine if the kernel supports asynchronous reads,\n  file systems should check the `FUSE_CAP_ASYNC_READ` bit of the\n  `capable` field. To enable/disable asynchronous reads, file systems\n  should set the flag in the `wanted` field.\n\n* The `fuse_parse_cmdline` function no longer prints out help when the\n  ``--verbose`` or ``--help`` flags are given. This needs to be done\n  by the file system (e.g. using the `fuse_cmdline_help()` and\n  `fuse_lowlevel_help()` functions).\n\n* Added ``example/cuse_client.c`` to test ``example/cuse.c``.\n\n* Removed ``example/null.c``. This has not been working for a while\n  for unknown reasons -- maybe because it tries to treat the\n  mountpoint as a file rather than a directory?\n\n* There are several new examples that demonstrate the use of\n  the ``fuse_lowlevel_notify_*`` functions:\n\n  - ``example/notify_store_retrieve.c``\n  - ``example/notify_inval_inode.c``\n  - ``example/notify_inval_entry.c``\n\n* The ``-o big_writes`` mount option has been removed. It is now\n  always active. File systems that want to limit the size of write\n  requests should use the ``-o max_write=<N>`` option instead.\n\n* The `fuse_lowlevel_new` function has been renamed to\n  `fuse_session_new` and no longer interprets the --version or --help\n  options. To print help or version information, use the new\n  `fuse_lowlevel_help` and `fuse_lowlevel_version` functions.\n\n* The ``allow_other`` and ``allow_root`` mount options (accepted by\n  `fuse_session_new()`) may now be specified together. In this case,\n  ``allow_root`` takes precedence.\n\n* There are new `fuse_session_unmount` and `fuse_session_mount`\n  functions that should be used in the low-level API. The `fuse_mount`\n  and `fuse_unmount` functions should be used with the high-level API\n  only.\n\n* Neither `fuse_mount` nor `fuse_session_mount` take struct fuse_opts\n  parameters anymore. Mount options are parsed by `fuse_new` (for the\n  high-level API) and `fuse_session_new` (for the low-level API)\n  instead. To print help or version information, use the new\n  `fuse_mount_help` and `fuse_mount_version` functions.\n\n* The ``fuse_lowlevel_notify_*`` functions now all take a `struct\n  fuse_session` parameter instead of a `struct fuse_chan`.\n\n* The channel interface (``fuse_chan_*`` functions) has been made\n  private. As a result, the typical initialization sequence of a\n  low-level file system has changed from ::\n\n        ch = fuse_mount(mountpoint, &args);\n        se = fuse_lowlevel_new(&args, &lo_oper, sizeof(lo_oper), &lo);\n        fuse_set_signal_handlers(se);\n        fuse_session_add_chan(se, ch);\n        fuse_daemonize(fg);\n        if (mt)\n            fuse_session_loop_mt(se);\n        else\n            fuse_session_loop(se);\n        fuse_remove_signal_handlers(se);\n        fuse_session_remove_chan(ch);\n        fuse_session_destroy(se);\n        fuse_unmount(mountpoint, ch);\n\n  to ::\n\n        se = fuse_session_new(&args, &ll_ops, sizeof(ll_ops), NULL);\n        fuse_set_signal_handlers(se);\n        fuse_session_mount(se, mountpoint);\n        fuse_daemonize(fg);\n        if (mt)\n            fuse_session_loop_mt(se);\n        else\n            fuse_session_loop(se);\n        fuse_remove_signal_handlers(se);\n        fuse_session_unmount(se);\n        fuse_lowlevel_destroy(se);\n\n  The typical high-level setup has changed from ::\n\n        ch = fuse_mount(*mountpoint, &args);\n        fuse = fuse_new(ch, &args, op, op_size, user_data);\n        se = fuse_get_session(fuse);\n        fuse_set_signal_handlers(se);\n        fuse_daemonize(fg);\n        if (mt)\n            fuse_loop_mt(fuse);\n        else\n            fuse_loop(fuse);\n        fuse_remove_signal_handlers(se);\n        fuse_unmount(mountpoint, ch);\n        fuse_destroy(fuse);\n\n  to ::\n\n        fuse = fuse_new(&args, op, op_size, user_data);\n        se = fuse_get_session(fuse);\n        fuse_set_signal_handlers(se);\n        fuse_mount(fuse, mountpoint);\n        fuse_daemonize(fg);\n         if (mt)\n            fuse_loop_mt(fuse);\n        else\n            fuse_loop(fuse);\n        fuse_remove_signal_handlers(se);\n        fuse_unmount(fuse);\n        fuse_destroy(fuse);\n\n  File systems that use `fuse_main` are not affected by this change.\n\n  For integration with custom event loops, the new `fuse_session_fd`\n  function provides the file descriptor that's used for communication\n  with the kernel.\n\n* Added *clone_fd* option.  This creates a separate device file\n  descriptor for each processing thread, which might improve\n  performance.\n\n* Added *writeback_cache* option. With kernel 3.14 and newer this\n  enables write-back caching which can significantly improve\n  performance.\n\n* Added *async_dio* option. With kernel 3.13 and newer, this allows\n  direct I/O to be done asynchronously.\n\n* The (high- and low-level) `rename` handlers now takes a *flags*\n  parameter (with values corresponding to the *renameat2* system call\n  introduced in Linux 3.15).\n\n* The \"ulockmgr_server\" has been dropped.\n\n* There is a new (low-level) `readdirplus` handler, with a\n  corresponding example in ``examples/fuse_lo-plus.c`` and a new\n  `fuse_add_direntry_plus` API function.\n\n* The (high-level) `readdir` handler now takes a *flags* argument.\n\n* The (high-level) `filler` function passed to `readdir` now takes an\n  additional *flags* argument.\n\n* The (high-level) `getdir` handler has been dropped.\n\n* The *flag_nullpath_ok* and *flag_utime_omit_ok* flags have been\n  dropped.\n\n* The (high-level) *utime* handler has been dropped.\n\n* The `fuse_invalidate` function has been removed.\n\n* The `fuse_is_lib_option` function has been removed.\n\n* The *fh_old* member of `struct fuse_file_info` has been dropped.\n\n* The type of the *writepage* member of `struct fuse_file_info` was\n  changed from *int* to *unsigned int*.\n\n* The `struct fuse_file_info` gained a new *poll_events* member.\n\n* There is a new `fuse_pkgversion` function.\n\n* The *fuse_off_t* and *fuse_ino_t* changed from *unsigned long* to\n  *uint64_t*, i.e. they are now 64 bits also on 32-bit systems.\n\n* The type of the *generation* member of `struct fuse_entry_param*`\n  changed from *unsigned* to *uint64_t*.\n\n* The (low-level) `setattr` handler gained a *FUSE_SET_ATTR_CTIME* bit\n  *for its *to_set* parameter.\n\n* The `struct fuse_session_ops` data structure has been dropped.\n\n* The documentation has been clarified and improved in many places.\n\n\nFUSE 2.9.7 (2016-06-20)\n=======================\n\n* Added SELinux support.\n* Fixed race-condition when session is terminated right after starting\n  a FUSE file system.\n\nFUSE 2.9.6 (2016-04-23)\n=======================\n\n* Tarball now includes documentation.\n* Shared-object version has now been bumped correctly.\n\nFUSE 2.9.5 (2016-01-14)\n=======================\n\n* New maintainer: Nikolaus Rath <Nikolaus@rath.org>. Many thanks to\n  Miklos Szeredi <miklos@szeredi.hu> for bringing FUSE to where it is\n  now!\n\n* fix warning in mount.c:receive_fd().  Reported by Albert Berger\n\n* fix possible memory leak.  Reported by Jose R. Guzman\n\nFUSE 2.9.4 (2015-05-22)\n=======================\n\n* fix exec environment for mount and umount.  Found by Tavis Ormandy\n  (CVE-2015-3202).\n\n* fix fuse_remove_signal_handlers() to properly restore the default\n  signal handler.  Reported by: Chris Johnson\n\n* highlevel API: fix directory file handle passed to ioctl() method.\n  Reported by Eric Biggers\n\n* libfuse: document deadlock avoidance for fuse_notify_inval_entry()\n  and fuse_notify_delete()\n\n* fusermount, libfuse: send value as unsigned in \"user_id=\" and\n  \"group_id=\" options.  Uids/gids larger than 2147483647 would result\n  in EINVAL when mounting the filesystem.  This also needs a fix in\n  the kernel.\n\n* Initialize stat buffer passed to ->getattr() and ->fgetattr() to\n  zero in all cases.  Reported by Daniel Iwan\n\n* libfuse: Add missing includes.  This allows compiling fuse with\n  musl.  Patch by Daniel Thau\n\n\nOlder Versions (before 2013-01-01)\n==================================\n\nPlease see Git history, e.g. at\nhttps://github.com/libfuse/libfuse/blob/fuse_2_9_3/ChangeLog.\n"
        },
        {
          "name": "GPL2.txt",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "LGPL2.txt",
          "type": "blob",
          "size": 25.908203125,
          "content": "                  GNU LESSER GENERAL PUBLIC LICENSE\n                       Version 2.1, February 1999\n\n Copyright (C) 1991, 1999 Free Software Foundation, Inc.\n 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n[This is the first released version of the Lesser GPL.  It also counts\n as the successor of the GNU Library Public License, version 2, hence\n the version number 2.1.]\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicenses are intended to guarantee your freedom to share and change\nfree software--to make sure the software is free for all its users.\n\n  This license, the Lesser General Public License, applies to some\nspecially designated software packages--typically libraries--of the\nFree Software Foundation and other authors who decide to use it.  You\ncan use it too, but we suggest you first think carefully about whether\nthis license or the ordinary General Public License is the better\nstrategy to use in any particular case, based on the explanations below.\n\n  When we speak of free software, we are referring to freedom of use,\nnot price.  Our General Public Licenses are designed to make sure that\nyou have the freedom to distribute copies of free software (and charge\nfor this service if you wish); that you receive source code or can get\nit if you want it; that you can change the software and use pieces of\nit in new free programs; and that you are informed that you can do\nthese things.\n\n  To protect your rights, we need to make restrictions that forbid\ndistributors to deny you these rights or to ask you to surrender these\nrights.  These restrictions translate to certain responsibilities for\nyou if you distribute copies of the library or if you modify it.\n\n  For example, if you distribute copies of the library, whether gratis\nor for a fee, you must give the recipients all the rights that we gave\nyou.  You must make sure that they, too, receive or can get the source\ncode.  If you link other code with the library, you must provide\ncomplete object files to the recipients, so that they can relink them\nwith the library after making changes to the library and recompiling\nit.  And you must show them these terms so they know their rights.\n\n  We protect your rights with a two-step method: (1) we copyright the\nlibrary, and (2) we offer you this license, which gives you legal\npermission to copy, distribute and/or modify the library.\n\n  To protect each distributor, we want to make it very clear that\nthere is no warranty for the free library.  Also, if the library is\nmodified by someone else and passed on, the recipients should know\nthat what they have is not the original version, so that the original\nauthor's reputation will not be affected by problems that might be\nintroduced by others.\n\f\n  Finally, software patents pose a constant threat to the existence of\nany free program.  We wish to make sure that a company cannot\neffectively restrict the users of a free program by obtaining a\nrestrictive license from a patent holder.  Therefore, we insist that\nany patent license obtained for a version of the library must be\nconsistent with the full freedom of use specified in this license.\n\n  Most GNU software, including some libraries, is covered by the\nordinary GNU General Public License.  This license, the GNU Lesser\nGeneral Public License, applies to certain designated libraries, and\nis quite different from the ordinary General Public License.  We use\nthis license for certain libraries in order to permit linking those\nlibraries into non-free programs.\n\n  When a program is linked with a library, whether statically or using\na shared library, the combination of the two is legally speaking a\ncombined work, a derivative of the original library.  The ordinary\nGeneral Public License therefore permits such linking only if the\nentire combination fits its criteria of freedom.  The Lesser General\nPublic License permits more lax criteria for linking other code with\nthe library.\n\n  We call this license the \"Lesser\" General Public License because it\ndoes Less to protect the user's freedom than the ordinary General\nPublic License.  It also provides other free software developers Less\nof an advantage over competing non-free programs.  These disadvantages\nare the reason we use the ordinary General Public License for many\nlibraries.  However, the Lesser license provides advantages in certain\nspecial circumstances.\n\n  For example, on rare occasions, there may be a special need to\nencourage the widest possible use of a certain library, so that it becomes\na de-facto standard.  To achieve this, non-free programs must be\nallowed to use the library.  A more frequent case is that a free\nlibrary does the same job as widely used non-free libraries.  In this\ncase, there is little to gain by limiting the free library to free\nsoftware only, so we use the Lesser General Public License.\n\n  In other cases, permission to use a particular library in non-free\nprograms enables a greater number of people to use a large body of\nfree software.  For example, permission to use the GNU C Library in\nnon-free programs enables many more people to use the whole GNU\noperating system, as well as its variant, the GNU/Linux operating\nsystem.\n\n  Although the Lesser General Public License is Less protective of the\nusers' freedom, it does ensure that the user of a program that is\nlinked with the Library has the freedom and the wherewithal to run\nthat program using a modified version of the Library.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.  Pay close attention to the difference between a\n\"work based on the library\" and a \"work that uses the library\".  The\nformer contains code derived from the library, whereas the latter must\nbe combined with the library in order to run.\n\f\n                  GNU LESSER GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License Agreement applies to any software library or other\nprogram which contains a notice placed by the copyright holder or\nother authorized party saying it may be distributed under the terms of\nthis Lesser General Public License (also called \"this License\").\nEach licensee is addressed as \"you\".\n\n  A \"library\" means a collection of software functions and/or data\nprepared so as to be conveniently linked with application programs\n(which use some of those functions and data) to form executables.\n\n  The \"Library\", below, refers to any such software library or work\nwhich has been distributed under these terms.  A \"work based on the\nLibrary\" means either the Library or any derivative work under\ncopyright law: that is to say, a work containing the Library or a\nportion of it, either verbatim or with modifications and/or translated\nstraightforwardly into another language.  (Hereinafter, translation is\nincluded without limitation in the term \"modification\".)\n\n  \"Source code\" for a work means the preferred form of the work for\nmaking modifications to it.  For a library, complete source code means\nall the source code for all modules it contains, plus any associated\ninterface definition files, plus the scripts used to control compilation\nand installation of the library.\n\n  Activities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning a program using the Library is not restricted, and output from\nsuch a program is covered only if its contents constitute a work based\non the Library (independent of the use of the Library in a tool for\nwriting it).  Whether that is true depends on what the Library does\nand what the program that uses the Library does.\n\n  1. You may copy and distribute verbatim copies of the Library's\ncomplete source code as you receive it, in any medium, provided that\nyou conspicuously and appropriately publish on each copy an\nappropriate copyright notice and disclaimer of warranty; keep intact\nall the notices that refer to this License and to the absence of any\nwarranty; and distribute a copy of this License along with the\nLibrary.\n\n  You may charge a fee for the physical act of transferring a copy,\nand you may at your option offer warranty protection in exchange for a\nfee.\n\f\n  2. You may modify your copy or copies of the Library or any portion\nof it, thus forming a work based on the Library, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) The modified work must itself be a software library.\n\n    b) You must cause the files modified to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    c) You must cause the whole of the work to be licensed at no\n    charge to all third parties under the terms of this License.\n\n    d) If a facility in the modified Library refers to a function or a\n    table of data to be supplied by an application program that uses\n    the facility, other than as an argument passed when the facility\n    is invoked, then you must make a good faith effort to ensure that,\n    in the event an application does not supply such function or\n    table, the facility still operates, and performs whatever part of\n    its purpose remains meaningful.\n\n    (For example, a function in a library to compute square roots has\n    a purpose that is entirely well-defined independent of the\n    application.  Therefore, Subsection 2d requires that any\n    application-supplied function or table used by this function must\n    be optional: if the application does not supply it, the square\n    root function must still compute square roots.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Library,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Library, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote\nit.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Library.\n\nIn addition, mere aggregation of another work not based on the Library\nwith the Library (or with a work based on the Library) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may opt to apply the terms of the ordinary GNU General Public\nLicense instead of this License to a given copy of the Library.  To do\nthis, you must alter all the notices that refer to this License, so\nthat they refer to the ordinary GNU General Public License, version 2,\ninstead of to this License.  (If a newer version than version 2 of the\nordinary GNU General Public License has appeared, then you can specify\nthat version instead if you wish.)  Do not make any other change in\nthese notices.\n\f\n  Once this change is made in a given copy, it is irreversible for\nthat copy, so the ordinary GNU General Public License applies to all\nsubsequent copies and derivative works made from that copy.\n\n  This option is useful when you wish to copy part of the code of\nthe Library into a program that is not a library.\n\n  4. You may copy and distribute the Library (or a portion or\nderivative of it, under Section 2) in object code or executable form\nunder the terms of Sections 1 and 2 above provided that you accompany\nit with the complete corresponding machine-readable source code, which\nmust be distributed under the terms of Sections 1 and 2 above on a\nmedium customarily used for software interchange.\n\n  If distribution of object code is made by offering access to copy\nfrom a designated place, then offering equivalent access to copy the\nsource code from the same place satisfies the requirement to\ndistribute the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  5. A program that contains no derivative of any portion of the\nLibrary, but is designed to work with the Library by being compiled or\nlinked with it, is called a \"work that uses the Library\".  Such a\nwork, in isolation, is not a derivative work of the Library, and\ntherefore falls outside the scope of this License.\n\n  However, linking a \"work that uses the Library\" with the Library\ncreates an executable that is a derivative of the Library (because it\ncontains portions of the Library), rather than a \"work that uses the\nlibrary\".  The executable is therefore covered by this License.\nSection 6 states terms for distribution of such executables.\n\n  When a \"work that uses the Library\" uses material from a header file\nthat is part of the Library, the object code for the work may be a\nderivative work of the Library even though the source code is not.\nWhether this is true is especially significant if the work can be\nlinked without the Library, or if the work is itself a library.  The\nthreshold for this to be true is not precisely defined by law.\n\n  If such an object file uses only numerical parameters, data\nstructure layouts and accessors, and small macros and small inline\nfunctions (ten lines or less in length), then the use of the object\nfile is unrestricted, regardless of whether it is legally a derivative\nwork.  (Executables containing this object code plus portions of the\nLibrary will still fall under Section 6.)\n\n  Otherwise, if the work is a derivative of the Library, you may\ndistribute the object code for the work under the terms of Section 6.\nAny executables containing that work also fall under Section 6,\nwhether or not they are linked directly with the Library itself.\n\f\n  6. As an exception to the Sections above, you may also combine or\nlink a \"work that uses the Library\" with the Library to produce a\nwork containing portions of the Library, and distribute that work\nunder terms of your choice, provided that the terms permit\nmodification of the work for the customer's own use and reverse\nengineering for debugging such modifications.\n\n  You must give prominent notice with each copy of the work that the\nLibrary is used in it and that the Library and its use are covered by\nthis License.  You must supply a copy of this License.  If the work\nduring execution displays copyright notices, you must include the\ncopyright notice for the Library among them, as well as a reference\ndirecting the user to the copy of this License.  Also, you must do one\nof these things:\n\n    a) Accompany the work with the complete corresponding\n    machine-readable source code for the Library including whatever\n    changes were used in the work (which must be distributed under\n    Sections 1 and 2 above); and, if the work is an executable linked\n    with the Library, with the complete machine-readable \"work that\n    uses the Library\", as object code and/or source code, so that the\n    user can modify the Library and then relink to produce a modified\n    executable containing the modified Library.  (It is understood\n    that the user who changes the contents of definitions files in the\n    Library will not necessarily be able to recompile the application\n    to use the modified definitions.)\n\n    b) Use a suitable shared library mechanism for linking with the\n    Library.  A suitable mechanism is one that (1) uses at run time a\n    copy of the library already present on the user's computer system,\n    rather than copying library functions into the executable, and (2)\n    will operate properly with a modified version of the library, if\n    the user installs one, as long as the modified version is\n    interface-compatible with the version that the work was made with.\n\n    c) Accompany the work with a written offer, valid for at\n    least three years, to give the same user the materials\n    specified in Subsection 6a, above, for a charge no more\n    than the cost of performing this distribution.\n\n    d) If distribution of the work is made by offering access to copy\n    from a designated place, offer equivalent access to copy the above\n    specified materials from the same place.\n\n    e) Verify that the user has already received a copy of these\n    materials or that you have already sent this user a copy.\n\n  For an executable, the required form of the \"work that uses the\nLibrary\" must include any data and utility programs needed for\nreproducing the executable from it.  However, as a special exception,\nthe materials to be distributed need not include anything that is\nnormally distributed (in either source or binary form) with the major\ncomponents (compiler, kernel, and so on) of the operating system on\nwhich the executable runs, unless that component itself accompanies\nthe executable.\n\n  It may happen that this requirement contradicts the license\nrestrictions of other proprietary libraries that do not normally\naccompany the operating system.  Such a contradiction means you cannot\nuse both them and the Library together in an executable that you\ndistribute.\n\f\n  7. You may place library facilities that are a work based on the\nLibrary side-by-side in a single library together with other library\nfacilities not covered by this License, and distribute such a combined\nlibrary, provided that the separate distribution of the work based on\nthe Library and of the other library facilities is otherwise\npermitted, and provided that you do these two things:\n\n    a) Accompany the combined library with a copy of the same work\n    based on the Library, uncombined with any other library\n    facilities.  This must be distributed under the terms of the\n    Sections above.\n\n    b) Give prominent notice with the combined library of the fact\n    that part of it is a work based on the Library, and explaining\n    where to find the accompanying uncombined form of the same work.\n\n  8. You may not copy, modify, sublicense, link with, or distribute\nthe Library except as expressly provided under this License.  Any\nattempt otherwise to copy, modify, sublicense, link with, or\ndistribute the Library is void, and will automatically terminate your\nrights under this License.  However, parties who have received copies,\nor rights, from you under this License will not have their licenses\nterminated so long as such parties remain in full compliance.\n\n  9. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Library or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Library (or any work based on the\nLibrary), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Library or works based on it.\n\n  10. Each time you redistribute the Library (or any work based on the\nLibrary), the recipient automatically receives a license from the\noriginal licensor to copy, distribute, link with or modify the Library\nsubject to these terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties with\nthis License.\n\f\n  11. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Library at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Library by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Library.\n\nIf any portion of this section is held invalid or unenforceable under any\nparticular circumstance, the balance of the section is intended to apply,\nand the section as a whole is intended to apply in other circumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  12. If the distribution and/or use of the Library is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Library under this License may add\nan explicit geographical distribution limitation excluding those countries,\nso that distribution is permitted only in or among countries not thus\nexcluded.  In such case, this License incorporates the limitation as if\nwritten in the body of this License.\n\n  13. The Free Software Foundation may publish revised and/or new\nversions of the Lesser General Public License from time to time.\nSuch new versions will be similar in spirit to the present version,\nbut may differ in detail to address new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Library\nspecifies a version number of this License which applies to it and\n\"any later version\", you have the option of following the terms and\nconditions either of that version or of any later version published by\nthe Free Software Foundation.  If the Library does not specify a\nlicense version number, you may choose any version ever published by\nthe Free Software Foundation.\n\f\n  14. If you wish to incorporate parts of the Library into other free\nprograms whose distribution conditions are incompatible with these,\nwrite to the author to ask for permission.  For software which is\ncopyrighted by the Free Software Foundation, write to the Free\nSoftware Foundation; we sometimes make exceptions for this.  Our\ndecision will be guided by the two goals of preserving the free status\nof all derivatives of our free software and of promoting the sharing\nand reuse of software generally.\n\n                            NO WARRANTY\n\n  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO\nWARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.\nEXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR\nOTHER PARTIES PROVIDE THE LIBRARY \"AS IS\" WITHOUT WARRANTY OF ANY\nKIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE\nLIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME\nTHE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN\nWRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY\nAND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU\nFOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR\nCONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE\nLIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING\nRENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A\nFAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF\nSUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\f\n           How to Apply These Terms to Your New Libraries\n\n  If you develop a new library, and you want it to be of the greatest\npossible use to the public, we recommend making it free software that\neveryone can redistribute and change.  You can do so by permitting\nredistribution under these terms (or, alternatively, under the terms of the\nordinary General Public License).\n\n  To apply these terms, attach the following notices to the library.  It is\nsafest to attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least the\n\"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the library's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nAlso add information on how to contact you by electronic and paper mail.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the library, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the\n  library `Frob' (a library for tweaking knobs) written by James Random Hacker.\n\n  <signature of Ty Coon>, 1 April 1990\n  Ty Coon, President of Vice\n\nThat's all there is to it!\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.4248046875,
          "content": "The following files may be used under the terms of the GNU Lesser\nGeneral Public License, version 2.1 (\"LGPL\"):\n\n- All files in the include/ directory.\n- All files in the lib/ directory.\n- meson.build\n\nThe full terms of the LGPL can be found in the LGPL2.txt file.\n\n\nAll other files may be used only under the terms of the GNU General\nPublic License, version 2 (\"GPL\"). The full text of this license can\nbe found in the GPL2.txt file.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.296875,
          "content": "libfuse\n=======\n\nAbout\n-----\n\nFUSE (Filesystem in Userspace) is an interface for userspace programs\nto export a filesystem to the Linux kernel. The FUSE project consists\nof two components: the *fuse* kernel module (maintained in the regular\nkernel repositories) and the *libfuse* userspace library (maintained\nin this repository). libfuse provides the reference implementation\nfor communicating with the FUSE kernel module.\n\nA FUSE file system is typically implemented as a standalone\napplication that links with libfuse. libfuse provides functions to\nmount the file system, unmount it, read requests from the kernel, and\nsend responses back. libfuse offers two APIs: a \"high-level\",\nsynchronous API, and a \"low-level\" asynchronous API. In both cases,\nincoming requests from the kernel are passed to the main program using\ncallbacks. When using the high-level API, the callbacks may work with\nfile names and paths instead of inodes, and processing of a request\nfinishes when the callback function returns. When using the low-level\nAPI, the callbacks must work with inodes and responses must be sent\nexplicitly using a separate set of API functions.\n\n\nDevelopment Status\n------------------\n\nlibfuse is shipped by all major Linux distributions and has been in\nproduction use across a wide range of systems for many years. However,\nat present libfuse does not have any active, regular contributors. The\ncurrent maintainer continues to apply pull requests and makes regular\nreleases, but unfortunately has no capacity to do any development\nbeyond addressing high-impact issues. When reporting bugs, please\nunderstand that unless you are including a pull request or are\nreporting a critical issue, you will probably not get a response. If\nyou are using libfuse, please consider contributing to the project.\n\n\nSupported Platforms\n-------------------\n\n* Linux (fully)\n* BSD (mostly/best-effort)\n* For OS-X, please use [OSXFUSE](https://osxfuse.github.io/)\n  \n\nInstallation\n------------\n\nYou can download libfuse from https://github.com/libfuse/libfuse/releases. To build and\ninstall, you must use [Meson](http://mesonbuild.com/) and\n[Ninja](https://ninja-build.org).  After downloading the tarball and `.sig` file, verify\nit using [signify](https://www.openbsd.org/papers/bsdcan-signify.html):\n\n    signify -V -m fuse-X.Y.Z.tar.gz -p fuse-X.Y.pub\n    \nThe `fuse-X.Y.pub` file contains the signing key and needs to be obtained from a\ntrustworthy source. Each libfuse release contains the signing key for the release after it\nin the `signify` directory, so you only need to manually acquire this file once when you\ninstall libfuse for the first time.\n\nAfter you have validated the tarball, extract it, create a (temporary) build directory and\nrun Meson:\n\n    $ tar xzf fuse-X.Y.Z.tar.gz; cd fuse-X.Y.Z\n    $ mkdir build; cd build\n    $ meson setup ..\n\nNormally, the default build options will work fine. If you\nnevertheless want to adjust them, you can do so with the\n*meson configure* command:\n\n    $ meson configure # list options\n    $ meson configure -D disable-mtab=true # set an optionq\n\n    $ # ensure all meson options are applied to the final build system\n    $ meson setup --reconfigure ../\n\nTo build, test, and install libfuse, you then use Ninja:\n\n    $ ninja\n    $ sudo python3 -m pytest test/\n    $ sudo ninja install\n\nRunning the tests requires the [py.test](http://www.pytest.org/)\nPython module. Instead of running the tests as root, the majority of\ntests can also be run as a regular user if *util/fusermount3* is made\nsetuid root first:\n\n    $ sudo chown root:root util/fusermount3\n    $ sudo chmod 4755 util/fusermount3\n    $ python3 -m pytest test/\n\nSecurity implications\n---------------------\n\nThe *fusermount3* program is installed setuid root. This is done to\nallow normal users to mount their own filesystem implementations.\n\nTo limit the harm that malicious users can do this way, *fusermount3*\nenforces the following limitations:\n\n  - The user can only mount on a mountpoint for which they have write\n    permission\n\n  - The mountpoint must not be a sticky directory which isn't owned by\n    the user (like /tmp usually is)\n\n  - No other user (including root) can access the contents of the\n    mounted filesystem (though this can be relaxed by allowing the use\n    of the *allow_other* and *allow_root* mount options in\n    */etc/fuse.conf*)\n\n\nIf you intend to use the *allow_other* mount options, be aware that\nFUSE has an unresolved [security\nbug](https://github.com/libfuse/libfuse/issues/15): if the\n*default_permissions* mount option is not used, the results of the\nfirst permission check performed by the file system for a directory\nentry will be re-used for subsequent accesses as long as the inode of\nthe accessed entry is present in the kernel cache - even if the\npermissions have since changed, and even if the subsequent access is\nmade by a different user. This is of little concern if the filesystem\nis accessible only to the mounting user (which has full access to the\nfilesystem anyway), but becomes a security issue when other users are\nallowed to access the filesystem (since they can exploit this to\nperform operations on the filesystem that they do not actually have\npermissions for).\n\nThis bug needs to be fixed in the Linux kernel and has been known\nsince 2006 but unfortunately no fix has been applied yet. If you\ndepend on correct permission handling for FUSE file systems, the only\nworkaround is to use `default_permissions` (which does not currently\nsupport ACLs), or to completely disable caching of directory entry\nattributes.\n\nBuilding your own filesystem\n------------------------------\n\nFUSE comes with several example file systems in the `example`\ndirectory. For example, the *passthrough* examples mirror the contents\nof the root directory under the mountpoint. Start from there and adapt\nthe code!\n\nThe documentation of the API functions and necessary callbacks is\nmostly contained in the files `include/fuse.h` (for the high-level\nAPI) and `include/fuse_lowlevel.h` (for the low-level API). An\nautogenerated html version of the API is available in the `doc/html`\ndirectory and at http://libfuse.github.io/doxygen.\n\n\nGetting Help\n------------\n\nIf you need help, please ask on the <fuse-devel@lists.sourceforge.net>\nmailing list (subscribe at\nhttps://lists.sourceforge.net/lists/listinfo/fuse-devel).\n\nPlease report any bugs on the GitHub issue tracker at\nhttps://github.com/libfuse/libfuse/issues.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.857421875,
          "content": "# Security Policy\n\nIf you have discovered a security vulnerability in this project, please report it\nprivately. **Do not disclose it as a public issue.** This gives me time to work with you\nto fix the issue before public exposure, reducing the chance that the exploit will be\nused before a patch is released.\n\nPlease submit information on the vulnerability as a\n[private report](https://github.com/libfuse/libfuse/security/advisories/new).\n\nPlease provide the following information in your report:\n\n- A description of the vulnerability and its impact\n- How to reproduce the issue\n\nThis project is maintained by a single volunteer on a reasonable-effort basis. As such,\nI ask that you give me 90 days to work on a fix before public exposure.\n\nNote we are aware of a long-standing security issue when using `allow_others` (see\n[#15](https://github.com/libfuse/libfuse/issues/15))."
        },
        {
          "name": "checkpatch.pl",
          "type": "blob",
          "size": 233.5625,
          "content": "#!/usr/bin/env perl\n# SPDX-License-Identifier: GPL-2.0\n#\n# (c) 2001, Dave Jones. (the file handling bit)\n# (c) 2005, Joel Schopp <jschopp@austin.ibm.com> (the ugly bit)\n# (c) 2007,2008, Andy Whitcroft <apw@uk.ibm.com> (new conditions, test suite)\n# (c) 2008-2010 Andy Whitcroft <apw@canonical.com>\n# (c) 2010-2018 Joe Perches <joe@perches.com>\n\nuse strict;\nuse warnings;\nuse POSIX;\nuse File::Basename;\nuse Cwd 'abs_path';\nuse Term::ANSIColor qw(:constants);\nuse Encode qw(decode encode);\n\nmy $P = $0;\nmy $D = dirname(abs_path($P));\n\nmy $V = '0.32';\n\nuse Getopt::Long qw(:config no_auto_abbrev);\n\nmy $quiet = 0;\nmy $verbose = 0;\nmy %verbose_messages = ();\nmy %verbose_emitted = ();\nmy $tree = 1;\nmy $chk_signoff = 1;\nmy $chk_fixes_tag = 1;\nmy $chk_patch = 1;\nmy $tst_only;\nmy $emacs = 0;\nmy $terse = 0;\nmy $showfile = 0;\nmy $file = 0;\nmy $git = 0;\nmy %git_commits = ();\nmy $check = 0;\nmy $check_orig = 0;\nmy $summary = 1;\nmy $mailback = 0;\nmy $summary_file = 0;\nmy $show_types = 0;\nmy $list_types = 0;\nmy $fix = 0;\nmy $fix_inplace = 0;\nmy $root;\nmy $gitroot = $ENV{'GIT_DIR'};\n$gitroot = \".git\" if !defined($gitroot);\nmy %debug;\nmy %camelcase = ();\nmy %use_type = ();\nmy @use = ();\nmy %ignore_type = ();\nmy @ignore = ();\nmy $help = 0;\nmy $configuration_file = \".checkpatch.conf\";\nmy $max_line_length = 100;\nmy $ignore_perl_version = 0;\nmy $minimum_perl_version = 5.10.0;\nmy $min_conf_desc_length = 4;\nmy $spelling_file = \"$D/spelling.txt\";\nmy $codespell = 0;\nmy $codespellfile = \"/usr/share/codespell/dictionary.txt\";\nmy $user_codespellfile = \"\";\nmy $conststructsfile = \"$D/const_structs.checkpatch\";\nmy $docsfile = \"$D/../Documentation/dev-tools/checkpatch.rst\";\nmy $typedefsfile;\nmy $color = \"auto\";\nmy $allow_c99_comments = 1; # Can be overridden by --ignore C99_COMMENT_TOLERANCE\n# git output parsing needs US English output, so first set backtick child process LANGUAGE\nmy $git_command ='export LANGUAGE=en_US.UTF-8; git';\nmy $tabsize = 8;\nmy ${CONFIG_} = \"CONFIG_\";\n\nmy %maybe_linker_symbol; # for externs in c exceptions, when seen in *vmlinux.lds.h\n\nsub help {\n\tmy ($exitcode) = @_;\n\n\tprint << \"EOM\";\nUsage: $P [OPTION]... [FILE]...\nVersion: $V\n\nOptions:\n  -q, --quiet                quiet\n  -v, --verbose              verbose mode\n  --no-tree                  run without a kernel tree\n  --no-signoff               do not check for 'Signed-off-by' line\n  --no-fixes-tag             do not check for 'Fixes:' tag\n  --patch                    treat FILE as patchfile (default)\n  --emacs                    emacs compile window format\n  --terse                    one line per report\n  --showfile                 emit diffed file position, not input file position\n  -g, --git                  treat FILE as a single commit or git revision range\n                             single git commit with:\n                               <rev>\n                               <rev>^\n                               <rev>~n\n                             multiple git commits with:\n                               <rev1>..<rev2>\n                               <rev1>...<rev2>\n                               <rev>-<count>\n                             git merges are ignored\n  -f, --file                 treat FILE as regular source file\n  --subjective, --strict     enable more subjective tests\n  --list-types               list the possible message types\n  --types TYPE(,TYPE2...)    show only these comma separated message types\n  --ignore TYPE(,TYPE2...)   ignore various comma separated message types\n  --show-types               show the specific message type in the output\n  --max-line-length=n        set the maximum line length, (default $max_line_length)\n                             if exceeded, warn on patches\n                             requires --strict for use with --file\n  --min-conf-desc-length=n   set the min description length, if shorter, warn\n  --tab-size=n               set the number of spaces for tab (default $tabsize)\n  --root=PATH                PATH to the kernel tree root\n  --no-summary               suppress the per-file summary\n  --mailback                 only produce a report in case of warnings/errors\n  --summary-file             include the filename in summary\n  --debug KEY=[0|1]          turn on/off debugging of KEY, where KEY is one of\n                             'values', 'possible', 'type', and 'attr' (default\n                             is all off)\n  --test-only=WORD           report only warnings/errors containing WORD\n                             literally\n  --fix                      EXPERIMENTAL - may create horrible results\n                             If correctable single-line errors exist, create\n                             \"<inputfile>.EXPERIMENTAL-checkpatch-fixes\"\n                             with potential errors corrected to the preferred\n                             checkpatch style\n  --fix-inplace              EXPERIMENTAL - may create horrible results\n                             Is the same as --fix, but overwrites the input\n                             file.  It's your fault if there's no backup or git\n  --ignore-perl-version      override checking of perl version.  expect\n                             runtime errors.\n  --codespell                Use the codespell dictionary for spelling/typos\n                             (default:$codespellfile)\n  --codespellfile            Use this codespell dictionary\n  --typedefsfile             Read additional types from this file\n  --color[=WHEN]             Use colors 'always', 'never', or only when output\n                             is a terminal ('auto'). Default is 'auto'.\n  --kconfig-prefix=WORD      use WORD as a prefix for Kconfig symbols (default\n                             ${CONFIG_})\n  -h, --help, --version      display this help and exit\n\nWhen FILE is - read standard input.\nEOM\n\n\texit($exitcode);\n}\n\nsub uniq {\n\tmy %seen;\n\treturn grep { !$seen{$_}++ } @_;\n}\n\nsub list_types {\n\tmy ($exitcode) = @_;\n\n\tmy $count = 0;\n\n\tlocal $/ = undef;\n\n\topen(my $script, '<', abs_path($P)) or\n\t    die \"$P: Can't read '$P' $!\\n\";\n\n\tmy $text = <$script>;\n\tclose($script);\n\n\tmy %types = ();\n\t# Also catch when type or level is passed through a variable\n\twhile ($text =~ /(?:(\\bCHK|\\bWARN|\\bERROR|&\\{\\$msg_level})\\s*\\(|\\$msg_type\\s*=)\\s*\"([^\"]+)\"/g) {\n\t\tif (defined($1)) {\n\t\t\tif (exists($types{$2})) {\n\t\t\t\t$types{$2} .= \",$1\" if ($types{$2} ne $1);\n\t\t\t} else {\n\t\t\t\t$types{$2} = $1;\n\t\t\t}\n\t\t} else {\n\t\t\t$types{$2} = \"UNDETERMINED\";\n\t\t}\n\t}\n\n\tprint(\"#\\tMessage type\\n\\n\");\n\tif ($color) {\n\t\tprint(\" ( Color coding: \");\n\t\tprint(RED . \"ERROR\" . RESET);\n\t\tprint(\" | \");\n\t\tprint(YELLOW . \"WARNING\" . RESET);\n\t\tprint(\" | \");\n\t\tprint(GREEN . \"CHECK\" . RESET);\n\t\tprint(\" | \");\n\t\tprint(\"Multiple levels / Undetermined\");\n\t\tprint(\" )\\n\\n\");\n\t}\n\n\tforeach my $type (sort keys %types) {\n\t\tmy $orig_type = $type;\n\t\tif ($color) {\n\t\t\tmy $level = $types{$type};\n\t\t\tif ($level eq \"ERROR\") {\n\t\t\t\t$type = RED . $type . RESET;\n\t\t\t} elsif ($level eq \"WARN\") {\n\t\t\t\t$type = YELLOW . $type . RESET;\n\t\t\t} elsif ($level eq \"CHK\") {\n\t\t\t\t$type = GREEN . $type . RESET;\n\t\t\t}\n\t\t}\n\t\tprint(++$count . \"\\t\" . $type . \"\\n\");\n\t\tif ($verbose && exists($verbose_messages{$orig_type})) {\n\t\t\tmy $message = $verbose_messages{$orig_type};\n\t\t\t$message =~ s/\\n/\\n\\t/g;\n\t\t\tprint(\"\\t\" . $message . \"\\n\\n\");\n\t\t}\n\t}\n\n\texit($exitcode);\n}\n\nmy $conf = which_conf($configuration_file);\nif (-f $conf) {\n\tmy @conf_args;\n\topen(my $conffile, '<', \"$conf\")\n\t    or warn \"$P: Can't find a readable $configuration_file file $!\\n\";\n\n\twhile (<$conffile>) {\n\t\tmy $line = $_;\n\n\t\t$line =~ s/\\s*\\n?$//g;\n\t\t$line =~ s/^\\s*//g;\n\t\t$line =~ s/\\s+/ /g;\n\n\t\tnext if ($line =~ m/^\\s*#/);\n\t\tnext if ($line =~ m/^\\s*$/);\n\n\t\tmy @words = split(\" \", $line);\n\t\tforeach my $word (@words) {\n\t\t\tlast if ($word =~ m/^#/);\n\t\t\tpush (@conf_args, $word);\n\t\t}\n\t}\n\tclose($conffile);\n\tunshift(@ARGV, @conf_args) if @conf_args;\n}\n\nsub load_docs {\n\topen(my $docs, '<', \"$docsfile\")\n\t    or warn \"$P: Can't read the documentation file $docsfile $!\\n\";\n\n\tmy $type = '';\n\tmy $desc = '';\n\tmy $in_desc = 0;\n\n\twhile (<$docs>) {\n\t\tchomp;\n\t\tmy $line = $_;\n\t\t$line =~ s/\\s+$//;\n\n\t\tif ($line =~ /^\\s*\\*\\*(.+)\\*\\*$/) {\n\t\t\tif ($desc ne '') {\n\t\t\t\t$verbose_messages{$type} = trim($desc);\n\t\t\t}\n\t\t\t$type = $1;\n\t\t\t$desc = '';\n\t\t\t$in_desc = 1;\n\t\t} elsif ($in_desc) {\n\t\t\tif ($line =~ /^(?:\\s{4,}|$)/) {\n\t\t\t\t$line =~ s/^\\s{4}//;\n\t\t\t\t$desc .= $line;\n\t\t\t\t$desc .= \"\\n\";\n\t\t\t} else {\n\t\t\t\t$verbose_messages{$type} = trim($desc);\n\t\t\t\t$type = '';\n\t\t\t\t$desc = '';\n\t\t\t\t$in_desc = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ($desc ne '') {\n\t\t$verbose_messages{$type} = trim($desc);\n\t}\n\tclose($docs);\n}\n\n# Perl's Getopt::Long allows options to take optional arguments after a space.\n# Prevent --color by itself from consuming other arguments\nforeach (@ARGV) {\n\tif ($_ eq \"--color\" || $_ eq \"-color\") {\n\t\t$_ = \"--color=$color\";\n\t}\n}\n\nGetOptions(\n\t'q|quiet+'\t=> \\$quiet,\n\t'v|verbose!'\t=> \\$verbose,\n\t'tree!'\t\t=> \\$tree,\n\t'signoff!'\t=> \\$chk_signoff,\n\t'fixes-tag!'\t=> \\$chk_fixes_tag,\n\t'patch!'\t=> \\$chk_patch,\n\t'emacs!'\t=> \\$emacs,\n\t'terse!'\t=> \\$terse,\n\t'showfile!'\t=> \\$showfile,\n\t'f|file!'\t=> \\$file,\n\t'g|git!'\t=> \\$git,\n\t'subjective!'\t=> \\$check,\n\t'strict!'\t=> \\$check,\n\t'ignore=s'\t=> \\@ignore,\n\t'types=s'\t=> \\@use,\n\t'show-types!'\t=> \\$show_types,\n\t'list-types!'\t=> \\$list_types,\n\t'max-line-length=i' => \\$max_line_length,\n\t'min-conf-desc-length=i' => \\$min_conf_desc_length,\n\t'tab-size=i'\t=> \\$tabsize,\n\t'root=s'\t=> \\$root,\n\t'summary!'\t=> \\$summary,\n\t'mailback!'\t=> \\$mailback,\n\t'summary-file!'\t=> \\$summary_file,\n\t'fix!'\t\t=> \\$fix,\n\t'fix-inplace!'\t=> \\$fix_inplace,\n\t'ignore-perl-version!' => \\$ignore_perl_version,\n\t'debug=s'\t=> \\%debug,\n\t'test-only=s'\t=> \\$tst_only,\n\t'codespell!'\t=> \\$codespell,\n\t'codespellfile=s'\t=> \\$user_codespellfile,\n\t'typedefsfile=s'\t=> \\$typedefsfile,\n\t'color=s'\t=> \\$color,\n\t'no-color'\t=> \\$color,\t#keep old behaviors of -nocolor\n\t'nocolor'\t=> \\$color,\t#keep old behaviors of -nocolor\n\t'kconfig-prefix=s'\t=> \\${CONFIG_},\n\t'h|help'\t=> \\$help,\n\t'version'\t=> \\$help\n) or $help = 2;\n\nif ($user_codespellfile) {\n\t# Use the user provided codespell file unconditionally\n\t$codespellfile = $user_codespellfile;\n} elsif (!(-f $codespellfile)) {\n\t# If /usr/share/codespell/dictionary.txt is not present, try to find it\n\t# under codespell's install directory: <codespell_root>/data/dictionary.txt\n\tif (($codespell || $help) && which(\"python3\") ne \"\") {\n\t\tmy $python_codespell_dict = << \"EOF\";\n\nimport os.path as op\nimport codespell_lib\ncodespell_dir = op.dirname(codespell_lib.__file__)\ncodespell_file = op.join(codespell_dir, 'data', 'dictionary.txt')\nprint(codespell_file, end='')\nEOF\n\n\t\tmy $codespell_dict = `python3 -c \"$python_codespell_dict\" 2> /dev/null`;\n\t\t$codespellfile = $codespell_dict if (-f $codespell_dict);\n\t}\n}\n\n# $help is 1 if either -h, --help or --version is passed as option - exitcode: 0\n# $help is 2 if invalid option is passed - exitcode: 1\nhelp($help - 1) if ($help);\n\ndie \"$P: --git cannot be used with --file or --fix\\n\" if ($git && ($file || $fix));\ndie \"$P: --verbose cannot be used with --terse\\n\" if ($verbose && $terse);\n\nif ($color =~ /^[01]$/) {\n\t$color = !$color;\n} elsif ($color =~ /^always$/i) {\n\t$color = 1;\n} elsif ($color =~ /^never$/i) {\n\t$color = 0;\n} elsif ($color =~ /^auto$/i) {\n\t$color = (-t STDOUT);\n} else {\n\tdie \"$P: Invalid color mode: $color\\n\";\n}\n\nload_docs() if ($verbose);\nlist_types(0) if ($list_types);\n\n$fix = 1 if ($fix_inplace);\n$check_orig = $check;\n\nmy $exit = 0;\n\nmy $perl_version_ok = 1;\nif ($^V && $^V lt $minimum_perl_version) {\n\t$perl_version_ok = 0;\n\tprintf \"$P: requires at least perl version %vd\\n\", $minimum_perl_version;\n\texit(1) if (!$ignore_perl_version);\n}\n\n#if no filenames are given, push '-' to read patch from stdin\nif ($#ARGV < 0) {\n\tpush(@ARGV, '-');\n}\n\n# skip TAB size 1 to avoid additional checks on $tabsize - 1\ndie \"$P: Invalid TAB size: $tabsize\\n\" if ($tabsize < 2);\n\nsub hash_save_array_words {\n\tmy ($hashRef, $arrayRef) = @_;\n\n\tmy @array = split(/,/, join(',', @$arrayRef));\n\tforeach my $word (@array) {\n\t\t$word =~ s/\\s*\\n?$//g;\n\t\t$word =~ s/^\\s*//g;\n\t\t$word =~ s/\\s+/ /g;\n\t\t$word =~ tr/[a-z]/[A-Z]/;\n\n\t\tnext if ($word =~ m/^\\s*#/);\n\t\tnext if ($word =~ m/^\\s*$/);\n\n\t\t$hashRef->{$word}++;\n\t}\n}\n\nsub hash_show_words {\n\tmy ($hashRef, $prefix) = @_;\n\n\tif (keys %$hashRef) {\n\t\tprint \"\\nNOTE: $prefix message types:\";\n\t\tforeach my $word (sort keys %$hashRef) {\n\t\t\tprint \" $word\";\n\t\t}\n\t\tprint \"\\n\";\n\t}\n}\n\nhash_save_array_words(\\%ignore_type, \\@ignore);\nhash_save_array_words(\\%use_type, \\@use);\n\nmy $dbg_values = 0;\nmy $dbg_possible = 0;\nmy $dbg_type = 0;\nmy $dbg_attr = 0;\nfor my $key (keys %debug) {\n\t## no critic\n\teval \"\\${dbg_$key} = '$debug{$key}';\";\n\tdie \"$@\" if ($@);\n}\n\nmy $rpt_cleaners = 0;\n\nif ($terse) {\n\t$emacs = 1;\n\t$quiet++;\n}\n\nif ($tree) {\n\tif (defined $root) {\n\t\tif (!top_of_kernel_tree($root)) {\n\t\t\tdie \"$P: $root: --root does not point at a valid tree\\n\";\n\t\t}\n\t} else {\n\t\tif (top_of_kernel_tree('.')) {\n\t\t\t$root = '.';\n\t\t} elsif ($0 =~ m@(.*)/scripts/[^/]*$@ &&\n\t\t\t\t\t\ttop_of_kernel_tree($1)) {\n\t\t\t$root = $1;\n\t\t}\n\t}\n\n\tif (!defined $root) {\n\t\tprint \"Must be run from the top-level dir. of a kernel tree\\n\";\n\t\texit(2);\n\t}\n}\n\nmy $emitted_corrupt = 0;\n\nour $Ident\t= qr{\n\t\t\t[A-Za-z_][A-Za-z\\d_]*\n\t\t\t(?:\\s*\\#\\#\\s*[A-Za-z_][A-Za-z\\d_]*)*\n\t\t}x;\nour $Storage\t= qr{extern|static|asmlinkage};\nour $Sparse\t= qr{\n\t\t\t__user|\n\t\t\t__kernel|\n\t\t\t__force|\n\t\t\t__iomem|\n\t\t\t__must_check|\n\t\t\t__kprobes|\n\t\t\t__ref|\n\t\t\t__refconst|\n\t\t\t__refdata|\n\t\t\t__rcu|\n\t\t\t__private\n\t\t}x;\nour $InitAttributePrefix = qr{__(?:mem|cpu|dev|net_|)};\nour $InitAttributeData = qr{$InitAttributePrefix(?:initdata\\b)};\nour $InitAttributeConst = qr{$InitAttributePrefix(?:initconst\\b)};\nour $InitAttributeInit = qr{$InitAttributePrefix(?:init\\b)};\nour $InitAttribute = qr{$InitAttributeData|$InitAttributeConst|$InitAttributeInit};\n\n# Notes to $Attribute:\n# We need \\b after 'init' otherwise 'initconst' will cause a false positive in a check\nour $Attribute\t= qr{\n\t\t\tconst|\n\t\t\tvolatile|\n\t\t\t__percpu|\n\t\t\t__nocast|\n\t\t\t__safe|\n\t\t\t__bitwise|\n\t\t\t__packed__|\n\t\t\t__packed2__|\n\t\t\t__naked|\n\t\t\t__maybe_unused|\n\t\t\t__always_unused|\n\t\t\t__noreturn|\n\t\t\t__used|\n\t\t\t__cold|\n\t\t\t__pure|\n\t\t\t__noclone|\n\t\t\t__deprecated|\n\t\t\t__read_mostly|\n\t\t\t__ro_after_init|\n\t\t\t__kprobes|\n\t\t\t$InitAttribute|\n\t\t\t__aligned\\s*\\(.*\\)|\n\t\t\t____cacheline_aligned|\n\t\t\t____cacheline_aligned_in_smp|\n\t\t\t____cacheline_internodealigned_in_smp|\n\t\t\t__weak|\n\t\t\t__alloc_size\\s*\\(\\s*\\d+\\s*(?:,\\s*\\d+\\s*)?\\)\n\t\t  }x;\nour $Modifier;\nour $Inline\t= qr{inline|__always_inline|noinline|__inline|__inline__};\nour $Member\t= qr{->$Ident|\\.$Ident|\\[[^]]*\\]};\nour $Lval\t= qr{$Ident(?:$Member)*};\n\nour $Int_type\t= qr{(?i)llu|ull|ll|lu|ul|l|u};\nour $Binary\t= qr{(?i)0b[01]+$Int_type?};\nour $Hex\t= qr{(?i)0x[0-9a-f]+$Int_type?};\nour $Int\t= qr{[0-9]+$Int_type?};\nour $Octal\t= qr{0[0-7]+$Int_type?};\nour $String\t= qr{(?:\\b[Lu])?\"[X\\t]*\"};\nour $Float_hex\t= qr{(?i)0x[0-9a-f]+p-?[0-9]+[fl]?};\nour $Float_dec\t= qr{(?i)(?:[0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)(?:e-?[0-9]+)?[fl]?};\nour $Float_int\t= qr{(?i)[0-9]+e-?[0-9]+[fl]?};\nour $Float\t= qr{$Float_hex|$Float_dec|$Float_int};\nour $Constant\t= qr{$Float|$Binary|$Octal|$Hex|$Int};\nour $Assignment\t= qr{\\*\\=|/=|%=|\\+=|-=|<<=|>>=|&=|\\^=|\\|=|=};\nour $Compare    = qr{<=|>=|==|!=|<|(?<!-)>};\nour $Arithmetic = qr{\\+|-|\\*|\\/|%};\nour $Operators\t= qr{\n\t\t\t<=|>=|==|!=|\n\t\t\t=>|->|<<|>>|<|>|!|~|\n\t\t\t&&|\\|\\||,|\\^|\\+\\+|--|&|\\||$Arithmetic\n\t\t  }x;\n\nour $c90_Keywords = qr{do|for|while|if|else|return|goto|continue|switch|default|case|break}x;\n\nour $BasicType;\nour $NonptrType;\nour $NonptrTypeMisordered;\nour $NonptrTypeWithAttr;\nour $Type;\nour $TypeMisordered;\nour $Declare;\nour $DeclareMisordered;\n\nour $NON_ASCII_UTF8\t= qr{\n\t[\\xC2-\\xDF][\\x80-\\xBF]               # non-overlong 2-byte\n\t|  \\xE0[\\xA0-\\xBF][\\x80-\\xBF]        # excluding overlongs\n\t| [\\xE1-\\xEC\\xEE\\xEF][\\x80-\\xBF]{2}  # straight 3-byte\n\t|  \\xED[\\x80-\\x9F][\\x80-\\xBF]        # excluding surrogates\n\t|  \\xF0[\\x90-\\xBF][\\x80-\\xBF]{2}     # planes 1-3\n\t| [\\xF1-\\xF3][\\x80-\\xBF]{3}          # planes 4-15\n\t|  \\xF4[\\x80-\\x8F][\\x80-\\xBF]{2}     # plane 16\n}x;\n\nour $UTF8\t= qr{\n\t[\\x09\\x0A\\x0D\\x20-\\x7E]              # ASCII\n\t| $NON_ASCII_UTF8\n}x;\n\nour $typeC99Typedefs = qr{(?:__)?(?:[us]_?)?int_?(?:8|16|32|64)_t};\nour $typeOtherOSTypedefs = qr{(?x:\n\tu_(?:char|short|int|long) |          # bsd\n\tu(?:nchar|short|int|long)            # sysv\n)};\nour $typeKernelTypedefs = qr{(?x:\n\t(?:__)?(?:u|s|be|le)(?:8|16|32|64)|\n\tatomic_t\n)};\nour $typeStdioTypedefs = qr{(?x:\n\tFILE\n)};\nour $typeTypedefs = qr{(?x:\n\t$typeC99Typedefs\\b|\n\t$typeOtherOSTypedefs\\b|\n\t$typeKernelTypedefs\\b|\n\t$typeStdioTypedefs\\b\n)};\n\nour $zero_initializer = qr{(?:(?:0[xX])?0+$Int_type?|NULL|false)\\b};\n\nour $logFunctions = qr{(?x:\n\tprintk(?:_ratelimited|_once|_deferred_once|_deferred|)|\n\t(?:[a-z0-9]+_){1,2}(?:printk|emerg|alert|crit|err|warning|warn|notice|info|debug|dbg|vdbg|devel|cont|WARN)(?:_ratelimited|_once|)|\n\tTP_printk|\n\tWARN(?:_RATELIMIT|_ONCE|)|\n\tpanic|\n\tMODULE_[A-Z_]+|\n\tseq_vprintf|seq_printf|seq_puts\n)};\n\nour $allocFunctions = qr{(?x:\n\t(?:(?:devm_)?\n\t\t(?:kv|k|v)[czm]alloc(?:_array)?(?:_node)? |\n\t\tkstrdup(?:_const)? |\n\t\tkmemdup(?:_nul)?) |\n\t(?:\\w+)?alloc_skb(?:_ip_align)? |\n\t\t\t\t# dev_alloc_skb/netdev_alloc_skb, et al\n\tdma_alloc_coherent\n)};\n\nour $signature_tags = qr{(?xi:\n\tSigned-off-by:|\n\tCo-developed-by:|\n\tAcked-by:|\n\tTested-by:|\n\tReviewed-by:|\n\tReported-by:|\n\tSuggested-by:|\n\tTo:|\n\tCc:\n)};\n\nour @link_tags = qw(Link Closes);\n\n#Create a search and print patterns for all these strings to be used directly below\nour $link_tags_search = \"\";\nour $link_tags_print = \"\";\nforeach my $entry (@link_tags) {\n\tif ($link_tags_search ne \"\") {\n\t\t$link_tags_search .= '|';\n\t\t$link_tags_print .= ' or ';\n\t}\n\t$entry .= ':';\n\t$link_tags_search .= $entry;\n\t$link_tags_print .= \"'$entry'\";\n}\n$link_tags_search = \"(?:${link_tags_search})\";\n\nour $tracing_logging_tags = qr{(?xi:\n\t[=-]*> |\n\t<[=-]* |\n\t\\[ |\n\t\\] |\n\tstart |\n\tcalled |\n\tentered |\n\tentry |\n\tenter |\n\tin |\n\tinside |\n\there |\n\tbegin |\n\texit |\n\tend |\n\tdone |\n\tleave |\n\tcompleted |\n\tout |\n\treturn |\n\t[\\.\\!:\\s]*\n)};\n\nsub edit_distance_min {\n\tmy (@arr) = @_;\n\tmy $len = scalar @arr;\n\tif ((scalar @arr) < 1) {\n\t\t# if underflow, return\n\t\treturn;\n\t}\n\tmy $min = $arr[0];\n\tfor my $i (0 .. ($len-1)) {\n\t\tif ($arr[$i] < $min) {\n\t\t\t$min = $arr[$i];\n\t\t}\n\t}\n\treturn $min;\n}\n\nsub get_edit_distance {\n\tmy ($str1, $str2) = @_;\n\t$str1 = lc($str1);\n\t$str2 = lc($str2);\n\t$str1 =~ s/-//g;\n\t$str2 =~ s/-//g;\n\tmy $len1 = length($str1);\n\tmy $len2 = length($str2);\n\t# two dimensional array storing minimum edit distance\n\tmy @distance;\n\tfor my $i (0 .. $len1) {\n\t\tfor my $j (0 .. $len2) {\n\t\t\tif ($i == 0) {\n\t\t\t\t$distance[$i][$j] = $j;\n\t\t\t} elsif ($j == 0) {\n\t\t\t\t$distance[$i][$j] = $i;\n\t\t\t} elsif (substr($str1, $i-1, 1) eq substr($str2, $j-1, 1)) {\n\t\t\t\t$distance[$i][$j] = $distance[$i - 1][$j - 1];\n\t\t\t} else {\n\t\t\t\tmy $dist1 = $distance[$i][$j - 1]; #insert distance\n\t\t\t\tmy $dist2 = $distance[$i - 1][$j]; # remove\n\t\t\t\tmy $dist3 = $distance[$i - 1][$j - 1]; #replace\n\t\t\t\t$distance[$i][$j] = 1 + edit_distance_min($dist1, $dist2, $dist3);\n\t\t\t}\n\t\t}\n\t}\n\treturn $distance[$len1][$len2];\n}\n\nsub find_standard_signature {\n\tmy ($sign_off) = @_;\n\tmy @standard_signature_tags = (\n\t\t'Signed-off-by:', 'Co-developed-by:', 'Acked-by:', 'Tested-by:',\n\t\t'Reviewed-by:', 'Reported-by:', 'Suggested-by:'\n\t);\n\tforeach my $signature (@standard_signature_tags) {\n\t\treturn $signature if (get_edit_distance($sign_off, $signature) <= 2);\n\t}\n\n\treturn \"\";\n}\n\nour $obsolete_archives = qr{(?xi:\n\t\\Qfreedesktop.org/archives/dri-devel\\E |\n\t\\Qlists.infradead.org\\E |\n\t\\Qlkml.org\\E |\n\t\\Qmail-archive.com\\E |\n\t\\Qmailman.alsa-project.org/pipermail\\E |\n\t\\Qmarc.info\\E |\n\t\\Qozlabs.org/pipermail\\E |\n\t\\Qspinics.net\\E\n)};\n\nour @typeListMisordered = (\n\tqr{char\\s+(?:un)?signed},\n\tqr{int\\s+(?:(?:un)?signed\\s+)?short\\s},\n\tqr{int\\s+short(?:\\s+(?:un)?signed)},\n\tqr{short\\s+int(?:\\s+(?:un)?signed)},\n\tqr{(?:un)?signed\\s+int\\s+short},\n\tqr{short\\s+(?:un)?signed},\n\tqr{long\\s+int\\s+(?:un)?signed},\n\tqr{int\\s+long\\s+(?:un)?signed},\n\tqr{long\\s+(?:un)?signed\\s+int},\n\tqr{int\\s+(?:un)?signed\\s+long},\n\tqr{int\\s+(?:un)?signed},\n\tqr{int\\s+long\\s+long\\s+(?:un)?signed},\n\tqr{long\\s+long\\s+int\\s+(?:un)?signed},\n\tqr{long\\s+long\\s+(?:un)?signed\\s+int},\n\tqr{long\\s+long\\s+(?:un)?signed},\n\tqr{long\\s+(?:un)?signed},\n);\n\nour @typeList = (\n\tqr{void},\n\tqr{(?:(?:un)?signed\\s+)?char},\n\tqr{(?:(?:un)?signed\\s+)?short\\s+int},\n\tqr{(?:(?:un)?signed\\s+)?short},\n\tqr{(?:(?:un)?signed\\s+)?int},\n\tqr{(?:(?:un)?signed\\s+)?long\\s+int},\n\tqr{(?:(?:un)?signed\\s+)?long\\s+long\\s+int},\n\tqr{(?:(?:un)?signed\\s+)?long\\s+long},\n\tqr{(?:(?:un)?signed\\s+)?long},\n\tqr{(?:un)?signed},\n\tqr{float},\n\tqr{double},\n\tqr{bool},\n\tqr{struct\\s+$Ident},\n\tqr{union\\s+$Ident},\n\tqr{enum\\s+$Ident},\n\tqr{${Ident}_t},\n\tqr{${Ident}_handler},\n\tqr{${Ident}_handler_fn},\n\t@typeListMisordered,\n);\n\nour $C90_int_types = qr{(?x:\n\tlong\\s+long\\s+int\\s+(?:un)?signed|\n\tlong\\s+long\\s+(?:un)?signed\\s+int|\n\tlong\\s+long\\s+(?:un)?signed|\n\t(?:(?:un)?signed\\s+)?long\\s+long\\s+int|\n\t(?:(?:un)?signed\\s+)?long\\s+long|\n\tint\\s+long\\s+long\\s+(?:un)?signed|\n\tint\\s+(?:(?:un)?signed\\s+)?long\\s+long|\n\n\tlong\\s+int\\s+(?:un)?signed|\n\tlong\\s+(?:un)?signed\\s+int|\n\tlong\\s+(?:un)?signed|\n\t(?:(?:un)?signed\\s+)?long\\s+int|\n\t(?:(?:un)?signed\\s+)?long|\n\tint\\s+long\\s+(?:un)?signed|\n\tint\\s+(?:(?:un)?signed\\s+)?long|\n\n\tint\\s+(?:un)?signed|\n\t(?:(?:un)?signed\\s+)?int\n)};\n\nour @typeListFile = ();\nour @typeListWithAttr = (\n\t@typeList,\n\tqr{struct\\s+$InitAttribute\\s+$Ident},\n\tqr{union\\s+$InitAttribute\\s+$Ident},\n);\n\nour @modifierList = (\n\tqr{fastcall},\n);\nour @modifierListFile = ();\n\nour @mode_permission_funcs = (\n\t[\"module_param\", 3],\n\t[\"module_param_(?:array|named|string)\", 4],\n\t[\"module_param_array_named\", 5],\n\t[\"debugfs_create_(?:file|u8|u16|u32|u64|x8|x16|x32|x64|size_t|atomic_t|bool|blob|regset32|u32_array)\", 2],\n\t[\"proc_create(?:_data|)\", 2],\n\t[\"(?:CLASS|DEVICE|SENSOR|SENSOR_DEVICE|IIO_DEVICE)_ATTR\", 2],\n\t[\"IIO_DEV_ATTR_[A-Z_]+\", 1],\n\t[\"SENSOR_(?:DEVICE_|)ATTR_2\", 2],\n\t[\"SENSOR_TEMPLATE(?:_2|)\", 3],\n\t[\"__ATTR\", 2],\n);\n\nmy $word_pattern = '\\b[A-Z]?[a-z]{2,}\\b';\n\n#Create a search pattern for all these functions to speed up a loop below\nour $mode_perms_search = \"\";\nforeach my $entry (@mode_permission_funcs) {\n\t$mode_perms_search .= '|' if ($mode_perms_search ne \"\");\n\t$mode_perms_search .= $entry->[0];\n}\n$mode_perms_search = \"(?:${mode_perms_search})\";\n\nour %deprecated_apis = (\n\t\"synchronize_rcu_bh\"\t\t\t=> \"synchronize_rcu\",\n\t\"synchronize_rcu_bh_expedited\"\t\t=> \"synchronize_rcu_expedited\",\n\t\"call_rcu_bh\"\t\t\t\t=> \"call_rcu\",\n\t\"rcu_barrier_bh\"\t\t\t=> \"rcu_barrier\",\n\t\"synchronize_sched\"\t\t\t=> \"synchronize_rcu\",\n\t\"synchronize_sched_expedited\"\t\t=> \"synchronize_rcu_expedited\",\n\t\"call_rcu_sched\"\t\t\t=> \"call_rcu\",\n\t\"rcu_barrier_sched\"\t\t\t=> \"rcu_barrier\",\n\t\"get_state_synchronize_sched\"\t\t=> \"get_state_synchronize_rcu\",\n\t\"cond_synchronize_sched\"\t\t=> \"cond_synchronize_rcu\",\n\t\"kmap\"\t\t\t\t\t=> \"kmap_local_page\",\n\t\"kunmap\"\t\t\t\t=> \"kunmap_local\",\n\t\"kmap_atomic\"\t\t\t\t=> \"kmap_local_page\",\n\t\"kunmap_atomic\"\t\t\t\t=> \"kunmap_local\",\n);\n\n#Create a search pattern for all these strings to speed up a loop below\nour $deprecated_apis_search = \"\";\nforeach my $entry (keys %deprecated_apis) {\n\t$deprecated_apis_search .= '|' if ($deprecated_apis_search ne \"\");\n\t$deprecated_apis_search .= $entry;\n}\n$deprecated_apis_search = \"(?:${deprecated_apis_search})\";\n\nour $mode_perms_world_writable = qr{\n\tS_IWUGO\t\t|\n\tS_IWOTH\t\t|\n\tS_IRWXUGO\t|\n\tS_IALLUGO\t|\n\t0[0-7][0-7][2367]\n}x;\n\nour %mode_permission_string_types = (\n\t\"S_IRWXU\" => 0700,\n\t\"S_IRUSR\" => 0400,\n\t\"S_IWUSR\" => 0200,\n\t\"S_IXUSR\" => 0100,\n\t\"S_IRWXG\" => 0070,\n\t\"S_IRGRP\" => 0040,\n\t\"S_IWGRP\" => 0020,\n\t\"S_IXGRP\" => 0010,\n\t\"S_IRWXO\" => 0007,\n\t\"S_IROTH\" => 0004,\n\t\"S_IWOTH\" => 0002,\n\t\"S_IXOTH\" => 0001,\n\t\"S_IRWXUGO\" => 0777,\n\t\"S_IRUGO\" => 0444,\n\t\"S_IWUGO\" => 0222,\n\t\"S_IXUGO\" => 0111,\n);\n\n#Create a search pattern for all these strings to speed up a loop below\nour $mode_perms_string_search = \"\";\nforeach my $entry (keys %mode_permission_string_types) {\n\t$mode_perms_string_search .= '|' if ($mode_perms_string_search ne \"\");\n\t$mode_perms_string_search .= $entry;\n}\nour $single_mode_perms_string_search = \"(?:${mode_perms_string_search})\";\nour $multi_mode_perms_string_search = qr{\n\t${single_mode_perms_string_search}\n\t(?:\\s*\\|\\s*${single_mode_perms_string_search})*\n}x;\n\nsub perms_to_octal {\n\tmy ($string) = @_;\n\n\treturn trim($string) if ($string =~ /^\\s*0[0-7]{3,3}\\s*$/);\n\n\tmy $val = \"\";\n\tmy $oval = \"\";\n\tmy $to = 0;\n\tmy $curpos = 0;\n\tmy $lastpos = 0;\n\twhile ($string =~ /\\b(($single_mode_perms_string_search)\\b(?:\\s*\\|\\s*)?\\s*)/g) {\n\t\t$curpos = pos($string);\n\t\tmy $match = $2;\n\t\tmy $omatch = $1;\n\t\tlast if ($lastpos > 0 && ($curpos - length($omatch) != $lastpos));\n\t\t$lastpos = $curpos;\n\t\t$to |= $mode_permission_string_types{$match};\n\t\t$val .= '\\s*\\|\\s*' if ($val ne \"\");\n\t\t$val .= $match;\n\t\t$oval .= $omatch;\n\t}\n\t$oval =~ s/^\\s*\\|\\s*//;\n\t$oval =~ s/\\s*\\|\\s*$//;\n\treturn sprintf(\"%04o\", $to);\n}\n\nour $allowed_asm_includes = qr{(?x:\n\tirq|\n\tmemory|\n\ttime|\n\treboot\n)};\n# memory.h: ARM has a custom one\n\n# Load common spelling mistakes and build regular expression list.\nmy $misspellings;\nmy %spelling_fix;\n\nif (open(my $spelling, '<', $spelling_file)) {\n\twhile (<$spelling>) {\n\t\tmy $line = $_;\n\n\t\t$line =~ s/\\s*\\n?$//g;\n\t\t$line =~ s/^\\s*//g;\n\n\t\tnext if ($line =~ m/^\\s*#/);\n\t\tnext if ($line =~ m/^\\s*$/);\n\n\t\tmy ($suspect, $fix) = split(/\\|\\|/, $line);\n\n\t\t$spelling_fix{$suspect} = $fix;\n\t}\n\tclose($spelling);\n} else {\n\twarn \"No typos will be found - file '$spelling_file': $!\\n\";\n}\n\nif ($codespell) {\n\tif (open(my $spelling, '<', $codespellfile)) {\n\t\twhile (<$spelling>) {\n\t\t\tmy $line = $_;\n\n\t\t\t$line =~ s/\\s*\\n?$//g;\n\t\t\t$line =~ s/^\\s*//g;\n\n\t\t\tnext if ($line =~ m/^\\s*#/);\n\t\t\tnext if ($line =~ m/^\\s*$/);\n\t\t\tnext if ($line =~ m/, disabled/i);\n\n\t\t\t$line =~ s/,.*$//;\n\n\t\t\tmy ($suspect, $fix) = split(/->/, $line);\n\n\t\t\t$spelling_fix{$suspect} = $fix;\n\t\t}\n\t\tclose($spelling);\n\t} else {\n\t\twarn \"No codespell typos will be found - file '$codespellfile': $!\\n\";\n\t}\n}\n\n$misspellings = join(\"|\", sort keys %spelling_fix) if keys %spelling_fix;\n\nsub read_words {\n\tmy ($wordsRef, $file) = @_;\n\n\tif (open(my $words, '<', $file)) {\n\t\twhile (<$words>) {\n\t\t\tmy $line = $_;\n\n\t\t\t$line =~ s/\\s*\\n?$//g;\n\t\t\t$line =~ s/^\\s*//g;\n\n\t\t\tnext if ($line =~ m/^\\s*#/);\n\t\t\tnext if ($line =~ m/^\\s*$/);\n\t\t\tif ($line =~ /\\s/) {\n\t\t\t\tprint(\"$file: '$line' invalid - ignored\\n\");\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\t$$wordsRef .= '|' if (defined $$wordsRef);\n\t\t\t$$wordsRef .= $line;\n\t\t}\n\t\tclose($file);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nmy $const_structs;\nif (show_type(\"CONST_STRUCT\")) {\n\tread_words(\\$const_structs, $conststructsfile)\n\t    or warn \"No structs that should be const will be found - file '$conststructsfile': $!\\n\";\n}\n\nif (defined($typedefsfile)) {\n\tmy $typeOtherTypedefs;\n\tread_words(\\$typeOtherTypedefs, $typedefsfile)\n\t    or warn \"No additional types will be considered - file '$typedefsfile': $!\\n\";\n\t$typeTypedefs .= '|' . $typeOtherTypedefs if (defined $typeOtherTypedefs);\n}\n\nsub build_types {\n\tmy $mods = \"(?x:  \\n\" . join(\"|\\n  \", (@modifierList, @modifierListFile)) . \"\\n)\";\n\tmy $all = \"(?x:  \\n\" . join(\"|\\n  \", (@typeList, @typeListFile)) . \"\\n)\";\n\tmy $Misordered = \"(?x:  \\n\" . join(\"|\\n  \", @typeListMisordered) . \"\\n)\";\n\tmy $allWithAttr = \"(?x:  \\n\" . join(\"|\\n  \", @typeListWithAttr) . \"\\n)\";\n\t$Modifier\t= qr{(?:$Attribute|$Sparse|$mods)};\n\t$BasicType\t= qr{\n\t\t\t\t(?:$typeTypedefs\\b)|\n\t\t\t\t(?:${all}\\b)\n\t\t}x;\n\t$NonptrType\t= qr{\n\t\t\t(?:$Modifier\\s+|const\\s+)*\n\t\t\t(?:\n\t\t\t\t(?:typeof|__typeof__)\\s*\\([^\\)]*\\)|\n\t\t\t\t(?:$typeTypedefs\\b)|\n\t\t\t\t(?:${all}\\b)\n\t\t\t)\n\t\t\t(?:\\s+$Modifier|\\s+const)*\n\t\t  }x;\n\t$NonptrTypeMisordered\t= qr{\n\t\t\t(?:$Modifier\\s+|const\\s+)*\n\t\t\t(?:\n\t\t\t\t(?:${Misordered}\\b)\n\t\t\t)\n\t\t\t(?:\\s+$Modifier|\\s+const)*\n\t\t  }x;\n\t$NonptrTypeWithAttr\t= qr{\n\t\t\t(?:$Modifier\\s+|const\\s+)*\n\t\t\t(?:\n\t\t\t\t(?:typeof|__typeof__)\\s*\\([^\\)]*\\)|\n\t\t\t\t(?:$typeTypedefs\\b)|\n\t\t\t\t(?:${allWithAttr}\\b)\n\t\t\t)\n\t\t\t(?:\\s+$Modifier|\\s+const)*\n\t\t  }x;\n\t$Type\t= qr{\n\t\t\t$NonptrType\n\t\t\t(?:(?:\\s|\\*|\\[\\])+\\s*const|(?:\\s|\\*\\s*(?:const\\s*)?|\\[\\])+|(?:\\s*\\[\\s*\\])+){0,4}\n\t\t\t(?:\\s+$Inline|\\s+$Modifier)*\n\t\t  }x;\n\t$TypeMisordered\t= qr{\n\t\t\t$NonptrTypeMisordered\n\t\t\t(?:(?:\\s|\\*|\\[\\])+\\s*const|(?:\\s|\\*\\s*(?:const\\s*)?|\\[\\])+|(?:\\s*\\[\\s*\\])+){0,4}\n\t\t\t(?:\\s+$Inline|\\s+$Modifier)*\n\t\t  }x;\n\t$Declare\t= qr{(?:$Storage\\s+(?:$Inline\\s+)?)?$Type};\n\t$DeclareMisordered\t= qr{(?:$Storage\\s+(?:$Inline\\s+)?)?$TypeMisordered};\n}\nbuild_types();\n\nour $Typecast\t= qr{\\s*(\\(\\s*$NonptrType\\s*\\)){0,1}\\s*};\n\n# Using $balanced_parens, $LvalOrFunc, or $FuncArg\n# requires at least perl version v5.10.0\n# Any use must be runtime checked with $^V\n\nour $balanced_parens = qr/(\\((?:[^\\(\\)]++|(?-1))*\\))/;\nour $LvalOrFunc\t= qr{((?:[\\&\\*]\\s*)?$Lval)\\s*($balanced_parens{0,1})\\s*};\nour $FuncArg = qr{$Typecast{0,1}($LvalOrFunc|$Constant|$String)};\n\nour $declaration_macros = qr{(?x:\n\t(?:$Storage\\s+)?(?:[A-Z_][A-Z0-9]*_){0,2}(?:DEFINE|DECLARE)(?:_[A-Z0-9]+){1,6}\\s*\\(|\n\t(?:$Storage\\s+)?[HLP]?LIST_HEAD\\s*\\(|\n\t(?:SKCIPHER_REQUEST|SHASH_DESC|AHASH_REQUEST)_ON_STACK\\s*\\(|\n\t(?:$Storage\\s+)?(?:XA_STATE|XA_STATE_ORDER)\\s*\\(\n)};\n\nour %allow_repeated_words = (\n\tadd => '',\n\tadded => '',\n\tbad => '',\n\tbe => '',\n);\n\nsub deparenthesize {\n\tmy ($string) = @_;\n\treturn \"\" if (!defined($string));\n\n\twhile ($string =~ /^\\s*\\(.*\\)\\s*$/) {\n\t\t$string =~ s@^\\s*\\(\\s*@@;\n\t\t$string =~ s@\\s*\\)\\s*$@@;\n\t}\n\n\t$string =~ s@\\s+@ @g;\n\n\treturn $string;\n}\n\nsub seed_camelcase_file {\n\tmy ($file) = @_;\n\n\treturn if (!(-f $file));\n\n\tlocal $/;\n\n\topen(my $include_file, '<', \"$file\")\n\t    or warn \"$P: Can't read '$file' $!\\n\";\n\tmy $text = <$include_file>;\n\tclose($include_file);\n\n\tmy @lines = split('\\n', $text);\n\n\tforeach my $line (@lines) {\n\t\tnext if ($line !~ /(?:[A-Z][a-z]|[a-z][A-Z])/);\n\t\tif ($line =~ /^[ \\t]*(?:#[ \\t]*define|typedef\\s+$Type)\\s+(\\w*(?:[A-Z][a-z]|[a-z][A-Z])\\w*)/) {\n\t\t\t$camelcase{$1} = 1;\n\t\t} elsif ($line =~ /^\\s*$Declare\\s+(\\w*(?:[A-Z][a-z]|[a-z][A-Z])\\w*)\\s*[\\(\\[,;]/) {\n\t\t\t$camelcase{$1} = 1;\n\t\t} elsif ($line =~ /^\\s*(?:union|struct|enum)\\s+(\\w*(?:[A-Z][a-z]|[a-z][A-Z])\\w*)\\s*[;\\{]/) {\n\t\t\t$camelcase{$1} = 1;\n\t\t}\n\t}\n}\n\nour %maintained_status = ();\n\nsub is_maintained_obsolete {\n\tmy ($filename) = @_;\n\n\treturn 0 if (!$tree || !(-e \"$root/scripts/get_maintainer.pl\"));\n\n\tif (!exists($maintained_status{$filename})) {\n\t\t$maintained_status{$filename} = `perl $root/scripts/get_maintainer.pl --status --nom --nol --nogit --nogit-fallback -f $filename 2>&1`;\n\t}\n\n\treturn $maintained_status{$filename} =~ /obsolete/i;\n}\n\nsub is_SPDX_License_valid {\n\tmy ($license) = @_;\n\n\treturn 1 if (!$tree || which(\"python3\") eq \"\" || !(-x \"$root/scripts/spdxcheck.py\") || !(-e \"$gitroot\"));\n\n\tmy $root_path = abs_path($root);\n\tmy $status = `cd \"$root_path\"; echo \"$license\" | scripts/spdxcheck.py -`;\n\treturn 0 if ($status ne \"\");\n\treturn 1;\n}\n\nmy $camelcase_seeded = 0;\nsub seed_camelcase_includes {\n\treturn if ($camelcase_seeded);\n\n\tmy $files;\n\tmy $camelcase_cache = \"\";\n\tmy @include_files = ();\n\n\t$camelcase_seeded = 1;\n\n\tif (-e \"$gitroot\") {\n\t\tmy $git_last_include_commit = `${git_command} log --no-merges --pretty=format:\"%h%n\" -1 -- include`;\n\t\tchomp $git_last_include_commit;\n\t\t$camelcase_cache = \".checkpatch-camelcase.git.$git_last_include_commit\";\n\t} else {\n\t\tmy $last_mod_date = 0;\n\t\t$files = `find $root/include -name \"*.h\"`;\n\t\t@include_files = split('\\n', $files);\n\t\tforeach my $file (@include_files) {\n\t\t\tmy $date = POSIX::strftime(\"%Y%m%d%H%M\",\n\t\t\t\t\t\t   localtime((stat $file)[9]));\n\t\t\t$last_mod_date = $date if ($last_mod_date < $date);\n\t\t}\n\t\t$camelcase_cache = \".checkpatch-camelcase.date.$last_mod_date\";\n\t}\n\n\tif ($camelcase_cache ne \"\" && -f $camelcase_cache) {\n\t\topen(my $camelcase_file, '<', \"$camelcase_cache\")\n\t\t    or warn \"$P: Can't read '$camelcase_cache' $!\\n\";\n\t\twhile (<$camelcase_file>) {\n\t\t\tchomp;\n\t\t\t$camelcase{$_} = 1;\n\t\t}\n\t\tclose($camelcase_file);\n\n\t\treturn;\n\t}\n\n\tif (-e \"$gitroot\") {\n\t\t$files = `${git_command} ls-files \"include/*.h\"`;\n\t\t@include_files = split('\\n', $files);\n\t}\n\n\tforeach my $file (@include_files) {\n\t\tseed_camelcase_file($file);\n\t}\n\n\tif ($camelcase_cache ne \"\") {\n\t\tunlink glob \".checkpatch-camelcase.*\";\n\t\topen(my $camelcase_file, '>', \"$camelcase_cache\")\n\t\t    or warn \"$P: Can't write '$camelcase_cache' $!\\n\";\n\t\tforeach (sort { lc($a) cmp lc($b) } keys(%camelcase)) {\n\t\t\tprint $camelcase_file (\"$_\\n\");\n\t\t}\n\t\tclose($camelcase_file);\n\t}\n}\n\nsub git_is_single_file {\n\tmy ($filename) = @_;\n\n\treturn 0 if ((which(\"git\") eq \"\") || !(-e \"$gitroot\"));\n\n\tmy $output = `${git_command} ls-files -- $filename 2>/dev/null`;\n\tmy $count = $output =~ tr/\\n//;\n\treturn $count eq 1 && $output =~ m{^${filename}$};\n}\n\nsub git_commit_info {\n\tmy ($commit, $id, $desc) = @_;\n\n\treturn ($id, $desc) if ((which(\"git\") eq \"\") || !(-e \"$gitroot\"));\n\n\tmy $output = `${git_command} log --no-color --format='%H %s' -1 $commit 2>&1`;\n\t$output =~ s/^\\s*//gm;\n\tmy @lines = split(\"\\n\", $output);\n\n\treturn ($id, $desc) if ($#lines < 0);\n\n\tif ($lines[0] =~ /^error: short SHA1 $commit is ambiguous/) {\n# Maybe one day convert this block of bash into something that returns\n# all matching commit ids, but it's very slow...\n#\n#\t\techo \"checking commits $1...\"\n#\t\tgit rev-list --remotes | grep -i \"^$1\" |\n#\t\twhile read line ; do\n#\t\t    git log --format='%H %s' -1 $line |\n#\t\t    echo \"commit $(cut -c 1-12,41-)\"\n#\t\tdone\n\t} elsif ($lines[0] =~ /^fatal: ambiguous argument '$commit': unknown revision or path not in the working tree\\./ ||\n\t\t $lines[0] =~ /^fatal: bad object $commit/) {\n\t\t$id = undef;\n\t} else {\n\t\t$id = substr($lines[0], 0, 12);\n\t\t$desc = substr($lines[0], 41);\n\t}\n\n\treturn ($id, $desc);\n}\n\n$chk_signoff = 0 if ($file);\n$chk_fixes_tag = 0 if ($file);\n\nmy @rawlines = ();\nmy @lines = ();\nmy @fixed = ();\nmy @fixed_inserted = ();\nmy @fixed_deleted = ();\nmy $fixlinenr = -1;\n\n# If input is git commits, extract all commits from the commit expressions.\n# For example, HEAD-3 means we need check 'HEAD, HEAD~1, HEAD~2'.\ndie \"$P: No git repository found\\n\" if ($git && !-e \"$gitroot\");\n\nif ($git) {\n\tmy @commits = ();\n\tforeach my $commit_expr (@ARGV) {\n\t\tmy $git_range;\n\t\tif ($commit_expr =~ m/^(.*)-(\\d+)$/) {\n\t\t\t$git_range = \"-$2 $1\";\n\t\t} elsif ($commit_expr =~ m/\\.\\./) {\n\t\t\t$git_range = \"$commit_expr\";\n\t\t} else {\n\t\t\t$git_range = \"-1 $commit_expr\";\n\t\t}\n\t\tmy $lines = `${git_command} log --no-color --no-merges --pretty=format:'%H %s' $git_range`;\n\t\tforeach my $line (split(/\\n/, $lines)) {\n\t\t\t$line =~ /^([0-9a-fA-F]{40,40}) (.*)$/;\n\t\t\tnext if (!defined($1) || !defined($2));\n\t\t\tmy $sha1 = $1;\n\t\t\tmy $subject = $2;\n\t\t\tunshift(@commits, $sha1);\n\t\t\t$git_commits{$sha1} = $subject;\n\t\t}\n\t}\n\tdie \"$P: no git commits after extraction!\\n\" if (@commits == 0);\n\t@ARGV = @commits;\n}\n\nmy $vname;\n$allow_c99_comments = !defined $ignore_type{\"C99_COMMENT_TOLERANCE\"};\nfor my $filename (@ARGV) {\n\tmy $FILE;\n\tmy $is_git_file = git_is_single_file($filename);\n\tmy $oldfile = $file;\n\t$file = 1 if ($is_git_file);\n\tif ($git) {\n\t\topen($FILE, '-|', \"git format-patch -M --stdout -1 $filename\") ||\n\t\t\tdie \"$P: $filename: git format-patch failed - $!\\n\";\n\t} elsif ($file) {\n\t\topen($FILE, '-|', \"diff -u /dev/null $filename\") ||\n\t\t\tdie \"$P: $filename: diff failed - $!\\n\";\n\t} elsif ($filename eq '-') {\n\t\topen($FILE, '<&STDIN');\n\t} else {\n\t\topen($FILE, '<', \"$filename\") ||\n\t\t\tdie \"$P: $filename: open failed - $!\\n\";\n\t}\n\tif ($filename eq '-') {\n\t\t$vname = 'Your patch';\n\t} elsif ($git) {\n\t\t$vname = \"Commit \" . substr($filename, 0, 12) . ' (\"' . $git_commits{$filename} . '\")';\n\t} else {\n\t\t$vname = $filename;\n\t}\n\twhile (<$FILE>) {\n\t\tchomp;\n\t\tpush(@rawlines, $_);\n\t\t$vname = qq(\"$1\") if ($filename eq '-' && $_ =~ m/^Subject:\\s+(.+)/i);\n\t}\n\tclose($FILE);\n\n\tif ($#ARGV > 0 && $quiet == 0) {\n\t\tprint '-' x length($vname) . \"\\n\";\n\t\tprint \"$vname\\n\";\n\t\tprint '-' x length($vname) . \"\\n\";\n\t}\n\n\tif (!process($filename)) {\n\t\t$exit = 1;\n\t}\n\t@rawlines = ();\n\t@lines = ();\n\t@fixed = ();\n\t@fixed_inserted = ();\n\t@fixed_deleted = ();\n\t$fixlinenr = -1;\n\t@modifierListFile = ();\n\t@typeListFile = ();\n\tbuild_types();\n\t$file = $oldfile if ($is_git_file);\n}\n\nif (!$quiet) {\n\thash_show_words(\\%use_type, \"Used\");\n\thash_show_words(\\%ignore_type, \"Ignored\");\n\n\tif (!$perl_version_ok) {\n\t\tprint << \"EOM\"\n\nNOTE: perl $^V is not modern enough to detect all possible issues.\n      An upgrade to at least perl $minimum_perl_version is suggested.\nEOM\n\t}\n\tif ($exit) {\n\t\tprint << \"EOM\"\n\nNOTE: If any of the errors are false positives, please report\n      them to the maintainer, see CHECKPATCH in MAINTAINERS.\nEOM\n\t}\n}\n\nexit($exit);\n\nsub top_of_kernel_tree {\n\tmy ($root) = @_;\n\n\tmy @tree_check = (\n\t\t\"COPYING\", \"CREDITS\", \"Kbuild\", \"MAINTAINERS\", \"Makefile\",\n\t\t\"README\", \"Documentation\", \"arch\", \"include\", \"drivers\",\n\t\t\"fs\", \"init\", \"ipc\", \"kernel\", \"lib\", \"scripts\",\n\t);\n\n\tforeach my $check (@tree_check) {\n\t\tif (! -e $root . '/' . $check) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nsub parse_email {\n\tmy ($formatted_email) = @_;\n\n\tmy $name = \"\";\n\tmy $quoted = \"\";\n\tmy $name_comment = \"\";\n\tmy $address = \"\";\n\tmy $comment = \"\";\n\n\tif ($formatted_email =~ /^(.*)<(\\S+\\@\\S+)>(.*)$/) {\n\t\t$name = $1;\n\t\t$address = $2;\n\t\t$comment = $3 if defined $3;\n\t} elsif ($formatted_email =~ /^\\s*<(\\S+\\@\\S+)>(.*)$/) {\n\t\t$address = $1;\n\t\t$comment = $2 if defined $2;\n\t} elsif ($formatted_email =~ /(\\S+\\@\\S+)(.*)$/) {\n\t\t$address = $1;\n\t\t$comment = $2 if defined $2;\n\t\t$formatted_email =~ s/\\Q$address\\E.*$//;\n\t\t$name = $formatted_email;\n\t\t$name = trim($name);\n\t\t$name =~ s/^\\\"|\\\"$//g;\n\t\t# If there's a name left after stripping spaces and\n\t\t# leading quotes, and the address doesn't have both\n\t\t# leading and trailing angle brackets, the address\n\t\t# is invalid. ie:\n\t\t#   \"joe smith joe@smith.com\" bad\n\t\t#   \"joe smith <joe@smith.com\" bad\n\t\tif ($name ne \"\" && $address !~ /^<[^>]+>$/) {\n\t\t\t$name = \"\";\n\t\t\t$address = \"\";\n\t\t\t$comment = \"\";\n\t\t}\n\t}\n\n\t# Extract comments from names excluding quoted parts\n\t# \"John D. (Doe)\" - Do not extract\n\tif ($name =~ s/\\\"(.+)\\\"//) {\n\t\t$quoted = $1;\n\t}\n\twhile ($name =~ s/\\s*($balanced_parens)\\s*/ /) {\n\t\t$name_comment .= trim($1);\n\t}\n\t$name =~ s/^[ \\\"]+|[ \\\"]+$//g;\n\t$name = trim(\"$quoted $name\");\n\n\t$address = trim($address);\n\t$address =~ s/^\\<|\\>$//g;\n\t$comment = trim($comment);\n\n\tif ($name =~ /[^\\w \\-]/i) { ##has \"must quote\" chars\n\t\t$name =~ s/(?<!\\\\)\"/\\\\\"/g; ##escape quotes\n\t\t$name = \"\\\"$name\\\"\";\n\t}\n\n\treturn ($name, $name_comment, $address, $comment);\n}\n\nsub format_email {\n\tmy ($name, $name_comment, $address, $comment) = @_;\n\n\tmy $formatted_email;\n\n\t$name =~ s/^[ \\\"]+|[ \\\"]+$//g;\n\t$address = trim($address);\n\t$address =~ s/(?:\\.|\\,|\\\")+$//; ##trailing commas, dots or quotes\n\n\tif ($name =~ /[^\\w \\-]/i) { ##has \"must quote\" chars\n\t\t$name =~ s/(?<!\\\\)\"/\\\\\"/g; ##escape quotes\n\t\t$name = \"\\\"$name\\\"\";\n\t}\n\n\t$name_comment = trim($name_comment);\n\t$name_comment = \" $name_comment\" if ($name_comment ne \"\");\n\t$comment = trim($comment);\n\t$comment = \" $comment\" if ($comment ne \"\");\n\n\tif (\"$name\" eq \"\") {\n\t\t$formatted_email = \"$address\";\n\t} else {\n\t\t$formatted_email = \"$name$name_comment <$address>\";\n\t}\n\t$formatted_email .= \"$comment\";\n\treturn $formatted_email;\n}\n\nsub reformat_email {\n\tmy ($email) = @_;\n\n\tmy ($email_name, $name_comment, $email_address, $comment) = parse_email($email);\n\treturn format_email($email_name, $name_comment, $email_address, $comment);\n}\n\nsub same_email_addresses {\n\tmy ($email1, $email2) = @_;\n\n\tmy ($email1_name, $name1_comment, $email1_address, $comment1) = parse_email($email1);\n\tmy ($email2_name, $name2_comment, $email2_address, $comment2) = parse_email($email2);\n\n\treturn $email1_name eq $email2_name &&\n\t       $email1_address eq $email2_address &&\n\t       $name1_comment eq $name2_comment &&\n\t       $comment1 eq $comment2;\n}\n\nsub which {\n\tmy ($bin) = @_;\n\n\tforeach my $path (split(/:/, $ENV{PATH})) {\n\t\tif (-e \"$path/$bin\") {\n\t\t\treturn \"$path/$bin\";\n\t\t}\n\t}\n\n\treturn \"\";\n}\n\nsub which_conf {\n\tmy ($conf) = @_;\n\n\tforeach my $path (split(/:/, \".:$ENV{HOME}:.scripts\")) {\n\t\tif (-e \"$path/$conf\") {\n\t\t\treturn \"$path/$conf\";\n\t\t}\n\t}\n\n\treturn \"\";\n}\n\nsub expand_tabs {\n\tmy ($str) = @_;\n\n\tmy $res = '';\n\tmy $n = 0;\n\tfor my $c (split(//, $str)) {\n\t\tif ($c eq \"\\t\") {\n\t\t\t$res .= ' ';\n\t\t\t$n++;\n\t\t\tfor (; ($n % $tabsize) != 0; $n++) {\n\t\t\t\t$res .= ' ';\n\t\t\t}\n\t\t\tnext;\n\t\t}\n\t\t$res .= $c;\n\t\t$n++;\n\t}\n\n\treturn $res;\n}\nsub copy_spacing {\n\t(my $res = shift) =~ tr/\\t/ /c;\n\treturn $res;\n}\n\nsub line_stats {\n\tmy ($line) = @_;\n\n\t# Drop the diff line leader and expand tabs\n\t$line =~ s/^.//;\n\t$line = expand_tabs($line);\n\n\t# Pick the indent from the front of the line.\n\tmy ($white) = ($line =~ /^(\\s*)/);\n\n\treturn (length($line), length($white));\n}\n\nmy $sanitise_quote = '';\n\nsub sanitise_line_reset {\n\tmy ($in_comment) = @_;\n\n\tif ($in_comment) {\n\t\t$sanitise_quote = '*/';\n\t} else {\n\t\t$sanitise_quote = '';\n\t}\n}\nsub sanitise_line {\n\tmy ($line) = @_;\n\n\tmy $res = '';\n\tmy $l = '';\n\n\tmy $qlen = 0;\n\tmy $off = 0;\n\tmy $c;\n\n\t# Always copy over the diff marker.\n\t$res = substr($line, 0, 1);\n\n\tfor ($off = 1; $off < length($line); $off++) {\n\t\t$c = substr($line, $off, 1);\n\n\t\t# Comments we are whacking completely including the begin\n\t\t# and end, all to $;.\n\t\tif ($sanitise_quote eq '' && substr($line, $off, 2) eq '/*') {\n\t\t\t$sanitise_quote = '*/';\n\n\t\t\tsubstr($res, $off, 2, \"$;$;\");\n\t\t\t$off++;\n\t\t\tnext;\n\t\t}\n\t\tif ($sanitise_quote eq '*/' && substr($line, $off, 2) eq '*/') {\n\t\t\t$sanitise_quote = '';\n\t\t\tsubstr($res, $off, 2, \"$;$;\");\n\t\t\t$off++;\n\t\t\tnext;\n\t\t}\n\t\tif ($sanitise_quote eq '' && substr($line, $off, 2) eq '//') {\n\t\t\t$sanitise_quote = '//';\n\n\t\t\tsubstr($res, $off, 2, $sanitise_quote);\n\t\t\t$off++;\n\t\t\tnext;\n\t\t}\n\n\t\t# A \\ in a string means ignore the next character.\n\t\tif (($sanitise_quote eq \"'\" || $sanitise_quote eq '\"') &&\n\t\t    $c eq \"\\\\\") {\n\t\t\tsubstr($res, $off, 2, 'XX');\n\t\t\t$off++;\n\t\t\tnext;\n\t\t}\n\t\t# Regular quotes.\n\t\tif ($c eq \"'\" || $c eq '\"') {\n\t\t\tif ($sanitise_quote eq '') {\n\t\t\t\t$sanitise_quote = $c;\n\n\t\t\t\tsubstr($res, $off, 1, $c);\n\t\t\t\tnext;\n\t\t\t} elsif ($sanitise_quote eq $c) {\n\t\t\t\t$sanitise_quote = '';\n\t\t\t}\n\t\t}\n\n\t\t#print \"c<$c> SQ<$sanitise_quote>\\n\";\n\t\tif ($off != 0 && $sanitise_quote eq '*/' && $c ne \"\\t\") {\n\t\t\tsubstr($res, $off, 1, $;);\n\t\t} elsif ($off != 0 && $sanitise_quote eq '//' && $c ne \"\\t\") {\n\t\t\tsubstr($res, $off, 1, $;);\n\t\t} elsif ($off != 0 && $sanitise_quote && $c ne \"\\t\") {\n\t\t\tsubstr($res, $off, 1, 'X');\n\t\t} else {\n\t\t\tsubstr($res, $off, 1, $c);\n\t\t}\n\t}\n\n\tif ($sanitise_quote eq '//') {\n\t\t$sanitise_quote = '';\n\t}\n\n\t# The pathname on a #include may be surrounded by '<' and '>'.\n\tif ($res =~ /^.\\s*\\#\\s*include\\s+\\<(.*)\\>/) {\n\t\tmy $clean = 'X' x length($1);\n\t\t$res =~ s@\\<.*\\>@<$clean>@;\n\n\t# The whole of a #error is a string.\n\t} elsif ($res =~ /^.\\s*\\#\\s*(?:error|warning)\\s+(.*)\\b/) {\n\t\tmy $clean = 'X' x length($1);\n\t\t$res =~ s@(\\#\\s*(?:error|warning)\\s+).*@$1$clean@;\n\t}\n\n\tif ($allow_c99_comments && $res =~ m@(//.*$)@) {\n\t\tmy $match = $1;\n\t\t$res =~ s/\\Q$match\\E/\"$;\" x length($match)/e;\n\t}\n\n\treturn $res;\n}\n\nsub get_quoted_string {\n\tmy ($line, $rawline) = @_;\n\n\treturn \"\" if (!defined($line) || !defined($rawline));\n\treturn \"\" if ($line !~ m/($String)/g);\n\treturn substr($rawline, $-[0], $+[0] - $-[0]);\n}\n\nsub ctx_statement_block {\n\tmy ($linenr, $remain, $off) = @_;\n\tmy $line = $linenr - 1;\n\tmy $blk = '';\n\tmy $soff = $off;\n\tmy $coff = $off - 1;\n\tmy $coff_set = 0;\n\n\tmy $loff = 0;\n\n\tmy $type = '';\n\tmy $level = 0;\n\tmy @stack = ();\n\tmy $p;\n\tmy $c;\n\tmy $len = 0;\n\n\tmy $remainder;\n\twhile (1) {\n\t\t@stack = (['', 0]) if ($#stack == -1);\n\n\t\t#warn \"CSB: blk<$blk> remain<$remain>\\n\";\n\t\t# If we are about to drop off the end, pull in more\n\t\t# context.\n\t\tif ($off >= $len) {\n\t\t\tfor (; $remain > 0; $line++) {\n\t\t\t\tlast if (!defined $lines[$line]);\n\t\t\t\tnext if ($lines[$line] =~ /^-/);\n\t\t\t\t$remain--;\n\t\t\t\t$loff = $len;\n\t\t\t\t$blk .= $lines[$line] . \"\\n\";\n\t\t\t\t$len = length($blk);\n\t\t\t\t$line++;\n\t\t\t\tlast;\n\t\t\t}\n\t\t\t# Bail if there is no further context.\n\t\t\t#warn \"CSB: blk<$blk> off<$off> len<$len>\\n\";\n\t\t\tif ($off >= $len) {\n\t\t\t\tlast;\n\t\t\t}\n\t\t\tif ($level == 0 && substr($blk, $off) =~ /^.\\s*#\\s*define/) {\n\t\t\t\t$level++;\n\t\t\t\t$type = '#';\n\t\t\t}\n\t\t}\n\t\t$p = $c;\n\t\t$c = substr($blk, $off, 1);\n\t\t$remainder = substr($blk, $off);\n\n\t\t#warn \"CSB: c<$c> type<$type> level<$level> remainder<$remainder> coff_set<$coff_set>\\n\";\n\n\t\t# Handle nested #if/#else.\n\t\tif ($remainder =~ /^#\\s*(?:ifndef|ifdef|if)\\s/) {\n\t\t\tpush(@stack, [ $type, $level ]);\n\t\t} elsif ($remainder =~ /^#\\s*(?:else|elif)\\b/) {\n\t\t\t($type, $level) = @{$stack[$#stack - 1]};\n\t\t} elsif ($remainder =~ /^#\\s*endif\\b/) {\n\t\t\t($type, $level) = @{pop(@stack)};\n\t\t}\n\n\t\t# Statement ends at the ';' or a close '}' at the\n\t\t# outermost level.\n\t\tif ($level == 0 && $c eq ';') {\n\t\t\tlast;\n\t\t}\n\n\t\t# An else is really a conditional as long as its not else if\n\t\tif ($level == 0 && $coff_set == 0 &&\n\t\t\t\t(!defined($p) || $p =~ /(?:\\s|\\}|\\+)/) &&\n\t\t\t\t$remainder =~ /^(else)(?:\\s|{)/ &&\n\t\t\t\t$remainder !~ /^else\\s+if\\b/) {\n\t\t\t$coff = $off + length($1) - 1;\n\t\t\t$coff_set = 1;\n\t\t\t#warn \"CSB: mark coff<$coff> soff<$soff> 1<$1>\\n\";\n\t\t\t#warn \"[\" . substr($blk, $soff, $coff - $soff + 1) . \"]\\n\";\n\t\t}\n\n\t\tif (($type eq '' || $type eq '(') && $c eq '(') {\n\t\t\t$level++;\n\t\t\t$type = '(';\n\t\t}\n\t\tif ($type eq '(' && $c eq ')') {\n\t\t\t$level--;\n\t\t\t$type = ($level != 0)? '(' : '';\n\n\t\t\tif ($level == 0 && $coff < $soff) {\n\t\t\t\t$coff = $off;\n\t\t\t\t$coff_set = 1;\n\t\t\t\t#warn \"CSB: mark coff<$coff>\\n\";\n\t\t\t}\n\t\t}\n\t\tif (($type eq '' || $type eq '{') && $c eq '{') {\n\t\t\t$level++;\n\t\t\t$type = '{';\n\t\t}\n\t\tif ($type eq '{' && $c eq '}') {\n\t\t\t$level--;\n\t\t\t$type = ($level != 0)? '{' : '';\n\n\t\t\tif ($level == 0) {\n\t\t\t\tif (substr($blk, $off + 1, 1) eq ';') {\n\t\t\t\t\t$off++;\n\t\t\t\t}\n\t\t\t\tlast;\n\t\t\t}\n\t\t}\n\t\t# Preprocessor commands end at the newline unless escaped.\n\t\tif ($type eq '#' && $c eq \"\\n\" && $p ne \"\\\\\") {\n\t\t\t$level--;\n\t\t\t$type = '';\n\t\t\t$off++;\n\t\t\tlast;\n\t\t}\n\t\t$off++;\n\t}\n\t# We are truly at the end, so shuffle to the next line.\n\tif ($off == $len) {\n\t\t$loff = $len + 1;\n\t\t$line++;\n\t\t$remain--;\n\t}\n\n\tmy $statement = substr($blk, $soff, $off - $soff + 1);\n\tmy $condition = substr($blk, $soff, $coff - $soff + 1);\n\n\t#warn \"STATEMENT<$statement>\\n\";\n\t#warn \"CONDITION<$condition>\\n\";\n\n\t#print \"coff<$coff> soff<$off> loff<$loff>\\n\";\n\n\treturn ($statement, $condition,\n\t\t\t$line, $remain + 1, $off - $loff + 1, $level);\n}\n\nsub statement_lines {\n\tmy ($stmt) = @_;\n\n\t# Strip the diff line prefixes and rip blank lines at start and end.\n\t$stmt =~ s/(^|\\n)./$1/g;\n\t$stmt =~ s/^\\s*//;\n\t$stmt =~ s/\\s*$//;\n\n\tmy @stmt_lines = ($stmt =~ /\\n/g);\n\n\treturn $#stmt_lines + 2;\n}\n\nsub statement_rawlines {\n\tmy ($stmt) = @_;\n\n\tmy @stmt_lines = ($stmt =~ /\\n/g);\n\n\treturn $#stmt_lines + 2;\n}\n\nsub statement_block_size {\n\tmy ($stmt) = @_;\n\n\t$stmt =~ s/(^|\\n)./$1/g;\n\t$stmt =~ s/^\\s*{//;\n\t$stmt =~ s/}\\s*$//;\n\t$stmt =~ s/^\\s*//;\n\t$stmt =~ s/\\s*$//;\n\n\tmy @stmt_lines = ($stmt =~ /\\n/g);\n\tmy @stmt_statements = ($stmt =~ /;/g);\n\n\tmy $stmt_lines = $#stmt_lines + 2;\n\tmy $stmt_statements = $#stmt_statements + 1;\n\n\tif ($stmt_lines > $stmt_statements) {\n\t\treturn $stmt_lines;\n\t} else {\n\t\treturn $stmt_statements;\n\t}\n}\n\nsub ctx_statement_full {\n\tmy ($linenr, $remain, $off) = @_;\n\tmy ($statement, $condition, $level);\n\n\tmy (@chunks);\n\n\t# Grab the first conditional/block pair.\n\t($statement, $condition, $linenr, $remain, $off, $level) =\n\t\t\t\tctx_statement_block($linenr, $remain, $off);\n\t#print \"F: c<$condition> s<$statement> remain<$remain>\\n\";\n\tpush(@chunks, [ $condition, $statement ]);\n\tif (!($remain > 0 && $condition =~ /^\\s*(?:\\n[+-])?\\s*(?:if|else|do)\\b/s)) {\n\t\treturn ($level, $linenr, @chunks);\n\t}\n\n\t# Pull in the following conditional/block pairs and see if they\n\t# could continue the statement.\n\tfor (;;) {\n\t\t($statement, $condition, $linenr, $remain, $off, $level) =\n\t\t\t\tctx_statement_block($linenr, $remain, $off);\n\t\t#print \"C: c<$condition> s<$statement> remain<$remain>\\n\";\n\t\tlast if (!($remain > 0 && $condition =~ /^(?:\\s*\\n[+-])*\\s*(?:else|do)\\b/s));\n\t\t#print \"C: push\\n\";\n\t\tpush(@chunks, [ $condition, $statement ]);\n\t}\n\n\treturn ($level, $linenr, @chunks);\n}\n\nsub ctx_block_get {\n\tmy ($linenr, $remain, $outer, $open, $close, $off) = @_;\n\tmy $line;\n\tmy $start = $linenr - 1;\n\tmy $blk = '';\n\tmy @o;\n\tmy @c;\n\tmy @res = ();\n\n\tmy $level = 0;\n\tmy @stack = ($level);\n\tfor ($line = $start; $remain > 0; $line++) {\n\t\tnext if ($rawlines[$line] =~ /^-/);\n\t\t$remain--;\n\n\t\t$blk .= $rawlines[$line];\n\n\t\t# Handle nested #if/#else.\n\t\tif ($lines[$line] =~ /^.\\s*#\\s*(?:ifndef|ifdef|if)\\s/) {\n\t\t\tpush(@stack, $level);\n\t\t} elsif ($lines[$line] =~ /^.\\s*#\\s*(?:else|elif)\\b/) {\n\t\t\t$level = $stack[$#stack - 1];\n\t\t} elsif ($lines[$line] =~ /^.\\s*#\\s*endif\\b/) {\n\t\t\t$level = pop(@stack);\n\t\t}\n\n\t\tforeach my $c (split(//, $lines[$line])) {\n\t\t\t##print \"C<$c>L<$level><$open$close>O<$off>\\n\";\n\t\t\tif ($off > 0) {\n\t\t\t\t$off--;\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\tif ($c eq $close && $level > 0) {\n\t\t\t\t$level--;\n\t\t\t\tlast if ($level == 0);\n\t\t\t} elsif ($c eq $open) {\n\t\t\t\t$level++;\n\t\t\t}\n\t\t}\n\n\t\tif (!$outer || $level <= 1) {\n\t\t\tpush(@res, $rawlines[$line]);\n\t\t}\n\n\t\tlast if ($level == 0);\n\t}\n\n\treturn ($level, @res);\n}\nsub ctx_block_outer {\n\tmy ($linenr, $remain) = @_;\n\n\tmy ($level, @r) = ctx_block_get($linenr, $remain, 1, '{', '}', 0);\n\treturn @r;\n}\nsub ctx_block {\n\tmy ($linenr, $remain) = @_;\n\n\tmy ($level, @r) = ctx_block_get($linenr, $remain, 0, '{', '}', 0);\n\treturn @r;\n}\nsub ctx_statement {\n\tmy ($linenr, $remain, $off) = @_;\n\n\tmy ($level, @r) = ctx_block_get($linenr, $remain, 0, '(', ')', $off);\n\treturn @r;\n}\nsub ctx_block_level {\n\tmy ($linenr, $remain) = @_;\n\n\treturn ctx_block_get($linenr, $remain, 0, '{', '}', 0);\n}\nsub ctx_statement_level {\n\tmy ($linenr, $remain, $off) = @_;\n\n\treturn ctx_block_get($linenr, $remain, 0, '(', ')', $off);\n}\n\nsub ctx_locate_comment {\n\tmy ($first_line, $end_line) = @_;\n\n\t# If c99 comment on the current line, or the line before or after\n\tmy ($current_comment) = ($rawlines[$end_line - 1] =~ m@^\\+.*(//.*$)@);\n\treturn $current_comment if (defined $current_comment);\n\t($current_comment) = ($rawlines[$end_line - 2] =~ m@^[\\+ ].*(//.*$)@);\n\treturn $current_comment if (defined $current_comment);\n\t($current_comment) = ($rawlines[$end_line] =~ m@^[\\+ ].*(//.*$)@);\n\treturn $current_comment if (defined $current_comment);\n\n\t# Catch a comment on the end of the line itself.\n\t($current_comment) = ($rawlines[$end_line - 1] =~ m@.*(/\\*.*\\*/)\\s*(?:\\\\\\s*)?$@);\n\treturn $current_comment if (defined $current_comment);\n\n\t# Look through the context and try and figure out if there is a\n\t# comment.\n\tmy $in_comment = 0;\n\t$current_comment = '';\n\tfor (my $linenr = $first_line; $linenr < $end_line; $linenr++) {\n\t\tmy $line = $rawlines[$linenr - 1];\n\t\t#warn \"           $line\\n\";\n\t\tif ($linenr == $first_line and $line =~ m@^.\\s*\\*@) {\n\t\t\t$in_comment = 1;\n\t\t}\n\t\tif ($line =~ m@/\\*@) {\n\t\t\t$in_comment = 1;\n\t\t}\n\t\tif (!$in_comment && $current_comment ne '') {\n\t\t\t$current_comment = '';\n\t\t}\n\t\t$current_comment .= $line . \"\\n\" if ($in_comment);\n\t\tif ($line =~ m@\\*/@) {\n\t\t\t$in_comment = 0;\n\t\t}\n\t}\n\n\tchomp($current_comment);\n\treturn($current_comment);\n}\nsub ctx_has_comment {\n\tmy ($first_line, $end_line) = @_;\n\tmy $cmt = ctx_locate_comment($first_line, $end_line);\n\n\t##print \"LINE: $rawlines[$end_line - 1 ]\\n\";\n\t##print \"CMMT: $cmt\\n\";\n\n\treturn ($cmt ne '');\n}\n\nsub raw_line {\n\tmy ($linenr, $cnt) = @_;\n\n\tmy $offset = $linenr - 1;\n\t$cnt++;\n\n\tmy $line;\n\twhile ($cnt) {\n\t\t$line = $rawlines[$offset++];\n\t\tnext if (defined($line) && $line =~ /^-/);\n\t\t$cnt--;\n\t}\n\n\treturn $line;\n}\n\nsub get_stat_real {\n\tmy ($linenr, $lc) = @_;\n\n\tmy $stat_real = raw_line($linenr, 0);\n\tfor (my $count = $linenr + 1; $count <= $lc; $count++) {\n\t\t$stat_real = $stat_real . \"\\n\" . raw_line($count, 0);\n\t}\n\n\treturn $stat_real;\n}\n\nsub get_stat_here {\n\tmy ($linenr, $cnt, $here) = @_;\n\n\tmy $herectx = $here . \"\\n\";\n\tfor (my $n = 0; $n < $cnt; $n++) {\n\t\t$herectx .= raw_line($linenr, $n) . \"\\n\";\n\t}\n\n\treturn $herectx;\n}\n\nsub cat_vet {\n\tmy ($vet) = @_;\n\tmy ($res, $coded);\n\n\t$res = '';\n\twhile ($vet =~ /([^[:cntrl:]]*)([[:cntrl:]]|$)/g) {\n\t\t$res .= $1;\n\t\tif ($2 ne '') {\n\t\t\t$coded = sprintf(\"^%c\", unpack('C', $2) + 64);\n\t\t\t$res .= $coded;\n\t\t}\n\t}\n\t$res =~ s/$/\\$/;\n\n\treturn $res;\n}\n\nmy $av_preprocessor = 0;\nmy $av_pending;\nmy @av_paren_type;\nmy $av_pend_colon;\n\nsub annotate_reset {\n\t$av_preprocessor = 0;\n\t$av_pending = '_';\n\t@av_paren_type = ('E');\n\t$av_pend_colon = 'O';\n}\n\nsub annotate_values {\n\tmy ($stream, $type) = @_;\n\n\tmy $res;\n\tmy $var = '_' x length($stream);\n\tmy $cur = $stream;\n\n\tprint \"$stream\\n\" if ($dbg_values > 1);\n\n\twhile (length($cur)) {\n\t\t@av_paren_type = ('E') if ($#av_paren_type < 0);\n\t\tprint \" <\" . join('', @av_paren_type) .\n\t\t\t\t\"> <$type> <$av_pending>\" if ($dbg_values > 1);\n\t\tif ($cur =~ /^(\\s+)/o) {\n\t\t\tprint \"WS($1)\\n\" if ($dbg_values > 1);\n\t\t\tif ($1 =~ /\\n/ && $av_preprocessor) {\n\t\t\t\t$type = pop(@av_paren_type);\n\t\t\t\t$av_preprocessor = 0;\n\t\t\t}\n\n\t\t} elsif ($cur =~ /^(\\(\\s*$Type\\s*)\\)/ && $av_pending eq '_') {\n\t\t\tprint \"CAST($1)\\n\" if ($dbg_values > 1);\n\t\t\tpush(@av_paren_type, $type);\n\t\t\t$type = 'c';\n\n\t\t} elsif ($cur =~ /^($Type)\\s*(?:$Ident|,|\\)|\\(|\\s*$)/) {\n\t\t\tprint \"DECLARE($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'T';\n\n\t\t} elsif ($cur =~ /^($Modifier)\\s*/) {\n\t\t\tprint \"MODIFIER($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'T';\n\n\t\t} elsif ($cur =~ /^(\\#\\s*define\\s*$Ident)(\\(?)/o) {\n\t\t\tprint \"DEFINE($1,$2)\\n\" if ($dbg_values > 1);\n\t\t\t$av_preprocessor = 1;\n\t\t\tpush(@av_paren_type, $type);\n\t\t\tif ($2 ne '') {\n\t\t\t\t$av_pending = 'N';\n\t\t\t}\n\t\t\t$type = 'E';\n\n\t\t} elsif ($cur =~ /^(\\#\\s*(?:undef\\s*$Ident|include\\b))/o) {\n\t\t\tprint \"UNDEF($1)\\n\" if ($dbg_values > 1);\n\t\t\t$av_preprocessor = 1;\n\t\t\tpush(@av_paren_type, $type);\n\n\t\t} elsif ($cur =~ /^(\\#\\s*(?:ifdef|ifndef|if))/o) {\n\t\t\tprint \"PRE_START($1)\\n\" if ($dbg_values > 1);\n\t\t\t$av_preprocessor = 1;\n\n\t\t\tpush(@av_paren_type, $type);\n\t\t\tpush(@av_paren_type, $type);\n\t\t\t$type = 'E';\n\n\t\t} elsif ($cur =~ /^(\\#\\s*(?:else|elif))/o) {\n\t\t\tprint \"PRE_RESTART($1)\\n\" if ($dbg_values > 1);\n\t\t\t$av_preprocessor = 1;\n\n\t\t\tpush(@av_paren_type, $av_paren_type[$#av_paren_type]);\n\n\t\t\t$type = 'E';\n\n\t\t} elsif ($cur =~ /^(\\#\\s*(?:endif))/o) {\n\t\t\tprint \"PRE_END($1)\\n\" if ($dbg_values > 1);\n\n\t\t\t$av_preprocessor = 1;\n\n\t\t\t# Assume all arms of the conditional end as this\n\t\t\t# one does, and continue as if the #endif was not here.\n\t\t\tpop(@av_paren_type);\n\t\t\tpush(@av_paren_type, $type);\n\t\t\t$type = 'E';\n\n\t\t} elsif ($cur =~ /^(\\\\\\n)/o) {\n\t\t\tprint \"PRECONT($1)\\n\" if ($dbg_values > 1);\n\n\t\t} elsif ($cur =~ /^(__attribute__)\\s*\\(?/o) {\n\t\t\tprint \"ATTR($1)\\n\" if ($dbg_values > 1);\n\t\t\t$av_pending = $type;\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~ /^(sizeof)\\s*(\\()?/o) {\n\t\t\tprint \"SIZEOF($1)\\n\" if ($dbg_values > 1);\n\t\t\tif (defined $2) {\n\t\t\t\t$av_pending = 'V';\n\t\t\t}\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~ /^(if|while|for)\\b/o) {\n\t\t\tprint \"COND($1)\\n\" if ($dbg_values > 1);\n\t\t\t$av_pending = 'E';\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~/^(case)/o) {\n\t\t\tprint \"CASE($1)\\n\" if ($dbg_values > 1);\n\t\t\t$av_pend_colon = 'C';\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~/^(return|else|goto|typeof|__typeof__)\\b/o) {\n\t\t\tprint \"KEYWORD($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~ /^(\\()/o) {\n\t\t\tprint \"PAREN('$1')\\n\" if ($dbg_values > 1);\n\t\t\tpush(@av_paren_type, $av_pending);\n\t\t\t$av_pending = '_';\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~ /^(\\))/o) {\n\t\t\tmy $new_type = pop(@av_paren_type);\n\t\t\tif ($new_type ne '_') {\n\t\t\t\t$type = $new_type;\n\t\t\t\tprint \"PAREN('$1') -> $type\\n\"\n\t\t\t\t\t\t\tif ($dbg_values > 1);\n\t\t\t} else {\n\t\t\t\tprint \"PAREN('$1')\\n\" if ($dbg_values > 1);\n\t\t\t}\n\n\t\t} elsif ($cur =~ /^($Ident)\\s*\\(/o) {\n\t\t\tprint \"FUNC($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'V';\n\t\t\t$av_pending = 'V';\n\n\t\t} elsif ($cur =~ /^($Ident\\s*):(?:\\s*\\d+\\s*(,|=|;))?/) {\n\t\t\tif (defined $2 && $type eq 'C' || $type eq 'T') {\n\t\t\t\t$av_pend_colon = 'B';\n\t\t\t} elsif ($type eq 'E') {\n\t\t\t\t$av_pend_colon = 'L';\n\t\t\t}\n\t\t\tprint \"IDENT_COLON($1,$type>$av_pend_colon)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'V';\n\n\t\t} elsif ($cur =~ /^($Ident|$Constant)/o) {\n\t\t\tprint \"IDENT($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'V';\n\n\t\t} elsif ($cur =~ /^($Assignment)/o) {\n\t\t\tprint \"ASSIGN($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~/^(;|{|})/) {\n\t\t\tprint \"END($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'E';\n\t\t\t$av_pend_colon = 'O';\n\n\t\t} elsif ($cur =~/^(,)/) {\n\t\t\tprint \"COMMA($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'C';\n\n\t\t} elsif ($cur =~ /^(\\?)/o) {\n\t\t\tprint \"QUESTION($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~ /^(:)/o) {\n\t\t\tprint \"COLON($1,$av_pend_colon)\\n\" if ($dbg_values > 1);\n\n\t\t\tsubstr($var, length($res), 1, $av_pend_colon);\n\t\t\tif ($av_pend_colon eq 'C' || $av_pend_colon eq 'L') {\n\t\t\t\t$type = 'E';\n\t\t\t} else {\n\t\t\t\t$type = 'N';\n\t\t\t}\n\t\t\t$av_pend_colon = 'O';\n\n\t\t} elsif ($cur =~ /^(\\[)/o) {\n\t\t\tprint \"CLOSE($1)\\n\" if ($dbg_values > 1);\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~ /^(-(?![->])|\\+(?!\\+)|\\*|\\&\\&|\\&)/o) {\n\t\t\tmy $variant;\n\n\t\t\tprint \"OPV($1)\\n\" if ($dbg_values > 1);\n\t\t\tif ($type eq 'V') {\n\t\t\t\t$variant = 'B';\n\t\t\t} else {\n\t\t\t\t$variant = 'U';\n\t\t\t}\n\n\t\t\tsubstr($var, length($res), 1, $variant);\n\t\t\t$type = 'N';\n\n\t\t} elsif ($cur =~ /^($Operators)/o) {\n\t\t\tprint \"OP($1)\\n\" if ($dbg_values > 1);\n\t\t\tif ($1 ne '++' && $1 ne '--') {\n\t\t\t\t$type = 'N';\n\t\t\t}\n\n\t\t} elsif ($cur =~ /(^.)/o) {\n\t\t\tprint \"C($1)\\n\" if ($dbg_values > 1);\n\t\t}\n\t\tif (defined $1) {\n\t\t\t$cur = substr($cur, length($1));\n\t\t\t$res .= $type x length($1);\n\t\t}\n\t}\n\n\treturn ($res, $var);\n}\n\nsub possible {\n\tmy ($possible, $line) = @_;\n\tmy $notPermitted = qr{(?:\n\t\t^(?:\n\t\t\t$Modifier|\n\t\t\t$Storage|\n\t\t\t$Type|\n\t\t\tDEFINE_\\S+\n\t\t)$|\n\t\t^(?:\n\t\t\tgoto|\n\t\t\treturn|\n\t\t\tcase|\n\t\t\telse|\n\t\t\tasm|__asm__|\n\t\t\tdo|\n\t\t\t\\#|\n\t\t\t\\#\\#|\n\t\t)(?:\\s|$)|\n\t\t^(?:typedef|struct|enum)\\b\n\t    )}x;\n\twarn \"CHECK<$possible> ($line)\\n\" if ($dbg_possible > 2);\n\tif ($possible !~ $notPermitted) {\n\t\t# Check for modifiers.\n\t\t$possible =~ s/\\s*$Storage\\s*//g;\n\t\t$possible =~ s/\\s*$Sparse\\s*//g;\n\t\tif ($possible =~ /^\\s*$/) {\n\n\t\t} elsif ($possible =~ /\\s/) {\n\t\t\t$possible =~ s/\\s*$Type\\s*//g;\n\t\t\tfor my $modifier (split(' ', $possible)) {\n\t\t\t\tif ($modifier !~ $notPermitted) {\n\t\t\t\t\twarn \"MODIFIER: $modifier ($possible) ($line)\\n\" if ($dbg_possible);\n\t\t\t\t\tpush(@modifierListFile, $modifier);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\twarn \"POSSIBLE: $possible ($line)\\n\" if ($dbg_possible);\n\t\t\tpush(@typeListFile, $possible);\n\t\t}\n\t\tbuild_types();\n\t} else {\n\t\twarn \"NOTPOSS: $possible ($line)\\n\" if ($dbg_possible > 1);\n\t}\n}\n\nmy $prefix = '';\n\nsub show_type {\n\tmy ($type) = @_;\n\n\t$type =~ tr/[a-z]/[A-Z]/;\n\n\treturn defined $use_type{$type} if (scalar keys %use_type > 0);\n\n\treturn !defined $ignore_type{$type};\n}\n\nsub report {\n\tmy ($level, $type, $msg) = @_;\n\n\tif (!show_type($type) ||\n\t    (defined $tst_only && $msg !~ /\\Q$tst_only\\E/)) {\n\t\treturn 0;\n\t}\n\tmy $output = '';\n\tif ($color) {\n\t\tif ($level eq 'ERROR') {\n\t\t\t$output .= RED;\n\t\t} elsif ($level eq 'WARNING') {\n\t\t\t$output .= YELLOW;\n\t\t} else {\n\t\t\t$output .= GREEN;\n\t\t}\n\t}\n\t$output .= $prefix . $level . ':';\n\tif ($show_types) {\n\t\t$output .= BLUE if ($color);\n\t\t$output .= \"$type:\";\n\t}\n\t$output .= RESET if ($color);\n\t$output .= ' ' . $msg . \"\\n\";\n\n\tif ($showfile) {\n\t\tmy @lines = split(\"\\n\", $output, -1);\n\t\tsplice(@lines, 1, 1);\n\t\t$output = join(\"\\n\", @lines);\n\t}\n\n\tif ($terse) {\n\t\t$output = (split('\\n', $output))[0] . \"\\n\";\n\t}\n\n\tif ($verbose && exists($verbose_messages{$type}) &&\n\t    !exists($verbose_emitted{$type})) {\n\t\t$output .= $verbose_messages{$type} . \"\\n\\n\";\n\t\t$verbose_emitted{$type} = 1;\n\t}\n\n\tpush(our @report, $output);\n\n\treturn 1;\n}\n\nsub report_dump {\n\tour @report;\n}\n\nsub fixup_current_range {\n\tmy ($lineRef, $offset, $length) = @_;\n\n\tif ($$lineRef =~ /^\\@\\@ -\\d+,\\d+ \\+(\\d+),(\\d+) \\@\\@/) {\n\t\tmy $o = $1;\n\t\tmy $l = $2;\n\t\tmy $no = $o + $offset;\n\t\tmy $nl = $l + $length;\n\t\t$$lineRef =~ s/\\+$o,$l \\@\\@/\\+$no,$nl \\@\\@/;\n\t}\n}\n\nsub fix_inserted_deleted_lines {\n\tmy ($linesRef, $insertedRef, $deletedRef) = @_;\n\n\tmy $range_last_linenr = 0;\n\tmy $delta_offset = 0;\n\n\tmy $old_linenr = 0;\n\tmy $new_linenr = 0;\n\n\tmy $next_insert = 0;\n\tmy $next_delete = 0;\n\n\tmy @lines = ();\n\n\tmy $inserted = @{$insertedRef}[$next_insert++];\n\tmy $deleted = @{$deletedRef}[$next_delete++];\n\n\tforeach my $old_line (@{$linesRef}) {\n\t\tmy $save_line = 1;\n\t\tmy $line = $old_line;\t#don't modify the array\n\t\tif ($line =~ /^(?:\\+\\+\\+|\\-\\-\\-)\\s+\\S+/) {\t#new filename\n\t\t\t$delta_offset = 0;\n\t\t} elsif ($line =~ /^\\@\\@ -\\d+,\\d+ \\+\\d+,\\d+ \\@\\@/) {\t#new hunk\n\t\t\t$range_last_linenr = $new_linenr;\n\t\t\tfixup_current_range(\\$line, $delta_offset, 0);\n\t\t}\n\n\t\twhile (defined($deleted) && ${$deleted}{'LINENR'} == $old_linenr) {\n\t\t\t$deleted = @{$deletedRef}[$next_delete++];\n\t\t\t$save_line = 0;\n\t\t\tfixup_current_range(\\$lines[$range_last_linenr], $delta_offset--, -1);\n\t\t}\n\n\t\twhile (defined($inserted) && ${$inserted}{'LINENR'} == $old_linenr) {\n\t\t\tpush(@lines, ${$inserted}{'LINE'});\n\t\t\t$inserted = @{$insertedRef}[$next_insert++];\n\t\t\t$new_linenr++;\n\t\t\tfixup_current_range(\\$lines[$range_last_linenr], $delta_offset++, 1);\n\t\t}\n\n\t\tif ($save_line) {\n\t\t\tpush(@lines, $line);\n\t\t\t$new_linenr++;\n\t\t}\n\n\t\t$old_linenr++;\n\t}\n\n\treturn @lines;\n}\n\nsub fix_insert_line {\n\tmy ($linenr, $line) = @_;\n\n\tmy $inserted = {\n\t\tLINENR => $linenr,\n\t\tLINE => $line,\n\t};\n\tpush(@fixed_inserted, $inserted);\n}\n\nsub fix_delete_line {\n\tmy ($linenr, $line) = @_;\n\n\tmy $deleted = {\n\t\tLINENR => $linenr,\n\t\tLINE => $line,\n\t};\n\n\tpush(@fixed_deleted, $deleted);\n}\n\nsub ERROR {\n\tmy ($type, $msg) = @_;\n\n\tif (report(\"ERROR\", $type, $msg)) {\n\t\tour $clean = 0;\n\t\tour $cnt_error++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nsub WARN {\n\tmy ($type, $msg) = @_;\n\n\tif (report(\"WARNING\", $type, $msg)) {\n\t\tour $clean = 0;\n\t\tour $cnt_warn++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nsub CHK {\n\tmy ($type, $msg) = @_;\n\n\tif ($check && report(\"CHECK\", $type, $msg)) {\n\t\tour $clean = 0;\n\t\tour $cnt_chk++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nsub check_absolute_file {\n\tmy ($absolute, $herecurr) = @_;\n\tmy $file = $absolute;\n\n\t##print \"absolute<$absolute>\\n\";\n\n\t# See if any suffix of this path is a path within the tree.\n\twhile ($file =~ s@^[^/]*/@@) {\n\t\tif (-f \"$root/$file\") {\n\t\t\t##print \"file<$file>\\n\";\n\t\t\tlast;\n\t\t}\n\t}\n\tif (! -f _)  {\n\t\treturn 0;\n\t}\n\n\t# It is, so see if the prefix is acceptable.\n\tmy $prefix = $absolute;\n\tsubstr($prefix, -length($file)) = '';\n\n\t##print \"prefix<$prefix>\\n\";\n\tif ($prefix ne \".../\") {\n\t\tWARN(\"USE_RELATIVE_PATH\",\n\t\t     \"use relative pathname instead of absolute in changelog text\\n\" . $herecurr);\n\t}\n}\n\nsub trim {\n\tmy ($string) = @_;\n\n\t$string =~ s/^\\s+|\\s+$//g;\n\n\treturn $string;\n}\n\nsub ltrim {\n\tmy ($string) = @_;\n\n\t$string =~ s/^\\s+//;\n\n\treturn $string;\n}\n\nsub rtrim {\n\tmy ($string) = @_;\n\n\t$string =~ s/\\s+$//;\n\n\treturn $string;\n}\n\nsub string_find_replace {\n\tmy ($string, $find, $replace) = @_;\n\n\t$string =~ s/$find/$replace/g;\n\n\treturn $string;\n}\n\nsub tabify {\n\tmy ($leading) = @_;\n\n\tmy $source_indent = $tabsize;\n\tmy $max_spaces_before_tab = $source_indent - 1;\n\tmy $spaces_to_tab = \" \" x $source_indent;\n\n\t#convert leading spaces to tabs\n\t1 while $leading =~ s@^([\\t]*)$spaces_to_tab@$1\\t@g;\n\t#Remove spaces before a tab\n\t1 while $leading =~ s@^([\\t]*)( {1,$max_spaces_before_tab})\\t@$1\\t@g;\n\n\treturn \"$leading\";\n}\n\nsub pos_last_openparen {\n\tmy ($line) = @_;\n\n\tmy $pos = 0;\n\n\tmy $opens = $line =~ tr/\\(/\\(/;\n\tmy $closes = $line =~ tr/\\)/\\)/;\n\n\tmy $last_openparen = 0;\n\n\tif (($opens == 0) || ($closes >= $opens)) {\n\t\treturn -1;\n\t}\n\n\tmy $len = length($line);\n\n\tfor ($pos = 0; $pos < $len; $pos++) {\n\t\tmy $string = substr($line, $pos);\n\t\tif ($string =~ /^($FuncArg|$balanced_parens)/) {\n\t\t\t$pos += length($1) - 1;\n\t\t} elsif (substr($line, $pos, 1) eq '(') {\n\t\t\t$last_openparen = $pos;\n\t\t} elsif (index($string, '(') == -1) {\n\t\t\tlast;\n\t\t}\n\t}\n\n\treturn length(expand_tabs(substr($line, 0, $last_openparen))) + 1;\n}\n\nsub get_raw_comment {\n\tmy ($line, $rawline) = @_;\n\tmy $comment = '';\n\n\tfor my $i (0 .. (length($line) - 1)) {\n\t\tif (substr($line, $i, 1) eq \"$;\") {\n\t\t\t$comment .= substr($rawline, $i, 1);\n\t\t}\n\t}\n\n\treturn $comment;\n}\n\nsub exclude_global_initialisers {\n\tmy ($realfile) = @_;\n\n\t# Do not check for BPF programs (tools/testing/selftests/bpf/progs/*.c, samples/bpf/*_kern.c, *.bpf.c).\n\treturn $realfile =~ m@^tools/testing/selftests/bpf/progs/.*\\.c$@ ||\n\t\t$realfile =~ m@^samples/bpf/.*_kern\\.c$@ ||\n\t\t$realfile =~ m@/bpf/.*\\.bpf\\.c$@;\n}\n\nsub process {\n\tmy $filename = shift;\n\n\tmy $linenr=0;\n\tmy $prevline=\"\";\n\tmy $prevrawline=\"\";\n\tmy $stashline=\"\";\n\tmy $stashrawline=\"\";\n\n\tmy $length;\n\tmy $indent;\n\tmy $previndent=0;\n\tmy $stashindent=0;\n\n\tour $clean = 1;\n\tmy $signoff = 0;\n\tmy $fixes_tag = 0;\n\tmy $is_revert = 0;\n\tmy $needs_fixes_tag = \"\";\n\tmy $author = '';\n\tmy $authorsignoff = 0;\n\tmy $author_sob = '';\n\tmy $is_patch = 0;\n\tmy $is_binding_patch = -1;\n\tmy $in_header_lines = $file ? 0 : 1;\n\tmy $in_commit_log = 0;\t\t#Scanning lines before patch\n\tmy $has_patch_separator = 0;\t#Found a --- line\n\tmy $has_commit_log = 0;\t\t#Encountered lines before patch\n\tmy $commit_log_lines = 0;\t#Number of commit log lines\n\tmy $commit_log_possible_stack_dump = 0;\n\tmy $commit_log_long_line = 0;\n\tmy $commit_log_has_diff = 0;\n\tmy $reported_maintainer_file = 0;\n\tmy $non_utf8_charset = 0;\n\n\tmy $last_git_commit_id_linenr = -1;\n\n\tmy $last_blank_line = 0;\n\tmy $last_coalesced_string_linenr = -1;\n\n\tour @report = ();\n\tour $cnt_lines = 0;\n\tour $cnt_error = 0;\n\tour $cnt_warn = 0;\n\tour $cnt_chk = 0;\n\n\t# Trace the real file/line as we go.\n\tmy $realfile = '';\n\tmy $realline = 0;\n\tmy $realcnt = 0;\n\tmy $here = '';\n\tmy $context_function;\t\t#undef'd unless there's a known function\n\tmy $in_comment = 0;\n\tmy $comment_edge = 0;\n\tmy $first_line = 0;\n\tmy $p1_prefix = '';\n\n\tmy $prev_values = 'E';\n\n\t# suppression flags\n\tmy %suppress_ifbraces;\n\tmy %suppress_whiletrailers;\n\tmy %suppress_export;\n\tmy $suppress_statement = 0;\n\n\tmy %signatures = ();\n\n\t# Pre-scan the patch sanitizing the lines.\n\t# Pre-scan the patch looking for any __setup documentation.\n\t#\n\tmy @setup_docs = ();\n\tmy $setup_docs = 0;\n\n\tmy $camelcase_file_seeded = 0;\n\n\tmy $checklicenseline = 1;\n\n\tsanitise_line_reset();\n\tmy $line;\n\tforeach my $rawline (@rawlines) {\n\t\t$linenr++;\n\t\t$line = $rawline;\n\n\t\tpush(@fixed, $rawline) if ($fix);\n\n\t\tif ($rawline=~/^\\+\\+\\+\\s+(\\S+)/) {\n\t\t\t$setup_docs = 0;\n\t\t\tif ($1 =~ m@Documentation/admin-guide/kernel-parameters.txt$@) {\n\t\t\t\t$setup_docs = 1;\n\t\t\t}\n\t\t\t#next;\n\t\t}\n\t\tif ($rawline =~ /^\\@\\@ -\\d+(?:,\\d+)? \\+(\\d+)(,(\\d+))? \\@\\@/) {\n\t\t\t$realline=$1-1;\n\t\t\tif (defined $2) {\n\t\t\t\t$realcnt=$3+1;\n\t\t\t} else {\n\t\t\t\t$realcnt=1+1;\n\t\t\t}\n\t\t\t$in_comment = 0;\n\n\t\t\t# Guestimate if this is a continuing comment.  Run\n\t\t\t# the context looking for a comment \"edge\".  If this\n\t\t\t# edge is a close comment then we must be in a comment\n\t\t\t# at context start.\n\t\t\tmy $edge;\n\t\t\tmy $cnt = $realcnt;\n\t\t\tfor (my $ln = $linenr + 1; $cnt > 0; $ln++) {\n\t\t\t\tnext if (defined $rawlines[$ln - 1] &&\n\t\t\t\t\t $rawlines[$ln - 1] =~ /^-/);\n\t\t\t\t$cnt--;\n\t\t\t\t#print \"RAW<$rawlines[$ln - 1]>\\n\";\n\t\t\t\tlast if (!defined $rawlines[$ln - 1]);\n\t\t\t\tif ($rawlines[$ln - 1] =~ m@(/\\*|\\*/)@ &&\n\t\t\t\t    $rawlines[$ln - 1] !~ m@\"[^\"]*(?:/\\*|\\*/)[^\"]*\"@) {\n\t\t\t\t\t($edge) = $1;\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (defined $edge && $edge eq '*/') {\n\t\t\t\t$in_comment = 1;\n\t\t\t}\n\n\t\t\t# Guestimate if this is a continuing comment.  If this\n\t\t\t# is the start of a diff block and this line starts\n\t\t\t# ' *' then it is very likely a comment.\n\t\t\tif (!defined $edge &&\n\t\t\t    $rawlines[$linenr] =~ m@^.\\s*(?:\\*\\*+| \\*)(?:\\s|$)@)\n\t\t\t{\n\t\t\t\t$in_comment = 1;\n\t\t\t}\n\n\t\t\t##print \"COMMENT:$in_comment edge<$edge> $rawline\\n\";\n\t\t\tsanitise_line_reset($in_comment);\n\n\t\t} elsif ($realcnt && $rawline =~ /^(?:\\+| |$)/) {\n\t\t\t# Standardise the strings and chars within the input to\n\t\t\t# simplify matching -- only bother with positive lines.\n\t\t\t$line = sanitise_line($rawline);\n\t\t}\n\t\tpush(@lines, $line);\n\n\t\tif ($realcnt > 1) {\n\t\t\t$realcnt-- if ($line =~ /^(?:\\+| |$)/);\n\t\t} else {\n\t\t\t$realcnt = 0;\n\t\t}\n\n\t\t#print \"==>$rawline\\n\";\n\t\t#print \"-->$line\\n\";\n\n\t\tif ($setup_docs && $line =~ /^\\+/) {\n\t\t\tpush(@setup_docs, $line);\n\t\t}\n\t}\n\n\t$prefix = '';\n\n\t$realcnt = 0;\n\t$linenr = 0;\n\t$fixlinenr = -1;\n\tforeach my $line (@lines) {\n\t\t$linenr++;\n\t\t$fixlinenr++;\n\t\tmy $sline = $line;\t#copy of $line\n\t\t$sline =~ s/$;/ /g;\t#with comments as spaces\n\n\t\tmy $rawline = $rawlines[$linenr - 1];\n\t\tmy $raw_comment = get_raw_comment($line, $rawline);\n\n# check if it's a mode change, rename or start of a patch\n\t\tif (!$in_commit_log &&\n\t\t    ($line =~ /^ mode change [0-7]+ => [0-7]+ \\S+\\s*$/ ||\n\t\t    ($line =~ /^rename (?:from|to) \\S+\\s*$/ ||\n\t\t     $line =~ /^diff --git a\\/[\\w\\/\\.\\_\\-]+ b\\/\\S+\\s*$/))) {\n\t\t\t$is_patch = 1;\n\t\t}\n\n#extract the line range in the file after the patch is applied\n\t\tif (!$in_commit_log &&\n\t\t    $line =~ /^\\@\\@ -\\d+(?:,\\d+)? \\+(\\d+)(,(\\d+))? \\@\\@(.*)/) {\n\t\t\tmy $context = $4;\n\t\t\t$is_patch = 1;\n\t\t\t$first_line = $linenr + 1;\n\t\t\t$realline=$1-1;\n\t\t\tif (defined $2) {\n\t\t\t\t$realcnt=$3+1;\n\t\t\t} else {\n\t\t\t\t$realcnt=1+1;\n\t\t\t}\n\t\t\tannotate_reset();\n\t\t\t$prev_values = 'E';\n\n\t\t\t%suppress_ifbraces = ();\n\t\t\t%suppress_whiletrailers = ();\n\t\t\t%suppress_export = ();\n\t\t\t$suppress_statement = 0;\n\t\t\tif ($context =~ /\\b(\\w+)\\s*\\(/) {\n\t\t\t\t$context_function = $1;\n\t\t\t} else {\n\t\t\t\tundef $context_function;\n\t\t\t}\n\t\t\tnext;\n\n# track the line number as we move through the hunk, note that\n# new versions of GNU diff omit the leading space on completely\n# blank context lines so we need to count that too.\n\t\t} elsif ($line =~ /^( |\\+|$)/) {\n\t\t\t$realline++;\n\t\t\t$realcnt-- if ($realcnt != 0);\n\n\t\t\t# Measure the line length and indent.\n\t\t\t($length, $indent) = line_stats($rawline);\n\n\t\t\t# Track the previous line.\n\t\t\t($prevline, $stashline) = ($stashline, $line);\n\t\t\t($previndent, $stashindent) = ($stashindent, $indent);\n\t\t\t($prevrawline, $stashrawline) = ($stashrawline, $rawline);\n\n\t\t\t#warn \"line<$line>\\n\";\n\n\t\t} elsif ($realcnt == 1) {\n\t\t\t$realcnt--;\n\t\t}\n\n\t\tmy $hunk_line = ($realcnt != 0);\n\n\t\t$here = \"#$linenr: \" if (!$file);\n\t\t$here = \"#$realline: \" if ($file);\n\n\t\tmy $found_file = 0;\n\t\t# extract the filename as it passes\n\t\tif ($line =~ /^diff --git.*?(\\S+)$/) {\n\t\t\t$realfile = $1;\n\t\t\t$realfile =~ s@^([^/]*)/@@ if (!$file);\n\t\t\t$in_commit_log = 0;\n\t\t\t$found_file = 1;\n\t\t} elsif ($line =~ /^\\+\\+\\+\\s+(\\S+)/) {\n\t\t\t$realfile = $1;\n\t\t\t$realfile =~ s@^([^/]*)/@@ if (!$file);\n\t\t\t$in_commit_log = 0;\n\n\t\t\t$p1_prefix = $1;\n\t\t\tif (!$file && $tree && $p1_prefix ne '' &&\n\t\t\t    -e \"$root/$p1_prefix\") {\n\t\t\t\tWARN(\"PATCH_PREFIX\",\n\t\t\t\t     \"patch prefix '$p1_prefix' exists, appears to be a -p0 patch\\n\");\n\t\t\t}\n\n\t\t\tif ($realfile =~ m@^include/asm/@) {\n\t\t\t\tERROR(\"MODIFIED_INCLUDE_ASM\",\n\t\t\t\t      \"do not modify files in include/asm, change architecture specific files in include/asm-<architecture>\\n\" . \"$here$rawline\\n\");\n\t\t\t}\n\t\t\t$found_file = 1;\n\t\t}\n\n#make up the handle for any error we report on this line\n\t\tif ($showfile) {\n\t\t\t$prefix = \"$realfile:$realline: \"\n\t\t} elsif ($emacs) {\n\t\t\tif ($file) {\n\t\t\t\t$prefix = \"$filename:$realline: \";\n\t\t\t} else {\n\t\t\t\t$prefix = \"$filename:$linenr: \";\n\t\t\t}\n\t\t}\n\n\t\tif ($found_file) {\n\t\t\tif (is_maintained_obsolete($realfile)) {\n\t\t\t\tWARN(\"OBSOLETE\",\n\t\t\t\t     \"$realfile is marked as 'obsolete' in the MAINTAINERS hierarchy.  No unnecessary modifications please.\\n\");\n\t\t\t}\n\t\t\tif ($realfile =~ m@^(?:drivers/net/|net/|drivers/staging/)@) {\n\t\t\t\t$check = 1;\n\t\t\t} else {\n\t\t\t\t$check = $check_orig;\n\t\t\t}\n\t\t\t$checklicenseline = 1;\n\n\t\t\tif ($realfile !~ /^MAINTAINERS/) {\n\t\t\t\tmy $last_binding_patch = $is_binding_patch;\n\n\t\t\t\t$is_binding_patch = () = $realfile =~ m@^(?:Documentation/devicetree/|include/dt-bindings/)@;\n\n\t\t\t\tif (($last_binding_patch != -1) &&\n\t\t\t\t    ($last_binding_patch ^ $is_binding_patch)) {\n\t\t\t\t\tWARN(\"DT_SPLIT_BINDING_PATCH\",\n\t\t\t\t\t     \"DT binding docs and includes should be a separate patch. See: Documentation/devicetree/bindings/submitting-patches.rst\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnext;\n\t\t}\n\n\t\t$here .= \"FILE: $realfile:$realline:\" if ($realcnt != 0);\n\n\t\tmy $hereline = \"$here\\n$rawline\\n\";\n\t\tmy $herecurr = \"$here\\n$rawline\\n\";\n\t\tmy $hereprev = \"$here\\n$prevrawline\\n$rawline\\n\";\n\n\t\t$cnt_lines++ if ($realcnt != 0);\n\n# Verify the existence of a commit log if appropriate\n# 2 is used because a $signature is counted in $commit_log_lines\n\t\tif ($in_commit_log) {\n\t\t\tif ($line !~ /^\\s*$/) {\n\t\t\t\t$commit_log_lines++;\t#could be a $signature\n\t\t\t}\n\t\t} elsif ($has_commit_log && $commit_log_lines < 2) {\n\t\t\tWARN(\"COMMIT_MESSAGE\",\n\t\t\t     \"Missing commit description - Add an appropriate one\\n\");\n\t\t\t$commit_log_lines = 2;\t#warn only once\n\t\t}\n\n# Check if the commit log has what seems like a diff which can confuse patch\n\t\tif ($in_commit_log && !$commit_log_has_diff &&\n\t\t    (($line =~ m@^\\s+diff\\b.*a/([\\w/]+)@ &&\n\t\t      $line =~ m@^\\s+diff\\b.*a/[\\w/]+\\s+b/$1\\b@) ||\n\t\t     $line =~ m@^\\s*(?:\\-\\-\\-\\s+a/|\\+\\+\\+\\s+b/)@ ||\n\t\t     $line =~ m/^\\s*\\@\\@ \\-\\d+,\\d+ \\+\\d+,\\d+ \\@\\@/)) {\n\t\t\tERROR(\"DIFF_IN_COMMIT_MSG\",\n\t\t\t      \"Avoid using diff content in the commit message - patch(1) might not work\\n\" . $herecurr);\n\t\t\t$commit_log_has_diff = 1;\n\t\t}\n\n# Check for incorrect file permissions\n\t\tif ($line =~ /^new (file )?mode.*[7531]\\d{0,2}$/) {\n\t\t\tmy $permhere = $here . \"FILE: $realfile\\n\";\n\t\t\tif ($realfile !~ m@scripts/@ &&\n\t\t\t    $realfile !~ /\\.(py|pl|awk|sh)$/) {\n\t\t\t\tERROR(\"EXECUTE_PERMISSIONS\",\n\t\t\t\t      \"do not set execute permissions for source files\\n\" . $permhere);\n\t\t\t}\n\t\t}\n\n# Check the patch for a From:\n\t\tif (decode(\"MIME-Header\", $line) =~ /^From:\\s*(.*)/) {\n\t\t\t$author = $1;\n\t\t\tmy $curline = $linenr;\n\t\t\twhile(defined($rawlines[$curline]) && ($rawlines[$curline++] =~ /^[ \\t]\\s*(.*)/)) {\n\t\t\t\t$author .= $1;\n\t\t\t}\n\t\t\t$author = encode(\"utf8\", $author) if ($line =~ /=\\?utf-8\\?/i);\n\t\t\t$author =~ s/\"//g;\n\t\t\t$author = reformat_email($author);\n\t\t}\n\n# Check the patch for a signoff:\n\t\tif ($line =~ /^\\s*signed-off-by:\\s*(.*)/i) {\n\t\t\t$signoff++;\n\t\t\t$in_commit_log = 0;\n\t\t\tif ($author ne ''  && $authorsignoff != 1) {\n\t\t\t\tif (same_email_addresses($1, $author)) {\n\t\t\t\t\t$authorsignoff = 1;\n\t\t\t\t} else {\n\t\t\t\t\tmy $ctx = $1;\n\t\t\t\t\tmy ($email_name, $email_comment, $email_address, $comment1) = parse_email($ctx);\n\t\t\t\t\tmy ($author_name, $author_comment, $author_address, $comment2) = parse_email($author);\n\n\t\t\t\t\tif (lc $email_address eq lc $author_address && $email_name eq $author_name) {\n\t\t\t\t\t\t$author_sob = $ctx;\n\t\t\t\t\t\t$authorsignoff = 2;\n\t\t\t\t\t} elsif (lc $email_address eq lc $author_address) {\n\t\t\t\t\t\t$author_sob = $ctx;\n\t\t\t\t\t\t$authorsignoff = 3;\n\t\t\t\t\t} elsif ($email_name eq $author_name) {\n\t\t\t\t\t\t$author_sob = $ctx;\n\t\t\t\t\t\t$authorsignoff = 4;\n\n\t\t\t\t\t\tmy $address1 = $email_address;\n\t\t\t\t\t\tmy $address2 = $author_address;\n\n\t\t\t\t\t\tif ($address1 =~ /(\\S+)\\+\\S+(\\@.*)/) {\n\t\t\t\t\t\t\t$address1 = \"$1$2\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($address2 =~ /(\\S+)\\+\\S+(\\@.*)/) {\n\t\t\t\t\t\t\t$address2 = \"$1$2\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($address1 eq $address2) {\n\t\t\t\t\t\t\t$authorsignoff = 5;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# Check for patch separator\n\t\tif ($line =~ /^---$/) {\n\t\t\t$has_patch_separator = 1;\n\t\t\t$in_commit_log = 0;\n\t\t}\n\n# Check if MAINTAINERS is being updated.  If so, there's probably no need to\n# emit the \"does MAINTAINERS need updating?\" message on file add/move/delete\n\t\tif ($line =~ /^\\s*MAINTAINERS\\s*\\|/) {\n\t\t\t$reported_maintainer_file = 1;\n\t\t}\n\n# Check signature styles\n\t\tif (!$in_header_lines &&\n\t\t    $line =~ /^(\\s*)([a-z0-9_-]+by:|$signature_tags)(\\s*)(.*)/i) {\n\t\t\tmy $space_before = $1;\n\t\t\tmy $sign_off = $2;\n\t\t\tmy $space_after = $3;\n\t\t\tmy $email = $4;\n\t\t\tmy $ucfirst_sign_off = ucfirst(lc($sign_off));\n\n\t\t\tif ($sign_off !~ /$signature_tags/) {\n\t\t\t\tmy $suggested_signature = find_standard_signature($sign_off);\n\t\t\t\tif ($suggested_signature eq \"\") {\n\t\t\t\t\tWARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t     \"Non-standard signature: $sign_off\\n\" . $herecurr);\n\t\t\t\t} else {\n\t\t\t\t\tif (WARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t\t \"Non-standard signature: '$sign_off' - perhaps '$suggested_signature'?\\n\" . $herecurr) &&\n\t\t\t\t\t    $fix) {\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/$sign_off/$suggested_signature/;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (defined $space_before && $space_before ne \"\") {\n\t\t\t\tif (WARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t \"Do not use whitespace before $ucfirst_sign_off\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =\n\t\t\t\t\t    \"$ucfirst_sign_off $email\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($sign_off =~ /-by:$/i && $sign_off ne $ucfirst_sign_off) {\n\t\t\t\tif (WARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t \"'$ucfirst_sign_off' is the preferred signature form\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =\n\t\t\t\t\t    \"$ucfirst_sign_off $email\";\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (!defined $space_after || $space_after ne \" \") {\n\t\t\t\tif (WARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t \"Use a single space after $ucfirst_sign_off\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =\n\t\t\t\t\t    \"$ucfirst_sign_off $email\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmy ($email_name, $name_comment, $email_address, $comment) = parse_email($email);\n\t\t\tmy $suggested_email = format_email(($email_name, $name_comment, $email_address, $comment));\n\t\t\tif ($suggested_email eq \"\") {\n\t\t\t\tERROR(\"BAD_SIGN_OFF\",\n\t\t\t\t      \"Unrecognized email address: '$email'\\n\" . $herecurr);\n\t\t\t} else {\n\t\t\t\tmy $dequoted = $suggested_email;\n\t\t\t\t$dequoted =~ s/^\"//;\n\t\t\t\t$dequoted =~ s/\" </ </;\n\t\t\t\t# Don't force email to have quotes\n\t\t\t\t# Allow just an angle bracketed address\n\t\t\t\tif (!same_email_addresses($email, $suggested_email)) {\n\t\t\t\t\tif (WARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t\t \"email address '$email' might be better as '$suggested_email'\\n\" . $herecurr) &&\n\t\t\t\t\t    $fix) {\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$email\\E/$suggested_email/;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t# Address part shouldn't have comments\n\t\t\t\tmy $stripped_address = $email_address;\n\t\t\t\t$stripped_address =~ s/\\([^\\(\\)]*\\)//g;\n\t\t\t\tif ($email_address ne $stripped_address) {\n\t\t\t\t\tif (WARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t\t \"address part of email should not have comments: '$email_address'\\n\" . $herecurr) &&\n\t\t\t\t\t    $fix) {\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$email_address\\E/$stripped_address/;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t# Only one name comment should be allowed\n\t\t\t\tmy $comment_count = () = $name_comment =~ /\\([^\\)]+\\)/g;\n\t\t\t\tif ($comment_count > 1) {\n\t\t\t\t\tWARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t     \"Use a single name comment in email: '$email'\\n\" . $herecurr);\n\t\t\t\t}\n\n\n\t\t\t\t# stable@vger.kernel.org or stable@kernel.org shouldn't\n\t\t\t\t# have an email name. In addition comments should strictly\n\t\t\t\t# begin with a #\n\t\t\t\tif ($email =~ /^.*stable\\@(?:vger\\.)?kernel\\.org/i) {\n\t\t\t\t\tif (($comment ne \"\" && $comment !~ /^#.+/) ||\n\t\t\t\t\t    ($email_name ne \"\")) {\n\t\t\t\t\t\tmy $cur_name = $email_name;\n\t\t\t\t\t\tmy $new_comment = $comment;\n\t\t\t\t\t\t$cur_name =~ s/[a-zA-Z\\s\\-\\\"]+//g;\n\n\t\t\t\t\t\t# Remove brackets enclosing comment text\n\t\t\t\t\t\t# and # from start of comments to get comment text\n\t\t\t\t\t\t$new_comment =~ s/^\\((.*)\\)$/$1/;\n\t\t\t\t\t\t$new_comment =~ s/^\\[(.*)\\]$/$1/;\n\t\t\t\t\t\t$new_comment =~ s/^[\\s\\#]+|\\s+$//g;\n\n\t\t\t\t\t\t$new_comment = trim(\"$new_comment $cur_name\") if ($cur_name ne $new_comment);\n\t\t\t\t\t\t$new_comment = \" # $new_comment\" if ($new_comment ne \"\");\n\t\t\t\t\t\tmy $new_email = \"$email_address$new_comment\";\n\n\t\t\t\t\t\tif (WARN(\"BAD_STABLE_ADDRESS_STYLE\",\n\t\t\t\t\t\t\t \"Invalid email format for stable: '$email', prefer '$new_email'\\n\" . $herecurr) &&\n\t\t\t\t\t\t    $fix) {\n\t\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$email\\E/$new_email/;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} elsif ($comment ne \"\" && $comment !~ /^(?:#.+|\\(.+\\))$/) {\n\t\t\t\t\tmy $new_comment = $comment;\n\n\t\t\t\t\t# Extract comment text from within brackets or\n\t\t\t\t\t# c89 style /*...*/ comments\n\t\t\t\t\t$new_comment =~ s/^\\[(.*)\\]$/$1/;\n\t\t\t\t\t$new_comment =~ s/^\\/\\*(.*)\\*\\/$/$1/;\n\n\t\t\t\t\t$new_comment = trim($new_comment);\n\t\t\t\t\t$new_comment =~ s/^[^\\w]$//; # Single lettered comment with non word character is usually a typo\n\t\t\t\t\t$new_comment = \"($new_comment)\" if ($new_comment ne \"\");\n\t\t\t\t\tmy $new_email = format_email($email_name, $name_comment, $email_address, $new_comment);\n\n\t\t\t\t\tif (WARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t\t \"Unexpected content after email: '$email', should be: '$new_email'\\n\" . $herecurr) &&\n\t\t\t\t\t    $fix) {\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$email\\E/$new_email/;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n# Check for duplicate signatures\n\t\t\tmy $sig_nospace = $line;\n\t\t\t$sig_nospace =~ s/\\s//g;\n\t\t\t$sig_nospace = lc($sig_nospace);\n\t\t\tif (defined $signatures{$sig_nospace}) {\n\t\t\t\tWARN(\"BAD_SIGN_OFF\",\n\t\t\t\t     \"Duplicate signature\\n\" . $herecurr);\n\t\t\t} else {\n\t\t\t\t$signatures{$sig_nospace} = 1;\n\t\t\t}\n\n# Check Co-developed-by: immediately followed by Signed-off-by: with same name and email\n\t\t\tif ($sign_off =~ /^co-developed-by:$/i) {\n\t\t\t\tif ($email eq $author) {\n\t\t\t\t\tWARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t      \"Co-developed-by: should not be used to attribute nominal patch author '$author'\\n\" . $herecurr);\n\t\t\t\t}\n\t\t\t\tif (!defined $lines[$linenr]) {\n\t\t\t\t\tWARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t     \"Co-developed-by: must be immediately followed by Signed-off-by:\\n\" . $herecurr);\n\t\t\t\t} elsif ($rawlines[$linenr] !~ /^signed-off-by:\\s*(.*)/i) {\n\t\t\t\t\tWARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t     \"Co-developed-by: must be immediately followed by Signed-off-by:\\n\" . $herecurr . $rawlines[$linenr] . \"\\n\");\n\t\t\t\t} elsif ($1 ne $email) {\n\t\t\t\t\tWARN(\"BAD_SIGN_OFF\",\n\t\t\t\t\t     \"Co-developed-by and Signed-off-by: name/email do not match\\n\" . $herecurr . $rawlines[$linenr] . \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\n# check if Reported-by: is followed by a Closes: tag\n\t\t\tif ($sign_off =~ /^reported(?:|-and-tested)-by:$/i) {\n\t\t\t\tif (!defined $lines[$linenr]) {\n\t\t\t\t\tWARN(\"BAD_REPORTED_BY_LINK\",\n\t\t\t\t\t     \"Reported-by: should be immediately followed by Closes: with a URL to the report\\n\" . $herecurr . \"\\n\");\n\t\t\t\t} elsif ($rawlines[$linenr] !~ /^closes:\\s*/i) {\n\t\t\t\t\tWARN(\"BAD_REPORTED_BY_LINK\",\n\t\t\t\t\t     \"Reported-by: should be immediately followed by Closes: with a URL to the report\\n\" . $herecurr . $rawlines[$linenr] . \"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# These indicate a bug fix\n\t\tif (!$in_header_lines && !$is_patch &&\n\t\t\t$line =~ /^This reverts commit/) {\n\t\t\t$is_revert = 1;\n\t\t}\n\n\t\tif (!$in_header_lines && !$is_patch &&\n\t\t    $line =~ /((?:(?:BUG: K.|UB)SAN: |Call Trace:|stable\\@|syzkaller))/) {\n\t\t\t$needs_fixes_tag = $1;\n\t\t}\n\n# Check Fixes: styles is correct\n\t\tif (!$in_header_lines &&\n\t\t    $line =~ /^\\s*(fixes:?)\\s*(?:commit\\s*)?([0-9a-f]{5,40})(?:\\s*($balanced_parens))?/i) {\n\t\t\tmy $tag = $1;\n\t\t\tmy $orig_commit = $2;\n\t\t\tmy $title;\n\t\t\tmy $title_has_quotes = 0;\n\t\t\t$fixes_tag = 1;\n\t\t\tif (defined $3) {\n\t\t\t\t# Always strip leading/trailing parens then double quotes if existing\n\t\t\t\t$title = substr($3, 1, -1);\n\t\t\t\tif ($title =~ /^\".*\"$/) {\n\t\t\t\t\t$title = substr($title, 1, -1);\n\t\t\t\t\t$title_has_quotes = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$title = \"commit title\"\n\t\t\t}\n\n\n\t\t\tmy $tag_case = not ($tag eq \"Fixes:\");\n\t\t\tmy $tag_space = not ($line =~ /^fixes:? [0-9a-f]{5,40} ($balanced_parens)/i);\n\n\t\t\tmy $id_length = not ($orig_commit =~ /^[0-9a-f]{12}$/i);\n\t\t\tmy $id_case = not ($orig_commit !~ /[A-F]/);\n\n\t\t\tmy $id = \"0123456789ab\";\n\t\t\tmy ($cid, $ctitle) = git_commit_info($orig_commit, $id,\n\t\t\t\t\t\t\t     $title);\n\n\t\t\tif ($ctitle ne $title || $tag_case || $tag_space ||\n\t\t\t    $id_length || $id_case || !$title_has_quotes) {\n\t\t\t\tif (WARN(\"BAD_FIXES_TAG\",\n\t\t\t\t     \"Please use correct Fixes: style 'Fixes: <12 chars of sha1> (\\\"<title line>\\\")' - ie: 'Fixes: $cid (\\\"$ctitle\\\")'\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] = \"Fixes: $cid (\\\"$ctitle\\\")\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# Check email subject for common tools that don't need to be mentioned\n\t\tif ($in_header_lines &&\n\t\t    $line =~ /^Subject:.*\\b(?:checkpatch|sparse|smatch)\\b[^:]/i) {\n\t\t\tWARN(\"EMAIL_SUBJECT\",\n\t\t\t     \"A patch subject line should describe the change not the tool that found it\\n\" . $herecurr);\n\t\t}\n\n# Check for Gerrit Change-Ids not in any patch context\n\t\tif ($realfile eq '' && !$has_patch_separator && $line =~ /^\\s*change-id:/i) {\n\t\t\tif (ERROR(\"GERRIT_CHANGE_ID\",\n\t\t\t          \"Remove Gerrit Change-Id's before submitting upstream\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t}\n\t\t}\n\n# Check if the commit log is in a possible stack dump\n\t\tif ($in_commit_log && !$commit_log_possible_stack_dump &&\n\t\t    ($line =~ /^\\s*(?:WARNING:|BUG:)/ ||\n\t\t     $line =~ /^\\s*\\[\\s*\\d+\\.\\d{6,6}\\s*\\]/ ||\n\t\t\t\t\t# timestamp\n\t\t     $line =~ /^\\s*\\[\\<[0-9a-fA-F]{8,}\\>\\]/) ||\n\t\t     $line =~ /^(?:\\s+\\w+:\\s+[0-9a-fA-F]+){3,3}/ ||\n\t\t     $line =~ /^\\s*\\#\\d+\\s*\\[[0-9a-fA-F]+\\]\\s*\\w+ at [0-9a-fA-F]+/) {\n\t\t\t\t\t# stack dump address styles\n\t\t\t$commit_log_possible_stack_dump = 1;\n\t\t}\n\n# Check for line lengths > 75 in commit log, warn once\n\t\tif ($in_commit_log && !$commit_log_long_line &&\n\t\t    length($line) > 75 &&\n\t\t    !($line =~ /^\\s*[a-zA-Z0-9_\\/\\.]+\\s+\\|\\s+\\d+/ ||\n\t\t\t\t\t# file delta changes\n\t\t      $line =~ /^\\s*(?:[\\w\\.\\-\\+]*\\/)++[\\w\\.\\-\\+]+:/ ||\n\t\t\t\t\t# filename then :\n\t\t      $line =~ /^\\s*(?:Fixes:|$link_tags_search|$signature_tags)/i ||\n\t\t\t\t\t# A Fixes:, link or signature tag line\n\t\t      $commit_log_possible_stack_dump)) {\n\t\t\tWARN(\"COMMIT_LOG_LONG_LINE\",\n\t\t\t     \"Prefer a maximum 75 chars per line (possible unwrapped commit description?)\\n\" . $herecurr);\n\t\t\t$commit_log_long_line = 1;\n\t\t}\n\n# Reset possible stack dump if a blank line is found\n\t\tif ($in_commit_log && $commit_log_possible_stack_dump &&\n\t\t    $line =~ /^\\s*$/) {\n\t\t\t$commit_log_possible_stack_dump = 0;\n\t\t}\n\n# Check for odd tags before a URI/URL\n\t\tif ($in_commit_log &&\n\t\t    $line =~ /^\\s*(\\w+:)\\s*http/ && $1 !~ /^$link_tags_search$/) {\n\t\t\tif ($1 =~ /^v(?:ersion)?\\d+/i) {\n\t\t\t\tWARN(\"COMMIT_LOG_VERSIONING\",\n\t\t\t\t     \"Patch version information should be after the --- line\\n\" . $herecurr);\n\t\t\t} else {\n\t\t\t\tWARN(\"COMMIT_LOG_USE_LINK\",\n\t\t\t\t     \"Unknown link reference '$1', use $link_tags_print instead\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# Check for misuse of the link tags\n\t\tif ($in_commit_log &&\n\t\t    $line =~ /^\\s*(\\w+:)\\s*(\\S+)/) {\n\t\t\tmy $tag = $1;\n\t\t\tmy $value = $2;\n\t\t\tif ($tag =~ /^$link_tags_search$/ && $value !~ m{^https?://}) {\n\t\t\t\tWARN(\"COMMIT_LOG_WRONG_LINK\",\n\t\t\t\t     \"'$tag' should be followed by a public http(s) link\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# Check for lines starting with a #\n\t\tif ($in_commit_log && $line =~ /^#/) {\n\t\t\tif (WARN(\"COMMIT_COMMENT_SYMBOL\",\n\t\t\t\t \"Commit log lines starting with '#' are dropped by git as comments\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/^/ /;\n\t\t\t}\n\t\t}\n\n# Check for git id commit length and improperly formed commit descriptions\n# A correctly formed commit description is:\n#    commit <SHA-1 hash length 12+ chars> (\"Complete commit subject\")\n# with the commit subject '(\"' prefix and '\")' suffix\n# This is a fairly compilicated block as it tests for what appears to be\n# bare SHA-1 hash with  minimum length of 5.  It also avoids several types of\n# possible SHA-1 matches.\n# A commit match can span multiple lines so this block attempts to find a\n# complete typical commit on a maximum of 3 lines\n\t\tif ($perl_version_ok &&\n\t\t    $in_commit_log && !$commit_log_possible_stack_dump &&\n\t\t    $line !~ /^\\s*(?:Link|Patchwork|http|https|BugLink|base-commit):/i &&\n\t\t    $line !~ /^This reverts commit [0-9a-f]{7,40}/ &&\n\t\t    (($line =~ /\\bcommit\\s+[0-9a-f]{5,}\\b/i ||\n\t\t      ($line =~ /\\bcommit\\s*$/i && defined($rawlines[$linenr]) && $rawlines[$linenr] =~ /^\\s*[0-9a-f]{5,}\\b/i)) ||\n\t\t     ($line =~ /(?:\\s|^)[0-9a-f]{12,40}(?:[\\s\"'\\(\\[]|$)/i &&\n\t\t      $line !~ /[\\<\\[][0-9a-f]{12,40}[\\>\\]]/i &&\n\t\t      $line !~ /\\bfixes:\\s*[0-9a-f]{12,40}/i))) {\n\t\t\tmy $init_char = \"c\";\n\t\t\tmy $orig_commit = \"\";\n\t\t\tmy $short = 1;\n\t\t\tmy $long = 0;\n\t\t\tmy $case = 1;\n\t\t\tmy $space = 1;\n\t\t\tmy $id = '0123456789ab';\n\t\t\tmy $orig_desc = \"commit description\";\n\t\t\tmy $description = \"\";\n\t\t\tmy $herectx = $herecurr;\n\t\t\tmy $has_parens = 0;\n\t\t\tmy $has_quotes = 0;\n\n\t\t\tmy $input = $line;\n\t\t\tif ($line =~ /(?:\\bcommit\\s+[0-9a-f]{5,}|\\bcommit\\s*$)/i) {\n\t\t\t\tfor (my $n = 0; $n < 2; $n++) {\n\t\t\t\t\tif ($input =~ /\\bcommit\\s+[0-9a-f]{5,}\\s*($balanced_parens)/i) {\n\t\t\t\t\t\t$orig_desc = $1;\n\t\t\t\t\t\t$has_parens = 1;\n\t\t\t\t\t\t# Always strip leading/trailing parens then double quotes if existing\n\t\t\t\t\t\t$orig_desc = substr($orig_desc, 1, -1);\n\t\t\t\t\t\tif ($orig_desc =~ /^\".*\"$/) {\n\t\t\t\t\t\t\t$orig_desc = substr($orig_desc, 1, -1);\n\t\t\t\t\t\t\t$has_quotes = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t\tlast if ($#lines < $linenr + $n);\n\t\t\t\t\t$input .= \" \" . trim($rawlines[$linenr + $n]);\n\t\t\t\t\t$herectx .= \"$rawlines[$linenr + $n]\\n\";\n\t\t\t\t}\n\t\t\t\t$herectx = $herecurr if (!$has_parens);\n\t\t\t}\n\n\t\t\tif ($input =~ /\\b(c)ommit\\s+([0-9a-f]{5,})\\b/i) {\n\t\t\t\t$init_char = $1;\n\t\t\t\t$orig_commit = lc($2);\n\t\t\t\t$short = 0 if ($input =~ /\\bcommit\\s+[0-9a-f]{12,40}/i);\n\t\t\t\t$long = 1 if ($input =~ /\\bcommit\\s+[0-9a-f]{41,}/i);\n\t\t\t\t$space = 0 if ($input =~ /\\bcommit [0-9a-f]/i);\n\t\t\t\t$case = 0 if ($input =~ /\\b[Cc]ommit\\s+[0-9a-f]{5,40}[^A-F]/);\n\t\t\t} elsif ($input =~ /\\b([0-9a-f]{12,40})\\b/i) {\n\t\t\t\t$orig_commit = lc($1);\n\t\t\t}\n\n\t\t\t($id, $description) = git_commit_info($orig_commit,\n\t\t\t\t\t\t\t      $id, $orig_desc);\n\n\t\t\tif (defined($id) &&\n\t\t\t    ($short || $long || $space || $case || ($orig_desc ne $description) || !$has_quotes) &&\n\t\t\t    $last_git_commit_id_linenr != $linenr - 1) {\n\t\t\t\tERROR(\"GIT_COMMIT_ID\",\n\t\t\t\t      \"Please use git commit description style 'commit <12+ chars of sha1> (\\\"<title line>\\\")' - ie: '${init_char}ommit $id (\\\"$description\\\")'\\n\" . $herectx);\n\t\t\t}\n\t\t\t#don't report the next line if this line ends in commit and the sha1 hash is the next line\n\t\t\t$last_git_commit_id_linenr = $linenr if ($line =~ /\\bcommit\\s*$/i);\n\t\t}\n\n# Check for mailing list archives other than lore.kernel.org\n\t\tif ($rawline =~ m{http.*\\b$obsolete_archives}) {\n\t\t\tWARN(\"PREFER_LORE_ARCHIVE\",\n\t\t\t     \"Use lore.kernel.org archive links when possible - see https://lore.kernel.org/lists.html\\n\" . $herecurr);\n\t\t}\n\n# Check for added, moved or deleted files\n\t\tif (!$reported_maintainer_file && !$in_commit_log &&\n\t\t    ($line =~ /^(?:new|deleted) file mode\\s*\\d+\\s*$/ ||\n\t\t     $line =~ /^rename (?:from|to) [\\w\\/\\.\\-]+\\s*$/ ||\n\t\t     ($line =~ /\\{\\s*([\\w\\/\\.\\-]*)\\s*\\=\\>\\s*([\\w\\/\\.\\-]*)\\s*\\}/ &&\n\t\t      (defined($1) || defined($2))))) {\n\t\t\t$is_patch = 1;\n\t\t\t$reported_maintainer_file = 1;\n\t\t\tWARN(\"FILE_PATH_CHANGES\",\n\t\t\t     \"added, moved or deleted file(s), does MAINTAINERS need updating?\\n\" . $herecurr);\n\t\t}\n\n# Check for adding new DT bindings not in schema format\n\t\tif (!$in_commit_log &&\n\t\t    ($line =~ /^new file mode\\s*\\d+\\s*$/) &&\n\t\t    ($realfile =~ m@^Documentation/devicetree/bindings/.*\\.txt$@)) {\n\t\t\tWARN(\"DT_SCHEMA_BINDING_PATCH\",\n\t\t\t     \"DT bindings should be in DT schema format. See: Documentation/devicetree/bindings/writing-schema.rst\\n\");\n\t\t}\n\n# Check for wrappage within a valid hunk of the file\n\t\tif ($realcnt != 0 && $line !~ m{^(?:\\+|-| |\\\\ No newline|$)}) {\n\t\t\tERROR(\"CORRUPTED_PATCH\",\n\t\t\t      \"patch seems to be corrupt (line wrapped?)\\n\" .\n\t\t\t\t$herecurr) if (!$emitted_corrupt++);\n\t\t}\n\n# UTF-8 regex found at http://www.w3.org/International/questions/qa-forms-utf-8.en.php\n\t\tif (($realfile =~ /^$/ || $line =~ /^\\+/) &&\n\t\t    $rawline !~ m/^$UTF8*$/) {\n\t\t\tmy ($utf8_prefix) = ($rawline =~ /^($UTF8*)/);\n\n\t\t\tmy $blank = copy_spacing($rawline);\n\t\t\tmy $ptr = substr($blank, 0, length($utf8_prefix)) . \"^\";\n\t\t\tmy $hereptr = \"$hereline$ptr\\n\";\n\n\t\t\tCHK(\"INVALID_UTF8\",\n\t\t\t    \"Invalid UTF-8, patch and commit message should be encoded in UTF-8\\n\" . $hereptr);\n\t\t}\n\n# Check if it's the start of a commit log\n# (not a header line and we haven't seen the patch filename)\n\t\tif ($in_header_lines && $realfile =~ /^$/ &&\n\t\t    !($rawline =~ /^\\s+(?:\\S|$)/ ||\n\t\t      $rawline =~ /^(?:commit\\b|from\\b|[\\w-]+:)/i)) {\n\t\t\t$in_header_lines = 0;\n\t\t\t$in_commit_log = 1;\n\t\t\t$has_commit_log = 1;\n\t\t}\n\n# Check if there is UTF-8 in a commit log when a mail header has explicitly\n# declined it, i.e defined some charset where it is missing.\n\t\tif ($in_header_lines &&\n\t\t    $rawline =~ /^Content-Type:.+charset=\"(.+)\".*$/ &&\n\t\t    $1 !~ /utf-8/i) {\n\t\t\t$non_utf8_charset = 1;\n\t\t}\n\n\t\tif ($in_commit_log && $non_utf8_charset && $realfile =~ /^$/ &&\n\t\t    $rawline =~ /$NON_ASCII_UTF8/) {\n\t\t\tWARN(\"UTF8_BEFORE_PATCH\",\n\t\t\t    \"8-bit UTF-8 used in possible commit log\\n\" . $herecurr);\n\t\t}\n\n# Check for absolute kernel paths in commit message\n\t\tif ($tree && $in_commit_log) {\n\t\t\twhile ($line =~ m{(?:^|\\s)(/\\S*)}g) {\n\t\t\t\tmy $file = $1;\n\n\t\t\t\tif ($file =~ m{^(.*?)(?::\\d+)+:?$} &&\n\t\t\t\t    check_absolute_file($1, $herecurr)) {\n\t\t\t\t\t#\n\t\t\t\t} else {\n\t\t\t\t\tcheck_absolute_file($file, $herecurr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# Check for various typo / spelling mistakes\n\t\tif (defined($misspellings) &&\n\t\t    ($in_commit_log || $line =~ /^(?:\\+|Subject:)/i)) {\n\t\t\twhile ($rawline =~ /(?:^|[^\\w\\-'`])($misspellings)(?:[^\\w\\-'`]|$)/gi) {\n\t\t\t\tmy $typo = $1;\n\t\t\t\tmy $blank = copy_spacing($rawline);\n\t\t\t\tmy $ptr = substr($blank, 0, $-[1]) . \"^\" x length($typo);\n\t\t\t\tmy $hereptr = \"$hereline$ptr\\n\";\n\t\t\t\tmy $typo_fix = $spelling_fix{lc($typo)};\n\t\t\t\t$typo_fix = ucfirst($typo_fix) if ($typo =~ /^[A-Z]/);\n\t\t\t\t$typo_fix = uc($typo_fix) if ($typo =~ /^[A-Z]+$/);\n\t\t\t\tmy $msg_level = \\&WARN;\n\t\t\t\t$msg_level = \\&CHK if ($file);\n\t\t\t\tif (&{$msg_level}(\"TYPO_SPELLING\",\n\t\t\t\t\t\t  \"'$typo' may be misspelled - perhaps '$typo_fix'?\\n\" . $hereptr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/(^|[^A-Za-z@])($typo)($|[^A-Za-z@])/$1$typo_fix$3/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for invalid commit id\n\t\tif ($in_commit_log && $line =~ /(^fixes:|\\bcommit)\\s+([0-9a-f]{6,40})\\b/i) {\n\t\t\tmy $id;\n\t\t\tmy $description;\n\t\t\t($id, $description) = git_commit_info($2, undef, undef);\n\t\t\tif (!defined($id)) {\n\t\t\t\tWARN(\"UNKNOWN_COMMIT_ID\",\n\t\t\t\t     \"Unknown commit id '$2', maybe rebased or not pulled?\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for repeated words separated by a single space\n# avoid false positive from list command eg, '-rw-r--r-- 1 root root'\n\t\tif (($rawline =~ /^\\+/ || $in_commit_log) &&\n\t\t    $rawline !~ /[bcCdDlMnpPs\\?-][rwxsStT-]{9}/) {\n\t\t\tpos($rawline) = 1 if (!$in_commit_log);\n\t\t\twhile ($rawline =~ /\\b($word_pattern) (?=($word_pattern))/g) {\n\n\t\t\t\tmy $first = $1;\n\t\t\t\tmy $second = $2;\n\t\t\t\tmy $start_pos = $-[1];\n\t\t\t\tmy $end_pos = $+[2];\n\t\t\t\tif ($first =~ /(?:struct|union|enum)/) {\n\t\t\t\t\tpos($rawline) += length($first) + length($second) + 1;\n\t\t\t\t\tnext;\n\t\t\t\t}\n\n\t\t\t\tnext if (lc($first) ne lc($second));\n\t\t\t\tnext if ($first eq 'long');\n\n\t\t\t\t# check for character before and after the word matches\n\t\t\t\tmy $start_char = '';\n\t\t\t\tmy $end_char = '';\n\t\t\t\t$start_char = substr($rawline, $start_pos - 1, 1) if ($start_pos > ($in_commit_log ? 0 : 1));\n\t\t\t\t$end_char = substr($rawline, $end_pos, 1) if ($end_pos < length($rawline));\n\n\t\t\t\tnext if ($start_char =~ /^\\S$/);\n\t\t\t\tnext if (index(\" \\t.,;?!\", $end_char) == -1);\n\n\t\t\t\t# avoid repeating hex occurrences like 'ff ff fe 09 ...'\n\t\t\t\tif ($first =~ /\\b[0-9a-f]{2,}\\b/i) {\n\t\t\t\t\tnext if (!exists($allow_repeated_words{lc($first)}));\n\t\t\t\t}\n\n\t\t\t\tif (WARN(\"REPEATED_WORD\",\n\t\t\t\t\t \"Possible repeated word: '$first'\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\b$first $second\\b/$first/;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t# if it's a repeated word on consecutive lines in a comment block\n\t\t\tif ($prevline =~ /$;+\\s*$/ &&\n\t\t\t    $prevrawline =~ /($word_pattern)\\s*$/) {\n\t\t\t\tmy $last_word = $1;\n\t\t\t\tif ($rawline =~ /^\\+\\s*\\*\\s*$last_word /) {\n\t\t\t\t\tif (WARN(\"REPEATED_WORD\",\n\t\t\t\t\t\t \"Possible repeated word: '$last_word'\\n\" . $hereprev) &&\n\t\t\t\t\t    $fix) {\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/(\\+\\s*\\*\\s*)$last_word /$1/;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# ignore non-hunk lines and lines being removed\n\t\tnext if (!$hunk_line || $line =~ /^-/);\n\n#trailing whitespace\n\t\tif ($line =~ /^\\+.*\\015/) {\n\t\t\tmy $herevet = \"$here\\n\" . cat_vet($rawline) . \"\\n\";\n\t\t\tif (ERROR(\"DOS_LINE_ENDINGS\",\n\t\t\t\t  \"DOS line endings\\n\" . $herevet) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/[\\s\\015]+$//;\n\t\t\t}\n\t\t} elsif ($rawline =~ /^\\+.*\\S\\s+$/ || $rawline =~ /^\\+\\s+$/) {\n\t\t\tmy $herevet = \"$here\\n\" . cat_vet($rawline) . \"\\n\";\n\t\t\tif (ERROR(\"TRAILING_WHITESPACE\",\n\t\t\t\t  \"trailing whitespace\\n\" . $herevet) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\s+$//;\n\t\t\t}\n\n\t\t\t$rpt_cleaners = 1;\n\t\t}\n\n# Check for FSF mailing addresses.\n\t\tif ($rawline =~ /\\bwrite to the Free/i ||\n\t\t    $rawline =~ /\\b675\\s+Mass\\s+Ave/i ||\n\t\t    $rawline =~ /\\b59\\s+Temple\\s+Pl/i ||\n\t\t    $rawline =~ /\\b51\\s+Franklin\\s+St/i) {\n\t\t\tmy $herevet = \"$here\\n\" . cat_vet($rawline) . \"\\n\";\n\t\t\tmy $msg_level = \\&ERROR;\n\t\t\t$msg_level = \\&CHK if ($file);\n\t\t\t&{$msg_level}(\"FSF_MAILING_ADDRESS\",\n\t\t\t\t      \"Do not include the paragraph about writing to the Free Software Foundation's mailing address from the sample GPL notice. The FSF has changed addresses in the past, and may do so again. Linux already includes a copy of the GPL.\\n\" . $herevet)\n\t\t}\n\n# check for Kconfig help text having a real description\n# Only applies when adding the entry originally, after that we do not have\n# sufficient context to determine whether it is indeed long enough.\n\t\tif ($realfile =~ /Kconfig/ &&\n\t\t    # 'choice' is usually the last thing on the line (though\n\t\t    # Kconfig supports named choices), so use a word boundary\n\t\t    # (\\b) rather than a whitespace character (\\s)\n\t\t    $line =~ /^\\+\\s*(?:config|menuconfig|choice)\\b/) {\n\t\t\tmy $ln = $linenr;\n\t\t\tmy $needs_help = 0;\n\t\t\tmy $has_help = 0;\n\t\t\tmy $help_length = 0;\n\t\t\twhile (defined $lines[$ln]) {\n\t\t\t\tmy $f = $lines[$ln++];\n\n\t\t\t\tnext if ($f =~ /^-/);\n\t\t\t\tlast if ($f !~ /^[\\+ ]/);\t# !patch context\n\n\t\t\t\tif ($f =~ /^\\+\\s*(?:bool|tristate|prompt)\\s*[\"']/) {\n\t\t\t\t\t$needs_help = 1;\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\tif ($f =~ /^\\+\\s*help\\s*$/) {\n\t\t\t\t\t$has_help = 1;\n\t\t\t\t\tnext;\n\t\t\t\t}\n\n\t\t\t\t$f =~ s/^.//;\t# strip patch context [+ ]\n\t\t\t\t$f =~ s/#.*//;\t# strip # directives\n\t\t\t\t$f =~ s/^\\s+//;\t# strip leading blanks\n\t\t\t\tnext if ($f =~ /^$/);\t# skip blank lines\n\n\t\t\t\t# At the end of this Kconfig block:\n\t\t\t\t# This only checks context lines in the patch\n\t\t\t\t# and so hopefully shouldn't trigger false\n\t\t\t\t# positives, even though some of these are\n\t\t\t\t# common words in help texts\n\t\t\t\tif ($f =~ /^(?:config|menuconfig|choice|endchoice|\n\t\t\t\t\t       if|endif|menu|endmenu|source)\\b/x) {\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t\t$help_length++ if ($has_help);\n\t\t\t}\n\t\t\tif ($needs_help &&\n\t\t\t    $help_length < $min_conf_desc_length) {\n\t\t\t\tmy $stat_real = get_stat_real($linenr, $ln - 1);\n\t\t\t\tWARN(\"CONFIG_DESCRIPTION\",\n\t\t\t\t     \"please write a help paragraph that fully describes the config symbol\\n\" . \"$here\\n$stat_real\\n\");\n\t\t\t}\n\t\t}\n\n# check MAINTAINERS entries\n\t\tif ($realfile =~ /^MAINTAINERS$/) {\n# check MAINTAINERS entries for the right form\n\t\t\tif ($rawline =~ /^\\+[A-Z]:/ &&\n\t\t\t    $rawline !~ /^\\+[A-Z]:\\t\\S/) {\n\t\t\t\tif (WARN(\"MAINTAINERS_STYLE\",\n\t\t\t\t\t \"MAINTAINERS entries use one tab after TYPE:\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/^(\\+[A-Z]):\\s*/$1:\\t/;\n\t\t\t\t}\n\t\t\t}\n# check MAINTAINERS entries for the right ordering too\n\t\t\tmy $preferred_order = 'MRLSWQBCPTFXNK';\n\t\t\tif ($rawline =~ /^\\+[A-Z]:/ &&\n\t\t\t    $prevrawline =~ /^[\\+ ][A-Z]:/) {\n\t\t\t\t$rawline =~ /^\\+([A-Z]):\\s*(.*)/;\n\t\t\t\tmy $cur = $1;\n\t\t\t\tmy $curval = $2;\n\t\t\t\t$prevrawline =~ /^[\\+ ]([A-Z]):\\s*(.*)/;\n\t\t\t\tmy $prev = $1;\n\t\t\t\tmy $prevval = $2;\n\t\t\t\tmy $curindex = index($preferred_order, $cur);\n\t\t\t\tmy $previndex = index($preferred_order, $prev);\n\t\t\t\tif ($curindex < 0) {\n\t\t\t\t\tWARN(\"MAINTAINERS_STYLE\",\n\t\t\t\t\t     \"Unknown MAINTAINERS entry type: '$cur'\\n\" . $herecurr);\n\t\t\t\t} else {\n\t\t\t\t\tif ($previndex >= 0 && $curindex < $previndex) {\n\t\t\t\t\t\tWARN(\"MAINTAINERS_STYLE\",\n\t\t\t\t\t\t     \"Misordered MAINTAINERS entry - list '$cur:' before '$prev:'\\n\" . $hereprev);\n\t\t\t\t\t} elsif ((($prev eq 'F' && $cur eq 'F') ||\n\t\t\t\t\t\t  ($prev eq 'X' && $cur eq 'X')) &&\n\t\t\t\t\t\t ($prevval cmp $curval) > 0) {\n\t\t\t\t\t\tWARN(\"MAINTAINERS_STYLE\",\n\t\t\t\t\t\t     \"Misordered MAINTAINERS entry - list file patterns in alphabetic order\\n\" . $hereprev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (($realfile =~ /Makefile.*/ || $realfile =~ /Kbuild.*/) &&\n\t\t    ($line =~ /\\+(EXTRA_[A-Z]+FLAGS).*/)) {\n\t\t\tmy $flag = $1;\n\t\t\tmy $replacement = {\n\t\t\t\t'EXTRA_AFLAGS' =>   'asflags-y',\n\t\t\t\t'EXTRA_CFLAGS' =>   'ccflags-y',\n\t\t\t\t'EXTRA_CPPFLAGS' => 'cppflags-y',\n\t\t\t\t'EXTRA_LDFLAGS' =>  'ldflags-y',\n\t\t\t};\n\n\t\t\tWARN(\"DEPRECATED_VARIABLE\",\n\t\t\t     \"Use of $flag is deprecated, please use \\`$replacement->{$flag} instead.\\n\" . $herecurr) if ($replacement->{$flag});\n\t\t}\n\n# check for DT compatible documentation\n\t\tif (defined $root &&\n\t\t\t(($realfile =~ /\\.dtsi?$/ && $line =~ /^\\+\\s*compatible\\s*=\\s*\\\"/) ||\n\t\t\t ($realfile =~ /\\.[ch]$/ && $line =~ /^\\+.*\\.compatible\\s*=\\s*\\\"/))) {\n\n\t\t\tmy @compats = $rawline =~ /\\\"([a-zA-Z0-9\\-\\,\\.\\+_]+)\\\"/g;\n\n\t\t\tmy $dt_path = $root . \"/Documentation/devicetree/bindings/\";\n\t\t\tmy $vp_file = $dt_path . \"vendor-prefixes.yaml\";\n\n\t\t\tforeach my $compat (@compats) {\n\t\t\t\tmy $compat2 = $compat;\n\t\t\t\t$compat2 =~ s/\\,[a-zA-Z0-9]*\\-/\\,<\\.\\*>\\-/;\n\t\t\t\tmy $compat3 = $compat;\n\t\t\t\t$compat3 =~ s/\\,([a-z]*)[0-9]*\\-/\\,$1<\\.\\*>\\-/;\n\t\t\t\t`grep -Erq \"$compat|$compat2|$compat3\" $dt_path`;\n\t\t\t\tif ( $? >> 8 ) {\n\t\t\t\t\tWARN(\"UNDOCUMENTED_DT_STRING\",\n\t\t\t\t\t     \"DT compatible string \\\"$compat\\\" appears un-documented -- check $dt_path\\n\" . $herecurr);\n\t\t\t\t}\n\n\t\t\t\tnext if $compat !~ /^([a-zA-Z0-9\\-]+)\\,/;\n\t\t\t\tmy $vendor = $1;\n\t\t\t\t`grep -Eq \"\\\\\"\\\\^\\Q$vendor\\E,\\\\.\\\\*\\\\\":\" $vp_file`;\n\t\t\t\tif ( $? >> 8 ) {\n\t\t\t\t\tWARN(\"UNDOCUMENTED_DT_STRING\",\n\t\t\t\t\t     \"DT compatible string vendor \\\"$vendor\\\" appears un-documented -- check $vp_file\\n\" . $herecurr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for using SPDX license tag at beginning of files\n\t\tif ($realline == $checklicenseline) {\n\t\t\tif ($rawline =~ /^[ \\+]\\s*\\#\\!\\s*\\//) {\n\t\t\t\t$checklicenseline = 2;\n\t\t\t} elsif ($rawline =~ /^\\+/) {\n\t\t\t\tmy $comment = \"\";\n\t\t\t\tif ($realfile =~ /\\.(h|s|S)$/) {\n\t\t\t\t\t$comment = '/*';\n\t\t\t\t} elsif ($realfile =~ /\\.(c|rs|dts|dtsi)$/) {\n\t\t\t\t\t$comment = '//';\n\t\t\t\t} elsif (($checklicenseline == 2) || $realfile =~ /\\.(sh|pl|py|awk|tc|yaml)$/) {\n\t\t\t\t\t$comment = '#';\n\t\t\t\t} elsif ($realfile =~ /\\.rst$/) {\n\t\t\t\t\t$comment = '..';\n\t\t\t\t}\n\n# check SPDX comment style for .[chsS] files\n\t\t\t\tif ($realfile =~ /\\.[chsS]$/ &&\n\t\t\t\t    $rawline =~ /SPDX-License-Identifier:/ &&\n\t\t\t\t    $rawline !~ m@^\\+\\s*\\Q$comment\\E\\s*@) {\n\t\t\t\t\tWARN(\"SPDX_LICENSE_TAG\",\n\t\t\t\t\t     \"Improper SPDX comment style for '$realfile', please use '$comment' instead\\n\" . $herecurr);\n\t\t\t\t}\n\n\t\t\t\tif ($comment !~ /^$/ &&\n\t\t\t\t    $rawline !~ m@^\\+\\Q$comment\\E SPDX-License-Identifier: @) {\n\t\t\t\t\tWARN(\"SPDX_LICENSE_TAG\",\n\t\t\t\t\t     \"Missing or malformed SPDX-License-Identifier tag in line $checklicenseline\\n\" . $herecurr);\n\t\t\t\t} elsif ($rawline =~ /(SPDX-License-Identifier: .*)/) {\n\t\t\t\t\tmy $spdx_license = $1;\n\t\t\t\t\tif (!is_SPDX_License_valid($spdx_license)) {\n\t\t\t\t\t\tWARN(\"SPDX_LICENSE_TAG\",\n\t\t\t\t\t\t     \"'$spdx_license' is not supported in LICENSES/...\\n\" . $herecurr);\n\t\t\t\t\t}\n\t\t\t\t\tif ($realfile =~ m@^Documentation/devicetree/bindings/@ &&\n\t\t\t\t\t    $spdx_license !~ /GPL-2\\.0(?:-only)? OR BSD-2-Clause/) {\n\t\t\t\t\t\tmy $msg_level = \\&WARN;\n\t\t\t\t\t\t$msg_level = \\&CHK if ($file);\n\t\t\t\t\t\tif (&{$msg_level}(\"SPDX_LICENSE_TAG\",\n\n\t\t\t\t\t\t\t\t  \"DT binding documents should be licensed (GPL-2.0-only OR BSD-2-Clause)\\n\" . $herecurr) &&\n\t\t\t\t\t\t    $fix) {\n\t\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/SPDX-License-Identifier: .*/SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)/;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($realfile =~ m@^include/dt-bindings/@ &&\n\t\t\t\t\t    $spdx_license !~ /GPL-2\\.0(?:-only)? OR \\S+/) {\n\t\t\t\t\t\tWARN(\"SPDX_LICENSE_TAG\",\n\t\t\t\t\t\t     \"DT binding headers should be licensed (GPL-2.0-only OR .*)\\n\" . $herecurr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for embedded filenames\n\t\tif ($rawline =~ /^\\+.*\\b\\Q$realfile\\E\\b/) {\n\t\t\tWARN(\"EMBEDDED_FILENAME\",\n\t\t\t     \"It's generally not useful to have the filename in the file\\n\" . $herecurr);\n\t\t}\n\n# check we are in a valid source file if not then ignore this hunk\n\t\tnext if ($realfile !~ /\\.(h|c|rs|s|S|sh|dtsi|dts)$/);\n\n# check for using SPDX-License-Identifier on the wrong line number\n\t\tif ($realline != $checklicenseline &&\n\t\t    $rawline =~ /\\bSPDX-License-Identifier:/ &&\n\t\t    substr($line, @-, @+ - @-) eq \"$;\" x (@+ - @-)) {\n\t\t\tWARN(\"SPDX_LICENSE_TAG\",\n\t\t\t     \"Misplaced SPDX-License-Identifier tag - use line $checklicenseline instead\\n\" . $herecurr);\n\t\t}\n\n# line length limit (with some exclusions)\n#\n# There are a few types of lines that may extend beyond $max_line_length:\n#\tlogging functions like pr_info that end in a string\n#\tlines with a single string\n#\t#defines that are a single string\n#\tlines with an RFC3986 like URL\n#\n# There are 3 different line length message types:\n# LONG_LINE_COMMENT\ta comment starts before but extends beyond $max_line_length\n# LONG_LINE_STRING\ta string starts before but extends beyond $max_line_length\n# LONG_LINE\t\tall other lines longer than $max_line_length\n#\n# if LONG_LINE is ignored, the other 2 types are also ignored\n#\n\n\t\tif ($line =~ /^\\+/ && $length > $max_line_length) {\n\t\t\tmy $msg_type = \"LONG_LINE\";\n\n\t\t\t# Check the allowed long line types first\n\n\t\t\t# logging functions that end in a string that starts\n\t\t\t# before $max_line_length\n\t\t\tif ($line =~ /^\\+\\s*$logFunctions\\s*\\(\\s*(?:(?:KERN_\\S+\\s*|[^\"]*))?($String\\s*(?:|,|\\)\\s*;)\\s*)$/ &&\n\t\t\t    length(expand_tabs(substr($line, 1, length($line) - length($1) - 1))) <= $max_line_length) {\n\t\t\t\t$msg_type = \"\";\n\n\t\t\t# lines with only strings (w/ possible termination)\n\t\t\t# #defines with only strings\n\t\t\t} elsif ($line =~ /^\\+\\s*$String\\s*(?:\\s*|,|\\)\\s*;)\\s*$/ ||\n\t\t\t\t $line =~ /^\\+\\s*#\\s*define\\s+\\w+\\s+$String$/) {\n\t\t\t\t$msg_type = \"\";\n\n\t\t\t# More special cases\n\t\t\t} elsif ($line =~ /^\\+.*\\bEFI_GUID\\s*\\(/ ||\n\t\t\t\t $line =~ /^\\+\\s*(?:\\w+)?\\s*DEFINE_PER_CPU/) {\n\t\t\t\t$msg_type = \"\";\n\n\t\t\t# URL ($rawline is used in case the URL is in a comment)\n\t\t\t} elsif ($rawline =~ /^\\+.*\\b[a-z][\\w\\.\\+\\-]*:\\/\\/\\S+/i) {\n\t\t\t\t$msg_type = \"\";\n\n\t\t\t# Otherwise set the alternate message types\n\n\t\t\t# a comment starts before $max_line_length\n\t\t\t} elsif ($line =~ /($;[\\s$;]*)$/ &&\n\t\t\t\t length(expand_tabs(substr($line, 1, length($line) - length($1) - 1))) <= $max_line_length) {\n\t\t\t\t$msg_type = \"LONG_LINE_COMMENT\"\n\n\t\t\t# a quoted string starts before $max_line_length\n\t\t\t} elsif ($sline =~ /\\s*($String(?:\\s*(?:\\\\|,\\s*|\\)\\s*;\\s*))?)$/ &&\n\t\t\t\t length(expand_tabs(substr($line, 1, length($line) - length($1) - 1))) <= $max_line_length) {\n\t\t\t\t$msg_type = \"LONG_LINE_STRING\"\n\t\t\t}\n\n\t\t\tif ($msg_type ne \"\" &&\n\t\t\t    show_type(\"LONG_LINE\") && show_type($msg_type)) {\n\t\t\t\tmy $msg_level = \\&WARN;\n\t\t\t\t$msg_level = \\&CHK if ($file);\n\t\t\t\t&{$msg_level}($msg_type,\n\t\t\t\t\t      \"line length of $length exceeds $max_line_length columns\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for adding lines without a newline.\n\t\tif ($line =~ /^\\+/ && defined $lines[$linenr] && $lines[$linenr] =~ /^\\\\ No newline at end of file/) {\n\t\t\tif (WARN(\"MISSING_EOF_NEWLINE\",\n\t\t\t         \"adding a line without newline at end of file\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tfix_delete_line($fixlinenr+1, \"No newline at end of file\");\n\t\t\t}\n\t\t}\n\n# check for .L prefix local symbols in .S files\n\t\tif ($realfile =~ /\\.S$/ &&\n\t\t    $line =~ /^\\+\\s*(?:[A-Z]+_)?SYM_[A-Z]+_(?:START|END)(?:_[A-Z_]+)?\\s*\\(\\s*\\.L/) {\n\t\t\tWARN(\"AVOID_L_PREFIX\",\n\t\t\t     \"Avoid using '.L' prefixed local symbol names for denoting a range of code via 'SYM_*_START/END' annotations; see Documentation/core-api/asm-annotations.rst\\n\" . $herecurr);\n\t\t}\n\n# check we are in a valid source file C or perl if not then ignore this hunk\n\t\tnext if ($realfile !~ /\\.(h|c|pl|dtsi|dts)$/);\n\n# at the beginning of a line any tabs must come first and anything\n# more than $tabsize must use tabs.\n\t\tif ($rawline =~ /^\\+\\s* \\t\\s*\\S/ ||\n\t\t    $rawline =~ /^\\+\\s*        \\s*/) {\n\t\t\tmy $herevet = \"$here\\n\" . cat_vet($rawline) . \"\\n\";\n\t\t\t$rpt_cleaners = 1;\n\t\t\tif (ERROR(\"CODE_INDENT\",\n\t\t\t\t  \"code indent should use tabs where possible\\n\" . $herevet) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/^\\+([ \\t]+)/\"\\+\" . tabify($1)/e;\n\t\t\t}\n\t\t}\n\n# check for space before tabs.\n\t\tif ($rawline =~ /^\\+/ && $rawline =~ / \\t/) {\n\t\t\tmy $herevet = \"$here\\n\" . cat_vet($rawline) . \"\\n\";\n\t\t\tif (WARN(\"SPACE_BEFORE_TAB\",\n\t\t\t\t\"please, no space before tabs\\n\" . $herevet) &&\n\t\t\t    $fix) {\n\t\t\t\twhile ($fixed[$fixlinenr] =~\n\t\t\t\t\t   s/(^\\+.*) {$tabsize,$tabsize}\\t/$1\\t\\t/) {}\n\t\t\t\twhile ($fixed[$fixlinenr] =~\n\t\t\t\t\t   s/(^\\+.*) +\\t/$1\\t/) {}\n\t\t\t}\n\t\t}\n\n# check for assignments on the start of a line\n\t\tif ($sline =~ /^\\+\\s+($Assignment)[^=]/) {\n\t\t\tmy $operator = $1;\n\t\t\tif (CHK(\"ASSIGNMENT_CONTINUATIONS\",\n\t\t\t\t\"Assignment operator '$1' should be on the previous line\\n\" . $hereprev) &&\n\t\t\t    $fix && $prevrawline =~ /^\\+/) {\n\t\t\t\t# add assignment operator to the previous line, remove from current line\n\t\t\t\t$fixed[$fixlinenr - 1] .= \" $operator\";\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$operator\\E\\s*//;\n\t\t\t}\n\t\t}\n\n# check for && or || at the start of a line\n\t\tif ($rawline =~ /^\\+\\s*(&&|\\|\\|)/) {\n\t\t\tmy $operator = $1;\n\t\t\tif (CHK(\"LOGICAL_CONTINUATIONS\",\n\t\t\t\t\"Logical continuations should be on the previous line\\n\" . $hereprev) &&\n\t\t\t    $fix && $prevrawline =~ /^\\+/) {\n\t\t\t\t# insert logical operator at last non-comment, non-whitepsace char on previous line\n\t\t\t\t$prevline =~ /[\\s$;]*$/;\n\t\t\t\tmy $line_end = substr($prevrawline, $-[0]);\n\t\t\t\t$fixed[$fixlinenr - 1] =~ s/\\Q$line_end\\E$/ $operator$line_end/;\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$operator\\E\\s*//;\n\t\t\t}\n\t\t}\n\n# check indentation starts on a tab stop\n\t\tif ($perl_version_ok &&\n\t\t    $sline =~ /^\\+\\t+( +)(?:$c90_Keywords\\b|\\{\\s*$|\\}\\s*(?:else\\b|while\\b|\\s*$)|$Declare\\s*$Ident\\s*[;=])/) {\n\t\t\tmy $indent = length($1);\n\t\t\tif ($indent % $tabsize) {\n\t\t\t\tif (WARN(\"TABSTOP\",\n\t\t\t\t\t \"Statements should start on a tabstop\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s@(^\\+\\t+) +@$1 . \"\\t\" x ($indent/$tabsize)@e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check multi-line statement indentation matches previous line\n\t\tif ($perl_version_ok &&\n\t\t    $prevline =~ /^\\+([ \\t]*)((?:$c90_Keywords(?:\\s+if)\\s*)|(?:$Declare\\s*)?(?:$Ident|\\(\\s*\\*\\s*$Ident\\s*\\))\\s*|(?:\\*\\s*)*$Lval\\s*=\\s*$Ident\\s*)\\(.*(\\&\\&|\\|\\||,)\\s*$/) {\n\t\t\t$prevline =~ /^\\+(\\t*)(.*)$/;\n\t\t\tmy $oldindent = $1;\n\t\t\tmy $rest = $2;\n\n\t\t\tmy $pos = pos_last_openparen($rest);\n\t\t\tif ($pos >= 0) {\n\t\t\t\t$line =~ /^(\\+| )([ \\t]*)/;\n\t\t\t\tmy $newindent = $2;\n\n\t\t\t\tmy $goodtabindent = $oldindent .\n\t\t\t\t\t\"\\t\" x ($pos / $tabsize) .\n\t\t\t\t\t\" \"  x ($pos % $tabsize);\n\t\t\t\tmy $goodspaceindent = $oldindent . \" \"  x $pos;\n\n\t\t\t\tif ($newindent ne $goodtabindent &&\n\t\t\t\t    $newindent ne $goodspaceindent) {\n\n\t\t\t\t\tif (CHK(\"PARENTHESIS_ALIGNMENT\",\n\t\t\t\t\t\t\"Alignment should match open parenthesis\\n\" . $hereprev) &&\n\t\t\t\t\t    $fix && $line =~ /^\\+/) {\n\t\t\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t\t\t    s/^\\+[ \\t]*/\\+$goodtabindent/;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for space after cast like \"(int) foo\" or \"(struct foo) bar\"\n# avoid checking a few false positives:\n#   \"sizeof(<type>)\" or \"__alignof__(<type>)\"\n#   function pointer declarations like \"(*foo)(int) = bar;\"\n#   structure definitions like \"(struct foo) { 0 };\"\n#   multiline macros that define functions\n#   known attributes or the __attribute__ keyword\n\t\tif ($line =~ /^\\+(.*)\\(\\s*$Type\\s*\\)([ \\t]++)((?![={]|\\\\$|$Attribute|__attribute__))/ &&\n\t\t    (!defined($1) || $1 !~ /\\b(?:sizeof|__alignof__)\\s*$/)) {\n\t\t\tif (CHK(\"SPACING\",\n\t\t\t\t\"No space is necessary after a cast\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/(\\(\\s*$Type\\s*\\))[ \\t]+/$1/;\n\t\t\t}\n\t\t}\n\n# Block comments use * on subsequent lines\n\t\tif ($prevline =~ /$;[ \\t]*$/ &&\t\t\t#ends in comment\n\t\t    $prevrawline =~ /^\\+.*?\\/\\*/ &&\t\t#starting /*\n\t\t    $prevrawline !~ /\\*\\/[ \\t]*$/ &&\t\t#no trailing */\n\t\t    $rawline =~ /^\\+/ &&\t\t\t#line is new\n\t\t    $rawline !~ /^\\+[ \\t]*\\*/) {\t\t#no leading *\n\t\t\tWARN(\"BLOCK_COMMENT_STYLE\",\n\t\t\t     \"Block comments use * on subsequent lines\\n\" . $hereprev);\n\t\t}\n\n# Block comments use */ on trailing lines\n\t\tif ($rawline !~ m@^\\+[ \\t]*\\*/[ \\t]*$@ &&\t#trailing */\n\t\t    $rawline !~ m@^\\+.*/\\*.*\\*/[ \\t]*$@ &&\t#inline /*...*/\n\t\t    $rawline !~ m@^\\+.*\\*{2,}/[ \\t]*$@ &&\t#trailing **/\n\t\t    $rawline =~ m@^\\+[ \\t]*.+\\*\\/[ \\t]*$@) {\t#non blank */\n\t\t\tWARN(\"BLOCK_COMMENT_STYLE\",\n\t\t\t     \"Block comments use a trailing */ on a separate line\\n\" . $herecurr);\n\t\t}\n\n# Block comment * alignment\n\t\tif ($prevline =~ /$;[ \\t]*$/ &&\t\t\t#ends in comment\n\t\t    $line =~ /^\\+[ \\t]*$;/ &&\t\t\t#leading comment\n\t\t    $rawline =~ /^\\+[ \\t]*\\*/ &&\t\t#leading *\n\t\t    (($prevrawline =~ /^\\+.*?\\/\\*/ &&\t\t#leading /*\n\t\t      $prevrawline !~ /\\*\\/[ \\t]*$/) ||\t\t#no trailing */\n\t\t     $prevrawline =~ /^\\+[ \\t]*\\*/)) {\t\t#leading *\n\t\t\tmy $oldindent;\n\t\t\t$prevrawline =~ m@^\\+([ \\t]*/?)\\*@;\n\t\t\tif (defined($1)) {\n\t\t\t\t$oldindent = expand_tabs($1);\n\t\t\t} else {\n\t\t\t\t$prevrawline =~ m@^\\+(.*/?)\\*@;\n\t\t\t\t$oldindent = expand_tabs($1);\n\t\t\t}\n\t\t\t$rawline =~ m@^\\+([ \\t]*)\\*@;\n\t\t\tmy $newindent = $1;\n\t\t\t$newindent = expand_tabs($newindent);\n\t\t\tif (length($oldindent) ne length($newindent)) {\n\t\t\t\tWARN(\"BLOCK_COMMENT_STYLE\",\n\t\t\t\t     \"Block comments should align the * on each line\\n\" . $hereprev);\n\t\t\t}\n\t\t}\n\n# check for missing blank lines after struct/union declarations\n# with exceptions for various attributes and macros\n\t\tif ($prevline =~ /^[\\+ ]};?\\s*$/ &&\n\t\t    $line =~ /^\\+/ &&\n\t\t    !($line =~ /^\\+\\s*$/ ||\n\t\t      $line =~ /^\\+\\s*(?:EXPORT_SYMBOL|early_param|ALLOW_ERROR_INJECTION)/ ||\n\t\t      $line =~ /^\\+\\s*MODULE_/i ||\n\t\t      $line =~ /^\\+\\s*\\#\\s*(?:end|elif|else)/ ||\n\t\t      $line =~ /^\\+[a-z_]*init/ ||\n\t\t      $line =~ /^\\+\\s*(?:static\\s+)?[A-Z_]*ATTR/ ||\n\t\t      $line =~ /^\\+\\s*DECLARE/ ||\n\t\t      $line =~ /^\\+\\s*builtin_[\\w_]*driver/ ||\n\t\t      $line =~ /^\\+\\s*__setup/)) {\n\t\t\tif (CHK(\"LINE_SPACING\",\n\t\t\t\t\"Please use a blank line after function/struct/union/enum declarations\\n\" . $hereprev) &&\n\t\t\t    $fix) {\n\t\t\t\tfix_insert_line($fixlinenr, \"\\+\");\n\t\t\t}\n\t\t}\n\n# check for multiple consecutive blank lines\n\t\tif ($prevline =~ /^[\\+ ]\\s*$/ &&\n\t\t    $line =~ /^\\+\\s*$/ &&\n\t\t    $last_blank_line != ($linenr - 1)) {\n\t\t\tif (CHK(\"LINE_SPACING\",\n\t\t\t\t\"Please don't use multiple blank lines\\n\" . $hereprev) &&\n\t\t\t    $fix) {\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t}\n\n\t\t\t$last_blank_line = $linenr;\n\t\t}\n\n# check for missing blank lines after declarations\n# (declarations must have the same indentation and not be at the start of line)\n\t\tif (($prevline =~ /\\+(\\s+)\\S/) && $sline =~ /^\\+$1\\S/) {\n\t\t\t# use temporaries\n\t\t\tmy $sl = $sline;\n\t\t\tmy $pl = $prevline;\n\t\t\t# remove $Attribute/$Sparse uses to simplify comparisons\n\t\t\t$sl =~ s/\\b(?:$Attribute|$Sparse)\\b//g;\n\t\t\t$pl =~ s/\\b(?:$Attribute|$Sparse)\\b//g;\n\t\t\tif (($pl =~ /^\\+\\s+$Declare\\s*$Ident\\s*[=,;:\\[]/ ||\n\t\t\t# function pointer declarations\n\t\t\t     $pl =~ /^\\+\\s+$Declare\\s*\\(\\s*\\*\\s*$Ident\\s*\\)\\s*[=,;:\\[\\(]/ ||\n\t\t\t# foo bar; where foo is some local typedef or #define\n\t\t\t     $pl =~ /^\\+\\s+$Ident(?:\\s+|\\s*\\*\\s*)$Ident\\s*[=,;\\[]/ ||\n\t\t\t# known declaration macros\n\t\t\t     $pl =~ /^\\+\\s+$declaration_macros/) &&\n\t\t\t# for \"else if\" which can look like \"$Ident $Ident\"\n\t\t\t    !($pl =~ /^\\+\\s+$c90_Keywords\\b/ ||\n\t\t\t# other possible extensions of declaration lines\n\t\t\t      $pl =~ /(?:$Compare|$Assignment|$Operators)\\s*$/ ||\n\t\t\t# not starting a section or a macro \"\\\" extended line\n\t\t\t      $pl =~ /(?:\\{\\s*|\\\\)$/) &&\n\t\t\t# looks like a declaration\n\t\t\t    !($sl =~ /^\\+\\s+$Declare\\s*$Ident\\s*[=,;:\\[]/ ||\n\t\t\t# function pointer declarations\n\t\t\t      $sl =~ /^\\+\\s+$Declare\\s*\\(\\s*\\*\\s*$Ident\\s*\\)\\s*[=,;:\\[\\(]/ ||\n\t\t\t# foo bar; where foo is some local typedef or #define\n\t\t\t      $sl =~ /^\\+\\s+$Ident(?:\\s+|\\s*\\*\\s*)$Ident\\s*[=,;\\[]/ ||\n\t\t\t# known declaration macros\n\t\t\t      $sl =~ /^\\+\\s+$declaration_macros/ ||\n\t\t\t# start of struct or union or enum\n\t\t\t      $sl =~ /^\\+\\s+(?:static\\s+)?(?:const\\s+)?(?:union|struct|enum|typedef)\\b/ ||\n\t\t\t# start or end of block or continuation of declaration\n\t\t\t      $sl =~ /^\\+\\s+(?:$|[\\{\\}\\.\\#\\\"\\?\\:\\(\\[])/ ||\n\t\t\t# bitfield continuation\n\t\t\t      $sl =~ /^\\+\\s+$Ident\\s*:\\s*\\d+\\s*[,;]/ ||\n\t\t\t# other possible extensions of declaration lines\n\t\t\t      $sl =~ /^\\+\\s+\\(?\\s*(?:$Compare|$Assignment|$Operators)/)) {\n\t\t\t\tif (WARN(\"LINE_SPACING\",\n\t\t\t\t\t \"Missing a blank line after declarations\\n\" . $hereprev) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\tfix_insert_line($fixlinenr, \"\\+\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for spaces at the beginning of a line.\n# Exceptions:\n#  1) within comments\n#  2) indented preprocessor commands\n#  3) hanging labels\n\t\tif ($rawline =~ /^\\+ / && $line !~ /^\\+ *(?:$;|#|$Ident:)/)  {\n\t\t\tmy $herevet = \"$here\\n\" . cat_vet($rawline) . \"\\n\";\n\t\t\tif (WARN(\"LEADING_SPACE\",\n\t\t\t\t \"please, no spaces at the start of a line\\n\" . $herevet) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/^\\+([ \\t]+)/\"\\+\" . tabify($1)/e;\n\t\t\t}\n\t\t}\n\n# check we are in a valid C source file if not then ignore this hunk\n\t\tnext if ($realfile !~ /\\.(h|c)$/);\n\n# check for unusual line ending [ or (\n\t\tif ($line =~ /^\\+.*([\\[\\(])\\s*$/) {\n\t\t\tCHK(\"OPEN_ENDED_LINE\",\n\t\t\t    \"Lines should not end with a '$1'\\n\" . $herecurr);\n\t\t}\n\n# check if this appears to be the start function declaration, save the name\n\t\tif ($sline =~ /^\\+\\{\\s*$/ &&\n\t\t    $prevline =~ /^\\+(?:(?:(?:$Storage|$Inline)\\s*)*\\s*$Type\\s*)?($Ident)\\(/) {\n\t\t\t$context_function = $1;\n\t\t}\n\n# check if this appears to be the end of function declaration\n\t\tif ($sline =~ /^\\+\\}\\s*$/) {\n\t\t\tundef $context_function;\n\t\t}\n\n# check indentation of any line with a bare else\n# (but not if it is a multiple line \"if (foo) return bar; else return baz;\")\n# if the previous line is a break or return and is indented 1 tab more...\n\t\tif ($sline =~ /^\\+([\\t]+)(?:}[ \\t]*)?else(?:[ \\t]*{)?\\s*$/) {\n\t\t\tmy $tabs = length($1) + 1;\n\t\t\tif ($prevline =~ /^\\+\\t{$tabs,$tabs}break\\b/ ||\n\t\t\t    ($prevline =~ /^\\+\\t{$tabs,$tabs}return\\b/ &&\n\t\t\t     defined $lines[$linenr] &&\n\t\t\t     $lines[$linenr] !~ /^[ \\+]\\t{$tabs,$tabs}return/)) {\n\t\t\t\tWARN(\"UNNECESSARY_ELSE\",\n\t\t\t\t     \"else is not generally useful after a break or return\\n\" . $hereprev);\n\t\t\t}\n\t\t}\n\n# check indentation of a line with a break;\n# if the previous line is a goto, return or break\n# and is indented the same # of tabs\n\t\tif ($sline =~ /^\\+([\\t]+)break\\s*;\\s*$/) {\n\t\t\tmy $tabs = $1;\n\t\t\tif ($prevline =~ /^\\+$tabs(goto|return|break)\\b/) {\n\t\t\t\tif (WARN(\"UNNECESSARY_BREAK\",\n\t\t\t\t\t \"break is not useful after a $1\\n\" . $hereprev) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for RCS/CVS revision markers\n\t\tif ($rawline =~ /^\\+.*\\$(Revision|Log|Id)(?:\\$|)/) {\n\t\t\tWARN(\"CVS_KEYWORD\",\n\t\t\t     \"CVS style keyword markers, these will _not_ be updated\\n\". $herecurr);\n\t\t}\n\n# check for old HOTPLUG __dev<foo> section markings\n\t\tif ($line =~ /\\b(__dev(init|exit)(data|const|))\\b/) {\n\t\t\tWARN(\"HOTPLUG_SECTION\",\n\t\t\t     \"Using $1 is unnecessary\\n\" . $herecurr);\n\t\t}\n\n# Check for potential 'bare' types\n\t\tmy ($stat, $cond, $line_nr_next, $remain_next, $off_next,\n\t\t    $realline_next);\n#print \"LINE<$line>\\n\";\n\t\tif ($linenr > $suppress_statement &&\n\t\t    $realcnt && $sline =~ /.\\s*\\S/) {\n\t\t\t($stat, $cond, $line_nr_next, $remain_next, $off_next) =\n\t\t\t\tctx_statement_block($linenr, $realcnt, 0);\n\t\t\t$stat =~ s/\\n./\\n /g;\n\t\t\t$cond =~ s/\\n./\\n /g;\n\n#print \"linenr<$linenr> <$stat>\\n\";\n\t\t\t# If this statement has no statement boundaries within\n\t\t\t# it there is no point in retrying a statement scan\n\t\t\t# until we hit end of it.\n\t\t\tmy $frag = $stat; $frag =~ s/;+\\s*$//;\n\t\t\tif ($frag !~ /(?:{|;)/) {\n#print \"skip<$line_nr_next>\\n\";\n\t\t\t\t$suppress_statement = $line_nr_next;\n\t\t\t}\n\n\t\t\t# Find the real next line.\n\t\t\t$realline_next = $line_nr_next;\n\t\t\tif (defined $realline_next &&\n\t\t\t    (!defined $lines[$realline_next - 1] ||\n\t\t\t     substr($lines[$realline_next - 1], $off_next) =~ /^\\s*$/)) {\n\t\t\t\t$realline_next++;\n\t\t\t}\n\n\t\t\tmy $s = $stat;\n\t\t\t$s =~ s/{.*$//s;\n\n\t\t\t# Ignore goto labels.\n\t\t\tif ($s =~ /$Ident:\\*$/s) {\n\n\t\t\t# Ignore functions being called\n\t\t\t} elsif ($s =~ /^.\\s*$Ident\\s*\\(/s) {\n\n\t\t\t} elsif ($s =~ /^.\\s*else\\b/s) {\n\n\t\t\t# declarations always start with types\n\t\t\t} elsif ($prev_values eq 'E' && $s =~ /^.\\s*(?:$Storage\\s+)?(?:$Inline\\s+)?(?:const\\s+)?((?:\\s*$Ident)+?)\\b(?:\\s+$Sparse)?\\s*\\**\\s*(?:$Ident|\\(\\*[^\\)]*\\))(?:\\s*$Modifier)?\\s*(?:;|=|,|\\()/s) {\n\t\t\t\tmy $type = $1;\n\t\t\t\t$type =~ s/\\s+/ /g;\n\t\t\t\tpossible($type, \"A:\" . $s);\n\n\t\t\t# definitions in global scope can only start with types\n\t\t\t} elsif ($s =~ /^.(?:$Storage\\s+)?(?:$Inline\\s+)?(?:const\\s+)?($Ident)\\b\\s*(?!:)/s) {\n\t\t\t\tpossible($1, \"B:\" . $s);\n\t\t\t}\n\n\t\t\t# any (foo ... *) is a pointer cast, and foo is a type\n\t\t\twhile ($s =~ /\\(($Ident)(?:\\s+$Sparse)*[\\s\\*]+\\s*\\)/sg) {\n\t\t\t\tpossible($1, \"C:\" . $s);\n\t\t\t}\n\n\t\t\t# Check for any sort of function declaration.\n\t\t\t# int foo(something bar, other baz);\n\t\t\t# void (*store_gdt)(x86_descr_ptr *);\n\t\t\tif ($prev_values eq 'E' && $s =~ /^(.(?:typedef\\s*)?(?:(?:$Storage|$Inline)\\s*)*\\s*$Type\\s*(?:\\b$Ident|\\(\\*\\s*$Ident\\))\\s*)\\(/s) {\n\t\t\t\tmy ($name_len) = length($1);\n\n\t\t\t\tmy $ctx = $s;\n\t\t\t\tsubstr($ctx, 0, $name_len + 1, '');\n\t\t\t\t$ctx =~ s/\\)[^\\)]*$//;\n\n\t\t\t\tfor my $arg (split(/\\s*,\\s*/, $ctx)) {\n\t\t\t\t\tif ($arg =~ /^(?:const\\s+)?($Ident)(?:\\s+$Sparse)*\\s*\\**\\s*(:?\\b$Ident)?$/s || $arg =~ /^($Ident)$/s) {\n\n\t\t\t\t\t\tpossible($1, \"D:\" . $s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n#\n# Checks which may be anchored in the context.\n#\n\n# Check for switch () and associated case and default\n# statements should be at the same indent.\n\t\tif ($line=~/\\bswitch\\s*\\(.*\\)/) {\n\t\t\tmy $err = '';\n\t\t\tmy $sep = '';\n\t\t\tmy @ctx = ctx_block_outer($linenr, $realcnt);\n\t\t\tshift(@ctx);\n\t\t\tfor my $ctx (@ctx) {\n\t\t\t\tmy ($clen, $cindent) = line_stats($ctx);\n\t\t\t\tif ($ctx =~ /^\\+\\s*(case\\s+|default:)/ &&\n\t\t\t\t\t\t\t$indent != $cindent) {\n\t\t\t\t\t$err .= \"$sep$ctx\\n\";\n\t\t\t\t\t$sep = '';\n\t\t\t\t} else {\n\t\t\t\t\t$sep = \"[...]\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($err ne '') {\n\t\t\t\tERROR(\"SWITCH_CASE_INDENT_LEVEL\",\n\t\t\t\t      \"switch and case should be at the same indent\\n$hereline$err\");\n\t\t\t}\n\t\t}\n\n# if/while/etc brace do not go on next line, unless defining a do while loop,\n# or if that brace on the next line is for something else\n\t\tif ($line =~ /(.*)\\b((?:if|while|for|switch|(?:[a-z_]+|)for_each[a-z_]+)\\s*\\(|do\\b|else\\b)/ && $line !~ /^.\\s*\\#/) {\n\t\t\tmy $pre_ctx = \"$1$2\";\n\n\t\t\tmy ($level, @ctx) = ctx_statement_level($linenr, $realcnt, 0);\n\n\t\t\tif ($line =~ /^\\+\\t{6,}/) {\n\t\t\t\tWARN(\"DEEP_INDENTATION\",\n\t\t\t\t     \"Too many leading tabs - consider code refactoring\\n\" . $herecurr);\n\t\t\t}\n\n\t\t\tmy $ctx_cnt = $realcnt - $#ctx - 1;\n\t\t\tmy $ctx = join(\"\\n\", @ctx);\n\n\t\t\tmy $ctx_ln = $linenr;\n\t\t\tmy $ctx_skip = $realcnt;\n\n\t\t\twhile ($ctx_skip > $ctx_cnt || ($ctx_skip == $ctx_cnt &&\n\t\t\t\t\tdefined $lines[$ctx_ln - 1] &&\n\t\t\t\t\t$lines[$ctx_ln - 1] =~ /^-/)) {\n\t\t\t\t##print \"SKIP<$ctx_skip> CNT<$ctx_cnt>\\n\";\n\t\t\t\t$ctx_skip-- if (!defined $lines[$ctx_ln - 1] || $lines[$ctx_ln - 1] !~ /^-/);\n\t\t\t\t$ctx_ln++;\n\t\t\t}\n\n\t\t\t#print \"realcnt<$realcnt> ctx_cnt<$ctx_cnt>\\n\";\n\t\t\t#print \"pre<$pre_ctx>\\nline<$line>\\nctx<$ctx>\\nnext<$lines[$ctx_ln - 1]>\\n\";\n\n\t\t\tif ($ctx !~ /{\\s*/ && defined($lines[$ctx_ln - 1]) && $lines[$ctx_ln - 1] =~ /^\\+\\s*{/) {\n\t\t\t\tERROR(\"OPEN_BRACE\",\n\t\t\t\t      \"that open brace { should be on the previous line\\n\" .\n\t\t\t\t\t\"$here\\n$ctx\\n$rawlines[$ctx_ln - 1]\\n\");\n\t\t\t}\n\t\t\tif ($level == 0 && $pre_ctx !~ /}\\s*while\\s*\\($/ &&\n\t\t\t    $ctx =~ /\\)\\s*\\;\\s*$/ &&\n\t\t\t    defined $lines[$ctx_ln - 1])\n\t\t\t{\n\t\t\t\tmy ($nlength, $nindent) = line_stats($lines[$ctx_ln - 1]);\n\t\t\t\tif ($nindent > $indent) {\n\t\t\t\t\tWARN(\"TRAILING_SEMICOLON\",\n\t\t\t\t\t     \"trailing semicolon indicates no statements, indent implies otherwise\\n\" .\n\t\t\t\t\t\t\"$here\\n$ctx\\n$rawlines[$ctx_ln - 1]\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# Check relative indent for conditionals and blocks.\n\t\tif ($line =~ /\\b(?:(?:if|while|for|(?:[a-z_]+|)for_each[a-z_]+)\\s*\\(|(?:do|else)\\b)/ && $line !~ /^.\\s*#/ && $line !~ /\\}\\s*while\\s*/) {\n\t\t\t($stat, $cond, $line_nr_next, $remain_next, $off_next) =\n\t\t\t\tctx_statement_block($linenr, $realcnt, 0)\n\t\t\t\t\tif (!defined $stat);\n\t\t\tmy ($s, $c) = ($stat, $cond);\n\n\t\t\tsubstr($s, 0, length($c), '');\n\n\t\t\t# remove inline comments\n\t\t\t$s =~ s/$;/ /g;\n\t\t\t$c =~ s/$;/ /g;\n\n\t\t\t# Find out how long the conditional actually is.\n\t\t\tmy @newlines = ($c =~ /\\n/gs);\n\t\t\tmy $cond_lines = 1 + $#newlines;\n\n\t\t\t# Make sure we remove the line prefixes as we have\n\t\t\t# none on the first line, and are going to readd them\n\t\t\t# where necessary.\n\t\t\t$s =~ s/\\n./\\n/gs;\n\t\t\twhile ($s =~ /\\n\\s+\\\\\\n/) {\n\t\t\t\t$cond_lines += $s =~ s/\\n\\s+\\\\\\n/\\n/g;\n\t\t\t}\n\n\t\t\t# We want to check the first line inside the block\n\t\t\t# starting at the end of the conditional, so remove:\n\t\t\t#  1) any blank line termination\n\t\t\t#  2) any opening brace { on end of the line\n\t\t\t#  3) any do (...) {\n\t\t\tmy $continuation = 0;\n\t\t\tmy $check = 0;\n\t\t\t$s =~ s/^.*\\bdo\\b//;\n\t\t\t$s =~ s/^\\s*{//;\n\t\t\tif ($s =~ s/^\\s*\\\\//) {\n\t\t\t\t$continuation = 1;\n\t\t\t}\n\t\t\tif ($s =~ s/^\\s*?\\n//) {\n\t\t\t\t$check = 1;\n\t\t\t\t$cond_lines++;\n\t\t\t}\n\n\t\t\t# Also ignore a loop construct at the end of a\n\t\t\t# preprocessor statement.\n\t\t\tif (($prevline =~ /^.\\s*#\\s*define\\s/ ||\n\t\t\t    $prevline =~ /\\\\\\s*$/) && $continuation == 0) {\n\t\t\t\t$check = 0;\n\t\t\t}\n\n\t\t\tmy $cond_ptr = -1;\n\t\t\t$continuation = 0;\n\t\t\twhile ($cond_ptr != $cond_lines) {\n\t\t\t\t$cond_ptr = $cond_lines;\n\n\t\t\t\t# If we see an #else/#elif then the code\n\t\t\t\t# is not linear.\n\t\t\t\tif ($s =~ /^\\s*\\#\\s*(?:else|elif)/) {\n\t\t\t\t\t$check = 0;\n\t\t\t\t}\n\n\t\t\t\t# Ignore:\n\t\t\t\t#  1) blank lines, they should be at 0,\n\t\t\t\t#  2) preprocessor lines, and\n\t\t\t\t#  3) labels.\n\t\t\t\tif ($continuation ||\n\t\t\t\t    $s =~ /^\\s*?\\n/ ||\n\t\t\t\t    $s =~ /^\\s*#\\s*?/ ||\n\t\t\t\t    $s =~ /^\\s*$Ident\\s*:/) {\n\t\t\t\t\t$continuation = ($s =~ /^.*?\\\\\\n/) ? 1 : 0;\n\t\t\t\t\tif ($s =~ s/^.*?\\n//) {\n\t\t\t\t\t\t$cond_lines++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmy (undef, $sindent) = line_stats(\"+\" . $s);\n\t\t\tmy $stat_real = raw_line($linenr, $cond_lines);\n\n\t\t\t# Check if either of these lines are modified, else\n\t\t\t# this is not this patch's fault.\n\t\t\tif (!defined($stat_real) ||\n\t\t\t    $stat !~ /^\\+/ && $stat_real !~ /^\\+/) {\n\t\t\t\t$check = 0;\n\t\t\t}\n\t\t\tif (defined($stat_real) && $cond_lines > 1) {\n\t\t\t\t$stat_real = \"[...]\\n$stat_real\";\n\t\t\t}\n\n\t\t\t#print \"line<$line> prevline<$prevline> indent<$indent> sindent<$sindent> check<$check> continuation<$continuation> s<$s> cond_lines<$cond_lines> stat_real<$stat_real> stat<$stat>\\n\";\n\n\t\t\tif ($check && $s ne '' &&\n\t\t\t    (($sindent % $tabsize) != 0 ||\n\t\t\t     ($sindent < $indent) ||\n\t\t\t     ($sindent == $indent &&\n\t\t\t      ($s !~ /^\\s*(?:\\}|\\{|else\\b)/)) ||\n\t\t\t     ($sindent > $indent + $tabsize))) {\n\t\t\t\tWARN(\"SUSPECT_CODE_INDENT\",\n\t\t\t\t     \"suspect code indent for conditional statements ($indent, $sindent)\\n\" . $herecurr . \"$stat_real\\n\");\n\t\t\t}\n\t\t}\n\n\t\t# Track the 'values' across context and added lines.\n\t\tmy $opline = $line; $opline =~ s/^./ /;\n\t\tmy ($curr_values, $curr_vars) =\n\t\t\t\tannotate_values($opline . \"\\n\", $prev_values);\n\t\t$curr_values = $prev_values . $curr_values;\n\t\tif ($dbg_values) {\n\t\t\tmy $outline = $opline; $outline =~ s/\\t/ /g;\n\t\t\tprint \"$linenr > .$outline\\n\";\n\t\t\tprint \"$linenr > $curr_values\\n\";\n\t\t\tprint \"$linenr >  $curr_vars\\n\";\n\t\t}\n\t\t$prev_values = substr($curr_values, -1);\n\n#ignore lines not being added\n\t\tnext if ($line =~ /^[^\\+]/);\n\n# check for self assignments used to avoid compiler warnings\n# e.g.:\tint foo = foo, *bar = NULL;\n#\tstruct foo bar = *(&(bar));\n\t\tif ($line =~ /^\\+\\s*(?:$Declare)?([A-Za-z_][A-Za-z\\d_]*)\\s*=/) {\n\t\t\tmy $var = $1;\n\t\t\tif ($line =~ /^\\+\\s*(?:$Declare)?$var\\s*=\\s*(?:$var|\\*\\s*\\(?\\s*&\\s*\\(?\\s*$var\\s*\\)?\\s*\\)?)\\s*[;,]/) {\n\t\t\t\tWARN(\"SELF_ASSIGNMENT\",\n\t\t\t\t     \"Do not use self-assignments to avoid compiler warnings\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for dereferences that span multiple lines\n\t\tif ($prevline =~ /^\\+.*$Lval\\s*(?:\\.|->)\\s*$/ &&\n\t\t    $line =~ /^\\+\\s*(?!\\#\\s*(?!define\\s+|if))\\s*$Lval/) {\n\t\t\t$prevline =~ /($Lval\\s*(?:\\.|->))\\s*$/;\n\t\t\tmy $ref = $1;\n\t\t\t$line =~ /^.\\s*($Lval)/;\n\t\t\t$ref .= $1;\n\t\t\t$ref =~ s/\\s//g;\n\t\t\tWARN(\"MULTILINE_DEREFERENCE\",\n\t\t\t     \"Avoid multiple line dereference - prefer '$ref'\\n\" . $hereprev);\n\t\t}\n\n# check for declarations of signed or unsigned without int\n\t\twhile ($line =~ m{\\b($Declare)\\s*(?!char\\b|short\\b|int\\b|long\\b)\\s*($Ident)?\\s*[=,;\\[\\)\\(]}g) {\n\t\t\tmy $type = $1;\n\t\t\tmy $var = $2;\n\t\t\t$var = \"\" if (!defined $var);\n\t\t\tif ($type =~ /^(?:(?:$Storage|$Inline|$Attribute)\\s+)*((?:un)?signed)((?:\\s*\\*)*)\\s*$/) {\n\t\t\t\tmy $sign = $1;\n\t\t\t\tmy $pointer = $2;\n\n\t\t\t\t$pointer = \"\" if (!defined $pointer);\n\n\t\t\t\tif (WARN(\"UNSPECIFIED_INT\",\n\t\t\t\t\t \"Prefer '\" . trim($sign) . \" int\" . rtrim($pointer) . \"' to bare use of '$sign\" . rtrim($pointer) . \"'\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\tmy $decl = trim($sign) . \" int \";\n\t\t\t\t\tmy $comp_pointer = $pointer;\n\t\t\t\t\t$comp_pointer =~ s/\\s//g;\n\t\t\t\t\t$decl .= $comp_pointer;\n\t\t\t\t\t$decl = rtrim($decl) if ($var eq \"\");\n\t\t\t\t\t$fixed[$fixlinenr] =~ s@\\b$sign\\s*\\Q$pointer\\E\\s*$var\\b@$decl$var@;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# TEST: allow direct testing of the type matcher.\n\t\tif ($dbg_type) {\n\t\t\tif ($line =~ /^.\\s*$Declare\\s*$/) {\n\t\t\t\tERROR(\"TEST_TYPE\",\n\t\t\t\t      \"TEST: is type\\n\" . $herecurr);\n\t\t\t} elsif ($dbg_type > 1 && $line =~ /^.+($Declare)/) {\n\t\t\t\tERROR(\"TEST_NOT_TYPE\",\n\t\t\t\t      \"TEST: is not type ($1 is)\\n\". $herecurr);\n\t\t\t}\n\t\t\tnext;\n\t\t}\n# TEST: allow direct testing of the attribute matcher.\n\t\tif ($dbg_attr) {\n\t\t\tif ($line =~ /^.\\s*$Modifier\\s*$/) {\n\t\t\t\tERROR(\"TEST_ATTR\",\n\t\t\t\t      \"TEST: is attr\\n\" . $herecurr);\n\t\t\t} elsif ($dbg_attr > 1 && $line =~ /^.+($Modifier)/) {\n\t\t\t\tERROR(\"TEST_NOT_ATTR\",\n\t\t\t\t      \"TEST: is not attr ($1 is)\\n\". $herecurr);\n\t\t\t}\n\t\t\tnext;\n\t\t}\n\n# check for initialisation to aggregates open brace on the next line\n\t\tif ($line =~ /^.\\s*{/ &&\n\t\t    $prevline =~ /(?:^|[^=])=\\s*$/) {\n\t\t\tif (ERROR(\"OPEN_BRACE\",\n\t\t\t\t  \"that open brace { should be on the previous line\\n\" . $hereprev) &&\n\t\t\t    $fix && $prevline =~ /^\\+/ && $line =~ /^\\+/) {\n\t\t\t\tfix_delete_line($fixlinenr - 1, $prevrawline);\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\tmy $fixedline = $prevrawline;\n\t\t\t\t$fixedline =~ s/\\s*=\\s*$/ = {/;\n\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t\t$fixedline = $line;\n\t\t\t\t$fixedline =~ s/^(.\\s*)\\{\\s*/$1/;\n\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t}\n\t\t}\n\n#\n# Checks which are anchored on the added line.\n#\n\n# check for malformed paths in #include statements (uses RAW line)\n\t\tif ($rawline =~ m{^.\\s*\\#\\s*include\\s+[<\"](.*)[\">]}) {\n\t\t\tmy $path = $1;\n\t\t\tif ($path =~ m{//}) {\n\t\t\t\tERROR(\"MALFORMED_INCLUDE\",\n\t\t\t\t      \"malformed #include filename\\n\" . $herecurr);\n\t\t\t}\n\t\t\tif ($path =~ \"^uapi/\" && $realfile =~ m@\\binclude/uapi/@) {\n\t\t\t\tERROR(\"UAPI_INCLUDE\",\n\t\t\t\t      \"No #include in ...include/uapi/... should use a uapi/ path prefix\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# no C99 // comments\n\t\tif ($line =~ m{//}) {\n\t\t\tif (ERROR(\"C99_COMMENTS\",\n\t\t\t\t  \"do not use C99 // comments\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tmy $line = $fixed[$fixlinenr];\n\t\t\t\tif ($line =~ /\\/\\/(.*)$/) {\n\t\t\t\t\tmy $comment = trim($1);\n\t\t\t\t\t$fixed[$fixlinenr] =~ s@\\/\\/(.*)$@/\\* $comment \\*/@;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t# Remove C99 comments.\n\t\t$line =~ s@//.*@@;\n\t\t$opline =~ s@//.*@@;\n\n# EXPORT_SYMBOL should immediately follow the thing it is exporting, consider\n# the whole statement.\n#print \"APW <$lines[$realline_next - 1]>\\n\";\n\t\tif (defined $realline_next &&\n\t\t    exists $lines[$realline_next - 1] &&\n\t\t    !defined $suppress_export{$realline_next} &&\n\t\t    ($lines[$realline_next - 1] =~ /EXPORT_SYMBOL.*\\((.*)\\)/)) {\n\t\t\t# Handle definitions which produce identifiers with\n\t\t\t# a prefix:\n\t\t\t#   XXX(foo);\n\t\t\t#   EXPORT_SYMBOL(something_foo);\n\t\t\tmy $name = $1;\n\t\t\t$name =~ s/^\\s*($Ident).*/$1/;\n\t\t\tif ($stat =~ /^(?:.\\s*}\\s*\\n)?.([A-Z_]+)\\s*\\(\\s*($Ident)/ &&\n\t\t\t    $name =~ /^${Ident}_$2/) {\n#print \"FOO C name<$name>\\n\";\n\t\t\t\t$suppress_export{$realline_next} = 1;\n\n\t\t\t} elsif ($stat !~ /(?:\n\t\t\t\t\\n.}\\s*$|\n\t\t\t\t^.DEFINE_$Ident\\(\\Q$name\\E\\)|\n\t\t\t\t^.DECLARE_$Ident\\(\\Q$name\\E\\)|\n\t\t\t\t^.LIST_HEAD\\(\\Q$name\\E\\)|\n\t\t\t\t^.(?:$Storage\\s+)?$Type\\s*\\(\\s*\\*\\s*\\Q$name\\E\\s*\\)\\s*\\(|\n\t\t\t\t\\b\\Q$name\\E(?:\\s+$Attribute)*\\s*(?:;|=|\\[|\\()\n\t\t\t    )/x) {\n#print \"FOO A<$lines[$realline_next - 1]> stat<$stat> name<$name>\\n\";\n\t\t\t\t$suppress_export{$realline_next} = 2;\n\t\t\t} else {\n\t\t\t\t$suppress_export{$realline_next} = 1;\n\t\t\t}\n\t\t}\n\t\tif (!defined $suppress_export{$linenr} &&\n\t\t    $prevline =~ /^.\\s*$/ &&\n\t\t    ($line =~ /EXPORT_SYMBOL.*\\((.*)\\)/)) {\n#print \"FOO B <$lines[$linenr - 1]>\\n\";\n\t\t\t$suppress_export{$linenr} = 2;\n\t\t}\n\t\tif (defined $suppress_export{$linenr} &&\n\t\t    $suppress_export{$linenr} == 2) {\n\t\t\tWARN(\"EXPORT_SYMBOL\",\n\t\t\t     \"EXPORT_SYMBOL(foo); should immediately follow its function/variable\\n\" . $herecurr);\n\t\t}\n\n# check for global initialisers.\n\t\tif ($line =~ /^\\+$Type\\s*$Ident(?:\\s+$Modifier)*\\s*=\\s*($zero_initializer)\\s*;/ &&\n\t\t    !exclude_global_initialisers($realfile)) {\n\t\t\tif (ERROR(\"GLOBAL_INITIALISERS\",\n\t\t\t\t  \"do not initialise globals to $1\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/(^.$Type\\s*$Ident(?:\\s+$Modifier)*)\\s*=\\s*$zero_initializer\\s*;/$1;/;\n\t\t\t}\n\t\t}\n# check for static initialisers.\n\t\tif ($line =~ /^\\+.*\\bstatic\\s.*=\\s*($zero_initializer)\\s*;/) {\n\t\t\tif (ERROR(\"INITIALISED_STATIC\",\n\t\t\t\t  \"do not initialise statics to $1\\n\" .\n\t\t\t\t      $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/(\\bstatic\\s.*?)\\s*=\\s*$zero_initializer\\s*;/$1;/;\n\t\t\t}\n\t\t}\n\n# check for misordered declarations of char/short/int/long with signed/unsigned\n\t\twhile ($sline =~ m{(\\b$TypeMisordered\\b)}g) {\n\t\t\tmy $tmp = trim($1);\n\t\t\tWARN(\"MISORDERED_TYPE\",\n\t\t\t     \"type '$tmp' should be specified in [[un]signed] [short|int|long|long long] order\\n\" . $herecurr);\n\t\t}\n\n# check for unnecessary <signed> int declarations of short/long/long long\n\t\twhile ($sline =~ m{\\b($TypeMisordered(\\s*\\*)*|$C90_int_types)\\b}g) {\n\t\t\tmy $type = trim($1);\n\t\t\tnext if ($type !~ /\\bint\\b/);\n\t\t\tnext if ($type !~ /\\b(?:short|long\\s+long|long)\\b/);\n\t\t\tmy $new_type = $type;\n\t\t\t$new_type =~ s/\\b\\s*int\\s*\\b/ /;\n\t\t\t$new_type =~ s/\\b\\s*(?:un)?signed\\b\\s*/ /;\n\t\t\t$new_type =~ s/^const\\s+//;\n\t\t\t$new_type = \"unsigned $new_type\" if ($type =~ /\\bunsigned\\b/);\n\t\t\t$new_type = \"const $new_type\" if ($type =~ /^const\\b/);\n\t\t\t$new_type =~ s/\\s+/ /g;\n\t\t\t$new_type = trim($new_type);\n\t\t\tif (WARN(\"UNNECESSARY_INT\",\n\t\t\t\t \"Prefer '$new_type' over '$type' as the int is unnecessary\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\b\\Q$type\\E\\b/$new_type/;\n\t\t\t}\n\t\t}\n\n# check for static const char * arrays.\n\t\tif ($line =~ /\\bstatic\\s+const\\s+char\\s*\\*\\s*(\\w+)\\s*\\[\\s*\\]\\s*=\\s*/) {\n\t\t\tWARN(\"STATIC_CONST_CHAR_ARRAY\",\n\t\t\t     \"static const char * array should probably be static const char * const\\n\" .\n\t\t\t\t$herecurr);\n\t\t}\n\n# check for initialized const char arrays that should be static const\n\t\tif ($line =~ /^\\+\\s*const\\s+(char|unsigned\\s+char|_*u8|(?:[us]_)?int8_t)\\s+\\w+\\s*\\[\\s*(?:\\w+\\s*)?\\]\\s*=\\s*\"/) {\n\t\t\tif (WARN(\"STATIC_CONST_CHAR_ARRAY\",\n\t\t\t\t \"const array should probably be static const\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/(^.\\s*)const\\b/${1}static const/;\n\t\t\t}\n\t\t}\n\n# check for static char foo[] = \"bar\" declarations.\n\t\tif ($line =~ /\\bstatic\\s+char\\s+(\\w+)\\s*\\[\\s*\\]\\s*=\\s*\"/) {\n\t\t\tWARN(\"STATIC_CONST_CHAR_ARRAY\",\n\t\t\t     \"static char array declaration should probably be static const char\\n\" .\n\t\t\t\t$herecurr);\n\t\t}\n\n# check for const <foo> const where <foo> is not a pointer or array type\n\t\tif ($sline =~ /\\bconst\\s+($BasicType)\\s+const\\b/) {\n\t\t\tmy $found = $1;\n\t\t\tif ($sline =~ /\\bconst\\s+\\Q$found\\E\\s+const\\b\\s*\\*/) {\n\t\t\t\tWARN(\"CONST_CONST\",\n\t\t\t\t     \"'const $found const *' should probably be 'const $found * const'\\n\" . $herecurr);\n\t\t\t} elsif ($sline !~ /\\bconst\\s+\\Q$found\\E\\s+const\\s+\\w+\\s*\\[/) {\n\t\t\t\tWARN(\"CONST_CONST\",\n\t\t\t\t     \"'const $found const' should probably be 'const $found'\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for const static or static <non ptr type> const declarations\n# prefer 'static const <foo>' over 'const static <foo>' and 'static <foo> const'\n\t\tif ($sline =~ /^\\+\\s*const\\s+static\\s+($Type)\\b/ ||\n\t\t    $sline =~ /^\\+\\s*static\\s+($BasicType)\\s+const\\b/) {\n\t\t\tif (WARN(\"STATIC_CONST\",\n\t\t\t\t \"Move const after static - use 'static const $1'\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\bconst\\s+static\\b/static const/;\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\bstatic\\s+($BasicType)\\s+const\\b/static const $1/;\n\t\t\t}\n\t\t}\n\n# check for non-global char *foo[] = {\"bar\", ...} declarations.\n\t\tif ($line =~ /^.\\s+(?:static\\s+|const\\s+)?char\\s+\\*\\s*\\w+\\s*\\[\\s*\\]\\s*=\\s*\\{/) {\n\t\t\tWARN(\"STATIC_CONST_CHAR_ARRAY\",\n\t\t\t     \"char * array declaration might be better as static const\\n\" .\n\t\t\t\t$herecurr);\n\t\t}\n\n# check for sizeof(foo)/sizeof(foo[0]) that could be ARRAY_SIZE(foo)\n\t\tif ($line =~ m@\\bsizeof\\s*\\(\\s*($Lval)\\s*\\)@) {\n\t\t\tmy $array = $1;\n\t\t\tif ($line =~ m@\\b(sizeof\\s*\\(\\s*\\Q$array\\E\\s*\\)\\s*/\\s*sizeof\\s*\\(\\s*\\Q$array\\E\\s*\\[\\s*0\\s*\\]\\s*\\))@) {\n\t\t\t\tmy $array_div = $1;\n\t\t\t\tif (WARN(\"ARRAY_SIZE\",\n\t\t\t\t\t \"Prefer ARRAY_SIZE($array)\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$array_div\\E/ARRAY_SIZE($array)/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for function declarations without arguments like \"int foo()\"\n\t\tif ($line =~ /(\\b$Type\\s*$Ident)\\s*\\(\\s*\\)/) {\n\t\t\tif (ERROR(\"FUNCTION_WITHOUT_ARGS\",\n\t\t\t\t  \"Bad function definition - $1() should probably be $1(void)\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/(\\b($Type)\\s+($Ident))\\s*\\(\\s*\\)/$2 $3(void)/;\n\t\t\t}\n\t\t}\n\n# check for new typedefs, only function parameters and sparse annotations\n# make sense.\n\t\tif ($line =~ /\\btypedef\\s/ &&\n\t\t    $line !~ /\\btypedef\\s+$Type\\s*\\(\\s*\\*?$Ident\\s*\\)\\s*\\(/ &&\n\t\t    $line !~ /\\btypedef\\s+$Type\\s+$Ident\\s*\\(/ &&\n\t\t    $line !~ /\\b$typeTypedefs\\b/ &&\n\t\t    $line !~ /\\b__bitwise\\b/) {\n\t\t\tWARN(\"NEW_TYPEDEFS\",\n\t\t\t     \"do not add new typedefs\\n\" . $herecurr);\n\t\t}\n\n# * goes on variable not on type\n\t\t# (char*[ const])\n\t\twhile ($line =~ m{(\\($NonptrType(\\s*(?:$Modifier\\b\\s*|\\*\\s*)+)\\))}g) {\n\t\t\t#print \"AA<$1>\\n\";\n\t\t\tmy ($ident, $from, $to) = ($1, $2, $2);\n\n\t\t\t# Should start with a space.\n\t\t\t$to =~ s/^(\\S)/ $1/;\n\t\t\t# Should not end with a space.\n\t\t\t$to =~ s/\\s+$//;\n\t\t\t# '*'s should not have spaces between.\n\t\t\twhile ($to =~ s/\\*\\s+\\*/\\*\\*/) {\n\t\t\t}\n\n##\t\t\tprint \"1: from<$from> to<$to> ident<$ident>\\n\";\n\t\t\tif ($from ne $to) {\n\t\t\t\tif (ERROR(\"POINTER_LOCATION\",\n\t\t\t\t\t  \"\\\"(foo$from)\\\" should be \\\"(foo$to)\\\"\\n\" .  $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\tmy $sub_from = $ident;\n\t\t\t\t\tmy $sub_to = $ident;\n\t\t\t\t\t$sub_to =~ s/\\Q$from\\E/$to/;\n\t\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t\t    s@\\Q$sub_from\\E@$sub_to@;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile ($line =~ m{(\\b$NonptrType(\\s*(?:$Modifier\\b\\s*|\\*\\s*)+)($Ident))}g) {\n\t\t\t#print \"BB<$1>\\n\";\n\t\t\tmy ($match, $from, $to, $ident) = ($1, $2, $2, $3);\n\n\t\t\t# Should start with a space.\n\t\t\t$to =~ s/^(\\S)/ $1/;\n\t\t\t# Should not end with a space.\n\t\t\t$to =~ s/\\s+$//;\n\t\t\t# '*'s should not have spaces between.\n\t\t\twhile ($to =~ s/\\*\\s+\\*/\\*\\*/) {\n\t\t\t}\n\t\t\t# Modifiers should have spaces.\n\t\t\t$to =~ s/(\\b$Modifier$)/$1 /;\n\n##\t\t\tprint \"2: from<$from> to<$to> ident<$ident>\\n\";\n\t\t\tif ($from ne $to && $ident !~ /^$Modifier$/) {\n\t\t\t\tif (ERROR(\"POINTER_LOCATION\",\n\t\t\t\t\t  \"\\\"foo${from}bar\\\" should be \\\"foo${to}bar\\\"\\n\" .  $herecurr) &&\n\t\t\t\t    $fix) {\n\n\t\t\t\t\tmy $sub_from = $match;\n\t\t\t\t\tmy $sub_to = $match;\n\t\t\t\t\t$sub_to =~ s/\\Q$from\\E/$to/;\n\t\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t\t    s@\\Q$sub_from\\E@$sub_to@;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# do not use BUG() or variants\n\t\tif ($line =~ /\\b(?!AA_|BUILD_|DCCP_|IDA_|KVM_|RWLOCK_|snd_|SPIN_)(?:[a-zA-Z_]*_)?BUG(?:_ON)?(?:_[A-Z_]+)?\\s*\\(/) {\n\t\t\tmy $msg_level = \\&WARN;\n\t\t\t$msg_level = \\&CHK if ($file);\n\t\t\t&{$msg_level}(\"AVOID_BUG\",\n\t\t\t\t      \"Do not crash the kernel unless it is absolutely unavoidable--use WARN_ON_ONCE() plus recovery code (if feasible) instead of BUG() or variants\\n\" . $herecurr);\n\t\t}\n\n# avoid LINUX_VERSION_CODE\n\t\tif ($line =~ /\\bLINUX_VERSION_CODE\\b/) {\n\t\t\tWARN(\"LINUX_VERSION_CODE\",\n\t\t\t     \"LINUX_VERSION_CODE should be avoided, code should be for the version to which it is merged\\n\" . $herecurr);\n\t\t}\n\n# check for uses of printk_ratelimit\n\t\tif ($line =~ /\\bprintk_ratelimit\\s*\\(/) {\n\t\t\tWARN(\"PRINTK_RATELIMITED\",\n\t\t\t     \"Prefer printk_ratelimited or pr_<level>_ratelimited to printk_ratelimit\\n\" . $herecurr);\n\t\t}\n\n# printk should use KERN_* levels\n\t\tif ($line =~ /\\bprintk\\s*\\(\\s*(?!KERN_[A-Z]+\\b)/) {\n\t\t\tWARN(\"PRINTK_WITHOUT_KERN_LEVEL\",\n\t\t\t     \"printk() should include KERN_<LEVEL> facility level\\n\" . $herecurr);\n\t\t}\n\n# prefer variants of (subsystem|netdev|dev|pr)_<level> to printk(KERN_<LEVEL>\n\t\tif ($line =~ /\\b(printk(_once|_ratelimited)?)\\s*\\(\\s*KERN_([A-Z]+)/) {\n\t\t\tmy $printk = $1;\n\t\t\tmy $modifier = $2;\n\t\t\tmy $orig = $3;\n\t\t\t$modifier = \"\" if (!defined($modifier));\n\t\t\tmy $level = lc($orig);\n\t\t\t$level = \"warn\" if ($level eq \"warning\");\n\t\t\tmy $level2 = $level;\n\t\t\t$level2 = \"dbg\" if ($level eq \"debug\");\n\t\t\t$level .= $modifier;\n\t\t\t$level2 .= $modifier;\n\t\t\tWARN(\"PREFER_PR_LEVEL\",\n\t\t\t     \"Prefer [subsystem eg: netdev]_$level2([subsystem]dev, ... then dev_$level2(dev, ... then pr_$level(...  to $printk(KERN_$orig ...\\n\" . $herecurr);\n\t\t}\n\n# prefer dev_<level> to dev_printk(KERN_<LEVEL>\n\t\tif ($line =~ /\\bdev_printk\\s*\\(\\s*KERN_([A-Z]+)/) {\n\t\t\tmy $orig = $1;\n\t\t\tmy $level = lc($orig);\n\t\t\t$level = \"warn\" if ($level eq \"warning\");\n\t\t\t$level = \"dbg\" if ($level eq \"debug\");\n\t\t\tWARN(\"PREFER_DEV_LEVEL\",\n\t\t\t     \"Prefer dev_$level(... to dev_printk(KERN_$orig, ...\\n\" . $herecurr);\n\t\t}\n\n# trace_printk should not be used in production code.\n\t\tif ($line =~ /\\b(trace_printk|trace_puts|ftrace_vprintk)\\s*\\(/) {\n\t\t\tWARN(\"TRACE_PRINTK\",\n\t\t\t     \"Do not use $1() in production code (this can be ignored if built only with a debug config option)\\n\" . $herecurr);\n\t\t}\n\n# ENOSYS means \"bad syscall nr\" and nothing else.  This will have a small\n# number of false positives, but assembly files are not checked, so at\n# least the arch entry code will not trigger this warning.\n\t\tif ($line =~ /\\bENOSYS\\b/) {\n\t\t\tWARN(\"ENOSYS\",\n\t\t\t     \"ENOSYS means 'invalid syscall nr' and nothing else\\n\" . $herecurr);\n\t\t}\n\n# ENOTSUPP is not a standard error code and should be avoided in new patches.\n# Folks usually mean EOPNOTSUPP (also called ENOTSUP), when they type ENOTSUPP.\n# Similarly to ENOSYS warning a small number of false positives is expected.\n\t\tif (!$file && $line =~ /\\bENOTSUPP\\b/) {\n\t\t\tif (WARN(\"ENOTSUPP\",\n\t\t\t\t \"ENOTSUPP is not a SUSV4 error code, prefer EOPNOTSUPP\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\bENOTSUPP\\b/EOPNOTSUPP/;\n\t\t\t}\n\t\t}\n\n# function brace can't be on same line, except for #defines of do while,\n# or if closed on same line\n\t\tif ($perl_version_ok &&\n\t\t    $sline =~ /$Type\\s*$Ident\\s*$balanced_parens\\s*\\{/ &&\n\t\t    $sline !~ /\\#\\s*define\\b.*do\\s*\\{/ &&\n\t\t    $sline !~ /}/) {\n\t\t\tif (ERROR(\"OPEN_BRACE\",\n\t\t\t\t  \"open brace '{' following function definitions go on the next line\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\tmy $fixed_line = $rawline;\n\t\t\t\t$fixed_line =~ /(^..*$Type\\s*$Ident\\(.*\\)\\s*)\\{(.*)$/;\n\t\t\t\tmy $line1 = $1;\n\t\t\t\tmy $line2 = $2;\n\t\t\t\tfix_insert_line($fixlinenr, ltrim($line1));\n\t\t\t\tfix_insert_line($fixlinenr, \"\\+{\");\n\t\t\t\tif ($line2 !~ /^\\s*$/) {\n\t\t\t\t\tfix_insert_line($fixlinenr, \"\\+\\t\" . trim($line2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# open braces for enum, union and struct go on the same line.\n\t\tif ($line =~ /^.\\s*{/ &&\n\t\t    $prevline =~ /^.\\s*(?:typedef\\s+)?(enum|union|struct)(?:\\s+$Ident)?\\s*$/) {\n\t\t\tif (ERROR(\"OPEN_BRACE\",\n\t\t\t\t  \"open brace '{' following $1 go on the same line\\n\" . $hereprev) &&\n\t\t\t    $fix && $prevline =~ /^\\+/ && $line =~ /^\\+/) {\n\t\t\t\tfix_delete_line($fixlinenr - 1, $prevrawline);\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\tmy $fixedline = rtrim($prevrawline) . \" {\";\n\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t\t$fixedline = $rawline;\n\t\t\t\t$fixedline =~ s/^(.\\s*)\\{\\s*/$1\\t/;\n\t\t\t\tif ($fixedline !~ /^\\+\\s*$/) {\n\t\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# missing space after union, struct or enum definition\n\t\tif ($line =~ /^.\\s*(?:typedef\\s+)?(enum|union|struct)(?:\\s+$Ident){1,2}[=\\{]/) {\n\t\t\tif (WARN(\"SPACING\",\n\t\t\t\t \"missing space after $1 definition\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/^(.\\s*(?:typedef\\s+)?(?:enum|union|struct)(?:\\s+$Ident){1,2})([=\\{])/$1 $2/;\n\t\t\t}\n\t\t}\n\n# Function pointer declarations\n# check spacing between type, funcptr, and args\n# canonical declaration is \"type (*funcptr)(args...)\"\n\t\tif ($line =~ /^.\\s*($Declare)\\((\\s*)\\*(\\s*)($Ident)(\\s*)\\)(\\s*)\\(/) {\n\t\t\tmy $declare = $1;\n\t\t\tmy $pre_pointer_space = $2;\n\t\t\tmy $post_pointer_space = $3;\n\t\t\tmy $funcname = $4;\n\t\t\tmy $post_funcname_space = $5;\n\t\t\tmy $pre_args_space = $6;\n\n# the $Declare variable will capture all spaces after the type\n# so check it for a missing trailing missing space but pointer return types\n# don't need a space so don't warn for those.\n\t\t\tmy $post_declare_space = \"\";\n\t\t\tif ($declare =~ /(\\s+)$/) {\n\t\t\t\t$post_declare_space = $1;\n\t\t\t\t$declare = rtrim($declare);\n\t\t\t}\n\t\t\tif ($declare !~ /\\*$/ && $post_declare_space =~ /^$/) {\n\t\t\t\tWARN(\"SPACING\",\n\t\t\t\t     \"missing space after return type\\n\" . $herecurr);\n\t\t\t\t$post_declare_space = \" \";\n\t\t\t}\n\n# unnecessary space \"type  (*funcptr)(args...)\"\n# This test is not currently implemented because these declarations are\n# equivalent to\n#\tint  foo(int bar, ...)\n# and this is form shouldn't/doesn't generate a checkpatch warning.\n#\n#\t\t\telsif ($declare =~ /\\s{2,}$/) {\n#\t\t\t\tWARN(\"SPACING\",\n#\t\t\t\t     \"Multiple spaces after return type\\n\" . $herecurr);\n#\t\t\t}\n\n# unnecessary space \"type ( *funcptr)(args...)\"\n\t\t\tif (defined $pre_pointer_space &&\n\t\t\t    $pre_pointer_space =~ /^\\s/) {\n\t\t\t\tWARN(\"SPACING\",\n\t\t\t\t     \"Unnecessary space after function pointer open parenthesis\\n\" . $herecurr);\n\t\t\t}\n\n# unnecessary space \"type (* funcptr)(args...)\"\n\t\t\tif (defined $post_pointer_space &&\n\t\t\t    $post_pointer_space =~ /^\\s/) {\n\t\t\t\tWARN(\"SPACING\",\n\t\t\t\t     \"Unnecessary space before function pointer name\\n\" . $herecurr);\n\t\t\t}\n\n# unnecessary space \"type (*funcptr )(args...)\"\n\t\t\tif (defined $post_funcname_space &&\n\t\t\t    $post_funcname_space =~ /^\\s/) {\n\t\t\t\tWARN(\"SPACING\",\n\t\t\t\t     \"Unnecessary space after function pointer name\\n\" . $herecurr);\n\t\t\t}\n\n# unnecessary space \"type (*funcptr) (args...)\"\n\t\t\tif (defined $pre_args_space &&\n\t\t\t    $pre_args_space =~ /^\\s/) {\n\t\t\t\tWARN(\"SPACING\",\n\t\t\t\t     \"Unnecessary space before function pointer arguments\\n\" . $herecurr);\n\t\t\t}\n\n\t\t\tif (show_type(\"SPACING\") && $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/^(.\\s*)$Declare\\s*\\(\\s*\\*\\s*$Ident\\s*\\)\\s*\\(/$1 . $declare . $post_declare_space . '(*' . $funcname . ')('/ex;\n\t\t\t}\n\t\t}\n\n# check for spacing round square brackets; allowed:\n#  1. with a type on the left -- int [] a;\n#  2. at the beginning of a line for slice initialisers -- [0...10] = 5,\n#  3. inside a curly brace -- = { [0...10] = 5 }\n\t\twhile ($line =~ /(.*?\\s)\\[/g) {\n\t\t\tmy ($where, $prefix) = ($-[1], $1);\n\t\t\tif ($prefix !~ /$Type\\s+$/ &&\n\t\t\t    ($where != 0 || $prefix !~ /^.\\s+$/) &&\n\t\t\t    $prefix !~ /[{,:]\\s+$/) {\n\t\t\t\tif (ERROR(\"BRACKET_SPACE\",\n\t\t\t\t\t  \"space prohibited before open square bracket '['\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t    $fixed[$fixlinenr] =~\n\t\t\t\t\ts/^(\\+.*?)\\s+\\[/$1\\[/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for spaces between functions and their parentheses.\n\t\twhile ($line =~ /($Ident)\\s+\\(/g) {\n\t\t\tmy $name = $1;\n\t\t\tmy $ctx_before = substr($line, 0, $-[1]);\n\t\t\tmy $ctx = \"$ctx_before$name\";\n\n\t\t\t# Ignore those directives where spaces _are_ permitted.\n\t\t\tif ($name =~ /^(?:\n\t\t\t\tif|for|while|switch|return|case|\n\t\t\t\tvolatile|__volatile__|\n\t\t\t\t__attribute__|format|__extension__|\n\t\t\t\tasm|__asm__|scoped_guard)$/x)\n\t\t\t{\n\t\t\t# cpp #define statements have non-optional spaces, ie\n\t\t\t# if there is a space between the name and the open\n\t\t\t# parenthesis it is simply not a parameter group.\n\t\t\t} elsif ($ctx_before =~ /^.\\s*\\#\\s*define\\s*$/) {\n\n\t\t\t# cpp #elif statement condition may start with a (\n\t\t\t} elsif ($ctx =~ /^.\\s*\\#\\s*elif\\s*$/) {\n\n\t\t\t# If this whole things ends with a type its most\n\t\t\t# likely a typedef for a function.\n\t\t\t} elsif ($ctx =~ /$Type$/) {\n\n\t\t\t} else {\n\t\t\t\tif (WARN(\"SPACING\",\n\t\t\t\t\t \"space prohibited between function name and open parenthesis '('\\n\" . $herecurr) &&\n\t\t\t\t\t     $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t\t    s/\\b$name\\s+\\(/$name\\(/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# Check operator spacing.\n\t\tif (!($line=~/\\#\\s*include/)) {\n\t\t\tmy $fixed_line = \"\";\n\t\t\tmy $line_fixed = 0;\n\n\t\t\tmy $ops = qr{\n\t\t\t\t<<=|>>=|<=|>=|==|!=|\n\t\t\t\t\\+=|-=|\\*=|\\/=|%=|\\^=|\\|=|&=|\n\t\t\t\t=>|->|<<|>>|<|>|=|!|~|\n\t\t\t\t&&|\\|\\||,|\\^|\\+\\+|--|&|\\||\\+|-|\\*|\\/|%|\n\t\t\t\t\\?:|\\?|:\n\t\t\t}x;\n\t\t\tmy @elements = split(/($ops|;)/, $opline);\n\n##\t\t\tprint(\"element count: <\" . $#elements . \">\\n\");\n##\t\t\tforeach my $el (@elements) {\n##\t\t\t\tprint(\"el: <$el>\\n\");\n##\t\t\t}\n\n\t\t\tmy @fix_elements = ();\n\t\t\tmy $off = 0;\n\n\t\t\tforeach my $el (@elements) {\n\t\t\t\tpush(@fix_elements, substr($rawline, $off, length($el)));\n\t\t\t\t$off += length($el);\n\t\t\t}\n\n\t\t\t$off = 0;\n\n\t\t\tmy $blank = copy_spacing($opline);\n\t\t\tmy $last_after = -1;\n\n\t\t\tfor (my $n = 0; $n < $#elements; $n += 2) {\n\n\t\t\t\tmy $good = $fix_elements[$n] . $fix_elements[$n + 1];\n\n##\t\t\t\tprint(\"n: <$n> good: <$good>\\n\");\n\n\t\t\t\t$off += length($elements[$n]);\n\n\t\t\t\t# Pick up the preceding and succeeding characters.\n\t\t\t\tmy $ca = substr($opline, 0, $off);\n\t\t\t\tmy $cc = '';\n\t\t\t\tif (length($opline) >= ($off + length($elements[$n + 1]))) {\n\t\t\t\t\t$cc = substr($opline, $off + length($elements[$n + 1]));\n\t\t\t\t}\n\t\t\t\tmy $cb = \"$ca$;$cc\";\n\n\t\t\t\tmy $a = '';\n\t\t\t\t$a = 'V' if ($elements[$n] ne '');\n\t\t\t\t$a = 'W' if ($elements[$n] =~ /\\s$/);\n\t\t\t\t$a = 'C' if ($elements[$n] =~ /$;$/);\n\t\t\t\t$a = 'B' if ($elements[$n] =~ /(\\[|\\()$/);\n\t\t\t\t$a = 'O' if ($elements[$n] eq '');\n\t\t\t\t$a = 'E' if ($ca =~ /^\\s*$/);\n\n\t\t\t\tmy $op = $elements[$n + 1];\n\n\t\t\t\tmy $c = '';\n\t\t\t\tif (defined $elements[$n + 2]) {\n\t\t\t\t\t$c = 'V' if ($elements[$n + 2] ne '');\n\t\t\t\t\t$c = 'W' if ($elements[$n + 2] =~ /^\\s/);\n\t\t\t\t\t$c = 'C' if ($elements[$n + 2] =~ /^$;/);\n\t\t\t\t\t$c = 'B' if ($elements[$n + 2] =~ /^(\\)|\\]|;)/);\n\t\t\t\t\t$c = 'O' if ($elements[$n + 2] eq '');\n\t\t\t\t\t$c = 'E' if ($elements[$n + 2] =~ /^\\s*\\\\$/);\n\t\t\t\t} else {\n\t\t\t\t\t$c = 'E';\n\t\t\t\t}\n\n\t\t\t\tmy $ctx = \"${a}x${c}\";\n\n\t\t\t\tmy $at = \"(ctx:$ctx)\";\n\n\t\t\t\tmy $ptr = substr($blank, 0, $off) . \"^\";\n\t\t\t\tmy $hereptr = \"$hereline$ptr\\n\";\n\n\t\t\t\t# Pull out the value of this operator.\n\t\t\t\tmy $op_type = substr($curr_values, $off + 1, 1);\n\n\t\t\t\t# Get the full operator variant.\n\t\t\t\tmy $opv = $op . substr($curr_vars, $off, 1);\n\n\t\t\t\t# Ignore operators passed as parameters.\n\t\t\t\tif ($op_type ne 'V' &&\n\t\t\t\t    $ca =~ /\\s$/ && $cc =~ /^\\s*[,\\)]/) {\n\n#\t\t\t\t# Ignore comments\n#\t\t\t\t} elsif ($op =~ /^$;+$/) {\n\n\t\t\t\t# ; should have either the end of line or a space or \\ after it\n\t\t\t\t} elsif ($op eq ';') {\n\t\t\t\t\tif ($ctx !~ /.x[WEBC]/ &&\n\t\t\t\t\t    $cc !~ /^\\\\/ && $cc !~ /^;/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space required after that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = $fix_elements[$n] . trim($fix_elements[$n + 1]) . \" \";\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t# // is a comment\n\t\t\t\t} elsif ($op eq '//') {\n\n\t\t\t\t#   :   when part of a bitfield\n\t\t\t\t} elsif ($opv eq ':B') {\n\t\t\t\t\t# skip the bitfield test for now\n\n\t\t\t\t# No spaces for:\n\t\t\t\t#   ->\n\t\t\t\t} elsif ($op eq '->') {\n\t\t\t\t\tif ($ctx =~ /Wx.|.xW/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"spaces prohibited around that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);\n\t\t\t\t\t\t\tif (defined $fix_elements[$n + 2]) {\n\t\t\t\t\t\t\t\t$fix_elements[$n + 2] =~ s/^\\s+//;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t# , must not have a space before and must have a space on the right.\n\t\t\t\t} elsif ($op eq ',') {\n\t\t\t\t\tmy $rtrim_before = 0;\n\t\t\t\t\tmy $space_after = 0;\n\t\t\t\t\tif ($ctx =~ /Wx./) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space prohibited before that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t\t$rtrim_before = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($ctx !~ /.x[WEC]/ && $cc !~ /^}/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space required after that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t\t$last_after = $n;\n\t\t\t\t\t\t\t$space_after = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($rtrim_before || $space_after) {\n\t\t\t\t\t\tif ($rtrim_before) {\n\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$good = $fix_elements[$n] . trim($fix_elements[$n + 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($space_after) {\n\t\t\t\t\t\t\t$good .= \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t# '*' as part of a type definition -- reported already.\n\t\t\t\t} elsif ($opv eq '*_') {\n\t\t\t\t\t#warn \"'*' is part of type\\n\";\n\n\t\t\t\t# unary operators should have a space before and\n\t\t\t\t# none after.  May be left adjacent to another\n\t\t\t\t# unary operator, or a cast\n\t\t\t\t} elsif ($op eq '!' || $op eq '~' ||\n\t\t\t\t\t $opv eq '*U' || $opv eq '-U' ||\n\t\t\t\t\t $opv eq '&U' || $opv eq '&&U') {\n\t\t\t\t\tif ($ctx !~ /[WEBC]x./ && $ca !~ /(?:\\)|!|~|\\*|-|\\&|\\||\\+\\+|\\-\\-|\\{)$/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space required before that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\tif ($n != $last_after + 2) {\n\t\t\t\t\t\t\t\t$good = $fix_elements[$n] . \" \" . ltrim($fix_elements[$n + 1]);\n\t\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($op eq '*' && $cc =~/\\s*$Modifier\\b/) {\n\t\t\t\t\t\t# A unary '*' may be const\n\n\t\t\t\t\t} elsif ($ctx =~ /.xW/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space prohibited after that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = $fix_elements[$n] . rtrim($fix_elements[$n + 1]);\n\t\t\t\t\t\t\tif (defined $fix_elements[$n + 2]) {\n\t\t\t\t\t\t\t\t$fix_elements[$n + 2] =~ s/^\\s+//;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t# unary ++ and unary -- are allowed no space on one side.\n\t\t\t\t} elsif ($op eq '++' or $op eq '--') {\n\t\t\t\t\tif ($ctx !~ /[WEOBC]x[^W]/ && $ctx !~ /[^W]x[WOBEC]/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space required one side of that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = $fix_elements[$n] . trim($fix_elements[$n + 1]) . \" \";\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($ctx =~ /Wx[BE]/ ||\n\t\t\t\t\t    ($ctx =~ /Wx./ && $cc =~ /^;/)) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space prohibited before that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($ctx =~ /ExW/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space prohibited after that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = $fix_elements[$n] . trim($fix_elements[$n + 1]);\n\t\t\t\t\t\t\tif (defined $fix_elements[$n + 2]) {\n\t\t\t\t\t\t\t\t$fix_elements[$n + 2] =~ s/^\\s+//;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t# << and >> may either have or not have spaces both sides\n\t\t\t\t} elsif ($op eq '<<' or $op eq '>>' or\n\t\t\t\t\t $op eq '&' or $op eq '^' or $op eq '|' or\n\t\t\t\t\t $op eq '+' or $op eq '-' or\n\t\t\t\t\t $op eq '*' or $op eq '/' or\n\t\t\t\t\t $op eq '%')\n\t\t\t\t{\n\t\t\t\t\tif ($check) {\n\t\t\t\t\t\tif (defined $fix_elements[$n + 2] && $ctx !~ /[EW]x[EW]/) {\n\t\t\t\t\t\t\tif (CHK(\"SPACING\",\n\t\t\t\t\t\t\t\t\"spaces preferred around that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . \" \" . trim($fix_elements[$n + 1]) . \" \";\n\t\t\t\t\t\t\t\t$fix_elements[$n + 2] =~ s/^\\s+//;\n\t\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} elsif (!defined $fix_elements[$n + 2] && $ctx !~ /Wx[OE]/) {\n\t\t\t\t\t\t\tif (CHK(\"SPACING\",\n\t\t\t\t\t\t\t\t\"space preferred before that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . \" \" . trim($fix_elements[$n + 1]);\n\t\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} elsif ($ctx =~ /Wx[^WCE]|[^WCE]xW/) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"need consistent spacing around '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . \" \" . trim($fix_elements[$n + 1]) . \" \";\n\t\t\t\t\t\t\tif (defined $fix_elements[$n + 2]) {\n\t\t\t\t\t\t\t\t$fix_elements[$n + 2] =~ s/^\\s+//;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t# A colon needs no spaces before when it is\n\t\t\t\t# terminating a case value or a label.\n\t\t\t\t} elsif ($opv eq ':C' || $opv eq ':L') {\n\t\t\t\t\tif ($ctx =~ /Wx./ and $realfile !~ m@.*\\.lds\\.h$@) {\n\t\t\t\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t\t\t\t  \"space prohibited before that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . trim($fix_elements[$n + 1]);\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t# All the others need spaces both sides.\n\t\t\t\t} elsif ($ctx !~ /[EWC]x[CWE]/) {\n\t\t\t\t\tmy $ok = 0;\n\n\t\t\t\t\t# Ignore email addresses <foo@bar>\n\t\t\t\t\tif (($op eq '<' &&\n\t\t\t\t\t     $cc =~ /^\\S+\\@\\S+>/) ||\n\t\t\t\t\t    ($op eq '>' &&\n\t\t\t\t\t     $ca =~ /<\\S+\\@\\S+$/))\n\t\t\t\t\t{\n\t\t\t\t\t\t$ok = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t# for asm volatile statements\n\t\t\t\t\t# ignore a colon with another\n\t\t\t\t\t# colon immediately before or after\n\t\t\t\t\tif (($op eq ':') &&\n\t\t\t\t\t    ($ca =~ /:$/ || $cc =~ /^:/)) {\n\t\t\t\t\t\t$ok = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t# messages are ERROR, but ?: are CHK\n\t\t\t\t\tif ($ok == 0) {\n\t\t\t\t\t\tmy $msg_level = \\&ERROR;\n\t\t\t\t\t\t$msg_level = \\&CHK if (($op eq '?:' || $op eq '?' || $op eq ':') && $ctx =~ /VxV/);\n\n\t\t\t\t\t\tif (&{$msg_level}(\"SPACING\",\n\t\t\t\t\t\t\t\t  \"spaces required around that '$op' $at\\n\" . $hereptr)) {\n\t\t\t\t\t\t\t$good = rtrim($fix_elements[$n]) . \" \" . trim($fix_elements[$n + 1]) . \" \";\n\t\t\t\t\t\t\tif (defined $fix_elements[$n + 2]) {\n\t\t\t\t\t\t\t\t$fix_elements[$n + 2] =~ s/^\\s+//;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t$line_fixed = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$off += length($elements[$n + 1]);\n\n##\t\t\t\tprint(\"n: <$n> GOOD: <$good>\\n\");\n\n\t\t\t\t$fixed_line = $fixed_line . $good;\n\t\t\t}\n\n\t\t\tif (($#elements % 2) == 0) {\n\t\t\t\t$fixed_line = $fixed_line . $fix_elements[$#elements];\n\t\t\t}\n\n\t\t\tif ($fix && $line_fixed && $fixed_line ne $fixed[$fixlinenr]) {\n\t\t\t\t$fixed[$fixlinenr] = $fixed_line;\n\t\t\t}\n\n\n\t\t}\n\n# check for whitespace before a non-naked semicolon\n\t\tif ($line =~ /^\\+.*\\S\\s+;\\s*$/) {\n\t\t\tif (WARN(\"SPACING\",\n\t\t\t\t \"space prohibited before semicolon\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t1 while $fixed[$fixlinenr] =~\n\t\t\t\t    s/^(\\+.*\\S)\\s+;/$1;/;\n\t\t\t}\n\t\t}\n\n# check for multiple assignments\n\t\tif ($line =~ /^.\\s*$Lval\\s*=\\s*$Lval\\s*=(?!=)/) {\n\t\t\tCHK(\"MULTIPLE_ASSIGNMENTS\",\n\t\t\t    \"multiple assignments should be avoided\\n\" . $herecurr);\n\t\t}\n\n## # check for multiple declarations, allowing for a function declaration\n## # continuation.\n## \t\tif ($line =~ /^.\\s*$Type\\s+$Ident(?:\\s*=[^,{]*)?\\s*,\\s*$Ident.*/ &&\n## \t\t    $line !~ /^.\\s*$Type\\s+$Ident(?:\\s*=[^,{]*)?\\s*,\\s*$Type\\s*$Ident.*/) {\n##\n## \t\t\t# Remove any bracketed sections to ensure we do not\n## \t\t\t# falsely report the parameters of functions.\n## \t\t\tmy $ln = $line;\n## \t\t\twhile ($ln =~ s/\\([^\\(\\)]*\\)//g) {\n## \t\t\t}\n## \t\t\tif ($ln =~ /,/) {\n## \t\t\t\tWARN(\"MULTIPLE_DECLARATION\",\n##\t\t\t\t     \"declaring multiple variables together should be avoided\\n\" . $herecurr);\n## \t\t\t}\n## \t\t}\n\n#need space before brace following if, while, etc\n\t\tif (($line =~ /\\(.*\\)\\{/ && $line !~ /\\($Type\\)\\{/) ||\n\t\t    $line =~ /\\b(?:else|do)\\{/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"space required before the open brace '{'\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/^(\\+.*(?:do|else|\\)))\\{/$1 {/;\n\t\t\t}\n\t\t}\n\n## # check for blank lines before declarations\n##\t\tif ($line =~ /^.\\t+$Type\\s+$Ident(?:\\s*=.*)?;/ &&\n##\t\t    $prevrawline =~ /^.\\s*$/) {\n##\t\t\tWARN(\"SPACING\",\n##\t\t\t     \"No blank lines before declarations\\n\" . $hereprev);\n##\t\t}\n##\n\n# closing brace should have a space following it when it has anything\n# on the line\n\t\tif ($line =~ /}(?!(?:,|;|\\)|\\}))\\S/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"space required after that close brace '}'\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/}((?!(?:,|;|\\)))\\S)/} $1/;\n\t\t\t}\n\t\t}\n\n# check spacing on square brackets\n\t\tif ($line =~ /\\[\\s/ && $line !~ /\\[\\s*$/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"space prohibited after that open square bracket '['\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/\\[\\s+/\\[/;\n\t\t\t}\n\t\t}\n\t\tif ($line =~ /\\s\\]/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"space prohibited before that close square bracket ']'\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/\\s+\\]/\\]/;\n\t\t\t}\n\t\t}\n\n# check spacing on parentheses\n\t\tif ($line =~ /\\(\\s/ && $line !~ /\\(\\s*(?:\\\\)?$/ &&\n\t\t    $line !~ /for\\s*\\(\\s+;/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"space prohibited after that open parenthesis '('\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/\\(\\s+/\\(/;\n\t\t\t}\n\t\t}\n\t\tif ($line =~ /(\\s+)\\)/ && $line !~ /^.\\s*\\)/ &&\n\t\t    $line !~ /for\\s*\\(.*;\\s+\\)/ &&\n\t\t    $line !~ /:\\s+\\)/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"space prohibited before that close parenthesis ')'\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/\\s+\\)/\\)/;\n\t\t\t}\n\t\t}\n\n# check unnecessary parentheses around addressof/dereference single $Lvals\n# ie: &(foo->bar) should be &foo->bar and *(foo->bar) should be *foo->bar\n\n\t\twhile ($line =~ /(?:[^&]&\\s*|\\*)\\(\\s*($Ident\\s*(?:$Member\\s*)+)\\s*\\)/g) {\n\t\t\tmy $var = $1;\n\t\t\tif (CHK(\"UNNECESSARY_PARENTHESES\",\n\t\t\t\t\"Unnecessary parentheses around $var\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\(\\s*\\Q$var\\E\\s*\\)/$var/;\n\t\t\t}\n\t\t}\n\n# check for unnecessary parentheses around function pointer uses\n# ie: (foo->bar)(); should be foo->bar();\n# but not \"if (foo->bar) (\" to avoid some false positives\n\t\tif ($line =~ /(\\bif\\s*|)(\\(\\s*$Ident\\s*(?:$Member\\s*)+\\))[ \\t]*\\(/ && $1 !~ /^if/) {\n\t\t\tmy $var = $2;\n\t\t\tif (CHK(\"UNNECESSARY_PARENTHESES\",\n\t\t\t\t\"Unnecessary parentheses around function pointer $var\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tmy $var2 = deparenthesize($var);\n\t\t\t\t$var2 =~ s/\\s//g;\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$var\\E/$var2/;\n\t\t\t}\n\t\t}\n\n# check for unnecessary parentheses around comparisons in if uses\n# when !drivers/staging or command-line uses --strict\n\t\tif (($realfile !~ m@^(?:drivers/staging/)@ || $check_orig) &&\n\t\t    $perl_version_ok && defined($stat) &&\n\t\t    $stat =~ /(^.\\s*if\\s*($balanced_parens))/) {\n\t\t\tmy $if_stat = $1;\n\t\t\tmy $test = substr($2, 1, -1);\n\t\t\tmy $herectx;\n\t\t\twhile ($test =~ /(?:^|[^\\w\\&\\!\\~])+\\s*\\(\\s*([\\&\\!\\~]?\\s*$Lval\\s*(?:$Compare\\s*$FuncArg)?)\\s*\\)/g) {\n\t\t\t\tmy $match = $1;\n\t\t\t\t# avoid parentheses around potential macro args\n\t\t\t\tnext if ($match =~ /^\\s*\\w+\\s*$/);\n\t\t\t\tif (!defined($herectx)) {\n\t\t\t\t\t$herectx = $here . \"\\n\";\n\t\t\t\t\tmy $cnt = statement_rawlines($if_stat);\n\t\t\t\t\tfor (my $n = 0; $n < $cnt; $n++) {\n\t\t\t\t\t\tmy $rl = raw_line($linenr, $n);\n\t\t\t\t\t\t$herectx .=  $rl . \"\\n\";\n\t\t\t\t\t\tlast if $rl =~ /^[ \\+].*\\{/;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCHK(\"UNNECESSARY_PARENTHESES\",\n\t\t\t\t    \"Unnecessary parentheses around '$match'\\n\" . $herectx);\n\t\t\t}\n\t\t}\n\n# check that goto labels aren't indented (allow a single space indentation)\n# and ignore bitfield definitions like foo:1\n# Strictly, labels can have whitespace after the identifier and before the :\n# but this is not allowed here as many ?: uses would appear to be labels\n\t\tif ($sline =~ /^.\\s+[A-Za-z_][A-Za-z\\d_]*:(?!\\s*\\d+)/ &&\n\t\t    $sline !~ /^. [A-Za-z\\d_][A-Za-z\\d_]*:/ &&\n\t\t    $sline !~ /^.\\s+default:/) {\n\t\t\tif (WARN(\"INDENTED_LABEL\",\n\t\t\t\t \"labels should not be indented\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/^(.)\\s+/$1/;\n\t\t\t}\n\t\t}\n\n# check if a statement with a comma should be two statements like:\n#\tfoo = bar(),\t/* comma should be semicolon */\n#\tbar = baz();\n\t\tif (defined($stat) &&\n\t\t    $stat =~ /^\\+\\s*(?:$Lval\\s*$Assignment\\s*)?$FuncArg\\s*,\\s*(?:$Lval\\s*$Assignment\\s*)?$FuncArg\\s*;\\s*$/) {\n\t\t\tmy $cnt = statement_rawlines($stat);\n\t\t\tmy $herectx = get_stat_here($linenr, $cnt, $here);\n\t\t\tWARN(\"SUSPECT_COMMA_SEMICOLON\",\n\t\t\t     \"Possible comma where semicolon could be used\\n\" . $herectx);\n\t\t}\n\n# return is not a function\n\t\tif (defined($stat) && $stat =~ /^.\\s*return(\\s*)\\(/s) {\n\t\t\tmy $spacing = $1;\n\t\t\tif ($perl_version_ok &&\n\t\t\t    $stat =~ /^.\\s*return\\s*($balanced_parens)\\s*;\\s*$/) {\n\t\t\t\tmy $value = $1;\n\t\t\t\t$value = deparenthesize($value);\n\t\t\t\tif ($value =~ m/^\\s*$FuncArg\\s*(?:\\?|$)/) {\n\t\t\t\t\tERROR(\"RETURN_PARENTHESES\",\n\t\t\t\t\t      \"return is not a function, parentheses are not required\\n\" . $herecurr);\n\t\t\t\t}\n\t\t\t} elsif ($spacing !~ /\\s+/) {\n\t\t\t\tERROR(\"SPACING\",\n\t\t\t\t      \"space required before the open parenthesis '('\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# unnecessary return in a void function\n# at end-of-function, with the previous line a single leading tab, then return;\n# and the line before that not a goto label target like \"out:\"\n\t\tif ($sline =~ /^[ \\+]}\\s*$/ &&\n\t\t    $prevline =~ /^\\+\\treturn\\s*;\\s*$/ &&\n\t\t    $linenr >= 3 &&\n\t\t    $lines[$linenr - 3] =~ /^[ +]/ &&\n\t\t    $lines[$linenr - 3] !~ /^[ +]\\s*$Ident\\s*:/) {\n\t\t\tWARN(\"RETURN_VOID\",\n\t\t\t     \"void function return statements are not generally useful\\n\" . $hereprev);\n\t\t}\n\n# if statements using unnecessary parentheses - ie: if ((foo == bar))\n\t\tif ($perl_version_ok &&\n\t\t    $line =~ /\\bif\\s*((?:\\(\\s*){2,})/) {\n\t\t\tmy $openparens = $1;\n\t\t\tmy $count = $openparens =~ tr@\\(@\\(@;\n\t\t\tmy $msg = \"\";\n\t\t\tif ($line =~ /\\bif\\s*(?:\\(\\s*){$count,$count}$LvalOrFunc\\s*($Compare)\\s*$LvalOrFunc(?:\\s*\\)){$count,$count}/) {\n\t\t\t\tmy $comp = $4;\t#Not $1 because of $LvalOrFunc\n\t\t\t\t$msg = \" - maybe == should be = ?\" if ($comp eq \"==\");\n\t\t\t\tWARN(\"UNNECESSARY_PARENTHESES\",\n\t\t\t\t     \"Unnecessary parentheses$msg\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# comparisons with a constant or upper case identifier on the left\n#\tavoid cases like \"foo + BAR < baz\"\n#\tonly fix matches surrounded by parentheses to avoid incorrect\n#\tconversions like \"FOO < baz() + 5\" being \"misfixed\" to \"baz() > FOO + 5\"\n\t\tif ($perl_version_ok &&\n\t\t    $line =~ /^\\+(.*)\\b($Constant|[A-Z_][A-Z0-9_]*)\\s*($Compare)\\s*($LvalOrFunc)/) {\n\t\t\tmy $lead = $1;\n\t\t\tmy $const = $2;\n\t\t\tmy $comp = $3;\n\t\t\tmy $to = $4;\n\t\t\tmy $newcomp = $comp;\n\t\t\tif ($lead !~ /(?:$Operators|\\.)\\s*$/ &&\n\t\t\t    $to !~ /^(?:Constant|[A-Z_][A-Z0-9_]*)$/ &&\n\t\t\t    WARN(\"CONSTANT_COMPARISON\",\n\t\t\t\t \"Comparisons should place the constant on the right side of the test\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tif ($comp eq \"<\") {\n\t\t\t\t\t$newcomp = \">\";\n\t\t\t\t} elsif ($comp eq \"<=\") {\n\t\t\t\t\t$newcomp = \">=\";\n\t\t\t\t} elsif ($comp eq \">\") {\n\t\t\t\t\t$newcomp = \"<\";\n\t\t\t\t} elsif ($comp eq \">=\") {\n\t\t\t\t\t$newcomp = \"<=\";\n\t\t\t\t}\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\(\\s*\\Q$const\\E\\s*$Compare\\s*\\Q$to\\E\\s*\\)/($to $newcomp $const)/;\n\t\t\t}\n\t\t}\n\n# Return of what appears to be an errno should normally be negative\n\t\tif ($sline =~ /\\breturn(?:\\s*\\(+\\s*|\\s+)(E[A-Z]+)(?:\\s*\\)+\\s*|\\s*)[;:,]/) {\n\t\t\tmy $name = $1;\n\t\t\tif ($name ne 'EOF' && $name ne 'ERROR' && $name !~ /^EPOLL/) {\n\t\t\t\tWARN(\"USE_NEGATIVE_ERRNO\",\n\t\t\t\t     \"return of an errno should typically be negative (ie: return -$1)\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# Need a space before open parenthesis after if, while etc\n\t\tif ($line =~ /\\b(if|while|for|switch)\\(/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"space required before the open parenthesis '('\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/\\b(if|while|for|switch)\\(/$1 \\(/;\n\t\t\t}\n\t\t}\n\n# Check for illegal assignment in if conditional -- and check for trailing\n# statements after the conditional.\n\t\tif ($line =~ /do\\s*(?!{)/) {\n\t\t\t($stat, $cond, $line_nr_next, $remain_next, $off_next) =\n\t\t\t\tctx_statement_block($linenr, $realcnt, 0)\n\t\t\t\t\tif (!defined $stat);\n\t\t\tmy ($stat_next) = ctx_statement_block($line_nr_next,\n\t\t\t\t\t\t$remain_next, $off_next);\n\t\t\t$stat_next =~ s/\\n./\\n /g;\n\t\t\t##print \"stat<$stat> stat_next<$stat_next>\\n\";\n\n\t\t\tif ($stat_next =~ /^\\s*while\\b/) {\n\t\t\t\t# If the statement carries leading newlines,\n\t\t\t\t# then count those as offsets.\n\t\t\t\tmy ($whitespace) =\n\t\t\t\t\t($stat_next =~ /^((?:\\s*\\n[+-])*\\s*)/s);\n\t\t\t\tmy $offset =\n\t\t\t\t\tstatement_rawlines($whitespace) - 1;\n\n\t\t\t\t$suppress_whiletrailers{$line_nr_next +\n\t\t\t\t\t\t\t\t$offset} = 1;\n\t\t\t}\n\t\t}\n\t\tif (!defined $suppress_whiletrailers{$linenr} &&\n\t\t    defined($stat) && defined($cond) &&\n\t\t    $line =~ /\\b(?:if|while|for)\\s*\\(/ && $line !~ /^.\\s*#/) {\n\t\t\tmy ($s, $c) = ($stat, $cond);\n\t\t\tmy $fixed_assign_in_if = 0;\n\n\t\t\tif ($c =~ /\\bif\\s*\\(.*[^<>!=]=[^=].*/s) {\n\t\t\t\tif (ERROR(\"ASSIGN_IN_IF\",\n\t\t\t\t\t  \"do not use assignment in if condition\\n\" . $herecurr) &&\n\t\t\t\t    $fix && $perl_version_ok) {\n\t\t\t\t\tif ($rawline =~ /^\\+(\\s+)if\\s*\\(\\s*(\\!)?\\s*\\(\\s*(($Lval)\\s*=\\s*$LvalOrFunc)\\s*\\)\\s*(?:($Compare)\\s*($FuncArg))?\\s*\\)\\s*(\\{)?\\s*$/) {\n\t\t\t\t\t\tmy $space = $1;\n\t\t\t\t\t\tmy $not = $2;\n\t\t\t\t\t\tmy $statement = $3;\n\t\t\t\t\t\tmy $assigned = $4;\n\t\t\t\t\t\tmy $test = $8;\n\t\t\t\t\t\tmy $against = $9;\n\t\t\t\t\t\tmy $brace = $15;\n\t\t\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\t\t\tfix_insert_line($fixlinenr, \"$space$statement;\");\n\t\t\t\t\t\tmy $newline = \"${space}if (\";\n\t\t\t\t\t\t$newline .= '!' if defined($not);\n\t\t\t\t\t\t$newline .= '(' if (defined $not && defined($test) && defined($against));\n\t\t\t\t\t\t$newline .= \"$assigned\";\n\t\t\t\t\t\t$newline .= \" $test $against\" if (defined($test) && defined($against));\n\t\t\t\t\t\t$newline .= ')' if (defined $not && defined($test) && defined($against));\n\t\t\t\t\t\t$newline .= ')';\n\t\t\t\t\t\t$newline .= \" {\" if (defined($brace));\n\t\t\t\t\t\tfix_insert_line($fixlinenr + 1, $newline);\n\t\t\t\t\t\t$fixed_assign_in_if = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t# Find out what is on the end of the line after the\n\t\t\t# conditional.\n\t\t\tsubstr($s, 0, length($c), '');\n\t\t\t$s =~ s/\\n.*//g;\n\t\t\t$s =~ s/$;//g;\t# Remove any comments\n\t\t\tif (length($c) && $s !~ /^\\s*{?\\s*\\\\*\\s*$/ &&\n\t\t\t    $c !~ /}\\s*while\\s*/)\n\t\t\t{\n\t\t\t\t# Find out how long the conditional actually is.\n\t\t\t\tmy @newlines = ($c =~ /\\n/gs);\n\t\t\t\tmy $cond_lines = 1 + $#newlines;\n\t\t\t\tmy $stat_real = '';\n\n\t\t\t\t$stat_real = raw_line($linenr, $cond_lines)\n\t\t\t\t\t\t\t. \"\\n\" if ($cond_lines);\n\t\t\t\tif (defined($stat_real) && $cond_lines > 1) {\n\t\t\t\t\t$stat_real = \"[...]\\n$stat_real\";\n\t\t\t\t}\n\n\t\t\t\tif (ERROR(\"TRAILING_STATEMENTS\",\n\t\t\t\t\t  \"trailing statements should be on next line\\n\" . $herecurr . $stat_real) &&\n\t\t\t\t    !$fixed_assign_in_if &&\n\t\t\t\t    $cond_lines == 0 &&\n\t\t\t\t    $fix && $perl_version_ok &&\n\t\t\t\t    $fixed[$fixlinenr] =~ /^\\+(\\s*)((?:if|while|for)\\s*$balanced_parens)\\s*(.*)$/) {\n\t\t\t\t\tmy $indent = $1;\n\t\t\t\t\tmy $test = $2;\n\t\t\t\t\tmy $rest = rtrim($4);\n\t\t\t\t\tif ($rest =~ /;$/) {\n\t\t\t\t\t\t$fixed[$fixlinenr] = \"\\+$indent$test\";\n\t\t\t\t\t\tfix_insert_line($fixlinenr + 1, \"$indent\\t$rest\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# Check for bitwise tests written as boolean\n\t\tif ($line =~ /\n\t\t\t(?:\n\t\t\t\t(?:\\[|\\(|\\&\\&|\\|\\|)\n\t\t\t\t\\s*0[xX][0-9]+\\s*\n\t\t\t\t(?:\\&\\&|\\|\\|)\n\t\t\t|\n\t\t\t\t(?:\\&\\&|\\|\\|)\n\t\t\t\t\\s*0[xX][0-9]+\\s*\n\t\t\t\t(?:\\&\\&|\\|\\||\\)|\\])\n\t\t\t)/x)\n\t\t{\n\t\t\tWARN(\"HEXADECIMAL_BOOLEAN_TEST\",\n\t\t\t     \"boolean test with hexadecimal, perhaps just 1 \\& or \\|?\\n\" . $herecurr);\n\t\t}\n\n# if and else should not have general statements after it\n\t\tif ($line =~ /^.\\s*(?:}\\s*)?else\\b(.*)/) {\n\t\t\tmy $s = $1;\n\t\t\t$s =~ s/$;//g;\t# Remove any comments\n\t\t\tif ($s !~ /^\\s*(?:\\sif|(?:{|)\\s*\\\\?\\s*$)/) {\n\t\t\t\tERROR(\"TRAILING_STATEMENTS\",\n\t\t\t\t      \"trailing statements should be on next line\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n# if should not continue a brace\n\t\tif ($line =~ /}\\s*if\\b/) {\n\t\t\tERROR(\"TRAILING_STATEMENTS\",\n\t\t\t      \"trailing statements should be on next line (or did you mean 'else if'?)\\n\" .\n\t\t\t\t$herecurr);\n\t\t}\n# case and default should not have general statements after them\n\t\tif ($line =~ /^.\\s*(?:case\\s*.*|default\\s*):/g &&\n\t\t    $line !~ /\\G(?:\n\t\t\t(?:\\s*$;*)(?:\\s*{)?(?:\\s*$;*)(?:\\s*\\\\)?\\s*$|\n\t\t\t\\s*return\\s+\n\t\t    )/xg)\n\t\t{\n\t\t\tERROR(\"TRAILING_STATEMENTS\",\n\t\t\t      \"trailing statements should be on next line\\n\" . $herecurr);\n\t\t}\n\n\t\t# Check for }<nl>else {, these must be at the same\n\t\t# indent level to be relevant to each other.\n\t\tif ($prevline=~/}\\s*$/ and $line=~/^.\\s*else\\s*/ &&\n\t\t    $previndent == $indent) {\n\t\t\tif (ERROR(\"ELSE_AFTER_BRACE\",\n\t\t\t\t  \"else should follow close brace '}'\\n\" . $hereprev) &&\n\t\t\t    $fix && $prevline =~ /^\\+/ && $line =~ /^\\+/) {\n\t\t\t\tfix_delete_line($fixlinenr - 1, $prevrawline);\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\tmy $fixedline = $prevrawline;\n\t\t\t\t$fixedline =~ s/}\\s*$//;\n\t\t\t\tif ($fixedline !~ /^\\+\\s*$/) {\n\t\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t\t}\n\t\t\t\t$fixedline = $rawline;\n\t\t\t\t$fixedline =~ s/^(.\\s*)else/$1} else/;\n\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t}\n\t\t}\n\n\t\tif ($prevline=~/}\\s*$/ and $line=~/^.\\s*while\\s*/ &&\n\t\t    $previndent == $indent) {\n\t\t\tmy ($s, $c) = ctx_statement_block($linenr, $realcnt, 0);\n\n\t\t\t# Find out what is on the end of the line after the\n\t\t\t# conditional.\n\t\t\tsubstr($s, 0, length($c), '');\n\t\t\t$s =~ s/\\n.*//g;\n\n\t\t\tif ($s =~ /^\\s*;/) {\n\t\t\t\tif (ERROR(\"WHILE_AFTER_BRACE\",\n\t\t\t\t\t  \"while should follow close brace '}'\\n\" . $hereprev) &&\n\t\t\t\t    $fix && $prevline =~ /^\\+/ && $line =~ /^\\+/) {\n\t\t\t\t\tfix_delete_line($fixlinenr - 1, $prevrawline);\n\t\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\t\tmy $fixedline = $prevrawline;\n\t\t\t\t\tmy $trailing = $rawline;\n\t\t\t\t\t$trailing =~ s/^\\+//;\n\t\t\t\t\t$trailing = trim($trailing);\n\t\t\t\t\t$fixedline =~ s/}\\s*$/} $trailing/;\n\t\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#Specific variable tests\n\t\twhile ($line =~ m{($Constant|$Lval)}g) {\n\t\t\tmy $var = $1;\n\n#CamelCase\n\t\t\tif ($var !~ /^$Constant$/ &&\n\t\t\t    $var =~ /[A-Z][a-z]|[a-z][A-Z]/ &&\n#Ignore some autogenerated defines and enum values\n\t\t\t    $var !~ /^(?:[A-Z]+_){1,5}[A-Z]{1,3}[a-z]/ &&\n#Ignore Page<foo> variants\n\t\t\t    $var !~ /^(?:Clear|Set|TestClear|TestSet|)Page[A-Z]/ &&\n#Ignore ETHTOOL_LINK_MODE_<foo> variants\n\t\t\t    $var !~ /^ETHTOOL_LINK_MODE_/ &&\n#Ignore SI style variants like nS, mV and dB\n#(ie: max_uV, regulator_min_uA_show, RANGE_mA_VALUE)\n\t\t\t    $var !~ /^(?:[a-z0-9_]*|[A-Z0-9_]*)?_?[a-z][A-Z](?:_[a-z0-9_]+|_[A-Z0-9_]+)?$/ &&\n#Ignore some three character SI units explicitly, like MiB and KHz\n\t\t\t    $var !~ /^(?:[a-z_]*?)_?(?:[KMGT]iB|[KMGT]?Hz)(?:_[a-z_]+)?$/) {\n\t\t\t\twhile ($var =~ m{\\b($Ident)}g) {\n\t\t\t\t\tmy $word = $1;\n\t\t\t\t\tnext if ($word !~ /[A-Z][a-z]|[a-z][A-Z]/);\n\t\t\t\t\tif ($check) {\n\t\t\t\t\t\tseed_camelcase_includes();\n\t\t\t\t\t\tif (!$file && !$camelcase_file_seeded) {\n\t\t\t\t\t\t\tseed_camelcase_file($realfile);\n\t\t\t\t\t\t\t$camelcase_file_seeded = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!defined $camelcase{$word}) {\n\t\t\t\t\t\t$camelcase{$word} = 1;\n\t\t\t\t\t\tCHK(\"CAMELCASE\",\n\t\t\t\t\t\t    \"Avoid CamelCase: <$word>\\n\" . $herecurr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#no spaces allowed after \\ in define\n\t\tif ($line =~ /\\#\\s*define.*\\\\\\s+$/) {\n\t\t\tif (WARN(\"WHITESPACE_AFTER_LINE_CONTINUATION\",\n\t\t\t\t \"Whitespace after \\\\ makes next lines useless\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\s+$//;\n\t\t\t}\n\t\t}\n\n# warn if <asm/foo.h> is #included and <linux/foo.h> is available and includes\n# itself <asm/foo.h> (uses RAW line)\n\t\tif ($tree && $rawline =~ m{^.\\s*\\#\\s*include\\s*\\<asm\\/(.*)\\.h\\>}) {\n\t\t\tmy $file = \"$1.h\";\n\t\t\tmy $checkfile = \"include/linux/$file\";\n\t\t\tif (-f \"$root/$checkfile\" &&\n\t\t\t    $realfile ne $checkfile &&\n\t\t\t    $1 !~ /$allowed_asm_includes/)\n\t\t\t{\n\t\t\t\tmy $asminclude = `grep -Ec \"#include\\\\s+<asm/$file>\" $root/$checkfile`;\n\t\t\t\tif ($asminclude > 0) {\n\t\t\t\t\tif ($realfile =~ m{^arch/}) {\n\t\t\t\t\t\tCHK(\"ARCH_INCLUDE_LINUX\",\n\t\t\t\t\t\t    \"Consider using #include <linux/$file> instead of <asm/$file>\\n\" . $herecurr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tWARN(\"INCLUDE_LINUX\",\n\t\t\t\t\t\t     \"Use #include <linux/$file> instead of <asm/$file>\\n\" . $herecurr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# multi-statement macros should be enclosed in a do while loop, grab the\n# first statement and ensure its the whole macro if its not enclosed\n# in a known good container\n\t\tif ($realfile !~ m@/vmlinux.lds.h$@ &&\n\t\t    $line =~ /^.\\s*\\#\\s*define\\s*$Ident(\\()?/) {\n\t\t\tmy $ln = $linenr;\n\t\t\tmy $cnt = $realcnt;\n\t\t\tmy ($off, $dstat, $dcond, $rest);\n\t\t\tmy $ctx = '';\n\t\t\tmy $has_flow_statement = 0;\n\t\t\tmy $has_arg_concat = 0;\n\t\t\t($dstat, $dcond, $ln, $cnt, $off) =\n\t\t\t\tctx_statement_block($linenr, $realcnt, 0);\n\t\t\t$ctx = $dstat;\n\t\t\t#print \"dstat<$dstat> dcond<$dcond> cnt<$cnt> off<$off>\\n\";\n\t\t\t#print \"LINE<$lines[$ln-1]> len<\" . length($lines[$ln-1]) . \"\\n\";\n\n\t\t\t$has_flow_statement = 1 if ($ctx =~ /\\b(goto|return)\\b/);\n\t\t\t$has_arg_concat = 1 if ($ctx =~ /\\#\\#/ && $ctx !~ /\\#\\#\\s*(?:__VA_ARGS__|args)\\b/);\n\n\t\t\t$dstat =~ s/^.\\s*\\#\\s*define\\s+$Ident(\\([^\\)]*\\))?\\s*//;\n\t\t\tmy $define_args = $1;\n\t\t\tmy $define_stmt = $dstat;\n\t\t\tmy @def_args = ();\n\n\t\t\tif (defined $define_args && $define_args ne \"\") {\n\t\t\t\t$define_args = substr($define_args, 1, length($define_args) - 2);\n\t\t\t\t$define_args =~ s/\\s*//g;\n\t\t\t\t$define_args =~ s/\\\\\\+?//g;\n\t\t\t\t@def_args = split(\",\", $define_args);\n\t\t\t}\n\n\t\t\t$dstat =~ s/$;//g;\n\t\t\t$dstat =~ s/\\\\\\n.//g;\n\t\t\t$dstat =~ s/^\\s*//s;\n\t\t\t$dstat =~ s/\\s*$//s;\n\n\t\t\t# Flatten any parentheses and braces\n\t\t\twhile ($dstat =~ s/\\([^\\(\\)]*\\)/1u/ ||\n\t\t\t       $dstat =~ s/\\{[^\\{\\}]*\\}/1u/ ||\n\t\t\t       $dstat =~ s/.\\[[^\\[\\]]*\\]/1u/)\n\t\t\t{\n\t\t\t}\n\n\t\t\t# Flatten any obvious string concatenation.\n\t\t\twhile ($dstat =~ s/($String)\\s*$Ident/$1/ ||\n\t\t\t       $dstat =~ s/$Ident\\s*($String)/$1/)\n\t\t\t{\n\t\t\t}\n\n\t\t\t# Make asm volatile uses seem like a generic function\n\t\t\t$dstat =~ s/\\b_*asm_*\\s+_*volatile_*\\b/asm_volatile/g;\n\n\t\t\tmy $exceptions = qr{\n\t\t\t\t$Declare|\n\t\t\t\tmodule_param_named|\n\t\t\t\tMODULE_PARM_DESC|\n\t\t\t\tDECLARE_PER_CPU|\n\t\t\t\tDEFINE_PER_CPU|\n\t\t\t\t__typeof__\\(|\n\t\t\t\tunion|\n\t\t\t\tstruct|\n\t\t\t\t\\.$Ident\\s*=\\s*|\n\t\t\t\t^\\\"|\\\"$|\n\t\t\t\t^\\[\n\t\t\t}x;\n\t\t\t#print \"REST<$rest> dstat<$dstat> ctx<$ctx>\\n\";\n\n\t\t\t$ctx =~ s/\\n*$//;\n\t\t\tmy $stmt_cnt = statement_rawlines($ctx);\n\t\t\tmy $herectx = get_stat_here($linenr, $stmt_cnt, $here);\n\n\t\t\tif ($dstat ne '' &&\n\t\t\t    $dstat !~ /^(?:$Ident|-?$Constant),$/ &&\t\t\t# 10, // foo(),\n\t\t\t    $dstat !~ /^(?:$Ident|-?$Constant);$/ &&\t\t\t# foo();\n\t\t\t    $dstat !~ /^[!~-]?(?:$Lval|$Constant)$/ &&\t\t# 10 // foo() // !foo // ~foo // -foo // foo->bar // foo.bar->baz\n\t\t\t    $dstat !~ /^'X'$/ && $dstat !~ /^'XX'$/ &&\t\t\t# character constants\n\t\t\t    $dstat !~ /$exceptions/ &&\n\t\t\t    $dstat !~ /^\\.$Ident\\s*=/ &&\t\t\t\t# .foo =\n\t\t\t    $dstat !~ /^(?:\\#\\s*$Ident|\\#\\s*$Constant)\\s*$/ &&\t\t# stringification #foo\n\t\t\t    $dstat !~ /^case\\b/ &&\t\t\t\t\t# case ...\n\t\t\t    $dstat !~ /^do\\s*$Constant\\s*while\\s*$Constant;?$/ &&\t# do {...} while (...); // do {...} while (...)\n\t\t\t    $dstat !~ /^while\\s*$Constant\\s*$Constant\\s*$/ &&\t\t# while (...) {...}\n\t\t\t    $dstat !~ /^for\\s*$Constant$/ &&\t\t\t\t# for (...)\n\t\t\t    $dstat !~ /^for\\s*$Constant\\s+(?:$Ident|-?$Constant)$/ &&\t# for (...) bar()\n\t\t\t    $dstat !~ /^do\\s*{/ &&\t\t\t\t\t# do {...\n\t\t\t    $dstat !~ /^\\(\\{/ &&\t\t\t\t\t\t# ({...\n\t\t\t    $ctx !~ /^.\\s*#\\s*define\\s+TRACE_(?:SYSTEM|INCLUDE_FILE|INCLUDE_PATH)\\b/)\n\t\t\t{\n\t\t\t\tif ($dstat =~ /^\\s*if\\b/) {\n\t\t\t\t\tERROR(\"MULTISTATEMENT_MACRO_USE_DO_WHILE\",\n\t\t\t\t\t      \"Macros starting with if should be enclosed by a do - while loop to avoid possible if/else logic defects\\n\" . \"$herectx\");\n\t\t\t\t} elsif ($dstat =~ /;/) {\n\t\t\t\t\tERROR(\"MULTISTATEMENT_MACRO_USE_DO_WHILE\",\n\t\t\t\t\t      \"Macros with multiple statements should be enclosed in a do - while loop\\n\" . \"$herectx\");\n\t\t\t\t} else {\n\t\t\t\t\tERROR(\"COMPLEX_MACRO\",\n\t\t\t\t\t      \"Macros with complex values should be enclosed in parentheses\\n\" . \"$herectx\");\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t# Make $define_stmt single line, comment-free, etc\n\t\t\tmy @stmt_array = split('\\n', $define_stmt);\n\t\t\tmy $first = 1;\n\t\t\t$define_stmt = \"\";\n\t\t\tforeach my $l (@stmt_array) {\n\t\t\t\t$l =~ s/\\\\$//;\n\t\t\t\tif ($first) {\n\t\t\t\t\t$define_stmt = $l;\n\t\t\t\t\t$first = 0;\n\t\t\t\t} elsif ($l =~ /^[\\+ ]/) {\n\t\t\t\t\t$define_stmt .= substr($l, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$define_stmt =~ s/$;//g;\n\t\t\t$define_stmt =~ s/\\s+/ /g;\n\t\t\t$define_stmt = trim($define_stmt);\n\n# check if any macro arguments are reused (ignore '...' and 'type')\n\t\t\tforeach my $arg (@def_args) {\n\t\t\t        next if ($arg =~ /\\.\\.\\./);\n\t\t\t        next if ($arg =~ /^type$/i);\n\t\t\t\tmy $tmp_stmt = $define_stmt;\n\t\t\t\t$tmp_stmt =~ s/\\b(__must_be_array|offsetof|sizeof|sizeof_field|__stringify|typeof|__typeof__|__builtin\\w+|typecheck\\s*\\(\\s*$Type\\s*,|\\#+)\\s*\\(*\\s*$arg\\s*\\)*\\b//g;\n\t\t\t\t$tmp_stmt =~ s/\\#+\\s*$arg\\b//g;\n\t\t\t\t$tmp_stmt =~ s/\\b$arg\\s*\\#\\#//g;\n\t\t\t\tmy $use_cnt = () = $tmp_stmt =~ /\\b$arg\\b/g;\n\t\t\t\tif ($use_cnt > 1) {\n\t\t\t\t\tCHK(\"MACRO_ARG_REUSE\",\n\t\t\t\t\t    \"Macro argument reuse '$arg' - possible side-effects?\\n\" . \"$herectx\");\n\t\t\t\t    }\n# check if any macro arguments may have other precedence issues\n\t\t\t\tif ($tmp_stmt =~ m/($Operators)?\\s*\\b$arg\\b\\s*($Operators)?/m &&\n\t\t\t\t    ((defined($1) && $1 ne ',') ||\n\t\t\t\t     (defined($2) && $2 ne ','))) {\n\t\t\t\t\tCHK(\"MACRO_ARG_PRECEDENCE\",\n\t\t\t\t\t    \"Macro argument '$arg' may be better as '($arg)' to avoid precedence issues\\n\" . \"$herectx\");\n\t\t\t\t}\n\n# check if this is an unused argument\n\t\t\t\tif ($define_stmt !~ /\\b$arg\\b/) {\n\t\t\t\t\tWARN(\"MACRO_ARG_UNUSED\",\n\t\t\t\t\t     \"Argument '$arg' is not used in function-like macro\\n\" . \"$herectx\");\n\t\t\t\t}\n\t\t\t}\n\n# check for macros with flow control, but without ## concatenation\n# ## concatenation is commonly a macro that defines a function so ignore those\n\t\t\tif ($has_flow_statement && !$has_arg_concat) {\n\t\t\t\tmy $cnt = statement_rawlines($ctx);\n\t\t\t\tmy $herectx = get_stat_here($linenr, $cnt, $here);\n\n\t\t\t\tWARN(\"MACRO_WITH_FLOW_CONTROL\",\n\t\t\t\t     \"Macros with flow control statements should be avoided\\n\" . \"$herectx\");\n\t\t\t}\n\n# check for line continuations outside of #defines, preprocessor #, and asm\n\n\t\t} elsif ($realfile =~ m@/vmlinux.lds.h$@) {\n\t\t    $line =~ s/(\\w+)/$maybe_linker_symbol{$1}++/ge;\n\t\t    #print \"REAL: $realfile\\nln: $line\\nkeys:\", sort keys %maybe_linker_symbol;\n\t\t} else {\n\t\t\tif ($prevline !~ /^..*\\\\$/ &&\n\t\t\t    $line !~ /^\\+\\s*\\#.*\\\\$/ &&\t\t# preprocessor\n\t\t\t    $line !~ /^\\+.*\\b(__asm__|asm)\\b.*\\\\$/ &&\t# asm\n\t\t\t    $line =~ /^\\+.*\\\\$/) {\n\t\t\t\tWARN(\"LINE_CONTINUATIONS\",\n\t\t\t\t     \"Avoid unnecessary line continuations\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# do {} while (0) macro tests:\n# single-statement macros do not need to be enclosed in do while (0) loop,\n# macro should not end with a semicolon\n\t\tif ($perl_version_ok &&\n\t\t    $realfile !~ m@/vmlinux.lds.h$@ &&\n\t\t    $line =~ /^.\\s*\\#\\s*define\\s+$Ident(\\()?/) {\n\t\t\tmy $ln = $linenr;\n\t\t\tmy $cnt = $realcnt;\n\t\t\tmy ($off, $dstat, $dcond, $rest);\n\t\t\tmy $ctx = '';\n\t\t\t($dstat, $dcond, $ln, $cnt, $off) =\n\t\t\t\tctx_statement_block($linenr, $realcnt, 0);\n\t\t\t$ctx = $dstat;\n\n\t\t\t$dstat =~ s/\\\\\\n.//g;\n\t\t\t$dstat =~ s/$;/ /g;\n\n\t\t\tif ($dstat =~ /^\\+\\s*#\\s*define\\s+$Ident\\s*${balanced_parens}\\s*do\\s*{(.*)\\s*}\\s*while\\s*\\(\\s*0\\s*\\)\\s*([;\\s]*)\\s*$/) {\n\t\t\t\tmy $stmts = $2;\n\t\t\t\tmy $semis = $3;\n\n\t\t\t\t$ctx =~ s/\\n*$//;\n\t\t\t\tmy $cnt = statement_rawlines($ctx);\n\t\t\t\tmy $herectx = get_stat_here($linenr, $cnt, $here);\n\n\t\t\t\tif (($stmts =~ tr/;/;/) == 1 &&\n\t\t\t\t    $stmts !~ /^\\s*(if|while|for|switch)\\b/) {\n\t\t\t\t\tWARN(\"SINGLE_STATEMENT_DO_WHILE_MACRO\",\n\t\t\t\t\t     \"Single statement macros should not use a do {} while (0) loop\\n\" . \"$herectx\");\n\t\t\t\t}\n\t\t\t\tif (defined $semis && $semis ne \"\") {\n\t\t\t\t\tWARN(\"DO_WHILE_MACRO_WITH_TRAILING_SEMICOLON\",\n\t\t\t\t\t     \"do {} while (0) macros should not be semicolon terminated\\n\" . \"$herectx\");\n\t\t\t\t}\n\t\t\t} elsif ($dstat =~ /^\\+\\s*#\\s*define\\s+$Ident.*;\\s*$/) {\n\t\t\t\t$ctx =~ s/\\n*$//;\n\t\t\t\tmy $cnt = statement_rawlines($ctx);\n\t\t\t\tmy $herectx = get_stat_here($linenr, $cnt, $here);\n\n\t\t\t\tWARN(\"TRAILING_SEMICOLON\",\n\t\t\t\t     \"macros should not use a trailing semicolon\\n\" . \"$herectx\");\n\t\t\t}\n\t\t}\n\n# check for redundant bracing round if etc\n\t\tif ($line =~ /(^.*)\\bif\\b/ && $1 !~ /else\\s*$/) {\n\t\t\tmy ($level, $endln, @chunks) =\n\t\t\t\tctx_statement_full($linenr, $realcnt, 1);\n\t\t\t#print \"chunks<$#chunks> linenr<$linenr> endln<$endln> level<$level>\\n\";\n\t\t\t#print \"APW: <<$chunks[1][0]>><<$chunks[1][1]>>\\n\";\n\t\t\tif ($#chunks > 0 && $level == 0) {\n\t\t\t\tmy @allowed = ();\n\t\t\t\tmy $allow = 0;\n\t\t\t\tmy $seen = 0;\n\t\t\t\tmy $herectx = $here . \"\\n\";\n\t\t\t\tmy $ln = $linenr - 1;\n\t\t\t\tfor my $chunk (@chunks) {\n\t\t\t\t\tmy ($cond, $block) = @{$chunk};\n\n\t\t\t\t\t# If the condition carries leading newlines, then count those as offsets.\n\t\t\t\t\tmy ($whitespace) = ($cond =~ /^((?:\\s*\\n[+-])*\\s*)/s);\n\t\t\t\t\tmy $offset = statement_rawlines($whitespace) - 1;\n\n\t\t\t\t\t$allowed[$allow] = 0;\n\t\t\t\t\t#print \"COND<$cond> whitespace<$whitespace> offset<$offset>\\n\";\n\n\t\t\t\t\t# We have looked at and allowed this specific line.\n\t\t\t\t\t$suppress_ifbraces{$ln + $offset} = 1;\n\n\t\t\t\t\t$herectx .= \"$rawlines[$ln + $offset]\\n[...]\\n\";\n\t\t\t\t\t$ln += statement_rawlines($block) - 1;\n\n\t\t\t\t\tsubstr($block, 0, length($cond), '');\n\n\t\t\t\t\t$seen++ if ($block =~ /^\\s*{/);\n\n\t\t\t\t\t#print \"cond<$cond> block<$block> allowed<$allowed[$allow]>\\n\";\n\t\t\t\t\tif (statement_lines($cond) > 1) {\n\t\t\t\t\t\t#print \"APW: ALLOWED: cond<$cond>\\n\";\n\t\t\t\t\t\t$allowed[$allow] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif ($block =~/\\b(?:if|for|while)\\b/) {\n\t\t\t\t\t\t#print \"APW: ALLOWED: block<$block>\\n\";\n\t\t\t\t\t\t$allowed[$allow] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (statement_block_size($block) > 1) {\n\t\t\t\t\t\t#print \"APW: ALLOWED: lines block<$block>\\n\";\n\t\t\t\t\t\t$allowed[$allow] = 1;\n\t\t\t\t\t}\n\t\t\t\t\t$allow++;\n\t\t\t\t}\n\t\t\t\tif ($seen) {\n\t\t\t\t\tmy $sum_allowed = 0;\n\t\t\t\t\tforeach (@allowed) {\n\t\t\t\t\t\t$sum_allowed += $_;\n\t\t\t\t\t}\n\t\t\t\t\tif ($sum_allowed == 0) {\n\t\t\t\t\t\tWARN(\"BRACES\",\n\t\t\t\t\t\t     \"braces {} are not necessary for any arm of this statement\\n\" . $herectx);\n\t\t\t\t\t} elsif ($sum_allowed != $allow &&\n\t\t\t\t\t\t $seen != $allow) {\n\t\t\t\t\t\tCHK(\"BRACES\",\n\t\t\t\t\t\t    \"braces {} should be used on all arms of this statement\\n\" . $herectx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!defined $suppress_ifbraces{$linenr - 1} &&\n\t\t\t\t\t$line =~ /\\b(if|while|for|else)\\b/) {\n\t\t\tmy $allowed = 0;\n\n\t\t\t# Check the pre-context.\n\t\t\tif (substr($line, 0, $-[0]) =~ /(\\}\\s*)$/) {\n\t\t\t\t#print \"APW: ALLOWED: pre<$1>\\n\";\n\t\t\t\t$allowed = 1;\n\t\t\t}\n\n\t\t\tmy ($level, $endln, @chunks) =\n\t\t\t\tctx_statement_full($linenr, $realcnt, $-[0]);\n\n\t\t\t# Check the condition.\n\t\t\tmy ($cond, $block) = @{$chunks[0]};\n\t\t\t#print \"CHECKING<$linenr> cond<$cond> block<$block>\\n\";\n\t\t\tif (defined $cond) {\n\t\t\t\tsubstr($block, 0, length($cond), '');\n\t\t\t}\n\t\t\tif (statement_lines($cond) > 1) {\n\t\t\t\t#print \"APW: ALLOWED: cond<$cond>\\n\";\n\t\t\t\t$allowed = 1;\n\t\t\t}\n\t\t\tif ($block =~/\\b(?:if|for|while)\\b/) {\n\t\t\t\t#print \"APW: ALLOWED: block<$block>\\n\";\n\t\t\t\t$allowed = 1;\n\t\t\t}\n\t\t\tif (statement_block_size($block) > 1) {\n\t\t\t\t#print \"APW: ALLOWED: lines block<$block>\\n\";\n\t\t\t\t$allowed = 1;\n\t\t\t}\n\t\t\t# Check the post-context.\n\t\t\tif (defined $chunks[1]) {\n\t\t\t\tmy ($cond, $block) = @{$chunks[1]};\n\t\t\t\tif (defined $cond) {\n\t\t\t\t\tsubstr($block, 0, length($cond), '');\n\t\t\t\t}\n\t\t\t\tif ($block =~ /^\\s*\\{/) {\n\t\t\t\t\t#print \"APW: ALLOWED: chunk-1 block<$block>\\n\";\n\t\t\t\t\t$allowed = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($level == 0 && $block =~ /^\\s*\\{/ && !$allowed) {\n\t\t\t\tmy $cnt = statement_rawlines($block);\n\t\t\t\tmy $herectx = get_stat_here($linenr, $cnt, $here);\n\n\t\t\t\tWARN(\"BRACES\",\n\t\t\t\t     \"braces {} are not necessary for single statement blocks\\n\" . $herectx);\n\t\t\t}\n\t\t}\n\n# check for single line unbalanced braces\n\t\tif ($sline =~ /^.\\s*\\}\\s*else\\s*$/ ||\n\t\t    $sline =~ /^.\\s*else\\s*\\{\\s*$/) {\n\t\t\tCHK(\"BRACES\", \"Unbalanced braces around else statement\\n\" . $herecurr);\n\t\t}\n\n# check for unnecessary blank lines around braces\n\t\tif (($line =~ /^.\\s*}\\s*$/ && $prevrawline =~ /^.\\s*$/)) {\n\t\t\tif (CHK(\"BRACES\",\n\t\t\t\t\"Blank lines aren't necessary before a close brace '}'\\n\" . $hereprev) &&\n\t\t\t    $fix && $prevrawline =~ /^\\+/) {\n\t\t\t\tfix_delete_line($fixlinenr - 1, $prevrawline);\n\t\t\t}\n\t\t}\n\t\tif (($rawline =~ /^.\\s*$/ && $prevline =~ /^..*{\\s*$/)) {\n\t\t\tif (CHK(\"BRACES\",\n\t\t\t\t\"Blank lines aren't necessary after an open brace '{'\\n\" . $hereprev) &&\n\t\t\t    $fix) {\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t}\n\t\t}\n\n# no volatiles please\n\t\tmy $asm_volatile = qr{\\b(__asm__|asm)\\s+(__volatile__|volatile)\\b};\n\t\tif ($line =~ /\\bvolatile\\b/ && $line !~ /$asm_volatile/) {\n\t\t\tWARN(\"VOLATILE\",\n\t\t\t     \"Use of volatile is usually wrong: see Documentation/process/volatile-considered-harmful.rst\\n\" . $herecurr);\n\t\t}\n\n# Check for user-visible strings broken across lines, which breaks the ability\n# to grep for the string.  Make exceptions when the previous string ends in a\n# newline (multiple lines in one string constant) or '\\t', '\\r', ';', or '{'\n# (common in inline assembly) or is a octal \\123 or hexadecimal \\xaf value\n\t\tif ($line =~ /^\\+\\s*$String/ &&\n\t\t    $prevline =~ /\"\\s*$/ &&\n\t\t    $prevrawline !~ /(?:\\\\(?:[ntr]|[0-7]{1,3}|x[0-9a-fA-F]{1,2})|;\\s*|\\{\\s*)\"\\s*$/) {\n\t\t\tif (WARN(\"SPLIT_STRING\",\n\t\t\t\t \"quoted string split across lines\\n\" . $hereprev) &&\n\t\t\t\t     $fix &&\n\t\t\t\t     $prevrawline =~ /^\\+.*\"\\s*$/ &&\n\t\t\t\t     $last_coalesced_string_linenr != $linenr - 1) {\n\t\t\t\tmy $extracted_string = get_quoted_string($line, $rawline);\n\t\t\t\tmy $comma_close = \"\";\n\t\t\t\tif ($rawline =~ /\\Q$extracted_string\\E(\\s*\\)\\s*;\\s*$|\\s*,\\s*)/) {\n\t\t\t\t\t$comma_close = $1;\n\t\t\t\t}\n\n\t\t\t\tfix_delete_line($fixlinenr - 1, $prevrawline);\n\t\t\t\tfix_delete_line($fixlinenr, $rawline);\n\t\t\t\tmy $fixedline = $prevrawline;\n\t\t\t\t$fixedline =~ s/\"\\s*$//;\n\t\t\t\t$fixedline .= substr($extracted_string, 1) . trim($comma_close);\n\t\t\t\tfix_insert_line($fixlinenr - 1, $fixedline);\n\t\t\t\t$fixedline = $rawline;\n\t\t\t\t$fixedline =~ s/\\Q$extracted_string\\E\\Q$comma_close\\E//;\n\t\t\t\tif ($fixedline !~ /\\+\\s*$/) {\n\t\t\t\t\tfix_insert_line($fixlinenr, $fixedline);\n\t\t\t\t}\n\t\t\t\t$last_coalesced_string_linenr = $linenr;\n\t\t\t}\n\t\t}\n\n# check for missing a space in a string concatenation\n\t\tif ($prevrawline =~ /[^\\\\]\\w\"$/ && $rawline =~ /^\\+[\\t ]+\"\\w/) {\n\t\t\tWARN('MISSING_SPACE',\n\t\t\t     \"break quoted strings at a space character\\n\" . $hereprev);\n\t\t}\n\n# check for an embedded function name in a string when the function is known\n# This does not work very well for -f --file checking as it depends on patch\n# context providing the function name or a single line form for in-file\n# function declarations\n\t\tif ($line =~ /^\\+.*$String/ &&\n\t\t    defined($context_function) &&\n\t\t    get_quoted_string($line, $rawline) =~ /\\b$context_function\\b/ &&\n\t\t    length(get_quoted_string($line, $rawline)) != (length($context_function) + 2)) {\n\t\t\tWARN(\"EMBEDDED_FUNCTION_NAME\",\n\t\t\t     \"Prefer using '\\\"%s...\\\", __func__' to using '$context_function', this function's name, in a string\\n\" . $herecurr);\n\t\t}\n\n# check for unnecessary function tracing like uses\n# This does not use $logFunctions because there are many instances like\n# 'dprintk(FOO, \"%s()\\n\", __func__);' which do not match $logFunctions\n\t\tif ($rawline =~ /^\\+.*\\([^\"]*\"$tracing_logging_tags{0,3}%s(?:\\s*\\(\\s*\\)\\s*)?$tracing_logging_tags{0,3}(?:\\\\n)?\"\\s*,\\s*__func__\\s*\\)\\s*;/) {\n\t\t\tif (WARN(\"TRACING_LOGGING\",\n\t\t\t\t \"Unnecessary ftrace-like logging - prefer using ftrace\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n                                fix_delete_line($fixlinenr, $rawline);\n\t\t\t}\n\t\t}\n\n# check for spaces before a quoted newline\n\t\tif ($rawline =~ /^.*\\\".*\\s\\\\n/) {\n\t\t\tif (WARN(\"QUOTED_WHITESPACE_BEFORE_NEWLINE\",\n\t\t\t\t \"unnecessary whitespace before a quoted newline\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/^(\\+.*\\\".*)\\s+\\\\n/$1\\\\n/;\n\t\t\t}\n\n\t\t}\n\n# concatenated string without spaces between elements\n\t\tif ($line =~ /$String[A-Z_]/ ||\n\t\t    ($line =~ /([A-Za-z0-9_]+)$String/ && $1 !~ /^[Lu]$/)) {\n\t\t\tif (CHK(\"CONCATENATED_STRING\",\n\t\t\t\t\"Concatenated strings should use spaces between elements\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\twhile ($line =~ /($String)/g) {\n\t\t\t\t\tmy $extracted_string = substr($rawline, $-[0], $+[0] - $-[0]);\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$extracted_string\\E([A-Za-z0-9_])/$extracted_string $1/;\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/([A-Za-z0-9_])\\Q$extracted_string\\E/$1 $extracted_string/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# uncoalesced string fragments\n\t\tif ($line =~ /$String\\s*[Lu]?\"/) {\n\t\t\tif (WARN(\"STRING_FRAGMENTS\",\n\t\t\t\t \"Consecutive strings are generally better as a single string\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\twhile ($line =~ /($String)(?=\\s*\")/g) {\n\t\t\t\t\tmy $extracted_string = substr($rawline, $-[0], $+[0] - $-[0]);\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$extracted_string\\E\\s*\"/substr($extracted_string, 0, -1)/e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for non-standard and hex prefixed decimal printf formats\n\t\tmy $show_L = 1;\t#don't show the same defect twice\n\t\tmy $show_Z = 1;\n\t\twhile ($line =~ /(?:^|\")([X\\t]*)(?:\"|$)/g) {\n\t\t\tmy $string = substr($rawline, $-[1], $+[1] - $-[1]);\n\t\t\t$string =~ s/%%/__/g;\n\t\t\t# check for %L\n\t\t\tif ($show_L && $string =~ /%[\\*\\d\\.\\$]*L([diouxX])/) {\n\t\t\t\tWARN(\"PRINTF_L\",\n\t\t\t\t     \"\\%L$1 is non-standard C, use %ll$1\\n\" . $herecurr);\n\t\t\t\t$show_L = 0;\n\t\t\t}\n\t\t\t# check for %Z\n\t\t\tif ($show_Z && $string =~ /%[\\*\\d\\.\\$]*Z([diouxX])/) {\n\t\t\t\tWARN(\"PRINTF_Z\",\n\t\t\t\t     \"%Z$1 is non-standard C, use %z$1\\n\" . $herecurr);\n\t\t\t\t$show_Z = 0;\n\t\t\t}\n\t\t\t# check for 0x<decimal>\n\t\t\tif ($string =~ /0x%[\\*\\d\\.\\$\\Llzth]*[diou]/) {\n\t\t\t\tERROR(\"PRINTF_0XDECIMAL\",\n\t\t\t\t      \"Prefixing 0x with decimal output is defective\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for line continuations in quoted strings with odd counts of \"\n\t\tif ($rawline =~ /\\\\$/ && $sline =~ tr/\"/\"/ % 2) {\n\t\t\tWARN(\"LINE_CONTINUATIONS\",\n\t\t\t     \"Avoid line continuations in quoted strings\\n\" . $herecurr);\n\t\t}\n\n# warn about #if 0\n\t\tif ($line =~ /^.\\s*\\#\\s*if\\s+0\\b/) {\n\t\t\tWARN(\"IF_0\",\n\t\t\t     \"Consider removing the code enclosed by this #if 0 and its #endif\\n\" . $herecurr);\n\t\t}\n\n# warn about #if 1\n\t\tif ($line =~ /^.\\s*\\#\\s*if\\s+1\\b/) {\n\t\t\tWARN(\"IF_1\",\n\t\t\t     \"Consider removing the #if 1 and its #endif\\n\" . $herecurr);\n\t\t}\n\n# check for needless \"if (<foo>) fn(<foo>)\" uses\n\t\tif ($prevline =~ /\\bif\\s*\\(\\s*($Lval)\\s*\\)/) {\n\t\t\tmy $tested = quotemeta($1);\n\t\t\tmy $expr = '\\s*\\(\\s*' . $tested . '\\s*\\)\\s*;';\n\t\t\tif ($line =~ /\\b(kfree|usb_free_urb|debugfs_remove(?:_recursive)?|(?:kmem_cache|mempool|dma_pool)_destroy)$expr/) {\n\t\t\t\tmy $func = $1;\n\t\t\t\tif (WARN('NEEDLESS_IF',\n\t\t\t\t\t \"$func(NULL) is safe and this check is probably not required\\n\" . $hereprev) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\tmy $do_fix = 1;\n\t\t\t\t\tmy $leading_tabs = \"\";\n\t\t\t\t\tmy $new_leading_tabs = \"\";\n\t\t\t\t\tif ($lines[$linenr - 2] =~ /^\\+(\\t*)if\\s*\\(\\s*$tested\\s*\\)\\s*$/) {\n\t\t\t\t\t\t$leading_tabs = $1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$do_fix = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif ($lines[$linenr - 1] =~ /^\\+(\\t+)$func\\s*\\(\\s*$tested\\s*\\)\\s*;\\s*$/) {\n\t\t\t\t\t\t$new_leading_tabs = $1;\n\t\t\t\t\t\tif (length($leading_tabs) + 1 ne length($new_leading_tabs)) {\n\t\t\t\t\t\t\t$do_fix = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$do_fix = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif ($do_fix) {\n\t\t\t\t\t\tfix_delete_line($fixlinenr - 1, $prevrawline);\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/^\\+$new_leading_tabs/\\+$leading_tabs/;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for unnecessary \"Out of Memory\" messages\n\t\tif ($line =~ /^\\+.*\\b$logFunctions\\s*\\(/ &&\n\t\t    $prevline =~ /^[ \\+]\\s*if\\s*\\(\\s*(\\!\\s*|NULL\\s*==\\s*)?($Lval)(\\s*==\\s*NULL\\s*)?\\s*\\)/ &&\n\t\t    (defined $1 || defined $3) &&\n\t\t    $linenr > 3) {\n\t\t\tmy $testval = $2;\n\t\t\tmy $testline = $lines[$linenr - 3];\n\n\t\t\tmy ($s, $c) = ctx_statement_block($linenr - 3, $realcnt, 0);\n#\t\t\tprint(\"line: <$line>\\nprevline: <$prevline>\\ns: <$s>\\nc: <$c>\\n\\n\\n\");\n\n\t\t\tif ($s =~ /(?:^|\\n)[ \\+]\\s*(?:$Type\\s*)?\\Q$testval\\E\\s*=\\s*(?:\\([^\\)]*\\)\\s*)?\\s*$allocFunctions\\s*\\(/ &&\n\t\t\t    $s !~ /\\b__GFP_NOWARN\\b/ ) {\n\t\t\t\tWARN(\"OOM_MESSAGE\",\n\t\t\t\t     \"Possible unnecessary 'out of memory' message\\n\" . $hereprev);\n\t\t\t}\n\t\t}\n\n# check for logging functions with KERN_<LEVEL>\n\t\tif ($line !~ /printk(?:_ratelimited|_once)?\\s*\\(/ &&\n\t\t    $line =~ /\\b$logFunctions\\s*\\(.*\\b(KERN_[A-Z]+)\\b/) {\n\t\t\tmy $level = $1;\n\t\t\tif (WARN(\"UNNECESSARY_KERN_LEVEL\",\n\t\t\t\t \"Possible unnecessary $level\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\s*$level\\s*//;\n\t\t\t}\n\t\t}\n\n# check for logging continuations\n\t\tif ($line =~ /\\bprintk\\s*\\(\\s*KERN_CONT\\b|\\bpr_cont\\s*\\(/) {\n\t\t\tWARN(\"LOGGING_CONTINUATION\",\n\t\t\t     \"Avoid logging continuation uses where feasible\\n\" . $herecurr);\n\t\t}\n\n# check for unnecessary use of %h[xudi] and %hh[xudi] in logging functions\n\t\tif (defined $stat &&\n\t\t    $line =~ /\\b$logFunctions\\s*\\(/ &&\n\t\t    index($stat, '\"') >= 0) {\n\t\t\tmy $lc = $stat =~ tr@\\n@@;\n\t\t\t$lc = $lc + $linenr;\n\t\t\tmy $stat_real = get_stat_real($linenr, $lc);\n\t\t\tpos($stat_real) = index($stat_real, '\"');\n\t\t\twhile ($stat_real =~ /[^\\\"%]*(%[\\#\\d\\.\\*\\-]*(h+)[idux])/g) {\n\t\t\t\tmy $pspec = $1;\n\t\t\t\tmy $h = $2;\n\t\t\t\tmy $lineoff = substr($stat_real, 0, $-[1]) =~ tr@\\n@@;\n\t\t\t\tif (WARN(\"UNNECESSARY_MODIFIER\",\n\t\t\t\t\t \"Integer promotion: Using '$h' in '$pspec' is unnecessary\\n\" . \"$here\\n$stat_real\\n\") &&\n\t\t\t\t    $fix && $fixed[$fixlinenr + $lineoff] =~ /^\\+/) {\n\t\t\t\t\tmy $nspec = $pspec;\n\t\t\t\t\t$nspec =~ s/h//g;\n\t\t\t\t\t$fixed[$fixlinenr + $lineoff] =~ s/\\Q$pspec\\E/$nspec/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for mask then right shift without a parentheses\n\t\tif ($perl_version_ok &&\n\t\t    $line =~ /$LvalOrFunc\\s*\\&\\s*($LvalOrFunc)\\s*>>/ &&\n\t\t    $4 !~ /^\\&/) { # $LvalOrFunc may be &foo, ignore if so\n\t\t\tWARN(\"MASK_THEN_SHIFT\",\n\t\t\t     \"Possible precedence defect with mask then right shift - may need parentheses\\n\" . $herecurr);\n\t\t}\n\n# check for pointer comparisons to NULL\n\t\tif ($perl_version_ok) {\n\t\t\twhile ($line =~ /\\b$LvalOrFunc\\s*(==|\\!=)\\s*NULL\\b/g) {\n\t\t\t\tmy $val = $1;\n\t\t\t\tmy $equal = \"!\";\n\t\t\t\t$equal = \"\" if ($4 eq \"!=\");\n\t\t\t\tif (CHK(\"COMPARISON_TO_NULL\",\n\t\t\t\t\t\"Comparison to NULL could be written \\\"${equal}${val}\\\"\\n\" . $herecurr) &&\n\t\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\b\\Q$val\\E\\s*(?:==|\\!=)\\s*NULL\\b/$equal$val/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for bad placement of section $InitAttribute (e.g.: __initdata)\n\t\tif ($line =~ /(\\b$InitAttribute\\b)/) {\n\t\t\tmy $attr = $1;\n\t\t\tif ($line =~ /^\\+\\s*static\\s+(?:const\\s+)?(?:$attr\\s+)?($NonptrTypeWithAttr)\\s+(?:$attr\\s+)?($Ident(?:\\[[^]]*\\])?)\\s*[=;]/) {\n\t\t\t\tmy $ptr = $1;\n\t\t\t\tmy $var = $2;\n\t\t\t\tif ((($ptr =~ /\\b(union|struct)\\s+$attr\\b/ &&\n\t\t\t\t      ERROR(\"MISPLACED_INIT\",\n\t\t\t\t\t    \"$attr should be placed after $var\\n\" . $herecurr)) ||\n\t\t\t\t     ($ptr !~ /\\b(union|struct)\\s+$attr\\b/ &&\n\t\t\t\t      WARN(\"MISPLACED_INIT\",\n\t\t\t\t\t   \"$attr should be placed after $var\\n\" . $herecurr))) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/(\\bstatic\\s+(?:const\\s+)?)(?:$attr\\s+)?($NonptrTypeWithAttr)\\s+(?:$attr\\s+)?($Ident(?:\\[[^]]*\\])?)\\s*([=;])\\s*/\"$1\" . trim(string_find_replace($2, \"\\\\s*$attr\\\\s*\", \" \")) . \" \" . trim(string_find_replace($3, \"\\\\s*$attr\\\\s*\", \"\")) . \" $attr\" . (\"$4\" eq \";\" ? \";\" : \" = \")/e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for $InitAttributeData (ie: __initdata) with const\n\t\tif ($line =~ /\\bconst\\b/ && $line =~ /($InitAttributeData)/) {\n\t\t\tmy $attr = $1;\n\t\t\t$attr =~ /($InitAttributePrefix)(.*)/;\n\t\t\tmy $attr_prefix = $1;\n\t\t\tmy $attr_type = $2;\n\t\t\tif (ERROR(\"INIT_ATTRIBUTE\",\n\t\t\t\t  \"Use of const init definition must use ${attr_prefix}initconst\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/$InitAttributeData/${attr_prefix}initconst/;\n\t\t\t}\n\t\t}\n\n# check for $InitAttributeConst (ie: __initconst) without const\n\t\tif ($line !~ /\\bconst\\b/ && $line =~ /($InitAttributeConst)/) {\n\t\t\tmy $attr = $1;\n\t\t\tif (ERROR(\"INIT_ATTRIBUTE\",\n\t\t\t\t  \"Use of $attr requires a separate use of const\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tmy $lead = $fixed[$fixlinenr] =~\n\t\t\t\t    /(^\\+\\s*(?:static\\s+))/;\n\t\t\t\t$lead = rtrim($1);\n\t\t\t\t$lead = \"$lead \" if ($lead !~ /^\\+$/);\n\t\t\t\t$lead = \"${lead}const \";\n\t\t\t\t$fixed[$fixlinenr] =~ s/(^\\+\\s*(?:static\\s+))/$lead/;\n\t\t\t}\n\t\t}\n\n# check for __read_mostly with const non-pointer (should just be const)\n\t\tif ($line =~ /\\b__read_mostly\\b/ &&\n\t\t    $line =~ /($Type)\\s*$Ident/ && $1 !~ /\\*\\s*$/ && $1 =~ /\\bconst\\b/) {\n\t\t\tif (ERROR(\"CONST_READ_MOSTLY\",\n\t\t\t\t  \"Invalid use of __read_mostly with const type\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\s+__read_mostly\\b//;\n\t\t\t}\n\t\t}\n\n# don't use __constant_<foo> functions outside of include/uapi/\n\t\tif ($realfile !~ m@^include/uapi/@ &&\n\t\t    $line =~ /(__constant_(?:htons|ntohs|[bl]e(?:16|32|64)_to_cpu|cpu_to_[bl]e(?:16|32|64)))\\s*\\(/) {\n\t\t\tmy $constant_func = $1;\n\t\t\tmy $func = $constant_func;\n\t\t\t$func =~ s/^__constant_//;\n\t\t\tif (WARN(\"CONSTANT_CONVERSION\",\n\t\t\t\t \"$constant_func should be $func\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\b$constant_func\\b/$func/g;\n\t\t\t}\n\t\t}\n\n# prefer usleep_range over udelay\n\t\tif ($line =~ /\\budelay\\s*\\(\\s*(\\d+)\\s*\\)/) {\n\t\t\tmy $delay = $1;\n\t\t\t# ignore udelay's < 10, however\n\t\t\tif (! ($delay < 10) ) {\n\t\t\t\tCHK(\"USLEEP_RANGE\",\n\t\t\t\t    \"usleep_range is preferred over udelay; see function description of usleep_range() and udelay().\\n\" . $herecurr);\n\t\t\t}\n\t\t\tif ($delay > 2000) {\n\t\t\t\tWARN(\"LONG_UDELAY\",\n\t\t\t\t     \"long udelay - prefer mdelay; see function description of mdelay().\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# warn about unexpectedly long msleep's\n\t\tif ($line =~ /\\bmsleep\\s*\\((\\d+)\\);/) {\n\t\t\tif ($1 < 20) {\n\t\t\t\tWARN(\"MSLEEP\",\n\t\t\t\t     \"msleep < 20ms can sleep for up to 20ms; see function description of msleep().\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for comparisons of jiffies\n\t\tif ($line =~ /\\bjiffies\\s*$Compare|$Compare\\s*jiffies\\b/) {\n\t\t\tWARN(\"JIFFIES_COMPARISON\",\n\t\t\t     \"Comparing jiffies is almost always wrong; prefer time_after, time_before and friends\\n\" . $herecurr);\n\t\t}\n\n# check for comparisons of get_jiffies_64()\n\t\tif ($line =~ /\\bget_jiffies_64\\s*\\(\\s*\\)\\s*$Compare|$Compare\\s*get_jiffies_64\\s*\\(\\s*\\)/) {\n\t\t\tWARN(\"JIFFIES_COMPARISON\",\n\t\t\t     \"Comparing get_jiffies_64() is almost always wrong; prefer time_after64, time_before64 and friends\\n\" . $herecurr);\n\t\t}\n\n# warn about #ifdefs in C files\n#\t\tif ($line =~ /^.\\s*\\#\\s*if(|n)def/ && ($realfile =~ /\\.c$/)) {\n#\t\t\tprint \"#ifdef in C files should be avoided\\n\";\n#\t\t\tprint \"$herecurr\";\n#\t\t\t$clean = 0;\n#\t\t}\n\n# warn about spacing in #ifdefs\n\t\tif ($line =~ /^.\\s*\\#\\s*(ifdef|ifndef|elif)\\s\\s+/) {\n\t\t\tif (ERROR(\"SPACING\",\n\t\t\t\t  \"exactly one space required after that #$1\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~\n\t\t\t\t    s/^(.\\s*\\#\\s*(ifdef|ifndef|elif))\\s{2,}/$1 /;\n\t\t\t}\n\n\t\t}\n\n# check for spinlock_t definitions without a comment.\n\t\tif ($line =~ /^.\\s*(struct\\s+mutex|spinlock_t)\\s+\\S+;/ ||\n\t\t    $line =~ /^.\\s*(DEFINE_MUTEX)\\s*\\(/) {\n\t\t\tmy $which = $1;\n\t\t\tif (!ctx_has_comment($first_line, $linenr)) {\n\t\t\t\tCHK(\"UNCOMMENTED_DEFINITION\",\n\t\t\t\t    \"$1 definition without comment\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n# check for memory barriers without a comment.\n\n\t\tmy $barriers = qr{\n\t\t\tmb|\n\t\t\trmb|\n\t\t\twmb\n\t\t}x;\n\t\tmy $barrier_stems = qr{\n\t\t\tmb__before_atomic|\n\t\t\tmb__after_atomic|\n\t\t\tstore_release|\n\t\t\tload_acquire|\n\t\t\tstore_mb|\n\t\t\t(?:$barriers)\n\t\t}x;\n\t\tmy $all_barriers = qr{\n\t\t\t(?:$barriers)|\n\t\t\tsmp_(?:$barrier_stems)|\n\t\t\tvirt_(?:$barrier_stems)\n\t\t}x;\n\n\t\tif ($line =~ /\\b(?:$all_barriers)\\s*\\(/) {\n\t\t\tif (!ctx_has_comment($first_line, $linenr)) {\n\t\t\t\tWARN(\"MEMORY_BARRIER\",\n\t\t\t\t     \"memory barrier without comment\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n\t\tmy $underscore_smp_barriers = qr{__smp_(?:$barrier_stems)}x;\n\n\t\tif ($realfile !~ m@^include/asm-generic/@ &&\n\t\t    $realfile !~ m@/barrier\\.h$@ &&\n\t\t    $line =~ m/\\b(?:$underscore_smp_barriers)\\s*\\(/ &&\n\t\t    $line !~ m/^.\\s*\\#\\s*define\\s+(?:$underscore_smp_barriers)\\s*\\(/) {\n\t\t\tWARN(\"MEMORY_BARRIER\",\n\t\t\t     \"__smp memory barriers shouldn't be used outside barrier.h and asm-generic\\n\" . $herecurr);\n\t\t}\n\n# check for waitqueue_active without a comment.\n\t\tif ($line =~ /\\bwaitqueue_active\\s*\\(/) {\n\t\t\tif (!ctx_has_comment($first_line, $linenr)) {\n\t\t\t\tWARN(\"WAITQUEUE_ACTIVE\",\n\t\t\t\t     \"waitqueue_active without comment\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for data_race without a comment.\n\t\tif ($line =~ /\\bdata_race\\s*\\(/) {\n\t\t\tif (!ctx_has_comment($first_line, $linenr)) {\n\t\t\t\tWARN(\"DATA_RACE\",\n\t\t\t\t     \"data_race without comment\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check of hardware specific defines\n\t\tif ($line =~ m@^.\\s*\\#\\s*if.*\\b(__i386__|__powerpc64__|__sun__|__s390x__)\\b@ && $realfile !~ m@include/asm-@) {\n\t\t\tCHK(\"ARCH_DEFINES\",\n\t\t\t    \"architecture specific defines should be avoided\\n\" .  $herecurr);\n\t\t}\n\n# check that the storage class is not after a type\n\t\tif ($line =~ /\\b($Type)\\s+($Storage)\\b/) {\n\t\t\tWARN(\"STORAGE_CLASS\",\n\t\t\t     \"storage class '$2' should be located before type '$1'\\n\" . $herecurr);\n\t\t}\n# Check that the storage class is at the beginning of a declaration\n\t\tif ($line =~ /\\b$Storage\\b/ &&\n\t\t    $line !~ /^.\\s*$Storage/ &&\n\t\t    $line =~ /^.\\s*(.+?)\\$Storage\\s/ &&\n\t\t    $1 !~ /[\\,\\)]\\s*$/) {\n\t\t\tWARN(\"STORAGE_CLASS\",\n\t\t\t     \"storage class should be at the beginning of the declaration\\n\" . $herecurr);\n\t\t}\n\n# check the location of the inline attribute, that it is between\n# storage class and type.\n\t\tif ($line =~ /\\b$Type\\s+$Inline\\b/ ||\n\t\t    $line =~ /\\b$Inline\\s+$Storage\\b/) {\n\t\t\tERROR(\"INLINE_LOCATION\",\n\t\t\t      \"inline keyword should sit between storage class and type\\n\" . $herecurr);\n\t\t}\n\n# Check for __inline__ and __inline, prefer inline\n\t\tif ($realfile !~ m@\\binclude/uapi/@ &&\n\t\t    $line =~ /\\b(__inline__|__inline)\\b/) {\n\t\t\tif (WARN(\"INLINE\",\n\t\t\t\t \"plain inline is preferred over $1\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\b(__inline__|__inline)\\b/inline/;\n\n\t\t\t}\n\t\t}\n\n# Check for compiler attributes\n\t\tif ($realfile !~ m@\\binclude/uapi/@ &&\n\t\t    $rawline =~ /\\b__attribute__\\s*\\(\\s*($balanced_parens)\\s*\\)/) {\n\t\t\tmy $attr = $1;\n\t\t\t$attr =~ s/\\s*\\(\\s*(.*)\\)\\s*/$1/;\n\n\t\t\tmy %attr_list = (\n\t\t\t\t\"alias\"\t\t\t\t=> \"__alias\",\n\t\t\t\t\"aligned\"\t\t\t=> \"__aligned\",\n\t\t\t\t\"always_inline\"\t\t\t=> \"__always_inline\",\n\t\t\t\t\"assume_aligned\"\t\t=> \"__assume_aligned\",\n\t\t\t\t\"cold\"\t\t\t\t=> \"__cold\",\n\t\t\t\t\"const\"\t\t\t\t=> \"__attribute_const__\",\n\t\t\t\t\"copy\"\t\t\t\t=> \"__copy\",\n\t\t\t\t\"designated_init\"\t\t=> \"__designated_init\",\n\t\t\t\t\"externally_visible\"\t\t=> \"__visible\",\n\t\t\t\t\"format\"\t\t\t=> \"printf|scanf\",\n\t\t\t\t\"gnu_inline\"\t\t\t=> \"__gnu_inline\",\n\t\t\t\t\"malloc\"\t\t\t=> \"__malloc\",\n\t\t\t\t\"mode\"\t\t\t\t=> \"__mode\",\n\t\t\t\t\"no_caller_saved_registers\"\t=> \"__no_caller_saved_registers\",\n\t\t\t\t\"noclone\"\t\t\t=> \"__noclone\",\n\t\t\t\t\"noinline\"\t\t\t=> \"noinline\",\n\t\t\t\t\"nonstring\"\t\t\t=> \"__nonstring\",\n\t\t\t\t\"noreturn\"\t\t\t=> \"__noreturn\",\n\t\t\t\t\"packed\"\t\t\t=> \"__packed\",\n\t\t\t\t\"pure\"\t\t\t\t=> \"__pure\",\n\t\t\t\t\"section\"\t\t\t=> \"__section\",\n\t\t\t\t\"used\"\t\t\t\t=> \"__used\",\n\t\t\t\t\"weak\"\t\t\t\t=> \"__weak\"\n\t\t\t);\n\n\t\t\twhile ($attr =~ /\\s*(\\w+)\\s*(${balanced_parens})?/g) {\n\t\t\t\tmy $orig_attr = $1;\n\t\t\t\tmy $params = '';\n\t\t\t\t$params = $2 if defined($2);\n\t\t\t\tmy $curr_attr = $orig_attr;\n\t\t\t\t$curr_attr =~ s/^[\\s_]+|[\\s_]+$//g;\n\t\t\t\tif (exists($attr_list{$curr_attr})) {\n\t\t\t\t\tmy $new = $attr_list{$curr_attr};\n\t\t\t\t\tif ($curr_attr eq \"format\" && $params) {\n\t\t\t\t\t\t$params =~ /^\\s*\\(\\s*(\\w+)\\s*,\\s*(.*)/;\n\t\t\t\t\t\t$new = \"__$1\\($2\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$new = \"$new$params\";\n\t\t\t\t\t}\n\t\t\t\t\tif (WARN(\"PREFER_DEFINED_ATTRIBUTE_MACRO\",\n\t\t\t\t\t\t \"Prefer $new over __attribute__(($orig_attr$params))\\n\" . $herecurr) &&\n\t\t\t\t\t    $fix) {\n\t\t\t\t\t\tmy $remove = \"\\Q$orig_attr\\E\" . '\\s*' . \"\\Q$params\\E\" . '(?:\\s*,\\s*)?';\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/$remove//;\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\b__attribute__/$new __attribute__/;\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\}\\Q$new\\E/} $new/;\n\t\t\t\t\t\t$fixed[$fixlinenr] =~ s/ __attribute__\\s*\\(\\s*\\(\\s*\\)\\s*\\)//;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t# Check for __attribute__ unused, prefer __always_unused or __maybe_unused\n\t\t\tif ($attr =~ /^_*unused/) {\n\t\t\t\tWARN(\"PREFER_DEFINED_ATTRIBUTE_MACRO\",\n\t\t\t\t     \"__always_unused or __maybe_unused is preferred over __attribute__((__unused__))\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# Check for __attribute__ weak, or __weak declarations (may have link issues)\n\t\tif ($perl_version_ok &&\n\t\t    $line =~ /(?:$Declare|$DeclareMisordered)\\s*$Ident\\s*$balanced_parens\\s*(?:$Attribute)?\\s*;/ &&\n\t\t    ($line =~ /\\b__attribute__\\s*\\(\\s*\\(.*\\bweak\\b/ ||\n\t\t     $line =~ /\\b__weak\\b/)) {\n\t\t\tERROR(\"WEAK_DECLARATION\",\n\t\t\t      \"Using weak declarations can have unintended link defects\\n\" . $herecurr);\n\t\t}\n\n# check for c99 types like uint8_t used outside of uapi/ and tools/\n\t\tif ($realfile !~ m@\\binclude/uapi/@ &&\n\t\t    $realfile !~ m@\\btools/@ &&\n\t\t    $line =~ /\\b($Declare)\\s*$Ident\\s*[=;,\\[]/) {\n\t\t\tmy $type = $1;\n\t\t\tif ($type =~ /\\b($typeC99Typedefs)\\b/) {\n\t\t\t\t$type = $1;\n\t\t\t\tmy $kernel_type = 'u';\n\t\t\t\t$kernel_type = 's' if ($type =~ /^_*[si]/);\n\t\t\t\t$type =~ /(\\d+)/;\n\t\t\t\t$kernel_type .= $1;\n\t\t\t\tif (CHK(\"PREFER_KERNEL_TYPES\",\n\t\t\t\t\t\"Prefer kernel type '$kernel_type' over '$type'\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\b$type\\b/$kernel_type/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for cast of C90 native int or longer types constants\n\t\tif ($line =~ /(\\(\\s*$C90_int_types\\s*\\)\\s*)($Constant)\\b/) {\n\t\t\tmy $cast = $1;\n\t\t\tmy $const = $2;\n\t\t\tmy $suffix = \"\";\n\t\t\tmy $newconst = $const;\n\t\t\t$newconst =~ s/${Int_type}$//;\n\t\t\t$suffix .= 'U' if ($cast =~ /\\bunsigned\\b/);\n\t\t\tif ($cast =~ /\\blong\\s+long\\b/) {\n\t\t\t    $suffix .= 'LL';\n\t\t\t} elsif ($cast =~ /\\blong\\b/) {\n\t\t\t    $suffix .= 'L';\n\t\t\t}\n\t\t\tif (WARN(\"TYPECAST_INT_CONSTANT\",\n\t\t\t\t \"Unnecessary typecast of c90 int constant - '$cast$const' could be '$const$suffix'\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$cast\\E$const\\b/$newconst$suffix/;\n\t\t\t}\n\t\t}\n\n# check for sizeof(&)\n\t\tif ($line =~ /\\bsizeof\\s*\\(\\s*\\&/) {\n\t\t\tWARN(\"SIZEOF_ADDRESS\",\n\t\t\t     \"sizeof(& should be avoided\\n\" . $herecurr);\n\t\t}\n\n# check for sizeof without parenthesis\n\t\tif ($line =~ /\\bsizeof\\s+((?:\\*\\s*|)$Lval|$Type(?:\\s+$Lval|))/) {\n\t\t\tif (WARN(\"SIZEOF_PARENTHESIS\",\n\t\t\t\t \"sizeof $1 should be sizeof($1)\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\bsizeof\\s+((?:\\*\\s*|)$Lval|$Type(?:\\s+$Lval|))/\"sizeof(\" . trim($1) . \")\"/ex;\n\t\t\t}\n\t\t}\n\n# check for struct spinlock declarations\n\t\tif ($line =~ /^.\\s*\\bstruct\\s+spinlock\\s+\\w+\\s*;/) {\n\t\t\tWARN(\"USE_SPINLOCK_T\",\n\t\t\t     \"struct spinlock should be spinlock_t\\n\" . $herecurr);\n\t\t}\n\n# check for seq_printf uses that could be seq_puts\n\t\tif ($sline =~ /\\bseq_printf\\s*\\(.*\"\\s*\\)\\s*;\\s*$/) {\n\t\t\tmy $fmt = get_quoted_string($line, $rawline);\n\t\t\t$fmt =~ s/%%//g;\n\t\t\tif ($fmt !~ /%/) {\n\t\t\t\tif (WARN(\"PREFER_SEQ_PUTS\",\n\t\t\t\t\t \"Prefer seq_puts to seq_printf\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\bseq_printf\\b/seq_puts/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for vsprintf extension %p<foo> misuses\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /^\\+(?![^\\{]*\\{\\s*).*\\b(\\w+)\\s*\\(.*$String\\s*,/s &&\n\t\t    $1 !~ /^_*volatile_*$/) {\n\t\t\tmy $stat_real;\n\n\t\t\tmy $lc = $stat =~ tr@\\n@@;\n\t\t\t$lc = $lc + $linenr;\n\t\t        for (my $count = $linenr; $count <= $lc; $count++) {\n\t\t\t\tmy $specifier;\n\t\t\t\tmy $extension;\n\t\t\t\tmy $qualifier;\n\t\t\t\tmy $bad_specifier = \"\";\n\t\t\t\tmy $fmt = get_quoted_string($lines[$count - 1], raw_line($count, 0));\n\t\t\t\t$fmt =~ s/%%//g;\n\n\t\t\t\twhile ($fmt =~ /(\\%[\\*\\d\\.]*p(\\w)(\\w*))/g) {\n\t\t\t\t\t$specifier = $1;\n\t\t\t\t\t$extension = $2;\n\t\t\t\t\t$qualifier = $3;\n\t\t\t\t\tif ($extension !~ /[4SsBKRraEehMmIiUDdgVCbGNOxtf]/ ||\n\t\t\t\t\t    ($extension eq \"f\" &&\n\t\t\t\t\t     defined $qualifier && $qualifier !~ /^w/) ||\n\t\t\t\t\t    ($extension eq \"4\" &&\n\t\t\t\t\t     defined $qualifier && $qualifier !~ /^cc/)) {\n\t\t\t\t\t\t$bad_specifier = $specifier;\n\t\t\t\t\t\tlast;\n\t\t\t\t\t}\n\t\t\t\t\tif ($extension eq \"x\" && !defined($stat_real)) {\n\t\t\t\t\t\tif (!defined($stat_real)) {\n\t\t\t\t\t\t\t$stat_real = get_stat_real($linenr, $lc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tWARN(\"VSPRINTF_SPECIFIER_PX\",\n\t\t\t\t\t\t     \"Using vsprintf specifier '\\%px' potentially exposes the kernel memory layout, if you don't really need the address please consider using '\\%p'.\\n\" . \"$here\\n$stat_real\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ($bad_specifier ne \"\") {\n\t\t\t\t\tmy $stat_real = get_stat_real($linenr, $lc);\n\t\t\t\t\tmy $msg_level = \\&WARN;\n\t\t\t\t\tmy $ext_type = \"Invalid\";\n\t\t\t\t\tmy $use = \"\";\n\t\t\t\t\tif ($bad_specifier =~ /p[Ff]/) {\n\t\t\t\t\t\t$use = \" - use %pS instead\";\n\t\t\t\t\t\t$use =~ s/pS/ps/ if ($bad_specifier =~ /pf/);\n\t\t\t\t\t} elsif ($bad_specifier =~ /pA/) {\n\t\t\t\t\t\t$use =  \" - '%pA' is only intended to be used from Rust code\";\n\t\t\t\t\t\t$msg_level = \\&ERROR;\n\t\t\t\t\t}\n\n\t\t\t\t\t&{$msg_level}(\"VSPRINTF_POINTER_EXTENSION\",\n\t\t\t\t\t\t      \"$ext_type vsprintf pointer extension '$bad_specifier'$use\\n\" . \"$here\\n$stat_real\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# Check for misused memsets\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /^\\+(?:.*?)\\bmemset\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*\\,\\s*$FuncArg\\s*\\)/) {\n\n\t\t\tmy $ms_addr = $2;\n\t\t\tmy $ms_val = $7;\n\t\t\tmy $ms_size = $12;\n\n\t\t\tif ($ms_size =~ /^(0x|)0$/i) {\n\t\t\t\tERROR(\"MEMSET\",\n\t\t\t\t      \"memset to 0's uses 0 as the 2nd argument, not the 3rd\\n\" . \"$here\\n$stat\\n\");\n\t\t\t} elsif ($ms_size =~ /^(0x|)1$/i) {\n\t\t\t\tWARN(\"MEMSET\",\n\t\t\t\t     \"single byte memset is suspicious. Swapped 2nd/3rd argument?\\n\" . \"$here\\n$stat\\n\");\n\t\t\t}\n\t\t}\n\n# Check for memcpy(foo, bar, ETH_ALEN) that could be ether_addr_copy(foo, bar)\n#\t\tif ($perl_version_ok &&\n#\t\t    defined $stat &&\n#\t\t    $stat =~ /^\\+(?:.*?)\\bmemcpy\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*\\,\\s*ETH_ALEN\\s*\\)/) {\n#\t\t\tif (WARN(\"PREFER_ETHER_ADDR_COPY\",\n#\t\t\t\t \"Prefer ether_addr_copy() over memcpy() if the Ethernet addresses are __aligned(2)\\n\" . \"$here\\n$stat\\n\") &&\n#\t\t\t    $fix) {\n#\t\t\t\t$fixed[$fixlinenr] =~ s/\\bmemcpy\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*\\,\\s*ETH_ALEN\\s*\\)/ether_addr_copy($2, $7)/;\n#\t\t\t}\n#\t\t}\n\n# Check for memcmp(foo, bar, ETH_ALEN) that could be ether_addr_equal*(foo, bar)\n#\t\tif ($perl_version_ok &&\n#\t\t    defined $stat &&\n#\t\t    $stat =~ /^\\+(?:.*?)\\bmemcmp\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*\\,\\s*ETH_ALEN\\s*\\)/) {\n#\t\t\tWARN(\"PREFER_ETHER_ADDR_EQUAL\",\n#\t\t\t     \"Prefer ether_addr_equal() or ether_addr_equal_unaligned() over memcmp()\\n\" . \"$here\\n$stat\\n\")\n#\t\t}\n\n# check for memset(foo, 0x0, ETH_ALEN) that could be eth_zero_addr\n# check for memset(foo, 0xFF, ETH_ALEN) that could be eth_broadcast_addr\n#\t\tif ($perl_version_ok &&\n#\t\t    defined $stat &&\n#\t\t    $stat =~ /^\\+(?:.*?)\\bmemset\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*\\,\\s*ETH_ALEN\\s*\\)/) {\n#\n#\t\t\tmy $ms_val = $7;\n#\n#\t\t\tif ($ms_val =~ /^(?:0x|)0+$/i) {\n#\t\t\t\tif (WARN(\"PREFER_ETH_ZERO_ADDR\",\n#\t\t\t\t\t \"Prefer eth_zero_addr over memset()\\n\" . \"$here\\n$stat\\n\") &&\n#\t\t\t\t    $fix) {\n#\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\bmemset\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*,\\s*ETH_ALEN\\s*\\)/eth_zero_addr($2)/;\n#\t\t\t\t}\n#\t\t\t} elsif ($ms_val =~ /^(?:0xff|255)$/i) {\n#\t\t\t\tif (WARN(\"PREFER_ETH_BROADCAST_ADDR\",\n#\t\t\t\t\t \"Prefer eth_broadcast_addr() over memset()\\n\" . \"$here\\n$stat\\n\") &&\n#\t\t\t\t    $fix) {\n#\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\bmemset\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*,\\s*ETH_ALEN\\s*\\)/eth_broadcast_addr($2)/;\n#\t\t\t\t}\n#\t\t\t}\n#\t\t}\n\n# strcpy uses that should likely be strscpy\n\t\tif ($line =~ /\\bstrcpy\\s*\\(/) {\n\t\t\tWARN(\"STRCPY\",\n\t\t\t     \"Prefer strscpy over strcpy - see: https://github.com/KSPP/linux/issues/88\\n\" . $herecurr);\n\t\t}\n\n# strlcpy uses that should likely be strscpy\n\t\tif ($line =~ /\\bstrlcpy\\s*\\(/) {\n\t\t\tWARN(\"STRLCPY\",\n\t\t\t     \"Prefer strscpy over strlcpy - see: https://github.com/KSPP/linux/issues/89\\n\" . $herecurr);\n\t\t}\n\n# strncpy uses that should likely be strscpy or strscpy_pad\n\t\tif ($line =~ /\\bstrncpy\\s*\\(/) {\n\t\t\tWARN(\"STRNCPY\",\n\t\t\t     \"Prefer strscpy, strscpy_pad, or __nonstring over strncpy - see: https://github.com/KSPP/linux/issues/90\\n\" . $herecurr);\n\t\t}\n\n# ethtool_sprintf uses that should likely be ethtool_puts\n\t\tif ($line =~ /\\bethtool_sprintf\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*\\)/) {\n\t\t\tif (WARN(\"PREFER_ETHTOOL_PUTS\",\n\t\t\t\t \"Prefer ethtool_puts over ethtool_sprintf with only two arguments\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\bethtool_sprintf\\s*\\(\\s*($FuncArg)\\s*,\\s*($FuncArg)/ethtool_puts($1, $7)/;\n\t\t\t}\n\t\t}\n\n\t\t# use $rawline because $line loses %s via sanitization and thus we can't match against it.\n\t\tif ($rawline =~ /\\bethtool_sprintf\\s*\\(\\s*$FuncArg\\s*,\\s*\\\"\\%s\\\"\\s*,\\s*$FuncArg\\s*\\)/) {\n\t\t\tif (WARN(\"PREFER_ETHTOOL_PUTS\",\n\t\t\t\t \"Prefer ethtool_puts over ethtool_sprintf with standalone \\\"%s\\\" specifier\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\bethtool_sprintf\\s*\\(\\s*($FuncArg)\\s*,\\s*\"\\%s\"\\s*,\\s*($FuncArg)/ethtool_puts($1, $7)/;\n\t\t\t}\n\t\t}\n\n\n# typecasts on min/max could be min_t/max_t\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /^\\+(?:.*?)\\b(min|max)\\s*\\(\\s*$FuncArg\\s*,\\s*$FuncArg\\s*\\)/) {\n\t\t\tif (defined $2 || defined $7) {\n\t\t\t\tmy $call = $1;\n\t\t\t\tmy $cast1 = deparenthesize($2);\n\t\t\t\tmy $arg1 = $3;\n\t\t\t\tmy $cast2 = deparenthesize($7);\n\t\t\t\tmy $arg2 = $8;\n\t\t\t\tmy $cast;\n\n\t\t\t\tif ($cast1 ne \"\" && $cast2 ne \"\" && $cast1 ne $cast2) {\n\t\t\t\t\t$cast = \"$cast1 or $cast2\";\n\t\t\t\t} elsif ($cast1 ne \"\") {\n\t\t\t\t\t$cast = $cast1;\n\t\t\t\t} else {\n\t\t\t\t\t$cast = $cast2;\n\t\t\t\t}\n\t\t\t\tWARN(\"MINMAX\",\n\t\t\t\t     \"$call() should probably be ${call}_t($cast, $arg1, $arg2)\\n\" . \"$here\\n$stat\\n\");\n\t\t\t}\n\t\t}\n\n# check usleep_range arguments\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /^\\+(?:.*?)\\busleep_range\\s*\\(\\s*($FuncArg)\\s*,\\s*($FuncArg)\\s*\\)/) {\n\t\t\tmy $min = $1;\n\t\t\tmy $max = $7;\n\t\t\tif ($min eq $max) {\n\t\t\t\tWARN(\"USLEEP_RANGE\",\n\t\t\t\t     \"usleep_range should not use min == max args;  see function description of usleep_range().\\n\" . \"$here\\n$stat\\n\");\n\t\t\t} elsif ($min =~ /^\\d+$/ && $max =~ /^\\d+$/ &&\n\t\t\t\t $min > $max) {\n\t\t\t\tWARN(\"USLEEP_RANGE\",\n\t\t\t\t     \"usleep_range args reversed, use min then max;  see function description of usleep_range().\\n\" . \"$here\\n$stat\\n\");\n\t\t\t}\n\t\t}\n\n# check for naked sscanf\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $line =~ /\\bsscanf\\b/ &&\n\t\t    ($stat !~ /$Ident\\s*=\\s*sscanf\\s*$balanced_parens/ &&\n\t\t     $stat !~ /\\bsscanf\\s*$balanced_parens\\s*(?:$Compare)/ &&\n\t\t     $stat !~ /(?:$Compare)\\s*\\bsscanf\\s*$balanced_parens/)) {\n\t\t\tmy $lc = $stat =~ tr@\\n@@;\n\t\t\t$lc = $lc + $linenr;\n\t\t\tmy $stat_real = get_stat_real($linenr, $lc);\n\t\t\tWARN(\"NAKED_SSCANF\",\n\t\t\t     \"unchecked sscanf return value\\n\" . \"$here\\n$stat_real\\n\");\n\t\t}\n\n# check for simple sscanf that should be kstrto<foo>\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $line =~ /\\bsscanf\\b/) {\n\t\t\tmy $lc = $stat =~ tr@\\n@@;\n\t\t\t$lc = $lc + $linenr;\n\t\t\tmy $stat_real = get_stat_real($linenr, $lc);\n\t\t\tif ($stat_real =~ /\\bsscanf\\b\\s*\\(\\s*$FuncArg\\s*,\\s*(\"[^\"]+\")/) {\n\t\t\t\tmy $format = $6;\n\t\t\t\tmy $count = $format =~ tr@%@%@;\n\t\t\t\tif ($count == 1 &&\n\t\t\t\t    $format =~ /^\"\\%(?i:ll[udxi]|[udxi]ll|ll|[hl]h?[udxi]|[udxi][hl]h?|[hl]h?|[udxi])\"$/) {\n\t\t\t\t\tWARN(\"SSCANF_TO_KSTRTO\",\n\t\t\t\t\t     \"Prefer kstrto<type> to single variable sscanf\\n\" . \"$here\\n$stat_real\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for new externs in .h files.\n\t\tif ($realfile =~ /\\.h$/ &&\n\t\t    $line =~ /^\\+\\s*(extern\\s+)$Type\\s*$Ident\\s*\\(/s) {\n\t\t\tif (CHK(\"AVOID_EXTERNS\",\n\t\t\t\t\"extern prototypes should be avoided in .h files\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/(.*)\\bextern\\b\\s*(.*)/$1$2/;\n\t\t\t}\n\t\t}\n\n# check for new externs in .c files.\n\t\tif ($realfile =~ /\\.c$/ && defined $stat &&\n\t\t    $stat =~ /^.\\s*(?:extern\\s+)?$Type\\s+($Ident)(\\s*)\\(/s)\n\t\t{\n\t\t\tmy $function_name = $1;\n\t\t\tmy $paren_space = $2;\n\n\t\t\tmy $s = $stat;\n\t\t\tif (defined $cond) {\n\t\t\t\tsubstr($s, 0, length($cond), '');\n\t\t\t}\n\t\t\tif ($s =~ /^\\s*;/)\n\t\t\t{\n\t\t\t\tWARN(\"AVOID_EXTERNS\",\n\t\t\t\t     \"externs should be avoided in .c files\\n\" .  $herecurr);\n\t\t\t}\n\n\t\t\tif ($paren_space =~ /\\n/) {\n\t\t\t\tWARN(\"FUNCTION_ARGUMENTS\",\n\t\t\t\t     \"arguments for function declarations should follow identifier\\n\" . $herecurr);\n\t\t\t}\n\n\t\t} elsif ($realfile =~ /\\.c$/ && defined $stat &&\n\t\t    $stat =~ /^\\+extern struct\\s+(\\w+)\\s+(\\w+)\\[\\];/)\n\t\t{\n\t\t\tmy ($st_type, $st_name) = ($1, $2);\n\n\t\t\tfor my $s (keys %maybe_linker_symbol) {\n\t\t\t    #print \"Linker symbol? $st_name : $s\\n\";\n\t\t\t    goto LIKELY_LINKER_SYMBOL\n\t\t\t\tif $st_name =~ /$s/;\n\t\t\t}\n\t\t\tWARN(\"AVOID_EXTERNS\",\n\t\t\t     \"found a file-scoped extern type:$st_type name:$st_name in .c file\\n\"\n\t\t\t     . \"is this a linker symbol ?\\n\" . $herecurr);\n\t\t  LIKELY_LINKER_SYMBOL:\n\n\t\t} elsif ($realfile =~ /\\.c$/ && defined $stat &&\n\t\t    $stat =~ /^.\\s*extern\\s+/)\n\t\t{\n\t\t\tWARN(\"AVOID_EXTERNS\",\n\t\t\t     \"externs should be avoided in .c files\\n\" .  $herecurr);\n\t\t}\n\n# check for function declarations that have arguments without identifier names\n\t\tif (defined $stat &&\n\t\t    $stat =~ /^.\\s*(?:extern\\s+)?$Type\\s*(?:$Ident|\\(\\s*\\*\\s*$Ident\\s*\\))\\s*\\(\\s*([^{]+)\\s*\\)\\s*;/s &&\n\t\t    $1 ne \"void\") {\n\t\t\tmy $args = trim($1);\n\t\t\twhile ($args =~ m/\\s*($Type\\s*(?:$Ident|\\(\\s*\\*\\s*$Ident?\\s*\\)\\s*$balanced_parens)?)/g) {\n\t\t\t\tmy $arg = trim($1);\n\t\t\t\tif ($arg =~ /^$Type$/ && $arg !~ /enum\\s+$Ident$/) {\n\t\t\t\t\tWARN(\"FUNCTION_ARGUMENTS\",\n\t\t\t\t\t     \"function definition argument '$arg' should also have an identifier name\\n\" . $herecurr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for function definitions\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /^.\\s*(?:$Storage\\s+)?$Type\\s*($Ident)\\s*$balanced_parens\\s*{/s) {\n\t\t\t$context_function = $1;\n\n# check for multiline function definition with misplaced open brace\n\t\t\tmy $ok = 0;\n\t\t\tmy $cnt = statement_rawlines($stat);\n\t\t\tmy $herectx = $here . \"\\n\";\n\t\t\tfor (my $n = 0; $n < $cnt; $n++) {\n\t\t\t\tmy $rl = raw_line($linenr, $n);\n\t\t\t\t$herectx .=  $rl . \"\\n\";\n\t\t\t\t$ok = 1 if ($rl =~ /^[ \\+]\\{/);\n\t\t\t\t$ok = 1 if ($rl =~ /\\{/ && $n == 0);\n\t\t\t\tlast if $rl =~ /^[ \\+].*\\{/;\n\t\t\t}\n\t\t\tif (!$ok) {\n\t\t\t\tERROR(\"OPEN_BRACE\",\n\t\t\t\t      \"open brace '{' following function definitions go on the next line\\n\" . $herectx);\n\t\t\t}\n\t\t}\n\n# checks for new __setup's\n\t\tif ($rawline =~ /\\b__setup\\(\"([^\"]*)\"/) {\n\t\t\tmy $name = $1;\n\n\t\t\tif (!grep(/$name/, @setup_docs)) {\n\t\t\t\tCHK(\"UNDOCUMENTED_SETUP\",\n\t\t\t\t    \"__setup appears un-documented -- check Documentation/admin-guide/kernel-parameters.txt\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for pointless casting of alloc functions\n\t\tif ($line =~ /\\*\\s*\\)\\s*$allocFunctions\\b/) {\n\t\t\tWARN(\"UNNECESSARY_CASTS\",\n\t\t\t     \"unnecessary cast may hide bugs, see http://c-faq.com/malloc/mallocnocast.html\\n\" . $herecurr);\n\t\t}\n\n# alloc style\n# p = alloc(sizeof(struct foo), ...) should be p = alloc(sizeof(*p), ...)\n\t\tif ($perl_version_ok &&\n\t\t    $line =~ /\\b($Lval)\\s*\\=\\s*(?:$balanced_parens)?\\s*((?:kv|k|v)[mz]alloc(?:_node)?)\\s*\\(\\s*(sizeof\\s*\\(\\s*struct\\s+$Lval\\s*\\))/) {\n\t\t\tCHK(\"ALLOC_SIZEOF_STRUCT\",\n\t\t\t    \"Prefer $3(sizeof(*$1)...) over $3($4...)\\n\" . $herecurr);\n\t\t}\n\n# check for (kv|k)[mz]alloc with multiplies that could be kmalloc_array/kvmalloc_array/kvcalloc/kcalloc\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /^\\+\\s*($Lval)\\s*\\=\\s*(?:$balanced_parens)?\\s*((?:kv|k)[mz]alloc)\\s*\\(\\s*($FuncArg)\\s*\\*\\s*($FuncArg)\\s*,/) {\n\t\t\tmy $oldfunc = $3;\n\t\t\tmy $a1 = $4;\n\t\t\tmy $a2 = $10;\n\t\t\tmy $newfunc = \"kmalloc_array\";\n\t\t\t$newfunc = \"kvmalloc_array\" if ($oldfunc eq \"kvmalloc\");\n\t\t\t$newfunc = \"kvcalloc\" if ($oldfunc eq \"kvzalloc\");\n\t\t\t$newfunc = \"kcalloc\" if ($oldfunc eq \"kzalloc\");\n\t\t\tmy $r1 = $a1;\n\t\t\tmy $r2 = $a2;\n\t\t\tif ($a1 =~ /^sizeof\\s*\\S/) {\n\t\t\t\t$r1 = $a2;\n\t\t\t\t$r2 = $a1;\n\t\t\t}\n\t\t\tif ($r1 !~ /^sizeof\\b/ && $r2 =~ /^sizeof\\s*\\S/ &&\n\t\t\t    !($r1 =~ /^$Constant$/ || $r1 =~ /^[A-Z_][A-Z0-9_]*$/)) {\n\t\t\t\tmy $cnt = statement_rawlines($stat);\n\t\t\t\tmy $herectx = get_stat_here($linenr, $cnt, $here);\n\n\t\t\t\tif (WARN(\"ALLOC_WITH_MULTIPLY\",\n\t\t\t\t\t \"Prefer $newfunc over $oldfunc with multiply\\n\" . $herectx) &&\n\t\t\t\t    $cnt == 1 &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\b($Lval)\\s*\\=\\s*(?:$balanced_parens)?\\s*((?:kv|k)[mz]alloc)\\s*\\(\\s*($FuncArg)\\s*\\*\\s*($FuncArg)/$1 . ' = ' . \"$newfunc(\" . trim($r1) . ', ' . trim($r2)/e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for krealloc arg reuse\n\t\tif ($perl_version_ok &&\n\t\t    $line =~ /\\b($Lval)\\s*\\=\\s*(?:$balanced_parens)?\\s*krealloc\\s*\\(\\s*($Lval)\\s*,/ &&\n\t\t    $1 eq $3) {\n\t\t\tWARN(\"KREALLOC_ARG_REUSE\",\n\t\t\t     \"Reusing the krealloc arg is almost always a bug\\n\" . $herecurr);\n\t\t}\n\n# check for alloc argument mismatch\n\t\tif ($line =~ /\\b((?:devm_)?((?:k|kv)?(calloc|malloc_array)(?:_node)?))\\s*\\(\\s*sizeof\\b/) {\n\t\t\tWARN(\"ALLOC_ARRAY_ARGS\",\n\t\t\t     \"$1 uses number as first arg, sizeof is generally wrong\\n\" . $herecurr);\n\t\t}\n\n# check for multiple semicolons\n\t\tif ($line =~ /;\\s*;\\s*$/) {\n\t\t\tif (WARN(\"ONE_SEMICOLON\",\n\t\t\t\t \"Statements terminations use 1 semicolon\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/(\\s*;\\s*){2,}$/;/g;\n\t\t\t}\n\t\t}\n\n# check for #defines like: 1 << <digit> that could be BIT(digit), it is not exported to uapi\n\t\tif ($realfile !~ m@^include/uapi/@ &&\n\t\t    $line =~ /#\\s*define\\s+\\w+\\s+\\(?\\s*1\\s*([ulUL]*)\\s*\\<\\<\\s*(?:\\d+|$Ident)\\s*\\)?/) {\n\t\t\tmy $ull = \"\";\n\t\t\t$ull = \"_ULL\" if (defined($1) && $1 =~ /ll/i);\n\t\t\tif (CHK(\"BIT_MACRO\",\n\t\t\t\t\"Prefer using the BIT$ull macro\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\(?\\s*1\\s*[ulUL]*\\s*<<\\s*(\\d+|$Ident)\\s*\\)?/BIT${ull}($1)/;\n\t\t\t}\n\t\t}\n\n# check for IS_ENABLED() without CONFIG_<FOO> ($rawline for comments too)\n\t\tif ($rawline =~ /\\bIS_ENABLED\\s*\\(\\s*(\\w+)\\s*\\)/ && $1 !~ /^${CONFIG_}/) {\n\t\t\tWARN(\"IS_ENABLED_CONFIG\",\n\t\t\t     \"IS_ENABLED($1) is normally used as IS_ENABLED(${CONFIG_}$1)\\n\" . $herecurr);\n\t\t}\n\n# check for #if defined CONFIG_<FOO> || defined CONFIG_<FOO>_MODULE\n\t\tif ($line =~ /^\\+\\s*#\\s*if\\s+defined(?:\\s*\\(?\\s*|\\s+)(${CONFIG_}[A-Z_]+)\\s*\\)?\\s*\\|\\|\\s*defined(?:\\s*\\(?\\s*|\\s+)\\1_MODULE\\s*\\)?\\s*$/) {\n\t\t\tmy $config = $1;\n\t\t\tif (WARN(\"PREFER_IS_ENABLED\",\n\t\t\t\t \"Prefer IS_ENABLED(<FOO>) to ${CONFIG_}<FOO> || ${CONFIG_}<FOO>_MODULE\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] = \"\\+#if IS_ENABLED($config)\";\n\t\t\t}\n\t\t}\n\n# check for /* fallthrough */ like comment, prefer fallthrough;\n\t\tmy @fallthroughs = (\n\t\t\t'fallthrough',\n\t\t\t'@fallthrough@',\n\t\t\t'lint -fallthrough[ \\t]*',\n\t\t\t'intentional(?:ly)?[ \\t]*fall(?:(?:s | |-)[Tt]|t)hr(?:ough|u|ew)',\n\t\t\t'(?:else,?\\s*)?FALL(?:S | |-)?THR(?:OUGH|U|EW)[ \\t.!]*(?:-[^\\n\\r]*)?',\n\t\t\t'Fall(?:(?:s | |-)[Tt]|t)hr(?:ough|u|ew)[ \\t.!]*(?:-[^\\n\\r]*)?',\n\t\t\t'fall(?:s | |-)?thr(?:ough|u|ew)[ \\t.!]*(?:-[^\\n\\r]*)?',\n\t\t    );\n\t\tif ($raw_comment ne '') {\n\t\t\tforeach my $ft (@fallthroughs) {\n\t\t\t\tif ($raw_comment =~ /$ft/) {\n\t\t\t\t\tmy $msg_level = \\&WARN;\n\t\t\t\t\t$msg_level = \\&CHK if ($file);\n\t\t\t\t\t&{$msg_level}(\"PREFER_FALLTHROUGH\",\n\t\t\t\t\t\t      \"Prefer 'fallthrough;' over fallthrough comment\\n\" . $herecurr);\n\t\t\t\t\tlast;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for switch/default statements without a break;\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /^\\+[$;\\s]*(?:case[$;\\s]+\\w+[$;\\s]*:[$;\\s]*|)*[$;\\s]*\\bdefault[$;\\s]*:[$;\\s]*;/g) {\n\t\t\tmy $cnt = statement_rawlines($stat);\n\t\t\tmy $herectx = get_stat_here($linenr, $cnt, $here);\n\n\t\t\tWARN(\"DEFAULT_NO_BREAK\",\n\t\t\t     \"switch default: should use break\\n\" . $herectx);\n\t\t}\n\n# check for gcc specific __FUNCTION__\n\t\tif ($line =~ /\\b__FUNCTION__\\b/) {\n\t\t\tif (WARN(\"USE_FUNC\",\n\t\t\t\t \"__func__ should be used instead of gcc specific __FUNCTION__\\n\"  . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\b__FUNCTION__\\b/__func__/g;\n\t\t\t}\n\t\t}\n\n# check for uses of __DATE__, __TIME__, __TIMESTAMP__\n\t\twhile ($line =~ /\\b(__(?:DATE|TIME|TIMESTAMP)__)\\b/g) {\n\t\t\tERROR(\"DATE_TIME\",\n\t\t\t      \"Use of the '$1' macro makes the build non-deterministic\\n\" . $herecurr);\n\t\t}\n\n# check for use of yield()\n\t\tif ($line =~ /\\byield\\s*\\(\\s*\\)/) {\n\t\t\tWARN(\"YIELD\",\n\t\t\t     \"Using yield() is generally wrong. See yield() kernel-doc (sched/core.c)\\n\"  . $herecurr);\n\t\t}\n\n# check for comparisons against true and false\n\t\tif ($line =~ /\\+\\s*(.*?)\\b(true|false|$Lval)\\s*(==|\\!=)\\s*(true|false|$Lval)\\b(.*)$/i) {\n\t\t\tmy $lead = $1;\n\t\t\tmy $arg = $2;\n\t\t\tmy $test = $3;\n\t\t\tmy $otype = $4;\n\t\t\tmy $trail = $5;\n\t\t\tmy $op = \"!\";\n\n\t\t\t($arg, $otype) = ($otype, $arg) if ($arg =~ /^(?:true|false)$/i);\n\n\t\t\tmy $type = lc($otype);\n\t\t\tif ($type =~ /^(?:true|false)$/) {\n\t\t\t\tif ((\"$test\" eq \"==\" && \"$type\" eq \"true\") ||\n\t\t\t\t    (\"$test\" eq \"!=\" && \"$type\" eq \"false\")) {\n\t\t\t\t\t$op = \"\";\n\t\t\t\t}\n\n\t\t\t\tCHK(\"BOOL_COMPARISON\",\n\t\t\t\t    \"Using comparison to $otype is error prone\\n\" . $herecurr);\n\n## maybe suggesting a correct construct would better\n##\t\t\t\t    \"Using comparison to $otype is error prone.  Perhaps use '${lead}${op}${arg}${trail}'\\n\" . $herecurr);\n\n\t\t\t}\n\t\t}\n\n# check for semaphores initialized locked\n\t\tif ($line =~ /^.\\s*sema_init.+,\\W?0\\W?\\)/) {\n\t\t\tWARN(\"CONSIDER_COMPLETION\",\n\t\t\t     \"consider using a completion\\n\" . $herecurr);\n\t\t}\n\n# recommend kstrto* over simple_strto* and strict_strto*\n\t\tif ($line =~ /\\b((simple|strict)_(strto(l|ll|ul|ull)))\\s*\\(/) {\n\t\t\tWARN(\"CONSIDER_KSTRTO\",\n\t\t\t     \"$1 is obsolete, use k$3 instead\\n\" . $herecurr);\n\t\t}\n\n# check for __initcall(), use device_initcall() explicitly or more appropriate function please\n\t\tif ($line =~ /^.\\s*__initcall\\s*\\(/) {\n\t\t\tWARN(\"USE_DEVICE_INITCALL\",\n\t\t\t     \"please use device_initcall() or more appropriate function instead of __initcall() (see include/linux/init.h)\\n\" . $herecurr);\n\t\t}\n\n# check for spin_is_locked(), suggest lockdep instead\n\t\tif ($line =~ /\\bspin_is_locked\\(/) {\n\t\t\tWARN(\"USE_LOCKDEP\",\n\t\t\t     \"Where possible, use lockdep_assert_held instead of assertions based on spin_is_locked\\n\" . $herecurr);\n\t\t}\n\n# check for deprecated apis\n\t\tif ($line =~ /\\b($deprecated_apis_search)\\b\\s*\\(/) {\n\t\t\tmy $deprecated_api = $1;\n\t\t\tmy $new_api = $deprecated_apis{$deprecated_api};\n\t\t\tWARN(\"DEPRECATED_API\",\n\t\t\t     \"Deprecated use of '$deprecated_api', prefer '$new_api' instead\\n\" . $herecurr);\n\t\t}\n\n# check for various structs that are normally const (ops, kgdb, device_tree)\n# and avoid what seem like struct definitions 'struct foo {'\n\t\tif (defined($const_structs) &&\n\t\t    $line !~ /\\bconst\\b/ &&\n\t\t    $line =~ /\\bstruct\\s+($const_structs)\\b(?!\\s*\\{)/) {\n\t\t\tWARN(\"CONST_STRUCT\",\n\t\t\t     \"struct $1 should normally be const\\n\" . $herecurr);\n\t\t}\n\n# use of NR_CPUS is usually wrong\n# ignore definitions of NR_CPUS and usage to define arrays as likely right\n# ignore designated initializers using NR_CPUS\n\t\tif ($line =~ /\\bNR_CPUS\\b/ &&\n\t\t    $line !~ /^.\\s*\\s*#\\s*if\\b.*\\bNR_CPUS\\b/ &&\n\t\t    $line !~ /^.\\s*\\s*#\\s*define\\b.*\\bNR_CPUS\\b/ &&\n\t\t    $line !~ /^.\\s*$Declare\\s.*\\[[^\\]]*NR_CPUS[^\\]]*\\]/ &&\n\t\t    $line !~ /\\[[^\\]]*\\.\\.\\.[^\\]]*NR_CPUS[^\\]]*\\]/ &&\n\t\t    $line !~ /\\[[^\\]]*NR_CPUS[^\\]]*\\.\\.\\.[^\\]]*\\]/ &&\n\t\t    $line !~ /^.\\s*\\.\\w+\\s*=\\s*.*\\bNR_CPUS\\b/)\n\t\t{\n\t\t\tWARN(\"NR_CPUS\",\n\t\t\t     \"usage of NR_CPUS is often wrong - consider using cpu_possible(), num_possible_cpus(), for_each_possible_cpu(), etc\\n\" . $herecurr);\n\t\t}\n\n# Use of __ARCH_HAS_<FOO> or ARCH_HAVE_<BAR> is wrong.\n\t\tif ($line =~ /\\+\\s*#\\s*define\\s+((?:__)?ARCH_(?:HAS|HAVE)\\w*)\\b/) {\n\t\t\tERROR(\"DEFINE_ARCH_HAS\",\n\t\t\t      \"#define of '$1' is wrong - use Kconfig variables or standard guards instead\\n\" . $herecurr);\n\t\t}\n\n# likely/unlikely comparisons similar to \"(likely(foo) > 0)\"\n\t\tif ($perl_version_ok &&\n\t\t    $line =~ /\\b((?:un)?likely)\\s*\\(\\s*$FuncArg\\s*\\)\\s*$Compare/) {\n\t\t\tWARN(\"LIKELY_MISUSE\",\n\t\t\t     \"Using $1 should generally have parentheses around the comparison\\n\" . $herecurr);\n\t\t}\n\n# return sysfs_emit(foo, fmt, ...) fmt without newline\n\t\tif ($line =~ /\\breturn\\s+sysfs_emit\\s*\\(\\s*$FuncArg\\s*,\\s*($String)/ &&\n\t\t    substr($rawline, $-[6], $+[6] - $-[6]) !~ /\\\\n\"$/) {\n\t\t\tmy $offset = $+[6] - 1;\n\t\t\tif (WARN(\"SYSFS_EMIT\",\n\t\t\t\t \"return sysfs_emit(...) formats should include a terminating newline\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\tsubstr($fixed[$fixlinenr], $offset, 0) = '\\\\n';\n\t\t\t}\n\t\t}\n\n# check for array definition/declarations that should use flexible arrays instead\n\t\tif ($sline =~ /^[\\+ ]\\s*\\}(?:\\s*__packed)?\\s*;\\s*$/ &&\n\t\t    $prevline =~ /^\\+\\s*(?:\\}(?:\\s*__packed\\s*)?|$Type)\\s*$Ident\\s*\\[\\s*(0|1)\\s*\\]\\s*;\\s*$/) {\n\t\t\tif (ERROR(\"FLEXIBLE_ARRAY\",\n\t\t\t\t  \"Use C99 flexible arrays - see https://docs.kernel.org/process/deprecated.html#zero-length-and-one-element-arrays\\n\" . $hereprev) &&\n\t\t\t    $1 == '0' && $fix) {\n\t\t\t\t$fixed[$fixlinenr - 1] =~ s/\\[\\s*0\\s*\\]/[]/;\n\t\t\t}\n\t\t}\n\n# nested likely/unlikely calls\n\t\tif ($line =~ /\\b(?:(?:un)?likely)\\s*\\(\\s*!?\\s*(IS_ERR(?:_OR_NULL|_VALUE)?|WARN)/) {\n\t\t\tWARN(\"LIKELY_MISUSE\",\n\t\t\t     \"nested (un)?likely() calls, $1 already uses unlikely() internally\\n\" . $herecurr);\n\t\t}\n\n# whine mightly about in_atomic\n\t\tif ($line =~ /\\bin_atomic\\s*\\(/) {\n\t\t\tif ($realfile =~ m@^drivers/@) {\n\t\t\t\tERROR(\"IN_ATOMIC\",\n\t\t\t\t      \"do not use in_atomic in drivers\\n\" . $herecurr);\n\t\t\t} elsif ($realfile !~ m@^kernel/@) {\n\t\t\t\tWARN(\"IN_ATOMIC\",\n\t\t\t\t     \"use of in_atomic() is incorrect outside core kernel code\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# Complain about RCU Tasks Trace used outside of BPF (and of course, RCU).\n\t\tour $rcu_trace_funcs = qr{(?x:\n\t\t\trcu_read_lock_trace |\n\t\t\trcu_read_lock_trace_held |\n\t\t\trcu_read_unlock_trace |\n\t\t\tcall_rcu_tasks_trace |\n\t\t\tsynchronize_rcu_tasks_trace |\n\t\t\trcu_barrier_tasks_trace |\n\t\t\trcu_request_urgent_qs_task\n\t\t)};\n\t\tour $rcu_trace_paths = qr{(?x:\n\t\t\tkernel/bpf/ |\n\t\t\tinclude/linux/bpf |\n\t\t\tnet/bpf/ |\n\t\t\tkernel/rcu/ |\n\t\t\tinclude/linux/rcu\n\t\t)};\n\t\tif ($line =~ /\\b($rcu_trace_funcs)\\s*\\(/) {\n\t\t\tif ($realfile !~ m{^$rcu_trace_paths}) {\n\t\t\t\tWARN(\"RCU_TASKS_TRACE\",\n\t\t\t\t     \"use of RCU tasks trace is incorrect outside BPF or core RCU code\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# check for lockdep_set_novalidate_class\n\t\tif ($line =~ /^.\\s*lockdep_set_novalidate_class\\s*\\(/ ||\n\t\t    $line =~ /__lockdep_no_validate__\\s*\\)/ ) {\n\t\t\tif ($realfile !~ m@^kernel/lockdep@ &&\n\t\t\t    $realfile !~ m@^include/linux/lockdep@ &&\n\t\t\t    $realfile !~ m@^drivers/base/core@) {\n\t\t\t\tERROR(\"LOCKDEP\",\n\t\t\t\t      \"lockdep_no_validate class is reserved for device->mutex.\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n\t\tif ($line =~ /debugfs_create_\\w+.*\\b$mode_perms_world_writable\\b/ ||\n\t\t    $line =~ /DEVICE_ATTR.*\\b$mode_perms_world_writable\\b/) {\n\t\t\tWARN(\"EXPORTED_WORLD_WRITABLE\",\n\t\t\t     \"Exporting world writable files is usually an error. Consider more restrictive permissions.\\n\" . $herecurr);\n\t\t}\n\n# check for DEVICE_ATTR uses that could be DEVICE_ATTR_<FOO>\n# and whether or not function naming is typical and if\n# DEVICE_ATTR permissions uses are unusual too\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $stat =~ /\\bDEVICE_ATTR\\s*\\(\\s*(\\w+)\\s*,\\s*\\(?\\s*(\\s*(?:${multi_mode_perms_string_search}|0[0-7]{3,3})\\s*)\\s*\\)?\\s*,\\s*(\\w+)\\s*,\\s*(\\w+)\\s*\\)/) {\n\t\t\tmy $var = $1;\n\t\t\tmy $perms = $2;\n\t\t\tmy $show = $3;\n\t\t\tmy $store = $4;\n\t\t\tmy $octal_perms = perms_to_octal($perms);\n\t\t\tif ($show =~ /^${var}_show$/ &&\n\t\t\t    $store =~ /^${var}_store$/ &&\n\t\t\t    $octal_perms eq \"0644\") {\n\t\t\t\tif (WARN(\"DEVICE_ATTR_RW\",\n\t\t\t\t\t \"Use DEVICE_ATTR_RW\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\bDEVICE_ATTR\\s*\\(\\s*$var\\s*,\\s*\\Q$perms\\E\\s*,\\s*$show\\s*,\\s*$store\\s*\\)/DEVICE_ATTR_RW(${var})/;\n\t\t\t\t}\n\t\t\t} elsif ($show =~ /^${var}_show$/ &&\n\t\t\t\t $store =~ /^NULL$/ &&\n\t\t\t\t $octal_perms eq \"0444\") {\n\t\t\t\tif (WARN(\"DEVICE_ATTR_RO\",\n\t\t\t\t\t \"Use DEVICE_ATTR_RO\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\bDEVICE_ATTR\\s*\\(\\s*$var\\s*,\\s*\\Q$perms\\E\\s*,\\s*$show\\s*,\\s*NULL\\s*\\)/DEVICE_ATTR_RO(${var})/;\n\t\t\t\t}\n\t\t\t} elsif ($show =~ /^NULL$/ &&\n\t\t\t\t $store =~ /^${var}_store$/ &&\n\t\t\t\t $octal_perms eq \"0200\") {\n\t\t\t\tif (WARN(\"DEVICE_ATTR_WO\",\n\t\t\t\t\t \"Use DEVICE_ATTR_WO\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\bDEVICE_ATTR\\s*\\(\\s*$var\\s*,\\s*\\Q$perms\\E\\s*,\\s*NULL\\s*,\\s*$store\\s*\\)/DEVICE_ATTR_WO(${var})/;\n\t\t\t\t}\n\t\t\t} elsif ($octal_perms eq \"0644\" ||\n\t\t\t\t $octal_perms eq \"0444\" ||\n\t\t\t\t $octal_perms eq \"0200\") {\n\t\t\t\tmy $newshow = \"$show\";\n\t\t\t\t$newshow = \"${var}_show\" if ($show ne \"NULL\" && $show ne \"${var}_show\");\n\t\t\t\tmy $newstore = $store;\n\t\t\t\t$newstore = \"${var}_store\" if ($store ne \"NULL\" && $store ne \"${var}_store\");\n\t\t\t\tmy $rename = \"\";\n\t\t\t\tif ($show ne $newshow) {\n\t\t\t\t\t$rename .= \" '$show' to '$newshow'\";\n\t\t\t\t}\n\t\t\t\tif ($store ne $newstore) {\n\t\t\t\t\t$rename .= \" '$store' to '$newstore'\";\n\t\t\t\t}\n\t\t\t\tWARN(\"DEVICE_ATTR_FUNCTIONS\",\n\t\t\t\t     \"Consider renaming function(s)$rename\\n\" . $herecurr);\n\t\t\t} else {\n\t\t\t\tWARN(\"DEVICE_ATTR_PERMS\",\n\t\t\t\t     \"DEVICE_ATTR unusual permissions '$perms' used\\n\" . $herecurr);\n\t\t\t}\n\t\t}\n\n# Mode permission misuses where it seems decimal should be octal\n# This uses a shortcut match to avoid unnecessary uses of a slow foreach loop\n# o Ignore module_param*(...) uses with a decimal 0 permission as that has a\n#   specific definition of not visible in sysfs.\n# o Ignore proc_create*(...) uses with a decimal 0 permission as that means\n#   use the default permissions\n\t\tif ($perl_version_ok &&\n\t\t    defined $stat &&\n\t\t    $line =~ /$mode_perms_search/) {\n\t\t\tforeach my $entry (@mode_permission_funcs) {\n\t\t\t\tmy $func = $entry->[0];\n\t\t\t\tmy $arg_pos = $entry->[1];\n\n\t\t\t\tmy $lc = $stat =~ tr@\\n@@;\n\t\t\t\t$lc = $lc + $linenr;\n\t\t\t\tmy $stat_real = get_stat_real($linenr, $lc);\n\n\t\t\t\tmy $skip_args = \"\";\n\t\t\t\tif ($arg_pos > 1) {\n\t\t\t\t\t$arg_pos--;\n\t\t\t\t\t$skip_args = \"(?:\\\\s*$FuncArg\\\\s*,\\\\s*){$arg_pos,$arg_pos}\";\n\t\t\t\t}\n\t\t\t\tmy $test = \"\\\\b$func\\\\s*\\\\(${skip_args}($FuncArg(?:\\\\|\\\\s*$FuncArg)*)\\\\s*[,\\\\)]\";\n\t\t\t\tif ($stat =~ /$test/) {\n\t\t\t\t\tmy $val = $1;\n\t\t\t\t\t$val = $6 if ($skip_args ne \"\");\n\t\t\t\t\tif (!($func =~ /^(?:module_param|proc_create)/ && $val eq \"0\") &&\n\t\t\t\t\t    (($val =~ /^$Int$/ && $val !~ /^$Octal$/) ||\n\t\t\t\t\t     ($val =~ /^$Octal$/ && length($val) ne 4))) {\n\t\t\t\t\t\tERROR(\"NON_OCTAL_PERMISSIONS\",\n\t\t\t\t\t\t      \"Use 4 digit octal (0777) not decimal permissions\\n\" . \"$here\\n\" . $stat_real);\n\t\t\t\t\t}\n\t\t\t\t\tif ($val =~ /^$Octal$/ && (oct($val) & 02)) {\n\t\t\t\t\t\tERROR(\"EXPORTED_WORLD_WRITABLE\",\n\t\t\t\t\t\t      \"Exporting writable files is usually an error. Consider more restrictive permissions.\\n\" . \"$here\\n\" . $stat_real);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for uses of S_<PERMS> that could be octal for readability\n\t\twhile ($line =~ m{\\b($multi_mode_perms_string_search)\\b}g) {\n\t\t\tmy $oval = $1;\n\t\t\tmy $octal = perms_to_octal($oval);\n\t\t\tif (WARN(\"SYMBOLIC_PERMS\",\n\t\t\t\t \"Symbolic permissions '$oval' are not preferred. Consider using octal permissions '$octal'.\\n\" . $herecurr) &&\n\t\t\t    $fix) {\n\t\t\t\t$fixed[$fixlinenr] =~ s/\\Q$oval\\E/$octal/;\n\t\t\t}\n\t\t}\n\n# validate content of MODULE_LICENSE against list from include/linux/module.h\n\t\tif ($line =~ /\\bMODULE_LICENSE\\s*\\(\\s*($String)\\s*\\)/) {\n\t\t\tmy $extracted_string = get_quoted_string($line, $rawline);\n\t\t\tmy $valid_licenses = qr{\n\t\t\t\t\t\tGPL|\n\t\t\t\t\t\tGPL\\ v2|\n\t\t\t\t\t\tGPL\\ and\\ additional\\ rights|\n\t\t\t\t\t\tDual\\ BSD/GPL|\n\t\t\t\t\t\tDual\\ MIT/GPL|\n\t\t\t\t\t\tDual\\ MPL/GPL|\n\t\t\t\t\t\tProprietary\n\t\t\t\t\t}x;\n\t\t\tif ($extracted_string !~ /^\"(?:$valid_licenses)\"$/x) {\n\t\t\t\tWARN(\"MODULE_LICENSE\",\n\t\t\t\t     \"unknown module license \" . $extracted_string . \"\\n\" . $herecurr);\n\t\t\t}\n\t\t\tif (!$file && $extracted_string eq '\"GPL v2\"') {\n\t\t\t\tif (WARN(\"MODULE_LICENSE\",\n\t\t\t\t     \"Prefer \\\"GPL\\\" over \\\"GPL v2\\\" - see commit bf7fbeeae6db (\\\"module: Cure the MODULE_LICENSE \\\"GPL\\\" vs. \\\"GPL v2\\\" bogosity\\\")\\n\" . $herecurr) &&\n\t\t\t\t    $fix) {\n\t\t\t\t\t$fixed[$fixlinenr] =~ s/\\bMODULE_LICENSE\\s*\\(\\s*\"GPL v2\"\\s*\\)/MODULE_LICENSE(\"GPL\")/;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n# check for sysctl duplicate constants\n\t\tif ($line =~ /\\.extra[12]\\s*=\\s*&(zero|one|int_max)\\b/) {\n\t\t\tWARN(\"DUPLICATED_SYSCTL_CONST\",\n\t\t\t\t\"duplicated sysctl range checking value '$1', consider using the shared one in include/linux/sysctl.h\\n\" . $herecurr);\n\t\t}\n\t}\n\n\t# If we have no input at all, then there is nothing to report on\n\t# so just keep quiet.\n\tif ($#rawlines == -1) {\n\t\texit(0);\n\t}\n\n\t# In mailback mode only produce a report in the negative, for\n\t# things that appear to be patches.\n\tif ($mailback && ($clean == 1 || !$is_patch)) {\n\t\texit(0);\n\t}\n\n\t# This is not a patch, and we are in 'no-patch' mode so\n\t# just keep quiet.\n\tif (!$chk_patch && !$is_patch) {\n\t\texit(0);\n\t}\n\n\tif (!$is_patch && $filename !~ /cover-letter\\.patch$/) {\n\t\tERROR(\"NOT_UNIFIED_DIFF\",\n\t\t      \"Does not appear to be a unified-diff format patch\\n\");\n\t}\n\tif ($is_patch && $has_commit_log && $chk_fixes_tag) {\n\t\tif ($needs_fixes_tag ne \"\" && !$is_revert && !$fixes_tag) {\n\t\t\tWARN(\"MISSING_FIXES_TAG\",\n\t\t\t\t \"The commit message has '$needs_fixes_tag', perhaps it also needs a 'Fixes:' tag?\\n\");\n\t\t}\n\t}\n\tif ($is_patch && $has_commit_log && $chk_signoff) {\n\t\tif ($signoff == 0) {\n\t\t\tERROR(\"MISSING_SIGN_OFF\",\n\t\t\t      \"Missing Signed-off-by: line(s)\\n\");\n\t\t} elsif ($authorsignoff != 1) {\n\t\t\t# authorsignoff values:\n\t\t\t# 0 -> missing sign off\n\t\t\t# 1 -> sign off identical\n\t\t\t# 2 -> names and addresses match, comments mismatch\n\t\t\t# 3 -> addresses match, names different\n\t\t\t# 4 -> names match, addresses different\n\t\t\t# 5 -> names match, addresses excluding subaddress details (refer RFC 5233) match\n\n\t\t\tmy $sob_msg = \"'From: $author' != 'Signed-off-by: $author_sob'\";\n\n\t\t\tif ($authorsignoff == 0) {\n\t\t\t\tERROR(\"NO_AUTHOR_SIGN_OFF\",\n\t\t\t\t      \"Missing Signed-off-by: line by nominal patch author '$author'\\n\");\n\t\t\t} elsif ($authorsignoff == 2) {\n\t\t\t\tCHK(\"FROM_SIGN_OFF_MISMATCH\",\n\t\t\t\t    \"From:/Signed-off-by: email comments mismatch: $sob_msg\\n\");\n\t\t\t} elsif ($authorsignoff == 3) {\n\t\t\t\tWARN(\"FROM_SIGN_OFF_MISMATCH\",\n\t\t\t\t     \"From:/Signed-off-by: email name mismatch: $sob_msg\\n\");\n\t\t\t} elsif ($authorsignoff == 4) {\n\t\t\t\tWARN(\"FROM_SIGN_OFF_MISMATCH\",\n\t\t\t\t     \"From:/Signed-off-by: email address mismatch: $sob_msg\\n\");\n\t\t\t} elsif ($authorsignoff == 5) {\n\t\t\t\tWARN(\"FROM_SIGN_OFF_MISMATCH\",\n\t\t\t\t     \"From:/Signed-off-by: email subaddress mismatch: $sob_msg\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprint report_dump();\n\tif ($summary && !($clean == 1 && $quiet == 1)) {\n\t\tprint \"$filename \" if ($summary_file);\n\t\tprint \"total: $cnt_error errors, $cnt_warn warnings, \" .\n\t\t\t(($check)? \"$cnt_chk checks, \" : \"\") .\n\t\t\t\"$cnt_lines lines checked\\n\";\n\t}\n\n\tif ($quiet == 0) {\n\t\t# If there were any defects found and not already fixing them\n\t\tif (!$clean and !$fix) {\n\t\t\tprint << \"EOM\"\n\nNOTE: For some of the reported defects, checkpatch may be able to\n      mechanically convert to the typical style using --fix or --fix-inplace.\nEOM\n\t\t}\n\t\t# If there were whitespace errors which cleanpatch can fix\n\t\t# then suggest that.\n\t\tif ($rpt_cleaners) {\n\t\t\t$rpt_cleaners = 0;\n\t\t\tprint << \"EOM\"\n\nNOTE: Whitespace errors detected.\n      You may wish to use scripts/cleanpatch or scripts/cleanfile\nEOM\n\t\t}\n\t}\n\n\tif ($clean == 0 && $fix &&\n\t    (\"@rawlines\" ne \"@fixed\" ||\n\t     $#fixed_inserted >= 0 || $#fixed_deleted >= 0)) {\n\t\tmy $newfile = $filename;\n\t\t$newfile .= \".EXPERIMENTAL-checkpatch-fixes\" if (!$fix_inplace);\n\t\tmy $linecount = 0;\n\t\tmy $f;\n\n\t\t@fixed = fix_inserted_deleted_lines(\\@fixed, \\@fixed_inserted, \\@fixed_deleted);\n\n\t\topen($f, '>', $newfile)\n\t\t    or die \"$P: Can't open $newfile for write\\n\";\n\t\tforeach my $fixed_line (@fixed) {\n\t\t\t$linecount++;\n\t\t\tif ($file) {\n\t\t\t\tif ($linecount > 3) {\n\t\t\t\t\t$fixed_line =~ s/^\\+//;\n\t\t\t\t\tprint $f $fixed_line . \"\\n\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint $f $fixed_line . \"\\n\";\n\t\t\t}\n\t\t}\n\t\tclose($f);\n\n\t\tif (!$quiet) {\n\t\t\tprint << \"EOM\";\n\nWrote EXPERIMENTAL --fix correction(s) to '$newfile'\n\nDo _NOT_ trust the results written to this file.\nDo _NOT_ submit these changes without inspecting them for correctness.\n\nThis EXPERIMENTAL file is simply a convenience to help rewrite patches.\nNo warranties, expressed or implied...\nEOM\n\t\t}\n\t}\n\n\tif ($quiet == 0) {\n\t\tprint \"\\n\";\n\t\tif ($clean == 1) {\n\t\t\tprint \"$vname has no obvious style problems and is ready for submission.\\n\";\n\t\t} else {\n\t\t\tprint \"$vname has style problems, please review.\\n\";\n\t\t}\n\t}\n\treturn $clean;\n}\n"
        },
        {
          "name": "dev-docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "make_release_tarball.sh",
          "type": "blob",
          "size": 0.8359375,
          "content": "#!/bin/sh\n#\n# Create tarball from Git tag, removing and adding\n# some files.\n#\n\nset -e\n\nif [ -z \"$1\" ]; then\n    TAG=\"$(git tag --list 'fuse-3*' --sort=-creatordate | head -1)\"\nelse\n    TAG=\"$1\"\nfi\nPREV_TAG=\"$(git tag --list 'fuse-3*' --sort=-creatordate --merged \"${TAG}^\"| head -1)\"\nMAJOR_REV=${TAG%.*}\n\necho \"Creating release tarball for ${TAG}...\"\n\ngit checkout -q \"${TAG}\"\ndoxygen doc/Doxyfile\n\nmkdir \"${TAG}\"\n\ngit archive --format=tar \"${TAG}\" | tar -x \"--directory=${TAG}\"\nfind \"${TAG}\" -name .gitignore -delete\nrm -r \"${TAG}/make_release_tarball.sh\" \\\n      \"${TAG}/.github\" \\\n      \"${TAG}/.cirrus.yml\"\ncp -a doc/html \"${TAG}/doc/\"\ntar -czf \"${TAG}.tar.gz\" \"${TAG}/\"\n\nsignify-openbsd -S -s signify/$MAJOR_REV.sec -m $TAG.tar.gz\n\n\necho \"Contributors from ${PREV_TAG} to ${TAG}:\"\ngit log --pretty=\"format:%an <%aE>\" \"${PREV_TAG}..${TAG}\" | sort -u\n\n"
        },
        {
          "name": "meson.build",
          "type": "blob",
          "size": 7.986328125,
          "content": "project('libfuse3', ['c'], version: '3.17.0',\n        meson_version: '>= 0.51',\n        default_options: [\n            'buildtype=debugoptimized',\n            'c_std=gnu11',\n            'cpp_std=c++17',\n            'warning_level=2',\n        ])\n\n# Would be better to create the version string\n# from integers, i.e. concatenating strings instead\n# of splitting a string, but 'project' needs to be\n# the first meson.build keyword...\nversion_list = meson.project_version().split('.')\nFUSE_MAJOR_VERSION = version_list[0]\nFUSE_MINOR_VERSION = version_list[1]\nFUSE_HOTFIX_VERSION = version_list[2]\n\nplatform = host_machine.system()\nif platform == 'darwin'\n  error('libfuse does not support OS-X.\\n' +\n        'Take a look at http://osxfuse.github.io/ or the more recent\\n' +\n        'https://www.fuse-t.org/ instead')\nelif platform == 'cygwin' or platform == 'windows'\n  error('libfuse does not support Windows.\\n' +\n        'Take a look at http://www.secfs.net/winfsp/ instead')       \nendif\n\ncc = meson.get_compiler('c')\n\n#\n# Feature detection, only available at libfuse compilation time,\n# but not for application linking to libfuse.\n#\nprivate_cfg = configuration_data()\n\n#\n# Feature detection, the resulting config file is installed\n# with the package.\n# Note: Symbols need to be care fully named, to avoid conflicts\n#       with applications linking to libfuse and including\n#       this config.\n#\npublic_cfg = configuration_data()\n\npublic_cfg.set('FUSE_MAJOR_VERSION', FUSE_MAJOR_VERSION)\npublic_cfg.set('FUSE_MINOR_VERSION', FUSE_MINOR_VERSION)\npublic_cfg.set('FUSE_HOTFIX_VERSION', FUSE_HOTFIX_VERSION)\n\n# Default includes when checking for presence of functions and\n# struct members\ninclude_default = '''\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n'''\nargs_default = [ '-D_GNU_SOURCE' ]\n\nprivate_cfg.set_quoted('PACKAGE_VERSION', meson.project_version())\n\n# Test for presence of some functions\ntest_funcs = [ 'fork', 'fstatat', 'openat', 'readlinkat', 'pipe2',\n               'splice', 'vmsplice', 'posix_fallocate', 'fdatasync',\n               'utimensat', 'copy_file_range', 'fallocate' ]\nforeach func : test_funcs\n    private_cfg.set('HAVE_' + func.to_upper(),\n        cc.has_function(func, prefix: include_default, args: args_default))\nendforeach\nprivate_cfg.set('HAVE_SETXATTR', \n        cc.has_function('setxattr', prefix: '#include <sys/xattr.h>'))\nprivate_cfg.set('HAVE_ICONV', \n        cc.has_function('iconv', prefix: '#include <iconv.h>'))\nprivate_cfg.set('HAVE_BACKTRACE',\n        cc.has_function('backtrace', prefix: '#include <execinfo.h>'))\n\n# Test if structs have specific member\nprivate_cfg.set('HAVE_STRUCT_STAT_ST_ATIM',\n         cc.has_member('struct stat', 'st_atim',\n                       prefix: include_default,\n                       args: args_default))\nprivate_cfg.set('HAVE_STRUCT_STAT_ST_ATIMESPEC',\n         cc.has_member('struct stat', 'st_atimespec',\n                       prefix: include_default,\n                       args: args_default))\n\n#\n# Compiler configuration\n#\nadd_project_arguments('-D_REENTRANT', '-DHAVE_LIBFUSE_PRIVATE_CONFIG_H', '-Wno-sign-compare', '-D_FILE_OFFSET_BITS=64',\n                      '-Wstrict-prototypes', '-Wmissing-declarations', '-Wwrite-strings',\n                      '-fno-strict-aliasing', language: 'c')\nadd_project_arguments('-D_REENTRANT', '-DHAVE_LIBFUSE_PRIVATE_CONFIG_H', '-D_GNU_SOURCE', '-D_FILE_OFFSET_BITS=64',\n                     '-Wno-sign-compare', '-Wmissing-declarations',\n                     '-Wwrite-strings', '-fno-strict-aliasing', language: 'cpp')\n\n# Some (stupid) GCC versions warn about unused return values even when they are\n# casted to void. This makes -Wunused-result pretty useless, since there is no\n# way to suppress the warning when we really *want* to ignore the value.\ncode = '''\n__attribute__((warn_unused_result)) int get_4() {\n    return 4;\n}\nint main(void) {\n    (void) get_4();\n    return 0;\n}'''\nif not cc.compiles(code, args: [ '-O0', '-Werror=unused-result' ])\n     message('Compiler warns about unused result even when casting to void')\n     add_project_arguments('-Wno-unused-result', language: 'c')\nendif\n\n# It is hard to detect if the libc supports versioned symbols. Only gnu-libc\n# seems to provide that, but then glibc is the main target for libfuse, so\n# enable it by default\nversioned_symbols = 1\n\n# This is an attempt to detect if another libc is used.\ncode = '''\nint main(void) {\n#if (defined(__UCLIBC__) || defined(__APPLE__))\n#error /* libc does not have versioned symbols */\n#endif\n    return 0;\n}'''\nif not cc.compiles(code, args: [ '-O0' ])\n  versioned_symbols = 0\nendif\n\n# The detection can be overridden, which is useful for other (above unhandled)\n# libcs and also especially useful for testing\nif get_option('disable-libc-symbol-version')\n     versioned_symbols = 0\nendif\n\nif versioned_symbols == 1\n     message('Enabling versioned libc symbols')\n     public_cfg.set('LIBFUSE_BUILT_WITH_VERSIONED_SYMBOLS', 1)\n\n     # gcc-10 and newer support the symver attribute which we need to use if we\n     # want to support LTO\n     # recent clang and gcc both support __has_attribute (and if they are too old\n     # to have __has_attribute, then they are too old to support symver)\n     # other compilers might not have __has_attribute, but in those cases\n     # it is safe for this check to fail and for us to fallback to the old _asm_\n     # method for symver. Anyway the attributes not supported by __has_attribute()\n     # unfortunately return true giving a false positive. So let's try to build\n     # using __attribute__ ((symver )) and see the result.\n     code = '''\n     __attribute__ ((symver (\"test@TEST\")))\n     void foo(void) {\n     }\n\n     int main(void) {\n         return 0;\n     }'''\n     if cc.compiles(code, args: [ '-O0', '-c', '-Werror'])\n          message('Compiler supports symver attribute')\n          add_project_arguments('-DHAVE_SYMVER_ATTRIBUTE', language: 'c')\n     else\n          message('Compiler does not support symver attribute')\n     endif\nelse\n     message('Disabling versioned libc symbols')\nendif\n\n# Older versions of musl libc don't unescape entries in /etc/mtab\n# Try to detect this behaviour, and work around, if necessary.\ndetect_getmntent_needs_unescape = '''\n#define _GNU_SOURCE\n#include <mntent.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define dir_space_tab \"dir\\\\040space\\\\011tab\"\n\nint main()\n{\n    const char *fake_mtab = \"name \" dir_space_tab \" type opts 0 0\\n\";\n    FILE *f = fmemopen((void *)fake_mtab, strlen(fake_mtab) + 1, \"r\");\n    struct mntent *entp = getmntent(f);\n    fclose(f);\n    if(NULL == entp)\n        exit(EXIT_FAILURE);\n    if (0 == strcmp(entp->mnt_dir, dir_space_tab))\n        printf(\"needs escaping\\n\");\n    else\n        printf(\"no need to escape\\n\");\n}\n'''\n\nif not meson.is_cross_build()\n  result = cc.run(detect_getmntent_needs_unescape)\n  if result.compiled() and result.returncode() == 0 and result.stdout().strip() == 'needs escaping'\n    message('getmntent does not unescape')\n    add_project_arguments('-DGETMNTENT_NEEDS_UNESCAPING', language: 'c')\n  endif\nendif\n\n# Write private test results into fuse_config.h (stored in build directory)\nconfigure_file(output: 'fuse_config.h', configuration : private_cfg)\n\n# Write the test results, installed with the package,\n# symbols need to be properly prefixed to avoid\n# symbol (define) conflicts\nconfigure_file(output: 'libfuse_config.h',\n               configuration : public_cfg,\n               install: true, install_dir: join_paths(get_option('includedir'), 'fuse3'))\n\n# '.' will refer to current build directory, which contains config.h\ninclude_dirs = include_directories('include', 'lib', '.')\n\n# Common dependencies\nthread_dep = dependency('threads') \n\n#\n# Read build files from sub-directories\n#\nsubdirs = [ 'lib', 'include']\nif get_option('utils') and not platform.endswith('bsd') and platform != 'dragonfly'\n  subdirs += [ 'util', 'doc' ]\nendif\n\nif get_option('examples')\n  subdirs += 'example'\nendif\n\nif get_option('tests')\n  subdirs += 'test'\nendif\n\nforeach n : subdirs\n    subdir(n)\nendforeach\n\n"
        },
        {
          "name": "meson_options.txt",
          "type": "blob",
          "size": 0.986328125,
          "content": "option('disable-mtab', type : 'boolean', value : false,\n       description: 'Disable and ignore usage of /etc/mtab')\n\noption('udevrulesdir', type : 'string', value : '',\n       description: 'Where to install udev rules (if empty, query pkg-config(1))')\n\noption('initscriptdir', type : 'string', value : '/etc/init.d/',\n       description: 'Init script installation location (if empty, disable init script installation)')\n\noption('utils', type : 'boolean', value : true,\n       description: 'Whether or not to build and install helper programs')\n\noption('examples', type : 'boolean', value : true,\n       description: 'Whether or not to build example programs')\n\noption('useroot', type : 'boolean', value : true,\n       description: 'Set owner and setuid bits on installed files')\n\noption('tests', type : 'boolean', value : true,\n       description: 'Compile the test files')\n\noption('disable-libc-symbol-version', type : 'boolean', value : false,\n       description: 'Disable versioned symbols through libc')\n\n"
        },
        {
          "name": "requirements.txt",
          "type": "blob",
          "size": 0.1591796875,
          "content": "# Packages required for building and testing libfuse only,\n# no python code is required when using libfuse.\n# Build packages: \nmeson\nninja\n# Test packages:\npytest\n"
        },
        {
          "name": "signify",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tsan_suppressions.txt",
          "type": "blob",
          "size": 0.1181640625,
          "content": "# Use with\n# TSAN_OPTIONS=\"suppressions=tsan_suppressions.txt\" ./myprogram\n\n# False positive\nrace:pthread_setcancelstate\n"
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        },
        {
          "name": "xfstests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}