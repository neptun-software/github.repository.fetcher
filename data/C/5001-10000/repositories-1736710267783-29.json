{
  "metadata": {
    "timestamp": 1736710267783,
    "page": 29,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "lua/lua",
      "stars": 8707,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1123046875,
          "content": ".gitattributes\n\n*.so\n*.o\n*.a\n\nmanual/manual.html\n\ntestes/time.txt\ntestes/time-debug.txt\n\ntestes/libs/all\n\ntemp\nlua\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.431640625,
          "content": "# Lua\n\nThis is the repository of Lua development code, as seen by the Lua team. It contains the full history of all commits but is mirrored irregularly. For complete information about Lua, visit [Lua.org](https://www.lua.org/).\n\nPlease **do not** send pull requests. To report issues, post a message to the [Lua mailing list](https://www.lua.org/lua-l.html).\n\nDownload official Lua releases from [Lua.org](https://www.lua.org/download.html).\n"
        },
        {
          "name": "all",
          "type": "blob",
          "size": 0.2001953125,
          "content": "make -s -j\ncd testes/libs; make -s\ncd ..     # back to directory 'testes'\nulimit -S -s 1100\nif { ../lua -W all.lua; } then\n  echo -e \"\\n\\n    final OK!!!!\\n\\n\"\nelse\n  echo -e \"\\n\\n    >>>> BUG!!!!\\n\\n\"\nfi\n"
        },
        {
          "name": "lapi.c",
          "type": "blob",
          "size": 35.8271484375,
          "content": "/*\n** $Id: lapi.c $\n** Lua API\n** See Copyright Notice in lua.h\n*/\n\n#define lapi_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <limits.h>\n#include <stdarg.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lundump.h\"\n#include \"lvm.h\"\n\n\n\nconst char lua_ident[] =\n  \"$LuaVersion: \" LUA_COPYRIGHT \" $\"\n  \"$LuaAuthors: \" LUA_AUTHORS \" $\";\n\n\n\n/*\n** Test for a valid index (one that is not the 'nilvalue').\n** '!ttisnil(o)' implies 'o != &G(L)->nilvalue', so it is not needed.\n** However, it covers the most common cases in a faster way.\n*/\n#define isvalid(L, o)\t(!ttisnil(o) || o != &G(L)->nilvalue)\n\n\n/* test for pseudo index */\n#define ispseudo(i)\t\t((i) <= LUA_REGISTRYINDEX)\n\n/* test for upvalue */\n#define isupvalue(i)\t\t((i) < LUA_REGISTRYINDEX)\n\n\n/*\n** Convert an acceptable index to a pointer to its respective value.\n** Non-valid indices return the special nil value 'G(L)->nilvalue'.\n*/\nstatic TValue *index2value (lua_State *L, int idx) {\n  CallInfo *ci = L->ci;\n  if (idx > 0) {\n    StkId o = ci->func.p + idx;\n    api_check(L, idx <= ci->top.p - (ci->func.p + 1), \"unacceptable index\");\n    if (o >= L->top.p) return &G(L)->nilvalue;\n    else return s2v(o);\n  }\n  else if (!ispseudo(idx)) {  /* negative index */\n    api_check(L, idx != 0 && -idx <= L->top.p - (ci->func.p + 1),\n                 \"invalid index\");\n    return s2v(L->top.p + idx);\n  }\n  else if (idx == LUA_REGISTRYINDEX)\n    return &G(L)->l_registry;\n  else {  /* upvalues */\n    idx = LUA_REGISTRYINDEX - idx;\n    api_check(L, idx <= MAXUPVAL + 1, \"upvalue index too large\");\n    if (ttisCclosure(s2v(ci->func.p))) {  /* C closure? */\n      CClosure *func = clCvalue(s2v(ci->func.p));\n      return (idx <= func->nupvalues) ? &func->upvalue[idx-1]\n                                      : &G(L)->nilvalue;\n    }\n    else {  /* light C function or Lua function (through a hook)?) */\n      api_check(L, ttislcf(s2v(ci->func.p)), \"caller not a C function\");\n      return &G(L)->nilvalue;  /* no upvalues */\n    }\n  }\n}\n\n\n\n/*\n** Convert a valid actual index (not a pseudo-index) to its address.\n*/\nstatic StkId index2stack (lua_State *L, int idx) {\n  CallInfo *ci = L->ci;\n  if (idx > 0) {\n    StkId o = ci->func.p + idx;\n    api_check(L, o < L->top.p, \"invalid index\");\n    return o;\n  }\n  else {    /* non-positive index */\n    api_check(L, idx != 0 && -idx <= L->top.p - (ci->func.p + 1),\n                 \"invalid index\");\n    api_check(L, !ispseudo(idx), \"invalid index\");\n    return L->top.p + idx;\n  }\n}\n\n\nLUA_API int lua_checkstack (lua_State *L, int n) {\n  int res;\n  CallInfo *ci;\n  lua_lock(L);\n  ci = L->ci;\n  api_check(L, n >= 0, \"negative 'n'\");\n  if (L->stack_last.p - L->top.p > n)  /* stack large enough? */\n    res = 1;  /* yes; check is OK */\n  else  /* need to grow stack */\n    res = luaD_growstack(L, n, 0);\n  if (res && ci->top.p < L->top.p + n)\n    ci->top.p = L->top.p + n;  /* adjust frame top */\n  lua_unlock(L);\n  return res;\n}\n\n\nLUA_API void lua_xmove (lua_State *from, lua_State *to, int n) {\n  int i;\n  if (from == to) return;\n  lua_lock(to);\n  api_checkpop(from, n);\n  api_check(from, G(from) == G(to), \"moving among independent states\");\n  api_check(from, to->ci->top.p - to->top.p >= n, \"stack overflow\");\n  from->top.p -= n;\n  for (i = 0; i < n; i++) {\n    setobjs2s(to, to->top.p, from->top.p + i);\n    to->top.p++;  /* stack already checked by previous 'api_check' */\n  }\n  lua_unlock(to);\n}\n\n\nLUA_API lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf) {\n  lua_CFunction old;\n  lua_lock(L);\n  old = G(L)->panic;\n  G(L)->panic = panicf;\n  lua_unlock(L);\n  return old;\n}\n\n\nLUA_API lua_Number lua_version (lua_State *L) {\n  UNUSED(L);\n  return LUA_VERSION_NUM;\n}\n\n\n\n/*\n** basic stack manipulation\n*/\n\n\n/*\n** convert an acceptable stack index into an absolute index\n*/\nLUA_API int lua_absindex (lua_State *L, int idx) {\n  return (idx > 0 || ispseudo(idx))\n         ? idx\n         : cast_int(L->top.p - L->ci->func.p) + idx;\n}\n\n\nLUA_API int lua_gettop (lua_State *L) {\n  return cast_int(L->top.p - (L->ci->func.p + 1));\n}\n\n\nLUA_API void lua_settop (lua_State *L, int idx) {\n  CallInfo *ci;\n  StkId func, newtop;\n  ptrdiff_t diff;  /* difference for new top */\n  lua_lock(L);\n  ci = L->ci;\n  func = ci->func.p;\n  if (idx >= 0) {\n    api_check(L, idx <= ci->top.p - (func + 1), \"new top too large\");\n    diff = ((func + 1) + idx) - L->top.p;\n    for (; diff > 0; diff--)\n      setnilvalue(s2v(L->top.p++));  /* clear new slots */\n  }\n  else {\n    api_check(L, -(idx+1) <= (L->top.p - (func + 1)), \"invalid new top\");\n    diff = idx + 1;  /* will \"subtract\" index (as it is negative) */\n  }\n  newtop = L->top.p + diff;\n  if (diff < 0 && L->tbclist.p >= newtop) {\n    lua_assert(ci->callstatus & CIST_CLSRET);\n    newtop = luaF_close(L, newtop, CLOSEKTOP, 0);\n  }\n  L->top.p = newtop;  /* correct top only after closing any upvalue */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_closeslot (lua_State *L, int idx) {\n  StkId level;\n  lua_lock(L);\n  level = index2stack(L, idx);\n  api_check(L, (L->ci->callstatus & CIST_CLSRET) && L->tbclist.p == level,\n     \"no variable to close at given level\");\n  level = luaF_close(L, level, CLOSEKTOP, 0);\n  setnilvalue(s2v(level));\n  lua_unlock(L);\n}\n\n\n/*\n** Reverse the stack segment from 'from' to 'to'\n** (auxiliary to 'lua_rotate')\n** Note that we move(copy) only the value inside the stack.\n** (We do not move additional fields that may exist.)\n*/\nstatic void reverse (lua_State *L, StkId from, StkId to) {\n  for (; from < to; from++, to--) {\n    TValue temp;\n    setobj(L, &temp, s2v(from));\n    setobjs2s(L, from, to);\n    setobj2s(L, to, &temp);\n  }\n}\n\n\n/*\n** Let x = AB, where A is a prefix of length 'n'. Then,\n** rotate x n == BA. But BA == (A^r . B^r)^r.\n*/\nLUA_API void lua_rotate (lua_State *L, int idx, int n) {\n  StkId p, t, m;\n  lua_lock(L);\n  t = L->top.p - 1;  /* end of stack segment being rotated */\n  p = index2stack(L, idx);  /* start of segment */\n  api_check(L, L->tbclist.p < p, \"moving a to-be-closed slot\");\n  api_check(L, (n >= 0 ? n : -n) <= (t - p + 1), \"invalid 'n'\");\n  m = (n >= 0 ? t - n : p - n - 1);  /* end of prefix */\n  reverse(L, p, m);  /* reverse the prefix with length 'n' */\n  reverse(L, m + 1, t);  /* reverse the suffix */\n  reverse(L, p, t);  /* reverse the entire segment */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_copy (lua_State *L, int fromidx, int toidx) {\n  TValue *fr, *to;\n  lua_lock(L);\n  fr = index2value(L, fromidx);\n  to = index2value(L, toidx);\n  api_check(L, isvalid(L, to), \"invalid index\");\n  setobj(L, to, fr);\n  if (isupvalue(toidx))  /* function upvalue? */\n    luaC_barrier(L, clCvalue(s2v(L->ci->func.p)), fr);\n  /* LUA_REGISTRYINDEX does not need gc barrier\n     (collector revisits it before finishing collection) */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushvalue (lua_State *L, int idx) {\n  lua_lock(L);\n  setobj2s(L, L->top.p, index2value(L, idx));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\n\n/*\n** access functions (stack -> C)\n*/\n\n\nLUA_API int lua_type (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return (isvalid(L, o) ? ttype(o) : LUA_TNONE);\n}\n\n\nLUA_API const char *lua_typename (lua_State *L, int t) {\n  UNUSED(L);\n  api_check(L, LUA_TNONE <= t && t < LUA_NUMTYPES, \"invalid type\");\n  return ttypename(t);\n}\n\n\nLUA_API int lua_iscfunction (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return (ttislcf(o) || (ttisCclosure(o)));\n}\n\n\nLUA_API int lua_isinteger (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return ttisinteger(o);\n}\n\n\nLUA_API int lua_isnumber (lua_State *L, int idx) {\n  lua_Number n;\n  const TValue *o = index2value(L, idx);\n  return tonumber(o, &n);\n}\n\n\nLUA_API int lua_isstring (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return (ttisstring(o) || cvt2str(o));\n}\n\n\nLUA_API int lua_isuserdata (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return (ttisfulluserdata(o) || ttislightuserdata(o));\n}\n\n\nLUA_API int lua_rawequal (lua_State *L, int index1, int index2) {\n  const TValue *o1 = index2value(L, index1);\n  const TValue *o2 = index2value(L, index2);\n  return (isvalid(L, o1) && isvalid(L, o2)) ? luaV_rawequalobj(o1, o2) : 0;\n}\n\n\nLUA_API void lua_arith (lua_State *L, int op) {\n  lua_lock(L);\n  if (op != LUA_OPUNM && op != LUA_OPBNOT)\n    api_checkpop(L, 2);  /* all other operations expect two operands */\n  else {  /* for unary operations, add fake 2nd operand */\n    api_checkpop(L, 1);\n    setobjs2s(L, L->top.p, L->top.p - 1);\n    api_incr_top(L);\n  }\n  /* first operand at top - 2, second at top - 1; result go to top - 2 */\n  luaO_arith(L, op, s2v(L->top.p - 2), s2v(L->top.p - 1), L->top.p - 2);\n  L->top.p--;  /* pop second operand */\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_compare (lua_State *L, int index1, int index2, int op) {\n  const TValue *o1;\n  const TValue *o2;\n  int i = 0;\n  lua_lock(L);  /* may call tag method */\n  o1 = index2value(L, index1);\n  o2 = index2value(L, index2);\n  if (isvalid(L, o1) && isvalid(L, o2)) {\n    switch (op) {\n      case LUA_OPEQ: i = luaV_equalobj(L, o1, o2); break;\n      case LUA_OPLT: i = luaV_lessthan(L, o1, o2); break;\n      case LUA_OPLE: i = luaV_lessequal(L, o1, o2); break;\n      default: api_check(L, 0, \"invalid option\");\n    }\n  }\n  lua_unlock(L);\n  return i;\n}\n\n\nLUA_API unsigned (lua_numbertostrbuff) (lua_State *L, int idx, char *buff) {\n  const TValue *o = index2value(L, idx);\n  if (ttisnumber(o)) {\n    unsigned len = luaO_tostringbuff(o, buff);\n    buff[len++] = '\\0';  /* add final zero */\n    return len;\n  }\n  else\n    return 0;\n}\n\n\nLUA_API size_t lua_stringtonumber (lua_State *L, const char *s) {\n  size_t sz = luaO_str2num(s, s2v(L->top.p));\n  if (sz != 0)\n    api_incr_top(L);\n  return sz;\n}\n\n\nLUA_API lua_Number lua_tonumberx (lua_State *L, int idx, int *pisnum) {\n  lua_Number n = 0;\n  const TValue *o = index2value(L, idx);\n  int isnum = tonumber(o, &n);\n  if (pisnum)\n    *pisnum = isnum;\n  return n;\n}\n\n\nLUA_API lua_Integer lua_tointegerx (lua_State *L, int idx, int *pisnum) {\n  lua_Integer res = 0;\n  const TValue *o = index2value(L, idx);\n  int isnum = tointeger(o, &res);\n  if (pisnum)\n    *pisnum = isnum;\n  return res;\n}\n\n\nLUA_API int lua_toboolean (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return !l_isfalse(o);\n}\n\n\nLUA_API const char *lua_tolstring (lua_State *L, int idx, size_t *len) {\n  TValue *o;\n  lua_lock(L);\n  o = index2value(L, idx);\n  if (!ttisstring(o)) {\n    if (!cvt2str(o)) {  /* not convertible? */\n      if (len != NULL) *len = 0;\n      lua_unlock(L);\n      return NULL;\n    }\n    luaO_tostring(L, o);\n    luaC_checkGC(L);\n    o = index2value(L, idx);  /* previous call may reallocate the stack */\n  }\n  lua_unlock(L);\n  if (len != NULL)\n    return getlstr(tsvalue(o), *len);\n  else\n    return getstr(tsvalue(o));\n}\n\n\nLUA_API lua_Unsigned lua_rawlen (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  switch (ttypetag(o)) {\n    case LUA_VSHRSTR: return cast(lua_Unsigned, tsvalue(o)->shrlen);\n    case LUA_VLNGSTR: return cast(lua_Unsigned, tsvalue(o)->u.lnglen);\n    case LUA_VUSERDATA: return cast(lua_Unsigned, uvalue(o)->len);\n    case LUA_VTABLE: return luaH_getn(hvalue(o));\n    default: return 0;\n  }\n}\n\n\nLUA_API lua_CFunction lua_tocfunction (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  if (ttislcf(o)) return fvalue(o);\n  else if (ttisCclosure(o))\n    return clCvalue(o)->f;\n  else return NULL;  /* not a C function */\n}\n\n\nl_sinline void *touserdata (const TValue *o) {\n  switch (ttype(o)) {\n    case LUA_TUSERDATA: return getudatamem(uvalue(o));\n    case LUA_TLIGHTUSERDATA: return pvalue(o);\n    default: return NULL;\n  }\n}\n\n\nLUA_API void *lua_touserdata (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return touserdata(o);\n}\n\n\nLUA_API lua_State *lua_tothread (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  return (!ttisthread(o)) ? NULL : thvalue(o);\n}\n\n\n/*\n** Returns a pointer to the internal representation of an object.\n** Note that ANSI C does not allow the conversion of a pointer to\n** function to a 'void*', so the conversion here goes through\n** a 'size_t'. (As the returned pointer is only informative, this\n** conversion should not be a problem.)\n*/\nLUA_API const void *lua_topointer (lua_State *L, int idx) {\n  const TValue *o = index2value(L, idx);\n  switch (ttypetag(o)) {\n    case LUA_VLCF: return cast_voidp(cast_sizet(fvalue(o)));\n    case LUA_VUSERDATA: case LUA_VLIGHTUSERDATA:\n      return touserdata(o);\n    default: {\n      if (iscollectable(o))\n        return gcvalue(o);\n      else\n        return NULL;\n    }\n  }\n}\n\n\n\n/*\n** push functions (C -> stack)\n*/\n\n\nLUA_API void lua_pushnil (lua_State *L) {\n  lua_lock(L);\n  setnilvalue(s2v(L->top.p));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushnumber (lua_State *L, lua_Number n) {\n  lua_lock(L);\n  setfltvalue(s2v(L->top.p), n);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushinteger (lua_State *L, lua_Integer n) {\n  lua_lock(L);\n  setivalue(s2v(L->top.p), n);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\n/*\n** Pushes on the stack a string with given length. Avoid using 's' when\n** 'len' == 0 (as 's' can be NULL in that case), due to later use of\n** 'memcmp' and 'memcpy'.\n*/\nLUA_API const char *lua_pushlstring (lua_State *L, const char *s, size_t len) {\n  TString *ts;\n  lua_lock(L);\n  ts = (len == 0) ? luaS_new(L, \"\") : luaS_newlstr(L, s, len);\n  setsvalue2s(L, L->top.p, ts);\n  api_incr_top(L);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return getstr(ts);\n}\n\n\nLUA_API const char *lua_pushextlstring (lua_State *L,\n\t        const char *s, size_t len, lua_Alloc falloc, void *ud) {\n  TString *ts;\n  lua_lock(L);\n  api_check(L, len <= MAX_SIZE, \"string too large\");\n  api_check(L, s[len] == '\\0', \"string not ending with zero\");\n  ts = luaS_newextlstr (L, s, len, falloc, ud);\n  setsvalue2s(L, L->top.p, ts);\n  api_incr_top(L);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return getstr(ts);\n}\n\n\nLUA_API const char *lua_pushstring (lua_State *L, const char *s) {\n  lua_lock(L);\n  if (s == NULL)\n    setnilvalue(s2v(L->top.p));\n  else {\n    TString *ts;\n    ts = luaS_new(L, s);\n    setsvalue2s(L, L->top.p, ts);\n    s = getstr(ts);  /* internal copy's address */\n  }\n  api_incr_top(L);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return s;\n}\n\n\nLUA_API const char *lua_pushvfstring (lua_State *L, const char *fmt,\n                                      va_list argp) {\n  const char *ret;\n  lua_lock(L);\n  ret = luaO_pushvfstring(L, fmt, argp);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return ret;\n}\n\n\nLUA_API const char *lua_pushfstring (lua_State *L, const char *fmt, ...) {\n  const char *ret;\n  va_list argp;\n  lua_lock(L);\n  va_start(argp, fmt);\n  ret = luaO_pushvfstring(L, fmt, argp);\n  va_end(argp);\n  luaC_checkGC(L);\n  if (ret == NULL)  /* error? */\n    luaD_throw(L, LUA_ERRMEM);\n  lua_unlock(L);\n  return ret;\n}\n\n\nLUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) {\n  lua_lock(L);\n  if (n == 0) {\n    setfvalue(s2v(L->top.p), fn);\n    api_incr_top(L);\n  }\n  else {\n    int i;\n    CClosure *cl;\n    api_checkpop(L, n);\n    api_check(L, n <= MAXUPVAL, \"upvalue index too large\");\n    cl = luaF_newCclosure(L, n);\n    cl->f = fn;\n    for (i = 0; i < n; i++) {\n      setobj2n(L, &cl->upvalue[i], s2v(L->top.p - n + i));\n      /* does not need barrier because closure is white */\n      lua_assert(iswhite(cl));\n    }\n    L->top.p -= n;\n    setclCvalue(L, s2v(L->top.p), cl);\n    api_incr_top(L);\n    luaC_checkGC(L);\n  }\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushboolean (lua_State *L, int b) {\n  lua_lock(L);\n  if (b)\n    setbtvalue(s2v(L->top.p));\n  else\n    setbfvalue(s2v(L->top.p));\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_pushlightuserdata (lua_State *L, void *p) {\n  lua_lock(L);\n  setpvalue(s2v(L->top.p), p);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_pushthread (lua_State *L) {\n  lua_lock(L);\n  setthvalue(L, s2v(L->top.p), L);\n  api_incr_top(L);\n  lua_unlock(L);\n  return (G(L)->mainthread == L);\n}\n\n\n\n/*\n** get functions (Lua -> stack)\n*/\n\n\nstatic int auxgetstr (lua_State *L, const TValue *t, const char *k) {\n  lu_byte tag;\n  TString *str = luaS_new(L, k);\n  luaV_fastget(t, str, s2v(L->top.p), luaH_getstr, tag);\n  if (!tagisempty(tag)) {\n    api_incr_top(L);\n  }\n  else {\n    setsvalue2s(L, L->top.p, str);\n    api_incr_top(L);\n    tag = luaV_finishget(L, t, s2v(L->top.p - 1), L->top.p - 1, tag);\n  }\n  lua_unlock(L);\n  return novariant(tag);\n}\n\n\nstatic void getGlobalTable (lua_State *L, TValue *gt) {\n  Table *registry = hvalue(&G(L)->l_registry);\n  lu_byte tag = luaH_getint(registry, LUA_RIDX_GLOBALS, gt);\n  (void)tag;  /* avoid not-used warnings when checks are off */\n  api_check(L, novariant(tag) == LUA_TTABLE, \"global table must exist\");\n}\n\n\nLUA_API int lua_getglobal (lua_State *L, const char *name) {\n  TValue gt;\n  lua_lock(L);\n  getGlobalTable(L, &gt);\n  return auxgetstr(L, &gt, name);\n}\n\n\nLUA_API int lua_gettable (lua_State *L, int idx) {\n  lu_byte tag;\n  TValue *t;\n  lua_lock(L);\n  api_checkpop(L, 1);\n  t = index2value(L, idx);\n  luaV_fastget(t, s2v(L->top.p - 1), s2v(L->top.p - 1), luaH_get, tag);\n  if (tagisempty(tag))\n    tag = luaV_finishget(L, t, s2v(L->top.p - 1), L->top.p - 1, tag);\n  lua_unlock(L);\n  return novariant(tag);\n}\n\n\nLUA_API int lua_getfield (lua_State *L, int idx, const char *k) {\n  lua_lock(L);\n  return auxgetstr(L, index2value(L, idx), k);\n}\n\n\nLUA_API int lua_geti (lua_State *L, int idx, lua_Integer n) {\n  TValue *t;\n  lu_byte tag;\n  lua_lock(L);\n  t = index2value(L, idx);\n  luaV_fastgeti(t, n, s2v(L->top.p), tag);\n  if (tagisempty(tag)) {\n    TValue key;\n    setivalue(&key, n);\n    tag = luaV_finishget(L, t, &key, L->top.p, tag);\n  }\n  api_incr_top(L);\n  lua_unlock(L);\n  return novariant(tag);\n}\n\n\nstatic int finishrawget (lua_State *L, lu_byte tag) {\n  if (tagisempty(tag))  /* avoid copying empty items to the stack */\n    setnilvalue(s2v(L->top.p));\n  api_incr_top(L);\n  lua_unlock(L);\n  return novariant(tag);\n}\n\n\nl_sinline Table *gettable (lua_State *L, int idx) {\n  TValue *t = index2value(L, idx);\n  api_check(L, ttistable(t), \"table expected\");\n  return hvalue(t);\n}\n\n\nLUA_API int lua_rawget (lua_State *L, int idx) {\n  Table *t;\n  lu_byte tag;\n  lua_lock(L);\n  api_checkpop(L, 1);\n  t = gettable(L, idx);\n  tag = luaH_get(t, s2v(L->top.p - 1), s2v(L->top.p - 1));\n  L->top.p--;  /* pop key */\n  return finishrawget(L, tag);\n}\n\n\nLUA_API int lua_rawgeti (lua_State *L, int idx, lua_Integer n) {\n  Table *t;\n  lu_byte tag;\n  lua_lock(L);\n  t = gettable(L, idx);\n  luaH_fastgeti(t, n, s2v(L->top.p), tag);\n  return finishrawget(L, tag);\n}\n\n\nLUA_API int lua_rawgetp (lua_State *L, int idx, const void *p) {\n  Table *t;\n  TValue k;\n  lua_lock(L);\n  t = gettable(L, idx);\n  setpvalue(&k, cast_voidp(p));\n  return finishrawget(L, luaH_get(t, &k, s2v(L->top.p)));\n}\n\n\nLUA_API void lua_createtable (lua_State *L, unsigned narray, unsigned nrec) {\n  Table *t;\n  lua_lock(L);\n  t = luaH_new(L);\n  sethvalue2s(L, L->top.p, t);\n  api_incr_top(L);\n  if (narray > 0 || nrec > 0)\n    luaH_resize(L, t, narray, nrec);\n  luaC_checkGC(L);\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_getmetatable (lua_State *L, int objindex) {\n  const TValue *obj;\n  Table *mt;\n  int res = 0;\n  lua_lock(L);\n  obj = index2value(L, objindex);\n  switch (ttype(obj)) {\n    case LUA_TTABLE:\n      mt = hvalue(obj)->metatable;\n      break;\n    case LUA_TUSERDATA:\n      mt = uvalue(obj)->metatable;\n      break;\n    default:\n      mt = G(L)->mt[ttype(obj)];\n      break;\n  }\n  if (mt != NULL) {\n    sethvalue2s(L, L->top.p, mt);\n    api_incr_top(L);\n    res = 1;\n  }\n  lua_unlock(L);\n  return res;\n}\n\n\nLUA_API int lua_getiuservalue (lua_State *L, int idx, int n) {\n  TValue *o;\n  int t;\n  lua_lock(L);\n  o = index2value(L, idx);\n  api_check(L, ttisfulluserdata(o), \"full userdata expected\");\n  if (n <= 0 || n > uvalue(o)->nuvalue) {\n    setnilvalue(s2v(L->top.p));\n    t = LUA_TNONE;\n  }\n  else {\n    setobj2s(L, L->top.p, &uvalue(o)->uv[n - 1].uv);\n    t = ttype(s2v(L->top.p));\n  }\n  api_incr_top(L);\n  lua_unlock(L);\n  return t;\n}\n\n\n/*\n** set functions (stack -> Lua)\n*/\n\n/*\n** t[k] = value at the top of the stack (where 'k' is a string)\n*/\nstatic void auxsetstr (lua_State *L, const TValue *t, const char *k) {\n  int hres;\n  TString *str = luaS_new(L, k);\n  api_checkpop(L, 1);\n  luaV_fastset(t, str, s2v(L->top.p - 1), hres, luaH_psetstr);\n  if (hres == HOK) {\n    luaV_finishfastset(L, t, s2v(L->top.p - 1));\n    L->top.p--;  /* pop value */\n  }\n  else {\n    setsvalue2s(L, L->top.p, str);  /* push 'str' (to make it a TValue) */\n    api_incr_top(L);\n    luaV_finishset(L, t, s2v(L->top.p - 1), s2v(L->top.p - 2), hres);\n    L->top.p -= 2;  /* pop value and key */\n  }\n  lua_unlock(L);  /* lock done by caller */\n}\n\n\nLUA_API void lua_setglobal (lua_State *L, const char *name) {\n  TValue gt;\n  lua_lock(L);  /* unlock done in 'auxsetstr' */\n  getGlobalTable(L, &gt);\n  auxsetstr(L, &gt, name);\n}\n\n\nLUA_API void lua_settable (lua_State *L, int idx) {\n  TValue *t;\n  int hres;\n  lua_lock(L);\n  api_checkpop(L, 2);\n  t = index2value(L, idx);\n  luaV_fastset(t, s2v(L->top.p - 2), s2v(L->top.p - 1), hres, luaH_pset);\n  if (hres == HOK) {\n    luaV_finishfastset(L, t, s2v(L->top.p - 1));\n  }\n  else\n    luaV_finishset(L, t, s2v(L->top.p - 2), s2v(L->top.p - 1), hres);\n  L->top.p -= 2;  /* pop index and value */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_setfield (lua_State *L, int idx, const char *k) {\n  lua_lock(L);  /* unlock done in 'auxsetstr' */\n  auxsetstr(L, index2value(L, idx), k);\n}\n\n\nLUA_API void lua_seti (lua_State *L, int idx, lua_Integer n) {\n  TValue *t;\n  int hres;\n  lua_lock(L);\n  api_checkpop(L, 1);\n  t = index2value(L, idx);\n  luaV_fastseti(t, n, s2v(L->top.p - 1), hres);\n  if (hres == HOK)\n    luaV_finishfastset(L, t, s2v(L->top.p - 1));\n  else {\n    TValue temp;\n    setivalue(&temp, n);\n    luaV_finishset(L, t, &temp, s2v(L->top.p - 1), hres);\n  }\n  L->top.p--;  /* pop value */\n  lua_unlock(L);\n}\n\n\nstatic void aux_rawset (lua_State *L, int idx, TValue *key, int n) {\n  Table *t;\n  lua_lock(L);\n  api_checkpop(L, n);\n  t = gettable(L, idx);\n  luaH_set(L, t, key, s2v(L->top.p - 1));\n  invalidateTMcache(t);\n  luaC_barrierback(L, obj2gco(t), s2v(L->top.p - 1));\n  L->top.p -= n;\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_rawset (lua_State *L, int idx) {\n  aux_rawset(L, idx, s2v(L->top.p - 2), 2);\n}\n\n\nLUA_API void lua_rawsetp (lua_State *L, int idx, const void *p) {\n  TValue k;\n  setpvalue(&k, cast_voidp(p));\n  aux_rawset(L, idx, &k, 1);\n}\n\n\nLUA_API void lua_rawseti (lua_State *L, int idx, lua_Integer n) {\n  Table *t;\n  lua_lock(L);\n  api_checkpop(L, 1);\n  t = gettable(L, idx);\n  luaH_setint(L, t, n, s2v(L->top.p - 1));\n  luaC_barrierback(L, obj2gco(t), s2v(L->top.p - 1));\n  L->top.p--;\n  lua_unlock(L);\n}\n\n\nLUA_API int lua_setmetatable (lua_State *L, int objindex) {\n  TValue *obj;\n  Table *mt;\n  lua_lock(L);\n  api_checkpop(L, 1);\n  obj = index2value(L, objindex);\n  if (ttisnil(s2v(L->top.p - 1)))\n    mt = NULL;\n  else {\n    api_check(L, ttistable(s2v(L->top.p - 1)), \"table expected\");\n    mt = hvalue(s2v(L->top.p - 1));\n  }\n  switch (ttype(obj)) {\n    case LUA_TTABLE: {\n      hvalue(obj)->metatable = mt;\n      if (mt) {\n        luaC_objbarrier(L, gcvalue(obj), mt);\n        luaC_checkfinalizer(L, gcvalue(obj), mt);\n      }\n      break;\n    }\n    case LUA_TUSERDATA: {\n      uvalue(obj)->metatable = mt;\n      if (mt) {\n        luaC_objbarrier(L, uvalue(obj), mt);\n        luaC_checkfinalizer(L, gcvalue(obj), mt);\n      }\n      break;\n    }\n    default: {\n      G(L)->mt[ttype(obj)] = mt;\n      break;\n    }\n  }\n  L->top.p--;\n  lua_unlock(L);\n  return 1;\n}\n\n\nLUA_API int lua_setiuservalue (lua_State *L, int idx, int n) {\n  TValue *o;\n  int res;\n  lua_lock(L);\n  api_checkpop(L, 1);\n  o = index2value(L, idx);\n  api_check(L, ttisfulluserdata(o), \"full userdata expected\");\n  if (!(cast_uint(n) - 1u < cast_uint(uvalue(o)->nuvalue)))\n    res = 0;  /* 'n' not in [1, uvalue(o)->nuvalue] */\n  else {\n    setobj(L, &uvalue(o)->uv[n - 1].uv, s2v(L->top.p - 1));\n    luaC_barrierback(L, gcvalue(o), s2v(L->top.p - 1));\n    res = 1;\n  }\n  L->top.p--;\n  lua_unlock(L);\n  return res;\n}\n\n\n/*\n** 'load' and 'call' functions (run Lua code)\n*/\n\n\n#define checkresults(L,na,nr) \\\n     (api_check(L, (nr) == LUA_MULTRET \\\n               || (L->ci->top.p - L->top.p >= (nr) - (na)), \\\n\t\"results from function overflow current stack size\"), \\\n      api_check(L, LUA_MULTRET <= (nr) && (nr) <= MAXRESULTS,  \\\n                   \"invalid number of results\"))\n\n\nLUA_API void lua_callk (lua_State *L, int nargs, int nresults,\n                        lua_KContext ctx, lua_KFunction k) {\n  StkId func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    \"cannot use continuations inside hooks\");\n  api_checkpop(L, nargs + 1);\n  api_check(L, L->status == LUA_OK, \"cannot do calls on non-normal thread\");\n  checkresults(L, nargs, nresults);\n  func = L->top.p - (nargs+1);\n  if (k != NULL && yieldable(L)) {  /* need to prepare continuation? */\n    L->ci->u.c.k = k;  /* save continuation */\n    L->ci->u.c.ctx = ctx;  /* save context */\n    luaD_call(L, func, nresults);  /* do the call */\n  }\n  else  /* no continuation or no yieldable */\n    luaD_callnoyield(L, func, nresults);  /* just do the call */\n  adjustresults(L, nresults);\n  lua_unlock(L);\n}\n\n\n\n/*\n** Execute a protected call.\n*/\nstruct CallS {  /* data to 'f_call' */\n  StkId func;\n  int nresults;\n};\n\n\nstatic void f_call (lua_State *L, void *ud) {\n  struct CallS *c = cast(struct CallS *, ud);\n  luaD_callnoyield(L, c->func, c->nresults);\n}\n\n\n\nLUA_API int lua_pcallk (lua_State *L, int nargs, int nresults, int errfunc,\n                        lua_KContext ctx, lua_KFunction k) {\n  struct CallS c;\n  int status;\n  ptrdiff_t func;\n  lua_lock(L);\n  api_check(L, k == NULL || !isLua(L->ci),\n    \"cannot use continuations inside hooks\");\n  api_checkpop(L, nargs + 1);\n  api_check(L, L->status == LUA_OK, \"cannot do calls on non-normal thread\");\n  checkresults(L, nargs, nresults);\n  if (errfunc == 0)\n    func = 0;\n  else {\n    StkId o = index2stack(L, errfunc);\n    api_check(L, ttisfunction(s2v(o)), \"error handler must be a function\");\n    func = savestack(L, o);\n  }\n  c.func = L->top.p - (nargs+1);  /* function to be called */\n  if (k == NULL || !yieldable(L)) {  /* no continuation or no yieldable? */\n    c.nresults = nresults;  /* do a 'conventional' protected call */\n    status = luaD_pcall(L, f_call, &c, savestack(L, c.func), func);\n  }\n  else {  /* prepare continuation (call is already protected by 'resume') */\n    CallInfo *ci = L->ci;\n    ci->u.c.k = k;  /* save continuation */\n    ci->u.c.ctx = ctx;  /* save context */\n    /* save information for error recovery */\n    ci->u2.funcidx = cast_int(savestack(L, c.func));\n    ci->u.c.old_errfunc = L->errfunc;\n    L->errfunc = func;\n    setoah(ci, L->allowhook);  /* save value of 'allowhook' */\n    ci->callstatus |= CIST_YPCALL;  /* function can do error recovery */\n    luaD_call(L, c.func, nresults);  /* do the call */\n    ci->callstatus &= ~CIST_YPCALL;\n    L->errfunc = ci->u.c.old_errfunc;\n    status = LUA_OK;  /* if it is here, there were no errors */\n  }\n  adjustresults(L, nresults);\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,\n                      const char *chunkname, const char *mode) {\n  ZIO z;\n  int status;\n  lua_lock(L);\n  if (!chunkname) chunkname = \"?\";\n  luaZ_init(L, &z, reader, data);\n  status = luaD_protectedparser(L, &z, chunkname, mode);\n  if (status == LUA_OK) {  /* no errors? */\n    LClosure *f = clLvalue(s2v(L->top.p - 1));  /* get new function */\n    if (f->nupvalues >= 1) {  /* does it have an upvalue? */\n      /* get global table from registry */\n      TValue gt;\n      getGlobalTable(L, &gt);\n      /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */\n      setobj(L, f->upvals[0]->v.p, &gt);\n      luaC_barrier(L, f->upvals[0], &gt);\n    }\n  }\n  lua_unlock(L);\n  return status;\n}\n\n\n/*\n** Dump a Lua function, calling 'writer' to write its parts. Ensure\n** the stack returns with its original size.\n*/\nLUA_API int lua_dump (lua_State *L, lua_Writer writer, void *data, int strip) {\n  int status;\n  ptrdiff_t otop = savestack(L, L->top.p);  /* original top */\n  TValue *f = s2v(L->top.p - 1);  /* function to be dumped */\n  lua_lock(L);\n  api_checkpop(L, 1);\n  api_check(L, isLfunction(f), \"Lua function expected\");\n  status = luaU_dump(L, clLvalue(f)->p, writer, data, strip);\n  L->top.p = restorestack(L, otop);  /* restore top */\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_status (lua_State *L) {\n  return L->status;\n}\n\n\n/*\n** Garbage-collection function\n*/\nLUA_API int lua_gc (lua_State *L, int what, ...) {\n  va_list argp;\n  int res = 0;\n  global_State *g = G(L);\n  if (g->gcstp & (GCSTPGC | GCSTPCLS))  /* internal stop? */\n    return -1;  /* all options are invalid when stopped */\n  lua_lock(L);\n  va_start(argp, what);\n  switch (what) {\n    case LUA_GCSTOP: {\n      g->gcstp = GCSTPUSR;  /* stopped by the user */\n      break;\n    }\n    case LUA_GCRESTART: {\n      luaE_setdebt(g, 0);\n      g->gcstp = 0;  /* (other bits must be zero here) */\n      break;\n    }\n    case LUA_GCCOLLECT: {\n      luaC_fullgc(L, 0);\n      break;\n    }\n    case LUA_GCCOUNT: {\n      /* GC values are expressed in Kbytes: #bytes/2^10 */\n      res = cast_int(gettotalbytes(g) >> 10);\n      break;\n    }\n    case LUA_GCCOUNTB: {\n      res = cast_int(gettotalbytes(g) & 0x3ff);\n      break;\n    }\n    case LUA_GCSTEP: {\n      lu_byte oldstp = g->gcstp;\n      l_mem n = cast(l_mem, va_arg(argp, size_t));\n      int work = 0;  /* true if GC did some work */\n      g->gcstp = 0;  /* allow GC to run (other bits must be zero here) */\n      if (n <= 0)\n        n = g->GCdebt;  /* force to run one basic step */\n      luaE_setdebt(g, g->GCdebt - n);\n      luaC_condGC(L, (void)0, work = 1);\n      if (work && g->gcstate == GCSpause)  /* end of cycle? */\n        res = 1;  /* signal it */\n      g->gcstp = oldstp;  /* restore previous state */\n      break;\n    }\n    case LUA_GCISRUNNING: {\n      res = gcrunning(g);\n      break;\n    }\n    case LUA_GCGEN: {\n      res = (g->gckind == KGC_INC) ? LUA_GCINC : LUA_GCGEN;\n      luaC_changemode(L, KGC_GENMINOR);\n      break;\n    }\n    case LUA_GCINC: {\n      res = (g->gckind == KGC_INC) ? LUA_GCINC : LUA_GCGEN;\n      luaC_changemode(L, KGC_INC);\n      break;\n    }\n    case LUA_GCPARAM: {\n      int param = va_arg(argp, int);\n      int value = va_arg(argp, int);\n      api_check(L, 0 <= param && param < LUA_GCPN, \"invalid parameter\");\n      res = cast_int(luaO_applyparam(g->gcparams[param], 100));\n      if (value >= 0)\n        g->gcparams[param] = luaO_codeparam(cast_uint(value));\n      break;\n    }\n    default: res = -1;  /* invalid option */\n  }\n  va_end(argp);\n  lua_unlock(L);\n  return res;\n}\n\n\n\n/*\n** miscellaneous functions\n*/\n\n\nLUA_API int lua_error (lua_State *L) {\n  TValue *errobj;\n  lua_lock(L);\n  errobj = s2v(L->top.p - 1);\n  api_checkpop(L, 1);\n  /* error object is the memory error message? */\n  if (ttisshrstring(errobj) && eqshrstr(tsvalue(errobj), G(L)->memerrmsg))\n    luaM_error(L);  /* raise a memory error */\n  else\n    luaG_errormsg(L);  /* raise a regular error */\n  /* code unreachable; will unlock when control actually leaves the kernel */\n  return 0;  /* to avoid warnings */\n}\n\n\nLUA_API int lua_next (lua_State *L, int idx) {\n  Table *t;\n  int more;\n  lua_lock(L);\n  api_checkpop(L, 1);\n  t = gettable(L, idx);\n  more = luaH_next(L, t, L->top.p - 1);\n  if (more)\n    api_incr_top(L);\n  else  /* no more elements */\n    L->top.p--;  /* pop key */\n  lua_unlock(L);\n  return more;\n}\n\n\nLUA_API void lua_toclose (lua_State *L, int idx) {\n  StkId o;\n  lua_lock(L);\n  o = index2stack(L, idx);\n  api_check(L, L->tbclist.p < o, \"given index below or equal a marked one\");\n  luaF_newtbcupval(L, o);  /* create new to-be-closed upvalue */\n  L->ci->callstatus |= CIST_CLSRET;  /* mark that function has TBC slots */\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_concat (lua_State *L, int n) {\n  lua_lock(L);\n  api_checknelems(L, n);\n  if (n > 0) {\n    luaV_concat(L, n);\n    luaC_checkGC(L);\n  }\n  else {  /* nothing to concatenate */\n    setsvalue2s(L, L->top.p, luaS_newlstr(L, \"\", 0));  /* push empty string */\n    api_incr_top(L);\n  }\n  lua_unlock(L);\n}\n\n\nLUA_API void lua_len (lua_State *L, int idx) {\n  TValue *t;\n  lua_lock(L);\n  t = index2value(L, idx);\n  luaV_objlen(L, L->top.p, t);\n  api_incr_top(L);\n  lua_unlock(L);\n}\n\n\nLUA_API lua_Alloc lua_getallocf (lua_State *L, void **ud) {\n  lua_Alloc f;\n  lua_lock(L);\n  if (ud) *ud = G(L)->ud;\n  f = G(L)->frealloc;\n  lua_unlock(L);\n  return f;\n}\n\n\nLUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud) {\n  lua_lock(L);\n  G(L)->ud = ud;\n  G(L)->frealloc = f;\n  lua_unlock(L);\n}\n\n\nvoid lua_setwarnf (lua_State *L, lua_WarnFunction f, void *ud) {\n  lua_lock(L);\n  G(L)->ud_warn = ud;\n  G(L)->warnf = f;\n  lua_unlock(L);\n}\n\n\nvoid lua_warning (lua_State *L, const char *msg, int tocont) {\n  lua_lock(L);\n  luaE_warning(L, msg, tocont);\n  lua_unlock(L);\n}\n\n\n\nLUA_API void *lua_newuserdatauv (lua_State *L, size_t size, int nuvalue) {\n  Udata *u;\n  lua_lock(L);\n  api_check(L, 0 <= nuvalue && nuvalue < SHRT_MAX, \"invalid value\");\n  u = luaS_newudata(L, size, cast(unsigned short, nuvalue));\n  setuvalue(L, s2v(L->top.p), u);\n  api_incr_top(L);\n  luaC_checkGC(L);\n  lua_unlock(L);\n  return getudatamem(u);\n}\n\n\n\nstatic const char *aux_upvalue (TValue *fi, int n, TValue **val,\n                                GCObject **owner) {\n  switch (ttypetag(fi)) {\n    case LUA_VCCL: {  /* C closure */\n      CClosure *f = clCvalue(fi);\n      if (!(cast_uint(n) - 1u < cast_uint(f->nupvalues)))\n        return NULL;  /* 'n' not in [1, f->nupvalues] */\n      *val = &f->upvalue[n-1];\n      if (owner) *owner = obj2gco(f);\n      return \"\";\n    }\n    case LUA_VLCL: {  /* Lua closure */\n      LClosure *f = clLvalue(fi);\n      TString *name;\n      Proto *p = f->p;\n      if (!(cast_uint(n) - 1u  < cast_uint(p->sizeupvalues)))\n        return NULL;  /* 'n' not in [1, p->sizeupvalues] */\n      *val = f->upvals[n-1]->v.p;\n      if (owner) *owner = obj2gco(f->upvals[n - 1]);\n      name = p->upvalues[n-1].name;\n      return (name == NULL) ? \"(no name)\" : getstr(name);\n    }\n    default: return NULL;  /* not a closure */\n  }\n}\n\n\nLUA_API const char *lua_getupvalue (lua_State *L, int funcindex, int n) {\n  const char *name;\n  TValue *val = NULL;  /* to avoid warnings */\n  lua_lock(L);\n  name = aux_upvalue(index2value(L, funcindex), n, &val, NULL);\n  if (name) {\n    setobj2s(L, L->top.p, val);\n    api_incr_top(L);\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nLUA_API const char *lua_setupvalue (lua_State *L, int funcindex, int n) {\n  const char *name;\n  TValue *val = NULL;  /* to avoid warnings */\n  GCObject *owner = NULL;  /* to avoid warnings */\n  TValue *fi;\n  lua_lock(L);\n  fi = index2value(L, funcindex);\n  api_checknelems(L, 1);\n  name = aux_upvalue(fi, n, &val, &owner);\n  if (name) {\n    L->top.p--;\n    setobj(L, val, s2v(L->top.p));\n    luaC_barrier(L, owner, val);\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nstatic UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {\n  static const UpVal *const nullup = NULL;\n  LClosure *f;\n  TValue *fi = index2value(L, fidx);\n  api_check(L, ttisLclosure(fi), \"Lua function expected\");\n  f = clLvalue(fi);\n  if (pf) *pf = f;\n  if (1 <= n && n <= f->p->sizeupvalues)\n    return &f->upvals[n - 1];  /* get its upvalue pointer */\n  else\n    return (UpVal**)&nullup;\n}\n\n\nLUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {\n  TValue *fi = index2value(L, fidx);\n  switch (ttypetag(fi)) {\n    case LUA_VLCL: {  /* lua closure */\n      return *getupvalref(L, fidx, n, NULL);\n    }\n    case LUA_VCCL: {  /* C closure */\n      CClosure *f = clCvalue(fi);\n      if (1 <= n && n <= f->nupvalues)\n        return &f->upvalue[n - 1];\n      /* else */\n    }  /* FALLTHROUGH */\n    case LUA_VLCF:\n      return NULL;  /* light C functions have no upvalues */\n    default: {\n      api_check(L, 0, \"function expected\");\n      return NULL;\n    }\n  }\n}\n\n\nLUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n                                            int fidx2, int n2) {\n  LClosure *f1;\n  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n  api_check(L, *up1 != NULL && *up2 != NULL, \"invalid upvalue index\");\n  *up1 = *up2;\n  luaC_objbarrier(L, f1, *up1);\n}\n\n\n"
        },
        {
          "name": "lapi.h",
          "type": "blob",
          "size": 1.5966796875,
          "content": "/*\n** $Id: lapi.h $\n** Auxiliary functions from Lua API\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lapi_h\n#define lapi_h\n\n\n#include \"llimits.h\"\n#include \"lstate.h\"\n\n\n#if defined(LUA_USE_APICHECK)\n#include <assert.h>\n#define api_check(l,e,msg)\tassert(e)\n#else\t/* for testing */\n#define api_check(l,e,msg)\t((void)(l), lua_assert((e) && msg))\n#endif\n\n\n\n/* Increments 'L->top.p', checking for stack overflows */\n#define api_incr_top(L)  \\\n    (L->top.p++, api_check(L, L->top.p <= L->ci->top.p, \"stack overflow\"))\n\n\n/*\n** macros that are executed whenever program enters the Lua core\n** ('lua_lock') and leaves the core ('lua_unlock')\n*/\n#if !defined(lua_lock)\n#define lua_lock(L)\t((void) 0)\n#define lua_unlock(L)\t((void) 0)\n#endif\n\n\n\n/*\n** If a call returns too many multiple returns, the callee may not have\n** stack space to accommodate all results. In this case, this macro\n** increases its stack space ('L->ci->top.p').\n*/\n#define adjustresults(L,nres) \\\n    { if ((nres) <= LUA_MULTRET && L->ci->top.p < L->top.p) \\\n\tL->ci->top.p = L->top.p; }\n\n\n/* Ensure the stack has at least 'n' elements */\n#define api_checknelems(L,n) \\\n       api_check(L, (n) < (L->top.p - L->ci->func.p), \\\n                         \"not enough elements in the stack\")\n\n\n/* Ensure the stack has at least 'n' elements to be popped. (Some\n** functions only update a slot after checking it for popping, but that\n** is only an optimization for a pop followed by a push.)\n*/\n#define api_checkpop(L,n) \\\n\tapi_check(L, (n) < L->top.p - L->ci->func.p &&  \\\n                     L->tbclist.p < L->top.p - (n), \\\n\t\t\t  \"not enough free elements in the stack\")\n\n#endif\n"
        },
        {
          "name": "lauxlib.c",
          "type": "blob",
          "size": 35.1337890625,
          "content": "/*\n** $Id: lauxlib.c $\n** Auxiliary functions for building Lua libraries\n** See Copyright Notice in lua.h\n*/\n\n#define lauxlib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\n/*\n** This file uses only the official API of Lua.\n** Any function declared here could be written as an application function.\n*/\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"llimits.h\"\n\n\n/*\n** {======================================================\n** Traceback\n** =======================================================\n*/\n\n\n#define LEVELS1\t10\t/* size of the first part of the stack */\n#define LEVELS2\t11\t/* size of the second part of the stack */\n\n\n\n/*\n** Search for 'objidx' in table at index -1. ('objidx' must be an\n** absolute index.) Return 1 + string at top if it found a good name.\n*/\nstatic int findfield (lua_State *L, int objidx, int level) {\n  if (level == 0 || !lua_istable(L, -1))\n    return 0;  /* not found */\n  lua_pushnil(L);  /* start 'next' loop */\n  while (lua_next(L, -2)) {  /* for each pair in table */\n    if (lua_type(L, -2) == LUA_TSTRING) {  /* ignore non-string keys */\n      if (lua_rawequal(L, objidx, -1)) {  /* found object? */\n        lua_pop(L, 1);  /* remove value (but keep name) */\n        return 1;\n      }\n      else if (findfield(L, objidx, level - 1)) {  /* try recursively */\n        /* stack: lib_name, lib_table, field_name (top) */\n        lua_pushliteral(L, \".\");  /* place '.' between the two names */\n        lua_replace(L, -3);  /* (in the slot occupied by table) */\n        lua_concat(L, 3);  /* lib_name.field_name */\n        return 1;\n      }\n    }\n    lua_pop(L, 1);  /* remove value */\n  }\n  return 0;  /* not found */\n}\n\n\n/*\n** Search for a name for a function in all loaded modules\n*/\nstatic int pushglobalfuncname (lua_State *L, lua_Debug *ar) {\n  int top = lua_gettop(L);\n  lua_getinfo(L, \"f\", ar);  /* push function */\n  lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n  luaL_checkstack(L, 6, \"not enough stack\");  /* slots for 'findfield' */\n  if (findfield(L, top + 1, 2)) {\n    const char *name = lua_tostring(L, -1);\n    if (strncmp(name, LUA_GNAME \".\", 3) == 0) {  /* name start with '_G.'? */\n      lua_pushstring(L, name + 3);  /* push name without prefix */\n      lua_remove(L, -2);  /* remove original name */\n    }\n    lua_copy(L, -1, top + 1);  /* copy name to proper place */\n    lua_settop(L, top + 1);  /* remove table \"loaded\" and name copy */\n    return 1;\n  }\n  else {\n    lua_settop(L, top);  /* remove function and global table */\n    return 0;\n  }\n}\n\n\nstatic void pushfuncname (lua_State *L, lua_Debug *ar) {\n  if (pushglobalfuncname(L, ar)) {  /* try first a global name */\n    lua_pushfstring(L, \"function '%s'\", lua_tostring(L, -1));\n    lua_remove(L, -2);  /* remove name */\n  }\n  else if (*ar->namewhat != '\\0')  /* is there a name from code? */\n    lua_pushfstring(L, \"%s '%s'\", ar->namewhat, ar->name);  /* use it */\n  else if (*ar->what == 'm')  /* main? */\n      lua_pushliteral(L, \"main chunk\");\n  else if (*ar->what != 'C')  /* for Lua functions, use <file:line> */\n    lua_pushfstring(L, \"function <%s:%d>\", ar->short_src, ar->linedefined);\n  else  /* nothing left... */\n    lua_pushliteral(L, \"?\");\n}\n\n\nstatic int lastlevel (lua_State *L) {\n  lua_Debug ar;\n  int li = 1, le = 1;\n  /* find an upper bound */\n  while (lua_getstack(L, le, &ar)) { li = le; le *= 2; }\n  /* do a binary search */\n  while (li < le) {\n    int m = (li + le)/2;\n    if (lua_getstack(L, m, &ar)) li = m + 1;\n    else le = m;\n  }\n  return le - 1;\n}\n\n\nLUALIB_API void luaL_traceback (lua_State *L, lua_State *L1,\n                                const char *msg, int level) {\n  luaL_Buffer b;\n  lua_Debug ar;\n  int last = lastlevel(L1);\n  int limit2show = (last - level > LEVELS1 + LEVELS2) ? LEVELS1 : -1;\n  luaL_buffinit(L, &b);\n  if (msg) {\n    luaL_addstring(&b, msg);\n    luaL_addchar(&b, '\\n');\n  }\n  luaL_addstring(&b, \"stack traceback:\");\n  while (lua_getstack(L1, level++, &ar)) {\n    if (limit2show-- == 0) {  /* too many levels? */\n      int n = last - level - LEVELS2 + 1;  /* number of levels to skip */\n      lua_pushfstring(L, \"\\n\\t...\\t(skipping %d levels)\", n);\n      luaL_addvalue(&b);  /* add warning about skip */\n      level += n;  /* and skip to last levels */\n    }\n    else {\n      lua_getinfo(L1, \"Slnt\", &ar);\n      if (ar.currentline <= 0)\n        lua_pushfstring(L, \"\\n\\t%s: in \", ar.short_src);\n      else\n        lua_pushfstring(L, \"\\n\\t%s:%d: in \", ar.short_src, ar.currentline);\n      luaL_addvalue(&b);\n      pushfuncname(L, &ar);\n      luaL_addvalue(&b);\n      if (ar.istailcall)\n        luaL_addstring(&b, \"\\n\\t(...tail calls...)\");\n    }\n  }\n  luaL_pushresult(&b);\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Error-report functions\n** =======================================================\n*/\n\nLUALIB_API int luaL_argerror (lua_State *L, int arg, const char *extramsg) {\n  lua_Debug ar;\n  const char *argword;\n  if (!lua_getstack(L, 0, &ar))  /* no stack frame? */\n    return luaL_error(L, \"bad argument #%d (%s)\", arg, extramsg);\n  lua_getinfo(L, \"nt\", &ar);\n  if (arg <= ar.extraargs)  /* error in an extra argument? */\n    argword =  \"extra argument\";\n  else {\n    arg -= ar.extraargs;  /* do not count extra arguments */\n    if (strcmp(ar.namewhat, \"method\") == 0) {  /* colon syntax? */\n      arg--;  /* do not count (extra) self argument */\n      if (arg == 0)  /* error in self argument? */\n        return luaL_error(L, \"calling '%s' on bad self (%s)\",\n                               ar.name, extramsg);\n      /* else go through; error in a regular argument */\n    }\n    argword = \"argument\";\n  }\n  if (ar.name == NULL)\n    ar.name = (pushglobalfuncname(L, &ar)) ? lua_tostring(L, -1) : \"?\";\n  return luaL_error(L, \"bad %s #%d to '%s' (%s)\",\n                       argword, arg, ar.name, extramsg);\n}\n\n\nLUALIB_API int luaL_typeerror (lua_State *L, int arg, const char *tname) {\n  const char *msg;\n  const char *typearg;  /* name for the type of the actual argument */\n  if (luaL_getmetafield(L, arg, \"__name\") == LUA_TSTRING)\n    typearg = lua_tostring(L, -1);  /* use the given type name */\n  else if (lua_type(L, arg) == LUA_TLIGHTUSERDATA)\n    typearg = \"light userdata\";  /* special name for messages */\n  else\n    typearg = luaL_typename(L, arg);  /* standard name */\n  msg = lua_pushfstring(L, \"%s expected, got %s\", tname, typearg);\n  return luaL_argerror(L, arg, msg);\n}\n\n\nstatic void tag_error (lua_State *L, int arg, int tag) {\n  luaL_typeerror(L, arg, lua_typename(L, tag));\n}\n\n\n/*\n** The use of 'lua_pushfstring' ensures this function does not\n** need reserved stack space when called.\n*/\nLUALIB_API void luaL_where (lua_State *L, int level) {\n  lua_Debug ar;\n  if (lua_getstack(L, level, &ar)) {  /* check function at level */\n    lua_getinfo(L, \"Sl\", &ar);  /* get info about it */\n    if (ar.currentline > 0) {  /* is there info? */\n      lua_pushfstring(L, \"%s:%d: \", ar.short_src, ar.currentline);\n      return;\n    }\n  }\n  lua_pushfstring(L, \"\");  /* else, no information available... */\n}\n\n\n/*\n** Again, the use of 'lua_pushvfstring' ensures this function does\n** not need reserved stack space when called. (At worst, it generates\n** a memory error instead of the given message.)\n*/\nLUALIB_API int luaL_error (lua_State *L, const char *fmt, ...) {\n  va_list argp;\n  va_start(argp, fmt);\n  luaL_where(L, 1);\n  lua_pushvfstring(L, fmt, argp);\n  va_end(argp);\n  lua_concat(L, 2);\n  return lua_error(L);\n}\n\n\nLUALIB_API int luaL_fileresult (lua_State *L, int stat, const char *fname) {\n  int en = errno;  /* calls to Lua API may change this value */\n  if (stat) {\n    lua_pushboolean(L, 1);\n    return 1;\n  }\n  else {\n    const char *msg;\n    luaL_pushfail(L);\n    msg = (en != 0) ? strerror(en) : \"(no extra info)\";\n    if (fname)\n      lua_pushfstring(L, \"%s: %s\", fname, msg);\n    else\n      lua_pushstring(L, msg);\n    lua_pushinteger(L, en);\n    return 3;\n  }\n}\n\n\n#if !defined(l_inspectstat)\t/* { */\n\n#if defined(LUA_USE_POSIX)\n\n#include <sys/wait.h>\n\n/*\n** use appropriate macros to interpret 'pclose' return status\n*/\n#define l_inspectstat(stat,what)  \\\n   if (WIFEXITED(stat)) { stat = WEXITSTATUS(stat); } \\\n   else if (WIFSIGNALED(stat)) { stat = WTERMSIG(stat); what = \"signal\"; }\n\n#else\n\n#define l_inspectstat(stat,what)  /* no op */\n\n#endif\n\n#endif\t\t\t\t/* } */\n\n\nLUALIB_API int luaL_execresult (lua_State *L, int stat) {\n  if (stat != 0 && errno != 0)  /* error with an 'errno'? */\n    return luaL_fileresult(L, 0, NULL);\n  else {\n    const char *what = \"exit\";  /* type of termination */\n    l_inspectstat(stat, what);  /* interpret result */\n    if (*what == 'e' && stat == 0)  /* successful termination? */\n      lua_pushboolean(L, 1);\n    else\n      luaL_pushfail(L);\n    lua_pushstring(L, what);\n    lua_pushinteger(L, stat);\n    return 3;  /* return true/fail,what,code */\n  }\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** Userdata's metatable manipulation\n** =======================================================\n*/\n\nLUALIB_API int luaL_newmetatable (lua_State *L, const char *tname) {\n  if (luaL_getmetatable(L, tname) != LUA_TNIL)  /* name already in use? */\n    return 0;  /* leave previous value on top, but return 0 */\n  lua_pop(L, 1);\n  lua_createtable(L, 0, 2);  /* create metatable */\n  lua_pushstring(L, tname);\n  lua_setfield(L, -2, \"__name\");  /* metatable.__name = tname */\n  lua_pushvalue(L, -1);\n  lua_setfield(L, LUA_REGISTRYINDEX, tname);  /* registry.name = metatable */\n  return 1;\n}\n\n\nLUALIB_API void luaL_setmetatable (lua_State *L, const char *tname) {\n  luaL_getmetatable(L, tname);\n  lua_setmetatable(L, -2);\n}\n\n\nLUALIB_API void *luaL_testudata (lua_State *L, int ud, const char *tname) {\n  void *p = lua_touserdata(L, ud);\n  if (p != NULL) {  /* value is a userdata? */\n    if (lua_getmetatable(L, ud)) {  /* does it have a metatable? */\n      luaL_getmetatable(L, tname);  /* get correct metatable */\n      if (!lua_rawequal(L, -1, -2))  /* not the same? */\n        p = NULL;  /* value is a userdata with wrong metatable */\n      lua_pop(L, 2);  /* remove both metatables */\n      return p;\n    }\n  }\n  return NULL;  /* value is not a userdata with a metatable */\n}\n\n\nLUALIB_API void *luaL_checkudata (lua_State *L, int ud, const char *tname) {\n  void *p = luaL_testudata(L, ud, tname);\n  luaL_argexpected(L, p != NULL, ud, tname);\n  return p;\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Argument check functions\n** =======================================================\n*/\n\nLUALIB_API int luaL_checkoption (lua_State *L, int arg, const char *def,\n                                 const char *const lst[]) {\n  const char *name = (def) ? luaL_optstring(L, arg, def) :\n                             luaL_checkstring(L, arg);\n  int i;\n  for (i=0; lst[i]; i++)\n    if (strcmp(lst[i], name) == 0)\n      return i;\n  return luaL_argerror(L, arg,\n                       lua_pushfstring(L, \"invalid option '%s'\", name));\n}\n\n\n/*\n** Ensures the stack has at least 'space' extra slots, raising an error\n** if it cannot fulfill the request. (The error handling needs a few\n** extra slots to format the error message. In case of an error without\n** this extra space, Lua will generate the same 'stack overflow' error,\n** but without 'msg'.)\n*/\nLUALIB_API void luaL_checkstack (lua_State *L, int space, const char *msg) {\n  if (l_unlikely(!lua_checkstack(L, space))) {\n    if (msg)\n      luaL_error(L, \"stack overflow (%s)\", msg);\n    else\n      luaL_error(L, \"stack overflow\");\n  }\n}\n\n\nLUALIB_API void luaL_checktype (lua_State *L, int arg, int t) {\n  if (l_unlikely(lua_type(L, arg) != t))\n    tag_error(L, arg, t);\n}\n\n\nLUALIB_API void luaL_checkany (lua_State *L, int arg) {\n  if (l_unlikely(lua_type(L, arg) == LUA_TNONE))\n    luaL_argerror(L, arg, \"value expected\");\n}\n\n\nLUALIB_API const char *luaL_checklstring (lua_State *L, int arg, size_t *len) {\n  const char *s = lua_tolstring(L, arg, len);\n  if (l_unlikely(!s)) tag_error(L, arg, LUA_TSTRING);\n  return s;\n}\n\n\nLUALIB_API const char *luaL_optlstring (lua_State *L, int arg,\n                                        const char *def, size_t *len) {\n  if (lua_isnoneornil(L, arg)) {\n    if (len)\n      *len = (def ? strlen(def) : 0);\n    return def;\n  }\n  else return luaL_checklstring(L, arg, len);\n}\n\n\nLUALIB_API lua_Number luaL_checknumber (lua_State *L, int arg) {\n  int isnum;\n  lua_Number d = lua_tonumberx(L, arg, &isnum);\n  if (l_unlikely(!isnum))\n    tag_error(L, arg, LUA_TNUMBER);\n  return d;\n}\n\n\nLUALIB_API lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number def) {\n  return luaL_opt(L, luaL_checknumber, arg, def);\n}\n\n\nstatic void interror (lua_State *L, int arg) {\n  if (lua_isnumber(L, arg))\n    luaL_argerror(L, arg, \"number has no integer representation\");\n  else\n    tag_error(L, arg, LUA_TNUMBER);\n}\n\n\nLUALIB_API lua_Integer luaL_checkinteger (lua_State *L, int arg) {\n  int isnum;\n  lua_Integer d = lua_tointegerx(L, arg, &isnum);\n  if (l_unlikely(!isnum)) {\n    interror(L, arg);\n  }\n  return d;\n}\n\n\nLUALIB_API lua_Integer luaL_optinteger (lua_State *L, int arg,\n                                                      lua_Integer def) {\n  return luaL_opt(L, luaL_checkinteger, arg, def);\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Generic Buffer manipulation\n** =======================================================\n*/\n\n/* userdata to box arbitrary data */\ntypedef struct UBox {\n  void *box;\n  size_t bsize;\n} UBox;\n\n\n/* Resize the buffer used by a box. Optimize for the common case of\n** resizing to the old size. (For instance, __gc will resize the box\n** to 0 even after it was closed. 'pushresult' may also resize it to a\n** final size that is equal to the one set when the buffer was created.)\n*/\nstatic void *resizebox (lua_State *L, int idx, size_t newsize) {\n  UBox *box = (UBox *)lua_touserdata(L, idx);\n  if (box->bsize == newsize)  /* not changing size? */\n    return box->box;  /* keep the buffer */\n  else {\n    void *ud;\n    lua_Alloc allocf = lua_getallocf(L, &ud);\n    void *temp = allocf(ud, box->box, box->bsize, newsize);\n    if (l_unlikely(temp == NULL && newsize > 0)) {  /* allocation error? */\n      lua_pushliteral(L, \"not enough memory\");\n      lua_error(L);  /* raise a memory error */\n    }\n    box->box = temp;\n    box->bsize = newsize;\n    return temp;\n  }\n}\n\n\nstatic int boxgc (lua_State *L) {\n  resizebox(L, 1, 0);\n  return 0;\n}\n\n\nstatic const luaL_Reg boxmt[] = {  /* box metamethods */\n  {\"__gc\", boxgc},\n  {\"__close\", boxgc},\n  {NULL, NULL}\n};\n\n\nstatic void newbox (lua_State *L) {\n  UBox *box = (UBox *)lua_newuserdatauv(L, sizeof(UBox), 0);\n  box->box = NULL;\n  box->bsize = 0;\n  if (luaL_newmetatable(L, \"_UBOX*\"))  /* creating metatable? */\n    luaL_setfuncs(L, boxmt, 0);  /* set its metamethods */\n  lua_setmetatable(L, -2);\n}\n\n\n/*\n** check whether buffer is using a userdata on the stack as a temporary\n** buffer\n*/\n#define buffonstack(B)\t((B)->b != (B)->init.b)\n\n\n/*\n** Whenever buffer is accessed, slot 'idx' must either be a box (which\n** cannot be NULL) or it is a placeholder for the buffer.\n*/\n#define checkbufferlevel(B,idx)  \\\n  lua_assert(buffonstack(B) ? lua_touserdata(B->L, idx) != NULL  \\\n                            : lua_touserdata(B->L, idx) == (void*)B)\n\n\n/*\n** Compute new size for buffer 'B', enough to accommodate extra 'sz'\n** bytes plus one for a terminating zero. (The test for \"not big enough\"\n** also gets the case when the computation of 'newsize' overflows.)\n*/\nstatic size_t newbuffsize (luaL_Buffer *B, size_t sz) {\n  size_t newsize = (B->size / 2) * 3;  /* buffer size * 1.5 */\n  if (l_unlikely(sz > MAX_SIZE - B->n - 1))\n    return cast_sizet(luaL_error(B->L, \"resulting string too large\"));\n  if (newsize < B->n + sz + 1 || newsize > MAX_SIZE) {\n    /* newsize was not big enough or too big */\n    newsize = B->n + sz + 1;\n  }\n  return newsize;\n}\n\n\n/*\n** Returns a pointer to a free area with at least 'sz' bytes in buffer\n** 'B'. 'boxidx' is the relative position in the stack where is the\n** buffer's box or its placeholder.\n*/\nstatic char *prepbuffsize (luaL_Buffer *B, size_t sz, int boxidx) {\n  checkbufferlevel(B, boxidx);\n  if (B->size - B->n >= sz)  /* enough space? */\n    return B->b + B->n;\n  else {\n    lua_State *L = B->L;\n    char *newbuff;\n    size_t newsize = newbuffsize(B, sz);\n    /* create larger buffer */\n    if (buffonstack(B))  /* buffer already has a box? */\n      newbuff = (char *)resizebox(L, boxidx, newsize);  /* resize it */\n    else {  /* no box yet */\n      lua_remove(L, boxidx);  /* remove placeholder */\n      newbox(L);  /* create a new box */\n      lua_insert(L, boxidx);  /* move box to its intended position */\n      lua_toclose(L, boxidx);\n      newbuff = (char *)resizebox(L, boxidx, newsize);\n      memcpy(newbuff, B->b, B->n * sizeof(char));  /* copy original content */\n    }\n    B->b = newbuff;\n    B->size = newsize;\n    return newbuff + B->n;\n  }\n}\n\n/*\n** returns a pointer to a free area with at least 'sz' bytes\n*/\nLUALIB_API char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz) {\n  return prepbuffsize(B, sz, -1);\n}\n\n\nLUALIB_API void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l) {\n  if (l > 0) {  /* avoid 'memcpy' when 's' can be NULL */\n    char *b = prepbuffsize(B, l, -1);\n    memcpy(b, s, l * sizeof(char));\n    luaL_addsize(B, l);\n  }\n}\n\n\nLUALIB_API void luaL_addstring (luaL_Buffer *B, const char *s) {\n  luaL_addlstring(B, s, strlen(s));\n}\n\n\nLUALIB_API void luaL_pushresult (luaL_Buffer *B) {\n  lua_State *L = B->L;\n  checkbufferlevel(B, -1);\n  if (!buffonstack(B))  /* using static buffer? */\n    lua_pushlstring(L, B->b, B->n);  /* save result as regular string */\n  else {  /* reuse buffer already allocated */\n    UBox *box = (UBox *)lua_touserdata(L, -1);\n    void *ud;\n    lua_Alloc allocf = lua_getallocf(L, &ud);  /* function to free buffer */\n    size_t len = B->n;  /* final string length */\n    char *s;\n    resizebox(L, -1, len + 1);  /* adjust box size to content size */\n    s = (char*)box->box;  /* final buffer address */\n    s[len] = '\\0';  /* add ending zero */\n    /* clear box, as 'lua_pushextlstring' will take control over buffer */\n    box->bsize = 0;  box->box = NULL;\n    lua_pushextlstring(L, s, len, allocf, ud);\n    lua_closeslot(L, -2);  /* close the box */\n    lua_gc(L, LUA_GCSTEP, len);\n  }\n  lua_remove(L, -2);  /* remove box or placeholder from the stack */\n}\n\n\nLUALIB_API void luaL_pushresultsize (luaL_Buffer *B, size_t sz) {\n  luaL_addsize(B, sz);\n  luaL_pushresult(B);\n}\n\n\n/*\n** 'luaL_addvalue' is the only function in the Buffer system where the\n** box (if existent) is not on the top of the stack. So, instead of\n** calling 'luaL_addlstring', it replicates the code using -2 as the\n** last argument to 'prepbuffsize', signaling that the box is (or will\n** be) below the string being added to the buffer. (Box creation can\n** trigger an emergency GC, so we should not remove the string from the\n** stack before we have the space guaranteed.)\n*/\nLUALIB_API void luaL_addvalue (luaL_Buffer *B) {\n  lua_State *L = B->L;\n  size_t len;\n  const char *s = lua_tolstring(L, -1, &len);\n  char *b = prepbuffsize(B, len, -2);\n  memcpy(b, s, len * sizeof(char));\n  luaL_addsize(B, len);\n  lua_pop(L, 1);  /* pop string */\n}\n\n\nLUALIB_API void luaL_buffinit (lua_State *L, luaL_Buffer *B) {\n  B->L = L;\n  B->b = B->init.b;\n  B->n = 0;\n  B->size = LUAL_BUFFERSIZE;\n  lua_pushlightuserdata(L, (void*)B);  /* push placeholder */\n}\n\n\nLUALIB_API char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz) {\n  luaL_buffinit(L, B);\n  return prepbuffsize(B, sz, -1);\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Reference system\n** =======================================================\n*/\n\n/*\n** The previously freed references form a linked list: t[1] is the index\n** of a first free index, t[t[1]] is the index of the second element,\n** etc. A zero signals the end of the list.\n*/\nLUALIB_API int luaL_ref (lua_State *L, int t) {\n  int ref;\n  if (lua_isnil(L, -1)) {\n    lua_pop(L, 1);  /* remove from stack */\n    return LUA_REFNIL;  /* 'nil' has a unique fixed reference */\n  }\n  t = lua_absindex(L, t);\n  if (lua_rawgeti(L, t, 1) == LUA_TNUMBER)  /* already initialized? */\n    ref = (int)lua_tointeger(L, -1);  /* ref = t[1] */\n  else {  /* first access */\n    lua_assert(!lua_toboolean(L, -1));  /* must be nil or false */\n    ref = 0;  /* list is empty */\n    lua_pushinteger(L, 0);  /* initialize as an empty list */\n    lua_rawseti(L, t, 1);  /* ref = t[1] = 0 */\n  }\n  lua_pop(L, 1);  /* remove element from stack */\n  if (ref != 0) {  /* any free element? */\n    lua_rawgeti(L, t, ref);  /* remove it from list */\n    lua_rawseti(L, t, 1);  /* (t[1] = t[ref]) */\n  }\n  else  /* no free elements */\n    ref = (int)lua_rawlen(L, t) + 1;  /* get a new reference */\n  lua_rawseti(L, t, ref);\n  return ref;\n}\n\n\nLUALIB_API void luaL_unref (lua_State *L, int t, int ref) {\n  if (ref >= 0) {\n    t = lua_absindex(L, t);\n    lua_rawgeti(L, t, 1);\n    lua_assert(lua_isinteger(L, -1));\n    lua_rawseti(L, t, ref);  /* t[ref] = t[1] */\n    lua_pushinteger(L, ref);\n    lua_rawseti(L, t, 1);  /* t[1] = ref */\n  }\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Load functions\n** =======================================================\n*/\n\ntypedef struct LoadF {\n  unsigned n;  /* number of pre-read characters */\n  FILE *f;  /* file being read */\n  char buff[BUFSIZ];  /* area for reading file */\n} LoadF;\n\n\nstatic const char *getF (lua_State *L, void *ud, size_t *size) {\n  LoadF *lf = (LoadF *)ud;\n  (void)L;  /* not used */\n  if (lf->n > 0) {  /* are there pre-read characters to be read? */\n    *size = lf->n;  /* return them (chars already in buffer) */\n    lf->n = 0;  /* no more pre-read characters */\n  }\n  else {  /* read a block from file */\n    /* 'fread' can return > 0 *and* set the EOF flag. If next call to\n       'getF' called 'fread', it might still wait for user input.\n       The next check avoids this problem. */\n    if (feof(lf->f)) return NULL;\n    *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f);  /* read block */\n  }\n  return lf->buff;\n}\n\n\nstatic int errfile (lua_State *L, const char *what, int fnameindex) {\n  int err = errno;\n  const char *filename = lua_tostring(L, fnameindex) + 1;\n  if (err != 0)\n    lua_pushfstring(L, \"cannot %s %s: %s\", what, filename, strerror(err));\n  else\n    lua_pushfstring(L, \"cannot %s %s\", what, filename);\n  lua_remove(L, fnameindex);\n  return LUA_ERRFILE;\n}\n\n\n/*\n** Skip an optional BOM at the start of a stream. If there is an\n** incomplete BOM (the first character is correct but the rest is\n** not), returns the first character anyway to force an error\n** (as no chunk can start with 0xEF).\n*/\nstatic int skipBOM (FILE *f) {\n  int c = getc(f);  /* read first character */\n  if (c == 0xEF && getc(f) == 0xBB && getc(f) == 0xBF)  /* correct BOM? */\n    return getc(f);  /* ignore BOM and return next char */\n  else  /* no (valid) BOM */\n    return c;  /* return first character */\n}\n\n\n/*\n** reads the first character of file 'f' and skips an optional BOM mark\n** in its beginning plus its first line if it starts with '#'. Returns\n** true if it skipped the first line.  In any case, '*cp' has the\n** first \"valid\" character of the file (after the optional BOM and\n** a first-line comment).\n*/\nstatic int skipcomment (FILE *f, int *cp) {\n  int c = *cp = skipBOM(f);\n  if (c == '#') {  /* first line is a comment (Unix exec. file)? */\n    do {  /* skip first line */\n      c = getc(f);\n    } while (c != EOF && c != '\\n');\n    *cp = getc(f);  /* next character after comment, if present */\n    return 1;  /* there was a comment */\n  }\n  else return 0;  /* no comment */\n}\n\n\nLUALIB_API int luaL_loadfilex (lua_State *L, const char *filename,\n                                             const char *mode) {\n  LoadF lf;\n  int status, readstatus;\n  int c;\n  int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */\n  if (filename == NULL) {\n    lua_pushliteral(L, \"=stdin\");\n    lf.f = stdin;\n  }\n  else {\n    lua_pushfstring(L, \"@%s\", filename);\n    errno = 0;\n    lf.f = fopen(filename, \"r\");\n    if (lf.f == NULL) return errfile(L, \"open\", fnameindex);\n  }\n  lf.n = 0;\n  if (skipcomment(lf.f, &c))  /* read initial portion */\n    lf.buff[lf.n++] = '\\n';  /* add newline to correct line numbers */\n  if (c == LUA_SIGNATURE[0]) {  /* binary file? */\n    lf.n = 0;  /* remove possible newline */\n    if (filename) {  /* \"real\" file? */\n      errno = 0;\n      lf.f = freopen(filename, \"rb\", lf.f);  /* reopen in binary mode */\n      if (lf.f == NULL) return errfile(L, \"reopen\", fnameindex);\n      skipcomment(lf.f, &c);  /* re-read initial portion */\n    }\n  }\n  if (c != EOF)\n    lf.buff[lf.n++] = cast_char(c);  /* 'c' is the first character */\n  status = lua_load(L, getF, &lf, lua_tostring(L, -1), mode);\n  readstatus = ferror(lf.f);\n  errno = 0;  /* no useful error number until here */\n  if (filename) fclose(lf.f);  /* close file (even in case of errors) */\n  if (readstatus) {\n    lua_settop(L, fnameindex);  /* ignore results from 'lua_load' */\n    return errfile(L, \"read\", fnameindex);\n  }\n  lua_remove(L, fnameindex);\n  return status;\n}\n\n\ntypedef struct LoadS {\n  const char *s;\n  size_t size;\n} LoadS;\n\n\nstatic const char *getS (lua_State *L, void *ud, size_t *size) {\n  LoadS *ls = (LoadS *)ud;\n  (void)L;  /* not used */\n  if (ls->size == 0) return NULL;\n  *size = ls->size;\n  ls->size = 0;\n  return ls->s;\n}\n\n\nLUALIB_API int luaL_loadbufferx (lua_State *L, const char *buff, size_t size,\n                                 const char *name, const char *mode) {\n  LoadS ls;\n  ls.s = buff;\n  ls.size = size;\n  return lua_load(L, getS, &ls, name, mode);\n}\n\n\nLUALIB_API int luaL_loadstring (lua_State *L, const char *s) {\n  return luaL_loadbuffer(L, s, strlen(s), s);\n}\n\n/* }====================================================== */\n\n\n\nLUALIB_API int luaL_getmetafield (lua_State *L, int obj, const char *event) {\n  if (!lua_getmetatable(L, obj))  /* no metatable? */\n    return LUA_TNIL;\n  else {\n    int tt;\n    lua_pushstring(L, event);\n    tt = lua_rawget(L, -2);\n    if (tt == LUA_TNIL)  /* is metafield nil? */\n      lua_pop(L, 2);  /* remove metatable and metafield */\n    else\n      lua_remove(L, -2);  /* remove only metatable */\n    return tt;  /* return metafield type */\n  }\n}\n\n\nLUALIB_API int luaL_callmeta (lua_State *L, int obj, const char *event) {\n  obj = lua_absindex(L, obj);\n  if (luaL_getmetafield(L, obj, event) == LUA_TNIL)  /* no metafield? */\n    return 0;\n  lua_pushvalue(L, obj);\n  lua_call(L, 1, 1);\n  return 1;\n}\n\n\nLUALIB_API lua_Integer luaL_len (lua_State *L, int idx) {\n  lua_Integer l;\n  int isnum;\n  lua_len(L, idx);\n  l = lua_tointegerx(L, -1, &isnum);\n  if (l_unlikely(!isnum))\n    luaL_error(L, \"object length is not an integer\");\n  lua_pop(L, 1);  /* remove object */\n  return l;\n}\n\n\nLUALIB_API const char *luaL_tolstring (lua_State *L, int idx, size_t *len) {\n  idx = lua_absindex(L,idx);\n  if (luaL_callmeta(L, idx, \"__tostring\")) {  /* metafield? */\n    if (!lua_isstring(L, -1))\n      luaL_error(L, \"'__tostring' must return a string\");\n  }\n  else {\n    switch (lua_type(L, idx)) {\n      case LUA_TNUMBER: {\n        char buff[LUA_N2SBUFFSZ];\n        lua_numbertostrbuff(L, idx, buff);\n        lua_pushstring(L, buff);\n        break;\n      }\n      case LUA_TSTRING:\n        lua_pushvalue(L, idx);\n        break;\n      case LUA_TBOOLEAN:\n        lua_pushstring(L, (lua_toboolean(L, idx) ? \"true\" : \"false\"));\n        break;\n      case LUA_TNIL:\n        lua_pushliteral(L, \"nil\");\n        break;\n      default: {\n        int tt = luaL_getmetafield(L, idx, \"__name\");  /* try name */\n        const char *kind = (tt == LUA_TSTRING) ? lua_tostring(L, -1) :\n                                                 luaL_typename(L, idx);\n        lua_pushfstring(L, \"%s: %p\", kind, lua_topointer(L, idx));\n        if (tt != LUA_TNIL)\n          lua_remove(L, -2);  /* remove '__name' */\n        break;\n      }\n    }\n  }\n  return lua_tolstring(L, -1, len);\n}\n\n\n/*\n** set functions from list 'l' into table at top - 'nup'; each\n** function gets the 'nup' elements at the top as upvalues.\n** Returns with only the table at the stack.\n*/\nLUALIB_API void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup) {\n  luaL_checkstack(L, nup, \"too many upvalues\");\n  for (; l->name != NULL; l++) {  /* fill the table with given functions */\n    if (l->func == NULL)  /* placeholder? */\n      lua_pushboolean(L, 0);\n    else {\n      int i;\n      for (i = 0; i < nup; i++)  /* copy upvalues to the top */\n        lua_pushvalue(L, -nup);\n      lua_pushcclosure(L, l->func, nup);  /* closure with those upvalues */\n    }\n    lua_setfield(L, -(nup + 2), l->name);\n  }\n  lua_pop(L, nup);  /* remove upvalues */\n}\n\n\n/*\n** ensure that stack[idx][fname] has a table and push that table\n** into the stack\n*/\nLUALIB_API int luaL_getsubtable (lua_State *L, int idx, const char *fname) {\n  if (lua_getfield(L, idx, fname) == LUA_TTABLE)\n    return 1;  /* table already there */\n  else {\n    lua_pop(L, 1);  /* remove previous result */\n    idx = lua_absindex(L, idx);\n    lua_newtable(L);\n    lua_pushvalue(L, -1);  /* copy to be left at top */\n    lua_setfield(L, idx, fname);  /* assign new table to field */\n    return 0;  /* false, because did not find table there */\n  }\n}\n\n\n/*\n** Stripped-down 'require': After checking \"loaded\" table, calls 'openf'\n** to open a module, registers the result in 'package.loaded' table and,\n** if 'glb' is true, also registers the result in the global table.\n** Leaves resulting module on the top.\n*/\nLUALIB_API void luaL_requiref (lua_State *L, const char *modname,\n                               lua_CFunction openf, int glb) {\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n  lua_getfield(L, -1, modname);  /* LOADED[modname] */\n  if (!lua_toboolean(L, -1)) {  /* package not already loaded? */\n    lua_pop(L, 1);  /* remove field */\n    lua_pushcfunction(L, openf);\n    lua_pushstring(L, modname);  /* argument to open function */\n    lua_call(L, 1, 1);  /* call 'openf' to open module */\n    lua_pushvalue(L, -1);  /* make copy of module (call result) */\n    lua_setfield(L, -3, modname);  /* LOADED[modname] = module */\n  }\n  lua_remove(L, -2);  /* remove LOADED table */\n  if (glb) {\n    lua_pushvalue(L, -1);  /* copy of module */\n    lua_setglobal(L, modname);  /* _G[modname] = module */\n  }\n}\n\n\nLUALIB_API void luaL_addgsub (luaL_Buffer *b, const char *s,\n                                     const char *p, const char *r) {\n  const char *wild;\n  size_t l = strlen(p);\n  while ((wild = strstr(s, p)) != NULL) {\n    luaL_addlstring(b, s, ct_diff2sz(wild - s));  /* push prefix */\n    luaL_addstring(b, r);  /* push replacement in place of pattern */\n    s = wild + l;  /* continue after 'p' */\n  }\n  luaL_addstring(b, s);  /* push last suffix */\n}\n\n\nLUALIB_API const char *luaL_gsub (lua_State *L, const char *s,\n                                  const char *p, const char *r) {\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  luaL_addgsub(&b, s, p, r);\n  luaL_pushresult(&b);\n  return lua_tostring(L, -1);\n}\n\n\nstatic void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {\n  (void)ud; (void)osize;  /* not used */\n  if (nsize == 0) {\n    free(ptr);\n    return NULL;\n  }\n  else\n    return realloc(ptr, nsize);\n}\n\n\n/*\n** Standard panic function just prints an error message. The test\n** with 'lua_type' avoids possible memory errors in 'lua_tostring'.\n*/\nstatic int panic (lua_State *L) {\n  const char *msg = (lua_type(L, -1) == LUA_TSTRING)\n                  ? lua_tostring(L, -1)\n                  : \"error object is not a string\";\n  lua_writestringerror(\"PANIC: unprotected error in call to Lua API (%s)\\n\",\n                        msg);\n  return 0;  /* return to Lua to abort */\n}\n\n\n/*\n** Warning functions:\n** warnfoff: warning system is off\n** warnfon: ready to start a new message\n** warnfcont: previous message is to be continued\n*/\nstatic void warnfoff (void *ud, const char *message, int tocont);\nstatic void warnfon (void *ud, const char *message, int tocont);\nstatic void warnfcont (void *ud, const char *message, int tocont);\n\n\n/*\n** Check whether message is a control message. If so, execute the\n** control or ignore it if unknown.\n*/\nstatic int checkcontrol (lua_State *L, const char *message, int tocont) {\n  if (tocont || *(message++) != '@')  /* not a control message? */\n    return 0;\n  else {\n    if (strcmp(message, \"off\") == 0)\n      lua_setwarnf(L, warnfoff, L);  /* turn warnings off */\n    else if (strcmp(message, \"on\") == 0)\n      lua_setwarnf(L, warnfon, L);   /* turn warnings on */\n    return 1;  /* it was a control message */\n  }\n}\n\n\nstatic void warnfoff (void *ud, const char *message, int tocont) {\n  checkcontrol((lua_State *)ud, message, tocont);\n}\n\n\n/*\n** Writes the message and handle 'tocont', finishing the message\n** if needed and setting the next warn function.\n*/\nstatic void warnfcont (void *ud, const char *message, int tocont) {\n  lua_State *L = (lua_State *)ud;\n  lua_writestringerror(\"%s\", message);  /* write message */\n  if (tocont)  /* not the last part? */\n    lua_setwarnf(L, warnfcont, L);  /* to be continued */\n  else {  /* last part */\n    lua_writestringerror(\"%s\", \"\\n\");  /* finish message with end-of-line */\n    lua_setwarnf(L, warnfon, L);  /* next call is a new message */\n  }\n}\n\n\nstatic void warnfon (void *ud, const char *message, int tocont) {\n  if (checkcontrol((lua_State *)ud, message, tocont))  /* control message? */\n    return;  /* nothing else to be done */\n  lua_writestringerror(\"%s\", \"Lua warning: \");  /* start a new warning */\n  warnfcont(ud, message, tocont);  /* finish processing */\n}\n\n\n\n/*\n** A function to compute an unsigned int with some level of\n** randomness. Rely on Address Space Layout Randomization (if present)\n** and the current time.\n*/\n#if !defined(luai_makeseed)\n\n#include <time.h>\n\n\n/* Size for the buffer, in bytes */\n#define BUFSEEDB\t(sizeof(void*) + sizeof(time_t))\n\n/* Size for the buffer in int's, rounded up */\n#define BUFSEED\t\t((BUFSEEDB + sizeof(int) - 1) / sizeof(int))\n\n/*\n** Copy the contents of variable 'v' into the buffer pointed by 'b'.\n** (The '&b[0]' disguises 'b' to fix an absurd warning from clang.)\n*/\n#define addbuff(b,v)\t(memcpy(&b[0], &(v), sizeof(v)), b += sizeof(v))\n\n\nstatic unsigned int luai_makeseed (void) {\n  unsigned int buff[BUFSEED];\n  unsigned int res;\n  unsigned int i;\n  time_t t = time(NULL);\n  char *b = (char*)buff;\n  addbuff(b, b);  /* local variable's address */\n  addbuff(b, t);  /* time */\n  /* fill (rare but possible) remain of the buffer with zeros */\n  memset(b, 0, sizeof(buff) - BUFSEEDB);\n  res = buff[0];\n  for (i = 1; i < BUFSEED; i++)\n    res ^= (res >> 3) + (res << 7) + buff[i];\n  return res;\n}\n\n#endif\n\n\nLUALIB_API unsigned int luaL_makeseed (lua_State *L) {\n  (void)L;  /* unused */\n  return luai_makeseed();\n}\n\n\nLUALIB_API lua_State *luaL_newstate (void) {\n  lua_State *L = lua_newstate(l_alloc, NULL, luai_makeseed());\n  if (l_likely(L)) {\n    lua_atpanic(L, &panic);\n    lua_setwarnf(L, warnfoff, L);  /* default is warnings off */\n  }\n  return L;\n}\n\n\nLUALIB_API void luaL_checkversion_ (lua_State *L, lua_Number ver, size_t sz) {\n  lua_Number v = lua_version(L);\n  if (sz != LUAL_NUMSIZES)  /* check numeric types */\n    luaL_error(L, \"core and library have incompatible numeric types\");\n  else if (v != ver)\n    luaL_error(L, \"version mismatch: app. needs %f, Lua core provides %f\",\n                  (LUAI_UACNUMBER)ver, (LUAI_UACNUMBER)v);\n}\n\n"
        },
        {
          "name": "lauxlib.h",
          "type": "blob",
          "size": 8.2216796875,
          "content": "/*\n** $Id: lauxlib.h $\n** Auxiliary functions for building Lua libraries\n** See Copyright Notice in lua.h\n*/\n\n\n#ifndef lauxlib_h\n#define lauxlib_h\n\n\n#include <stddef.h>\n#include <stdio.h>\n\n#include \"luaconf.h\"\n#include \"lua.h\"\n\n\n/* global table */\n#define LUA_GNAME\t\"_G\"\n\n\ntypedef struct luaL_Buffer luaL_Buffer;\n\n\n/* extra error code for 'luaL_loadfilex' */\n#define LUA_ERRFILE     (LUA_ERRERR+1)\n\n\n/* key, in the registry, for table of loaded modules */\n#define LUA_LOADED_TABLE\t\"_LOADED\"\n\n\n/* key, in the registry, for table of preloaded loaders */\n#define LUA_PRELOAD_TABLE\t\"_PRELOAD\"\n\n\ntypedef struct luaL_Reg {\n  const char *name;\n  lua_CFunction func;\n} luaL_Reg;\n\n\n#define LUAL_NUMSIZES\t(sizeof(lua_Integer)*16 + sizeof(lua_Number))\n\nLUALIB_API void (luaL_checkversion_) (lua_State *L, lua_Number ver, size_t sz);\n#define luaL_checkversion(L)  \\\n\t  luaL_checkversion_(L, LUA_VERSION_NUM, LUAL_NUMSIZES)\n\nLUALIB_API int (luaL_getmetafield) (lua_State *L, int obj, const char *e);\nLUALIB_API int (luaL_callmeta) (lua_State *L, int obj, const char *e);\nLUALIB_API const char *(luaL_tolstring) (lua_State *L, int idx, size_t *len);\nLUALIB_API int (luaL_argerror) (lua_State *L, int arg, const char *extramsg);\nLUALIB_API int (luaL_typeerror) (lua_State *L, int arg, const char *tname);\nLUALIB_API const char *(luaL_checklstring) (lua_State *L, int arg,\n                                                          size_t *l);\nLUALIB_API const char *(luaL_optlstring) (lua_State *L, int arg,\n                                          const char *def, size_t *l);\nLUALIB_API lua_Number (luaL_checknumber) (lua_State *L, int arg);\nLUALIB_API lua_Number (luaL_optnumber) (lua_State *L, int arg, lua_Number def);\n\nLUALIB_API lua_Integer (luaL_checkinteger) (lua_State *L, int arg);\nLUALIB_API lua_Integer (luaL_optinteger) (lua_State *L, int arg,\n                                          lua_Integer def);\n\nLUALIB_API void (luaL_checkstack) (lua_State *L, int sz, const char *msg);\nLUALIB_API void (luaL_checktype) (lua_State *L, int arg, int t);\nLUALIB_API void (luaL_checkany) (lua_State *L, int arg);\n\nLUALIB_API int   (luaL_newmetatable) (lua_State *L, const char *tname);\nLUALIB_API void  (luaL_setmetatable) (lua_State *L, const char *tname);\nLUALIB_API void *(luaL_testudata) (lua_State *L, int ud, const char *tname);\nLUALIB_API void *(luaL_checkudata) (lua_State *L, int ud, const char *tname);\n\nLUALIB_API void (luaL_where) (lua_State *L, int lvl);\nLUALIB_API int (luaL_error) (lua_State *L, const char *fmt, ...);\n\nLUALIB_API int (luaL_checkoption) (lua_State *L, int arg, const char *def,\n                                   const char *const lst[]);\n\nLUALIB_API int (luaL_fileresult) (lua_State *L, int stat, const char *fname);\nLUALIB_API int (luaL_execresult) (lua_State *L, int stat);\n\n\n/* predefined references */\n#define LUA_NOREF       (-2)\n#define LUA_REFNIL      (-1)\n\nLUALIB_API int (luaL_ref) (lua_State *L, int t);\nLUALIB_API void (luaL_unref) (lua_State *L, int t, int ref);\n\nLUALIB_API int (luaL_loadfilex) (lua_State *L, const char *filename,\n                                               const char *mode);\n\n#define luaL_loadfile(L,f)\tluaL_loadfilex(L,f,NULL)\n\nLUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,\n                                   const char *name, const char *mode);\nLUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);\n\nLUALIB_API lua_State *(luaL_newstate) (void);\n\nLUALIB_API unsigned luaL_makeseed (lua_State *L);\n\nLUALIB_API lua_Integer (luaL_len) (lua_State *L, int idx);\n\nLUALIB_API void (luaL_addgsub) (luaL_Buffer *b, const char *s,\n                                     const char *p, const char *r);\nLUALIB_API const char *(luaL_gsub) (lua_State *L, const char *s,\n                                    const char *p, const char *r);\n\nLUALIB_API void (luaL_setfuncs) (lua_State *L, const luaL_Reg *l, int nup);\n\nLUALIB_API int (luaL_getsubtable) (lua_State *L, int idx, const char *fname);\n\nLUALIB_API void (luaL_traceback) (lua_State *L, lua_State *L1,\n                                  const char *msg, int level);\n\nLUALIB_API void (luaL_requiref) (lua_State *L, const char *modname,\n                                 lua_CFunction openf, int glb);\n\n/*\n** ===============================================================\n** some useful macros\n** ===============================================================\n*/\n\n\n#define luaL_newlibtable(L,l)\t\\\n  lua_createtable(L, 0, sizeof(l)/sizeof((l)[0]) - 1)\n\n#define luaL_newlib(L,l)  \\\n  (luaL_checkversion(L), luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))\n\n#define luaL_argcheck(L, cond,arg,extramsg)\t\\\n\t((void)(luai_likely(cond) || luaL_argerror(L, (arg), (extramsg))))\n\n#define luaL_argexpected(L,cond,arg,tname)\t\\\n\t((void)(luai_likely(cond) || luaL_typeerror(L, (arg), (tname))))\n\n#define luaL_checkstring(L,n)\t(luaL_checklstring(L, (n), NULL))\n#define luaL_optstring(L,n,d)\t(luaL_optlstring(L, (n), (d), NULL))\n\n#define luaL_typename(L,i)\tlua_typename(L, lua_type(L,(i)))\n\n#define luaL_dofile(L, fn) \\\n\t(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\n#define luaL_dostring(L, s) \\\n\t(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))\n\n#define luaL_getmetatable(L,n)\t(lua_getfield(L, LUA_REGISTRYINDEX, (n)))\n\n#define luaL_opt(L,f,n,d)\t(lua_isnoneornil(L,(n)) ? (d) : f(L,(n)))\n\n#define luaL_loadbuffer(L,s,sz,n)\tluaL_loadbufferx(L,s,sz,n,NULL)\n\n\n/*\n** Perform arithmetic operations on lua_Integer values with wrap-around\n** semantics, as the Lua core does.\n*/\n#define luaL_intop(op,v1,v2)  \\\n\t((lua_Integer)((lua_Unsigned)(v1) op (lua_Unsigned)(v2)))\n\n\n/* push the value used to represent failure/error */\n#define luaL_pushfail(L)\tlua_pushnil(L)\n\n\n\n/*\n** {======================================================\n** Generic Buffer manipulation\n** =======================================================\n*/\n\nstruct luaL_Buffer {\n  char *b;  /* buffer address */\n  size_t size;  /* buffer size */\n  size_t n;  /* number of characters in buffer */\n  lua_State *L;\n  union {\n    LUAI_MAXALIGN;  /* ensure maximum alignment for buffer */\n    char b[LUAL_BUFFERSIZE];  /* initial buffer */\n  } init;\n};\n\n\n#define luaL_bufflen(bf)\t((bf)->n)\n#define luaL_buffaddr(bf)\t((bf)->b)\n\n\n#define luaL_addchar(B,c) \\\n  ((void)((B)->n < (B)->size || luaL_prepbuffsize((B), 1)), \\\n   ((B)->b[(B)->n++] = (c)))\n\n#define luaL_addsize(B,s)\t((B)->n += (s))\n\n#define luaL_buffsub(B,s)\t((B)->n -= (s))\n\nLUALIB_API void (luaL_buffinit) (lua_State *L, luaL_Buffer *B);\nLUALIB_API char *(luaL_prepbuffsize) (luaL_Buffer *B, size_t sz);\nLUALIB_API void (luaL_addlstring) (luaL_Buffer *B, const char *s, size_t l);\nLUALIB_API void (luaL_addstring) (luaL_Buffer *B, const char *s);\nLUALIB_API void (luaL_addvalue) (luaL_Buffer *B);\nLUALIB_API void (luaL_pushresult) (luaL_Buffer *B);\nLUALIB_API void (luaL_pushresultsize) (luaL_Buffer *B, size_t sz);\nLUALIB_API char *(luaL_buffinitsize) (lua_State *L, luaL_Buffer *B, size_t sz);\n\n#define luaL_prepbuffer(B)\tluaL_prepbuffsize(B, LUAL_BUFFERSIZE)\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** File handles for IO library\n** =======================================================\n*/\n\n/*\n** A file handle is a userdata with metatable 'LUA_FILEHANDLE' and\n** initial structure 'luaL_Stream' (it may contain other fields\n** after that initial structure).\n*/\n\n#define LUA_FILEHANDLE          \"FILE*\"\n\n\ntypedef struct luaL_Stream {\n  FILE *f;  /* stream (NULL for incompletely created streams) */\n  lua_CFunction closef;  /* to close stream (NULL for closed streams) */\n} luaL_Stream;\n\n/* }====================================================== */\n\n\n/*\n** {============================================================\n** Compatibility with deprecated conversions\n** =============================================================\n*/\n#if defined(LUA_COMPAT_APIINTCASTS)\n\n#define luaL_checkunsigned(L,a)\t((lua_Unsigned)luaL_checkinteger(L,a))\n#define luaL_optunsigned(L,a,d)\t\\\n\t((lua_Unsigned)luaL_optinteger(L,a,(lua_Integer)(d)))\n\n#define luaL_checkint(L,n)\t((int)luaL_checkinteger(L, (n)))\n#define luaL_optint(L,n,d)\t((int)luaL_optinteger(L, (n), (d)))\n\n#define luaL_checklong(L,n)\t((long)luaL_checkinteger(L, (n)))\n#define luaL_optlong(L,n,d)\t((long)luaL_optinteger(L, (n), (d)))\n\n#endif\n/* }============================================================ */\n\n\n\n#endif\n\n\n"
        },
        {
          "name": "lbaselib.c",
          "type": "blob",
          "size": 15.3623046875,
          "content": "/*\n** $Id: lbaselib.c $\n** Basic library\n** See Copyright Notice in lua.h\n*/\n\n#define lbaselib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n#include \"llimits.h\"\n\n\nstatic int luaB_print (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  int i;\n  for (i = 1; i <= n; i++) {  /* for each argument */\n    size_t l;\n    const char *s = luaL_tolstring(L, i, &l);  /* convert it to string */\n    if (i > 1)  /* not the first element? */\n      lua_writestring(\"\\t\", 1);  /* add a tab before it */\n    lua_writestring(s, l);  /* print it */\n    lua_pop(L, 1);  /* pop result */\n  }\n  lua_writeline();\n  return 0;\n}\n\n\n/*\n** Creates a warning with all given arguments.\n** Check first for errors; otherwise an error may interrupt\n** the composition of a warning, leaving it unfinished.\n*/\nstatic int luaB_warn (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  int i;\n  luaL_checkstring(L, 1);  /* at least one argument */\n  for (i = 2; i <= n; i++)\n    luaL_checkstring(L, i);  /* make sure all arguments are strings */\n  for (i = 1; i < n; i++)  /* compose warning */\n    lua_warning(L, lua_tostring(L, i), 1);\n  lua_warning(L, lua_tostring(L, n), 0);  /* close warning */\n  return 0;\n}\n\n\n#define SPACECHARS\t\" \\f\\n\\r\\t\\v\"\n\nstatic const char *b_str2int (const char *s, unsigned base, lua_Integer *pn) {\n  lua_Unsigned n = 0;\n  int neg = 0;\n  s += strspn(s, SPACECHARS);  /* skip initial spaces */\n  if (*s == '-') { s++; neg = 1; }  /* handle sign */\n  else if (*s == '+') s++;\n  if (!isalnum(cast_uchar(*s)))  /* no digit? */\n    return NULL;\n  do {\n    unsigned digit = cast_uint(isdigit(cast_uchar(*s))\n                               ? *s - '0'\n                               : (toupper(cast_uchar(*s)) - 'A') + 10);\n    if (digit >= base) return NULL;  /* invalid numeral */\n    n = n * base + digit;\n    s++;\n  } while (isalnum(cast_uchar(*s)));\n  s += strspn(s, SPACECHARS);  /* skip trailing spaces */\n  *pn = (lua_Integer)((neg) ? (0u - n) : n);\n  return s;\n}\n\n\nstatic int luaB_tonumber (lua_State *L) {\n  if (lua_isnoneornil(L, 2)) {  /* standard conversion? */\n    if (lua_type(L, 1) == LUA_TNUMBER) {  /* already a number? */\n      lua_settop(L, 1);  /* yes; return it */\n      return 1;\n    }\n    else {\n      size_t l;\n      const char *s = lua_tolstring(L, 1, &l);\n      if (s != NULL && lua_stringtonumber(L, s) == l + 1)\n        return 1;  /* successful conversion to number */\n      /* else not a number */\n      luaL_checkany(L, 1);  /* (but there must be some parameter) */\n    }\n  }\n  else {\n    size_t l;\n    const char *s;\n    lua_Integer n = 0;  /* to avoid warnings */\n    lua_Integer base = luaL_checkinteger(L, 2);\n    luaL_checktype(L, 1, LUA_TSTRING);  /* no numbers as strings */\n    s = lua_tolstring(L, 1, &l);\n    luaL_argcheck(L, 2 <= base && base <= 36, 2, \"base out of range\");\n    if (b_str2int(s, cast_uint(base), &n) == s + l) {\n      lua_pushinteger(L, n);\n      return 1;\n    }  /* else not a number */\n  }  /* else not a number */\n  luaL_pushfail(L);  /* not a number */\n  return 1;\n}\n\n\nstatic int luaB_error (lua_State *L) {\n  int level = (int)luaL_optinteger(L, 2, 1);\n  lua_settop(L, 1);\n  if (lua_type(L, 1) == LUA_TSTRING && level > 0) {\n    luaL_where(L, level);   /* add extra information */\n    lua_pushvalue(L, 1);\n    lua_concat(L, 2);\n  }\n  return lua_error(L);\n}\n\n\nstatic int luaB_getmetatable (lua_State *L) {\n  luaL_checkany(L, 1);\n  if (!lua_getmetatable(L, 1)) {\n    lua_pushnil(L);\n    return 1;  /* no metatable */\n  }\n  luaL_getmetafield(L, 1, \"__metatable\");\n  return 1;  /* returns either __metatable field (if present) or metatable */\n}\n\n\nstatic int luaB_setmetatable (lua_State *L) {\n  int t = lua_type(L, 2);\n  luaL_checktype(L, 1, LUA_TTABLE);\n  luaL_argexpected(L, t == LUA_TNIL || t == LUA_TTABLE, 2, \"nil or table\");\n  if (l_unlikely(luaL_getmetafield(L, 1, \"__metatable\") != LUA_TNIL))\n    return luaL_error(L, \"cannot change a protected metatable\");\n  lua_settop(L, 2);\n  lua_setmetatable(L, 1);\n  return 1;\n}\n\n\nstatic int luaB_rawequal (lua_State *L) {\n  luaL_checkany(L, 1);\n  luaL_checkany(L, 2);\n  lua_pushboolean(L, lua_rawequal(L, 1, 2));\n  return 1;\n}\n\n\nstatic int luaB_rawlen (lua_State *L) {\n  int t = lua_type(L, 1);\n  luaL_argexpected(L, t == LUA_TTABLE || t == LUA_TSTRING, 1,\n                      \"table or string\");\n  lua_pushinteger(L, l_castU2S(lua_rawlen(L, 1)));\n  return 1;\n}\n\n\nstatic int luaB_rawget (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  luaL_checkany(L, 2);\n  lua_settop(L, 2);\n  lua_rawget(L, 1);\n  return 1;\n}\n\nstatic int luaB_rawset (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  luaL_checkany(L, 2);\n  luaL_checkany(L, 3);\n  lua_settop(L, 3);\n  lua_rawset(L, 1);\n  return 1;\n}\n\n\nstatic int pushmode (lua_State *L, int oldmode) {\n  if (oldmode == -1)\n    luaL_pushfail(L);  /* invalid call to 'lua_gc' */\n  else\n    lua_pushstring(L, (oldmode == LUA_GCINC) ? \"incremental\"\n                                             : \"generational\");\n  return 1;\n}\n\n\n/*\n** check whether call to 'lua_gc' was valid (not inside a finalizer)\n*/\n#define checkvalres(res) { if (res == -1) break; }\n\nstatic int luaB_collectgarbage (lua_State *L) {\n  static const char *const opts[] = {\"stop\", \"restart\", \"collect\",\n    \"count\", \"step\", \"isrunning\", \"generational\", \"incremental\",\n    \"param\", NULL};\n  static const char optsnum[] = {LUA_GCSTOP, LUA_GCRESTART, LUA_GCCOLLECT,\n    LUA_GCCOUNT, LUA_GCSTEP, LUA_GCISRUNNING, LUA_GCGEN, LUA_GCINC,\n    LUA_GCPARAM};\n  int o = optsnum[luaL_checkoption(L, 1, \"collect\", opts)];\n  switch (o) {\n    case LUA_GCCOUNT: {\n      int k = lua_gc(L, o);\n      int b = lua_gc(L, LUA_GCCOUNTB);\n      checkvalres(k);\n      lua_pushnumber(L, (lua_Number)k + ((lua_Number)b/1024));\n      return 1;\n    }\n    case LUA_GCSTEP: {\n      lua_Integer n = luaL_optinteger(L, 2, 0);\n      int res = lua_gc(L, o, cast_sizet(n));\n      checkvalres(res);\n      lua_pushboolean(L, res);\n      return 1;\n    }\n    case LUA_GCISRUNNING: {\n      int res = lua_gc(L, o);\n      checkvalres(res);\n      lua_pushboolean(L, res);\n      return 1;\n    }\n    case LUA_GCGEN: {\n      return pushmode(L, lua_gc(L, o));\n    }\n    case LUA_GCINC: {\n      return pushmode(L, lua_gc(L, o));\n    }\n    case LUA_GCPARAM: {\n      static const char *const params[] = {\n        \"minormul\", \"majorminor\", \"minormajor\",\n        \"pause\", \"stepmul\", \"stepsize\", NULL};\n      static const char pnum[] = {\n        LUA_GCPMINORMUL, LUA_GCPMAJORMINOR, LUA_GCPMINORMAJOR,\n        LUA_GCPPAUSE, LUA_GCPSTEPMUL, LUA_GCPSTEPSIZE};\n      int p = pnum[luaL_checkoption(L, 2, NULL, params)];\n      lua_Integer value = luaL_optinteger(L, 3, -1);\n      lua_pushinteger(L, lua_gc(L, o, p, (int)value));\n      return 1;\n    }\n    default: {\n      int res = lua_gc(L, o);\n      checkvalres(res);\n      lua_pushinteger(L, res);\n      return 1;\n    }\n  }\n  luaL_pushfail(L);  /* invalid call (inside a finalizer) */\n  return 1;\n}\n\n\nstatic int luaB_type (lua_State *L) {\n  int t = lua_type(L, 1);\n  luaL_argcheck(L, t != LUA_TNONE, 1, \"value expected\");\n  lua_pushstring(L, lua_typename(L, t));\n  return 1;\n}\n\n\nstatic int luaB_next (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  lua_settop(L, 2);  /* create a 2nd argument if there isn't one */\n  if (lua_next(L, 1))\n    return 2;\n  else {\n    lua_pushnil(L);\n    return 1;\n  }\n}\n\n\nstatic int pairscont (lua_State *L, int status, lua_KContext k) {\n  (void)L; (void)status; (void)k;  /* unused */\n  return 3;\n}\n\nstatic int luaB_pairs (lua_State *L) {\n  luaL_checkany(L, 1);\n  if (luaL_getmetafield(L, 1, \"__pairs\") == LUA_TNIL) {  /* no metamethod? */\n    lua_pushcfunction(L, luaB_next);  /* will return generator, */\n    lua_pushvalue(L, 1);  /* state, */\n    lua_pushnil(L);  /* and initial value */\n  }\n  else {\n    lua_pushvalue(L, 1);  /* argument 'self' to metamethod */\n    lua_callk(L, 1, 3, 0, pairscont);  /* get 3 values from metamethod */\n  }\n  return 3;\n}\n\n\n/*\n** Traversal function for 'ipairs'\n*/\nstatic int ipairsaux (lua_State *L) {\n  lua_Integer i = luaL_checkinteger(L, 2);\n  i = luaL_intop(+, i, 1);\n  lua_pushinteger(L, i);\n  return (lua_geti(L, 1, i) == LUA_TNIL) ? 1 : 2;\n}\n\n\n/*\n** 'ipairs' function. Returns 'ipairsaux', given \"table\", 0.\n** (The given \"table\" may not be a table.)\n*/\nstatic int luaB_ipairs (lua_State *L) {\n  luaL_checkany(L, 1);\n  lua_pushcfunction(L, ipairsaux);  /* iteration function */\n  lua_pushvalue(L, 1);  /* state */\n  lua_pushinteger(L, 0);  /* initial value */\n  return 3;\n}\n\n\nstatic int load_aux (lua_State *L, int status, int envidx) {\n  if (l_likely(status == LUA_OK)) {\n    if (envidx != 0) {  /* 'env' parameter? */\n      lua_pushvalue(L, envidx);  /* environment for loaded function */\n      if (!lua_setupvalue(L, -2, 1))  /* set it as 1st upvalue */\n        lua_pop(L, 1);  /* remove 'env' if not used by previous call */\n    }\n    return 1;\n  }\n  else {  /* error (message is on top of the stack) */\n    luaL_pushfail(L);\n    lua_insert(L, -2);  /* put before error message */\n    return 2;  /* return fail plus error message */\n  }\n}\n\n\nstatic const char *getMode (lua_State *L, int idx) {\n  const char *mode = luaL_optstring(L, idx, \"bt\");\n  if (strchr(mode, 'B') != NULL)  /* Lua code cannot use fixed buffers */\n    luaL_argerror(L, idx, \"invalid mode\");\n  return mode;\n}\n\n\nstatic int luaB_loadfile (lua_State *L) {\n  const char *fname = luaL_optstring(L, 1, NULL);\n  const char *mode = getMode(L, 2);\n  int env = (!lua_isnone(L, 3) ? 3 : 0);  /* 'env' index or 0 if no 'env' */\n  int status = luaL_loadfilex(L, fname, mode);\n  return load_aux(L, status, env);\n}\n\n\n/*\n** {======================================================\n** Generic Read function\n** =======================================================\n*/\n\n\n/*\n** reserved slot, above all arguments, to hold a copy of the returned\n** string to avoid it being collected while parsed. 'load' has four\n** optional arguments (chunk, source name, mode, and environment).\n*/\n#define RESERVEDSLOT\t5\n\n\n/*\n** Reader for generic 'load' function: 'lua_load' uses the\n** stack for internal stuff, so the reader cannot change the\n** stack top. Instead, it keeps its resulting string in a\n** reserved slot inside the stack.\n*/\nstatic const char *generic_reader (lua_State *L, void *ud, size_t *size) {\n  (void)(ud);  /* not used */\n  luaL_checkstack(L, 2, \"too many nested functions\");\n  lua_pushvalue(L, 1);  /* get function */\n  lua_call(L, 0, 1);  /* call it */\n  if (lua_isnil(L, -1)) {\n    lua_pop(L, 1);  /* pop result */\n    *size = 0;\n    return NULL;\n  }\n  else if (l_unlikely(!lua_isstring(L, -1)))\n    luaL_error(L, \"reader function must return a string\");\n  lua_replace(L, RESERVEDSLOT);  /* save string in reserved slot */\n  return lua_tolstring(L, RESERVEDSLOT, size);\n}\n\n\nstatic int luaB_load (lua_State *L) {\n  int status;\n  size_t l;\n  const char *s = lua_tolstring(L, 1, &l);\n  const char *mode = getMode(L, 3);\n  int env = (!lua_isnone(L, 4) ? 4 : 0);  /* 'env' index or 0 if no 'env' */\n  if (s != NULL) {  /* loading a string? */\n    const char *chunkname = luaL_optstring(L, 2, s);\n    status = luaL_loadbufferx(L, s, l, chunkname, mode);\n  }\n  else {  /* loading from a reader function */\n    const char *chunkname = luaL_optstring(L, 2, \"=(load)\");\n    luaL_checktype(L, 1, LUA_TFUNCTION);\n    lua_settop(L, RESERVEDSLOT);  /* create reserved slot */\n    status = lua_load(L, generic_reader, NULL, chunkname, mode);\n  }\n  return load_aux(L, status, env);\n}\n\n/* }====================================================== */\n\n\nstatic int dofilecont (lua_State *L, int d1, lua_KContext d2) {\n  (void)d1;  (void)d2;  /* only to match 'lua_Kfunction' prototype */\n  return lua_gettop(L) - 1;\n}\n\n\nstatic int luaB_dofile (lua_State *L) {\n  const char *fname = luaL_optstring(L, 1, NULL);\n  lua_settop(L, 1);\n  if (l_unlikely(luaL_loadfile(L, fname) != LUA_OK))\n    return lua_error(L);\n  lua_callk(L, 0, LUA_MULTRET, 0, dofilecont);\n  return dofilecont(L, 0, 0);\n}\n\n\nstatic int luaB_assert (lua_State *L) {\n  if (l_likely(lua_toboolean(L, 1)))  /* condition is true? */\n    return lua_gettop(L);  /* return all arguments */\n  else {  /* error */\n    luaL_checkany(L, 1);  /* there must be a condition */\n    lua_remove(L, 1);  /* remove it */\n    lua_pushliteral(L, \"assertion failed!\");  /* default message */\n    lua_settop(L, 1);  /* leave only message (default if no other one) */\n    return luaB_error(L);  /* call 'error' */\n  }\n}\n\n\nstatic int luaB_select (lua_State *L) {\n  int n = lua_gettop(L);\n  if (lua_type(L, 1) == LUA_TSTRING && *lua_tostring(L, 1) == '#') {\n    lua_pushinteger(L, n-1);\n    return 1;\n  }\n  else {\n    lua_Integer i = luaL_checkinteger(L, 1);\n    if (i < 0) i = n + i;\n    else if (i > n) i = n;\n    luaL_argcheck(L, 1 <= i, 1, \"index out of range\");\n    return n - (int)i;\n  }\n}\n\n\n/*\n** Continuation function for 'pcall' and 'xpcall'. Both functions\n** already pushed a 'true' before doing the call, so in case of success\n** 'finishpcall' only has to return everything in the stack minus\n** 'extra' values (where 'extra' is exactly the number of items to be\n** ignored).\n*/\nstatic int finishpcall (lua_State *L, int status, lua_KContext extra) {\n  if (l_unlikely(status != LUA_OK && status != LUA_YIELD)) {  /* error? */\n    lua_pushboolean(L, 0);  /* first result (false) */\n    lua_pushvalue(L, -2);  /* error message */\n    return 2;  /* return false, msg */\n  }\n  else\n    return lua_gettop(L) - (int)extra;  /* return all results */\n}\n\n\nstatic int luaB_pcall (lua_State *L) {\n  int status;\n  luaL_checkany(L, 1);\n  lua_pushboolean(L, 1);  /* first result if no errors */\n  lua_insert(L, 1);  /* put it in place */\n  status = lua_pcallk(L, lua_gettop(L) - 2, LUA_MULTRET, 0, 0, finishpcall);\n  return finishpcall(L, status, 0);\n}\n\n\n/*\n** Do a protected call with error handling. After 'lua_rotate', the\n** stack will have <f, err, true, f, [args...]>; so, the function passes\n** 2 to 'finishpcall' to skip the 2 first values when returning results.\n*/\nstatic int luaB_xpcall (lua_State *L) {\n  int status;\n  int n = lua_gettop(L);\n  luaL_checktype(L, 2, LUA_TFUNCTION);  /* check error function */\n  lua_pushboolean(L, 1);  /* first result */\n  lua_pushvalue(L, 1);  /* function */\n  lua_rotate(L, 3, 2);  /* move them below function's arguments */\n  status = lua_pcallk(L, n - 2, LUA_MULTRET, 2, 2, finishpcall);\n  return finishpcall(L, status, 2);\n}\n\n\nstatic int luaB_tostring (lua_State *L) {\n  luaL_checkany(L, 1);\n  luaL_tolstring(L, 1, NULL);\n  return 1;\n}\n\n\nstatic const luaL_Reg base_funcs[] = {\n  {\"assert\", luaB_assert},\n  {\"collectgarbage\", luaB_collectgarbage},\n  {\"dofile\", luaB_dofile},\n  {\"error\", luaB_error},\n  {\"getmetatable\", luaB_getmetatable},\n  {\"ipairs\", luaB_ipairs},\n  {\"loadfile\", luaB_loadfile},\n  {\"load\", luaB_load},\n  {\"next\", luaB_next},\n  {\"pairs\", luaB_pairs},\n  {\"pcall\", luaB_pcall},\n  {\"print\", luaB_print},\n  {\"warn\", luaB_warn},\n  {\"rawequal\", luaB_rawequal},\n  {\"rawlen\", luaB_rawlen},\n  {\"rawget\", luaB_rawget},\n  {\"rawset\", luaB_rawset},\n  {\"select\", luaB_select},\n  {\"setmetatable\", luaB_setmetatable},\n  {\"tonumber\", luaB_tonumber},\n  {\"tostring\", luaB_tostring},\n  {\"type\", luaB_type},\n  {\"xpcall\", luaB_xpcall},\n  /* placeholders */\n  {LUA_GNAME, NULL},\n  {\"_VERSION\", NULL},\n  {NULL, NULL}\n};\n\n\nLUAMOD_API int luaopen_base (lua_State *L) {\n  /* open lib into global table */\n  lua_pushglobaltable(L);\n  luaL_setfuncs(L, base_funcs, 0);\n  /* set global _G */\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -2, LUA_GNAME);\n  /* set global _VERSION */\n  lua_pushliteral(L, LUA_VERSION);\n  lua_setfield(L, -2, \"_VERSION\");\n  return 1;\n}\n\n"
        },
        {
          "name": "lcode.c",
          "type": "blob",
          "size": 52.4228515625,
          "content": "/*\n** $Id: lcode.c $\n** Code generator for Lua\n** See Copyright Notice in lua.h\n*/\n\n#define lcode_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdlib.h>\n\n#include \"lua.h\"\n\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"llex.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lvm.h\"\n\n\n/* (note that expressions VJMP also have jumps.) */\n#define hasjumps(e)\t((e)->t != (e)->f)\n\n\nstatic int codesJ (FuncState *fs, OpCode o, int sj, int k);\n\n\n\n/* semantic error */\nl_noret luaK_semerror (LexState *ls, const char *msg) {\n  ls->t.token = 0;  /* remove \"near <token>\" from final message */\n  luaX_syntaxerror(ls, msg);\n}\n\n\n/*\n** If expression is a numeric constant, fills 'v' with its value\n** and returns 1. Otherwise, returns 0.\n*/\nstatic int tonumeral (const expdesc *e, TValue *v) {\n  if (hasjumps(e))\n    return 0;  /* not a numeral */\n  switch (e->k) {\n    case VKINT:\n      if (v) setivalue(v, e->u.ival);\n      return 1;\n    case VKFLT:\n      if (v) setfltvalue(v, e->u.nval);\n      return 1;\n    default: return 0;\n  }\n}\n\n\n/*\n** Get the constant value from a constant expression\n*/\nstatic TValue *const2val (FuncState *fs, const expdesc *e) {\n  lua_assert(e->k == VCONST);\n  return &fs->ls->dyd->actvar.arr[e->u.info].k;\n}\n\n\n/*\n** If expression is a constant, fills 'v' with its value\n** and returns 1. Otherwise, returns 0.\n*/\nint luaK_exp2const (FuncState *fs, const expdesc *e, TValue *v) {\n  if (hasjumps(e))\n    return 0;  /* not a constant */\n  switch (e->k) {\n    case VFALSE:\n      setbfvalue(v);\n      return 1;\n    case VTRUE:\n      setbtvalue(v);\n      return 1;\n    case VNIL:\n      setnilvalue(v);\n      return 1;\n    case VKSTR: {\n      setsvalue(fs->ls->L, v, e->u.strval);\n      return 1;\n    }\n    case VCONST: {\n      setobj(fs->ls->L, v, const2val(fs, e));\n      return 1;\n    }\n    default: return tonumeral(e, v);\n  }\n}\n\n\n/*\n** Return the previous instruction of the current code. If there\n** may be a jump target between the current instruction and the\n** previous one, return an invalid instruction (to avoid wrong\n** optimizations).\n*/\nstatic Instruction *previousinstruction (FuncState *fs) {\n  static const Instruction invalidinstruction = ~(Instruction)0;\n  if (fs->pc > fs->lasttarget)\n    return &fs->f->code[fs->pc - 1];  /* previous instruction */\n  else\n    return cast(Instruction*, &invalidinstruction);\n}\n\n\n/*\n** Create a OP_LOADNIL instruction, but try to optimize: if the previous\n** instruction is also OP_LOADNIL and ranges are compatible, adjust\n** range of previous instruction instead of emitting a new one. (For\n** instance, 'local a; local b' will generate a single opcode.)\n*/\nvoid luaK_nil (FuncState *fs, int from, int n) {\n  int l = from + n - 1;  /* last register to set nil */\n  Instruction *previous = previousinstruction(fs);\n  if (GET_OPCODE(*previous) == OP_LOADNIL) {  /* previous is LOADNIL? */\n    int pfrom = GETARG_A(*previous);  /* get previous range */\n    int pl = pfrom + GETARG_B(*previous);\n    if ((pfrom <= from && from <= pl + 1) ||\n        (from <= pfrom && pfrom <= l + 1)) {  /* can connect both? */\n      if (pfrom < from) from = pfrom;  /* from = min(from, pfrom) */\n      if (pl > l) l = pl;  /* l = max(l, pl) */\n      SETARG_A(*previous, from);\n      SETARG_B(*previous, l - from);\n      return;\n    }  /* else go through */\n  }\n  luaK_codeABC(fs, OP_LOADNIL, from, n - 1, 0);  /* else no optimization */\n}\n\n\n/*\n** Gets the destination address of a jump instruction. Used to traverse\n** a list of jumps.\n*/\nstatic int getjump (FuncState *fs, int pc) {\n  int offset = GETARG_sJ(fs->f->code[pc]);\n  if (offset == NO_JUMP)  /* point to itself represents end of list */\n    return NO_JUMP;  /* end of list */\n  else\n    return (pc+1)+offset;  /* turn offset into absolute position */\n}\n\n\n/*\n** Fix jump instruction at position 'pc' to jump to 'dest'.\n** (Jump addresses are relative in Lua)\n*/\nstatic void fixjump (FuncState *fs, int pc, int dest) {\n  Instruction *jmp = &fs->f->code[pc];\n  int offset = dest - (pc + 1);\n  lua_assert(dest != NO_JUMP);\n  if (!(-OFFSET_sJ <= offset && offset <= MAXARG_sJ - OFFSET_sJ))\n    luaX_syntaxerror(fs->ls, \"control structure too long\");\n  lua_assert(GET_OPCODE(*jmp) == OP_JMP);\n  SETARG_sJ(*jmp, offset);\n}\n\n\n/*\n** Concatenate jump-list 'l2' into jump-list 'l1'\n*/\nvoid luaK_concat (FuncState *fs, int *l1, int l2) {\n  if (l2 == NO_JUMP) return;  /* nothing to concatenate? */\n  else if (*l1 == NO_JUMP)  /* no original list? */\n    *l1 = l2;  /* 'l1' points to 'l2' */\n  else {\n    int list = *l1;\n    int next;\n    while ((next = getjump(fs, list)) != NO_JUMP)  /* find last element */\n      list = next;\n    fixjump(fs, list, l2);  /* last element links to 'l2' */\n  }\n}\n\n\n/*\n** Create a jump instruction and return its position, so its destination\n** can be fixed later (with 'fixjump').\n*/\nint luaK_jump (FuncState *fs) {\n  return codesJ(fs, OP_JMP, NO_JUMP, 0);\n}\n\n\n/*\n** Code a 'return' instruction\n*/\nvoid luaK_ret (FuncState *fs, int first, int nret) {\n  OpCode op;\n  switch (nret) {\n    case 0: op = OP_RETURN0; break;\n    case 1: op = OP_RETURN1; break;\n    default: op = OP_RETURN; break;\n  }\n  luaY_checklimit(fs, nret + 1, MAXARG_B, \"returns\");\n  luaK_codeABC(fs, op, first, nret + 1, 0);\n}\n\n\n/*\n** Code a \"conditional jump\", that is, a test or comparison opcode\n** followed by a jump. Return jump position.\n*/\nstatic int condjump (FuncState *fs, OpCode op, int A, int B, int C, int k) {\n  luaK_codeABCk(fs, op, A, B, C, k);\n  return luaK_jump(fs);\n}\n\n\n/*\n** returns current 'pc' and marks it as a jump target (to avoid wrong\n** optimizations with consecutive instructions not in the same basic block).\n*/\nint luaK_getlabel (FuncState *fs) {\n  fs->lasttarget = fs->pc;\n  return fs->pc;\n}\n\n\n/*\n** Returns the position of the instruction \"controlling\" a given\n** jump (that is, its condition), or the jump itself if it is\n** unconditional.\n*/\nstatic Instruction *getjumpcontrol (FuncState *fs, int pc) {\n  Instruction *pi = &fs->f->code[pc];\n  if (pc >= 1 && testTMode(GET_OPCODE(*(pi-1))))\n    return pi-1;\n  else\n    return pi;\n}\n\n\n/*\n** Patch destination register for a TESTSET instruction.\n** If instruction in position 'node' is not a TESTSET, return 0 (\"fails\").\n** Otherwise, if 'reg' is not 'NO_REG', set it as the destination\n** register. Otherwise, change instruction to a simple 'TEST' (produces\n** no register value)\n*/\nstatic int patchtestreg (FuncState *fs, int node, int reg) {\n  Instruction *i = getjumpcontrol(fs, node);\n  if (GET_OPCODE(*i) != OP_TESTSET)\n    return 0;  /* cannot patch other instructions */\n  if (reg != NO_REG && reg != GETARG_B(*i))\n    SETARG_A(*i, reg);\n  else {\n     /* no register to put value or register already has the value;\n        change instruction to simple test */\n    *i = CREATE_ABCk(OP_TEST, GETARG_B(*i), 0, 0, GETARG_k(*i));\n  }\n  return 1;\n}\n\n\n/*\n** Traverse a list of tests ensuring no one produces a value\n*/\nstatic void removevalues (FuncState *fs, int list) {\n  for (; list != NO_JUMP; list = getjump(fs, list))\n      patchtestreg(fs, list, NO_REG);\n}\n\n\n/*\n** Traverse a list of tests, patching their destination address and\n** registers: tests producing values jump to 'vtarget' (and put their\n** values in 'reg'), other tests jump to 'dtarget'.\n*/\nstatic void patchlistaux (FuncState *fs, int list, int vtarget, int reg,\n                          int dtarget) {\n  while (list != NO_JUMP) {\n    int next = getjump(fs, list);\n    if (patchtestreg(fs, list, reg))\n      fixjump(fs, list, vtarget);\n    else\n      fixjump(fs, list, dtarget);  /* jump to default target */\n    list = next;\n  }\n}\n\n\n/*\n** Path all jumps in 'list' to jump to 'target'.\n** (The assert means that we cannot fix a jump to a forward address\n** because we only know addresses once code is generated.)\n*/\nvoid luaK_patchlist (FuncState *fs, int list, int target) {\n  lua_assert(target <= fs->pc);\n  patchlistaux(fs, list, target, NO_REG, target);\n}\n\n\nvoid luaK_patchtohere (FuncState *fs, int list) {\n  int hr = luaK_getlabel(fs);  /* mark \"here\" as a jump target */\n  luaK_patchlist(fs, list, hr);\n}\n\n\n/* limit for difference between lines in relative line info. */\n#define LIMLINEDIFF\t0x80\n\n\n/*\n** Save line info for a new instruction. If difference from last line\n** does not fit in a byte, of after that many instructions, save a new\n** absolute line info; (in that case, the special value 'ABSLINEINFO'\n** in 'lineinfo' signals the existence of this absolute information.)\n** Otherwise, store the difference from last line in 'lineinfo'.\n*/\nstatic void savelineinfo (FuncState *fs, Proto *f, int line) {\n  int linedif = line - fs->previousline;\n  int pc = fs->pc - 1;  /* last instruction coded */\n  if (abs(linedif) >= LIMLINEDIFF || fs->iwthabs++ >= MAXIWTHABS) {\n    luaM_growvector(fs->ls->L, f->abslineinfo, fs->nabslineinfo,\n                    f->sizeabslineinfo, AbsLineInfo, INT_MAX, \"lines\");\n    f->abslineinfo[fs->nabslineinfo].pc = pc;\n    f->abslineinfo[fs->nabslineinfo++].line = line;\n    linedif = ABSLINEINFO;  /* signal that there is absolute information */\n    fs->iwthabs = 1;  /* restart counter */\n  }\n  luaM_growvector(fs->ls->L, f->lineinfo, pc, f->sizelineinfo, ls_byte,\n                  INT_MAX, \"opcodes\");\n  f->lineinfo[pc] = cast(ls_byte, linedif);\n  fs->previousline = line;  /* last line saved */\n}\n\n\n/*\n** Remove line information from the last instruction.\n** If line information for that instruction is absolute, set 'iwthabs'\n** above its max to force the new (replacing) instruction to have\n** absolute line info, too.\n*/\nstatic void removelastlineinfo (FuncState *fs) {\n  Proto *f = fs->f;\n  int pc = fs->pc - 1;  /* last instruction coded */\n  if (f->lineinfo[pc] != ABSLINEINFO) {  /* relative line info? */\n    fs->previousline -= f->lineinfo[pc];  /* correct last line saved */\n    fs->iwthabs--;  /* undo previous increment */\n  }\n  else {  /* absolute line information */\n    lua_assert(f->abslineinfo[fs->nabslineinfo - 1].pc == pc);\n    fs->nabslineinfo--;  /* remove it */\n    fs->iwthabs = MAXIWTHABS + 1;  /* force next line info to be absolute */\n  }\n}\n\n\n/*\n** Remove the last instruction created, correcting line information\n** accordingly.\n*/\nstatic void removelastinstruction (FuncState *fs) {\n  removelastlineinfo(fs);\n  fs->pc--;\n}\n\n\n/*\n** Emit instruction 'i', checking for array sizes and saving also its\n** line information. Return 'i' position.\n*/\nint luaK_code (FuncState *fs, Instruction i) {\n  Proto *f = fs->f;\n  /* put new instruction in code array */\n  luaM_growvector(fs->ls->L, f->code, fs->pc, f->sizecode, Instruction,\n                  INT_MAX, \"opcodes\");\n  f->code[fs->pc++] = i;\n  savelineinfo(fs, f, fs->ls->lastline);\n  return fs->pc - 1;  /* index of new instruction */\n}\n\n\n/*\n** Format and emit an 'iABC' instruction. (Assertions check consistency\n** of parameters versus opcode.)\n*/\nint luaK_codeABCk (FuncState *fs, OpCode o, int A, int B, int C, int k) {\n  lua_assert(getOpMode(o) == iABC);\n  lua_assert(A <= MAXARG_A && B <= MAXARG_B &&\n             C <= MAXARG_C && (k & ~1) == 0);\n  return luaK_code(fs, CREATE_ABCk(o, A, B, C, k));\n}\n\n\nint luaK_codevABCk (FuncState *fs, OpCode o, int A, int B, int C, int k) {\n  lua_assert(getOpMode(o) == ivABC);\n  lua_assert(A <= MAXARG_A && B <= MAXARG_vB &&\n             C <= MAXARG_vC && (k & ~1) == 0);\n  return luaK_code(fs, CREATE_vABCk(o, A, B, C, k));\n}\n\n\n/*\n** Format and emit an 'iABx' instruction.\n*/\nint luaK_codeABx (FuncState *fs, OpCode o, int A, int Bc) {\n  lua_assert(getOpMode(o) == iABx);\n  lua_assert(A <= MAXARG_A && Bc <= MAXARG_Bx);\n  return luaK_code(fs, CREATE_ABx(o, A, Bc));\n}\n\n\n/*\n** Format and emit an 'iAsBx' instruction.\n*/\nstatic int codeAsBx (FuncState *fs, OpCode o, int A, int Bc) {\n  int b = Bc + OFFSET_sBx;\n  lua_assert(getOpMode(o) == iAsBx);\n  lua_assert(A <= MAXARG_A && b <= MAXARG_Bx);\n  return luaK_code(fs, CREATE_ABx(o, A, b));\n}\n\n\n/*\n** Format and emit an 'isJ' instruction.\n*/\nstatic int codesJ (FuncState *fs, OpCode o, int sj, int k) {\n  int j = sj + OFFSET_sJ;\n  lua_assert(getOpMode(o) == isJ);\n  lua_assert(j <= MAXARG_sJ && (k & ~1) == 0);\n  return luaK_code(fs, CREATE_sJ(o, j, k));\n}\n\n\n/*\n** Emit an \"extra argument\" instruction (format 'iAx')\n*/\nstatic int codeextraarg (FuncState *fs, int A) {\n  lua_assert(A <= MAXARG_Ax);\n  return luaK_code(fs, CREATE_Ax(OP_EXTRAARG, A));\n}\n\n\n/*\n** Emit a \"load constant\" instruction, using either 'OP_LOADK'\n** (if constant index 'k' fits in 18 bits) or an 'OP_LOADKX'\n** instruction with \"extra argument\".\n*/\nstatic int luaK_codek (FuncState *fs, int reg, int k) {\n  if (k <= MAXARG_Bx)\n    return luaK_codeABx(fs, OP_LOADK, reg, k);\n  else {\n    int p = luaK_codeABx(fs, OP_LOADKX, reg, 0);\n    codeextraarg(fs, k);\n    return p;\n  }\n}\n\n\n/*\n** Check register-stack level, keeping track of its maximum size\n** in field 'maxstacksize'\n*/\nvoid luaK_checkstack (FuncState *fs, int n) {\n  int newstack = fs->freereg + n;\n  if (newstack > fs->f->maxstacksize) {\n    luaY_checklimit(fs, newstack, MAX_FSTACK, \"registers\");\n    fs->f->maxstacksize = cast_byte(newstack);\n  }\n}\n\n\n/*\n** Reserve 'n' registers in register stack\n*/\nvoid luaK_reserveregs (FuncState *fs, int n) {\n  luaK_checkstack(fs, n);\n  fs->freereg =  cast_byte(fs->freereg + n);\n}\n\n\n/*\n** Free register 'reg', if it is neither a constant index nor\n** a local variable.\n)\n*/\nstatic void freereg (FuncState *fs, int reg) {\n  if (reg >= luaY_nvarstack(fs)) {\n    fs->freereg--;\n    lua_assert(reg == fs->freereg);\n  }\n}\n\n\n/*\n** Free two registers in proper order\n*/\nstatic void freeregs (FuncState *fs, int r1, int r2) {\n  if (r1 > r2) {\n    freereg(fs, r1);\n    freereg(fs, r2);\n  }\n  else {\n    freereg(fs, r2);\n    freereg(fs, r1);\n  }\n}\n\n\n/*\n** Free register used by expression 'e' (if any)\n*/\nstatic void freeexp (FuncState *fs, expdesc *e) {\n  if (e->k == VNONRELOC)\n    freereg(fs, e->u.info);\n}\n\n\n/*\n** Free registers used by expressions 'e1' and 'e2' (if any) in proper\n** order.\n*/\nstatic void freeexps (FuncState *fs, expdesc *e1, expdesc *e2) {\n  int r1 = (e1->k == VNONRELOC) ? e1->u.info : -1;\n  int r2 = (e2->k == VNONRELOC) ? e2->u.info : -1;\n  freeregs(fs, r1, r2);\n}\n\n\n/*\n** Add constant 'v' to prototype's list of constants (field 'k').\n** Use scanner's table to cache position of constants in constant list\n** and try to reuse constants. Because some values should not be used\n** as keys (nil cannot be a key, integer keys can collapse with float\n** keys), the caller must provide a useful 'key' for indexing the cache.\n** Note that all functions share the same table, so entering or exiting\n** a function can make some indices wrong.\n*/\nstatic int addk (FuncState *fs, TValue *key, TValue *v) {\n  TValue val;\n  lua_State *L = fs->ls->L;\n  Proto *f = fs->f;\n  int tag = luaH_get(fs->ls->h, key, &val);  /* query scanner table */\n  int k, oldsize;\n  if (tag == LUA_VNUMINT) {  /* is there an index there? */\n    k = cast_int(ivalue(&val));\n    /* correct value? (warning: must distinguish floats from integers!) */\n    if (k < fs->nk && ttypetag(&f->k[k]) == ttypetag(v) &&\n                      luaV_rawequalobj(&f->k[k], v))\n      return k;  /* reuse index */\n  }\n  /* constant not found; create a new entry */\n  oldsize = f->sizek;\n  k = fs->nk;\n  /* numerical value does not need GC barrier;\n     table has no metatable, so it does not need to invalidate cache */\n  setivalue(&val, k);\n  luaH_set(L, fs->ls->h, key, &val);\n  luaM_growvector(L, f->k, k, f->sizek, TValue, MAXARG_Ax, \"constants\");\n  while (oldsize < f->sizek) setnilvalue(&f->k[oldsize++]);\n  setobj(L, &f->k[k], v);\n  fs->nk++;\n  luaC_barrier(L, f, v);\n  return k;\n}\n\n\n/*\n** Add a string to list of constants and return its index.\n*/\nstatic int stringK (FuncState *fs, TString *s) {\n  TValue o;\n  setsvalue(fs->ls->L, &o, s);\n  return addk(fs, &o, &o);  /* use string itself as key */\n}\n\n\n/*\n** Add an integer to list of constants and return its index.\n*/\nstatic int luaK_intK (FuncState *fs, lua_Integer n) {\n  TValue o;\n  setivalue(&o, n);\n  return addk(fs, &o, &o);  /* use integer itself as key */\n}\n\n/*\n** Add a float to list of constants and return its index. Floats\n** with integral values need a different key, to avoid collision\n** with actual integers. To that, we add to the number its smaller\n** power-of-two fraction that is still significant in its scale.\n** For doubles, that would be 1/2^52.\n** (This method is not bulletproof: there may be another float\n** with that value, and for floats larger than 2^53 the result is\n** still an integer. At worst, this only wastes an entry with\n** a duplicate.)\n*/\nstatic int luaK_numberK (FuncState *fs, lua_Number r) {\n  TValue o;\n  lua_Integer ik;\n  setfltvalue(&o, r);\n  if (!luaV_flttointeger(r, &ik, F2Ieq))  /* not an integral value? */\n    return addk(fs, &o, &o);  /* use number itself as key */\n  else {  /* must build an alternative key */\n    const int nbm = l_floatatt(MANT_DIG);\n    const lua_Number q = l_mathop(ldexp)(l_mathop(1.0), -nbm + 1);\n    const lua_Number k = (ik == 0) ? q : r + r*q;  /* new key */\n    TValue kv;\n    setfltvalue(&kv, k);\n    /* result is not an integral value, unless value is too large */\n    lua_assert(!luaV_flttointeger(k, &ik, F2Ieq) ||\n                l_mathop(fabs)(r) >= l_mathop(1e6));\n    return addk(fs, &kv, &o);\n  }\n}\n\n\n/*\n** Add a false to list of constants and return its index.\n*/\nstatic int boolF (FuncState *fs) {\n  TValue o;\n  setbfvalue(&o);\n  return addk(fs, &o, &o);  /* use boolean itself as key */\n}\n\n\n/*\n** Add a true to list of constants and return its index.\n*/\nstatic int boolT (FuncState *fs) {\n  TValue o;\n  setbtvalue(&o);\n  return addk(fs, &o, &o);  /* use boolean itself as key */\n}\n\n\n/*\n** Add nil to list of constants and return its index.\n*/\nstatic int nilK (FuncState *fs) {\n  TValue k, v;\n  setnilvalue(&v);\n  /* cannot use nil as key; instead use table itself to represent nil */\n  sethvalue(fs->ls->L, &k, fs->ls->h);\n  return addk(fs, &k, &v);\n}\n\n\n/*\n** Check whether 'i' can be stored in an 'sC' operand. Equivalent to\n** (0 <= int2sC(i) && int2sC(i) <= MAXARG_C) but without risk of\n** overflows in the hidden addition inside 'int2sC'.\n*/\nstatic int fitsC (lua_Integer i) {\n  return (l_castS2U(i) + OFFSET_sC <= cast_uint(MAXARG_C));\n}\n\n\n/*\n** Check whether 'i' can be stored in an 'sBx' operand.\n*/\nstatic int fitsBx (lua_Integer i) {\n  return (-OFFSET_sBx <= i && i <= MAXARG_Bx - OFFSET_sBx);\n}\n\n\nvoid luaK_int (FuncState *fs, int reg, lua_Integer i) {\n  if (fitsBx(i))\n    codeAsBx(fs, OP_LOADI, reg, cast_int(i));\n  else\n    luaK_codek(fs, reg, luaK_intK(fs, i));\n}\n\n\nstatic void luaK_float (FuncState *fs, int reg, lua_Number f) {\n  lua_Integer fi;\n  if (luaV_flttointeger(f, &fi, F2Ieq) && fitsBx(fi))\n    codeAsBx(fs, OP_LOADF, reg, cast_int(fi));\n  else\n    luaK_codek(fs, reg, luaK_numberK(fs, f));\n}\n\n\n/*\n** Convert a constant in 'v' into an expression description 'e'\n*/\nstatic void const2exp (TValue *v, expdesc *e) {\n  switch (ttypetag(v)) {\n    case LUA_VNUMINT:\n      e->k = VKINT; e->u.ival = ivalue(v);\n      break;\n    case LUA_VNUMFLT:\n      e->k = VKFLT; e->u.nval = fltvalue(v);\n      break;\n    case LUA_VFALSE:\n      e->k = VFALSE;\n      break;\n    case LUA_VTRUE:\n      e->k = VTRUE;\n      break;\n    case LUA_VNIL:\n      e->k = VNIL;\n      break;\n    case LUA_VSHRSTR:  case LUA_VLNGSTR:\n      e->k = VKSTR; e->u.strval = tsvalue(v);\n      break;\n    default: lua_assert(0);\n  }\n}\n\n\n/*\n** Fix an expression to return the number of results 'nresults'.\n** 'e' must be a multi-ret expression (function call or vararg).\n*/\nvoid luaK_setreturns (FuncState *fs, expdesc *e, int nresults) {\n  Instruction *pc = &getinstruction(fs, e);\n  luaY_checklimit(fs, nresults + 1, MAXARG_C, \"multiple results\");\n  if (e->k == VCALL)  /* expression is an open function call? */\n    SETARG_C(*pc, nresults + 1);\n  else {\n    lua_assert(e->k == VVARARG);\n    SETARG_C(*pc, nresults + 1);\n    SETARG_A(*pc, fs->freereg);\n    luaK_reserveregs(fs, 1);\n  }\n}\n\n\n/*\n** Convert a VKSTR to a VK\n*/\nstatic void str2K (FuncState *fs, expdesc *e) {\n  lua_assert(e->k == VKSTR);\n  e->u.info = stringK(fs, e->u.strval);\n  e->k = VK;\n}\n\n\n/*\n** Fix an expression to return one result.\n** If expression is not a multi-ret expression (function call or\n** vararg), it already returns one result, so nothing needs to be done.\n** Function calls become VNONRELOC expressions (as its result comes\n** fixed in the base register of the call), while vararg expressions\n** become VRELOC (as OP_VARARG puts its results where it wants).\n** (Calls are created returning one result, so that does not need\n** to be fixed.)\n*/\nvoid luaK_setoneret (FuncState *fs, expdesc *e) {\n  if (e->k == VCALL) {  /* expression is an open function call? */\n    /* already returns 1 value */\n    lua_assert(GETARG_C(getinstruction(fs, e)) == 2);\n    e->k = VNONRELOC;  /* result has fixed position */\n    e->u.info = GETARG_A(getinstruction(fs, e));\n  }\n  else if (e->k == VVARARG) {\n    SETARG_C(getinstruction(fs, e), 2);\n    e->k = VRELOC;  /* can relocate its simple result */\n  }\n}\n\n\n/*\n** Ensure that expression 'e' is not a variable (nor a <const>).\n** (Expression still may have jump lists.)\n*/\nvoid luaK_dischargevars (FuncState *fs, expdesc *e) {\n  switch (e->k) {\n    case VCONST: {\n      const2exp(const2val(fs, e), e);\n      break;\n    }\n    case VLOCAL: {  /* already in a register */\n      int temp = e->u.var.ridx;\n      e->u.info = temp;  /* (can't do a direct assignment; values overlap) */\n      e->k = VNONRELOC;  /* becomes a non-relocatable value */\n      break;\n    }\n    case VUPVAL: {  /* move value to some (pending) register */\n      e->u.info = luaK_codeABC(fs, OP_GETUPVAL, 0, e->u.info, 0);\n      e->k = VRELOC;\n      break;\n    }\n    case VINDEXUP: {\n      e->u.info = luaK_codeABC(fs, OP_GETTABUP, 0, e->u.ind.t, e->u.ind.idx);\n      e->k = VRELOC;\n      break;\n    }\n    case VINDEXI: {\n      freereg(fs, e->u.ind.t);\n      e->u.info = luaK_codeABC(fs, OP_GETI, 0, e->u.ind.t, e->u.ind.idx);\n      e->k = VRELOC;\n      break;\n    }\n    case VINDEXSTR: {\n      freereg(fs, e->u.ind.t);\n      e->u.info = luaK_codeABC(fs, OP_GETFIELD, 0, e->u.ind.t, e->u.ind.idx);\n      e->k = VRELOC;\n      break;\n    }\n    case VINDEXED: {\n      freeregs(fs, e->u.ind.t, e->u.ind.idx);\n      e->u.info = luaK_codeABC(fs, OP_GETTABLE, 0, e->u.ind.t, e->u.ind.idx);\n      e->k = VRELOC;\n      break;\n    }\n    case VVARARG: case VCALL: {\n      luaK_setoneret(fs, e);\n      break;\n    }\n    default: break;  /* there is one value available (somewhere) */\n  }\n}\n\n\n/*\n** Ensure expression value is in register 'reg', making 'e' a\n** non-relocatable expression.\n** (Expression still may have jump lists.)\n*/\nstatic void discharge2reg (FuncState *fs, expdesc *e, int reg) {\n  luaK_dischargevars(fs, e);\n  switch (e->k) {\n    case VNIL: {\n      luaK_nil(fs, reg, 1);\n      break;\n    }\n    case VFALSE: {\n      luaK_codeABC(fs, OP_LOADFALSE, reg, 0, 0);\n      break;\n    }\n    case VTRUE: {\n      luaK_codeABC(fs, OP_LOADTRUE, reg, 0, 0);\n      break;\n    }\n    case VKSTR: {\n      str2K(fs, e);\n    }  /* FALLTHROUGH */\n    case VK: {\n      luaK_codek(fs, reg, e->u.info);\n      break;\n    }\n    case VKFLT: {\n      luaK_float(fs, reg, e->u.nval);\n      break;\n    }\n    case VKINT: {\n      luaK_int(fs, reg, e->u.ival);\n      break;\n    }\n    case VRELOC: {\n      Instruction *pc = &getinstruction(fs, e);\n      SETARG_A(*pc, reg);  /* instruction will put result in 'reg' */\n      break;\n    }\n    case VNONRELOC: {\n      if (reg != e->u.info)\n        luaK_codeABC(fs, OP_MOVE, reg, e->u.info, 0);\n      break;\n    }\n    default: {\n      lua_assert(e->k == VJMP);\n      return;  /* nothing to do... */\n    }\n  }\n  e->u.info = reg;\n  e->k = VNONRELOC;\n}\n\n\n/*\n** Ensure expression value is in a register, making 'e' a\n** non-relocatable expression.\n** (Expression still may have jump lists.)\n*/\nstatic void discharge2anyreg (FuncState *fs, expdesc *e) {\n  if (e->k != VNONRELOC) {  /* no fixed register yet? */\n    luaK_reserveregs(fs, 1);  /* get a register */\n    discharge2reg(fs, e, fs->freereg-1);  /* put value there */\n  }\n}\n\n\nstatic int code_loadbool (FuncState *fs, int A, OpCode op) {\n  luaK_getlabel(fs);  /* those instructions may be jump targets */\n  return luaK_codeABC(fs, op, A, 0, 0);\n}\n\n\n/*\n** check whether list has any jump that do not produce a value\n** or produce an inverted value\n*/\nstatic int need_value (FuncState *fs, int list) {\n  for (; list != NO_JUMP; list = getjump(fs, list)) {\n    Instruction i = *getjumpcontrol(fs, list);\n    if (GET_OPCODE(i) != OP_TESTSET) return 1;\n  }\n  return 0;  /* not found */\n}\n\n\n/*\n** Ensures final expression result (which includes results from its\n** jump lists) is in register 'reg'.\n** If expression has jumps, need to patch these jumps either to\n** its final position or to \"load\" instructions (for those tests\n** that do not produce values).\n*/\nstatic void exp2reg (FuncState *fs, expdesc *e, int reg) {\n  discharge2reg(fs, e, reg);\n  if (e->k == VJMP)  /* expression itself is a test? */\n    luaK_concat(fs, &e->t, e->u.info);  /* put this jump in 't' list */\n  if (hasjumps(e)) {\n    int final;  /* position after whole expression */\n    int p_f = NO_JUMP;  /* position of an eventual LOAD false */\n    int p_t = NO_JUMP;  /* position of an eventual LOAD true */\n    if (need_value(fs, e->t) || need_value(fs, e->f)) {\n      int fj = (e->k == VJMP) ? NO_JUMP : luaK_jump(fs);\n      p_f = code_loadbool(fs, reg, OP_LFALSESKIP);  /* skip next inst. */\n      p_t = code_loadbool(fs, reg, OP_LOADTRUE);\n      /* jump around these booleans if 'e' is not a test */\n      luaK_patchtohere(fs, fj);\n    }\n    final = luaK_getlabel(fs);\n    patchlistaux(fs, e->f, final, reg, p_f);\n    patchlistaux(fs, e->t, final, reg, p_t);\n  }\n  e->f = e->t = NO_JUMP;\n  e->u.info = reg;\n  e->k = VNONRELOC;\n}\n\n\n/*\n** Ensures final expression result is in next available register.\n*/\nvoid luaK_exp2nextreg (FuncState *fs, expdesc *e) {\n  luaK_dischargevars(fs, e);\n  freeexp(fs, e);\n  luaK_reserveregs(fs, 1);\n  exp2reg(fs, e, fs->freereg - 1);\n}\n\n\n/*\n** Ensures final expression result is in some (any) register\n** and return that register.\n*/\nint luaK_exp2anyreg (FuncState *fs, expdesc *e) {\n  luaK_dischargevars(fs, e);\n  if (e->k == VNONRELOC) {  /* expression already has a register? */\n    if (!hasjumps(e))  /* no jumps? */\n      return e->u.info;  /* result is already in a register */\n    if (e->u.info >= luaY_nvarstack(fs)) {  /* reg. is not a local? */\n      exp2reg(fs, e, e->u.info);  /* put final result in it */\n      return e->u.info;\n    }\n    /* else expression has jumps and cannot change its register\n       to hold the jump values, because it is a local variable.\n       Go through to the default case. */\n  }\n  luaK_exp2nextreg(fs, e);  /* default: use next available register */\n  return e->u.info;\n}\n\n\n/*\n** Ensures final expression result is either in a register\n** or in an upvalue.\n*/\nvoid luaK_exp2anyregup (FuncState *fs, expdesc *e) {\n  if (e->k != VUPVAL || hasjumps(e))\n    luaK_exp2anyreg(fs, e);\n}\n\n\n/*\n** Ensures final expression result is either in a register\n** or it is a constant.\n*/\nvoid luaK_exp2val (FuncState *fs, expdesc *e) {\n  if (e->k == VJMP || hasjumps(e))\n    luaK_exp2anyreg(fs, e);\n  else\n    luaK_dischargevars(fs, e);\n}\n\n\n/*\n** Try to make 'e' a K expression with an index in the range of R/K\n** indices. Return true iff succeeded.\n*/\nstatic int luaK_exp2K (FuncState *fs, expdesc *e) {\n  if (!hasjumps(e)) {\n    int info;\n    switch (e->k) {  /* move constants to 'k' */\n      case VTRUE: info = boolT(fs); break;\n      case VFALSE: info = boolF(fs); break;\n      case VNIL: info = nilK(fs); break;\n      case VKINT: info = luaK_intK(fs, e->u.ival); break;\n      case VKFLT: info = luaK_numberK(fs, e->u.nval); break;\n      case VKSTR: info = stringK(fs, e->u.strval); break;\n      case VK: info = e->u.info; break;\n      default: return 0;  /* not a constant */\n    }\n    if (info <= MAXINDEXRK) {  /* does constant fit in 'argC'? */\n      e->k = VK;  /* make expression a 'K' expression */\n      e->u.info = info;\n      return 1;\n    }\n  }\n  /* else, expression doesn't fit; leave it unchanged */\n  return 0;\n}\n\n\n/*\n** Ensures final expression result is in a valid R/K index\n** (that is, it is either in a register or in 'k' with an index\n** in the range of R/K indices).\n** Returns 1 iff expression is K.\n*/\nstatic int exp2RK (FuncState *fs, expdesc *e) {\n  if (luaK_exp2K(fs, e))\n    return 1;\n  else {  /* not a constant in the right range: put it in a register */\n    luaK_exp2anyreg(fs, e);\n    return 0;\n  }\n}\n\n\nstatic void codeABRK (FuncState *fs, OpCode o, int A, int B,\n                      expdesc *ec) {\n  int k = exp2RK(fs, ec);\n  luaK_codeABCk(fs, o, A, B, ec->u.info, k);\n}\n\n\n/*\n** Generate code to store result of expression 'ex' into variable 'var'.\n*/\nvoid luaK_storevar (FuncState *fs, expdesc *var, expdesc *ex) {\n  switch (var->k) {\n    case VLOCAL: {\n      freeexp(fs, ex);\n      exp2reg(fs, ex, var->u.var.ridx);  /* compute 'ex' into proper place */\n      return;\n    }\n    case VUPVAL: {\n      int e = luaK_exp2anyreg(fs, ex);\n      luaK_codeABC(fs, OP_SETUPVAL, e, var->u.info, 0);\n      break;\n    }\n    case VINDEXUP: {\n      codeABRK(fs, OP_SETTABUP, var->u.ind.t, var->u.ind.idx, ex);\n      break;\n    }\n    case VINDEXI: {\n      codeABRK(fs, OP_SETI, var->u.ind.t, var->u.ind.idx, ex);\n      break;\n    }\n    case VINDEXSTR: {\n      codeABRK(fs, OP_SETFIELD, var->u.ind.t, var->u.ind.idx, ex);\n      break;\n    }\n    case VINDEXED: {\n      codeABRK(fs, OP_SETTABLE, var->u.ind.t, var->u.ind.idx, ex);\n      break;\n    }\n    default: lua_assert(0);  /* invalid var kind to store */\n  }\n  freeexp(fs, ex);\n}\n\n\n/*\n** Emit SELF instruction (convert expression 'e' into 'e:key(e,').\n*/\nvoid luaK_self (FuncState *fs, expdesc *e, expdesc *key) {\n  int ereg;\n  luaK_exp2anyreg(fs, e);\n  ereg = e->u.info;  /* register where 'e' was placed */\n  freeexp(fs, e);\n  e->u.info = fs->freereg;  /* base register for op_self */\n  e->k = VNONRELOC;  /* self expression has a fixed register */\n  luaK_reserveregs(fs, 2);  /* function and 'self' produced by op_self */\n  codeABRK(fs, OP_SELF, e->u.info, ereg, key);\n  freeexp(fs, key);\n}\n\n\n/*\n** Negate condition 'e' (where 'e' is a comparison).\n*/\nstatic void negatecondition (FuncState *fs, expdesc *e) {\n  Instruction *pc = getjumpcontrol(fs, e->u.info);\n  lua_assert(testTMode(GET_OPCODE(*pc)) && GET_OPCODE(*pc) != OP_TESTSET &&\n                                           GET_OPCODE(*pc) != OP_TEST);\n  SETARG_k(*pc, (GETARG_k(*pc) ^ 1));\n}\n\n\n/*\n** Emit instruction to jump if 'e' is 'cond' (that is, if 'cond'\n** is true, code will jump if 'e' is true.) Return jump position.\n** Optimize when 'e' is 'not' something, inverting the condition\n** and removing the 'not'.\n*/\nstatic int jumponcond (FuncState *fs, expdesc *e, int cond) {\n  if (e->k == VRELOC) {\n    Instruction ie = getinstruction(fs, e);\n    if (GET_OPCODE(ie) == OP_NOT) {\n      removelastinstruction(fs);  /* remove previous OP_NOT */\n      return condjump(fs, OP_TEST, GETARG_B(ie), 0, 0, !cond);\n    }\n    /* else go through */\n  }\n  discharge2anyreg(fs, e);\n  freeexp(fs, e);\n  return condjump(fs, OP_TESTSET, NO_REG, e->u.info, 0, cond);\n}\n\n\n/*\n** Emit code to go through if 'e' is true, jump otherwise.\n*/\nvoid luaK_goiftrue (FuncState *fs, expdesc *e) {\n  int pc;  /* pc of new jump */\n  luaK_dischargevars(fs, e);\n  switch (e->k) {\n    case VJMP: {  /* condition? */\n      negatecondition(fs, e);  /* jump when it is false */\n      pc = e->u.info;  /* save jump position */\n      break;\n    }\n    case VK: case VKFLT: case VKINT: case VKSTR: case VTRUE: {\n      pc = NO_JUMP;  /* always true; do nothing */\n      break;\n    }\n    default: {\n      pc = jumponcond(fs, e, 0);  /* jump when false */\n      break;\n    }\n  }\n  luaK_concat(fs, &e->f, pc);  /* insert new jump in false list */\n  luaK_patchtohere(fs, e->t);  /* true list jumps to here (to go through) */\n  e->t = NO_JUMP;\n}\n\n\n/*\n** Emit code to go through if 'e' is false, jump otherwise.\n*/\nvoid luaK_goiffalse (FuncState *fs, expdesc *e) {\n  int pc;  /* pc of new jump */\n  luaK_dischargevars(fs, e);\n  switch (e->k) {\n    case VJMP: {\n      pc = e->u.info;  /* already jump if true */\n      break;\n    }\n    case VNIL: case VFALSE: {\n      pc = NO_JUMP;  /* always false; do nothing */\n      break;\n    }\n    default: {\n      pc = jumponcond(fs, e, 1);  /* jump if true */\n      break;\n    }\n  }\n  luaK_concat(fs, &e->t, pc);  /* insert new jump in 't' list */\n  luaK_patchtohere(fs, e->f);  /* false list jumps to here (to go through) */\n  e->f = NO_JUMP;\n}\n\n\n/*\n** Code 'not e', doing constant folding.\n*/\nstatic void codenot (FuncState *fs, expdesc *e) {\n  switch (e->k) {\n    case VNIL: case VFALSE: {\n      e->k = VTRUE;  /* true == not nil == not false */\n      break;\n    }\n    case VK: case VKFLT: case VKINT: case VKSTR: case VTRUE: {\n      e->k = VFALSE;  /* false == not \"x\" == not 0.5 == not 1 == not true */\n      break;\n    }\n    case VJMP: {\n      negatecondition(fs, e);\n      break;\n    }\n    case VRELOC:\n    case VNONRELOC: {\n      discharge2anyreg(fs, e);\n      freeexp(fs, e);\n      e->u.info = luaK_codeABC(fs, OP_NOT, 0, e->u.info, 0);\n      e->k = VRELOC;\n      break;\n    }\n    default: lua_assert(0);  /* cannot happen */\n  }\n  /* interchange true and false lists */\n  { int temp = e->f; e->f = e->t; e->t = temp; }\n  removevalues(fs, e->f);  /* values are useless when negated */\n  removevalues(fs, e->t);\n}\n\n\n/*\n** Check whether expression 'e' is a short literal string\n*/\nstatic int isKstr (FuncState *fs, expdesc *e) {\n  return (e->k == VK && !hasjumps(e) && e->u.info <= MAXARG_B &&\n          ttisshrstring(&fs->f->k[e->u.info]));\n}\n\n/*\n** Check whether expression 'e' is a literal integer.\n*/\nstatic int isKint (expdesc *e) {\n  return (e->k == VKINT && !hasjumps(e));\n}\n\n\n/*\n** Check whether expression 'e' is a literal integer in\n** proper range to fit in register C\n*/\nstatic int isCint (expdesc *e) {\n  return isKint(e) && (l_castS2U(e->u.ival) <= l_castS2U(MAXARG_C));\n}\n\n\n/*\n** Check whether expression 'e' is a literal integer in\n** proper range to fit in register sC\n*/\nstatic int isSCint (expdesc *e) {\n  return isKint(e) && fitsC(e->u.ival);\n}\n\n\n/*\n** Check whether expression 'e' is a literal integer or float in\n** proper range to fit in a register (sB or sC).\n*/\nstatic int isSCnumber (expdesc *e, int *pi, int *isfloat) {\n  lua_Integer i;\n  if (e->k == VKINT)\n    i = e->u.ival;\n  else if (e->k == VKFLT && luaV_flttointeger(e->u.nval, &i, F2Ieq))\n    *isfloat = 1;\n  else\n    return 0;  /* not a number */\n  if (!hasjumps(e) && fitsC(i)) {\n    *pi = int2sC(cast_int(i));\n    return 1;\n  }\n  else\n    return 0;\n}\n\n\n/*\n** Create expression 't[k]'. 't' must have its final result already in a\n** register or upvalue. Upvalues can only be indexed by literal strings.\n** Keys can be literal strings in the constant table or arbitrary\n** values in registers.\n*/\nvoid luaK_indexed (FuncState *fs, expdesc *t, expdesc *k) {\n  if (k->k == VKSTR)\n    str2K(fs, k);\n  lua_assert(!hasjumps(t) &&\n             (t->k == VLOCAL || t->k == VNONRELOC || t->k == VUPVAL));\n  if (t->k == VUPVAL && !isKstr(fs, k))  /* upvalue indexed by non 'Kstr'? */\n    luaK_exp2anyreg(fs, t);  /* put it in a register */\n  if (t->k == VUPVAL) {\n    lu_byte temp = cast_byte(t->u.info);  /* upvalue index */\n    lua_assert(isKstr(fs, k));\n    t->u.ind.t = temp;  /* (can't do a direct assignment; values overlap) */\n    t->u.ind.idx = cast(short, k->u.info);  /* literal short string */\n    t->k = VINDEXUP;\n  }\n  else {\n    /* register index of the table */\n    t->u.ind.t = cast_byte((t->k == VLOCAL) ? t->u.var.ridx: t->u.info);\n    if (isKstr(fs, k)) {\n      t->u.ind.idx = cast(short, k->u.info);  /* literal short string */\n      t->k = VINDEXSTR;\n    }\n    else if (isCint(k)) {  /* int. constant in proper range? */\n      t->u.ind.idx = cast(short, k->u.ival);\n      t->k = VINDEXI;\n    }\n    else {\n      t->u.ind.idx = cast(short, luaK_exp2anyreg(fs, k));  /* register */\n      t->k = VINDEXED;\n    }\n  }\n}\n\n\n/*\n** Return false if folding can raise an error.\n** Bitwise operations need operands convertible to integers; division\n** operations cannot have 0 as divisor.\n*/\nstatic int validop (int op, TValue *v1, TValue *v2) {\n  switch (op) {\n    case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:\n    case LUA_OPSHL: case LUA_OPSHR: case LUA_OPBNOT: {  /* conversion errors */\n      lua_Integer i;\n      return (luaV_tointegerns(v1, &i, LUA_FLOORN2I) &&\n              luaV_tointegerns(v2, &i, LUA_FLOORN2I));\n    }\n    case LUA_OPDIV: case LUA_OPIDIV: case LUA_OPMOD:  /* division by 0 */\n      return (nvalue(v2) != 0);\n    default: return 1;  /* everything else is valid */\n  }\n}\n\n\n/*\n** Try to \"constant-fold\" an operation; return 1 iff successful.\n** (In this case, 'e1' has the final result.)\n*/\nstatic int constfolding (FuncState *fs, int op, expdesc *e1,\n                                        const expdesc *e2) {\n  TValue v1, v2, res;\n  if (!tonumeral(e1, &v1) || !tonumeral(e2, &v2) || !validop(op, &v1, &v2))\n    return 0;  /* non-numeric operands or not safe to fold */\n  luaO_rawarith(fs->ls->L, op, &v1, &v2, &res);  /* does operation */\n  if (ttisinteger(&res)) {\n    e1->k = VKINT;\n    e1->u.ival = ivalue(&res);\n  }\n  else {  /* folds neither NaN nor 0.0 (to avoid problems with -0.0) */\n    lua_Number n = fltvalue(&res);\n    if (luai_numisnan(n) || n == 0)\n      return 0;\n    e1->k = VKFLT;\n    e1->u.nval = n;\n  }\n  return 1;\n}\n\n\n/*\n** Convert a BinOpr to an OpCode  (ORDER OPR - ORDER OP)\n*/\nl_sinline OpCode binopr2op (BinOpr opr, BinOpr baser, OpCode base) {\n  lua_assert(baser <= opr &&\n            ((baser == OPR_ADD && opr <= OPR_SHR) ||\n             (baser == OPR_LT && opr <= OPR_LE)));\n  return cast(OpCode, (cast_int(opr) - cast_int(baser)) + cast_int(base));\n}\n\n\n/*\n** Convert a UnOpr to an OpCode  (ORDER OPR - ORDER OP)\n*/\nl_sinline OpCode unopr2op (UnOpr opr) {\n  return cast(OpCode, (cast_int(opr) - cast_int(OPR_MINUS)) +\n                                       cast_int(OP_UNM));\n}\n\n\n/*\n** Convert a BinOpr to a tag method  (ORDER OPR - ORDER TM)\n*/\nl_sinline TMS binopr2TM (BinOpr opr) {\n  lua_assert(OPR_ADD <= opr && opr <= OPR_SHR);\n  return cast(TMS, (cast_int(opr) - cast_int(OPR_ADD)) + cast_int(TM_ADD));\n}\n\n\n/*\n** Emit code for unary expressions that \"produce values\"\n** (everything but 'not').\n** Expression to produce final result will be encoded in 'e'.\n*/\nstatic void codeunexpval (FuncState *fs, OpCode op, expdesc *e, int line) {\n  int r = luaK_exp2anyreg(fs, e);  /* opcodes operate only on registers */\n  freeexp(fs, e);\n  e->u.info = luaK_codeABC(fs, op, 0, r, 0);  /* generate opcode */\n  e->k = VRELOC;  /* all those operations are relocatable */\n  luaK_fixline(fs, line);\n}\n\n\n/*\n** Emit code for binary expressions that \"produce values\"\n** (everything but logical operators 'and'/'or' and comparison\n** operators).\n** Expression to produce final result will be encoded in 'e1'.\n*/\nstatic void finishbinexpval (FuncState *fs, expdesc *e1, expdesc *e2,\n                             OpCode op, int v2, int flip, int line,\n                             OpCode mmop, TMS event) {\n  int v1 = luaK_exp2anyreg(fs, e1);\n  int pc = luaK_codeABCk(fs, op, 0, v1, v2, 0);\n  freeexps(fs, e1, e2);\n  e1->u.info = pc;\n  e1->k = VRELOC;  /* all those operations are relocatable */\n  luaK_fixline(fs, line);\n  luaK_codeABCk(fs, mmop, v1, v2, event, flip);  /* to call metamethod */\n  luaK_fixline(fs, line);\n}\n\n\n/*\n** Emit code for binary expressions that \"produce values\" over\n** two registers.\n*/\nstatic void codebinexpval (FuncState *fs, BinOpr opr,\n                           expdesc *e1, expdesc *e2, int line) {\n  OpCode op = binopr2op(opr, OPR_ADD, OP_ADD);\n  int v2 = luaK_exp2anyreg(fs, e2);  /* make sure 'e2' is in a register */\n  /* 'e1' must be already in a register or it is a constant */\n  lua_assert((VNIL <= e1->k && e1->k <= VKSTR) ||\n             e1->k == VNONRELOC || e1->k == VRELOC);\n  lua_assert(OP_ADD <= op && op <= OP_SHR);\n  finishbinexpval(fs, e1, e2, op, v2, 0, line, OP_MMBIN, binopr2TM(opr));\n}\n\n\n/*\n** Code binary operators with immediate operands.\n*/\nstatic void codebini (FuncState *fs, OpCode op,\n                       expdesc *e1, expdesc *e2, int flip, int line,\n                       TMS event) {\n  int v2 = int2sC(cast_int(e2->u.ival));  /* immediate operand */\n  lua_assert(e2->k == VKINT);\n  finishbinexpval(fs, e1, e2, op, v2, flip, line, OP_MMBINI, event);\n}\n\n\n/*\n** Code binary operators with K operand.\n*/\nstatic void codebinK (FuncState *fs, BinOpr opr,\n                      expdesc *e1, expdesc *e2, int flip, int line) {\n  TMS event = binopr2TM(opr);\n  int v2 = e2->u.info;  /* K index */\n  OpCode op = binopr2op(opr, OPR_ADD, OP_ADDK);\n  finishbinexpval(fs, e1, e2, op, v2, flip, line, OP_MMBINK, event);\n}\n\n\n/* Try to code a binary operator negating its second operand.\n** For the metamethod, 2nd operand must keep its original value.\n*/\nstatic int finishbinexpneg (FuncState *fs, expdesc *e1, expdesc *e2,\n                             OpCode op, int line, TMS event) {\n  if (!isKint(e2))\n    return 0;  /* not an integer constant */\n  else {\n    lua_Integer i2 = e2->u.ival;\n    if (!(fitsC(i2) && fitsC(-i2)))\n      return 0;  /* not in the proper range */\n    else {  /* operating a small integer constant */\n      int v2 = cast_int(i2);\n      finishbinexpval(fs, e1, e2, op, int2sC(-v2), 0, line, OP_MMBINI, event);\n      /* correct metamethod argument */\n      SETARG_B(fs->f->code[fs->pc - 1], int2sC(v2));\n      return 1;  /* successfully coded */\n    }\n  }\n}\n\n\nstatic void swapexps (expdesc *e1, expdesc *e2) {\n  expdesc temp = *e1; *e1 = *e2; *e2 = temp;  /* swap 'e1' and 'e2' */\n}\n\n\n/*\n** Code binary operators with no constant operand.\n*/\nstatic void codebinNoK (FuncState *fs, BinOpr opr,\n                        expdesc *e1, expdesc *e2, int flip, int line) {\n  if (flip)\n    swapexps(e1, e2);  /* back to original order */\n  codebinexpval(fs, opr, e1, e2, line);  /* use standard operators */\n}\n\n\n/*\n** Code arithmetic operators ('+', '-', ...). If second operand is a\n** constant in the proper range, use variant opcodes with K operands.\n*/\nstatic void codearith (FuncState *fs, BinOpr opr,\n                       expdesc *e1, expdesc *e2, int flip, int line) {\n  if (tonumeral(e2, NULL) && luaK_exp2K(fs, e2))  /* K operand? */\n    codebinK(fs, opr, e1, e2, flip, line);\n  else  /* 'e2' is neither an immediate nor a K operand */\n    codebinNoK(fs, opr, e1, e2, flip, line);\n}\n\n\n/*\n** Code commutative operators ('+', '*'). If first operand is a\n** numeric constant, change order of operands to try to use an\n** immediate or K operator.\n*/\nstatic void codecommutative (FuncState *fs, BinOpr op,\n                             expdesc *e1, expdesc *e2, int line) {\n  int flip = 0;\n  if (tonumeral(e1, NULL)) {  /* is first operand a numeric constant? */\n    swapexps(e1, e2);  /* change order */\n    flip = 1;\n  }\n  if (op == OPR_ADD && isSCint(e2))  /* immediate operand? */\n    codebini(fs, OP_ADDI, e1, e2, flip, line, TM_ADD);\n  else\n    codearith(fs, op, e1, e2, flip, line);\n}\n\n\n/*\n** Code bitwise operations; they are all commutative, so the function\n** tries to put an integer constant as the 2nd operand (a K operand).\n*/\nstatic void codebitwise (FuncState *fs, BinOpr opr,\n                         expdesc *e1, expdesc *e2, int line) {\n  int flip = 0;\n  if (e1->k == VKINT) {\n    swapexps(e1, e2);  /* 'e2' will be the constant operand */\n    flip = 1;\n  }\n  if (e2->k == VKINT && luaK_exp2K(fs, e2))  /* K operand? */\n    codebinK(fs, opr, e1, e2, flip, line);\n  else  /* no constants */\n    codebinNoK(fs, opr, e1, e2, flip, line);\n}\n\n\n/*\n** Emit code for order comparisons. When using an immediate operand,\n** 'isfloat' tells whether the original value was a float.\n*/\nstatic void codeorder (FuncState *fs, BinOpr opr, expdesc *e1, expdesc *e2) {\n  int r1, r2;\n  int im;\n  int isfloat = 0;\n  OpCode op;\n  if (isSCnumber(e2, &im, &isfloat)) {\n    /* use immediate operand */\n    r1 = luaK_exp2anyreg(fs, e1);\n    r2 = im;\n    op = binopr2op(opr, OPR_LT, OP_LTI);\n  }\n  else if (isSCnumber(e1, &im, &isfloat)) {\n    /* transform (A < B) to (B > A) and (A <= B) to (B >= A) */\n    r1 = luaK_exp2anyreg(fs, e2);\n    r2 = im;\n    op = binopr2op(opr, OPR_LT, OP_GTI);\n  }\n  else {  /* regular case, compare two registers */\n    r1 = luaK_exp2anyreg(fs, e1);\n    r2 = luaK_exp2anyreg(fs, e2);\n    op = binopr2op(opr, OPR_LT, OP_LT);\n  }\n  freeexps(fs, e1, e2);\n  e1->u.info = condjump(fs, op, r1, r2, isfloat, 1);\n  e1->k = VJMP;\n}\n\n\n/*\n** Emit code for equality comparisons ('==', '~=').\n** 'e1' was already put as RK by 'luaK_infix'.\n*/\nstatic void codeeq (FuncState *fs, BinOpr opr, expdesc *e1, expdesc *e2) {\n  int r1, r2;\n  int im;\n  int isfloat = 0;  /* not needed here, but kept for symmetry */\n  OpCode op;\n  if (e1->k != VNONRELOC) {\n    lua_assert(e1->k == VK || e1->k == VKINT || e1->k == VKFLT);\n    swapexps(e1, e2);\n  }\n  r1 = luaK_exp2anyreg(fs, e1);  /* 1st expression must be in register */\n  if (isSCnumber(e2, &im, &isfloat)) {\n    op = OP_EQI;\n    r2 = im;  /* immediate operand */\n  }\n  else if (exp2RK(fs, e2)) {  /* 2nd expression is constant? */\n    op = OP_EQK;\n    r2 = e2->u.info;  /* constant index */\n  }\n  else {\n    op = OP_EQ;  /* will compare two registers */\n    r2 = luaK_exp2anyreg(fs, e2);\n  }\n  freeexps(fs, e1, e2);\n  e1->u.info = condjump(fs, op, r1, r2, isfloat, (opr == OPR_EQ));\n  e1->k = VJMP;\n}\n\n\n/*\n** Apply prefix operation 'op' to expression 'e'.\n*/\nvoid luaK_prefix (FuncState *fs, UnOpr opr, expdesc *e, int line) {\n  static const expdesc ef = {VKINT, {0}, NO_JUMP, NO_JUMP};\n  luaK_dischargevars(fs, e);\n  switch (opr) {\n    case OPR_MINUS: case OPR_BNOT:  /* use 'ef' as fake 2nd operand */\n      if (constfolding(fs, cast_int(opr + LUA_OPUNM), e, &ef))\n        break;\n      /* else */ /* FALLTHROUGH */\n    case OPR_LEN:\n      codeunexpval(fs, unopr2op(opr), e, line);\n      break;\n    case OPR_NOT: codenot(fs, e); break;\n    default: lua_assert(0);\n  }\n}\n\n\n/*\n** Process 1st operand 'v' of binary operation 'op' before reading\n** 2nd operand.\n*/\nvoid luaK_infix (FuncState *fs, BinOpr op, expdesc *v) {\n  luaK_dischargevars(fs, v);\n  switch (op) {\n    case OPR_AND: {\n      luaK_goiftrue(fs, v);  /* go ahead only if 'v' is true */\n      break;\n    }\n    case OPR_OR: {\n      luaK_goiffalse(fs, v);  /* go ahead only if 'v' is false */\n      break;\n    }\n    case OPR_CONCAT: {\n      luaK_exp2nextreg(fs, v);  /* operand must be on the stack */\n      break;\n    }\n    case OPR_ADD: case OPR_SUB:\n    case OPR_MUL: case OPR_DIV: case OPR_IDIV:\n    case OPR_MOD: case OPR_POW:\n    case OPR_BAND: case OPR_BOR: case OPR_BXOR:\n    case OPR_SHL: case OPR_SHR: {\n      if (!tonumeral(v, NULL))\n        luaK_exp2anyreg(fs, v);\n      /* else keep numeral, which may be folded or used as an immediate\n         operand */\n      break;\n    }\n    case OPR_EQ: case OPR_NE: {\n      if (!tonumeral(v, NULL))\n        exp2RK(fs, v);\n      /* else keep numeral, which may be an immediate operand */\n      break;\n    }\n    case OPR_LT: case OPR_LE:\n    case OPR_GT: case OPR_GE: {\n      int dummy, dummy2;\n      if (!isSCnumber(v, &dummy, &dummy2))\n        luaK_exp2anyreg(fs, v);\n      /* else keep numeral, which may be an immediate operand */\n      break;\n    }\n    default: lua_assert(0);\n  }\n}\n\n/*\n** Create code for '(e1 .. e2)'.\n** For '(e1 .. e2.1 .. e2.2)' (which is '(e1 .. (e2.1 .. e2.2))',\n** because concatenation is right associative), merge both CONCATs.\n*/\nstatic void codeconcat (FuncState *fs, expdesc *e1, expdesc *e2, int line) {\n  Instruction *ie2 = previousinstruction(fs);\n  if (GET_OPCODE(*ie2) == OP_CONCAT) {  /* is 'e2' a concatenation? */\n    int n = GETARG_B(*ie2);  /* # of elements concatenated in 'e2' */\n    lua_assert(e1->u.info + 1 == GETARG_A(*ie2));\n    freeexp(fs, e2);\n    SETARG_A(*ie2, e1->u.info);  /* correct first element ('e1') */\n    SETARG_B(*ie2, n + 1);  /* will concatenate one more element */\n  }\n  else {  /* 'e2' is not a concatenation */\n    luaK_codeABC(fs, OP_CONCAT, e1->u.info, 2, 0);  /* new concat opcode */\n    freeexp(fs, e2);\n    luaK_fixline(fs, line);\n  }\n}\n\n\n/*\n** Finalize code for binary operation, after reading 2nd operand.\n*/\nvoid luaK_posfix (FuncState *fs, BinOpr opr,\n                  expdesc *e1, expdesc *e2, int line) {\n  luaK_dischargevars(fs, e2);\n  if (foldbinop(opr) && constfolding(fs, cast_int(opr + LUA_OPADD), e1, e2))\n    return;  /* done by folding */\n  switch (opr) {\n    case OPR_AND: {\n      lua_assert(e1->t == NO_JUMP);  /* list closed by 'luaK_infix' */\n      luaK_concat(fs, &e2->f, e1->f);\n      *e1 = *e2;\n      break;\n    }\n    case OPR_OR: {\n      lua_assert(e1->f == NO_JUMP);  /* list closed by 'luaK_infix' */\n      luaK_concat(fs, &e2->t, e1->t);\n      *e1 = *e2;\n      break;\n    }\n    case OPR_CONCAT: {  /* e1 .. e2 */\n      luaK_exp2nextreg(fs, e2);\n      codeconcat(fs, e1, e2, line);\n      break;\n    }\n    case OPR_ADD: case OPR_MUL: {\n      codecommutative(fs, opr, e1, e2, line);\n      break;\n    }\n    case OPR_SUB: {\n      if (finishbinexpneg(fs, e1, e2, OP_ADDI, line, TM_SUB))\n        break; /* coded as (r1 + -I) */\n      /* ELSE */\n    }  /* FALLTHROUGH */\n    case OPR_DIV: case OPR_IDIV: case OPR_MOD: case OPR_POW: {\n      codearith(fs, opr, e1, e2, 0, line);\n      break;\n    }\n    case OPR_BAND: case OPR_BOR: case OPR_BXOR: {\n      codebitwise(fs, opr, e1, e2, line);\n      break;\n    }\n    case OPR_SHL: {\n      if (isSCint(e1)) {\n        swapexps(e1, e2);\n        codebini(fs, OP_SHLI, e1, e2, 1, line, TM_SHL);  /* I << r2 */\n      }\n      else if (finishbinexpneg(fs, e1, e2, OP_SHRI, line, TM_SHL)) {\n        /* coded as (r1 >> -I) */;\n      }\n      else  /* regular case (two registers) */\n       codebinexpval(fs, opr, e1, e2, line);\n      break;\n    }\n    case OPR_SHR: {\n      if (isSCint(e2))\n        codebini(fs, OP_SHRI, e1, e2, 0, line, TM_SHR);  /* r1 >> I */\n      else  /* regular case (two registers) */\n        codebinexpval(fs, opr, e1, e2, line);\n      break;\n    }\n    case OPR_EQ: case OPR_NE: {\n      codeeq(fs, opr, e1, e2);\n      break;\n    }\n    case OPR_GT: case OPR_GE: {\n      /* '(a > b)' <=> '(b < a)';  '(a >= b)' <=> '(b <= a)' */\n      swapexps(e1, e2);\n      opr = cast(BinOpr, (opr - OPR_GT) + OPR_LT);\n    }  /* FALLTHROUGH */\n    case OPR_LT: case OPR_LE: {\n      codeorder(fs, opr, e1, e2);\n      break;\n    }\n    default: lua_assert(0);\n  }\n}\n\n\n/*\n** Change line information associated with current position, by removing\n** previous info and adding it again with new line.\n*/\nvoid luaK_fixline (FuncState *fs, int line) {\n  removelastlineinfo(fs);\n  savelineinfo(fs, fs->f, line);\n}\n\n\nvoid luaK_settablesize (FuncState *fs, int pc, int ra, int asize, int hsize) {\n  Instruction *inst = &fs->f->code[pc];\n  int extra = asize / (MAXARG_vC + 1);  /* higher bits of array size */\n  int rc = asize % (MAXARG_vC + 1);  /* lower bits of array size */\n  int k = (extra > 0);  /* true iff needs extra argument */\n  hsize = (hsize != 0) ? luaO_ceillog2(cast_uint(hsize)) + 1 : 0;\n  *inst = CREATE_vABCk(OP_NEWTABLE, ra, hsize, rc, k);\n  *(inst + 1) = CREATE_Ax(OP_EXTRAARG, extra);\n}\n\n\n/*\n** Emit a SETLIST instruction.\n** 'base' is register that keeps table;\n** 'nelems' is #table plus those to be stored now;\n** 'tostore' is number of values (in registers 'base + 1',...) to add to\n** table (or LUA_MULTRET to add up to stack top).\n*/\nvoid luaK_setlist (FuncState *fs, int base, int nelems, int tostore) {\n  lua_assert(tostore != 0);\n  if (tostore == LUA_MULTRET)\n    tostore = 0;\n  if (nelems <= MAXARG_vC)\n    luaK_codevABCk(fs, OP_SETLIST, base, tostore, nelems, 0);\n  else {\n    int extra = nelems / (MAXARG_vC + 1);\n    nelems %= (MAXARG_vC + 1);\n    luaK_codevABCk(fs, OP_SETLIST, base, tostore, nelems, 1);\n    codeextraarg(fs, extra);\n  }\n  fs->freereg = cast_byte(base + 1);  /* free registers with list values */\n}\n\n\n/*\n** return the final target of a jump (skipping jumps to jumps)\n*/\nstatic int finaltarget (Instruction *code, int i) {\n  int count;\n  for (count = 0; count < 100; count++) {  /* avoid infinite loops */\n    Instruction pc = code[i];\n    if (GET_OPCODE(pc) != OP_JMP)\n      break;\n    else\n      i += GETARG_sJ(pc) + 1;\n  }\n  return i;\n}\n\n\n/*\n** Do a final pass over the code of a function, doing small peephole\n** optimizations and adjustments.\n*/\n#include \"lopnames.h\"\nvoid luaK_finish (FuncState *fs) {\n  int i;\n  Proto *p = fs->f;\n  for (i = 0; i < fs->pc; i++) {\n    Instruction *pc = &p->code[i];\n    /* avoid \"not used\" warnings when assert is off (for 'onelua.c') */\n    (void)luaP_isOT; (void)luaP_isIT;\n    lua_assert(i == 0 || luaP_isOT(*(pc - 1)) == luaP_isIT(*pc));\n    switch (GET_OPCODE(*pc)) {\n      case OP_RETURN0: case OP_RETURN1: {\n        if (!(fs->needclose || (p->flag & PF_ISVARARG)))\n          break;  /* no extra work */\n        /* else use OP_RETURN to do the extra work */\n        SET_OPCODE(*pc, OP_RETURN);\n      }  /* FALLTHROUGH */\n      case OP_RETURN: case OP_TAILCALL: {\n        if (fs->needclose)\n          SETARG_k(*pc, 1);  /* signal that it needs to close */\n        if (p->flag & PF_ISVARARG)\n          SETARG_C(*pc, p->numparams + 1);  /* signal that it is vararg */\n        break;\n      }\n      case OP_JMP: {\n        int target = finaltarget(p->code, i);\n        fixjump(fs, i, target);\n        break;\n      }\n      default: break;\n    }\n  }\n}\n"
        },
        {
          "name": "lcode.h",
          "type": "blob",
          "size": 3.66796875,
          "content": "/*\n** $Id: lcode.h $\n** Code generator for Lua\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lcode_h\n#define lcode_h\n\n#include \"llex.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n\n\n/*\n** Marks the end of a patch list. It is an invalid value both as an absolute\n** address, and as a list link (would link an element to itself).\n*/\n#define NO_JUMP (-1)\n\n\n/*\n** grep \"ORDER OPR\" if you change these enums  (ORDER OP)\n*/\ntypedef enum BinOpr {\n  /* arithmetic operators */\n  OPR_ADD, OPR_SUB, OPR_MUL, OPR_MOD, OPR_POW,\n  OPR_DIV, OPR_IDIV,\n  /* bitwise operators */\n  OPR_BAND, OPR_BOR, OPR_BXOR,\n  OPR_SHL, OPR_SHR,\n  /* string operator */\n  OPR_CONCAT,\n  /* comparison operators */\n  OPR_EQ, OPR_LT, OPR_LE,\n  OPR_NE, OPR_GT, OPR_GE,\n  /* logical operators */\n  OPR_AND, OPR_OR,\n  OPR_NOBINOPR\n} BinOpr;\n\n\n/* true if operation is foldable (that is, it is arithmetic or bitwise) */\n#define foldbinop(op)\t((op) <= OPR_SHR)\n\n\n#define luaK_codeABC(fs,o,a,b,c)\tluaK_codeABCk(fs,o,a,b,c,0)\n\n\ntypedef enum UnOpr { OPR_MINUS, OPR_BNOT, OPR_NOT, OPR_LEN, OPR_NOUNOPR } UnOpr;\n\n\n/* get (pointer to) instruction of given 'expdesc' */\n#define getinstruction(fs,e)\t((fs)->f->code[(e)->u.info])\n\n\n#define luaK_setmultret(fs,e)\tluaK_setreturns(fs, e, LUA_MULTRET)\n\n#define luaK_jumpto(fs,t)\tluaK_patchlist(fs, luaK_jump(fs), t)\n\nLUAI_FUNC int luaK_code (FuncState *fs, Instruction i);\nLUAI_FUNC int luaK_codeABx (FuncState *fs, OpCode o, int A, int Bx);\nLUAI_FUNC int luaK_codeABCk (FuncState *fs, OpCode o, int A, int B, int C,\n                                            int k);\nLUAI_FUNC int luaK_codevABCk (FuncState *fs, OpCode o, int A, int B, int C,\n                                             int k);\nLUAI_FUNC int luaK_exp2const (FuncState *fs, const expdesc *e, TValue *v);\nLUAI_FUNC void luaK_fixline (FuncState *fs, int line);\nLUAI_FUNC void luaK_nil (FuncState *fs, int from, int n);\nLUAI_FUNC void luaK_reserveregs (FuncState *fs, int n);\nLUAI_FUNC void luaK_checkstack (FuncState *fs, int n);\nLUAI_FUNC void luaK_int (FuncState *fs, int reg, lua_Integer n);\nLUAI_FUNC void luaK_dischargevars (FuncState *fs, expdesc *e);\nLUAI_FUNC int luaK_exp2anyreg (FuncState *fs, expdesc *e);\nLUAI_FUNC void luaK_exp2anyregup (FuncState *fs, expdesc *e);\nLUAI_FUNC void luaK_exp2nextreg (FuncState *fs, expdesc *e);\nLUAI_FUNC void luaK_exp2val (FuncState *fs, expdesc *e);\nLUAI_FUNC void luaK_self (FuncState *fs, expdesc *e, expdesc *key);\nLUAI_FUNC void luaK_indexed (FuncState *fs, expdesc *t, expdesc *k);\nLUAI_FUNC void luaK_goiftrue (FuncState *fs, expdesc *e);\nLUAI_FUNC void luaK_goiffalse (FuncState *fs, expdesc *e);\nLUAI_FUNC void luaK_storevar (FuncState *fs, expdesc *var, expdesc *e);\nLUAI_FUNC void luaK_setreturns (FuncState *fs, expdesc *e, int nresults);\nLUAI_FUNC void luaK_setoneret (FuncState *fs, expdesc *e);\nLUAI_FUNC int luaK_jump (FuncState *fs);\nLUAI_FUNC void luaK_ret (FuncState *fs, int first, int nret);\nLUAI_FUNC void luaK_patchlist (FuncState *fs, int list, int target);\nLUAI_FUNC void luaK_patchtohere (FuncState *fs, int list);\nLUAI_FUNC void luaK_concat (FuncState *fs, int *l1, int l2);\nLUAI_FUNC int luaK_getlabel (FuncState *fs);\nLUAI_FUNC void luaK_prefix (FuncState *fs, UnOpr op, expdesc *v, int line);\nLUAI_FUNC void luaK_infix (FuncState *fs, BinOpr op, expdesc *v);\nLUAI_FUNC void luaK_posfix (FuncState *fs, BinOpr op, expdesc *v1,\n                            expdesc *v2, int line);\nLUAI_FUNC void luaK_settablesize (FuncState *fs, int pc,\n                                  int ra, int asize, int hsize);\nLUAI_FUNC void luaK_setlist (FuncState *fs, int base, int nelems, int tostore);\nLUAI_FUNC void luaK_finish (FuncState *fs);\nLUAI_FUNC l_noret luaK_semerror (LexState *ls, const char *msg);\n\n\n#endif\n"
        },
        {
          "name": "lcorolib.c",
          "type": "blob",
          "size": 4.7626953125,
          "content": "/*\n** $Id: lcorolib.c $\n** Coroutine Library\n** See Copyright Notice in lua.h\n*/\n\n#define lcorolib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <stdlib.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n#include \"llimits.h\"\n\n\nstatic lua_State *getco (lua_State *L) {\n  lua_State *co = lua_tothread(L, 1);\n  luaL_argexpected(L, co, 1, \"thread\");\n  return co;\n}\n\n\n/*\n** Resumes a coroutine. Returns the number of results for non-error\n** cases or -1 for errors.\n*/\nstatic int auxresume (lua_State *L, lua_State *co, int narg) {\n  int status, nres;\n  if (l_unlikely(!lua_checkstack(co, narg))) {\n    lua_pushliteral(L, \"too many arguments to resume\");\n    return -1;  /* error flag */\n  }\n  lua_xmove(L, co, narg);\n  status = lua_resume(co, L, narg, &nres);\n  if (l_likely(status == LUA_OK || status == LUA_YIELD)) {\n    if (l_unlikely(!lua_checkstack(L, nres + 1))) {\n      lua_pop(co, nres);  /* remove results anyway */\n      lua_pushliteral(L, \"too many results to resume\");\n      return -1;  /* error flag */\n    }\n    lua_xmove(co, L, nres);  /* move yielded values */\n    return nres;\n  }\n  else {\n    lua_xmove(co, L, 1);  /* move error message */\n    return -1;  /* error flag */\n  }\n}\n\n\nstatic int luaB_coresume (lua_State *L) {\n  lua_State *co = getco(L);\n  int r;\n  r = auxresume(L, co, lua_gettop(L) - 1);\n  if (l_unlikely(r < 0)) {\n    lua_pushboolean(L, 0);\n    lua_insert(L, -2);\n    return 2;  /* return false + error message */\n  }\n  else {\n    lua_pushboolean(L, 1);\n    lua_insert(L, -(r + 1));\n    return r + 1;  /* return true + 'resume' returns */\n  }\n}\n\n\nstatic int luaB_auxwrap (lua_State *L) {\n  lua_State *co = lua_tothread(L, lua_upvalueindex(1));\n  int r = auxresume(L, co, lua_gettop(L));\n  if (l_unlikely(r < 0)) {  /* error? */\n    int stat = lua_status(co);\n    if (stat != LUA_OK && stat != LUA_YIELD) {  /* error in the coroutine? */\n      stat = lua_closethread(co, L);  /* close its tbc variables */\n      lua_assert(stat != LUA_OK);\n      lua_xmove(co, L, 1);  /* move error message to the caller */\n    }\n    if (stat != LUA_ERRMEM &&  /* not a memory error and ... */\n        lua_type(L, -1) == LUA_TSTRING) {  /* ... error object is a string? */\n      luaL_where(L, 1);  /* add extra info, if available */\n      lua_insert(L, -2);\n      lua_concat(L, 2);\n    }\n    return lua_error(L);  /* propagate error */\n  }\n  return r;\n}\n\n\nstatic int luaB_cocreate (lua_State *L) {\n  lua_State *NL;\n  luaL_checktype(L, 1, LUA_TFUNCTION);\n  NL = lua_newthread(L);\n  lua_pushvalue(L, 1);  /* move function to top */\n  lua_xmove(L, NL, 1);  /* move function from L to NL */\n  return 1;\n}\n\n\nstatic int luaB_cowrap (lua_State *L) {\n  luaB_cocreate(L);\n  lua_pushcclosure(L, luaB_auxwrap, 1);\n  return 1;\n}\n\n\nstatic int luaB_yield (lua_State *L) {\n  return lua_yield(L, lua_gettop(L));\n}\n\n\n#define COS_RUN\t\t0\n#define COS_DEAD\t1\n#define COS_YIELD\t2\n#define COS_NORM\t3\n\n\nstatic const char *const statname[] =\n  {\"running\", \"dead\", \"suspended\", \"normal\"};\n\n\nstatic int auxstatus (lua_State *L, lua_State *co) {\n  if (L == co) return COS_RUN;\n  else {\n    switch (lua_status(co)) {\n      case LUA_YIELD:\n        return COS_YIELD;\n      case LUA_OK: {\n        lua_Debug ar;\n        if (lua_getstack(co, 0, &ar))  /* does it have frames? */\n          return COS_NORM;  /* it is running */\n        else if (lua_gettop(co) == 0)\n            return COS_DEAD;\n        else\n          return COS_YIELD;  /* initial state */\n      }\n      default:  /* some error occurred */\n        return COS_DEAD;\n    }\n  }\n}\n\n\nstatic int luaB_costatus (lua_State *L) {\n  lua_State *co = getco(L);\n  lua_pushstring(L, statname[auxstatus(L, co)]);\n  return 1;\n}\n\n\nstatic int luaB_yieldable (lua_State *L) {\n  lua_State *co = lua_isnone(L, 1) ? L : getco(L);\n  lua_pushboolean(L, lua_isyieldable(co));\n  return 1;\n}\n\n\nstatic int luaB_corunning (lua_State *L) {\n  int ismain = lua_pushthread(L);\n  lua_pushboolean(L, ismain);\n  return 2;\n}\n\n\nstatic int luaB_close (lua_State *L) {\n  lua_State *co = getco(L);\n  int status = auxstatus(L, co);\n  switch (status) {\n    case COS_DEAD: case COS_YIELD: {\n      status = lua_closethread(co, L);\n      if (status == LUA_OK) {\n        lua_pushboolean(L, 1);\n        return 1;\n      }\n      else {\n        lua_pushboolean(L, 0);\n        lua_xmove(co, L, 1);  /* move error message */\n        return 2;\n      }\n    }\n    default:  /* normal or running coroutine */\n      return luaL_error(L, \"cannot close a %s coroutine\", statname[status]);\n  }\n}\n\n\nstatic const luaL_Reg co_funcs[] = {\n  {\"create\", luaB_cocreate},\n  {\"resume\", luaB_coresume},\n  {\"running\", luaB_corunning},\n  {\"status\", luaB_costatus},\n  {\"wrap\", luaB_cowrap},\n  {\"yield\", luaB_yield},\n  {\"isyieldable\", luaB_yieldable},\n  {\"close\", luaB_close},\n  {NULL, NULL}\n};\n\n\n\nLUAMOD_API int luaopen_coroutine (lua_State *L) {\n  luaL_newlib(L, co_funcs);\n  return 1;\n}\n\n"
        },
        {
          "name": "lctype.c",
          "type": "blob",
          "size": 2.4033203125,
          "content": "/*\n** $Id: lctype.c $\n** 'ctype' functions for Lua\n** See Copyright Notice in lua.h\n*/\n\n#define lctype_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include \"lctype.h\"\n\n#if !LUA_USE_CTYPE\t/* { */\n\n#include <limits.h>\n\n\n#if defined (LUA_UCID)\t\t/* accept UniCode IDentifiers? */\n/* consider all non-ascii codepoints to be alphabetic */\n#define NONA\t\t0x01\n#else\n#define NONA\t\t0x00\t/* default */\n#endif\n\n\nLUAI_DDEF const lu_byte luai_ctype_[UCHAR_MAX + 2] = {\n  0x00,  /* EOZ */\n  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\t/* 0. */\n  0x00,  0x08,  0x08,  0x08,  0x08,  0x08,  0x00,  0x00,\n  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\t/* 1. */\n  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,\n  0x0c,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,\t/* 2. */\n  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,\n  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,  0x16,\t/* 3. */\n  0x16,  0x16,  0x04,  0x04,  0x04,  0x04,  0x04,  0x04,\n  0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,\t/* 4. */\n  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,\n  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,\t/* 5. */\n  0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x05,\n  0x04,  0x15,  0x15,  0x15,  0x15,  0x15,  0x15,  0x05,\t/* 6. */\n  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,\n  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,  0x05,\t/* 7. */\n  0x05,  0x05,  0x05,  0x04,  0x04,  0x04,  0x04,  0x00,\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\t/* 8. */\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\t/* 9. */\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\t/* a. */\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\t/* b. */\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\n  0x00,  0x00,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\t/* c. */\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\t/* d. */\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\t/* e. */\n  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,  NONA,\n  NONA,  NONA,  NONA,  NONA,  NONA,  0x00,  0x00,  0x00,\t/* f. */\n  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00\n};\n\n#endif\t\t\t/* } */\n"
        },
        {
          "name": "lctype.h",
          "type": "blob",
          "size": 2.0654296875,
          "content": "/*\n** $Id: lctype.h $\n** 'ctype' functions for Lua\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lctype_h\n#define lctype_h\n\n#include \"lua.h\"\n\n\n/*\n** WARNING: the functions defined here do not necessarily correspond\n** to the similar functions in the standard C ctype.h. They are\n** optimized for the specific needs of Lua.\n*/\n\n#if !defined(LUA_USE_CTYPE)\n\n#if 'A' == 65 && '0' == 48\n/* ASCII case: can use its own tables; faster and fixed */\n#define LUA_USE_CTYPE\t0\n#else\n/* must use standard C ctype */\n#define LUA_USE_CTYPE\t1\n#endif\n\n#endif\n\n\n#if !LUA_USE_CTYPE\t/* { */\n\n#include <limits.h>\n\n#include \"llimits.h\"\n\n\n#define ALPHABIT\t0\n#define DIGITBIT\t1\n#define PRINTBIT\t2\n#define SPACEBIT\t3\n#define XDIGITBIT\t4\n\n\n#define MASK(B)\t\t(1 << (B))\n\n\n/*\n** add 1 to char to allow index -1 (EOZ)\n*/\n#define testprop(c,p)\t(luai_ctype_[(c)+1] & (p))\n\n/*\n** 'lalpha' (Lua alphabetic) and 'lalnum' (Lua alphanumeric) both include '_'\n*/\n#define lislalpha(c)\ttestprop(c, MASK(ALPHABIT))\n#define lislalnum(c)\ttestprop(c, (MASK(ALPHABIT) | MASK(DIGITBIT)))\n#define lisdigit(c)\ttestprop(c, MASK(DIGITBIT))\n#define lisspace(c)\ttestprop(c, MASK(SPACEBIT))\n#define lisprint(c)\ttestprop(c, MASK(PRINTBIT))\n#define lisxdigit(c)\ttestprop(c, MASK(XDIGITBIT))\n\n\n/*\n** In ASCII, this 'ltolower' is correct for alphabetic characters and\n** for '.'. That is enough for Lua needs. ('check_exp' ensures that\n** the character either is an upper-case letter or is unchanged by\n** the transformation, which holds for lower-case letters and '.'.)\n*/\n#define ltolower(c)  \\\n  check_exp(('A' <= (c) && (c) <= 'Z') || (c) == ((c) | ('A' ^ 'a')),  \\\n            (c) | ('A' ^ 'a'))\n\n\n/* one entry for each character and for -1 (EOZ) */\nLUAI_DDEC(const lu_byte luai_ctype_[UCHAR_MAX + 2];)\n\n\n#else\t\t\t/* }{ */\n\n/*\n** use standard C ctypes\n*/\n\n#include <ctype.h>\n\n\n#define lislalpha(c)\t(isalpha(c) || (c) == '_')\n#define lislalnum(c)\t(isalnum(c) || (c) == '_')\n#define lisdigit(c)\t(isdigit(c))\n#define lisspace(c)\t(isspace(c))\n#define lisprint(c)\t(isprint(c))\n#define lisxdigit(c)\t(isxdigit(c))\n\n#define ltolower(c)\t(tolower(c))\n\n#endif\t\t\t/* } */\n\n#endif\n\n"
        },
        {
          "name": "ldblib.c",
          "type": "blob",
          "size": 12.9013671875,
          "content": "/*\n** $Id: ldblib.c $\n** Interface from Lua to its debug API\n** See Copyright Notice in lua.h\n*/\n\n#define ldblib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n#include \"llimits.h\"\n\n\n/*\n** The hook table at registry[HOOKKEY] maps threads to their current\n** hook function.\n*/\nstatic const char *const HOOKKEY = \"_HOOKKEY\";\n\n\n/*\n** If L1 != L, L1 can be in any state, and therefore there are no\n** guarantees about its stack space; any push in L1 must be\n** checked.\n*/\nstatic void checkstack (lua_State *L, lua_State *L1, int n) {\n  if (l_unlikely(L != L1 && !lua_checkstack(L1, n)))\n    luaL_error(L, \"stack overflow\");\n}\n\n\nstatic int db_getregistry (lua_State *L) {\n  lua_pushvalue(L, LUA_REGISTRYINDEX);\n  return 1;\n}\n\n\nstatic int db_getmetatable (lua_State *L) {\n  luaL_checkany(L, 1);\n  if (!lua_getmetatable(L, 1)) {\n    lua_pushnil(L);  /* no metatable */\n  }\n  return 1;\n}\n\n\nstatic int db_setmetatable (lua_State *L) {\n  int t = lua_type(L, 2);\n  luaL_argexpected(L, t == LUA_TNIL || t == LUA_TTABLE, 2, \"nil or table\");\n  lua_settop(L, 2);\n  lua_setmetatable(L, 1);\n  return 1;  /* return 1st argument */\n}\n\n\nstatic int db_getuservalue (lua_State *L) {\n  int n = (int)luaL_optinteger(L, 2, 1);\n  if (lua_type(L, 1) != LUA_TUSERDATA)\n    luaL_pushfail(L);\n  else if (lua_getiuservalue(L, 1, n) != LUA_TNONE) {\n    lua_pushboolean(L, 1);\n    return 2;\n  }\n  return 1;\n}\n\n\nstatic int db_setuservalue (lua_State *L) {\n  int n = (int)luaL_optinteger(L, 3, 1);\n  luaL_checktype(L, 1, LUA_TUSERDATA);\n  luaL_checkany(L, 2);\n  lua_settop(L, 2);\n  if (!lua_setiuservalue(L, 1, n))\n    luaL_pushfail(L);\n  return 1;\n}\n\n\n/*\n** Auxiliary function used by several library functions: check for\n** an optional thread as function's first argument and set 'arg' with\n** 1 if this argument is present (so that functions can skip it to\n** access their other arguments)\n*/\nstatic lua_State *getthread (lua_State *L, int *arg) {\n  if (lua_isthread(L, 1)) {\n    *arg = 1;\n    return lua_tothread(L, 1);\n  }\n  else {\n    *arg = 0;\n    return L;  /* function will operate over current thread */\n  }\n}\n\n\n/*\n** Variations of 'lua_settable', used by 'db_getinfo' to put results\n** from 'lua_getinfo' into result table. Key is always a string;\n** value can be a string, an int, or a boolean.\n*/\nstatic void settabss (lua_State *L, const char *k, const char *v) {\n  lua_pushstring(L, v);\n  lua_setfield(L, -2, k);\n}\n\nstatic void settabsi (lua_State *L, const char *k, int v) {\n  lua_pushinteger(L, v);\n  lua_setfield(L, -2, k);\n}\n\nstatic void settabsb (lua_State *L, const char *k, int v) {\n  lua_pushboolean(L, v);\n  lua_setfield(L, -2, k);\n}\n\n\n/*\n** In function 'db_getinfo', the call to 'lua_getinfo' may push\n** results on the stack; later it creates the result table to put\n** these objects. Function 'treatstackoption' puts the result from\n** 'lua_getinfo' on top of the result table so that it can call\n** 'lua_setfield'.\n*/\nstatic void treatstackoption (lua_State *L, lua_State *L1, const char *fname) {\n  if (L == L1)\n    lua_rotate(L, -2, 1);  /* exchange object and table */\n  else\n    lua_xmove(L1, L, 1);  /* move object to the \"main\" stack */\n  lua_setfield(L, -2, fname);  /* put object into table */\n}\n\n\n/*\n** Calls 'lua_getinfo' and collects all results in a new table.\n** L1 needs stack space for an optional input (function) plus\n** two optional outputs (function and line table) from function\n** 'lua_getinfo'.\n*/\nstatic int db_getinfo (lua_State *L) {\n  lua_Debug ar;\n  int arg;\n  lua_State *L1 = getthread(L, &arg);\n  const char *options = luaL_optstring(L, arg+2, \"flnSrtu\");\n  checkstack(L, L1, 3);\n  luaL_argcheck(L, options[0] != '>', arg + 2, \"invalid option '>'\");\n  if (lua_isfunction(L, arg + 1)) {  /* info about a function? */\n    options = lua_pushfstring(L, \">%s\", options);  /* add '>' to 'options' */\n    lua_pushvalue(L, arg + 1);  /* move function to 'L1' stack */\n    lua_xmove(L, L1, 1);\n  }\n  else {  /* stack level */\n    if (!lua_getstack(L1, (int)luaL_checkinteger(L, arg + 1), &ar)) {\n      luaL_pushfail(L);  /* level out of range */\n      return 1;\n    }\n  }\n  if (!lua_getinfo(L1, options, &ar))\n    return luaL_argerror(L, arg+2, \"invalid option\");\n  lua_newtable(L);  /* table to collect results */\n  if (strchr(options, 'S')) {\n    lua_pushlstring(L, ar.source, ar.srclen);\n    lua_setfield(L, -2, \"source\");\n    settabss(L, \"short_src\", ar.short_src);\n    settabsi(L, \"linedefined\", ar.linedefined);\n    settabsi(L, \"lastlinedefined\", ar.lastlinedefined);\n    settabss(L, \"what\", ar.what);\n  }\n  if (strchr(options, 'l'))\n    settabsi(L, \"currentline\", ar.currentline);\n  if (strchr(options, 'u')) {\n    settabsi(L, \"nups\", ar.nups);\n    settabsi(L, \"nparams\", ar.nparams);\n    settabsb(L, \"isvararg\", ar.isvararg);\n  }\n  if (strchr(options, 'n')) {\n    settabss(L, \"name\", ar.name);\n    settabss(L, \"namewhat\", ar.namewhat);\n  }\n  if (strchr(options, 'r')) {\n    settabsi(L, \"ftransfer\", ar.ftransfer);\n    settabsi(L, \"ntransfer\", ar.ntransfer);\n  }\n  if (strchr(options, 't')) {\n    settabsb(L, \"istailcall\", ar.istailcall);\n    settabsi(L, \"extraargs\", ar.extraargs);\n  }\n  if (strchr(options, 'L'))\n    treatstackoption(L, L1, \"activelines\");\n  if (strchr(options, 'f'))\n    treatstackoption(L, L1, \"func\");\n  return 1;  /* return table */\n}\n\n\nstatic int db_getlocal (lua_State *L) {\n  int arg;\n  lua_State *L1 = getthread(L, &arg);\n  int nvar = (int)luaL_checkinteger(L, arg + 2);  /* local-variable index */\n  if (lua_isfunction(L, arg + 1)) {  /* function argument? */\n    lua_pushvalue(L, arg + 1);  /* push function */\n    lua_pushstring(L, lua_getlocal(L, NULL, nvar));  /* push local name */\n    return 1;  /* return only name (there is no value) */\n  }\n  else {  /* stack-level argument */\n    lua_Debug ar;\n    const char *name;\n    int level = (int)luaL_checkinteger(L, arg + 1);\n    if (l_unlikely(!lua_getstack(L1, level, &ar)))  /* out of range? */\n      return luaL_argerror(L, arg+1, \"level out of range\");\n    checkstack(L, L1, 1);\n    name = lua_getlocal(L1, &ar, nvar);\n    if (name) {\n      lua_xmove(L1, L, 1);  /* move local value */\n      lua_pushstring(L, name);  /* push name */\n      lua_rotate(L, -2, 1);  /* re-order */\n      return 2;\n    }\n    else {\n      luaL_pushfail(L);  /* no name (nor value) */\n      return 1;\n    }\n  }\n}\n\n\nstatic int db_setlocal (lua_State *L) {\n  int arg;\n  const char *name;\n  lua_State *L1 = getthread(L, &arg);\n  lua_Debug ar;\n  int level = (int)luaL_checkinteger(L, arg + 1);\n  int nvar = (int)luaL_checkinteger(L, arg + 2);\n  if (l_unlikely(!lua_getstack(L1, level, &ar)))  /* out of range? */\n    return luaL_argerror(L, arg+1, \"level out of range\");\n  luaL_checkany(L, arg+3);\n  lua_settop(L, arg+3);\n  checkstack(L, L1, 1);\n  lua_xmove(L, L1, 1);\n  name = lua_setlocal(L1, &ar, nvar);\n  if (name == NULL)\n    lua_pop(L1, 1);  /* pop value (if not popped by 'lua_setlocal') */\n  lua_pushstring(L, name);\n  return 1;\n}\n\n\n/*\n** get (if 'get' is true) or set an upvalue from a closure\n*/\nstatic int auxupvalue (lua_State *L, int get) {\n  const char *name;\n  int n = (int)luaL_checkinteger(L, 2);  /* upvalue index */\n  luaL_checktype(L, 1, LUA_TFUNCTION);  /* closure */\n  name = get ? lua_getupvalue(L, 1, n) : lua_setupvalue(L, 1, n);\n  if (name == NULL) return 0;\n  lua_pushstring(L, name);\n  lua_insert(L, -(get+1));  /* no-op if get is false */\n  return get + 1;\n}\n\n\nstatic int db_getupvalue (lua_State *L) {\n  return auxupvalue(L, 1);\n}\n\n\nstatic int db_setupvalue (lua_State *L) {\n  luaL_checkany(L, 3);\n  return auxupvalue(L, 0);\n}\n\n\n/*\n** Check whether a given upvalue from a given closure exists and\n** returns its index\n*/\nstatic void *checkupval (lua_State *L, int argf, int argnup, int *pnup) {\n  void *id;\n  int nup = (int)luaL_checkinteger(L, argnup);  /* upvalue index */\n  luaL_checktype(L, argf, LUA_TFUNCTION);  /* closure */\n  id = lua_upvalueid(L, argf, nup);\n  if (pnup) {\n    luaL_argcheck(L, id != NULL, argnup, \"invalid upvalue index\");\n    *pnup = nup;\n  }\n  return id;\n}\n\n\nstatic int db_upvalueid (lua_State *L) {\n  void *id = checkupval(L, 1, 2, NULL);\n  if (id != NULL)\n    lua_pushlightuserdata(L, id);\n  else\n    luaL_pushfail(L);\n  return 1;\n}\n\n\nstatic int db_upvaluejoin (lua_State *L) {\n  int n1, n2;\n  checkupval(L, 1, 2, &n1);\n  checkupval(L, 3, 4, &n2);\n  luaL_argcheck(L, !lua_iscfunction(L, 1), 1, \"Lua function expected\");\n  luaL_argcheck(L, !lua_iscfunction(L, 3), 3, \"Lua function expected\");\n  lua_upvaluejoin(L, 1, n1, 3, n2);\n  return 0;\n}\n\n\n/*\n** Call hook function registered at hook table for the current\n** thread (if there is one)\n*/\nstatic void hookf (lua_State *L, lua_Debug *ar) {\n  static const char *const hooknames[] =\n    {\"call\", \"return\", \"line\", \"count\", \"tail call\"};\n  lua_getfield(L, LUA_REGISTRYINDEX, HOOKKEY);\n  lua_pushthread(L);\n  if (lua_rawget(L, -2) == LUA_TFUNCTION) {  /* is there a hook function? */\n    lua_pushstring(L, hooknames[(int)ar->event]);  /* push event name */\n    if (ar->currentline >= 0)\n      lua_pushinteger(L, ar->currentline);  /* push current line */\n    else lua_pushnil(L);\n    lua_assert(lua_getinfo(L, \"lS\", ar));\n    lua_call(L, 2, 0);  /* call hook function */\n  }\n}\n\n\n/*\n** Convert a string mask (for 'sethook') into a bit mask\n*/\nstatic int makemask (const char *smask, int count) {\n  int mask = 0;\n  if (strchr(smask, 'c')) mask |= LUA_MASKCALL;\n  if (strchr(smask, 'r')) mask |= LUA_MASKRET;\n  if (strchr(smask, 'l')) mask |= LUA_MASKLINE;\n  if (count > 0) mask |= LUA_MASKCOUNT;\n  return mask;\n}\n\n\n/*\n** Convert a bit mask (for 'gethook') into a string mask\n*/\nstatic char *unmakemask (int mask, char *smask) {\n  int i = 0;\n  if (mask & LUA_MASKCALL) smask[i++] = 'c';\n  if (mask & LUA_MASKRET) smask[i++] = 'r';\n  if (mask & LUA_MASKLINE) smask[i++] = 'l';\n  smask[i] = '\\0';\n  return smask;\n}\n\n\nstatic int db_sethook (lua_State *L) {\n  int arg, mask, count;\n  lua_Hook func;\n  lua_State *L1 = getthread(L, &arg);\n  if (lua_isnoneornil(L, arg+1)) {  /* no hook? */\n    lua_settop(L, arg+1);\n    func = NULL; mask = 0; count = 0;  /* turn off hooks */\n  }\n  else {\n    const char *smask = luaL_checkstring(L, arg+2);\n    luaL_checktype(L, arg+1, LUA_TFUNCTION);\n    count = (int)luaL_optinteger(L, arg + 3, 0);\n    func = hookf; mask = makemask(smask, count);\n  }\n  if (!luaL_getsubtable(L, LUA_REGISTRYINDEX, HOOKKEY)) {\n    /* table just created; initialize it */\n    lua_pushliteral(L, \"k\");\n    lua_setfield(L, -2, \"__mode\");  /** hooktable.__mode = \"k\" */\n    lua_pushvalue(L, -1);\n    lua_setmetatable(L, -2);  /* metatable(hooktable) = hooktable */\n  }\n  checkstack(L, L1, 1);\n  lua_pushthread(L1); lua_xmove(L1, L, 1);  /* key (thread) */\n  lua_pushvalue(L, arg + 1);  /* value (hook function) */\n  lua_rawset(L, -3);  /* hooktable[L1] = new Lua hook */\n  lua_sethook(L1, func, mask, count);\n  return 0;\n}\n\n\nstatic int db_gethook (lua_State *L) {\n  int arg;\n  lua_State *L1 = getthread(L, &arg);\n  char buff[5];\n  int mask = lua_gethookmask(L1);\n  lua_Hook hook = lua_gethook(L1);\n  if (hook == NULL) {  /* no hook? */\n    luaL_pushfail(L);\n    return 1;\n  }\n  else if (hook != hookf)  /* external hook? */\n    lua_pushliteral(L, \"external hook\");\n  else {  /* hook table must exist */\n    lua_getfield(L, LUA_REGISTRYINDEX, HOOKKEY);\n    checkstack(L, L1, 1);\n    lua_pushthread(L1); lua_xmove(L1, L, 1);\n    lua_rawget(L, -2);   /* 1st result = hooktable[L1] */\n    lua_remove(L, -2);  /* remove hook table */\n  }\n  lua_pushstring(L, unmakemask(mask, buff));  /* 2nd result = mask */\n  lua_pushinteger(L, lua_gethookcount(L1));  /* 3rd result = count */\n  return 3;\n}\n\n\nstatic int db_debug (lua_State *L) {\n  for (;;) {\n    char buffer[250];\n    lua_writestringerror(\"%s\", \"lua_debug> \");\n    if (fgets(buffer, sizeof(buffer), stdin) == NULL ||\n        strcmp(buffer, \"cont\\n\") == 0)\n      return 0;\n    if (luaL_loadbuffer(L, buffer, strlen(buffer), \"=(debug command)\") ||\n        lua_pcall(L, 0, 0, 0))\n      lua_writestringerror(\"%s\\n\", luaL_tolstring(L, -1, NULL));\n    lua_settop(L, 0);  /* remove eventual returns */\n  }\n}\n\n\nstatic int db_traceback (lua_State *L) {\n  int arg;\n  lua_State *L1 = getthread(L, &arg);\n  const char *msg = lua_tostring(L, arg + 1);\n  if (msg == NULL && !lua_isnoneornil(L, arg + 1))  /* non-string 'msg'? */\n    lua_pushvalue(L, arg + 1);  /* return it untouched */\n  else {\n    int level = (int)luaL_optinteger(L, arg + 2, (L == L1) ? 1 : 0);\n    luaL_traceback(L, L1, msg, level);\n  }\n  return 1;\n}\n\n\nstatic const luaL_Reg dblib[] = {\n  {\"debug\", db_debug},\n  {\"getuservalue\", db_getuservalue},\n  {\"gethook\", db_gethook},\n  {\"getinfo\", db_getinfo},\n  {\"getlocal\", db_getlocal},\n  {\"getregistry\", db_getregistry},\n  {\"getmetatable\", db_getmetatable},\n  {\"getupvalue\", db_getupvalue},\n  {\"upvaluejoin\", db_upvaluejoin},\n  {\"upvalueid\", db_upvalueid},\n  {\"setuservalue\", db_setuservalue},\n  {\"sethook\", db_sethook},\n  {\"setlocal\", db_setlocal},\n  {\"setmetatable\", db_setmetatable},\n  {\"setupvalue\", db_setupvalue},\n  {\"traceback\", db_traceback},\n  {NULL, NULL}\n};\n\n\nLUAMOD_API int luaopen_debug (lua_State *L) {\n  luaL_newlib(L, dblib);\n  return 1;\n}\n\n"
        },
        {
          "name": "ldebug.c",
          "type": "blob",
          "size": 28.990234375,
          "content": "/*\n** $Id: ldebug.c $\n** Debug Interface\n** See Copyright Notice in lua.h\n*/\n\n#define ldebug_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <stdarg.h>\n#include <stddef.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\n\n#define LuaClosure(f)\t\t((f) != NULL && (f)->c.tt == LUA_VLCL)\n\n\nstatic const char *funcnamefromcall (lua_State *L, CallInfo *ci,\n                                                   const char **name);\n\n\nstatic int currentpc (CallInfo *ci) {\n  lua_assert(isLua(ci));\n  return pcRel(ci->u.l.savedpc, ci_func(ci)->p);\n}\n\n\n/*\n** Get a \"base line\" to find the line corresponding to an instruction.\n** Base lines are regularly placed at MAXIWTHABS intervals, so usually\n** an integer division gets the right place. When the source file has\n** large sequences of empty/comment lines, it may need extra entries,\n** so the original estimate needs a correction.\n** If the original estimate is -1, the initial 'if' ensures that the\n** 'while' will run at least once.\n** The assertion that the estimate is a lower bound for the correct base\n** is valid as long as the debug info has been generated with the same\n** value for MAXIWTHABS or smaller. (Previous releases use a little\n** smaller value.)\n*/\nstatic int getbaseline (const Proto *f, int pc, int *basepc) {\n  if (f->sizeabslineinfo == 0 || pc < f->abslineinfo[0].pc) {\n    *basepc = -1;  /* start from the beginning */\n    return f->linedefined;\n  }\n  else {\n    int i = pc / MAXIWTHABS - 1;  /* get an estimate */\n    /* estimate must be a lower bound of the correct base */\n    lua_assert(i < 0 ||\n              (i < f->sizeabslineinfo && f->abslineinfo[i].pc <= pc));\n    while (i + 1 < f->sizeabslineinfo && pc >= f->abslineinfo[i + 1].pc)\n      i++;  /* low estimate; adjust it */\n    *basepc = f->abslineinfo[i].pc;\n    return f->abslineinfo[i].line;\n  }\n}\n\n\n/*\n** Get the line corresponding to instruction 'pc' in function 'f';\n** first gets a base line and from there does the increments until\n** the desired instruction.\n*/\nint luaG_getfuncline (const Proto *f, int pc) {\n  if (f->lineinfo == NULL)  /* no debug information? */\n    return -1;\n  else {\n    int basepc;\n    int baseline = getbaseline(f, pc, &basepc);\n    while (basepc++ < pc) {  /* walk until given instruction */\n      lua_assert(f->lineinfo[basepc] != ABSLINEINFO);\n      baseline += f->lineinfo[basepc];  /* correct line */\n    }\n    return baseline;\n  }\n}\n\n\nstatic int getcurrentline (CallInfo *ci) {\n  return luaG_getfuncline(ci_func(ci)->p, currentpc(ci));\n}\n\n\n/*\n** Set 'trap' for all active Lua frames.\n** This function can be called during a signal, under \"reasonable\"\n** assumptions. A new 'ci' is completely linked in the list before it\n** becomes part of the \"active\" list, and we assume that pointers are\n** atomic; see comment in next function.\n** (A compiler doing interprocedural optimizations could, theoretically,\n** reorder memory writes in such a way that the list could be\n** temporarily broken while inserting a new element. We simply assume it\n** has no good reasons to do that.)\n*/\nstatic void settraps (CallInfo *ci) {\n  for (; ci != NULL; ci = ci->previous)\n    if (isLua(ci))\n      ci->u.l.trap = 1;\n}\n\n\n/*\n** This function can be called during a signal, under \"reasonable\"\n** assumptions.\n** Fields 'basehookcount' and 'hookcount' (set by 'resethookcount')\n** are for debug only, and it is no problem if they get arbitrary\n** values (causes at most one wrong hook call). 'hookmask' is an atomic\n** value. We assume that pointers are atomic too (e.g., gcc ensures that\n** for all platforms where it runs). Moreover, 'hook' is always checked\n** before being called (see 'luaD_hook').\n*/\nLUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {\n  if (func == NULL || mask == 0) {  /* turn off hooks? */\n    mask = 0;\n    func = NULL;\n  }\n  L->hook = func;\n  L->basehookcount = count;\n  resethookcount(L);\n  L->hookmask = cast_byte(mask);\n  if (mask)\n    settraps(L->ci);  /* to trace inside 'luaV_execute' */\n}\n\n\nLUA_API lua_Hook lua_gethook (lua_State *L) {\n  return L->hook;\n}\n\n\nLUA_API int lua_gethookmask (lua_State *L) {\n  return L->hookmask;\n}\n\n\nLUA_API int lua_gethookcount (lua_State *L) {\n  return L->basehookcount;\n}\n\n\nLUA_API int lua_getstack (lua_State *L, int level, lua_Debug *ar) {\n  int status;\n  CallInfo *ci;\n  if (level < 0) return 0;  /* invalid (negative) level */\n  lua_lock(L);\n  for (ci = L->ci; level > 0 && ci != &L->base_ci; ci = ci->previous)\n    level--;\n  if (level == 0 && ci != &L->base_ci) {  /* level found? */\n    status = 1;\n    ar->i_ci = ci;\n  }\n  else status = 0;  /* no such level */\n  lua_unlock(L);\n  return status;\n}\n\n\nstatic const char *upvalname (const Proto *p, int uv) {\n  TString *s = check_exp(uv < p->sizeupvalues, p->upvalues[uv].name);\n  if (s == NULL) return \"?\";\n  else return getstr(s);\n}\n\n\nstatic const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func.p))->p->flag & PF_ISVARARG) {\n    int nextra = ci->u.l.nextraargs;\n    if (n >= -nextra) {  /* 'n' is negative */\n      *pos = ci->func.p - nextra - (n + 1);\n      return \"(vararg)\";  /* generic name for any vararg */\n    }\n  }\n  return NULL;  /* no such vararg */\n}\n\n\nconst char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func.p + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top.p : ci->next->func.p;\n    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */\n      /* generic name for any valid slot */\n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else\n      return NULL;  /* no name */\n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}\n\n\nLUA_API const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n) {\n  const char *name;\n  lua_lock(L);\n  if (ar == NULL) {  /* information about non-active function? */\n    if (!isLfunction(s2v(L->top.p - 1)))  /* not a Lua function? */\n      name = NULL;\n    else  /* consider live variables at function start (parameters) */\n      name = luaF_getlocalname(clLvalue(s2v(L->top.p - 1))->p, n, 0);\n  }\n  else {  /* active function; get information through 'ar' */\n    StkId pos = NULL;  /* to avoid warnings */\n    name = luaG_findlocal(L, ar->i_ci, n, &pos);\n    if (name) {\n      setobjs2s(L, L->top.p, pos);\n      api_incr_top(L);\n    }\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nLUA_API const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n) {\n  StkId pos = NULL;  /* to avoid warnings */\n  const char *name;\n  lua_lock(L);\n  name = luaG_findlocal(L, ar->i_ci, n, &pos);\n  if (name) {\n    api_checkpop(L, 1);\n    setobjs2s(L, pos, L->top.p - 1);\n    L->top.p--;  /* pop value */\n  }\n  lua_unlock(L);\n  return name;\n}\n\n\nstatic void funcinfo (lua_Debug *ar, Closure *cl) {\n  if (!LuaClosure(cl)) {\n    ar->source = \"=[C]\";\n    ar->srclen = LL(\"=[C]\");\n    ar->linedefined = -1;\n    ar->lastlinedefined = -1;\n    ar->what = \"C\";\n  }\n  else {\n    const Proto *p = cl->l.p;\n    if (p->source) {\n      ar->source = getlstr(p->source, ar->srclen);\n    }\n    else {\n      ar->source = \"=?\";\n      ar->srclen = LL(\"=?\");\n    }\n    ar->linedefined = p->linedefined;\n    ar->lastlinedefined = p->lastlinedefined;\n    ar->what = (ar->linedefined == 0) ? \"main\" : \"Lua\";\n  }\n  luaO_chunkid(ar->short_src, ar->source, ar->srclen);\n}\n\n\nstatic int nextline (const Proto *p, int currentline, int pc) {\n  if (p->lineinfo[pc] != ABSLINEINFO)\n    return currentline + p->lineinfo[pc];\n  else\n    return luaG_getfuncline(p, pc);\n}\n\n\nstatic void collectvalidlines (lua_State *L, Closure *f) {\n  if (!LuaClosure(f)) {\n    setnilvalue(s2v(L->top.p));\n    api_incr_top(L);\n  }\n  else {\n    const Proto *p = f->l.p;\n    int currentline = p->linedefined;\n    Table *t = luaH_new(L);  /* new table to store active lines */\n    sethvalue2s(L, L->top.p, t);  /* push it on stack */\n    api_incr_top(L);\n    if (p->lineinfo != NULL) {  /* proto with debug information? */\n      int i;\n      TValue v;\n      setbtvalue(&v);  /* boolean 'true' to be the value of all indices */\n      if (!(p->flag & PF_ISVARARG))  /* regular function? */\n        i = 0;  /* consider all instructions */\n      else {  /* vararg function */\n        lua_assert(GET_OPCODE(p->code[0]) == OP_VARARGPREP);\n        currentline = nextline(p, currentline, 0);\n        i = 1;  /* skip first instruction (OP_VARARGPREP) */\n      }\n      for (; i < p->sizelineinfo; i++) {  /* for each instruction */\n        currentline = nextline(p, currentline, i);  /* get its line */\n        luaH_setint(L, t, currentline, &v);  /* table[line] = true */\n      }\n    }\n  }\n}\n\n\nstatic const char *getfuncname (lua_State *L, CallInfo *ci, const char **name) {\n  /* calling function is a known function? */\n  if (ci != NULL && !(ci->callstatus & CIST_TAIL))\n    return funcnamefromcall(L, ci->previous, name);\n  else return NULL;  /* no way to find a name */\n}\n\n\nstatic int auxgetinfo (lua_State *L, const char *what, lua_Debug *ar,\n                       Closure *f, CallInfo *ci) {\n  int status = 1;\n  for (; *what; what++) {\n    switch (*what) {\n      case 'S': {\n        funcinfo(ar, f);\n        break;\n      }\n      case 'l': {\n        ar->currentline = (ci && isLua(ci)) ? getcurrentline(ci) : -1;\n        break;\n      }\n      case 'u': {\n        ar->nups = (f == NULL) ? 0 : f->c.nupvalues;\n        if (!LuaClosure(f)) {\n          ar->isvararg = 1;\n          ar->nparams = 0;\n        }\n        else {\n          ar->isvararg = (f->l.p->flag & PF_ISVARARG) ? 1 : 0;\n          ar->nparams = f->l.p->numparams;\n        }\n        break;\n      }\n      case 't': {\n        if (ci != NULL) {\n          ar->istailcall = !!(ci->callstatus & CIST_TAIL);\n          ar->extraargs =\n                   cast_uchar((ci->callstatus & MAX_CCMT) >> CIST_CCMT);\n        }\n        else {\n          ar->istailcall = 0;\n          ar->extraargs = 0;\n        }\n        break;\n      }\n      case 'n': {\n        ar->namewhat = getfuncname(L, ci, &ar->name);\n        if (ar->namewhat == NULL) {\n          ar->namewhat = \"\";  /* not found */\n          ar->name = NULL;\n        }\n        break;\n      }\n      case 'r': {\n        if (ci == NULL || !(ci->callstatus & CIST_HOOKED))\n          ar->ftransfer = ar->ntransfer = 0;\n        else {\n          ar->ftransfer = L->transferinfo.ftransfer;\n          ar->ntransfer = L->transferinfo.ntransfer;\n        }\n        break;\n      }\n      case 'L':\n      case 'f':  /* handled by lua_getinfo */\n        break;\n      default: status = 0;  /* invalid option */\n    }\n  }\n  return status;\n}\n\n\nLUA_API int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar) {\n  int status;\n  Closure *cl;\n  CallInfo *ci;\n  TValue *func;\n  lua_lock(L);\n  if (*what == '>') {\n    ci = NULL;\n    func = s2v(L->top.p - 1);\n    api_check(L, ttisfunction(func), \"function expected\");\n    what++;  /* skip the '>' */\n    L->top.p--;  /* pop function */\n  }\n  else {\n    ci = ar->i_ci;\n    func = s2v(ci->func.p);\n    lua_assert(ttisfunction(func));\n  }\n  cl = ttisclosure(func) ? clvalue(func) : NULL;\n  status = auxgetinfo(L, what, ar, cl, ci);\n  if (strchr(what, 'f')) {\n    setobj2s(L, L->top.p, func);\n    api_incr_top(L);\n  }\n  if (strchr(what, 'L'))\n    collectvalidlines(L, cl);\n  lua_unlock(L);\n  return status;\n}\n\n\n/*\n** {======================================================\n** Symbolic Execution\n** =======================================================\n*/\n\n\nstatic int filterpc (int pc, int jmptarget) {\n  if (pc < jmptarget)  /* is code conditional (inside a jump)? */\n    return -1;  /* cannot know who sets that register */\n  else return pc;  /* current position sets that register */\n}\n\n\n/*\n** Try to find last instruction before 'lastpc' that modified register 'reg'.\n*/\nstatic int findsetreg (const Proto *p, int lastpc, int reg) {\n  int pc;\n  int setreg = -1;  /* keep last instruction that changed 'reg' */\n  int jmptarget = 0;  /* any code before this address is conditional */\n  if (testMMMode(GET_OPCODE(p->code[lastpc])))\n    lastpc--;  /* previous instruction was not actually executed */\n  for (pc = 0; pc < lastpc; pc++) {\n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    int a = GETARG_A(i);\n    int change;  /* true if current instruction changed 'reg' */\n    switch (op) {\n      case OP_LOADNIL: {  /* set registers from 'a' to 'a+b' */\n        int b = GETARG_B(i);\n        change = (a <= reg && reg <= a + b);\n        break;\n      }\n      case OP_TFORCALL: {  /* affect all regs above its base */\n        change = (reg >= a + 2);\n        break;\n      }\n      case OP_CALL:\n      case OP_TAILCALL: {  /* affect all registers above base */\n        change = (reg >= a);\n        break;\n      }\n      case OP_JMP: {  /* doesn't change registers, but changes 'jmptarget' */\n        int b = GETARG_sJ(i);\n        int dest = pc + 1 + b;\n        /* jump does not skip 'lastpc' and is larger than current one? */\n        if (dest <= lastpc && dest > jmptarget)\n          jmptarget = dest;  /* update 'jmptarget' */\n        change = 0;\n        break;\n      }\n      default:  /* any instruction that sets A */\n        change = (testAMode(op) && reg == a);\n        break;\n    }\n    if (change)\n      setreg = filterpc(pc, jmptarget);\n  }\n  return setreg;\n}\n\n\n/*\n** Find a \"name\" for the constant 'c'.\n*/\nstatic const char *kname (const Proto *p, int index, const char **name) {\n  TValue *kvalue = &p->k[index];\n  if (ttisstring(kvalue)) {\n    *name = getstr(tsvalue(kvalue));\n    return \"constant\";\n  }\n  else {\n    *name = \"?\";\n    return NULL;\n  }\n}\n\n\nstatic const char *basicgetobjname (const Proto *p, int *ppc, int reg,\n                                    const char **name) {\n  int pc = *ppc;\n  *name = luaF_getlocalname(p, reg + 1, pc);\n  if (*name)  /* is a local? */\n    return \"local\";\n  /* else try symbolic execution */\n  *ppc = pc = findsetreg(p, pc, reg);\n  if (pc != -1) {  /* could find instruction? */\n    Instruction i = p->code[pc];\n    OpCode op = GET_OPCODE(i);\n    switch (op) {\n      case OP_MOVE: {\n        int b = GETARG_B(i);  /* move from 'b' to 'a' */\n        if (b < GETARG_A(i))\n          return basicgetobjname(p, ppc, b, name);  /* get name for 'b' */\n        break;\n      }\n      case OP_GETUPVAL: {\n        *name = upvalname(p, GETARG_B(i));\n        return \"upvalue\";\n      }\n      case OP_LOADK: return kname(p, GETARG_Bx(i), name);\n      case OP_LOADKX: return kname(p, GETARG_Ax(p->code[pc + 1]), name);\n      default: break;\n    }\n  }\n  return NULL;  /* could not find reasonable name */\n}\n\n\n/*\n** Find a \"name\" for the register 'c'.\n*/\nstatic void rname (const Proto *p, int pc, int c, const char **name) {\n  const char *what = basicgetobjname(p, &pc, c, name); /* search for 'c' */\n  if (!(what && *what == 'c'))  /* did not find a constant name? */\n    *name = \"?\";\n}\n\n\n/*\n** Find a \"name\" for a 'C' value in an RK instruction.\n*/\nstatic void rkname (const Proto *p, int pc, Instruction i, const char **name) {\n  int c = GETARG_C(i);  /* key index */\n  if (GETARG_k(i))  /* is 'c' a constant? */\n    kname(p, c, name);\n  else  /* 'c' is a register */\n    rname(p, pc, c, name);\n}\n\n\n/*\n** Check whether table being indexed by instruction 'i' is the\n** environment '_ENV'\n*/\nstatic const char *isEnv (const Proto *p, int pc, Instruction i, int isup) {\n  int t = GETARG_B(i);  /* table index */\n  const char *name;  /* name of indexed variable */\n  if (isup)  /* is 't' an upvalue? */\n    name = upvalname(p, t);\n  else  /* 't' is a register */\n    basicgetobjname(p, &pc, t, &name);\n  return (name && strcmp(name, LUA_ENV) == 0) ? \"global\" : \"field\";\n}\n\n\n/*\n** Extend 'basicgetobjname' to handle table accesses\n*/\nstatic const char *getobjname (const Proto *p, int lastpc, int reg,\n                               const char **name) {\n  const char *kind = basicgetobjname(p, &lastpc, reg, name);\n  if (kind != NULL)\n    return kind;\n  else if (lastpc != -1) {  /* could find instruction? */\n    Instruction i = p->code[lastpc];\n    OpCode op = GET_OPCODE(i);\n    switch (op) {\n      case OP_GETTABUP: {\n        int k = GETARG_C(i);  /* key index */\n        kname(p, k, name);\n        return isEnv(p, lastpc, i, 1);\n      }\n      case OP_GETTABLE: {\n        int k = GETARG_C(i);  /* key index */\n        rname(p, lastpc, k, name);\n        return isEnv(p, lastpc, i, 0);\n      }\n      case OP_GETI: {\n        *name = \"integer index\";\n        return \"field\";\n      }\n      case OP_GETFIELD: {\n        int k = GETARG_C(i);  /* key index */\n        kname(p, k, name);\n        return isEnv(p, lastpc, i, 0);\n      }\n      case OP_SELF: {\n        rkname(p, lastpc, i, name);\n        return \"method\";\n      }\n      default: break;  /* go through to return NULL */\n    }\n  }\n  return NULL;  /* could not find reasonable name */\n}\n\n\n/*\n** Try to find a name for a function based on the code that called it.\n** (Only works when function was called by a Lua function.)\n** Returns what the name is (e.g., \"for iterator\", \"method\",\n** \"metamethod\") and sets '*name' to point to the name.\n*/\nstatic const char *funcnamefromcode (lua_State *L, const Proto *p,\n                                     int pc, const char **name) {\n  TMS tm = (TMS)0;  /* (initial value avoids warnings) */\n  Instruction i = p->code[pc];  /* calling instruction */\n  switch (GET_OPCODE(i)) {\n    case OP_CALL:\n    case OP_TAILCALL:\n      return getobjname(p, pc, GETARG_A(i), name);  /* get function name */\n    case OP_TFORCALL: {  /* for iterator */\n      *name = \"for iterator\";\n       return \"for iterator\";\n    }\n    /* other instructions can do calls through metamethods */\n    case OP_SELF: case OP_GETTABUP: case OP_GETTABLE:\n    case OP_GETI: case OP_GETFIELD:\n      tm = TM_INDEX;\n      break;\n    case OP_SETTABUP: case OP_SETTABLE: case OP_SETI: case OP_SETFIELD:\n      tm = TM_NEWINDEX;\n      break;\n    case OP_MMBIN: case OP_MMBINI: case OP_MMBINK: {\n      tm = cast(TMS, GETARG_C(i));\n      break;\n    }\n    case OP_UNM: tm = TM_UNM; break;\n    case OP_BNOT: tm = TM_BNOT; break;\n    case OP_LEN: tm = TM_LEN; break;\n    case OP_CONCAT: tm = TM_CONCAT; break;\n    case OP_EQ: tm = TM_EQ; break;\n    /* no cases for OP_EQI and OP_EQK, as they don't call metamethods */\n    case OP_LT: case OP_LTI: case OP_GTI: tm = TM_LT; break;\n    case OP_LE: case OP_LEI: case OP_GEI: tm = TM_LE; break;\n    case OP_CLOSE: case OP_RETURN: tm = TM_CLOSE; break;\n    default:\n      return NULL;  /* cannot find a reasonable name */\n  }\n  *name = getshrstr(G(L)->tmname[tm]) + 2;\n  return \"metamethod\";\n}\n\n\n/*\n** Try to find a name for a function based on how it was called.\n*/\nstatic const char *funcnamefromcall (lua_State *L, CallInfo *ci,\n                                                   const char **name) {\n  if (ci->callstatus & CIST_HOOKED) {  /* was it called inside a hook? */\n    *name = \"?\";\n    return \"hook\";\n  }\n  else if (ci->callstatus & CIST_FIN) {  /* was it called as a finalizer? */\n    *name = \"__gc\";\n    return \"metamethod\";  /* report it as such */\n  }\n  else if (isLua(ci))\n    return funcnamefromcode(L, ci_func(ci)->p, currentpc(ci), name);\n  else\n    return NULL;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** Check whether pointer 'o' points to some value in the stack frame of\n** the current function and, if so, returns its index.  Because 'o' may\n** not point to a value in this stack, we cannot compare it with the\n** region boundaries (undefined behavior in ISO C).\n*/\nstatic int instack (CallInfo *ci, const TValue *o) {\n  int pos;\n  StkId base = ci->func.p + 1;\n  for (pos = 0; base + pos < ci->top.p; pos++) {\n    if (o == s2v(base + pos))\n      return pos;\n  }\n  return -1;  /* not found */\n}\n\n\n/*\n** Checks whether value 'o' came from an upvalue. (That can only happen\n** with instructions OP_GETTABUP/OP_SETTABUP, which operate directly on\n** upvalues.)\n*/\nstatic const char *getupvalname (CallInfo *ci, const TValue *o,\n                                 const char **name) {\n  LClosure *c = ci_func(ci);\n  int i;\n  for (i = 0; i < c->nupvalues; i++) {\n    if (c->upvals[i]->v.p == o) {\n      *name = upvalname(c->p, i);\n      return \"upvalue\";\n    }\n  }\n  return NULL;\n}\n\n\nstatic const char *formatvarinfo (lua_State *L, const char *kind,\n                                                const char *name) {\n  if (kind == NULL)\n    return \"\";  /* no information */\n  else\n    return luaO_pushfstring(L, \" (%s '%s')\", kind, name);\n}\n\n/*\n** Build a string with a \"description\" for the value 'o', such as\n** \"variable 'x'\" or \"upvalue 'y'\".\n*/\nstatic const char *varinfo (lua_State *L, const TValue *o) {\n  CallInfo *ci = L->ci;\n  const char *name = NULL;  /* to avoid warnings */\n  const char *kind = NULL;\n  if (isLua(ci)) {\n    kind = getupvalname(ci, o, &name);  /* check whether 'o' is an upvalue */\n    if (!kind) {  /* not an upvalue? */\n      int reg = instack(ci, o);  /* try a register */\n      if (reg >= 0)  /* is 'o' a register? */\n        kind = getobjname(ci_func(ci)->p, currentpc(ci), reg, &name);\n    }\n  }\n  return formatvarinfo(L, kind, name);\n}\n\n\n/*\n** Raise a type error\n*/\nstatic l_noret typeerror (lua_State *L, const TValue *o, const char *op,\n                          const char *extra) {\n  const char *t = luaT_objtypename(L, o);\n  luaG_runerror(L, \"attempt to %s a %s value%s\", op, t, extra);\n}\n\n\n/*\n** Raise a type error with \"standard\" information about the faulty\n** object 'o' (using 'varinfo').\n*/\nl_noret luaG_typeerror (lua_State *L, const TValue *o, const char *op) {\n  typeerror(L, o, op, varinfo(L, o));\n}\n\n\n/*\n** Raise an error for calling a non-callable object. Try to find a name\n** for the object based on how it was called ('funcnamefromcall'); if it\n** cannot get a name there, try 'varinfo'.\n*/\nl_noret luaG_callerror (lua_State *L, const TValue *o) {\n  CallInfo *ci = L->ci;\n  const char *name = NULL;  /* to avoid warnings */\n  const char *kind = funcnamefromcall(L, ci, &name);\n  const char *extra = kind ? formatvarinfo(L, kind, name) : varinfo(L, o);\n  typeerror(L, o, \"call\", extra);\n}\n\n\nl_noret luaG_forerror (lua_State *L, const TValue *o, const char *what) {\n  luaG_runerror(L, \"bad 'for' %s (number expected, got %s)\",\n                   what, luaT_objtypename(L, o));\n}\n\n\nl_noret luaG_concaterror (lua_State *L, const TValue *p1, const TValue *p2) {\n  if (ttisstring(p1) || cvt2str(p1)) p1 = p2;\n  luaG_typeerror(L, p1, \"concatenate\");\n}\n\n\nl_noret luaG_opinterror (lua_State *L, const TValue *p1,\n                         const TValue *p2, const char *msg) {\n  if (!ttisnumber(p1))  /* first operand is wrong? */\n    p2 = p1;  /* now second is wrong */\n  luaG_typeerror(L, p2, msg);\n}\n\n\n/*\n** Error when both values are convertible to numbers, but not to integers\n*/\nl_noret luaG_tointerror (lua_State *L, const TValue *p1, const TValue *p2) {\n  lua_Integer temp;\n  if (!luaV_tointegerns(p1, &temp, LUA_FLOORN2I))\n    p2 = p1;\n  luaG_runerror(L, \"number%s has no integer representation\", varinfo(L, p2));\n}\n\n\nl_noret luaG_ordererror (lua_State *L, const TValue *p1, const TValue *p2) {\n  const char *t1 = luaT_objtypename(L, p1);\n  const char *t2 = luaT_objtypename(L, p2);\n  if (strcmp(t1, t2) == 0)\n    luaG_runerror(L, \"attempt to compare two %s values\", t1);\n  else\n    luaG_runerror(L, \"attempt to compare %s with %s\", t1, t2);\n}\n\n\n/* add src:line information to 'msg' */\nconst char *luaG_addinfo (lua_State *L, const char *msg, TString *src,\n                                        int line) {\n  char buff[LUA_IDSIZE];\n  if (src) {\n    size_t idlen;\n    const char *id = getlstr(src, idlen);\n    luaO_chunkid(buff, id, idlen);\n  }\n  else {  /* no source available; use \"?\" instead */\n    buff[0] = '?'; buff[1] = '\\0';\n  }\n  return luaO_pushfstring(L, \"%s:%d: %s\", buff, line, msg);\n}\n\n\nl_noret luaG_errormsg (lua_State *L) {\n  if (L->errfunc != 0) {  /* is there an error handling function? */\n    StkId errfunc = restorestack(L, L->errfunc);\n    lua_assert(ttisfunction(s2v(errfunc)));\n    setobjs2s(L, L->top.p, L->top.p - 1);  /* move argument */\n    setobjs2s(L, L->top.p - 1, errfunc);  /* push function */\n    L->top.p++;  /* assume EXTRA_STACK */\n    luaD_callnoyield(L, L->top.p - 2, 1);  /* call it */\n  }\n  luaD_throw(L, LUA_ERRRUN);\n}\n\n\nl_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  /* error message uses memory */\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  /* format message */\n  va_end(argp);\n  if (msg != NULL && isLua(ci)) {  /* Lua function? (and no error) */\n    /* add source:line information */\n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n    setobjs2s(L, L->top.p - 2, L->top.p - 1);  /* remove 'msg' */\n    L->top.p--;\n  }\n  luaG_errormsg(L);\n}\n\n\n/*\n** Check whether new instruction 'newpc' is in a different line from\n** previous instruction 'oldpc'. More often than not, 'newpc' is only\n** one or a few instructions after 'oldpc' (it must be after, see\n** caller), so try to avoid calling 'luaG_getfuncline'. If they are\n** too far apart, there is a good chance of a ABSLINEINFO in the way,\n** so it goes directly to 'luaG_getfuncline'.\n*/\nstatic int changedline (const Proto *p, int oldpc, int newpc) {\n  if (p->lineinfo == NULL)  /* no debug information? */\n    return 0;\n  if (newpc - oldpc < MAXIWTHABS / 2) {  /* not too far apart? */\n    int delta = 0;  /* line difference */\n    int pc = oldpc;\n    for (;;) {\n      int lineinfo = p->lineinfo[++pc];\n      if (lineinfo == ABSLINEINFO)\n        break;  /* cannot compute delta; fall through */\n      delta += lineinfo;\n      if (pc == newpc)\n        return (delta != 0);  /* delta computed successfully */\n    }\n  }\n  /* either instructions are too far apart or there is an absolute line\n     info in the way; compute line difference explicitly */\n  return (luaG_getfuncline(p, oldpc) != luaG_getfuncline(p, newpc));\n}\n\n\n/*\n** Traces Lua calls. If code is running the first instruction of a function,\n** and function is not vararg, and it is not coming from an yield,\n** calls 'luaD_hookcall'. (Vararg functions will call 'luaD_hookcall'\n** after adjusting its variable arguments; otherwise, they could call\n** a line/count hook before the call hook. Functions coming from\n** an yield already called 'luaD_hookcall' before yielding.)\n*/\nint luaG_tracecall (lua_State *L) {\n  CallInfo *ci = L->ci;\n  Proto *p = ci_func(ci)->p;\n  ci->u.l.trap = 1;  /* ensure hooks will be checked */\n  if (ci->u.l.savedpc == p->code) {  /* first instruction (not resuming)? */\n    if (p->flag & PF_ISVARARG)\n      return 0;  /* hooks will start at VARARGPREP instruction */\n    else if (!(ci->callstatus & CIST_HOOKYIELD))  /* not yieded? */\n      luaD_hookcall(L, ci);  /* check 'call' hook */\n  }\n  return 1;  /* keep 'trap' on */\n}\n\n\n/*\n** Traces the execution of a Lua function. Called before the execution\n** of each opcode, when debug is on. 'L->oldpc' stores the last\n** instruction traced, to detect line changes. When entering a new\n** function, 'npci' will be zero and will test as a new line whatever\n** the value of 'oldpc'.  Some exceptional conditions may return to\n** a function without setting 'oldpc'. In that case, 'oldpc' may be\n** invalid; if so, use zero as a valid value. (A wrong but valid 'oldpc'\n** at most causes an extra call to a line hook.)\n** This function is not \"Protected\" when called, so it should correct\n** 'L->top.p' before calling anything that can run the GC.\n*/\nint luaG_traceexec (lua_State *L, const Instruction *pc) {\n  CallInfo *ci = L->ci;\n  lu_byte mask = cast_byte(L->hookmask);\n  const Proto *p = ci_func(ci)->p;\n  int counthook;\n  if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  /* no hooks? */\n    ci->u.l.trap = 0;  /* don't need to stop again */\n    return 0;  /* turn off 'trap' */\n  }\n  pc++;  /* reference is always next instruction */\n  ci->u.l.savedpc = pc;  /* save 'pc' */\n  counthook = (mask & LUA_MASKCOUNT) && (--L->hookcount == 0);\n  if (counthook)\n    resethookcount(L);  /* reset count */\n  else if (!(mask & LUA_MASKLINE))\n    return 1;  /* no line hook and count != 0; nothing to be done now */\n  if (ci->callstatus & CIST_HOOKYIELD) {  /* hook yielded last time? */\n    ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */\n    return 1;  /* do not call hook again (VM yielded, so it did not move) */\n  }\n  if (!luaP_isIT(*(ci->u.l.savedpc - 1)))  /* top not being used? */\n    L->top.p = ci->top.p;  /* correct top */\n  if (counthook)\n    luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  /* call count hook */\n  if (mask & LUA_MASKLINE) {\n    /* 'L->oldpc' may be invalid; use zero in this case */\n    int oldpc = (L->oldpc < p->sizecode) ? L->oldpc : 0;\n    int npci = pcRel(pc, p);\n    if (npci <= oldpc ||  /* call hook when jump back (loop), */\n        changedline(p, oldpc, npci)) {  /* or when enter new line */\n      int newline = luaG_getfuncline(p, npci);\n      luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  /* call line hook */\n    }\n    L->oldpc = npci;  /* 'pc' of last call to line hook */\n  }\n  if (L->status == LUA_YIELD) {  /* did hook yield? */\n    if (counthook)\n      L->hookcount = 1;  /* undo decrement to zero */\n    ci->callstatus |= CIST_HOOKYIELD;  /* mark that it yielded */\n    luaD_throw(L, LUA_YIELD);\n  }\n  return 1;  /* keep 'trap' on */\n}\n\n"
        },
        {
          "name": "ldebug.h",
          "type": "blob",
          "size": 2.1630859375,
          "content": "/*\n** $Id: ldebug.h $\n** Auxiliary functions from Debug Interface module\n** See Copyright Notice in lua.h\n*/\n\n#ifndef ldebug_h\n#define ldebug_h\n\n\n#include \"lstate.h\"\n\n\n#define pcRel(pc, p)\t(cast_int((pc) - (p)->code) - 1)\n\n\n/* Active Lua function (given call info) */\n#define ci_func(ci)\t\t(clLvalue(s2v((ci)->func.p)))\n\n\n#define resethookcount(L)\t(L->hookcount = L->basehookcount)\n\n/*\n** mark for entries in 'lineinfo' array that has absolute information in\n** 'abslineinfo' array\n*/\n#define ABSLINEINFO\t(-0x80)\n\n\n/*\n** MAXimum number of successive Instructions WiTHout ABSolute line\n** information. (A power of two allows fast divisions.)\n*/\n#if !defined(MAXIWTHABS)\n#define MAXIWTHABS\t128\n#endif\n\n\nLUAI_FUNC int luaG_getfuncline (const Proto *f, int pc);\nLUAI_FUNC const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n,\n                                                    StkId *pos);\nLUAI_FUNC l_noret luaG_typeerror (lua_State *L, const TValue *o,\n                                                const char *opname);\nLUAI_FUNC l_noret luaG_callerror (lua_State *L, const TValue *o);\nLUAI_FUNC l_noret luaG_forerror (lua_State *L, const TValue *o,\n                                               const char *what);\nLUAI_FUNC l_noret luaG_concaterror (lua_State *L, const TValue *p1,\n                                                  const TValue *p2);\nLUAI_FUNC l_noret luaG_opinterror (lua_State *L, const TValue *p1,\n                                                 const TValue *p2,\n                                                 const char *msg);\nLUAI_FUNC l_noret luaG_tointerror (lua_State *L, const TValue *p1,\n                                                 const TValue *p2);\nLUAI_FUNC l_noret luaG_ordererror (lua_State *L, const TValue *p1,\n                                                 const TValue *p2);\nLUAI_FUNC l_noret luaG_runerror (lua_State *L, const char *fmt, ...);\nLUAI_FUNC const char *luaG_addinfo (lua_State *L, const char *msg,\n                                                  TString *src, int line);\nLUAI_FUNC l_noret luaG_errormsg (lua_State *L);\nLUAI_FUNC int luaG_traceexec (lua_State *L, const Instruction *pc);\nLUAI_FUNC int luaG_tracecall (lua_State *L);\n\n\n#endif\n"
        },
        {
          "name": "ldo.c",
          "type": "blob",
          "size": 36.6806640625,
          "content": "/*\n** $Id: ldo.c $\n** Stack and Call structure of Lua\n** See Copyright Notice in lua.h\n*/\n\n#define ldo_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <setjmp.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lundump.h\"\n#include \"lvm.h\"\n#include \"lzio.h\"\n\n\n\n#define errorstatus(s)\t((s) > LUA_YIELD)\n\n\n/*\n** these macros allow user-specific actions when a thread is\n** resumed/yielded.\n*/\n#if !defined(luai_userstateresume)\n#define luai_userstateresume(L,n)\t((void)L)\n#endif\n\n#if !defined(luai_userstateyield)\n#define luai_userstateyield(L,n)\t((void)L)\n#endif\n\n\n/*\n** {======================================================\n** Error-recovery functions\n** =======================================================\n*/\n\n/*\n** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By\n** default, Lua handles errors with exceptions when compiling as\n** C++ code, with _longjmp/_setjmp when asked to use them, and with\n** longjmp/setjmp otherwise.\n*/\n#if !defined(LUAI_THROW)\t\t\t\t/* { */\n\n#if defined(__cplusplus) && !defined(LUA_USE_LONGJMP)\t/* { */\n\n/* C++ exceptions */\n#define LUAI_THROW(L,c)\t\tthrow(c)\n#define LUAI_TRY(L,c,f,ud) \\\n    try { (f)(L, ud); } catch(...) { if ((c)->status == 0) (c)->status = -1; }\n#define luai_jmpbuf\t\tint  /* dummy field */\n\n#elif defined(LUA_USE_POSIX)\t\t\t\t/* }{ */\n\n/* in POSIX, try _longjmp/_setjmp (more efficient) */\n#define LUAI_THROW(L,c)\t\t_longjmp((c)->b, 1)\n#define LUAI_TRY(L,c,f,ud)\tif (_setjmp((c)->b) == 0) ((f)(L, ud))\n#define luai_jmpbuf\t\tjmp_buf\n\n#else\t\t\t\t\t\t\t/* }{ */\n\n/* ISO C handling with long jumps */\n#define LUAI_THROW(L,c)\t\tlongjmp((c)->b, 1)\n#define LUAI_TRY(L,c,f,ud)\tif (setjmp((c)->b) == 0) ((f)(L, ud))\n#define luai_jmpbuf\t\tjmp_buf\n\n#endif\t\t\t\t\t\t\t/* } */\n\n#endif\t\t\t\t\t\t\t/* } */\n\n\n\n/* chain list of long jump buffers */\nstruct lua_longjmp {\n  struct lua_longjmp *previous;\n  luai_jmpbuf b;\n  volatile int status;  /* error code */\n};\n\n\nvoid luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop) {\n  switch (errcode) {\n    case LUA_ERRMEM: {  /* memory error? */\n      setsvalue2s(L, oldtop, G(L)->memerrmsg); /* reuse preregistered msg. */\n      break;\n    }\n    case LUA_ERRERR: {\n      setsvalue2s(L, oldtop, luaS_newliteral(L, \"error in error handling\"));\n      break;\n    }\n    case LUA_OK: {  /* special case only for closing upvalues */\n      setnilvalue(s2v(oldtop));  /* no error message */\n      break;\n    }\n    default: {\n      lua_assert(errorstatus(errcode));  /* real error */\n      setobjs2s(L, oldtop, L->top.p - 1);  /* error message on current top */\n      break;\n    }\n  }\n  L->top.p = oldtop + 1;\n}\n\n\nl_noret luaD_throw (lua_State *L, int errcode) {\n  if (L->errorJmp) {  /* thread has an error handler? */\n    L->errorJmp->status = errcode;  /* set status */\n    LUAI_THROW(L, L->errorJmp);  /* jump to it */\n  }\n  else {  /* thread has no error handler */\n    global_State *g = G(L);\n    errcode = luaE_resetthread(L, errcode);  /* close all upvalues */\n    if (g->mainthread->errorJmp) {  /* main thread has a handler? */\n      setobjs2s(L, g->mainthread->top.p++, L->top.p - 1);  /* copy error obj. */\n      luaD_throw(g->mainthread, errcode);  /* re-throw in main thread */\n    }\n    else {  /* no handler at all; abort */\n      if (g->panic) {  /* panic function? */\n        lua_unlock(L);\n        g->panic(L);  /* call panic function (last chance to jump out) */\n      }\n      abort();\n    }\n  }\n}\n\n\nint luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud) {\n  l_uint32 oldnCcalls = L->nCcalls;\n  struct lua_longjmp lj;\n  lj.status = LUA_OK;\n  lj.previous = L->errorJmp;  /* chain new error handler */\n  L->errorJmp = &lj;\n  LUAI_TRY(L, &lj, f, ud);  /* call 'f' catching errors */\n  L->errorJmp = lj.previous;  /* restore old error handler */\n  L->nCcalls = oldnCcalls;\n  return lj.status;\n}\n\n/* }====================================================== */\n\n\n/*\n** {==================================================================\n** Stack reallocation\n** ===================================================================\n*/\n\n/* some stack space for error handling */\n#define STACKERRSPACE\t200\n\n\n/* maximum stack size that respects size_t */\n#define MAXSTACK_BYSIZET  ((MAX_SIZET / sizeof(StackValue)) - STACKERRSPACE)\n\n/*\n** Minimum between LUAI_MAXSTACK and MAXSTACK_BYSIZET\n** (Maximum size for the stack must respect size_t.)\n*/\n#define MAXSTACK\tcast_int(LUAI_MAXSTACK < MAXSTACK_BYSIZET  \\\n\t\t\t        ? LUAI_MAXSTACK : MAXSTACK_BYSIZET)\n\n\n/* stack size with extra space for error handling */\n#define ERRORSTACKSIZE\t(MAXSTACK + STACKERRSPACE)\n\n\n/*\n** In ISO C, any pointer use after the pointer has been deallocated is\n** undefined behavior. So, before a stack reallocation, all pointers are\n** changed to offsets, and after the reallocation they are changed back\n** to pointers. As during the reallocation the pointers are invalid, the\n** reallocation cannot run emergency collections.\n**\n*/\n\n#if 1\n/*\n** Change all pointers to the stack into offsets.\n*/\nstatic void relstack (lua_State *L) {\n  CallInfo *ci;\n  UpVal *up;\n  L->top.offset = savestack(L, L->top.p);\n  L->tbclist.offset = savestack(L, L->tbclist.p);\n  for (up = L->openupval; up != NULL; up = up->u.open.next)\n    up->v.offset = savestack(L, uplevel(up));\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    ci->top.offset = savestack(L, ci->top.p);\n    ci->func.offset = savestack(L, ci->func.p);\n  }\n}\n\n\n/*\n** Change back all offsets into pointers.\n*/\nstatic void correctstack (lua_State *L, StkId oldstack) {\n  CallInfo *ci;\n  UpVal *up;\n  UNUSED(oldstack);\n  L->top.p = restorestack(L, L->top.offset);\n  L->tbclist.p = restorestack(L, L->tbclist.offset);\n  for (up = L->openupval; up != NULL; up = up->u.open.next)\n    up->v.p = s2v(restorestack(L, up->v.offset));\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    ci->top.p = restorestack(L, ci->top.offset);\n    ci->func.p = restorestack(L, ci->func.offset);\n    if (isLua(ci))\n      ci->u.l.trap = 1;  /* signal to update 'trap' in 'luaV_execute' */\n  }\n}\n\n#else\n/*\n** Alternatively, we can use the old address after the dealocation.\n** That is not strict ISO C, but seems to work fine everywhere.\n*/\n\nstatic void relstack (lua_State *L) { UNUSED(L); }\n\nstatic void correctstack (lua_State *L, StkId oldstack) {\n  CallInfo *ci;\n  UpVal *up;\n  StkId newstack = L->stack.p;\n  if (oldstack == newstack)\n    return;\n  L->top.p = L->top.p - oldstack + newstack;\n  L->tbclist.p = L->tbclist.p - oldstack + newstack;\n  for (up = L->openupval; up != NULL; up = up->u.open.next)\n    up->v.p = s2v(uplevel(up) - oldstack + newstack);\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    ci->top.p = ci->top.p - oldstack + newstack;\n    ci->func.p = ci->func.p - oldstack + newstack;\n    if (isLua(ci))\n      ci->u.l.trap = 1;  /* signal to update 'trap' in 'luaV_execute' */\n  }\n}\n\n#endif\n\n\n/*\n** Reallocate the stack to a new size, correcting all pointers into it.\n** In case of allocation error, raise an error or return false according\n** to 'raiseerror'.\n*/\nint luaD_reallocstack (lua_State *L, int newsize, int raiseerror) {\n  int oldsize = stacksize(L);\n  int i;\n  StkId newstack;\n  StkId oldstack = L->stack.p;\n  lu_byte oldgcstop = G(L)->gcstopem;\n  lua_assert(newsize <= MAXSTACK || newsize == ERRORSTACKSIZE);\n  relstack(L);  /* change pointers to offsets */\n  G(L)->gcstopem = 1;  /* stop emergency collection */\n  newstack = luaM_reallocvector(L, oldstack, oldsize + EXTRA_STACK,\n                                   newsize + EXTRA_STACK, StackValue);\n  G(L)->gcstopem = oldgcstop;  /* restore emergency collection */\n  if (l_unlikely(newstack == NULL)) {  /* reallocation failed? */\n    correctstack(L, oldstack);  /* change offsets back to pointers */\n    if (raiseerror)\n      luaM_error(L);\n    else return 0;  /* do not raise an error */\n  }\n  L->stack.p = newstack;\n  correctstack(L, oldstack);  /* change offsets back to pointers */\n  L->stack_last.p = L->stack.p + newsize;\n  for (i = oldsize + EXTRA_STACK; i < newsize + EXTRA_STACK; i++)\n    setnilvalue(s2v(newstack + i)); /* erase new segment */\n  return 1;\n}\n\n\n/*\n** Try to grow the stack by at least 'n' elements. When 'raiseerror'\n** is true, raises any error; otherwise, return 0 in case of errors.\n*/\nint luaD_growstack (lua_State *L, int n, int raiseerror) {\n  int size = stacksize(L);\n  if (l_unlikely(size > MAXSTACK)) {\n    /* if stack is larger than maximum, thread is already using the\n       extra space reserved for errors, that is, thread is handling\n       a stack error; cannot grow further than that. */\n    lua_assert(stacksize(L) == ERRORSTACKSIZE);\n    if (raiseerror)\n      luaD_throw(L, LUA_ERRERR);  /* error inside message handler */\n    return 0;  /* if not 'raiseerror', just signal it */\n  }\n  else if (n < MAXSTACK) {  /* avoids arithmetic overflows */\n    int newsize = 2 * size;  /* tentative new size */\n    int needed = cast_int(L->top.p - L->stack.p) + n;\n    if (newsize > MAXSTACK)  /* cannot cross the limit */\n      newsize = MAXSTACK;\n    if (newsize < needed)  /* but must respect what was asked for */\n      newsize = needed;\n    if (l_likely(newsize <= MAXSTACK))\n      return luaD_reallocstack(L, newsize, raiseerror);\n  }\n  /* else stack overflow */\n  /* add extra size to be able to handle the error message */\n  luaD_reallocstack(L, ERRORSTACKSIZE, raiseerror);\n  if (raiseerror)\n    luaG_runerror(L, \"stack overflow\");\n  return 0;\n}\n\n\n/*\n** Compute how much of the stack is being used, by computing the\n** maximum top of all call frames in the stack and the current top.\n*/\nstatic int stackinuse (lua_State *L) {\n  CallInfo *ci;\n  int res;\n  StkId lim = L->top.p;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {\n    if (lim < ci->top.p) lim = ci->top.p;\n  }\n  lua_assert(lim <= L->stack_last.p + EXTRA_STACK);\n  res = cast_int(lim - L->stack.p) + 1;  /* part of stack in use */\n  if (res < LUA_MINSTACK)\n    res = LUA_MINSTACK;  /* ensure a minimum size */\n  return res;\n}\n\n\n/*\n** If stack size is more than 3 times the current use, reduce that size\n** to twice the current use. (So, the final stack size is at most 2/3 the\n** previous size, and half of its entries are empty.)\n** As a particular case, if stack was handling a stack overflow and now\n** it is not, 'max' (limited by MAXSTACK) will be smaller than\n** stacksize (equal to ERRORSTACKSIZE in this case), and so the stack\n** will be reduced to a \"regular\" size.\n*/\nvoid luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int max = (inuse > MAXSTACK / 3) ? MAXSTACK : inuse * 3;\n  /* if thread is currently not handling a stack overflow and its\n     size is larger than maximum \"reasonable\" size, shrink it */\n  if (inuse <= MAXSTACK && stacksize(L) > max) {\n    int nsize = (inuse > MAXSTACK / 2) ? MAXSTACK : inuse * 2;\n    luaD_reallocstack(L, nsize, 0);  /* ok if that fails */\n  }\n  else  /* don't change stack */\n    condmovestack(L,{},{});  /* (change only for debugging) */\n  luaE_shrinkCI(L);  /* shrink CI list */\n}\n\n\nvoid luaD_inctop (lua_State *L) {\n  luaD_checkstack(L, 1);\n  L->top.p++;\n}\n\n/* }================================================================== */\n\n\n/*\n** Call a hook for the given event. Make sure there is a hook to be\n** called. (Both 'L->hook' and 'L->hookmask', which trigger this\n** function, can be changed asynchronously by signals.)\n*/\nvoid luaD_hook (lua_State *L, int event, int line,\n                              int ftransfer, int ntransfer) {\n  lua_Hook hook = L->hook;\n  if (hook && L->allowhook) {  /* make sure there is a hook */\n    CallInfo *ci = L->ci;\n    ptrdiff_t top = savestack(L, L->top.p);  /* preserve original 'top' */\n    ptrdiff_t ci_top = savestack(L, ci->top.p);  /* idem for 'ci->top' */\n    lua_Debug ar;\n    ar.event = event;\n    ar.currentline = line;\n    ar.i_ci = ci;\n    L->transferinfo.ftransfer = ftransfer;\n    L->transferinfo.ntransfer = ntransfer;\n    if (isLua(ci) && L->top.p < ci->top.p)\n      L->top.p = ci->top.p;  /* protect entire activation register */\n    luaD_checkstack(L, LUA_MINSTACK);  /* ensure minimum stack size */\n    if (ci->top.p < L->top.p + LUA_MINSTACK)\n      ci->top.p = L->top.p + LUA_MINSTACK;\n    L->allowhook = 0;  /* cannot call hooks inside a hook */\n    ci->callstatus |= CIST_HOOKED;\n    lua_unlock(L);\n    (*hook)(L, &ar);\n    lua_lock(L);\n    lua_assert(!L->allowhook);\n    L->allowhook = 1;\n    ci->top.p = restorestack(L, ci_top);\n    L->top.p = restorestack(L, top);\n    ci->callstatus &= ~CIST_HOOKED;\n  }\n}\n\n\n/*\n** Executes a call hook for Lua functions. This function is called\n** whenever 'hookmask' is not zero, so it checks whether call hooks are\n** active.\n*/\nvoid luaD_hookcall (lua_State *L, CallInfo *ci) {\n  L->oldpc = 0;  /* set 'oldpc' for new function */\n  if (L->hookmask & LUA_MASKCALL) {  /* is call hook on? */\n    int event = (ci->callstatus & CIST_TAIL) ? LUA_HOOKTAILCALL\n                                             : LUA_HOOKCALL;\n    Proto *p = ci_func(ci)->p;\n    ci->u.l.savedpc++;  /* hooks assume 'pc' is already incremented */\n    luaD_hook(L, event, -1, 1, p->numparams);\n    ci->u.l.savedpc--;  /* correct 'pc' */\n  }\n}\n\n\n/*\n** Executes a return hook for Lua and C functions and sets/corrects\n** 'oldpc'. (Note that this correction is needed by the line hook, so it\n** is done even when return hooks are off.)\n*/\nstatic void rethook (lua_State *L, CallInfo *ci, int nres) {\n  if (L->hookmask & LUA_MASKRET) {  /* is return hook on? */\n    StkId firstres = L->top.p - nres;  /* index of first result */\n    int delta = 0;  /* correction for vararg functions */\n    int ftransfer;\n    if (isLua(ci)) {\n      Proto *p = ci_func(ci)->p;\n      if (p->flag & PF_ISVARARG)\n        delta = ci->u.l.nextraargs + p->numparams + 1;\n    }\n    ci->func.p += delta;  /* if vararg, back to virtual 'func' */\n    ftransfer = cast_int(firstres - ci->func.p);\n    luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  /* call it */\n    ci->func.p -= delta;\n  }\n  if (isLua(ci = ci->previous))\n    L->oldpc = pcRel(ci->u.l.savedpc, ci_func(ci)->p);  /* set 'oldpc' */\n}\n\n\n/*\n** Check whether 'func' has a '__call' metafield. If so, put it in the\n** stack, below original 'func', so that 'luaD_precall' can call it.\n** Raise an error if there is no '__call' metafield.\n** Bits CIST_CCMT in status count how many _call metamethods were\n** invoked and how many corresponding extra arguments were pushed.\n** (This count will be saved in the 'callstatus' of the call).\n**  Raise an error if this counter overflows.\n*/\nstatic unsigned tryfuncTM (lua_State *L, StkId func, unsigned status) {\n  const TValue *tm;\n  StkId p;\n  tm = luaT_gettmbyobj(L, s2v(func), TM_CALL);\n  if (l_unlikely(ttisnil(tm)))  /* no metamethod? */\n    luaG_callerror(L, s2v(func));\n  for (p = L->top.p; p > func; p--)  /* open space for metamethod */\n    setobjs2s(L, p, p-1);\n  L->top.p++;  /* stack space pre-allocated by the caller */\n  setobj2s(L, func, tm);  /* metamethod is the new function to be called */\n  if ((status & MAX_CCMT) == MAX_CCMT)  /* is counter full? */\n    luaG_runerror(L, \"'__call' chain too long\");\n  return status + (1u << CIST_CCMT);  /* increment counter */\n}\n\n\n/* Generic case for 'moveresult */\nl_sinline void genmoveresults (lua_State *L, StkId res, int nres,\n                                             int wanted) {\n  StkId firstresult = L->top.p - nres;  /* index of first result */\n  int i;\n  if (nres > wanted)  /* extra results? */\n    nres = wanted;  /* don't need them */\n  for (i = 0; i < nres; i++)  /* move all results to correct place */\n    setobjs2s(L, res + i, firstresult + i);\n  for (; i < wanted; i++)  /* complete wanted number of results */\n    setnilvalue(s2v(res + i));\n  L->top.p = res + wanted;  /* top points after the last result */\n}\n\n\n/*\n** Given 'nres' results at 'firstResult', move 'fwanted-1' of them\n** to 'res'.  Handle most typical cases (zero results for commands,\n** one result for expressions, multiple results for tail calls/single\n** parameters) separated. The flag CIST_CLSRET in 'fwanted', if set,\n** forces the swicth to go to the default case.\n*/\nl_sinline void moveresults (lua_State *L, StkId res, int nres,\n                                          l_uint32 fwanted) {\n  switch (fwanted) {  /* handle typical cases separately */\n    case 0 + 1:  /* no values needed */\n      L->top.p = res;\n      return;\n    case 1 + 1:  /* one value needed */\n      if (nres == 0)   /* no results? */\n        setnilvalue(s2v(res));  /* adjust with nil */\n      else  /* at least one result */\n        setobjs2s(L, res, L->top.p - nres);  /* move it to proper place */\n      L->top.p = res + 1;\n      return;\n    case LUA_MULTRET + 1:\n      genmoveresults(L, res, nres, nres);  /* we want all results */\n      break;\n    default: {  /* two/more results and/or to-be-closed variables */\n      int wanted = get_nresults(fwanted);\n      if (fwanted & CIST_CLSRET) {  /* to-be-closed variables? */\n        L->ci->u2.nres = nres;\n        res = luaF_close(L, res, CLOSEKTOP, 1);\n        L->ci->callstatus &= ~CIST_CLSRET;\n        if (L->hookmask) {  /* if needed, call hook after '__close's */\n          ptrdiff_t savedres = savestack(L, res);\n          rethook(L, L->ci, nres);\n          res = restorestack(L, savedres);  /* hook can move stack */\n        }\n        if (wanted == LUA_MULTRET)\n          wanted = nres;  /* we want all results */\n      }\n      genmoveresults(L, res, nres, wanted);\n      break;\n    }\n  }\n}\n\n\n/*\n** Finishes a function call: calls hook if necessary, moves current\n** number of results to proper place, and returns to previous call\n** info. If function has to close variables, hook must be called after\n** that.\n*/\nvoid luaD_poscall (lua_State *L, CallInfo *ci, int nres) {\n  l_uint32 fwanted = ci->callstatus & (CIST_CLSRET | CIST_NRESULTS);\n  if (l_unlikely(L->hookmask) && !(fwanted & CIST_CLSRET))\n    rethook(L, ci, nres);\n  /* move results to proper place */\n  moveresults(L, ci->func.p, nres, fwanted);\n  /* function cannot be in any of these cases when returning */\n  lua_assert(!(ci->callstatus &\n        (CIST_HOOKED | CIST_YPCALL | CIST_FIN | CIST_CLSRET)));\n  L->ci = ci->previous;  /* back to caller (after closing variables) */\n}\n\n\n\n#define next_ci(L)  (L->ci->next ? L->ci->next : luaE_extendCI(L))\n\n\n/*\n** Allocate and initialize CallInfo structure. At this point, the\n** only valid fields in the call status are number of results,\n** CIST_C (if it's a C function), and number of extra arguments.\n** (All these bit-fields fit in 16-bit values.)\n*/\nl_sinline CallInfo *prepCallInfo (lua_State *L, StkId func, unsigned status,\n                                                StkId top) {\n  CallInfo *ci = L->ci = next_ci(L);  /* new frame */\n  ci->func.p = func;\n  lua_assert((status & ~(CIST_NRESULTS | CIST_C | MAX_CCMT)) == 0);\n  ci->callstatus = status;\n  ci->top.p = top;\n  return ci;\n}\n\n\n/*\n** precall for C functions\n*/\nl_sinline int precallC (lua_State *L, StkId func, unsigned status,\n                                            lua_CFunction f) {\n  int n;  /* number of returns */\n  CallInfo *ci;\n  checkstackp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */\n  L->ci = ci = prepCallInfo(L, func, status | CIST_C,\n                               L->top.p + LUA_MINSTACK);\n  lua_assert(ci->top.p <= L->stack_last.p);\n  if (l_unlikely(L->hookmask & LUA_MASKCALL)) {\n    int narg = cast_int(L->top.p - func) - 1;\n    luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n  }\n  lua_unlock(L);\n  n = (*f)(L);  /* do the actual call */\n  lua_lock(L);\n  api_checknelems(L, n);\n  luaD_poscall(L, ci, n);\n  return n;\n}\n\n\n/*\n** Prepare a function for a tail call, building its call info on top\n** of the current call info. 'narg1' is the number of arguments plus 1\n** (so that it includes the function itself). Return the number of\n** results, if it was a C function, or -1 for a Lua function.\n*/\nint luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func,\n                                    int narg1, int delta) {\n  unsigned status = LUA_MULTRET + 1;\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  /* C closure */\n      return precallC(L, func, status, clCvalue(s2v(func))->f);\n    case LUA_VLCF:  /* light C function */\n      return precallC(L, func, status, fvalue(s2v(func)));\n    case LUA_VLCL: {  /* Lua function */\n      Proto *p = clLvalue(s2v(func))->p;\n      int fsize = p->maxstacksize;  /* frame size */\n      int nfixparams = p->numparams;\n      int i;\n      checkstackp(L, fsize - delta, func);\n      ci->func.p -= delta;  /* restore 'func' (if vararg) */\n      for (i = 0; i < narg1; i++)  /* move down function and arguments */\n        setobjs2s(L, ci->func.p + i, func + i);\n      func = ci->func.p;  /* moved-down function */\n      for (; narg1 <= nfixparams; narg1++)\n        setnilvalue(s2v(func + narg1));  /* complete missing arguments */\n      ci->top.p = func + 1 + fsize;  /* top for new function */\n      lua_assert(ci->top.p <= L->stack_last.p);\n      ci->u.l.savedpc = p->code;  /* starting point */\n      ci->callstatus |= CIST_TAIL;\n      L->top.p = func + narg1;  /* set top */\n      return -1;\n    }\n    default: {  /* not a function */\n      checkstackp(L, 1, func);  /* space for metamethod */\n      status = tryfuncTM(L, func, status);  /* try '__call' metamethod */\n      narg1++;\n      goto retry;  /* try again */\n    }\n  }\n}\n\n\n/*\n** Prepares the call to a function (C or Lua). For C functions, also do\n** the call. The function to be called is at '*func'.  The arguments\n** are on the stack, right after the function.  Returns the CallInfo\n** to be executed, if it was a Lua function. Otherwise (a C function)\n** returns NULL, with all the results on the stack, starting at the\n** original function position.\n*/\nCallInfo *luaD_precall (lua_State *L, StkId func, int nresults) {\n  unsigned status = cast_uint(nresults + 1);\n  lua_assert(status <= MAXRESULTS + 1);\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  /* C closure */\n      precallC(L, func, status, clCvalue(s2v(func))->f);\n      return NULL;\n    case LUA_VLCF:  /* light C function */\n      precallC(L, func, status, fvalue(s2v(func)));\n      return NULL;\n    case LUA_VLCL: {  /* Lua function */\n      CallInfo *ci;\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top.p - func) - 1;  /* number of real arguments */\n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  /* frame size */\n      checkstackp(L, fsize, func);\n      L->ci = ci = prepCallInfo(L, func, status, func + 1 + fsize);\n      ci->u.l.savedpc = p->code;  /* starting point */\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top.p++));  /* complete missing arguments */\n      lua_assert(ci->top.p <= L->stack_last.p);\n      return ci;\n    }\n    default: {  /* not a function */\n      checkstackp(L, 1, func);  /* space for metamethod */\n      status = tryfuncTM(L, func, status);  /* try '__call' metamethod */\n      goto retry;  /* try again with metamethod */\n    }\n  }\n}\n\n\n/*\n** Call a function (C or Lua) through C. 'inc' can be 1 (increment\n** number of recursive invocations in the C stack) or nyci (the same\n** plus increment number of non-yieldable calls).\n** This function can be called with some use of EXTRA_STACK, so it should\n** check the stack before doing anything else. 'luaD_precall' already\n** does that.\n*/\nl_sinline void ccall (lua_State *L, StkId func, int nResults, l_uint32 inc) {\n  CallInfo *ci;\n  L->nCcalls += inc;\n  if (l_unlikely(getCcalls(L) >= LUAI_MAXCCALLS)) {\n    checkstackp(L, 0, func);  /* free any use of EXTRA_STACK */\n    luaE_checkcstack(L);\n  }\n  if ((ci = luaD_precall(L, func, nResults)) != NULL) {  /* Lua function? */\n    ci->callstatus |= CIST_FRESH;  /* mark that it is a \"fresh\" execute */\n    luaV_execute(L, ci);  /* call it */\n  }\n  L->nCcalls -= inc;\n}\n\n\n/*\n** External interface for 'ccall'\n*/\nvoid luaD_call (lua_State *L, StkId func, int nResults) {\n  ccall(L, func, nResults, 1);\n}\n\n\n/*\n** Similar to 'luaD_call', but does not allow yields during the call.\n*/\nvoid luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  ccall(L, func, nResults, nyci);\n}\n\n\n/*\n** Finish the job of 'lua_pcallk' after it was interrupted by an yield.\n** (The caller, 'finishCcall', does the final call to 'adjustresults'.)\n** The main job is to complete the 'luaD_pcall' called by 'lua_pcallk'.\n** If a '__close' method yields here, eventually control will be back\n** to 'finishCcall' (when that '__close' method finally returns) and\n** 'finishpcallk' will run again and close any still pending '__close'\n** methods. Similarly, if a '__close' method errs, 'precover' calls\n** 'unroll' which calls ''finishCcall' and we are back here again, to\n** close any pending '__close' methods.\n** Note that, up to the call to 'luaF_close', the corresponding\n** 'CallInfo' is not modified, so that this repeated run works like the\n** first one (except that it has at least one less '__close' to do). In\n** particular, field CIST_RECST preserves the error status across these\n** multiple runs, changing only if there is a new error.\n*/\nstatic int finishpcallk (lua_State *L,  CallInfo *ci) {\n  int status = getcistrecst(ci);  /* get original status */\n  if (l_likely(status == LUA_OK))  /* no error? */\n    status = LUA_YIELD;  /* was interrupted by an yield */\n  else {  /* error */\n    StkId func = restorestack(L, ci->u2.funcidx);\n    L->allowhook = getoah(ci);  /* restore 'allowhook' */\n    func = luaF_close(L, func, status, 1);  /* can yield or raise an error */\n    luaD_seterrorobj(L, status, func);\n    luaD_shrinkstack(L);   /* restore stack size in case of overflow */\n    setcistrecst(ci, LUA_OK);  /* clear original status */\n  }\n  ci->callstatus &= ~CIST_YPCALL;\n  L->errfunc = ci->u.c.old_errfunc;\n  /* if it is here, there were errors or yields; unlike 'lua_pcallk',\n     do not change status */\n  return status;\n}\n\n\n/*\n** Completes the execution of a C function interrupted by an yield.\n** The interruption must have happened while the function was either\n** closing its tbc variables in 'moveresults' or executing\n** 'lua_callk'/'lua_pcallk'. In the first case, it just redoes\n** 'luaD_poscall'. In the second case, the call to 'finishpcallk'\n** finishes the interrupted execution of 'lua_pcallk'.  After that, it\n** calls the continuation of the interrupted function and finally it\n** completes the job of the 'luaD_call' that called the function.  In\n** the call to 'adjustresults', we do not know the number of results\n** of the function called by 'lua_callk'/'lua_pcallk', so we are\n** conservative and use LUA_MULTRET (always adjust).\n*/\nstatic void finishCcall (lua_State *L, CallInfo *ci) {\n  int n;  /* actual number of results from C function */\n  if (ci->callstatus & CIST_CLSRET) {  /* was returning? */\n    n = ci->u2.nres;  /* just redo 'luaD_poscall' */\n    /* don't need to reset CIST_CLSRET, as it will be set again anyway */\n  }\n  else {\n    int status = LUA_YIELD;  /* default if there were no errors */\n    /* must have a continuation and must be able to call it */\n    lua_assert(ci->u.c.k != NULL && yieldable(L));\n    if (ci->callstatus & CIST_YPCALL)   /* was inside a 'lua_pcallk'? */\n      status = finishpcallk(L, ci);  /* finish it */\n    adjustresults(L, LUA_MULTRET);  /* finish 'lua_callk' */\n    lua_unlock(L);\n    n = (*ci->u.c.k)(L, status, ci->u.c.ctx);  /* call continuation */\n    lua_lock(L);\n    api_checknelems(L, n);\n  }\n  luaD_poscall(L, ci, n);  /* finish 'luaD_call' */\n}\n\n\n/*\n** Executes \"full continuation\" (everything in the stack) of a\n** previously interrupted coroutine until the stack is empty (or another\n** interruption long-jumps out of the loop).\n*/\nstatic void unroll (lua_State *L, void *ud) {\n  CallInfo *ci;\n  UNUSED(ud);\n  while ((ci = L->ci) != &L->base_ci) {  /* something in the stack */\n    if (!isLua(ci))  /* C function? */\n      finishCcall(L, ci);  /* complete its execution */\n    else {  /* Lua function */\n      luaV_finishOp(L);  /* finish interrupted instruction */\n      luaV_execute(L, ci);  /* execute down to higher C 'boundary' */\n    }\n  }\n}\n\n\n/*\n** Try to find a suspended protected call (a \"recover point\") for the\n** given thread.\n*/\nstatic CallInfo *findpcall (lua_State *L) {\n  CallInfo *ci;\n  for (ci = L->ci; ci != NULL; ci = ci->previous) {  /* search for a pcall */\n    if (ci->callstatus & CIST_YPCALL)\n      return ci;\n  }\n  return NULL;  /* no pending pcall */\n}\n\n\n/*\n** Signal an error in the call to 'lua_resume', not in the execution\n** of the coroutine itself. (Such errors should not be handled by any\n** coroutine error handler and should not kill the coroutine.)\n*/\nstatic int resume_error (lua_State *L, const char *msg, int narg) {\n  api_checkpop(L, narg);\n  L->top.p -= narg;  /* remove args from the stack */\n  setsvalue2s(L, L->top.p, luaS_new(L, msg));  /* push error message */\n  api_incr_top(L);\n  lua_unlock(L);\n  return LUA_ERRRUN;\n}\n\n\n/*\n** Do the work for 'lua_resume' in protected mode. Most of the work\n** depends on the status of the coroutine: initial state, suspended\n** inside a hook, or regularly suspended (optionally with a continuation\n** function), plus erroneous cases: non-suspended coroutine or dead\n** coroutine.\n*/\nstatic void resume (lua_State *L, void *ud) {\n  int n = *(cast(int*, ud));  /* number of arguments */\n  StkId firstArg = L->top.p - n;  /* first argument */\n  CallInfo *ci = L->ci;\n  if (L->status == LUA_OK)  /* starting a coroutine? */\n    ccall(L, firstArg - 1, LUA_MULTRET, 0);  /* just call its body */\n  else {  /* resuming from previous yield */\n    lua_assert(L->status == LUA_YIELD);\n    L->status = LUA_OK;  /* mark that it is running (again) */\n    if (isLua(ci)) {  /* yielded inside a hook? */\n      /* undo increment made by 'luaG_traceexec': instruction was not\n         executed yet */\n      lua_assert(ci->callstatus & CIST_HOOKYIELD);\n      ci->u.l.savedpc--;\n      L->top.p = firstArg;  /* discard arguments */\n      luaV_execute(L, ci);  /* just continue running Lua code */\n    }\n    else {  /* 'common' yield */\n      if (ci->u.c.k != NULL) {  /* does it have a continuation function? */\n        lua_unlock(L);\n        n = (*ci->u.c.k)(L, LUA_YIELD, ci->u.c.ctx); /* call continuation */\n        lua_lock(L);\n        api_checknelems(L, n);\n      }\n      luaD_poscall(L, ci, n);  /* finish 'luaD_call' */\n    }\n    unroll(L, NULL);  /* run continuation */\n  }\n}\n\n\n/*\n** Unrolls a coroutine in protected mode while there are recoverable\n** errors, that is, errors inside a protected call. (Any error\n** interrupts 'unroll', and this loop protects it again so it can\n** continue.) Stops with a normal end (status == LUA_OK), an yield\n** (status == LUA_YIELD), or an unprotected error ('findpcall' doesn't\n** find a recover point).\n*/\nstatic int precover (lua_State *L, int status) {\n  CallInfo *ci;\n  while (errorstatus(status) && (ci = findpcall(L)) != NULL) {\n    L->ci = ci;  /* go down to recovery functions */\n    setcistrecst(ci, status);  /* status to finish 'pcall' */\n    status = luaD_rawrunprotected(L, unroll, NULL);\n  }\n  return status;\n}\n\n\nLUA_API int lua_resume (lua_State *L, lua_State *from, int nargs,\n                                      int *nresults) {\n  int status;\n  lua_lock(L);\n  if (L->status == LUA_OK) {  /* may be starting a coroutine */\n    if (L->ci != &L->base_ci)  /* not in base level? */\n      return resume_error(L, \"cannot resume non-suspended coroutine\", nargs);\n    else if (L->top.p - (L->ci->func.p + 1) == nargs)  /* no function? */\n      return resume_error(L, \"cannot resume dead coroutine\", nargs);\n  }\n  else if (L->status != LUA_YIELD)  /* ended with errors? */\n    return resume_error(L, \"cannot resume dead coroutine\", nargs);\n  L->nCcalls = (from) ? getCcalls(from) : 0;\n  if (getCcalls(L) >= LUAI_MAXCCALLS)\n    return resume_error(L, \"C stack overflow\", nargs);\n  L->nCcalls++;\n  luai_userstateresume(L, nargs);\n  api_checkpop(L, (L->status == LUA_OK) ? nargs + 1 : nargs);\n  status = luaD_rawrunprotected(L, resume, &nargs);\n   /* continue running after recoverable errors */\n  status = precover(L, status);\n  if (l_likely(!errorstatus(status)))\n    lua_assert(status == L->status);  /* normal end or yield */\n  else {  /* unrecoverable error */\n    L->status = cast_byte(status);  /* mark thread as 'dead' */\n    luaD_seterrorobj(L, status, L->top.p);  /* push error message */\n    L->ci->top.p = L->top.p;\n  }\n  *nresults = (status == LUA_YIELD) ? L->ci->u2.nyield\n                                    : cast_int(L->top.p - (L->ci->func.p + 1));\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API int lua_isyieldable (lua_State *L) {\n  return yieldable(L);\n}\n\n\nLUA_API int lua_yieldk (lua_State *L, int nresults, lua_KContext ctx,\n                        lua_KFunction k) {\n  CallInfo *ci;\n  luai_userstateyield(L, nresults);\n  lua_lock(L);\n  ci = L->ci;\n  api_checkpop(L, nresults);\n  if (l_unlikely(!yieldable(L))) {\n    if (L != G(L)->mainthread)\n      luaG_runerror(L, \"attempt to yield across a C-call boundary\");\n    else\n      luaG_runerror(L, \"attempt to yield from outside a coroutine\");\n  }\n  L->status = LUA_YIELD;\n  ci->u2.nyield = nresults;  /* save number of results */\n  if (isLua(ci)) {  /* inside a hook? */\n    lua_assert(!isLuacode(ci));\n    api_check(L, nresults == 0, \"hooks cannot yield values\");\n    api_check(L, k == NULL, \"hooks cannot continue after yielding\");\n  }\n  else {\n    if ((ci->u.c.k = k) != NULL)  /* is there a continuation? */\n      ci->u.c.ctx = ctx;  /* save context */\n    luaD_throw(L, LUA_YIELD);\n  }\n  lua_assert(ci->callstatus & CIST_HOOKED);  /* must be inside a hook */\n  lua_unlock(L);\n  return 0;  /* return to 'luaD_hook' */\n}\n\n\n/*\n** Auxiliary structure to call 'luaF_close' in protected mode.\n*/\nstruct CloseP {\n  StkId level;\n  int status;\n};\n\n\n/*\n** Auxiliary function to call 'luaF_close' in protected mode.\n*/\nstatic void closepaux (lua_State *L, void *ud) {\n  struct CloseP *pcl = cast(struct CloseP *, ud);\n  luaF_close(L, pcl->level, pcl->status, 0);\n}\n\n\n/*\n** Calls 'luaF_close' in protected mode. Return the original status\n** or, in case of errors, the new status.\n*/\nint luaD_closeprotected (lua_State *L, ptrdiff_t level, int status) {\n  CallInfo *old_ci = L->ci;\n  lu_byte old_allowhooks = L->allowhook;\n  for (;;) {  /* keep closing upvalues until no more errors */\n    struct CloseP pcl;\n    pcl.level = restorestack(L, level); pcl.status = status;\n    status = luaD_rawrunprotected(L, &closepaux, &pcl);\n    if (l_likely(status == LUA_OK))  /* no more errors? */\n      return pcl.status;\n    else {  /* an error occurred; restore saved state and repeat */\n      L->ci = old_ci;\n      L->allowhook = old_allowhooks;\n    }\n  }\n}\n\n\n/*\n** Call the C function 'func' in protected mode, restoring basic\n** thread information ('allowhook', etc.) and in particular\n** its stack level in case of errors.\n*/\nint luaD_pcall (lua_State *L, Pfunc func, void *u,\n                ptrdiff_t old_top, ptrdiff_t ef) {\n  int status;\n  CallInfo *old_ci = L->ci;\n  lu_byte old_allowhooks = L->allowhook;\n  ptrdiff_t old_errfunc = L->errfunc;\n  L->errfunc = ef;\n  status = luaD_rawrunprotected(L, func, u);\n  if (l_unlikely(status != LUA_OK)) {  /* an error occurred? */\n    L->ci = old_ci;\n    L->allowhook = old_allowhooks;\n    status = luaD_closeprotected(L, old_top, status);\n    luaD_seterrorobj(L, status, restorestack(L, old_top));\n    luaD_shrinkstack(L);   /* restore stack size in case of overflow */\n  }\n  L->errfunc = old_errfunc;\n  return status;\n}\n\n\n\n/*\n** Execute a protected parser.\n*/\nstruct SParser {  /* data to 'f_parser' */\n  ZIO *z;\n  Mbuffer buff;  /* dynamic structure used by the scanner */\n  Dyndata dyd;  /* dynamic structures used by the parser */\n  const char *mode;\n  const char *name;\n};\n\n\nstatic void checkmode (lua_State *L, const char *mode, const char *x) {\n  if (strchr(mode, x[0]) == NULL) {\n    luaO_pushfstring(L,\n       \"attempt to load a %s chunk (mode is '%s')\", x, mode);\n    luaD_throw(L, LUA_ERRSYNTAX);\n  }\n}\n\n\nstatic void f_parser (lua_State *L, void *ud) {\n  LClosure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  const char *mode = p->mode ? p->mode : \"bt\";\n  int c = zgetc(p->z);  /* read first character */\n  if (c == LUA_SIGNATURE[0]) {\n    int fixed = 0;\n    if (strchr(mode, 'B') != NULL)\n      fixed = 1;\n    else\n      checkmode(L, mode, \"binary\");\n    cl = luaU_undump(L, p->z, p->name, fixed);\n  }\n  else {\n    checkmode(L, mode, \"text\");\n    cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);\n  }\n  lua_assert(cl->nupvalues == cl->p->sizeupvalues);\n  luaF_initupvals(L, cl);\n}\n\n\nint luaD_protectedparser (lua_State *L, ZIO *z, const char *name,\n                                        const char *mode) {\n  struct SParser p;\n  int status;\n  incnny(L);  /* cannot yield during parsing */\n  p.z = z; p.name = name; p.mode = mode;\n  p.dyd.actvar.arr = NULL; p.dyd.actvar.size = 0;\n  p.dyd.gt.arr = NULL; p.dyd.gt.size = 0;\n  p.dyd.label.arr = NULL; p.dyd.label.size = 0;\n  luaZ_initbuffer(L, &p.buff);\n  status = luaD_pcall(L, f_parser, &p, savestack(L, L->top.p), L->errfunc);\n  luaZ_freebuffer(L, &p.buff);\n  luaM_freearray(L, p.dyd.actvar.arr, cast_sizet(p.dyd.actvar.size));\n  luaM_freearray(L, p.dyd.gt.arr, cast_sizet(p.dyd.gt.size));\n  luaM_freearray(L, p.dyd.label.arr, cast_sizet(p.dyd.label.size));\n  decnny(L);\n  return status;\n}\n\n\n"
        },
        {
          "name": "ldo.h",
          "type": "blob",
          "size": 3.2421875,
          "content": "/*\n** $Id: ldo.h $\n** Stack and Call structure of Lua\n** See Copyright Notice in lua.h\n*/\n\n#ifndef ldo_h\n#define ldo_h\n\n\n#include \"llimits.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lzio.h\"\n\n\n/*\n** Macro to check stack size and grow stack if needed.  Parameters\n** 'pre'/'pos' allow the macro to preserve a pointer into the\n** stack across reallocations, doing the work only when needed.\n** It also allows the running of one GC step when the stack is\n** reallocated.\n** 'condmovestack' is used in heavy tests to force a stack reallocation\n** at every check.\n*/\n\n#if !defined(HARDSTACKTESTS)\n#define condmovestack(L,pre,pos)\t((void)0)\n#else\n/* realloc stack keeping its size */\n#define condmovestack(L,pre,pos)  \\\n  { int sz_ = stacksize(L); pre; luaD_reallocstack((L), sz_, 0); pos; }\n#endif\n\n#define luaD_checkstackaux(L,n,pre,pos)  \\\n\tif (l_unlikely(L->stack_last.p - L->top.p <= (n))) \\\n\t  { pre; luaD_growstack(L, n, 1); pos; } \\\n\telse { condmovestack(L,pre,pos); }\n\n/* In general, 'pre'/'pos' are empty (nothing to save) */\n#define luaD_checkstack(L,n)\tluaD_checkstackaux(L,n,(void)0,(void)0)\n\n\n\n#define savestack(L,pt)\t\t(cast_charp(pt) - cast_charp(L->stack.p))\n#define restorestack(L,n)\tcast(StkId, cast_charp(L->stack.p) + (n))\n\n\n/* macro to check stack size, preserving 'p' */\n#define checkstackp(L,n,p)  \\\n  luaD_checkstackaux(L, n, \\\n    ptrdiff_t t__ = savestack(L, p),  /* save 'p' */ \\\n    p = restorestack(L, t__))  /* 'pos' part: restore 'p' */\n\n\n/*\n** Maximum depth for nested C calls, syntactical nested non-terminals,\n** and other features implemented through recursion in C. (Value must\n** fit in a 16-bit unsigned integer. It must also be compatible with\n** the size of the C stack.)\n*/\n#if !defined(LUAI_MAXCCALLS)\n#define LUAI_MAXCCALLS\t\t200\n#endif\n\n\n/* type of protected functions, to be ran by 'runprotected' */\ntypedef void (*Pfunc) (lua_State *L, void *ud);\n\nLUAI_FUNC void luaD_seterrorobj (lua_State *L, int errcode, StkId oldtop);\nLUAI_FUNC int luaD_protectedparser (lua_State *L, ZIO *z, const char *name,\n                                                  const char *mode);\nLUAI_FUNC void luaD_hook (lua_State *L, int event, int line,\n                                        int fTransfer, int nTransfer);\nLUAI_FUNC void luaD_hookcall (lua_State *L, CallInfo *ci);\nLUAI_FUNC int luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func,\n                                              int narg1, int delta);\nLUAI_FUNC CallInfo *luaD_precall (lua_State *L, StkId func, int nResults);\nLUAI_FUNC void luaD_call (lua_State *L, StkId func, int nResults);\nLUAI_FUNC void luaD_callnoyield (lua_State *L, StkId func, int nResults);\nLUAI_FUNC int luaD_closeprotected (lua_State *L, ptrdiff_t level, int status);\nLUAI_FUNC int luaD_pcall (lua_State *L, Pfunc func, void *u,\n                                        ptrdiff_t oldtop, ptrdiff_t ef);\nLUAI_FUNC void luaD_poscall (lua_State *L, CallInfo *ci, int nres);\nLUAI_FUNC int luaD_reallocstack (lua_State *L, int newsize, int raiseerror);\nLUAI_FUNC int luaD_growstack (lua_State *L, int n, int raiseerror);\nLUAI_FUNC void luaD_shrinkstack (lua_State *L);\nLUAI_FUNC void luaD_inctop (lua_State *L);\n\nLUAI_FUNC l_noret luaD_throw (lua_State *L, int errcode);\nLUAI_FUNC int luaD_rawrunprotected (lua_State *L, Pfunc f, void *ud);\n\n#endif\n\n"
        },
        {
          "name": "ldump.c",
          "type": "blob",
          "size": 7.0107421875,
          "content": "/*\n** $Id: ldump.c $\n** save precompiled Lua chunks\n** See Copyright Notice in lua.h\n*/\n\n#define ldump_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <limits.h>\n#include <stddef.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"lgc.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"ltable.h\"\n#include \"lundump.h\"\n\n\ntypedef struct {\n  lua_State *L;\n  lua_Writer writer;\n  void *data;\n  size_t offset;  /* current position relative to beginning of dump */\n  int strip;\n  int status;\n  Table *h;  /* table to track saved strings */\n  lua_Integer nstr;  /* counter for counting saved strings */\n} DumpState;\n\n\n/*\n** All high-level dumps go through dumpVector; you can change it to\n** change the endianness of the result\n*/\n#define dumpVector(D,v,n)\tdumpBlock(D,v,(n)*sizeof((v)[0]))\n\n#define dumpLiteral(D, s)\tdumpBlock(D,s,sizeof(s) - sizeof(char))\n\n\n/*\n** Dump the block of memory pointed by 'b' with given 'size'.\n** 'b' should not be NULL, except for the last call signaling the end\n** of the dump.\n*/\nstatic void dumpBlock (DumpState *D, const void *b, size_t size) {\n  if (D->status == 0) {  /* do not write anything after an error */\n    lua_unlock(D->L);\n    D->status = (*D->writer)(D->L, b, size, D->data);\n    lua_lock(D->L);\n    D->offset += size;\n  }\n}\n\n\n/*\n** Dump enough zeros to ensure that current position is a multiple of\n** 'align'.\n*/\nstatic void dumpAlign (DumpState *D, unsigned align) {\n  unsigned padding = align - cast_uint(D->offset % align);\n  if (padding < align) {  /* padding == align means no padding */\n    static lua_Integer paddingContent = 0;\n    lua_assert(align <= sizeof(lua_Integer));\n    dumpBlock(D, &paddingContent, padding);\n  }\n  lua_assert(D->offset % align == 0);\n}\n\n\n#define dumpVar(D,x)\t\tdumpVector(D,&x,1)\n\n\nstatic void dumpByte (DumpState *D, int y) {\n  lu_byte x = (lu_byte)y;\n  dumpVar(D, x);\n}\n\n\n/*\n** size for 'dumpVarint' buffer: each byte can store up to 7 bits.\n** (The \"+6\" rounds up the division.)\n*/\n#define DIBS    ((sizeof(size_t) * CHAR_BIT + 6) / 7)\n\n/*\n** Dumps an unsigned integer using the MSB Varint encoding\n*/\nstatic void dumpVarint (DumpState *D, size_t x) {\n  lu_byte buff[DIBS];\n  unsigned n = 1;\n  buff[DIBS - 1] = x & 0x7f;  /* fill least-significant byte */\n  while ((x >>= 7) != 0)  /* fill other bytes in reverse order */\n    buff[DIBS - (++n)] = cast_byte((x & 0x7f) | 0x80);\n  dumpVector(D, buff + DIBS - n, n);\n}\n\n\nstatic void dumpSize (DumpState *D, size_t sz) {\n  dumpVarint(D, sz);\n}\n\nstatic void dumpInt (DumpState *D, int x) {\n  lua_assert(x >= 0);\n  dumpVarint(D, cast(size_t, x));\n}\n\n\nstatic void dumpNumber (DumpState *D, lua_Number x) {\n  dumpVar(D, x);\n}\n\n\nstatic void dumpInteger (DumpState *D, lua_Integer x) {\n  dumpVar(D, x);\n}\n\n\n/*\n** Dump a String. First dump its \"size\": size==0 means NULL;\n** size==1 is followed by an index and means \"reuse saved string with\n** that index\"; size>=2 is followed by the string contents with real\n** size==size-2 and means that string, which will be saved with\n** the next available index.\n*/\nstatic void dumpString (DumpState *D, TString *ts) {\n  if (ts == NULL)\n    dumpSize(D, 0);\n  else {\n    TValue idx;\n    int tag = luaH_getstr(D->h, ts, &idx);\n    if (!tagisempty(tag)) {  /* string already saved? */\n      dumpSize(D, 1);  /* reuse a saved string */\n      dumpSize(D, cast_sizet(ivalue(&idx)));  /* index of saved string */\n    }\n    else {  /* must write and save the string */\n      TValue key, value;  /* to save the string in the hash */\n      size_t size;\n      const char *s = getlstr(ts, size);\n      dumpSize(D, size + 2);\n      dumpVector(D, s, size + 1);  /* include ending '\\0' */\n      D->nstr++;  /* one more saved string */\n      setsvalue(D->L, &key, ts);  /* the string is the key */\n      setivalue(&value, D->nstr);  /* its index is the value */\n      luaH_set(D->L, D->h, &key, &value);  /* h[ts] = nstr */\n      /* integer value does not need barrier */\n    }\n  }\n}\n\n\nstatic void dumpCode (DumpState *D, const Proto *f) {\n  dumpInt(D, f->sizecode);\n  dumpAlign(D, sizeof(f->code[0]));\n  lua_assert(f->code != NULL);\n  dumpVector(D, f->code, cast_uint(f->sizecode));\n}\n\n\nstatic void dumpFunction (DumpState *D, const Proto *f);\n\nstatic void dumpConstants (DumpState *D, const Proto *f) {\n  int i;\n  int n = f->sizek;\n  dumpInt(D, n);\n  for (i = 0; i < n; i++) {\n    const TValue *o = &f->k[i];\n    int tt = ttypetag(o);\n    dumpByte(D, tt);\n    switch (tt) {\n      case LUA_VNUMFLT:\n        dumpNumber(D, fltvalue(o));\n        break;\n      case LUA_VNUMINT:\n        dumpInteger(D, ivalue(o));\n        break;\n      case LUA_VSHRSTR:\n      case LUA_VLNGSTR:\n        dumpString(D, tsvalue(o));\n        break;\n      default:\n        lua_assert(tt == LUA_VNIL || tt == LUA_VFALSE || tt == LUA_VTRUE);\n    }\n  }\n}\n\n\nstatic void dumpProtos (DumpState *D, const Proto *f) {\n  int i;\n  int n = f->sizep;\n  dumpInt(D, n);\n  for (i = 0; i < n; i++)\n    dumpFunction(D, f->p[i]);\n}\n\n\nstatic void dumpUpvalues (DumpState *D, const Proto *f) {\n  int i, n = f->sizeupvalues;\n  dumpInt(D, n);\n  for (i = 0; i < n; i++) {\n    dumpByte(D, f->upvalues[i].instack);\n    dumpByte(D, f->upvalues[i].idx);\n    dumpByte(D, f->upvalues[i].kind);\n  }\n}\n\n\nstatic void dumpDebug (DumpState *D, const Proto *f) {\n  int i, n;\n  n = (D->strip) ? 0 : f->sizelineinfo;\n  dumpInt(D, n);\n  if (f->lineinfo != NULL)\n    dumpVector(D, f->lineinfo, cast_uint(n));\n  n = (D->strip) ? 0 : f->sizeabslineinfo;\n  dumpInt(D, n);\n  if (n > 0) {\n    /* 'abslineinfo' is an array of structures of int's */\n    dumpAlign(D, sizeof(int));\n    dumpVector(D, f->abslineinfo, cast_uint(n));\n  }\n  n = (D->strip) ? 0 : f->sizelocvars;\n  dumpInt(D, n);\n  for (i = 0; i < n; i++) {\n    dumpString(D, f->locvars[i].varname);\n    dumpInt(D, f->locvars[i].startpc);\n    dumpInt(D, f->locvars[i].endpc);\n  }\n  n = (D->strip) ? 0 : f->sizeupvalues;\n  dumpInt(D, n);\n  for (i = 0; i < n; i++)\n    dumpString(D, f->upvalues[i].name);\n}\n\n\nstatic void dumpFunction (DumpState *D, const Proto *f) {\n  dumpInt(D, f->linedefined);\n  dumpInt(D, f->lastlinedefined);\n  dumpByte(D, f->numparams);\n  dumpByte(D, f->flag);\n  dumpByte(D, f->maxstacksize);\n  dumpCode(D, f);\n  dumpConstants(D, f);\n  dumpUpvalues(D, f);\n  dumpProtos(D, f);\n  dumpString(D, D->strip ? NULL : f->source);\n  dumpDebug(D, f);\n}\n\n\nstatic void dumpHeader (DumpState *D) {\n  dumpLiteral(D, LUA_SIGNATURE);\n  dumpByte(D, LUAC_VERSION);\n  dumpByte(D, LUAC_FORMAT);\n  dumpLiteral(D, LUAC_DATA);\n  dumpByte(D, sizeof(Instruction));\n  dumpByte(D, sizeof(lua_Integer));\n  dumpByte(D, sizeof(lua_Number));\n  dumpInteger(D, LUAC_INT);\n  dumpNumber(D, LUAC_NUM);\n}\n\n\n/*\n** dump Lua function as precompiled chunk\n*/\nint luaU_dump (lua_State *L, const Proto *f, lua_Writer w, void *data,\n               int strip) {\n  DumpState D;\n  D.h = luaH_new(L);  /* aux. table to keep strings already dumped */\n  sethvalue2s(L, L->top.p, D.h);  /* anchor it */\n  L->top.p++;\n  D.L = L;\n  D.writer = w;\n  D.offset = 0;\n  D.data = data;\n  D.strip = strip;\n  D.status = 0;\n  D.nstr = 0;\n  dumpHeader(&D);\n  dumpByte(&D, f->sizeupvalues);\n  dumpFunction(&D, f);\n  dumpBlock(&D, NULL, 0);  /* signal end of dump */\n  return D.status;\n}\n\n"
        },
        {
          "name": "lfunc.c",
          "type": "blob",
          "size": 8.85546875,
          "content": "/*\n** $Id: lfunc.c $\n** Auxiliary functions to manipulate prototypes and closures\n** See Copyright Notice in lua.h\n*/\n\n#define lfunc_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <stddef.h>\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n\n\n\nCClosure *luaF_newCclosure (lua_State *L, int nupvals) {\n  GCObject *o = luaC_newobj(L, LUA_VCCL, sizeCclosure(nupvals));\n  CClosure *c = gco2ccl(o);\n  c->nupvalues = cast_byte(nupvals);\n  return c;\n}\n\n\nLClosure *luaF_newLclosure (lua_State *L, int nupvals) {\n  GCObject *o = luaC_newobj(L, LUA_VLCL, sizeLclosure(nupvals));\n  LClosure *c = gco2lcl(o);\n  c->p = NULL;\n  c->nupvalues = cast_byte(nupvals);\n  while (nupvals--) c->upvals[nupvals] = NULL;\n  return c;\n}\n\n\n/*\n** fill a closure with new closed upvalues\n*/\nvoid luaF_initupvals (lua_State *L, LClosure *cl) {\n  int i;\n  for (i = 0; i < cl->nupvalues; i++) {\n    GCObject *o = luaC_newobj(L, LUA_VUPVAL, sizeof(UpVal));\n    UpVal *uv = gco2upv(o);\n    uv->v.p = &uv->u.value;  /* make it closed */\n    setnilvalue(uv->v.p);\n    cl->upvals[i] = uv;\n    luaC_objbarrier(L, cl, uv);\n  }\n}\n\n\n/*\n** Create a new upvalue at the given level, and link it to the list of\n** open upvalues of 'L' after entry 'prev'.\n**/\nstatic UpVal *newupval (lua_State *L, StkId level, UpVal **prev) {\n  GCObject *o = luaC_newobj(L, LUA_VUPVAL, sizeof(UpVal));\n  UpVal *uv = gco2upv(o);\n  UpVal *next = *prev;\n  uv->v.p = s2v(level);  /* current value lives in the stack */\n  uv->u.open.next = next;  /* link it to list of open upvalues */\n  uv->u.open.previous = prev;\n  if (next)\n    next->u.open.previous = &uv->u.open.next;\n  *prev = uv;\n  if (!isintwups(L)) {  /* thread not in list of threads with upvalues? */\n    L->twups = G(L)->twups;  /* link it to the list */\n    G(L)->twups = L;\n  }\n  return uv;\n}\n\n\n/*\n** Find and reuse, or create if it does not exist, an upvalue\n** at the given level.\n*/\nUpVal *luaF_findupval (lua_State *L, StkId level) {\n  UpVal **pp = &L->openupval;\n  UpVal *p;\n  lua_assert(isintwups(L) || L->openupval == NULL);\n  while ((p = *pp) != NULL && uplevel(p) >= level) {  /* search for it */\n    lua_assert(!isdead(G(L), p));\n    if (uplevel(p) == level)  /* corresponding upvalue? */\n      return p;  /* return it */\n    pp = &p->u.open.next;\n  }\n  /* not found: create a new upvalue after 'pp' */\n  return newupval(L, level, pp);\n}\n\n\n/*\n** Call closing method for object 'obj' with error message 'err'. The\n** boolean 'yy' controls whether the call is yieldable.\n** (This function assumes EXTRA_STACK.)\n*/\nstatic void callclosemethod (lua_State *L, TValue *obj, TValue *err, int yy) {\n  StkId top = L->top.p;\n  const TValue *tm = luaT_gettmbyobj(L, obj, TM_CLOSE);\n  setobj2s(L, top, tm);  /* will call metamethod... */\n  setobj2s(L, top + 1, obj);  /* with 'self' as the 1st argument */\n  setobj2s(L, top + 2, err);  /* and error msg. as 2nd argument */\n  L->top.p = top + 3;  /* add function and arguments */\n  if (yy)\n    luaD_call(L, top, 0);\n  else\n    luaD_callnoyield(L, top, 0);\n}\n\n\n/*\n** Check whether object at given level has a close metamethod and raise\n** an error if not.\n*/\nstatic void checkclosemth (lua_State *L, StkId level) {\n  const TValue *tm = luaT_gettmbyobj(L, s2v(level), TM_CLOSE);\n  if (ttisnil(tm)) {  /* no metamethod? */\n    int idx = cast_int(level - L->ci->func.p);  /* variable index */\n    const char *vname = luaG_findlocal(L, L->ci, idx, NULL);\n    if (vname == NULL) vname = \"?\";\n    luaG_runerror(L, \"variable '%s' got a non-closable value\", vname);\n  }\n}\n\n\n/*\n** Prepare and call a closing method.\n** If status is CLOSEKTOP, the call to the closing method will be pushed\n** at the top of the stack. Otherwise, values can be pushed right after\n** the 'level' of the upvalue being closed, as everything after that\n** won't be used again.\n*/\nstatic void prepcallclosemth (lua_State *L, StkId level, int status, int yy) {\n  TValue *uv = s2v(level);  /* value being closed */\n  TValue *errobj;\n  if (status == CLOSEKTOP)\n    errobj = &G(L)->nilvalue;  /* error object is nil */\n  else {  /* 'luaD_seterrorobj' will set top to level + 2 */\n    errobj = s2v(level + 1);  /* error object goes after 'uv' */\n    luaD_seterrorobj(L, status, level + 1);  /* set error object */\n  }\n  callclosemethod(L, uv, errobj, yy);\n}\n\n\n/*\n** Maximum value for deltas in 'tbclist', dependent on the type\n** of delta. (This macro assumes that an 'L' is in scope where it\n** is used.)\n*/\n#define MAXDELTA  \\\n\t((256ul << ((sizeof(L->stack.p->tbclist.delta) - 1) * 8)) - 1)\n\n\n/*\n** Insert a variable in the list of to-be-closed variables.\n*/\nvoid luaF_newtbcupval (lua_State *L, StkId level) {\n  lua_assert(level > L->tbclist.p);\n  if (l_isfalse(s2v(level)))\n    return;  /* false doesn't need to be closed */\n  checkclosemth(L, level);  /* value must have a close method */\n  while (cast_uint(level - L->tbclist.p) > MAXDELTA) {\n    L->tbclist.p += MAXDELTA;  /* create a dummy node at maximum delta */\n    L->tbclist.p->tbclist.delta = 0;\n  }\n  level->tbclist.delta = cast(unsigned short, level - L->tbclist.p);\n  L->tbclist.p = level;\n}\n\n\nvoid luaF_unlinkupval (UpVal *uv) {\n  lua_assert(upisopen(uv));\n  *uv->u.open.previous = uv->u.open.next;\n  if (uv->u.open.next)\n    uv->u.open.next->u.open.previous = uv->u.open.previous;\n}\n\n\n/*\n** Close all upvalues up to the given stack level.\n*/\nvoid luaF_closeupval (lua_State *L, StkId level) {\n  UpVal *uv;\n  StkId upl;  /* stack index pointed by 'uv' */\n  while ((uv = L->openupval) != NULL && (upl = uplevel(uv)) >= level) {\n    TValue *slot = &uv->u.value;  /* new position for value */\n    lua_assert(uplevel(uv) < L->top.p);\n    luaF_unlinkupval(uv);  /* remove upvalue from 'openupval' list */\n    setobj(L, slot, uv->v.p);  /* move value to upvalue slot */\n    uv->v.p = slot;  /* now current value lives here */\n    if (!iswhite(uv)) {  /* neither white nor dead? */\n      nw2black(uv);  /* closed upvalues cannot be gray */\n      luaC_barrier(L, uv, slot);\n    }\n  }\n}\n\n\n/*\n** Remove first element from the tbclist plus its dummy nodes.\n*/\nstatic void poptbclist (lua_State *L) {\n  StkId tbc = L->tbclist.p;\n  lua_assert(tbc->tbclist.delta > 0);  /* first element cannot be dummy */\n  tbc -= tbc->tbclist.delta;\n  while (tbc > L->stack.p && tbc->tbclist.delta == 0)\n    tbc -= MAXDELTA;  /* remove dummy nodes */\n  L->tbclist.p = tbc;\n}\n\n\n/*\n** Close all upvalues and to-be-closed variables up to the given stack\n** level. Return restored 'level'.\n*/\nStkId luaF_close (lua_State *L, StkId level, int status, int yy) {\n  ptrdiff_t levelrel = savestack(L, level);\n  luaF_closeupval(L, level);  /* first, close the upvalues */\n  while (L->tbclist.p >= level) {  /* traverse tbc's down to that level */\n    StkId tbc = L->tbclist.p;  /* get variable index */\n    poptbclist(L);  /* remove it from list */\n    prepcallclosemth(L, tbc, status, yy);  /* close variable */\n    level = restorestack(L, levelrel);\n  }\n  return level;\n}\n\n\nProto *luaF_newproto (lua_State *L) {\n  GCObject *o = luaC_newobj(L, LUA_VPROTO, sizeof(Proto));\n  Proto *f = gco2p(o);\n  f->k = NULL;\n  f->sizek = 0;\n  f->p = NULL;\n  f->sizep = 0;\n  f->code = NULL;\n  f->sizecode = 0;\n  f->lineinfo = NULL;\n  f->sizelineinfo = 0;\n  f->abslineinfo = NULL;\n  f->sizeabslineinfo = 0;\n  f->upvalues = NULL;\n  f->sizeupvalues = 0;\n  f->numparams = 0;\n  f->flag = 0;\n  f->maxstacksize = 0;\n  f->locvars = NULL;\n  f->sizelocvars = 0;\n  f->linedefined = 0;\n  f->lastlinedefined = 0;\n  f->source = NULL;\n  return f;\n}\n\n\nlu_mem luaF_protosize (Proto *p) {\n  lu_mem sz = cast(lu_mem, sizeof(Proto))\n            + cast_uint(p->sizep) * sizeof(Proto*)\n            + cast_uint(p->sizek) * sizeof(TValue)\n            + cast_uint(p->sizelocvars) * sizeof(LocVar)\n            + cast_uint(p->sizeupvalues) * sizeof(Upvaldesc);\n  if (!(p->flag & PF_FIXED)) {\n    sz += cast_uint(p->sizecode) * sizeof(Instruction);\n    sz += cast_uint(p->sizelineinfo) * sizeof(lu_byte);\n    sz += cast_uint(p->sizeabslineinfo) * sizeof(AbsLineInfo);\n  }\n  return sz;\n}\n\n\nvoid luaF_freeproto (lua_State *L, Proto *f) {\n  if (!(f->flag & PF_FIXED)) {\n    luaM_freearray(L, f->code, cast_sizet(f->sizecode));\n    luaM_freearray(L, f->lineinfo, cast_sizet(f->sizelineinfo));\n    luaM_freearray(L, f->abslineinfo, cast_sizet(f->sizeabslineinfo));\n  }\n  luaM_freearray(L, f->p, cast_sizet(f->sizep));\n  luaM_freearray(L, f->k, cast_sizet(f->sizek));\n  luaM_freearray(L, f->locvars, cast_sizet(f->sizelocvars));\n  luaM_freearray(L, f->upvalues, cast_sizet(f->sizeupvalues));\n  luaM_free(L, f);\n}\n\n\n/*\n** Look for n-th local variable at line 'line' in function 'func'.\n** Returns NULL if not found.\n*/\nconst char *luaF_getlocalname (const Proto *f, int local_number, int pc) {\n  int i;\n  for (i = 0; i<f->sizelocvars && f->locvars[i].startpc <= pc; i++) {\n    if (pc < f->locvars[i].endpc) {  /* is variable active? */\n      local_number--;\n      if (local_number == 0)\n        return getstr(f->locvars[i].varname);\n    }\n  }\n  return NULL;  /* not found */\n}\n\n"
        },
        {
          "name": "lfunc.h",
          "type": "blob",
          "size": 1.6435546875,
          "content": "/*\n** $Id: lfunc.h $\n** Auxiliary functions to manipulate prototypes and closures\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lfunc_h\n#define lfunc_h\n\n\n#include \"lobject.h\"\n\n\n#define sizeCclosure(n)  \\\n\t(offsetof(CClosure, upvalue) + sizeof(TValue) * cast_uint(n))\n\n#define sizeLclosure(n)  \\\n\t(offsetof(LClosure, upvals) + sizeof(UpVal *) * cast_uint(n))\n\n\n/* test whether thread is in 'twups' list */\n#define isintwups(L)\t(L->twups != L)\n\n\n/*\n** maximum number of upvalues in a closure (both C and Lua). (Value\n** must fit in a VM register.)\n*/\n#define MAXUPVAL\t255\n\n\n#define upisopen(up)\t((up)->v.p != &(up)->u.value)\n\n\n#define uplevel(up)\tcheck_exp(upisopen(up), cast(StkId, (up)->v.p))\n\n\n/*\n** maximum number of misses before giving up the cache of closures\n** in prototypes\n*/\n#define MAXMISS\t\t10\n\n\n\n/* special status to close upvalues preserving the top of the stack */\n#define CLOSEKTOP\t(-1)\n\n\nLUAI_FUNC Proto *luaF_newproto (lua_State *L);\nLUAI_FUNC CClosure *luaF_newCclosure (lua_State *L, int nupvals);\nLUAI_FUNC LClosure *luaF_newLclosure (lua_State *L, int nupvals);\nLUAI_FUNC void luaF_initupvals (lua_State *L, LClosure *cl);\nLUAI_FUNC UpVal *luaF_findupval (lua_State *L, StkId level);\nLUAI_FUNC void luaF_newtbcupval (lua_State *L, StkId level);\nLUAI_FUNC void luaF_closeupval (lua_State *L, StkId level);\nLUAI_FUNC StkId luaF_close (lua_State *L, StkId level, int status, int yy);\nLUAI_FUNC void luaF_unlinkupval (UpVal *uv);\nLUAI_FUNC lu_mem luaF_protosize (Proto *p);\nLUAI_FUNC void luaF_freeproto (lua_State *L, Proto *f);\nLUAI_FUNC const char *luaF_getlocalname (const Proto *func, int local_number,\n                                         int pc);\n\n\n#endif\n"
        },
        {
          "name": "lgc.c",
          "type": "blob",
          "size": 55.9072265625,
          "content": "/*\n** $Id: lgc.c $\n** Garbage Collector\n** See Copyright Notice in lua.h\n*/\n\n#define lgc_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n#include <string.h>\n\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n\n\n/*\n** Maximum number of elements to sweep in each single step.\n** (Large enough to dissipate fixed overheads but small enough\n** to allow small steps for the collector.)\n*/\n#define GCSWEEPMAX\t20\n\n\n/*\n** Cost (in work units) of running one finalizer.\n*/\n#define CWUFIN\t10\n\n\n/* mask with all color bits */\n#define maskcolors\t(bitmask(BLACKBIT) | WHITEBITS)\n\n/* mask with all GC bits */\n#define maskgcbits      (maskcolors | AGEBITS)\n\n\n/* macro to erase all color bits then set only the current white bit */\n#define makewhite(g,x)\t\\\n  (x->marked = cast_byte((x->marked & ~maskcolors) | luaC_white(g)))\n\n/* make an object gray (neither white nor black) */\n#define set2gray(x)\tresetbits(x->marked, maskcolors)\n\n\n/* make an object black (coming from any color) */\n#define set2black(x)  \\\n  (x->marked = cast_byte((x->marked & ~WHITEBITS) | bitmask(BLACKBIT)))\n\n\n#define valiswhite(x)   (iscollectable(x) && iswhite(gcvalue(x)))\n\n#define keyiswhite(n)   (keyiscollectable(n) && iswhite(gckey(n)))\n\n\n/*\n** Protected access to objects in values\n*/\n#define gcvalueN(o)     (iscollectable(o) ? gcvalue(o) : NULL)\n\n\n/*\n** Access to collectable objects in array part of tables\n*/\n#define gcvalarr(t,i)  \\\n\t((*getArrTag(t,i) & BIT_ISCOLLECTABLE) ? getArrVal(t,i)->gc : NULL)\n\n\n#define markvalue(g,o) { checkliveness(g->mainthread,o); \\\n  if (valiswhite(o)) reallymarkobject(g,gcvalue(o)); }\n\n#define markkey(g, n)\t{ if keyiswhite(n) reallymarkobject(g,gckey(n)); }\n\n#define markobject(g,t)\t{ if (iswhite(t)) reallymarkobject(g, obj2gco(t)); }\n\n/*\n** mark an object that can be NULL (either because it is really optional,\n** or it was stripped as debug info, or inside an uncompleted structure)\n*/\n#define markobjectN(g,t)\t{ if (t) markobject(g,t); }\n\n\nstatic void reallymarkobject (global_State *g, GCObject *o);\nstatic void atomic (lua_State *L);\nstatic void entersweep (lua_State *L);\n\n\n/*\n** {======================================================\n** Generic functions\n** =======================================================\n*/\n\n\n/*\n** one after last element in a hash array\n*/\n#define gnodelast(h)\tgnode(h, cast_sizet(sizenode(h)))\n\n\nstatic l_mem objsize (GCObject *o) {\n  lu_mem res;\n  switch (o->tt) {\n    case LUA_VTABLE: {\n      res = luaH_size(gco2t(o));\n      break;\n    }\n    case LUA_VLCL: {\n      LClosure *cl = gco2lcl(o);\n      res = sizeLclosure(cl->nupvalues);\n      break;\n    }\n    case LUA_VCCL: {\n      CClosure *cl = gco2ccl(o);\n      res = sizeCclosure(cl->nupvalues);\n      break;\n      break;\n    }\n    case LUA_VUSERDATA: {\n      Udata *u = gco2u(o);\n      res = sizeudata(u->nuvalue, u->len);\n      break;\n    }\n    case LUA_VPROTO: {\n      res = luaF_protosize(gco2p(o));\n      break;\n    }\n    case LUA_VTHREAD: {\n      res = luaE_threadsize(gco2th(o));\n      break;\n    }\n    case LUA_VSHRSTR: {\n      TString *ts = gco2ts(o);\n      res = sizestrshr(cast_uint(ts->shrlen));\n      break;\n    }\n    case LUA_VLNGSTR: {\n      TString *ts = gco2ts(o);\n      res = luaS_sizelngstr(ts->u.lnglen, ts->shrlen);\n      break;\n    }\n    case LUA_VUPVAL: {\n      res = sizeof(UpVal);\n      break;\n    }\n    default: res = 0; lua_assert(0);\n  }\n  return cast(l_mem, res);\n}\n\n\nstatic GCObject **getgclist (GCObject *o) {\n  switch (o->tt) {\n    case LUA_VTABLE: return &gco2t(o)->gclist;\n    case LUA_VLCL: return &gco2lcl(o)->gclist;\n    case LUA_VCCL: return &gco2ccl(o)->gclist;\n    case LUA_VTHREAD: return &gco2th(o)->gclist;\n    case LUA_VPROTO: return &gco2p(o)->gclist;\n    case LUA_VUSERDATA: {\n      Udata *u = gco2u(o);\n      lua_assert(u->nuvalue > 0);\n      return &u->gclist;\n    }\n    default: lua_assert(0); return 0;\n  }\n}\n\n\n/*\n** Link a collectable object 'o' with a known type into the list 'p'.\n** (Must be a macro to access the 'gclist' field in different types.)\n*/\n#define linkgclist(o,p)\tlinkgclist_(obj2gco(o), &(o)->gclist, &(p))\n\nstatic void linkgclist_ (GCObject *o, GCObject **pnext, GCObject **list) {\n  lua_assert(!isgray(o));  /* cannot be in a gray list */\n  *pnext = *list;\n  *list = o;\n  set2gray(o);  /* now it is */\n}\n\n\n/*\n** Link a generic collectable object 'o' into the list 'p'.\n*/\n#define linkobjgclist(o,p) linkgclist_(obj2gco(o), getgclist(o), &(p))\n\n\n\n/*\n** Clear keys for empty entries in tables. If entry is empty, mark its\n** entry as dead. This allows the collection of the key, but keeps its\n** entry in the table: its removal could break a chain and could break\n** a table traversal.  Other places never manipulate dead keys, because\n** its associated empty value is enough to signal that the entry is\n** logically empty.\n*/\nstatic void clearkey (Node *n) {\n  lua_assert(isempty(gval(n)));\n  if (keyiscollectable(n))\n    setdeadkey(n);  /* unused key; remove it */\n}\n\n\n/*\n** tells whether a key or value can be cleared from a weak\n** table. Non-collectable objects are never removed from weak\n** tables. Strings behave as 'values', so are never removed too. for\n** other objects: if really collected, cannot keep them; for objects\n** being finalized, keep them in keys, but not in values\n*/\nstatic int iscleared (global_State *g, const GCObject *o) {\n  if (o == NULL) return 0;  /* non-collectable value */\n  else if (novariant(o->tt) == LUA_TSTRING) {\n    markobject(g, o);  /* strings are 'values', so are never weak */\n    return 0;\n  }\n  else return iswhite(o);\n}\n\n\n/*\n** Barrier that moves collector forward, that is, marks the white object\n** 'v' being pointed by the black object 'o'.  In the generational\n** mode, 'v' must also become old, if 'o' is old; however, it cannot\n** be changed directly to OLD, because it may still point to non-old\n** objects. So, it is marked as OLD0. In the next cycle it will become\n** OLD1, and in the next it will finally become OLD (regular old). By\n** then, any object it points to will also be old.  If called in the\n** incremental sweep phase, it clears the black object to white (sweep\n** it) to avoid other barrier calls for this same object. (That cannot\n** be done is generational mode, as its sweep does not distinguish\n** whites from deads.)\n*/\nvoid luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  /* must keep invariant? */\n    reallymarkobject(g, v);  /* restore invariant */\n    if (isold(o)) {\n      lua_assert(!isold(v));  /* white object could not be old */\n      setage(v, G_OLD0);  /* restore generational invariant */\n    }\n  }\n  else {  /* sweep phase */\n    lua_assert(issweepphase(g));\n    if (g->gckind != KGC_GENMINOR)  /* incremental mode? */\n      makewhite(g, o);  /* mark 'o' as white to avoid other barriers */\n  }\n}\n\n\n/*\n** barrier that moves collector backward, that is, mark the black object\n** pointing to a white object as gray again.\n*/\nvoid luaC_barrierback_ (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && !isdead(g, o));\n  lua_assert((g->gckind != KGC_GENMINOR)\n          || (isold(o) && getage(o) != G_TOUCHED1));\n  if (getage(o) == G_TOUCHED2)  /* already in gray list? */\n    set2gray(o);  /* make it gray to become touched1 */\n  else  /* link it in 'grayagain' and paint it gray */\n    linkobjgclist(o, g->grayagain);\n  if (isold(o))  /* generational mode? */\n    setage(o, G_TOUCHED1);  /* touched in current cycle */\n}\n\n\nvoid luaC_fix (lua_State *L, GCObject *o) {\n  global_State *g = G(L);\n  lua_assert(g->allgc == o);  /* object must be 1st in 'allgc' list! */\n  set2gray(o);  /* they will be gray forever */\n  setage(o, G_OLD);  /* and old forever */\n  g->allgc = o->next;  /* remove object from 'allgc' list */\n  o->next = g->fixedgc;  /* link it to 'fixedgc' list */\n  g->fixedgc = o;\n}\n\n\n/*\n** create a new collectable object (with given type, size, and offset)\n** and link it to 'allgc' list.\n*/\nGCObject *luaC_newobjdt (lua_State *L, lu_byte tt, size_t sz, size_t offset) {\n  global_State *g = G(L);\n  char *p = cast_charp(luaM_newobject(L, novariant(tt), sz));\n  GCObject *o = cast(GCObject *, p + offset);\n  o->marked = luaC_white(g);\n  o->tt = tt;\n  o->next = g->allgc;\n  g->allgc = o;\n  return o;\n}\n\n\n/*\n** create a new collectable object with no offset.\n*/\nGCObject *luaC_newobj (lua_State *L, lu_byte tt, size_t sz) {\n  return luaC_newobjdt(L, tt, sz, 0);\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** Mark functions\n** =======================================================\n*/\n\n\n/*\n** Mark an object.  Userdata with no user values, strings, and closed\n** upvalues are visited and turned black here.  Open upvalues are\n** already indirectly linked through their respective threads in the\n** 'twups' list, so they don't go to the gray list; nevertheless, they\n** are kept gray to avoid barriers, as their values will be revisited\n** by the thread or by 'remarkupvals'.  Other objects are added to the\n** gray list to be visited (and turned black) later.  Both userdata and\n** upvalues can call this function recursively, but this recursion goes\n** for at most two levels: An upvalue cannot refer to another upvalue\n** (only closures can), and a userdata's metatable must be a table.\n*/\nstatic void reallymarkobject (global_State *g, GCObject *o) {\n  g->GCmarked += objsize(o);\n  switch (o->tt) {\n    case LUA_VSHRSTR:\n    case LUA_VLNGSTR: {\n      set2black(o);  /* nothing to visit */\n      break;\n    }\n    case LUA_VUPVAL: {\n      UpVal *uv = gco2upv(o);\n      if (upisopen(uv))\n        set2gray(uv);  /* open upvalues are kept gray */\n      else\n        set2black(uv);  /* closed upvalues are visited here */\n      markvalue(g, uv->v.p);  /* mark its content */\n      break;\n    }\n    case LUA_VUSERDATA: {\n      Udata *u = gco2u(o);\n      if (u->nuvalue == 0) {  /* no user values? */\n        markobjectN(g, u->metatable);  /* mark its metatable */\n        set2black(u);  /* nothing else to mark */\n        break;\n      }\n      /* else... */\n    }  /* FALLTHROUGH */\n    case LUA_VLCL: case LUA_VCCL: case LUA_VTABLE:\n    case LUA_VTHREAD: case LUA_VPROTO: {\n      linkobjgclist(o, g->gray);  /* to be visited later */\n      break;\n    }\n    default: lua_assert(0); break;\n  }\n}\n\n\n/*\n** mark metamethods for basic types\n*/\nstatic void markmt (global_State *g) {\n  int i;\n  for (i=0; i < LUA_NUMTYPES; i++)\n    markobjectN(g, g->mt[i]);\n}\n\n\n/*\n** mark all objects in list of being-finalized\n*/\nstatic void markbeingfnz (global_State *g) {\n  GCObject *o;\n  for (o = g->tobefnz; o != NULL; o = o->next)\n    markobject(g, o);\n}\n\n\n/*\n** For each non-marked thread, simulates a barrier between each open\n** upvalue and its value. (If the thread is collected, the value will be\n** assigned to the upvalue, but then it can be too late for the barrier\n** to act. The \"barrier\" does not need to check colors: A non-marked\n** thread must be young; upvalues cannot be older than their threads; so\n** any visited upvalue must be young too.) Also removes the thread from\n** the list, as it was already visited. Removes also threads with no\n** upvalues, as they have nothing to be checked. (If the thread gets an\n** upvalue later, it will be linked in the list again.)\n*/\nstatic void remarkupvals (global_State *g) {\n  lua_State *thread;\n  lua_State **p = &g->twups;\n  while ((thread = *p) != NULL) {\n    if (!iswhite(thread) && thread->openupval != NULL)\n      p = &thread->twups;  /* keep marked thread with upvalues in the list */\n    else {  /* thread is not marked or without upvalues */\n      UpVal *uv;\n      lua_assert(!isold(thread) || thread->openupval == NULL);\n      *p = thread->twups;  /* remove thread from the list */\n      thread->twups = thread;  /* mark that it is out of list */\n      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n        lua_assert(getage(uv) <= getage(thread));\n        if (!iswhite(uv)) {  /* upvalue already visited? */\n          lua_assert(upisopen(uv) && isgray(uv));\n          markvalue(g, uv->v.p);  /* mark its value */\n        }\n      }\n    }\n  }\n}\n\n\nstatic void cleargraylists (global_State *g) {\n  g->gray = g->grayagain = NULL;\n  g->weak = g->allweak = g->ephemeron = NULL;\n}\n\n\n/*\n** mark root set and reset all gray lists, to start a new collection.\n** 'GCmarked' is initialized to count the total number of live bytes\n** during a cycle.\n*/\nstatic void restartcollection (global_State *g) {\n  cleargraylists(g);\n  g->GCmarked = 0;\n  markobject(g, g->mainthread);\n  markvalue(g, &g->l_registry);\n  markmt(g);\n  markbeingfnz(g);  /* mark any finalizing object left from previous cycle */\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Traverse functions\n** =======================================================\n*/\n\n\n/*\n** Check whether object 'o' should be kept in the 'grayagain' list for\n** post-processing by 'correctgraylist'. (It could put all old objects\n** in the list and leave all the work to 'correctgraylist', but it is\n** more efficient to avoid adding elements that will be removed.) Only\n** TOUCHED1 objects need to be in the list. TOUCHED2 doesn't need to go\n** back to a gray list, but then it must become OLD. (That is what\n** 'correctgraylist' does when it finds a TOUCHED2 object.)\n*/\nstatic void genlink (global_State *g, GCObject *o) {\n  lua_assert(isblack(o));\n  if (getage(o) == G_TOUCHED1) {  /* touched in this cycle? */\n    linkobjgclist(o, g->grayagain);  /* link it back in 'grayagain' */\n  }  /* everything else do not need to be linked back */\n  else if (getage(o) == G_TOUCHED2)\n    setage(o, G_OLD);  /* advance age */\n}\n\n\n/*\n** Traverse a table with weak values and link it to proper list. During\n** propagate phase, keep it in 'grayagain' list, to be revisited in the\n** atomic phase. In the atomic phase, if table has any white value,\n** put it in 'weak' list, to be cleared.\n*/\nstatic void traverseweakvalue (global_State *g, Table *h) {\n  Node *n, *limit = gnodelast(h);\n  /* if there is array part, assume it may have white values (it is not\n     worth traversing it now just to check) */\n  int hasclears = (h->asize > 0);\n  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */\n    if (isempty(gval(n)))  /* entry is empty? */\n      clearkey(n);  /* clear its key */\n    else {\n      lua_assert(!keyisnil(n));\n      markkey(g, n);\n      if (!hasclears && iscleared(g, gcvalueN(gval(n))))  /* a white value? */\n        hasclears = 1;  /* table will have to be cleared */\n    }\n  }\n  if (g->gcstate == GCSatomic && hasclears)\n    linkgclist(h, g->weak);  /* has to be cleared later */\n  else\n    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */\n}\n\n\n/*\n** Traverse the array part of a table.\n*/\nstatic int traversearray (global_State *g, Table *h) {\n  unsigned asize = h->asize;\n  int marked = 0;  /* true if some object is marked in this traversal */\n  unsigned i;\n  for (i = 0; i < asize; i++) {\n    GCObject *o = gcvalarr(h, i);\n    if (o != NULL && iswhite(o)) {\n      marked = 1;\n      reallymarkobject(g, o);\n    }\n  }\n  return marked;\n}\n\n\n/*\n** Traverse an ephemeron table and link it to proper list. Returns true\n** iff any object was marked during this traversal (which implies that\n** convergence has to continue). During propagation phase, keep table\n** in 'grayagain' list, to be visited again in the atomic phase. In\n** the atomic phase, if table has any white->white entry, it has to\n** be revisited during ephemeron convergence (as that key may turn\n** black). Otherwise, if it has any white key, table has to be cleared\n** (in the atomic phase). In generational mode, some tables\n** must be kept in some gray list for post-processing; this is done\n** by 'genlink'.\n*/\nstatic int traverseephemeron (global_State *g, Table *h, int inv) {\n  int hasclears = 0;  /* true if table has white keys */\n  int hasww = 0;  /* true if table has entry \"white-key -> white-value\" */\n  unsigned int i;\n  unsigned int nsize = sizenode(h);\n  int marked = traversearray(g, h);  /* traverse array part */\n  /* traverse hash part; if 'inv', traverse descending\n     (see 'convergeephemerons') */\n  for (i = 0; i < nsize; i++) {\n    Node *n = inv ? gnode(h, nsize - 1 - i) : gnode(h, i);\n    if (isempty(gval(n)))  /* entry is empty? */\n      clearkey(n);  /* clear its key */\n    else if (iscleared(g, gckeyN(n))) {  /* key is not marked (yet)? */\n      hasclears = 1;  /* table must be cleared */\n      if (valiswhite(gval(n)))  /* value not marked yet? */\n        hasww = 1;  /* white-white entry */\n    }\n    else if (valiswhite(gval(n))) {  /* value not marked yet? */\n      marked = 1;\n      reallymarkobject(g, gcvalue(gval(n)));  /* mark it now */\n    }\n  }\n  /* link table into proper list */\n  if (g->gcstate == GCSpropagate)\n    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */\n  else if (hasww)  /* table has white->white entries? */\n    linkgclist(h, g->ephemeron);  /* have to propagate again */\n  else if (hasclears)  /* table has white keys? */\n    linkgclist(h, g->allweak);  /* may have to clean white keys */\n  else\n    genlink(g, obj2gco(h));  /* check whether collector still needs to see it */\n  return marked;\n}\n\n\nstatic void traversestrongtable (global_State *g, Table *h) {\n  Node *n, *limit = gnodelast(h);\n  traversearray(g, h);\n  for (n = gnode(h, 0); n < limit; n++) {  /* traverse hash part */\n    if (isempty(gval(n)))  /* entry is empty? */\n      clearkey(n);  /* clear its key */\n    else {\n      lua_assert(!keyisnil(n));\n      markkey(g, n);\n      markvalue(g, gval(n));\n    }\n  }\n  genlink(g, obj2gco(h));\n}\n\n\nstatic l_mem traversetable (global_State *g, Table *h) {\n  const char *weakkey, *weakvalue;\n  const TValue *mode = gfasttm(g, h->metatable, TM_MODE);\n  TString *smode;\n  markobjectN(g, h->metatable);\n  if (mode && ttisshrstring(mode) &&  /* is there a weak mode? */\n      (cast_void(smode = tsvalue(mode)),\n       cast_void(weakkey = strchr(getshrstr(smode), 'k')),\n       cast_void(weakvalue = strchr(getshrstr(smode), 'v')),\n       (weakkey || weakvalue))) {  /* is really weak? */\n    if (!weakkey)  /* strong keys? */\n      traverseweakvalue(g, h);\n    else if (!weakvalue)  /* strong values? */\n      traverseephemeron(g, h, 0);\n    else  /* all weak */\n      linkgclist(h, g->allweak);  /* nothing to traverse now */\n  }\n  else  /* not weak */\n    traversestrongtable(g, h);\n  return 1 + 2*sizenode(h) + h->asize;\n}\n\n\nstatic l_mem traverseudata (global_State *g, Udata *u) {\n  int i;\n  markobjectN(g, u->metatable);  /* mark its metatable */\n  for (i = 0; i < u->nuvalue; i++)\n    markvalue(g, &u->uv[i].uv);\n  genlink(g, obj2gco(u));\n  return 1 + u->nuvalue;\n}\n\n\n/*\n** Traverse a prototype. (While a prototype is being build, its\n** arrays can be larger than needed; the extra slots are filled with\n** NULL, so the use of 'markobjectN')\n*/\nstatic l_mem traverseproto (global_State *g, Proto *f) {\n  int i;\n  markobjectN(g, f->source);\n  for (i = 0; i < f->sizek; i++)  /* mark literals */\n    markvalue(g, &f->k[i]);\n  for (i = 0; i < f->sizeupvalues; i++)  /* mark upvalue names */\n    markobjectN(g, f->upvalues[i].name);\n  for (i = 0; i < f->sizep; i++)  /* mark nested protos */\n    markobjectN(g, f->p[i]);\n  for (i = 0; i < f->sizelocvars; i++)  /* mark local-variable names */\n    markobjectN(g, f->locvars[i].varname);\n  return 1 + f->sizek + f->sizeupvalues + f->sizep + f->sizelocvars;\n}\n\n\nstatic l_mem traverseCclosure (global_State *g, CClosure *cl) {\n  int i;\n  for (i = 0; i < cl->nupvalues; i++)  /* mark its upvalues */\n    markvalue(g, &cl->upvalue[i]);\n  return 1 + cl->nupvalues;\n}\n\n/*\n** Traverse a Lua closure, marking its prototype and its upvalues.\n** (Both can be NULL while closure is being created.)\n*/\nstatic l_mem traverseLclosure (global_State *g, LClosure *cl) {\n  int i;\n  markobjectN(g, cl->p);  /* mark its prototype */\n  for (i = 0; i < cl->nupvalues; i++) {  /* visit its upvalues */\n    UpVal *uv = cl->upvals[i];\n    markobjectN(g, uv);  /* mark upvalue */\n  }\n  return 1 + cl->nupvalues;\n}\n\n\n/*\n** Traverse a thread, marking the elements in the stack up to its top\n** and cleaning the rest of the stack in the final traversal. That\n** ensures that the entire stack have valid (non-dead) objects.\n** Threads have no barriers. In gen. mode, old threads must be visited\n** at every cycle, because they might point to young objects.  In inc.\n** mode, the thread can still be modified before the end of the cycle,\n** and therefore it must be visited again in the atomic phase. To ensure\n** these visits, threads must return to a gray list if they are not new\n** (which can only happen in generational mode) or if the traverse is in\n** the propagate phase (which can only happen in incremental mode).\n*/\nstatic l_mem traversethread (global_State *g, lua_State *th) {\n  UpVal *uv;\n  StkId o = th->stack.p;\n  if (isold(th) || g->gcstate == GCSpropagate)\n    linkgclist(th, g->grayagain);  /* insert into 'grayagain' list */\n  if (o == NULL)\n    return 0;  /* stack not completely built yet */\n  lua_assert(g->gcstate == GCSatomic ||\n             th->openupval == NULL || isintwups(th));\n  for (; o < th->top.p; o++)  /* mark live elements in the stack */\n    markvalue(g, s2v(o));\n  for (uv = th->openupval; uv != NULL; uv = uv->u.open.next)\n    markobject(g, uv);  /* open upvalues cannot be collected */\n  if (g->gcstate == GCSatomic) {  /* final traversal? */\n    if (!g->gcemergency)\n      luaD_shrinkstack(th); /* do not change stack in emergency cycle */\n    for (o = th->top.p; o < th->stack_last.p + EXTRA_STACK; o++)\n      setnilvalue(s2v(o));  /* clear dead stack slice */\n    /* 'remarkupvals' may have removed thread from 'twups' list */\n    if (!isintwups(th) && th->openupval != NULL) {\n      th->twups = g->twups;  /* link it back to the list */\n      g->twups = th;\n    }\n  }\n  return 1 + (th->top.p - th->stack.p);\n}\n\n\n/*\n** traverse one gray object, turning it to black. Return an estimate\n** of the number of slots traversed.\n*/\nstatic l_mem propagatemark (global_State *g) {\n  GCObject *o = g->gray;\n  nw2black(o);\n  g->gray = *getgclist(o);  /* remove from 'gray' list */\n  switch (o->tt) {\n    case LUA_VTABLE: return traversetable(g, gco2t(o));\n    case LUA_VUSERDATA: return traverseudata(g, gco2u(o));\n    case LUA_VLCL: return traverseLclosure(g, gco2lcl(o));\n    case LUA_VCCL: return traverseCclosure(g, gco2ccl(o));\n    case LUA_VPROTO: return traverseproto(g, gco2p(o));\n    case LUA_VTHREAD: return traversethread(g, gco2th(o));\n    default: lua_assert(0); return 0;\n  }\n}\n\n\nstatic void propagateall (global_State *g) {\n  while (g->gray)\n    propagatemark(g);\n}\n\n\n/*\n** Traverse all ephemeron tables propagating marks from keys to values.\n** Repeat until it converges, that is, nothing new is marked. 'dir'\n** inverts the direction of the traversals, trying to speed up\n** convergence on chains in the same table.\n*/\nstatic void convergeephemerons (global_State *g) {\n  int changed;\n  int dir = 0;\n  do {\n    GCObject *w;\n    GCObject *next = g->ephemeron;  /* get ephemeron list */\n    g->ephemeron = NULL;  /* tables may return to this list when traversed */\n    changed = 0;\n    while ((w = next) != NULL) {  /* for each ephemeron table */\n      Table *h = gco2t(w);\n      next = h->gclist;  /* list is rebuilt during loop */\n      nw2black(h);  /* out of the list (for now) */\n      if (traverseephemeron(g, h, dir)) {  /* marked some value? */\n        propagateall(g);  /* propagate changes */\n        changed = 1;  /* will have to revisit all ephemeron tables */\n      }\n    }\n    dir = !dir;  /* invert direction next time */\n  } while (changed);  /* repeat until no more changes */\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Sweep Functions\n** =======================================================\n*/\n\n\n/*\n** clear entries with unmarked keys from all weaktables in list 'l'\n*/\nstatic void clearbykeys (global_State *g, GCObject *l) {\n  for (; l; l = gco2t(l)->gclist) {\n    Table *h = gco2t(l);\n    Node *limit = gnodelast(h);\n    Node *n;\n    for (n = gnode(h, 0); n < limit; n++) {\n      if (iscleared(g, gckeyN(n)))  /* unmarked key? */\n        setempty(gval(n));  /* remove entry */\n      if (isempty(gval(n)))  /* is entry empty? */\n        clearkey(n);  /* clear its key */\n    }\n  }\n}\n\n\n/*\n** clear entries with unmarked values from all weaktables in list 'l' up\n** to element 'f'\n*/\nstatic void clearbyvalues (global_State *g, GCObject *l, GCObject *f) {\n  for (; l != f; l = gco2t(l)->gclist) {\n    Table *h = gco2t(l);\n    Node *n, *limit = gnodelast(h);\n    unsigned int i;\n    unsigned int asize = h->asize;\n    for (i = 0; i < asize; i++) {\n      GCObject *o = gcvalarr(h, i);\n      if (iscleared(g, o))  /* value was collected? */\n        *getArrTag(h, i) = LUA_VEMPTY;  /* remove entry */\n    }\n    for (n = gnode(h, 0); n < limit; n++) {\n      if (iscleared(g, gcvalueN(gval(n))))  /* unmarked value? */\n        setempty(gval(n));  /* remove entry */\n      if (isempty(gval(n)))  /* is entry empty? */\n        clearkey(n);  /* clear its key */\n    }\n  }\n}\n\n\nstatic void freeupval (lua_State *L, UpVal *uv) {\n  if (upisopen(uv))\n    luaF_unlinkupval(uv);\n  luaM_free(L, uv);\n}\n\n\nstatic void freeobj (lua_State *L, GCObject *o) {\n  assert_code(l_mem newmem = gettotalbytes(G(L)) - objsize(o));\n  switch (o->tt) {\n    case LUA_VPROTO:\n      luaF_freeproto(L, gco2p(o));\n      break;\n    case LUA_VUPVAL:\n      freeupval(L, gco2upv(o));\n      break;\n    case LUA_VLCL: {\n      LClosure *cl = gco2lcl(o);\n      luaM_freemem(L, cl, sizeLclosure(cl->nupvalues));\n      break;\n    }\n    case LUA_VCCL: {\n      CClosure *cl = gco2ccl(o);\n      luaM_freemem(L, cl, sizeCclosure(cl->nupvalues));\n      break;\n    }\n    case LUA_VTABLE:\n      luaH_free(L, gco2t(o));\n      break;\n    case LUA_VTHREAD:\n      luaE_freethread(L, gco2th(o));\n      break;\n    case LUA_VUSERDATA: {\n      Udata *u = gco2u(o);\n      luaM_freemem(L, o, sizeudata(u->nuvalue, u->len));\n      break;\n    }\n    case LUA_VSHRSTR: {\n      TString *ts = gco2ts(o);\n      luaS_remove(L, ts);  /* remove it from hash table */\n      luaM_freemem(L, ts, sizestrshr(cast_uint(ts->shrlen)));\n      break;\n    }\n    case LUA_VLNGSTR: {\n      TString *ts = gco2ts(o);\n      if (ts->shrlen == LSTRMEM)  /* must free external string? */\n        (*ts->falloc)(ts->ud, ts->contents, ts->u.lnglen + 1, 0);\n      luaM_freemem(L, ts, luaS_sizelngstr(ts->u.lnglen, ts->shrlen));\n      break;\n    }\n    default: lua_assert(0);\n  }\n  lua_assert(gettotalbytes(G(L)) == newmem);\n}\n\n\n/*\n** sweep at most 'countin' elements from a list of GCObjects erasing dead\n** objects, where a dead object is one marked with the old (non current)\n** white; change all non-dead objects back to white (and new), preparing\n** for next collection cycle. Return where to continue the traversal or\n** NULL if list is finished.\n*/\nstatic GCObject **sweeplist (lua_State *L, GCObject **p, l_mem countin) {\n  global_State *g = G(L);\n  int ow = otherwhite(g);\n  int white = luaC_white(g);  /* current white */\n  while (*p != NULL && countin-- > 0) {\n    GCObject *curr = *p;\n    int marked = curr->marked;\n    if (isdeadm(ow, marked)) {  /* is 'curr' dead? */\n      *p = curr->next;  /* remove 'curr' from list */\n      freeobj(L, curr);  /* erase 'curr' */\n    }\n    else {  /* change mark to 'white' and age to 'new' */\n      curr->marked = cast_byte((marked & ~maskgcbits) | white | G_NEW);\n      p = &curr->next;  /* go to next element */\n    }\n  }\n  return (*p == NULL) ? NULL : p;\n}\n\n\n/*\n** sweep a list until a live object (or end of list)\n*/\nstatic GCObject **sweeptolive (lua_State *L, GCObject **p) {\n  GCObject **old = p;\n  do {\n    p = sweeplist(L, p, 1);\n  } while (p == old);\n  return p;\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Finalization\n** =======================================================\n*/\n\n/*\n** If possible, shrink string table.\n*/\nstatic void checkSizes (lua_State *L, global_State *g) {\n  if (!g->gcemergency) {\n    if (g->strt.nuse < g->strt.size / 4)  /* string table too big? */\n      luaS_resize(L, g->strt.size / 2);\n  }\n}\n\n\n/*\n** Get the next udata to be finalized from the 'tobefnz' list, and\n** link it back into the 'allgc' list.\n*/\nstatic GCObject *udata2finalize (global_State *g) {\n  GCObject *o = g->tobefnz;  /* get first element */\n  lua_assert(tofinalize(o));\n  g->tobefnz = o->next;  /* remove it from 'tobefnz' list */\n  o->next = g->allgc;  /* return it to 'allgc' list */\n  g->allgc = o;\n  resetbit(o->marked, FINALIZEDBIT);  /* object is \"normal\" again */\n  if (issweepphase(g))\n    makewhite(g, o);  /* \"sweep\" object */\n  else if (getage(o) == G_OLD1)\n    g->firstold1 = o;  /* it is the first OLD1 object in the list */\n  return o;\n}\n\n\nstatic void dothecall (lua_State *L, void *ud) {\n  UNUSED(ud);\n  luaD_callnoyield(L, L->top.p - 2, 0);\n}\n\n\nstatic void GCTM (lua_State *L) {\n  global_State *g = G(L);\n  const TValue *tm;\n  TValue v;\n  lua_assert(!g->gcemergency);\n  setgcovalue(L, &v, udata2finalize(g));\n  tm = luaT_gettmbyobj(L, &v, TM_GC);\n  if (!notm(tm)) {  /* is there a finalizer? */\n    int status;\n    lu_byte oldah = L->allowhook;\n    lu_byte oldgcstp  = g->gcstp;\n    g->gcstp |= GCSTPGC;  /* avoid GC steps */\n    L->allowhook = 0;  /* stop debug hooks during GC metamethod */\n    setobj2s(L, L->top.p++, tm);  /* push finalizer... */\n    setobj2s(L, L->top.p++, &v);  /* ... and its argument */\n    L->ci->callstatus |= CIST_FIN;  /* will run a finalizer */\n    status = luaD_pcall(L, dothecall, NULL, savestack(L, L->top.p - 2), 0);\n    L->ci->callstatus &= ~CIST_FIN;  /* not running a finalizer anymore */\n    L->allowhook = oldah;  /* restore hooks */\n    g->gcstp = oldgcstp;  /* restore state */\n    if (l_unlikely(status != LUA_OK)) {  /* error while running __gc? */\n      luaE_warnerror(L, \"__gc\");\n      L->top.p--;  /* pops error object */\n    }\n  }\n}\n\n\n/*\n** call all pending finalizers\n*/\nstatic void callallpendingfinalizers (lua_State *L) {\n  global_State *g = G(L);\n  while (g->tobefnz)\n    GCTM(L);\n}\n\n\n/*\n** find last 'next' field in list 'p' list (to add elements in its end)\n*/\nstatic GCObject **findlast (GCObject **p) {\n  while (*p != NULL)\n    p = &(*p)->next;\n  return p;\n}\n\n\n/*\n** Move all unreachable objects (or 'all' objects) that need\n** finalization from list 'finobj' to list 'tobefnz' (to be finalized).\n** (Note that objects after 'finobjold1' cannot be white, so they\n** don't need to be traversed. In incremental mode, 'finobjold1' is NULL,\n** so the whole list is traversed.)\n*/\nstatic void separatetobefnz (global_State *g, int all) {\n  GCObject *curr;\n  GCObject **p = &g->finobj;\n  GCObject **lastnext = findlast(&g->tobefnz);\n  while ((curr = *p) != g->finobjold1) {  /* traverse all finalizable objects */\n    lua_assert(tofinalize(curr));\n    if (!(iswhite(curr) || all))  /* not being collected? */\n      p = &curr->next;  /* don't bother with it */\n    else {\n      if (curr == g->finobjsur)  /* removing 'finobjsur'? */\n        g->finobjsur = curr->next;  /* correct it */\n      *p = curr->next;  /* remove 'curr' from 'finobj' list */\n      curr->next = *lastnext;  /* link at the end of 'tobefnz' list */\n      *lastnext = curr;\n      lastnext = &curr->next;\n    }\n  }\n}\n\n\n/*\n** If pointer 'p' points to 'o', move it to the next element.\n*/\nstatic void checkpointer (GCObject **p, GCObject *o) {\n  if (o == *p)\n    *p = o->next;\n}\n\n\n/*\n** Correct pointers to objects inside 'allgc' list when\n** object 'o' is being removed from the list.\n*/\nstatic void correctpointers (global_State *g, GCObject *o) {\n  checkpointer(&g->survival, o);\n  checkpointer(&g->old1, o);\n  checkpointer(&g->reallyold, o);\n  checkpointer(&g->firstold1, o);\n}\n\n\n/*\n** if object 'o' has a finalizer, remove it from 'allgc' list (must\n** search the list to find it) and link it in 'finobj' list.\n*/\nvoid luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt) {\n  global_State *g = G(L);\n  if (tofinalize(o) ||                 /* obj. is already marked... */\n      gfasttm(g, mt, TM_GC) == NULL ||    /* or has no finalizer... */\n      (g->gcstp & GCSTPCLS))                   /* or closing state? */\n    return;  /* nothing to be done */\n  else {  /* move 'o' to 'finobj' list */\n    GCObject **p;\n    if (issweepphase(g)) {\n      makewhite(g, o);  /* \"sweep\" object 'o' */\n      if (g->sweepgc == &o->next)  /* should not remove 'sweepgc' object */\n        g->sweepgc = sweeptolive(L, g->sweepgc);  /* change 'sweepgc' */\n    }\n    else\n      correctpointers(g, o);\n    /* search for pointer pointing to 'o' */\n    for (p = &g->allgc; *p != o; p = &(*p)->next) { /* empty */ }\n    *p = o->next;  /* remove 'o' from 'allgc' list */\n    o->next = g->finobj;  /* link it in 'finobj' list */\n    g->finobj = o;\n    l_setbit(o->marked, FINALIZEDBIT);  /* mark it as such */\n  }\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** Generational Collector\n** =======================================================\n*/\n\n/*\n** Fields 'GCmarked' and 'GCmajorminor' are used to control the pace and\n** the mode of the collector. They play several roles, depending on the\n** mode of the collector:\n** * KGC_INC:\n**     GCmarked: number of marked bytes during a cycle.\n**     GCmajorminor: not used.\n** * KGC_GENMINOR\n**     GCmarked: number of bytes that became old since last major collection.\n**     GCmajorminor: number of bytes marked in last major collection.\n** * KGC_GENMAJOR\n**     GCmarked: number of bytes that became old sinse last major collection.\n**     GCmajorminor: number of bytes marked in last major collection.\n*/\n\n\n/*\n** Set the \"time\" to wait before starting a new incremental cycle;\n** cycle will start when number of bytes in use hits the threshold of\n** approximately (marked * pause / 100).\n*/\nstatic void setpause (global_State *g) {\n  l_mem threshold = applygcparam(g, PAUSE, g->GCmarked);\n  l_mem debt = threshold - gettotalbytes(g);\n  if (debt < 0) debt = 0;\n  luaE_setdebt(g, debt);\n}\n\n\n/*\n** Sweep a list of objects to enter generational mode.  Deletes dead\n** objects and turns the non dead to old. All non-dead threads---which\n** are now old---must be in a gray list. Everything else is not in a\n** gray list. Open upvalues are also kept gray.\n*/\nstatic void sweep2old (lua_State *L, GCObject **p) {\n  GCObject *curr;\n  global_State *g = G(L);\n  while ((curr = *p) != NULL) {\n    if (iswhite(curr)) {  /* is 'curr' dead? */\n      lua_assert(isdead(g, curr));\n      *p = curr->next;  /* remove 'curr' from list */\n      freeobj(L, curr);  /* erase 'curr' */\n    }\n    else {  /* all surviving objects become old */\n      setage(curr, G_OLD);\n      if (curr->tt == LUA_VTHREAD) {  /* threads must be watched */\n        lua_State *th = gco2th(curr);\n        linkgclist(th, g->grayagain);  /* insert into 'grayagain' list */\n      }\n      else if (curr->tt == LUA_VUPVAL && upisopen(gco2upv(curr)))\n        set2gray(curr);  /* open upvalues are always gray */\n      else  /* everything else is black */\n        nw2black(curr);\n      p = &curr->next;  /* go to next element */\n    }\n  }\n}\n\n\n/*\n** Sweep for generational mode. Delete dead objects. (Because the\n** collection is not incremental, there are no \"new white\" objects\n** during the sweep. So, any white object must be dead.) For\n** non-dead objects, advance their ages and clear the color of\n** new objects. (Old objects keep their colors.)\n** The ages of G_TOUCHED1 and G_TOUCHED2 objects cannot be advanced\n** here, because these old-generation objects are usually not swept\n** here.  They will all be advanced in 'correctgraylist'. That function\n** will also remove objects turned white here from any gray list.\n*/\nstatic GCObject **sweepgen (lua_State *L, global_State *g, GCObject **p,\n                            GCObject *limit, GCObject **pfirstold1,\n                            l_mem *paddedold) {\n  static const lu_byte nextage[] = {\n    G_SURVIVAL,  /* from G_NEW */\n    G_OLD1,      /* from G_SURVIVAL */\n    G_OLD1,      /* from G_OLD0 */\n    G_OLD,       /* from G_OLD1 */\n    G_OLD,       /* from G_OLD (do not change) */\n    G_TOUCHED1,  /* from G_TOUCHED1 (do not change) */\n    G_TOUCHED2   /* from G_TOUCHED2 (do not change) */\n  };\n  l_mem addedold = 0;\n  int white = luaC_white(g);\n  GCObject *curr;\n  while ((curr = *p) != limit) {\n    if (iswhite(curr)) {  /* is 'curr' dead? */\n      lua_assert(!isold(curr) && isdead(g, curr));\n      *p = curr->next;  /* remove 'curr' from list */\n      freeobj(L, curr);  /* erase 'curr' */\n    }\n    else {  /* correct mark and age */\n      int age = getage(curr);\n      if (age == G_NEW) {  /* new objects go back to white */\n        int marked = curr->marked & ~maskgcbits;  /* erase GC bits */\n        curr->marked = cast_byte(marked | G_SURVIVAL | white);\n      }\n      else {  /* all other objects will be old, and so keep their color */\n        lua_assert(age != G_OLD1);  /* advanced in 'markold' */\n        setage(curr, nextage[age]);\n        if (getage(curr) == G_OLD1) {\n          addedold += objsize(curr);  /* bytes becoming old */\n          if (*pfirstold1 == NULL)\n            *pfirstold1 = curr;  /* first OLD1 object in the list */\n        }\n      }\n      p = &curr->next;  /* go to next element */\n    }\n  }\n  *paddedold += addedold;\n  return p;\n}\n\n\n/*\n** Correct a list of gray objects. Return a pointer to the last element\n** left on the list, so that we can link another list to the end of\n** this one.\n** Because this correction is done after sweeping, young objects might\n** be turned white and still be in the list. They are only removed.\n** 'TOUCHED1' objects are advanced to 'TOUCHED2' and remain on the list;\n** Non-white threads also remain on the list. 'TOUCHED2' objects and\n** anything else become regular old, are marked black, and are removed\n** from the list.\n*/\nstatic GCObject **correctgraylist (GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    GCObject **next = getgclist(curr);\n    if (iswhite(curr))\n      goto remove;  /* remove all white objects */\n    else if (getage(curr) == G_TOUCHED1) {  /* touched in this cycle? */\n      lua_assert(isgray(curr));\n      nw2black(curr);  /* make it black, for next barrier */\n      setage(curr, G_TOUCHED2);\n      goto remain;  /* keep it in the list and go to next element */\n    }\n    else if (curr->tt == LUA_VTHREAD) {\n      lua_assert(isgray(curr));\n      goto remain;  /* keep non-white threads on the list */\n    }\n    else {  /* everything else is removed */\n      lua_assert(isold(curr));  /* young objects should be white here */\n      if (getage(curr) == G_TOUCHED2)  /* advance from TOUCHED2... */\n        setage(curr, G_OLD);  /* ... to OLD */\n      nw2black(curr);  /* make object black (to be removed) */\n      goto remove;\n    }\n    remove: *p = *next; continue;\n    remain: p = next; continue;\n  }\n  return p;\n}\n\n\n/*\n** Correct all gray lists, coalescing them into 'grayagain'.\n*/\nstatic void correctgraylists (global_State *g) {\n  GCObject **list = correctgraylist(&g->grayagain);\n  *list = g->weak; g->weak = NULL;\n  list = correctgraylist(list);\n  *list = g->allweak; g->allweak = NULL;\n  list = correctgraylist(list);\n  *list = g->ephemeron; g->ephemeron = NULL;\n  correctgraylist(list);\n}\n\n\n/*\n** Mark black 'OLD1' objects when starting a new young collection.\n** Gray objects are already in some gray list, and so will be visited in\n** the atomic step.\n*/\nstatic void markold (global_State *g, GCObject *from, GCObject *to) {\n  GCObject *p;\n  for (p = from; p != to; p = p->next) {\n    if (getage(p) == G_OLD1) {\n      lua_assert(!iswhite(p));\n      setage(p, G_OLD);  /* now they are old */\n      if (isblack(p))\n        reallymarkobject(g, p);\n    }\n  }\n}\n\n\n/*\n** Finish a young-generation collection.\n*/\nstatic void finishgencycle (lua_State *L, global_State *g) {\n  correctgraylists(g);\n  checkSizes(L, g);\n  g->gcstate = GCSpropagate;  /* skip restart */\n  if (!g->gcemergency)\n    callallpendingfinalizers(L);\n}\n\n\n/*\n** Shifts from a minor collection to major collections. It starts in\n** the \"sweep all\" state to clear all objects, which are mostly black\n** in generational mode.\n*/\nstatic void minor2inc (lua_State *L, global_State *g, lu_byte kind) {\n  g->GCmajorminor = g->GCmarked;  /* number of live bytes */\n  g->gckind = kind;\n  g->reallyold = g->old1 = g->survival = NULL;\n  g->finobjrold = g->finobjold1 = g->finobjsur = NULL;\n  entersweep(L);  /* continue as an incremental cycle */\n  /* set a debt equal to the step size */\n  luaE_setdebt(g, applygcparam(g, STEPSIZE, 100));\n}\n\n\n/*\n** Decide whether to shift to major mode. It shifts if the accumulated\n** number of added old bytes (counted in 'GCmarked') is larger than\n** 'minormajor'% of the number of lived bytes after the last major\n** collection. (This number is kept in 'GCmajorminor'.)\n*/\nstatic int checkminormajor (global_State *g) {\n  l_mem limit = applygcparam(g, MINORMAJOR, g->GCmajorminor);\n  if (limit == 0)\n    return 0;  /* special case: 'minormajor' 0 stops major collections */\n  return (g->GCmarked >= limit);\n}\n\n/*\n** Does a young collection. First, mark 'OLD1' objects. Then does the\n** atomic step. Then, check whether to continue in minor mode. If so,\n** sweep all lists and advance pointers. Finally, finish the collection.\n*/\nstatic void youngcollection (lua_State *L, global_State *g) {\n  l_mem addedold1 = 0;\n  l_mem marked = g->GCmarked;  /* preserve 'g->GCmarked' */\n  GCObject **psurvival;  /* to point to first non-dead survival object */\n  GCObject *dummy;  /* dummy out parameter to 'sweepgen' */\n  lua_assert(g->gcstate == GCSpropagate);\n  if (g->firstold1) {  /* are there regular OLD1 objects? */\n    markold(g, g->firstold1, g->reallyold);  /* mark them */\n    g->firstold1 = NULL;  /* no more OLD1 objects (for now) */\n  }\n  markold(g, g->finobj, g->finobjrold);\n  markold(g, g->tobefnz, NULL);\n\n  atomic(L);  /* will lose 'g->marked' */\n\n  /* sweep nursery and get a pointer to its last live element */\n  g->gcstate = GCSswpallgc;\n  psurvival = sweepgen(L, g, &g->allgc, g->survival, &g->firstold1, &addedold1);\n  /* sweep 'survival' */\n  sweepgen(L, g, psurvival, g->old1, &g->firstold1, &addedold1);\n  g->reallyold = g->old1;\n  g->old1 = *psurvival;  /* 'survival' survivals are old now */\n  g->survival = g->allgc;  /* all news are survivals */\n\n  /* repeat for 'finobj' lists */\n  dummy = NULL;  /* no 'firstold1' optimization for 'finobj' lists */\n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur, &dummy, &addedold1);\n  /* sweep 'survival' */\n  sweepgen(L, g, psurvival, g->finobjold1, &dummy, &addedold1);\n  g->finobjrold = g->finobjold1;\n  g->finobjold1 = *psurvival;  /* 'survival' survivals are old now */\n  g->finobjsur = g->finobj;  /* all news are survivals */\n\n  sweepgen(L, g, &g->tobefnz, NULL, &dummy, &addedold1);\n\n  /* keep total number of added old1 bytes */\n  g->GCmarked = marked + addedold1;\n\n  /* decide whether to shift to major mode */\n  if (checkminormajor(g)) {\n    minor2inc(L, g, KGC_GENMAJOR);  /* go to major mode */\n    g->GCmarked = 0;  /* avoid pause in first major cycle (see 'setpause') */\n  }\n  else\n    finishgencycle(L, g);  /* still in minor mode; finish it */\n}\n\n\n/*\n** Clears all gray lists, sweeps objects, and prepare sublists to enter\n** generational mode. The sweeps remove dead objects and turn all\n** surviving objects to old. Threads go back to 'grayagain'; everything\n** else is turned black (not in any gray list).\n*/\nstatic void atomic2gen (lua_State *L, global_State *g) {\n  cleargraylists(g);\n  /* sweep all elements making them old */\n  g->gcstate = GCSswpallgc;\n  sweep2old(L, &g->allgc);\n  /* everything alive now is old */\n  g->reallyold = g->old1 = g->survival = g->allgc;\n  g->firstold1 = NULL;  /* there are no OLD1 objects anywhere */\n\n  /* repeat for 'finobj' lists */\n  sweep2old(L, &g->finobj);\n  g->finobjrold = g->finobjold1 = g->finobjsur = g->finobj;\n\n  sweep2old(L, &g->tobefnz);\n\n  g->gckind = KGC_GENMINOR;\n  g->GCmajorminor = g->GCmarked;  /* \"base\" for number of bytes */\n  g->GCmarked = 0;  /* to count the number of added old1 bytes */\n  finishgencycle(L, g);\n}\n\n\n/*\n** Set debt for the next minor collection, which will happen when\n** total number of bytes grows 'genminormul'% in relation to\n** the base, GCmajorminor, which is the number of bytes being used\n** after the last major collection.\n*/\nstatic void setminordebt (global_State *g) {\n  luaE_setdebt(g, applygcparam(g, MINORMUL, g->GCmajorminor));\n}\n\n\n/*\n** Enter generational mode. Must go until the end of an atomic cycle\n** to ensure that all objects are correctly marked and weak tables\n** are cleared. Then, turn all objects into old and finishes the\n** collection.\n*/\nstatic void entergen (lua_State *L, global_State *g) {\n  luaC_runtilstate(L, GCSpause, 1);  /* prepare to start a new cycle */\n  luaC_runtilstate(L, GCSpropagate, 1);  /* start new cycle */\n  atomic(L);  /* propagates all and then do the atomic stuff */\n  atomic2gen(L, g);\n  setminordebt(g);  /* set debt assuming next cycle will be minor */\n}\n\n\n/*\n** Change collector mode to 'newmode'.\n*/\nvoid luaC_changemode (lua_State *L, int newmode) {\n  global_State *g = G(L);\n  if (g->gckind == KGC_GENMAJOR)  /* doing major collections? */\n    g->gckind = KGC_INC;  /* already incremental but in name */\n  if (newmode != g->gckind) {  /* does it need to change? */\n    if (newmode == KGC_INC)  /* entering incremental mode? */\n      minor2inc(L, g, KGC_INC);  /* entering incremental mode */\n    else {\n      lua_assert(newmode == KGC_GENMINOR);\n      entergen(L, g);\n    }\n  }\n}\n\n\n/*\n** Does a full collection in generational mode.\n*/\nstatic void fullgen (lua_State *L, global_State *g) {\n  minor2inc(L, g, KGC_INC);\n  entergen(L, g);\n}\n\n\n/*\n** After an atomic incremental step from a major collection,\n** check whether collector could return to minor collections.\n** It checks whether the number of bytes 'tobecollected'\n** is greater than 'majorminor'% of the number of bytes added\n** since the last collection ('addedbytes').\n*/\nstatic int checkmajorminor (lua_State *L, global_State *g) {\n  if (g->gckind == KGC_GENMAJOR) {  /* generational mode? */\n    l_mem numbytes = gettotalbytes(g);\n    l_mem addedbytes = numbytes - g->GCmajorminor;\n    l_mem limit = applygcparam(g, MAJORMINOR, addedbytes);\n    l_mem tobecollected = numbytes - g->GCmarked;\n    if (tobecollected > limit) {\n      atomic2gen(L, g);  /* return to generational mode */\n      setminordebt(g);\n      return 1;  /* exit incremental collection */\n    }\n  }\n  g->GCmajorminor = g->GCmarked;  /* prepare for next collection */\n  return 0;  /* stay doing incremental collections */\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** GC control\n** =======================================================\n*/\n\n\n/*\n** Enter first sweep phase.\n** The call to 'sweeptolive' makes the pointer point to an object\n** inside the list (instead of to the header), so that the real sweep do\n** not need to skip objects created between \"now\" and the start of the\n** real sweep.\n*/\nstatic void entersweep (lua_State *L) {\n  global_State *g = G(L);\n  g->gcstate = GCSswpallgc;\n  lua_assert(g->sweepgc == NULL);\n  g->sweepgc = sweeptolive(L, &g->allgc);\n}\n\n\n/*\n** Delete all objects in list 'p' until (but not including) object\n** 'limit'.\n*/\nstatic void deletelist (lua_State *L, GCObject *p, GCObject *limit) {\n  while (p != limit) {\n    GCObject *next = p->next;\n    freeobj(L, p);\n    p = next;\n  }\n}\n\n\n/*\n** Call all finalizers of the objects in the given Lua state, and\n** then free all objects, except for the main thread.\n*/\nvoid luaC_freeallobjects (lua_State *L) {\n  global_State *g = G(L);\n  g->gcstp = GCSTPCLS;  /* no extra finalizers after here */\n  luaC_changemode(L, KGC_INC);\n  separatetobefnz(g, 1);  /* separate all objects with finalizers */\n  lua_assert(g->finobj == NULL);\n  callallpendingfinalizers(L);\n  deletelist(L, g->allgc, obj2gco(g->mainthread));\n  lua_assert(g->finobj == NULL);  /* no new finalizers */\n  deletelist(L, g->fixedgc, NULL);  /* collect fixed objects */\n  lua_assert(g->strt.nuse == 0);\n}\n\n\nstatic void atomic (lua_State *L) {\n  global_State *g = G(L);\n  GCObject *origweak, *origall;\n  GCObject *grayagain = g->grayagain;  /* save original list */\n  g->grayagain = NULL;\n  lua_assert(g->ephemeron == NULL && g->weak == NULL);\n  lua_assert(!iswhite(g->mainthread));\n  g->gcstate = GCSatomic;\n  markobject(g, L);  /* mark running thread */\n  /* registry and global metatables may be changed by API */\n  markvalue(g, &g->l_registry);\n  markmt(g);  /* mark global metatables */\n  propagateall(g);  /* empties 'gray' list */\n  /* remark occasional upvalues of (maybe) dead threads */\n  remarkupvals(g);\n  propagateall(g);  /* propagate changes */\n  g->gray = grayagain;\n  propagateall(g);  /* traverse 'grayagain' list */\n  convergeephemerons(g);\n  /* at this point, all strongly accessible objects are marked. */\n  /* Clear values from weak tables, before checking finalizers */\n  clearbyvalues(g, g->weak, NULL);\n  clearbyvalues(g, g->allweak, NULL);\n  origweak = g->weak; origall = g->allweak;\n  separatetobefnz(g, 0);  /* separate objects to be finalized */\n  markbeingfnz(g);  /* mark objects that will be finalized */\n  propagateall(g);  /* remark, to propagate 'resurrection' */\n  convergeephemerons(g);\n  /* at this point, all resurrected objects are marked. */\n  /* remove dead objects from weak tables */\n  clearbykeys(g, g->ephemeron);  /* clear keys from all ephemeron */\n  clearbykeys(g, g->allweak);  /* clear keys from all 'allweak' */\n  /* clear values from resurrected weak tables */\n  clearbyvalues(g, g->weak, origweak);\n  clearbyvalues(g, g->allweak, origall);\n  luaS_clearcache(g);\n  g->currentwhite = cast_byte(otherwhite(g));  /* flip current white */\n  lua_assert(g->gray == NULL);\n}\n\n\n/*\n** Do a sweep step. The normal case (not fast) sweeps at most GCSWEEPMAX\n** elements. The fast case sweeps the whole list.\n*/\nstatic void sweepstep (lua_State *L, global_State *g,\n                       lu_byte nextstate, GCObject **nextlist, int fast) {\n  if (g->sweepgc)\n    g->sweepgc = sweeplist(L, g->sweepgc, fast ? MAX_LMEM : GCSWEEPMAX);\n  else {  /* enter next state */\n    g->gcstate = nextstate;\n    g->sweepgc = nextlist;\n  }\n}\n\n\n/*\n** Performs one incremental \"step\" in an incremental garbage collection.\n** For indivisible work, a step goes to the next state. When marking\n** (propagating), a step traverses one object. When sweeping, a step\n** sweeps GCSWEEPMAX objects, to avoid a big overhead for sweeping\n** objects one by one. (Sweeping is inexpensive, no matter the\n** object.) When 'fast' is true, 'singlestep' tries to finish a state\n** \"as fast as possible\". In particular, it skips the propagation\n** phase and leaves all objects to be traversed by the atomic phase:\n** That avoids traversing twice some objects, such as threads and\n** weak tables.\n*/\n\n#define step2pause\t-3  /* finished collection; entered pause state */\n#define atomicstep\t-2  /* atomic step */\n#define step2minor\t-1  /* moved to minor collections */\n\n\nstatic l_mem singlestep (lua_State *L, int fast) {\n  global_State *g = G(L);\n  l_mem stepresult;\n  lua_assert(!g->gcstopem);  /* collector is not reentrant */\n  g->gcstopem = 1;  /* no emergency collections while collecting */\n  switch (g->gcstate) {\n    case GCSpause: {\n      restartcollection(g);\n      g->gcstate = GCSpropagate;\n      stepresult = 1;\n      break;\n    }\n    case GCSpropagate: {\n      if (fast || g->gray == NULL) {\n        g->gcstate = GCSenteratomic;  /* finish propagate phase */\n        stepresult = 1;\n      }\n      else\n        stepresult = propagatemark(g);  /* traverse one gray object */\n      break;\n    }\n    case GCSenteratomic: {\n      atomic(L);\n      if (checkmajorminor(L, g))\n        stepresult = step2minor;\n      else {\n        entersweep(L);\n        stepresult = atomicstep;\n      }\n      break;\n    }\n    case GCSswpallgc: {  /* sweep \"regular\" objects */\n      sweepstep(L, g, GCSswpfinobj, &g->finobj, fast);\n      stepresult = GCSWEEPMAX;\n      break;\n    }\n    case GCSswpfinobj: {  /* sweep objects with finalizers */\n      sweepstep(L, g, GCSswptobefnz, &g->tobefnz, fast);\n      stepresult = GCSWEEPMAX;\n      break;\n    }\n    case GCSswptobefnz: {  /* sweep objects to be finalized */\n      sweepstep(L, g, GCSswpend, NULL, fast);\n      stepresult = GCSWEEPMAX;\n      break;\n    }\n    case GCSswpend: {  /* finish sweeps */\n      checkSizes(L, g);\n      g->gcstate = GCScallfin;\n      stepresult = GCSWEEPMAX;\n      break;\n    }\n    case GCScallfin: {  /* call finalizers */\n      if (g->tobefnz && !g->gcemergency) {\n        g->gcstopem = 0;  /* ok collections during finalizers */\n        GCTM(L);  /* call one finalizer */\n        stepresult = CWUFIN;\n      }\n      else {  /* emergency mode or no more finalizers */\n        g->gcstate = GCSpause;  /* finish collection */\n        stepresult = step2pause;\n      }\n      break;\n    }\n    default: lua_assert(0); return 0;\n  }\n  g->gcstopem = 0;\n  return stepresult;\n}\n\n\n/*\n** Advances the garbage collector until it reaches the given state.\n** (The option 'fast' is only for testing; in normal code, 'fast'\n** here is always true.)\n*/\nvoid luaC_runtilstate (lua_State *L, int state, int fast) {\n  global_State *g = G(L);\n  lua_assert(g->gckind == KGC_INC);\n  while (state != g->gcstate)\n    singlestep(L, fast);\n}\n\n\n\n/*\n** Performs a basic incremental step. The step size is\n** converted from bytes to \"units of work\"; then the function loops\n** running single steps until adding that many units of work or\n** finishing a cycle (pause state). Finally, it sets the debt that\n** controls when next step will be performed.\n*/\nstatic void incstep (lua_State *L, global_State *g) {\n  l_mem stepsize = applygcparam(g, STEPSIZE, 100);\n  l_mem work2do = applygcparam(g, STEPMUL, stepsize / cast_int(sizeof(void*)));\n  l_mem stres;\n  int fast = (work2do == 0);  /* special case: do a full collection */\n  do {  /* repeat until enough work */\n    stres = singlestep(L, fast);  /* perform one single step */\n    if (stres == step2minor)  /* returned to minor collections? */\n      return;  /* nothing else to be done here */\n    else if (stres == step2pause || (stres == atomicstep && !fast))\n      break;  /* end of cycle or atomic */\n    else\n      work2do -= stres;\n  } while (fast || work2do > 0);\n  if (g->gcstate == GCSpause)\n    setpause(g);  /* pause until next cycle */\n  else\n    luaE_setdebt(g, stepsize);\n}\n\n\n#if !defined(luai_tracegc)\n#define luai_tracegc(L,f)\t\t((void)0)\n#endif\n\n/*\n** Performs a basic GC step if collector is running. (If collector was\n** stopped by the user, set a reasonable debt to avoid it being called\n** at every single check.)\n*/\nvoid luaC_step (lua_State *L) {\n  global_State *g = G(L);\n  lua_assert(!g->gcemergency);\n  if (!gcrunning(g)) {  /* not running? */\n    if (g->gcstp & GCSTPUSR)  /* stopped by the user? */\n      luaE_setdebt(g, 20000);\n  }\n  else {\n    luai_tracegc(L, 1);  /* for internal debugging */\n    switch (g->gckind) {\n      case KGC_INC: case KGC_GENMAJOR:\n        incstep(L, g);\n        break;\n      case KGC_GENMINOR:\n        youngcollection(L, g);\n        setminordebt(g);\n        break;\n    }\n    luai_tracegc(L, 0);  /* for internal debugging */\n  }\n}\n\n\n/*\n** Perform a full collection in incremental mode.\n** Before running the collection, check 'keepinvariant'; if it is true,\n** there may be some objects marked as black, so the collector has\n** to sweep all objects to turn them back to white (as white has not\n** changed, nothing will be collected).\n*/\nstatic void fullinc (lua_State *L, global_State *g) {\n  if (keepinvariant(g))  /* black objects? */\n    entersweep(L); /* sweep everything to turn them back to white */\n  /* finish any pending sweep phase to start a new cycle */\n  luaC_runtilstate(L, GCSpause, 1);\n  luaC_runtilstate(L, GCScallfin, 1);  /* run up to finalizers */\n  luaC_runtilstate(L, GCSpause, 1);  /* finish collection */\n  setpause(g);\n}\n\n\n/*\n** Performs a full GC cycle; if 'isemergency', set a flag to avoid\n** some operations which could change the interpreter state in some\n** unexpected ways (running finalizers and shrinking some structures).\n*/\nvoid luaC_fullgc (lua_State *L, int isemergency) {\n  global_State *g = G(L);\n  lua_assert(!g->gcemergency);\n  g->gcemergency = cast_byte(isemergency);  /* set flag */\n  switch (g->gckind) {\n    case KGC_GENMINOR: fullgen(L, g); break;\n    case KGC_INC: fullinc(L, g); break;\n    case KGC_GENMAJOR:\n      g->gckind = KGC_INC;\n      fullinc(L, g);\n      g->gckind = KGC_GENMAJOR;\n      break;\n  }\n  g->gcemergency = 0;\n}\n\n/* }====================================================== */\n\n\n"
        },
        {
          "name": "lgc.h",
          "type": "blob",
          "size": 8.7841796875,
          "content": "/*\n** $Id: lgc.h $\n** Garbage Collector\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lgc_h\n#define lgc_h\n\n\n#include <stddef.h>\n\n\n#include \"lobject.h\"\n#include \"lstate.h\"\n\n/*\n** Collectable objects may have one of three colors: white, which means\n** the object is not marked; gray, which means the object is marked, but\n** its references may be not marked; and black, which means that the\n** object and all its references are marked.  The main invariant of the\n** garbage collector, while marking objects, is that a black object can\n** never point to a white one. Moreover, any gray object must be in a\n** \"gray list\" (gray, grayagain, weak, allweak, ephemeron) so that it\n** can be visited again before finishing the collection cycle. (Open\n** upvalues are an exception to this rule, as they are attached to\n** a corresponding thread.)  These lists have no meaning when the\n** invariant is not being enforced (e.g., sweep phase).\n*/\n\n\n/*\n** Possible states of the Garbage Collector\n*/\n#define GCSpropagate\t0\n#define GCSenteratomic\t1\n#define GCSatomic\t2\n#define GCSswpallgc\t3\n#define GCSswpfinobj\t4\n#define GCSswptobefnz\t5\n#define GCSswpend\t6\n#define GCScallfin\t7\n#define GCSpause\t8\n\n\n#define issweepphase(g)  \\\n\t(GCSswpallgc <= (g)->gcstate && (g)->gcstate <= GCSswpend)\n\n\n/*\n** macro to tell when main invariant (white objects cannot point to black\n** ones) must be kept. During a collection, the sweep phase may break\n** the invariant, as objects turned white may point to still-black\n** objects. The invariant is restored when sweep ends and all objects\n** are white again.\n*/\n\n#define keepinvariant(g)\t((g)->gcstate <= GCSatomic)\n\n\n/*\n** some useful bit tricks\n*/\n#define resetbits(x,m)\t\t((x) &= cast_byte(~(m)))\n#define setbits(x,m)\t\t((x) |= (m))\n#define testbits(x,m)\t\t((x) & (m))\n#define bitmask(b)\t\t(1<<(b))\n#define bit2mask(b1,b2)\t\t(bitmask(b1) | bitmask(b2))\n#define l_setbit(x,b)\t\tsetbits(x, bitmask(b))\n#define resetbit(x,b)\t\tresetbits(x, bitmask(b))\n#define testbit(x,b)\t\ttestbits(x, bitmask(b))\n\n\n/*\n** Layout for bit use in 'marked' field. First three bits are\n** used for object \"age\" in generational mode. Last bit is used\n** by tests.\n*/\n#define WHITE0BIT\t3  /* object is white (type 0) */\n#define WHITE1BIT\t4  /* object is white (type 1) */\n#define BLACKBIT\t5  /* object is black */\n#define FINALIZEDBIT\t6  /* object has been marked for finalization */\n\n#define TESTBIT\t\t7\n\n\n\n#define WHITEBITS\tbit2mask(WHITE0BIT, WHITE1BIT)\n\n\n#define iswhite(x)      testbits((x)->marked, WHITEBITS)\n#define isblack(x)      testbit((x)->marked, BLACKBIT)\n#define isgray(x)  /* neither white nor black */  \\\n\t(!testbits((x)->marked, WHITEBITS | bitmask(BLACKBIT)))\n\n#define tofinalize(x)\ttestbit((x)->marked, FINALIZEDBIT)\n\n#define otherwhite(g)\t((g)->currentwhite ^ WHITEBITS)\n#define isdeadm(ow,m)\t((m) & (ow))\n#define isdead(g,v)\tisdeadm(otherwhite(g), (v)->marked)\n\n#define changewhite(x)\t((x)->marked ^= WHITEBITS)\n#define nw2black(x)  \\\n\tcheck_exp(!iswhite(x), l_setbit((x)->marked, BLACKBIT))\n\n#define luaC_white(g)\tcast_byte((g)->currentwhite & WHITEBITS)\n\n\n/* object age in generational mode */\n#define G_NEW\t\t0\t/* created in current cycle */\n#define G_SURVIVAL\t1\t/* created in previous cycle */\n#define G_OLD0\t\t2\t/* marked old by frw. barrier in this cycle */\n#define G_OLD1\t\t3\t/* first full cycle as old */\n#define G_OLD\t\t4\t/* really old object (not to be visited) */\n#define G_TOUCHED1\t5\t/* old object touched this cycle */\n#define G_TOUCHED2\t6\t/* old object touched in previous cycle */\n\n#define AGEBITS\t\t7  /* all age bits (111) */\n\n#define getage(o)\t((o)->marked & AGEBITS)\n#define setage(o,a)  ((o)->marked = cast_byte(((o)->marked & (~AGEBITS)) | a))\n#define isold(o)\t(getage(o) > G_SURVIVAL)\n\n\n/*\n** In generational mode, objects are created 'new'. After surviving one\n** cycle, they become 'survival'. Both 'new' and 'survival' can point\n** to any other object, as they are traversed at the end of the cycle.\n** We call them both 'young' objects.\n** If a survival object survives another cycle, it becomes 'old1'.\n** 'old1' objects can still point to survival objects (but not to\n** new objects), so they still must be traversed. After another cycle\n** (that, being old, 'old1' objects will \"survive\" no matter what)\n** finally the 'old1' object becomes really 'old', and then they\n** are no more traversed.\n**\n** To keep its invariants, the generational mode uses the same barriers\n** also used by the incremental mode. If a young object is caught in a\n** forward barrier, it cannot become old immediately, because it can\n** still point to other young objects. Instead, it becomes 'old0',\n** which in the next cycle becomes 'old1'. So, 'old0' objects is\n** old but can point to new and survival objects; 'old1' is old\n** but cannot point to new objects; and 'old' cannot point to any\n** young object.\n**\n** If any old object ('old0', 'old1', 'old') is caught in a back\n** barrier, it becomes 'touched1' and goes into a gray list, to be\n** visited at the end of the cycle.  There it evolves to 'touched2',\n** which can point to survivals but not to new objects. In yet another\n** cycle then it becomes 'old' again.\n**\n** The generational mode must also control the colors of objects,\n** because of the barriers.  While the mutator is running, young objects\n** are kept white. 'old', 'old1', and 'touched2' objects are kept black,\n** as they cannot point to new objects; exceptions are threads and open\n** upvalues, which age to 'old1' and 'old' but are kept gray. 'old0'\n** objects may be gray or black, as in the incremental mode. 'touched1'\n** objects are kept gray, as they must be visited again at the end of\n** the cycle.\n*/\n\n\n/*\n** {======================================================\n** Default Values for GC parameters\n** =======================================================\n*/\n\n/*\n** Minor collections will shift to major ones after LUAI_MINORMAJOR%\n** bytes become old.\n*/\n#define LUAI_MINORMAJOR         70\n\n/*\n** Major collections will shift to minor ones after a collection\n** collects at least LUAI_MAJORMINOR% of the new bytes.\n*/\n#define LUAI_MAJORMINOR         50\n\n/*\n** A young (minor) collection will run after creating LUAI_GENMINORMUL%\n** new bytes.\n*/\n#define LUAI_GENMINORMUL         20\n\n\n/* incremental */\n\n/* Number of bytes must be LUAI_GCPAUSE% before starting new cycle */\n#define LUAI_GCPAUSE    250\n\n/*\n** Step multiplier: The collector handles LUAI_GCMUL% work units for\n** each new allocated word. (Each \"work unit\" corresponds roughly to\n** sweeping one object or traversing one slot.)\n*/\n#define LUAI_GCMUL      200\n\n/* How many bytes to allocate before next GC step */\n#define LUAI_GCSTEPSIZE\t(200 * sizeof(Table))\n\n\n#define setgcparam(g,p,v)  (g->gcparams[LUA_GCP##p] = luaO_codeparam(v))\n#define applygcparam(g,p,x)  luaO_applyparam(g->gcparams[LUA_GCP##p], x)\n\n/* }====================================================== */\n\n\n/*\n** Control when GC is running:\n*/\n#define GCSTPUSR\t1  /* bit true when GC stopped by user */\n#define GCSTPGC\t\t2  /* bit true when GC stopped by itself */\n#define GCSTPCLS\t4  /* bit true when closing Lua state */\n#define gcrunning(g)\t((g)->gcstp == 0)\n\n\n/*\n** Does one step of collection when debt becomes zero. 'pre'/'pos'\n** allows some adjustments to be done only when needed. macro\n** 'condchangemem' is used only for heavy tests (forcing a full\n** GC cycle on every opportunity)\n*/\n\n#if !defined(HARDMEMTESTS)\n#define condchangemem(L,pre,pos)\t((void)0)\n#else\n#define condchangemem(L,pre,pos)  \\\n\t{ if (gcrunning(G(L))) { pre; luaC_fullgc(L, 0); pos; } }\n#endif\n\n#define luaC_condGC(L,pre,pos) \\\n\t{ if (G(L)->GCdebt <= 0) { pre; luaC_step(L); pos;}; \\\n\t  condchangemem(L,pre,pos); }\n\n/* more often than not, 'pre'/'pos' are empty */\n#define luaC_checkGC(L)\t\tluaC_condGC(L,(void)0,(void)0)\n\n\n#define luaC_objbarrier(L,p,o) (  \\\n\t(isblack(p) && iswhite(o)) ? \\\n\tluaC_barrier_(L,obj2gco(p),obj2gco(o)) : cast_void(0))\n\n#define luaC_barrier(L,p,v) (  \\\n\tiscollectable(v) ? luaC_objbarrier(L,p,gcvalue(v)) : cast_void(0))\n\n#define luaC_objbarrierback(L,p,o) (  \\\n\t(isblack(p) && iswhite(o)) ? luaC_barrierback_(L,p) : cast_void(0))\n\n#define luaC_barrierback(L,p,v) (  \\\n\tiscollectable(v) ? luaC_objbarrierback(L, p, gcvalue(v)) : cast_void(0))\n\nLUAI_FUNC void luaC_fix (lua_State *L, GCObject *o);\nLUAI_FUNC void luaC_freeallobjects (lua_State *L);\nLUAI_FUNC void luaC_step (lua_State *L);\nLUAI_FUNC void luaC_runtilstate (lua_State *L, int state, int fast);\nLUAI_FUNC void luaC_fullgc (lua_State *L, int isemergency);\nLUAI_FUNC GCObject *luaC_newobj (lua_State *L, lu_byte tt, size_t sz);\nLUAI_FUNC GCObject *luaC_newobjdt (lua_State *L, lu_byte tt, size_t sz,\n                                                 size_t offset);\nLUAI_FUNC void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v);\nLUAI_FUNC void luaC_barrierback_ (lua_State *L, GCObject *o);\nLUAI_FUNC void luaC_checkfinalizer (lua_State *L, GCObject *o, Table *mt);\nLUAI_FUNC void luaC_changemode (lua_State *L, int newmode);\n\n\n#endif\n"
        },
        {
          "name": "linit.c",
          "type": "blob",
          "size": 1.4931640625,
          "content": "/*\n** $Id: linit.c $\n** Initialization of libraries for lua.c and other clients\n** See Copyright Notice in lua.h\n*/\n\n\n#define linit_c\n#define LUA_LIB\n\n\n#include \"lprefix.h\"\n\n\n#include <stddef.h>\n\n#include \"lua.h\"\n\n#include \"lualib.h\"\n#include \"lauxlib.h\"\n#include \"llimits.h\"\n\n\n/*\n** Standard Libraries. (Must be listed in the same ORDER of their\n** respective constants LUA_<libname>K.)\n*/\nstatic const luaL_Reg stdlibs[] = {\n  {LUA_GNAME, luaopen_base},\n  {LUA_LOADLIBNAME, luaopen_package},\n  {LUA_COLIBNAME, luaopen_coroutine},\n  {LUA_DBLIBNAME, luaopen_debug},\n  {LUA_IOLIBNAME, luaopen_io},\n  {LUA_MATHLIBNAME, luaopen_math},\n  {LUA_OSLIBNAME, luaopen_os},\n  {LUA_STRLIBNAME, luaopen_string},\n  {LUA_TABLIBNAME, luaopen_table},\n  {LUA_UTF8LIBNAME, luaopen_utf8},\n  {NULL, NULL}\n};\n\n\n/*\n** require and preload selected standard libraries\n*/\nLUALIB_API void luaL_openselectedlibs (lua_State *L, int load, int preload) {\n  int mask;\n  const luaL_Reg *lib;\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);\n  for (lib = stdlibs, mask = 1; lib->name != NULL; lib++, mask <<= 1) {\n    if (load & mask) {  /* selected? */\n      luaL_requiref(L, lib->name, lib->func, 1);  /* require library */\n      lua_pop(L, 1);  /* remove result from the stack */\n    }\n    else if (preload & mask) {  /* selected? */\n      lua_pushcfunction(L, lib->func);\n      lua_setfield(L, -2, lib->name);  /* add library to PRELOAD table */\n    }\n  }\n  lua_assert((mask >> 1) == LUA_UTF8LIBK);\n  lua_pop(L, 1);  /* remove PRELOAD table */\n}\n\n"
        },
        {
          "name": "liolib.c",
          "type": "blob",
          "size": 21.5517578125,
          "content": "/*\n** $Id: liolib.c $\n** Standard I/O (and system) library\n** See Copyright Notice in lua.h\n*/\n\n#define liolib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <ctype.h>\n#include <errno.h>\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n#include \"llimits.h\"\n\n\n/*\n** Change this macro to accept other modes for 'fopen' besides\n** the standard ones.\n*/\n#if !defined(l_checkmode)\n\n/* accepted extensions to 'mode' in 'fopen' */\n#if !defined(L_MODEEXT)\n#define L_MODEEXT\t\"b\"\n#endif\n\n/* Check whether 'mode' matches '[rwa]%+?[L_MODEEXT]*' */\nstatic int l_checkmode (const char *mode) {\n  return (*mode != '\\0' && strchr(\"rwa\", *(mode++)) != NULL &&\n         (*mode != '+' || ((void)(++mode), 1)) &&  /* skip if char is '+' */\n         (strspn(mode, L_MODEEXT) == strlen(mode)));  /* check extensions */\n}\n\n#endif\n\n/*\n** {======================================================\n** l_popen spawns a new process connected to the current\n** one through the file streams.\n** =======================================================\n*/\n\n#if !defined(l_popen)\t\t/* { */\n\n#if defined(LUA_USE_POSIX)\t/* { */\n\n#define l_popen(L,c,m)\t\t(fflush(NULL), popen(c,m))\n#define l_pclose(L,file)\t(pclose(file))\n\n#elif defined(LUA_USE_WINDOWS)\t/* }{ */\n\n#define l_popen(L,c,m)\t\t(_popen(c,m))\n#define l_pclose(L,file)\t(_pclose(file))\n\n#if !defined(l_checkmodep)\n/* Windows accepts \"[rw][bt]?\" as valid modes */\n#define l_checkmodep(m)\t((m[0] == 'r' || m[0] == 'w') && \\\n  (m[1] == '\\0' || ((m[1] == 'b' || m[1] == 't') && m[2] == '\\0')))\n#endif\n\n#else\t\t\t\t/* }{ */\n\n/* ISO C definitions */\n#define l_popen(L,c,m)  \\\n\t  ((void)c, (void)m, \\\n\t  luaL_error(L, \"'popen' not supported\"), \\\n\t  (FILE*)0)\n#define l_pclose(L,file)\t\t((void)L, (void)file, -1)\n\n#endif\t\t\t\t/* } */\n\n#endif\t\t\t\t/* } */\n\n\n#if !defined(l_checkmodep)\n/* By default, Lua accepts only \"r\" or \"w\" as valid modes */\n#define l_checkmodep(m)        ((m[0] == 'r' || m[0] == 'w') && m[1] == '\\0')\n#endif\n\n/* }====================================================== */\n\n\n#if !defined(l_getc)\t\t/* { */\n\n#if defined(LUA_USE_POSIX)\n#define l_getc(f)\t\tgetc_unlocked(f)\n#define l_lockfile(f)\t\tflockfile(f)\n#define l_unlockfile(f)\t\tfunlockfile(f)\n#else\n#define l_getc(f)\t\tgetc(f)\n#define l_lockfile(f)\t\t((void)0)\n#define l_unlockfile(f)\t\t((void)0)\n#endif\n\n#endif\t\t\t\t/* } */\n\n\n/*\n** {======================================================\n** l_fseek: configuration for longer offsets\n** =======================================================\n*/\n\n#if !defined(l_fseek)\t\t/* { */\n\n#if defined(LUA_USE_POSIX)\t/* { */\n\n#include <sys/types.h>\n\n#define l_fseek(f,o,w)\t\tfseeko(f,o,w)\n#define l_ftell(f)\t\tftello(f)\n#define l_seeknum\t\toff_t\n\n#elif defined(LUA_USE_WINDOWS) && !defined(_CRTIMP_TYPEINFO) \\\n   && defined(_MSC_VER) && (_MSC_VER >= 1400)\t/* }{ */\n\n/* Windows (but not DDK) and Visual C++ 2005 or higher */\n#define l_fseek(f,o,w)\t\t_fseeki64(f,o,w)\n#define l_ftell(f)\t\t_ftelli64(f)\n#define l_seeknum\t\t__int64\n\n#else\t\t\t\t/* }{ */\n\n/* ISO C definitions */\n#define l_fseek(f,o,w)\t\tfseek(f,o,w)\n#define l_ftell(f)\t\tftell(f)\n#define l_seeknum\t\tlong\n\n#endif\t\t\t\t/* } */\n\n#endif\t\t\t\t/* } */\n\n/* }====================================================== */\n\n\n\n#define IO_PREFIX\t\"_IO_\"\n#define IOPREF_LEN\t(sizeof(IO_PREFIX)/sizeof(char) - 1)\n#define IO_INPUT\t(IO_PREFIX \"input\")\n#define IO_OUTPUT\t(IO_PREFIX \"output\")\n\n\ntypedef luaL_Stream LStream;\n\n\n#define tolstream(L)\t((LStream *)luaL_checkudata(L, 1, LUA_FILEHANDLE))\n\n#define isclosed(p)\t((p)->closef == NULL)\n\n\nstatic int io_type (lua_State *L) {\n  LStream *p;\n  luaL_checkany(L, 1);\n  p = (LStream *)luaL_testudata(L, 1, LUA_FILEHANDLE);\n  if (p == NULL)\n    luaL_pushfail(L);  /* not a file */\n  else if (isclosed(p))\n    lua_pushliteral(L, \"closed file\");\n  else\n    lua_pushliteral(L, \"file\");\n  return 1;\n}\n\n\nstatic int f_tostring (lua_State *L) {\n  LStream *p = tolstream(L);\n  if (isclosed(p))\n    lua_pushliteral(L, \"file (closed)\");\n  else\n    lua_pushfstring(L, \"file (%p)\", p->f);\n  return 1;\n}\n\n\nstatic FILE *tofile (lua_State *L) {\n  LStream *p = tolstream(L);\n  if (l_unlikely(isclosed(p)))\n    luaL_error(L, \"attempt to use a closed file\");\n  lua_assert(p->f);\n  return p->f;\n}\n\n\n/*\n** When creating file handles, always creates a 'closed' file handle\n** before opening the actual file; so, if there is a memory error, the\n** handle is in a consistent state.\n*/\nstatic LStream *newprefile (lua_State *L) {\n  LStream *p = (LStream *)lua_newuserdatauv(L, sizeof(LStream), 0);\n  p->closef = NULL;  /* mark file handle as 'closed' */\n  luaL_setmetatable(L, LUA_FILEHANDLE);\n  return p;\n}\n\n\n/*\n** Calls the 'close' function from a file handle. The 'volatile' avoids\n** a bug in some versions of the Clang compiler (e.g., clang 3.0 for\n** 32 bits).\n*/\nstatic int aux_close (lua_State *L) {\n  LStream *p = tolstream(L);\n  volatile lua_CFunction cf = p->closef;\n  p->closef = NULL;  /* mark stream as closed */\n  return (*cf)(L);  /* close it */\n}\n\n\nstatic int f_close (lua_State *L) {\n  tofile(L);  /* make sure argument is an open stream */\n  return aux_close(L);\n}\n\n\nstatic int io_close (lua_State *L) {\n  if (lua_isnone(L, 1))  /* no argument? */\n    lua_getfield(L, LUA_REGISTRYINDEX, IO_OUTPUT);  /* use default output */\n  return f_close(L);\n}\n\n\nstatic int f_gc (lua_State *L) {\n  LStream *p = tolstream(L);\n  if (!isclosed(p) && p->f != NULL)\n    aux_close(L);  /* ignore closed and incompletely open files */\n  return 0;\n}\n\n\n/*\n** function to close regular files\n*/\nstatic int io_fclose (lua_State *L) {\n  LStream *p = tolstream(L);\n  errno = 0;\n  return luaL_fileresult(L, (fclose(p->f) == 0), NULL);\n}\n\n\nstatic LStream *newfile (lua_State *L) {\n  LStream *p = newprefile(L);\n  p->f = NULL;\n  p->closef = &io_fclose;\n  return p;\n}\n\n\nstatic void opencheck (lua_State *L, const char *fname, const char *mode) {\n  LStream *p = newfile(L);\n  p->f = fopen(fname, mode);\n  if (l_unlikely(p->f == NULL))\n    luaL_error(L, \"cannot open file '%s' (%s)\", fname, strerror(errno));\n}\n\n\nstatic int io_open (lua_State *L) {\n  const char *filename = luaL_checkstring(L, 1);\n  const char *mode = luaL_optstring(L, 2, \"r\");\n  LStream *p = newfile(L);\n  const char *md = mode;  /* to traverse/check mode */\n  luaL_argcheck(L, l_checkmode(md), 2, \"invalid mode\");\n  errno = 0;\n  p->f = fopen(filename, mode);\n  return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;\n}\n\n\n/*\n** function to close 'popen' files\n*/\nstatic int io_pclose (lua_State *L) {\n  LStream *p = tolstream(L);\n  errno = 0;\n  return luaL_execresult(L, l_pclose(L, p->f));\n}\n\n\nstatic int io_popen (lua_State *L) {\n  const char *filename = luaL_checkstring(L, 1);\n  const char *mode = luaL_optstring(L, 2, \"r\");\n  LStream *p = newprefile(L);\n  luaL_argcheck(L, l_checkmodep(mode), 2, \"invalid mode\");\n  errno = 0;\n  p->f = l_popen(L, filename, mode);\n  p->closef = &io_pclose;\n  return (p->f == NULL) ? luaL_fileresult(L, 0, filename) : 1;\n}\n\n\nstatic int io_tmpfile (lua_State *L) {\n  LStream *p = newfile(L);\n  errno = 0;\n  p->f = tmpfile();\n  return (p->f == NULL) ? luaL_fileresult(L, 0, NULL) : 1;\n}\n\n\nstatic FILE *getiofile (lua_State *L, const char *findex) {\n  LStream *p;\n  lua_getfield(L, LUA_REGISTRYINDEX, findex);\n  p = (LStream *)lua_touserdata(L, -1);\n  if (l_unlikely(isclosed(p)))\n    luaL_error(L, \"default %s file is closed\", findex + IOPREF_LEN);\n  return p->f;\n}\n\n\nstatic int g_iofile (lua_State *L, const char *f, const char *mode) {\n  if (!lua_isnoneornil(L, 1)) {\n    const char *filename = lua_tostring(L, 1);\n    if (filename)\n      opencheck(L, filename, mode);\n    else {\n      tofile(L);  /* check that it's a valid file handle */\n      lua_pushvalue(L, 1);\n    }\n    lua_setfield(L, LUA_REGISTRYINDEX, f);\n  }\n  /* return current value */\n  lua_getfield(L, LUA_REGISTRYINDEX, f);\n  return 1;\n}\n\n\nstatic int io_input (lua_State *L) {\n  return g_iofile(L, IO_INPUT, \"r\");\n}\n\n\nstatic int io_output (lua_State *L) {\n  return g_iofile(L, IO_OUTPUT, \"w\");\n}\n\n\nstatic int io_readline (lua_State *L);\n\n\n/*\n** maximum number of arguments to 'f:lines'/'io.lines' (it + 3 must fit\n** in the limit for upvalues of a closure)\n*/\n#define MAXARGLINE\t250\n\n/*\n** Auxiliary function to create the iteration function for 'lines'.\n** The iteration function is a closure over 'io_readline', with\n** the following upvalues:\n** 1) The file being read (first value in the stack)\n** 2) the number of arguments to read\n** 3) a boolean, true iff file has to be closed when finished ('toclose')\n** *) a variable number of format arguments (rest of the stack)\n*/\nstatic void aux_lines (lua_State *L, int toclose) {\n  int n = lua_gettop(L) - 1;  /* number of arguments to read */\n  luaL_argcheck(L, n <= MAXARGLINE, MAXARGLINE + 2, \"too many arguments\");\n  lua_pushvalue(L, 1);  /* file */\n  lua_pushinteger(L, n);  /* number of arguments to read */\n  lua_pushboolean(L, toclose);  /* close/not close file when finished */\n  lua_rotate(L, 2, 3);  /* move the three values to their positions */\n  lua_pushcclosure(L, io_readline, 3 + n);\n}\n\n\nstatic int f_lines (lua_State *L) {\n  tofile(L);  /* check that it's a valid file handle */\n  aux_lines(L, 0);\n  return 1;\n}\n\n\n/*\n** Return an iteration function for 'io.lines'. If file has to be\n** closed, also returns the file itself as a second result (to be\n** closed as the state at the exit of a generic for).\n*/\nstatic int io_lines (lua_State *L) {\n  int toclose;\n  if (lua_isnone(L, 1)) lua_pushnil(L);  /* at least one argument */\n  if (lua_isnil(L, 1)) {  /* no file name? */\n    lua_getfield(L, LUA_REGISTRYINDEX, IO_INPUT);  /* get default input */\n    lua_replace(L, 1);  /* put it at index 1 */\n    tofile(L);  /* check that it's a valid file handle */\n    toclose = 0;  /* do not close it after iteration */\n  }\n  else {  /* open a new file */\n    const char *filename = luaL_checkstring(L, 1);\n    opencheck(L, filename, \"r\");\n    lua_replace(L, 1);  /* put file at index 1 */\n    toclose = 1;  /* close it after iteration */\n  }\n  aux_lines(L, toclose);  /* push iteration function */\n  if (toclose) {\n    lua_pushnil(L);  /* state */\n    lua_pushnil(L);  /* control */\n    lua_pushvalue(L, 1);  /* file is the to-be-closed variable (4th result) */\n    return 4;\n  }\n  else\n    return 1;\n}\n\n\n/*\n** {======================================================\n** READ\n** =======================================================\n*/\n\n\n/* maximum length of a numeral */\n#if !defined (L_MAXLENNUM)\n#define L_MAXLENNUM     200\n#endif\n\n\n/* auxiliary structure used by 'read_number' */\ntypedef struct {\n  FILE *f;  /* file being read */\n  int c;  /* current character (look ahead) */\n  int n;  /* number of elements in buffer 'buff' */\n  char buff[L_MAXLENNUM + 1];  /* +1 for ending '\\0' */\n} RN;\n\n\n/*\n** Add current char to buffer (if not out of space) and read next one\n*/\nstatic int nextc (RN *rn) {\n  if (l_unlikely(rn->n >= L_MAXLENNUM)) {  /* buffer overflow? */\n    rn->buff[0] = '\\0';  /* invalidate result */\n    return 0;  /* fail */\n  }\n  else {\n    rn->buff[rn->n++] = cast_char(rn->c);  /* save current char */\n    rn->c = l_getc(rn->f);  /* read next one */\n    return 1;\n  }\n}\n\n\n/*\n** Accept current char if it is in 'set' (of size 2)\n*/\nstatic int test2 (RN *rn, const char *set) {\n  if (rn->c == set[0] || rn->c == set[1])\n    return nextc(rn);\n  else return 0;\n}\n\n\n/*\n** Read a sequence of (hex)digits\n*/\nstatic int readdigits (RN *rn, int hex) {\n  int count = 0;\n  while ((hex ? isxdigit(rn->c) : isdigit(rn->c)) && nextc(rn))\n    count++;\n  return count;\n}\n\n\n/*\n** Read a number: first reads a valid prefix of a numeral into a buffer.\n** Then it calls 'lua_stringtonumber' to check whether the format is\n** correct and to convert it to a Lua number.\n*/\nstatic int read_number (lua_State *L, FILE *f) {\n  RN rn;\n  int count = 0;\n  int hex = 0;\n  char decp[2];\n  rn.f = f; rn.n = 0;\n  decp[0] = lua_getlocaledecpoint();  /* get decimal point from locale */\n  decp[1] = '.';  /* always accept a dot */\n  l_lockfile(rn.f);\n  do { rn.c = l_getc(rn.f); } while (isspace(rn.c));  /* skip spaces */\n  test2(&rn, \"-+\");  /* optional sign */\n  if (test2(&rn, \"00\")) {\n    if (test2(&rn, \"xX\")) hex = 1;  /* numeral is hexadecimal */\n    else count = 1;  /* count initial '0' as a valid digit */\n  }\n  count += readdigits(&rn, hex);  /* integral part */\n  if (test2(&rn, decp))  /* decimal point? */\n    count += readdigits(&rn, hex);  /* fractional part */\n  if (count > 0 && test2(&rn, (hex ? \"pP\" : \"eE\"))) {  /* exponent mark? */\n    test2(&rn, \"-+\");  /* exponent sign */\n    readdigits(&rn, 0);  /* exponent digits */\n  }\n  ungetc(rn.c, rn.f);  /* unread look-ahead char */\n  l_unlockfile(rn.f);\n  rn.buff[rn.n] = '\\0';  /* finish string */\n  if (l_likely(lua_stringtonumber(L, rn.buff)))\n    return 1;  /* ok, it is a valid number */\n  else {  /* invalid format */\n   lua_pushnil(L);  /* \"result\" to be removed */\n   return 0;  /* read fails */\n  }\n}\n\n\nstatic int test_eof (lua_State *L, FILE *f) {\n  int c = getc(f);\n  ungetc(c, f);  /* no-op when c == EOF */\n  lua_pushliteral(L, \"\");\n  return (c != EOF);\n}\n\n\nstatic int read_line (lua_State *L, FILE *f, int chop) {\n  luaL_Buffer b;\n  int c;\n  luaL_buffinit(L, &b);\n  do {  /* may need to read several chunks to get whole line */\n    char *buff = luaL_prepbuffer(&b);  /* preallocate buffer space */\n    unsigned i = 0;\n    l_lockfile(f);  /* no memory errors can happen inside the lock */\n    while (i < LUAL_BUFFERSIZE && (c = l_getc(f)) != EOF && c != '\\n')\n      buff[i++] = cast_char(c);  /* read up to end of line or buffer limit */\n    l_unlockfile(f);\n    luaL_addsize(&b, i);\n  } while (c != EOF && c != '\\n');  /* repeat until end of line */\n  if (!chop && c == '\\n')  /* want a newline and have one? */\n    luaL_addchar(&b, '\\n');  /* add ending newline to result */\n  luaL_pushresult(&b);  /* close buffer */\n  /* return ok if read something (either a newline or something else) */\n  return (c == '\\n' || lua_rawlen(L, -1) > 0);\n}\n\n\nstatic void read_all (lua_State *L, FILE *f) {\n  size_t nr;\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  do {  /* read file in chunks of LUAL_BUFFERSIZE bytes */\n    char *p = luaL_prepbuffer(&b);\n    nr = fread(p, sizeof(char), LUAL_BUFFERSIZE, f);\n    luaL_addsize(&b, nr);\n  } while (nr == LUAL_BUFFERSIZE);\n  luaL_pushresult(&b);  /* close buffer */\n}\n\n\nstatic int read_chars (lua_State *L, FILE *f, size_t n) {\n  size_t nr;  /* number of chars actually read */\n  char *p;\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  p = luaL_prepbuffsize(&b, n);  /* prepare buffer to read whole block */\n  nr = fread(p, sizeof(char), n, f);  /* try to read 'n' chars */\n  luaL_addsize(&b, nr);\n  luaL_pushresult(&b);  /* close buffer */\n  return (nr > 0);  /* true iff read something */\n}\n\n\nstatic int g_read (lua_State *L, FILE *f, int first) {\n  int nargs = lua_gettop(L) - 1;\n  int n, success;\n  clearerr(f);\n  errno = 0;\n  if (nargs == 0) {  /* no arguments? */\n    success = read_line(L, f, 1);\n    n = first + 1;  /* to return 1 result */\n  }\n  else {\n    /* ensure stack space for all results and for auxlib's buffer */\n    luaL_checkstack(L, nargs+LUA_MINSTACK, \"too many arguments\");\n    success = 1;\n    for (n = first; nargs-- && success; n++) {\n      if (lua_type(L, n) == LUA_TNUMBER) {\n        size_t l = (size_t)luaL_checkinteger(L, n);\n        success = (l == 0) ? test_eof(L, f) : read_chars(L, f, l);\n      }\n      else {\n        const char *p = luaL_checkstring(L, n);\n        if (*p == '*') p++;  /* skip optional '*' (for compatibility) */\n        switch (*p) {\n          case 'n':  /* number */\n            success = read_number(L, f);\n            break;\n          case 'l':  /* line */\n            success = read_line(L, f, 1);\n            break;\n          case 'L':  /* line with end-of-line */\n            success = read_line(L, f, 0);\n            break;\n          case 'a':  /* file */\n            read_all(L, f);  /* read entire file */\n            success = 1; /* always success */\n            break;\n          default:\n            return luaL_argerror(L, n, \"invalid format\");\n        }\n      }\n    }\n  }\n  if (ferror(f))\n    return luaL_fileresult(L, 0, NULL);\n  if (!success) {\n    lua_pop(L, 1);  /* remove last result */\n    luaL_pushfail(L);  /* push nil instead */\n  }\n  return n - first;\n}\n\n\nstatic int io_read (lua_State *L) {\n  return g_read(L, getiofile(L, IO_INPUT), 1);\n}\n\n\nstatic int f_read (lua_State *L) {\n  return g_read(L, tofile(L), 2);\n}\n\n\n/*\n** Iteration function for 'lines'.\n*/\nstatic int io_readline (lua_State *L) {\n  LStream *p = (LStream *)lua_touserdata(L, lua_upvalueindex(1));\n  int i;\n  int n = (int)lua_tointeger(L, lua_upvalueindex(2));\n  if (isclosed(p))  /* file is already closed? */\n    return luaL_error(L, \"file is already closed\");\n  lua_settop(L , 1);\n  luaL_checkstack(L, n, \"too many arguments\");\n  for (i = 1; i <= n; i++)  /* push arguments to 'g_read' */\n    lua_pushvalue(L, lua_upvalueindex(3 + i));\n  n = g_read(L, p->f, 2);  /* 'n' is number of results */\n  lua_assert(n > 0);  /* should return at least a nil */\n  if (lua_toboolean(L, -n))  /* read at least one value? */\n    return n;  /* return them */\n  else {  /* first result is false: EOF or error */\n    if (n > 1) {  /* is there error information? */\n      /* 2nd result is error message */\n      return luaL_error(L, \"%s\", lua_tostring(L, -n + 1));\n    }\n    if (lua_toboolean(L, lua_upvalueindex(3))) {  /* generator created file? */\n      lua_settop(L, 0);  /* clear stack */\n      lua_pushvalue(L, lua_upvalueindex(1));  /* push file at index 1 */\n      aux_close(L);  /* close it */\n    }\n    return 0;\n  }\n}\n\n/* }====================================================== */\n\n\nstatic int g_write (lua_State *L, FILE *f, int arg) {\n  int nargs = lua_gettop(L) - arg;\n  int status = 1;\n  errno = 0;\n  for (; nargs--; arg++) {\n    char buff[LUA_N2SBUFFSZ];\n    const char *s;\n    size_t len = lua_numbertostrbuff(L, arg, buff);  /* try as a number */\n    if (len > 0) {  /* did conversion work (value was a number)? */\n      s = buff;\n      len--;\n    }\n    else  /* must be a string */\n      s = luaL_checklstring(L, arg, &len);\n    status = status && (fwrite(s, sizeof(char), len, f) == len);\n  }\n  if (l_likely(status))\n    return 1;  /* file handle already on stack top */\n  else\n    return luaL_fileresult(L, status, NULL);\n}\n\n\nstatic int io_write (lua_State *L) {\n  return g_write(L, getiofile(L, IO_OUTPUT), 1);\n}\n\n\nstatic int f_write (lua_State *L) {\n  FILE *f = tofile(L);\n  lua_pushvalue(L, 1);  /* push file at the stack top (to be returned) */\n  return g_write(L, f, 2);\n}\n\n\nstatic int f_seek (lua_State *L) {\n  static const int mode[] = {SEEK_SET, SEEK_CUR, SEEK_END};\n  static const char *const modenames[] = {\"set\", \"cur\", \"end\", NULL};\n  FILE *f = tofile(L);\n  int op = luaL_checkoption(L, 2, \"cur\", modenames);\n  lua_Integer p3 = luaL_optinteger(L, 3, 0);\n  l_seeknum offset = (l_seeknum)p3;\n  luaL_argcheck(L, (lua_Integer)offset == p3, 3,\n                  \"not an integer in proper range\");\n  errno = 0;\n  op = l_fseek(f, offset, mode[op]);\n  if (l_unlikely(op))\n    return luaL_fileresult(L, 0, NULL);  /* error */\n  else {\n    lua_pushinteger(L, (lua_Integer)l_ftell(f));\n    return 1;\n  }\n}\n\n\nstatic int f_setvbuf (lua_State *L) {\n  static const int mode[] = {_IONBF, _IOFBF, _IOLBF};\n  static const char *const modenames[] = {\"no\", \"full\", \"line\", NULL};\n  FILE *f = tofile(L);\n  int op = luaL_checkoption(L, 2, NULL, modenames);\n  lua_Integer sz = luaL_optinteger(L, 3, LUAL_BUFFERSIZE);\n  int res;\n  errno = 0;\n  res = setvbuf(f, NULL, mode[op], (size_t)sz);\n  return luaL_fileresult(L, res == 0, NULL);\n}\n\n\n\nstatic int io_flush (lua_State *L) {\n  FILE *f = getiofile(L, IO_OUTPUT);\n  errno = 0;\n  return luaL_fileresult(L, fflush(f) == 0, NULL);\n}\n\n\nstatic int f_flush (lua_State *L) {\n  FILE *f = tofile(L);\n  errno = 0;\n  return luaL_fileresult(L, fflush(f) == 0, NULL);\n}\n\n\n/*\n** functions for 'io' library\n*/\nstatic const luaL_Reg iolib[] = {\n  {\"close\", io_close},\n  {\"flush\", io_flush},\n  {\"input\", io_input},\n  {\"lines\", io_lines},\n  {\"open\", io_open},\n  {\"output\", io_output},\n  {\"popen\", io_popen},\n  {\"read\", io_read},\n  {\"tmpfile\", io_tmpfile},\n  {\"type\", io_type},\n  {\"write\", io_write},\n  {NULL, NULL}\n};\n\n\n/*\n** methods for file handles\n*/\nstatic const luaL_Reg meth[] = {\n  {\"read\", f_read},\n  {\"write\", f_write},\n  {\"lines\", f_lines},\n  {\"flush\", f_flush},\n  {\"seek\", f_seek},\n  {\"close\", f_close},\n  {\"setvbuf\", f_setvbuf},\n  {NULL, NULL}\n};\n\n\n/*\n** metamethods for file handles\n*/\nstatic const luaL_Reg metameth[] = {\n  {\"__index\", NULL},  /* placeholder */\n  {\"__gc\", f_gc},\n  {\"__close\", f_gc},\n  {\"__tostring\", f_tostring},\n  {NULL, NULL}\n};\n\n\nstatic void createmeta (lua_State *L) {\n  luaL_newmetatable(L, LUA_FILEHANDLE);  /* metatable for file handles */\n  luaL_setfuncs(L, metameth, 0);  /* add metamethods to new metatable */\n  luaL_newlibtable(L, meth);  /* create method table */\n  luaL_setfuncs(L, meth, 0);  /* add file methods to method table */\n  lua_setfield(L, -2, \"__index\");  /* metatable.__index = method table */\n  lua_pop(L, 1);  /* pop metatable */\n}\n\n\n/*\n** function to (not) close the standard files stdin, stdout, and stderr\n*/\nstatic int io_noclose (lua_State *L) {\n  LStream *p = tolstream(L);\n  p->closef = &io_noclose;  /* keep file opened */\n  luaL_pushfail(L);\n  lua_pushliteral(L, \"cannot close standard file\");\n  return 2;\n}\n\n\nstatic void createstdfile (lua_State *L, FILE *f, const char *k,\n                           const char *fname) {\n  LStream *p = newprefile(L);\n  p->f = f;\n  p->closef = &io_noclose;\n  if (k != NULL) {\n    lua_pushvalue(L, -1);\n    lua_setfield(L, LUA_REGISTRYINDEX, k);  /* add file to registry */\n  }\n  lua_setfield(L, -2, fname);  /* add file to module */\n}\n\n\nLUAMOD_API int luaopen_io (lua_State *L) {\n  luaL_newlib(L, iolib);  /* new module */\n  createmeta(L);\n  /* create (and set) default files */\n  createstdfile(L, stdin, IO_INPUT, \"stdin\");\n  createstdfile(L, stdout, IO_OUTPUT, \"stdout\");\n  createstdfile(L, stderr, NULL, \"stderr\");\n  return 1;\n}\n\n"
        },
        {
          "name": "ljumptab.h",
          "type": "blob",
          "size": 1.6240234375,
          "content": "/*\n** $Id: ljumptab.h $\n** Jump Table for the Lua interpreter\n** See Copyright Notice in lua.h\n*/\n\n\n#undef vmdispatch\n#undef vmcase\n#undef vmbreak\n\n#define vmdispatch(x)     goto *disptab[x];\n\n#define vmcase(l)     L_##l:\n\n#define vmbreak\t\tvmfetch(); vmdispatch(GET_OPCODE(i));\n\n\nstatic const void *const disptab[NUM_OPCODES] = {\n\n#if 0\n** you can update the following list with this command:\n**\n**  sed -n '/^OP_/\\!d; s/OP_/\\&\\&L_OP_/ ; s/,.*/,/ ; s/\\/.*// ; p'  lopcodes.h\n**\n#endif\n\n&&L_OP_MOVE,\n&&L_OP_LOADI,\n&&L_OP_LOADF,\n&&L_OP_LOADK,\n&&L_OP_LOADKX,\n&&L_OP_LOADFALSE,\n&&L_OP_LFALSESKIP,\n&&L_OP_LOADTRUE,\n&&L_OP_LOADNIL,\n&&L_OP_GETUPVAL,\n&&L_OP_SETUPVAL,\n&&L_OP_GETTABUP,\n&&L_OP_GETTABLE,\n&&L_OP_GETI,\n&&L_OP_GETFIELD,\n&&L_OP_SETTABUP,\n&&L_OP_SETTABLE,\n&&L_OP_SETI,\n&&L_OP_SETFIELD,\n&&L_OP_NEWTABLE,\n&&L_OP_SELF,\n&&L_OP_ADDI,\n&&L_OP_ADDK,\n&&L_OP_SUBK,\n&&L_OP_MULK,\n&&L_OP_MODK,\n&&L_OP_POWK,\n&&L_OP_DIVK,\n&&L_OP_IDIVK,\n&&L_OP_BANDK,\n&&L_OP_BORK,\n&&L_OP_BXORK,\n&&L_OP_SHRI,\n&&L_OP_SHLI,\n&&L_OP_ADD,\n&&L_OP_SUB,\n&&L_OP_MUL,\n&&L_OP_MOD,\n&&L_OP_POW,\n&&L_OP_DIV,\n&&L_OP_IDIV,\n&&L_OP_BAND,\n&&L_OP_BOR,\n&&L_OP_BXOR,\n&&L_OP_SHL,\n&&L_OP_SHR,\n&&L_OP_MMBIN,\n&&L_OP_MMBINI,\n&&L_OP_MMBINK,\n&&L_OP_UNM,\n&&L_OP_BNOT,\n&&L_OP_NOT,\n&&L_OP_LEN,\n&&L_OP_CONCAT,\n&&L_OP_CLOSE,\n&&L_OP_TBC,\n&&L_OP_JMP,\n&&L_OP_EQ,\n&&L_OP_LT,\n&&L_OP_LE,\n&&L_OP_EQK,\n&&L_OP_EQI,\n&&L_OP_LTI,\n&&L_OP_LEI,\n&&L_OP_GTI,\n&&L_OP_GEI,\n&&L_OP_TEST,\n&&L_OP_TESTSET,\n&&L_OP_CALL,\n&&L_OP_TAILCALL,\n&&L_OP_RETURN,\n&&L_OP_RETURN0,\n&&L_OP_RETURN1,\n&&L_OP_FORLOOP,\n&&L_OP_FORPREP,\n&&L_OP_TFORPREP,\n&&L_OP_TFORCALL,\n&&L_OP_TFORLOOP,\n&&L_OP_SETLIST,\n&&L_OP_CLOSURE,\n&&L_OP_VARARG,\n&&L_OP_VARARGPREP,\n&&L_OP_EXTRAARG\n\n};\n"
        },
        {
          "name": "llex.c",
          "type": "blob",
          "size": 16.7822265625,
          "content": "/*\n** $Id: llex.c $\n** Lexical Analyzer\n** See Copyright Notice in lua.h\n*/\n\n#define llex_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <locale.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lctype.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"llex.h\"\n#include \"lobject.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lzio.h\"\n\n\n\n#define next(ls)\t(ls->current = zgetc(ls->z))\n\n\n/* minimum size for string buffer */\n#if !defined(LUA_MINBUFFER)\n#define LUA_MINBUFFER   32\n#endif\n\n\n#define currIsNewline(ls)\t(ls->current == '\\n' || ls->current == '\\r')\n\n\n/* ORDER RESERVED */\nstatic const char *const luaX_tokens [] = {\n    \"and\", \"break\", \"do\", \"else\", \"elseif\",\n    \"end\", \"false\", \"for\", \"function\", \"goto\", \"if\",\n    \"in\", \"local\", \"nil\", \"not\", \"or\", \"repeat\",\n    \"return\", \"then\", \"true\", \"until\", \"while\",\n    \"//\", \"..\", \"...\", \"==\", \">=\", \"<=\", \"~=\",\n    \"<<\", \">>\", \"::\", \"<eof>\",\n    \"<number>\", \"<integer>\", \"<name>\", \"<string>\"\n};\n\n\n#define save_and_next(ls) (save(ls, ls->current), next(ls))\n\n\nstatic l_noret lexerror (LexState *ls, const char *msg, int token);\n\n\nstatic void save (LexState *ls, int c) {\n  Mbuffer *b = ls->buff;\n  if (luaZ_bufflen(b) + 1 > luaZ_sizebuffer(b)) {\n    size_t newsize;\n    if (luaZ_sizebuffer(b) >= MAX_SIZE/2)\n      lexerror(ls, \"lexical element too long\", 0);\n    newsize = luaZ_sizebuffer(b) * 2;\n    luaZ_resizebuffer(ls->L, b, newsize);\n  }\n  b->buffer[luaZ_bufflen(b)++] = cast_char(c);\n}\n\n\nvoid luaX_init (lua_State *L) {\n  int i;\n  TString *e = luaS_newliteral(L, LUA_ENV);  /* create env name */\n  luaC_fix(L, obj2gco(e));  /* never collect this name */\n  for (i=0; i<NUM_RESERVED; i++) {\n    TString *ts = luaS_new(L, luaX_tokens[i]);\n    luaC_fix(L, obj2gco(ts));  /* reserved words are never collected */\n    ts->extra = cast_byte(i+1);  /* reserved word */\n  }\n}\n\n\nconst char *luaX_token2str (LexState *ls, int token) {\n  if (token < FIRST_RESERVED) {  /* single-byte symbols? */\n    if (lisprint(token))\n      return luaO_pushfstring(ls->L, \"'%c'\", token);\n    else  /* control character */\n      return luaO_pushfstring(ls->L, \"'<\\\\%d>'\", token);\n  }\n  else {\n    const char *s = luaX_tokens[token - FIRST_RESERVED];\n    if (token < TK_EOS)  /* fixed format (symbols and reserved words)? */\n      return luaO_pushfstring(ls->L, \"'%s'\", s);\n    else  /* names, strings, and numerals */\n      return s;\n  }\n}\n\n\nstatic const char *txtToken (LexState *ls, int token) {\n  switch (token) {\n    case TK_NAME: case TK_STRING:\n    case TK_FLT: case TK_INT:\n      save(ls, '\\0');\n      return luaO_pushfstring(ls->L, \"'%s'\", luaZ_buffer(ls->buff));\n    default:\n      return luaX_token2str(ls, token);\n  }\n}\n\n\nstatic l_noret lexerror (LexState *ls, const char *msg, int token) {\n  msg = luaG_addinfo(ls->L, msg, ls->source, ls->linenumber);\n  if (token)\n    luaO_pushfstring(ls->L, \"%s near %s\", msg, txtToken(ls, token));\n  luaD_throw(ls->L, LUA_ERRSYNTAX);\n}\n\n\nl_noret luaX_syntaxerror (LexState *ls, const char *msg) {\n  lexerror(ls, msg, ls->t.token);\n}\n\n\n/*\n** Creates a new string and anchors it in scanner's table so that it\n** will not be collected until the end of the compilation; by that time\n** it should be anchored somewhere. It also internalizes long strings,\n** ensuring there is only one copy of each unique string.  The table\n** here is used as a set: the string enters as the key, while its value\n** is irrelevant. We use the string itself as the value only because it\n** is a TValue readily available. Later, the code generation can change\n** this value.\n*/\nTString *luaX_newstring (LexState *ls, const char *str, size_t l) {\n  lua_State *L = ls->L;\n  TString *ts = luaS_newlstr(L, str, l);  /* create new string */\n  TString *oldts = luaH_getstrkey(ls->h, ts);\n  if (oldts != NULL)  /* string already present? */\n    return oldts;  /* use it */\n  else {  /* create a new entry */\n    TValue *stv = s2v(L->top.p++);  /* reserve stack space for string */\n    setsvalue(L, stv, ts);  /* temporarily anchor the string */\n    luaH_set(L, ls->h, stv, stv);  /* t[string] = string */\n    /* table is not a metatable, so it does not need to invalidate cache */\n    luaC_checkGC(L);\n    L->top.p--;  /* remove string from stack */\n  }\n  return ts;\n}\n\n\n/*\n** increment line number and skips newline sequence (any of\n** \\n, \\r, \\n\\r, or \\r\\n)\n*/\nstatic void inclinenumber (LexState *ls) {\n  int old = ls->current;\n  lua_assert(currIsNewline(ls));\n  next(ls);  /* skip '\\n' or '\\r' */\n  if (currIsNewline(ls) && ls->current != old)\n    next(ls);  /* skip '\\n\\r' or '\\r\\n' */\n  if (++ls->linenumber >= INT_MAX)\n    lexerror(ls, \"chunk has too many lines\", 0);\n}\n\n\nvoid luaX_setinput (lua_State *L, LexState *ls, ZIO *z, TString *source,\n                    int firstchar) {\n  ls->t.token = 0;\n  ls->L = L;\n  ls->current = firstchar;\n  ls->lookahead.token = TK_EOS;  /* no look-ahead token */\n  ls->z = z;\n  ls->fs = NULL;\n  ls->linenumber = 1;\n  ls->lastline = 1;\n  ls->source = source;\n  ls->envn = luaS_newliteral(L, LUA_ENV);  /* get env name */\n  luaZ_resizebuffer(ls->L, ls->buff, LUA_MINBUFFER);  /* initialize buffer */\n}\n\n\n\n/*\n** =======================================================\n** LEXICAL ANALYZER\n** =======================================================\n*/\n\n\nstatic int check_next1 (LexState *ls, int c) {\n  if (ls->current == c) {\n    next(ls);\n    return 1;\n  }\n  else return 0;\n}\n\n\n/*\n** Check whether current char is in set 'set' (with two chars) and\n** saves it\n*/\nstatic int check_next2 (LexState *ls, const char *set) {\n  lua_assert(set[2] == '\\0');\n  if (ls->current == set[0] || ls->current == set[1]) {\n    save_and_next(ls);\n    return 1;\n  }\n  else return 0;\n}\n\n\n/* LUA_NUMBER */\n/*\n** This function is quite liberal in what it accepts, as 'luaO_str2num'\n** will reject ill-formed numerals. Roughly, it accepts the following\n** pattern:\n**\n**   %d(%x|%.|([Ee][+-]?))* | 0[Xx](%x|%.|([Pp][+-]?))*\n**\n** The only tricky part is to accept [+-] only after a valid exponent\n** mark, to avoid reading '3-4' or '0xe+1' as a single number.\n**\n** The caller might have already read an initial dot.\n*/\nstatic int read_numeral (LexState *ls, SemInfo *seminfo) {\n  TValue obj;\n  const char *expo = \"Ee\";\n  int first = ls->current;\n  lua_assert(lisdigit(ls->current));\n  save_and_next(ls);\n  if (first == '0' && check_next2(ls, \"xX\"))  /* hexadecimal? */\n    expo = \"Pp\";\n  for (;;) {\n    if (check_next2(ls, expo))  /* exponent mark? */\n      check_next2(ls, \"-+\");  /* optional exponent sign */\n    else if (lisxdigit(ls->current) || ls->current == '.')  /* '%x|%.' */\n      save_and_next(ls);\n    else break;\n  }\n  if (lislalpha(ls->current))  /* is numeral touching a letter? */\n    save_and_next(ls);  /* force an error */\n  save(ls, '\\0');\n  if (luaO_str2num(luaZ_buffer(ls->buff), &obj) == 0)  /* format error? */\n    lexerror(ls, \"malformed number\", TK_FLT);\n  if (ttisinteger(&obj)) {\n    seminfo->i = ivalue(&obj);\n    return TK_INT;\n  }\n  else {\n    lua_assert(ttisfloat(&obj));\n    seminfo->r = fltvalue(&obj);\n    return TK_FLT;\n  }\n}\n\n\n/*\n** read a sequence '[=*[' or ']=*]', leaving the last bracket. If\n** sequence is well formed, return its number of '='s + 2; otherwise,\n** return 1 if it is a single bracket (no '='s and no 2nd bracket);\n** otherwise (an unfinished '[==...') return 0.\n*/\nstatic size_t skip_sep (LexState *ls) {\n  size_t count = 0;\n  int s = ls->current;\n  lua_assert(s == '[' || s == ']');\n  save_and_next(ls);\n  while (ls->current == '=') {\n    save_and_next(ls);\n    count++;\n  }\n  return (ls->current == s) ? count + 2\n         : (count == 0) ? 1\n         : 0;\n}\n\n\nstatic void read_long_string (LexState *ls, SemInfo *seminfo, size_t sep) {\n  int line = ls->linenumber;  /* initial line (for error message) */\n  save_and_next(ls);  /* skip 2nd '[' */\n  if (currIsNewline(ls))  /* string starts with a newline? */\n    inclinenumber(ls);  /* skip it */\n  for (;;) {\n    switch (ls->current) {\n      case EOZ: {  /* error */\n        const char *what = (seminfo ? \"string\" : \"comment\");\n        const char *msg = luaO_pushfstring(ls->L,\n                     \"unfinished long %s (starting at line %d)\", what, line);\n        lexerror(ls, msg, TK_EOS);\n        break;  /* to avoid warnings */\n      }\n      case ']': {\n        if (skip_sep(ls) == sep) {\n          save_and_next(ls);  /* skip 2nd ']' */\n          goto endloop;\n        }\n        break;\n      }\n      case '\\n': case '\\r': {\n        save(ls, '\\n');\n        inclinenumber(ls);\n        if (!seminfo) luaZ_resetbuffer(ls->buff);  /* avoid wasting space */\n        break;\n      }\n      default: {\n        if (seminfo) save_and_next(ls);\n        else next(ls);\n      }\n    }\n  } endloop:\n  if (seminfo)\n    seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + sep,\n                                     luaZ_bufflen(ls->buff) - 2 * sep);\n}\n\n\nstatic void esccheck (LexState *ls, int c, const char *msg) {\n  if (!c) {\n    if (ls->current != EOZ)\n      save_and_next(ls);  /* add current to buffer for error message */\n    lexerror(ls, msg, TK_STRING);\n  }\n}\n\n\nstatic int gethexa (LexState *ls) {\n  save_and_next(ls);\n  esccheck (ls, lisxdigit(ls->current), \"hexadecimal digit expected\");\n  return luaO_hexavalue(ls->current);\n}\n\n\nstatic int readhexaesc (LexState *ls) {\n  int r = gethexa(ls);\n  r = (r << 4) + gethexa(ls);\n  luaZ_buffremove(ls->buff, 2);  /* remove saved chars from buffer */\n  return r;\n}\n\n\nstatic unsigned long readutf8esc (LexState *ls) {\n  unsigned long r;\n  int i = 4;  /* chars to be removed: '\\', 'u', '{', and first digit */\n  save_and_next(ls);  /* skip 'u' */\n  esccheck(ls, ls->current == '{', \"missing '{'\");\n  r = cast_ulong(gethexa(ls));  /* must have at least one digit */\n  while (cast_void(save_and_next(ls)), lisxdigit(ls->current)) {\n    i++;\n    esccheck(ls, r <= (0x7FFFFFFFu >> 4), \"UTF-8 value too large\");\n    r = (r << 4) + luaO_hexavalue(ls->current);\n  }\n  esccheck(ls, ls->current == '}', \"missing '}'\");\n  next(ls);  /* skip '}' */\n  luaZ_buffremove(ls->buff, i);  /* remove saved chars from buffer */\n  return r;\n}\n\n\nstatic void utf8esc (LexState *ls) {\n  char buff[UTF8BUFFSZ];\n  int n = luaO_utf8esc(buff, readutf8esc(ls));\n  for (; n > 0; n--)  /* add 'buff' to string */\n    save(ls, buff[UTF8BUFFSZ - n]);\n}\n\n\nstatic int readdecesc (LexState *ls) {\n  int i;\n  int r = 0;  /* result accumulator */\n  for (i = 0; i < 3 && lisdigit(ls->current); i++) {  /* read up to 3 digits */\n    r = 10*r + ls->current - '0';\n    save_and_next(ls);\n  }\n  esccheck(ls, r <= UCHAR_MAX, \"decimal escape too large\");\n  luaZ_buffremove(ls->buff, i);  /* remove read digits from buffer */\n  return r;\n}\n\n\nstatic void read_string (LexState *ls, int del, SemInfo *seminfo) {\n  save_and_next(ls);  /* keep delimiter (for error messages) */\n  while (ls->current != del) {\n    switch (ls->current) {\n      case EOZ:\n        lexerror(ls, \"unfinished string\", TK_EOS);\n        break;  /* to avoid warnings */\n      case '\\n':\n      case '\\r':\n        lexerror(ls, \"unfinished string\", TK_STRING);\n        break;  /* to avoid warnings */\n      case '\\\\': {  /* escape sequences */\n        int c;  /* final character to be saved */\n        save_and_next(ls);  /* keep '\\\\' for error messages */\n        switch (ls->current) {\n          case 'a': c = '\\a'; goto read_save;\n          case 'b': c = '\\b'; goto read_save;\n          case 'f': c = '\\f'; goto read_save;\n          case 'n': c = '\\n'; goto read_save;\n          case 'r': c = '\\r'; goto read_save;\n          case 't': c = '\\t'; goto read_save;\n          case 'v': c = '\\v'; goto read_save;\n          case 'x': c = readhexaesc(ls); goto read_save;\n          case 'u': utf8esc(ls);  goto no_save;\n          case '\\n': case '\\r':\n            inclinenumber(ls); c = '\\n'; goto only_save;\n          case '\\\\': case '\\\"': case '\\'':\n            c = ls->current; goto read_save;\n          case EOZ: goto no_save;  /* will raise an error next loop */\n          case 'z': {  /* zap following span of spaces */\n            luaZ_buffremove(ls->buff, 1);  /* remove '\\\\' */\n            next(ls);  /* skip the 'z' */\n            while (lisspace(ls->current)) {\n              if (currIsNewline(ls)) inclinenumber(ls);\n              else next(ls);\n            }\n            goto no_save;\n          }\n          default: {\n            esccheck(ls, lisdigit(ls->current), \"invalid escape sequence\");\n            c = readdecesc(ls);  /* digital escape '\\ddd' */\n            goto only_save;\n          }\n        }\n       read_save:\n         next(ls);\n         /* go through */\n       only_save:\n         luaZ_buffremove(ls->buff, 1);  /* remove '\\\\' */\n         save(ls, c);\n         /* go through */\n       no_save: break;\n      }\n      default:\n        save_and_next(ls);\n    }\n  }\n  save_and_next(ls);  /* skip delimiter */\n  seminfo->ts = luaX_newstring(ls, luaZ_buffer(ls->buff) + 1,\n                                   luaZ_bufflen(ls->buff) - 2);\n}\n\n\nstatic int llex (LexState *ls, SemInfo *seminfo) {\n  luaZ_resetbuffer(ls->buff);\n  for (;;) {\n    switch (ls->current) {\n      case '\\n': case '\\r': {  /* line breaks */\n        inclinenumber(ls);\n        break;\n      }\n      case ' ': case '\\f': case '\\t': case '\\v': {  /* spaces */\n        next(ls);\n        break;\n      }\n      case '-': {  /* '-' or '--' (comment) */\n        next(ls);\n        if (ls->current != '-') return '-';\n        /* else is a comment */\n        next(ls);\n        if (ls->current == '[') {  /* long comment? */\n          size_t sep = skip_sep(ls);\n          luaZ_resetbuffer(ls->buff);  /* 'skip_sep' may dirty the buffer */\n          if (sep >= 2) {\n            read_long_string(ls, NULL, sep);  /* skip long comment */\n            luaZ_resetbuffer(ls->buff);  /* previous call may dirty the buff. */\n            break;\n          }\n        }\n        /* else short comment */\n        while (!currIsNewline(ls) && ls->current != EOZ)\n          next(ls);  /* skip until end of line (or end of file) */\n        break;\n      }\n      case '[': {  /* long string or simply '[' */\n        size_t sep = skip_sep(ls);\n        if (sep >= 2) {\n          read_long_string(ls, seminfo, sep);\n          return TK_STRING;\n        }\n        else if (sep == 0)  /* '[=...' missing second bracket? */\n          lexerror(ls, \"invalid long string delimiter\", TK_STRING);\n        return '[';\n      }\n      case '=': {\n        next(ls);\n        if (check_next1(ls, '=')) return TK_EQ;  /* '==' */\n        else return '=';\n      }\n      case '<': {\n        next(ls);\n        if (check_next1(ls, '=')) return TK_LE;  /* '<=' */\n        else if (check_next1(ls, '<')) return TK_SHL;  /* '<<' */\n        else return '<';\n      }\n      case '>': {\n        next(ls);\n        if (check_next1(ls, '=')) return TK_GE;  /* '>=' */\n        else if (check_next1(ls, '>')) return TK_SHR;  /* '>>' */\n        else return '>';\n      }\n      case '/': {\n        next(ls);\n        if (check_next1(ls, '/')) return TK_IDIV;  /* '//' */\n        else return '/';\n      }\n      case '~': {\n        next(ls);\n        if (check_next1(ls, '=')) return TK_NE;  /* '~=' */\n        else return '~';\n      }\n      case ':': {\n        next(ls);\n        if (check_next1(ls, ':')) return TK_DBCOLON;  /* '::' */\n        else return ':';\n      }\n      case '\"': case '\\'': {  /* short literal strings */\n        read_string(ls, ls->current, seminfo);\n        return TK_STRING;\n      }\n      case '.': {  /* '.', '..', '...', or number */\n        save_and_next(ls);\n        if (check_next1(ls, '.')) {\n          if (check_next1(ls, '.'))\n            return TK_DOTS;   /* '...' */\n          else return TK_CONCAT;   /* '..' */\n        }\n        else if (!lisdigit(ls->current)) return '.';\n        else return read_numeral(ls, seminfo);\n      }\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9': {\n        return read_numeral(ls, seminfo);\n      }\n      case EOZ: {\n        return TK_EOS;\n      }\n      default: {\n        if (lislalpha(ls->current)) {  /* identifier or reserved word? */\n          TString *ts;\n          do {\n            save_and_next(ls);\n          } while (lislalnum(ls->current));\n          ts = luaX_newstring(ls, luaZ_buffer(ls->buff),\n                                  luaZ_bufflen(ls->buff));\n          seminfo->ts = ts;\n          if (isreserved(ts))  /* reserved word? */\n            return ts->extra - 1 + FIRST_RESERVED;\n          else {\n            return TK_NAME;\n          }\n        }\n        else {  /* single-char tokens ('+', '*', '%', '{', '}', ...) */\n          int c = ls->current;\n          next(ls);\n          return c;\n        }\n      }\n    }\n  }\n}\n\n\nvoid luaX_next (LexState *ls) {\n  ls->lastline = ls->linenumber;\n  if (ls->lookahead.token != TK_EOS) {  /* is there a look-ahead token? */\n    ls->t = ls->lookahead;  /* use this one */\n    ls->lookahead.token = TK_EOS;  /* and discharge it */\n  }\n  else\n    ls->t.token = llex(ls, &ls->t.seminfo);  /* read next token */\n}\n\n\nint luaX_lookahead (LexState *ls) {\n  lua_assert(ls->lookahead.token == TK_EOS);\n  ls->lookahead.token = llex(ls, &ls->lookahead.seminfo);\n  return ls->lookahead.token;\n}\n\n"
        },
        {
          "name": "llex.h",
          "type": "blob",
          "size": 2.345703125,
          "content": "/*\n** $Id: llex.h $\n** Lexical Analyzer\n** See Copyright Notice in lua.h\n*/\n\n#ifndef llex_h\n#define llex_h\n\n#include <limits.h>\n\n#include \"lobject.h\"\n#include \"lzio.h\"\n\n\n/*\n** Single-char tokens (terminal symbols) are represented by their own\n** numeric code. Other tokens start at the following value.\n*/\n#define FIRST_RESERVED\t(UCHAR_MAX + 1)\n\n\n#if !defined(LUA_ENV)\n#define LUA_ENV\t\t\"_ENV\"\n#endif\n\n\n/*\n* WARNING: if you change the order of this enumeration,\n* grep \"ORDER RESERVED\"\n*/\nenum RESERVED {\n  /* terminal symbols denoted by reserved words */\n  TK_AND = FIRST_RESERVED, TK_BREAK,\n  TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,\n  TK_GOTO, TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,\n  TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,\n  /* other terminal symbols */\n  TK_IDIV, TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE,\n  TK_SHL, TK_SHR,\n  TK_DBCOLON, TK_EOS,\n  TK_FLT, TK_INT, TK_NAME, TK_STRING\n};\n\n/* number of reserved words */\n#define NUM_RESERVED\t(cast_int(TK_WHILE-FIRST_RESERVED + 1))\n\n\ntypedef union {\n  lua_Number r;\n  lua_Integer i;\n  TString *ts;\n} SemInfo;  /* semantics information */\n\n\ntypedef struct Token {\n  int token;\n  SemInfo seminfo;\n} Token;\n\n\n/* state of the lexer plus state of the parser when shared by all\n   functions */\ntypedef struct LexState {\n  int current;  /* current character (charint) */\n  int linenumber;  /* input line counter */\n  int lastline;  /* line of last token 'consumed' */\n  Token t;  /* current token */\n  Token lookahead;  /* look ahead token */\n  struct FuncState *fs;  /* current function (parser) */\n  struct lua_State *L;\n  ZIO *z;  /* input stream */\n  Mbuffer *buff;  /* buffer for tokens */\n  Table *h;  /* to avoid collection/reuse strings */\n  struct Dyndata *dyd;  /* dynamic structures used by the parser */\n  TString *source;  /* current source name */\n  TString *envn;  /* environment variable name */\n} LexState;\n\n\nLUAI_FUNC void luaX_init (lua_State *L);\nLUAI_FUNC void luaX_setinput (lua_State *L, LexState *ls, ZIO *z,\n                              TString *source, int firstchar);\nLUAI_FUNC TString *luaX_newstring (LexState *ls, const char *str, size_t l);\nLUAI_FUNC void luaX_next (LexState *ls);\nLUAI_FUNC int luaX_lookahead (LexState *ls);\nLUAI_FUNC l_noret luaX_syntaxerror (LexState *ls, const char *s);\nLUAI_FUNC const char *luaX_token2str (LexState *ls, int token);\n\n\n#endif\n"
        },
        {
          "name": "llimits.h",
          "type": "blob",
          "size": 7.716796875,
          "content": "/*\n** $Id: llimits.h $\n** Limits, basic types, and some other 'installation-dependent' definitions\n** See Copyright Notice in lua.h\n*/\n\n#ifndef llimits_h\n#define llimits_h\n\n\n#include <limits.h>\n#include <stddef.h>\n\n\n#include \"lua.h\"\n\n\n/*\n** 'l_mem' is a signed integer big enough to count the total memory\n** used by Lua.  (It is signed due to the use of debt in several\n** computations.)  Usually, 'ptrdiff_t' should work, but we use 'long'\n** for 16-bit machines.\n*/\n#if defined(LUAI_MEM)\t\t/* { external definitions? */\ntypedef LUAI_MEM l_mem;\ntypedef LUAI_UMEM lu_mem;\n#elif LUAI_IS32INT\t/* }{ */\ntypedef ptrdiff_t l_mem;\ntypedef size_t lu_mem;\n#else  /* 16-bit ints */\t/* }{ */\ntypedef long l_mem;\ntypedef unsigned long lu_mem;\n#endif\t\t\t\t/* } */\n\n#define MAX_LMEM  \\\n\tcast(l_mem, (cast(lu_mem, 1) << (sizeof(l_mem) * 8 - 1)) - 1)\n\n\n/* chars used as small naturals (so that 'char' is reserved for characters) */\ntypedef unsigned char lu_byte;\ntypedef signed char ls_byte;\n\n\n/* maximum value for size_t */\n#define MAX_SIZET\t((size_t)(~(size_t)0))\n\n/*\n** Maximum size for strings and userdata visible for Lua; should be\n** representable as a lua_Integer and as a size_t.\n*/\n#define MAX_SIZE\t(sizeof(size_t) < sizeof(lua_Integer) ? MAX_SIZET \\\n\t\t\t  : cast_sizet(LUA_MAXINTEGER))\n\n/*\n** floor of the log2 of the maximum signed value for integral type 't'.\n** (That is, maximum 'n' such that '2^n' fits in the given signed type.)\n*/\n#define log2maxs(t)\tcast_int(sizeof(t) * 8 - 2)\n\n\n/*\n** test whether an unsigned value is a power of 2 (or zero)\n*/\n#define ispow2(x)\t(((x) & ((x) - 1)) == 0)\n\n\n/* number of chars of a literal string without the ending \\0 */\n#define LL(x)   (sizeof(x)/sizeof(char) - 1)\n\n\n/*\n** conversion of pointer to unsigned integer: this is for hashing only;\n** there is no problem if the integer cannot hold the whole pointer\n** value. (In strict ISO C this may cause undefined behavior, but no\n** actual machine seems to bother.)\n*/\n#if !defined(LUA_USE_C89) && defined(__STDC_VERSION__) && \\\n    __STDC_VERSION__ >= 199901L\n#include <stdint.h>\n#if defined(UINTPTR_MAX)  /* even in C99 this type is optional */\n#define L_P2I\tuintptr_t\n#else  /* no 'intptr'? */\n#define L_P2I\tuintmax_t  /* use the largest available integer */\n#endif\n#else  /* C89 option */\n#define L_P2I\tsize_t\n#endif\n\n#define point2uint(p)\tcast_uint((L_P2I)(p) & UINT_MAX)\n\n\n\n/* types of 'usual argument conversions' for lua_Number and lua_Integer */\ntypedef LUAI_UACNUMBER l_uacNumber;\ntypedef LUAI_UACINT l_uacInt;\n\n\n/*\n** Internal assertions for in-house debugging\n*/\n#if defined LUAI_ASSERT\n#undef NDEBUG\n#include <assert.h>\n#define lua_assert(c)           assert(c)\n#define assert_code(c)\t\tc\n#endif\n\n#if defined(lua_assert)\n#else\n#define lua_assert(c)\t\t((void)0)\n#define assert_code(c)\t\t((void)0)\n#endif\n\n#define check_exp(c,e)\t\t(lua_assert(c), (e))\n/* to avoid problems with conditions too long */\n#define lua_longassert(c)\tassert_code((c) ? (void)0 : lua_assert(0))\n\n\n/* macro to avoid warnings about unused variables */\n#if !defined(UNUSED)\n#define UNUSED(x)\t((void)(x))\n#endif\n\n\n/* type casts (a macro highlights casts in the code) */\n#define cast(t, exp)\t((t)(exp))\n\n#define cast_void(i)\tcast(void, (i))\n#define cast_voidp(i)\tcast(void *, (i))\n#define cast_num(i)\tcast(lua_Number, (i))\n#define cast_int(i)\tcast(int, (i))\n#define cast_uint(i)\tcast(unsigned int, (i))\n#define cast_ulong(i)\tcast(unsigned long, (i))\n#define cast_byte(i)\tcast(lu_byte, (i))\n#define cast_uchar(i)\tcast(unsigned char, (i))\n#define cast_char(i)\tcast(char, (i))\n#define cast_charp(i)\tcast(char *, (i))\n#define cast_sizet(i)\tcast(size_t, (i))\n\n\n/* cast a signed lua_Integer to lua_Unsigned */\n#if !defined(l_castS2U)\n#define l_castS2U(i)\t((lua_Unsigned)(i))\n#endif\n\n/*\n** cast a lua_Unsigned to a signed lua_Integer; this cast is\n** not strict ISO C, but two-complement architectures should\n** work fine.\n*/\n#if !defined(l_castU2S)\n#define l_castU2S(i)\t((lua_Integer)(i))\n#endif\n\n/*\n** cast a size_t to lua_Integer: These casts are always valid for\n** sizes of Lua objects (see MAX_SIZE)\n*/\n#define cast_st2S(sz)\t((lua_Integer)(sz))\n\n/* Cast a ptrdiff_t to size_t, when it is known that the minuend\n** comes from the subtraend (the base)\n*/\n#define ct_diff2sz(df)\t((size_t)(df))\n\n/* ptrdiff_t to lua_Integer */\n#define ct_diff2S(df)\tcast_st2S(ct_diff2sz(df))\n\n/*\n** Special type equivalent to '(void*)' for functions (to suppress some\n** warnings when converting function pointers)\n*/\ntypedef void (*voidf)(void);\n\n/*\n** Macro to convert pointer-to-void* to pointer-to-function. This cast\n** is undefined according to ISO C, but POSIX assumes that it works.\n** (The '__extension__' in gnu compilers is only to avoid warnings.)\n*/\n#if defined(__GNUC__)\n#define cast_func(p) (__extension__ (voidf)(p))\n#else\n#define cast_func(p) ((voidf)(p))\n#endif\n\n\n\n/*\n** non-return type\n*/\n#if !defined(l_noret)\n\n#if defined(__GNUC__)\n#define l_noret\t\tvoid __attribute__((noreturn))\n#elif defined(_MSC_VER) && _MSC_VER >= 1200\n#define l_noret\t\tvoid __declspec(noreturn)\n#else\n#define l_noret\t\tvoid\n#endif\n\n#endif\n\n\n/*\n** Inline functions\n*/\n#if !defined(LUA_USE_C89)\n#define l_inline\tinline\n#elif defined(__GNUC__)\n#define l_inline\t__inline__\n#else\n#define l_inline\t/* empty */\n#endif\n\n#define l_sinline\tstatic l_inline\n\n\n/*\n** An unsigned with (at least) 4 bytes\n*/\n#if LUAI_IS32INT\ntypedef unsigned int l_uint32;\n#else\ntypedef unsigned long l_uint32;\n#endif\n\n\n/*\n** The luai_num* macros define the primitive operations over numbers.\n*/\n\n/* floor division (defined as 'floor(a/b)') */\n#if !defined(luai_numidiv)\n#define luai_numidiv(L,a,b)     ((void)L, l_floor(luai_numdiv(L,a,b)))\n#endif\n\n/* float division */\n#if !defined(luai_numdiv)\n#define luai_numdiv(L,a,b)      ((a)/(b))\n#endif\n\n/*\n** modulo: defined as 'a - floor(a/b)*b'; the direct computation\n** using this definition has several problems with rounding errors,\n** so it is better to use 'fmod'. 'fmod' gives the result of\n** 'a - trunc(a/b)*b', and therefore must be corrected when\n** 'trunc(a/b) ~= floor(a/b)'. That happens when the division has a\n** non-integer negative result: non-integer result is equivalent to\n** a non-zero remainder 'm'; negative result is equivalent to 'a' and\n** 'b' with different signs, or 'm' and 'b' with different signs\n** (as the result 'm' of 'fmod' has the same sign of 'a').\n*/\n#if !defined(luai_nummod)\n#define luai_nummod(L,a,b,m)  \\\n  { (void)L; (m) = l_mathop(fmod)(a,b); \\\n    if (((m) > 0) ? (b) < 0 : ((m) < 0 && (b) > 0)) (m) += (b); }\n#endif\n\n/* exponentiation */\n#if !defined(luai_numpow)\n#define luai_numpow(L,a,b)  \\\n  ((void)L, (b == 2) ? (a)*(a) : l_mathop(pow)(a,b))\n#endif\n\n/* the others are quite standard operations */\n#if !defined(luai_numadd)\n#define luai_numadd(L,a,b)      ((a)+(b))\n#define luai_numsub(L,a,b)      ((a)-(b))\n#define luai_nummul(L,a,b)      ((a)*(b))\n#define luai_numunm(L,a)        (-(a))\n#define luai_numeq(a,b)         ((a)==(b))\n#define luai_numlt(a,b)         ((a)<(b))\n#define luai_numle(a,b)         ((a)<=(b))\n#define luai_numgt(a,b)         ((a)>(b))\n#define luai_numge(a,b)         ((a)>=(b))\n#define luai_numisnan(a)        (!luai_numeq((a), (a)))\n#endif\n\n\n/*\n** {==================================================================\n** \"Abstraction Layer\" for basic report of messages and errors\n** ===================================================================\n*/\n\n/* print a string */\n#if !defined(lua_writestring)\n#define lua_writestring(s,l)   fwrite((s), sizeof(char), (l), stdout)\n#endif\n\n/* print a newline and flush the output */\n#if !defined(lua_writeline)\n#define lua_writeline()        (lua_writestring(\"\\n\", 1), fflush(stdout))\n#endif\n\n/* print an error message */\n#if !defined(lua_writestringerror)\n#define lua_writestringerror(s,p) \\\n        (fprintf(stderr, (s), (p)), fflush(stderr))\n#endif\n\n/* }================================================================== */\n\n#endif\n\n"
        },
        {
          "name": "lmathlib.c",
          "type": "blob",
          "size": 18.8564453125,
          "content": "/*\n** $Id: lmathlib.c $\n** Standard mathematical library\n** See Copyright Notice in lua.h\n*/\n\n#define lmathlib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdlib.h>\n#include <time.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n#include \"llimits.h\"\n\n\n#undef PI\n#define PI\t(l_mathop(3.141592653589793238462643383279502884))\n\n\nstatic int math_abs (lua_State *L) {\n  if (lua_isinteger(L, 1)) {\n    lua_Integer n = lua_tointeger(L, 1);\n    if (n < 0) n = (lua_Integer)(0u - (lua_Unsigned)n);\n    lua_pushinteger(L, n);\n  }\n  else\n    lua_pushnumber(L, l_mathop(fabs)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_sin (lua_State *L) {\n  lua_pushnumber(L, l_mathop(sin)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_cos (lua_State *L) {\n  lua_pushnumber(L, l_mathop(cos)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_tan (lua_State *L) {\n  lua_pushnumber(L, l_mathop(tan)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_asin (lua_State *L) {\n  lua_pushnumber(L, l_mathop(asin)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_acos (lua_State *L) {\n  lua_pushnumber(L, l_mathop(acos)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_atan (lua_State *L) {\n  lua_Number y = luaL_checknumber(L, 1);\n  lua_Number x = luaL_optnumber(L, 2, 1);\n  lua_pushnumber(L, l_mathop(atan2)(y, x));\n  return 1;\n}\n\n\nstatic int math_toint (lua_State *L) {\n  int valid;\n  lua_Integer n = lua_tointegerx(L, 1, &valid);\n  if (l_likely(valid))\n    lua_pushinteger(L, n);\n  else {\n    luaL_checkany(L, 1);\n    luaL_pushfail(L);  /* value is not convertible to integer */\n  }\n  return 1;\n}\n\n\nstatic void pushnumint (lua_State *L, lua_Number d) {\n  lua_Integer n;\n  if (lua_numbertointeger(d, &n))  /* does 'd' fit in an integer? */\n    lua_pushinteger(L, n);  /* result is integer */\n  else\n    lua_pushnumber(L, d);  /* result is float */\n}\n\n\nstatic int math_floor (lua_State *L) {\n  if (lua_isinteger(L, 1))\n    lua_settop(L, 1);  /* integer is its own floor */\n  else {\n    lua_Number d = l_mathop(floor)(luaL_checknumber(L, 1));\n    pushnumint(L, d);\n  }\n  return 1;\n}\n\n\nstatic int math_ceil (lua_State *L) {\n  if (lua_isinteger(L, 1))\n    lua_settop(L, 1);  /* integer is its own ceil */\n  else {\n    lua_Number d = l_mathop(ceil)(luaL_checknumber(L, 1));\n    pushnumint(L, d);\n  }\n  return 1;\n}\n\n\nstatic int math_fmod (lua_State *L) {\n  if (lua_isinteger(L, 1) && lua_isinteger(L, 2)) {\n    lua_Integer d = lua_tointeger(L, 2);\n    if ((lua_Unsigned)d + 1u <= 1u) {  /* special cases: -1 or 0 */\n      luaL_argcheck(L, d != 0, 2, \"zero\");\n      lua_pushinteger(L, 0);  /* avoid overflow with 0x80000... / -1 */\n    }\n    else\n      lua_pushinteger(L, lua_tointeger(L, 1) % d);\n  }\n  else\n    lua_pushnumber(L, l_mathop(fmod)(luaL_checknumber(L, 1),\n                                     luaL_checknumber(L, 2)));\n  return 1;\n}\n\n\n/*\n** next function does not use 'modf', avoiding problems with 'double*'\n** (which is not compatible with 'float*') when lua_Number is not\n** 'double'.\n*/\nstatic int math_modf (lua_State *L) {\n  if (lua_isinteger(L ,1)) {\n    lua_settop(L, 1);  /* number is its own integer part */\n    lua_pushnumber(L, 0);  /* no fractional part */\n  }\n  else {\n    lua_Number n = luaL_checknumber(L, 1);\n    /* integer part (rounds toward zero) */\n    lua_Number ip = (n < 0) ? l_mathop(ceil)(n) : l_mathop(floor)(n);\n    pushnumint(L, ip);\n    /* fractional part (test needed for inf/-inf) */\n    lua_pushnumber(L, (n == ip) ? l_mathop(0.0) : (n - ip));\n  }\n  return 2;\n}\n\n\nstatic int math_sqrt (lua_State *L) {\n  lua_pushnumber(L, l_mathop(sqrt)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\n\nstatic int math_ult (lua_State *L) {\n  lua_Integer a = luaL_checkinteger(L, 1);\n  lua_Integer b = luaL_checkinteger(L, 2);\n  lua_pushboolean(L, (lua_Unsigned)a < (lua_Unsigned)b);\n  return 1;\n}\n\nstatic int math_log (lua_State *L) {\n  lua_Number x = luaL_checknumber(L, 1);\n  lua_Number res;\n  if (lua_isnoneornil(L, 2))\n    res = l_mathop(log)(x);\n  else {\n    lua_Number base = luaL_checknumber(L, 2);\n#if !defined(LUA_USE_C89)\n    if (base == l_mathop(2.0))\n      res = l_mathop(log2)(x);\n    else\n#endif\n    if (base == l_mathop(10.0))\n      res = l_mathop(log10)(x);\n    else\n      res = l_mathop(log)(x)/l_mathop(log)(base);\n  }\n  lua_pushnumber(L, res);\n  return 1;\n}\n\nstatic int math_exp (lua_State *L) {\n  lua_pushnumber(L, l_mathop(exp)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_deg (lua_State *L) {\n  lua_pushnumber(L, luaL_checknumber(L, 1) * (l_mathop(180.0) / PI));\n  return 1;\n}\n\nstatic int math_rad (lua_State *L) {\n  lua_pushnumber(L, luaL_checknumber(L, 1) * (PI / l_mathop(180.0)));\n  return 1;\n}\n\n\nstatic int math_min (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  int imin = 1;  /* index of current minimum value */\n  int i;\n  luaL_argcheck(L, n >= 1, 1, \"value expected\");\n  for (i = 2; i <= n; i++) {\n    if (lua_compare(L, i, imin, LUA_OPLT))\n      imin = i;\n  }\n  lua_pushvalue(L, imin);\n  return 1;\n}\n\n\nstatic int math_max (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  int imax = 1;  /* index of current maximum value */\n  int i;\n  luaL_argcheck(L, n >= 1, 1, \"value expected\");\n  for (i = 2; i <= n; i++) {\n    if (lua_compare(L, imax, i, LUA_OPLT))\n      imax = i;\n  }\n  lua_pushvalue(L, imax);\n  return 1;\n}\n\n\nstatic int math_type (lua_State *L) {\n  if (lua_type(L, 1) == LUA_TNUMBER)\n    lua_pushstring(L, (lua_isinteger(L, 1)) ? \"integer\" : \"float\");\n  else {\n    luaL_checkany(L, 1);\n    luaL_pushfail(L);\n  }\n  return 1;\n}\n\n\n\n/*\n** {==================================================================\n** Pseudo-Random Number Generator based on 'xoshiro256**'.\n** ===================================================================\n*/\n\n/*\n** This code uses lots of shifts. ANSI C does not allow shifts greater\n** than or equal to the width of the type being shifted, so some shifts\n** are written in convoluted ways to match that restriction. For\n** preprocessor tests, it assumes a width of 32 bits, so the maximum\n** shift there is 31 bits.\n*/\n\n\n/* number of binary digits in the mantissa of a float */\n#define FIGS\tl_floatatt(MANT_DIG)\n\n#if FIGS > 64\n/* there are only 64 random bits; use them all */\n#undef FIGS\n#define FIGS\t64\n#endif\n\n\n/*\n** LUA_RAND32 forces the use of 32-bit integers in the implementation\n** of the PRN generator (mainly for testing).\n*/\n#if !defined(LUA_RAND32) && !defined(Rand64)\n\n/* try to find an integer type with at least 64 bits */\n\n#if ((ULONG_MAX >> 31) >> 31) >= 3\n\n/* 'long' has at least 64 bits */\n#define Rand64\t\tunsigned long\n#define SRand64\t\tlong\n\n#elif !defined(LUA_USE_C89) && defined(LLONG_MAX)\n\n/* there is a 'long long' type (which must have at least 64 bits) */\n#define Rand64\t\tunsigned long long\n#define SRand64\t\tlong long\n\n#elif ((LUA_MAXUNSIGNED >> 31) >> 31) >= 3\n\n/* 'lua_Unsigned' has at least 64 bits */\n#define Rand64\t\tlua_Unsigned\n#define SRand64\t\tlua_Integer\n\n#endif\n\n#endif\n\n\n#if defined(Rand64)  /* { */\n\n/*\n** Standard implementation, using 64-bit integers.\n** If 'Rand64' has more than 64 bits, the extra bits do not interfere\n** with the 64 initial bits, except in a right shift. Moreover, the\n** final result has to discard the extra bits.\n*/\n\n/* avoid using extra bits when needed */\n#define trim64(x)\t((x) & 0xffffffffffffffffu)\n\n\n/* rotate left 'x' by 'n' bits */\nstatic Rand64 rotl (Rand64 x, int n) {\n  return (x << n) | (trim64(x) >> (64 - n));\n}\n\nstatic Rand64 nextrand (Rand64 *state) {\n  Rand64 state0 = state[0];\n  Rand64 state1 = state[1];\n  Rand64 state2 = state[2] ^ state0;\n  Rand64 state3 = state[3] ^ state1;\n  Rand64 res = rotl(state1 * 5, 7) * 9;\n  state[0] = state0 ^ state3;\n  state[1] = state1 ^ state2;\n  state[2] = state2 ^ (state1 << 17);\n  state[3] = rotl(state3, 45);\n  return res;\n}\n\n\n/*\n** Convert bits from a random integer into a float in the\n** interval [0,1), getting the higher FIG bits from the\n** random unsigned integer and converting that to a float.\n** Some old Microsoft compilers cannot cast an unsigned long\n** to a floating-point number, so we use a signed long as an\n** intermediary. When lua_Number is float or double, the shift ensures\n** that 'sx' is non negative; in that case, a good compiler will remove\n** the correction.\n*/\n\n/* must throw out the extra (64 - FIGS) bits */\n#define shift64_FIG\t(64 - FIGS)\n\n/* 2^(-FIGS) == 2^-1 / 2^(FIGS-1) */\n#define scaleFIG\t(l_mathop(0.5) / ((Rand64)1 << (FIGS - 1)))\n\nstatic lua_Number I2d (Rand64 x) {\n  SRand64 sx = (SRand64)(trim64(x) >> shift64_FIG);\n  lua_Number res = (lua_Number)(sx) * scaleFIG;\n  if (sx < 0)\n    res += l_mathop(1.0);  /* correct the two's complement if negative */\n  lua_assert(0 <= res && res < 1);\n  return res;\n}\n\n/* convert a 'Rand64' to a 'lua_Unsigned' */\n#define I2UInt(x)\t((lua_Unsigned)trim64(x))\n\n/* convert a 'lua_Unsigned' to a 'Rand64' */\n#define Int2I(x)\t((Rand64)(x))\n\n\n#else\t/* no 'Rand64'   }{ */\n\n/*\n** Use two 32-bit integers to represent a 64-bit quantity.\n*/\ntypedef struct Rand64 {\n  l_uint32 h;  /* higher half */\n  l_uint32 l;  /* lower half */\n} Rand64;\n\n\n/*\n** If 'l_uint32' has more than 32 bits, the extra bits do not interfere\n** with the 32 initial bits, except in a right shift and comparisons.\n** Moreover, the final result has to discard the extra bits.\n*/\n\n/* avoid using extra bits when needed */\n#define trim32(x)\t((x) & 0xffffffffu)\n\n\n/*\n** basic operations on 'Rand64' values\n*/\n\n/* build a new Rand64 value */\nstatic Rand64 packI (l_uint32 h, l_uint32 l) {\n  Rand64 result;\n  result.h = h;\n  result.l = l;\n  return result;\n}\n\n/* return i << n */\nstatic Rand64 Ishl (Rand64 i, int n) {\n  lua_assert(n > 0 && n < 32);\n  return packI((i.h << n) | (trim32(i.l) >> (32 - n)), i.l << n);\n}\n\n/* i1 ^= i2 */\nstatic void Ixor (Rand64 *i1, Rand64 i2) {\n  i1->h ^= i2.h;\n  i1->l ^= i2.l;\n}\n\n/* return i1 + i2 */\nstatic Rand64 Iadd (Rand64 i1, Rand64 i2) {\n  Rand64 result = packI(i1.h + i2.h, i1.l + i2.l);\n  if (trim32(result.l) < trim32(i1.l))  /* carry? */\n    result.h++;\n  return result;\n}\n\n/* return i * 5 */\nstatic Rand64 times5 (Rand64 i) {\n  return Iadd(Ishl(i, 2), i);  /* i * 5 == (i << 2) + i */\n}\n\n/* return i * 9 */\nstatic Rand64 times9 (Rand64 i) {\n  return Iadd(Ishl(i, 3), i);  /* i * 9 == (i << 3) + i */\n}\n\n/* return 'i' rotated left 'n' bits */\nstatic Rand64 rotl (Rand64 i, int n) {\n  lua_assert(n > 0 && n < 32);\n  return packI((i.h << n) | (trim32(i.l) >> (32 - n)),\n               (trim32(i.h) >> (32 - n)) | (i.l << n));\n}\n\n/* for offsets larger than 32, rotate right by 64 - offset */\nstatic Rand64 rotl1 (Rand64 i, int n) {\n  lua_assert(n > 32 && n < 64);\n  n = 64 - n;\n  return packI((trim32(i.h) >> n) | (i.l << (32 - n)),\n               (i.h << (32 - n)) | (trim32(i.l) >> n));\n}\n\n/*\n** implementation of 'xoshiro256**' algorithm on 'Rand64' values\n*/\nstatic Rand64 nextrand (Rand64 *state) {\n  Rand64 res = times9(rotl(times5(state[1]), 7));\n  Rand64 t = Ishl(state[1], 17);\n  Ixor(&state[2], state[0]);\n  Ixor(&state[3], state[1]);\n  Ixor(&state[1], state[2]);\n  Ixor(&state[0], state[3]);\n  Ixor(&state[2], t);\n  state[3] = rotl1(state[3], 45);\n  return res;\n}\n\n\n/*\n** Converts a 'Rand64' into a float.\n*/\n\n/* an unsigned 1 with proper type */\n#define UONE\t\t((l_uint32)1)\n\n\n#if FIGS <= 32\n\n/* 2^(-FIGS) */\n#define scaleFIG       (l_mathop(0.5) / (UONE << (FIGS - 1)))\n\n/*\n** get up to 32 bits from higher half, shifting right to\n** throw out the extra bits.\n*/\nstatic lua_Number I2d (Rand64 x) {\n  lua_Number h = (lua_Number)(trim32(x.h) >> (32 - FIGS));\n  return h * scaleFIG;\n}\n\n#else\t/* 32 < FIGS <= 64 */\n\n/* 2^(-FIGS) = 1.0 / 2^30 / 2^3 / 2^(FIGS-33) */\n#define scaleFIG  \\\n    (l_mathop(1.0) / (UONE << 30) / l_mathop(8.0) / (UONE << (FIGS - 33)))\n\n/*\n** use FIGS - 32 bits from lower half, throwing out the other\n** (32 - (FIGS - 32)) = (64 - FIGS) bits\n*/\n#define shiftLOW\t(64 - FIGS)\n\n/*\n** higher 32 bits go after those (FIGS - 32) bits: shiftHI = 2^(FIGS - 32)\n*/\n#define shiftHI\t\t((lua_Number)(UONE << (FIGS - 33)) * l_mathop(2.0))\n\n\nstatic lua_Number I2d (Rand64 x) {\n  lua_Number h = (lua_Number)trim32(x.h) * shiftHI;\n  lua_Number l = (lua_Number)(trim32(x.l) >> shiftLOW);\n  return (h + l) * scaleFIG;\n}\n\n#endif\n\n\n/* convert a 'Rand64' to a 'lua_Unsigned' */\nstatic lua_Unsigned I2UInt (Rand64 x) {\n  return (((lua_Unsigned)trim32(x.h) << 31) << 1) | (lua_Unsigned)trim32(x.l);\n}\n\n/* convert a 'lua_Unsigned' to a 'Rand64' */\nstatic Rand64 Int2I (lua_Unsigned n) {\n  return packI((l_uint32)((n >> 31) >> 1), (l_uint32)n);\n}\n\n#endif  /* } */\n\n\n/*\n** A state uses four 'Rand64' values.\n*/\ntypedef struct {\n  Rand64 s[4];\n} RanState;\n\n\n/*\n** Project the random integer 'ran' into the interval [0, n].\n** Because 'ran' has 2^B possible values, the projection can only be\n** uniform when the size of the interval is a power of 2 (exact\n** division). Otherwise, to get a uniform projection into [0, n], we\n** first compute 'lim', the smallest Mersenne number not smaller than\n** 'n'. We then project 'ran' into the interval [0, lim].  If the result\n** is inside [0, n], we are done. Otherwise, we try with another 'ran',\n** until we have a result inside the interval.\n*/\nstatic lua_Unsigned project (lua_Unsigned ran, lua_Unsigned n,\n                             RanState *state) {\n  if ((n & (n + 1)) == 0)  /* is 'n + 1' a power of 2? */\n    return ran & n;  /* no bias */\n  else {\n    lua_Unsigned lim = n;\n    /* compute the smallest (2^b - 1) not smaller than 'n' */\n    lim |= (lim >> 1);\n    lim |= (lim >> 2);\n    lim |= (lim >> 4);\n    lim |= (lim >> 8);\n    lim |= (lim >> 16);\n#if (LUA_MAXUNSIGNED >> 31) >= 3\n    lim |= (lim >> 32);  /* integer type has more than 32 bits */\n#endif\n    lua_assert((lim & (lim + 1)) == 0  /* 'lim + 1' is a power of 2, */\n      && lim >= n  /* not smaller than 'n', */\n      && (lim >> 1) < n);  /* and it is the smallest one */\n    while ((ran &= lim) > n)  /* project 'ran' into [0..lim] */\n      ran = I2UInt(nextrand(state->s));  /* not inside [0..n]? try again */\n    return ran;\n  }\n}\n\n\nstatic int math_random (lua_State *L) {\n  lua_Integer low, up;\n  lua_Unsigned p;\n  RanState *state = (RanState *)lua_touserdata(L, lua_upvalueindex(1));\n  Rand64 rv = nextrand(state->s);  /* next pseudo-random value */\n  switch (lua_gettop(L)) {  /* check number of arguments */\n    case 0: {  /* no arguments */\n      lua_pushnumber(L, I2d(rv));  /* float between 0 and 1 */\n      return 1;\n    }\n    case 1: {  /* only upper limit */\n      low = 1;\n      up = luaL_checkinteger(L, 1);\n      if (up == 0) {  /* single 0 as argument? */\n        lua_pushinteger(L, l_castU2S(I2UInt(rv)));  /* full random integer */\n        return 1;\n      }\n      break;\n    }\n    case 2: {  /* lower and upper limits */\n      low = luaL_checkinteger(L, 1);\n      up = luaL_checkinteger(L, 2);\n      break;\n    }\n    default: return luaL_error(L, \"wrong number of arguments\");\n  }\n  /* random integer in the interval [low, up] */\n  luaL_argcheck(L, low <= up, 1, \"interval is empty\");\n  /* project random integer into the interval [0, up - low] */\n  p = project(I2UInt(rv), (lua_Unsigned)up - (lua_Unsigned)low, state);\n  lua_pushinteger(L, l_castU2S(p) + low);\n  return 1;\n}\n\n\nstatic void setseed (lua_State *L, Rand64 *state,\n                     lua_Unsigned n1, lua_Unsigned n2) {\n  int i;\n  state[0] = Int2I(n1);\n  state[1] = Int2I(0xff);  /* avoid a zero state */\n  state[2] = Int2I(n2);\n  state[3] = Int2I(0);\n  for (i = 0; i < 16; i++)\n    nextrand(state);  /* discard initial values to \"spread\" seed */\n  lua_pushinteger(L, l_castU2S(n1));\n  lua_pushinteger(L, l_castU2S(n2));\n}\n\n\nstatic int math_randomseed (lua_State *L) {\n  RanState *state = (RanState *)lua_touserdata(L, lua_upvalueindex(1));\n  lua_Unsigned n1, n2;\n  if (lua_isnone(L, 1)) {\n    n1 = luaL_makeseed(L);  /* \"random\" seed */\n    n2 = I2UInt(nextrand(state->s));  /* in case seed is not that random... */\n  }\n  else {\n    n1 = l_castS2U(luaL_checkinteger(L, 1));\n    n2 = l_castS2U(luaL_optinteger(L, 2, 0));\n  }\n  setseed(L, state->s, n1, n2);\n  return 2;  /* return seeds */\n}\n\n\nstatic const luaL_Reg randfuncs[] = {\n  {\"random\", math_random},\n  {\"randomseed\", math_randomseed},\n  {NULL, NULL}\n};\n\n\n/*\n** Register the random functions and initialize their state.\n*/\nstatic void setrandfunc (lua_State *L) {\n  RanState *state = (RanState *)lua_newuserdatauv(L, sizeof(RanState), 0);\n  setseed(L, state->s, luaL_makeseed(L), 0);  /* initialize with random seed */\n  lua_pop(L, 2);  /* remove pushed seeds */\n  luaL_setfuncs(L, randfuncs, 1);\n}\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Deprecated functions (for compatibility only)\n** ===================================================================\n*/\n#if defined(LUA_COMPAT_MATHLIB)\n\nstatic int math_cosh (lua_State *L) {\n  lua_pushnumber(L, l_mathop(cosh)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_sinh (lua_State *L) {\n  lua_pushnumber(L, l_mathop(sinh)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_tanh (lua_State *L) {\n  lua_pushnumber(L, l_mathop(tanh)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\nstatic int math_pow (lua_State *L) {\n  lua_Number x = luaL_checknumber(L, 1);\n  lua_Number y = luaL_checknumber(L, 2);\n  lua_pushnumber(L, l_mathop(pow)(x, y));\n  return 1;\n}\n\nstatic int math_frexp (lua_State *L) {\n  int e;\n  lua_pushnumber(L, l_mathop(frexp)(luaL_checknumber(L, 1), &e));\n  lua_pushinteger(L, e);\n  return 2;\n}\n\nstatic int math_ldexp (lua_State *L) {\n  lua_Number x = luaL_checknumber(L, 1);\n  int ep = (int)luaL_checkinteger(L, 2);\n  lua_pushnumber(L, l_mathop(ldexp)(x, ep));\n  return 1;\n}\n\nstatic int math_log10 (lua_State *L) {\n  lua_pushnumber(L, l_mathop(log10)(luaL_checknumber(L, 1)));\n  return 1;\n}\n\n#endif\n/* }================================================================== */\n\n\n\nstatic const luaL_Reg mathlib[] = {\n  {\"abs\",   math_abs},\n  {\"acos\",  math_acos},\n  {\"asin\",  math_asin},\n  {\"atan\",  math_atan},\n  {\"ceil\",  math_ceil},\n  {\"cos\",   math_cos},\n  {\"deg\",   math_deg},\n  {\"exp\",   math_exp},\n  {\"tointeger\", math_toint},\n  {\"floor\", math_floor},\n  {\"fmod\",   math_fmod},\n  {\"ult\",   math_ult},\n  {\"log\",   math_log},\n  {\"max\",   math_max},\n  {\"min\",   math_min},\n  {\"modf\",   math_modf},\n  {\"rad\",   math_rad},\n  {\"sin\",   math_sin},\n  {\"sqrt\",  math_sqrt},\n  {\"tan\",   math_tan},\n  {\"type\", math_type},\n#if defined(LUA_COMPAT_MATHLIB)\n  {\"atan2\", math_atan},\n  {\"cosh\",   math_cosh},\n  {\"sinh\",   math_sinh},\n  {\"tanh\",   math_tanh},\n  {\"pow\",   math_pow},\n  {\"frexp\", math_frexp},\n  {\"ldexp\", math_ldexp},\n  {\"log10\", math_log10},\n#endif\n  /* placeholders */\n  {\"random\", NULL},\n  {\"randomseed\", NULL},\n  {\"pi\", NULL},\n  {\"huge\", NULL},\n  {\"maxinteger\", NULL},\n  {\"mininteger\", NULL},\n  {NULL, NULL}\n};\n\n\n/*\n** Open math library\n*/\nLUAMOD_API int luaopen_math (lua_State *L) {\n  luaL_newlib(L, mathlib);\n  lua_pushnumber(L, PI);\n  lua_setfield(L, -2, \"pi\");\n  lua_pushnumber(L, (lua_Number)HUGE_VAL);\n  lua_setfield(L, -2, \"huge\");\n  lua_pushinteger(L, LUA_MAXINTEGER);\n  lua_setfield(L, -2, \"maxinteger\");\n  lua_pushinteger(L, LUA_MININTEGER);\n  lua_setfield(L, -2, \"mininteger\");\n  setrandfunc(L);\n  return 1;\n}\n\n"
        },
        {
          "name": "lmem.c",
          "type": "blob",
          "size": 6.0986328125,
          "content": "/*\n** $Id: lmem.c $\n** Interface to Memory Manager\n** See Copyright Notice in lua.h\n*/\n\n#define lmem_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <stddef.h>\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n\n\n\n/*\n** About the realloc function:\n** void *frealloc (void *ud, void *ptr, size_t osize, size_t nsize);\n** ('osize' is the old size, 'nsize' is the new size)\n**\n** - frealloc(ud, p, x, 0) frees the block 'p' and returns NULL.\n** Particularly, frealloc(ud, NULL, 0, 0) does nothing,\n** which is equivalent to free(NULL) in ISO C.\n**\n** - frealloc(ud, NULL, x, s) creates a new block of size 's'\n** (no matter 'x'). Returns NULL if it cannot create the new block.\n**\n** - otherwise, frealloc(ud, b, x, y) reallocates the block 'b' from\n** size 'x' to size 'y'. Returns NULL if it cannot reallocate the\n** block to the new size.\n*/\n\n\n/*\n** Macro to call the allocation function.\n*/\n#define callfrealloc(g,block,os,ns)    ((*g->frealloc)(g->ud, block, os, ns))\n\n\n/*\n** When an allocation fails, it will try again after an emergency\n** collection, except when it cannot run a collection.  The GC should\n** not be called while the state is not fully built, as the collector\n** is not yet fully initialized. Also, it should not be called when\n** 'gcstopem' is true, because then the interpreter is in the middle of\n** a collection step.\n*/\n#define cantryagain(g)\t(completestate(g) && !g->gcstopem)\n\n\n\n\n#if defined(EMERGENCYGCTESTS)\n/*\n** First allocation will fail except when freeing a block (frees never\n** fail) and when it cannot try again; this fail will trigger 'tryagain'\n** and a full GC cycle at every allocation.\n*/\nstatic void *firsttry (global_State *g, void *block, size_t os, size_t ns) {\n  if (ns > 0 && cantryagain(g))\n    return NULL;  /* fail */\n  else  /* normal allocation */\n    return callfrealloc(g, block, os, ns);\n}\n#else\n#define firsttry(g,block,os,ns)    callfrealloc(g, block, os, ns)\n#endif\n\n\n\n\n\n/*\n** {==================================================================\n** Functions to allocate/deallocate arrays for the Parser\n** ===================================================================\n*/\n\n/*\n** Minimum size for arrays during parsing, to avoid overhead of\n** reallocating to size 1, then 2, and then 4. All these arrays\n** will be reallocated to exact sizes or erased when parsing ends.\n*/\n#define MINSIZEARRAY\t4\n\n\nvoid *luaM_growaux_ (lua_State *L, void *block, int nelems, int *psize,\n                     unsigned size_elems, int limit, const char *what) {\n  void *newblock;\n  int size = *psize;\n  if (nelems + 1 <= size)  /* does one extra element still fit? */\n    return block;  /* nothing to be done */\n  if (size >= limit / 2) {  /* cannot double it? */\n    if (l_unlikely(size >= limit))  /* cannot grow even a little? */\n      luaG_runerror(L, \"too many %s (limit is %d)\", what, limit);\n    size = limit;  /* still have at least one free place */\n  }\n  else {\n    size *= 2;\n    if (size < MINSIZEARRAY)\n      size = MINSIZEARRAY;  /* minimum size */\n  }\n  lua_assert(nelems + 1 <= size && size <= limit);\n  /* 'limit' ensures that multiplication will not overflow */\n  newblock = luaM_saferealloc_(L, block, cast_sizet(*psize) * size_elems,\n                                         cast_sizet(size) * size_elems);\n  *psize = size;  /* update only when everything else is OK */\n  return newblock;\n}\n\n\n/*\n** In prototypes, the size of the array is also its number of\n** elements (to save memory). So, if it cannot shrink an array\n** to its number of elements, the only option is to raise an\n** error.\n*/\nvoid *luaM_shrinkvector_ (lua_State *L, void *block, int *size,\n                          int final_n, unsigned size_elem) {\n  void *newblock;\n  size_t oldsize = cast_sizet(*size) * size_elem;\n  size_t newsize = cast_sizet(final_n) * size_elem;\n  lua_assert(newsize <= oldsize);\n  newblock = luaM_saferealloc_(L, block, oldsize, newsize);\n  *size = final_n;\n  return newblock;\n}\n\n/* }================================================================== */\n\n\nl_noret luaM_toobig (lua_State *L) {\n  luaG_runerror(L, \"memory allocation error: block too big\");\n}\n\n\n/*\n** Free memory\n*/\nvoid luaM_free_ (lua_State *L, void *block, size_t osize) {\n  global_State *g = G(L);\n  lua_assert((osize == 0) == (block == NULL));\n  callfrealloc(g, block, osize, 0);\n  g->GCdebt += cast(l_mem, osize);\n}\n\n\n/*\n** In case of allocation fail, this function will do an emergency\n** collection to free some memory and then try the allocation again.\n*/\nstatic void *tryagain (lua_State *L, void *block,\n                       size_t osize, size_t nsize) {\n  global_State *g = G(L);\n  if (cantryagain(g)) {\n    luaC_fullgc(L, 1);  /* try to free some memory... */\n    return callfrealloc(g, block, osize, nsize);  /* try again */\n  }\n  else return NULL;  /* cannot run an emergency collection */\n}\n\n\n/*\n** Generic allocation routine.\n*/\nvoid *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {\n  void *newblock;\n  global_State *g = G(L);\n  lua_assert((osize == 0) == (block == NULL));\n  newblock = firsttry(g, block, osize, nsize);\n  if (l_unlikely(newblock == NULL && nsize > 0)) {\n    newblock = tryagain(L, block, osize, nsize);\n    if (newblock == NULL)  /* still no memory? */\n      return NULL;  /* do not update 'GCdebt' */\n  }\n  lua_assert((nsize == 0) == (newblock == NULL));\n  g->GCdebt -= cast(l_mem, nsize) - cast(l_mem, osize);\n  return newblock;\n}\n\n\nvoid *luaM_saferealloc_ (lua_State *L, void *block, size_t osize,\n                                                    size_t nsize) {\n  void *newblock = luaM_realloc_(L, block, osize, nsize);\n  if (l_unlikely(newblock == NULL && nsize > 0))  /* allocation failed? */\n    luaM_error(L);\n  return newblock;\n}\n\n\nvoid *luaM_malloc_ (lua_State *L, size_t size, int tag) {\n  if (size == 0)\n    return NULL;  /* that's all */\n  else {\n    global_State *g = G(L);\n    void *newblock = firsttry(g, NULL, cast_sizet(tag), size);\n    if (l_unlikely(newblock == NULL)) {\n      newblock = tryagain(L, NULL, cast_sizet(tag), size);\n      if (newblock == NULL)\n        luaM_error(L);\n    }\n    g->GCdebt -= cast(l_mem, size);\n    return newblock;\n  }\n}\n"
        },
        {
          "name": "lmem.h",
          "type": "blob",
          "size": 3.359375,
          "content": "/*\n** $Id: lmem.h $\n** Interface to Memory Manager\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lmem_h\n#define lmem_h\n\n\n#include <stddef.h>\n\n#include \"llimits.h\"\n#include \"lua.h\"\n\n\n#define luaM_error(L)\tluaD_throw(L, LUA_ERRMEM)\n\n\n/*\n** This macro tests whether it is safe to multiply 'n' by the size of\n** type 't' without overflows. Because 'e' is always constant, it avoids\n** the runtime division MAX_SIZET/(e).\n** (The macro is somewhat complex to avoid warnings:  The 'sizeof'\n** comparison avoids a runtime comparison when overflow cannot occur.\n** The compiler should be able to optimize the real test by itself, but\n** when it does it, it may give a warning about \"comparison is always\n** false due to limited range of data type\"; the +1 tricks the compiler,\n** avoiding this warning but also this optimization.)\n*/\n#define luaM_testsize(n,e)  \\\n\t(sizeof(n) >= sizeof(size_t) && cast_sizet((n)) + 1 > MAX_SIZET/(e))\n\n#define luaM_checksize(L,n,e)  \\\n\t(luaM_testsize(n,e) ? luaM_toobig(L) : cast_void(0))\n\n\n/*\n** Computes the minimum between 'n' and 'MAX_SIZET/sizeof(t)', so that\n** the result is not larger than 'n' and cannot overflow a 'size_t'\n** when multiplied by the size of type 't'. (Assumes that 'n' is an\n** 'int' or 'unsigned int' and that 'int' is not larger than 'size_t'.)\n*/\n#define luaM_limitN(n,t)  \\\n  ((cast_sizet(n) <= MAX_SIZET/sizeof(t)) ? (n) :  \\\n     cast_uint((MAX_SIZET/sizeof(t))))\n\n\n/*\n** Arrays of chars do not need any test\n*/\n#define luaM_reallocvchar(L,b,on,n)  \\\n  cast_charp(luaM_saferealloc_(L, (b), (on)*sizeof(char), (n)*sizeof(char)))\n\n#define luaM_freemem(L, b, s)\tluaM_free_(L, (b), (s))\n#define luaM_free(L, b)\t\tluaM_free_(L, (b), sizeof(*(b)))\n#define luaM_freearray(L, b, n)   luaM_free_(L, (b), (n)*sizeof(*(b)))\n\n#define luaM_new(L,t)\t\tcast(t*, luaM_malloc_(L, sizeof(t), 0))\n#define luaM_newvector(L,n,t)\tcast(t*, luaM_malloc_(L, (n)*sizeof(t), 0))\n#define luaM_newvectorchecked(L,n,t) \\\n  (luaM_checksize(L,n,sizeof(t)), luaM_newvector(L,n,t))\n\n#define luaM_newobject(L,tag,s)\tluaM_malloc_(L, (s), tag)\n\n#define luaM_newblock(L, size)\tluaM_newvector(L, size, char)\n\n#define luaM_growvector(L,v,nelems,size,t,limit,e) \\\n\t((v)=cast(t *, luaM_growaux_(L,v,nelems,&(size),sizeof(t), \\\n                         luaM_limitN(limit,t),e)))\n\n#define luaM_reallocvector(L, v,oldn,n,t) \\\n   (cast(t *, luaM_realloc_(L, v, cast_sizet(oldn) * sizeof(t), \\\n                                  cast_sizet(n) * sizeof(t))))\n\n#define luaM_shrinkvector(L,v,size,fs,t) \\\n   ((v)=cast(t *, luaM_shrinkvector_(L, v, &(size), fs, sizeof(t))))\n\nLUAI_FUNC l_noret luaM_toobig (lua_State *L);\n\n/* not to be called directly */\nLUAI_FUNC void *luaM_realloc_ (lua_State *L, void *block, size_t oldsize,\n                                                          size_t size);\nLUAI_FUNC void *luaM_saferealloc_ (lua_State *L, void *block, size_t oldsize,\n                                                              size_t size);\nLUAI_FUNC void luaM_free_ (lua_State *L, void *block, size_t osize);\nLUAI_FUNC void *luaM_growaux_ (lua_State *L, void *block, int nelems,\n                               int *size, unsigned size_elem, int limit,\n                               const char *what);\nLUAI_FUNC void *luaM_shrinkvector_ (lua_State *L, void *block, int *nelem,\n                                    int final_n, unsigned size_elem);\nLUAI_FUNC void *luaM_malloc_ (lua_State *L, size_t size, int tag);\n\n#endif\n\n"
        },
        {
          "name": "loadlib.c",
          "type": "blob",
          "size": 22.0107421875,
          "content": "/*\n** $Id: loadlib.c $\n** Dynamic library loader for Lua\n** See Copyright Notice in lua.h\n**\n** This module contains an implementation of loadlib for Unix systems\n** that have dlfcn, an implementation for Windows, and a stub for other\n** systems.\n*/\n\n#define loadlib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n#include \"llimits.h\"\n\n\n/*\n** LUA_CSUBSEP is the character that replaces dots in submodule names\n** when searching for a C loader.\n** LUA_LSUBSEP is the character that replaces dots in submodule names\n** when searching for a Lua loader.\n*/\n#if !defined(LUA_CSUBSEP)\n#define LUA_CSUBSEP\t\tLUA_DIRSEP\n#endif\n\n#if !defined(LUA_LSUBSEP)\n#define LUA_LSUBSEP\t\tLUA_DIRSEP\n#endif\n\n\n/* prefix for open functions in C libraries */\n#define LUA_POF\t\t\"luaopen_\"\n\n/* separator for open functions in C libraries */\n#define LUA_OFSEP\t\"_\"\n\n\n/*\n** key for table in the registry that keeps handles\n** for all loaded C libraries\n*/\nstatic const char *const CLIBS = \"_CLIBS\";\n\n#define LIB_FAIL\t\"open\"\n\n\n#define setprogdir(L)           ((void)0)\n\n\n/* cast void* to a Lua function */\n#define cast_Lfunc(p)\tcast(lua_CFunction, cast_func(p))\n\n\n/*\n** system-dependent functions\n*/\n\n/*\n** unload library 'lib'\n*/\nstatic void lsys_unloadlib (void *lib);\n\n/*\n** load C library in file 'path'. If 'seeglb', load with all names in\n** the library global.\n** Returns the library; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb);\n\n/*\n** Try to find a function named 'sym' in library 'lib'.\n** Returns the function; in case of error, returns NULL plus an\n** error string in the stack.\n*/\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym);\n\n\n\n\n#if defined(LUA_USE_DLOPEN)\t/* { */\n/*\n** {========================================================================\n** This is an implementation of loadlib based on the dlfcn interface,\n** which is available in all POSIX systems.\n** =========================================================================\n*/\n\n#include <dlfcn.h>\n\n\nstatic void lsys_unloadlib (void *lib) {\n  dlclose(lib);\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  void *lib = dlopen(path, RTLD_NOW | (seeglb ? RTLD_GLOBAL : RTLD_LOCAL));\n  if (l_unlikely(lib == NULL))\n    lua_pushstring(L, dlerror());\n  return lib;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = cast_Lfunc(dlsym(lib, sym));\n  if (l_unlikely(f == NULL))\n    lua_pushstring(L, dlerror());\n  return f;\n}\n\n/* }====================================================== */\n\n\n\n#elif defined(LUA_DL_DLL)\t/* }{ */\n/*\n** {======================================================================\n** This is an implementation of loadlib for Windows using native functions.\n** =======================================================================\n*/\n\n#include <windows.h>\n\n\n/*\n** optional flags for LoadLibraryEx\n*/\n#if !defined(LUA_LLE_FLAGS)\n#define LUA_LLE_FLAGS\t0\n#endif\n\n\n#undef setprogdir\n\n\n/*\n** Replace in the path (on the top of the stack) any occurrence\n** of LUA_EXEC_DIR with the executable's path.\n*/\nstatic void setprogdir (lua_State *L) {\n  char buff[MAX_PATH + 1];\n  char *lb;\n  DWORD nsize = sizeof(buff)/sizeof(char);\n  DWORD n = GetModuleFileNameA(NULL, buff, nsize);  /* get exec. name */\n  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\\\')) == NULL)\n    luaL_error(L, \"unable to get ModuleFileName\");\n  else {\n    *lb = '\\0';  /* cut name on the last '\\\\' to get the path */\n    luaL_gsub(L, lua_tostring(L, -1), LUA_EXEC_DIR, buff);\n    lua_remove(L, -2);  /* remove original string */\n  }\n}\n\n\n\n\nstatic void pusherror (lua_State *L) {\n  int error = GetLastError();\n  char buffer[128];\n  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, buffer, sizeof(buffer)/sizeof(char), NULL))\n    lua_pushstring(L, buffer);\n  else\n    lua_pushfstring(L, \"system error %d\\n\", error);\n}\n\nstatic void lsys_unloadlib (void *lib) {\n  FreeLibrary((HMODULE)lib);\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  HMODULE lib = LoadLibraryExA(path, NULL, LUA_LLE_FLAGS);\n  (void)(seeglb);  /* not used: symbols are 'global' by default */\n  if (lib == NULL) pusherror(L);\n  return lib;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = cast_Lfunc(GetProcAddress((HMODULE)lib, sym));\n  if (f == NULL) pusherror(L);\n  return f;\n}\n\n/* }====================================================== */\n\n\n#else\t\t\t\t/* }{ */\n/*\n** {======================================================\n** Fallback for other systems\n** =======================================================\n*/\n\n#undef LIB_FAIL\n#define LIB_FAIL\t\"absent\"\n\n\n#define DLMSG\t\"dynamic libraries not enabled; check your Lua installation\"\n\n\nstatic void lsys_unloadlib (void *lib) {\n  (void)(lib);  /* not used */\n}\n\n\nstatic void *lsys_load (lua_State *L, const char *path, int seeglb) {\n  (void)(path); (void)(seeglb);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n\nstatic lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {\n  (void)(lib); (void)(sym);  /* not used */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n/* }====================================================== */\n#endif\t\t\t\t/* } */\n\n\n/*\n** {==================================================================\n** Set Paths\n** ===================================================================\n*/\n\n/*\n** LUA_PATH_VAR and LUA_CPATH_VAR are the names of the environment\n** variables that Lua check to set its paths.\n*/\n#if !defined(LUA_PATH_VAR)\n#define LUA_PATH_VAR    \"LUA_PATH\"\n#endif\n\n#if !defined(LUA_CPATH_VAR)\n#define LUA_CPATH_VAR   \"LUA_CPATH\"\n#endif\n\n\n\n/*\n** return registry.LUA_NOENV as a boolean\n*/\nstatic int noenv (lua_State *L) {\n  int b;\n  lua_getfield(L, LUA_REGISTRYINDEX, \"LUA_NOENV\");\n  b = lua_toboolean(L, -1);\n  lua_pop(L, 1);  /* remove value */\n  return b;\n}\n\n\n/*\n** Set a path. (If using the default path, assume it is a string\n** literal in C and create it as an external string.)\n*/\nstatic void setpath (lua_State *L, const char *fieldname,\n                                   const char *envname,\n                                   const char *dft) {\n  const char *dftmark;\n  const char *nver = lua_pushfstring(L, \"%s%s\", envname, LUA_VERSUFFIX);\n  const char *path = getenv(nver);  /* try versioned name */\n  if (path == NULL)  /* no versioned environment variable? */\n    path = getenv(envname);  /* try unversioned name */\n  if (path == NULL || noenv(L))  /* no environment variable? */\n    lua_pushextlstring(L, dft, strlen(dft), NULL, NULL);  /* use default */\n  else if ((dftmark = strstr(path, LUA_PATH_SEP LUA_PATH_SEP)) == NULL)\n    lua_pushstring(L, path);  /* nothing to change */\n  else {  /* path contains a \";;\": insert default path in its place */\n    size_t len = strlen(path);\n    luaL_Buffer b;\n    luaL_buffinit(L, &b);\n    if (path < dftmark) {  /* is there a prefix before ';;'? */\n      luaL_addlstring(&b, path, ct_diff2sz(dftmark - path));  /* add it */\n      luaL_addchar(&b, *LUA_PATH_SEP);\n    }\n    luaL_addstring(&b, dft);  /* add default */\n    if (dftmark < path + len - 2) {  /* is there a suffix after ';;'? */\n      luaL_addchar(&b, *LUA_PATH_SEP);\n      luaL_addlstring(&b, dftmark + 2, ct_diff2sz((path + len - 2) - dftmark));\n    }\n    luaL_pushresult(&b);\n  }\n  setprogdir(L);\n  lua_setfield(L, -3, fieldname);  /* package[fieldname] = path value */\n  lua_pop(L, 1);  /* pop versioned variable name ('nver') */\n}\n\n/* }================================================================== */\n\n\n/*\n** return registry.CLIBS[path]\n*/\nstatic void *checkclib (lua_State *L, const char *path) {\n  void *plib;\n  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);\n  lua_getfield(L, -1, path);\n  plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */\n  lua_pop(L, 2);  /* pop CLIBS table and 'plib' */\n  return plib;\n}\n\n\n/*\n** registry.CLIBS[path] = plib        -- for queries\n** registry.CLIBS[#CLIBS + 1] = plib  -- also keep a list of all libraries\n*/\nstatic void addtoclib (lua_State *L, const char *path, void *plib) {\n  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);\n  lua_pushlightuserdata(L, plib);\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -3, path);  /* CLIBS[path] = plib */\n  lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */\n  lua_pop(L, 1);  /* pop CLIBS table */\n}\n\n\n/*\n** __gc tag method for CLIBS table: calls 'lsys_unloadlib' for all lib\n** handles in list CLIBS\n*/\nstatic int gctm (lua_State *L) {\n  lua_Integer n = luaL_len(L, 1);\n  for (; n >= 1; n--) {  /* for each handle, in reverse order */\n    lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */\n    lsys_unloadlib(lua_touserdata(L, -1));\n    lua_pop(L, 1);  /* pop handle */\n  }\n  return 0;\n}\n\n\n\n/* error codes for 'lookforfunc' */\n#define ERRLIB\t\t1\n#define ERRFUNC\t\t2\n\n/*\n** Look for a C function named 'sym' in a dynamically loaded library\n** 'path'.\n** First, check whether the library is already loaded; if not, try\n** to load it.\n** Then, if 'sym' is '*', return true (as library has been loaded).\n** Otherwise, look for symbol 'sym' in the library and push a\n** C function with that symbol.\n** Return 0 and 'true' or a function in the stack; in case of\n** errors, return an error code and an error message in the stack.\n*/\nstatic int lookforfunc (lua_State *L, const char *path, const char *sym) {\n  void *reg = checkclib(L, path);  /* check loaded C libraries */\n  if (reg == NULL) {  /* must load library? */\n    reg = lsys_load(L, path, *sym == '*');  /* global symbols if 'sym'=='*' */\n    if (reg == NULL) return ERRLIB;  /* unable to load library */\n    addtoclib(L, path, reg);\n  }\n  if (*sym == '*') {  /* loading only library (no function)? */\n    lua_pushboolean(L, 1);  /* return 'true' */\n    return 0;  /* no errors */\n  }\n  else {\n    lua_CFunction f = lsys_sym(L, reg, sym);\n    if (f == NULL)\n      return ERRFUNC;  /* unable to find function */\n    lua_pushcfunction(L, f);  /* else create new function */\n    return 0;  /* no errors */\n  }\n}\n\n\nstatic int ll_loadlib (lua_State *L) {\n  const char *path = luaL_checkstring(L, 1);\n  const char *init = luaL_checkstring(L, 2);\n  int stat = lookforfunc(L, path, init);\n  if (l_likely(stat == 0))  /* no errors? */\n    return 1;  /* return the loaded function */\n  else {  /* error; error message is on stack top */\n    luaL_pushfail(L);\n    lua_insert(L, -2);\n    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : \"init\");\n    return 3;  /* return fail, error message, and where */\n  }\n}\n\n\n\n/*\n** {======================================================\n** 'require' function\n** =======================================================\n*/\n\n\nstatic int readable (const char *filename) {\n  FILE *f = fopen(filename, \"r\");  /* try to open file */\n  if (f == NULL) return 0;  /* open failed */\n  fclose(f);\n  return 1;\n}\n\n\n/*\n** Get the next name in '*path' = 'name1;name2;name3;...', changing\n** the ending ';' to '\\0' to create a zero-terminated string. Return\n** NULL when list ends.\n*/\nstatic const char *getnextfilename (char **path, char *end) {\n  char *sep;\n  char *name = *path;\n  if (name == end)\n    return NULL;  /* no more names */\n  else if (*name == '\\0') {  /* from previous iteration? */\n    *name = *LUA_PATH_SEP;  /* restore separator */\n    name++;  /* skip it */\n  }\n  sep = strchr(name, *LUA_PATH_SEP);  /* find next separator */\n  if (sep == NULL)  /* separator not found? */\n    sep = end;  /* name goes until the end */\n  *sep = '\\0';  /* finish file name */\n  *path = sep;  /* will start next search from here */\n  return name;\n}\n\n\n/*\n** Given a path such as \";blabla.so;blublu.so\", pushes the string\n**\n** no file 'blabla.so'\n**\tno file 'blublu.so'\n*/\nstatic void pusherrornotfound (lua_State *L, const char *path) {\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  luaL_addstring(&b, \"no file '\");\n  luaL_addgsub(&b, path, LUA_PATH_SEP, \"'\\n\\tno file '\");\n  luaL_addstring(&b, \"'\");\n  luaL_pushresult(&b);\n}\n\n\nstatic const char *searchpath (lua_State *L, const char *name,\n                                             const char *path,\n                                             const char *sep,\n                                             const char *dirsep) {\n  luaL_Buffer buff;\n  char *pathname;  /* path with name inserted */\n  char *endpathname;  /* its end */\n  const char *filename;\n  /* separator is non-empty and appears in 'name'? */\n  if (*sep != '\\0' && strchr(name, *sep) != NULL)\n    name = luaL_gsub(L, name, sep, dirsep);  /* replace it by 'dirsep' */\n  luaL_buffinit(L, &buff);\n  /* add path to the buffer, replacing marks ('?') with the file name */\n  luaL_addgsub(&buff, path, LUA_PATH_MARK, name);\n  luaL_addchar(&buff, '\\0');\n  pathname = luaL_buffaddr(&buff);  /* writable list of file names */\n  endpathname = pathname + luaL_bufflen(&buff) - 1;\n  while ((filename = getnextfilename(&pathname, endpathname)) != NULL) {\n    if (readable(filename))  /* does file exist and is readable? */\n      return lua_pushstring(L, filename);  /* save and return name */\n  }\n  luaL_pushresult(&buff);  /* push path to create error message */\n  pusherrornotfound(L, lua_tostring(L, -1));  /* create error message */\n  return NULL;  /* not found */\n}\n\n\nstatic int ll_searchpath (lua_State *L) {\n  const char *f = searchpath(L, luaL_checkstring(L, 1),\n                                luaL_checkstring(L, 2),\n                                luaL_optstring(L, 3, \".\"),\n                                luaL_optstring(L, 4, LUA_DIRSEP));\n  if (f != NULL) return 1;\n  else {  /* error message is on top of the stack */\n    luaL_pushfail(L);\n    lua_insert(L, -2);\n    return 2;  /* return fail + error message */\n  }\n}\n\n\nstatic const char *findfile (lua_State *L, const char *name,\n                                           const char *pname,\n                                           const char *dirsep) {\n  const char *path;\n  lua_getfield(L, lua_upvalueindex(1), pname);\n  path = lua_tostring(L, -1);\n  if (l_unlikely(path == NULL))\n    luaL_error(L, \"'package.%s' must be a string\", pname);\n  return searchpath(L, name, path, \".\", dirsep);\n}\n\n\nstatic int checkload (lua_State *L, int stat, const char *filename) {\n  if (l_likely(stat)) {  /* module loaded successfully? */\n    lua_pushstring(L, filename);  /* will be 2nd argument to module */\n    return 2;  /* return open function and file name */\n  }\n  else\n    return luaL_error(L, \"error loading module '%s' from file '%s':\\n\\t%s\",\n                          lua_tostring(L, 1), filename, lua_tostring(L, -1));\n}\n\n\nstatic int searcher_Lua (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  filename = findfile(L, name, \"path\", LUA_LSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (luaL_loadfile(L, filename) == LUA_OK), filename);\n}\n\n\n/*\n** Try to find a load function for module 'modname' at file 'filename'.\n** First, change '.' to '_' in 'modname'; then, if 'modname' has\n** the form X-Y (that is, it has an \"ignore mark\"), build a function\n** name \"luaopen_X\" and look for it. (For compatibility, if that\n** fails, it also tries \"luaopen_Y\".) If there is no ignore mark,\n** look for a function named \"luaopen_modname\".\n*/\nstatic int loadfunc (lua_State *L, const char *filename, const char *modname) {\n  const char *openfunc;\n  const char *mark;\n  modname = luaL_gsub(L, modname, \".\", LUA_OFSEP);\n  mark = strchr(modname, *LUA_IGMARK);\n  if (mark) {\n    int stat;\n    openfunc = lua_pushlstring(L, modname, ct_diff2sz(mark - modname));\n    openfunc = lua_pushfstring(L, LUA_POF\"%s\", openfunc);\n    stat = lookforfunc(L, filename, openfunc);\n    if (stat != ERRFUNC) return stat;\n    modname = mark + 1;  /* else go ahead and try old-style name */\n  }\n  openfunc = lua_pushfstring(L, LUA_POF\"%s\", modname);\n  return lookforfunc(L, filename, openfunc);\n}\n\n\nstatic int searcher_C (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  const char *filename = findfile(L, name, \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* module not found in this path */\n  return checkload(L, (loadfunc(L, filename, name) == 0), filename);\n}\n\n\nstatic int searcher_Croot (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  const char *p = strchr(name, '.');\n  int stat;\n  if (p == NULL) return 0;  /* is root */\n  lua_pushlstring(L, name, ct_diff2sz(p - name));\n  filename = findfile(L, lua_tostring(L, -1), \"cpath\", LUA_CSUBSEP);\n  if (filename == NULL) return 1;  /* root not found */\n  if ((stat = loadfunc(L, filename, name)) != 0) {\n    if (stat != ERRFUNC)\n      return checkload(L, 0, filename);  /* real error */\n    else {  /* open function not found */\n      lua_pushfstring(L, \"no module '%s' in file '%s'\", name, filename);\n      return 1;\n    }\n  }\n  lua_pushstring(L, filename);  /* will be 2nd argument to module */\n  return 2;\n}\n\n\nstatic int searcher_preload (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_getfield(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);\n  if (lua_getfield(L, -1, name) == LUA_TNIL) {  /* not found? */\n    lua_pushfstring(L, \"no field package.preload['%s']\", name);\n    return 1;\n  }\n  else {\n    lua_pushliteral(L, \":preload:\");\n    return 2;\n  }\n}\n\n\nstatic void findloader (lua_State *L, const char *name) {\n  int i;\n  luaL_Buffer msg;  /* to build error message */\n  /* push 'package.searchers' to index 3 in the stack */\n  if (l_unlikely(lua_getfield(L, lua_upvalueindex(1), \"searchers\")\n                 != LUA_TTABLE))\n    luaL_error(L, \"'package.searchers' must be a table\");\n  luaL_buffinit(L, &msg);\n  luaL_addstring(&msg, \"\\n\\t\");  /* error-message prefix for first message */\n  /*  iterate over available searchers to find a loader */\n  for (i = 1; ; i++) {\n    if (l_unlikely(lua_rawgeti(L, 3, i) == LUA_TNIL)) {  /* no more searchers? */\n      lua_pop(L, 1);  /* remove nil */\n      luaL_buffsub(&msg, 2);  /* remove last prefix */\n      luaL_pushresult(&msg);  /* create error message */\n      luaL_error(L, \"module '%s' not found:%s\", name, lua_tostring(L, -1));\n    }\n    lua_pushstring(L, name);\n    lua_call(L, 1, 2);  /* call it */\n    if (lua_isfunction(L, -2))  /* did it find a loader? */\n      return;  /* module loader found */\n    else if (lua_isstring(L, -2)) {  /* searcher returned error message? */\n      lua_pop(L, 1);  /* remove extra return */\n      luaL_addvalue(&msg);  /* concatenate error message */\n      luaL_addstring(&msg, \"\\n\\t\");  /* prefix for next message */\n    }\n    else  /* no error message */\n      lua_pop(L, 2);  /* remove both returns */\n  }\n}\n\n\nstatic int ll_require (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_settop(L, 1);  /* LOADED table will be at index 2 */\n  lua_getfield(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n  lua_getfield(L, 2, name);  /* LOADED[name] */\n  if (lua_toboolean(L, -1))  /* is it there? */\n    return 1;  /* package is already loaded */\n  /* else must load package */\n  lua_pop(L, 1);  /* remove 'getfield' result */\n  findloader(L, name);\n  lua_rotate(L, -2, 1);  /* function <-> loader data */\n  lua_pushvalue(L, 1);  /* name is 1st argument to module loader */\n  lua_pushvalue(L, -3);  /* loader data is 2nd argument */\n  /* stack: ...; loader data; loader function; mod. name; loader data */\n  lua_call(L, 2, 1);  /* run loader to load module */\n  /* stack: ...; loader data; result from loader */\n  if (!lua_isnil(L, -1))  /* non-nil return? */\n    lua_setfield(L, 2, name);  /* LOADED[name] = returned value */\n  else\n    lua_pop(L, 1);  /* pop nil */\n  if (lua_getfield(L, 2, name) == LUA_TNIL) {   /* module set no value? */\n    lua_pushboolean(L, 1);  /* use true as result */\n    lua_copy(L, -1, -2);  /* replace loader result */\n    lua_setfield(L, 2, name);  /* LOADED[name] = true */\n  }\n  lua_rotate(L, -2, 1);  /* loader data <-> module result  */\n  return 2;  /* return module result and loader data */\n}\n\n/* }====================================================== */\n\n\n\n\nstatic const luaL_Reg pk_funcs[] = {\n  {\"loadlib\", ll_loadlib},\n  {\"searchpath\", ll_searchpath},\n  /* placeholders */\n  {\"preload\", NULL},\n  {\"cpath\", NULL},\n  {\"path\", NULL},\n  {\"searchers\", NULL},\n  {\"loaded\", NULL},\n  {NULL, NULL}\n};\n\n\nstatic const luaL_Reg ll_funcs[] = {\n  {\"require\", ll_require},\n  {NULL, NULL}\n};\n\n\nstatic void createsearcherstable (lua_State *L) {\n  static const lua_CFunction searchers[] = {\n    searcher_preload,\n    searcher_Lua,\n    searcher_C,\n    searcher_Croot,\n    NULL\n  };\n  int i;\n  /* create 'searchers' table */\n  lua_createtable(L, sizeof(searchers)/sizeof(searchers[0]) - 1, 0);\n  /* fill it with predefined searchers */\n  for (i=0; searchers[i] != NULL; i++) {\n    lua_pushvalue(L, -2);  /* set 'package' as upvalue for all searchers */\n    lua_pushcclosure(L, searchers[i], 1);\n    lua_rawseti(L, -2, i+1);\n  }\n  lua_setfield(L, -2, \"searchers\");  /* put it in field 'searchers' */\n}\n\n\n/*\n** create table CLIBS to keep track of loaded C libraries,\n** setting a finalizer to close all libraries when closing state.\n*/\nstatic void createclibstable (lua_State *L) {\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, CLIBS);  /* create CLIBS table */\n  lua_createtable(L, 0, 1);  /* create metatable for CLIBS */\n  lua_pushcfunction(L, gctm);\n  lua_setfield(L, -2, \"__gc\");  /* set finalizer for CLIBS table */\n  lua_setmetatable(L, -2);\n}\n\n\nLUAMOD_API int luaopen_package (lua_State *L) {\n  createclibstable(L);\n  luaL_newlib(L, pk_funcs);  /* create 'package' table */\n  createsearcherstable(L);\n  /* set paths */\n  setpath(L, \"path\", LUA_PATH_VAR, LUA_PATH_DEFAULT);\n  setpath(L, \"cpath\", LUA_CPATH_VAR, LUA_CPATH_DEFAULT);\n  /* store config information */\n  lua_pushliteral(L, LUA_DIRSEP \"\\n\" LUA_PATH_SEP \"\\n\" LUA_PATH_MARK \"\\n\"\n                     LUA_EXEC_DIR \"\\n\" LUA_IGMARK \"\\n\");\n  lua_setfield(L, -2, \"config\");\n  /* set field 'loaded' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_LOADED_TABLE);\n  lua_setfield(L, -2, \"loaded\");\n  /* set field 'preload' */\n  luaL_getsubtable(L, LUA_REGISTRYINDEX, LUA_PRELOAD_TABLE);\n  lua_setfield(L, -2, \"preload\");\n  lua_pushglobaltable(L);\n  lua_pushvalue(L, -2);  /* set 'package' as upvalue for next lib */\n  luaL_setfuncs(L, ll_funcs, 1);  /* open lib into global table */\n  lua_pop(L, 1);  /* pop global table */\n  return 1;  /* return 'package' table */\n}\n\n"
        },
        {
          "name": "lobject.c",
          "type": "blob",
          "size": 23.34375,
          "content": "/*\n** $Id: lobject.c $\n** Some generic functions over Lua objects\n** See Copyright Notice in lua.h\n*/\n\n#define lobject_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <float.h>\n#include <locale.h>\n#include <math.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lctype.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"lvm.h\"\n\n\n/*\n** Computes ceil(log2(x))\n*/\nlu_byte luaO_ceillog2 (unsigned int x) {\n  static const lu_byte log_2[256] = {  /* log_2[i - 1] = ceil(log2(i)) */\n    0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,\n    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8\n  };\n  int l = 0;\n  x--;\n  while (x >= 256) { l += 8; x >>= 8; }\n  return cast_byte(l + log_2[x]);\n}\n\n/*\n** Encodes 'p'% as a floating-point byte, represented as (eeeexxxx).\n** The exponent is represented using excess-7. Mimicking IEEE 754, the\n** representation normalizes the number when possible, assuming an extra\n** 1 before the mantissa (xxxx) and adding one to the exponent (eeee)\n** to signal that. So, the real value is (1xxxx) * 2^(eeee - 7 - 1) if\n** eeee != 0, and (xxxx) * 2^-7 otherwise (subnormal numbers).\n*/\nlu_byte luaO_codeparam (unsigned int p) {\n  if (p >= (cast(lu_mem, 0x1F) << (0xF - 7 - 1)) * 100u)  /* overflow? */\n    return 0xFF;  /* return maximum value */\n  else {\n    p = (cast(l_uint32, p) * 128 + 99) / 100;  /* round up the division */\n    if (p < 0x10) {  /* subnormal number? */\n      /* exponent bits are already zero; nothing else to do */\n      return cast_byte(p);\n    }\n    else {  /* p >= 0x10 implies ceil(log2(p + 1)) >= 5 */\n      /* preserve 5 bits in 'p' */\n      unsigned log = luaO_ceillog2(p + 1) - 5u;\n      return cast_byte(((p >> log) - 0x10) | ((log + 1) << 4));\n    }\n  }\n}\n\n\n/*\n** Computes 'p' times 'x', where 'p' is a floating-point byte. Roughly,\n** we have to multiply 'x' by the mantissa and then shift accordingly to\n** the exponent.  If the exponent is positive, both the multiplication\n** and the shift increase 'x', so we have to care only about overflows.\n** For negative exponents, however, multiplying before the shift keeps\n** more significant bits, as long as the multiplication does not\n** overflow, so we check which order is best.\n*/\nl_mem luaO_applyparam (lu_byte p, l_mem x) {\n  unsigned int m = p & 0xF;  /* mantissa */\n  int e = (p >> 4);  /* exponent */\n  if (e > 0) {  /* normalized? */\n    e--;  /* correct exponent */\n    m += 0x10;  /* correct mantissa; maximum value is 0x1F */\n  }\n  e -= 7;  /* correct excess-7 */\n  if (e >= 0) {\n    if (x < (MAX_LMEM / 0x1F) >> e)  /* no overflow? */\n      return (x * m) << e;  /* order doesn't matter here */\n    else  /* real overflow */\n      return MAX_LMEM;\n  }\n  else {  /* negative exponent */\n    e = -e;\n    if (x < MAX_LMEM / 0x1F)  /* multiplication cannot overflow? */\n      return (x * m) >> e;  /* multiplying first gives more precision */\n    else if ((x >> e) <  MAX_LMEM / 0x1F)  /* cannot overflow after shift? */\n      return (x >> e) * m;\n    else  /* real overflow */\n      return MAX_LMEM;\n  }\n}\n\n\nstatic lua_Integer intarith (lua_State *L, int op, lua_Integer v1,\n                                                   lua_Integer v2) {\n  switch (op) {\n    case LUA_OPADD: return intop(+, v1, v2);\n    case LUA_OPSUB:return intop(-, v1, v2);\n    case LUA_OPMUL:return intop(*, v1, v2);\n    case LUA_OPMOD: return luaV_mod(L, v1, v2);\n    case LUA_OPIDIV: return luaV_idiv(L, v1, v2);\n    case LUA_OPBAND: return intop(&, v1, v2);\n    case LUA_OPBOR: return intop(|, v1, v2);\n    case LUA_OPBXOR: return intop(^, v1, v2);\n    case LUA_OPSHL: return luaV_shiftl(v1, v2);\n    case LUA_OPSHR: return luaV_shiftr(v1, v2);\n    case LUA_OPUNM: return intop(-, 0, v1);\n    case LUA_OPBNOT: return intop(^, ~l_castS2U(0), v1);\n    default: lua_assert(0); return 0;\n  }\n}\n\n\nstatic lua_Number numarith (lua_State *L, int op, lua_Number v1,\n                                                  lua_Number v2) {\n  switch (op) {\n    case LUA_OPADD: return luai_numadd(L, v1, v2);\n    case LUA_OPSUB: return luai_numsub(L, v1, v2);\n    case LUA_OPMUL: return luai_nummul(L, v1, v2);\n    case LUA_OPDIV: return luai_numdiv(L, v1, v2);\n    case LUA_OPPOW: return luai_numpow(L, v1, v2);\n    case LUA_OPIDIV: return luai_numidiv(L, v1, v2);\n    case LUA_OPUNM: return luai_numunm(L, v1);\n    case LUA_OPMOD: return luaV_modf(L, v1, v2);\n    default: lua_assert(0); return 0;\n  }\n}\n\n\nint luaO_rawarith (lua_State *L, int op, const TValue *p1, const TValue *p2,\n                   TValue *res) {\n  switch (op) {\n    case LUA_OPBAND: case LUA_OPBOR: case LUA_OPBXOR:\n    case LUA_OPSHL: case LUA_OPSHR:\n    case LUA_OPBNOT: {  /* operate only on integers */\n      lua_Integer i1; lua_Integer i2;\n      if (tointegerns(p1, &i1) && tointegerns(p2, &i2)) {\n        setivalue(res, intarith(L, op, i1, i2));\n        return 1;\n      }\n      else return 0;  /* fail */\n    }\n    case LUA_OPDIV: case LUA_OPPOW: {  /* operate only on floats */\n      lua_Number n1; lua_Number n2;\n      if (tonumberns(p1, n1) && tonumberns(p2, n2)) {\n        setfltvalue(res, numarith(L, op, n1, n2));\n        return 1;\n      }\n      else return 0;  /* fail */\n    }\n    default: {  /* other operations */\n      lua_Number n1; lua_Number n2;\n      if (ttisinteger(p1) && ttisinteger(p2)) {\n        setivalue(res, intarith(L, op, ivalue(p1), ivalue(p2)));\n        return 1;\n      }\n      else if (tonumberns(p1, n1) && tonumberns(p2, n2)) {\n        setfltvalue(res, numarith(L, op, n1, n2));\n        return 1;\n      }\n      else return 0;  /* fail */\n    }\n  }\n}\n\n\nvoid luaO_arith (lua_State *L, int op, const TValue *p1, const TValue *p2,\n                 StkId res) {\n  if (!luaO_rawarith(L, op, p1, p2, s2v(res))) {\n    /* could not perform raw operation; try metamethod */\n    luaT_trybinTM(L, p1, p2, res, cast(TMS, (op - LUA_OPADD) + TM_ADD));\n  }\n}\n\n\nlu_byte luaO_hexavalue (int c) {\n  if (lisdigit(c)) return cast_byte(c - '0');\n  else return cast_byte((ltolower(c) - 'a') + 10);\n}\n\n\nstatic int isneg (const char **s) {\n  if (**s == '-') { (*s)++; return 1; }\n  else if (**s == '+') (*s)++;\n  return 0;\n}\n\n\n\n/*\n** {==================================================================\n** Lua's implementation for 'lua_strx2number'\n** ===================================================================\n*/\n\n#if !defined(lua_strx2number)\n\n/* maximum number of significant digits to read (to avoid overflows\n   even with single floats) */\n#define MAXSIGDIG\t30\n\n/*\n** convert a hexadecimal numeric string to a number, following\n** C99 specification for 'strtod'\n*/\nstatic lua_Number lua_strx2number (const char *s, char **endptr) {\n  int dot = lua_getlocaledecpoint();\n  lua_Number r = l_mathop(0.0);  /* result (accumulator) */\n  int sigdig = 0;  /* number of significant digits */\n  int nosigdig = 0;  /* number of non-significant digits */\n  int e = 0;  /* exponent correction */\n  int neg;  /* 1 if number is negative */\n  int hasdot = 0;  /* true after seen a dot */\n  *endptr = cast_charp(s);  /* nothing is valid yet */\n  while (lisspace(cast_uchar(*s))) s++;  /* skip initial spaces */\n  neg = isneg(&s);  /* check sign */\n  if (!(*s == '0' && (*(s + 1) == 'x' || *(s + 1) == 'X')))  /* check '0x' */\n    return l_mathop(0.0);  /* invalid format (no '0x') */\n  for (s += 2; ; s++) {  /* skip '0x' and read numeral */\n    if (*s == dot) {\n      if (hasdot) break;  /* second dot? stop loop */\n      else hasdot = 1;\n    }\n    else if (lisxdigit(cast_uchar(*s))) {\n      if (sigdig == 0 && *s == '0')  /* non-significant digit (zero)? */\n        nosigdig++;\n      else if (++sigdig <= MAXSIGDIG)  /* can read it without overflow? */\n          r = (r * l_mathop(16.0)) + luaO_hexavalue(*s);\n      else e++; /* too many digits; ignore, but still count for exponent */\n      if (hasdot) e--;  /* decimal digit? correct exponent */\n    }\n    else break;  /* neither a dot nor a digit */\n  }\n  if (nosigdig + sigdig == 0)  /* no digits? */\n    return l_mathop(0.0);  /* invalid format */\n  *endptr = cast_charp(s);  /* valid up to here */\n  e *= 4;  /* each digit multiplies/divides value by 2^4 */\n  if (*s == 'p' || *s == 'P') {  /* exponent part? */\n    int exp1 = 0;  /* exponent value */\n    int neg1;  /* exponent sign */\n    s++;  /* skip 'p' */\n    neg1 = isneg(&s);  /* sign */\n    if (!lisdigit(cast_uchar(*s)))\n      return l_mathop(0.0);  /* invalid; must have at least one digit */\n    while (lisdigit(cast_uchar(*s)))  /* read exponent */\n      exp1 = exp1 * 10 + *(s++) - '0';\n    if (neg1) exp1 = -exp1;\n    e += exp1;\n    *endptr = cast_charp(s);  /* valid up to here */\n  }\n  if (neg) r = -r;\n  return l_mathop(ldexp)(r, e);\n}\n\n#endif\n/* }====================================================== */\n\n\n/* maximum length of a numeral to be converted to a number */\n#if !defined (L_MAXLENNUM)\n#define L_MAXLENNUM\t200\n#endif\n\n/*\n** Convert string 's' to a Lua number (put in 'result'). Return NULL on\n** fail or the address of the ending '\\0' on success. ('mode' == 'x')\n** means a hexadecimal numeral.\n*/\nstatic const char *l_str2dloc (const char *s, lua_Number *result, int mode) {\n  char *endptr;\n  *result = (mode == 'x') ? lua_strx2number(s, &endptr)  /* try to convert */\n                          : lua_str2number(s, &endptr);\n  if (endptr == s) return NULL;  /* nothing recognized? */\n  while (lisspace(cast_uchar(*endptr))) endptr++;  /* skip trailing spaces */\n  return (*endptr == '\\0') ? endptr : NULL;  /* OK iff no trailing chars */\n}\n\n\n/*\n** Convert string 's' to a Lua number (put in 'result') handling the\n** current locale.\n** This function accepts both the current locale or a dot as the radix\n** mark. If the conversion fails, it may mean number has a dot but\n** locale accepts something else. In that case, the code copies 's'\n** to a buffer (because 's' is read-only), changes the dot to the\n** current locale radix mark, and tries to convert again.\n** The variable 'mode' checks for special characters in the string:\n** - 'n' means 'inf' or 'nan' (which should be rejected)\n** - 'x' means a hexadecimal numeral\n** - '.' just optimizes the search for the common case (no special chars)\n*/\nstatic const char *l_str2d (const char *s, lua_Number *result) {\n  const char *endptr;\n  const char *pmode = strpbrk(s, \".xXnN\");  /* look for special chars */\n  int mode = pmode ? ltolower(cast_uchar(*pmode)) : 0;\n  if (mode == 'n')  /* reject 'inf' and 'nan' */\n    return NULL;\n  endptr = l_str2dloc(s, result, mode);  /* try to convert */\n  if (endptr == NULL) {  /* failed? may be a different locale */\n    char buff[L_MAXLENNUM + 1];\n    const char *pdot = strchr(s, '.');\n    if (pdot == NULL || strlen(s) > L_MAXLENNUM)\n      return NULL;  /* string too long or no dot; fail */\n    strcpy(buff, s);  /* copy string to buffer */\n    buff[pdot - s] = lua_getlocaledecpoint();  /* correct decimal point */\n    endptr = l_str2dloc(buff, result, mode);  /* try again */\n    if (endptr != NULL)\n      endptr = s + (endptr - buff);  /* make relative to 's' */\n  }\n  return endptr;\n}\n\n\n#define MAXBY10\t\tcast(lua_Unsigned, LUA_MAXINTEGER / 10)\n#define MAXLASTD\tcast_int(LUA_MAXINTEGER % 10)\n\nstatic const char *l_str2int (const char *s, lua_Integer *result) {\n  lua_Unsigned a = 0;\n  int empty = 1;\n  int neg;\n  while (lisspace(cast_uchar(*s))) s++;  /* skip initial spaces */\n  neg = isneg(&s);\n  if (s[0] == '0' &&\n      (s[1] == 'x' || s[1] == 'X')) {  /* hex? */\n    s += 2;  /* skip '0x' */\n    for (; lisxdigit(cast_uchar(*s)); s++) {\n      a = a * 16 + luaO_hexavalue(*s);\n      empty = 0;\n    }\n  }\n  else {  /* decimal */\n    for (; lisdigit(cast_uchar(*s)); s++) {\n      int d = *s - '0';\n      if (a >= MAXBY10 && (a > MAXBY10 || d > MAXLASTD + neg))  /* overflow? */\n        return NULL;  /* do not accept it (as integer) */\n      a = a * 10 + cast_uint(d);\n      empty = 0;\n    }\n  }\n  while (lisspace(cast_uchar(*s))) s++;  /* skip trailing spaces */\n  if (empty || *s != '\\0') return NULL;  /* something wrong in the numeral */\n  else {\n    *result = l_castU2S((neg) ? 0u - a : a);\n    return s;\n  }\n}\n\n\nsize_t luaO_str2num (const char *s, TValue *o) {\n  lua_Integer i; lua_Number n;\n  const char *e;\n  if ((e = l_str2int(s, &i)) != NULL) {  /* try as an integer */\n    setivalue(o, i);\n  }\n  else if ((e = l_str2d(s, &n)) != NULL) {  /* else try as a float */\n    setfltvalue(o, n);\n  }\n  else\n    return 0;  /* conversion failed */\n  return ct_diff2sz(e - s) + 1;  /* success; return string size */\n}\n\n\nint luaO_utf8esc (char *buff, unsigned long x) {\n  int n = 1;  /* number of bytes put in buffer (backwards) */\n  lua_assert(x <= 0x7FFFFFFFu);\n  if (x < 0x80)  /* ascii? */\n    buff[UTF8BUFFSZ - 1] = cast_char(x);\n  else {  /* need continuation bytes */\n    unsigned int mfb = 0x3f;  /* maximum that fits in first byte */\n    do {  /* add continuation bytes */\n      buff[UTF8BUFFSZ - (n++)] = cast_char(0x80 | (x & 0x3f));\n      x >>= 6;  /* remove added bits */\n      mfb >>= 1;  /* now there is one less bit available in first byte */\n    } while (x > mfb);  /* still needs continuation byte? */\n    buff[UTF8BUFFSZ - n] = cast_char((~mfb << 1) | x);  /* add first byte */\n  }\n  return n;\n}\n\n\n/*\n** The size of the buffer for the conversion of a number to a string\n** 'LUA_N2SBUFFSZ' must be enough to accommodate both LUA_INTEGER_FMT\n** and LUA_NUMBER_FMT.  For a long long int, this is 19 digits plus a\n** sign and a final '\\0', adding to 21. For a long double, it can go to\n** a sign, the dot, an exponent letter, an exponent sign, 4 exponent\n** digits, the final '\\0', plus the significant digits, which are\n** approximately the *_DIG attribute.\n*/\n#if LUA_N2SBUFFSZ < (20 + l_floatatt(DIG))\n#error \"invalid value for LUA_N2SBUFFSZ\"\n#endif\n\n\n/*\n** Convert a float to a string, adding it to a buffer. First try with\n** a not too large number of digits, to avoid noise (for instance,\n** 1.1 going to \"1.1000000000000001\"). If that lose precision, so\n** that reading the result back gives a different number, then do the\n** conversion again with extra precision. Moreover, if the numeral looks\n** like an integer (without a decimal point or an exponent), add \".0\" to\n** its end.\n*/\nstatic int tostringbuffFloat (lua_Number n, char *buff) {\n  /* first conversion */\n  int len = l_sprintf(buff, LUA_N2SBUFFSZ, LUA_NUMBER_FMT,\n                            (LUAI_UACNUMBER)n);\n  lua_Number check = lua_str2number(buff, NULL);  /* read it back */\n  if (check != n) {  /* not enough precision? */\n    /* convert again with more precision */\n    len = l_sprintf(buff, LUA_N2SBUFFSZ, LUA_NUMBER_FMT_N,\n                          (LUAI_UACNUMBER)n);\n  }\n  /* looks like an integer? */\n  if (buff[strspn(buff, \"-0123456789\")] == '\\0') {\n    buff[len++] = lua_getlocaledecpoint();\n    buff[len++] = '0';  /* adds '.0' to result */\n  }\n  return len;\n}\n\n\n/*\n** Convert a number object to a string, adding it to a buffer.\n*/\nunsigned luaO_tostringbuff (const TValue *obj, char *buff) {\n  int len;\n  lua_assert(ttisnumber(obj));\n  if (ttisinteger(obj))\n    len = lua_integer2str(buff, LUA_N2SBUFFSZ, ivalue(obj));\n  else\n    len = tostringbuffFloat(fltvalue(obj), buff);\n  lua_assert(len < LUA_N2SBUFFSZ);\n  return cast_uint(len);\n}\n\n\n/*\n** Convert a number object to a Lua string, replacing the value at 'obj'\n*/\nvoid luaO_tostring (lua_State *L, TValue *obj) {\n  char buff[LUA_N2SBUFFSZ];\n  unsigned len = luaO_tostringbuff(obj, buff);\n  setsvalue(L, obj, luaS_newlstr(L, buff, len));\n}\n\n\n\n\n/*\n** {==================================================================\n** 'luaO_pushvfstring'\n** ===================================================================\n*/\n\n/*\n** Size for buffer space used by 'luaO_pushvfstring'. It should be\n** (LUA_IDSIZE + LUA_N2SBUFFSZ) + a minimal space for basic messages,\n** so that 'luaG_addinfo' can work directly on the static buffer.\n*/\n#define BUFVFS\t\tcast_uint(LUA_IDSIZE + LUA_N2SBUFFSZ + 95)\n\n/*\n** Buffer used by 'luaO_pushvfstring'. 'err' signals an error while\n** building result (memory error [1] or buffer overflow [2]).\n*/\ntypedef struct BuffFS {\n  lua_State *L;\n  char *b;\n  size_t buffsize;\n  size_t blen;  /* length of string in 'buff' */\n  int err;\n  char space[BUFVFS];  /* initial buffer */\n} BuffFS;\n\n\nstatic void initbuff (lua_State *L, BuffFS *buff) {\n  buff->L = L;\n  buff->b = buff->space;\n  buff->buffsize = sizeof(buff->space);\n  buff->blen = 0;\n  buff->err = 0;\n}\n\n\n/*\n** Push final result from 'luaO_pushvfstring'. This function may raise\n** errors explicitly or through memory errors, so it must run protected.\n*/\nstatic void pushbuff (lua_State *L, void *ud) {\n  BuffFS *buff = cast(BuffFS*, ud);\n  switch (buff->err) {\n    case 1:\n      luaD_throw(L, LUA_ERRMEM);\n      break;\n    case 2:  /* length overflow: Add \"...\" at the end of result */\n      if (buff->buffsize - buff->blen < 3)\n        strcpy(buff->b + buff->blen - 3, \"...\"); /* 'blen' must be > 3 */\n      else {  /* there is enough space left for the \"...\" */\n        strcpy(buff->b + buff->blen, \"...\");\n        buff->blen += 3;\n      }\n      /* FALLTHROUGH */\n    default: {  /* no errors */\n      TString *ts = luaS_newlstr(L, buff->b, buff->blen);\n      setsvalue2s(L, L->top.p, ts);\n      L->top.p++;\n    }\n  }\n}\n\n\nstatic const char *clearbuff (BuffFS *buff) {\n  lua_State *L = buff->L;\n  const char *res;\n  if (luaD_rawrunprotected(L, pushbuff, buff) != LUA_OK)  /* errors? */\n    res = NULL;  /* error message is on the top of the stack */\n  else\n    res = getstr(tsvalue(s2v(L->top.p - 1)));\n  if (buff->b != buff->space)  /* using dynamic buffer? */\n    luaM_freearray(L, buff->b, buff->buffsize);  /* free it */\n  return res;\n}\n\n\nstatic void addstr2buff (BuffFS *buff, const char *str, size_t slen) {\n  size_t left = buff->buffsize - buff->blen;  /* space left in the buffer */\n  if (buff->err)  /* do nothing else after an error */\n    return;\n  if (slen > left) {  /* new string doesn't fit into current buffer? */\n    if (slen > ((MAX_SIZE/2) - buff->blen)) {  /* overflow? */\n      memcpy(buff->b + buff->blen, str, left);  /* copy what it can */\n      buff->blen = buff->buffsize;\n      buff->err = 2;  /* doesn't add anything else */\n      return;\n    }\n    else {\n      size_t newsize = buff->buffsize + slen;  /* limited to MAX_SIZE/2 */\n      char *newb =\n        (buff->b == buff->space)  /* still using static space? */\n        ? luaM_reallocvector(buff->L, NULL, 0, newsize, char)\n        : luaM_reallocvector(buff->L, buff->b, buff->buffsize, newsize,\n                                                               char);\n      if (newb == NULL) {  /* allocation error? */\n        buff->err = 1;  /* signal a memory error */\n        return;\n      }\n      if (buff->b == buff->space)  /* new buffer (not reallocated)? */\n        memcpy(newb, buff->b, buff->blen);  /* copy previous content */\n      buff->b = newb;  /* set new (larger) buffer... */\n      buff->buffsize = newsize;  /* ...and its new size */\n    }\n  }\n  memcpy(buff->b + buff->blen, str, slen);  /* copy new content */\n  buff->blen += slen;\n}\n\n\n/*\n** Add a numeral to the buffer.\n*/\nstatic void addnum2buff (BuffFS *buff, TValue *num) {\n  char numbuff[LUA_N2SBUFFSZ];\n  unsigned len = luaO_tostringbuff(num, numbuff);\n  addstr2buff(buff, numbuff, len);\n}\n\n\n/*\n** this function handles only '%d', '%c', '%f', '%p', '%s', and '%%'\n   conventional formats, plus Lua-specific '%I' and '%U'\n*/\nconst char *luaO_pushvfstring (lua_State *L, const char *fmt, va_list argp) {\n  BuffFS buff;  /* holds last part of the result */\n  const char *e;  /* points to next '%' */\n  initbuff(L, &buff);\n  while ((e = strchr(fmt, '%')) != NULL) {\n    addstr2buff(&buff, fmt, ct_diff2sz(e - fmt));  /* add 'fmt' up to '%' */\n    switch (*(e + 1)) {  /* conversion specifier */\n      case 's': {  /* zero-terminated string */\n        const char *s = va_arg(argp, char *);\n        if (s == NULL) s = \"(null)\";\n        addstr2buff(&buff, s, strlen(s));\n        break;\n      }\n      case 'c': {  /* an 'int' as a character */\n        char c = cast_char(va_arg(argp, int));\n        addstr2buff(&buff, &c, sizeof(char));\n        break;\n      }\n      case 'd': {  /* an 'int' */\n        TValue num;\n        setivalue(&num, va_arg(argp, int));\n        addnum2buff(&buff, &num);\n        break;\n      }\n      case 'I': {  /* a 'lua_Integer' */\n        TValue num;\n        setivalue(&num, cast(lua_Integer, va_arg(argp, l_uacInt)));\n        addnum2buff(&buff, &num);\n        break;\n      }\n      case 'f': {  /* a 'lua_Number' */\n        TValue num;\n        setfltvalue(&num, cast_num(va_arg(argp, l_uacNumber)));\n        addnum2buff(&buff, &num);\n        break;\n      }\n      case 'p': {  /* a pointer */\n        char bf[LUA_N2SBUFFSZ];  /* enough space for '%p' */\n        void *p = va_arg(argp, void *);\n        int len = lua_pointer2str(bf, LUA_N2SBUFFSZ, p);\n        addstr2buff(&buff, bf, cast_uint(len));\n        break;\n      }\n      case 'U': {  /* an 'unsigned long' as a UTF-8 sequence */\n        char bf[UTF8BUFFSZ];\n        int len = luaO_utf8esc(bf, va_arg(argp, unsigned long));\n        addstr2buff(&buff, bf + UTF8BUFFSZ - len, cast_uint(len));\n        break;\n      }\n      case '%': {\n        addstr2buff(&buff, \"%\", 1);\n        break;\n      }\n      default: {\n        addstr2buff(&buff, e, 2);  /* keep unknown format in the result */\n        break;\n      }\n    }\n    fmt = e + 2;  /* skip '%' and the specifier */\n  }\n  addstr2buff(&buff, fmt, strlen(fmt));  /* rest of 'fmt' */\n  return clearbuff(&buff);  /* empty buffer into a new string */\n}\n\n\nconst char *luaO_pushfstring (lua_State *L, const char *fmt, ...) {\n  const char *msg;\n  va_list argp;\n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);\n  va_end(argp);\n  if (msg == NULL)  /* error? */\n    luaD_throw(L, LUA_ERRMEM);\n  return msg;\n}\n\n/* }================================================================== */\n\n\n#define RETS\t\"...\"\n#define PRE\t\"[string \\\"\"\n#define POS\t\"\\\"]\"\n\n#define addstr(a,b,l)\t( memcpy(a,b,(l) * sizeof(char)), a += (l) )\n\nvoid luaO_chunkid (char *out, const char *source, size_t srclen) {\n  size_t bufflen = LUA_IDSIZE;  /* free space in buffer */\n  if (*source == '=') {  /* 'literal' source */\n    if (srclen <= bufflen)  /* small enough? */\n      memcpy(out, source + 1, srclen * sizeof(char));\n    else {  /* truncate it */\n      addstr(out, source + 1, bufflen - 1);\n      *out = '\\0';\n    }\n  }\n  else if (*source == '@') {  /* file name */\n    if (srclen <= bufflen)  /* small enough? */\n      memcpy(out, source + 1, srclen * sizeof(char));\n    else {  /* add '...' before rest of name */\n      addstr(out, RETS, LL(RETS));\n      bufflen -= LL(RETS);\n      memcpy(out, source + 1 + srclen - bufflen, bufflen * sizeof(char));\n    }\n  }\n  else {  /* string; format as [string \"source\"] */\n    const char *nl = strchr(source, '\\n');  /* find first new line (if any) */\n    addstr(out, PRE, LL(PRE));  /* add prefix */\n    bufflen -= LL(PRE RETS POS) + 1;  /* save space for prefix+suffix+'\\0' */\n    if (srclen < bufflen && nl == NULL) {  /* small one-line source? */\n      addstr(out, source, srclen);  /* keep it */\n    }\n    else {\n      if (nl != NULL)\n        srclen = ct_diff2sz(nl - source);  /* stop at first newline */\n      if (srclen > bufflen) srclen = bufflen;\n      addstr(out, source, srclen);\n      addstr(out, RETS, LL(RETS));\n    }\n    memcpy(out, POS, (LL(POS) + 1) * sizeof(char));\n  }\n}\n\n"
        },
        {
          "name": "lobject.h",
          "type": "blob",
          "size": 23.2255859375,
          "content": "/*\n** $Id: lobject.h $\n** Type definitions for Lua objects\n** See Copyright Notice in lua.h\n*/\n\n\n#ifndef lobject_h\n#define lobject_h\n\n\n#include <stdarg.h>\n\n\n#include \"llimits.h\"\n#include \"lua.h\"\n\n\n/*\n** Extra types for collectable non-values\n*/\n#define LUA_TUPVAL\tLUA_NUMTYPES  /* upvalues */\n#define LUA_TPROTO\t(LUA_NUMTYPES+1)  /* function prototypes */\n#define LUA_TDEADKEY\t(LUA_NUMTYPES+2)  /* removed keys in tables */\n\n\n\n/*\n** number of all possible types (including LUA_TNONE but excluding DEADKEY)\n*/\n#define LUA_TOTALTYPES\t\t(LUA_TPROTO + 2)\n\n\n/*\n** tags for Tagged Values have the following use of bits:\n** bits 0-3: actual tag (a LUA_T* constant)\n** bits 4-5: variant bits\n** bit 6: whether value is collectable\n*/\n\n/* add variant bits to a type */\n#define makevariant(t,v)\t((t) | ((v) << 4))\n\n\n\n/*\n** Union of all Lua values\n*/\ntypedef union Value {\n  struct GCObject *gc;    /* collectable objects */\n  void *p;         /* light userdata */\n  lua_CFunction f; /* light C functions */\n  lua_Integer i;   /* integer numbers */\n  lua_Number n;    /* float numbers */\n  /* not used, but may avoid warnings for uninitialized value */\n  lu_byte ub;\n} Value;\n\n\n/*\n** Tagged Values. This is the basic representation of values in Lua:\n** an actual value plus a tag with its type.\n*/\n\n#define TValuefields\tValue value_; lu_byte tt_\n\ntypedef struct TValue {\n  TValuefields;\n} TValue;\n\n\n#define val_(o)\t\t((o)->value_)\n#define valraw(o)\t(val_(o))\n\n\n/* raw type tag of a TValue */\n#define rawtt(o)\t((o)->tt_)\n\n/* tag with no variants (bits 0-3) */\n#define novariant(t)\t((t) & 0x0F)\n\n/* type tag of a TValue (bits 0-3 for tags + variant bits 4-5) */\n#define withvariant(t)\t((t) & 0x3F)\n#define ttypetag(o)\twithvariant(rawtt(o))\n\n/* type of a TValue */\n#define ttype(o)\t(novariant(rawtt(o)))\n\n\n/* Macros to test type */\n#define checktag(o,t)\t\t(rawtt(o) == (t))\n#define checktype(o,t)\t\t(ttype(o) == (t))\n\n\n/* Macros for internal tests */\n\n/* collectable object has the same tag as the original value */\n#define righttt(obj)\t\t(ttypetag(obj) == gcvalue(obj)->tt)\n\n/*\n** Any value being manipulated by the program either is non\n** collectable, or the collectable object has the right tag\n** and it is not dead. The option 'L == NULL' allows other\n** macros using this one to be used where L is not available.\n*/\n#define checkliveness(L,obj) \\\n\t((void)L, lua_longassert(!iscollectable(obj) || \\\n\t\t(righttt(obj) && (L == NULL || !isdead(G(L),gcvalue(obj))))))\n\n\n/* Macros to set values */\n\n/* set a value's tag */\n#define settt_(o,t)\t((o)->tt_=(t))\n\n\n/* main macro to copy values (from 'obj2' to 'obj1') */\n#define setobj(L,obj1,obj2) \\\n\t{ TValue *io1=(obj1); const TValue *io2=(obj2); \\\n          io1->value_ = io2->value_; settt_(io1, io2->tt_); \\\n\t  checkliveness(L,io1); lua_assert(!isnonstrictnil(io1)); }\n\n/*\n** Different types of assignments, according to source and destination.\n** (They are mostly equal now, but may be different in the future.)\n*/\n\n/* from stack to stack */\n#define setobjs2s(L,o1,o2)\tsetobj(L,s2v(o1),s2v(o2))\n/* to stack (not from same stack) */\n#define setobj2s(L,o1,o2)\tsetobj(L,s2v(o1),o2)\n/* from table to same table */\n#define setobjt2t\tsetobj\n/* to new object */\n#define setobj2n\tsetobj\n/* to table */\n#define setobj2t\tsetobj\n\n\n/*\n** Entries in a Lua stack. Field 'tbclist' forms a list of all\n** to-be-closed variables active in this stack. Dummy entries are\n** used when the distance between two tbc variables does not fit\n** in an unsigned short. They are represented by delta==0, and\n** their real delta is always the maximum value that fits in\n** that field.\n*/\ntypedef union StackValue {\n  TValue val;\n  struct {\n    TValuefields;\n    unsigned short delta;\n  } tbclist;\n} StackValue;\n\n\n/* index to stack elements */\ntypedef StackValue *StkId;\n\n\n/*\n** When reallocating the stack, change all pointers to the stack into\n** proper offsets.\n*/\ntypedef union {\n  StkId p;  /* actual pointer */\n  ptrdiff_t offset;  /* used while the stack is being reallocated */\n} StkIdRel;\n\n\n/* convert a 'StackValue' to a 'TValue' */\n#define s2v(o)\t(&(o)->val)\n\n\n\n/*\n** {==================================================================\n** Nil\n** ===================================================================\n*/\n\n/* Standard nil */\n#define LUA_VNIL\tmakevariant(LUA_TNIL, 0)\n\n/* Empty slot (which might be different from a slot containing nil) */\n#define LUA_VEMPTY\tmakevariant(LUA_TNIL, 1)\n\n/* Value returned for a key not found in a table (absent key) */\n#define LUA_VABSTKEY\tmakevariant(LUA_TNIL, 2)\n\n/* Special variant to signal that a fast get is accessing a non-table */\n#define LUA_VNOTABLE    makevariant(LUA_TNIL, 3)\n\n\n/* macro to test for (any kind of) nil */\n#define ttisnil(v)\t\tchecktype((v), LUA_TNIL)\n\n/*\n** Macro to test the result of a table access. Formally, it should\n** distinguish between LUA_VEMPTY/LUA_VABSTKEY/LUA_VNOTABLE and\n** other tags. As currently nil is equivalent to LUA_VEMPTY, it is\n** simpler to just test whether the value is nil.\n*/\n#define tagisempty(tag)\t\t(novariant(tag) == LUA_TNIL)\n\n\n/* macro to test for a standard nil */\n#define ttisstrictnil(o)\tchecktag((o), LUA_VNIL)\n\n\n#define setnilvalue(obj) settt_(obj, LUA_VNIL)\n\n\n#define isabstkey(v)\t\tchecktag((v), LUA_VABSTKEY)\n\n\n/*\n** macro to detect non-standard nils (used only in assertions)\n*/\n#define isnonstrictnil(v)\t(ttisnil(v) && !ttisstrictnil(v))\n\n\n/*\n** By default, entries with any kind of nil are considered empty.\n** (In any definition, values associated with absent keys must also\n** be accepted as empty.)\n*/\n#define isempty(v)\t\tttisnil(v)\n\n\n/* macro defining a value corresponding to an absent key */\n#define ABSTKEYCONSTANT\t\t{NULL}, LUA_VABSTKEY\n\n\n/* mark an entry as empty */\n#define setempty(v)\t\tsettt_(v, LUA_VEMPTY)\n\n\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Booleans\n** ===================================================================\n*/\n\n\n#define LUA_VFALSE\tmakevariant(LUA_TBOOLEAN, 0)\n#define LUA_VTRUE\tmakevariant(LUA_TBOOLEAN, 1)\n\n#define ttisboolean(o)\t\tchecktype((o), LUA_TBOOLEAN)\n#define ttisfalse(o)\t\tchecktag((o), LUA_VFALSE)\n#define ttistrue(o)\t\tchecktag((o), LUA_VTRUE)\n\n\n#define l_isfalse(o)\t(ttisfalse(o) || ttisnil(o))\n#define tagisfalse(t)\t((t) == LUA_VFALSE || novariant(t) == LUA_TNIL)\n\n\n\n#define setbfvalue(obj)\t\tsettt_(obj, LUA_VFALSE)\n#define setbtvalue(obj)\t\tsettt_(obj, LUA_VTRUE)\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Threads\n** ===================================================================\n*/\n\n#define LUA_VTHREAD\t\tmakevariant(LUA_TTHREAD, 0)\n\n#define ttisthread(o)\t\tchecktag((o), ctb(LUA_VTHREAD))\n\n#define thvalue(o)\tcheck_exp(ttisthread(o), gco2th(val_(o).gc))\n\n#define setthvalue(L,obj,x) \\\n  { TValue *io = (obj); lua_State *x_ = (x); \\\n    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_VTHREAD)); \\\n    checkliveness(L,io); }\n\n#define setthvalue2s(L,o,t)\tsetthvalue(L,s2v(o),t)\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Collectable Objects\n** ===================================================================\n*/\n\n/*\n** Common Header for all collectable objects (in macro form, to be\n** included in other objects)\n*/\n#define CommonHeader\tstruct GCObject *next; lu_byte tt; lu_byte marked\n\n\n/* Common type for all collectable objects */\ntypedef struct GCObject {\n  CommonHeader;\n} GCObject;\n\n\n/* Bit mark for collectable types */\n#define BIT_ISCOLLECTABLE\t(1 << 6)\n\n#define iscollectable(o)\t(rawtt(o) & BIT_ISCOLLECTABLE)\n\n/* mark a tag as collectable */\n#define ctb(t)\t\t\t((t) | BIT_ISCOLLECTABLE)\n\n#define gcvalue(o)\tcheck_exp(iscollectable(o), val_(o).gc)\n\n#define gcvalueraw(v)\t((v).gc)\n\n#define setgcovalue(L,obj,x) \\\n  { TValue *io = (obj); GCObject *i_g=(x); \\\n    val_(io).gc = i_g; settt_(io, ctb(i_g->tt)); }\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Numbers\n** ===================================================================\n*/\n\n/* Variant tags for numbers */\n#define LUA_VNUMINT\tmakevariant(LUA_TNUMBER, 0)  /* integer numbers */\n#define LUA_VNUMFLT\tmakevariant(LUA_TNUMBER, 1)  /* float numbers */\n\n#define ttisnumber(o)\t\tchecktype((o), LUA_TNUMBER)\n#define ttisfloat(o)\t\tchecktag((o), LUA_VNUMFLT)\n#define ttisinteger(o)\t\tchecktag((o), LUA_VNUMINT)\n\n#define nvalue(o)\tcheck_exp(ttisnumber(o), \\\n\t(ttisinteger(o) ? cast_num(ivalue(o)) : fltvalue(o)))\n#define fltvalue(o)\tcheck_exp(ttisfloat(o), val_(o).n)\n#define ivalue(o)\tcheck_exp(ttisinteger(o), val_(o).i)\n\n#define fltvalueraw(v)\t((v).n)\n#define ivalueraw(v)\t((v).i)\n\n#define setfltvalue(obj,x) \\\n  { TValue *io=(obj); val_(io).n=(x); settt_(io, LUA_VNUMFLT); }\n\n#define chgfltvalue(obj,x) \\\n  { TValue *io=(obj); lua_assert(ttisfloat(io)); val_(io).n=(x); }\n\n#define setivalue(obj,x) \\\n  { TValue *io=(obj); val_(io).i=(x); settt_(io, LUA_VNUMINT); }\n\n#define chgivalue(obj,x) \\\n  { TValue *io=(obj); lua_assert(ttisinteger(io)); val_(io).i=(x); }\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Strings\n** ===================================================================\n*/\n\n/* Variant tags for strings */\n#define LUA_VSHRSTR\tmakevariant(LUA_TSTRING, 0)  /* short strings */\n#define LUA_VLNGSTR\tmakevariant(LUA_TSTRING, 1)  /* long strings */\n\n#define ttisstring(o)\t\tchecktype((o), LUA_TSTRING)\n#define ttisshrstring(o)\tchecktag((o), ctb(LUA_VSHRSTR))\n#define ttislngstring(o)\tchecktag((o), ctb(LUA_VLNGSTR))\n\n#define tsvalueraw(v)\t(gco2ts((v).gc))\n\n#define tsvalue(o)\tcheck_exp(ttisstring(o), gco2ts(val_(o).gc))\n\n#define setsvalue(L,obj,x) \\\n  { TValue *io = (obj); TString *x_ = (x); \\\n    val_(io).gc = obj2gco(x_); settt_(io, ctb(x_->tt)); \\\n    checkliveness(L,io); }\n\n/* set a string to the stack */\n#define setsvalue2s(L,o,s)\tsetsvalue(L,s2v(o),s)\n\n/* set a string to a new object */\n#define setsvalue2n\tsetsvalue\n\n\n/* Kinds of long strings (stored in 'shrlen') */\n#define LSTRREG\t\t-1  /* regular long string */\n#define LSTRFIX\t\t-2  /* fixed external long string */\n#define LSTRMEM\t\t-3  /* external long string with deallocation */\n\n\n/*\n** Header for a string value.\n*/\ntypedef struct TString {\n  CommonHeader;\n  lu_byte extra;  /* reserved words for short strings; \"has hash\" for longs */\n  ls_byte shrlen;  /* length for short strings, negative for long strings */\n  unsigned int hash;\n  union {\n    size_t lnglen;  /* length for long strings */\n    struct TString *hnext;  /* linked list for hash table */\n  } u;\n  char *contents;  /* pointer to content in long strings */\n  lua_Alloc falloc;  /* deallocation function for external strings */\n  void *ud;  /* user data for external strings */\n} TString;\n\n\n#define strisshr(ts)\t((ts)->shrlen >= 0)\n\n\n/*\n** Get the actual string (array of bytes) from a 'TString'. (Generic\n** version and specialized versions for long and short strings.)\n*/\n#define rawgetshrstr(ts)  (cast_charp(&(ts)->contents))\n#define getshrstr(ts)\tcheck_exp(strisshr(ts), rawgetshrstr(ts))\n#define getlngstr(ts)\tcheck_exp(!strisshr(ts), (ts)->contents)\n#define getstr(ts) \t(strisshr(ts) ? rawgetshrstr(ts) : (ts)->contents)\n\n\n/* get string length from 'TString *ts' */\n#define tsslen(ts)  \\\n\t(strisshr(ts) ? cast_sizet((ts)->shrlen) : (ts)->u.lnglen)\n\n/*\n** Get string and length */\n#define getlstr(ts, len)  \\\n\t(strisshr(ts) \\\n\t? (cast_void((len) = cast_sizet((ts)->shrlen)), rawgetshrstr(ts)) \\\n\t: (cast_void((len) = (ts)->u.lnglen), (ts)->contents))\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Userdata\n** ===================================================================\n*/\n\n\n/*\n** Light userdata should be a variant of userdata, but for compatibility\n** reasons they are also different types.\n*/\n#define LUA_VLIGHTUSERDATA\tmakevariant(LUA_TLIGHTUSERDATA, 0)\n\n#define LUA_VUSERDATA\t\tmakevariant(LUA_TUSERDATA, 0)\n\n#define ttislightuserdata(o)\tchecktag((o), LUA_VLIGHTUSERDATA)\n#define ttisfulluserdata(o)\tchecktag((o), ctb(LUA_VUSERDATA))\n\n#define pvalue(o)\tcheck_exp(ttislightuserdata(o), val_(o).p)\n#define uvalue(o)\tcheck_exp(ttisfulluserdata(o), gco2u(val_(o).gc))\n\n#define pvalueraw(v)\t((v).p)\n\n#define setpvalue(obj,x) \\\n  { TValue *io=(obj); val_(io).p=(x); settt_(io, LUA_VLIGHTUSERDATA); }\n\n#define setuvalue(L,obj,x) \\\n  { TValue *io = (obj); Udata *x_ = (x); \\\n    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_VUSERDATA)); \\\n    checkliveness(L,io); }\n\n\n/* Ensures that addresses after this type are always fully aligned. */\ntypedef union UValue {\n  TValue uv;\n  LUAI_MAXALIGN;  /* ensures maximum alignment for udata bytes */\n} UValue;\n\n\n/*\n** Header for userdata with user values;\n** memory area follows the end of this structure.\n*/\ntypedef struct Udata {\n  CommonHeader;\n  unsigned short nuvalue;  /* number of user values */\n  size_t len;  /* number of bytes */\n  struct Table *metatable;\n  GCObject *gclist;\n  UValue uv[1];  /* user values */\n} Udata;\n\n\n/*\n** Header for userdata with no user values. These userdata do not need\n** to be gray during GC, and therefore do not need a 'gclist' field.\n** To simplify, the code always use 'Udata' for both kinds of userdata,\n** making sure it never accesses 'gclist' on userdata with no user values.\n** This structure here is used only to compute the correct size for\n** this representation. (The 'bindata' field in its end ensures correct\n** alignment for binary data following this header.)\n*/\ntypedef struct Udata0 {\n  CommonHeader;\n  unsigned short nuvalue;  /* number of user values */\n  size_t len;  /* number of bytes */\n  struct Table *metatable;\n  union {LUAI_MAXALIGN;} bindata;\n} Udata0;\n\n\n/* compute the offset of the memory area of a userdata */\n#define udatamemoffset(nuv) \\\n       ((nuv) == 0 ? offsetof(Udata0, bindata)  \\\n\t\t   : offsetof(Udata, uv) + (sizeof(UValue) * (nuv)))\n\n/* get the address of the memory block inside 'Udata' */\n#define getudatamem(u)\t(cast_charp(u) + udatamemoffset((u)->nuvalue))\n\n/* compute the size of a userdata */\n#define sizeudata(nuv,nb)\t(udatamemoffset(nuv) + (nb))\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Prototypes\n** ===================================================================\n*/\n\n#define LUA_VPROTO\tmakevariant(LUA_TPROTO, 0)\n\n\ntypedef l_uint32 Instruction;\n\n\n/*\n** Description of an upvalue for function prototypes\n*/\ntypedef struct Upvaldesc {\n  TString *name;  /* upvalue name (for debug information) */\n  lu_byte instack;  /* whether it is in stack (register) */\n  lu_byte idx;  /* index of upvalue (in stack or in outer function's list) */\n  lu_byte kind;  /* kind of corresponding variable */\n} Upvaldesc;\n\n\n/*\n** Description of a local variable for function prototypes\n** (used for debug information)\n*/\ntypedef struct LocVar {\n  TString *varname;\n  int startpc;  /* first point where variable is active */\n  int endpc;    /* first point where variable is dead */\n} LocVar;\n\n\n/*\n** Associates the absolute line source for a given instruction ('pc').\n** The array 'lineinfo' gives, for each instruction, the difference in\n** lines from the previous instruction. When that difference does not\n** fit into a byte, Lua saves the absolute line for that instruction.\n** (Lua also saves the absolute line periodically, to speed up the\n** computation of a line number: we can use binary search in the\n** absolute-line array, but we must traverse the 'lineinfo' array\n** linearly to compute a line.)\n*/\ntypedef struct AbsLineInfo {\n  int pc;\n  int line;\n} AbsLineInfo;\n\n\n/*\n** Flags in Prototypes\n*/\n#define PF_ISVARARG\t1\n#define PF_FIXED\t2  /* prototype has parts in fixed memory */\n\n\n/*\n** Function Prototypes\n*/\ntypedef struct Proto {\n  CommonHeader;\n  lu_byte numparams;  /* number of fixed (named) parameters */\n  lu_byte flag;\n  lu_byte maxstacksize;  /* number of registers needed by this function */\n  int sizeupvalues;  /* size of 'upvalues' */\n  int sizek;  /* size of 'k' */\n  int sizecode;\n  int sizelineinfo;\n  int sizep;  /* size of 'p' */\n  int sizelocvars;\n  int sizeabslineinfo;  /* size of 'abslineinfo' */\n  int linedefined;  /* debug information  */\n  int lastlinedefined;  /* debug information  */\n  TValue *k;  /* constants used by the function */\n  Instruction *code;  /* opcodes */\n  struct Proto **p;  /* functions defined inside the function */\n  Upvaldesc *upvalues;  /* upvalue information */\n  ls_byte *lineinfo;  /* information about source lines (debug information) */\n  AbsLineInfo *abslineinfo;  /* idem */\n  LocVar *locvars;  /* information about local variables (debug information) */\n  TString  *source;  /* used for debug information */\n  GCObject *gclist;\n} Proto;\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Functions\n** ===================================================================\n*/\n\n#define LUA_VUPVAL\tmakevariant(LUA_TUPVAL, 0)\n\n\n/* Variant tags for functions */\n#define LUA_VLCL\tmakevariant(LUA_TFUNCTION, 0)  /* Lua closure */\n#define LUA_VLCF\tmakevariant(LUA_TFUNCTION, 1)  /* light C function */\n#define LUA_VCCL\tmakevariant(LUA_TFUNCTION, 2)  /* C closure */\n\n#define ttisfunction(o)\t\tchecktype(o, LUA_TFUNCTION)\n#define ttisLclosure(o)\t\tchecktag((o), ctb(LUA_VLCL))\n#define ttislcf(o)\t\tchecktag((o), LUA_VLCF)\n#define ttisCclosure(o)\t\tchecktag((o), ctb(LUA_VCCL))\n#define ttisclosure(o)         (ttisLclosure(o) || ttisCclosure(o))\n\n\n#define isLfunction(o)\tttisLclosure(o)\n\n#define clvalue(o)\tcheck_exp(ttisclosure(o), gco2cl(val_(o).gc))\n#define clLvalue(o)\tcheck_exp(ttisLclosure(o), gco2lcl(val_(o).gc))\n#define fvalue(o)\tcheck_exp(ttislcf(o), val_(o).f)\n#define clCvalue(o)\tcheck_exp(ttisCclosure(o), gco2ccl(val_(o).gc))\n\n#define fvalueraw(v)\t((v).f)\n\n#define setclLvalue(L,obj,x) \\\n  { TValue *io = (obj); LClosure *x_ = (x); \\\n    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_VLCL)); \\\n    checkliveness(L,io); }\n\n#define setclLvalue2s(L,o,cl)\tsetclLvalue(L,s2v(o),cl)\n\n#define setfvalue(obj,x) \\\n  { TValue *io=(obj); val_(io).f=(x); settt_(io, LUA_VLCF); }\n\n#define setclCvalue(L,obj,x) \\\n  { TValue *io = (obj); CClosure *x_ = (x); \\\n    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_VCCL)); \\\n    checkliveness(L,io); }\n\n\n/*\n** Upvalues for Lua closures\n*/\ntypedef struct UpVal {\n  CommonHeader;\n  union {\n    TValue *p;  /* points to stack or to its own value */\n    ptrdiff_t offset;  /* used while the stack is being reallocated */\n  } v;\n  union {\n    struct {  /* (when open) */\n      struct UpVal *next;  /* linked list */\n      struct UpVal **previous;\n    } open;\n    TValue value;  /* the value (when closed) */\n  } u;\n} UpVal;\n\n\n\n#define ClosureHeader \\\n\tCommonHeader; lu_byte nupvalues; GCObject *gclist\n\ntypedef struct CClosure {\n  ClosureHeader;\n  lua_CFunction f;\n  TValue upvalue[1];  /* list of upvalues */\n} CClosure;\n\n\ntypedef struct LClosure {\n  ClosureHeader;\n  struct Proto *p;\n  UpVal *upvals[1];  /* list of upvalues */\n} LClosure;\n\n\ntypedef union Closure {\n  CClosure c;\n  LClosure l;\n} Closure;\n\n\n#define getproto(o)\t(clLvalue(o)->p)\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Tables\n** ===================================================================\n*/\n\n#define LUA_VTABLE\tmakevariant(LUA_TTABLE, 0)\n\n#define ttistable(o)\t\tchecktag((o), ctb(LUA_VTABLE))\n\n#define hvalue(o)\tcheck_exp(ttistable(o), gco2t(val_(o).gc))\n\n#define sethvalue(L,obj,x) \\\n  { TValue *io = (obj); Table *x_ = (x); \\\n    val_(io).gc = obj2gco(x_); settt_(io, ctb(LUA_VTABLE)); \\\n    checkliveness(L,io); }\n\n#define sethvalue2s(L,o,h)\tsethvalue(L,s2v(o),h)\n\n\n/*\n** Nodes for Hash tables: A pack of two TValue's (key-value pairs)\n** plus a 'next' field to link colliding entries. The distribution\n** of the key's fields ('key_tt' and 'key_val') not forming a proper\n** 'TValue' allows for a smaller size for 'Node' both in 4-byte\n** and 8-byte alignments.\n*/\ntypedef union Node {\n  struct NodeKey {\n    TValuefields;  /* fields for value */\n    lu_byte key_tt;  /* key type */\n    int next;  /* for chaining */\n    Value key_val;  /* key value */\n  } u;\n  TValue i_val;  /* direct access to node's value as a proper 'TValue' */\n} Node;\n\n\n/* copy a value into a key */\n#define setnodekey(node,obj) \\\n\t{ Node *n_=(node); const TValue *io_=(obj); \\\n\t  n_->u.key_val = io_->value_; n_->u.key_tt = io_->tt_; }\n\n\n/* copy a value from a key */\n#define getnodekey(L,obj,node) \\\n\t{ TValue *io_=(obj); const Node *n_=(node); \\\n\t  io_->value_ = n_->u.key_val; io_->tt_ = n_->u.key_tt; \\\n\t  checkliveness(L,io_); }\n\n\n\ntypedef struct Table {\n  CommonHeader;\n  lu_byte flags;  /* 1<<p means tagmethod(p) is not present */\n  lu_byte lsizenode;  /* log2 of number of slots of 'node' array */\n  unsigned int asize;  /* number of slots in 'array' array */\n  Value *array;  /* array part */\n  Node *node;\n  struct Table *metatable;\n  GCObject *gclist;\n} Table;\n\n\n/*\n** Macros to manipulate keys inserted in nodes\n*/\n#define keytt(node)\t\t((node)->u.key_tt)\n#define keyval(node)\t\t((node)->u.key_val)\n\n#define keyisnil(node)\t\t(keytt(node) == LUA_TNIL)\n#define keyisinteger(node)\t(keytt(node) == LUA_VNUMINT)\n#define keyival(node)\t\t(keyval(node).i)\n#define keyisshrstr(node)\t(keytt(node) == ctb(LUA_VSHRSTR))\n#define keystrval(node)\t\t(gco2ts(keyval(node).gc))\n\n#define setnilkey(node)\t\t(keytt(node) = LUA_TNIL)\n\n#define keyiscollectable(n)\t(keytt(n) & BIT_ISCOLLECTABLE)\n\n#define gckey(n)\t(keyval(n).gc)\n#define gckeyN(n)\t(keyiscollectable(n) ? gckey(n) : NULL)\n\n\n/*\n** Dead keys in tables have the tag DEADKEY but keep their original\n** gcvalue. This distinguishes them from regular keys but allows them to\n** be found when searched in a special way. ('next' needs that to find\n** keys removed from a table during a traversal.)\n*/\n#define setdeadkey(node)\t(keytt(node) = LUA_TDEADKEY)\n#define keyisdead(node)\t\t(keytt(node) == LUA_TDEADKEY)\n\n/* }================================================================== */\n\n\n\n/*\n** 'module' operation for hashing (size is always a power of 2)\n*/\n#define lmod(s,size) \\\n\t(check_exp((size&(size-1))==0, (cast_uint(s) & cast_uint((size)-1))))\n\n\n#define twoto(x)\t(1u<<(x))\n#define sizenode(t)\t(twoto((t)->lsizenode))\n\n\n/* size of buffer for 'luaO_utf8esc' function */\n#define UTF8BUFFSZ\t8\n\nLUAI_FUNC int luaO_utf8esc (char *buff, unsigned long x);\nLUAI_FUNC lu_byte luaO_ceillog2 (unsigned int x);\nLUAI_FUNC lu_byte luaO_codeparam (unsigned int p);\nLUAI_FUNC l_mem luaO_applyparam (lu_byte p, l_mem x);\n\nLUAI_FUNC int luaO_rawarith (lua_State *L, int op, const TValue *p1,\n                             const TValue *p2, TValue *res);\nLUAI_FUNC void luaO_arith (lua_State *L, int op, const TValue *p1,\n                           const TValue *p2, StkId res);\nLUAI_FUNC size_t luaO_str2num (const char *s, TValue *o);\nLUAI_FUNC unsigned luaO_tostringbuff (const TValue *obj, char *buff);\nLUAI_FUNC lu_byte luaO_hexavalue (int c);\nLUAI_FUNC void luaO_tostring (lua_State *L, TValue *obj);\nLUAI_FUNC const char *luaO_pushvfstring (lua_State *L, const char *fmt,\n                                                       va_list argp);\nLUAI_FUNC const char *luaO_pushfstring (lua_State *L, const char *fmt, ...);\nLUAI_FUNC void luaO_chunkid (char *out, const char *source, size_t srclen);\n\n\n#endif\n\n"
        },
        {
          "name": "lopcodes.c",
          "type": "blob",
          "size": 4.7705078125,
          "content": "/*\n** $Id: lopcodes.c $\n** Opcodes for Lua virtual machine\n** See Copyright Notice in lua.h\n*/\n\n#define lopcodes_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include \"lopcodes.h\"\n\n\n#define opmode(mm,ot,it,t,a,m)  \\\n    (((mm) << 7) | ((ot) << 6) | ((it) << 5) | ((t) << 4) | ((a) << 3) | (m))\n\n\n/* ORDER OP */\n\nLUAI_DDEF const lu_byte luaP_opmodes[NUM_OPCODES] = {\n/*       MM OT IT T  A  mode\t\t   opcode  */\n  opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_MOVE */\n ,opmode(0, 0, 0, 0, 1, iAsBx)\t\t/* OP_LOADI */\n ,opmode(0, 0, 0, 0, 1, iAsBx)\t\t/* OP_LOADF */\n ,opmode(0, 0, 0, 0, 1, iABx)\t\t/* OP_LOADK */\n ,opmode(0, 0, 0, 0, 1, iABx)\t\t/* OP_LOADKX */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_LOADFALSE */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_LFALSESKIP */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_LOADTRUE */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_LOADNIL */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_GETUPVAL */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_SETUPVAL */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_GETTABUP */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_GETTABLE */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_GETI */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_GETFIELD */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_SETTABUP */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_SETTABLE */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_SETI */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_SETFIELD */\n ,opmode(0, 0, 0, 0, 1, ivABC)\t\t/* OP_NEWTABLE */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_SELF */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_ADDI */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_ADDK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_SUBK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_MULK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_MODK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_POWK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_DIVK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_IDIVK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_BANDK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_BORK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_BXORK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_SHRI */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_SHLI */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_ADD */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_SUB */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_MUL */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_MOD */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_POW */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_DIV */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_IDIV */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_BAND */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_BOR */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_BXOR */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_SHL */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_SHR */\n ,opmode(1, 0, 0, 0, 0, iABC)\t\t/* OP_MMBIN */\n ,opmode(1, 0, 0, 0, 0, iABC)\t\t/* OP_MMBINI */\n ,opmode(1, 0, 0, 0, 0, iABC)\t\t/* OP_MMBINK */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_UNM */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_BNOT */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_NOT */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_LEN */\n ,opmode(0, 0, 0, 0, 1, iABC)\t\t/* OP_CONCAT */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_CLOSE */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_TBC */\n ,opmode(0, 0, 0, 0, 0, isJ)\t\t/* OP_JMP */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_EQ */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_LT */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_LE */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_EQK */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_EQI */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_LTI */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_LEI */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_GTI */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_GEI */\n ,opmode(0, 0, 0, 1, 0, iABC)\t\t/* OP_TEST */\n ,opmode(0, 0, 0, 1, 1, iABC)\t\t/* OP_TESTSET */\n ,opmode(0, 1, 1, 0, 1, iABC)\t\t/* OP_CALL */\n ,opmode(0, 1, 1, 0, 1, iABC)\t\t/* OP_TAILCALL */\n ,opmode(0, 0, 1, 0, 0, iABC)\t\t/* OP_RETURN */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_RETURN0 */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_RETURN1 */\n ,opmode(0, 0, 0, 0, 1, iABx)\t\t/* OP_FORLOOP */\n ,opmode(0, 0, 0, 0, 1, iABx)\t\t/* OP_FORPREP */\n ,opmode(0, 0, 0, 0, 0, iABx)\t\t/* OP_TFORPREP */\n ,opmode(0, 0, 0, 0, 0, iABC)\t\t/* OP_TFORCALL */\n ,opmode(0, 0, 0, 0, 1, iABx)\t\t/* OP_TFORLOOP */\n ,opmode(0, 0, 1, 0, 0, ivABC)\t\t/* OP_SETLIST */\n ,opmode(0, 0, 0, 0, 1, iABx)\t\t/* OP_CLOSURE */\n ,opmode(0, 1, 0, 0, 1, iABC)\t\t/* OP_VARARG */\n ,opmode(0, 0, 1, 0, 1, iABC)\t\t/* OP_VARARGPREP */\n ,opmode(0, 0, 0, 0, 0, iAx)\t\t/* OP_EXTRAARG */\n};\n\n\n\n/*\n** Check whether instruction sets top for next instruction, that is,\n** it results in multiple values.\n*/\nint luaP_isOT (Instruction i) {\n  OpCode op = GET_OPCODE(i);\n  switch (op) {\n    case OP_TAILCALL: return 1;\n    default:\n      return testOTMode(op) && GETARG_C(i) == 0;\n  }\n}\n\n\n/*\n** Check whether instruction uses top from previous instruction, that is,\n** it accepts multiple results.\n*/\nint luaP_isIT (Instruction i) {\n  OpCode op = GET_OPCODE(i);\n  switch (op) {\n    case OP_SETLIST:\n      return testITMode(GET_OPCODE(i)) && GETARG_vB(i) == 0;\n    default:\n      return testITMode(GET_OPCODE(i)) && GETARG_B(i) == 0;\n  }\n}\n\n"
        },
        {
          "name": "lopcodes.h",
          "type": "blob",
          "size": 13.6416015625,
          "content": "/*\n** $Id: lopcodes.h $\n** Opcodes for Lua virtual machine\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lopcodes_h\n#define lopcodes_h\n\n#include \"llimits.h\"\n#include \"lobject.h\"\n\n\n/*===========================================================================\n  We assume that instructions are unsigned 32-bit integers.\n  All instructions have an opcode in the first 7 bits.\n  Instructions can have the following formats:\n\n        3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0\n        1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0\niABC          C(8)     |      B(8)     |k|     A(8)      |   Op(7)     |\nivABC         vC(10)     |     vB(6)   |k|     A(8)      |   Op(7)     |\niABx                Bx(17)               |     A(8)      |   Op(7)     |\niAsBx              sBx (signed)(17)      |     A(8)      |   Op(7)     |\niAx                           Ax(25)                     |   Op(7)     |\nisJ                           sJ (signed)(25)            |   Op(7)     |\n\n  ('v' stands for \"variant\", 's' for \"signed\", 'x' for \"extended\".)\n  A signed argument is represented in excess K: The represented value is\n  the written unsigned value minus K, where K is half (rounded down) the\n  maximum value for the corresponding unsigned argument.\n===========================================================================*/\n\n\n/* basic instruction formats */\nenum OpMode {iABC, ivABC, iABx, iAsBx, iAx, isJ};\n\n\n/*\n** size and position of opcode arguments.\n*/\n#define SIZE_C\t\t8\n#define SIZE_vC\t\t10\n#define SIZE_B\t\t8\n#define SIZE_vB\t\t6\n#define SIZE_Bx\t\t(SIZE_C + SIZE_B + 1)\n#define SIZE_A\t\t8\n#define SIZE_Ax\t\t(SIZE_Bx + SIZE_A)\n#define SIZE_sJ\t\t(SIZE_Bx + SIZE_A)\n\n#define SIZE_OP\t\t7\n\n#define POS_OP\t\t0\n\n#define POS_A\t\t(POS_OP + SIZE_OP)\n#define POS_k\t\t(POS_A + SIZE_A)\n#define POS_B\t\t(POS_k + 1)\n#define POS_vB\t\t(POS_k + 1)\n#define POS_C\t\t(POS_B + SIZE_B)\n#define POS_vC\t\t(POS_vB + SIZE_vB)\n\n#define POS_Bx\t\tPOS_k\n\n#define POS_Ax\t\tPOS_A\n\n#define POS_sJ\t\tPOS_A\n\n\n/*\n** limits for opcode arguments.\n** we use (signed) 'int' to manipulate most arguments,\n** so they must fit in ints.\n*/\n\n/*\n** Check whether type 'int' has at least 'b' + 1 bits.\n** 'b' < 32; +1 for the sign bit.\n*/\n#define L_INTHASBITS(b)\t\t((UINT_MAX >> (b)) >= 1)\n\n\n#if L_INTHASBITS(SIZE_Bx)\n#define MAXARG_Bx\t((1<<SIZE_Bx)-1)\n#else\n#define MAXARG_Bx\tINT_MAX\n#endif\n\n#define OFFSET_sBx\t(MAXARG_Bx>>1)         /* 'sBx' is signed */\n\n\n#if L_INTHASBITS(SIZE_Ax)\n#define MAXARG_Ax\t((1<<SIZE_Ax)-1)\n#else\n#define MAXARG_Ax\tINT_MAX\n#endif\n\n#if L_INTHASBITS(SIZE_sJ)\n#define MAXARG_sJ\t((1 << SIZE_sJ) - 1)\n#else\n#define MAXARG_sJ\tINT_MAX\n#endif\n\n#define OFFSET_sJ\t(MAXARG_sJ >> 1)\n\n\n#define MAXARG_A\t((1<<SIZE_A)-1)\n#define MAXARG_B\t((1<<SIZE_B)-1)\n#define MAXARG_vB\t((1<<SIZE_vB)-1)\n#define MAXARG_C\t((1<<SIZE_C)-1)\n#define MAXARG_vC\t((1<<SIZE_vC)-1)\n#define OFFSET_sC\t(MAXARG_C >> 1)\n\n#define int2sC(i)\t((i) + OFFSET_sC)\n#define sC2int(i)\t((i) - OFFSET_sC)\n\n\n/* creates a mask with 'n' 1 bits at position 'p' */\n#define MASK1(n,p)\t((~((~(Instruction)0)<<(n)))<<(p))\n\n/* creates a mask with 'n' 0 bits at position 'p' */\n#define MASK0(n,p)\t(~MASK1(n,p))\n\n/*\n** the following macros help to manipulate instructions\n*/\n\n#define GET_OPCODE(i)\t(cast(OpCode, ((i)>>POS_OP) & MASK1(SIZE_OP,0)))\n#define SET_OPCODE(i,o)\t((i) = (((i)&MASK0(SIZE_OP,POS_OP)) | \\\n\t\t((cast(Instruction, o)<<POS_OP)&MASK1(SIZE_OP,POS_OP))))\n\n#define checkopm(i,m)\t(getOpMode(GET_OPCODE(i)) == m)\n\n\n#define getarg(i,pos,size)\t(cast_int(((i)>>(pos)) & MASK1(size,0)))\n#define setarg(i,v,pos,size)\t((i) = (((i)&MASK0(size,pos)) | \\\n                ((cast(Instruction, v)<<pos)&MASK1(size,pos))))\n\n#define GETARG_A(i)\tgetarg(i, POS_A, SIZE_A)\n#define SETARG_A(i,v)\tsetarg(i, v, POS_A, SIZE_A)\n\n#define GETARG_B(i)  \\\n\tcheck_exp(checkopm(i, iABC), getarg(i, POS_B, SIZE_B))\n#define GETARG_vB(i)  \\\n\tcheck_exp(checkopm(i, ivABC), getarg(i, POS_vB, SIZE_vB))\n#define GETARG_sB(i)\tsC2int(GETARG_B(i))\n#define SETARG_B(i,v)\tsetarg(i, v, POS_B, SIZE_B)\n#define SETARG_vB(i,v)\tsetarg(i, v, POS_vB, SIZE_vB)\n\n#define GETARG_C(i)  \\\n\tcheck_exp(checkopm(i, iABC), getarg(i, POS_C, SIZE_C))\n#define GETARG_vC(i)  \\\n\tcheck_exp(checkopm(i, ivABC), getarg(i, POS_vC, SIZE_vC))\n#define GETARG_sC(i)\tsC2int(GETARG_C(i))\n#define SETARG_C(i,v)\tsetarg(i, v, POS_C, SIZE_C)\n#define SETARG_vC(i,v)\tsetarg(i, v, POS_vC, SIZE_vC)\n\n#define TESTARG_k(i)\t(cast_int(((i) & (1u << POS_k))))\n#define GETARG_k(i)\tgetarg(i, POS_k, 1)\n#define SETARG_k(i,v)\tsetarg(i, v, POS_k, 1)\n\n#define GETARG_Bx(i)\tcheck_exp(checkopm(i, iABx), getarg(i, POS_Bx, SIZE_Bx))\n#define SETARG_Bx(i,v)\tsetarg(i, v, POS_Bx, SIZE_Bx)\n\n#define GETARG_Ax(i)\tcheck_exp(checkopm(i, iAx), getarg(i, POS_Ax, SIZE_Ax))\n#define SETARG_Ax(i,v)\tsetarg(i, v, POS_Ax, SIZE_Ax)\n\n#define GETARG_sBx(i)  \\\n\tcheck_exp(checkopm(i, iAsBx), getarg(i, POS_Bx, SIZE_Bx) - OFFSET_sBx)\n#define SETARG_sBx(i,b)\tSETARG_Bx((i),cast_uint((b)+OFFSET_sBx))\n\n#define GETARG_sJ(i)  \\\n\tcheck_exp(checkopm(i, isJ), getarg(i, POS_sJ, SIZE_sJ) - OFFSET_sJ)\n#define SETARG_sJ(i,j) \\\n\tsetarg(i, cast_uint((j)+OFFSET_sJ), POS_sJ, SIZE_sJ)\n\n\n#define CREATE_ABCk(o,a,b,c,k)\t((cast(Instruction, o)<<POS_OP) \\\n\t\t\t| (cast(Instruction, a)<<POS_A) \\\n\t\t\t| (cast(Instruction, b)<<POS_B) \\\n\t\t\t| (cast(Instruction, c)<<POS_C) \\\n\t\t\t| (cast(Instruction, k)<<POS_k))\n\n#define CREATE_vABCk(o,a,b,c,k)\t((cast(Instruction, o)<<POS_OP) \\\n\t\t\t| (cast(Instruction, a)<<POS_A) \\\n\t\t\t| (cast(Instruction, b)<<POS_vB) \\\n\t\t\t| (cast(Instruction, c)<<POS_vC) \\\n\t\t\t| (cast(Instruction, k)<<POS_k))\n\n#define CREATE_ABx(o,a,bc)\t((cast(Instruction, o)<<POS_OP) \\\n\t\t\t| (cast(Instruction, a)<<POS_A) \\\n\t\t\t| (cast(Instruction, bc)<<POS_Bx))\n\n#define CREATE_Ax(o,a)\t\t((cast(Instruction, o)<<POS_OP) \\\n\t\t\t| (cast(Instruction, a)<<POS_Ax))\n\n#define CREATE_sJ(o,j,k)\t((cast(Instruction, o) << POS_OP) \\\n\t\t\t| (cast(Instruction, j) << POS_sJ) \\\n\t\t\t| (cast(Instruction, k) << POS_k))\n\n\n#if !defined(MAXINDEXRK)  /* (for debugging only) */\n#define MAXINDEXRK\tMAXARG_B\n#endif\n\n\n/*\n** Maximum size for the stack of a Lua function. It must fit in 8 bits.\n** The highest valid register is one less than this value.\n*/\n#define MAX_FSTACK\tMAXARG_A\n\n/*\n** Invalid register (one more than last valid register).\n*/\n#define NO_REG\t\tMAX_FSTACK\n\n\n\n/*\n** R[x] - register\n** K[x] - constant (in constant table)\n** RK(x) == if k(i) then K[x] else R[x]\n*/\n\n\n/*\n** Grep \"ORDER OP\" if you change these enums. Opcodes marked with a (*)\n** has extra descriptions in the notes after the enumeration.\n*/\n\ntypedef enum {\n/*----------------------------------------------------------------------\n  name\t\targs\tdescription\n------------------------------------------------------------------------*/\nOP_MOVE,/*\tA B\tR[A] := R[B]\t\t\t\t\t*/\nOP_LOADI,/*\tA sBx\tR[A] := sBx\t\t\t\t\t*/\nOP_LOADF,/*\tA sBx\tR[A] := (lua_Number)sBx\t\t\t\t*/\nOP_LOADK,/*\tA Bx\tR[A] := K[Bx]\t\t\t\t\t*/\nOP_LOADKX,/*\tA\tR[A] := K[extra arg]\t\t\t\t*/\nOP_LOADFALSE,/*\tA\tR[A] := false\t\t\t\t\t*/\nOP_LFALSESKIP,/*A\tR[A] := false; pc++\t(*)\t\t\t*/\nOP_LOADTRUE,/*\tA\tR[A] := true\t\t\t\t\t*/\nOP_LOADNIL,/*\tA B\tR[A], R[A+1], ..., R[A+B] := nil\t\t*/\nOP_GETUPVAL,/*\tA B\tR[A] := UpValue[B]\t\t\t\t*/\nOP_SETUPVAL,/*\tA B\tUpValue[B] := R[A]\t\t\t\t*/\n\nOP_GETTABUP,/*\tA B C\tR[A] := UpValue[B][K[C]:shortstring]\t\t*/\nOP_GETTABLE,/*\tA B C\tR[A] := R[B][R[C]]\t\t\t\t*/\nOP_GETI,/*\tA B C\tR[A] := R[B][C]\t\t\t\t\t*/\nOP_GETFIELD,/*\tA B C\tR[A] := R[B][K[C]:shortstring]\t\t\t*/\n\nOP_SETTABUP,/*\tA B C\tUpValue[A][K[B]:shortstring] := RK(C)\t\t*/\nOP_SETTABLE,/*\tA B C\tR[A][R[B]] := RK(C)\t\t\t\t*/\nOP_SETI,/*\tA B C\tR[A][B] := RK(C)\t\t\t\t*/\nOP_SETFIELD,/*\tA B C\tR[A][K[B]:shortstring] := RK(C)\t\t\t*/\n\nOP_NEWTABLE,/*\tA B C k\tR[A] := {}\t\t\t\t\t*/\n\nOP_SELF,/*\tA B C\tR[A+1] := R[B]; R[A] := R[B][RK(C):string]\t*/\n\nOP_ADDI,/*\tA B sC\tR[A] := R[B] + sC\t\t\t\t*/\n\nOP_ADDK,/*\tA B C\tR[A] := R[B] + K[C]:number\t\t\t*/\nOP_SUBK,/*\tA B C\tR[A] := R[B] - K[C]:number\t\t\t*/\nOP_MULK,/*\tA B C\tR[A] := R[B] * K[C]:number\t\t\t*/\nOP_MODK,/*\tA B C\tR[A] := R[B] % K[C]:number\t\t\t*/\nOP_POWK,/*\tA B C\tR[A] := R[B] ^ K[C]:number\t\t\t*/\nOP_DIVK,/*\tA B C\tR[A] := R[B] / K[C]:number\t\t\t*/\nOP_IDIVK,/*\tA B C\tR[A] := R[B] // K[C]:number\t\t\t*/\n\nOP_BANDK,/*\tA B C\tR[A] := R[B] & K[C]:integer\t\t\t*/\nOP_BORK,/*\tA B C\tR[A] := R[B] | K[C]:integer\t\t\t*/\nOP_BXORK,/*\tA B C\tR[A] := R[B] ~ K[C]:integer\t\t\t*/\n\nOP_SHRI,/*\tA B sC\tR[A] := R[B] >> sC\t\t\t\t*/\nOP_SHLI,/*\tA B sC\tR[A] := sC << R[B]\t\t\t\t*/\n\nOP_ADD,/*\tA B C\tR[A] := R[B] + R[C]\t\t\t\t*/\nOP_SUB,/*\tA B C\tR[A] := R[B] - R[C]\t\t\t\t*/\nOP_MUL,/*\tA B C\tR[A] := R[B] * R[C]\t\t\t\t*/\nOP_MOD,/*\tA B C\tR[A] := R[B] % R[C]\t\t\t\t*/\nOP_POW,/*\tA B C\tR[A] := R[B] ^ R[C]\t\t\t\t*/\nOP_DIV,/*\tA B C\tR[A] := R[B] / R[C]\t\t\t\t*/\nOP_IDIV,/*\tA B C\tR[A] := R[B] // R[C]\t\t\t\t*/\n\nOP_BAND,/*\tA B C\tR[A] := R[B] & R[C]\t\t\t\t*/\nOP_BOR,/*\tA B C\tR[A] := R[B] | R[C]\t\t\t\t*/\nOP_BXOR,/*\tA B C\tR[A] := R[B] ~ R[C]\t\t\t\t*/\nOP_SHL,/*\tA B C\tR[A] := R[B] << R[C]\t\t\t\t*/\nOP_SHR,/*\tA B C\tR[A] := R[B] >> R[C]\t\t\t\t*/\n\nOP_MMBIN,/*\tA B C\tcall C metamethod over R[A] and R[B]\t(*)\t*/\nOP_MMBINI,/*\tA sB C k\tcall C metamethod over R[A] and sB\t*/\nOP_MMBINK,/*\tA B C k\t\tcall C metamethod over R[A] and K[B]\t*/\n\nOP_UNM,/*\tA B\tR[A] := -R[B]\t\t\t\t\t*/\nOP_BNOT,/*\tA B\tR[A] := ~R[B]\t\t\t\t\t*/\nOP_NOT,/*\tA B\tR[A] := not R[B]\t\t\t\t*/\nOP_LEN,/*\tA B\tR[A] := #R[B] (length operator)\t\t\t*/\n\nOP_CONCAT,/*\tA B\tR[A] := R[A].. ... ..R[A + B - 1]\t\t*/\n\nOP_CLOSE,/*\tA\tclose all upvalues >= R[A]\t\t\t*/\nOP_TBC,/*\tA\tmark variable A \"to be closed\"\t\t\t*/\nOP_JMP,/*\tsJ\tpc += sJ\t\t\t\t\t*/\nOP_EQ,/*\tA B k\tif ((R[A] == R[B]) ~= k) then pc++\t\t*/\nOP_LT,/*\tA B k\tif ((R[A] <  R[B]) ~= k) then pc++\t\t*/\nOP_LE,/*\tA B k\tif ((R[A] <= R[B]) ~= k) then pc++\t\t*/\n\nOP_EQK,/*\tA B k\tif ((R[A] == K[B]) ~= k) then pc++\t\t*/\nOP_EQI,/*\tA sB k\tif ((R[A] == sB) ~= k) then pc++\t\t*/\nOP_LTI,/*\tA sB k\tif ((R[A] < sB) ~= k) then pc++\t\t\t*/\nOP_LEI,/*\tA sB k\tif ((R[A] <= sB) ~= k) then pc++\t\t*/\nOP_GTI,/*\tA sB k\tif ((R[A] > sB) ~= k) then pc++\t\t\t*/\nOP_GEI,/*\tA sB k\tif ((R[A] >= sB) ~= k) then pc++\t\t*/\n\nOP_TEST,/*\tA k\tif (not R[A] == k) then pc++\t\t\t*/\nOP_TESTSET,/*\tA B k\tif (not R[B] == k) then pc++ else R[A] := R[B] (*) */\n\nOP_CALL,/*\tA B C\tR[A], ... ,R[A+C-2] := R[A](R[A+1], ... ,R[A+B-1]) */\nOP_TAILCALL,/*\tA B C k\treturn R[A](R[A+1], ... ,R[A+B-1])\t\t*/\n\nOP_RETURN,/*\tA B C k\treturn R[A], ... ,R[A+B-2]\t(see note)\t*/\nOP_RETURN0,/*\t\treturn\t\t\t\t\t\t*/\nOP_RETURN1,/*\tA\treturn R[A]\t\t\t\t\t*/\n\nOP_FORLOOP,/*\tA Bx\tupdate counters; if loop continues then pc-=Bx; */\nOP_FORPREP,/*\tA Bx\t<check values and prepare counters>;\n                        if not to run then pc+=Bx+1;\t\t\t*/\n\nOP_TFORPREP,/*\tA Bx\tcreate upvalue for R[A + 3]; pc+=Bx\t\t*/\nOP_TFORCALL,/*\tA C\tR[A+4], ... ,R[A+3+C] := R[A](R[A+1], R[A+2]);\t*/\nOP_TFORLOOP,/*\tA Bx\tif R[A+2] ~= nil then { R[A]=R[A+2]; pc -= Bx }\t*/\n\nOP_SETLIST,/*\tA vB vC k\tR[A][vC+i] := R[A+i], 1 <= i <= vB\t*/\n\nOP_CLOSURE,/*\tA Bx\tR[A] := closure(KPROTO[Bx])\t\t\t*/\n\nOP_VARARG,/*\tA C\tR[A], R[A+1], ..., R[A+C-2] = vararg\t\t*/\n\nOP_VARARGPREP,/*A\t(adjust vararg parameters)\t\t\t*/\n\nOP_EXTRAARG/*\tAx\textra (larger) argument for previous opcode\t*/\n} OpCode;\n\n\n#define NUM_OPCODES\t((int)(OP_EXTRAARG) + 1)\n\n\n\n/*===========================================================================\n  Notes:\n\n  (*) Opcode OP_LFALSESKIP is used to convert a condition to a boolean\n  value, in a code equivalent to (not cond ? false : true).  (It\n  produces false and skips the next instruction producing true.)\n\n  (*) Opcodes OP_MMBIN and variants follow each arithmetic and\n  bitwise opcode. If the operation succeeds, it skips this next\n  opcode. Otherwise, this opcode calls the corresponding metamethod.\n\n  (*) Opcode OP_TESTSET is used in short-circuit expressions that need\n  both to jump and to produce a value, such as (a = b or c).\n\n  (*) In OP_CALL, if (B == 0) then B = top - A. If (C == 0), then\n  'top' is set to last_result+1, so next open instruction (OP_CALL,\n  OP_RETURN*, OP_SETLIST) may use 'top'.\n\n  (*) In OP_VARARG, if (C == 0) then use actual number of varargs and\n  set top (like in OP_CALL with C == 0).\n\n  (*) In OP_RETURN, if (B == 0) then return up to 'top'.\n\n  (*) In OP_LOADKX and OP_NEWTABLE, the next instruction is always\n  OP_EXTRAARG.\n\n  (*) In OP_SETLIST, if (B == 0) then real B = 'top'; if k, then\n  real C = EXTRAARG _ C (the bits of EXTRAARG concatenated with the\n  bits of C).\n\n  (*) In OP_NEWTABLE, B is log2 of the hash size (which is always a\n  power of 2) plus 1, or zero for size zero. If not k, the array size\n  is C. Otherwise, the array size is EXTRAARG _ C.\n\n  (*) For comparisons, k specifies what condition the test should accept\n  (true or false).\n\n  (*) In OP_MMBINI/OP_MMBINK, k means the arguments were flipped\n   (the constant is the first operand).\n\n  (*) All 'skips' (pc++) assume that next instruction is a jump.\n\n  (*) In instructions OP_RETURN/OP_TAILCALL, 'k' specifies that the\n  function builds upvalues, which may need to be closed. C > 0 means\n  the function is vararg, so that its 'func' must be corrected before\n  returning; in this case, (C - 1) is its number of fixed parameters.\n\n  (*) In comparisons with an immediate operand, C signals whether the\n  original operand was a float. (It must be corrected in case of\n  metamethods.)\n\n===========================================================================*/\n\n\n/*\n** masks for instruction properties. The format is:\n** bits 0-2: op mode\n** bit 3: instruction set register A\n** bit 4: operator is a test (next instruction must be a jump)\n** bit 5: instruction uses 'L->top' set by previous instruction (when B == 0)\n** bit 6: instruction sets 'L->top' for next instruction (when C == 0)\n** bit 7: instruction is an MM instruction (call a metamethod)\n*/\n\nLUAI_DDEC(const lu_byte luaP_opmodes[NUM_OPCODES];)\n\n#define getOpMode(m)\t(cast(enum OpMode, luaP_opmodes[m] & 7))\n#define testAMode(m)\t(luaP_opmodes[m] & (1 << 3))\n#define testTMode(m)\t(luaP_opmodes[m] & (1 << 4))\n#define testITMode(m)\t(luaP_opmodes[m] & (1 << 5))\n#define testOTMode(m)\t(luaP_opmodes[m] & (1 << 6))\n#define testMMMode(m)\t(luaP_opmodes[m] & (1 << 7))\n\n\nLUAI_FUNC int luaP_isOT (Instruction i);\nLUAI_FUNC int luaP_isIT (Instruction i);\n\n\n#endif\n"
        },
        {
          "name": "lopnames.h",
          "type": "blob",
          "size": 1.1162109375,
          "content": "/*\n** $Id: lopnames.h $\n** Opcode names\n** See Copyright Notice in lua.h\n*/\n\n#if !defined(lopnames_h)\n#define lopnames_h\n\n#include <stddef.h>\n\n\n/* ORDER OP */\n\nstatic const char *const opnames[] = {\n  \"MOVE\",\n  \"LOADI\",\n  \"LOADF\",\n  \"LOADK\",\n  \"LOADKX\",\n  \"LOADFALSE\",\n  \"LFALSESKIP\",\n  \"LOADTRUE\",\n  \"LOADNIL\",\n  \"GETUPVAL\",\n  \"SETUPVAL\",\n  \"GETTABUP\",\n  \"GETTABLE\",\n  \"GETI\",\n  \"GETFIELD\",\n  \"SETTABUP\",\n  \"SETTABLE\",\n  \"SETI\",\n  \"SETFIELD\",\n  \"NEWTABLE\",\n  \"SELF\",\n  \"ADDI\",\n  \"ADDK\",\n  \"SUBK\",\n  \"MULK\",\n  \"MODK\",\n  \"POWK\",\n  \"DIVK\",\n  \"IDIVK\",\n  \"BANDK\",\n  \"BORK\",\n  \"BXORK\",\n  \"SHRI\",\n  \"SHLI\",\n  \"ADD\",\n  \"SUB\",\n  \"MUL\",\n  \"MOD\",\n  \"POW\",\n  \"DIV\",\n  \"IDIV\",\n  \"BAND\",\n  \"BOR\",\n  \"BXOR\",\n  \"SHL\",\n  \"SHR\",\n  \"MMBIN\",\n  \"MMBINI\",\n  \"MMBINK\",\n  \"UNM\",\n  \"BNOT\",\n  \"NOT\",\n  \"LEN\",\n  \"CONCAT\",\n  \"CLOSE\",\n  \"TBC\",\n  \"JMP\",\n  \"EQ\",\n  \"LT\",\n  \"LE\",\n  \"EQK\",\n  \"EQI\",\n  \"LTI\",\n  \"LEI\",\n  \"GTI\",\n  \"GEI\",\n  \"TEST\",\n  \"TESTSET\",\n  \"CALL\",\n  \"TAILCALL\",\n  \"RETURN\",\n  \"RETURN0\",\n  \"RETURN1\",\n  \"FORLOOP\",\n  \"FORPREP\",\n  \"TFORPREP\",\n  \"TFORCALL\",\n  \"TFORLOOP\",\n  \"SETLIST\",\n  \"CLOSURE\",\n  \"VARARG\",\n  \"VARARGPREP\",\n  \"EXTRAARG\",\n  NULL\n};\n\n#endif\n\n"
        },
        {
          "name": "loslib.c",
          "type": "blob",
          "size": 11.5732421875,
          "content": "/*\n** $Id: loslib.c $\n** Standard Operating System library\n** See Copyright Notice in lua.h\n*/\n\n#define loslib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <errno.h>\n#include <locale.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n#include \"llimits.h\"\n\n\n/*\n** {==================================================================\n** List of valid conversion specifiers for the 'strftime' function;\n** options are grouped by length; group of length 2 start with '||'.\n** ===================================================================\n*/\n#if !defined(LUA_STRFTIMEOPTIONS)\t/* { */\n\n#if defined(LUA_USE_WINDOWS)\n#define LUA_STRFTIMEOPTIONS  \"aAbBcdHIjmMpSUwWxXyYzZ%\" \\\n    \"||\" \"#c#x#d#H#I#j#m#M#S#U#w#W#y#Y\"  /* two-char options */\n#elif defined(LUA_USE_C89)  /* ANSI C 89 (only 1-char options) */\n#define LUA_STRFTIMEOPTIONS  \"aAbBcdHIjmMpSUwWxXyYZ%\"\n#else  /* C99 specification */\n#define LUA_STRFTIMEOPTIONS  \"aAbBcCdDeFgGhHIjmMnprRStTuUVwWxXyYzZ%\" \\\n    \"||\" \"EcECExEXEyEY\" \"OdOeOHOIOmOMOSOuOUOVOwOWOy\"  /* two-char options */\n#endif\n\n#endif\t\t\t\t\t/* } */\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Configuration for time-related stuff\n** ===================================================================\n*/\n\n/*\n** type to represent time_t in Lua\n*/\n#if !defined(LUA_NUMTIME)\t/* { */\n\n#define l_timet\t\t\tlua_Integer\n#define l_pushtime(L,t)\t\tlua_pushinteger(L,(lua_Integer)(t))\n#define l_gettime(L,arg)\tluaL_checkinteger(L, arg)\n\n#else\t\t\t\t/* }{ */\n\n#define l_timet\t\t\tlua_Number\n#define l_pushtime(L,t)\t\tlua_pushnumber(L,(lua_Number)(t))\n#define l_gettime(L,arg)\tluaL_checknumber(L, arg)\n\n#endif\t\t\t\t/* } */\n\n\n#if !defined(l_gmtime)\t\t/* { */\n/*\n** By default, Lua uses gmtime/localtime, except when POSIX is available,\n** where it uses gmtime_r/localtime_r\n*/\n\n#if defined(LUA_USE_POSIX)\t/* { */\n\n#define l_gmtime(t,r)\t\tgmtime_r(t,r)\n#define l_localtime(t,r)\tlocaltime_r(t,r)\n\n#else\t\t\t\t/* }{ */\n\n/* ISO C definitions */\n#define l_gmtime(t,r)\t\t((void)(r)->tm_sec, gmtime(t))\n#define l_localtime(t,r)\t((void)(r)->tm_sec, localtime(t))\n\n#endif\t\t\t\t/* } */\n\n#endif\t\t\t\t/* } */\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Configuration for 'tmpnam':\n** By default, Lua uses tmpnam except when POSIX is available, where\n** it uses mkstemp.\n** ===================================================================\n*/\n#if !defined(lua_tmpnam)\t/* { */\n\n#if defined(LUA_USE_POSIX)\t/* { */\n\n#include <unistd.h>\n\n#define LUA_TMPNAMBUFSIZE\t32\n\n#if !defined(LUA_TMPNAMTEMPLATE)\n#define LUA_TMPNAMTEMPLATE\t\"/tmp/lua_XXXXXX\"\n#endif\n\n#define lua_tmpnam(b,e) { \\\n        strcpy(b, LUA_TMPNAMTEMPLATE); \\\n        e = mkstemp(b); \\\n        if (e != -1) close(e); \\\n        e = (e == -1); }\n\n#else\t\t\t\t/* }{ */\n\n/* ISO C definitions */\n#define LUA_TMPNAMBUFSIZE\tL_tmpnam\n#define lua_tmpnam(b,e)\t\t{ e = (tmpnam(b) == NULL); }\n\n#endif\t\t\t\t/* } */\n\n#endif\t\t\t\t/* } */\n/* }================================================================== */\n\n\n#if !defined(l_system)\n#if defined(LUA_USE_IOS)\n/* Despite claiming to be ISO C, iOS does not implement 'system'. */\n#define l_system(cmd) ((cmd) == NULL ? 0 : -1)\n#else\n#define l_system(cmd)\tsystem(cmd)  /* default definition */\n#endif\n#endif\n\n\nstatic int os_execute (lua_State *L) {\n  const char *cmd = luaL_optstring(L, 1, NULL);\n  int stat;\n  errno = 0;\n  stat = l_system(cmd);\n  if (cmd != NULL)\n    return luaL_execresult(L, stat);\n  else {\n    lua_pushboolean(L, stat);  /* true if there is a shell */\n    return 1;\n  }\n}\n\n\nstatic int os_remove (lua_State *L) {\n  const char *filename = luaL_checkstring(L, 1);\n  errno = 0;\n  return luaL_fileresult(L, remove(filename) == 0, filename);\n}\n\n\nstatic int os_rename (lua_State *L) {\n  const char *fromname = luaL_checkstring(L, 1);\n  const char *toname = luaL_checkstring(L, 2);\n  errno = 0;\n  return luaL_fileresult(L, rename(fromname, toname) == 0, NULL);\n}\n\n\nstatic int os_tmpname (lua_State *L) {\n  char buff[LUA_TMPNAMBUFSIZE];\n  int err;\n  lua_tmpnam(buff, err);\n  if (l_unlikely(err))\n    return luaL_error(L, \"unable to generate a unique filename\");\n  lua_pushstring(L, buff);\n  return 1;\n}\n\n\nstatic int os_getenv (lua_State *L) {\n  lua_pushstring(L, getenv(luaL_checkstring(L, 1)));  /* if NULL push nil */\n  return 1;\n}\n\n\nstatic int os_clock (lua_State *L) {\n  lua_pushnumber(L, ((lua_Number)clock())/(lua_Number)CLOCKS_PER_SEC);\n  return 1;\n}\n\n\n/*\n** {======================================================\n** Time/Date operations\n** { year=%Y, month=%m, day=%d, hour=%H, min=%M, sec=%S,\n**   wday=%w+1, yday=%j, isdst=? }\n** =======================================================\n*/\n\n/*\n** About the overflow check: an overflow cannot occur when time\n** is represented by a lua_Integer, because either lua_Integer is\n** large enough to represent all int fields or it is not large enough\n** to represent a time that cause a field to overflow.  However, if\n** times are represented as doubles and lua_Integer is int, then the\n** time 0x1.e1853b0d184f6p+55 would cause an overflow when adding 1900\n** to compute the year.\n*/\nstatic void setfield (lua_State *L, const char *key, int value, int delta) {\n  #if (defined(LUA_NUMTIME) && LUA_MAXINTEGER <= INT_MAX)\n    if (l_unlikely(value > LUA_MAXINTEGER - delta))\n      luaL_error(L, \"field '%s' is out-of-bound\", key);\n  #endif\n  lua_pushinteger(L, (lua_Integer)value + delta);\n  lua_setfield(L, -2, key);\n}\n\n\nstatic void setboolfield (lua_State *L, const char *key, int value) {\n  if (value < 0)  /* undefined? */\n    return;  /* does not set field */\n  lua_pushboolean(L, value);\n  lua_setfield(L, -2, key);\n}\n\n\n/*\n** Set all fields from structure 'tm' in the table on top of the stack\n*/\nstatic void setallfields (lua_State *L, struct tm *stm) {\n  setfield(L, \"year\", stm->tm_year, 1900);\n  setfield(L, \"month\", stm->tm_mon, 1);\n  setfield(L, \"day\", stm->tm_mday, 0);\n  setfield(L, \"hour\", stm->tm_hour, 0);\n  setfield(L, \"min\", stm->tm_min, 0);\n  setfield(L, \"sec\", stm->tm_sec, 0);\n  setfield(L, \"yday\", stm->tm_yday, 1);\n  setfield(L, \"wday\", stm->tm_wday, 1);\n  setboolfield(L, \"isdst\", stm->tm_isdst);\n}\n\n\nstatic int getboolfield (lua_State *L, const char *key) {\n  int res;\n  res = (lua_getfield(L, -1, key) == LUA_TNIL) ? -1 : lua_toboolean(L, -1);\n  lua_pop(L, 1);\n  return res;\n}\n\n\nstatic int getfield (lua_State *L, const char *key, int d, int delta) {\n  int isnum;\n  int t = lua_getfield(L, -1, key);  /* get field and its type */\n  lua_Integer res = lua_tointegerx(L, -1, &isnum);\n  if (!isnum) {  /* field is not an integer? */\n    if (l_unlikely(t != LUA_TNIL))  /* some other value? */\n      return luaL_error(L, \"field '%s' is not an integer\", key);\n    else if (l_unlikely(d < 0))  /* absent field; no default? */\n      return luaL_error(L, \"field '%s' missing in date table\", key);\n    res = d;\n  }\n  else {\n    if (!(res >= 0 ? res - delta <= INT_MAX : INT_MIN + delta <= res))\n      return luaL_error(L, \"field '%s' is out-of-bound\", key);\n    res -= delta;\n  }\n  lua_pop(L, 1);\n  return (int)res;\n}\n\n\nstatic const char *checkoption (lua_State *L, const char *conv,\n                                ptrdiff_t convlen, char *buff) {\n  const char *option = LUA_STRFTIMEOPTIONS;\n  unsigned oplen = 1;  /* length of options being checked */\n  for (; *option != '\\0' && oplen <= convlen; option += oplen) {\n    if (*option == '|')  /* next block? */\n      oplen++;  /* will check options with next length (+1) */\n    else if (memcmp(conv, option, oplen) == 0) {  /* match? */\n      memcpy(buff, conv, oplen);  /* copy valid option to buffer */\n      buff[oplen] = '\\0';\n      return conv + oplen;  /* return next item */\n    }\n  }\n  luaL_argerror(L, 1,\n    lua_pushfstring(L, \"invalid conversion specifier '%%%s'\", conv));\n  return conv;  /* to avoid warnings */\n}\n\n\nstatic time_t l_checktime (lua_State *L, int arg) {\n  l_timet t = l_gettime(L, arg);\n  luaL_argcheck(L, (time_t)t == t, arg, \"time out-of-bounds\");\n  return (time_t)t;\n}\n\n\n/* maximum size for an individual 'strftime' item */\n#define SIZETIMEFMT\t250\n\n\nstatic int os_date (lua_State *L) {\n  size_t slen;\n  const char *s = luaL_optlstring(L, 1, \"%c\", &slen);\n  time_t t = luaL_opt(L, l_checktime, 2, time(NULL));\n  const char *se = s + slen;  /* 's' end */\n  struct tm tmr, *stm;\n  if (*s == '!') {  /* UTC? */\n    stm = l_gmtime(&t, &tmr);\n    s++;  /* skip '!' */\n  }\n  else\n    stm = l_localtime(&t, &tmr);\n  if (stm == NULL)  /* invalid date? */\n    return luaL_error(L,\n                 \"date result cannot be represented in this installation\");\n  if (strcmp(s, \"*t\") == 0) {\n    lua_createtable(L, 0, 9);  /* 9 = number of fields */\n    setallfields(L, stm);\n  }\n  else {\n    char cc[4];  /* buffer for individual conversion specifiers */\n    luaL_Buffer b;\n    cc[0] = '%';\n    luaL_buffinit(L, &b);\n    while (s < se) {\n      if (*s != '%')  /* not a conversion specifier? */\n        luaL_addchar(&b, *s++);\n      else {\n        size_t reslen;\n        char *buff = luaL_prepbuffsize(&b, SIZETIMEFMT);\n        s++;  /* skip '%' */\n        s = checkoption(L, s, se - s, cc + 1);  /* copy specifier to 'cc' */\n        reslen = strftime(buff, SIZETIMEFMT, cc, stm);\n        luaL_addsize(&b, reslen);\n      }\n    }\n    luaL_pushresult(&b);\n  }\n  return 1;\n}\n\n\nstatic int os_time (lua_State *L) {\n  time_t t;\n  if (lua_isnoneornil(L, 1))  /* called without args? */\n    t = time(NULL);  /* get current time */\n  else {\n    struct tm ts;\n    luaL_checktype(L, 1, LUA_TTABLE);\n    lua_settop(L, 1);  /* make sure table is at the top */\n    ts.tm_year = getfield(L, \"year\", -1, 1900);\n    ts.tm_mon = getfield(L, \"month\", -1, 1);\n    ts.tm_mday = getfield(L, \"day\", -1, 0);\n    ts.tm_hour = getfield(L, \"hour\", 12, 0);\n    ts.tm_min = getfield(L, \"min\", 0, 0);\n    ts.tm_sec = getfield(L, \"sec\", 0, 0);\n    ts.tm_isdst = getboolfield(L, \"isdst\");\n    t = mktime(&ts);\n    setallfields(L, &ts);  /* update fields with normalized values */\n  }\n  if (t != (time_t)(l_timet)t || t == (time_t)(-1))\n    return luaL_error(L,\n                  \"time result cannot be represented in this installation\");\n  l_pushtime(L, t);\n  return 1;\n}\n\n\nstatic int os_difftime (lua_State *L) {\n  time_t t1 = l_checktime(L, 1);\n  time_t t2 = l_checktime(L, 2);\n  lua_pushnumber(L, (lua_Number)difftime(t1, t2));\n  return 1;\n}\n\n/* }====================================================== */\n\n\nstatic int os_setlocale (lua_State *L) {\n  static const int cat[] = {LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY,\n                      LC_NUMERIC, LC_TIME};\n  static const char *const catnames[] = {\"all\", \"collate\", \"ctype\", \"monetary\",\n     \"numeric\", \"time\", NULL};\n  const char *l = luaL_optstring(L, 1, NULL);\n  int op = luaL_checkoption(L, 2, \"all\", catnames);\n  lua_pushstring(L, setlocale(cat[op], l));\n  return 1;\n}\n\n\nstatic int os_exit (lua_State *L) {\n  int status;\n  if (lua_isboolean(L, 1))\n    status = (lua_toboolean(L, 1) ? EXIT_SUCCESS : EXIT_FAILURE);\n  else\n    status = (int)luaL_optinteger(L, 1, EXIT_SUCCESS);\n  if (lua_toboolean(L, 2))\n    lua_close(L);\n  if (L) exit(status);  /* 'if' to avoid warnings for unreachable 'return' */\n  return 0;\n}\n\n\nstatic const luaL_Reg syslib[] = {\n  {\"clock\",     os_clock},\n  {\"date\",      os_date},\n  {\"difftime\",  os_difftime},\n  {\"execute\",   os_execute},\n  {\"exit\",      os_exit},\n  {\"getenv\",    os_getenv},\n  {\"remove\",    os_remove},\n  {\"rename\",    os_rename},\n  {\"setlocale\", os_setlocale},\n  {\"time\",      os_time},\n  {\"tmpname\",   os_tmpname},\n  {NULL, NULL}\n};\n\n/* }====================================================== */\n\n\n\nLUAMOD_API int luaopen_os (lua_State *L) {\n  luaL_newlib(L, syslib);\n  return 1;\n}\n\n"
        },
        {
          "name": "lparser.c",
          "type": "blob",
          "size": 56.2255859375,
          "content": "/*\n** $Id: lparser.c $\n** Lua Parser\n** See Copyright Notice in lua.h\n*/\n\n#define lparser_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <limits.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lcode.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"llex.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lparser.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n\n\n\n/* maximum number of local variables per function (must be smaller\n   than 250, due to the bytecode format) */\n#define MAXVARS\t\t200\n\n\n#define hasmultret(k)\t\t((k) == VCALL || (k) == VVARARG)\n\n\n/* because all strings are unified by the scanner, the parser\n   can use pointer equality for string equality */\n#define eqstr(a,b)\t((a) == (b))\n\n\n/*\n** nodes for block list (list of active blocks)\n*/\ntypedef struct BlockCnt {\n  struct BlockCnt *previous;  /* chain */\n  int firstlabel;  /* index of first label in this block */\n  int firstgoto;  /* index of first pending goto in this block */\n  lu_byte nactvar;  /* # active locals outside the block */\n  lu_byte upval;  /* true if some variable in the block is an upvalue */\n  lu_byte isloop;  /* true if 'block' is a loop */\n  lu_byte insidetbc;  /* true if inside the scope of a to-be-closed var. */\n} BlockCnt;\n\n\n\n/*\n** prototypes for recursive non-terminal functions\n*/\nstatic void statement (LexState *ls);\nstatic void expr (LexState *ls, expdesc *v);\n\n\nstatic l_noret error_expected (LexState *ls, int token) {\n  luaX_syntaxerror(ls,\n      luaO_pushfstring(ls->L, \"%s expected\", luaX_token2str(ls, token)));\n}\n\n\nstatic l_noret errorlimit (FuncState *fs, int limit, const char *what) {\n  lua_State *L = fs->ls->L;\n  const char *msg;\n  int line = fs->f->linedefined;\n  const char *where = (line == 0)\n                      ? \"main function\"\n                      : luaO_pushfstring(L, \"function at line %d\", line);\n  msg = luaO_pushfstring(L, \"too many %s (limit is %d) in %s\",\n                             what, limit, where);\n  luaX_syntaxerror(fs->ls, msg);\n}\n\n\nvoid luaY_checklimit (FuncState *fs, int v, int l, const char *what) {\n  if (l_unlikely(v > l)) errorlimit(fs, l, what);\n}\n\n\n/*\n** Test whether next token is 'c'; if so, skip it.\n*/\nstatic int testnext (LexState *ls, int c) {\n  if (ls->t.token == c) {\n    luaX_next(ls);\n    return 1;\n  }\n  else return 0;\n}\n\n\n/*\n** Check that next token is 'c'.\n*/\nstatic void check (LexState *ls, int c) {\n  if (ls->t.token != c)\n    error_expected(ls, c);\n}\n\n\n/*\n** Check that next token is 'c' and skip it.\n*/\nstatic void checknext (LexState *ls, int c) {\n  check(ls, c);\n  luaX_next(ls);\n}\n\n\n#define check_condition(ls,c,msg)\t{ if (!(c)) luaX_syntaxerror(ls, msg); }\n\n\n/*\n** Check that next token is 'what' and skip it. In case of error,\n** raise an error that the expected 'what' should match a 'who'\n** in line 'where' (if that is not the current line).\n*/\nstatic void check_match (LexState *ls, int what, int who, int where) {\n  if (l_unlikely(!testnext(ls, what))) {\n    if (where == ls->linenumber)  /* all in the same line? */\n      error_expected(ls, what);  /* do not need a complex message */\n    else {\n      luaX_syntaxerror(ls, luaO_pushfstring(ls->L,\n             \"%s expected (to close %s at line %d)\",\n              luaX_token2str(ls, what), luaX_token2str(ls, who), where));\n    }\n  }\n}\n\n\nstatic TString *str_checkname (LexState *ls) {\n  TString *ts;\n  check(ls, TK_NAME);\n  ts = ls->t.seminfo.ts;\n  luaX_next(ls);\n  return ts;\n}\n\n\nstatic void init_exp (expdesc *e, expkind k, int i) {\n  e->f = e->t = NO_JUMP;\n  e->k = k;\n  e->u.info = i;\n}\n\n\nstatic void codestring (expdesc *e, TString *s) {\n  e->f = e->t = NO_JUMP;\n  e->k = VKSTR;\n  e->u.strval = s;\n}\n\n\nstatic void codename (LexState *ls, expdesc *e) {\n  codestring(e, str_checkname(ls));\n}\n\n\n/*\n** Register a new local variable in the active 'Proto' (for debug\n** information).\n*/\nstatic short registerlocalvar (LexState *ls, FuncState *fs,\n                               TString *varname) {\n  Proto *f = fs->f;\n  int oldsize = f->sizelocvars;\n  luaM_growvector(ls->L, f->locvars, fs->ndebugvars, f->sizelocvars,\n                  LocVar, SHRT_MAX, \"local variables\");\n  while (oldsize < f->sizelocvars)\n    f->locvars[oldsize++].varname = NULL;\n  f->locvars[fs->ndebugvars].varname = varname;\n  f->locvars[fs->ndebugvars].startpc = fs->pc;\n  luaC_objbarrier(ls->L, f, varname);\n  return fs->ndebugvars++;\n}\n\n\n/*\n** Create a new local variable with the given 'name' and given 'kind'.\n** Return its index in the function.\n*/\nstatic int new_localvarkind (LexState *ls, TString *name, lu_byte kind) {\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Dyndata *dyd = ls->dyd;\n  Vardesc *var;\n  luaY_checklimit(fs, dyd->actvar.n + 1 - fs->firstlocal,\n                 MAXVARS, \"local variables\");\n  luaM_growvector(L, dyd->actvar.arr, dyd->actvar.n + 1,\n                  dyd->actvar.size, Vardesc, SHRT_MAX, \"local variables\");\n  var = &dyd->actvar.arr[dyd->actvar.n++];\n  var->vd.kind = kind;  /* default */\n  var->vd.name = name;\n  return dyd->actvar.n - 1 - fs->firstlocal;\n}\n\n\n/*\n** Create a new local variable with the given 'name' and regular kind.\n*/\nstatic int new_localvar (LexState *ls, TString *name) {\n  return new_localvarkind(ls, name, VDKREG);\n}\n\n#define new_localvarliteral(ls,v) \\\n    new_localvar(ls,  \\\n      luaX_newstring(ls, \"\" v, (sizeof(v)/sizeof(char)) - 1));\n\n\n\n/*\n** Return the \"variable description\" (Vardesc) of a given variable.\n** (Unless noted otherwise, all variables are referred to by their\n** compiler indices.)\n*/\nstatic Vardesc *getlocalvardesc (FuncState *fs, int vidx) {\n  return &fs->ls->dyd->actvar.arr[fs->firstlocal + vidx];\n}\n\n\n/*\n** Convert 'nvar', a compiler index level, to its corresponding\n** register. For that, search for the highest variable below that level\n** that is in a register and uses its register index ('ridx') plus one.\n*/\nstatic lu_byte reglevel (FuncState *fs, int nvar) {\n  while (nvar-- > 0) {\n    Vardesc *vd = getlocalvardesc(fs, nvar);  /* get previous variable */\n    if (vd->vd.kind != RDKCTC)  /* is in a register? */\n      return cast_byte(vd->vd.ridx + 1);\n  }\n  return 0;  /* no variables in registers */\n}\n\n\n/*\n** Return the number of variables in the register stack for the given\n** function.\n*/\nlu_byte luaY_nvarstack (FuncState *fs) {\n  return reglevel(fs, fs->nactvar);\n}\n\n\n/*\n** Get the debug-information entry for current variable 'vidx'.\n*/\nstatic LocVar *localdebuginfo (FuncState *fs, int vidx) {\n  Vardesc *vd = getlocalvardesc(fs,  vidx);\n  if (vd->vd.kind == RDKCTC)\n    return NULL;  /* no debug info. for constants */\n  else {\n    int idx = vd->vd.pidx;\n    lua_assert(idx < fs->ndebugvars);\n    return &fs->f->locvars[idx];\n  }\n}\n\n\n/*\n** Create an expression representing variable 'vidx'\n*/\nstatic void init_var (FuncState *fs, expdesc *e, int vidx) {\n  e->f = e->t = NO_JUMP;\n  e->k = VLOCAL;\n  e->u.var.vidx = cast(unsigned short, vidx);\n  e->u.var.ridx = getlocalvardesc(fs, vidx)->vd.ridx;\n}\n\n\n/*\n** Raises an error if variable described by 'e' is read only\n*/\nstatic void check_readonly (LexState *ls, expdesc *e) {\n  FuncState *fs = ls->fs;\n  TString *varname = NULL;  /* to be set if variable is const */\n  switch (e->k) {\n    case VCONST: {\n      varname = ls->dyd->actvar.arr[e->u.info].vd.name;\n      break;\n    }\n    case VLOCAL: {\n      Vardesc *vardesc = getlocalvardesc(fs, e->u.var.vidx);\n      if (vardesc->vd.kind != VDKREG)  /* not a regular variable? */\n        varname = vardesc->vd.name;\n      break;\n    }\n    case VUPVAL: {\n      Upvaldesc *up = &fs->f->upvalues[e->u.info];\n      if (up->kind != VDKREG)\n        varname = up->name;\n      break;\n    }\n    default:\n      return;  /* other cases cannot be read-only */\n  }\n  if (varname) {\n    const char *msg = luaO_pushfstring(ls->L,\n       \"attempt to assign to const variable '%s'\", getstr(varname));\n    luaK_semerror(ls, msg);  /* error */\n  }\n}\n\n\n/*\n** Start the scope for the last 'nvars' created variables.\n*/\nstatic void adjustlocalvars (LexState *ls, int nvars) {\n  FuncState *fs = ls->fs;\n  int reglevel = luaY_nvarstack(fs);\n  int i;\n  for (i = 0; i < nvars; i++) {\n    int vidx = fs->nactvar++;\n    Vardesc *var = getlocalvardesc(fs, vidx);\n    var->vd.ridx = cast_byte(reglevel++);\n    var->vd.pidx = registerlocalvar(ls, fs, var->vd.name);\n  }\n}\n\n\n/*\n** Close the scope for all variables up to level 'tolevel'.\n** (debug info.)\n*/\nstatic void removevars (FuncState *fs, int tolevel) {\n  fs->ls->dyd->actvar.n -= (fs->nactvar - tolevel);\n  while (fs->nactvar > tolevel) {\n    LocVar *var = localdebuginfo(fs, --fs->nactvar);\n    if (var)  /* does it have debug information? */\n      var->endpc = fs->pc;\n  }\n}\n\n\n/*\n** Search the upvalues of the function 'fs' for one\n** with the given 'name'.\n*/\nstatic int searchupvalue (FuncState *fs, TString *name) {\n  int i;\n  Upvaldesc *up = fs->f->upvalues;\n  for (i = 0; i < fs->nups; i++) {\n    if (eqstr(up[i].name, name)) return i;\n  }\n  return -1;  /* not found */\n}\n\n\nstatic Upvaldesc *allocupvalue (FuncState *fs) {\n  Proto *f = fs->f;\n  int oldsize = f->sizeupvalues;\n  luaY_checklimit(fs, fs->nups + 1, MAXUPVAL, \"upvalues\");\n  luaM_growvector(fs->ls->L, f->upvalues, fs->nups, f->sizeupvalues,\n                  Upvaldesc, MAXUPVAL, \"upvalues\");\n  while (oldsize < f->sizeupvalues)\n    f->upvalues[oldsize++].name = NULL;\n  return &f->upvalues[fs->nups++];\n}\n\n\nstatic int newupvalue (FuncState *fs, TString *name, expdesc *v) {\n  Upvaldesc *up = allocupvalue(fs);\n  FuncState *prev = fs->prev;\n  if (v->k == VLOCAL) {\n    up->instack = 1;\n    up->idx = v->u.var.ridx;\n    up->kind = getlocalvardesc(prev, v->u.var.vidx)->vd.kind;\n    lua_assert(eqstr(name, getlocalvardesc(prev, v->u.var.vidx)->vd.name));\n  }\n  else {\n    up->instack = 0;\n    up->idx = cast_byte(v->u.info);\n    up->kind = prev->f->upvalues[v->u.info].kind;\n    lua_assert(eqstr(name, prev->f->upvalues[v->u.info].name));\n  }\n  up->name = name;\n  luaC_objbarrier(fs->ls->L, fs->f, name);\n  return fs->nups - 1;\n}\n\n\n/*\n** Look for an active local variable with the name 'n' in the\n** function 'fs'. If found, initialize 'var' with it and return\n** its expression kind; otherwise return -1.\n*/\nstatic int searchvar (FuncState *fs, TString *n, expdesc *var) {\n  int i;\n  for (i = cast_int(fs->nactvar) - 1; i >= 0; i--) {\n    Vardesc *vd = getlocalvardesc(fs, i);\n    if (eqstr(n, vd->vd.name)) {  /* found? */\n      if (vd->vd.kind == RDKCTC)  /* compile-time constant? */\n        init_exp(var, VCONST, fs->firstlocal + i);\n      else  /* real variable */\n        init_var(fs, var, i);\n      return var->k;\n    }\n  }\n  return -1;  /* not found */\n}\n\n\n/*\n** Mark block where variable at given level was defined\n** (to emit close instructions later).\n*/\nstatic void markupval (FuncState *fs, int level) {\n  BlockCnt *bl = fs->bl;\n  while (bl->nactvar > level)\n    bl = bl->previous;\n  bl->upval = 1;\n  fs->needclose = 1;\n}\n\n\n/*\n** Mark that current block has a to-be-closed variable.\n*/\nstatic void marktobeclosed (FuncState *fs) {\n  BlockCnt *bl = fs->bl;\n  bl->upval = 1;\n  bl->insidetbc = 1;\n  fs->needclose = 1;\n}\n\n\n/*\n** Find a variable with the given name 'n'. If it is an upvalue, add\n** this upvalue into all intermediate functions. If it is a global, set\n** 'var' as 'void' as a flag.\n*/\nstatic void singlevaraux (FuncState *fs, TString *n, expdesc *var, int base) {\n  if (fs == NULL)  /* no more levels? */\n    init_exp(var, VVOID, 0);  /* default is global */\n  else {\n    int v = searchvar(fs, n, var);  /* look up locals at current level */\n    if (v >= 0) {  /* found? */\n      if (v == VLOCAL && !base)\n        markupval(fs, var->u.var.vidx);  /* local will be used as an upval */\n    }\n    else {  /* not found as local at current level; try upvalues */\n      int idx = searchupvalue(fs, n);  /* try existing upvalues */\n      if (idx < 0) {  /* not found? */\n        singlevaraux(fs->prev, n, var, 0);  /* try upper levels */\n        if (var->k == VLOCAL || var->k == VUPVAL)  /* local or upvalue? */\n          idx  = newupvalue(fs, n, var);  /* will be a new upvalue */\n        else  /* it is a global or a constant */\n          return;  /* don't need to do anything at this level */\n      }\n      init_exp(var, VUPVAL, idx);  /* new or old upvalue */\n    }\n  }\n}\n\n\n/*\n** Find a variable with the given name 'n', handling global variables\n** too.\n*/\nstatic void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  /* global name? */\n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  /* get environment variable */\n    lua_assert(var->k != VVOID);  /* this one must exist */\n    luaK_exp2anyregup(fs, var);  /* but could be a constant */\n    codestring(&key, varname);  /* key is variable name */\n    luaK_indexed(fs, var, &key);  /* env[varname] */\n  }\n}\n\n\n/*\n** Adjust the number of results from an expression list 'e' with 'nexps'\n** expressions to 'nvars' values.\n*/\nstatic void adjust_assign (LexState *ls, int nvars, int nexps, expdesc *e) {\n  FuncState *fs = ls->fs;\n  int needed = nvars - nexps;  /* extra values needed */\n  if (hasmultret(e->k)) {  /* last expression has multiple returns? */\n    int extra = needed + 1;  /* discount last expression itself */\n    if (extra < 0)\n      extra = 0;\n    luaK_setreturns(fs, e, extra);  /* last exp. provides the difference */\n  }\n  else {\n    if (e->k != VVOID)  /* at least one expression? */\n      luaK_exp2nextreg(fs, e);  /* close last expression */\n    if (needed > 0)  /* missing values? */\n      luaK_nil(fs, fs->freereg, needed);  /* complete with nils */\n  }\n  if (needed > 0)\n    luaK_reserveregs(fs, needed);  /* registers for extra values */\n  else  /* adding 'needed' is actually a subtraction */\n    fs->freereg = cast_byte(fs->freereg + needed);  /* remove extra values */\n}\n\n\n#define enterlevel(ls)\tluaE_incCstack(ls->L)\n\n\n#define leavelevel(ls) ((ls)->L->nCcalls--)\n\n\n/*\n** Generates an error that a goto jumps into the scope of some\n** local variable.\n*/\nstatic l_noret jumpscopeerror (LexState *ls, Labeldesc *gt) {\n  TString *tsname = getlocalvardesc(ls->fs, gt->nactvar)->vd.name;\n  const char *varname = getstr(tsname);\n  const char *msg = \"<goto %s> at line %d jumps into the scope of local '%s'\";\n  msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line, varname);\n  luaK_semerror(ls, msg);  /* raise the error */\n}\n\n\n/*\n** Solves the goto at index 'g' to given 'label' and removes it\n** from the list of pending gotos.\n** If it jumps into the scope of some variable, raises an error.\n*/\nstatic void solvegoto (LexState *ls, int g, Labeldesc *label) {\n  int i;\n  Labellist *gl = &ls->dyd->gt;  /* list of gotos */\n  Labeldesc *gt = &gl->arr[g];  /* goto to be resolved */\n  lua_assert(eqstr(gt->name, label->name));\n  if (l_unlikely(gt->nactvar < label->nactvar))  /* enter some scope? */\n    jumpscopeerror(ls, gt);\n  luaK_patchlist(ls->fs, gt->pc, label->pc);\n  for (i = g; i < gl->n - 1; i++)  /* remove goto from pending list */\n    gl->arr[i] = gl->arr[i + 1];\n  gl->n--;\n}\n\n\n/*\n** Search for an active label with the given name.\n*/\nstatic Labeldesc *findlabel (LexState *ls, TString *name) {\n  int i;\n  Dyndata *dyd = ls->dyd;\n  /* check labels in current function for a match */\n  for (i = ls->fs->firstlabel; i < dyd->label.n; i++) {\n    Labeldesc *lb = &dyd->label.arr[i];\n    if (eqstr(lb->name, name))  /* correct label? */\n      return lb;\n  }\n  return NULL;  /* label not found */\n}\n\n\n/*\n** Adds a new label/goto in the corresponding list.\n*/\nstatic int newlabelentry (LexState *ls, Labellist *l, TString *name,\n                          int line, int pc) {\n  int n = l->n;\n  luaM_growvector(ls->L, l->arr, n, l->size,\n                  Labeldesc, SHRT_MAX, \"labels/gotos\");\n  l->arr[n].name = name;\n  l->arr[n].line = line;\n  l->arr[n].nactvar = ls->fs->nactvar;\n  l->arr[n].close = 0;\n  l->arr[n].pc = pc;\n  l->n = n + 1;\n  return n;\n}\n\n\nstatic int newgotoentry (LexState *ls, TString *name, int line, int pc) {\n  return newlabelentry(ls, &ls->dyd->gt, name, line, pc);\n}\n\n\n/*\n** Solves forward jumps. Check whether new label 'lb' matches any\n** pending gotos in current block and solves them. Return true\n** if any of the gotos need to close upvalues.\n*/\nstatic int solvegotos (LexState *ls, Labeldesc *lb) {\n  Labellist *gl = &ls->dyd->gt;\n  int i = ls->fs->bl->firstgoto;\n  int needsclose = 0;\n  while (i < gl->n) {\n    if (eqstr(gl->arr[i].name, lb->name)) {\n      needsclose |= gl->arr[i].close;\n      solvegoto(ls, i, lb);  /* will remove 'i' from the list */\n    }\n    else\n      i++;\n  }\n  return needsclose;\n}\n\n\n/*\n** Create a new label with the given 'name' at the given 'line'.\n** 'last' tells whether label is the last non-op statement in its\n** block. Solves all pending gotos to this new label and adds\n** a close instruction if necessary.\n** Returns true iff it added a close instruction.\n*/\nstatic int createlabel (LexState *ls, TString *name, int line,\n                        int last) {\n  FuncState *fs = ls->fs;\n  Labellist *ll = &ls->dyd->label;\n  int l = newlabelentry(ls, ll, name, line, luaK_getlabel(fs));\n  if (last) {  /* label is last no-op statement in the block? */\n    /* assume that locals are already out of scope */\n    ll->arr[l].nactvar = fs->bl->nactvar;\n  }\n  if (solvegotos(ls, &ll->arr[l])) {  /* need close? */\n    luaK_codeABC(fs, OP_CLOSE, luaY_nvarstack(fs), 0, 0);\n    return 1;\n  }\n  return 0;\n}\n\n\n/*\n** Adjust pending gotos to outer level of a block.\n*/\nstatic void movegotosout (FuncState *fs, BlockCnt *bl) {\n  int i;\n  Labellist *gl = &fs->ls->dyd->gt;\n  /* correct pending gotos to current block */\n  for (i = bl->firstgoto; i < gl->n; i++) {  /* for each pending goto */\n    Labeldesc *gt = &gl->arr[i];\n    /* leaving a variable scope? */\n    if (reglevel(fs, gt->nactvar) > reglevel(fs, bl->nactvar))\n      gt->close |= bl->upval;  /* jump may need a close */\n    gt->nactvar = bl->nactvar;  /* update goto level */\n  }\n}\n\n\nstatic void enterblock (FuncState *fs, BlockCnt *bl, lu_byte isloop) {\n  bl->isloop = isloop;\n  bl->nactvar = fs->nactvar;\n  bl->firstlabel = fs->ls->dyd->label.n;\n  bl->firstgoto = fs->ls->dyd->gt.n;\n  bl->upval = 0;\n  bl->insidetbc = (fs->bl != NULL && fs->bl->insidetbc);\n  bl->previous = fs->bl;\n  fs->bl = bl;\n  lua_assert(fs->freereg == luaY_nvarstack(fs));\n}\n\n\n/*\n** generates an error for an undefined 'goto'.\n*/\nstatic l_noret undefgoto (LexState *ls, Labeldesc *gt) {\n  const char *msg;\n  if (eqstr(gt->name, luaS_newliteral(ls->L, \"break\"))) {\n    msg = \"break outside loop at line %d\";\n    msg = luaO_pushfstring(ls->L, msg, gt->line);\n  }\n  else {\n    msg = \"no visible label '%s' for <goto> at line %d\";\n    msg = luaO_pushfstring(ls->L, msg, getstr(gt->name), gt->line);\n  }\n  luaK_semerror(ls, msg);\n}\n\n\nstatic void leaveblock (FuncState *fs) {\n  BlockCnt *bl = fs->bl;\n  LexState *ls = fs->ls;\n  int hasclose = 0;\n  lu_byte stklevel = reglevel(fs, bl->nactvar);  /* level outside the block */\n  removevars(fs, bl->nactvar);  /* remove block locals */\n  lua_assert(bl->nactvar == fs->nactvar);  /* back to level on entry */\n  if (bl->isloop)  /* has to fix pending breaks? */\n    hasclose = createlabel(ls, luaS_newliteral(ls->L, \"break\"), 0, 0);\n  if (!hasclose && bl->previous && bl->upval)  /* still need a 'close'? */\n    luaK_codeABC(fs, OP_CLOSE, stklevel, 0, 0);\n  fs->freereg = stklevel;  /* free registers */\n  ls->dyd->label.n = bl->firstlabel;  /* remove local labels */\n  fs->bl = bl->previous;  /* current block now is previous one */\n  if (bl->previous)  /* was it a nested block? */\n    movegotosout(fs, bl);  /* update pending gotos to enclosing block */\n  else {\n    if (bl->firstgoto < ls->dyd->gt.n)  /* still pending gotos? */\n      undefgoto(ls, &ls->dyd->gt.arr[bl->firstgoto]);  /* error */\n  }\n}\n\n\n/*\n** adds a new prototype into list of prototypes\n*/\nstatic Proto *addprototype (LexState *ls) {\n  Proto *clp;\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;  /* prototype of current function */\n  if (fs->np >= f->sizep) {\n    int oldsize = f->sizep;\n    luaM_growvector(L, f->p, fs->np, f->sizep, Proto *, MAXARG_Bx, \"functions\");\n    while (oldsize < f->sizep)\n      f->p[oldsize++] = NULL;\n  }\n  f->p[fs->np++] = clp = luaF_newproto(L);\n  luaC_objbarrier(L, f, clp);\n  return clp;\n}\n\n\n/*\n** codes instruction to create new closure in parent function.\n** The OP_CLOSURE instruction uses the last available register,\n** so that, if it invokes the GC, the GC knows which registers\n** are in use at that time.\n\n*/\nstatic void codeclosure (LexState *ls, expdesc *v) {\n  FuncState *fs = ls->fs->prev;\n  init_exp(v, VRELOC, luaK_codeABx(fs, OP_CLOSURE, 0, fs->np - 1));\n  luaK_exp2nextreg(fs, v);  /* fix it at the last register */\n}\n\n\nstatic void open_func (LexState *ls, FuncState *fs, BlockCnt *bl) {\n  Proto *f = fs->f;\n  fs->prev = ls->fs;  /* linked list of funcstates */\n  fs->ls = ls;\n  ls->fs = fs;\n  fs->pc = 0;\n  fs->previousline = f->linedefined;\n  fs->iwthabs = 0;\n  fs->lasttarget = 0;\n  fs->freereg = 0;\n  fs->nk = 0;\n  fs->nabslineinfo = 0;\n  fs->np = 0;\n  fs->nups = 0;\n  fs->ndebugvars = 0;\n  fs->nactvar = 0;\n  fs->needclose = 0;\n  fs->firstlocal = ls->dyd->actvar.n;\n  fs->firstlabel = ls->dyd->label.n;\n  fs->bl = NULL;\n  f->source = ls->source;\n  luaC_objbarrier(ls->L, f, f->source);\n  f->maxstacksize = 2;  /* registers 0/1 are always valid */\n  enterblock(fs, bl, 0);\n}\n\n\nstatic void close_func (LexState *ls) {\n  lua_State *L = ls->L;\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  luaK_ret(fs, luaY_nvarstack(fs), 0);  /* final return */\n  leaveblock(fs);\n  lua_assert(fs->bl == NULL);\n  luaK_finish(fs);\n  luaM_shrinkvector(L, f->code, f->sizecode, fs->pc, Instruction);\n  luaM_shrinkvector(L, f->lineinfo, f->sizelineinfo, fs->pc, ls_byte);\n  luaM_shrinkvector(L, f->abslineinfo, f->sizeabslineinfo,\n                       fs->nabslineinfo, AbsLineInfo);\n  luaM_shrinkvector(L, f->k, f->sizek, fs->nk, TValue);\n  luaM_shrinkvector(L, f->p, f->sizep, fs->np, Proto *);\n  luaM_shrinkvector(L, f->locvars, f->sizelocvars, fs->ndebugvars, LocVar);\n  luaM_shrinkvector(L, f->upvalues, f->sizeupvalues, fs->nups, Upvaldesc);\n  ls->fs = fs->prev;\n  luaC_checkGC(L);\n}\n\n\n\n/*============================================================*/\n/* GRAMMAR RULES */\n/*============================================================*/\n\n\n/*\n** check whether current token is in the follow set of a block.\n** 'until' closes syntactical blocks, but do not close scope,\n** so it is handled in separate.\n*/\nstatic int block_follow (LexState *ls, int withuntil) {\n  switch (ls->t.token) {\n    case TK_ELSE: case TK_ELSEIF:\n    case TK_END: case TK_EOS:\n      return 1;\n    case TK_UNTIL: return withuntil;\n    default: return 0;\n  }\n}\n\n\nstatic void statlist (LexState *ls) {\n  /* statlist -> { stat [';'] } */\n  while (!block_follow(ls, 1)) {\n    if (ls->t.token == TK_RETURN) {\n      statement(ls);\n      return;  /* 'return' must be last statement */\n    }\n    statement(ls);\n  }\n}\n\n\nstatic void fieldsel (LexState *ls, expdesc *v) {\n  /* fieldsel -> ['.' | ':'] NAME */\n  FuncState *fs = ls->fs;\n  expdesc key;\n  luaK_exp2anyregup(fs, v);\n  luaX_next(ls);  /* skip the dot or colon */\n  codename(ls, &key);\n  luaK_indexed(fs, v, &key);\n}\n\n\nstatic void yindex (LexState *ls, expdesc *v) {\n  /* index -> '[' expr ']' */\n  luaX_next(ls);  /* skip the '[' */\n  expr(ls, v);\n  luaK_exp2val(ls->fs, v);\n  checknext(ls, ']');\n}\n\n\n/*\n** {======================================================================\n** Rules for Constructors\n** =======================================================================\n*/\n\ntypedef struct ConsControl {\n  expdesc v;  /* last list item read */\n  expdesc *t;  /* table descriptor */\n  int nh;  /* total number of 'record' elements */\n  int na;  /* number of array elements already stored */\n  int tostore;  /* number of array elements pending to be stored */\n  int maxtostore;  /* maximum number of pending elements */\n} ConsControl;\n\n\nstatic void recfield (LexState *ls, ConsControl *cc) {\n  /* recfield -> (NAME | '['exp']') = exp */\n  FuncState *fs = ls->fs;\n  lu_byte reg = ls->fs->freereg;\n  expdesc tab, key, val;\n  if (ls->t.token == TK_NAME) {\n    luaY_checklimit(fs, cc->nh, INT_MAX / 2, \"items in a constructor\");\n    codename(ls, &key);\n  }\n  else  /* ls->t.token == '[' */\n    yindex(ls, &key);\n  cc->nh++;\n  checknext(ls, '=');\n  tab = *cc->t;\n  luaK_indexed(fs, &tab, &key);\n  expr(ls, &val);\n  luaK_storevar(fs, &tab, &val);\n  fs->freereg = reg;  /* free registers */\n}\n\n\nstatic void closelistfield (FuncState *fs, ConsControl *cc) {\n  if (cc->v.k == VVOID) return;  /* there is no list item */\n  luaK_exp2nextreg(fs, &cc->v);\n  cc->v.k = VVOID;\n  if (cc->tostore >= cc->maxtostore) {\n    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);  /* flush */\n    cc->na += cc->tostore;\n    cc->tostore = 0;  /* no more items pending */\n  }\n}\n\n\nstatic void lastlistfield (FuncState *fs, ConsControl *cc) {\n  if (cc->tostore == 0) return;\n  if (hasmultret(cc->v.k)) {\n    luaK_setmultret(fs, &cc->v);\n    luaK_setlist(fs, cc->t->u.info, cc->na, LUA_MULTRET);\n    cc->na--;  /* do not count last expression (unknown number of elements) */\n  }\n  else {\n    if (cc->v.k != VVOID)\n      luaK_exp2nextreg(fs, &cc->v);\n    luaK_setlist(fs, cc->t->u.info, cc->na, cc->tostore);\n  }\n  cc->na += cc->tostore;\n}\n\n\nstatic void listfield (LexState *ls, ConsControl *cc) {\n  /* listfield -> exp */\n  expr(ls, &cc->v);\n  cc->tostore++;\n}\n\n\nstatic void field (LexState *ls, ConsControl *cc) {\n  /* field -> listfield | recfield */\n  switch(ls->t.token) {\n    case TK_NAME: {  /* may be 'listfield' or 'recfield' */\n      if (luaX_lookahead(ls) != '=')  /* expression? */\n        listfield(ls, cc);\n      else\n        recfield(ls, cc);\n      break;\n    }\n    case '[': {\n      recfield(ls, cc);\n      break;\n    }\n    default: {\n      listfield(ls, cc);\n      break;\n    }\n  }\n}\n\n\n/*\n** Compute a limit for how many registers a constructor can use before\n** emitting a 'SETLIST' instruction, based on how many registers are\n** available.\n*/\nstatic int maxtostore (FuncState *fs) {\n  int numfreeregs = MAX_FSTACK - fs->freereg;\n  if (numfreeregs >= 160)  /* \"lots\" of registers? */\n    return numfreeregs / 5;  /* use up to 1/5 of them */\n  else if (numfreeregs >= 80)  /* still \"enough\" registers? */\n    return 10;  /* one 'SETLIST' instruction for each 10 values */\n  else  /* save registers for potential more nesting */\n    return 1;\n}\n\n\nstatic void constructor (LexState *ls, expdesc *t) {\n  /* constructor -> '{' [ field { sep field } [sep] ] '}'\n     sep -> ',' | ';' */\n  FuncState *fs = ls->fs;\n  int line = ls->linenumber;\n  int pc = luaK_codevABCk(fs, OP_NEWTABLE, 0, 0, 0, 0);\n  ConsControl cc;\n  luaK_code(fs, 0);  /* space for extra arg. */\n  cc.na = cc.nh = cc.tostore = 0;\n  cc.t = t;\n  init_exp(t, VNONRELOC, fs->freereg);  /* table will be at stack top */\n  luaK_reserveregs(fs, 1);\n  init_exp(&cc.v, VVOID, 0);  /* no value (yet) */\n  checknext(ls, '{');\n  cc.maxtostore = maxtostore(fs);\n  do {\n    lua_assert(cc.v.k == VVOID || cc.tostore > 0);\n    if (ls->t.token == '}') break;\n    closelistfield(fs, &cc);\n    field(ls, &cc);\n  } while (testnext(ls, ',') || testnext(ls, ';'));\n  check_match(ls, '}', '{', line);\n  lastlistfield(fs, &cc);\n  luaK_settablesize(fs, pc, t->u.info, cc.na, cc.nh);\n}\n\n/* }====================================================================== */\n\n\nstatic void setvararg (FuncState *fs, int nparams) {\n  fs->f->flag |= PF_ISVARARG;\n  luaK_codeABC(fs, OP_VARARGPREP, nparams, 0, 0);\n}\n\n\nstatic void parlist (LexState *ls) {\n  /* parlist -> [ {NAME ','} (NAME | '...') ] */\n  FuncState *fs = ls->fs;\n  Proto *f = fs->f;\n  int nparams = 0;\n  int isvararg = 0;\n  if (ls->t.token != ')') {  /* is 'parlist' not empty? */\n    do {\n      switch (ls->t.token) {\n        case TK_NAME: {\n          new_localvar(ls, str_checkname(ls));\n          nparams++;\n          break;\n        }\n        case TK_DOTS: {\n          luaX_next(ls);\n          isvararg = 1;\n          break;\n        }\n        default: luaX_syntaxerror(ls, \"<name> or '...' expected\");\n      }\n    } while (!isvararg && testnext(ls, ','));\n  }\n  adjustlocalvars(ls, nparams);\n  f->numparams = cast_byte(fs->nactvar);\n  if (isvararg)\n    setvararg(fs, f->numparams);  /* declared vararg */\n  luaK_reserveregs(fs, fs->nactvar);  /* reserve registers for parameters */\n}\n\n\nstatic void body (LexState *ls, expdesc *e, int ismethod, int line) {\n  /* body ->  '(' parlist ')' block END */\n  FuncState new_fs;\n  BlockCnt bl;\n  new_fs.f = addprototype(ls);\n  new_fs.f->linedefined = line;\n  open_func(ls, &new_fs, &bl);\n  checknext(ls, '(');\n  if (ismethod) {\n    new_localvarliteral(ls, \"self\");  /* create 'self' parameter */\n    adjustlocalvars(ls, 1);\n  }\n  parlist(ls);\n  checknext(ls, ')');\n  statlist(ls);\n  new_fs.f->lastlinedefined = ls->linenumber;\n  check_match(ls, TK_END, TK_FUNCTION, line);\n  codeclosure(ls, e);\n  close_func(ls);\n}\n\n\nstatic int explist (LexState *ls, expdesc *v) {\n  /* explist -> expr { ',' expr } */\n  int n = 1;  /* at least one expression */\n  expr(ls, v);\n  while (testnext(ls, ',')) {\n    luaK_exp2nextreg(ls->fs, v);\n    expr(ls, v);\n    n++;\n  }\n  return n;\n}\n\n\nstatic void funcargs (LexState *ls, expdesc *f) {\n  FuncState *fs = ls->fs;\n  expdesc args;\n  int base, nparams;\n  int line = ls->linenumber;\n  switch (ls->t.token) {\n    case '(': {  /* funcargs -> '(' [ explist ] ')' */\n      luaX_next(ls);\n      if (ls->t.token == ')')  /* arg list is empty? */\n        args.k = VVOID;\n      else {\n        explist(ls, &args);\n        if (hasmultret(args.k))\n          luaK_setmultret(fs, &args);\n      }\n      check_match(ls, ')', '(', line);\n      break;\n    }\n    case '{': {  /* funcargs -> constructor */\n      constructor(ls, &args);\n      break;\n    }\n    case TK_STRING: {  /* funcargs -> STRING */\n      codestring(&args, ls->t.seminfo.ts);\n      luaX_next(ls);  /* must use 'seminfo' before 'next' */\n      break;\n    }\n    default: {\n      luaX_syntaxerror(ls, \"function arguments expected\");\n    }\n  }\n  lua_assert(f->k == VNONRELOC);\n  base = f->u.info;  /* base register for call */\n  if (hasmultret(args.k))\n    nparams = LUA_MULTRET;  /* open call */\n  else {\n    if (args.k != VVOID)\n      luaK_exp2nextreg(fs, &args);  /* close last argument */\n    nparams = fs->freereg - (base+1);\n  }\n  init_exp(f, VCALL, luaK_codeABC(fs, OP_CALL, base, nparams+1, 2));\n  luaK_fixline(fs, line);\n  /* call removes function and arguments and leaves one result (unless\n     changed later) */\n  fs->freereg = cast_byte(base + 1);\n}\n\n\n\n\n/*\n** {======================================================================\n** Expression parsing\n** =======================================================================\n*/\n\n\nstatic void primaryexp (LexState *ls, expdesc *v) {\n  /* primaryexp -> NAME | '(' expr ')' */\n  switch (ls->t.token) {\n    case '(': {\n      int line = ls->linenumber;\n      luaX_next(ls);\n      expr(ls, v);\n      check_match(ls, ')', '(', line);\n      luaK_dischargevars(ls->fs, v);\n      return;\n    }\n    case TK_NAME: {\n      singlevar(ls, v);\n      return;\n    }\n    default: {\n      luaX_syntaxerror(ls, \"unexpected symbol\");\n    }\n  }\n}\n\n\nstatic void suffixedexp (LexState *ls, expdesc *v) {\n  /* suffixedexp ->\n       primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */\n  FuncState *fs = ls->fs;\n  primaryexp(ls, v);\n  for (;;) {\n    switch (ls->t.token) {\n      case '.': {  /* fieldsel */\n        fieldsel(ls, v);\n        break;\n      }\n      case '[': {  /* '[' exp ']' */\n        expdesc key;\n        luaK_exp2anyregup(fs, v);\n        yindex(ls, &key);\n        luaK_indexed(fs, v, &key);\n        break;\n      }\n      case ':': {  /* ':' NAME funcargs */\n        expdesc key;\n        luaX_next(ls);\n        codename(ls, &key);\n        luaK_self(fs, v, &key);\n        funcargs(ls, v);\n        break;\n      }\n      case '(': case TK_STRING: case '{': {  /* funcargs */\n        luaK_exp2nextreg(fs, v);\n        funcargs(ls, v);\n        break;\n      }\n      default: return;\n    }\n  }\n}\n\n\nstatic void simpleexp (LexState *ls, expdesc *v) {\n  /* simpleexp -> FLT | INT | STRING | NIL | TRUE | FALSE | ... |\n                  constructor | FUNCTION body | suffixedexp */\n  switch (ls->t.token) {\n    case TK_FLT: {\n      init_exp(v, VKFLT, 0);\n      v->u.nval = ls->t.seminfo.r;\n      break;\n    }\n    case TK_INT: {\n      init_exp(v, VKINT, 0);\n      v->u.ival = ls->t.seminfo.i;\n      break;\n    }\n    case TK_STRING: {\n      codestring(v, ls->t.seminfo.ts);\n      break;\n    }\n    case TK_NIL: {\n      init_exp(v, VNIL, 0);\n      break;\n    }\n    case TK_TRUE: {\n      init_exp(v, VTRUE, 0);\n      break;\n    }\n    case TK_FALSE: {\n      init_exp(v, VFALSE, 0);\n      break;\n    }\n    case TK_DOTS: {  /* vararg */\n      FuncState *fs = ls->fs;\n      check_condition(ls, fs->f->flag & PF_ISVARARG,\n                      \"cannot use '...' outside a vararg function\");\n      init_exp(v, VVARARG, luaK_codeABC(fs, OP_VARARG, 0, 0, 1));\n      break;\n    }\n    case '{': {  /* constructor */\n      constructor(ls, v);\n      return;\n    }\n    case TK_FUNCTION: {\n      luaX_next(ls);\n      body(ls, v, 0, ls->linenumber);\n      return;\n    }\n    default: {\n      suffixedexp(ls, v);\n      return;\n    }\n  }\n  luaX_next(ls);\n}\n\n\nstatic UnOpr getunopr (int op) {\n  switch (op) {\n    case TK_NOT: return OPR_NOT;\n    case '-': return OPR_MINUS;\n    case '~': return OPR_BNOT;\n    case '#': return OPR_LEN;\n    default: return OPR_NOUNOPR;\n  }\n}\n\n\nstatic BinOpr getbinopr (int op) {\n  switch (op) {\n    case '+': return OPR_ADD;\n    case '-': return OPR_SUB;\n    case '*': return OPR_MUL;\n    case '%': return OPR_MOD;\n    case '^': return OPR_POW;\n    case '/': return OPR_DIV;\n    case TK_IDIV: return OPR_IDIV;\n    case '&': return OPR_BAND;\n    case '|': return OPR_BOR;\n    case '~': return OPR_BXOR;\n    case TK_SHL: return OPR_SHL;\n    case TK_SHR: return OPR_SHR;\n    case TK_CONCAT: return OPR_CONCAT;\n    case TK_NE: return OPR_NE;\n    case TK_EQ: return OPR_EQ;\n    case '<': return OPR_LT;\n    case TK_LE: return OPR_LE;\n    case '>': return OPR_GT;\n    case TK_GE: return OPR_GE;\n    case TK_AND: return OPR_AND;\n    case TK_OR: return OPR_OR;\n    default: return OPR_NOBINOPR;\n  }\n}\n\n\n/*\n** Priority table for binary operators.\n*/\nstatic const struct {\n  lu_byte left;  /* left priority for each binary operator */\n  lu_byte right; /* right priority */\n} priority[] = {  /* ORDER OPR */\n   {10, 10}, {10, 10},           /* '+' '-' */\n   {11, 11}, {11, 11},           /* '*' '%' */\n   {14, 13},                  /* '^' (right associative) */\n   {11, 11}, {11, 11},           /* '/' '//' */\n   {6, 6}, {4, 4}, {5, 5},   /* '&' '|' '~' */\n   {7, 7}, {7, 7},           /* '<<' '>>' */\n   {9, 8},                   /* '..' (right associative) */\n   {3, 3}, {3, 3}, {3, 3},   /* ==, <, <= */\n   {3, 3}, {3, 3}, {3, 3},   /* ~=, >, >= */\n   {2, 2}, {1, 1}            /* and, or */\n};\n\n#define UNARY_PRIORITY\t12  /* priority for unary operators */\n\n\n/*\n** subexpr -> (simpleexp | unop subexpr) { binop subexpr }\n** where 'binop' is any binary operator with a priority higher than 'limit'\n*/\nstatic BinOpr subexpr (LexState *ls, expdesc *v, int limit) {\n  BinOpr op;\n  UnOpr uop;\n  enterlevel(ls);\n  uop = getunopr(ls->t.token);\n  if (uop != OPR_NOUNOPR) {  /* prefix (unary) operator? */\n    int line = ls->linenumber;\n    luaX_next(ls);  /* skip operator */\n    subexpr(ls, v, UNARY_PRIORITY);\n    luaK_prefix(ls->fs, uop, v, line);\n  }\n  else simpleexp(ls, v);\n  /* expand while operators have priorities higher than 'limit' */\n  op = getbinopr(ls->t.token);\n  while (op != OPR_NOBINOPR && priority[op].left > limit) {\n    expdesc v2;\n    BinOpr nextop;\n    int line = ls->linenumber;\n    luaX_next(ls);  /* skip operator */\n    luaK_infix(ls->fs, op, v);\n    /* read sub-expression with higher priority */\n    nextop = subexpr(ls, &v2, priority[op].right);\n    luaK_posfix(ls->fs, op, v, &v2, line);\n    op = nextop;\n  }\n  leavelevel(ls);\n  return op;  /* return first untreated operator */\n}\n\n\nstatic void expr (LexState *ls, expdesc *v) {\n  subexpr(ls, v, 0);\n}\n\n/* }==================================================================== */\n\n\n\n/*\n** {======================================================================\n** Rules for Statements\n** =======================================================================\n*/\n\n\nstatic void block (LexState *ls) {\n  /* block -> statlist */\n  FuncState *fs = ls->fs;\n  BlockCnt bl;\n  enterblock(fs, &bl, 0);\n  statlist(ls);\n  leaveblock(fs);\n}\n\n\n/*\n** structure to chain all variables in the left-hand side of an\n** assignment\n*/\nstruct LHS_assign {\n  struct LHS_assign *prev;\n  expdesc v;  /* variable (global, local, upvalue, or indexed) */\n};\n\n\n/*\n** check whether, in an assignment to an upvalue/local variable, the\n** upvalue/local variable is begin used in a previous assignment to a\n** table. If so, save original upvalue/local value in a safe place and\n** use this safe copy in the previous assignment.\n*/\nstatic void check_conflict (LexState *ls, struct LHS_assign *lh, expdesc *v) {\n  FuncState *fs = ls->fs;\n  lu_byte extra = fs->freereg;  /* eventual position to save local variable */\n  int conflict = 0;\n  for (; lh; lh = lh->prev) {  /* check all previous assignments */\n    if (vkisindexed(lh->v.k)) {  /* assignment to table field? */\n      if (lh->v.k == VINDEXUP) {  /* is table an upvalue? */\n        if (v->k == VUPVAL && lh->v.u.ind.t == v->u.info) {\n          conflict = 1;  /* table is the upvalue being assigned now */\n          lh->v.k = VINDEXSTR;\n          lh->v.u.ind.t = extra;  /* assignment will use safe copy */\n        }\n      }\n      else {  /* table is a register */\n        if (v->k == VLOCAL && lh->v.u.ind.t == v->u.var.ridx) {\n          conflict = 1;  /* table is the local being assigned now */\n          lh->v.u.ind.t = extra;  /* assignment will use safe copy */\n        }\n        /* is index the local being assigned? */\n        if (lh->v.k == VINDEXED && v->k == VLOCAL &&\n            lh->v.u.ind.idx == v->u.var.ridx) {\n          conflict = 1;\n          lh->v.u.ind.idx = extra;  /* previous assignment will use safe copy */\n        }\n      }\n    }\n  }\n  if (conflict) {\n    /* copy upvalue/local value to a temporary (in position 'extra') */\n    if (v->k == VLOCAL)\n      luaK_codeABC(fs, OP_MOVE, extra, v->u.var.ridx, 0);\n    else\n      luaK_codeABC(fs, OP_GETUPVAL, extra, v->u.info, 0);\n    luaK_reserveregs(fs, 1);\n  }\n}\n\n/*\n** Parse and compile a multiple assignment. The first \"variable\"\n** (a 'suffixedexp') was already read by the caller.\n**\n** assignment -> suffixedexp restassign\n** restassign -> ',' suffixedexp restassign | '=' explist\n*/\nstatic void restassign (LexState *ls, struct LHS_assign *lh, int nvars) {\n  expdesc e;\n  check_condition(ls, vkisvar(lh->v.k), \"syntax error\");\n  check_readonly(ls, &lh->v);\n  if (testnext(ls, ',')) {  /* restassign -> ',' suffixedexp restassign */\n    struct LHS_assign nv;\n    nv.prev = lh;\n    suffixedexp(ls, &nv.v);\n    if (!vkisindexed(nv.v.k))\n      check_conflict(ls, lh, &nv.v);\n    enterlevel(ls);  /* control recursion depth */\n    restassign(ls, &nv, nvars+1);\n    leavelevel(ls);\n  }\n  else {  /* restassign -> '=' explist */\n    int nexps;\n    checknext(ls, '=');\n    nexps = explist(ls, &e);\n    if (nexps != nvars)\n      adjust_assign(ls, nvars, nexps, &e);\n    else {\n      luaK_setoneret(ls->fs, &e);  /* close last expression */\n      luaK_storevar(ls->fs, &lh->v, &e);\n      return;  /* avoid default */\n    }\n  }\n  init_exp(&e, VNONRELOC, ls->fs->freereg-1);  /* default assignment */\n  luaK_storevar(ls->fs, &lh->v, &e);\n}\n\n\nstatic int cond (LexState *ls) {\n  /* cond -> exp */\n  expdesc v;\n  expr(ls, &v);  /* read condition */\n  if (v.k == VNIL) v.k = VFALSE;  /* 'falses' are all equal here */\n  luaK_goiftrue(ls->fs, &v);\n  return v.f;\n}\n\n\nstatic void gotostat (LexState *ls) {\n  FuncState *fs = ls->fs;\n  int line = ls->linenumber;\n  TString *name = str_checkname(ls);  /* label's name */\n  Labeldesc *lb = findlabel(ls, name);\n  if (lb == NULL)  /* no label? */\n    /* forward jump; will be resolved when the label is declared */\n    newgotoentry(ls, name, line, luaK_jump(fs));\n  else {  /* found a label */\n    /* backward jump; will be resolved here */\n    int lblevel = reglevel(fs, lb->nactvar);  /* label level */\n    if (luaY_nvarstack(fs) > lblevel)  /* leaving the scope of a variable? */\n      luaK_codeABC(fs, OP_CLOSE, lblevel, 0, 0);\n    /* create jump and link it to the label */\n    luaK_patchlist(fs, luaK_jump(fs), lb->pc);\n  }\n}\n\n\n/*\n** Break statement. Semantically equivalent to \"goto break\".\n*/\nstatic void breakstat (LexState *ls) {\n  int line = ls->linenumber;\n  luaX_next(ls);  /* skip break */\n  newgotoentry(ls, luaS_newliteral(ls->L, \"break\"), line, luaK_jump(ls->fs));\n}\n\n\n/*\n** Check whether there is already a label with the given 'name'.\n*/\nstatic void checkrepeated (LexState *ls, TString *name) {\n  Labeldesc *lb = findlabel(ls, name);\n  if (l_unlikely(lb != NULL)) {  /* already defined? */\n    const char *msg = \"label '%s' already defined on line %d\";\n    msg = luaO_pushfstring(ls->L, msg, getstr(name), lb->line);\n    luaK_semerror(ls, msg);  /* error */\n  }\n}\n\n\nstatic void labelstat (LexState *ls, TString *name, int line) {\n  /* label -> '::' NAME '::' */\n  checknext(ls, TK_DBCOLON);  /* skip double colon */\n  while (ls->t.token == ';' || ls->t.token == TK_DBCOLON)\n    statement(ls);  /* skip other no-op statements */\n  checkrepeated(ls, name);  /* check for repeated labels */\n  createlabel(ls, name, line, block_follow(ls, 0));\n}\n\n\nstatic void whilestat (LexState *ls, int line) {\n  /* whilestat -> WHILE cond DO block END */\n  FuncState *fs = ls->fs;\n  int whileinit;\n  int condexit;\n  BlockCnt bl;\n  luaX_next(ls);  /* skip WHILE */\n  whileinit = luaK_getlabel(fs);\n  condexit = cond(ls);\n  enterblock(fs, &bl, 1);\n  checknext(ls, TK_DO);\n  block(ls);\n  luaK_jumpto(fs, whileinit);\n  check_match(ls, TK_END, TK_WHILE, line);\n  leaveblock(fs);\n  luaK_patchtohere(fs, condexit);  /* false conditions finish the loop */\n}\n\n\nstatic void repeatstat (LexState *ls, int line) {\n  /* repeatstat -> REPEAT block UNTIL cond */\n  int condexit;\n  FuncState *fs = ls->fs;\n  int repeat_init = luaK_getlabel(fs);\n  BlockCnt bl1, bl2;\n  enterblock(fs, &bl1, 1);  /* loop block */\n  enterblock(fs, &bl2, 0);  /* scope block */\n  luaX_next(ls);  /* skip REPEAT */\n  statlist(ls);\n  check_match(ls, TK_UNTIL, TK_REPEAT, line);\n  condexit = cond(ls);  /* read condition (inside scope block) */\n  leaveblock(fs);  /* finish scope */\n  if (bl2.upval) {  /* upvalues? */\n    int exit = luaK_jump(fs);  /* normal exit must jump over fix */\n    luaK_patchtohere(fs, condexit);  /* repetition must close upvalues */\n    luaK_codeABC(fs, OP_CLOSE, reglevel(fs, bl2.nactvar), 0, 0);\n    condexit = luaK_jump(fs);  /* repeat after closing upvalues */\n    luaK_patchtohere(fs, exit);  /* normal exit comes to here */\n  }\n  luaK_patchlist(fs, condexit, repeat_init);  /* close the loop */\n  leaveblock(fs);  /* finish loop */\n}\n\n\n/*\n** Read an expression and generate code to put its results in next\n** stack slot.\n**\n*/\nstatic void exp1 (LexState *ls) {\n  expdesc e;\n  expr(ls, &e);\n  luaK_exp2nextreg(ls->fs, &e);\n  lua_assert(e.k == VNONRELOC);\n}\n\n\n/*\n** Fix for instruction at position 'pc' to jump to 'dest'.\n** (Jump addresses are relative in Lua). 'back' true means\n** a back jump.\n*/\nstatic void fixforjump (FuncState *fs, int pc, int dest, int back) {\n  Instruction *jmp = &fs->f->code[pc];\n  int offset = dest - (pc + 1);\n  if (back)\n    offset = -offset;\n  if (l_unlikely(offset > MAXARG_Bx))\n    luaX_syntaxerror(fs->ls, \"control structure too long\");\n  SETARG_Bx(*jmp, offset);\n}\n\n\n/*\n** Generate code for a 'for' loop.\n*/\nstatic void forbody (LexState *ls, int base, int line, int nvars, int isgen) {\n  /* forbody -> DO block */\n  static const OpCode forprep[2] = {OP_FORPREP, OP_TFORPREP};\n  static const OpCode forloop[2] = {OP_FORLOOP, OP_TFORLOOP};\n  BlockCnt bl;\n  FuncState *fs = ls->fs;\n  int prep, endfor;\n  checknext(ls, TK_DO);\n  prep = luaK_codeABx(fs, forprep[isgen], base, 0);\n  fs->freereg--;  /* both 'forprep' remove one register from the stack */\n  enterblock(fs, &bl, 0);  /* scope for declared variables */\n  adjustlocalvars(ls, nvars);\n  luaK_reserveregs(fs, nvars);\n  block(ls);\n  leaveblock(fs);  /* end of scope for declared variables */\n  fixforjump(fs, prep, luaK_getlabel(fs), 0);\n  if (isgen) {  /* generic for? */\n    luaK_codeABC(fs, OP_TFORCALL, base, 0, nvars);\n    luaK_fixline(fs, line);\n  }\n  endfor = luaK_codeABx(fs, forloop[isgen], base, 0);\n  fixforjump(fs, endfor, prep + 1, 1);\n  luaK_fixline(fs, line);\n}\n\n\nstatic void fornum (LexState *ls, TString *varname, int line) {\n  /* fornum -> NAME = exp,exp[,exp] forbody */\n  FuncState *fs = ls->fs;\n  int base = fs->freereg;\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarliteral(ls, \"(for state)\");\n  new_localvarkind(ls, varname, RDKCONST);  /* control variable */\n  checknext(ls, '=');\n  exp1(ls);  /* initial value */\n  checknext(ls, ',');\n  exp1(ls);  /* limit */\n  if (testnext(ls, ','))\n    exp1(ls);  /* optional step */\n  else {  /* default step = 1 */\n    luaK_int(fs, fs->freereg, 1);\n    luaK_reserveregs(fs, 1);\n  }\n  adjustlocalvars(ls, 2);  /* start scope for internal variables */\n  forbody(ls, base, line, 1, 0);\n}\n\n\nstatic void forlist (LexState *ls, TString *indexname) {\n  /* forlist -> NAME {,NAME} IN explist forbody */\n  FuncState *fs = ls->fs;\n  expdesc e;\n  int nvars = 4;  /* function, state, closing, control */\n  int line;\n  int base = fs->freereg;\n  /* create internal variables */\n  new_localvarliteral(ls, \"(for state)\");  /* iterator function */\n  new_localvarliteral(ls, \"(for state)\");  /* state */\n  new_localvarliteral(ls, \"(for state)\");  /* closing var. (after swap) */\n  new_localvarkind(ls, indexname, RDKCONST);  /* control variable */\n  /* other declared variables */\n  while (testnext(ls, ',')) {\n    new_localvar(ls, str_checkname(ls));\n    nvars++;\n  }\n  checknext(ls, TK_IN);\n  line = ls->linenumber;\n  adjust_assign(ls, 4, explist(ls, &e), &e);\n  adjustlocalvars(ls, 3);  /* start scope for internal variables */\n  marktobeclosed(fs);  /* last internal var. must be closed */\n  luaK_checkstack(fs, 2);  /* extra space to call iterator */\n  forbody(ls, base, line, nvars - 3, 1);\n}\n\n\nstatic void forstat (LexState *ls, int line) {\n  /* forstat -> FOR (fornum | forlist) END */\n  FuncState *fs = ls->fs;\n  TString *varname;\n  BlockCnt bl;\n  enterblock(fs, &bl, 1);  /* scope for loop and control variables */\n  luaX_next(ls);  /* skip 'for' */\n  varname = str_checkname(ls);  /* first variable name */\n  switch (ls->t.token) {\n    case '=': fornum(ls, varname, line); break;\n    case ',': case TK_IN: forlist(ls, varname); break;\n    default: luaX_syntaxerror(ls, \"'=' or 'in' expected\");\n  }\n  check_match(ls, TK_END, TK_FOR, line);\n  leaveblock(fs);  /* loop scope ('break' jumps to this point) */\n}\n\n\nstatic void test_then_block (LexState *ls, int *escapelist) {\n  /* test_then_block -> [IF | ELSEIF] cond THEN block */\n  BlockCnt bl;\n  FuncState *fs = ls->fs;\n  expdesc v;\n  int jf;  /* instruction to skip 'then' code (if condition is false) */\n  luaX_next(ls);  /* skip IF or ELSEIF */\n  expr(ls, &v);  /* read condition */\n  checknext(ls, TK_THEN);\n  if (ls->t.token == TK_BREAK) {  /* 'if x then break' ? */\n    int line = ls->linenumber;\n    luaK_goiffalse(ls->fs, &v);  /* will jump if condition is true */\n    luaX_next(ls);  /* skip 'break' */\n    enterblock(fs, &bl, 0);  /* must enter block before 'goto' */\n    newgotoentry(ls, luaS_newliteral(ls->L, \"break\"), line, v.t);\n    while (testnext(ls, ';')) {}  /* skip semicolons */\n    if (block_follow(ls, 0)) {  /* jump is the entire block? */\n      leaveblock(fs);\n      return;  /* and that is it */\n    }\n    else  /* must skip over 'then' part if condition is false */\n      jf = luaK_jump(fs);\n  }\n  else {  /* regular case (not a break) */\n    luaK_goiftrue(ls->fs, &v);  /* skip over block if condition is false */\n    enterblock(fs, &bl, 0);\n    jf = v.f;\n  }\n  statlist(ls);  /* 'then' part */\n  leaveblock(fs);\n  if (ls->t.token == TK_ELSE ||\n      ls->t.token == TK_ELSEIF)  /* followed by 'else'/'elseif'? */\n    luaK_concat(fs, escapelist, luaK_jump(fs));  /* must jump over it */\n  luaK_patchtohere(fs, jf);\n}\n\n\nstatic void ifstat (LexState *ls, int line) {\n  /* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */\n  FuncState *fs = ls->fs;\n  int escapelist = NO_JUMP;  /* exit list for finished parts */\n  test_then_block(ls, &escapelist);  /* IF cond THEN block */\n  while (ls->t.token == TK_ELSEIF)\n    test_then_block(ls, &escapelist);  /* ELSEIF cond THEN block */\n  if (testnext(ls, TK_ELSE))\n    block(ls);  /* 'else' part */\n  check_match(ls, TK_END, TK_IF, line);\n  luaK_patchtohere(fs, escapelist);  /* patch escape list to 'if' end */\n}\n\n\nstatic void localfunc (LexState *ls) {\n  expdesc b;\n  FuncState *fs = ls->fs;\n  int fvar = fs->nactvar;  /* function's variable index */\n  new_localvar(ls, str_checkname(ls));  /* new local variable */\n  adjustlocalvars(ls, 1);  /* enter its scope */\n  body(ls, &b, 0, ls->linenumber);  /* function created in next register */\n  /* debug information will only see the variable after this point! */\n  localdebuginfo(fs, fvar)->startpc = fs->pc;\n}\n\n\nstatic lu_byte getlocalattribute (LexState *ls) {\n  /* ATTRIB -> ['<' Name '>'] */\n  if (testnext(ls, '<')) {\n    TString *ts = str_checkname(ls);\n    const char *attr = getstr(ts);\n    checknext(ls, '>');\n    if (strcmp(attr, \"const\") == 0)\n      return RDKCONST;  /* read-only variable */\n    else if (strcmp(attr, \"close\") == 0)\n      return RDKTOCLOSE;  /* to-be-closed variable */\n    else\n      luaK_semerror(ls,\n        luaO_pushfstring(ls->L, \"unknown attribute '%s'\", attr));\n  }\n  return VDKREG;  /* regular variable */\n}\n\n\nstatic void checktoclose (FuncState *fs, int level) {\n  if (level != -1) {  /* is there a to-be-closed variable? */\n    marktobeclosed(fs);\n    luaK_codeABC(fs, OP_TBC, reglevel(fs, level), 0, 0);\n  }\n}\n\n\nstatic void localstat (LexState *ls) {\n  /* stat -> LOCAL NAME ATTRIB { ',' NAME ATTRIB } ['=' explist] */\n  FuncState *fs = ls->fs;\n  int toclose = -1;  /* index of to-be-closed variable (if any) */\n  Vardesc *var;  /* last variable */\n  int vidx;  /* index of last variable */\n  int nvars = 0;\n  int nexps;\n  expdesc e;\n  do {\n    TString *vname = str_checkname(ls);\n    lu_byte kind = getlocalattribute(ls);\n    vidx = new_localvarkind(ls, vname, kind);\n    if (kind == RDKTOCLOSE) {  /* to-be-closed? */\n      if (toclose != -1)  /* one already present? */\n        luaK_semerror(ls, \"multiple to-be-closed variables in local list\");\n      toclose = fs->nactvar + nvars;\n    }\n    nvars++;\n  } while (testnext(ls, ','));\n  if (testnext(ls, '='))\n    nexps = explist(ls, &e);\n  else {\n    e.k = VVOID;\n    nexps = 0;\n  }\n  var = getlocalvardesc(fs, vidx);  /* get last variable */\n  if (nvars == nexps &&  /* no adjustments? */\n      var->vd.kind == RDKCONST &&  /* last variable is const? */\n      luaK_exp2const(fs, &e, &var->k)) {  /* compile-time constant? */\n    var->vd.kind = RDKCTC;  /* variable is a compile-time constant */\n    adjustlocalvars(ls, nvars - 1);  /* exclude last variable */\n    fs->nactvar++;  /* but count it */\n  }\n  else {\n    adjust_assign(ls, nvars, nexps, &e);\n    adjustlocalvars(ls, nvars);\n  }\n  checktoclose(fs, toclose);\n}\n\n\nstatic int funcname (LexState *ls, expdesc *v) {\n  /* funcname -> NAME {fieldsel} [':' NAME] */\n  int ismethod = 0;\n  singlevar(ls, v);\n  while (ls->t.token == '.')\n    fieldsel(ls, v);\n  if (ls->t.token == ':') {\n    ismethod = 1;\n    fieldsel(ls, v);\n  }\n  return ismethod;\n}\n\n\nstatic void funcstat (LexState *ls, int line) {\n  /* funcstat -> FUNCTION funcname body */\n  int ismethod;\n  expdesc v, b;\n  luaX_next(ls);  /* skip FUNCTION */\n  ismethod = funcname(ls, &v);\n  body(ls, &b, ismethod, line);\n  check_readonly(ls, &v);\n  luaK_storevar(ls->fs, &v, &b);\n  luaK_fixline(ls->fs, line);  /* definition \"happens\" in the first line */\n}\n\n\nstatic void exprstat (LexState *ls) {\n  /* stat -> func | assignment */\n  FuncState *fs = ls->fs;\n  struct LHS_assign v;\n  suffixedexp(ls, &v.v);\n  if (ls->t.token == '=' || ls->t.token == ',') { /* stat -> assignment ? */\n    v.prev = NULL;\n    restassign(ls, &v, 1);\n  }\n  else {  /* stat -> func */\n    Instruction *inst;\n    check_condition(ls, v.v.k == VCALL, \"syntax error\");\n    inst = &getinstruction(fs, &v.v);\n    SETARG_C(*inst, 1);  /* call statement uses no results */\n  }\n}\n\n\nstatic void retstat (LexState *ls) {\n  /* stat -> RETURN [explist] [';'] */\n  FuncState *fs = ls->fs;\n  expdesc e;\n  int nret;  /* number of values being returned */\n  int first = luaY_nvarstack(fs);  /* first slot to be returned */\n  if (block_follow(ls, 1) || ls->t.token == ';')\n    nret = 0;  /* return no values */\n  else {\n    nret = explist(ls, &e);  /* optional return values */\n    if (hasmultret(e.k)) {\n      luaK_setmultret(fs, &e);\n      if (e.k == VCALL && nret == 1 && !fs->bl->insidetbc) {  /* tail call? */\n        SET_OPCODE(getinstruction(fs,&e), OP_TAILCALL);\n        lua_assert(GETARG_A(getinstruction(fs,&e)) == luaY_nvarstack(fs));\n      }\n      nret = LUA_MULTRET;  /* return all values */\n    }\n    else {\n      if (nret == 1)  /* only one single value? */\n        first = luaK_exp2anyreg(fs, &e);  /* can use original slot */\n      else {  /* values must go to the top of the stack */\n        luaK_exp2nextreg(fs, &e);\n        lua_assert(nret == fs->freereg - first);\n      }\n    }\n  }\n  luaK_ret(fs, first, nret);\n  testnext(ls, ';');  /* skip optional semicolon */\n}\n\n\nstatic void statement (LexState *ls) {\n  int line = ls->linenumber;  /* may be needed for error messages */\n  enterlevel(ls);\n  switch (ls->t.token) {\n    case ';': {  /* stat -> ';' (empty statement) */\n      luaX_next(ls);  /* skip ';' */\n      break;\n    }\n    case TK_IF: {  /* stat -> ifstat */\n      ifstat(ls, line);\n      break;\n    }\n    case TK_WHILE: {  /* stat -> whilestat */\n      whilestat(ls, line);\n      break;\n    }\n    case TK_DO: {  /* stat -> DO block END */\n      luaX_next(ls);  /* skip DO */\n      block(ls);\n      check_match(ls, TK_END, TK_DO, line);\n      break;\n    }\n    case TK_FOR: {  /* stat -> forstat */\n      forstat(ls, line);\n      break;\n    }\n    case TK_REPEAT: {  /* stat -> repeatstat */\n      repeatstat(ls, line);\n      break;\n    }\n    case TK_FUNCTION: {  /* stat -> funcstat */\n      funcstat(ls, line);\n      break;\n    }\n    case TK_LOCAL: {  /* stat -> localstat */\n      luaX_next(ls);  /* skip LOCAL */\n      if (testnext(ls, TK_FUNCTION))  /* local function? */\n        localfunc(ls);\n      else\n        localstat(ls);\n      break;\n    }\n    case TK_DBCOLON: {  /* stat -> label */\n      luaX_next(ls);  /* skip double colon */\n      labelstat(ls, str_checkname(ls), line);\n      break;\n    }\n    case TK_RETURN: {  /* stat -> retstat */\n      luaX_next(ls);  /* skip RETURN */\n      retstat(ls);\n      break;\n    }\n    case TK_BREAK: {  /* stat -> breakstat */\n      breakstat(ls);\n      break;\n    }\n    case TK_GOTO: {  /* stat -> 'goto' NAME */\n      luaX_next(ls);  /* skip 'goto' */\n      gotostat(ls);\n      break;\n    }\n    default: {  /* stat -> func | assignment */\n      exprstat(ls);\n      break;\n    }\n  }\n  lua_assert(ls->fs->f->maxstacksize >= ls->fs->freereg &&\n             ls->fs->freereg >= luaY_nvarstack(ls->fs));\n  ls->fs->freereg = luaY_nvarstack(ls->fs);  /* free registers */\n  leavelevel(ls);\n}\n\n/* }====================================================================== */\n\n\n/*\n** compiles the main function, which is a regular vararg function with an\n** upvalue named LUA_ENV\n*/\nstatic void mainfunc (LexState *ls, FuncState *fs) {\n  BlockCnt bl;\n  Upvaldesc *env;\n  open_func(ls, fs, &bl);\n  setvararg(fs, 0);  /* main function is always declared vararg */\n  env = allocupvalue(fs);  /* ...set environment upvalue */\n  env->instack = 1;\n  env->idx = 0;\n  env->kind = VDKREG;\n  env->name = ls->envn;\n  luaC_objbarrier(ls->L, fs->f, env->name);\n  luaX_next(ls);  /* read first token */\n  statlist(ls);  /* parse main body */\n  check(ls, TK_EOS);\n  close_func(ls);\n}\n\n\nLClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,\n                       Dyndata *dyd, const char *name, int firstchar) {\n  LexState lexstate;\n  FuncState funcstate;\n  LClosure *cl = luaF_newLclosure(L, 1);  /* create main closure */\n  setclLvalue2s(L, L->top.p, cl);  /* anchor it (to avoid being collected) */\n  luaD_inctop(L);\n  lexstate.h = luaH_new(L);  /* create table for scanner */\n  sethvalue2s(L, L->top.p, lexstate.h);  /* anchor it */\n  luaD_inctop(L);\n  funcstate.f = cl->p = luaF_newproto(L);\n  luaC_objbarrier(L, cl, cl->p);\n  funcstate.f->source = luaS_new(L, name);  /* create and anchor TString */\n  luaC_objbarrier(L, funcstate.f, funcstate.f->source);\n  lexstate.buff = buff;\n  lexstate.dyd = dyd;\n  dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;\n  luaX_setinput(L, &lexstate, z, funcstate.f->source, firstchar);\n  mainfunc(&lexstate, &funcstate);\n  lua_assert(!funcstate.prev && funcstate.nups == 1 && !lexstate.fs);\n  /* all scopes should be correctly finished */\n  lua_assert(dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0);\n  L->top.p--;  /* remove scanner's table */\n  return cl;  /* closure is on the stack, too */\n}\n\n"
        },
        {
          "name": "lparser.h",
          "type": "blob",
          "size": 5.9013671875,
          "content": "/*\n** $Id: lparser.h $\n** Lua Parser\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lparser_h\n#define lparser_h\n\n#include \"llimits.h\"\n#include \"lobject.h\"\n#include \"lzio.h\"\n\n\n/*\n** Expression and variable descriptor.\n** Code generation for variables and expressions can be delayed to allow\n** optimizations; An 'expdesc' structure describes a potentially-delayed\n** variable/expression. It has a description of its \"main\" value plus a\n** list of conditional jumps that can also produce its value (generated\n** by short-circuit operators 'and'/'or').\n*/\n\n/* kinds of variables/expressions */\ntypedef enum {\n  VVOID,  /* when 'expdesc' describes the last expression of a list,\n             this kind means an empty list (so, no expression) */\n  VNIL,  /* constant nil */\n  VTRUE,  /* constant true */\n  VFALSE,  /* constant false */\n  VK,  /* constant in 'k'; info = index of constant in 'k' */\n  VKFLT,  /* floating constant; nval = numerical float value */\n  VKINT,  /* integer constant; ival = numerical integer value */\n  VKSTR,  /* string constant; strval = TString address;\n             (string is fixed by the lexer) */\n  VNONRELOC,  /* expression has its value in a fixed register;\n                 info = result register */\n  VLOCAL,  /* local variable; var.ridx = register index;\n              var.vidx = relative index in 'actvar.arr'  */\n  VUPVAL,  /* upvalue variable; info = index of upvalue in 'upvalues' */\n  VCONST,  /* compile-time <const> variable;\n              info = absolute index in 'actvar.arr'  */\n  VINDEXED,  /* indexed variable;\n                ind.t = table register;\n                ind.idx = key's R index */\n  VINDEXUP,  /* indexed upvalue;\n                ind.t = table upvalue;\n                ind.idx = key's K index */\n  VINDEXI, /* indexed variable with constant integer;\n                ind.t = table register;\n                ind.idx = key's value */\n  VINDEXSTR, /* indexed variable with literal string;\n                ind.t = table register;\n                ind.idx = key's K index */\n  VJMP,  /* expression is a test/comparison;\n            info = pc of corresponding jump instruction */\n  VRELOC,  /* expression can put result in any register;\n              info = instruction pc */\n  VCALL,  /* expression is a function call; info = instruction pc */\n  VVARARG  /* vararg expression; info = instruction pc */\n} expkind;\n\n\n#define vkisvar(k)\t(VLOCAL <= (k) && (k) <= VINDEXSTR)\n#define vkisindexed(k)\t(VINDEXED <= (k) && (k) <= VINDEXSTR)\n\n\ntypedef struct expdesc {\n  expkind k;\n  union {\n    lua_Integer ival;    /* for VKINT */\n    lua_Number nval;  /* for VKFLT */\n    TString *strval;  /* for VKSTR */\n    int info;  /* for generic use */\n    struct {  /* for indexed variables */\n      short idx;  /* index (R or \"long\" K) */\n      lu_byte t;  /* table (register or upvalue) */\n    } ind;\n    struct {  /* for local variables */\n      lu_byte ridx;  /* register holding the variable */\n      unsigned short vidx;  /* compiler index (in 'actvar.arr')  */\n    } var;\n  } u;\n  int t;  /* patch list of 'exit when true' */\n  int f;  /* patch list of 'exit when false' */\n} expdesc;\n\n\n/* kinds of variables */\n#define VDKREG\t\t0   /* regular */\n#define RDKCONST\t1   /* constant */\n#define RDKTOCLOSE\t2   /* to-be-closed */\n#define RDKCTC\t\t3   /* compile-time constant */\n\n/* description of an active local variable */\ntypedef union Vardesc {\n  struct {\n    TValuefields;  /* constant value (if it is a compile-time constant) */\n    lu_byte kind;\n    lu_byte ridx;  /* register holding the variable */\n    short pidx;  /* index of the variable in the Proto's 'locvars' array */\n    TString *name;  /* variable name */\n  } vd;\n  TValue k;  /* constant value (if any) */\n} Vardesc;\n\n\n\n/* description of pending goto statements and label statements */\ntypedef struct Labeldesc {\n  TString *name;  /* label identifier */\n  int pc;  /* position in code */\n  int line;  /* line where it appeared */\n  lu_byte nactvar;  /* number of active variables in that position */\n  lu_byte close;  /* goto that escapes upvalues */\n} Labeldesc;\n\n\n/* list of labels or gotos */\ntypedef struct Labellist {\n  Labeldesc *arr;  /* array */\n  int n;  /* number of entries in use */\n  int size;  /* array size */\n} Labellist;\n\n\n/* dynamic structures used by the parser */\ntypedef struct Dyndata {\n  struct {  /* list of all active local variables */\n    Vardesc *arr;\n    int n;\n    int size;\n  } actvar;\n  Labellist gt;  /* list of pending gotos */\n  Labellist label;   /* list of active labels */\n} Dyndata;\n\n\n/* control of blocks */\nstruct BlockCnt;  /* defined in lparser.c */\n\n\n/* state needed to generate code for a given function */\ntypedef struct FuncState {\n  Proto *f;  /* current function header */\n  struct FuncState *prev;  /* enclosing function */\n  struct LexState *ls;  /* lexical state */\n  struct BlockCnt *bl;  /* chain of current blocks */\n  int pc;  /* next position to code (equivalent to 'ncode') */\n  int lasttarget;   /* 'label' of last 'jump label' */\n  int previousline;  /* last line that was saved in 'lineinfo' */\n  int nk;  /* number of elements in 'k' */\n  int np;  /* number of elements in 'p' */\n  int nabslineinfo;  /* number of elements in 'abslineinfo' */\n  int firstlocal;  /* index of first local var (in Dyndata array) */\n  int firstlabel;  /* index of first label (in 'dyd->label->arr') */\n  short ndebugvars;  /* number of elements in 'f->locvars' */\n  lu_byte nactvar;  /* number of active local variables */\n  lu_byte nups;  /* number of upvalues */\n  lu_byte freereg;  /* first free register */\n  lu_byte iwthabs;  /* instructions issued since last absolute line info */\n  lu_byte needclose;  /* function needs to close upvalues when returning */\n} FuncState;\n\n\nLUAI_FUNC lu_byte luaY_nvarstack (FuncState *fs);\nLUAI_FUNC void luaY_checklimit (FuncState *fs, int v, int l,\n                                const char *what);\nLUAI_FUNC LClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,\n                                 Dyndata *dyd, const char *name, int firstchar);\n\n\n#endif\n"
        },
        {
          "name": "lprefix.h",
          "type": "blob",
          "size": 0.80859375,
          "content": "/*\n** $Id: lprefix.h $\n** Definitions for Lua code that must come before any other header file\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lprefix_h\n#define lprefix_h\n\n\n/*\n** Allows POSIX/XSI stuff\n*/\n#if !defined(LUA_USE_C89)\t/* { */\n\n#if !defined(_XOPEN_SOURCE)\n#define _XOPEN_SOURCE           600\n#elif _XOPEN_SOURCE == 0\n#undef _XOPEN_SOURCE  /* use -D_XOPEN_SOURCE=0 to undefine it */\n#endif\n\n/*\n** Allows manipulation of large files in gcc and some other compilers\n*/\n#if !defined(LUA_32BITS) && !defined(_FILE_OFFSET_BITS)\n#define _LARGEFILE_SOURCE       1\n#define _FILE_OFFSET_BITS       64\n#endif\n\n#endif\t\t\t\t/* } */\n\n\n/*\n** Windows stuff\n*/\n#if defined(_WIN32)\t/* { */\n\n#if !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS  /* avoid warnings about ISO C functions */\n#endif\n\n#endif\t\t\t/* } */\n\n#endif\n\n"
        },
        {
          "name": "lstate.c",
          "type": "blob",
          "size": 10.9658203125,
          "content": "/*\n** $Id: lstate.c $\n** Global State\n** See Copyright Notice in lua.h\n*/\n\n#define lstate_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <stddef.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"llex.h\"\n#include \"lmem.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n\n\n\n/*\n** thread state + extra space\n*/\ntypedef struct LX {\n  lu_byte extra_[LUA_EXTRASPACE];\n  lua_State l;\n} LX;\n\n\n/*\n** Main thread combines a thread state and the global state\n*/\ntypedef struct LG {\n  LX l;\n  global_State g;\n} LG;\n\n\n\n#define fromstate(L)\t(cast(LX *, cast(lu_byte *, (L)) - offsetof(LX, l)))\n\n\n/*\n** these macros allow user-specific actions when a thread is\n** created/deleted\n*/\n#if !defined(luai_userstateopen)\n#define luai_userstateopen(L)\t\t((void)L)\n#endif\n\n#if !defined(luai_userstateclose)\n#define luai_userstateclose(L)\t\t((void)L)\n#endif\n\n#if !defined(luai_userstatethread)\n#define luai_userstatethread(L,L1)\t((void)L)\n#endif\n\n#if !defined(luai_userstatefree)\n#define luai_userstatefree(L,L1)\t((void)L)\n#endif\n\n\n/*\n** set GCdebt to a new value keeping the real number of allocated\n** objects (GCtotalobjs - GCdebt) invariant and avoiding overflows in\n** 'GCtotalobjs'.\n*/\nvoid luaE_setdebt (global_State *g, l_mem debt) {\n  l_mem tb = gettotalbytes(g);\n  lua_assert(tb > 0);\n  if (debt > MAX_LMEM - tb)\n    debt = MAX_LMEM - tb;  /* will make GCtotalbytes == MAX_LMEM */\n  g->GCtotalbytes = tb + debt;\n  g->GCdebt = debt;\n}\n\n\nCallInfo *luaE_extendCI (lua_State *L) {\n  CallInfo *ci;\n  lua_assert(L->ci->next == NULL);\n  ci = luaM_new(L, CallInfo);\n  lua_assert(L->ci->next == NULL);\n  L->ci->next = ci;\n  ci->previous = L->ci;\n  ci->next = NULL;\n  ci->u.l.trap = 0;\n  L->nci++;\n  return ci;\n}\n\n\n/*\n** free all CallInfo structures not in use by a thread\n*/\nstatic void freeCI (lua_State *L) {\n  CallInfo *ci = L->ci;\n  CallInfo *next = ci->next;\n  ci->next = NULL;\n  while ((ci = next) != NULL) {\n    next = ci->next;\n    luaM_free(L, ci);\n    L->nci--;\n  }\n}\n\n\n/*\n** free half of the CallInfo structures not in use by a thread,\n** keeping the first one.\n*/\nvoid luaE_shrinkCI (lua_State *L) {\n  CallInfo *ci = L->ci->next;  /* first free CallInfo */\n  CallInfo *next;\n  if (ci == NULL)\n    return;  /* no extra elements */\n  while ((next = ci->next) != NULL) {  /* two extra elements? */\n    CallInfo *next2 = next->next;  /* next's next */\n    ci->next = next2;  /* remove next from the list */\n    L->nci--;\n    luaM_free(L, next);  /* free next */\n    if (next2 == NULL)\n      break;  /* no more elements */\n    else {\n      next2->previous = ci;\n      ci = next2;  /* continue */\n    }\n  }\n}\n\n\n/*\n** Called when 'getCcalls(L)' larger or equal to LUAI_MAXCCALLS.\n** If equal, raises an overflow error. If value is larger than\n** LUAI_MAXCCALLS (which means it is handling an overflow) but\n** not much larger, does not report an error (to allow overflow\n** handling to work).\n*/\nvoid luaE_checkcstack (lua_State *L) {\n  if (getCcalls(L) == LUAI_MAXCCALLS)\n    luaG_runerror(L, \"C stack overflow\");\n  else if (getCcalls(L) >= (LUAI_MAXCCALLS / 10 * 11))\n    luaD_throw(L, LUA_ERRERR);  /* error while handling stack error */\n}\n\n\nLUAI_FUNC void luaE_incCstack (lua_State *L) {\n  L->nCcalls++;\n  if (l_unlikely(getCcalls(L) >= LUAI_MAXCCALLS))\n    luaE_checkcstack(L);\n}\n\n\nstatic void stack_init (lua_State *L1, lua_State *L) {\n  int i; CallInfo *ci;\n  /* initialize stack array */\n  L1->stack.p = luaM_newvector(L, BASIC_STACK_SIZE + EXTRA_STACK, StackValue);\n  L1->tbclist.p = L1->stack.p;\n  for (i = 0; i < BASIC_STACK_SIZE + EXTRA_STACK; i++)\n    setnilvalue(s2v(L1->stack.p + i));  /* erase new stack */\n  L1->top.p = L1->stack.p;\n  L1->stack_last.p = L1->stack.p + BASIC_STACK_SIZE;\n  /* initialize first ci */\n  ci = &L1->base_ci;\n  ci->next = ci->previous = NULL;\n  ci->callstatus = CIST_C;\n  ci->func.p = L1->top.p;\n  ci->u.c.k = NULL;\n  setnilvalue(s2v(L1->top.p));  /* 'function' entry for this 'ci' */\n  L1->top.p++;\n  ci->top.p = L1->top.p + LUA_MINSTACK;\n  L1->ci = ci;\n}\n\n\nstatic void freestack (lua_State *L) {\n  if (L->stack.p == NULL)\n    return;  /* stack not completely built yet */\n  L->ci = &L->base_ci;  /* free the entire 'ci' list */\n  freeCI(L);\n  lua_assert(L->nci == 0);\n  /* free stack */\n  luaM_freearray(L, L->stack.p, cast_sizet(stacksize(L) + EXTRA_STACK));\n}\n\n\n/*\n** Create registry table and its predefined values\n*/\nstatic void init_registry (lua_State *L, global_State *g) {\n  /* create registry */\n  TValue aux;\n  Table *registry = luaH_new(L);\n  sethvalue(L, &g->l_registry, registry);\n  luaH_resize(L, registry, LUA_RIDX_LAST, 0);\n  /* registry[1] = false */\n  setbfvalue(&aux);\n  luaH_setint(L, registry, 1, &aux);\n  /* registry[LUA_RIDX_MAINTHREAD] = L */\n  setthvalue(L, &aux, L);\n  luaH_setint(L, registry, LUA_RIDX_MAINTHREAD, &aux);\n  /* registry[LUA_RIDX_GLOBALS] = new table (table of globals) */\n  sethvalue(L, &aux, luaH_new(L));\n  luaH_setint(L, registry, LUA_RIDX_GLOBALS, &aux);\n}\n\n\n/*\n** open parts of the state that may cause memory-allocation errors.\n*/\nstatic void f_luaopen (lua_State *L, void *ud) {\n  global_State *g = G(L);\n  UNUSED(ud);\n  stack_init(L, L);  /* init stack */\n  init_registry(L, g);\n  luaS_init(L);\n  luaT_init(L);\n  luaX_init(L);\n  g->gcstp = 0;  /* allow gc */\n  setnilvalue(&g->nilvalue);  /* now state is complete */\n  luai_userstateopen(L);\n}\n\n\n/*\n** preinitialize a thread with consistent values without allocating\n** any memory (to avoid errors)\n*/\nstatic void preinit_thread (lua_State *L, global_State *g) {\n  G(L) = g;\n  L->stack.p = NULL;\n  L->ci = NULL;\n  L->nci = 0;\n  L->twups = L;  /* thread has no upvalues */\n  L->nCcalls = 0;\n  L->errorJmp = NULL;\n  L->hook = NULL;\n  L->hookmask = 0;\n  L->basehookcount = 0;\n  L->allowhook = 1;\n  resethookcount(L);\n  L->openupval = NULL;\n  L->status = LUA_OK;\n  L->errfunc = 0;\n  L->oldpc = 0;\n}\n\n\nlu_mem luaE_threadsize (lua_State *L) {\n  lu_mem sz = cast(lu_mem, sizeof(LX))\n            + cast_uint(L->nci) * sizeof(CallInfo);\n  if (L->stack.p != NULL)\n    sz += cast_uint(stacksize(L) + EXTRA_STACK) * sizeof(StackValue);\n  return sz;\n}\n\n\nstatic void close_state (lua_State *L) {\n  global_State *g = G(L);\n  if (!completestate(g))  /* closing a partially built state? */\n    luaC_freeallobjects(L);  /* just collect its objects */\n  else {  /* closing a fully built state */\n    L->ci = &L->base_ci;  /* unwind CallInfo list */\n    luaD_closeprotected(L, 1, LUA_OK);  /* close all upvalues */\n    luaC_freeallobjects(L);  /* collect all objects */\n    luai_userstateclose(L);\n  }\n  luaM_freearray(L, G(L)->strt.hash, cast_sizet(G(L)->strt.size));\n  freestack(L);\n  lua_assert(gettotalbytes(g) == sizeof(LG));\n  (*g->frealloc)(g->ud, fromstate(L), sizeof(LG), 0);  /* free main block */\n}\n\n\nLUA_API lua_State *lua_newthread (lua_State *L) {\n  global_State *g = G(L);\n  GCObject *o;\n  lua_State *L1;\n  lua_lock(L);\n  luaC_checkGC(L);\n  /* create new thread */\n  o = luaC_newobjdt(L, LUA_TTHREAD, sizeof(LX), offsetof(LX, l));\n  L1 = gco2th(o);\n  /* anchor it on L stack */\n  setthvalue2s(L, L->top.p, L1);\n  api_incr_top(L);\n  preinit_thread(L1, g);\n  L1->hookmask = L->hookmask;\n  L1->basehookcount = L->basehookcount;\n  L1->hook = L->hook;\n  resethookcount(L1);\n  /* initialize L1 extra space */\n  memcpy(lua_getextraspace(L1), lua_getextraspace(g->mainthread),\n         LUA_EXTRASPACE);\n  luai_userstatethread(L, L1);\n  stack_init(L1, L);  /* init stack */\n  lua_unlock(L);\n  return L1;\n}\n\n\nvoid luaE_freethread (lua_State *L, lua_State *L1) {\n  LX *l = fromstate(L1);\n  luaF_closeupval(L1, L1->stack.p);  /* close all upvalues */\n  lua_assert(L1->openupval == NULL);\n  luai_userstatefree(L, L1);\n  freestack(L1);\n  luaM_free(L, l);\n}\n\n\nint luaE_resetthread (lua_State *L, int status) {\n  CallInfo *ci = L->ci = &L->base_ci;  /* unwind CallInfo list */\n  setnilvalue(s2v(L->stack.p));  /* 'function' entry for basic 'ci' */\n  ci->func.p = L->stack.p;\n  ci->callstatus = CIST_C;\n  if (status == LUA_YIELD)\n    status = LUA_OK;\n  L->status = LUA_OK;  /* so it can run __close metamethods */\n  status = luaD_closeprotected(L, 1, status);\n  if (status != LUA_OK)  /* errors? */\n    luaD_seterrorobj(L, status, L->stack.p + 1);\n  else\n    L->top.p = L->stack.p + 1;\n  ci->top.p = L->top.p + LUA_MINSTACK;\n  luaD_reallocstack(L, cast_int(ci->top.p - L->stack.p), 0);\n  return status;\n}\n\n\nLUA_API int lua_closethread (lua_State *L, lua_State *from) {\n  int status;\n  lua_lock(L);\n  L->nCcalls = (from) ? getCcalls(from) : 0;\n  status = luaE_resetthread(L, L->status);\n  lua_unlock(L);\n  return status;\n}\n\n\nLUA_API lua_State *lua_newstate (lua_Alloc f, void *ud, unsigned seed) {\n  int i;\n  lua_State *L;\n  global_State *g;\n  LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));\n  if (l == NULL) return NULL;\n  L = &l->l.l;\n  g = &l->g;\n  L->tt = LUA_VTHREAD;\n  g->currentwhite = bitmask(WHITE0BIT);\n  L->marked = luaC_white(g);\n  preinit_thread(L, g);\n  g->allgc = obj2gco(L);  /* by now, only object is the main thread */\n  L->next = NULL;\n  incnny(L);  /* main thread is always non yieldable */\n  g->frealloc = f;\n  g->ud = ud;\n  g->warnf = NULL;\n  g->ud_warn = NULL;\n  g->mainthread = L;\n  g->seed = seed;\n  g->gcstp = GCSTPGC;  /* no GC while building state */\n  g->strt.size = g->strt.nuse = 0;\n  g->strt.hash = NULL;\n  setnilvalue(&g->l_registry);\n  g->panic = NULL;\n  g->gcstate = GCSpause;\n  g->gckind = KGC_INC;\n  g->gcstopem = 0;\n  g->gcemergency = 0;\n  g->finobj = g->tobefnz = g->fixedgc = NULL;\n  g->firstold1 = g->survival = g->old1 = g->reallyold = NULL;\n  g->finobjsur = g->finobjold1 = g->finobjrold = NULL;\n  g->sweepgc = NULL;\n  g->gray = g->grayagain = NULL;\n  g->weak = g->ephemeron = g->allweak = NULL;\n  g->twups = NULL;\n  g->GCtotalbytes = sizeof(LG);\n  g->GCmarked = 0;\n  g->GCdebt = 0;\n  setivalue(&g->nilvalue, 0);  /* to signal that state is not yet built */\n  setgcparam(g, PAUSE, LUAI_GCPAUSE);\n  setgcparam(g, STEPMUL, LUAI_GCMUL);\n  setgcparam(g, STEPSIZE, LUAI_GCSTEPSIZE);\n  setgcparam(g, MINORMUL, LUAI_GENMINORMUL);\n  setgcparam(g, MINORMAJOR, LUAI_MINORMAJOR);\n  setgcparam(g, MAJORMINOR, LUAI_MAJORMINOR);\n  for (i=0; i < LUA_NUMTYPES; i++) g->mt[i] = NULL;\n  if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {\n    /* memory allocation error: free partial state */\n    close_state(L);\n    L = NULL;\n  }\n  return L;\n}\n\n\nLUA_API void lua_close (lua_State *L) {\n  lua_lock(L);\n  L = G(L)->mainthread;  /* only the main thread can be closed */\n  close_state(L);\n}\n\n\nvoid luaE_warning (lua_State *L, const char *msg, int tocont) {\n  lua_WarnFunction wf = G(L)->warnf;\n  if (wf != NULL)\n    wf(G(L)->ud_warn, msg, tocont);\n}\n\n\n/*\n** Generate a warning from an error message\n*/\nvoid luaE_warnerror (lua_State *L, const char *where) {\n  TValue *errobj = s2v(L->top.p - 1);  /* error object */\n  const char *msg = (ttisstring(errobj))\n                  ? getstr(tsvalue(errobj))\n                  : \"error object is not a string\";\n  /* produce warning \"error in %s (%s)\" (where, msg) */\n  luaE_warning(L, \"error in \", 1);\n  luaE_warning(L, where, 1);\n  luaE_warning(L, \" (\", 1);\n  luaE_warning(L, msg, 1);\n  luaE_warning(L, \")\", 0);\n}\n\n"
        },
        {
          "name": "lstate.h",
          "type": "blob",
          "size": 15.4931640625,
          "content": "/*\n** $Id: lstate.h $\n** Global State\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lstate_h\n#define lstate_h\n\n#include \"lua.h\"\n\n\n/* Some header files included here need this definition */\ntypedef struct CallInfo CallInfo;\n\n\n#include \"lobject.h\"\n#include \"ltm.h\"\n#include \"lzio.h\"\n\n\n/*\n** Some notes about garbage-collected objects: All objects in Lua must\n** be kept somehow accessible until being freed, so all objects always\n** belong to one (and only one) of these lists, using field 'next' of\n** the 'CommonHeader' for the link:\n**\n** 'allgc': all objects not marked for finalization;\n** 'finobj': all objects marked for finalization;\n** 'tobefnz': all objects ready to be finalized;\n** 'fixedgc': all objects that are not to be collected (currently\n** only small strings, such as reserved words).\n**\n** For the generational collector, some of these lists have marks for\n** generations. Each mark points to the first element in the list for\n** that particular generation; that generation goes until the next mark.\n**\n** 'allgc' -> 'survival': new objects;\n** 'survival' -> 'old': objects that survived one collection;\n** 'old1' -> 'reallyold': objects that became old in last collection;\n** 'reallyold' -> NULL: objects old for more than one cycle.\n**\n** 'finobj' -> 'finobjsur': new objects marked for finalization;\n** 'finobjsur' -> 'finobjold1': survived   \"\"\"\";\n** 'finobjold1' -> 'finobjrold': just old  \"\"\"\";\n** 'finobjrold' -> NULL: really old       \"\"\"\".\n**\n** All lists can contain elements older than their main ages, due\n** to 'luaC_checkfinalizer' and 'udata2finalize', which move\n** objects between the normal lists and the \"marked for finalization\"\n** lists. Moreover, barriers can age young objects in young lists as\n** OLD0, which then become OLD1. However, a list never contains\n** elements younger than their main ages.\n**\n** The generational collector also uses a pointer 'firstold1', which\n** points to the first OLD1 object in the list. It is used to optimize\n** 'markold'. (Potentially OLD1 objects can be anywhere between 'allgc'\n** and 'reallyold', but often the list has no OLD1 objects or they are\n** after 'old1'.) Note the difference between it and 'old1':\n** 'firstold1': no OLD1 objects before this point; there can be all\n**   ages after it.\n** 'old1': no objects younger than OLD1 after this point.\n*/\n\n/*\n** Moreover, there is another set of lists that control gray objects.\n** These lists are linked by fields 'gclist'. (All objects that\n** can become gray have such a field. The field is not the same\n** in all objects, but it always has this name.)  Any gray object\n** must belong to one of these lists, and all objects in these lists\n** must be gray (with two exceptions explained below):\n**\n** 'gray': regular gray objects, still waiting to be visited.\n** 'grayagain': objects that must be revisited at the atomic phase.\n**   That includes\n**   - black objects got in a write barrier;\n**   - all kinds of weak tables during propagation phase;\n**   - all threads.\n** 'weak': tables with weak values to be cleared;\n** 'ephemeron': ephemeron tables with white->white entries;\n** 'allweak': tables with weak keys and/or weak values to be cleared.\n**\n** The exceptions to that \"gray rule\" are:\n** - TOUCHED2 objects in generational mode stay in a gray list (because\n** they must be visited again at the end of the cycle), but they are\n** marked black because assignments to them must activate barriers (to\n** move them back to TOUCHED1).\n** - Open upvales are kept gray to avoid barriers, but they stay out\n** of gray lists. (They don't even have a 'gclist' field.)\n*/\n\n\n\n/*\n** About 'nCcalls':  This count has two parts: the lower 16 bits counts\n** the number of recursive invocations in the C stack; the higher\n** 16 bits counts the number of non-yieldable calls in the stack.\n** (They are together so that we can change and save both with one\n** instruction.)\n*/\n\n\n/* true if this thread does not have non-yieldable calls in the stack */\n#define yieldable(L)\t\t(((L)->nCcalls & 0xffff0000) == 0)\n\n/* real number of C calls */\n#define getCcalls(L)\t((L)->nCcalls & 0xffff)\n\n\n/* Increment the number of non-yieldable calls */\n#define incnny(L)\t((L)->nCcalls += 0x10000)\n\n/* Decrement the number of non-yieldable calls */\n#define decnny(L)\t((L)->nCcalls -= 0x10000)\n\n/* Non-yieldable call increment */\n#define nyci\t(0x10000 | 1)\n\n\n\n\nstruct lua_longjmp;  /* defined in ldo.c */\n\n\n/*\n** Atomic type (relative to signals) to better ensure that 'lua_sethook'\n** is thread safe\n*/\n#if !defined(l_signalT)\n#include <signal.h>\n#define l_signalT\tsig_atomic_t\n#endif\n\n\n/*\n** Extra stack space to handle TM calls and some other extras. This\n** space is not included in 'stack_last'. It is used only to avoid stack\n** checks, either because the element will be promptly popped or because\n** there will be a stack check soon after the push. Function frames\n** never use this extra space, so it does not need to be kept clean.\n*/\n#define EXTRA_STACK   5\n\n\n/*\n** Size of cache for strings in the API. 'N' is the number of\n** sets (better be a prime) and \"M\" is the size of each set.\n** (M == 1 makes a direct cache.)\n*/\n#if !defined(STRCACHE_N)\n#define STRCACHE_N              53\n#define STRCACHE_M              2\n#endif\n\n\n#define BASIC_STACK_SIZE        (2*LUA_MINSTACK)\n\n#define stacksize(th)\tcast_int((th)->stack_last.p - (th)->stack.p)\n\n\n/* kinds of Garbage Collection */\n#define KGC_INC\t\t0\t/* incremental gc */\n#define KGC_GENMINOR\t1\t/* generational gc in minor (regular) mode */\n#define KGC_GENMAJOR\t2\t/* generational in major mode */\n\n\ntypedef struct stringtable {\n  TString **hash;  /* array of buckets (linked lists of strings) */\n  int nuse;  /* number of elements */\n  int size;  /* number of buckets */\n} stringtable;\n\n\n/*\n** Information about a call.\n** About union 'u':\n** - field 'l' is used only for Lua functions;\n** - field 'c' is used only for C functions.\n** About union 'u2':\n** - field 'funcidx' is used only by C functions while doing a\n** protected call;\n** - field 'nyield' is used only while a function is \"doing\" an\n** yield (from the yield until the next resume);\n** - field 'nres' is used only while closing tbc variables when\n** returning from a function;\n*/\nstruct CallInfo {\n  StkIdRel func;  /* function index in the stack */\n  StkIdRel\ttop;  /* top for this function */\n  struct CallInfo *previous, *next;  /* dynamic call link */\n  union {\n    struct {  /* only for Lua functions */\n      const Instruction *savedpc;\n      volatile l_signalT trap;  /* function is tracing lines/counts */\n      int nextraargs;  /* # of extra arguments in vararg functions */\n    } l;\n    struct {  /* only for C functions */\n      lua_KFunction k;  /* continuation in case of yields */\n      ptrdiff_t old_errfunc;\n      lua_KContext ctx;  /* context info. in case of yields */\n    } c;\n  } u;\n  union {\n    int funcidx;  /* called-function index */\n    int nyield;  /* number of values yielded */\n    int nres;  /* number of values returned */\n  } u2;\n  l_uint32 callstatus;\n};\n\n\n/*\n** Maximum expected number of results from a function\n** (must fit in CIST_NRESULTS).\n*/\n#define MAXRESULTS\t250\n\n\n/*\n** Bits in CallInfo status\n*/\n/* bits 0-7 are the expected number of results from this function + 1 */\n#define CIST_NRESULTS\t0xffu\n\n/* bits 8-11 count call metamethods (and their extra arguments) */\n#define CIST_CCMT\t8  /* the offset, not the mask */\n#define MAX_CCMT\t(0xfu << CIST_CCMT)\n\n/* Bits 12-14 are used for CIST_RECST (see below) */\n#define CIST_RECST\t12  /* the offset, not the mask */\n\n/* call is running a C function (still in first 16 bits) */\n#define CIST_C\t\t(1u << (CIST_RECST + 3))\n/* call is on a fresh \"luaV_execute\" frame */\n#define CIST_FRESH\tcast(l_uint32, CIST_C << 1)\n/* function is closing tbc variables */\n#define CIST_CLSRET\t(CIST_FRESH << 1)\n/* original value of 'allowhook' */\n#define CIST_OAH\t(CIST_CLSRET << 1)\n/* call is running a debug hook */\n#define CIST_HOOKED\t(CIST_OAH << 1)\n/* doing a yieldable protected call */\n#define CIST_YPCALL\t(CIST_HOOKED << 1)\n/* call was tail called */\n#define CIST_TAIL\t(CIST_YPCALL << 1)\n/* last hook called yielded */\n#define CIST_HOOKYIELD\t(CIST_TAIL << 1)\n/* function \"called\" a finalizer */\n#define CIST_FIN\t(CIST_HOOKYIELD << 1)\n#if defined(LUA_COMPAT_LT_LE)\n/* using __lt for __le */\n#define CIST_LEQ\t(CIST_FIN << 1)\n#endif\n\n\n#define get_nresults(cs)  (cast_int((cs) & CIST_NRESULTS) - 1)\n\n/*\n** Field CIST_RECST stores the \"recover status\", used to keep the error\n** status while closing to-be-closed variables in coroutines, so that\n** Lua can correctly resume after an yield from a __close method called\n** because of an error.  (Three bits are enough for error status.)\n*/\n#define getcistrecst(ci)     (((ci)->callstatus >> CIST_RECST) & 7)\n#define setcistrecst(ci,st)  \\\n  check_exp(((st) & 7) == (st),   /* status must fit in three bits */  \\\n            ((ci)->callstatus = ((ci)->callstatus & ~(7u << CIST_RECST))  \\\n                                | (cast(l_uint32, st) << CIST_RECST)))\n\n\n/* active function is a Lua function */\n#define isLua(ci)\t(!((ci)->callstatus & CIST_C))\n\n/* call is running Lua code (not a hook) */\n#define isLuacode(ci)\t(!((ci)->callstatus & (CIST_C | CIST_HOOKED)))\n\n\n#define setoah(ci,v)  \\\n  ((ci)->callstatus = ((v) ? (ci)->callstatus | CIST_OAH  \\\n                           : (ci)->callstatus & ~CIST_OAH))\n#define getoah(ci)  (((ci)->callstatus & CIST_OAH) ? 1 : 0)\n\n\n/*\n** 'global state', shared by all threads of this state\n*/\ntypedef struct global_State {\n  lua_Alloc frealloc;  /* function to reallocate memory */\n  void *ud;         /* auxiliary data to 'frealloc' */\n  l_mem GCtotalbytes;  /* number of bytes currently allocated + debt */\n  l_mem GCdebt;  /* bytes counted but not yet allocated */\n  l_mem GCmarked;  /* number of objects marked in a GC cycle */\n  l_mem GCmajorminor;  /* auxiliary counter to control major-minor shifts */\n  stringtable strt;  /* hash table for strings */\n  TValue l_registry;\n  TValue nilvalue;  /* a nil value */\n  unsigned int seed;  /* randomized seed for hashes */\n  lu_byte gcparams[LUA_GCPN];\n  lu_byte currentwhite;\n  lu_byte gcstate;  /* state of garbage collector */\n  lu_byte gckind;  /* kind of GC running */\n  lu_byte gcstopem;  /* stops emergency collections */\n  lu_byte gcstp;  /* control whether GC is running */\n  lu_byte gcemergency;  /* true if this is an emergency collection */\n  GCObject *allgc;  /* list of all collectable objects */\n  GCObject **sweepgc;  /* current position of sweep in list */\n  GCObject *finobj;  /* list of collectable objects with finalizers */\n  GCObject *gray;  /* list of gray objects */\n  GCObject *grayagain;  /* list of objects to be traversed atomically */\n  GCObject *weak;  /* list of tables with weak values */\n  GCObject *ephemeron;  /* list of ephemeron tables (weak keys) */\n  GCObject *allweak;  /* list of all-weak tables */\n  GCObject *tobefnz;  /* list of userdata to be GC */\n  GCObject *fixedgc;  /* list of objects not to be collected */\n  /* fields for generational collector */\n  GCObject *survival;  /* start of objects that survived one GC cycle */\n  GCObject *old1;  /* start of old1 objects */\n  GCObject *reallyold;  /* objects more than one cycle old (\"really old\") */\n  GCObject *firstold1;  /* first OLD1 object in the list (if any) */\n  GCObject *finobjsur;  /* list of survival objects with finalizers */\n  GCObject *finobjold1;  /* list of old1 objects with finalizers */\n  GCObject *finobjrold;  /* list of really old objects with finalizers */\n  struct lua_State *twups;  /* list of threads with open upvalues */\n  lua_CFunction panic;  /* to be called in unprotected errors */\n  struct lua_State *mainthread;\n  TString *memerrmsg;  /* message for memory-allocation errors */\n  TString *tmname[TM_N];  /* array with tag-method names */\n  struct Table *mt[LUA_NUMTYPES];  /* metatables for basic types */\n  TString *strcache[STRCACHE_N][STRCACHE_M];  /* cache for strings in API */\n  lua_WarnFunction warnf;  /* warning function */\n  void *ud_warn;         /* auxiliary data to 'warnf' */\n} global_State;\n\n\n/*\n** 'per thread' state\n*/\nstruct lua_State {\n  CommonHeader;\n  lu_byte status;\n  lu_byte allowhook;\n  unsigned short nci;  /* number of items in 'ci' list */\n  StkIdRel top;  /* first free slot in the stack */\n  global_State *l_G;\n  CallInfo *ci;  /* call info for current function */\n  StkIdRel stack_last;  /* end of stack (last element + 1) */\n  StkIdRel stack;  /* stack base */\n  UpVal *openupval;  /* list of open upvalues in this stack */\n  StkIdRel tbclist;  /* list of to-be-closed variables */\n  GCObject *gclist;\n  struct lua_State *twups;  /* list of threads with open upvalues */\n  struct lua_longjmp *errorJmp;  /* current error recover point */\n  CallInfo base_ci;  /* CallInfo for first level (C calling Lua) */\n  volatile lua_Hook hook;\n  ptrdiff_t errfunc;  /* current error handling function (stack index) */\n  l_uint32 nCcalls;  /* number of nested (non-yieldable | C)  calls */\n  int oldpc;  /* last pc traced */\n  int basehookcount;\n  int hookcount;\n  volatile l_signalT hookmask;\n  struct {  /* info about transferred values (for call/return hooks) */\n    int ftransfer;  /* offset of first value transferred */\n    int ntransfer;  /* number of values transferred */\n  } transferinfo;\n};\n\n\n#define G(L)\t(L->l_G)\n\n/*\n** 'g->nilvalue' being a nil value flags that the state was completely\n** build.\n*/\n#define completestate(g)\tttisnil(&g->nilvalue)\n\n\n/*\n** Union of all collectable objects (only for conversions)\n** ISO C99, 6.5.2.3 p.5:\n** \"if a union contains several structures that share a common initial\n** sequence [...], and if the union object currently contains one\n** of these structures, it is permitted to inspect the common initial\n** part of any of them anywhere that a declaration of the complete type\n** of the union is visible.\"\n*/\nunion GCUnion {\n  GCObject gc;  /* common header */\n  struct TString ts;\n  struct Udata u;\n  union Closure cl;\n  struct Table h;\n  struct Proto p;\n  struct lua_State th;  /* thread */\n  struct UpVal upv;\n};\n\n\n/*\n** ISO C99, 6.7.2.1 p.14:\n** \"A pointer to a union object, suitably converted, points to each of\n** its members [...], and vice versa.\"\n*/\n#define cast_u(o)\tcast(union GCUnion *, (o))\n\n/* macros to convert a GCObject into a specific value */\n#define gco2ts(o)  \\\n\tcheck_exp(novariant((o)->tt) == LUA_TSTRING, &((cast_u(o))->ts))\n#define gco2u(o)  check_exp((o)->tt == LUA_VUSERDATA, &((cast_u(o))->u))\n#define gco2lcl(o)  check_exp((o)->tt == LUA_VLCL, &((cast_u(o))->cl.l))\n#define gco2ccl(o)  check_exp((o)->tt == LUA_VCCL, &((cast_u(o))->cl.c))\n#define gco2cl(o)  \\\n\tcheck_exp(novariant((o)->tt) == LUA_TFUNCTION, &((cast_u(o))->cl))\n#define gco2t(o)  check_exp((o)->tt == LUA_VTABLE, &((cast_u(o))->h))\n#define gco2p(o)  check_exp((o)->tt == LUA_VPROTO, &((cast_u(o))->p))\n#define gco2th(o)  check_exp((o)->tt == LUA_VTHREAD, &((cast_u(o))->th))\n#define gco2upv(o)\tcheck_exp((o)->tt == LUA_VUPVAL, &((cast_u(o))->upv))\n\n\n/*\n** macro to convert a Lua object into a GCObject\n** (The access to 'tt' tries to ensure that 'v' is actually a Lua object.)\n*/\n#define obj2gco(v)\tcheck_exp((v)->tt >= LUA_TSTRING, &(cast_u(v)->gc))\n\n\n/* actual number of total memory allocated */\n#define gettotalbytes(g)\t((g)->GCtotalbytes - (g)->GCdebt)\n\n\nLUAI_FUNC void luaE_setdebt (global_State *g, l_mem debt);\nLUAI_FUNC void luaE_freethread (lua_State *L, lua_State *L1);\nLUAI_FUNC lu_mem luaE_threadsize (lua_State *L);\nLUAI_FUNC CallInfo *luaE_extendCI (lua_State *L);\nLUAI_FUNC void luaE_shrinkCI (lua_State *L);\nLUAI_FUNC void luaE_checkcstack (lua_State *L);\nLUAI_FUNC void luaE_incCstack (lua_State *L);\nLUAI_FUNC void luaE_warning (lua_State *L, const char *msg, int tocont);\nLUAI_FUNC void luaE_warnerror (lua_State *L, const char *where);\nLUAI_FUNC int luaE_resetthread (lua_State *L, int status);\n\n\n#endif\n\n"
        },
        {
          "name": "lstring.c",
          "type": "blob",
          "size": 9.826171875,
          "content": "/*\n** $Id: lstring.c $\n** String table (keeps all strings handled by Lua)\n** See Copyright Notice in lua.h\n*/\n\n#define lstring_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n\n\n/*\n** Maximum size for string table.\n*/\n#define MAXSTRTB\tcast_int(luaM_limitN(INT_MAX, TString*))\n\n/*\n** Initial size for the string table (must be power of 2).\n** The Lua core alone registers ~50 strings (reserved words +\n** metaevent keys + a few others). Libraries would typically add\n** a few dozens more.\n*/\n#if !defined(MINSTRTABSIZE)\n#define MINSTRTABSIZE   128\n#endif\n\n\n/*\n** equality for long strings\n*/\nint luaS_eqlngstr (TString *a, TString *b) {\n  size_t len = a->u.lnglen;\n  lua_assert(a->tt == LUA_VLNGSTR && b->tt == LUA_VLNGSTR);\n  return (a == b) ||  /* same instance or... */\n    ((len == b->u.lnglen) &&  /* equal length and ... */\n     (memcmp(getlngstr(a), getlngstr(b), len) == 0));  /* equal contents */\n}\n\n\nunsigned luaS_hash (const char *str, size_t l, unsigned seed) {\n  unsigned int h = seed ^ cast_uint(l);\n  for (; l > 0; l--)\n    h ^= ((h<<5) + (h>>2) + cast_byte(str[l - 1]));\n  return h;\n}\n\n\nunsigned luaS_hashlongstr (TString *ts) {\n  lua_assert(ts->tt == LUA_VLNGSTR);\n  if (ts->extra == 0) {  /* no hash? */\n    size_t len = ts->u.lnglen;\n    ts->hash = luaS_hash(getlngstr(ts), len, ts->hash);\n    ts->extra = 1;  /* now it has its hash */\n  }\n  return ts->hash;\n}\n\n\nstatic void tablerehash (TString **vect, int osize, int nsize) {\n  int i;\n  for (i = osize; i < nsize; i++)  /* clear new elements */\n    vect[i] = NULL;\n  for (i = 0; i < osize; i++) {  /* rehash old part of the array */\n    TString *p = vect[i];\n    vect[i] = NULL;\n    while (p) {  /* for each string in the list */\n      TString *hnext = p->u.hnext;  /* save next */\n      unsigned int h = lmod(p->hash, nsize);  /* new position */\n      p->u.hnext = vect[h];  /* chain it into array */\n      vect[h] = p;\n      p = hnext;\n    }\n  }\n}\n\n\n/*\n** Resize the string table. If allocation fails, keep the current size.\n** (This can degrade performance, but any non-zero size should work\n** correctly.)\n*/\nvoid luaS_resize (lua_State *L, int nsize) {\n  stringtable *tb = &G(L)->strt;\n  int osize = tb->size;\n  TString **newvect;\n  if (nsize < osize)  /* shrinking table? */\n    tablerehash(tb->hash, osize, nsize);  /* depopulate shrinking part */\n  newvect = luaM_reallocvector(L, tb->hash, osize, nsize, TString*);\n  if (l_unlikely(newvect == NULL)) {  /* reallocation failed? */\n    if (nsize < osize)  /* was it shrinking table? */\n      tablerehash(tb->hash, nsize, osize);  /* restore to original size */\n    /* leave table as it was */\n  }\n  else {  /* allocation succeeded */\n    tb->hash = newvect;\n    tb->size = nsize;\n    if (nsize > osize)\n      tablerehash(newvect, osize, nsize);  /* rehash for new size */\n  }\n}\n\n\n/*\n** Clear API string cache. (Entries cannot be empty, so fill them with\n** a non-collectable string.)\n*/\nvoid luaS_clearcache (global_State *g) {\n  int i, j;\n  for (i = 0; i < STRCACHE_N; i++)\n    for (j = 0; j < STRCACHE_M; j++) {\n      if (iswhite(g->strcache[i][j]))  /* will entry be collected? */\n        g->strcache[i][j] = g->memerrmsg;  /* replace it with something fixed */\n    }\n}\n\n\n/*\n** Initialize the string table and the string cache\n*/\nvoid luaS_init (lua_State *L) {\n  global_State *g = G(L);\n  int i, j;\n  stringtable *tb = &G(L)->strt;\n  tb->hash = luaM_newvector(L, MINSTRTABSIZE, TString*);\n  tablerehash(tb->hash, 0, MINSTRTABSIZE);  /* clear array */\n  tb->size = MINSTRTABSIZE;\n  /* pre-create memory-error message */\n  g->memerrmsg = luaS_newliteral(L, MEMERRMSG);\n  luaC_fix(L, obj2gco(g->memerrmsg));  /* it should never be collected */\n  for (i = 0; i < STRCACHE_N; i++)  /* fill cache with valid strings */\n    for (j = 0; j < STRCACHE_M; j++)\n      g->strcache[i][j] = g->memerrmsg;\n}\n\n\nsize_t luaS_sizelngstr (size_t len, int kind) {\n  switch (kind) {\n    case LSTRREG:  /* regular long string */\n      /* don't need 'falloc'/'ud', but need space for content */\n      return offsetof(TString, falloc) + (len + 1) * sizeof(char);\n    case LSTRFIX:  /* fixed external long string */\n      /* don't need 'falloc'/'ud' */\n      return offsetof(TString, falloc);\n    default:  /* external long string with deallocation */\n      lua_assert(kind == LSTRMEM);\n      return sizeof(TString);\n  }\n}\n\n\n/*\n** creates a new string object\n*/\nstatic TString *createstrobj (lua_State *L, size_t totalsize, lu_byte tag,\n                              unsigned h) {\n  TString *ts;\n  GCObject *o;\n  o = luaC_newobj(L, tag, totalsize);\n  ts = gco2ts(o);\n  ts->hash = h;\n  ts->extra = 0;\n  return ts;\n}\n\n\nTString *luaS_createlngstrobj (lua_State *L, size_t l) {\n  size_t totalsize = luaS_sizelngstr(l, LSTRREG);\n  TString *ts = createstrobj(L, totalsize, LUA_VLNGSTR, G(L)->seed);\n  ts->u.lnglen = l;\n  ts->shrlen = LSTRREG;  /* signals that it is a regular long string */\n  ts->contents = cast_charp(ts) + offsetof(TString, falloc);\n  ts->contents[l] = '\\0';  /* ending 0 */\n  return ts;\n}\n\n\nvoid luaS_remove (lua_State *L, TString *ts) {\n  stringtable *tb = &G(L)->strt;\n  TString **p = &tb->hash[lmod(ts->hash, tb->size)];\n  while (*p != ts)  /* find previous element */\n    p = &(*p)->u.hnext;\n  *p = (*p)->u.hnext;  /* remove element from its list */\n  tb->nuse--;\n}\n\n\nstatic void growstrtab (lua_State *L, stringtable *tb) {\n  if (l_unlikely(tb->nuse == INT_MAX)) {  /* too many strings? */\n    luaC_fullgc(L, 1);  /* try to free some... */\n    if (tb->nuse == INT_MAX)  /* still too many? */\n      luaM_error(L);  /* cannot even create a message... */\n  }\n  if (tb->size <= MAXSTRTB / 2)  /* can grow string table? */\n    luaS_resize(L, tb->size * 2);\n}\n\n\n/*\n** Checks whether short string exists and reuses it or creates a new one.\n*/\nstatic TString *internshrstr (lua_State *L, const char *str, size_t l) {\n  TString *ts;\n  global_State *g = G(L);\n  stringtable *tb = &g->strt;\n  unsigned int h = luaS_hash(str, l, g->seed);\n  TString **list = &tb->hash[lmod(h, tb->size)];\n  lua_assert(str != NULL);  /* otherwise 'memcmp'/'memcpy' are undefined */\n  for (ts = *list; ts != NULL; ts = ts->u.hnext) {\n    if (l == cast_uint(ts->shrlen) &&\n        (memcmp(str, getshrstr(ts), l * sizeof(char)) == 0)) {\n      /* found! */\n      if (isdead(g, ts))  /* dead (but not collected yet)? */\n        changewhite(ts);  /* resurrect it */\n      return ts;\n    }\n  }\n  /* else must create a new string */\n  if (tb->nuse >= tb->size) {  /* need to grow string table? */\n    growstrtab(L, tb);\n    list = &tb->hash[lmod(h, tb->size)];  /* rehash with new size */\n  }\n  ts = createstrobj(L, sizestrshr(l), LUA_VSHRSTR, h);\n  ts->shrlen = cast(ls_byte, l);\n  getshrstr(ts)[l] = '\\0';  /* ending 0 */\n  memcpy(getshrstr(ts), str, l * sizeof(char));\n  ts->u.hnext = *list;\n  *list = ts;\n  tb->nuse++;\n  return ts;\n}\n\n\n/*\n** new string (with explicit length)\n*/\nTString *luaS_newlstr (lua_State *L, const char *str, size_t l) {\n  if (l <= LUAI_MAXSHORTLEN)  /* short string? */\n    return internshrstr(L, str, l);\n  else {\n    TString *ts;\n    if (l_unlikely(l * sizeof(char) >= (MAX_SIZE - sizeof(TString))))\n      luaM_toobig(L);\n    ts = luaS_createlngstrobj(L, l);\n    memcpy(getlngstr(ts), str, l * sizeof(char));\n    return ts;\n  }\n}\n\n\n/*\n** Create or reuse a zero-terminated string, first checking in the\n** cache (using the string address as a key). The cache can contain\n** only zero-terminated strings, so it is safe to use 'strcmp' to\n** check hits.\n*/\nTString *luaS_new (lua_State *L, const char *str) {\n  unsigned int i = point2uint(str) % STRCACHE_N;  /* hash */\n  int j;\n  TString **p = G(L)->strcache[i];\n  for (j = 0; j < STRCACHE_M; j++) {\n    if (strcmp(str, getstr(p[j])) == 0)  /* hit? */\n      return p[j];  /* that is it */\n  }\n  /* normal route */\n  for (j = STRCACHE_M - 1; j > 0; j--)\n    p[j] = p[j - 1];  /* move out last element */\n  /* new element is first in the list */\n  p[0] = luaS_newlstr(L, str, strlen(str));\n  return p[0];\n}\n\n\nUdata *luaS_newudata (lua_State *L, size_t s, unsigned short nuvalue) {\n  Udata *u;\n  int i;\n  GCObject *o;\n  if (l_unlikely(s > MAX_SIZE - udatamemoffset(nuvalue)))\n    luaM_toobig(L);\n  o = luaC_newobj(L, LUA_VUSERDATA, sizeudata(nuvalue, s));\n  u = gco2u(o);\n  u->len = s;\n  u->nuvalue = nuvalue;\n  u->metatable = NULL;\n  for (i = 0; i < nuvalue; i++)\n    setnilvalue(&u->uv[i].uv);\n  return u;\n}\n\n\nstruct NewExt {\n  ls_byte kind;\n  const char *s;\n   size_t len;\n  TString *ts;  /* output */\n};\n\n\nstatic void f_newext (lua_State *L, void *ud) {\n  struct NewExt *ne = cast(struct NewExt *, ud);\n  size_t size = luaS_sizelngstr(0, ne->kind);\n  ne->ts = createstrobj(L, size, LUA_VLNGSTR, G(L)->seed);\n}\n\n\nstatic void f_pintern (lua_State *L, void *ud) {\n  struct NewExt *ne = cast(struct NewExt *, ud);\n  ne->ts = internshrstr(L, ne->s, ne->len);\n}\n\n\nTString *luaS_newextlstr (lua_State *L,\n\t          const char *s, size_t len, lua_Alloc falloc, void *ud) {\n  struct NewExt ne;\n  if (len <= LUAI_MAXSHORTLEN) {  /* short string? */\n    ne.s = s; ne.len = len;\n    if (!falloc)\n      f_pintern(L, &ne);  /* just internalize string */\n    else {\n      int status = luaD_rawrunprotected(L, f_pintern, &ne);\n      (*falloc)(ud, cast_voidp(s), len + 1, 0);  /* free external string */\n      if (status != LUA_OK)  /* memory error? */\n        luaM_error(L);  /* re-raise memory error */\n    }\n    return ne.ts;\n  }\n  /* \"normal\" case: long strings */\n  if (!falloc) {\n    ne.kind = LSTRFIX;\n    f_newext(L, &ne);  /* just create header */\n  }\n  else {\n    ne.kind = LSTRMEM;\n    if (luaD_rawrunprotected(L, f_newext, &ne) != LUA_OK) {  /* mem. error? */\n      (*falloc)(ud, cast_voidp(s), len + 1, 0);  /* free external string */\n      luaM_error(L);  /* re-raise memory error */\n    }\n    ne.ts->falloc = falloc;\n    ne.ts->ud = ud;\n  }\n  ne.ts->shrlen = ne.kind;\n  ne.ts->u.lnglen = len;\n  ne.ts->contents = cast_charp(s);\n  return ne.ts;\n}\n\n\n"
        },
        {
          "name": "lstring.h",
          "type": "blob",
          "size": 2.076171875,
          "content": "/*\n** $Id: lstring.h $\n** String table (keep all strings handled by Lua)\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lstring_h\n#define lstring_h\n\n#include \"lgc.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n\n\n/*\n** Memory-allocation error message must be preallocated (it cannot\n** be created after memory is exhausted)\n*/\n#define MEMERRMSG       \"not enough memory\"\n\n\n/*\n** Maximum length for short strings, that is, strings that are\n** internalized. (Cannot be smaller than reserved words or tags for\n** metamethods, as these strings must be internalized;\n** #(\"function\") = 8, #(\"__newindex\") = 10.)\n*/\n#if !defined(LUAI_MAXSHORTLEN)\n#define LUAI_MAXSHORTLEN\t40\n#endif\n\n\n/*\n** Size of a short TString: Size of the header plus space for the string\n** itself (including final '\\0').\n*/\n#define sizestrshr(l)  \\\n\t(offsetof(TString, contents) + ((l) + 1) * sizeof(char))\n\n\n#define luaS_newliteral(L, s)\t(luaS_newlstr(L, \"\" s, \\\n                                 (sizeof(s)/sizeof(char))-1))\n\n\n/*\n** test whether a string is a reserved word\n*/\n#define isreserved(s)\t((s)->tt == LUA_VSHRSTR && (s)->extra > 0)\n\n\n/*\n** equality for short strings, which are always internalized\n*/\n#define eqshrstr(a,b)\tcheck_exp((a)->tt == LUA_VSHRSTR, (a) == (b))\n\n\nLUAI_FUNC unsigned luaS_hash (const char *str, size_t l, unsigned seed);\nLUAI_FUNC unsigned luaS_hashlongstr (TString *ts);\nLUAI_FUNC int luaS_eqlngstr (TString *a, TString *b);\nLUAI_FUNC void luaS_resize (lua_State *L, int newsize);\nLUAI_FUNC void luaS_clearcache (global_State *g);\nLUAI_FUNC void luaS_init (lua_State *L);\nLUAI_FUNC void luaS_remove (lua_State *L, TString *ts);\nLUAI_FUNC Udata *luaS_newudata (lua_State *L, size_t s,\n                                              unsigned short nuvalue);\nLUAI_FUNC TString *luaS_newlstr (lua_State *L, const char *str, size_t l);\nLUAI_FUNC TString *luaS_new (lua_State *L, const char *str);\nLUAI_FUNC TString *luaS_createlngstrobj (lua_State *L, size_t l);\nLUAI_FUNC TString *luaS_newextlstr (lua_State *L,\n\t\tconst char *s, size_t len, lua_Alloc falloc, void *ud);\nLUAI_FUNC size_t luaS_sizelngstr (size_t len, int kind);\n\n#endif\n"
        },
        {
          "name": "lstrlib.c",
          "type": "blob",
          "size": 56.197265625,
          "content": "/*\n** $Id: lstrlib.c $\n** Standard library for string operations and pattern-matching\n** See Copyright Notice in lua.h\n*/\n\n#define lstrlib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <locale.h>\n#include <math.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n#include \"llimits.h\"\n\n\n/*\n** maximum number of captures that a pattern can do during\n** pattern-matching. This limit is arbitrary, but must fit in\n** an unsigned char.\n*/\n#if !defined(LUA_MAXCAPTURES)\n#define LUA_MAXCAPTURES\t\t32\n#endif\n\n\nstatic int str_len (lua_State *L) {\n  size_t l;\n  luaL_checklstring(L, 1, &l);\n  lua_pushinteger(L, (lua_Integer)l);\n  return 1;\n}\n\n\n/*\n** translate a relative initial string position\n** (negative means back from end): clip result to [1, inf).\n** The length of any string in Lua must fit in a lua_Integer,\n** so there are no overflows in the casts.\n** The inverted comparison avoids a possible overflow\n** computing '-pos'.\n*/\nstatic size_t posrelatI (lua_Integer pos, size_t len) {\n  if (pos > 0)\n    return (size_t)pos;\n  else if (pos == 0)\n    return 1;\n  else if (pos < -(lua_Integer)len)  /* inverted comparison */\n    return 1;  /* clip to 1 */\n  else return len + (size_t)pos + 1;\n}\n\n\n/*\n** Gets an optional ending string position from argument 'arg',\n** with default value 'def'.\n** Negative means back from end: clip result to [0, len]\n*/\nstatic size_t getendpos (lua_State *L, int arg, lua_Integer def,\n                         size_t len) {\n  lua_Integer pos = luaL_optinteger(L, arg, def);\n  if (pos > (lua_Integer)len)\n    return len;\n  else if (pos >= 0)\n    return (size_t)pos;\n  else if (pos < -(lua_Integer)len)\n    return 0;\n  else return len + (size_t)pos + 1;\n}\n\n\nstatic int str_sub (lua_State *L) {\n  size_t l;\n  const char *s = luaL_checklstring(L, 1, &l);\n  size_t start = posrelatI(luaL_checkinteger(L, 2), l);\n  size_t end = getendpos(L, 3, -1, l);\n  if (start <= end)\n    lua_pushlstring(L, s + start - 1, (end - start) + 1);\n  else lua_pushliteral(L, \"\");\n  return 1;\n}\n\n\nstatic int str_reverse (lua_State *L) {\n  size_t l, i;\n  luaL_Buffer b;\n  const char *s = luaL_checklstring(L, 1, &l);\n  char *p = luaL_buffinitsize(L, &b, l);\n  for (i = 0; i < l; i++)\n    p[i] = s[l - i - 1];\n  luaL_pushresultsize(&b, l);\n  return 1;\n}\n\n\nstatic int str_lower (lua_State *L) {\n  size_t l;\n  size_t i;\n  luaL_Buffer b;\n  const char *s = luaL_checklstring(L, 1, &l);\n  char *p = luaL_buffinitsize(L, &b, l);\n  for (i=0; i<l; i++)\n    p[i] = cast_char(tolower(cast_uchar(s[i])));\n  luaL_pushresultsize(&b, l);\n  return 1;\n}\n\n\nstatic int str_upper (lua_State *L) {\n  size_t l;\n  size_t i;\n  luaL_Buffer b;\n  const char *s = luaL_checklstring(L, 1, &l);\n  char *p = luaL_buffinitsize(L, &b, l);\n  for (i=0; i<l; i++)\n    p[i] = cast_char(toupper(cast_uchar(s[i])));\n  luaL_pushresultsize(&b, l);\n  return 1;\n}\n\n\nstatic int str_rep (lua_State *L) {\n  size_t l, lsep;\n  const char *s = luaL_checklstring(L, 1, &l);\n  lua_Integer n = luaL_checkinteger(L, 2);\n  const char *sep = luaL_optlstring(L, 3, \"\", &lsep);\n  if (n <= 0)\n    lua_pushliteral(L, \"\");\n  else if (l_unlikely(l + lsep < l || l + lsep > MAX_SIZE / cast_sizet(n)))\n    return luaL_error(L, \"resulting string too large\");\n  else {\n    size_t totallen = ((size_t)n * (l + lsep)) - lsep;\n    luaL_Buffer b;\n    char *p = luaL_buffinitsize(L, &b, totallen);\n    while (n-- > 1) {  /* first n-1 copies (followed by separator) */\n      memcpy(p, s, l * sizeof(char)); p += l;\n      if (lsep > 0) {  /* empty 'memcpy' is not that cheap */\n        memcpy(p, sep, lsep * sizeof(char));\n        p += lsep;\n      }\n    }\n    memcpy(p, s, l * sizeof(char));  /* last copy (not followed by separator) */\n    luaL_pushresultsize(&b, totallen);\n  }\n  return 1;\n}\n\n\nstatic int str_byte (lua_State *L) {\n  size_t l;\n  const char *s = luaL_checklstring(L, 1, &l);\n  lua_Integer pi = luaL_optinteger(L, 2, 1);\n  size_t posi = posrelatI(pi, l);\n  size_t pose = getendpos(L, 3, pi, l);\n  int n, i;\n  if (posi > pose) return 0;  /* empty interval; return no values */\n  if (l_unlikely(pose - posi >= (size_t)INT_MAX))  /* arithmetic overflow? */\n    return luaL_error(L, \"string slice too long\");\n  n = (int)(pose -  posi) + 1;\n  luaL_checkstack(L, n, \"string slice too long\");\n  for (i=0; i<n; i++)\n    lua_pushinteger(L, cast_uchar(s[posi + cast_uint(i) - 1]));\n  return n;\n}\n\n\nstatic int str_char (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  int i;\n  luaL_Buffer b;\n  char *p = luaL_buffinitsize(L, &b, cast_uint(n));\n  for (i=1; i<=n; i++) {\n    lua_Unsigned c = (lua_Unsigned)luaL_checkinteger(L, i);\n    luaL_argcheck(L, c <= (lua_Unsigned)UCHAR_MAX, i, \"value out of range\");\n    p[i - 1] = cast_char(cast_uchar(c));\n  }\n  luaL_pushresultsize(&b, cast_uint(n));\n  return 1;\n}\n\n\n/*\n** Buffer to store the result of 'string.dump'. It must be initialized\n** after the call to 'lua_dump', to ensure that the function is on the\n** top of the stack when 'lua_dump' is called. ('luaL_buffinit' might\n** push stuff.)\n*/\nstruct str_Writer {\n  int init;  /* true iff buffer has been initialized */\n  luaL_Buffer B;\n};\n\n\nstatic int writer (lua_State *L, const void *b, size_t size, void *ud) {\n  struct str_Writer *state = (struct str_Writer *)ud;\n  if (!state->init) {\n    state->init = 1;\n    luaL_buffinit(L, &state->B);\n  }\n  if (b == NULL) {  /* finishing dump? */\n    luaL_pushresult(&state->B);  /* push result */\n    lua_replace(L, 1);  /* move it to reserved slot */\n  }\n  else\n    luaL_addlstring(&state->B, (const char *)b, size);\n  return 0;\n}\n\n\nstatic int str_dump (lua_State *L) {\n  struct str_Writer state;\n  int strip = lua_toboolean(L, 2);\n  luaL_argcheck(L, lua_type(L, 1) == LUA_TFUNCTION && !lua_iscfunction(L, 1),\n                   1, \"Lua function expected\");\n  /* ensure function is on the top of the stack and vacate slot 1 */\n  lua_pushvalue(L, 1);\n  state.init = 0;\n  lua_dump(L, writer, &state, strip);\n  lua_settop(L, 1);  /* leave final result on top */\n  return 1;\n}\n\n\n\n/*\n** {======================================================\n** METAMETHODS\n** =======================================================\n*/\n\n#if defined(LUA_NOCVTS2N)\t/* { */\n\n/* no coercion from strings to numbers */\n\nstatic const luaL_Reg stringmetamethods[] = {\n  {\"__index\", NULL},  /* placeholder */\n  {NULL, NULL}\n};\n\n#else\t\t/* }{ */\n\nstatic int tonum (lua_State *L, int arg) {\n  if (lua_type(L, arg) == LUA_TNUMBER) {  /* already a number? */\n    lua_pushvalue(L, arg);\n    return 1;\n  }\n  else {  /* check whether it is a numerical string */\n    size_t len;\n    const char *s = lua_tolstring(L, arg, &len);\n    return (s != NULL && lua_stringtonumber(L, s) == len + 1);\n  }\n}\n\n\nstatic void trymt (lua_State *L, const char *mtname) {\n  lua_settop(L, 2);  /* back to the original arguments */\n  if (l_unlikely(lua_type(L, 2) == LUA_TSTRING ||\n                 !luaL_getmetafield(L, 2, mtname)))\n    luaL_error(L, \"attempt to %s a '%s' with a '%s'\", mtname + 2,\n                  luaL_typename(L, -2), luaL_typename(L, -1));\n  lua_insert(L, -3);  /* put metamethod before arguments */\n  lua_call(L, 2, 1);  /* call metamethod */\n}\n\n\nstatic int arith (lua_State *L, int op, const char *mtname) {\n  if (tonum(L, 1) && tonum(L, 2))\n    lua_arith(L, op);  /* result will be on the top */\n  else\n    trymt(L, mtname);\n  return 1;\n}\n\n\nstatic int arith_add (lua_State *L) {\n  return arith(L, LUA_OPADD, \"__add\");\n}\n\nstatic int arith_sub (lua_State *L) {\n  return arith(L, LUA_OPSUB, \"__sub\");\n}\n\nstatic int arith_mul (lua_State *L) {\n  return arith(L, LUA_OPMUL, \"__mul\");\n}\n\nstatic int arith_mod (lua_State *L) {\n  return arith(L, LUA_OPMOD, \"__mod\");\n}\n\nstatic int arith_pow (lua_State *L) {\n  return arith(L, LUA_OPPOW, \"__pow\");\n}\n\nstatic int arith_div (lua_State *L) {\n  return arith(L, LUA_OPDIV, \"__div\");\n}\n\nstatic int arith_idiv (lua_State *L) {\n  return arith(L, LUA_OPIDIV, \"__idiv\");\n}\n\nstatic int arith_unm (lua_State *L) {\n  return arith(L, LUA_OPUNM, \"__unm\");\n}\n\n\nstatic const luaL_Reg stringmetamethods[] = {\n  {\"__add\", arith_add},\n  {\"__sub\", arith_sub},\n  {\"__mul\", arith_mul},\n  {\"__mod\", arith_mod},\n  {\"__pow\", arith_pow},\n  {\"__div\", arith_div},\n  {\"__idiv\", arith_idiv},\n  {\"__unm\", arith_unm},\n  {\"__index\", NULL},  /* placeholder */\n  {NULL, NULL}\n};\n\n#endif\t\t/* } */\n\n/* }====================================================== */\n\n/*\n** {======================================================\n** PATTERN MATCHING\n** =======================================================\n*/\n\n\n#define CAP_UNFINISHED\t(-1)\n#define CAP_POSITION\t(-2)\n\n\ntypedef struct MatchState {\n  const char *src_init;  /* init of source string */\n  const char *src_end;  /* end ('\\0') of source string */\n  const char *p_end;  /* end ('\\0') of pattern */\n  lua_State *L;\n  int matchdepth;  /* control for recursive depth (to avoid C stack overflow) */\n  int level;  /* total number of captures (finished or unfinished) */\n  struct {\n    const char *init;\n    ptrdiff_t len;  /* length or special value (CAP_*) */\n  } capture[LUA_MAXCAPTURES];\n} MatchState;\n\n\n/* recursive function */\nstatic const char *match (MatchState *ms, const char *s, const char *p);\n\n\n/* maximum recursion depth for 'match' */\n#if !defined(MAXCCALLS)\n#define MAXCCALLS\t200\n#endif\n\n\n#define L_ESC\t\t'%'\n#define SPECIALS\t\"^$*+?.([%-\"\n\n\nstatic int check_capture (MatchState *ms, int l) {\n  l -= '1';\n  if (l_unlikely(l < 0 || l >= ms->level ||\n                 ms->capture[l].len == CAP_UNFINISHED))\n    return luaL_error(ms->L, \"invalid capture index %%%d\", l + 1);\n  return l;\n}\n\n\nstatic int capture_to_close (MatchState *ms) {\n  int level = ms->level;\n  for (level--; level>=0; level--)\n    if (ms->capture[level].len == CAP_UNFINISHED) return level;\n  return luaL_error(ms->L, \"invalid pattern capture\");\n}\n\n\nstatic const char *classend (MatchState *ms, const char *p) {\n  switch (*p++) {\n    case L_ESC: {\n      if (l_unlikely(p == ms->p_end))\n        luaL_error(ms->L, \"malformed pattern (ends with '%%')\");\n      return p+1;\n    }\n    case '[': {\n      if (*p == '^') p++;\n      do {  /* look for a ']' */\n        if (l_unlikely(p == ms->p_end))\n          luaL_error(ms->L, \"malformed pattern (missing ']')\");\n        if (*(p++) == L_ESC && p < ms->p_end)\n          p++;  /* skip escapes (e.g. '%]') */\n      } while (*p != ']');\n      return p+1;\n    }\n    default: {\n      return p;\n    }\n  }\n}\n\n\nstatic int match_class (int c, int cl) {\n  int res;\n  switch (tolower(cl)) {\n    case 'a' : res = isalpha(c); break;\n    case 'c' : res = iscntrl(c); break;\n    case 'd' : res = isdigit(c); break;\n    case 'g' : res = isgraph(c); break;\n    case 'l' : res = islower(c); break;\n    case 'p' : res = ispunct(c); break;\n    case 's' : res = isspace(c); break;\n    case 'u' : res = isupper(c); break;\n    case 'w' : res = isalnum(c); break;\n    case 'x' : res = isxdigit(c); break;\n    case 'z' : res = (c == 0); break;  /* deprecated option */\n    default: return (cl == c);\n  }\n  return (islower(cl) ? res : !res);\n}\n\n\nstatic int matchbracketclass (int c, const char *p, const char *ec) {\n  int sig = 1;\n  if (*(p+1) == '^') {\n    sig = 0;\n    p++;  /* skip the '^' */\n  }\n  while (++p < ec) {\n    if (*p == L_ESC) {\n      p++;\n      if (match_class(c, cast_uchar(*p)))\n        return sig;\n    }\n    else if ((*(p+1) == '-') && (p+2 < ec)) {\n      p+=2;\n      if (cast_uchar(*(p-2)) <= c && c <= cast_uchar(*p))\n        return sig;\n    }\n    else if (cast_uchar(*p) == c) return sig;\n  }\n  return !sig;\n}\n\n\nstatic int singlematch (MatchState *ms, const char *s, const char *p,\n                        const char *ep) {\n  if (s >= ms->src_end)\n    return 0;\n  else {\n    int c = cast_uchar(*s);\n    switch (*p) {\n      case '.': return 1;  /* matches any char */\n      case L_ESC: return match_class(c, cast_uchar(*(p+1)));\n      case '[': return matchbracketclass(c, p, ep-1);\n      default:  return (cast_uchar(*p) == c);\n    }\n  }\n}\n\n\nstatic const char *matchbalance (MatchState *ms, const char *s,\n                                   const char *p) {\n  if (l_unlikely(p >= ms->p_end - 1))\n    luaL_error(ms->L, \"malformed pattern (missing arguments to '%%b')\");\n  if (*s != *p) return NULL;\n  else {\n    int b = *p;\n    int e = *(p+1);\n    int cont = 1;\n    while (++s < ms->src_end) {\n      if (*s == e) {\n        if (--cont == 0) return s+1;\n      }\n      else if (*s == b) cont++;\n    }\n  }\n  return NULL;  /* string ends out of balance */\n}\n\n\nstatic const char *max_expand (MatchState *ms, const char *s,\n                                 const char *p, const char *ep) {\n  ptrdiff_t i = 0;  /* counts maximum expand for item */\n  while (singlematch(ms, s + i, p, ep))\n    i++;\n  /* keeps trying to match with the maximum repetitions */\n  while (i>=0) {\n    const char *res = match(ms, (s+i), ep+1);\n    if (res) return res;\n    i--;  /* else didn't match; reduce 1 repetition to try again */\n  }\n  return NULL;\n}\n\n\nstatic const char *min_expand (MatchState *ms, const char *s,\n                                 const char *p, const char *ep) {\n  for (;;) {\n    const char *res = match(ms, s, ep+1);\n    if (res != NULL)\n      return res;\n    else if (singlematch(ms, s, p, ep))\n      s++;  /* try with one more repetition */\n    else return NULL;\n  }\n}\n\n\nstatic const char *start_capture (MatchState *ms, const char *s,\n                                    const char *p, int what) {\n  const char *res;\n  int level = ms->level;\n  if (level >= LUA_MAXCAPTURES) luaL_error(ms->L, \"too many captures\");\n  ms->capture[level].init = s;\n  ms->capture[level].len = what;\n  ms->level = level+1;\n  if ((res=match(ms, s, p)) == NULL)  /* match failed? */\n    ms->level--;  /* undo capture */\n  return res;\n}\n\n\nstatic const char *end_capture (MatchState *ms, const char *s,\n                                  const char *p) {\n  int l = capture_to_close(ms);\n  const char *res;\n  ms->capture[l].len = s - ms->capture[l].init;  /* close capture */\n  if ((res = match(ms, s, p)) == NULL)  /* match failed? */\n    ms->capture[l].len = CAP_UNFINISHED;  /* undo capture */\n  return res;\n}\n\n\nstatic const char *match_capture (MatchState *ms, const char *s, int l) {\n  size_t len;\n  l = check_capture(ms, l);\n  len = cast_sizet(ms->capture[l].len);\n  if ((size_t)(ms->src_end-s) >= len &&\n      memcmp(ms->capture[l].init, s, len) == 0)\n    return s+len;\n  else return NULL;\n}\n\n\nstatic const char *match (MatchState *ms, const char *s, const char *p) {\n  if (l_unlikely(ms->matchdepth-- == 0))\n    luaL_error(ms->L, \"pattern too complex\");\n  init: /* using goto to optimize tail recursion */\n  if (p != ms->p_end) {  /* end of pattern? */\n    switch (*p) {\n      case '(': {  /* start capture */\n        if (*(p + 1) == ')')  /* position capture? */\n          s = start_capture(ms, s, p + 2, CAP_POSITION);\n        else\n          s = start_capture(ms, s, p + 1, CAP_UNFINISHED);\n        break;\n      }\n      case ')': {  /* end capture */\n        s = end_capture(ms, s, p + 1);\n        break;\n      }\n      case '$': {\n        if ((p + 1) != ms->p_end)  /* is the '$' the last char in pattern? */\n          goto dflt;  /* no; go to default */\n        s = (s == ms->src_end) ? s : NULL;  /* check end of string */\n        break;\n      }\n      case L_ESC: {  /* escaped sequences not in the format class[*+?-]? */\n        switch (*(p + 1)) {\n          case 'b': {  /* balanced string? */\n            s = matchbalance(ms, s, p + 2);\n            if (s != NULL) {\n              p += 4; goto init;  /* return match(ms, s, p + 4); */\n            }  /* else fail (s == NULL) */\n            break;\n          }\n          case 'f': {  /* frontier? */\n            const char *ep; char previous;\n            p += 2;\n            if (l_unlikely(*p != '['))\n              luaL_error(ms->L, \"missing '[' after '%%f' in pattern\");\n            ep = classend(ms, p);  /* points to what is next */\n            previous = (s == ms->src_init) ? '\\0' : *(s - 1);\n            if (!matchbracketclass(cast_uchar(previous), p, ep - 1) &&\n               matchbracketclass(cast_uchar(*s), p, ep - 1)) {\n              p = ep; goto init;  /* return match(ms, s, ep); */\n            }\n            s = NULL;  /* match failed */\n            break;\n          }\n          case '0': case '1': case '2': case '3':\n          case '4': case '5': case '6': case '7':\n          case '8': case '9': {  /* capture results (%0-%9)? */\n            s = match_capture(ms, s, cast_uchar(*(p + 1)));\n            if (s != NULL) {\n              p += 2; goto init;  /* return match(ms, s, p + 2) */\n            }\n            break;\n          }\n          default: goto dflt;\n        }\n        break;\n      }\n      default: dflt: {  /* pattern class plus optional suffix */\n        const char *ep = classend(ms, p);  /* points to optional suffix */\n        /* does not match at least once? */\n        if (!singlematch(ms, s, p, ep)) {\n          if (*ep == '*' || *ep == '?' || *ep == '-') {  /* accept empty? */\n            p = ep + 1; goto init;  /* return match(ms, s, ep + 1); */\n          }\n          else  /* '+' or no suffix */\n            s = NULL;  /* fail */\n        }\n        else {  /* matched once */\n          switch (*ep) {  /* handle optional suffix */\n            case '?': {  /* optional */\n              const char *res;\n              if ((res = match(ms, s + 1, ep + 1)) != NULL)\n                s = res;\n              else {\n                p = ep + 1; goto init;  /* else return match(ms, s, ep + 1); */\n              }\n              break;\n            }\n            case '+':  /* 1 or more repetitions */\n              s++;  /* 1 match already done */\n              /* FALLTHROUGH */\n            case '*':  /* 0 or more repetitions */\n              s = max_expand(ms, s, p, ep);\n              break;\n            case '-':  /* 0 or more repetitions (minimum) */\n              s = min_expand(ms, s, p, ep);\n              break;\n            default:  /* no suffix */\n              s++; p = ep; goto init;  /* return match(ms, s + 1, ep); */\n          }\n        }\n        break;\n      }\n    }\n  }\n  ms->matchdepth++;\n  return s;\n}\n\n\n\nstatic const char *lmemfind (const char *s1, size_t l1,\n                               const char *s2, size_t l2) {\n  if (l2 == 0) return s1;  /* empty strings are everywhere */\n  else if (l2 > l1) return NULL;  /* avoids a negative 'l1' */\n  else {\n    const char *init;  /* to search for a '*s2' inside 's1' */\n    l2--;  /* 1st char will be checked by 'memchr' */\n    l1 = l1-l2;  /* 's2' cannot be found after that */\n    while (l1 > 0 && (init = (const char *)memchr(s1, *s2, l1)) != NULL) {\n      init++;   /* 1st char is already checked */\n      if (memcmp(init, s2+1, l2) == 0)\n        return init-1;\n      else {  /* correct 'l1' and 's1' to try again */\n        l1 -= ct_diff2sz(init - s1);\n        s1 = init;\n      }\n    }\n    return NULL;  /* not found */\n  }\n}\n\n\n/*\n** get information about the i-th capture. If there are no captures\n** and 'i==0', return information about the whole match, which\n** is the range 's'..'e'. If the capture is a string, return\n** its length and put its address in '*cap'. If it is an integer\n** (a position), push it on the stack and return CAP_POSITION.\n*/\nstatic ptrdiff_t get_onecapture (MatchState *ms, int i, const char *s,\n                              const char *e, const char **cap) {\n  if (i >= ms->level) {\n    if (l_unlikely(i != 0))\n      luaL_error(ms->L, \"invalid capture index %%%d\", i + 1);\n    *cap = s;\n    return (e - s);\n  }\n  else {\n    ptrdiff_t capl = ms->capture[i].len;\n    *cap = ms->capture[i].init;\n    if (l_unlikely(capl == CAP_UNFINISHED))\n      luaL_error(ms->L, \"unfinished capture\");\n    else if (capl == CAP_POSITION)\n      lua_pushinteger(ms->L,\n          ct_diff2S(ms->capture[i].init - ms->src_init) + 1);\n    return capl;\n  }\n}\n\n\n/*\n** Push the i-th capture on the stack.\n*/\nstatic void push_onecapture (MatchState *ms, int i, const char *s,\n                                                    const char *e) {\n  const char *cap;\n  ptrdiff_t l = get_onecapture(ms, i, s, e, &cap);\n  if (l != CAP_POSITION)\n    lua_pushlstring(ms->L, cap, cast_sizet(l));\n  /* else position was already pushed */\n}\n\n\nstatic int push_captures (MatchState *ms, const char *s, const char *e) {\n  int i;\n  int nlevels = (ms->level == 0 && s) ? 1 : ms->level;\n  luaL_checkstack(ms->L, nlevels, \"too many captures\");\n  for (i = 0; i < nlevels; i++)\n    push_onecapture(ms, i, s, e);\n  return nlevels;  /* number of strings pushed */\n}\n\n\n/* check whether pattern has no special characters */\nstatic int nospecials (const char *p, size_t l) {\n  size_t upto = 0;\n  do {\n    if (strpbrk(p + upto, SPECIALS))\n      return 0;  /* pattern has a special character */\n    upto += strlen(p + upto) + 1;  /* may have more after \\0 */\n  } while (upto <= l);\n  return 1;  /* no special chars found */\n}\n\n\nstatic void prepstate (MatchState *ms, lua_State *L,\n                       const char *s, size_t ls, const char *p, size_t lp) {\n  ms->L = L;\n  ms->matchdepth = MAXCCALLS;\n  ms->src_init = s;\n  ms->src_end = s + ls;\n  ms->p_end = p + lp;\n}\n\n\nstatic void reprepstate (MatchState *ms) {\n  ms->level = 0;\n  lua_assert(ms->matchdepth == MAXCCALLS);\n}\n\n\nstatic int str_find_aux (lua_State *L, int find) {\n  size_t ls, lp;\n  const char *s = luaL_checklstring(L, 1, &ls);\n  const char *p = luaL_checklstring(L, 2, &lp);\n  size_t init = posrelatI(luaL_optinteger(L, 3, 1), ls) - 1;\n  if (init > ls) {  /* start after string's end? */\n    luaL_pushfail(L);  /* cannot find anything */\n    return 1;\n  }\n  /* explicit request or no special characters? */\n  if (find && (lua_toboolean(L, 4) || nospecials(p, lp))) {\n    /* do a plain search */\n    const char *s2 = lmemfind(s + init, ls - init, p, lp);\n    if (s2) {\n      lua_pushinteger(L, ct_diff2S(s2 - s) + 1);\n      lua_pushinteger(L, cast_st2S(ct_diff2sz(s2 - s) + lp));\n      return 2;\n    }\n  }\n  else {\n    MatchState ms;\n    const char *s1 = s + init;\n    int anchor = (*p == '^');\n    if (anchor) {\n      p++; lp--;  /* skip anchor character */\n    }\n    prepstate(&ms, L, s, ls, p, lp);\n    do {\n      const char *res;\n      reprepstate(&ms);\n      if ((res=match(&ms, s1, p)) != NULL) {\n        if (find) {\n          lua_pushinteger(L, ct_diff2S(s1 - s) + 1);  /* start */\n          lua_pushinteger(L, ct_diff2S(res - s));   /* end */\n          return push_captures(&ms, NULL, 0) + 2;\n        }\n        else\n          return push_captures(&ms, s1, res);\n      }\n    } while (s1++ < ms.src_end && !anchor);\n  }\n  luaL_pushfail(L);  /* not found */\n  return 1;\n}\n\n\nstatic int str_find (lua_State *L) {\n  return str_find_aux(L, 1);\n}\n\n\nstatic int str_match (lua_State *L) {\n  return str_find_aux(L, 0);\n}\n\n\n/* state for 'gmatch' */\ntypedef struct GMatchState {\n  const char *src;  /* current position */\n  const char *p;  /* pattern */\n  const char *lastmatch;  /* end of last match */\n  MatchState ms;  /* match state */\n} GMatchState;\n\n\nstatic int gmatch_aux (lua_State *L) {\n  GMatchState *gm = (GMatchState *)lua_touserdata(L, lua_upvalueindex(3));\n  const char *src;\n  gm->ms.L = L;\n  for (src = gm->src; src <= gm->ms.src_end; src++) {\n    const char *e;\n    reprepstate(&gm->ms);\n    if ((e = match(&gm->ms, src, gm->p)) != NULL && e != gm->lastmatch) {\n      gm->src = gm->lastmatch = e;\n      return push_captures(&gm->ms, src, e);\n    }\n  }\n  return 0;  /* not found */\n}\n\n\nstatic int gmatch (lua_State *L) {\n  size_t ls, lp;\n  const char *s = luaL_checklstring(L, 1, &ls);\n  const char *p = luaL_checklstring(L, 2, &lp);\n  size_t init = posrelatI(luaL_optinteger(L, 3, 1), ls) - 1;\n  GMatchState *gm;\n  lua_settop(L, 2);  /* keep strings on closure to avoid being collected */\n  gm = (GMatchState *)lua_newuserdatauv(L, sizeof(GMatchState), 0);\n  if (init > ls)  /* start after string's end? */\n    init = ls + 1;  /* avoid overflows in 's + init' */\n  prepstate(&gm->ms, L, s, ls, p, lp);\n  gm->src = s + init; gm->p = p; gm->lastmatch = NULL;\n  lua_pushcclosure(L, gmatch_aux, 3);\n  return 1;\n}\n\n\nstatic void add_s (MatchState *ms, luaL_Buffer *b, const char *s,\n                                                   const char *e) {\n  size_t l;\n  lua_State *L = ms->L;\n  const char *news = lua_tolstring(L, 3, &l);\n  const char *p;\n  while ((p = (char *)memchr(news, L_ESC, l)) != NULL) {\n    luaL_addlstring(b, news, ct_diff2sz(p - news));\n    p++;  /* skip ESC */\n    if (*p == L_ESC)  /* '%%' */\n      luaL_addchar(b, *p);\n    else if (*p == '0')  /* '%0' */\n        luaL_addlstring(b, s, ct_diff2sz(e - s));\n    else if (isdigit(cast_uchar(*p))) {  /* '%n' */\n      const char *cap;\n      ptrdiff_t resl = get_onecapture(ms, *p - '1', s, e, &cap);\n      if (resl == CAP_POSITION)\n        luaL_addvalue(b);  /* add position to accumulated result */\n      else\n        luaL_addlstring(b, cap, cast_sizet(resl));\n    }\n    else\n      luaL_error(L, \"invalid use of '%c' in replacement string\", L_ESC);\n    l -= ct_diff2sz(p + 1 - news);\n    news = p + 1;\n  }\n  luaL_addlstring(b, news, l);\n}\n\n\n/*\n** Add the replacement value to the string buffer 'b'.\n** Return true if the original string was changed. (Function calls and\n** table indexing resulting in nil or false do not change the subject.)\n*/\nstatic int add_value (MatchState *ms, luaL_Buffer *b, const char *s,\n                                      const char *e, int tr) {\n  lua_State *L = ms->L;\n  switch (tr) {\n    case LUA_TFUNCTION: {  /* call the function */\n      int n;\n      lua_pushvalue(L, 3);  /* push the function */\n      n = push_captures(ms, s, e);  /* all captures as arguments */\n      lua_call(L, n, 1);  /* call it */\n      break;\n    }\n    case LUA_TTABLE: {  /* index the table */\n      push_onecapture(ms, 0, s, e);  /* first capture is the index */\n      lua_gettable(L, 3);\n      break;\n    }\n    default: {  /* LUA_TNUMBER or LUA_TSTRING */\n      add_s(ms, b, s, e);  /* add value to the buffer */\n      return 1;  /* something changed */\n    }\n  }\n  if (!lua_toboolean(L, -1)) {  /* nil or false? */\n    lua_pop(L, 1);  /* remove value */\n    luaL_addlstring(b, s, ct_diff2sz(e - s));  /* keep original text */\n    return 0;  /* no changes */\n  }\n  else if (l_unlikely(!lua_isstring(L, -1)))\n    return luaL_error(L, \"invalid replacement value (a %s)\",\n                         luaL_typename(L, -1));\n  else {\n    luaL_addvalue(b);  /* add result to accumulator */\n    return 1;  /* something changed */\n  }\n}\n\n\nstatic int str_gsub (lua_State *L) {\n  size_t srcl, lp;\n  const char *src = luaL_checklstring(L, 1, &srcl);  /* subject */\n  const char *p = luaL_checklstring(L, 2, &lp);  /* pattern */\n  const char *lastmatch = NULL;  /* end of last match */\n  int tr = lua_type(L, 3);  /* replacement type */\n  /* max replacements */\n  lua_Integer max_s = luaL_optinteger(L, 4, cast_st2S(srcl) + 1);\n  int anchor = (*p == '^');\n  lua_Integer n = 0;  /* replacement count */\n  int changed = 0;  /* change flag */\n  MatchState ms;\n  luaL_Buffer b;\n  luaL_argexpected(L, tr == LUA_TNUMBER || tr == LUA_TSTRING ||\n                   tr == LUA_TFUNCTION || tr == LUA_TTABLE, 3,\n                      \"string/function/table\");\n  luaL_buffinit(L, &b);\n  if (anchor) {\n    p++; lp--;  /* skip anchor character */\n  }\n  prepstate(&ms, L, src, srcl, p, lp);\n  while (n < max_s) {\n    const char *e;\n    reprepstate(&ms);  /* (re)prepare state for new match */\n    if ((e = match(&ms, src, p)) != NULL && e != lastmatch) {  /* match? */\n      n++;\n      changed = add_value(&ms, &b, src, e, tr) | changed;\n      src = lastmatch = e;\n    }\n    else if (src < ms.src_end)  /* otherwise, skip one character */\n      luaL_addchar(&b, *src++);\n    else break;  /* end of subject */\n    if (anchor) break;\n  }\n  if (!changed)  /* no changes? */\n    lua_pushvalue(L, 1);  /* return original string */\n  else {  /* something changed */\n    luaL_addlstring(&b, src, ct_diff2sz(ms.src_end - src));\n    luaL_pushresult(&b);  /* create and return new string */\n  }\n  lua_pushinteger(L, n);  /* number of substitutions */\n  return 2;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** STRING FORMAT\n** =======================================================\n*/\n\n#if !defined(lua_number2strx)\t/* { */\n\n/*\n** Hexadecimal floating-point formatter\n*/\n\n#define SIZELENMOD\t(sizeof(LUA_NUMBER_FRMLEN)/sizeof(char))\n\n\n/*\n** Number of bits that goes into the first digit. It can be any value\n** between 1 and 4; the following definition tries to align the number\n** to nibble boundaries by making what is left after that first digit a\n** multiple of 4.\n*/\n#define L_NBFD\t\t((l_floatatt(MANT_DIG) - 1)%4 + 1)\n\n\n/*\n** Add integer part of 'x' to buffer and return new 'x'\n*/\nstatic lua_Number adddigit (char *buff, unsigned n, lua_Number x) {\n  lua_Number dd = l_mathop(floor)(x);  /* get integer part from 'x' */\n  int d = (int)dd;\n  buff[n] = cast_char(d < 10 ? d + '0' : d - 10 + 'a');  /* add to buffer */\n  return x - dd;  /* return what is left */\n}\n\n\nstatic int num2straux (char *buff, unsigned sz, lua_Number x) {\n  /* if 'inf' or 'NaN', format it like '%g' */\n  if (x != x || x == (lua_Number)HUGE_VAL || x == -(lua_Number)HUGE_VAL)\n    return l_sprintf(buff, sz, LUA_NUMBER_FMT, (LUAI_UACNUMBER)x);\n  else if (x == 0) {  /* can be -0... */\n    /* create \"0\" or \"-0\" followed by exponent */\n    return l_sprintf(buff, sz, LUA_NUMBER_FMT \"x0p+0\", (LUAI_UACNUMBER)x);\n  }\n  else {\n    int e;\n    lua_Number m = l_mathop(frexp)(x, &e);  /* 'x' fraction and exponent */\n    unsigned n = 0;  /* character count */\n    if (m < 0) {  /* is number negative? */\n      buff[n++] = '-';  /* add sign */\n      m = -m;  /* make it positive */\n    }\n    buff[n++] = '0'; buff[n++] = 'x';  /* add \"0x\" */\n    m = adddigit(buff, n++, m * (1 << L_NBFD));  /* add first digit */\n    e -= L_NBFD;  /* this digit goes before the radix point */\n    if (m > 0) {  /* more digits? */\n      buff[n++] = lua_getlocaledecpoint();  /* add radix point */\n      do {  /* add as many digits as needed */\n        m = adddigit(buff, n++, m * 16);\n      } while (m > 0);\n    }\n    n += cast_uint(l_sprintf(buff + n, sz - n, \"p%+d\", e));  /* add exponent */\n    lua_assert(n < sz);\n    return cast_int(n);\n  }\n}\n\n\nstatic int lua_number2strx (lua_State *L, char *buff, unsigned sz,\n                            const char *fmt, lua_Number x) {\n  int n = num2straux(buff, sz, x);\n  if (fmt[SIZELENMOD] == 'A') {\n    int i;\n    for (i = 0; i < n; i++)\n      buff[i] = cast_char(toupper(cast_uchar(buff[i])));\n  }\n  else if (l_unlikely(fmt[SIZELENMOD] != 'a'))\n    return luaL_error(L, \"modifiers for format '%%a'/'%%A' not implemented\");\n  return n;\n}\n\n#endif\t\t\t\t/* } */\n\n\n/*\n** Maximum size for items formatted with '%f'. This size is produced\n** by format('%.99f', -maxfloat), and is equal to 99 + 3 ('-', '.',\n** and '\\0') + number of decimal digits to represent maxfloat (which\n** is maximum exponent + 1). (99+3+1, adding some extra, 110)\n*/\n#define MAX_ITEMF\t(110 + l_floatatt(MAX_10_EXP))\n\n\n/*\n** All formats except '%f' do not need that large limit.  The other\n** float formats use exponents, so that they fit in the 99 limit for\n** significant digits; 's' for large strings and 'q' add items directly\n** to the buffer; all integer formats also fit in the 99 limit.  The\n** worst case are floats: they may need 99 significant digits, plus\n** '0x', '-', '.', 'e+XXXX', and '\\0'. Adding some extra, 120.\n*/\n#define MAX_ITEM\t120\n\n\n/* valid flags in a format specification */\n#if !defined(L_FMTFLAGSF)\n\n/* valid flags for a, A, e, E, f, F, g, and G conversions */\n#define L_FMTFLAGSF\t\"-+#0 \"\n\n/* valid flags for o, x, and X conversions */\n#define L_FMTFLAGSX\t\"-#0\"\n\n/* valid flags for d and i conversions */\n#define L_FMTFLAGSI\t\"-+0 \"\n\n/* valid flags for u conversions */\n#define L_FMTFLAGSU\t\"-0\"\n\n/* valid flags for c, p, and s conversions */\n#define L_FMTFLAGSC\t\"-\"\n\n#endif\n\n\n/*\n** Maximum size of each format specification (such as \"%-099.99d\"):\n** Initial '%', flags (up to 5), width (2), period, precision (2),\n** length modifier (8), conversion specifier, and final '\\0', plus some\n** extra.\n*/\n#define MAX_FORMAT\t32\n\n\nstatic void addquoted (luaL_Buffer *b, const char *s, size_t len) {\n  luaL_addchar(b, '\"');\n  while (len--) {\n    if (*s == '\"' || *s == '\\\\' || *s == '\\n') {\n      luaL_addchar(b, '\\\\');\n      luaL_addchar(b, *s);\n    }\n    else if (iscntrl(cast_uchar(*s))) {\n      char buff[10];\n      if (!isdigit(cast_uchar(*(s+1))))\n        l_sprintf(buff, sizeof(buff), \"\\\\%d\", (int)cast_uchar(*s));\n      else\n        l_sprintf(buff, sizeof(buff), \"\\\\%03d\", (int)cast_uchar(*s));\n      luaL_addstring(b, buff);\n    }\n    else\n      luaL_addchar(b, *s);\n    s++;\n  }\n  luaL_addchar(b, '\"');\n}\n\n\n/*\n** Serialize a floating-point number in such a way that it can be\n** scanned back by Lua. Use hexadecimal format for \"common\" numbers\n** (to preserve precision); inf, -inf, and NaN are handled separately.\n** (NaN cannot be expressed as a numeral, so we write '(0/0)' for it.)\n*/\nstatic int quotefloat (lua_State *L, char *buff, lua_Number n) {\n  const char *s;  /* for the fixed representations */\n  if (n == (lua_Number)HUGE_VAL)  /* inf? */\n    s = \"1e9999\";\n  else if (n == -(lua_Number)HUGE_VAL)  /* -inf? */\n    s = \"-1e9999\";\n  else if (n != n)  /* NaN? */\n    s = \"(0/0)\";\n  else {  /* format number as hexadecimal */\n    int  nb = lua_number2strx(L, buff, MAX_ITEM,\n                                 \"%\" LUA_NUMBER_FRMLEN \"a\", n);\n    /* ensures that 'buff' string uses a dot as the radix character */\n    if (memchr(buff, '.', cast_uint(nb)) == NULL) {  /* no dot? */\n      char point = lua_getlocaledecpoint();  /* try locale point */\n      char *ppoint = (char *)memchr(buff, point, cast_uint(nb));\n      if (ppoint) *ppoint = '.';  /* change it to a dot */\n    }\n    return nb;\n  }\n  /* for the fixed representations */\n  return l_sprintf(buff, MAX_ITEM, \"%s\", s);\n}\n\n\nstatic void addliteral (lua_State *L, luaL_Buffer *b, int arg) {\n  switch (lua_type(L, arg)) {\n    case LUA_TSTRING: {\n      size_t len;\n      const char *s = lua_tolstring(L, arg, &len);\n      addquoted(b, s, len);\n      break;\n    }\n    case LUA_TNUMBER: {\n      char *buff = luaL_prepbuffsize(b, MAX_ITEM);\n      int nb;\n      if (!lua_isinteger(L, arg))  /* float? */\n        nb = quotefloat(L, buff, lua_tonumber(L, arg));\n      else {  /* integers */\n        lua_Integer n = lua_tointeger(L, arg);\n        const char *format = (n == LUA_MININTEGER)  /* corner case? */\n                           ? \"0x%\" LUA_INTEGER_FRMLEN \"x\"  /* use hex */\n                           : LUA_INTEGER_FMT;  /* else use default format */\n        nb = l_sprintf(buff, MAX_ITEM, format, (LUAI_UACINT)n);\n      }\n      luaL_addsize(b, cast_uint(nb));\n      break;\n    }\n    case LUA_TNIL: case LUA_TBOOLEAN: {\n      luaL_tolstring(L, arg, NULL);\n      luaL_addvalue(b);\n      break;\n    }\n    default: {\n      luaL_argerror(L, arg, \"value has no literal form\");\n    }\n  }\n}\n\n\nstatic const char *get2digits (const char *s) {\n  if (isdigit(cast_uchar(*s))) {\n    s++;\n    if (isdigit(cast_uchar(*s))) s++;  /* (2 digits at most) */\n  }\n  return s;\n}\n\n\n/*\n** Check whether a conversion specification is valid. When called,\n** first character in 'form' must be '%' and last character must\n** be a valid conversion specifier. 'flags' are the accepted flags;\n** 'precision' signals whether to accept a precision.\n*/\nstatic void checkformat (lua_State *L, const char *form, const char *flags,\n                                       int precision) {\n  const char *spec = form + 1;  /* skip '%' */\n  spec += strspn(spec, flags);  /* skip flags */\n  if (*spec != '0') {  /* a width cannot start with '0' */\n    spec = get2digits(spec);  /* skip width */\n    if (*spec == '.' && precision) {\n      spec++;\n      spec = get2digits(spec);  /* skip precision */\n    }\n  }\n  if (!isalpha(cast_uchar(*spec)))  /* did not go to the end? */\n    luaL_error(L, \"invalid conversion specification: '%s'\", form);\n}\n\n\n/*\n** Get a conversion specification and copy it to 'form'.\n** Return the address of its last character.\n*/\nstatic const char *getformat (lua_State *L, const char *strfrmt,\n                                            char *form) {\n  /* spans flags, width, and precision ('0' is included as a flag) */\n  size_t len = strspn(strfrmt, L_FMTFLAGSF \"123456789.\");\n  len++;  /* adds following character (should be the specifier) */\n  /* still needs space for '%', '\\0', plus a length modifier */\n  if (len >= MAX_FORMAT - 10)\n    luaL_error(L, \"invalid format (too long)\");\n  *(form++) = '%';\n  memcpy(form, strfrmt, len * sizeof(char));\n  *(form + len) = '\\0';\n  return strfrmt + len - 1;\n}\n\n\n/*\n** add length modifier into formats\n*/\nstatic void addlenmod (char *form, const char *lenmod) {\n  size_t l = strlen(form);\n  size_t lm = strlen(lenmod);\n  char spec = form[l - 1];\n  strcpy(form + l - 1, lenmod);\n  form[l + lm - 1] = spec;\n  form[l + lm] = '\\0';\n}\n\n\nstatic int str_format (lua_State *L) {\n  int top = lua_gettop(L);\n  int arg = 1;\n  size_t sfl;\n  const char *strfrmt = luaL_checklstring(L, arg, &sfl);\n  const char *strfrmt_end = strfrmt+sfl;\n  const char *flags;\n  luaL_Buffer b;\n  luaL_buffinit(L, &b);\n  while (strfrmt < strfrmt_end) {\n    if (*strfrmt != L_ESC)\n      luaL_addchar(&b, *strfrmt++);\n    else if (*++strfrmt == L_ESC)\n      luaL_addchar(&b, *strfrmt++);  /* %% */\n    else { /* format item */\n      char form[MAX_FORMAT];  /* to store the format ('%...') */\n      unsigned maxitem = MAX_ITEM;  /* maximum length for the result */\n      char *buff = luaL_prepbuffsize(&b, maxitem);  /* to put result */\n      int nb = 0;  /* number of bytes in result */\n      if (++arg > top)\n        return luaL_argerror(L, arg, \"no value\");\n      strfrmt = getformat(L, strfrmt, form);\n      switch (*strfrmt++) {\n        case 'c': {\n          checkformat(L, form, L_FMTFLAGSC, 0);\n          nb = l_sprintf(buff, maxitem, form, (int)luaL_checkinteger(L, arg));\n          break;\n        }\n        case 'd': case 'i':\n          flags = L_FMTFLAGSI;\n          goto intcase;\n        case 'u':\n          flags = L_FMTFLAGSU;\n          goto intcase;\n        case 'o': case 'x': case 'X':\n          flags = L_FMTFLAGSX;\n         intcase: {\n          lua_Integer n = luaL_checkinteger(L, arg);\n          checkformat(L, form, flags, 1);\n          addlenmod(form, LUA_INTEGER_FRMLEN);\n          nb = l_sprintf(buff, maxitem, form, (LUAI_UACINT)n);\n          break;\n        }\n        case 'a': case 'A':\n          checkformat(L, form, L_FMTFLAGSF, 1);\n          addlenmod(form, LUA_NUMBER_FRMLEN);\n          nb = lua_number2strx(L, buff, maxitem, form,\n                                  luaL_checknumber(L, arg));\n          break;\n        case 'f':\n          maxitem = MAX_ITEMF;  /* extra space for '%f' */\n          buff = luaL_prepbuffsize(&b, maxitem);\n          /* FALLTHROUGH */\n        case 'e': case 'E': case 'g': case 'G': {\n          lua_Number n = luaL_checknumber(L, arg);\n          checkformat(L, form, L_FMTFLAGSF, 1);\n          addlenmod(form, LUA_NUMBER_FRMLEN);\n          nb = l_sprintf(buff, maxitem, form, (LUAI_UACNUMBER)n);\n          break;\n        }\n        case 'p': {\n          const void *p = lua_topointer(L, arg);\n          checkformat(L, form, L_FMTFLAGSC, 0);\n          if (p == NULL) {  /* avoid calling 'printf' with argument NULL */\n            p = \"(null)\";  /* result */\n            form[strlen(form) - 1] = 's';  /* format it as a string */\n          }\n          nb = l_sprintf(buff, maxitem, form, p);\n          break;\n        }\n        case 'q': {\n          if (form[2] != '\\0')  /* modifiers? */\n            return luaL_error(L, \"specifier '%%q' cannot have modifiers\");\n          addliteral(L, &b, arg);\n          break;\n        }\n        case 's': {\n          size_t l;\n          const char *s = luaL_tolstring(L, arg, &l);\n          if (form[2] == '\\0')  /* no modifiers? */\n            luaL_addvalue(&b);  /* keep entire string */\n          else {\n            luaL_argcheck(L, l == strlen(s), arg, \"string contains zeros\");\n            checkformat(L, form, L_FMTFLAGSC, 1);\n            if (strchr(form, '.') == NULL && l >= 100) {\n              /* no precision and string is too long to be formatted */\n              luaL_addvalue(&b);  /* keep entire string */\n            }\n            else {  /* format the string into 'buff' */\n              nb = l_sprintf(buff, maxitem, form, s);\n              lua_pop(L, 1);  /* remove result from 'luaL_tolstring' */\n            }\n          }\n          break;\n        }\n        default: {  /* also treat cases 'pnLlh' */\n          return luaL_error(L, \"invalid conversion '%s' to 'format'\", form);\n        }\n      }\n      lua_assert(cast_uint(nb) < maxitem);\n      luaL_addsize(&b, cast_uint(nb));\n    }\n  }\n  luaL_pushresult(&b);\n  return 1;\n}\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** PACK/UNPACK\n** =======================================================\n*/\n\n\n/* value used for padding */\n#if !defined(LUAL_PACKPADBYTE)\n#define LUAL_PACKPADBYTE\t\t0x00\n#endif\n\n/* maximum size for the binary representation of an integer */\n#define MAXINTSIZE\t16\n\n/* number of bits in a character */\n#define NB\tCHAR_BIT\n\n/* mask for one character (NB 1's) */\n#define MC\t((1 << NB) - 1)\n\n/* size of a lua_Integer */\n#define SZINT\t((int)sizeof(lua_Integer))\n\n\n/* dummy union to get native endianness */\nstatic const union {\n  int dummy;\n  char little;  /* true iff machine is little endian */\n} nativeendian = {1};\n\n\n/*\n** information to pack/unpack stuff\n*/\ntypedef struct Header {\n  lua_State *L;\n  int islittle;\n  unsigned maxalign;\n} Header;\n\n\n/*\n** options for pack/unpack\n*/\ntypedef enum KOption {\n  Kint,\t\t/* signed integers */\n  Kuint,\t/* unsigned integers */\n  Kfloat,\t/* single-precision floating-point numbers */\n  Knumber,\t/* Lua \"native\" floating-point numbers */\n  Kdouble,\t/* double-precision floating-point numbers */\n  Kchar,\t/* fixed-length strings */\n  Kstring,\t/* strings with prefixed length */\n  Kzstr,\t/* zero-terminated strings */\n  Kpadding,\t/* padding */\n  Kpaddalign,\t/* padding for alignment */\n  Knop\t\t/* no-op (configuration or spaces) */\n} KOption;\n\n\n/*\n** Read an integer numeral from string 'fmt' or return 'df' if\n** there is no numeral\n*/\nstatic int digit (int c) { return '0' <= c && c <= '9'; }\n\nstatic size_t getnum (const char **fmt, size_t df) {\n  if (!digit(**fmt))  /* no number? */\n    return df;  /* return default value */\n  else {\n    size_t a = 0;\n    do {\n      a = a*10 + cast_uint(*((*fmt)++) - '0');\n    } while (digit(**fmt) && a <= (MAX_SIZE - 9)/10);\n    return a;\n  }\n}\n\n\n/*\n** Read an integer numeral and raises an error if it is larger\n** than the maximum size of integers.\n*/\nstatic unsigned getnumlimit (Header *h, const char **fmt, size_t df) {\n  size_t sz = getnum(fmt, df);\n  if (l_unlikely((sz - 1u) >= MAXINTSIZE))\n    return cast_uint(luaL_error(h->L,\n               \"integral size (%d) out of limits [1,%d]\", sz, MAXINTSIZE));\n  return cast_uint(sz);\n}\n\n\n/*\n** Initialize Header\n*/\nstatic void initheader (lua_State *L, Header *h) {\n  h->L = L;\n  h->islittle = nativeendian.little;\n  h->maxalign = 1;\n}\n\n\n/*\n** Read and classify next option. 'size' is filled with option's size.\n*/\nstatic KOption getoption (Header *h, const char **fmt, size_t *size) {\n  /* dummy structure to get native alignment requirements */\n  struct cD { char c; union { LUAI_MAXALIGN; } u; };\n  int opt = *((*fmt)++);\n  *size = 0;  /* default */\n  switch (opt) {\n    case 'b': *size = sizeof(char); return Kint;\n    case 'B': *size = sizeof(char); return Kuint;\n    case 'h': *size = sizeof(short); return Kint;\n    case 'H': *size = sizeof(short); return Kuint;\n    case 'l': *size = sizeof(long); return Kint;\n    case 'L': *size = sizeof(long); return Kuint;\n    case 'j': *size = sizeof(lua_Integer); return Kint;\n    case 'J': *size = sizeof(lua_Integer); return Kuint;\n    case 'T': *size = sizeof(size_t); return Kuint;\n    case 'f': *size = sizeof(float); return Kfloat;\n    case 'n': *size = sizeof(lua_Number); return Knumber;\n    case 'd': *size = sizeof(double); return Kdouble;\n    case 'i': *size = getnumlimit(h, fmt, sizeof(int)); return Kint;\n    case 'I': *size = getnumlimit(h, fmt, sizeof(int)); return Kuint;\n    case 's': *size = getnumlimit(h, fmt, sizeof(size_t)); return Kstring;\n    case 'c':\n      *size = getnum(fmt, cast_sizet(-1));\n      if (l_unlikely(*size == cast_sizet(-1)))\n        luaL_error(h->L, \"missing size for format option 'c'\");\n      return Kchar;\n    case 'z': return Kzstr;\n    case 'x': *size = 1; return Kpadding;\n    case 'X': return Kpaddalign;\n    case ' ': break;\n    case '<': h->islittle = 1; break;\n    case '>': h->islittle = 0; break;\n    case '=': h->islittle = nativeendian.little; break;\n    case '!': {\n      const size_t maxalign = offsetof(struct cD, u);\n      h->maxalign = getnumlimit(h, fmt, maxalign);\n      break;\n    }\n    default: luaL_error(h->L, \"invalid format option '%c'\", opt);\n  }\n  return Knop;\n}\n\n\n/*\n** Read, classify, and fill other details about the next option.\n** 'psize' is filled with option's size, 'notoalign' with its\n** alignment requirements.\n** Local variable 'size' gets the size to be aligned. (Kpadal option\n** always gets its full alignment, other options are limited by\n** the maximum alignment ('maxalign'). Kchar option needs no alignment\n** despite its size.\n*/\nstatic KOption getdetails (Header *h, size_t totalsize, const char **fmt,\n                           size_t *psize, unsigned *ntoalign) {\n  KOption opt = getoption(h, fmt, psize);\n  size_t align = *psize;  /* usually, alignment follows size */\n  if (opt == Kpaddalign) {  /* 'X' gets alignment from following option */\n    if (**fmt == '\\0' || getoption(h, fmt, &align) == Kchar || align == 0)\n      luaL_argerror(h->L, 1, \"invalid next option for option 'X'\");\n  }\n  if (align <= 1 || opt == Kchar)  /* need no alignment? */\n    *ntoalign = 0;\n  else {\n    if (align > h->maxalign)  /* enforce maximum alignment */\n      align = h->maxalign;\n    if (l_unlikely(!ispow2(align)))  /* not a power of 2? */\n      luaL_argerror(h->L, 1, \"format asks for alignment not power of 2\");\n    else {\n      /* 'szmoda' = totalsize % align */\n      unsigned szmoda = cast_uint(totalsize & (align - 1));\n      *ntoalign = cast_uint((align - szmoda) & (align - 1));\n    }\n  }\n  return opt;\n}\n\n\n/*\n** Pack integer 'n' with 'size' bytes and 'islittle' endianness.\n** The final 'if' handles the case when 'size' is larger than\n** the size of a Lua integer, correcting the extra sign-extension\n** bytes if necessary (by default they would be zeros).\n*/\nstatic void packint (luaL_Buffer *b, lua_Unsigned n,\n                     int islittle, unsigned size, int neg) {\n  char *buff = luaL_prepbuffsize(b, size);\n  unsigned i;\n  buff[islittle ? 0 : size - 1] = (char)(n & MC);  /* first byte */\n  for (i = 1; i < size; i++) {\n    n >>= NB;\n    buff[islittle ? i : size - 1 - i] = (char)(n & MC);\n  }\n  if (neg && size > SZINT) {  /* negative number need sign extension? */\n    for (i = SZINT; i < size; i++)  /* correct extra bytes */\n      buff[islittle ? i : size - 1 - i] = (char)MC;\n  }\n  luaL_addsize(b, size);  /* add result to buffer */\n}\n\n\n/*\n** Copy 'size' bytes from 'src' to 'dest', correcting endianness if\n** given 'islittle' is different from native endianness.\n*/\nstatic void copywithendian (char *dest, const char *src,\n                            unsigned size, int islittle) {\n  if (islittle == nativeendian.little)\n    memcpy(dest, src, size);\n  else {\n    dest += size - 1;\n    while (size-- != 0)\n      *(dest--) = *(src++);\n  }\n}\n\n\nstatic int str_pack (lua_State *L) {\n  luaL_Buffer b;\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);  /* format string */\n  int arg = 1;  /* current argument to pack */\n  size_t totalsize = 0;  /* accumulate total size of result */\n  initheader(L, &h);\n  lua_pushnil(L);  /* mark to separate arguments from string buffer */\n  luaL_buffinit(L, &b);\n  while (*fmt != '\\0') {\n    unsigned ntoalign;\n    size_t size;\n    KOption opt = getdetails(&h, totalsize, &fmt, &size, &ntoalign);\n    luaL_argcheck(L, size + ntoalign <= MAX_SIZE - totalsize, arg,\n                     \"result too long\");\n    totalsize += ntoalign + size;\n    while (ntoalign-- > 0)\n     luaL_addchar(&b, LUAL_PACKPADBYTE);  /* fill alignment */\n    arg++;\n    switch (opt) {\n      case Kint: {  /* signed integers */\n        lua_Integer n = luaL_checkinteger(L, arg);\n        if (size < SZINT) {  /* need overflow check? */\n          lua_Integer lim = (lua_Integer)1 << ((size * NB) - 1);\n          luaL_argcheck(L, -lim <= n && n < lim, arg, \"integer overflow\");\n        }\n        packint(&b, (lua_Unsigned)n, h.islittle, cast_uint(size), (n < 0));\n        break;\n      }\n      case Kuint: {  /* unsigned integers */\n        lua_Integer n = luaL_checkinteger(L, arg);\n        if (size < SZINT)  /* need overflow check? */\n          luaL_argcheck(L, (lua_Unsigned)n < ((lua_Unsigned)1 << (size * NB)),\n                           arg, \"unsigned overflow\");\n        packint(&b, (lua_Unsigned)n, h.islittle, cast_uint(size), 0);\n        break;\n      }\n      case Kfloat: {  /* C float */\n        float f = (float)luaL_checknumber(L, arg);  /* get argument */\n        char *buff = luaL_prepbuffsize(&b, sizeof(f));\n        /* move 'f' to final result, correcting endianness if needed */\n        copywithendian(buff, (char *)&f, sizeof(f), h.islittle);\n        luaL_addsize(&b, size);\n        break;\n      }\n      case Knumber: {  /* Lua float */\n        lua_Number f = luaL_checknumber(L, arg);  /* get argument */\n        char *buff = luaL_prepbuffsize(&b, sizeof(f));\n        /* move 'f' to final result, correcting endianness if needed */\n        copywithendian(buff, (char *)&f, sizeof(f), h.islittle);\n        luaL_addsize(&b, size);\n        break;\n      }\n      case Kdouble: {  /* C double */\n        double f = (double)luaL_checknumber(L, arg);  /* get argument */\n        char *buff = luaL_prepbuffsize(&b, sizeof(f));\n        /* move 'f' to final result, correcting endianness if needed */\n        copywithendian(buff, (char *)&f, sizeof(f), h.islittle);\n        luaL_addsize(&b, size);\n        break;\n      }\n      case Kchar: {  /* fixed-size string */\n        size_t len;\n        const char *s = luaL_checklstring(L, arg, &len);\n        luaL_argcheck(L, len <= size, arg, \"string longer than given size\");\n        luaL_addlstring(&b, s, len);  /* add string */\n        if (len < size) {  /* does it need padding? */\n          size_t psize = size - len;  /* pad size */\n          char *buff = luaL_prepbuffsize(&b, psize);\n          memset(buff, LUAL_PACKPADBYTE, psize);\n          luaL_addsize(&b, psize);\n        }\n        break;\n      }\n      case Kstring: {  /* strings with length count */\n        size_t len;\n        const char *s = luaL_checklstring(L, arg, &len);\n        luaL_argcheck(L, size >= sizeof(lua_Unsigned) ||\n                         len < ((lua_Unsigned)1 << (size * NB)),\n                         arg, \"string length does not fit in given size\");\n        /* pack length */\n        packint(&b, (lua_Unsigned)len, h.islittle, cast_uint(size), 0);\n        luaL_addlstring(&b, s, len);\n        totalsize += len;\n        break;\n      }\n      case Kzstr: {  /* zero-terminated string */\n        size_t len;\n        const char *s = luaL_checklstring(L, arg, &len);\n        luaL_argcheck(L, strlen(s) == len, arg, \"string contains zeros\");\n        luaL_addlstring(&b, s, len);\n        luaL_addchar(&b, '\\0');  /* add zero at the end */\n        totalsize += len + 1;\n        break;\n      }\n      case Kpadding: luaL_addchar(&b, LUAL_PACKPADBYTE);  /* FALLTHROUGH */\n      case Kpaddalign: case Knop:\n        arg--;  /* undo increment */\n        break;\n    }\n  }\n  luaL_pushresult(&b);\n  return 1;\n}\n\n\nstatic int str_packsize (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);  /* format string */\n  size_t totalsize = 0;  /* accumulate total size of result */\n  initheader(L, &h);\n  while (*fmt != '\\0') {\n    unsigned ntoalign;\n    size_t size;\n    KOption opt = getdetails(&h, totalsize, &fmt, &size, &ntoalign);\n    luaL_argcheck(L, opt != Kstring && opt != Kzstr, 1,\n                     \"variable-length format\");\n    size += ntoalign;  /* total space used by option */\n    luaL_argcheck(L, totalsize <= LUA_MAXINTEGER - size,\n                     1, \"format result too large\");\n    totalsize += size;\n  }\n  lua_pushinteger(L, cast_st2S(totalsize));\n  return 1;\n}\n\n\n/*\n** Unpack an integer with 'size' bytes and 'islittle' endianness.\n** If size is smaller than the size of a Lua integer and integer\n** is signed, must do sign extension (propagating the sign to the\n** higher bits); if size is larger than the size of a Lua integer,\n** it must check the unread bytes to see whether they do not cause an\n** overflow.\n*/\nstatic lua_Integer unpackint (lua_State *L, const char *str,\n                              int islittle, int size, int issigned) {\n  lua_Unsigned res = 0;\n  int i;\n  int limit = (size  <= SZINT) ? size : SZINT;\n  for (i = limit - 1; i >= 0; i--) {\n    res <<= NB;\n    res |= (lua_Unsigned)(unsigned char)str[islittle ? i : size - 1 - i];\n  }\n  if (size < SZINT) {  /* real size smaller than lua_Integer? */\n    if (issigned) {  /* needs sign extension? */\n      lua_Unsigned mask = (lua_Unsigned)1 << (size*NB - 1);\n      res = ((res ^ mask) - mask);  /* do sign extension */\n    }\n  }\n  else if (size > SZINT) {  /* must check unread bytes */\n    int mask = (!issigned || (lua_Integer)res >= 0) ? 0 : MC;\n    for (i = limit; i < size; i++) {\n      if (l_unlikely((unsigned char)str[islittle ? i : size - 1 - i] != mask))\n        luaL_error(L, \"%d-byte integer does not fit into Lua Integer\", size);\n    }\n  }\n  return (lua_Integer)res;\n}\n\n\nstatic int str_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = posrelatI(luaL_optinteger(L, 3, 1), ld) - 1;\n  int n = 0;  /* number of results */\n  luaL_argcheck(L, pos <= ld, 3, \"initial position out of string\");\n  initheader(L, &h);\n  while (*fmt != '\\0') {\n    unsigned ntoalign;\n    size_t size;\n    KOption opt = getdetails(&h, pos, &fmt, &size, &ntoalign);\n    luaL_argcheck(L, ntoalign + size <= ld - pos, 2,\n                    \"data string too short\");\n    pos += ntoalign;  /* skip alignment */\n    /* stack space for item + next position */\n    luaL_checkstack(L, 2, \"too many results\");\n    n++;\n    switch (opt) {\n      case Kint:\n      case Kuint: {\n        lua_Integer res = unpackint(L, data + pos, h.islittle,\n                                       cast_int(size), (opt == Kint));\n        lua_pushinteger(L, res);\n        break;\n      }\n      case Kfloat: {\n        float f;\n        copywithendian((char *)&f, data + pos, sizeof(f), h.islittle);\n        lua_pushnumber(L, (lua_Number)f);\n        break;\n      }\n      case Knumber: {\n        lua_Number f;\n        copywithendian((char *)&f, data + pos, sizeof(f), h.islittle);\n        lua_pushnumber(L, f);\n        break;\n      }\n      case Kdouble: {\n        double f;\n        copywithendian((char *)&f, data + pos, sizeof(f), h.islittle);\n        lua_pushnumber(L, (lua_Number)f);\n        break;\n      }\n      case Kchar: {\n        lua_pushlstring(L, data + pos, size);\n        break;\n      }\n      case Kstring: {\n        lua_Unsigned len = (lua_Unsigned)unpackint(L, data + pos,\n                                          h.islittle, cast_int(size), 0);\n        luaL_argcheck(L, len <= ld - pos - size, 2, \"data string too short\");\n        lua_pushlstring(L, data + pos + size, len);\n        pos += len;  /* skip string */\n        break;\n      }\n      case Kzstr: {\n        size_t len = strlen(data + pos);\n        luaL_argcheck(L, pos + len < ld, 2,\n                         \"unfinished string for format 'z'\");\n        lua_pushlstring(L, data + pos, len);\n        pos += len + 1;  /* skip string plus final '\\0' */\n        break;\n      }\n      case Kpaddalign: case Kpadding: case Knop:\n        n--;  /* undo increment */\n        break;\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, cast_st2S(pos) + 1);  /* next position */\n  return n + 1;\n}\n\n/* }====================================================== */\n\n\nstatic const luaL_Reg strlib[] = {\n  {\"byte\", str_byte},\n  {\"char\", str_char},\n  {\"dump\", str_dump},\n  {\"find\", str_find},\n  {\"format\", str_format},\n  {\"gmatch\", gmatch},\n  {\"gsub\", str_gsub},\n  {\"len\", str_len},\n  {\"lower\", str_lower},\n  {\"match\", str_match},\n  {\"rep\", str_rep},\n  {\"reverse\", str_reverse},\n  {\"sub\", str_sub},\n  {\"upper\", str_upper},\n  {\"pack\", str_pack},\n  {\"packsize\", str_packsize},\n  {\"unpack\", str_unpack},\n  {NULL, NULL}\n};\n\n\nstatic void createmetatable (lua_State *L) {\n  /* table to be metatable for strings */\n  luaL_newlibtable(L, stringmetamethods);\n  luaL_setfuncs(L, stringmetamethods, 0);\n  lua_pushliteral(L, \"\");  /* dummy string */\n  lua_pushvalue(L, -2);  /* copy table */\n  lua_setmetatable(L, -2);  /* set table as metatable for strings */\n  lua_pop(L, 1);  /* pop dummy string */\n  lua_pushvalue(L, -2);  /* get string library */\n  lua_setfield(L, -2, \"__index\");  /* metatable.__index = string */\n  lua_pop(L, 1);  /* pop metatable */\n}\n\n\n/*\n** Open string library\n*/\nLUAMOD_API int luaopen_string (lua_State *L) {\n  luaL_newlib(L, strlib);\n  createmetatable(L);\n  return 1;\n}\n\n"
        },
        {
          "name": "ltable.c",
          "type": "blob",
          "size": 39.2548828125,
          "content": "/*\n** $Id: ltable.c $\n** Lua tables (hash)\n** See Copyright Notice in lua.h\n*/\n\n#define ltable_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n/*\n** Implementation of tables (aka arrays, objects, or hash tables).\n** Tables keep its elements in two parts: an array part and a hash part.\n** Non-negative integer keys are all candidates to be kept in the array\n** part. The actual size of the array is the largest 'n' such that\n** more than half the slots between 1 and n are in use.\n** Hash uses a mix of chained scatter table with Brent's variation.\n** A main invariant of these tables is that, if an element is not\n** in its main position (i.e. the 'original' position that its hash gives\n** to it), then the colliding element is in its own main position.\n** Hence even when the load factor reaches 100%, performance remains good.\n*/\n\n#include <math.h>\n#include <limits.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lvm.h\"\n\n\n/*\n** Only hash parts with at least 2^LIMFORLAST have a 'lastfree' field\n** that optimizes finding a free slot. That field is stored just before\n** the array of nodes, in the same block. Smaller tables do a complete\n** search when looking for a free slot.\n*/\n#define LIMFORLAST    3  /* log2 of real limit (8) */\n\n/*\n** The union 'Limbox' stores 'lastfree' and ensures that what follows it\n** is properly aligned to store a Node.\n*/\ntypedef struct { Node *dummy; Node follows_pNode; } Limbox_aux;\n\ntypedef union {\n  Node *lastfree;\n  char padding[offsetof(Limbox_aux, follows_pNode)];\n} Limbox;\n\n#define haslastfree(t)     ((t)->lsizenode >= LIMFORLAST)\n#define getlastfree(t)     ((cast(Limbox *, (t)->node) - 1)->lastfree)\n\n\n/*\n** MAXABITS is the largest integer such that 2^MAXABITS fits in an\n** unsigned int.\n*/\n#define MAXABITS\tcast_int(sizeof(int) * CHAR_BIT - 1)\n\n\n/*\n** MAXASIZEB is the maximum number of elements in the array part such\n** that the size of the array fits in 'size_t'.\n*/\n#define MAXASIZEB\t(MAX_SIZET/(sizeof(Value) + 1))\n\n\n/*\n** MAXASIZE is the maximum size of the array part. It is the minimum\n** between 2^MAXABITS and MAXASIZEB.\n*/\n#define MAXASIZE  \\\n    (((1u << MAXABITS) < MAXASIZEB) ? (1u << MAXABITS) : cast_uint(MAXASIZEB))\n\n/*\n** MAXHBITS is the largest integer such that 2^MAXHBITS fits in a\n** signed int.\n*/\n#define MAXHBITS\t(MAXABITS - 1)\n\n\n/*\n** MAXHSIZE is the maximum size of the hash part. It is the minimum\n** between 2^MAXHBITS and the maximum size such that, measured in bytes,\n** it fits in a 'size_t'.\n*/\n#define MAXHSIZE\tluaM_limitN(1u << MAXHBITS, Node)\n\n\n/*\n** When the original hash value is good, hashing by a power of 2\n** avoids the cost of '%'.\n*/\n#define hashpow2(t,n)\t\t(gnode(t, lmod((n), sizenode(t))))\n\n/*\n** for other types, it is better to avoid modulo by power of 2, as\n** they can have many 2 factors.\n*/\n#define hashmod(t,n)\t(gnode(t, ((n) % ((sizenode(t)-1u)|1u))))\n\n\n#define hashstr(t,str)\t\thashpow2(t, (str)->hash)\n#define hashboolean(t,p)\thashpow2(t, p)\n\n\n#define hashpointer(t,p)\thashmod(t, point2uint(p))\n\n\n#define dummynode\t\t(&dummynode_)\n\n/*\n** Common hash part for tables with empty hash parts. That allows all\n** tables to have a hash part, avoding an extra check (\"is there a hash\n** part?\") when indexing. Its sole node has an empty value and a key\n** (DEADKEY, NULL) that is different from any valid TValue.\n*/\nstatic const Node dummynode_ = {\n  {{NULL}, LUA_VEMPTY,  /* value's value and type */\n   LUA_TDEADKEY, 0, {NULL}}  /* key type, next, and key value */\n};\n\n\nstatic const TValue absentkey = {ABSTKEYCONSTANT};\n\n\n/*\n** Hash for integers. To allow a good hash, use the remainder operator\n** ('%'). If integer fits as a non-negative int, compute an int\n** remainder, which is faster. Otherwise, use an unsigned-integer\n** remainder, which uses all bits and ensures a non-negative result.\n*/\nstatic Node *hashint (const Table *t, lua_Integer i) {\n  lua_Unsigned ui = l_castS2U(i);\n  if (ui <= cast_uint(INT_MAX))\n    return gnode(t, cast_int(ui) % cast_int((sizenode(t)-1) | 1));\n  else\n    return hashmod(t, ui);\n}\n\n\n/*\n** Hash for floating-point numbers.\n** The main computation should be just\n**     n = frexp(n, &i); return (n * INT_MAX) + i\n** but there are some numerical subtleties.\n** In a two-complement representation, INT_MAX does not has an exact\n** representation as a float, but INT_MIN does; because the absolute\n** value of 'frexp' is smaller than 1 (unless 'n' is inf/NaN), the\n** absolute value of the product 'frexp * -INT_MIN' is smaller or equal\n** to INT_MAX. Next, the use of 'unsigned int' avoids overflows when\n** adding 'i'; the use of '~u' (instead of '-u') avoids problems with\n** INT_MIN.\n*/\n#if !defined(l_hashfloat)\nstatic unsigned l_hashfloat (lua_Number n) {\n  int i;\n  lua_Integer ni;\n  n = l_mathop(frexp)(n, &i) * -cast_num(INT_MIN);\n  if (!lua_numbertointeger(n, &ni)) {  /* is 'n' inf/-inf/NaN? */\n    lua_assert(luai_numisnan(n) || l_mathop(fabs)(n) == cast_num(HUGE_VAL));\n    return 0;\n  }\n  else {  /* normal case */\n    unsigned int u = cast_uint(i) + cast_uint(ni);\n    return (u <= cast_uint(INT_MAX) ? u : ~u);\n  }\n}\n#endif\n\n\n/*\n** returns the 'main' position of an element in a table (that is,\n** the index of its hash value).\n*/\nstatic Node *mainpositionTV (const Table *t, const TValue *key) {\n  switch (ttypetag(key)) {\n    case LUA_VNUMINT: {\n      lua_Integer i = ivalue(key);\n      return hashint(t, i);\n    }\n    case LUA_VNUMFLT: {\n      lua_Number n = fltvalue(key);\n      return hashmod(t, l_hashfloat(n));\n    }\n    case LUA_VSHRSTR: {\n      TString *ts = tsvalue(key);\n      return hashstr(t, ts);\n    }\n    case LUA_VLNGSTR: {\n      TString *ts = tsvalue(key);\n      return hashpow2(t, luaS_hashlongstr(ts));\n    }\n    case LUA_VFALSE:\n      return hashboolean(t, 0);\n    case LUA_VTRUE:\n      return hashboolean(t, 1);\n    case LUA_VLIGHTUSERDATA: {\n      void *p = pvalue(key);\n      return hashpointer(t, p);\n    }\n    case LUA_VLCF: {\n      lua_CFunction f = fvalue(key);\n      return hashpointer(t, f);\n    }\n    default: {\n      GCObject *o = gcvalue(key);\n      return hashpointer(t, o);\n    }\n  }\n}\n\n\nl_sinline Node *mainpositionfromnode (const Table *t, Node *nd) {\n  TValue key;\n  getnodekey(cast(lua_State *, NULL), &key, nd);\n  return mainpositionTV(t, &key);\n}\n\n\n/*\n** Check whether key 'k1' is equal to the key in node 'n2'. This\n** equality is raw, so there are no metamethods. Floats with integer\n** values have been normalized, so integers cannot be equal to\n** floats. It is assumed that 'eqshrstr' is simply pointer equality, so\n** that short strings are handled in the default case.\n** A true 'deadok' means to accept dead keys as equal to their original\n** values. All dead keys are compared in the default case, by pointer\n** identity. (Only collectable objects can produce dead keys.) Note that\n** dead long strings are also compared by identity.\n** Once a key is dead, its corresponding value may be collected, and\n** then another value can be created with the same address. If this\n** other value is given to 'next', 'equalkey' will signal a false\n** positive. In a regular traversal, this situation should never happen,\n** as all keys given to 'next' came from the table itself, and therefore\n** could not have been collected. Outside a regular traversal, we\n** have garbage in, garbage out. What is relevant is that this false\n** positive does not break anything.  (In particular, 'next' will return\n** some other valid item on the table or nil.)\n*/\nstatic int equalkey (const TValue *k1, const Node *n2, int deadok) {\n  if ((rawtt(k1) != keytt(n2)) &&  /* not the same variants? */\n       !(deadok && keyisdead(n2) && iscollectable(k1)))\n   return 0;  /* cannot be same key */\n  switch (keytt(n2)) {\n    case LUA_VNIL: case LUA_VFALSE: case LUA_VTRUE:\n      return 1;\n    case LUA_VNUMINT:\n      return (ivalue(k1) == keyival(n2));\n    case LUA_VNUMFLT:\n      return luai_numeq(fltvalue(k1), fltvalueraw(keyval(n2)));\n    case LUA_VLIGHTUSERDATA:\n      return pvalue(k1) == pvalueraw(keyval(n2));\n    case LUA_VLCF:\n      return fvalue(k1) == fvalueraw(keyval(n2));\n    case ctb(LUA_VLNGSTR):\n      return luaS_eqlngstr(tsvalue(k1), keystrval(n2));\n    default:\n      return gcvalue(k1) == gcvalueraw(keyval(n2));\n  }\n}\n\n\n/*\n** \"Generic\" get version. (Not that generic: not valid for integers,\n** which may be in array part, nor for floats with integral values.)\n** See explanation about 'deadok' in function 'equalkey'.\n*/\nstatic const TValue *getgeneric (Table *t, const TValue *key, int deadok) {\n  Node *n = mainpositionTV(t, key);\n  for (;;) {  /* check whether 'key' is somewhere in the chain */\n    if (equalkey(key, n, deadok))\n      return gval(n);  /* that's it */\n    else {\n      int nx = gnext(n);\n      if (nx == 0)\n        return &absentkey;  /* not found */\n      n += nx;\n    }\n  }\n}\n\n\n/*\n** Return the index 'k' (converted to an unsigned) if it is inside\n** the range [1, limit].\n*/\nstatic unsigned checkrange (lua_Integer k, unsigned limit) {\n  return (l_castS2U(k) - 1u < limit) ? cast_uint(k) : 0;\n}\n\n\n/*\n** Return the index 'k' if 'k' is an appropriate key to live in the\n** array part of a table, 0 otherwise.\n*/\n#define arrayindex(k)\tcheckrange(k, MAXASIZE)\n\n\n/*\n** Check whether an integer key is in the array part of a table and\n** return its index there, or zero.\n*/\n#define ikeyinarray(t,k)\tcheckrange(k, t->asize)\n\n\n/*\n** Check whether a key is in the array part of a table and return its\n** index there, or zero.\n*/\nstatic unsigned keyinarray (Table *t, const TValue *key) {\n  return (ttisinteger(key)) ? ikeyinarray(t, ivalue(key)) : 0;\n}\n\n\n/*\n** returns the index of a 'key' for table traversals. First goes all\n** elements in the array part, then elements in the hash part. The\n** beginning of a traversal is signaled by 0.\n*/\nstatic unsigned findindex (lua_State *L, Table *t, TValue *key,\n                               unsigned asize) {\n  unsigned int i;\n  if (ttisnil(key)) return 0;  /* first iteration */\n  i = keyinarray(t, key);\n  if (i != 0)  /* is 'key' inside array part? */\n    return i;  /* yes; that's the index */\n  else {\n    const TValue *n = getgeneric(t, key, 1);\n    if (l_unlikely(isabstkey(n)))\n      luaG_runerror(L, \"invalid key to 'next'\");  /* key not found */\n    i = cast_uint(nodefromval(n) - gnode(t, 0));  /* key index in hash table */\n    /* hash elements are numbered after array ones */\n    return (i + 1) + asize;\n  }\n}\n\n\nint luaH_next (lua_State *L, Table *t, StkId key) {\n  unsigned int asize = t->asize;\n  unsigned int i = findindex(L, t, s2v(key), asize);  /* find original key */\n  for (; i < asize; i++) {  /* try first array part */\n    lu_byte tag = *getArrTag(t, i);\n    if (!tagisempty(tag)) {  /* a non-empty entry? */\n      setivalue(s2v(key), cast_int(i) + 1);\n      farr2val(t, i, tag, s2v(key + 1));\n      return 1;\n    }\n  }\n  for (i -= asize; i < sizenode(t); i++) {  /* hash part */\n    if (!isempty(gval(gnode(t, i)))) {  /* a non-empty entry? */\n      Node *n = gnode(t, i);\n      getnodekey(L, s2v(key), n);\n      setobj2s(L, key + 1, gval(n));\n      return 1;\n    }\n  }\n  return 0;  /* no more elements */\n}\n\n\n/* Extra space in Node array if it has a lastfree entry */\n#define extraLastfree(t)\t(haslastfree(t) ? sizeof(Limbox) : 0)\n\n/* 'node' size in bytes */\nstatic size_t sizehash (Table *t) {\n  return cast_sizet(sizenode(t)) * sizeof(Node) + extraLastfree(t);\n}\n\n\nstatic void freehash (lua_State *L, Table *t) {\n  if (!isdummy(t)) {\n    /* get pointer to the beginning of Node array */\n    char *arr = cast_charp(t->node) - extraLastfree(t);\n    luaM_freearray(L, arr, sizehash(t));\n  }\n}\n\n\n/*\n** {=============================================================\n** Rehash\n** ==============================================================\n*/\n\nstatic int insertkey (Table *t, const TValue *key, TValue *value);\nstatic void newcheckedkey (Table *t, const TValue *key, TValue *value);\n\n\n/*\n** Structure to count the keys in a table.\n** 'total' is the total number of keys in the table.\n** 'na' is the number of *array indices* in the table (see 'arrayindex').\n** 'deleted' is true if there are deleted nodes in the hash part.\n** 'nums' is a \"count array\" where 'nums[i]' is the number of integer\n** keys between 2^(i - 1) + 1 and 2^i. Note that 'na' is the summation\n** of 'nums'.\n*/\ntypedef struct {\n  unsigned total;\n  unsigned na;\n  int deleted;\n  unsigned nums[MAXABITS + 1];\n} Counters;\n\n\n/*\n** Check whether it is worth to use 'na' array entries instead of 'nh'\n** hash nodes. (A hash node uses ~3 times more memory than an array\n** entry: Two values plus 'next' versus one value.) Evaluate with size_t\n** to avoid overflows.\n*/\n#define arrayXhash(na,nh)\t(cast_sizet(na) <= cast_sizet(nh) * 3)\n\n/*\n** Compute the optimal size for the array part of table 't'.\n** This size maximizes the number of elements going to the array part\n** while satisfying the condition 'arrayXhash' with the use of memory if\n** all those elements went to the hash part.\n** 'ct->na' enters with the total number of array indices in the table\n** and leaves with the number of keys that will go to the array part;\n** return the optimal size for the array part.\n*/\nstatic unsigned computesizes (Counters *ct) {\n  int i;\n  unsigned int twotoi;  /* 2^i (candidate for optimal size) */\n  unsigned int a = 0;  /* number of elements smaller than 2^i */\n  unsigned int na = 0;  /* number of elements to go to array part */\n  unsigned int optimal = 0;  /* optimal size for array part */\n  /* traverse slices while 'twotoi' does not overflow and total of array\n     indices still can satisfy 'arrayXhash' against the array size */\n  for (i = 0, twotoi = 1;\n       twotoi > 0 && arrayXhash(twotoi, ct->na);\n       i++, twotoi *= 2) {\n    unsigned nums = ct->nums[i];\n    a += nums;\n    if (nums > 0 &&  /* grows array only if it gets more elements... */\n        arrayXhash(twotoi, a)) {  /* ...while using \"less memory\" */\n      optimal = twotoi;  /* optimal size (till now) */\n      na = a;  /* all elements up to 'optimal' will go to array part */\n    }\n  }\n  ct->na = na;\n  return optimal;\n}\n\n\nstatic void countint (lua_Integer key, Counters *ct) {\n  unsigned int k = arrayindex(key);\n  if (k != 0) {  /* is 'key' an array index? */\n    ct->nums[luaO_ceillog2(k)]++;  /* count as such */\n    ct->na++;\n  }\n}\n\n\nl_sinline int arraykeyisempty (const Table *t, unsigned key) {\n  int tag = *getArrTag(t, key - 1);\n  return tagisempty(tag);\n}\n\n\n/*\n** Count keys in array part of table 't'.\n*/\nstatic void numusearray (const Table *t, Counters *ct) {\n  int lg;\n  unsigned int ttlg;  /* 2^lg */\n  unsigned int ause = 0;  /* summation of 'nums' */\n  unsigned int i = 1;  /* index to traverse all array keys */\n  unsigned int asize = t->asize;\n  /* traverse each slice */\n  for (lg = 0, ttlg = 1; lg <= MAXABITS; lg++, ttlg *= 2) {\n    unsigned int lc = 0;  /* counter */\n    unsigned int lim = ttlg;\n    if (lim > asize) {\n      lim = asize;  /* adjust upper limit */\n      if (i > lim)\n        break;  /* no more elements to count */\n    }\n    /* count elements in range (2^(lg - 1), 2^lg] */\n    for (; i <= lim; i++) {\n      if (!arraykeyisempty(t, i))\n        lc++;\n    }\n    ct->nums[lg] += lc;\n    ause += lc;\n  }\n  ct->total += ause;\n  ct->na += ause;\n}\n\n\n/*\n** Count keys in hash part of table 't'. As this only happens during\n** a rehash, all nodes have been used. A node can have a nil value only\n** if it was deleted after being created.\n*/\nstatic void numusehash (const Table *t, Counters *ct) {\n  unsigned i = sizenode(t);\n  unsigned total = 0;\n  while (i--) {\n    Node *n = &t->node[i];\n    if (isempty(gval(n))) {\n      lua_assert(!keyisnil(n));  /* entry was deleted; key cannot be nil */\n      ct->deleted = 1;\n    }\n    else {\n      total++;\n      if (keyisinteger(n))\n        countint(keyival(n), ct);\n    }\n  }\n  ct->total += total;\n}\n\n\n/*\n** Convert an \"abstract size\" (number of slots in an array) to\n** \"concrete size\" (number of bytes in the array).\n*/\nstatic size_t concretesize (unsigned int size) {\n  if (size == 0)\n    return 0;\n  else  /* space for the two arrays plus an unsigned in between */\n    return size * (sizeof(Value) + 1) + sizeof(unsigned);\n}\n\n\n/*\n** Resize the array part of a table. If new size is equal to the old,\n** do nothing. Else, if new size is zero, free the old array. (It must\n** be present, as the sizes are different.) Otherwise, allocate a new\n** array, move the common elements to new proper position, and then\n** frees the old array.\n** We could reallocate the array, but we still would need to move the\n** elements to their new position, so the copy implicit in realloc is a\n** waste. Moreover, most allocators will move the array anyway when the\n** new size is double the old one (the most common case).\n*/\nstatic Value *resizearray (lua_State *L , Table *t,\n                               unsigned oldasize,\n                               unsigned newasize) {\n  if (oldasize == newasize)\n    return t->array;  /* nothing to be done */\n  else if (newasize == 0) {  /* erasing array? */\n    Value *op = t->array - oldasize;  /* original array's real address */\n    luaM_freemem(L, op, concretesize(oldasize));  /* free it */\n    return NULL;\n  }\n  else {\n    size_t newasizeb = concretesize(newasize);\n    Value *np = cast(Value *,\n                  luaM_reallocvector(L, NULL, 0, newasizeb, lu_byte));\n    if (np == NULL)  /* allocation error? */\n      return NULL;\n    np += newasize;  /* shift pointer to the end of value segment */\n    if (oldasize > 0) {\n      /* move common elements to new position */\n      size_t oldasizeb = concretesize(oldasize);\n      Value *op = t->array;  /* original array */\n      unsigned tomove = (oldasize < newasize) ? oldasize : newasize;\n      size_t tomoveb = (oldasize < newasize) ? oldasizeb : newasizeb;\n      lua_assert(tomoveb > 0);\n      memcpy(np - tomove, op - tomove, tomoveb);\n      luaM_freemem(L, op - oldasize, oldasizeb);  /* free old block */\n    }\n    return np;\n  }\n}\n\n\n/*\n** Creates an array for the hash part of a table with the given\n** size, or reuses the dummy node if size is zero.\n** The computation for size overflow is in two steps: the first\n** comparison ensures that the shift in the second one does not\n** overflow.\n*/\nstatic void setnodevector (lua_State *L, Table *t, unsigned size) {\n  if (size == 0) {  /* no elements to hash part? */\n    t->node = cast(Node *, dummynode);  /* use common 'dummynode' */\n    t->lsizenode = 0;\n    setdummy(t);  /* signal that it is using dummy node */\n  }\n  else {\n    int i;\n    int lsize = luaO_ceillog2(size);\n    if (lsize > MAXHBITS || (1u << lsize) > MAXHSIZE)\n      luaG_runerror(L, \"table overflow\");\n    size = twoto(lsize);\n    if (lsize < LIMFORLAST)  /* no 'lastfree' field? */\n      t->node = luaM_newvector(L, size, Node);\n    else {\n      size_t bsize = size * sizeof(Node) + sizeof(Limbox);\n      char *node = luaM_newblock(L, bsize);\n      t->node = cast(Node *, node + sizeof(Limbox));\n      getlastfree(t) = gnode(t, size);  /* all positions are free */\n    }\n    t->lsizenode = cast_byte(lsize);\n    setnodummy(t);\n    for (i = 0; i < cast_int(size); i++) {\n      Node *n = gnode(t, i);\n      gnext(n) = 0;\n      setnilkey(n);\n      setempty(gval(n));\n    }\n  }\n}\n\n\n/*\n** (Re)insert all elements from the hash part of 'ot' into table 't'.\n*/\nstatic void reinserthash (lua_State *L, Table *ot, Table *t) {\n  unsigned j;\n  unsigned size = sizenode(ot);\n  for (j = 0; j < size; j++) {\n    Node *old = gnode(ot, j);\n    if (!isempty(gval(old))) {\n      /* doesn't need barrier/invalidate cache, as entry was\n         already present in the table */\n      TValue k;\n      getnodekey(L, &k, old);\n      newcheckedkey(t, &k, gval(old));\n    }\n  }\n}\n\n\n/*\n** Exchange the hash part of 't1' and 't2'. (In 'flags', only the\n** dummy bit must be exchanged: The 'isrealasize' is not related\n** to the hash part, and the metamethod bits do not change during\n** a resize, so the \"real\" table can keep their values.)\n*/\nstatic void exchangehashpart (Table *t1, Table *t2) {\n  lu_byte lsizenode = t1->lsizenode;\n  Node *node = t1->node;\n  int bitdummy1 = t1->flags & BITDUMMY;\n  t1->lsizenode = t2->lsizenode;\n  t1->node = t2->node;\n  t1->flags = cast_byte((t1->flags & NOTBITDUMMY) | (t2->flags & BITDUMMY));\n  t2->lsizenode = lsizenode;\n  t2->node = node;\n  t2->flags = cast_byte((t2->flags & NOTBITDUMMY) | bitdummy1);\n}\n\n\n/*\n** Re-insert into the new hash part of a table the elements from the\n** vanishing slice of the array part.\n*/\nstatic void reinsertOldSlice (Table *t, unsigned oldasize,\n                                        unsigned newasize) {\n  unsigned i;\n  for (i = newasize; i < oldasize; i++) {  /* traverse vanishing slice */\n    lu_byte tag = *getArrTag(t, i);\n    if (!tagisempty(tag)) {  /* a non-empty entry? */\n      TValue key, aux;\n      setivalue(&key, l_castU2S(i) + 1);  /* make the key */\n      farr2val(t, i, tag, &aux);  /* copy value into 'aux' */\n      insertkey(t, &key, &aux);  /* insert entry into the hash part */\n    }\n  }\n}\n\n\n/*\n** Clear new slice of the array.\n*/\nstatic void clearNewSlice (Table *t, unsigned oldasize, unsigned newasize) {\n  for (; oldasize < newasize; oldasize++)\n    *getArrTag(t, oldasize) = LUA_VEMPTY;\n}\n\n\n/*\n** Resize table 't' for the new given sizes. Both allocations (for\n** the hash part and for the array part) can fail, which creates some\n** subtleties. If the first allocation, for the hash part, fails, an\n** error is raised and that is it. Otherwise, it copies the elements from\n** the shrinking part of the array (if it is shrinking) into the new\n** hash. Then it reallocates the array part.  If that fails, the table\n** is in its original state; the function frees the new hash part and then\n** raises the allocation error. Otherwise, it sets the new hash part\n** into the table, initializes the new part of the array (if any) with\n** nils and reinserts the elements of the old hash back into the new\n** parts of the table.\n** Note that if the new size for the arry part ('newasize') is equal to\n** the old one ('oldasize'), this function will do nothing with that\n** part.\n*/\nvoid luaH_resize (lua_State *L, Table *t, unsigned newasize,\n                                          unsigned nhsize) {\n  Table newt;  /* to keep the new hash part */\n  unsigned oldasize = t->asize;\n  Value *newarray;\n  if (newasize > MAXASIZE)\n    luaG_runerror(L, \"table overflow\");\n  /* create new hash part with appropriate size into 'newt' */\n  newt.flags = 0;\n  setnodevector(L, &newt, nhsize);\n  if (newasize < oldasize) {  /* will array shrink? */\n    /* re-insert into the new hash the elements from vanishing slice */\n    exchangehashpart(t, &newt);  /* pretend table has new hash */\n    reinsertOldSlice(t, oldasize, newasize);\n    exchangehashpart(t, &newt);  /* restore old hash (in case of errors) */\n  }\n  /* allocate new array */\n  newarray = resizearray(L, t, oldasize, newasize);\n  if (l_unlikely(newarray == NULL && newasize > 0)) {  /* allocation failed? */\n    freehash(L, &newt);  /* release new hash part */\n    luaM_error(L);  /* raise error (with array unchanged) */\n  }\n  /* allocation ok; initialize new part of the array */\n  exchangehashpart(t, &newt);  /* 't' has the new hash ('newt' has the old) */\n  t->array = newarray;  /* set new array part */\n  t->asize = newasize;\n  if (newarray != NULL)\n    *lenhint(t) = newasize / 2u;  /* set an initial hint */\n  clearNewSlice(t, oldasize, newasize);\n  /* re-insert elements from old hash part into new parts */\n  reinserthash(L, &newt, t);  /* 'newt' now has the old hash */\n  freehash(L, &newt);  /* free old hash part */\n}\n\n\nvoid luaH_resizearray (lua_State *L, Table *t, unsigned int nasize) {\n  unsigned nsize = allocsizenode(t);\n  luaH_resize(L, t, nasize, nsize);\n}\n\n\n/*\n** Rehash a table. First, count its keys. If there are array indices\n** outside the array part, compute the new best size for that part.\n** Then, resize the table.\n*/\nstatic void rehash (lua_State *L, Table *t, const TValue *ek) {\n  unsigned asize;  /* optimal size for array part */\n  Counters ct;\n  unsigned i;\n  unsigned nsize;  /* size for the hash part */\n  /* reset counts */\n  for (i = 0; i <= MAXABITS; i++) ct.nums[i] = 0;\n  ct.na = 0;\n  ct.deleted = 0;\n  ct.total = 1;  /* count extra key */\n  if (ttisinteger(ek))\n    countint(ivalue(ek), &ct);  /* extra key may go to array */\n  numusehash(t, &ct);  /* count keys in hash part */\n  if (ct.na == 0) {\n    /* no new keys to enter array part; keep it with the same size */\n    asize = t->asize;\n  }\n  else {  /* compute best size for array part */\n    numusearray(t, &ct);  /* count keys in array part */\n    asize = computesizes(&ct);  /* compute new size for array part */\n  }\n  /* all keys not in the array part go to the hash part */\n  nsize = ct.total - ct.na;\n  if (ct.deleted) {  /* table has deleted entries? */\n    /* insertion-deletion-insertion: give hash some extra size to\n       avoid constant resizings */\n    nsize += nsize >> 2;\n  }\n  /* resize the table to new computed sizes */\n  luaH_resize(L, t, asize, nsize);\n}\n\n/*\n** }=============================================================\n*/\n\n\nTable *luaH_new (lua_State *L) {\n  GCObject *o = luaC_newobj(L, LUA_VTABLE, sizeof(Table));\n  Table *t = gco2t(o);\n  t->metatable = NULL;\n  t->flags = maskflags;  /* table has no metamethod fields */\n  t->array = NULL;\n  t->asize = 0;\n  setnodevector(L, t, 0);\n  return t;\n}\n\n\nlu_mem luaH_size (Table *t) {\n  lu_mem sz = cast(lu_mem, sizeof(Table)) + concretesize(t->asize);\n  if (!isdummy(t))\n    sz += sizehash(t);\n  return sz;\n}\n\n\n/*\n** Frees a table.\n*/\nvoid luaH_free (lua_State *L, Table *t) {\n  freehash(L, t);\n  resizearray(L, t, t->asize, 0);\n  luaM_free(L, t);\n}\n\n\nstatic Node *getfreepos (Table *t) {\n  if (haslastfree(t)) {  /* does it have 'lastfree' information? */\n    /* look for a spot before 'lastfree', updating 'lastfree' */\n    while (getlastfree(t) > t->node) {\n      Node *free = --getlastfree(t);\n      if (keyisnil(free))\n        return free;\n    }\n  }\n  else {  /* no 'lastfree' information */\n    unsigned i = sizenode(t);\n    while (i--) {  /* do a linear search */\n      Node *free = gnode(t, i);\n      if (keyisnil(free))\n        return free;\n    }\n  }\n  return NULL;  /* could not find a free place */\n}\n\n\n\n/*\n** Inserts a new key into a hash table; first, check whether key's main\n** position is free. If not, check whether colliding node is in its main\n** position or not: if it is not, move colliding node to an empty place\n** and put new key in its main position; otherwise (colliding node is in\n** its main position), new key goes to an empty position. Return 0 if\n** could not insert key (could not find a free space).\n*/\nstatic int insertkey (Table *t, const TValue *key, TValue *value) {\n  Node *mp = mainpositionTV(t, key);\n  /* table cannot already contain the key */\n  lua_assert(isabstkey(getgeneric(t, key, 0)));\n  if (!isempty(gval(mp)) || isdummy(t)) {  /* main position is taken? */\n    Node *othern;\n    Node *f = getfreepos(t);  /* get a free place */\n    if (f == NULL)  /* cannot find a free place? */\n      return 0;\n    lua_assert(!isdummy(t));\n    othern = mainpositionfromnode(t, mp);\n    if (othern != mp) {  /* is colliding node out of its main position? */\n      /* yes; move colliding node into free position */\n      while (othern + gnext(othern) != mp)  /* find previous */\n        othern += gnext(othern);\n      gnext(othern) = cast_int(f - othern);  /* rechain to point to 'f' */\n      *f = *mp;  /* copy colliding node into free pos. (mp->next also goes) */\n      if (gnext(mp) != 0) {\n        gnext(f) += cast_int(mp - f);  /* correct 'next' */\n        gnext(mp) = 0;  /* now 'mp' is free */\n      }\n      setempty(gval(mp));\n    }\n    else {  /* colliding node is in its own main position */\n      /* new node will go into free position */\n      if (gnext(mp) != 0)\n        gnext(f) = cast_int((mp + gnext(mp)) - f);  /* chain new position */\n      else lua_assert(gnext(f) == 0);\n      gnext(mp) = cast_int(f - mp);\n      mp = f;\n    }\n  }\n  setnodekey(mp, key);\n  lua_assert(isempty(gval(mp)));\n  setobj2t(cast(lua_State *, 0), gval(mp), value);\n  return 1;\n}\n\n\n/*\n** Insert a key in a table where there is space for that key, the\n** key is valid, and the value is not nil.\n*/\nstatic void newcheckedkey (Table *t, const TValue *key, TValue *value) {\n  unsigned i = keyinarray(t, key);\n  if (i > 0)  /* is key in the array part? */\n    obj2arr(t, i - 1, value);  /* set value in the array */\n  else {\n    int done = insertkey(t, key, value);  /* insert key in the hash part */\n    lua_assert(done);  /* it cannot fail */\n    cast(void, done);  /* to avoid warnings */\n  }\n}\n\n\nstatic void luaH_newkey (lua_State *L, Table *t, const TValue *key,\n                                                 TValue *value) {\n  if (!ttisnil(value)) {  /* do not insert nil values */\n    int done = insertkey(t, key, value);\n    if (!done) {  /* could not find a free place? */\n      rehash(L, t, key);  /* grow table */\n      newcheckedkey(t, key, value);  /* insert key in grown table */\n    }\n    luaC_barrierback(L, obj2gco(t), key);\n  }\n}\n\n\nstatic const TValue *getintfromhash (Table *t, lua_Integer key) {\n  Node *n = hashint(t, key);\n  lua_assert(!ikeyinarray(t, key));\n  for (;;) {  /* check whether 'key' is somewhere in the chain */\n    if (keyisinteger(n) && keyival(n) == key)\n      return gval(n);  /* that's it */\n    else {\n      int nx = gnext(n);\n      if (nx == 0) break;\n      n += nx;\n    }\n  }\n  return &absentkey;\n}\n\n\nstatic int hashkeyisempty (Table *t, lua_Unsigned key) {\n  const TValue *val = getintfromhash(t, l_castU2S(key));\n  return isempty(val);\n}\n\n\nstatic lu_byte finishnodeget (const TValue *val, TValue *res) {\n  if (!ttisnil(val)) {\n    setobj(((lua_State*)NULL), res, val);\n  }\n  return ttypetag(val);\n}\n\n\nlu_byte luaH_getint (Table *t, lua_Integer key, TValue *res) {\n  unsigned k = ikeyinarray(t, key);\n  if (k > 0) {\n    lu_byte tag = *getArrTag(t, k - 1);\n    if (!tagisempty(tag))\n      farr2val(t, k - 1, tag, res);\n    return tag;\n  }\n  else\n    return finishnodeget(getintfromhash(t, key), res);\n}\n\n\n/*\n** search function for short strings\n*/\nconst TValue *luaH_Hgetshortstr (Table *t, TString *key) {\n  Node *n = hashstr(t, key);\n  lua_assert(key->tt == LUA_VSHRSTR);\n  for (;;) {  /* check whether 'key' is somewhere in the chain */\n    if (keyisshrstr(n) && eqshrstr(keystrval(n), key))\n      return gval(n);  /* that's it */\n    else {\n      int nx = gnext(n);\n      if (nx == 0)\n        return &absentkey;  /* not found */\n      n += nx;\n    }\n  }\n}\n\n\nlu_byte luaH_getshortstr (Table *t, TString *key, TValue *res) {\n  return finishnodeget(luaH_Hgetshortstr(t, key), res);\n}\n\n\nstatic const TValue *Hgetstr (Table *t, TString *key) {\n  if (key->tt == LUA_VSHRSTR)\n    return luaH_Hgetshortstr(t, key);\n  else {  /* for long strings, use generic case */\n    TValue ko;\n    setsvalue(cast(lua_State *, NULL), &ko, key);\n    return getgeneric(t, &ko, 0);\n  }\n}\n\n\nlu_byte luaH_getstr (Table *t, TString *key, TValue *res) {\n  return finishnodeget(Hgetstr(t, key), res);\n}\n\n\nTString *luaH_getstrkey (Table *t, TString *key) {\n  const TValue *o = Hgetstr(t, key);\n  if (!isabstkey(o))  /* string already present? */\n    return keystrval(nodefromval(o));  /* get saved copy */\n  else\n    return NULL;\n}\n\n\n/*\n** main search function\n*/\nlu_byte luaH_get (Table *t, const TValue *key, TValue *res) {\n  const TValue *slot;\n  switch (ttypetag(key)) {\n    case LUA_VSHRSTR:\n      slot = luaH_Hgetshortstr(t, tsvalue(key));\n      break;\n    case LUA_VNUMINT:\n      return luaH_getint(t, ivalue(key), res);\n    case LUA_VNIL:\n      slot = &absentkey;\n      break;\n    case LUA_VNUMFLT: {\n      lua_Integer k;\n      if (luaV_flttointeger(fltvalue(key), &k, F2Ieq)) /* integral index? */\n        return luaH_getint(t, k, res);  /* use specialized version */\n      /* else... */\n    }  /* FALLTHROUGH */\n    default:\n      slot = getgeneric(t, key, 0);\n      break;\n  }\n  return finishnodeget(slot, res);\n}\n\n\nstatic int finishnodeset (Table *t, const TValue *slot, TValue *val) {\n  if (!ttisnil(slot)) {\n    setobj(((lua_State*)NULL), cast(TValue*, slot), val);\n    return HOK;  /* success */\n  }\n  else if (isabstkey(slot))\n    return HNOTFOUND;  /* no slot with that key */\n  else  /* return node encoded */\n    return cast_int((cast(Node*, slot) - t->node)) + HFIRSTNODE;\n}\n\n\nstatic int rawfinishnodeset (const TValue *slot, TValue *val) {\n  if (isabstkey(slot))\n    return 0;  /* no slot with that key */\n  else {\n    setobj(((lua_State*)NULL), cast(TValue*, slot), val);\n    return 1;  /* success */\n  }\n}\n\n\nint luaH_psetint (Table *t, lua_Integer key, TValue *val) {\n  lua_assert(!ikeyinarray(t, key));\n  return finishnodeset(t, getintfromhash(t, key), val);\n}\n\n\nstatic int psetint (Table *t, lua_Integer key, TValue *val) {\n  int hres;\n  luaH_fastseti(t, key, val, hres);\n  return hres;\n}\n\n\nint luaH_psetshortstr (Table *t, TString *key, TValue *val) {\n  return finishnodeset(t, luaH_Hgetshortstr(t, key), val);\n}\n\n\nint luaH_psetstr (Table *t, TString *key, TValue *val) {\n  return finishnodeset(t, Hgetstr(t, key), val);\n}\n\n\nint luaH_pset (Table *t, const TValue *key, TValue *val) {\n  switch (ttypetag(key)) {\n    case LUA_VSHRSTR: return luaH_psetshortstr(t, tsvalue(key), val);\n    case LUA_VNUMINT: return psetint(t, ivalue(key), val);\n    case LUA_VNIL: return HNOTFOUND;\n    case LUA_VNUMFLT: {\n      lua_Integer k;\n      if (luaV_flttointeger(fltvalue(key), &k, F2Ieq)) /* integral index? */\n        return psetint(t, k, val);  /* use specialized version */\n      /* else... */\n    }  /* FALLTHROUGH */\n    default:\n      return finishnodeset(t, getgeneric(t, key, 0), val);\n  }\n}\n\n/*\n** Finish a raw \"set table\" operation, where 'slot' is where the value\n** should have been (the result of a previous \"get table\").\n** Beware: when using this function you probably need to check a GC\n** barrier and invalidate the TM cache.\n*/\n\n\nvoid luaH_finishset (lua_State *L, Table *t, const TValue *key,\n                                    TValue *value, int hres) {\n  lua_assert(hres != HOK);\n  if (hres == HNOTFOUND) {\n    TValue aux;\n    if (l_unlikely(ttisnil(key)))\n      luaG_runerror(L, \"table index is nil\");\n    else if (ttisfloat(key)) {\n      lua_Number f = fltvalue(key);\n      lua_Integer k;\n      if (luaV_flttointeger(f, &k, F2Ieq)) {\n        setivalue(&aux, k);  /* key is equal to an integer */\n        key = &aux;  /* insert it as an integer */\n      }\n      else if (l_unlikely(luai_numisnan(f)))\n        luaG_runerror(L, \"table index is NaN\");\n    }\n    luaH_newkey(L, t, key, value);\n  }\n  else if (hres > 0) {  /* regular Node? */\n    setobj2t(L, gval(gnode(t, hres - HFIRSTNODE)), value);\n  }\n  else {  /* array entry */\n    hres = ~hres;  /* real index */\n    obj2arr(t, cast_uint(hres), value);\n  }\n}\n\n\n/*\n** beware: when using this function you probably need to check a GC\n** barrier and invalidate the TM cache.\n*/\nvoid luaH_set (lua_State *L, Table *t, const TValue *key, TValue *value) {\n  int hres = luaH_pset(t, key, value);\n  if (hres != HOK)\n    luaH_finishset(L, t, key, value, hres);\n}\n\n\n/*\n** Ditto for a GC barrier. (No need to invalidate the TM cache, as\n** integers cannot be keys to metamethods.)\n*/\nvoid luaH_setint (lua_State *L, Table *t, lua_Integer key, TValue *value) {\n  unsigned ik = ikeyinarray(t, key);\n  if (ik > 0)\n    obj2arr(t, ik - 1, value);\n  else {\n    int ok = rawfinishnodeset(getintfromhash(t, key), value);\n    if (!ok) {\n      TValue k;\n      setivalue(&k, key);\n      luaH_newkey(L, t, &k, value);\n    }\n  }\n}\n\n\n/*\n** Try to find a boundary in the hash part of table 't'. From the\n** caller, we know that 'j' is zero or present and that 'j + 1' is\n** present. We want to find a larger key that is absent from the\n** table, so that we can do a binary search between the two keys to\n** find a boundary. We keep doubling 'j' until we get an absent index.\n** If the doubling would overflow, we try LUA_MAXINTEGER. If it is\n** absent, we are ready for the binary search. ('j', being max integer,\n** is larger or equal to 'i', but it cannot be equal because it is\n** absent while 'i' is present; so 'j > i'.) Otherwise, 'j' is a\n** boundary. ('j + 1' cannot be a present integer key because it is\n** not a valid integer in Lua.)\n*/\nstatic lua_Unsigned hash_search (Table *t, lua_Unsigned j) {\n  lua_Unsigned i;\n  if (j == 0) j++;  /* the caller ensures 'j + 1' is present */\n  do {\n    i = j;  /* 'i' is a present index */\n    if (j <= l_castS2U(LUA_MAXINTEGER) / 2)\n      j *= 2;\n    else {\n      j = LUA_MAXINTEGER;\n      if (hashkeyisempty(t, j))  /* t[j] not present? */\n        break;  /* 'j' now is an absent index */\n      else  /* weird case */\n        return j;  /* well, max integer is a boundary... */\n    }\n  } while (!hashkeyisempty(t, j));  /* repeat until an absent t[j] */\n  /* i < j  &&  t[i] present  &&  t[j] absent */\n  while (j - i > 1u) {  /* do a binary search between them */\n    lua_Unsigned m = (i + j) / 2;\n    if (hashkeyisempty(t, m)) j = m;\n    else i = m;\n  }\n  return i;\n}\n\n\nstatic unsigned int binsearch (Table *array, unsigned int i, unsigned int j) {\n  lua_assert(i <= j);\n  while (j - i > 1u) {  /* binary search */\n    unsigned int m = (i + j) / 2;\n    if (arraykeyisempty(array, m)) j = m;\n    else i = m;\n  }\n  return i;\n}\n\n\n/* return a border, saving it as a hint for next call */\nstatic lua_Unsigned newhint (Table *t, unsigned hint) {\n  lua_assert(hint <= t->asize);\n  *lenhint(t) = hint;\n  return hint;\n}\n\n\n/*\n** Try to find a border in table 't'. (A 'border' is an integer index\n** such that t[i] is present and t[i+1] is absent, or 0 if t[1] is absent,\n** or 'maxinteger' if t[maxinteger] is present.)\n** If there is an array part, try to find a border there. First try\n** to find it in the vicinity of the previous result (hint), to handle\n** cases like 't[#t + 1] = val' or 't[#t] = nil', that move the border\n** by one entry. Otherwise, do a binary search to find the border.\n** If there is no array part, or its last element is non empty, the\n** border may be in the hash part.\n*/\nlua_Unsigned luaH_getn (Table *t) {\n  unsigned asize = t->asize;\n  if (asize > 0) {  /* is there an array part? */\n    const unsigned maxvicinity = 4;\n    unsigned limit = *lenhint(t);  /* start with the hint */\n    if (limit == 0)\n      limit = 1;  /* make limit a valid index in the array */\n    if (arraykeyisempty(t, limit)) {  /* t[limit] empty? */\n      /* there must be a border before 'limit' */\n      unsigned i;\n      /* look for a border in the vicinity of the hint */\n      for (i = 0; i < maxvicinity && limit > 1; i++) {\n        limit--;\n        if (!arraykeyisempty(t, limit))\n          return newhint(t, limit);  /* 'limit' is a border */\n      }\n      /* t[limit] still empty; search for a border in [0, limit) */\n      return newhint(t, binsearch(t, 0, limit));\n    }\n    else {  /* 'limit' is present in table; look for a border after it */\n      unsigned i;\n      /* look for a border in the vicinity of the hint */\n      for (i = 0; i < maxvicinity && limit < asize; i++) {\n        limit++;\n        if (arraykeyisempty(t, limit))\n          return newhint(t, limit - 1);  /* 'limit - 1' is a border */\n      }\n      if (arraykeyisempty(t, asize)) {  /* last element empty? */\n        /* t[limit] not empty; search for a border in [limit, asize) */\n        return newhint(t, binsearch(t, limit, asize));\n      }\n    }\n    /* last element non empty; set a hint to speed up findind that again */\n    /* (keys in the hash part cannot be hints) */\n    *lenhint(t) = asize;\n  }\n  /* no array part or t[asize] is not empty; check the hash part */\n  lua_assert(asize == 0 || !arraykeyisempty(t, asize));\n  if (isdummy(t) || hashkeyisempty(t, asize + 1))\n    return asize;  /* 'asize + 1' is empty */\n  else  /* 'asize + 1' is also non empty */\n    return hash_search(t, asize);\n}\n\n\n\n#if defined(LUA_DEBUG)\n\n/* export this function for the test library */\n\nNode *luaH_mainposition (const Table *t, const TValue *key) {\n  return mainpositionTV(t, key);\n}\n\n#endif\n"
        },
        {
          "name": "ltable.h",
          "type": "blob",
          "size": 6.328125,
          "content": "/*\n** $Id: ltable.h $\n** Lua tables (hash)\n** See Copyright Notice in lua.h\n*/\n\n#ifndef ltable_h\n#define ltable_h\n\n#include \"lobject.h\"\n\n\n#define gnode(t,i)\t(&(t)->node[i])\n#define gval(n)\t\t(&(n)->i_val)\n#define gnext(n)\t((n)->u.next)\n\n\n/*\n** Clear all bits of fast-access metamethods, which means that the table\n** may have any of these metamethods. (First access that fails after the\n** clearing will set the bit again.)\n*/\n#define invalidateTMcache(t)\t((t)->flags &= cast_byte(~maskflags))\n\n\n/*\n** Bit BITDUMMY set in 'flags' means the table is using the dummy node\n** for its hash part.\n*/\n\n#define BITDUMMY\t\t(1 << 6)\n#define NOTBITDUMMY\t\tcast_byte(~BITDUMMY)\n#define isdummy(t)\t\t((t)->flags & BITDUMMY)\n\n#define setnodummy(t)\t\t((t)->flags &= NOTBITDUMMY)\n#define setdummy(t)\t\t((t)->flags |= BITDUMMY)\n\n\n\n/* allocated size for hash nodes */\n#define allocsizenode(t)\t(isdummy(t) ? 0 : sizenode(t))\n\n\n/* returns the Node, given the value of a table entry */\n#define nodefromval(v)\tcast(Node *, (v))\n\n\n\n#define luaH_fastgeti(t,k,res,tag) \\\n  { Table *h = t; lua_Unsigned u = l_castS2U(k) - 1u; \\\n    if ((u < h->asize)) { \\\n      tag = *getArrTag(h, u); \\\n      if (!tagisempty(tag)) { farr2val(h, u, tag, res); }} \\\n    else { tag = luaH_getint(h, (k), res); }}\n\n\n#define luaH_fastseti(t,k,val,hres) \\\n  { Table *h = t; lua_Unsigned u = l_castS2U(k) - 1u; \\\n    if ((u < h->asize)) { \\\n      lu_byte *tag = getArrTag(h, u); \\\n      if (h->metatable == NULL || !tagisempty(*tag)) \\\n        { fval2arr(h, u, tag, val); hres = HOK; } \\\n      else hres = ~cast_int(u); } \\\n    else { hres = luaH_psetint(h, k, val); }}\n\n\n/* results from pset */\n#define HOK\t\t0\n#define HNOTFOUND\t1\n#define HNOTATABLE\t2\n#define HFIRSTNODE\t3\n\n/*\n** 'luaH_get*' operations set 'res', unless the value is absent, and\n** return the tag of the result.\n** The 'luaH_pset*' (pre-set) operations set the given value and return\n** HOK, unless the original value is absent. In that case, if the key\n** is really absent, they return HNOTFOUND. Otherwise, if there is a\n** slot with that key but with no value, 'luaH_pset*' return an encoding\n** of where the key is (usually called 'hres'). (pset cannot set that\n** value because there might be a metamethod.) If the slot is in the\n** hash part, the encoding is (HFIRSTNODE + hash index); if the slot is\n** in the array part, the encoding is (~array index), a negative value.\n** The value HNOTATABLE is used by the fast macros to signal that the\n** value being indexed is not a table.\n** (The size for the array part is limited by the maximum power of two\n** that fits in an unsigned integer; that is INT_MAX+1. So, the C-index\n** ranges from 0, which encodes to -1, to INT_MAX, which encodes to\n** INT_MIN. The size of the hash part is limited by the maximum power of\n** two that fits in a signed integer; that is (INT_MAX+1)/2. So, it is\n** safe to add HFIRSTNODE to any index there.)\n*/\n\n\n/*\n** The array part of a table is represented by an inverted array of\n** values followed by an array of tags, to avoid wasting space with\n** padding. In between them there is an unsigned int, explained later.\n** The 'array' pointer points between the two arrays, so that values are\n** indexed with negative indices and tags with non-negative indices.\n\n             Values                              Tags\n  --------------------------------------------------------\n  ...  |   Value 1     |   Value 0     |unsigned|0|1|...\n  --------------------------------------------------------\n                                       ^ t->array\n\n** All accesses to 't->array' should be through the macros 'getArrTag'\n** and 'getArrVal'.\n*/\n\n/* Computes the address of the tag for the abstract C-index 'k' */\n#define getArrTag(t,k)\t(cast(lu_byte*, (t)->array) + sizeof(unsigned) + (k))\n\n/* Computes the address of the value for the abstract C-index 'k' */\n#define getArrVal(t,k)\t((t)->array - 1 - (k))\n\n\n/*\n** The unsigned between the two arrays is used as a hint for #t;\n** see luaH_getn. It is stored there to avoid wasting space in\n** the structure Table for tables with no array part.\n*/\n#define lenhint(t)\tcast(unsigned*, (t)->array)\n\n\n/*\n** Move TValues to/from arrays, using C indices\n*/\n#define arr2obj(h,k,val)  \\\n  ((val)->tt_ = *getArrTag(h,(k)), (val)->value_ = *getArrVal(h,(k)))\n\n#define obj2arr(h,k,val)  \\\n  (*getArrTag(h,(k)) = (val)->tt_, *getArrVal(h,(k)) = (val)->value_)\n\n\n/*\n** Often, we need to check the tag of a value before moving it. The\n** following macros also move TValues to/from arrays, but receive the\n** precomputed tag value or address as an extra argument.\n*/\n#define farr2val(h,k,tag,res)  \\\n  ((res)->tt_ = tag, (res)->value_ = *getArrVal(h,(k)))\n\n#define fval2arr(h,k,tag,val)  \\\n  (*tag = (val)->tt_, *getArrVal(h,(k)) = (val)->value_)\n\n\nLUAI_FUNC lu_byte luaH_get (Table *t, const TValue *key, TValue *res);\nLUAI_FUNC lu_byte luaH_getshortstr (Table *t, TString *key, TValue *res);\nLUAI_FUNC lu_byte luaH_getstr (Table *t, TString *key, TValue *res);\nLUAI_FUNC lu_byte luaH_getint (Table *t, lua_Integer key, TValue *res);\n\n/* Special get for metamethods */\nLUAI_FUNC const TValue *luaH_Hgetshortstr (Table *t, TString *key);\n\nLUAI_FUNC TString *luaH_getstrkey (Table *t, TString *key);\n\nLUAI_FUNC int luaH_psetint (Table *t, lua_Integer key, TValue *val);\nLUAI_FUNC int luaH_psetshortstr (Table *t, TString *key, TValue *val);\nLUAI_FUNC int luaH_psetstr (Table *t, TString *key, TValue *val);\nLUAI_FUNC int luaH_pset (Table *t, const TValue *key, TValue *val);\n\nLUAI_FUNC void luaH_setint (lua_State *L, Table *t, lua_Integer key,\n                                                    TValue *value);\nLUAI_FUNC void luaH_set (lua_State *L, Table *t, const TValue *key,\n                                                 TValue *value);\n\nLUAI_FUNC void luaH_finishset (lua_State *L, Table *t, const TValue *key,\n                                              TValue *value, int hres);\nLUAI_FUNC Table *luaH_new (lua_State *L);\nLUAI_FUNC void luaH_resize (lua_State *L, Table *t, unsigned nasize,\n                                                    unsigned nhsize);\nLUAI_FUNC void luaH_resizearray (lua_State *L, Table *t, unsigned nasize);\nLUAI_FUNC lu_mem luaH_size (Table *t);\nLUAI_FUNC void luaH_free (lua_State *L, Table *t);\nLUAI_FUNC int luaH_next (lua_State *L, Table *t, StkId key);\nLUAI_FUNC lua_Unsigned luaH_getn (Table *t);\n\n\n#if defined(LUA_DEBUG)\nLUAI_FUNC Node *luaH_mainposition (const Table *t, const TValue *key);\n#endif\n\n\n#endif\n"
        },
        {
          "name": "ltablib.c",
          "type": "blob",
          "size": 12.8447265625,
          "content": "/*\n** $Id: ltablib.c $\n** Library for Table Manipulation\n** See Copyright Notice in lua.h\n*/\n\n#define ltablib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <limits.h>\n#include <stddef.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n#include \"llimits.h\"\n\n\n/*\n** Operations that an object must define to mimic a table\n** (some functions only need some of them)\n*/\n#define TAB_R\t1\t\t\t/* read */\n#define TAB_W\t2\t\t\t/* write */\n#define TAB_L\t4\t\t\t/* length */\n#define TAB_RW\t(TAB_R | TAB_W)\t\t/* read/write */\n\n\n#define aux_getn(L,n,w)\t(checktab(L, n, (w) | TAB_L), luaL_len(L, n))\n\n\nstatic int checkfield (lua_State *L, const char *key, int n) {\n  lua_pushstring(L, key);\n  return (lua_rawget(L, -n) != LUA_TNIL);\n}\n\n\n/*\n** Check that 'arg' either is a table or can behave like one (that is,\n** has a metatable with the required metamethods)\n*/\nstatic void checktab (lua_State *L, int arg, int what) {\n  if (lua_type(L, arg) != LUA_TTABLE) {  /* is it not a table? */\n    int n = 1;  /* number of elements to pop */\n    if (lua_getmetatable(L, arg) &&  /* must have metatable */\n        (!(what & TAB_R) || checkfield(L, \"__index\", ++n)) &&\n        (!(what & TAB_W) || checkfield(L, \"__newindex\", ++n)) &&\n        (!(what & TAB_L) || checkfield(L, \"__len\", ++n))) {\n      lua_pop(L, n);  /* pop metatable and tested metamethods */\n    }\n    else\n      luaL_checktype(L, arg, LUA_TTABLE);  /* force an error */\n  }\n}\n\n\nstatic int tcreate (lua_State *L) {\n  lua_Unsigned sizeseq = (lua_Unsigned)luaL_checkinteger(L, 1);\n  lua_Unsigned sizerest = (lua_Unsigned)luaL_optinteger(L, 2, 0);\n  luaL_argcheck(L, sizeseq <= UINT_MAX, 1, \"out of range\");\n  luaL_argcheck(L, sizerest <= UINT_MAX, 2, \"out of range\");\n  lua_createtable(L, (unsigned)sizeseq, (unsigned)sizerest);\n  return 1;\n}\n\n\nstatic int tinsert (lua_State *L) {\n  lua_Integer pos;  /* where to insert new element */\n  lua_Integer e = aux_getn(L, 1, TAB_RW);\n  e = luaL_intop(+, e, 1);  /* first empty element */\n  switch (lua_gettop(L)) {\n    case 2: {  /* called with only 2 arguments */\n      pos = e;  /* insert new element at the end */\n      break;\n    }\n    case 3: {\n      lua_Integer i;\n      pos = luaL_checkinteger(L, 2);  /* 2nd argument is the position */\n      /* check whether 'pos' is in [1, e] */\n      luaL_argcheck(L, (lua_Unsigned)pos - 1u < (lua_Unsigned)e, 2,\n                       \"position out of bounds\");\n      for (i = e; i > pos; i--) {  /* move up elements */\n        lua_geti(L, 1, i - 1);\n        lua_seti(L, 1, i);  /* t[i] = t[i - 1] */\n      }\n      break;\n    }\n    default: {\n      return luaL_error(L, \"wrong number of arguments to 'insert'\");\n    }\n  }\n  lua_seti(L, 1, pos);  /* t[pos] = v */\n  return 0;\n}\n\n\nstatic int tremove (lua_State *L) {\n  lua_Integer size = aux_getn(L, 1, TAB_RW);\n  lua_Integer pos = luaL_optinteger(L, 2, size);\n  if (pos != size)  /* validate 'pos' if given */\n    /* check whether 'pos' is in [1, size + 1] */\n    luaL_argcheck(L, (lua_Unsigned)pos - 1u <= (lua_Unsigned)size, 2,\n                     \"position out of bounds\");\n  lua_geti(L, 1, pos);  /* result = t[pos] */\n  for ( ; pos < size; pos++) {\n    lua_geti(L, 1, pos + 1);\n    lua_seti(L, 1, pos);  /* t[pos] = t[pos + 1] */\n  }\n  lua_pushnil(L);\n  lua_seti(L, 1, pos);  /* remove entry t[pos] */\n  return 1;\n}\n\n\n/*\n** Copy elements (1[f], ..., 1[e]) into (tt[t], tt[t+1], ...). Whenever\n** possible, copy in increasing order, which is better for rehashing.\n** \"possible\" means destination after original range, or smaller\n** than origin, or copying to another table.\n*/\nstatic int tmove (lua_State *L) {\n  lua_Integer f = luaL_checkinteger(L, 2);\n  lua_Integer e = luaL_checkinteger(L, 3);\n  lua_Integer t = luaL_checkinteger(L, 4);\n  int tt = !lua_isnoneornil(L, 5) ? 5 : 1;  /* destination table */\n  checktab(L, 1, TAB_R);\n  checktab(L, tt, TAB_W);\n  if (e >= f) {  /* otherwise, nothing to move */\n    lua_Integer n, i;\n    luaL_argcheck(L, f > 0 || e < LUA_MAXINTEGER + f, 3,\n                  \"too many elements to move\");\n    n = e - f + 1;  /* number of elements to move */\n    luaL_argcheck(L, t <= LUA_MAXINTEGER - n + 1, 4,\n                  \"destination wrap around\");\n    if (t > e || t <= f || (tt != 1 && !lua_compare(L, 1, tt, LUA_OPEQ))) {\n      for (i = 0; i < n; i++) {\n        lua_geti(L, 1, f + i);\n        lua_seti(L, tt, t + i);\n      }\n    }\n    else {\n      for (i = n - 1; i >= 0; i--) {\n        lua_geti(L, 1, f + i);\n        lua_seti(L, tt, t + i);\n      }\n    }\n  }\n  lua_pushvalue(L, tt);  /* return destination table */\n  return 1;\n}\n\n\nstatic void addfield (lua_State *L, luaL_Buffer *b, lua_Integer i) {\n  lua_geti(L, 1, i);\n  if (l_unlikely(!lua_isstring(L, -1)))\n    luaL_error(L, \"invalid value (%s) at index %I in table for 'concat'\",\n                  luaL_typename(L, -1), (LUAI_UACINT)i);\n  luaL_addvalue(b);\n}\n\n\nstatic int tconcat (lua_State *L) {\n  luaL_Buffer b;\n  lua_Integer last = aux_getn(L, 1, TAB_R);\n  size_t lsep;\n  const char *sep = luaL_optlstring(L, 2, \"\", &lsep);\n  lua_Integer i = luaL_optinteger(L, 3, 1);\n  last = luaL_optinteger(L, 4, last);\n  luaL_buffinit(L, &b);\n  for (; i < last; i++) {\n    addfield(L, &b, i);\n    luaL_addlstring(&b, sep, lsep);\n  }\n  if (i == last)  /* add last value (if interval was not empty) */\n    addfield(L, &b, i);\n  luaL_pushresult(&b);\n  return 1;\n}\n\n\n/*\n** {======================================================\n** Pack/unpack\n** =======================================================\n*/\n\nstatic int tpack (lua_State *L) {\n  int i;\n  int n = lua_gettop(L);  /* number of elements to pack */\n  lua_createtable(L, cast_uint(n), 1);  /* create result table */\n  lua_insert(L, 1);  /* put it at index 1 */\n  for (i = n; i >= 1; i--)  /* assign elements */\n    lua_seti(L, 1, i);\n  lua_pushinteger(L, n);\n  lua_setfield(L, 1, \"n\");  /* t.n = number of elements */\n  return 1;  /* return table */\n}\n\n\nstatic int tunpack (lua_State *L) {\n  lua_Unsigned n;\n  lua_Integer i = luaL_optinteger(L, 2, 1);\n  lua_Integer e = luaL_opt(L, luaL_checkinteger, 3, luaL_len(L, 1));\n  if (i > e) return 0;  /* empty range */\n  n = l_castS2U(e) - l_castS2U(i);  /* number of elements minus 1 */\n  if (l_unlikely(n >= (unsigned int)INT_MAX  ||\n                 !lua_checkstack(L, (int)(++n))))\n    return luaL_error(L, \"too many results to unpack\");\n  for (; i < e; i++) {  /* push arg[i..e - 1] (to avoid overflows) */\n    lua_geti(L, 1, i);\n  }\n  lua_geti(L, 1, e);  /* push last element */\n  return (int)n;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** Quicksort\n** (based on 'Algorithms in MODULA-3', Robert Sedgewick;\n**  Addison-Wesley, 1993.)\n** =======================================================\n*/\n\n\n/*\n** Type for array indices. These indices are always limited by INT_MAX,\n** so it is safe to cast them to lua_Integer even for Lua 32 bits.\n*/\ntypedef unsigned int IdxT;\n\n\n/* Versions of lua_seti/lua_geti specialized for IdxT */\n#define geti(L,idt,idx)\tlua_geti(L, idt, l_castU2S(idx))\n#define seti(L,idt,idx)\tlua_seti(L, idt, l_castU2S(idx))\n\n\n/*\n** Produce a \"random\" 'unsigned int' to randomize pivot choice. This\n** macro is used only when 'sort' detects a big imbalance in the result\n** of a partition. (If you don't want/need this \"randomness\", ~0 is a\n** good choice.)\n*/\n#if !defined(l_randomizePivot)\n#define l_randomizePivot(L)\tluaL_makeseed(L)\n#endif\t\t\t\t\t/* } */\n\n\n/* arrays larger than 'RANLIMIT' may use randomized pivots */\n#define RANLIMIT\t100u\n\n\nstatic void set2 (lua_State *L, IdxT i, IdxT j) {\n  seti(L, 1, i);\n  seti(L, 1, j);\n}\n\n\n/*\n** Return true iff value at stack index 'a' is less than the value at\n** index 'b' (according to the order of the sort).\n*/\nstatic int sort_comp (lua_State *L, int a, int b) {\n  if (lua_isnil(L, 2))  /* no function? */\n    return lua_compare(L, a, b, LUA_OPLT);  /* a < b */\n  else {  /* function */\n    int res;\n    lua_pushvalue(L, 2);    /* push function */\n    lua_pushvalue(L, a-1);  /* -1 to compensate function */\n    lua_pushvalue(L, b-2);  /* -2 to compensate function and 'a' */\n    lua_call(L, 2, 1);      /* call function */\n    res = lua_toboolean(L, -1);  /* get result */\n    lua_pop(L, 1);          /* pop result */\n    return res;\n  }\n}\n\n\n/*\n** Does the partition: Pivot P is at the top of the stack.\n** precondition: a[lo] <= P == a[up-1] <= a[up],\n** so it only needs to do the partition from lo + 1 to up - 2.\n** Pos-condition: a[lo .. i - 1] <= a[i] == P <= a[i + 1 .. up]\n** returns 'i'.\n*/\nstatic IdxT partition (lua_State *L, IdxT lo, IdxT up) {\n  IdxT i = lo;  /* will be incremented before first use */\n  IdxT j = up - 1;  /* will be decremented before first use */\n  /* loop invariant: a[lo .. i] <= P <= a[j .. up] */\n  for (;;) {\n    /* next loop: repeat ++i while a[i] < P */\n    while ((void)geti(L, 1, ++i), sort_comp(L, -1, -2)) {\n      if (l_unlikely(i == up - 1))  /* a[up - 1] < P == a[up - 1] */\n        luaL_error(L, \"invalid order function for sorting\");\n      lua_pop(L, 1);  /* remove a[i] */\n    }\n    /* after the loop, a[i] >= P and a[lo .. i - 1] < P  (a) */\n    /* next loop: repeat --j while P < a[j] */\n    while ((void)geti(L, 1, --j), sort_comp(L, -3, -1)) {\n      if (l_unlikely(j < i))  /* j <= i - 1 and a[j] > P, contradicts (a) */\n        luaL_error(L, \"invalid order function for sorting\");\n      lua_pop(L, 1);  /* remove a[j] */\n    }\n    /* after the loop, a[j] <= P and a[j + 1 .. up] >= P */\n    if (j < i) {  /* no elements out of place? */\n      /* a[lo .. i - 1] <= P <= a[j + 1 .. i .. up] */\n      lua_pop(L, 1);  /* pop a[j] */\n      /* swap pivot (a[up - 1]) with a[i] to satisfy pos-condition */\n      set2(L, up - 1, i);\n      return i;\n    }\n    /* otherwise, swap a[i] - a[j] to restore invariant and repeat */\n    set2(L, i, j);\n  }\n}\n\n\n/*\n** Choose an element in the middle (2nd-3th quarters) of [lo,up]\n** \"randomized\" by 'rnd'\n*/\nstatic IdxT choosePivot (IdxT lo, IdxT up, unsigned int rnd) {\n  IdxT r4 = (up - lo) / 4;  /* range/4 */\n  IdxT p = (rnd ^ lo ^ up) % (r4 * 2) + (lo + r4);\n  lua_assert(lo + r4 <= p && p <= up - r4);\n  return p;\n}\n\n\n/*\n** Quicksort algorithm (recursive function)\n*/\nstatic void auxsort (lua_State *L, IdxT lo, IdxT up, unsigned rnd) {\n  while (lo < up) {  /* loop for tail recursion */\n    IdxT p;  /* Pivot index */\n    IdxT n;  /* to be used later */\n    /* sort elements 'lo', 'p', and 'up' */\n    geti(L, 1, lo);\n    geti(L, 1, up);\n    if (sort_comp(L, -1, -2))  /* a[up] < a[lo]? */\n      set2(L, lo, up);  /* swap a[lo] - a[up] */\n    else\n      lua_pop(L, 2);  /* remove both values */\n    if (up - lo == 1)  /* only 2 elements? */\n      return;  /* already sorted */\n    if (up - lo < RANLIMIT || rnd == 0)  /* small interval or no randomize? */\n      p = (lo + up)/2;  /* middle element is a good pivot */\n    else  /* for larger intervals, it is worth a random pivot */\n      p = choosePivot(lo, up, rnd);\n    geti(L, 1, p);\n    geti(L, 1, lo);\n    if (sort_comp(L, -2, -1))  /* a[p] < a[lo]? */\n      set2(L, p, lo);  /* swap a[p] - a[lo] */\n    else {\n      lua_pop(L, 1);  /* remove a[lo] */\n      geti(L, 1, up);\n      if (sort_comp(L, -1, -2))  /* a[up] < a[p]? */\n        set2(L, p, up);  /* swap a[up] - a[p] */\n      else\n        lua_pop(L, 2);\n    }\n    if (up - lo == 2)  /* only 3 elements? */\n      return;  /* already sorted */\n    geti(L, 1, p);  /* get middle element (Pivot) */\n    lua_pushvalue(L, -1);  /* push Pivot */\n    geti(L, 1, up - 1);  /* push a[up - 1] */\n    set2(L, p, up - 1);  /* swap Pivot (a[p]) with a[up - 1] */\n    p = partition(L, lo, up);\n    /* a[lo .. p - 1] <= a[p] == P <= a[p + 1 .. up] */\n    if (p - lo < up - p) {  /* lower interval is smaller? */\n      auxsort(L, lo, p - 1, rnd);  /* call recursively for lower interval */\n      n = p - lo;  /* size of smaller interval */\n      lo = p + 1;  /* tail call for [p + 1 .. up] (upper interval) */\n    }\n    else {\n      auxsort(L, p + 1, up, rnd);  /* call recursively for upper interval */\n      n = up - p;  /* size of smaller interval */\n      up = p - 1;  /* tail call for [lo .. p - 1]  (lower interval) */\n    }\n    if ((up - lo) / 128 > n) /* partition too imbalanced? */\n      rnd = l_randomizePivot(L);  /* try a new randomization */\n  }  /* tail call auxsort(L, lo, up, rnd) */\n}\n\n\nstatic int sort (lua_State *L) {\n  lua_Integer n = aux_getn(L, 1, TAB_RW);\n  if (n > 1) {  /* non-trivial interval? */\n    luaL_argcheck(L, n < INT_MAX, 1, \"array too big\");\n    if (!lua_isnoneornil(L, 2))  /* is there a 2nd argument? */\n      luaL_checktype(L, 2, LUA_TFUNCTION);  /* must be a function */\n    lua_settop(L, 2);  /* make sure there are two arguments */\n    auxsort(L, 1, (IdxT)n, 0);\n  }\n  return 0;\n}\n\n/* }====================================================== */\n\n\nstatic const luaL_Reg tab_funcs[] = {\n  {\"concat\", tconcat},\n  {\"create\", tcreate},\n  {\"insert\", tinsert},\n  {\"pack\", tpack},\n  {\"unpack\", tunpack},\n  {\"remove\", tremove},\n  {\"move\", tmove},\n  {\"sort\", sort},\n  {NULL, NULL}\n};\n\n\nLUAMOD_API int luaopen_table (lua_State *L) {\n  luaL_newlib(L, tab_funcs);\n  return 1;\n}\n\n"
        },
        {
          "name": "ltests.c",
          "type": "blob",
          "size": 55.7890625,
          "content": "/*\n** $Id: ltests.c $\n** Internal Module for Debugging of the Lua Implementation\n** See Copyright Notice in lua.h\n*/\n\n#define ltests_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <limits.h>\n#include <setjmp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"lauxlib.h\"\n#include \"lcode.h\"\n#include \"lctype.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lmem.h\"\n#include \"lopcodes.h\"\n#include \"lopnames.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lualib.h\"\n\n\n\n/*\n** The whole module only makes sense with LUA_DEBUG on\n*/\n#if defined(LUA_DEBUG)\n\n\nvoid *l_Trick = 0;\n\n\n#define obj_at(L,k)\ts2v(L->ci->func.p + (k))\n\n\nstatic int runC (lua_State *L, lua_State *L1, const char *pc);\n\n\nstatic void setnameval (lua_State *L, const char *name, int val) {\n  lua_pushinteger(L, val);\n  lua_setfield(L, -2, name);\n}\n\n\nstatic void pushobject (lua_State *L, const TValue *o) {\n  setobj2s(L, L->top.p, o);\n  api_incr_top(L);\n}\n\n\nstatic void badexit (const char *fmt, const char *s1, const char *s2) {\n  fprintf(stderr, fmt, s1);\n  if (s2)\n    fprintf(stderr, \"extra info: %s\\n\", s2);\n  /* avoid assertion failures when exiting */\n  l_memcontrol.numblocks = l_memcontrol.total = 0;\n  exit(EXIT_FAILURE);\n}\n\n\nstatic int tpanic (lua_State *L) {\n  const char *msg = (lua_type(L, -1) == LUA_TSTRING)\n                  ? lua_tostring(L, -1)\n                  : \"error object is not a string\";\n  return (badexit(\"PANIC: unprotected error in call to Lua API (%s)\\n\",\n                   msg, NULL),\n          0);  /* do not return to Lua */\n}\n\n\n/*\n** Warning function for tests. First, it concatenates all parts of\n** a warning in buffer 'buff'. Then, it has three modes:\n** - 0.normal: messages starting with '#' are shown on standard output;\n** - other messages abort the tests (they represent real warning\n** conditions; the standard tests should not generate these conditions\n** unexpectedly);\n** - 1.allow: all messages are shown;\n** - 2.store: all warnings go to the global '_WARN';\n*/\nstatic void warnf (void *ud, const char *msg, int tocont) {\n  lua_State *L = cast(lua_State *, ud);\n  static char buff[200] = \"\";  /* should be enough for tests... */\n  static int onoff = 0;\n  static int mode = 0;  /* start in normal mode */\n  static int lasttocont = 0;\n  if (!lasttocont && !tocont && *msg == '@') {  /* control message? */\n    if (buff[0] != '\\0')\n      badexit(\"Control warning during warning: %s\\naborting...\\n\", msg, buff);\n    if (strcmp(msg, \"@off\") == 0)\n      onoff = 0;\n    else if (strcmp(msg, \"@on\") == 0)\n      onoff = 1;\n    else if (strcmp(msg, \"@normal\") == 0)\n      mode = 0;\n    else if (strcmp(msg, \"@allow\") == 0)\n      mode = 1;\n    else if (strcmp(msg, \"@store\") == 0)\n      mode = 2;\n    else\n      badexit(\"Invalid control warning in test mode: %s\\naborting...\\n\",\n              msg, NULL);\n    return;\n  }\n  lasttocont = tocont;\n  if (strlen(msg) >= sizeof(buff) - strlen(buff))\n    badexit(\"warnf-buffer overflow (%s)\\n\", msg, buff);\n  strcat(buff, msg);  /* add new message to current warning */\n  if (!tocont) {  /* message finished? */\n    lua_unlock(L);\n    luaL_checkstack(L, 1, \"warn stack space\");\n    lua_getglobal(L, \"_WARN\");\n    if (!lua_toboolean(L, -1))\n      lua_pop(L, 1);  /* ok, no previous unexpected warning */\n    else {\n      badexit(\"Unhandled warning in store mode: %s\\naborting...\\n\",\n              lua_tostring(L, -1), buff);\n    }\n    lua_lock(L);\n    switch (mode) {\n      case 0: {  /* normal */\n        if (buff[0] != '#' && onoff)  /* unexpected warning? */\n          badexit(\"Unexpected warning in test mode: %s\\naborting...\\n\",\n                  buff, NULL);\n      }  /* FALLTHROUGH */\n      case 1: {  /* allow */\n        if (onoff)\n          fprintf(stderr, \"Lua warning: %s\\n\", buff);  /* print warning */\n        break;\n      }\n      case 2: {  /* store */\n        lua_unlock(L);\n        luaL_checkstack(L, 1, \"warn stack space\");\n        lua_pushstring(L, buff);\n        lua_setglobal(L, \"_WARN\");  /* assign message to global '_WARN' */\n        lua_lock(L);\n        break;\n      }\n    }\n    buff[0] = '\\0';  /* prepare buffer for next warning */\n  }\n}\n\n\n/*\n** {======================================================================\n** Controlled version for realloc.\n** =======================================================================\n*/\n\n#define MARK\t\t0x55  /* 01010101 (a nice pattern) */\n\ntypedef union Header {\n  LUAI_MAXALIGN;\n  struct {\n    size_t size;\n    int type;\n  } d;\n} Header;\n\n\n#if !defined(EXTERNMEMCHECK)\n\n/* full memory check */\n#define MARKSIZE\t16  /* size of marks after each block */\n#define fillmem(mem,size)\tmemset(mem, -MARK, size)\n\n#else\n\n/* external memory check: don't do it twice */\n#define MARKSIZE\t0\n#define fillmem(mem,size)\t/* empty */\n\n#endif\n\n\nMemcontrol l_memcontrol =\n  {0, 0UL, 0UL, 0UL, 0UL, (~0UL),\n   {0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL}};\n\n\nstatic void freeblock (Memcontrol *mc, Header *block) {\n  if (block) {\n    size_t size = block->d.size;\n    int i;\n    for (i = 0; i < MARKSIZE; i++)  /* check marks after block */\n      lua_assert(*(cast_charp(block + 1) + size + i) == MARK);\n    mc->objcount[block->d.type]--;\n    fillmem(block, sizeof(Header) + size + MARKSIZE);  /* erase block */\n    free(block);  /* actually free block */\n    mc->numblocks--;  /* update counts */\n    mc->total -= size;\n  }\n}\n\n\nvoid *debug_realloc (void *ud, void *b, size_t oldsize, size_t size) {\n  Memcontrol *mc = cast(Memcontrol *, ud);\n  Header *block = cast(Header *, b);\n  int type;\n  if (mc->memlimit == 0) {  /* first time? */\n    char *limit = getenv(\"MEMLIMIT\");  /* initialize memory limit */\n    mc->memlimit = limit ? strtoul(limit, NULL, 10) : ULONG_MAX;\n  }\n  if (block == NULL) {\n    type = (oldsize < LUA_NUMTYPES) ? cast_int(oldsize) : 0;\n    oldsize = 0;\n  }\n  else {\n    block--;  /* go to real header */\n    type = block->d.type;\n    lua_assert(oldsize == block->d.size);\n  }\n  if (size == 0) {\n    freeblock(mc, block);\n    return NULL;\n  }\n  if (mc->failnext) {\n    mc->failnext = 0;\n    return NULL;  /* fake a single memory allocation error */\n  }\n  if (mc->countlimit != ~0UL && size != oldsize) {  /* count limit in use? */\n    if (mc->countlimit == 0)\n      return NULL;  /* fake a memory allocation error */\n    mc->countlimit--;\n  }\n  if (size > oldsize && mc->total+size-oldsize > mc->memlimit)\n    return NULL;  /* fake a memory allocation error */\n  else {\n    Header *newblock;\n    int i;\n    size_t commonsize = (oldsize < size) ? oldsize : size;\n    size_t realsize = sizeof(Header) + size + MARKSIZE;\n    if (realsize < size) return NULL;  /* arithmetic overflow! */\n    newblock = cast(Header *, malloc(realsize));  /* alloc a new block */\n    if (newblock == NULL)\n      return NULL;  /* really out of memory? */\n    if (block) {\n      memcpy(newblock + 1, block + 1, commonsize);  /* copy old contents */\n      freeblock(mc, block);  /* erase (and check) old copy */\n    }\n    /* initialize new part of the block with something weird */\n    fillmem(cast_charp(newblock + 1) + commonsize, size - commonsize);\n    /* initialize marks after block */\n    for (i = 0; i < MARKSIZE; i++)\n      *(cast_charp(newblock + 1) + size + i) = MARK;\n    newblock->d.size = size;\n    newblock->d.type = type;\n    mc->total += size;\n    if (mc->total > mc->maxmem)\n      mc->maxmem = mc->total;\n    mc->numblocks++;\n    mc->objcount[type]++;\n    return newblock + 1;\n  }\n}\n\n\n/* }====================================================================== */\n\n\n\n/*\n** {=====================================================================\n** Functions to check memory consistency.\n** Most of these checks are done through asserts, so this code does\n** not make sense with asserts off. For this reason, it uses 'assert'\n** directly, instead of 'lua_assert'.\n** ======================================================================\n*/\n\n#include <assert.h>\n\n/*\n** Check GC invariants. For incremental mode, a black object cannot\n** point to a white one. For generational mode, really old objects\n** cannot point to young objects. Both old1 and touched2 objects\n** cannot point to new objects (but can point to survivals).\n** (Threads and open upvalues, despite being marked \"really old\",\n** continue to be visited in all collections, and therefore can point to\n** new objects. They, and only they, are old but gray.)\n*/\nstatic int testobjref1 (global_State *g, GCObject *f, GCObject *t) {\n  if (isdead(g,t)) return 0;\n  if (issweepphase(g))\n    return 1;  /* no invariants */\n  else if (g->gckind != KGC_GENMINOR)\n    return !(isblack(f) && iswhite(t));  /* basic incremental invariant */\n  else {  /* generational mode */\n    if ((getage(f) == G_OLD && isblack(f)) && !isold(t))\n      return 0;\n    if ((getage(f) == G_OLD1 || getage(f) == G_TOUCHED2) &&\n         getage(t) == G_NEW)\n      return 0;\n    return 1;\n  }\n}\n\n\nstatic void printobj (global_State *g, GCObject *o) {\n  printf(\"||%s(%p)-%c%c(%02X)||\",\n           ttypename(novariant(o->tt)), (void *)o,\n           isdead(g,o) ? 'd' : isblack(o) ? 'b' : iswhite(o) ? 'w' : 'g',\n           \"ns01oTt\"[getage(o)], o->marked);\n  if (o->tt == LUA_VSHRSTR || o->tt == LUA_VLNGSTR)\n    printf(\" '%s'\", getstr(gco2ts(o)));\n}\n\n\nvoid lua_printobj (lua_State *L, struct GCObject *o) {\n  printobj(G(L), o);\n}\n\n\nvoid lua_printvalue (TValue *v) {\n  switch (ttype(v)) {\n    case LUA_TNUMBER: {\n      char buff[LUA_N2SBUFFSZ];\n      unsigned len = luaO_tostringbuff(v, buff);\n      buff[len] = '\\0';\n      printf(\"%s\", buff);\n      break;\n    }\n    case LUA_TSTRING: {\n      printf(\"'%s'\", getstr(tsvalue(v)));\n      break;\n    }\n    case LUA_TBOOLEAN: {\n      printf(\"%s\", (!l_isfalse(v) ? \"true\" : \"false\"));\n      break;\n    }\n    case LUA_TNIL: {\n      printf(\"nil\");\n      break;\n    }\n    default: {\n      void *p = iscollectable(v) ? gcvalue(v) : NULL;\n      printf(\"%s: %p\", ttypename(ttype(v)), p);\n      break;\n    }\n  }\n}\n\n\nstatic int testobjref (global_State *g, GCObject *f, GCObject *t) {\n  int r1 = testobjref1(g, f, t);\n  if (!r1) {\n    printf(\"%d(%02X) - \", g->gcstate, g->currentwhite);\n    printobj(g, f);\n    printf(\"  ->  \");\n    printobj(g, t);\n    printf(\"\\n\");\n  }\n  return r1;\n}\n\n\nstatic void checkobjref (global_State *g, GCObject *f, GCObject *t) {\n    assert(testobjref(g, f, t));\n}\n\n\n/*\n** Version where 't' can be NULL. In that case, it should not apply the\n** macro 'obj2gco' over the object. ('t' may have several types, so this\n** definition must be a macro.)  Most checks need this version, because\n** the check may run while an object is still being created.\n*/\n#define checkobjrefN(g,f,t)\t{ if (t) checkobjref(g,f,obj2gco(t)); }\n\n\nstatic void checkvalref (global_State *g, GCObject *f, const TValue *t) {\n  assert(!iscollectable(t) || (righttt(t) && testobjref(g, f, gcvalue(t))));\n}\n\n\nstatic void checktable (global_State *g, Table *h) {\n  unsigned int i;\n  unsigned int asize = h->asize;\n  Node *n, *limit = gnode(h, sizenode(h));\n  GCObject *hgc = obj2gco(h);\n  checkobjrefN(g, hgc, h->metatable);\n  for (i = 0; i < asize; i++) {\n    TValue aux;\n    arr2obj(h, i, &aux);\n    checkvalref(g, hgc, &aux);\n  }\n  for (n = gnode(h, 0); n < limit; n++) {\n    if (!isempty(gval(n))) {\n      TValue k;\n      getnodekey(g->mainthread, &k, n);\n      assert(!keyisnil(n));\n      checkvalref(g, hgc, &k);\n      checkvalref(g, hgc, gval(n));\n    }\n  }\n}\n\n\nstatic void checkudata (global_State *g, Udata *u) {\n  int i;\n  GCObject *hgc = obj2gco(u);\n  checkobjrefN(g, hgc, u->metatable);\n  for (i = 0; i < u->nuvalue; i++)\n    checkvalref(g, hgc, &u->uv[i].uv);\n}\n\n\nstatic void checkproto (global_State *g, Proto *f) {\n  int i;\n  GCObject *fgc = obj2gco(f);\n  checkobjrefN(g, fgc, f->source);\n  for (i=0; i<f->sizek; i++) {\n    if (iscollectable(f->k + i))\n      checkobjref(g, fgc, gcvalue(f->k + i));\n  }\n  for (i=0; i<f->sizeupvalues; i++)\n    checkobjrefN(g, fgc, f->upvalues[i].name);\n  for (i=0; i<f->sizep; i++)\n    checkobjrefN(g, fgc, f->p[i]);\n  for (i=0; i<f->sizelocvars; i++)\n    checkobjrefN(g, fgc, f->locvars[i].varname);\n}\n\n\nstatic void checkCclosure (global_State *g, CClosure *cl) {\n  GCObject *clgc = obj2gco(cl);\n  int i;\n  for (i = 0; i < cl->nupvalues; i++)\n    checkvalref(g, clgc, &cl->upvalue[i]);\n}\n\n\nstatic void checkLclosure (global_State *g, LClosure *cl) {\n  GCObject *clgc = obj2gco(cl);\n  int i;\n  checkobjrefN(g, clgc, cl->p);\n  for (i=0; i<cl->nupvalues; i++) {\n    UpVal *uv = cl->upvals[i];\n    if (uv) {\n      checkobjrefN(g, clgc, uv);\n      if (!upisopen(uv))\n        checkvalref(g, obj2gco(uv), uv->v.p);\n    }\n  }\n}\n\n\nstatic int lua_checkpc (CallInfo *ci) {\n  if (!isLua(ci)) return 1;\n  else {\n    StkId f = ci->func.p;\n    Proto *p = clLvalue(s2v(f))->p;\n    return p->code <= ci->u.l.savedpc &&\n           ci->u.l.savedpc <= p->code + p->sizecode;\n  }\n}\n\n\nstatic void checkstack (global_State *g, lua_State *L1) {\n  StkId o;\n  CallInfo *ci;\n  UpVal *uv;\n  assert(!isdead(g, L1));\n  if (L1->stack.p == NULL) {  /* incomplete thread? */\n    assert(L1->openupval == NULL && L1->ci == NULL);\n    return;\n  }\n  for (uv = L1->openupval; uv != NULL; uv = uv->u.open.next)\n    assert(upisopen(uv));  /* must be open */\n  assert(L1->top.p <= L1->stack_last.p);\n  assert(L1->tbclist.p <= L1->top.p);\n  for (ci = L1->ci; ci != NULL; ci = ci->previous) {\n    assert(ci->top.p <= L1->stack_last.p);\n    assert(lua_checkpc(ci));\n  }\n  for (o = L1->stack.p; o < L1->stack_last.p; o++)\n    checkliveness(L1, s2v(o));  /* entire stack must have valid values */\n}\n\n\nstatic void checkrefs (global_State *g, GCObject *o) {\n  switch (o->tt) {\n    case LUA_VUSERDATA: {\n      checkudata(g, gco2u(o));\n      break;\n    }\n    case LUA_VUPVAL: {\n      checkvalref(g, o, gco2upv(o)->v.p);\n      break;\n    }\n    case LUA_VTABLE: {\n      checktable(g, gco2t(o));\n      break;\n    }\n    case LUA_VTHREAD: {\n      checkstack(g, gco2th(o));\n      break;\n    }\n    case LUA_VLCL: {\n      checkLclosure(g, gco2lcl(o));\n      break;\n    }\n    case LUA_VCCL: {\n      checkCclosure(g, gco2ccl(o));\n      break;\n    }\n    case LUA_VPROTO: {\n      checkproto(g, gco2p(o));\n      break;\n    }\n    case LUA_VSHRSTR:\n    case LUA_VLNGSTR: {\n      assert(!isgray(o));  /* strings are never gray */\n      break;\n    }\n    default: assert(0);\n  }\n}\n\n\n/*\n** Check consistency of an object:\n** - Dead objects can only happen in the 'allgc' list during a sweep\n** phase (controlled by the caller through 'maybedead').\n** - During pause, all objects must be white.\n** - In generational mode:\n**   * objects must be old enough for their lists ('listage').\n**   * old objects cannot be white.\n**   * old objects must be black, except for 'touched1', 'old0',\n**     threads, and open upvalues.\n**   * 'touched1' objects must be gray.\n*/\nstatic void checkobject (global_State *g, GCObject *o, int maybedead,\n                         int listage) {\n  if (isdead(g, o))\n    assert(maybedead);\n  else {\n    assert(g->gcstate != GCSpause || iswhite(o));\n    if (g->gckind == KGC_GENMINOR) {  /* generational mode? */\n      assert(getage(o) >= listage);\n      if (isold(o)) {\n        assert(!iswhite(o));\n        assert(isblack(o) ||\n        getage(o) == G_TOUCHED1 ||\n        getage(o) == G_OLD0 ||\n        o->tt == LUA_VTHREAD ||\n        (o->tt == LUA_VUPVAL && upisopen(gco2upv(o))));\n      }\n      assert(getage(o) != G_TOUCHED1 || isgray(o));\n    }\n    checkrefs(g, o);\n  }\n}\n\n\nstatic l_mem checkgraylist (global_State *g, GCObject *o) {\n  int total = 0;  /* count number of elements in the list */\n  cast_void(g);  /* better to keep it if we need to print an object */\n  while (o) {\n    assert(!!isgray(o) ^ (getage(o) == G_TOUCHED2));\n    assert(!testbit(o->marked, TESTBIT));\n    if (keepinvariant(g))\n      l_setbit(o->marked, TESTBIT);  /* mark that object is in a gray list */\n    total++;\n    switch (o->tt) {\n      case LUA_VTABLE: o = gco2t(o)->gclist; break;\n      case LUA_VLCL: o = gco2lcl(o)->gclist; break;\n      case LUA_VCCL: o = gco2ccl(o)->gclist; break;\n      case LUA_VTHREAD: o = gco2th(o)->gclist; break;\n      case LUA_VPROTO: o = gco2p(o)->gclist; break;\n      case LUA_VUSERDATA:\n        assert(gco2u(o)->nuvalue > 0);\n        o = gco2u(o)->gclist;\n        break;\n      default: assert(0);  /* other objects cannot be in a gray list */\n    }\n  }\n  return total;\n}\n\n\n/*\n** Check objects in gray lists.\n*/\nstatic l_mem checkgrays (global_State *g) {\n  l_mem total = 0;  /* count number of elements in all lists */\n  if (!keepinvariant(g)) return total;\n  total += checkgraylist(g, g->gray);\n  total += checkgraylist(g, g->grayagain);\n  total += checkgraylist(g, g->weak);\n  total += checkgraylist(g, g->allweak);\n  total += checkgraylist(g, g->ephemeron);\n  return total;\n}\n\n\n/*\n** Check whether 'o' should be in a gray list. If so, increment\n** 'count' and check its TESTBIT. (It must have been previously set by\n** 'checkgraylist'.)\n*/\nstatic void incifingray (global_State *g, GCObject *o, l_mem *count) {\n  if (!keepinvariant(g))\n    return;  /* gray lists not being kept in these phases */\n  if (o->tt == LUA_VUPVAL) {\n    /* only open upvalues can be gray */\n    assert(!isgray(o) || upisopen(gco2upv(o)));\n    return;  /* upvalues are never in gray lists */\n  }\n  /* these are the ones that must be in gray lists */\n  if (isgray(o) || getage(o) == G_TOUCHED2) {\n    (*count)++;\n    assert(testbit(o->marked, TESTBIT));\n    resetbit(o->marked, TESTBIT);  /* prepare for next cycle */\n  }\n}\n\n\nstatic l_mem checklist (global_State *g, int maybedead, int tof,\n  GCObject *newl, GCObject *survival, GCObject *old, GCObject *reallyold) {\n  GCObject *o;\n  l_mem total = 0;  /* number of object that should be in  gray lists */\n  for (o = newl; o != survival; o = o->next) {\n    checkobject(g, o, maybedead, G_NEW);\n    incifingray(g, o, &total);\n    assert(!tof == !tofinalize(o));\n  }\n  for (o = survival; o != old; o = o->next) {\n    checkobject(g, o, 0, G_SURVIVAL);\n    incifingray(g, o, &total);\n    assert(!tof == !tofinalize(o));\n  }\n  for (o = old; o != reallyold; o = o->next) {\n    checkobject(g, o, 0, G_OLD1);\n    incifingray(g, o, &total);\n    assert(!tof == !tofinalize(o));\n  }\n  for (o = reallyold; o != NULL; o = o->next) {\n    checkobject(g, o, 0, G_OLD);\n    incifingray(g, o, &total);\n    assert(!tof == !tofinalize(o));\n  }\n  return total;\n}\n\n\nint lua_checkmemory (lua_State *L) {\n  global_State *g = G(L);\n  GCObject *o;\n  int maybedead;\n  l_mem totalin;  /* total of objects that are in gray lists */\n  l_mem totalshould;  /* total of objects that should be in gray lists */\n  if (keepinvariant(g)) {\n    assert(!iswhite(g->mainthread));\n    assert(!iswhite(gcvalue(&g->l_registry)));\n  }\n  assert(!isdead(g, gcvalue(&g->l_registry)));\n  assert(g->sweepgc == NULL || issweepphase(g));\n  totalin = checkgrays(g);\n\n  /* check 'fixedgc' list */\n  for (o = g->fixedgc; o != NULL; o = o->next) {\n    assert(o->tt == LUA_VSHRSTR && isgray(o) && getage(o) == G_OLD);\n  }\n\n  /* check 'allgc' list */\n  maybedead = (GCSatomic < g->gcstate && g->gcstate <= GCSswpallgc);\n  totalshould = checklist(g, maybedead, 0, g->allgc,\n                             g->survival, g->old1, g->reallyold);\n\n  /* check 'finobj' list */\n  totalshould += checklist(g, 0, 1, g->finobj,\n                              g->finobjsur, g->finobjold1, g->finobjrold);\n\n  /* check 'tobefnz' list */\n  for (o = g->tobefnz; o != NULL; o = o->next) {\n    checkobject(g, o, 0, G_NEW);\n    incifingray(g, o, &totalshould);\n    assert(tofinalize(o));\n    assert(o->tt == LUA_VUSERDATA || o->tt == LUA_VTABLE);\n  }\n  if (keepinvariant(g))\n    assert(totalin == totalshould);\n  return 0;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** Disassembler\n** =======================================================\n*/\n\n\nstatic char *buildop (Proto *p, int pc, char *buff) {\n  char *obuff = buff;\n  Instruction i = p->code[pc];\n  OpCode o = GET_OPCODE(i);\n  const char *name = opnames[o];\n  int line = luaG_getfuncline(p, pc);\n  int lineinfo = (p->lineinfo != NULL) ? p->lineinfo[pc] : 0;\n  if (lineinfo == ABSLINEINFO)\n    buff += sprintf(buff, \"(__\");\n  else\n    buff += sprintf(buff, \"(%2d\", lineinfo);\n  buff += sprintf(buff, \" - %4d) %4d - \", line, pc);\n  switch (getOpMode(o)) {\n    case iABC:\n      sprintf(buff, \"%-12s%4d %4d %4d%s\", name,\n              GETARG_A(i), GETARG_B(i), GETARG_C(i),\n              GETARG_k(i) ? \" (k)\" : \"\");\n      break;\n    case ivABC:\n      sprintf(buff, \"%-12s%4d %4d %4d%s\", name,\n              GETARG_A(i), GETARG_vB(i), GETARG_vC(i),\n              GETARG_k(i) ? \" (k)\" : \"\");\n      break;\n    case iABx:\n      sprintf(buff, \"%-12s%4d %4d\", name, GETARG_A(i), GETARG_Bx(i));\n      break;\n    case iAsBx:\n      sprintf(buff, \"%-12s%4d %4d\", name, GETARG_A(i), GETARG_sBx(i));\n      break;\n    case iAx:\n      sprintf(buff, \"%-12s%4d\", name, GETARG_Ax(i));\n      break;\n    case isJ:\n      sprintf(buff, \"%-12s%4d\", name, GETARG_sJ(i));\n      break;\n  }\n  return obuff;\n}\n\n\n#if 0\nvoid luaI_printcode (Proto *pt, int size) {\n  int pc;\n  for (pc=0; pc<size; pc++) {\n    char buff[100];\n    printf(\"%s\\n\", buildop(pt, pc, buff));\n  }\n  printf(\"-------\\n\");\n}\n\n\nvoid luaI_printinst (Proto *pt, int pc) {\n  char buff[100];\n  printf(\"%s\\n\", buildop(pt, pc, buff));\n}\n#endif\n\n\nstatic int listcode (lua_State *L) {\n  int pc;\n  Proto *p;\n  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),\n                 1, \"Lua function expected\");\n  p = getproto(obj_at(L, 1));\n  lua_newtable(L);\n  setnameval(L, \"maxstack\", p->maxstacksize);\n  setnameval(L, \"numparams\", p->numparams);\n  for (pc=0; pc<p->sizecode; pc++) {\n    char buff[100];\n    lua_pushinteger(L, pc+1);\n    lua_pushstring(L, buildop(p, pc, buff));\n    lua_settable(L, -3);\n  }\n  return 1;\n}\n\n\nstatic int printcode (lua_State *L) {\n  int pc;\n  Proto *p;\n  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),\n                 1, \"Lua function expected\");\n  p = getproto(obj_at(L, 1));\n  printf(\"maxstack: %d\\n\", p->maxstacksize);\n  printf(\"numparams: %d\\n\", p->numparams);\n  for (pc=0; pc<p->sizecode; pc++) {\n    char buff[100];\n    printf(\"%s\\n\", buildop(p, pc, buff));\n  }\n  return 0;\n}\n\n\nstatic int listk (lua_State *L) {\n  Proto *p;\n  int i;\n  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),\n                 1, \"Lua function expected\");\n  p = getproto(obj_at(L, 1));\n  lua_createtable(L, cast_uint(p->sizek), 0);\n  for (i=0; i<p->sizek; i++) {\n    pushobject(L, p->k+i);\n    lua_rawseti(L, -2, i+1);\n  }\n  return 1;\n}\n\n\nstatic int listabslineinfo (lua_State *L) {\n  Proto *p;\n  int i;\n  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),\n                 1, \"Lua function expected\");\n  p = getproto(obj_at(L, 1));\n  luaL_argcheck(L, p->abslineinfo != NULL, 1, \"function has no debug info\");\n  lua_createtable(L, 2u * cast_uint(p->sizeabslineinfo), 0);\n  for (i=0; i < p->sizeabslineinfo; i++) {\n    lua_pushinteger(L, p->abslineinfo[i].pc);\n    lua_rawseti(L, -2, 2 * i + 1);\n    lua_pushinteger(L, p->abslineinfo[i].line);\n    lua_rawseti(L, -2, 2 * i + 2);\n  }\n  return 1;\n}\n\n\nstatic int listlocals (lua_State *L) {\n  Proto *p;\n  int pc = cast_int(luaL_checkinteger(L, 2)) - 1;\n  int i = 0;\n  const char *name;\n  luaL_argcheck(L, lua_isfunction(L, 1) && !lua_iscfunction(L, 1),\n                 1, \"Lua function expected\");\n  p = getproto(obj_at(L, 1));\n  while ((name = luaF_getlocalname(p, ++i, pc)) != NULL)\n    lua_pushstring(L, name);\n  return i-1;\n}\n\n/* }====================================================== */\n\n\n\nvoid lua_printstack (lua_State *L) {\n  int i;\n  int n = lua_gettop(L);\n  printf(\"stack: >>\\n\");\n  for (i = 1; i <= n; i++) {\n    printf(\"%3d: \", i);\n    lua_printvalue(s2v(L->ci->func.p + i));\n    printf(\"\\n\");\n  }\n  printf(\"<<\\n\");\n}\n\n\nstatic int get_limits (lua_State *L) {\n  lua_createtable(L, 0, 6);\n  setnameval(L, \"IS32INT\", LUAI_IS32INT);\n  setnameval(L, \"MAXARG_Ax\", MAXARG_Ax);\n  setnameval(L, \"MAXARG_Bx\", MAXARG_Bx);\n  setnameval(L, \"OFFSET_sBx\", OFFSET_sBx);\n  setnameval(L, \"NUM_OPCODES\", NUM_OPCODES);\n  return 1;\n}\n\n\nstatic int mem_query (lua_State *L) {\n  if (lua_isnone(L, 1)) {\n    lua_pushinteger(L, cast(lua_Integer, l_memcontrol.total));\n    lua_pushinteger(L, cast(lua_Integer, l_memcontrol.numblocks));\n    lua_pushinteger(L, cast(lua_Integer, l_memcontrol.maxmem));\n    return 3;\n  }\n  else if (lua_isnumber(L, 1)) {\n    unsigned long limit = cast(unsigned long, luaL_checkinteger(L, 1));\n    if (limit == 0) limit = ULONG_MAX;\n    l_memcontrol.memlimit = limit;\n    return 0;\n  }\n  else {\n    const char *t = luaL_checkstring(L, 1);\n    int i;\n    for (i = LUA_NUMTYPES - 1; i >= 0; i--) {\n      if (strcmp(t, ttypename(i)) == 0) {\n        lua_pushinteger(L, cast(lua_Integer, l_memcontrol.objcount[i]));\n        return 1;\n      }\n    }\n    return luaL_error(L, \"unknown type '%s'\", t);\n  }\n}\n\n\nstatic int alloc_count (lua_State *L) {\n  if (lua_isnone(L, 1))\n    l_memcontrol.countlimit = cast(unsigned long, ~0L);\n  else\n    l_memcontrol.countlimit = cast(unsigned long, luaL_checkinteger(L, 1));\n  return 0;\n}\n\n\nstatic int alloc_failnext (lua_State *L) {\n  UNUSED(L);\n  l_memcontrol.failnext = 1;\n  return 0;\n}\n\n\nstatic int settrick (lua_State *L) {\n  if (ttisnil(obj_at(L, 1)))\n    l_Trick = NULL;\n  else\n    l_Trick = gcvalue(obj_at(L, 1));\n  return 0;\n}\n\n\nstatic int gc_color (lua_State *L) {\n  TValue *o;\n  luaL_checkany(L, 1);\n  o = obj_at(L, 1);\n  if (!iscollectable(o))\n    lua_pushstring(L, \"no collectable\");\n  else {\n    GCObject *obj = gcvalue(o);\n    lua_pushstring(L, isdead(G(L), obj) ? \"dead\" :\n                      iswhite(obj) ? \"white\" :\n                      isblack(obj) ? \"black\" : \"gray\");\n  }\n  return 1;\n}\n\n\nstatic int gc_age (lua_State *L) {\n  TValue *o;\n  luaL_checkany(L, 1);\n  o = obj_at(L, 1);\n  if (!iscollectable(o))\n    lua_pushstring(L, \"no collectable\");\n  else {\n    static const char *gennames[] = {\"new\", \"survival\", \"old0\", \"old1\",\n                                     \"old\", \"touched1\", \"touched2\"};\n    GCObject *obj = gcvalue(o);\n    lua_pushstring(L, gennames[getage(obj)]);\n  }\n  return 1;\n}\n\n\nstatic int gc_printobj (lua_State *L) {\n  TValue *o;\n  luaL_checkany(L, 1);\n  o = obj_at(L, 1);\n  if (!iscollectable(o))\n    printf(\"no collectable\\n\");\n  else {\n    GCObject *obj = gcvalue(o);\n    printobj(G(L), obj);\n    printf(\"\\n\");\n  }\n  return 0;\n}\n\n\nstatic const char *statenames[] = {\n  \"propagate\", \"enteratomic\", \"atomic\", \"sweepallgc\", \"sweepfinobj\",\n  \"sweeptobefnz\", \"sweepend\", \"callfin\", \"pause\", \"\"};\n\nstatic int gc_state (lua_State *L) {\n  static const int states[] = {\n    GCSpropagate, GCSenteratomic, GCSatomic, GCSswpallgc, GCSswpfinobj,\n    GCSswptobefnz, GCSswpend, GCScallfin, GCSpause, -1};\n  int option = states[luaL_checkoption(L, 1, \"\", statenames)];\n  global_State *g = G(L);\n  if (option == -1) {\n    lua_pushstring(L, statenames[g->gcstate]);\n    return 1;\n  }\n  else {\n    if (g->gckind != KGC_INC)\n      luaL_error(L, \"cannot change states in generational mode\");\n    lua_lock(L);\n    if (option < g->gcstate) {  /* must cross 'pause'? */\n      luaC_runtilstate(L, GCSpause, 1);  /* run until pause */\n    }\n    luaC_runtilstate(L, option, 0);  /* do not skip propagation state */\n    lua_assert(g->gcstate == option);\n    lua_unlock(L);\n    return 0;\n  }\n}\n\n\nstatic int tracinggc = 0;\nvoid luai_tracegctest (lua_State *L, int first) {\n  if (!tracinggc) return;\n  else {\n    global_State *g = G(L);\n    lua_unlock(L);\n    g->gcstp = GCSTPGC;\n    lua_checkstack(L, 10);\n    lua_getfield(L, LUA_REGISTRYINDEX, \"tracegc\");\n    lua_pushboolean(L, first);\n    lua_call(L, 1, 0);\n    g->gcstp = 0;\n    lua_lock(L);\n  }\n}\n\n\nstatic int tracegc (lua_State *L) {\n  if (lua_isnil(L, 1))\n    tracinggc = 0;\n  else {\n    tracinggc = 1;\n    lua_setfield(L, LUA_REGISTRYINDEX, \"tracegc\");\n  }\n  return 0;\n}\n\n\nstatic int hash_query (lua_State *L) {\n  if (lua_isnone(L, 2)) {\n    luaL_argcheck(L, lua_type(L, 1) == LUA_TSTRING, 1, \"string expected\");\n    lua_pushinteger(L, cast_int(tsvalue(obj_at(L, 1))->hash));\n  }\n  else {\n    TValue *o = obj_at(L, 1);\n    Table *t;\n    luaL_checktype(L, 2, LUA_TTABLE);\n    t = hvalue(obj_at(L, 2));\n    lua_pushinteger(L, cast(lua_Integer, luaH_mainposition(t, o) - t->node));\n  }\n  return 1;\n}\n\n\nstatic int stacklevel (lua_State *L) {\n  int a = 0;\n  lua_pushinteger(L, cast(lua_Integer, L->top.p - L->stack.p));\n  lua_pushinteger(L, stacksize(L));\n  lua_pushinteger(L, cast(lua_Integer, L->nCcalls));\n  lua_pushinteger(L, L->nci);\n  lua_pushinteger(L, (lua_Integer)(size_t)&a);\n  return 5;\n}\n\n\nstatic int table_query (lua_State *L) {\n  const Table *t;\n  int i = cast_int(luaL_optinteger(L, 2, -1));\n  unsigned int asize;\n  luaL_checktype(L, 1, LUA_TTABLE);\n  t = hvalue(obj_at(L, 1));\n  asize = t->asize;\n  if (i == -1) {\n    lua_pushinteger(L, cast(lua_Integer, asize));\n    lua_pushinteger(L, cast(lua_Integer, allocsizenode(t)));\n    lua_pushinteger(L, cast(lua_Integer, asize > 0 ? *lenhint(t) : 0));\n    return 3;\n  }\n  else if (cast_uint(i) < asize) {\n    lua_pushinteger(L, i);\n    if (!tagisempty(*getArrTag(t, i)))\n      arr2obj(t, cast_uint(i), s2v(L->top.p));\n    else\n      setnilvalue(s2v(L->top.p));\n    api_incr_top(L);\n    lua_pushnil(L);\n  }\n  else if (cast_uint(i -= cast_int(asize)) < sizenode(t)) {\n    TValue k;\n    getnodekey(L, &k, gnode(t, i));\n    if (!isempty(gval(gnode(t, i))) ||\n        ttisnil(&k) ||\n        ttisnumber(&k)) {\n      pushobject(L, &k);\n    }\n    else\n      lua_pushliteral(L, \"<undef>\");\n    if (!isempty(gval(gnode(t, i))))\n      pushobject(L, gval(gnode(t, i)));\n    else\n      lua_pushnil(L);\n    lua_pushinteger(L, gnext(&t->node[i]));\n  }\n  return 3;\n}\n\n\nstatic int gc_query (lua_State *L) {\n  global_State *g = G(L);\n  lua_pushstring(L, g->gckind == KGC_INC ? \"inc\"\n                  : g->gckind == KGC_GENMAJOR ? \"genmajor\"\n                  : \"genminor\");\n  lua_pushstring(L, statenames[g->gcstate]);\n  lua_pushinteger(L, cast_st2S(gettotalbytes(g)));\n  lua_pushinteger(L, cast_st2S(g->GCdebt));\n  lua_pushinteger(L, cast_st2S(g->GCmarked));\n  lua_pushinteger(L, cast_st2S(g->GCmajorminor));\n  return 6;\n}\n\n\nstatic int test_codeparam (lua_State *L) {\n  lua_Integer p = luaL_checkinteger(L, 1);\n  lua_pushinteger(L, luaO_codeparam(cast_uint(p)));\n  return 1;\n}\n\n\nstatic int test_applyparam (lua_State *L) {\n  lua_Integer p = luaL_checkinteger(L, 1);\n  lua_Integer x = luaL_checkinteger(L, 2);\n  lua_pushinteger(L, cast(lua_Integer, luaO_applyparam(cast_byte(p), x)));\n  return 1;\n}\n\n\nstatic int string_query (lua_State *L) {\n  stringtable *tb = &G(L)->strt;\n  int s = cast_int(luaL_optinteger(L, 1, 0)) - 1;\n  if (s == -1) {\n    lua_pushinteger(L ,tb->size);\n    lua_pushinteger(L ,tb->nuse);\n    return 2;\n  }\n  else if (s < tb->size) {\n    TString *ts;\n    int n = 0;\n    for (ts = tb->hash[s]; ts != NULL; ts = ts->u.hnext) {\n      setsvalue2s(L, L->top.p, ts);\n      api_incr_top(L);\n      n++;\n    }\n    return n;\n  }\n  else return 0;\n}\n\n\nstatic int getreftable (lua_State *L) {\n  if (lua_istable(L, 2))  /* is there a table as second argument? */\n    return 2;  /* use it as the table */\n  else\n    return LUA_REGISTRYINDEX;  /* default is to use the register */\n}\n\n\nstatic int tref (lua_State *L) {\n  int t = getreftable(L);\n  int level = lua_gettop(L);\n  luaL_checkany(L, 1);\n  lua_pushvalue(L, 1);\n  lua_pushinteger(L, luaL_ref(L, t));\n  cast_void(level);  /* to avoid warnings */\n  lua_assert(lua_gettop(L) == level+1);  /* +1 for result */\n  return 1;\n}\n\n\nstatic int getref (lua_State *L) {\n  int t = getreftable(L);\n  int level = lua_gettop(L);\n  lua_rawgeti(L, t, luaL_checkinteger(L, 1));\n  cast_void(level);  /* to avoid warnings */\n  lua_assert(lua_gettop(L) == level+1);\n  return 1;\n}\n\nstatic int unref (lua_State *L) {\n  int t = getreftable(L);\n  int level = lua_gettop(L);\n  luaL_unref(L, t, cast_int(luaL_checkinteger(L, 1)));\n  cast_void(level);  /* to avoid warnings */\n  lua_assert(lua_gettop(L) == level);\n  return 0;\n}\n\n\nstatic int upvalue (lua_State *L) {\n  int n = cast_int(luaL_checkinteger(L, 2));\n  luaL_checktype(L, 1, LUA_TFUNCTION);\n  if (lua_isnone(L, 3)) {\n    const char *name = lua_getupvalue(L, 1, n);\n    if (name == NULL) return 0;\n    lua_pushstring(L, name);\n    return 2;\n  }\n  else {\n    const char *name = lua_setupvalue(L, 1, n);\n    lua_pushstring(L, name);\n    return 1;\n  }\n}\n\n\nstatic int newuserdata (lua_State *L) {\n  size_t size = cast_sizet(luaL_optinteger(L, 1, 0));\n  int nuv = cast_int(luaL_optinteger(L, 2, 0));\n  char *p = cast_charp(lua_newuserdatauv(L, size, nuv));\n  while (size--) *p++ = '\\0';\n  return 1;\n}\n\n\nstatic int pushuserdata (lua_State *L) {\n  lua_Integer u = luaL_checkinteger(L, 1);\n  lua_pushlightuserdata(L, cast_voidp(cast_sizet(u)));\n  return 1;\n}\n\n\nstatic int udataval (lua_State *L) {\n  lua_pushinteger(L, cast(lua_Integer, cast(size_t, lua_touserdata(L, 1))));\n  return 1;\n}\n\n\nstatic int doonnewstack (lua_State *L) {\n  lua_State *L1 = lua_newthread(L);\n  size_t l;\n  const char *s = luaL_checklstring(L, 1, &l);\n  int status = luaL_loadbuffer(L1, s, l, s);\n  if (status == LUA_OK)\n    status = lua_pcall(L1, 0, 0, 0);\n  lua_pushinteger(L, status);\n  return 1;\n}\n\n\nstatic int s2d (lua_State *L) {\n  lua_pushnumber(L, cast_num(*cast(const double *, luaL_checkstring(L, 1))));\n  return 1;\n}\n\n\nstatic int d2s (lua_State *L) {\n  double d = cast(double, luaL_checknumber(L, 1));\n  lua_pushlstring(L, cast_charp(&d), sizeof(d));\n  return 1;\n}\n\n\nstatic int num2int (lua_State *L) {\n  lua_pushinteger(L, lua_tointeger(L, 1));\n  return 1;\n}\n\n\nstatic int makeseed (lua_State *L) {\n  lua_pushinteger(L, cast(lua_Integer, luaL_makeseed(L)));\n  return 1;\n}\n\n\nstatic int newstate (lua_State *L) {\n  void *ud;\n  lua_Alloc f = lua_getallocf(L, &ud);\n  lua_State *L1 = lua_newstate(f, ud, 0);\n  if (L1) {\n    lua_atpanic(L1, tpanic);\n    lua_pushlightuserdata(L, L1);\n  }\n  else\n    lua_pushnil(L);\n  return 1;\n}\n\n\nstatic lua_State *getstate (lua_State *L) {\n  lua_State *L1 = cast(lua_State *, lua_touserdata(L, 1));\n  luaL_argcheck(L, L1 != NULL, 1, \"state expected\");\n  return L1;\n}\n\n\nstatic int loadlib (lua_State *L) {\n  lua_State *L1 = getstate(L);\n  int load = cast_int(luaL_checkinteger(L, 2));\n  int preload = cast_int(luaL_checkinteger(L, 3));\n  luaL_openselectedlibs(L1, load, preload);\n  luaL_requiref(L1, \"T\", luaB_opentests, 0);\n  lua_assert(lua_type(L1, -1) == LUA_TTABLE);\n  /* 'requiref' should not reload module already loaded... */\n  luaL_requiref(L1, \"T\", NULL, 1);  /* seg. fault if it reloads */\n  /* ...but should return the same module */\n  lua_assert(lua_compare(L1, -1, -2, LUA_OPEQ));\n  return 0;\n}\n\nstatic int closestate (lua_State *L) {\n  lua_State *L1 = getstate(L);\n  lua_close(L1);\n  return 0;\n}\n\nstatic int doremote (lua_State *L) {\n  lua_State *L1 = getstate(L);\n  size_t lcode;\n  const char *code = luaL_checklstring(L, 2, &lcode);\n  int status;\n  lua_settop(L1, 0);\n  status = luaL_loadbuffer(L1, code, lcode, code);\n  if (status == LUA_OK)\n    status = lua_pcall(L1, 0, LUA_MULTRET, 0);\n  if (status != LUA_OK) {\n    lua_pushnil(L);\n    lua_pushstring(L, lua_tostring(L1, -1));\n    lua_pushinteger(L, status);\n    return 3;\n  }\n  else {\n    int i = 0;\n    while (!lua_isnone(L1, ++i))\n      lua_pushstring(L, lua_tostring(L1, i));\n    lua_pop(L1, i-1);\n    return i-1;\n  }\n}\n\n\nstatic int log2_aux (lua_State *L) {\n  unsigned int x = (unsigned int)luaL_checkinteger(L, 1);\n  lua_pushinteger(L, luaO_ceillog2(x));\n  return 1;\n}\n\n\nstruct Aux { jmp_buf jb; const char *paniccode; lua_State *L; };\n\n/*\n** does a long-jump back to \"main program\".\n*/\nstatic int panicback (lua_State *L) {\n  struct Aux *b;\n  lua_checkstack(L, 1);  /* open space for 'Aux' struct */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_jmpbuf\");  /* get 'Aux' struct */\n  b = (struct Aux *)lua_touserdata(L, -1);\n  lua_pop(L, 1);  /* remove 'Aux' struct */\n  runC(b->L, L, b->paniccode);  /* run optional panic code */\n  longjmp(b->jb, 1);\n  return 1;  /* to avoid warnings */\n}\n\nstatic int checkpanic (lua_State *L) {\n  struct Aux b;\n  void *ud;\n  lua_State *L1;\n  const char *code = luaL_checkstring(L, 1);\n  lua_Alloc f = lua_getallocf(L, &ud);\n  b.paniccode = luaL_optstring(L, 2, \"\");\n  b.L = L;\n  L1 = lua_newstate(f, ud, 0);  /* create new state */\n  if (L1 == NULL) {  /* error? */\n    lua_pushnil(L);\n    return 1;\n  }\n  lua_atpanic(L1, panicback);  /* set its panic function */\n  lua_pushlightuserdata(L1, &b);\n  lua_setfield(L1, LUA_REGISTRYINDEX, \"_jmpbuf\");  /* store 'Aux' struct */\n  if (setjmp(b.jb) == 0) {  /* set jump buffer */\n    runC(L, L1, code);  /* run code unprotected */\n    lua_pushliteral(L, \"no errors\");\n  }\n  else {  /* error handling */\n    /* move error message to original state */\n    lua_pushstring(L, lua_tostring(L1, -1));\n  }\n  lua_close(L1);\n  return 1;\n}\n\n\nstatic int externKstr (lua_State *L) {\n  size_t len;\n  const char *s = luaL_checklstring(L, 1, &len);\n  lua_pushextlstring(L, s, len, NULL, NULL);\n  return 1;\n}\n\n\n/*\n** Create a buffer with the content of a given string and then\n** create an external string using that buffer. Use the allocation\n** function from Lua to create and free the buffer.\n*/\nstatic int externstr (lua_State *L) {\n  size_t len;\n  const char *s = luaL_checklstring(L, 1, &len);\n  void *ud;\n  lua_Alloc allocf = lua_getallocf(L, &ud);  /* get allocation function */\n  /* create the buffer */\n  char *buff = cast_charp((*allocf)(ud, NULL, 0, len + 1));\n  if (buff == NULL) {  /* memory error? */\n    lua_pushliteral(L, \"not enough memory\");\n    lua_error(L);  /* raise a memory error */\n  }\n  /* copy string content to buffer, including ending 0 */\n  memcpy(buff, s, (len + 1) * sizeof(char));\n  /* create external string */\n  lua_pushextlstring(L, buff, len, allocf, ud);\n  return 1;\n}\n\n\n/*\n** {====================================================================\n** function to test the API with C. It interprets a kind of assembler\n** language with calls to the API, so the test can be driven by Lua code\n** =====================================================================\n*/\n\n\nstatic void sethookaux (lua_State *L, int mask, int count, const char *code);\n\nstatic const char *const delimits = \" \\t\\n,;\";\n\nstatic void skip (const char **pc) {\n  for (;;) {\n    if (**pc != '\\0' && strchr(delimits, **pc)) (*pc)++;\n    else if (**pc == '#') {  /* comment? */\n      while (**pc != '\\n' && **pc != '\\0') (*pc)++;  /* until end-of-line */\n    }\n    else break;\n  }\n}\n\nstatic int getnum_aux (lua_State *L, lua_State *L1, const char **pc) {\n  int res = 0;\n  int sig = 1;\n  skip(pc);\n  if (**pc == '.') {\n    res = cast_int(lua_tointeger(L1, -1));\n    lua_pop(L1, 1);\n    (*pc)++;\n    return res;\n  }\n  else if (**pc == '*') {\n    res = lua_gettop(L1);\n    (*pc)++;\n    return res;\n  }\n  else if (**pc == '!') {\n    (*pc)++;\n    if (**pc == 'G')\n      res = LUA_RIDX_GLOBALS;\n    else if (**pc == 'M')\n      res = LUA_RIDX_MAINTHREAD;\n    else lua_assert(0);\n    (*pc)++;\n    return res;\n  }\n  else if (**pc == '-') {\n    sig = -1;\n    (*pc)++;\n  }\n  if (!lisdigit(cast_uchar(**pc)))\n    luaL_error(L, \"number expected (%s)\", *pc);\n  while (lisdigit(cast_uchar(**pc))) res = res*10 + (*(*pc)++) - '0';\n  return sig*res;\n}\n\nstatic const char *getstring_aux (lua_State *L, char *buff, const char **pc) {\n  int i = 0;\n  skip(pc);\n  if (**pc == '\"' || **pc == '\\'') {  /* quoted string? */\n    int quote = *(*pc)++;\n    while (**pc != quote) {\n      if (**pc == '\\0') luaL_error(L, \"unfinished string in C script\");\n      buff[i++] = *(*pc)++;\n    }\n    (*pc)++;\n  }\n  else {\n    while (**pc != '\\0' && !strchr(delimits, **pc))\n      buff[i++] = *(*pc)++;\n  }\n  buff[i] = '\\0';\n  return buff;\n}\n\n\nstatic int getindex_aux (lua_State *L, lua_State *L1, const char **pc) {\n  skip(pc);\n  switch (*(*pc)++) {\n    case 'R': return LUA_REGISTRYINDEX;\n    case 'G': return luaL_error(L, \"deprecated index 'G'\");\n    case 'U': return lua_upvalueindex(getnum_aux(L, L1, pc));\n    default: (*pc)--; return getnum_aux(L, L1, pc);\n  }\n}\n\n\nstatic const char *const statcodes[] = {\"OK\", \"YIELD\", \"ERRRUN\",\n    \"ERRSYNTAX\", MEMERRMSG, \"ERRGCMM\", \"ERRERR\"};\n\n/*\n** Avoid these stat codes from being collected, to avoid possible\n** memory error when pushing them.\n*/\nstatic void regcodes (lua_State *L) {\n  unsigned int i;\n  for (i = 0; i < sizeof(statcodes) / sizeof(statcodes[0]); i++) {\n    lua_pushboolean(L, 1);\n    lua_setfield(L, LUA_REGISTRYINDEX, statcodes[i]);\n  }\n}\n\n\n#define EQ(s1)\t(strcmp(s1, inst) == 0)\n\n#define getnum\t\t(getnum_aux(L, L1, &pc))\n#define getstring\t(getstring_aux(L, buff, &pc))\n#define getindex\t(getindex_aux(L, L1, &pc))\n\n\nstatic int testC (lua_State *L);\nstatic int Cfunck (lua_State *L, int status, lua_KContext ctx);\n\n/*\n** arithmetic operation encoding for 'arith' instruction\n** LUA_OPIDIV  -> \\\n** LUA_OPSHL   -> <\n** LUA_OPSHR   -> >\n** LUA_OPUNM   -> _\n** LUA_OPBNOT  -> !\n*/\nstatic const char ops[] = \"+-*%^/\\\\&|~<>_!\";\n\nstatic int runC (lua_State *L, lua_State *L1, const char *pc) {\n  char buff[300];\n  int status = 0;\n  if (pc == NULL) return luaL_error(L, \"attempt to runC null script\");\n  for (;;) {\n    const char *inst = getstring;\n    if EQ(\"\") return 0;\n    else if EQ(\"absindex\") {\n      lua_pushinteger(L1, lua_absindex(L1, getindex));\n    }\n    else if EQ(\"append\") {\n      int t = getindex;\n      int i = cast_int(lua_rawlen(L1, t));\n      lua_rawseti(L1, t, i + 1);\n    }\n    else if EQ(\"arith\") {\n      int op;\n      skip(&pc);\n      op = cast_int(strchr(ops, *pc++) - ops);\n      lua_arith(L1, op);\n    }\n    else if EQ(\"call\") {\n      int narg = getnum;\n      int nres = getnum;\n      lua_call(L1, narg, nres);\n    }\n    else if EQ(\"callk\") {\n      int narg = getnum;\n      int nres = getnum;\n      int i = getindex;\n      lua_callk(L1, narg, nres, i, Cfunck);\n    }\n    else if EQ(\"checkstack\") {\n      int sz = getnum;\n      const char *msg = getstring;\n      if (*msg == '\\0')\n        msg = NULL;  /* to test 'luaL_checkstack' with no message */\n      luaL_checkstack(L1, sz, msg);\n    }\n    else if EQ(\"rawcheckstack\") {\n      int sz = getnum;\n      lua_pushboolean(L1, lua_checkstack(L1, sz));\n    }\n    else if EQ(\"compare\") {\n      const char *opt = getstring;  /* EQ, LT, or LE */\n      int op = (opt[0] == 'E') ? LUA_OPEQ\n                               : (opt[1] == 'T') ? LUA_OPLT : LUA_OPLE;\n      int a = getindex;\n      int b = getindex;\n      lua_pushboolean(L1, lua_compare(L1, a, b, op));\n    }\n    else if EQ(\"concat\") {\n      lua_concat(L1, getnum);\n    }\n    else if EQ(\"copy\") {\n      int f = getindex;\n      lua_copy(L1, f, getindex);\n    }\n    else if EQ(\"func2num\") {\n      lua_CFunction func = lua_tocfunction(L1, getindex);\n      lua_pushinteger(L1, cast(lua_Integer, cast(size_t, func)));\n    }\n    else if EQ(\"getfield\") {\n      int t = getindex;\n      int tp = lua_getfield(L1, t, getstring);\n      lua_assert(tp == lua_type(L1, -1));\n    }\n    else if EQ(\"getglobal\") {\n      lua_getglobal(L1, getstring);\n    }\n    else if EQ(\"getmetatable\") {\n      if (lua_getmetatable(L1, getindex) == 0)\n        lua_pushnil(L1);\n    }\n    else if EQ(\"gettable\") {\n      int tp = lua_gettable(L1, getindex);\n      lua_assert(tp == lua_type(L1, -1));\n    }\n    else if EQ(\"gettop\") {\n      lua_pushinteger(L1, lua_gettop(L1));\n    }\n    else if EQ(\"gsub\") {\n      int a = getnum; int b = getnum; int c = getnum;\n      luaL_gsub(L1, lua_tostring(L1, a),\n                    lua_tostring(L1, b),\n                    lua_tostring(L1, c));\n    }\n    else if EQ(\"insert\") {\n      lua_insert(L1, getnum);\n    }\n    else if EQ(\"iscfunction\") {\n      lua_pushboolean(L1, lua_iscfunction(L1, getindex));\n    }\n    else if EQ(\"isfunction\") {\n      lua_pushboolean(L1, lua_isfunction(L1, getindex));\n    }\n    else if EQ(\"isnil\") {\n      lua_pushboolean(L1, lua_isnil(L1, getindex));\n    }\n    else if EQ(\"isnull\") {\n      lua_pushboolean(L1, lua_isnone(L1, getindex));\n    }\n    else if EQ(\"isnumber\") {\n      lua_pushboolean(L1, lua_isnumber(L1, getindex));\n    }\n    else if EQ(\"isstring\") {\n      lua_pushboolean(L1, lua_isstring(L1, getindex));\n    }\n    else if EQ(\"istable\") {\n      lua_pushboolean(L1, lua_istable(L1, getindex));\n    }\n    else if EQ(\"isudataval\") {\n      lua_pushboolean(L1, lua_islightuserdata(L1, getindex));\n    }\n    else if EQ(\"isuserdata\") {\n      lua_pushboolean(L1, lua_isuserdata(L1, getindex));\n    }\n    else if EQ(\"len\") {\n      lua_len(L1, getindex);\n    }\n    else if EQ(\"Llen\") {\n      lua_pushinteger(L1, luaL_len(L1, getindex));\n    }\n    else if EQ(\"loadfile\") {\n      luaL_loadfile(L1, luaL_checkstring(L1, getnum));\n    }\n    else if EQ(\"loadstring\") {\n      size_t slen;\n      const char *s = luaL_checklstring(L1, getnum, &slen);\n      const char *name = getstring;\n      const char *mode = getstring;\n      luaL_loadbufferx(L1, s, slen, name, mode);\n    }\n    else if EQ(\"newmetatable\") {\n      lua_pushboolean(L1, luaL_newmetatable(L1, getstring));\n    }\n    else if EQ(\"newtable\") {\n      lua_newtable(L1);\n    }\n    else if EQ(\"newthread\") {\n      lua_newthread(L1);\n    }\n    else if EQ(\"resetthread\") {\n      lua_pushinteger(L1, lua_resetthread(L1));  /* deprecated */\n    }\n    else if EQ(\"newuserdata\") {\n      lua_newuserdata(L1, cast_sizet(getnum));\n    }\n    else if EQ(\"next\") {\n      lua_next(L1, -2);\n    }\n    else if EQ(\"objsize\") {\n      lua_pushinteger(L1, l_castU2S(lua_rawlen(L1, getindex)));\n    }\n    else if EQ(\"pcall\") {\n      int narg = getnum;\n      int nres = getnum;\n      status = lua_pcall(L1, narg, nres, getnum);\n    }\n    else if EQ(\"pcallk\") {\n      int narg = getnum;\n      int nres = getnum;\n      int i = getindex;\n      status = lua_pcallk(L1, narg, nres, 0, i, Cfunck);\n    }\n    else if EQ(\"pop\") {\n      lua_pop(L1, getnum);\n    }\n    else if EQ(\"printstack\") {\n      int n = getnum;\n      if (n != 0) {\n        lua_printvalue(s2v(L->ci->func.p + n));\n        printf(\"\\n\");\n      }\n      else lua_printstack(L1);\n    }\n    else if EQ(\"print\") {\n      const char *msg = getstring;\n      printf(\"%s\\n\", msg);\n    }\n    else if EQ(\"warningC\") {\n      const char *msg = getstring;\n      lua_warning(L1, msg, 1);\n    }\n    else if EQ(\"warning\") {\n      const char *msg = getstring;\n      lua_warning(L1, msg, 0);\n    }\n    else if EQ(\"pushbool\") {\n      lua_pushboolean(L1, getnum);\n    }\n    else if EQ(\"pushcclosure\") {\n      lua_pushcclosure(L1, testC, getnum);\n    }\n    else if EQ(\"pushint\") {\n      lua_pushinteger(L1, getnum);\n    }\n    else if EQ(\"pushnil\") {\n      lua_pushnil(L1);\n    }\n    else if EQ(\"pushnum\") {\n      lua_pushnumber(L1, (lua_Number)getnum);\n    }\n    else if EQ(\"pushstatus\") {\n      lua_pushstring(L1, statcodes[status]);\n    }\n    else if EQ(\"pushstring\") {\n      lua_pushstring(L1, getstring);\n    }\n    else if EQ(\"pushupvalueindex\") {\n      lua_pushinteger(L1, lua_upvalueindex(getnum));\n    }\n    else if EQ(\"pushvalue\") {\n      lua_pushvalue(L1, getindex);\n    }\n    else if EQ(\"pushfstringI\") {\n      lua_pushfstring(L1, lua_tostring(L, -2), (int)lua_tointeger(L, -1));\n    }\n    else if EQ(\"pushfstringS\") {\n      lua_pushfstring(L1, lua_tostring(L, -2), lua_tostring(L, -1));\n    }\n    else if EQ(\"pushfstringP\") {\n      lua_pushfstring(L1, lua_tostring(L, -2), lua_topointer(L, -1));\n    }\n    else if EQ(\"rawget\") {\n      int t = getindex;\n      lua_rawget(L1, t);\n    }\n    else if EQ(\"rawgeti\") {\n      int t = getindex;\n      lua_rawgeti(L1, t, getnum);\n    }\n    else if EQ(\"rawgetp\") {\n      int t = getindex;\n      lua_rawgetp(L1, t, cast_voidp(cast_sizet(getnum)));\n    }\n    else if EQ(\"rawset\") {\n      int t = getindex;\n      lua_rawset(L1, t);\n    }\n    else if EQ(\"rawseti\") {\n      int t = getindex;\n      lua_rawseti(L1, t, getnum);\n    }\n    else if EQ(\"rawsetp\") {\n      int t = getindex;\n      lua_rawsetp(L1, t, cast_voidp(cast_sizet(getnum)));\n    }\n    else if EQ(\"remove\") {\n      lua_remove(L1, getnum);\n    }\n    else if EQ(\"replace\") {\n      lua_replace(L1, getindex);\n    }\n    else if EQ(\"resume\") {\n      int i = getindex;\n      int nres;\n      status = lua_resume(lua_tothread(L1, i), L, getnum, &nres);\n    }\n    else if EQ(\"traceback\") {\n      const char *msg = getstring;\n      int level = getnum;\n      luaL_traceback(L1, L1, msg, level);\n    }\n    else if EQ(\"return\") {\n      int n = getnum;\n      if (L1 != L) {\n        int i;\n        for (i = 0; i < n; i++) {\n          int idx = -(n - i);\n          switch (lua_type(L1, idx)) {\n            case LUA_TBOOLEAN:\n              lua_pushboolean(L, lua_toboolean(L1, idx));\n              break;\n            default:\n              lua_pushstring(L, lua_tostring(L1, idx));\n              break;\n          }\n        }\n      }\n      return n;\n    }\n    else if EQ(\"rotate\") {\n      int i = getindex;\n      lua_rotate(L1, i, getnum);\n    }\n    else if EQ(\"setfield\") {\n      int t = getindex;\n      const char *s = getstring;\n      lua_setfield(L1, t, s);\n    }\n    else if EQ(\"seti\") {\n      int t = getindex;\n      lua_seti(L1, t, getnum);\n    }\n    else if EQ(\"setglobal\") {\n      const char *s = getstring;\n      lua_setglobal(L1, s);\n    }\n    else if EQ(\"sethook\") {\n      int mask = getnum;\n      int count = getnum;\n      const char *s = getstring;\n      sethookaux(L1, mask, count, s);\n    }\n    else if EQ(\"setmetatable\") {\n      int idx = getindex;\n      lua_setmetatable(L1, idx);\n    }\n    else if EQ(\"settable\") {\n      lua_settable(L1, getindex);\n    }\n    else if EQ(\"settop\") {\n      lua_settop(L1, getnum);\n    }\n    else if EQ(\"testudata\") {\n      int i = getindex;\n      lua_pushboolean(L1, luaL_testudata(L1, i, getstring) != NULL);\n    }\n    else if EQ(\"error\") {\n      lua_error(L1);\n    }\n    else if EQ(\"abort\") {\n      abort();\n    }\n    else if EQ(\"throw\") {\n#if defined(__cplusplus)\nstatic struct X { int x; } x;\n      throw x;\n#else\n      luaL_error(L1, \"C++\");\n#endif\n      break;\n    }\n    else if EQ(\"tobool\") {\n      lua_pushboolean(L1, lua_toboolean(L1, getindex));\n    }\n    else if EQ(\"tocfunction\") {\n      lua_pushcfunction(L1, lua_tocfunction(L1, getindex));\n    }\n    else if EQ(\"tointeger\") {\n      lua_pushinteger(L1, lua_tointeger(L1, getindex));\n    }\n    else if EQ(\"tonumber\") {\n      lua_pushnumber(L1, lua_tonumber(L1, getindex));\n    }\n    else if EQ(\"topointer\") {\n      lua_pushlightuserdata(L1, cast_voidp(lua_topointer(L1, getindex)));\n    }\n    else if EQ(\"touserdata\") {\n      lua_pushlightuserdata(L1, lua_touserdata(L1, getindex));\n    }\n    else if EQ(\"tostring\") {\n      const char *s = lua_tostring(L1, getindex);\n      const char *s1 = lua_pushstring(L1, s);\n      cast_void(s1);  /* to avoid warnings */\n      lua_longassert((s == NULL && s1 == NULL) || strcmp(s, s1) == 0);\n    }\n    else if EQ(\"Ltolstring\") {\n      luaL_tolstring(L1, getindex, NULL);\n    }\n    else if EQ(\"type\") {\n      lua_pushstring(L1, luaL_typename(L1, getnum));\n    }\n    else if EQ(\"xmove\") {\n      int f = getindex;\n      int t = getindex;\n      lua_State *fs = (f == 0) ? L1 : lua_tothread(L1, f);\n      lua_State *ts = (t == 0) ? L1 : lua_tothread(L1, t);\n      int n = getnum;\n      if (n == 0) n = lua_gettop(fs);\n      lua_xmove(fs, ts, n);\n    }\n    else if EQ(\"isyieldable\") {\n      lua_pushboolean(L1, lua_isyieldable(lua_tothread(L1, getindex)));\n    }\n    else if EQ(\"yield\") {\n      return lua_yield(L1, getnum);\n    }\n    else if EQ(\"yieldk\") {\n      int nres = getnum;\n      int i = getindex;\n      return lua_yieldk(L1, nres, i, Cfunck);\n    }\n    else if EQ(\"toclose\") {\n      lua_toclose(L1, getnum);\n    }\n    else if EQ(\"closeslot\") {\n      lua_closeslot(L1, getnum);\n    }\n    else if EQ(\"argerror\") {\n      int arg = getnum;\n      luaL_argerror(L1, arg, getstring);\n    }\n    else luaL_error(L, \"unknown instruction %s\", buff);\n  }\n  return 0;\n}\n\n\nstatic int testC (lua_State *L) {\n  lua_State *L1;\n  const char *pc;\n  if (lua_isuserdata(L, 1)) {\n    L1 = getstate(L);\n    pc = luaL_checkstring(L, 2);\n  }\n  else if (lua_isthread(L, 1)) {\n    L1 = lua_tothread(L, 1);\n    pc = luaL_checkstring(L, 2);\n  }\n  else {\n    L1 = L;\n    pc = luaL_checkstring(L, 1);\n  }\n  return runC(L, L1, pc);\n}\n\n\nstatic int Cfunc (lua_State *L) {\n  return runC(L, L, lua_tostring(L, lua_upvalueindex(1)));\n}\n\n\nstatic int Cfunck (lua_State *L, int status, lua_KContext ctx) {\n  lua_pushstring(L, statcodes[status]);\n  lua_setglobal(L, \"status\");\n  lua_pushinteger(L, cast(lua_Integer, ctx));\n  lua_setglobal(L, \"ctx\");\n  return runC(L, L, lua_tostring(L, cast_int(ctx)));\n}\n\n\nstatic int makeCfunc (lua_State *L) {\n  luaL_checkstring(L, 1);\n  lua_pushcclosure(L, Cfunc, lua_gettop(L));\n  return 1;\n}\n\n\n/* }====================================================== */\n\n\n/*\n** {======================================================\n** tests for C hooks\n** =======================================================\n*/\n\n/*\n** C hook that runs the C script stored in registry.C_HOOK[L]\n*/\nstatic void Chook (lua_State *L, lua_Debug *ar) {\n  const char *scpt;\n  const char *const events [] = {\"call\", \"ret\", \"line\", \"count\", \"tailcall\"};\n  lua_getfield(L, LUA_REGISTRYINDEX, \"C_HOOK\");\n  lua_pushlightuserdata(L, L);\n  lua_gettable(L, -2);  /* get C_HOOK[L] (script saved by sethookaux) */\n  scpt = lua_tostring(L, -1);  /* not very religious (string will be popped) */\n  lua_pop(L, 2);  /* remove C_HOOK and script */\n  lua_pushstring(L, events[ar->event]);  /* may be used by script */\n  lua_pushinteger(L, ar->currentline);  /* may be used by script */\n  runC(L, L, scpt);  /* run script from C_HOOK[L] */\n}\n\n\n/*\n** sets 'registry.C_HOOK[L] = scpt' and sets 'Chook' as a hook\n*/\nstatic void sethookaux (lua_State *L, int mask, int count, const char *scpt) {\n  if (*scpt == '\\0') {  /* no script? */\n    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */\n    return;\n  }\n  lua_getfield(L, LUA_REGISTRYINDEX, \"C_HOOK\");  /* get C_HOOK table */\n  if (!lua_istable(L, -1)) {  /* no hook table? */\n    lua_pop(L, 1);  /* remove previous value */\n    lua_newtable(L);  /* create new C_HOOK table */\n    lua_pushvalue(L, -1);\n    lua_setfield(L, LUA_REGISTRYINDEX, \"C_HOOK\");  /* register it */\n  }\n  lua_pushlightuserdata(L, L);\n  lua_pushstring(L, scpt);\n  lua_settable(L, -3);  /* C_HOOK[L] = script */\n  lua_sethook(L, Chook, mask, count);\n}\n\n\nstatic int sethook (lua_State *L) {\n  if (lua_isnoneornil(L, 1))\n    lua_sethook(L, NULL, 0, 0);  /* turn off hooks */\n  else {\n    const char *scpt = luaL_checkstring(L, 1);\n    const char *smask = luaL_checkstring(L, 2);\n    int count = cast_int(luaL_optinteger(L, 3, 0));\n    int mask = 0;\n    if (strchr(smask, 'c')) mask |= LUA_MASKCALL;\n    if (strchr(smask, 'r')) mask |= LUA_MASKRET;\n    if (strchr(smask, 'l')) mask |= LUA_MASKLINE;\n    if (count > 0) mask |= LUA_MASKCOUNT;\n    sethookaux(L, mask, count, scpt);\n  }\n  return 0;\n}\n\n\nstatic int coresume (lua_State *L) {\n  int status, nres;\n  lua_State *co = lua_tothread(L, 1);\n  luaL_argcheck(L, co, 1, \"coroutine expected\");\n  status = lua_resume(co, L, 0, &nres);\n  if (status != LUA_OK && status != LUA_YIELD) {\n    lua_pushboolean(L, 0);\n    lua_insert(L, -2);\n    return 2;  /* return false + error message */\n  }\n  else {\n    lua_pushboolean(L, 1);\n    return 1;\n  }\n}\n\n/* }====================================================== */\n\n\n\nstatic const struct luaL_Reg tests_funcs[] = {\n  {\"checkmemory\", lua_checkmemory},\n  {\"closestate\", closestate},\n  {\"d2s\", d2s},\n  {\"doonnewstack\", doonnewstack},\n  {\"doremote\", doremote},\n  {\"gccolor\", gc_color},\n  {\"gcage\", gc_age},\n  {\"gcstate\", gc_state},\n  {\"tracegc\", tracegc},\n  {\"pobj\", gc_printobj},\n  {\"getref\", getref},\n  {\"hash\", hash_query},\n  {\"log2\", log2_aux},\n  {\"limits\", get_limits},\n  {\"listcode\", listcode},\n  {\"printcode\", printcode},\n  {\"listk\", listk},\n  {\"listabslineinfo\", listabslineinfo},\n  {\"listlocals\", listlocals},\n  {\"loadlib\", loadlib},\n  {\"checkpanic\", checkpanic},\n  {\"newstate\", newstate},\n  {\"newuserdata\", newuserdata},\n  {\"num2int\", num2int},\n  {\"makeseed\", makeseed},\n  {\"pushuserdata\", pushuserdata},\n  {\"gcquery\", gc_query},\n  {\"querystr\", string_query},\n  {\"querytab\", table_query},\n  {\"codeparam\", test_codeparam},\n  {\"applyparam\", test_applyparam},\n  {\"ref\", tref},\n  {\"resume\", coresume},\n  {\"s2d\", s2d},\n  {\"sethook\", sethook},\n  {\"stacklevel\", stacklevel},\n  {\"testC\", testC},\n  {\"makeCfunc\", makeCfunc},\n  {\"totalmem\", mem_query},\n  {\"alloccount\", alloc_count},\n  {\"allocfailnext\", alloc_failnext},\n  {\"trick\", settrick},\n  {\"udataval\", udataval},\n  {\"unref\", unref},\n  {\"upvalue\", upvalue},\n  {\"externKstr\", externKstr},\n  {\"externstr\", externstr},\n  {NULL, NULL}\n};\n\n\nstatic void checkfinalmem (void) {\n  lua_assert(l_memcontrol.numblocks == 0);\n  lua_assert(l_memcontrol.total == 0);\n}\n\n\nint luaB_opentests (lua_State *L) {\n  void *ud;\n  lua_Alloc f = lua_getallocf(L, &ud);\n  lua_atpanic(L, &tpanic);\n  lua_setwarnf(L, &warnf, L);\n  lua_pushboolean(L, 0);\n  lua_setglobal(L, \"_WARN\");  /* _WARN = false */\n  regcodes(L);\n  atexit(checkfinalmem);\n  lua_assert(f == debug_realloc && ud == cast_voidp(&l_memcontrol));\n  lua_setallocf(L, f, ud);  /* exercise this function */\n  luaL_newlib(L, tests_funcs);\n  return 1;\n}\n\n#endif\n\n"
        },
        {
          "name": "ltests.h",
          "type": "blob",
          "size": 3.537109375,
          "content": "/*\n** $Id: ltests.h $\n** Internal Header for Debugging of the Lua Implementation\n** See Copyright Notice in lua.h\n*/\n\n#ifndef ltests_h\n#define ltests_h\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n/* test Lua with compatibility code */\n#define LUA_COMPAT_MATHLIB\n#define LUA_COMPAT_LT_LE\n\n\n#define LUA_DEBUG\n\n\n/* turn on assertions */\n#define LUAI_ASSERT\n\n\n/* to avoid warnings, and to make sure value is really unused */\n#define UNUSED(x)       (x=0, (void)(x))\n\n\n/* test for sizes in 'l_sprintf' (make sure whole buffer is available) */\n#undef l_sprintf\n#if !defined(LUA_USE_C89)\n#define l_sprintf(s,sz,f,i)\t(memset(s,0xAB,sz), snprintf(s,sz,f,i))\n#else\n#define l_sprintf(s,sz,f,i)\t(memset(s,0xAB,sz), sprintf(s,f,i))\n#endif\n\n\n/* get a chance to test code without jump tables */\n#define LUA_USE_JUMPTABLE\t0\n\n\n/* use 32-bit integers in random generator */\n#define LUA_RAND32\n\n\n/* memory-allocator control variables */\ntypedef struct Memcontrol {\n  int failnext;\n  unsigned long numblocks;\n  unsigned long total;\n  unsigned long maxmem;\n  unsigned long memlimit;\n  unsigned long countlimit;\n  unsigned long objcount[LUA_NUMTYPES];\n} Memcontrol;\n\nLUA_API Memcontrol l_memcontrol;\n\n\n#define luai_tracegc(L,f)\t\tluai_tracegctest(L, f)\nLUAI_FUNC void luai_tracegctest (lua_State *L, int first);\n\n\n/*\n** generic variable for debug tricks\n*/\nextern void *l_Trick;\n\n\n/*\n** Function to traverse and check all memory used by Lua\n*/\nLUAI_FUNC int lua_checkmemory (lua_State *L);\n\n/*\n** Function to print an object GC-friendly\n*/\nstruct GCObject;\nLUAI_FUNC void lua_printobj (lua_State *L, struct GCObject *o);\n\n\n/*\n** Function to print a value\n*/\nstruct TValue;\nLUAI_FUNC void lua_printvalue (struct TValue *v);\n\n/*\n** Function to print the stack\n*/\nLUAI_FUNC void lua_printstack (lua_State *L);\n\n\n/* test for lock/unlock */\n\nstruct L_EXTRA { int lock; int *plock; };\n#undef LUA_EXTRASPACE\n#define LUA_EXTRASPACE\tsizeof(struct L_EXTRA)\n#define getlock(l)\tcast(struct L_EXTRA*, lua_getextraspace(l))\n#define luai_userstateopen(l)  \\\n\t(getlock(l)->lock = 0, getlock(l)->plock = &(getlock(l)->lock))\n#define luai_userstateclose(l)  \\\n  lua_assert(getlock(l)->lock == 1 && getlock(l)->plock == &(getlock(l)->lock))\n#define luai_userstatethread(l,l1) \\\n  lua_assert(getlock(l1)->plock == getlock(l)->plock)\n#define luai_userstatefree(l,l1) \\\n  lua_assert(getlock(l)->plock == getlock(l1)->plock)\n#define lua_lock(l)     lua_assert((*getlock(l)->plock)++ == 0)\n#define lua_unlock(l)   lua_assert(--(*getlock(l)->plock) == 0)\n\n\n\nLUA_API int luaB_opentests (lua_State *L);\n\nLUA_API void *debug_realloc (void *ud, void *block,\n                             size_t osize, size_t nsize);\n\n#if defined(lua_c)\n#define luaL_newstate()  \\\n\tlua_newstate(debug_realloc, &l_memcontrol, luaL_makeseed(NULL))\n#define luai_openlibs(L)  \\\n  {  luaL_openlibs(L); \\\n     luaL_requiref(L, \"T\", luaB_opentests, 1); \\\n     lua_pop(L, 1); }\n#endif\n\n\n\n/* change some sizes to give some bugs a chance */\n\n#undef LUAL_BUFFERSIZE\n#define LUAL_BUFFERSIZE\t\t23\n#define MINSTRTABSIZE\t\t2\n#define MAXIWTHABS\t\t3\n\n#define STRCACHE_N\t23\n#define STRCACHE_M\t5\n\n#undef LUAI_USER_ALIGNMENT_T\n#define LUAI_USER_ALIGNMENT_T   union { char b[sizeof(void*) * 8]; }\n\n\n/*\n** This one is not compatible with tests for opcode optimizations,\n** as it blocks some optimizations\n#define MAXINDEXRK\t0\n*/\n\n\n/* make stack-overflow tests run faster */\n#undef LUAI_MAXSTACK\n#define LUAI_MAXSTACK   50000\n\n\n/* test mode uses more stack space */\n#undef LUAI_MAXCCALLS\n#define LUAI_MAXCCALLS\t180\n\n\n/* force Lua to use its own implementations */\n#undef lua_strx2number\n#undef lua_number2strx\n\n\n#endif\n\n"
        },
        {
          "name": "ltm.c",
          "type": "blob",
          "size": 8.328125,
          "content": "/*\n** $Id: ltm.c $\n** Tag methods\n** See Copyright Notice in lua.h\n*/\n\n#define ltm_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lgc.h\"\n#include \"lobject.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\nstatic const char udatatypename[] = \"userdata\";\n\nLUAI_DDEF const char *const luaT_typenames_[LUA_TOTALTYPES] = {\n  \"no value\",\n  \"nil\", \"boolean\", udatatypename, \"number\",\n  \"string\", \"table\", \"function\", udatatypename, \"thread\",\n  \"upvalue\", \"proto\" /* these last cases are used for tests only */\n};\n\n\nvoid luaT_init (lua_State *L) {\n  static const char *const luaT_eventname[] = {  /* ORDER TM */\n    \"__index\", \"__newindex\",\n    \"__gc\", \"__mode\", \"__len\", \"__eq\",\n    \"__add\", \"__sub\", \"__mul\", \"__mod\", \"__pow\",\n    \"__div\", \"__idiv\",\n    \"__band\", \"__bor\", \"__bxor\", \"__shl\", \"__shr\",\n    \"__unm\", \"__bnot\", \"__lt\", \"__le\",\n    \"__concat\", \"__call\", \"__close\"\n  };\n  int i;\n  for (i=0; i<TM_N; i++) {\n    G(L)->tmname[i] = luaS_new(L, luaT_eventname[i]);\n    luaC_fix(L, obj2gco(G(L)->tmname[i]));  /* never collect these names */\n  }\n}\n\n\n/*\n** function to be used with macro \"fasttm\": optimized for absence of\n** tag methods\n*/\nconst TValue *luaT_gettm (Table *events, TMS event, TString *ename) {\n  const TValue *tm = luaH_Hgetshortstr(events, ename);\n  lua_assert(event <= TM_EQ);\n  if (notm(tm)) {  /* no tag method? */\n    events->flags |= cast_byte(1u<<event);  /* cache this fact */\n    return NULL;\n  }\n  else return tm;\n}\n\n\nconst TValue *luaT_gettmbyobj (lua_State *L, const TValue *o, TMS event) {\n  Table *mt;\n  switch (ttype(o)) {\n    case LUA_TTABLE:\n      mt = hvalue(o)->metatable;\n      break;\n    case LUA_TUSERDATA:\n      mt = uvalue(o)->metatable;\n      break;\n    default:\n      mt = G(L)->mt[ttype(o)];\n  }\n  return (mt ? luaH_Hgetshortstr(mt, G(L)->tmname[event]) : &G(L)->nilvalue);\n}\n\n\n/*\n** Return the name of the type of an object. For tables and userdata\n** with metatable, use their '__name' metafield, if present.\n*/\nconst char *luaT_objtypename (lua_State *L, const TValue *o) {\n  Table *mt;\n  if ((ttistable(o) && (mt = hvalue(o)->metatable) != NULL) ||\n      (ttisfulluserdata(o) && (mt = uvalue(o)->metatable) != NULL)) {\n    const TValue *name = luaH_Hgetshortstr(mt, luaS_new(L, \"__name\"));\n    if (ttisstring(name))  /* is '__name' a string? */\n      return getstr(tsvalue(name));  /* use it as type name */\n  }\n  return ttypename(ttype(o));  /* else use standard type name */\n}\n\n\nvoid luaT_callTM (lua_State *L, const TValue *f, const TValue *p1,\n                  const TValue *p2, const TValue *p3) {\n  StkId func = L->top.p;\n  setobj2s(L, func, f);  /* push function (assume EXTRA_STACK) */\n  setobj2s(L, func + 1, p1);  /* 1st argument */\n  setobj2s(L, func + 2, p2);  /* 2nd argument */\n  setobj2s(L, func + 3, p3);  /* 3rd argument */\n  L->top.p = func + 4;\n  /* metamethod may yield only when called from Lua code */\n  if (isLuacode(L->ci))\n    luaD_call(L, func, 0);\n  else\n    luaD_callnoyield(L, func, 0);\n}\n\n\nlu_byte luaT_callTMres (lua_State *L, const TValue *f, const TValue *p1,\n                        const TValue *p2, StkId res) {\n  ptrdiff_t result = savestack(L, res);\n  StkId func = L->top.p;\n  setobj2s(L, func, f);  /* push function (assume EXTRA_STACK) */\n  setobj2s(L, func + 1, p1);  /* 1st argument */\n  setobj2s(L, func + 2, p2);  /* 2nd argument */\n  L->top.p += 3;\n  /* metamethod may yield only when called from Lua code */\n  if (isLuacode(L->ci))\n    luaD_call(L, func, 1);\n  else\n    luaD_callnoyield(L, func, 1);\n  res = restorestack(L, result);\n  setobjs2s(L, res, --L->top.p);  /* move result to its place */\n  return ttypetag(s2v(res));  /* return tag of the result */\n}\n\n\nstatic int callbinTM (lua_State *L, const TValue *p1, const TValue *p2,\n                      StkId res, TMS event) {\n  const TValue *tm = luaT_gettmbyobj(L, p1, event);  /* try first operand */\n  if (notm(tm))\n    tm = luaT_gettmbyobj(L, p2, event);  /* try second operand */\n  if (notm(tm))\n    return -1;  /* tag method not found */\n  else  /* call tag method and return the tag of the result */\n    return luaT_callTMres(L, tm, p1, p2, res);\n}\n\n\nvoid luaT_trybinTM (lua_State *L, const TValue *p1, const TValue *p2,\n                    StkId res, TMS event) {\n  if (l_unlikely(callbinTM(L, p1, p2, res, event) < 0)) {\n    switch (event) {\n      case TM_BAND: case TM_BOR: case TM_BXOR:\n      case TM_SHL: case TM_SHR: case TM_BNOT: {\n        if (ttisnumber(p1) && ttisnumber(p2))\n          luaG_tointerror(L, p1, p2);\n        else\n          luaG_opinterror(L, p1, p2, \"perform bitwise operation on\");\n      }\n      /* calls never return, but to avoid warnings: *//* FALLTHROUGH */\n      default:\n        luaG_opinterror(L, p1, p2, \"perform arithmetic on\");\n    }\n  }\n}\n\n\n/*\n** The use of 'p1' after 'callbinTM' is safe because, when a tag\n** method is not found, 'callbinTM' cannot change the stack.\n*/\nvoid luaT_tryconcatTM (lua_State *L) {\n  StkId p1 = L->top.p - 2;  /* first argument */\n  if (l_unlikely(callbinTM(L, s2v(p1), s2v(p1 + 1), p1, TM_CONCAT) < 0))\n    luaG_concaterror(L, s2v(p1), s2v(p1 + 1));\n}\n\n\nvoid luaT_trybinassocTM (lua_State *L, const TValue *p1, const TValue *p2,\n                                       int flip, StkId res, TMS event) {\n  if (flip)\n    luaT_trybinTM(L, p2, p1, res, event);\n  else\n    luaT_trybinTM(L, p1, p2, res, event);\n}\n\n\nvoid luaT_trybiniTM (lua_State *L, const TValue *p1, lua_Integer i2,\n                                   int flip, StkId res, TMS event) {\n  TValue aux;\n  setivalue(&aux, i2);\n  luaT_trybinassocTM(L, p1, &aux, flip, res, event);\n}\n\n\n/*\n** Calls an order tag method.\n** For lessequal, LUA_COMPAT_LT_LE keeps compatibility with old\n** behavior: if there is no '__le', try '__lt', based on l <= r iff\n** !(r < l) (assuming a total order). If the metamethod yields during\n** this substitution, the continuation has to know about it (to negate\n** the result of r<l); bit CIST_LEQ in the call status keeps that\n** information.\n*/\nint luaT_callorderTM (lua_State *L, const TValue *p1, const TValue *p2,\n                      TMS event) {\n  int tag = callbinTM(L, p1, p2, L->top.p, event);  /* try original event */\n  if (tag >= 0)  /* found tag method? */\n    return !tagisfalse(tag);\n#if defined(LUA_COMPAT_LT_LE)\n  else if (event == TM_LE) {\n    /* try '!(p2 < p1)' for '(p1 <= p2)' */\n    L->ci->callstatus |= CIST_LEQ;  /* mark it is doing 'lt' for 'le' */\n    tag = callbinTM(L, p2, p1, L->top.p, TM_LT);\n    L->ci->callstatus ^= CIST_LEQ;  /* clear mark */\n    if (tag >= 0)  /* found tag method? */\n      return tagisfalse(tag);\n  }\n#endif\n  luaG_ordererror(L, p1, p2);  /* no metamethod found */\n  return 0;  /* to avoid warnings */\n}\n\n\nint luaT_callorderiTM (lua_State *L, const TValue *p1, int v2,\n                       int flip, int isfloat, TMS event) {\n  TValue aux; const TValue *p2;\n  if (isfloat) {\n    setfltvalue(&aux, cast_num(v2));\n  }\n  else\n    setivalue(&aux, v2);\n  if (flip) {  /* arguments were exchanged? */\n    p2 = p1; p1 = &aux;  /* correct them */\n  }\n  else\n    p2 = &aux;\n  return luaT_callorderTM(L, p1, p2, event);\n}\n\n\nvoid luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top.p - ci->func.p) - 1;  /* number of arguments */\n  int nextra = actual - nfixparams;  /* number of extra arguments */\n  ci->u.l.nextraargs = nextra;\n  luaD_checkstack(L, p->maxstacksize + 1);\n  /* copy function to the top of the stack */\n  setobjs2s(L, L->top.p++, ci->func.p);\n  /* move fixed parameters to the top of the stack */\n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top.p++, ci->func.p + i);\n    setnilvalue(s2v(ci->func.p + i));  /* erase original parameter (for GC) */\n  }\n  ci->func.p += actual + 1;\n  ci->top.p += actual + 1;\n  lua_assert(L->top.p <= ci->top.p && ci->top.p <= L->stack_last.p);\n}\n\n\nvoid luaT_getvarargs (lua_State *L, CallInfo *ci, StkId where, int wanted) {\n  int i;\n  int nextra = ci->u.l.nextraargs;\n  if (wanted < 0) {\n    wanted = nextra;  /* get all extra arguments available */\n    checkstackp(L, nextra, where);  /* ensure stack space */\n    L->top.p = where + nextra;  /* next instruction will need top */\n  }\n  for (i = 0; i < wanted && i < nextra; i++)\n    setobjs2s(L, where + i, ci->func.p - nextra + i);\n  for (; i < wanted; i++)   /* complete required results with nil */\n    setnilvalue(s2v(where + i));\n}\n\n"
        },
        {
          "name": "ltm.h",
          "type": "blob",
          "size": 2.943359375,
          "content": "/*\n** $Id: ltm.h $\n** Tag methods\n** See Copyright Notice in lua.h\n*/\n\n#ifndef ltm_h\n#define ltm_h\n\n\n#include \"lobject.h\"\n\n\n/*\n* WARNING: if you change the order of this enumeration,\n* grep \"ORDER TM\" and \"ORDER OP\"\n*/\ntypedef enum {\n  TM_INDEX,\n  TM_NEWINDEX,\n  TM_GC,\n  TM_MODE,\n  TM_LEN,\n  TM_EQ,  /* last tag method with fast access */\n  TM_ADD,\n  TM_SUB,\n  TM_MUL,\n  TM_MOD,\n  TM_POW,\n  TM_DIV,\n  TM_IDIV,\n  TM_BAND,\n  TM_BOR,\n  TM_BXOR,\n  TM_SHL,\n  TM_SHR,\n  TM_UNM,\n  TM_BNOT,\n  TM_LT,\n  TM_LE,\n  TM_CONCAT,\n  TM_CALL,\n  TM_CLOSE,\n  TM_N\t\t/* number of elements in the enum */\n} TMS;\n\n\n/*\n** Mask with 1 in all fast-access methods. A 1 in any of these bits\n** in the flag of a (meta)table means the metatable does not have the\n** corresponding metamethod field. (Bit 6 of the flag indicates that\n** the table is using the dummy node; bit 7 is used for 'isrealasize'.)\n*/\n#define maskflags\tcast_byte(~(~0u << (TM_EQ + 1)))\n\n\n/*\n** Test whether there is no tagmethod.\n** (Because tagmethods use raw accesses, the result may be an \"empty\" nil.)\n*/\n#define notm(tm)\tttisnil(tm)\n\n#define checknoTM(mt,e)\t((mt) == NULL || (mt)->flags & (1u<<(e)))\n\n#define gfasttm(g,mt,e)  \\\n  (checknoTM(mt, e) ? NULL : luaT_gettm(mt, e, (g)->tmname[e]))\n\n#define fasttm(l,mt,e)\tgfasttm(G(l), mt, e)\n\n#define ttypename(x)\tluaT_typenames_[(x) + 1]\n\nLUAI_DDEC(const char *const luaT_typenames_[LUA_TOTALTYPES];)\n\n\nLUAI_FUNC const char *luaT_objtypename (lua_State *L, const TValue *o);\n\nLUAI_FUNC const TValue *luaT_gettm (Table *events, TMS event, TString *ename);\nLUAI_FUNC const TValue *luaT_gettmbyobj (lua_State *L, const TValue *o,\n                                                       TMS event);\nLUAI_FUNC void luaT_init (lua_State *L);\n\nLUAI_FUNC void luaT_callTM (lua_State *L, const TValue *f, const TValue *p1,\n                            const TValue *p2, const TValue *p3);\nLUAI_FUNC lu_byte luaT_callTMres (lua_State *L, const TValue *f,\n                               const TValue *p1, const TValue *p2, StkId p3);\nLUAI_FUNC void luaT_trybinTM (lua_State *L, const TValue *p1, const TValue *p2,\n                              StkId res, TMS event);\nLUAI_FUNC void luaT_tryconcatTM (lua_State *L);\nLUAI_FUNC void luaT_trybinassocTM (lua_State *L, const TValue *p1,\n       const TValue *p2, int inv, StkId res, TMS event);\nLUAI_FUNC void luaT_trybiniTM (lua_State *L, const TValue *p1, lua_Integer i2,\n                               int inv, StkId res, TMS event);\nLUAI_FUNC int luaT_callorderTM (lua_State *L, const TValue *p1,\n                                const TValue *p2, TMS event);\nLUAI_FUNC int luaT_callorderiTM (lua_State *L, const TValue *p1, int v2,\n                                 int inv, int isfloat, TMS event);\n\nLUAI_FUNC void luaT_adjustvarargs (lua_State *L, int nfixparams,\n                                   struct CallInfo *ci, const Proto *p);\nLUAI_FUNC void luaT_getvarargs (lua_State *L, struct CallInfo *ci,\n                                              StkId where, int wanted);\n\n\n#endif\n"
        },
        {
          "name": "lua.c",
          "type": "blob",
          "size": 21.890625,
          "content": "/*\n** $Id: lua.c $\n** Lua stand-alone interpreter\n** See Copyright Notice in lua.h\n*/\n\n#define lua_c\n\n#include \"lprefix.h\"\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <signal.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n#include \"llimits.h\"\n\n\n#if !defined(LUA_PROGNAME)\n#define LUA_PROGNAME\t\t\"lua\"\n#endif\n\n#if !defined(LUA_INIT_VAR)\n#define LUA_INIT_VAR\t\t\"LUA_INIT\"\n#endif\n\n#define LUA_INITVARVERSION\tLUA_INIT_VAR LUA_VERSUFFIX\n\n\nstatic lua_State *globalL = NULL;\n\nstatic const char *progname = LUA_PROGNAME;\n\n\n#if defined(LUA_USE_POSIX)   /* { */\n\n/*\n** Use 'sigaction' when available.\n*/\nstatic void setsignal (int sig, void (*handler)(int)) {\n  struct sigaction sa;\n  sa.sa_handler = handler;\n  sa.sa_flags = 0;\n  sigemptyset(&sa.sa_mask);  /* do not mask any signal */\n  sigaction(sig, &sa, NULL);\n}\n\n#else           /* }{ */\n\n#define setsignal            signal\n\n#endif                               /* } */\n\n\n/*\n** Hook set by signal function to stop the interpreter.\n*/\nstatic void lstop (lua_State *L, lua_Debug *ar) {\n  (void)ar;  /* unused arg. */\n  lua_sethook(L, NULL, 0, 0);  /* reset hook */\n  luaL_error(L, \"interrupted!\");\n}\n\n\n/*\n** Function to be called at a C signal. Because a C signal cannot\n** just change a Lua state (as there is no proper synchronization),\n** this function only sets a hook that, when called, will stop the\n** interpreter.\n*/\nstatic void laction (int i) {\n  int flag = LUA_MASKCALL | LUA_MASKRET | LUA_MASKLINE | LUA_MASKCOUNT;\n  setsignal(i, SIG_DFL); /* if another SIGINT happens, terminate process */\n  lua_sethook(globalL, lstop, flag, 1);\n}\n\n\nstatic void print_usage (const char *badoption) {\n  lua_writestringerror(\"%s: \", progname);\n  if (badoption[1] == 'e' || badoption[1] == 'l')\n    lua_writestringerror(\"'%s' needs argument\\n\", badoption);\n  else\n    lua_writestringerror(\"unrecognized option '%s'\\n\", badoption);\n  lua_writestringerror(\n  \"usage: %s [options] [script [args]]\\n\"\n  \"Available options are:\\n\"\n  \"  -e stat   execute string 'stat'\\n\"\n  \"  -i        enter interactive mode after executing 'script'\\n\"\n  \"  -l mod    require library 'mod' into global 'mod'\\n\"\n  \"  -l g=mod  require library 'mod' into global 'g'\\n\"\n  \"  -v        show version information\\n\"\n  \"  -E        ignore environment variables\\n\"\n  \"  -W        turn warnings on\\n\"\n  \"  --        stop handling options\\n\"\n  \"  -         stop handling options and execute stdin\\n\"\n  ,\n  progname);\n}\n\n\n/*\n** Prints an error message, adding the program name in front of it\n** (if present)\n*/\nstatic void l_message (const char *pname, const char *msg) {\n  if (pname) lua_writestringerror(\"%s: \", pname);\n  lua_writestringerror(\"%s\\n\", msg);\n}\n\n\n/*\n** Check whether 'status' is not OK and, if so, prints the error\n** message on the top of the stack.\n*/\nstatic int report (lua_State *L, int status) {\n  if (status != LUA_OK) {\n    const char *msg = lua_tostring(L, -1);\n    if (msg == NULL)\n      msg = \"(error message not a string)\";\n    l_message(progname, msg);\n    lua_pop(L, 1);  /* remove message */\n  }\n  return status;\n}\n\n\n/*\n** Message handler used to run all chunks\n*/\nstatic int msghandler (lua_State *L) {\n  const char *msg = lua_tostring(L, 1);\n  if (msg == NULL) {  /* is error object not a string? */\n    if (luaL_callmeta(L, 1, \"__tostring\") &&  /* does it have a metamethod */\n        lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */\n      return 1;  /* that is the message */\n    else\n      msg = lua_pushfstring(L, \"(error object is a %s value)\",\n                               luaL_typename(L, 1));\n  }\n  luaL_traceback(L, L, msg, 1);  /* append a standard traceback */\n  return 1;  /* return the traceback */\n}\n\n\n/*\n** Interface to 'lua_pcall', which sets appropriate message function\n** and C-signal handler. Used to run all chunks.\n*/\nstatic int docall (lua_State *L, int narg, int nres) {\n  int status;\n  int base = lua_gettop(L) - narg;  /* function index */\n  lua_pushcfunction(L, msghandler);  /* push message handler */\n  lua_insert(L, base);  /* put it under function and args */\n  globalL = L;  /* to be available to 'laction' */\n  setsignal(SIGINT, laction);  /* set C-signal handler */\n  status = lua_pcall(L, narg, nres, base);\n  setsignal(SIGINT, SIG_DFL); /* reset C-signal handler */\n  lua_remove(L, base);  /* remove message handler from the stack */\n  return status;\n}\n\n\nstatic void print_version (void) {\n  lua_writestring(LUA_COPYRIGHT, strlen(LUA_COPYRIGHT));\n  lua_writeline();\n}\n\n\n/*\n** Create the 'arg' table, which stores all arguments from the\n** command line ('argv'). It should be aligned so that, at index 0,\n** it has 'argv[script]', which is the script name. The arguments\n** to the script (everything after 'script') go to positive indices;\n** other arguments (before the script name) go to negative indices.\n** If there is no script name, assume interpreter's name as base.\n** (If there is no interpreter's name either, 'script' is -1, so\n** table sizes are zero.)\n*/\nstatic void createargtable (lua_State *L, char **argv, int argc, int script) {\n  int i, narg;\n  narg = argc - (script + 1);  /* number of positive indices */\n  lua_createtable(L, cast_uint(narg), cast_uint(script + 1));\n  for (i = 0; i < argc; i++) {\n    lua_pushstring(L, argv[i]);\n    lua_rawseti(L, -2, i - script);\n  }\n  lua_setglobal(L, \"arg\");\n}\n\n\nstatic int dochunk (lua_State *L, int status) {\n  if (status == LUA_OK) status = docall(L, 0, 0);\n  return report(L, status);\n}\n\n\nstatic int dofile (lua_State *L, const char *name) {\n  return dochunk(L, luaL_loadfile(L, name));\n}\n\n\nstatic int dostring (lua_State *L, const char *s, const char *name) {\n  return dochunk(L, luaL_loadbuffer(L, s, strlen(s), name));\n}\n\n\n/*\n** Receives 'globname[=modname]' and runs 'globname = require(modname)'.\n** If there is no explicit modname and globname contains a '-', cut\n** the suffix after '-' (the \"version\") to make the global name.\n*/\nstatic int dolibrary (lua_State *L, char *globname) {\n  int status;\n  char *suffix = NULL;\n  char *modname = strchr(globname, '=');\n  if (modname == NULL) {  /* no explicit name? */\n    modname = globname;  /* module name is equal to global name */\n    suffix = strchr(modname, *LUA_IGMARK);  /* look for a suffix mark */\n  }\n  else {\n    *modname = '\\0';  /* global name ends here */\n    modname++;  /* module name starts after the '=' */\n  }\n  lua_getglobal(L, \"require\");\n  lua_pushstring(L, modname);\n  status = docall(L, 1, 1);  /* call 'require(modname)' */\n  if (status == LUA_OK) {\n    if (suffix != NULL)  /* is there a suffix mark? */\n      *suffix = '\\0';  /* remove suffix from global name */\n    lua_setglobal(L, globname);  /* globname = require(modname) */\n  }\n  return report(L, status);\n}\n\n\n/*\n** Push on the stack the contents of table 'arg' from 1 to #arg\n*/\nstatic int pushargs (lua_State *L) {\n  int i, n;\n  if (lua_getglobal(L, \"arg\") != LUA_TTABLE)\n    luaL_error(L, \"'arg' is not a table\");\n  n = (int)luaL_len(L, -1);\n  luaL_checkstack(L, n + 3, \"too many arguments to script\");\n  for (i = 1; i <= n; i++)\n    lua_rawgeti(L, -i, i);\n  lua_remove(L, -i);  /* remove table from the stack */\n  return n;\n}\n\n\nstatic int handle_script (lua_State *L, char **argv) {\n  int status;\n  const char *fname = argv[0];\n  if (strcmp(fname, \"-\") == 0 && strcmp(argv[-1], \"--\") != 0)\n    fname = NULL;  /* stdin */\n  status = luaL_loadfile(L, fname);\n  if (status == LUA_OK) {\n    int n = pushargs(L);  /* push arguments to script */\n    status = docall(L, n, LUA_MULTRET);\n  }\n  return report(L, status);\n}\n\n\n/* bits of various argument indicators in 'args' */\n#define has_error\t1\t/* bad option */\n#define has_i\t\t2\t/* -i */\n#define has_v\t\t4\t/* -v */\n#define has_e\t\t8\t/* -e */\n#define has_E\t\t16\t/* -E */\n\n\n/*\n** Traverses all arguments from 'argv', returning a mask with those\n** needed before running any Lua code or an error code if it finds any\n** invalid argument. In case of error, 'first' is the index of the bad\n** argument.  Otherwise, 'first' is -1 if there is no program name,\n** 0 if there is no script name, or the index of the script name.\n*/\nstatic int collectargs (char **argv, int *first) {\n  int args = 0;\n  int i;\n  if (argv[0] != NULL) {  /* is there a program name? */\n    if (argv[0][0])  /* not empty? */\n      progname = argv[0];  /* save it */\n  }\n  else {  /* no program name */\n    *first = -1;\n    return 0;\n  }\n  for (i = 1; argv[i] != NULL; i++) {  /* handle arguments */\n    *first = i;\n    if (argv[i][0] != '-')  /* not an option? */\n        return args;  /* stop handling options */\n    switch (argv[i][1]) {  /* else check option */\n      case '-':  /* '--' */\n        if (argv[i][2] != '\\0')  /* extra characters after '--'? */\n          return has_error;  /* invalid option */\n        *first = i + 1;\n        return args;\n      case '\\0':  /* '-' */\n        return args;  /* script \"name\" is '-' */\n      case 'E':\n        if (argv[i][2] != '\\0')  /* extra characters? */\n          return has_error;  /* invalid option */\n        args |= has_E;\n        break;\n      case 'W':\n        if (argv[i][2] != '\\0')  /* extra characters? */\n          return has_error;  /* invalid option */\n        break;\n      case 'i':\n        args |= has_i;  /* (-i implies -v) *//* FALLTHROUGH */\n      case 'v':\n        if (argv[i][2] != '\\0')  /* extra characters? */\n          return has_error;  /* invalid option */\n        args |= has_v;\n        break;\n      case 'e':\n        args |= has_e;  /* FALLTHROUGH */\n      case 'l':  /* both options need an argument */\n        if (argv[i][2] == '\\0') {  /* no concatenated argument? */\n          i++;  /* try next 'argv' */\n          if (argv[i] == NULL || argv[i][0] == '-')\n            return has_error;  /* no next argument or it is another option */\n        }\n        break;\n      default:  /* invalid option */\n        return has_error;\n    }\n  }\n  *first = 0;  /* no script name */\n  return args;\n}\n\n\n/*\n** Processes options 'e' and 'l', which involve running Lua code, and\n** 'W', which also affects the state.\n** Returns 0 if some code raises an error.\n*/\nstatic int runargs (lua_State *L, char **argv, int n) {\n  int i;\n  for (i = 1; i < n; i++) {\n    int option = argv[i][1];\n    lua_assert(argv[i][0] == '-');  /* already checked */\n    switch (option) {\n      case 'e':  case 'l': {\n        int status;\n        char *extra = argv[i] + 2;  /* both options need an argument */\n        if (*extra == '\\0') extra = argv[++i];\n        lua_assert(extra != NULL);\n        status = (option == 'e')\n                 ? dostring(L, extra, \"=(command line)\")\n                 : dolibrary(L, extra);\n        if (status != LUA_OK) return 0;\n        break;\n      }\n      case 'W':\n        lua_warning(L, \"@on\", 0);  /* warnings on */\n        break;\n    }\n  }\n  return 1;\n}\n\n\nstatic int handle_luainit (lua_State *L) {\n  const char *name = \"=\" LUA_INITVARVERSION;\n  const char *init = getenv(name + 1);\n  if (init == NULL) {\n    name = \"=\" LUA_INIT_VAR;\n    init = getenv(name + 1);  /* try alternative name */\n  }\n  if (init == NULL) return LUA_OK;\n  else if (init[0] == '@')\n    return dofile(L, init+1);\n  else\n    return dostring(L, init, name);\n}\n\n\n/*\n** {==================================================================\n** Read-Eval-Print Loop (REPL)\n** ===================================================================\n*/\n\n#if !defined(LUA_PROMPT)\n#define LUA_PROMPT\t\t\"> \"\n#define LUA_PROMPT2\t\t\">> \"\n#endif\n\n#if !defined(LUA_MAXINPUT)\n#define LUA_MAXINPUT\t\t512\n#endif\n\n\n/*\n** lua_stdin_is_tty detects whether the standard input is a 'tty' (that\n** is, whether we're running lua interactively).\n*/\n#if !defined(lua_stdin_is_tty)\t/* { */\n\n#if defined(LUA_USE_POSIX)\t/* { */\n\n#include <unistd.h>\n#define lua_stdin_is_tty()\tisatty(0)\n\n#elif defined(LUA_USE_WINDOWS)\t/* }{ */\n\n#include <io.h>\n#include <windows.h>\n\n#define lua_stdin_is_tty()\t_isatty(_fileno(stdin))\n\n#else\t\t\t\t/* }{ */\n\n/* ISO C definition */\n#define lua_stdin_is_tty()\t1  /* assume stdin is a tty */\n\n#endif\t\t\t\t/* } */\n\n#endif\t\t\t\t/* } */\n\n\n/*\n** lua_readline defines how to show a prompt and then read a line from\n** the standard input.\n** lua_saveline defines how to \"save\" a read line in a \"history\".\n** lua_freeline defines how to free a line read by lua_readline.\n*/\n\n#if defined(LUA_USE_READLINE)\n\n#include <readline/readline.h>\n#include <readline/history.h>\n#define lua_initreadline(L)\t((void)L, rl_readline_name=\"lua\")\n#define lua_readline(b,p)\t((void)b, readline(p))\n#define lua_saveline(line)\tadd_history(line)\n#define lua_freeline(b)\t\tfree(b)\n\n#endif\n\n\n#if !defined(lua_readline)\t/* { */\n\n/* pointer to dynamically loaded 'readline' function (if any) */\ntypedef char *(*l_readline_t) (const char *prompt);\nstatic l_readline_t l_readline = NULL;\n\nstatic char *lua_readline (char *buff, const char *prompt) {\n  if (l_readline != NULL)  /* is there a dynamic 'readline'? */\n    return (*l_readline)(prompt);  /* use it */\n  else {  /* emulate 'readline' over 'buff' */\n    fputs(prompt, stdout);\n    fflush(stdout);  /* show prompt */\n    return fgets(buff, LUA_MAXINPUT, stdin);  /* read line */\n  }\n}\n\n\n/* pointer to dynamically loaded 'add_history' function (if any) */\ntypedef void (*l_addhist_t) (const char *string);\nstatic l_addhist_t l_addhist = NULL;\n\nstatic void lua_saveline (const char *line) {\n  if (l_addhist != NULL)  /* is there a dynamic 'add_history'? */\n    (*l_addhist)(line);  /* use it */\n  /* else nothing to be done */\n}\n\n\nstatic void lua_freeline (char *line) {\n  if (l_readline != NULL)  /* is there a dynamic 'readline'? */\n    free(line);  /* free line created by it */\n  /* else 'lua_readline' used an automatic buffer; nothing to free */\n}\n\n\n#if !defined(LUA_USE_DLOPEN) || !defined(LUA_READLINELIB)\n\n#define lua_initreadline(L)  ((void)L)\n\n#else /* { */\n\n#include <dlfcn.h>\n\n\nstatic void lua_initreadline (lua_State *L) {\n  void *lib = dlopen(LUA_READLINELIB, RTLD_NOW | RTLD_LOCAL);\n  if (lib == NULL)\n    lua_warning(L, \"library '\" LUA_READLINELIB \"'not found\", 0);\n  else {\n    const char **name = cast(const char**, dlsym(lib, \"rl_readline_name\"));\n    if (name != NULL)\n      *name = \"Lua\";\n    l_readline = cast(l_readline_t, cast_func(dlsym(lib, \"readline\")));\n    if (l_readline == NULL)\n      lua_warning(L, \"unable to load 'readline'\", 0);\n    else\n      l_addhist = cast(l_addhist_t, cast_func(dlsym(lib, \"add_history\")));\n  }\n}\n\n#endif\t/* } */\n\n#endif\t\t\t\t/* } */\n\n\n/*\n** Return the string to be used as a prompt by the interpreter. Leave\n** the string (or nil, if using the default value) on the stack, to keep\n** it anchored.\n*/\nstatic const char *get_prompt (lua_State *L, int firstline) {\n  if (lua_getglobal(L, firstline ? \"_PROMPT\" : \"_PROMPT2\") == LUA_TNIL)\n    return (firstline ? LUA_PROMPT : LUA_PROMPT2);  /* use the default */\n  else {  /* apply 'tostring' over the value */\n    const char *p = luaL_tolstring(L, -1, NULL);\n    lua_remove(L, -2);  /* remove original value */\n    return p;\n  }\n}\n\n/* mark in error messages for incomplete statements */\n#define EOFMARK\t\t\"<eof>\"\n#define marklen\t\t(sizeof(EOFMARK)/sizeof(char) - 1)\n\n\n/*\n** Check whether 'status' signals a syntax error and the error\n** message at the top of the stack ends with the above mark for\n** incomplete statements.\n*/\nstatic int incomplete (lua_State *L, int status) {\n  if (status == LUA_ERRSYNTAX) {\n    size_t lmsg;\n    const char *msg = lua_tolstring(L, -1, &lmsg);\n    if (lmsg >= marklen && strcmp(msg + lmsg - marklen, EOFMARK) == 0)\n      return 1;\n  }\n  return 0;  /* else... */\n}\n\n\n/*\n** Prompt the user, read a line, and push it into the Lua stack.\n*/\nstatic int pushline (lua_State *L, int firstline) {\n  char buffer[LUA_MAXINPUT];\n  size_t l;\n  const char *prmt = get_prompt(L, firstline);\n  char *b = lua_readline(buffer, prmt);\n  lua_pop(L, 1);  /* remove prompt */\n  if (b == NULL)\n    return 0;  /* no input */\n  l = strlen(b);\n  if (l > 0 && b[l-1] == '\\n')  /* line ends with newline? */\n    b[--l] = '\\0';  /* remove it */\n  lua_pushlstring(L, b, l);\n  lua_freeline(b);\n  return 1;\n}\n\n\n/*\n** Try to compile line on the stack as 'return <line>;'; on return, stack\n** has either compiled chunk or original line (if compilation failed).\n*/\nstatic int addreturn (lua_State *L) {\n  const char *line = lua_tostring(L, -1);  /* original line */\n  const char *retline = lua_pushfstring(L, \"return %s;\", line);\n  int status = luaL_loadbuffer(L, retline, strlen(retline), \"=stdin\");\n  if (status == LUA_OK)\n    lua_remove(L, -2);  /* remove modified line */\n  else\n    lua_pop(L, 2);  /* pop result from 'luaL_loadbuffer' and modified line */\n  return status;\n}\n\n\nstatic void checklocal (const char *line) {\n  static const size_t szloc = sizeof(\"local\") - 1;\n  static const char space[] = \" \\t\";\n  line += strspn(line, space);  /* skip spaces */\n  if (strncmp(line, \"local\", szloc) == 0 &&  /* \"local\"? */\n      strchr(space, *(line + szloc)) != NULL) {  /* followed by a space? */\n    lua_writestringerror(\"%s\\n\",\n      \"warning: locals do not survive across lines in interactive mode\");\n  }\n}\n\n\n/*\n** Read multiple lines until a complete Lua statement or an error not\n** for an incomplete statement. Start with first line already read in\n** the stack.\n*/\nstatic int multiline (lua_State *L) {\n  size_t len;\n  const char *line = lua_tolstring(L, 1, &len);  /* get first line */\n  checklocal(line);\n  for (;;) {  /* repeat until gets a complete statement */\n    int status = luaL_loadbuffer(L, line, len, \"=stdin\");  /* try it */\n    if (!incomplete(L, status) || !pushline(L, 0))\n      return status;  /* should not or cannot try to add continuation line */\n    lua_remove(L, -2);  /* remove error message (from incomplete line) */\n    lua_pushliteral(L, \"\\n\");  /* add newline... */\n    lua_insert(L, -2);  /* ...between the two lines */\n    lua_concat(L, 3);  /* join them */\n    line = lua_tolstring(L, 1, &len);  /* get what is has */\n  }\n}\n\n\n/*\n** Read a line and try to load (compile) it first as an expression (by\n** adding \"return \" in front of it) and second as a statement. Return\n** the final status of load/call with the resulting function (if any)\n** in the top of the stack.\n*/\nstatic int loadline (lua_State *L) {\n  const char *line;\n  int status;\n  lua_settop(L, 0);\n  if (!pushline(L, 1))\n    return -1;  /* no input */\n  if ((status = addreturn(L)) != LUA_OK)  /* 'return ...' did not work? */\n    status = multiline(L);  /* try as command, maybe with continuation lines */\n  line = lua_tostring(L, 1);\n  if (line[0] != '\\0')  /* non empty? */\n    lua_saveline(line);  /* keep history */\n  lua_remove(L, 1);  /* remove line from the stack */\n  lua_assert(lua_gettop(L) == 1);\n  return status;\n}\n\n\n/*\n** Prints (calling the Lua 'print' function) any values on the stack\n*/\nstatic void l_print (lua_State *L) {\n  int n = lua_gettop(L);\n  if (n > 0) {  /* any result to be printed? */\n    luaL_checkstack(L, LUA_MINSTACK, \"too many results to print\");\n    lua_getglobal(L, \"print\");\n    lua_insert(L, 1);\n    if (lua_pcall(L, n, 0, 0) != LUA_OK)\n      l_message(progname, lua_pushfstring(L, \"error calling 'print' (%s)\",\n                                             lua_tostring(L, -1)));\n  }\n}\n\n\n/*\n** Do the REPL: repeatedly read (load) a line, evaluate (call) it, and\n** print any results.\n*/\nstatic void doREPL (lua_State *L) {\n  int status;\n  const char *oldprogname = progname;\n  progname = NULL;  /* no 'progname' on errors in interactive mode */\n  lua_initreadline(L);\n  while ((status = loadline(L)) != -1) {\n    if (status == LUA_OK)\n      status = docall(L, 0, LUA_MULTRET);\n    if (status == LUA_OK) l_print(L);\n    else report(L, status);\n  }\n  lua_settop(L, 0);  /* clear stack */\n  lua_writeline();\n  progname = oldprogname;\n}\n\n/* }================================================================== */\n\n#if !defined(luai_openlibs)\n#define luai_openlibs(L)\tluaL_openselectedlibs(L, ~0, 0)\n#endif\n\n\n/*\n** Main body of stand-alone interpreter (to be called in protected mode).\n** Reads the options and handles them all.\n*/\nstatic int pmain (lua_State *L) {\n  int argc = (int)lua_tointeger(L, 1);\n  char **argv = (char **)lua_touserdata(L, 2);\n  int script;\n  int args = collectargs(argv, &script);\n  int optlim = (script > 0) ? script : argc; /* first argv not an option */\n  luaL_checkversion(L);  /* check that interpreter has correct version */\n  if (args == has_error) {  /* bad arg? */\n    print_usage(argv[script]);  /* 'script' has index of bad arg. */\n    return 0;\n  }\n  if (args & has_v)  /* option '-v'? */\n    print_version();\n  if (args & has_E) {  /* option '-E'? */\n    lua_pushboolean(L, 1);  /* signal for libraries to ignore env. vars. */\n    lua_setfield(L, LUA_REGISTRYINDEX, \"LUA_NOENV\");\n  }\n  luai_openlibs(L);  /* open standard libraries */\n  createargtable(L, argv, argc, script);  /* create table 'arg' */\n  lua_gc(L, LUA_GCRESTART);  /* start GC... */\n  lua_gc(L, LUA_GCGEN);  /* ...in generational mode */\n  if (!(args & has_E)) {  /* no option '-E'? */\n    if (handle_luainit(L) != LUA_OK)  /* run LUA_INIT */\n      return 0;  /* error running LUA_INIT */\n  }\n  if (!runargs(L, argv, optlim))  /* execute arguments -e and -l */\n    return 0;  /* something failed */\n  if (script > 0) {  /* execute main script (if there is one) */\n    if (handle_script(L, argv + script) != LUA_OK)\n      return 0;  /* interrupt in case of error */\n  }\n  if (args & has_i)  /* -i option? */\n    doREPL(L);  /* do read-eval-print loop */\n  else if (script < 1 && !(args & (has_e | has_v))) { /* no active option? */\n    if (lua_stdin_is_tty()) {  /* running in interactive mode? */\n      print_version();\n      doREPL(L);  /* do read-eval-print loop */\n    }\n    else dofile(L, NULL);  /* executes stdin as a file */\n  }\n  lua_pushboolean(L, 1);  /* signal no errors */\n  return 1;\n}\n\n\nint main (int argc, char **argv) {\n  int status, result;\n  lua_State *L = luaL_newstate();  /* create state */\n  if (L == NULL) {\n    l_message(argv[0], \"cannot create state: not enough memory\");\n    return EXIT_FAILURE;\n  }\n  lua_gc(L, LUA_GCSTOP);  /* stop GC while building state */\n  lua_pushcfunction(L, &pmain);  /* to call 'pmain' in protected mode */\n  lua_pushinteger(L, argc);  /* 1st argument */\n  lua_pushlightuserdata(L, argv); /* 2nd argument */\n  status = lua_pcall(L, 2, 1, 0);  /* do the call */\n  result = lua_toboolean(L, -1);  /* get result */\n  report(L, status);\n  lua_close(L);\n  return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n\n"
        },
        {
          "name": "lua.h",
          "type": "blob",
          "size": 16.5263671875,
          "content": "/*\n** $Id: lua.h $\n** Lua - A Scripting Language\n** Lua.org, PUC-Rio, Brazil (www.lua.org)\n** See Copyright Notice at the end of this file\n*/\n\n\n#ifndef lua_h\n#define lua_h\n\n#include <stdarg.h>\n#include <stddef.h>\n\n\n#define LUA_COPYRIGHT\tLUA_RELEASE \"  Copyright (C) 1994-2024 Lua.org, PUC-Rio\"\n#define LUA_AUTHORS\t\"R. Ierusalimschy, L. H. de Figueiredo, W. Celes\"\n\n\n#define LUA_VERSION_MAJOR_N\t5\n#define LUA_VERSION_MINOR_N\t5\n#define LUA_VERSION_RELEASE_N\t0\n\n#define LUA_VERSION_NUM  (LUA_VERSION_MAJOR_N * 100 + LUA_VERSION_MINOR_N)\n#define LUA_VERSION_RELEASE_NUM  (LUA_VERSION_NUM * 100 + LUA_VERSION_RELEASE_N)\n\n\n#include \"luaconf.h\"\n\n\n/* mark for precompiled code ('<esc>Lua') */\n#define LUA_SIGNATURE\t\"\\x1bLua\"\n\n/* option for multiple returns in 'lua_pcall' and 'lua_call' */\n#define LUA_MULTRET\t(-1)\n\n\n/*\n** Pseudo-indices\n** (-LUAI_MAXSTACK is the minimum valid index; we keep some free empty\n** space after that to help overflow detection)\n*/\n#define LUA_REGISTRYINDEX\t(-LUAI_MAXSTACK - 1000)\n#define lua_upvalueindex(i)\t(LUA_REGISTRYINDEX - (i))\n\n\n/* thread status */\n#define LUA_OK\t\t0\n#define LUA_YIELD\t1\n#define LUA_ERRRUN\t2\n#define LUA_ERRSYNTAX\t3\n#define LUA_ERRMEM\t4\n#define LUA_ERRERR\t5\n\n\ntypedef struct lua_State lua_State;\n\n\n/*\n** basic types\n*/\n#define LUA_TNONE\t\t(-1)\n\n#define LUA_TNIL\t\t0\n#define LUA_TBOOLEAN\t\t1\n#define LUA_TLIGHTUSERDATA\t2\n#define LUA_TNUMBER\t\t3\n#define LUA_TSTRING\t\t4\n#define LUA_TTABLE\t\t5\n#define LUA_TFUNCTION\t\t6\n#define LUA_TUSERDATA\t\t7\n#define LUA_TTHREAD\t\t8\n\n#define LUA_NUMTYPES\t\t9\n\n\n\n/* minimum Lua stack available to a C function */\n#define LUA_MINSTACK\t20\n\n\n/* predefined values in the registry */\n/* index 1 is reserved for the reference mechanism */\n#define LUA_RIDX_GLOBALS\t2\n#define LUA_RIDX_MAINTHREAD\t3\n#define LUA_RIDX_LAST\t\t3\n\n\n/* type of numbers in Lua */\ntypedef LUA_NUMBER lua_Number;\n\n\n/* type for integer functions */\ntypedef LUA_INTEGER lua_Integer;\n\n/* unsigned integer type */\ntypedef LUA_UNSIGNED lua_Unsigned;\n\n/* type for continuation-function contexts */\ntypedef LUA_KCONTEXT lua_KContext;\n\n\n/*\n** Type for C functions registered with Lua\n*/\ntypedef int (*lua_CFunction) (lua_State *L);\n\n/*\n** Type for continuation functions\n*/\ntypedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);\n\n\n/*\n** Type for functions that read/write blocks when loading/dumping Lua chunks\n*/\ntypedef const char * (*lua_Reader) (lua_State *L, void *ud, size_t *sz);\n\ntypedef int (*lua_Writer) (lua_State *L, const void *p, size_t sz, void *ud);\n\n\n/*\n** Type for memory-allocation functions\n*/\ntypedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);\n\n\n/*\n** Type for warning functions\n*/\ntypedef void (*lua_WarnFunction) (void *ud, const char *msg, int tocont);\n\n\n/*\n** Type used by the debug API to collect debug information\n*/\ntypedef struct lua_Debug lua_Debug;\n\n\n/*\n** Functions to be called by the debugger in specific events\n*/\ntypedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);\n\n\n/*\n** generic extra include file\n*/\n#if defined(LUA_USER_H)\n#include LUA_USER_H\n#endif\n\n\n/*\n** RCS ident string\n*/\nextern const char lua_ident[];\n\n\n/*\n** state manipulation\n*/\nLUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud, unsigned seed);\nLUA_API void       (lua_close) (lua_State *L);\nLUA_API lua_State *(lua_newthread) (lua_State *L);\nLUA_API int        (lua_closethread) (lua_State *L, lua_State *from);\n\nLUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);\n\n\nLUA_API lua_Number (lua_version) (lua_State *L);\n\n\n/*\n** basic stack manipulation\n*/\nLUA_API int   (lua_absindex) (lua_State *L, int idx);\nLUA_API int   (lua_gettop) (lua_State *L);\nLUA_API void  (lua_settop) (lua_State *L, int idx);\nLUA_API void  (lua_pushvalue) (lua_State *L, int idx);\nLUA_API void  (lua_rotate) (lua_State *L, int idx, int n);\nLUA_API void  (lua_copy) (lua_State *L, int fromidx, int toidx);\nLUA_API int   (lua_checkstack) (lua_State *L, int n);\n\nLUA_API void  (lua_xmove) (lua_State *from, lua_State *to, int n);\n\n\n/*\n** access functions (stack -> C)\n*/\n\nLUA_API int             (lua_isnumber) (lua_State *L, int idx);\nLUA_API int             (lua_isstring) (lua_State *L, int idx);\nLUA_API int             (lua_iscfunction) (lua_State *L, int idx);\nLUA_API int             (lua_isinteger) (lua_State *L, int idx);\nLUA_API int             (lua_isuserdata) (lua_State *L, int idx);\nLUA_API int             (lua_type) (lua_State *L, int idx);\nLUA_API const char     *(lua_typename) (lua_State *L, int tp);\n\nLUA_API lua_Number      (lua_tonumberx) (lua_State *L, int idx, int *isnum);\nLUA_API lua_Integer     (lua_tointegerx) (lua_State *L, int idx, int *isnum);\nLUA_API int             (lua_toboolean) (lua_State *L, int idx);\nLUA_API const char     *(lua_tolstring) (lua_State *L, int idx, size_t *len);\nLUA_API lua_Unsigned    (lua_rawlen) (lua_State *L, int idx);\nLUA_API lua_CFunction   (lua_tocfunction) (lua_State *L, int idx);\nLUA_API void\t       *(lua_touserdata) (lua_State *L, int idx);\nLUA_API lua_State      *(lua_tothread) (lua_State *L, int idx);\nLUA_API const void     *(lua_topointer) (lua_State *L, int idx);\n\n\n/*\n** Comparison and arithmetic functions\n*/\n\n#define LUA_OPADD\t0\t/* ORDER TM, ORDER OP */\n#define LUA_OPSUB\t1\n#define LUA_OPMUL\t2\n#define LUA_OPMOD\t3\n#define LUA_OPPOW\t4\n#define LUA_OPDIV\t5\n#define LUA_OPIDIV\t6\n#define LUA_OPBAND\t7\n#define LUA_OPBOR\t8\n#define LUA_OPBXOR\t9\n#define LUA_OPSHL\t10\n#define LUA_OPSHR\t11\n#define LUA_OPUNM\t12\n#define LUA_OPBNOT\t13\n\nLUA_API void  (lua_arith) (lua_State *L, int op);\n\n#define LUA_OPEQ\t0\n#define LUA_OPLT\t1\n#define LUA_OPLE\t2\n\nLUA_API int   (lua_rawequal) (lua_State *L, int idx1, int idx2);\nLUA_API int   (lua_compare) (lua_State *L, int idx1, int idx2, int op);\n\n\n/*\n** push functions (C -> stack)\n*/\nLUA_API void        (lua_pushnil) (lua_State *L);\nLUA_API void        (lua_pushnumber) (lua_State *L, lua_Number n);\nLUA_API void        (lua_pushinteger) (lua_State *L, lua_Integer n);\nLUA_API const char *(lua_pushlstring) (lua_State *L, const char *s, size_t len);\nLUA_API const char *(lua_pushextlstring) (lua_State *L,\n\t\tconst char *s, size_t len, lua_Alloc falloc, void *ud);\nLUA_API const char *(lua_pushstring) (lua_State *L, const char *s);\nLUA_API const char *(lua_pushvfstring) (lua_State *L, const char *fmt,\n                                                      va_list argp);\nLUA_API const char *(lua_pushfstring) (lua_State *L, const char *fmt, ...);\nLUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);\nLUA_API void  (lua_pushboolean) (lua_State *L, int b);\nLUA_API void  (lua_pushlightuserdata) (lua_State *L, void *p);\nLUA_API int   (lua_pushthread) (lua_State *L);\n\n\n/*\n** get functions (Lua -> stack)\n*/\nLUA_API int (lua_getglobal) (lua_State *L, const char *name);\nLUA_API int (lua_gettable) (lua_State *L, int idx);\nLUA_API int (lua_getfield) (lua_State *L, int idx, const char *k);\nLUA_API int (lua_geti) (lua_State *L, int idx, lua_Integer n);\nLUA_API int (lua_rawget) (lua_State *L, int idx);\nLUA_API int (lua_rawgeti) (lua_State *L, int idx, lua_Integer n);\nLUA_API int (lua_rawgetp) (lua_State *L, int idx, const void *p);\n\nLUA_API void  (lua_createtable) (lua_State *L, unsigned narr, unsigned nrec);\nLUA_API void *(lua_newuserdatauv) (lua_State *L, size_t sz, int nuvalue);\nLUA_API int   (lua_getmetatable) (lua_State *L, int objindex);\nLUA_API int  (lua_getiuservalue) (lua_State *L, int idx, int n);\n\n\n/*\n** set functions (stack -> Lua)\n*/\nLUA_API void  (lua_setglobal) (lua_State *L, const char *name);\nLUA_API void  (lua_settable) (lua_State *L, int idx);\nLUA_API void  (lua_setfield) (lua_State *L, int idx, const char *k);\nLUA_API void  (lua_seti) (lua_State *L, int idx, lua_Integer n);\nLUA_API void  (lua_rawset) (lua_State *L, int idx);\nLUA_API void  (lua_rawseti) (lua_State *L, int idx, lua_Integer n);\nLUA_API void  (lua_rawsetp) (lua_State *L, int idx, const void *p);\nLUA_API int   (lua_setmetatable) (lua_State *L, int objindex);\nLUA_API int   (lua_setiuservalue) (lua_State *L, int idx, int n);\n\n\n/*\n** 'load' and 'call' functions (load and run Lua code)\n*/\nLUA_API void  (lua_callk) (lua_State *L, int nargs, int nresults,\n                           lua_KContext ctx, lua_KFunction k);\n#define lua_call(L,n,r)\t\tlua_callk(L, (n), (r), 0, NULL)\n\nLUA_API int   (lua_pcallk) (lua_State *L, int nargs, int nresults, int errfunc,\n                            lua_KContext ctx, lua_KFunction k);\n#define lua_pcall(L,n,r,f)\tlua_pcallk(L, (n), (r), (f), 0, NULL)\n\nLUA_API int   (lua_load) (lua_State *L, lua_Reader reader, void *dt,\n                          const char *chunkname, const char *mode);\n\nLUA_API int (lua_dump) (lua_State *L, lua_Writer writer, void *data, int strip);\n\n\n/*\n** coroutine functions\n*/\nLUA_API int  (lua_yieldk)     (lua_State *L, int nresults, lua_KContext ctx,\n                               lua_KFunction k);\nLUA_API int  (lua_resume)     (lua_State *L, lua_State *from, int narg,\n                               int *nres);\nLUA_API int  (lua_status)     (lua_State *L);\nLUA_API int (lua_isyieldable) (lua_State *L);\n\n#define lua_yield(L,n)\t\tlua_yieldk(L, (n), 0, NULL)\n\n\n/*\n** Warning-related functions\n*/\nLUA_API void (lua_setwarnf) (lua_State *L, lua_WarnFunction f, void *ud);\nLUA_API void (lua_warning)  (lua_State *L, const char *msg, int tocont);\n\n\n/*\n** garbage-collection options\n*/\n\n#define LUA_GCSTOP\t\t0\n#define LUA_GCRESTART\t\t1\n#define LUA_GCCOLLECT\t\t2\n#define LUA_GCCOUNT\t\t3\n#define LUA_GCCOUNTB\t\t4\n#define LUA_GCSTEP\t\t5\n#define LUA_GCISRUNNING\t\t6\n#define LUA_GCGEN\t\t7\n#define LUA_GCINC\t\t8\n#define LUA_GCPARAM\t\t9\n\n\n/*\n** garbage-collection parameters\n*/\n/* parameters for generational mode */\n#define LUA_GCPMINORMUL\t\t0  /* control minor collections */\n#define LUA_GCPMAJORMINOR\t1  /* control shift major->minor */\n#define LUA_GCPMINORMAJOR\t2  /* control shift minor->major */\n\n/* parameters for incremental mode */\n#define LUA_GCPPAUSE\t\t3  /* size of pause between successive GCs */\n#define LUA_GCPSTEPMUL\t\t4  /* GC \"speed\" */\n#define LUA_GCPSTEPSIZE\t\t5  /* GC granularity */\n\n/* number of parameters */\n#define LUA_GCPN\t\t6\n\n\nLUA_API int (lua_gc) (lua_State *L, int what, ...);\n\n\n/*\n** miscellaneous functions\n*/\n\nLUA_API int   (lua_error) (lua_State *L);\n\nLUA_API int   (lua_next) (lua_State *L, int idx);\n\nLUA_API void  (lua_concat) (lua_State *L, int n);\nLUA_API void  (lua_len)    (lua_State *L, int idx);\n\n#define LUA_N2SBUFFSZ\t64\nLUA_API unsigned  (lua_numbertostrbuff) (lua_State *L, int idx, char *buff);\nLUA_API size_t  (lua_stringtonumber) (lua_State *L, const char *s);\n\nLUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);\nLUA_API void      (lua_setallocf) (lua_State *L, lua_Alloc f, void *ud);\n\nLUA_API void (lua_toclose) (lua_State *L, int idx);\nLUA_API void (lua_closeslot) (lua_State *L, int idx);\n\n\n/*\n** {==============================================================\n** some useful macros\n** ===============================================================\n*/\n\n#define lua_getextraspace(L)\t((void *)((char *)(L) - LUA_EXTRASPACE))\n\n#define lua_tonumber(L,i)\tlua_tonumberx(L,(i),NULL)\n#define lua_tointeger(L,i)\tlua_tointegerx(L,(i),NULL)\n\n#define lua_pop(L,n)\t\tlua_settop(L, -(n)-1)\n\n#define lua_newtable(L)\t\tlua_createtable(L, 0, 0)\n\n#define lua_register(L,n,f) (lua_pushcfunction(L, (f)), lua_setglobal(L, (n)))\n\n#define lua_pushcfunction(L,f)\tlua_pushcclosure(L, (f), 0)\n\n#define lua_isfunction(L,n)\t(lua_type(L, (n)) == LUA_TFUNCTION)\n#define lua_istable(L,n)\t(lua_type(L, (n)) == LUA_TTABLE)\n#define lua_islightuserdata(L,n)\t(lua_type(L, (n)) == LUA_TLIGHTUSERDATA)\n#define lua_isnil(L,n)\t\t(lua_type(L, (n)) == LUA_TNIL)\n#define lua_isboolean(L,n)\t(lua_type(L, (n)) == LUA_TBOOLEAN)\n#define lua_isthread(L,n)\t(lua_type(L, (n)) == LUA_TTHREAD)\n#define lua_isnone(L,n)\t\t(lua_type(L, (n)) == LUA_TNONE)\n#define lua_isnoneornil(L, n)\t(lua_type(L, (n)) <= 0)\n\n#define lua_pushliteral(L, s)\tlua_pushstring(L, \"\" s)\n\n#define lua_pushglobaltable(L)  \\\n\t((void)lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS))\n\n#define lua_tostring(L,i)\tlua_tolstring(L, (i), NULL)\n\n\n#define lua_insert(L,idx)\tlua_rotate(L, (idx), 1)\n\n#define lua_remove(L,idx)\t(lua_rotate(L, (idx), -1), lua_pop(L, 1))\n\n#define lua_replace(L,idx)\t(lua_copy(L, -1, (idx)), lua_pop(L, 1))\n\n/* }============================================================== */\n\n\n/*\n** {==============================================================\n** compatibility macros\n** ===============================================================\n*/\n#if defined(LUA_COMPAT_APIINTCASTS)\n\n#define lua_pushunsigned(L,n)\tlua_pushinteger(L, (lua_Integer)(n))\n#define lua_tounsignedx(L,i,is)\t((lua_Unsigned)lua_tointegerx(L,i,is))\n#define lua_tounsigned(L,i)\tlua_tounsignedx(L,(i),NULL)\n\n#endif\n\n#define lua_newuserdata(L,s)\tlua_newuserdatauv(L,s,1)\n#define lua_getuservalue(L,idx)\tlua_getiuservalue(L,idx,1)\n#define lua_setuservalue(L,idx)\tlua_setiuservalue(L,idx,1)\n\n#define lua_resetthread(L)\tlua_closethread(L,NULL)\n\n/* }============================================================== */\n\n/*\n** {======================================================================\n** Debug API\n** =======================================================================\n*/\n\n\n/*\n** Event codes\n*/\n#define LUA_HOOKCALL\t0\n#define LUA_HOOKRET\t1\n#define LUA_HOOKLINE\t2\n#define LUA_HOOKCOUNT\t3\n#define LUA_HOOKTAILCALL 4\n\n\n/*\n** Event masks\n*/\n#define LUA_MASKCALL\t(1 << LUA_HOOKCALL)\n#define LUA_MASKRET\t(1 << LUA_HOOKRET)\n#define LUA_MASKLINE\t(1 << LUA_HOOKLINE)\n#define LUA_MASKCOUNT\t(1 << LUA_HOOKCOUNT)\n\n\nLUA_API int (lua_getstack) (lua_State *L, int level, lua_Debug *ar);\nLUA_API int (lua_getinfo) (lua_State *L, const char *what, lua_Debug *ar);\nLUA_API const char *(lua_getlocal) (lua_State *L, const lua_Debug *ar, int n);\nLUA_API const char *(lua_setlocal) (lua_State *L, const lua_Debug *ar, int n);\nLUA_API const char *(lua_getupvalue) (lua_State *L, int funcindex, int n);\nLUA_API const char *(lua_setupvalue) (lua_State *L, int funcindex, int n);\n\nLUA_API void *(lua_upvalueid) (lua_State *L, int fidx, int n);\nLUA_API void  (lua_upvaluejoin) (lua_State *L, int fidx1, int n1,\n                                               int fidx2, int n2);\n\nLUA_API void (lua_sethook) (lua_State *L, lua_Hook func, int mask, int count);\nLUA_API lua_Hook (lua_gethook) (lua_State *L);\nLUA_API int (lua_gethookmask) (lua_State *L);\nLUA_API int (lua_gethookcount) (lua_State *L);\n\n\nstruct lua_Debug {\n  int event;\n  const char *name;\t/* (n) */\n  const char *namewhat;\t/* (n) 'global', 'local', 'field', 'method' */\n  const char *what;\t/* (S) 'Lua', 'C', 'main', 'tail' */\n  const char *source;\t/* (S) */\n  size_t srclen;\t/* (S) */\n  int currentline;\t/* (l) */\n  int linedefined;\t/* (S) */\n  int lastlinedefined;\t/* (S) */\n  unsigned char nups;\t/* (u) number of upvalues */\n  unsigned char nparams;/* (u) number of parameters */\n  char isvararg;        /* (u) */\n  unsigned char extraargs;  /* (t) number of extra arguments */\n  char istailcall;\t/* (t) */\n  int ftransfer;   /* (r) index of first value transferred */\n  int ntransfer;   /* (r) number of transferred values */\n  char short_src[LUA_IDSIZE]; /* (S) */\n  /* private part */\n  struct CallInfo *i_ci;  /* active function */\n};\n\n/* }====================================================================== */\n\n\n#define LUAI_TOSTRAUX(x)\t#x\n#define LUAI_TOSTR(x)\t\tLUAI_TOSTRAUX(x)\n\n#define LUA_VERSION_MAJOR\tLUAI_TOSTR(LUA_VERSION_MAJOR_N)\n#define LUA_VERSION_MINOR\tLUAI_TOSTR(LUA_VERSION_MINOR_N)\n#define LUA_VERSION_RELEASE\tLUAI_TOSTR(LUA_VERSION_RELEASE_N)\n\n#define LUA_VERSION\t\"Lua \" LUA_VERSION_MAJOR \".\" LUA_VERSION_MINOR\n#define LUA_RELEASE\tLUA_VERSION \".\" LUA_VERSION_RELEASE\n\n\n/******************************************************************************\n* Copyright (C) 1994-2024 Lua.org, PUC-Rio.\n*\n* Permission is hereby granted, free of charge, to any person obtaining\n* a copy of this software and associated documentation files (the\n* \"Software\"), to deal in the Software without restriction, including\n* without limitation the rights to use, copy, modify, merge, publish,\n* distribute, sublicense, and/or sell copies of the Software, and to\n* permit persons to whom the Software is furnished to do so, subject to\n* the following conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n******************************************************************************/\n\n\n#endif\n"
        },
        {
          "name": "luaconf.h",
          "type": "blob",
          "size": 22.0859375,
          "content": "/*\n** $Id: luaconf.h $\n** Configuration file for Lua\n** See Copyright Notice in lua.h\n*/\n\n\n#ifndef luaconf_h\n#define luaconf_h\n\n#include <limits.h>\n#include <stddef.h>\n\n\n/*\n** ===================================================================\n** General Configuration File for Lua\n**\n** Some definitions here can be changed externally, through the compiler\n** (e.g., with '-D' options): They are commented out or protected\n** by '#if !defined' guards. However, several other definitions\n** should be changed directly here, either because they affect the\n** Lua ABI (by making the changes here, you ensure that all software\n** connected to Lua, such as C libraries, will be compiled with the same\n** configuration); or because they are seldom changed.\n**\n** Search for \"@@\" to find all configurable definitions.\n** ===================================================================\n*/\n\n\n/*\n** {====================================================================\n** System Configuration: macros to adapt (if needed) Lua to some\n** particular platform, for instance restricting it to C89.\n** =====================================================================\n*/\n\n/*\n@@ LUA_USE_C89 controls the use of non-ISO-C89 features.\n** Define it if you want Lua to avoid the use of a few C99 features\n** or Windows-specific features on Windows.\n*/\n/* #define LUA_USE_C89 */\n\n\n/*\n** By default, Lua on Windows use (some) specific Windows features\n*/\n#if !defined(LUA_USE_C89) && defined(_WIN32) && !defined(_WIN32_WCE)\n#define LUA_USE_WINDOWS  /* enable goodies for regular Windows */\n#endif\n\n\n#if defined(LUA_USE_WINDOWS)\n#define LUA_DL_DLL\t/* enable support for DLL */\n#define LUA_USE_C89\t/* broadly, Windows is C89 */\n#endif\n\n\n/*\n** When Posix DLL ('LUA_USE_DLOPEN') is enabled, the Lua stand-alone\n** application will try to dynamically link a 'readline' facility\n** for its REPL.  In that case, LUA_READLINELIB is the name of the\n** library it will look for those facilities.  If lua.c cannot open\n** the specified library, it will generate a warning and then run\n** without 'readline'.  If that macro is not defined, lua.c will not\n** use 'readline'.\n*/\n#if defined(LUA_USE_LINUX)\n#define LUA_USE_POSIX\n#define LUA_USE_DLOPEN\t\t/* needs an extra library: -ldl */\n#define LUA_READLINELIB\t\t\"libreadline.so\"\n#endif\n\n\n#if defined(LUA_USE_MACOSX)\n#define LUA_USE_POSIX\n#define LUA_USE_DLOPEN\t\t/* MacOS does not need -ldl */\n#define LUA_READLINELIB\t\t\"libedit.dylib\"\n#endif\n\n\n#if defined(LUA_USE_IOS)\n#define LUA_USE_POSIX\n#define LUA_USE_DLOPEN\n#endif\n\n\n#if defined(LUA_USE_C89) && defined(LUA_USE_POSIX)\n#error \"Posix is not compatible with C89\"\n#endif\n\n\n/*\n@@ LUAI_IS32INT is true iff 'int' has (at least) 32 bits.\n*/\n#define LUAI_IS32INT\t((UINT_MAX >> 30) >= 3)\n\n/* }================================================================== */\n\n\n\n/*\n** {==================================================================\n** Configuration for Number types. These options should not be\n** set externally, because any other code connected to Lua must\n** use the same configuration.\n** ===================================================================\n*/\n\n/*\n@@ LUA_INT_TYPE defines the type for Lua integers.\n@@ LUA_FLOAT_TYPE defines the type for Lua floats.\n** Lua should work fine with any mix of these options supported\n** by your C compiler. The usual configurations are 64-bit integers\n** and 'double' (the default), 32-bit integers and 'float' (for\n** restricted platforms), and 'long'/'double' (for C compilers not\n** compliant with C99, which may not have support for 'long long').\n*/\n\n/* predefined options for LUA_INT_TYPE */\n#define LUA_INT_INT\t\t1\n#define LUA_INT_LONG\t\t2\n#define LUA_INT_LONGLONG\t3\n\n/* predefined options for LUA_FLOAT_TYPE */\n#define LUA_FLOAT_FLOAT\t\t1\n#define LUA_FLOAT_DOUBLE\t2\n#define LUA_FLOAT_LONGDOUBLE\t3\n\n\n/* Default configuration ('long long' and 'double', for 64-bit Lua) */\n#define LUA_INT_DEFAULT\t\tLUA_INT_LONGLONG\n#define LUA_FLOAT_DEFAULT\tLUA_FLOAT_DOUBLE\n\n\n/*\n@@ LUA_32BITS enables Lua with 32-bit integers and 32-bit floats.\n*/\n#define LUA_32BITS\t0\n\n\n/*\n@@ LUA_C89_NUMBERS ensures that Lua uses the largest types available for\n** C89 ('long' and 'double'); Windows always has '__int64', so it does\n** not need to use this case.\n*/\n#if defined(LUA_USE_C89) && !defined(LUA_USE_WINDOWS)\n#define LUA_C89_NUMBERS\t\t1\n#else\n#define LUA_C89_NUMBERS\t\t0\n#endif\n\n\n#if LUA_32BITS\t\t/* { */\n/*\n** 32-bit integers and 'float'\n*/\n#if LUAI_IS32INT  /* use 'int' if big enough */\n#define LUA_INT_TYPE\tLUA_INT_INT\n#else  /* otherwise use 'long' */\n#define LUA_INT_TYPE\tLUA_INT_LONG\n#endif\n#define LUA_FLOAT_TYPE\tLUA_FLOAT_FLOAT\n\n#elif LUA_C89_NUMBERS\t/* }{ */\n/*\n** largest types available for C89 ('long' and 'double')\n*/\n#define LUA_INT_TYPE\tLUA_INT_LONG\n#define LUA_FLOAT_TYPE\tLUA_FLOAT_DOUBLE\n\n#else\t\t/* }{ */\n/* use defaults */\n\n#define LUA_INT_TYPE\tLUA_INT_DEFAULT\n#define LUA_FLOAT_TYPE\tLUA_FLOAT_DEFAULT\n\n#endif\t\t\t\t/* } */\n\n\n/* }================================================================== */\n\n\n\n/*\n** {==================================================================\n** Configuration for Paths.\n** ===================================================================\n*/\n\n/*\n** LUA_PATH_SEP is the character that separates templates in a path.\n** LUA_PATH_MARK is the string that marks the substitution points in a\n** template.\n** LUA_EXEC_DIR in a Windows path is replaced by the executable's\n** directory.\n*/\n#define LUA_PATH_SEP            \";\"\n#define LUA_PATH_MARK           \"?\"\n#define LUA_EXEC_DIR            \"!\"\n\n\n/*\n@@ LUA_PATH_DEFAULT is the default path that Lua uses to look for\n** Lua libraries.\n@@ LUA_CPATH_DEFAULT is the default path that Lua uses to look for\n** C libraries.\n** CHANGE them if your machine has a non-conventional directory\n** hierarchy or if you want to install your libraries in\n** non-conventional directories.\n*/\n\n#define LUA_VDIR\tLUA_VERSION_MAJOR \".\" LUA_VERSION_MINOR\n#if defined(_WIN32)\t/* { */\n/*\n** In Windows, any exclamation mark ('!') in the path is replaced by the\n** path of the directory of the executable file of the current process.\n*/\n#define LUA_LDIR\t\"!\\\\lua\\\\\"\n#define LUA_CDIR\t\"!\\\\\"\n#define LUA_SHRDIR\t\"!\\\\..\\\\share\\\\lua\\\\\" LUA_VDIR \"\\\\\"\n\n#if !defined(LUA_PATH_DEFAULT)\n#define LUA_PATH_DEFAULT  \\\n\t\tLUA_LDIR\"?.lua;\"  LUA_LDIR\"?\\\\init.lua;\" \\\n\t\tLUA_CDIR\"?.lua;\"  LUA_CDIR\"?\\\\init.lua;\" \\\n\t\tLUA_SHRDIR\"?.lua;\" LUA_SHRDIR\"?\\\\init.lua;\" \\\n\t\t\".\\\\?.lua;\" \".\\\\?\\\\init.lua\"\n#endif\n\n#if !defined(LUA_CPATH_DEFAULT)\n#define LUA_CPATH_DEFAULT \\\n\t\tLUA_CDIR\"?.dll;\" \\\n\t\tLUA_CDIR\"..\\\\lib\\\\lua\\\\\" LUA_VDIR \"\\\\?.dll;\" \\\n\t\tLUA_CDIR\"loadall.dll;\" \".\\\\?.dll\"\n#endif\n\n#else\t\t\t/* }{ */\n\n#define LUA_ROOT\t\"/usr/local/\"\n#define LUA_LDIR\tLUA_ROOT \"share/lua/\" LUA_VDIR \"/\"\n#define LUA_CDIR\tLUA_ROOT \"lib/lua/\" LUA_VDIR \"/\"\n\n#if !defined(LUA_PATH_DEFAULT)\n#define LUA_PATH_DEFAULT  \\\n\t\tLUA_LDIR\"?.lua;\"  LUA_LDIR\"?/init.lua;\" \\\n\t\tLUA_CDIR\"?.lua;\"  LUA_CDIR\"?/init.lua;\" \\\n\t\t\"./?.lua;\" \"./?/init.lua\"\n#endif\n\n#if !defined(LUA_CPATH_DEFAULT)\n#define LUA_CPATH_DEFAULT \\\n\t\tLUA_CDIR\"?.so;\" LUA_CDIR\"loadall.so;\" \"./?.so\"\n#endif\n\n#endif\t\t\t/* } */\n\n\n/*\n@@ LUA_DIRSEP is the directory separator (for submodules).\n** CHANGE it if your machine does not use \"/\" as the directory separator\n** and is not Windows. (On Windows Lua automatically uses \"\\\".)\n*/\n#if !defined(LUA_DIRSEP)\n\n#if defined(_WIN32)\n#define LUA_DIRSEP\t\"\\\\\"\n#else\n#define LUA_DIRSEP\t\"/\"\n#endif\n\n#endif\n\n\n/*\n** LUA_IGMARK is a mark to ignore all after it when building the\n** module name (e.g., used to build the luaopen_ function name).\n** Typically, the suffix after the mark is the module version,\n** as in \"mod-v1.2.so\".\n*/\n#define LUA_IGMARK\t\t\"-\"\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Marks for exported symbols in the C code\n** ===================================================================\n*/\n\n/*\n@@ LUA_API is a mark for all core API functions.\n@@ LUALIB_API is a mark for all auxiliary library functions.\n@@ LUAMOD_API is a mark for all standard library opening functions.\n** CHANGE them if you need to define those functions in some special way.\n** For instance, if you want to create one Windows DLL with the core and\n** the libraries, you may want to use the following definition (define\n** LUA_BUILD_AS_DLL to get it).\n*/\n#if defined(LUA_BUILD_AS_DLL)\t/* { */\n\n#if defined(LUA_CORE) || defined(LUA_LIB)\t/* { */\n#define LUA_API __declspec(dllexport)\n#else\t\t\t\t\t\t/* }{ */\n#define LUA_API __declspec(dllimport)\n#endif\t\t\t\t\t\t/* } */\n\n#else\t\t\t\t/* }{ */\n\n#define LUA_API\t\textern\n\n#endif\t\t\t\t/* } */\n\n\n/*\n** More often than not the libs go together with the core.\n*/\n#define LUALIB_API\tLUA_API\n#define LUAMOD_API\tLUA_API\n\n\n/*\n@@ LUAI_FUNC is a mark for all extern functions that are not to be\n** exported to outside modules.\n@@ LUAI_DDEF and LUAI_DDEC are marks for all extern (const) variables,\n** none of which to be exported to outside modules (LUAI_DDEF for\n** definitions and LUAI_DDEC for declarations).\n** CHANGE them if you need to mark them in some special way. Elf/gcc\n** (versions 3.2 and later) mark them as \"hidden\" to optimize access\n** when Lua is compiled as a shared library. Not all elf targets support\n** this attribute. Unfortunately, gcc does not offer a way to check\n** whether the target offers that support, and those without support\n** give a warning about it. To avoid these warnings, change to the\n** default definition.\n*/\n#if defined(__GNUC__) && ((__GNUC__*100 + __GNUC_MINOR__) >= 302) && \\\n    defined(__ELF__)\t\t/* { */\n#define LUAI_FUNC\t__attribute__((visibility(\"internal\"))) extern\n#else\t\t\t\t/* }{ */\n#define LUAI_FUNC\textern\n#endif\t\t\t\t/* } */\n\n#define LUAI_DDEC(dec)\tLUAI_FUNC dec\n#define LUAI_DDEF\t/* empty */\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Compatibility with previous versions\n** ===================================================================\n*/\n\n/*\n@@ LUA_COMPAT_5_3 controls other macros for compatibility with Lua 5.3.\n** You can define it to get all options, or change specific options\n** to fit your specific needs.\n*/\n#if defined(LUA_COMPAT_5_3)\t/* { */\n\n/*\n@@ LUA_COMPAT_MATHLIB controls the presence of several deprecated\n** functions in the mathematical library.\n** (These functions were already officially removed in 5.3;\n** nevertheless they are still available here.)\n*/\n#define LUA_COMPAT_MATHLIB\n\n/*\n@@ LUA_COMPAT_APIINTCASTS controls the presence of macros for\n** manipulating other integer types (lua_pushunsigned, lua_tounsigned,\n** luaL_checkint, luaL_checklong, etc.)\n** (These macros were also officially removed in 5.3, but they are still\n** available here.)\n*/\n#define LUA_COMPAT_APIINTCASTS\n\n\n/*\n@@ LUA_COMPAT_LT_LE controls the emulation of the '__le' metamethod\n** using '__lt'.\n*/\n#define LUA_COMPAT_LT_LE\n\n\n/*\n@@ The following macros supply trivial compatibility for some\n** changes in the API. The macros themselves document how to\n** change your code to avoid using them.\n** (Once more, these macros were officially removed in 5.3, but they are\n** still available here.)\n*/\n#define lua_strlen(L,i)\t\tlua_rawlen(L, (i))\n\n#define lua_objlen(L,i)\t\tlua_rawlen(L, (i))\n\n#define lua_equal(L,idx1,idx2)\t\tlua_compare(L,(idx1),(idx2),LUA_OPEQ)\n#define lua_lessthan(L,idx1,idx2)\tlua_compare(L,(idx1),(idx2),LUA_OPLT)\n\n#endif\t\t\t\t/* } */\n\n/* }================================================================== */\n\n\n\n/*\n** {==================================================================\n** Configuration for Numbers (low-level part).\n** Change these definitions if no predefined LUA_FLOAT_* / LUA_INT_*\n** satisfy your needs.\n** ===================================================================\n*/\n\n/*\n@@ LUAI_UACNUMBER is the result of a 'default argument promotion'\n@@ over a floating number.\n@@ l_floatatt(x) corrects float attribute 'x' to the proper float type\n** by prefixing it with one of FLT/DBL/LDBL.\n@@ LUA_NUMBER_FRMLEN is the length modifier for writing floats.\n@@ LUA_NUMBER_FMT is the format for writing floats with the maximum\n** number of digits that respects tostring(tonumber(numeral)) == numeral.\n** (That would be floor(log10(2^n)), where n is the number of bits in\n** the float mantissa.)\n@@ LUA_NUMBER_FMT_N is the format for writing floats with the minimum\n** number of digits that ensures tonumber(tostring(number)) == number.\n** (That would be LUA_NUMBER_FMT+2.)\n@@ l_mathop allows the addition of an 'l' or 'f' to all math operations.\n@@ l_floor takes the floor of a float.\n@@ lua_str2number converts a decimal numeral to a number.\n*/\n\n\n/* The following definitions are good for most cases here */\n\n#define l_floor(x)\t\t(l_mathop(floor)(x))\n\n\n/*\n@@ lua_numbertointeger converts a float number with an integral value\n** to an integer, or returns 0 if float is not within the range of\n** a lua_Integer.  (The range comparisons are tricky because of\n** rounding. The tests here assume a two-complement representation,\n** where MININTEGER always has an exact representation as a float;\n** MAXINTEGER may not have one, and therefore its conversion to float\n** may have an ill-defined value.)\n*/\n#define lua_numbertointeger(n,p) \\\n  ((n) >= (LUA_NUMBER)(LUA_MININTEGER) && \\\n   (n) < -(LUA_NUMBER)(LUA_MININTEGER) && \\\n      (*(p) = (LUA_INTEGER)(n), 1))\n\n\n/* now the variable definitions */\n\n#if LUA_FLOAT_TYPE == LUA_FLOAT_FLOAT\t\t/* { single float */\n\n#define LUA_NUMBER\tfloat\n\n#define l_floatatt(n)\t\t(FLT_##n)\n\n#define LUAI_UACNUMBER\tdouble\n\n#define LUA_NUMBER_FRMLEN\t\"\"\n#define LUA_NUMBER_FMT\t\t\"%.7g\"\n#define LUA_NUMBER_FMT_N\t\"%.9g\"\n\n#define l_mathop(op)\t\top##f\n\n#define lua_str2number(s,p)\tstrtof((s), (p))\n\n\n#elif LUA_FLOAT_TYPE == LUA_FLOAT_LONGDOUBLE\t/* }{ long double */\n\n#define LUA_NUMBER\tlong double\n\n#define l_floatatt(n)\t\t(LDBL_##n)\n\n#define LUAI_UACNUMBER\tlong double\n\n#define LUA_NUMBER_FRMLEN\t\"L\"\n#define LUA_NUMBER_FMT\t\t\"%.19Lg\"\n#define LUA_NUMBER_FMT_N\t\"%.21Lg\"\n\n#define l_mathop(op)\t\top##l\n\n#define lua_str2number(s,p)\tstrtold((s), (p))\n\n#elif LUA_FLOAT_TYPE == LUA_FLOAT_DOUBLE\t/* }{ double */\n\n#define LUA_NUMBER\tdouble\n\n#define l_floatatt(n)\t\t(DBL_##n)\n\n#define LUAI_UACNUMBER\tdouble\n\n#define LUA_NUMBER_FRMLEN\t\"\"\n#define LUA_NUMBER_FMT\t\t\"%.15g\"\n#define LUA_NUMBER_FMT_N\t\"%.17g\"\n\n#define l_mathop(op)\t\top\n\n#define lua_str2number(s,p)\tstrtod((s), (p))\n\n#else\t\t\t\t\t\t/* }{ */\n\n#error \"numeric float type not defined\"\n\n#endif\t\t\t\t\t/* } */\n\n\n\n/*\n@@ LUA_UNSIGNED is the unsigned version of LUA_INTEGER.\n@@ LUAI_UACINT is the result of a 'default argument promotion'\n@@ over a LUA_INTEGER.\n@@ LUA_INTEGER_FRMLEN is the length modifier for reading/writing integers.\n@@ LUA_INTEGER_FMT is the format for writing integers.\n@@ LUA_MAXINTEGER is the maximum value for a LUA_INTEGER.\n@@ LUA_MININTEGER is the minimum value for a LUA_INTEGER.\n@@ LUA_MAXUNSIGNED is the maximum value for a LUA_UNSIGNED.\n@@ lua_integer2str converts an integer to a string.\n*/\n\n\n/* The following definitions are good for most cases here */\n\n#define LUA_INTEGER_FMT\t\t\"%\" LUA_INTEGER_FRMLEN \"d\"\n\n#define LUAI_UACINT\t\tLUA_INTEGER\n\n#define lua_integer2str(s,sz,n)  \\\n\tl_sprintf((s), sz, LUA_INTEGER_FMT, (LUAI_UACINT)(n))\n\n/*\n** use LUAI_UACINT here to avoid problems with promotions (which\n** can turn a comparison between unsigneds into a signed comparison)\n*/\n#define LUA_UNSIGNED\t\tunsigned LUAI_UACINT\n\n\n/* now the variable definitions */\n\n#if LUA_INT_TYPE == LUA_INT_INT\t\t/* { int */\n\n#define LUA_INTEGER\t\tint\n#define LUA_INTEGER_FRMLEN\t\"\"\n\n#define LUA_MAXINTEGER\t\tINT_MAX\n#define LUA_MININTEGER\t\tINT_MIN\n\n#define LUA_MAXUNSIGNED\t\tUINT_MAX\n\n#elif LUA_INT_TYPE == LUA_INT_LONG\t/* }{ long */\n\n#define LUA_INTEGER\t\tlong\n#define LUA_INTEGER_FRMLEN\t\"l\"\n\n#define LUA_MAXINTEGER\t\tLONG_MAX\n#define LUA_MININTEGER\t\tLONG_MIN\n\n#define LUA_MAXUNSIGNED\t\tULONG_MAX\n\n#elif LUA_INT_TYPE == LUA_INT_LONGLONG\t/* }{ long long */\n\n/* use presence of macro LLONG_MAX as proxy for C99 compliance */\n#if defined(LLONG_MAX)\t\t/* { */\n/* use ISO C99 stuff */\n\n#define LUA_INTEGER\t\tlong long\n#define LUA_INTEGER_FRMLEN\t\"ll\"\n\n#define LUA_MAXINTEGER\t\tLLONG_MAX\n#define LUA_MININTEGER\t\tLLONG_MIN\n\n#define LUA_MAXUNSIGNED\t\tULLONG_MAX\n\n#elif defined(LUA_USE_WINDOWS) /* }{ */\n/* in Windows, can use specific Windows types */\n\n#define LUA_INTEGER\t\t__int64\n#define LUA_INTEGER_FRMLEN\t\"I64\"\n\n#define LUA_MAXINTEGER\t\t_I64_MAX\n#define LUA_MININTEGER\t\t_I64_MIN\n\n#define LUA_MAXUNSIGNED\t\t_UI64_MAX\n\n#else\t\t\t\t/* }{ */\n\n#error \"Compiler does not support 'long long'. Use option '-DLUA_32BITS' \\\n  or '-DLUA_C89_NUMBERS' (see file 'luaconf.h' for details)\"\n\n#endif\t\t\t\t/* } */\n\n#else\t\t\t\t/* }{ */\n\n#error \"numeric integer type not defined\"\n\n#endif\t\t\t\t/* } */\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Dependencies with C99 and other C details\n** ===================================================================\n*/\n\n/*\n@@ l_sprintf is equivalent to 'snprintf' or 'sprintf' in C89.\n** (All uses in Lua have only one format item.)\n*/\n#if !defined(LUA_USE_C89)\n#define l_sprintf(s,sz,f,i)\tsnprintf(s,sz,f,i)\n#else\n#define l_sprintf(s,sz,f,i)\t((void)(sz), sprintf(s,f,i))\n#endif\n\n\n/*\n@@ lua_strx2number converts a hexadecimal numeral to a number.\n** In C99, 'strtod' does that conversion. Otherwise, you can\n** leave 'lua_strx2number' undefined and Lua will provide its own\n** implementation.\n*/\n#if !defined(LUA_USE_C89)\n#define lua_strx2number(s,p)\t\tlua_str2number(s,p)\n#endif\n\n\n/*\n@@ lua_pointer2str converts a pointer to a readable string in a\n** non-specified way.\n*/\n#define lua_pointer2str(buff,sz,p)\tl_sprintf(buff,sz,\"%p\",p)\n\n\n/*\n@@ lua_number2strx converts a float to a hexadecimal numeral.\n** In C99, 'sprintf' (with format specifiers '%a'/'%A') does that.\n** Otherwise, you can leave 'lua_number2strx' undefined and Lua will\n** provide its own implementation.\n*/\n#if !defined(LUA_USE_C89)\n#define lua_number2strx(L,b,sz,f,n)  \\\n\t((void)L, l_sprintf(b,sz,f,(LUAI_UACNUMBER)(n)))\n#endif\n\n\n/*\n** 'strtof' and 'opf' variants for math functions are not valid in\n** C89. Otherwise, the macro 'HUGE_VALF' is a good proxy for testing the\n** availability of these variants. ('math.h' is already included in\n** all files that use these macros.)\n*/\n#if defined(LUA_USE_C89) || (defined(HUGE_VAL) && !defined(HUGE_VALF))\n#undef l_mathop  /* variants not available */\n#undef lua_str2number\n#define l_mathop(op)\t\t(lua_Number)op  /* no variant */\n#define lua_str2number(s,p)\t((lua_Number)strtod((s), (p)))\n#endif\n\n\n/*\n@@ LUA_KCONTEXT is the type of the context ('ctx') for continuation\n** functions.  It must be a numerical type; Lua will use 'intptr_t' if\n** available, otherwise it will use 'ptrdiff_t' (the nearest thing to\n** 'intptr_t' in C89)\n*/\n#define LUA_KCONTEXT\tptrdiff_t\n\n#if !defined(LUA_USE_C89) && defined(__STDC_VERSION__) && \\\n    __STDC_VERSION__ >= 199901L\n#include <stdint.h>\n#if defined(INTPTR_MAX)  /* even in C99 this type is optional */\n#undef LUA_KCONTEXT\n#define LUA_KCONTEXT\tintptr_t\n#endif\n#endif\n\n\n/*\n@@ lua_getlocaledecpoint gets the locale \"radix character\" (decimal point).\n** Change that if you do not want to use C locales. (Code using this\n** macro must include the header 'locale.h'.)\n*/\n#if !defined(lua_getlocaledecpoint)\n#define lua_getlocaledecpoint()\t\t(localeconv()->decimal_point[0])\n#endif\n\n\n/*\n** macros to improve jump prediction, used mostly for error handling\n** and debug facilities. (Some macros in the Lua API use these macros.\n** Define LUA_NOBUILTIN if you do not want '__builtin_expect' in your\n** code.)\n*/\n#if !defined(luai_likely)\n\n#if defined(__GNUC__) && !defined(LUA_NOBUILTIN)\n#define luai_likely(x)\t\t(__builtin_expect(((x) != 0), 1))\n#define luai_unlikely(x)\t(__builtin_expect(((x) != 0), 0))\n#else\n#define luai_likely(x)\t\t(x)\n#define luai_unlikely(x)\t(x)\n#endif\n\n#endif\n\n\n#if defined(LUA_CORE) || defined(LUA_LIB)\n/* shorter names for Lua's own use */\n#define l_likely(x)\tluai_likely(x)\n#define l_unlikely(x)\tluai_unlikely(x)\n#endif\n\n\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Language Variations\n** =====================================================================\n*/\n\n/*\n@@ LUA_NOCVTN2S/LUA_NOCVTS2N control how Lua performs some\n** coercions. Define LUA_NOCVTN2S to turn off automatic coercion from\n** numbers to strings. Define LUA_NOCVTS2N to turn off automatic\n** coercion from strings to numbers.\n*/\n/* #define LUA_NOCVTN2S */\n/* #define LUA_NOCVTS2N */\n\n\n/*\n@@ LUA_USE_APICHECK turns on several consistency checks on the C API.\n** Define it as a help when debugging C code.\n*/\n/* #define LUA_USE_APICHECK */\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Macros that affect the API and must be stable (that is, must be the\n** same when you compile Lua and when you compile code that links to\n** Lua).\n** =====================================================================\n*/\n\n/*\n@@ LUAI_MAXSTACK limits the size of the Lua stack.\n** CHANGE it if you need a different limit. This limit is arbitrary;\n** its only purpose is to stop Lua from consuming unlimited stack\n** space and to reserve some numbers for pseudo-indices.\n** (It must fit into max(int)/2.)\n*/\n#if 1000000 < (INT_MAX / 2)\n#define LUAI_MAXSTACK\t\t1000000\n#else\n#define LUAI_MAXSTACK\t\t(INT_MAX / 2u)\n#endif\n\n\n/*\n@@ LUA_EXTRASPACE defines the size of a raw memory area associated with\n** a Lua state with very fast access.\n** CHANGE it if you need a different size.\n*/\n#define LUA_EXTRASPACE\t\t(sizeof(void *))\n\n\n/*\n@@ LUA_IDSIZE gives the maximum size for the description of the source\n** of a function in debug information.\n** CHANGE it if you want a different size.\n*/\n#define LUA_IDSIZE\t60\n\n\n/*\n@@ LUAL_BUFFERSIZE is the initial buffer size used by the lauxlib\n** buffer system.\n*/\n#define LUAL_BUFFERSIZE   ((int)(16 * sizeof(void*) * sizeof(lua_Number)))\n\n\n/*\n@@ LUAI_MAXALIGN defines fields that, when used in a union, ensure\n** maximum alignment for the other items in that union.\n*/\n#define LUAI_MAXALIGN  lua_Number n; double u; void *s; lua_Integer i; long l\n\n/* }================================================================== */\n\n\n\n\n\n/* =================================================================== */\n\n/*\n** Local configuration. You can use this space to add your redefinitions\n** without modifying the main part of the file.\n*/\n\n\n\n\n\n#endif\n\n"
        },
        {
          "name": "lualib.h",
          "type": "blob",
          "size": 1.5556640625,
          "content": "/*\n** $Id: lualib.h $\n** Lua standard libraries\n** See Copyright Notice in lua.h\n*/\n\n\n#ifndef lualib_h\n#define lualib_h\n\n#include \"lua.h\"\n\n\n/* version suffix for environment variable names */\n#define LUA_VERSUFFIX          \"_\" LUA_VERSION_MAJOR \"_\" LUA_VERSION_MINOR\n\n#define LUA_GLIBK\t\t1\nLUAMOD_API int (luaopen_base) (lua_State *L);\n\n#define LUA_LOADLIBNAME\t\"package\"\n#define LUA_LOADLIBK\t(LUA_GLIBK << 1)\nLUAMOD_API int (luaopen_package) (lua_State *L);\n\n\n#define LUA_COLIBNAME\t\"coroutine\"\n#define LUA_COLIBK\t(LUA_LOADLIBK << 1)\nLUAMOD_API int (luaopen_coroutine) (lua_State *L);\n\n#define LUA_DBLIBNAME\t\"debug\"\n#define LUA_DBLIBK\t(LUA_COLIBK << 1)\nLUAMOD_API int (luaopen_debug) (lua_State *L);\n\n#define LUA_IOLIBNAME\t\"io\"\n#define LUA_IOLIBK\t(LUA_DBLIBK << 1)\nLUAMOD_API int (luaopen_io) (lua_State *L);\n\n#define LUA_MATHLIBNAME\t\"math\"\n#define LUA_MATHLIBK\t(LUA_IOLIBK << 1)\nLUAMOD_API int (luaopen_math) (lua_State *L);\n\n#define LUA_OSLIBNAME\t\"os\"\n#define LUA_OSLIBK\t(LUA_MATHLIBK << 1)\nLUAMOD_API int (luaopen_os) (lua_State *L);\n\n#define LUA_STRLIBNAME\t\"string\"\n#define LUA_STRLIBK\t(LUA_OSLIBK << 1)\nLUAMOD_API int (luaopen_string) (lua_State *L);\n\n#define LUA_TABLIBNAME\t\"table\"\n#define LUA_TABLIBK\t(LUA_STRLIBK << 1)\nLUAMOD_API int (luaopen_table) (lua_State *L);\n\n#define LUA_UTF8LIBNAME\t\"utf8\"\n#define LUA_UTF8LIBK\t(LUA_TABLIBK << 1)\nLUAMOD_API int (luaopen_utf8) (lua_State *L);\n\n\n/* open selected libraries */\nLUALIB_API void (luaL_openselectedlibs) (lua_State *L, int load, int preload);\n\n/* open all libraries */\n#define luaL_openlibs(L)\tluaL_openselectedlibs(L, ~0, 0)\n\n\n#endif\n"
        },
        {
          "name": "lundump.c",
          "type": "blob",
          "size": 10.427734375,
          "content": "/*\n** $Id: lundump.c $\n** load precompiled Lua chunks\n** See Copyright Notice in lua.h\n*/\n\n#define lundump_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <limits.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lmem.h\"\n#include \"lobject.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"lundump.h\"\n#include \"lzio.h\"\n\n\n#if !defined(luai_verifycode)\n#define luai_verifycode(L,f)  /* empty */\n#endif\n\n\ntypedef struct {\n  lua_State *L;\n  ZIO *Z;\n  const char *name;\n  Table *h;  /* list for string reuse */\n  size_t offset;  /* current position relative to beginning of dump */\n  lua_Integer nstr;  /* number of strings in the list */\n  lu_byte fixed;  /* dump is fixed in memory */\n} LoadState;\n\n\nstatic l_noret error (LoadState *S, const char *why) {\n  luaO_pushfstring(S->L, \"%s: bad binary format (%s)\", S->name, why);\n  luaD_throw(S->L, LUA_ERRSYNTAX);\n}\n\n\n/*\n** All high-level loads go through loadVector; you can change it to\n** adapt to the endianness of the input\n*/\n#define loadVector(S,b,n)\tloadBlock(S,b,(n)*sizeof((b)[0]))\n\nstatic void loadBlock (LoadState *S, void *b, size_t size) {\n  if (luaZ_read(S->Z, b, size) != 0)\n    error(S, \"truncated chunk\");\n  S->offset += size;\n}\n\n\nstatic void loadAlign (LoadState *S, unsigned align) {\n  unsigned padding = align - cast_uint(S->offset % align);\n  if (padding < align) {  /* apd == align means no padding */\n    lua_Integer paddingContent;\n    loadBlock(S, &paddingContent, padding);\n    lua_assert(S->offset % align == 0);\n  }\n}\n\n\n#define getaddr(S,n,t)\tcast(t *, getaddr_(S,(n) * sizeof(t)))\n\nstatic const void *getaddr_ (LoadState *S, size_t size) {\n  const void *block = luaZ_getaddr(S->Z, size);\n  S->offset += size;\n  if (block == NULL)\n    error(S, \"truncated fixed buffer\");\n  return block;\n}\n\n\n#define loadVar(S,x)\t\tloadVector(S,&x,1)\n\n\nstatic lu_byte loadByte (LoadState *S) {\n  int b = zgetc(S->Z);\n  if (b == EOZ)\n    error(S, \"truncated chunk\");\n  S->offset++;\n  return cast_byte(b);\n}\n\n\nstatic size_t loadVarint (LoadState *S, size_t limit) {\n  size_t x = 0;\n  int b;\n  limit >>= 7;\n  do {\n    b = loadByte(S);\n    if (x > limit)\n      error(S, \"integer overflow\");\n    x = (x << 7) | (b & 0x7f);\n  } while ((b & 0x80) != 0);\n  return x;\n}\n\n\nstatic size_t loadSize (LoadState *S) {\n  return loadVarint(S, MAX_SIZE);\n}\n\n\n/*\n** Read an non-negative int */\nstatic unsigned loadUint (LoadState *S) {\n  return cast_uint(loadVarint(S, cast_sizet(INT_MAX)));\n}\n\n\nstatic int loadInt (LoadState *S) {\n  return cast_int(loadVarint(S, cast_sizet(INT_MAX)));\n}\n\n\n\nstatic lua_Number loadNumber (LoadState *S) {\n  lua_Number x;\n  loadVar(S, x);\n  return x;\n}\n\n\nstatic lua_Integer loadInteger (LoadState *S) {\n  lua_Integer x;\n  loadVar(S, x);\n  return x;\n}\n\n\n/*\n** Load a nullable string into slot 'sl' from prototype 'p'. The\n** assignment to the slot and the barrier must be performed before any\n** possible GC activity, to anchor the string. (Both 'loadVector' and\n** 'luaH_setint' can call the GC.)\n*/\nstatic void loadString (LoadState *S, Proto *p, TString **sl) {\n  lua_State *L = S->L;\n  TString *ts;\n  TValue sv;\n  size_t size = loadSize(S);\n  if (size == 0) {  /* no string? */\n    lua_assert(*sl == NULL);  /* must be prefilled */\n    return;\n  }\n  else if (size == 1) {  /* previously saved string? */\n    lua_Integer idx = cast(lua_Integer, loadSize(S));  /* get its index */\n    TValue stv;\n    luaH_getint(S->h, idx, &stv);  /* get its value */\n    *sl = ts = tsvalue(&stv);\n    luaC_objbarrier(L, p, ts);\n    return;  /* do not save it again */\n  }\n  else if ((size -= 2) <= LUAI_MAXSHORTLEN) {  /* short string? */\n    char buff[LUAI_MAXSHORTLEN + 1];  /* extra space for '\\0' */\n    loadVector(S, buff, size + 1);  /* load string into buffer */\n    *sl = ts = luaS_newlstr(L, buff, size);  /* create string */\n    luaC_objbarrier(L, p, ts);\n  }\n  else if (S->fixed) {  /* for a fixed buffer, use a fixed string */\n    const char *s = getaddr(S, size + 1, char);  /* get content address */\n    *sl = ts = luaS_newextlstr(L, s, size, NULL, NULL);\n    luaC_objbarrier(L, p, ts);\n  }\n  else {  /* create internal copy */\n    *sl = ts = luaS_createlngstrobj(L, size);  /* create string */\n    luaC_objbarrier(L, p, ts);\n    loadVector(S, getlngstr(ts), size + 1);  /* load directly in final place */\n  }\n  /* add string to list of saved strings */\n  S->nstr++;\n  setsvalue(L, &sv, ts);\n  luaH_setint(L, S->h, S->nstr, &sv);\n  luaC_objbarrierback(L, obj2gco(S->h), ts);\n}\n\n\nstatic void loadCode (LoadState *S, Proto *f) {\n  unsigned n = loadUint(S);\n  loadAlign(S, sizeof(f->code[0]));\n  if (S->fixed) {\n    f->code = getaddr(S, n, Instruction);\n    f->sizecode = cast_int(n);\n  }\n  else {\n    f->code = luaM_newvectorchecked(S->L, n, Instruction);\n    f->sizecode = cast_int(n);\n    loadVector(S, f->code, n);\n  }\n}\n\n\nstatic void loadFunction(LoadState *S, Proto *f);\n\n\nstatic void loadConstants (LoadState *S, Proto *f) {\n  unsigned i;\n  unsigned n = loadUint(S);\n  f->k = luaM_newvectorchecked(S->L, n, TValue);\n  f->sizek = cast_int(n);\n  for (i = 0; i < n; i++)\n    setnilvalue(&f->k[i]);\n  for (i = 0; i < n; i++) {\n    TValue *o = &f->k[i];\n    int t = loadByte(S);\n    switch (t) {\n      case LUA_VNIL:\n        setnilvalue(o);\n        break;\n      case LUA_VFALSE:\n        setbfvalue(o);\n        break;\n      case LUA_VTRUE:\n        setbtvalue(o);\n        break;\n      case LUA_VNUMFLT:\n        setfltvalue(o, loadNumber(S));\n        break;\n      case LUA_VNUMINT:\n        setivalue(o, loadInteger(S));\n        break;\n      case LUA_VSHRSTR:\n      case LUA_VLNGSTR: {\n        lua_assert(f->source == NULL);\n        loadString(S, f, &f->source);  /* use 'source' to anchor string */\n        if (f->source == NULL)\n          error(S, \"bad format for constant string\");\n        setsvalue2n(S->L, o, f->source);  /* save it in the right place */\n        f->source = NULL;\n        break;\n      }\n      default: lua_assert(0);\n    }\n  }\n}\n\n\nstatic void loadProtos (LoadState *S, Proto *f) {\n  unsigned i;\n  unsigned n = loadUint(S);\n  f->p = luaM_newvectorchecked(S->L, n, Proto *);\n  f->sizep = cast_int(n);\n  for (i = 0; i < n; i++)\n    f->p[i] = NULL;\n  for (i = 0; i < n; i++) {\n    f->p[i] = luaF_newproto(S->L);\n    luaC_objbarrier(S->L, f, f->p[i]);\n    loadFunction(S, f->p[i]);\n  }\n}\n\n\n/*\n** Load the upvalues for a function. The names must be filled first,\n** because the filling of the other fields can raise read errors and\n** the creation of the error message can call an emergency collection;\n** in that case all prototypes must be consistent for the GC.\n*/\nstatic void loadUpvalues (LoadState *S, Proto *f) {\n  unsigned i;\n  unsigned n = loadUint(S);\n  f->upvalues = luaM_newvectorchecked(S->L, n, Upvaldesc);\n  f->sizeupvalues = cast_int(n);\n  for (i = 0; i < n; i++)  /* make array valid for GC */\n    f->upvalues[i].name = NULL;\n  for (i = 0; i < n; i++) {  /* following calls can raise errors */\n    f->upvalues[i].instack = loadByte(S);\n    f->upvalues[i].idx = loadByte(S);\n    f->upvalues[i].kind = loadByte(S);\n  }\n}\n\n\nstatic void loadDebug (LoadState *S, Proto *f) {\n  unsigned i;\n  unsigned n = loadUint(S);\n  if (S->fixed) {\n    f->lineinfo = getaddr(S, n, ls_byte);\n    f->sizelineinfo = cast_int(n);\n  }\n  else {\n    f->lineinfo = luaM_newvectorchecked(S->L, n, ls_byte);\n    f->sizelineinfo = cast_int(n);\n    loadVector(S, f->lineinfo, n);\n  }\n  n = loadUint(S);\n  if (n > 0) {\n    loadAlign(S, sizeof(int));\n    if (S->fixed) {\n      f->abslineinfo = getaddr(S, n, AbsLineInfo);\n      f->sizeabslineinfo = cast_int(n);\n    }\n    else {\n      f->abslineinfo = luaM_newvectorchecked(S->L, n, AbsLineInfo);\n      f->sizeabslineinfo = cast_int(n);\n      loadVector(S, f->abslineinfo, n);\n    }\n  }\n  n = loadUint(S);\n  f->locvars = luaM_newvectorchecked(S->L, n, LocVar);\n  f->sizelocvars = cast_int(n);\n  for (i = 0; i < n; i++)\n    f->locvars[i].varname = NULL;\n  for (i = 0; i < n; i++) {\n    loadString(S, f, &f->locvars[i].varname);\n    f->locvars[i].startpc = loadInt(S);\n    f->locvars[i].endpc = loadInt(S);\n  }\n  n = loadUint(S);\n  if (n != 0)  /* does it have debug information? */\n    n = cast_uint(f->sizeupvalues);  /* must be this many */\n  for (i = 0; i < n; i++)\n    loadString(S, f, &f->upvalues[i].name);\n}\n\n\nstatic void loadFunction (LoadState *S, Proto *f) {\n  f->linedefined = loadInt(S);\n  f->lastlinedefined = loadInt(S);\n  f->numparams = loadByte(S);\n  f->flag = loadByte(S) & PF_ISVARARG;  /* get only the meaningful flags */\n  if (S->fixed)\n    f->flag |= PF_FIXED;  /* signal that code is fixed */\n  f->maxstacksize = loadByte(S);\n  loadCode(S, f);\n  loadConstants(S, f);\n  loadUpvalues(S, f);\n  loadProtos(S, f);\n  loadString(S, f, &f->source);\n  loadDebug(S, f);\n}\n\n\nstatic void checkliteral (LoadState *S, const char *s, const char *msg) {\n  char buff[sizeof(LUA_SIGNATURE) + sizeof(LUAC_DATA)]; /* larger than both */\n  size_t len = strlen(s);\n  loadVector(S, buff, len);\n  if (memcmp(s, buff, len) != 0)\n    error(S, msg);\n}\n\n\nstatic void fchecksize (LoadState *S, size_t size, const char *tname) {\n  if (loadByte(S) != size)\n    error(S, luaO_pushfstring(S->L, \"%s size mismatch\", tname));\n}\n\n\n#define checksize(S,t)\tfchecksize(S,sizeof(t),#t)\n\nstatic void checkHeader (LoadState *S) {\n  /* skip 1st char (already read and checked) */\n  checkliteral(S, &LUA_SIGNATURE[1], \"not a binary chunk\");\n  if (loadByte(S) != LUAC_VERSION)\n    error(S, \"version mismatch\");\n  if (loadByte(S) != LUAC_FORMAT)\n    error(S, \"format mismatch\");\n  checkliteral(S, LUAC_DATA, \"corrupted chunk\");\n  checksize(S, Instruction);\n  checksize(S, lua_Integer);\n  checksize(S, lua_Number);\n  if (loadInteger(S) != LUAC_INT)\n    error(S, \"integer format mismatch\");\n  if (loadNumber(S) != LUAC_NUM)\n    error(S, \"float format mismatch\");\n}\n\n\n/*\n** Load precompiled chunk.\n*/\nLClosure *luaU_undump (lua_State *L, ZIO *Z, const char *name, int fixed) {\n  LoadState S;\n  LClosure *cl;\n  if (*name == '@' || *name == '=')\n    S.name = name + 1;\n  else if (*name == LUA_SIGNATURE[0])\n    S.name = \"binary string\";\n  else\n    S.name = name;\n  S.L = L;\n  S.Z = Z;\n  S.fixed = cast_byte(fixed);\n  S.offset = 1;  /* fist byte was already read */\n  checkHeader(&S);\n  cl = luaF_newLclosure(L, loadByte(&S));\n  setclLvalue2s(L, L->top.p, cl);\n  luaD_inctop(L);\n  S.h = luaH_new(L);  /* create list of saved strings */\n  S.nstr = 0;\n  sethvalue2s(L, L->top.p, S.h);  /* anchor it */\n  luaD_inctop(L);\n  cl->p = luaF_newproto(L);\n  luaC_objbarrier(L, cl, cl->p);\n  loadFunction(&S, cl->p);\n  lua_assert(cl->nupvalues == cl->p->sizeupvalues);\n  luai_verifycode(L, cl->p);\n  L->top.p--;  /* pop table */\n  return cl;\n}\n\n"
        },
        {
          "name": "lundump.h",
          "type": "blob",
          "size": 0.8515625,
          "content": "/*\n** $Id: lundump.h $\n** load precompiled Lua chunks\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lundump_h\n#define lundump_h\n\n#include <limits.h>\n\n#include \"llimits.h\"\n#include \"lobject.h\"\n#include \"lzio.h\"\n\n\n/* data to catch conversion errors */\n#define LUAC_DATA\t\"\\x19\\x93\\r\\n\\x1a\\n\"\n\n#define LUAC_INT\t0x5678\n#define LUAC_NUM\tcast_num(370.5)\n\n/*\n** Encode major-minor version in one byte, one nibble for each\n*/\n#define LUAC_VERSION\t(LUA_VERSION_MAJOR_N*16+LUA_VERSION_MINOR_N)\n\n#define LUAC_FORMAT\t0\t/* this is the official format */\n\n\n/* load one chunk; from lundump.c */\nLUAI_FUNC LClosure* luaU_undump (lua_State* L, ZIO* Z, const char* name,\n                                               int fixed);\n\n/* dump one chunk; from ldump.c */\nLUAI_FUNC int luaU_dump (lua_State* L, const Proto* f, lua_Writer w,\n                         void* data, int strip);\n\n#endif\n"
        },
        {
          "name": "lutf8lib.c",
          "type": "blob",
          "size": 8.16796875,
          "content": "/*\n** $Id: lutf8lib.c $\n** Standard library for UTF-8 manipulation\n** See Copyright Notice in lua.h\n*/\n\n#define lutf8lib_c\n#define LUA_LIB\n\n#include \"lprefix.h\"\n\n\n#include <assert.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n#include \"llimits.h\"\n\n\n#define MAXUNICODE\t0x10FFFFu\n\n#define MAXUTF\t\t0x7FFFFFFFu\n\n\n#define MSGInvalid\t\"invalid UTF-8 code\"\n\n\n#define iscont(c)\t(((c) & 0xC0) == 0x80)\n#define iscontp(p)\tiscont(*(p))\n\n\n/* from strlib */\n/* translate a relative string position: negative means back from end */\nstatic lua_Integer u_posrelat (lua_Integer pos, size_t len) {\n  if (pos >= 0) return pos;\n  else if (0u - (size_t)pos > len) return 0;\n  else return (lua_Integer)len + pos + 1;\n}\n\n\n/*\n** Decode one UTF-8 sequence, returning NULL if byte sequence is\n** invalid.  The array 'limits' stores the minimum value for each\n** sequence length, to check for overlong representations. Its first\n** entry forces an error for non-ascii bytes with no continuation\n** bytes (count == 0).\n*/\nstatic const char *utf8_decode (const char *s, l_uint32 *val, int strict) {\n  static const l_uint32 limits[] =\n        {~(l_uint32)0, 0x80, 0x800, 0x10000u, 0x200000u, 0x4000000u};\n  unsigned int c = (unsigned char)s[0];\n  l_uint32 res = 0;  /* final result */\n  if (c < 0x80)  /* ascii? */\n    res = c;\n  else {\n    int count = 0;  /* to count number of continuation bytes */\n    for (; c & 0x40; c <<= 1) {  /* while it needs continuation bytes... */\n      unsigned int cc = (unsigned char)s[++count];  /* read next byte */\n      if (!iscont(cc))  /* not a continuation byte? */\n        return NULL;  /* invalid byte sequence */\n      res = (res << 6) | (cc & 0x3F);  /* add lower 6 bits from cont. byte */\n    }\n    res |= ((l_uint32)(c & 0x7F) << (count * 5));  /* add first byte */\n    if (count > 5 || res > MAXUTF || res < limits[count])\n      return NULL;  /* invalid byte sequence */\n    s += count;  /* skip continuation bytes read */\n  }\n  if (strict) {\n    /* check for invalid code points; too large or surrogates */\n    if (res > MAXUNICODE || (0xD800u <= res && res <= 0xDFFFu))\n      return NULL;\n  }\n  if (val) *val = res;\n  return s + 1;  /* +1 to include first byte */\n}\n\n\n/*\n** utf8len(s [, i [, j [, lax]]]) --> number of characters that\n** start in the range [i,j], or nil + current position if 's' is not\n** well formed in that interval\n*/\nstatic int utflen (lua_State *L) {\n  lua_Integer n = 0;  /* counter for the number of characters */\n  size_t len;  /* string length in bytes */\n  const char *s = luaL_checklstring(L, 1, &len);\n  lua_Integer posi = u_posrelat(luaL_optinteger(L, 2, 1), len);\n  lua_Integer posj = u_posrelat(luaL_optinteger(L, 3, -1), len);\n  int lax = lua_toboolean(L, 4);\n  luaL_argcheck(L, 1 <= posi && --posi <= (lua_Integer)len, 2,\n                   \"initial position out of bounds\");\n  luaL_argcheck(L, --posj < (lua_Integer)len, 3,\n                   \"final position out of bounds\");\n  while (posi <= posj) {\n    const char *s1 = utf8_decode(s + posi, NULL, !lax);\n    if (s1 == NULL) {  /* conversion error? */\n      luaL_pushfail(L);  /* return fail ... */\n      lua_pushinteger(L, posi + 1);  /* ... and current position */\n      return 2;\n    }\n    posi = ct_diff2S(s1 - s);\n    n++;\n  }\n  lua_pushinteger(L, n);\n  return 1;\n}\n\n\n/*\n** codepoint(s, [i, [j [, lax]]]) -> returns codepoints for all\n** characters that start in the range [i,j]\n*/\nstatic int codepoint (lua_State *L) {\n  size_t len;\n  const char *s = luaL_checklstring(L, 1, &len);\n  lua_Integer posi = u_posrelat(luaL_optinteger(L, 2, 1), len);\n  lua_Integer pose = u_posrelat(luaL_optinteger(L, 3, posi), len);\n  int lax = lua_toboolean(L, 4);\n  int n;\n  const char *se;\n  luaL_argcheck(L, posi >= 1, 2, \"out of bounds\");\n  luaL_argcheck(L, pose <= (lua_Integer)len, 3, \"out of bounds\");\n  if (posi > pose) return 0;  /* empty interval; return no values */\n  if (pose - posi >= INT_MAX)  /* (lua_Integer -> int) overflow? */\n    return luaL_error(L, \"string slice too long\");\n  n = (int)(pose -  posi) + 1;  /* upper bound for number of returns */\n  luaL_checkstack(L, n, \"string slice too long\");\n  n = 0;  /* count the number of returns */\n  se = s + pose;  /* string end */\n  for (s += posi - 1; s < se;) {\n    l_uint32 code;\n    s = utf8_decode(s, &code, !lax);\n    if (s == NULL)\n      return luaL_error(L, MSGInvalid);\n    lua_pushinteger(L, l_castU2S(code));\n    n++;\n  }\n  return n;\n}\n\n\nstatic void pushutfchar (lua_State *L, int arg) {\n  lua_Unsigned code = (lua_Unsigned)luaL_checkinteger(L, arg);\n  luaL_argcheck(L, code <= MAXUTF, arg, \"value out of range\");\n  lua_pushfstring(L, \"%U\", (long)code);\n}\n\n\n/*\n** utfchar(n1, n2, ...)  -> char(n1)..char(n2)...\n*/\nstatic int utfchar (lua_State *L) {\n  int n = lua_gettop(L);  /* number of arguments */\n  if (n == 1)  /* optimize common case of single char */\n    pushutfchar(L, 1);\n  else {\n    int i;\n    luaL_Buffer b;\n    luaL_buffinit(L, &b);\n    for (i = 1; i <= n; i++) {\n      pushutfchar(L, i);\n      luaL_addvalue(&b);\n    }\n    luaL_pushresult(&b);\n  }\n  return 1;\n}\n\n\n/*\n** offset(s, n, [i])  -> indices where n-th character counting from\n**   position 'i' starts and ends; 0 means character at 'i'.\n*/\nstatic int byteoffset (lua_State *L) {\n  size_t len;\n  const char *s = luaL_checklstring(L, 1, &len);\n  lua_Integer n  = luaL_checkinteger(L, 2);\n  lua_Integer posi = (n >= 0) ? 1 : cast_st2S(len) + 1;\n  posi = u_posrelat(luaL_optinteger(L, 3, posi), len);\n  luaL_argcheck(L, 1 <= posi && --posi <= (lua_Integer)len, 3,\n                   \"position out of bounds\");\n  if (n == 0) {\n    /* find beginning of current byte sequence */\n    while (posi > 0 && iscontp(s + posi)) posi--;\n  }\n  else {\n    if (iscontp(s + posi))\n      return luaL_error(L, \"initial position is a continuation byte\");\n    if (n < 0) {\n      while (n < 0 && posi > 0) {  /* move back */\n        do {  /* find beginning of previous character */\n          posi--;\n        } while (posi > 0 && iscontp(s + posi));\n        n++;\n      }\n    }\n    else {\n      n--;  /* do not move for 1st character */\n      while (n > 0 && posi < (lua_Integer)len) {\n        do {  /* find beginning of next character */\n          posi++;\n        } while (iscontp(s + posi));  /* (cannot pass final '\\0') */\n        n--;\n      }\n    }\n  }\n  if (n != 0) {  /* did not find given character? */\n    luaL_pushfail(L);\n    return 1;\n  }\n  lua_pushinteger(L, posi + 1);  /* initial position */\n  if ((s[posi] & 0x80) != 0) {  /* multi-byte character? */\n    do {\n      posi++;\n    } while (iscontp(s + posi + 1));  /* skip to final byte */\n  }\n  /* else one-byte character: final position is the initial one */\n  lua_pushinteger(L, posi + 1);  /* 'posi' now is the final position */\n  return 2;\n}\n\n\nstatic int iter_aux (lua_State *L, int strict) {\n  size_t len;\n  const char *s = luaL_checklstring(L, 1, &len);\n  lua_Unsigned n = (lua_Unsigned)lua_tointeger(L, 2);\n  if (n < len) {\n    while (iscontp(s + n)) n++;  /* go to next character */\n  }\n  if (n >= len)  /* (also handles original 'n' being negative) */\n    return 0;  /* no more codepoints */\n  else {\n    l_uint32 code;\n    const char *next = utf8_decode(s + n, &code, strict);\n    if (next == NULL || iscontp(next))\n      return luaL_error(L, MSGInvalid);\n    lua_pushinteger(L, l_castU2S(n + 1));\n    lua_pushinteger(L, l_castU2S(code));\n    return 2;\n  }\n}\n\n\nstatic int iter_auxstrict (lua_State *L) {\n  return iter_aux(L, 1);\n}\n\nstatic int iter_auxlax (lua_State *L) {\n  return iter_aux(L, 0);\n}\n\n\nstatic int iter_codes (lua_State *L) {\n  int lax = lua_toboolean(L, 2);\n  const char *s = luaL_checkstring(L, 1);\n  luaL_argcheck(L, !iscontp(s), 1, MSGInvalid);\n  lua_pushcfunction(L, lax ? iter_auxlax : iter_auxstrict);\n  lua_pushvalue(L, 1);\n  lua_pushinteger(L, 0);\n  return 3;\n}\n\n\n/* pattern to match a single UTF-8 character */\n#define UTF8PATT\t\"[\\0-\\x7F\\xC2-\\xFD][\\x80-\\xBF]*\"\n\n\nstatic const luaL_Reg funcs[] = {\n  {\"offset\", byteoffset},\n  {\"codepoint\", codepoint},\n  {\"char\", utfchar},\n  {\"len\", utflen},\n  {\"codes\", iter_codes},\n  /* placeholders */\n  {\"charpattern\", NULL},\n  {NULL, NULL}\n};\n\n\nLUAMOD_API int luaopen_utf8 (lua_State *L) {\n  luaL_newlib(L, funcs);\n  lua_pushlstring(L, UTF8PATT, sizeof(UTF8PATT)/sizeof(char) - 1);\n  lua_setfield(L, -2, \"charpattern\");\n  return 1;\n}\n\n"
        },
        {
          "name": "lvm.c",
          "type": "blob",
          "size": 58.1708984375,
          "content": "/*\n** $Id: lvm.c $\n** Lua virtual machine\n** See Copyright Notice in lua.h\n*/\n\n#define lvm_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"ldebug.h\"\n#include \"ldo.h\"\n#include \"lfunc.h\"\n#include \"lgc.h\"\n#include \"lobject.h\"\n#include \"lopcodes.h\"\n#include \"lstate.h\"\n#include \"lstring.h\"\n#include \"ltable.h\"\n#include \"ltm.h\"\n#include \"lvm.h\"\n\n\n/*\n** By default, use jump tables in the main interpreter loop on gcc\n** and compatible compilers.\n*/\n#if !defined(LUA_USE_JUMPTABLE)\n#if defined(__GNUC__)\n#define LUA_USE_JUMPTABLE\t1\n#else\n#define LUA_USE_JUMPTABLE\t0\n#endif\n#endif\n\n\n\n/* limit for table tag-method chains (to avoid infinite loops) */\n#define MAXTAGLOOP\t2000\n\n\n/*\n** 'l_intfitsf' checks whether a given integer is in the range that\n** can be converted to a float without rounding. Used in comparisons.\n*/\n\n/* number of bits in the mantissa of a float */\n#define NBM\t\t(l_floatatt(MANT_DIG))\n\n/*\n** Check whether some integers may not fit in a float, testing whether\n** (maxinteger >> NBM) > 0. (That implies (1 << NBM) <= maxinteger.)\n** (The shifts are done in parts, to avoid shifting by more than the size\n** of an integer. In a worst case, NBM == 113 for long double and\n** sizeof(long) == 32.)\n*/\n#if ((((LUA_MAXINTEGER >> (NBM / 4)) >> (NBM / 4)) >> (NBM / 4)) \\\n\t>> (NBM - (3 * (NBM / 4))))  >  0\n\n/* limit for integers that fit in a float */\n#define MAXINTFITSF\t((lua_Unsigned)1 << NBM)\n\n/* check whether 'i' is in the interval [-MAXINTFITSF, MAXINTFITSF] */\n#define l_intfitsf(i)\t((MAXINTFITSF + l_castS2U(i)) <= (2 * MAXINTFITSF))\n\n#else  /* all integers fit in a float precisely */\n\n#define l_intfitsf(i)\t1\n\n#endif\n\n\n/*\n** Try to convert a value from string to a number value.\n** If the value is not a string or is a string not representing\n** a valid numeral (or if coercions from strings to numbers\n** are disabled via macro 'cvt2num'), do not modify 'result'\n** and return 0.\n*/\nstatic int l_strton (const TValue *obj, TValue *result) {\n  lua_assert(obj != result);\n  if (!cvt2num(obj))  /* is object not a string? */\n    return 0;\n  else {\n    TString *st = tsvalue(obj);\n    size_t stlen;\n    const char *s = getlstr(st, stlen);\n    return (luaO_str2num(s, result) == stlen + 1);\n  }\n}\n\n\n/*\n** Try to convert a value to a float. The float case is already handled\n** by the macro 'tonumber'.\n*/\nint luaV_tonumber_ (const TValue *obj, lua_Number *n) {\n  TValue v;\n  if (ttisinteger(obj)) {\n    *n = cast_num(ivalue(obj));\n    return 1;\n  }\n  else if (l_strton(obj, &v)) {  /* string coercible to number? */\n    *n = nvalue(&v);  /* convert result of 'luaO_str2num' to a float */\n    return 1;\n  }\n  else\n    return 0;  /* conversion failed */\n}\n\n\n/*\n** try to convert a float to an integer, rounding according to 'mode'.\n*/\nint luaV_flttointeger (lua_Number n, lua_Integer *p, F2Imod mode) {\n  lua_Number f = l_floor(n);\n  if (n != f) {  /* not an integral value? */\n    if (mode == F2Ieq) return 0;  /* fails if mode demands integral value */\n    else if (mode == F2Iceil)  /* needs ceil? */\n      f += 1;  /* convert floor to ceil (remember: n != f) */\n  }\n  return lua_numbertointeger(f, p);\n}\n\n\n/*\n** try to convert a value to an integer, rounding according to 'mode',\n** without string coercion.\n** (\"Fast track\" handled by macro 'tointegerns'.)\n*/\nint luaV_tointegerns (const TValue *obj, lua_Integer *p, F2Imod mode) {\n  if (ttisfloat(obj))\n    return luaV_flttointeger(fltvalue(obj), p, mode);\n  else if (ttisinteger(obj)) {\n    *p = ivalue(obj);\n    return 1;\n  }\n  else\n    return 0;\n}\n\n\n/*\n** try to convert a value to an integer.\n*/\nint luaV_tointeger (const TValue *obj, lua_Integer *p, F2Imod mode) {\n  TValue v;\n  if (l_strton(obj, &v))  /* does 'obj' point to a numerical string? */\n    obj = &v;  /* change it to point to its corresponding number */\n  return luaV_tointegerns(obj, p, mode);\n}\n\n\n/*\n** Try to convert a 'for' limit to an integer, preserving the semantics\n** of the loop. Return true if the loop must not run; otherwise, '*p'\n** gets the integer limit.\n** (The following explanation assumes a positive step; it is valid for\n** negative steps mutatis mutandis.)\n** If the limit is an integer or can be converted to an integer,\n** rounding down, that is the limit.\n** Otherwise, check whether the limit can be converted to a float. If\n** the float is too large, clip it to LUA_MAXINTEGER.  If the float\n** is too negative, the loop should not run, because any initial\n** integer value is greater than such limit; so, the function returns\n** true to signal that. (For this latter case, no integer limit would be\n** correct; even a limit of LUA_MININTEGER would run the loop once for\n** an initial value equal to LUA_MININTEGER.)\n*/\nstatic int forlimit (lua_State *L, lua_Integer init, const TValue *lim,\n                                   lua_Integer *p, lua_Integer step) {\n  if (!luaV_tointeger(lim, p, (step < 0 ? F2Iceil : F2Ifloor))) {\n    /* not coercible to in integer */\n    lua_Number flim;  /* try to convert to float */\n    if (!tonumber(lim, &flim)) /* cannot convert to float? */\n      luaG_forerror(L, lim, \"limit\");\n    /* else 'flim' is a float out of integer bounds */\n    if (luai_numlt(0, flim)) {  /* if it is positive, it is too large */\n      if (step < 0) return 1;  /* initial value must be less than it */\n      *p = LUA_MAXINTEGER;  /* truncate */\n    }\n    else {  /* it is less than min integer */\n      if (step > 0) return 1;  /* initial value must be greater than it */\n      *p = LUA_MININTEGER;  /* truncate */\n    }\n  }\n  return (step > 0 ? init > *p : init < *p);  /* not to run? */\n}\n\n\n/*\n** Prepare a numerical for loop (opcode OP_FORPREP).\n** Before execution, stack is as follows:\n**   ra     : initial value\n**   ra + 1 : limit\n**   ra + 2 : step\n** Return true to skip the loop. Otherwise,\n** after preparation, stack will be as follows:\n**   ra     : loop counter (integer loops) or limit (float loops)\n**   ra + 1 : step\n**   ra + 2 : control variable\n*/\nstatic int forprep (lua_State *L, StkId ra) {\n  TValue *pinit = s2v(ra);\n  TValue *plimit = s2v(ra + 1);\n  TValue *pstep = s2v(ra + 2);\n  if (ttisinteger(pinit) && ttisinteger(pstep)) { /* integer loop? */\n    lua_Integer init = ivalue(pinit);\n    lua_Integer step = ivalue(pstep);\n    lua_Integer limit;\n    if (step == 0)\n      luaG_runerror(L, \"'for' step is zero\");\n    if (forlimit(L, init, plimit, &limit, step))\n      return 1;  /* skip the loop */\n    else {  /* prepare loop counter */\n      lua_Unsigned count;\n      if (step > 0) {  /* ascending loop? */\n        count = l_castS2U(limit) - l_castS2U(init);\n        if (step != 1)  /* avoid division in the too common case */\n          count /= l_castS2U(step);\n      }\n      else {  /* step < 0; descending loop */\n        count = l_castS2U(init) - l_castS2U(limit);\n        /* 'step+1' avoids negating 'mininteger' */\n        count /= l_castS2U(-(step + 1)) + 1u;\n      }\n      /* use 'chgivalue' for places that for sure had integers */\n      chgivalue(s2v(ra), l_castU2S(count));  /* change init to count */\n      setivalue(s2v(ra + 1), step);  /* change limit to step */\n      chgivalue(s2v(ra + 2), init);  /* change step to init */\n    }\n  }\n  else {  /* try making all values floats */\n    lua_Number init; lua_Number limit; lua_Number step;\n    if (l_unlikely(!tonumber(plimit, &limit)))\n      luaG_forerror(L, plimit, \"limit\");\n    if (l_unlikely(!tonumber(pstep, &step)))\n      luaG_forerror(L, pstep, \"step\");\n    if (l_unlikely(!tonumber(pinit, &init)))\n      luaG_forerror(L, pinit, \"initial value\");\n    if (step == 0)\n      luaG_runerror(L, \"'for' step is zero\");\n    if (luai_numlt(0, step) ? luai_numlt(limit, init)\n                            : luai_numlt(init, limit))\n      return 1;  /* skip the loop */\n    else {\n      /* make sure all values are floats */\n      setfltvalue(s2v(ra), limit);\n      setfltvalue(s2v(ra + 1), step);\n      setfltvalue(s2v(ra + 2), init);  /* control variable */\n    }\n  }\n  return 0;\n}\n\n\n/*\n** Execute a step of a float numerical for loop, returning\n** true iff the loop must continue. (The integer case is\n** written online with opcode OP_FORLOOP, for performance.)\n*/\nstatic int floatforloop (StkId ra) {\n  lua_Number step = fltvalue(s2v(ra + 1));\n  lua_Number limit = fltvalue(s2v(ra));\n  lua_Number idx = fltvalue(s2v(ra + 2));  /* control variable */\n  idx = luai_numadd(L, idx, step);  /* increment index */\n  if (luai_numlt(0, step) ? luai_numle(idx, limit)\n                          : luai_numle(limit, idx)) {\n    chgfltvalue(s2v(ra + 2), idx);  /* update control variable */\n    return 1;  /* jump back */\n  }\n  else\n    return 0;  /* finish the loop */\n}\n\n\n/*\n** Finish the table access 'val = t[key]' and return the tag of the result.\n*/\nlu_byte luaV_finishget (lua_State *L, const TValue *t, TValue *key,\n                                      StkId val, lu_byte tag) {\n  int loop;  /* counter to avoid infinite loops */\n  const TValue *tm;  /* metamethod */\n  for (loop = 0; loop < MAXTAGLOOP; loop++) {\n    if (tag == LUA_VNOTABLE) {  /* 't' is not a table? */\n      lua_assert(!ttistable(t));\n      tm = luaT_gettmbyobj(L, t, TM_INDEX);\n      if (l_unlikely(notm(tm)))\n        luaG_typeerror(L, t, \"index\");  /* no metamethod */\n      /* else will try the metamethod */\n    }\n    else {  /* 't' is a table */\n      tm = fasttm(L, hvalue(t)->metatable, TM_INDEX);  /* table's metamethod */\n      if (tm == NULL) {  /* no metamethod? */\n        setnilvalue(s2v(val));  /* result is nil */\n        return LUA_VNIL;\n      }\n      /* else will try the metamethod */\n    }\n    if (ttisfunction(tm)) {  /* is metamethod a function? */\n      tag = luaT_callTMres(L, tm, t, key, val);  /* call it */\n      return tag;  /* return tag of the result */\n    }\n    t = tm;  /* else try to access 'tm[key]' */\n    luaV_fastget(t, key, s2v(val), luaH_get, tag);\n    if (!tagisempty(tag))\n      return tag;  /* done */\n    /* else repeat (tail call 'luaV_finishget') */\n  }\n  luaG_runerror(L, \"'__index' chain too long; possible loop\");\n  return 0;  /* to avoid warnings */\n}\n\n\n/*\n** Finish a table assignment 't[key] = val'.\n*/\nvoid luaV_finishset (lua_State *L, const TValue *t, TValue *key,\n                      TValue *val, int hres) {\n  int loop;  /* counter to avoid infinite loops */\n  for (loop = 0; loop < MAXTAGLOOP; loop++) {\n    const TValue *tm;  /* '__newindex' metamethod */\n    if (hres != HNOTATABLE) {  /* is 't' a table? */\n      Table *h = hvalue(t);  /* save 't' table */\n      tm = fasttm(L, h->metatable, TM_NEWINDEX);  /* get metamethod */\n      if (tm == NULL) {  /* no metamethod? */\n        luaH_finishset(L, h, key, val, hres);  /* set new value */\n        invalidateTMcache(h);\n        luaC_barrierback(L, obj2gco(h), val);\n        return;\n      }\n      /* else will try the metamethod */\n    }\n    else {  /* not a table; check metamethod */\n      tm = luaT_gettmbyobj(L, t, TM_NEWINDEX);\n      if (l_unlikely(notm(tm)))\n        luaG_typeerror(L, t, \"index\");\n    }\n    /* try the metamethod */\n    if (ttisfunction(tm)) {\n      luaT_callTM(L, tm, t, key, val);\n      return;\n    }\n    t = tm;  /* else repeat assignment over 'tm' */\n    luaV_fastset(t, key, val, hres, luaH_pset);\n    if (hres == HOK)\n      return;  /* done */\n    /* else 'return luaV_finishset(L, t, key, val, slot)' (loop) */\n  }\n  luaG_runerror(L, \"'__newindex' chain too long; possible loop\");\n}\n\n\n/*\n** Compare two strings 'ts1' x 'ts2', returning an integer less-equal-\n** -greater than zero if 'ts1' is less-equal-greater than 'ts2'.\n** The code is a little tricky because it allows '\\0' in the strings\n** and it uses 'strcoll' (to respect locales) for each segment\n** of the strings. Note that segments can compare equal but still\n** have different lengths.\n*/\nstatic int l_strcmp (const TString *ts1, const TString *ts2) {\n  size_t rl1;  /* real length */\n  const char *s1 = getlstr(ts1, rl1);\n  size_t rl2;\n  const char *s2 = getlstr(ts2, rl2);\n  for (;;) {  /* for each segment */\n    int temp = strcoll(s1, s2);\n    if (temp != 0)  /* not equal? */\n      return temp;  /* done */\n    else {  /* strings are equal up to a '\\0' */\n      size_t zl1 = strlen(s1);  /* index of first '\\0' in 's1' */\n      size_t zl2 = strlen(s2);  /* index of first '\\0' in 's2' */\n      if (zl2 == rl2)  /* 's2' is finished? */\n        return (zl1 == rl1) ? 0 : 1;  /* check 's1' */\n      else if (zl1 == rl1)  /* 's1' is finished? */\n        return -1;  /* 's1' is less than 's2' ('s2' is not finished) */\n      /* both strings longer than 'zl'; go on comparing after the '\\0' */\n      zl1++; zl2++;\n      s1 += zl1; rl1 -= zl1; s2 += zl2; rl2 -= zl2;\n    }\n  }\n}\n\n\n/*\n** Check whether integer 'i' is less than float 'f'. If 'i' has an\n** exact representation as a float ('l_intfitsf'), compare numbers as\n** floats. Otherwise, use the equivalence 'i < f <=> i < ceil(f)'.\n** If 'ceil(f)' is out of integer range, either 'f' is greater than\n** all integers or less than all integers.\n** (The test with 'l_intfitsf' is only for performance; the else\n** case is correct for all values, but it is slow due to the conversion\n** from float to int.)\n** When 'f' is NaN, comparisons must result in false.\n*/\nl_sinline int LTintfloat (lua_Integer i, lua_Number f) {\n  if (l_intfitsf(i))\n    return luai_numlt(cast_num(i), f);  /* compare them as floats */\n  else {  /* i < f <=> i < ceil(f) */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Iceil))  /* fi = ceil(f) */\n      return i < fi;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f > 0;  /* greater? */\n  }\n}\n\n\n/*\n** Check whether integer 'i' is less than or equal to float 'f'.\n** See comments on previous function.\n*/\nl_sinline int LEintfloat (lua_Integer i, lua_Number f) {\n  if (l_intfitsf(i))\n    return luai_numle(cast_num(i), f);  /* compare them as floats */\n  else {  /* i <= f <=> i <= floor(f) */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Ifloor))  /* fi = floor(f) */\n      return i <= fi;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f > 0;  /* greater? */\n  }\n}\n\n\n/*\n** Check whether float 'f' is less than integer 'i'.\n** See comments on previous function.\n*/\nl_sinline int LTfloatint (lua_Number f, lua_Integer i) {\n  if (l_intfitsf(i))\n    return luai_numlt(f, cast_num(i));  /* compare them as floats */\n  else {  /* f < i <=> floor(f) < i */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Ifloor))  /* fi = floor(f) */\n      return fi < i;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f < 0;  /* less? */\n  }\n}\n\n\n/*\n** Check whether float 'f' is less than or equal to integer 'i'.\n** See comments on previous function.\n*/\nl_sinline int LEfloatint (lua_Number f, lua_Integer i) {\n  if (l_intfitsf(i))\n    return luai_numle(f, cast_num(i));  /* compare them as floats */\n  else {  /* f <= i <=> ceil(f) <= i */\n    lua_Integer fi;\n    if (luaV_flttointeger(f, &fi, F2Iceil))  /* fi = ceil(f) */\n      return fi <= i;   /* compare them as integers */\n    else  /* 'f' is either greater or less than all integers */\n      return f < 0;  /* less? */\n  }\n}\n\n\n/*\n** Return 'l < r', for numbers.\n*/\nl_sinline int LTnum (const TValue *l, const TValue *r) {\n  lua_assert(ttisnumber(l) && ttisnumber(r));\n  if (ttisinteger(l)) {\n    lua_Integer li = ivalue(l);\n    if (ttisinteger(r))\n      return li < ivalue(r);  /* both are integers */\n    else  /* 'l' is int and 'r' is float */\n      return LTintfloat(li, fltvalue(r));  /* l < r ? */\n  }\n  else {\n    lua_Number lf = fltvalue(l);  /* 'l' must be float */\n    if (ttisfloat(r))\n      return luai_numlt(lf, fltvalue(r));  /* both are float */\n    else  /* 'l' is float and 'r' is int */\n      return LTfloatint(lf, ivalue(r));\n  }\n}\n\n\n/*\n** Return 'l <= r', for numbers.\n*/\nl_sinline int LEnum (const TValue *l, const TValue *r) {\n  lua_assert(ttisnumber(l) && ttisnumber(r));\n  if (ttisinteger(l)) {\n    lua_Integer li = ivalue(l);\n    if (ttisinteger(r))\n      return li <= ivalue(r);  /* both are integers */\n    else  /* 'l' is int and 'r' is float */\n      return LEintfloat(li, fltvalue(r));  /* l <= r ? */\n  }\n  else {\n    lua_Number lf = fltvalue(l);  /* 'l' must be float */\n    if (ttisfloat(r))\n      return luai_numle(lf, fltvalue(r));  /* both are float */\n    else  /* 'l' is float and 'r' is int */\n      return LEfloatint(lf, ivalue(r));\n  }\n}\n\n\n/*\n** return 'l < r' for non-numbers.\n*/\nstatic int lessthanothers (lua_State *L, const TValue *l, const TValue *r) {\n  lua_assert(!ttisnumber(l) || !ttisnumber(r));\n  if (ttisstring(l) && ttisstring(r))  /* both are strings? */\n    return l_strcmp(tsvalue(l), tsvalue(r)) < 0;\n  else\n    return luaT_callorderTM(L, l, r, TM_LT);\n}\n\n\n/*\n** Main operation less than; return 'l < r'.\n*/\nint luaV_lessthan (lua_State *L, const TValue *l, const TValue *r) {\n  if (ttisnumber(l) && ttisnumber(r))  /* both operands are numbers? */\n    return LTnum(l, r);\n  else return lessthanothers(L, l, r);\n}\n\n\n/*\n** return 'l <= r' for non-numbers.\n*/\nstatic int lessequalothers (lua_State *L, const TValue *l, const TValue *r) {\n  lua_assert(!ttisnumber(l) || !ttisnumber(r));\n  if (ttisstring(l) && ttisstring(r))  /* both are strings? */\n    return l_strcmp(tsvalue(l), tsvalue(r)) <= 0;\n  else\n    return luaT_callorderTM(L, l, r, TM_LE);\n}\n\n\n/*\n** Main operation less than or equal to; return 'l <= r'.\n*/\nint luaV_lessequal (lua_State *L, const TValue *l, const TValue *r) {\n  if (ttisnumber(l) && ttisnumber(r))  /* both operands are numbers? */\n    return LEnum(l, r);\n  else return lessequalothers(L, l, r);\n}\n\n\n/*\n** Main operation for equality of Lua values; return 't1 == t2'.\n** L == NULL means raw equality (no metamethods)\n*/\nint luaV_equalobj (lua_State *L, const TValue *t1, const TValue *t2) {\n  const TValue *tm;\n  if (ttypetag(t1) != ttypetag(t2)) {  /* not the same variant? */\n    if (ttype(t1) != ttype(t2) || ttype(t1) != LUA_TNUMBER)\n      return 0;  /* only numbers can be equal with different variants */\n    else {  /* two numbers with different variants */\n      /* One of them is an integer. If the other does not have an\n         integer value, they cannot be equal; otherwise, compare their\n         integer values. */\n      lua_Integer i1, i2;\n      return (luaV_tointegerns(t1, &i1, F2Ieq) &&\n              luaV_tointegerns(t2, &i2, F2Ieq) &&\n              i1 == i2);\n    }\n  }\n  /* values have same type and same variant */\n  switch (ttypetag(t1)) {\n    case LUA_VNIL: case LUA_VFALSE: case LUA_VTRUE: return 1;\n    case LUA_VNUMINT: return (ivalue(t1) == ivalue(t2));\n    case LUA_VNUMFLT: return luai_numeq(fltvalue(t1), fltvalue(t2));\n    case LUA_VLIGHTUSERDATA: return pvalue(t1) == pvalue(t2);\n    case LUA_VLCF: return fvalue(t1) == fvalue(t2);\n    case LUA_VSHRSTR: return eqshrstr(tsvalue(t1), tsvalue(t2));\n    case LUA_VLNGSTR: return luaS_eqlngstr(tsvalue(t1), tsvalue(t2));\n    case LUA_VUSERDATA: {\n      if (uvalue(t1) == uvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = fasttm(L, uvalue(t1)->metatable, TM_EQ);\n      if (tm == NULL)\n        tm = fasttm(L, uvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    case LUA_VTABLE: {\n      if (hvalue(t1) == hvalue(t2)) return 1;\n      else if (L == NULL) return 0;\n      tm = fasttm(L, hvalue(t1)->metatable, TM_EQ);\n      if (tm == NULL)\n        tm = fasttm(L, hvalue(t2)->metatable, TM_EQ);\n      break;  /* will try TM */\n    }\n    default:\n      return gcvalue(t1) == gcvalue(t2);\n  }\n  if (tm == NULL)  /* no TM? */\n    return 0;  /* objects are different */\n  else {\n    int tag = luaT_callTMres(L, tm, t1, t2, L->top.p);  /* call TM */\n    return !tagisfalse(tag);\n  }\n}\n\n\n/* macro used by 'luaV_concat' to ensure that element at 'o' is a string */\n#define tostring(L,o)  \\\n\t(ttisstring(o) || (cvt2str(o) && (luaO_tostring(L, o), 1)))\n\n#define isemptystr(o)\t(ttisshrstring(o) && tsvalue(o)->shrlen == 0)\n\n/* copy strings in stack from top - n up to top - 1 to buffer */\nstatic void copy2buff (StkId top, int n, char *buff) {\n  size_t tl = 0;  /* size already copied */\n  do {\n    TString *st = tsvalue(s2v(top - n));\n    size_t l;  /* length of string being copied */\n    const char *s = getlstr(st, l);\n    memcpy(buff + tl, s, l * sizeof(char));\n    tl += l;\n  } while (--n > 0);\n}\n\n\n/*\n** Main operation for concatenation: concat 'total' values in the stack,\n** from 'L->top.p - total' up to 'L->top.p - 1'.\n*/\nvoid luaV_concat (lua_State *L, int total) {\n  if (total == 1)\n    return;  /* \"all\" values already concatenated */\n  do {\n    StkId top = L->top.p;\n    int n = 2;  /* number of elements handled in this pass (at least 2) */\n    if (!(ttisstring(s2v(top - 2)) || cvt2str(s2v(top - 2))) ||\n        !tostring(L, s2v(top - 1)))\n      luaT_tryconcatTM(L);  /* may invalidate 'top' */\n    else if (isemptystr(s2v(top - 1)))  /* second operand is empty? */\n      cast_void(tostring(L, s2v(top - 2)));  /* result is first operand */\n    else if (isemptystr(s2v(top - 2))) {  /* first operand is empty string? */\n      setobjs2s(L, top - 2, top - 1);  /* result is second op. */\n    }\n    else {\n      /* at least two non-empty string values; get as many as possible */\n      size_t tl = tsslen(tsvalue(s2v(top - 1)));\n      TString *ts;\n      /* collect total length and number of strings */\n      for (n = 1; n < total && tostring(L, s2v(top - n - 1)); n++) {\n        size_t l = tsslen(tsvalue(s2v(top - n - 1)));\n        if (l_unlikely(l >= MAX_SIZE - sizeof(TString) - tl)) {\n          L->top.p = top - total;  /* pop strings to avoid wasting stack */\n          luaG_runerror(L, \"string length overflow\");\n        }\n        tl += l;\n      }\n      if (tl <= LUAI_MAXSHORTLEN) {  /* is result a short string? */\n        char buff[LUAI_MAXSHORTLEN];\n        copy2buff(top, n, buff);  /* copy strings to buffer */\n        ts = luaS_newlstr(L, buff, tl);\n      }\n      else {  /* long string; copy strings directly to final result */\n        ts = luaS_createlngstrobj(L, tl);\n        copy2buff(top, n, getlngstr(ts));\n      }\n      setsvalue2s(L, top - n, ts);  /* create result */\n    }\n    total -= n - 1;  /* got 'n' strings to create one new */\n    L->top.p -= n - 1;  /* popped 'n' strings and pushed one */\n  } while (total > 1);  /* repeat until only 1 result left */\n}\n\n\n/*\n** Main operation 'ra = #rb'.\n*/\nvoid luaV_objlen (lua_State *L, StkId ra, const TValue *rb) {\n  const TValue *tm;\n  switch (ttypetag(rb)) {\n    case LUA_VTABLE: {\n      Table *h = hvalue(rb);\n      tm = fasttm(L, h->metatable, TM_LEN);\n      if (tm) break;  /* metamethod? break switch to call it */\n      setivalue(s2v(ra), l_castU2S(luaH_getn(h)));  /* else primitive len */\n      return;\n    }\n    case LUA_VSHRSTR: {\n      setivalue(s2v(ra), tsvalue(rb)->shrlen);\n      return;\n    }\n    case LUA_VLNGSTR: {\n      setivalue(s2v(ra), cast_st2S(tsvalue(rb)->u.lnglen));\n      return;\n    }\n    default: {  /* try metamethod */\n      tm = luaT_gettmbyobj(L, rb, TM_LEN);\n      if (l_unlikely(notm(tm)))  /* no metamethod? */\n        luaG_typeerror(L, rb, \"get length of\");\n      break;\n    }\n  }\n  luaT_callTMres(L, tm, rb, rb, ra);\n}\n\n\n/*\n** Integer division; return 'm // n', that is, floor(m/n).\n** C division truncates its result (rounds towards zero).\n** 'floor(q) == trunc(q)' when 'q >= 0' or when 'q' is integer,\n** otherwise 'floor(q) == trunc(q) - 1'.\n*/\nlua_Integer luaV_idiv (lua_State *L, lua_Integer m, lua_Integer n) {\n  if (l_unlikely(l_castS2U(n) + 1u <= 1u)) {  /* special cases: -1 or 0 */\n    if (n == 0)\n      luaG_runerror(L, \"attempt to divide by zero\");\n    return intop(-, 0, m);   /* n==-1; avoid overflow with 0x80000...//-1 */\n  }\n  else {\n    lua_Integer q = m / n;  /* perform C division */\n    if ((m ^ n) < 0 && m % n != 0)  /* 'm/n' would be negative non-integer? */\n      q -= 1;  /* correct result for different rounding */\n    return q;\n  }\n}\n\n\n/*\n** Integer modulus; return 'm % n'. (Assume that C '%' with\n** negative operands follows C99 behavior. See previous comment\n** about luaV_idiv.)\n*/\nlua_Integer luaV_mod (lua_State *L, lua_Integer m, lua_Integer n) {\n  if (l_unlikely(l_castS2U(n) + 1u <= 1u)) {  /* special cases: -1 or 0 */\n    if (n == 0)\n      luaG_runerror(L, \"attempt to perform 'n%%0'\");\n    return 0;   /* m % -1 == 0; avoid overflow with 0x80000...%-1 */\n  }\n  else {\n    lua_Integer r = m % n;\n    if (r != 0 && (r ^ n) < 0)  /* 'm/n' would be non-integer negative? */\n      r += n;  /* correct result for different rounding */\n    return r;\n  }\n}\n\n\n/*\n** Float modulus\n*/\nlua_Number luaV_modf (lua_State *L, lua_Number m, lua_Number n) {\n  lua_Number r;\n  luai_nummod(L, m, n, r);\n  return r;\n}\n\n\n/* number of bits in an integer */\n#define NBITS\tcast_int(sizeof(lua_Integer) * CHAR_BIT)\n\n\n/*\n** Shift left operation. (Shift right just negates 'y'.)\n*/\nlua_Integer luaV_shiftl (lua_Integer x, lua_Integer y) {\n  if (y < 0) {  /* shift right? */\n    if (y <= -NBITS) return 0;\n    else return intop(>>, x, -y);\n  }\n  else {  /* shift left */\n    if (y >= NBITS) return 0;\n    else return intop(<<, x, y);\n  }\n}\n\n\n/*\n** create a new Lua closure, push it in the stack, and initialize\n** its upvalues.\n*/\nstatic void pushclosure (lua_State *L, Proto *p, UpVal **encup, StkId base,\n                         StkId ra) {\n  int nup = p->sizeupvalues;\n  Upvaldesc *uv = p->upvalues;\n  int i;\n  LClosure *ncl = luaF_newLclosure(L, nup);\n  ncl->p = p;\n  setclLvalue2s(L, ra, ncl);  /* anchor new closure in stack */\n  for (i = 0; i < nup; i++) {  /* fill in its upvalues */\n    if (uv[i].instack)  /* upvalue refers to local variable? */\n      ncl->upvals[i] = luaF_findupval(L, base + uv[i].idx);\n    else  /* get upvalue from enclosing function */\n      ncl->upvals[i] = encup[uv[i].idx];\n    luaC_objbarrier(L, ncl, ncl->upvals[i]);\n  }\n}\n\n\n/*\n** finish execution of an opcode interrupted by a yield\n*/\nvoid luaV_finishOp (lua_State *L) {\n  CallInfo *ci = L->ci;\n  StkId base = ci->func.p + 1;\n  Instruction inst = *(ci->u.l.savedpc - 1);  /* interrupted instruction */\n  OpCode op = GET_OPCODE(inst);\n  switch (op) {  /* finish its execution */\n    case OP_MMBIN: case OP_MMBINI: case OP_MMBINK: {\n      setobjs2s(L, base + GETARG_A(*(ci->u.l.savedpc - 2)), --L->top.p);\n      break;\n    }\n    case OP_UNM: case OP_BNOT: case OP_LEN:\n    case OP_GETTABUP: case OP_GETTABLE: case OP_GETI:\n    case OP_GETFIELD: case OP_SELF: {\n      setobjs2s(L, base + GETARG_A(inst), --L->top.p);\n      break;\n    }\n    case OP_LT: case OP_LE:\n    case OP_LTI: case OP_LEI:\n    case OP_GTI: case OP_GEI:\n    case OP_EQ: {  /* note that 'OP_EQI'/'OP_EQK' cannot yield */\n      int res = !l_isfalse(s2v(L->top.p - 1));\n      L->top.p--;\n#if defined(LUA_COMPAT_LT_LE)\n      if (ci->callstatus & CIST_LEQ) {  /* \"<=\" using \"<\" instead? */\n        ci->callstatus ^= CIST_LEQ;  /* clear mark */\n        res = !res;  /* negate result */\n      }\n#endif\n      lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_JMP);\n      if (res != GETARG_k(inst))  /* condition failed? */\n        ci->u.l.savedpc++;  /* skip jump instruction */\n      break;\n    }\n    case OP_CONCAT: {\n      StkId top = L->top.p - 1;  /* top when 'luaT_tryconcatTM' was called */\n      int a = GETARG_A(inst);      /* first element to concatenate */\n      int total = cast_int(top - 1 - (base + a));  /* yet to concatenate */\n      setobjs2s(L, top - 2, top);  /* put TM result in proper position */\n      L->top.p = top - 1;  /* top is one after last element (at top-2) */\n      luaV_concat(L, total);  /* concat them (may yield again) */\n      break;\n    }\n    case OP_CLOSE: {  /* yielded closing variables */\n      ci->u.l.savedpc--;  /* repeat instruction to close other vars. */\n      break;\n    }\n    case OP_RETURN: {  /* yielded closing variables */\n      StkId ra = base + GETARG_A(inst);\n      /* adjust top to signal correct number of returns, in case the\n         return is \"up to top\" ('isIT') */\n      L->top.p = ra + ci->u2.nres;\n      /* repeat instruction to close other vars. and complete the return */\n      ci->u.l.savedpc--;\n      break;\n    }\n    default: {\n      /* only these other opcodes can yield */\n      lua_assert(op == OP_TFORCALL || op == OP_CALL ||\n           op == OP_TAILCALL || op == OP_SETTABUP || op == OP_SETTABLE ||\n           op == OP_SETI || op == OP_SETFIELD);\n      break;\n    }\n  }\n}\n\n\n\n\n/*\n** {==================================================================\n** Macros for arithmetic/bitwise/comparison opcodes in 'luaV_execute'\n** ===================================================================\n*/\n\n#define l_addi(L,a,b)\tintop(+, a, b)\n#define l_subi(L,a,b)\tintop(-, a, b)\n#define l_muli(L,a,b)\tintop(*, a, b)\n#define l_band(a,b)\tintop(&, a, b)\n#define l_bor(a,b)\tintop(|, a, b)\n#define l_bxor(a,b)\tintop(^, a, b)\n\n#define l_lti(a,b)\t(a < b)\n#define l_lei(a,b)\t(a <= b)\n#define l_gti(a,b)\t(a > b)\n#define l_gei(a,b)\t(a >= b)\n\n\n/*\n** Arithmetic operations with immediate operands. 'iop' is the integer\n** operation, 'fop' is the float operation.\n*/\n#define op_arithI(L,iop,fop) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  int imm = GETARG_sC(i);  \\\n  if (ttisinteger(v1)) {  \\\n    lua_Integer iv1 = ivalue(v1);  \\\n    pc++; setivalue(s2v(ra), iop(L, iv1, imm));  \\\n  }  \\\n  else if (ttisfloat(v1)) {  \\\n    lua_Number nb = fltvalue(v1);  \\\n    lua_Number fimm = cast_num(imm);  \\\n    pc++; setfltvalue(s2v(ra), fop(L, nb, fimm)); \\\n  }}\n\n\n/*\n** Auxiliary function for arithmetic operations over floats and others\n** with two operands.\n*/\n#define op_arithf_aux(L,v1,v2,fop) {  \\\n  lua_Number n1; lua_Number n2;  \\\n  if (tonumberns(v1, n1) && tonumberns(v2, n2)) {  \\\n    pc++; setfltvalue(s2v(ra), fop(L, n1, n2));  \\\n  }}\n\n\n/*\n** Arithmetic operations over floats and others with register operands.\n*/\n#define op_arithf(L,fop) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = vRC(i);  \\\n  op_arithf_aux(L, v1, v2, fop); }\n\n\n/*\n** Arithmetic operations with K operands for floats.\n*/\n#define op_arithfK(L,fop) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = KC(i); lua_assert(ttisnumber(v2));  \\\n  op_arithf_aux(L, v1, v2, fop); }\n\n\n/*\n** Arithmetic operations over integers and floats.\n*/\n#define op_arith_aux(L,v1,v2,iop,fop) {  \\\n  StkId ra = RA(i); \\\n  if (ttisinteger(v1) && ttisinteger(v2)) {  \\\n    lua_Integer i1 = ivalue(v1); lua_Integer i2 = ivalue(v2);  \\\n    pc++; setivalue(s2v(ra), iop(L, i1, i2));  \\\n  }  \\\n  else op_arithf_aux(L, v1, v2, fop); }\n\n\n/*\n** Arithmetic operations with register operands.\n*/\n#define op_arith(L,iop,fop) {  \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = vRC(i);  \\\n  op_arith_aux(L, v1, v2, iop, fop); }\n\n\n/*\n** Arithmetic operations with K operands.\n*/\n#define op_arithK(L,iop,fop) {  \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = KC(i); lua_assert(ttisnumber(v2));  \\\n  op_arith_aux(L, v1, v2, iop, fop); }\n\n\n/*\n** Bitwise operations with constant operand.\n*/\n#define op_bitwiseK(L,op) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = KC(i);  \\\n  lua_Integer i1;  \\\n  lua_Integer i2 = ivalue(v2);  \\\n  if (tointegerns(v1, &i1)) {  \\\n    pc++; setivalue(s2v(ra), op(i1, i2));  \\\n  }}\n\n\n/*\n** Bitwise operations with register operands.\n*/\n#define op_bitwise(L,op) {  \\\n  StkId ra = RA(i); \\\n  TValue *v1 = vRB(i);  \\\n  TValue *v2 = vRC(i);  \\\n  lua_Integer i1; lua_Integer i2;  \\\n  if (tointegerns(v1, &i1) && tointegerns(v2, &i2)) {  \\\n    pc++; setivalue(s2v(ra), op(i1, i2));  \\\n  }}\n\n\n/*\n** Order operations with register operands. 'opn' actually works\n** for all numbers, but the fast track improves performance for\n** integers.\n*/\n#define op_order(L,opi,opn,other) {  \\\n  StkId ra = RA(i); \\\n  int cond;  \\\n  TValue *rb = vRB(i);  \\\n  if (ttisinteger(s2v(ra)) && ttisinteger(rb)) {  \\\n    lua_Integer ia = ivalue(s2v(ra));  \\\n    lua_Integer ib = ivalue(rb);  \\\n    cond = opi(ia, ib);  \\\n  }  \\\n  else if (ttisnumber(s2v(ra)) && ttisnumber(rb))  \\\n    cond = opn(s2v(ra), rb);  \\\n  else  \\\n    Protect(cond = other(L, s2v(ra), rb));  \\\n  docondjump(); }\n\n\n/*\n** Order operations with immediate operand. (Immediate operand is\n** always small enough to have an exact representation as a float.)\n*/\n#define op_orderI(L,opi,opf,inv,tm) {  \\\n  StkId ra = RA(i); \\\n  int cond;  \\\n  int im = GETARG_sB(i);  \\\n  if (ttisinteger(s2v(ra)))  \\\n    cond = opi(ivalue(s2v(ra)), im);  \\\n  else if (ttisfloat(s2v(ra))) {  \\\n    lua_Number fa = fltvalue(s2v(ra));  \\\n    lua_Number fim = cast_num(im);  \\\n    cond = opf(fa, fim);  \\\n  }  \\\n  else {  \\\n    int isf = GETARG_C(i);  \\\n    Protect(cond = luaT_callorderiTM(L, s2v(ra), im, inv, isf, tm));  \\\n  }  \\\n  docondjump(); }\n\n/* }================================================================== */\n\n\n/*\n** {==================================================================\n** Function 'luaV_execute': main interpreter loop\n** ===================================================================\n*/\n\n/*\n** some macros for common tasks in 'luaV_execute'\n*/\n\n\n#define RA(i)\t(base+GETARG_A(i))\n#define RB(i)\t(base+GETARG_B(i))\n#define vRB(i)\ts2v(RB(i))\n#define KB(i)\t(k+GETARG_B(i))\n#define RC(i)\t(base+GETARG_C(i))\n#define vRC(i)\ts2v(RC(i))\n#define KC(i)\t(k+GETARG_C(i))\n#define RKC(i)\t((TESTARG_k(i)) ? k + GETARG_C(i) : s2v(base + GETARG_C(i)))\n\n\n\n#define updatetrap(ci)  (trap = ci->u.l.trap)\n\n#define updatebase(ci)\t(base = ci->func.p + 1)\n\n\n#define updatestack(ci)  \\\n\t{ if (l_unlikely(trap)) { updatebase(ci); ra = RA(i); } }\n\n\n/*\n** Execute a jump instruction. The 'updatetrap' allows signals to stop\n** tight loops. (Without it, the local copy of 'trap' could never change.)\n*/\n#define dojump(ci,i,e)\t{ pc += GETARG_sJ(i) + e; updatetrap(ci); }\n\n\n/* for test instructions, execute the jump instruction that follows it */\n#define donextjump(ci)\t{ Instruction ni = *pc; dojump(ci, ni, 1); }\n\n/*\n** do a conditional jump: skip next instruction if 'cond' is not what\n** was expected (parameter 'k'), else do next instruction, which must\n** be a jump.\n*/\n#define docondjump()\tif (cond != GETARG_k(i)) pc++; else donextjump(ci);\n\n\n/*\n** Correct global 'pc'.\n*/\n#define savepc(L)\t(ci->u.l.savedpc = pc)\n\n\n/*\n** Whenever code can raise errors, the global 'pc' and the global\n** 'top' must be correct to report occasional errors.\n*/\n#define savestate(L,ci)\t\t(savepc(L), L->top.p = ci->top.p)\n\n\n/*\n** Protect code that, in general, can raise errors, reallocate the\n** stack, and change the hooks.\n*/\n#define Protect(exp)  (savestate(L,ci), (exp), updatetrap(ci))\n\n/* special version that does not change the top */\n#define ProtectNT(exp)  (savepc(L), (exp), updatetrap(ci))\n\n/*\n** Protect code that can only raise errors. (That is, it cannot change\n** the stack or hooks.)\n*/\n#define halfProtect(exp)  (savestate(L,ci), (exp))\n\n/*\n** macro executed during Lua functions at points where the\n** function can yield.\n*/\n#if !defined(luai_threadyield)\n#define luai_threadyield(L)\t{lua_unlock(L); lua_lock(L);}\n#endif\n\n/* 'c' is the limit of live values in the stack */\n#define checkGC(L,c)  \\\n\t{ luaC_condGC(L, (savepc(L), L->top.p = (c)), \\\n                         updatetrap(ci)); \\\n           luai_threadyield(L); }\n\n\n/* fetch an instruction and prepare its execution */\n#define vmfetch()\t{ \\\n  if (l_unlikely(trap)) {  /* stack reallocation or hooks? */ \\\n    trap = luaG_traceexec(L, pc);  /* handle hooks */ \\\n    updatebase(ci);  /* correct stack */ \\\n  } \\\n  i = *(pc++); \\\n}\n\n#define vmdispatch(o)\tswitch(o)\n#define vmcase(l)\tcase l:\n#define vmbreak\t\tbreak\n\n\nvoid luaV_execute (lua_State *L, CallInfo *ci) {\n  LClosure *cl;\n  TValue *k;\n  StkId base;\n  const Instruction *pc;\n  int trap;\n#if LUA_USE_JUMPTABLE\n#include \"ljumptab.h\"\n#endif\n startfunc:\n  trap = L->hookmask;\n returning:  /* trap already set */\n  cl = ci_func(ci);\n  k = cl->p->k;\n  pc = ci->u.l.savedpc;\n  if (l_unlikely(trap))\n    trap = luaG_tracecall(L);\n  base = ci->func.p + 1;\n  /* main loop of interpreter */\n  for (;;) {\n    Instruction i;  /* instruction being executed */\n    vmfetch();\n    #if 0\n      /* low-level line tracing for debugging Lua */\n      printf(\"line: %d\\n\", luaG_getfuncline(cl->p, pcRel(pc, cl->p)));\n    #endif\n    lua_assert(base == ci->func.p + 1);\n    lua_assert(base <= L->top.p && L->top.p <= L->stack_last.p);\n    /* for tests, invalidate top for instructions not expecting it */\n    lua_assert(luaP_isIT(i) || (cast_void(L->top.p = base), 1));\n    vmdispatch (GET_OPCODE(i)) {\n      vmcase(OP_MOVE) {\n        StkId ra = RA(i);\n        setobjs2s(L, ra, RB(i));\n        vmbreak;\n      }\n      vmcase(OP_LOADI) {\n        StkId ra = RA(i);\n        lua_Integer b = GETARG_sBx(i);\n        setivalue(s2v(ra), b);\n        vmbreak;\n      }\n      vmcase(OP_LOADF) {\n        StkId ra = RA(i);\n        int b = GETARG_sBx(i);\n        setfltvalue(s2v(ra), cast_num(b));\n        vmbreak;\n      }\n      vmcase(OP_LOADK) {\n        StkId ra = RA(i);\n        TValue *rb = k + GETARG_Bx(i);\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADKX) {\n        StkId ra = RA(i);\n        TValue *rb;\n        rb = k + GETARG_Ax(*pc); pc++;\n        setobj2s(L, ra, rb);\n        vmbreak;\n      }\n      vmcase(OP_LOADFALSE) {\n        StkId ra = RA(i);\n        setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LFALSESKIP) {\n        StkId ra = RA(i);\n        setbfvalue(s2v(ra));\n        pc++;  /* skip next instruction */\n        vmbreak;\n      }\n      vmcase(OP_LOADTRUE) {\n        StkId ra = RA(i);\n        setbtvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LOADNIL) {\n        StkId ra = RA(i);\n        int b = GETARG_B(i);\n        do {\n          setnilvalue(s2v(ra++));\n        } while (b--);\n        vmbreak;\n      }\n      vmcase(OP_GETUPVAL) {\n        StkId ra = RA(i);\n        int b = GETARG_B(i);\n        setobj2s(L, ra, cl->upvals[b]->v.p);\n        vmbreak;\n      }\n      vmcase(OP_SETUPVAL) {\n        StkId ra = RA(i);\n        UpVal *uv = cl->upvals[GETARG_B(i)];\n        setobj(L, uv->v.p, s2v(ra));\n        luaC_barrier(L, uv, s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_GETTABUP) {\n        StkId ra = RA(i);\n        TValue *upval = cl->upvals[GETARG_B(i)]->v.p;\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a short string */\n        lu_byte tag;\n        luaV_fastget(upval, key, s2v(ra), luaH_getshortstr, tag);\n        if (tagisempty(tag))\n          Protect(luaV_finishget(L, upval, rc, ra, tag));\n        vmbreak;\n      }\n      vmcase(OP_GETTABLE) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        TValue *rc = vRC(i);\n        lu_byte tag;\n        if (ttisinteger(rc)) {  /* fast track for integers? */\n          luaV_fastgeti(rb, ivalue(rc), s2v(ra), tag);\n        }\n        else\n          luaV_fastget(rb, rc, s2v(ra), luaH_get, tag);\n        if (tagisempty(tag))\n          Protect(luaV_finishget(L, rb, rc, ra, tag));\n        vmbreak;\n      }\n      vmcase(OP_GETI) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        int c = GETARG_C(i);\n        lu_byte tag;\n        luaV_fastgeti(rb, c, s2v(ra), tag);\n        if (tagisempty(tag)) {\n          TValue key;\n          setivalue(&key, c);\n          Protect(luaV_finishget(L, rb, &key, ra, tag));\n        }\n        vmbreak;\n      }\n      vmcase(OP_GETFIELD) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        TValue *rc = KC(i);\n        TString *key = tsvalue(rc);  /* key must be a short string */\n        lu_byte tag;\n        luaV_fastget(rb, key, s2v(ra), luaH_getshortstr, tag);\n        if (tagisempty(tag))\n          Protect(luaV_finishget(L, rb, rc, ra, tag));\n        vmbreak;\n      }\n      vmcase(OP_SETTABUP) {\n        int hres;\n        TValue *upval = cl->upvals[GETARG_A(i)]->v.p;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a short string */\n        luaV_fastset(upval, key, rc, hres, luaH_psetshortstr);\n        if (hres == HOK)\n          luaV_finishfastset(L, upval, rc);\n        else\n          Protect(luaV_finishset(L, upval, rb, rc, hres));\n        vmbreak;\n      }\n      vmcase(OP_SETTABLE) {\n        StkId ra = RA(i);\n        int hres;\n        TValue *rb = vRB(i);  /* key (table is in 'ra') */\n        TValue *rc = RKC(i);  /* value */\n        if (ttisinteger(rb)) {  /* fast track for integers? */\n          luaV_fastseti(s2v(ra), ivalue(rb), rc, hres);\n        }\n        else {\n          luaV_fastset(s2v(ra), rb, rc, hres, luaH_pset);\n        }\n        if (hres == HOK)\n          luaV_finishfastset(L, s2v(ra), rc);\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, hres));\n        vmbreak;\n      }\n      vmcase(OP_SETI) {\n        StkId ra = RA(i);\n        int hres;\n        int b = GETARG_B(i);\n        TValue *rc = RKC(i);\n        luaV_fastseti(s2v(ra), b, rc, hres);\n        if (hres == HOK)\n          luaV_finishfastset(L, s2v(ra), rc);\n        else {\n          TValue key;\n          setivalue(&key, b);\n          Protect(luaV_finishset(L, s2v(ra), &key, rc, hres));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SETFIELD) {\n        StkId ra = RA(i);\n        int hres;\n        TValue *rb = KB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rb);  /* key must be a short string */\n        luaV_fastset(s2v(ra), key, rc, hres, luaH_psetshortstr);\n        if (hres == HOK)\n          luaV_finishfastset(L, s2v(ra), rc);\n        else\n          Protect(luaV_finishset(L, s2v(ra), rb, rc, hres));\n        vmbreak;\n      }\n      vmcase(OP_NEWTABLE) {\n        StkId ra = RA(i);\n        unsigned b = cast_uint(GETARG_vB(i));  /* log2(hash size) + 1 */\n        unsigned c = cast_uint(GETARG_vC(i));  /* array size */\n        Table *t;\n        if (b > 0)\n          b = 1u << (b - 1);  /* hash size is 2^(b - 1) */\n        if (TESTARG_k(i)) {  /* non-zero extra argument? */\n          lua_assert(GETARG_Ax(*pc) != 0);\n          /* add it to array size */\n          c += cast_uint(GETARG_Ax(*pc)) * (MAXARG_vC + 1);\n        }\n        pc++;  /* skip extra argument */\n        L->top.p = ra + 1;  /* correct top in case of emergency GC */\n        t = luaH_new(L);  /* memory allocation */\n        sethvalue2s(L, ra, t);\n        if (b != 0 || c != 0)\n          luaH_resize(L, t, c, b);  /* idem */\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_SELF) {\n        StkId ra = RA(i);\n        lu_byte tag;\n        TValue *rb = vRB(i);\n        TValue *rc = RKC(i);\n        TString *key = tsvalue(rc);  /* key must be a string */\n        setobj2s(L, ra + 1, rb);\n        luaV_fastget(rb, key, s2v(ra), luaH_getstr, tag);\n        if (tagisempty(tag))\n          Protect(luaV_finishget(L, rb, rc, ra, tag));\n        vmbreak;\n      }\n      vmcase(OP_ADDI) {\n        op_arithI(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_ADDK) {\n        op_arithK(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUBK) {\n        op_arithK(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MULK) {\n        op_arithK(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MODK) {\n        savestate(L, ci);  /* in case of division by 0 */\n        op_arithK(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POWK) {\n        op_arithfK(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIVK) {\n        op_arithfK(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIVK) {\n        savestate(L, ci);  /* in case of division by 0 */\n        op_arithK(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BANDK) {\n        op_bitwiseK(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BORK) {\n        op_bitwiseK(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXORK) {\n        op_bitwiseK(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHRI) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ib, -ic));\n        }\n        vmbreak;\n      }\n      vmcase(OP_SHLI) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        int ic = GETARG_sC(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          pc++; setivalue(s2v(ra), luaV_shiftl(ic, ib));\n        }\n        vmbreak;\n      }\n      vmcase(OP_ADD) {\n        op_arith(L, l_addi, luai_numadd);\n        vmbreak;\n      }\n      vmcase(OP_SUB) {\n        op_arith(L, l_subi, luai_numsub);\n        vmbreak;\n      }\n      vmcase(OP_MUL) {\n        op_arith(L, l_muli, luai_nummul);\n        vmbreak;\n      }\n      vmcase(OP_MOD) {\n        savestate(L, ci);  /* in case of division by 0 */\n        op_arith(L, luaV_mod, luaV_modf);\n        vmbreak;\n      }\n      vmcase(OP_POW) {\n        op_arithf(L, luai_numpow);\n        vmbreak;\n      }\n      vmcase(OP_DIV) {  /* float division (always with floats) */\n        op_arithf(L, luai_numdiv);\n        vmbreak;\n      }\n      vmcase(OP_IDIV) {  /* floor division */\n        savestate(L, ci);  /* in case of division by 0 */\n        op_arith(L, luaV_idiv, luai_numidiv);\n        vmbreak;\n      }\n      vmcase(OP_BAND) {\n        op_bitwise(L, l_band);\n        vmbreak;\n      }\n      vmcase(OP_BOR) {\n        op_bitwise(L, l_bor);\n        vmbreak;\n      }\n      vmcase(OP_BXOR) {\n        op_bitwise(L, l_bxor);\n        vmbreak;\n      }\n      vmcase(OP_SHR) {\n        op_bitwise(L, luaV_shiftr);\n        vmbreak;\n      }\n      vmcase(OP_SHL) {\n        op_bitwise(L, luaV_shiftl);\n        vmbreak;\n      }\n      vmcase(OP_MMBIN) {\n        StkId ra = RA(i);\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *rb = vRB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        StkId result = RA(pi);\n        lua_assert(OP_ADD <= GET_OPCODE(pi) && GET_OPCODE(pi) <= OP_SHR);\n        Protect(luaT_trybinTM(L, s2v(ra), rb, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINI) {\n        StkId ra = RA(i);\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        int imm = GETARG_sB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybiniTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_MMBINK) {\n        StkId ra = RA(i);\n        Instruction pi = *(pc - 2);  /* original arith. expression */\n        TValue *imm = KB(i);\n        TMS tm = (TMS)GETARG_C(i);\n        int flip = GETARG_k(i);\n        StkId result = RA(pi);\n        Protect(luaT_trybinassocTM(L, s2v(ra), imm, flip, result, tm));\n        vmbreak;\n      }\n      vmcase(OP_UNM) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        lua_Number nb;\n        if (ttisinteger(rb)) {\n          lua_Integer ib = ivalue(rb);\n          setivalue(s2v(ra), intop(-, 0, ib));\n        }\n        else if (tonumberns(rb, nb)) {\n          setfltvalue(s2v(ra), luai_numunm(L, nb));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_UNM));\n        vmbreak;\n      }\n      vmcase(OP_BNOT) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        lua_Integer ib;\n        if (tointegerns(rb, &ib)) {\n          setivalue(s2v(ra), intop(^, ~l_castS2U(0), ib));\n        }\n        else\n          Protect(luaT_trybinTM(L, rb, rb, ra, TM_BNOT));\n        vmbreak;\n      }\n      vmcase(OP_NOT) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb))\n          setbtvalue(s2v(ra));\n        else\n          setbfvalue(s2v(ra));\n        vmbreak;\n      }\n      vmcase(OP_LEN) {\n        StkId ra = RA(i);\n        Protect(luaV_objlen(L, ra, vRB(i)));\n        vmbreak;\n      }\n      vmcase(OP_CONCAT) {\n        StkId ra = RA(i);\n        int n = GETARG_B(i);  /* number of elements to concatenate */\n        L->top.p = ra + n;  /* mark the end of concat operands */\n        ProtectNT(luaV_concat(L, n));\n        checkGC(L, L->top.p); /* 'luaV_concat' ensures correct top */\n        vmbreak;\n      }\n      vmcase(OP_CLOSE) {\n        StkId ra = RA(i);\n        Protect(luaF_close(L, ra, LUA_OK, 1));\n        vmbreak;\n      }\n      vmcase(OP_TBC) {\n        StkId ra = RA(i);\n        /* create new to-be-closed upvalue */\n        halfProtect(luaF_newtbcupval(L, ra));\n        vmbreak;\n      }\n      vmcase(OP_JMP) {\n        dojump(ci, i, 0);\n        vmbreak;\n      }\n      vmcase(OP_EQ) {\n        StkId ra = RA(i);\n        int cond;\n        TValue *rb = vRB(i);\n        Protect(cond = luaV_equalobj(L, s2v(ra), rb));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LT) {\n        op_order(L, l_lti, LTnum, lessthanothers);\n        vmbreak;\n      }\n      vmcase(OP_LE) {\n        op_order(L, l_lei, LEnum, lessequalothers);\n        vmbreak;\n      }\n      vmcase(OP_EQK) {\n        StkId ra = RA(i);\n        TValue *rb = KB(i);\n        /* basic types do not use '__eq'; we can use raw equality */\n        int cond = luaV_rawequalobj(s2v(ra), rb);\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_EQI) {\n        StkId ra = RA(i);\n        int cond;\n        int im = GETARG_sB(i);\n        if (ttisinteger(s2v(ra)))\n          cond = (ivalue(s2v(ra)) == im);\n        else if (ttisfloat(s2v(ra)))\n          cond = luai_numeq(fltvalue(s2v(ra)), cast_num(im));\n        else\n          cond = 0;  /* other types cannot be equal to a number */\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_LTI) {\n        op_orderI(L, l_lti, luai_numlt, 0, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_LEI) {\n        op_orderI(L, l_lei, luai_numle, 0, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_GTI) {\n        op_orderI(L, l_gti, luai_numgt, 1, TM_LT);\n        vmbreak;\n      }\n      vmcase(OP_GEI) {\n        op_orderI(L, l_gei, luai_numge, 1, TM_LE);\n        vmbreak;\n      }\n      vmcase(OP_TEST) {\n        StkId ra = RA(i);\n        int cond = !l_isfalse(s2v(ra));\n        docondjump();\n        vmbreak;\n      }\n      vmcase(OP_TESTSET) {\n        StkId ra = RA(i);\n        TValue *rb = vRB(i);\n        if (l_isfalse(rb) == GETARG_k(i))\n          pc++;\n        else {\n          setobj2s(L, ra, rb);\n          donextjump(ci);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CALL) {\n        StkId ra = RA(i);\n        CallInfo *newci;\n        int b = GETARG_B(i);\n        int nresults = GETARG_C(i) - 1;\n        if (b != 0)  /* fixed number of arguments? */\n          L->top.p = ra + b;  /* top signals number of arguments */\n        /* else previous instruction set top */\n        savepc(L);  /* in case of errors */\n        if ((newci = luaD_precall(L, ra, nresults)) == NULL)\n          updatetrap(ci);  /* C call; nothing else to be done */\n        else {  /* Lua call: run function in this same C frame */\n          ci = newci;\n          goto startfunc;\n        }\n        vmbreak;\n      }\n      vmcase(OP_TAILCALL) {\n        StkId ra = RA(i);\n        int b = GETARG_B(i);  /* number of arguments + 1 (function) */\n        int n;  /* number of results when calling a C function */\n        int nparams1 = GETARG_C(i);\n        /* delta is virtual 'func' - real 'func' (vararg functions) */\n        int delta = (nparams1) ? ci->u.l.nextraargs + nparams1 : 0;\n        if (b != 0)\n          L->top.p = ra + b;\n        else  /* previous instruction set top */\n          b = cast_int(L->top.p - ra);\n        savepc(ci);  /* several calls here can raise errors */\n        if (TESTARG_k(i)) {\n          luaF_closeupval(L, base);  /* close upvalues from current call */\n          lua_assert(L->tbclist.p < base);  /* no pending tbc variables */\n          lua_assert(base == ci->func.p + 1);\n        }\n        if ((n = luaD_pretailcall(L, ci, ra, b, delta)) < 0)  /* Lua function? */\n          goto startfunc;  /* execute the callee */\n        else {  /* C function? */\n          ci->func.p -= delta;  /* restore 'func' (if vararg) */\n          luaD_poscall(L, ci, n);  /* finish caller */\n          updatetrap(ci);  /* 'luaD_poscall' can change hooks */\n          goto ret;  /* caller returns after the tail call */\n        }\n      }\n      vmcase(OP_RETURN) {\n        StkId ra = RA(i);\n        int n = GETARG_B(i) - 1;  /* number of results */\n        int nparams1 = GETARG_C(i);\n        if (n < 0)  /* not fixed? */\n          n = cast_int(L->top.p - ra);  /* get what is available */\n        savepc(ci);\n        if (TESTARG_k(i)) {  /* may there be open upvalues? */\n          ci->u2.nres = n;  /* save number of returns */\n          if (L->top.p < ci->top.p)\n            L->top.p = ci->top.p;\n          luaF_close(L, base, CLOSEKTOP, 1);\n          updatetrap(ci);\n          updatestack(ci);\n        }\n        if (nparams1)  /* vararg function? */\n          ci->func.p -= ci->u.l.nextraargs + nparams1;\n        L->top.p = ra + n;  /* set call for 'luaD_poscall' */\n        luaD_poscall(L, ci, n);\n        updatetrap(ci);  /* 'luaD_poscall' can change hooks */\n        goto ret;\n      }\n      vmcase(OP_RETURN0) {\n        if (l_unlikely(L->hookmask)) {\n          StkId ra = RA(i);\n          L->top.p = ra;\n          savepc(ci);\n          luaD_poscall(L, ci, 0);  /* no hurry... */\n          trap = 1;\n        }\n        else {  /* do the 'poscall' here */\n          int nres = get_nresults(ci->callstatus);\n          L->ci = ci->previous;  /* back to caller */\n          L->top.p = base - 1;\n          for (; l_unlikely(nres > 0); nres--)\n            setnilvalue(s2v(L->top.p++));  /* all results are nil */\n        }\n        goto ret;\n      }\n      vmcase(OP_RETURN1) {\n        if (l_unlikely(L->hookmask)) {\n          StkId ra = RA(i);\n          L->top.p = ra + 1;\n          savepc(ci);\n          luaD_poscall(L, ci, 1);  /* no hurry... */\n          trap = 1;\n        }\n        else {  /* do the 'poscall' here */\n          int nres = get_nresults(ci->callstatus);\n          L->ci = ci->previous;  /* back to caller */\n          if (nres == 0)\n            L->top.p = base - 1;  /* asked for no results */\n          else {\n            StkId ra = RA(i);\n            setobjs2s(L, base - 1, ra);  /* at least this result */\n            L->top.p = base;\n            for (; l_unlikely(nres > 1); nres--)\n              setnilvalue(s2v(L->top.p++));  /* complete missing results */\n          }\n        }\n       ret:  /* return from a Lua function */\n        if (ci->callstatus & CIST_FRESH)\n          return;  /* end this frame */\n        else {\n          ci = ci->previous;\n          goto returning;  /* continue running caller in this frame */\n        }\n      }\n      vmcase(OP_FORLOOP) {\n        StkId ra = RA(i);\n        if (ttisinteger(s2v(ra + 1))) {  /* integer loop? */\n          lua_Unsigned count = l_castS2U(ivalue(s2v(ra)));\n          if (count > 0) {  /* still more iterations? */\n            lua_Integer step = ivalue(s2v(ra + 1));\n            lua_Integer idx = ivalue(s2v(ra + 2));  /* control variable */\n            chgivalue(s2v(ra), l_castU2S(count - 1));  /* update counter */\n            idx = intop(+, idx, step);  /* add step to index */\n            chgivalue(s2v(ra + 2), idx);  /* update control variable */\n            pc -= GETARG_Bx(i);  /* jump back */\n          }\n        }\n        else if (floatforloop(ra))  /* float loop */\n          pc -= GETARG_Bx(i);  /* jump back */\n        updatetrap(ci);  /* allows a signal to break the loop */\n        vmbreak;\n      }\n      vmcase(OP_FORPREP) {\n        StkId ra = RA(i);\n        savestate(L, ci);  /* in case of errors */\n        if (forprep(L, ra))\n          pc += GETARG_Bx(i) + 1;  /* skip the loop */\n        vmbreak;\n      }\n      vmcase(OP_TFORPREP) {\n       /* before: 'ra' has the iterator function, 'ra + 1' has the state,\n          'ra + 2' has the initial value for the control variable, and\n          'ra + 3' has the closing variable. This opcode then swaps the\n          control and the closing variables and marks the closing variable\n          as to-be-closed.\n       */\n       StkId ra = RA(i);\n       TValue temp;  /* to swap control and closing variables */\n       setobj(L, &temp, s2v(ra + 3));\n       setobjs2s(L, ra + 3, ra + 2);\n       setobj2s(L, ra + 2, &temp);\n        /* create to-be-closed upvalue (if closing var. is not nil) */\n        halfProtect(luaF_newtbcupval(L, ra + 2));\n        pc += GETARG_Bx(i);  /* go to end of the loop */\n        i = *(pc++);  /* fetch next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORCALL && ra == RA(i));\n        goto l_tforcall;\n      }\n      vmcase(OP_TFORCALL) {\n       l_tforcall: {\n        /* 'ra' has the iterator function, 'ra + 1' has the state,\n           'ra + 2' has the closing variable, and 'ra + 3' has the control\n           variable. The call will use the stack starting at 'ra + 3',\n           so that it preserves the first three values, and the first\n           return will be the new value for the control variable.\n        */\n        StkId ra = RA(i);\n        setobjs2s(L, ra + 5, ra + 3);  /* copy the control variable */\n        setobjs2s(L, ra + 4, ra + 1);  /* copy state */\n        setobjs2s(L, ra + 3, ra);  /* copy function */\n        L->top.p = ra + 3 + 3;\n        ProtectNT(luaD_call(L, ra + 3, GETARG_C(i)));  /* do the call */\n        updatestack(ci);  /* stack may have changed */\n        i = *(pc++);  /* go to next instruction */\n        lua_assert(GET_OPCODE(i) == OP_TFORLOOP && ra == RA(i));\n        goto l_tforloop;\n      }}\n      vmcase(OP_TFORLOOP) {\n       l_tforloop: {\n        StkId ra = RA(i);\n        if (!ttisnil(s2v(ra + 3)))  /* continue loop? */\n          pc -= GETARG_Bx(i);  /* jump back */\n        vmbreak;\n      }}\n      vmcase(OP_SETLIST) {\n        StkId ra = RA(i);\n        unsigned n = cast_uint(GETARG_vB(i));\n        unsigned int last = cast_uint(GETARG_vC(i));\n        Table *h = hvalue(s2v(ra));\n        if (n == 0)\n          n = cast_uint(L->top.p - ra) - 1;  /* get up to the top */\n        else\n          L->top.p = ci->top.p;  /* correct top in case of emergency GC */\n        last += n;\n        if (TESTARG_k(i)) {\n          last += cast_uint(GETARG_Ax(*pc)) * (MAXARG_vC + 1);\n          pc++;\n        }\n        /* when 'n' is known, table should have proper size */\n        if (last > h->asize) {  /* needs more space? */\n          /* fixed-size sets should have space preallocated */\n          lua_assert(GETARG_vB(i) == 0);\n          luaH_resizearray(L, h, last);  /* preallocate it at once */\n        }\n        for (; n > 0; n--) {\n          TValue *val = s2v(ra + n);\n          obj2arr(h, last - 1, val);\n          last--;\n          luaC_barrierback(L, obj2gco(h), val);\n        }\n        vmbreak;\n      }\n      vmcase(OP_CLOSURE) {\n        StkId ra = RA(i);\n        Proto *p = cl->p->p[GETARG_Bx(i)];\n        halfProtect(pushclosure(L, p, cl->upvals, base, ra));\n        checkGC(L, ra + 1);\n        vmbreak;\n      }\n      vmcase(OP_VARARG) {\n        StkId ra = RA(i);\n        int n = GETARG_C(i) - 1;  /* required results */\n        Protect(luaT_getvarargs(L, ci, ra, n));\n        vmbreak;\n      }\n      vmcase(OP_VARARGPREP) {\n        ProtectNT(luaT_adjustvarargs(L, GETARG_A(i), ci, cl->p));\n        if (l_unlikely(trap)) {  /* previous \"Protect\" updated trap */\n          luaD_hookcall(L, ci);\n          L->oldpc = 1;  /* next opcode will be seen as a \"new\" line */\n        }\n        updatebase(ci);  /* function has new base after adjustment */\n        vmbreak;\n      }\n      vmcase(OP_EXTRAARG) {\n        lua_assert(0);\n        vmbreak;\n      }\n    }\n  }\n}\n\n/* }================================================================== */\n"
        },
        {
          "name": "lvm.h",
          "type": "blob",
          "size": 3.96875,
          "content": "/*\n** $Id: lvm.h $\n** Lua virtual machine\n** See Copyright Notice in lua.h\n*/\n\n#ifndef lvm_h\n#define lvm_h\n\n\n#include \"ldo.h\"\n#include \"lobject.h\"\n#include \"ltm.h\"\n\n\n#if !defined(LUA_NOCVTN2S)\n#define cvt2str(o)\tttisnumber(o)\n#else\n#define cvt2str(o)\t0\t/* no conversion from numbers to strings */\n#endif\n\n\n#if !defined(LUA_NOCVTS2N)\n#define cvt2num(o)\tttisstring(o)\n#else\n#define cvt2num(o)\t0\t/* no conversion from strings to numbers */\n#endif\n\n\n/*\n** You can define LUA_FLOORN2I if you want to convert floats to integers\n** by flooring them (instead of raising an error if they are not\n** integral values)\n*/\n#if !defined(LUA_FLOORN2I)\n#define LUA_FLOORN2I\t\tF2Ieq\n#endif\n\n\n/*\n** Rounding modes for float->integer coercion\n */\ntypedef enum {\n  F2Ieq,     /* no rounding; accepts only integral values */\n  F2Ifloor,  /* takes the floor of the number */\n  F2Iceil    /* takes the ceil of the number */\n} F2Imod;\n\n\n/* convert an object to a float (including string coercion) */\n#define tonumber(o,n) \\\n\t(ttisfloat(o) ? (*(n) = fltvalue(o), 1) : luaV_tonumber_(o,n))\n\n\n/* convert an object to a float (without string coercion) */\n#define tonumberns(o,n) \\\n\t(ttisfloat(o) ? ((n) = fltvalue(o), 1) : \\\n\t(ttisinteger(o) ? ((n) = cast_num(ivalue(o)), 1) : 0))\n\n\n/* convert an object to an integer (including string coercion) */\n#define tointeger(o,i) \\\n  (l_likely(ttisinteger(o)) ? (*(i) = ivalue(o), 1) \\\n                          : luaV_tointeger(o,i,LUA_FLOORN2I))\n\n\n/* convert an object to an integer (without string coercion) */\n#define tointegerns(o,i) \\\n  (l_likely(ttisinteger(o)) ? (*(i) = ivalue(o), 1) \\\n                          : luaV_tointegerns(o,i,LUA_FLOORN2I))\n\n\n#define intop(op,v1,v2) l_castU2S(l_castS2U(v1) op l_castS2U(v2))\n\n#define luaV_rawequalobj(t1,t2)\t\tluaV_equalobj(NULL,t1,t2)\n\n\n/*\n** fast track for 'gettable'\n*/\n#define luaV_fastget(t,k,res,f, tag) \\\n  (tag = (!ttistable(t) ? LUA_VNOTABLE : f(hvalue(t), k, res)))\n\n\n/*\n** Special case of 'luaV_fastget' for integers, inlining the fast case\n** of 'luaH_getint'.\n*/\n#define luaV_fastgeti(t,k,res,tag) \\\n  if (!ttistable(t)) tag = LUA_VNOTABLE; \\\n  else { luaH_fastgeti(hvalue(t), k, res, tag); }\n\n\n#define luaV_fastset(t,k,val,hres,f) \\\n  (hres = (!ttistable(t) ? HNOTATABLE : f(hvalue(t), k, val)))\n\n#define luaV_fastseti(t,k,val,hres) \\\n  if (!ttistable(t)) hres = HNOTATABLE; \\\n  else { luaH_fastseti(hvalue(t), k, val, hres); }\n\n\n/*\n** Finish a fast set operation (when fast set succeeds).\n*/\n#define luaV_finishfastset(L,t,v)\tluaC_barrierback(L, gcvalue(t), v)\n\n\n/*\n** Shift right is the same as shift left with a negative 'y'\n*/\n#define luaV_shiftr(x,y)\tluaV_shiftl(x,intop(-, 0, y))\n\n\n\nLUAI_FUNC int luaV_equalobj (lua_State *L, const TValue *t1, const TValue *t2);\nLUAI_FUNC int luaV_lessthan (lua_State *L, const TValue *l, const TValue *r);\nLUAI_FUNC int luaV_lessequal (lua_State *L, const TValue *l, const TValue *r);\nLUAI_FUNC int luaV_tonumber_ (const TValue *obj, lua_Number *n);\nLUAI_FUNC int luaV_tointeger (const TValue *obj, lua_Integer *p, F2Imod mode);\nLUAI_FUNC int luaV_tointegerns (const TValue *obj, lua_Integer *p,\n                                F2Imod mode);\nLUAI_FUNC int luaV_flttointeger (lua_Number n, lua_Integer *p, F2Imod mode);\nLUAI_FUNC lu_byte luaV_finishget (lua_State *L, const TValue *t, TValue *key,\n                                                StkId val, lu_byte tag);\nLUAI_FUNC void luaV_finishset (lua_State *L, const TValue *t, TValue *key,\n                                             TValue *val, int aux);\nLUAI_FUNC void luaV_finishOp (lua_State *L);\nLUAI_FUNC void luaV_execute (lua_State *L, CallInfo *ci);\nLUAI_FUNC void luaV_concat (lua_State *L, int total);\nLUAI_FUNC lua_Integer luaV_idiv (lua_State *L, lua_Integer x, lua_Integer y);\nLUAI_FUNC lua_Integer luaV_mod (lua_State *L, lua_Integer x, lua_Integer y);\nLUAI_FUNC lua_Number luaV_modf (lua_State *L, lua_Number x, lua_Number y);\nLUAI_FUNC lua_Integer luaV_shiftl (lua_Integer x, lua_Integer y);\nLUAI_FUNC void luaV_objlen (lua_State *L, StkId ra, const TValue *rb);\n\n#endif\n"
        },
        {
          "name": "lzio.c",
          "type": "blob",
          "size": 1.7666015625,
          "content": "/*\n** $Id: lzio.c $\n** Buffered streams\n** See Copyright Notice in lua.h\n*/\n\n#define lzio_c\n#define LUA_CORE\n\n#include \"lprefix.h\"\n\n\n#include <string.h>\n\n#include \"lua.h\"\n\n#include \"lapi.h\"\n#include \"llimits.h\"\n#include \"lmem.h\"\n#include \"lstate.h\"\n#include \"lzio.h\"\n\n\nint luaZ_fill (ZIO *z) {\n  size_t size;\n  lua_State *L = z->L;\n  const char *buff;\n  lua_unlock(L);\n  buff = z->reader(L, z->data, &size);\n  lua_lock(L);\n  if (buff == NULL || size == 0)\n    return EOZ;\n  z->n = size - 1;  /* discount char being returned */\n  z->p = buff;\n  return cast_uchar(*(z->p++));\n}\n\n\nvoid luaZ_init (lua_State *L, ZIO *z, lua_Reader reader, void *data) {\n  z->L = L;\n  z->reader = reader;\n  z->data = data;\n  z->n = 0;\n  z->p = NULL;\n}\n\n\n/* --------------------------------------------------------------- read --- */\n\nstatic int checkbuffer (ZIO *z) {\n  if (z->n == 0) {  /* no bytes in buffer? */\n    if (luaZ_fill(z) == EOZ)  /* try to read more */\n      return 0;  /* no more input */\n    else {\n      z->n++;  /* luaZ_fill consumed first byte; put it back */\n      z->p--;\n    }\n  }\n  return 1;  /* now buffer has something */\n}\n\n\nsize_t luaZ_read (ZIO *z, void *b, size_t n) {\n  while (n) {\n    size_t m;\n    if (!checkbuffer(z))\n      return n;  /* no more input; return number of missing bytes */\n    m = (n <= z->n) ? n : z->n;  /* min. between n and z->n */\n    memcpy(b, z->p, m);\n    z->n -= m;\n    z->p += m;\n    b = (char *)b + m;\n    n -= m;\n  }\n  return 0;\n}\n\n\nconst void *luaZ_getaddr (ZIO* z, size_t n) {\n  const void *res;\n  if (!checkbuffer(z))\n    return NULL;  /* no more input */\n  if (z->n < n)  /* not enough bytes? */\n    return NULL;  /* block not whole; cannot give an address */\n  res = z->p;  /* get block address */\n  z->n -= n;  /* consume these bytes */\n  z->p += n;\n  return res;\n}\n"
        },
        {
          "name": "lzio.h",
          "type": "blob",
          "size": 1.4677734375,
          "content": "/*\n** $Id: lzio.h $\n** Buffered streams\n** See Copyright Notice in lua.h\n*/\n\n\n#ifndef lzio_h\n#define lzio_h\n\n#include \"lua.h\"\n\n#include \"lmem.h\"\n\n\n#define EOZ\t(-1)\t\t\t/* end of stream */\n\ntypedef struct Zio ZIO;\n\n#define zgetc(z)  (((z)->n--)>0 ?  cast_uchar(*(z)->p++) : luaZ_fill(z))\n\n\ntypedef struct Mbuffer {\n  char *buffer;\n  size_t n;\n  size_t buffsize;\n} Mbuffer;\n\n#define luaZ_initbuffer(L, buff) ((buff)->buffer = NULL, (buff)->buffsize = 0)\n\n#define luaZ_buffer(buff)\t((buff)->buffer)\n#define luaZ_sizebuffer(buff)\t((buff)->buffsize)\n#define luaZ_bufflen(buff)\t((buff)->n)\n\n#define luaZ_buffremove(buff,i)\t((buff)->n -= cast_sizet(i))\n#define luaZ_resetbuffer(buff) ((buff)->n = 0)\n\n\n#define luaZ_resizebuffer(L, buff, size) \\\n\t((buff)->buffer = luaM_reallocvchar(L, (buff)->buffer, \\\n\t\t\t\t(buff)->buffsize, size), \\\n\t(buff)->buffsize = size)\n\n#define luaZ_freebuffer(L, buff)\tluaZ_resizebuffer(L, buff, 0)\n\n\nLUAI_FUNC void luaZ_init (lua_State *L, ZIO *z, lua_Reader reader,\n                                        void *data);\nLUAI_FUNC size_t luaZ_read (ZIO* z, void *b, size_t n);\t/* read next n bytes */\n\nLUAI_FUNC const void *luaZ_getaddr (ZIO* z, size_t n);\n\n\n/* --------- Private Part ------------------ */\n\nstruct Zio {\n  size_t n;\t\t\t/* bytes still unread */\n  const char *p;\t\t/* current position in buffer */\n  lua_Reader reader;\t\t/* reader function */\n  void *data;\t\t\t/* additional data */\n  lua_State *L;\t\t\t/* Lua state (for reader) */\n};\n\n\nLUAI_FUNC int luaZ_fill (ZIO *z);\n\n#endif\n"
        },
        {
          "name": "makefile",
          "type": "blob",
          "size": 7.5703125,
          "content": "# Developer's makefile for building Lua\n# see luaconf.h for further customization\n\n# == CHANGE THE SETTINGS BELOW TO SUIT YOUR ENVIRONMENT =======================\n\n# Warnings valid for both C and C++\nCWARNSCPP= \\\n\t-Wfatal-errors \\\n\t-Wextra \\\n\t-Wshadow \\\n\t-Wundef \\\n\t-Wwrite-strings \\\n\t-Wredundant-decls \\\n\t-Wdisabled-optimization \\\n\t-Wdouble-promotion \\\n\t-Wmissing-declarations \\\n\t-Wconversion \\\n\t-Wuninitialized \\\n\t-Wstrict-overflow=2 \\\n        # the next warnings might be useful sometimes,\n\t# but usually they generate too much noise\n\t# -Werror \\\n\t# -pedantic   # warns if we use jump tables \\\n\t# -Wformat=2 \\\n\t# -Wcast-qual \\\n\n\n# Warnings for gcc, not valid for clang\nCWARNGCC= \\\n\t-Wlogical-op \\\n\t-Wno-aggressive-loop-optimizations \\\n\n\n# The next warnings are neither valid nor needed for C++\nCWARNSC= -Wdeclaration-after-statement \\\n\t-Wmissing-prototypes \\\n\t-Wnested-externs \\\n\t-Wstrict-prototypes \\\n\t-Wc++-compat \\\n\t-Wold-style-definition \\\n\n\nCWARNS= $(CWARNSCPP) $(CWARNSC) $(CWARNGCC)\n\n# Some useful compiler options for internal tests:\n# -DLUAI_ASSERT turns on all assertions inside Lua.\n# -DHARDSTACKTESTS forces a reallocation of the stack at every point where\n# the stack can be reallocated.\n# -DHARDMEMTESTS forces a full collection at all points where the collector\n# can run.\n# -DEMERGENCYGCTESTS forces an emergency collection at every single allocation.\n# -DEXTERNMEMCHECK removes internal consistency checking of blocks being\n# deallocated (useful when an external tool like valgrind does the check).\n# -DMAXINDEXRK=k limits range of constants in RK instruction operands.\n# -DLUA_COMPAT_5_3\n\n# -pg -malign-double\n# -DLUA_USE_CTYPE -DLUA_USE_APICHECK\n\n# The following options help detect \"undefined behavior\"s that seldom\n# create problems; some are only available in newer gcc versions. To\n# use some of them, we also have to define an environment variable\n# ASAN_OPTIONS=\"detect_invalid_pointer_pairs=2\".\n# -fsanitize=undefined\n# -fsanitize=pointer-subtract -fsanitize=address -fsanitize=pointer-compare\n# TESTS= -DLUA_USER_H='\"ltests.h\"' -O0 -g\n\n\nLOCAL = $(TESTS) $(CWARNS)\n\n\n# To enable Linux goodies, -DLUA_USE_LINUX\n# For C89, \"-std=c89 -DLUA_USE_C89\"\n# Note that Linux/Posix options are not compatible with C89\nMYCFLAGS= $(LOCAL) -std=c99 -DLUA_USE_LINUX\nMYLDFLAGS= $(LOCAL) -Wl,-E\nMYLIBS= -ldl\n\n\nCC= gcc\nCFLAGS= -Wall -O2 $(MYCFLAGS) -fno-stack-protector -fno-common -march=native\nAR= ar rc\nRANLIB= ranlib\nRM= rm -f\n\n\n\n# == END OF USER SETTINGS. NO NEED TO CHANGE ANYTHING BELOW THIS LINE =========\n\n\nLIBS = -lm\n\nCORE_T=\tliblua.a\nCORE_O=\tlapi.o lcode.o lctype.o ldebug.o ldo.o ldump.o lfunc.o lgc.o llex.o \\\n\tlmem.o lobject.o lopcodes.o lparser.o lstate.o lstring.o ltable.o \\\n\tltm.o lundump.o lvm.o lzio.o ltests.o\nAUX_O=\tlauxlib.o\nLIB_O=\tlbaselib.o ldblib.o liolib.o lmathlib.o loslib.o ltablib.o lstrlib.o \\\n\tlutf8lib.o loadlib.o lcorolib.o linit.o\n\nLUA_T=\tlua\nLUA_O=\tlua.o\n\n\nALL_T= $(CORE_T) $(LUA_T)\nALL_O= $(CORE_O) $(LUA_O) $(AUX_O) $(LIB_O)\nALL_A= $(CORE_T)\n\nall:\t$(ALL_T)\n\ttouch all\n\no:\t$(ALL_O)\n\na:\t$(ALL_A)\n\n$(CORE_T): $(CORE_O) $(AUX_O) $(LIB_O)\n\t$(AR) $@ $?\n\t$(RANLIB) $@\n\n$(LUA_T): $(LUA_O) $(CORE_T)\n\t$(CC) -o $@ $(MYLDFLAGS) $(LUA_O) $(CORE_T) $(LIBS) $(MYLIBS) $(DL)\n\n\nclean:\n\t$(RM) $(ALL_T) $(ALL_O)\n\ndepend:\n\t@$(CC) $(CFLAGS) -MM *.c\n\necho:\n\t@echo \"CC = $(CC)\"\n\t@echo \"CFLAGS = $(CFLAGS)\"\n\t@echo \"AR = $(AR)\"\n\t@echo \"RANLIB = $(RANLIB)\"\n\t@echo \"RM = $(RM)\"\n\t@echo \"MYCFLAGS = $(MYCFLAGS)\"\n\t@echo \"MYLDFLAGS = $(MYLDFLAGS)\"\n\t@echo \"MYLIBS = $(MYLIBS)\"\n\t@echo \"DL = $(DL)\"\n\n$(ALL_O): makefile ltests.h\n\n# DO NOT EDIT\n# automatically made with 'gcc -MM l*.c'\n\nlapi.o: lapi.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h lstring.h \\\n ltable.h lundump.h lvm.h\nlauxlib.o: lauxlib.c lprefix.h lua.h luaconf.h lauxlib.h llimits.h\nlbaselib.o: lbaselib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h \\\n llimits.h\nlcode.o: lcode.c lprefix.h lua.h luaconf.h lcode.h llex.h lobject.h \\\n llimits.h lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h \\\n ldo.h lgc.h lstring.h ltable.h lvm.h lopnames.h\nlcorolib.o: lcorolib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h \\\n llimits.h\nlctype.o: lctype.c lprefix.h lctype.h lua.h luaconf.h llimits.h\nldblib.o: ldblib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h llimits.h\nldebug.o: ldebug.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h lcode.h llex.h lopcodes.h lparser.h \\\n ldebug.h ldo.h lfunc.h lstring.h lgc.h ltable.h lvm.h\nldo.o: ldo.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h lopcodes.h \\\n lparser.h lstring.h ltable.h lundump.h lvm.h\nldump.o: ldump.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h lgc.h ltable.h lundump.h\nlfunc.o: lfunc.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \\\n llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h\nlgc.o: lgc.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \\\n llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h llex.h lstring.h \\\n ltable.h\nlinit.o: linit.c lprefix.h lua.h luaconf.h lualib.h lauxlib.h llimits.h\nliolib.o: liolib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h llimits.h\nllex.o: llex.c lprefix.h lua.h luaconf.h lctype.h llimits.h ldebug.h \\\n lstate.h lobject.h ltm.h lzio.h lmem.h ldo.h lgc.h llex.h lparser.h \\\n lstring.h ltable.h\nlmathlib.o: lmathlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h \\\n llimits.h\nlmem.o: lmem.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \\\n llimits.h ltm.h lzio.h lmem.h ldo.h lgc.h\nloadlib.o: loadlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h \\\n llimits.h\nlobject.o: lobject.c lprefix.h lua.h luaconf.h lctype.h llimits.h \\\n ldebug.h lstate.h lobject.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h \\\n lvm.h\nlopcodes.o: lopcodes.c lprefix.h lopcodes.h llimits.h lua.h luaconf.h \\\n lobject.h\nloslib.o: loslib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h llimits.h\nlparser.o: lparser.c lprefix.h lua.h luaconf.h lcode.h llex.h lobject.h \\\n llimits.h lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h \\\n ldo.h lfunc.h lstring.h lgc.h ltable.h\nlstate.o: lstate.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h llex.h \\\n lstring.h ltable.h\nlstring.o: lstring.c lprefix.h lua.h luaconf.h ldebug.h lstate.h \\\n lobject.h llimits.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h\nlstrlib.o: lstrlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h \\\n llimits.h\nltable.o: ltable.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \\\n llimits.h ltm.h lzio.h lmem.h ldo.h lgc.h lstring.h ltable.h lvm.h\nltablib.o: ltablib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h \\\n llimits.h\nltests.o: ltests.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h lauxlib.h lcode.h llex.h lopcodes.h \\\n lparser.h lctype.h ldebug.h ldo.h lfunc.h lopnames.h lstring.h lgc.h \\\n ltable.h lualib.h\nltm.o: ltm.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \\\n llimits.h ltm.h lzio.h lmem.h ldo.h lgc.h lstring.h ltable.h lvm.h\nlua.o: lua.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h llimits.h\nlundump.o: lundump.c lprefix.h lua.h luaconf.h ldebug.h lstate.h \\\n lobject.h llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lstring.h lgc.h \\\n ltable.h lundump.h\nlutf8lib.o: lutf8lib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h \\\n llimits.h\nlvm.o: lvm.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h lopcodes.h \\\n lstring.h ltable.h lvm.h ljumptab.h\nlzio.o: lzio.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \\\n lobject.h ltm.h lzio.h lmem.h\n\n# (end of Makefile)\n"
        },
        {
          "name": "manual",
          "type": "tree",
          "content": null
        },
        {
          "name": "onelua.c",
          "type": "blob",
          "size": 2.1826171875,
          "content": "/*\n** Lua core, libraries, and interpreter in a single file.\n** Compiling just this file generates a complete Lua stand-alone\n** program:\n**\n** $ gcc -O2 -std=c99 -o lua onelua.c -lm\n**\n** or\n**\n** $ gcc -O2 -std=c89 -DLUA_USE_C89 -o lua onelua.c -lm\n**\n*/\n\n/* default is to build the full interpreter */\n#ifndef MAKE_LIB\n#ifndef MAKE_LUAC\n#ifndef MAKE_LUA\n#define MAKE_LUA\n#endif\n#endif\n#endif\n\n\n/*\n** Choose suitable platform-specific features. Default is no\n** platform-specific features. Some of these options may need extra\n** libraries such as -ldl -lreadline -lncurses\n*/\n#if 0\n#define LUA_USE_LINUX\n#define LUA_USE_MACOSX\n#define LUA_USE_POSIX\n#define LUA_ANSI\n#endif\n\n\n/* no need to change anything below this line ----------------------------- */\n\n#include \"lprefix.h\"\n\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <limits.h>\n#include <locale.h>\n#include <math.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n\n/* setup for luaconf.h */\n#define LUA_CORE\n#define LUA_LIB\n#define ltable_c\n#define lvm_c\n#include \"luaconf.h\"\n\n/* do not export internal symbols */\n#undef LUAI_FUNC\n#undef LUAI_DDEC\n#undef LUAI_DDEF\n#define LUAI_FUNC\tstatic\n#define LUAI_DDEC(def)\t/* empty */\n#define LUAI_DDEF\tstatic\n\n/* core -- used by all */\n#include \"lzio.c\"\n#include \"lctype.c\"\n#include \"lopcodes.c\"\n#include \"lmem.c\"\n#include \"lundump.c\"\n#include \"ldump.c\"\n#include \"lstate.c\"\n#include \"lgc.c\"\n#include \"llex.c\"\n#include \"lcode.c\"\n#include \"lparser.c\"\n#include \"ldebug.c\"\n#include \"lfunc.c\"\n#include \"lobject.c\"\n#include \"ltm.c\"\n#include \"lstring.c\"\n#include \"ltable.c\"\n#include \"ldo.c\"\n#include \"lvm.c\"\n#include \"lapi.c\"\n\n/* auxiliary library -- used by all */\n#include \"lauxlib.c\"\n\n/* standard library  -- not used by luac */\n#ifndef MAKE_LUAC\n#include \"lbaselib.c\"\n#include \"lcorolib.c\"\n#include \"ldblib.c\"\n#include \"liolib.c\"\n#include \"lmathlib.c\"\n#include \"loadlib.c\"\n#include \"loslib.c\"\n#include \"lstrlib.c\"\n#include \"ltablib.c\"\n#include \"lutf8lib.c\"\n#include \"linit.c\"\n#endif\n\n/* lua */\n#ifdef MAKE_LUA\n#include \"lua.c\"\n#endif\n\n/* luac */\n#ifdef MAKE_LUAC\n#include \"luac.c\"\n#endif\n"
        },
        {
          "name": "testes",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}