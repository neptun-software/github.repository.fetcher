{
  "metadata": {
    "timestamp": 1736557477791,
    "page": 512,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "huihut/interview",
      "stars": 35202,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.02,
          "content": ".vscode\n*.txt\n*.bat"
        },
        {
          "name": "Algorithm",
          "type": "tree",
          "content": null
        },
        {
          "name": "DataStructure",
          "type": "tree",
          "content": null
        },
        {
          "name": "DesignPattern",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 16.3,
          "content": "Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International\nPublic License\n\nBy exercising the Licensed Rights (defined below), You accept and agree\nto be bound by the terms and conditions of this Creative Commons\nAttribution-NonCommercial-ShareAlike 4.0 International Public License\n(\"Public License\"). To the extent this Public License may be\ninterpreted as a contract, You are granted the Licensed Rights in\nconsideration of Your acceptance of these terms and conditions, and the\nLicensor grants You such rights in consideration of benefits the\nLicensor receives from making the Licensed Material available under\nthese terms and conditions.\n\n\nSection 1 -- Definitions.\n\n  a. Adapted Material means material subject to Copyright and Similar\n     Rights that is derived from or based upon the Licensed Material\n     and in which the Licensed Material is translated, altered,\n     arranged, transformed, or otherwise modified in a manner requiring\n     permission under the Copyright and Similar Rights held by the\n     Licensor. For purposes of this Public License, where the Licensed\n     Material is a musical work, performance, or sound recording,\n     Adapted Material is always produced where the Licensed Material is\n     synched in timed relation with a moving image.\n\n  b. Adapter's License means the license You apply to Your Copyright\n     and Similar Rights in Your contributions to Adapted Material in\n     accordance with the terms and conditions of this Public License.\n\n  c. BY-NC-SA Compatible License means a license listed at\n     creativecommons.org/compatiblelicenses, approved by Creative\n     Commons as essentially the equivalent of this Public License.\n\n  d. Copyright and Similar Rights means copyright and/or similar rights\n     closely related to copyright including, without limitation,\n     performance, broadcast, sound recording, and Sui Generis Database\n     Rights, without regard to how the rights are labeled or\n     categorized. For purposes of this Public License, the rights\n     specified in Section 2(b)(1)-(2) are not Copyright and Similar\n     Rights.\n\n  e. Effective Technological Measures means those measures that, in the\n     absence of proper authority, may not be circumvented under laws\n     fulfilling obligations under Article 11 of the WIPO Copyright\n     Treaty adopted on December 20, 1996, and/or similar international\n     agreements.\n\n  f. Exceptions and Limitations means fair use, fair dealing, and/or\n     any other exception or limitation to Copyright and Similar Rights\n     that applies to Your use of the Licensed Material.\n\n  g. License Elements means the license attributes listed in the name\n     of a Creative Commons Public License. The License Elements of this\n     Public License are Attribution, NonCommercial, and ShareAlike.\n\n  h. Licensed Material means the artistic or literary work, database,\n     or other material to which the Licensor applied this Public\n     License.\n\n  i. Licensed Rights means the rights granted to You subject to the\n     terms and conditions of this Public License, which are limited to\n     all Copyright and Similar Rights that apply to Your use of the\n     Licensed Material and that the Licensor has authority to license.\n\n  j. Licensor means the individual(s) or entity(ies) granting rights\n     under this Public License.\n\n  k. NonCommercial means not primarily intended for or directed towards\n     commercial advantage or monetary compensation. For purposes of\n     this Public License, the exchange of the Licensed Material for\n     other material subject to Copyright and Similar Rights by digital\n     file-sharing or similar means is NonCommercial provided there is\n     no payment of monetary compensation in connection with the\n     exchange.\n\n  l. Share means to provide material to the public by any means or\n     process that requires permission under the Licensed Rights, such\n     as reproduction, public display, public performance, distribution,\n     dissemination, communication, or importation, and to make material\n     available to the public including in ways that members of the\n     public may access the material from a place and at a time\n     individually chosen by them.\n\n  m. Sui Generis Database Rights means rights other than copyright\n     resulting from Directive 96/9/EC of the European Parliament and of\n     the Council of 11 March 1996 on the legal protection of databases,\n     as amended and/or succeeded, as well as other essentially\n     equivalent rights anywhere in the world.\n\n  n. You means the individual or entity exercising the Licensed Rights\n     under this Public License. Your has a corresponding meaning.\n\n\nSection 2 -- Scope.\n\n  a. License grant.\n\n       1. Subject to the terms and conditions of this Public License,\n          the Licensor hereby grants You a worldwide, royalty-free,\n          non-sublicensable, non-exclusive, irrevocable license to\n          exercise the Licensed Rights in the Licensed Material to:\n\n            a. reproduce and Share the Licensed Material, in whole or\n               in part, for NonCommercial purposes only; and\n\n            b. produce, reproduce, and Share Adapted Material for\n               NonCommercial purposes only.\n\n       2. Exceptions and Limitations. For the avoidance of doubt, where\n          Exceptions and Limitations apply to Your use, this Public\n          License does not apply, and You do not need to comply with\n          its terms and conditions.\n\n       3. Term. The term of this Public License is specified in Section\n          6(a).\n\n       4. Media and formats; technical modifications allowed. The\n          Licensor authorizes You to exercise the Licensed Rights in\n          all media and formats whether now known or hereafter created,\n          and to make technical modifications necessary to do so. The\n          Licensor waives and/or agrees not to assert any right or\n          authority to forbid You from making technical modifications\n          necessary to exercise the Licensed Rights, including\n          technical modifications necessary to circumvent Effective\n          Technological Measures. For purposes of this Public License,\n          simply making modifications authorized by this Section 2(a)\n          (4) never produces Adapted Material.\n\n       5. Downstream recipients.\n\n            a. Offer from the Licensor -- Licensed Material. Every\n               recipient of the Licensed Material automatically\n               receives an offer from the Licensor to exercise the\n               Licensed Rights under the terms and conditions of this\n               Public License.\n\n            b. Additional offer from the Licensor -- Adapted Material.\n               Every recipient of Adapted Material from You\n               automatically receives an offer from the Licensor to\n               exercise the Licensed Rights in the Adapted Material\n               under the conditions of the Adapter's License You apply.\n\n            c. No downstream restrictions. You may not offer or impose\n               any additional or different terms or conditions on, or\n               apply any Effective Technological Measures to, the\n               Licensed Material if doing so restricts exercise of the\n               Licensed Rights by any recipient of the Licensed\n               Material.\n\n       6. No endorsement. Nothing in this Public License constitutes or\n          may be construed as permission to assert or imply that You\n          are, or that Your use of the Licensed Material is, connected\n          with, or sponsored, endorsed, or granted official status by,\n          the Licensor or others designated to receive attribution as\n          provided in Section 3(a)(1)(A)(i).\n\n  b. Other rights.\n\n       1. Moral rights, such as the right of integrity, are not\n          licensed under this Public License, nor are publicity,\n          privacy, and/or other similar personality rights; however, to\n          the extent possible, the Licensor waives and/or agrees not to\n          assert any such rights held by the Licensor to the limited\n          extent necessary to allow You to exercise the Licensed\n          Rights, but not otherwise.\n\n       2. Patent and trademark rights are not licensed under this\n          Public License.\n\n       3. To the extent possible, the Licensor waives any right to\n          collect royalties from You for the exercise of the Licensed\n          Rights, whether directly or through a collecting society\n          under any voluntary or waivable statutory or compulsory\n          licensing scheme. In all other cases the Licensor expressly\n          reserves any right to collect such royalties, including when\n          the Licensed Material is used other than for NonCommercial\n          purposes.\n\n\nSection 3 -- License Conditions.\n\nYour exercise of the Licensed Rights is expressly made subject to the\nfollowing conditions.\n\n  a. Attribution.\n\n       1. If You Share the Licensed Material (including in modified\n          form), You must:\n\n            a. retain the following if it is supplied by the Licensor\n               with the Licensed Material:\n\n                 i. identification of the creator(s) of the Licensed\n                    Material and any others designated to receive\n                    attribution, in any reasonable manner requested by\n                    the Licensor (including by pseudonym if\n                    designated);\n\n                ii. a copyright notice;\n\n               iii. a notice that refers to this Public License;\n\n                iv. a notice that refers to the disclaimer of\n                    warranties;\n\n                 v. a URI or hyperlink to the Licensed Material to the\n                    extent reasonably practicable;\n\n            b. indicate if You modified the Licensed Material and\n               retain an indication of any previous modifications; and\n\n            c. indicate the Licensed Material is licensed under this\n               Public License, and include the text of, or the URI or\n               hyperlink to, this Public License.\n\n       2. You may satisfy the conditions in Section 3(a)(1) in any\n          reasonable manner based on the medium, means, and context in\n          which You Share the Licensed Material. For example, it may be\n          reasonable to satisfy the conditions by providing a URI or\n          hyperlink to a resource that includes the required\n          information.\n       3. If requested by the Licensor, You must remove any of the\n          information required by Section 3(a)(1)(A) to the extent\n          reasonably practicable.\n\n  b. ShareAlike.\n\n     In addition to the conditions in Section 3(a), if You Share\n     Adapted Material You produce, the following conditions also apply.\n\n       1. The Adapter's License You apply must be a Creative Commons\n          license with the same License Elements, this version or\n          later, or a BY-NC-SA Compatible License.\n\n       2. You must include the text of, or the URI or hyperlink to, the\n          Adapter's License You apply. You may satisfy this condition\n          in any reasonable manner based on the medium, means, and\n          context in which You Share Adapted Material.\n\n       3. You may not offer or impose any additional or different terms\n          or conditions on, or apply any Effective Technological\n          Measures to, Adapted Material that restrict exercise of the\n          rights granted under the Adapter's License You apply.\n\n\nSection 4 -- Sui Generis Database Rights.\n\nWhere the Licensed Rights include Sui Generis Database Rights that\napply to Your use of the Licensed Material:\n\n  a. for the avoidance of doubt, Section 2(a)(1) grants You the right\n     to extract, reuse, reproduce, and Share all or a substantial\n     portion of the contents of the database for NonCommercial purposes\n     only;\n\n  b. if You include all or a substantial portion of the database\n     contents in a database in which You have Sui Generis Database\n     Rights, then the database in which You have Sui Generis Database\n     Rights (but not its individual contents) is Adapted Material,\n     including for purposes of Section 3(b); and\n\n  c. You must comply with the conditions in Section 3(a) if You Share\n     all or a substantial portion of the contents of the database.\n\nFor the avoidance of doubt, this Section 4 supplements and does not\nreplace Your obligations under this Public License where the Licensed\nRights include other Copyright and Similar Rights.\n\n\nSection 5 -- Disclaimer of Warranties and Limitation of Liability.\n\n  a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE\n     EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS\n     AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF\n     ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS,\n     IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION,\n     WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR\n     PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS,\n     ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT\n     KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT\n     ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.\n\n  b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE\n     TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,\n     NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT,\n     INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES,\n     COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR\n     USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN\n     ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR\n     DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR\n     IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.\n\n  c. The disclaimer of warranties and limitation of liability provided\n     above shall be interpreted in a manner that, to the extent\n     possible, most closely approximates an absolute disclaimer and\n     waiver of all liability.\n\n\nSection 6 -- Term and Termination.\n\n  a. This Public License applies for the term of the Copyright and\n     Similar Rights licensed here. However, if You fail to comply with\n     this Public License, then Your rights under this Public License\n     terminate automatically.\n\n  b. Where Your right to use the Licensed Material has terminated under\n     Section 6(a), it reinstates:\n\n       1. automatically as of the date the violation is cured, provided\n          it is cured within 30 days of Your discovery of the\n          violation; or\n\n       2. upon express reinstatement by the Licensor.\n\n     For the avoidance of doubt, this Section 6(b) does not affect any\n     right the Licensor may have to seek remedies for Your violations\n     of this Public License.\n\n  c. For the avoidance of doubt, the Licensor may also offer the\n     Licensed Material under separate terms or conditions or stop\n     distributing the Licensed Material at any time; however, doing so\n     will not terminate this Public License.\n\n  d. Sections 1, 5, 6, 7, and 8 survive termination of this Public\n     License.\n\n\nSection 7 -- Other Terms and Conditions.\n\n  a. The Licensor shall not be bound by any additional or different\n     terms or conditions communicated by You unless expressly agreed.\n\n  b. Any arrangements, understandings, or agreements regarding the\n     Licensed Material not stated herein are separate from and\n     independent of the terms and conditions of this Public License.\n\n\nSection 8 -- Interpretation.\n\n  a. For the avoidance of doubt, this Public License does not, and\n     shall not be interpreted to, reduce, limit, restrict, or impose\n     conditions on any use of the Licensed Material that could lawfully\n     be made without permission under this Public License.\n\n  b. To the extent possible, if any provision of this Public License is\n     deemed unenforceable, it shall be automatically reformed to the\n     minimum extent necessary to make it enforceable. If the provision\n     cannot be reformed, it shall be severed from this Public License\n     without affecting the enforceability of the remaining terms and\n     conditions.\n\n  c. No term or condition of this Public License will be waived and no\n     failure to comply consented to unless expressly agreed to by the\n     Licensor.\n\n  d. Nothing in this Public License constitutes or may be interpreted\n     as a limitation upon, or waiver of, any privileges and immunities\n     that apply to the Licensor or You, including from the legal\n     processes of any jurisdiction or authority."
        },
        {
          "name": "Problems",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 145.53,
          "content": "<div align=\"center\">\n📖 Github\n&emsp;&emsp; | &emsp;&emsp;\n<a href=\"https://interview.huihut.com\">📚 Docsify</a>\n</div> \n<br>\n\n<div align=\"center\">\n简体中文\n&emsp;&emsp; | &emsp;&emsp;\n<a href=\"https://github.com/huihut/interview/blob/master/README_en.md\">English</a>\n</div> \n<br>\n\n<b><details><summary>💡 关于</summary></b>\n\n📚 本仓库是面向 C/C++ 技术方向校招求职者、初学者的基础知识总结，包括语言、程序库、数据结构、算法、系统、网络、链接装载库等知识及面试经验、招聘、内推等信息。\n\n💡 侧边目录支持方式：[📚 Docsify 文档](https://interview.huihut.com)、[Github + TOC 导航](https://github.com/jawil/GayHub)（[TOC预览.png](https://gitee.com/huihut/interview/raw/master/images/TOC预览.png)）\n\n📄 保存为 PDF 方式：使用 Chrome 浏览器打开 <a href=\"https://interview.huihut.com\">📚 Docsify 文档</a> 页面，缩起左侧目录-右键 - 打印 - 选择目标打印机是另存为PDF - 保存（[打印预览.png](https://gitee.com/huihut/interview/raw/master/images/打印预览.png)）\n\n🙏 仓库内容如有错误或改进欢迎 issue 或 pr，建议或讨论可在 [#12](https://github.com/huihut/interview/issues/12) 提出。由于本人水平有限，仓库中的知识点有来自本人原创、读书笔记、书籍、博文等，非原创均已标明出处，如有遗漏，请 issue 提出。本仓库遵循 [CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享）](https://github.com/huihut/interview/blob/master/LICENSE) 协议，转载请注明出处，不得用于商业目的。\n\n</details>\n\n## 📑 目录\n\n* [➕ C/C++](#cc)\n* [⭐️ Effective](#effective)\n* [📦 STL](#stl)\n* [〽️ 数据结构](#data-structure)\n* [⚡️ 算法](#algorithm)\n* [❓ Problems](#problems)\n* [💻 操作系统](#os)\n* [☁️ 计算机网络](#computer-network)\n* [🌩 网络编程](#network-programming)\n* [💾 数据库](#database)\n* [📏 设计模式](#design-pattern)\n* [⚙️ 链接装载库](#link-loading-library)\n* [📚 书籍](#books)\n* [🔱 C/C++ 发展方向](#cc-development-direction)\n* [💯 复习刷题网站](#review-of-brush-questions-website)\n* [📝 面试题目经验](#interview-questions-experience)\n* [📆 招聘时间岗位](#recruitment-time-post)\n* [👍 内推](#recommend)\n* [👬 贡献者](#contributor)\n* [📜 License](#license)\n\n\n<a id=\"cc\"></a>\n\n## ➕ C/C++\n\n### const\n\n#### 作用\n\n1. 修饰变量，说明该变量不可以被改变；\n2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；\n3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；\n4. 修饰成员函数，说明该成员函数内不能修改成员变量。\n\n#### const 的指针与引用\n\n* 指针\n    * 指向常量的指针（pointer to const）\n    * 自身是常量的指针（常量指针，const pointer）\n* 引用\n    * 指向常量的引用（reference to const）\n    * 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰\n\n> （为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 `p2`、`p3`\n\n#### 使用\n\nconst 使用\n\n```cpp\n// 类\nclass A\n{\nprivate:\n    const int a;                // 常对象成员，可以使用初始化列表或者类内初始化\n\npublic:\n    // 构造函数\n    A() : a(0) { };\n    A(int x) : a(x) { };        // 初始化列表\n\n    // const可用于对重载函数的区分\n    int getValue();             // 普通成员函数\n    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值\n};\n\nvoid function()\n{\n    // 对象\n    A b;                        // 普通对象，可以调用全部成员函数\n    const A a;                  // 常对象，只能调用常成员函数\n    const A *p = &a;            // 指针变量，指向常对象\n    const A &q = a;             // 指向常对象的引用\n\n    // 指针\n    char greeting[] = \"Hello\";\n    char* p1 = greeting;                // 指针变量，指向字符数组变量\n    const char* p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）\n    char* const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）\n    const char* const p4 = greeting;    // 自身是常量的指针，指向字符数组常量\n}\n\n// 函数\nvoid function1(const int Var);           // 传递过来的参数在函数内不可变\nvoid function2(const char* Var);         // 参数指针所指内容为常量\nvoid function3(char* const Var);         // 参数指针为常量\nvoid function4(const int& Var);          // 引用参数在函数内为常量\n\n// 函数返回值\nconst int function5();      // 返回一个常数\nconst int* function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();\nint* const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();\n```\n\n#### 宏定义 #define 和 const 常量 \n\n宏定义 #define|const 常量\n---|---\n宏定义，相当于字符替换|常量声明\n预处理器处理|编译器处理\n无类型安全检查|有类型安全检查\n不分配内存|要分配内存\n存储在代码段|存储在数据段\n可通过 `#undef` 取消|不可取消\n\n### static\n\n#### 作用\n\n1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。\n2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。\n3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。\n4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。\n\n### this 指针\n\n1. `this` 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。\n2. 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 `this` 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 `this` 指针。\n3. 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。\n4. `this` 指针被隐含地声明为: `ClassName *const this`，这意味着不能给 `this` 指针赋值；在 `ClassName` 类的 `const` 成员函数中，`this` 指针的类型为：`const ClassName* const`，这说明不能对 `this` 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；\n5. `this` 并不是一个常规变量，而是个右值，所以不能取得 `this` 的地址（不能 `&this`）。\n6. 在以下场景中，经常需要显式引用 `this` 指针：\n    1. 为实现对象的链式引用；\n    2. 为避免对同一对象进行赋值操作；\n    3. 在实现一些数据结构时，如 `list`。\n\n### inline 内联函数\n\n#### 特征\n\n* 相当于把内联函数里面的内容写在调用内联函数处；\n* 相当于不用执行进入函数的步骤，直接执行函数体；\n* 相当于宏，却比宏多了类型检查，真正具有函数特性；\n* 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；\n* 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。\n\n#### 使用\n\ninline 使用\n\n```cpp\n// 声明1（加 inline，建议使用）\ninline int functionName(int first, int second,...);\n\n// 声明2（不加 inline）\nint functionName(int first, int second,...);\n\n// 定义\ninline int functionName(int first, int second,...) {/****/};\n\n// 类内定义，隐式内联\nclass A {\n    int doA() { return 0; }         // 隐式内联\n}\n\n// 类外定义，需要显式内联\nclass A {\n    int doA();\n}\ninline int A::doA() { return 0; }   // 需要显式内联\n```\n\n#### 编译器对 inline 函数的处理步骤\n\n1. 将 inline 函数体复制到 inline 函数调用点处； \n2. 为所用 inline 函数中的局部变量分配内存空间； \n3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； \n4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。\n\n#### 优缺点\n\n优点\n\n1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。\n2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 \n3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。\n4. 内联函数在运行时可调试，而宏定义不可以。\n\n缺点\n\n1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。\n2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。\n3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。\n\n#### 虚函数（virtual）可以是内联函数（inline）吗？\n\n> [Are \"inline virtual\" member functions ever actually \"inlined\"?](http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html)\n\n* 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。\n* 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。\n* `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。\n\n虚函数内联使用\n\n```cpp\n#include <iostream>  \nusing namespace std;\nclass Base\n{\npublic:\n\tinline virtual void who()\n\t{\n\t\tcout << \"I am Base\\n\";\n\t}\n\tvirtual ~Base() {}\n};\nclass Derived : public Base\n{\npublic:\n\tinline void who()  // 不写inline时隐式内联\n\t{\n\t\tcout << \"I am Derived\\n\";\n\t}\n};\n\nint main()\n{\n\t// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 \n\tBase b;\n\tb.who();\n\n\t// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  \n\tBase *ptr = new Derived();\n\tptr->who();\n\n\t// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。\n\tdelete ptr;\n\tptr = nullptr;\n\n\tsystem(\"pause\");\n\treturn 0;\n} \n```\n\n### volatile\n\n```cpp\nvolatile int i = 10; \n```\n\n* volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。\n* volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）\n* const 可以是 volatile （如只读的状态寄存器）\n* 指针可以是 volatile\n\n### assert()\n\n断言，是宏，而非函数。assert 宏的原型定义在 `<assert.h>`（C）、`<cassert>`（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 `NDEBUG` 来关闭 assert，但是需要在源代码的开头，`include <assert.h>` 之前。\n\nassert() 使用\n\n```cpp\n#define NDEBUG          // 加上这行，则 assert 不可用\n#include <assert.h>\n\nassert( p != NULL );    // assert 不可用\n```\n\n### sizeof()\n\n* sizeof 对数组，得到整个数组所占空间大小。\n* sizeof 对指针，得到指针本身所占空间大小。\n\n### #pragma pack(n)\n\n设定结构体、联合以及类成员变量以 n 字节方式对齐\n\n#pragma pack(n) 使用\n\n```cpp\n#pragma pack(push)  // 保存对齐状态\n#pragma pack(4)     // 设定为 4 字节对齐\n\nstruct test\n{\n    char m1;\n    double m4;\n    int m3;\n};\n\n#pragma pack(pop)   // 恢复对齐状态\n```\n\n### 位域\n\n```cpp\nBit mode: 2;    // mode 占 2 位\n```\n\n类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。\n\n* 位域在内存中的布局是与机器有关的\n* 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定\n* 取地址运算符（&）不能作用于位域，任何指针都无法指向类的位域\n\n### extern \"C\"\n\n* 被 extern 限定的函数或变量是 extern 类型的\n* 被 `extern \"C\"` 修饰的变量和函数是按照 C 语言方式编译和链接的\n\n`extern \"C\"` 的作用是让 C++ 编译器将 `extern \"C\"` 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。\n\nextern \"C\" 使用\n\n```cpp\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid *memset(void *, int, size_t);\n\n#ifdef __cplusplus\n}\n#endif\n```\n\n### struct 和 typedef struct\n\n#### C 中\n\n```c\n// c\ntypedef struct Student {\n    int age; \n} S;\n```\n\n等价于\n\n```c\n// c\nstruct Student { \n    int age; \n};\n\ntypedef struct Student S;\n```\n\n此时 `S` 等价于 `struct Student`，但两个标识符名称空间不相同。\n\n另外还可以定义与 `struct Student` 不冲突的 `void Student() {}`。\n\n#### C++ 中\n\n由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。\n\n一、如果在类标识符空间定义了 `struct Student {...};`，使用 `Student me;` 时，编译器将搜索全局标识符表，`Student` 未找到，则在类标识符内搜索。\n\n即表现为可以使用 `Student` 也可以使用 `struct Student`，如下：\n\n```cpp\n// cpp\nstruct Student { \n    int age; \n};\n\nvoid f( Student me );       // 正确，\"struct\" 关键字可省略\n```\n\n二、若定义了与 `Student` 同名函数之后，则 `Student` 只代表函数，不代表结构体，如下：\n\n```cpp\ntypedef struct Student { \n    int age; \n} S;\n\nvoid Student() {}           // 正确，定义后 \"Student\" 只代表此函数\n\n//void S() {}               // 错误，符号 \"S\" 已经被定义为一个 \"struct Student\" 的别名\n\nint main() {\n    Student(); \n    struct Student me;      // 或者 \"S me\";\n    return 0;\n}\n```\n\n### C++ 中 struct 和 class\n\n总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。\n\n#### 区别\n\n* 最本质的一个区别就是默认的访问控制\n    1. 默认的继承访问权限。struct 是 public 的，class 是 private 的。  \n    2. struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。\n\n### union 联合\n\n联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：\n\n* 默认访问控制符为 public\n* 可以含有构造函数、析构函数\n* 不能含有引用类型的成员\n* 不能继承自其他类，不能作为基类\n* 不能含有虚函数\n* 匿名 union 在定义所在作用域可直接访问 union 成员\n* 匿名 union 不能包含 protected 成员或 private 成员\n* 全局匿名联合必须是静态（static）的\n\nunion 使用\n\n```cpp\n#include<iostream>\n\nunion UnionTest {\n    UnionTest() : i(10) {};\n    int i;\n    double d;\n};\n\nstatic union {\n    int i;\n    double d;\n};\n\nint main() {\n    UnionTest u;\n\n    union {\n        int i;\n        double d;\n    };\n\n    std::cout << u.i << std::endl;  // 输出 UnionTest 联合的 10\n\n    ::i = 20;\n    std::cout << ::i << std::endl;  // 输出全局静态匿名联合的 20\n\n    i = 30;\n    std::cout << i << std::endl;    // 输出局部匿名联合的 30\n\n    return 0;\n}\n```\n\n### C 实现 C++ 类\n\nC 实现 C++ 的面向对象特性（封装、继承、多态）\n\n* 封装：使用函数指针把属性与方法封装到结构体中\n* 继承：结构体嵌套\n* 多态：父类与子类方法的函数指针不同\n\n> [Can you write object-oriented code in C? [closed]](https://stackoverflow.com/a/351745)\n\n### explicit（显式）关键字\n\n* explicit 修饰构造函数时，可以防止隐式转换和复制初始化\n* explicit 修饰转换函数时，可以防止隐式转换，但 [按语境转换](https://zh.cppreference.com/w/cpp/language/implicit_conversion) 除外\n\nexplicit 使用\n\n```cpp\nstruct A\n{\n\tA(int) { }\n\toperator bool() const { return true; }\n};\n\nstruct B\n{\n\texplicit B(int) {}\n\texplicit operator bool() const { return true; }\n};\n\nvoid doA(A a) {}\n\nvoid doB(B b) {}\n\nint main()\n{\n\tA a1(1);\t\t// OK：直接初始化\n\tA a2 = 1;\t\t// OK：复制初始化\n\tA a3{ 1 };\t\t// OK：直接列表初始化\n\tA a4 = { 1 };\t\t// OK：复制列表初始化\n\tA a5 = (A)1;\t\t// OK：允许 static_cast 的显式转换 \n\tdoA(1);\t\t\t// OK：允许从 int 到 A 的隐式转换\n\tif (a1);\t\t// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换\n\tbool a6(a1);\t\t// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换\n\tbool a7 = a1;\t\t// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换\n\tbool a8 = static_cast<bool>(a1);  // OK ：static_cast 进行直接初始化\n\n\tB b1(1);\t\t// OK：直接初始化\n\tB b2 = 1;\t\t// 错误：被 explicit 修饰构造函数的对象不可以复制初始化\n\tB b3{ 1 };\t\t// OK：直接列表初始化\n\tB b4 = { 1 };\t\t// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化\n\tB b5 = (B)1;\t\t// OK：允许 static_cast 的显式转换\n\tdoB(1);\t\t\t// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换\n\tif (b1);\t\t// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换\n\tbool b6(b1);\t\t// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换\n\tbool b7 = b1;\t\t// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换\n\tbool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化\n\n\treturn 0;\n}\n```\n\n### friend 友元类和友元函数\n\n* 能访问私有成员  \n* 破坏封装性\n* 友元关系不可传递\n* 友元关系的单向性\n* 友元声明的形式及数量不受限制\n\n### using\n\n#### using 声明\n\n一条 `using 声明` 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：\n\n```cpp\nusing namespace_name::name;\n```\n\n#### 构造函数的 using 声明\n\n在 C++11 中，派生类能够重用其直接基类定义的构造函数。\n\n```cpp\nclass Derived : Base {\npublic:\n    using Base::Base;\n    /* ... */\n};\n```\n\n如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：\n\n```cpp\nDerived(parms) : Base(args) { }\n```\n\n#### using 指示\n\n`using 指示` 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：\n\n```cpp\nusing namespace_name name;\n```\n\n#### 尽量少使用 `using 指示` 污染命名空间\n\n> 一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它**只导入了指定的名称**。如果该名称与局部名称发生冲突，编译器将**发出指示**。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则**局部名称将覆盖名称空间版本**，而编译器**并不会发出警告**。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。\n\nusing 使用\n\n尽量少使用 `using 指示`\n\n```cpp\nusing namespace std;\n```\n\n应该多使用 `using 声明`\n\n```cpp\nint x;\nstd::cin >> x ;\nstd::cout << x << std::endl;\n```\n\n或者\n\n```cpp\nusing std::cin;\nusing std::cout;\nusing std::endl;\nint x;\ncin >> x;\ncout << x << endl;\n```\n\n### :: 范围解析运算符\n\n#### 分类\n\n1. 全局作用域符（`::name`）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间\n2. 类作用域符（`class::name`）：用于表示指定类型的作用域范围是具体某个类的\n3. 命名空间作用域符（`namespace::name`）:用于表示指定类型的作用域范围是具体某个命名空间的\n\n:: 使用\n\n```cpp\nint count = 11;         // 全局（::）的 count\n\nclass A {\npublic:\n\tstatic int count;   // 类 A 的 count（A::count）\n};\nint A::count = 21;\n\nvoid fun()\n{\n\tint count = 31;     // 初始化局部的 count 为 31\n\tcount = 32;         // 设置局部的 count 的值为 32\n}\n\nint main() {\n\t::count = 12;       // 测试 1：设置全局的 count 的值为 12\n\n\tA::count = 22;      // 测试 2：设置类 A 的 count 为 22\n\n\tfun();\t\t        // 测试 3\n\n\treturn 0;\n}\n```\n\n### enum 枚举类型\n\n#### 限定作用域的枚举类型\n\n```cpp\nenum class open_modes { input, output, append };\n```\n\n#### 不限定作用域的枚举类型\n\n```cpp\nenum color { red, yellow, green };\nenum { floatPrec = 6, doublePrec = 10 };\n```\n\n### decltype\n\ndecltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：\n\n```cpp\ndecltype ( expression )\n```\n\ndecltype 使用\n\n```cpp\n// 尾置返回允许我们在参数列表之后声明返回类型\ntemplate <typename It>\nauto fcn(It beg, It end) -> decltype(*beg)\n{\n    // 处理序列\n    return *beg;    // 返回序列中一个元素的引用\n}\n// 为了使用模板参数成员，必须用 typename\ntemplate <typename It>\nauto fcn2(It beg, It end) -> typename remove_reference<decltype(*beg)>::type\n{\n    // 处理序列\n    return *beg;    // 返回序列中一个元素的拷贝\n}\n```\n\n### 引用\n\n#### 左值引用\n\n常规引用，一般表示对象的身份。\n\n#### 右值引用\n\n右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。\n\n右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：\n\n* 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。\n* 能够更简洁明确地定义泛型函数。\n\n#### 引用折叠\n\n* `X& &`、`X& &&`、`X&& &` 可折叠成 `X&`\n* `X&& &&` 可折叠成 `X&&`\n\n### 宏\n\n* 宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。\n\n### 成员初始化列表\n\n好处\n\n* 更高效：少了一次调用默认构造函数的过程。\n* 有些场合必须要用初始化列表：\n  1. 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面\n  2. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面\n  3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化\n\n### initializer_list 列表初始化\n\n用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 `std::initializer_list` 参数.\n\ninitializer_list 使用\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <initializer_list>\n \ntemplate <class T>\nstruct S {\n    std::vector<T> v;\n    S(std::initializer_list<T> l) : v(l) {\n         std::cout << \"constructed with a \" << l.size() << \"-element list\\n\";\n    }\n    void append(std::initializer_list<T> l) {\n        v.insert(v.end(), l.begin(), l.end());\n    }\n    std::pair<const T*, std::size_t> c_arr() const {\n        return {&v[0], v.size()};  // 在 return 语句中复制列表初始化\n                                   // 这不使用 std::initializer_list\n    }\n};\n \ntemplate <typename T>\nvoid templated_fn(T) {}\n \nint main()\n{\n    S<int> s = {1, 2, 3, 4, 5}; // 复制初始化\n    s.append({6, 7, 8});      // 函数调用中的列表初始化\n \n    std::cout << \"The vector size is now \" << s.c_arr().second << \" ints:\\n\";\n \n    for (auto n : s.v)\n        std::cout << n << ' ';\n    std::cout << '\\n';\n \n    std::cout << \"Range-for over brace-init-list: \\n\";\n \n    for (int x : {-1, -2, -3}) // auto 的规则令此带范围 for 工作\n        std::cout << x << ' ';\n    std::cout << '\\n';\n \n    auto al = {10, 11, 12};   // auto 的特殊规则\n \n    std::cout << \"The list bound to auto has size() = \" << al.size() << '\\n';\n \n//    templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式，\n                             // 它无类型，故 T 无法推导\n    templated_fn<std::initializer_list<int>>({1, 2, 3}); // OK\n    templated_fn<std::vector<int>>({1, 2, 3});           // 也 OK\n}\n```\n\n### 面向对象\n\n面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。\n\n![面向对象特征](https://gitee.com/huihut/interview/raw/master/images/面向对象基本特征.png)\n\n面向对象三大特征 —— 封装、继承、多态\n\n### 封装\n\n把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。\n\n* `public` 成员：可以被任意实体访问\n* `protected` 成员：只允许被子类及本类的成员函数访问\n* `private` 成员：只允许被本类的成员函数、友元类或友元函数访问\n\n### 继承\n\n* 基类（父类）——&gt; 派生类（子类）\n\n### 多态\n\n* 多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。\n* 多态是以封装和继承为基础的。\n* C++ 多态分类及实现：\n    1. 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载\n    2. 子类型多态（Subtype Polymorphism，运行期）：虚函数\n    3. 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板\n    4. 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换\n\n> [The Four Polymorphisms in C++](https://catonmat.net/cpp-polymorphism)\n\n#### 静态多态（编译期/早绑定）\n\n函数重载\n\n```cpp\nclass A\n{\npublic:\n    void do(int a);\n    void do(int a, int b);\n};\n```\n\n#### 动态多态（运行期期/晚绑定）\n* 虚函数：用 virtual 修饰成员函数，使其成为虚函数\n* 动态绑定：当使用基类的引用或指针调用一个虚函数时将发生动态绑定\n\n**注意：**\n\n* 可以将派生类的对象赋值给基类的指针或引用，反之不可\n* 普通函数（非类成员函数）不能是虚函数\n* 静态函数（static）不能是虚函数\n* 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）\n* 内联函数不能是表现多态性时的虚函数，解释见：[虚函数（virtual）可以是内联函数（inline）吗？](https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97)\n\n动态多态使用\n\n```cpp\nclass Shape                     // 形状类\n{\npublic:\n    virtual double calcArea()\n    {\n        ...\n    }\n    virtual ~Shape();\n};\nclass Circle : public Shape     // 圆形类\n{\npublic:\n    virtual double calcArea();\n    ...\n};\nclass Rect : public Shape       // 矩形类\n{\npublic:\n    virtual double calcArea();\n    ...\n};\nint main()\n{\n    Shape * shape1 = new Circle(4.0);\n    Shape * shape2 = new Rect(5.0, 6.0);\n    shape1->calcArea();         // 调用圆形类里面的方法\n    shape2->calcArea();         // 调用矩形类里面的方法\n    delete shape1;\n    shape1 = nullptr;\n    delete shape2;\n    shape2 = nullptr;\n    return 0;\n}\n```\n\n### 虚析构函数\n\n虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。\n\n虚析构函数使用\n\n```cpp\nclass Shape\n{\npublic:\n    Shape();                    // 构造函数不能是虚函数\n    virtual double calcArea();\n    virtual ~Shape();           // 虚析构函数\n};\nclass Circle : public Shape     // 圆形类\n{\npublic:\n    virtual double calcArea();\n    ...\n};\nint main()\n{\n    Shape * shape1 = new Circle(4.0);\n    shape1->calcArea();    \n    delete shape1;  // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。\n    shape1 = NULL;\n    return 0；\n}\n```\n\n### 纯虚函数\n\n纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。\n\n```cpp\nvirtual int A() = 0;\n```\n\n### 虚函数、纯虚函数\n\n* 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 \n* 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。\n* 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 \n* 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。\n* 虚基类是虚继承中的基类，具体见下文虚继承。\n\n> [CSDN . C++ 中的虚函数、纯虚函数区别和联系](https://blog.csdn.net/u012260238/article/details/53610462)\n\n### 虚函数指针、虚函数表\n\n* 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。\n* 虚函数表：在程序只读数据段（`.rodata section`，见：[目标文件存储结构](#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。\n\n> [C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现](https://blog.twofei.com/496/)\n\n### 虚继承\n\n虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。\n\n底层实现原理与编译器相关，一般通过**虚基类指针**和**虚基类表**实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。\n\n实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。\n\n### 虚继承、虚函数\n\n* 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）\n* 不同之处：\n    * 虚继承\n        * 虚基类依旧存在继承类中，只占用存储空间\n        * 虚基类表存储的是虚基类相对直接继承类的偏移\n    * 虚函数\n        * 虚函数不占用存储空间\n        * 虚函数表存储的是虚函数地址\n\n### 类模板、成员模板、虚函数\n\n* 类模板中可以使用虚函数\n* 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数\n\n### 抽象类、接口类、聚合类\n\n* 抽象类：含有纯虚函数的类\n* 接口类：仅含有纯虚函数的抽象类\n* 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：\n    * 所有成员都是 public\n    * 没有定义任何构造函数\n    * 没有类内初始化\n    * 没有基类，也没有 virtual 函数\n\n### 内存分配和管理\n\n#### malloc、calloc、realloc、alloca\n\n1. malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。\n2. calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。\n3. realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。\n4. alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。\n\n#### malloc、free\n\n用于分配、释放内存\n\nmalloc、free 使用\n\n申请内存，确认是否申请成功\n\n```cpp\nchar *str = (char*) malloc(100);\nassert(str != nullptr);\n```\n\n释放内存后指针置空\n\n```cpp\nfree(p); \np = nullptr;\n```\n\n#### new、delete\n\n1. new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。\n2. delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。\n3. new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。\n\nnew、delete 使用\n\n申请内存，确认是否申请成功\n\n```cpp\nint main()\n{\n    T* t = new T();     // 先内存分配 ，再构造函数\n    delete t;           // 先析构函数，再内存释放\n    return 0;\n}\n```\n\n#### 定位 new\n\n定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。\n\n```cpp\nnew (place_address) type\nnew (place_address) type (initializers)\nnew (place_address) type [size]\nnew (place_address) type [size] { braced initializer list }\n```\n\n* `place_address` 是个指针\n* `initializers` 提供一个（可能为空的）以逗号分隔的初始值列表\n\n### delete this 合法吗？\n\n> [Is it legal (and moral) for a member function to say delete this?](https://isocpp.org/wiki/faq/freestore-mgmt#delete-this)\n\n合法，但：\n\n1. 必须保证 this 对象是通过 `new`（不是 `new[]`、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的\n2. 必须保证调用 `delete this` 的成员函数是最后一个调用 this 的成员函数\n3. 必须保证成员函数的 `delete this ` 后面没有调用 this 了\n4. 必须保证 `delete this` 后没有人使用了\n\n### 如何定义一个只能在堆上（栈上）生成对象的类？\n\n> [如何定义一个只能在堆上（栈上）生成对象的类?](https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618)\n\n#### 只能在堆上\n\n方法：将析构函数设置为私有\n\n原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。\n\n#### 只能在栈上\n\n方法：将 new 和 delete 重载为私有\n\n原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。\n\n### 智能指针\n\n#### C++ 标准库（STL）中\n\n头文件：`#include <memory>`\n\n#### C++ 98\n\n```cpp\nstd::auto_ptr<std::string> ps (new std::string(str))；\n```\n\n#### C++ 11\n\n1. shared_ptr\n2. unique_ptr\n3. weak_ptr\n4. auto_ptr（被 C++11 弃用）\n\n* Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。\n* Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。\n\n##### shared_ptr\n\n多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。\n\n* 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁\n\n##### weak_ptr\n\nweak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。\n\n* 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题\n\n##### unique_ptr\n\nunique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。\n\n* unique_ptr 用于取代 auto_ptr\n\n##### auto_ptr\n\n被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 `std::move` 语义，以及其他瑕疵。\n\n##### auto_ptr 与 unique_ptr 比较\n\n* auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了`move` 语义；\n* auto_ptr 对象不能管理数组（析构调用 `delete`），unique_ptr 可以管理数组（析构调用 `delete[]` ）；\n\n### 强制类型转换运算符\n\n> [MSDN . 强制转换运算符](https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx)\n\n#### static_cast\n\n* 用于非多态类型的转换\n* 不执行运行时类型检查（转换安全性不如 dynamic_cast）\n* 通常用于转换数值数据类型（如 float -> int）\n* 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）\n\n> 向上转换是一种隐式转换。\n\n#### dynamic_cast\n\n* 用于多态类型的转换\n* 执行行运行时类型检查\n* 只适用于指针或引用\n* 对不明确的指针的转换将失败（返回 nullptr），但不引发异常\n* 可以在整个类层次结构中移动指针，包括向上转换、向下转换\n\n#### const_cast \n\n* 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）\n\n#### reinterpret_cast\n\n* 用于位的简单重新解释\n* 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。\n* 允许将任何指针转换为任何其他指针类型（如 `char*` 到 `int*` 或 `One_class*` 到 `Unrelated_class*` 之类的转换，但其本身并不安全）\n* 也允许将任何整数类型转换为任何指针类型以及反向转换。\n* reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 \n* reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。\n\n#### bad_cast\n\n* 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。\n\nbad_cast 使用\n\n```cpp\ntry {  \n    Circle& ref_circle = dynamic_cast<Circle&>(ref_shape);   \n}  \ncatch (bad_cast b) {  \n    cout << \"Caught: \" << b.what();  \n} \n```\n\n### 运行时类型信息 (RTTI) \n\n#### dynamic_cast\n\n* 用于多态类型的转换\n\n#### typeid\n\n* typeid 运算符允许在运行时确定对象的类型\n* type\\_id 返回一个 type\\_info 对象的引用\n* 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数\n* 只能获取对象的实际类型\n\n#### type_info\n\n* type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。\n* 头文件：`typeinfo`\n\ntypeid、type_info 使用\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Flyable                       // 能飞的\n{\npublic:\n    virtual void takeoff() = 0;     // 起飞\n    virtual void land() = 0;        // 降落\n};\nclass Bird : public Flyable         // 鸟\n{\npublic:\n    void foraging() {...}           // 觅食\n    virtual void takeoff() {...}\n    virtual void land() {...}\n    virtual ~Bird(){}\n};\nclass Plane : public Flyable        // 飞机\n{\npublic:\n    void carry() {...}              // 运输\n    virtual void takeoff() {...}\n    virtual void land() {...}\n};\n\nclass type_info\n{\npublic:\n    const char* name() const;\n    bool operator == (const type_info & rhs) const;\n    bool operator != (const type_info & rhs) const;\n    int before(const type_info & rhs) const;\n    virtual ~type_info();\nprivate:\n    ...\n};\n\nvoid doSomething(Flyable *obj)                 // 做些事情\n{\n    obj->takeoff();\n\n    cout << typeid(*obj).name() << endl;        // 输出传入对象类型（\"class Bird\" or \"class Plane\"）\n\n    if(typeid(*obj) == typeid(Bird))            // 判断对象类型\n    {\n        Bird *bird = dynamic_cast<Bird *>(obj); // 对象转化\n        bird->foraging();\n    }\n\n    obj->land();\n}\n\nint main(){\n\tBird *b = new Bird();\n\tdoSomething(b);\n\tdelete b;\n\tb = nullptr;\n\treturn 0;\n}\n```\n\n<a id=\"effective\"></a>\n\n## ⭐️ Effective\n\n### Effective C++\n\n1. 视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）\n2. 宁可以编译器替换预处理器（尽量以 `const`、`enum`、`inline` 替换 `#define`）\n3. 尽可能使用 const\n4. 确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）\n5. 了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）\n6. 若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）\n7. 为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）\n8. 别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）\n9. 绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）\n10. 令 `operator=` 返回一个 `reference to *this` （用于连锁赋值）\n11. 在 `operator=` 中处理 “自我赋值”\n12. 赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）\n13. 以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））\n14. 在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））\n15. 在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）\n16. 成对使用 new 和 delete 时要采取相同形式（`new` 中使用 `[]` 则 `delete []`，`new` 中不使用 `[]` 则 `delete`）\n17. 以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）\n18. 让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）\n19. 设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。\n20. 宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）\n21. 必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）\n22. 将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）\n23. 宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）\n24. 若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数\n25. 考虑写一个不抛异常的 swap 函数\n26. 尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）\n27. 尽量少做转型动作（旧式：`(T)expression`、`T(expression)`；新式：`const_cast<T>(expression)`、`dynamic_cast<T>(expression)`、`reinterpret_cast<T>(expression)`、`static_cast<T>(expression)`、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）\n28. 避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）\n29. 为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）\n30. 透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）\n31. 将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）\n32. 确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）\n33. 避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）\n34. 区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）\n35. 考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 `tr1::function` 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）\n36. 绝不重新定义继承而来的 non-virtual 函数\n37. 绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）\n38. 通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出））\n39. 明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承）\n40. 明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本）\n41. 了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期）\n42. 了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符）\n43. 学习处理模板化基类内的名称（可在 derived class templates 内通过 `this->` 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成）\n44. 将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码）\n45. 运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符）\n46. 需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”）\n47. 请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if...else 测试）\n48. 认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码）\n49. 了解 new-handler 的行为（set\\_new\\_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常）\n50. 了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为）\n51. 编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”）\n52. 写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本）\n53. 不要轻忽编译器的警告\n54. 让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件）\n55. 让自己熟悉 Boost（准标准库）\n\n### More Effective c++\n\n1. 仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers）\n2. 最好使用 C++ 转型操作符（`static_cast`、`const_cast`、`dynamic_cast`、`reinterpret_cast`）\n3. 绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用）\n4. 非必要不提供 default constructor（避免对象中的字段被无意义地初始化）\n5. 对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为）\n6. 区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础）\n7. 千万不要重载 `&&`，`||` 和 `,` 操作符（`&&` 与 `||` 的重载会用 “函数调用语义” 取代 “骤死式语义”；`,` 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估）\n8. 了解各种不同意义的 new 和 delete（`new operator`、`operator new`、`placement new`、`operator new[]`；`delete operator`、`operator delete`、`destructor`、`operator delete[]`）\n9. 利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏）\n10. 在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try...catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题）\n11. 禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情）\n12. 了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数）\n13. 以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数）\n14. 明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions）\n15. 了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions）\n16. 谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码）\n17. 考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作）\n18. 分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率）\n\n### Google C++ Style Guide\n\n* 英文：[Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html)\n* 中文：[C++ 风格指南](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/)\n\n### 其他\n\n* [Bjarne Stroustrup 的常见问题](http://www.stroustrup.com/bs_faq.html)\n* [Bjarne Stroustrup 的 C++ 风格和技巧常见问题](http://www.stroustrup.com/bs_faq2.html)\n\n<a id=\"stl\"></a>\n\n## 📦 STL\n\n### STL 索引\n\n[STL 方法含义索引](https://github.com/huihut/interview/tree/master/STL)\n\n### STL 容器\n\n容器 | 底层数据结构 | 时间复杂度 | 有无序 | 可不可重复 | 其他\n---|---|---|---|---|---\n[array](https://github.com/huihut/interview/tree/master/STL#array)|数组|随机读改 O(1)|无序|可重复|支持随机访问\n[vector](https://github.com/huihut/interview/tree/master/STL#vector)|数组|随机读改、尾部插入、尾部删除 O(1)<br/>头部插入、头部删除 O(n)|无序|可重复|支持随机访问\n[deque](https://github.com/huihut/interview/tree/master/STL#deque)|双端队列|头尾插入、头尾删除 O(1)|无序|可重复|一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问\n[forward_list](https://github.com/huihut/interview/tree/master/STL#forward_list)|单向链表|插入、删除 O(1)|无序|可重复|不支持随机访问\n[list](https://github.com/huihut/interview/tree/master/STL#list)|双向链表|插入、删除 O(1)|无序|可重复|不支持随机访问\n[stack](https://github.com/huihut/interview/tree/master/STL#stack)|deque / list|顶部插入、顶部删除 O(1)|无序|可重复|deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时\n[queue](https://github.com/huihut/interview/tree/master/STL#queue)|deque / list|尾部插入、头部删除 O(1)|无序|可重复|deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时\n[priority_queue](https://github.com/huihut/interview/tree/master/STL#priority_queue)|vector + max-heap|插入、删除 O(log<sub>2</sub>n)|有序|可重复|vector容器+heap处理规则\n[set](https://github.com/huihut/interview/tree/master/STL#set)|红黑树|插入、删除、查找 O(log<sub>2</sub>n)|有序|不可重复|\n[multiset](https://github.com/huihut/interview/tree/master/STL#multiset)|红黑树|插入、删除、查找 O(log<sub>2</sub>n)|有序|可重复|\n[map](https://github.com/huihut/interview/tree/master/STL#map)|红黑树|插入、删除、查找 O(log<sub>2</sub>n)|有序|不可重复|\n[multimap](https://github.com/huihut/interview/tree/master/STL#multimap)|红黑树|插入、删除、查找 O(log<sub>2</sub>n)|有序|可重复|\n[unordered_set](https://github.com/huihut/interview/tree/master/STL#unordered_set)|哈希表|插入、删除、查找 O(1) 最差 O(n)|无序|不可重复|\n[unordered_multiset](https://github.com/huihut/interview/tree/master/STL#unordered_multiset)|哈希表|插入、删除、查找 O(1) 最差 O(n)|无序|可重复|\n[unordered_map](https://github.com/huihut/interview/tree/master/STL#unordered_map)|哈希表|插入、删除、查找 O(1) 最差 O(n)|无序|不可重复|\n[unordered_multimap](https://github.com/huihut/interview/tree/master/STL#unordered_multimap)|哈希表|插入、删除、查找 O(1) 最差 O(n)|无序|可重复|\n\n### STL 算法\n\n算法 | 底层算法 | 时间复杂度 | 可不可重复\n---|---|---|---\n[find](http://www.cplusplus.com/reference/algorithm/find/)|顺序查找|O(n)|可重复\n[sort](https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h#L4808)|[内省排序](https://en.wikipedia.org/wiki/Introsort)|O(n*log<sub>2</sub>n)|可重复\n\n\n<a id=\"data-structure\"></a>\n\n## 〽️ 数据结构\n\n### 顺序结构\n\n#### 顺序栈（Sequence Stack）\n\n[SqStack.cpp](DataStructure/SqStack.cpp)\n\n顺序栈数据结构和图片\n\n```cpp\ntypedef struct {\n\tElemType *elem;\n\tint top;\n\tint size;\n\tint increment;\n} SqStack;\n```\n\n![](https://gitee.com/huihut/interview/raw/master/images/SqStack.png)\n\n#### 队列（Sequence Queue）\n\n队列数据结构\n\n```cpp\ntypedef struct {\n\tElemType * elem;\n\tint front;\n\tint rear;\n\tint maxSize;\n}SqQueue;\n```\n\n##### 非循环队列\n\n非循环队列图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/SqQueue.png)\n\n`SqQueue.rear++`\n\n##### 循环队列\n\n循环队列图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/SqLoopStack.png)\n\n`SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize`\n\n#### 顺序表（Sequence List）\n\n[SqList.cpp](DataStructure/SqList.cpp)\n\n顺序表数据结构和图片\n\n```cpp\ntypedef struct {\n\tElemType *elem;\n\tint length;\n\tint size;\n\tint increment;\n} SqList;\n```\n\n![](https://gitee.com/huihut/interview/raw/master/images/SqList.png)\n\n\n### 链式结构\n\n[LinkList.cpp](DataStructure/LinkList.cpp)\n\n[LinkList_with_head.cpp](DataStructure/LinkList_with_head.cpp)\n\n链式数据结构\n\n```cpp\ntypedef struct LNode {\n    ElemType data;\n    struct LNode *next;\n} LNode, *LinkList; \n```\n\n#### 链队列（Link Queue）\n\n链队列图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/LinkQueue.png)\n\n#### 线性表的链式表示\n\n##### 单链表（Link List）\n\n单链表图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/LinkList.png)\n\n##### 双向链表（Du-Link-List）\n\n双向链表图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/DuLinkList.png)\n\n##### 循环链表（Cir-Link-List）\n\n循环链表图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/CirLinkList.png)\n\n### 哈希表\n\n[HashTable.cpp](DataStructure/HashTable.cpp)\n\n#### 概念\n\n哈希函数：`H(key): K -> D , key ∈ K`\n\n#### 构造方法\n\n* 直接定址法\n* 除留余数法\n* 数字分析法\n* 折叠法\n* 平方取中法\n\n#### 冲突处理方法\n\n* 链地址法：key 相同的用单链表链接\n* 开放定址法\n    * 线性探测法：key 相同 -> 放到 key 的下一个位置，`Hi = (H(key) + i) % m`\n    * 二次探测法：key 相同 -> 放到 `Di = 1^2, -1^2, ..., ±（k)^2,(k<=m/2）`\n    * 随机探测法：`H = (H(key) + 伪随机数) % m`\n\n#### 线性探测的哈希表数据结构\n\n线性探测的哈希表数据结构和图片\n\n```cpp\ntypedef char KeyType;\n\ntypedef struct {\n\tKeyType key;\n}RcdType;\n\ntypedef struct {\n\tRcdType *rcd;\n\tint size;\n\tint count;\n\tbool *tag;\n}HashTable;\n```\n\n![](https://gitee.com/huihut/interview/raw/master/images/HashTable.png)\n\n### 递归\n\n#### 概念\n\n函数直接或间接地调用自身\n\n#### 递归与分治\n\n* 分治法\n    * 问题的分解\n    * 问题规模的分解\n* 折半查找（递归）\n* 归并排序（递归）\n* 快速排序（递归）\n\n#### 递归与迭代\n\n* 迭代：反复利用变量旧值推出新值\n* 折半查找（迭代）\n* 归并排序（迭代）\n\n#### 广义表\n\n##### 头尾链表存储表示\n\n广义表的头尾链表存储表示和图片\n\n```cpp\n// 广义表的头尾链表存储表示\ntypedef enum {ATOM, LIST} ElemTag;\n// ATOM==0：原子，LIST==1：子表\ntypedef struct GLNode {\n    ElemTag tag;\n    // 公共部分，用于区分原子结点和表结点\n    union {\n        // 原子结点和表结点的联合部分\n        AtomType atom;\n        // atom 是原子结点的值域，AtomType 由用户定义\n        struct {\n            struct GLNode *hp, *tp;\n        } ptr;\n        // ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾\n    } a;\n} *GList, GLNode;\n```\n\n![](https://gitee.com/huihut/interview/raw/master/images/GeneralizedList1.png)\n\n##### 扩展线性链表存储表示\n\n扩展线性链表存储表示和图片\n\n```cpp\n// 广义表的扩展线性链表存储表示\ntypedef enum {ATOM, LIST} ElemTag;\n// ATOM==0：原子，LIST==1：子表\ntypedef struct GLNode1 {\n    ElemTag tag;\n    // 公共部分，用于区分原子结点和表结点\n    union {\n        // 原子结点和表结点的联合部分\n        AtomType atom; // 原子结点的值域\n        struct GLNode1 *hp; // 表结点的表头指针\n    } a;\n    struct GLNode1 *tp;\n    // 相当于线性链表的 next，指向下一个元素结点\n} *GList1, GLNode1;\n```\n\n![](https://gitee.com/huihut/interview/raw/master/images/GeneralizedList2.png)\n\n### 二叉树\n\n[BinaryTree.cpp](DataStructure/BinaryTree.cpp)\n\n#### 性质\n\n1. 非空二叉树第 i 层最多 2<sup>(i-1)</sup> 个结点 （i >= 1）\n2. 深度为 k 的二叉树最多 2<sup>k</sup> - 1 个结点 （k >= 1）\n3. 度为 0 的结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1\n4. 有 n 个结点的完全二叉树深度 k = ⌊ log<sub>2</sub>(n) ⌋ + 1 \n5. 对于含 n 个结点的完全二叉树中编号为 i （1 <= i <= n） 的结点\n    1. 若 i = 1，为根，否则双亲为 ⌊ i / 2 ⌋\n    2. 若 2i > n，则 i 结点没有左孩子，否则孩子编号为 2i\n    3. 若 2i + 1 > n，则 i 结点没有右孩子，否则孩子编号为 2i + 1\n\n#### 存储结构\n\n二叉树数据结构\n\n```cpp\ntypedef struct BiTNode\n{\n    TElemType data;\n    struct BiTNode *lchild, *rchild;\n}BiTNode, *BiTree;\n```\n\n##### 顺序存储\n\n二叉树顺序存储图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/SqBinaryTree.png)\n\n##### 链式存储\n\n二叉树链式存储图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/LinkBinaryTree.png)\n\n#### 遍历方式\n\n* 先序遍历\n* 中序遍历\n* 后续遍历\n* 层次遍历\n\n#### 分类\n\n* 满二叉树\n* 完全二叉树（堆）\n    * 大顶堆：根 >= 左 && 根 >= 右\n    * 小顶堆：根 <= 左 && 根 <= 右\n* 二叉查找树（二叉排序树）：左 < 根 < 右\n* 平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | <= 1\n* 最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整：\n    * LL型：根的左孩子右旋\n    * RR型：根的右孩子左旋\n    * LR型：根的左孩子左旋，再右旋\n    * RL型：右孩子的左子树，先右旋，再左旋\n\n### 其他树及森林\n\n#### 树的存储结构\n\n* 双亲表示法\n* 双亲孩子表示法\n* 孩子兄弟表示法\n\n#### 并查集\n\n一种不相交的子集所构成的集合 S = {S1, S2, ..., Sn}\n\n#### 平衡二叉树（AVL树）\n\n##### 性质\n\n* | 左子树树高 - 右子树树高 | <= 1\n* 平衡二叉树必定是二叉搜索树，反之则不一定\n* 最小二叉平衡树的节点的公式：`F(n)=F(n-1)+F(n-2)+1` （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量）\n\n平衡二叉树图片\n\n![](https://gitee.com/huihut/interview/raw/master/images/Self-balancingBinarySearchTree.png)\n\n##### 最小失衡树\n\n平衡二叉树插入新结点导致失衡的子树\n\n调整：\n\n* LL 型：根的左孩子右旋\n* RR 型：根的右孩子左旋\n* LR 型：根的左孩子左旋，再右旋\n* RL 型：右孩子的左子树，先右旋，再左旋\n\n#### 红黑树\n\n[RedBlackTree.cpp](DataStructure/RedBlackTree.cpp)\n\n##### 红黑树的特征是什么？\n\n1. 节点是红色或黑色。\n2. 根是黑色。\n3. 所有叶子都是黑色（叶子是 NIL 节点）。\n4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）\n5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）\n\n##### 调整\n\n1. 变色\n2. 左旋\n3. 右旋\n\n##### 应用\n\n* 关联数组：如 STL 中的 map、set\n\n##### 红黑树、B 树、B+ 树的区别？\n\n* 红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些\n* B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。\n\n#### B 树（B-tree）、B+ 树（B+-tree）\n\nB 树、B+ 树图片\n\n![B 树（B-tree）、B+ 树（B+-tree）](https://i.stack.imgur.com/l6UyF.png)\n\n##### 特点\n\n* 一般化的二叉查找树（binary search tree）\n* “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）\n\n##### 应用\n\n* 大部分文件系统、数据库系统都采用B树、B+树作为索引结构\n\n##### 区别\n\n* B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。\n* B+树中所有叶子节点都是通过指针连接在一起，而B树不会。\n\n##### B树的优点\n\n对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。\n\n##### B+树的优点\n\n* 非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。\n* 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。\n\n> B 树、B+ 树区别来自：[differences-between-b-trees-and-b-trees](https://stackoverflow.com/questions/870218/differences-between-b-trees-and-b-trees)、[B树和B+树的区别](https://www.cnblogs.com/ivictor/p/5849061.html)\n\n#### 八叉树\n\n八叉树图片\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Octree2.png/400px-Octree2.png)\n\n八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。\n\n##### 用途\n\n* 三维计算机图形\n* 最邻近搜索\n\n<a id=\"algorithm\"></a>\n\n## ⚡️ 算法\n\n### 排序\n\n排序算法 | 平均时间复杂度 | 最差时间复杂度 | 空间复杂度 | 数据对象稳定性\n---|---|---|---|---\n[冒泡排序](Algorithm/BubbleSort.h) | O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|稳定\n[选择排序](Algorithm/SelectionSort.h) | O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|数组不稳定、链表稳定\n[插入排序](Algorithm/InsertSort.h) | O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|稳定\n[快速排序](Algorithm/QuickSort.h) | O(n*log<sub>2</sub>n) |  O(n<sup>2</sup>) | O(log<sub>2</sub>n) | 不稳定\n[堆排序](Algorithm/HeapSort.cpp) | O(n*log<sub>2</sub>n)|O(n*log<sub>2</sub>n)|O(1)|不稳定\n[归并排序](Algorithm/MergeSort.h) | O(n*log<sub>2</sub>n) | O(n*log<sub>2</sub>n)|O(n)|稳定\n[希尔排序](Algorithm/ShellSort.h) | O(n*log<sup>2</sup>n)|O(n<sup>2</sup>)|O(1)|不稳定\n[计数排序](Algorithm/CountSort.cpp) | O(n+m)|O(n+m)|O(n+m)|稳定\n[桶排序](Algorithm/BucketSort.cpp) | O(n)|O(n)|O(m)|稳定\n[基数排序](Algorithm/RadixSort.h) | O(k*n)|O(n<sup>2</sup>)| |稳定\n\n> * 均按从小到大排列\n> * k：代表数值中的 “数位” 个数\n> * n：代表数据规模\n> * m：代表数据的最大值减最小值\n> * 来自：[wikipedia . 排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)\n\n### 查找\n\n查找算法 | 平均时间复杂度 | 空间复杂度 | 查找条件\n---|---|---|---\n[顺序查找](Algorithm/SequentialSearch.h) | O(n) | O(1) | 无序或有序\n[二分查找（折半查找）](Algorithm/BinarySearch.h) | O(log<sub>2</sub>n)| O(1) | 有序\n[插值查找](Algorithm/InsertionSearch.h) | O(log<sub>2</sub>(log<sub>2</sub>n)) | O(1) | 有序\n[斐波那契查找](Algorithm/FibonacciSearch.cpp) | O(log<sub>2</sub>n) | O(1) | 有序\n[哈希查找](DataStructure/HashTable.cpp) | O(1) | O(n) | 无序或有序\n[二叉查找树（二叉搜索树查找）](Algorithm/BSTSearch.h) |O(log<sub>2</sub>n) |   | \n[红黑树](DataStructure/RedBlackTree.cpp) |O(log<sub>2</sub>n) | |\n2-3树 | O(log<sub>2</sub>n - log<sub>3</sub>n) |   | \nB树/B+树 |O(log<sub>2</sub>n) |   | \n\n### 图搜索算法\n\n图搜索算法 |数据结构| 遍历时间复杂度 | 空间复杂度\n---|---|---|---\n[BFS广度优先搜索](https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)|邻接矩阵<br/>邻接链表|O(\\|v\\|<sup>2</sup>)<br/>O(\\|v\\|+\\|E\\|)|O(\\|v\\|<sup>2</sup>)<br/>O(\\|v\\|+\\|E\\|)\n[DFS深度优先搜索](https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)|邻接矩阵<br/>邻接链表|O(\\|v\\|<sup>2</sup>)<br/>O(\\|v\\|+\\|E\\|)|O(\\|v\\|<sup>2</sup>)<br/>O(\\|v\\|+\\|E\\|)\n\n### 其他算法\n\n算法 |思想| 应用\n---|---|---\n[分治法](https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95)|把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并|[循环赛日程安排问题](https://github.com/huihut/interview/tree/master/Problems/RoundRobinProblem)、排序算法（快速排序、归并排序）\n[动态规划](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92)|通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题|[背包问题](https://github.com/huihut/interview/tree/master/Problems/KnapsackProblem)、斐波那契数列\n[贪心法](https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95)|一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法|旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码\n\n<a id=\"problems\"></a>\n\n## ❓ Problems\n\n### Single Problem\n\n* [Chessboard Coverage Problem（棋盘覆盖问题）](Problems/ChessboardCoverageProblem)\n* [Knapsack Problem（背包问题）](Problems/KnapsackProblem)\n* [Neumann Neighbor Problem（冯诺依曼邻居问题）](Problems/NeumannNeighborProblem)\n* [Round Robin Problem（循环赛日程安排问题）](Problems/RoundRobinProblem)\n* [Tubing Problem（输油管道问题）](Problems/TubingProblem)\n\n### Leetcode Problems\n\n* [Github . haoel/leetcode](https://github.com/haoel/leetcode)\n* [Github . pezy/LeetCode](https://github.com/pezy/LeetCode)\n\n### 剑指 Offer\n\n* [Github . zhedahht/CodingInterviewChinese2](https://github.com/zhedahht/CodingInterviewChinese2)\n* [Github . gatieme/CodingInterviews](https://github.com/gatieme/CodingInterviews)\n\n### Cracking the Coding Interview 程序员面试金典\n\n* [Github . careercup/ctci](https://github.com/careercup/ctci)\n* [牛客网 . 程序员面试金典](https://www.nowcoder.com/ta/cracking-the-coding-interview)\n\n### 牛客网\n\n* [牛客网 . 在线编程专题](https://www.nowcoder.com/activity/oj)\n\n<a id=\"os\"></a>\n\n## 💻 操作系统\n\n### 进程与线程\n\n对于有线程系统：\n* 进程是资源分配的独立单位\n* 线程是资源调度的独立单位\n\n对于无线程系统：\n* 进程是资源调度、分配的独立单位\n\n#### 进程之间的通信方式以及优缺点\n\n* 管道（PIPE）\n    * 有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信\n        * 优点：可以实现任意关系的进程间的通信\n        * 缺点：\n            1. 长期存于系统中，使用不当容易出错\n            2. 缓冲区有限\n    * 无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）\n        * 优点：简单方便\n        * 缺点：\n            1. 局限于单向通信 \n            2. 只能创建在它的进程以及其有亲缘关系的进程之间\n            3. 缓冲区有限\n* 信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问\n    * 优点：可以同步进程\n    * 缺点：信号量有限\n* 信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生\n* 消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识\n    * 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便\n    * 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合\n* 共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问\n    * 优点：无须复制，快捷，信息量大\n    * 缺点：\n        1. 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题\n        2. 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信\n* 套接字（Socket）：可用于不同计算机间的进程通信\n    * 优点：\n        1. 传输数据为字节级，传输数据可自定义，数据量小效率高\n        2. 传输数据时间短，性能高\n        3. 适合于客户端和服务器端之间信息实时交互\n        4. 可以加密,数据安全性强\n    * 缺点：需对传输的数据进行解析，转化成应用级的数据。\n\n#### 线程之间的通信方式\n\n* 锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）\n    * 互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。\n    * 读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。\n    * 自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。\n    * 条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。\n* 信号量机制(Semaphore)\n    * 无名线程信号量\n    * 命名线程信号量\n* 信号机制(Signal)：类似进程间的信号处理\n* 屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。\n\n线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制  \n\n> 进程之间的通信方式以及优缺点来源于：[进程线程面试题总结](http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977)\n\n#### 进程之间私有和共享的资源\n\n* 私有：地址空间、堆、全局变量、栈、寄存器\n* 共享：代码段，公共数据，进程目录，进程 ID\n\n#### 线程之间私有和共享的资源\n\n* 私有：线程栈，寄存器，程序计数器\n* 共享：堆，地址空间，全局变量，静态变量\n\n#### 多进程与多线程间的对比、优劣与选择\n\n##### 对比\n\n对比维度 | 多进程 | 多线程 | 总结\n---|---|---|---\n数据共享、同步|数据共享复杂，需要用 IPC；数据是分开的，同步简单|因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂|各有优势\n内存、CPU|占用内存多，切换复杂，CPU 利用率低|占用内存少，切换简单，CPU 利用率高|线程占优\n创建销毁、切换|创建销毁、切换复杂，速度慢|创建销毁、切换简单，速度很快|线程占优\n编程、调试|编程简单，调试简单|编程复杂，调试复杂|进程占优\n可靠性|进程间不会互相影响|一个线程挂掉将导致整个进程挂掉|进程占优\n分布式|适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单|适应于多核分布式|进程占优\n\n##### 优劣\n\n优劣|多进程|多线程\n---|---|---\n优点|编程、调试简单，可靠性较高|创建、销毁、切换速度快，内存、资源占用小\n缺点|创建、销毁、切换速度慢，内存、资源占用大|编程、调试复杂，可靠性较差\n\n##### 选择\n\n* 需要频繁创建销毁的优先用线程\n* 需要进行大量计算的优先使用线程\n* 强相关的处理用线程，弱相关的处理用进程\n* 可能要扩展到多机分布的用进程，多核分布的用线程\n* 都满足需求的情况下，用你最熟悉、最拿手的方式\n\n> 多进程与多线程间的对比、优劣与选择来自：[多线程还是多进程的选择及区别](https://blog.csdn.net/lishenglong666/article/details/8557215)\n\n### Linux 内核的同步方式\n\n#### 原因\n\n在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。\n\n#### 同步方式\n\n* 原子操作\n* 信号量（semaphore）\n* 读写信号量（rw_semaphore）\n* 自旋锁（spinlock）\n* 大内核锁（BKL，Big Kernel Lock）\n* 读写锁（rwlock）\n* 大读者锁（brlock-Big Reader Lock）\n* 读-拷贝修改(RCU，Read-Copy Update)\n* 顺序锁（seqlock）\n\n> 来自：[Linux 内核的同步机制，第 1 部分](https://www.ibm.com/developerworks/cn/linux/l-synch/part1/)、[Linux 内核的同步机制，第 2 部分](https://www.ibm.com/developerworks/cn/linux/l-synch/part2/)\n\n### 死锁\n\n#### 原因\n\n* 系统资源不足\n* 资源分配不当\n* 进程运行推进顺序不合适\n\n#### 产生条件\n\n* 互斥\n* 请求和保持\n* 不剥夺\n* 环路\n\n#### 预防\n\n* 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。\n* 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。\n* 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。\n* 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。\n* 有序资源分配法\n* 银行家算法\n\n### 文件系统\n\n* Windows：FCB 表 + FAT + 位图\n* Unix：inode + 混合索引 + 成组链接\n\n### 主机字节序与网络字节序\n\n#### 主机字节序（CPU 字节序）\n\n##### 概念\n\n主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种：\n\n* 大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址\n* 小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址\n\n##### 存储方式\n\n32 位整数 `0x12345678` 是从起始位置为 `0x00` 的地址开始存放，则：\n\n内存地址 | 0x00 | 0x01 | 0x02 | 0x03\n---|---|---|---|---\n大端|12|34|56|78\n小端|78|56|34|12\n\n大端小端图片\n\n![大端序](https://gitee.com/huihut/interview/raw/master/images/CPU-Big-Endian.svg.png)\n![小端序](https://gitee.com/huihut/interview/raw/master/images/CPU-Little-Endian.svg.png)\n\n##### 判断大端小端\n\n判断大端小端\n\n可以这样判断自己 CPU 字节序是大端还是小端：\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint i = 0x12345678;\n\n\tif (*((char*)&i) == 0x12)\n\t\tcout << \"大端\" << endl;\n\telse\t\n\t\tcout << \"小端\" << endl;\n\n\treturn 0;\n}\n```\n\n##### 各架构处理器的字节序\n\n* x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序；\n* Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序；\n* ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。\n\n#### 网络字节序\n\n网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。\n\n网络字节顺序采用：大端（Big Endian）排列方式。\n\n### 页面置换算法\n\n在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。\n\n#### 分类\n\n* 全局置换：在整个内存空间置换\n* 局部置换：在本进程中进行置换\n\n#### 算法\n\n全局：\n* 工作集算法\n* 缺页率置换算法\n\n局部：\n* 最佳置换算法（OPT）\n* 先进先出置换算法（FIFO）\n* 最近最久未使用（LRU）算法\n* 时钟（Clock）置换算法\n\n<a id=\"computer-network\"></a>\n\n## ☁️ 计算机网络\n\n> 本节部分知识点来自《计算机网络（第 7 版）》\n\n计算机网络体系结构：\n\n![计算机网络体系结构](https://gitee.com/huihut/interview/raw/master/images/计算机网络体系结构.png)\n\n### 各层作用及协议\n\n分层 | 作用 | 协议\n---|---|---\n物理层 | 通过媒介传输比特，确定机械及电气规范（比特 Bit） | RJ45、CLOCK、IEEE802.3（中继器，集线器）\n数据链路层|将比特组装成帧和点到点的传递（帧 Frame）| PPP、FR、HDLC、VLAN、MAC（网桥，交换机）\n网络层|负责数据包从源到宿的传递和网际互连（包 Packet）|IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）\n运输层|提供端到端的可靠报文传递和错误恢复（ 段Segment）|TCP、UDP、SPX\n会话层|建立、管理和终止会话（会话协议数据单元 SPDU）|NFS、SQL、NETBIOS、RPC\n表示层|对数据进行翻译、加密和压缩（表示协议数据单元 PPDU）|JPEG、MPEG、ASII\n应用层|允许访问OSI环境的手段（应用协议数据单元 APDU）|FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS\n\n\n### 物理层\n\n* 传输数据的单位：比特\n* 数据传输系统：源系统（源点、发送器） --> 传输系统 --> 目的系统（接收器、终点）\n\n通道：\n* 单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播\n* 双向交替通信（半双工通信）：通信双方都可发消息，但不能同时发送或接收\n* 双向同时通信（全双工通信）：通信双方可以同时发送和接收信息\n\n通道复用技术：\n* 频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源\n* 时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度\n* 波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用\n* 码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信\n\n### 数据链路层\n\n主要信道：\n* 点对点信道\n* 广播信道\n\n#### 点对点信道\n\n* 数据单元：帧\n\n三个基本问题：\n* 封装成帧：把网络层的 IP 数据报封装成帧，`SOH - 数据部分 - EOT`\n* 透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符）\n* 差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check）\n\n点对点协议（Point-to-Point Protocol）：\n* 点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议\n\n#### 广播信道\n\n广播通信：\n* 硬件地址（物理地址、MAC 地址）\n* 单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同\n* 广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧\n* 多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧\n\n### 网络层\n\n* IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。\n* ARP（Address Resolution Protocol，地址解析协议）\n* ICMP（Internet Control Message Protocol，网际控制报文协议）\n* IGMP（Internet Group Management Protocol，网际组管理协议）\n\n#### IP 网际协议\n\nIP 地址分类：\n* `IP 地址 ::= {<网络号>,<主机号>}`\n\nIP 地址类别 | 网络号 | 网络范围 | 主机号 | IP 地址范围\n---|---|---|---|---\nA 类 | 8bit，第一位固定为 0 | 0 —— 127 | 24bit | 1.0.0.0 —— 127.255.255.255\nB 类 | 16bit，前两位固定为  10 | 128.0 —— 191.255 | 16bit | 128.0.0.0 —— 191.255.255.255\nC  类 | 24bit，前三位固定为  110 | 192.0.0 —— 223.255.255 | 8bit | 192.0.0.0 —— 223.255.255.255\nD  类 | 前四位固定为 1110，后面为多播地址\nE  类 | 前五位固定为 11110，后面保留为今后所用\n\nIP 数据报格式：\n\n![IP 数据报格式](https://gitee.com/huihut/interview/raw/master/images/IP数据报格式.png)\n\n#### ICMP 网际控制报文协议\n\nICMP 报文格式：\n\n![ICMP 报文格式](https://gitee.com/huihut/interview/raw/master/images/ICMP报文格式.png)\n\n应用：\n* PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性\n* TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量\n\n#### 内部网关协议\n\n* RIP（Routing Information Protocol，路由信息协议）\n* OSPF（Open Sortest Path First，开放最短路径优先）\n\n#### 外部网关协议\n\n* BGP（Border Gateway Protocol，边界网关协议）\n\n#### IP多播\n\n* IGMP（Internet Group Management Protocol，网际组管理协议）\n* 多播路由选择协议\n\n#### VPN 和 NAT\n\n* VPN（Virtual Private Network，虚拟专用网）\n* NAT（Network Address Translation，网络地址转换）\n\n#### 路由表包含什么？\n\n1. 网络 ID（Network ID, Network number）：就是目标地址的网络 ID。\n2. 子网掩码（subnet mask）：用来判断 IP 所属网络\n3. 下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: `0.0.0.0`, Netmask: `0.0.0.0`）指向自治系统的出口。\n\n根据应用和执行的不同，路由表可能含有如下附加信息：\n\n1. 花费（Cost）：就是数据发送过程中通过路径所需要的花费。\n2. 路由的服务质量\n3. 路由中需要过滤的出/入连接列表\n\n### 运输层\n\n协议：\n\n* TCP（Transmission Control Protocol，传输控制协议）\n* UDP（User Datagram Protocol，用户数据报协议）\n\n端口：\n\n应用程序 | FTP | TELNET | SMTP | DNS | TFTP | HTTP | HTTPS | SNMP  \n--- | --- | --- |--- |--- |--- |--- |--- |---   \n端口号 | 21 | 23 | 25 | 53 | 69 | 80 | 443 | 161  \n\n#### TCP\n\n* TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。\n\n特征：\n* 面向连接\n* 只能点对点（一对一）通信\n* 可靠交互\n* 全双工通信\n* 面向字节流\n\nTCP 如何保证可靠传输：\n* 确认和超时重传\n* 数据合理分片和排序\n* 流量控制\n* 拥塞控制\n* 数据校验\n\nTCP 报文结构\n\n![TCP 报文](https://gitee.com/huihut/interview/raw/master/images/TCP报文.png)\n\nTCP 首部\n\n![TCP 首部](https://gitee.com/huihut/interview/raw/master/images/TCP首部.png)\n\nTCP：状态控制码（Code，Control Flag），占 6 比特，含义如下：\n* URG：紧急比特（urgent），当 `URG＝1` 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。\n* ACK：确认比特（Acknowledge）。只有当 `ACK＝1` 时确认号字段才有效，代表这个封包为确认封包。当 `ACK＝0` 时，确认号无效。\n* PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。\n* RST：复位比特(Reset)，当 `RST＝1` 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。\n* SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。\n* FIN：终止比特(Final)，用来释放一个连接。当 `FIN＝1` 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。\n\n#### UDP\n\n* UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。\n\n特征：\n* 无连接\n* 尽最大努力交付\n* 面向报文\n* 没有拥塞控制\n* 支持一对一、一对多、多对一、多对多的交互通信\n* 首部开销小\n\nUDP 报文结构\n\n![UDP 报文](https://gitee.com/huihut/interview/raw/master/images/UDP报文.png)\n\nUDP 首部\n\n![UDP 首部](https://gitee.com/huihut/interview/raw/master/images/UDP首部.png)\n\n> TCP/UDP 图片来源于：<https://github.com/JerryC8080/understand-tcp-udp>\n\n#### TCP 与 UDP 的区别\n\n1. TCP 面向连接，UDP 是无连接的；\n2. TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付\n3. TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道\n5. 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信\n6. TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）\n7. UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）\n8. TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节\n\n#### TCP 黏包问题\n\n##### 原因\n\nTCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。\n\n##### 解决\n\n* 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。\n* 包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。\n* 在数据包之间设置边界，如添加特殊符号 `\\r\\n` 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 `\\r\\n`，则会误判为消息的边界。\n* 使用更加复杂的应用层协议。\n\n#### TCP 流量控制\n\n##### 概念\n\n流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。\n\n##### 方法\n\n利用可变窗口进行流量控制\n\n![](https://gitee.com/huihut/interview/raw/master/images/利用可变窗口进行流量控制举例.png)\n\n#### TCP 拥塞控制\n\n##### 概念\n\n拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。\n\n##### 方法\n\n* 慢开始( slow-start )\n* 拥塞避免( congestion avoidance )\n* 快重传( fast retransmit )\n* 快恢复( fast recovery )\n\nTCP的拥塞控制图\n\n![](https://gitee.com/huihut/interview/raw/master/images/TCP拥塞窗口cwnd在拥塞控制时的变化情况.png)\n![](https://gitee.com/huihut/interview/raw/master/images/快重传示意图.png)\n![](https://gitee.com/huihut/interview/raw/master/images/TCP的拥塞控制流程图.png)\n\n#### TCP 传输连接管理\n\n> 因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：<https://gitee.com/huihut/interview/raw/master/images/TCP-transport-connection-management.png>\n\n##### TCP 三次握手建立连接\n\n![UDP 报文](https://gitee.com/huihut/interview/raw/master/images/TCP三次握手建立连接.png)\n\n【TCP 建立连接全过程解释】\n\n1. 客户端发送 SYN 给服务器，说明客户端请求建立连接；\n2. 服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）；\n3. 客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）；\n4. 服务端收到客户端的 ACK，连接已建立，可以数据传输。\n\n##### TCP 为什么要进行三次握手？\n\n【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）\n\n> [Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信}](https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ)\n\n【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。\n\n> [知乎 . TCP 为什么是三次握手，而不是两次或四次？](https://www.zhihu.com/question/24853633/answer/115173386)\n\n【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。\n\n> [《计算机网络（第 7 版）-谢希仁》](https://gitee.com/huihut/interview/raw/master/images/TCP-transport-connection-management.png)\n\n##### TCP 四次挥手释放连接\n\n![UDP 报文](https://gitee.com/huihut/interview/raw/master/images/TCP四次挥手释放连接.png)\n\n【TCP 释放连接全过程解释】\n\n1. 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；\n2. 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；\n3. 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；\n4. 服务端继续发送之前没发完的数据给客户端；\n5. 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；\n6. 客户端收到服务端的 FIN+ACK，并回复 ACK 给服务端（同意释放从服务端到客户端的连接）；\n7. 服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。\n\n##### TCP 为什么要进行四次挥手？\n\n【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？\n\n【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。\n\n【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）\n\n【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。\n\n【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？\n\n【答案三】\n\n1. 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。\n2. 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。\n\n#### TCP 有限状态机\n\nTCP 有限状态机图片\n\n![TCP 的有限状态机](https://gitee.com/huihut/interview/raw/master/images/TCP的有限状态机.png)\n\n### 应用层\n\n#### DNS\n\n* DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。\n\n域名：\n* `域名 ::= {<三级域名>.<二级域名>.<顶级域名>}`，如：`blog.huihut.com`\n\n#### FTP\n\n* FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。\n* TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定\n\n#### TELNET\n\n* TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。\n\n* HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。\n\n* SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。\n* Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。\n\n#### WWW\n\n* WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问\n\n##### URL\n\n* URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address）\n\n标准格式：\n\n* `协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]`\n    \n完整格式：\n\n* `协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]`\n\n> 其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项  \n> 如：`https://github.com/huihut/interview#cc`\n\n##### HTTP\n\nHTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。\n\n请求方法\n\n方法 | 意义\n--- | ---\nOPTIONS | 请求一些选项信息，允许客户端查看服务器的性能\nGET | 请求指定的页面信息，并返回实体主体\nHEAD | 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头\nPOST | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改\nPUT | 从客户端向服务器传送的数据取代指定的文档的内容\nDELETE | 请求服务器删除指定的页面\nTRACE | 回显服务器收到的请求，主要用于测试或诊断\n\n状态码（Status-Code）\n\n* 1xx：表示通知信息，如请求收到了或正在进行处理\n    * 100 Continue：继续，客户端应继续其请求\n    * 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议\n* 2xx：表示成功，如接收或知道了\n    * 200 OK: 请求成功\n* 3xx：表示重定向，如要完成请求还必须采取进一步的行动\n    * 301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替\n* 4xx：表示客户的差错，如请求中有错误的语法或不能完成\n    * 400 Bad Request: 客户端请求的语法错误，服务器无法理解\n    * 401 Unauthorized: 请求要求用户的身份认证\n    * 403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够）\n    * 404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面\n    * 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时\n* 5xx：表示服务器的差错，如服务器失效无法完成请求\n    * 500 Internal Server Error: 服务器内部错误，无法完成请求\n    * 503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中\n    * 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求\n\n> 更多状态码：[菜鸟教程 . HTTP状态码](http://www.runoob.com/http/http-status-codes.html)\n\n##### 其他协议\n\n* SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。\n* DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：\n    * 用于内部网络或网络服务供应商自动分配 IP 地址给用户\n    * 用于内部网络管理员作为对所有电脑作中央管理的手段\n* SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。\n\n<a id=\"network-programming\"></a>\n\n## 🌩 网络编程\n\n### Socket\n\n> [Linux Socket 编程（不限 Linux）](https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html)\n\n![Socket 客户端服务器通讯](https://gitee.com/huihut/interview/raw/master/images/socket客户端服务器通讯.jpg)\n\n\n#### Socket 中的 read()、write() 函数\n\n```cpp\nssize_t read(int fd, void *buf, size_t count);\nssize_t write(int fd, const void *buf, size_t count);\n```\n\n##### read()\n\n* read 函数是负责从 fd 中读取内容。\n* 当读成功时，read 返回实际所读的字节数。\n* 如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。\n* 如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。\n\n##### write()\n\n* write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。\n* 成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。\n* 在网络程序中，当我们向套接字文件描述符写时有俩种可能。\n* （1）write 的返回值大于 0，表示写了部分或者是全部的数据。\n* （2）返回的值小于 0，此时出现了错误。\n* 如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。\n\n#### Socket 中 TCP 的三次握手建立连接\n\n我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下：\n\n1. 客户端向服务器发送一个 SYN J\n2. 服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1\n3. 客户端再想服务器发一个确认 ACK K+1\n\n只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图：\n\n![socket 中发送的 TCP 三次握手](http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png)\n\n从图中可以看出：\n1. 当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态；  \n2. 服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态；  \n3. 客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认；  \n4. 服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。\n\n#### Socket 中 TCP 的四次握手释放连接\n\n上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图：\n\n![socket 中发送的 TCP 四次握手](http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png)\n\n图示过程如下：\n\n1. 某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M；\n2. 另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据；\n3. 一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N；\n4. 接收到这个 FIN 的源发送端 TCP 对它进行确认。\n\n这样每个方向上都有一个 FIN 和 ACK。\n\n<a id=\"database\"></a>\n\n## 💾 数据库\n\n> 本节部分知识点来自《数据库系统概论（第 5 版）》\n\n### 基本概念\n\n* 数据（data）：描述事物的符号记录称为数据。\n* 数据库（DataBase，DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合，具有永久存储、有组织、可共享三个基本特点。\n* 数据库管理系统（DataBase Management System，DBMS）：是位于用户与操作系统之间的一层数据管理软件。\n* 数据库系统（DataBase System，DBS）：是有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator DBA）组成的存储、管理、处理和维护数据的系统。\n* 实体（entity）：客观存在并可相互区别的事物称为实体。\n* 属性（attribute）：实体所具有的某一特性称为属性。\n* 码（key）：唯一标识实体的属性集称为码。\n* 实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。\n* 实体集（entity set）：同一实体型的集合称为实体集。\n* 联系（relationship）：实体之间的联系通常是指不同实体集之间的联系。\n* 模式（schema）：模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。\n* 外模式（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。\n* 内模式（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。\n\n### 常用数据模型\n\n* 层次模型（hierarchical model）\n* 网状模型（network model）\n* 关系模型（relational model）\n    * 关系（relation）：一个关系对应通常说的一张表\n    * 元组（tuple）：表中的一行即为一个元组\n    * 属性（attribute）：表中的一列即为一个属性\n    * 码（key）：表中可以唯一确定一个元组的某个属性组\n    * 域（domain）：一组具有相同数据类型的值的集合\n    * 分量：元组中的一个属性值\n    * 关系模式：对关系的描述，一般表示为 `关系名(属性1, 属性2, ..., 属性n)`\n* 面向对象数据模型（object oriented data model）\n* 对象关系数据模型（object relational data model）\n* 半结构化数据模型（semistructure data model）\n\n### 常用 SQL 操作\n\n<table>\n  <tr>\n    <th>对象类型</th>\n    <th>对象</th>\n    <th>操作类型</th>\n  </tr>\n  <tr>\n    <td rowspan=\"4\">数据库模式</td>\n    <td>模式</td>\n    <td><code>CREATE SCHEMA</code></td>\n  </tr>\n  <tr>\n    <td>基本表</td>\n    <td><code>CREATE SCHEMA</code>，<code>ALTER TABLE</code></td>\n  </tr>\n    <tr>\n    <td>视图</td>\n    <td><code>CREATE VIEW</code></td>\n  </tr>\n    <tr>\n    <td>索引</td>\n    <td><code>CREATE INDEX</code></td>\n  </tr>\n    <tr>\n    <td rowspan=\"2\">数据</td>\n    <td>基本表和视图</td>\n    <td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code></td>\n  </tr>\n    <tr>\n    <td>属性列</td>\n    <td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code></td>\n  </tr>\n</table>\n\n> SQL 语法教程：[runoob . SQL 教程](http://www.runoob.com/sql/sql-tutorial.html)\n\n### 关系型数据库\n\n* 基本关系操作：查询（选择、投影、连接（等值连接、自然连接、外连接（左外连接、右外连接））、除、并、差、交、笛卡尔积等）、插入、删除、修改\n* 关系模型中的三类完整性约束：实体完整性、参照完整性、用户定义的完整性\n\n#### 索引\n\n* 数据库索引：顺序索引、B+ 树索引、hash 索引\n* [MySQL 索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)\n\n### 数据库完整性\n\n* 数据库的完整性是指数据的正确性和相容性。\n    * 完整性：为了防止数据库中存在不符合语义（不正确）的数据。\n    * 安全性：为了保护数据库防止恶意破坏和非法存取。\n* 触发器：是用户定义在关系表中的一类由事件驱动的特殊过程。\n\n### 关系数据理论\n\n* 数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。\n* 最重要的数据依赖：函数依赖、多值依赖。\n\n#### 范式\n\n* 第一范式（1NF）：属性（字段）是最小单位不可再分。\n* 第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）。\n* 第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 非主属性对码的传递函数依赖）。\n* 鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）。\n* 第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）。\n\n### 数据库恢复\n\n* 事务：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。\n* 事物的 ACID 特性：原子性、一致性、隔离性、持续性。\n* 恢复的实现技术：建立冗余数据 -> 利用冗余数据实施数据库恢复。\n* 建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。\n\n### 并发控制\n\n* 事务是并发控制的基本单位。\n* 并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。\n* 并发控制主要技术：封锁、时间戳、乐观控制法、多版本并发控制等。\n* 基本封锁类型：排他锁（X 锁 / 写锁）、共享锁（S 锁 / 读锁）。\n* 活锁死锁：\n    * 活锁：事务永远处于等待状态，可通过先来先服务的策略避免。\n    * 死锁：事务永远不能结束\n        * 预防：一次封锁法、顺序封锁法；\n        * 诊断：超时法、等待图法；\n        * 解除：撤销处理死锁代价最小的事务，并释放此事务的所有的锁，使其他事务得以继续运行下去。\n* 可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。可串行性时并发事务正确调度的准则。\n\n<a id=\"design-pattern\"></a>\n\n## 📏 设计模式\n\n> 各大设计模式例子参考：[CSDN专栏 . C++ 设计模式](https://blog.csdn.net/liang19890820/article/details/66974516) 系列博文\n\n[设计模式工程目录](DesignPattern)\n\n### 单例模式\n\n[单例模式例子](DesignPattern/SingletonPattern)\n\n### 抽象工厂模式\n\n[抽象工厂模式例子](DesignPattern/AbstractFactoryPattern)\n\n### 适配器模式\n\n[适配器模式例子](DesignPattern/AdapterPattern)\n\n### 桥接模式\n\n[桥接模式例子](DesignPattern/BridgePattern)\n\n### 观察者模式\n\n[观察者模式例子](DesignPattern/ObserverPattern)\n\n### 设计模式的六大原则\n\n* 单一职责原则（SRP，Single Responsibility Principle）\n* 里氏替换原则（LSP，Liskov Substitution Principle）\n* 依赖倒置原则（DIP，Dependence Inversion Principle）\n* 接口隔离原则（ISP，Interface Segregation Principle）\n* 迪米特法则（LoD，Law of Demeter）\n* 开放封闭原则（OCP，Open Close Principle）\n\n<a id=\"link-loading-library\"></a>\n\n## ⚙️ 链接装载库\n\n> 本节部分知识点来自《程序员的自我修养——链接装载库》\n\n### 内存、栈、堆\n\n一般应用程序内存空间有如下区域：\n\n* 栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文\n* 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域\n* 可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里\n* 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据\n\n#### 栈\n\n栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：\n\n* 函数的返回地址和参数\n* 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量\n* 保存上下文：包括函数调用前后需要保持不变的寄存器\n\n#### 堆\n\n堆分配算法：\n\n* 空闲链表（Free List）\n* 位图（Bitmap）\n* 对象池\n\n#### “段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”\n\n典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。\n\n普遍原因：\n\n* 将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针\n* 没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针\n\n### 编译链接\n\n#### 各平台文件格式\n\n平台 | 可执行文件 | 目标文件 | 动态库/共享对象 | 静态库\n---|---|---|---|---\nWindows|exe|obj|dll|lib\nUnix/Linux|ELF、out|o|so|a\nMac|Mach-O|o|dylib、tbd、framework|a、framework\n\n#### 编译链接过程\n\n1. 预编译（预编译器处理如 `#include`、`#define` 等预编译指令，生成 `.i` 或 `.ii` 文件）\n2. 编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 `.s` 文件）\n3. 汇编（汇编器把汇编码翻译成机器码，生成 `.o` 文件）\n4. 链接（连接器进行地址和空间分配、符号决议、重定位，生成 `.out` 文件）\n\n> 现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld\n\n> MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin\n\n#### 目标文件\n\n编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。\n\n> 可执行文件（Windows 的 `.exe` 和 Linux 的 `ELF`）、动态链接库（Windows 的 `.dll` 和 Linux 的 `.so`）、静态链接库（Windows 的 `.lib` 和 Linux 的 `.a`）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）\n\n##### 目标文件格式\n\n* Windows 的 PE（Portable Executable），或称为 PE-COFF，`.obj` 格式\n* Linux 的 ELF（Executable Linkable Format），`.o` 格式\n* Intel/Microsoft 的 OMF（Object Module Format）\n* Unix 的 `a.out` 格式\n* MS-DOS 的 `.COM` 格式\n\n> PE 和 ELF 都是 COFF（Common File Format）的变种\n\n##### 目标文件存储结构\n\n段 | 功能\n--- | ---\nFile Header | 文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）\n.text section | 代码段，执行语句编译成的机器代码 \n.data section | 数据段，已初始化的全局变量和局部静态变量\n.bss section | BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）\n.rodata section | 只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量\n.comment section | 注释信息段，存放编译器版本信息\n.note.GNU-stack section | 堆栈提示段 \n\n> 其他段略\n\n#### 链接的接口————符号\n\n在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。\n\n如下符号表（Symbol Table）：\n\nSymbol（符号名） | Symbol Value （地址）\n--- | ---\nmain| 0x100\nAdd | 0x123\n... | ...\n\n### Linux 的共享库（Shared Library）\n\nLinux 下的共享库就是普通的 ELF 共享对象。\n\n共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容\n\n#### 命名\n\n`libname.so.x.y.z`\n\n* x：主版本号，不同主版本号的库之间不兼容，需要重新编译\n* y：次版本号，高版本号向后兼容低版本号\n* z：发布版本号，不对接口进行更改，完全兼容\n\n#### 路径\n\n大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。\n\n* `/lib`：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等\n* `/usr/lib`：存放非系统运行时所需要的关键性的库，主要是开发库\n* `/usr/local/lib`：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库\n\n> 动态链接器会在 `/lib`、`/usr/lib` 和由 `/etc/ld.so.conf` 配置文件指定的，目录中查找共享库\n\n#### 环境变量\n\n* `LD_LIBRARY_PATH`：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序\n* `LD_PRELOAD`：指定预先装载的一些共享库甚至是目标文件\n* `LD_DEBUG`：打开动态链接器的调试功能\n\n#### so 共享库的编写\n\n使用 CLion 编写共享库\n\n创建一个名为 MySharedLib 的共享库\n\nCMakeLists.txt\n\n```cmake\ncmake_minimum_required(VERSION 3.10)\nproject(MySharedLib)\n\nset(CMAKE_CXX_STANDARD 11)\n\nadd_library(MySharedLib SHARED library.cpp library.h)\n```\n\nlibrary.h\n\n```cpp\n#ifndef MYSHAREDLIB_LIBRARY_H\n#define MYSHAREDLIB_LIBRARY_H\n\n// 打印 Hello World!\nvoid hello();\n\n// 使用可变模版参数求和\ntemplate <typename T>\nT sum(T t)\n{\n    return t;\n}\ntemplate <typename T, typename ...Types>\nT sum(T first, Types ... rest)\n{\n    return first + sum<T>(rest...);\n}\n\n#endif\n```\n\nlibrary.cpp\n\n```cpp\n#include <iostream>\n#include \"library.h\"\n\nvoid hello() {\n    std::cout << \"Hello, World!\" << std::endl;\n}\n```\n\n#### so 共享库的使用（被可执行项目调用）\n\n使用 CLion 调用共享库\n\n创建一个名为 TestSharedLib 的可执行项目\n\nCMakeLists.txt\n\n```cmake\ncmake_minimum_required(VERSION 3.10)\nproject(TestSharedLib)\n\n# C++11 编译\nset(CMAKE_CXX_STANDARD 11)\n\n# 头文件路径\nset(INC_DIR /home/xx/code/clion/MySharedLib)\n# 库文件路径\nset(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)\n\ninclude_directories(${INC_DIR})\nlink_directories(${LIB_DIR})\nlink_libraries(MySharedLib)\n\nadd_executable(TestSharedLib main.cpp)\n\n# 链接 MySharedLib 库\ntarget_link_libraries(TestSharedLib MySharedLib)\n```\n\nmain.cpp\n\n```cpp\n#include <iostream>\n#include \"library.h\"\nusing std::cout;\nusing std::endl;\n\nint main() {\n\n    hello();\n    cout << \"1 + 2 = \" << sum(1,2) << endl;\n    cout << \"1 + 2 + 3 = \" << sum(1,2,3) << endl;\n\n    return 0;\n}\n```\n\n执行结果\n\n```\nHello, World!\n1 + 2 = 3\n1 + 2 + 3 = 6\n```\n\n### Windows 应用程序入口函数\n\n* GUI（Graphical User Interface）应用，链接器选项：`/SUBSYSTEM:WINDOWS`\n* CUI（Console User Interface）应用，链接器选项：`/SUBSYSTEM:CONSOLE`\n\n_tWinMain 与 _tmain 函数声明\n\n```cpp\nInt WINAPI _tWinMain(\n    HINSTANCE hInstanceExe,\n    HINSTANCE,\n    PTSTR pszCmdLine,\n    int nCmdShow);\n\nint _tmain(\n    int argc,\n    TCHAR *argv[],\n    TCHAR *envp[]);\n```\n\n应用程序类型|入口点函数|嵌入可执行文件的启动函数\n---|---|---\n处理ANSI字符（串）的GUI应用程序|_tWinMain(WinMain)|WinMainCRTSartup\n处理Unicode字符（串）的GUI应用程序|_tWinMain(wWinMain)|wWinMainCRTSartup\n处理ANSI字符（串）的CUI应用程序|_tmain(Main)|mainCRTSartup\n处理Unicode字符（串）的CUI应用程序|_tmain(wMain)|wmainCRTSartup\n动态链接库（Dynamic-Link Library）|DllMain|_DllMainCRTStartup \n\n### Windows 的动态链接库（Dynamic-Link Library）\n\n> 部分知识点来自《Windows 核心编程（第五版）》\n\n#### 用处\n\n* 扩展了应用程序的特性\n* 简化了项目管理\n* 有助于节省内存\n* 促进了资源的共享\n* 促进了本地化\n* 有助于解决平台间的差异\n* 可以用于特殊目的\n\n#### 注意\n\n* 创建 DLL，事实上是在创建可供一个可执行模块调用的函数\n* 当一个模块提供一个内存分配函数（malloc、new）的时候，它必须同时提供另一个内存释放函数（free、delete）\n* 在使用 C 和 C++ 混编的时候，要使用 extern \"C\" 修饰符\n* 一个 DLL 可以导出函数、变量（避免导出）、C++ 类（导出导入需要同编译器，否则避免导出）\n* DLL 模块：cpp 文件中的 __declspec(dllexport) 写在 include 头文件之前\n* 调用 DLL 的可执行模块：cpp 文件的 __declspec(dllimport) 之前不应该定义 MYLIBAPI\n\n#### 加载 Windows 程序的搜索顺序\n\n1. 包含可执行文件的目录\n2. Windows 的系统目录，可以通过 GetSystemDirectory 得到\n3. 16 位的系统目录，即 Windows 目录中的 System 子目录\n4. Windows 目录，可以通过 GetWindowsDirectory 得到\n5. 进程的当前目录\n6. PATH 环境变量中所列出的目录\n\n#### DLL 入口函数\n\nDllMain 函数\n\n```cpp\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n{\n    switch(fdwReason)\n    {\n    case DLL_PROCESS_ATTACH:\n        // 第一次将一个DLL映射到进程地址空间时调用\n        // The DLL is being mapped into the process' address space.\n        break;\n    case DLL_THREAD_ATTACH:\n        // 当进程创建一个线程的时候，用于告诉DLL执行与线程相关的初始化（非主线程执行）\n        // A thread is bing created.\n        break;\n    case DLL_THREAD_DETACH:\n        // 系统调用 ExitThread 线程退出前，即将终止的线程通过告诉DLL执行与线程相关的清理\n        // A thread is exiting cleanly.\n        break;\n    case DLL_PROCESS_DETACH:\n        // 将一个DLL从进程的地址空间时调用\n        // The DLL is being unmapped from the process' address space.\n        break;\n    }\n    return (TRUE); // Used only for DLL_PROCESS_ATTACH\n}\n```\n\n#### 载入卸载库\n\nLoadLibrary、LoadLibraryExA、LoadPackagedLibrary、FreeLibrary、FreeLibraryAndExitThread 函数声明\n\n```cpp\n// 载入库\nHMODULE WINAPI LoadLibrary(\n  _In_ LPCTSTR lpFileName\n);\nHMODULE LoadLibraryExA(\n  LPCSTR lpLibFileName,\n  HANDLE hFile,\n  DWORD  dwFlags\n);\n// 若要在通用 Windows 平台（UWP）应用中加载 Win32 DLL，需要调用 LoadPackagedLibrary，而不是 LoadLibrary 或 LoadLibraryEx\nHMODULE LoadPackagedLibrary(\n  LPCWSTR lpwLibFileName,\n  DWORD   Reserved\n);\n\n// 卸载库\nBOOL WINAPI FreeLibrary(\n  _In_ HMODULE hModule\n);\n// 卸载库和退出线程\nVOID WINAPI FreeLibraryAndExitThread(\n  _In_ HMODULE hModule,\n  _In_ DWORD   dwExitCode\n);\n```\n\n#### 显示地链接到导出符号\n\nGetProcAddress 函数声明\n\n```cpp\nFARPROC GetProcAddress(\n  HMODULE hInstDll,\n  PCSTR pszSymbolName  // 只能接受 ANSI 字符串，不能是 Unicode\n);\n```\n\n#### DumpBin.exe 查看 DLL 信息\n\n在 `VS 的开发人员命令提示符` 使用 `DumpBin.exe` 可查看 DLL 库的导出段（导出的变量、函数、类名的符号）、相对虚拟地址（RVA，relative virtual address）。如：\n```\nDUMPBIN -exports D:\\mydll.dll\n```\n\n#### LoadLibrary 与 FreeLibrary 流程图\n\nLoadLibrary 与 FreeLibrary 流程图\n\n##### LoadLibrary\n\n![WindowsLoadLibrary](https://gitee.com/huihut/interview/raw/master/images/WindowsLoadLibrary.png)\n\n##### FreeLibrary\n\n![WindowsFreeLibrary](https://gitee.com/huihut/interview/raw/master/images/WindowsFreeLibrary.png)\n\n#### DLL 库的编写（导出一个 DLL 模块）\n\nDLL 库的编写（导出一个 DLL 模块）\nDLL 头文件\n\n```cpp\n// MyLib.h\n\n#ifdef MYLIBAPI\n\n// MYLIBAPI 应该在全部 DLL 源文件的 include \"Mylib.h\" 之前被定义\n// 全部函数/变量正在被导出\n\n#else\n\n// 这个头文件被一个exe源代码模块包含，意味着全部函数/变量被导入\n#define MYLIBAPI extern \"C\" __declspec(dllimport)\n\n#endif\n\n// 这里定义任何的数据结构和符号\n\n// 定义导出的变量（避免导出变量）\nMYLIBAPI int g_nResult;\n\n// 定义导出函数原型\nMYLIBAPI int Add(int nLeft, int nRight);\n```\n\nDLL 源文件\n\n```cpp\n// MyLibFile1.cpp\n\n// 包含标准Windows和C运行时头文件\n#include <windows.h>\n\n// DLL源码文件导出的函数和变量\n#define MYLIBAPI extern \"C\" __declspec(dllexport)\n\n// 包含导出的数据结构、符号、函数、变量\n#include \"MyLib.h\"\n\n// 将此DLL源代码文件的代码放在此处\nint g_nResult;\n\nint Add(int nLeft, int nRight)\n{\n    g_nResult = nLeft + nRight;\n    return g_nResult;\n}\n```\n\n#### DLL 库的使用（运行时动态链接 DLL）\n\nDLL 库的使用（运行时动态链接 DLL）\n\n```cpp\n// A simple program that uses LoadLibrary and \n// GetProcAddress to access myPuts from Myputs.dll. \n \n#include <windows.h> \n#include <stdio.h> \n \ntypedef int (__cdecl *MYPROC)(LPWSTR); \n \nint main( void ) \n{ \n    HINSTANCE hinstLib; \n    MYPROC ProcAdd; \n    BOOL fFreeResult, fRunTimeLinkSuccess = FALSE; \n \n    // Get a handle to the DLL module.\n \n    hinstLib = LoadLibrary(TEXT(\"MyPuts.dll\")); \n \n    // If the handle is valid, try to get the function address.\n \n    if (hinstLib != NULL) \n    { \n        ProcAdd = (MYPROC) GetProcAddress(hinstLib, \"myPuts\"); \n \n        // If the function address is valid, call the function.\n \n        if (NULL != ProcAdd) \n        {\n            fRunTimeLinkSuccess = TRUE;\n            (ProcAdd) (L\"Message sent to the DLL function\\n\"); \n        }\n        // Free the DLL module.\n \n        fFreeResult = FreeLibrary(hinstLib); \n    } \n\n    // If unable to call the DLL function, use an alternative.\n    if (! fRunTimeLinkSuccess) \n        printf(\"Message printed from executable\\n\"); \n\n    return 0;\n}\n```\n\n### 运行库（Runtime Library）\n\n#### 典型程序运行步骤\n\n1. 操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数）\n2. 入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。\n3. 入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。\n4. main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。\n\n> 一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。\n\n#### glibc 入口\n\n`_start -> __libc_start_main -> exit -> _exit`\n\n其中 `main(argc, argv, __environ)` 函数在 `__libc_start_main` 里执行。\n\n#### MSVC CRT 入口\n\n`int mainCRTStartup(void)`\n\n执行如下操作：\n\n1. 初始化和 OS 版本有关的全局变量。\n2. 初始化堆。\n3. 初始化 I/O。\n4. 获取命令行参数和环境变量。\n5. 初始化 C 库的一些数据。\n6. 调用 main 并记录返回值。\n7. 检查错误并将 main 的返回值返回。\n\n#### C 语言运行库（CRT）\n\n大致包含如下功能：\n\n* 启动与退出：包括入口函数及入口函数所依赖的其他函数等。\n* 标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。\n* I/O：I/O 功能的封装和实现。\n* 堆：堆的封装和实现。\n* 语言实现：语言中一些特殊功能的实现。\n* 调试：实现调试功能的代码。\n\n#### C语言标准库（ANSI C）\n\n包含：\n\n* 标准输入输出（stdio.h）\n* 文件操作（stdio.h）\n* 字符操作（ctype.h）\n* 字符串操作（string.h）\n* 数学函数（math.h）\n* 资源管理（stdlib.h）\n* 格式转换（stdlib.h）\n* 时间/日期（time.h）\n* 断言（assert.h）\n* 各种类型上的常数（limits.h & float.h）\n* 变长参数（stdarg.h）\n* 非局部跳转（setjmp.h）\n\n<a id=\"books\"></a>\n\n## 📚 书籍\n\n> [huihut/CS-Books](https://github.com/huihut/CS-Books)：📚 Computer Science Books 计算机技术类书籍 PDF\n\n### 语言\n\n* 《C++ Primer》\n* 《Effective C++》\n* 《More Effective C++》\n* 《深度探索 C++ 对象模型》\n* 《深入理解 C++11》\n* 《STL 源码剖析》\n\n### 算法\n\n* 《剑指 Offer》\n* 《编程珠玑》\n* 《程序员面试宝典》\n\n### 系统\n\n* 《深入理解计算机系统》\n* 《Windows 核心编程》\n* 《Unix 环境高级编程》\n\n### 网络\n\n* 《Unix 网络编程》\n* 《TCP/IP 详解》\n\n### 其他\n\n* 《程序员的自我修养》\n\n<a id=\"cc-development-direction\"></a>\n\n## 🔱 C/C++ 发展方向\n\n> C/C++ 发展方向甚广，包括不限于以下方向， 以下列举一些大厂校招岗位要求。\n\n### 后台/服务器\n\n【后台开发】\n\n* 编程基本功扎实，掌握 C/C++/JAVA 等开发语言、常用算法和数据结构；\n* 熟悉 TCP/UDP 网络协议及相关编程、进程间通讯编程；\n* 了解 Python、Shell、Perl 等脚本语言；\n* 了解 MYSQL 及 SQL 语言、编程，了解 NoSQL, key-value 存储原理；\n* 全面、扎实的软件知识结构，掌握操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全等专业知识；\n* 了解分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统等知识。\n\n### 桌面客户端\n\n【PC 客户端开发】\n\n* 计算机软件相关专业本科或以上学历，热爱编程，基础扎实，理解算法和数据结构相关知识；  \n* 熟悉 windows 操作系统的内存管理、文件系统、进程线程调度； \n* 熟悉 MFC/windows 界面实现机制，熟练使用 VC，精通 C/C++，熟练使用 STL，以及 Windows 下网络编程经验；\n* 熟练掌握 Windows 客户端开发、调试，有 Windows 应用软件开发经验优先；\n* 对于创新及解决具有挑战性的问题充满激情，具有良好的算法基础及系统分析能力。\n\n### 图形学/游戏/VR/AR\n\n【游戏客户端开发】\n\n* 计算机科学/工程相关专业本科或以上学历，热爱编程，基础扎实，理解算法、数据结构、软件设计相关知识；\n* 至少掌握一种游戏开发常用的编程语言，具 C++/C# 编程经验优先；\n* 具游戏引擎（如 Unity、Unreal）使用经验者优先；\n* 了解某方面的游戏客户端技术（如图形、音频、动画、物理、人工智能、网络同步）者优先考虑；\n* 对于创新及解决具有挑战性的问题充满激情，有较强的学习能力、分析及解决问题能力，具备良好的团队合作意识；\n* 具阅读英文技术文档能力；\n* 热爱游戏。\n\n### 测试开发\n\n【测试开发】\n\n* 计算机或相关专业本科及以上学历；\n* 一至两年的 C/C++/Python 或其他计算机语言的编程经验；\n* 具备撰写测试计划、测试用例、以及实现性能和安全等测试的能力；\n* 具备实现自动化系统的能力；\n* 具备定位调查产品缺陷能力、以及代码级别调试缺陷的能力；\n* 工作主动积极，有责任心，具有良好的团队合作精神。\n\n### 网络安全/逆向\n\n【安全技术】\n\n* 热爱互联网，对操作系统和网络安全有狂热的追求，专业不限；\n* 熟悉漏洞挖掘、网络安全攻防技术，了解常见黑客攻击手法；  \n* 掌握基本开发能力，熟练使用 C/C++ 语言；\n* 对数据库、操作系统、网络原理有较好掌握；  \n* 具有软件逆向，网络安全攻防或安全系统开发经验者优先。\n\n### 嵌入式/物联网\n\n【嵌入式应用开发】\n\n* 有良好的编程基础，熟练掌握 C/C++ 语言；\n* 掌握操作系统、数据结构等软件开发必备知识；\n* 具备较强的沟通理解能力及良好的团队合作意识；\n* 有 Linux/Android 系统平台的开发经验者优先。\n\n### 音视频/流媒体/SDK\n\n【音视频编解码】\n\n1. 硕士及以上学历，计算机、信号处理、数学、信息类及相关专业和方向； \n2. 视频编解码基础扎实，熟常用的 HEVC 或 H264，有较好的数字信号处理基础； \n3. 掌握 C/C++，代码能力强, 熟悉一种汇编语言尤佳； \n4. 较强的英文文献阅读能力； \n5. 学习能力强，具有团队协作精神，有较强的抗压能力。\n\n### 计算机视觉/机器学习\n\n【计算机视觉研究】\n\n* 计算机、应用数学、模式识别、人工智能、自控、统计学、运筹学、生物信息、物理学/量子计算、神经科学、社会学/心理学等专业，图像处理、模式识别、机器学习相关研究方向，本科及以上，博士优先；\n* 熟练掌握计算机视觉和图像处理相关的基本算法及应用；\n* 较强的算法实现能力，熟练掌握 C/C++ 编程，熟悉 Shell/Python/Matlab 至少一种编程语言；\n* 在计算机视觉、模式识别等学术会议或者期刊上发表论文、相关国际比赛获奖、及有相关专利者优先。\n\n<a id=\"review-of-brush-questions-website\"></a>\n\n## 💯 复习刷题网站\n\n* [cplusplus](http://www.cplusplus.com/)\n* [cppreference](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)\n* [runoob](http://www.runoob.com/cplusplus/cpp-tutorial.html)\n* [leetcode](https://leetcode.com/) | [leetcode-cn](https://leetcode-cn.com/)\n* [lintcode](https://www.lintcode.com/)\n* [nowcoder](https://www.nowcoder.net/)\n\n<a id=\"interview-questions-experience\"></a>\n\n## 📝 面试题目经验\n\n* [牛客网 . 2020秋招面经大汇总！（岗位划分）](https://www.nowcoder.com/discuss/205497)\n* [牛客网 . 【备战秋招】2020届秋招备战攻略](https://www.nowcoder.com/discuss/197116)\n* [牛客网 . 2019校招面经大汇总！【每日更新中】](https://www.nowcoder.com/discuss/90907)\n* [牛客网 . 2019校招技术类岗位面经汇总【技术类】](https://www.nowcoder.com/discuss/146655)\n* [牛客网 . 2018校招笔试真题汇总](https://www.nowcoder.com/discuss/68802)\n* [牛客网 . 2017秋季校园招聘笔经面经专题汇总](https://www.nowcoder.com/discuss/12805)\n* [牛客网 . 史上最全2017春招面经大合集！！](https://www.nowcoder.com/discuss/25268)\n* [牛客网 . 面试题干货在此](https://www.nowcoder.com/discuss/57978)\n* [知乎 . 互联网求职路上，你见过哪些写得很好、很用心的面经？最好能分享自己的面经、心路历程。](https://www.zhihu.com/question/29693016)\n* [知乎 . 互联网公司最常见的面试算法题有哪些？](https://www.zhihu.com/question/24964987)\n* [CSDN . 全面整理的C++面试题](http://blog.csdn.net/ljzcome/article/details/574158)\n* [CSDN . 百度研发类面试题（C++方向）](http://blog.csdn.net/Xiongchao99/article/details/74524807?locationNum=6&fps=1)\n* [CSDN . c++常见面试题30道](http://blog.csdn.net/fakine/article/details/51321544)\n* [CSDN . 腾讯2016实习生面试经验（已经拿到offer)](http://blog.csdn.net/onever_say_love/article/details/51223886)\n* [cnblogs . C++面试集锦( 面试被问到的问题 )](https://www.cnblogs.com/Y1Focus/p/6707121.html)\n* [cnblogs . C/C++ 笔试、面试题目大汇总](https://www.cnblogs.com/fangyukuan/archive/2010/09/18/1829871.html)\n* [cnblogs . 常见C++面试题及基本知识点总结（一）](https://www.cnblogs.com/LUO77/p/5771237.html)\n* [segmentfault . C++常见面试问题总结](https://segmentfault.com/a/1190000003745529)\n\n<a id=\"recruitment-time-post\"></a>\n\n## 📆 招聘时间岗位\n\n* [牛客网 . 名企校招日程](https://www.nowcoder.com/school/schedule)\n\n<a id=\"recommend\"></a>\n\n## 👍 内推\n\n* [Github . CyC2018/Job-Recommend](https://github.com/CyC2018/Job-Recommend)：🔎 互联网内推信息（社招、校招、实习）\n* [Github . amusi/AI-Job-Recommend](https://github.com/amusi/AI-Job-Recommend)：国内公司人工智能方向（含机器学习、深度学习、计算机视觉和自然语言处理）岗位的招聘信息（含全职、实习和校招）\n\n<a id=\"contributor\"></a>\n\n## 👬 贡献者\n\n<a href=\"https://github.com/huihut/interview/graphs/contributors\"><img src=\"https://opencollective.com/interview/contributors.svg?button=false\" /></a>\n\n<a id=\"license\"></a>\n\n## 📜 License\n\n本仓库遵循 CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享） 协议，转载请注明出处，不得用于商业目的。\n\n[![CC BY-NC-SA 4.0](https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png)](https://github.com/huihut/interview/blob/master/LICENSE)\n\n"
        },
        {
          "name": "README_en.md",
          "type": "blob",
          "size": 162.65,
          "content": "<div align=\"center\">\n📖 Github\n&emsp;&emsp; | &emsp;&emsp;\n<a href=\"https://interview.huihut.com\">📚 Docsify</a>\n</div> \n<br>\n\n<div align=\"center\">\n<a href=\"https://github.com/huihut/interview/\">简体中文</a>\n&emsp;&emsp; | &emsp;&emsp;\nEnglish\n</div> \n<br>\n\t\n<b><details><summary>💡 ON</summary></b>\t\n\n\n📚 This repository is a summary of the basic knowledge of recruiting job seekers and beginners in the direction of C / C ++ technology, including language, program library, data structure, algorithm, system, network, link loading library and other knowledge and interview experience, recruitment, internal push, etc. information.\n\n\n💡 Side directory support methods:[📚 Docsify Doc](https://interview.huihut.com)、[Github + TOC navigation](https://github.com/jawil/GayHub)（[TOC preview.png](https://raw.githubusercontent.com/huihut/interview/master/images/TOC预览.png)）\n\n📄 Save as PDF: Use the Chrome browser to open the <a href=\"https://interview.huihut.com\"> 📚 Docsify document </a> page, shrink the left directory-right click-print-select the target printer is Save as PDF-Save ( [Print Preview.png](https://raw.githubusercontent.com/huihut/interview/master/images/PrintPreview.png) )\n\n🙏 If there are any errors or improvements in the contents of the warehouse, issues or pr are welcome. Suggestions or discussions can be submitted at [# 12](https://github.com/huihut/interview/issues/12). Due to my limited level, the knowledge points in the warehouse are from my original, reading notes, books, blog posts, etc. Non-original has been marked with the source, if there is any omission, please issue an issue. This warehouse follows the [CC BY-NC-SA 4.0](https://github.com/huihut/interview/blob/master/LICENSE) agreement, please indicate the source for the reprint, and may not be used for commercial purposes.\n\n</details>\n\n\n## 📑 Table of contents\n\n\n* [➕ C/C++](#cc)\n* [⭐️ Effective](#effective)\n* [📦 STL](#stl)\n* [〽️ Data Structure](#data-structure)\n* [⚡️ Algorithm](#algorithm)\n* [❓ Problems](#problems)\n* [💻 OS](#os)\n* [☁️ Computer Network](#computer-network)\n* [🌩 Network Programming](#network-programming)\n* [💾 Database](#database)\n* [📏 Design Pattern](#design-pattern)\n* [⚙️ Link Loading Library](#link-loading-library)\n* [📚 Books](#books)\n* [🔱 C/C++ development direction](#cc-development-direction)\n* [💯 Review of Brush Questions Website](#review-of-brush-questions-website)\n* [📝 Interview Questions Experience](#interview-questions-experience)\n* [📆 Recruitment time post](#recruitment-time-post)\n* [👍 Recommend](#recommend)\n* [👬 Contributor](#contributor)\n* [📜 License](#license)\n\n\n<a id=\"cc\"></a>\n\n## ➕ C/C++\n\n### const\n\n#### Function\n\n1. Modify the variable, indicating that the variable cannot be changed;\n2. Modified pointers, divided into pointers to const (pointer to const) and pointers that are constants themselves (const pointer, const pointer);\n3. Modified references, references to constants (reference to const), are used for formal parameter types, which avoids copying and function modification of values;\n4. Decorate a member function, stating that member variables cannot be modified within the member function.\n\n#### const Pointers and references\n\n* Pointer\n     * Pointer to const\n     * A pointer to a constant itself (const pointer)\n* Reference\n     * Reference to const\n     * There is no const reference because the reference is an alias of an object, the reference is not an object\n\n> (Think of it for convenience) The value modified by const (after const) cannot be changed, such as `p2`, `p3` in the usage example below\n\n\n#### use\n\nconst use\n\n```cpp\n// class\nclass A\n{\nprivate:\n    const int a;                // constant object member, can use initialization list or in-class initializer\n\npublic:\n    // Constructor\n    A() : a(0) { };\n    A(int x) : a(x) { };        //  initialize list\n\n    //  const can be used to distinguish between overloaded functions\n    int getValue();             //  ordinary member function\n    int getValue() const;       // constant member function, must not modify the value of any data member in the class\n};\n\nvoid function()\n{\n    // object\n    A b;                        // ordinary object, can call all member functions\n    const A a;                  // constant object, can only call constant member functions\n    const A *p = &a;            // pointer variable, point to a constant object\n    const A &q = a;             // reference to constant object\n\n    // pointer\n    char greeting[] = \"Hello\";\n    char* p1 = greeting;                // pointer variable, pointing to a character array variable\n    const char* p2 = greeting;          // pointer variable, pointing to a character array constant (char followed by const, indicating that the character pointed to (char) cannot be changed)\n    char* const p3 = greeting;          // itself is a constant pointer to a character array variable (const followed by p3, indicating that the p3 pointer itself cannot be changed)\n    const char* const p4 = greeting;    // a pointer to a constant itself, pointing to a character array constant\n}\n\n// function\nvoid function1(const int Var);           // the passed parameters are immutable within the function\nvoid function2(const char* Var);         // The content pointed to by the parameter pointer is constant\nvoid function3(char* const Var);         // parameter pointer is constant\nvoid function4(const int& Var);          // the reference parameter is constant inside the function\n\n// function return value\nconst int function5();      // returns a constant\nconst int* function6();     // returns a pointer variable to a constant, use: const int * p = function6 ();\nint* const function7();     // returns a constant pointer to a variable, use: int * const p = function7 ();\n```\n\n#### #define and const constants \n\n#define|const constants\n---|---\nMacro definitions, equivalent to character substitution|constant declarations\npreprocessor processing|compiler processing\nwithout type safety checking|with type safety checking\nno memory allocation|memory allocation required\nstored in code segment|stored in data segment\nCan be canceled by `#undef`|Not cancelable\n\n### static\n\n#### Function\n\n1. Modify ordinary variables, modify the storage area and life cycle of the variables, make the variables stored in the static area, allocate space before the `main` function runs, if there is an initial value, initialize it with the initial value, if there is no initial value, the system uses the default Value to initialize it.\n2. Modify ordinary functions to indicate the scope of the function, which can only be used in the file where the function is defined. When developing a project with multiple people, in order to prevent duplicate names from functions in other people's namespaces, you can position functions as static.\n3. Decorate member variables. Decorate member variables so that all objects hold only one of the variable, and you can access the member without generating an object.\n4. Decorate member functions. Decorate member functions so that they can be accessed without generating objects, but non-static members cannot be accessed within static functions.\n\n### this pointer\n\n1. `this` pointer is a special pointer hidden in every non-static member function. It points to the object that called the member function.\n2. When calling a member function on an object, the compiler first assigns the address of the object to the `this` pointer, and then calls the member function. Each time the member function accesses a data member, the `this` pointer is implicitly used.\n3. When a member function is called, it is automatically passed an implicit parameter, which is a pointer to the object where the member function is located.\n4. The `this` pointer is implicitly declared as: `ClassName * const this`, which means that the `this` pointer cannot be assigned; in the `const` member function of the `ClassName` class, the type of the `this` pointer For: `const ClassName * const`, this means that the object pointed to by the `this` pointer cannot be modified (that is, the data members of such objects cannot be assigned);\n5. `this` is not a regular variable, but an rvalue, so you cannot get the address of `this` (you can't `& this`).\n6. It is often necessary to explicitly reference the `this` pointer in the following scenarios:\n    1. To implement a chained reference to an object;\n    2. To avoid performing assignments on the same object;\n    3. When implementing some data structures, such as `list`.\n\n### inline function\n\n#### Features\n\n* Equivalent to writing the contents of the inline function at the call of the inline function;\n* It is equivalent to directly execute the function body without executing the steps of entering the function;\n* Equivalent to a macro, but with more type checking than a macro, it really has function characteristics;\n* The compiler generally does not inline inline functions that include complex operations such as loops, recursion, and switch;\n* Functions defined in class declarations, other than virtual functions, are automatically implicitly treated as inline functions.\n\n#### use\n\ninline use\n\n```cpp\n// Statement 1 (plus inline, recommended)\ninline int functionName(int first, int second,...);\n\n// statement 2 (without inline)\nint functionName(int first, int second,...);\n\n// definition\ninline int functionName(int first, int second,...) {/****/};\n\n// inside class definition, implicitly inline\nclass A {\n    int doA() { return 0; }         // implicit inlining\n}\n\n// definition outside the class, need to be explicitly inlined\nclass A {\n    int doA();\n}\ninline int A::doA() { return 0; }   // requires explicit inlining\n```\n\n#### Compiler processing steps for inline functions\n\n1. Copy the inline function body to the `inline` function call point;\n2. Allocate memory space for local variables in the used `inline` function;\n3. Map the input parameters and return values of the `inline` function to the local variable space of the calling method;\n4. If the `inline` function has multiple return points, turn it into a branch at the end of the inline function code block (using `GOTO`).\n\n#### Advantages and disadvantages\n\nAdvantages\n\n1. Inline functions, like macro functions, perform code expansion at the callee's place, eliminating the need to push parameters on the stack, open and recover stack frames, and return results, etc., thereby improving program execution speed.\n2. Compared to macro functions, inline functions do security checks or automatic type conversions (as with normal functions) when code is expanded, while macro definitions do not.\n3. Declaring a member function that is also defined in a class automatically converts it into an inline function, so inline functions can access class member variables, while macro definitions cannot.\n4. Inline functions are debuggable at runtime, while macro definitions are not.\n\nDisadvantages\n\n1. Code bloat. Inlining is at the expense of code bloat (copy), eliminating the overhead of function calls. If the time to execute the code in the function body is greater than the cost of the function call, then the efficiency gain will be small. On the other hand, copying the code for each inline function call will increase the total code size of the program and consume more memory space.\n2. The inline function cannot be upgraded with the function library upgrade. Changes to the inline function require recompilation, unlike non-inline, which can be linked directly.\n3. Whether it is inline or not is beyond the programmer's control. Inline functions are just suggestions to the compiler. The decision whether to inline functions is up to the compiler.\n\n#### Can a virtual function be an inline function?\n\n> [Are \"inline virtual\" member functions ever actually \"inlined\"?](Http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html)\n\n* A virtual function can be an inline function. Inline can modify a virtual function, but it cannot be inlined when the virtual function exhibits polymorphism.\n* Inlining is recommended by the compiler, and the polymorphism of virtual functions is at runtime. The compiler cannot know which code is called at runtime, so virtual functions cannot be inlined at runtime (runtime). .\n* `inline virtual` The only time it can be inlined is: the compiler knows which class the object is called (such as `Base::who()` ), only if the compiler has an actual object instead of a pointer or reference to the object Will happen.\n\nVirtual function inline use\n\n```cpp\n#include <iostream>  \nusing namespace std;\nclass Base\n{\npublic:\n\tinline virtual void who()\n\t{\n\t\tcout << \"I am Base\\n\";\n\t}\n\tvirtual ~Base() {}\n};\nclass Derived : public Base\n{\npublic:\n\tinline void who()  // Implicit inlining when not writing inline\n\t{\n\t\tcout << \"I am Derived\\n\";\n\t}\n};\n\nint main()\n{\n\t// The virtual function who () here is called through the concrete object (b) of the class (Base), which can be determined during compilation, so it can be inlined, but whether it is inlined depends on the compilation Device.\n\tBase b;\n\tb.who();\n\n\t// The virtual function here is called through a pointer, which is polymorphic and needs to be determined during runtime, so it cannot be inlined.\n\tBase *ptr = new Derived();\n\tptr->who();\n\n\t// Because Base has a virtual destructor (virtual ~ Base () {}), when deleting, the Derived destructor is called first, and then the Base destructor is called to prevent memory leaks.\n\tdelete ptr;\n\tptr = nullptr;\n\n\tsystem(\"pause\");\n\treturn 0;\n} \n```\n\n### volatile\n\n```cpp\nvolatile int i = 10; \n```\n\n* The volatile keyword is a type modifier, and the type variable declared with it indicates that it can be changed by some factors unknown to the compiler (operating system, hardware, other threads, etc.). So using volatile tells the compiler that such objects should not be optimized.\n* Variables declared by the volatile keyword must be fetched from memory each time they are accessed (variables that are not modified by volatile may be fetched from CPU registers due to compiler optimizations)\n* const can be volatile (such as a read-only status register)\n* Pointer can be volatile\n\n### assert()\n\nAssertions are macros, not functions. The prototype of the assert macro is defined in `<assert.h>` (C), `<cassert>` (C ++), and its role is to terminate program execution if its condition returns an error. You can turn off assert by defining `NDEBUG`, but it needs to be at the beginning of the source code, before `include <assert.h>` .\n\nassert () uses\n\n```cpp\n#define NDEBUG          // Add this line, assert is not available\n#include <assert.h>\n\nassert( p != NULL );    // assert is not available\n```\n\n### sizeof()\n\n* sizeof For arrays - get the size of the entire array.\n* sizeof For pointers - get the size of the space occupied by the pointer itself.\n\n### #pragma pack(n)\n\nSet structure, union, and class member variables to be n-byte aligned\n\n#pragma pack (n) use\n\n```cpp\n#pragma pack(push)  // save alignment state\n#pragma pack(4)     // Set to 4 byte alignment\n\nstruct test\n{\n    char m1;\n    double m4;\n    int m3;\n};\n\n#pragma pack(pop)   // Restore alignment\n```\n\n### Bit field\n\n```cpp\nBit mode: 2;    // mode is 2 digits\n```\n\nA class can define its (non-static) data members as bit-fields, which contain a certain number of binary bits in a bit-field. When a program needs to transfer binary data to other programs or hardware devices, the bit field is usually used.\n\n* The layout of the bit field in memory is machine-dependent\n* The type of the bit field must be an integer or enumerated type. The behavior of the bit field in a signed type will depend on the implementation.\n* The fetch operator (&) cannot be applied to the bit field, and no pointer can point to the bit field of the class\n\n### extern \"C\"\n\n* Extern-qualified functions or variables are of type extern\n* Variables and functions decorated with `extern\" C \"` are compiled and linked in C\n\nThe function of `extern\" C \"` is to let the C ++ compiler treat the code declared by `extern\" C \"` as C language code, which can avoid the problem that the code cannot be linked with the symbols in the C language library due to symbol modification. .\n\nextern \"C\" demo\n\n```cpp\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nvoid *memset(void *, int, size_t);\n\n#ifdef __cplusplus\n}\n#endif\n```\n\n### struct with typedef struct\n\n####  In C\n\n```c\n// c\ntypedef struct Student {\n    int age; \n} S;\n```\n\nEquivalent to\n\n```c\n// c\nstruct Student { \n    int age; \n};\n\ntypedef struct Student S;\n```\n\nAt this time `S` is equivalent to` struct Student`, but the two identifier namespaces are different.\n\nYou can also define `void Student(){}` that does not conflict with `struct Student` .\n\n#### In C++\n\nBecause the compiler's rules for positioning symbols (search rules) have changed, it is different from the C language.\n\nFirst, if `struct Student {...};` is defined in the class identifier space, when `Student me;` is used, the compiler will search the global identifier table. If `Student` is not found, it will be in the class identifier. search for.\n\nThat means it can use `Student` or `struct Student`, as follows:\n\n```cpp\n// cpp\nstruct Student { \n    int age; \n};\n\nvoid f( Student me );       // correct, the \"struct\" keyword can be omitted\n```\n\nIf a function with the same name as `Student` is defined, `Student` only represents the function, not the structure, as follows:\n\n```cpp\ntypedef struct Student { \n    int age; \n} S;\n\nvoid Student() {}           //Correct, \"Student\" only represents this function after definition\n\n//void S() {}               // Error, symbol \"S\" has been defined as an alias for \"struct Student\"\n\nint main() {\n    Student(); \n    struct Student me;      // Or \"S me\";\n    return 0;\n}\n```\n\n### struct and class in C ++\n\nIn general, struct is more suitable as an implementation of a data structure, and class is more suitable as an implementation of an object.\n\n#### The difference\n\n* The most essential difference is the default access control\n     1. Default inherited access rights. struct is public and class is private.\n     2. struct as the data structure implementation body, its default data access control is public, and class as the object implementation body, its default member variable access control is private.\n\n### union union\n\nUnion is a special class that saves space. A union can have multiple data members, but only one data member can have a value at any time. When a member is assigned, other members become undefined. Union has the following characteristics:\n\n* The default access control character is public\n* May contain constructors and destructors\n* Cannot contain members of reference type\n* Cannot inherit from other classes and cannot be used as a base class\n* Cannot contain virtual functions\n* Anonymous union can directly access union members in the scope where it is defined\n* Anonymous union cannot contain protected members or private members\n* Global anonymous union must be static\n\nunion demo\n\n```cpp\n#include<iostream>\n\nunion UnionTest {\n    UnionTest() : i(10) {};\n    int i;\n    double d;\n};\n\nstatic union {\n    int i;\n    double d;\n};\n\nint main() {\n    UnionTest u;\n\n    union {\n        int i;\n        double d;\n    };\n\n    std::cout << u.i << std::endl;  // Output UnionTest union 10\n\n    ::i = 20;\n    std::cout << ::i << std::endl;  // Output global static anonymous union 20\n\n    i = 30;\n    std::cout << i << std::endl;    // Output of locally anonymous union of 30\n\n    return 0;\n}\n```\n\n### C implements C ++ classes\n\nC implements object-oriented features of C ++ (encapsulation, inheritance, polymorphism)\n\n* Encapsulation: Use function pointers to encapsulate properties and methods into structures\n* Inheritance: structure nesting\n* Polymorphism: function pointers of parent and child methods are different\n\n> [Can you write object-oriented code in C? [closed]](https://stackoverflow.com/a/351745)\n\n### explicit (keyword)\n\n* explicit constructor modification prevents implicit conversion and copy initialization\n* explicit conversions can prevent implicit conversions, except [conversion by context](https://en.cppreference.com/w/cpp/language/implicit_conversion)\n\nexplicit demo\n```cpp\nstruct A\n{\n\tA(int) { }\n\toperator bool() const { return true; }\n};\n\nstruct B\n{\n\texplicit B(int) {}\n\texplicit operator bool() const { return true; }\n};\n\nvoid doA(A a) {}\n\nvoid doB(B b) {}\n\nint main()\n{\n\tA a1(1);\t\t// OK：direct initialization\n\tA a2 = 1;\t\t// OK：copy initialization\n\tA a3{ 1 };\t\t// OK：direct list initialization\n\tA a4 = { 1 };\t\t// OK：copy list initialization\n\tA a5 = (A)1;\t\t// OK：Allow explicit conversion of static_cast\n\tdoA(1);\t\t\t// OK：Allow implicit conversion from int to A\n\tif (a1);\t\t// OK: implicit conversion from A to bool using conversion function A ::operator bool()\n\tbool a6(a1);\t\t// OK: implicit conversion from A to bool using conversion function A::operator bool()\n\tbool a7 = a1;\t\t// OK: implicit conversion from A to bool using conversion function A::operator bool()\n\tbool a8 = static_cast<bool>(a1);  // OK: static_cast for direct initialization\n\n\tB b1(1);\t\t// OK：direct initialization\n\tB b2 = 1;\t\t// Error: Object modified by explicit constructor cannot be initialized by copying\n\tB b3{ 1 };\t\t// OK：direct list initialization\n\tB b4 = { 1 };\t\t// Error: Object modified by explicit constructor cannot copy list initialization\n\tB b5 = (B)1;\t\t// OK: Allow explicit conversion of static_cast\n\tdoB(1);\t\t\t// Error: Objects whose constructor is explicitly modified cannot be implicitly converted from int to B\n\tif (b1);\t\t// OK: objects modified by explicit conversion function B::operator bool() can be converted from B to bool by context\n\tbool b6(b1);\t\t// OK: Explicitly modified conversion function B::operator The object of bool() can be converted from B to bool by context\n\tbool b7 = b1;\t\t// Error: Objects modified by explicit conversion function B :: operator bool () cannot be implicitly converted\n\tbool b8 = static_cast<bool>(b1);  // OK: static_cast performs direct initialization\n\n\treturn 0;\n}\n```\n\n### friend - friend class and friend function\n\n* Access to private members\n* Destruction of encapsulation\n* Friendship is not transitive\n* One-way friendship\n* There are no restrictions on the form and number of friend declarations\n\n### using\n\n#### using statement\n\nA `using declaration` introduces only one member of a namespace at a time. It allows us to know exactly which name is referenced in the program. Such as:\n\n```cpp\nusing namespace_name :: name;\n```\n\n#### Using declaration of constructor\n\nIn C ++ 11, a derived class can reuse the constructor defined by its direct base class.\n\n```cpp\nclass Derived : Base {\npublic:\n    using Base::Base;\n    /* ... */\n};\n```\n\nAs above using statement, for each constructor of the base class, the compiler generates a derived class constructor corresponding to it (the parameter list is exactly the same). Generates the following type constructor:\n\n```cpp\nDerived (parms): Base (args) {}\n```\n\n#### using instructions\n\nThe `using directive` makes all names in a particular namespace visible, so we don't need to add any prefix qualifiers to them. Such as:\n\n```cpp\nusing namespace_name name;\n```\n\n#### Minimize `using directives` to pollute namespaces\n\n> Generally speaking, it is safer to use the using command than the using compile command, because it** imports only the specified name**. If the name conflicts with a local name, the compiler will** issue instructions**. The using compile command imports all names, including names that may not be needed. If there is a conflict with a local name, the local name will override the namespace version, and the compiler will not issue a warning. In addition, the openness of the namespace means that the names of the namespace may be scattered in multiple places, which makes it difficult to know exactly which names have been added.\n\nusing demo\n\nMinimize `using directives`\n\n```cpp\nusing namespace std;\n```\n\nYou should use `using declarations` more often\n\n```cpp\nint x;\nstd::cin >> x ;\nstd::cout << x << std::endl;\n```\n\nor\n\n```cpp\nusing std::cin;\nusing std::cout;\nusing std::endl;\nint x;\ncin >> x;\ncout << x << endl;\n```\n\n### :: scope resolution operator\n\n#### classification\n\n1. Global scope (`:: name`): used before type names (classes, class members, member functions, variables, etc.) to indicate that the scope is a global namespace\n2. Class scope character (`class :: name`): used to indicate that the scope of the specified type is specific to a class\n3. Namespace scope (`namespace :: name`): used to indicate that the scope of the specified type is specific to a namespace\n\n:: demo\n\n```cpp\nint count = 11;         // Global (: :) count\n\nclass A {\npublic:\n\tstatic int count;   // Count (A::count) of class A\n};\nint A::count = 21;\n\nvoid fun()\n{\n\tint count = 31;     // Initialize the local count to 31\n\tcount = 32;         // Set the local count to 32\n}\n\nint main() {\n\t::count = 12;       // Test 1: Set the global count to 12\n\n\tA::count = 22;      // Test 2: Set the count of class A to 22\n\n\tfun();\t\t        // Test 3\n\n\treturn 0;\n}\n```\n\n### enum - enum type\n\n#### Scoped Enumeration Type\n\n```cpp\nenum class open_modes { input, output, append };\n```\n\n#### Unscoped enumeration type\n\n```cpp\nenum color { red, yellow, green };\nenum { floatPrec = 6, doublePrec = 10 };\n```\n\n### decltype\n\ndecltype keyword is used to check the declared type or expression type and value classification of an entity. grammar:\n\n```cpp\ndecltype ( expression )\n```\n\ndecltype demo\n\n```cpp\n// Tail return allows us to declare the return type after the parameter list\ntemplate <typename It>\nauto fcn(It beg, It end) -> decltype(*beg)\n{\n    / process the sequence\n    return *beg;     // return a reference to an element in the sequence\n}\n// In order to use template parameter members, you must use typename\ntemplate <typename It>\nauto fcn2(It beg, It end) -> typename remove_reference<decltype(*beg)>::type\n{\n    // process the sequence\n    return * beg; // return a copy of an element in the sequence\n}\n```\n\n### reference\n\n#### lvalue reference\n\nRegular reference, which generally represents the identity of the object.\n\n#### rvalue reference\n\nAn rvalue reference is a reference that must be bound to an rvalue (a temporary object, an object to be destroyed) and generally represents the value of the object.\n\nAn rvalue reference implements Move Sementics and Perfect Forwarding. Its main purpose is twofold:\n\n* Eliminate unnecessary copying of objects when two objects interact, saving computing storage resources and improving efficiency.\n* Ability to define generic functions more concisely.\n\n#### Reference Collapse\n\n* `X & &`, `X & &&`, `X && &` can be folded into `X &`\n* `X && &&` can be folded into `X &&`\n\n### Macro\n\n* A macro definition can implement a function similar to a function, but it is not a function after all, and the \"parameters\" in the brackets in the macro definition are not real parameters. The \"parameters\" are replaced one-to-one when the macro is expanded .\n\n### Member initialization list\n\nbenefit\n\n* More efficient: There is no need to call the default constructor once.\n* In some cases it is necessary to use the initialization list:\n   1. Constant members, because constants can only be initialized and cannot be assigned, so they must be placed in the initialization list\n   2. Reference types. References must be initialized at the time of definition and cannot be reassigned, so they must also be written in the initialization list.\n   3. There is no class type for the default constructor, because the initialization list can be used to initialize without having to call the default constructor.\n\n### initializer_list list initialization\n\nInitialize an object with a curly brace initializer list, where the corresponding constructor accepts a `std :: initializer_list` parameter.\n\ninitializer_list uses\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <initializer_list>\n \ntemplate <class T>\nstruct S {\n    std::vector<T> v;\n    S(std::initializer_list<T> l) : v(l) {\n         std::cout << \"constructed with a \" << l.size() << \"-element list\\n\";\n    }\n    void append(std::initializer_list<T> l) {\n        v.insert(v.end(), l.begin(), l.end());\n    }\n    std::pair<const T*, std::size_t> c_arr() const {\n        return {&v[0], v.size()};  // Copy the list initialization in the return statement\n                                   // this does not use std :: initializer_list\n    }\n};\n \ntemplate <typename T>\nvoid templated_fn(T) {}\n \nint main()\n{\n    S<int> s = {1, 2, 3, 4, 5}; // copy initialization\n    s.append({6, 7, 8});      // list initialization in function call\n \n    std::cout << \"The vector size is now \" << s.c_arr().second << \" ints:\\n\";\n \n    for (auto n : s.v)\n        std::cout << n << ' ';\n    std::cout << '\\n';\n \n    std::cout << \"Range-for over brace-init-list: \\n\";\n \n    for (int x : {-1, -2, -3}) // auto rules make this band for work\n        std::cout << x << ' ';\n    std::cout << '\\n';\n \n    auto al = {10, 11, 12};   // special rules for auto\n \n    std::cout << \"The list bound to auto has size() = \" << al.size() << '\\n';\n \n//    templated_fn({1, 2, 3}); // Compile error! \"{1, 2, 3}\" is not an expression,\n                              // it has no type, so T cannot infer\n    templated_fn<std::initializer_list<int>>({1, 2, 3}); // OK\n    templated_fn<std::vector<int>>({1, 2, 3});           // also OK\n}\n```\n\n### Object-oriented\n\nObject-oriented programming (OOP) is a model of program programming with object concepts, and it is also an abstract approach to program development.\n\n![Object-oriented features](https://raw.githubusercontent.com/huihut/interview/master/images/面向对象基本特征.png)\n\nThree Object-Oriented Features-Encapsulation, Inheritance, and Polymorphism\n\n### Encapsulation\n\nEncapsulate objective things into abstract classes, and classes can only use their own data and methods for trusted classes or objects to operate, and hide untrusted information. Keywords: public, protected, private. Do not write defaults to private.\n\n* `public` members: can be accessed by any entity\n* `protected` members: only allowed to be accessed by subclasses and member functions of this class\n* `private` members: only accessible by member functions, friend classes, or friend functions of this class\n\n###  Inheritance\n\n*  Base class (parent class) ——&gt; derived class (subclass)\n\n### Polymorphism\n\n* Polymorphism, that is, multiple states (morphology). In simple terms, we can define polymorphism as the ability of a message to be displayed in multiple forms.\n* Polymorphism is based on encapsulation and inheritance.\n* C polymorphism classification and implementation:\n     1. Ad-hoc Polymorphism (compile-time): function overload, operator overload\n     2. Subtype Polymorphism (runtime): virtual function\n     3. Parametric Polymorphism (compile-time): class template, function template\n     4. Coercion Polymorphism (compilation / runtime): basic type conversion, custom type conversion\n\n> [The Four Polymorphisms in C++](https://catonmat.net/cpp-polymorphism)\n\n#### Static polymorphism (compile time / early binding)\n\nFunction overloading\n\n```cpp\nclass A\n{\npublic:\n    void do(int a);\n    void do(int a, int b);\n};\n```\n\n#### Dynamic polymorphism (runtime / late binding)\n\n* Virtual functions: decorate member functions with virtual to make them virtual\n* Dynamic binding: dynamic binding occurs when a virtual function is called using a reference or pointer to a base class\n\n**note:**\n\n* You can assign an object of a derived class to a pointer or reference of the base class, and not vice versa\n* Ordinary functions (non-class member functions) cannot be virtual functions\n* Static functions (static) cannot be virtual functions\n* The constructor cannot be a virtual function (because when the constructor is called, the virtual table pointer is not in the object's memory space, the virtual table pointer must be formed after the constructor is called)\n* An inline function cannot be a virtual function when it shows polymorphism. For an explanation, see: [Can a virtual function be an inline function? ](https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97)\n\nDynamic polymorphic demo\n\n```cpp\nclass Shape                     // shape class\n{\npublic:\n    virtual double calcArea()\n    {\n        ...\n    }\n    virtual ~Shape();\n};\nclass Circle : public Shape     // circle class\n{\npublic:\n    virtual double calcArea();\n    ...\n};\nclass Rect : public Shape       // rectangle class\n{\npublic:\n    virtual double calcArea();\n    ...\n};\nint main()\n{\n    Shape * shape1 = new Circle(4.0);\n    Shape * shape2 = new Rect(5.0, 6.0);\n    shape1->calcArea();         // call the method in the circular class\n    shape2->calcArea();         // call the method in the rectangle class\n    delete shape1;\n    shape1 = nullptr;\n    delete shape2;\n    shape2 = nullptr;\n    return 0;\n}\n```\n\n### Virtual destructor\n\nThe virtual destructor is to resolve the pointer of the base class to the derived class object, and delete the derived class object with the pointer of the base class.\n\nVirtual destructor demo\n\n```cpp\nclass Shape\n{\npublic:\n    Shape();                    // Constructor cannot be virtual\n    virtual double calcArea();\n    virtual ~Shape();           // virtual destructor\n};\nclass Circle : public Shape     // circle class\n{\npublic:\n    virtual double calcArea();\n    ...\n};\nint main()\n{\n    Shape * shape1 = new Circle(4.0);\n    shape1->calcArea();    \n    delete shape1;  // Because Shape has a virtual destructor, when delete deletes the memory, it first calls the subclass destructor and then the base class destructor to prevent memory leaks.\n    shape1 = NULL;\n    return 0；\n}\n```\n\n### Pure virtual functions\n\nA pure virtual function is a special kind of virtual function. You cannot give a meaningful implementation to a virtual function in a base class. Instead, you declare it as a pure virtual function. Its implementation is left to the derived classes of the base class.\n\n```cpp\nvirtual int A() = 0;\n```\n\n### Virtual functions, pure virtual functions\n\n* If a virtual function is declared in the class, this function is implemented, even if it is empty, its role is to allow this function to be overridden in its subclasses, so that the compiler can use Late binding to achieve polymorphism. A pure virtual function is just an interface. It is a function declaration. It must be left in a subclass to implement it.\n* Virtual functions can not be overridden in subclasses; but pure virtual functions must be implemented in subclasses to instantiate subclasses.\n* The virtual function class is used for \"implementation inheritance\". Inheriting the interface also inherits the implementation of the parent class. Pure virtual functions focus on the uniformity of the interface, and the implementation is done by subclasses.\n* A class with a pure virtual function is called an abstract class. This class cannot directly generate objects. It can only be used after being inherited and rewriting its virtual function. After an abstract class is inherited, subclasses can continue to be abstract or ordinary classes.\n* Virtual base class is the base class in virtual inheritance, see below for details.\n\n> [CSDN . C++ And connection of virtual functions and pure virtual functions](https://blog.csdn.net/u012260238/article/details/53610462)\n\n### Virtual function pointer, virtual function table\n\n* Virtual function pointer: In an object containing a virtual function class, it points to a virtual function table, which is determined at runtime.\n* Virtual function table: in the program read-only data section (`.rodata section`, see: [object file storage structure](#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)），Stores virtual function pointers. If the derived class implements a virtual function of the base class, the virtual function pointer of the original base class is overwritten in the virtual table, and is created according to the class declaration at compile time.\n\n> [C++ Function (table) implementation mechanism and simulation implementation in C language](https://blog.twofei.com/496/)\n\n### Virtual inheritance\n\nVirtual inheritance is used to solve the problem of diamond inheritance under multiple inheritance conditions (wasting storage space and ambiguity).\n\nThe underlying implementation principle is related to the compiler. It is generally implemented by ** virtual base class pointer ** and ** virtual base class table **. Each virtual inherited subclass has a virtual base class pointer (occupies the storage space of a pointer) , 4 bytes) and virtual base class table (does not occupy storage space of class objects) (It should be emphasized that the virtual base class will still have a copy in the subclass, but there is only one copy at most, not not in the subclass. Inside); when the subclass of virtual inheritance is inherited as the parent class, the pointer of the virtual base class will also be inherited.\n\nIn fact, vbptr refers to a virtual base table pointer. This pointer points to a virtual base table. The virtual table records the offset address of the virtual base class and this class. Offset address, so that the virtual base class members are found, and virtual inheritance does not need to maintain two identical copies of the public base class (virtual base class) like ordinary multiple inheritance, saving storage space.\n\n### Virtual inheritance, virtual functions\n\n* Similarities: Both use virtual pointers (both occupy class storage space) and virtual tables (both do not occupy class storage space)\n* the difference:\n    * Virtual inheritance\n        * The virtual base class still exists in the inherited class and only takes up storage space\n        * The virtual base class table stores the offset of the virtual base class relative to the direct inherited class\n    * Virtual function\n        * Virtual functions do not take up storage space\n        * The virtual function table stores the virtual function address\n\n### Template classes, member templates, virtual functions\n\n* Virtual functions can be used in template classes\n* The member template of a class (whether it is a normal class or a class template) (it is a member function of the template) cannot be a virtual function\n\n### Abstract class, interface class, aggregate class\n\n* Abstract class: a class containing pure virtual functions\n* Interface class: Abstract class containing only pure virtual functions\n* Aggregation classes: Users can directly access their members and have a special form of initialization syntax. Meet the following characteristics:\n    * All members are public\n    * No constructor is defined\n    * No in-class initialization\n    * No base class, no virtual function\n\n### Memory allocation and management\n\n#### malloc, calloc, realloc, alloca\n\n1. malloc: apply for a specified number of bytes of memory. The initial value in the requested memory is uncertain.\n2. calloc: For an object of a specified length, allocate memory that can hold the specified number of objects. Each bit of the requested memory is initialized to 0.\n3. realloc: change the previously allocated memory length (increase or decrease). When increasing the length, it may be necessary to move the contents of the previously allocated area to another sufficiently large area, while the initial value in the newly added area is uncertain.\n4. alloca: apply for memory on the stack. When the program pops out of the stack, it will automatically release memory. However, it should be noted that alloca is not portable and difficult to implement on machines without traditional stacks. alloca should not be used in programs that must be widely ported. C99 supports variable-length arrays (VLAs) and can be used instead of alloca.\n\n#### malloc, free\n\nUsed to allocate and release memory\n\nmalloc, free use\n\nApply for memory and confirm whether the application is successful\n\n```cpp\nchar *str = (char*) malloc(100);\nassert(str != nullptr);\n```\n\nPointer is empty after freeing memory\n\n```cpp\nfree(p); \np = nullptr;\n```\n\n#### new、delete\n\n1. new / new []: Do two things, first call malloc at the bottom to allocate memory, and then call the constructor (create the object).\n2. delete / delete []: also complete two things, first call the destructor (clean up resources), and then call free to free up space at the bottom.\n3. new automatically calculates the number of bytes required when applying for memory, and malloc requires us to enter the number of bytes of the requested memory space ourselves.\n\nnew, delete demo\n\nApply for memory and confirm whether the application is successful\n\n```cpp\nint main()\n{\n    T* t = new T();     // memory allocation first, then constructor\n    delete t;           // destructor first, then release memory\n    return 0;\n}\n```\n\n#### Positioning new\n\nPositioning new (placement new) allows us to pass additional address parameters to new to create objects in a pre-specified memory area.\n\n```cpp\nnew (place_address) type\nnew (place_address) type (initializers)\nnew (place_address) type [size]\nnew (place_address) type [size] { braced initializer list }\n```\n\n* `place_address` is a pointer\n* `initializers` provides a (possibly empty) comma-separated list of initial values\n\n### delete this - Is it legal?\n\n> [Is it legal (and moral) for a member function to say delete this?](https://isocpp.org/wiki/faq/freestore-mgmt#delete-this)\n\nLegal, but:\n\n1. It must be guaranteed that this object is allocated via `new` (not `new[]`, not placement new, not on the stack, not global, not a member of other objects)\n2. You must ensure that the member function that calls delete this is the last member function that calls this\n3. You must ensure that the member function does not call this after `delete this`\n4. Make sure no one uses it after delete this\n\n### How to define a class that can only generate objects on the heap (on the stack)?\n\n> [How to define a class that can only generate objects on the heap (on the stack)?](https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618)\n\n#### Only on the heap\n\nMethod: Make the destructor private\n\nReason: C ++ is a static binding language. The compiler manages the life cycle of objects on the stack. When the compiler allocates stack space for class objects, it first checks the accessibility of the class's destructor. If the destructor is not accessible, the object cannot be created on the stack.\n\n#### Only on the stack\n\nMethod: overload new and delete as private\n\nReason: The object is generated on the heap using the new keyword operation. The process is divided into two stages: the first stage uses new to find available memory on the heap and allocates it to the object; the second stage calls the constructor to generate the object. By setting the new operation to private, the first phase cannot be completed, and objects cannot be generated on the heap.\n\n### Smart pointer\n\n#### In the C ++ Standard Library (STL)\n\nheader file：`#include <memory>`\n\n#### C++ 98\n\n```cpp\nstd::auto_ptr<std::string> ps (new std::string(str))；\n```\n\n#### C++ 11\n\n1. shared_ptr\n2. unique_ptr\n3. weak_ptr\n4. auto_ptr (Deprecated by C ++ 11)\n\n* Class shared_ptr implements the concept of shared ownership. Multiple smart pointers point to the same object, and that object and its associated resources are released when the \"last reference is destroyed\". In order to perform the above work in more complex scenarios, the standard library provides auxiliary classes such as weak_ptr, bad_weak_ptr, and enable_shared_from_this.\n* Class unique_ptr implements the concept of exclusive ownership or strict ownership, ensuring that only one smart pointer can point to the object at a time. You can transfer ownership. It is especially useful for avoiding resource leaks, such as forgetting to delete after new.\n\n##### shared_ptr\n\nMultiple smart pointers can share the same object, and the last one of the object has the responsibility to destroy the object and clean up all resources related to the object.\n\n* Support custom deleter, which can prevent Cross-DLL problems (object is created by new in dynamic link library (DLL), but deleted by another DLL), and the mutex is automatically released\n\n##### weak_ptr\n\nweak_ptr allows you to share but does not own an object. Once the last smart pointer that owns the object loses ownership, any weak_ptr will automatically become empty. Therefore, in addition to the default and copy constructors, weak_ptr only provides a \"accept a shared_ptr\" constructor.\n\n* The problem of cycles of references (two objects that have not been used actually refer to each other, making them appear to be in the \"used\" state)\n\n##### unique_ptr\n\nunique_ptr is a type that has only been available since C ++ 11, and is a smart pointer that can help avoid resource leaks during exceptions. Using exclusive ownership means that you can ensure that an object and its corresponding resource are owned by only one pointer at a time. Once you own the destroyed or programmed empty, or start owning another object, the previously owned object will be destroyed and any corresponding resources will be released.\n\n* unique_ptr is used instead of auto_ptr\n\n##### auto_ptr\n\nDeprecated by c ++ 11 due to lack of language features such as `std::move` semantics \"for construction and assignment\", and other flaws.\n\n##### auto_ptr compared to unique_ptr\n\n* auto_ptr can be assigned a copy, and ownership is transferred after copying; unqiue_ptr has no copy assignment semantics, but implements `move` semantics;\n* auto_ptr objects cannot manage arrays (destructive call `delete`), unique_ptr can manage arrays (destructive call` delete [] `);\n\n### Casting Operator\n\n> [MSDN. Casting Operator](https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx)\n\n#### static_cast\n\n* For non-polymorphic conversions\n* Do not perform runtime type checking (conversion security is not as good as dynamic_cast)\n* Usually used to convert numeric data types (such as float-> int)\n* You can move the pointer throughout the class hierarchy. It is safe (upward conversion) for a child class to be converted to a parent class, and it is not safe to convert a parent class to a child class (because a child class may have fields or methods that are not in the parent class)\n\n> Upcast is an implicit conversion.\n\n#### dynamic_cast\n\n* For polymorphic type conversions\n* Perform line runtime type checking\n* Only applicable to pointers or references\n* Conversion of ambiguous pointers will fail (return nullptr), but no exception will be thrown\n* You can move the pointer throughout the class hierarchy, including up conversion, down conversion\n\n#### const_cast\n\n* Used to remove const, volatile, and __unaligned features (such as converting const int to int)\n\n#### reinterpret_cast\n\n* Simple reinterpretation for bits\n* Misuse of the reinterpret_cast operator can be very risky. Unless the required conversion itself is low-level, you should use one of the other cast operators.\n* Allows conversion of any pointer to any other pointer type (such as `char *` to `int *` or `One_class *` to `Unrelated_class *`, but it is not itself safe)\n* Also allows conversion of any integer type to any pointer type and reverse conversion.\n* The reinterpret_cast operator cannot lose const, volatile, or __unaligned attributes.\n* A practical use of reinterpret_cast is in a hash function, which is to map values to indexes by making two different values hardly end with the same index.\n\n#### bad_cast\n\n* The dynamic_cast operator throws a bad_cast exception because the cast to a reference type fails.\n\nbad_cast demo\n\n```cpp\ntry {  \n    Circle& ref_circle = dynamic_cast<Circle&>(ref_shape);   \n}  \ncatch (bad_cast b) {  \n    cout << \"Caught: \" << b.what();  \n} \n```\n\n### Runtime Type Information (RTTI)\n\n#### dynamic_cast\n\n* For polymorphic type conversions\n\n#### typeid\n\n* The typeid operator allows determining the type of an object at runtime\n* type \\ _id returns a reference to a type \\ _info object\n* If you want to get the data type of the derived class through the pointer of the base class, the base class must have a virtual function\n* Can only get the actual type of the object\n\n#### type_info\n\n* The type_info class describes the type information generated by the compiler in the program. Objects of this class can effectively store pointers to the names of types. The type_info class can also store encoded values suitable for comparing whether two types are equal or comparing their permutation order. The encoding rules and permutation order for the types are unspecified and may vary from program to program.\n* Header file: `typeinfo`\n\ntypeid, type_info demo\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Flyable                       // can fly\n{\npublic:\n    virtual void takeoff() = 0;     // take off\n    virtual void land() = 0;        // land\n};\nclass Bird : public Flyable         // bird\n{\npublic:\n    void foraging() {...}           // foraging\n    virtual void takeoff() {...}\n    virtual void land() {...}\n    virtual ~Bird(){}\n};\nclass Plane : public Flyable        // airplane\n{\npublic:\n    void carry() {...}              // carry\n    virtual void takeoff() {...}\n    virtual void land() {...}\n};\n\nclass type_info\n{\npublic:\n    const char* name() const;\n    bool operator == (const type_info & rhs) const;\n    bool operator != (const type_info & rhs) const;\n    int before(const type_info & rhs) const;\n    virtual ~type_info();\nprivate:\n    ...\n};\n\nvoid doSomething(Flyable *obj)                 // do something\n{\n    obj->takeoff();\n\n    cout << typeid(*obj).name() << endl;        //  output the type of the incoming object（\"class Bird\" or \"class Plane\"）\n\n    if(typeid(*obj) == typeid(Bird))            // determine object type\n    {\n        Bird *bird = dynamic_cast<Bird *>(obj); // object conversion\n        bird->foraging();\n    }\n\n    obj->land();\n}\n\nint main(){\n\tBird *b = new Bird();\n\tdoSomething(b);\n\tdelete b;\n\tb = nullptr;\n\treturn 0;\n}\n```\n\n<a id=\"effective\"></a>\n\n## ⭐️ Effective\n\n### Effective C++\n\n1. Treat C ++ as a language federation (C, Object-Oriented C ++, Template C ++, STL)\n2. It is better to replace the preprocessor with a compiler (try to replace `# define` with `const`, `enum`, `inline`)\n3. Use const whenever possible\n4. Make sure that the object has been initialized before being used (the copy constructor is more efficient than the default copy assignment after construction)\n5. Understand what functions C ++ silently writes and calls (the compiler secretly creates a default constructor, copy constructor, copy assignment operator, destructor for class)\n6. If you don't want to use the automatically generated function of the compiler, you should explicitly reject it (declare member functions that you don't want to use as private and do not implement them)\n7. Declare a virtual destructor for the polymorphic base class (if the class has any virtual functions, it should have a virtual destructor)\n8. Don't let the exception escape the destructor (the destructor should swallow and not propagate the exception, or end the program, instead of spitting out the exception; if you want to handle the exception, you should handle it in a non-destructed ordinary function)\n9. Never call virtual functions during construction and destruction (because such calls never descend to the derived class)\n10. Let `operator =` return a `reference to * this` (for chained assignment)\n11. Handle \"self-assignment\" in `operator =`\n12. When assigning an object, be sure to copy \"all member variables within the object\" and \"all base class components\" (call the base class copy constructor)\n13. Manage resources by objects (resources are obtained in the constructor and released in the destructor. It is recommended to use smart pointers. The resource acquisition time is the initialization time (Resource Acquisition Is Initialization (RAII)).\n14. Be careful with copying behavior in resource management classes (the general RAII class copying behavior is: inhibit copying, reference counting, deep copying, transfer of bottom resource ownership (similar to auto_ptr))\n15. Provide access to raw resources in the resource management class (access to raw resources may be explicitly or implicitly converted, in general, display conversion is safer, and implicit conversion is more convenient for customers)\n16. Use the same form when using new and delete in pairs (`[]` in `new` then` delete []`, `new` without `[]` and `delete`)\n17. Store the newed object in (into) a smart pointer in a separate statement (if you do not do this, it may cause undetectable resource leaks due to compiler optimizations)\n18. Make interfaces easy to use correctly and not easy to be misused (Promote normal use: Consistency of interfaces, compatible behavior of built-in types; Prevent misuse: Create new types, Restrict operation on types, Constrain object values Eliminate the client's resource management responsibilities)\n19. Designing a class is like designing a type, and you need to consider object creation, destruction, initialization, assignment, value passing, legal values, inheritance relationships, conversion, generalization, and so on.\n20. Prefer pass-by-reference-to-const instead of pass-by-value (the former is usually more efficient and avoids slicing problems, but not applicable to built-in types, STL iterators, function objects)\n21. When an object must be returned, do not deliberately return its reference (never return pointer or reference to a local stack object, or return reference to a heap-allocated object, or return pointer or reference to a local static object, which may be required at the same time. Multiple such objects.)\n22. Declare member variables as private (for encapsulation, consistency, precise control over reads and writes, etc.)\n23. Rather replace the member function with non-member and non-friend (which can increase packaging flexibility, packaging flexibility, and functional extensibility)\n24. If all parameters (including the metaphoric parameter pointed to by this pointer) require type conversion, please use a non-member function for this\n25. Consider writing a swap function that does not throw exceptions\n26. Delay the appearance of variable definitions as much as possible (to increase program clarity and improve program efficiency)\n27. Do as few transformations as possible (old: `(T) expression`,` T (expression) `; new:` const_cast <T> (expression) `,` dynamic_cast <T> (expression) `,` reinterpret_cast <T > (expression) `,` static_cast <T> (expression) `;; try to avoid transformation, pay attention to efficiency and avoid dynamic_casts, try to design so that no transformation is needed, the transformation can be encapsulated into a function, rather a new type of transformation is preferred)\n28. Avoid using handles (including references, pointers, iterators) to point inside the object (to increase encapsulation, make const member functions behave more like const, and reduce \"dangling handles\" (such as dangling pointers, etc.) possibility)\n29. It is worthwhile to work for \"exception safety\" (Exception-safe functions) will not leak resources or allow any data structure to break even if an exception occurs. There are three possible guarantees: basic, strong Type, do not throw abnormal type)\n30. Thorough understanding of inlining inside and outside (inlining is a compile-time behavior in most C ++ programs; whether an inline function is really inline depends on the compiler; most compilers refuse to be too complex (such as with loops or recursion) ) Function inlining, and all calls to virtual functions (unless they are the most bland) will also cause inlining to fail; the code expansion caused by inline may cause a loss of efficiency; inline functions cannot be upgraded with the upgrade of the library)\n31. Minimize the compilation dependencies between files (if you can use object references or object pointers to complete the task, do not use objects; if possible, try to replace class definitions with class declarations; provide differences between declarative and definitions Header file)\n32. Make sure your public inheritance moulds out an is-a (is a) relationship (applicable to everything in base classes must apply to derived classes, because every derived class object is also a base class object )\n33. Avoid obscuring inherited names (you can use using declarative or forwarding functions to make the obscure names goodbye)\n34. Distinguish between interface inheritance and implementation inheritance (under public inheritance, derived classes always inherit the interface of the base class; pure virtual functions only specify interface inheritance; non-pure virtual virtual functions specify interface inheritance and default implementation inheritance; non -virtual function specifies interface inheritance and mandatory implementation inheritance)\n35. Consider alternatives to virtual functions (such as the non-virtual interface (NVI) approach of the Template Method design pattern, replacing virtual functions with \"function pointer member variables\" and replacing virtual functions with `tr1 :: function` member variables, Replace the virtual function in the inheritance system with another virtual function in the inheritance system)\n36. Never redefine inherited non-virtual functions\n37. Never redefine inherited default parameter values, because the default parameter value is statically bound (statically bound), but the virtual function is dynamically bound (dynamically bound)\n38. Through compound molding has-a (one) or \"implemented according to something\" (in the application domain, compound means has-a (there is one); in the implementation domain, compound means (Is-implemented-in-terms-of)\n39. Use private inheritance wisely and prudently (private inheritance means is-implemented-in-terms-of (implemented according to something)), use composite whenever possible, when the derived class needs to access the members of the protected base class, or needs to re- Use private inheritance when defining inherited virtual functions, or when empty base optimization is required)\n40. Use multiple inheritance wisely and prudently (multiple inheritance is more complex than single inheritance, may lead to new ambiguities, and the need for virtual inheritance, but it does have a legitimate purpose, such as \"public inheritance of an interface class\" and \"private inheritance A class that assists implementation \"; virtual inheritance can solve the ambiguity of diamond inheritance under multiple inheritance, but it will increase the size, speed, complexity of initialization and assignment, etc.)\n41. Understand implicit interfaces and compile-time polymorphism (both classes and templates support interfaces and polymorphism); class interfaces are explicit with signatures as the center, and polymorphism is through virtual Functions occur at runtime; the interface of a template is implicit based on valid expressions, and polymorphism occurs through comprehension of templates and function overloading resolution at compile time)\n42. Understand the double meaning of typename (declared that the template type parameter is that the meaning of the prefix keywords class and typename are exactly the same; use the keyword typename to identify the nested dependent type name, but not in the base class lists or members Use it as a base class modifier in the member initialization list)\n43. Learn to deal with the names in templated base classes (you can refer to the member names in base class templates via `this->` in derived class templates, or by a clearly written \"base class qualification modifier\" )\n44. Extract parameter-independent code from templates (code bloat caused by non-type template parameters can often be eliminated by replacing template parameters with function parameters or class member variables; because of type parameters The resulting code bloat can often be achieved by having implementation types with identical binary representations share implementation codes)\n45. Use member function templates to accept all compatible types (please use member function templates to generate functions that \"accept all compatible types\"; declare member templates for \"generalized copy construction\" or \"generalized assignment operation\" Also need to declare the normal copy constructor and copy assignment operator)\n46. ​​When you need type conversion, please define non-member functions for the template (when we write a class template, and the \"relevant to this template\" function provided by it supports \"implicit type conversion of all parameters\", please those functions Defined as \"friend function inside class template\")\n47. Please use traits classes to represent type information (traits classes use templates and \"templates specialization\" to make \"type-related information\" available at compile time, and use overloading (overloading) to implement if ... else on types at compile time test)\n48. Recognize template metaprogramming (TMP, template metaprogramming)\n\n### More Effective c++\n\n1. Carefully distinguish between pointers and references (when you know that you need to point to something and never change to point to other things, or when you implement an operator whose syntax requirements cannot be met by pointers, you should choose references; At any other time, use pointers)\n2. It is best to use C ++ cast operators (`static_cast`, `const_cast`, `dynamic_cast`, `reinterpret_cast`)\n3. Never polymorphically treat arrays (polymorphism and pointer arithmetic cannot be mixed; array objects almost always involve pointer arithmetic, so arrays and polymorphism should not be mixed)\n4. Don't provide default constructor if necessary (to avoid fields in the object being initialized meaninglessly)\n5. Be alert to custom \"type conversion functions\" (single argument constructors can be avoided by simple methods (explicit keywords) or proxy classes); implicit type conversion operators can be changed to explicit Member function to avoid unexpected behavior)\n6. Distinguish the prefix and postfix forms of the increment / decrement operator (pre-accumulate and take out and return a reference; post-preparation take and accumulate and return a const object; when processing user-defined types Should use pre-increment as much as possible; post-implementation should be based on its pre-brother)\n7. Never overload the `&&`, `||`, and `,` operators (`&&` and `||` overloading will replace “sudden-semantic semantics” with “function call semantics”; `The overload of` does not guarantee that the left expression must be evaluated earlier than the right expression)\n8. Understand the different meanings of new and delete ( `new operator`, `operator new`, `placement new`, `operator new[]` ; `delete operator`, `operator delete`, `destructor`, `operator delete[]` )\n9. Use destructors to avoid leaking resources (freeing resources when destructors can avoid resource leaks during exceptions)\n10. Prevent resource leaks in constructors (because C ++ will only destruct objects that have already been constructed, the constructor can use try ... catch or auto_ptr (and similar classes) to handle resource leaks when exceptions occur)\n11. Prohibit exceptions from flowing out of destructors (reason: first, avoid the terminate function being called in the stack-unwinding mechanism of exception propagation; second, help ensure that destructors complete everything they should do)\n12. Understand the difference between \"throwing an exception\" and \"passing a parameter\" or \"calling a virtual function\" (first, exception objects are always copied (except by pointer), if you catch even by value It is copied twice, but the object passed to the function parameter does not necessarily have to be copied. Second, the object that is \"thrown as exceptions\" has fewer allowed type conversion actions than the object \"passed to the function\"; Third, the catch clause is checked by the compiler for its \"order in which it appears in the source code\". The first match succeeds and is executed, and a virtual function is called. Function \"\n13. Capture exceptions by by reference (to avoid the problem of object deletion and cutting of exception objects, retain the ability to catch standard exceptions, and restrict the number of times an exception object needs to be copied)\n14. Use exception specifications wisely (exception specifications provide an excellent description of what kind of exceptions a function expects to throw; there are also some disadvantages, including that the compiler only checks them locally and is easy to inadvertently violate them. Prevent higher-level exception handlers from handling unexpected exceptions)\n15. Understand the cost of exception handling (roughly estimated, if try block is used, the overall code will expand by about 5% -10%, and the execution speed will also decrease by this number; therefore, please limit your use of try block and exception specifications Must-use locations, and throw exceptions only in case of real exceptions)\n16. Keep in mind the 80-20 rule (the overall performance of software is almost always determined by a small part of its constituent elements (codes), and the code that consumes resources can be identified using a program profiler)\n17. Consider using lazy evaluation (can be applied to: Reference Counting to avoid unnecessary object copying, distinguish read and write actions of operator [] to do different things, Lazy Fetching (easy (Remove) to avoid unnecessary database reads, and Lazy Expression Evaluation (to avoid unnecessary numerical calculations)\n18. Amortize the expected computational cost (when you must support certain operations whose structure is almost always required, or when the results are often required multiple times, over-eager evaluation can improve program efficiency )\n\n### Google C ++ Style Guide\n\n* English: [Google C ++ Style Guide](https://google.github.io/styleguide/cppguide.html)\n* Chinese: [C ++ Style Guide](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/)\n\n### Other\n\n* [Bjarne Stroustrup FAQ](http://www.stroustrup.com/bs_faq.html)\n* [C ++ style and trick FAQ for Bjarne Stroustrup](http://www.stroustrup.com/bs_faq2.html)\n\n<a id=\"stl\"></a>\n\n## 📦 STL\n\n### STL index\n\n[STL Method Meaning Index](https://github.com/huihut/interview/tree/master/STL)\n\n### STL container\n\nContainer | Underlying data structure | Time complexity | Unordered | Can not be repeated | Other\n---|---|---|---|---|---\n[array](https://github.com/huihut/interview/tree/master/STL#array) | array | random read and change O(1) | unordered | repeatable | support random access\n[vector](https://github.com/huihut/interview/tree/master/STL#vector) | Array | Random read, tail insertion, tail deletion O(1) <br/> head insertion, head Delete O(n) | Unordered | Repeatable | Support random access\n[deque](https://github.com/huihut/interview/tree/master/STL#deque) | Dual-end queue | End-to-end insertion, end-to-end deletion O(1) | Unordered | Repeatable | One central control + Multiple buffers, support rapid addition and deletion at the beginning and end, support random access\n[forward_list](https://github.com/huihut/interview/tree/master/STL#forward_list) | One-way linked list | Insert and delete O(1) | Unordered | Repeatable | Random access is not supported\n[list](https://github.com/huihut/interview/tree/master/STL#list) | Doubly linked list | Insert / delete O(1) | Unordered | Repeatable | Does not support random access\n[stack](https://github.com/huihut/interview/tree/master/STL#stack) | deque / list | top insert, top delete O(1) | unordered | repeatable | deque or list closed head The end is open. The reason why the vector is not used should be that the capacity is limited, and the expansion takes time.\n[queue](https://github.com/huihut/interview/tree/master/STL#queue) | deque / list | tail insertion, head deletion O(1) | unordered | repeatable | deque or list closure The head end is open. The reason why the vector is not used should be that the capacity is limited, and the expansion takes time.\n[priority_queue](https://github.com/huihut/interview/tree/master/STL#priority_queue) | vector + max-heap | Insert, delete O(log<sub>2</sub>n) | Ordered | Repeatable | vector container + heap processing rules\n[set](https://github.com/huihut/interview/tree/master/STL#set) | Red and Black Tree | Insert, delete, find O(log<sub>2</sub>n) | Ordered | Not repeatable |\n[multiset](https://github.com/huihut/interview/tree/master/STL#multiset) | Red and Black Tree | Insert, delete, find O(log<sub>2</sub>n) | Ordered | Repeatable |\n[map](https://github.com/huihut/interview/tree/master/STL#map) | Red and Black Tree | Insert, delete, find O(log<sub>2</sub>n) | Ordered | Not repeatable |\n[multimap](https://github.com/huihut/interview/tree/master/STL#multimap) | Red and Black Tree | Insert, delete, find O(log<sub>2</sub>n) | Ordered | Repeatable |\n[unordered_set](https://github.com/huihut/interview/tree/master/STL#unordered_set) | Hash Table | Insert, Delete, Find O(1) Worst O(n) | Unordered | Not Repeatable |\n[unordered_multiset](https://github.com/huihut/interview/tree/master/STL#unordered_multiset) | Hash Table | Insert, Delete, Find O(1) Worst O(n) | Unordered | Repeatable |\n[unordered_map](https://github.com/huihut/interview/tree/master/STL#unordered_map) | Hash Table | Insert, Delete, Find O(1) Worst O(n) | Unordered | Not Repeatable |\n[unordered_multimap](https://github.com/huihut/interview/tree/master/STL#unordered_multimap) | Hash Table | Insert, Delete, Find O(1) Worst O(n) | Unordered | Repeatable |\n\n\n### STL Algorithm\n\nAlgorithm | Low-level algorithm | Time complexity | Can not be repeated\n--- | --- | --- | ---\n[find](http://www.cplusplus.com/reference/algorithm/find/) | Sequence search | O(n) | Repeatable\n[sort](https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h#L4808) | [Introspection sorting](https://en.wikipedia.org/wiki/Introsort) | O(n*log<sub>2</sub>n) | Repeatable\n\n<a id=\"data-structure\"></a>\n\n## 〽️ Data Structure\n\n### Sequence structure\n\n#### Sequential stack（Sequence Stack）\n\n[SqStack.cpp](DataStructure/SqStack.cpp)\n\nSequential stack data structures and pictures\n\n```cpp\ntypedef struct {\n\tElemType *elem;\n\tint top;\n\tint size;\n\tint increment;\n} SqStack;\n```\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/SqStack.png)\n\n#### queue（Sequence Queue）\n\nQueue data structure\n\n```cpp\ntypedef struct {\n\tElemType * elem;\n\tint front;\n\tint rear;\n\tint maxSize;\n}SqQueue;\n```\n\n##### Acyclic queue\n\nAcyclic queue picture\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/SqQueue.png)\n\n`SqQueue.rear++`\n\n##### Circular queue\n\nCircular queue picture\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/SqLoopStack.png)\n\n`SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize`\n\n#### Sequence table（Sequence List）\n\n[SqList.cpp](DataStructure/SqList.cpp)\n\nSequence table data structure and pictures\n\n```cpp\ntypedef struct {\n\tElemType *elem;\n\tint length;\n\tint size;\n\tint increment;\n} SqList;\n```\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/SqList.png)\n\n\n### Chain structure\n\n[LinkList.cpp](DataStructure/LinkList.cpp)\n\n[LinkList_with_head.cpp](DataStructure/LinkList_with_head.cpp)\n\nChained data structure\n\n```cpp\ntypedef struct LNode {\n    ElemType data;\n    struct LNode *next;\n} LNode, *LinkList; \n```\n\n#### Chain queue（Link Queue）\n\nChain queue picture\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/LinkQueue.png)\n\n#### Chained representation of a linear list\n\n##### Singly-Linked list（Link List）\n\nSingly-linked list picture\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/LinkList.png)\n\n##### Doubly linked list（Du-Link-List）\n\nDoubly-linked list picture\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/DuLinkList.png)\n\n##### Circular linked list（Cir-Link-List）\n\nCircular-linked list picture\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/CirLinkList.png)\n\n### Hash table\n\n[HashTable.cpp](DataStructure/HashTable.cpp)\n\n#### Concept\n\nHash function：`H(key): K -> D , key ∈ K`\n\n#### Construction method\n\n* Direct Addressing\n* Divided remainder method\n* Digital analysis method\n* Folding method\n* The square method\n\n#### Collision resolution method\n\n* Chain address method: single linked list linked with the same key\n* Open Addressing\n     * Linear detection method: same key-> put to the next position of key，`Hi = (H(key) + i) % m`\n    * Secondary detection method: same key-> put to `Di = 1^2, -1^2, ..., ±（k)^2,(k<=m/2）`\n    * Random detection：`H = (H(key) + Pseudo-random number) % m`\n\n#### Hash table data structure for linear probing\n\nHash table data structure and pictures for linear detection\n\n```cpp\ntypedef char KeyType;\n\ntypedef struct {\n\tKeyType key;\n}RcdType;\n\ntypedef struct {\n\tRcdType *rcd;\n\tint size;\n\tint count;\n\tbool *tag;\n}HashTable;\n```\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/HashTable.png)\n\n### Recursion\n\n#### Concept\n\nFunction calls itself directly or indirectly\n\n#### Recursion and Divide\n\n* Divide and Conquer\n     * Breakdown of the problem\n     * Problem size decomposition\n* Half search (recursive)\n* Merge sort (recursive)\n* Quick sort (recursive)\n\n#### Recursion and Iteration\n\n* Iteration: use the old value of the variable repeatedly to push out the new value\n* Search in half (iterative)\n* Merge sort (iterative)\n\n#### Generalized table\n\n##### Head and tail linked list storage representation\n\nHead and tail linked list storage representations and pictures for generalized tables\n\n```cpp\n// Head-to-tail linked list storage representation of generalized list\ntypedef enum {ATOM, LIST} ElemTag;\n// ATOM == 0: atom, LIST == 1: child table\ntypedef struct GLNode {\n    ElemTag tag;\n    // public part, used to distinguish atomic nodes from table nodes\n    union {\n        // joint part of atomic node and table node\n        AtomType atom;\n         // atom is the range of atom nodes, AtomType is defined by the user\n        struct {\n            struct GLNode *hp, *tp;\n        } ptr;\n        /// ptr is the pointer field of the table node, prt.hp and ptr.tp point to the table header and table tail respectively\n    } a;\n} *GList, GLNode;\n```\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/GeneralizedList1.png)\n\n##### Extended linear linked list storage representation\n\nExtended linear linked list storage representations and pictures\n\n```cpp\n// Extended linear linked list storage representation of generalized tables\ntypedef enum {ATOM, LIST} ElemTag;\n// ATOM == 0: atom, LIST == 1: child table\ntypedef struct GLNode1 {\n    ElemTag tag;\n    // public part, used to distinguish atomic nodes from table nodes\n    union {\n        // joint part of atomic node and table node\n        AtomType atom;  // range of atom nodes\n        struct GLNode1 *hp; // table pointer pointer\n    } a;\n    struct GLNode1 *tp;\n    // Equivalent to next of a linear linked list, pointing to the next \n} *GList1, GLNode1;\n```\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/GeneralizedList2.png)\n\n### Binary tree\n\n[BinaryTree.cpp](DataStructure/BinaryTree.cpp)\n\n#### properties\n\n1. Up to 2<sup>(i-1)</sup> nodes at the i-th level of a non-empty binary tree (i> = 1)\n2. Binary tree with depth k up to 2<sup>k</sup>-1 node (k >= 1)\n3. The number of nodes with degree 0 is n<sub>0</sub>, and the number of nodes with degree 2 is n<sub>2</sub>, then n<sub>0</sub> = n<sub>2</sub> + 1\n4. Full binary tree depth with n nodes k = ⌊ log <sub> 2 </ sub> (n) ⌋ + 1\n5. For the node numbered i (1 <= i <= n) in a complete binary tree with n nodes\n     1. If i = 1, it is the root, otherwise the parents are ⌊ i / 2 ⌋\n     2. If 2i > n, node i has no left child, otherwise the child number is 2i\n     3. If 2i + 1> n, the i node has no right child, otherwise the child number is 2i + 1\n\n#### Storage structure\n\nBinary tree data structure\n\n```cpp\ntypedef struct BiTNode\n{\n    TElemType data;\n    struct BiTNode *lchild, *rchild;\n}BiTNode, *BiTree;\n```\n\n##### Sequential storage\n\nBinary tree sequential storage pictures\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/SqBinaryTree.png)\n\n##### Chained storage\n\nBinary tree chain store pictures\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/LinkBinaryTree.png)\n\n#### Traversal\n\n* Sequence traversal\n* In-order traversal\n* Subsequent traversals\n* Hierarchical traversal\n\n#### Categories\n\n* Full Binary Tree\n* Complete binary tree (heap)\n     * Big top heap: root> = left && root> = right\n     * Small top heap: root <= left && root <= right\n* Binary search tree (binary sort tree): left <root <right\n* Balanced binary tree (AVL tree): | Left subtree tree height-Right subtree tree height | <= 1\n* Least Imbalanced Tree: Balanced Binary Tree Inserting New Nodes Causes Imbalanced Subtree: Adjustment:\n     * LL type: left-handed child of the root\n     * RR type: right child of the root\n     * LR type: Left-handed child of the root, left-handed\n     * RL type: Left child of right child, turn right first, then left\n\n### Other trees and forests\n\n#### The storage structure of the tree\n\n* Parental notation\n* Parental notation\n* Child brother notation\n\n#### And check\n\nA set of disjoint subsets S = {S1, S2, ..., Sn}\n\n#### Balanced Binary Tree (AVL Tree)\n\n##### nature\n\n* | Left Subtree Tree Height-Right Subtree Tree Height | <= 1\n* A balanced binary tree must be a binary search tree, otherwise it is not necessarily\n* The formula of the nodes of the minimum binary balanced tree: `F(n) = F(n-1) + F(n-2) + 1` (1 is the root node, F (n-1) is the left subtree Number of nodes, F (n-2) is the number of nodes in the right subtree)\n\nBalanced binary tree pictures\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/Self-balancingBinarySearchTree.png)\n\n##### Minimal Imbalance Tree\n\nBalanced binary tree inserting new nodes causes unbalanced subtrees\n\nAdjustment:\n\n* LL type: left child of the root\n* RR type: right child of the root\n* LR type: Left-handed child of the root, left-handed, then right-handed\n* RL type: Left child of right child, right-handed first, then left-handed\n\n#### Red black tree\n\n[RedBlackTree.cpp](DataStructure/RedBlackTree.cpp)\n\n##### What are the characteristics of red-black trees?\n\n1. The nodes are red or black.\n2. The root is black.\n3. All leaves are black (the leaves are NIL nodes).\n4. Each red node must have two black child nodes. (There cannot be two consecutive red nodes on all paths from each leaf to the root.) (The parent node of the new node must be the same)\n5. All simple paths from any node to each of its leaves contain the same number of black nodes. (New nodes must be red)\n\n##### Adjustment\n\nDiscoloration\nLeft\nRight turn\n\n##### Application\n\n* Associative arrays: such as map, set in STL\n\n##### What is the difference between red and black trees, B trees, and B + trees?\n\n* The depth of the red-black tree is larger, while the depth of the B-tree and B + -tree is relatively smaller\n* B + trees store data in leaf nodes, and connect them together in the form of linked lists.\n\n#### B-tree, B + -tree\n\nB-tree, B+-tree pictures\n\n![B tree (B-tree), B+ tree (B+-tree)](https://i.stack.imgur.com/l6UyF.png)\n\n##### Features\n\n* Generalized binary search tree\n* \"Puffy\", internal (non-leaf) nodes can have a variable number of child nodes (the number range is predefined)\n\n##### Application\n\n* Most file systems and database systems use B-trees and B + trees as index structures\n\n##### the difference\n\n* Only leaf nodes in the B + tree will have pointers to records (ROWID), while all nodes in the B-tree will have, and the index items appearing in the internal nodes will no longer appear in the leaf nodes.\n* All leaf nodes in the B + tree are connected by pointers, while the B tree does not.\n\n##### Advantages of B-tree\n\nThe data at the internal nodes can be obtained directly without having to locate according to the leaf nodes.\n\n##### Advantages of B + trees\n\n* Non-leaf nodes do not carry ROWID. In this way, more index entries can be accommodated in a block. One is to reduce the height of the tree. The second is that an internal node can locate more leaf nodes.\n* The leaf nodes are connected by pointers. The range scan will be very simple. For the B-tree, the leaf nodes and internal nodes need to be moved back and forth continuously.\n\n> The difference between B-tree and B + -tree comes from：[differences-between-b-trees-and-b-trees](https://stackoverflow.com/questions/870218/differences-between-b-trees-and-b-trees)、[Difference between B-tree and B + tree](https://www.cnblogs.com/ivictor/p/5849061.html)\n\n#### Octree\n\nOctree picture\n\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Octree2.png/400px-Octree2.png)\n\nAn octree is a tree-like data structure used to describe three-dimensional space (dividing space). Each node of the octree represents a volume element of a cube, and each node has eight child nodes. The volume elements represented by the eight child nodes are added together to equal the volume of the parent node. The general center point is used as the bifurcation center of the node.\n\n##### Purpose\n\n* 3D computer graphics\n* Nearest Search\n\n<a id=\"algorithm\"></a>\n\n## ⚡️ Algorithm\n\n### Sort\n\nSorting Algorithm | Average Time Complexity | Worst Time Complexity | Spatial Complexity | Data Object Stability\n---|---|---|---|---\n[Bubble Sort](Algorithm/BubbleSort.h) | O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|Stable\n[Selection Sort](Algorithm/SelectionSort.h) | O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|The array is unstable and the linked list is stable\n[Insert Sort](Algorithm/InsertSort.h) | O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|Stable\n[Quick Sort](Algorithm/QuickSort.h) | O(n*log<sub>2</sub>n) |  O(n<sup>2</sup>) | O(log<sub>2</sub>n) | Unstable\n[Heap Sort](Algorithm/HeapSort.cpp) | O(n*log<sub>2</sub>n)|O(n*log<sub>2</sub>n)|O(1)|Unstable\n[Merge Sort](Algorithm/MergeSort.h) | O(n*log<sub>2</sub>n) | O(n*log<sub>2</sub>n)|O(n)| Stable\n[Shell Sort](Algorithm/ShellSort.h) | O(n*log<sup>2</sup>n)|O(n<sup>2</sup>)|O(1)|Unstable\n[Count Sort](Algorithm/CountSort.cpp) | O(n+m)|O(n+m)|O(n+m)|Stable\n[Bucket Sort](Algorithm/BucketSort.cpp) | O(n)|O(n)|O(m)|Stable\n[Radix Sort](Algorithm/RadixSort.h) | O(k*n)|O(n<sup>2</sup>)| |Stable\n\n> * Are arranged in ascending order\n> * k: represents the number of \"digits\" in the value\n> * n: represents the size of the data\n> * m: represents the maximum value minus the minimum value of the data\n> * From: [wikipedia. Sorting Algorithm](https://en.wikipedia.org/wiki/Sorting_algorithm)\n\n### Find\n\nFind Algorithm | Average Time Complexity | Spatial Complexity | Find Conditions\n---|---|---|---\n[SequentialSearch](Algorithm/SequentialSearch.h) | O(n) | O(1) | sorted or unsorted\n[Binary search (half search)](Algorithm/BinarySearch.h) | O(log<sub>2</sub>n)| O(1) | sorted\n[Insertion Search](Algorithm/InsertionSearch.h) | O(log<sub>2</sub>(log<sub>2</sub>n)) | O(1) | sorted\n[Fibonacci Search](Algorithm/FibonacciSearch.cpp) | O(log<sub>2</sub>n) | O(1) | soted\n[Hash Table](DataStructure/HashTable.cpp) | O(1) | O(n) | sorted or unsorted\n[Binary Search Tree (BST Search)](Algorithm/BSTSearch.h) |O(log<sub>2</sub>n) |   | \n[Red Black Tree](DataStructure/RedBlackTree.cpp) |O(log<sub>2</sub>n) | |\n2-3 Tree | O(log<sub>2</sub>n - log<sub>3</sub>n) |   | \nB Tree/B+ Tree |O(log<sub>2</sub>n) |   | \n\n### Graph search algorithm\n\nGraph Search Algorithm | Data Structure | Traversal Time Complexity | Spatial Complexity\n---|---|---|---\n[BFS - Breadth First Search](https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)|adjacency matrix <br/> adjacency list |O(\\|v\\|<sup>2</sup>)<br/>O(\\|v\\|+\\|E\\|)|O(\\|v\\|<sup>2</sup>)<br/>O(\\|v\\|+\\|E\\|)\n[DFS - Depth-First Search](https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)| adjacency matrix <br/> adjacent linked list |O(\\|v\\|<sup>2</sup>)<br/>O(\\|v\\|+\\|E\\|)|O(\\|v\\|<sup>2</sup>)<br/>O(\\|v\\|+\\|E\\|)\n\n### Other algorithms\n\nAlgorithms | Ideas | Applications\n--- | --- | ---\n[Divide and Conquer](https://en.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95) | Divide a complex problem into two or more The same or similar sub-problems, until the last sub-problem can be simply and directly solved, the solution of the original problem is the combination of the solutions of the sub-problems | [loop schedule problem](https://github.com/huihut/interview/tree/master/Problems/RoundRobinProblem), sorting algorithms (quick sort, merge sort)\n[Dynamic Programming](https://en.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92) | By decomposing the original problem into relative Simple sub-question way to solve complex problems, suitable for problems with overlapping sub-problems and optimal sub-structure properties | [knapsack problem] KnapsackProblem), Fibonacci sequence\n[Greedy method](https://en.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95) | A kind of choice is taken in the current state in each step The best or optimal (that is, the most advantageous) choice, so that the result is the best or optimal algorithm | Travel Salesman Problem (Shortest Path Problem), Minimum Spanning Tree, Huffman Coding\n\n<a id=\"problems\"></a>\n\n## ❓ Problems\n\n### Single Problem\n\n* [Chessboard Coverage Problem (Checkerboard coverage problem)](Problems/ChessboardCoverageProblem)\n* [Knapsack Problem](Problems/KnapsackProblem)\n* [Neumann Neighbor Problem](Problems/NeumannNeighborProblem)\n* [Round Robin Problem](Problems/RoundRobinProblem)\n* [Tubing Problem](Problems/TubingProblem)\n\n### Leetcode Problems\n\n* [Github . haoel/leetcode](https://github.com/haoel/leetcode)\n* [Github . pezy/LeetCode](https://github.com/pezy/LeetCode)\n\n### Sword Finger Offer\n\n* [Github . zhedahht/CodingInterviewChinese2](https://github.com/zhedahht/CodingInterviewChinese2)\n* [Github . gatieme/CodingInterviews](https://github.com/gatieme/CodingInterviews)\n\n### Cracking the Coding Interview (Programmer Interview Gold)\n\n* [Github . careercup/ctci](https://github.com/careercup/ctci)\n* [Niu Ke. Programmer interview golden code](https://www.nowcoder.com/ta/cracking-the-coding-interview)\n\n### Niu Ke\n\n* [Niu Ke . Online programming topics](https://www.nowcoder.com/activity/oj)\n\n<a id=\"os\"></a>\n\n## 💻 Operating system\n\n### Processes and threads\n\nFor threaded systems:\n* Processes are independent units of resource allocation\n* Thread is an independent unit of resource scheduling\n\nFor non-threaded systems:\n* Process is an independent unit of resource scheduling and allocation\n\n#### Communication between processes and advantages and disadvantages\n\n* Pipeline (PIPE)\n    * Famous Pipeline: A half-duplex communication method that allows communication between unrelated processes\n        * Advantages: can achieve inter-process communication in any relationship\n        * Disadvantages:\n            1. Long-term storage in the system, improper use is prone to errors\n            Limited buffer\n    * Unnamed pipe: a half-duplex communication method that can only be used between processes with parental relationships (parent-child processes)\n        * Advantages: simple and convenient\n        * Disadvantages:\n            Limited to one-way communication\n            2. Can only be created between its processes and their related processes\n            3. Limited buffer\n* Semaphore: a counter that can be used to control access to shared resources by multiple threads\n    * Advantages: can synchronize processes\n    * Disadvantage: limited semaphore\n* Signal (Signal): a more complex communication method used to notify the receiving process that an event has occurred\n* Message Queue: a linked list of messages, stored in the kernel and identified by the message queue identifier\n    * Advantages: can achieve communication between any process, and achieve synchronization between message sending and receiving through system call functions, no need to consider synchronization issues, convenient\n    * Disadvantages: Copying information requires additional CPU time, which is not suitable for situations with large amounts of information or frequent operations\n* Shared Memory: Maps a piece of memory that can be accessed by other processes. This shared memory is created by one process, but can be accessed by multiple processes.\n    * Advantages: no need to copy, fast, large amount of information\n    * Disadvantages:\n        1. Communication is achieved by directly attaching the shared space buffer to the virtual address space of the process, so the synchronization of read and write operations between processes\n        2. Use the memory buffer to directly exchange information. The entity of memory exists in the computer and can only be shared with many processes in a computer system, which is not convenient for network communication.\n* Socket (Socket): can be used for process communication between different computers\n    * Advantages:\n        1. The transmission data is byte level, the transmission data can be customized, the data volume is small and the efficiency is high\n        2. Short data transmission time and high performance\n        3. Suitable for real-time information exchange between client and server\n        4. Can be encrypted, strong data security\n    * Disadvantages: The transmitted data needs to be parsed and converted into application-level data.\n\n#### Communication between threads\n\n* Locking mechanism: including mutex, reader-writer lock, spin lock, and condition\n    * Mutex (mutex): Provides an exclusive way to prevent data structures from being modified concurrently.\n    * Reader-writer lock: Allow multiple threads to read shared data at the same time, and are mutually exclusive for write operations.\n    * Spin locks are similar to mutex locks in order to protect shared resources. The mutex is when the resource is occupied and the applicant goes to sleep; the spin lock circularly detects whether the holder has released the lock.\n    * Condition variable (condition): you can atomically block the process until a certain condition is true. Testing of conditions is performed under the protection of a mutex. Condition variables are always used with a mutex.\n* Semaphore mechanism\n    * Unknown thread semaphore\n    * Named thread semaphore\n* Signal mechanism (Signal): similar to signal processing between processes\n* Barrier: A barrier allows each thread to wait until all cooperating threads reach a certain point, and then continue execution from that point.\n\nThe purpose of communication between threads is mainly for thread synchronization, so threads have no communication mechanism for data exchange like in process communication.\n\n> The communication methods between processes and their advantages and disadvantages come from: [Process thread interview question summary](http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977)\n\n#### Private and shared resources between processes\n\n* Private: address space, heap, global variables, stack, registers\n* Share: code snippet, public data, process directory, process ID\n\n#### Private and shared resources between threads\n\n* Private: thread stack, register, program counter\n* Shared: heap, address space, global variables, static variables\n\n#### Comparison, advantages and disadvantages of multi-process and multi-thread\n\n##### Compared\n\nContrast Dimensions | Multi-Process | Multi-Threaded | Summary\n--- | --- | --- | ---\nData sharing and synchronization | Complex data sharing requires IPC; data is separate and easy to synchronize | Because process data is shared, data sharing is simple, but it is also because of this reason that synchronization is complicated | Each advantage\nMemory, CPU | Occupies more memory, complex switching, low CPU utilization | Less memory, simple switching, high CPU utilization | Threads dominate\nCreate destroy, switch | create destroy, switch complex, slow speed | create destroy, switch simple, fast speed | thread dominant\nProgramming, debugging | simple programming, simple debugging | complex programming, complex debugging | process dominates\nReliability | Processes will not affect each other | Hanging a thread will cause the entire process to hang | Process dominance\nDistributed | Applicable to multi-core, multi-machine distributed; if one machine is not enough, it is relatively simple to expand to multiple machines | adapted to multi-core distributed | process dominant\n\n##### Pros and cons\n\nPros and cons | multi-process | multi-threaded\n--- | --- | ---\nAdvantages | Simple programming and debugging, high reliability | Fast creation, destruction, switching, small memory and resource occupation\nDisadvantages | Creating, destroying, slow switching, large memory and resource occupation | Complex programming and debugging, poor reliability\n\n##### Select\n\n* Need to frequently create and destroy priority threads\n* Priority threads that require a lot of calculations\n* Strongly related processing threads, weakly related processing processes\n* May be extended to multi-machine distributed processes, multi-core distributed threads\n* When all meet the needs, use the method you are most familiar with\n\n> The comparison, advantages and disadvantages of multi-process and multi-thread come from: [multi-thread or multi-process selection and difference](https://blog.csdn.net/lishenglong666/article/details/8557215)\n\n### Linux kernel synchronization\n\n#### the reason\n\nIn modern operating systems, there may be multiple kernel execution streams executing at the same time, so the kernel actually needs some synchronization mechanism to synchronize the access of the execution units to shared data like multi-process and multi-thread programming. Especially on multiprocessor systems, some synchronization mechanisms are needed to synchronize the access of the execution units on different processors to shared data.\n\n#### Synchronously\n\n* Atomic operations\n* Semaphore\n* Read and write semaphore (rw_semaphore)\n* Spinlock\n* Big Kernel Lock (BKL, Big Kernel Lock)\n* Read-write lock (rwlock)\n* Brlock-Big Reader Lock\n* Read-Copy Update (RCU, Read-Copy Update)\n* Sequence lock (seqlock)\n\n> From: [Linux kernel synchronization mechanism, Part 1](https://www.ibm.com/developerworks/cn/linux/l-synch/part1/), [Linux kernel synchronization mechanism, Part 2](https://www.ibm.com/developerworks/cn/linux/l-synch/part2/)\n\n### Deadlock\n\n#### Reasons\n\n* Insufficient system resources\n* Improper allocation of resources\n* The progress order of the process operation is not suitable\n\n#### Generate conditions\n\n* Mutex\n* Request and hold\n* Not deprived\n* Loop\n\n#### Prevention\n\n* Breaking mutually exclusive conditions: transforming exclusive resources into virtual resources, most of which cannot be transformed.\n* Break the non-preemption condition: when a process occupies an exclusive resource and then applies for an exclusive resource that cannot be met, it will withdraw from the original resource.\n* Break possession and apply conditions: Adopt a resource pre-allocation strategy, that is, apply for all resources before the process runs, run if it meets, or wait, so that it will not be occupied and applied.\n* Break the loop waiting condition: implement the orderly allocation of resources, implement classification numbers for all devices, and all processes can only apply for resources in the form of increasing numbers.\n* Ordered resource allocation method\n* Banker Algorithm\n\n### File system\n\n* Windows: FCB table + FAT + bitmap\n* Unix: inode + mixed index + group link\n\n### Host byte order and network byte order\n\n#### Host Endianness (CPU Endianness)\n\n##### Concept\n\nThe host byte order is also called the CPU byte order. It is not determined by the operating system, but by the CPU instruction set architecture. There are two types of host byte order:\n\n* Big Endian: The high-order byte is stored in the low-order address, and the low-order byte is stored in the high-order address\n* Little Endian: The high-order byte is stored in the high-order address, and the low-order byte is stored in the low-order address.\n\n##### Storage method\n\nThe 32-bit integer `0x12345678` is stored from the address starting at` 0x00`, then:\n\nMemory address | 0x00 | 0x01 | 0x02 | 0x03\n--- | --- | --- | --- | ---\nBig Endian | 12 | 34 | 56 | 78\nLittle Endian | 78 | 56 | 34 | 12\n\nBig-endian little-endian pictures\n\n![Big endian](https://raw.githubusercontent.com/huihut/interview/master/images/CPU-Big-Endian.svg.png)\n![Little endian](https://raw.githubusercontent.com/huihut/interview/master/images/CPU-Little-Endian.svg.png)\n\n##### Judging big-endian little-endian\n\nJudge big-endian little-endian\n\nYou can determine whether your CPU byte order is big-endian or little-endian:\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint i = 0x12345678;\n\n\tif (*((char*)&i) == 0x12)\n\t\tcout << \"Big endian\" << endl;\n\telse\t\n\t\tcout << \"Little endian\" << endl;\n\n\treturn 0;\n}\n```\n\n##### Byte order of each architecture processor\n\n* x86 (Intel, AMD), MOS Technology 6502, Z80, VAX, PDP-11 and other processors are little-endian;\n* Motorola 6800, Motorola 68000, PowerPC 970, System/370, SPARC (except V9) processors are big-endian;\n* The endianness of ARM (default little-endian), PowerPC (except PowerPC 970), DEC Alpha, SPARC V9, MIPS, PA-RISC, and IA64 are configurable.\n\n#### Network byte order\n\nNetwork byte order is a data representation format specified in TCP/IP. It has nothing to do with the specific CPU type, operating system, etc., so that it can ensure that the data can be correctly interpreted when transmitted between different hosts.\n\nThe network byte order uses: Big Endian arrangement.\n\n### Page replacement algorithm\n\nDuring the address mapping process, if a page to be accessed is found not to be in memory, a page fault interrupt is generated. When a page fault occurs, if there is no free page in the operating system memory, the operating system must select a page in memory to move it out of memory in order to make room for the page that is about to be paged in. The rules used to select which pages to eliminate are called page replacement algorithms.\n\n#### Categories\n\n* Global replacement: replacement in the entire memory space\n* Partial replacement: Replace in this process\n\n#### Algorithm\n\nGlobal:\n* Working set algorithm\n* Page rate replacement algorithm\n\nPartially:\n* Optimal Replacement Algorithm (OPT)\n* First in, first out replacement algorithm (FIFO)\n* Least Recently Used (LRU) Algorithm\n* Clock replacement algorithm\n\n<a id=\"computer-network\"></a>\n\n## ☁️ Computer Network\n\n> Some of the knowledge in this section comes from Computer Networking (7th Edition)\n\nComputer network architecture:\n\n![Computer Network Architecture](https://raw.githubusercontent.com/huihut/interview/master/images/计算机网络体系结构.png)\n\n### Roles and protocols of each layer\n\nLayered | role | protocol\n--- | --- | ---\nPhysical layer | Transmission of bits through the medium, determination of mechanical and electrical specifications (bits) | RJ45, CLOCK, IEEE802.3 (repeaters, hubs)\nData link layer | Assemble bits into frames and point-to-point delivery (Frame) | PPP, FR, HDLC, VLAN, MAC (bridge, switch)\nNetwork layer | Responsible for the transmission of data packets from source to sink and Internet interconnection (packets) | IP, ICMP, ARP, RARP, OSPF, IPX, RIP, IGRP (router)\nTransport layer | Provide end-to-end reliable message delivery and error recovery (Segment) | TCP, UDP, SPX\nSession layer | Establishing, managing, and terminating sessions (session protocol data unit SPDU) | NFS, SQL, NETBIOS, RPC\nPresentation Layer | Translate, Encrypt, and Compress Data (Representation Protocol Data Unit PPDU) | JPEG, MPEG, ASII\nApplication layer | A means to allow access to the OSI environment (Application Protocol Data Unit APDU) | FTP, DNS, Telnet, SMTP, HTTP, WWW, NFS\n\n\n### Physical layer\n\n* Unit of transmitted data: bit\n* Data transmission system: source system (source point, sender)-> transmission system-> destination system (receiver, destination)\n\naisle:\n* Unidirectional channel (simplex channel): only one direction communication, no reverse direction interaction, such as broadcasting\n* Two-way alternate communication (half-duplex communication): both parties of the communication can send messages, but cannot send or receive at the same time\n* Two-way simultaneous communication (full-duplex communication): both parties of the communication can send and receive information at the same time\n\nChannel multiplexing technology:\n* Frequency division multiplexing (FDM, Frequency Division Multiplexing): different users in different frequency bands, users use different bandwidth resources at the same time\n* Time Division Multiplexing (TDM): different users in different time slices in the same time period, all users occupy the same bandwidth at different times\n* Wavelength Division Multiplexing (WDM): Frequency division multiplexing of light\n* Code Division Multiplexing (CDM): Different users use different codes and can use the same frequency band for communication at the same time\n\n### data link layer\n\nMain channel:\n* Point-to-point channel\n* Broadcast channel\n\n#### Point-to-point channel\n\n* Data unit: frame\n\nThree basic questions:\n* Encapsulation: Encapsulate IP datagrams at the network layer into frames, `SOH-data part-EOT`\n* Transparent transmission: No matter what characters in the data part, it can be transmitted; it can be solved by byte padding method (escaping characters before conflicting characters)\n* Error detection: reduce bit error rate (BER), widely use cyclic redundancy check (CRC, Cyclic Redundancy Check)\n\nPoint-to-Point Protocol:\n* Point-to-Point Protocol: The protocol used by the user computer to communicate with the ISP\n\n#### Broadcast Channel\n\nBroadcast communication:\n* Hardware address (physical address, MAC address)\n* Unicast frame (one-to-one): The MAC address of the received frame is the same as the hardware address of this station\n* Broadcast frame (one pair): frame sent to all stations on the local area network\n* Multicast frame (one-to-many): frame sent to some sites on the local area network\n\n### Network layer\n\n* IP (Internet Protocol, Internet Protocol) is a protocol designed for computer networks to communicate with each other.\n* ARP (Address Resolution Protocol, Address Resolution Protocol)\n* ICMP (Internet Control Message Protocol, Internet Control Message Protocol)\n* IGMP (Internet Group Management Protocol, Internet Group Management Protocol)\n\n#### IP Internet Protocol\n\nIP address classification:\n* `IP address ::= (<network number>, <host number>)`\n\nIP address category | network number | network range | host number | IP address range\n--- | --- | --- | --- | ---\nClass A | 8bit, the first bit is fixed at 0 | 0 —— 127 | 24bit | 1.0.0.0 —— 127.255.255.255\nClass B | 16bit, the first two bits are fixed at 10 | 128.0 —— 191.255 | 16bit | 128.0.0.0 —— 191.255.255.255\nClass C | 24bit, the first three bits are fixed at 110 | 192.0.0 —— 223.255.255 | 8bit | 192.0.0.0 —— 223.255.255.255\nClass D | The first four bits are fixed at 1110, followed by the multicast address\nClass E | The first five digits are fixed at 11110, the latter are reserved for future use\n\nIP datagram format:\n\n![IP 数据报格式](https://raw.githubusercontent.com/huihut/interview/master/images/IP数据报格式.png)\n\n#### ICMP Internet Control Message Protocol\n\nICMP message format:\n\n![ICMP message format](https://raw.githubusercontent.com/huihut/interview/master/images/ICMP报文格式.png)\n\napplication:\n* PING (Packet InterNet Groper) to test connectivity between two hosts\n* TTL (Time To Live, time to live) This field specifies the maximum number of network segments that IP packets are allowed to pass before being dropped by the router.\n\n#### Interior Gateway Protocol\n\n* RIP (Routing Information Protocol, Routing Information Protocol)\n* OSPF (Open Sortest Path First)\n\n#### External gateway protocol\n\n* BGP (Border Gateway Protocol, Border Gateway Protocol)\n\n#### IP multicast\n\n* IGMP (Internet Group Management Protocol, Internet Group Management Protocol)\n* Multicast routing protocol\n\n#### VPN and NAT\n\n* VPN (Virtual Private Network)\n* NAT (Network Address Translation, Network Address Translation)\n\n#### What does the routing table contain?\n\n1. Network ID (Network ID): It is the network ID of the destination address.\n2. Subnet mask: used to determine the network to which the IP belongs\n3. Next hop address / interface: It is the address of the next stop of the data on the journey sent to the destination address. Where interface points to the next hop (that is, the next route). The route in an autonomous system (AS) should contain all subnets in the area, and the default gateway (Network id: `0.0.0.0`, Netmask:` 0.0.0.0`) points to the exit of the autonomous system.\n\nDepending on the application and implementation, the routing table may contain the following additional information:\n\n1. Cost: It is the cost required to pass the path during data transmission.\n2. Quality of service for routing\n3. List of inbound / outbound connections to be filtered in the route\n\n### Transport layer\n\nprotocol:\n\n* TCP (Transmission Control Protocol)\n* UDP (User Datagram Protocol, User Datagram Protocol)\n\nport:\n\nApplications | FTP | TELNET | SMTP | DNS | TFTP | HTTP | HTTPS | SNMP\n--- | --- | --- | --- | --- | --- | --- | --- | ---\nPort number | 21 | 23 | 25 | 53 | 69 | 80 | 443 | 161\n\n#### TCP\n\n* TCP (Transmission Control Protocol, Transmission Control Protocol) is a connection-oriented, reliable, byte stream-based transport layer communication protocol, and its transmission unit is a message segment.\n\nFeature:\n* Connection oriented\n* Only point-to-point (one-to-one) communication\n* Reliable interaction\n* Full-duplex communication\n* Byte stream oriented\n\nHow TCP guarantees reliable transmission:\n* Confirmation and timeout retransmission\n* Reasonable fragmentation and ordering of data\n* flow control\n* Congestion control\n* Data validation\n\nTCP message structure\n\n![TCP Message](https://raw.githubusercontent.com/huihut/interview/master/images/TCP报文.png)\n\nTCP header\n\n![TCP header](https://raw.githubusercontent.com/huihut/interview/master/images/TCP首部.png)\n\nTCP: Status Control Code (Code, Control Flag), which takes 6 bits and has the following meaning:\n* URG: Urgent. When `URG = 1` , it indicates that the urgent pointer field is valid, which means that the packet is an urgent packet. It tells the system that there is urgent data in this segment and it should be transmitted as soon as possible (equivalent to high-priority data), and the Urgent Pointer field in the above figure will also be enabled.\n* ACK: Acknowledge. The acknowledgment number field is valid only when `ACK = 1`, which means this packet is an acknowledgment packet. When `ACK = 0`, the confirmation number is invalid.\n* PSH: (Push function) If it is 1, the representative requires the other party to immediately transmit other corresponding packets in the buffer, without waiting for the buffer to be full before sending.\n* RST: Reset bit (Reset). When `RST = 1`, it indicates that a serious error occurred in the TCP connection (such as due to a host crash or other reasons). You must release the connection and then re-establish the transport connection.\n* SYN: Synchronous. When SYN is set to 1, it indicates that this is a connection request or connection acceptance message. Usually, the packet with the SYN flag indicates that \"active\" wants to connect to the other party.\n* FIN: Final bit, used to release a connection. When `FIN = 1`, it means that the data of the sending end of this segment has been sent, and it is required to release the transport connection.\n\n#### UDP\n\n* UDP (User Datagram Protocol, User Datagram Protocol) is a connectionless transport layer protocol in the OSI (Open System Interconnection) reference model, which provides a simple and unreliable information transfer service oriented to transactions, and its transmission unit Is a user datagram.\n\nfeature:\n* no connection\n* Best efforts to deliver\n* Message-oriented\n* No congestion control\n* Supports one-to-one, one-to-many, many-to-one, and many-to-many interactive communication\n* Small overhead\n\nUDP message structure\n\n![UDP 报文](https://raw.githubusercontent.com/huihut/interview/master/images/UDP报文.png)\n\nUDP 首部\n\n![UDP 首部](https://raw.githubusercontent.com/huihut/interview/master/images/UDP首部.png)\n\n> TCP/UDP Pictures from <https://github.com/JerryC8080/understand-tcp-udp>\n\n#### Difference between TCP and UDP\n\n1. TCP connection-oriented, UDP is connectionless;\n2. TCP provides reliable service, that is, the data transmitted through the TCP connection is error-free, not lost, not duplicated, and arrives in order; UDP does its best to deliver, that is, it does not guarantee reliable delivery\n3. TCP logical communication channel is a full-duplex reliable channel; UDP is an unreliable channel\n5. Each TCP connection can only be point-to-point; UDP supports one-to-one, one-to-many, many-to-one and many-to-many interactive communication\n6. TCP is oriented to byte streams (probably sticky packets may occur). In fact, TCP treats data as a series of unstructured byte streams; UDP is message-oriented (no sticky packets will occur)\n7. UDP has no congestion control, so congestion on the network will not reduce the sending rate of the source host (useful for real-time applications, such as IP phones, real-time video conferencing, etc.)\n8. TCP header overhead is 20 bytes; UDP header overhead is small, only 8 bytes\n\n#### TCP Sticky Packet\n\n##### the reason\n\nTCP is a byte stream-based transmission service (UDP is message-based). \"Stream\" means that the data transmitted by TCP has no boundaries. So there may be situations where two data packets stick together.\n\n##### Solve\n\n* Send fixed-length packets. If the size of each message is the same, the receiving peer only needs to accumulate the received data until the data is equal to a fixed-length value and treats it as a message.\n* Baotou plus package body length. The header is 4 bytes of fixed length, which indicates the length of the packet body. The receiving peer first receives the header length and receives the packet body according to the header length.\n* Set boundaries between packets, such as adding special symbols `\\r\\n` mark. The FTP protocol does just that. The problem is that if the data body also contains `\\r\\n` , it will be misjudged as the message boundary.\n* Use more complex application layer protocols.\n\n#### TCP Flow Control\n\n##### Concept\n\nFlow control is to make the sending rate of the sender not too fast, but to allow the receiver to receive it.\n\n##### Methods\n\nVariable window for flow control\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/利用可变窗口进行流量控制举例.png)\n\n#### TCP congestion control\n\n##### Concept\n\nCongestion control is to prevent excessive data from being injected into the network, so that the routers or links in the network will not be overloaded.\n\n##### Methods\n\n* Slow start\n* Congestion avoidance\n* Fast retransmit\n* Fast recovery\n\n\n\nTCP Congestion control graph\n\n![](https://raw.githubusercontent.com/huihut/interview/master/images/TCP拥塞窗口cwnd在拥塞控制时的变化情况.png)\n![](https://raw.githubusercontent.com/huihut/interview/master/images/快重传示意图.png)\n![](https://raw.githubusercontent.com/huihut/interview/master/images/TCP的拥塞控制流程图.png)\n\n#### TCP Transmission connection management\n\n> 因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：<https://raw.githubusercontent.com/huihut/interview/master/images/TCP-transport-connection-management.png>\n\n##### TCP 三次握手建立连接\n\n![UDP 报文](https://raw.githubusercontent.com/huihut/interview/master/images/TCP三次握手建立连接.png)\n\n【Explain the whole process of TCP connection establishment】\n\n1. The client sends a SYN to the server, indicating that the client requests to establish a connection;\n2. The server receives the SYN sent by the client and replies with SYN + ACK to the client (agreeing to establish a connection);\n3. After receiving the SYN + ACK from the server, the client responds with an ACK to the server (indicating that the client received the consent message sent by the server);\n4. The server receives the ACK from the client, the connection is established, and data transmission is possible.\n\n##### Why does TCP have to shake hands three times?\n\n【Answer One】 Because the channel is unreliable, and TCP wants to establish a reliable transmission on the unreliable channel, then three communications is the theoretical minimum. (And UDP does not need to establish a reliable transmission, so UDP does not require a three-way handshake.)\n\n> [Google Groups. Why is TCP a three-way handshake to establish a connection? {Technology} {Network Communication}](https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ)\n\n[Answer II] Because both parties need to confirm that the other party has received the serial number sent by themselves, the confirmation process requires at least three communications.\n\n> [Know. Why is TCP a three-way handshake instead of two or four? ](https://www.zhihu.com/question/24853633/answer/115173386)\n\n[Answer three] In order to prevent the invalid connection request segment from being sent to the server suddenly, an error is generated.\n\n> [\"Computer Network (7th Edition) -Xie Xiren\"](https://raw.githubusercontent.com/huihut/interview/master/images/TCP-transport-connection-management.png)\n\n##### TCP Four waves to release the connection\n\n![UDP 报文](https://raw.githubusercontent.com/huihut/interview/master/images/TCP四次挥手释放连接.png)\n\n【TCP Four waves to release the connection】\n\n1. The client sends FIN to the server, indicating that the client does not need to send data to the server (request to release the connection from the client to the server);\n2. The server receives the FIN sent by the client and replies ACK to the client (agreeing to release the connection from the client to the server);\n3. The client receives the ACK from the server, and the connection from the client to the server has been released (but the connection from the server to the client has not been released, and the client can still receive data);\n4. The server continues to send the unfinished data to the client;\n5. The server sends FIN + ACK to the client, indicating that the server has sent the data (request to release the connection from the server to the client, even if no reply is received from the client, it will be automatically released after a certain period of time);\n6. The client receives the FIN + ACK from the server and replies to the server with an ACK (agreeing to release the connection from the server to the client);\n7. After receiving the ACK from the client, the server releases the connection from the server to the client.\n\n##### Why does TCP have to wave four times?\n\n[Question 1] Why does TCP wave four times? / Why does TCP need three times to establish a connection and four times to release a connection?\n\n[Answer One] Because TCP is in full-duplex mode, after the client requests to close the connection, the connection from the client to the server is closed (one or two waves), and the server continues to transmit the data that has not been previously transmitted to the client (data transmission) , The connection from the server to the client is closed (waving three or four times). Therefore, when TCP releases the connection, the server's ACK and FIN are sent separately (with data transmission in between), and when the TCP establishes the connection, the server's ACK and SYN are sent together (second handshake), so TCP needs to establish the connection three times. It takes four times to release the connection.\n\n[Question 2] Why can ACK and SYN be sent together when TCP is connected, and ACK and FIN are sent separately when released? (ACK and FIN refer to the second and third wave)\n\n[Answer 2:] When the client requests the release, the server may still have data to transmit to the client, so the server must respond to the client FIN request (the server sends an ACK), and then the data is transmitted. After the transmission is completed, the server then Make a FIN request (the server sends FIN); there is no intermediate data transmission when connecting, so ACK and SYN can be sent together when connecting.\n\n[Question three] Why does the client need TIME-WAIT to wait for 2MSL at the end?\n\n【Answer three】\n\n1. In order to ensure that the last ACK message sent by the client can reach the server. If it fails to arrive, the server will retransmit the FIN + ACK segment overtime, and the client will retransmit the ACK and re-time.\n2. Prevent invalid connection request segments from appearing in this connection. When TIME-WAIT lasts 2MSL, all the segments generated during the duration of this connection will disappear from the network, so that the old connection segments will not appear in the next connection.\n\n#### TCP finite state machine\n\nTCP finite state machine picture\n\n![TCP Finite state machine](https://raw.githubusercontent.com/huihut/interview/master/images/TCP的有限状态机.png)\n\n### Application layer\n\n#### DNS\n\n* DNS (Domain Name System) is a service of the Internet. It serves as a distributed database that maps domain names and IP addresses to each other, enabling people to access the Internet more conveniently. DNS uses TCP and UDP port 53. Currently, the limit for the length of each domain name is 63 characters, and the total length of the domain name cannot exceed 253 characters.\n\ndomain name:\n* `Domain name :: = {<third-level domain name>.<Second-level domain name>.<Top-level domain name>}`, for example: `blog.huihut.com`\n\n#### FTP\n\n* FTP (File Transfer Protocol, file transfer protocol) is a set of standard protocols for file transfer on the network, using the client / server model, using TCP datagrams, providing interactive access, two-way transmission.\n* TFTP (Trivial File Transfer Protocol) is a small and easy-to-implement file transfer protocol. It also uses the client-server method and uses UDP datagrams. It only supports file transfers and does not support interaction. User authentication\n\n#### TELNET\n\n* The TELNET protocol is a member of the TCP / IP protocol family and is the standard protocol and main method of the Internet remote login service. It provides users with the ability to complete remote host work on the local computer.\n\n* HTTP (HyperText Transfer Protocol) is a transfer protocol used to transfer hypertext from a WWW (World Wide Web, World Wide Web) server to a local browser.\n\n* SMTP (Simple Mail Transfer Protocol) is a set of rules for transferring mail from the source address to the destination address, which controls the transfer method of the letter. The SMTP protocol belongs to the TCP / IP protocol suite, which helps each computer find the next destination when sending or transferring letters.\n* Socket requires at least a pair of port numbers (Socket) to establish a network communication connection. Socket is essentially a programming interface (API), which encapsulates TCP / IP. TCP / IP also provides an interface that programmers can use for network development. This is the Socket programming interface.\n\n#### WWW\n\n* WWW (World Wide Web, World Wide Web, World Wide Web) is a system composed of many hypertext links to each other, accessed via the Internet\n\n##### URL\n\n* URL (Uniform Resource Locator) is a standard resource address (Address) on the Internet\n\nstandard format:\n\n* `Protocol type: [// server address [: port number]] [/ resource level UNIX file path] file name [? Query] [# Clip ID]`\n    \nComplete format:\n\n* `Protocol type: [// [Credential information required to access resources @] server address [: port number]] [/ resource level UNIX file path] file name [? Query] [# segment ID]`\n\n> Among them [access credential information @ ;: port number ;? query; #fragment ID] are all optional items\n> For example: `https://github.com/huihut/interview#cc`\n\n##### HTTP\n\nHypertext Transfer Protocol (HTTP) is an application-layer protocol for distributed, collaborative, and hypermedia information systems. HTTP is the foundation of data communication for the World Wide Web.\n\nRequest method\n\nMethod | meaning\n--- | ---\nOPTIONS | Request some option information to allow clients to view server performance\nGET | Request the specified page information and return the entity body\nHEAD | Similar to a get request, except that there is no specific content in the returned response, which is used to get the header\nPOST | Submits data to a specified resource for processing requests (such as submitting a form or uploading a file). The data is contained in the request body. POST requests may result in the creation of new resources and / or modification of existing resources\nPUT | Data transmitted from the client to the server replaces the contents of the specified document\nDELETE | request the server to delete the specified page\nTRACE | echo requests received by the server, mainly for testing or diagnostics\n\nStatus Code\n\n* 1xx: indicates notification information, such as the request has been received or is being processed\n    * 100 Continue: Continue, the client should continue its request\n    * 101 Switching Protocols. The server switches protocols according to the client's request. Can only switch to higher-level protocols, for example, to new versions of HTTP\n* 2xx: indicates success, such as receiving or knowing\n    * 200 OK: The request was successful\n* 3xx: indicates a redirect, and further action is required to complete the request\n    * 301 Moved Permanently: Move permanently. The requested resource has been permanently moved to the new URL, the returned information will include the new URL, and the browser will automatically be directed to the new URL. Any future requests should use the new URL instead\n* 4xx: indicates a customer error, such as incorrect syntax in the request or inability to complete\n    * 400 Bad Request: The client requested a syntax error that the server could not understand\n    * 401 Unauthorized: request requires user authentication\n    * 403 Forbidden: The server understood the request from the requesting client, but refused to execute the request (insufficient permissions)\n    * 404 Not Found: The server cannot find the resource (web page) based on the client's request. With this code, the website designer can set a personality page for \"the resource you requested could not be found\"\n    * 408 Request Timeout: The server waited too long for the request sent by the client, timed out\n* 5xx: indicates a server error, such as the server failing to complete the request\n    * 500 Internal Server Error: Server internal error, unable to complete request\n    * 503 Service Unavailable: Due to overload or system maintenance, the server cannot temporarily process the client's request. The length of the delay can be included in the server's Retry-After header\n    * 504 Gateway Timeout: The server acting as a gateway or proxy, not receiving requests from the remote server in a timely manner\n\n>More status codes: [Rookie Tutorials. HTTP Status Codes](http://www.runoob.com/http/http-status-codes.html)\n\n##### Other agreements\n\n* SMTP (Simple Main Transfer Protocol, Simple Mail Transfer Protocol) is a standard for transmitting Email over the Internet. It is a relatively simple text-based protocol. One or more recipients of a message are specified on top of it (confirmed to exist in most cases), and the message text is transmitted. You can easily test an SMTP server through a Telnet program. SMTP uses TCP port 25.\n* DHCP (Dynamic Host Configuration Protocol) is a network protocol for a local area network. It uses the UDP protocol to work and has two main purposes:\n    * For internal network or network service provider to automatically assign IP addresses to users\n    * For internal network administrators as a means of central management of all computers\n* SNMP (Simple Network Management Protocol) forms part of the Internet protocol family defined by the Internet Engineering Task Force (IETF). The protocol can support a network management system to monitor whether the devices connected to the network have any management concerns.\n\n<a id=\"network-programming\"></a>\n\n## 🌩 Network Programming\n\n### Socket\n\n> [Linux Socket Programming (unlimited Linux）](https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html)\n\n![Socket Client server communication](https://raw.githubusercontent.com/huihut/interview/master/images/socket客户端服务器通讯.jpg)\n\n\n#### Socket middle read()、write() function\n\n```cpp\nssize_t read(int fd, void *buf, size_t count);\nssize_t write(int fd, const void *buf, size_t count);\n```\n\n##### read()\n\n* The read function is responsible for reading content from fd.\n* When the read is successful, read returns the actual number of bytes read.\n* If the returned value is 0, it means that the end of the file has been read, and if it is less than 0, an error has occurred.\n* If the error is EINTR, the reading is caused by interruption; if it is ECONNREST, there is a problem with the network connection.\n\n##### write ()\n\n* The write function writes the contents of nbytes in buf to the file descriptor fd.\n* Returns the number of bytes written when successful. On failure, it returns -1 and sets the errno variable.\n* In network programs, there are two possibilities when we write to the socket file descriptor.\n* (1) The return value of write is greater than 0, indicating that part or all of the data has been written.\n* (2) The returned value is less than 0, and an error has occurred at this time.\n* If the error is EINTR, it indicates that an interruption error occurred during writing; if it is EPIPE, it indicates that there is a problem with the network connection (the other party has closed the connection).\n\n#### TCP three-way handshake in socket to establish connection\n\nWe know that TCP establishes a connection by performing a \"three-way handshake\", that is, exchanging three packets. The general process is as follows:\n\n1. The client sends a SYN J to the server\n2. The server responds to the client with a SYN K, and confirms SYN J ACK J + 1\n3. The client wants the server to send an acknowledgement ACK K + 1\n\nOnly the three-way handshake is finished, but what about the three-way handshake in the socket function? Please see the picture below:\n\n![socket Sent in TCP Three handshake](http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png)\n\nIt can be seen from the figure:\n1. When the client calls connect, a connection request is triggered and a SYN J packet is sent to the server. At this time, connect enters a blocking state;\n2. The server listens to the connection request, that is, receives the SYN J packet, calls the accept function to receive the request and sends SYN K and ACK J + 1 to the client, then accept enters the blocking state;\n3. After the client receives the SYN K of the server, ACK J + 1, connect returns at this time, and confirms the SYN K;\n4. When the server receives ACK K + 1, accept returns, so that the three handshake is completed and the connection is established.\n\n#### TCP four-way handshake in socket to release connection\n\nThe above describes the three-way handshake establishment process of TCP in socket and the socket functions involved. Now we introduce the process of releasing the connection by the four-way handshake in the socket, please see the following figure:\n\n![socket TCP four-way handshake sent in](http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png)\n\nThe illustrated process is as follows:\n\n1. An application process first calls close to actively close the connection, then TCP sends a FIN M;\n2. After receiving the FIN M, the other end performs a passive close to confirm the FIN. Its reception is also passed to the application process as an end-of-file character, because the reception of FIN means that the application process can no longer receive additional data on the corresponding connection;\n3. After a period of time, the application process that received the end-of-file character calls close to close its socket. This causes its TCP to also send a FIN N;\n4. The source TCP that received the FIN confirms it.\n\nSo there is a FIN and ACK in each direction.\n\n<a id=\"database\"></a>\n\n## 💾 Database\n\n> Part of the knowledge in this section comes from \"Introduction to Database Systems (5th Edition)\"\n\n### basic concepts\n\n* Data: Symbolic records describing things are called data.\n* Database (DB): It is a collection of a large amount of organized, shareable data stored in a computer for a long time, and has three basic characteristics of permanent storage, organization, and shareability.\n* Database Management System (DBMS): is a layer of data management software located between the user and the operating system.\n* Database system (DBS): is a system consisting of a database, a database management system (and its application development tools), applications, and a database administrator (DBA) to store, manage, process, and maintain data.\n* Entity: Objects that exist objectively and can be distinguished from each other are called entities.\n* Attribute: An attribute of an entity is called an attribute.\n* Key: The set of attributes that uniquely identify an entity is called a key.\n* Entity type: Use entity name and its attribute name set to abstract and characterize similar entities, called entity type.\n* Entity set: A set of the same entity type is called an entity set.\n* Relationship: The relationship between entities usually refers to the connection between different sets of entities.\n* Schema: A schema is also called a logical schema. It is a description of the logical structure and characteristics of the entire database data. It is a common data view for all users.\n* External schema: External schema is also called subschema or user schema. It is a description of the logical structure and characteristics of local data that database users (including application programmers and end users) can see and use. A database user's data view is a logical representation of data related to an application.\n* Internal schema: Internal schema is also called storage schema. A database has only one internal schema. It is a description of the physical structure and storage of the data, and the way the database is organized within the database.\n\n### Common data models\n\n* Hierarchical model\n* Network model\n* Relational model\n     * Relation (relation): a relation corresponds to a table\n     * Tuple: a row in the table is a tuple\n     * Attribute (attribute): a column in the table is an attribute\n     * Key: A certain attribute group of a tuple can be uniquely identified in the table\n     * Domain (domain): a set of values of the same data type\n     * Component: an attribute value in a tuple\n     * Relation mode: description of the relationship, generally expressed as `relation name (attribute 1, attribute 2, ..., attribute n)`\n* Object oriented data model\n* Object relational data model\n* Semistructured data model\n\n### Common SQL Operations\n\n<table>\n  <tr>\n    <th> Object type </ th>\n    <th> Object </ th>\n    <th> Type of operation </ th>\n  </ tr>\n  <tr>\n    <td rowspan = \"4\"> Database mode </ td>\n    <td> Mode </ td>\n    <td> <code> CREATE SCHEMA </ code> </ td>\n  </ tr>\n  <tr>\n    <td> Basic table </ td>\n    <td> <code> CREATE SCHEMA </ code>, <code> ALTER TABLE </ code> </ td>\n  </ tr>\n    <tr>\n    <td> View </ td>\n    <td> <code> CREATE VIEW </ code> </ td>\n  </ tr>\n    <tr>\n    <td> Index </ td>\n    <td> <code> CREATE INDEX </ code> </ td>\n  </ tr>\n    <tr>\n    <td rowspan=\"2\"> Data </ ​​td>\n    <td> Basic tables and views </ td>\n    <td> <code> SELECT </ code>, <code> INSERT </ code>, <code> UPDATE </ code>, <code> DELETE </ code>, <code> REFERENCES </ code>, <code > ALL PRIVILEGES </ code> </ td>\n  </ tr>\n    <tr>\n    <td> Attribute column </ td>\n    <td> <code> SELECT </ code>, <code> INSERT </ code>, <code> UPDATE </ code>, <code> REFERENCES </ code>, <code> ALL PRIVILEGES </ code> </ td>\n  </ tr>\n</table>\n\n> SQL Grammar Tutorial: [runoob . SQL Tutorial](http://www.runoob.com/sql/sql-tutorial.html)\n\n### Relational Database\n\n* Basic relation operations: query (selection, projection, connection (equivalent connection, natural connection, outer connection (left outer connection, right outer connection)), division, union, difference, intersection, Cartesian product, etc.), insertion, deletion ,modify\n* Three types of integrity constraints in the relationship model: entity integrity, referential integrity, user-defined integrity\n\n#### Index\n\n* Database index: sequential index, B + tree index, hash index\n* [Data structure and algorithm principle behind MySQL index](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)\n\n### Database integrity\n\n* Database integrity refers to the correctness and compatibility of data.\n    * Integrity: To prevent non-semantic (incorrect) data from the database.\n    * Security: In order to protect the database from malicious damage and illegal access.\n* Trigger: is a special event-driven process defined by the user in the relational table.\n\n### Relational data theory\n\n* Data dependency is a constraint relationship between the internal attributes and attributes of a relationship. It is a correlation between data that is reflected by the equality of the values ​​between attributes.\n* The most important data dependencies: function dependencies, multi-value dependencies.\n\n#### Paradigm\n\n* First Normal Form (1NF): The attribute (field) is the smallest unit and cannot be separated.\n* The second normal form (2NF): meet 1NF, each non-primary attribute completely depends on the primary key (eliminating the partial function dependence of 1NF non-primary attribute on the code).\n* The third normal form (3NF): 2NF is satisfied, and any non-primary attribute does not depend on other non-primary attributes (eliminating the 2NF non-primary attribute's transfer function dependence on the code).\n* Bowies-Kode Normal Form (BCNF): Satisfy 3NF, any non-primary attribute cannot depend on the subset of primary keys (eliminating the 3NF primary attribute's dependence on the code part and transfer function)\n* The fourth normal form (4NF): meet 3NF, there must be non-trivial and non-functional dependent multi-value dependencies between attributes (eliminating 3NF non-trivial and non-functional multi-value dependencies).\n\n### Database Recovery\n\n* Transaction: It is a user-defined sequence of database operations. These operations are either all done or not done at all. It is an indivisible unit of work.\n* ACID characteristics of things: atomicity, consistency, isolation, persistence.\n* Implementation technology of recovery: establish redundant data-> use redundant data to implement database recovery.\n* Common techniques for establishing redundant data: data dumps (dynamic mass dumps, dynamic incremental dumps, static mass dumps, static incremental dumps), registration log files.\n\n### Concurrency control\n\n* Transactions are the basic unit of concurrency control.\n* Data inconsistencies caused by concurrent operations include: lost modifications, non-repeatable reads, and \"dirty\" data reads.\n* The main technologies of concurrency control: blocking, timestamp, optimistic control method, multi-version concurrency control, etc.\n* Basic lock types: exclusive lock (X lock / write lock), shared lock (S lock / read lock).\n* Livelock deadlock:\n    * Livelock: The transaction is always in a waiting state, which can be avoided through a first come, first served policy.\n    * Deadlock: The transaction can never end\n        * Prevention: one-time block method, sequential block method;\n        * Diagnosis: timeout method, waiting graph method;\n        * Cancel: Undo the transaction with the least deadlock cost and release all the locks of this transaction, so that other transactions can continue to run.\n* Serializable scheduling: The concurrent execution of multiple transactions is correct if and only if the result is the same as when the transactions are executed serially in a certain order. Guidelines for correct scheduling of concurrent transactions when serializable.\n\n<a id=\"design-pattern\"></a>\n\n## 📏 Design pattern\n\n> Examples of major design patterns: [CSDN column. C ++ Design Patterns](https://blog.csdn.net/liang19890820/article/details/66974516) series of blog posts\n\n[Design Pattern Project Catalog](DesignPattern)\n\n### Singleton mode\n\n[Singleton Pattern Example](DesignPattern/SingletonPattern)\n\n### Abstract factory pattern\n\n[Abstract Factory Pattern Example](DesignPattern/AbstractFactoryPattern)\n\n### Adapter Mode\n\n[Adapter pattern example](DesignPattern/AdapterPattern)\n\n### Bridge mode\n\n[Bridge pattern example](DesignPattern/BridgePattern)\n\n### Observer mode\n\n[Example of Observer Pattern](DesignPattern/ObserverPattern)\n\n### Six Principles of Design Patterns\n\n* Single Responsibility Principle (SRP)\n* Liskov Substitution Principle (LSP)\n* Dependence Inversion Principle (DIP)\n* Interface Segregation Principle (ISP)\n* Law of Demeter (LoD)\n* Open Close Principle (OCP)\n\n<a id=\"link-loading-library\"></a>\n\n## ⚙️ Link Loading Library\n\n> Part of the knowledge in this section comes from \"Programmer's Self-Cultivation-Link Loading Library\"\n\n### memory, stack, heap\n\nThe general application memory space has the following areas:\n\n* Stack: Automatically allocated and released by the operating system, storing function parameter values, local variable values, etc., used to maintain the context of function calls\n* Heap: Generally allocated and released by the programmer. If the programmer does not release, it may be recycled by the operating system at the end of the program to accommodate the dynamically allocated memory area of ​​the application.\n* Executable image: Stores the image of the executable file in memory. Loading by the loader is to read or map the memory of the executable file here.\n* Reserved area: The reserved area is not a single memory area, but a general term for memory areas that are protected from access in the memory. For example, in C, the invalid pointer is assigned a value of 0 (NULL), so the 0 address is normal. Impossible to access data efficiently\n\n#### stack\n\nThe stack stores the maintenance information required for a function call. It is often called a stack frame or an active record. It generally contains the following aspects:\n\n* Function return address and parameters\n* Temporary variables: including non-static local variables of functions and other temporary variables automatically generated by the compiler\n* Save context: including registers that need to remain unchanged before and after function calls\n\n#### Heap\n\nHeap allocation algorithm:\n\n* Free List\n* Bitmap\n* Object pool\n\n#### \"Segment fault\" or \"Illegal operation, this memory address cannot be read / write\"\n\nErrors caused by typical illegal pointer dereferencing. This error occurs when the pointer points to a memory address that is not allowed to read and write, and the program attempts to use the pointer to read or write that address.\n\nCommon reasons:\n\n* Initialize the pointer to NULL, then start using the pointer without giving it a reasonable value\n* There is no need to initialize the pointer in the stack. The value of the pointer will generally be a random number. After that, the pointer is used directly.\n\n### Compile and link\n\n#### File formats for each platform\n\nPlatform | Executables | Objects | Dynamic Libraries / Shared Objects | Static Libraries\n---|---|---|---|---\nWindows|exe|obj|dll|lib\nUnix/Linux|ELF、out|o|so|a\nMac|Mach-O|o|dylib、tbd、framework|a、framework\n\n#### Compile and link process\n\n1. Pre-compilation (pre-compiler processes pre-compilation instructions such as `# include`,` # define` and generates `.i` or` .ii` files)\n2. Compile (the compiler performs lexical analysis, syntax analysis, semantic analysis, intermediate code generation, object code generation, optimization, and generation of `.s` files)\n3. Assembly (the assembler translates the assembly code into machine code and generates a `.o` file)\n4. Linking (connectors perform address and space allocation, symbol resolution, relocation, and generate `.out` files)\n\n> The current version of GCC combines pre-compilation and compilation into one step, pre-compiled compiler cc1, assembler as, linker ld\n\n> MSVC compilation environment, compiler cl, linker link, executable file viewer dumpbin\n\n#### target document\n\nThe files generated by the compiler after compiling the source code are called object files. The object file is structurally speaking, it is a compiled executable file format, but the linking process has not yet been performed, and some symbols or addresses may not be adjusted.\n\n> Executable files (`.exe` for Windows and` ELF` for Linux), dynamic link libraries (`.dll` for Windows and` .so` for Linux), static link libraries (`.lib` for Windows and Linux `.A`) are stored according to the executable file format (Windows according to PE-COFF, Linux according to ELF)\n\n##### Object file format\n\n* Windows PE (Portable Executable), or PE-COFF, `.obj` format\n* Linux's ELF (Executable Linkable Format), `.o` format\n* Intel / Microsoft OMF (Object Module Format)\n* Unix `a.out` format\n* MS-DOS `.COM` format\n\n> PE and ELF are both COFF (Common File Format) variants\n\n##### Object file storage structure\n\nSegment | Function\n--- | ---\nFile Header | File header, describing the file attributes of the entire file (including whether the file is executable, is it statically linked or dynamically linked with the entry address, target hardware, target operating system, etc.)\n.text section | Code section, machine code compiled by the execution statement\n.data section | Data section, initialized global and local static variables\n.bss section | BSS section (Block Started by Symbol), uninitialized global and local static variables (because the default value is 0, so it is only reserved here and does not take up space)\n.rodata section | Read-only data section, which stores read-only data, generally read-only variables (such as const-modified variables) and string constants in the program\n.comment section | Comment section for compiler version information\n.note.GNU-stack section | Stack hint section\n\n> Other paragraphs omitted\n\n#### Linked Interface-Symbol\n\nIn the link, the object files are actually a reference to the address between the object files, that is, a reference to the address of a function and a variable. We collectively refer to functions and variables as Symbols, and function names or variable names are Symbol Names.\n\nThe following Symbol Table:\n\nSymbol (Symbol Name) | Symbol Value (Address)\n--- | ---\nmain| 0x100\nAdd | 0x123\n... | ...\n\n### Shared Library for Linux\n\nShared libraries under Linux are ordinary ELF shared objects.\n\nThe shared library version update should ensure the compatibility of the binary interface ABI (Application Binary Interface)\n\n#### Name\n\n`libname.so.x.y.z`\n\n* x: major version number, libraries with different major version numbers are not compatible and need to be recompiled\n* y: minor version number, higher version number is backward compatible with lower version number\n* z: release version number, no interface changes, fully compatible\n\n#### path\n\nMost open source systems, including Linux, follow the FHS (File Hierarchy Standard) standard. This standard specifies how system files are stored, including various directory structures, organizations, and roles.\n\n* `/lib`: Stores the most critical and basic shared libraries of the system, such as dynamic linker, C language runtime library, math library, etc.\n* `/usr/lib`: Stores key libraries required by non-system runtime, mainly development libraries\n* `/usr/local/lib`: Stores libraries that are not very relevant to the operating system itself, mainly libraries for some third-party applications\n\n> The dynamic linker looks for shared libraries in `/ lib`, `/usr/lib`, and specified by the `/etc/ld.so.conf` configuration file\n\n#### Environment variables\n\n* `LD_LIBRARY_PATH`: temporarily change the shared library search path of an application without affecting other applications\n* `LD_PRELOAD`: specify some shared libraries or even object files that are pre-loaded\n* `LD_DEBUG`: Turn on the debugging function of the dynamic linker\n\n#### So shared library writing\n\nWriting shared libraries with CLion\n\nCreate a shared library named MySharedLib\n\nCMakeLists.txt\n\n```cmake\ncmake_minimum_required(VERSION 3.10)\nproject(MySharedLib)\n\nset(CMAKE_CXX_STANDARD 11)\n\nadd_library(MySharedLib SHARED library.cpp library.h)\n```\n\nlibrary.h\n\n```cpp\n#ifndef MYSHAREDLIB_LIBRARY_H\n#define MYSHAREDLIB_LIBRARY_H\n\n// print Hello World!\nvoid hello();\n\n// Sum using variable template parameters\ntemplate <typename T>\nT sum(T t)\n{\n    return t;\n}\ntemplate <typename T, typename ...Types>\nT sum(T first, Types ... rest)\n{\n    return first + sum<T>(rest...);\n}\n\n#endif\n```\n\nlibrary.cpp\n\n```cpp\n#include <iostream>\n#include \"library.h\"\n\nvoid hello() {\n    std::cout << \"Hello, World!\" << std::endl;\n}\n```\n\n#### use of so shared library (called by executable project)\n\nUse CLion to call a shared library\n\nCreate an executable project named TestSharedLib\n\nCMakeLists.txt\n\n```cmake\ncmake_minimum_required (VERSION 3.10)\nproject (TestSharedLib)\n\n# C ++ 11 compile\nset (CMAKE_CXX_STANDARD 11)\n\n# Header file path\nset (INC_DIR / home / xx / code / clion / MySharedLib)\n# Library file path\nset (LIB_DIR / home / xx / code / clion / MySharedLib / cmake-build-debug)\n\ninclude_directories(${INC_DIR})\nlink_directories(${LIB_DIR})\nlink_libraries(MySharedLib)\n\nadd_executable(TestSharedLib main.cpp)\n\n# link MySharedLib Library\ntarget_link_libraries(TestSharedLib MySharedLib)\n```\n\nmain.cpp\n\n```cpp\n#include <iostream>\n#include \"library.h\"\nusing std::cout;\nusing std::endl;\n\nint main() {\n\n    hello();\n    cout << \"1 + 2 = \" << sum(1,2) << endl;\n    cout << \"1 + 2 + 3 = \" << sum(1,2,3) << endl;\n\n    return 0;\n}\n```\n\nResults\n\n```\nHello, World!\n1 + 2 = 3\n1 + 2 + 3 = 6\n```\n\n### Windows Application entry function\n\n* GUI（Graphical User Interface) application, linker options:`/SUBSYSTEM:WINDOWS`\n* CUI（Console User Interface) application, linker options：`/SUBSYSTEM:CONSOLE`\n\n_tWinMain versus _tmain Function declaration\n\n```cpp\nInt WINAPI _tWinMain(\n    HINSTANCE hInstanceExe,\n    HINSTANCE,\n    PTSTR pszCmdLine,\n    int nCmdShow);\n\nint _tmain(\n    int argc,\n    TCHAR *argv[],\n    TCHAR *envp[]);\n```\n\nApplication Type | Entry Point Function | Embedded Startup Function\n--- | --- | ---\nGUI application for processing ANSI characters (strings) | _tWinMain (WinMain) | WinMainCRTSartup\nGUI application for handling Unicode characters (strings) | _tWinMain (wWinMain) | wWinMainCRTSartup\nCUI application that handles ANSI characters (strings) | _tmain (Main) | mainCRTSartup\nCUI application for handling Unicode characters (strings) | _tmain (wMain) | wmainCRTSartup\nDynamic-Link Library | DllMain | _DllMainCRTStartup\n\n### Dynamic-Link Library for Windows\n\n> Part of the knowledge comes from \"Windows Core Programming (Fifth Edition)\"\n\n#### Uses\n\n* Expanded application features\n* Simplified project management\n* Helps save memory\n* Promote the sharing of resources\n* Improved localization\n* Helps resolve differences between platforms\n* Can be used for special purposes\n\n#### Note\n\n* Creating a DLL is actually creating a function that can be called by an executable module\n* When a module provides a memory allocation function (malloc, new), it must also provide another memory release function (free, delete)\n* When mixing C and C++, use the extern \"C\" modifier\n* A DLL can export functions, variables (to avoid export), C++ classes (export and import need to be the same as the compiler, otherwise avoid export)\n* DLL module: __declspec (dllexport) in the cpp file is written before the include header file\n* Calling DLL's executable module: __declspec (dllimport) of the cpp file should not define MYLIBAPI before\n\n#### Search order for loading Windows programs\n\n1. Directory containing executable files\n2. The system directory of Windows can be obtained through GetSystemDirectory\n3. 16-bit system directory, the System subdirectory in the Windows directory\n4. The Windows directory can be obtained through GetWindowsDirectory\n5. The current directory of the process\n6. Directories listed in the PATH environment variable\n\n#### DLL Entry function\n\nDllMain function\n\n```cpp\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n{\n    switch(fdwReason)\n    {\n    case DLL_PROCESS_ATTACH:\n        // Called when mapping a DLL to the process address space for the first time\n        // The DLL is being mapped into the process' address space.\n        break;\n    case DLL_THREAD_ATTACH:\n        // When the process creates a thread, it is used to tell the DLL to perform thread-related initialization (non-main thread execution)\n        // A thread is bing created.\n        break;\n    case DLL_THREAD_DETACH:\n        // The system calls ExitThread before the thread exits, the thread that is about to be terminated performs thread-related cleanup by telling the DLL\n        // A thread is exiting cleanly.\n        break;\n    case DLL_PROCESS_DETACH:\n        // Called when a DLL is removed from the process's address space\n        // The DLL is being unmapped from the process' address space.\n        break;\n    }\n    \n    return (TRUE); // Used only for DLL_PROCESS_ATTACH\n}\n```\n\n#### Load and unload library\n\nLoadLibrary、LoadLibraryExA、LoadPackagedLibrary、FreeLibrary、FreeLibraryAndExitThread Function declaration\n\n```cpp\n// load library\nHMODULE WINAPI LoadLibrary (\n  _In_ LPCTSTR lpFileName\n);\nHMODULE LoadLibraryExA (\n  LPCSTR lpLibFileName,\n  HANDLE hFile,\n  DWORD dwFlags\n);\n// To load a Win32 DLL in a Universal Windows Platform (UWP) application, you need to call LoadPackagedLibrary instead of LoadLibrary or LoadLibraryEx\nHMODULE LoadPackagedLibrary (\n  LPCWSTR lpwLibFileName,\n  DWORD Reserved\n);\n\n// uninstall library\nBOOL WINAPI FreeLibrary (\n  _In_ HMODULE hModule\n);\n// Unload the library and exit the thread\nVOID WINAPI FreeLibraryAndExitThread(\n  _In_ HMODULE hModule,\n  _In_ DWORD   dwExitCode\n);\n```\n\n#### Display link to export symbol\n\nGetProcAddress function declaration\n\n```cpp\nFARPROC GetProcAddress (\n  HMODULE hInstDll,\n  PCSTR pszSymbolName // Can only accept ANSI strings, not Unicode\n);\n```\n\n#### DumpBin.exe View DLL information\n\nUse `DumpBin.exe` in the` VS Developer Command Prompt` to view the exported section of the DLL library (exported variables, functions, symbols of class names), relative virtual addresses (RVA). Such as:\n```\nDUMPBIN -exports D: \\ mydll.dll\n```\n\n#### Flow chart of LoadLibrary and FreeLibrary\n\nLoadLibrary and FreeLibrary flowchart\n\n##### LoadLibrary\n\n![WindowsLoadLibrary](https://raw.githubusercontent.com/huihut/interview/master/images/WindowsLoadLibrary.png)\n\n##### FreeLibrary\n\n![WindowsFreeLibrary](https://raw.githubusercontent.com/huihut/interview/master/images/WindowsFreeLibrary.png)\n\n#### Writing of DLL library (export a DLL module)\n\nWriting DLL library (export a DLL module)\nDLL header file\n\n```cpp\n// MyLib.h\n\n#ifdef MYLIBAPI\n\n// MYLIBAPI should be defined before include \"Mylib.h\" in all DLL source files\n// All functions / variables are being exported\n\n#else\n\n// This header file is included by an exe source code module, which means that all functions / variables are imported\n#define MYLIBAPI extern \"C\" __declspec (dllimport)\n\n#endif\n\n// Define any data structure and symbol here\n\n// Define exported variables (avoid exporting variables)\nMYLIBAPI int g_nResult;\n\n// Define the prototype of the exported function\nMYLIBAPI int Add(int nLeft, int nRight);\n```\n\nDLL source files\n\n```cpp\n// MyLibFile1.cpp\n\n// Contains standard Windows and C runtime header files\n#include <windows.h>\n\n// Functions and variables exported from DLL source files\n#define MYLIBAPI extern \"C\" __declspec (dllexport)\n\n// Contains exported data structures, symbols, functions, variables\n#include \"MyLib.h\"\n\n// Put the code of this DLL source code file here\nint g_nResult;\n\nint Add(int nLeft, int nRight)\n{\n    g_nResult = nLeft + nRight;\n    return g_nResult;\n}\n```\n\n#### Use of DLL library (dynamic link DLL at runtime)\n\nUse of DLL libraries (dynamically linking DLLs at runtime)\n\n```cpp\n// A simple program that uses LoadLibrary and \n// GetProcAddress to access myPuts from Myputs.dll. \n \n#include <windows.h> \n#include <stdio.h> \n \ntypedef int (__cdecl *MYPROC)(LPWSTR); \n \nint main( void ) \n{ \n    HINSTANCE hinstLib; \n    MYPROC ProcAdd; \n    BOOL fFreeResult, fRunTimeLinkSuccess = FALSE; \n \n    // Get a handle to the DLL module.\n \n    hinstLib = LoadLibrary(TEXT(\"MyPuts.dll\")); \n \n    // If the handle is valid, try to get the function address.\n \n    if (hinstLib != NULL) \n    { \n        ProcAdd = (MYPROC) GetProcAddress(hinstLib, \"myPuts\"); \n \n        // If the function address is valid, call the function.\n \n        if (NULL != ProcAdd) \n        {\n            fRunTimeLinkSuccess = TRUE;\n            (ProcAdd) (L\"Message sent to the DLL function\\n\"); \n        }\n        // Free the DLL module.\n \n        fFreeResult = FreeLibrary(hinstLib); \n    } \n\n    // If unable to call the DLL function, use an alternative.\n    if (! fRunTimeLinkSuccess) \n        printf(\"Message printed from executable\\n\"); \n\n    return 0;\n}\n```\n\n### Runtime（Runtime Library）\n\n#### Typical program operation steps\n\n1. The operating system creates a process and passes control to the entry point of the program (often an entry function in the runtime library)\n2. The entry function initializes the runtime library and program running environment (including heap, I / O, threads, global variable construction, etc.).\n3. After the entry function is initialized, the main function is called to officially start executing the main part of the program.\n4. After the main function finishes executing, return to the entry function for cleanup (including global variable destruction, heap destruction, closing I / O, etc.), and then make a system call to end the process.\n\n> I / O of a program refers to the interaction between the program and the outside world, including files, management programs, network, command line, signals, etc. More broadly, I / O refers to what the operating system understands as a \"file.\"\n\n#### glibc entry\n\n`_start-> __libc_start_main-> exit-> _exit`\n\nThe `main (argc, argv, __environ)` function is executed in `__libc_start_main`.\n\n#### MSVC CRT Entry\n\n`int mainCRTStartup (void)`\n\nDo the following:\n\n1. Initialize global variables related to the OS version.\n2. Initialize the heap.\n3. Initialize I / O.\n4. Get command line parameters and environment variables.\n5. Initialize some data of the C library.\n6. Call main and record the return value.\n7. Check for errors and return the return value of main.\n\n#### C Language Runtime (CRT)\n\nIt contains the following functions:\n\n* Start and exit: including entry functions and other functions on which entry functions depend.\n* Standard functions: There are functions implemented by the C language standard library specified by the C language standard.\n* I/O: Encapsulation and implementation of I / O functions.\n* Heap: Encapsulation and implementation of the heap.\n* Language implementation: implementation of some special functions in the language.\n* Debugging: Code that implements debugging functions.\n\n#### C Language Standard Library (ANSI C)\n\ncontain:\n\n* Standard input and output (stdio.h)\n* File operations (stdio.h)\n* Character manipulation (ctype.h)\n* String operations (string.h)\n* Mathematical functions (math.h)\n* Resource Management (stdlib.h)\n* Format conversion (stdlib.h)\n* Time / Date (time.h)\n* Assertions (assert.h)\n* Constants on various types (limits.h & float.h)\n* Variable length parameter (stdarg.h)\n* Non-local jump (setjmp.h)\n\n<a id=\"books\"></a>\n\n## 📚 Books\n\n> [huihut/CS-Books](https://github.com/huihut/CS-Books)：📚 Computer Technology Books PDF\n\n### Language\n\n* \"C ++ Primer\"\n* \"Effective C ++\"\n* \"More Effective C ++\"\n* \"Exploring the C ++ Object Model\"\n* \"Understanding C ++ 11\"\n* \"Anatomy of STL Source Code\"\n\n### Algorithm\n\n* \"Sword Finger Offer\"\n* \"Programming Pearls\"\n* \"Programmer Interview Collection\"\n\n### System\n\n* \"Understanding Computer Systems\"\n* \"Windows Core Programming\"\n* \"Advanced Programming in the Unix Environment\"\n\n### The internet\n\n* \"Unix Network Programming\"\n* \"Detailed Explanation of TCP / IP\"\n\n### Other\n\n* \"The Self-Cultivation of Programmers\"\n\n<a id=\"cc-development-direction\"></a>\n\n## 🔱 C / C ++ Development Direction\n\n> The development direction of C / C ++ is very wide, including not limited to the following directions. The following are some of the requirements for recruiting positions of big factories and schools.\n\n### Backend / Server\n\n[Backend Development]\n\n* Solid basic programming skills, master C / C ++ / JAVA and other development languages, commonly used algorithms and data structures;\n* Familiar with TCP / UDP network protocol and related programming, inter-process communication programming;\n* Understanding Python, Shell, Perl and other scripting languages;\n* Understand MYSQL, SQL language, programming, NoSQL, key-value storage principle;\n* Comprehensive and solid software knowledge structure, mastering professional knowledge of operating systems, software engineering, design patterns, data structures, database systems, and network security;\n* Understand the knowledge of distributed system design and development, load balancing technology, system disaster recovery design, and high availability systems.\n\n### Desktop Client\n\n[PC client development]\n\n* Bachelor degree or above in computer software, majoring in programming, solid foundation, understanding of algorithms and data structure;\n* Familiar with memory management, file system, process thread scheduling of windows operating system;\n* Familiar with MFC / windows interface implementation mechanism, proficient in VC, proficient in C / C ++, proficient in STL, and network programming experience under Windows;\n* Familiar with Windows client development and debugging, Windows application software development experience is preferred;\n* Passionate about innovation and solving challenging problems, with good algorithm foundation and system analysis ability.\n\n### Graphics / Game / VR / AR\n\n[Game Client Development]\n\n* Bachelor degree or above in computer science / engineering major, passion for programming, solid foundation, understanding of algorithms, data structure, software design related knowledge;\n* At least one programming language commonly used in game development, C ++ / C # programming experience is preferred;\n* Experience with game engines (such as Unity, Unreal) is preferred;\n* Knowledge of game client technology (such as graphics, audio, animation, physics, artificial intelligence, network synchronization) is preferred;\n* Passionate about innovation and solving challenging problems, strong learning ability, analytical and problem solving skills, and a good sense of teamwork;\n* Ability to read English technical documents;\n* Love games.\n\n### Test Development\n\n[Test Development]\n\n* Bachelor degree or above in computer or related field;\n* One to two years of programming experience in C / C ++ / Python or other computer languages;\n* Ability to write test plans, test cases, and achieve performance and safety tests;\n* Ability to implement automated systems;\n* Ability to locate and investigate product defects and code-level debugging defects;\n* Work proactively, have a sense of responsibility, and have a good team spirit.\n\n### Cyber Security / Reverse\n\n[safety technology]\n\n* Love the Internet, have a passionate pursuit of operating systems and network security, and professionalism is not limited;\n* Familiar with vulnerability mining, network security attack and defense technologies, and common hacking techniques;\n* Master basic development skills and be proficient in C / C ++ language;\n* Have a good grasp of database, operating system and network principles;\n* Experience in software reverse, network security attack and defense or security system development is preferred.\n\n### Embedded / IoT\n\n[Embedded Application Development]\n\n* Have a good programming foundation, proficient in C / C ++ language;\n* Master the necessary knowledge for software development such as operating system and data structure;\n* Strong communication and understanding ability and good teamwork awareness;\n* Development experience on Linux / Android system platform is preferred.\n\n### Audio / Video / Streaming / SDK\n\n[Audio and video codec]\n\n1. Master's degree or above, computer, signal processing, mathematics, information and related majors and directions;\n2. Solid video coding and decoding foundation, familiar with commonly used HEVC or H264, have a good digital signal processing foundation;\n3. Master C / C ++, strong code ability, familiar with an assembly language is preferred;\n4. Strong English literature reading ability;\n5. Strong learning ability, teamwork spirit, and strong resistance to stress.\n\n### Computer Vision / Machine Learning\n\n[Computer Vision Research]\n\n* Computer, applied mathematics, pattern recognition, artificial intelligence, automatic control, statistics, operations research, bioinformatics, physics / quantum computing, neuroscience, sociology / psychology and other majors, image processing, pattern recognition, machine learning related research Direction, undergraduate and above, doctoral degree is preferred;\n* Proficient in basic algorithms and applications related to computer vision and image processing;\n* Strong algorithm implementation ability, proficient in C / C ++ programming, familiar with at least one programming language of Shell / Python / Matlab;\n* Publication of papers in computer vision, pattern recognition and other academic conferences or journals, awards in relevant international competitions, and related patents are preferred.\n\n<a id=\"review-of-brush-questions-website\"></a>\n\n## 💯 Review brush question website\n\n* [cplusplus](http://www.cplusplus.com/)\n* [cppreference](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)\n* [runoob](http://www.runoob.com/cplusplus/cpp-tutorial.html)\n* [leetcode](https://leetcode.com/) | [leetcode-cn](https://leetcode-cn.com/)\n* [lintcode](https://www.lintcode.com/)\n* [nowcoder](https://www.nowcoder.net/)\n\n<a id=\"interview-questions-experience\"></a>\n\n## 📝 Interview Question Experience\n\n* [Nowcoder.com's summary of the 2020 autumn tricks! (Post division)](https://www.nowcoder.com/discuss/205497)\n* [【Preparation for Autumn Moves】 Raiders for 2020 Autumn Moves](https://www.nowcoder.com/discuss/197116)\n* [2019 School Recruitment Summary! 【Daily Update】](https://www.nowcoder.com/discuss/90907)\n* [2019 School Recruitment Technology Posts Summary [Technology]](https://www.nowcoder.com/discuss/146655)\n* [2018 School Recruitment Questions Summary](https://www.nowcoder.com/discuss/68802)\n* [2017 Autumn Campus Recruitment Pen and Face Summaries](https://www.nowcoder.com/discuss/12805)\n* [The most complete collection of 2017 spring tricks in history!!](https://www.nowcoder.com/discuss/25268)\n* [Interview questions are here](https://www.nowcoder.com/discuss/57978)\n* [zhihu. On the Internet job search, what well-written and attentive face have you seen? It is best to share your own facial and mental journey. ](https://www.zhihu.com/question/29693016)\n* [zhihu. What are the most common interview algorithm questions for internet companies? ](https://www.zhihu.com/question/24964987)\n* [CSDN. C ++ Interview Questions Completely Organized](http://blog.csdn.net/ljzcome/article/details/574158)\n* [CSDN. Baidu R & D interview questions (C ++ direction)](http://blog.csdn.net/Xiongchao99/article/details/74524807?locationNum=6&fps=1)\n* [CSDN. C ++ 30 common interview questions](http://blog.csdn.net/fakine/article/details/51321544)\n* [CSDN. Tencent 2016 intern interview experience (already got offer)](http://blog.csdn.net/onever_say_love/article/details/51223886)\n* [cnblogs. C ++ Interview Collection (Questions Asked for Interview)](https://www.cnblogs.com/Y1Focus/p/6707121.html)\n* [cnblogs. C / C ++ written and interview questions summary](https://www.cnblogs.com/fangyukuan/archive/2010/09/18/1829871.html)\n* [cnblogs. Summary of common C ++ interview questions and basic knowledge points (1)](https://www.cnblogs.com/LUO77/p/5771237.html)\n* [segmentfault. Summary of common interview questions in C ++](https://segmentfault.com/a/1190000003745529)\n\n<a id=\"recruitment-time-post\"></a>\n\n## 📆 Recruiting time posts\n\n* [nowcoder . Enterprise Recruitment Schedule](https://www.nowcoder.com/school/schedule)\n\n<a id=\"recommend\"></a>\n\n## 👍 Recommend\n\n* [Github. CyC2018 / Job-Recommend](https://github.com/CyC2018/Job-Recommend): 🔎 Internet internal push information (social recruitment, school recruitment, internship)\n* [Github. Amusi / AI-Job-Recommend](https://github.com/amusi/AI-Job-Recommend): direction of artificial intelligence of domestic companies (including machine learning, deep learning, computer vision and natural language processing) Job recruitment information (including full-time, internship and school recruitment)\n\n<a id=\"contributor\"></a>\n\n## 👬 Contributor\n\n<a href=\"https://github.com/huihut/interview/graphs/contributors\"><img src=\"https://opencollective.com/interview/contributors.svg?button=false\" /></a>\n\n<a id=\"license\"></a>\n\n## 📜 License\n\nThis repository follows the CC BY-NC-SA 4.0 (signed-non-commercial use-shared in the same way) agreement, please indicate the source when reprinting, and should not be used for commercial purposes.\n\n[![CC BY-NC-SA 4.0](https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png)](https://github.com/huihut/interview/blob/master/LICENSE)\n"
        },
        {
          "name": "STL",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}