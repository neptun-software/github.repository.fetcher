{
  "metadata": {
    "timestamp": 1736711712982,
    "page": 438,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "desandro/3dtransforms",
      "stars": 1012,
      "defaultBranch": "gh-pages",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0146484375,
          "content": "_site\nnotes.md\n"
        },
        {
          "name": "3d-transform-functions.md",
          "type": "blob",
          "size": 3.3447265625,
          "content": "---\n\ntitle: 3D transform functions\nlayout: doc\nslug: functions\nredirect_from:\n  - \"/docs/3d-transform-functions.html\"\n  - \"/examples/transforms-01-functions.html\"\n\n---\n\nAs a web designer, you're probably well acquainted with working in two dimensions, X and Y, positioning items horizontally and vertically. With a 3D space initialized with `perspective`, we can now transform elements in three spatial dimensions with the third Z dimension.\n\n3D transforms use the same `transform` property used for 2D transforms. If you're familiar with 2D transforms, you'll find the basic [3D transform functions](https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function) similar.\n\n* `rotateX( angle )`\n* `rotateY( angle )`\n* `rotateZ( angle )`\n* `translateZ( tz )`\n* `scaleZ( sz )`\n\nWhereas `translateX()` positions an element along the horizontal X axis, `translateZ()` positions it along the Z axis, which runs front to back in 3D space. Positive values position the element closer to the viewer, negative values further away.\n\nThe `rotate` functions rotate the element around the corresponding axis. This is a bit counter-intuitive at first, as you might imagine that `rotateX()` will rotate an object horizontally left or right. Instead, using `rotateX()` rotates an element _around_ the horizontal X axis, so the top of the element angles back and away, and the bottom angles near.\n\n<div class=\"scene scene--transform-func\">\n  <div class=\"transform-func-panel\" style=\"transform: translateZ(-200px)\">translateZ(-200px)</div>\n</div>\n\n<div class=\"scene scene--transform-func\">\n  <div class=\"transform-func-panel\" style=\"transform: translateZ(200px)\">translateZ(200px)</div>\n</div>\n\n<div class=\"scene scene--transform-func\">\n  <div class=\"transform-func-panel\" style=\"transform: rotateX(45deg)\">rotateX(45deg)</div>\n</div>\n\n<div class=\"scene scene--transform-func\">\n  <div class=\"transform-func-panel\" style=\"transform: rotateY(45deg)\">rotateY(45deg)</div>\n</div>\n\n<div class=\"scene scene--transform-func\">\n  <div class=\"transform-func-panel\" style=\"transform: rotateZ(45deg)\">rotateZ(45deg)</div>\n</div>\n\n{% include edit-codepen.html pen_slug=\"NMpVxV\" %}\n\nThere's also several shorthand transform functions so you can set values for all three dimensions:\n\n* `translate3d( tx, ty, tz )`\n* `scale3d( sx, sy, sz )`\n* `rotate3d( rx, ry, rz, angle )`\n\n## Hardware acceleration\n\nThese 3-argument `transform3d()` functions also have the benefit of triggering hardware acceleration. Dean Jackson, CSS 3D transform spec author and main WebKit dude, wrote:\n\n> In essence, any transform that has a 3D operation as one of its functions will trigger hardware compositing, even when the actual transform is 2D, or not doing anything at all (such as `translate3d(0,0,0)`). Note this is just current behaviour, and could change in the future (which is why we don't document or encourage it). But it is very helpful in some situations and can significantly improve redraw performance.\n\n[This note was written in 2010.](http://mir.aculo.us/2010/08/05/html5-buzzwords-in-action/) Since then, other browsers have adopted this behavior. But YMMV. Hardware acceleration in browsers remains a mysterious subject that's rarely documented.\n\nFor the sake of clarity, the demos in this essay will use the basic transform functions, but if you're looking to boost performance, try using `transform3d()`.\n\n* * *\n\n[**Next: Card flip &rarr;**](card-flip)\n"
        },
        {
          "name": "CNAME",
          "type": "blob",
          "size": 0.025390625,
          "content": "3dtransforms.desandro.com\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.69921875,
          "content": "# Intro to CSS 3D transforms\n\nBy [David DeSandro](https://desandro.com)\n\n[3dtransforms.desandro.com](https://3dtransforms.desandro.com)\n\nTutorial, examples, and discussion all about CSS 3D transforms.\n\nOriginally written for [24 ways 2010](https://24ways.org/2010/intro-to-css-3d-transforms).\n\n## Viewing this project locally\n\nThis project is built with [Jekyll](https://jekyllrb.com).\n\n    git clone https://github.com/desandro/3dtransforms.git\n    cd 3dtransforms/\n    jekyll serve\n\n## License\n\nWritten content is licensed under a [Creative Commons Attribution License](https://creativecommons.org/licenses/by/4.0/).\n\nExample code is licensed under the [MIT license](https://desandro.mit-license.org). Have at it.\n"
        },
        {
          "name": "_config.yml",
          "type": "blob",
          "size": 0.1064453125,
          "content": "permalink: /:slug\n\n# site-wide data\nsite_name: Intro to CSS 3D transforms\n\nplugins:\n  - jekyll-redirect-from\n"
        },
        {
          "name": "_includes",
          "type": "tree",
          "content": null
        },
        {
          "name": "_layouts",
          "type": "tree",
          "content": null
        },
        {
          "name": "box.md",
          "type": "blob",
          "size": 6.796875,
          "content": "---\n\ntitle: Box\nlayout: doc\nslug: box\nredirect_from:\n  - \"/docs/rectangular-prism.html\"\n  - \"/examples/box-01-steps.html\"\n  - \"/examples/box-02-show-sides.html\"\n\n---\n\nCube objects are easy enough to generate as we only have to worry about one measurement. But how would we handle a non-regular rectangular prism? Or, as the kids say, a box. Let's try to make one 300px wide, 200px high, and 100px deep.\n\nThe markup remains the same.\n\n{% highlight html %}\n<div class=\"scene\">\n  <div class=\"box\">\n    <div class=\"box__face box__face--front\">front</div>\n    <div class=\"box__face box__face--back\">back</div>\n    <div class=\"box__face box__face--right\">right</div>\n    <div class=\"box__face box__face--left\">left</div>\n    <div class=\"box__face box__face--top\">top</div>\n    <div class=\"box__face box__face--bottom\">bottom</div>\n  </div>\n</div>\n{% endhighlight %}\n\nThe CSS the same as the cube's, with size values changed: `width: 300px`, `height: 200px` and `translateZ(-50px)` on the `.box` as its 100px deep.\n\n{% highlight css %}\n.scene {\n  width: 300px;\n  height: 200px;\n  perspective: 500px;\n}\n\n.box {\n  width: 300px;\n  height: 200px;\n  position: relative;\n  transform-style: preserve-3d;\n  transform: translateZ(-50px);\n}\n\n.box__face--front,\n.box__face--back {\n  width: 300px;\n  height: 200px;\n}\n\n.box__face--right,\n.box__face--left {\n  width: 100px;\n  height: 200px;\n}\n\n.box__face--top,\n.box__face--bottom {\n  width: 300px;\n  height: 100px;\n}\n{% endhighlight %}\n\n<div class=\"scene\">\n  <div class=\"box box--step0\">\n    <div class=\"box__face box__face--front\">front</div>\n    <div class=\"box__face box__face--back\">back</div>\n    <div class=\"box__face box__face--right\">right</div>\n    <div class=\"box__face box__face--left\">left</div>\n    <div class=\"box__face box__face--top\">top</div>\n    <div class=\"box__face box__face--bottom\">bottom</div>\n  </div>\n</div>\n\nWith `position: absolute` applied to the faces, they all collapse to the top left corner of `.box`.\n\n<div class=\"scene scene--box\">\n  <div class=\"box box--step1 box--step1a\">\n    <div class=\"box__face box__face--front\">front</div>\n    <div class=\"box__face box__face--back\">back</div>\n    <div class=\"box__face box__face--right\">right</div>\n    <div class=\"box__face box__face--left\">left</div>\n    <div class=\"box__face box__face--top\">top</div>\n    <div class=\"box__face box__face--bottom\">bottom</div>\n  </div>\n</div>\n\nIn order to translate out the faces from the center of the box in 3D, we need to center the faces. We can do this by adding `top` and `left` position styles. `.box__face--left` and `.box__face--right` need to be positioned `left: 100px`. `.box__face--top` and `.box__face--bottom` need to be positioned `top: 50px`.\n\n{% highlight css %}\n.box__face--right,\n.box__face--left {\n  width: 100px;\n  height: 200px;\n  left: 100px;\n}\n\n.box__face--top,\n.box__face--bottom {\n  width: 300px;\n  height: 100px;\n  top: 50px;\n}\n{% endhighlight %}\n\n<div class=\"scene scene--box\">\n  <div class=\"box box--step1\">\n    <div class=\"box__face box__face--front\">front</div>\n    <div class=\"box__face box__face--back\">back</div>\n    <div class=\"box__face box__face--right\">right</div>\n    <div class=\"box__face box__face--left\">left</div>\n    <div class=\"box__face box__face--top\">top</div>\n    <div class=\"box__face box__face--bottom\">bottom</div>\n  </div>\n</div>\n\nTo position the faces in 3D, the rotate values all can remain the same as in the cube example, but for this rectangular prism, the translate values differ. The front and back faces each are shifted out `50px` since the box is 100px deep. Left and right faces translate is `150px` for 300px width. Top and bottom panels go `100px` for the 200px height.\n\n{% highlight css %}\n.box__face--front  { transform: rotateY(  0deg) translateZ( 50px); }\n.box__face--back   { transform: rotateY(180deg) translateZ( 50px); }\n\n.box__face--right  { transform: rotateY( 90deg) translateZ(150px); }\n.box__face--left   { transform: rotateY(-90deg) translateZ(150px); }\n\n.box__face--top    { transform: rotateX( 90deg) translateZ(100px); }\n.box__face--bottom { transform: rotateX(-90deg) translateZ(100px); }\n{% endhighlight %}\n\n<div class=\"scene scene--box\">\n  <div class=\"box\">\n    <div class=\"box__face box__face--front\">front</div>\n    <div class=\"box__face box__face--back\">back</div>\n    <div class=\"box__face box__face--right\">right</div>\n    <div class=\"box__face box__face--left\">left</div>\n    <div class=\"box__face box__face--top\">top</div>\n    <div class=\"box__face box__face--bottom\">bottom</div>\n  </div>\n</div>\n\nJust like the cube example, to expose a face, the `#box` needs to have a style to reverse its face's transform. Both the `translateZ` and `rotate` values are the opposites of the corresponding face.\n\n{% highlight css %}\n.box.show-front  { transform: translateZ( -50px) rotateY(   0deg); }\n.box.show-back   { transform: translateZ( -50px) rotateY(-180deg); }\n.box.show-right  { transform: translateZ(-150px) rotateY( -90deg); }\n.box.show-left   { transform: translateZ(-150px) rotateY(  90deg); }\n.box.show-top    { transform: translateZ(-100px) rotateX( -90deg); }\n.box.show-bottom { transform: translateZ(-100px) rotateX(  90deg); }\n{% endhighlight %}\n\n<div class=\"demo demo--rotate-box\">\n  <div class=\"scene scene--box\">\n    <div class=\"box box--rotate\">\n      <div class=\"box__face box__face--front\">front</div>\n      <div class=\"box__face box__face--back\">back</div>\n      <div class=\"box__face box__face--right\">right</div>\n      <div class=\"box__face box__face--left\">left</div>\n      <div class=\"box__face box__face--top\">top</div>\n      <div class=\"box__face box__face--bottom\">bottom</div>\n    </div>\n  </div>\n  <p class=\"radio-button-group\">\n    <label>\n      <input type=\"radio\" name=\"rotate-box-side\" value=\"front\" checked /> front\n    </label>\n    <label>\n      <input type=\"radio\" name=\"rotate-box-side\" value=\"right\" /> right\n    </label>\n    <label>\n      <input type=\"radio\" name=\"rotate-box-side\" value=\"back\" /> back\n    </label>\n    <label>\n      <input type=\"radio\" name=\"rotate-box-side\" value=\"left\" /> left\n    </label>\n    <label>\n      <input type=\"radio\" name=\"rotate-box-side\" value=\"top\" /> top\n    </label>\n    <label>\n      <input type=\"radio\" name=\"rotate-box-side\" value=\"bottom\" /> bottom\n    </label>\n  </p>\n</div>\n<script>\n( function() {\n  var demo = document.querySelector('.demo--rotate-box');\n  var box = demo.querySelector('.box');\n  var currentClass = '';\n\n  function changeSide() {\n    var checkedRadio = demo.querySelector(':checked');\n    var showClass = 'show-' + checkedRadio.value;\n    if ( currentClass ) {\n      box.classList.remove( currentClass );\n    }\n    box.classList.add( showClass );\n    currentClass = showClass;\n  }\n  // set initial side\n  changeSide();\n\n  demo.addEventListener( 'change', changeSide );\n})();\n</script>\n\n\n{% include edit-codepen.html pen_slug=\"MGpMOV\" %}\n\n![3D CSS box object rotating](../img/box02.png)\n\n* * *\n\n[**Next: Carousel &rarr;**](carousel)\n"
        },
        {
          "name": "card-flip.md",
          "type": "blob",
          "size": 5.517578125,
          "content": "---\n\ntitle: Card Flip\nlayout: doc\ncategory: docs\nslug: card\nredirect_from:\n  - \"/docs/card-flip.html\"\n  - \"/examples/card-01.html\"\n  - \"/examples/card-02-slide-flip.html\"\n  - \"/examples/card-03-slide-flip-2-ways.html\"\n  - \"/examples/transforms-03-origin.html\"\n\n---\n\nWe now have all the tools to start making 3D objects. Let's get started with the basics, flipping a card.\n\nHere's the basic markup we'll need:\n\n{% highlight html %}\n<div class=\"scene\">\n  <div class=\"card\">\n    <div class=\"card__face card__face--front\">front</div>\n    <div class=\"card__face card__face--back\">back</div>\n  </div>\n</div>\n{% endhighlight %}\n\n<div class=\"scene\">\n  <div class=\"card card--step0\">\n    <div class=\"card__face card__face--front\">front</div>\n    <div class=\"card__face card__face--back\">back</div>\n  </div>\n</div>\n\nThe `.scene` will house the 3D space. The `.card` acts as the 3D object. Two separate `.card__face` elements are used for the faces of the card. I recommend using this same pattern for any 3D transform: scene, object, and faces. Keeping the 3D space element and the object separate element establishes a paradigm that is simple to understand and easier to style.\n\nWe're ready for some 3D stylin'. First, apply necessary `perspective` to the containing 3D space, along with any size or positioning styles.\n\n{% highlight css %}\n.scene {\n  width: 200px;\n  height: 260px;\n  perspective: 600px;\n}\n{% endhighlight %}\n\nNow the `.card` element can be transformed in its parent's 3D space. We'll add `width: 100%;`  and `height: 100%;` so the card's `transform-origin` will occur in the center of container. More on `transform-origin` later. `position: relative` is used to position card faces absolutely.\n\nLet's add a CSS3 transition so users can see the transform take effect.\n\n{% highlight css %}\n.card {\n  width: 100%;\n  height: 100%;\n  position: relative;\n  transition: transform 1s;\n  transform-style: preserve-3d;\n}\n{% endhighlight %}\n\nAn element's `perspective` only applies to direct descendant children, in this case `.card`. In order for subsequent children to inherit a parent's perspective, and live in the same 3D space, the parent can pass along its perspective with `transform-style: preserve-3d`. Without 3D `transform-style`, the faces of the card would be flattened with its parents, and the back face's rotation would be nullified.\n\nTo position the faces in 3D space, we'll need to reset their positions in 2D with `position: absolute`. In order to hide the back-side of the faces when they are faced away from the viewer, we use `backface-visibility: hidden`.\n\n{% highlight css %}\n.card__face {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  backface-visibility: hidden;\n}\n{% endhighlight %}\n\nTo flip `.card__face--back`, we add a basic 3D transform of `rotateY(180deg)`.\n\n{% highlight css %}\n.card__face--front {\n  background: red;\n}\n\n.card__face--back {\n  background: blue;\n  transform: rotateY( 180deg );\n}\n{% endhighlight %}\n\nWith the faces in place, the `.card` requires a corresponding style for when it is flipped.\n\n{% highlight css %}\n.card.is-flipped {\n  transform: rotateY(180deg);\n}\n{% endhighlight %}\n\nNow we have a working 3D object. To flip the card, we can toggle the `is-flipped` class. When `.is-flipped`, the `.card` will rotate 180 degrees, thus exposing `.card__face--back`.\n\n<div class=\"demo demo--card-flip\">\n  <div class=\"scene scene--card\">\n    <div class=\"card\">\n      <div class=\"card__face card__face--front\">front</div>\n      <div class=\"card__face card__face--back\">back</div>\n    </div>\n  </div>\n  <p>Click card to flip.</p>\n</div>\n<script>\n( function() {\n  var card = document.querySelector('.demo--card-flip .card');\n  card.addEventListener( 'click', function() {\n    card.classList.toggle('is-flipped');\n  });\n})();\n</script>\n\n{% include edit-codepen.html pen_slug=\"LmWoWe\" %}\n\n![3D card flip transition](../img/card-flip01.png)\n\n## Slide-flip\n\nTake another look at the Weather App 3D transition. You'll notice that it's not quite the same effect as our previous demo. If you follow the right edge of the card, you'll find that it stays flush with the container. Instead of pivoting from the horizontal center, it pivots on that right edge. But the transition is not just a rotation -- the edge moves horizontally from right to left. We can reproduce this transition just by modifying a couple lines of CSS from our original card flip demo.\n\nThe pivot point for the rotation occurs at the right side of the card. By default, the `transform-origin` of an element is at its horizontal and vertical center (`50% 50%` or `center center`). An element's transforms are applied from its `transform-origin`. Let's change it to the right side:\n\n{% highlight css %}\n.card { transform-origin: center right; }\n{% endhighlight %}\n\nThat flip now needs some horizontal movement with `translateX`. We'll set the rotation to `-180deg` so it flips right side out.\n\n{% highlight css %}\n.card.is-flipped {\n  transform: translateX(-100%) rotateY(-180deg);\n}\n{% endhighlight %}\n\n<div class=\"demo demo--card-slide-flip\">\n  <div class=\"scene scene--card\">\n    <div class=\"card card--slide\">\n      <div class=\"card__face card__face--front\">front</div>\n      <div class=\"card__face card__face--back\">back</div>\n    </div>\n  </div>\n  <p>Click card to flip.</p>\n</div>\n<script>\n( function() {\n  var card = document.querySelector('.demo--card-slide-flip .card');\n  card.addEventListener( 'click', function() {\n    card.classList.toggle('is-flipped');\n  });\n})();\n</script>\n\n{% include edit-codepen.html pen_slug=\"LmWozd\" %}\n\n![3D card slide-flip transition](../img/card-flip02.png)\n\n* * *\n\n[**Next: Cube &rarr;**](cube)\n"
        },
        {
          "name": "carousel.md",
          "type": "blob",
          "size": 7.994140625,
          "content": "---\n\ntitle: Carousel\nlayout: doc\nslug: carousel\nscript: carousel.js\nredirect_from:\n  - \"/docs/carousel.html\"\n  - \"/examples/carousel-01.html\"\n  - \"/examples/carousel-02-dynamic.html\"\n\n---\n\nFront-end developers have a myriad of choices when it comes to content carousels. [May I suggest Flickity?](https://flickity.metafizzy.co) Now that we have 3D capabilities in our browsers, why not give a shot at creating an actual 3D carousel?\n\nThe markup for this demo takes the same form as the box, cube, and card. Let's make it interesting and have a carousel with 9 panels.\n\n{% highlight html %}\n<div class=\"scene\">\n  <div class=\"carousel\">\n    <div class=\"carousel__cell\">1</div>\n    <div class=\"carousel__cell\">2</div>\n    <div class=\"carousel__cell\">3</div>\n    <div class=\"carousel__cell\">4</div>\n    <div class=\"carousel__cell\">5</div>\n    <div class=\"carousel__cell\">6</div>\n    <div class=\"carousel__cell\">7</div>\n    <div class=\"carousel__cell\">8</div>\n    <div class=\"carousel__cell\">9</div>\n  </div>\n</div>\n{% endhighlight %}\n\n<div class=\"scene\">\n  <div class=\"carousel carousel--step0\">\n    <div class=\"carousel__cell\">1</div>\n    <div class=\"carousel__cell\">2</div>\n    <div class=\"carousel__cell\">3</div>\n    <div class=\"carousel__cell\">4</div>\n    <div class=\"carousel__cell\">5</div>\n    <div class=\"carousel__cell\">6</div>\n    <div class=\"carousel__cell\">7</div>\n    <div class=\"carousel__cell\">8</div>\n    <div class=\"carousel__cell\">9</div>\n  </div>\n</div>\n\nNow apply basic layout styles. Let's give each cell 20px gaps between one another, done here with `left: 10px`. The effective width of each panel remains 210px.\n\n{% highlight css %}\n.scene {\n  width: 210px;\n  height: 140px;\n  position: relative;\n  perspective: 1000px;\n}\n\n.carousel {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  transform-style: preserve-3d;\n}\n\n.carousel__cell {\n  position: absolute;\n  width: 190px;\n  height: 120px;\n  left: 10px;\n  top: 10px;\n}\n{% endhighlight %}\n\nNext up: rotating the faces. This carousel has 9 cells. If each cell gets an equal distribution on the carousel, each panel would be rotated 40 degrees from the next ( 360 / 9 ).\n\n{% highlight css %}\n.carousel__cell:nth-child(1) { transform: rotateY(  0deg); }\n.carousel__cell:nth-child(2) { transform: rotateY( 40deg); }\n.carousel__cell:nth-child(3) { transform: rotateY( 80deg); }\n.carousel__cell:nth-child(4) { transform: rotateY(120deg); }\n.carousel__cell:nth-child(5) { transform: rotateY(160deg); }\n.carousel__cell:nth-child(6) { transform: rotateY(200deg); }\n.carousel__cell:nth-child(7) { transform: rotateY(240deg); }\n.carousel__cell:nth-child(8) { transform: rotateY(280deg); }\n.carousel__cell:nth-child(9) { transform: rotateY(320deg); }\n{% endhighlight %}\n\nNow the outward shift. Back when we were creating cube and boxes, the `translate` value was simple to calculate, as it was equal to one half the width, height, or depth of the object. Now with a carousel, there is no size we can immediately reference. We'll have calculate the distance for the shift by other means.\n\nDrawing out a diagram of the carousel, we see that we only know two things: the width of each panel is 210px and the each panel is rotated 40 degrees from the next. If we split one of these triangles down its center, we get a right triangle, prime for some trigonometry.\n\n![Geometric diagram of carousel](../img/diagram.png)\n\nWe can determine the length of _r_ in this diagram with a basic tangent equation.\n\n![Trigonometric calculation](../img/calc.png)\n\nThere you have it, `288px` is the distance to translate the panels out in 3D space.\n\n{% highlight css %}\n.carousel__cell:nth-child(1) { transform: rotateY(  0deg) translateZ(288px); }\n.carousel__cell:nth-child(2) { transform: rotateY( 40deg) translateZ(288px); }\n.carousel__cell:nth-child(3) { transform: rotateY( 80deg) translateZ(288px); }\n.carousel__cell:nth-child(4) { transform: rotateY(120deg) translateZ(288px); }\n.carousel__cell:nth-child(5) { transform: rotateY(160deg) translateZ(288px); }\n.carousel__cell:nth-child(6) { transform: rotateY(200deg) translateZ(288px); }\n.carousel__cell:nth-child(7) { transform: rotateY(240deg) translateZ(288px); }\n.carousel__cell:nth-child(8) { transform: rotateY(280deg) translateZ(288px); }\n.carousel__cell:nth-child(9) { transform: rotateY(320deg) translateZ(288px); }\n{% endhighlight %}\n\n<div class=\"scene scene--carousel\">\n  <div class=\"carousel\">\n    <div class=\"carousel__cell\">1</div>\n    <div class=\"carousel__cell\">2</div>\n    <div class=\"carousel__cell\">3</div>\n    <div class=\"carousel__cell\">4</div>\n    <div class=\"carousel__cell\">5</div>\n    <div class=\"carousel__cell\">6</div>\n    <div class=\"carousel__cell\">7</div>\n    <div class=\"carousel__cell\">8</div>\n    <div class=\"carousel__cell\">9</div>\n  </div>\n</div>\n\nIf we decide on changing the width of the panel or the number of panels, we only need to plug in those two variables into our equation to get the appropriate translateZ value. In JS terms, that equation would be:\n\n{% highlight javascript %}\nvar tz = Math.round( ( cellSize / 2 ) /\n  Math.tan( ( ( Math.PI * 2 ) / numberOfCells ) / 2 ) );\n// or simplified to\nvar tz = Math.round( ( cellSize / 2 ) /  Math.tan( Math.PI / numberOfCells ) );\n{% endhighlight %}\n\nJust like our previous 3D objects, to show any one panel, we need only to apply the reverse transform on the carousel.\n\n{% highlight css %}\n/* show fifth cell */\n.carousel {\n  transform: translateZ(-288px) rotateY(-160deg);\n}\n{% endhighlight %}\n\n<div class=\"demo demo--rotate-carousel\">\n  <div class=\"scene scene--carousel\">\n    <div class=\"carousel\">\n      <div class=\"carousel__cell\">1</div>\n      <div class=\"carousel__cell\">2</div>\n      <div class=\"carousel__cell\">3</div>\n      <div class=\"carousel__cell\">4</div>\n      <div class=\"carousel__cell\">5</div>\n      <div class=\"carousel__cell\">6</div>\n      <div class=\"carousel__cell\">7</div>\n      <div class=\"carousel__cell\">8</div>\n      <div class=\"carousel__cell\">9</div>\n    </div>\n  </div>\n  <p style=\"text-align: center;\">\n    <button class=\"previous-button\">Previous</button>\n    <button class=\"next-button\">Next</button>\n  </p>\n</div>\n\n{% include edit-codepen.html pen_slug=\"jxwELK\" %}\n\n## 3D Carousel with JavaScript\n\nBy now, you probably are thinking how re-writing transform styles for each panel is tedious. And you're absolutely right. The repetitive nature of 3D objects lend themselves to scripting. We can offload all the monotonous transform styles to our JavaScript, which, if done right, will be more flexible than the hard-coded version.\n\n<div class=\"demo demo--dynamic-carousel\">\n  <div class=\"scene scene--carousel\">\n    <div class=\"carousel carousel--dynamic\">\n      <div class=\"carousel__cell\">1</div>\n      <div class=\"carousel__cell\">2</div>\n      <div class=\"carousel__cell\">3</div>\n      <div class=\"carousel__cell\">4</div>\n      <div class=\"carousel__cell\">5</div>\n      <div class=\"carousel__cell\">6</div>\n      <div class=\"carousel__cell\">7</div>\n      <div class=\"carousel__cell\">8</div>\n      <div class=\"carousel__cell\">9</div>\n      <div class=\"carousel__cell\">10</div>\n      <div class=\"carousel__cell\">11</div>\n      <div class=\"carousel__cell\">12</div>\n      <div class=\"carousel__cell\">13</div>\n      <div class=\"carousel__cell\">14</div>\n      <div class=\"carousel__cell\">15</div>\n    </div>\n  </div>\n  <div class=\"dynamic-carousel-options\">\n    <p>\n      <label>\n        Cells\n        <input class=\"cells-range\" type=\"range\" min=\"3\" max=\"15\" value=\"9\" />\n      </label>\n    </p>\n    <p>\n      <button class=\"previous-button\">Previous</button>\n      <button class=\"next-button\">Next</button>\n    </p>\n    <p>\n      Orientation:\n      <label>\n        <input type=\"radio\" name=\"orientation\" value=\"horizontal\" checked />\n        horizontal\n      </label>\n      <label>\n        <input type=\"radio\" name=\"orientation\" value=\"vertical\" />\n        vertical\n      </label>\n    </p>\n  </div>\n</div>\n\n{% include edit-codepen.html pen_slug=\"wjeBpp\" %}\n\nNot only can we change the number of cells, we can even change the orientation of the carousel from horizontal to vertical. Perfect for The Price is Right wheel.\n\n* * *\n\n[**Next: Conclusion &rarr;**](conclusion)\n"
        },
        {
          "name": "conclusion.md",
          "type": "blob",
          "size": 1.1484375,
          "content": "---\n\ntitle: Conclusion\nlayout: doc\nslug: conclusion\ncategory: docs\nredirect_from:\n  - \"/docs/conclusion.html\"\n\n---\n\n\n3D transforms change how we approach blank canvas of web design. Or rather, they change canvas itself, trading in the flat surface for an voluminous installation.\n\nMy hope is that you took at least one peak a demo and were intrigued. We web designers, who have rejoiced for border-radius, box-shadow, and background gradient, now have an incredible tool at our disposal in 3D transforms. They deserve just the same enthusiasm, research, and experimentation we have spent on the previous browser features. Now is the perfect time to start leveraging three dimensions and elevate our craft. I'm enthralled to witness what's to come.\n\nSee you on the flip side.\n\n* * *\n\n## About the author\n\n[**David DeSandro**](https://desandro.com) is the author of [Masonry](https://masonry.desandro.com), [Isotope](https://isotope.metafizzy.co), and [Flickity](https://flickity.metafizzy.co), some of the most popular open-source plugins on the web. He runs [Metafizzy](https://metafizzy.co), where he supports the plugins and designs logos. He lives in Alexandria, Virginia.\n"
        },
        {
          "name": "css",
          "type": "tree",
          "content": null
        },
        {
          "name": "cube.md",
          "type": "blob",
          "size": 8.7744140625,
          "content": "---\n\ntitle: Cube\nlayout: doc\nslug: cube\nredirect_from:\n - \"/docs/cube.html\"\n - \"/examples/cube-01-steps.html\"\n - \"/examples/cube-02-show-sides.html\"\n - \"/examples/transforms-02-pixelation.html\"\n\n---\n\nCards are a good start for working with 3D transforms, but they only show off 3D in transition. To show off 3D at rest, we'll have to create true 3D objects: prisms. We'll start with a cube.\n\nThe markup for the cube is similar to the card. This time we need 6 child elements for all 6 faces of the cube.\n\n{% highlight html %}\n<div class=\"scene\">\n  <div class=\"cube\">\n    <div class=\"cube__face cube__face--front\">front</div>\n    <div class=\"cube__face cube__face--back\">back</div>\n    <div class=\"cube__face cube__face--right\">right</div>\n    <div class=\"cube__face cube__face--left\">left</div>\n    <div class=\"cube__face cube__face--top\">top</div>\n    <div class=\"cube__face cube__face--bottom\">bottom</div>\n  </div>\n</div>\n{% endhighlight %}\n\n<div class=\"scene\">\n  <div class=\"cube cube--step0\">\n    <div class=\"cube__face cube__face--front\">front</div>\n    <div class=\"cube__face cube__face--back\">back</div>\n    <div class=\"cube__face cube__face--right\">right</div>\n    <div class=\"cube__face cube__face--left\">left</div>\n    <div class=\"cube__face cube__face--top\">top</div>\n    <div class=\"cube__face cube__face--bottom\">bottom</div>\n  </div>\n</div>\n\nBasic position and size styles set the 6 faces on top of one another in the container.\n\n{% highlight css %}\n.scene {\n  width: 200px;\n  height: 200px;\n  perspective: 600px;\n}\n\n.cube {\n  width: 100%;\n  height: 100%;\n  position: relative;\n  transform-style: preserve-3d;\n}\n\n.cube__face {\n  position: absolute;\n  width: 200px;\n  height: 200px;\n}\n{% endhighlight %}\n\n<div class=\"scene scene--cube\">\n  <div class=\"cube cube--step1\">\n    <div class=\"cube__face cube__face--front\">front</div>\n    <div class=\"cube__face cube__face--back\">back</div>\n    <div class=\"cube__face cube__face--right\">right</div>\n    <div class=\"cube__face cube__face--left\">left</div>\n    <div class=\"cube__face cube__face--top\">top</div>\n    <div class=\"cube__face cube__face--bottom\">bottom</div>\n  </div>\n</div>\n\nNow all the faces are placed on top of one another, ready to be rotated. `.cube__face--top` and `.cube__face--bottom` will use `rotateX()` so they are rotated around the vertical X axis.\n\n{% highlight css %}\n.cube__face--front  { transform: rotateY(  0deg); }\n.cube__face--right  { transform: rotateY( 90deg); }\n.cube__face--back   { transform: rotateY(180deg); }\n.cube__face--left   { transform: rotateY(-90deg); }\n.cube__face--top    { transform: rotateX( 90deg); }\n.cube__face--bottom { transform: rotateX(-90deg); }\n{% endhighlight %}\n\n<div class=\"scene scene--cube\">\n  <div class=\"cube cube--step2\">\n    <div class=\"cube__face cube__face--front\">front</div>\n    <div class=\"cube__face cube__face--back\">back</div>\n    <div class=\"cube__face cube__face--right\">right</div>\n    <div class=\"cube__face cube__face--left\">left</div>\n    <div class=\"cube__face cube__face--top\">top</div>\n    <div class=\"cube__face cube__face--bottom\">bottom</div>\n  </div>\n</div>\n\n(We could remove the `rotateY(  0deg)` style, as this transform has no effect, but let's leave it in for consistency.)\n\nNow that faces are rotated, only the front and back faces are visible. The 4 side faces are all perpendicular to the viewer, so they appear on-edge, near-invisible. To push them out to their appropriate sides, they need to be translated out from the center of their positions. Each side of the cube is 200px wide. From the cube's center they'll need to be translated out half that distance, `100px`.\n\n{% highlight css %}\n.cube__face--front  { transform: rotateY(  0deg) translateZ(100px); }\n.cube__face--right  { transform: rotateY( 90deg) translateZ(100px); }\n.cube__face--back   { transform: rotateY(180deg) translateZ(100px); }\n.cube__face--left   { transform: rotateY(-90deg) translateZ(100px); }\n.cube__face--top    { transform: rotateX( 90deg) translateZ(100px); }\n.cube__face--bottom { transform: rotateX(-90deg) translateZ(100px); }\n{% endhighlight %}\n\n<div class=\"scene scene--cube\">\n  <div class=\"cube cube--step3\">\n    <div class=\"cube__face cube__face--front\">front</div>\n    <div class=\"cube__face cube__face--right\">right</div>\n    <div class=\"cube__face cube__face--back\">back</div>\n    <div class=\"cube__face cube__face--left\">left</div>\n    <div class=\"cube__face cube__face--top\">top</div>\n    <div class=\"cube__face cube__face--bottom\">bottom</div>\n  </div>\n</div>\n\nNote here that the `translate` function comes _after_ the `rotate`. The order of transform functions is meaningful. Each face is first rotated towards its position, then translated outward in a separate direction.\n\nWe have rendered a cube, but we're not done yet.\n\n## Un-fuzzing 3D transformed text\n\nTake another look at the text \"front\" in the above cube. It's fuzzy.\n\n3D transforms affect text rendering. When you apply a 3D transform, browsers take a snap-shot of the element and then re-render those pixels with 3D transforms applied. As such, fonts don't have the same anti-aliasing given their transformed size.\n\n<div style=\"overflow-x: hidden\">\n  <p class=\"pixelation-p\" style=\"font-size: 2em\">font-size: 2.5em</p>\n  <p class=\"pixelation-p\" style=\"transform: scale(2)\">transform: scale(2.5)</p>\n  <p class=\"pixelation-p\" style=\"transform: perspective(500px) translateZ(250px)\"> transform: perspective(500px) translateZ(250px)</p>\n</div>\n\nFor the sake of our users, 3D transforms should not distort the interface. To resolve the distortion and restore pixel perfection to our cube, we can push back the 3D object, so that the front face will be positioned back at the Z origin.\n\n{% highlight css %}\n.cube { transform: translateZ(-100px); }\n{% endhighlight %}\n\n<div class=\"scene scene--cube\">\n  <div class=\"cube\">\n    <div class=\"cube__face cube__face--front\">front</div>\n    <div class=\"cube__face cube__face--right\">right</div>\n    <div class=\"cube__face cube__face--back\">back</div>\n    <div class=\"cube__face cube__face--left\">left</div>\n    <div class=\"cube__face cube__face--top\">top</div>\n    <div class=\"cube__face cube__face--bottom\">bottom</div>\n  </div>\n</div>\n\n## Rotating the cube\n\nTo expose any face of the cube, we'll need a style that rotates the cube to show that face. The transform is the opposite of the corresponding face. We toggle the necessary class on the `.cube` to apply the appropriate transform.\n\n{% highlight css %}\n.cube.show-front  { transform: translateZ(-100px) rotateY(   0deg); }\n.cube.show-right  { transform: translateZ(-100px) rotateY( -90deg); }\n.cube.show-back   { transform: translateZ(-100px) rotateY(-180deg); }\n.cube.show-left   { transform: translateZ(-100px) rotateY(  90deg); }\n.cube.show-top    { transform: translateZ(-100px) rotateX( -90deg); }\n.cube.show-bottom { transform: translateZ(-100px) rotateX(  90deg); }\n{% endhighlight %}\n\nNotice how the order of the transform functions has reversed. First we push the object back with `translateZ`, then we rotate it.\n\nFinishing up, we can add a transition to animate the rotation between states.\n\n{% highlight css %}\n.cube { transition: transform 1s; }\n{% endhighlight %}\n\n<div class=\"demo demo--rotate-cube\">\n  <div class=\"scene scene--cube\">\n    <div class=\"cube cube--rotate\">\n      <div class=\"cube__face cube__face--front\">front</div>\n      <div class=\"cube__face cube__face--back\">back</div>\n      <div class=\"cube__face cube__face--right\">right</div>\n      <div class=\"cube__face cube__face--left\">left</div>\n      <div class=\"cube__face cube__face--top\">top</div>\n      <div class=\"cube__face cube__face--bottom\">bottom</div>\n    </div>\n  </div>\n  <p class=\"radio-button-group\">\n    <label>\n      <input type=\"radio\" name=\"rotate-cube-side\" value=\"front\" checked /> front\n    </label>\n    <label>\n      <input type=\"radio\" name=\"rotate-cube-side\" value=\"right\" /> right\n    </label>\n    <label>\n      <input type=\"radio\" name=\"rotate-cube-side\" value=\"back\" /> back\n    </label>\n    <label>\n      <input type=\"radio\" name=\"rotate-cube-side\" value=\"left\" /> left\n    </label>\n    <label>\n      <input type=\"radio\" name=\"rotate-cube-side\" value=\"top\" /> top\n    </label>\n    <label>\n      <input type=\"radio\" name=\"rotate-cube-side\" value=\"bottom\" /> bottom\n    </label>\n  </p>\n</div>\n<script>\n( function() {\n  var demo = document.querySelector('.demo--rotate-cube');\n  var cube = demo.querySelector('.cube');\n  var currentClass = '';\n\n  function changeSide() {\n    var checkedRadio = demo.querySelector(':checked');\n    var showClass = 'show-' + checkedRadio.value;\n    if ( currentClass ) {\n      cube.classList.remove( currentClass );\n    }\n    cube.classList.add( showClass );\n    currentClass = showClass;\n  }\n  // set initial side\n  changeSide();\n\n  demo.addEventListener( 'change', changeSide );\n})();\n</script>\n\n{% include edit-codepen.html pen_slug=\"KRWjzm\" %}\n\n![CSS 3D cube object changing sides](../img/cube02.png)\n\n* * *\n\n[**Next: Box &rarr;**](box)\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.md",
          "type": "blob",
          "size": 3.28125,
          "content": "---\n\ntitle: Introduction\nlayout: doc\nis_homepage: true\nslug: intro\nredirect_from:\n  - \"/docs/introduction\"\n\n---\n\nWith the introduction of CSS transforms, elements could be shifted, rotated, slanted, squashed and stretched. Web designers were finally able to catch up to print designers. With CSS 3D transforms, web designers can move past their print counterparts and explore a new realm in graphic design.\n\nRendering 3D graphics on the web has been around for years. First there was Flash. Then with  `<canvas>` and WebGL came [Three.js](https://threejs.org/). WebVR and augmented reality lie around the corner. While these solutions are superb at producing explorable 3D environments, they can be overkill for the main stuff of the web: interfaces. With CSS 3D transforms, front-end developers can enhance their designs by adding a new dimension to traditional websites.\n\n## Rationale\n\nBefore we dive into the third dimension, we owe it to our users to ask how they benefit from this feature.\n\nLet's be real. CSS was built to style documents. It has since grown to handle applications. But alas, CSS is not ideal for 3D modeling. Instead, 3D transforms should be treated just like its fellow modern features like media queries, gradients, and transitions â€” as an **add-on.** 3D for websites works best when it adds to your interface, not replaces it. There is plenty of opportunity to use 3D transforms _in between_ the interface, via transitions.\n\nTake for instance the Weather App for early iOS. The application used two views: a details view and an options view. Switching between these two views was done with a 3D flip transition. This afforded the user that the interface had two and only two views, one on each side of the panel.\n\n![iPhone Weather App 3D flip transition](../img/weather-app-transition.jpg)\n\nAlso consider carousel cycle plugins. How can you communicate how the slides wrap around to repeat? With 3D, slides are placed side by side one another in a circle in 3D space. In that arrangement, the cyclic pattern of the carousel is self-evident.\n\n3D transforms can be more than just eye candy. We can use them to solve actual interface challenges and make our applications more intuitive.\n\n## Current Support Environment\n\n[The CSS 3D transforms module](https://www.w3.org/TR/css-transforms-1/) was first [introduced in 2009](https://www.w3.org/TR/2009/WD-css3-3d-transforms-20090320/). It was authored by members at Apple and was first supported by Safari. Since then, all modern browsers including Chrome, Firefox, Internet Explorer and Edge have added support. View the chart on [caniuse.com/#feat=transforms3d](https://caniuse.com/#feat=transforms3d) to check the latest support environment across the browser landscape.\n\nAs of 2018, un-prefixed `transform` CSS properties are supported by 98% of browsers in use. Adding `-webkit-transform` will capture older browsers to get to 99%.\n\nThere is one caveat. [Internet Explorer 11 does not support `transform-style: preserve-3d`](http://msdn.microsoft.com/en-us/library/ie/hh673529%28v=vs.85%29.aspx#the_ms_transform_style_property) (we'll cover this property later). This means IE11 can still use 3D transforms with individual elements, but cannot handle nested elements to build the objects covered in this essay.\n\nLet's get coding.\n\n* * *\n\n[**Next: Perspective &rarr;**](perspective)\n"
        },
        {
          "name": "js",
          "type": "tree",
          "content": null
        },
        {
          "name": "perspective.md",
          "type": "blob",
          "size": 6.015625,
          "content": "---\n\ntitle: Perspective\nlayout: doc\nslug: perspective\nscript: perspective.js\nredirect_from:\n  - \"/docs/perspective.html\"\n  - \"/examples/perspective-01.html\"\n  - \"/examples/perspective-02-children.html\"\n  - \"/examples/perspective-03.html\"\n\n---\n\n\nTo activate 3D space, an element needs perspective.  This can be applied in two ways.\n\nThe first technique is with the [`transform` property](https://developer.mozilla.org/en-US/docs/Web/CSS/transform), with `perspective()` as a function:\n\n\n{% highlight css %}\ntransform: perspective(400px);\n{% endhighlight %}\n\nFor example:\n\n{% highlight css %}\n.panel--red {\n  /* perspective function in transform property */\n  transform: perspective(400px) rotateY(45deg);\n}\n{% endhighlight %}\n\n<div class=\"scene scene--set-persp\">\n  <div class=\"set-persp-panel set-persp-panel--red\"></div>\n</div>\n\n{% include edit-codepen.html pen_slug=\"XqMGRB\" %}\n\nThe second technique is with the [`perspective` property](https://developer.mozilla.org/en-US/docs/Web/CSS/perspective):\n\n{% highlight css %}\nperspective: 400px;\n{% endhighlight %}\n\nFor example:\n\n{% highlight css %}\n.scene--blue {\n  /* perspective property */\n  perspective: 400px;\n}\n\n.panel--blue {\n  transform: rotateY(45deg);\n}\n{% endhighlight %}\n\n<div class=\"scene scene--set-persp scene--set-persp--blue\">\n  <div class=\"set-persp-panel set-persp-panel--blue\"></div>\n</div>\n\n{% include edit-codepen.html pen_slug=\"PepLOz\" %}\n\nThese two formats both trigger a 3D space and can produce the same visual result. But there is a difference. The functional notation is convenient for directly applying a 3D transform on a single element (in the red example, I use it in conjunction with a `rotateY` transform). In this way, it is used as a shorthand to transform a single element in 3D.\n\nBut when used on multiple elements, the effect breaks. The transformed elements don't line up together. This is because each element has its own perspective, its own vanishing point. To remedy this, use the `perspective` property on a parent element, so each child may share the same 3D space.\n\n{% highlight css %}\n.panel--separate {\n  transform: perspective(400px) rotateY(45deg);\n}\n{% endhighlight %}\n\n<div class=\"scene scene--persp-children\">\n  <div class=\"persp-children-panel persp-children-panel--separate\"></div>\n  <div class=\"persp-children-panel persp-children-panel--separate\"></div>\n  <div class=\"persp-children-panel persp-children-panel--separate\"></div>\n  <div class=\"persp-children-panel persp-children-panel--separate\"></div>\n  <div class=\"persp-children-panel persp-children-panel--separate\"></div>\n  <div class=\"persp-children-panel persp-children-panel--separate\"></div>\n  <div class=\"persp-children-panel persp-children-panel--separate\"></div>\n  <div class=\"persp-children-panel persp-children-panel--separate\"></div>\n  <div class=\"persp-children-panel persp-children-panel--separate\"></div>\n</div>\n\n{% include edit-codepen.html pen_slug=\"WJpmdO\" %}\n\n{% highlight css %}\n.scene--together {\n  perspective: 400px;\n}\n\n.panel--together {\n  transform: rotateY(45deg);\n}\n{% endhighlight %}\n\n<div class=\"scene scene--persp-children scene--persp-children--together\">\n  <div class=\"persp-children-panel persp-children-panel--together\"></div>\n  <div class=\"persp-children-panel persp-children-panel--together\"></div>\n  <div class=\"persp-children-panel persp-children-panel--together\"></div>\n  <div class=\"persp-children-panel persp-children-panel--together\"></div>\n  <div class=\"persp-children-panel persp-children-panel--together\"></div>\n  <div class=\"persp-children-panel persp-children-panel--together\"></div>\n  <div class=\"persp-children-panel persp-children-panel--together\"></div>\n  <div class=\"persp-children-panel persp-children-panel--together\"></div>\n  <div class=\"persp-children-panel persp-children-panel--together\"></div>\n</div>\n\n{% include edit-codepen.html pen_slug=\"MGpxVG\" %}\n\nThe value of `perspective` determines the intensity of the 3D effect. Think of it as a distance from the viewer to the object. The greater the value, the further the distance, the less intense the visual effect. `perspective: 2000px` yields a subtle 3D effect, as if we are viewing an object from far away through binoculars. `perspective: 100px` produces a tremendous 3D effect, like a tiny insect viewing a massive object.\n\nYou can also use 3D transforms without perspective, either by setting `perspective: none` or not setting `perspective` at all. Without perspective, parallel planes are orthogonal and have no vanishing point.\n\nBy default, the vanishing point for a 3D space is positioned at the center. You can change the position of the vanishing point with [`perspective-origin` property](https://developer.mozilla.org/en-US/docs/Web/CSS/perspective-origin).\n\n{% highlight css %}\n\nperspective-origin: 25% 75%;\n\n{% endhighlight %}\n\n<div class=\"demo demo--persp-cube\">\n  <div class=\"scene scene--cube scene--persp-cube\">\n    <div class=\"cube is-spinning\">\n      <div class=\"cube__face cube__face--front\">front</div>\n      <div class=\"cube__face cube__face--back\">back</div>\n      <div class=\"cube__face cube__face--right\">right</div>\n      <div class=\"cube__face cube__face--left\">left</div>\n      <div class=\"cube__face cube__face--top\">top</div>\n      <div class=\"cube__face cube__face--bottom\">bottom</div>\n    </div>\n  </div>\n  <p>\n    <label>\n      perspective\n      <input class=\"perspective-range\" type=\"range\" min=\"1\" max=\"1000\" value=\"400\" data-units=\"px\" />\n    </label>\n  </p>\n  <p>\n    <label>\n      perspective-origin x\n      <input class=\"origin-x-range\" type=\"range\" min=\"0\" max=\"100\" value=\"50\" data-units=\"%\" />\n    </label>\n  </p>\n  <p>\n    <label>\n      perspective-origin y\n      <input class=\"origin-y-range\" type=\"range\" min=\"0\" max=\"100\" value=\"50\" data-units=\"%\" />\n    </label>\n  </p>\n  <p>\n    <label>\n      Spin cube\n      <input class=\"spin-cube-checkbox\" type=\"checkbox\" />\n    </label>\n  </p>\n  <p>\n    <label>\n      Backface visible\n      <input class=\"backface-checkbox\" type=\"checkbox\" checked />\n    </label>\n  </p>\n</div>\n\n{% include edit-codepen.html pen_slug=\"bMqZmr\" %}\n\n* * *\n\n[**Next: 3D transform functions &rarr;**](3d-transform-functions)\n"
        }
      ]
    }
  ]
}