{
  "metadata": {
    "timestamp": 1736711577660,
    "page": 136,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "littleosbook/littleosbook",
      "stars": 2256,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0419921875,
          "content": "book.html\nbook.pdf\nheader.log\n\n# vim\n*.swp\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.25,
          "content": "CSS = book.css\nHTML_TEMPLATE = template.html\nTEX_HEADER = header.tex\nCHAPTERS = title.txt introduction.md environment_and_booting.md \\\n\t\t   getting_to_c.md output.md segmentation.md interrupts.md \\\n\t\t   the_road_to_user_mode.md virtual_memory.md \\\n\t\t   paging.md page_frame_allocation.md user_mode.md file_systems.md \\\n\t\t   syscalls.md scheduling.md \\\n\t\t   references.md\nBIB = bibliography.bib\nCITATION = citation_style.csl\n\nall: book.html\n\nbook.html: $(CHAPTERS) $(CSS) $(HTML_TEMPLATE) $(BIB) $(CITATION)\n\tpandoc -s -S --toc -c $(CSS) --template $(HTML_TEMPLATE) \\\n\t\t   --bibliography $(BIB) --csl $(CITATION) --number-sections \\\n\t\t   $(CHAPTERS) -o $@\n\nbook.pdf: $(CHAPTERS) $(TEX_HEADER) $(BIB) $(CITATION)\n\tpandoc --toc -H $(TEX_HEADER) --latex-engine=pdflatex --chapters \\\n\t\t   --no-highlight --bibliography $(BIB) --csl $(CITATION) \\\n\t\t   $(CHAPTERS) -o $@\n\nff: book.html\n\tfirefox book.html\n\nrelease: book.html book.pdf\n\tmkdir -p ../littleosbook.github.com/images\n\tcp images/*.png ../littleosbook.github.com/images/\n\tmkdir -p ../littleosbook.github.com/files\n\tcp files/* ../littleosbook.github.com/files/\n\tcp book.pdf ../littleosbook.github.com/\n\tcp book.html ../littleosbook.github.com/index.html\n\tcp book.css ../littleosbook.github.com/\n\nclean:\n\trm -f book.pdf book.html\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.076171875,
          "content": "# littleosbook\n\nThis is the source code for the book \"The little book about OS development\".\nThe source for the book is written in\n[\"Pandoc\"](http://johnmacfarlane.net/pandoc/) Markdown.\n\n## Building\nIf you want to use the build scripts (which we recommend you to do), you need\n[\"Make\"](http://www.gnu.org/software/make/).\n\nTo convert the Markdown to either HTML or PDF, you need to have\n[\"Pandoc\"](http://johnmacfarlane.net/pandoc/) version 1.9.1.1 or higher. For\ninstalling Pandoc, see <http://johnmacfarlane.net/pandoc/installing.html>.\n\nIf you want to create the PDF version, you also need `pdflatex` installed.\n\n## Errors\nIf you find any error (there are probably plenty :)), please open a new\n[\"issue\"](https://github.com/littleosbook/littleosbook/issues).\n\n## Contributing\nIf you want to contribute new material or fix some errors, please open fork the\nrepository, make your changes and open a pull request.\n\n## License\nAll content is licensed under the Creative Commons Attribute, NonCommercial,\nShare-Alike license. See <http://creativecommons.org/licenses/by-nc-sa/3.0/us/>\nfor more details.\n"
        },
        {
          "name": "bibliography.bib",
          "type": "blob",
          "size": 5.5146484375,
          "content": "@book{ostanenbaum,\n    author = \"Andrew Tanenbaum\",\n    title = \"Modern Operating Systems, 3rd edition\",\n    year = \"2007\",\n    publisher = \"Prentice Hall, Inc.\"\n}\n\n@misc{osdev,\n    author = \"OSDev\",\n    title = \"OSDev\",\n    url = \"http://wiki.osdev.org/Main_Page\"\n}\n\n@misc{malloy,\n    author = \"James Molloy\",\n    title = \"James M's kernel development tutorial\",\n    url = \"http://www.jamesmolloy.co.uk/tutorial_html/\"\n}\n\n@misc{wiki:c,\n    author = \"Wikipedia\",\n    title = \"C (programming language)\",\n    url = \"http://en.wikipedia.org/wiki/C_(programming_language)\"\n}\n\n@misc{wiki:bios,\n    author = \"Wikipedia\",\n    title = \"BIOS\",\n    url = \"https://en.wikipedia.org/wiki/BIOS\"\n}\n\n@misc{bochs,\n    author = \"Volker Ruppert\",\n    title = \"bochs: The Open Souce IA-32 emulation project\",\n    url = \"http://bochs.sourceforge.net/\"\n}\n\n@misc{qemu,\n    author = \"QEMU\",\n    title = \"QEMU\",\n    url = \"http://wiki.qemu.org/Main_Page\"\n}\n\n@misc{gcc,\n    author = \"Free Software Foundation\",\n    title = \"GCC, the GNU Compiler Collection\",\n    url = \"http://gcc.gnu.org/\"\n}\n\n@misc{virtualbox,\n    author = \"Oracle\",\n    title = \"Oracle VM VirtualBox\",\n    url = \"http://www.virtualbox.org/\"\n}\n\n@misc{ubuntu,\n    author = \"Canonical Ltd\",\n    title = \"Ubuntu\",\n    url = \"http://www.ubuntu.com/\"\n}\n\n@misc{nasm,\n    author = \"NASM\",\n    title = \"NASM: The Netwide Assembler\",\n    url = \"http://www.nasm.us/\"\n}\n\n@misc{make,\n    author = \"Free Software Foundation\",\n    title = \"GNU Make\",\n    url = \"http://www.gnu.org/software/make/\"\n}\n\n@misc{grub,\n    author = \"Free Software Foundation\",\n    title = \"GNU GRUB\",\n    url = \"http://www.gnu.org/software/grub/\"\n}\n\n@misc{multiboot,\n    author = \"Free Software Foundation\",\n    title = \"Multiboot Specification version 0.6.96\",\n    url = \"http://www.gnu.org/software/\n           grub/manual/multiboot/multiboot.html\"\n}\n\n@misc{wiki:iso,\n    author = \"Wikipedia\",\n    title = \"ISO image\",\n    url = \"http://en.wikipedia.org/wiki/ISO_image\"\n}\n\n@misc{intel3a,\n    author = \"Intel\",\n    title = \"Intel 64 and IA-32 Architectures Software Developer's Manual Vol. 3A\",\n    url = \"http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html\"\n}\n\n@misc{ldcmdlang,\n    author = \"Steve Chamberlain\",\n    title = \"Using ld, the GNU linker\",\n    url = \"http://www.math.utah.edu/docs/info/ld_toc.html\",\n}\n\n@misc{wiki:elf,\n    author = \"Wikipedia\",\n    title = \"Executable and Linkable Format\",\n    url = \"http://en.wikipedia.org/wiki/Executable_and_Linkable_Format\"\n}\n\n@book{knr,\n    author = \"Brian W. Kernighan, Dennis M. Ritchie\",\n    title = \"The C Programming Language, Second Edition\",\n    year = \"1988\",\n    publisher = \"Prentice Hall, Inc.\"\n}\n\n@misc{wiki:fb,\n\tauthor = \"Wikipedia\",\n\ttitle = \"Framebuffer\",\n\turl = \"http://en.wikipedia.org/wiki/Framebuffer\"\n}\n\n@misc{wiki:ascii,\n\tauthor = \"Wikipedia\",\n\ttitle = \"ASCII\",\n\turl = \"https://en.wikipedia.org/wiki/Ascii\"\n}\n\n@misc{osdev:serial,\n    author = \"OSDev\",\n    title = \"Serial Ports\",\n    url = \"http://wiki.osdev.org/Serial_ports\"\n}\n\n@misc{acm,\n    author = \"SIGOPS\",\n    title = \"i386 Interrupt Handling\",\n    url = \"http://www.acm.uiuc.edu/sigops/roll_your_own/i386/irq.html\"\n}\n\n@misc{nasm:macros,\n    author = \"NASM\",\n    title = \"Multi-Line Macros\",\n    url = \"http://www.nasm.us/doc/nasmdoc4.html#section-4.3\"\n}\n\n@misc{resb,\n    author = \"NASM\",\n    title = \"RESB and Friends: Declaring Uninitialized Data\",\n    url = \"http://www.nasm.us/doc/nasmdoc3.htm\"\n}\n\n@misc{scancodes,\n    author = \"Andries Brouwer\",\n    title = \"Keyboard scancodes\",\n    url = \"http://www.win.tue.nl/\"\n}\n\n@misc{wiki:serial,\n    author = \"Wikipedia\",\n    title = \"Serial port\",\n    url = \"http://en.wikipedia.org/wiki/Serial_port\"\n}\n\n@misc{wiki:ccall,\n    author = \"Wikipedia\",\n    title = \"x86 calling conventions\",\n    url = \"http://en.wikipedia.org/wiki/X86_calling_conventions\"\n}\n\n@misc{osdev:pit,\n    author = \"OSDev\",\n    title = \"Programmable Interval Timer\",\n    url = \"http://wiki.osdev.org/Programmable_Interval_Timer\"\n}\n\n@misc{ubuntu-grub,\n    author = \"Lars Nodeen\",\n    title = \"Bug #426419: configure: error: GRUB requires a working absolute\n        objcopy\",\n    url = \"https://bugs.launchpad.net/ubuntu/+source/grub/+bug/426419\"\n}\n\n@misc{bochs-config,\n    author = \"Bochs\",\n    title = \"bochsrc\",\n    url = \"http://bochs.sourceforge.net/doc/docbook/user/bochsrc.html\"\n}\n\n@misc{wikibook:serial,\n    author = \"WikiBooks\",\n    title = \"Serial Programming/8250 UART Programming\",\n    url = \"http://en.wikibooks.org/wiki/Serial_Programming/\n      8250_UART_Programming\"\n}\n\n@misc{gnubinutils,\n    author = \"GNU\",\n    title = \"GNU Binutils\",\n    url = \"http://www.gnu.org/software/binutils/\"\n}\n\n@misc{clang,\n    author = \"LLVM\",\n    title = \"clang: a C language family frontend for LLVM\",\n    url = \"http://clang.llvm.org/\"\n}\n\n@misc{osdev:pfa,\n    author = \"OSDev\",\n    title = \"Page Frame Allocation\",\n    url = \"http://wiki.osdev.org/Page_Frame_Allocation\"\n}\n\n@misc{wiki:bash,\n    author = \"Wikipedia\",\n    title = \"Bash\",\n    url = \"http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29\"\n}\n\n@misc{wiki:vga-compat,\n    author = \"Wikipedia\",\n    title = \"VGA-compatible text mode\",\n    url = \"http://en.wikipedia.org/wiki/VGA-compatible_text_mode\"\n}\n\n@misc{osdev:vga,\n    author = \"OSDev\",\n    title = \"VGA Hardware\",\n    url = \"http://wiki.osdev.org/VGA_Hardware\"\n}\n\n@misc{wiki:hex,\n    author = \"Wikipedia\",\n    title = \"Hexadecimal\",\n    url = \"http://en.wikipedia.org/wiki/Hexadecimal\"\n}\n\n@misc{kth,\n    author = \"\",\n    title = \"The Royal Institute of Technology\",\n    url = \"http://www.kth.se\"\n}\n"
        },
        {
          "name": "book.css",
          "type": "blob",
          "size": 6.2861328125,
          "content": "body {\n  font-family:\"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  background: #dda;\n  color: #222;\n}\n\na {\n    color: black;\n}\n\nh1 a {\n\ttext-decoration: none\n}\n\nh2 a {\n\ttext-decoration: none\n}\n\nh3 a {\n\ttext-decoration: none\n}\n\na:visited {\n  color: #444;\n}\n\n#TOC a {\n\ttext-decoration: underline\n}\n\n.more { font-size: 0.7em;}\n\nimg.right {\n  float: right;\n  margin: 15px;\n}\n\n#header {\n  font-family: Courier;\n  text-align: left;\n  background: #222;\n  -moz-border-radius-topleft: 0.4em;\n  -webkit-border-top-left-radius: 0.4em;\n  -moz-border-radius-topright: 0.4em;\n  -webkit-border-top-right-radius: 0.4em;\n  border-top-left-radius: 0.4em;\n  border-top-right-radius: 0.4em;\n  padding: 1em;\n  text-align: center;\n}\n\n#header h1 {\n  font-size: 2.2em;\n  color: #fff;\n  font-weight: normal;\n}\n\n#header h2 {\n  font-size: 1.5em;\n  margin-left: 0.5em;\n  font-weight: normal;\n  color: #dd5;\n}\n\n#header h3 {\n  margin-left: 0.5em;\n  font-weight: normal;\n  color: #dd5;\n}\n\n#wrapper {\n  width: 50em;\n  margin: 2em auto 0;\n  padding: 0;\n  background: #fff;\n  -moz-border-radius: 0.4em;\n  -webkit-border-radius: 0.4em;\n  border-radius: 0.4em;\n  box-shadow: 0 3px 7px #999;\n}\n\n#menu {\n  background: #444;\n}\n\n#menu ul {\n  list-style: none;\n  margin: 0;\n  text-align: center;\n}\n\n#message {\n  padding: 20px;\n  margin: 10px 30px;\n  border: 1px solid #383;\n  background: #aea;\n  text-align: center;\n}\n\n#content {\n  padding: 2em;\n}\n\n#content h2 {\n  margin: 0 0 0.5em 0;\n  color: black;\n  font-size: 1.5em;\n}\n\n#content p {\n  line-height: 140%;\n}\n\n.subheader {\n  background: #484;\n  display: block;\n  padding: 0.4em 0.6em 0.3em;\n  font-weight: bold;\n  color: white;\n  border-bottom: 3px solid #262;\n  position: relative;\n}\n\n.subheader .pdflink {\n    text-align: right;\n    display: block;\n    float: right;\n}\n\ndiv.post {\n  margin-bottom: 2em;\n}\n\n.post h1 {\n  margin-top: 0.2em;\n}\n\n.post { color: #333; }\n\n.post h1 a {\n  text-decoration: none;\n  clear: left;\n  display: block;\n  color: black;\n  padding: 0.3em 0;\n  margin: 0 0 0.2em 0;\n  border-bottom: 1px dashed #555;\n  font-weight: bold;\n}\n\n.post br { margin-bottom: 10px;}\n\npre {\n  background: #f8f8f8;\n  border: 1px solid #E7E5DC;\n  border-width: 1px 0 4px 6px;\n  padding: 1em;\n  overflow: auto;\n  color: black;\n  line-height: 120%;\n  font-family: \"Consolas\",\"Courier New\",Courier,mono;\n  font-size: 12px;\n  letter-spacing: 0;\n}\n\n.figure .caption {\n    font-style: italic;\n}\n\ntable thead, table tbody {\n    font-size: 12px;\n}\n\ntable.has_caption {\n    position: relative;\n    padding-bottom: 30px;\n}\n\ntable.has_caption caption {\n    position: absolute;\n    bottom: 0px;\n    left: 0px;\n}\n\ntable caption {\n    font-style: italic;\n    text-align: left;\n}\n\ntable thead {\n    font-weight: bold;\n    background: #eaeaea;\n}\n\ntable th, table td {\n    padding: 8px;\n}\n\ntable.post-list {\n  width: 100%;\n  border-collapse: collapse;\n}\n\ntable.post-list a {\n  color: #262;\n  font-weight: bold;\n}\n\ntable.post-list th {\n  text-align: left;\n}\n\ntable.post-list td, table.post-list th {\n  padding: 0.5em 0.3em;\n  border-bottom: 1px solid #dba;\n}\n\ntable.post-list tr:last-child td, table.post-list tr:last-child th {\n  border-bottom: 0;\n}\n\ndiv.related {\n  margin-bottom: 2em;\n}\n\n#footer {\n  margin-bottom: 2em;\n  color: #3E423A;\n  font-size: 0.9em;\n  padding: 0.5em;\n  text-align: center;\n}\n\n.home_box {\n  float: left;\n}\n\n#content .home_box h2 {\n  background: #333;\n  padding: 0.3em 0.5em;\n  border-bottom: 3px solid #666;\n  margin-bottom: 0em;\n  color: #dd5;\n}\n\n.home_box h2 a {\n  color: #ff3;\n  margin: 0 0.2em;\n}\n\n#home_left {\n  width: 29em;\n}\n\n#home_right {\n  width: 16em;\n  margin-left: 1em;\n}\n\n.clearfix { clear: both;}\n\n#footer a {\n  color: #3E423A;\n  font-weight: normal;\n}\n\n.announce { padding: 5px; padding-bottom: 20px; padding-top: 0px; }\n\n.home_box .post h1 a {\n  font-size: 0.7em;\n}\n\n.repo {\n  background: #fff5cc;\n  border: 2px solid #dda;\n  padding: 0.7em 1em;\n  font-size: 0.8em;\n  margin: 1em 1em 0 0;\n  -moz-border-radius: 0.5em;\n  -webkit-border-radius: 0.5em;\n  border-radius: 0.5em;\n}\n.repo h3 {\n  margin: 0 0 0.3em 0;\n}\n.repo h3 a {\n  font-weight: bold;\n  color: black;\n  font-size: 1.1em;\n}\n\n#github-projects.big .repo {\n  float: left;\n  width: 25.2em;\n  margin: 1.2em 1em 0 0;\n  display: inline-block;\n  float: none;\n  vertical-align: top;\n}\n\n.float-left { float: left; }\n.float-right { float: right; }\n\na img { border: 0; }\n\nul#toc  {\n  list-style: none;\n  margin: 0;\n}\n\nul#toc ul  {\n  list-style: none;\n}\n\nul#toc a {\n  color: #333;\n}\n\n.book-ad a {\n    color: #262;\n    font-size: 1.5em;\n    text-decoration: none;\n}\n\nh3.subtitle {\n  margin-top: 15px;\n}\n\nh3.subtitle small {\n  color: #666;\n  font-size: 0.7em;\n  padding-left: 10px;\n}\n\ntable.rdata {\n  width: 95%;\n  background: #fff;\n  padding: 8px;\n  border: 1px solid #333;\n  font-size: 1.1em;\n}\n\ntable.rdata tr.level {\n  color: #0b98b4;\n  background: #def;\n}\n\ntable.rdata tr.even {\n  background: #eee;\n}\n\ntable.rdata tr th.cmd {\n  font-family: monospace;\n  text-align: left;\n}\ntable.rdata tr {\n}\n\ntable.rdata tr th {\n  padding: 8px;\n}\ntable.rdata tr td {\n  padding: 15px 8px;\n  border-left: 1px solid #def;\n}\ntable.rdata tr td.no {\n  background: #fdd;\n}\ntable.rdata tr td.yes {\n  background: #dfd;\n}\ntable.rdata tr td.yes-wd {\n  background: #aea;\n}\ntable.rdata tr td.no-wd {\n  background: #eaa;\n}\n\n.moreinfo {\n  float: right;\n  background: #eee;\n  padding: 4px;\n  margin-left: 8px;\n  margin-bottom: 10px;\n  width: 160px;\n  min-height: 170px;\n  font-size: 0.9em;\n  border: 1px solid #aaa;\n}\n\n.moreinfo .twitter {\n  display: relative;\n  padding: 8px;\n}\n.moreinfo .twitter small {\n  margin-top: 10px;\n  color: #888;\n}\n.moreinfo .twitter small a {\n  color: #888;\n}\n\n.moreinfo .book {\n  display: relative;\n  padding: 10px;\n  font-size: 0.9em;\n}\n.moreinfo img {\n  float: right;\n  padding-left: 10px;\n}\n\n.commands-index ul {\n    list-style-type: none;\n    padding-left: 20px;\n}\n\n.commands-index ul li {\n    line-height: 1.5em;\n}\n\n.commands-index ul li strong {\n    display: inline-block;\n    padding-left: 5px;\n    vertical-align: top;\n    width: 130px;\n    transition: all .2s;\n    -moz-transition: all .2s;\n    -webkit-transition: all .2s;\n}\n\n.commands-index ul li:hover strong {\n    background:#DDA;\n    border-radius: 5px;\n    -moz-border-radius: 5px;\n    -webkit-border-radius: 5px;\n}\n\n.commands-index ul li small {\n    display: inline-block;\n    width: 560px;\n}\n\n.commands-index ul li small .pagelink {\n    display: inline-block;\n    width: 50px;\n}\n"
        },
        {
          "name": "citation_style.csl",
          "type": "blob",
          "size": 6.06640625,
          "content": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<style xmlns=\"http://purl.org/net/xbiblio/csl\" class=\"in-text\" version=\"1.0\" demote-non-dropping-particle=\"sort-only\" default-locale=\"en-US\">\n  <info>\n    <title>ACM SIG Proceedings</title>\n    <id>http://www.zotero.org/styles/acm-sig-proceedings</id>\n    <link href=\"http://www.zotero.org/styles/acm-sig-proceedings\" rel=\"self\"/>\n    <author>\n      <name>Naeem Esfahani</name>\n      <email>nesfaha2@gmu.edu</email>\n      <uri>http://mason.gmu.edu/~nesfaha2/</uri>\n    </author>\n    <contributor>\n      <name>Chris Horn</name>\n      <email>chris.horn@securedecisions.com</email>\n    </contributor>\n    <category field=\"science\"/>\n    <category field=\"engineering\"/>\n    <category citation-format=\"numeric\"/>\n    <updated>2012-02-07T01:46:04+00:00</updated>\n    <link href=\"http://www.acm.org/sigs/publications/proceedings-templates\" rel=\"documentation\"/>\n    <rights>This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 License: http://creativecommons.org/licenses/by-sa/3.0/</rights>\n  </info>\n  <macro name=\"author\">\n    <choose>\n      <if type=\"webpage\">\n        <text variable=\"title\" suffix=\":\"/>\n      </if>\n      <else-if type=\"article-journal\">\n        <names variable=\"author\">\n          <name name-as-sort-order=\"all\" and=\"text\" sort-separator=\", \" initialize-with=\".\" delimiter-precedes-last=\"never\" delimiter=\", \"/>\n          <label form=\"short\" prefix=\" \" suffix=\".\" text-case=\"lowercase\" strip-periods=\"true\"/>\n          <substitute>\n            <names variable=\"editor\"/>\n            <names variable=\"translator\"/>\n          </substitute>\n        </names>\n      </else-if>\n      <else>\n        <names variable=\"author\">\n            <name />\n        </names>\n      </else>\n    </choose>\n  </macro>\n  <macro name=\"editor\">\n    <names variable=\"editor\">\n      <name initialize-with=\".\" delimiter=\", \" and=\"text\"/>\n      <label form=\"short\" prefix=\", \" text-case=\"lowercase\" suffix=\".\" strip-periods=\"true\"/>\n    </names>\n  </macro>\n  <citation collapse=\"citation-number\">\n    <sort>\n      <key variable=\"citation-number\"/>\n    </sort>\n    <layout prefix=\"[\" suffix=\"]\" delimiter=\", \">\n      <text variable=\"citation-number\"/>\n    </layout>\n  </citation>\n  <bibliography entry-spacing=\"0\" second-field-align=\"flush\" et-al-min=\"3\" et-al-use-first=\"1\">\n    <sort>\n      <key variable=\"citation-number\"/>\n    </sort>\n    <layout suffix=\",\">\n      <text variable=\"citation-number\" prefix=\"[\" suffix=\"] \"/>\n      <text macro=\"author\" suffix=\", \"/>\n      <date variable=\"issued\" suffix=\". \">\n        <date-part name=\"year\"/>\n      </date>\n      <choose>\n        <if type=\"paper-conference\">\n          <group delimiter=\". \">\n            <text variable=\"title\"/>\n            <group delimiter=\" \">\n              <text variable=\"container-title\" font-style=\"italic\"/>\n              <group delimiter=\", \">\n                <group delimiter=\", \" prefix=\"(\" suffix=\")\">\n                  <text variable=\"publisher-place\"/>\n                  <date variable=\"issued\">\n                    <date-part name=\"month\" form=\"short\" suffix=\". \" strip-periods=\"true\"/>\n                    <date-part name=\"year\"/>\n                  </date>\n                </group>\n                <text variable=\"page\"/>\n              </group>\n            </group>\n          </group>\n        </if>\n        <else-if type=\"article-journal\">\n          <group delimiter=\". \">\n            <text variable=\"title\"/>\n            <text variable=\"container-title\" font-style=\"italic\"/>\n            <group delimiter=\", \">\n              <text variable=\"volume\"/>\n              <group delimiter=\" \">\n                <text variable=\"issue\"/>\n                <date variable=\"issued\" prefix=\"(\" suffix=\")\">\n                  <date-part name=\"month\" form=\"short\" suffix=\". \" strip-periods=\"true\"/>\n                  <date-part name=\"year\"/>\n                </date>\n              </group>\n              <text variable=\"page\"/>\n            </group>\n          </group>\n        </else-if>\n        <else-if type=\"patent\">\n          <group delimiter=\". \">\n            <text variable=\"title\"/>\n            <text variable=\"number\" prefix=\"U.S. Patent #\"/>\n            <date variable=\"issued\">\n              <date-part name=\"month\" form=\"short\" suffix=\". \" strip-periods=\"true\"/>\n              <date-part name=\"day\" suffix=\", \"/>\n              <date-part name=\"year\"/>\n            </date>\n          </group>\n        </else-if>\n        <else-if type=\"thesis\">\n          <group delimiter=\". \">\n            <text variable=\"title\" font-style=\"italic\"/>\n            <text variable=\"archive_location\" prefix=\"Doctoral Thesis #\"/>\n            <text variable=\"publisher\"/>\n          </group>\n        </else-if>\n        <else-if type=\"report\">\n          <group delimiter=\". \">\n            <text variable=\"title\" font-style=\"italic\"/>\n            <text variable=\"number\" prefix=\"Technical Report #\"/>\n            <text variable=\"publisher\"/>\n          </group>\n        </else-if>\n        <else-if type=\"webpage\">\n          <group delimiter=\". \">\n            <text variable=\"URL\" font-style=\"italic\"/>\n            <date variable=\"accessed\" prefix=\"Accessed: \">\n              <date-part name=\"year\" suffix=\"-\"/>\n              <date-part name=\"month\" form=\"numeric-leading-zeros\" suffix=\"-\"/>\n              <date-part name=\"day\" form=\"numeric-leading-zeros\"/>\n            </date>\n          </group>\n        </else-if>\n        <else-if type=\"chapter paper-conference\" match=\"any\">\n          <group delimiter=\". \">\n            <text variable=\"title\"/>\n            <text variable=\"container-title\" font-style=\"italic\"/>\n            <text macro=\"editor\"/>\n            <text variable=\"publisher\"/>\n            <text variable=\"page\"/>\n          </group>\n        </else-if>\n        <else-if type=\"bill book graphic legal_case motion_picture report song\" match=\"any\">\n          <group delimiter=\". \">\n            <text variable=\"title\" font-style=\"italic\"/>\n            <text variable=\"publisher\"/>\n          </group>\n        </else-if>\n        <else>\n            <text variable=\"title\" font-style=\"italic\" suffix=\", \"/>\n            <text variable=\"url\"/>\n        </else>\n      </choose>\n    </layout>\n  </bibliography>\n</style>\n"
        },
        {
          "name": "environment_and_booting.md",
          "type": "blob",
          "size": 12.97265625,
          "content": "# First Steps\n\nDeveloping an operating system (OS) is no easy task, and the question \"How do I\neven begin to solve this problem?\" is likely to come up several times during\nthe course of the project for different problems. This chapter will help you\nset up your development environment and booting a very small (and primitive)\noperating system.\n\n## Tools\n\n### Quick Setup\nWe (the authors) have used Ubuntu [@ubuntu] as the operating system for doing\nOS development, running it both physically and virtually (using the\nvirtual machine VirtualBox [@virtualbox]). A quick way to get everything up and\nrunning is to use the same setup as we did, since we know that these tools\nwork with the samples provided in this book.\n\nOnce Ubuntu is installed, either physical or virtual, the following packages\nshould be installed using `apt-get`:\n\n~~~ {.bash}\n    sudo apt-get install build-essential nasm genisoimage bochs bochs-sdl\n~~~\n\n### Programming Languages\nThe operating system will be developed using the C programming language\n[@knr][@wiki:c], using GCC [@gcc]. We use C because developing an OS requires a very precise\ncontrol of the generated code and direct access to memory. Other languages that\nprovide the same features can also be used, but this book will only cover C.\n\nThe code will make use of one type attribute that is specific for GCC:\n\n~~~\n    __attribute__((packed))\n~~~\n\nThis attribute allows us to ensure that the compiler uses a memory layout for a\n`struct` exactly as we define it in the code. This is explained in more detail\nin the next chapter.\n\nDue to this attribute, the example code might be hard to compile using a C\ncompiler other than GCC.\n\nFor writing assembly code, we have chosen NASM [@nasm] as the assembler, since we\nprefer NASM's syntax over GNU Assembler.\n\nBash [@wiki:bash] will be used as the scripting language throughout the book.\n\n### Host Operating System\nAll the code examples assumes that the code is being compiled on a UNIX like\noperating system. All code examples have been successfully compiled using\nUbuntu [@ubuntu] versions 11.04 and 11.10.\n\n### Build System\nMake [@make] has been used when constructing the Makefile examples.\n\n### Virtual Machine\nWhen developing an OS it is very convenient to be able to run your code in a\n_virtual machine_ instead of on a physical computer, since starting your OS in\na virtual machine is much faster than getting your OS onto a physical medium\nand then running it on a physical machine.\nBochs [@bochs] is an\nemulator for the x86 (IA-32) platform which is well suited for OS development\ndue to its debugging features. Other popular choices are QEMU [@qemu] and\nVirtualBox [@virtualbox]. This book uses Bochs.\n\nBy using a virtual machine we cannot ensure that our OS works on real, physical\nhardware. The environment simulated by the virtual machine is designed to be\nvery similar to their physical counterparts, and the OS can be tested on one by\njust copying the executable to a CD and finding a suitable machine.\n\n## Booting\nBooting an operating system consists of transferring control along a\nchain of small programs, each one more \"powerful\" than the previous one, where\nthe operating system is the last \"program\". See the following figure for an\nexample of the boot process:\n\n![An example of the boot process. Each box is a program.](images/boot_chain.png)\n\n### BIOS\nWhen the PC is turned on, the computer will start a small program that adheres\nto the _Basic Input Output System_ (BIOS) [@wiki:bios] standard. This program is\nusually stored on a read only memory chip on the motherboard of the PC. The\noriginal role of the BIOS program was to export some library functions for\nprinting to the screen, reading keyboard input etc. Modern operating\nsystems do not use the BIOS' functions, they use drivers that interact\ndirectly with the hardware, bypassing the BIOS.\nToday, BIOS mainly runs some early diagnostics (power-on-self-test) and then\ntransfers control to the bootloader.\n\n### The Bootloader\nThe BIOS program will transfer control of the PC to a program called a\n_bootloader_. The bootloader's task is to transfer control to us, the operating\nsystem developers, and our code. However, due to some restrictions[^1] of the\nhardware and because of backward compatibility, the bootloader is often split\ninto two parts: the first part of the bootloader will transfer control to the\nsecond part, which finally gives control of the PC to the operating system.\n\n[^1]: The bootloader must fit into the _master boot record_ (MBR) boot sector\nof a hard drive, which is only 512 bytes large.\n\nWriting a bootloader involves writing a lot of low-level code that interacts\nwith the BIOS. Therefore, an existing bootloader will be used: the GNU GRand\nUnified Bootloader (GRUB) [@grub].\n\nUsing GRUB, the operating system can be built as an ordinary ELF [@wiki:elf]\nexecutable, which will be loaded by GRUB into the correct memory location.\nThe compilation of the kernel requires that the code is laid out in\nmemory in a specific way (how to compile the kernel will be discussed later in\nthis chapter).\n\n### The Operating System\nGRUB will transfer control to the operating system by jumping to a position in\nmemory. Before the jump, GRUB will look for a magic number to ensure that it is\nactually jumping to an OS and not some random code. This magic number is part\nof the _multiboot specification_ [@multiboot] which GRUB adheres to. Once GRUB\nhas made the jump, the OS has full control of the computer.\n\n## Hello Cafebabe\nThis section will describe how to implement of the smallest possible OS that\ncan be used together with GRUB. The only thing the OS will do is write\n`0xCAFEBABE` to the `eax` register (most people would probably not even call\nthis an OS).\n\n### Compiling the Operating System\nThis part of the OS has to be written in assembly code, since C requires a\nstack, which isn't available (the chapter [\"Getting to C\"](#getting-to-c)\ndescribes how to set one up). Save the following code in a file called\n`loader.s`:\n\n~~~ {.nasm}\n    global loader                   ; the entry symbol for ELF\n\n    MAGIC_NUMBER equ 0x1BADB002     ; define the magic number constant\n    FLAGS        equ 0x0            ; multiboot flags\n    CHECKSUM     equ -MAGIC_NUMBER  ; calculate the checksum\n                                    ; (magic number + checksum + flags should equal 0)\n\n    section .text:                  ; start of the text (code) section\n    align 4                         ; the code must be 4 byte aligned\n        dd MAGIC_NUMBER             ; write the magic number to the machine code,\n        dd FLAGS                    ; the flags,\n        dd CHECKSUM                 ; and the checksum\n\n    loader:                         ; the loader label (defined as entry point in linker script)\n        mov eax, 0xCAFEBABE         ; place the number 0xCAFEBABE in the register eax\n    .loop:\n        jmp .loop                   ; loop forever\n~~~\n\nThe only thing this OS will do is write the very specific number\n`0xCAFEBABE` to the `eax` register. It is _very_ unlikely that the number\n`0xCAFEBABE` would be in the `eax` register if the OS did _not_ put it\nthere.\n\nThe file `loader.s` can be compiled into a 32 bits ELF [@wiki:elf] object file\nwith the following command:\n\n~~~ {.bash}\n    nasm -f elf32 loader.s\n~~~\n\n### Linking the Kernel\nThe code must now be linked to produce an executable file, which requires some\nextra thought compared to when linking most programs. We want GRUB to load the\nkernel at a memory address larger than or equal to `0x00100000` (1 megabyte\n(MB)), because addresses lower than 1 MB are used by GRUB itself, BIOS\nand memory-mapped I/O. Therefore, the following linker script is needed\n(written for GNU LD [@gnubinutils]):\n\n~~~\nENTRY(loader)                /* the name of the entry label */\n\nSECTIONS {\n    . = 0x00100000;          /* the code should be loaded at 1 MB */\n\n    .text ALIGN (0x1000) :   /* align at 4 KB */\n    {\n        *(.text)             /* all text sections from all files */\n    }\n\n    .rodata ALIGN (0x1000) : /* align at 4 KB */\n    {\n        *(.rodata*)          /* all read-only data sections from all files */\n    }\n\n    .data ALIGN (0x1000) :   /* align at 4 KB */\n    {\n        *(.data)             /* all data sections from all files */\n    }\n\n    .bss ALIGN (0x1000) :    /* align at 4 KB */\n    {\n        *(COMMON)            /* all COMMON sections from all files */\n        *(.bss)              /* all bss sections from all files */\n    }\n}\n~~~\n\nSave the linker script into a file called `link.ld`. The executable can now be\nlinked with the following command:\n\n~~~ {.bash}\n    ld -T link.ld -melf_i386 loader.o -o kernel.elf\n~~~\n\nThe final executable will be called `kernel.elf`.\n\n### Obtaining GRUB\nThe GRUB version we will use is GRUB Legacy, since the OS ISO image can then be\ngenerated on systems using both GRUB Legacy and GRUB 2. More specifically, the\nGRUB Legacy `stage2_eltorito` bootloader will be used. This file can be built\nfrom GRUB 0.97 by downloading the source from\n<ftp://alpha.gnu.org/gnu/grub/grub-0.97.tar.gz>.  However, the `configure`\nscript doesn't work well with Ubuntu [@ubuntu-grub], so the binary file can be\ndownloaded from <http://littleosbook.github.com/files/stage2_eltorito>. Copy\nthe file `stage2_eltorito` to the folder that already contains `loader.s` and\n`link.ld`.\n\n### Building an ISO Image\nThe executable must be placed on a media that can be loaded by a virtual or\nphysical machine. In this book we will use ISO [@wiki:iso] image files as the\nmedia, but one can also use floppy images, depending on what the virtual or\nphysical machine supports.\n\nWe will create the kernel ISO image with the program `genisoimage`. A folder\nmust first be created that contains the files that will be on the ISO image.\nThe following commands create the folder and copy the files to their correct\nplaces:\n\n~~~ {.bash}\n    mkdir -p iso/boot/grub              # create the folder structure\n    cp stage2_eltorito iso/boot/grub/   # copy the bootloader\n    cp kernel.elf iso/boot/             # copy the kernel\n~~~\n\nA configuration file `menu.lst` for GRUB must be created. This file tells GRUB\nwhere the kernel is located and configures some options:\n\n~~~\n    default=0\n    timeout=0\n\n    title os\n    kernel /boot/kernel.elf\n~~~\n\nPlace the file `menu.lst` in the folder `iso/boot/grub/`. The contents of the\n`iso` folder should now look like the following figure:\n\n~~~\n    iso\n    |-- boot\n      |-- grub\n      | |-- menu.lst\n      | |-- stage2_eltorito\n      |-- kernel.elf\n~~~\n\nThe ISO image can then be generated with the following command:\n\n~~~\n    genisoimage -R                              \\\n                -b boot/grub/stage2_eltorito    \\\n                -no-emul-boot                   \\\n                -boot-load-size 4               \\\n                -A os                           \\\n                -input-charset utf8             \\\n                -quiet                          \\\n                -boot-info-table                \\\n                -o os.iso                       \\\n                iso\n~~~\n\nFor more information about the flags used in the command, see the manual for\n`genisoimage`.\n\nThe ISO image `os.iso` now contains the kernel executable, the GRUB\nbootloader and the configuration file.\n\n### Running Bochs\nNow we can run the OS in the Bochs emulator using the `os.iso` ISO image.\nBochs needs a configuration file to start and an example of a simple\nconfiguration file is given below:\n\n~~~\n    megs:            32\n    display_library: sdl\n    romimage:        file=/usr/share/bochs/BIOS-bochs-latest\n    vgaromimage:     file=/usr/share/bochs/VGABIOS-lgpl-latest\n    ata0-master:     type=cdrom, path=os.iso, status=inserted\n    boot:            cdrom\n    log:             bochslog.txt\n    clock:           sync=realtime, time0=local\n    cpu:             count=1, ips=1000000\n~~~\n\nYou might need to change the path to `romimage` and `vgaromimage` depending on\nhow you installed Bochs. More information about the Bochs config file can be\nfound at Boch's website [@bochs-config].\n\nIf you saved the configuration in a file named `bochsrc.txt` then you can run\nBochs with the following command:\n\n~~~\n    bochs -f bochsrc.txt -q\n~~~\n\nThe flag `-f` tells Bochs to use the given configuration file and the flag `-q`\ntells Bochs to skip the interactive start menu. You should now see Bochs\nstarting and displaying a console with some information from GRUB on it.\n\nAfter quitting Bochs, display the log produced by Boch:\n\n~~~\n    cat bochslog.txt\n~~~\n\nYou should now see the contents of the registers of the CPU simulated by Bochs\nsomewhere in the output. If you find `RAX=00000000CAFEBABE` or `EAX=CAFEBABE`\n(depending on if you are running Bochs with or without 64 bit support) in the\noutput then your OS has successfully booted!\n\n## Further Reading\n- Gustavo Duertes has written an in-depth article about what actually happens\n  when a x86 computer boots up,\n  <http://duartes.org/gustavo/blog/post/how-computers-boot-up>\n- Gustavo continues to describe what the kernel does in the very early\n  stages at <http://duartes.org/gustavo/blog/post/kernel-boot-process>\n- The OSDev wiki also contains a nice article about booting an x86 computer:\n  <http://wiki.osdev.org/Boot_Sequence>\n"
        },
        {
          "name": "file_systems.md",
          "type": "blob",
          "size": 3.9091796875,
          "content": "# File Systems\n\nWe are not required to have file systems in our operating system, but it is a\nvery usable abstraction, and it often plays a central part of many operating\nsystems, especially UNIX-like operating systems. Before we start the\nprocess of supporting multiple processes and system calls we might want to\nconsider implementing a simple file system.\n\n## Why a File System?\n\nHow do we specify what programs to run in our OS? Which is the first program to\nrun? How do programs output data or read input?\n\nIn UNIX-like systems, with their almost-everything-is-a-file convention, these\nproblems are solved by the file system. (It might also be interesting to read a\nbit about the Plan 9 project, which takes this idea one step further.)\n\n## A Simple Read-Only File System\n\nThe simplest file system might be what we already have - one\nfile, existing only in RAM, loaded by GRUB before the kernel starts. When the\nkernel and operating system grows this is probably too limiting.\n\nA file system that is slightly more advanced than just the bits of one file is\na file with metadata. The metadata can describe the type of the file, the size\nof the file and so on.  A utility program can be created that runs at build\ntime, adding this metadata to a file. This way, a \"file system in a file\" can\nbe constructed by concatenating several files with metadata into one large file.\nThe result of this technique is a read-only file system that resides in memory\n(once GRUB has loaded the file).\n\nThe program constructing the file system can traverse a directory on the host\nsystem and add all subdirectories and files as part of the target file system.\nEach object in the file system (directory or file) can consist of a header and\na body, where the body of a file is the actual file and the body of a directory\nis a list of entries - names and \"addresses\" of other files and directories.\n\nEach object in this file system will become contiguous, so they will be easy to\nread from memory for the kernel. All objects will also have a fixed size\n(except for the last one, which can grow), therefore it is difficult to add new\nfiles or modify existing ones.\n\n## Inodes and Writable File Systems\n\nWhen the need for a writable file system arises, then it is a good idea to look\ninto the concept of an _inode_. See the section [\"Further\nReading\"](#further-reading-9) for recommended reading.\n\n## A Virtual File System\n\nWhat abstraction should be used for reading and writing to devices such as the\nscreen and the keyboard?\n\nA virtual file system (VFS) creates an abstraction on top of the concrete\nfile systems. A VFS mainly supplies the path system and file\nhierarchy, it delegates operations on files to the underlying file\nsystems. The original paper on VFS is succinct and well worth a\nread. See the section [\"Further Reading\"](#further-reading-9) for a reference.\n\nWith a VFS we could mount a special file system on the path `/dev`. This file\nsystem would handle all devices such as keyboards and the console. However, one\ncould also take the traditional UNIX approach, with major/minor device numbers\nand `mknod` to create special files for devices. Which approach you think\nis the most appropriate is up to you, there is no right or wrong when building\nabstraction layers (although some abstractions turn out way more useful\nthan others).\n\n## Further Reading\n\n- The ideas behind the Plan 9 operating systems is worth taking a look at:\n  <http://plan9.bell-labs.com/plan9/index.html>\n- Wikipedia's page on inodes: <http://en.wikipedia.org/wiki/Inode> and the\n  inode pointer structure:\n  <http://en.wikipedia.org/wiki/Inode_pointer_structure>.\n- The original paper on the concept of vnodes and a virtual file system is\n  quite interesting:\n  <http://www.arl.wustl.edu/~fredk/Courses/cs523/fall01/Papers/kleiman86vnodes.pdf>\n- Poul-Henning Kamp discusses the idea of a special file system for `/dev` in\n  <http://static.usenix.org/publications/library/proceedings/bsdcon02/full_papers/kamp/kamp_html/index.html>\n"
        },
        {
          "name": "files",
          "type": "tree",
          "content": null
        },
        {
          "name": "getting_to_c.md",
          "type": "blob",
          "size": 7.703125,
          "content": "# Getting to C\nThis chapter will show you how to use C instead of assembly code as the programming\nlanguage for the OS. Assembly is very good for interacting with the CPU and\nenables maximum control over every aspect of the code.  However, at least for\nthe authors, C is a much more convenient language to use. Therefore, we would\nlike to use C as much as possible and use assembly code only where it make sense.\n\n## Setting Up a Stack\nOne prerequisite for using C is a stack, since all non-trivial C programs use\na stack.  Setting up a stack is not harder than to make the `esp` register\npoint to the end of an area of free memory (remember that the stack grows\ntowards lower addresses on the x86) that is correctly aligned (alignment on 4 bytes is\nrecommended from a performance perspective).\n\nWe could point `esp` to a random area in memory since, so far, the only thing\nin the memory is GRUB, BIOS, the OS kernel and some memory-mapped I/O.  This is\nnot a good idea - we don't know how much memory is available or if the\narea `esp` would point to is used by something else. A better idea is to\nreserve a piece of uninitialized memory in the `bss` section in the ELF file\nof the kernel. It is better to use the `bss` section instead of the\n`data` section to reduce the size of the OS executable. Since GRUB understands\nELF, GRUB will allocate any memory reserved in the `bss` section\nwhen loading the OS.\n\nThe NASM pseudo-instruction `resb` [@resb] can be used to declare uninitialized\ndata:\n\n~~~ {.nasm}\n    KERNEL_STACK_SIZE equ 4096                  ; size of stack in bytes\n\n    section .bss\n    align 4                                     ; align at 4 bytes\n    kernel_stack:                               ; label points to beginning of memory\n        resb KERNEL_STACK_SIZE                  ; reserve stack for the kernel\n~~~\n\nThere is no need to worry about the use of uninitialized memory for the stack,\nsince it is not possible to read a stack location that has not been written\n(without manual pointer fiddling).\nA (correct) program can not pop an element from the stack\nwithout having pushed an element onto the stack first. Therefore, the memory\nlocations of the stack will always be written to before they are being read.\n\nThe stack pointer is then set up by pointing `esp` to the end of the\n`kernel_stack` memory:\n\n~~~ {.nasm}\n    mov esp, kernel_stack + KERNEL_STACK_SIZE   ; point esp to the start of the\n                                                ; stack (end of memory area)\n~~~\n\n## Calling C Code From Assembly\nThe next step is to call a C function from assembly code. There are many\ndifferent conventions for how to call C code from assembly code\n[@wiki:ccall]. This book uses the _cdecl_ calling convention, since that is the\none used by GCC. The cdecl calling convention states that arguments to a\nfunction should be passed via the stack (on x86). The arguments of the function\nshould be pushed on the stack in a right-to-left order, that is, you push the\nrightmost argument first. The return value of the function is placed in the\n`eax` register. The following code shows an example:\n\n~~~ {.c}\n    /* The C function */\n    int sum_of_three(int arg1, int arg2, int arg3)\n    {\n        return arg1 + arg2 + arg3;\n    }\n~~~\n\n~~~ {.nasm}\n    ; The assembly code\n    extern sum_of_three   ; the function sum_of_three is defined elsewhere\n\n    push dword 3            ; arg3\n    push dword 2            ; arg2\n    push dword 1            ; arg1\n    call sum_of_three       ; call the function, the result will be in eax\n~~~\n\n### Packing Structs\nIn the rest of this book, you will often come across \"configuration bytes\" that are\na collection of bits in a very specific order. Below follows an example with 32\nbits:\n\n    Bit:     | 31     24 | 23          8 | 7     0 |\n    Content: | index     | address       | config  |\n\nInstead of using an unsigned integer, `unsigned int`, for handling such\nconfigurations, it is much more convenient to use \"packed structures\":\n\n~~~ {.C}\n    struct example {\n        unsigned char config;   /* bit 0 - 7   */\n        unsigned short address; /* bit 8 - 23  */\n        unsigned char index;    /* bit 24 - 31 */\n    };\n~~~\n\nWhen using the `struct` in the previous example there is no guarantee that the\nsize of the `struct` will be exactly 32 bits - the compiler can add some\npadding between elements for various reasons, for example to speed up element\naccess or due to requirements set by the hardware and/or compiler. When using a\n`struct` to represent configuration bytes, it is very important that the\ncompiler does _not_ add any padding, because the `struct` will eventually be\ntreated as a 32 bit unsigned integer by the hardware. The attribute `packed`\ncan be used to force GCC to _not_ add any padding:\n\n~~~ {.C}\n    struct example {\n        unsigned char config;   /* bit 0 - 7   */\n        unsigned short address; /* bit 8 - 23  */\n        unsigned char index;    /* bit 24 - 31 */\n    } __attribute__((packed));\n~~~\n\nNote that `__attribute__((packed))` is not part of the C standard - it might\nnot work with all C compilers.\n\n## Compiling C Code\nWhen compiling the C code for the OS, a lot of flags to GCC need to be used.\nThis is because the C code should _not_ assume the presence of a standard\nlibrary, since there is no standard library available for our OS. For more\ninformation about the flags, see the GCC manual.\n\nThe flags used for compiling the C code are:\n\n~~~\n    -m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector -nostartfiles\n    -nodefaultlibs\n~~~\n\nAs always when writing C programs we recommend turning on all warnings and\ntreat warnings as errors:\n\n~~~\n    -Wall -Wextra -Werror\n~~~\n\nYou can now create a function `kmain` in a file called `kmain.c` that you call\nfrom `loader.s`. At this point, `kmain` probably won't need any arguments (but\nin later chapters it will).\n\n## Build Tools\nNow is also probably a good time to set up some build tools to make it easier\nto compile and test-run the OS. We recommend using `make` [@make], but there are\nplenty of other build systems available. A simple Makefile for the OS could\nlook like the following example:\n\n~~~ {.Makefile}\n    OBJECTS = loader.o kmain.o\n    CC = gcc\n    CFLAGS = -m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector \\\n             -nostartfiles -nodefaultlibs -Wall -Wextra -Werror -c\n    LDFLAGS = -T link.ld -melf_i386\n    AS = nasm\n    ASFLAGS = -f elf\n\n    all: kernel.elf\n\n    kernel.elf: $(OBJECTS)\n        ld $(LDFLAGS) $(OBJECTS) -o kernel.elf\n\n    os.iso: kernel.elf\n        cp kernel.elf iso/boot/kernel.elf\n        genisoimage -R                              \\\n                    -b boot/grub/stage2_eltorito    \\\n                    -no-emul-boot                   \\\n                    -boot-load-size 4               \\\n                    -A os                           \\\n                    -input-charset utf8             \\\n                    -quiet                          \\\n                    -boot-info-table                \\\n                    -o os.iso                       \\\n                    iso\n\n    run: os.iso\n        bochs -f bochsrc.txt -q\n\n    %.o: %.c\n        $(CC) $(CFLAGS)  $< -o $@\n\n    %.o: %.s\n        $(AS) $(ASFLAGS) $< -o $@\n\n    clean:\n        rm -rf *.o kernel.elf os.iso\n~~~\n\nThe contents of your working directory should now look like the following\nfigure:\n\n~~~\n    .\n    |-- bochsrc.txt\n    |-- iso\n    |   |-- boot\n    |     |-- grub\n    |       |-- menu.lst\n    |       |-- stage2_eltorito\n    |-- kmain.c\n    |-- loader.s\n    |-- Makefile\n~~~\n\nYou should now be able to start the OS with the simple command `make\nrun`, which will compile the kernel and boot it up in Bochs (as defined in the\nMakefile above).\n\n## Further Reading\n\n- Kernigan & Richie's book, _The C Programming Language, Second Edition_, [@knr]\n  is great for learning about all the aspects of C.\n"
        },
        {
          "name": "header.tex",
          "type": "blob",
          "size": 0.080078125,
          "content": "\\usepackage{fullpage}\n\n\\hypersetup{\n  pdfborder = {0 0 0},\n  colorlinks = false\n}\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "interrupts.md",
          "type": "blob",
          "size": 12.56640625,
          "content": "# Interrupts and Input\nNow that the OS can produce _output_ it would be nice if\nit also could get some _input_. (The operating system must be able to handle\n_interrupts_ in order to read information from the keyboard). An interrupt\noccurs when a hardware device, such as the keyboard, the serial port or the\ntimer, signals the CPU that the state of the device has changed. The CPU itself\ncan also send interrupts due to program errors, for example when a program\nreferences memory it doesn't have access to, or when a program divides a number\nby zero. Finally, there are also _software intterupts_, which are interrupts\nthat are caused by the `int` assembly code instruction, and they are often used for\nsystem calls.\n\n## Interrupts Handlers\nInterrupts are handled via the _Interrupt Descriptor Table_ (IDT). The IDT\ndescribes a handler for each interrupt. The interrupts are numbered (0 - 255)\nand the handler for interrupt _i_ is defined at the _ith_ position in the\ntable. There are three different kinds of handlers for interrupts:\n\n- Task handler\n- Interrupt handler\n- Trap handler\n\nThe task handlers use functionality specific to the Intel version of x86, so they won't be covered\nhere (see the Intel manual [@intel3a], chapter 6, for more info). The only\ndifference between an interrupt handler and a trap handler is that the\ninterrupt handler disables interrupts, which means you cannot get an interrupt\nwhile at the same time handling an interrupt. In this book, we will use trap\nhandlers and disable interrupts manually when we need to.\n\n## Creating an Entry in the IDT\nAn entry in the IDT for an interrupt handler consists of 64 bits.\nThe highest 32 bits are shown in the figure below:\n\n    Bit:     | 31              16 | 15 | 14 13 | 12 | 11 | 10 9 8 | 7 6 5 | 4 3 2 1 0 |\n    Content: | offset high        | P  | DPL   | 0  | D  | 1  1 0 | 0 0 0 | reserved  |\n\nThe lowest 32 bits are presented in the following figure:\n\n    Bit:     | 31              16 | 15              0 |\n    Content: | segment selector   | offset low        |\n\nA description for each name can be found in the table below:\n\n             Name Description\n----------------- ------------\n      offset high The 16 highest bits of the 32 bit address in the segment.\n       offset low The 16 lowest bits of the 32 bits address in the segment.\n                p If the handler is present in memory or not (1 = present, 0 = not present).\n              DPL Descriptor Privilige Level, the privilege level the handler can be called from (0, 1, 2, 3).\n                D Size of gate, (1 = 32 bits, 0 = 16 bits).\n segment selector The offset in the GDT.\n                r Reserved.\n\nThe offset is a pointer to code (preferably an assembly code label). For example, to\ncreate an entry for a handler whose code starts at `0xDEADBEEF` and that\nruns in privilege level 0 (therefore using the same code\nsegment selector as the kernel) the following two bytes would be used:\n\n~~~\n    0xDEAD8E00\n    0x0008BEEF\n~~~\n\nIf the IDT is represented as an `unsigned integer idt[512]` then to register\nthe above example as an handler for interrupt 0 (divide-by-zero), the following\ncode would be used:\n\n~~~ {.c}\n    idt[0] = 0xDEAD8E00\n    idt[1] = 0x0008BEEF\n~~~\n\nAs written in the chapter [\"Getting to C\"](#getting-to-c), we recommend that you\ninstead of using bytes (or unsigned integers) use packed structures to make the\ncode more readable.\n\n## Handling an Interrupt\nWhen an interrupt occurs the CPU will push some information about the interrupt onto\nthe stack, then look up the appropriate interrupt hander in the IDT and jump to\nit. The stack at the time of the interrupt will look like the following:\n\n~~~\n    [esp + 12] eflags\n    [esp + 8]  cs\n    [esp + 4]  eip\n    [esp]      error code?\n~~~\n\nThe reason for the question mark behind error code is that not all interrupts\ncreate an _error code_. The specific CPU interrupts that put an error code on the\nstack are 8, 10, 11, 12, 13, 14 and 17. The error code can be used by the\ninterrupt handler to get more information on what has happened.\nAlso, note that the interrupt _number_ is _not_ pushed onto the stack. We can only\ndetermine what interrupt has occurred by knowing what code is executing - if the handler\nregistered for interrupt 17 is executing, then interrupt 17 has occurred.\n\nOnce the interrupt handler is done, it uses the `iret` instruction to\nreturn. The instruction `iret` expects the stack to be the same as at the time\nof the interrupt (see the figure above). Therefore, any values pushed onto the\nstack by the interrupt handler must be popped.  Before returning, `iret`\nrestores `eflags` by popping the value from the stack and then finally jumps to\n`cs:eip` as specified by the values on the stack.\n\nThe interrupt handler has to be written in assembly code, since all registers that\nthe interrupt handlers use must be preserved by pushing them onto the stack.\nThis is because the code that was interrupted doesn't know about the interrupt\nand will therefore expect that its registers stay the same. Writing all the\nlogic of the interrupt handler in assembly code will be tiresome. Creating a\nhandler in assembly code that saves the registers, calls a C function, restores the\nregisters and finally executes `iret` is a good idea!\n\nThe C handler should get the state of the registers, the state of the stack and\nthe number of the interrupt as arguments. The following definitions can for\nexample be used:\n\n~~~ {.c}\n    struct cpu_state {\n        unsigned int eax;\n        unsigned int ebx;\n        unsigned int ecx;\n        .\n        .\n        .\n        unsigned int esp;\n    } __attribute__((packed));\n\n    struct stack_state {\n        unsigned int error_code;\n        unsigned int eip;\n        unsigned int cs;\n        unsigned int eflags;\n    } __attribute__((packed));\n\n    void interrupt_handler(struct cpu_state cpu, struct stack_state stack, unsigned int interrupt);\n~~~\n\n## Creating a Generic Interrupt Handler\nSince the CPU does not push the interrupt number on the stack it is a\nlittle tricky to write a generic interrupt handler. This section will use\nmacros to show how it can be done. Writing one version for each\ninterrupt is tedious - it is better to use the macro functionality of NASM\n[@nasm:macros]. And since not all interrupts produce an error code the value 0\nwill be added as the \"error code\" for interrupts without an error code. The following\ncode shows an example of how this can be done:\n\n~~~ {.nasm}\n    %macro no_error_code_interrupt_handler %1\n    global interrupt_handler_%1\n    interrupt_handler_%1:\n        push    dword 0                     ; push 0 as error code\n        push    dword %1                    ; push the interrupt number\n        jmp     common_interrupt_handler    ; jump to the common handler\n    %endmacro\n\n    %macro error_code_interrupt_handler %1\n    global interrupt_handler_%1\n    interrupt_handler_%1:\n        push    dword %1                    ; push the interrupt number\n        jmp     common_interrupt_handler    ; jump to the common handler\n    %endmacro\n\n    common_interrupt_handler:               ; the common parts of the generic interrupt handler\n        ; save the registers\n        push    eax\n        push    ebx\n        .\n        .\n        .\n        push    ebp\n\n        ; call the C function\n        call    interrupt_handler\n\n        ; restore the registers\n        pop     ebp\n        .\n        .\n        .\n        pop     ebx\n        pop     eax\n\n        ; restore the esp\n        add     esp, 8\n\n        ; return to the code that got interrupted\n        iret\n\n    no_error_code_interrupt_handler 0       ; create handler for interrupt 0\n    no_error_code_interrupt_handler 1       ; create handler for interrupt 1\n    .\n    .\n    .\n    error_code_handler              7       ; create handler for interrupt 7\n    .\n    .\n    .\n~~~\n\nThe `common_interrupt_handler` does the following:\n\n- Push the registers on the stack.\n- Call the C function `interrupt_handler`.\n- Pop the registers from the stack.\n- Add 8 to `esp` (because of the error code and the interrupt number pushed earlier).\n- Execute `iret` to return to the interrupted code.\n\nSince the macros declare global labels the addresses of the interrupt handlers\ncan be accessed from C or assembly code when creating the IDT.\n\n## Loading the IDT\nThe IDT is loaded with the `lidt` assembly code instruction which takes the address\nof the first element in the table. It is easiest to wrap this instruction and\nuse it from C:\n\n~~~ {.nasm}\n    global  load_idt\n\n    ; load_idt - Loads the interrupt descriptor table (IDT).\n    ; stack: [esp + 4] the address of the first entry in the IDT\n    ;        [esp    ] the return address\n    load_idt:\n        mov     eax, [esp+4]    ; load the address of the IDT into register eax\n        lidt    eax             ; load the IDT\n        ret                     ; return to the calling function\n~~~\n\n## Programmable Interrupt Controller (PIC)\nTo start using hardware interrupts you must first configure the Programmable\nInterrupt Controller (PIC). The PIC makes it possible to map signals from the\nhardware to interrupts. The reasons for configuring the PIC are:\n\n- Remap the interrupts. The PIC uses interrupts 0 - 15 for hardware interrupts\n  by default, which conflicts with the CPU interrupts. Therefore the PIC\n  interrupts must be remapped to another interval.\n- Select which interrupts to receive. You probably don't want to receive\n  interrupts from all devices since you don't have code that handles these\n  interrupts anyway.\n- Set up the correct mode for the PIC.\n\nIn the beginning there was only one PIC (PIC 1) and eight interrupts. As more\nhardware were added, 8 interrupts were too few. The solution\nchosen was to chain on another PIC (PIC 2) on the first PIC (see interrupt 2 on\nPIC 1).\n\nThe hardware interrupts are shown in the table below:\n\n PIC 1 Hardware     PIC 2 Hardware\n------ ---------   ------ ---------\n     0 Timer            8 Real Time Clock\n     1 Keyboard         9 General I/O\n     2 PIC 2           10 General I/O\n     3 COM 2           11 General I/O\n     4 COM 1           12 General I/O\n     5 LPT 2           13 Coprocessor\n     6 Floppy disk     14 IDE Bus\n     7 LPT 1           15 IDE Bus\n\nA great tutorial for configuring the PIC can be found at the SigOPS\nwebsite [@acm]. We won't repeat that information here.\n\nEvery interrupt from the PIC has to be acknowledged - that is, sending a\nmessage to the PIC confirming that the interrupt has been handled. If this\nisn't done the PIC won't generate any more interrupts.\n\nAcknowledging a PIC interrupt is done by sending the byte `0x20` to the PIC\nthat raised the interrupt. Implementing a `pic_acknowledge` function can thus\nbe done as follows:\n\n~~~ {.c}\n    #include \"io.h\"\n\n    #define PIC1_PORT_A 0x20\n    #define PIC2_PORT_A 0xA0\n\n    /* The PIC interrupts have been remapped */\n    #define PIC1_START_INTERRUPT 0x20\n    #define PIC2_START_INTERRUPT 0x28\n    #define PIC2_END_INTERRUPT   PIC2_START_INTERRUPT + 7\n\n    #define PIC_ACK     0x20\n\n    /** pic_acknowledge:\n     *  Acknowledges an interrupt from either PIC 1 or PIC 2.\n     *\n     *  @param num The number of the interrupt\n     */\n    void pic_acknowledge(unsigned integer interrupt)\n    {\n        if (interrupt < PIC1_START_INTERRUPT || interrupt > PIC2_END_INTERRUPT) {\n          return;\n        }\n\n        if (interrupt < PIC2_START_INTERRUPT) {\n          outb(PIC1_PORT_A, PIC_ACK);\n        } else {\n          outb(PIC2_PORT_A, PIC_ACK);\n        }\n    }\n~~~\n\n## Reading Input from the Keyboard\n\nThe keyboard does not generate ASCII characters, it generates scan codes. A\nscan code represents a button - both presses and releases. The scan code\nrepresenting the just pressed button can be read from the keyboard's data I/O\nport which has address `0x60`. How this can be done is shown in the following\nexample:\n\n~~~ {.c}\n    #include \"io.h\"\n\n    #define KBD_DATA_PORT   0x60\n\n    /** read_scan_code:\n     *  Reads a scan code from the keyboard\n     *\n     *  @return The scan code (NOT an ASCII character!)\n     */\n    unsigned char read_scan_code(void)\n    {\n        return inb(KBD_DATA_PORT);\n    }\n~~~\n\nThe next step is to write a function that translates a scan code to the\ncorresponding ASCII character. If you want to map the scan codes to ASCII\ncharacters as is done on an American keyboard then Andries Brouwer has a great\ntutorial [@scancodes].\n\nRemember, since the keyboard interrupt is raised by the PIC, you must call\n`pic_acknowledge` at the end of the keyboard interrupt handler. Also, the\nkeyboard will not send you any more interrupts until you read the scan\ncode from the keyboard.\n\n## Further Reading\n\n- The OSDev wiki has a great page on interrupts,\n  <http://wiki.osdev.org/Interrupts>\n- Chapter 6 of Intel Manual 3a [@intel3a] describes everything there is to know\n  about interrupts.\n"
        },
        {
          "name": "introduction.md",
          "type": "blob",
          "size": 5.8017578125,
          "content": "# Introduction\n\nThis text is a practical guide to writing your own x86 operating system. It is\ndesigned to give enough help with the technical details while at the same time not\nreveal too much with samples and code excerpts. We've tried to collect\nparts of the vast (and often excellent) expanse of material and tutorials\navailable, on the web and otherwise, and add our own insights into the problems\nwe encountered and struggled with.\n\nThis book is not about the theory behind operating systems, or how any specific\noperating system (OS) works. For OS theory we recommend the book _Modern\nOperating Systems_ by Andrew Tanenbaum [@ostanenbaum]. Lists and details on\ncurrent operating systems are available on the Internet.\n\nThe starting chapters are quite detailed and explicit, to quickly get you into\ncoding. Later chapters give more of an outline of what is needed, as more and\nmore of the implementation and design becomes up to the reader, who should now\nbe more familiar with the world of kernel development. At the end of some\nchapters there are links for further reading, which might be interesting and\ngive a deeper understanding of the topics covered.\n\nIn [chapter 2](#first-steps) and [3](#getting-to-c) we set up our development\nenvironment and boot up our OS kernel in a virtual machine, eventually starting\nto write code in C. We continue in [chapter 4](#output) with writing to the\nscreen and the serial port, and then we dive into segmentation in [chapter\n5](#segmentation) and interrupts and input in [chapter\n6](#interrupts-and-input).\n\nAfter this we have a quite functional but bare-bones OS kernel. In [chapter\n7](#the-road-to-user-mode) we start the road to user mode applications, with\nvirtual memory through paging ([chapter\n8](#a-short-introduction-to-virtual-memory) and [9](#paging)), memory\nallocation ([chapter 10](#page-frame-allocation)), and finally running a user\napplication in [chapter 11](#user-mode).\n\nIn the last three chapters we discuss the more advanced topics of file systems\n([chapter 12](#file-systems)), system calls ([chapter 13](#system-calls)), and\nmultitasking ([chapter 14](#multitasking)).\n\n## About the Book\n\nThe OS kernel and this book were produced as part of an advanced individual\ncourse at the Royal Institute of Technology [@kth], Stockholm.  The authors had\npreviously taken courses in OS theory, but had only minor practical experience\nwith OS kernel development.  In order to get more insight and a deeper\nunderstanding of how the theory from the previous OS courses works out in\npractice, the authors decided to create a new course, which focused on the\ndevelopment of a small OS. Another goal of the course was writing a thorough\ntutorial on how to develop a small OS basically from scratch, and this short\nbook is the result.\n\nThe x86 architecture is, and has been for a long time, one of the most common\nhardware architectures. It was not a difficult choice to use the x86\narchitecture as the target of the OS, with its large community, extensive\nreference material and mature emulators. The documentation and information\nsurrounding the details of the hardware we had to work with was not always easy\nto find or understand, despite (or perhaps due to) the age of the architecture.\n\nThe OS was developed in about six weeks of full-time work. The implementation\nwas done in many small steps, and after each step the OS was tested manually.\nBy developing in this incremental and iterative way, it was often easier to\nfind any bugs that were introduced, since only a small part of the code had\nchanged since the last known good state of the code. We encourage the reader to\nwork in a similar way.\n\nDuring the six weeks of development, almost every single line of code was\nwritten by the authors together (this way of working is also called\n_pair-programming_). It is our belief that we managed to avoid a lot of bugs\ndue to this style of development, but this is hard to prove scientifically.\n\n## The Reader\n\nThe reader of this book should be comfortable with UNIX/Linux, systems\nprogramming, the C language and computer systems in general (such as\nhexadecimal notation [@wiki:hex]). This book could be a way to get started\nlearning those things, but it will be more difficult, and developing an\noperating system is already challenging on its own. Search engines and other\ntutorials are often helpful if you get stuck.\n\n## Credits, Thanks and Acknowledgements\n\nWe'd like to thank the OSDev community [@osdev] for their great wiki and\nhelpful members, and James Malloy for his eminent kernel development tutorial\n[@malloy]. We'd also like to thank our supervisor Torbjrn Granlund for his\ninsightful questions and interesting discussions.\n\nMost of the CSS formatting of the book is based on the work by Scott Chacon for\nthe book Pro Git, <http://progit.org/>.\n\n## Contributors\nWe are very grateful for the patches that people send us. The following users\nhave all contributed to this book:\n\n- [alexschneider](https://github.com/alexschneider)\n- [Avidanborisov](https://github.com/Avidanborisov)\n- [nirs](https://github.com/nirs)\n- [kedarmhaswade](https://github.com/kedarmhaswade)\n- [vamanea](https://github.com/vamanea)\n- [ansjob](https://github.com/ansjob)\n\n## Changes and Corrections\n\nThis book is hosted on Github - if you have any suggestions, comments or\ncorrections, just fork the book, write your changes, and send us a pull\nrequest. We'll happily incorporate anything that makes this book better.\n\n## Issues and where to get help\nIf you run into problems while reading the book, please check the issues on\nGithub for help: <https://github.com/littleosbook/littleosbook/issues>.\n\n## License\n\nAll content is under the Creative Commons Attribution Non Commercial Share\nAlike 3.0 license, <http://creativecommons.org/licenses/by-nc-sa/3.0/us/>. The\ncode samples are in the public domain - use them however you want. References\nto this book are always received with warmth.\n"
        },
        {
          "name": "output.md",
          "type": "blob",
          "size": 18.2255859375,
          "content": "# Output\nThis chapter will present how to display text on the console as well as writing\ndata to the serial port. Furthermore, we will create our\nfirst _driver_, that is, code that acts as a layer between the kernel and the\nhardware, providing a higher abstraction than communicating directly with the\nhardware.  The first part of this chapter is about creating a driver for the\n_framebuffer_ [@wiki:fb] to be able to display text on the console. The second\npart shows how to create a driver for the serial port. Bochs can store output\nfrom the serial port in a file, effectively creating a logging mechanism for\nthe operating system.\n\n## Interacting with the Hardware\nThere are usually two different ways to interact with the hardware,\n_memory-mapped I/O_ and _I/O ports_.\n\nIf the hardware uses memory-mapped I/O then you can write to a specific memory\naddress and the hardware will be updated with the new data. One example of this\nis the framebuffer, which will be discussed in more detail later. For example,\nif you write the value `0x410F` to address `0x000B8000`, you\nwill see the letter A in white color on a black background (see the section\non [the framebuffer](#the-framebuffer) for more details).\n\nIf the hardware uses I/O ports then the assembly code instructions `out` and `in`\nmust be used to communicate with the hardware. The instruction `out` takes two\nparameters: the address of the I/O port and the data to send. The instruction\n`in` takes a single parameter, the address of the I/O port, and returns data\nfrom the hardware. One can think of I/O ports as communicating with hardware\nthe same way as you communicate with a server using sockets. The cursor (the\nblinking rectangle) of the framebuffer is one example of hardware controlled\nvia I/O ports on a PC.\n\n## The Framebuffer\nThe framebuffer is a hardware device that is capable of displaying a buffer of\nmemory on the screen [@wiki:fb]. The framebuffer has 80 columns and 25 rows,\nand the row and column indices start at 0 (so rows are labelled 0 - 24).\n\n### Writing Text\nWriting text to the console via the framebuffer is done with memory-mapped I/O.\nThe starting address of the memory-mapped I/O for the framebuffer is\n`0x000B8000` [@wiki:vga-compat]. The memory is divided into 16 bit cells, where\nthe 16 bits determine both the character, the foreground color and the\nbackground color. The highest eight bits is the ASCII [@wiki:ascii] value of\nthe character, bit 7 - 4 the background and bit 3 - 0 the foreground, as can be\nseen in the following figure:\n\n    Bit:     | 15 14 13 12 11 10 9 8 | 7 6 5 4 | 3 2 1 0 |\n    Content: | ASCII                 | FG      | BG      |\n\nThe available colors are shown in the following table:\n\n Color Value       Color Value         Color Value          Color Value\n------ ------ ---------- ------- ----------- ------ ------------- ------\n Black 0             Red 4         Dark grey 8          Light red 12\n  Blue 1         Magenta 5        Light blue 9      Light magenta 13\n Green 2           Brown 6       Light green 10       Light brown 14\n  Cyan 3      Light grey 7        Light cyan 11             White 15\n\nThe first cell corresponds to row zero, column zero on the console.  Using an\nASCII table, one can see that A corresponds to 65 or `0x41`. Therefore, to\nwrite the character A with a green foreground (2) and dark grey background (8)\nat place (0,0), the following assembly code instruction is used:\n\n~~~ {.nasm}\n    mov [0x000B8000], 0x4128\n~~~\n\nThe second cell then corresponds to row zero, column one and its address is\ntherefore:\n\n~~~\n    0x000B8000 + 16 = 0x000B8010\n~~~\n\nWriting to the framebuffer can also be done in C by treating the address\n`0x000B8000` as a char pointer, `char *fb = (char *) 0x000B8000`. Then, writing\nA at place (0,0) with green foreground and dark grey background becomes:\n\n~~~ {.nasm}\n    fb[0] = 'A';\n    fb[1] = 0x28;\n~~~\n\nThe following code shows how this can be wrapped into a function:\n\n~~~ {.c}\n    /** fb_write_cell:\n     *  Writes a character with the given foreground and background to position i\n     *  in the framebuffer.\n     *\n     *  @param i  The location in the framebuffer\n     *  @param c  The character\n     *  @param fg The foreground color\n     *  @param bg The background color\n     */\n    void fb_write_cell(unsigned int i, char c, unsigned char fg, unsigned char bg)\n    {\n        fb[i] = c;\n        fb[i + 1] = ((fg & 0x0F) << 4) | (bg & 0x0F)\n    }\n~~~\n\nThe function can then be used as follows:\n\n~~~ {.c}\n    #define FB_GREEN     2\n    #define FB_DARK_GREY 8\n\n    fb_write_cell(0, 'A', FB_GREEN, FB_DARK_GREY);\n~~~\n\n### Moving the Cursor\n\nMoving the cursor of the framebuffer is done via two different I/O ports. The\ncursor's position is determined with a 16 bits integer: 0 means row zero,\ncolumn zero; 1 means row zero, column one; 80 means row one, column zero and so\non.  Since the position is 16 bits large, and the `out` assembly code instruction\nargument is 8 bits, the position must be sent in two turns, first 8 bits then\nthe next 8 bits. The framebuffer has two I/O ports, one for accepting the data,\nand one for describing the data being received. Port `0x3D4` [@osdev:vga] is\nthe port that describes the data and port `0x3D5` [@osdev:vga] is for the data\nitself.\n\nTo set the cursor at row one, column zero (position `80 = 0x0050`), one would\nuse the following assembly code instructions:\n\n~~~ {.nasm}\n    out 0x3D4, 14      ; 14 tells the framebuffer to expect the highest 8 bits of the position\n    out 0x3D5, 0x00    ; sending the highest 8 bits of 0x0050\n    out 0x3D4, 15      ; 15 tells the framebuffer to expect the lowest 8 bits of the position\n    out 0x3D5, 0x50    ; sending the lowest 8 bits of 0x0050\n~~~\n\nThe `out` assembly code instruction can't be executed directly in C. Therefore it is a good idea\nto wrap `out` in a function in assembly code which can be accessed from C via the cdecl\ncalling standard [@wiki:ccall]:\n\n~~~ {.nasm}\n    global outb             ; make the label outb visible outside this file\n\n    ; outb - send a byte to an I/O port\n    ; stack: [esp + 8] the data byte\n    ;        [esp + 4] the I/O port\n    ;        [esp    ] return address\n    outb:\n        mov al, [esp + 8]    ; move the data to be sent into the al register\n        mov dx, [esp + 4]    ; move the address of the I/O port into the dx register\n        out dx, al           ; send the data to the I/O port\n        ret                  ; return to the calling function\n~~~\n\nBy storing this function in a file called `io.s` and also creating a header\n`io.h`, the `out` assembly code instruction can be conveniently accessed from C:\n\n~~~ {.c}\n    #ifndef INCLUDE_IO_H\n    #define INCLUDE_IO_H\n\n    /** outb:\n     *  Sends the given data to the given I/O port. Defined in io.s\n     *\n     *  @param port The I/O port to send the data to\n     *  @param data The data to send to the I/O port\n     */\n    void outb(unsigned short port, unsigned char data);\n\n    #endif /* INCLUDE_IO_H */\n~~~\n\nMoving the cursor can now be wrapped in a C function:\n\n~~~ {.c}\n    #include \"io.h\"\n\n    /* The I/O ports */\n    #define FB_COMMAND_PORT         0x3D4\n    #define FB_DATA_PORT            0x3D5\n\n    /* The I/O port commands */\n    #define FB_HIGH_BYTE_COMMAND    14\n    #define FB_LOW_BYTE_COMMAND     15\n\n    /** fb_move_cursor:\n     *  Moves the cursor of the framebuffer to the given position\n     *\n     *  @param pos The new position of the cursor\n     */\n    void fb_move_cursor(unsigned short pos)\n    {\n        outb(FB_COMMAND_PORT, FB_HIGH_BYTE_COMMAND);\n        outb(FB_DATA_PORT,    ((pos >> 8) & 0x00FF));\n        outb(FB_COMMAND_PORT, FB_LOW_BYTE_COMMAND);\n        outb(FB_DATA_PORT,    pos & 0x00FF);\n    }\n~~~\n\n### The Driver\nThe driver should provide an interface that the rest of the code in the OS will\nuse for interacting with the framebuffer.  There is no right or wrong in what\nfunctionality the interface should provide, but a suggestion is to have a\n`write` function with the following declaration:\n\n~~~ {.c}\n    int write(char *buf, unsigned int len);\n~~~\n\nThe `write` function writes the contents of the buffer `buf` of length `len` to\nthe screen. The `write` function should automatically advance the cursor after a\ncharacter has been written and scroll the screen if necessary.\n\n## The Serial Ports\nThe serial port [@wiki:serial] is an interface for\ncommunicating between hardware devices and although it is available on almost\nall motherboards, it is seldom exposed to the user in the form of a DE-9\nconnector nowadays. The serial port is easy to use, and, more importantly, it\ncan be used as a logging utility in Bochs. If a computer has support for a\nserial port, then it usually has support for multiple serial ports, but we will\nonly make use of one of the ports. This is because we will only use the serial\nports for logging. Furthermore, we will only use the serial ports for output,\nnot input. The serial ports are completely controlled via I/O ports.\n\n### Configuring the Serial Port\nThe first data that need to be sent to the serial port is configuration\ndata. In order for two hardware devices to be able to talk to each other they\nmust agree upon a couple of things. These things include:\n\n- The speed used for sending data (bit or baud rate)\n- If any error checking should be used for the data (parity bit, stop bits)\n- The number of bits that represent a unit of data (data bits)\n\n### Configuring the Line\nConfiguring the line means to configure how data is being sent over the line.\nThe serial port has an I/O port, the _line command port_, that is used for\nconfiguration.\n\nFirst the speed for sending data will be set. The serial port has an internal\nclock that runs at 115200 Hz. Setting the speed means sending a divisor to the\nserial port, for example sending 2 results in a speed of `115200 / 2 = 57600`\nHz.\n\nThe divisor is a 16 bit number but we can only send 8 bits at a time.  We must\ntherefore send an instruction telling the serial port to first expect the\nhighest 8 bits, then the lowest 8 bits. This is done by sending `0x80` to the\nline command port. An example is shown below:\n\n~~~ {.c}\n    #include \"io.h\" /* io.h is implement in the section \"Moving the cursor\" */\n\n    /* The I/O ports */\n\n    /* All the I/O ports are calculated relative to the data port. This is because\n     * all serial ports (COM1, COM2, COM3, COM4) have their ports in the same\n     * order, but they start at different values.\n     */\n\n    #define SERIAL_COM1_BASE                0x3F8      /* COM1 base port */\n\n    #define SERIAL_DATA_PORT(base)          (base)\n    #define SERIAL_FIFO_COMMAND_PORT(base)  (base + 2)\n    #define SERIAL_LINE_COMMAND_PORT(base)  (base + 3)\n    #define SERIAL_MODEM_COMMAND_PORT(base) (base + 4)\n    #define SERIAL_LINE_STATUS_PORT(base)   (base + 5)\n\n    /* The I/O port commands */\n\n    /* SERIAL_LINE_ENABLE_DLAB:\n     * Tells the serial port to expect first the highest 8 bits on the data port,\n     * then the lowest 8 bits will follow\n     */\n    #define SERIAL_LINE_ENABLE_DLAB         0x80\n\n    /** serial_configure_baud_rate:\n     *  Sets the speed of the data being sent. The default speed of a serial\n     *  port is 115200 bits/s. The argument is a divisor of that number, hence\n     *  the resulting speed becomes (115200 / divisor) bits/s.\n     *\n     *  @param com      The COM port to configure\n     *  @param divisor  The divisor\n     */\n    void serial_configure_baud_rate(unsigned short com, unsigned short divisor)\n    {\n        outb(SERIAL_LINE_COMMAND_PORT(com),\n             SERIAL_LINE_ENABLE_DLAB);\n        outb(SERIAL_DATA_PORT(com),\n             (divisor >> 8) & 0x00FF);\n        outb(SERIAL_DATA_PORT(com),\n             divisor & 0x00FF);\n    }\n~~~\n\nThe way that data should be sent must be configured. This is also done\nvia the line command port by sending a byte. The layout of the 8 bits looks\nlike the following:\n\n    Bit:     | 7 | 6 | 5 4 3 | 2 | 1 0 |\n    Content: | d | b | prty  | s | dl  |\n\nA description for each name can be found in the table below (and in\n[@osdev:serial]):\n\n Name Description\n----- ------------\n    d Enables (`d = 1`) or disables (`d = 0`) DLAB\n    b If break control is enabled (`b = 1`) or disabled (`b = 0`)\n prty The number of parity bits to use\n    s The number of stop bits to use (`s = 0` equals 1, `s = 1` equals 1.5 or 2)\n   dl Describes the length of the data\n\nWe will use the mostly standard value `0x03` [@osdev:serial], meaning a length\nof 8 bits, no parity bit, one stop bit and break control disabled. This is sent\nto the line command port, as seen in the following example:\n\n~~~ {.c}\n    /** serial_configure_line:\n     *  Configures the line of the given serial port. The port is set to have a\n     *  data length of 8 bits, no parity bits, one stop bit and break control\n     *  disabled.\n     *\n     *  @param com  The serial port to configure\n     */\n    void serial_configure_line(unsigned short com)\n    {\n        /* Bit:     | 7 | 6 | 5 4 3 | 2 | 1 0 |\n         * Content: | d | b | prty  | s | dl  |\n         * Value:   | 0 | 0 | 0 0 0 | 0 | 1 1 | = 0x03\n         */\n        outb(SERIAL_LINE_COMMAND_PORT(com), 0x03);\n    }\n~~~\n\nThe article on OSDev [@osdev:serial] has a more in-depth explanation of the\nvalues.\n\n### Configuring the Buffers\nWhen data is transmitted via the serial port it is placed in buffers, both\nwhen receiving and sending data. This way, if you send data to the serial\nport faster than it can send it over the wire, it will be buffered. However, if\nyou send too much data too fast the buffer will be full and data will be\nlost. In other words, the buffers are FIFO queues.\nThe FIFO queue configuration byte looks like the following figure:\n\n    Bit:     | 7 6 | 5  | 4 | 3   | 2   | 1   | 0 |\n    Content: | lvl | bs | r | dma | clt | clr | e |\n\nA description for each name can be found in the table below:\n\n Name Description\n----- ------------\n  lvl How many bytes should be stored in the FIFO buffers\n   bs If the buffers should be 16 or 64 bytes large\n    r Reserved for future use\n  dma How the serial port data should be accessed\n  clt Clear the transmission FIFO buffer\n  clr Clear the receiver FIFO buffer\n    e If the FIFO buffer should be enabled or not\n\nWe use the value `0xC7 = 11000111` that:\n\n- Enables FIFO\n- Clear both receiver and transmission FIFO queues\n- Use 14 bytes as size of queue\n\nThe WikiBook on serial programming [@wikibook:serial] explains the values in\nmore depth.\n\n### Configuring the Modem\nThe modem control register is used for very simple hardware flow control via\nthe Ready To Transmit (RTS) and Data Terminal Ready (DTR) pins. When\nconfiguring the serial port we want RTS and DTR to be 1, which means that we\nare ready to send data.\n\nThe modem configuration byte is shown in the following figure:\n\n    Bit:     | 7 | 6 | 5  | 4  | 3   | 2   | 1   | 0   |\n    Content: | r | r | af | lb | ao2 | ao1 | rts | dtr |\n\nA description for each name can be found in the table below:\n\n Name Description\n----- ------------\n    r Reserved\n   af Autoflow control enabled\n   lb Loopback mode (used for debugging serial ports)\n  ao2 Auxiliary output 2, used for receiving interrupts\n  ao1 Auxiliary output 1\n  rts Ready To Transmit\n  dtr Data Terminal Ready\n\nWe don't need to enable interrupts, because we won't handle any received data.\nTherefore we use the configuration value `0x03 = 00000011` (RTS = 1 and DTS =\n1).\n\n### Writing Data to the Serial Port\n\nWriting data to the serial port is done via the data I/O port. However, before\nwriting, the transmit FIFO queue has to be empty (all previous writes must have\nfinished). The transmit FIFO queue is empty if bit 5 of the line status I/O\nport is equal to one.\n\nReading the contents of an I/O port is done via the `in` assembly code instruction.\nThere is no way to use the `in` assembly code instruction from C, therefore it has\nto be wrapped (the same way as the `out` assembly code instruction):\n\n~~~ {.nasm}\n    global inb\n\n    ; inb - returns a byte from the given I/O port\n    ; stack: [esp + 4] The address of the I/O port\n    ;        [esp    ] The return address\n    inb:\n        mov dx, [esp + 4]       ; move the address of the I/O port to the dx register\n        in  al, dx              ; read a byte from the I/O port and store it in the al register\n        ret                     ; return the read byte\n~~~\n\n~~~ {.c}\n    /* in file io.h */\n\n    /** inb:\n     *  Read a byte from an I/O port.\n     *\n     *  @param  port The address of the I/O port\n     *  @return      The read byte\n     */\n    unsigned char inb(unsigned short port);\n~~~\n\nChecking if the transmit FIFO is empty can then be done from C:\n\n~~~ {.c}\n    #include \"io.h\"\n\n    /** serial_is_transmit_fifo_empty:\n     *  Checks whether the transmit FIFO queue is empty or not for the given COM\n     *  port.\n     *\n     *  @param  com The COM port\n     *  @return 0 if the transmit FIFO queue is not empty\n     *          1 if the transmit FIFO queue is empty\n     */\n    int serial_is_transmit_fifo_empty(unsigned int com)\n    {\n        /* 0x20 = 0010 0000 */\n        return inb(SERIAL_LINE_STATUS_PORT(com)) & 0x20;\n    }\n~~~\n\nWriting to a serial port means spinning as long as the transmit FIFO queue\nisn't empty, and then writing the data to the data I/O port.\n\n### Configuring Bochs\nTo save the output from the first serial serial port the Bochs configuration\nfile `bochsrc.txt` must be updated.\nThe `com1` configuration instructs Bochs how to handle first\nserial port:\n\n~~~\n    com1: enabled=1, mode=file, dev=com1.out\n~~~\n\nThe output from serial port one will now be stored in the file `com1.out`.\n\n### The Driver\nWe recommend that you implement a `write` function for the serial port similar\nto the `write` function in the driver for the framebuffer. To avoid name\nclashes with the `write` function for the framebuffer it is a good idea to name\nthe functions `fb_write` and `serial_write` to distinguish them.\n\nWe further recommend that you try to write a `printf`-like function, see\nsection 7.3 in [@knr]. The `printf` function could take an additional argument\nto decide to which device to write the output (framebuffer or serial).\n\nA final recommendation is that you create some way of\ndistinguishing the severeness of the log messages, for example by prepending\nthe messages with `DEBUG`, `INFO` or `ERROR`.\n\n## Further Reading\n- The book \"Serial programming\" (available on WikiBooks) has a great section on\n  programming the serial port,\n  <http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming#UART_Registers>\n- The OSDev wiki has a page with a lot of information about the serial ports,\n  <http://wiki.osdev.org/Serial_ports>\n"
        },
        {
          "name": "page_frame_allocation.md",
          "type": "blob",
          "size": 5.8701171875,
          "content": "# Page Frame Allocation\n\nWhen using virtual memory, how does the OS know which parts of memory are free\nto use? That is the role of the page frame allocator.\n\n## Managing Available Memory\n\n### How Much Memory is There?\n\nFirst we need to know how much memory is available on the computer the OS is\nrunning on.\nThe easiest way to do this is to read it from the multiboot structure\n[@multiboot] passed to us by GRUB. GRUB collects the information we need about\nthe memory - what is reserved, I/O mapped, read-only etc. We must also make\nsure that we don't mark the part of memory used by the kernel as free (since\nGRUB doesn't mark this memory as reserved). One way to know how much memory the\nkernel uses is to export labels at the beginning and the end of the kernel\nbinary from the linker script:\n\n~~~\n    ENTRY(loader)           /* the name of the entry symbol */\n\n    . = 0xC0100000          /* the code should be relocated to 3 GB + 1 MB */\n\n    /* these labels get exported to the code files */\n    kernel_virtual_start = .;\n    kernel_physical_start = . - 0xC0000000;\n\n    /* align at 4 KB and load at 1 MB */\n    .text ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)\n    {\n        *(.text)            /* all text sections from all files */\n    }\n\n    /* align at 4 KB and load at 1 MB + . */\n    .rodata ALIGN (0x1000) : AT(ADDR(.rodata)-0xC0000000)\n    {\n        *(.rodata*)         /* all read-only data sections from all files */\n    }\n\n    /* align at 4 KB and load at 1 MB + . */\n    .data ALIGN (0x1000) : AT(ADDR(.data)-0xC0000000)\n    {\n        *(.data)            /* all data sections from all files */\n    }\n\n    /* align at 4 KB and load at 1 MB + . */\n    .bss ALIGN (0x1000) : AT(ADDR(.bss)-0xC0000000)\n    {\n        *(COMMON)           /* all COMMON sections from all files */\n        *(.bss)             /* all bss sections from all files */\n    }\n\n    kernel_virtual_end = .;\n    kernel_physical_end = . - 0xC0000000;\n~~~\n\nThese labels can directly be read from assembly code and pushed on the stack to\nmake them available to C code:\n\n~~~ {.nasm}\n    extern kernel_virtual_start\n    extern kernel_virtual_end\n    extern kernel_physical_start\n    extern kernel_physical_end\n\n    ; ...\n\n    push kernel_physical_end\n    push kernel_physical_start\n    push kernel_virtual_end\n    push kernel_virtual_start\n\n    call kmain\n~~~\n\nThis way we get the labels as arguments to `kmain`. If you want to use C\ninstead of assembly code, one way to do it is to declare the labels as functions and\ntake the addresses of these functions:\n\n~~~ {.c}\n    void kernel_virtual_start(void);\n\n    /* ... */\n\n    unsigned int vaddr = (unsigned int) &kernel_virtual_start;\n~~~\n\nIf you use GRUB modules you need to make sure the memory they use is marked as\nreserved as well.\n\nNote that the available memory does not need to be contiguous. In the first 1 MB\nthere are several I/O-mapped memory sections, as well as memory used by GRUB\nand the BIOS. Other parts of the memory might be similarly unavailable.\n\nIt's convenient to divide the memory sections into complete page frames, as we\ncan't map part of pages into memory.\n\n### Managing Available Memory\n\nHow do we know which page frames are in use? The page frame allocator needs to\nkeep track of which are free and which aren't. There are several ways to do\nthis: bitmaps, linked lists, trees, the Buddy System (used by Linux) etc.\nFor more information about the different algorithms see the article on OSDev\n[@osdev:pfa].\n\nBitmaps are quite easy to implement. One bit is used for each page frame and\none (or more) page frames are dedicated to store the bitmap. (Note that this is\njust one way to do it, other designs might be better and/or more fun to\nimplement.)\n\n## How Can We Access a Page Frame?\n\nThe page frame allocator returns the\nphysical start address of the page frame. This page frame is not mapped in - no\npage table points to this page frame. How can we read and write data to the\nframe?\n\nWe need to map the page frame into virtual memory, by updating the PDT and/or\nPT used by the kernel. What if all available page tables are full? Then we\ncan't map the page frame into memory, because we'd need a new page table -\nwhich takes up an entire page frame - and to write to this page frame we'd need\nto map its page frame... Somehow this circular dependency must be broken.\n\nOne solution is to reserve a part of the first page table used by the kernel\n(or some other higher-half page table) for temporarily mapping page frames to\nmake them accessible. If the kernel is mapped at `0xC0000000` (page\ndirectory entry with index 768), and 4 KB page frames are used, then the kernel\nhas at least one page table. If we assume - or limit us to - a kernel of size at\nmost 4 MB minus 4 KB we can dedicate the last entry (entry 1023) of this page\ntable for temporary mappings. The virtual address of pages mapped in using the\nlast entry of the kernel's PT will be:\n\n~~~\n    (768 << 22) | (1023 << 12) | 0x000 = 0xC03FF000\n~~~\n\nAfter we've temporarily mapped the page frame we want to use as a page\ntable, and set it up to map in our first page frame, we can add it to the\npaging directory, and remove the temporary mapping.\n\n## A Kernel Heap\n\nSo far we've only been able to work with fixed-size data, or directly with raw\nmemory. Now that we have a page frame allocator we can implement `malloc` and\n`free` to use in the kernel.\n\nKernighan and Ritchie [@knr] have an example implementation in their book [@knr] that\nwe can draw inspiration from. The only modification we need to do is to\nreplace calls to `sbrk`/`brk` with calls to the page frame allocator when more\nmemory is needed. We must also make sure to map the page frames returned by the\npage frame allocator to virtual addresses.\nA correct implementation should also return page frames to the page frame\nallocator on call to `free`, whenever sufficiently large blocks of memory are\nfreed.\n\n## Further reading\n\n- The OSDev wiki page on page frame allocation:\n  <http://wiki.osdev.org/Page_Frame_Allocation>\n"
        },
        {
          "name": "paging.md",
          "type": "blob",
          "size": 15.109375,
          "content": "# Paging\n\nSegmentation translates a logical address into a linear address. _Paging_\ntranslates these linear addresses onto the physical address space, and\ndetermines access rights and how the memory should be cached.\n\n## Why Paging?\n\nPaging is the most common technique used in x86 to enable virtual memory.\nVirtual memory through paging means that each process will get the impression\nthat the available memory range is `0x00000000` - `0xFFFFFFFF` even though the\nactual size of the memory might be much less. It also means that when a process\naddresses a byte of memory it will use a virtual (linear) address instead of\nphysical one. The code in the user process won't notice any difference (except\nfor execution delays). The linear address gets translated to a physical address\nby the MMU and the page table. If the virtual address isn't mapped to a\nphysical address, the CPU will raise a page fault interrupt.\n\nPaging is optional, and some operating systems do not make use of it. But if we\nwant to mark certain areas of memory accessible only to code running at a\ncertain privilege level (to be able to have processes running at different\nprivilege levels), paging is the neatest way to do it.\n\n## Paging in x86\n\nPaging in x86 (chapter 4 in the Intel manual [@intel3a]) consists of a _page\ndirectory_ (PDT) that can contain references to 1024 _page tables_ (PT), each of\nwhich can point to 1024 sections of physical memory called _page frames_ (PF).\nEach page frame is 4096 byte large. In a virtual (linear) address, the\nhighest 10 bits specifies the offset of a page directory entry (PDE) in the\ncurrent PDT, the next 10 bits the offset of a page table entry (PTE)\nwithin the page table pointed to by that PDE. The lowest 12 bits in the address\nis the offset within the page frame to be addressed.\n\nAll page directories, page tables and page frames need to be aligned on 4096\nbyte addresses. This makes it possible to address a PDT, PT or PF with just the\nhighest 20 bits of a 32 bit address, since the lowest 12 need to be zero.\n\nThe PDE and PTE structure is very similar to each other: 32 bits (4 bytes),\nwhere the highest 20 bits points to a PTE or PF, and the lowest 12 bits control\naccess rights and other configurations. 4 bytes times 1024 equals 4096 bytes,\nso a page directory and page table both fit in a page frame themselves.\n\nThe translation of linear addresses to physical addresses is described in\nthe figure below.\n\nWhile pages are normally 4096 bytes, it is also possible to use 4 MB pages. A\nPDE then points directly to a 4 MB page frame, which needs to be aligned on a 4\nMB address boundary. The address translation is almost the same as in the\nfigure, with just the page table step removed. It is possible to mix 4 MB and 4\nKB pages.\n\n![Translating virtual addresses (linear addresses) to physical addresses.\n](images/intel_4_2_linear_address_translation.png)\n\nThe 20 bits pointing to the current PDT is stored in the register `cr3`. The\nlower 12 bits of `cr3` are used for configuration.\n\nFor more details on the paging structures, see chapter 4 in the Intel manual\n[@intel3a]. The most interesting bits are _U/S_, which determine what privilege\nlevels can access this page (PL0 or PL3), and _R/W_, which makes the memory in\nthe page read-write or read-only.\n\n### Identity Paging\n\nThe simplest kind of paging is when we map each virtual address onto the same\nphysical address, called _identity paging_. This can be done at compile time\nby creating a page directory where each entry points to its\ncorresponding 4 MB frame. In NASM this can be done with macros and commands\n(`%rep`, `times` and `dd`). It can of course also be done at run-time by using\nordinary assembly code instructions.\n\n### Enabling Paging\n\nPaging is enabled by first writing the address of a page directory to `cr3` and\nthen setting bit 31 (the PG \"paging-enable\" bit) of `cr0` to `1`. To use 4\nMB pages, set the PSE bit (Page Size Extensions, bit 4) of `cr4`. The following\nassembly code shows an example:\n\n~~~ {.nasm}\n    ; eax has the address of the page directory\n    mov cr3, eax\n\n    mov ebx, cr4        ; read current cr4\n    or  ebx, 0x00000010 ; set PSE\n    mov cr4, ebx        ; update cr4\n\n    mov ebx, cr0        ; read current cr0\n    or  ebx, 0x80000000 ; set PG\n    mov cr0, ebx        ; update cr0\n\n    ; now paging is enabled\n~~~\n\n### A Few Details\n\nIt is important to note that all addresses within the page directory, page\ntables and in `cr3` need to be physical addresses to the structures, never\nvirtual. This will be more relevant in later sections where we dynamically\nupdate the paging structures (see the chapter [\"User Mode\"](#user-mode)).\n\nAn instruction that is useful when an updating a PDT or PT is `invlpg`. It\ninvalidates the _Translation Lookaside Buffer_ (TLB) entry for a virtual\naddress. The TLB is a cache for translated addresses, mapping physical\naddresses corresponding to virtual addresses.\nThis is only required when changing a PDE or PTE that was previously\nmapped to something else. If the PDE or PTE had previously been marked as not\npresent (bit 0 was set to 0), executing `invlpg` is unnecessary. Changing the\nvalue of `cr3` will cause all entries in the TLB to be invalidated.\n\nAn example of invalidating a TLB entry is shown below:\n\n~~~ {.nasm}\n    ; invalidate any TLB references to virtual address 0\n    invlpg [0]\n~~~\n\n## Paging and the Kernel\nThis section will describe how paging affects the OS kernel. We\nencourage you to run your OS using identity paging before trying to implement a\nmore advanced paging setup, since it can be hard to debug a malfunctioning\npage table that is set up via assembly code.\n\n### Reasons to Not Identity Map the Kernel\n\nIf the kernel is placed at the beginning of the virtual address space - that\nis, the virtual address space (`0x00000000`, `\"size of kernel\"`) maps to the\nlocation of the kernel in memory - there will be issues when linking the user\nmode process code. Normally, during linking, the linker assumes that the code\nwill be loaded into the memory position `0x00000000`. Therefore, when resolving\nabsolute references, `0x00000000` will be the base address for calculating the\nexact position. But if the kernel is mapped onto the virtual address space\n(`0x00000000`, `\"size of kernel\"`), the user mode process cannot be loaded at\nvirtual address `0x00000000` - it must be placed somewhere else. Therefore, the\nassumption from the linker that the user mode process is loaded into memory at\nposition `0x00000000` is wrong. This can be corrected by using a linker script\nwhich tells the linker to assume a different starting address, but that is a\nvery cumbersome solution for the users of the operating system.\n\nThis also assumes that we want the kernel to be part of the user mode process'\naddress space. As we will see later, this is a nice feature, since during\nsystem calls we don't have to change any paging structures to get access to the\nkernel's code and data. The kernel pages will of course require privilege level\n0 for access, to prevent a user process from reading or writing kernel memory.\n\n### The Virtual Address for the Kernel\n\nPreferably, the kernel should be placed at a very high virtual memory address,\nfor example `0xC0000000` (3 GB). The user mode process is not likely to\nbe 3 GB large, which is now the only way that it can conflict with the\nkernel. When the kernel uses virtual addresses at 3 GB and above it is called a\n_higher-half kernel_. `0xC0000000` is just an example, the kernel can be placed\nat any address higher than 0 to get the same benefits. Choosing the correct\naddress depends on how much virtual memory should be available for the kernel\n(it is easiest if all memory above the kernel virtual address should belong to the\nkernel) and how much virtual memory should be available for the process.\n\nIf the user mode process is larger than 3 GB, some pages will need to be\nswapped out by the kernel. Swapping pages is not part of this book.\n\n### Placing the Kernel at `0xC0000000`\nTo start with, it is better to place the kernel at `0xC0100000` than\n`0xC0000000`, since this makes it possible to map (`0x00000000`, `0x00100000`)\nto (`0xC0000000`, `0xC0100000`). This way, the entire range (`0x00000000`,\n`\"size of kernel\"`) of memory is mapped to the range\n(`0xC0000000`, `0xC0000000  + \"size of kernel\"`).\n\nPlacing the kernel at `0xC0100000` isn't hard, but it does require some\nthought. This is once again a linking problem.  When the linker resolves all\nabsolute references in the kernel, it will assume that our kernel is loaded at\nphysical memory location `0x00100000`, not `0x00000000`, since relocation is\nused in the linker script (see the section\n[\"Linking the kernel\"](#linking-the-kernel)). However, we want the jumps to be\nresolved using `0xC0100000` as base address, since otherwise a kernel jump will\njump straight into the user mode process code (remember that the user mode\nprocess is loaded at virtual memory `0x00000000`).\n\nHowever, we can't simply tell the linker to assume that the kernel starts (is\nloaded) at `0xC01000000`, since we want it to be loaded at the physical address\n`0x00100000`. The reason for having the kernel loaded at 1 MB is because it\ncan't be loaded at `0x00000000`, since there is BIOS and GRUB code loaded below\n1 MB. Furthermore, we cannot assume that we can load the kernel at\n`0xC0100000`, since the machine might not have 3 GB of physical memory.\n\nThis can be solved by using both relocation (`.=0xC0100000`) and the `AT`\ninstruction in the linker script. Relocation specifies that non-relative\nmemory-references should should use the relocation address as base in address\ncalculations. `AT` specifies where the kernel should be loaded into memory.\nRelocation is done at link time by GNU ld [@ldcmdlang], the load address\nspecified by `AT` is handled by GRUB when loading the kernel, and is part of\nthe ELF format [@wiki:elf].\n\n### Higher-half Linker Script\n\nWe can modify the [first linker script](#linking-the-kernel) to implement this:\n\n~~~\n    ENTRY(loader)           /* the name of the entry symbol */\n\n    . = 0xC0100000          /* the code should be relocated to 3GB + 1MB */\n\n    /* align at 4 KB and load at 1 MB */\n    .text ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)\n    {\n        *(.text)            /* all text sections from all files */\n    }\n\n    /* align at 4 KB and load at 1 MB + . */\n    .rodata ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)\n    {\n        *(.rodata*)         /* all read-only data sections from all files */\n    }\n\n    /* align at 4 KB and load at 1 MB + . */\n    .data ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)\n    {\n        *(.data)            /* all data sections from all files */\n    }\n\n    /* align at 4 KB and load at 1 MB + . */\n    .bss ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)\n    {\n        *(COMMON)           /* all COMMON sections from all files */\n        *(.bss)             /* all bss sections from all files */\n    }\n~~~\n\n### Entering the Higher Half\n\nWhen GRUB jumps to the kernel code, there is no paging table.  Therefore, all\nreferences to `0xC0100000 + X` won't be mapped to the correct physical address,\nand will therefore cause a general protection exception (GPE) at the very best,\notherwise (if the computer has more than 3 GB of memory) the computer will just\ncrash.\n\nTherefore, assembly code that doesn't use relative jumps or relative memory\naddressing must be used to do the following:\n\n- Set up a page table.\n- Add identity mapping for the first 4 MB of the virtual address space.\n- Add an entry for `0xC0100000` that maps to `0x0010000`\n\nIf we skip the identity mapping for the\nfirst 4 MB, the CPU would generate a page fault immediately after paging was\nenabled when trying to fetch the next instruction from memory. After the table\nhas been created, an jump can be done to a label to make `eip` point\nto a virtual address in the higher half:\n\n~~~ {.nasm}\n    ; assembly code executing at around 0x00100000\n    ; enable paging for both actual location of kernel\n    ; and its higher-half virtual location\n\n    lea ebx, [higher_half] ; load the address of the label in ebx\n    jmp ebx                ; jump to the label\n\n    higher_half:\n        ; code here executes in the higher half kernel\n        ; eip is larger than 0xC0000000\n        ; can continue kernel initialisation, calling C code, etc.\n~~~\n\nThe register `eip` will now point to a memory location somewhere right after\n`0xC0100000` - all the code can now execute as if it were located at\n`0xC0100000`, the higher-half.  The entry mapping of the first 4 MB of virtual\nmemory to the first 4 MB of physical memory can now be removed from the page\ntable and its corresponding entry in the TLB invalidated with `invlpg [0]`.\n\n### Running in the Higher Half\n\nThere are a few more details we must deal with when using a higher-half kernel.\nWe must be careful when using memory-mapped I/O that uses specific memory\nlocations. For example, the frame buffer is located at `0x000B8000`, but since\nthere is no entry in the page table for the address `0x000B8000` any longer,\nthe address `0xC00B8000` must be used, since the virtual address `0xC0000000`\nmaps to the physical address `0x00000000`.\n\nAny explicit references to addresses within the multiboot structure needs to be\nchanged to reflect the new virtual addresses as well.\n\nMapping 4 MB pages for the kernel is simple, but wastes memory (unless you have\na really big kernel). Creating a higher-half kernel mapped in as 4 KB pages\nsaves memory but is harder to set up. Memory for the page directory and one\npage table can be reserved in the `.data` section, but one needs to configure\nthe mappings from virtual to physical addresses at run-time. The size of the\nkernel can be determined by exporting labels from the linker script\n[@ldcmdlang], which we'll need to do later anyway when writing the page frame\nallocator (see the chapter [\"Page Frame Allocation](#page-frame-allocation)).\n\n## Virtual Memory Through Paging\n\nPaging enables two things that are good for virtual memory. First, it allows\nfor fine-grained access control to memory. You can mark pages as read-only,\nread-write, only for PL0 etc. Second, it creates the illusion of contiguous\nmemory. User mode processes, and the kernel, can access memory as if it\nwere contiguous, and the contiguous memory can be extended without the need\nto move data around in memory. We can also allow the user mode programs access\nto all memory below 3 GB, but unless they actually use it, we don't have to\nassign page frames to the pages. This allows processes to have code located\nnear `0x00000000` and the stack at just below `0xC0000000`, and still not\nrequire more than two actual pages.\n\n## Further Reading\n\n- Chapter 4 (and to some extent chapter 3) of the Intel manual [@intel3a] are\n  your definitive sources for the details about paging.\n- Wikipedia has an article on paging: <http://en.wikipedia.org/wiki/Paging>\n- The OSDev wiki has a page on paging: <http://wiki.osdev.org/Paging> and a\n  tutorial for making a higher-half kernel:\n  <http://wiki.osdev.org/Higher_Half_bare_bones>\n- Gustavo Duarte's article on how a kernel manages memory is well worth a read:\n  <http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory>\n- Details on the linker command language can be found at Steve Chamberlain's\n  website [@ldcmdlang].\n- More details on the ELF format can be found in this presentation:\n  <http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf>\n"
        },
        {
          "name": "references.md",
          "type": "blob",
          "size": 0.0126953125,
          "content": "# References\n"
        },
        {
          "name": "scheduling.md",
          "type": "blob",
          "size": 7.5966796875,
          "content": "# Multitasking\nHow do you make multiple processes appear to run at the same time? Today, this\nquestion has two answers:\n\n- With the availability of multi-core processors, or on system with multiple\n  processors, two processes can actually run at the same time by running two\n  processes on different cores or processors.\n- Fake it. That is, switch rapidly (faster than a human can notice) between the\n  processes. At any given moment there is only one process executing, but the\n  rapid switching gives the impression that they are running \"at the same\n  time\".\n\nSince the operating system created in this book does not support multi-core\nprocessors or multiple processors the only option is to fake it. The part of\nthe operating system responsible for rapidly switching between the processes is\ncalled the _scheduling algorithm_.\n\n## Creating New Processes\nCreating new processes is usually done with two different system calls: `fork`\nand `exec`. `fork` creates an exact copy of the currently running process,\nwhile `exec` replaces the current process with one that is specified by a\npath to the location of a program in the file system. Of these two we recommend\nthat you start implementing `exec`, since this system call will do almost\nexactly the same steps as described in the section [\"Setting up for user\nmode\"](#setting-up-for-user-mode) in the chapter [\"User Mode\"](#user-mode).\n\n## Cooperative Scheduling with Yielding\nThe easiest way to achieve rapid switching between processes is if the\nprocesses themselves are responsible for the switching. The processes\nrun for a while and then tell the OS (via a system call) that it can now switch\nto another process. Giving up the control of CPU to another process is called\n_yielding_ and when the processes themselves are responsible for the\nscheduling it's called _cooperative scheduling_, since all the processes must\ncooperate with each other.\n\nWhen a process yields the process' entire state must be saved (all the\nregisters), preferably on the kernel heap in a structure that represents a\nprocess. When changing to a new process all the registers must be restored from\nthe saved values.\n\nScheduling can be implemented by keeping a list of which processes are\nrunning. The system call `yield` should then run the next process in the list\nand put the current one last (other schemes are possible, but this is a simple\none).\n\nThe transfer of control to the new process is done via the `iret` assembly code\ninstruction in exactly the same way as explained in the section [\"Entering user\nmode\"](#entering-user-mode) in the chapter [\"User Mode\"](#user-mode).\n\nWe __strongly__ recommend that you start to implement support for multiple\nprocesses by implementing cooperative scheduling. We further recommend that you\nhave a working solution for both `exec`, `fork` and `yield` before implementing\npreemptive scheduling. Since cooperative scheduling is deterministic, it is\nmuch easier to debug than preemptive scheduling.\n\n## Preemptive Scheduling with Interrupts\nInstead of letting the processes themselves manage when to change to another\nprocess the OS can switch processes automatically after a short period of time.\nThe OS can set up the _programmable interval timer_ (PIT) to raise an interrupt\nafter a short period of time, for example 20 ms. In the interrupt handler for\nthe PIT interrupt the OS will change the running process to a new one. This\nway the processes themselves don't need to worry about scheduling. This kind\nof scheduling is called _preemptive scheduling_.\n\n### Programmable Interval Timer\nTo be able to do preemptive scheduling the PIT must first be configured to\nraise interrupts every _x_ milliseconds, where _x_ should be configurable.\n\nThe configuration of the PIT is very similar to the configuration of other\nhardware devices: a byte is sent to an I/O port. The command port of the PIT\nis `0x43`. To read about all the configuration options, see the article about\nthe PIT on OSDev [@osdev:pit]. We use the following options:\n\n- Raise interrupts (use channel 0)\n- Send the divider as low byte then high byte (see next section for an\n  explanation)\n- Use a square wave\n- Use binary mode\n\nThis results in the configuration byte `00110110`.\n\nSetting the interval for how often interrupts are to be raised is done via a\n_divider_, the same way as for the serial port. Instead of sending the PIT a\nvalue (e.g. in milliseconds) that says how often an interrupt should be raised\nyou send the divider. The PIT operates at 1193182 Hz as default. Sending the\ndivider 10 results in the PIT running at `1193182 / 10 = 119318` Hz. The\ndivider can only be 16 bits, so it is only possible to configure the timer's\nfrequency between 1193182 Hz and `1193182 / 65535 = 18.2` Hz. We recommend that\nyou create a function that takes an interval in milliseconds and converts it to\nthe correct divider.\n\nThe divider is sent to the channel 0 data I/O port of the PIT, but since only\none byte can be sent at at a time, the lowest 8 bits of the divider has to sent\nfirst, then the highest 8 bits of the divider can be sent. The channel 0 data\nI/O port is located at `0x40`. Again, see the article on OSDev [@osdev:pit] for\nmore details.\n\n### Separate Kernel Stacks for Processes\nIf all processes uses the same kernel stack (the stack exposed by the TSS)\nthere will be trouble if a process is interrupted while still in kernel mode.\nThe process that is being switched to will now use the same kernel stack and\nwill overwrite what the previous process have written on the stack (remember\nthat TSS data structure points to the _beginning_ of the stack).\n\nTo solve this problem every process should have it's own kernel stack, the\nsame way that each process have their own user mode stack. When switching\nprocess the TSS must be updated to point to the new process' kernel stack.\n\n### Difficulties with Preemptive Scheduling\nWhen using preemptive scheduling one problem arises that doesn't exist with\ncooperative scheduling. With cooperative scheduling every time a process\nyields, it must be in user mode (privilege level 3), since yield is a system\ncall. With preemptive scheduling, the processes can be interrupted in either\nuser mode or kernel mode (privilege level 0), since the process itself does not \ncontrol when it gets interrupted.\n\nInterrupting a process in kernel mode is a little bit different than\ninterrupting a process in user mode, due to the way the CPU sets up the stack\nat interrupts. If a privilege level change occurred (the process was interrupted\nin user mode) the CPU will push the value of the process `ss` and `esp`\nregister on the stack. If _no_ privilege level change occurs (the process was\ninterrupted in kernel mode) the CPU won't push the `esp` register on the\nstack. Furthermore, if there was no privilege level change, the CPU won't change\nstack to the one defined it the TSS.\n\nThis problem is solved by calculating what the value of `esp` was _before_\nthe interrupt. Since you know that the CPU pushes 3 things on the stack when no\nprivilege change happens and you know how much you have pushed on the stack,\nyou can calculate what the value of `esp` was at the time of the interrupt.\nThis is possible since the CPU won't change stacks if there is no privilege\nlevel change, so the content of `esp` will be the same as at the time of the\ninterrupt.\n\nTo further complicate things, one must think of how to handle case when\nswitching to a new process that should be running in kernel mode. Since `iret`\nis being used without a privilege level change the CPU won't update the value\nof `esp` with the one placed on the stack - you must update `esp` yourself.\n\n## Further Reading\n- For more information about different scheduling algorithms, see\n  <http://wiki.osdev.org/Scheduling_Algorithms>\n"
        },
        {
          "name": "segmentation.md",
          "type": "blob",
          "size": 7.734375,
          "content": "# Segmentation\n\n_Segmentation_ in x86 means accessing the memory through segments. Segments are\nportions of the address space, possibly overlapping, specified by a base\naddress and a limit. To address a byte in segmented memory you use a 48-bit\n_logical address_: 16 bits that specifies the segment and 32-bits that\nspecifies what offset within that segment you want. The offset is added to the\nbase address of the segment, and the resulting linear address is checked\nagainst the segment's limit - see the figure below. If everything works out\nfine (including access-rights checks ignored for now) the result is a _linear\naddress_. When paging is disabled, then\nthe linear address space is mapped 1:1 onto the _physical address_ space, and\nthe physical memory can be accessed. (See the chapter [\"Paging\"](#paging) for\nhow to enable paging.)\n\n![Translation of logical addresses to linear addresses.\n](images/intel_3_5_logical_to_linear.png)\n\nTo enable segmentation you need to set up a table that describes each segment -\na _segment descriptor table_. In x86, there are two types of descriptor tables:\nthe _Global Descriptor Table_ (GDT) and _Local Descriptor Tables_ (LDT). An LDT\nis set up and managed by user-space processes, and all processes have their own\nLDT.  LDTs can be used if a more complex segmentation model is desired - we\nwon't use it. The GDT is shared by everyone - it's global.\n\nAs we discuss in the sections on virtual memory and paging, segmentation is\nrarely used more than in a minimal setup, similar to what we do below.\n\n## Accessing Memory\nMost of the time when accessing memory there is no need to explicitly specify\nthe segment to use. The processor has six 16-bit segment registers: `cs`, `ss`,\n`ds`, `es`, `gs` and  `fs`. The register `cs` is the code segment register and\nspecifies the segment to use when fetching instructions. The register `ss` is\nused whenever accessing the stack (through the stack pointer `esp`), and `ds`\nis used for other data accesses. The OS is free to use the registers `es`, `gs`\nand `fs` however it want.\n\nBelow is an example showing implicit use of the segment registers:\n\n~~~ {.nasm}\n    func:\n        mov eax, [esp+4]\n        mov ebx, [eax]\n        add ebx, 8\n        mov [eax], ebx\n        ret\n~~~\n\nThe above example can be compared with the following one that makes explicit\nuse of the segment registers:\n\n~~~ {.nasm}\n    func:\n        mov eax, [ss:esp+4]\n        mov ebx, [ds:eax]\n        add ebx, 8\n        mov [ds:eax], ebx\n        ret\n~~~\n\nYou don't need to use `ss` for storing the stack segment selector, or `ds` for\nthe data segment selector. You could store the stack segment selector in `ds`\nand vice versa. However, in order to use the implicit style shown above, you\nmust store the segment selectors in their indented registers.\n\nSegment descriptors and their fields are described in figure 3-8 in the Intel\nmanual [@intel3a].\n\n## The Global Descriptor Table (GDT)\n\nA GDT/LDT is an array of 8-byte segment descriptors. The first descriptor in\nthe GDT is always a null descriptor and can never be used to access memory. At\nleast two segment descriptors (plus the null descriptor) are needed for the GDT,\nbecause the descriptor contains more information than just the base and\nlimit fields. The two most relevant fields for us are the _Type_ field and the\n_Descriptor Privilege Level_ (DPL) field.\n\nTable 3-1 in chapter 3 of the Intel manual [@intel3a] specifies the values for\nthe Type field. The table shows that the Type field can't be both\nwritable _and_ executable at the same time.\nTherefore, two segments are needed: one segment for executing code to put in\n`cs` (Type is Execute-only or Execute-Read) and one segment for reading and\nwriting data (Type is Read/Write) to put in the other segment registers.\n\nThe DPL specifies the _privilege levels_ required to use the segment. x86\nallows for four privilege levels (PL), 0 to 3, where PL0 is the most\nprivileged. In most operating systems (eg. Linux and Windows), only PL0 and PL3\nare used. However, some operating system, such as MINIX, make use of all\nlevels. The kernel should be able to do anything, therefore it uses segments\nwith DPL set to 0 (also called kernel mode). The current privilege level (CPL)\nis determined by the segment selector in `cs`.\n\nThe segments needed are described in the table below.\n\n  Index   Offset   Name                 Address range             Type   DPL\n-------  -------   -------------------  ------------------------- -----  ----\n      0   `0x00`   null descriptor\n      1   `0x08`   kernel code segment  `0x00000000 - 0xFFFFFFFF` RX     PL0\n      2   `0x10`   kernel data segment  `0x00000000 - 0xFFFFFFFF` RW     PL0\n\nTable: The segment descriptors needed.\n\nNote that the segments overlap - they both encompass the entire linear address\nspace. In our minimal setup we'll only use segmentation to get privilege levels.\nSee the Intel manual [@intel3a], chapter 3, for details on the other descriptor\nfields.\n\n## Loading the GDT\n\nLoading the GDT into the processor is done with the `lgdt` assembly code\ninstruction, which takes the address of a struct that specifies the start and\nsize of the GDT.  It is easiest to encode this information using a [\"packed\nstruct\"](#packing-structs) as shown in the following example:\n\n~~~ {.c}\n    struct gdt {\n        unsigned int address;\n        unsigned short size;\n    } __attribute__((packed));\n~~~\n\nIf the content of the `eax` register is the address to such a struct, then the\nGDT can be loaded with the assembly code shown below:\n\n~~~ {.nasm}\n    lgdt [eax]\n~~~\n\nIt might be easier if you make this instruction available from C, the same way\nas was done with the assembly code instructions `in` and `out`.\n\nAfter the GDT has been loaded the segment registers needs to be loaded with\ntheir corresponding segment selectors. The content of a segment selector is\ndescribed in the figure and table below:\n\n    Bit:     | 15                                3 | 2  | 1 0 |\n    Content: | offset (index)                      | ti | rpl |\n\n-------------------------------------------------------------------------\nName             Description\n---------------- -------------------------------------------------------\nrpl              Requested Privilege Level - we want to execute in PL0\n                 for now.\n\nti               Table Indicator. 0 means that this specifies a GDT segment, 1\n                 means an LDT Segment.\n\noffset (index)   Offset within descriptor table.\n------------------------------------------------------------------------\n\nTable: The layout of segment selectors.\n\nThe offset of the segment selector is added to the start of the GDT to get the\naddress of the segment descriptor: `0x08` for the first descriptor and `0x10`\nfor the second, since each descriptor is 8 bytes. The Requested Privilege Level\n(RPL) should be `0` since the kernel of the OS should execute in privilege\nlevel 0.\n\nLoading the segment selector registers is easy for the data registers - just\ncopy the correct offsets to the registers:\n\n~~~ {.nasm}\n    mov ds, 0x10\n    mov ss, 0x10\n    mov es, 0x10\n    .\n    .\n    .\n~~~\n\nTo load `cs` we have to do a \"far jump\":\n\n~~~ {.nasm}\n    ; code here uses the previous cs\n    jmp 0x08:flush_cs   ; specify cs when jumping to flush_cs\n\n    flush_cs:\n        ; now we've changed cs to 0x08\n~~~\n\nA far jump is a jump where we explicitly specify the full 48-bit logical\naddress: the segment selector to use and the absolute address to jump to. It\nwill first set `cs` to `0x08` and then jump to `flush_cs` using its absolute\naddress.\n\n## Further Reading\n\n- Chapter 3 of the Intel manual [@intel3a] is filled with low-level and\n  technical details about segmentation.\n- The OSDev wiki has a page about segmentation: <http://wiki.osdev.org/Segmentation>\n- The Wikipedia page on x86 segmentation might be worth looking into:\n  <http://en.wikipedia.org/wiki/X86_memory_segmentation>\n"
        },
        {
          "name": "syscalls.md",
          "type": "blob",
          "size": 3.349609375,
          "content": "# System Calls\n_System calls_ is the way user-mode applications interact with the kernel - to\nask for resources, request operations to be performed, etc. The system call API\nis the part of the kernel that is most exposed to the users, therefore its\ndesign requires some thought.\n\n## Designing System Calls\n\nIt is up to us, the kernel developers, to design the system calls that\napplication developers can use. We can draw inspiration from the POSIX\nstandards or, if they seem like too much work, just look at the ones for Linux,\nand pick and choose. See the section [\"Further Reading\"](#further-reading-7) at\nthe end of the chapter for references.\n\n## Implementing System Calls\n\nSystem calls are traditionally invoked with software interrupts. The user\napplications put the appropriate values in registers or on the stack and then\ninitiates a pre-defined interrupt which transfers execution to the kernel. The\ninterrupt number used is dependent on the kernel, Linux uses the number `0x80`\nto identify that an interrupt is intended as a system call.\n\nWhen system calls are executed, the current privilege level is typically\nchanged from PL3 to PL0 (if the application is running in user mode). To allow\nthis, the DPL of the entry in the IDT for the system call interrupt needs to\nallow PL3 access.\n\nWhenever inter-privilege level interrupts occur, the processor pushes a few\nimportant registers onto the stack - the same ones we used to enter user mode\n[before](#user-mode), see figure 6-4, section 6.12.1, in the Intel manual\n[@intel3a]. What stack is used? The same section in [@intel3a]\nspecifies that if an interrupt leads to code executing at a numerically lower\nprivilege level, a stack switch occurs. The new values for the registers `ss`\nand `esp` is loaded from the current Task State Segment (TSS). The TSS\nstructure is specified in figure 7-2, section 7.2.1 of the Intel manual\n[@intel3a].\n\nTo enable system calls we need to setup a TSS before entering user mode.\nSetting it up can be done in C by setting the `ss0` and `esp0` fields of a\n\"packed struct\" that represents a TSS. Before loading the \"packed struct\" into\nthe processor, a TSS descriptor has to be added to the GDT. The structure of\nthe TSS descriptor is described in section 7.2.2 in [@intel3a].\n\nYou specify the current TSS segment selector by loading it into the `tr`\nregister with the `ltr` assembly code instruction. If the TSS segment descriptor has\nindex 5, and thus offset `5 * 8 = 40 = 0x28`, this is the value that should be\nloaded into the register `tr`.\n\nWhen we entered user mode before in the chapter [\"Entering User\nMode\"](#entering-user-mode) we disabled interrupts when executing in PL3. Since\nsystem calls are implemented using interrupts, interrupts must be enabled in\nuser mode. Setting the IF flag bit in the `eflags` value on the stack will make\n`iret` enable interrupts (since the `eflags` value on the stack will be loaded\ninto the `eflags` register by the assembly code instruction `iret`).\n\n## Further Reading\n\n- The Wikipedia page on POSIX, with links to the specifications:\n  <http://en.wikipedia.org/wiki/POSIX>\n- A list of system calls used in Linux:\n  <http://bluemaster.iu.hio.no/edu/dark/lin-asm/syscalls.html>\n- The Wikipedia page on system calls:\n  <http://en.wikipedia.org/wiki/System_call>\n- The Intel manual [@intel3a] sections on interrupts (chapter 6) and TSS\n  (chapter 7) are where you get all the details you need.\n"
        },
        {
          "name": "template.html",
          "type": "blob",
          "size": 1.8134765625,
          "content": "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\"$if(lang)$ lang=\"$lang$\" xml:lang=\"$lang$\"$endif$>\n<head>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n  <meta http-equiv=\"Content-Style-Type\" content=\"text/css\" />\n  <meta name=\"generator\" content=\"pandoc\" />\n$for(author-meta)$\n  <meta name=\"author\" content=\"$author-meta$\" />\n$endfor$\n$if(date-meta)$\n  <meta name=\"date\" content=\"$date-meta$\" />\n$endif$\n  <title>$if(title-prefix)$$title-prefix$ - $endif$$if(pagetitle)$$pagetitle$$endif$</title>\n$if(highlighting-css)$\n  <style type=\"text/css\">\n$highlighting-css$\n  </style>\n$endif$\n$for(css)$\n  <link rel=\"stylesheet\" href=\"$css$\" $if(html5)$$else$type=\"text/css\" $endif$/>\n$endfor$\n$if(math)$\n  $math$\n$endif$\n$for(header-includes)$\n  $header-includes$\n$endfor$\n</head>\n<body>\n<div id='wrapper'>\n<div id=\"$idprefix$header\">\n<h1 class=\"title\">$title$</h1>\n$for(author)$\n<h2 class=\"author\">$author$</h2>\n$endfor$\n</div>\n<div class=\"subheader\">\n$if(date)$\n<a href=\"https://github.com/littleosbook/littleosbook/\">$date$</a>\n$endif$\n<a class=\"pdflink\" href=\"book.pdf\" title=\"PDF version\">PDF version</a>\n</div>\n<div id='content'>\n$for(include-before)$\n$include-before$\n$endfor$\n$if(title)$\n$endif$\n$if(toc)$\n<div id=\"$idprefix$TOC\">\n<h1>Contents</h1>\n$toc$\n</div>\n$endif$\n$body$\n$for(include-after)$\n$include-after$\n$endfor$\n</div>\n</div>\n\n<script type=\"text/javascript\">\n    (function() {\n        var tables = document.getElementsByTagName(\"table\");\n        for (var i = 0; i < tables.length; ++i) {\n            var table = tables[i];\n            if (table.getElementsByTagName(\"caption\").length > 0) {\n                table.className += \" has_caption\";\n            }\n        }\n     })();\n</script>\n</body>\n</html>\n"
        },
        {
          "name": "the_road_to_user_mode.md",
          "type": "blob",
          "size": 6.3525390625,
          "content": "# The Road to User Mode\n\nNow that the kernel boots, prints to screen and reads from keyboard - what do\nwe do? Usually, a kernel is not supposed to do the application logic itself,\nbut leave that for applications. The kernel creates the proper\nabstractions (for memory, files, devices) to make application development\neasier, performs tasks on behalf of applications (system calls) and\n[schedules processes](#multitasking).\n\nUser mode, in contrast with kernel mode, is the environment in which the user's\nprograms execute. This environment is less privileged than the kernel, and will\nprevent (badly written) user programs from messing with other programs or the\nkernel. Badly written kernels are free to mess up what they want.\n\nThere's quite a way to go until the OS created in this book can execute\nprograms in user mode, but this chapter will show how to easily execute a small\nprogram in kernel mode.\n\n## Loading an External Program\n\nWhere do we get the external program from? Somehow we need to load the code we\nwant to execute into memory. More feature-complete operating systems usually\nhave drivers and file systems that enable them to load the software from a CD-ROM\ndrive, a hard disk or other persistent media.\n\nInstead of creating all these drivers and file systems we will use a\nfeature in GRUB called modules to load the program.\n\n### GRUB Modules\n\nGRUB can load arbitrary files into memory from the ISO image, and these files\nare usually referred to as _modules_. To make GRUB load a module, edit the file\n`iso/boot/grub/menu.lst` and add the following line at the end of the file:\n\n~~~\n    module /modules/program\n~~~\n\nNow create the folder `iso/modules`:\n\n~~~\n    mkdir -p iso/modules\n~~~\n\nThe application `program` will be created later in this chapter.\n\nThe code that calls `kmain` must be updated to pass information to `kmain`\nabout where it can find the modules. We also want to tell GRUB that it should\nalign all the modules on page boundaries when loading them (see the chapter\n[\"Paging\"](#paging) for details about page alignment).\n\nTo instruct GRUB how to load our modules, the \"multiboot header\" - the first\nbytes of the kernel - must be updated as follows:\n\n~~~ {.nasm}\n    ; in file `loader.s`\n\n\n    MAGIC_NUMBER    equ 0x1BADB002      ; define the magic number constant\n    ALIGN_MODULES   equ 0x00000001      ; tell GRUB to align modules\n\n    ; calculate the checksum (all options + checksum should equal 0)\n    CHECKSUM        equ -(MAGIC_NUMBER + ALIGN_MODULES)\n\n    section .text:                      ; start of the text (code) section\n    align 4                             ; the code must be 4 byte aligned\n        dd MAGIC_NUMBER                 ; write the magic number\n        dd ALIGN_MODULES                ; write the align modules instruction\n        dd CHECKSUM                     ; write the checksum\n~~~\n\nGRUB will also store a pointer to a `struct` in the register `ebx` that, among\nother things, describes at which addresses the modules are loaded. Therefore,\nyou probably want to push `ebx` on the stack before calling `kmain` to make\nit an argument for `kmain`.\n\n## Executing a Program\n\n### A Very Simple Program\n\nA program written at this stage can only perform a few actions. Therefore, a\nvery short program that writes a value to a register suffices as a test\nprogram. Halting Bochs after a while and then check that register contains the\ncorrect number by looking in the Bochs log will verify that the program has\nrun. This is an example of such a short program:\n\n~~~ {.nasm}\n    ; set eax to some distinguishable number, to read from the log afterwards\n    mov eax, 0xDEADBEEF\n\n    ; enter infinite loop, nothing more to do\n    ; $ means \"beginning of line\", ie. the same instruction\n    jmp $\n~~~\n\n### Compiling\n\nSince our kernel cannot parse advanced executable formats we need to compile\nthe code into a flat binary. NASM can do this with the flag `-f`:\n\n~~~\n    nasm -f bin program.s -o program\n~~~\n\nThis is all we need. You must now move the file `program` to the folder\n`iso/modules`.\n\n### Finding the Program in Memory\nBefore jumping to the program we must find where it resides in memory.\nAssuming that the contents of `ebx` is passed as an argument to `kmain`, we\ncan do this entirely from C.\n\nThe pointer in `ebx` points to a _multiboot_ structure [@multiboot]. Download the\n`multiboot.h` file from\n<http://www.gnu.org/software/grub/manual/multiboot/html_node/multiboot.h.html>,\nwhich describes the structure.\n\nThe pointer passed to `kmain` in the `ebx` register can be cast to a\n`multiboot_info_t` pointer. The address of the first module is in the field\n`mods_addr`. The following code shows an example:\n\n~~~ {.c}\n    int kmain(/* additional arguments */ unsigned int ebx)\n    {\n        multiboot_info_t *mbinfo = (multiboot_info_t *) ebx;\n        unsigned int address_of_module = mbinfo->mods_addr;\n    }\n~~~\n\nHowever, before just blindly following the pointer, you should check that the\nmodule got loaded correctly by GRUB. This can be done by checking the `flags`\nfield of the `multiboot_info_t` structure. You should also check the field\n`mods_count` to make sure it is exactly 1. For more details about the multiboot\nstructure, see the multiboot documentation [@multiboot].\n\n### Jumping to the Code\nThe only thing left to do is to jump to the code loaded\nby GRUB.  Since it is easier to parse the multiboot structure in C than\nassembly code, calling the code from C is more convenient (it can of course be done\nwith `jmp` or `call` in assembly code as well). The C code could look like this:\n\n~~~ {.c}\n    typedef void (*call_module_t)(void);\n    /* ... */\n    call_module_t start_program = (call_module_t) address_of_module;\n    start_program();\n    /* we'll never get here, unless the module code returns */\n~~~\n\nIf we start the kernel, wait until it has run and entered the infinite loop in\nthe program, and then halt Bochs, we should see `0xDEADBEEF` in the register\n`eax` via the Bochs log. We have successfully started a program in our OS!\n\n## The Beginning of User Mode\n\nThe program we've written now runs at the same privilege level as the kernel -\nwe've just entered it in a somewhat peculiar way. To enable applications to\nexecute at a different privilege level we'll need to, beside\n[_segmentation_](#segmentation), do [_paging_](#paging) and [_page frame\nallocation_](#page-frame-allocation).\n\nIt's quite a lot of work and technical details to go through, but in a few\nchapters you'll have working user mode programs.\n"
        },
        {
          "name": "title.txt",
          "type": "blob",
          "size": 0.126953125,
          "content": "% The little book about OS development\n% Erik Helin, Adam Renberg\n% 2012-05-11 | Commit: 29e097ea98f6dddba5640bcb583198f3abf94ad4\n"
        },
        {
          "name": "user_mode.md",
          "type": "blob",
          "size": 8.2607421875,
          "content": "# User Mode\n\nUser mode is now almost within our reach, there are just a few more steps\nrequired to get there. Although these steps might seem easy the way they\nare presented in this chapter, they can be tricky to implement, since there are\na lot of places where small errors will cause bugs that are hard to find.\n\n## Segments for User Mode\n\nTo enable user mode we need to add two more segments to the GDT. They are very\nsimilar to the kernel segments we added when we [set up the\nGDT](#the-global-descriptor-table-gdt) in the [chapter about\nsegmentation](#segmentation):\n\n  Index   Offset   Name                 Address range             Type   DPL\n-------  -------   -------------------  ------------------------- -----  ----\n      3   `0x18`   user code segment    `0x00000000 - 0xFFFFFFFF` RX     PL3\n      4   `0x20`   user data segment    `0x00000000 - 0xFFFFFFFF` RW     PL3\n\nTable: The segment descriptors needed for user mode.\n\nThe difference is the DPL, which now allows code to execute in PL3. The\nsegments can still be used to address the entire address space, just using\nthese segments for user mode code will not protect the kernel. For that we need\npaging.\n\n## Setting Up For User Mode\n\nThere are a few things every user mode process needs:\n\n- Page frames for code, data and stack. At the moment it suffices to allocate\n  one page frame for the stack and enough page frames to fit the program's\n  code. Don't worry about setting up a stack that can grow and shrink at\n  this point in time, focus on getting a basic implementation work first.\n\n- The binary from the GRUB module has to be copied to the page frames used for\n  the programs code.\n\n- A page directory and page tables are needed to map the page frames described\n  above into memory. At least two page tables are needed, because the code and\n  data should be mapped in at `0x00000000` and increasing, and the stack should\n  start just below the kernel, at `0xBFFFFFFB`, growing towards lower\n  addresses. The U/S flag has to be set to allow PL3 access.\n\nIt might be convenient to store this information in a `struct` representing a\nprocess. This process `struct` can be dynamically allocated with the\nkernel's `malloc` function.\n\n## Entering User Mode\n\nThe only way to execute code with a lower privilege level than the current\nprivilege level (CPL) is to execute an `iret` or `lret` instruction - interrupt\nreturn or long return, respectively.\n\nTo enter user mode we set up the stack as if the processor had raised an\ninter-privilege level interrupt. The stack should look like the following:\n\n~~~\n    [esp + 16]  ss      ; the stack segment selector we want for user mode\n    [esp + 12]  esp     ; the user mode stack pointer\n    [esp +  8]  eflags  ; the control flags we want to use in user mode\n    [esp +  4]  cs      ; the code segment selector\n    [esp +  0]  eip     ; the instruction pointer of user mode code to execute\n~~~\n\nSee the Intel manual [@intel3a], section 6.2.1, figure 6-4 for more\ninformation.\n\nThe instruction `iret` will then read these values from the stack and fill in\nthe corresponding registers. Before we execute `iret` we need to change to the\npage directory we setup for the user mode process. It is important to remember\nthat to continue executing kernel code after we've switched PDT, the kernel\nneeds to be mapped in. One way to accomplish this is to have a separate PDT for\nthe kernel, which maps all data at `0xC0000000` and above, and merge it with\nthe user PDT (which only maps below `0xC0000000`) when performing the switch.\nRemember that physical address of the PDT has to be used when setting the\nregister `cr3`.\n\nThe register `eflags` contains a set of different flags, specified in\nsection 2.3 of the Intel manual [@intel3a]. Most important for us is the\ninterrupt enable (IF) flag. The assembly code instruction `sti` can't be used in\nprivilege level 3 for enabling interrupts. If interrupts are disabled when\nentering user mode, then interrupts can't enabled once user mode is entered.\nSetting the IF flag in the `eflags` entry on the stack will enable interrupts\nin user mode, since the assembly code instruction `iret` will set the register\n`eflags` to the corresponding value on the stack.\n\nFor now, we should have interrupts disabled, as it requires a little more\nwork to get inter-privilege level interrupts to work properly (see the\nsection [\"System calls\"](#system-calls)).\n\nThe value `eip` on the stack should point to the entry point for the user code\n- `0x00000000` in our case. The value `esp` on the stack should be where the\nstack starts - `0xBFFFFFFB` (`0xC0000000 - 4`).\n\nThe values `cs` and `ss` on the stack should be the segment selectors for the\nuser code and user data segments, respectively. As we saw in the [segmentation\nchapter](#loading-the-gdt), the lowest two bits of a segment\nselector is the RPL - the Requested Privilege Level. When using `iret` to enter\nPL3, the RPL of `cs` and `ss` should be `0x3`. The following code shows an\nexample:\n\n~~~ {.nasm}\n    USER_MODE_CODE_SEGMENT_SELECTOR equ 0x18\n    USER_MODE_DATA_SEGMENT_SELECTOR equ 0x20\n    mov cs, USER_MODE_CODE_SEGMENT_SELECTOR | 0x3\n    mov ss, USER_MODE_DATA_SEGMENT_SELECTOR | 0x3\n~~~\n\nThe register `ds`, and the other data segment registers, should be set to the\nsame segment selector as `ss`. They can be set the ordinary way, with the `mov`\nassembly code instruction.\n\nWe are now ready to execute `iret`. If everything has been set up right, we\nshould now have a kernel that can enter user mode.\n\n## Using C for User Mode Programs\n\nWhen C is used as the programming language for user mode programs, it is\nimportant to think about the structure of the file that will be the result of\nthe compilation.\n\nThe reason we can use ELF [@wiki:elf] as the file format for for the kernel\nexecutable is because GRUB knows how to parse and interpret the ELF file format.\nIf we implemented an ELF parser, we could compile the user mode programs into ELF\nbinaries as well. We leave this as an exercise for the reader.\n\nOne thing we can do to make it easier to develop user mode programs is to allow\nthe programs to be written in C, but compile them to flat binaries instead of\nELF binaries. In C the layout of the generated code is more unpredictable and\nthe entry point, `main`, might not be at offset 0 in the binary. One common way\nto work around this is to add a few assembly code lines placed at offset 0 which\ncalls `main`:\n\n~~~ {.nasm}\n    extern main\n\n    section .text\n        ; push argv\n        ; push argc\n        call main\n        ; main has returned, eax is return value\n        jmp  $    ; loop forever\n~~~\n\nIf this code is saved in a file called `start.s`, then the following code show\nan example of a linker script that places these instructions first in\nexecutable (remember that `start.s` gets compiled to `start.o`):\n\n~~~\n    OUTPUT_FORMAT(\"binary\")    /* output flat binary */\n\n    SECTIONS\n    {\n        . = 0;                 /* relocate to address 0 */\n\n        .text ALIGN(4):\n        {\n            start.o(.text)     /* include the .text section of start.o */\n            *(.text)           /* include all other .text sections */\n        }\n\n        .data ALIGN(4):\n        {\n            *(.data)\n        }\n\n        .rodata ALIGN(4):\n        {\n            *(.rodata*)\n        }\n    }\n~~~\n\n_Note_: `*(.text)` will not include the `.text` section of `start.o` again.\n\nWith this script we can write programs in C or assembler (or any other language\nthat compiles to object files linkable with `ld`), and it is easy to load and\nmap for the kernel (`.rodata` will be mapped in as writeable, though).\n\nWhen we compile user programs we want the following GCC flags:\n\n~~~\n    -m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector -nostartfiles\n    -nodefaultlibs\n~~~\n\nFor linking, the followings flags should be used:\n\n~~~\n    -T link.ld -melf_i386  # emulate 32 bits ELF, the binary output is specified\n                           # in the linker script\n~~~\n\nThe option `-T` instructs the linker to use the linker script `link.ld`.\n\n### A C Library\n\nIt might now be interesting to start thinking about writing a small \"standard\nlibrary\" for your programs. Some of the functionality requires [system\ncalls](#system-calls) to work, but some, such as the functions in `string.h`,\ndoes not.\n\n## Further Reading\n\n- Gustavo Duarte has an article on privilege levels:\n  <http://duartes.org/gustavo/blog/post/cpu-rings-privilege-and-protection>\n"
        },
        {
          "name": "virtual_memory.md",
          "type": "blob",
          "size": 1.962890625,
          "content": "# A Short Introduction to Virtual Memory\n\n_Virtual memory_ is an abstraction of physical memory. The purpose of virtual\nmemory is generally to simplify application development and to let processes\naddress more memory than what is actually physically present in the machine. We also don't\nwant applications messing with the kernel or other applications' memory due to\nsecurity.\n\nIn the x86 architecture, virtual memory can be accomplished in two ways:\n_segmentation_ and _paging_. Paging is by far the most common and versatile\ntechnique, and we'll implement it the next chapter. Some use of segmentation\nis still necessary to allow for code to execute under different privilege\nlevels.\n\nManaging memory is a big part of what an operating system does.\n[Paging](#paging) and [page frame allocation](#page-frame-allocation) deals\nwith that.\n\nSegmentation and paging is described in the [@intel3a], chapter 3\nand 4.\n\n## Virtual Memory Through Segmentation?\n\nYou could skip paging entirely and just use segmentation for virtual memory.\nEach user mode process would get its own segment, with base address and limit\nproperly set up. This way no process can see the memory of another process. A\nproblem with this is that the physical memory for a process needs to be\ncontiguous (or at least it is very convenient if it is). Either we need to know\nin advance how much memory the program will require (unlikely), or we can move\nthe memory segments to places where they can grow when the limit is reached\n(expensive, causes fragmentation - can result in \"out of memory\" even though\nenough memory is available). Paging solves both these problems.\n\nIt is interesting to note that in x86\\_64 (the 64-bit version of the x86\narchitecture), segmentation is almost completely removed.\n\n## Further Reading\n\n- LWN.net has an article on virtual memory: <http://lwn.net/Articles/253361/>\n- Gustavo Duarte has also written an article about virtual memory:\n  <http://duartes.org/gustavo/blog/post/memory-translation-and-segmentation>\n"
        }
      ]
    }
  ]
}