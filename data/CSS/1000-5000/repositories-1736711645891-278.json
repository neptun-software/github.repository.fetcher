{
  "metadata": {
    "timestamp": 1736711645891,
    "page": 278,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "progit/progit2-zh",
      "stars": 1473,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".dependabot",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.15625,
          "content": "output\n.DS_Store\n\n# build artifacts\nGemfile.lock\nprogit.html\nprogit.pdf\nprogit.pdfmarks\nprogit.epub\nprogit.fb2.zip\nprogit-kf8.epub\nprogit.mobi\ncontributors.txt\n"
        },
        {
          "name": ".mailmap",
          "type": "blob",
          "size": 0.06640625,
          "content": "Jean-Noël Avila <jn.avila@free.fr>\nScott Chacon <schacon@gmail.com>"
        },
        {
          "name": ".tgitconfig",
          "type": "blob",
          "size": 0.2373046875,
          "content": "[bugtraq]\n\turl = https://github.com/progit/progit2/issues/%BUGID%\n\tlogregex = \"(?:[Cc]lose[sd]?|[Ff]ix(?:e[sd])?|[Rr]esolve[sd]?):?\\\\s+(?:[Ii]ssues?\\\\s+#?|#)\\\\d+(?:(?:,|\\\\s+and)\\\\s+(?:[Ii]ssues?\\\\s+#?|#)\\\\d+)*\\n(\\\\d+)\"\n\n[tgit]\n\ticon = Pro.ico\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.583984375,
          "content": "language: ruby\nsudo: false\ngit:\n  depth: false\ncache: bundler\nbefore_install:\n - wget https://raw.githubusercontent.com/progit/progit2-pub/master/bootstrap.sh\n - sh bootstrap.sh\nscript: bundle exec rake book:build\nafter_success: bundle exec rake book:tag\ndeploy:\n  provider: releases\n  file_glob: true\n  file:\n  - progit*.epub\n  - progit*.mobi\n  - progit*.pdf\n  skip_cleanup: true\n  on:\n    tags: true\n  api-key: $GITHUB_API_TOKEN\nbranches:\n  only:\n  - master\n  - /^2\\.1(\\.\\d+)+$/\n\naddons:\n  apt:\n    packages:\n      - epubcheck\nnotifications:\n  email:\n    on_success: never\n    on_failure: always\n"
        },
        {
          "name": "A-git-in-other-environments.asc",
          "type": "blob",
          "size": 1.23828125,
          "content": "[[A-git-in-other-environments]]\n[appendix]\n== 在其它环境中使用 Git\n\n如果你读完了本书，那就已经掌握了很多在命令行中使用 Git 的知识了。\n你可以用它来处理本地文件，通过网络连接到他人的仓库，以及高效地与他人协同工作。\n不过故事到这儿还没结束。Git 通常还会作为一个组件在更大的生态系统中使用，\n而终端并不总是最佳的使用方式。现在我们来看看 Git 在其它环境中的使用，\n以及其它应用（包括你的应用）是如何与 Git 协同使用的。\n\ninclude::book/A-git-in-other-environments/sections/guis.asc[]\n\ninclude::book/A-git-in-other-environments/sections/visualstudio.asc[]\n\ninclude::book/A-git-in-other-environments/sections/visualstudiocode.asc[]\n\ninclude::book/A-git-in-other-environments/sections/jetbrainsides.asc[]\n\ninclude::book/A-git-in-other-environments/sections/sublimetext.asc[]\n\ninclude::book/A-git-in-other-environments/sections/bash.asc[]\n\ninclude::book/A-git-in-other-environments/sections/zsh.asc[]\n\ninclude::book/A-git-in-other-environments/sections/powershell.asc[]\n\n=== 总结\n\n现在你已经学会如何在日常使用的工具中驾驭强大的 Git，以及如何在自己的程序中访问 Git 仓库了。\n"
        },
        {
          "name": "B-embedding-git-in-your-applications.asc",
          "type": "blob",
          "size": 0.8115234375,
          "content": "[[B-embedding-git-in-your-applications]]\n[appendix]\n== 在你的应用中嵌入 Git\n\n如果你的应用程序的目标用户是开发者，那么在其中集成源码控制功能会让他们从中受益。\n甚至对于文档编辑器等并非面向程序员的应用，也可以从版本控制系统中受益，Git 的工作模式在多种场景下表现得都非常出色。\n\n如果你想将 Git 整合进你的应用程序，那么通常有两种可行的选择：启动 shell 来调用 Git 的命令行程序，或者将 Git 库嵌入到你的应用中。\n\ninclude::book/B-embedding-git/sections/command-line.asc[]\n\ninclude::book/B-embedding-git/sections/libgit2.asc[]\n\ninclude::book/B-embedding-git/sections/jgit.asc[]\n\ninclude::book/B-embedding-git/sections/go-git.asc[]\n\ninclude::book/B-embedding-git/sections/dulwich.asc[]\n\n"
        },
        {
          "name": "C-git-commands.asc",
          "type": "blob",
          "size": 33.130859375,
          "content": "[[C-git-commands]]\n[appendix]\n== Git 命令\n\n在这一整本书里我们介绍了大量的 Git 命令，并尽可能通过讲故事的方式来介绍它们，慢慢介绍了越来越多的命令。\n但是这导致这些命令的示例用法都散落在全书的各处。\n\n在此附录中，我们会将本书中所提到过的命令都过一遍，并根据其用途进行大致分类。\n我们会大致地讨论每个命令的作用，指出其在本书中哪些章节使用过。\n\n[TIP]\n====\n较长的选项可以。\n例如，你可以输入 `git commit --a`，它的行为与 `git commit --amend` 相同。\n这种方式只有在 `--` 后的字母对于该选项唯一时才可行。\n请在编写脚本时使用完整的选项。\n====\n\n=== 设置与配置\n\n有两个十分常用的命令：`config` 和 `help`。从第一次调用 Git 到日常微调及阅读参考，它们一直陪伴着你。\n\n==== git config\n\nGit 做的很多工作都有一种默认方式。\n对于绝大多数工作而言，你可以改变 Git 的默认方式，或者根据你的偏好来设置。\n这些设置涵盖了所有的事，从告诉 Git 你的名字，到指定偏好的终端颜色，以及你使用的编辑器。\n此命令会从几个特定的配置文件中读取和写入配置值，以便你可以从全局或者针对特定的仓库来进行设置。\n\n本书几乎所有的章节都用到了 `git config` 命令。\n\n在 <<ch01-getting-started#_first_time>> 一节中，在开始使用 Git 之前，我们用它来指定我们的名字，邮箱地址和编辑器偏好。\n\n在 <<ch02-git-basics-chapter#_git_aliases>> 一节中我们展示了如何创建可以展开为长选项序列的短命令，以便你不用每次都输入它们。\n\n在 <<ch03-git-branching#_rebasing>> 一节中，执行 `git pull` 命令时，使用此命令来将 `--rebase` 作为默认选项。\n\n在 <<ch07-git-tools#_credential_caching>> 一节中，我们使用它来为你的 HTTP 密码设置一个默认的存储区域。\n\n在 <<ch08-customizing-git#_keyword_expansion>> 一节中我们展示了如何设置在 Git 的内容添加和减少时使用的 smudge 过滤器 和 clean 过滤器。\n\n最后，基本上 <<ch08-customizing-git#_git_config>> 整个章节都是针对此命令的。\n\n[[ch_core_editor]]\n==== git config core.editor 命令\n\n就像 <<ch01-getting-started#_first_time>> 里的设置指示，很多编辑器可以如下设置：\n\n.详细的 `core.editor` 设置命令列表\n[cols=\"1,2\",options=\"header\"]\n|==============================\n|编辑器 | 设置命令\n|Atom |`git config --global core.editor \"atom --wait\"`\n|BBEdit (macOS, with command line tools) |`git config --global core.editor \"bbedit -w\"`\n|Emacs |`git config --global core.editor emacs`\n|Gedit (Linux) |`git config --global core.editor \"gedit --wait --new-window\"`\n|Gvim (Windows 64-bit) |`git config --global core.editor \"'C:\\Program Files\\Vim\\vim72\\gvim.exe' --nofork '%*'\"` (Also see note below)\n|Helix |`git config --global core.editor \"hx\"`\n|Kate (Linux) |`git config --global core.editor \"kate --block\"`\n|nano |`git config --global core.editor \"nano -w\"`\n|Notepad (Windows 64-bit) |`git config core.editor notepad`\n|Notepad++ (Windows 64-bit) |`git config --global core.editor \"'C:\\Program Files\\Notepad\\++\\notepad++.exe' -multiInst -notabbar -nosession -noPlugin\"` (Also see note below)\n|Scratch (Linux)|`git config --global core.editor \"scratch-text-editor\"`\n|Sublime Text (macOS) |`git config --global core.editor \"/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl --new-window --wait\"`\n|Sublime Text (Windows 64-bit) |`git config --global core.editor \"'C:\\Program Files\\Sublime Text 3\\sublime_text.exe' -w\"` (Also see note below)\n|TextEdit (macOS)|`git config --global core.editor \"open --wait-apps --new -e\"`\n|Textmate |`git config --global core.editor \"mate -w\"`\n|Textpad (Windows 64-bit) |`git config --global core.editor \"'C:\\Program Files\\TextPad 5\\TextPad.exe' -m\"` (Also see note below)\n|UltraEdit (Windows 64-bit) | `git config --global core.editor Uedit32`\n|Vim |`git config --global core.editor \"vim --nofork\"`\n|Visual Studio Code |`git config --global core.editor \"code --wait\"`\n|VSCodium (Free/Libre Open Source Software Binaries of VSCode) | `git config --global core.editor \"codium --wait\"`\n|WordPad |`git config --global core.editor \"'C:\\Program Files\\Windows NT\\Accessories\\wordpad.exe'\"`\n|Xi | `git config --global core.editor \"xi --wait\"`\n|==============================\n\n[NOTE]\n====\n如果你在 64 位 Windows 系统上安装了 32 位的编辑器，那么它会被安装在 `C:\\Program Files (x86)\\` 而非上表中所写的 `C:\\Program Files\\` 中。\n====\n\n==== git help\n\n`git help` 命令用来显示任何命令的 Git 自带文档。\n但是我们仅会在此附录中提到大部分最常用的命令，对于每一个命令的完整的可选项及标志列表，你可以随时运行 `git help <command>` 命令来了解。\n\n我们在 <<ch01-getting-started#_git_help>> 一节中介绍了 `git help` 命令，同时在 <<ch04-git-on-the-server#_setting_up_server>> 一节中给你展示了如何使用它来查找更多关于 `git shell` 的信息。\n\n=== 获取与创建项目\n\n有几种方式获取一个 Git 仓库。\n一种是从网络上或者其他地方拷贝一个现有的仓库，另一种就是在一个目录中创建一个新的仓库。\n\n==== git init\n\n你只需要简单地运行 `git init` 就可以将一个目录转变成一个 Git 仓库，这样你就可以开始对它进行版本管理了。\n\n我们一开始在 <<ch02-git-basics-chapter#_getting_a_repo>> 一节中介绍了如何创建一个新的仓库来开始工作。\n\n在 <<ch03-git-branching#_remote_branches>> 一节中我们简单的讨论了如何改变默认分支。\n\n在 <<ch04-git-on-the-server#_bare_repo>> 一节中我们使用此命令来为一个服务器创建一个空的祼仓库。\n\n最后，我们在 <<ch10-git-internals#_plumbing_porcelain>> 一节中介绍了此命令背后工作的原理的一些细节。\n\n==== git clone\n\n`git clone` 实际上是一个封装了其他几个命令的命令。\n它创建了一个新目录，切换到新的目录，然后 `git init` 来初始化一个空的 Git 仓库， 然后为你指定的 URL 添加一个（默认名称为 `origin` 的）远程仓库（`git remote add`），再针对远程仓库执行 `git fetch`，最后通过 `git checkout` 将远程仓库的最新提交检出到本地的工作目录。\n\n`git clone` 命令在本书中多次用到，这里只列举几个有意思的地方。\n\n在 <<ch02-git-basics-chapter#_git_cloning>> 一节中我们通过几个示例详细介绍了此命令。\n\n在 <<ch04-git-on-the-server#_getting_git_on_a_server>> 一节中，我们使用了 `--bare` 选项来创建一个没有任何工作目录的 Git 仓库副本。\n\n在 <<ch07-git-tools#_bundling>> 一节中我们使用它来解包一个打包好的 Git 仓库。\n\n最后，在 <<ch07-git-tools#_cloning_submodules>> 一节中我们学习了使用 `--recursive` 选项来让克隆一个带有子模块的仓库变得简单。\n\n虽然在本书的其他地方都有用到此命令，但是上面这些用法是特例，或者使用方式有点特别。\n\n=== 快照基础\n\n对于基本的暂存内容及提交到你的历史记录中的工作流，只有少数基本的命令。\n\n==== git add\n\n`git add` 命令将内容从工作目录添加到暂存区（或称为索引（index）区），以备下次提交。\n当 `git commit` 命令执行时，默认情况下它只会检查暂存区域，因此 `git add` 是用来确定下一次提交时快照的样子的。\n\n这个命令对于 Git 来说特别重要，所以在本书中被无数次地提及和使用。\n我们将快速地过一遍一些可以看到的独特的用法。\n\n我们在 <<ch02-git-basics-chapter#_tracking_files>> 一节中介绍并详细解释了 `git add` 命令。\n\n然后，我们在 <<ch03-git-branching#_basic_merge_conflicts>> 一节中提到了如何使用它来解决合并冲突。\n\n接下来，我们在 <<ch07-git-tools#_interactive_staging>> 一章中使用它来交互式的暂存一个已修改文件的特定部分。\n\n最后，在 <<ch10-git-internals#_tree_objects>> 一节中我们在底层模拟了它的用法，以便你了解幕后发生了什么。\n\n==== git status\n\n`git status` 命令会显示工作区及暂存区域中不同状态的文件。\n其中包含了已修改但未暂存，或已经暂存但没有提交的文件。\n在一般的显示形式中，它会给你一些如何在这些暂存区之间移动文件的提示。\n\n首先，我们在 <<ch02-git-basics-chapter#_checking_status>> 一节中介绍了 `status` 的基本及简单的形式。\n虽然我们在全书中都有用到它，但是绝大部分的你能用 `git status` 做的事情都在这一章讲到了。\n\n==== git diff\n\n当需要查看任意两棵树的差异时，可以使用 `git diff` 命令。\n此命令可以查看你工作环境与你的暂存区的差异（`git diff` 默认的做法），你暂存区域与你最后提交之间的差异（`git diff --staged`），或者比较两个提交记录的差异（`git diff master branchB`）。\n\n首先，我们在 <<ch02-git-basics-chapter#_git_diff_staged>> 一章中研究了 `git diff` 的基本用法，在此节中我们展示了如何查看哪些变化已经暂存了，哪些没有。\n\n在 <<ch05-distributed-git#_commit_guidelines>> 一节中,我们在提交前使用 `--check` 选项来检查可能存在的空白字符问题。\n\n在 <<ch05-distributed-git#_what_is_introduced>> 一节中,了解了使用 `git diff A...B` 语法来更有效地比较不同分支之间的差异。\n\n在 <<ch07-git-tools#_advanced_merging>> 一节中我们使用 `-b` 选项来过滤掉空白字符的差异，及通过 `--theirs`、`--ours` 和 `--base` 选项来比较不同暂存区冲突文件的差异。\n\n最后，在 <<ch07-git-tools#_starting_submodules>> 一节中,我们使用此命令合 `--submodule` 选项来有效地比较子模块的变化。\n\n==== git difftool\n\n当你不想使用内置的 `git diff` 命令时。`git difftool` 可以用来简单地启动一个外部工具来为你展示两棵树之间的差异。\n\n我们只在 <<ch02-git-basics-chapter#_git_diff_staged>> 一节中简单的提到了此命令。\n\n==== git commit\n\n`git commit` 命令将所有通过 `git add` 暂存的文件内容在数据库中创建一个持久的快照，然后将当前分支上的分支指针移到其之上。\n\n首先，我们在 <<ch02-git-basics-chapter#_committing_changes>> 一节中涉及了此命令的基本用法。\n我们演示了如何在日常的工作流程中通过使用 `-a` 标志来跳过 `git add` 这一步，及如何使用 `-m` 标志通过命令行而不启动一个编辑器来传递提交信息。\n\n在 <<ch02-git-basics-chapter#_undoing>> 一节中我们介绍了使用 `--amend` 选项来重做最后的提交。\n\n在 <<ch03-git-branching#_git_branches_overview>>，我们探讨了 `git commit` 的更多细节，及工作原理。\n\n在 <<ch07-git-tools#_signing_commits>> 一节中我们探讨了如何使用 `-S` 标志来为提交签名加密。\n\n最后，在 <<ch10-git-internals#_git_commit_objects>> 一节中，我们了解了 `git commit` 在背后做了什么，及它是如何实现的。\n\n==== git reset\n\n`git reset` 命令主要用来根据你传递给动作的参数来执行撤销操作。\n它可以移动 `HEAD` 指针并且可选的改变 `index` 或者暂存区，如果你使用 `--hard` 参数的话你甚至可以改变工作区。\n如果错误地为这个命令附加后面的参数，你可能会丢失你的工作，所以在使用前你要确定你已经完全理解了它。\n\n首先，我们在 <<ch02-git-basics-chapter#_unstaging>> 一节中介绍了 `git reset` 简单高效的用法，用来对执行过 `git add` 命令的文件取消暂存。\n\n在 <<ch07-git-tools#_git_reset>> 一节中我们详细介绍了此命令，几乎整节都在解释此命令。\n\n在 <<ch07-git-tools#_abort_merge>> 一节中，我们使用 `git reset --hard` 来取消一个合并，同时我们也使用了 `git merge --abort` 命令，它是 `git reset` 的一个简单的封装。\n\n==== git rm\n\n`git rm` 是 Git 用来从工作区，或者暂存区移除文件的命令。\n在为下一次提交暂存一个移除操作上，它与 `git add` 有一点类似。\n\n我们在 <<ch02-git-basics-chapter#_removing_files>> 一节中提到了 `git rm` 的一些细节，包括递归地移除文件，和使用 `--cached` 选项来只移除暂存区域的文件但是保留工作区的文件。\n\n在本书的 <<ch10-git-internals#_removing_objects>> 一节中，介绍了 `git rm` 仅有的几种不同用法，如在执行 `git filter-branch` 中使用和解释了 `--ignore-unmatch` 选项。\n这对脚本来说很有用。\n\n==== git mv\n\n`git mv` 命令是一个便利命令，用于移到一个文件并且在新文件上执行`git add`命令及在老文件上执行`git rm`命令。\n\n我们只是在 <<ch02-git-basics-chapter#_git_mv>> 一节中简单地提到了此命令。\n\n==== git clean\n\n`git clean` 是一个用来从工作区中移除不想要的文件的命令。\n可以是编译的临时文件或者合并冲突的文件。\n\n在 <<ch07-git-tools#_git_clean>> 一节中我们介绍了你可能会使用 `clean` 命令的大量选项及场景。\n\n=== 分支与合并\n\nGit 有几个实现大部的分支及合并功能的实用命令。\n\n==== git branch\n\n`git branch` 命令实际上是某种程度上的分支管理工具。\n它可以列出你所有的分支、创建新分支、删除分支及重命名分支。\n\n<<ch03-git-branching#ch03-git-branching>> 一节主要是为 `branch` 命令来设计的，它贯穿了整个章节。\n首先，我们在 <<ch03-git-branching#_create_new_branch>> 一节中介绍了它，然后我们在 <<ch03-git-branching#_branch_management>> 一节中介绍了它的其它大部分特性（列举及删除）。\n\n在 <<ch03-git-branching#_tracking_branches>> 一节中，我们使用 `git branch -u` 选项来设置一个跟踪分支。\n\n最后，我们在 <<ch10-git-internals#_git_refs>> 一节中讲到了它在背后做一什么。\n\n==== git checkout\n\n`git checkout` 命令用来切换分支，或者检出内容到工作目录。\n\n我们是在 <<ch03-git-branching#_switching_branches>> 一节中第一次认识了命令及 `git branch` 命令。\n\n在 <<ch03-git-branching#_tracking_branches>> 一节中我们了解了如何使用 `--track` 标志来开始跟踪分支。\n\n在 <<ch07-git-tools#_checking_out_conflicts>> 一节中，我们用此命令和 `--conflict=diff3` 来重新介绍文件冲突。\n\n在 <<ch07-git-tools#_git_reset>> 一节中，我们进一步了解了其细节及与 `git reset` 的关系。\n\n最后，我们在 <<ch10-git-internals#ref_the_ref>> 一节中介绍了此命令的一些实现细节。\n\n==== git merge\n\n`git merge` 工具用来合并一个或者多个分支到你已经检出的分支中。\n然后它将当前分支指针移动到合并结果上。\n\n我们首先在 <<ch03-git-branching#_basic_branching>> 一节中介绍了 `git merge` 命令。\n虽然它在本书的各种地方都有用到，但是 `merge` 命令只有几个变种，一般只是 `git merge <branch>` 带上一个你想合并进来的一个分支名称。\n\n我们在 <<ch05-distributed-git#_public_project>> 的后面介绍了如何做一个 `squashed merge` （指 Git 合并时将其当作一个新的提交而不是记录你合并时的分支的历史记录。）\n\n在 <<ch07-git-tools#_advanced_merging>> 一节中，我们介绍了合并的过程及命令，包含 `-Xignore-space-change` 命令及 `--abort` 选项来中止一个有问题的提交。\n\n在 <<ch07-git-tools#_signing_commits>> 一节中我们学习了如何在合并前验证签名，如果你项目正在使用 GPG 签名的话。\n\n最后，我们在 <<ch07-git-tools#_subtree_merge>> 一节中学习了子树合并。\n\n==== git mergetool\n\n当你在 Git 的合并中遇到问题时，可以使用 `git mergetool` 来启动一个外部的合并帮助工具。\n\n我们在 <<ch03-git-branching#_basic_merge_conflicts>> 中快速介绍了一下它，然后在 <<ch08-customizing-git#_external_merge_tools>> 一节中介绍了如何实现你自己的外部合并工具的细节。\n\n==== git log\n\n`git log` 命令用来展示一个项目的可达历史记录，从最近的提交快照起。\n默认情况下，它只显示你当前所在分支的历史记录，但是可以显示不同的甚至多个头记录或分支以供遍历。\n此命令通常也用来在提交记录级别显示两个或多个分支之间的差异。\n\n在本书的每一章几乎都有用到此命令来描述一个项目的历史。\n\n在 <<ch02-git-basics-chapter#_viewing_history>> 一节中我们介绍了此命令，并深入做了研究。\n研究了包括 `-p` 和 `--stat` 选项来了解每一个提交引入的变更，及使用`--pretty` 和 `--online` 选项来查看简洁的历史记录。\n\n在 <<ch03-git-branching#_create_new_branch>> 一节中我们使用它加 `--decorate` 选项来简单的可视化我们分支的指针所在，同时我们使用 `--graph` 选项来查看分叉的历史记录是怎么样的。\n\n在 <<ch05-distributed-git#_private_team>> 和 <<ch07-git-tools#_commit_ranges>> 章节中，我们介绍了在使用 `git log` 命令时用 `branchA..branchB` 的语法来查看一个分支相对于另一个分支, 哪一些提交是唯一的。\n在 <<ch07-git-tools#_commit_ranges>> 一节中我们作了更多介绍。\n\n在 <_merge_log>> 和 <<ch07-git-tools#_triple_dot>> 章节中，我们介绍了 `branchA...branchB` 格式和 `--left-right` 语法来查看哪些仅其中一个分支。\n在 <<ch07-git-tools#_merge_log>> 一节中我们还研究了如何使用 `--merge` 选项来帮助合并冲突调试，同样也使用 `--cc` 选项来查看在你历史记录中的合并提交的冲突。\n\n在 <<ch07-git-tools#_git_reflog>> 一节中我们使用此工具和 `-g` 选项 而不是遍历分支来查看 Git 的 `reflog`。\n\n在 <<ch07-git-tools#_searching>> 一节中我们研究了`-S` 及 `-L` 选项来进行来在代码的历史变更中进行相当优雅地搜索，如一个函数的历史。\n\n在 <<ch07-git-tools#_signing_commits>> 一节中，我们了解了如何使用 `--show-signature` 来为每一个提交的 `git log` 输出中，添加一个判断是否已经合法的签名的一个验证。\n\n==== git stash\n\n`git stash` 命令用来临时地保存一些还没有提交的工作，以便在分支上不需要提交未完成工作就可以清理工作目录。\n\n<<ch07-git-tools#_git_stashing>> 一整个章节基本就是在讲这个命令。\n\n==== git tag\n\n`git tag` 命令用来为代码历史记录中的某一个点指定一个永久的书签。\n一般来说它用于发布相关事项。\n\n我们在 <<ch02-git-basics-chapter#_git_tagging>> 一节中介绍了此命令及相关细节，并在 <<ch05-distributed-git#_tagging_releases>> 一节实践了此命令。\n\n我也在 <<ch07-git-tools#_signing>> 一节中介绍了如何使用 `-s` 标志创建一个 GPG 签名的标签，然后使用 `-v` 选项来验证。\n\n=== 项目分享与更新\n\n在 Git 中没有多少访问网络的命令，几乎所以的命令都是在操作本地的数据库。\n当你想要分享你的工作，或者从其他地方拉取变更时，这有几个处理远程仓库的命令。\n\n==== git fetch\n\n`git fetch` 命令与一个远程的仓库交互，并且将远程仓库中有但是在当前仓库的没有的所有信息拉取下来然后存储在你本地数据库中。\n\n我们开始在 <<ch02-git-basics-chapter#_fetching_and_pulling>> 一节中介绍了此命令，然后我们在 <<ch03-git-branching#_remote_branches>> 中看到了几个使用示例。\n\n我们在 <<ch05-distributed-git#_contributing_project>> 一节中有几个示例中也都有使用此命令。\n\n在 <<ch06-github#_pr_refs>> 我们用它来抓取一个在默认空间之外指定的引用，在 <<ch07-git-tools#_bundling>> 中，我们了解了怎么从一个包中获取内容。\n\n在 <<ch10-git-internals#_refspec>> 章节中我们设置了高度自定义的 `refspec` 以便 `git fetch` 可以做一些跟默认不同的事情。\n\n==== git pull\n\n`git pull` 命令基本上就是 `git fetch` 和 `git merge` 命令的组合体，Git 从你指定的远程仓库中抓取内容，然后马上尝试将其合并进你所在的分支中。\n\n我们在 <<ch02-git-basics-chapter#_fetching_and_pulling>> 一节中快速介绍了此命令，然后在 <<ch02-git-basics-chapter#_inspecting_remote>> 一节中了解了如果你运行此命令的话，什么将会合并。\n\n我们也在 <<ch03-git-branching#_rebase_rebase>> 一节中了解了如何使用此命令来来处理变基的难题。\n\n在 <<ch07-git-tools#_checking_out_conflicts>> 一节中我们展示了使用此命令如何通过一个 URL 来一次性的拉取变更。\n\n最后，我们在 <<ch07-git-tools#_signing_commits>> 一节中我们快速的介绍了你可以使用 `--verify-signatures` 选项来验证你正在拉取下来的经过 GPG 签名的提交。\n\n==== git push\n\n`git push` 命令用来与另一个仓库通信，计算你本地数据库与远程仓库的差异，然后将差异推送到另一个仓库中。\n它需要有另一个仓库的写权限，因此这通常是需要验证的。\n\n我们开始在 <<ch02-git-basics-chapter#_pushing_remotes>> 一节中介绍了 `git push` 命令。\n在这一节中主要介绍了推送一个分支到远程仓库的基本用法。\n在 <<ch03-git-branching#_pushing_branches>> 一节中，我们深入了解了如何推送指定分支，在 <<ch03-git-branching#_tracking_branches>> 一节中我们了解了如何设置一个默认的推送的跟踪分支。\n在 <<ch03-git-branching#_delete_branches>> 一节中我们使用 `--delete` 标志和 `git push` 命令来在删除一个在服务器上的分支。\n\n在 <<ch05-distributed-git#_contributing_project>> 一整节中，我们看到了几个使用 `git push` 在多个远程仓库分享分支中的工作的示例。\n\n在 <<ch02-git-basics-chapter#_sharing_tags>> 一节中，我们知道了如何使用此命令加 `--tags` 选项来分享你打的标签。\n\n在 <<ch07-git-tools#_publishing_submodules>> 一节中，我们使用 `--recurse-submodules` 选项来检查是否我们所有的子模块的工作都已经在推送子项目之前已经推送出去了，当使用子模块时这真的很有帮助。\n\n在 <<ch08-customizing-git#_other_client_hooks>> 中我们简单的提到了 `pre-push` 挂钩（hook），它是一个可以用来设置成在一个推送完成之前运行的脚本，以检查推送是否被允许。\n\n最后，在 <<ch10-git-internals#_pushing_refspecs>> 一节中，我们知道了使用完整的 refspec 来推送，而不是通常使用的简写形式。\n这对我们精确的指定要分享出去的工作很有帮助。\n\n==== git remote\n\n`git remote` 命令是一个是你远程仓库记录的管理工具。\n它允许你将一个长的 URL 保存成一个简写的句柄，例如 `origin` ，这样你就可以不用每次都输入他们了。\n你可以有多个这样的句柄，`git remote` 可以用来添加，修改，及删除它们。\n\n此命令在 <<ch02-git-basics-chapter#_remote_repos>> 一节中做了详细的介绍，包括列举、添加、移除、重命名功能。\n\n几乎在此书的后续章节中都有使用此命令，但是一般是以 `git remote add <name> <url>` 这样的标准格式。\n\n==== git archive\n\n`git archive` 命令用来创建项目一个指定快照的归档文件。\n\n我们在 <<ch05-distributed-git#_preparing_release>> 一节中，使用 `git archive` 命令来创建一个项目的归档文件用于分享。\n\n==== git submodule\n\n`git submodule` 命令用来管理一个仓库的其他外部仓库。\n它可以被用在库或者其他类型的共享资源上。\n`submodule` 命令有几个子命令, 如（`add`、`update`、`sync` 等等）用来管理这些资源。\n\n只在 <<ch07-git-tools#_git_submodules>> 章节中提到和详细介绍了此命令。\n\n=== 检查与比较\n\n==== git show\n\n`git show` 命令可以以一种简单的人类可读的方式来显示一个 Git 对象。\n你一般使用此命令来显示一个标签或一个提交的信息。\n\n我们在 <<ch02-git-basics-chapter#_annotated_tags>> 一节中使用此命令来显示带注解标签的信息。\n\n然后，我们在 <<ch07-git-tools#_revision_selection>> 一节中，用了很多次来显示不同的版本选择将解析出来的提交。\n\n我们使用 `git show` 做的最有意思的事情是在 <<ch07-git-tools#_manual_remerge>> 一节中用来在合并冲突的多个暂存区域中提取指定文件的内容。\n\n==== git shortlog\n\n`git shortlog` 是一个用来归纳 `git log` 的输出的命令。\n它可以接受很多与 `git log` 相同的选项，但是此命令并不会列出所有的提交，而是展示一个根据作者分组的提交记录的概括性信息\n\n我们在 <<ch05-distributed-git#_the_shortlog>> 一节中展示了如何使用此命令来创建一个漂亮的 changelog 文件。\n\n==== git describe\n\n`git describe` 命令用来接受任何可以解析成一个提交的东西，然后生成一个人类可读的字符串且不可变。\n这是一种获得一个提交的描述的方式，它跟一个提交的 SHA-1 值一样是无歧义，但是更具可读性。\n\n我们在 <<ch05-distributed-git#_build_number>> 及 <<ch05-distributed-git#_preparing_release>> 章节中使用 `git describe` 命令来获得一个字符串来命名我们发布的文件。\n\n=== 调试\n\nGit 有一些命令可以用来帮你调试你代码中的问题。\n包括找出是什么时候，是谁引入的变更。\n\n==== git bisect\n\n`git bisect` 工具是一个非常有用的调试工具，它通过自动进行一个二分查找来找到哪一个特定的提交是导致 bug 或者问题的第一个提交。\n\n仅在 <<ch07-git-tools#_binary_search>> 一节中完整的介绍了此命令。\n\n==== git blame\n\n`git blame` 命令标注任何文件的行，指出文件的每一行的最后的变更的提交及谁是那一个提交的作者。\n当你要找那个人去询问关于这块特殊代码的信息时这会很有用。\n\n只有 <<ch07-git-tools#_file_annotation>> 一节中提到此命令。\n\n==== git grep\n\n`git grep` 命令可以帮助在源代码中，甚至是你项目的老版本中的任意文件中查找任何字符串或者正则表达式。\n\n只有 <<ch07-git-tools#_git_grep>> 的章节中提到此命令。\n\n=== 补丁\n\nGit 中的一些命令是以引入的变更即提交这样的概念为中心的，这样一系列的提交，就是一系列的补丁。\n这些命令以这样的方式来管理你的分支。\n\n==== git cherry-pick\n\n`git cherry-pick` 命令用来获得在单个提交中引入的变更，然后尝试将作为一个新的提交引入到你当前分支上。\n从一个分支单独一个或者两个提交而不是合并整个分支的所有变更是非常有用的。\n\n在 <<ch05-distributed-git#_rebase_cherry_pick>> 一节中描述和演示了 `Cherry picking`\n\n==== git rebase\n\n`git rebase` 命令基本是是一个自动化的 `cherry-pick` 命令。\n它计算出一系列的提交，然后再以它们在其他地方以同样的顺序一个一个的 `cherry-picks` 出它们。\n\n在 <<ch03-git-branching#_rebasing>> 一章中详细提到了此命令，包括与已经公开的分支的变基所涉及的协作问题。\n\n在 <<ch07-git-tools#_replace>> 中我们在一个分离历史记录到两个单独的仓库的示例中实践了此命令，同时使用了 `--onto` 选项。\n\n在 <<ch07-git-tools#ef_rerere>> 一节中，我们研究了在变基时遇到的合并冲突的问题。\n\n在 <<ch07-git-tools#_changing_multiple>> 一节中，我们也结合 `-i` 选项将其用于交互式的脚本模式。\n\n==== git revert\n\n`git revert` 命令本质上就是一个逆向的 `git cherry-pick` 操作。\n它将你提交中的变更的以完全相反的方式的应用到一个新创建的提交中，本质上就是撤销或者倒转。\n\n我们在 <<ch07-git-tools#_reverse_commit>> 一节中使用此命令来撤销一个合并提交。\n\n=== 邮件\n\n很多 Git 项目，包括 Git 本身，基本是通过邮件列表来维护的。\n从方便地生成邮件补丁到从一个邮箱中应用这些补丁,Git 都有工具来让这些操作变得简单。\n\n==== git apply\n\n`git apply` 命令应用一个通过 `git diff` 或者甚至使用 GNU diff 命令创建的补丁。\n它跟补丁命令做了差不多的工作，但还是有一些小小的差别。\n\n我们在 <<ch05-distributed-git#_patches_from_email>> 一节中演示了它的使用及什么环境下你可能会用到它。\n\n==== git am\n\n`git am` 命令用来应用来自邮箱的补丁。特别是那些被 mbox 格式化过的。\n这对于通过邮件接受补丁并将他们轻松地应用到你的项目中很有用。\n\n我们在 <<ch05-distributed-git#_git_am>> 命令中提到了它的用法及工作流，包括使用 `--resolved`、`-i` 及 `-3` 选项。\n\n我们在 <<ch08-customizing-git#_email_hooks>> 也提到了几条 hooks，你可以用来辅助与 `git am` 相关工作流。\n\n在 <<ch06-github#_email_notifications>> 一节中我们也将用此命令来应用 格式化的 GitHub 的推送请求的变更。\n\n==== git format-patch\n\n`git format-patch` 命令用来以 mbox 的格式来生成一系列的补丁以便你可以发送到一个邮件列表中。\n\n我们在 <<ch05-distributed-git#_project_over_email>> 一节中研究了一个使用 `git format-patch` 工具为一个项目做贡献的示例。\n\n==== git imap-send\n\n`git imap-send` 将一个由 `git format-patch` 生成的邮箱上传至 IMAP 草稿文件夹。\n\n我们在 <<ch05-distributed-git#_project_over_email>> 一节中见过一个通过使用 `git imap-send` 工具向一个项目发送补丁进行贡献的例子。\n\n==== git send-email\n\n`git send-mail` 命令用来通过邮件发送那些使用 `git format-patch` 生成的补丁。\n\n我们在 <<ch05-distributed-git#_project_over_email>> 一节中研究了一个使用 `git send-email` 工具发送补丁来为一个项目做贡献的示例。\n\n==== git request-pull\n\n`git request-pull` 命令只是简单的用来生成一个可通过邮件发送给某个人的示例信息体。\n如果你在公共服务器上有一个分支，并且想让别人知道如何集成这些变更，而不用通过邮件发送补丁，你就可以执行此命令的输出发送给这个你想拉取变更的人。\n\n我们在 <<ch05-distributed-git#_public_project>> 一节中演示了如何使用 `git request-pull` 来生成一个推送消息。\n\n===  外部系统\n\nGit 有一些可以与其他的版本控制系统集成的命令。\n\n==== git svn\n\n`git svn` 可以使 Git 作为一个客户端来与 Subversion 版本控制系统通信。\n这意味着你可以使用 Git 来检出内容，或者提交到 Subversion 服务器。\n\n<<ch09-git-and-other-systems#_git_svn>> 一章深入讲解了此命令。\n\n==== git fast-import\n\n对于其他版本控制系统或者从其他任何的格式导入，你可以使用 `git fast-import` 快速地将其他格式映射到 Git 可以轻松记录的格式。\n\n在 <<ch09-git-and-other-systems#_custom_importer>> 一节中深入讲解了此命令。\n\n=== 管理\n\n如果你正在管理一个 Git 仓库，或者需要通过一个复杂的方法来修复某些东西，Git 提供了一些管理命令来帮助你。\n\n==== git gc\n\n`git gc` 命令在你的仓库中执行 “garbage collection”，删除数据库中不需要的文件和将其他文件打包成一种更有效的格式。\n\n此命令一般在背后为你工作，虽然你可以手动执行它-如果你想的话。\n我们在<<ch10-git-internals#_git_gc>> 一节中研究此命令的几个示例。\n\n==== git fsck\n\n`git fsck` 命令用来检查内部数据库的问题或者不一致性。\n\n我们只在 <<ch10-git-internals#_data_recovery>> 这一节中快速使用了一次此命令来搜索所有的悬空对象（dangling object）。\n\n==== git reflog\n\n`git reflog` 命令分析你所有分支的头指针的日志来查找出你在重写历史上可能丢失的提交。\n\n我们主要在 <<ch07-git-tools#_git_reflog>> 一节中提到了此命令，并在展示了一般用法，及如何使用 `git log -g` 来通过 `git log` 的输出来查看同样的信息。\n\n我们同样在 <<ch10-git-internals#_data_recovery>> 一节中研究了一个恢复丢失的分支的实例。\n\n==== git filter-branch\n\n`git filter-branch` 命令用来根据某些规则来重写大量的提交记录，例如从任何地方删除文件，或者通过过滤一个仓库中的一个单独的子目录以提取出一个项目。\n\n在 <<ch07-git-tools#_removing_file_every_commit>> 一节中，我们解释了此命令，并探究了其他几个选项，例如 `--commit-filter`，`--subdirectory-filter` 及 `--tree-filter` 。\n\n在 <<ch09-git-and-other-systems#_git_p4>> 的章节中我们使用它来修复已经导入的外部仓库。\n\n=== 底层命令\n\n在本书中我们也遇到了不少底层的命令。\n\n我们遇到的第一个底层命令是在 <<ch06-github#_pr_refs>> 中的 `ls-remote` 命令。我们用它来查看服务端的原始引用。\n\n我们在 <<ch07-git-tools#_manual_remerge>>、 <<ch07-git-tools#ef_rerere>> 及 <<ch07-git-tools#_the_index>> 章节中使用 `ls-files` 来查看暂存区的更原始的样子。\n\n我们同样在 <<ch07-git-tools#_branch_references>> 一节中提到了 `rev-parse` 命令，它可以接受任意字符串，并将其转成一个对象的 SHA-1 值。\n\n我们在 <<ch10-git-internals#ch10-git-internals>> 一章中对大部分的底层命令进行了介绍，这差不多正是这一章的重点所在。\n我们尽量避免了在本书的其他部分使用这些命令。\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.9599609375,
          "content": "# 向 Pro Git（第二版 简体中文）贡献\n\n## 授权许可\n\n向本仓库发起一个拉取请求，意味着你同意在 [项目授权许可](LICENSE.asc) 下提供你的工作。\n同样，因为未来打印版本的需要，你同意以这种许可授权你的工作给 @ben 与 @schacon。\n你的修改可能会出现在一个印刷版本中，你将被包括在 [贡献者列表](book/contributors.asc)中 。\n\n## 发起一个 Issue\n\n在发起一个 Issue 前，请在 bug 跟踪系统中搜索是否已有类似的问题。\n\n此外，如果该问题是在 git-scm.com 网站上发现的，请再次确认 pdf 版本中是否仍有此问题。\n该问题可能已被修复，但修改内容尚未部署。\n\n## 小的修正\n\n如果我们认同你的勘误和基本说明能够提升内容质量，那么它们将会被接受。\n你也可以发起一个 Issue，这样我们可以确定该问题是否需要解决，以及如何解决。\n\n如果你之前从未发起过 Issue，可参考 [流程向导](https://guides.github.com/introduction/flow/)。\n\n## 大范围重写\n\n在开始重写前，请先发起一个 Issue 讨论一下。这些改动往往非常主观，经常只为少数人澄清事实，很少值得花时间来接受它们。专业的编辑已经多次审核过这些内容，尽管你的文字品味和语法可能比我们更好一些，但你所写的内容不太可能 *如此* 地优秀以至于值得修改一大片文字。\n\n## 图表\n\n本书中使用的图片是使用 [Sketch 3](http://bohemiancoding.com/sketch/) 和 [包含的 sketchbook 文件](diagram-source/progit.sketch) 生成的。\n\n要添加一个图表：\n\n1. 向 sketchbook 添加一页。尽可能尝试使用内置符号。\n2. 向你的页中添加一个 \"slice\"。并给它一个相对于源代码根目录的与目标PNG文件名一致的名字。\n3. 确保你的 slice 设置导出为 \"800w\"。\n\n## 翻译\n\n如果你想将 Pro Git 翻译到你的语言，请参考 [TRANSLATING.md](TRANSLATING.md) 文件。\n"
        },
        {
          "name": "Gemfile",
          "type": "blob",
          "size": 0.4892578125,
          "content": "source 'https://rubygems.org'\n\ngem 'ffi', '1.16.3'\ngem 'rake'\ngem 'asciidoctor', '2.0.12'\n\ngem 'json'\ngem 'awesome_print'\n\ngem 'ttfunk', '1.5.1'\ngem 'asciidoctor-fb2'\ngem 'asciidoctor-epub3', '1.5.0.alpha.11'\ngem 'asciidoctor-pdf', '1.5.0.alpha.16'\ngem 'asciidoctor-pdf-cjk', '~> 0.1.3'\ngem 'asciidoctor-pdf-cjk-kai_gen_gothic', github: 'Sherry520/asciidoctor-pdf-cjk-kai_gen_gothic'\n\ngem 'coderay'\ngem 'pygments.rb'\ngem 'thread_safe'\ngem 'epubcheck-ruby'\ngem 'html-proofer'\n\ngem 'kindlegen', '3.1.1'\n"
        },
        {
          "name": "LICENSE.asc",
          "type": "blob",
          "size": 0.3173828125,
          "content": "本作品在“创作共用 署名-非商业性使用-相同方式共享 3.0 未本地化版本 (CC BY-NC-SA 3.0)”许可协议下授权。\n要阅览该许可的副本，请访问 https://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh\n或者写信向 Creative Commons, PO Box 1866, Mountain View, CA 94042, USA 获取。\n"
        },
        {
          "name": "Pro.ico",
          "type": "blob",
          "size": 1605.583984375,
          "content": null
        },
        {
          "name": "README.asc",
          "type": "blob",
          "size": 1.884765625,
          "content": "image::https://travis-ci.org/progit/progit2-zh.svg?branch=master[]\n= Pro Git，第二版，简体中文\n\n**翻译、校对、修改前请阅读 link:TRANSLATION_NOTES.asc[翻译规范]！**\n\n欢迎阅读 Pro Git 第二版。\n\n你可以访问 https://git-scm.com/book 在线阅读本书。\n\n与第一版类似，Pro Git 第二版以知识共享协议开源。\n\n自第一版开源以来，许多事情都发生了变化。\n首先，我们将本书的文本由 Markdown 迁移至 Asciidoc。\n\n我们还在独立的仓库中进行翻译，而不是在英文仓库的子目录中。\n查看 link:CONTRIBUTING.md[贡献文档] 了解更多信息。\n\n== 如何生成本书\n\n你可以用 Asciidoctor 手动生成电子书文件。\n如果你运行下面的命令，你 _可能_ 实际上获得 HTML、Epub、Mobi 和 PDF 输出文件：\n\n----\n$ bundle install\n$ asciidoctor-pdf-cjk-kai_gen_gothic-install\n$ bundle exec rake book:build\nConverting to HTML...\n -- HTML output at progit.html\nConverting to EPub...\n -- Epub output at progit.epub\nConverting to Mobi (kf8)...\n -- Mobi output at progit.mobi\nConverting to PDF...\n -- PDF output at progit.pdf\n----\n\n你可以只生成一种支持的格式（ HTML、EPUB、mobi、或 PDF ）。\n使用以下命令之一：\n\n生成 HTML 图书：\n\n----\n$ bundle exec rake book:build_html\n----\n\n生成 EPUB 图书：\n\n----\n$ bundle exec rake book:build_epub\n----\n\n生成 mobi 图书：\n\n----\n$ bundle exec rake book:build_mobi\n----\n\n生成 PDF 图书：\n\n----\n$ bundle exec rake book:build_pdf\n----\n\n## 发起一个 Issue\n\n在发起一个 Issue 前，请在 bug 跟踪系统中搜索是否已有类似的问题。\n\n此外，如果该问题是在 git-scm.com 网站上发现的，请再次确认 pdf 版本中是否仍有此问题。\n该问题可能已被修复，但修改内容尚未部署。\n\n== 贡献\n\n如果你想要帮助修改或者贡献翻译，查看 link:CONTRIBUTING.md[贡献者指南]。\n"
        },
        {
          "name": "Rakefile",
          "type": "blob",
          "size": 5.6865234375,
          "content": "def exec_or_raise(command)\n  puts `#{command}`\n  if (! $?.success?)\n    raise \"'#{command}' failed\"\n  end\nend\n\nnamespace :book do\n\n  # Download asciidoctor-pdf-cjk-kai_gen_gothic\n  exec_or_raise(\"asciidoctor-pdf-cjk-kai_gen_gothic-install\")\n\n  # Variables referenced for build\n  version_string = `git describe --tags --abbrev=0`.chomp\n  if version_string.empty?\n    version_string = '0'\n  else\n    versions = version_string.split('.')\n    version_string = versions[0] + '.' + versions[1] + '.' + versions[2].to_i.next.to_s\n  end\n  date_string = Time.now.strftime('%Y-%m-%d')\n  header_hash = `git rev-parse --short HEAD`.strip\n  \n  # Check language\n  repo = File.basename(`git rev-parse --show-toplevel`.chomp)\n  lang_match = repo.match(/progit2-([a-z-]*)/)\n  if lang_match\n    lang = lang_match[1]\n  else\n    lang = \"en\"\n  end\n\n  begin\n    if lang == \"zh\"\n      params = \"-r asciidoctor-pdf-cjk -r asciidoctor-pdf-cjk-kai_gen_gothic -a pdf-style=KaiGenGothicCN --attribute revnumber='#{version_string}' --attribute revdate='#{date_string}' --attribute lang='#{lang}'\"\n    elsif lang == \"zh-tw\"\n      params = \"-r asciidoctor-pdf-cjk -r asciidoctor-pdf-cjk-kai_gen_gothic -a pdf-style=KaiGenGothicTW --attribute revnumber='#{version_string}' --attribute revdate='#{date_string}' --attribute lang='#{lang}'\"\n    elsif lang == \"ja\"\n      params = \"-r asciidoctor-pdf-cjk -r asciidoctor-pdf-cjk-kai_gen_gothic -a pdf-style=KaiGenGothicJP --attribute revnumber='#{version_string}' --attribute revdate='#{date_string}' --attribute lang='#{lang}'\"\n    elsif lang == \"ko\"\n      params = \"-r asciidoctor-pdf-cjk -r asciidoctor-pdf-cjk-kai_gen_gothic -a pdf-style=KaiGenGothicKR --attribute revnumber='#{version_string}' --attribute revdate='#{date_string}' --attribute lang='#{lang}'\"\n    else\n      params = \"--attribute revnumber='#{version_string}' --attribute revdate='#{date_string}'\"\n    end\n  rescue => e\n    puts e.message\n    puts 'Error when checking repo language(ignored)'\n  end\n\n  # Check contributors list\n  # This checks commit hash stored in the header of list against current HEAD\n  def check_contrib\n    if File.exist?('book/contributors.txt')\n      current_head_hash = `git rev-parse --short HEAD`.strip\n      header = `head -n 1 book/contributors.txt`.strip\n      # Match regex, then coerce resulting array to string by join\n      header_hash = header.scan(/[a-f0-9]{7,}/).join\n\n      if header_hash == current_head_hash\n        puts \"Hash on header of contributors list (#{header_hash}) matches the current HEAD (#{current_head_hash})\"\n      else\n        puts \"Hash on header of contributors list (#{header_hash}) does not match the current HEAD (#{current_head_hash}), refreshing\"\n        sh \"rm book/contributors.txt\"\n        # Reenable and invoke task again\n        Rake::Task['book/contributors.txt'].reenable\n        Rake::Task['book/contributors.txt'].invoke\n      end\n    end\n  end\n\n  desc 'build basic book formats'\n  task :build => [:build_html, :build_epub, :build_fb2, :build_mobi, :build_pdf] do\n    begin\n        # Run check\n        Rake::Task['book:check'].invoke\n\n        # Rescue to ignore checking errors\n        rescue => e\n        puts e.message\n        puts 'Error when checking books (ignored)'\n    end\n  end\n\n  desc 'build basic book formats (for ci)'\n  task :ci => [:build_html, :build_epub, :build_fb2, :build_mobi, :build_pdf] do\n      # Run check, but don't ignore any errors\n      Rake::Task['book:check'].invoke\n  end\n\n  desc 'generate contributors list'\n  file 'book/contributors.txt' do\n      puts 'Generating contributors list'\n      sh \"echo 'Contributors as of #{header_hash}:\\n' > book/contributors.txt\"\n      sh \"git shortlog -s HEAD | grep -v -E '(Straub|Chacon|dependabot)' | cut -f 2- | sort | column -c 120 >> book/contributors.txt\"\n  end\n\n  desc 'build HTML format'\n  task :build_html => 'book/contributors.txt' do\n      check_contrib()\n\n      puts 'Converting to HTML...'\n      sh \"bundle exec asciidoctor #{params} -a data-uri progit.asc\"\n      puts ' -- HTML output at progit.html'\n\n  end\n\n  desc 'build Epub format'\n  task :build_epub => 'book/contributors.txt' do\n      check_contrib()\n\n      puts 'Converting to EPub...'\n      sh \"bundle exec asciidoctor-epub3 #{params} progit.asc\"\n      puts ' -- Epub output at progit.epub'\n\n  end\n\n  desc 'build FB2 format'\n  task :build_fb2 => 'book/contributors.txt' do\n      check_contrib()\n\n      puts 'Converting to FB2...'\n      sh \"bundle exec asciidoctor-fb2 #{params} progit.asc\"\n      puts ' -- FB2 output at progit.fb2.zip'\n\n  end\n\n  desc 'build Mobi format'\n  task :build_mobi => 'book/contributors.txt' do\n      check_contrib()\n\n      puts \"Converting to Mobi (kf8)...\"\n      sh \"bundle exec asciidoctor-epub3 #{params} -a ebook-format=kf8 progit.asc\"\n      puts \" -- Mobi output at progit.mobi\"\n  end\n\n  desc 'build PDF format'\n  task :build_pdf => 'book/contributors.txt' do\n      check_contrib()\n\n      puts 'Converting to PDF... (this one takes a while)'\n      sh \"bundle exec asciidoctor-pdf #{params} progit.asc 2>/dev/null\"\n      puts ' -- PDF output at progit.pdf'\n  end\n\n  desc 'Check generated books'\n  task :check => [:build_html, :build_epub] do\n      puts 'Checking generated books'\n\n      sh \"htmlproofer progit.html\"\n      sh \"epubcheck progit.epub\"\n  end\n\n  desc 'Clean all generated files'\n  task :clean do\n    begin\n        puts 'Removing generated files'\n\n        FileList['book/contributors.txt', 'progit.html', 'progit-kf8.epub', 'progit.epub', 'progit.fb2.zip', 'progit.mobi', 'progit.pdf'].each do |file|\n            rm file\n\n            # Rescue if file not found\n            rescue Errno::ENOENT => e\n              begin\n                  puts e.message\n                  puts 'Error removing files (ignored)'\n              end\n        end\n    end\n  end\n\nend\n\ntask :default => \"book:build\"\n"
        },
        {
          "name": "TRANSLATING.md",
          "type": "blob",
          "size": 7.0078125,
          "content": "# Translating Pro Git (2nd Edition)\n\nThe translations are managed in a decentralized way. Each translation team maintains their own project. Each translation is in its own repository, the Pro Git team simply pulls the changes and builds them into the https://git-scm.com website when ready.\n\n## General guidance for translating Pro Git\n\nPro Git is a book about a technical tool, therefore translating it is difficult compared to a non-technical translation.\n\nThe following are guidelines to help you on your way:\n* Before you begin, read the whole Git Pro book in English, so that you're aware of the content, and are familiar with the style used.\n* Ensure you have a good working knowledge of git, so that explaining the technical terms is doable.\n* Stick to a common style and format for the translation.\n* Be sure to read and understand the basics of [Asciidoc formatting](https://asciidoctor.org/docs/asciidoc-syntax-quick-reference/). Not following the asciidoc syntax can lead to problems with building/compilation of the pdf, epub and html files needed for the book.\n\n## Translating the book to another language\n\n### Helping with a existing project\n\n* Check for an already existing project in the following table.\n* Go to the project's page on GitHub.\n* Open an issue, introduce yourself and ask where you can help.\n\n| Language     | GitHub page     |\n| :------------- | :------------- |\n| العربية | [progit2-ar/progit2](https://github.com/progit2-ar/progit2) |\n| Беларуская  | [progit/progit2-be](https://github.com/progit/progit2-be) |\n| български език | [progit/progit2-bg](https://github.com/progit/progit2-bg) |\n| Čeština    | [progit-cs/progit2-cs](https://github.com/progit-cs/progit2-cs) |\n| English    | [progit/progit2](https://github.com/progit/progit2) |\n| Español    | [progit/progit2-es](https://github.com/progit/progit2-es) |\n| فارسی | [progit2-fa/progit2](https://github.com/progit2-fa/progit2) |\n| Français   | [progit/progit2-fr](https://github.com/progit/progit2-fr) |\n| Deutsch    | [progit/progit2-de](https://github.com/progit/progit2-de) |\n| Ελληνικά   | [progit2-gr/progit2](https://github.com/progit2-gr/progit2) |\n| Indonesian | [progit/progit2-id](https://github.com/progit/progit2-id) |\n| Italiano   | [progit/progit2-it](https://github.com/progit/progit2-it) |\n| 日本語   | [progit/progit2-ja](https://github.com/progit/progit2-ja) |\n| 한국어   | [progit/progit2-ko](https://github.com/progit/progit2-ko) |\n| Македонски | [progit2-mk/progit2](https://github.com/progit2-mk/progit2) |\n| Bahasa Melayu| [progit2-ms/progit2](https://github.com/progit2-ms/progit2) |\n| Nederlands | [progit/progit2-nl](https://github.com/progit/progit2-nl) |\n| Polski | [progit2-pl/progit2-pl](https://github.com/progit2-pl/progit2-pl) |\n| Português (Brasil) | [progit/progit2-pt-br](https://github.com/progit/progit2-pt-br) |\n| Русский   | [progit/progit2-ru](https://github.com/progit/progit2-ru) |\n| Slovenščina  | [progit/progit2-sl](https://github.com/progit/progit2-sl) |\n| Српски   | [progit/progit2-sr](https://github.com/progit/progit2-sr) |\n| Tagalog   | [progit2-tl/progit2](https://github.com/progit2-tl/progit2) |\n| Türkçe   | [progit/progit2-tr](https://github.com/progit/progit2-tr) |\n| Українська| [progit/progit2-uk](https://github.com/progit/progit2-uk) |\n| Ўзбекча  | [progit/progit2-uz](https://github.com/progit/progit2-uz) |\n| 简体中文  | [progit/progit2-zh](https://github.com/progit/progit2-zh) |\n| 正體中文  | [progit/progit2-zh-tw](https://github.com/progit/progit2-zh-tw) |\n\n### Starting a new translation\n\nIf there is no project for your language, you can start your own translation.\n\nBase your work on the second edition of the book, available [here](https://github.com/progit/progit2). To do so:\n 1. Pick the correct [ISO 639 code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) for your language.\n 1. Create a [GitHub organization](https://help.github.com/articles/creating-a-new-organization-from-scratch/), for example: `progit2-[your code]` on GitHub.\n 1. Create a project ``progit2``.\n 1. Copy the structure of progit/progit2 (this project) in your project and start translating.\n\n### Updating the status of your translation\n\nOn https://git-scm.com, the translations are divided into three categories. Once you have reached one of these levels, contact the maintainers of https://git-scm.com/ so that they can pull the changes.\n\n| Category | Completion     |\n| :------------- | :------------- |\n| Translation started for | Introduction translated, not much else. |\n| Partial translations available in | up to chapter 6 has been translated. |\n| Full translation available in |the book is (almost) fully translated. |\n\n## Continuous integration with Travis CI\n\nTravis CI is a [continuous integration](https://en.wikipedia.org/wiki/Continuous_integration) service that integrates with GitHub. Travis CI is used to ensure that a pull-request doesn't break the build or compilation. Travis CI can also provide compiled versions of the book.\n\nSetting up Travis CI requires administrative control over the repository.\n\n### Registering for Travis continuous integration\n\n1. Register a Travis account [here](https://travis-ci.org/).\n1. Register your project in Travis.\nPlease refer to the [Travis documentation](https://docs.travis-ci.com/) for more information.\n\n### Setting up your repository for continuous integration\n\nTravis CI works by scanning your project's root directory for a file named `.travis.yml` and following the 'recipe' that it contains. The good news is: there's already a working `.travis.yml` file in the Pro Git 2 source [here](https://raw.githubusercontent.com/progit/progit2-pub/master/travis.yml).\nCopy that file, and put it in your working directory. Commit the .yml file and push it to your translation repository; that should fire up a compilation and a check of the book's contents.\n\n## Setting up a publication chain for e-books\n\nThis is a technical task, please ping @jnavila to get started with epub publication.\n\n## Beyond Pro Git\n\nTranslating the book is the first step. Once this is finished, you could consider translating the user interface of Git itself.\n\nThis task requires a more technical knowledge of the tool than the book. Hopefully, after having translated the full book content, you can understand the terms used in the application. If you feel technically up to the task, the repo is [here](https://github.com/git-l10n/git-po) and you just have to follow the [guide](https://github.com/git-l10n/git-po/blob/master/po/README).\n\nBeware though that\n\n * you'll need to use more specific tools to manage localization po files (such as editing them with [poedit](https://poedit.net/) and merging them. You might need to compile git in order to check your work.\n * a basic knowledge of how translating applications works is required, which is significantly different from translating books.\n * the core Git project uses more stringent [procedures](https://github.com/git-l10n/git-po/blob/master/Documentation/SubmittingPatches) to accept contributions, be sure to abide by them.\n"
        },
        {
          "name": "TRANSLATION_NOTES.asc",
          "type": "blob",
          "size": 7.11328125,
          "content": "== 翻译注记\n\n本文件记录了词汇表、翻译风格、表达方式、翻译进度以及注意事项等多种内容。\n在派生此仓库前，请认真阅读本文件以协调翻译工作，统一译文风格。\n\n翻译版的维护者也可按需修改或重写本文件和 README 文件，在其中包含该语言的翻译指南。\n\n=== 翻译状态\n\n在翻译工作进行时，请及时修改 `status.json` 文件，更新每个文件的翻译进度。该信息将会在页面显示，以便读者知道还有多少工作才能完成。\n\n[line-through]#合并请求在接收到并审核完毕之后，保留 48 小时时间，以防又有别人发现新的问题。如果 48 小时之内没有其它改变，将直接合并到主分支。#（ *UPDATE* ：合并请求在三个有效审校并修订完成后直接合入主干。最终由一个审核小组统一风格。）\n\n== 翻译约定\n* [line-through]#在翻译之前，首先在 github 的 issue “翻译章节认领”中查找自己想翻译的章节是不是已经有人翻译，如果没有，在 issue 追加评论，避免重复劳动。#（ *UPDATE* ：所有翻译工作已经完成。请移步 https://github.com/progit/progit2-zh/issues/160 认领审校任务。）\n* 在存在与第一版相关章节时，注意参考第一版的相关翻译。\n* 原则上所有标点均使用全角，标点两侧不应有空格，输出、引用除外。\n* 嵌入中文中的英文两端添加空格；如果英文前、后是标点，则不需再添加空格。数字一般也按照英文的方式进行处理。\n* 原文中的“``PLACEHOLDER''”（两个反引号+文字+两个半角单引号）为双引号转义符，统一使用中文全角双引号““””，双引号前后不需要添加空格。\n++++\n对上一句的解释，请注意观察“”‘’\"'`的区别：原文有一个``killer feature,''，在英文版显示效果是“killer feature,”，没问题。但是中文版对应代码是``必杀技特性''，结果效果是`‘必杀技特性’'，因为处理中文的bug，仅仅转换了单引号。所以要把它换成“必杀技特性”，直接使用全角引号。翻译中很多引号错误都是因为不遵照上一条规范造成的！另外不要相信 https://tool.lu/asciidoc/ ，它的效果有很多错误\n++++\n* 在没有其它影响的情况下，英文“you”统一翻译为“你”。如果原文中“you”的出现过于频繁，可以在译文中适当减少“你”，或将部分“你”用“我们”替代，但应考虑如下原则：\n  - 保证句子主语明确、主谓一致。\n  - “你”与“我们”的表述不必严格统一，优先考虑行文的流畅。\n  - 某些可以根据上下文确定主语的场景，可以省略“你”或“我们”，但不宜滥用。\n* 章节头部的锚记（anchor）统一不译，保留原文。相应的交叉引用（xref）也应不译。参见《AsciiDoc User Guide》的“link:http://asciidoc.org/userguide.html#_inline_macros[21.1.2. Internal Cross References]”小节。\n* 所有的英文人名统一不译，保留原文。\n* 章节标题只能出现中文字样；如有必要说明术语原文，在正文中第一次出现处注明，不应重复。\n* 翻译提交之前将文件以 UTF-8 编码保存。\n\n=== 专业术语对照表\n\n为了保证翻译风格的统一，在翻译专业术语的时候请尽量参考如下对照表，同时也欢迎大家针对下表进行 *补充* 和 *讨论* 。\n\n术语的译法应当优先参考“link:https://github.com/git/git/blob/master/po/zh_CN.po[Git 软件包的简体中文翻译]”。\n\n==== *#*\n\n3-way merge => 三方合并\n\n==== *A*\n\nabbreviate => 简写/简写的 SHA-1 值\n\nabbreviated => 简写的\n\namend => 修补\n\nancestor => 祖先/祖先提交\n\nannotate => 附注\n\nannotated => 附注的\n\nannotated tag => 附注标签\n\napply => 应用\n\nargument => 参数\n\nauthentication => 认证\n\n==== *B*\n\nbackport => 向后移植\n\nbare repo => 纯仓库\n\nbare repository => 纯仓库\n\nbinding => 绑定\n\nbisect => 二分查找\n\nblob object => 数据对象\n\nbranch => 分支\n\nbug => bug\n\n==== *C*\n\ncertificate => 证书\n\ncheckout => 检出\n\nchecksum => 校验/校验和\n\ncherry-pick => 拣选\n\nchunk => 块/区块\n\nclean => 干净/干净的工作区\n\nclient => 客户端\n\nclone => 克隆\n\ncode review => 代码审查\n\ncollaborator => 合作者\n\ncommand => 命令\n\ncommit => 提交\n\ncommit message => 提交说明\n\ncommit object => 提交对象\n\nconfilict => 冲突\n\ncontributing => 贡献/作贡献\n\ncontribution => 贡献\n\ncontributor => 贡献者\n\n==== *D*\n\ndangling object => 悬空对象\n\ndumb HTTP protocol => 哑 HTTP 协议\n\n==== *E*\n\nemail address => 邮件地址\n\nendpoint => 接口\n\n==== *F*\n\nfast-forward => 快进\n\nfetch => 抓取\n\nfork => 派生\n\n==== *G*\n\nguideline => 准则\n\n==== *H*\n\nhash => 哈希/哈希值\n\nHEAD => HEAD/头指针/当前分支\n\nhead => 头/分支\n\nheader => 头信息\n\nhome directory => 主目录\n\nhook => 钩子\n\nhunk => 数据块/区块/片段\n\n==== *I*\n\nignore => 忽略\n\nimporter => 导入器\n\nindex => index/索引/暂存区\n\nissue => 缺陷/问题/议题/issue\n\n==== *J*\n\n==== *K*\n\n==== *L*\n\nlightweight tag => 轻量标签\n\nlog => 日志\n\nloose object => 松散对象\n\n==== *M*\n\nmerge => 合并\n\n==== *N*\n\n==== *O*\n\nobject => 对象\n\nobject database => 对象库\n\nobject name => 对象名称\n\nobject type => 对象类型\n\noption => 选项\n\n==== *P*\n\npack => 包/打包\n\npacked => 已打包的\n\npackfile => 包文件\n\nparameter => 参数\n\nparent => 父提交\n\npatch => 补丁\n\npathspec => 路径规范\n\npattern => 模式\n\nplumbing => 底层命令\n\nporcelain => 上层命令\n\nprogressive-stability => 趋于稳定\n\npull => 拉/拉取\n\npull request => 拉取请求\n\npush => 推/推送\n\n==== *Q*\n\n==== *R*\n\nreapply => 重新应用\n\nrebase => 变基\n\nref => 引用\n\nreference => 引用\n\nreflog => 引用日志\n\nrefspec => 引用规范\n\nregex => 正则表达式\n\nremote => 远程/远程仓库/远端\n\nremote helper => 远程助手\n\nremote-tracking branch => 远程跟踪分支\n\nreplay => 重放\n\nrepo => 仓库\n\nrepository => 仓库\n\nresolve => 解决\n\nreverse => 反转/相反\n\nrevert => 还原\n\nrevision => 版本\n\nrewind => 回退\n\nrewrite => 重写\n\n==== *S*\n\nSCM => SCM/源代码管理工具\n\nSHA-1 => SHA-1\n\nshorthand => 简写\n\nshow => 显示\n\nsign => 签名\n\nsigned => 已签署的/已签名的\n\nsigned tag => 签名标签\n\nsilo => 流水线\n\nsmart HTTP protocol => 智能 HTTP 协议\n\nsquash => 压缩\n\nstage => 暂存\n\nstaged => 已暂存的\n\nstaging area => 暂存区\n\nstash => 进度保存/保存进度/贮藏（做名词）\n\nstore => 保存/存储\n\nsubmodule => 子模块\n\n==== *T*\n\ntag => 标签/打标签\n\ntag object => 标签对象\n\ntagger => 打标签者\n\nthree-way merge => 三方合并\n\ntrack => 跟踪\n\ntracking branch => 跟踪分支\n\ntopic branch => 主题分支\n\ntree => 树/目录树\n\ntree object => 树对象\n\n==== *U*\n\nunambiguous => 没有歧义/没有歧义的\n\nunannotated tag => 未附注标签\n\nunpack => 解包\n\nunstage => 取消暂存\n\nupstream => 上游/上游仓库\n\n==== *V*\n\nVCS => 版本控制系统/VCS\n\n==== *W*\n\nwhitespace => 多余的空白字符\n\nworkflow => 工作流程\n\nworking directory => 工作目录\n\nworking tree => 工作区\n\n==== *X*\n\n==== *Y*\n\n==== *Z*\n"
        },
        {
          "name": "atlas.json",
          "type": "blob",
          "size": 2.0478515625,
          "content": "{\n  \"branch\": \"master\",\n  \"files\": [\n    \"book/cover.html\",\n    \"LICENSE.asc\",\n    \"book/preface.asc\",\n    \"book/contributors.asc\",\n    \"book/introduction.asc\",\n    \"book/toc.asc\",\n    \"book/01-introduction/1-introduction.asc\",\n    \"book/02-git-basics/1-git-basics.asc\",\n    \"book/03-git-branching/1-git-branching.asc\",\n    \"book/04-git-server/1-git-server.asc\",\n    \"book/05-distributed-git/1-distributed-git.asc\",\n    \"book/06-github/1-github.asc\",\n    \"book/07-git-tools/1-git-tools.asc\",\n    \"book/08-customizing-git/1-customizing-git.asc\",\n    \"book/09-git-and-other-scms/1-git-and-other-scms.asc\",\n    \"book/10-git-internals/1-git-internals.asc\",\n    \"book/A-git-in-other-environments/1-git-other-environments.asc\",\n    \"book/B-embedding-git/1-embedding-git.asc\",\n    \"book/C-git-commands/1-git-commands.asc\",\n    \"book/index.asc\"\n  ],\n  \"formats\": {\n    \"pdf\": {\n      \"version\": \"web\",\n      \"index\": true,\n      \"toc\": true,\n      \"syntaxhighlighting\": true,\n      \"show_comments\": false\n    },\n    \"epub\": {\n      \"index\": true,\n      \"toc\": true,\n      \"epubcheck\": true,\n      \"embedded_fonts\": [\n        \"fonts/DejaVuSerif.otf\",\n        \"fonts/DejaVuSans-Bold.otf\",\n        \"fonts/hold/UbuntuMono-Bold.otf\",\n        \"fonts/hold/UbuntuMono-BoldItalic.otf\",\n        \"fonts/hold/UbuntuMono-Regular.otf\",\n        \"fonts/hold/UbuntuMono-Italic.otf\"\n      ],\n      \"syntaxhighlighting\": true,\n      \"show_comments\": false\n    },\n    \"mobi\": {\n      \"index\": true,\n      \"toc\": true,\n      \"embedded_fonts\": [\n        \"fonts/DejaVuSerif.otf\",\n        \"fonts/DejaVuSans-Bold.otf\",\n        \"fonts/hold/UbuntuMono-Bold.otf\",\n        \"fonts/hold/UbuntuMono-BoldItalic.otf\",\n        \"fonts/hold/UbuntuMono-Regular.otf\",\n        \"fonts/hold/UbuntuMono-Italic.otf\"\n      ],\n      \"syntaxhighlighting\": true,\n      \"show_comments\": false\n    },\n    \"html\": {\n      \"index\": true,\n      \"toc\": true,\n      \"syntaxhighlighting\": true,\n      \"show_comments\": false,\n      \"consolidate\": false,\n      \"consolidated\": false\n    }\n  },\n  \"theme\": \"oreillymedia/atlas_tech1c_theme\",\n  \"title\": \"Pro Git\"\n}\n"
        },
        {
          "name": "book",
          "type": "tree",
          "content": null
        },
        {
          "name": "callouts",
          "type": "tree",
          "content": null
        },
        {
          "name": "ch01-getting-started.asc",
          "type": "blob",
          "size": 1.0361328125,
          "content": "[[ch01-getting-started]]\n== 起步\n\n本章为 Git 入门。\n我们从介绍版本控制工具的背景知识开始，然后讲解如何在你的系统上运行 Git，最后是关于如何设置 Git 以便开始工作。\n通过本章的学习，你应该能了解为什么 Git 这么流行，为什么你应该使用 Git 以及你应该如何设置以便使用 Git。\n\ninclude::book/01-introduction/sections/about-version-control.asc[]\n\ninclude::book/01-introduction/sections/history.asc[]\n\ninclude::book/01-introduction/sections/what-is-git.asc[]\n\ninclude::book/01-introduction/sections/command-line.asc[]\n\ninclude::book/01-introduction/sections/installing.asc[]\n\ninclude::book/01-introduction/sections/first-time-setup.asc[]\n\ninclude::book/01-introduction/sections/help.asc[]\n\n=== 总结\n\n你应该已经对 Git 是什么、Git 与你可能正在使用的集中式版本控制系统有何区别等问题有了基本的了解。\n现在，在你的系统中应该也有了一份能够工作的 Git 版本。\n是时候开始学习有关 Git 的基础知识了。\n"
        },
        {
          "name": "ch02-git-basics-chapter.asc",
          "type": "blob",
          "size": 1.3623046875,
          "content": "[[ch02-git-basics-chapter]]\n== Git 基础\n\n如果你只想通过阅读一章来学习 Git，那么本章将是你的不二选择。\n本章涵盖了你在使用 Git 完成各种工作时将会用到的各种基本命令。\n在学习完本章之后，你应该能够配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit）更改。\n本章也将向你演示了如何配置 Git 来忽略指定的文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）之间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。\n\ninclude::book/02-git-basics/sections/getting-a-repository.asc[]\n\ninclude::book/02-git-basics/sections/recording-changes.asc[]\n\ninclude::book/02-git-basics/sections/viewing-history.asc[]\n\ninclude::book/02-git-basics/sections/undoing.asc[]\n\ninclude::book/02-git-basics/sections/remotes.asc[]\n\ninclude::book/02-git-basics/sections/tagging.asc[]\n\ninclude::book/02-git-basics/sections/aliases.asc[]\n\n=== 总结\n\n现在，你应该能完成所有 Git 基本的本地操作了－创建或克隆一个仓库、进行更改、暂存并提交这些更改、浏览仓库从创建到现在的所有更改历史。\n接下来，本书将介绍 Git 的杀手级特性：分支模型。\n"
        },
        {
          "name": "ch03-git-branching.asc",
          "type": "blob",
          "size": 1.8662109375,
          "content": "[[ch03-git-branching]]\n== Git 分支\n\n(((branches)))\n几乎所有的版本控制系统都以某种形式支持分支。\n使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。\n在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。\n\n有人把 Git 的分支模型称为它的“必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。\n为何 Git 的分支模型如此出众呢？\nGit 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。\n与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\n理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。\n\ninclude::book/03-git-branching/sections/nutshell.asc[]\n\ninclude::book/03-git-branching/sections/basic-branching-and-merging.asc[]\n\ninclude::book/03-git-branching/sections/branch-management.asc[]\n\ninclude::book/03-git-branching/sections/workflows.asc[]\n\ninclude::book/03-git-branching/sections/remote-branches.asc[]\n\ninclude::book/03-git-branching/sections/rebasing.asc[]\n\n=== 总结\n\n我们已经讲完了 Git 分支与合并的基础知识。\n你现在应该能自如地创建并切换至新分支、在不同分支之间切换以及合并本地分支。\n你现在应该也能通过推送你的分支至共享服务以分享它们、使用共享分支与他人协作以及在共享之前使用变基操作合并你的分支。\n下一章，我们将要讲到，如果你想要运行自己的 Git 仓库托管服务器，你需要知道些什么。\n"
        },
        {
          "name": "ch04-git-on-the-server.asc",
          "type": "blob",
          "size": 2.7216796875,
          "content": "[[ch04-git-on-the-server]]\n== 服务器上的 Git\n\n(((serving repositories)))\n到目前为止，你应该已经有办法使用 Git 来完成日常工作。\n然而，为了使用 Git 协作功能，你还需要有远程的 Git 仓库。\n尽管在技术上你可以从个人仓库进行推送（push）和拉取（pull）来修改内容，但不鼓励使用这种方法，因为一不留心就很容易弄混其他人的进度。\n此外，你希望你的合作者们即使在你的电脑未联机时亦能存取仓库 — 拥有一个更可靠的公用仓库十分有用。\n因此，与他人合作的最佳方法即是建立一个你与合作者们都有权利访问，且可从那里推送和拉取资料的共用仓库。\n\n架设一台 Git 服务器并不难。\n首先，选择你希望服务器使用的通讯协议。\n在本章第一节将介绍可用的协议以及各自优缺点。\n下面一节将解释使用那些协议的典型设置及如何在你的服务器上运行。\n最后，如果你不介意托管你的代码在其他人的服务器，且不想经历设置与维护自己服务器的麻烦，可以试试我们介绍的几个仓库托管服务。\n\n如果你对架设自己的服务器没兴趣，可以跳到本章最后一节去看看如何申请一个代码托管服务的帐户然后继续下一章，我们会在那里讨论分布式源码控制环境的林林总总。\n\n一个远程仓库通常只是一个裸仓库（bare repository）——即一个没有当前工作目录的仓库。\n因为该仓库仅仅作为合作媒介，不需要从磁盘检查快照；存放的只有 Git 的资料。\n简单的说，裸仓库就是你工程目录内的 `.git` 子目录内容，不包含其他资料。\n\ninclude::book/04-git-server/sections/protocols.asc[]\n\ninclude::book/04-git-server/sections/git-on-a-server.asc[]\n\ninclude::book/04-git-server/sections/generating-ssh-key.asc[]\n\ninclude::book/04-git-server/sections/setting-up-server.asc[]\n\ninclude::book/04-git-server/sections/git-daemon.asc[]\n\ninclude::book/04-git-server/sections/smart-http.asc[]\n\ninclude::book/04-git-server/sections/gitweb.asc[]\n\ninclude::book/04-git-server/sections/gitlab.asc[]\n\ninclude::book/04-git-server/sections/hosted.asc[]\n\n=== 总结\n\n你有多种远程存取 Git 仓库的选择便于与其他人合作或是分享你的工作。\n\n运行你自己的服务器将有许多权限且允许你运行该服务于你自己的防火墙内，但如此通常需要耗费你大量的时间去设置与维护服务器。\n如果你放置你的资料于托管服务器内，可轻易的设置与维护；无论如何，你必须能够保存你的代码在其他服务器，且某些组织不允许此作法。\n这将直截了当的决定哪个作法或组合的方式较适合你或你的组织。\n"
        },
        {
          "name": "ch05-distributed-git.asc",
          "type": "blob",
          "size": 1.099609375,
          "content": "[[ch05-distributed-git]]\n== 分布式 Git\n\n(((distributed git)))\n你现在拥有了一个远程 Git 版本库，能为所有开发者共享代码提供服务，在一个本地工作流程下，你也已经熟悉了基本 Git 命令。你现在可以学习如何利用 Git 提供的一些分布式工作流程了。\n\n这一章中，你将会学习如何作为贡献者或整合者，在一个分布式协作的环境中使用 Git。\n你会学习为一个项目成功地贡献代码，并接触一些最佳实践方式，让你和项目的维护者能轻松地完成这个过程。另外，你也会学到如何管理有很多开发者提交贡献的项目。\n\ninclude::book/05-distributed-git/sections/distributed-workflows.asc[]\n\ninclude::book/05-distributed-git/sections/contributing.asc[]\n\ninclude::book/05-distributed-git/sections/maintaining.asc[]\n\n=== 总结\n\n你现在能自如地使用 Git 为项目做出贡献、维护自己的项目或采纳其他用户的贡献了。\n恭喜你成为了一个高效的 Git 开发者！\n下一章中，你将会学到如何使用规模最大最流行的 Git 托管服务，GitHub。\n"
        },
        {
          "name": "ch06-github.asc",
          "type": "blob",
          "size": 1.8505859375,
          "content": "[[ch06-github]]\n== GitHub\n\n(((GitHub)))\nGitHub 是最大的 Git 版本库托管商，是成千上万的开发者和项目能够合作进行的中心。\n大部分 Git 版本库都托管在 GitHub，很多开源项目使用 GitHub 实现 Git 托管、问题追踪、代码审查以及其它事情。\n所以，尽管这不是 Git 开源项目的直接部分，但如果想要专业地使用 Git，你将不可避免地与 GitHub 打交道，所以这依然是一个绝好的学习机会。\n\n本章将讨论如何高效地使用 GitHub。\n我们将学习如何注册和管理账户、创建和使用 Git 版本库、向已有项目贡献的通用流程以及如何接受别人向你自己项目的贡献、GitHub 的编程接口和很多能够让这些操作更简单的小提示。\n\n如果你对如何使用 GitHub 托管自己的项目，或者与已经托管在 GitHub 上面的项目进行合作没有兴趣，可以直接跳到 <<ch07-git-tools#ch07-git-tools>> 这一章。\n\n[WARNING]\n.接口的改变\n====\n需要注意一点，同很多活跃的网站一样，书中截取的界面会随时间而改变。\n希望我们试图表达的核心思想一直是不变的，但是，如果你想要这些截图的更新版本，本书的在线版本或许有更新的截图。\n====\n\ninclude::book/06-github/sections/1-setting-up-account.asc[]\n\ninclude::book/06-github/sections/2-contributing.asc[]\n\ninclude::book/06-github/sections/3-maintaining.asc[]\n\ninclude::book/06-github/sections/4-managing-organization.asc[]\n\ninclude::book/06-github/sections/5-scripting.asc[]\n\n=== 总结\n\n现在你已经是一名 GitHub 用户了。\n你知道了如何创建账户、管理组织、创建和推送版本库、向别人的项目提供贡献以及接受别人的贡献。\n在下一章中，你将学习更多强有力的工具，以及处理复杂情况的知识，这些将使你成为真正的 Git 大师。\n"
        },
        {
          "name": "ch07-git-tools.asc",
          "type": "blob",
          "size": 1.56640625,
          "content": "[[ch07-git-tools]]\n== Git 工具\n\n现在，你已经学习了管理或者维护 Git 仓库、实现代码控制所需的大多数日常命令和工作流程。\n你已经尝试了跟踪和提交文件的基本操作，并且掌握了暂存区和轻量级地分支及合并的威力。\n\n接下来你将学习一些 Git 的强大功能，这些功能你可能并不会在日常操作中使用，但在某些时候你可能会需要。\n\ninclude::book/07-git-tools/sections/revision-selection.asc[]\n\ninclude::book/07-git-tools/sections/interactive-staging.asc[]\n\ninclude::book/07-git-tools/sections/stashing-cleaning.asc[]\n\ninclude::book/07-git-tools/sections/signing.asc[]\n\ninclude::book/07-git-tools/sections/searching.asc[]\n\ninclude::book/07-git-tools/sections/rewriting-history.asc[]\n\ninclude::book/07-git-tools/sections/reset.asc[]\n\ninclude::book/07-git-tools/sections/advanced-merging.asc[]\n\ninclude::book/07-git-tools/sections/rerere.asc[]\n\ninclude::book/07-git-tools/sections/debugging.asc[]\n\ninclude::book/07-git-tools/sections/submodules.asc[]\n\ninclude::book/07-git-tools/sections/bundling.asc[]\n\ninclude::book/07-git-tools/sections/replace.asc[]\n\ninclude::book/07-git-tools/sections/credentials.asc[]\n\n=== 总结\n\n你已经接触了很多能够精确地操控提交和暂存区的高级工具。\n当你碰到问题时，你应该可以很容易找出是哪个分支在什么时候由谁引入了它们。\n如果你想在项目中使用子项目，你也已经知道如何来满足这些需求。\n到此，你应该能毫无压力地在命令行中使用 Git 来完成日常中的大部分事情。\n"
        },
        {
          "name": "ch08-customizing-git.asc",
          "type": "blob",
          "size": 0.9775390625,
          "content": "[[ch08-customizing-git]]\n== 自定义 Git\n\n到目前为止，我们已经阐述了 Git 基本的运作机制和使用方式，介绍了许多 Git 提供的工具来帮助你简单且有效地使用它。\n在本章，我们将演示如何借助 Git 的一些重要的配置方法和钩子机制，来满足自定义的需求。\n通过这些工具，它会和你、你的公司或你的团队配合得天衣无缝。\n\ninclude::book/08-customizing-git/sections/config.asc[]\n\ninclude::book/08-customizing-git/sections/attributes.asc[]\n\ninclude::book/08-customizing-git/sections/hooks.asc[]\n\ninclude::book/08-customizing-git/sections/policy.asc[]\n\n=== 总结\n\n我们已经阐述了大部分通过自定义 Git 客户端和服务端来适应自己工作流程和项目内容的方式。\n你已经学到各种各样的设置项、基于文件的选项和事件钩子，还建立了一个示例用的强制策略服务器。\n无论创造出了什么样的工作流程，你都能使 Git 与它珠联璧合。\n"
        },
        {
          "name": "ch09-git-and-other-systems.asc",
          "type": "blob",
          "size": 2.216796875,
          "content": "[[ch09-git-and-other-systems]]\n== Git 与其他系统\n\n现实并不总是尽如人意。\n通常，你不能立刻就把接触到的每一个项目都切换到 Git。\n有时候你被困在使用其他 VCS 的项目中，却希望使用 Git。\n在本章的第一部分我们将会了解到，怎样在你的那些托管在不同系统的项目上使用 Git 客户端。\n\n在某些时候，你可能想要将已有项目转换到 Git。\n本章的第二部分涵盖了从几个特定系统将你的项目迁移至 Git 的方法，即使没有预先构建好的导入工具，我们也有办法手动导入。\n\n=== 作为客户端的 Git\n\n(((Git as a client)))\nGit 为开发者提供了如此优秀的体验，许多人已经找到了在他们的工作站上使用 Git 的方法，即使他们团队其余的人使用的是完全不同的 VCS。\n有许多这种可用的适配器，它们被叫做“桥接”。\n下面我们将要介绍几个很可能会在实际中用到的桥接。\n\ninclude::book/09-git-and-other-scms/sections/client-svn.asc[]\n\ninclude::book/09-git-and-other-scms/sections/client-hg.asc[]\n\ninclude::book/09-git-and-other-scms/sections/client-p4.asc[]\n\n[[_migrating]]\n=== 迁移到 Git\n\n(((Migrating to Git)))\n如果你现在有一个正在使用其他 VCS 的代码库，但是你已经决定开始使用 Git，必须通过某种方式将你的项目迁移至 Git。\n这一部分会介绍一些通用系统的导入器，然后演示如何开发你自己定制的导入器。\n你将会学习如何从几个大型专业应用的 SCM 系统中导入数据，不仅因为它们是大多数想要转换的用户正在使用的系统，也因为获取针对它们的高质量工具很容易。\n\ninclude::book/09-git-and-other-scms/sections/import-svn.asc[]\n\ninclude::book/09-git-and-other-scms/sections/import-hg.asc[]\n\ninclude::book/09-git-and-other-scms/sections/import-p4.asc[]\n\ninclude::book/09-git-and-other-scms/sections/import-custom.asc[]\n\n=== 总结\n\n你会觉得将 Git 作为其他版本控制系统的客户端，或者在数据无损的情况下将几乎任何一个现有的仓库导入到 Git，都是一件很惬意的事。\n在下一章，我们将要讲解 Git 的原始内部数据，如果需要的话你就可以加工每一个字节。\n"
        },
        {
          "name": "ch10-git-internals.asc",
          "type": "blob",
          "size": 2.564453125,
          "content": "[[ch10-git-internals]]\n== Git 内部原理\n\n无论是从之前的章节直接跳到本章，还是读完了其余章节一直到这——你都将在本章见识到 Git 的内部工作原理和实现方式。\n我们认为学习这部分内容对于理解 Git 的用途和强大至关重要。不过也有人认为这些内容对于初学者而言可能难以理解且过于复杂。\n因此我们把这部分内容放在最后一章，在学习过程中可以先阅读这部分，也可以晚点阅读这部分，这取决于你自己。\n\n无论如何，既然已经读到了这里，就让我们开始吧。\n首先要弄明白一点，从根本上来讲 Git 是一个内容寻址（content-addressable）文件系统，并在此之上提供了一个版本控制系统的用户界面。\n马上你就会学到这意味着什么。\n\n早期的 Git（主要是 1.5 之前的版本）的用户界面要比现在复杂的多，因为它更侧重于作为一个文件系统，而不是一个打磨过的版本控制系统。\n不时会有一些陈词滥调抱怨早期那个晦涩复杂的 Git 用户界面；不过最近几年来，它已经被改进到不输于任何其他版本控制系统地清晰易用了。\n\n内容寻址文件系统层是一套相当酷的东西，所以在本章我们会先讲解这部分内容。随后我们会学习传输机制和版本库管理任务——你迟早会和它们打交道。\n\ninclude::book/10-git-internals/sections/plumbing-porcelain.asc[]\n\ninclude::book/10-git-internals/sections/objects.asc[]\n\ninclude::book/10-git-internals/sections/refs.asc[]\n\ninclude::book/10-git-internals/sections/packfiles.asc[]\n\ninclude::book/10-git-internals/sections/refspec.asc[]\n\ninclude::book/10-git-internals/sections/transfer-protocols.asc[]\n\ninclude::book/10-git-internals/sections/maintenance.asc[]\n\ninclude::book/10-git-internals/sections/environment.asc[]\n\n=== 总结\n\n现在，你应该相当了解 Git 在背后都做了些什么工作，并且在一定程度上也知道了 Git 是如何实现的。\n本章讨论了很多底层命令，这些命令比我们在本书其余部分学到的高层命令来得更原始，也更简洁。\n从底层了解 Git 的工作原理有助于更好地理解 Git 在内部是如何运作的，也方便你能够针对特定的工作流写出自己的工具和脚本。\n\n作为一套内容寻址文件系统，Git 不仅仅是一个版本控制系统，它同时是一个非常强大且易用的工具。\n我们希望你可以借助新学到的 Git 内部原理相关知识来实现出自己的应用，并且以更高级、更得心应手的方式来驾驭 Git。\n"
        },
        {
          "name": "config.rb",
          "type": "blob",
          "size": 0.552734375,
          "content": "Bundler.require(:default)\n\nclass TrailingTreeprocessor < Asciidoctor::Extensions::Treeprocessor\n  def process document\n    return unless document.blocks?\n    process_blocks document\n    nil\n  end\n\n  def process_blocks node\n    node.blocks.each_with_index do |block, index|\n      if block.context == :paragraph\n        node.blocks[index] = create_paragraph block.document, block.content.gsub(\"\\n\", ''), block.attributes\n      else\n        process_blocks block\n      end\n    end\n  end\nend\n\nAsciidoctor::Extensions.register do\n  treeprocessor TrailingTreeprocessor\nend\n"
        },
        {
          "name": "diagram-source",
          "type": "tree",
          "content": null
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.asc",
          "type": "blob",
          "size": 0.025390625,
          "content": "[#index]\n[index]\n= 索引\n"
        },
        {
          "name": "progit.asc",
          "type": "blob",
          "size": 0.9638671875,
          "content": "= Pro Git\nScott Chacon; Ben Straub\n:doctype: book\n:docinfo:\n:toc:\n:toclevels: 2\n:pagenums:\n:front-cover-image: image:book/cover.png[width=1050,height=1600]\n:icons: font\n:toc-title: 目录\n:appendix-caption: 附录\n\n\nifdef::ebook-format[:leveloffset: -1]\n\ninclude::book/license.asc[]\n\ninclude::book/preface_schacon.asc[]\n\ninclude::book/preface_ben.asc[]\n\ninclude::book/dedication.asc[]\n\ninclude::book/contributors.asc[]\n\ninclude::book/introduction.asc[]\n\ninclude::ch01-getting-started.asc[]\n\ninclude::ch02-git-basics-chapter.asc[]\n\ninclude::ch03-git-branching.asc[]\n\ninclude::ch04-git-on-the-server.asc[]\n\ninclude::ch05-distributed-git.asc[]\n\ninclude::ch06-github.asc[]\n\ninclude::ch07-git-tools.asc[]\n\ninclude::ch08-customizing-git.asc[]\n\ninclude::ch09-git-and-other-systems.asc[]\n\ninclude::ch10-git-internals.asc[]\n\ninclude::A-git-in-other-environments.asc[]\n\ninclude::B-embedding-git-in-your-applications.asc[]\n\ninclude::C-git-commands.asc[]\n\nifndef::ebook-format[include::index.asc[]]\n"
        },
        {
          "name": "script",
          "type": "tree",
          "content": null
        },
        {
          "name": "status.json",
          "type": "blob",
          "size": 4.1025390625,
          "content": "{\n  \"code\": \"zh\",\n  \"language\": \"Simplified Chinese\",\n  \"maintainers\": [\"networm\"],\n  \"files\": {\n    \"01-introduction\": {\n      \"1-introduction.asc\": 100,\n      \"sections/about-version-control.asc\": 100,\n      \"sections/basics.asc\": 100,\n      \"sections/command-line.asc\": 100,\n      \"sections/first-time-setup.asc\": 100,\n      \"sections/help.asc\": 100,\n      \"sections/history.asc\": 100,\n      \"sections/installing.asc\": 100\n    },\n    \"02-git-basics\": {\n      \"1-git-basics.asc\": 100,\n      \"sections/aliases.asc\": 100,\n      \"sections/getting-a-repository.asc\": 100,\n      \"sections/recording-changes.asc\": 100,\n      \"sections/remotes.asc\": 100,\n      \"sections/tagging.asc\": 100,\n      \"sections/undoing.asc\": 100,\n      \"sections/viewing-history.asc\": 100\n    },\n    \"03-git-branching\": {\n      \"1-git-branching.asc\": 100,\n      \"sections/basic-branching-and-merging.asc\": 100,\n      \"sections/branch-management.asc\": 100,\n      \"sections/nutshell.asc\": 100,\n      \"sections/rebasing.asc\": 100,\n      \"sections/remote-branches.asc\": 100,\n      \"sections/workflows.asc\": 100\n    },\n    \"04-git-server\": {\n      \"1-git-server.asc\": 100,\n      \"sections/generating-ssh-key.asc\": 100,\n      \"sections/git-daemon.asc\": 100,\n      \"sections/git-on-a-server.asc\": 100,\n      \"sections/gitlab.asc\": 100,\n      \"sections/gitweb.asc\": 100,\n      \"sections/hosted.asc\": 100,\n      \"sections/protocols.asc\": 100,\n      \"sections/setting-up-server.asc\": 100,\n      \"sections/smart-http.asc\": 100\n    },\n    \"05-distributed-git\": {\n      \"1-distributed-git.asc\": 100,\n      \"sections/contributing.asc\": 100,\n      \"sections/distributed-workflows.asc\": 100,\n      \"sections/maintaining.asc\": 100\n    },\n    \"06-github\": {\n      \"1-github.asc\": 100,\n      \"sections/1-setting-up-account.asc\": 100,\n      \"sections/2-contributing.asc\": 100,\n      \"sections/3-maintaining.asc\": 100,\n      \"sections/4-managing-organization.asc\": 100,\n      \"sections/5-scripting.asc\": 100\n    },\n    \"07-git-tools\": {\n      \"1-git-tools.asc\": 100,\n      \"sections/advanced-merging.asc\": 100,\n      \"sections/bundling.asc\": 100,\n      \"sections/credentials.asc\": 100,\n      \"sections/debugging.asc\": 100,\n      \"sections/interactive-staging.asc\": 100,\n      \"sections/replace.asc\": 100,\n      \"sections/rerere.asc\": 100,\n      \"sections/reset.asc\": 100,\n      \"sections/revision-selection.asc\": 100,\n      \"sections/rewriting-history.asc\": 100,\n      \"sections/searching.asc\": 100,\n      \"sections/signing.asc\": 100,\n      \"sections/stashing-cleaning.asc\": 100,\n      \"sections/submodules.asc\": 100,\n      \"sections/subtree-merges.asc\": 100\n    },\n    \"08-customizing-git\": {\n      \"1-customizing-git.asc\": 100,\n      \"sections/attributes.asc\": 100,\n      \"sections/config.asc\": 100,\n      \"sections/hooks.asc\": 100,\n      \"sections/policy.asc\": 100\n    },\n    \"09-git-and-other-scms\": {\n      \"1-git-and-other-scms.asc\": 100,\n      \"sections/client-hg.asc\": 100,\n      \"sections/client-p4.asc\": 100,\n      \"sections/client-svn.asc\": 100,\n      \"sections/import-custom.asc\": 100,\n      \"sections/import-hg.asc\": 100,\n      \"sections/import-p4.asc\": 100,\n      \"sections/import-svn.asc\": 100\n    },\n    \"10-git-internals\": {\n      \"1-git-internals.asc\": 100,\n      \"sections/environment.asc\": 100,\n      \"sections/maintenance.asc\": 100,\n      \"sections/objects.asc\": 100,\n      \"sections/packfiles.asc\": 100,\n      \"sections/plumbing-porcelain.asc\": 100,\n      \"sections/refs.asc\": 100,\n      \"sections/refspec.asc\": 100,\n      \"sections/transfer-protocols.asc\": 100\n    },\n    \"A-git-in-other-environments\": {\n      \"1-git-other-environments.asc\": 100,\n      \"sections/bash.asc\": 100,\n      \"sections/eclipse.asc\": 100,\n      \"sections/guis.asc\": 100,\n      \"sections/powershell.asc\": 100,\n      \"sections/visualstudio.asc\": 100,\n      \"sections/zsh.asc\": 100,\n      \"sections/visualstudiocode.asc\": 100,\n      \"sections/sublimetext.asc\": 100,\n      \"sections/jetbrainsides.asc\": 100\n    },\n    \"B-embedding-git\": {\n      \"1-embedding-git.asc\": 100,\n      \"sections/command-line.asc\": 100,\n      \"sections/jgit.asc\": 100,\n      \"sections/libgit2.asc\": 100\n    },\n    \"C-git-commands\": {\n      \"1-git-commands.asc\": 100\n    }\n  }\n}\n"
        },
        {
          "name": "theme",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}