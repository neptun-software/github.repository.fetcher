{
  "metadata": {
    "timestamp": 1736711674846,
    "page": 342,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "seankross/the-unix-workbench",
      "stars": 1279,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".Rbuildignore",
          "type": "blob",
          "size": 0.056640625,
          "content": "^.*\\.Rproj$\n^\\.Rproj\\.user$\n^\\.travis\\.yml$\n^CONDUCT\\.md$\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0947265625,
          "content": ".Rproj.user\n.Rhistory\n.RData\n_bookdown_files\n.DS_Store\n*.rds\n.Rapp.history\nrsconnect/*\n.rstudio/*"
        },
        {
          "name": ".nojekyll",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.779296875,
          "content": "language: r\ncache: packages\nscript:\n- Rscript -e 'bookdown::render_book(\"index.rmd\")'\nenv:\n  global:\n    secure: pvgYZfGz3xiuiyGBMcjlIGcjYtVMc1/Gpg5UGSxkZTbTxaIEB+e6q5QWsYwltgy7nyOs4VUm0tm5KIZGjj9tWU7GUPqR8P3EeSaFJDKgulcxbF1T+oN+rrEg6pvpUqvpLESFghGlRVAx55ht9X4/pV5yHSTxC3Z207Ux5KifCn4OTGgkOcKx6KJ9YEZ5vXMwkwtuvX55Pca7Or7HJ2ZV/gk0Y1cB+t1UYnjDZukYBHs2gIml2i2sEixuBxKk4Isv33YMTFno4Hm/gdgsrZBrAmfTYe9DrAsdIoZfm6SsE8ElTKFWvAlbC/sxQryJg5eioBnDzgN0z7117YBcTbHMwVliwzOLNxk0zgQWYbIzrt7mk0JtJkFYN9EaBFWnqzCQCmpzR7w43WRQVFa6jMytu+z2dXstY+iMdV091dxw7pUQdi7Mwxabln6Fy/HJVo9YcJYv5rtbYiri955eMyQi2ygI3MEcPhdtTQorTI1J8wdgAFLVAVLERlupOs6/RTDW1rUq1UOFb4fqJHksU4EuRT3rV1hg8cVr5bBr7NMkOJrjRwbxGywrFlbq1EwZgAkHgZ/kUwdcvnZCHLcAvvOQMBQzowVdT3mZnzK9VWNK+jxzfnb3Gbw+m0tndSzlpy+dd2CW/DxMMTHxrGu4QAync7Xj/jcoBtpNGkrAwcq+cn4=\n"
        },
        {
          "name": "01-What-is-Unix.Rmd",
          "type": "blob",
          "size": 1.18359375,
          "content": "# What is Unix?\n\nUnix is an operating system and a set of tools. The tool we will be using the\nmost in this book is a shell, which is a computer program that provides a\ncommand line interface. You have probably seen a command line interface in the\nmovies: an elite computer hacker sits in front of a black screen with green \nglowing text, furiously typing in commands and shouting something like \n\"Spike them!\" Using the command line interface lets you enter lines of code into\na shell (also called a console) and that code instructs your computer to\nperform a specific task. Throughout this book I may use the terms command line,\nshell, and console interchangeably. You will learn about using the command line\nin the Command Line Basics chapter.\n\nThe shell is a very direct and powerful way to manipulate a computer. You\ncan produce wonderful creations that help thousands of people, or you can wreak\nhavoc on yourself and on others. Like\n[Benjamin Parker](https://en.wikipedia.org/wiki/Uncle_Ben) once \nsaid: \"With great power comes great responsibility.\"\n\nThere are several popular shell programs but in this book we'll be using a shell \ncalled Bash because it is the default shell program on Mac and Ubuntu.\n"
        },
        {
          "name": "02-Getting-Unix.Rmd",
          "type": "blob",
          "size": 0.8720703125,
          "content": "# Getting Unix\n\n> An indispensable thing never has much value. - Russian proverb\n\n## Mac & Ubuntu Users\n\nIf you're using a Mac or you're using the Ubuntu operating system find a\nprogram called **Terminal** and open it. You can skip the next section about\nWindows.\n\n## Windows\n\nIf you're using the latest version of Windows 10 you should enable and install\nBash on Ubuntu on Windows. You can find the installation guide from Microsoft\n[here](https://msdn.microsoft.com/en-us/commandline/wsl/install_guide).\n\nIf you don't have the latest version of Windows 10 you should download \n[VirtualBox](https://www.virtualbox.org/) and then set up the latest version of\nUbuntu with VirtualBox. Instructions for doing this tend to change slightly\nover time, so I suggest using Google to search for \"how to install Ubuntu on\nWindows with VirtualBox\" and then you can follow the instructions that you find.\n"
        },
        {
          "name": "03-Command-Line-Basics.Rmd",
          "type": "blob",
          "size": 29.2587890625,
          "content": "# Command Line Basics\n\n> Of a small spark a great fire. - Gaelic proverb\n\n## Hello Terminal!\n\nOnce you have opened up Terminal then you should see a window that \nlooks something like this:\n\n![](images/shell1.png)\n\nWhat you are looking at is the bash shell! Your shell will surely look different \nthan mine, but all bash shells have the same essential parts. As you can see in\nmy shell it says `seans-air:~ sean$`. This string of characters is called the\n**prompt**. You type command line commands after the prompt. The prompt is just\nthere to let you know that the shell is ready for you to type in a command.\nPress `Enter` on your keyboard a few times to see what happens with the prompt.\nYour shell should now look like this:\n\n![](images/shell2.png)\n\nIf you don't type anything after the prompt and you press `Enter` then nothing\nhappens and you get a new prompt under the old prompt. The white rectangle \nafter the prompt is just a cursor that allows you to edit what you have typed\ninto the shell. Your cursor might look like a rectangle, a line, or an\nunderscore, but all cursors behave the same way. After typing something into\nthe command line you can move the cursor back and forth with the left and right\narrow keys, just like you would when typing an email.\n\nNow that we have pressed `Enter` several times our shell looks messy with all of \nthose old prompts! Do not worry, you are about to learn your first shell command \nwhich will clear all of those old prompts from your shell. Type `clear` at the \nprompt and then hit `Enter`. Voila! Your shell now only has the current prompt,\njust like when you first opened the terminal.\n\nEvery command line command is actually a little computer program, even commands\nas simple as `clear`. These commands all tend to have the following structure:\n\n```\n[command] [options] [arguments]\n```\n\nSome simple commands like `clear` do not require any options or arguments.\nOptions are usually preceded by a hyphen (`-`) and they tweak the behavior\nof the command. Arguments can be names of files, raw data, or other options\nthat the command requires. A simple command that has an argument is `echo`.\nThe `echo` command prints a phrase to the console. Enter `echo 'Hello World!'`\ninto the command line to see what happens:\n\n```{r, engine='bash'}\necho 'Hello World!'\n```\n\nWe will be using the above syntax for the rest of the book, where on one line there\nwill be a command that I have entered into the command line, and then below that\ncommand the console output of the command will appear (if there is any\nconsole output). You can use `echo` to print any phrase surrounded by single\nquotes (`''`) to the console.\n\nIf you want to see the last command press the `Up` arrow key. You can press\n`Up` and `Down` in order to scroll through the history of commands that you've\nentered. If you want to re-execute a past command, you can scroll to that\ncommand then press `Enter`. Try getting back to the `echo 'Hello World!'`\ncommand and execute it again.\n\n### Summary\n\n- You type command line commands after the prompt.\n- `clear` will clean up your terminal.\n- `echo` prints text to your terminal.\n- You can scroll through your command history with the `Up` and `Down` arrow\nkeys.\n\n### Exercises\n\n1. Print your name to the terminal.\n2. Clear your terminal after completing #1.\n\n## Navigating the Command Line\n\nYou have learned two command line commands (`clear` and `echo`) which is pretty\ngood! Before you learn more commands we need to discuss how files and folders \nare organized on your computer.\n\nComputers are organized in a hierarchy of folders, where a folder can contain \nmany folders and files. People who use Unix often refer to folders as \ndirectories and these terms are interchangeable. This directory hierarchy forms \na tree, like the diagram below. You can use the command line to navigate these\ntrees on your computer.\n\n![](images/musictree1.png)\n\nAs you can see in the image below, my Debussy directory is contained in my Music \ndirectory. This is the simplest case of how directories are structured.\n\n![](images/musictree2.png)\n\nThe directory structure on most computers is much more complicated, but the \nstructure on your computer probably looks something like this:\n\n![](images/ft1.png)\n\nThere are a few special directories that you should be aware of on your \ncomputer. The directory at the top of this tree is called the root directory. \nThe root directory contains all other directories, and is represented by a \nslash (`/`). The home directory is another special directory which contains your \npersonal files, like your photos, documents, and the contents of your desktop.\nThe tilde (`~`) represents a shorthand for your home directory. \n\nImagine tracing all of the directories from your root directory to the \ndirectory you are currently viewing. This sequence of directories is called a \n**path**. The diagram below illustrates the path from the root \ndirectory to a directory called *sean*. This directory happens to be my home\ndirectory.\n\n![](images/ft2.png)\n\nThis path can be written as `/Users/sean`. Since this is my home directory, We\ncan also use `~` as a shorter way to refer to the same path. We will see this\ndemonstrated soon.\n\nOpen the command line if you closed it. Your shell is always in a directory,\nand the directory that your shell starts in your home directory. Whatever \ndirectory your shell is in is called the **working directory**. Enter the `pwd` command into your shell to **p**rint the **w**orking **d**irectory.\n\n```{r, engine='bash', eval=FALSE}\npwd\n```\n\n```\n## /Users/sean\n```\n\nYou can change your working directory using the `cd` command. If you use the\n`cd` command without any arguments then your working directory is changed\nto your home directory.\n\nEnter `cd` into the command line and then enter `pwd`.\n\n```{r, engine='bash'}\ncd\npwd\n```\n\nYou were in your working directory to start, and by entering `cd` into the\ncommand line you did technically **c**hange **d**irectory, you just changed it\nto your home directory (the directory you were in to begin with). To use `cd` to\nchange your working directory to a directory other than your home directory, you\nneed to provide `cd` with the path to another directory as an argument. You can\nspecify a path as either a path that is **relative** to your current directory,\nor you can specify the **absolute** path to a directory starting from the root\nof your computer. Let's say we simply want to change the working directory to\none of the folders that is inside our home directory. First we need to be able to\nsee which folders are in our working directory. You can list the files and\nfolders in a directory using the `ls` command. Let's use the `ls` command in our\nhome directory to list the files and folders contained within it.\n\n```{r, engine='bash', eval=FALSE}\nls\n```\n\n```\n## Desktop\n## Documents\n## Photos\n## Music\n## todo.txt\n```\n\nIt looks like I have four folders and one text file in my home directory. Now\nlet's switch into the Music directory:\n\n```{r, engine='bash', eval=FALSE}\ncd Music\n```\n\nAs you can see the path to the current working directory has changed:\n\n```{r, engine='bash', eval=FALSE}\npwd\n```\n\n```\n## /Users/sean/Music\n```\n\nI specified a **relative** path when I entered `cd Music`. The path to the \nMusic directory is just `Music/` relative to my previous working directory.\nI can go back to `/Users/sean/` with the command `cd ..` which changes the\nworking directory to the folder above the current working directory:\n\n```{r, engine='bash', eval=FALSE}\ncd ..\npwd\n```\n\n```\n## /Users/sean\n```\n\nNotice that `..` is also a relative path, since it specifies the directory above\nyour current working directory. Similarly `.` is the path to your current\nworking directory. Therefore since my current working directory is `/Users/sean`\nthen `cd Music` is the same as `cd ./Music`.\n\nI can `cd` to any folder as long as I know the **absolute** path to that folder.\nFor example I can `cd` to `/Users/sean/Music` by entering the following into \nthe shell:\n\n```{r, engine='bash', eval=FALSE}\ncd ~/Music\npwd\n```\n\n```\n## /Users/sean/Music\n```\n\nIt does not matter what directory the shell is in since we are using an \nabsolute path. Therefore we can jump straight to a directory as long as we specify\nthe absolute path. Notice above that we used `~` as shortcut for `/Users/sean/`. \n\nOf course you should not expect yourself to have every\nabsolute path on your computer memorized! You can use a terminal feature called\n**tab completion** in order to speed up typing paths and other commands. Enter\nthe following into your shell, and then try pressing the `Tab` key (on some\nmachines you need to press it twice):\n\n```{r, engine='bash', eval=FALSE}\ncd ~/\n```\n\n(press `Tab`)\n\n```\n## Desktop\n## Documents\n## Photos\n## Music\n## todo.txt\n```\n\nPressing tab shows you a list of all files and folders inside of the `~/`\ndirectory. Now I'm going to type `~/D` into my terminal and you can see what\nhappens when I press `Tab` again:\n\n```{r, engine='bash', eval=FALSE}\ncd ~/D\n```\n\n(press `Tab`)\n\n```\n## Desktop\n## Documents\n```\n\nSince I added a \"D\" to the path, only folders with names that start with a \"D\"\nare listed. If I type `cd ~/De` into the console and then press `Tab` then the\ncommand will autocomplete to `cd ~/Desktop/`. If I press `Tab` again, the console\nwill list all of the files and folders on my desktop.\n\nMake sure to pause and try this yourself in your own terminal! You will not have\nthe same files or folders that I do, but you should try using `cd` and tab \ncompletion with directories and files that start with the same letters.\n\n### Summary\n\n- You can identify a specific file or folder by its path.\n- The root directory (`/`) contains all of the folders and files on your\ncomputer.\n- Your home directory (`~`) is the directory where your terminal always starts.\n- Your terminal is always inside of a working directory.\n- When you open your terminal your working directory will be set to the home\ndirectory.\n- Use the `cd` command to **c**hange your working **d**irectory.\n- The `pwd` command will **p**rint the **w**orking **d**irectory.\n- The `ls` command will **l**i**s**t files and folders in a directory.\n\n### Exercises\n\n1. Set your working directory to the root directory.\n2. Set your working directory to your home directory using three different \ncommands.\n3. Find a folder on your computer using your file and folder browser, and then\nset your working directory to that folder using the terminal.\n4. List all of the files and folders in the directory you navigated to in #3.\n\n## Creation and Inspection\n\nNow that you can fluidly use your terminal to bound between directories all\nover your computer, it is time to learn some actions you can perform on folders and\nfiles. One of the first actions you will probably want to take when opening up a\nfresh terminal is to create a new folder or file. You can **m**a**k**e a \n**dir**ectory with the `mkdir` command, followed by the path to the new\ndirectory. First let's look at the contents of my home directory:\n\n```{r, engine='bash', eval=FALSE}\ncd\nls\n```\n\n```\n## Desktop\n## Documents\n## Photos\n## Music\n## todo.txt\n```\n\nLet's create a new directory to store some code files we am going to write\nlater. We can use `mkdir` to create a new directory called `Code`:\n\n```{r, engine='bash', eval=FALSE}\nmkdir Code\nls\n```\n\n```\n## Desktop\n## Documents\n## Photos\n## Music\n## todo.txt\n## Code\n```\n\nIt worked! Notice that the argument `Code` to the command `mkdir` is a relative \npath, however we could have specified an absolute path. In general you should\nexpect Unix tools that take paths as arguments to accept both relative and\nabsolute paths.\n\nThere are a few different ways to create a new file on the command line. The\nmost simple way to create a blank file is to use the `touch` command, followed\nby the path to the file you want to create. In this example we are going to create\na new journal entry using `touch`:\n\n```{r, engine='bash', eval=FALSE}\ntouch journal-2017-01-24.txt\nls\n```\n\n```\n## Desktop\n## Documents\n## Photos\n## Music\n## todo.txt\n## Code\n## journal-2017-01-24.txt\n```\n\nA new file has been created! We have been using `ls` to list the files and folders\nin the current directory, but using `ls` alone does not differentiate between\nwhich of the listed items are folders and which are files. Thankfully you can\nuse the `-l` option with `ls` in order to get a **l**ong listing of files in\na directory.\n\n```{r, engine='bash', eval=FALSE}\nls -l\n```\n\n```\n## drwxr-xr-x  2 sean  staff  68 Jan 24 12:31 Code\n## drwxr-xr-x  2 sean  staff  94 Jan 20 12:44 Desktop\n## drwxr-xr-x  2 sean  staff  24 Jan 20 12:44 Documents\n## drwxr-xr-x  2 sean  staff  68 Jan 20 12:36 Music\n## drwxr-xr-x  2 sean  staff  68 Jan 20 12:35 Photos\n## -rw-r--r--  1 sean  staff  90 Jan 24 11:33 journal-2017-01-24.txt\n## -rw-r--r--  1 sean  staff  70 Jan 24 10:58 todo.txt\n```\n\nThere is a row in the resulting table for each file or folder. If the entry in the\nfirst column is a `d`, then the row in the table corresponds to a **d**irectory,\notherwise the information in the row corresponds to a file. As you can see in my\nhome directory there are five directories and two files. The string of\ncharacters following the `d` in the case of a directory or following the first\n`-` in the case of a file represent the permissions for that file or directory.\nWe will cover permissions in a later section. The columns of this table also show\nwho created the file, the group that the creator of the file belongs to (we will\ncover groups later when we cover permissions), the size of the file, the time\nand date when the file was last modified, and then finally the name of the file.\n\nNow that we have created a file there are a few different ways that we can inspect\nand edit this file. First let's use the `wc` command to view the **w**ord\n**c**ount and other information about the file:\n\n```{r, engine='bash', eval=FALSE}\nwc todo.txt\n```\n\n```\n##       3      14      70 todo.txt\n```\n\nThe `wc` command displays the number of lines in a file followed by the number\nof words and then the number of characters. Since this file looks pretty small\n(only three lines) let's try printing it to the console using the `cat` command.\n\n```{r, engine='bash', eval=FALSE}\ncat todo.txt\n```\n\n```\n## - email Jeff\n## - write letter to Aunt Marie\n## - get groceries for Shabbat\n```\n\nThe `cat` command is often used to print text files to the terminal, despite\nthe fact that it is really meant to con**cat**enate files. You can see this\nconcatenation in action in the following example:\n\n```{r, engine='bash', eval=FALSE}\ncat todo.txt todo.txt\n```\n\n```\n## - email Jeff\n## - write letter to Aunt Marie\n## - get groceries for Shabbat\n## - email Jeff\n## - write letter to Aunt Marie\n## - get groceries for Shabbat\n```\n\nThe `cat` command will combine every text file that is provided as an argument.\n\nLet's take a look at how we could view a larger file. There is a file inside\nthe Documents directory:\n\n```{r, engine='bash', eval=FALSE}\nls Documents\n```\n\n```\n## a-tale-of-two-cities.txt\n```\n\nLet's examine this file to see if it is reasonable to read it with `cat`:\n\n```{r, engine='bash', eval=FALSE}\nwc Documents/a-tale-of-two-cities.txt\n```\n\n```\n##      17    1005    5799 Documents/a-tale-of-two-cities.txt\n```\n\nWow, over 1000 words! If we use `cat` on this file it is liable to take up our\nentire terminal. Instead of using `cat` for this large file we should use\n`less`, which is a program designed for viewing multi-page files. Let's try\nusing `less`:\n\n```{r, engine='bash', eval=FALSE}\nless Documents/a-tale-of-two-cities.txt\n```\n\n```\nI. The Period\n\nIt was the best of times,\nit was the worst of times,\nit was the age of wisdom,\nit was the age of foolishness,\nit was the epoch of belief,\nit was the epoch of incredulity,\nit was the season of Light,\nit was the season of Darkness,\nit was the spring of hope,\nit was the winter of despair,\nwe had everything before us, we had nothing before us, we were all going direct\nDocuments/a-tale-of-two-cities.txt\n```\n\nYou can scroll up and down the file line-by-line using the up and down arrow \nkeys, and if you want to scroll faster you can use the `spacebar` to go to the\nnext page and the `b` key to go to the previous page. In order to quit `less`\nand go back to the prompt press the `q` key.\n\nAs you can see the `less` program is a kind of Unix tool with behavior that we\nhave not seen before because it \"takes over\" your terminal. There are a few\nprograms like this that we will discuss throughout this book.\n\nThere are also two easy to remember programs for glimpsing the beginning or end\nof a text file: `head` and `tail`. Let's quickly use `head` and `tail` on\n`a-tale-of-two-cities.txt`:\n\n```{r, engine='bash', eval=FALSE}\nhead Documents/a-tale-of-two-cities.txt\n```\n\n```\n## I. The Period\n## \n## It was the best of times,\n## it was the worst of times,\n## it was the age of wisdom,\n## it was the age of foolishness,\n## it was the epoch of belief,\n## it was the epoch of incredulity,\n## it was the season of Light,\n## it was the season of Darkness,\n```\n\nAs you can see `head` prints the first ten lines of the file to the terminal.\nYou can specify the number of lines printed with the `-n` option followed by\nthe number of lines you would like to see:\n\n```{r, engine='bash', eval=FALSE}\nhead -n 4 Documents/a-tale-of-two-cities.txt\n```\n\n```\n## I. The Period\n## \n## It was the best of times,\n## it was the worst of times,\n```\n\nThe `tail` program works exactly the same way:\n\n```{r, engine='bash', eval=FALSE}\ntail Documents/a-tale-of-two-cities.txt\n```\n\n```\nof an atrocious murderer, and to-morrow of a wretched pilferer who had robbed a\nfarmer’s boy of sixpence.\nAll these things, and a thousand like them, came to pass in and close upon the\ndear old year one thousand seven hundred and seventy-five. Environed by them,\nwhile the Woodman and the Farmer worked unheeded, those two of the large jaws,\nand those other two of the plain and the fair faces, trod with stir enough,\nand carried their divine rights with a high hand. Thus did the year one\nthousand seven hundred and seventy-five conduct their Greatnesses, and myriads\nof small creatures—the creatures of this chronicle among the rest—along the\nroads that lay before them.\n```\n\nWe have now gone over a few tools for inspecting files, folders, and their\ncontents including `ls`, `wc`, `cat`, `less`, `head`, and `tail`. Before the \nend of this section\nwe should discuss a few more techniques for creating and also editing files. One\neasy way to create a file is using **output redirection**. Output redirection\nstores text that would be normally printed to the command line in a text file.\nYou can use output redirection by typing the greater-than sign (`>`) at the end\nof a command followed by the name of the new file that will contain the output\nfrom the proceeding command. Let's try an example using `echo`:\n\n```{r, engine='bash', eval=FALSE}\necho \"I'm in the terminal.\"\n```\n\n```\n## I'm in the terminal.\n```\n\n```{r, engine='bash', eval=FALSE}\necho \"I'm in the file.\" > echo-out.txt\n```\n\nOnly the first command printed output to the terminal. Let's see if the second\ncommand worked:\n\n```{r, engine='bash', eval=FALSE}\nls\n```\n\n```\n## Desktop\n## Documents\n## Photos\n## Music\n## todo.txt\n## Code\n## journal-2017-01-24.txt\n## echo-out.txt\n```\n\n```{r, engine='bash', eval=FALSE}\ncat echo-out.txt\n```\n\n```\n## I'm in the file.\n```\n\nIt worked! You can also **append** text to the end of a file using\ntwo greater-than signs (`>>`). Let's try this feature out:\n\n```{r, engine='bash', eval=FALSE}\necho \"I have been appended.\" >> echo-out.txt\ncat echo-out.txt\n```\n\n```\n## I'm in the file.\n## I have been appended.\n```\n\nNow for a **word of warning**. Imagine that I want to append another line to \nthe end of `echo-out.txt`, so typed `echo \"A third line.\" > echo-out.txt` into\nthe terminal when really I meant to type `echo \"A third line.\" >> echo-out.txt`\n(notice I used `>` when I meant to use `>>`). Let's see what happens:\n\n```{r, engine='bash', eval=FALSE}\necho \"A third line.\" > echo-out.txt\ncat echo-out.txt\n```\n\n```\n## A third line.\n```\n\nUnfortunately we have unintentionally overwritten what was already contained in\n`echo-out.txt`. There is no undo button in Unix so we will have to live with this\nmistake. This is the first of several lessons demonstrating the damage that you\nshould try to avoid inflicting with Unix. Make sure to take extra care when\nexecuting commands that can modify or delete a file, a typo in the command can\nbe potentially devastating. Thankfully there are a few strategies for protecting\nyourself from mistakes, including managing permissions for files, and tracking\nversions of your files with Git, which we will discuss thoroughly in a later\nchapter.\n\nFinally we should discuss how to edit text files. There are several file editors\nthat are available for your terminal including \n[`vim`](https://en.wikipedia.org/wiki/Vim_(text_editor)) \nand [`emacs`](https://en.wikipedia.org/wiki/Emacs). Entire books have been\nwritten about how to use both of these text editors, and if you are interested\nin one of them you should look for resources online about how to use them. The\none text editor we will discuss using is called `nano`. Just like `less`, `nano`\nuses your entire terminal window. Let's edit `todo.txt` using `nano`:\n\n```{r, engine='bash', eval=FALSE}\nnano todo.txt\n```\n\n```\n  GNU nano 2.0.6                File: todo.txt\n\n- email Jeff\n- write letter to Aunt Marie\n- get groceries for Shabbat\n\n\n\n^G Get Help   ^O WriteOut   ^R Read File  ^Y Prev Page  ^K Cut Text   ^C Cur Pos\n^X Exit       ^J Justify    ^W Where Is   ^V Next Page  ^U UnCut Text ^T To Spell\n```\n\nOnce you have started `nano` you can start editing the text file. The top line of\nthe `nano` editor shows the file you are currently working on, and the bottom two\nlines show a few commands that you can use in `nano`. The caret character (`^`)\nrepresents the `Control` key on your keyboard, so you can for example type\n`Control` + `O` in order to save the changes you have made to the text file, or\n`Control` + `X` in order to exit `nano` and go back to the prompt. \n\n`nano` is a good editor for beginners because it works similarly to word \nprocessors you have used before. You can use the arrow keys in order to move your\ncursor around the file, and the rest of the keys on your keyboard work as\nexpected. Let's add an item to the to-do list and then we will save and exit `nano`\nby typing `Control` + `O` followed by `Control` + `X`.\n\n```\n  GNU nano 2.0.6                File: todo.txt\n\n- email Jeff\n- write letter to Aunt Marie\n- get groceries for Shabbat\n- write final section of \"command line basics\"\n\n\n^G Get Help   ^O WriteOut   ^R Read File  ^Y Prev Page  ^K Cut Text   ^C Cur Pos\n^X Exit       ^J Justify    ^W Where Is   ^V Next Page  ^U UnCut Text ^T To Spell\n```\n\nNow let's quickly check if those changes were saved correctly:\n\n```{r, engine='bash', eval=FALSE}\ncat todo.txt\n```\n\n```\n## - email Jeff\n## - write letter to Aunt Marie\n## - get groceries for Shabbat\n## - write final section of \"command line basics\"\n```\n\nYou can also create new text files with `nano`. Instead of using an existing\npath to a file as the argument to `nano`, use a path to a file that does not\nyet exist and then save your changes to that file.\n\n### Summary\n\n- Use `mkdir` to create new directories.\n- The `touch` command creates empty files.\n- You can use `>` to redirect the output of a command into a file.\n- `>>` will append command output to the end of a file.\n- Print a text file to the command line using `cat`.\n- Inspect properties of a text file with `wc`.\n- Peak at the beginning and end of a text file with `head` and `tail`.\n- Scroll through a large text file with `less`.\n- `nano` is simple text editor.\n\n### Exercises\n\n1. Create a new directory called `workbench` in your home directory.\n2. Without changing directories create a file called `readme.txt` inside of \n`workbench`.\n3. Append the numbers 1, 2, and 3 to `readme.txt` so that each number appears on\nit's own line.\n4. Print `readme.txt` to the command line.\n5. Use output redirection to create a new file in the `workbench` directory called \n`list.txt` which lists the files and folders in your home directory.\n6. Find out how many characters are in `list.txt` without opening the file or\nprinting it to the command line.\n\n## Migration and Destruction\n\nIn this section we will discuss moving, renaming, copying, and deleting files and\nfolders. First let's revisit the contents of our current working directory:\n\n```{r, engine='bash', eval=FALSE}\nls\n```\n\n```\nCode\nDocuments\nPhotos\nDesktop\nMusic\necho-out.txt\njournal-2017-01-24.txt\ntodo.txt\n```\n\nIt's gotten a little sloppy, so let's clean this directory up. First we will\nmake a new directory to store all of the journal entries in called `Journal`. We\nalready know how to do that:\n\n```{r, engine='bash', eval=FALSE}\nmkdir Journal\n```\n\nNow we want to move the journal entry `journal-2017-01-24.txt` into the `Journal`\ndirectory. We can **m**o**v**e it using the `mv` command. `mv` takes two\narguments: first the path to the file or folder that you wish to move followed\nby the destination folder. Let's try using `mv` now:\n\n```{r, engine='bash', eval=FALSE}\nmv journal-2017-01-24.txt Journal\nls\n```\n\n```\nCode\nDocuments\nJournal\nPhotos\nDesktop\nMusic\necho-out.txt\ntodo.txt\n```\n\nLooks like it worked! I just realized however that we should move the `Journal`\ndirectory into the `Documents` folder. Thankfully we can do this with `mv` in\nthe same way:\n\n```{r, engine='bash', eval=FALSE}\nmv Journal Documents\nls\n```\n\n```\nCode\nDocuments\nPhotos\nDesktop\nMusic\necho-out.txt\ntodo.txt\n```\n\nLet's just make sure it ended up in the right place:\n\n```{r, engine='bash', eval=FALSE}\nls Documents\n```\n\n```\nJournal\na-tale-of-two-cities.txt\n```\n\nLooks good! Another hidden use of the `mv` command is that you can use it to\nrename files and folders. The first argument is the path to the folder or file\nthat you want to rename, and the second argument is a path with the new name\nfor the file or folder. Let's rename `todo.txt` so it includes today's date:\n\n```{r, engine='bash', eval=FALSE}\nmv todo.txt todo-2017-01-24.txt\nls\n```\n\n```\nCode\nDocuments\nPhotos\nDesktop\nMusic\necho-out.txt\ntodo-2017-01-24.txt\n```\n\nLooks like it worked nicely. Similar to the `mv` command, the `cp` command\n**c**o**p**ies a file or folder from one location to another. As you can see `cp` is\nused exactly like `mv` when copying files, the file or folder you wish to copy\nis the first argument, followed by the path to the folder where you want the\ncopy to be made:\n\n```{r, engine='bash', eval=FALSE}\ncp echo-out.txt Desktop\nls\n```\n\n```\nCode\nDocuments\nPhotos\nDesktop\nMusic\necho-out.txt\ntodo-2017-01-24.txt\n```\n\n```{r, engine='bash', eval=FALSE}\nls Desktop\n```\n\n```\necho-out.txt\n```\n\nBe aware that there is one difference between copying files and folders, when\ncopying folders you need to specify the `-r` option, which is short for\n*recursive*. This ensures that the underlying directory structure of the\ndirectory you wish to copy remains intact. Let's try copying my `Documents`\ndirectory into the `Desktop` directory:\n\n```{r, engine='bash', eval=FALSE}\ncp -r Documents Desktop\nls Desktop\n```\n\n```\nDocuments\necho-out.txt\n```\n\nFinally, let's discuss how to delete files and folders with the command line.\n**A word of extreme caution:** in general I do not recommend deleting files or\nfolders on the command line because as we have discussed before there is \n***no undo button*** on the command line. If you delete a file that is critical\nto your computer functioning you may cause irreparable damage. I *highly* \nrecommend moving files or folders to a designated trash folder and then deleting\nthem the way you would normally delete files and folders outside of the command\nline (The path to the Trash Bin is `~/.Trash` on Mac and `~/.local/share/Trash`\non Ubuntu). If you decide to delete \na file or folder on your computer make absolutely\nsure that the command you have typed is correct before you press `Enter`. If you do\ndelete a file or folder by accident stop using your computer immediately and\nconsult with a computer professional or your IT department so they can try to\nrecover the file.\n\nNow that you have been warned, let's discuss `rm`, the\n[Avada Kedavra](https://en.wikipedia.org/wiki/Magic_in_Harry_Potter#Unforgivable_Curses)\nof command line programs. When **r**e**m**oving files `rm` only requires the path to a\nfile in order to delete it. Let's test its destructive power on `echo-out.txt`:\n\n```{r, engine='bash', eval=FALSE}\nrm echo-out.txt\nls\n```\n\n```\nCode\nDocuments\nPhotos\nDesktop\nMusic\ntodo-2017-01-24.txt\n```\n\n> I felt a great disturbance in the Force, as if millions of voices suddenly cried out in terror, and were suddenly silenced. - *Obi-wan Kenobi*\n\nThe file `echo-out.txt` is gone forever. Remember when we copied the entire\n`Documents` directory into `Desktop`? Let's get rid of that directory now. Just\nlike when we were using `cp` the `rm` command requires you to use the `-r`\noption when deleting entire directories. Let's test this battle station:\n\n```{r, engine='bash', eval=FALSE}\nls Desktop\n```\n\n```\nDocuments\necho-out.txt\n```\n\n```{r, engine='bash', eval=FALSE}\nrm -r Desktop/Documents\nls Desktop\n```\n\n```\necho-out.txt\n```\n\nNow that the awesome destructive power of `rm` is on your side, you have learned\nthe basics of the command line! See you in the next chapter for a discussion of\nmore advanced command line topics.\n\n### Summary\n\n- `mv` can be used for moving or renaming files or folders.\n- `cp` can copy files or folders.\n- You should try to avoid using `rm` which permanently removes files or folders.\n\n### Exercises\n\n1. Create a file called `message.txt` in your home directory and move it into\nanother directory.\n2. Copy the `message.txt` you just moved into your home directory.\n3. Delete both copies of `message.txt`. Try to do this without using `rm`.\n"
        },
        {
          "name": "04-Working-with-Unix.Rmd",
          "type": "blob",
          "size": 44.2138671875,
          "content": "# Working with Unix\n\n> It is not the knowing that is difficult, but the doing. - Chinese proverb\n\n## Self-Help\n\nEach of the commands that we've discussed so far are thoroughly documented, and\nyou can view their documentation using the `man` command, where the first\nargument to `man` is the command you're curious about. Let's take a look at the\ndocumentation for `ls`:\n\n```{r, engine='bash', eval=FALSE}\nman ls\n```\n\n```\nLS(1)                     BSD General Commands Manual                    LS(1)\n\nNAME\n     ls -- list directory contents\n\nSYNOPSIS\n     ls [-ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1] [file ...]\n\nDESCRIPTION\n     For each operand that names a file of a type other than directory, ls\n     displays its name as well as any requested, associated information.  For\n:\n```\n\nThe controls for navigating `man` pages are the same as they are for `less`.\nI often use `man` pages for quickly searching for an option that I've forgotten.\nLet's say that I forgot how to get `ls` to print a long list. After typing\n`man ls` to open the page, type `/` in order to start a search. Then type the\nword or phrase that you're searching for, in this case type in `long list` and\nthen press `Enter`. The page jumps to this entry:\n\n```\n     -l      (The lowercase letter ``ell''.)  List in long format.  (See below.)\n             If the output is to a terminal, a total sum for all the file sizes is\n             output on a line before the long listing.\n```\n\nPress the `n` key in order to search for the next occurrence of the word, and if\nyou want to go to the previous occurrence type `Shift` + `n`. This method of\nsearching also works with `less`. When you're finished looking at a `man` page\ntype `q` to get back to the prompt.\n\nThe `man` command works wonderfully when you know which command you want to look\nup, but what if you've forgotten the name of the command you're looking for? You\ncan use `apropos` to search all of the available commands and their\ndescriptions. For example let's pretend that I forgot the name of my favorite\ncommand line text editor. You could type `apropos editor` into the command line\nwhich will print a list of results:\n\n```{r, engine='bash', eval=FALSE}\napropos editor\n```\n\n```\n## ed(1), red(1)            - text editor\n## nano(1)                  - Nano's ANOther editor, an enhanced free Pico clone\n## sed(1)                   - stream editor\n## vim(1)                   - Vi IMproved, a programmers text editor\n```\n\nThe second result is `nano` which was just on the tip of my tongue! Both `man`\nand `apropos` are useful when a search is only a few keystrokes away, but if \nyou're looking for detailed examples and explanations you're better off using \na search engine if you have access to a web browser.\n\n### Summary\n\n- Use `man` to look up the documentation for a command.\n- If you can't think of the name of a command use `apropos` to search for a word\nassociated with that command.\n- If you have access to a web browser, using a search engine might be better\nthan `man` or `apropos`.\n\n### Exercises\n\n1. Use `man` to look up the flag for human-readable output from `ls`.\n2. Get help with `man` by typing `man man` into the console.\n3. Wouldn't it be nice if there was a calendar command? Use `apropos` to look\nfor such a command, then use `man` to read about how that command works.\n\n## Get Wild\n\nLet's go into my `Photos` folder in my home directory and take a look around:\n\n```{r, engine='bash', eval=FALSE}\npwd\n```\n\n```\n## /Users/sean\n```\n\n```{r, engine='bash', eval=FALSE}\nls\n```\n\n```\n## Code\n## Documents\n## Photos\n## Desktop\n## Music\n## todo-2017-01-24.txt\n```\n\n```{r, engine='bash', eval=FALSE}\ncd Photos\nls\n```\n\n```\n## 2016-06-20-datasci01.png\n## 2016-06-20-datasci02.png\n## 2016-06-20-datasci03.png\n## 2016-06-21-lab01.jpg\n## 2016-06-21-lab02.jpg\n## 2017-01-02-hiking01.jpg\n## 2017-01-02-hiking02.jpg\n## 2017-02-10-hiking01.jpg\n## 2017-02-10-hiking02.jpg\n```\n\nI've just been dumping pictures and figures into this folder without organizing\nthem at all! Thankfully (in the words of Dr. Jenny Bryan) [I have an unwavering \ncommitment to the ISO 8601 date\nstandard](https://twitter.com/JennyBryan/status/816143967695687684) so at least\nI know when these photos were taken. Instead of using `mv` to move around each\nindividual photo I can select groups of photos using the `*` wildcard. A \n**wildcard** is a character that represents other characters, much like how\njoker in a deck of cards can represent other cards in the deck. Wildcards are\na subset of metacharacters, a topic which we will discuss in detail later on in\nthis chapter. The `*` (\"star\") wildcard represents *zero or more of any\ncharacter*, and it can be used to match names of files and folders in the \ncommand line. For example if I wanted to list all of the files in my Photos \ndirectory which have a name that starts with \"2017\" I could do the following:\n\n```{r, engine='bash', eval=FALSE}\nls 2017*\n```\n\n```\n## 2017-01-02-hiking01.jpg\n## 2017-01-02-hiking02.jpg\n## 2017-02-10-hiking01.jpg\n## 2017-02-10-hiking02.jpg\n```\n\nOnly the files starting with \"2017\" are listed! The command `ls 2017*` literally\nmeans: list the files that start with \"2017\" followed by zero or more of any\ncharacter. As you can imagine using wildcards is a powerful tool for working \nwith groups of files that are similarly named.\n\nLet's walk through a few other examples of using the star wildcard. We could\nonly list the photos starting with \"2016\":\n\n```{r, engine='bash', eval=FALSE}\nls 2016*\n```\n\n```\n## 2016-06-20-datasci01.png\n## 2016-06-20-datasci02.png\n## 2016-06-20-datasci03.png\n## 2016-06-21-lab01.jpg\n## 2016-06-21-lab02.jpg\n```\n\nWe could list only the files with names ending in `.jpg`:\n\n```{r, engine='bash', eval=FALSE}\nls *.jpg\n```\n\n```\n## 2016-06-21-lab01.jpg\n## 2016-06-21-lab02.jpg\n## 2017-01-02-hiking01.jpg\n## 2017-01-02-hiking02.jpg\n## 2017-02-10-hiking01.jpg\n## 2017-02-10-hiking02.jpg\n```\n\nIn the case above the file name can start with a sequence of zero or more of \nany character, but the file name must end in `.jpg`.\nOr we could also list only the first photos from each set of photos:\n\n```{r, engine='bash', eval=FALSE}\nls *01.*\n```\n\n```\n## 2016-06-20-datasci01.png\n## 2016-06-21-lab01.jpg\n## 2017-01-02-hiking01.jpg\n## 2017-02-10-hiking01.jpg\n```\n\nAll of the files above have names that are composed of a sequence of characters,\nfollowed by the adjacent characters `01.`, followed by another sequence of\ncharacters.\nNotice that if I had entered `ls *01*` into the console every file would have\nbeen listed since `01` is a part of all of the file names in my Photos\ndirectory.\n\nLet's organize these photos by year. First let's create one directory for\neach year of photos:\n\n```{r, engine='bash', eval=FALSE}\nmkdir 2016\nmkdir 2017\n```\n\nNow we can move the photos using wildcards:\n\n```{r, engine='bash', eval=FALSE}\nmv 2017-* 2017/\nls\n```\n\n```\n## 2016\n## 2016-06-20-datasci01.png\n## 2016-06-20-datasci02.png\n## 2016-06-20-datasci03.png\n## 2016-06-21-lab01.jpg\n## 2016-06-21-lab02.jpg\n## 2017\n```\n\nNotice that I've moved all files that start with \"2017-\" into the 2017 folder!\nNow let's do the same thing for files with names starting with \"2016-\":\n\n```{r, engine='bash', eval=FALSE}\nmv 2016-* 2016/\nls\n```\n\n```\n## 2016\n## 2017\n```\n\nFinally my photos are somewhat organized! Let's list the files in each directory\njust to make sure all was moved as planned:\n\n```{r, engine='bash', eval=FALSE}\nls 2016/\n```\n\n```\n## 2016-06-20-datasci01.png\n## 2016-06-20-datasci02.png\n## 2016-06-20-datasci03.png\n## 2016-06-21-lab01.jpg\n## 2016-06-21-lab02.jpg\n```\n\n```{r, engine='bash', eval=FALSE}\nls 2017/\n```\n\n```\n## 2017-01-02-hiking01.jpg\n## 2017-01-02-hiking02.jpg\n## 2017-02-10-hiking01.jpg\n## 2017-02-10-hiking02.jpg\n```\n\nLooks good! There are a few more wildcards beyond the star wildcard which we'll\ndiscuss in the next section where searching file names gets a little more\nadvanced.\n\n### Summary\n\n- Wildcards can represent many kinds and numbers of characters.\n- The star wildcard (`*`) represents zero or more of any character.\n- You can use wildcards on the command line in order to work with multiple files\nand folders.\n\n### Exercises\n\n1. Before I organized the photos by year, what command would have listed all of\nthe photos of type `.png`?\n2. Before I organized the photos by year, what command would have deleted all of\nmy hiking photos?\n3. What series of commands would you use in order to put my figures for a data\nscience course and the pictures I took in the lab into their own folders?\n\n## Search\n\n### Regular Expressions\n\nThe ability to search through files and folders can greatly improve your\nproductivity using Unix. First we'll cover searching through text files.\nI recently downloaded a list of the names of the states in the US which you\ncan find [here](http://seankross.com/notes/states.txt). Let's take a look at \nthis file:\n\n```{r, engine='bash', eval=FALSE}\ncd ~/Documents\nls\n```\n\n```\n## canada.txt\n## states.txt\n```\n\n```{r, engine='bash', eval=FALSE}\nwc states.txt\n```\n\n```\n## 50      60     472 states.txt\n```\n\nIt makes sense that there are 50 lines, but it's interesting that there are 60\ntotal words. Let's a take a peak at the beginning of the file:\n\n```{r, engine='bash', eval=FALSE}\nhead states.txt\n```\n\n```\n## Alabama\n## Alaska\n## Arizona\n## Arkansas\n## California\n## Colorado\n## Connecticut\n## Delaware\n## Florida\n## Georgia\n```\n\nThis file looks basically how you would expect it to look! You may recall from\nChapter 3 that the kind of shell that we're using is the bash shell. Bash\ntreats different kinds of data differently, and we'll dive deeper into data\ntypes in Chapter 5. For now all you need to know is that text data are\ncalled **strings**. A string could be a word, a sentence, a book, or a file or \nfolder name. One of the most effective ways to search through strings is to use\n**regular expressions**. Regular expressions are strings that define patterns\nin other strings. You can use regular expressions to search for a sub-string\ncontained within a larger string, or to replace one part of a string with\nanother string.\n\nOne of the most popular tools for searching through text files is `grep`. The\nsimplest use of `grep` requires two arguments: a regular expression and a text\nfile to search. Let's see a simple example of `grep` in action and then I'll\nexplain how it works:\n\n```{r, engine='bash', eval=FALSE}\ngrep \"x\" states.txt\n```\n\n```\n## New Mexico\n## Texas\n```\n\nIn the command above, the first argument to `grep` is the regular expression\n`\"x\"`. The `\"x\"` regular expression represents one instance of the letter \"x\".\nEvery line of the `states.txt` file that contains at least one instance of the\nletter \"x\" is printed to the console. As you can see New Mexico and Texas are\nthe only two state names that contain the letter \"x\". Let's try searching for \nthe letter \"q\" in all of the state names using `grep`:\n\n```{r, engine='bash', eval=FALSE}\ngrep \"q\" states.txt\n```\n\nNothing is printed to the console because the letter \"q\" isn't in any of the\nstate names. We can search for more than individual characters though. For\nexample the following command will search for the state names that contain the\nword \"New\":\n\n```{r, engine='bash', eval=FALSE}\ngrep \"New\" states.txt\n```\n\n```\n## New Hampshire\n## New Jersey\n## New Mexico\n## New York\n```\n\nIn the previous case the regular expression we used was simply `\"New\"`, which\nrepresents an occurrence of the string \"New\". Regular expressions are not\nlimited to just being individual characters or words, they can also represent\nparts of words. For example I could search all of the state names that contain\nthe string \"nia\" with the following command:\n\n```{r, engine='bash', eval=FALSE}\ngrep \"nia\" states.txt\n```\n\n```\n## California\n## Pennsylvania\n## Virginia\n## West Virginia\n```\n\nAll of the state names above happen to end with the string \"nia\".\n\n### Metacharacters\n\nRegular expressions aren't just limited to searching with characters and\nstrings, the real power of regular expressions come from using\n**metacharacters**. Remember that metacharacters are characters that can be used\nto represent other characters. To take full advantage of all of the metacharacters\nwe should use `grep`'s cousin `egrep`, which just extends `grep`'s capabilities.\nIf you're using Ubuntu you should use `grep -P` instead of `egrep` for results\nthat are consistent with this chapter.\nThe first metacharacter we should discuss is the `\".\"` (period) metacharacter, \nwhich represents *any* character. If for example I wanted to search `states.txt` \nfor the character \"i\", followed by any character, followed by the character \"g\" \nI could do so with the following command:\n\n```{r, engine='bash', eval=FALSE}\negrep \"i.g\" states.txt\n```\n\n```\n## Virginia\n## Washington\n## West Virginia\n## Wyoming\n```\n\nThe regular expression \"i.g\" matches the sub-string \"irg\" in V*irg*inia, and\nWest V*irg*inia, and it matches the sub-string \"ing\" in Wash*ing*ton and\nWyom*ing*. The period metacharacter is a stand-in for the \"r\" in \"irg\" and the\n\"n\" in \"ing\" in the example above. The period metacharacter is extremely liberal,\nfor example the command `egrep \".\" states.txt` would return every line of\nstates.txt since the regular expression `\".\"` would match one occurrence of any\ncharacter on every line (there's at least one character on every line). \n\nBesides characters that can represent other\ncharacters, there are also metacharacters called **quantifiers** which allow you\nto specify the number of times a particular regular expression should appear in \na string. One of the most basic quantifiers is `\"+\"` (plus) which represents one \nor more occurrences of the proceeding expression. For example the regular \nexpression \"s+as\" means: one or more \"s\" followed by \"as\". Let's see if any of \nthe state names match this expression:\n\n```{r, engine='bash', eval=FALSE}\negrep \"s+as\" states.txt\n```\n\n```\n## Arkansas\n## Kansas\n```\n\nBoth Arkan*sas* and Kan*sas* match the regular expression `\"s+as\"`. Besides the\nplus metacharacter there's also the `\"*\"` (star) metacharacter which represents\nzero or more occurrences of the preceding expression. Let's see what happens if\nwe change `\"s+as\"` to `\"s*as\"`:\n\n```{r, engine='bash', eval=FALSE}\negrep \"s*as\" states.txt\n```\n\n```\n## Alaska\n## Arkansas\n## Kansas\n## Massachusetts\n## Nebraska\n## Texas\n## Washington\n```\n\nAs you can see the star metacharacter is much more liberal with respect to\nmatching since many more state names are matched by `\"s*as\"`. There are more\nspecific quantifies you can use beyond \"zero or more\" or \"one or more\"\noccurrences of an expression. You can use curly brackets (`{ }`) to specify an\nexact number of occurrences of an expression. For example the regular expression\n`\"s{2}\"` specifies exactly two occurrences of the character \"s\". Let's try using\nthis regular expression:\n\n```{r, engine='bash', eval=FALSE}\negrep \"s{2}\" states.txt\n```\n\n```\n## Massachusetts\n## Mississippi\n## Missouri\n## Tennessee\n```\n\nTake note that the regular expression `\"s{2}\"` is equivalent to the regular\nexpression `\"ss\"`. We could also search for state names that have between two\nand three adjacent occurrences of the letter \"s\" with the regular expression\n`\"s{2,3}\"`:\n\n```{r, engine='bash', eval=FALSE}\negrep \"s{2,3}\" states.txt\n```\n\n```\n## Massachusetts\n## Mississippi\n## Missouri\n## Tennessee\n```\n\nOf course the results are the same because there aren't any states that have \"s\"\nrepeated three times.\n\nYou can use a **capturing group** in order to search for multiple occurrences of\na string. You can create capturing groups within regular expressions by using\nparentheses (`\"( )\"`). For example if I wanted to search states.txt for the\nstring \"iss\" occurring twice in a state name I could use a capturing group and\na quantifier like so:\n\n```{r, engine='bash', eval=FALSE}\negrep \"(iss){2}\" states.txt\n```\n\n```\n## Mississippi\n```\n\nWe could combine more quantifiers and capturing groups to dream up even more\ncomplicated regular expressions. For example, the following regular expression\ndescribes three occurrences of an \"i\" followed by two of any character:\n\n```{r, engine='bash', eval=FALSE}\negrep \"(i.{2}){3}\" states.txt\n```\n\n```\n## Mississippi\n```\n\nThe complex regular expression above still only matches \"Mississippi\".\n\n### Character Sets\n\nFor the next couple of examples we're going to need some text data beyond the\nnames of the states. Let's just create a short text file from the console:\n\n```{r, engine='bash', eval=FALSE}\ntouch small.txt\necho \"abcdefghijklmnopqrstuvwxyz\" >> small.txt\necho \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" >> small.txt\necho \"0123456789\" >> small.txt\necho \"aa bb cc\" >> small.txt\necho \"rhythms\" >> small.txt\necho \"xyz\" >> small.txt\necho \"abc\" >> small.txt\necho \"tragedy + time = humor\" >> small.txt\necho \"http://www.jhsph.edu/\" >> small.txt\necho \"#%&-=***=-&%#\" >> small.txt\n```\n\nIn addition to quantifiers there are also regular expressions for describing\nsets of characters. The `\\w` metacharacter corresponds to all \"word\" characters,\nthe `\\d` metacharacter corresponds to all \"number\" characters, and the `\\s`\nmetacharacter corresponds to all \"space\" characters. Let's take a look at using\neach of these metacharacters on small.txt:\n\n```{r, engine='bash', eval=FALSE}\negrep \"\\w\" small.txt\n```\n\n```\n## abcdefghijklmnopqrstuvwxyz\n## ABCDEFGHIJKLMNOPQRSTUVWXYZ\n## 0123456789\n## aa bb cc\n## rhythms\n## xyz\n## abc\n## tragedy + time = humor\n## http://www.jhsph.edu/\n```\n\n```{r, engine='bash', eval=FALSE}\negrep \"\\d\" small.txt\n```\n\n```\n## 0123456789\n```\n\n```{r, engine='bash', eval=FALSE}\negrep \"\\s\" small.txt\n```\n\n```\n## aa bb cc\n## tragedy + time = humor\n```\n\nAs you can see in the example above, the `\\w` metacharacter matches all letters,\nnumbers, and even the underscore character (`_`). We can see the complement of\nthis grep by adding the `-v` flag to the command:\n\n```{r, engine='bash', eval=FALSE}\negrep -v \"\\w\" small.txt\n```\n\n```\n## #%&-=***=-&%#\n```\n\nThe `-v` flag (which stands for in**v**ert match) makes `grep` return all of the\nlines not matched by the regular expression. Note that the character sets for \nregular expressions also have their inverse sets: `\\W` for non-words, `\\D` for\nnon-digits, and `\\S` for non-spaces. Let's take a look at using `\\W`:\n\n```{r, engine='bash', eval=FALSE}\negrep \"\\W\" small.txt\n```\n\n```\n## aa bb cc\n## tragedy + time = humor\n## http://www.jhsph.edu/\n## #%&-=***=-&%#\n```\n\nThe returned strings all contain non-word characters. Note the difference between\nthe results of using the invert flag `-v` versus using an inverse set regular\nexpression.\n\nIn addition to general character sets we can also create specific character\nsets using square brackets (`[ ]`) and then including the characters we wish to\nmatch in the square brackets. For example the regular expression for the set\nof vowels is `[aeiou]`. You can also create a regular expression for the\ncomplement of a set by including a caret (`^`) in the beginning of a set. For\nexample the regular expression `[^aeiou]` matches all characters that are not\nvowels. Let's test both on small.txt:\n\n```{r, engine='bash', eval=FALSE}\negrep \"[aeiou]\" small.txt\n```\n\n```\n## abcdefghijklmnopqrstuvwxyz\n## aa bb cc\n## abc\n## tragedy + time = humor\n## http://www.jhsph.edu/\n```\n\nNotice that the word \"rhythms\" does not appear in the result (it's the longest\nword without any vowels that I could think of).\n\n```{r, engine='bash', eval=FALSE}\negrep \"[^aeiou]\" small.txt\n```\n\n```\n## abcdefghijklmnopqrstuvwxyz\n## ABCDEFGHIJKLMNOPQRSTUVWXYZ\n## 0123456789\n## aa bb cc\n## rhythms\n## xyz\n## abc\n## tragedy + time = humor\n## http://www.jhsph.edu/\n## #%&-=***=-&%#\n```\n\nEvery line in the file is printed, because every line contains at least one\nnon-vowel! If you want to specify a range of characters you can use a hyphen\n(`-`) inside of the square brackets. For example the regular expression `[e-q]`\nmatches all of the lowercase letters between \"e\" and \"q\" in the alphabet\ninclusively. Case matters when you're specifying character sets, so if you\nwanted to only match uppercase characters you'd need to use `[E-Q]`. To ignore\nthe case of your match you could combine the character sets with the `[e-qE-Q]`\nregex (short for regular expression), or you could use the `-i` flag with `grep`\nto **i**gnore the case. Note that the `-i` flag will work for any provided regular\nexpression, not just character sets. Let's take a look at some examples using\nthe regular expressions that we just described:\n\n```{r, engine='bash', eval=FALSE}\negrep \"[e-q]\" small.txt\n```\n\n```\n## abcdefghijklmnopqrstuvwxyz\n## rhythms\n## tragedy + time = humor\n## http://www.jhsph.edu/\n```\n\n```{r, engine='bash', eval=FALSE}\negrep \"[E-Q]\" small.txt\n```\n\n```\n## ABCDEFGHIJKLMNOPQRSTUVWXYZ\n```\n\n```{r, engine='bash', eval=FALSE}\negrep \"[e-qE-Q]\" small.txt\n```\n\n```\n## abcdefghijklmnopqrstuvwxyz\n## ABCDEFGHIJKLMNOPQRSTUVWXYZ\n## rhythms\n## tragedy + time = humor\n## http://www.jhsph.edu/\n```\n\n### Escaping, Anchors, Odds, and Ends\n\nOne issue you may have thought about during our little exploration of regular\nexpressions is how to search for certain punctuation marks in text considering\nthat those same symbols are used as metacharacters! For example, how would you\nfind a plus sign (`+`) in a line of text since the plus sign is **also** a\nmetacharacter? The answer is simply using a backslash (`\\`) before the plus sign\nin a regex, in order to \"escape\" the metacharacter functionality. Here are a few\nexamples:\n\n```{r, engine='bash', eval=FALSE}\negrep \"\\+\" small.txt\n```\n\n```\n## tragedy + time = humor\n```\n\n```{r, engine='bash', eval=FALSE}\negrep \"\\.\" small.txt\n```\n\n```\n## http://www.jhsph.edu/\n```\n\nThere are three more metacharacters that we should discuss, and two of them come\nas a pair: the caret (`^`), which represents the start of a line, and the dollar\nsign (`$`) which represents the end of line. These \"anchor characters\" only\nmatch the beginning and ends of lines when coupled with other regular\nexpressions. For example, going back to looking at states.txt, I could search\nfor all of the state names that begin with \"M\" with the following command:\n\n```{r, engine='bash', eval=FALSE}\negrep \"^M\" states.txt\n```\n\n```\n## Maine\n## Maryland\n## Massachusetts\n## Michigan\n## Minnesota\n## Mississippi\n## Missouri\n## Montana\n```\n\nOr we could search for all of the states that end in \"s\":\n\n```{r, engine='bash', eval=FALSE}\negrep \"s$\" states.txt\n```\n\n```\n## Arkansas\n## Illinois\n## Kansas\n## Massachusetts\n## Texas\n```\n\nThere's a mnemonic that I love for remembering which metacharacter to use for\neach anchor: \"First you get the **power**, then you get the **money**.\" The\ncaret character is used for exponentiation in many programming languages, so\n\"power\" (`^`) is used for the beginning of a line and \"money\" (`$`) is used for\nthe end of a line.\n\nFinally, let's talk about the \"or\" metacharacter (`|`), which is also called the\n\"pipe\" character. This metacharacter allows you to match either the regex on \nthe right or on the left side of the pipe. Let's take a look at a small example:\n\n```{r, engine='bash', eval=FALSE}\negrep \"North|South\" states.txt\n```\n\n```\n## North Carolina\n## North Dakota\n## South Carolina\n## South Dakota\n```\n\nIn the example above we're searching for lines of text that contain the words\n\"North\" or \"South\". You can also use multiple pipe characters to, for example,\nsearch for lines that contain the words for all of the cardinal directions:\n\n```{r, engine='bash', eval=FALSE}\negrep \"North|South|East|West\" states.txt\n```\n\n```\n## North Carolina\n## North Dakota\n## South Carolina\n## South Dakota\n## West Virginia\n```\n\nJust two more notes on `grep`: you can display the line number that a match\noccurs on using the `-n` flag:\n\n```{r, engine='bash', eval=FALSE}\negrep -n \"t$\" states.txt\n```\n\n```\n## 7:Connecticut\n## 45:Vermont\n```\n\nAnd you can also `grep` multiple files at once by providing multiple file\narguments:\n\n```{r, engine='bash', eval=FALSE}\negrep \"New\" states.txt canada.txt\n```\n\n```\n## states.txt:New Hampshire\n## states.txt:New Jersey\n## states.txt:New Mexico\n## states.txt:New York\n## canada.txt:Newfoundland and Labrador\n## canada.txt:New Brunswick\n```\n\nYou now have the power to do some pretty complicated string searching using\nregular expressions! Imagine you wanted to search for all of the state names \nthat both begin and end with a vowel. Now you can:\n\n```{r, engine='bash', eval=FALSE}\negrep \"^[AEIOU]{1}.+[aeiou]{1}$\" states.txt\n```\n\n```\n## Alabama\n## Alaska\n## Arizona\n## Idaho\n## Indiana\n## Iowa\n## Ohio\n## Oklahoma\n```\n\nI know there a many metacharacters to keep track of here so below I've included\na table with several of the metacharacters we've discussed in this chapter:\n\n| Metacharacter |               Meaning                |\n|--------------:|:-------------------------------------|\n|       .       |            Any Character             |\n|      \\\\w      |                A Word                |\n|      \\\\W      |              Not a Word              |\n|      \\\\d      |               A Digit                |\n|      \\\\D      |             Not a Digit              |\n|      \\\\s      |              Whitespace              |\n|      \\\\S      |            Not Whitespace            |\n|     [def]     |         A Set of Characters          |\n|    [^def]     |           Negation of Set            |\n|     [e-q]     |        A Range of Characters         |\n|       ^       |         Beginning of String          |\n|       $       |            End of String             |\n|      \\\\n      |               Newline                |\n|       +       |       One or More of Previous        |\n|       *       |       Zero or More of Previous       |\n|       ?       |       Zero or One of Previous        |\n|    &#124;     | Either the Previous or the Following |\n|      {6}      |        Exactly 6 of Previous         |\n|    {4, 6}     |     Between 4 and 6 of Previous      |\n|     {4, }     |        4 or more of Previous         |\n\nIf you want to experiment with writing regular expressions before you use them\nI highly recommend playing around with http://regexr.com/.\n\n### `find`\n\nIf you want to find the location of a file or the location of a group of files\nyou can use the `find` command. This command has a specific structure where\nthe first argument is the directory where you want to begin the search, and all\ndirectories contained within that directory will also be searched. The first\nargument is then followed by a flag that describes the method you want to use to\nsearch. In this case we'll only be searching for a file by its name, so we'll\nuse the `-name` flag. The `-name` flag itself then takes an argument, the name\nof the file that you're looking for. Let's go back to the home directory and\nlook for some files from there:\n\n```{r, engine='bash', eval=FALSE}\ncd\npwd\n```\n\n```\n## /Users/sean\n```\n\nLet's start by looking for a file called states.txt:\n\n```{r, engine='bash', eval=FALSE}\nfind . -name \"states.txt\"\n```\n\n```\n## ./Documents/states.txt\n```\n\nRight where we expected it to be! Now let's try searching for all `.jpg` files:\n\n```{r, engine='bash', eval=FALSE}\nfind . -name \"*.jpg\"\n```\n\n```\n## ./Photos/2016-06-21-lab01.jpg\n## ./Photos/2016-06-21-lab02.jpg\n## ./Photos/2017/2017-01-02-hiking01.jpg\n## ./Photos/2017/2017-01-02-hiking02.jpg\n## ./Photos/2017/2017-02-10-hiking01.jpg\n## ./Photos/2017/2017-02-10-hiking02.jpg\n```\n\nGood file hunting out there!\n\n### Summary\n\n- `grep` and `egrep` can be used along with regular expressions to search for\npatterns of text in a file.\n- Metacharacters are used in regular expressions to describe patterns of\ncharacters.\n- `find` can be used to search for the names of files in a directory.\n\n### Exercises\n\n1. Search `states.txt` and `canada.txt` for lines that contain the word \"New\".\n2. Make five text files containing the names of states that don't contain one of\neach of the five vowels.\n3. Download the GitHub repository for this book and find out how many `.html` \nfiles it contains.\n\n## Configure\n\n### History\n\nNear the start of this book we discussed how you can browse the commands\nthat you recently entered into the prompt using the `Up` and `Down` arrow keys.\nBash keeps track of all of your recent commands, and you can browse your command\nhistory two different ways. The commands that we've used since opening our\nterminal can be accessed via the `history` command. Let's try it out:\n\n```{r, engine='bash', eval=FALSE}\nhistory\n```\n\n```\n## ...\n## 48 egrep \"^M\" states.txt\n## 49 egrep \"s$\" states.txt\n## 50 egrep \"North|South\" states.txt\n## 51 egrep \"North|South|East|West\" states.txt\n## 52 egrep -n \"t$\" states.txt\n## 53 egrep \"New\" states.txt canada.txt\n## 54 egrep \"^[AEIOU]{1}.+[aeiou]{1}$\" states.txt\n## 55 cd\n## 56 pwd\n## 57 find . -name \"states.txt\"\n## 58 find . -name \"*.jpg\"\n## 59 history\n```\n\nWe've had our terminal open for a while so there are tons of commands in our\nhistory! Whenever we close a terminal our recent commands are written to the\n`~/.bash_history` file. Let's a take a look at the beginning of this file:\n\n```{r, engine='bash', eval=FALSE}\nhead -n 5 ~/.bash_history\n```\n\n```\n## echo \"Hello World!\"\n## pwd\n## cd\n## pwd\n## ls\n```\n\nLooks like the very first commands we entered into the terminal! Searching your\n`~/.bash_history` file can be particularly useful if you're trying to recall\na command you've used in the past. The `~/.bash_history` file is just a regular\ntext file, so you can search it with `grep`. Here's a simple example:\n\n```{r, engine='bash', eval=FALSE}\ngrep \"canada\" ~/.bash_history\n```\n\n```\n## egrep \"New\" states.txt canada.txt\n```\n\n### Customizing Bash\n\nBesides `~/.bash_history`, another text file in our home directory that we\nshould be aware of is `~/.bash_profile`. The `~/.bash_profile` is a list of\nUnix commands that are run every time we open our terminal, usually with a\ndifferent command on every line. One of the most common commands used in a\n`~/.bash_profile` is the `alias` command, which creates a shorter name for a\ncommand. Let's take a look at a `~/.bash_profile`:\n\n```\nalias docs='cd ~/Documents'\nalias edbp='nano ~/.bash_profile'\n```\n\nThe first `alias` creates a new command `docs`. Now entering `docs` into the\ncommand line is the equivalent of entering `cd ~/Documents` into the comamnd\nline. Let's edit our `~/.bash_profile` with `nano`. If there's anything\nin your `~/.bash_profile` already then start adding lines at the end of the\nfile. Add the line `alias docs='cd ~/Documents'`, then save the file and quit\n`nano`. In order to make the changes to our `~/.bash_profile` take effect we\nneed to run `source ~/.bash_profile` in the console:\n\n```{r, engine='bash', eval=FALSE}\nsource ~/.bash_profile\n```\n\nNow let's try using `docs`:\n\n```{r, engine='bash', eval=FALSE}\ndocs\npwd\n```\n\n```\n## /Users/sean/Documents\n```\n\nIt works! Setting different `alias`es allows you to save time if there are long\ncommands that you use often. In the example `~/.bash_profile` above, the second\nline, `alias edbp='nano ~/.bash_profile'` creates the command `edbp` (**ed**it\n**b**ash **p**rofile) so that you can quickly add `alias`es. Try adding it to\nyour `~/.bash_profile` and take your new command for a spin!\n\nThere are a few other details about the `~/.bash_profile` that are important\nwhen you're writing software which we'll discuss in the Bash Programming\nchapter.\n\n### Summary\n\n- `history` displays what commands we've entered into the console\nsince opening our current terminal.\n- The `~/.bash_history` file lists commands we've used in the past.\n- `alias` creates a command that can be used as a substitute for a longer\ncommand that we use often.\n- The `~/.bash_profile` is a text file that is run every time we start a shell,\nand it's the best place to assign `alias`es.\n\n## Differentiate\n\nIt's important to be able to examine differences between files. First let's\nmake two small simple text files in the Documents directory.\n\n```{r, engine='bash', eval=FALSE}\ncd ~/Documents\nhead -n 4 states.txt > four.txt\nhead -n 6 states.txt > six.txt\n```\n\nIf we want to look at which lines in these files are different we can use the\n`diff` command:\n\n```{r, engine='bash', eval=FALSE}\ndiff four.txt six.txt\n```\n\n```\n## 4a5,6\n## > California\n## > Colorado\n```\n\nOnly the differing lines are printed to the console. We could also compare\ndiffering lines in a side-by-side comparison using `sdiff`:\n\n```{r, engine='bash', eval=FALSE}\nsdiff four.txt six.txt\n```\n\n```\n## Alabama              Alabama\n## Alaska               Alaska\n## Arizona              Arizona\n## Arkansas             Arkansas\n##                    > California\n##                    > Colorado\n```\n\nIn a common situation you might be sent a file, or you might download a file from the \ninternet that comes with code known as a **checksum** or a **hash**. Hashing\nprograms generate a unique code based on the contents of a file. People\ndistribute hashes with files so that we can be sure that the file we think\nwe've downloaded is the genuine file. One way we can prevent malicious\nindividuals from sending us harmful files is to check to make sure the computed\nhash matches the provided hash. \nThere are a few commonly used file hashes but we'll talk about two called MD5\nand SHA-1.\n\nSince hashes are generated based on file contents, then two identical files\nshould have the same hash. Let's test this by making a copy of `states.txt`.\n\n```{r, engine='bash', eval=FALSE}\ncp states.txt states_copy.txt\n```\n\nTo compute the MD5 hash of a file we can use the `md5` command:\n\n```{r, engine='bash', eval=FALSE}\nmd5 states.txt\n```\n\n```\n## MD5 (states.txt) = 8d7dd71ff51614e69339b03bd1cb86ac\n```\n\n```{r, engine='bash', eval=FALSE}\nmd5 states_copy.txt\n```\n\n```\n## MD5 (states_copy.txt) = 8d7dd71ff51614e69339b03bd1cb86ac\n```\n\nAs we expected they're the same! We can compute the SHA-1 hash using the\n`shasum` command:\n\n```{r, engine='bash', eval=FALSE}\nshasum states.txt\n```\n\n```\n## 588e9de7ffa97268b2448927df41760abd3369a9  states.txt\n```\n\n```{r, engine='bash', eval=FALSE}\nshasum states_copy.txt\n```\n\n```\n## 588e9de7ffa97268b2448927df41760abd3369a9  states_copy.txt\n```\n\nOnce again, both copies produce the same hash. Let's make a change to one of the\nfiles, just to illustrate the fact that the hash changes if file contents are\ndifferent:\n\n```{r, engine='bash', eval=FALSE}\nhead -n 5 states_copy.txt > states_copy.txt\nshasum states_copy.txt\n```\n\n```\n## b1c1c805f123f31795c77f78dd15c9f7ac5732d4  states_copy.txt\n```\n\n### Summary\n\n- The `md5` and `shasum` commands use different algorithms to create codes\n(called hashes or checksums) that are unique to the contents of a file.\n- These hashes can be used to ensure that a file is genuine.\n\n## Pipes\n\nOne of the most powerful features of the command line is skilled use of the\n**pipe** (`|`) which you can usually find above the backslash (`\\`) on your\nkeyboard. The pipe allows us to take the output of a command, which would\nnormally be printed to the console, and use it as the input to another command.\nIt's like fitting an actual pipe between the end of one program and connecting\nit to the top of another program!\nLet's take a look at a basic example. We know the `cat` command takes the\ncontents of a text file and prints it to the console:\n\n```{r, engine='bash', eval=FALSE}\ncd ~/Documents\ncat canada.txt\n```\n\n```\n## Nunavut\n## Quebec\n## Northwest Territories\n## Ontario\n## British Columbia\n## Alberta\n## Saskatchewan\n## Manitoba\n## Yukon\n## Newfoundland and Labrador\n## New Brunswick\n## Nova Scotia\n## Prince Edward Island\n```\n\nThis output from `cat canada.txt` will go into our pipe, and we'll attach the\ndispensing end of the pipe to `head`, which we use to look at the first few\nlines of a file:\n\n```{r, engine='bash', eval=FALSE}\ncat canada.txt | head -n 5\n```\n\n```\nNunavut\nQuebec\nNorthwest Territories\nOntario\nBritish Columbia\n```\n\nNotice that this is the same result we would get from `head -n 5 canada.txt`,\nwe just used `cat` to illustrate how the pipe works. The general syntax of the\npipe is \n`[program that produces output] | [program that uses pipe output as input instead of a file]`.\n\nA more common and useful example where we could use the pipe is answering the\nquestion: \"How many US states end in a vowel?\" We could use `grep` and regular\nexpressions to list all of the state names that end with a vowel, then we could\nuse `wc` to count all of the matching state names:\n\n```{r, engine='bash', eval=FALSE}\ngrep \"[aeiou]$\" states.txt | wc -l\n```\n\n```\n## 32\n```\n\nThe pipe can also be used multiple times in one command in order to take\nthe output from one piped command and use it as the input to yet another program!\nFor example we could use three pipes with `ls`, `grep`, and `less` so that we\ncould scroll through the files in our current directory that were created in February:\n\n```{r, engine='bash', eval=FALSE}\nls -al | grep \"Feb\" | less\n```\n\n```\n-rw-r--r--   1 sean  staff   472 Feb 22 13:47 states.txt\n```\n\nRemember you can use the `Q` key to quit `less` and return to the prompt.\n\n### Summary\n\n- The pipe (`|`) takes the output of the program on its left side and directs\nthe output to be the input for the program on its right side.\n\n### Exercises\n\n1. Use pipes to figure out how many US states contain the word \"New.\"\n2. Examine your `~/.bash_history` to try to figure out how many unique commands\nyou've ever used. (You may need to look up how to use the `uniq` and `sort`\ncommands).\n\n## Make\n\nOnce upon a time there were no web browsers, file browsers, start menus, or\nsearch bars. When somebody booted up a computer all they got a was a shell\nprompt, and all of the work they did started from that prompt. Back then people\nstill loved to share software, but there was always the problem of how software\nshould be installed. The `make` program is the best attempt at solving this\nproblem, and `make`'s elegance has carried it so far that it is still in wide\nuse today. The guiding design goal of `make` is that in order to\ninstall some new piece of software one would:\n\n1. Download all of the files required for installation into a directory.\n2. `cd` into that directory.\n3. Run `make`.\n\nThis is accomplished by specifying a file called `makefile`, which describes the\nrelationships between different files and programs. In addition to installing\nprograms, `make` is also useful for creating documents automatically. Let's build\nup a `makefile` that creates a `readme.txt` file which is automatically\npopulated with some information about our current directory.\n\nLet's start by creating a very basic `makefile` with `nano`:\n\n```{r, engine='bash', eval=FALSE}\ncd ~/Documents/Journal\nnano makefile\n```\n\n```\ndraft_journal_entry.txt:\n  touch draft_journal_entry.txt\n```\n\nThe simple `makefile` above illustrates a **rule** which has the\nfollowing general format:\n\n```\n[target]: [dependencies...]\n  [commands...]\n```\n\nIn the simple example we created `draft_journal_entry.txt` is the **target**, a\nfile which is created as the result of the **command(s)**. It's very important\nto note that any commands under a target **must be indented with a `Tab`**. If\nwe don't use `Tab`s to indent the commands then `make` will fail.\nLet's save and close the `makefile`, then we can run the following in the\nconsole:\n\n```{r, engine='bash', eval=FALSE}\nls\n```\n\n```\n## makefile\n```\n\nLet's use the `make` command with the target we want to be \"made\" as the only\nargument:\n\n```{r, engine='bash', eval=FALSE}\nmake draft_journal_entry.txt\n```\n\n```\n## touch draft_journal_entry.txt\n```\n\n```{r, engine='bash', eval=FALSE}\nls\n```\n\n```\n## draft_journal_entry.txt\n## makefile\n```\n\nThe commands that are indented under our definition of the rule for the\n`draft_journal_entry.txt` target were executed, so now `draft_journal_entry.txt`\nexists! Let's try running the same `make` command again:\n\n```{r, engine='bash', eval=FALSE}\nmake draft_journal_entry.txt\n```\n\n```\n## make: 'draft_journal_entry.txt' is up to date.\n```\n\nSince the target file already exists no action is taken, and instead we're\ninformed that the rule for `draft_journal_entry.txt` is \"up to date\" (there's\nnothing to be done).\n\nIf we look at the general rule format we previously sketched out, we can see\nthat we didn't specify any dependencies for this rule. A **dependency** is a\nfile that the target depends on in order to be built. If a dependency has\nbeen updated since the last time `make` was run for a target then the target is\nnot \"up to date.\" This means that the commands for that target will be run the\nnext time `make` is run for that target. This way, the changes to the dependency\nare incorporated into the target. The commands are only run when the dependencies\nchange, or when the target doesn't exist at all, in order to avoid running\ncommands unnecessarily.\n\nLet's update our `makefile` to include a `readme.txt` that is built\nautomatically. First, let's add a table of contents for our journal:\n\n```{r, engine='bash', eval=FALSE}\necho \"1. 2017-06-15-In-Boston\" > toc.txt\n```\n\nNow let's update our `makefile` with `nano` to automatically generate a \n`readme.txt`:\n\n```{r, engine='bash', eval=FALSE}\nnano makefile\n```\n\n```\ndraft_journal_entry.txt:\n  touch draft_journal_entry.txt\n  \nreadme.txt: toc.txt\n  echo \"This journal contains the following number of entries:\" > readme.txt\n  wc -l toc.txt | egrep -o \"[0-9]+\" >> readme.txt\n```\n\nTake note that the `-o` flag provided to `egrep` above extracts the regular\nexpression match from the matching line, so that only the number of lines is\nappended to `readme.txt`. Now let's run `make` with `readme.txt` as the target:\n\n```{r, engine='bash', eval=FALSE}\nmake readme.txt\n```\n\n```\n## echo \"This journal contains the following number of entries:\" > readme.txt\n## wc -l toc.txt | egrep -o \"[0-9]+\" >> readme.txt\n```\n\nNow let's take a look at `readme.txt`:\n\n```{r, engine='bash', eval=FALSE}\ncat readme.txt\n```\n\n```\n## This journal contains the following number of entries:\n## 1\n```\n\nLooks like it worked! What do you think will happen if we run `make readme.txt`\nagain?\n\n```{r, engine='bash', eval=FALSE}\nmake readme.txt\n```\n\n```\n## make: 'readme.txt' is up to date.\n```\n\nYou guessed it: nothing happened! Since the `readme.txt` file still exists and\nno changes were made to any of the dependencies for `readme.txt` (`toc.txt` is\nthe only dependency) `make` doesn't run the commands for the `readme.txt` rule.\nNow let's modify `toc.txt` then we'll try running `make` again.\n\n```{r, engine='bash', eval=FALSE}\necho \"2. 2017-06-16-IQSS-Talk\" >> toc.txt\nmake readme.txt\n```\n\n```\n## echo \"This journal contains the following number of entries:\" > readme.txt\n## wc -l toc.txt | egrep -o \"[0-9]+\" >> readme.txt\n```\n\nLooks like it ran! Let's check readme.txt to make sure.\n\n```{r, engine='bash', eval=FALSE}\ncat readme.txt\n```\n\n```\n## This journal contains the following number of entries:\n## 2\n```\n\nIt looks like `make` successfully updated `readme.txt`! With every change to\n`toc.txt`, running `make readme.txt` will *programmatically* update `readme.txt`.\n\nIn order to simplify the `make` experience, we can create a rule at the top of\nour `makefile` called `all` where we can list all of the files that are built\nby the `makefile`. By adding the `all` target we can simply run `make` without\nany arguments in order to build all of the targets in the `makefile`. Let's \nopen up `nano` and add this rule:\n\n```{r, engine='bash', eval=FALSE}\nnano makefile\n```\n\n```\nall: draft_journal_entry.txt readme.txt\n\ndraft_journal_entry.txt:\n  touch draft_journal_entry.txt\n  \nreadme.txt: toc.txt\n  echo \"This journal contains the following number of entries:\" > readme.txt\n  wc -l toc.txt | egrep -o \"[0-9]+\" >> readme.txt\n```\n\nWhile we have `nano` open let's add another special rule at the end of our\n`makefile` called `clean` which destroys the files created by our `makefile`:\n\n```\nall: draft_journal_entry.txt readme.txt\n\ndraft_journal_entry.txt:\n  touch draft_journal_entry.txt\n  \nreadme.txt: toc.txt\n  echo \"This journal contains the following number of entries:\" > readme.txt\n  wc -l toc.txt | egrep -o \"[0-9]+\" >> readme.txt\n  \nclean:\n  rm draft_journal_entry.txt\n  rm readme.txt\n```\n\nLet's save and close our `makefile` then let's test it out.  First let's clean up\nour repository:\n\n```{r, engine='bash', eval=FALSE}\nmake clean\nls\n```\n\n```\n## rm draft_journal_entry.txt\n## rm readme.txt\n## makefile\n## toc.txt\n```\n\n```{r, engine='bash', eval=FALSE}\nmake\nls\n```\n\n```\n## touch draft_journal_entry.txt\n## echo \"This journal contains the following number of entries:\" > readme.txt\n## wc -l toc.txt | egrep -o \"[0-9]+\" >> readme.txt\n## draft_journal_entry.txt\n## readme.txt\n## makefile\n## toc.txt\n```\n\nLooks like our `makefile` works! The `make` command is extremely powerful, and\nthis section is meant to just be an introduction. For more in-depth reading\nabout `make` I recommend [Karl Broman](https://twitter.com/kwbroman)'s\n[tutorial](http://kbroman.org/minimal_make/) or \n[Chase Lambert](http://chaselambda.com)'s\n[makefiletutorial.com](http://makefiletutorial.com).\n\n### Summary\n\n- `make` is a tool for creating relationships between files and programs, so\nthat files that depend on other files can be automatically rebuilt.\n- `makefiles` are text files that contain a list of rules.\n- Rules are made up of targets (files to be built), commands (a list of bash\ncommands that build the target), and dependencies (files that the target depends\non to be built).\n"
        },
        {
          "name": "05-Bash-Programming.Rmd",
          "type": "blob",
          "size": 63.6474609375,
          "content": "# Bash Programming\n\n> Communities begin by building their kitchen. - French proverb\n\nThe last two chapters have discussed how to use the bash shell. Bash itself is a\nlittle programming language, and this chapter we're going to discuss how you can\nwrite your own computer programs in Bash. Programming in Bash is useful to know\nbecause of how seamlessly it integrates with all of the command line programs\nyou've already learned. By the end of this chapter you should be able to write\nyour own command line tools!\n\nYou can use `nano` to write all of the programs we're going to discuss in this\nchapter, however I recommend using the [Atom](https://atom.io/) text editor\nbecause it's more user friendly.\n\nNow let's create a new file called `math.sh` in the `~/Code/` directory\nand let's open that file with either `nano` or Atom.\n\n```{r, engine='bash', eval=FALSE}\ncd ~/Code/\nnano math.sh\n```\n\nYou should now have a new, clean text file open. Any code block in the following\nchapters that starts with the code (or similar) below should indicate to you\nthat we're working on a particular text file.\n\n```\n#!/usr/bin/env bash\n# File: math.sh\n```\n\nYou do not need to add these lines to your file, though you should type exactly\nwhat I have typed below these lines. **Note**: please type all of the lines out\nfor every program that we're going to write, do not copy and paste. Typing code\nis a little different from typing an email, and you should practice typing the\ncode out yourself as much as possible. Both of these lines start with the pound\nsymbol (`#`) and in the Bash programming language anything that is typed after\na pound symbol is ignored (unless the pound symbol is between curly brackets\n(`{ }`), but that's only in very specific situations). The pound symbol allows\nyou to make **comments** in\nyour code which you can use to annotate code so that another human being who is\nreading your code can understand how your program is designed to function.\n\nIf you're using `nano` or another shell-based text editor you should perhaps\nopen up two terminals, one where you can edit and save the programs you're\nworking on, and one where you can run your programs. One advantage of using Atom\nis that you can keep Atom open in a separate window and then run your programs\nin your terminal window.\n\n## Math\n\nThe Bash programming language can do very basic arithmetic, which we'll\ndemonstrate in this section.\nNow that you have `math.sh` open in your preferred text editor type the following\ninto your text editor:\n\n```\n#!/usr/bin/env bash\n# File: math.sh\n\nexpr 5 + 2\nexpr 5 - 2\nexpr 5 \\* 2\nexpr 5 / 2\n```\n\nSave `math.sh` and then run this script in your shell:\n\n```{r, engine='bash', eval=FALSE}\nbash math.sh\n```\n\n```\n## 7\n## 3\n## 10\n## 2\n```\n\nLet's break down what's going on in the Bash script you just created. Bash\nexecutes programs in order from the first line in your file to the last line.\nThe `expr` command can be used to **evaluate** Bash **expressions**.\nAn expression is just\na valid string of Bash code that, when run, produces a result. The arithmetic\noperators that you're already familiar with for addition (`+`), subtraction\n(`-`), and multiplication (`*`) work like you would expect them to. Notice that\nwhen doing multiplication you need to escape the star character, otherwise\nBash thinks you're trying to create a regular expression! The division operator\n(`/`) does not work as you might expect it to since 5 / 2 = 2.5. Bash does\n**integer division**, which means that the result of dividing one number by\nanother is always rounded down to the nearest integer. Let's take a look at a\nfew examples on the command line:\n\n```{r, engine='bash'}\nexpr 1 / 3\nexpr 10 / 3\nexpr 40 / 21\nexpr 40 / 20\n```\n\nThe other numerical operator you should be aware of that you might not be\nfamiliar with is the modulus operator (`%`). The modulus operator returns the\n**remainder** after integer division. In integer division if A / B = C, and\nA % B = D, then B * C + D = A. Let's take a look at some examples on the command\nline:\n\n```{r, engine='bash', eval=FALSE}\nexpr 1 % 3\nexpr 10 % 3\nexpr 40 % 21\nexpr 40 % 20\n```\n\n```\n## 1\n## 1\n## 19\n## 0\n```\n\nNotice that when one number is completely divisible by another number then the\nresult of the modulus is zero.\n\nIf you want to do more complex math, for example math with fractions and numbers\nwith decimals then I highly suggest combining `echo` and the **b**ench **c**alculator\nprogram called `bc`. Open up a new file called `bigmath.sh` and type in the\nfollowing:\n\n```\n#!/usr/bin/env bash\n# File: bigmath.sh\n\necho \"22 / 7\" | bc -l\necho \"4.2 * 9.15\" | bc -l\necho \"(6.5 / 0.5) + (6 * 2.2)\" | bc -l\n```\n\nSave `bigmath.sh` and then run this script in your shell:\n\n```{r, engine='bash', eval=FALSE}\nbash bigmath.sh\n```\n\n```\n## 3.14285714285714285714\n## 38.430\n## 26.2\n```\n\nYou can pipe any mathematical string to `bc` with the `-l` flag in order to\nuse decimal numbers in your calculations.\n\n### Summary\n\n- Bash programs are executed in order from the first line in a file until the\nlast line.\n- Anything written after a pound sign (`#`) is a comment and is not executed by\nBash.\n- You can do simple arithmetic with the `expr` command.\n- Perform more complicated arithmetic by piping a string expression into `bc`\nusing `echo`.\n\n### Exercises\n\n1. Look at the `man` pages for `bc`.\n2. Try doing some math in `bc` interactively.\n3. Try writing some equations in a file and then provide that file as an\nargument to `bc`.\n\n## Variables\n\nIn Bash you can store data in variables. In chapter 4 we discussed environmental\nvariables that are set by your operating system. You can also create your own\nvariables. Make sure you follow these rules when you're naming variables:\n\n- Every letter should be lowercase.\n- The variable name should start with a letter.\n- The name should only contain alphanumeric characters and underscores (`_`).\n- Words in the name should be separated by underscores.\n\nIf you follow those rules then you can avoid accidentally overwriting data\nstored in environmental variables.\n\nYou can assign data to a variable using the equals sign (`=`). The data you\nstore in a variable can either be a string or a number. Let's create a variable\nnow on the command line:\n\n```{r, engine='bash', eval=FALSE}\nchapter_number=5\n```\n\nThe variable name is on the left hand side of the equals sign, and the data\nwhich will be stored in that variable is on the right hand side of the equals\nsign. Notice that there are no spaces on either side of the equals sign, this\nis not allowed when assigning variables:\n\n```{r, engine='bash', error=TRUE}\nchapter_number = 5\n```\n\nIn order to print the data in a variable, also called the value of a variable,\nwe can use `echo`. When you want to retrieve the value of a variable you must\nuse the dollar sign (`$`) before the name of the variable. Let's try this out:\n\n```{r, engine='bash', eval=FALSE}\necho $chapter_number\n```\n\n```\n## 5\n```\n\nYou can modify the value of a variable using arithmetic operators by using the\n`let` command:\n\n```{r, engine='bash', eval=FALSE}\nlet chapter_number=$chapter_number+1\necho $chapter_number\n```\n\n```\n## 6\n```\n\nYou can also store strings in variables:\n\n```{r, engine='bash'}\nthe_empire_state=\"New York\"\necho $the_empire_state\n```\n\nOccasionally you might want to run a command like you would on the command line\nand store the result of that command in a variable. We can do this by wrapping\nthe command in a dollar sign and parentheses (`$( )`) around a command.\nThis syntax is called **command substitution**. The command is executed and then\ngets replaced by the string that resulted from running the command. For\nexample if we wanted to store the number of lines in `math.sh`:\n\n```{r, engine='bash', eval=FALSE}\nmath_lines=$(cat math.sh | wc -l)\necho $math_lines\n```\n\n```\n## 7\n```\n\nVariable names with a dollar sign can also be used inside other strings in\norder to insert the value of the variable into the string:\n\n```{r, engine='bash', eval=FALSE}\necho \"I went to school in $the_empire_state.\"\n```\n\n```\n## I went to school in New York.\n```\n\nWhen writing a Bash script, the script gives you a few variables for free. Let's\ncreate a new file called `vars.sh` with the following code:\n\n```\n#!/usr/bin/env bash\n# File: vars.sh\n\necho \"Script arguments: $@\"\necho \"First arg: $1. Second arg: $2.\"\necho \"Number of arguments: $#\"\n```\n\nNow let's try running the script a few times in a few different ways:\n\n```{r, engine='bash', eval=FALSE}\nbash vars.sh\n```\n\n```\n## Script arguments:\n## First arg: . Second arg: .\n## Number of arguments: 0\n```\n\n```{r, engine='bash', eval=FALSE}\nbash vars.sh red\n```\n\n```\n## Script arguments: red\n## First arg: red. Second arg: .\n## Number of arguments: 1\n```\n\n```{r, engine='bash', eval=FALSE}\nbash vars.sh red blue\n```\n\n```\n## Script arguments: red blue\n## First arg: red. Second arg: blue.\n## Number of arguments: 2\n```\n\n```{r, engine='bash', eval=FALSE}\nbash vars.sh red blue green\n```\n\n```\n## Script arguments: red blue green\n## First arg: red. Second arg: blue.\n## Number of arguments: 3\n```\n\nYour script can accept arguments just like a command line program! The first\nargument to your script is stored in `$1`, the second argument is stored in\n`$2`, etc, etc. An array of all of the arguments passed to your script is stored\nin `$@`, and we'll discuss how to handle arrays later on in this chapter. The\ntotal number of arguments passed to your script is stored in `$#`. Now that you\nknow how to pass arguments to your scripts you can start writing your own command\nline tools!\n\n### Summary\n\n- Variables can be assigned with the equal sign (`=`) operator.\n- Strings or numbers can be assigned to variables.\n- The value of a variable can be accessed with the dollar sign (`$`) before the\nvariable name.\n- You can use the dollar sign and parentheses syntax (command substitution) to\nexecute a command and save the output in a variable.\n- You can access command line arguments within your own scripts using the dollar\nsign followed by the number of the argument.\n\n### Exercises\n\n1. Write a Bash program where you assign two numbers to different variables,\nand then the program prints the sum of those variables.\n2. Write another Bash program where you assign two strings to different\nvariables, and then the program prints both of those strings. Write a version\nwhere the strings are printed on the same line, and a version where the strings\nare printed on different lines.\n3. Write a Bash program that prints the number of arguments provided to that\nprogram multiplied by the first argument provided to the program.\n\n## User Input\n\nIf you're making Bash programs for you or for others to use one way you can get\nuser input is to specify arguments for users to provide to your program, as we\ndiscussed in the previous section. You could also ask users to type in a string\non the command line by temporarily stopping the execution of your program using\nthe `read` command. Let's write a small script where you can see how the read\ncommand works:\n\n```\n#!/usr/bin/env bash\n# File: letsread.sh\n\necho \"Type in a string and then press Enter:\"\nread response\necho \"You entered: $response\"\n```\n\nNow let's run this script:\n\n```{r, engine='bash', eval=FALSE}\nbash letsread.sh\n```\n\n```\n## Type in a string and then press Enter:\n##\n```\n\nLet's type `Hello!` into the console, then press enter:\n\n```\n## Type in a string and then press Enter:\n## Hello!\n## You entered: Hello!\n```\n\nThe `read` command prompts the user to type in a string, and the string that the\nuser provides is stored in the variable that is given to the `read` command in\nthe script.\n\n### Summary\n\n- `read` stores a string that the user provides in a variable.\n\n### Exercises\n\n1. Write a script that asks the user for an adjective, a noun, and a verb, and\nthen use those words in a sentence (like [Mad Libs](https://en.wikipedia.org/wiki/Mad_Libs)).\n\n## Logic and If/Else\n\n### Conditional Execution\n\nWhen writing computer programs it is often useful for your program to be able to\nmake decisions based on inputs like arguments, files, and environmental\nvariables. Bash provides mechanisms for creating **logical expressions** which\nresemble mathematical equations. These logical expressions can be evaluated\nuntil they are either true or false. In fact, `true` and `false` are both simple\nBash commands! Let's try them both out now:\n\n```{r, engine='bash', eval=FALSE}\ntrue\nfalse\n```\n\nAt first it doesn't look like they do much. In order to see how they work, we're\ngoing to need to look under the hood of Unix a little bit. Whenever you execute\na program on the command line, in general one of two things will happen: either\nthe command is executed successfully, or there's an error. In terms of errors\nthere are many ways that a program can go wrong, and Unix can take different\nactions depending on what kind of error occurs. For example if I enter the name\nof a command that does not exist into the terminal, then I'll see an error:\n\n```{r, engine='bash', error=TRUE}\nthis_command_does_not_exist\n```\n\nSince that command does not exist, it creates a specific kind of error which is\nindicated by the program's **exit status**. The exit status of a program is an\ninteger which indicates whether the program was executed successfully or if\nan error occurred.\nThe exit status of the last program run is stored in the question mark\nvariable (`$?`). We can take a look at the exit status of the last program with\n`echo`:\n\n```{r, engine='bash', eval=FALSE}\necho $?\n```\n\n```\n## 127\n```\n\nThis particular exit status made an indication to the shell that it should\nprint an error message to the console. What's the exit status of a program that\nruns successfully? Let's take a look:\n\n```{r, engine='bash', eval=FALSE}\necho I will succeed.\necho $?\n```\n\n```\n## I will succeed.\n## 0\n```\n\nSo the exit status of a successful program is 0. Now let's take a look at the\nexit statuses of `true` and `false`:\n\n```{r, engine='bash'}\ntrue\necho $?\nfalse\necho $?\n```\n\nAs you can see `true` has an exit status of 0 and `false` has an exit status of\n1. Since these programs don't do much else, you could define `true` as a program\nthat always has an exit status of 0 and `false` as a program that always has an\nexit status of 1.\n\nKnowing the exit status of these programs is important when discussing the\n**logical operators**: the AND operator (`&&`) and the OR operator (`||`). The\nAND and OR operators can be used for conditional execution of programs on the\ncommand line. Conditional execution occurs when the execution of one program\ndepends on the exit status of another program. For example in the case of the\nAND operator, the program on the right hand side of `&&` will only be executed\nif the program on the left hand side of `&&` has an exit status of 0. Let's\ntake a look at some small examples:\n\n```{r, engine='bash', error=TRUE}\ntrue && echo \"Program 1 was executed.\"\nfalse && echo \"Program 2 was executed.\"\n```\n\nSince `false` has an exit status of 1, the program `echo \"Program 2 was executed.\"`\nis not executed, so nothing is printed to the console for that command.\nSeveral AND operators can be chained together like so:\n\n```{r, engine='bash', error=TRUE}\nfalse && true && echo Hello\necho 1 && false && echo 3\necho Athos && echo Porthos && echo Aramis\n```\n\nIn a series of programs joined together by AND operators, any programs to the\nright of a program that has a non-zero exit status is not executed.\n\nThe OR operator (`||`) follows a similar set of principles. Commands on the right\nhand side of `||` are only executed if the command on the left hand side *fails*\nand therefore has an exit status other than 0. Let's take a look at how this\nworks:\n\n```{r, engine='bash', error=TRUE}\ntrue || echo \"Program 1 was executed.\"\nfalse || echo \"Program 2 was executed.\"\n```\n\nOnly `echo \"Program 2 was executed.\"` runs because `false` has a non-zero exit\nstatus. You can combine multiple OR operators so that only the first program\nwith an exit status of 0 is executed:\n\n```{r, engine='bash', error=TRUE}\nfalse || echo 1 || echo 2\necho 3 || false || echo 4\necho Athos || echo Porthos || echo Aramis\n```\n\nYou can combine AND and OR operators in commands, which are evaluated from left\nto right:\n\n```{r, engine='bash', error=TRUE}\necho Athos || echo Porthos && echo Aramis\necho Gaspar && echo Balthasar || echo Melchior\n```\n\nBy combining AND and OR operators you can precisely control the conditions for\nwhen certain commands should be executed.\n\n### Conditional Expressions\n\nEnabling your Bash script to make decisions is extremely useful. Conditional\nexecution allows you to control the circumstances where certain programs are\nexecuted based on whether those programs succeed or fail, but you can also\nconstruct **conditional expressions** which are logical statements that are\neither equivalent to `true` or `false`. Conditional expressions either compare\ntwo values, or they ask a question about one value. Conditional expressions are\nalways between double brackets (`[[ ]]`), and they either use **logical flags**\nor **logical operators**. For example, there are several logical flags you could\nuse for comparing two integers. If we wanted to see if one integer was greater\nthan another we could use `-gt`, the **g**reater **t**han flag. Enter this\nsimple conditional expression into the command line:\n\n```{r, engine='bash', error=TRUE}\n[[ 4 -gt 3 ]]\n```\n\nThe logical expression above is asking: Is 4 greater than 3? No result is\nprinted to the console so let's check the exit status of that expression.\n\n```{r, engine='bash', eval=FALSE}\necho $?\n```\n\n```\n## 0\n```\n\nIt looks like the exit status of this program is 0, the same exit status as\n`true`. This conditional expression is saying that `[[ 4 -gt 3 ]]` is equivalent\nto `true`, which of course we know is logically consistent, 4 is in fact greater\nthan 3! Let's see what happens if we flip the expression around so we're asking\nif 3 is greater than 4:\n\n```{r, engine='bash', error=TRUE}\n[[ 3 -gt 4 ]]\n```\n\nAgain, nothing is printed to the console so we'll look at the exit status:\n\n```{r, engine='bash', eval=FALSE}\necho $?\n```\n\n```\n## 1\n```\n\nAh-ha! Obviously 3 is not greater than 4, so this false logical expression\nresulted in an exit status of 1, which is the same exit status as `false`!\nBecause they have the same exit status `[[ 3 -gt 4 ]]` and `false` are\nessentially equivalent. To quickly test the logical value of a conditional\nexpression, we can use the AND and OR operators so that an expression will\nprint \"t\" if it's true and \"f\" if its false:\n\n```{r, engine='bash', error=TRUE}\n[[ 4 -gt 3 ]] && echo t || echo f\n[[ 3 -gt 4 ]] && echo t || echo f\n```\n\nThis is a little trick you can use to quickly look at the resulting value of a\nlogical expression.\n\nThese **binary** logical expressions compare two values, but there are also\n**unary** logical expressions that only look at one value. For example, you can\ntest whether or not a file exists using the `-e` logical flag. Let's take a look\nat this flag in action:\n\n```{r, engine='bash', eval=FALSE}\ncd ~/Code\n[[ -e math.sh ]] && echo t || echo f\n```\n\n```\n## t\n```\n\nAs you can see the file `math.sh` exists! Most of the time when you're writing\nbash scripts you won't be comparing two raw values or trying to find something\nout about one raw value, instead you'll want to create a logical statement\nabout a value contained in a variable. Variables behave just like raw values in\nlogical expressions. Let's take a look at a few examples:\n\n```{r, engine='bash', error=TRUE}\nnumber=7\n[[ $number -gt 3 ]] && echo t || echo f\n[[ $number -gt 10 ]] && echo t || echo f\n[[ -e $number ]] && echo t || echo f\n```\n\nAs you can see 7 is greater than 3 though it is not greater than 10, and there\nis not file in this directory called `7`. There are several other varieties of\nlogical flags, and you can find a table of several of these flags below.\n\n| Logical Flag | Meaning | Usage |\n|:-------------|:--------|:------|\n| -gt | **G**reater **T**han | `[[ $planets -gt 8 ]]` |\n| -ge | **G**reater Than or **E**qual To | `[[ $votes -ge 270 ]]` |\n| -eq | **Eq**ual | `[[ $fingers -eq 10 ]]` |\n| -ne | **N**ot **E**qual | `[[ $pages -ne 0 ]]` |\n| -le | **L**ess Than or **E**qual To | `[[ $candles -le 9 ]]` |\n| -lt | **L**ess **T**han | `[[ $wives -lt 2 ]]` |\n| -e | A File **E**xists | `[[ -e $taxes_2016 ]]` |\n| -d | A **D**irectory Exists | `[[ -d $photos ]]` |\n| -z | Length of String is **Z**ero | `[[ -z $name ]]` |\n| -n | Length of String is **N**on-Zero | `[[ -n $name ]]` |\n\nTry using each of these flags on the command line before moving on to the next\nsection.\n\nIn addition to logical flags there are also logical operators. One of the most\nuseful logical operators is the regex match operator `=~`. The regex match\noperator compares a string to a regular expression and if the string is a match\nfor the regex then the expression is equivalent to `true`, otherwise it's\nequivalent to `false`. Let's test this operator a couple different ways:\n\n```{r, engine='bash', error=TRUE}\n[[ rhythms =~ [aeiou] ]] && echo t || echo f\nmy_name=sean\n[[ $my_name =~ ^s.+n$ ]] && echo t || echo f\n```\n\nThere's also the NOT operator `!`, which inverts the value of any conditional\nexpression. The NOT operator turns true expressions into false expressions and\nvice-versa. Let's take a look at a few examples using the NOT operator:\n\n```{r, engine='bash', error=TRUE}\n[[ 7 -gt 2 ]] && echo t || echo f\n[[ ! 7 -gt 2 ]] && echo t || echo f\n[[ 6 -ne 3 ]] && echo t || echo f\n[[ ! 6 -ne 3 ]] && echo t || echo f\n```\n\nHere's a table of some of the useful logical operators in case you need to\nreference how they're used later:\n\n| Logical Operator | Meaning | Usage |\n|:-------------|:--------|:------|\n| =~ | Matches Regular Expression | `[[ $consonants =~ [aeiou] ]]` |\n| = | String Equal To | `[[ $password = \"pegasus\" ]]` |\n| != | String Not Equal To | `[[ $fruit != \"banana\" ]]` |\n| ! | Not | `[[ ! \"apple\" =~ ^b ]]` |\n\n### If and Else\n\nConditional expressions are powerful because you can use them to control how a\nBash program that you're writing is executed. One of the fundamental constructs\nin Bash programming is the **IF statement**. Code written inside of an IF\nstatement is only executed *if* a certain condition is true, otherwise the code\nis skipped. Let's write a small program with an IF statement:\n\n```\n#!/usr/bin/env bash\n# File: simpleif.sh\n\necho \"Start program\"\n\nif [[ $1 -eq 4 ]]\nthen\n  echo \"You entered $1\"\nfi\n\necho \"End program\"\n```\n\nFirst this program will print \"Start program\", then the IF statement will check\nif the conditional expression `[[ $1 -eq 4 ]]` is true. It will only be true if\nyou provide `4` as the first argument to the script. If the conditional\nexpression if true then it will execute the code in between `then` and `fi`,\notherwise it will skip over that code. Finally the program will print\n\"End program.\"\n\nLet's try running this Bash program a few different ways. First we'll run this\nprogram with no arguments:\n\n```{r, engine='bash', eval=FALSE}\nbash simpleif.sh\n```\n\n```\n## Start program\n## End program\n```\n\nSince we didn't provide any arguments to `simpleif.sh` the code within the IF\nstatement was skipped! Now let's try providing an argument to this script:\n\n```{r, engine='bash', eval=FALSE}\nbash simpleif.sh 77\n```\n\n```\n## Start program\n## End program\n```\n\nWe provided the argument `77`, however 77 is not equal to 4, therefore the code\nwithin the IF statement was once again skipped. Finally let's provide `4` as an\nargument:\n\n```{r, engine='bash', eval=FALSE}\nbash simpleif.sh 4\n```\n\n```\n## Start program\n## You entered 4\n## End program\n```\n\nIt worked! Since the first argument to this script was `4`, and 4 is equal to 4,\nthe code within the IF statement was executed. You can pair IF statements with\nELSE statements. An ELSE statement only runs if the conditional expression being\nevaluated by the IF statement is false. Let's create a simple program that uses\nan ELSE statement:\n\n```\n#!/usr/bin/env bash\n# File: simpleifelse.sh\n\necho \"Start program\"\n\nif [[ $1 -eq 4 ]]\nthen\n  echo \"Thanks for entering $1\"\nelse\n  echo \"You entered: $1, not what I was looking for.\"\nfi\n\necho \"End program\"\n```\n\nNow let's try running this program a few different ways:\n\n```{r, engine='bash', eval=FALSE}\nbash simpleifelse.sh 4\n```\n\n```\n## Start program\n## Thanks for entering 4\n## End program\n```\n\nThe conditional expression `[[ $1 -eq 4 ]]` was true so code inside of the IF\nstatement was run and the code in the ELSE statement was not run. What do you\nthink will happened when we make the conditional expression false?\n\n```{r, engine='bash', eval=FALSE}\nbash simpleifelse.sh 3\n```\n\n```\n## Start program\n## You entered: 3, not what I was looking for.\n## End program\n```\n\nThe conditional expression `[[ $1 -eq 4 ]]` was false so code inside of the ELSE\nstatement was run and the code in the IF statement was not run.\n\nBetween IF and ELSE statements you can also have ELIF statements. These\nstatements act like IF statements except they're only evaluated if preceding\nIF and ELIF statements have all evaluated false conditional expressions. Let's\ncreate a brief program using ELIF:\n\n```\n#!/usr/bin/env bash\n# File: simpleelif.sh\n\nif [[ $1 -eq 4 ]]\nthen\n  echo \"$1 is my favorite number\"\nelif [[ $1 -gt 3 ]]\nthen\n  echo \"$1 is a great number\"\nelse\n  echo \"You entered: $1, not what I was looking for.\"\nfi\n```\n\nFirst let's run the program with `4` as the first argument:\n\n```{r, engine='bash', eval=FALSE}\nbash simpleelif.sh 4\n```\n\n```\n## 4 is my favorite number\n```\n\nThe condition in the IF statement was true, so only the first `echo` command was\nexecuted. Now let's run the program with `5` as the first argument:\n\n```{r, engine='bash', eval=FALSE}\nbash simpleelif.sh 5\n```\n\n```\n## 5 is a great number\n```\n\nThe first condition is false since 5 is not equal to 4, but then the next\ncondition in the ELIF statement is true since 5 is greater than 3, so that\necho command is executed and the rest of the statement is skipped. Try to guess\nwhat will happen if we use `2` as an argument:\n\n```{r, engine='bash', eval=FALSE}\nbash simpleelif.sh 2\n```\n\n```\n## You entered: 2, not what I was looking for.\n```\n\nSince 2 is neither equal to 4 nor greater than 3, the code in the ELSE statement\nis executed.\n\nYou should also know that you can combine conditional execution, conditional\nexpressions, and IF/ELIF/ELSE statements. The conditional execution operators\nAND (`&&`) and OR (`||`) can be used in an IF or ELIF statement. Let's look at\nan example using these operators in an IF statement:\n\n```\n#!/usr/bin/env bash\n# File: condexif.sh\n\nif [[ $1 -gt 3 ]] && [[ $1 -lt 7 ]]\nthen\n  echo \"$1 is between 3 and 7\"\nelif [[ $1 =~ \"Jeff\" ]] || [[ $1 =~ \"Roger\" ]] || [[ $1 =~ \"Brian\" ]]\nthen\n  echo \"$1 works in the Data Science Lab\"\nelse\n  echo \"You entered: $1, not what I was looking for.\"\nfi\n```\nNow let's test this script with a few different arguments:\n\n```{r, engine='bash', eval=FALSE}\nbash condexif.sh 2\nbash condexif.sh 4\nbash condexif.sh 6\nbash condexif.sh Jeff\nbash condexif.sh Brian\nbash condexif.sh Sean\n```\n\n```\n## You entered: 2, not what I was looking for.\n## 4 is between 3 and 7\n## 6 is between 3 and 7\n## Jeff works in the Data Science Lab\n## Brian works in the Data Science Lab\n## You entered: Sean, not what I was looking for.\n```\n\nThe conditional execution operators work just like they would on the command\nline. If the entire conditional expression evaluates to the equivalent of `true`\nthen the code within the IF statement is executed, otherwise it is skipped.\n\nFinally we should note that IF/ELIF/ELSE statements can be nested inside of\nother IF statements. Here's a small example of a program with nested statements:\n\n```\n#!/usr/bin/env bash\n# File: nested.sh\n\nif [[ $1 -gt 3 ]] && [[ $1 -lt 7 ]]\nthen\n  if [[ $1 -eq 4 ]]\n  then\n  \techo \"four\"\n  elif [[ $1 -eq 5 ]]\n  then\n  \techo \"five\"\n  else\n  \techo \"six\"\n  fi\nelse\n  echo \"You entered: $1, not what I was looking for.\"\nfi\n```\n\nNow let's run it a few times:\n\n```{r, engine='bash', eval=FALSE}\nbash nested.sh 2\nbash nested.sh 4\nbash nested.sh 6\n```\n\n```\n## You entered: 2, not what I was looking for.\n## four\n## six\n```\n\nIn order to get to the inner IF statement, the conditions for the outer IF\nstatement must be met first (the first argument for the script must be between\n3 and 7). As you can see combining variables, arguments, conditional\nexpressions, and IF statements allow you to write more powerful Bash programs.\n\n\n### Summary\n\n- All Bash programs have an exit status. `true` has an exit status of 0 and\n`false` has an exit status of 1.\n- Conditional execution uses two operators: AND (`&&`) and OR (`||`) which you\ncan use to control what command get executed based on their exit status.\n- Conditional expressions are always in double brackets (`[[ ]]`). They have\nan exit status of 0 if they contain a true assertion or 1 if they contain\na false assertion.\n- IF statements evaluate conditional expressions. If an expression is true then\nthe code within an IF statement is executed, otherwise it is skipped.\n- ELIF and ELSE statements also help control the flow of a Bash program, and IF\nstatements can be nested within other IF statements.\n\n### Exercises\n\n1. Write a Bash script that takes a string as an argument and prints\n\"how proper\" if the string starts with a capital letter.\n2. Write a Bash script that takes one argument and prints \"even\" if the first\nargument is an even number or \"odd\" if the first argument is an odd number.\n3. Write a Bash script that takes two arguments. If both arguments are numbers,\nprint their sum, otherwise just print both arguments.\n4. Write a Bash script that prints \"Thank Moses it's Friday\" if today is Friday.\n(Hint: take a look at the `date` program).\n\n## Arrays\n\nArrays in Bash are ordered lists of values. You can create a list from scratch\nby assigning it to a variable name. Lists are created with parentheses (`( )`)\nwith a space separating each element in the list. Let's make a list of the\nplagues of Egypt:\n\n```{r, engine='bash', eval=FALSE}\nplagues=(blood frogs lice flies sickness boils hail locusts darkness death)\n```\n\nTo retrieve the array you need to use **parameter expansion**, which involves\nthe dollar sign and curly brackets (`${ }`). The positions of the elements in\nthe array are numbered starting from zero. To get the first element of this\narray use `${plagues[0]}` like so:\n\n```{r, engine='bash', eval=FALSE}\necho ${plagues[0]}\n```\n\n```\n## blood\n```\n\nNotice that the first element has an **index** of 0. You can get any of the\nelements this way, for example the fourth element:\n\n```{r, engine='bash', eval=FALSE}\necho ${plagues[3]}\n```\n\n```\n## flies\n```\n\nTo get all of the elements of `plagues` use a star (`*`) between the square\nbrackets:\n\n```{r, engine='bash', eval=FALSE}\necho ${plagues[*]}\n```\n\n```\n## blood frogs lice flies sickness boils hail locusts darkness death\n```\n\nYou can also change an individual elements in the array by specifying their\nindex with square brackets:\n\n```{r, engine='bash', eval=FALSE}\necho ${plagues[*]}\nplagues[4]=disease\necho ${plagues[*]}\n```\n\n```\n## blood frogs lice flies sickness boils hail locusts darkness death\n## blood frogs lice flies disease boils hail locusts darkness death\n```\n\nTo get only part of an array you have to specify the index you would like to\nstart at, followed by the number of elements you would like to retrieve from the\narray, separated by colons:\n\n```{r, engine='bash', eval=FALSE}\necho ${plagues[*]:5:3}\n```\n\n```\n## boils hail locusts\n```\n\nThe above query essentially says: get 3 array elements starting from the sixth\nelement of the array (remember, the sixth element has an index of 5).\n\nYou can find the length of an array using the pound sign (`#`):\n\n```{r, engine='bash', eval=FALSE}\necho ${#plagues[*]}\n```\n\n```\n## 10\n```\n\nYou can use the plus-equals operator (`+=`) to add an array onto the end of\nan array array:\n\n```{r, engine='bash'}\ndwarfs=(grumpy sleepy sneezy doc)\necho ${dwarfs[*]}\ndwarfs+=(bashful dopey happy)\necho ${dwarfs[*]}\n```\n\n### Summary\n\n- Arrays are a linear data structure with ordered elements which can be stored\nin variables.\n- The each element of an array has an index and the first index is 0.\n- Individual elements of an array can be accessed using their index.\n\n### Exercises\n\n1. Write a bash script where you define an array inside of the script, and the\nfirst argument for the script indicates the index of the array element that is\nprinted to the console when the script is run.\n2. Write a bash script where you define two arrays inside of the script, and the\nsum of the lengths of the arrays are printed to the console when the script is\nrun.\n\n## Braces\n\nBash has a very handy tool for creating strings out of sequences called\n**brace expansion**. Brace expansion uses the curly brackets and two periods\n(`{ .. }`) to create a sequence of letters or numbers. For example to create a\nstring with all of the numbers between zero and nine you could do the following:\n\n```{r, engine='bash'}\necho {0..9}\n```\n\nIn addition to numbers you can also create sequences of letters:\n\n```{r, engine='bash'}\necho {a..e}\necho {W..Z}\n```\n\nYou can put strings on either side of the curly brackets and they'll be \"pasted\"\nonto the corresponding end of the sequence:\n\n```{r, engine='bash'}\necho a{0..4}\necho b{0..4}c\n```\n\nYou can also combine sequences so that two or more sequences are pasted\ntogether:\n\n```{r, engine='bash'}\necho {1..3}{A..C}\n```\n\nIf you want to use variables in order to define a sequence you need to use the\n`eval` command in order to create the sequence:\n\n```{r, engine='bash'}\nstart=4\nend=9\necho {$start..$end}\neval echo {$start..$end}\n```\n\nYou can combine sequences with a comma between brackets (`{,}`):\n\n```{r, engine='bash'}\necho {{1..3},{a..c}}\n```\n\nIn fact you can do this with any number of strings:\n\n```{r, engine='bash'}\necho {Who,What,Why,When,How}?\n```\n\n### Summary\n\n- Braces allow you create string sequences and expansions.\n- To use variables with braces you need to use the `eval` command.\n\n### Exercises\n\n1. Create 100 text files using brace expansion.\n\n## Loops\n\n### `for`\n\nLoops are one of the most important programming structures in the Bash language.\nAll of the programs we've written so far are executed from the first line of the\nscript until the last line, but loops allow you to repeat lines of code based on\nlogical conditions or by following a sequence. The first kind of loop that we'll\ndiscuss is a FOR loop. **FOR loops** iterate through every element of a sequence\nthat you specify. Let's take a look at a small example FOR loop:\n\n```\n#!/usr/bin/env bash\n# File: forloop.sh\n\necho \"Before Loop\"\n\nfor i in {1..3}\ndo\n\techo \"i is equal to $i\"\ndone\n\necho \"After Loop\"\n```\n\nNow let's execute this script:\n\n```{r, engine='bash', eval=FALSE}\nbash forloop.sh\n```\n\n```\n## Before Loop\n## i is equal to 1\n## i is equal to 2\n## i is equal to 3\n## After Loop\n```\n\nLet's walk through `forloop.sh` line-by-line. First `\"Before Loop\"` is printed\nbefore the FOR loop, then the loop begins. FOR loops start with the syntax\n`for [variable name] in [sequence]` followed by `do` on the next line. The\nvariable name that you define immediately after `for` will take on a value\ninside of the loop that corresponds to an element in the sequence you provide\nafter `in`, starting with the first element of the sequence, followed by every\nsubsequent element. Valid sequences include brace expansions, explicit lists of strings,\narrays, and command substitutions. In this instance we're using the brace\nexpansion `{1..3}` which we know expands to the string `\"1 2 3\"`. The code\nexecuted in each iteration of the loop is written\nbetween `do` and `done`. In the first iteration of the loop, the variable `$i`\ncontains the value 1. The string `\"i is equal to 1\"` is printed to the console.\nThere are more elements in the brace expansion after 1, so after\nreaching `done` the first time, the program starts executing back at the\n`do` statement. The second time through the loop variable `$i` contains the\nvalue 2. The string\n`\"i is equal to 2\"` is printed to the console, then the loop goes back to the\n`do` statement since there are still elements left in the sequence. The `$i`\nvariable is now equal to 3, so `\"i is equal to 3\"` is printed to the console.\nThere are no elements left in the sequence, so the program moves beyond the\nFOR loop and finally prints `\"After Loop\"`. Stop for a moment and edit this loop\nyourself. Try changing the brace expansion to include other sequences of\nnumbers, letters, or words, then execute the modified code. Before you execute\nyour modified program, write down what you think will be printed. How do the\nresults of executing your program compare with your expectations?\n\nOnce you've experimented a little take a look at this example with several\nother kinds of sequence generating strategies:\n\n```\n#!/usr/bin/env bash\n# File: manyloops.sh\n\necho \"Explicit list:\"\n\nfor picture in img001.jpg img002.jpg img451.jpg\ndo\n\techo \"picture is equal to $picture\"\ndone\n\necho \"\"\necho \"Array:\"\n\nstooges=(curly larry moe)\n\nfor stooge in ${stooges[*]}\ndo\n\techo \"Current stooge: $stooge\"\ndone\n\necho \"\"\necho \"Command substitution:\"\n\nfor code in $(ls)\ndo\n\techo \"$code is a bash script\"\ndone\n```\n\n```{r, engine='bash', eval=FALSE}\nbash manyloops.sh\n```\n\n```\n## Explicit list:\n## picture is equal to img001.jpg\n## picture is equal to img002.jpg\n## picture is equal to img451.jpg\n##\n## Array:\n## Current stooge: curly\n## Current stooge: larry\n## Current stooge: moe\n##\n## Command substitution:\n## bigmath.sh is a bash script\n## condexif.sh is a bash script\n## forloop.sh is a bash script\n## letsread.sh is a bash script\n## manyloops.sh is a bash script\n## math.sh is a bash script\n## nested.sh is a bash script\n## simpleelif.sh is a bash script\n## simpleif.sh is a bash script\n## simpleifelse.sh is a bash script\n## vars.sh is a bash script\n```\n\nThe example above illustrates three other methods of creating sequences for FOR\nloops: typing out an explicit list, using an array, and getting the result of a\ncommand substitution. In each case a variable name is declared after the `for`,\nand the value of tha variable changes through each iteration of the loop until\nthe corresponding sequence has been exhausted. Right now you should take a\nmoment to write a few FOR loops yourself, generating sequences in all of the\nways that we've gone over, just to reinforce your understanding of how a FOR\nloop works. Loops and conditional statements are two of the most important\nstructures that we have at our disposal as programmers.\n\n### `while`\n\nNow that we've gotten a few FOR loops working let's move on to WHILE loops. The\n**WHILE loop** is truly the [Reese's Peanut Butter Cup](https://youtu.be/O7oD_oX-Gio)\nof programming structures, combining parts of the FOR loop and the IF statement.\nLet's take a look at an example WHILE loop so you can see what I mean:\n\n```\n#!/usr/bin/env bash\n# File: whileloop.sh\n\ncount=3\n\nwhile [[ $count -gt 0 ]]\ndo\n  echo \"count is equal to $count\"\n  let count=$count-1\ndone\n```\n\nThe WHILE loop begins first with the `while` keyword followed by a conditional\nexpression. As long as the conditional expression is equivalent to `true` when\nan iteration of the loop begins, then\nthe code within the WHILE loop will continue to be executed. Based on the code\nfor `whileloop.sh` what do you think will be printed to the console when we run\nthis script? Let's find out:\n\n```{r, engine='bash', eval=FALSE}\nbash whileloop.sh\n```\n\n```\n## count is equal to 3\n## count is equal to 2\n## count is equal to 1\n```\n\nBefore the WHILE the `count` variable is set to be 3, but then each\ntime the WHILE loop is executed 1 is subtracted from the value of `count`. The\nloop then starts from the top again and the conditional expression is\nre-checked to see if it's still equivalent to `true`. After three iterations\nthrough the loop `count` is equal to 0 since 1 is subtracted from `count` in\nevery iteration. Therefore\nthe logical expression `[[ $count -gt 0 ]]` is no longer equal to `true` and\nthe loop ends. By changing the value of the variable in the logical expression\ninside of the loop we're able to ensure that the logical expression will\neventually be equivalent to `false`, and therefore the loop will eventually end.\n\nIf the logical expression is never equivalent to `false` then we've created an\n*infinite loop*, so the loop never ends and the program runs forever. Obviously we\nwould like for our programs to end eventually, and therefore creating infinite\nloops is undesirable. However let's create an infinite loop so we know what to\ndo if we get into a situation where our program won't terminate. With a simple\n\"typo\" we can change the program above so that it runs forever but substituting\nthe minus sign `-` with a plus sign `+` so that `count` is always greater than\nzero (and growing) after every iteration.\n\n```\n#!/usr/bin/env bash\n# File: foreverloop.sh\n\ncount=3\n\nwhile [[ $count -gt 0 ]]\ndo\n  echo \"count is equal to $count\"\n  let count=$count+1              # We only changed this line!\ndone\n```\n\n```\n## ...\n## count is equal to 29026\n## count is equal to 29027\n## count is equal to 29028\n## count is equal to 29029\n## count is equal to 29030\n## ...\n```\n\nIf the program is working, then `count` is being incremented very rapidly and\nyou're watching numbers whiz by in your terminal! Don't fret, you can terminate\nany program that's stuck in an infinite loop using `Control` + `C`. Use\n`Control` + `C` to get the prompt back so that we can continue.\n\nWhen constructing WHILE loops, make absolutely sure that you've structured the\nprogram so that the loop will terminate! If the logical expression after `while`\nnever becomes `false` then the program will run forever, which is probably not\nthe kind of behavior you were planning for your program.\n\n### Nesting\n\nJust like IF statements `for` and `while` loops can be nested within each other.\nIn the example below a FOR loop is nested inside of another FOR loop.\n\n```\n#!/usr/bin/env bash\n# File: nestedloops.sh\n\nfor number in {1..3}\ndo\n  for letter in a b\n  do\n    echo \"number is $number, letter is $letter\"\n  done\ndone\n```\n\nBased on what we know about FOR loops try to predict what this program will\nprint out before we run the program. Now that you've written down or typed out\nyour prediction let's run it.\n\n```{r, engine='bash', eval=FALSE}\nbash nestedloops.sh\n```\n\n```\n## number is 1, letter is a\n## number is 1, letter is b\n## number is 2, letter is a\n## number is 2, letter is b\n## number is 3, letter is a\n## number is 3, letter is b\n```\n\nLet's closely examine what's going on here. The outer most FOR loop starts\niterating through the sequence generated by `{1..3}`. On the first pass through\nthe loop, the inner loop iterates through the sequence `a b` which first prints\n`number is 1, letter is a` followed by `number is 1, letter is b`. The first\niteration of the outer loop is then finished and the whole process starts over\nwith `number` having a value of 2. This process continues going through the\ninner loop until the sequence for the outer loop is exhausted. I again strongly\nencourage you to pause for a moment and write some of your own nested loops\nbased on the code above. Try to predict what your nested loop program will print\nbefore you run your program. If the printed result does not match your\nprediction trace your way through the program and try to figure out why. Don't\njust limit yourself to nested FOR loops, use nested WHILE loops, or FOR and\nWHILE loops in nested combinations.\n\nBesides nesting loops within each other you can also nest loops within IF\nstatements and IF statements within loops. Let's take a look at an example:\n\n```\n#!/usr/bin/env bash\n# File: ifloop.sh\n\nfor number in {1..10}\ndo\n  if [[ $number -lt 3 ]] || [[ $number -gt 8 ]]\n  then\n    echo $number\n  fi\ndone\n```\n\nBefore we run this example try once more to guess what the output will be.\n\n```{r, engine='bash', eval=FALSE}\nbash ifloop.sh\n```\n\n```\n## 1\n## 2\n## 9\n## 10\n```\n\nFor each iteration of the loop above, the value of `number` was checked in the\nIF statement, and the `echo` command was only run if `number` was outside the\nrange from 3 to 8.\n\nThere are endless combinations for nesting IF statements and loops, but one good\nrule of thumb you should remember is that your nesting should never go more than\ntwo or possibly three layers deep. If you find yourself writing code with lots\nof nesting, you should consider restructuring your program. Deeply nested code\nis difficult to read and even more difficult to debug if your program contains\nmistakes.\n\n### Summary\n\n- Loops allows you repeat sections of your program.\n- FOR loops iterate through a sequence so that a variable that you assign\ntakes on the value of every element of the sequence in every iteration of the\nloop.\n- WHILE loops check a conditional statement at the beginning of every iteration.\nIf the condition is equivalent to `true` then one iteration of the loop is\nexecuted and then the conditional statement is checked again. Otherwise the\nloop ends.\n- IF statements and loops can be nested in order to make more powerful\nprogramming structures.\n\n### Exercises\n\n- Write several programs with three levels of nesting and include FOR loops,\nWHILE loops, and IF statements. Before you run your program try to predict what\nyour program is going to print. If the result is different from your prediction\ntry to figure out why.\n- Enter the `yes` command into the console, then stop the program from running.\nTake a look at the `man` page for `yes` to learn more about the program.\n\n## Functions\n\n### Writing Functions\n\nA function is a small piece of code that has a name. Writing functions allows\nus to re-use the same code multiple times across programs. Functions have\nthe following syntax:\n\n```\nfunction [name of function] {\n  # code here\n}\n```\n\nPretty simple, right? Let's open up a new file called `hello.sh` so we can write\nour first simple function.\n\n```\n#!/usr/bin/env bash\n# File: hello.sh\n\nfunction hello {\n  echo \"Hello\"\n}\n\nhello\nhello\nhello\n```\n\nThe entire structure of the function including the `function` keyword, the name\nof the function, and the code for the function written inside of the brackets\nserves as the **function definition**. The function definition assigns the code\nwithin the function to the name of the function (`hello` in this case). After a\nfunction is defined it can be used like any other command. Using our `hello`\ncommand three times should be the equivalent of using `echo \"Hello\"` three\ntimes. Let's run this script to find out:\n\n```{r, engine='bash', eval=FALSE}\nbash hello.sh\n```\n\n```\n## Hello\n## Hello\n## Hello\n```\n\nIt looks like this function works exactly like we expected.\n\nFunctions share lots of their behavior with individual bash scripts including\nhow they handle arguments. The usual bash script arguments like `$1`, `$2`, and\n`$@` all work within a function, which allows you to specify function arguments.\nLet's create a slightly modified version of `hello.sh` which we'll call\n`ntmy.sh`:\n\n```\n#!/usr/bin/env bash\n# File: ntmy.sh\n\nfunction ntmy {\n  echo \"Nice to meet you $1\"\n}\n```\n\nIn the file above notice that we're not using the `ntmy` function after we've\ndefined it. That's because we're going to start using the functions that we\ndefine as command line programs. So far in this chapter we've been using the\nsyntax of `bash [name of script]` in order to execute the contents of a script.\nNow we're going to start using the `source` command, which allows us to use\nfunction definitions in bash scripts as command line commands. Let's use\n`source` with this file so that we can then use the `ntmy` command:\n\n```{r, engine='bash', eval=FALSE}\nsource ntmy.sh\nntmy Jeff\nntmy Philip\nntmy Jenny\n```\n\n```\n## Nice to meet you Jeff\n## Nice to meet you Philip\n## Nice to meet you Jenny\n```\n\nAnd just like that you've created your very own command! Once you close your\ncurrent shell you'll lose access to the `ntmy` command, but in the next section\nwe'll discuss how to set up your own commands so that you always have access to\nthem.\n\nLet's write a more complicated function. Imagine that we wanted to add up\na sequence of numbers from the command line, but we had no way of knowing how\nmany numbers would be in the sequence. What components would we need to write\nthis function? First we would need a way to capture a list of arguments which\ncan have variable length, second we would need a way to iterate through that\nlist so we could add up each element, and we would need a way to store the\ncumulative sum of the sequence. These three requirements can be satisfied by\nusing the `$@` variable, a FOR loop, and variable where we can store the sum.\nIt's important to break down a larger goal into a series of individual\ncomponents before writing a program, that way we more easily can identify which\nfeatures and tools will be required. Let's write this program in a file called\n`addseq.sh`.\n\n```\n#!/usr/bin/env bash\n# File: addseq.sh\n\nfunction addseq {\n  sum=0\n\n  for element in $@\n  do\n    let sum=sum+$element\n  done\n\n  echo $sum\n}\n```\n\nIn the program above we initialize the `sum` variable to be 0 so that we can\nadd other values in the sequence to `sum`. We then use a FOR loop to iterate\nthrough every element of `$@`, which is an array of all the arguments we provide\nto `addseq`. Finally we `echo` the value of `sum`. Let's `source` this program\nand test it out:\n\n```{r, engine='bash', eval=FALSE}\nsource addseq.sh\naddseq 12 90 3\naddseq 0 1 1 2 3 5 8 13\naddseq\naddseq 4 6 6 6 4\n```\n\n```\n## 105\n## 33\n## 0\n## 26\n```\n\nBy breaking down a large problem we were able to write a nice little function!\n\n### Getting Values from Functions\n\nFunctions are used for two primary purposes: *computing values* and\n*side effects*. In the `addseq` command in the previous section we provide the\ncommand with a sequence of numbers and then the command provides us with the sum\nof the sequence which is a value that we're interested in. In this case we can\nsee that `addseq` has computed a value based on a few input values.\nMany other commands,\nlike `pwd` for example, return a value without affecting the state of the file\non our computer. There are however functions like `mv` or `cp` which move and\ncopy files on our computer. A side effect occurs whenever a function creates or\nchanges files on our computer. These commands don't print any value if they\nsucceed.\n\nWe'll often write functions in order to calculate some value, and it's important\nto understand how to store the result of a function in a variable so that it can\nbe used later. Let's `source` `addseq.sh` and run it one more time:\n\n```{r, engine='bash', eval=FALSE}\nsource addseq.sh\naddseq 3 0 0 7\n```\n\n```\n## 10\n```\n\nIf we look back at the code for `addseq.sh` we can see that we created a\nvariable in the function called `sum`. When you create variables in functions\nthose variables become **globally accessible**, meaning that even after the\nprogram is finished that variable retains its value in your shell. We can easily\nverify this by `echo`ing the value of `sum`:\n\n```{r, engine='bash', eval=FALSE}\necho $sum\n```\n\n```\n## 10\n```\n\nThis is an example of one strategy we can use to retrieve values that a function\nhas calculated. Unfortunately this approach is problematic because it changes\nthe values of variables that we might be using in our shell. For example if we\nwere storing some other important value in a variable called `sum` we would\ndestroy that value by accident by running `addseq`. In order to avoid this\nproblem it's important that we use the `local` keyword when assigning variables\nwithin a function. The `local` keyword ensures that variables outside of our\nfunction are not overwritten by our function. Let's create a new version of\n`addseq` called `addseq2` which uses `local` when assigning variables.\n\n```\n#!/usr/bin/env bash\n# File: addseq2.sh\n\nfunction addseq2 {\n  local sum=0\n\n  for element in $@\n  do\n    let sum=sum+$element\n  done\n\n  echo $sum\n}\n```\n\nNow let's `source` both files so we demonstrate how `local` helps us avoid\noverwriting variables.\n\n```{r, engine='bash', eval=FALSE}\nsource addseq.sh\nsource addseq2.sh\nsum=4444\naddseq 5 10 15 20\necho $sum\n```\n\n```\n## 50\n## 50\n```\n\nOur original `addseq` overwrites the value we assigned to `sum`. Now let's try\n`addseq2`.\n\n```{r, engine='bash', eval=FALSE}\nsum=4444\naddseq2 5 10 15 20\necho $sum\n```\n\n```\n## 50\n## 4444\n```\n\nBy using `local` within our function the value of `sum` is preserved! In order\nto correctly capture the value of the result of `addseq2` we can use command\nsubstitution.\n\n```{r, engine='bash', eval=FALSE}\nmy_sum=$(addseq2 5 10 15 20)\necho $my_sum\n```\n\n```\n## 50\n```\n\n### Summary\n\n- Functions start with the `function` keyword followed by the name of the\nfunction and curly brackets (`{}`).\n- Functions are small, reusable pieces of code that behave just like commands.\n- You can use variables like `$1`, `$2`, and `$@` in order to provide arguments\nto functions, just like a Bash script.\n- Use the `source` command in order to read in a Bash script with function\ndefinitions so that you can use your functions in your shell.\n- Use the `local` keyword to prevent your function from creating or modifying\nglobal variables.\n- Be sure to `echo` the results of your function (if there are any) so that\nthey can be captured with command substitution.\n\n### Exercises\n\nBelow this list of exercises you can find examples of how these programs should\nwork when used on the command line.\n\n1. Write a function called `plier` which multiplies together a sequence of\nnumbers.\n2. Write a function called `isiteven` that prints `1` if a number is even or\n`0` a number is not even.\n3. Write a function called `nevens` which prints the number of even numbers when\nprovided with a sequence of numbers. Use `isiteven` when writing this function.\n4. Write a function called `howodd` which prints the percentage of odd numbers\nin a sequence of numbers. Use `nevens` when writing this function.\n5. Write a function called `fib` which prints the number of\n[fibonacci](https://en.wikipedia.org/wiki/Fibonacci_number) numbers specified.\n\n```{r, engine='bash', eval=FALSE}\nplier 7 2 3\n```\n\n```\n## 42\n```\n\n```{r, engine='bash', eval=FALSE}\nisiteven 42\n```\n\n```\n## 1\n```\n\n```{r, engine='bash', eval=FALSE}\nnevens 42 6 7 9 33\n```\n\n```\n## 2\n```\n\n```{r, engine='bash', eval=FALSE}\nhowodd 42 6 7 9 33\n```\n\n```\n## .60\n```\n\n```{r, engine='bash', eval=FALSE}\nfib 4\n```\n\n```\n## 0 1 1 2\n```\n\n```{r, engine='bash', eval=FALSE}\nfib 10\n```\n\n```\n## 0 1 1 2 3 5 8 13 21 34\n```\n\n## Writing Programs\n\n### The Unix Philosophy\n\nPerhaps there are some design patterns that you've been noticing since we started\ntalking about Unix tools, and now we're going to discuss them explicitly. Unix\ntools were designed along a set of guidelines which are best summarized by\n[Ken Thompson](https://en.wikipedia.org/wiki/Ken_Thompson)'s idea that each Unix\nprogram should **do one thing well**. Following this rule when writing functions\nand programs accomplished several goals:\n\n- Limiting a program to only doing one thing reduces the length of the program,\nand the shorter a program is the easier it is to fix if it contains bugs or if\nit needs to be revised.\n- Writing short programs also helps the users of your code\nunderstand what's going on in your code in the event that they need to read your\ncode. Reading a poem induces a different cognitive load compared to reading a\nnovel.\n- Folks who don't read the source code of your program (most users won't -\nthey shouldn't have to) will be able to understand the inputs, outputs, and side\neffects of your program more easily.\n- Using small programs to write a new program will increase the likelihood that\nthe new program will also be small. **Composability** is the concept of\nstringing small programs together to create a new program.\n\nThe concept of composability in Unix is best illustrated by the use of the pipe\noperator (`|`) for creating pipelines of programs.\nWhen you're considering what inputs your program is going to have and what your\nprogram is going to print to the console you should consider whether or not your\nprogram might be used in a pipeline, and you should organize your program\naccordingly.\n\nIn the previous section we discussed the difference between functions that\ncompute values and functions that produce side effects. You should notice that\nthe side effect functions like `mv` and `cp` do not print any text to the\nconsole if they are successful. The concept of *quietness* is another important\npart of the Unix philosophy. Quietness in this case means that a function should\nnot print to the console unless it is necessary, either to inform the user of a\nvalue (`pwd`), to display the result of a computation (`bc`), or to warn the\nuser that an error has occurred.\n\n### Making Programs Executable\n\nLet's take a detailed look at some of the code files in our current working\ndirectory:\n\n```{r, engine='bash', eval=FALSE}\nls -l | head -n 3\n```\n\n```\n## -rw-rw-r-- 1 sean sean 138 Jun 26 12:51 addseq.sh\n## -rw-rw-r-- 1 sean sean 146 Jun 26 14:45 addseq2.sh\n## -rw-rw-r-- 1 sean sean 140 Jan 29 10:06 bigmath.sh\n```\n\nThe left column of this table contains a series of individual characters and\ndashes. The first hyphen (`-`) signifies that each of the entries in this list\nare files. If any of them were directories then instead of a hyphen there would\nbe a `d`. Excluding the first hyphen we have the following string: `rw-rw-r--`.\nThis string reflects the **permissions** that are set up for this file. There\nare three permissions that we can grant: the ability to **read** the file (`r`),\n**write** to or edit the file (`w`), or **execute** the file (`x`) as a program.\nThese three permissions can be granted on three different levels of access which\ncorrespond to each of the three sets of `rwx` in the permissions string: the\nowner of the file, the group that the file belongs to, and everyone other than\nthe owner and the members of a group. Since you\ncreated the file you are the owner of the file, and you can set the permissions\nfor files that you own using the `chmod` command.\n\nThe `chmod` command takes two arguments. The first argument is a string which\nspecifies how we're going to change permissions for a file, and the second\nargument is the path to the file. The first argument has to be composed in a\nvery specific way. First we can specify which set of users we're going to change\npermissions for:\n\n|Character  |Meaning |\n|:----------|:-------|\n|`u` |The owner of the file |\n|`g` |The group that the file belongs to |\n|`o` |Everyone else  |\n|`a` |Everyone above |\n\nWe then need to specify whether we're going to add, remove, or set the\npermission:\n\n|Character  |Meaning |\n|:----------|:-------|\n|`+` |Add permission |\n|`-` |Remove permission |\n|`=` |Set permission  |\n\nFinally we specify what permission we're changing:\n\n|Character  |Meaning |\n|:----------|:-------|\n|`r` |Read a file |\n|`w` |Write to or edit a file |\n|`x` |Execute a file  |\n\nLet's use `echo` to write a very short program which we'll call `short`.\n\n```{r, engine='bash', eval=FALSE}\necho 'echo \"a small program\"' > short\n```\n\nNormally if we wanted to run `short` we would enter `bash short` into the\nconsole. If we make this file executable we would only need to enter `short`\ninto the command line to run the program, just like a command!\nLet's take a look at the permissions for `short`.\n\n```{r, engine='bash', eval=FALSE}\nls -l short\n```\n\n```\n## -rw-r--r--  1 sean  staff  23 Jun 28 09:47 short\n```\n\nWe want to make this file executable and we're the owner of this file since we\ncreated it. This means we can combine `u`, `+`, and `x` in order make `short`\nexecutable. Let's try it:\n\n```{r, engine='bash', eval=FALSE}\nchmod u+x short\nls -l short\n```\n\n```\n## -rwxr--r--  1 sean  staff  23 Jun 28 09:47 short\n```\n\nWe successfully added the `x`! To run an executable file we need to specify the\npath to the file, even if the path is in the current directory, meaning we need\nto prepend `./` to `short`. Now let's try running the program.\n\n```{r, engine='bash', eval=FALSE}\n./short\n```\n\n```\n## a small program\n```\n\nLooks like it works! There is one small detail we should add to this program\nthough. Even though we've made our file executable, if we give our program to\nsomebody else they might be using a shell that doesn't know how to execute our\nprogram. We need to indicate how the program should be run by adding\na special line of text to the beginning of our program called a **shebang**.\nThe shebang always begins with `#!` followed by the path to the program which\nwill execute the code in our file. The shebang for indicating that we want to\nuse Bash is `#!/usr/bin/env bash`, which we've been adding to the start of our\nscripts for a while now! Let's rewrite this program to include the Bash shebang\nand then let's run the program.\n\n```{r, engine='bash', eval=FALSE}\necho '#!/usr/bin/env bash' > short\necho 'echo \"a small program\"' >> short\n```\n\n```\n## a small program\n```\n\nNow our Bash script is ready to go!\n\n### Environmental Variables\n\nWe're one step away from being able to use our scripts and functions as shell\ncommands, but first we need to learn about environmental variables.\nAn environmental variable is a variable that Bash creates where data about your\ncurrent computing environment is stored. Environmental variable names use all\ncapitalized letters. Let's look at the values for some of these variables. The\n`HOME` variable contains the path to our home directory, and the `PWD` variable\ncontains the path to our current directory.\n\n```{r, engine='bash', eval=FALSE}\necho $HOME\necho $PWD\n```\n\n```\n## /Users/sean\n## /Users/sean/Code\n```\n\nIf we want one of our functions to be available always as a command then we need\nto change the `PATH` variable. Let's take a look at this variable first.\n\n```{r, engine='bash', eval=FALSE}\necho $PATH\n```\n\n```\n## /usr/local/bin:/usr/bin:/bin:/usr/local/git/bin\n```\n\nThe `PATH` variable contains a sequence of paths on our computer separated by\ncolons. When the shell starts it searches these paths for executable files, and\nthen makes those executable commands available in our shell. One approach to\nmaking our scripts available is to add a directory to the `PATH`. Bash scripts\nin the directory that are executable can be used as commands. We need to modify\n`PATH` every time we start a shell, so we can ammend our `~/.bash_profile` so\nthat our directory for executable scripts is always in the `PATH`. To modify an\nenvironmental variable we need to use the `export` keyword.\n\nFirst let's create a new directory called `Commands` in our `Code` directory\nwhere we can keep our executable scripts. Then we'll add a line to our\n`~/.bash_profile` so that `Commands` is added to the `PATH`.\n\n```{r, engine='bash', eval=FALSE}\nmkdir Commands\nnano ~/.bash_profile\n```\n\n```\nalias docs='cd ~/Documents'\nalias edbp='nano ~/.bash_profile'\n\nexport PATH=~/Code/Commands:$PATH\n```\n\nSave `~/.bash_profile` and close `nano`. Now let's `source` our Bash profile\n(we only need to do this once) and move `short` into the `Commands` directory.\nThen we should be able to use `short` as a command!\n\n```{r, engine='bash', eval=FALSE}\nsource ~/.bash_profile\nshort\n```\n\n```\n## a small program\n```\n\nLooks like it works!\n\nAlternatively to making individual scripts executable we can add a `source`\ncommand to our `~/.bash_profile` so that we can use a Bash function on the\ncommand line. Let's use `nano` to open up our `~/.bash_profile` again.\n\n```{r, engine='bash', eval=FALSE}\nnano ~/.bash_profile\n```\n\n```\nalias docs='cd ~/Documents'\nalias edbp='nano ~/.bash_profile'\n\nexport PATH=~/Code/Commands:$PATH\nsource ~/Code/addseq2.sh\n```\n\nSave the `~/.bash_profile`, quit `nano`, and now let's `source` our\n`~/.bash_profile` so we can test if we can use `addseq2`.\n\n```{r, engine='bash', eval=FALSE}\nsource ~/.bash_profile\naddseq2 9 8 7\n```\n\n```\n## 24\n```\n\nAgain it works! If you have multiple Bash functions that you'd like to be able\nto use on the command line then it's a good idea to define these functions in\none of a few files so that you don't have to `source` every individual function\nthat you want to have available.\n\n### Summary\n\n- According to the Unix Philosophy you should keep your programs short, simple,\nand quiet.\n- Use `chmod` to make your programs executable.\n- You can modify your `~/.bash_profile` in order to make scripts and functions\navailable to use on the command line.\n- Use `export` to change an environmental variable.\n\n### Exercises\n\nBelow this list of exercises you can find examples of how the programs described\nhere should work when used on the command line.\n\n1. Make a script executable.\n2. Put that script in a directory that you create and make that directory part\nof your `PATH`.\n3. Write a program called `range` that takes one number as an argument and\nprints all of the numbers between that number and 0.\n4. Write a program called `extremes` which prints the maximum and minimum \nvalues of a sequence of numbers.\n\n```{r, engine='bash', eval=FALSE}\nrange 6\n```\n\n```\n## 0 1 2 3 4 5 6\n```\n\n```{r, engine='bash', eval=FALSE}\nrange -3\n```\n\n```\n## -3 -2 -1 0\n```\n\n```{r, engine='bash', eval=FALSE}\nextremes 8 2 9 4 0 3\n```\n\n```\n## 0 9\n```\n"
        },
        {
          "name": "06-Git-and-GitHub.Rmd",
          "type": "blob",
          "size": 52.7236328125,
          "content": "# Git and GitHub\n\n> Proof rather than argument. - Japanese proverb\n\n## What are Git and GitHub?\n\nGit is a command line program which allows you to track versions of any code or\nplain text documents that you create. Like the \"track changes\" feature of\na word processor Git keeps track of who made particular changes, the time and\ndate of those changes, and where the changes were made. If a critical file gets\ndeleted by accident, or if you make a breaking change to your code and you want\nto try to figure out where the breaking change was made, you can use Git to\nrestore the deleted file or find the new bug in your program. Git organizes\ngroups of files that you're tracking into a **repository**, which is just a\ndirectory where all of the changes to files in that directory are tracked. Git\ncan also help you collaborate with others when you're writing software. As\n[Karl Broman](https://twitter.com/kwbroman) says\n(paraphrasing [Mark Holder](https://twitter.com/mtholder)):\n\"Your closest collaborator is you six months ago, but you don’t reply to\nemails.\"\n\nGitHub is a website that provides remote Git repositories. A remote repository\nis just a Git repository that you're able to access over an internet connection.\nGitHub allows you to create public remote repositories for free, and anyone can\nsee your code in these public repositories. If you want to keep your code private\nthen you can pay GitHub for private remote repositories.\n\nIf you're working\non code together with a friend GitHub can help you sync changes to code files\nbetween you and your friend. There's also a social and community aspect to\nGitHub, since you can watch other programmers develop their projects. GitHub\nalso makes it easy to jump in and help somebody with their project. GitHub\noffers many other useful features which we will discuss at length.\n\n## Setting Up Git and GitHub\n\nBefore setting up Git, go to [GitHub](https://github.com/) and create a free\naccount. Take note of which email address you use and which username you choose.\n\nTo see if you have Git installed open up your terminal and enter the following:\n\n```{r, engine='bash'}\ngit --version\n```\n\nIf you don't get a response back telling you the version of Git that you have\ninstalled then you need to install Git. You can find instructions for installing\nGit on your operating system\n[here](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git).\n\nOpen up your shell once you have git installed and run `git --version` again to\nmake sure that installation succeeded (you may need to restart your shell or\nyour computer). After Git is installed we need to set up two environmental\nvariables, but we only need to do this once. The first variable we need to set\nup with Git is your GitHub user name, and the second variable is the email\naddress that you used to create your GitHub account:\n\n```{r, engine='bash', eval=FALSE}\ngit config --global user.name \"myUserName\"\ngit config --global user.email myName@email.com\n```\n\n\n## Getting Started with Git\n\nLet's create our first Git repository. First we need to create a directory:\n\n```{r, engine='bash', eval=FALSE}\ncd\nmkdir my-first-repo\ncd my-first-repo\n```\n\n\"Repo\" in this case is just shorthand for \"repository.\" To start tracking files\nwith Git in a directory enter `git init` into the command line:\n\n```{r, engine='bash', eval=FALSE}\ngit init\n```\n\n```\n## Initialized empty Git repository in /Users/sean/my-first-repo/.git/\n```\n\nYou've just created your first repository! Now let's create a file and start\ntracking it.\n\n```{r, engine='bash', eval=FALSE}\necho \"Welcome to My First Repo\" > readme.txt\n```\n\nNow that we've created a file in this Git repository, let's use `git status` to\nsee what's going on in this repository. We'll be using `git status` continuously\nthroughout this chapter in order to get information about the status of this Git\nrepository.\n\n```{r, engine='bash', eval=FALSE}\ngit status\n```\n\n```\n## On branch master\n##\n## Initial commit\n##\n## Untracked files:\n##   (use \"git add <file>...\" to include in what will be committed)\n##\n## \treadme.txt\n##\n## nothing added to commit but untracked files present (use \"git add\" to track)\n```\n\nAs you can see `readme.txt` is listed as an untracked file. In order to let Git\nknow that you want to track this file we need to use `git add` with the name of\nthe file that we want to track. Let's start tracking `readme.txt`:\n\n```{r, engine='bash', eval=FALSE}\ngit add readme.txt\n```\n\nGit now knows to track any changes to `readme.txt`. Let's see how the status of\nthe repository has changed:\n\n```{r, engine='bash', eval=FALSE}\ngit status\n```\n\n```\n## On branch master\n##\n## Initial commit\n##\n## Changes to be committed:\n##   (use \"git rm --cached <file>...\" to unstage)\n##\n## \tnew file:   readme.txt\n##\n```\n\nGit is now tracking `readme.txt`, or in Git-specific language `readme.txt` is\nnow **staged**. Between the parentheses in the message above you can see that\n`git status` is giving us a tip about how to unstage (or un-track) this file,\nwhich we could do with `git rm --cached readme.txt`. Let's unstage this file\njust to see what happens:\n\n```{r, engine='bash', eval=FALSE}\ngit rm --cached readme.txt\n```\n\n```\n## rm 'readme.txt'\n```\n\n```{r, engine='bash', eval=FALSE}\ngit status\n```\n\n```\n## On branch master\n##\n## Initial commit\n##\n## Untracked files:\n##   (use \"git add <file>...\" to include in what will be committed)\n##\n## \treadme.txt\n##\n```\n\nOur repository is right back to the way it started with `readme.txt` as an\nunstaged file. Let's start tracking `readme.txt` again so we can move on to\ncooler Git features.\n\n```{r, engine='bash', eval=FALSE}\ngit add readme.txt\n```\n\nNow that Git is tracking `readme.txt` we need to create a milestone to indicate\nthe changes that we made to `readme.txt`. In this case, the changes that we made\nwere creating the file in the first place! This milestone is called a **commit**\nin Git. A commit logs the content of all of the currently staged files. Right\nnow we only have `readme.txt` staged so let's commit the creation of this file.\nWhen making a Git commit, we need to write a commit message which is specified\nafter the `-m` flag. The message should briefly describe what changes you've\nmade since the last commit.\n\n```{r, engine='bash', eval=FALSE}\ngit commit -m \"added readme.txt\"\n```\n\n```\n## [master (root-commit) 73e53ca] added readme.txt\n##  1 file changed, 1 insertion(+)\n##  create mode 100644 readme.txt\n```\n\nThe message above confirms that the commit succeeded and it summarizes the\nchanges that took place since the last commit. As you can see in the message we\nonly changed one file, and we only changed one line in that file. Let's run\n`git status` again to see the state of our repository after we've made the first\ncommit:\n\n```{r, engine='bash', eval=FALSE}\ngit status\n```\n\n```\n## On branch master\n## nothing to commit, working tree clean\n```\n\nAll of the changes to the files in this repository have been committed! Let's\nadd a few more files to this repository and commit them.\n\n```{r, engine='bash', eval=FALSE}\ntouch file1.txt\ntouch fil2.txt\nls\n```\n\n```\n## file1.txt\n## fil2.txt\n## readme.txt\n```\n\nWhile we're at it let's also add a new line of text to `readme.txt`:\n\n```{r, engine='bash', eval=FALSE}\necho \"Learning Git is going well so far.\" >> readme.txt\n```\n\nNow that we've added two more files and we've made changes to one file let's\ntake a look at the state of this repository.\n\n```{r, engine='bash', eval=FALSE}\ngit status\n```\n\n```\n## On branch master\n## Changes not staged for commit:\n##   (use \"git add <file>...\" to update what will be committed)\n##   (use \"git checkout -- <file>...\" to discard changes in working directory)\n##\n## \tmodified:   readme.txt\n##\n## Untracked files:\n##   (use \"git add <file>...\" to include in what will be committed)\n##\n## \tfil2.txt\n## \tfile1.txt\n##\n## no changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nWe can see that Git has detected that one file has been modified, and that there\nare two files in this directory that it is not tracking. Now we need to tell\nGit to track the changes to these files. We could tell Git to track changes to\neach file using `git add`, or since all of the files in this repository are\n`.txt` files we could use a wildcard and enter `git add *.txt` into the\nconsole. However if we want to track all of the changes to all of the files in\nour directory we should use the command `git add -A`.\n\n```{r, engine='bash', eval=FALSE}\ngit add -A\ngit status\n```\n\n```\n## On branch master\n## Changes to be committed:\n##   (use \"git reset HEAD <file>...\" to unstage)\n##\n## \tnew file:   fil2.txt\n## \tnew file:   file1.txt\n## \tmodified:   readme.txt\n##\n```\n\nNow the changes to all of the files in this repository are being tracked.\nFinally let's commit these changes:\n\n```{r, engine='bash', eval=FALSE}\ngit commit -m \"added two files\"\n```\n\n```\n## [master 53a1983] added two files\n##  3 files changed, 1 insertion(+)\n##  create mode 100644 fil2.txt\n##  create mode 100644 file1.txt\n```\n\nDarn it, now looking at this commit summary I realize that I have a typo in one\nof the names of my files! Thankfully we can undo the most recent commit with\nthe command `git reset --soft HEAD~`:\n\n```{r, engine='bash', eval=FALSE}\ngit reset --soft HEAD~\ngit status\n```\n\n```\n## On branch master\n## Changes to be committed:\n##   (use \"git reset HEAD <file>...\" to unstage)\n##\n## \tnew file:   fil2.txt\n## \tnew file:   file1.txt\n## \tmodified:   readme.txt\n##\n```\n\nThis repo is now in that exact same state it was right before we made the\ncommit. Now we can rename `fil2.txt` to `file2.txt`, then let's look at the\nstatus of the repository again.\n\n```{r, engine='bash', eval=FALSE}\nmv fil2.txt file2.txt\ngit status\n```\n\n```\n## On branch master\n## Changes to be committed:\n##   (use \"git reset HEAD <file>...\" to unstage)\n##\n## \tnew file:   fil2.txt\n## \tnew file:   file1.txt\n## \tmodified:   readme.txt\n##\n## Changes not staged for commit:\n##   (use \"git add/rm <file>...\" to update what will be committed)\n##   (use \"git checkout -- <file>...\" to discard changes in working directory)\n##\n## \tdeleted:    fil2.txt\n##\n## Untracked files:\n##   (use \"git add <file>...\" to include in what will be committed)\n##\n## \tfile2.txt\n##\n```\n\nWe previously told Git to track `fil2.txt`, and we can see that Git acknowledges\nthat the file has been deleted. We can bring Git up to speed with what files it\nshould be tracking with `git add -A`:\n\n```{r, engine='bash', eval=FALSE}\ngit add -A\ngit status\n```\n\n```\n## On branch master\n## Changes to be committed:\n##   (use \"git reset HEAD <file>...\" to unstage)\n##\n## \tnew file:   file1.txt\n## \tnew file:   file2.txt\n## \tmodified:   readme.txt\n##\n```\n\nFinally we got the file names right! Now let's make the correct commit:\n\n```{r, engine='bash', eval=FALSE}\ngit commit -m \"added two files\"\n```\n\n```\n## [master 12bb9f5] added two files\n##  3 files changed, 1 insertion(+)\n##  create mode 100644 file1.txt\n##  create mode 100644 file2.txt\n```\n\nThat looks much better.\n\n### Summary\n\n- Git tracks changes to plain text files (code files and text documents).\n- A directory where changes to files are tracked by Git is called a Git\nrepository.\n- Change your working directory, then run `git init` to start a repository.\n- You can track changes to a file using `git add [names of files]`.\n- You can create a milestone about the state of your files using `git commit -m \"message about changes since the last commit\"`.\n- To examine the state of files in your repository use `git status`.\n\n### Exercises\n\n1. Start a repository in a new directory.\n2. Create a new file in your new Git repository. Make sure Git is tracking the\nfile and then create a new commit.\n3. Make changes to the file, and then commit these changes.\n4. Add two new files to your repository, but only commit one of them. What is\nthe status of your repository after the commit?\n5. Undo the last commit, add the untracked file, and redo the commit.\n\n## Important Git Features\n\n### Getting Help, Logs, and Diffs\n\nGit commands have their own `man` pages. You can access them with\n`git help [name of command]`. For example here's the start of the help page\nfor `git status`:\n\n```{r, engine='bash', eval=FALSE}\ngit help status\n```\n\n```\nGIT-STATUS(1)                                Git Manual                               GIT-STATUS(1)\n\nNAME\n       git-status - Show the working tree status\n\nSYNOPSIS\n       git status [<options>...] [--] [<pathspec>...]\n\nDESCRIPTION\n       Displays paths that have differences between the index file and the current HEAD commit,\n       paths that have differences between the working tree and the index file, and paths in the\n       working tree that are not tracked by Git (and are not ignored by gitignore(5)). The first\n       are what you would commit by running git commit; the second and third are what you could\n       commit by running git add before running git commit.\n```\n\nJust like any other help page that uses `less`, you can return to the prompt\nwith the `Q` key.\n\nIf you want to see a list of your Git commits, enter `git log` into the console:\n\n```{r, engine='bash', eval=FALSE}\ngit log\n```\n\n```\n## commit 12bb9f53b10c9b720dac8441e8624370e4e071b6\n## Author: seankross <sean@seankross.com>\n## Date:   Fri Apr 21 15:23:59 2017 -0400\n##\n##     added two files\n##\n## commit 73e53cae75301ce9b2802107b1956447241bb17a\n## Author: seankross <sean@seankross.com>\n## Date:   Thu Apr 20 14:15:26 2017 -0400\n##\n##     added readme.txt\n```\n\nIf you've made many commits to a repository you might need to press the `Q` key\nin order to get back to the prompt. Each commit has its time, date, and commit\nmessage recorded, along with a SHA-1 hash that uniquely identifies the commit.\n\nGit can also help show the differences between unstaged changes to your files\ncompared to the last commit. Let's add a new line of text to `readme.txt`:\n\n```{r, engine='bash', eval=FALSE}\necho \"I added a line.\" >> readme.txt\ngit diff readme.txt\n```\n\n```\n## diff --git a/readme.txt b/readme.txt\n## index b965f6a..a3db358 100644\n## --- a/readme.txt\n## +++ b/readme.txt\n## @@ -1,2 +1,3 @@\n##  Welcome to My First Repo\n##  Learning Git is going well so far.\n## +I added a line.\n```\n\nAs you can see a plus sign shows up next to the added line. Now let's open up\nthis file in a text editor so we can delete the second line.\n\n```{r, engine='bash', eval=FALSE}\nnano readme.txt\n# Delete the second line\ngit diff readme.txt\n```\n\n```\n## diff --git a/readme.txt b/readme.txt\n## index b965f6a..e173fdf 100644\n## --- a/readme.txt\n## +++ b/readme.txt\n## @@ -1,2 +1,2 @@\n##  Welcome to My First Repo\n## -Learning Git is going well so far.\n## +I added a line.\n```\n\nA minus sign appears next to the line we deleted. Let's take a look at the\nstatus of our directory at this point.\n\n```{r, engine='bash', eval=FALSE}\ngit status\n```\n\n```\n## On branch master\n## Changes not staged for commit:\n##   (use \"git add <file>...\" to update what will be committed)\n##   (use \"git checkout -- <file>...\" to discard changes in working directory)\n##\n## \tmodified:   readme.txt\n##\n## no changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nIf you read the results from `git status` carefully you can see that we can take\nthis repository in one of two directions at this point. We can either `git add`\nthe files we've made changes to in order to track those changes, or we can\nuse `git checkout` in order to remove all of the changes we've made to a file\nto restore its content to what was present in the last commit. Let's remove\nour changes to see how this works.\n\n```{r, engine='bash', eval=FALSE}\ncat readme.txt\n```\n\n```\n## Welcome to My First Repo\n## I added a line.\n```\n\n```{r, engine='bash', eval=FALSE}\ngit checkout readme.txt\ncat readme.txt\n```\n\n```\n## Welcome to My First Repo\n## Learning Git is going well so far.\n```\n\nAnd as you can see the changes we made to `readme.txt` have been undone.\n\n### Ignoring Files\n\nSometimes you might have files that you never want Git to track, for example\nbinary files that are generated as by-products of running code (PDFs or images),\nor secrets like passwords or API keys. A file in your Git repository called\n`.gitignore` can list names of files and sub-folders, or simple regular\nexpressions (whatever you can use with `ls`) in order to specify files which\nshould never be tracked. Each line of a `.gitignore` file should specify a file\nor group of files that should not be tracked by Git. Let's make a `.gitignore`\nfile to make sure that we never track image files in this repository:\n\n```{r, engine='bash', eval=FALSE}\ntouch toby.jpg\ngit status\n```\n\n```\n## On branch master\n## Untracked files:\n##   (use \"git add <file>...\" to include in what will be committed)\n##\n## \ttoby.jpg\n##\n## nothing added to commit but untracked files present (use \"git add\" to track)\n```\n\nNow that we've added an image to our repository, let's add a `.gitignore` file\nto make sure Git doesn't track these kinds of files.\n\n```{r, engine='bash', eval=FALSE}\necho \"*.jpg\" > .gitignore\ngit status\n```\n\n```\n## On branch master\n## Untracked files:\n##   (use \"git add <file>...\" to include in what will be committed)\n##\n## \t.gitignore\n##\n## nothing added to commit but untracked files present (use \"git add\" to track)\n```\n\nNow we can see that Git has detected the new `.gitignore` file, but it doesn't\nsee `toby.jpg`. Let's add and commit our `.gitignore` file:\n\n```{r, engine='bash', eval=FALSE}\ngit add -A\ngit commit -m \"added gitignore\"\n```\n\n```\n## [master adef548] added gitignore\n##  1 file changed, 1 insertion(+)\n##  create mode 100644 .gitignore\n```\n\nNow if we add another `.jpg` file, Git will not see the file:\n\n```{r, engine='bash', eval=FALSE}\ntouch bernie.jpg\ngit status\n```\n\n```\n## On branch master\n## nothing to commit, working tree clean\n```\n\n```{r, engine='bash', eval=FALSE}\nls\n```\n\n```\n## bernie.jpg\n## toby.jpg\n## file1.txt\n## file2.txt\n## readme.txt\n```\n\n### Summary\n\n- `git help` allows you to read the `man` pages for specific Git commands.\n- `git log` will show you your commit history.\n- `git diff` displays what has changed between the last commit and your current\nuntracked changes.\n- You can specify a `.gitignore` file in order to tell Git not to track certain\nfiles.\n\n### Exercises\n\n1. Look at the help pages for `git log` and `git diff`.\n2. Add to the `.gitignore` you already started to include a specific file name,\nthen add that file to your repository.\n3. Create a file that contains the Git log for this repository. Use `grep` to\nsee which day of the week most of the commits occurred on.\n\n## Branching\n\nBranching is one of the most powerful features that Git offers. Creating\ndifferent Git branches allows you to work on a particular feature or set of\nfiles independently from other \"copies\" of a repository. That way you and a\nfriend can work on different parts of the same file on different branches, and\nthen Git can help you elegantly merge your branches and changes together.\n\nYou can list all of the available branches with the command `git branch`:\n\n```{r, engine='bash', eval=FALSE}\ngit branch\n```\n\n```\n## * master\n```\n\nThe star (`*`) indicates which branch you're currently on. The default branch\nthat is created is always called *master*. Usually people use this branch as the\nworking version of the software that they are writing, while they develop new and\npotentially unstable features on other branches.\n\nTo add a branch we'll also use the `git branch` command, followed the name of\nthe branch we want to create:\n\n```{r, engine='bash', eval=FALSE}\ngit branch my-new-feature\n```\n\nNow let's enter `git branch` again to confirm that we've created the branch:\n\n```{r, engine='bash', eval=FALSE}\ngit branch\n```\n\n```\n## * master\n## my-new-feature\n```\n\nWe can make `my-new-feature` the current branch using `git checkout` with the\nname of the branch:\n\n```{r, engine='bash', eval=FALSE}\ngit checkout my-new-feature\n```\n\n```\n## Switched to branch 'my-new-feature'\n```\n\n```{r, engine='bash', eval=FALSE}\ngit branch\n```\n\n```\n##   master\n## * my-new-feature\n```\n\nIf we look at `git status` we can also see that it will tell us which branch\nwe're on:\n\n```{r, engine='bash', eval=FALSE}\ngit status\n```\n\n```\nOn branch my-new-feature\nnothing to commit, working tree clean\n```\n\nWe can switch back to the `master` branch using `git checkout`:\n\n```{r, engine='bash', eval=FALSE}\ngit checkout master\n```\n\n```\n## Switched to branch 'master'\n```\n\n```{r, engine='bash', eval=FALSE}\ngit branch\n```\n\n```\n## * master\n##   my-new-feature\n```\n\nNow we can delete a branch by using the `-d` flag with `git branch` and the name\nof the branch we want to delete:\n\n```{r, engine='bash', eval=FALSE}\ngit branch -d my-new-feature\n```\n\n```\n## Deleted branch my-new-feature (was adef548).\n```\n\n```{r, engine='bash', eval=FALSE}\ngit branch\n```\n\n```\n## * master\n```\n\nLet's create a new branch for adding a section to the `readme.txt` in our\nrepository. We can create a new branch and switch to that branch at the same\ntime using the command `git checkout -b` and the name of the new branch we want\nto create:\n\n```{r, engine='bash', eval=FALSE}\ngit checkout -b update-readme\n```\n\n```\n## Switched to a new branch 'update-readme'\n```\n\nNow that we've created and switched to a new branch, let's make some changes to\na file. As you might be expecting right now we'll add a new line to\n`readme.txt`:\n\n```{r, engine='bash', eval=FALSE}\necho \"I added this line in the update-readme branch.\" >> readme.txt\ncat readme.txt\n```\n\n```\n## Welcome to My First Repo\n## Learning Git is going well so far.\n## I added this line in the update-readme branch.\n```\n\nNow that we've added a new line let's commit these changes:\n\n```{r, engine='bash', eval=FALSE}\ngit add -A\ngit commit -m \"added a third line to readme.txt\"\n```\n\n```\n## [update-readme 6e378a9] added a third line to readme.txt\n##  1 file changed, 1 insertion(+)\n```\n\nNow that we've made a commit on the `update-readme` branch, let's switch back to the\n`master` branch, and then we'll take a look at `readme.txt`:\n\n```{r, engine='bash', eval=FALSE}\ngit checkout master\n```\n\n```\n## Switched to branch 'master'\n```\n\nNow that we're on the `master` branch let's quickly glance at `readme.txt`:\n\n```{r, engine='bash', eval=FALSE}\ncat readme.txt\n```\n\n```\n## Welcome to My First Repo\n## Learning Git is going well so far.\n```\n\nThe third line that we added is gone! Don't fret, the line that we added isn't\ngone forever. We committed the change to this file while we were on the\n`update-readme` branch, so the updated file is safely in that branch. Let's\nswitch back to that branch just to make sure:\n\n```{r, engine='bash', eval=FALSE}\ngit checkout update-readme\ncat readme.txt\n```\n\n```\n## Welcome to My First Repo\n## Learning Git is going well so far.\n## I added this line in the update-readme branch.\n```\n\nAnd the third line is back! Let's add and commit yet another line while we're\non this branch:\n\n```{r, engine='bash', eval=FALSE}\necho \"It's sunny outside today.\" >> readme.txt\ngit add -A\ngit commit -m \"added weather info\"\n```\n\n```\n## [update-readme d7946e9] added weather info\n##  1 file changed, 1 insertion(+)\n```\n\nThis is a small example of how to use Git branching, but you can see how you\ncan make incremental edits to plain text (usually code files) without\naffecting the `master` branch (the tested and working copy of your software)\nand without affecting any other branches. You can imagine how\nthis system could be used for multiple people to work on the same codebase at\nthe same time, or how you could develop and test multiple software features\nwithout them interfering with each other. Now that we've made a couple of\nchanges to `readme.txt`, let's combine those changes with what we have in the\n`master` branch. This is made possible by a Git **merge**. Merging allows you\nto elegantly combine the changes that have been made between two branches. Let's\nmerge the changes we made in the `update-readme` branch with the `master`\nbranch. Git incorporates other branches into the current branch by default.\nWhen you're merging, the current branch is also called the **base** branch.\nLet's switch to the `master` branch so we can merge in the changes from the\n`update-readme` branch:\n\n```{r, engine='bash', eval=FALSE}\ngit checkout master\n```\n\n```\n## Switched to branch 'master'\n```\n\nTo merge in the changes from another branch we need to use `git merge` and the\nname of the branch:\n\n```{r, engine='bash', eval=FALSE}\ngit merge update-readme\n```\n\n```\n## Updating adef548..d7946e9\n## Fast-forward\n##  readme.txt | 2 ++\n##  1 file changed, 2 insertions(+)\n```\n\n```{r, engine='bash', eval=FALSE}\ncat readme.txt\n```\n\n```\n## Welcome to My First Repo\n## Learning Git is going well so far.\n## I added this line in the update-readme branch.\n## It's sunny outside today.\n```\n\nIt looks like you've merged your first branch in Git! Branching is part of what\nmakes Git so powerful since it enables parallel developments on the same code\nbase. But what if there are two commits in two separate branches that make\ndifferent edits to the same line of text? When this occurs it is called a\n**conflict**. Let's create a conflict so we can learn how they can be resolved.\n\nFirst we'll switch to the `update-readme` branch. Use `nano` to edit the last\nline of `readme.txt`, then commit your changes:\n\n```{r, engine='bash', eval=FALSE}\ngit checkout update-readme\nnano readme.txt\ncat readme.txt\n```\n\n```\n## Welcome to My First Repo\n## Learning Git is going well so far.\n## I added this line in the update-readme branch.\n## It's cloudy outside today.\n```\n\nNotice that we changed \"sunny\" to \"cloudy\" in the last line.\n\n```{r, engine='bash', eval=FALSE}\ngit add -A\ngit commit -m \"changed sunny to cloudy\"\n```\n\nNow that our changes are committed on the `update-readme` branch, let's switch\nback to `master`:\n\n```{r, engine='bash', eval=FALSE}\ngit checkout master\n```\n\nLet's change the same line of code using `nano`:\n\n```{r, engine='bash', eval=FALSE}\nnano readme.txt\ncat readme.txt\n```\n\n```\n## Welcome to My First Repo\n## Learning Git is going well so far.\n## I added this line in the update-readme branch.\n## It's windy outside today.\n```\n\nNow let's commit these changes:\n\n```{r, engine='bash', eval=FALSE}\ngit add -A\ngit commit -m \"changed sunny to windy\"\n```\n\nWe've now created two commits that directly conflict with each other. On the\n`update-readme` branch the last line says `It's cloudy outside today.`, while\non the `master` branch the last line says `It's windy outside today.`. Let's\nsee what happens when we try to merge `update-readme` into `master`.\n\n```{r, engine='bash', eval=FALSE}\ngit merge update-readme\n```\n\n```\n## Auto-merging readme.txt\n## CONFLICT (content): Merge conflict in readme.txt\n## Automatic merge failed; fix conflicts and then commit the result.\n```\n\nUh-oh, there's a conflict! Let's check the status of the repo right now:\n\n```{r, engine='bash', eval=FALSE}\ngit status\n```\n\n```\n## On branch master\n## You have unmerged paths.\n##   (fix conflicts and run \"git commit\")\n##   (use \"git merge --abort\" to abort the merge)\n##\n## Unmerged paths:\n##   (use \"git add <file>...\" to mark resolution)\n##\n## \tboth modified:   readme.txt\n##\n## no changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n\nIf you're getting used to reading the result of `git status`, you can see that\nit often offers suggestions about what steps you should take next. Git is\nindicating that both versions of readme.txt have modified the same text. Let's\ntake a look at `readme.txt` to see what's going on there:\n\n```{r, engine='bash', eval=FALSE}\ncat readme.txt\n```\n\n```\n## Welcome to My First Repo\n## Learning Git is going well so far.\n## I added this line in the update-readme branch.\n## <<<<<<< HEAD\n## It's windy outside today.\n## =======\n## It's cloudy outside today.\n## >>>>>>> update-readme\n```\n\nThe first three lines of this file look normal, then things get interesting!\nThe line between `<<<<<<< HEAD` and `=======` shows the version of the\nconflicted line on the current branch. In Git terminology the `HEAD`\nrepresents the most recent commit on the branch which is currently checked out\n(which is `master` in this case). The line between `=======` and\n`>>>>>>> update-readme` shows the version of the line on the `update-readme`\nbranch. In order to resolve this conflict, all we need to do is open `readme.txt`\nwith `nano` so we can delete the lines we want to get rid of. In this case let's\nkeep the \"cloudy\" version.\n\n```{r, engine='bash', eval=FALSE}\nnano readme.txt\ncat readme.txt\n```\n\n```\n## Welcome to My First Repo\n## Learning Git is going well so far.\n## I added this line in the update-readme branch.\n## It's cloudy outside today.\n```\n\nNow we can commit the resolution of this conflict.\n\n```{r, engine='bash', eval=FALSE}\ngit add -A\ngit commit -m \"resolved conflict\"\n```\n\nYou're now familiar with this basics of Git! If you want to go into further\ndepth with your study of Git I highly recommend the free and open source book\n[Pro Git](https://git-scm.com/book/).\n\n### Summary\n\n- Git branching allows you and others to work on the same code base together.\n- You can create a branch with the command `git branch [name of branch]`.\n- To switch to a branch use `git checkout [name of branch]`.\n- You can combine a branch with your current branch by using `git merge`.\n\n### Exercises\n\n1. Start a new branch.\n2. Switch to that branch and add commits to it. Switch to an older branch and\nthen merge the new branch into your current branch.\n3. Purposefully create and resolve a merge conflict.\n\n## GitHub\n\nNow that you know the basics of using Git, let's talk about how you can share\nyour work and start collaborating online using GitHub. As an added bonus, by\nthe end of this chapter you will have created your very own website!\nTo get started go to [GitHub](https://github.com/) and sign in with the\ncredentials we set up at the beginning of the chapter. After you sign in you\nshould see a plus-sign near the top-right corner of your web browser. Click the\nplus-sign and a little menu should appear, then click \"New repository.\" You\nshould now see a screen that looks like this:\n\n![](images/new-repo.png)\n\nIn the text box under **Repository name** type `my-first-repo` and then click\nthe green **Create repository** button. Now you should see a page like this:\n\n![](images/quick-setup.png)\nGitHub offers a few suggestions about what to do with our new remote repository.\nWe've already been using a local Git repository, and what GitHub provides is a\n**remote** Git repository. A remote Git repository is just a Git repository\nstored on a computer is that always turned on and connected to the internet, so\nit can act as a central point where we can share and sync our changes to files\nwith our friends and colleagues. We can see which remote repositories our local\nrepository is connected to with the `git remote` command while we have our\nworking directory set to `my-first-repo`:\n\n```{r, engine='bash', eval=FALSE}\ngit remote\n```\n\nNothing is printed to the console since you haven't set any remotes up yet!\nNow let's add your new GitHub repository as a remote in your local repository:\n\n```{r, engine='bash', eval=FALSE}\ngit remote add origin https://github.com/seankross/my-first-repo.git\n```\n\nIn the command above `git remote add` adds a new remote to your local repository,\n`origin` is the name we're assigning to this remote repository, and\n`https://github.com/seankross/my-first-repo.git`\nis the URL of the remote repository. You should of course substitute `seankross`\nfor your GitHub user name so that it corresponds to your remote repository URL.\nLater I'll explain why \"origin\" is the name we chose for this remote.\nLet's run `git remote` again to confirm that we added the `origin` remote\nsuccessfully:\n\n```{r, engine='bash', eval=FALSE}\ngit remote\n```\n\n```\n## origin\n```\n\nNow that we've added our GitHub remote, let's perform our first Git **push**. A\nGit push updates a remote repository with all of the commits that we've made to\nour local Git repository. This first Git push you do when setting up a remote\non GitHub with a local repository is a little different from future Git pushes.\nWe'll need to use the `-u` flag in order to set `origin` as the default remote\nrepository so we don't have to provide its name every time we want to interact\nwith it. Enter the following command, modified so that you're using your GitHub\nuser name:\n\n```{r, engine='bash', eval=FALSE}\ngit push -u origin master\n```\n\n```\n## Counting objects: 23, done.\n## Delta compression using up to 4 threads.\n## Compressing objects: 100% (19/19), done.\n## Writing objects: 100% (23/23), 1.88 KiB | 0 bytes/s, done.\n## Total 23 (delta 9), reused 0 (delta 0)\n## remote: Resolving deltas: 100% (9/9), done.\n## To https://github.com/seankross/my-first-repo.git\n##  * [new branch]      master -> master\n## Branch master set up to track remote branch master from origin.\n```\n\nThe command above pushed all of our commits to the remote repository on\nGitHub, and it set up the `master` branch of the `origin` remote repository as\nthe default remote repository. Looking back at the web page for your repository\non GitHub, it should look something like this:\n\n![](images/first-push.png)\n\nOne neat feature of GitHub is that readme files are rendered on the repository\npage so you can write documents which explain the contents of your repository.\nLet's get more creative with these readme documents by learning a small\nlanguage called Markdown.\n\n### Markdown\n\nMarkdown is a markup language. Markup languages are sets of rules for adding\ndecorative features to text. The most popular markup language is HTML, but you\nmight have also heard of XML and LaTeX.\nMarkdown is a powerful markup language because it's\nsmall, intuitive, and readable when it's written as plain text. GitHub\ntransforms Markdown files (which end in the file extension `.md`) into simple\nHTML web pages in your repository. If there is a file called `README.md` in any\nfolder in your repository, then that file is rendered to HTML and displayed on\nGitHub. Let's create a `README.md` file for our repository. First we'll destroy\nthe plain text readme file we already have:\n\n```{r, engine='bash', eval=FALSE}\nrm readme.txt\n```\n\nI've included a Markdown file below that attempts to explain some of Markdown's\nfeatures. Copy the plain text below, create a new file called `README.md` with\n`nano`, paste the text in, and then save the file.\n\n    # This is a large heading\n\n    ## This is a smaller heading\n\n    And as **imagination** bodies forth,\n    The forms of things *unknown*, the poet’s pen,\n    Turns them to shapes and gives to airy nothing,\n    A local *habitation* and a **name**.\n\n    - This is\n    - an unordered\n    - list\n\n    1. This is\n    2. an ordered\n    3. list\n\n    Here is `some code` in the middle of a sentence.\n\n    ```\n    This is\n    a block\n    of code\n    ```\n\n    Here is how you make [a link](https://www.wikipedia.org/).\n\n    ![This is an image.](https://github.com/yihui/xaringan/releases/download/v0.0.2/karl-moustache.jpg)\n\n```{r, engine='bash', eval=FALSE}\nnano README.md\n```\n\nNow let's add our changes, make a commit, and push those changes to our remote\nrepository:\n\n```{r, engine='bash', eval=FALSE}\ngit add -A\ngit commit -m \"added README.md\"\ngit push\n```\n\n```\n## Counting objects: 3, done.\n## Delta compression using up to 4 threads.\n## Compressing objects: 100% (3/3), done.\n## Writing objects: 100% (3/3), 659 bytes | 0 bytes/s, done.\n## Total 3 (delta 0), reused 0 (delta 0)\n## To https://github.com/seankross/my-first-repo.git\n##    ca04f67..2169912  master -> master\n```\n\nSince we set up a default remote repository the first time we pushed, we can\nnow simply enter `git push` in order to send our latest commits to the `master`\nbranch on the `origin` remote. Now the page on GitHub for your repository should\nlook something like this:\n\n![](images/md-readme.png)\n\nWe've got a much more complex readme file! Notice how the plain text that we\nwrote has been rendered according to a few rules:\n\n- Pound signs (`#`, `##`) make headings.\n- A word surrounded by single asterisks (`*word*`) makes that word *italicized*.\n- A word surrounded by double asterisks (`**word**`) makes that word **bold**.\n- You can create lists with hyphens (`-`) or numbers (`1.`, `2.`, `3.`).\n- Code can be placed in the middle of a line with single backticks (`` `code` ``).\n- A code block can be created by putting code in between a set of triple\nbackticks (`` ``` ``).\n- You can insert a link with brackets and parentheses (`[Link text here](http://jhu.edu)`).\n- You can use an image with an exclamation point, and a link to an image (`![Alt text here](http://jhu.edu/jeff.jpg)`)\n\nPersonally I really enjoy writing with Markdown, to the point where I wrote\n[this entire book](https://github.com/seankross/the-unix-workbench/blob/master/docs/06-Git-and-GitHub.md)\nin Markdown! We're going to be using Markdown for the rest of this chapter, so\nI suggest that you take a few minutes to play around with the syntax in\n[this in-browser Markdown editor](https://jbt.github.io/markdown-editor/#TVFLbtwwDN3rFCxm0xgTOU133WXXA2QXFDDHYizWEmlIctzZ9Rq9Xk9SetqZFNCCIt97/LwDPEeuYA8hYZkIImFgmZw7HP6r1YwpUXmvPkkArNB1nHFiwcYqXQcnDUwVXrW0eHTPkfYwV9BXaNGIxlhlFt2kO1qGYFFqv3/+qrCQGGEtUvd8hqZQIy4mhtZq4jeLLIdcziB6ETu6J0g6YoIu4onb3yEueLTJBDN1nXfu/rqIRSiwipZAhYJ9E9fm3Cd/Qzz6HXIFfPb/EF/tu19iqJoJRg00AMtlg8whJNo3tDORNJKRrOkwDO4qinCyOWdnmJ16qd0ko25w1hUyzgQvZgPL/O1jbG2pX/p+2za/8cwLBUavZervTPzDy80agd0B8u+UiVtcT37U3J85rtz/wGLXQukLJcJKtQ9mQFIM/duDf/CP/Ywl3Wdda8Mxkv++THd/AA==).\nFor more information about Markdown see GitHub's helpful\n[*Mastering Markdown*](https://guides.github.com/features/mastering-markdown/)\nguide.\n\n### Pull Requests\n\nThe next two features of GitHub we're going to discuss - **pull requests** and\n**forking** - are what make GitHub so great. A pull request allows you to\ninteractively compare two different branches before you merge them so you can\neither go ahead with the merge or provide feedback to whoever opened the pull\nrequest. Essentially a pull request allows a person to ask another person if\nthey're willing to incorporate changes on one branch into another branch. This\nsocial coding transaction may involve you and a collaborator, you and a\nstranger, or you might open a pull request on your own repository just as a\nmethod of staying organized.\n\nSince I can't guarantee that you have a collaborator I'll show you how to open\na pull request on your own repository. First in your local `my-first-repo`\nrepository let's switch over to the `update-readme` branch.\n\n```{r, engine='bash', eval=FALSE}\ngit checkout update-readme\n```\n\n```\n## Switched to branch 'update-readme'\n```\n\nLet's take a look at what's currently on this branch:\n\n```{r, engine='bash', eval=FALSE}\nls\n```\n\n```\n## bernie.jpg\n## toby.jpg\n## file1.txt\n## file2.txt\n## readme.txt\n```\n\nIt looks like we haven't updated this branch to be current with the `master`\nbranch. We can easily do this by merging in the `master` branch.\n\n```{r, engine='bash', eval=FALSE}\ngit merge master\n```\n\n```\n## Updating 5aa94fa..2169912\n## Fast-forward\n##  README.md  | 28 ++++++++++++++++++++++++++++\n##  readme.txt |  4 ----\n##  2 files changed, 28 insertions(+), 4 deletions(-)\n##  create mode 100644 README.md\n##  delete mode 100644 readme.txt\n```\n\nNow the `master` and `update-readme` branches are identical. Let's clean up this\ndirectory so that you can make a little personalized Markdown project. First\nlet's delete all of the files in this directory that we don't really need,\nmeaning everything except `README.md`.\n\n```{r, engine='bash', eval=FALSE}\nrm *.txt\nrm *.jpg\nls\n```\n\n```\n## README.md\n```\n\nNow that we've cleaned up our repository let's open up `README.md` with `nano`.\nDelete everything that's written there and write a few lines about yourself.\nIn the block of text below you can see what I've written in `README.md`.\n\n```\n# Sean Kross\n\n### Geography\n\nI live in the city of Baltimore, in the state of Maryland, in the United States\nof America.\n\n### Reading\n\nThree of my favorite books are:\n\n- *Mindstorms* by Seymour Papert\n- *Welcome to the Monkey House* by Kurt Vonnegut\n- *Persepolis* by Marjane Satrapi\n\n### Food\n\nLast night I dreamt about eating in these restaurants:\n\n1. Linger in Denver.\n2. Azura in Jerusalem.\n3. Gemma in New York City.\n\n### Contact\n\nThe best way to get in touch with me is [on Twitter](https://twitter.com/seankross).\n```\n\nOnce you've written up a few fun things about yourself, add your changes, and\nmake a new commit.\n\n```{r, engine='bash', eval=FALSE}\ngit add -A\ngit commit -m \"made readme more personal\"\n```\n\nLike a local Git repository, remote repositories on GitHub can have multiple\nbranches. Let's push this commit to the `update-readme` branch on GitHub:\n\n```{r, engine='bash', eval=FALSE}\ngit push origin update-readme\n```\n\n```\n## Counting objects: 3, done.\n## Delta compression using up to 4 threads.\n## Compressing objects: 100% (3/3), done.\n## Writing objects: 100% (3/3), 630 bytes | 0 bytes/s, done.\n## Total 3 (delta 0), reused 0 (delta 0)\n## To https://github.com/seankross/my-first-repo.git\n##  * [new branch]      update-readme -> update-readme\n```\n\nNotice that we needed to specify which remote we were pushing to since GitHub\ndidn't previously know about the existence of the `update-readme` branch.\nWhen you perform a `git push`, only the commits on the current branch are sent\nto the remote repository. That way you can create local branches that cannot be\naccessed from the remote repository, unless you explicitly push them to GitHub.\n\nNow let's go back to the GitHub page for our repository. On the left side of the\npage you should see a button that says \"Branch: master.\" Click on that button\nand a little drop-down menu should appear, as you can see below:\n\n![](images/branch-button.png)\n\nClick \"update-readme\" in the menu in order to view the files in that branch. You\nshould see that the `README.md` files are different! You can switch back and\nforth between looking at branches using this menu.\n\nNow that you've pushed an updated branch to GitHub, let's open a pull request.\nA pull request is like a guided `git merge` that is facilitated by GitHub. To\nstart the pull request click the \"New pull request\" button next to the branch\nbutton (see the upper left corner of the image above). That button should take\nyou to a page like this:\n\n![](images/create-pr.png)\n\nThere are a few important details on this page, so let's go through them. First\nunder the \"Open a pull request\" heading you can see the names of two branches.\nThe branch name after \"base:\" shows the branch that changes are being merged\ninto (in this case the `master` branch), and the branch name after \"compare:\"\nshows the branch that has the changes (in this case the `update-readme` branch).\n\nIn the text boxes below you can write a title for your pull request (the default\ntitle in this case is the name of the last commit) and you can write comments\nabout the pull request which you can format with Markdown. If you're\ncollaborating with somebody else on a project it's important to write good\ncomments so that your collaborators know what changes you made in the branch\nyou are requesting to merge. If you scroll down\nthe page you can see a line-by-line comparison of the changes in the \"compare\"\nbranch compared to the \"base\" branch. When you've finished going over these\nchanges click the green \"Create pull request\" button in order to open the pull\nrequest. You should now see a screen like this:\n\n![](images/opened-pr.png)\n\nCongratulations on opening your first pull request! Let's take a look at what's\nhappening on this page. Below the title of the pull request we can see three\ntabs called **Conversation**, **Commits**, and **Files changed**. In the\n**Conversation** tab we can add comments to the pull request which can be\nformatted with Markdown. The **Commits** tab lists the commits that have been\nmade to the \"compare\" branch in this pull request. Finally the **Files changed**\ntab shows the same line-by-line comparison we saw before.\n\nUsually when you're working with collaborators there's a great deal of\ndiscussion that occurs after you open a pull request. Git commits that are\npushed to the \"compare\" branch (`update-readme` in the case) of the GitHub\nrepository will be reflected in a pull request even after the request has been\nopened. This way changes that are made as a result of the discussion can be\neasily incorporated. Once you're ready go back to the **Conversation** tab and click\nthe green \"Merge pull request\" button, then click the green \"Confirm merge\"\nbutton that appears. This will `git merge` the \"compare\" branch into the \"base\"\nbranch on our remote repository. You just merged your first pull request! Now\nclick near the top left corner of this page on the **<> Code** tab, and you\nshould see that the changes from the `update-readme` branch have been merged\ninto `master`.\n\nWhen working on a remote GitHub repository with many other folks, these pull\nrequests and merges can happen without you being involved at all if the commits\naffect parts of the code that you're not working on. Still it's important to\nkeep your local repository up to date with the latest changes in the remote\nrepository. Let's go back to your terminal where you have `my-first-repo` set\nas the current working directory. First let's switch to the `master` branch.\n\n```{r, engine='bash', eval=FALSE}\ngit checkout master\n```\n\nNow let's update our local master branch with the commits that have been merged\ninto the master branch on our remote repository. We can accomplish this with\nthe command `git pull`:\n\n```{r, engine='bash', eval=FALSE}\ngit pull\n```\n\n```\n## remote: Counting objects: 1, done.\n## remote: Total 1 (delta 0), reused 0 (delta 0), pack-reused 0\n## Unpacking objects: 100% (1/1), done.\n## From https://github.com/seankross/my-first-repo\n##    2169912..b9217f6  master     -> origin/master\n## Updating 2169912..b9217f6\n## Fast-forward\n##  README.md | 38 ++++++++++++++++++--------------------\n##  file1.txt |  0\n##  file2.txt |  0\n##  3 files changed, 18 insertions(+), 20 deletions(-)\n##  delete mode 100644 file1.txt\n##  delete mode 100644 file2.txt\n```\n\nWith `git pull` Git finds the `master` branch on the `origin` remote repository\nand updates our local repository with the new commits. You've now completed the\nfull pull request life cycle! In the **Forking** section of this chapter we'll\ncome back to discussing how GitHub super-charges pull requests in order to\nfoster a greater coding community.\n\n### Pages\n\nFor now we're going to take a little detour to discuss\n[GitHub Pages](https://pages.github.com/). GitHub Pages allows you to create\nand host a website on GitHub using only Git and Markdown. Go back to your\n`my-first-repo` repository page on GitHub on click the *Settings* tab at the\ntop. Scroll down the page until you see a box that says **GitHub Pages**. Then\nclick on the drop-down menu that says **None**. You should see a screen like\nthis:\n\n![](images/select-pages.png)\n\nClick *master branch* and then click *Save*. Now go to the website\n[your-github-username].github.io/my-first-repo (in my case the address is\n[seankross.github.io/my-first-repo](http://seankross.github.io/my-first-repo))\nand you should see your very own website!\n\n![](images/my-website.png)\n\nHow cool is that!? If you want to change your new website all you need to do\nis edit your `README.md` then commit and push the changes! Websites like these\nare great for showing off projects, providing software documentation, creating\nonline resumes, or writing a blog! GitHub pages websites can be as simple as a\nfew Markdown documents, or if you know some web programming you can turn\nthem into complex websites. For more information about GitHub Pages you can\ncheck out the [documentation here](https://pages.github.com/).\n\n### Forking\n\nIf you're reading this book it's fairly safe to say that you probably interact\nwith software every day. Software powers your computer, the internet, your\nphone, and this book. Considering all of the software you use, have you ever\nthought about modifying that software? Perhaps you could write some code to add\na new feature you think would be useful or to fix a glitch that you've noticed.\nGitHub makes modifying other people's software easy through the process of\n**forking**. Forking a GitHub repository copies somebody else's GitHub\nrepository into your GitHub account. You can then modify this copy of their\nsoftware however you like. After you've added some commits to your copy of the\nrepository you can keep the new commits to yourself, share them with\nothers, or you can open up a **pull request** for your new commits to be merged\ninto the original source repository. This original source repository (the\nrepository you forked) is often called the *upstream* repository.\n\nLet's try forking a repository now. Go to\nhttps://github.com/seankross/the-unix-workbench and click the **Fork** button\nin the upper right corner. GitHub will then ask you what account you want to\nuse to fork the repository. If you're a new GitHub user then you only have one\naccount, so select that account. After a brief \"please wait\" screen you should\nthen see the forked repository at the URL\nhttps://github.com/[your-github-username]/the-unix-workbench. You've now forked\nthe repository for this book! In order to get a local copy of the repository \nyou'll need to use the `git clone` command. Cloning a repository copies a Git \nrepository to your computer while keeping track of the remote repository that \nit originated from. Let's clone your fork of my repository now. On the right \nside of the repository page you should see a green button that says **Clone or \ndownload**. Click that button and the following menu should appear:\n\n![](images/clone-wb.png)\n\nClick on the little clipboard icon which will copy the Git URL. Now go back to\nthe terminal and change your working directory to your home directory.\n\n```{r, engine='bash', eval=FALSE}\ncd\npwd\n```\n\n```\n## /Users/sean\n```\n\nNow let's clone the repository. Type `git clone` into the terminal and then\npaste in the Git URL we copied from GitHub:\n\n```{r, engine='bash', eval=FALSE}\ngit clone https://github.com/[your-github-username]/the-unix-workbench.git\n```\n\n```\n## Cloning into 'the-unix-workbench'...\n## remote: Counting objects: 669, done.\n## remote: Compressing objects: 100% (7/7), done.\n## remote: Total 669 (delta 2), reused 8 (delta 2), pack-reused 660\n## Receiving objects: 100% (669/669), 4.00 MiB | 4.55 MiB/s, done.\n## Resolving deltas: 100% (510/510), done.\n```\n\nNow `cd` into your cloned repository.\n\n```{r, engine='bash', eval=FALSE}\ncd the-unix-workbench\n```\n\nYou've just successfully completed your first Git clone! Like we mentioned\nbefore, cloning has the advantage of keeping track of the remote repository that\nshould be associated with the local repository. Let's test this by entering\n`git remote` with the added `-v` flag:\n\n```{r, engine='bash', eval=FALSE}\ngit remote -v\n```\n\n```\n## origin\thttps://github.com/[your-github-username]/the-unix-workbench.git (fetch)\n## origin\thttps://github.com/[your-github-username]/the-unix-workbench.git (push)\n```\n\nAs you can see the default name of the remote repository after you clone that\nrepository is `origin`. Now that you've cloned your fork you should add a\ncommit! One change that I suggest is adding your name to `guestbook.md`. Let's\ndo this now:\n\n```{r, engine='bash', eval=FALSE}\necho \"- Sean Kross\" >> guestbook.md # Add your own name of course!\ncat guestbook.md\n```\n\n```\n## # Guest Book\n##\n## - Sean Kross\n```\n\nNow add, commit, and push your changes:\n\n```{r, engine='bash', eval=FALSE}\ngit add guestbook.md\ngit commit -m \"added my name to guestbook.md\"\ngit push\n```\n\nNow that you've added your name to the guest book you can merge your change into\nmy version of the guest book by opening up a new pull request as described in\nthe previous section. If your pull request to the guest book is merged into the\nupstream repository (by me) then you will have completed the full GitHub\nlifecycle!\n\nThe process of forking a repository, making changes, and then opening a pull\nrequest is a very powerful workflow for seeing changes that you want made in\nthe software world. Many large and important software projects have repositories\non GitHub including [operating systems](https://github.com/torvalds/linux),\n[programming languages](https://github.com/golang/go),\nand even [Git itself](https://github.com/git/git)! If there's a change you want\nto see in a public GitHub repository, fork that repository and make the change!\n\n### Summary\n\n- You can use GitHub to create and host remote Git repositories.\n- A remote Git repository is a Git repository that is always connected to the\ninternet.\n- List remote repositories with `git remote`.\n- Add remote repositories with `git remote add [name-of-remote] https://github.com/[username]/[repo-name].git`\n- Add commits to your remote repository with `git push [name-of-remote] [name-of-branch]`\nor just `git push` if you've set up a default remote and branch.\n- To merge commits on a remote repository into your local repository use\n`git pull [name-of-remote] [name-of-branch]` or just `git pull` if you've set\nup a default remote and branch.\n- A pull request allows you to interactively compare two different branches\nbefore you merge them.\n- GitHub Pages allows you to host websites written in Markdown for free!\n- Forking a repository allows you to make changes to a copy of a public\nrepository. You can then open a pull request if you think your changes should\nbe merged into the upstream repository!\n\n### Exercises\n\n1. Create a new repository on GitHub. Clone your repository and add a\n`README.md` file. Push this file to GitHub and create a GitHub Pages website\nfor this repository.\n2. Fork an existing repository (try one of mine: https://github.com/seankross)\nand try to identify something valuable you could contribute. Make changes or\nadditions to that repository, then open a pull request.\n3. Read through [GitHub's Guides](https://guides.github.com/).\n"
        },
        {
          "name": "07-Nephology.Rmd",
          "type": "blob",
          "size": 25.8515625,
          "content": "# Nephology\n\n> I saw a city in the clouds. - Dagobahnian proverb\n\n## Introduction to Cloud Computing\n\nNephology is the study of clouds. Few modern technology concepts (other than\nmaybe data science and artificial intelligence) have been hyped as loudly as \"the\ncloud.\" The cloud is simply a computer which we can access over the internet.\nIn this chapter we'll set up a cloud computer and we'll learn the basics of\ninteracting with one.\n\nTo get the most out of this chapter you're going to need your credit or\ndebit card, or a [PayPal](https://www.paypal.com) account. We're going to be\nusing [DigitalOcean](https://m.do.co/c/530d6cfa2b37), a company which we\ncan rent cloud computers from. Throughout this chapter I might refer to cloud\ncomputers as **servers** (computers connected to the internet) or as\n**droplets**, which is a marketing term DigitalOcean uses to refer to their\nservers (a droplet is *not* a technical term). Renting from DigitalOcean won't\ncost you any money since I'm giving you a coupon for two free months of service!\nThere are several companies that offer similar services compared to\nDigitalOcean, but in my opinion they have the best user interface and the most\ntransparent pricing model.\n\n**Warning:** *At the end of this chapter we will discuss how to shut down any\nservers we've started on DigitalOcean. If you don't shut down your server\nafter two months then your account will be charged real money for using\nDigitalOcean. Please be sure to shut down any servers you start after you are\nfinished using them.*\n\n## Setting Up DigitalOcean\n\nTo get started with DigitalOcean we need to rent a server from their website.\n[Click this link](https://m.do.co/c/530d6cfa2b37) to sign up for DigitalOcean\nin order to get two free months of server use. (If you don't use this link then\nyou don't get two free months). Click **Sign Up** in the upper right corner,\nthen enter your email address and choose your password.\n\n![](images/do-main.png)\n\nCheck your email for a message from DigitalOcean and click the enclosed link to\nconfirm your email. Then you'll need to enter your credit or debit card\ninformation, or your Paypal account details. As long as you close down all of\nyour servers less than two months after you start them you will not be charged.\nAfter entering in your payment information you should see this screen:\n\n![](images/do-create-drop.png)\n\nClick the big blue **Create a new Droplet** button which should then bring you\nto a screen where you can customize the server you're going to be renting. Make\nsure you have Ubuntu chosen as your distribution, and select the $5 per month\nsize option:\n\n![](images/do-distro-size.png)\n\nScroll down the page and then select the region that is geographically closest\nto you. Some regions have multiple data centers, it doesn't matter which data\ncenter you pick. Currently I'm in Baltimore, Maryland, USA, so I'm going to pick\nthe number 1 data center in New York:\n\n![](images/do-region.png)\n\nFinally at the bottom of the page click the big green **Create** button in order\nto start your server!\n\n![](images/do-create-confirm.png)\n\nIt will take a minute to launch the server, but once launched\nyou should receive an email from Digital Ocean with the details about your\nnew server. Included in this email you should find the IP address of your\nserver, the default username (which should be `root`) and a\nrandomly generated password that you will need to connect to\nyour server for the first time. Once you've received this email open up a new\nterminal.\n\n## Connecting to the Cloud\n\nWe can connect to computers on the internet with the `ssh` program, which\nstands for **S**ecure **Sh**ell. The `ssh` command provides a command line\ninterface to whichever computer we point it to. A computer that is connected to\nthe internet has an address (just like a house has an address) which is\nspecified by an **IP address**. The command for connecting to a computer with\n`ssh` generally looks like this:\n\n```{r, engine='bash', eval=FALSE}\nssh [username]@[IP address]\n```\n\nLet's connect to our DigitalOcean server using `ssh`. Enter the following\ncommand in the terminal substituting the IP address you received from\nDigitalOcean for the IP address I'm using in this example:\n\n```{r, engine='bash', eval=FALSE}\nssh root@159.203.134.88\n```\n\n```\n## The authenticity of host '159.203.134.88 (159.203.134.88)' can't be established.\n## ECDSA key fingerprint is SHA256:UhtoIx/3c6/MmAIE+H8w5oGE06PsbXdzRRsAUhKtjhs.\n## Are you sure you want to continue connecting (yes/no)?\n```\n\nType `yes` and then press Enter.\n\n```\n## Warning: Permanently added '159.203.134.88' (ECDSA) to the list of known hosts.\n## root@159.203.134.88's password:\n```\n\nThis password should be in the email you received from DigitalOcean. Copy and\npaste the password into the terminal, then press Enter.\n\n```\n## You are required to change your password immediately (root enforced)\n## Welcome to Ubuntu 16.04.2 LTS (GNU/Linux 4.4.0-78-generic x86_64)\n## \n##  * Documentation:  https://help.ubuntu.com\n##  * Management:     https://landscape.canonical.com\n##  * Support:        https://ubuntu.com/advantage\n## \n##   Get cloud support with Ubuntu Advantage Cloud Guest:\n##     http://www.ubuntu.com/business/services/cloud\n## \n## 0 packages can be updated.\n## 0 updates are security updates.\n## \n## \n## \n## The programs included with the Ubuntu system are free software;\n## the exact distribution terms for each program are described in the\n## individual files in /usr/share/doc/*/copyright.\n## \n## Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by\n## applicable law.\n## \n## Changing password for root.\n## (current) UNIX password:\n```\n\nWe now need to create a new password for this server. First paste in the old\npassword and press Enter. Then think of a new, strong password and enter it into\nthe console. Then enter the new password again to confirm. After entering in the\nnew password we should have a prompt! Press enter a few times to make sure that\nyou get the prompt back each time. We're in!\n\nNow we have access to all of the Unix commands we would normally have:\n\n```{r, engine='bash', eval=FALSE}\npwd\n```\n\n```\n## /root\n```\n\nIn order to disconnect from the server and return to your machine use `logout`.\n\n```{r, engine='bash', eval=FALSE}\nlogout\n```\n\n```\n## Connection to 159.203.134.88 closed.\n```\n\nTo reconnect to the server use `ssh` again:\n\n```{r, engine='bash', eval=FALSE}\nssh root@159.203.134.88\n```\n\n```\n## root@159.203.134.88's password:\n```\n\nEnter your password and you should get the prompt back for your cloud server.\n\n### Summary\n\n- `ssh` connects you to computers that are connected to the internet. The\ntemplate for the command to connect is `ssh [username]@[IP address]`.\n- To disconnect from an `ssh` session use the `logout` command.\n\n## Cloud Computing Basics\n\n### Moving Files In and Out of the Cloud\n\nSo now that we have a cloud computer, what can we do with it? One thing we\ncan do is store and retrieve files from a cloud computer. The program `scp`\nallows us to copy local files to a server and it allows us to copy files on\na server to our local computer. First let's connect to our server so we can\ncreate a file there:\n\n```{r, engine='bash', eval=FALSE}\nssh root@159.203.134.88\n```\n\n```\n## root@159.203.134.88's password:\n## # (Enter your password)\n```\n\n```{r, engine='bash', eval=FALSE}\nmkdir textfiles\necho \"From the server\" > textfiles/server-file.txt\nlogout\n```\n\n```\n## Connection to 159.203.134.88 closed.\n```\n\nNow that we're back at the prompt on our local machine let's try getting\n`server-file.txt` from our server. The arguments for copying files from a server\nwith `scp` have the following general structure:\n\n```{r, engine='bash', eval=FALSE}\nscp [username]@[IP address]:path/to/file/on/server path/on/my/computer\n```\n\nThis copies the file located on the server at `path/to/file/on/server` to a\nlocal path at `path/on/my/computer`. In the same way we can copy an entire\nfolder from a server using the `-r` flag:\n\n```{r, engine='bash', eval=FALSE}\nscp -r [username]@[IP address]:path/to/folder/on/server folder/on/my/computer\n```\n\nLet's try doing this now from our local computer. Enter your password when\nasked to do so:\n\n```{r, engine='bash', eval=FALSE}\ncd\npwd\n```\n\n```\n## /Users/sean/\n```\n\n```{r, engine='bash', eval=FALSE}\nmkdir Cloud\ncd Cloud\nscp root@159.203.134.88:/root/textfiles/server-file.txt downloaded.txt\n```\n\n```\n## root@159.203.134.88's password:\n## server-file.txt                                         100%   16     1.2KB/s   00:00\n```\n\n```{r, engine='bash', eval=FALSE}\ncat downloaded.txt\n```\n\n```\n## From the server\n```\n\nIt worked! Now let's try uploading a file to our server. The arguments for doing\nthis are just the swapped arguments for downloading a file from a server:\n\n```{r, engine='bash', eval=FALSE}\nscp path/on/my/computer [username]@[IP address]:path/to/file/on/server \n```\n\nLet's create a file and upload it to our server:\n\n```{r, engine='bash', eval=FALSE}\necho \"from local computer\" > to-upload.txt\nscp to-upload.txt root@159.203.134.88:/root/textfiles/uploaded-file.txt\n```\n\n```\n## root@159.203.134.88's password:\n## to-upload.txt                                           100%   20     1.8KB/s   00:00\n```\n\nNow let's log in to our server and we'll see if it's there:\n\n```{r, engine='bash', eval=FALSE}\nssh root@159.203.134.88\ncat textfiles/uploaded-file.txt\n```\n\n```\n## from local computer\n```\n\nLooks like it worked! Keeping files in the cloud allows you to work with the\nsame files in the same workspace as long as you have access to a terminal and\n`ssh`.\n\n### Talking to Other Servers\n\nThere are tons of servers out there on the internet! The way you're probably\nused to talking to a server is through a web browser, but there are other ways\nwe can talk to servers on the command line. One of the most popular command line\nprograms for talking to other servers is `curl`. The `curl` command allows us\nto send requests and information to other servers.\n\nOne easy task that we can use `curl` for is downloading files that are available\nonline. For example, this entire book and all of the files associated with it\nare hosted on a server! You can find the Markdown file for one of the first\nchapters of this book [here](http://seankross.com/the-unix-workbench/01-What-is-Unix.md).\nTo download a file with `curl`, we simply need to provide the `-O` flag and the\nURL of the file:\n\n```{r, engine='bash', eval=FALSE}\ncurl -O http://website.org/textfile.txt\n```\n\nLet's try downloading the Markdown file from my website:\n\n```{r, engine='bash', eval=FALSE}\ncurl -O http://seankross.com/the-unix-workbench/01-What-is-Unix.md\n```\n\n```\n##   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n##                                  Dload  Upload   Total   Spent    Left  Speed\n## 100  1198  100  1198    0     0  13681      0 --:--:-- --:--:-- --:--:-- 13770\n```\n\n```{r, engine='bash', eval=FALSE}\nhead -n 5 01-What-is-Unix.md\n```\n\n```{r, engine='bash', echo=FALSE}\nhead -n 5 docs/01-What-is-Unix.md\n```\n\nLooks like we got the file! The `curl` command is also commonly used for\ncommunicating with **API**s. API stands for **a**pplication\n**p**rogramming **i**nterface. APIs are a set of rules which allow us to\ncommunicate with computer programs or with servers on the web. GitHub has a\n[large API](https://developer.github.com/v3/) which allows us to find out\ninformation about GitHub's users and repositories. Let's use `curl` to look \nat what programming languages are used by some of my repositories. Let's start\nwith the repository for this book:\n\n```{r, engine='bash', eval=FALSE}\ncurl https://api.github.com/repos/seankross/the-unix-workbench/languages\n```\n\n```\n{\n  \"CSS\": 2615,\n  \"TeX\": 22\n}\n```\n\nIt looks like most of the repository is dedicated to making the book website\nlook pretty! Take a look at the URL in the `curl` command above, and let's\ndissect it a little bit. The API itself is located at `https://api.github.com/`.\nThen each word in the rest of the url acts as a sort of argument. We're\ninterested in `repos` in this case, specifically a repo belonging to the\nusername `seankross` called `the-unix-workbench`, and we want to know about\nwhich `languages` are used in that repo. Let's take a look at one more of my\nrepositories just to see how the response can be different:\n\n```{r, engine='bash', eval=FALSE}\ncurl https://api.github.com/repos/seankross/lego/languages\n```\n\n```\n{\n  \"R\": 4197,\n  \"Shell\": 442\n}\n```\n\nUse of `curl`, especially when coupled with using APIs can become very\ncomplicated and much more advanced content has been written on the subject.\nLet's get a little more in depth by looking through some of the examples from\n[httpbin.org](http://httpbin.org/). This website allows us to send requests to\nit with `curl`, and it will return to us a structured version of whatever\ninformation we sent. This is useful for debugging our `curl` commands. First\nlet's send a request which should return our IP address:\n\n```{r, engine='bash', eval=FALSE}\ncurl http://httpbin.org/ip\n```\n\n```\n{\n  \"origin\": \"159.203.134.88\"\n}\n```\n\nLooks like we're getting the response we expect. Before we go on I should\nclarify: `curl` sends **HTTP requests**. HTTP is a technology for sending\ninformation over a network, and HTTP powers much of how the internet works.\nThere are different categories of HTTP requests, and the categories are often\ncalled **verbs**. When we use `curl` without any flags we are sending a\n**GET** request (GET is an HTTP verb). A GET request is a message that says to\na server: \"Hi, I live at [IP address]. Would you mind sending some information\nabout yourself to that IP?\" In the case above we asked for our own IP address,\nwhich httpbin.org knew to just send back to us.\n\nLet's send a general HTTP GET request to http://httpbin.org/get:\n\n```{r, engine='bash', eval=FALSE}\ncurl http://httpbin.org/get\n```\n\n```\n{\n  \"args\": {},\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Connection\": \"close\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"curl/7.47.0\"\n  },\n  \"origin\": \"159.203.134.88\",\n  \"url\": \"http://httpbin.org/get\"\n}\n```\n\nThe text that we get back from the request specifies four information groups:\n`args`, `headers`, `origin`, and `url`. The `origin` shows our own IP address,\nand `url` shows where we sent the request. The `headers` group shows some\ninteresting information, including the `User-Agent` which shows that httpbin.org\nknows that we sent this request with `curl`. Notice that the `args` group is\nempty. The `args` group is short for *arguments*, which hints at the fact that\nwe can provide arguments in an HTTP request, just like arguments we would use\nfor a function, or the arguments we used in the GitHub API.\n\nIn the general case we can provide arguments to an HTTP API by putting a\nquestion mark (`?`) after the API's URL. Let's try this out:\n\n```{r, engine='bash', eval=FALSE}\ncurl http://httpbin.org/get?Baltimore\n```\n\n```\n{\n  \"args\": {\n    \"Baltimore\": \"\"\n  },\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Connection\": \"close\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"curl/7.47.0\"\n  },\n  \"origin\": \"159.203.134.88\",\n  \"url\": \"http://httpbin.org/get?Baltimore\"\n}\n```\n\nLooks like `\"Baltimore\"` showed up in `args`! For most HTTP APIs we need to\ngive names to our arguments, unlike most arguments in Bash. We can specify\nan argument's name with the template `[argument name]=[argument value]`. Let's\ntake a look at a simple example:\n\n```{r, engine='bash', eval=FALSE}\ncurl http://httpbin.org/get?city=Baltimore\n```\n\n```\n{\n  \"args\": {\n    \"city\": \"Baltimore\"\n  },\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Connection\": \"close\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"curl/7.47.0\"\n  },\n  \"origin\": \"159.203.134.88\",\n  \"url\": \"http://httpbin.org/get?city=Baltimore\"\n}\n```\n\nNow we can see that in `args` there's a correspondence between `city` and\n`Baltimore`. We can add more named arguments by separating them with an \nampersand (`&`):\n\n\n```{r, engine='bash', eval=FALSE}\ncurl \"http://httpbin.org/get?city=Baltimore&state=Maryland\"\n```\n\n```\n{\n  \"args\": {\n    \"city\": \"Baltimore\",\n    \"state\": \"Maryland\"\n  },\n  \"headers\": {\n    \"Accept\": \"*/*\",\n    \"Connection\": \"close\",\n    \"Host\": \"httpbin.org\",\n    \"User-Agent\": \"curl/7.47.0\"\n  },\n  \"origin\": \"159.203.134.88\",\n  \"url\": \"http://httpbin.org/get?city=Baltimore&state=Maryland\"\n}\n```\n\nPerhaps you could imagine building a server that accepts HTTP requests, and\nsends back different information depending on what arguments are provided (for\nexample, send back a weather report given a location). Building these kinds of\nservers is an advanced topic that is outside the scope of this book, but there\nare lots of resources out there if you're interested in building your own HTTP\nAPI on a web server.\n\n\n### Automating Tasks\n\nOne of the most compelling features about any web server is that it's always\npowered on and always connected to the internet. This means that we can instruct\nour server to perform tasks automatically, without us needing to enter a command\ninto a shell. One of the most commonly used programs for executing *other programs*\nwith a regular frequency is called `cron`. Let's take a look at how to use\n`cron` to schedule a program to be run.\n\nIf you're not already connected to the server use `ssh` to connect.\n\n```{r, engine='bash', eval=FALSE}\nssh root@159.203.134.88\n```\n\nThe `cron` program is part of a family of programs called **daemons**. A daemon\nis a program that is always running in the background of our computer. First, \nlet's see if `cron` is running. We can get a list of all running programs\nwith the `ps` command while using the `-A` flag:\n\n```{r, engine='bash', eval=FALSE}\nps -A\n```\n\n```\n##  PID TTY          TIME CMD\n##    1 ?        00:00:13 systemd\n##    2 ?        00:00:00 kthreadd\n##    3 ?        00:00:03 ksoftirqd/0\n##    5 ?        00:00:00 kworker/0:0H\n##    7 ?        00:00:11 rcu_sched\n##    8 ?        00:00:00 rcu_bh\n##    9 ?        00:00:00 migration/0\n## ...\n```\n\nYou probably have a huge list of programs in your terminal now! Instead of\nsifting through this listing line-by-line, let's pipe the output of this command\nto `grep` and we'll look for `cron`:\n\n```{r, engine='bash', eval=FALSE}\nps -A | grep \"cron\"\n```\n\n```\n##  1273 ?        00:00:01 cron\n```\n\nLooks like the `cron` daemon is running! In order to assign programs to be\nexecuted with `cron` we need to edit a special text file called the `cron`\ntable. Before we edit the `cron` table we need to select the default text\neditor. If you like using `nano` (the text editor we've been using throughout\nthis book) then enter `select-editor` into the console, type in the number\nthat corresponds to `nano` (usually `2`) and then press enter:\n\n```{r, engine='bash', eval=FALSE}\nselect-editor\n```\n\n```\n## Select an editor.  To change later, run 'select-editor'.\n##   1. /bin/ed\n##   2. /bin/nano        <---- easiest\n##   3. /usr/bin/vim.basic\n##   4. /usr/bin/vim.tiny\n## \n## Choose 1-4 [2]:\n```\n\nNow that we've chosen a text editor we can edit the `cron` table using the\ncommand `crontab -e` (**`cron`** **tab**le **e**dit) which will automatically\nopen `nano` with the appropriate file.\n\n```{r, engine='bash', eval=FALSE}\ncrontab -e\n```\n\n```\n# Edit this file to introduce tasks to be run by cron.\n#\n# m h  dom mon dow   command\n\n```\n\nLet's go over the layout of the `cron` table. First you should notice that any\ntext after a pound sign (`#`) is a comment, so it's not seen by `cron` (just\nlike bash comments). The `cron` table has six columns:\n\n1. Minute (`m`)\n2. Hour (`h`)\n3. Day of Month (`dom`)\n4. Month (`mon`)\n5. Day of Week (`dow`)\n6. Command to be run (`command`)\n\nEach column is separated by a single space in the table. The first five columns \nallow you to specify when you want a particular command to be run. Only certain \nvalues are valid in each column:\n\n1. Minute: `00 - 59` (A particular minute in an hour)\n2. Hour: `00 - 23` (0 is the midnight hour)\n3. Day of Month: `01 - 31` (1 is the first day of the month)\n4. Month: `01 - 12` (1 is January)\n5. Day of Week `0 - 6` (0 is Sunday)\n\nThere are also a few other characters that are valid in the `cron` table. The\nmost commonly used character is a star (`*`) which represents *all* of the\npossible values in a column. So a star in the Minute column means \"run every\nminute,\" and a star in the Hour column means \"run during every hour.\"\nKnowing this let's make our first entry in the `cron` table. If we want a\ncommand to be executed every minute, during every hour, on every day of the\nmonth, during every month, on every day of the week, then we can put stars in\nall of the first five\ncolumns, followed by the command that we want to run. In this case the command\nthat `cron` will run every minute will be `date >> ~/date-file.txt`, which will\nappend the date and time when the command is executed to a file in our home\ndirectory called `date-file.txt`. This is what your `cron` table should look\nlike before you save and exit from `nano`:\n\n```\n# Edit this file to introduce tasks to be run by cron.\n#\n# m h  dom mon dow   command\n* * * * * date >> ~/date-file.txt\n```\n\nSave and exit `nano` just like you would for a regular text file and then wait\na little bit! After a minute has gone by use `cat` to look at `~/date-file.txt`:\n\n```{r, engine='bash', eval=FALSE}\ncd\ncat date-file.txt\n```\n\n```\n## Thu Jun  8 18:50:01 UTC 2017\n```\n\nLook like our entry in the `cron` table is working! Wait another minute and then\nlook at the file again:\n\n```{r, engine='bash', eval=FALSE}\ncat date-file.txt\n```\n\n```\n## Thu Jun  8 18:50:01 UTC 2017\n## Thu Jun  8 18:51:01 UTC 2017\n```\n\nUnless we delete the line that we entered in the `cron` table, the output from\n`date` will be appended to `date-file.txt` every minute.\n\nThe single line of bash `date >> ~/date-file.txt` is a much simpler program than\nwe would probably use in a `cron` table, though it's good for illustrating how\na `cron` table works. If you want to do more complex tasks with `cron` it's\nbetter for `cron` to execute a bash script that you've written in advance. That\nway you can just specify `bash /path/to/script.sh` in the last column of the\ntable.\n\nUsing stars in all columns is the simplest line of a `cron` table, so let's \nlook at some examples of more complex table entries:\n\n```\n# m h  dom mon dow   command\n00 * * * * bash /path/to/script.sh     # Runs every hour at the start of the hour\n00 12 * * * bash /path/to/script.sh    # Runs every day at noon\n* 12 * * * bash /path/to/script.sh     # Runs every minute between 12pm and 12:59pm\n00 00 05 * * bash /path/to/script.sh   # Runs the 5th day of every month at midnight\n00 00 * 07 * bash /path/to/script.sh   # Runs every day in the month of July at midnight\n00 00 * * 2 bash /path/to/script.sh    # Runs every Tuesday at midnight\n```\n\nBesides numbers and the star there are a few other characters that you can use\nin `cron` table columns including a hyphen (`-`) for specifying ranges and a\ncomma (`,`) for specifying lists of items. For example `00-29` in the Minutes\ncolumn would specify the first thirty minutes of an hour, while `1,5` in the\nDay of Week column would specify Monday and Friday.\n\nLet's take a look at another example of a `cron` table that uses hyphens and \nranges so you can get a sense of how each character works.\n\n```\n# m h  dom mon dow   command\n00-04 * * * * bash /path/to/script.sh       # Runs every minute for the first five minutes of every hour\n00 00 * * 0,6 bash /path/to/script.sh       # Runs at midnight every Saturday and Sunday\n00 03 01-15 * * bash /path/to/script.sh     # Runs at 3am for the first fifteen days of every month \n00,30 * * * * bash /path/to/script.sh       # Runs at the start and middle of every hour\n00 00,12 * * * bash /path/to/script.sh      # Runs every day at midnight and noon\n00 * 01-07 01,06 * bash /path/to/script.sh  # Runs at the start of every hour for the first seven days of the months of January and June\n```\n\nA program that is being run by `cron` is only as powerful as your imagination\ncan stretch! If you're familiar with the social network\n[Twitter](https://twitter.com/) then you might have come across some Twitter\naccounts which create posts automatically like\n[Emoji Aquarium](https://twitter.com/emojiaquarium),\n[Old Fruit Pictures](https://twitter.com/pomological), or\n[Endless Screaming](https://twitter.com/infinite_scream). Many of these \"bot\"\naccounts are powered by `cron`, which uses Twitter's HTTP API to post tweets\nregularly.\n\n### Summary\n\n- `scp` copies files between a cloud computer and your personal computer. Use\nthe `-r` flag in order to copy directories.\n- `curl` allows you to send HTTP requests to other servers. Use the `-O` flag to\ndownload files with `curl`.\n- `ps -A` lists all of the programs running in the background of your computer.\n- `cron` allows you to schedule when programs are run. Use `crontab -e` in order\nto edit the `cron` table.\n\n### Exercises\n\n1. Write a bash script that takes a file path as an argument and copies that\nfile to a designated folder on your server.\n2. Find a file online that changes periodically, then write a program to\ndownload that file every time it changes.\n2. Try creating your own Twitter or GitHub bot with the \n[Twitter API](https://dev.twitter.com/rest/public) or the\n[GitHub API](https://developer.github.com/v3/).\n\n## Shutting Down a Server\n\nIn order to avoid using more DigitalOcean credits than we have to or\nbeing charged for using the service make sure to **destroy** any DigitalOcean\ndroplets that you started. When you destroy a droplet all files\non the droplet are gone forever, so please be sure that you don't have any\nimportant information on a droplet before you destroy it. If there are files\nyou want to save on your droplet use `scp` in order to copy them to your local\nmachine. Let's walk through destroying a droplet. Go back to \n[DigitalOcean](https://m.do.co/c/530d6cfa2b37) and log in. You should then see\na listing of all of your droplets:\n\n![](images/do-droplets-list.png)\n\nClick on **More** on the right side of the screen and a menu should appear.\nClick **Destroy** at the bottom of this menu. Then this screen should appear:\n\n![](images/do-destroy-button.png)\n\nClick the **Destroy** button and then click **Confirm** in the menu that pops\nup. Your droplet should now be destroyed. If you have no active droplets then\nthe main droplets page should look like this:\n\n![](images/do-fresh.png)\n\nCongratulations on your new cloud computing skills!\n"
        },
        {
          "name": "08-Start-Building.Rmd",
          "type": "blob",
          "size": 3.87109375,
          "content": "# Start Building\n\n## Next Steps\n\nWe've reached the end of this book, which means that you now have a formidable\nfoundation in using Unix. Congratulations! As the title of this book suggests\nUnix serves mostly as a workbench - a set of tools for building amazing digital\ncreations. However, what you can create with Unix is usually not made out of\nUnix's constituent parts. You might use a hammer and saw to build a good\nbirdhouse, but the birdhouse itself isn't made out of hammers. Working knowledge\nof Unix is best complemented by knowing at least one other programming language.\nHere are a few suggestions about how you can continue your computing and\nprogramming education.\n\n[**Python**](https://www.python.org/) is an approachable and essential language\nfor anyone interested in computing. If you don't have any programming experience\noutside of this book, I very highly recommend learning Python. My favorite book\non the subject is [Learn Python the Hard Way](https://learnpythonthehardway.org/book/)\nby Zed Shaw. Philip Guo's [Python Tutor](http://pythontutor.com/) allows you to\nvisualize how Python is working under-the-hood, which allows you to develop a\nbetter intuition about the code you're writing. The pairing of those two\nresources is currently the best way to learn how to write software outside of\nformal university or corporate training. Once you have some Python experience\nyou can try building your own HTTP API with [Flask](http://flask.pocoo.org/).\n\n[**R**](https://www.r-project.org/) is a general purpose programming language\ndesigned for folks who are interested in data science, analysis, modeling, and\nvisualization. R is also fantastic for making digital documents: this book was\ncreated with R! If you want to get started with R I recommend the book \n[R Programming for Data Science](https://leanpub.com/rprogramming), the\n[Swirl](http://swirlstats.com/) software package, and the interactive R\ntutorial website called [DataCamp](https://www.datacamp.com/).\n\n[**JavaScript**](https://developer.mozilla.org/en-US/docs/Web/JavaScript) is \nthe main language that powers the internet and it forms the backbone of web\napplication programming. The Mozilla Development Network has \n[wonderful tutorials](https://developer.mozilla.org/en-US/docs/Web/Tutorials)\nabout HTML, CSS, and JavaScript. Usually you use JavaScript to manipulate\nHTML and CSS, so learning about all three is important! I also recommend\n[NodeSchool](https://nodeschool.io/) for purely learning about JavaScript with\nUnix.\n\n## Giving Feedback\n\nThank you so much for reading this book! If you'd like to discuss the book or\nyou have any feedback I would love to hear from you. The best way to contact me\nis [on Twitter](https://twitter.com/seankross).\n\nNow that you know how to use Git and GitHub you can submit changes that you\nthink should be made to this book including fixing typos and correcting errors.\nYou can find the repository for this book\n[here](https://github.com/seankross/the-unix-workbench). Fork the repository,\nand make your changes to the appropriate `.Rmd` file (just treat it like a\nregular Markdown file). Add, commit, and push your changes, then send me a pull\nrequest! While you're on the GitHub if you wouldn't mind giving this book's\nrepository a [**Star**](https://github.com/seankross/the-unix-workbench) I \nwould really appreciate it so that others can find this book more easily.\n\n## Using this Book\n\nThis book is released under a [CC0](https://creativecommons.org/publicdomain/zero/1.0/) \nlicense, meaning that it is dedicated to the public domain. If you think this\nbook is worth paying for or you want to support the creation of more open source \neducational materials then consider buying the book \non [Leanpub](https://leanpub.com/unix) where you are free to pay \nwhat you want, or send me a few dollars via [PayPal](https://www.paypal.me/seankross/5).\n\nIf you use this book as part of a course or in any other setting please let me\nknow!\n"
        },
        {
          "name": "CONDUCT.md",
          "type": "blob",
          "size": 1.3564453125,
          "content": "# Contributor Code of Conduct\n\nAs contributors and maintainers of this project, we pledge to respect all people who \ncontribute through reporting issues, posting feature requests, updating documentation,\nsubmitting pull requests or patches, and other activities.\n\nWe are committed to making participation in this project a harassment-free experience for\neveryone, regardless of level of experience, gender, gender identity and expression,\nsexual orientation, disability, personal appearance, body size, race, ethnicity, age, or religion.\n\nExamples of unacceptable behavior by participants include the use of sexual language or\nimagery, derogatory comments or personal attacks, trolling, public or private harassment,\ninsults, or other unprofessional conduct.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments,\ncommits, code, wiki edits, issues, and other contributions that are not aligned to this \nCode of Conduct. Project maintainers who do not follow the Code of Conduct may be removed \nfrom the project team.\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by \nopening an issue or contacting one or more of the project maintainers.\n\nThis Code of Conduct is adapted from the Contributor Covenant \n(http://contributor-covenant.org), version 1.0.0, available at \nhttp://contributor-covenant.org/version/1/0/0/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.974609375,
          "content": "# Contributing to The Unix Workbench\n\nContributions from anyone are welcome to this book! Please note that this\nproject is released with a [Contributor Code of Conduct](CONDUCT.md). By \nparticipating in this project you agree to abide by its terms.\n\n## How to Contribute\n\nFirst fork this repository and then clone your fork. Please only make changes\nto the `.md` and `.Rmd` files in the root of this directory. Once you've added,\ncommitted, and pushed your changes you should\n[submit a pull request](https://github.com/seankross/the-unix-workbench/compare/).\n\nIf you're new to Git and GitHub you should read the\n[chapter of this book](http://seankross.com/the-unix-workbench/git-and-github.html)\nwhich explains how to use both.\n\n## Adding Your Name to the Guestbook\n\nYou are strongly encouraged to add your name to `guestbook.md` via pull request \nafter reading the Git and GitHub section of this book. If you would like to\nadd other edits to the book, please make them in a separate pull request.\n"
        },
        {
          "name": "Crypto.Rmd",
          "type": "blob",
          "size": 0.06640625,
          "content": "# Crypto\n\n> After dark, all cats are leopards. - Zuni Indian proverb"
        },
        {
          "name": "DESCRIPTION",
          "type": "blob",
          "size": 0.1015625,
          "content": "Package: placeholder\nTitle: Does not matter.\nVersion: 0.0.1\nImports: bookdown\nRemotes: rstudio/bookdown\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 6.400390625,
          "content": "CC0 1.0 Universal\n\nStatement of Purpose\n\nThe laws of most jurisdictions throughout the world automatically confer\nexclusive Copyright and Related Rights (defined below) upon the creator and\nsubsequent owner(s) (each and all, an \"owner\") of an original work of\nauthorship and/or a database (each, a \"Work\").\n\nCertain owners wish to permanently relinquish those rights to a Work for the\npurpose of contributing to a commons of creative, cultural and scientific\nworks (\"Commons\") that the public can reliably and without fear of later\nclaims of infringement build upon, modify, incorporate in other works, reuse\nand redistribute as freely as possible in any form whatsoever and for any\npurposes, including without limitation commercial purposes. These owners may\ncontribute to the Commons to promote the ideal of a free culture and the\nfurther production of creative, cultural and scientific works, or to gain\nreputation or greater distribution for their Work in part through the use and\nefforts of others.\n\nFor these and/or other purposes and motivations, and without any expectation\nof additional consideration or compensation, the person associating CC0 with a\nWork (the \"Affirmer\"), to the extent that he or she is an owner of Copyright\nand Related Rights in the Work, voluntarily elects to apply CC0 to the Work\nand publicly distribute the Work under its terms, with knowledge of his or her\nCopyright and Related Rights in the Work and the meaning and intended legal\neffect of CC0 on those rights.\n\n1. Copyright and Related Rights. A Work made available under CC0 may be\nprotected by copyright and related or neighboring rights (\"Copyright and\nRelated Rights\"). Copyright and Related Rights include, but are not limited\nto, the following:\n\n  i. the right to reproduce, adapt, distribute, perform, display, communicate,\n  and translate a Work;\n\n  ii. moral rights retained by the original author(s) and/or performer(s);\n\n  iii. publicity and privacy rights pertaining to a person's image or likeness\n  depicted in a Work;\n\n  iv. rights protecting against unfair competition in regards to a Work,\n  subject to the limitations in paragraph 4(a), below;\n\n  v. rights protecting the extraction, dissemination, use and reuse of data in\n  a Work;\n\n  vi. database rights (such as those arising under Directive 96/9/EC of the\n  European Parliament and of the Council of 11 March 1996 on the legal\n  protection of databases, and under any national implementation thereof,\n  including any amended or successor version of such directive); and\n\n  vii. other similar, equivalent or corresponding rights throughout the world\n  based on applicable law or treaty, and any national implementations thereof.\n\n2. Waiver. To the greatest extent permitted by, but not in contravention of,\napplicable law, Affirmer hereby overtly, fully, permanently, irrevocably and\nunconditionally waives, abandons, and surrenders all of Affirmer's Copyright\nand Related Rights and associated claims and causes of action, whether now\nknown or unknown (including existing as well as future claims and causes of\naction), in the Work (i) in all territories worldwide, (ii) for the maximum\nduration provided by applicable law or treaty (including future time\nextensions), (iii) in any current or future medium and for any number of\ncopies, and (iv) for any purpose whatsoever, including without limitation\ncommercial, advertising or promotional purposes (the \"Waiver\"). Affirmer makes\nthe Waiver for the benefit of each member of the public at large and to the\ndetriment of Affirmer's heirs and successors, fully intending that such Waiver\nshall not be subject to revocation, rescission, cancellation, termination, or\nany other legal or equitable action to disrupt the quiet enjoyment of the Work\nby the public as contemplated by Affirmer's express Statement of Purpose.\n\n3. Public License Fallback. Should any part of the Waiver for any reason be\njudged legally invalid or ineffective under applicable law, then the Waiver\nshall be preserved to the maximum extent permitted taking into account\nAffirmer's express Statement of Purpose. In addition, to the extent the Waiver\nis so judged Affirmer hereby grants to each affected person a royalty-free,\nnon transferable, non sublicensable, non exclusive, irrevocable and\nunconditional license to exercise Affirmer's Copyright and Related Rights in\nthe Work (i) in all territories worldwide, (ii) for the maximum duration\nprovided by applicable law or treaty (including future time extensions), (iii)\nin any current or future medium and for any number of copies, and (iv) for any\npurpose whatsoever, including without limitation commercial, advertising or\npromotional purposes (the \"License\"). The License shall be deemed effective as\nof the date CC0 was applied by Affirmer to the Work. Should any part of the\nLicense for any reason be judged legally invalid or ineffective under\napplicable law, such partial invalidity or ineffectiveness shall not\ninvalidate the remainder of the License, and in such case Affirmer hereby\naffirms that he or she will not (i) exercise any of his or her remaining\nCopyright and Related Rights in the Work or (ii) assert any associated claims\nand causes of action with respect to the Work, in either case contrary to\nAffirmer's express Statement of Purpose.\n\n4. Limitations and Disclaimers.\n\n  a. No trademark or patent rights held by Affirmer are waived, abandoned,\n  surrendered, licensed or otherwise affected by this document.\n\n  b. Affirmer offers the Work as-is and makes no representations or warranties\n  of any kind concerning the Work, express, implied, statutory or otherwise,\n  including without limitation warranties of title, merchantability, fitness\n  for a particular purpose, non infringement, or the absence of latent or\n  other defects, accuracy, or the present or absence of errors, whether or not\n  discoverable, all to the greatest extent permissible under applicable law.\n\n  c. Affirmer disclaims responsibility for clearing rights of other persons\n  that may apply to the Work or any use thereof, including without limitation\n  any person's Copyright and Related Rights in the Work. Further, Affirmer\n  disclaims responsibility for obtaining any necessary consents, permissions\n  or other rights required for any use of the Work.\n\n  d. Affirmer understands and acknowledges that Creative Commons is not a\n  party to this document and has no duty or obligation with respect to this\n  CC0 or use of the Work.\n\nFor more information, please see\n<http://creativecommons.org/publicdomain/zero/1.0/>"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.486328125,
          "content": "# [The Unix Workbench](http://seankross.com/the-unix-workbench/)\n\n[![Build Status](https://travis-ci.org/seankross/the-unix-workbench.svg?branch=master)](https://travis-ci.org/seankross/the-unix-workbench)\n\nAn introduction to Unix for everyone.\n\n[![CC0](https://licensebuttons.net/p/zero/1.0/88x31.png)](https://creativecommons.org/publicdomain/zero/1.0/)\n\nThis work by [Sean Kross](http://seankross.com) is licensed\n[CC0](https://creativecommons.org/publicdomain/zero/1.0/). Zero rights reserved.\n"
        },
        {
          "name": "_bookdown.yml",
          "type": "blob",
          "size": 0.4013671875,
          "content": "book_filename: \"the-unix-workbench\"\nchapter_name: \"Chapter \"\nrepo: https://github.com/seankross/the-unix-workbench\noutput_dir: docs\nrmd_files: [\"index.Rmd\", \"01-What-is-Unix.Rmd\", \"02-Getting-Unix.Rmd\", \"03-Command-Line-Basics.Rmd\", \"04-Working-with-Unix.Rmd\", \"05-Bash-Programming.Rmd\", \"06-Git-and-GitHub.Rmd\", \"07-Nephology.Rmd\", \"08-Start-Building.Rmd\"]\nclean: [packages.bib, bookdown.bbl]\nnew_session: yes\n"
        },
        {
          "name": "_output.yml",
          "type": "blob",
          "size": 0.5390625,
          "content": "bookdown::gitbook:\n  css: style.css\n  split_by: chapter\n  config:\n    toc:\n      collapse: subsection\n      before: |\n        <li><a href=\"./\">The Unix Workbench</a></li>\n      after: |\n        <li><a href=\"https://github.com/rstudio/bookdown\" target=\"blank\">Published with bookdown</a></li>\n  includes:\n    in_header: [google_analytics.html]\nbookdown::html_chapters:\n  css: [style.css, toc.css]\nbookdown::pdf_book:\n  includes:\n    in_header: preamble.tex\n  latex_engine: xelatex\n  citation_package: natbib\nbookdown::epub_book:\n  stylesheet: style.css\n"
        },
        {
          "name": "book.bib",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "google_analytics.html",
          "type": "blob",
          "size": 0.306640625,
          "content": "<!-- Global site tag (gtag.js) - Google Analytics -->\n<script async src=\"https://www.googletagmanager.com/gtag/js?id=UA-47412721-2\"></script>\n<script>\n  window.dataLayer = window.dataLayer || [];\n  function gtag(){dataLayer.push(arguments);}\n  gtag('js', new Date());\n\n  gtag('config', 'UA-47412721-2');\n</script>\n"
        },
        {
          "name": "guestbook.md",
          "type": "blob",
          "size": 12.8662109375,
          "content": "# Guest Book\n- Kanye Stephen\n- Mark Havens\n- Sean Kross\n- Jonathan Leslie\n- Jose M Salan\n- David Ranzolin\n- Yamila Omar\n- Adrian Foo\n- Anton Heister\n- Nawaz Rahman\n- Kevin De Baere\n- Peter Bates\n- Ivan Stoyanov\n- Shahir\n- Jody Gibney\n- Jon\n- Oleg Platonenko\n- Miguel Fernandez\n- Sanjoy Karmakar\n- Franco Iovi\n- John Oliver\n- Tracy Nash\n- Tatiana Itzcovich\n- Data and Drones\n- Vineet Bhat\n- Emily Grossman\n- Umar\n- Hisham Elkassih\n- Nadia Mazur\n- George\n- ecruz3\n- Mario Rossi\n- Neeraj Pandey @neal0829\n- Giulia G\n- amir rezaei\n- Hadar Golan\n- Evan Chan\n- Jean-Paul Cardinal\n- Michael Ward\n- Jerome Cholewa\n- Mala Deep\n- Elbin Elias\n- Krishna Biradar\n- Ana Maria Hernandez\n- Hsiaochi Chelsea Liao\n- Aana Hahn\n- Marc Weisenberg\n- Kent Mok\n- A T\n- Tzafos Panagiotis\n- Angeliki Skan\n- Lovro\n- Chris Geissler\n- Steve D\n- Alicia Tsai\n- Josh Sulkers\n- Jamie Henzy\n- Aliaksei Kuzmin\n- Francisco Lima\n- Suchir Bhatnagar\n- Alexandra Villamizar\n- Roberto Noorduijn Londono\n- Darren Jacquet\n- Joonil Ahn\n- Phuc K Nguyen\n- Mark Boehler\n- Stefano Manca\n- Aleksandar Lazić\n- Liubov Chagaeva\n- Burc G\n- Nikolay\n- Carla Bates\n- dnafrance\n- Supriya\n- Grant Macandrew\n- Habibi\n- Martin Selway\n- Albert Barragan Laso\n- Nicholas D'Cruz\n- Bharadwaj Enagandula\n- Nick Arnold\n- Wayne\n- Paul Bridge\n- Carlos A.\n- Daniel A. Rodríguez Caballero\n- Paolo Vagnini\n- Swapan Jain\n- Yuan Tian\n- carolynzy\n- Xuange Cui\n- David Conrad\n- M McPhail\n- Marcus Rodrigues de Araujo\n- Stefan M\n- S. A.\n- Chase LeCroy\n- Jason Plante\n- Bela Widi\n- Barbara M\n- Javad Ebadi\n- Andrew Pirie\n- Angela Laios\n- Sergio Diaz\n- Femi\n- Jaakko Järvinen\n- Christopher Michael Reece\n- Ksenia Koroleva\n- Antonio J Morales\n- Amit Bhatia\n- Konstantin G\n- Sarath Radhakrishnan\n- Leonie NDOYE\n- Aris kumar\n- Charles Zhang\n- coolestxuxu\n- Charles\n- Frank\n- Sougata Ghosh\n- Amanda Sim\n- Goran Tirnanić\n- Steven Van Isterdael\n- ajeetkumar vishwakarma\n- Kris Hampel\n- Nala\n- Seung Hoon Ha\n- Arsenii Mustafin\n- Pia Backmann\n- Vivek Rudrapatna\n- Lara L.\n- Raimund Strauck\n- Eden Mugg\n- Stephanie Doctor\n- hamza salifou\n- Rachit Kinger\n- Eric Elder\n- Kenyon Smith\n- Ashkan Ranjbar\n- Jenny Censin\n- Elton Melo\n- Saliha Xiaoxuan Wang\n- Trevorr Marshall\n- Santi Santichaivekin\n- Huajun Zhou\n- zee melle\n- Vitaly\n- Oliver Kakine\n- Justin Shankle\n- Krista H.\n- stickey\n- Koenraad Van Hoorde\n- Holly Grimm\n- Soledad López Gambino\n- Chunlei Dai\n- Brian Hawkins\n- Emilie Wolf\n- Victor Golf\n- Vladimir Kanchev\n- Angela Renggli\n- Josue Garcia\n- Alexandre Cadima\n- Palatip Jopanya John\n- Rebecca B\n- Kalki Sharma\n- Daniel Hall\n- Michel Sun\n- Siddhesh Dalvi\n- Nathan Rooney\n- Nikhilendra Gudisa\n- Yin Yang\n- Dhruman Goradia\n- Nina P\n- Anmol Patil\n- Yaz Belinskiy\n- Twsa Liu\n- Xin Guo\n- Yaz Belinskiy\n- benedictor\n- Darwin Huang\n- Santi\n- Sajjad Bin Samad\n- Eleftheria Theodoropoulou\n- Anand Swaroop\n- Oksana Chartier\n- Sergei Iakovlev\n- Karthik\n- Sparkling\n- ReversibleMan\n- Makoto I.\n- Tah Ren Yie\n- Erica M\n- Marie-Eve Michel\n- Pietro Tavazzi\n- Artem Novikov\n- Miguel Rodriguez\n- Marx Ortiz\n- Jiayi Li\n- Claire Fahy\n- Deep Shekhar\n- Cristina Leoni\n- Aaron\n- Reza Noghabaie\n- Steve LaRock\n- Pragati Sharma\n- Andreu C\n- Juan San Martín\n- Tom Fee\n- Simón Villanueva\n- Alexey Goloviznin\n- Esin Karahan\n- Saurabh Pujar\n- Akila\n- Pranav\n- matan niv\n- Gaurav Sukhija\n- Tormod Rogne\n- Me\n- sunday sun\n- Will Sparks\n- Paul D\n- AJ Tong\n- T. Mittra\n- Stanton Dowd\n- Mani Krishna\n- Louis Solo\n- Edgardo Salazar\n- Kim Kwa\n- James Patrick Conlon\n- Philippe Schindelohlz\n- C Steed\n- Adam Lu\n- Shawn Serik\n- Caleb Bowyer\n- Dale Gaines\n- Semen Tymoshchuk\n- Tom Zu\n- Bahar Paydar\n- Nikolay Miller\n- Yolanda D\n- Dileep Nackathaya\n- Luiz Felipe Brito\n- Jerome Gransac\n- Ana D\n- Abhi Thadeshwar\n- David\n- Reinoud Bosch\n- Himanshu Rawal\n- Claude Molinaro\n- Riley Mahn\n- Mirko\n- Khal Drogo\n- Themistocles Anagno\n- Daniel Yukimura\n- Anirudh Srivastava\n- Micah Bell\n- Naznin Shaikh\n- Ivan Santana\n- Zhihao Fan\n- Irina Popov\n- Lian Aldrich\n- Yovan Petrovich\n- Nikola Aksentijevic\n- Cheng-Han Yu\n- John Smith\n- mrcazzim\n- AnuragAnalog\n- Shashank\n- Nguyen Le\n- coolblueguy\n- Ahmed Elghannam\n- Andrey Chirkov\n- Peter E.\n- Bob\n- 国得杰\n- Paul Bauer\n- MentalRecessMonkey\n- Lily Chen\n- Jimmy Lem\n- JIHO PARK\n- SOOHO PARK\n- Dana Bentley\n- Abhinav Agarwal\n- Pradyumna\n- Sanket Rajgarhia\n- Mohsin Raza\n- Esteban Mendoza\n- IvanY\n- Jaye\n- Julia Sokolova\n- dangnamkhanh\n- Rob Harrand\n- Oren Tal\n- Danya Martsinovich\n- awesome Kratos\n- P\n- Ebi Chukwudi\n- Reza Ebadi\n- Sylvia Lods\n- Victor Yu\n- Christian San Jose\n- Gaurav Vijaywargia\n- Ivan Petrov\n- Alex Mac\n- Trung Nguyen T\n- Tushar Teji\n- Hank JIN\n- Shane Davitt\n- Ajit Velhal\n- Dmitrii Zhavoronkov\n- Mohamed Refaat\n- Jamie Hutchins\n- Fred\n- Anestis Kotidis\n- Sue Wang\n- Tiago Salema\n- Rojin\n- Vladimir Mazin\n- Jose Zancudo\n- Munib Ahsan\n- Panagiotis T.\n- Mazi Chiadikobi\n- Karen Jones\n- Ray Larone\n- Andrew Burger\n- Fanny Taborsak-Lines\n- Abdul\n- Claudia Kiesewetter\n- Chenda\n- Liam Konidaris\n- Bilal Gamal\n- Tomer\n- Ludovic M\n- Ilia Pankratov\n- Hylton Socher\n- Millan ME\n- Núria Rivera Brugués\n- Elwira Kobusiewicz\n- Fränki\n- Konstantinos Yeles\n- Jason F.\n- Luis Alberto Alaniz Castillo\n- Siddharth D Jaiswal\n- Navid Shayanfar\n- Kangk\n- Rick Petry\n- Rene Porto\n- Ilia Galaktionov\n- Alex Sandro\n- Ardilla Latifasari\n- Tim Gretler\n- Anthony Alfimov\n- Sara Ghanem\n- Samba SG\n- Vlad Kuzin\n- Dmitry Bobylev\n- Baurzhan Ryskaliyev\n- yeshwanth\n- Arjun Sengupta\n- Jeremy Carrothers\n- Lingshen He\n- Przemek Raczkowski\n- Ala Barjasteh\n- Kevin Chu\n- Liza Shaburova\n- Cristiano Berhanu\n- Justin Knutzen\n- David Hsu\n- Stefano\n- Andrey Radchenko\n- eric\n- Mary Taylor\n- Zhu Zhi\n- Dan Hustmyer\n- Alp Aribal\n- Haseeb\n- Marton Kanasz-Nagy\n- Ran Wang\n- Mounes S\n- Rebecca Crane\n- Nitin\n- Aditya Kakoti\n- Charlie Toothaker\n- Matheus Amaral\n- Karina188\n- Oiliba\n- Filippo Corri\n- Mudassar Raza\n- Bernhard S\n- Sako\n- Jake SR\n- Vic Harkness\n- Amir Yariv\n- Daniel Shen\n- Keshari Nandan\n- JK\n- J Yu\n- Sergey Lazarev\n- Maddy Powers\n- Giannis Tampakakis\n- schan\n- Zikun Qin\n- Cindy Flórez\n- Patrick Hennessey\n- Ravi Rathore\n- Sanjay\n- Mitch Edmunds\n- Iris Zimmermann\n- Nick Antonogiannis\n- Frank Tseng\n- Ayoub Haj\n- Ewelina Strużyńska\n- Zixin Zhang\n- TX\n- Sergio Chamorro\n- Alfredo Vazquez\n- Jaineshkumar Patel\n- Nick Wapstra\n- Elena Liga\n- Julian Jose\n- Aaron Wells\n- Alex G\n- Reena\n- Hoang Tran\n- Wiktor W\n- Jamshed Khan\n- Kathi Raja Ravindra\n- Tianli Song\n- Daniel Kuenzle\n- Tianmin Lyu\n- Colin Burton\n- Sherrill Castrodale\n- adam paz\n- Kacy Chisom\n- Katya Delikishkina\n- Laura Marcos\n- Archit Sengupta\n- 空海\n- Brandon Goldenberg\n- Agyey Arya\n- Gabriel Alves Vieira\n- Kelvin\n- James B\n- Sven Abelsson Runing\n- FredXie\n- Valentyna K.\n- Allen Mwandunga\n- Adhira Deogade\n- pu chen\n- Naresh Gurbuxani\n- Aisuluu\n- Kevin Heylin\n- Rohan Nayak\n- Jamie Z\n- Mengdan Wan\n- J Planken\n- J Kaze\n- Rishab Rajan\n- Anita Kowalska\n- Misael\n- Fentiss\n- @ErikCodigo\n- Edu G\n- Justina ND\n- Ning Chen\n- Selam G\n- YVB\n- Gleb\n- Charlie Collier\n- Vladimir Zarnitsyn\n- Sunil Sunny\n- Ke Zhang\n- Veronika\n- Kai-Hui Sun\n- Sara Diaz\n- Sam Giles\n- Muhammed Sidibeh\n- Irina Borozdina\n- zch4\n- Rohit Jayanti\n- josujean\n- Sawyer Prestwood\n- sudodjl\n- Notto J. W. Thelle\n- Darius Tamasauskas\n- Ben Bracey\n- Anscharius Linitextor\n- Michael Cunningham\n- Patrick Still\n- Ritwik Agarwal\n- Damir Paripovic\n- Nilesh Jain\n- Jeevan Sapkota\n- Jakub Majer\n- Carles Garcia\n- Param Parikh\n- Mica Pictor\n- Pablo Pena\n- Nik Seldon\n- Benjamin Washington\n- Adrian\n- Alexander Nelson\n- Kumar Rahul\n- Isaiah Duncan\n- DJ Pringle\n- Hassan\n- Evgenii Klt\n- Alexandru Patulea\n- VASYAN\n- Heine Elias Husdal\n- Tim Thomas\n- Tatsuya Hayashi\n- Paweł Krakowiak\n- Claire Wu\n- S.M.Al Mahin\n- erika 6\n- Raunak Ranjan\n- Agustin Beceyro Ferran\n- Nataliya A. Logvina\n- Reshmi de\n- N Rius\n- Armin Salmasi\n- Mamta_Singh\n- Ahmed Zedan\n- Musab Shakeel\n- Josie Everatt\n- René Salas\n- Amy Nguyen\n- Ben Bonner\n- Daniel Santos\n- Greatman Okonkwo\n- Valentin Corelj\n- Alberto Gutierrez\n- Ali Abolhassanzadeh Mahani\n- Shi Wen\n- Maria-Anna Klironomou\n- Rahul Tarte\n- Answar Twizeyimana\n- Stefan Ivanica\n- Gabriel Mota\n- Gerson Santos\n- Raquel Fueyo\n- Sander de Vries\n- Jose Luis\n- Aaron Schlichting\n- Shreyansh Pathak\n- Knut Husdal\n- Michael Lim\n- #tejas\n- Manish Meena\n- Vishal Singh\n- Claire Volleman\n- Konstheo\n- Shyam Deo\n- Tare\n- Kir Pra\n- Petr Hala\n- Arvind Verma\n- Sachin Awasthi\n- Alberto Machado\n- Vetha Nishanth\n- Hassan el Hassan\n- Christina Canavati\n- Krishna Desabhotla\n- Tinatin Baratashvili\n- Soo Liew\n- Andrés Morales Reyes\n- Nico Ca\n- Juan Marcucci\n- Uttam Dey\n- Navy\n- Miguel Ramirez (mik315)\n- Raymond Calderon\n- Ruhi D.\n- Nyasha Chambwe\n- Carles Hilario\n- Fuhad Olatunbosun\n- John Donne Sr\n- Artem Smirnov\n- Mark Wentowski\n- PB\n- Andres Thomas\n- Kelly Christensen\n- Steve B\n- Alex\n- CHIA LUNG NI\n- Mohan Govindasamy\n- Ghazaleh Kazeminejad\n- Simon Larose\n- xiaobo\n- Lucas\n- Jaz Edebeli\n- Vadim Azalov\n- Sukanta Das\n- Bilal Khan\n- Mehedi Hasan\n- Ravi Kalia\n- varun\n- Kashish Mittal\n- Akshar\n- Yan Xie\n- Pavel Nedyalkov\n- Arun Pathak\n- Iftah Tsdaka\n- Johannes Ranalletta\n- B. Heitner\n- Luis Talavera\n- Daniil Udobnyj\n- MuratTuz\n- Sarah Gratton\n- Olga Klipa\n- Raghav Gade\n- Andreas Rockert\n- Michael Collins\n- Robed Beauvile\n- Alejandro Moliné\n- Sam Feng\n- Eric Carswell\n- Santosh Acharya\n- Paul Borman\n- Bram Vandendriessche\n- Rhett Marchant\n- Ning Mou\n- Kauffman\n- J A Zamindar\n- Alexander\n- Jerrod Nelson\n- Rachel Zhande\n- Rohit Aggarwal\n- Tlegen Kamidollayev\n- Fedor Baulin\n- Kai Wang\n- Isaac Myers\n- Marina Markantoni\n- Homayoun\n- Triratna Manandhar\n- Jax Tan\n- Kai Tan\n- Omar Hammouda\n- Danny O'Donnell\n- Arash Kiyanmehr\n- Allen CT Chen\n- Ellie Aizenberg\n- Surton Redjopawiro\n- Sergio Prieto Molina\n- DenkiMenki\n- Fahim Khan\n- Radoslaw Kotwa\n- MTA\n- Shady Saad\n- Tony Marek\n- Artem Prokopenko\n- Ekhlass Talha\n- Nasrulain Mohamed\n- Dinesh Virwani\n- Jazib Dawre\n- ABDOUS Mohammed-Amine\n- Md. Samiul Islam Sagar\n- Daniel Gartner\n- Severine Bonnechere\n- Marco Pandolfi\n- Hung En Lai\n- Lokman GALAL\n- Lilia Hausmann\n- Matthias Brandtner\n- Adamantios Sigiorgis\n- Steve Carr\n- David Peter\n- Asaf Dahan\n- Leonardo Sanches\n- Sierra Corban\n- Illia Krystal\n- Jean De Vour\n- Kinga Farkas\n- David Arturo\n- Dor Avraham\n- Charlie Fenwick\n- Carlos Soliz\n- Jatin Rathee\n- Loïc Borcard\n- Frey Norden\n- Francesco Lorenzelli\n- Rahul Rajesh\n- Aswin Raj\n- Andrei Karanko\n- Mike Pete\n- Patrick Harley Semples\n- Vikalp Rusia\n- Halim S\n- Srinandan P\n- Janin\n- Leonardo Castro\n- Alessandro Centola\n- Chris Miller\n- Satish Thuwal\n- Vitaly Stepanyants\n- Matthew Oppenheim\n- Joachim Koch\n- Mario Cabrera\n- Kate McCluskey\n- MJ is here\n- Brendan Schroeder\n- Juan Reyes\n- Gin Seow\n- Rahul Dangi\n- Simo Leppälä\n- Shubham Kumar\n- Nil Garcia\n- Susmita Roy\n- JZstats\n- Bruno Mendes\n- Joaquin Gajardo\n- Kateryna Perebaieva\n- Anmol Kalra\n- Sofia Kiriakidi\n- nekobito\n- Shivangi Tomar\n- Akhilesh Mishra\n- C Lu\n- Sophie Wang\n- Breno Tiburcio\n- Julia Hitschfel\n- Manish Bharti\n- Dasara Shullani\n- Gabriel George Silvas\n- Erdinger Pinto\n- Elizabeth Dossett\n- Aswin S\n- ashu\n- Yuri Miguel\n- Roy Natian\n- Jebin\n- Priyanshu Jain\n- Steve Aston\n- Jacinto Alvarez\n- HBX\n- KSK\n- Aart Spek\n- Thomas Bucaioni\n- Laura King\n- Chahat Chawla\n- Snir Israeli\n- Jenna LaBelle\n- Rita SR\n- Bruce Wayne\n- Mitika Surana\n- Ayman EL Mouss\n- A. Luna\n- Mohammed Waseem\n- momomore\n- Sergey Yashin\n- shouvik\n- Keenal Shah\n- Vishal B.\n- Jahan\n- Daniel Paz\n- HM Low\n- Vinko Besic\n- Hannah T\n- MuckT\n- Brandyn Ryan\n- Vladislav Pisanenko\n- Julio Cesar\n- HARSH THAKKAR\n- Alan Kong\n- Dharamraj\n- Ravi Shankar\n- Manish Gowd\n- Anna Blashkina\n- Marcus Richardson\n- Anubhav Kumar\n- prabhabharabi\n- Peter Obishchenko\n- Geetanjan Roy\n- Carlos Anrés Vélez González\n- Artem Vorobyev\n- Deepak Kumar\n- Oussama Braydi\n- Achuthan Raja Venkatesh\n- Mei S.\n- sagiraldogu \n- Nataly\n- Prasang G\n- Sona Pisova\n- Christy Henderson\n- Alejandro\n- Daniel Donoso\n- Ziv Zerr\n- Diego\n- Ilya Demidov\n- Carolina Duque\n- Darshankumar Hosamani\n- Bojan631\n- Rex\n- Muralidhara\n- Roman Tarasov\n- Kseniia Soloveva\n- Yvon D'Amours\n- Dmitriy Biryuchkov\n- Dominique Ng\n- Nghi Dang\n- Antonios M.\n- Piyush\n- Abanob Medhat\n- Antonis Christou\n- Ambika\n- Karen Parente\n- Tim Kuhlow\n- Olivier Roncalez\n- Wouter Mulder\n- Souvik Chandra\n- Sai Teja V\n- Jorge González\n- Fanzhao Meng\n- Ruwaa I. Mohamed\n- Julsen\n- Rowan Liu\n- aatish uniyal\n- Eric Lumsden\n- LEE\n- Ahmed Elgamal\n- Suruchi Walekar\n- Yauheni Mardan\n- Tomomi\n- Brian Allen\n- Elena Radchenko\n- Apoorv Dankar\n- Ilmars Rauda\n- Simon Villadsen\n- Ruby K.\n- smserge\n- Juan García\n- Abbie Byford\n- Alex Muhr\n- Ananya Agrawal\n- Kalpan Shah\n- Mayank Panwar\n- Fotis Baltoumas\n- Sarah Teeters\n- MuAZ Modak\n- beerded\n- Lars-Johan Brannmark\n- Lotachukwu Ibe\n- Dwain Perkins\n- Jason Eid\n- Jimmy Phan :)\n- Alejandro Lemus\n- Marc Ponchon\n- Ilias Sabirov\n- Janakinath\n- Catherine Serova\n- Amanita Muscarito\n- Shakthivel\n- Richard H\n- Andrew M\n- HS\n- Gerardo Lorenzo \n- Akhil Ajithkumar\n- G H Giri\n- Sreejan Bandyopadhyay\n- youssef k\n- 4M.1N3\n- Vlad Ienceanu\n- Linus Bergman\n- Mahmoud Hamdy\n- Alberto Miranda\n- Vachan Gowda\n- Andrew Younkers\n-Yevhen Movenko\n- Mike Younkers\n- Minxin\n- Ernesto\n- Manav Aswani\n- Mohammad Anwar Shah\n- Swarnava Ghosh\n- Adam X\n- Musta User\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.Rmd",
          "type": "blob",
          "size": 3.1484375,
          "content": "--- \ntitle: \"The Unix Workbench\"\nauthor: \"Sean Kross\"\ndate: \"`r Sys.Date()`\"\nsite: bookdown::bookdown_site\noutput:\n bookdown::html_chapters:\n   includes:\n     in_header: style.css\ndocumentclass: book\ncover-image: \"images/cover.png\"\nbibliography: [book.bib]\nbiblio-style: apalike\nlink-citations: yes\ngithub-repo: seankross/the-unix-workbench\nurl: 'https\\://github.com/seankross/the-unix-workbench'\ndescription: \"\"\n---\n\n# Title Page {-}\n\n<img src=\"images/cover.png\" width=\"350\" height=\"560\" alt=\"Cover image\" />\n\nCover Image: *A Goldsmith in his Shop* by Petrus Christus\n\n[![CC0](images/cc0.png)](https://creativecommons.org/publicdomain/zero/1.0/)\n\nThis work by [Sean Kross](http://seankross.com) is licensed \n[CC0](https://creativecommons.org/publicdomain/zero/1.0/). Zero rights reserved.\n\nThis book is available for purchase on [Leanpub.com](https://leanpub.com/unix).\n\nThis book can be used on its own, however it's also the companion textbook to\na course of the same name on [Coursera.org](https://www.coursera.org/learn/unix).\n\n# Dedication {-}\n\nIn memory of Toby Kross.\n\n# Acknowledgements {-}\n\nThank you to Jeff Leek, Roger Peng, and Brian Caffo for your advice and support.\nAlso thank you to Jon Calder and Elissa Redmiles for your edits and suggestions.\n\n# Introduction {-}\n\nThis book is intended for folks who are new to programming and new to Unix-like\noperating systems like macOS and Linux distributions like Ubuntu. Most of the\ntechnologies discussed in this book will be accessed via a command line\ninterface. Command line \ninterfaces can seem alien at first, so this book\nattempts to draw parallels between using the command line and actions that you\nwould normally take while using your mouse and keyboard.\nYou will also learn how to write little pieces of software in a programming\nlanguage called Bash, which allows you to connect together the tools we will\ndiscuss. My hope is that by the end of this book you be able to use different\nUnix tools as if they are interconnecting Lego bricks.\n\nUnix forms a foundation that is often very helpful for\naccomplishing other goals you might have for you and your computer, whether\nthat goal is running a business, writing a book, curing disease, or creating\nthe next great app. The means to these goals are sometimes carried out by\nwriting software.\nSoftware cannot be mined out of the ground, nor can software seeds be planted in\nspring to harvest by autumn. Software is not produced in factories on an\nassembly line. Software is a hand-made, often bespoke good. If a software\ndeveloper is an artisan, then Unix is their workbench. Unix provides an\nessential and simple set of tools in a distraction-free environment. Even if\nyou are not a software developer learning Unix can open you up to new methods\nof thinking and novel ways to scale your ideas. My goal\nfor this book is to help you get started with Unix by writing the book I would\nhave wanted when I was first learning Unix. If you have any additions,\ncorrections, or comments for this book please open an issue or send a pull\nrequest to: https://github.com/seankross/the-unix-workbench. If you are unsure\nwhat a pull request is don't worry, you will find out in the Git and GitHub\nchapter of this book!\n"
        },
        {
          "name": "paper.md",
          "type": "blob",
          "size": 0.24609375,
          "content": "---\ntitle: 'The Unix Workbench'\ntags:\n- unix\n- linux\n- command line\n- bash\n- git\n- cloud\n- regular expressions\nauthors:\n- name: Sean Kross\n  affiliation: 1\naffiliations:\n- name: The University of California San Diego\n  index: 1\ndate: 16 March 2018\n---\n"
        },
        {
          "name": "preamble.tex",
          "type": "blob",
          "size": 0.021484375,
          "content": "\\usepackage{booktabs}\n"
        },
        {
          "name": "style.css",
          "type": "blob",
          "size": 0.16796875,
          "content": "p.caption {\n  color: #777;\n  margin-top: 10px;\n}\np code {\n  white-space: inherit;\n}\npre {\n  word-break: normal;\n  word-wrap: normal;\n}\npre code {\n  white-space: inherit;\n}\n"
        },
        {
          "name": "the-unix-workbench.Rproj",
          "type": "blob",
          "size": 0.2958984375,
          "content": "Version: 1.0\n\nRestoreWorkspace: Default\nSaveWorkspace: Default\nAlwaysSaveHistory: Default\n\nEnableCodeIndexing: Yes\nUseSpacesForTab: Yes\nNumSpacesForTab: 2\nEncoding: UTF-8\n\nRnwWeave: Sweave\nLaTeX: pdfLaTeX\n\nBuildType: Package\nPackageUseDevtools: Yes\nPackageInstallArgs: --no-multiarch --with-keep.source\n"
        },
        {
          "name": "toc.css",
          "type": "blob",
          "size": 2.3857421875,
          "content": "#TOC ul,\n#TOC li,\n#TOC span,\n#TOC a {\n  margin: 0;\n  padding: 0;\n  position: relative;\n}\n#TOC {\n  line-height: 1;\n  border-radius: 5px 5px 0 0;\n  background: #141414;\n  background: linear-gradient(to bottom, #333333 0%, #141414 100%);\n  border-bottom: 2px solid #0fa1e0;\n  width: auto;\n}\n#TOC:after,\n#TOC ul:after {\n  content: '';\n  display: block;\n  clear: both;\n}\n#TOC a {\n  background: #141414;\n  background: linear-gradient(to bottom, #333333 0%, #141414 100%);\n  color: #ffffff;\n  display: block;\n  padding: 19px 20px;\n  text-decoration: none;\n  text-shadow: none;\n}\n#TOC ul {\n  list-style: none;\n}\n#TOC > ul > li {\n  display: inline-block;\n  float: left;\n  margin: 0;\n}\n#TOC > ul > li > a {\n  color: #ffffff;\n}\n#TOC > ul > li:hover:after {\n  content: '';\n  display: block;\n  width: 0;\n  height: 0;\n  position: absolute;\n  left: 50%;\n  bottom: 0;\n  border-left: 10px solid transparent;\n  border-right: 10px solid transparent;\n  border-bottom: 10px solid #0fa1e0;\n  margin-left: -10px;\n}\n#TOC > ul > li:first-child > a {\n  border-radius: 5px 0 0 0;\n}\n#TOC.align-right > ul > li:first-child > a,\n#TOC.align-center > ul > li:first-child > a {\n  border-radius: 0;\n}\n#TOC.align-right > ul > li:last-child > a {\n  border-radius: 0 5px 0 0;\n}\n#TOC > ul > li.active > a,\n#TOC > ul > li:hover > a {\n  color: #ffffff;\n  box-shadow: inset 0 0 3px #000000;\n  background: #070707;\n  background: linear-gradient(to bottom, #262626 0%, #070707 100%);\n}\n#TOC .has-sub {\n  z-index: 1;\n}\n#TOC .has-sub:hover > ul {\n  display: block;\n}\n#TOC .has-sub ul {\n  display: none;\n  position: absolute;\n  width: 200px;\n  top: 100%;\n  left: 0;\n}\n#TOC .has-sub ul li a {\n  background: #0fa1e0;\n  border-bottom: 1px dotted #31b7f1;\n  filter: none;\n  display: block;\n  line-height: 120%;\n  padding: 10px;\n  color: #ffffff;\n}\n#TOC .has-sub ul li:hover a {\n  background: #0c7fb0;\n}\n#TOC ul ul li:hover > a {\n  color: #ffffff;\n}\n#TOC .has-sub .has-sub:hover > ul {\n  display: block;\n}\n#TOC .has-sub .has-sub ul {\n  display: none;\n  position: absolute;\n  left: 100%;\n  top: 0;\n}\n#TOC .has-sub .has-sub ul li a {\n  background: #0c7fb0;\n  border-bottom: 1px dotted #31b7f1;\n}\n#TOC .has-sub .has-sub ul li a:hover {\n  background: #0a6d98;\n}\n#TOC ul ul li.last > a,\n#TOC ul ul li:last-child > a,\n#TOC ul ul ul li.last > a,\n#TOC ul ul ul li:last-child > a,\n#TOC .has-sub ul li:last-child > a,\n#TOC .has-sub ul li.last > a {\n  border-bottom: 0;\n}\n#TOC ul {\n  font-size: 1.2rem;\n}\n"
        }
      ]
    }
  ]
}