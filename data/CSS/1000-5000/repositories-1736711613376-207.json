{
  "metadata": {
    "timestamp": 1736711613376,
    "page": 207,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "yakimka/python_interview_questions",
      "stars": 1767,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0390625,
          "content": "MIT License\n\nCopyright (c) 2021 yakimka\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.326171875,
          "content": "questions.epub: questions.md metadata.txt book_res/* attachments/* Makefile ## Generate epub book\n\tpandoc --toc --toc-depth=6 -o questions.epub metadata.txt questions.md\n\n.PHONY: toc\ntoc:  ## Generate TOC from questions.md\n\tpython3 generate_toc.py\n\n.PHONY: toc\ntoc-check:  ## Check that toc is actual\n\tpython3 generate_toc.py --check\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 42.7001953125,
          "content": "# Вопросы для подготовки к Python Developer интервью\n\n## Disclaimer\n\nОтветы на вопросы собирал давно и с попеременным успехом.\nГде-то могут быть неточности, где-то откровенный бред (особенно в разделе про БД). Источники также выбирались не очень переборчиво.\nЧасть ссылок на источники может быть не указана по причине забывчивости или просто случайно была утеряна.\nВладелец этого репозитория не несет ответственности за ущерб причиненный содержимым этого репозитория,\nработой Python-разработчика и работой как таковой.\n\n## Собственно вопросы\n\n[questions.md](questions.md)\n\n## FAQ\n\n### Что это?\n\nСписок вопросов для подготовки к интервью. Могут быть полезны как интервьюеру так и интервьюируемому\n\n### Зачем?\n\nКак-то увидел [статью](https://habr.com/ru/post/439576/) на Хабре где было много вопросов,\nно практически не было ответов и не смог пройти мимо.\n\n### Нашел ошибку/опечатку/бред в ответах или хочу добавить еще вопросов\n\nМолодец, создавай PR.\n\n- После того как что-то изменил в [questions.md](questions.md) запусти `make toc` чтобы обновить [Список вопросов](#Список-вопросов)\n- Не забудь добавить себя в [metadata.txt](metadata.txt) в раздел `author`\n\n### Не хочу читать в Markdown, хочу читать в электронной книге\n\nПожалуйста [releases](https://github.com/yakimka/python_interview_questions/releases)\n\n## Список вопросов\n\n<!-- toc -->\n\n- [Python](questions.md/#Python)\n  * [Последовательности](questions.md/#Последовательности)\n    + [Что такое последовательность](questions.md/#Что-такое-последовательность)\n    + [Какие операции поддерживают большинство последовательностей](questions.md/#Какие-операции-поддерживают-большинство-последовательностей)\n    + [Какие виды строк бывают в питоне](questions.md/#Какие-виды-строк-бывают-в-питоне)\n    + [Можно ли изменить отдельный символ внутри строки](questions.md/#Можно-ли-изменить-отдельный-символ-внутри-строки)\n    + [Как соединить список строк в одну. Как разбить строку на список строк](questions.md/#Как-соединить-список-строк-в-одну-Как-разбить-строку-на-список-строк)\n    + [Как кодировать и декодировать строки](questions.md/#Как-кодировать-и-декодировать-строки)\n    + [Чем список отличается от кортежа](questions.md/#Чем-список-отличается-от-кортежа)\n    + [Что такое диапазон](questions.md/#Что-такое-диапазон)\n    + [Как сделать список уникальным (без повторяющихся элементов)](questions.md/#Как-сделать-список-уникальным-без-повторяющихся-элементов)\n    + [Есть кортеж из трех элементов. Назначить переменным a, b, c его значения](questions.md/#Есть-кортеж-из-трех-элементов-Назначить-переменным-a-b-c-его-значения)\n    + [Как сравниваются последовательности](questions.md/#Как-сравниваются-последовательности)\n  * [Множества и отображения](questions.md/#Множества-и-отображения)\n    + [Как понять хешируемый ли объект](questions.md/#Как-понять-хешируемый-ли-объект)\n    + [Что такое множество](questions.md/#Что-такое-множество)\n    + [Для чего применяются множества](questions.md/#Для-чего-применяются-множества)\n    + [Какие операции можно производить над множествами](questions.md/#Какие-операции-можно-производить-над-множествами)\n    + [Как происходит проверка множеств на равенство](questions.md/#Как-происходит-проверка-множеств-на-равенство)\n    + [Что такое отображение](questions.md/#Что-такое-отображение)\n    + [Какие нюансы есть в использовании чисел как ключей](questions.md/#Какие-нюансы-есть-в-использовании-чисел-как-ключей)\n    + [Какие операции можно производить над отображениями](questions.md/#Какие-операции-можно-производить-над-отображениями)\n    + [Что возвращает метод items](questions.md/#Что-возвращает-метод-items)\n    + [Как отсортировать список словарей по определенному полю](questions.md/#Как-отсортировать-список-словарей-по-определенному-полю)\n    + [Что может являться ключом словаря. Что не может. Почему](questions.md/#Что-может-являться-ключом-словаря-Что-не-может-Почему)\n    + [Есть два списка – ключи и значения. Как составить из них словарь](questions.md/#Есть-два-списка--ключи-и-значения-Как-составить-из-них-словарь)\n    + [Как работает хэш-таблица](questions.md/#Как-работает-хэш-таблица)\n    + [Что такое коллизия](questions.md/#Что-такое-коллизия)\n    + [Где будет быстрее поиск, а где перебор и почему: dict, list, set, tuple](questions.md/#Где-будет-быстрее-поиск-а-где-перебор-и-почему-dict-list-set-tuple)\n  * [Функции](questions.md/#Функции)\n    + [Что такое args, kwargs. В каких случаях они требуются](questions.md/#Что-такое-args-kwargs-В-каких-случаях-они-требуются)\n    + [Почему использовать изменяемые объекты как параметры по-умолчанию плохо. Приведите пример плохого случая. Как исправить](questions.md/#Почему-использовать-изменяемые-объекты-как-параметры-по-умолчанию-плохо-Приведите-пример-плохого-случая-Как-исправить)\n    + [Можно ли передавать функцию в качестве аргумента другой функции](questions.md/#Можно-ли-передавать-функцию-в-качестве-аргумента-другой-функции)\n    + [Можно ли объявлять функцию внутри другой функции. Где она будет видна](questions.md/#Можно-ли-объявлять-функцию-внутри-другой-функции-Где-она-будет-видна)\n    + [Что такое лямбды. Каковы их особенности](questions.md/#Что-такое-лямбды-Каковы-их-особенности)\n    + [Допустимы ли следующие выражения](questions.md/#Допустимы-ли-следующие-выражения)\n    + [Как передаются значения аргументов в функцию или метод](questions.md/#Как-передаются-значения-аргументов-в-функцию-или-метод)\n    + [Что такое замыкание](questions.md/#Что-такое-замыкание)\n  * [Итераторы и генераторы](questions.md/#Итераторы-и-генераторы)\n    + [Что такое контейнер](questions.md/#Что-такое-контейнер)\n    + [Что такое итерабельный объект](questions.md/#Что-такое-итерабельный-объект)\n    + [Что такое итератор](questions.md/#Что-такое-итератор)\n    + [Что такое генератор](questions.md/#Что-такое-генератор)\n    + [Что такое генераторная функция](questions.md/#Что-такое-генераторная-функция)\n    + [Что делает yield](questions.md/#Что-делает-yield)\n    + [В чем отличие \\[x for x in y\\] от (x for x in y)](questions.md/#В-чем-отличие-x-for-x-in-y-от-x-for-x-in-y)\n    + [Что особенного в генераторе](questions.md/#Что-особенного-в-генераторе)\n    + [Как объявить генератор](questions.md/#Как-объявить-генератор)\n    + [Как получить из генератора список](questions.md/#Как-получить-из-генератора-список)\n    + [Что такое подгенератор](questions.md/#Что-такое-подгенератор)\n    + [Какие методы есть у генераторов](questions.md/#Какие-методы-есть-у-генераторов)\n    + [Можно ли извлечь элемент генератора по индексу](questions.md/#Можно-ли-извлечь-элемент-генератора-по-индексу)\n    + [Что возвращает итерация по словарю](questions.md/#Что-возвращает-итерация-по-словарю)\n    + [Как итерировать словарь по парам ключ-значение](questions.md/#Как-итерировать-словарь-по-парам-ключ-значение)\n    + [Что такое сопрограмма](questions.md/#Что-такое-сопрограмма)\n  * [Классы, объекты](questions.md/#Классы-объекты)\n    + [Как получить список атрибутов объекта](questions.md/#Как-получить-список-атрибутов-объекта)\n    + [Что такое магические методы, для чего нужны](questions.md/#Что-такое-магические-методы-для-чего-нужны)\n    + [Как в классе сослаться на родительский класс](questions.md/#Как-в-классе-сослаться-на-родительский-класс)\n    + [Возможно ли множественное наследование](questions.md/#Возможно-ли-множественное-наследование)\n    + [Что такое MRO](questions.md/#Что-такое-MRO)\n    + [Что такое Diamond problem](questions.md/#Что-такое-Diamond-problem)\n    + [Что такое миксины](questions.md/#Что-такое-миксины)\n    + [Что такое контекстный менеджер. Как написать свой](questions.md/#Что-такое-контекстный-менеджер-Как-написать-свой)\n    + [Прокомментировать выражение](questions.md/#Прокомментировать-выражение)\n    + [Что такое \\_\\_slots\\_\\_. Плюсы, минусы](questions.md/#Что-такое-__slots__-Плюсы-минусы)\n    + [В чем смысл параметров _value, __value](questions.md/#В-чем-смысл-параметров-_value-__value)\n    + [Что такое \\_\\_new\\_\\_. И чем он отличается от \\_\\_init\\_\\_. В какой последовательности они выполняются](questions.md/#Что-такое-__new__-И-чем-он-отличается-от-__init__-В-какой-последовательности-они-выполняются)\n    + [Что такое и чем отличается old-style от new-style classes](questions.md/#Что-такое-и-чем-отличается-old-style-от-new-style-classes)\n    + [Что такое утиная типизация](questions.md/#Что-такое-утиная-типизация)\n  * [Модули, пакеты](questions.md/#Модули-пакеты)\n    + [Что такое модуль](questions.md/#Что-такое-модуль)\n    + [Как можно получить имя модуля](questions.md/#Как-можно-получить-имя-модуля)\n    + [Что такое модульное программирование](questions.md/#Что-такое-модульное-программирование)\n    + [Как Python ищет модули при импорте](questions.md/#Как-Python-ищет-модули-при-импорте)\n    + [Что такое пакет](questions.md/#Что-такое-пакет)\n    + [Что вы можете сказать о конструкции import package.item](questions.md/#Что-вы-можете-сказать-о-конструкции-import-packageitem)\n  * [Исключения](questions.md/#Исключения)\n    + [Что такое обработка исключений](questions.md/#Что-такое-обработка-исключений)\n    + [Для чего могут применять конструкцию try finally без except](questions.md/#Для-чего-могут-применять-конструкцию-try-finally-без-except)\n    + [Как правильно по-разному обрабатывать исключения](questions.md/#Как-правильно-по-разному-обрабатывать-исключения)\n    + [Что будет если ошибку не обработает блок except](questions.md/#Что-будет-если-ошибку-не-обработает-блок-except)\n    + [Что делать если нужно перехватить исключение, выполнить действия и опять возбудить это же исключение](questions.md/#Что-делать-если-нужно-перехватить-исключение-выполнить-действия-и-опять-возбудить-это-же-исключение)\n    + [Что такое сцепление исключений](questions.md/#Что-такое-сцепление-исключений)\n    + [Зачем нужен блок else](questions.md/#Зачем-нужен-блок-else)\n    + [Что можно передать в конструктор исключения](questions.md/#Что-можно-передать-в-конструктор-исключения)\n    + [Какие есть классы исключений](questions.md/#Какие-есть-классы-исключений)\n    + [В каких случаях можно обработать SyntaxError](questions.md/#В-каких-случаях-можно-обработать-SyntaxError)\n    + [Можно ли создавать собственные исключения](questions.md/#Можно-ли-создавать-собственные-исключения)\n    + [Для чего нужны предупреждения (warnings) и как создать собственное](questions.md/#Для-чего-нужны-предупреждения-warnings-и-как-создать-собственное)\n    + [Для чего нужен модуль warnings](questions.md/#Для-чего-нужен-модуль-warnings)\n  * [Декораторы](questions.md/#Декораторы)\n    + [Что такое декораторы. Зачем нужны](questions.md/#Что-такое-декораторы-Зачем-нужны)\n    + [Что может быть декоратором. К чему может быть применен декоратор](questions.md/#Что-может-быть-декоратором-К-чему-может-быть-применен-декоратор)\n    + [Что будет, если декоратор не возвращает ничего](questions.md/#Что-будет-если-декоратор-не-возвращает-ничего)\n    + [В чем отличие \\@foobar от \\@foobar()](questions.md/#В-чем-отличие-foobar-от-foobar)\n    + [Что такое фабрика декораторов](questions.md/#Что-такое-фабрика-декораторов)\n    + [Зачем нужен wraps](questions.md/#Зачем-нужен-wraps)\n  * [Метаклассы](questions.md/#Метаклассы)\n    + [Что такое метаклассы](questions.md/#Что-такое-метаклассы)\n    + [Что такое type. Как работает поиск метакласса при создании объекта](questions.md/#Что-такое-type-Как-работает-поиск-метакласса-при-создании-объекта)\n    + [Как работают метаклассы](questions.md/#Как-работают-метаклассы)\n    + [Зачем вообще использовать метаклассы](questions.md/#Зачем-вообще-использовать-метаклассы)\n  * [Ввод-Вывод](questions.md/#Ввод-Вывод)\n    + [Что такое файловый объект](questions.md/#Что-такое-файловый-объект)\n    + [Какие есть виды файловых объектов](questions.md/#Какие-есть-виды-файловых-объектов)\n    + [В чем отличие текстовых и бинарных файлов](questions.md/#В-чем-отличие-текстовых-и-бинарных-файлов)\n    + [Как пользоваться функцией open](questions.md/#Как-пользоваться-функцией-open)\n    + [Для чего необходимо закрывать файлы](questions.md/#Для-чего-необходимо-закрывать-файлы)\n    + [Что делают методы tell и seek](questions.md/#Что-делают-методы-tell-и-seek)\n    + [Что делают StringIO и BytesIO](questions.md/#Что-делают-StringIO-и-BytesIO)\n    + [Являются ли файловые объекты контекстными менеджерами](questions.md/#Являются-ли-файловые-объекты-контекстными-менеджерами)\n    + [Что такое сериализация](questions.md/#Что-такое-сериализация)\n    + [json.dumps / json.dump , json.loads / json.load](questions.md/#jsondumps--jsondump--jsonloads--jsonload)\n    + [Что делать если нужно сериализовать данные, которые не поддерживаются стандартным модулем json](questions.md/#Что-делать-если-нужно-сериализовать-данные-которые-не-поддерживаются-стандартным-модулем-json)\n    + [pickle.dumps / pickle.dump, pickle.loads / pickle.load](questions.md/#pickledumps--pickledump-pickleloads--pickleload)\n  * [Тестирование](questions.md/#Тестирование)\n    + [Пирамида тестирования](questions.md/#Пирамида-тестирования)\n    + [Что такое mocking](questions.md/#Что-такое-mocking)\n    + [Что делать, если тестируемая функция использует удалённое подключение к внешним сервисам, которое иногда видает ошибку таймаута, 404 и им подобные](questions.md/#Что-делать-если-тестируемая-функция-использует-удалённое-подключение-к-внешним-сервисам-которое-иногда-видает-ошибку-таймаута-404-и-им-подобные)\n    + [Что делать, если тестируемая функция занимает много времени на выполнение повторяющихся операций внутри неё](questions.md/#Что-делать-если-тестируемая-функция-занимает-много-времени-на-выполнение-повторяющихся-операций-внутри-неё)\n    + [Какие вы знаете виды тестов](questions.md/#Какие-вы-знаете-виды-тестов)\n      - [Unit-тесты](questions.md/#Unit-тесты)\n      - [Интеграционные тесты (Integration tests)](questions.md/#Интеграционные-тесты-Integration-tests)\n      - [Функциональное тестирование](questions.md/#Функциональное-тестирование)\n      - [Системный тест (System test, Service test)](questions.md/#Системный-тест-System-test-Service-test)\n      - [Проверка работоспособности (Smoke test, Sanity check)](questions.md/#Проверка-работоспособности-Smoke-test-Sanity-check)\n      - [Регрессионное тестирование (Regression testing)](questions.md/#Регрессионное-тестирование-Regression-testing)\n      - [Прочее](questions.md/#Прочее)\n    + [Чем интеграционное тестирование отличается от функционального](questions.md/#Чем-интеграционное-тестирование-отличается-от-функционального)\n  * [Функциональное программирование](questions.md/#Функциональное-программирование)\n    + [Что такое функциональное программирование](questions.md/#Что-такое-функциональное-программирование)\n    + [Как у Python с поддержкой функционального программирования](questions.md/#Как-у-Python-с-поддержкой-функционального-программирования)\n    + [Что такое объект первого класса](questions.md/#Что-такое-объект-первого-класса)\n    + [Что такое функция высшего порядка](questions.md/#Что-такое-функция-высшего-порядка)\n    + [Что такое каррирование](questions.md/#Что-такое-каррирование)\n    + [Опишите функции map, reduce, filter модуля functools](questions.md/#Опишите-функции-map-reduce-filter-модуля-functools)\n    + [Какие еще вы знаете функции из модуля functools](questions.md/#Какие-еще-вы-знаете-функции-из-модуля-functools)\n    + [Какие вы функции знаете из модуля itertools](questions.md/#Какие-вы-функции-знаете-из-модуля-itertools)\n    + [Для чего нужен модуль operator](questions.md/#Для-чего-нужен-модуль-operator)\n  * [GIL, потоки, процессы](questions.md/#GIL-потоки-процессы)\n    + [Что такое GIL. Какие у него есть проблемы](questions.md/#Что-такое-GIL-Какие-у-него-есть-проблемы)\n    + [Работали ли Вы с asyncio. В чём его особенность](questions.md/#Работали-ли-Вы-с-asyncio-В-чём-его-особенность)\n    + [Что такое async/await, для чего они нужны и как их использовать](questions.md/#Что-такое-asyncawait-для-чего-они-нужны-и-как-их-использовать)\n    + [Как в питоне реализуется многопоточность. Какими модулями](questions.md/#Как-в-питоне-реализуется-многопоточность-Какими-модулями)\n    + [В чем отличие тредов от мультипроцессинга](questions.md/#В-чем-отличие-тредов-от-мультипроцессинга)\n    + [Какие задачи хорошо параллелятся, какие плохо](questions.md/#Какие-задачи-хорошо-параллелятся-какие-плохо)\n    + [Нужно посчитать 100 уравнений. Делать это в тредах или нет](questions.md/#Нужно-посчитать-100-уравнений-Делать-это-в-тредах-или-нет)\n    + [Треды в Питоне — это нативные треды или нет](questions.md/#Треды-в-Питоне--это-нативные-треды-или-нет)\n    + [Что такое гринлеты. Общее понятие. Примеры реализаций](questions.md/#Что-такое-гринлеты-Общее-понятие-Примеры-реализаций)\n  * [Какие варианты реализации шаблона Singleton на питоне](questions.md/#Какие-варианты-реализации-шаблона-Singleton-на-питоне)\n  * [Какие вы знаете инструменты для проверки кодстайл](questions.md/#Какие-вы-знаете-инструменты-для-проверки-кодстайл)\n  * [Что такое list/dict comprehension](questions.md/#Что-такое-listdict-comprehension)\n  * [Какая разница между одинарным и двойным подчеркиванием](questions.md/#Какая-разница-между-одинарным-и-двойным-подчеркиванием)\n  * [Отличие copy() от deepcopy()](questions.md/#Отличие-copy-от-deepcopy)\n  * [Что такое garbage collector. В чём его плюсы и минусы](questions.md/#Что-такое-garbage-collector-В-чём-его-плюсы-и-минусы)\n  * [Что такое интроспекция](questions.md/#Что-такое-интроспекция)\n  * [Что такое рефлексия](questions.md/#Что-такое-рефлексия)\n- [Django](questions.md/#Django)\n  * [Что такое Middleware, для чего, как реализуется](questions.md/#Что-такое-Middleware-для-чего-как-реализуется)\n  * [Назовите основные мидлвари. Зачем они нужны](questions.md/#Назовите-основные-мидлвари-Зачем-они-нужны)\n  * [Опишите алгоритм работы CSRF middleware](questions.md/#Опишите-алгоритм-работы-CSRF-middleware)\n  * [Что такое сигналы? Зачем нужны? Назовите основные](questions.md/#Что-такое-сигналы-Зачем-нужны-Назовите-основные)\n  * [Как реализуется связь m2m на уровне базы данных](questions.md/#Как-реализуется-связь-m2m-на-уровне-базы-данных)\n  * [Чем лучше отправлять форму — GET или POST](questions.md/#Чем-лучше-отправлять-форму--GET-или-POST)\n  * [Как работает Serializer в Django REST Framework](questions.md/#Как-работает-Serializer-в-Django-REST-Framework)\n  * [Что такое Meta в классах Django и для чего нужен](questions.md/#Что-такое-Meta-в-классах-Django-и-для-чего-нужен)\n  * [За что отвечает Meta в сериализаторе](questions.md/#За-что-отвечает-Meta-в-сериализаторе)\n  * [Какая разница в быстродействии между django и Flask (и почему)](questions.md/#Какая-разница-в-быстродействии-между-django-и-Flask-и-почему)\n  * [Как в django работает система аутентификации](questions.md/#Как-в-django-работает-система-аутентификации)\n- [Веб-разработка](questions.md/#Веб-разработка)\n  * [Что такое CGI. Плюсы, минусы](questions.md/#Что-такое-CGI-Плюсы-минусы)\n  * [Как защитить куки от воровства и от подделки](questions.md/#Как-защитить-куки-от-воровства-и-от-подделки)\n  * [Какая разница между аутентификацией и авторизацией](questions.md/#Какая-разница-между-аутентификацией-и-авторизацией)\n  * [Что такое XSS. Примеры. Как защитить приложение](questions.md/#Что-такое-XSS-Примеры-Как-защитить-приложение)\n  * [REST & SOAP](questions.md/#REST--SOAP)\n    + [Что такое REST](questions.md/#Что-такое-REST)\n    + [Что такое SOAP](questions.md/#Что-такое-SOAP)\n    + [В чем разница между REST и SOAP веб сервисами](questions.md/#В-чем-разница-между-REST-и-SOAP-веб-сервисами)\n    + [Можем ли мы посылать SOAP сообщения с вложением](questions.md/#Можем-ли-мы-посылать-SOAP-сообщения-с-вложением)\n    + [Как бы вы решили какой из REST или SOAP веб сервисов использовать](questions.md/#Как-бы-вы-решили-какой-из-REST-или-SOAP-веб-сервисов-использовать)\n  * [Какие способы для мониторинга веб-приложений в production вы использовали или знаете](questions.md/#Какие-способы-для-мониторинга-веб-приложений-в-production-вы-использовали-или-знаете)\n- [HTTP](questions.md/#HTTP)\n  * [Как устроен протокол HTTP](questions.md/#Как-устроен-протокол-HTTP)\n  * [Написать raw запрос главной Яндекса](questions.md/#Написать-raw-запрос-главной-Яндекса)\n  * [Как клиенту понять, удался запрос или нет](questions.md/#Как-клиенту-понять-удался-запрос-или-нет)\n  * [Что нужно отправить браузеру, чтобы перенаправить на другую страницу](questions.md/#Что-нужно-отправить-браузеру-чтобы-перенаправить-на-другую-страницу)\n  * [Как управлять кешированием в HTTP](questions.md/#Как-управлять-кешированием-в-HTTP)\n  * [Как кэшируются файлы на уровне протокола](questions.md/#Как-кэшируются-файлы-на-уровне-протокола)\n  * [Что такое HTTP](questions.md/#Что-такое-HTTP)\n  * [Чем отличаются HTTP и HTTPS](questions.md/#Чем-отличаются-HTTP-и-HTTPS)\n- [Общее](questions.md/#Общее)\n  * [ООП](questions.md/#ООП)\n    + [Инкапсуляция](questions.md/#Инкапсуляция)\n    + [Наследование](questions.md/#Наследование)\n    + [Полиморфизм](questions.md/#Полиморфизм)\n    + [Абстракция](questions.md/#Абстракция)\n  * [Какие принципы программирования вы знаете](questions.md/#Какие-принципы-программирования-вы-знаете)\n    + [KISS](questions.md/#KISS)\n    + [DRY](questions.md/#DRY)\n    + [YAGNI](questions.md/#YAGNI)\n    + [SLAP](questions.md/#SLAP)\n    + [SOLID принципы](questions.md/#SOLID-принципы)\n  * [Что такое code cohesion & code coupling](questions.md/#Что-такое-code-cohesion--code-coupling)\n  * [Какие шаблоны проектирования вы знаете](questions.md/#Какие-шаблоны-проектирования-вы-знаете)\n    + [Порождающие (Creational)](questions.md/#Порождающие-Creational)\n      - [Абстрактная фабрика (Abstract factory)](questions.md/#Абстрактная-фабрика-Abstract-factory)\n      - [Построитель (Builder)](questions.md/#Построитель-Builder)\n      - [Фабричный метод (Factory method)](questions.md/#Фабричный-метод-Factory-method)\n      - [Прототип (Prototype)](questions.md/#Прототип-Prototype)\n      - [Одиночка (Singleton)](questions.md/#Одиночка-Singleton)\n      - [Порождающие паттерны. Итог](questions.md/#Порождающие-паттерны-Итог)\n    + [Структурные (Structural)](questions.md/#Структурные-Structural)\n      - [Адаптер (Adapter)](questions.md/#Адаптер-Adapter)\n      - [Мост (Bridge)](questions.md/#Мост-Bridge)\n      - [Компоновщик (Composite)](questions.md/#Компоновщик-Composite)\n      - [Декоратор (Decorator)](questions.md/#Декоратор-Decorator)\n      - [Фасад (Facade)](questions.md/#Фасад-Facade)\n      - [Приспособленец (Flyweight)](questions.md/#Приспособленец-Flyweight)\n      - [Заместитель (Proxy)](questions.md/#Заместитель-Proxy)\n      - [Структурные паттерны. Итог](questions.md/#Структурные-паттерны-Итог)\n    + [Поведенческие (Behavioral)](questions.md/#Поведенческие-Behavioral)\n      - [Цепочка ответственности (Chain of responsobility)](questions.md/#Цепочка-ответственности-Chain-of-responsobility)\n      - [Команда (Command)](questions.md/#Команда-Command)\n      - [Интерпретатор (Interpreter)](questions.md/#Интерпретатор-Interpreter)\n      - [Итератор (Iterator)](questions.md/#Итератор-Iterator)\n      - [Посредник (Mediator)](questions.md/#Посредник-Mediator)\n      - [Хранитель (Memento)](questions.md/#Хранитель-Memento)\n      - [Наблюдатель (Observer)](questions.md/#Наблюдатель-Observer)\n      - [Состояние (State)](questions.md/#Состояние-State)\n      - [Стратегия (Strategy)](questions.md/#Стратегия-Strategy)\n      - [Шаблонный метод (Template method)](questions.md/#Шаблонный-метод-Template-method)\n      - [Посетитель (Visitor)](questions.md/#Посетитель-Visitor)\n      - [Поведенческие паттерны. Итог](questions.md/#Поведенческие-паттерны-Итог)\n  * [Что такое lru cache](questions.md/#Что-такое-lru-cache)\n  * [Что такое MQ](questions.md/#Что-такое-MQ)\n  * [Какие готовые реализации MQ вы знаете](questions.md/#Какие-готовые-реализации-MQ-вы-знаете)\n  * [Что такое RPC](questions.md/#Что-такое-RPC)\n  * [Что такое gPRC](questions.md/#Что-такое-gPRC)\n- [Алгоритмы, структуры](questions.md/#Алгоритмы-структуры)\n  * [Что такое рекурсия. Какие минусы, плюсы](questions.md/#Что-такое-рекурсия-Какие-минусы-плюсы)\n  * [Что такое хвостовая рекурсия](questions.md/#Что-такое-хвостовая-рекурсия)\n  * [Как можно оптимизировать хвостовую рекурсию в Python](questions.md/#Как-можно-оптимизировать-хвостовую-рекурсию-в-Python)\n  * [О-большое при оценке сложности](questions.md/#О-большое-при-оценке-сложности)\n  * [Простой поиск](questions.md/#Простой-поиск)\n  * [Бинарный поиск](questions.md/#Бинарный-поиск)\n  * [Рекурсивные алгоритмы](questions.md/#Рекурсивные-алгоритмы)\n  * [Быстрая сортировка](questions.md/#Быстрая-сортировка)\n  * [Граф](questions.md/#Граф)\n  * [Очередь и стек](questions.md/#Очередь-и-стек)\n  * [Дерево](questions.md/#Дерево)\n  * [Поиск в ширину](questions.md/#Поиск-в-ширину)\n  * [Алгоритм Дейкстры](questions.md/#Алгоритм-Дейкстры)\n  * [Жадные алгоритмы](questions.md/#Жадные-алгоритмы)\n  * [Как распознать NP-полную задачу](questions.md/#Как-распознать-NP-полную-задачу)\n  * [Динамическое программирование](questions.md/#Динамическое-программирование)\n  * [Алгоритм k ближайших соседей](questions.md/#Алгоритм-k-ближайших-соседей)\n  * [Алгоритм Ричарда Фейнмана](questions.md/#Алгоритм-Ричарда-Фейнмана)\n- [Frontend](questions.md/#Frontend)\n  * [Что такое куки. Зачем они, как с ними работать и где они сохраняются](questions.md/#Что-такое-куки-Зачем-они-как-с-ними-работать-и-где-они-сохраняются)\n  * [Может ли сервер изменить (добавить, удалить) куки](questions.md/#Может-ли-сервер-изменить-добавить-удалить-куки)\n  * [Что такое JWT (JSON Web Token)](questions.md/#Что-такое-JWT-JSON-Web-Token)\n- [SDLC](questions.md/#SDLC)\n  * [Agile/Scrum](questions.md/#AgileScrum)\n  * [Какая разница между CI и CD](questions.md/#Какая-разница-между-CI-и-CD)\n  * [Какая разница между Scrum и Kanban](questions.md/#Какая-разница-между-Scrum-и-Kanban)\n  * [Вопрос для тим-лидов: что Вы будете делать, если на проекте нет тестов и заказчик не хочет тратить на их разработку время и деньги](questions.md/#Вопрос-для-тим-лидов-что-Вы-будете-делать-если-на-проекте-нет-тестов-и-заказчик-не-хочет-тратить-на-их-разработку-время-и-деньги)\n  * [Что такое Code Debt и как с ним быть](questions.md/#Что-такое-Code-Debt-и-как-с-ним-быть)\n- [VCS](questions.md/#VCS)\n  * [Что такое Git Flow](questions.md/#Что-такое-Git-Flow)\n  * [Что такое Git Rebase](questions.md/#Что-такое-Git-Rebase)\n  * [Что такое Git Cherry pick](questions.md/#Что-такое-Git-Cherry-pick)\n  * [Что такое force push](questions.md/#Что-такое-force-push)\n  * [Что такое pre-commit check](questions.md/#Что-такое-pre-commit-check)\n- [БД](questions.md/#БД)\n  * [Что такое транзакция. Какие у неё есть свойства](questions.md/#Что-такое-транзакция-Какие-у-неё-есть-свойства)\n  * [Какие команды управления транзакциями вы знаете](questions.md/#Какие-команды-управления-транзакциями-вы-знаете)\n  * [Что такое уровни изолированности транзакций. Какие они бывают](questions.md/#Что-такое-уровни-изолированности-транзакций-Какие-они-бывают)\n  * [Что такое вложенные транзакции](questions.md/#Что-такое-вложенные-транзакции)\n  * [Что такое курсор и зачем он нужен](questions.md/#Что-такое-курсор-и-зачем-он-нужен)\n  * [Какая разница между PostgreSQL и MySQL](questions.md/#Какая-разница-между-PostgreSQL-и-MySQL)\n  * [Что такое VACUUM в PostgreSQL](questions.md/#Что-такое-VACUUM-в-PostgreSQL)\n  * [Что такое EXPLAIN. Какая разница между ним и EXPLAIN ANALYZE](questions.md/#Что-такое-EXPLAIN-Какая-разница-между-ним-и-EXPLAIN-ANALYZE)\n  * [Какие виды Join'ов вы знаете, чем они отличаются друг от друга](questions.md/#Какие-виды-Joinов-вы-знаете-чем-они-отличаются-друг-от-друга)\n- [Дизайн-интервью](questions.md/#Дизайн-интервью)\n  * [План интервью](questions.md/#План-интервью)\n  * [1. Сбор требований](questions.md/#1-Сбор-требований)\n  * [2. Эстимейты](questions.md/#2-Эстимейты)\n  * [3. API](questions.md/#3-API)\n  * [4. High-level design](questions.md/#4-High-level-design)\n  * [5. Detailed design](questions.md/#5-Detailed-design)\n    + [Performance mantras](questions.md/#Performance-mantras)\n  * [6. Масштабирование](questions.md/#6-Масштабирование)\n    + [Performance bottlenecks](questions.md/#Performance-bottlenecks)\n- [Вопросы работодателю](questions.md/#Вопросы-работодателю)\n  * [Вопросы HR'у](questions.md/#Вопросы-HRу)\n  * [Вопросы для технического собеседования](questions.md/#Вопросы-для-технического-собеседования)\n- [Интересные ссылки](questions.md/#Интересные-ссылки)\n- [Источники вопросов](questions.md/#Источники-вопросов)\n"
        },
        {
          "name": "attachments",
          "type": "tree",
          "content": null
        },
        {
          "name": "book_res",
          "type": "tree",
          "content": null
        },
        {
          "name": "generate_toc.py",
          "type": "blob",
          "size": 3.294921875,
          "content": "import dataclasses\nimport re\nimport sys\nfrom typing import List\n\n\n@dataclasses.dataclass()\nclass Header:\n    name: str\n    level: int\n\n    @property\n    def slug(self):\n        text = self.name.replace(' ', '-')\n        # single chars that are removed\n        text = re.sub(r'[`~!@#$%^&*()+=<>?,./:;\"\\'|{}\\[\\]\\\\–—]', '', text)\n        # CJK punctuations that are removed\n        text = re.sub(r'[　。？！，、；：“”【】（）〔〕［］﹃﹄“”‘’﹁﹂—…－～《》〈〉「」]', '', text)\n        return text\n\n\nclass TOCMaker:\n    def __init__(\n            self,\n            *,\n            max_depth=6,\n            link_prefix='',\n            indentation_size=2,\n            list_bullets=('-', '*', '+', '-'),\n            header_class=Header,\n    ):\n        self.max_depth = max_depth\n        self.link_prefix = link_prefix\n        self.indentation_size = indentation_size\n        self.list_bullets = list_bullets\n        self.header_class = header_class\n\n    def make(self, text):\n        headers = self._collect_headers(text)\n        return self._make_toc(headers)\n\n    def make_from_file(self, fp):\n        return self.make(fp.read())\n\n    def _collect_headers(self, text):\n        headers = []\n\n        code_blocks = 0\n        for line in text.splitlines():\n            line = line.strip()\n            code_blocks += line.count('```') % 2\n            if code_blocks % 2 == 0 and line.startswith('#'):\n                header = self._parse_header_from_line(line)\n                if header.level <= self.max_depth:\n                    headers.append(self._parse_header_from_line(line))\n\n        return headers\n\n    def _make_toc(self, headers: List[Header]):\n        toc = []\n        for header in headers:\n            indentation = ' ' * ((header.level - 1) * self.indentation_size)\n            bullet = self._get_bullet(header.level)\n            toc.append(f'{indentation}{bullet} [{header.name}]({self.link_prefix}#{header.slug})')\n        return '\\n'.join(toc)\n\n    def _get_bullet(self, level):\n        if level > len(self.list_bullets):\n            return self.list_bullets[-1]\n        return self.list_bullets[level - 1]\n\n    def _parse_header_from_line(self, line):\n        level = 0\n        name = ''\n        for char in line:\n            if char == '#':\n                level += 1\n            else:\n                name = line[level + 1:].strip()\n                break\n\n        return self.header_class(\n            name=name,\n            level=level\n        )\n\n\ndef paste_after(delimiter, content, text):\n    result = []\n    for line in text.splitlines():\n        if line.strip() != delimiter:\n            result.append(line)\n        else:\n            result.append(f'{delimiter}\\n')\n            result.append(f'{content}\\n')\n            return '\\n'.join(result)\n\n    raise ValueError(f\"Can't find delimiter '{delimiter}'\")\n\n\nif __name__ == '__main__':\n    with open('questions.md') as fp:\n        maker = TOCMaker(link_prefix='questions.md/')\n        toc = maker.make_from_file(fp)\n\n    with open('README.md', 'r') as fp:\n        original = fp.read()\n        changed = paste_after('<!-- toc -->', toc, original)\n\n    if '--check' in sys.argv:\n        if original != changed:\n            print('Error')\n            sys.exit(1)\n    else:\n        with open('README.md', 'w') as fp:\n            fp.write(changed)\n\n    print('Done')\n"
        },
        {
          "name": "metadata.txt",
          "type": "blob",
          "size": 0.3408203125,
          "content": "---\ntitle:\n- type: main\n  text: Вопросы для подготовки к Python Developer интервью\n- type: edition\n  text: dev-build\nauthor:\n- yakimka <https://github.com/yakimka>\n- pavlenk0 <https://github.com/pavlenk0>\ntoc-title: Содержание\nlanguage: ru-RU\nstylesheet: book_res/style.css\ncover-image: book_res/cover.png\n...\n"
        },
        {
          "name": "questions.md",
          "type": "blob",
          "size": 431.6357421875,
          "content": "# Python\n\n## Последовательности\n\n### Что такое последовательность\n\nПоследовательностью в Python называется итерабельный объект, который поддерживает эффективный доступ к элементам с использованием целочисленных индексов через специальный метод `__getitem__()` и поддерживает метод `__len__()`, который возвращает длину последовательности.\nК основным встроенным типам последовательностей относятся list, tuple, range, str и bytes.\n\nПоследовательности также опционально могут реализовывать методы `count()`, `index()`, `__contains__()` и `__reversed__()` и другие.\n\n### Какие операции поддерживают большинство последовательностей\n\n- `x in s`, `x not in s` – находится ли элемент x в последовательности s (для строк и последовательностей байтов – является ли x подстрокой s)\n- `s + t` – конкатенация последовательностей s и t\n- `s * n, n * s` – конкатенация n нерекурсивных копий последовательности s\n- `s[i]` – i-й элемент последовательности s\n- `s[:i]` - срез всех элементов последовательности s до i (не включая i)\n- `s[i:]` - срез всех элементов последовательности s от i до последнего элемента\n- `s[-i:]` - срез последних i элементов последовательности s\n- `s[::-1]` - перевернуть последовательность\n- `s[i:j]` – срез последовательности s от i до j (не включая j)\n- `s[i:j:k]` – срез последовательности s от i до j с шагом k (не включая j)\n- `len(s)` – длина последовательности s\n- `min(s)` – минимальный элемент последовательности s\n- `max(s)` – максимальный элемент последовательности s\n- `s.index(x[, i[, j]])` – индекс первого вхождения x (опционально – начиная с позиции i и до позиции j)\n- `s.count(x)` – общее количество вхождений x в s\n- `sum(s)` – сумма элементов последовательности\n\nНеизменяемые последовательности обычно реализуют операцию hash(s) – хеш-значение объекта.\n\nБольшинство изменяемых последовательностей поддерживают следующие операции:\n\n- `s[i] = x` – элемент с индексом i заменяется на x\n- `s[i:j] = t`, `s[i:j:k] = t` – элементы с индексами от i до j (с шагом k) заменяются содержимым итерабельного объекта t\n- `del s[i:j]`, `del s[i:j:k]` – удаление соответствующих элементов из последовательности\n- `s.append(x)` – добавление x в конец последовательности\n- `s.clear()` – удаление всех элементов последовательности\n- `s.copy()` – нерекурсивная копия последовательности\n- `s.extend(t)` – добавление всех элементов итерабельного объекта в конец последовательности\n- `s.insert(i, x)` – вставка элемента x по индексу i\n- `s.pop()`, `s.pop(i)` – возврат значения по индексу i (по умолчанию – последний элемент) и удаление его из последовательности\n- `s.remove(x)` – удаление первого вхождения x\n- `s.reverse()` – разворот последовательности в обратном порядке\n\n### Какие виды строк бывают в питоне\n\nЗависит от версии Питона. Во второй ветке два типа: однобайтные строки и Юникод представлены классами str и unicode соответственно. В третьем Питоне есть один вид строк str, который представляет собой Юникод. Однобайтных строк нет, вместо них есть тип bytes, то есть цепочка байт.\n\n### Можно ли изменить отдельный символ внутри строки\n\nНет, строки неизменяемы. Операции замены, форматирования и конкатенации возвращают новую строку.\n\n### Как соединить список строк в одну. Как разбить строку на список строк\n\nЧтобы соединить, нужен метод строки `.join()`. Чтобы разбить, метод `.split()`.\n\n### Как кодировать и декодировать строки\n\nКодировать – перевести Юникод в байтовую строку. Вызвать метод `.encode()` у строки.\n\nДекодировать – восстановить строку из цепочки байт. Вызвать метод `.decode()` у объекта `str` или `bytes` (версии Питона 2 и 3 соответственно).\n\nВ обоих случаях явно передавать кодировку, иначе будет использована та, что определена в системе по умолчанию. Быть готовым поймать исключения `UnicodeEncodeError`, `UnicodeDecodeError`.\n\n### Чем список отличается от кортежа\n\nСписки – это изменяемые последовательности, обычно используемые для хранения однотипных данных (хотя Python не запрещает хранить в них данные разных типов). Представлены классом list.\n\nКортежи – это неизменяемые последовательности, обычно используемые, чтобы хранить разнотипные данные. Представлены классом tuple.\n\nНа уровне языка отличаются тем, что в кортеж нельзя добавить или убрать элемент. На уровне интерпретатора различий нет. Обе коллекции представлены массивом указателей на структуру `PyObject`.\n\nСуществуют специальные функции для работы со списками. Они вызываются методами списка. Ниже приведены наиболее часто используемые.\n\n```python\n# Создаем исходный список\nlst = [1, 2, 3]\n\n# append(x): добавляет элемент в конец списка\nlst.append(4)\n# Теперь lst = [1, 2, 3, 4]\n\n# extend(iterable): расширяет список, добавляя элементы из итерируемого объекта\nlst.extend([5, 6])\n# Теперь lst = [1, 2, 3, 4, 5, 6]\n\n# insert(i, x): вставляет элемент x на позицию i\nlst.insert(0, 'start')\n# Теперь lst = ['start', 1, 2, 3, 4, 5, 6]\n\n# remove(x): удаляет первое вхождение элемента x\nlst.remove(3)\n# Теперь lst = ['start', 1, 2, 4, 5, 6]\n\n# pop([i]): удаляет и возвращает элемент на позиции i (по умолчанию последний)\nlast = lst.pop()\n# last = 6, а lst = ['start', 1, 2, 4, 5]\n\n# sort(): сортирует список на месте\nlst = [3, 1, 4, 1, 5, 9, 2]\nlst.sort()\n# Теперь lst = [1, 1, 2, 3, 4, 5, 9]\n\n# reverse(): разворачивает список на месте\nlst.reverse()\n# Теперь lst = [9, 5, 4, 3, 2, 1, 1]\n```\n\n\n\n### Что такое диапазон\n\nДиапазоны – неизменяемые последовательности чисел, которые задаются началом, концом и шагом. Представлены классом range (в Python 2 – xrange; range в Python 2 – это функция, которая возвращает список).\nПараметры конструктора должны быть целыми числами (либо экземпляры класса int, либо любой объект с методом `__index__`)\nПоддерживает все общие для последовательностей операции, кроме конкатенации и повторения, а также, в версиях Python до 3.2, срезов и отрицательных индексов.\n\n### Как сделать список уникальным (без повторяющихся элементов)\n\nВариант со множеством. Не гарантирует порядок элементов. Порядок сохраняется только для маленьких списков.\n\n```python\nlist(set([1, 2, 2, 2, 3, 3, 1]))\n>>> [1, 2, 3]\n```\n\nВариант с OrderedDict. Гарантирует порядок элементов.\n\n```python\n>>> from collections import OrderedDict\n>>> list(OrderedDict.fromkeys([1, 2, 2, 2, 3, 3, 1]))\n[1, 2, 3]\n```\n\nВариант с циклом. Медленно, но гарантирует порядок. Подходит, если элементы нельзя помещать внутрь множества (например, словари).\n\n```python\nres = []\nfor x in [1, 2, 2, 2, 3, 3, 1]:\n    if x not in res:\n        res.append(x)\n>>> [1, 2, 3]\n```\n\n### Есть кортеж из трех элементов. Назначить переменным a, b, c его значения\n\n`a, b, c = (1, 2, 3)`\n\n### Как сравниваются последовательности\n\nДве последовательности равны, если они имеют одинаковый тип, равную длину и соответствующие элементы обоих последовательностей равны.\n\nПоследовательности одинаковых типов можно сравнивать. Сравнения происходят в лексикографическом порядке: последовательность меньшей длины меньше, чем последовательность большей длины, если же их длины равны, то результат сравнения равен результату сравнения первых отличающихся элементов.\n\n## Множества и отображения\n\n### Как понять хешируемый ли объект\n\nОбъект называется хешируемым, если он имеет хеш-значение (целое число), которое никогда не изменяется на протяжении его жизненного цикла и возвращается методом `__hash__()`, и может сравниваться с другими объектами (реализует метод `__eq__()`). Равные хешируемые объекты должны иметь равные хеш-значения.\nВсе стандартные неизменяемые объекты хешируемые. Все стандартные изменяемые объекты не хешируемые.\n\n### Что такое множество\n\nМножество – это неупорядоченная коллекция хешируемых объектов, которые не повторяются.\nВ множествах нет понятия позиции элемента. Соответственно, они не поддерживают индексацию и срезы.\nВстроенные классы множеств: set (изменяемое множество), frozenset (неизменяемое множество).\n\n### Для чего применяются множества\n\nОбычно используются для проверки элемента на вхождение в множество и удаление повторений элементов и выполнения таких операций, как объединение, пересечение, разница и симметрическая разница.\n\n### Какие операции можно производить над множествами\n\n- `set([iterable])`, `frozenset([iterable])` – создание множества (пустого или из элементов итерабельного объекта)\n- `len(s)` – количество элементов множества\n- `x in s`, `x not in s` – проверка нахождения элемента в множестве\n- `s.isdisjoint(t)` – проверка того, что данное множество не имеет общих элементов с заданным\n- `s.issubset(t)`, `s <= t` – проверка того, что все элементы множества s являются элементами множества t\n- `s < t` – проверка того, что s <= t и s != t\n- `s.isuperset(t)`, `s >= t` – проверка того, что все элементы множества t являются элементами множества s\n- `s > t` – проверка того, что `s >= t` и `s != t`\n- `s.union(t, ...)`, `s | t | ...` – создание нового множества, которое является объединением данных множеств\n- `s.intersection(t, ...)`, `s & t & ...` – создание нового множества, которое является пересечением данных множеств\n- `s.difference(t, ...)`, `s - t - ...` – создание нового множества, которое является разницей данных множеств\n- `s.symmetric_difference(t)`, `s ^ t` – создание нового множества, которое является симметрической разницей данных множеств (то есть, разница объединения и пересечения множеств)\n- `s.copy()` – неполная копия множества s\n\nОперации над множествами, которые являются методами, принимают в качестве аргументов любые итерабельные объекты. Операции над множествами, записанные в виде бинарных операций, требуют, чтобы второй операнд операции тоже был множеством, и возвращают множество того типа, которым было первое множество.\n\nОперации над изменяемыми множествами:\n\n- `s.update(t, ...)`, `s |= t | ...` – добавить в данное множество элементы из других множеств\n- `s.intersection_update(t, ...)`, `s &= t & ...` – оставить в данном множестве только те элементы, которые есть и в других множествах\n- `s.difference_update(t, ...)`, `s -= t | ...` – удалить из данного множества те элементы, которые есть в других множествах\n- `s.symmetric_difference_update(t)`, `s ^= t` – оставить или добавить в s элементы, которые есть либо в s, либо в t, но не в обоих множествах\n- `s.add(element)` – добавить новый элемент в множество\n- `s.remove(element)` – удалить элемент из множества; если такого элемента нет, возникает исключение KeyError\n- `s.discard(element)` – удалить элемент из множества, если он в нём находится\n- `s.pop()` – удалить из множества и вернуть произвольный элемент; если множество пустое, возникает исключение KeyError\n- `s.clear()` – удалить все элементы множества.\n\n### Как происходит проверка множеств на равенство\n\nПроверка множеств на равенство происходит поэлементно, независимо от типов множеств.\n\n### Что такое отображение\n\nОтображение (mapping) – это объект-контейнер, который поддерживает произвольный доступ к элементам по ключам и описывает все методы, описанные в абстрактном базовом классе `collections.Mapping` (`get()`, `items()`, `keys()`, `values()`) или `collections.MutableMapping` (`clear()`, `get()`, `items()`, `keys()`, `pop()`, `popitem()`, `setdefault()`, `update()`, `values()`).\nК отображениям относятся классы `dict`, `collections.defaultdict`, `collections.OrderedDict` и `collections.Counter`.\n\n### Какие нюансы есть в использовании чисел как ключей\n\nЧисловые ключи в словарях подчиняются правилам сравнения чисел. Таким образом, `int(1)` и `float(1.0)` считаются одинаковым ключом. Однако из-за того, что значения типа float сохраняются приближенно, не рекомендуется использовать их в качестве ключей.\n\n```python\n>>> {True: 'yes', 1: 'no', 1.0: 'maybe'}\n{True: 'maybe'}\n```\n\n### Какие операции можно производить над отображениями\n\n- `len(d)` – количество элементов.\n- `d[key]` – получение значения с ключом key. Если такой ключ не существует и отображение реализует специальный метод `__missing__(self, key)`, то он вызывается. Если ключ не существует и метод `__missing__` не определён, выбрасывается исключение KeyError.\n- `d[key] = value` – изменить значение или создать новую пару ключ-значение, если ключ не существует.\n- `key in d`, `key not in d` – проверка наличия ключа в отображении.\n- `iter(d)` – то же самое, что iter(d.keys()).\n- `clear()` – удалить все элементы словаря.\n- `copy()` – создать неполную копию словаря.\n- `(метод класса) dict.fromkeys(sequence[, value])` – создаёт новый словарь с ключами из последовательности sequence и заданным значением (по умолчанию – None).\n- `d.get(key[, default])` – безопасное получение значения по ключу (никогда не выбрасывает KeyError). Если ключ не найден, возвращается значение default (по-умолчанию – None).\n- `d.items()` – в Python 3 возвращает объект представления словаря, соответствующий парам (двухэлементным кортежам) вида (ключ, значение). В Python 2 возвращает соответствующий список, а метод iteritems() возвращает итератор. Аналогичный метод в Python 2.7 – viewitems().\n- `d.keys()` – в Python 3 возвращает объект представления словаря, соответствующий ключам словаря. В Python 2 возвращает соответствующий список, а метод iterkeys() возвращает итератор. Аналогичный метод в Python 2.7 – viewkeys().\n- `d.pop(key[, default])` – если ключ key существует, удаляет элемент из словаря и возвращает его значение. Если ключ не существует и задано значение default, возвращается данное значение, иначе выбрасывается исключение KeyError.\n- `d.popitem()` – удаляет произвольную пару ключ-значение и возвращает её. Если словарь пустой, возникает исключение KeyError. Метод полезен для алгоритмов, которые обходят словарь, удаляя уже обработанные значения (например, определённые алгоритмы, связанные с теорией графов).\n- `d.setdefault(key[, default])` – если ключ key существует, возвращает соответствующее значение. Иначе создаёт элемент с ключом key и значением default. default по умолчанию равен None.\n- `d.update(mapping)` – принимает либо другой словарь или отображение, либо итерабельный объект, состоящий из итерабельных объектов – пар ключ-значение, либо именованные аргументы. Добавляет соответствующие элементы в словарь, перезаписывая элементы с существующими ключами.\n- `d.values()` – в Python 3 возвращает объект представления словаря, соответствующий значениям. В Python 2 возвращает соответствующий список, а метод itervalues() возвращает итератор. Аналогичный метод в Python 2.7 – viewvalues().\n\n### Что возвращает метод items\n\nОбъекты, возвращаемые методами `items()`, `keys()` и `values()` (`viewitems()`, `viewkeys()`, `viewvalues()` в Python 2.7) – это объекты *представления словаря*. Они предоставляют динамическое представление элементов словаря, то есть изменения данного словаря автоматически отображаются и на этих объектах.\n\nОперации с представлениями словарей:\n\n- `iter(dictview)` – получение итератора по ключам, значениям или парам ключей и значений. Все представления словарей при итерировании возвращают элементы словаря в одинаковом порядке. При попытке изменить словарь во время итерирования может возникнуть исключение RuntimeError\n- `len(dictview)` – количество элементов в словаре.\n- `x in dictview` – проверка существования ключа, значения или пары ключ-значение в словаре.\n\n### Как отсортировать список словарей по определенному полю\n\nМетод списка `.sort()` и встроенная функция `sorted()` принимают параметр `key`. Им должен быть вызываемый объект, который принимает очередной элемент (в нашем случае словарь) и возвращает значение-критерий сортировки.\n\nКод ниже показывает, как отсортировать список людей по возрасту:\n\n```python\nusers = [{'age': 30}, {'age': 20}, {'age': 10}]\nusers.sort(key=lambda user: user['age'])\n>>> [{'age': 10}, {'age': 20}, {'age': 30}]\n```\n\n### Что может являться ключом словаря. Что не может. Почему\n\nКлючом словаря может быть любой хешируемый неизменяемый объект: число, строка, datetime, функция и даже модуль. Такие объекты имеют метод `__hash__()`, который однозначно сопоставляет объект с некоторым числом. По этому числу словарь ищет значение для ключа.\n\nСписки, словари и множества изменяемы и не имеют метода хеширования. При подстановке их в словарь возникнет ошибка.\n\nХеш кортежа вычисляется рекурсивно по всем элементам. Так, кортеж\n\n`(1, (True, (42, ('hello', ))))`\nсостоит только из неизменяемых элементов, поэтому может быть ключом. Однако, такой кортеж\n\n`(1, (True, (42, ({'hello': 'world'}, ))))`\nсодержит глубоко внутри словарь, поэтому хеш не может быть рассчитан.\n\n### Есть два списка – ключи и значения. Как составить из них словарь\n\n```python\nkeys = ['foo', 'bar', 'baz']\nvals = [1, 2, 3]\ndict(zip(keys, vals))\n>>> {'baz': 3, 'foo': 1, 'bar': 2}\n```\n\nФункция `zip` отдает список пар N-ых элементов. Конструктор `dict` принимает список пар. Каждую пару он рассматривает как ключ и значение соответственно.\n\n### Как работает хэш-таблица\n\nХэш-таблица это разреженный массив (массив, в котором имеются незаполненные позиции). В стандартных англоязычных учебниках ячейки хэш-таблицы называются \"bucket\". В хэш-таблице dict каждому элементу соотвествует ячейка, содержащая два поля: ссылку на ключ и ссылку на значение элемента. Поскольку размер всех ячеек одинаков, доступ к отдельной ячейке производится по смещению.\n\nPython стремится оставить не менее трети ячеек пустыми; если хэш-таблица становится чрезмерно заполненной, то она копируется в новый участок памяти, где есть место для большего числа ячеек.\n\nДля помещения элемента в хэш-таблицу нужно первым делом вычислить хэш-значение ключа элемента. Это делает встроенная функция `hash()`.\n\nДля выборки значения с помощью выражения `my_dict[search_key]` Python обращается к функции `hash(search_key)`, чтобы получить хэш-значение search_key, и использует несколько младших битов полученного числа как смещение ячейки относительно начала хэш-таблицы (сколько именно битов зависит от текущего размера таблицы). Если найденная ячейка пуста, возбуждается исключение `KeyError`. В противном случае в найденной ячейке есть какой-то элемент - пара `ключ:значение` - и тогда Python проверяет, верно ли то, что search_key == found_key. Если да, то элемент найден и возвращается found_value. Если же search_key и found_key не совпали, то имеет место *коллизия хэширования*. Для разрешения коллизии алгоритм берет различные биты хэш-значения, производит над ними определенные действия и использует результат как смещение другой ячейки.\n\n### Что такое коллизия\n\nКогда хеш-функция возвращает один и тот же ответ для разных данных.\n\n### Где будет быстрее поиск, а где перебор и почему: dict, list, set, tuple\n\nПоиск будет быстрее в dict и set, потому что это хэш-таблицы, доступ к элементу которых выполняется за O(1). Для list и tuple поиск будет выполняться в среднем за O(n).\n\nИсключение работает только для очень маленьких списков длиной до 5 элементов. В этом случае интерпретатору будет быстрей пробежаться по списку, чем считать хеш.\n\nВ Python 2 методы словаря `keys`, `values`, `items` возвращают список. Тоесть перед итерацией по словарю (или сету) интерпретатор сначала создает новый список, что занимает дополнительное время и память, но после создания это уже обыкновенный список. Тоесть в Python 2 итерация по словарям и сетам выполняется дольше, за счет создания нового списка и копирования в него элементов.\n\nВ Python 3 эти методы создают объект-представление. Это определенно происходит быстрее чем создание нового списка в Python2. Но итерирование по такому представлению должно происходить немного дольше, чем по списку из-за того что данные в словарях хранятся разреженно (редко, негусто). В подтверждение вышесказанного (Python 3):\n\n```python\n>>> l = list(range(1000000))\n>>> d = dict.fromkeys(l)\n>>> s = set(l)\n>>> def iter_list():\n...     for i in l:\n...         pass\n...\n>>> def iter_dict():\n...     for i in d:\n...         pass\n...\n>>> def iter_set():\n...     for i in s:\n...         pass\n...\n>>> timeit.timeit(iter_list, number=1000)\n 6.727667486004066\n>>> timeit.timeit(iter_dict, number=1000)\n 9.293120226997416\n>>> timeit.timeit(iter_set, number=1000)\n 8.627948219014797\n```\n\n## Функции\n\n### Что такое args, kwargs. В каких случаях они требуются\n\nВыражения `*args` и `**kwargs` объявляют в сигнатуре функции. Они означают, что внутри функции будут доступны переменные с именами `args` и `kwargs` (без звездочек). Можно использовать другие имена, но это считается дурным тоном.\n\n`args` – это кортеж, который накапливает позиционные аргументы. `kwargs` – словарь именованных аргументов, где ключ – имя параметра, значение – значение параметра.\n\n**Важно:** если в функцию не передано никаких параметров, переменные будут соответственно равны пустому кортежу и пустому словарю, а не `None`.\n\nПожалуйста, не путайте кортеж со списком. Следующий вопрос объясняет, почему.\n\n### Почему использовать изменяемые объекты как параметры по-умолчанию плохо. Приведите пример плохого случая. Как исправить\n\nФункция создается однажды при загрузке модуля. Именованные параметры и их дефолтные значения тоже создаются один раз и хранятся в одном из полей объекта-функции.\n\nВ нашем примере `bar` равен пустому списку. Список – изменяемая коллекция, поэтому значение `bar` может изменяться от вызова к вызову. Пример:\n\n```python\ndef foo(bar=[]):\n    bar.append(1)\n    return bar\nfoo()\n>>> [1]\nfoo()\n[1, 1]\nfoo()\n>>> [1, 1, 1]\n```\n\nХорошим тоном считается указывать параметру пустое неизменяемое значение, например `0`, `None`, `''`, `False`. В теле функции проверять на заполненность и создавать новую коллекцию:\n\n```python\ndef foo(bar=None):\n    if bar is None:\n        bar = []\n    bar.append(1)\n    return bar\nfoo()\n>>> [1]\nfoo()\n>>> [1]\nfoo()\n>>> [1]\n```\n\nСказанное выше актуально в т.ч. для множеств и словарей.\n\n### Можно ли передавать функцию в качестве аргумента другой функции\n\nМожно, функция в Питоне объект первого порядка: допускает присваивание, передачу в функцию, удаление.\n\n### Можно ли объявлять функцию внутри другой функции. Где она будет видна\n\nМожно. Такая функция будет видна только внутри первой функции.\n\n### Что такое лямбды. Каковы их особенности\n\nЭто анонимные функции. Они не резервируют имени в пространстве имен. Лямбды\nчасто передают в функции `map`, `reduce`, `filter`.\n\nЛямбды в Питоне могут состоять только из одного выражения. Используя синтаксис\nскобок, можно оформить тело лямбды в несколько строк.\n\nИспользовать точку с запятой для разделения операторов нельзя.\n\n### Допустимы ли следующие выражения\n\n- `nope = lambda: pass`\n- `riser = lambda x: raise Exception(x)`\n\nНет, при загрузке модуля выскочит исключение `SyntaxError`. В теле лямбды может\nбыть только выражение. `pass` и `raise` являются операторами.\n\n### Как передаются значения аргументов в функцию или метод\n\n- [How do I write a function with output parameters (call by reference)?](https://docs.python.org/3/faq/programming.html#how-do-i-write-a-function-with-output-parameters-call-by-reference)\n- [Интересности и полезности python. Часть 3](https://habr.com/ru/post/422951/)\n\nВ таких языках как C++ есть переменные, хранящиеся на стеке и в динамической памяти. При вызове функции мы помещаем все аргументы на стек, после чего передаём управление функции. Она знает размеры и смещения переменных на стеке, соответственно может их правильно интерпретировать.\nПри этом у нас есть два варианта: скопировать на стек память переменной или положить ссылку на объект в динамической памяти (или на более высоких уровнях стека).\nОчевидно, что при изменении значений на стеке функции, значения в динамической памяти не поменяются, а при изменении области памяти по ссылке, мы модифицируем общую память, соответственно все ссылки на эту же область памяти «увидят» новое значение.\n\nВ python отказались от подобного механизма, заменой служит механизм *связывания (assignment)* имени переменной с объектом, например при создании переменной:\n`var = \"john\"`\n\nИнтерпретатор создаёт объект «john» и «имя» var, а затем связывает объект с данным именем.\nПри вызове функции, новых объектов не создаётся, вместо этого в её области видимости создаётся имя, которое связывается с существующим объектом.\nНо в python есть изменяемые и неизменяемые типы. Ко вторым, например, относятся числа: при арифметических операциях существующие объекты не меняются, а создаётся новый объект, с которым потом связывается существующее имя. Если же со старым объектом после этого не связано ни одного имени, оно будет удалено с помощью механизма подсчёта ссылок.\nЕсли же имя связано с переменной изменяемого типа, то при операциях с ней изменяется память объекта, соответственно все имена, связанные с данной областью памяти «увидят» изменения.\n\n### Что такое замыкание\n\nСинтаксически это выглядит как функция, находящаяся целиком в теле другой функции. При этом вложенная внутренняя функция содержит ссылки на локальные переменные внешней функции. Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней.\n\n## Итераторы и генераторы\n\n- [Генераторы-итераторы Python](https://xakep.ru/2014/10/06/generatora-iteratory-python/)\n- [Итерируемый объект, итератор и генератор](https://habr.com/ru/post/337314/)\n\n### Что такое контейнер\n\nКонтейнер – это тип данных, который инкапсулирует в себе значения других типов. Списки, кортежи, множества, словари и т.д. являются контейнерами.\n\n### Что такое итерабельный объект\n\n*Итерабельный объект* (в оригинальной терминологии – «iterable») – это объект, который может возвращать значения по одному за раз.\nПримеры: все контейнеры и последовательности (списки, строки и т.д.), файлы, а также экземпляры любых классов, в которых определён метод `__iter__()` или `__getitem__()`.\nИтерабельные объекты могут быть использованы внутри цикла `for`, а также во многих других случаях, когда ожидается последовательность (функции `sum()`, `zip()`, `map()` и т.д.).\n\n**Подробнее**:\n\nРассмотрим итерируемый объект (`Iterable`). В стандартной библиотеке он объявлен как абстрактный класс `collections.abc.Iterable`:\n\n```python\nclass Iterable(metaclass=ABCMeta):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __iter__(self):\n        while False:\n            yield None\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Iterable:\n            return _check_methods(C, \"__iter__\")\n        return NotImplemented\n```\n\nУ него есть абстрактный метод `__iter__` который должен вернуть объект итератора. И метод `__subclasshook__` который проверяет наличие у класса метод `__iter__`. Таким образом, получается, что итерируемый объект это любой объект который реализует метод `__iter__`\n\n```python\nclass SomeIterable1(collections.abc.Iterable):\n    def __iter__(self):\n        pass\n\nclass SomeIterable2:\n    def __iter__(self):\n        pass\n\nprint(isinstance(SomeIterable1(), collections.abc.Iterable))\n# True\nprint(isinstance(SomeIterable2(), collections.abc.Iterable))\n# True\n```\n\nНо есть один момент, это функция `iter()`. Именно эту функцией использует например цикл for для получения итератора. Функция `iter()` в первую очередь для получения итератора из объекта, вызывает его метод `__iter__`. Если метод не реализован, то она проверяет наличие метода `__getitem__` и если он реализован, то на его основе создается итератор. `__getitem__` должен принимать индекс с нуля. Если не реализован ни один из этих методов, тогда будет вызвано исключение `TypeError`.\n\n```python\nfrom string import ascii_letters\n\nclass SomeIterable3:\n    def __getitem__(self, key):\n        return ascii_letters[key]\n\nfor item in SomeIterable3():\n    print(item)\n```\n\n### Что такое итератор\n\n*Итератор* (iterator) – это объект, который представляет поток данных. Повторяемый вызов метода `__next__()` (`next()` в Python 2) итератора или передача его встроенной функции `next()` возвращает последующие элементы потока.\n\nЕсли больше не осталось данных, выбрасывается исключение `StopIteration`. После этого итератор исчерпан и любые последующие вызовы его метода `__next__()` снова генерируют исключение `StopIteration`.\n\nИтераторы обязаны иметь метод `__iter__`, который возвращает сам объект итератора, так что любой итератор также является итерабельным объектом и может быть использован почти везде, где принимаются итерабельные объекты.\n\n**Подробнее:**\n\nИтераторы представлены абстрактным классом `collections.abc.Iterator`:\n\n```python\nclass Iterator(Iterable):\n\n    __slots__ = ()\n\n    @abstractmethod\n    def __next__(self):\n        'Return the next item from the iterator. When exhausted, raise StopIteration'\n        raise StopIteration\n\n    def __iter__(self):\n        return self\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is Iterator:\n            return _check_methods(C, '__iter__', '__next__')\n        return NotImplemented\n```\n\n`__next__` Возвращает следующий доступный элемент и вызывает исключение `StopIteration`, когда элементов не осталось.\n`__iter__` Возвращает `self`. Это позволяет использовать итератор там, где ожидается итерируемых объект, например `for`.\n`__subclasshook__` Проверяет наличие у класса метода `__iter__` и `__next__`\n\n### Что такое генератор\n\nВ зависимости от контекста, может означать либо функцию-генератор, либо итератор генератора (чаще всего, последнее).\nМетоды `__iter__` и `__next__` у генераторов создаются автоматически.\n\nС точки зрения реализации, *генератор* в Python — это языковая конструкция, которую можно реализовать двумя способами: как функция с ключевым словом `yield` или как генераторное выражение. В результате вызова функции или вычисления выражения, получаем объект-генератор типа `types.GeneratorType`. Канонический пример - генератор, порождающий последовательность чисел Фибоначчи, которая, будучи бесконечна, не смогла бы поместиться ни в одну коллекцию. Иногда термин применяется для самой генераторной функции, а не только объекта, возвращенного ей в качестве результата.\n\nТак как в объекте-генераторе определены методы `__next__` и `__iter__`, то есть реализован протокол итератора, с этой точки зрения, в Python любой генератор является итератором.\n\nКогда выполнение функции-генераторы завершается (при помощи ключевого слова `return` или достижения конца функции), возникает исключение `StopIteration`.\n\n### Что такое генераторная функция\n\n*Генераторная функция* - функция, в теле которой встречается ключевое слово `yield`. Будучи вызвана, такая функция возвращает объект-генератор (generator object) (итератор генератора (generator iterator)).\n\n### Что делает yield\n\n`yield` замораживает состояние функции-генератора и возвращает текущее значение. После следующего вызова `__next__()` функция-генератор продолжает своё выполнение с того места, где она была приостановлена.\n\n### В чем отличие \\[x for x in y\\] от (x for x in y)\n\nПервое выражение возвращает список (списковое включение), второе – генератор.\n\n### Что особенного в генераторе\n\nГенератор хранит в памяти не все элементы, а только внутреннее состояние для вычисления очередного элемента. На каждом шаге можно вычислить только следующий элемент, но не предыдущий. Пройти генератор в цикле можно только один раз.\n\n### Как объявить генератор\n\n- использовать синтаксис `(x for x in seq)`\n- оператор `yield` в теле функции вместо `return`\n- встроенная функция `iter`, которая вызывает у объекта метод `__iter__()`. Этот метод должен возвращать генератор.\n\n### Как получить из генератора список\n\nПередать его в конструктор списка: `list(x for x in some_seq)`. Важно, что после этого по генератору уже нельзя будет итерироваться.\n\n### Что такое подгенератор\n\nВ Python 3 существуют так называемые подгенераторы (subgenerators). Если в функции-генераторе встречается пара ключевых слов `yield from`, после которых следует объект-генератор, то данный генератор делегирует доступ к подгенератору, пока он не завершится (не закончатся его значения), после чего продолжает своё исполнение.\n\nНа самом деле `yield` является выражением. Оно может принимать значения, которые отправляются в генератор. Если в генератор не отправляются значения, результат данного выражения равен `None`.\n\n`yield from` также является выражением. Его результатом является то значение, которое подгенератор возвращает в исключении `StopIteration` (для этого значение возвращается при помощи ключевого слова `return`).\n\n### Какие методы есть у генераторов\n\n- `__next__()` – начинает или продолжает исполнение функции-генератора. Результат текущего yield-выражения будет равен None. Выполнение затем продолжается до следующего yield-выражения, которое передаёт значение туда, где был вызван `__next__`. Если генератор завершается без возврата значения при помощи `yield`, возникает исключение `StopIteration`. Метод обычно вызывается неявно, то есть циклом `for` или встроенной функцией `next()`.\n- `send(value)` – продолжает выполнение и отправляет значение в функцию-генератор. Аргумент value становится значением текущего yield-выражения. Метод `send()` возвращает следующее значение, возвращённое генератором, или выбрасывает исключение `StopIteration`, если генератор завершается без возврата значения. Если `send()` используется для запуска генератора, то единственным допустимым значением является `None`, так как ещё не было выполнено ни одно yield-выражение, которому можно присвоить это значение.\n- `throw(type[, value[, traceback]])` – выбрасывает исключение типа type в месте, где был приостановлен генератор, и возвращает следующее значение генератора (или выбрасывает `StopIteration`). Если генератор не обрабатывает данное исключение (или выбрасывает другое исключение), то оно выбрасывается в месте вызова.\n- `close()` – выбрасывает исключение `GeneratorExit` в месте, где был приостановлен генератор. Если генератор выбрасывает `StopIteration` (путём нормального завершения или по причине того, что он уже закрыт) или `GeneratorExit` (путём отсутствия обработки данного исключения), `close` просто возвращается к месту вызова. Если же генератор возвращает очередное значение, выбрасывается исключение `RuntimeError`. Метод `close()` ничего не делает, если генератор уже завершён.\n\n### Можно ли извлечь элемент генератора по индексу\n\nНет, будет ошибка. Генератор не поддерживает метод `__getitem__`.\n\n### Что возвращает итерация по словарю\n\nКлюч. Порядок следования ключей не гарантируется (в 3.6 гарантируется неофициально, в 3.7 гарантируется). Для маленьких словарей порядок будет тот же, что и в объявлении. Для больших порядок зависит от расположения элементов в памяти. Особый класс `OrderedDict` учитывает порядок добавления ключей.\n\n```python\nfor key in {'foo': 1, 'bar': 2}:\n    process_key(key)\n```\n\n### Как итерировать словарь по парам ключ-значение\n\nМетод словаря `.items()` возвращает генератор кортежей `(key, value)`.\n\n### Что такое сопрограмма\n\nСопрограмма (англ. coroutine) — компонент программы, обобщающий понятие подпрограммы, который дополнительно поддерживает множество входных точек (а не одну, как подпрограмма) и остановку и продолжение выполнения с сохранением определённого положения.\nРасширенные возможности генераторов в Python (выражения yield и yield from, отправка значений в генераторы) используются для реализации сопрограмм.\nСопрограммы полезны для реализации асинхронных неблокирующих операций и кооперативной многозадачности в одном потоке без использования функций обратного вызова (callback-функций) и написания асинхронного кода в синхронном стиле.\nPython 3.5 включает в себе поддержку сопрограмм на уровне языка. Для этого используются ключевые слова async и await.\n\n## Классы, объекты\n\n### Как получить список атрибутов объекта\n\nФункция `dir` возвращает список строк – полей объекта. Поле `__dict__` содержит словарь вида `{поле -> значение}`.\n\n### Что такое магические методы, для чего нужны\n\nМагическими метода называют методы, имена которых начинаются и заканчиваются двойным подчеркиванием. Магические они потому, что почти никогда не вызываются явно. Их вызывают встроенные функции или синтаксические конструкции. Например, функция `len()` вызывает метод `__len__()` переданного объекта. Метод `__add__(self, other)` вызывается автоматически при сложении оператором `+`.\n\nПеречислим некоторые магические методы:\n\n- `__init__`: инициализатор класса\n- `__add__`: сложение с другим объектом\n- `__eq__`: проверка на равенство с другим объектом\n- `__iter__`: возвращает итератор\n\n### Как в классе сослаться на родительский класс\n\nФункция `super` принимает класс и экземпляр:\n\n```python\nclass NextClass(FirstClass):\n    def __init__(self, x):\n        super(NextClass, self).__init__()\n        self.x = x\n```\n\n### Возможно ли множественное наследование\n\nДа, можно указать более одного родителя в классе потомка.\n\n### Что такое MRO\n\n*MRO* – method resolution order, порядок разрешения методов. Алгоритм, по которому следует искать метод в случае, если у класса два и более родителей.\n\nВ классических классах поиск при наследовании по ссылкам на имена осуществляется в следующем порядке:\n\n1. Сначала экземпляр\n2. Затем его класс\n3. Далее все суперклассы его класса с обходом сначала с глубину, а затем слева направо\n\nИспользуется первое обнаруженное вхождение. Такой порядок называется DFLR (Обход вглубину и слева направо).\n\nПри наследовании классов нового стиля применяется правило MRO (порядок разрешения методов), т.е линеаризованный обход дерева классов, причем вложенный элемент наследования становится доступным в атрибуте `__mro__` данного класса. Такой алгорим называется *C3-линеаризация*. Наследование по правилу MRO осуществляется приблизительно в следующем порядке.\n\n1. Перечисление всех классов, наследуемых экземпляром, по правилу поиска DFLR для классических классов, причем класс включается в результат поиска столько раз, сколько он встречается при обходе.\n2. Просмотр в полученном списке дубликатов классов, из которых удаляются все, кроме последнего (крайнего справа) дубликата в списке.\n\nУпорядочение по правилу MRO применяется при наследовании и вызове встроенной функции super(), которая всегда вызывает следующий по правилу MRO класс (относительно точки вызова).\n\n**Пример наследования в неромбовидных иерархаических деревьях:**\n\n```python\nclass D:          attr = 3      #  D:3   E:2\nclass B(D)        pass          #   |     |\nclass E:          attr = 2      #   B    C:1\nclass C(E):       attr = 1      #    /   /\nclass A(B, C):    pass          #      A\nX = A()                         #      |\nprint(X.attr)                   #      X\n\n# DFLR = [X, A, B, D, C, E]\n# MRO = [X, A, B, D, C, E, object]\n# И в версии 3.х и в версии 2.х (всегда) выводит строку \"3\"\n```\n\n**Пример наследования в ромбовидных иерархаических деревьях:**\n\n```python\nclass D:          attr = 3      #  D:3   D:3\nclass B(D)        pass          #   |     |\nclass C(D):       attr = 1      #   B    C:1\nclass A(B, C):    pass          #    /   /\nX = A()                         #      A\nprint(X.attr)                   #      |\n                                #      X\n\n# DFLR = [X, A, B, D, C, D]\n# MRO = [X, A, B, C, D, object] (сохраняет только последний дубликат D)\n# Выводит строку \"1\" в версии 3.х, строку \"3\" в версии 2.х  (\"1\" если D(object))\n```\n\n### Что такое Diamond problem\n\nПри ромбовидном наследовании определить метод какого класса должен быть вызван\n\n### Что такое миксины\n\nМиксин (mix-in, анг. “примесь”), паттерн проектирования в ООП, когда в цепочку наследования добавляется небольшой класс-помощник. Например, есть класс\n\n```python\nclass NowMixin(object):\n    def now():\n        return datetime.datetime.utcnow()\n```\n\nТогда любой класс, наследованный с этим миксином, будет иметь метод `now()`.\n\nВ названия миксинов принято добавлять слово `Mixin`, так как не существует никакого механизма для понимания полноценный это класс или миксин. Миксин технически является самым обычным классом.\n\n### Что такое контекстный менеджер. Как написать свой\n\nВ питоне есть оператор `with`. Размещенный внутри код выполняется с особенностью: до и после гарантированно срабатывают события входа в блок `with`и выхода из него. Объект, который определяет эту логику, называется контекстным менеджером.\n\nСобытия входа и выхода из блока определены методами `__enter__` и `__exit__`. Первый срабатывает в тот момент, когда ход исполнения программы переходит внутрь `with`. Метод может вернуть значение. Оно будет доступно низлежащему внутри блока `with` коду.\n\n`__exit__` срабатывает в момент выхода из блока, в т.ч. и по причине исключения. В этом случае в метод будет передана тройка значений `(exc_class, exc_instance, traceback)`.\n\nСамый распространённый контекстный менеджер – класс, порожденный функцией `open`. Он гарантирует, что файл будет закрыт даже в том случае, если внутри блока возникнет ошибка.\n\nНужно стараться выходить из контекстного менеджера как можно быстрее, чтобы освобождать контекст и ресурсы.\n\n```python\nwith open('file.txt') as f:\n    data = f.read()\nprocess_data(data)\n```\n\nПример реализации своего контекстного менеджера на основе класса:\n\n```python\nclass Printable:\n    def __enter__(self):\n        print('enter')\n\n    def __exit__(self, type, value, traceback):\n        print('exit')\n```\n\nПример реализации своего контекстного менеджера с использованием встроенной библиотеки contextlib:\n\n```python\nfrom contextlib import contextmanager\n\n@contextmanager\ndef printable():\n    print('enter')\n    try:\n      yield\n    finally:\n      print('exit')\n```\n\nКонтекстные менеджеры также можно использовать для временной замены параметров, переменных окружения, транзакций БД.\n\n### Прокомментировать выражение\n\n`object() == object()`\n\nВсегда ложь, поскольку по умолчанию объекты сравниваются по полю id (адрес в памяти), если только не переопределен метод `__eq__`.\n\n### Что такое \\_\\_slots\\_\\_. Плюсы, минусы\n\nКлассы хранят поля и их значения в секретном словаре `__dict__`. Поскольку словарь – изменяемая структура, вы можете на лету добавлять и удалять из класса поля. Параметр `__slots__` в классе жестко фиксирует набор полей класса. Слоты используются когда у класса может быть очень много полей, например, в некоторых `ORM`, либо когда критична производительность, потому что доступ к слоту срабатывает быстрее, чем поиск в словаре, или когда в процессе выполнения программы создаются миллионы экземпляров класса, применение `__slots__` позволит сэкономить память.\n\nСлоты активно используются в библиотеках `requests` и `falcon`.\n\nНедостатотк: нельзя присвоить классу поле, которого нет в слотах. Не работают методы `__getattr__` и `__setattr__`.\nРешение: включить в `__slots__` элемент `__dict__`\n\n### В чем смысл параметров _value, __value\n\nПоле класса с одним лидирующим подчеркиванием говорит о том, что параметр используется только внутри класса. При этом он доступен для обращения извне. Это ограничение доступа только на уровне соглашения.\n\n```python\nclass Foo(object):\n    def __init__(self):\n        self._bar = 42\n\nFoo()._bar\n>>> 42\n```\n\nСовременные IDE вроде `PyCharm` подсвечивают обращение к полю с подчеркиванием, но ошибки в процессе исполнения не будет.\n\nПоля с двойным подчеркиванием доступны внутри класса, но недоступны извне. Это достигается хитрым приемом: интерпретатор назначает таким полям имена вида `_<ClassName>__<fieldName>`. Описанный механизм называется *name mangling* или *name decoration*\n\n```python\nclass Foo(object):\n    def __init__(self):\n        self.__bar = 42\n\nFoo().__bar\n>>> AttributeError: 'Foo' object has no attribute '__bar'\nFoo()._Foo__bar\n>>> 42\n```\n\n### Что такое \\_\\_new\\_\\_. И чем он отличается от \\_\\_init\\_\\_. В какой последовательности они выполняются\n\nОсновное различие между этими двумя методами состоит в том, что `__new__` обрабатывает создание объекта, а `__init__` обрабатывает его инициализацию.\n\n`__new__` вызывается автоматически при вызове имени класса (при создании экземпляра), тогда как `__init__` вызывается каждый раз, когда экземпляр класса возвращается `__new__`, передавая возвращаемый экземпляр в `__init__` в качестве параметра `self`, поэтому даже если вы сохранили экземпляр где-нибудь глобально/статически и возвращали его каждый раз из `__new__`, для него все-равно будет каждый раз вызываться `__init__`.\n\nИз вышесказанного вытекает что сначала вызывается `__new__`, а потом `__init__`\n\n### Что такое и чем отличается old-style от new-style classes\n\nКлассы нового стиля (3.х доступны только они, в 2.х при наследовании от `object`) отличаются от классических (по умолчанию в 2.х) следующими особенностями:\n\n- Причиной создания new style classes послужила идея убрать отличие встроенных типов от определённых пользователем типов. [Unifying types and classes in Python 2.2](https://www.python.org/download/releases/2.2.3/descrintro/)\n- Ромбовидные шаблоны множественного наследования имеют несколько иной порядок поиска. Поиск в них осуществляется скорее в ширину, чем в глубину, перед тем как начать обход снизу вверх (см. вопрос про MRO)\n- Классы теперь обозначают типы, а типы являются классами. Так, в результате вызова встроенной функции `type(I)` возвращается класс, из которого получается экземпляр, а не тип экземпляра, что, как правило, равнозначно выражению `I.__class__`. От класса `type` могут быть произведены подклассы для создания специальных классов. Все классы наследуют от встроенного класса `object`, предоставляющего по умолчанию небольшой набор методов\n\n### Что такое утиная типизация\n\nНеявная типизация, латентная типизация или *утиная типизация* (англ. Duck typing) – вид динамической типизации, применяемой в некоторых языках программирования (Perl, Smalltalk, Python, Objective-C, Ruby, JavaScript, Groovy, ColdFusion, Boo, Lua, Go, C#), когда границы использования объекта определяются его текущим набором методов и свойств, в противоположность наследованию от определённого класса.\nТо есть считается, что объект реализует интерфейс, если он содержит все методы этого интерфейса, независимо от связей в иерархии наследования и принадлежности к какому-либо конкретному классу.\n\nУтиная типизация решает такие проблемы иерархической типизации, как:\n\n- невозможность явно указать (путём наследования) на совместимость интерфейса со всеми настоящими и будущими интерфейсами, с которыми он идейно совместим;\n- экспоненциальное увеличение числа связей в иерархии типов при хотя бы частичной попытке это сделать.\n\n## Модули, пакеты\n\n### Что такое модуль\n\nМодуль – функционально законченный фрагмент программы, оформленный в виде отдельного файла с исходным кодом или поименованной непрерывной её части. Модули позволяют разбивать сложные задачи на более мелкие в соответствии с принципом модульности.\nФайл, который содержит исходный код на языке Python, является модулем.\nМодули могут объединяться в пакеты и, далее, в библиотеки.\n\n### Как можно получить имя модуля\n\nНазвание модуля доступно в его глобальной переменной `__name__`. Если модуль не импортирован, а запущен как скрипт, то `__name__` устанавливается в значение `\"__main__\"`.\n\n### Что такое модульное программирование\n\nМодульное программирование – это организация программы как совокупности небольших независимых блоков, называемых модулями, структура и поведение которых подчиняются определенным правилам. Использование модульного программирования позволяет упростить тестирование программы и обнаружение ошибок. Аппаратно-зависимые подзадачи могут быть строго отделены от других подзадач, что улучшает мобильность создаваемых программ.\n\n### Как Python ищет модули при импорте\n\nПри импортировании модулей интерпретатор Python ищет их в директориях и архивах, список которых доступен как для чтения, так и для модификации в виде переменной path встроенного модуля sys.\nПо умолчанию sys.path состоит из директории с запускаемым скриптом, содержимого переменной окружения PYTHONPATH и стандартного расположения модулей, специфичного для конкретной платформы и интерпретатора.\n\n### Что такое пакет\n\nМодули могут объединяться в пакеты. Пакеты служат как пространства имён для модулей и способ их структурирования.\nЛюбой пакет является модулем, но не каждый модуль является пакетом.\nКак правило, модули представляются в виде файлов, а пакеты – каталогов в файловой системе (но не всегда).\nДля того, чтобы каталог был пакетом, в нём должен находиться файл `__init__.py`. Он автоматически выполняется при импортировании соответствующего модуля и может содержать определённые действия для инициализации или быть пустым.\n\n### Что вы можете сказать о конструкции import package.item\n\nПри использовании оператора from package import item, item может быть пакетом, модулем или любым именем, описанным в пакете. При использовании оператора import package.item, item должен быть модулем или пакетом.\n\n## Исключения\n\n### Что такое обработка исключений\n\nОбработка *исключительных ситуаций* или обработка *исключений* (англ. exception handling) — механизм языков программирования, предназначенный для описания реакции программы на ошибки времени выполнения и другие возможные проблемы (исключения), которые могут возникнуть при выполнении программы и приводят к невозможности (бессмысленности) дальнейшей отработки программой её базового алгоритма.\n\nКод на Python может сгенерировать исключение при помощи ключевого слова raise. После него указывается объект исключения. Также можно указать класс исключения, в таком случае будет автоматически вызван конструктор без параметров. raise может выбрасывать в качестве исключений только экземпляры класса BaseException и его наследников, а также (в Python 2) экземпляры классов старого типа.\n\n### Для чего могут применять конструкцию try finally без except\n\n```python\ntry:\n    # some code\nfinally:\n    # some code\n```\n\nЕсли в блоке try произойдет ошибка, то блок finally все-равно будет выполнен и внутри него можно будет сделать \"cleanup\", например.\n\n### Как правильно по-разному обрабатывать исключения\n\nБлоки except обрабатываются сверху вниз и управление передаётся не больше, чем одному обработчику. Поэтому при необходимости по-разному обрабатывать исключения, находящиеся в иерархии наследования, сначала нужно указывать обработчики менее общих исключений, а затем – более общих.\nТакже именно поэтому *bare except* может быть только последним (иначе SyntaxError). Причём если сначала расположить обработчики более общих исключений, то обработчики менее общих будут просто проигнорированы.\n\n### Что будет если ошибку не обработает блок except\n\nЕсли ни один из заданных блоков except не перехватывает возникнувшее исключение, то оно будет перехвачено ближайшим внешним блоков try/except, в котором есть соответствующий обработчик. Если же программа не перехватывает исключение вообще, то интерпретатор завершает выполнение программы и выводит информацию об исключении в стандартный поток ошибок sys.stderr.\nИз этого правила есть два исключения:\n\n- Если исключение возникло в деструкторе объекта, выполнение программы не завершается, а в стандартный поток ошибок выводится предупреждение “Exception ignored” с информацией об исключении.\n- При возникновении исключения SystemExit происходит только завершение программы без вывода информации об исключении на экран (не касается предыдущего пункта, в деструкторе поведение данного исключения будет таким же, как и остальных).\n\n### Что делать если нужно перехватить исключение, выполнить действия и опять возбудить это же исключение\n\nДля того, чтобы в обработчике исключения выполнить определённые действия, а затем передать исключение дальше, на один уровень обработчиков выше (то есть, выбросить то же самое исключение ещё раз), используется ключевое слово raise без параметров.\n\n```python\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n  # some logic\n  raise\n```\n\n### Что такое сцепление исключений\n\nВ Python 3 при возбуждении исключения в блоке except, старое исключение сохраняется в атрибуте данных `__context__` и если новое исключение не обработано, то будет выведена информация о том, что новое исключение возникло при обработке старого («During handling of the above exception, another exception occurred:»).\nТакже, можно связывать исключения в одну цепь или заменять старые новыми. Для этого используется конструкция `raise новое_исключение from старое_исключение` либо `raise новое_исключение from None`.\nВ первом случае указанное исключение сохраняется в атрибуте `__cause__` и атрибут `__suppress_context__` (который подавляет вывод исключения из `__context__`) устанавливается в True. Тогда, если новое исключение не обработано, будет выведена информация о том, что старое исключение является причиной нового («The above exception was the direct cause of the following exception:»).\nВо втором случае `__suppress_context__` устанавливается в True и `__cause__` в None. Тогда при выводе исключения оно, фактически, будет заменено новым (хотя старое исключение всё ещё хранится в `__context__`).\n\nВ Python 2 нет сцепления исключений. Любое исключение, выброшенное в блоке except, заменяет старое.\n\n### Зачем нужен блок else\n\nБлок else выполняется, если в процессе выполнения блока try не возникло исключений. Он предназначен для того, чтобы отделить код, который может вызвать исключение, которое должно быть обработано в данном блоке try/except, от кода, который может вызвать исключение того же класса, которое должно быть перехвачено на уровне выше, и свести к минимуму количество операторов в блоке try.\n\n### Что можно передать в конструктор исключения\n\nИсключения могут принимать в качестве параметра конструктора любые неименованные аргументы. Они помещаются в атрибуте данных args в виде кортежа (неизменяемого списка). Чаще всего используется один строковой параметр, который содержит сообщение об ошибке. Во всех исключениях определён метод `__str__`, который по умолчанию вызывает str(self.args).\nВ Python 2 также имеется атрибут message, в который помещается `args[0]`, если `len(args) == 1`.\n\n### Какие есть классы исключений\n\n- Базовые:\n  - BaseException – базовый класс для всех исключений.\n  - Exception – класс-наследник BaseException, базовый класс для для всех стандартных исключений, которые не указывают на обязательное завершение программы, и всех пользовательских исключений.\n  - StandardError (Python 2) – базовый класс для всех встроенных исключений, кроме StopIteration, GeneratorExit, KeyboardInterrupt и SystemExit.\n  - ArithmeticError – базовый класс для всех исключений, связанных с арифметическими операциями.\n  - BufferError – базовый класс для исключений, связанных с операциями над буфером.\n  - LookupError – базовый класс для исключений, связанных с неверным ключом или индексом коллекции.\n  - EnvironmentError (Python 2) – базовый класс для исключений, связанных с ошибками, которые происходят вне интерпретатора Python. В Python 3 его роль выполняет OSError.\n- Некоторые из конкретных стандартных исключений:\n  - AssertionError – провал условия в операторе assert.\n  - AttributeError – ошибка обращения к атрибуту.\n  - FloatingPointError – ошибка операции над числами с плавающей точкой.\n  - ImportError – ошибка импортирования модуля или имени из модуля.\n  - IndexError – неверный индекс последовательности (например, списка).\n  - KeyboardInterrupt – завершение программы путём нажатия Ctrl+C в консоли.\n  - MemoryError – нехватка памяти.\n  - NameError – имя не найдено.\n  - NotImplementedError – действие не реализовано. Предназначено, среди прочего, для создания абстрактных методов.\n  - OSError – системная ошибка.\n  - OverflowError – результат арифметической операции слишком большой, чтобы быть представлен.\n  - RuntimeError – общая ошибка времени выполнения, которая не входит ни в одну из категорий.\n  - SyntaxError – ошибка синтаксиса.\n  - IndentationError – подкласс SyntaxError – неверный отступ.\n  - TabError – подкласс IndentationError – смешанное использование символов табуляции и пробелов.\n  - SystemError – некритичная внутренняя ошибка интерпретатора. При возникновении данного исключения следует оставить отчёт об ошибке на сайте [bugs.python.org](https://bugs.python.org/)\n  - SystemExit – исключение, которое генерируется функцией sys.exit(). Служит для завершения работы программы.\n  - TypeError – ошибка несоответствия типов данных.\n  - UnboundLocalError – подкласс NameError – обращение к несуществующей локальной переменной.\n  - ValueError – генерируется, когда функции или операции передан объект корректного типа, но с некорректным значением, причём эту ситуацию нельзя описать более точным исключением, таким как IndexError.\n  - ZeroDivisionError – деление на ноль.\n\n### В каких случаях можно обработать SyntaxError\n\nОшибка синтаксиса возникает, когда синтаксический анализатор Python сталкивается с участком кода, который не соответствует спецификации языка и не может быть интерпретирован.\nПоскольку, в случае синтаксической ошибки в главном модуле, она возникает до начала выполнения программы и не может быть перехвачена, учебник для начинающих в документации языка Python даже разделяет синтаксические ошибки и исключения. Однако SyntaxError – это тоже исключение, которое наследуется от Exception, и существуют ситуации, когда оно может возникнуть во время исполнения и быть обработано, а именно:\n\n- ошибка синтаксиса в импортируемом модуле;\n- ошибка синтаксиса в коде, который представляется строкой и передаётся функции eval или exec.\n\n### Можно ли создавать собственные исключения\n\nМожно. Они должны быть наследниками класса Exception. Принято называть исключения так, что имя их класса заканчивается словом Error.\n\n### Для чего нужны предупреждения (warnings) и как создать собственное\n\nПредупреждения обычно выводятся на экран в ситуациях, когда не гарантируется ошибочное поведение и программа, как правило, может продолжать работу, однако пользователя следует уведомить о чём-либо.\nБазовым классом для предупреждений является Warning, который наследуется от Exception.\nБазовым классом-наследником Warning для пользовательских предупреждений является UserWarning.\n\n### Для чего нужен модуль warnings\n\nВ модуле warnings собраны функции для работы с предупреждениями.\nОсновной является функция warn, которая принимает один обязательный параметр message, который может быть либо строкой-сообщением, либо экземпляром класса или подкласса Warning (в таком случае параметр category устанавливается автоматически) и два опциональных параметра: category (по умолчанию – UserWarning) – класс предупреждения и stacklevel (по умолчанию – 1) – уровень вложенности функций, начиная с которого необходимо выводить содержимое стека вызовов (полезно, например, для функций-обёрток для вывода предупреждений, где следует задать stacklevel=2, чтобы предупреждение относилось к месту вызова данной функции, а не самой функции).\n\n## Декораторы\n\n- [Понимаем декораторы в Python'e, шаг за шагом. Шаг 1](https://habr.com/ru/post/141411/)\n- [Понимаем декораторы в Python'e, шаг за шагом. Шаг 2](https://habr.com/ru/post/141501/)\n\n### Что такое декораторы. Зачем нужны\n\nДекоратор в широком смысле - паттерн проектирования, когда один объект изменяет поведение другого. В Питоне декоратор, как правило, это функция A, которая принимает функцию B и возвращает функцию C. При этом функция C задействует в себе функцию B.\n\nЗадекорировать функцию значит заменить ее на результат работы декоратора.\n\n### Что может быть декоратором. К чему может быть применен декоратор\n\nДекоратором может быть любой вызываемый объект: функция, лямбда, класс, экземпляр класса. В последнем случае определите метод `__call__`.\n\nПрименять декоратор можно к любому объекту. Чаще всего к функциям, методам и классам. Декорирование встречается настолько часто, что под него выделен особый оператор `@`.\n\n```python\ndef auth_only(view):\n    ...\n\n@auth_only\ndef dashboard(request):\n    ...\n```\n\nЕсли бы оператора декорирования не существовало, мы бы записали код выше так:\n\n```python\ndef auth_only(view):\n    ...\n\ndef dashboard(request):\n    ...\n\ndashboard = auth_only(dashboard)\n```\n\n### Что будет, если декоратор не возвращает ничего\n\nЕсли в теле функции нет оператора `return`, вызов вернет `None`. Помним, результат декоратора замещает декорируемый объект. В нашем случае декоратор вернет `None` и функция, которую мы декорируем, тоже станет `None`. При попытке вызвать ее после декорирования получим ошибку \"NoneType is not callable\".\n\n### В чем отличие \\@foobar от \\@foobar()\n\nПервое -- обычное декорирование функцией foobar.\n\nВторой случай -- декорирование функцией, которую вернет вызов foobar. По-другому это называется параметрический декоратор или фабрика декораторов. См. следующий вопрос.\n\n### Что такое фабрика декораторов\n\nЭто функция, которая возвращает декоратор. Например, вам нужен декоратор для проверки прав. Логика проверки одинакова, но прав может быть много. Чтобы не плодить копипасту, напишем фабрику декораторов.\n\n```python\nfrom functools import wraps\n\ndef has_perm(perm):\n    def decorator(view):\n        @wraps(view)\n        def wrapper(request):\n            if perm in request.user.permissions:\n                return view(request)\n            else:\n                return HTTPRedirect('/login')\n        return wrapper\n    return decorator\n\n@has_perm('view_user')\ndef users(request):\n    ...\n```\n\n### Зачем нужен wraps\n\n`wraps` - декоратор из стандартной поставки Python, модуль `functools`. Он назначает функции-врапперу те же поля `__name__`, `__module__`, `__doc__`, что и у исходной функции, которую вы декорируете. Это нужно для того, чтобы после декорирования функция-враппер в стектрейсах выглядела как декорируемая функция.\n\n## Метаклассы\n\n- [Метаклассы в Python: что это такое и с чем его едят](https://proglib.io/p/metaclasses-in-python/)\n- [Метаклассы в Python](https://habr.com/ru/post/145835/)\n\n### Что такое метаклассы\n\nМетакласс это «штука», которая создаёт классы.\n\nМы создаём класс для того, чтобы создавать объекты, так? А классы являются объектами. Метакласс это то, что создаёт эти самые объекты.\n\n### Что такое type. Как работает поиск метакласса при создании объекта\n\n`type` это метакласс, который Питон внутренне использует для создания всех классов.\n\nКогда вы пишете:\n\n```python\nclass Foo(Bar):\n  pass\n```\n\nПитон делает следующее:\n\n- Есть ли у класса Foo атрибут `__metaclass__`?\n- Если да, создаёт в памяти объект-класс с именем Foo, используя то, что указано в `__metaclass__`.\n- Если Питон не находит `__metaclass__`, он ищет `__metaclass__` в родительском классе Bar и попробует сделать то же самое.\n- Если же `__metaclass__` не находится ни в одном из родителей, Питон будет искать `__metaclass__` на уровне модуля.\n- И если он не может найти вообще ни одного `__metaclass__`, он использует `type` для создания объекта-класса.\n\n### Как работают метаклассы\n\n- перехватить создание класса\n- изменить класс\n- вернуть модифицированный\n\n### Зачем вообще использовать метаклассы\n\nОсновное применение метаклассов это создание API. Типичный пример — Django ORM.\n\nОна позволяет написать что-то в таком духе:\n\n```python\nclass Person(models.Model):\n  name = models.CharField(max_length=30)\n  age = models.IntegerField()\n```\n\nОднако если вы выполните следующий код:\n\n```python\nguy = Person(name='bob', age='35')\nprint guy.age\n\n```\n\nвы получите не `IntegerField`, а `int`, причём значение может быть получено прямо из базы данных.\n\nЭто возможно, потому что `models.Model` определяет `__metaclass__`, который сотворит некую магию и превратит класс `Person`, который мы только что определили простым выражением в сложную привязку к базе данных.\n\nDjango делает что-то сложное выглядящее простым, выставляя наружу простой API и используя метаклассы, воссоздающие код из API и незаметно делающие всю работу.\n\n## Ввод-Вывод\n\n### Что такое файловый объект\n\nФайловый объект – объект, предоставляющий файл-ориентированный API (методы `read()`, `write()` и т.д.) для доступа к ресурсу. В зависимости от способа создания, файловый объект может предоставлять доступ к реальному файлу на диске или другому виду устройства хранения или передачи данных (стандартные потоки ввода/вывода, буферы в памяти, сокеты и т.д.).\nФайловые объекты также называют потоками.\nФайловые объекты являются контекстными менеджерами.\n\n### Какие есть виды файловых объектов\n\nНа уровне типов данных в Python 2 нет отличия между текстовыми и бинарными файлами. При открытии можно указать текстовый либо бинарный режим, но это влияет только на преобразования концов строк при выполнении под ОС Windows, а под Unix-системами, где преобразования концов строк не требуются, не влияет ни на что.\n\nВ Python 3 существует три вида файловых объектов: текстовые файлы (text files), «обычные» (небуферизированные) бинарные файлы (raw binary files) и буферизированные бинарные файлы (buffered binary files). Разные виды потоков представляются соответствующими классами модуля io.\n\nМодуль io был обратно портирован в последние версии Python 2, поэтому в Python 2 также при желании можно использовать систему ввода-вывода, аналогичную Python 3.\n\n### В чем отличие текстовых и бинарных файлов\n\nТекстовые файлы записывают и считывают данные типа str и автоматически выполняют преобразования кодировок и концов строк. Бинарные файлы записывают и считывают данные типов bytes и bytearray и не производят никаких манипуляций с данными: всё записывается и считывается в таком же виде, как и сохраняется.\n\n### Как пользоваться функцией open\n\nСигнатура функции в Python 2: `open(file, mode='r', buffering=-1)`.\n\nСигнатура функции в Python 3 (и в Python 2 при использовании функции io.open):\n`open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)`.\n\nОсновные параметры:\n\n- file – имя файла или файловый дескриптор;\n- mode – режим открытия файла;\n- encoding – кодировка файла;\n- buffering – использовать ли буферизацию: отрицательное число (по умолчанию, указывать явно не нужно) – стандартное значение для данного вида файлового объекта, 0 – отключить буферизацию, 1 – построчная буферизация (для текстовых файлов), другое значение – включить буферизацию и задать соответствующий размер буфера.\n\nОбязательным параметром является только первый. Чаще всего функция `open()` используется с двумя параметрами.\n\nmode может начинаться с символов «r» (чтение), «w» (запись, очищает файл, если уже существует), «x» (исключительное создание, неуспешно, если файл уже существует), «a» (добавление, запись в конец файла).\nТакже параметр mode может иметь вторую букву для определения типа файла: «t» для текстового (по умолчанию) и «b» для бинарного.\nТакже можно добавить символ «+» для открытия в режиме чтения и записи одновременно. Порядок последних двух символов не имеет значения: «rb+» и «r+b» задают один и тот же режим.\n\n### Для чего необходимо закрывать файлы\n\nПосле окончания работы с файлом следует обязательно его закрыть при помощи метода `close()`, особенно если он был открыт для записи. При использовании буферизированного вывода данные, которые записываются в файл, не попадают в него сразу, а записываются в буфер.\nСодержимое буфера записывается в файл при его заполнении или вызове методов `flush()` или `close()`. Кроме того, если файл открыт для записи, он будет заблокирован для открытия для записи другими процессами до момента закрытия. Все открытые файлы автоматически закрываются при удалении соответствующих файловых объектов из памяти сборщиком мусора интерпретатора Python и при завершении работы самого интерпретатора, однако следует держать файлы открытыми минимально требуемое время.\n\n### Что делают методы tell и seek\n\nМетод `tell()` возвращает текущую позицию считывания/записи в файле. Метод `seek(offset, whence)` устанавливает её. Параметр offset задаёт отступ, а whence – точку, от которой данный отступ считается: `io.SEEK_SET(0)` – начало файла, `io.SEEK_CUR(1)` – текущая позиция, `io.SEEK_END(2)` – конец файла.\n\n### Что делают StringIO и BytesIO\n\nКлассы `io.StringIO` и `io.BytesIO`, представляют собой потоки для считывания и записи в строки или байтовые строки в памяти. Они могут быть использованы для того, чтобы использовать строки и байтовые строки в качестве текстовых и бинарных файлов.\n\n### Являются ли файловые объекты контекстными менеджерами\n\nДа, являются\n\n### Что такое сериализация\n\nСериализация – это процесс сохранения объектов в двоичном или строковом виде для хранения, передачи и восстановления. Обратный процесс называется десериализацией. Термины-синонимы маршалинг/анмаршалинг\n\n### json.dumps / json.dump , json.loads / json.load\n\nФункция dumps модуля json сохраняет JSON-представление объекта в строку. Функция dump – в текстовый файл.\nФункция loads модуля json загружает объект из строки. Функция load – из текстового файла.\n\n### Что делать если нужно сериализовать данные, которые не поддерживаются стандартным модулем json\n\nМожно использовать pickle или расширить классы JSONEncoder и JSONDecoder.\n\n### pickle.dumps / pickle.dump, pickle.loads / pickle.load\n\nФункции dump, dumps, load и loads модуля pickle аналогичны по своему предназначению соответствующим функциям модуля JSON, но работают с байтовыми строками и бинарными файлами.\n\nОпциональный параметр protocol данных функций задаёт версию протокола. Последнюю версию протокола можно получить как константу pickle.HIGHEST_PROTOCOL, текущую версию по умолчанию – pickle.DEFAULT_PROTOCOL.\n\nНа момент написания данного текста существует пять версий протокола:\n\n- 0 и 1 – это устаревшие версии, которые использовались в Python 2.2 и ниже;\n- 2 – это основная версия протокола для Python 2;\n- 3 – версия протокола, которая появилась в Python 3, стандартный протокол в Python 3 на текущий момент, не может быть десериализован в Python 2;\n- 4 – версия протокола, появившаяся в Python 3.4, поддерживает очень большие по объёму памяти объекты, поддерживает большее количество типов объектов, добавлены некоторые оптимизации.\n- 5 - версия протокола, появившаяся в Python 3.8. Он добавляет поддержку данных out-of-band и ускорение для in-band данных. PEP 574 более подробно описывает изменения.\n\n## Тестирование\n\n### Пирамида тестирования\n\n![Рис. Пирамида тестирования](attachments/eb2d6637.png)\n\n### Что такое mocking\n\n- [Модуль Mock: макеты-пустышки в тестировании](https://habr.com/ru/post/141209/)\n\nMock на английском значит «имитация», «подделка». Принцип его работы простой: если нужно тестировать функцию, то всё, что не относится к ней самой (например, чтение с диска или из сети), можно подменить макетами-пустышками. При этом тестируемые функции не нужно адаптировать для тестов: Mock подменяет объекты в других модулях, даже если код не принимает их в виде параметров. То есть, тестировать можно вообще без адаптации под тесты.\n\n### Что делать, если тестируемая функция использует удалённое подключение к внешним сервисам, которое иногда видает ошибку таймаута, 404 и им подобные\n\nЕсли мы говорим про юнит тесты, то они не должны вызывать внешние ресурсы, то есть делать http запросы и тд. Следовательно нужно либо замокать http-клиент, который использует функция для вызова сервиса, либо, что обычно является лучшим решением, передавать то что вызывает этот сервис в функцию зависимостью (если конечно мы не тестируем сам клиент для вызова сервиса).\n\n### Что делать, если тестируемая функция занимает много времени на выполнение повторяющихся операций внутри неё\n\nНапример, внутри цикл от 1 до 1000000, где что-то считывается, записывается, рассчитывается.\n\nДопустим у этой функции не проблем с декомпозицией - это функция, которая выполняет одно действие и разбивать ее на несколько других не имеет никакого смысла. В таком случае я бы:\n\n- сделал бы возможным заменить из теста верхнюю границу цикла (через параметр или мокая константу, настройку и т.д.)\n- если функция вызывает для расчетов другую ресурсоёмкую функцию, стороннюю или из своей кодовой базы, то возможно замокал бы ее и проверил что она вызывается с нужными параметрами\n- по возможности подготовил бы для теста такой входящий набор данных, при котором она выполялась быстро\n\nЕсли функция не соответсвует условиям, описанным в первом предложении, следовало бы сначала заняться ее декомпозицией.\n\n### Какие вы знаете виды тестов\n  \n- [Пирамида тестов на практике](https://habr.com/ru/post/358950/)\n- [Тесты, которые должен писать разработчик](https://medium.com/front-end-in-regions-grodno/%D1%82%D0%B5%D1%81%D1%82%D1%8B-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD-%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D1%8C-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA-a04cab35f45b)\n- [Различные виды тестирования и их особенности](https://techrocks.ru/2018/12/08/different-types-of-testing/)\n\n#### Unit-тесты\n  \n*Что проверяется?*\nМодульные тесты проверяют, правильно ли работает каждый отдельный модуль (юнит) вашего кода. В идеале при планировании и написании модульных тестов нужно изолировать функционал, который нельзя разделить на более мелкие составляющие, и протестировать его.\n  \n  Модульные тесты не должны проверять внешние зависимости или взаимодействия. Вам определенно нужно сымитировать (mock out) api-вызовы. Борцы за чистоту модульных тестов будут также настаивать на имитации вызовов базы данных, чтобы убедиться, что ваш код, получая корректный input из внешних источников, ведет себя правильно. Модульные тесты должны быть быстрыми, иначе они значительно замедляют разработку.\n  \n*Когда их запускать?*\nВы должны писать и запускать модульные тесты параллельно со своим кодом.\n\n#### Интеграционные тесты (Integration tests)\n  \nЭтот термин употребляют чаще к тестам, покрывающим непосредственно публичный API сервиса. Фокус устремлен на проверку взаимодействия разных систем по принципу “сервис-клиент”.\n\n*Что проверяется?*\nИнтеграционные тесты проверяют взаимодействие между двумя (или больше, чем двумя) отдельными юнитами вашего кода.\n  \n  Ваше приложение состоит из отдельных модулей, выполняющих определенные маленькие функции. Каждый из них может хорошо работать в изолированном состоянии, но ломаться в связке с другими.\n  \n  Интеграционные тесты также проверяют интеграцию вашего кода с внешними зависимостями, вроде соединений с базой данных или сторонними API.\n  \n*Когда их запускать?*\nИнтеграционные тесты это следующий шаг после модульных тестов.\n  \n*Что, если тесты провалены?*\nПровал интеграционных тестов означает, что две (или больше) функции вашего приложения не работают вместе. Это могут быть два написанных вами модуля, которые приходят в противоречие из-за какой-то сложной бизнес-логики. Также провал может случиться из-за того, что изменилась структура ответа стороннего API. Провал тестов может быть предупреждением о плохой обработке ошибок в случае сбоя подключения к базе данных.\n  \n#### Функциональное тестирование\n\n- Функциональное тестирование может быть определено как тестирование отдельных функций модулей.\n- Это относится к тестированию программного продукта на индивидуальном уровне, чтобы проверить его функциональность.\n- Оно сильно отличается от модульного или интеграционного тестирования; вы не можете написать бесчисленное множество тест-кейсов для функционального тестирования, поскольку оно является более сложным, чем модульное.\n- Инструменты функционального тестирования стремятся проверить функциональные возможности (работоспособность) программного обеспечения. Тестовые примеры используются для проверки ожидаемых и неожиданных результатов тестирования программного обеспечения.\n- Этот тип тестирования проводится больше с точки зрения пользователя. То есть, он рассматривает ожидание пользователя в выбранном типе ввода данных.\n- Selenium является одним из наиболее распространенных инструментов, используемых для функционального тестирования.\n\n#### Системный тест (System test, Service test)\n  \n  Автоматизированные тесты, проверяющие работу всей интегрированной системы. По сути, они представляют собой предельный случай интеграционных тестов. Системные тесты не проверяют бизнес-правила напрямую. Вместо этого они проверяют, что компоненты системы правильно связаны друг с другом, а взаимодействие между ними проходит по исходному плану. Тесты производительности и пропускной способности обычно относятся к этой категории.\n\nСистемное — это тестирование программы в целом. Для небольших проектов это, как правило, ручное тестирование — запустил, пощелкал, убедился, что (не) работает. Можно автоматизировать. К автоматизации есть два подхода.\n\nЭти тесты пишутся системными архитекторами и ведущими специалистами с технической стороны. Как правило, они пишутся на том же языке и в той же среде, что и интеграционные тесты пользовательского интерфейса. Системные тесты выполняются относительно редко (в зависимости от продолжительности их выполнения), но чем чаще – тем лучше.\n\nСистемные тесты покрывают 10 % системы. Это объясняется тем, что они предназначены для проверки правильности не поведения системы, а ее конструкции. Правильность поведения нижележащего кода и компонентов уже была проверена на нижних уровнях пирамиды.\n\n#### Проверка работоспособности (Smoke test, Sanity check)\n  \n  Это частный случай интеграционного теста. Обычно это очень небольшие тесты, которые прогоняются перед запуском системы, чтобы убедиться в работоспособности стороннего ПО, которое необходимо для корректного функционирования нашей системы. В случае провала таких тестов, мы можем оповестить пользователя о проблеме или и вовсе остановить запуск системы.\n  \n  Дымовое тестирование - пришло из сферы проверки оборудования, если, после подачи питания, появляется дым и запах гари, то оборудование неисправно.\n  \nТакже дымовыми тестами можно сопровождать рефакторинг legacy кода, потому что написание полноценных юниттестов может быть сильно затратно по времени.\n\n#### Регрессионное тестирование (Regression testing)\n  \n  Это может быть любой вид теста из описанных выше, который пишется после того, как была обнаружена проблема. Тест должен эмулировать в точности шаги для воспроизведения проблемы. Наличие такого теста после исправления проблемы дает гарантию, что точно такой же баг, больше не появится в системе.\n  \n*Что проверяется?*\nРегрессионные тесты проверяют набор сценариев, которые раньше работали и должны быть относительно стабильными.\n\n#### Прочее\n\n- Приемочное тестирование\n- Проверка на уязвимости (Penetration test, Pentest)\n- Нагрузочное тестирование (Load testing)\n- Тестирование производительности (Performance testing)\n- Фаззинг тест (Fuzzing test, Fuzztest, Random test)\n  \n### Чем интеграционное тестирование отличается от функционального\n\n- [Сравнение интеграционного и функционального тестирования](http://juice-health.ru/program/software-testing/497-integration-and-functional-testing)\n\nИнтеграционное и функциональное тестирования - это две фазы в процессе тестирования программного обеспечения. Первое проводится после модульного тестирования, а второе - метод тестирования черного ящика.\n\n*Функциональное тестирование также упоминается как тестирование Е2Е для тестирования браузера.*\n\n![Рис. Интеграционное тестирование против функционального тестирования](attachments/aed78f00.png)\n\n## Функциональное программирование\n\n### Что такое функциональное программирование\n\n- [Функциональное программирование в примерах](https://medium.com/@kiky.tokamuro/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85-be5ebe4a6053)\n\nФункциональное программирование – раздел дискретной математики и парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании).\nПротивопоставляется парадигме императивного программирования, которая описывает процесс вычислений как последовательное изменение состояний (в значении, подобном таковому в теории автоматов)\n\n### Как у Python с поддержкой функционального программирования\n\nPython частично поддерживает парадигму функционального программирования и позволяет писать код в функциональном стиле. Кроме того, в нём присутствуют определённые возможности, характерные для функциональных языков или впервые появившиеся в функциональных языках (списковые включения, лямбда-функции, функции высшего порядка и т.д.).\n\n### Что такое объект первого класса\n\nОбъектами первого класса (англ. first-class object, first-class entity, first-class citizen) в контексте конкретного языка программирования называются сущности, которые могут быть переданы как параметр, возвращены из функции, присвоены переменной.\n\nОбъект называют «объектом первого класса», если он:\n\n- может быть сохранен в переменной или структурах данных;\n- может быть передан в функцию как аргумент;\n- может быть возвращен из функции как результат;\n- может быть создан во время выполнения программы;\n- внутренне самоидентифицируем (независим от именования).\n\nТермин «объект» используется здесь в общем смысле, и не ограничивается объектами языка программирования.\nВ Python, как и в функциональных языках, функции являются объектами первого класса.\n\n### Что такое функция высшего порядка\n\nФункция высшего порядка – функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата. Основная идея состоит в том, что функции имеют тот же статус, что и другие объекты данных.\n\n### Что такое каррирование\n\n*Карринг* — это преобразование функции от многих аргументов в набор функций, каждая из которых является функцией от одного аргумента. Мы можем передать часть аргументов в функцию и получить обратно функцию, ожидающую остальные аргументы. Это преобразование было введено М. Шейнфинкелем и Г. Фреге и получило свое название в честь Х. Карри.\n\nСоздадим простую функцию greet, которая принимает в качестве аргументов приветствие и имя:\n\n```python\ndef greet(greeting, name):\n    print(greeting + ', ' + name)\n\ngreet('Hello', 'German')\n```\n\nНебольшое улучшение позволит нам создать новую функцию для любого типа приветствия и передать этой новой функции имя:\n\n```python\ndef greet_curried(greeting):\n    def greet(name):\n        print(greeting + ', ' + name)\n    return greet\n\ngreet_hello = greet_curried('Hello')\n\ngreet_hello('German')\ngreet_hello('Ivan')\n```\n\nИли напрямую `greet_curried`\n\n```python\ngreet_curried('Hi')('Roma')\n\nА дальше можно сделать это с любым количеством аргументов:\n\ndef greet_deeply_curried(greeting):\n    def w_separator(separator):\n        def w_emphasis(emphasis):\n            def w_name(name):\n                print(greeting + separator + name + emphasis)\n            return w_name\n        return w_emphasis\n    return w_separator\n\ngreet = greet_deeply_curried(\"Hello\")(\"...\")(\".\")\ngreet('German')\ngreet('Ivan')\n```\n\n### Опишите функции map, reduce, filter модуля functools\n\nФункция `map` применяет функцию к каждому элементу последовательности. В Python 2 возвращает список, в Python 3 – объект-итератор.\n\nФункция `filter` оставляет лишь те элементы последовательности, для которых заданная функция истинна. В Python 2 возвращает список, в Python 3 – объект-итератор.\n\nФункция `reduce` (в Python 2 встроенная, в Python 3 находится в модуле functools) принимает функцию от двух аргументов, последовательность и опциональное начальное значение и вычисляет свёртку (fold) последовательности как результат последовательного применения данной функции к текущему значению (так называемому аккумулятору) и следующему элементу последовательности.\n\n### Какие еще вы знаете функции из модуля functools\n\nМодуль functools содержит большое количество стандартных функций высшего порядка. Среди них особенно полезны:\n\n- lru_cache – декоратор, который кеширует значения функций, которые не меняют свой результат при неизменных аргументах; полезен для кеширования данных, мемоизации (сохранения результатов для возврата без вычисления функции) значений рекурсивных функций (например, такого типа, как функция вычисления n-го числа Фибоначчи) и т.д.;\n- partial – частичное применение функции (вызов функции с меньшим количеством аргументов, чем она ожидает, и получение функции, которая принимает оставшиеся параметры).\n\n### Какие вы функции знаете из модуля itertools\n\nМодуль itertools содержит функции для работы с итераторами и создания итераторов.\nНекоторые из его функций:\n\n- `product` – декартово произведение итераторов (для избегания вложенных циклов for);\n- `permutations` – генерация перестановок;\n- `combinations` – генерация сочетаний;\n- `combinations_with_replacement` – генерация размещений;\n- `chain` – соединение нескольких итераторов в один;\n- `takewhile` – получение значений последовательности, пока значение функции-предиката для её элементов истинно;\n- `dropwhile` – получение значений последовательности начиная с элемента, для которого значение функции-предиката перестанет быть истинно.\n\n### Для чего нужен модуль operator\n\nМодуль operator содержит функции, которые соответствуют стандартным операторам. Таким образом, вместо lambda x, y: x + y можно использовать уже готовую функцию operator.add и т.д.\n\n## GIL, потоки, процессы\n\n### Что такое GIL. Какие у него есть проблемы\n\n- [GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock)\n- [Как устроен GIL в Python](https://habr.com/ru/post/84629/)\n\nВ любой момент может выполняться только один поток Python. Глобальная блокировка интерпретатора — GIL — тщательно контролирует выполнение тредов. GIL гарантирует каждому потоку эксклюзивный доступ к переменным интерпретатора (и соответствующие вызовы C-расширений работают правильно).\n\nПринцип работы прост. Потоки удерживают GIL, пока выполняются. Однако они освобождают его при блокировании для операций ввода-вывода. Каждый раз, когда поток вынужден ждать, другие, готовые к выполнению, потоки используют свой шанс запуститься.\n\nКогда поток начинает работу, он выполняет захват GIL. Спустя какое-то время планировщик процессов решает, что текущий поток поработал достаточно, и передает управление следующему потоку. Поток №2 видит, что GIL захвачен, так что он не продолжает работу, а погружает себя в сон, уступая процессор потоку №1.\n\nНо поток не может удерживать GIL бесконечно. До Python 3.3 GIL переключался каждые 100 инструкций машинного кода. В поздних версиях GIL может быть удержан потоком не дольше 5 мс. GIL так-же освобождается, если поток совершает системный вызов, работает с диском или сетью.\n\nПроблема в том, что из-за GIL далеко не все задачи могут быть решены в тредах. Напротив, их использование чаще всего снижает быстродействие программы (при CPU-bound задачах). С использованием тредов требуется следить за доступом к общим ресурсам: словарям, файлам, соединением к БД.\n\n- GIL упрощает интеграцию non thread safe библиотек на С. Благодаря GIL у нас так много быстрых модулей и биндингов почти ко всему.\n- Библиотекам на C доступен механизм управления GIL. Так например NumPy отпускает его на долгих операциях.\n\nПо сути, GIL в питоне делает бесполезной идею применять потоки для параллелизма в вычислительных задачах. Они будут работать последовательно даже на многопроцессорной системе. На CPU Bound задачах программа не ускорится, а только замедлится, так как теперь потокам придется делить пополам процессорное время. При этом I/O операции GIL не замедлит, так как перед системным вызовом поток отпускает GIL.\n\n### Работали ли Вы с asyncio. В чём его особенность\n\n- [Асинхронное программирование в Python](https://webstudio-uwk.ru/asinhronnoe-programmirovanie-v-python/)\n\nПредставим, что мы пишем HTTP или WebSocket сервер, который каждое подключение обрабатывает в отдельном потоке.\n\nЗдесь вполне можно создать 100, может даже 500 потоков, чтобы обработать нужное количество одновременных соединений. Для коротких запросов это даже будет работать и позволит выдержать нагрузку в 5000 RPS на самом дешевом инстансе в DO за пять баксов — вполне неплохо. Если у вас меньше, возможно здесь и не нужны никакие AsyncIO/Tornado/Twisted.\n\nНо что, если их количество стремится к бесконечности? Скажем, это большой чат с кучей каналов, где количество одновременных участников не ограничено. В такой ситуации создать столько потоков, чтобы хватило каждому пользователю я бы уже не рискнул. И вот почему:\n\nКак говорилось выше, пока GIL захвачен одним потоком, другие работать не будут. Планировщик операционной системы, при этом, о GIL ничего не знает и все равно будет отдавать процессор заблокированный потокам. Такой поток, конечно, увидит что GIL захвачен и сразу же уснет, но на переключение контекста процессора будет тратиться драгоценное время.\n\nПереключение контекста — вообще дорогая для процессора операция, которая требует сброса регистров, кэша и таблицы отображения страниц памяти. Чем больше потоков запущено, тем больше процессор совершает холостых переключений на потоки, заблокированные GIL, прежде чем дойдет до того самого, который этот GIL удерживает. Не очень-то эффективно.\n\nЕсть старые добрые сопрограммы — то, что сейчас предлагает AsyncIO и Tornado. Их еще называют корутинами или просто потоками на уровне пользователя. Модная нынче штука, но, далеко не новая, а использовалась еще во времена, когда в ходу были ОС без поддержки многозадачности.\n\nВ отличи от потоков, сопрограммы выполняют только полезную работу, а переключение между ними происходит только в тот момент, когда сопрограмма ожидает завершения какой-то внешней операции.\n\nКак и в случае с тредами, асинхронщина бесполезна для вычислений. Тут ситуация даже хуже, так как зависший на вычислениях поток рано или поздно GIL отпустит, а вот блокирующий код в сопрограмме заблокирует весь поток, до тех пор, пока не исполнится весь. В отличии от нативных тредов, у сопрограмм отсутствует прерывание по таймеру. Передача управления следующей сопрограмме происходит вручную, при явном вызове конструкции await (или yield, если используются generator-based корутины). Поэтому важно следить, чтобы в асинхронных программах не было блокирующего кода и использовались только асинхронные вызовы, а все вычисления происходили в отдельных процессах.\n\nПотоки будут проще, если у вас типичное веб-приложение, которое не зависит от внешних сервисов, и относительно конечное количество клиентов, для которых время ответа будет предсказуемо-коротким.\n\nAsyncIO подойдет, если приложение большую часть времени тратит на чтение/запись данных, а не их обработку. Например, у вас много медленных запросов — вебсокеты, long polling или есть медленные внешние синхронные бекенды, запросы к которым неизвестно когда завершатся.\n\n### Что такое async/await, для чего они нужны и как их использовать\n\nКлючевое слово `async` идет до `def`, чтобы показать, что метод является асинхронным. Ключевое слово `await` показывает, что вы ожидаете завершения сопрограммы.\n\n```python\nimport asyncio\nimport aiohttp\n\nurls = ['http://www.google.com', 'http://www.yandex.ru', 'http://www.python.org']\n\nasync def call_url(url):\n    async with aiohttp.ClientSession() as session:\n        print('Starting {}'.format(url))\n        async with session.get(url) as response:\n            data = await response.text()\n            print('{}: {} bytes: {}'.format(url, len(data), data))\n            return data\n\nfutures = [call_url(url) for url in urls]\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(asyncio.gather(*futures))\n```\n\nПрограмма состоит из метода async. Во время выполнения он возвращает сопрограмму, которая затем находится в ожидании.\n\n`async/await` нужен для того, чтобы не блокировать поток выполнения на время ожидания какого-нибудь асинхронного события. Конструкция `async/await` превращает по сути процедуру в корутину (сопрограмму): она прекращает своё выполнение на время `await`, дожидается асинхронного события, и возобновляет работу.\n\nВ не-async-варианте ожидание получается блокирующим, или нужно вручную делать трюки: запускать операцию и подписываться на её окончание. Async делает код более простым, линейным.\n\n### Как в питоне реализуется многопоточность. Какими модулями\n\nМногопоточность достигается модулем Threading. Это нативные Posix-треды. Такие треды исполняются операционной системой, а не виртуальной машиной.\n\n### В чем отличие тредов от мультипроцессинга\n\nГлавное отличие в разделении памяти. Процессы независимы друг от друга, имеют раздельные адресные пространства, идентификаторы, ресурсы. Треды исполняются в совместном адресном порстранстве, имеют общий доступ к памяти, переменным, загруженным модулям.\n\n### Какие задачи хорошо параллелятся, какие плохо\n\nХорошо параллелятся задачи, которые порождают долгий IO. Когда тред упирается в ожидание сокета или диска, интерпретатор бросает этот тред и стартует следующий. Это значит, не будет простоя из-за ожидания. Наоборот, если ходить в сеть в одном треде (в цикле), то каждый раз придется ждать ответа.\n\nОднако, если затем в треде обрабатывает полученные данные, то выполнятся будет только он один. Это не только не даст прироста в скорости, но и замедлит программу из-за переключения на другие треды.\n\nКороткий ответ: хорошо ложатся на треды задачи по работе с сетью. Например, выкачать сто урлов. Полученные данные обрабатывайте вне тредов.\n\n### Нужно посчитать 100 уравнений. Делать это в тредах или нет\n\nНет, потому что в этой задаче нет ввода-вывода. Интерпретатор только будет тратить лишнее время на переключение тредов. Сложные математические задачи лучше выносить в отдельные процессы, либо использовать фреймворк для распределенных задач Celery, либо подключать как C-библиотеки.\n\n### Треды в Питоне — это нативные треды или нет\n\nДа, это нативные Posix-совместимые треды, которые исполняются на уровне операционной системы.\n\n### Что такое гринлеты. Общее понятие. Примеры реализаций\n\nGreenlet == Green thread == Зеленые треды == легковесные треды внутри виртуальной машины. Могут называться корутинами, сопроцессами, акторами и т.д. в зависимости от платформы. Операционная система не видит их. С точки зрения ОС запущен один процесс виртуальной машины, а что внутри нее – неизвестно. Такими тредами управляет сама вируальная машина: порождает, исполняет, согласует доступ к ресурсам.\n\nПримеры: корутины в языках Go и Lua, легковесные процессы в Erlang, модуль greenlet для Python. Модуль gevent использует гринлеты\n\n## Какие варианты реализации шаблона Singleton на питоне\n\n- [Creating a singleton in Python](https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python)\n\n**Декоратор:**\n\n```python\ndef singleton(class_):\n    instances = {}\n    def getinstance(*args, **kwargs):\n        if class_ not in instances:\n            instances[class_] = class_(*args, **kwargs)\n        return instances[class_]\n    return getinstance\n\n@singleton\nclass MyClass(BaseClass):\n    pass\n```\n\n*Достоиства:*\n\n- Декораторы зачастую более интуитивны, чем множественное наследование.\n\n*Недостатки:*\n\n- Хотя объекты, созданные с использованием `MyClass()`, будут настоящими singleton объектами, сам `MyClass` является функцией, а не классом, поэтому вы не можете вызывать методы класса из него.\n- Увеличивает сложность тестирования\n\n**Base class:**\n\n```python\nclass Singleton(object):\n    _instance = None\n    def __new__(class_, *args, **kwargs):\n        if not isinstance(class_._instance, class_):\n            class_._instance = object.__new__(class_, *args, **kwargs)\n        return class_._instance\n\nclass MyClass(Singleton, BaseClass):\n    pass\n```\n\n*Достоиства:*\n\n- Это настоящий класс.\n\n*Недостатки:*\n\n- Множественное наследование усложняет код. `__new__` может быть перезаписан во время наследования от второго базового класса?\n\n**Метаклассы:**\n\n```python\nclass Singleton(type):\n    _instances = {}\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instances[cls]\n\n#Python2\nclass MyClass(BaseClass):\n    __metaclass__ = Singleton\n\n#Python3\nclass MyClass(BaseClass, metaclass=Singleton):\n    pass\n```\n\n*Достоиства:*\n  \n- Это настоящий класс\n- Автомагически покрывает наследование\n- Используем метаклассы по их прямому назначению\n  \n*Недостатки:*\n\n- А они есть?\n\n**Модуль:**\n\n*Достоиства:*\n  \n- Простота\n  \n*Недостатки:*\n\n- Не инициализируется лениво\n\n## Какие вы знаете инструменты для проверки кодстайл\n\n- [Инструменты для анализа кода Python. Часть 1](https://proglib.io/p/python-code-analysis/)\n- [Инструменты для анализа кода Python. Часть 2](https://proglib.io/p/python-code-analysis-tools/)\n\n**Pycodestyle** — простая консольная утилита для анализа кода Python, а именно для проверки кода на соответствие PEP8. Один из старейших анализаторов кода, до 2016 года носил название pep8, но был переименован по просьбе создателя языка Python Гвидо ван Россума.\n\n**Pydocstyle** проверяет наличие docstring у модулей, классов, функций и их соответствие официальному соглашению PEP257.\n\n**Pylint** совместил в себе как поиск логических так и стилистических ошибок. Этот мощный, гибко настраиваемый инструмент для анализа кода Python отличается большим количеством проверок и разнообразием отчетов.\n\n**Vulture** — небольшая утилита для поиска “мертвого” кода в программах Python. Она использует модуль ast стандартной библиотеки и создает абстрактные синтаксические деревья для всех файлов исходного кода в проекте. Далее осуществляется поиск всех объектов, которые были определены, но не используются. Vulture полезно применять для очистки и нахождения ошибок в больших базовых кодах.\n\n**Flake8** — обвязка к входящим в нее утилитам — pyflakes, pycodestyle, mccabe. Flake8 имеет схожий с pylint основной функционал. Однако она имеет ряд отличий и особенностей:\n\n- Возможности статистических отчетов ограничены подсчетом количества каждой из ошибок (—statistics) и их общим количеством (—count).\n- Для запуска в несколько потоков (`—jobs=<num>`) используется модуль multiprocessing, по этой причине многопоточность не будет работать на Windows системах.\n- Отсутствует возможность генерации отчетов в формате json, при вызове с ключом —bug-report создается только заголовок для отчета с указанием платформы и версий входящих утилит.\n- Комментарии в коде блокирующие вывод. Добавление в строку с ошибкой комментария # noqa, уберет ее из отчета.\n- Во время редактирования для подавления отдельных ошибок “на лету” можно перечислить исключаемые ошибки в ключе `—extend-ignore=<errors>`\n- Проверка синтаксиса в строках doctest (—doctests).\n- Наличие Version Control Hooks. Интеграция с системами контроля версий происходит буквально с помощью двух команд (поддерживаются git и mercurial).\n- Расширяемость. Flake8 для анализа кода Python позволяет создавать и использовать плагины. С помощью плагинов в Flake8 можно: добавить дополнительные проверки, использовать другие форматы отчетов или автоматически исправлять найденные ошибки. На PyPi можно найти большое количество open-source плагинов.\n\n**Prospector** — это инструмент для анализа кода Python. Объединяет функциональность других инструментов анализа Python, таких как pylint, pep8, mccabe, Pyflakes, Dodgy, pydocstyle (экспериментально, возможны ошибки). Дополнительно можно подключить mypy, pyroma, vulture. Главной особенностью prospector является наличие предустановленных профилей, которые содержат настройки входящих в него утилит, призванных подавить наиболее придирчивые предупреждения и оставить только важные сообщения.\n\n**Pylama** — инструмент аудита кода для Python и JavaScript. Служит оберткой на такими утилитами как: pydocstyle, pycodestyle, pyflakes, mccabe, pylint, radon (инструмент для сбора и вычисления различных метрик из исходного кода). Для работы с работы с JavaScript кодом используется gjslint.\n\n**autopep8** модифицирует код, не совместимый с PEP8. Проверка соответствия соглашениям осуществляется с помощью утилиты pycodestyle. В autopep8 есть поддержка многопоточности, рекурсивного обхода каталогов, возможность сохранения настроек в файле, задание диапазона строк для исправления, фильтрация ошибок и непосредственное изменение проверяемого файла.\n\n**yapf** похож на autopep8, но использует другой подход, который основан на «clang-format», разработанном Дэниелом Джаспером. Отформатированный yapf код, будет не только соблюдать принятые соглашения, но и выглядеть так, словно был написан хорошим программистом. Вторым важным отличием является возможность задавать стили. Для этого воспользуйтесь ключом —style и в качестве аргумента передайте файл с настройками или одно из предопределенных значений (pep8, google, chromium, facebook).\n\n**black** — это бескомпромиссный форматировщик, который работает быстро и экономит время и умственную энергию программистов для более важных вопросов.\n\n## Что такое list/dict comprehension\n\nВыражение заключенное в квадратные/фигурные скобки, в котором используются ключевые слова `for` и `in` для построения списка/словаря путем обработки и фильтрации элементов из одного или нескольких итерируемых объектов. Списковое включение работает энергично.\n\n*Энергичный* - итерируемый объект, который сразу строит все свои элементы. В Python включения - энергичные операции. Противоположность - *ленивый*.\n\n## Какая разница между одинарным и двойным подчеркиванием\n\n- [Understanding the underscore of Python](https://hackernoon.com/understanding-the-underscore-of-python-309d1a029edc)\n\nЕсть 5 кейсов использования подчеркивая в Python:\n\n1. Для хранения значения последнего выражения в REPL\n2. Игнорирования значения\n3. Для опеределения специального значения функции или переменной\n    - одинарное в начале или конце названия\n    - двойное в начале\n    - двойное в начале и конце\n4. Для использования в качестве функции локализации\n5. Для разделения символов числа (`1_00 == 100`)\n\n## Отличие copy() от deepcopy()\n\n- [Deep vs Shallow Copies in Python](https://stackabuse.com/deep-vs-shallow-copies-in-python/)\n\nГлубокая копия `deepcopy()` создает новую и отдельную копию всего объекта или списка со своим уникальным адресом памяти. Это означает, что любые изменения, внесенные вами в новую копию объекта или списка, не будут отражаться в исходной. Этот процесс происходит следующим образом: сначала создается новый список или объект, а затем рекурсивно копируются все элементы из исходного в новый.\n\nПоверхностное копирование `copy()` также создает отдельный новый объект или список, но вместо копирования дочерних элементов в новый объект оно просто копирует ссылки на их адреса памяти. Следовательно, если вы сделаете изменение в исходном объекте, оно будет отражено в скопированном объекте, и наоборот. Короче говоря, обе копии зависят друг от друга.\n\n## Что такое garbage collector. В чём его плюсы и минусы\n\n- [Всё, что нужно знать о сборщике мусора в Python](https://habr.com/ru/post/417215/)\n- [CPython Garbage Collection: The Internal Mechanics and Algorithms](https://blog.codingconfessions.com/p/cpython-garbage-collection-internals)\n\nGC (generational garbage collector) - это сборщик мусора, создавался он в первую очередь для обнаружения и удаления циклических ссылок.\n`gc` является встроенным в python модулем и при необходимости его можно выключить и запускать вручную (или не запускать). Чтобы понимать для чего был создан GC нужно понимать как в Python работает менеджер памяти и как эта память высвобождается.\n\nВ отличие от других популярных языков, Python не освобождает всю память обратно операционной системе как только он удаляет какой либо объект. Вместо этого, он использует дополнительный менеджер памяти, предназначенный для маленьких объектов (размер которых меньше чем 512 байт). Для работы с такими объектами он выделяет большие блоки памяти, в которых в дальнейшем будет хранится множество маленьких объектов.\n\nКак только один из маленьких объектов удаляется — память из под него не переходит операционной системе, Python оставляет её для новых объектов с таким же размером. Если в одном из выделенных блоков памяти не осталось объектов, то Python может высвободить его операционной системе. Как правило, высвобождение блоков случается когда скрипт создает множество временных объектов.\n\nТаким образом, если долгоживущий Python процесс с течением времени начинает потреблять больше памяти, то это совсем не означает, что в вашем коде есть проблема с утечкой памяти.\n\nСтандартный интерпретатор питона (CPython) использует сразу два алгоритма сборки мусора, подсчет ссылок и generational garbage collector (далее GC), более известный как стандартный модуль gc из Python.\n\nАлгоритм подсчета ссылок очень простой и эффективный, но у него есть один большой недостаток. Он не умеет определять циклические ссылки. Именно из-за этого, в питоне существует дополнительный сборщик, именуемый поколенческий GC, который следит за объектами с потенциальными циклическими ссылками.\n\nВ Python, алгоритм подсчета ссылок является фундаментальным и не может быть отключен, тогда как GC опционален и может быть отключен.\n\nВ отличие от алгоритма подсчета ссылок, циклический GC не работает в режиме реального времени и запускается периодически. Каждый запуск сборщика создаёт микропаузы в работе кода, поэтому CPython (стандартный интерпретатор) использует различные эвристики, для определения частоты запуска сборщика мусора.\n\nЦиклический сборщик мусора разделяет все объекты на 3 поколения (генерации). Новые объекты попадают в первое поколение. Если новый объект выживает после процесса сборки мусора, то он перемещается в следующее поколение. Чем выше поколение, тем реже оно сканируется на мусор. Так-как новые объекты зачастую имеют очень маленький срок жизни (являются временными), то имеет смысл опрашивать их чаще, чем те, которые уже прошли через несколько этапов сборки мусора.\n\nВ каждой генерации есть специальный счетчик и порог срабатывания, при достижении которых срабатывает процесс сборки мусора. Каждый счетчик хранит количество аллокаций минус количество деаллокаций в данной генерации. Как только в Python создается какой либо контейнерный объект, он проверяет эти счетчики. Если условия срабатывают, то начинается процесс сборки мусора.\n\nЕсли сразу несколько или больше поколений преодолели порог, то выбирается наиболее старшее поколение. Это сделано из-за того, что старые поколения также сканируют все предыдущие. Чтобы сократить число пауз сборки мусора для долгоживущих объектов, самая старшая генерация имеет дополнительный набор условий.\n\nСтандартные пороги срабатывания для поколений установлены на 700, 10 и 10 соответственно, но вы всегда можете их изменить с помощью функций gc.get_threshold и gc.set_threshold.\n\n## Что такое интроспекция\n\n- [Introspection in Python](http://zetcode.com/lang/python/introspection/)\n\n*Интроспекция* — это способность программы исследовать тип или свойства объекта во время работы программы. Вы можете поинтересоваться, каков тип объекта, является ли он экземпляром класса. Некоторые языки даже позволяют узнать иерархию наследования объекта. Возможность интроспекции есть в таких языках, как Ruby, Java, PHP, Python, C++ и других. В целом, инстроспекция — это очень простое и очень мощное явление. Вот несколько примеров использования инстроспекции:\n\n```java\n// Java\n\nif(obj instanceof Person){\n   Person p = (Person)obj;\n   p.walk();\n}\n```\n\n```php\n//PHP\n\nif ($obj instanceof Person) {\n   // делаем что угодно\n}\n```\n\nВ Python самой распространённой формой интроспекции является использование метода dir для вывода списка атрибутов объекта:\n\n```python\n# Python\n\nclass foo(object):\n  def __init__(self, val):\n    self.x = val\n  def bar(self):\n    return self.x\n\n...\n\ndir(foo(5))\n=> ['__class__', '__delattr__', '__dict__', '__doc__', '__getattribute__', '__hash__', '__init__', '__module__',\n'__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__str__', '__weakref__', 'bar', 'x']\n```\n\n## Что такое рефлексия\n\nИнтроспекция позволяет вам изучать атрибуты объекта во время выполнения программы, а рефлексия — манипулировать ими. *Рефлексия* — это способность компьютерной программы изучать и модифицировать свою структуру и поведение (значения, мета-данные, свойства и функции) во время выполнения. Простым языком: она позволяет вам вызывать методы объектов, создавать новые объекты, модифицировать их, даже не зная имён интерфейсов, полей, методов во время компиляции. Из-за такой природы рефлексии её труднее реализовать в статически типизированных языках, поскольку ошибки типизации возникают во время компиляции, а не исполнения программы (подробнее об этом здесь). Тем не менее, она возможна, ведь такие языки, как Java, C# и другие допускают использование как интроспекции, так и рефлексии (но не C++, он позволяет использовать лишь интроспекцию).\n\nПо той же причине рефлексию проще реализовать в интерпретируемых языках, поскольку когда функции, объекты и другие структуры данных создаются и вызываются во время работы программы, используется какая-то система распределения памяти. Интерпретируемые языки обычно предоставляют такую систему по умолчанию, а для компилируемых понадобится дополнительный компилятор и интерпретатор, который следит за корректностью рефлексии.\n\n*Пример*:\n\n```python\n# Без рефлексии\nFoo().hello()\n\n# С рефлексией\ngetattr(globals()['Foo'](), 'hello')()\n```\n\n# Django\n\n## Что такое Middleware, для чего, как реализуется\n\nMiddleware – особый объект, который обычно изменяет входящий запрос или исходящий ответ. Например, добавляет заголовки, делает предварительные проверки. Middleware нужен, когда требуется подвергнуть обработке все запросы приложения.\n\nНа уровне языка это объект с методами `process_request` и `process_response`. Методы должны вернуть принятый объект (запрос или ответ) для дальнейшей обработки или выкинуть исключение, если что-то не в порядке. В этом случает дальнейшая обработка прекращается.\n\nЧтобы включить Middleware, достаточно добавить путь к нему в список `MIDDLEWARE`.\n\n## Назовите основные мидлвари. Зачем они нужны\n\n- `SessionMiddleware` – поддержка сессий. Добавляет в запрос объект `session`\n- `CsrfViewMiddleware` – проверяет, что POST-запросы отправлены с текущего домена\n- `AuthenticationMiddleware` – авторизует пользователя. Добавляет в запрос поле `user`\n- `MessageMiddleware` – передает пользователю короткие сообщения\n\n## Опишите алгоритм работы CSRF middleware\n\nНа каждый запрос система генерирует уникальный токен и выставляет его в куках. В каждой форме размещается скрытое поле `csrf-token` с этим же токеном. При отправке формы методом `POST` Джанго проверяет, что поле формы и значение в куках совпадают. Если нет, это значит, что запрос подделан или отправлен с другого домена.\n\nЧтобы освободить какую-то вьюху от проверки (если это API, например), достаточно обернуть ее декоратором `csrf_except`.\n\nПромежуточный слой CSRF и шаблонный тег предоставляют легкую-в-использовании защиту против Межсайтовой подделки запроса. Этот тип атак случается, когда злонамеренный Web сайт содержит ссылку, кнопку формы или некоторый javascript, который предназначен для выполнения некоторых действий на вашем Web сайте, используя учетные данные авторизованного пользователя, который посещал злонамеренный сайт в своем браузере. Сюда также входит связанный тип атак, ‘login CSRF’, где атакуемый сайт обманывает браузер пользователя, авторизируясь на сайте с чужими учетными данными.\n\nПервая защита против CSRF атак - это гарантирование того, что GET запросы (и другие ‘безопасные’ методы, определенные в 9.1.1 Safe Methods, HTTP 1.1, [RFC 2616#section-9.1.1](https://tools.ietf.org/html/rfc2616.html#section-9.1.1)) свободны от побочных эффектов. Запросы через ‘небезопасные’ методы, такие как POST, PUT и DELETE могут быть защищены при помощи шагов, описанных ниже.\n\n*Как это работает:*\n\nCSRF базируется на следующих вещах:\n\n1. CSRF кука, которая устанавливается как случайное число (сессия независимого случайного слова, как это еще иногда называют), к которой другие сайты не будут иметь доступа. Эта кука устанавливается при помощи CsrfViewMiddleware. Она должно быть постоянной, но так как нет способа установить куки, у которых никогда не истекает время жизни, то она отправляется с каждым ответом, который вызывал django.middleware.csrf.get_token() (функция использовалась внутри для получения CSRF токена).\n\n2. Все POST формы содержат скрытое поле ‘csrfmiddlewaretoken’. Значение поля равно CSRF куке. Эта часть выполняет шаблонным тегом.\n3. Все HTTP запросы, которые не GET, HEAD, OPTIONS или TRACE, должны содержать CSRF куку, и поле ‘csrfmiddlewaretoken’ с правильным значением. Иначе пользователь получит 403 ошибку. Эта проверка выполняется в CsrfViewMiddleware.\n4. В дополнение для HTTPS запросов в CsrfViewMiddleware проверяется “referer”(источник запроса). Это необходимо для предотвращения MITM-атаки(Man-In-The-Middle), которая возможна при использовании HTTPS и токена не привязанного к сессии, т.к. клиенты принимают(к сожалению) HTTP заголовок ‘Set-Cookie’, несмотря на то, что коммуникация с сервером происходит через HTTPS. (Такая проверка не выполняется для HTTP запросов т.к. “Referer” заголовок легко подменить при использовании HTTP.) Если указана настройка CSRF_COOKIE_DOMAIN, значение “referer” будет сравниваться с этим значением. Значение поддерживает под-домены. Например, CSRF_COOKIE_DOMAIN = '.example.com' позволить отправлять POST запросы с www.example.com и api.example.com. Если настройка не указана, “referer” должен быть равен HTTP заголовку Host. Чтобы расширить список доступных доменов, кроме текущего хоста и домена кук, используйте CSRF_TRUSTED_ORIGINS.\n\nТакой подход гарантирует, что только формы, отправленные с доверенных доменов, могут передавать POST данные.\n\nGET игнорируются сознательно (и все другие запросы, которые считаются “безопасными” в соответствии с RFC 2616). Эти запросы никогда не должны выполнять каких-либо потенциально опасные действия, и CSRF атаки через GET запрос должен быть безвредным. RFC 2616 определяет POST, PUT и DELETE как “небезопасные”.\n\n## Что такое сигналы? Зачем нужны? Назовите основные\n\nСигналы – это события в экосистеме Джанго. С помощью сигналов подсистемы оповещают приложение о том, что случилось. Чтобы читать сигналы, программист регистрирет обработчики сигналов. Сигналы распространяются синхронно. Это значит, подписав на один сигнал сотню обработчиков, мы увеличим время, необходимое на отдачу ответа.\n\nОсновные сигналы это начало запроса и его окончание, перед сохранением модели и после, обращение к базе данных.\n\n**Важно:** сигналы моделей работают поштучно, то есть для одной модели. При пакетной обработке, например, `queryset.all().delete()` или `queryset.all().update({'foo'=42})`, события об удалении или изменения не будут вызваны.\n\n## Как реализуется связь m2m на уровне базы данных\n\nЕсли есть модели A и B со связью многие ко многим, то создается таблица-мост с именем `a_to_b`, которая хранит ключ на A, ключ на B и дополнительные сведения, например, время, когда была создана связь. Эта таблица сцепляется с A и B оператором `JOIN`.\n\n## Чем лучше отправлять форму — GET или POST\n\nФорму можно отправлять обоими способами. В первом случае переменные прикрепляются к строке запроса после вопросительного знака. Во втором – передаются в теле запроса.\n\nТехническое ограничение метода GET в том, что им нельзя передать файл, в отличие от POST.\n\nФорму желательно передавать методом POST по следующим причинам:\n\n- GET-запросы могут быть кешированы, особенно в браузерах семейства IE\n- GET-запросы оседают в логах провайдера, сервера, истории браузера. Пароль и логин в таком случае может засветиться во многих местах\n- некоторые вирусы отслеживают содержимое адресной строки и пересылают третьим лицам.\n\n## Как работает Serializer в Django REST Framework\n\nSerializer преобразует информацию, хранящуюся в базе данных и определенную с помощью моделей Django, в формат, который легко и эффективно передается через API.\n\nМодели Django интуитивно представляют данные, хранящиеся в базе, но API должен передавать информацию в менее сложной структуре. Хотя данные будут представлены как экземпляры классов Model, их необходимо перевести в формат JSON для передачи через API.\n\nСериализатор DRF производит это преобразование. Когда пользователь передает информацию (например, создание нового экземпляра) через API, сериализатор берет данные, проверяет их и преобразует в нечто, что Django может сложить в экземпляр модели. Аналогичным образом, когда пользователь обращается к информации через API, соответствующие экземпляры передаются в сериализатор, который преобразовывает их в формат, который может быть легко передан пользователю как JSON.\n\nНаиболее распространенной формой, которую принимает сериализатор DRF, является тот, который привязан непосредственно к модели Django:\n\n```python\nclass ThingSerializer(serializers.ModelSerializer):\n  class Meta:\n    model = Thing\n    fields = (‘name’, )\n```\n\nНастройки fields позволяют точно указать, какие поля доступны этому сериализатору. В качестве альтернативы, может быть установлен exclude вместо fields, которое будет включать все поля модели, кроме тех, которые указаны в exclude.\n\nСериализаторы — это невероятно гибкий и мощный компонент DRF. Хотя подключение сериализатора к модели является наиболее распространенным, сериализаторы могут использоваться для создания любой структуры данных Python через API в соответствии с определенными параметрами.\n\n## Что такое Meta в классах Django и для чего нужен\n\nDjango во многом работает через метаклассы.\n\nЕсли коротко, то метаклассы - это классы, которые конструируют другие классы. Объявляются они через атрибут класса `__metaclass__` (в джанге через слой совместимости с python 3 через модуль six до версии 2).\n\nПоэтому когда Django конструирует ваш класс, она делает это с помощью своего метакласса. Чтобы при конструировании ей знать какие-то параметры вашего класса, ну, например модель или поля в вашем случае, она ищет в вашем классе класс с названием Meta.\n\nВообще вся эта магия с метаклассами очень важна в джанге и поэтому лучше саму логику становления класса не переопределять.\n\nЕсли взять за пример Serializer, то можно посмотреть на код джанги:\n\n```python\n@six.add_metaclass(SerializerMetaclass)\nclass Serializer(BaseSerializer):\n  ...\n```\n\nSerializerMetaclass - это тот самый метакласс, который конструирует класс ModelForm.\n\n## За что отвечает Meta в сериализаторе\n\nВ классе Meta сериализатора можно задать модель по которой будет создан сериализатор, поля, которые будут включены (или exclude для исключения), `list_serializer_class`, например для того чтобы задать специфическую валидацию списков и тд.\n\n## Какая разница в быстродействии между django и Flask (и почему)\n\nНасчет быстродействия затрудняюсь ответить, потому что это довольно каверзный вопрос, тестов лично я не проводил. Но, что касается отличий этих двух фреймворков:\n\n- Flask предоставляет простоту, гибкость и аккуратность в работе, позволяя пользователю самому выбирать, как реализовать те или иные вещи.\n- Django предоставляет пакет «все включено»: у вас есть панель админа, интерфейсы баз данных, ORM, и структура каталогов для ваших приложений и проектов.\n\nПод каждую задачу нужно брать свой инструмент, Django хорошо подойдет для новостных сайтов, блогов и тд, благодаря тому что у него уже из коробки есть многое (в том числе админка), да и создавался он именно под такой тип сайтов. Flask же из коробки напротив, практически ничего не имеет и лучше подойдет для каких-либо микросервисов или приложений для которых стек технологий с которыми поставляется Django не подходит.\n\n## Как в django работает система аутентификации\n\nDjango поставляется с системой аутентификации пользователей. Она обеспечивает пользовательские аккаунты, группы, права и сессии на основе куки.\n\nСистема аутентификации Django отвечает за оба аспекта: аутентификацию и авторизацию. Если коротко, то аутентификация проверяет пользователя, а авторизация определяет, что аутентифицированный пользователь может делать. Далее термин “аутентификация” будет использоваться для обозначения обоих аспектов ([User authentication in Django](https://docs.djangoproject.com/en/2.2/topics/auth/)).\n\nСистема аутентификации состоит из:\n\n- Пользователей\n- Прав: Бинарные (да/нет) флаги, определяющие наличие у пользователя права выполнять определённые действия.\n- Групп: Общий способ назначения меток и прав на множество пользователей.\n- Настраиваемой системы хеширования паролей\n- Инструментов для форм и представлений для аутентификации пользователей или для ограничения доступа к контенту\n- Системы плагинов\n\nАутентификационная система Django старается быть очень простой и не предоставляет некоторые фичи, распространённые в других системах веб аутентификации. Такие фичи реализованы в сторонних пакетах:\n\n- Проверка сложности пароля\n- Ограничение попыток входа\n- Аутентификация через сторонние сервисы (OAuth, например)\n\n# Веб-разработка\n\n## Что такое CGI. Плюсы, минусы\n\nCommon Gateway Interface. Соглашение о том, как веб-сервер взаимодействует с программой, написанной на каком-то языке. Веб-сервер запускает программу как исполняемый файл. Параметры запроса, например, метод, путь, заголовки и т.д. передаются через переменные окружения.\n\nПрограмма должна прочитать эти переменные и записать в стандартный поток вывода HTTP-ответ.\n\nПлюсы:\n\n- Протокол не накладывает условия на язык, на котором написана программа. Это     может быть и скрипт, и бинарный файл.\n- Протокол экстремально прост.\n- Программа не хранит состояние, что удобно для отладки.\n\nМинусы:\n\n- Запуск процесса ОС на каждый запрос отрабатывает очень медленно.\n- Передача данных через `stdout` медленней юникс-сокетов.\n\n## Как защитить куки от воровства и от подделки\n\nЗависит от того, насколько строгие критерии безопасности на сайте. Если в куках хранятся вспомогательные данные, например, индекс последнего выбранного в дропдауне элемента, правилами ниже можно пренебречь.\n\nДля платежных систем, сайтов с приватными данными приведенные правила обязательны.\n\n- Выставлять кукам флаг `httponly`. Браузер не даст прочесть и изменить такие куки на клиенте Джаваскриптом.\n- Использовать флаг `secure`. Куки будут переданы только по безопасному соединению.\n- Устанавливать короткий срок жизни куки.\n- Устанавливать короткий срок сессии на сервере.\n- Добавлять в ключ сессии заголовок `User-Agent`. Тогда если украсть куки и установить на другой машине, ключ сессии будет другим.\n- Аналогично пункту выше, но добавлять `IP` пользователя.\n- Подписывать куки секретным ключом. Добавлять поле `sig`, которое равно `HMAC-SHA1(cookie-body, secret_key)`. На сервере проверять, что подпись совпадает.\n\n## Какая разница между аутентификацией и авторизацией\n\n**Идентификация** (от латинского identifico — отождествлять): присвоение субъектам и объектам идентификатора и / или сравнение идентификатора с перечнем присвоенных идентификаторов. Например, представление человека по имени отчеству - это идентификация.\n\n**Аутентификация** (от греческого: αυθεντικός ; реальный или подлинный): проверка соответствия субъекта и того, за кого он пытается себя выдать, с помощью некой уникальной информации (отпечатки пальцев, цвет радужки, голос и тд.), в простейшем случае - с помощью имени входа и пароля.\n\n**Авторизация** - это проверка и определение полномочий на выполнение некоторых действий (например, чтение файла /var/mail/eltsin) в соответствии с ранее выполненной аутентификацией.\n\nВсе три процедуры взаимосвязаны:\n\n1. Сначала определяют имя (логин или номер) – идентификация\n2. Затем проверяют пароль (ключ или отпечаток пальца) – аутентификация\n3. И в конце предоставляют доступ – авторизация\n\n## Что такое XSS. Примеры. Как защитить приложение\n\nXSS – межсайтовые запросы. Страница, подверженная уязвимости, вынуждает пользователя выполнить запрос к другой странице, либо запустить нежелательный js-код.\n\nНапример, пользователь отправил комментарий, в котором был код:\n\n```html\n<script>alert('foo');</script>\n```\n\nДвижок сайта не фильтрует текст комментария, поэтому тег `<script>` становится частью страницы и исполняется браузером. Каждый, кто зайдет на страницу с опасным комментарием, увидит всплывающее окно с тестом `foo`.\n\nДругой пример. Страница поиска принимает поисковой терм `q`. В заголовке фраза “Результат поиска по запросу” + текст параметра. Если не экранировать параметр, то запрос `/search?q=<script>alert('foo');</script>` приведет к аналогичному результату.\n\nЗная, что страница выполняет js-код, хакер может подгрузить на страницу контекстную рекламу, баннеры, заставить браузей перейти на любую страницу, похитить куки.\n\nУязвимость устраняется экранированием небезопасных символов, чисткой (санацией) HTML-тегов.\n\n## REST & SOAP\n\n### Что такое REST\n\n- [REST Principles and Architectural Constraints](https://restfulapi.net/rest-architectural-constraints/)\n\nREST (Representational state transfer «передача состояния представления») – соглашение о том, как выстраивать сервисы. Под REST часто имеют в виду т.н HTTP REST API. Как правило, это веб-приложение с набором урлов – конечных точек. Урлы принимают и возвращают данные в формате JSON. Тип операции задают методом HTTP-запроса, например:\n\n- `GET` – получить объект или список объектов\n- `POST` – создать объект\n- `PUT` – обновить существующий объект\n- `PATCH` – частично обновить существующий объект\n- `DELETE` – удалить объект\n- `HEAD` – получить метаданные объекта\n\nREST-архитектура активно использует возможности протокола HTTP, чтобы избежать т.н. “велосипедов” – собственных решений. Например, параметры кеширования передаются стандартными заголовками `Cache`, `If-Modified-Since`, `ETag`. Авторизациция – заголовком `Authentication`.\n\nREST это архитектурный стиль для проектирования слабо связанных HTTP приложений, что часто используется при разработке веб-сервисов. REST не диктует правил как это должно быть имплементировано на low уровне, он лишь дает высокоуровненые гайдлайны и оставляет тебе свободу для того чтобы воплотить собственную реализацию.\n\nДля веб-служб, построенных с учётом REST (то есть не нарушающих накладываемых им ограничений), применяют термин «RESTful».\n\nВ отличие от веб-сервисов (веб-служб) на основе SOAP, не существует «официального» стандарта для RESTful веб-API. Дело в том, что REST является архитектурным стилем, в то время как SOAP является протоколом.\n\nREST определяет 6 архитектурных ограничений, соблюдение которых позволит создать настоящий RESTful API:\n\n1. Единообразие интерфейса\n2. Клиент-сервер\n3. Отсутствие состояния\n4. Кэширование\n5. Слои\n6. Код по требованию (необязательное ограничение)\n\n**Единообразие интерфейса**\nВы должны придумать API интерфейс для ресурсов системы, доступный для пользователей системы и следовать ему во что бы то ни стало. Ресурс в системе должен иметь только один логичный URI, который должен обеспечивать способ получения связанных или дополнительных данных. Всегда лучше ассоциировать (синонимизировать) ресурс с веб страницей.\n\nЛюбой ресурс не должен быть слишком большим и содержать все и вся в своем представлении. Когда это уместно, ресурс должен содержать ссылки (HATEOAS: Hypermedia as the Engine of Application State), указывающие на относительные URI для получения связанной информации.\n\nКроме того, представления ресурсов в системе должны следовать определенным рекомендациям, таким как соглашения об именах, форматы ссылок или формат данных (xml или / и json).\n\n>Как только разработчик ознакомится с одним из ваших API, он сможет следовать аналогичному подходу для других API.\n\n**Клиент-сервер**\nПо сути, это означает, что клиентское приложение и серверное приложение ДОЛЖНЫ иметь возможность развиваться по отдельности без какой-либо зависимости друг от друга. Клиент должен знать только URI ресурса и больше ничего. Сегодня это нормальная практика в веб-разработке, поэтому с вашей стороны ничего особенного не требуется. Будь проще.\n\n>Серверы и клиенты также могут заменяться и разрабатываться независимо, если интерфейс между ними не изменяется.\n\n**Отсутствие состояния**\nРой Филдинг черпал вдохновение из HTTP, и это отражается в этом ограничении. Сделайте все клиент-серверное взаимодействие без состояний. Сервер не будет хранить информацию о последних  HTTP-запросах клиента. Он будет рассматривать каждый запрос как новый. Нет сессии, нет истории.\n\nЕсли клиентское приложение должно быть приложением с отслеживанием состояния для конечного пользователя, когда пользователь входит в систему один раз и после этого выполняет другие авторизованные операции, то каждый запрос от клиента должен содержать всю информацию, необходимую для обслуживания запроса, включая сведения об аутентификации и авторизации.\n\n>Клиентский контекст не должен храниться на сервере между запросами. Клиент отвечает за управление состоянием приложения.\n\n**Кэширование**\nВ современном мире кэширование данных и ответов имеет первостепенное значение везде, где это применимо/возможно. Кэширование повышает производительность на стороне клиента и расширяет возможности масштабирования для сервера, поскольку нагрузка уменьшается.\n\nВ REST кэширование должно применяться к ресурсам, когда это применимо, и тогда эти ресурсы ДОЛЖНЫ быть объявлены кешируемыми. Кэширование может быть реализовано на стороне сервера или клиента.\n\n>Хорошо настроенное кэширование частично или полностью исключает некоторые взаимодействия клиент-сервер, что еще больше повышает масштабируемость и производительность.\n\n**Слои**\nREST позволяет вам использовать многоуровневую архитектуру системы, в которой вы развертываете API-интерфейсы на сервере A, храните данные на сервере B, a запросы аутентифицируете, например, на сервере C. Клиент обычно не может сказать, подключен ли он напрямую к конечному серверу или к посреднику.\n\n**Код по требованию (необязательное ограничение)**\nЭто опциональное ограничение. Большую часть времени вы будете отправлять статические представления ресурсов в форме XML или JSON. Но когда вам нужно, вы можете вернуть исполняемый код для поддержки части вашего приложения, например, клиенты могут вызывать ваш API для получения кода визуализации виджета интерфейса пользователя. Это разрешено\n\nВсе вышеперечисленные ограничения помогают вам создать действительно RESTful API, и вы должны следовать им. Тем не менее, иногда вы можете столкнуться с нарушением одного или двух ограничений. Не беспокойтесь, вы все еще создаете API RESTful, но не «труЪ RESTful».\n\n### Что такое SOAP\n\nSOAP (от англ. Simple Object Access Protocol - простой протокол доступа к объектам; вплоть до спецификации 1.2) - протокол обмена структурированными сообщениями в распределённой вычислительной среде. Первоначально SOAP предназначался в основном для реализации удалённого вызова процедур (RPC). Сейчас протокол используется для обмена произвольными сообщениями в формате XML, а не только для вызова процедур. Официальная спецификация последней версии 1.2 протокола никак не расшифровывает название SOAP. SOAP является расширением протокола XML-RPC.\nSOAP может использоваться с любым протоколом прикладного уровня: SMTP, FTP, HTTP, HTTPS и др. Однако его взаимодействие с каждым из этих протоколов имеет свои особенности, которые должны быть определены отдельно. Чаще всего SOAP используется поверх HTTP.\n\n### В чем разница между REST и SOAP веб сервисами\n\nНекоторые отличия:\n\n- REST поддерживает различные форматы: text, JSON, XML; SOAP - только XML,\n- REST работает только по HTTP(S), а SOAP может работать с различными протоколами,\n- REST может работать с ресурсами. Каждый URL это представление какого-либо ресурса. SOAP работает с операциями, которые реализуют какую-либо бизнес логику с помощью нескольких интерфейсов,\n- SOAP на основе чтения не может быть помещена в кэш, а REST в этом случае может быть закэширован,\n- SOAP поддерживает SSL и WS-security, в то время как REST - только SSL, SOAP поддерживает ACID (Atomicity, Consistency, Isolation, Durability). REST поддерживает транзакции, но не один из ACID не совместим с двух фазовым коммитом.\n\n### Можем ли мы посылать SOAP сообщения с вложением\n\nДа, это возможно. Можно посылать вложением различные форматы: PDF, изображения или другие двоичные данные. Сообщения SOAP работают вместе с расширением MIME, в котором предусмотрено multipart/related\n\n### Как бы вы решили какой из REST или SOAP веб сервисов использовать\n\nREST против SOAP можно перефразировать как \"Простота против Стандарта\". В случае REST (простота) у вас будет скорость, расширяемость и поддержка многих форматов. В случае с SOAP у вас будет больше возможностей по безопасности (WS-security) и транзакционная безопасность (ACID).\n\n## Какие способы для мониторинга веб-приложений в production вы использовали или знаете\n\n- [51 инструмент для APM и мониторинга серверов](https://habr.com/ru/company/pc-administrator/blog/304356/)\n\n# HTTP\n\n## Как устроен протокол HTTP\n\nHTTP – текстовый протокол, работающий поверх TCP/IP. HTTP состоит из запроса и ответа. Их структуры похожи: стартовая строка, заголовки, тело ответа.\n\nСтартовая строка запроса состоит из метода, пути и версии протокола:\n\n```plaintext\nGET /index.html HTTP/1.1\n```\n\nСтартовая строка ответа состоит из версии протокола, кода ответа и текстовой расшифровке ответа.\n\n```plaintext\nHTTP/1.1 200 OK\n```\n\nЗаголовки – это набор пар ключ-значение, например, `User-Agent`, `Content-Type`. В заголовках передают метаданные запроса: язык пользователя, авторизацию, перенаправление. Заголовок `Host` должен быть в запросе всегда.\n\nТело ответа может быть пустым, либо может передавать пары переменных, файлы, бинарные данные. Тело отделяется от заголовков пустой строкой.\n\n## Написать raw запрос главной Яндекса\n\n```plaintext\nGET / HTTP/1.1\nHost: ya.ru\n```\n\n## Как клиенту понять, удался запрос или нет\n\nПроверить статус ответа. Ответы разделены старшему разряду. Имеем пять групп со следующей семантикой:\n\n- `1xx`: используется крайне редко. В этой группе только один статус `100 Continue`.\n- `2xx`: запрос прошел успешно (данные получены или созданы)\n- `3xx`: перенаправление на другой ресурс\n- `4xx`: ошибка по вине пользователя (нет такой страницы, нет прав на доступ)\n- `5xx`: ошибка по вине сервера (ошибка в коде, сети, конфигурации)\n\n## Что нужно отправить браузеру, чтобы перенаправить на другую страницу\n\nМинимальный ответ должен иметь статус `301` или `302`. Заголовок `Location` указывает адрес ресурса, на который следует перейти.\n\nВ теле ответа можно разместить `HTML` со ссылкой на новый ресурс. Тогда пользователи старых браузеров смогут перейти вручную.\n\n## Как управлять кешированием в HTTP\n\nСуществуют несколько способов кешировать данные на уровне протокола.\n\n- Заголовки `Cache` и `Cache-Control` регулируют сразу несколько критериев кеша: время жизни, политику обновления, поведение прокси-сервера, тип данных (публичные, приватные).\n- Заголовки `Last-Modified` и `If-Modified-Since` задают кеширование в зависимости от даты обновления документа.\n- Заголовок `Etag` кеширует документ по его уникальному хешу.\n\n## Как кэшируются файлы на уровне протокола\n\nКогда `Nginx` отдает статичный файл, он добавляет заголовок `Etag` – `MD5`-хеш файла. Клиент запоминает этот хеш. В следующий раз при запросе файла клиент посылает хеш. Сервер проверяет хеш клиента для этого файла. Если хеш не совпадает (файл обновили), сервер отвечает с кодом `200` и выгружает актуальный файл с новым хешем. Если хеши равны, сервер отвечает с кодом `304 Not Modified` с пустым телом. В этом случае браузер подставляет локальную копию файла.\n\n## Что такое HTTP\n\n- [Простым языком об HTTP](https://habr.com/ru/post/215117/)\n- [Обзор протокола HTTP - HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP/Overview)\n\nHTTP — широко распространённый протокол передачи данных, изначально предназначенный для передачи гипертекстовых документов (то есть документов, которые могут содержать ссылки, позволяющие организовать переход к другим документам).\n\nАббревиатура HTTP расшифровывается как HyperText Transfer Protocol, «протокол передачи гипертекста». В соответствии со спецификацией OSI, HTTP является протоколом прикладного (верхнего, 7-го) уровня. Актуальная на данный момент версия протокола, HTTP 1.1, описана в спецификации RFC 2616.\n\nПротокол HTTP предполагает использование клиент-серверной структуры передачи данных. Клиентское приложение формирует запрос и отправляет его на сервер, после чего серверное программное обеспечение обрабатывает данный запрос, формирует ответ и передаёт его обратно клиенту. После этого клиентское приложение может продолжить отправлять другие запросы, которые будут обработаны аналогичным образом.\n\nЗадача, которая традиционно решается с помощью протокола HTTP — обмен данными между пользовательским приложением, осуществляющим доступ к веб-ресурсам (обычно это веб-браузер) и веб-сервером. На данный момент именно благодаря протоколу HTTP обеспечивается работа Всемирной паутины.\n\nТакже HTTP часто используется как протокол передачи информации для других протоколов прикладного уровня, таких как SOAP, XML-RPC и WebDAV. В таком случае говорят, что протокол HTTP используется как «транспорт».\n\n## Чем отличаются HTTP и HTTPS\n\nHTTP — прикладной протокол передачи данный, используемый для получения информации с веб-сайтов.\n\nHTTPS — расширение протокола HTTP, поддерживающее шифрование по протоколам SSL и TLS.\n\n# Общее\n\n## ООП\n\n### Инкапсуляция\n\n*Инкапсуляция* - механизм языка, позволяющий объединить данные и методы, работающие с этими данными, в единый объект и скрыть детали реализации от пользователя.\n\nПодлинное назначение инкапсуляции — собрать в одном месте знания, относящиеся к устройству некой сущности, правилам обращения и операциям с ней. Инкапсуляция появилась гораздо раньше, чем принято думать. Модули в программах на C — это инкапсуляция. Подпрограммы на ассемблере — это инкапсуляция. Противоположность инкапсуляции — размазывание знаний о функционировании чего-либо по всей программе.\n\n*Пример*: работа с денежными величинами. Не секрет, что во многих e-commerce системах денежные величины реализованы в виде чисел с плавающей запятой. Думаю, все из нас в курсе, что при простом сложении двух «целых» чисел, представленных в виде переменных с плавающих запятой, может образоваться «немного не целое число». Поэтому при такой реализации там и тут приходится вставлять вызов функции округления. Это и есть размазывание знаний об устройстве сущности по всей программе. Инкапсуляция в данном случае — собрать (спрятать) в одном месте знание о том, что деньги представлены в виде величины с плавающей запятой, и что её постоянно приходится округлять при самых невинных операциях. Спрятать так, чтобы при использовании сущности «деньги» речь об округлении даже не заходила. При инкапсуляции не будет никаких проблем заменить реализацию «денег» с числа с плавающей на число с фиксированной запятой.\n\nМожно сказать, что сокрытие – это одна из задач инкапсуляции. Но само по себе сокрытие данных инкапсуляцией не является. Также сказать, что инкапсуляция – это сокрытие данных, тоже было бы неверно. Потому что её задачи выходят за рамки сокрытия.\n\nЕсли мы говорим, что данный метод инкапсулирует некий алгоритм, то подразумеваем, что в данном методе происходит определённое вычисление, детали которого нам знать необязательно, но результатам которого мы можем доверять и пользоваться ими. Также мы можем сказать, что объект, в котором инкапсулированы данные, может скрывать их – то есть защищать от несанкционированного доступа. Таким образом, разграничивать понятие инкапсуляции и сокрытия данных всё-таки нужно и важно видеть грань между ними. Инкапсуляция – технология объединения собственно данных и методов их обработки. В результате и сами данные, и алгоритмы работы с ними становятся логически неотделимы. Типичный пример из C++ – поля и методы класса.\n\nИтак, если инкапсуляция обеспечивает своего рода целостность объекта, то сокрытие - скрывает детали о процессе. Для \"настройки\" доступа к данным в классе и к классу непосредственно используются так называемые модификаторы доступа. Так вот использование этих модификаторов доступа и есть сокрытие.\n\n### Наследование\n\n*Наследование* - механизм языка, который позволяет описывать новый класс на основе существующего. В \"истинном\" ООП нужно для обеспечения реализации полиморфизма, как самостоятельная единица, не нужно и даже вредно, потому что является причиной сильного связывания. Наследованию лучше предпочитать композицию.\n\n### Полиморфизм\n\n*Полиморфизм* имеет несколько форм:\n\n- Специальный (Ad-Hoc) (в некоторых языках представлен механизмом перегрузки методов)\n- Параметрический (в некоторых языках представлен дженериками)\n- Полиморфизм подтипов (достигается с помощью механизмов наследования и апкаста). Когда говорят о полиморфизме чаще всего имеют в виду его\n\n*Полиморфизм* - возможность схожим типам данных, которые явно заданы иерархией наследования иметь различные реализации (с помощью переопределения методов и апкаста)\n\nТакже в языках программирования и теории типов полиморфизмом называется способность функции обрабатывать данные разных типов.\n\n### Абстракция\n\n*Абстракция* гласит что мы должны выделять важные характеристики объекта. Мысль в том, чтобы мы могли определить минимально необходимый набор этих характеристик для того чтобы можно было решить поставленную задачу.\nЧасто путают с инкапсуляцией, потому что и то и другое косвенно влияет на формирование публичного интерфейса типа.\nДовольно тривиальная парадигма и поэтому часто не указывается как таковая.\n\n## Какие принципы программирования вы знаете\n\n- [10 Coding principles and acronyms demystified!](https://areknawo.com/10-coding-principles-and-acronyms-demystified/)\n\n### KISS\n\nПринцип *Keep It Stupid Simple* («Придерживайся простоты») велит вам следить за тем, чтобы код оставался как можно более простым. Чем код проще, тем легче в нем разобраться, как вам, так и другим людям, занимающимся его поддержкой. Под простотой главным образом имеется в виду отказ от использования хитроумных приемов и ненужного усложнения.\n\nВ качестве примеров нарушения этого принципа можно назвать написание отдельной функции только лишь для осуществления операции сложения или использование побитового оператора (right shift >> 1) для деления целых чисел на 2. Последнее, безусловно, более эффективно, чем обычное (/2), но при этом очень сильно снижается понятность кода. Применяя такой подход, вы осуществляете clever coding («заумный кодинг») и over-optimization (чрезмерную оптимизацию). И то, и другое в долгосрочной перспективе не слишком хорошо сказывается на здоровье вашего кода.\n\n### DRY\n\nПринцип *Don’t Repeat Yourself* («Не повторяйся») напоминает нам, что каждое повторяемое поведение в коде следует обособлять (например, выделять в отдельную функцию) для возможности многократного использования. Когда у вас в кодовой базе есть два совершенно одинаковых фрагмента кода, это не хорошо. Это часто приводит к рассинхронизации и прочим багам, не говоря уже о том, что от этого увеличивается размер программы.\n\n### YAGNI\n\nПринцип *You Aren’t Gonna Need It* («Тебе это не понадобится») говорит о том, что нежелательно оставлять в продакшене «точки расширения» (места, предназначенные только для того, чтобы позволить вам в будущем легко добавить новый функционал). Конечно, мы не говорим о случаях, когда речь идет об уже заказанном функционале. Такие точки расширения вносят ненужную сложность и увеличивают размер вашей кодовой базы.\n\n### SLAP\n\nПринцип *Single Level of Abstraction Principle* («Принцип единого уровня абстракций») означает, что функции должны иметь единый уровень абстракции. Скажем, функция, читающая input, не должна также обрабатывать полученные данные. Для этого она должна задействовать отдельную функцию, находящуюся на другом, более низком уровне абстракции. Чем более общей является функция и чем больше других функций она использует, тем выше она располагается в абстракционной иерархии.\n\n### SOLID принципы\n\n*SOLID* - это аббревиатура от 5 принципов, описанных Робертом Мартином, которые способствуют созданию хорошего объектно-ориентированного (и не только) кода.\n\n**S**: Single Responsibility Principle (Принцип единственной ответственности).\n>Каждый класс должен решать лишь одну задачу.\n\n**O**: Open-Closed Principle (Принцип открытости-закрытости).\n>Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.\n\n**L**: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).\n>Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.\n\n**I**: Interface Segregation Principle (Принцип разделения интерфейса).\n>Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют.\n\n**D**: Dependency Inversion Principle (Принцип инверсии зависимостей).\n>Объектом зависимости должна быть абстракция, а не что-то конкретное.\n\n- Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.\n- Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.\n\n## Что такое code cohesion & code coupling\n\n**Связанность модулей (coupling)**, часто называемую **зацеплением**, характеризует степень независимости модулей. При проектировании систем необходимо стремиться, чтобы модули имели минимальную зависимость друг от друга, т.е. были минимально «сцеплены» между собой (отсюда и термин «сцепление» или связанность). Это требование вытекает из одного из основных принципов системного подхода, требующего минимизации информационных потоков между подсистемами.\n\n**Связность (cohesion)** характеризует целостность, «плотность» модуля, т.е. насколько модуль является простым с точки зрения его использования. В идеале модуль должен выполнять одну единственную функцию и иметь минимальное число «ручек управления». Примером модуля имеющего максимальную связность является модуль проверки орфографии, вычисления заработной платы сотрудника, вычисления логарифма функции. Если связанность является характеристикой системы, то связность характеризует отдельно взятый модуль.\n\n## Какие шаблоны проектирования вы знаете\n\n- \"Марк Саммерфилд - Python на практике\"\n- [GitHub - pkolt/design_patterns: Паттерны проектирования](https://github.com/pkolt/design_patterns)\n- [GitHub - faif/python-patterns: A collection of design patterns/idioms in Python](https://github.com/faif/python-patterns)\n- [Python Design Patterns](https://python-patterns.guide/)\n- [Design Patterns in Python: A Series](https://medium.com/@amirm.lavasani/design-patterns-in-python-a-series-f502b7804ae5)\n- [A Catalog For Design Patterns in Python](https://towardsdev.com/a-catalog-for-design-patterns-in-python-a1b69493c677)\n\n### Порождающие (Creational)\n\nПорождающие паттерны проектирования описывают, как создавать объекты. Обычно объект создается путем вызова констуктора, но иногда требуется большая гибкость именно для этого порождающие паттерны и полезны.\n\n#### Абстрактная фабрика (Abstract factory)\n\nПредназначен для случаев, когда требуется создать сложный объект, состоящий из других объектов, причем все составляющие объекты принадлежат одному \"семейству\". Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов.\n\nНапример, в системе с GUI может быть абстрактная фабрика виджетов, которой наследуют три конкретных фабрики: MacWidgetFactory, XfceWidgetFactory, WindowsWidgetFactory, каждая из которых предоставляет методы для создания одних и тех же объектов (make_button(), make_spinbox() и т.д), стилизованных, однако, как принято на конкретной платформе. Это дает возможность создать обобщенную функцию create_dialog(), которая принимает экземпляр фабрики в качестве аргумента и создает диалоговое окно, выглядещее как в OS X, Xfce или Windows - в зависимости от того какую фабрику мы передали.\n\nКлассы абстрактной фабрики часто реализуются фабричными методами, но могут быть реализованы и с помощью паттерна прототип.\n\n```python\n\"\"\"\n*What is this pattern about?\nIn Java and other languages, the Abstract Factory Pattern serves to provide an interface for\ncreating related/dependent objects without need to specify their\nactual class.\nThe idea is to abstract the creation of objects depending on business\nlogic, platform choice, etc.\nIn Python, the interface we use is simply a callable, which is \"builtin\" interface\nin Python, and in normal circumstances we can simply use the class itself as\nthat callable, because classes are first class objects in Python.\n*What does this example do?\nThis particular implementation abstracts the creation of a pet and\ndoes so depending on the factory we chose (Dog or Cat, or random_animal)\nThis works because both Dog/Cat and random_animal respect a common\ninterface (callable for creation and .speak()).\nNow my application can create pets abstractly and decide later,\nbased on my own criteria, dogs over cats.\n*Where is the pattern used practically?\n*References:\nhttps://sourcemaking.com/design_patterns/abstract_factory\nhttp://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/\n*TL;DR\nProvides a way to encapsulate a group of individual factories.\n\"\"\"\n\nimport random\n\n\nclass PetShop:\n\n    \"\"\"A pet shop\"\"\"\n\n    def __init__(self, animal_factory=None):\n        \"\"\"pet_factory is our abstract factory.  We can set it at will.\"\"\"\n\n        self.pet_factory = animal_factory\n\n    def show_pet(self):\n        \"\"\"Creates and shows a pet using the abstract factory\"\"\"\n\n        pet = self.pet_factory()\n        print(\"We have a lovely {}\".format(pet))\n        print(\"It says {}\".format(pet.speak()))\n\n\nclass Dog:\n    def speak(self):\n        return \"woof\"\n\n    def __str__(self):\n        return \"Dog\"\n\n\nclass Cat:\n    def speak(self):\n        return \"meow\"\n\n    def __str__(self):\n        return \"Cat\"\n\n\n# Additional factories:\n\n# Create a random animal\ndef random_animal():\n    \"\"\"Let's be dynamic!\"\"\"\n    return random.choice([Dog, Cat])()\n\n\n# Show pets with various factories\nif __name__ == \"__main__\":\n\n    # A Shop that sells only cats\n    cat_shop = PetShop(Cat)\n    cat_shop.show_pet()\n    print(\"\")\n\n    # A shop that sells random animals\n    shop = PetShop(random_animal)\n    for i in range(3):\n        shop.show_pet()\n        print(\"=\" * 20)\n\n# OUTPUT #\n# We have a lovely Cat\n# It says meow\n#\n# We have a lovely Dog\n# It says woof\n# ====================\n# We have a lovely Cat\n# It says meow\n# ====================\n# We have a lovely Cat\n# It says meow\n# ====================\n```\n\n#### Построитель (Builder)\n\nПостроитель аналогичен паттерну Абстрактная фабрика в том смысле, что оба предназначены для создания сложных объектов, составленных из других объектов. Но отличается тем, что не только предоставляет методы для построения сложного объекта, но и хранит внутри себя его полное представление.\n\nЭтот паттерн допускает такую же композиционную структуру как и Абстрактная фабрика (то есть сложные объекты, составленные из нескольких более простых) но особенно удобен в ситуациях, когда представление составного объета должно быть отделено от алгоритмов композиции\n\nОтделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления. От абстрактной фабрики отличается тем, что делает акцент на пошаговом конструировании объекта. Строитель возвращает объект на последнем шаге, тогда как абстрактная фабрика возвращает объект немедленно. Строитель часто используется для создания паттерна компоновщик.\n\n```python\n\"\"\"\n*What is this pattern about?\nIt decouples the creation of a complex object and its representation,\nso that the same process can be reused to build objects from the same\nfamily.\nThis is useful when you must separate the specification of an object\nfrom its actual representation (generally for abstraction).\n*What does this example do?\nThe first example achieves this by using an abstract base\nclass for a building, where the initializer (__init__ method) specifies the\nsteps needed, and the concrete subclasses implement these steps.\nIn other programming languages, a more complex arrangement is sometimes\nnecessary. In particular, you cannot have polymorphic behaviour in a constructor in C++ -\nsee https://stackoverflow.com/questions/1453131/how-can-i-get-polymorphic-behavior-in-a-c-constructor\n- which means this Python technique will not work. The polymorphism\nrequired has to be provided by an external, already constructed\ninstance of a different class.\nIn general, in Python this won't be necessary, but a second example showing\nthis kind of arrangement is also included.\n*Where is the pattern used practically?\n*References:\nhttps://sourcemaking.com/design_patterns/builder\n*TL;DR\nDecouples the creation of a complex object and its representation.\n\"\"\"\n\n\n# Abstract Building\nclass Building:\n    def __init__(self):\n        self.build_floor()\n        self.build_size()\n\n    def build_floor(self):\n        raise NotImplementedError\n\n    def build_size(self):\n        raise NotImplementedError\n\n    def __repr__(self):\n        return 'Floor: {0.floor} | Size: {0.size}'.format(self)\n\n\n# Concrete Buildings\nclass House(Building):\n    def build_floor(self):\n        self.floor = 'One'\n\n    def build_size(self):\n        self.size = 'Big'\n\n\nclass Flat(Building):\n    def build_floor(self):\n        self.floor = 'More than One'\n\n    def build_size(self):\n        self.size = 'Small'\n\n\n# In some very complex cases, it might be desirable to pull out the building\n# logic into another function (or a method on another class), rather than being\n# in the base class '__init__'. (This leaves you in the strange situation where\n# a concrete class does not have a useful constructor)\n\n\nclass ComplexBuilding:\n    def __repr__(self):\n        return 'Floor: {0.floor} | Size: {0.size}'.format(self)\n\n\nclass ComplexHouse(ComplexBuilding):\n    def build_floor(self):\n        self.floor = 'One'\n\n    def build_size(self):\n        self.size = 'Big and fancy'\n\n\ndef construct_building(cls):\n    building = cls()\n    building.build_floor()\n    building.build_size()\n    return building\n\n\ndef main():\n    \"\"\"\n    >>> house = House()\n    >>> house\n    Floor: One | Size: Big\n    >>> flat = Flat()\n    >>> flat\n    Floor: More than One | Size: Small\n    # Using an external constructor function:\n    >>> complex_house = construct_building(ComplexHouse)\n    >>> complex_house\n    Floor: One | Size: Big and fancy\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n```\n\n#### Фабричный метод (Factory method)\n\nПаттерн Фабричный метод применяется, когда мы хотим, чтобы подклассы выбирали, какой класс инстанциировать, когда запрашивается объект. Это полезно само по себе, но можно пойти дальше и использовать в случае, когда класс заранее неизвестен (например, зависит от информации, прочитанной из файла или введенных пользователем данных).\n\nАбстрактная фабрика часто реализуется с помощью фабричных методов.\nФабричные методы часто вызываются внутри шаблонных методов.\n\n```python\n\"\"\"*What is this pattern about?\nA Factory is an object for creating other objects.\n*What does this example do?\nThe code shows a way to localize words in two languages: English and\nGreek. \"get_localizer\" is the factory function that constructs a\nlocalizer depending on the language chosen. The localizer object will\nbe an instance from a different class according to the language\nlocalized. However, the main code does not have to worry about which\nlocalizer will be instantiated, since the method \"localize\" will be called\nin the same way independently of the language.\n*Where can the pattern be used practically?\nThe Factory Method can be seen in the popular web framework Django:\nhttp://django.wikispaces.asu.edu/*NEW*+Django+Design+Patterns For\nexample, in a contact form of a web page, the subject and the message\nfields are created using the same form factory (CharField()), even\nthough they have different implementations according to their\npurposes.\n*References:\nhttp://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/\n*TL;DR\nCreates objects without having to specify the exact class.\n\"\"\"\n\n\nclass GreekLocalizer:\n    \"\"\"A simple localizer a la gettext\"\"\"\n\n    def __init__(self):\n        self.translations = {\"dog\": \"σκύλος\", \"cat\": \"γάτα\"}\n\n    def localize(self, msg):\n        \"\"\"We'll punt if we don't have a translation\"\"\"\n        return self.translations.get(msg, msg)\n\n\nclass EnglishLocalizer:\n    \"\"\"Simply echoes the message\"\"\"\n\n    def localize(self, msg):\n        return msg\n\n\ndef get_localizer(language=\"English\"):\n    \"\"\"Factory\"\"\"\n    localizers = {\n        \"English\": EnglishLocalizer,\n        \"Greek\": GreekLocalizer,\n    }\n    return localizers[language]()\n\n\ndef main():\n    \"\"\"\n    # Create our localizers\n    >>> e, g = get_localizer(language=\"English\"), get_localizer(language=\"Greek\")\n    # Localize some text\n    >>> for msg in \"dog parrot cat bear\".split():\n    ...     print(e.localize(msg), g.localize(msg))\n    dog σκύλος\n    parrot parrot\n    cat γάτα\n    bear bear\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n```\n\n#### Прототип (Prototype)\n\nПаттерн Прототип применяется для создания нового объекта путем клонирования исходного с последующей модификацией клона.\n\nСпособы создания нового объекта в Python:\n\n```python\nclass Point:\n    __slots__ = ('x', 'y',)\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n# При таком классическом определении класса Point создать новую точку можно семью способами\n\ndef make_object(cls, *args, **kwargs):\n    return cls(*args, **kwargs)\n\npoint1 = Point(1, 2)\npoint2 = eval('{}({}, {})'.format('Point', 2, 4)) # Опасно\npoint3 = getattr(sys.modules[__name__], 'Point')(3, 6)\npoint4 = globals()['Point'](4, 8)\npoint5 = make_object(Point, 5, 10)\npoint6 = copy.deepcopy(point5)\npoint6.x = 6\npoint6.y = 12\npoint7 = point1.__class__(7, 14)\n```\n\nПри создании point6 используется классический подход на основе прототипа: сначала мы клонируем существующий объект, а затем  инициализируем и конфигурируем его. Для создания point7 мы берем объект класса точки point1 и передаем ему другие аргументы.\n\nНа примере point6 мы видим, чтов  Python уже встроена поддержка прототипов в виде функции copy.deepcopy(). Однако пример point7 показывает, что в Python есть средства и поулчше: вместо того чтобы клонировать существующий объект и модифицировать клон, Python предоставляет доступ к объекту класса имеющегося объекта и таким образом мы можем создать новый объект непосредственно, что гораздо эффективнее клонирования.\n\nПрототип - паттерн, порождающий объекты. Задает виды создаваемых объектов с помощью экземпляра-прототипа и создает новые объекты путем копирования этого прототипа.\n\n```python\n\"\"\"\n*What is this pattern about?\nThis patterns aims to reduce the number of classes required by an\napplication. Instead of relying on subclasses it creates objects by\ncopying a prototypical instance at run-time.\nThis is useful as it makes it easier to derive new kinds of objects,\nwhen instances of the class have only a few different combinations of\nstate, and when instantiation is expensive.\n*What does this example do?\nWhen the number of prototypes in an application can vary, it can be\nuseful to keep a Dispatcher (aka, Registry or Manager). This allows\nclients to query the Dispatcher for a prototype before cloning a new\ninstance.\nBelow provides an example of such Dispatcher, which contains three\ncopies of the prototype: 'default', 'objecta' and 'objectb'.\n*TL;DR\nCreates new object instances by cloning prototype.\n\"\"\"\n\n\nclass Prototype:\n\n    value = 'default'\n\n    def clone(self, **attrs):\n        \"\"\"Clone a prototype and update inner attributes dictionary\"\"\"\n        # Python in Practice, Mark Summerfield\n        obj = self.__class__()\n        obj.__dict__.update(attrs)\n        return obj\n\n\nclass PrototypeDispatcher:\n    def __init__(self):\n        self._objects = {}\n\n    def get_objects(self):\n        \"\"\"Get all objects\"\"\"\n        return self._objects\n\n    def register_object(self, name, obj):\n        \"\"\"Register an object\"\"\"\n        self._objects[name] = obj\n\n    def unregister_object(self, name):\n        \"\"\"Unregister an object\"\"\"\n        del self._objects[name]\n\n\ndef main():\n    \"\"\"\n    >>> dispatcher = PrototypeDispatcher()\n    >>> prototype = Prototype()\n    >>> d = prototype.clone()\n    >>> a = prototype.clone(value='a-value', category='a')\n    >>> b = prototype.clone(value='b-value', is_checked=True)\n    >>> dispatcher.register_object('objecta', a)\n    >>> dispatcher.register_object('objectb', b)\n    >>> dispatcher.register_object('default', d)\n    >>> [{n: p.value} for n, p in dispatcher.get_objects().items()]\n    [{'objecta': 'a-value'}, {'objectb': 'b-value'}, {'default': 'default'}]\n    \"\"\"\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n```\n\n#### Одиночка (Singleton)\n\nПаттерн Одиночка (Синглтон) применяется, когда необходим класс, у которого должен быть единственный экземпляр во всей программе.\n\nС помощью паттерна одиночка могут быть реализованы многие паттерны (абстрактная фабрика, строитель, прототип).\n\nВ сборнике рецептов приводится простой класс Singleton, которому любой класс может унаследовать, чтобы стать одиночкой.\n\n```python\n\"\"\"\nYet one singleton realization on Python without metaclass. Singleton may has __init__ method which will call only when first object create.\nhttp://code.activestate.com/recipes/577208-singletonsubclass-with-once-initialization/\n\"\"\"\n\n\nclass Singleton(object):\n\n    def __new__(cls,*dt,**mp):\n        if not hasattr(cls,'_inst'):\n            cls._inst = super(Singleton, cls).__new__(cls,dt,mp)\n        else:\n            def init_pass(self,*dt,**mp):pass\n            cls.__init__ = init_pass\n\n        return cls._inst\n\nif __name__ == '__main__':\n\n\n    class A(Singleton):\n\n        def __init__(self):\n            \"\"\"Super constructor\n                There is we can open file or create connection to the database\n            \"\"\"\n            print \"A init\"\n\n\n    a1 = A()\n    a2 = A()\n```\n\nИ класс Borg, который даст тот же результат совсем другим способом.\n\n```python\n\"\"\"\n*What is this pattern about?\nThe Borg pattern (also known as the Monostate pattern) is a way to\nimplement singleton behavior, but instead of having only one instance\nof a class, there are multiple instances that share the same state. In\nother words, the focus is on sharing state instead of sharing instance\nidentity.\n*What does this example do?\nTo understand the implementation of this pattern in Python, it is\nimportant to know that, in Python, instance attributes are stored in a\nattribute dictionary called __dict__. Usually, each instance will have\nits own dictionary, but the Borg pattern modifies this so that all\ninstances have the same dictionary.\nIn this example, the __shared_state attribute will be the dictionary\nshared between all instances, and this is ensured by assigining\n__shared_state to the __dict__ variable when initializing a new\ninstance (i.e., in the __init__ method). Other attributes are usually\nadded to the instance's attribute dictionary, but, since the attribute\ndictionary itself is shared (which is __shared_state), all other\nattributes will also be shared.\n*Where is the pattern used practically?\nSharing state is useful in applications like managing database connections:\nhttps://github.com/onetwopunch/pythonDbTemplate/blob/master/database.py\n*References:\nhttps://fkromer.github.io/python-pattern-references/design/#singleton\n*TL;DR\nProvides singleton-like behavior sharing state between instances.\n\"\"\"\n\n\nclass Borg:\n    __shared_state = {}\n\n    def __init__(self):\n        self.__dict__ = self.__shared_state\n        self.state = 'Init'\n\n    def __str__(self):\n        return self.state\n\n\nclass YourBorg(Borg):\n    pass\n\n\ndef main():\n    \"\"\"\n    >>> rm1 = Borg()\n    >>> rm2 = Borg()\n    >>> rm1.state = 'Idle'\n    >>> rm2.state = 'Running'\n    >>> print('rm1: {0}'.format(rm1))\n    rm1: Running\n    >>> print('rm2: {0}'.format(rm2))\n    rm2: Running\n    # When the `state` attribute is modified from instance `rm2`,\n    # the value of `state` in instance `rm1` also changes\n    >>> rm2.state = 'Zombie'\n    >>> print('rm1: {0}'.format(rm1))\n    rm1: Zombie\n    >>> print('rm2: {0}'.format(rm2))\n    rm2: Zombie\n    # Even though `rm1` and `rm2` share attributes, the instances are not the same\n    >>> rm1 is rm2\n    False\n    # Shared state is also modified from a subclass instance `rm3`\n    >>> rm3 = YourBorg()\n    >>> print('rm1: {0}'.format(rm1))\n    rm1: Init\n    >>> print('rm2: {0}'.format(rm2))\n    rm2: Init\n    >>> print('rm3: {0}'.format(rm3))\n    rm3: Init\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n```\n\nОднако самый простой способ получить функциональность одиночки в Python - создать модуль с глобальным состоянием, которое хранится в закрытых переменных, и предоставить открытые функции для доступа к нему. Например, для получения курсов валют нам понадобится функция, которая будет возвращать словарь (ключ - название валюты, значение - обменный курс). Возможно, эту функцию понадобится вызывать несколько раз, но в большинстве случев извлекать откуда-то курсы нужно единожды. Реализовать это поможет паттерн Одиночка.\n\n```python\n#!/usr/bin/env python3\n# Copyright © 2012-13 Qtrac Ltd. All rights reserved.\n# This program or module is free software: you can redistribute it\n# and/or modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation, either version 3 of the\n# License, or (at your option) any later version. It is provided for\n# educational purposes and is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n\nimport re\nimport urllib.request\n\n\n_URL = \"http://www.bankofcanada.ca/stats/assets/csv/fx-seven-day.csv\"\n\n\ndef get(refresh=False):\n    if refresh:\n        get.rates = {}\n    if get.rates:\n        return get.rates\n    with urllib.request.urlopen(_URL) as file:\n        for line in file:\n            line = line.rstrip().decode(\"utf-8\")\n            if not line or line.startswith((\"#\", \"Date\")):\n                continue\n            name, currency, *rest = re.split(r\"/s*,/s*\", line)\n            key = \"{} ({})\".format(name, currency)\n            try:\n                get.rates[key] = float(rest[-1])\n            except ValueError as err:\n                print(\"error {}: {}\".format(err, line))\n    return get.rates\nget.rates = {}\n\n\nif __name__ == \"__main__\":\n    import sys\n    if sys.stdout.isatty():\n        print(get())\n    else:\n        print(\"Loaded OK\")\n\n```\n\nЗдесь мы создаем словарь rates в виде атрибута функции Rates.get() - это наше закрытое значение. Когда открытая функция get() вызывается в первый раз (а также при вызове с параметром refresh=True), мы загружаем список курсов; в противном случае просто возвращаем последние загруженные курсы.\n\n#### Порождающие паттерны. Итог\n\nВсе порождающие паттерны проектирования реализуются на Python тривиально. Паттерн Одиночка можно реализовать непосредственно с помощью модуля, а паттерн Прототип вообще ни к чему (хотя его можно реализовать с помощью модуля copy), так как Python дает динамический доступ к объектам классов. Из порождающих паттернов наиболее полезны Фабрика и Построитель, и реализовать их можно несколькими способами.\n\n### Структурные (Structural)\n\nСтруктурные паттерны описывают, как из одних объектов составляются другие, более крупные. Рассматриваются три основных круга вопросов: адаптация интерфейсов, добавление функциональности и работа с коллекциями объектов.\n\n#### Адаптер (Adapter)\n\nПаттерн Адаптер описывает технику адаптации интерфейса. Задача состоит в том, чтобы один класс мог воспользоваться другим - с несовместимым интерфейсом - без внесения каких-либо изменений в оба класса. Это полезно, например, когда требуется воспользоваться не подлежащим изменению классом в контексте, на который он не был расчитан.\n\nАдаптер обеспечивает совместную работу классов с несовместимыми интерфейсами, которая без него была бы невозможна.\n\n```python\n\"\"\"\n*What is this pattern about?\nThe Adapter pattern provides a different interface for a class. We can\nthink about it as a cable adapter that allows you to charge a phone\nsomewhere that has outlets in a different shape. Following this idea,\nthe Adapter pattern is useful to integrate classes that couldn't be\nintegrated due to their incompatible interfaces.\n*What does this example do?\nThe example has classes that represent entities (Dog, Cat, Human, Car)\nthat make different noises. The Adapter class provides a different\ninterface to the original methods that make such noises. So the\noriginal interfaces (e.g., bark and meow) are available under a\ndifferent name: make_noise.\n*Where is the pattern used practically?\nThe Grok framework uses adapters to make objects work with a\nparticular API without modifying the objects themselves:\nhttp://grok.zope.org/doc/current/grok_overview.html#adapters\n*References:\nhttp://ginstrom.com/scribbles/2008/11/06/generic-adapter-class-in-python/\nhttps://sourcemaking.com/design_patterns/adapter\nhttp://python-3-patterns-idioms-test.readthedocs.io/en/latest/ChangeInterface.html#adapter\n*TL;DR\nAllows the interface of an existing class to be used as another interface.\n\"\"\"\n\n\nclass Dog:\n    def __init__(self):\n        self.name = \"Dog\"\n\n    def bark(self):\n        return \"woof!\"\n\n\nclass Cat:\n    def __init__(self):\n        self.name = \"Cat\"\n\n    def meow(self):\n        return \"meow!\"\n\n\nclass Human:\n    def __init__(self):\n        self.name = \"Human\"\n\n    def speak(self):\n        return \"'hello'\"\n\n\nclass Car:\n    def __init__(self):\n        self.name = \"Car\"\n\n    def make_noise(self, octane_level):\n        return \"vroom{0}\".format(\"!\" * octane_level)\n\n\nclass Adapter:\n    \"\"\"\n    Adapts an object by replacing methods.\n    Usage:\n    dog = Dog()\n    dog = Adapter(dog, make_noise=dog.bark)\n    \"\"\"\n\n    def __init__(self, obj, **adapted_methods):\n        \"\"\"We set the adapted methods in the object's dict\"\"\"\n        self.obj = obj\n        self.__dict__.update(adapted_methods)\n\n    def __getattr__(self, attr):\n        \"\"\"All non-adapted calls are passed to the object\"\"\"\n        return getattr(self.obj, attr)\n\n    def original_dict(self):\n        \"\"\"Print original object dict\"\"\"\n        return self.obj.__dict__\n\n\ndef main():\n    \"\"\"\n    >>> objects = []\n    >>> dog = Dog()\n    >>> print(dog.__dict__)\n    {'name': 'Dog'}\n    >>> objects.append(Adapter(dog, make_noise=dog.bark))\n    >>> objects[0].__dict__['obj'], objects[0].__dict__['make_noise']\n    (<...Dog object at 0x...>, <bound method Dog.bark of <...Dog object at 0x...>>)\n    >>> print(objects[0].original_dict())\n    {'name': 'Dog'}\n    >>> cat = Cat()\n    >>> objects.append(Adapter(cat, make_noise=cat.meow))\n    >>> human = Human()\n    >>> objects.append(Adapter(human, make_noise=human.speak))\n    >>> car = Car()\n    >>> objects.append(Adapter(car, make_noise=lambda: car.make_noise(3)))\n    >>> for obj in objects:\n    ...    print(\"A {0} goes {1}\".format(obj.name, obj.make_noise()))\n    A Dog goes woof!\n    A Cat goes meow!\n    A Human goes 'hello'\n    A Car goes vroom!!!\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(optionflags=doctest.ELLIPSIS)\n```\n\n#### Мост (Bridge)\n\nМост (Bridge) - паттерн, структурирующий объекты. Основная задача - отделить абстракцию от её реализации так, чтобы то и другое можно было изменять независимо.\n\nТрадиционный подход без использования паттерна Мост состоит в том, чтобы создать один или несколько абстрактных базовых классов, а затем предоставить две или более конкретных реализации каждого базового класса.\nА паттерн Мост предлагает создать две независимых иерархии классов: \"абстрактную\", которая определяет операции (например интерфейс или алгоритм верхнего уровня) и конкретную, предоставляющую реализацию, которые в конечном итоге и будут вызваны из абстрактных операций. \"Абстрактный\" класс агрегирует экземпляр одного из конкретных классов с реализацией - и этот последний служит *мостом* между абстрактным интерфейсом и конкретными операциями.\n\n```python\n\"\"\"\n*References:\nhttp://en.wikibooks.org/wiki/Computer_Science_Design_Patterns/Bridge_Pattern#Python\n*TL;DR\nDecouples an abstraction from its implementation.\n\"\"\"\n\n\n# ConcreteImplementor 1/2\nclass DrawingAPI1:\n    def draw_circle(self, x, y, radius):\n        print('API1.circle at {}:{} radius {}'.format(x, y, radius))\n\n\n# ConcreteImplementor 2/2\nclass DrawingAPI2:\n    def draw_circle(self, x, y, radius):\n        print('API2.circle at {}:{} radius {}'.format(x, y, radius))\n\n\n# Refined Abstraction\nclass CircleShape:\n    def __init__(self, x, y, radius, drawing_api):\n        self._x = x\n        self._y = y\n        self._radius = radius\n        self._drawing_api = drawing_api\n\n    # low-level i.e. Implementation specific\n    def draw(self):\n        self._drawing_api.draw_circle(self._x, self._y, self._radius)\n\n    # high-level i.e. Abstraction specific\n    def scale(self, pct):\n        self._radius *= pct\n\n\ndef main():\n    \"\"\"\n    >>> shapes = (CircleShape(1, 2, 3, DrawingAPI1()), CircleShape(5, 7, 11, DrawingAPI2()))\n    >>> for shape in shapes:\n    ...    shape.scale(2.5)\n    ...    shape.draw()\n    API1.circle at 1:2 radius 7.5\n    API2.circle at 5:7 radius 27.5\n    \"\"\"\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n```\n\n#### Компоновщик (Composite)\n\nПаттерн Компоновщик позволяет единообразно обрабатывать объекты, образующие иерархию, вне зависимости от того, содержат они другие объекты или нет. Такие объекты называют составными.\n\nВ классическом решении составные объекты - как отдельные, так и коллекции - имеют один и тот же базовый класс. У составных и несоставных объектов обычно одни и те же основные методы, но составные объекты добавляют методы для поддержки добавления, удаления и перебора дочерних объектов.\n\nЭтот паттерн часто применяется в программах рисования, например Inkscape, для поддержки группировки и разгруппировки. Его полезность в таких ситуациях объясняется тем, что подлежащие группировке или разгруппировке компоненты могут быть как одиночными (например прямоугольник) так и состаными (например, рожица, составленная из нескольких разных фигур)\n\n```python\n\"\"\"\n*What is this pattern about?\nThe composite pattern describes a group of objects that is treated the\nsame way as a single instance of the same type of object. The intent of\na composite is to \"compose\" objects into tree structures to represent\npart-whole hierarchies. Implementing the composite pattern lets clients\ntreat individual objects and compositions uniformly.\n*What does this example do?\nThe example implements a graphic class，which can be either an ellipse\nor a composition of several graphics. Every graphic can be printed.\n*Where is the pattern used practically?\nIn graphics editors a shape can be basic or complex. An example of a\nsimple shape is a line, where a complex shape is a rectangle which is\nmade of four line objects. Since shapes have many operations in common\nsuch as rendering the shape to screen, and since shapes follow a\npart-whole hierarchy, composite pattern can be used to enable the\nprogram to deal with all shapes uniformly.\n*References:\nhttps://en.wikipedia.org/wiki/Composite_pattern\nhttps://infinitescript.com/2014/10/the-23-gang-of-three-design-patterns/\n*TL;DR\nDescribes a group of objects that is treated as a single instance.\n\"\"\"\n\n\nclass Graphic:\n    def render(self):\n        raise NotImplementedError(\"You should implement this.\")\n\n\nclass CompositeGraphic(Graphic):\n    def __init__(self):\n        self.graphics = []\n\n    def render(self):\n        for graphic in self.graphics:\n            graphic.render()\n\n    def add(self, graphic):\n        self.graphics.append(graphic)\n\n    def remove(self, graphic):\n        self.graphics.remove(graphic)\n\n\nclass Ellipse(Graphic):\n    def __init__(self, name):\n        self.name = name\n\n    def render(self):\n        print(\"Ellipse: {}\".format(self.name))\n\n\nif __name__ == '__main__':\n    ellipse1 = Ellipse(\"1\")\n    ellipse2 = Ellipse(\"2\")\n    ellipse3 = Ellipse(\"3\")\n    ellipse4 = Ellipse(\"4\")\n\n    graphic1 = CompositeGraphic()\n    graphic2 = CompositeGraphic()\n\n    graphic1.add(ellipse1)\n    graphic1.add(ellipse2)\n    graphic1.add(ellipse3)\n    graphic2.add(ellipse4)\n\n    graphic = CompositeGraphic()\n\n    graphic.add(graphic1)\n    graphic.add(graphic2)\n\n    graphic.render()\n\n# OUTPUT #\n# Ellipse: 1\n# Ellipse: 2\n# Ellipse: 3\n# Ellipse: 4\n```\n\n#### Декоратор (Decorator)\n\nДекоратором называется функция, которая принимает функцию с таким же именем, как у исходной, но с расширенной функциональностью. Декораторы часто используются во фреймвоках, чтобы упростить интеграцию пользовательских функций с фреймворком.\n\nПаттерн Декоратор настолько полезен, что в Python встроена специальная поддержка для него. В Python декорировать можно как функции, так и методы. Кроме того, Python поддерживает декораторы классов: функции, которые принимают клас в качестве аргумента и возвращают новый класс с таким же именем, как у исходного, но дополненной функциональностью.\n\nИногда декораторы классов удобно использовать как альтернативу производным классам.\n\n```python\n\"\"\"\n*What is this pattern about?\nThe Decorator pattern is used to dynamically add a new feature to an\nobject without changing its implementation. It differs from\ninheritance because the new feature is added only to that particular\nobject, not to the entire subclass.\n*What does this example do?\nThis example shows a way to add formatting options (boldface and\nitalic) to a text by appending the corresponding tags (<b> and\n<i>). Also, we can see that decorators can be applied one after the other,\nsince the original text is passed to the bold wrapper, which in turn\nis passed to the italic wrapper.\n*Where is the pattern used practically?\nThe Grok framework uses decorators to add functionalities to methods,\nlike permissions or subscription to an event:\nhttp://grok.zope.org/doc/current/reference/decorators.html\n*References:\nhttps://sourcemaking.com/design_patterns/decorator\n*TL;DR\nAdds behaviour to object without affecting its class.\n\"\"\"\n\n\nclass TextTag:\n    \"\"\"Represents a base text tag\"\"\"\n\n    def __init__(self, text):\n        self._text = text\n\n    def render(self):\n        return self._text\n\n\nclass BoldWrapper(TextTag):\n    \"\"\"Wraps a tag in <b>\"\"\"\n\n    def __init__(self, wrapped):\n        self._wrapped = wrapped\n\n    def render(self):\n        return \"<b>{}</b>\".format(self._wrapped.render())\n\n\nclass ItalicWrapper(TextTag):\n    \"\"\"Wraps a tag in <i>\"\"\"\n\n    def __init__(self, wrapped):\n        self._wrapped = wrapped\n\n    def render(self):\n        return \"<i>{}</i>\".format(self._wrapped.render())\n\n\nif __name__ == '__main__':\n    simple_hello = TextTag(\"hello, world!\")\n    special_hello = ItalicWrapper(BoldWrapper(simple_hello))\n    print(\"before:\", simple_hello.render())\n    print(\"after:\", special_hello.render())\n\n# OUTPUT #\n# before: hello, world!\n# after: <i><b>hello, world!</b></i>\n```\n\n#### Фасад (Facade)\n\nПаттерн Фасад служит для того, чтобы предоставить упрощенный унифицированный интерфейс к подсистеме, чей истинный интерфейс слишком сложен или написан на таком низком уровне, что работать с ним неудобно. Фасад определяет интерфейс более высокого уровня, который упрощает использование подсистемы.\n\nВ стандартной библиотеке Python имеется несколько модулей для работы с сжатыми файлами - gzip, tar+gzip, zip. Все они имеют разные интерфейсы. Если мы хотим иметь один унифицированный интерфейс для работы с архивами, мы можем воспользоваться паттерном Фасад.\n\nПаттерны Фасад и Адаптер на первый взгляд кажутся похожими. Разница в том, что Фасад надстраивает простой интерфейс поверх сложного, а Адаптер надстраивает унифицированный интерфейс над каким-то другим (необязательно сложным). Оба эти паттерна можно использовать совместно. Например определить интерфейс для работы с архивными файлами, написать адапрет для каждого формата и надстроить поверх них фасад, чтобы пользователям не нужно было беспокоиться о том, какой конкретно формат файла используется.\n\n```python\n\"\"\"\nExample from https://en.wikipedia.org/wiki/Facade_pattern#Python\n*What is this pattern about?\nThe Facade pattern is a way to provide a simpler unified interface to\na more complex system. It provides an easier way to access functions\nof the underlying system by providing a single entry point.\nThis kind of abstraction is seen in many real life situations. For\nexample, we can turn on a computer by just pressing a button, but in\nfact there are many procedures and operations done when that happens\n(e.g., loading programs from disk to memory). In this case, the button\nserves as an unified interface to all the underlying procedures to\nturn on a computer.\n*Where is the pattern used practically?\nThis pattern can be seen in the Python standard library when we use\nthe isdir function. Although a user simply uses this function to know\nwhether a path refers to a directory, the system makes a few\noperations and calls other modules (e.g., os.stat) to give the result.\n*References:\nhttps://sourcemaking.com/design_patterns/facade\nhttps://fkromer.github.io/python-pattern-references/design/#facade\nhttp://python-3-patterns-idioms-test.readthedocs.io/en/latest/ChangeInterface.html#facade\n*TL;DR\nProvides a simpler unified interface to a complex system.\n\"\"\"\n\n\n# Complex computer parts\nclass CPU:\n    \"\"\"\n    Simple CPU representation.\n    \"\"\"\n    def freeze(self):\n        print(\"Freezing processor.\")\n\n    def jump(self, position):\n        print(\"Jumping to:\", position)\n\n    def execute(self):\n        print(\"Executing.\")\n\n\nclass Memory:\n    \"\"\"\n    Simple memory representation.\n    \"\"\"\n    def load(self, position, data):\n        print(\"Loading from {0} data: '{1}'.\".format(position, data))\n\n\nclass SolidStateDrive:\n    \"\"\"\n    Simple solid state drive representation.\n    \"\"\"\n    def read(self, lba, size):\n        return \"Some data from sector {0} with size {1}\".format(lba, size)\n\n\nclass ComputerFacade:\n    \"\"\"\n    Represents a facade for various computer parts.\n    \"\"\"\n    def __init__(self):\n        self.cpu = CPU()\n        self.memory = Memory()\n        self.ssd = SolidStateDrive()\n\n    def start(self):\n        self.cpu.freeze()\n        self.memory.load(\"0x00\", self.ssd.read(\"100\", \"1024\"))\n        self.cpu.jump(\"0x00\")\n        self.cpu.execute()\n\n\ndef main():\n    \"\"\"\n    >>> computer_facade = ComputerFacade()\n    >>> computer_facade.start()\n    Freezing processor.\n    Loading from 0x00 data: 'Some data from sector 100 with size 1024'.\n    Jumping to: 0x00\n    Executing.\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(optionflags=doctest.ELLIPSIS)\n```\n\n#### Приспособленец (Flyweight)\n\nПриспособленец предназначен для обработки большого числа сравнительно небольших объектов, когда многие из этих объектов являются дубликатами. Реализация паттерна предполагает, что каждый уникальный объект представлется всего один раз и именно этот экземпляр отдается на запрос. В Python легко реализуется через словарь.\n\nВ Python подход к реализации приспособленцев естественный - благодаря наличию ссылок на объекты. Например, если бы у нас был длинный список строк, в котором много дубликатов, то, сохраняя ссылки на объекты (то есть переменные), а не литеральные строки, мы бы могли существенно сэкономить память\n\n```python\nred, green, blue = 'red', 'green', 'blue'\nx = (red, green, blue, red, green, blue, green)\n```\n\n```python\n\"\"\"\n*What is this pattern about?\nThis pattern aims to minimise the number of objects that are needed by\na program at run-time. A Flyweight is an object shared by multiple\ncontexts, and is indistinguishable from an object that is not shared.\nThe state of a Flyweight should not be affected by it's context, this\nis known as its intrinsic state. The decoupling of the objects state\nfrom the object's context, allows the Flyweight to be shared.\n*What does this example do?\nThe example below sets-up an 'object pool' which stores initialised\nobjects. When a 'Card' is created it first checks to see if it already\nexists instead of creating a new one. This aims to reduce the number of\nobjects initialised by the program.\n*References:\nhttp://codesnipers.com/?q=python-flyweights\nhttps://python-patterns.guide/gang-of-four/flyweight/\n*Examples in Python ecosystem:\nhttps://docs.python.org/3/library/sys.html#sys.intern\n*TL;DR\nMinimizes memory usage by sharing data with other similar objects.\n\"\"\"\n\nimport weakref\n\n\nclass Card:\n    \"\"\"The Flyweight\"\"\"\n\n    # Could be a simple dict.\n    # With WeakValueDictionary garbage collection can reclaim the object\n    # when there are no other references to it.\n    _pool = weakref.WeakValueDictionary()\n\n    def __new__(cls, value, suit):\n        # If the object exists in the pool - just return it\n        obj = cls._pool.get(value + suit)\n        # otherwise - create new one (and add it to the pool)\n        if obj is None:\n            obj = object.__new__(Card)\n            cls._pool[value + suit] = obj\n            # This row does the part we usually see in `__init__`\n            obj.value, obj.suit = value, suit\n        return obj\n\n    # If you uncomment `__init__` and comment-out `__new__` -\n    #   Card becomes normal (non-flyweight).\n    # def __init__(self, value, suit):\n    #     self.value, self.suit = value, suit\n\n    def __repr__(self):\n        return \"<Card: {}{}>\".format(self.value, self.suit)\n\n\ndef main():\n    \"\"\"\n    >>> c1 = Card('9', 'h')\n    >>> c2 = Card('9', 'h')\n    >>> c1, c2\n    (<Card: 9h>, <Card: 9h>)\n    >>> c1 == c2\n    True\n    >>> c1 is c2\n    True\n    >>> c1.new_attr = 'temp'\n    >>> c3 = Card('9', 'h')\n    >>> hasattr(c3, 'new_attr')\n    True\n    >>> Card._pool.clear()\n    >>> c4 = Card('9', 'h')\n    >>> hasattr(c4, 'new_attr')\n    False\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n```\n\n#### Заместитель (Proxy)\n\nПаттерн Заместитель применяется когда мы хотим подставить один объект вместо другого. В книге \"Паттенрны проектирования\" описаны 4 таких случая:\n\n1. удаленный прокси, когда доступ к удаленному объекту проксируется локальным объектом;\n2. вирутальный прокси, который позволяет создавать облегченные объекты вместо тяжеловесных, а последние создавать только когда это необходимо;\n3. защитный прокси, который предоставляет различные уровни доступа, в зависимости от прав клиента;\n4. интелектуальная сслыка, которая выполняет \"дополнительные действия при обращении к объекту\" (можно также реализовать с помощью дескриптопа @property)\n\nMock - пример реализации паттерна Заместитель\n\n```python\n\"\"\"\n*TL;DR\nProvides an interface to resource that is expensive to duplicate.\n\"\"\"\n\nimport time\n\n\nclass SalesManager:\n    def talk(self):\n        print(\"Sales Manager ready to talk\")\n\n\nclass Proxy:\n    def __init__(self):\n        self.busy = 'No'\n        self.sales = None\n\n    def talk(self):\n        print(\"Proxy checking for Sales Manager availability\")\n        if self.busy == 'No':\n            self.sales = SalesManager()\n            time.sleep(0.1)\n            self.sales.talk()\n        else:\n            time.sleep(0.1)\n            print(\"Sales Manager is busy\")\n\n\nclass NoTalkProxy(Proxy):\n    def talk(self):\n        print(\"Proxy checking for Sales Manager availability\")\n        time.sleep(0.1)\n        print(\"This Sales Manager will not talk to you\", \"whether he/she is busy or not\")\n\n\nif __name__ == '__main__':\n    p = Proxy()\n    p.talk()\n    p.busy = 'Yes'\n    p.talk()\n    p = NoTalkProxy()\n    p.talk()\n    p.busy = 'Yes'\n    p.talk()\n\n# OUTPUT #\n# Proxy checking for Sales Manager availability\n# Sales Manager ready to talk\n# Proxy checking for Sales Manager availability\n# Sales Manager is busy\n# Proxy checking for Sales Manager availability\n# This Sales Manager will not talk to you whether he/she is busy or not\n# Proxy checking for Sales Manager availability\n# This Sales Manager will not talk to you whether he/she is busy or not\n```\n\n#### Структурные паттерны. Итог\n\nПаттерны Адаптер и Фасад упрощают повторное использование классов в новых контекстах, а паттерн Мост дает возможность внедрить сложную функциональность одного класса в другой. Компоновщик упрощает создание иерархий объектов, хотя в Python это не особенно нужно, так как для этой цели хватает словарей. Декоратор настолько полезен, что в Python для него имеется прямая поддержка, причем идея декоратора распространена даже на классы. Использование ссылок на объекты означает что в сам язык встроена варианция на тему паттерна Приспособленец. А паттерн Заместитель в Python реализовать особенно просто.\n\n### Поведенческие (Behavioral)\n\nПредмет поведенческих паттерном - способ решения задачи, то есть они имеют дело с алгоритмами и взаимодействиями объектов. Эти паттерны предлагают действенные способы обдумывания и организации вычислений. Для некоторых из них имеется прямяая поддержка в синтаксисе Python.\n\n#### Цепочка ответственности (Chain of responsobility)\n\nПаттерн цепочка отвестственности предназначен, для того чтобы разорвать связь между отправителем запроса и получателем, который этот запрос обрабатывает. Вместо непосредственного вызова одной функции из другой первая функция отправляет запрос цепочке получателей. Первый получатель в цепочке может либо обработать запрос и прервать цепочку (не передавая запрос дальше), либо передать запрос следующему получателю. У второго получателя есть такой же выбор и так далее, пока запрос не дойдет до последнего получателя (который может отбросить запрос или возбудить исключение).\n\nПредставьте себе пользовательский интерфейс, который получает события для обработки. Одни события поступают от пользователя (например, события мыши и клавиатуры), другие - от системы (например, события таймера).\n\n```python\n\"\"\"\n*What is this pattern about?\nThe Chain of responsibility is an object oriented version of the\n`if ... elif ... elif ... else ...` idiom, with the\nbenefit that the condition–action blocks can be dynamically rearranged\nand reconfigured at runtime.\nThis pattern aims to decouple the senders of a request from its\nreceivers by allowing request to move through chained\nreceivers until it is handled.\nRequest receiver in simple form keeps a reference to a single successor.\nAs a variation some receivers may be capable of sending requests out\nin several directions, forming a `tree of responsibility`.\n*TL;DR\nAllow a request to pass down a chain of receivers until it is handled.\n\"\"\"\n\nimport abc\n\n\nclass Handler(metaclass=abc.ABCMeta):\n\n    def __init__(self, successor=None):\n        self.successor = successor\n\n    def handle(self, request):\n        \"\"\"\n        Handle request and stop.\n        If can't - call next handler in chain.\n        As an alternative you might even in case of success\n        call the next handler.\n        \"\"\"\n        res = self.check_range(request)\n        if not res and self.successor:\n            self.successor.handle(request)\n\n    @abc.abstractmethod\n    def check_range(self, request):\n        \"\"\"Compare passed value to predefined interval\"\"\"\n\n\nclass ConcreteHandler0(Handler):\n    \"\"\"Each handler can be different.\n    Be simple and static...\n    \"\"\"\n\n    @staticmethod\n    def check_range(request):\n        if 0 <= request < 10:\n            print(\"request {} handled in handler 0\".format(request))\n            return True\n\n\nclass ConcreteHandler1(Handler):\n    \"\"\"... With it's own internal state\"\"\"\n\n    start, end = 10, 20\n\n    def check_range(self, request):\n        if self.start <= request < self.end:\n            print(\"request {} handled in handler 1\".format(request))\n            return True\n\n\nclass ConcreteHandler2(Handler):\n    \"\"\"... With helper methods.\"\"\"\n\n    def check_range(self, request):\n        start, end = self.get_interval_from_db()\n        if start <= request < end:\n            print(\"request {} handled in handler 2\".format(request))\n            return True\n\n    @staticmethod\n    def get_interval_from_db():\n        return (20, 30)\n\n\nclass FallbackHandler(Handler):\n    @staticmethod\n    def check_range(request):\n        print(\"end of chain, no handler for {}\".format(request))\n        return False\n\n\ndef main():\n    \"\"\"\n    >>> h0 = ConcreteHandler0()\n    >>> h1 = ConcreteHandler1()\n    >>> h2 = ConcreteHandler2(FallbackHandler())\n    >>> h0.successor = h1\n    >>> h1.successor = h2\n    >>> requests = [2, 5, 14, 22, 18, 3, 35, 27, 20]\n    >>> for request in requests:\n    ...     h0.handle(request)\n    request 2 handled in handler 0\n    request 5 handled in handler 0\n    request 14 handled in handler 1\n    request 22 handled in handler 2\n    request 18 handled in handler 1\n    request 3 handled in handler 0\n    end of chain, no handler for 35\n    request 27 handled in handler 2\n    request 20 handled in handler 2\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(optionflags=doctest.ELLIPSIS)\n```\n\n#### Команда (Command)\n\nпаттерн Команда применяется для инкапсуляции команд в виде объектов. Например, с его помощью можно построить последовательность команд для отложенного выполнения или создать команды, допускающие отмену.\n\n```python\n\"\"\"\n*TL;DR\nEncapsulates all information needed to perform an action or trigger an event.\n*Examples in Python ecosystem:\nDjango HttpRequest (without `execute` method):\n https://docs.djangoproject.com/en/2.1/ref/request-response/#httprequest-objects\n\"\"\"\n\nimport os\n\n\nclass MoveFileCommand:\n    def __init__(self, src, dest):\n        self.src = src\n        self.dest = dest\n\n    def execute(self):\n        self.rename(self.src, self.dest)\n\n    def undo(self):\n        self.rename(self.dest, self.src)\n\n    def rename(self, src, dest):\n        print(\"renaming {} to {}\".format(src, dest))\n        os.rename(src, dest)\n\n\ndef main():\n    \"\"\"\n    >>> from os.path import lexists\n    >>> command_stack = [\n    ...     MoveFileCommand('foo.txt', 'bar.txt'),\n    ...     MoveFileCommand('bar.txt', 'baz.txt')\n    ... ]\n    # Verify that none of the target files exist\n    >>> assert not lexists(\"foo.txt\")\n    >>> assert not lexists(\"bar.txt\")\n    >>> assert not lexists(\"baz.txt\")\n    # Create empty file\n    >>> open(\"foo.txt\", \"w\").close()\n    # Commands can be executed later on\n    >>> for cmd in command_stack:\n    ...     cmd.execute()\n    renaming foo.txt to bar.txt\n    renaming bar.txt to baz.txt\n    # And can also be undone at will\n    >>> for cmd in reversed(command_stack):\n    ...     cmd.undo()\n    renaming baz.txt to bar.txt\n    renaming bar.txt to foo.txt\n    >>> os.unlink(\"foo.txt\")\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n```\n\n#### Интерпретатор (Interpreter)\n\nПаттерн Интерпретатор формализует два типичных требования: предоставить средства, с помощью которых пользователь мог бы вводить в программу нестроковые значения, и дать пользователям возможность создавать программы.\n\nНа самом примитивном уровне  приложение получает от пользователя, или от другой программы, строки, которые необходимо каким-то образом интерпретировать (и, быть может, выполнить).\n\nПримером широко распространенного воплощения таких требований является создание предметно-ориентированных языков (DSL).\n\n```python\n\"\"\"\nИнтерпретатор (Interpreter) - паттерн поведения классов.\nДля заданного языка определяет представление его грамматики,\nа также интерпретатор предложений этого языка.\n\"\"\"\n\n\nclass RomanNumeralInterpreter(object):\n    \"\"\"Интерпретатор римских цифр\"\"\"\n    def __init__(self):\n        self.grammar = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n\n    def interpret(self, text):\n        numbers = map(self.grammar.get, text)  # строки в значения\n        if None in numbers:\n            raise ValueError('Ошибочное значение: %s' % text)\n        result = 0  # накапливаем результат\n        temp = None  # запоминаем последнее значение\n        while numbers:\n            num = numbers.pop(0)\n            if temp is None or temp >= num:\n                result += num\n            else:\n                result += (num - temp * 2)\n            temp = num\n        return result\n\n\ninterp = RomanNumeralInterpreter()\nprint interp.interpret('MMMCMXCIX') == 3999  # True\nprint interp.interpret('MCMLXXXVIII') == 1988  # True\n```\n\n#### Итератор (Iterator)\n\nпаттерн Итератор позвояет последовательно обойти элементы коллекции или агрегированного объекта, не раскрывая деталей их внутреннего устройства. Он настолько полезен, что в Python встроена его поддержка, а кроме того, предоставляются специальные методы, которые мы можем реализовать в собственных классах, чтобы органично поддержать итерирование.\n\nИтерирование можно поддержать тремя способами: следуя протоколу последовательности, пользуясь вариантом встроенной функции iter() с двумя агрументами или следуя протоколу итератора.\n\n```python\n#!/usr/bin/env python3\n# Copyright © 2012-13 Qtrac Ltd. All rights reserved.\n# This program or module is free software: you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as published\n# by the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version. It is provided for educational\n# purposes and is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n\n\nclass Bag:\n\n    def __init__(self, items=None):\n        self.__bag = {}\n        if items is not None:\n            for item in items:\n                self.add(item)\n\n\n    def clear(self):\n        self.__bag.clear()\n\n\n    def add(self, item):\n        self.__bag[item] = self.__bag.get(item, 0) + 1\n\n\n    def __delitem__(self, item):\n        if self.__bag.get(item) is not None:\n            self.__bag[item] -= 1\n            if self.__bag[item] <= 0:\n                del self.__bag[item]\n        else:\n            raise KeyError(str(item))\n\n\n    def count(self, item):\n        return self.__bag.get(item, 0)\n\n\n    def __len__(self):\n        return sum(count for count in self.__bag.values())\n\n\n    def __iter__(self):\n        return (item for item, count in self.__bag.items()\n                for _ in range(count))\n\n\n    items = __iter__\n\n\n    def __contains__(self, item):\n        return item in self.__bag\n\n```\n\n#### Посредник (Mediator)\n\nПаттерн Посредник представляет средства для создания объекта - посредника - который инкапсулирует взаимодействия между другими объектами. Это позволяет осуществлять взаимодействия между объектами, которые ничего не знают друг о друге. Например, в случае нажатия кнопки соответствующий ей объект должен только известить посредника, а уж тот уведомит все объекты, которых интересует нажатие этой кнопки.\n\nПосредник обеспечивает слабую связанность системы, избавляя объекты от необъодимости явно ссылаться друг на друга и позволяя тем самым независимо изменять взаимодействия между ними.\n\n```python\n\"\"\"\nhttps://www.djangospin.com/design-patterns-python/mediator/\nObjects in a system communicate through a Mediator instead of directly with each other.\nThis reduces the dependencies between communicating objects, thereby reducing coupling.\n*TL;DR\nEncapsulates how a set of objects interact.\n\"\"\"\n\n\nclass ChatRoom:\n    \"\"\"Mediator class\"\"\"\n\n    def display_message(self, user, message):\n        print(\"[{} says]: {}\".format(user, message))\n\n\nclass User:\n    \"\"\"A class whose instances want to interact with each other\"\"\"\n\n    def __init__(self, name):\n        self.name = name\n        self.chat_room = ChatRoom()\n\n    def say(self, message):\n        self.chat_room.display_message(self, message)\n\n    def __str__(self):\n        return self.name\n\n\ndef main():\n    \"\"\"\n    >>> molly = User('Molly')\n    >>> mark = User('Mark')\n    >>> ethan = User('Ethan')\n    >>> molly.say(\"Hi Team! Meeting at 3 PM today.\")\n    [Molly says]: Hi Team! Meeting at 3 PM today.\n    >>> mark.say(\"Roger that!\")\n    [Mark says]: Roger that!\n    >>> ethan.say(\"Alright.\")\n    [Ethan says]: Alright.\n    \"\"\"\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n```\n\nЕще пример\n\n```python\n#!/usr/bin/env python3\n# Copyright © 2012-13 Qtrac Ltd. All rights reserved.\n# This program or module is free software: you can redistribute it\n# and/or modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation, either version 3 of the\n# License, or (at your option) any later version. It is provided for\n# educational purposes and is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n\nimport collections\n\n\ndef main():\n    form = Form()\n    test_user_interaction_with(form)\n\n\nclass Form:\n\n    def __init__(self):\n        self.create_widgets()\n        self.create_mediator()\n\n\n    def create_widgets(self):\n        self.nameText = Text()\n        self.emailText = Text()\n        self.okButton = Button(\"OK\")\n        self.cancelButton = Button(\"Cancel\")\n\n\n    def create_mediator(self):\n        self.mediator = Mediator(((self.nameText, self.update_ui),\n                (self.emailText, self.update_ui),\n                (self.okButton, self.clicked),\n                (self.cancelButton, self.clicked)))\n        self.update_ui()\n\n\n    def update_ui(self, widget=None):\n        self.okButton.enabled = (bool(self.nameText.text) and\n                                 bool(self.emailText.text))\n\n\n    def clicked(self, widget):\n        if widget == self.okButton:\n            print(\"OK\")\n        elif widget == self.cancelButton:\n            print(\"Cancel\")\n\n\nclass Mediator:\n\n    def __init__(self, widgetCallablePairs):\n        self.callablesForWidget = collections.defaultdict(list)\n        for widget, caller in widgetCallablePairs:\n            self.callablesForWidget[widget].append(caller)\n            widget.mediator = self\n\n\n    def on_change(self, widget):\n        callables = self.callablesForWidget.get(widget)\n        if callables is not None:\n            for caller in callables:\n                caller(widget)\n        else:\n            raise AttributeError(\"No on_change() method registered for {}\"\n                    .format(widget))\n\n\nclass Mediated:\n\n    def __init__(self):\n        self.mediator = None\n\n\n    def on_change(self):\n        if self.mediator is not None:\n            self.mediator.on_change(self)\n\n\nclass Button(Mediated):\n\n    def __init__(self, text=\"\"):\n        super().__init__()\n        self.enabled = True\n        self.text = text\n\n\n    def click(self):\n        if self.enabled:\n            self.on_change()\n\n\n    def __str__(self):\n        return \"Button({!r}) {}\".format(self.text,\n                \"enabled\" if self.enabled else \"disabled\")\n\n\nclass Text(Mediated):\n\n    def __init__(self, text=\"\"):\n        super().__init__()\n        self.__text = text\n\n\n    @property\n    def text(self):\n        return self.__text\n\n\n    @text.setter\n    def text(self, text):\n        if self.text != text:\n            self.__text = text\n            self.on_change()\n\n\n    def __str__(self):\n        return \"Text({!r})\".format(self.text)\n\n\ndef test_user_interaction_with(form):\n    form.okButton.click()           # Ignored because it is disabled\n    print(form.okButton.enabled)    # False\n    form.nameText.text = \"Fred\"\n    print(form.okButton.enabled)    # False\n    form.emailText.text = \"fred@bloggers.com\"\n    print(form.okButton.enabled)    # True\n    form.okButton.click()           # OK\n    form.emailText.text = \"\"\n    print(form.okButton.enabled)    # False\n    form.cancelButton.click()       # Cancel\n\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n#### Хранитель (Memento)\n\nПаттерн хранитель служит для сохранения и восстановленя состояния объекта, не нарушая инкапсуляцию.\n\nВ языке Python имеется готовая поддержка этого паттерна; с помощью модуля `pickle` мы можем сериализовать и десериализовать произвольные объекты Python (с некоторыми ограничениями, например, нельзя сериализовать файловый объект).\n\nДаже в тех редких случаях, когда мы сталкиваемся с ограничением сериализации, всегда можно добавить собственную поддержку этого механизам, например, реализовав специальные методы `__getstate__()` и `__setstate__()` и, возможно, метод `__getnewargs__()`. Аналогично если мы захотим использовать формат JSON для своих классов, то сможем расширить кодировщик и декодировщик ищ модуля `json`.\n\nМожно было бы придумать собственный формат и протоколы, но смысла в это немного, так как Python и так предоставляет развитую поддержку этого паттерна.\n\n```python\n\"\"\"\nhttp://code.activestate.com/recipes/413838-memento-closure/\n*TL;DR\nProvides the ability to restore an object to its previous state.\n\"\"\"\n\nfrom copy import copy\nfrom copy import deepcopy\n\n\ndef memento(obj, deep=False):\n    state = deepcopy(obj.__dict__) if deep else copy(obj.__dict__)\n\n    def restore():\n        obj.__dict__.clear()\n        obj.__dict__.update(state)\n\n    return restore\n\n\nclass Transaction:\n    \"\"\"A transaction guard.\n    This is, in fact, just syntactic sugar around a memento closure.\n    \"\"\"\n\n    deep = False\n    states = []\n\n    def __init__(self, deep, *targets):\n        self.deep = deep\n        self.targets = targets\n        self.commit()\n\n    def commit(self):\n        self.states = [memento(target, self.deep) for target in self.targets]\n\n    def rollback(self):\n        for a_state in self.states:\n            a_state()\n\n\nclass Transactional:\n    \"\"\"Adds transactional semantics to methods. Methods decorated  with\n    @Transactional will rollback to entry-state upon exceptions.\n    \"\"\"\n\n    def __init__(self, method):\n        self.method = method\n\n    def __get__(self, obj, T):\n        def transaction(*args, **kwargs):\n            state = memento(obj)\n            try:\n                return self.method(obj, *args, **kwargs)\n            except Exception as e:\n                state()\n                raise e\n\n        return transaction\n\n\nclass NumObj:\n    def __init__(self, value):\n        self.value = value\n\n    def __repr__(self):\n        return '<%s: %r>' % (self.__class__.__name__, self.value)\n\n    def increment(self):\n        self.value += 1\n\n    @Transactional\n    def do_stuff(self):\n        self.value = '1111'  # <- invalid value\n        self.increment()  # <- will fail and rollback\n\n\ndef main():\n    \"\"\"\n    >>> num_obj = NumObj(-1)\n    >>> print(num_obj)\n    <NumObj: -1>\n    >>> a_transaction = Transaction(True, num_obj)\n    >>> try:\n    ...    for i in range(3):\n    ...        num_obj.increment()\n    ...        print(num_obj)\n    ...    a_transaction.commit()\n    ...    print('-- committed')\n    ...    for i in range(3):\n    ...        num_obj.increment()\n    ...        print(num_obj)\n    ...    num_obj.value += 'x'  # will fail\n    ...    print(num_obj)\n    ... except Exception:\n    ...    a_transaction.rollback()\n    ...    print('-- rolled back')\n    <NumObj: 0>\n    <NumObj: 1>\n    <NumObj: 2>\n    -- committed\n    <NumObj: 3>\n    <NumObj: 4>\n    <NumObj: 5>\n    -- rolled back\n    >>> print(num_obj)\n    <NumObj: 2>\n    >>> print('-- now doing stuff ...')\n    -- now doing stuff ...\n    >>> try:\n    ...    num_obj.do_stuff()\n    ... except Exception:\n    ...    print('-> doing stuff failed!')\n    ...    import sys\n    ...    import traceback\n    ...    traceback.print_exc(file=sys.stdout)\n    -> doing stuff failed!\n    Traceback (most recent call last):\n    ...\n    TypeError: ...str...int...\n    >>> print(num_obj)\n    <NumObj: 2>\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod(optionflags=doctest.ELLIPSIS)\n```\n\n#### Наблюдатель (Observer)\n\nПаттерн Наблюдатель поддерживает отношения зависимости многие-ко-многим между объектами, например, когда изменяется состояние одного объекта, уведомляются все связанные с ним объекты. В наши дни, наверное самый распростарненный пример этого паттерна и его вариантов - парадигма модель-представление-контроллер (MVC). В этой парадигме модель описывает данные, одно или несколько предствалений эти данные визиалируют, а одни или несколько контроллеров осуществляют посредничество между вводом (например, взаимодействие с пользователем) и моделью. И любые изменения в модели автоматически отражаются в ассоциированных с ней представлениях.\n\nУ подхода MVC есть одно популярное упрощение - использовать только модели и представления, но поручить представлениям как визуализацию данных, так и передачу модели входных данных; иными словами, представления совмещены с контроллерами. В терминах паттерна Наблюдатель это означает, что представления - наблюдатели, а модель - наблюдаемый объект.\n\nВ качестве примеров можно назвать триггеры в базах данных, систему сигнализации Django, механизм сигналов и слотов в библиотеке QT и многочисленные применения технологии WebSockets.\n\n```python\n\"\"\"\nhttp://code.activestate.com/recipes/131499-observer-pattern/\n*TL;DR\nMaintains a list of dependents and notifies them of any state changes.\n*Examples in Python ecosystem:\nDjango Signals: https://docs.djangoproject.com/en/2.1/topics/signals/\nFlask Signals: http://flask.pocoo.org/docs/1.0/signals/\n\"\"\"\n\n\nclass Subject:\n    def __init__(self):\n        self._observers = []\n\n    def attach(self, observer):\n        if observer not in self._observers:\n            self._observers.append(observer)\n\n    def detach(self, observer):\n        try:\n            self._observers.remove(observer)\n        except ValueError:\n            pass\n\n    def notify(self, modifier=None):\n        for observer in self._observers:\n            if modifier != observer:\n                observer.update(self)\n\n\nclass Data(Subject):\n    def __init__(self, name=''):\n        Subject.__init__(self)\n        self.name = name\n        self._data = 0\n\n    @property\n    def data(self):\n        return self._data\n\n    @data.setter\n    def data(self, value):\n        self._data = value\n        self.notify()\n\n\nclass HexViewer:\n    def update(self, subject):\n        print('HexViewer: Subject {} has data 0x{:x}'.format(subject.name, subject.data))\n\n\nclass DecimalViewer:\n    def update(self, subject):\n        print('DecimalViewer: Subject %s has data %d' % (subject.name, subject.data))\n\n\ndef main():\n    \"\"\"\n    >>> data1 = Data('Data 1')\n    >>> data2 = Data('Data 2')\n    >>> view1 = DecimalViewer()\n    >>> view2 = HexViewer()\n    >>> data1.attach(view1)\n    >>> data1.attach(view2)\n    >>> data2.attach(view2)\n    >>> data2.attach(view1)\n    >>> data1.data = 10\n    DecimalViewer: Subject Data 1 has data 10\n    HexViewer: Subject Data 1 has data 0xa\n    >>> data2.data = 15\n    HexViewer: Subject Data 2 has data 0xf\n    DecimalViewer: Subject Data 2 has data 15\n    >>> data1.data = 3\n    DecimalViewer: Subject Data 1 has data 3\n    HexViewer: Subject Data 1 has data 0x3\n    >>> data2.data = 5\n    HexViewer: Subject Data 2 has data 0x5\n    DecimalViewer: Subject Data 2 has data 5\n    # Detach HexViewer from data1 and data2\n    >>> data1.detach(view2)\n    >>> data2.detach(view2)\n    >>> data1.data = 10\n    DecimalViewer: Subject Data 1 has data 10\n    >>> data2.data = 15\n    DecimalViewer: Subject Data 2 has data 15\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n```\n\n#### Состояние (State)\n\nПаттерн Состояние предназначен для создания объектов, поведение которых изменяется при изменении состояния; это означает, что у объекта есть режими работы. Извне создается впечатление, что изменился класс объекта.\n\nК обработке состояния, хранящегося внутри класса, есть два основных подхода. Первый - использование методов, чувствительных к состоянию. Второй - использование определяемых состоянием методов.\n\n```python\n\"\"\"\nImplementation of the state pattern\nhttp://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/\n*TL;DR\nImplements state as a derived class of the state pattern interface.\nImplements state transitions by invoking methods from the pattern's superclass.\n\"\"\"\n\n\nclass State:\n\n    \"\"\"Base state. This is to share functionality\"\"\"\n\n    def scan(self):\n        \"\"\"Scan the dial to the next station\"\"\"\n        self.pos += 1\n        if self.pos == len(self.stations):\n            self.pos = 0\n        print(\"Scanning... Station is {} {}\".format(self.stations[self.pos], self.name))\n\n\nclass AmState(State):\n    def __init__(self, radio):\n        self.radio = radio\n        self.stations = [\"1250\", \"1380\", \"1510\"]\n        self.pos = 0\n        self.name = \"AM\"\n\n    def toggle_amfm(self):\n        print(\"Switching to FM\")\n        self.radio.state = self.radio.fmstate\n\n\nclass FmState(State):\n    def __init__(self, radio):\n        self.radio = radio\n        self.stations = [\"81.3\", \"89.1\", \"103.9\"]\n        self.pos = 0\n        self.name = \"FM\"\n\n    def toggle_amfm(self):\n        print(\"Switching to AM\")\n        self.radio.state = self.radio.amstate\n\n\nclass Radio:\n\n    \"\"\"A radio. It has a scan button, and an AM/FM toggle switch.\"\"\"\n\n    def __init__(self):\n        \"\"\"We have an AM state and an FM state\"\"\"\n        self.amstate = AmState(self)\n        self.fmstate = FmState(self)\n        self.state = self.amstate\n\n    def toggle_amfm(self):\n        self.state.toggle_amfm()\n\n    def scan(self):\n        self.state.scan()\n\n\ndef main():\n    \"\"\"\n    >>> radio = Radio()\n    >>> actions = [radio.scan] * 2 + [radio.toggle_amfm] + [radio.scan] * 2\n    >>> actions *= 2\n    >>> for action in actions:\n    ...    action()\n    Scanning... Station is 1380 AM\n    Scanning... Station is 1510 AM\n    Switching to FM\n    Scanning... Station is 89.1 FM\n    Scanning... Station is 103.9 FM\n    Scanning... Station is 81.3 FM\n    Scanning... Station is 89.1 FM\n    Switching to AM\n    Scanning... Station is 1250 AM\n    Scanning... Station is 1380 AM\n    \"\"\"\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n```\n\nЕще пример\n\n```python\n\"\"\"\nСостояние (State) - паттерн поведения объектов.\nПозволяет объекту варьировать свое поведение в зависимости от внутреннего состояния.\nИзвне создается впечатление, что изменился класс объекта.\n\"\"\"\n\n\nclass LampStateBase(object):\n    \"\"\"Состояние лампы\"\"\"\n    def get_color(self):\n        raise NotImplementedError()\n\n\nclass GreenLampState(LampStateBase):\n    def get_color(self):\n        return 'Green'\n\n\nclass RedLampState(LampStateBase):\n    def get_color(self):\n        return 'Red'\n\n\nclass BlueLampState(LampStateBase):\n    def get_color(self):\n        return 'Blue'\n\n\nclass Lamp(object):\n    def __init__(self):\n        self._current_state = None\n        self._states = self.get_states()\n\n    def get_states(self):\n        return [GreenLampState(), RedLampState(), BlueLampState()]\n\n    def next_state(self):\n        if self._current_state is None:\n            self._current_state = self._states[0]\n        else:\n            index = self._states.index(self._current_state)\n            if index < len(self._states) - 1:\n                index += 1\n            else:\n                index = 0\n            self._current_state = self._states[index]\n        return self._current_state\n\n    def light(self):\n        state = self.next_state()\n        print state.get_color()\n\n\nlamp = Lamp()\n[lamp.light() for i in range(3)]\n# Green\n# Red\n# Blue\n[lamp.light() for i in range(3)]\n# Green\n# Red\n# Blue\n```\n\n#### Стратегия (Strategy)\n\nПаттерн Стратегия позволяет инкапсулировать набор взаимозаменяемых алгоритмов, из которых пользователь выбирает тот, что ему нужен.\n\n```python\n\"\"\"\nСтратегия (Strategy) - паттерн поведения объектов.\nОпределяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.\nСтратегия позволяет изменять алгоритмы независимо от клиентов, которые ими пользуются.\n\"\"\"\n\n\nclass ImageDecoder(object):\n    @staticmethod\n    def decode(filename):\n        raise NotImplementedError()\n\n\nclass PNGImageDecoder(ImageDecoder):\n    @staticmethod\n    def decode(filename):\n        print 'PNG decode'\n\n\nclass JPEGImageDecoder(ImageDecoder):\n    @staticmethod\n    def decode(filename):\n        print 'JPEG decode'\n\n\nclass GIFImageDecoder(ImageDecoder):\n    @staticmethod\n    def decode(filename):\n        print 'GIF decode'\n\n\nclass Image(object):\n    @classmethod\n    def open(cls, filename):\n        ext = filename.rsplit('.', 1)[-1]\n        if ext == 'png':\n            decoder = PNGImageDecoder\n        elif ext in ('jpg', 'jpeg'):\n            decoder = JPEGImageDecoder\n        elif ext == 'gif':\n            decoder = GIFImageDecoder\n        else:\n            raise RuntimeError('Невозможно декодировать файл %s' % filename)\n        byterange = decoder.decode(filename)\n        return cls(byterange, filename)\n\n    def __init__(self, byterange, filename):\n        self._byterange = byterange\n        self._filename = filename\n\n\nImage.open('picture.png')  # PNG decode\nImage.open('picture.jpg')  # JPEG decode\nImage.open('picture.gif')  # GIF decode\n```\n\nЕще пример\n\n```python\n\"\"\"\n*What is this pattern about?\nDefine a family of algorithms, encapsulate each one, and make them interchangeable.\nStrategy lets the algorithm vary independently from clients that use it.\n*TL;DR\nEnables selecting an algorithm at runtime.\n\"\"\"\n\n\nclass Order:\n    def __init__(self, price, discount_strategy=None):\n        self.price = price\n        self.discount_strategy = discount_strategy\n\n    def price_after_discount(self):\n        if self.discount_strategy:\n            discount = self.discount_strategy(self)\n        else:\n            discount = 0\n        return self.price - discount\n\n    def __repr__(self):\n        fmt = \"<Price: {}, price after discount: {}>\"\n        return fmt.format(self.price, self.price_after_discount())\n\n\ndef ten_percent_discount(order):\n    return order.price * 0.10\n\n\ndef on_sale_discount(order):\n    return order.price * 0.25 + 20\n\n\ndef main():\n    \"\"\"\n    >>> Order(100)\n    <Price: 100, price after discount: 100>\n    >>> Order(100, discount_strategy=ten_percent_discount)\n    <Price: 100, price after discount: 90.0>\n    >>> Order(1000, discount_strategy=on_sale_discount)\n    <Price: 1000, price after discount: 730.0>\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n```\n\n#### Шаблонный метод (Template method)\n\nПаттерн Шаблонный метод позволяет определить шаги алгоритма, оставив реализацию некоторых шагов подклассам.\n\nПаттерн Шаблонный метод в некоторых отношениях похож на паттерн Мост.\n\n```python\n\"\"\"\nШаблонный метод (Template method) - паттерн поведения классов.\nШаблонный метод определяет основу алгоритма и позволяет подклассам переопределить некоторые шаги алгоритма,\nне изменяя его структуру в целом.\n\"\"\"\n\n\nclass ExampleBase(object):\n    def template_method(self):\n        self.step_one()\n        self.step_two()\n        self.step_three()\n\n    def step_one(self):\n        raise NotImplementedError()\n\n    def step_two(self):\n        raise NotImplementedError()\n\n    def step_three(self):\n        raise NotImplementedError()\n\n\nclass Example(ExampleBase):\n    def step_one(self):\n        print 'Первый шаг алгоритма'\n\n    def step_two(self):\n        print 'Второй шаг алгоритма'\n\n    def step_three(self):\n        print 'Третий шаг алгоритма'\n\n\nexample = Example()\nexample.template_method()\n\n# Первый шаг алгоритма\n# Второй шаг алгоритма\n# Третий шаг алгоритма\n```\n\nЕще пример\n\n```python\n\"\"\"\nAn example of the Template pattern in Python\n*TL;DR\nDefines the skeleton of a base algorithm, deferring definition of exact\nsteps to subclasses.\n*Examples in Python ecosystem:\nDjango class based views: https://docs.djangoproject.com/en/2.1/topics/class-based-views/\n\"\"\"\n\n\ndef get_text():\n    return \"plain-text\"\n\n\ndef get_pdf():\n    return \"pdf\"\n\n\ndef get_csv():\n    return \"csv\"\n\n\ndef convert_to_text(data):\n    print(\"[CONVERT]\")\n    return \"{} as text\".format(data)\n\n\ndef saver():\n    print(\"[SAVE]\")\n\n\ndef template_function(getter, converter=False, to_save=False):\n    data = getter()\n    print(\"Got `{}`\".format(data))\n\n    if len(data) <= 3 and converter:\n        data = converter(data)\n    else:\n        print(\"Skip conversion\")\n\n    if to_save:\n        saver()\n\n    print(\"`{}` was processed\".format(data))\n\n\ndef main():\n    \"\"\"\n    >>> template_function(get_text, to_save=True)\n    Got `plain-text`\n    Skip conversion\n    [SAVE]\n    `plain-text` was processed\n    >>> template_function(get_pdf, converter=convert_to_text)\n    Got `pdf`\n    [CONVERT]\n    `pdf as text` was processed\n    >>> template_function(get_csv, to_save=True)\n    Got `csv`\n    Skip conversion\n    [SAVE]\n    `csv` was processed\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n```\n\n#### Посетитель (Visitor)\n\nПаттерн Посетитель используется, когда нужно применить некую функцию к каждому элементу коллекции или объекту-агрегатору. Это не то же самое, что типичное использование паттерна Итератор - где мы обходим коллекцию или агрегат и вызываем некий метод для каждого элемента, - поскольку в случае \"посетителя\" вызывается внешнняя функция, а не метод.\n\nВ Python имеется встроенная поддержва этого паттерна. Например конструкция `new_list = map(function, old_sequence)` означает, что `function()` вызывается для каждого элемента `old_sequence`, в результате чего порождается `new_list`\n\n```python\n\"\"\"\nПостетитель (Visitor) - паттерн поведения объектов.\nОписывает операцию, выполняемую с каждым объектом из некоторой структуры.\nПаттерн посетитель позволяет определить новую операцию, не изменяя классы этих объектов.\n\"\"\"\n\n\nclass FruitVisitor(object):\n    \"\"\"Посетитель\"\"\"\n    def draw(self, fruit):\n        methods = {\n            Apple: self.draw_apple,\n            Pear: self.draw_pear,\n        }\n        draw = methods.get(type(fruit), self.draw_unknown)\n        draw(fruit)\n\n    def draw_apple(self, fruit):\n        print 'Яблоко'\n\n    def draw_pear(self, fruit):\n        print 'Груша'\n\n    def draw_unknown(self, fruit):\n        print 'Фрукт'\n\n\nclass Fruit(object):\n    \"\"\"Фрукты\"\"\"\n    def draw(self, visitor):\n        visitor.draw(self)\n\n\nclass Apple(Fruit):\n    \"\"\"Яблоко\"\"\"\n\n\nclass Pear(Fruit):\n    \"\"\"Груша\"\"\"\n\n\nclass Banana(Fruit):\n    \"\"\"Банан\"\"\"\n\n\nvisitor = FruitVisitor()\n\napple = Apple()\napple.draw(visitor)\n# Яблоко\n\npear = Pear()\npear.draw(visitor)\n# Груша\n\nbanana = Banana()\nbanana.draw(visitor)\n# Фрукт\n```\n\nЕще пример\n\n```python\n\"\"\"\nhttp://peter-hoffmann.com/2010/extrinsic-visitor-pattern-python-inheritance.html\n*TL;DR\nSeparates an algorithm from an object structure on which it operates.\nAn interesting recipe could be found in\nBrian Jones, David Beazley \"Python Cookbook\" (2013):\n- \"8.21. Implementing the Visitor Pattern\"\n- \"8.22. Implementing the Visitor Pattern Without Recursion\"\n*Examples in Python ecosystem:\n- Python's ast.NodeVisitor: https://github.com/python/cpython/blob/master/Lib/ast.py#L250\nwhich is then being used e.g. in tools like `pyflakes`.\n- `Black` formatter tool implements it's own: https://github.com/ambv/black/blob/master/black.py#L718\n\"\"\"\n\n\nclass Node:\n    pass\n\n\nclass A(Node):\n    pass\n\n\nclass B(Node):\n    pass\n\n\nclass C(A, B):\n    pass\n\n\nclass Visitor:\n    def visit(self, node, *args, **kwargs):\n        meth = None\n        for cls in node.__class__.__mro__:\n            meth_name = 'visit_' + cls.__name__\n            meth = getattr(self, meth_name, None)\n            if meth:\n                break\n\n        if not meth:\n            meth = self.generic_visit\n        return meth(node, *args, **kwargs)\n\n    def generic_visit(self, node, *args, **kwargs):\n        print('generic_visit ' + node.__class__.__name__)\n\n    def visit_B(self, node, *args, **kwargs):\n        print('visit_B ' + node.__class__.__name__)\n\n\ndef main():\n    \"\"\"\n    >>> a, b, c = A(), B(), C()\n    >>> visitor = Visitor()\n    >>> visitor.visit(a)\n    generic_visit A\n    >>> visitor.visit(b)\n    visit_B B\n    >>> visitor.visit(c)\n    visit_B C\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n```\n\n#### Поведенческие паттерны. Итог\n\nДля некоторых поведенческих паттернов в Python имеется прямая поддержка; остальные нетрудно реализовать самостоятельно. Паттерны Цепочка ответственности, Посредник и Наблюдатель можно реализовать традиционным способом или с помощью сопрограмм, и все они являются вариациями на тему разрыва связи между взаимодействующими объектами. Паттерн Команда можно использовать для отложенного вычисления и реализации механизма выполнения-отмена. Поскольку Python - интерпретируемый язык (на уровне байт-кода), то паттерн Интерпретатор можно реализовать с помощью самого Python и даже изолировать интерпретируемый код в отдельном процессе. Поддержка паттерна Итератор (и - неявно - паттерна посетитель) встроена в Python. Паттерн Хранитель неплохо поддержан в стандартной библиотеке Python (например, с помощью модулей `pickle` и `json`). У паттернов Состояние, Стратегия и Шаблонный метод прямой поддержки нет, но все они легко реализуются.\n\n## Что такое lru cache\n\n- [LRU, метод вытеснения из кэша](https://habr.com/ru/post/136758/)\n\nLRU (least recently used) — это алгоритм, при котором вытесняются значения, которые дольше всего не запрашивались. Соответственно, необходимо хранить время последнего запроса к значению. И как только число закэшированных значений превосходит N необходимо вытеснить из кеша значение, которое дольше всего не запрашивалось.\n\n## Что такое MQ\n\nОчереди сообщений, по существу, являются связующим звеном между различными процессами в ваших приложениях и обеспечивают надежный и масштабируемый интерфейс взаимодействия с другими подключенными системами и устройствами.\nО́чередь — структура данных с дисциплиной доступа к элементам «первый пришёл — первый вышел». Добавление элемента возможно лишь в конец очереди, выборка — только из начала очереди, при этом выбранный элемент из очереди удаляется.\n\nДесять причин, почему очереди сообщений являются жизненно важным компонентом для любой архитектуры или приложения:\n\n- *Слабое связывание* — очереди сообщений создают неявные интерфейсы обмена данными, которые позволяют процессам быть независимыми друг от друга т.е вы просто определяете формат сообщений отправляемых от одного процесса другому.\n- *Избыточность* — Очереди позволяют избежать случаев неэкономного использования ресурсов процесса(например памяти) в результате хранения необработанной (лишней) информации.\n- *Масштабируемость* — очереди сообщений позволяют распределить процессы обработки информации. Таким образом, они позволяют легко наращивать скорость, с которой сообщения добавляются в очередь и обрабатываются.\n- *Эластичность и возможность выдерживать пиковые нагрузки* — очереди сообщений могут выполнять роль своего рода буфера для накопления данных в случае пиковой нагрузки, смягчая тем самым нагрузку на систему обработки информации и не допуская ее отказа.\n- *Отказоустойчивость* — очереди сообщений позволяют отделить процессы друг от друга, так что если процесс, который обрабатывает сообщения из очереди падает, то сообщения могут быть добавлены в очередь на обработку позднее, когда система восстановится.\n- *Гарантированная доставка* — использование очереди сообщений гарантирует, что сообщение будет доставлено и обработано в любом случае (пока есть хотя бы один обработчик).\n- *Гарантированный порядок доставки* — большая часть систем очередей сообщений способны обеспечить гарантии того, что данные будут обрабатываться в определённом порядке (чаще всего в том порядке в котором они поступили).\n- *Буферизация* — очереди сообщений позволяет отправлять и получать сообщения при этом работая с максимальной эффективностью, предлагая буферный слой — процесс записи в очередь может происходить настолько быстро, насколько быстро это в состоянии выполнить очередь сообщений, а не обработчик сообщения.\n- *Понимание потоков данных* — очереди сообщений позволяют выявлять узкие места в потоках данных приложения, легко можно определить какая из очередей забивается, какая простаивает и определить что необходимо делать — добавлять новых обработчиков сообщений или оптимизировать текущую архитектуру.\n- *Асинхронная связь* — очереди сообщений предоставляют возможность асинхронной обработки данных, которая позволяет поместить сообщение в очередь без обработки, позволяя системе обработать сообщение позднее, когда появится возможность.\n\n## Какие готовые реализации MQ вы знаете\n\n- [Message middleware deployment and comparison: rabbitMQ, activeMQ, zeroMQ, rocketMQ, Kafka, redis](http://www.programmersought.com/article/3359645442/)\n- [RabbitMQ против Kafka: два разных подхода к обмену сообщениями](https://habr.com/ru/company/itsumma/blog/416629/)\n- [Kafka VS RabbitMQ](https://medium.com/@vozerov/kafka-vs-rabbitmq-38e221cf511b)\n- [Выбор MQ для высоконагруженного проекта](https://habr.com/ru/post/326880/)\n\n\n- ActiveMQ\n- RabbitMQ\n- RedisQueue\n- Kafka\n- rocketMQ\n- zeroMQ\n\n## Что такое RPC\n\nУдалённый вызов процедур, реже Вызов удалённых процедур (от англ. Remote Procedure Call, RPC) — класс технологий, позволяющих компьютерным программам вызывать функции или процедуры в другом адресном пространстве (на удалённых компьютерах, либо в независимой сторонней системе на том же устройстве). Обычно реализация RPC-технологии включает в себя два компонента: сетевой протокол для обмена в режиме клиент-сервер и язык сериализации объектов (или структур, для необъектных RPC). На транспортном уровне RPC используют в основном протоколы TCP и UDP, однако, некоторые построены на основе HTTP (что нарушает архитектуру ISO/OSI, так как HTTP — изначально не транспортный протокол).\n\nХарактерными чертами вызова удалённых процедур являются:\n\n- Асимметричность, то есть одна из взаимодействующих сторон является инициатором;\n- Синхронность, то есть выполнение вызывающей процедуры приостанавливается с момента выдачи запроса и возобновляется только после возврата из вызываемой процедуры.\n\n## Что такое gPRC\n\n- [gRPC — фреймворк от Google для удалённого вызова процедур](https://habr.com/ru/company/infopulse/blog/265805/)\n- [Введение в gRPC](https://blog.maddevs.io/introduction-to-grpc-6de0d9c0fe61)\n- [gRPC в качестве протокола межсервисного взаимодействия. Доклад Яндекса](https://habr.com/ru/company/yandex/blog/484068/)\n- [Python Microservices With gRPC](https://realpython.com/python-microservices-grpc/)\n\ngRPC — это высокопроизводительный фреймворк разработанный компанией Google для вызов удаленных процедур (RPC), работает поверх HTTP/2.\ngRPC простой в использовании, отлично подходит для создания распределенных систем (микросервисов) и API. Имеет встроенную поддержку для балансировки нагрузки, трассировки, аутентификации и проверки жизнеспособности сервисов. Есть возможность создавать клиентские библиотеки для работы с бэкендом на 10 языках. Высокая производительность достигается за счет использования протокола HTTP/2 и Protocol Buffers.\n\nИз коробки имеет:\n\n- Protobuf в качестве инструмента описания типов данных и сериализации. Очень классная и хорошо зарекомендовавшая себя на практике штука. Собственно говоря, те, кому была нужна производительность — и раньше брали Protobuf, а дальше уже отдельно заморачивались транспортом. Теперь всё в комплекте.\n- HTTP/2 в качестве транспорта. И это невероятно мощный ход! Вся прелесть полного сжатия данных, контроля трафика, инициации событий с сервера, переиспользования одного cокета для нескольких параллельных запросов — красотища.\n- Статические пути — никаких больше «сервис/коллекция/ресурс/запрос? параметр=значение». Теперь только «сервис», а что внутри — описывайте в терминах вашей модели и её событий.\n- Никакого привязывания методов к HTTP-методам, никакого привязывания возвращаемых значений к HTTP-статусам. Пишите, что хотите.\n- SSL/TLS, OAuth 2.0, аутентификация через сервисы Google, плюс можно прикрутить свою (например, двухфакторную)\n- Поддержка 9-ти языков: C, C++, Java, Go, Node.js, Python, Ruby, Objective-C, PHP, C# плюс, конечно, никто не запрещает взять и реализовать свою версию хоть для брейнфака.\n- Поддержка gRPC в публичных API от Google. Уже работает для некоторых сервисов. Нет, REST-версии, конечно, тоже останутся. Но посудите сами, если у вас будет выбор — использовать, скажем, из мобильного приложения REST-версию, отдающие данные за 1 сек или с теми же затратами на разработку взять gRPC-версию, работающую 0.5 сек — что вы выберете? А что выберет ваш конкурент?\n\n# Алгоритмы, структуры\n\n\"Грокаем алгоритмы. Адитья Бхаргава\"\n\n## Что такое рекурсия. Какие минусы, плюсы\n\nРекурсия – когда функция вызывает саму себя. Логика рекурсивной функции как правило состоит из двух ветвей. Длинная ветвь вызывает эту же функцию с другими параметрами, чтобы накопить результат. Короткая ветвь определяет критерий выхода из рекурсии.\n\nРекурсия, **в некоторых случаях**, упрощает код и делает его декларативным. Рекурсия поощряет мыслить функционально и избегать побочных эффектов.\n\nНеоптимизированная рекурсия приводит к накладным расходам ресурсов. При большом количестве итераций можно превысить лимит на число рекурсивных вызовов (recursion depth limit reached), но при возникновении такой необходимости скорее всего вы делаете что-то не так и лучше присмотритесь к другим инструментам (стэк, например).\n\n## Что такое хвостовая рекурсия\n\nЭто особый вид рекурсии, когда функция заканчивается вызовом самой себя без дополнительных операторов. Когда это условие выполняется, компилятор разворачивает рекурсию в цикл с одним стек-фреймом, просто меняя локальные переменные от итерации к итерации.\n\nТак, классическое определение рекурсивного факториала `return N * fact(N - 1)` не поддерживает хвостовую рекурсию, потому что для каждого стек-фрейма придется хранить текущее значение `N`.\n\nЧтобы сделать рекурсии хвостовой, добавляют параметры-аккумуляторы. Благодаря им функция знает о своем текущем состоянии. Пусть параметр `acc` по умолчанию равен 1. Тогда запись с хвостовой рекурсией будет выглядеть так:\n\n```python\ndef fact(N, acc=1):\n    if N == 1:\n        return acc\n    else:\n        return fact(N - 1, acc * N)\n```\n\n## Как можно оптимизировать хвостовую рекурсию в Python\n\n- [Python — оптимизация хвостовой рекурсии](https://habr.com/ru/post/158385/)\n- [Устранение Хвостовой рекурсии](https://habr.com/ru/post/111768/)\n\n```python\nclass recursion(object):\n    \"Can call other methods inside...\"\n    def __init__(self, func):\n        self.func = func\n\n    def __call__(self, *args, **kwargs):\n        result = self.func(*args, **kwargs)\n        while callable(result): result = result()\n        return result\n\n    def call(self, *args, **kwargs):\n        return lambda: self.func(*args, **kwargs)\n\n\n@recursion\ndef sum_natural(x, result=0):\n    if x == 0:\n        return result\n    else:\n        return sum_natural.call(x - 1, result + x)\n\n# Даже такой вызов не заканчивается исключением\n# RuntimeError: maximum recursion depth exceeded\nprint(sum_natural(1000000))\n```\n\n## О-большое при оценке сложности\n\nО-большое описывает скорость работы алгоритма (не время).\n\n## Простой поиск\n\nО(n).\n\n## Бинарный поиск\n\nO(log n): работает только с отсортированным массивом. Берем средний элемент и проверяем не тот ли это элемент что мы ищем, если нет и он меньше чем тот который мы ищем - отбрасываем половину с меньшими значениями (если больше, то с большими) и повторяем пока не найдем искомый элемент.\n\n```python\ndef binary_search(list, item):\n  # low and high keep track of which part of the list you'll search in.\n  low = 0\n  high = len(list) - 1\n\n  # While you haven't narrowed it down to one element ...\n  while low <= high:\n    # ... check the middle element\n    mid = (low + high) // 2\n    guess = list[mid]\n    # Found the item.\n    if guess == item:\n      return mid\n    # The guess was too high.\n    if guess > item:\n      high = mid - 1\n    # The guess was too low.\n    else:\n      low = mid + 1\n\n  # Item doesn't exist\n  return None\n\nmy_list = [1, 3, 5, 7, 9]\nprint(binary_search(my_list, 3)) # => 1\n\n# 'None' means nil in Python. We use to indicate that the item wasn't found.\nprint(binary_search(my_list, -1)) # => None\n```\n\n## Рекурсивные алгоритмы\n\nДолжны иметь базовый и рекурсивный случай. Если рекурсивный алгоритм не будет иметь базового случая, он будет выполняться вечно, так как не будет условия при котором нужно вернуть управление.\n\n## Быстрая сортировка\n\nНа первом этапе выбирают опорный элемент. Чаще всего его берут из середины массива. Затем последовательно сравнивают первый элемент массива с последним, второй с предпоследним и т.д. Если элемент слева от опорного элемента больше правого, они меняются местами. Когда доходят до опорного элемента, итерация считается законченной.\n\nДалее описанный выше алгоритм применяют для двух подмассивов. Первый – от первого элемента до опорного элемента (не включительно), второй – от опорного до последнего.\n\nРекурсивный спуск продолжается, пока длины подмассивов не станут равны единице.\n\nСложность быстрой сортировки в среднем случае равна `N * log(N)`.\n\nO(n * log n) (средний и лучший случай), O(n^2) в худшем. Скорость зависит от выбора опорного элемента - в большистве случаев выполняется за среднее время.\nБазовый случай - в массиве 0 или 1 элемент, тогда он уже отсортирован.\n\nАлгоритм:\n\n- Выбрать опорный элемент\n- Разделить массив на два подмассива - с элементами меньше и больше опорного\n- Рекурсивно применять быструю сортировку к двум подмассивам\n\n*Доказательство по индукции:*\n\n```python\ndef quicksort(array):\n  if len(array) < 2:\n    # base case, arrays with 0 or 1 element are already \"sorted\"\n    return array\n  else:\n    # recursive case\n    pivot = array[0]\n    # sub-array of all the elements less than the pivot\n    less = [i for i in array[1:] if i <= pivot]\n    # sub-array of all the elements greater than the pivot\n    greater = [i for i in array[1:] if i > pivot]\n    return quicksort(less) + [pivot] + quicksort(greater)\n\nprint(quicksort([10, 5, 2, 3]))\n```\n\n## Граф\n\nМоделирует набор связей. Они состоят из узлов и ребер. Узлы напрямую соединенные с другими узлами называются соседями.\n\nБывают направленные и ненаправленные, взвешенные и невзвешенные.\n\nВ направленном графе есть стрелки, а отношения действуют в направлении стрелки (А -> Б, значит Б - сосед А, а А - родитель Б)\n\nВ ненаправленном графе стрелок нет, а отношение идет в обе стороны\n\n## Очередь и стек\n\nОчередь FIFO (first in first out), стрек LIFO (last in first out)\n\n## Дерево\n\nОсобая разновидность графа, в котором нет ребер, которые указывают в обратном направлении\n\n## Поиск в ширину\n\nO(V + E), где V - количество вершин, E - количество ребер, работает с графами и помогает ответить на вопросы двух типов:\n\n- Существует ли путь от узла А к узлу Б?\n- Как выглядит кратчайший путь от узла А к узлу Б?\n\n*Алгоритм:*\n\n- Поместить узел, с которого начинается поиск, в изначально пустую очередь.\n- Извлечь из начала очереди узел u и пометить его как развёрнутый.\n- Если узел u является целевым узлом, то завершить поиск с результатом «успех».\n- В противном случае, в конец очереди добавляются все преемники узла u, которые ещё не развёрнуты и не находятся в очереди.\n- Если очередь пуста, то все узлы связного графа были просмотрены, следовательно, целевой узел недостижим из начального; завершить поиск с результатом «неудача».\n- Вернуться к п. 2.\n\nИспользуется для нахождения кратчайшего пути в невзвешенном графе\n\n## Алгоритм Дейкстры\n\nИспользуется для нахождения пути с наименьшим весом в взвешенном графе\nРаботает только в направленных ациклических графах (DAG - Directed Acyclic Graph)\n\nСостоит из 4 шагов:\n\n- Найти узел с наименьшей стоимостью\n- Обновить стоимость соседей этого узла\n- Повторять пока это не будет сделано для всех узлов\n- Вычислить итоговый путь\n\nНе работает с отрицательными весами - для графов с отрицательными весами сущестувет специальный алгоритм, называемый *алгоритмом Беллмана-Форда*\n\n## Жадные алгоритмы\n\nИспользуются когда вычисление точного решения занимает слишком много времени или когда высокая точность не требуется. Эффективность приближенного алгоритма оценивается по:\n\n- быстроте\n- близости полученного решения к оптимальному\n\nЖадные алгоритмы хороши не только тем что они обычно легко формулируются, но и тем что простота обычно оборачивается быстротой выполнения.\n\nЖадные алгоритмы стремятся к локальной оптимизации в расчете на то что в итоге будет достигнут глобальный оптимум\n\nЖадные алгоритмы легко реализуются и быстро выполняются, поэтому из них получаются хорошие приближенные алгоритмы\n\n## Как распознать NP-полную задачу\n\nНе существует простого способа это сделать, но есть ряд признаков:\n\n- ваш алгоритм быстро работает при малом количестве элементов, но сильно замедляется при увеличении их числа;\n- формулировка ~все комбинации х~ часто указывает на NР-полноту задачи;\n- вам приходится вычислять все возможные варианты Х, потому что задачу невозможно разбить на меньшие подзадачи? Такая задача может оказаться NР-полной;\n- если в задаче встречается некоторая последовательность (например, последовательность городов, как в задаче о коммивояжере) и задача не имеет простого решения, она может оказаться NР-полной;\n- если в задаче встречается некоторое множество (например, множество радиостанций) и задача не имеет простого решения, она может оказаться NР-полной;\n- можно ли переформулировать задачу в условиях задачи покрытия множества или задачи о коммивояжере? В таком случае ваша задача определенно является NР-полной.\n\nУ NP-полных задач не бывает известных быстрых решений\nЕсли у вас имеется NP-полная задача лучше воспользоваться приближенным алгоритмом\n\n## Динамическое программирование\n\nПрименяется для оптимизации некоторой характиристики, например положить в рюкзак вещей на наибольшую сумму, или найти самую длинную подстроку в двух словах и тд.\n\nРаботает только в ситуациях когда задача может быть разбита на автономные подзадачи\n\nВ каждом решении из области динамического программирования строится таблица (!)\nЗначения ячеек таблицы обычно соответствует оптимизируемой характеристике (цена вещей, их важность, количество повторений букв и тд)\n\nНе существует единой формулы для вычисления решений методом динамического программирования\n\n## Алгоритм k ближайших соседей\n\nПрименяется для классификации и регрессии. В нем используется проверка k ближайших соседей\n\nКлассификация - распределение по категориям\n\nРегрессия - прогнозирование результата (например, в виде числа)\nИзвлечением признаком называется преобразование элемента (например фрукта или пользователя) в список чисел, которые могут использоваться для сравнения\nКачественный выбор признаков очень важен\nИспользуется в машинном обучении, построении рекомендательных систем, прогнозировании и тд\n\nДля вычисления расстояния до соседа используется формула Пифагора (`sqrt((x1 - x2)^2 + (y1 - y2)^2)`) или метрика близости косинусов. Метрика близости косинусов не измеряет расстояние между двумя векторами, вместо этого она сравнивает углы двух векторов.\n\n## Алгоритм Ричарда Фейнмана\n\n- Записать формулировку задачи\n- Хорошенько подумать\n- Записать решение\n\n# Frontend\n\n## Что такое куки. Зачем они, как с ними работать и где они сохраняются\n\nКуки являются информацией, сохраняемой на компьютере веб-сайтом. Куки часто хранят настройки для веб-сайта, например предпочитаемый язык или местоположение. При возвращении на сайт, браузер отправляет обратно куки, которые принадлежат этому сайту. Это позволяет сайту запоминать информацию о предыдущих посещениях.\n\nDjango использует куки чтобы хранить идентификатор сессии (или позволяет настроить проект чтобы хранить сессию в куках)\n\nКуки хранятся в браузере.\n\nС ними можно работать как из Django (request.COOKIES, response.st_cookie) так и из JavaScript (document.cookie) (если не установлен флаг HTTPONLY).\n\n## Может ли сервер изменить (добавить, удалить) куки\n\nДа. Значение куки может быть изменено сервером путём отправления новых строк Set-Cookie: name=newvalue. После этого браузер заменяет старое куки с тем же name на новую строку.\n\n## Что такое JWT (JSON Web Token)\n\n- [JWT простым языком: что такое JSON токены и зачем они нужны](https://proglib.io/p/json-tokens/)\n\nВеб-токен JSON, или JWT (произносится «jot»), представляет собой стандартизированный, в некоторых случаях подписанный и/или зашифрованный формат упаковки данных, который используется для безопасной передачи информации между двумя сторонами.\n\nJWT определяет особую структуру информации, которая отправляется по сети. Она представлена в двух формах – сериализованной и десериализованной. Первая используется непосредственно для передачи данных с запросами и ответами. С другой стороны, чтобы читать и записывать информацию в токен, нужна его десериализация.\n\n# SDLC\n\n## Agile/Scrum\n\n- [Agile/Scrum. Все что необходимо знать](https://www.slideshare.net/ssuser2ea1b3/agilescrum-72029120)\n\n## Какая разница между CI и CD\n\n- [Непрерывная интеграция, непрерывная доставка, непрерывное развертывание: просто матрешка](https://habr.com/ru/company/piter/blog/343270/)\n\n**Continuous integration (непрерывная интеграция)**\nНепрерывной интеграция заключается в следующем: все изменения, вносимые в код, объединяются в центральном репозитории (операция называется «слияние»). Слияние происходит несколько раз в день, и после каждого слияния в конкретном проекте срабатывает автоматическая сборка и тестирование.\n\nБывает, что перед сборкой и тестированием программу требуется скомпилировать (это зависит от языка, на котором она написана). Сегодня все чаще возникает необходимость упаковать приложение в контейнер Docker. Затем автоматические тесты проверяют конкретные модули кода, работу UI, производительность приложения, надежность API и пр. Все эти этапы в совокупности обычно называют «сборкой».\n\nCI – это своеобразная страховочная сетка, позволяющая разработчикам избежать массы проблем перед сдачей проекта.\n\n**Continuous delivery (непрерывная доставка)**\nНепрерывная доставка – это практика автоматизации всего процесса релиза ПО. Идея заключается в том, чтобы выполнять CI, плюс автоматически готовить и вести релиз к продакшену. При этом желательно добиться следующего: любой, кто обладает достаточными привилегиями для развертывания нового релиза может выполнить развертывание в любой момент, и это можно сделать в несколько кликов. Программист, избавившись практически от всей ручной работы, трудится продуктивнее.\n\nКак правило, в процессе непрерывной доставки требуется выполнять вручную как минимум один этап: одобрить развертывание в продакшен и запустить его. В сложных системах с множеством зависимостей конвейер непрерывной доставки может включать дополнительные этапы, выполняемые вручную либо автоматически.\n\n**Continuous deployment(непрерывное развёртываение)**\nНепрерывное развертывание располагается «на уровень выше» непрерывной доставки. В данном случае все изменения, вносимые в исходный код, автоматически развертываются в продакшен, без явной отмашки от разработчика. Как правило, задача разработчика сводится к проверке запроса на включение (pull request) от коллеги и к информированию команды о результатах всех важных событий.\n\nНепрерывное развертывание требует, чтобы в команде существовала отлаженная культура мониторинга, все умели держать руку на пульсе и быстро восстанавливать систему.\n\nРазработчики, практикующие CI и желающие перейти к непрерывному развертыванию, для начала автоматизируют развертывание в обкаточную среду, а развертывание в продакшен продолжают делать вручную – одним кликом.\n\n**Резюме:**\n\n- Непрерывная интеграция (CI): короткоживущие функциональные ветки, команда сливает их с основной веткой разработки по несколько раз в день, процессы сборки и тестирования полностью автоматизированы, результат имеем в пределах 10 минут; развертывание выполняется вручную.\n- Непрерывная доставка (CD): автоматизируется CI + весь процесс релиза ПО. Может состоять из нескольких этапов. Развертывание в продакшен выполняется вручную.\n- Непрерывное развертывание: CI + CD + полностью автоматизированное развертывание в продакшен.\n\n## Какая разница между Scrum и Kanban\n\n- [Scrum vs Kanban: в чем разница и что выбрать?](https://habr.com/ru/company/hygger/blog/351048/)\n\nScrum и Kanban — представители методологий Agile-семейства. Обе считаются гибкими и итеративными.\n\nБолее 17 лет назад лидеры IT-разработки сформулировали манифест Agile. Главное, что можем выделить из манифеста:\n\n- Люди и взаимодействие важнее процессов и инструментов.\n- Работающий продукт важнее исчерпывающей документации.\n- Сотрудничество с заказчиком важнее согласования условий контракта.\n- Готовность к изменениям важнее следования первоначальному плану.\n\nОснову **Scrum** составляют короткие итерации или спринты, как правило, 2-3-х недельные. Перед началом спринта команда сама формирует список фич на итерацию, далее запускается спринт.\n\nПосле окончания спринта выполненные фичи заливаются на продакшн, а невыполненные — переносятся в другой спринт. Как правило, фичи, которые делаются во время спринта, не меняются: что было на старте спринта — должно быть сделано любой ценой к окончанию спринта.\n\n**Kanban** дает больше гибкости, если под гибкостью понимать частоту смены приоритетов. Вчера вы залили на прод новую фичу, а сегодня получили данные с передовой и узнали, что вот эта штука не работает так, как было задумано — люди не нажимают кнопку «купить». Вы «даете по шапке» UX, он дает вам новые требования. Вы поднимаете наверх очереди эту задачу, программист берет эту задачу «сверху», выполняет ее и, к вечеру fix уже на проде, конверсия в платежи выросли на 12%. Это победа.\n\n**Основная разница между Scrum и Канбан — в длине итераций. В Scrum итерации — 2 недели, в Kanban задачи программисту можно «подсовывать» хоть каждый день.**\n\nВ **Scrum** задачи принято оценивать в Story points или в часах. Без оценки не получится сформировать спринт: ведь нам нужно знать, успеем ли мы сделать задачи за 2 недели. Через 2 недели мы получаем ценную статистику — сколько часов или Story points команда смогла сделать за спринт. Velocity — это производительность команды за один спринт. Этот параметр позволяет Scrum менеджеру предсказать, где команда будет через 2 недели.\n\nВ **Kanban** не принято делать оценку. Это опционально, команда решает сама. Здесь нет понятия «скорость работы команды», считается только среднее время на задачу. Время это считается с помощью специального отчета — Cycle Time.\n\n**Итак, в Scrum наша цель — закончить спринт, в Kanban — задачу.**\n\nScrum — это автобус, который останавливается лишь на определенных остановках, где люди выходят группами. А Kanban — это маршрутка: захотел пассажир выйти, попросил водителя и вышел там, где ему нужно.\n\n## Вопрос для тим-лидов: что Вы будете делать, если на проекте нет тестов и заказчик не хочет тратить на их разработку время и деньги\n\nАпелировать к прибыльности для бизнеса заказчика.\n\n## Что такое Code Debt и как с ним быть\n\nВ классическом понимании, т.е. в том виде, в котором эта метафора была описана Вардом Каннингемом, под техническим долгом понимается осознанное компромиссное решение, когда заказчик и ключевые разработчики четко понимают все преимущества от быстрого, пусть и не идеального технического решения, за которое придется расплатиться позднее. И хотя с точки зрения многих разработчиков ситуация, когда плохое решение может быть хорошим, может показаться безумной, на самом деле, это вполне возможно: если краткосрочное решение позволит компании получить видимые преимущества, выпустить продукт раньше конкурентов, удовлетворить ключевого заказчика или каким-то другим образом получить преимущества перед конкурентами, тогда такое решение совершенно оправданно. Иногда это может быть единственным способом, чтобы долгосрочная перспектива вообще существовала.\n\nТехнический долг в классическом понимании является преднамеренным и в основном касается стратегических решений, поэтому и ответственность за него лежит на заказчиках, матерых лидах, архитекторах и даже ПМ-ах, но вот все, что связано с грязным кодом касается по большей части простых разработчиков. На самом деле, разница между грязным кодом и неоптимальным стратегическим решением, по сути, не такая уж и большая: при добавлении новой возможности в систему вам приходится расплачиваться за недальновидность в прошлом.\n\nВыплачивать проценты по техдолгу легче, если начать задумываться об этом на этапе создания продукта.\n\n- Делайте одноразовые прототипы MVP и только подтвержденные гипотезы включайте в работу.\n- Создавайте архитектуру, которую будет просто изменить: микросервисы, API с версионированием.\n- Откажитесь от организации собственных серверных в пользу облачных решений. Например, Microsoft Azure, AWS Amazon Cloud, «Яндекс.Облако», облако от Mail.ru и так далее.\n- Установите в команде четкий definition of done, включающий в том числе метрики качества. Очень помогает включить в DOD пункт, исключающий «приемку» фичи, если есть связанные с ней баги.\n- Для MVP хорошо проектировать систему так, чтобы миграция пользователей с прототипов на стабильную часть была незаметной.\n\nКомпании справляются с техдолгом по-разному. Основных стратегий три.\n\n- Переписывают все с нуля. Это ультимативный способ поддерживать систему в состоянии, когда она постоянно готова к изменениям, если все зашло слишком далеко и уже нет прежней гибкости.\n- Делают постепенный рефакторинг. Задачи по техдолгу отправляются в бэклог наравне с продуктовыми задачами. Это замедляет работу по выкатке новых фич, но бизнес обычно идет на компромиссы.\n- Смиряются с техдолгом. Если у вас не стартап, а обновления нужны раз в полгода, то можно просто смириться с тем, что код неоптимален, и действовать по принципу «работает — не трогай». Как только поймете, что ошиблись, вы так или иначе переместитесь к пункту 1.\n\n# VCS\n\n- [Git - Book](https://git-scm.com/book/ru/v2)\n\n## Что такое Git Flow\n\n- [Gitflow Workflowl](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow)\n- [Read Git Flow](https://leanpub.com/git-flow/read)\n\n**Historical Branches**\nВместо использования только одной master ветки, этот workflow использует две ветки, для записи истории проекта. Master хранит официальную историю релизов, в development же ветке ведется активная разработка. Также важно тагать комиты в master ветки номерами версий.\n\n**Feature Branches**\nКаждая новая фича должна разрабатываться отдельно - в своей ветке, которая должна пушиться в центральный репозиторий для сохранения работы или коллаборации с другими разработчиками. Для создания фичебранча используется development ветка. Когда разработка фичи закончена, она сливается в development. Фичи никогда не должны сливаться напрямую с master веткой.\n\n**Release Branches**\nКак только development наберет достаточно фич для релиза (или в заранее определенную дату) создается release ветка из development ветки.\n\nСоздание этого бранча начинает новый релиз-цикл, поэтому в эту ветку уже не должно покадать никаких новых фич - только баг-фиксы, генерация документации и другие таски, ориентированные на релиз.\n\nКак только релиз-ветка подготовлена, ее сливают с master и тагают новой версией. Также она должна быть слита и с development веткой, которая уже скорее всего убежала вперед, с момента инициализации релиза.\n\nИспользование отдельной ветки для релиза позволяет одной команде готовить релиз, в том время когда другая команда будет продолжать разрабатывать новые фичи в development для последующих релизов.\n\n**Hotfix Branches**\nHotfix ветки используются для быстрого патчинга релизов. Это единственная ветка, которая создается из master. Как только фикс готов, он должен быть слит как в master, так и в development (или в новый release, если она есть) и master должен быть тегирован новой версией (инкрементирована patch цифра. v.1.0.1, например)\n\nЭто позволяет исправлять ошибки не прерывая весь воркфлоу или не дожидаясь следующего релиза, для выкатывания исправлений.\n\n## Что такое Git Rebase\n\nИтак git работает с комитами. Каждый комит — набор изменений. У каждого комита есть уникальный hash. Когда происходит слияние веток посредством merge:\n\n`$ git merge \"another_branch\"`\n\nто все комиты сохраняются — сохраняются комментарии комита, его hash + как правило добавляется еще один искусственный комит. При этом комиты могут чередоваться друг с другом. Это не всегда удобно. Допустим ваш комит решили откатить — выискивать в общем списке где ваш комит, а где не ваш не очень приятно. И вообще — в общей истории хочется видеть действительно важные изменения, а не «ой, я забыл поставить ;». Для того, чтобы несколько комитов склеивать в один можно использовать rebase. Хотя в интерфейсе GitHub есть кнопочка squash & commit — это когда вы создаете pull request (PR) из одной ветки в другую (как правило из вашей рабочей ветки в основную) и после прохождения всех формальностей можно нажать squash & commit, обновить комментарий и ваши изменения появятся в основной ветке как один комит.\n\nХочу написать о двух случаях использования rebase:\n\n1. Когда изменения включаются из одну ветку в другую не посредством merge, а посредством rebase:\n    `$ git rebase \"another_branch\"`\n    Это позволяет ваши локальные комиты поставить после всех комитов, которые были внесены в ветку «another_branch». Хэши ваших комитов изменятся.\n2. Когда можно руками отредактировать несколько ваших комитов — например склеить их, изменить коментарий:\n    `$ git rebase -i {HEAD~_commit_count_|commit_hash}`\n\nИтак вы все сделали в своей уютненькой веточки и решили поделиться этим комитом с миром, но мир хочет от вас только один комит. `git rebase -i` запустит редактор и предложит отредактировать комиты (порядок следования комитов — сверху вниз в отличие от git log). Можно оставить комит как есть, можно изменить комментарий, можно склеить с предыдущим. Как правило ваш первый комит надо оставить как есть, а все остальные изменить на\n`pick \"commit_hash\" \"comment\" → fixup \"commit_hash\" \"comment\"`.\n\nПри этом все комментарии, которые были в fixup комитах потеряются и будет использоваться комментарий от первого комита. Если вам были дороги комментарии, то стоит использовать squash вместо fixup.\n\nНо если процесс разработки был долог, то скорее всего вам приходилось делать merge основной ветки. И все ваши комиты перемешаются с общими комитами и склеивать ваши с не вашими будет задачей непростой. Поэтому перед тем, как делать `git rebase -i <>` стоит сделать `git rebase`. `git rebase` поставит все ваши комиты в конец списка всех комитов (в чем можно убедиться запустив `git log`) и после этого запустиь `git rebase -i <HEAD~Количесво_ваших_комитов>`, во всех строчках кроме первой заменить pick → {fixup|squash} и вуаля — у вас один комит.\n\nЕсли в процессе редактирования комитов `git rebase -i <>` вы как-то накосячили, то не стоит жать Control+C — exit code выхода из редактора git не волнует. Он просто возьмет файл и сделает все по нему. Просто удалите или закомментируйте все строчки в файле. git поймет, что вы ничего не хотели.\n\nПосле манипуляций с rebase потребуется push с опцией -F. Все это потому, что мы переписываем меняем историю комитов и git нас об этом честно предупреждает.\n`$ git push -f`\n\n## Что такое Git Cherry pick\n\nКоманда `git cherry-pick` используется для перенесения отдельных коммитов из одного места репозитория в другое, обычно между ветками разработки и обслуживания. Этот механизм отличается от привычных команд `git merge` и `git rebase`, которые переносят коммиты целыми цепочками.\n\n`git cherry-pick <commit-hash>`\n\n## Что такое force push\n\nЕсли вы поправили какие-нибудь старые коммиты в истории git, например: исправили имя автора или e-mail, или отменили последний коммит или воспользовались amend или revert, то при попытке push-а git справедливо «ругнётся»\n\nЧтобы нам всё же запушить наши изменения, нам нужно выполнить либо\n\n`git push --force origin <имя_ветки>`\n\nНо в этом случае мы рискуем перетереть чьи-нибудь изменения, если с тех пор, как мы забирали изменения с сервера, кто-то успел запушить свои коммиты. Поэтому лучше использовать более безопасную команду:\n\n`git push --force-with-lease origin <имя_ветки>`\n\nТакой вариант лучше тем, что если кто-то успел запушить свои коммиты после того, как мы забирали изменения с сервера, то он не будет их перетирать, а выдаст нам ошибку, после чего мы сможем интегрировать чужие коммиты со своими изменениями и попытаться сделать `push --force-with-lease` ещё раз.\n\n## Что такое pre-commit check\n\nКак и во многих других системах контроля версий, в Git'е есть возможность запускать собственные сценарии в те моменты, когда происходят некоторые важные действия. Существуют две группы подобных перехватчиков (hook): на стороне клиента и на стороне сервера. Перехватчики на стороне клиента предназначены для клиентских операций, таких как создание коммита и слияние. Перехватчики на стороне сервера нужны для серверных операций, таких как приём отправленных коммитов. Перехватчики могут быть использованы для выполнения самых различных задач. О некоторых из таких задач мы и поговорим.\n\nPre-commit check можно использовать например так:\n\n- выполнять проверку кода на валидность (например: соответствие требованиям PEP8, наличие документации итд);\n- выполнять комплексную проверку проекта (юнит-тесты итд);\n- прерывать операцию commit'а в случае обнаружения ошибок и отображать подробный журнал для разбора полетов.\n\n# БД\n\n- [Топ-65 вопросов по SQL с собеседований, к которым вы должны подготовиться в 2019 году. Часть I](https://habr.com/ru/company/otus/blog/461067/)\n\n## Что такое транзакция. Какие у неё есть свойства\n\n- [Руководство по SQL. Транзакции](https://proselyte.net/tutorials/sql/sql-transactions/)\n\nТранзакция является рабочей единицей работы с базой данных (далее – БД). Это последовательность операций, выполняемых в логическом порядке пользователем, либо программой, которая работает с БД.\n\nМы можем сказать, что транзакция – это распространение изменений в БД. Например, если мы создаём, изменяем или удаляем запись, то мы выполняем транзакцию. Крайне важно контролировать транзакции для гарантирования.\n\nОсновные концепции (свойства) транзакции описываются аббревиатурой ACID – Atomicity, Consistency, Isolation, Durability (Атомарность, Согласованность, Изолированность, Долговечность).\n\n**Атомарность:**\n\nАтомарность гарантирует, что любая транзакция будет зафиксирована только целиком (полностью). Если одна из операций в последовательности не будет выполнена, то вся транзакция будет отменена. Тут вводится понятие “отката” (rollback). Т.е. внутри последовательности будут происходить определённые изменения, но по итогу все они будут отменены (“откачены”) и по итогу пользователь не увидит никаких изменений.\n\n**Согласованность:**\n\nЭто означает, что любая завершённая транзакция (транзакция, которая достигла завершения транзакции – end of transaction) фиксирует только допустимые результаты. Например, при переводе денег с одного счёта на другой, в случае, если деньги ушли с одного счёта, они должны прийти на другой (это и есть согласованность системы). Списание и зачисление  – это две разные транзакции, поэтому первая транзакция пройдёт без ошибок, а второй просто не будет. Именно поэтому крайне важно учитывать это свойство и поддерживать баланс системы.\n\n**Изолированность:**\n\nКаждая транзакция должна быть изолирована от других, т.е. её результат не должен зависеть от выполнения других параллельных транзакций. На практике, изолированность крайне труднодостижимая вещь, поэтому здесь вводится понятие “уровни изолированности” (транзакция изолируется не полностью).\n\n**Долговечность:**\n\nЭта концепция гарантирует, что если мы получили подтверждение о выполнении транзакции, то изменения, вызванные этой транзакцией не должны быть отменены из-за сбоя системы (например, отключение электропитания).\n\n## Какие команды управления транзакциями вы знаете\n\n- [Руководство по SQL. Транзакции](https://proselyte.net/tutorials/sql/sql-transactions/)\n\nДля управления транзакциями используются следующие команды:\n\n- COMMIT: Сохраняет изменения\n- ROLLBACK: Откатывает (отменяет) изменения\n- SAVEPOINT: Создаёт точку к которой группа транзакций может откатиться\n- SET TRANSACTION: Размещает имя транзакции.\n\nКоманды управление транзакциями используются только для DML команд: INSERT, UPDATE, DELETE. Они не могут быть использованы во время создания, изменения или удаления таблицы.\n\n## Что такое уровни изолированности транзакций. Какие они бывают\n\n\"Высоконагруженные приложения\". М. Клеппман. Глава 7\n\n*Изоляция* в смысле ACID означает, что конкурентно выполняемые транзакции изолированы друг от друга — они не могут помешать друг другу. Классические учебники по базам данных понимают под изоляцией сериализуемость (serializability). То есть каждая транзакция выполняется так, будто она единственная во всей базе. БД гарантирует, что результат фиксации транзакций такой же, как если бы они выполнялись последовательно (serially, одна за другой), хотя в реальности они могут выполняться конкурентно.\n\n**Чтение зафиксированных данных (read comitted):**\n\nСамый базовый уровень изоляции транзакций — чтение зафиксированных данных. Он обеспечивает две гарантии.\n\n- При чтении из БД клиент видит только зафиксированные данные (никаких «грязных» операций чтения).\n- При записи в БД можно перезаписывать только зафиксированные данные (никаких «грязных» операций записи).\n\n*«Грязные» операции чтения*. Клиент читает записанные другим клиентом данные до их фиксации. Уровень изоляции чтения зафиксированных данных и более сильные предотвращают «грязные» операции чтения.\n\n*«Грязные» операции записи*. Клиент перезаписывает данные, которые другой клиент записал, но еще не зафиксировал. Практически все реализации транзакций предотвращают «грязные» операции записи.\n\n**Изоляция снимков состояния и воспроизводимое чтение:**\n\nЕе идея состоит в том, что каждая из транзакций читает данные из согласованного снимка состояния БД, то есть видит данные, которые были зафиксированы в базе на момент ее (транзакции) начала. Даже если данные затем были изменены другой транзакцией, каждая транзакция видит только старые данные, по состоянию на конкретный момент времени. Позволяет предотвратить асимметрии чтения.\n\n*Асимметрия чтения* (невоспроизводимое чтение). Клиент видит различные части базы данных по состоянию на разные моменты времени. Чаще всего такую проблему предотвращают с помощью изоляции снимков состояния, при которой транзакция читает данные из согласованного снимка состояния, соответствующего определенному моменту времени. Обычно это реализуется благодаря многоверсионному управлению конкурентным доступом (MVCC).\n\n**Сериализуемость (serializability):**\n\nОбычно считается самым сильным уровнем изоляции. Она гарантирует, что даже при конкурентном выполнении транзакций результат останется таким же, как и в случае их последовательного (по одной за раз) выполнения, без всякой конкурентности. Следовательно, база данных гарантирует, что правильно выполняющиеся последовательно транзакции будут столь же правильно выполняться конкурентно. Другими словами, база предотвращает все возможные состояния гонки.\n\nБольшинство современных БД, обеспечивающих сериализуемость, применяют один из трех методов:\n\n- По-настоящему последовательное выполнение транзакций. Если вы можете сделать отдельные транзакции очень быстрыми, причем количество транзакций, обрабатываемых за единицу времени на одном ядре CPU, достаточно невелико, то для обработки этот вариант окажется простым и эффективным.\n- Двухфазная блокировка. На протяжении десятилетий она была стандартным способом обеспечения сериализуемости, но многие приложения стараются ее не использовать из-за плохих показателей производительности.\n- Сериализуемая изоляция снимков состояния (SSI). Довольно свежий алгоритм, лишенный практически всех недостатков предыдущих подходов. В нем используется оптимистический подход, благодаря чему транзакции выполняются без блокировок. Перед фиксацией транзакции выполняется проверка, и если выполнение было несериализуемым, то транзакция прерывается без фиксации.\n\n## Что такое вложенные транзакции\n\nВложенными называются транзакции, выполнение которых инициируется из тела уже активной транзакции .\n\nДля создания вложенной транзакции пользователю не нужны какие-либо дополнительные команды. Он просто начинает новую транзакцию, не закрыв предыдущую. Завершение транзакции верхнего уровня откладывается до завершения вложенных транзакций. Если транзакция самого нижнего ( вложенного ) уровня завершена неудачно и отменена, то все транзакции верхнего уровня, включая транзакцию первого уровня, будут отменены. Кроме того, если несколько транзакций нижнего уровня были завершены успешно (но не зафиксированы), однако на среднем уровне (не самая верхняя транзакция ) неудачно завершилась другая транзакция, то в соответствии с требованиями ACID произойдет откат всех транзакций всех уровней, включая успешно завершенные. Только когда все транзакции на всех уровнях завершены успешно, происходит фиксация всех сделанных изменений в результате успешного завершения транзакции верхнего уровня.\n\nКаждая команда COMMIT TRANSACTION работает только с последней начатой транзакцией. При завершении вложенной транзакции команда COMMIT применяется к наиболее \"глубокой\" вложенной транзакции. Даже если в команде COMMIT TRANSACTION указано имя транзакции более высокого уровня, будет завершена транзакция, начатая последней.\n\n## Что такое курсор и зачем он нужен\n\nЗапрос к реляционной базе данных обычно возвращает несколько рядов (записей) данных, но приложение за один раз обрабатывает лишь одну запись. Даже если оно имеет дело одновременно с несколькими рядами (например, выводит данные в форме электронных таблиц), их количество по-прежнему ограничено. Кроме того, при модификации, удалении или добавлении данных рабочей единицей является ряд. В этой ситуации на первый план выступает концепция курсора, и в таком контексте курсор – указатель на ряд.\n\nКурсор в SQL – это область в памяти базы данных, которая предназначена для хранения последнего оператора SQL. Если текущий оператор – запрос к базе данных, в памяти сохраняется строка данных запроса, называемая текущим значением, или текущей строкой курсора. Указанная область в памяти поименована и доступна для прикладных программ.\n\nОбычно курсоры используются для выбора из базы данных некоторого подмножества хранимой в ней информации. В каждый момент времени прикладной программой может быть проверена одна строка курсора. Курсоры часто применяются в операторах SQL, встроенных в написанные на языках процедурного типа прикладные программы. Некоторые из них неявно создаются сервером базы данных, в то время как другие определяются программистами.\n\nВ некоторых случаях применение курсора неизбежно. Однако по возможности этого следует избегать и работать со стандартными командами обработки данных: SELECT, UPDATE, INSERT, DELETE. Помимо того, что курсоры не позволяют проводить операции изменения над всем объемом данных, скорость выполнения операций обработки данных посредством курсора заметно ниже, чем у стандартных средств SQL.\n\n## Какая разница между PostgreSQL и MySQL\n\n- [Сравнение MySQL и PostgreSQL](https://hyperhost.ua/info/ru/sravnenie-mysql-i-postgresql)\n\n**История разработки MySQL и PostgreSQL.**\n\nMySQL начал создаваться еще в 90-х. Внутренний выпуск произошел в 1995 году. Тогда разработкой MySQL занимались несколько компаний. Начиная с 2010 года компания  Oracle владеет проектом MySQL и разрабатывает новые версии.\n\nPostgreSQL немного ранее в 1986 году начал разрабатываться в Калифорнийском университете.  Над проектом работали более 8 лет, но потом был разделен на коммерческую БД IIlustra и свободный проект Postrgesql.\n\n**Особенности хранения данных.**\n\nВ MySQL для хранения данных в таблицах используются различные движки. Движок не имеет влияния на синтаксис запросов и их выполнение. Имеется поддержка MyISAM, InnoDB, MEMORY, Berkeley DB. Их основное отличие в способе записи данных на диск и методов считывания. PostgreSQL работает только на движке storage engine. Таблицы организованы в виде обьектов, а действия выполняются с помощью объективно ориентированных функций.\n\n**Стандарты SQL.**\n\nSQL - это стандартизированный язык выполнения запросов, который используется и MySQL и PostgreSQL. Этот стандарт имеет несколько версий и был разработан еще в 1986 году.\n\nMySQL имеет поддержку не всех функций и возможностей SQL. Это сделано для того, чтобы работать с MySQL было просто и удобно. Но если для проекта необходимо какое-то расширение, разработчики его могут добавить не в ущерб стандарту.\n\nPostgreSQL поддерживает все новые стандарты SQL, из-за этого данный проект довольно сложный и не настолько популярный как MySQL.\n\n**Возможности обработки данных.**\n\nMySQL при исполнении запроса делает загрузку всего ответа сервера в память клиента. В случае больших обьемов это не всегда удобно. По функциям Postgresql более широкий чем Mysql. Например, в Postgresql при помощи курсора можно перемещать полученные данные. Вам предоставляется только указатель, а весь ответ хранится в памяти сервера баз данных. Данный указатель можно хранить между сеансами. Postgresql имеет поддержку регулярных выражений в запросах, рекурсивных запросов и наследования таблиц.\n\n**Производительность MySQL и Postgresql.**\n\nMySQL всегда был ориентирован на большую производительность, в то время как Postgresql был нацелен на большое количество настроек и стандартов. Но со временем эта ситуация поменялась и Postgre стал более производительным.\n\nДля организации работы с базой данных в MySQL используется таблица InnoDB. А это значит, что MySQL будет значительно быстрее Postgre в случае использовании первичного ключа.\n\nПо поводу  Postgresql, вся заголовочная информация таблиц размещается в оперативной памяти. Можно применять несколько индексов к одной таблице для большего удобства. В общем PostgreSQL работает быстрее, кроме ситуаций с использованием первичных ключей.\n\n**Поддерживаемые типы данных.**\n\nMySQL и Postgresql имеют похожий набор, который, конечно же, имеет свои отличия. В Postgre типы более разнообразны и есть свои типы полей для определенных видов данных, которых, например, нет в MySQL.\n\n## Что такое VACUUM в PostgreSQL\n\nVACUUM высвобождает пространство, занимаемое «мёртвыми» кортежами. При обычных операциях Postgres кортежи, удалённые или устаревшие в результате обновления, физически не удаляются из таблицы; они сохраняются в ней, пока не будет выполнена команда VACUUM. Таким образом, периодически необходимо выполнять VACUUM, особенно для часто изменяемых таблиц.\n\n## Что такое EXPLAIN. Какая разница между ним и EXPLAIN ANALYZE\n\nEXPLAIN выводит информацию, необходимую для понимания, что же делает ядро при каждом конкретном запросе.\n\nEXPLAIN ANALYZE выполняет объясняемое выражение, даже если это insert, update или delete.\n\n## Какие виды Join'ов вы знаете, чем они отличаются друг от друга\n\n- [Табличные выраженияl](https://postgrespro.ru/docs/postgresql/9.6/queries-table-expressions)\n\nСлова INNER и OUTER необязательны во всех формах. По умолчанию подразумевается INNER (внутреннее соединение), а при указании LEFT, RIGHT и FULL — внешнее соединение.\n\nУсловие соединения указывается в предложении ON или USING, либо неявно задаётся ключевым словом NATURAL. Это условие определяет, какие строки двух исходных таблиц считаются «соответствующими» друг другу.\n\nВозможные типы соединений с сопоставлениями строк:\n\n*INNER JOIN*\nДля каждой строки R1 из T1 в результирующей таблице содержится строка для каждой строки в T2, удовлетворяющей условию соединения с R1.\n\n*LEFT OUTER JOIN*\nСначала выполняется внутреннее соединение (INNER JOIN). Затем в результат добавляются все строки из T1, которым не соответствуют никакие строки в T2, а вместо значений столбцов T2 вставляются NULL. Таким образом, в результирующей таблице всегда будет минимум одна строка для каждой строки из T1.\n\n*RIGHT OUTER JOIN*\nСначала выполняется внутреннее соединение (INNER JOIN). Затем в результат добавляются все строки из T2, которым не соответствуют никакие строки в T1, а вместо значений столбцов T1 вставляются NULL. Это соединение является обратным к левому (LEFT JOIN): в результирующей таблице всегда будет минимум одна строка для каждой строки из T2.\n\n*FULL OUTER JOIN*\nСначала выполняется внутреннее соединение. Затем в результат добавляются все строки из T1, которым не соответствуют никакие строки в T2, а вместо значений столбцов T2 вставляются NULL. И наконец, в результат включаются все строки из T2, которым не соответствуют никакие строки в T1, а вместо значений столбцов T1 вставляются NULL.\n\nПредложение ON определяет наиболее общую форму условия соединения: в нём указываются выражения логического типа, подобные тем, что используются в предложении WHERE. Пара строк из T1 и T2 соответствуют друг другу, если выражение ON возвращает для них true.\n\nUSING — это сокращённая запись условия, полезная в ситуации, когда с обеих сторон соединения столбцы имеют одинаковые имена. Она принимает список общих имён столбцов через запятую и формирует условие соединения с равенством этих столбцов. Например, запись соединения T1 и T2 с USING (a, b) формирует условие ON T1.a = T2.a AND T1.b = T2.b.\n\nБолее того, при выводе JOIN USING исключаются избыточные столбцы: оба сопоставленных столбца выводить не нужно, так как они содержат одинаковые значения. Тогда как JOIN ON выдаёт все столбцы из T1, а за ними все столбцы из T2, JOIN USING выводит один столбец для каждой пары (в указанном порядке), за ними все оставшиеся столбцы из T1 и, наконец, все оставшиеся столбцы T2.\n\nНаконец, NATURAL — сокращённая форма USING: она образует список USING из всех имён столбцов, существующих в обеих входных таблицах. Как и с USING, эти столбцы оказываются в выходной таблице в единственном экземпляре. Если столбцов с одинаковыми именами не находится, NATURAL JOIN действует как JOIN ... ON TRUE и выдаёт декартово произведение строк.\n\nЕще есть cross join - декартово произведение.\n\n# Дизайн-интервью\n\n[Как задизайнить Facebook за пол часа или секреты System Design Interview / Алексей Петров](https://www.youtube.com/watch?v=Be7INI_U6GY)\n\nТема очень обширная, поэтому этот раздел следует воспринимать как чеклист для его прохождения.\n\n## План интервью\n\nБудем считать что тайм-слот интервью - 40 минут.\n\n1. Уточнить требования и ограничения (4 минуты)\n2. Сделать эстимейты проектируемой системы (пропускная способность, сколько нужно хранить информации, количество серверов и т.д.) (3 минуты)\n3. System interface - какие сервисы предоставляет система, какие сервисы использует система (3 минуты)\n4. System high-level design - какие компоненты входят в систему, как они взаимодействуют друг с другом (5 минут)\n5. Component detailed design - какие компоненты входят в систему, как они взаимодействуют друг с другом. Описать возможные ботлнеки (15 минут)\n6. Масштабирование - как система будет масштабироваться (5 минут)\n7. Summary - общий обзор и презентация решения (5 минут)\n\n## 1. Сбор требований\n\nСобираем ответы на вопросы \"Что система делает?\" и \"Какой должна быть система?\"\n\nПримеры вопросов:\n\n- Это должна быть глобальная система или региональная?\n- Как быстро система должна реагировать на внесенные изменения (latency)?\n- Какая должна быть доступность системы (availability)?\n- Сколько у нас пользователей активно ежедневно?\n- Сколько пользователи генерируют трафика ежедневно (количество постов, публикаций и тд)?\n- Какое количество информации пользователь просматривает каждый день?\n\nЕсли нам предлагают спроектировать систему по примеру существующей (twitter, facebook, google docs, etc), то мы можем спросить:\n- Какую часть системы мы проектируем?\n- Какие именно функции должны быть реализованы?\n\nСразу формируем для себя чек-лист требований, чтобы не забыть что-то важное.\nНапример нам предложили спроектировать Facebook с такими требованиями:\n\n- Дизайним ленту новостей (news feed) фейсбука\n- Фото/видео не реализуем\n- Ранжирование постов не нужно, хронологический порядок\n- Встраиваем реламу в ленту (желательно)\n- Глобальная система (multi-region)\n- Latency (внутри региона) < 1s\n- Latency (между регионами) < 60s\n- Durability (постоянство данных) очень важно\n- Availability (доступность) менее важно\n- Миллиард пользователей\n- 10 миллионов постов в день\n- 500 друзей в среднем\n- 5 просмотров фида на пользователя в день\n\n## 2. Эстимейты\n\nЧтобы посчитать эстимейты нужно примерно представить какой тип информации сколько весит.\n\nХранение информации:\n- Символ - 1 байт\n- Метаданные (строка в базе, вес поста, etc) - 5-10 килобайт\n- 1080p изображение - 2 мегабайта\n- 1080p видео (минута) - 30 мегабайт\n\nСервера:\n- Дисковое пространство - 10 терабайт\n- RAM - 256-512 гигабайт\n\nИтого считаем эстимейты для примера с фейсбуком:\n- Read-write ratio - 5B / 10M = 500:1\n- RPS\n  - Read: 5B / (24 * 60 * 60) = ~58k rps\n  - Write: 10M / (24 * 60 * 60) = ~115 rps\n- Storage:\n  - 10KB * 10M = 100GB ежедневно\n  - 30 * 100GB = 3TB ежемесячно\n- Пропускная способность:\n  - Read: 5B * 20 постов * 10KB = 1PB ежедневно\n  - Write: 10M * 10KB = 100GB ежедневно\n\nPS. RPS мы посчитали \"постоянный\", в пиках он может увеличиваться в 10 раз (условно)\n\n## 3. API\n\nОписываем максимально просто - какие методы будут доступны, какие параметры будут принимать.\n\n## 4. High-level design\n\nНе стоит называть какие-то конкретные технологии, а просто описывать какие компоненты будут в системе и как они будут взаимодействовать.\nНу тоесть не нужно прям называть Nginx, а просто описать что будет балансировщик нагрузки.\n\n- Если ставим лоад-балансер, то какой? (Round-robin, sticky sessions, etc)\n- Если БД, то какая? (RDBMS, NoSQL, inmemory etc)\n\n## 5. Detailed design\n\n- Описываем схему БД и запросы к ней (можем прям примеры запросов писать)\n- Перебираем подходы по обработке данных (pros/cons)\n- Выбираем решения и объясняем их tradeoffs\n- Проверяем требования (список который мы составили на шаге 1)\n- Определить edge cases (если они есть)\n\n### Performance mantras\n\nВ процессе, если мы сталкиваемся с проблемой производительности, то мы можем применять следующие [мантры](https://www.brendangregg.com/methodology.html):\n- Не делай этого\n- Делай, но только один раз\n- Делай это реже\n- Сделай это позже\n- Сделай пока пользователь этого не видит\n- Сделай это параллельно\n- Сделай это дешевле\n\n## 6. Масштабирование\n\nЕсли говорим про шардирование, то сразу оговариаем какой ключ шардирования выбираем.\n\n### Performance bottlenecks\n\nВ зависимости от количества пользователей нам может понадобиться разные инфраструктурные решения:\n\n- 1000 пользователей\n  - 1 сервер\n  - 1 БД\n- 10 000 пользователей\n  - Read replicas\n  - Несколько серверов\n  - Load balancer(s)\n- 100 000 пользователей\n  - Message queue\n  - Rate limits\n  - Cache\n  - CDN\n- 1 000 000 пользователей\n  - Stateless services (если они еще не такие)\n  - Возможно появится noSQL (если еще не использовался)\n  - Database sharding\n- 1 000 000 000 пользователей\n  - Regional DCs\n\n# Вопросы работодателю\n\n- [Вопросы не мальчика, а джуна. 22 вопроса работодателю на собеседовании на позицию «Middle Python-разработчик»](https://habr.com/ru/post/428283/)\n\n## Вопросы HR'у\n\n1. Что с отпуском и больничными?\n2. Переносится ли отпуск на следующий год?\n3. Какое отношение к официальным государственным выходным?\n4. Есть ли мед-страховка?\n5. Какие ограничения есть на период испытательного срока\n6. Свободный график? Нужно находиться в офисе n часов?\n7. Как в компании относятся к удалённой работе?\n8. Можно ли получить оборудование для удалённой работы (мониторы, etc.) или может есть компенсация на оборудование рабочего места\n9. Существует ли в компании полугодовая/годовая оценка сотрудников и как она происходит?\n10. Какой минимальный срок для первого пересмотра ЗП начиная с первого рабочего дня?\n11. Есть ли у в компании переработки? Если есть, то компенсируются ли они и как часто они происходят?\n12. Насколько в компании сильна бюрократия?\n13. Является ли компания участником каких-либо IT-конференций и есть ли у компании публикации на IT-темы?\n14. Есть ли митапы внутри компании?\n15. Есть ли в компании стажёры и развита ли система наставничества?\n16. Зарплата в какой валюте и привязана ли к курсу, если не в у.е?\n\n## Вопросы для технического собеседования\n\n1. Как дела с тестированием? Какие тесты вы пишете? Какие библиотеки для тестирования вы используете? (фабрики, моки и т.д.)\n2. Есть ли Code Review? Как оно проходит?\n3. Есть ли в проектах CI/CD? Есть ли DevOps-инженер?\n4. Используете ли вы git-flow или какую-либо определенную методологию при работе с git?\n5. Используете ли Вы методологию разработки (scrum, kanban и т.д.)?\n6. Используются ли системы мониторинга в проектах(Sentry, NewRelic и т.д.)?\n7. Используется ли в проекте система для хранения логов и работы с ними(ELK-технология и прочее)?\n8. Какие БД используются в проекте? Почему именно такие?\n9. Какая версия языка Python используется в проектах?\n10. Компания ищет fullstack-разработчика или backend-разработчика?\n11. Используется ли технология контейнеризации в проектах?\n12. Немного поспрашивать собеседующего о том, чем он занимался до этого проекта и давно ли он в проекте.\n13. Есть ли синьеры в команде или просто очень опытные разрабы?\n14. Оцениваниются ли задачи по времени или стори-поинтам?\n15. Как легко втащить в проект новую технологию? Как выбирается стек для нового проекта?\n16. Как в команде принимаются решения? Есть ли человек за которым последнее слово?\n17. Попросить описать несколько типичных задач или несколько последних\n18. Какие версии Python и фреймворков используются?\n19. Насколько часто приходится работать с legacy?\n20. Если приходится работать с legacy то какой подход: вносим минимальные правки или пытаемся привести legacy в нормальный вид?\n\n# Интересные ссылки\n\n- [Интересности и полезности python](https://habr.com/ru/post/421993/)\n- [Python: вещи, которых вы могли не знать](https://habr.com/ru/post/207988/)\n- [Интересные особенности Python, о которых вы могли не догадываться](https://habr.com/ru/post/322360/)\n- [Python на Хабре](https://habr.com/ru/post/205944/)\n- [Микросервисы (Microservices)](https://habr.com/ru/post/249183/)\n- [Цикл событий в js](https://www.youtube.com/watch?v=8cV4ZvHXQL4&index=3&t=0s&list=PLmcXv3fDgVcjpZ6QnpXrSNTj7-RxtdFhA)\n- [Разница между nginx и apache с примерами](https://habr.com/ru/post/320710/)\n\n# Источники вопросов\n\n- [Обширный обзор собеседований по Python. Советы и подсказки](https://habr.com/ru/post/439576/)\n- [Собеседование. Вопросы для подготовки](https://grishaev.me/interview/)\n"
        }
      ]
    }
  ]
}