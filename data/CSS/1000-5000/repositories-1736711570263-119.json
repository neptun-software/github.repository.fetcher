{
  "metadata": {
    "timestamp": 1736711570263,
    "page": 119,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rickyrauch/Balloons.IO",
      "stars": 2364,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.103515625,
          "content": ".DS_Store\n*.swp\nnode_modules\nconfig.json\nchats/*\n*.rdb\n!views/themes/default\nviews/themes/*\npublic/custom\n"
        },
        {
          "name": "Procfile",
          "type": "blob",
          "size": 0.021484375,
          "content": "web: node balloons.js\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.173828125,
          "content": "Balloons.IO\n===========\n\nBalloons.IO is a web multi-room chat server and client ready to use.\nIt’s build with the help of node.JS, Express, Socket.IO and Redis. \n \n<img src=\"https://i.cloudup.com/WFU5nGgvny.png\" />\n\n## Installation\n\nThe installation of certain tools can be a bit annoying, but these then\nbecome inseparable friends to all developer. We will not explain how\nto install each and every one of these tools, especially because their\nsites do much better than what we could do ourselves:\n\n### Requirements\n\n-   [node.JS](http://nodejs.org)\n-\t\t[Redis-server](http://redis.io)\n\n\n### Install Redis\n\n    wget http://redis.googlecode.com/files/redis-2.4.17.tar.gz\n    tar xvf redis-2.4.17.tar.gz\n    cd redis-2.4.17\n    make && make install\n\nStart Redis\n\n`./redis-server ./redis.conf`\n\n\n### Install Balloons.IO\n\nIf you have these 2 tools installed, go to terminal and type:\n\n    git clone https://github.com/gravityonmars/Balloons.IO.git\n    cd Balloons.IO\n    npm install\n    mv config/config.sample.json config/config.json\n\nThen, edit config/config.json with your favorite text editor and add Facebook & Twitter keys.\n\nTo allow Sign In with Twitter: \n\n- [Create a new application](https://dev.twitter.com/apps/new) and copy the keys that Twitter gives you into 'config/config.json'. \n\n- Go to your Twitter app Settings and add the Callback URL contained in 'config/config.json': http://127.0.0.1:6789/auth/twitter/callback\n\nTo allow Sign In with Facebook:\n\n- [Create a new application](https://developers.facebook.com/apps) and copy the keys Facebook gives you into 'config/config.json'.\n\n- Go to your Facebook app Settings/Basic, click on Website with Facebook Login and add the Callback URL contained in 'config/config.json':\nhttp://127.0.0.1:6789/auth/facebook/callback\n\nGo to terminal and run `node balloons`.\n\nPoint your browser to `http://127.0.0.1:6789` (You can also change the port from 'config/config.json')\n\nBalloons uses [PassportJS](http://passportjs.org) for authentication with Twitter and Facebook.\n\nEnjoy!\n\n\n## Contributors \n- [Dan Zajdband](https://twitter.com/dzajdband)\n- [Ricardo Rauch](https://twitter.com/rickyrauch)\n- [Cristian Douce](https://twitter.com/dzajdband)\n\n\n\n\n\n\n\n\n\n## License \n\nMIT\n"
        },
        {
          "name": "balloons.js",
          "type": "blob",
          "size": 1.01953125,
          "content": "/*\n * Module dependencies\n */\n\nvar express = require('express')\n  , init = require('./init')\n\n/*\n * Create and config server\n */\n\nvar app = exports.app = express();\n\n/**\n * Configure application\n */\n\nrequire('./config')(app);\n\n/*\n * Clean db and create folder\n */\n\n// init(app.get('redisClient'));\n\n/*\n * Passportjs auth strategy\n */\n\nrequire('./strategy')(app);\n\n\n/*\n * Routes\n */\n\nrequire('./routes')(app);\n\n/*\n * Web server\n */\n\nif(app.get('config').credentials) {\n  exports.server = require('https')\n  .createServer(app.get('config').credentials, app).listen(app.get('port'), function() {\n    console.log('Balloons.io started on port %d', app.get('port'));\n  });\n} else {\n  exports.server = require('http')\n  .createServer(app).listen(app.get('port'), function() {\n    console.log('Balloons.io started on port %d', app.get('port'));\n  });\n}\n\n/*\n * Socket.io\n */\n\nrequire('./sockets')(app, exports.server);\n\n\n/*\n * Catch uncaught exceptions\n */\n\nprocess.on('uncaughtException', function(err){\n  console.log('Exception: ' + err.stack);\n});\n"
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "init.js",
          "type": "blob",
          "size": 1.2373046875,
          "content": "\n/*\n * Initialize the application\n */\n\n/*\n * Module dependencies\n */\n\nvar fs = require('fs');\n\n\n/*\n * Initialize the \n *\n * @param {Object} Redis client instance\n * API @public\n */\n\nmodule.exports = function(client) {\n  /*\n   * Clean all forgoten sockets in Redis.io\n   */\n\n  // Delete all users sockets from their lists\n  client.keys('sockets:for:*', function(err, keys) {\n    if(keys.length) client.del(keys);\n    console.log('Deletion of sockets reference for each user >> ', err || \"Done!\");\n  });\n\n  // No one is online when starting up\n  client.keys('rooms:*:online', function(err, keys) {\n    var roomNames = [];\n    \n    if(keys.length) {\n      roomNames = roomNames.concat(keys);\n      client.del(keys);\n    }\n\n    roomNames.forEach(function(roomName, index) {\n      var key = roomName.replace(':online', ':info');\n      client.hset(key, 'online', 0);\n    });\n\n    console.log('Deletion of online users from rooms >> ', err || \"Done!\");\n  });\n\n  // Delete all socket.io's sockets data from Redis\n  client.smembers('socketio:sockets', function(err, sockets) {\n    if(sockets.length) client.del(sockets);\n    console.log('Deletion of socket.io stored sockets data >> ', err || \"Done!\");\n  });\n\n  /*\n   * Create 'chats' dir\n   */\n  // fs.mkdir('./chats');\n\n};\n\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.5634765625,
          "content": "{\n  \"name\": \"Balloons.io\",\n  \"description\": \"Web multi-room chat server and client ready to use.\",\n  \"version\": \"0.0.1\",\n  \"dependencies\": {\n    \"express\": \"3.3.4\",\n    \"connect\": \"~2.8.4\",\n    \"debug\": \"~0.7.2\",\n    \"cookie\": \"0.0.x\",\n    \"jade\": \"~0.33.0\",\n    \"socket.io\": \"~0.9.16\",\n    \"redis\": \"0.7.2\",\n    \"connect-redis\": \"1.4.x\",\n    \"passport\": \"~0.1.17\",\n    \"passport-facebook\": \"~0.1.5\",\n    \"passport-twitter\": \"~0.1.5\",\n    \"component-type\": \"component/type\",\n    \"passport-github\": \"~0.1.5\"\n  },\n  \"engines\": {\n    \"node\": \">= 0.8.0\",\n    \"npm\": \">= 1.0\"\n  }\n}\n"
        },
        {
          "name": "public",
          "type": "tree",
          "content": null
        },
        {
          "name": "routes",
          "type": "tree",
          "content": null
        },
        {
          "name": "sockets.js",
          "type": "blob",
          "size": 4.90625,
          "content": "\n/*\n * Module dependencies\n */\n\nvar sio = require('socket.io')\n  , parseCookies = require('connect').utils.parseSignedCookies\n  , cookie = require('cookie')\n  , fs = require('fs');\n\n/**\n * Expose Sockets initialization\n */\n\nmodule.exports = Sockets;\n\n/**\n * Socket.io\n *\n * @param {Express} app `Express` instance.\n * @param {HTTPServer} server `http` server instance.\n * @api public\n */\n\nfunction Sockets (app, server) {\n  var config = app.get('config');\n  var client = app.get('redisClient');\n  var sessionStore = app.get('sessionStore');\n\n  var io = sio.listen(server);\n  io.set('authorization', function (hsData, accept) {\n    if(hsData.headers.cookie) {\n      var cookies = parseCookies(cookie.parse(hsData.headers.cookie), config.session.secret)\n        , sid = cookies['balloons'];\n\n      sessionStore.load(sid, function(err, session) {\n        if(err || !session) {\n          return accept('Error retrieving session!', false);\n        }\n\n        hsData.balloons = {\n          user: session.passport.user,\n          room: /\\/(?:([^\\/]+?))\\/?$/g.exec(hsData.headers.referer)[1]\n        };\n\n        return accept(null, true);\n        \n      });\n    } else {\n      return accept('No cookie transmitted.', false);\n    }\n  });\n\n  io.configure(function() {\n    io.set('store', new sio.RedisStore({\n      redisClient: client,\n      redisPub: client,\n      redisSub: client\n    }));\n    io.enable('browser client minification');\n    io.enable('browser client gzip');\n  });\n\n\n  io.sockets.on('connection', function (socket) {\n    var hs = socket.handshake\n      , nickname = hs.balloons.user.username\n      , provider = hs.balloons.user.provider\n      , userKey = provider + \":\" + nickname\n      , room_id = hs.balloons.room\n      , now = new Date()\n      // Chat Log handler\n      , chatlogFileName = './chats/' + room_id + (now.getFullYear()) + (now.getMonth() + 1) + (now.getDate()) + \".txt\"\n      // , chatlogWriteStream = fs.createWriteStream(chatlogFileName, {'flags': 'a'});\n\n    socket.join(room_id);\n\n    client.sadd('sockets:for:' + userKey + ':at:' + room_id, socket.id, function(err, socketAdded) {\n      if(socketAdded) {\n        client.sadd('socketio:sockets', socket.id);\n        client.sadd('rooms:' + room_id + ':online', userKey, function(err, userAdded) {\n          if(userAdded) {\n            client.hincrby('rooms:' + room_id + ':info', 'online', 1);\n            client.get('users:' + userKey + ':status', function(err, status) {\n              io.sockets.in(room_id).emit('new user', {\n                nickname: nickname,\n                provider: provider,\n                status: status || 'available'\n              });\n            });\n          }\n        });\n      }\n    });\n\n    socket.on('my msg', function(data) {\n      var no_empty = data.msg.replace(\"\\n\",\"\");\n      if(no_empty.length > 0) {\n        var chatlogRegistry = {\n          type: 'message',\n          from: userKey,\n          atTime: new Date(),\n          withData: data.msg\n        }\n\n        // chatlogWriteStream.write(JSON.stringify(chatlogRegistry) + \"\\n\");\n        \n        io.sockets.in(room_id).emit('new msg', {\n          nickname: nickname,\n          provider: provider,\n          msg: data.msg\n        });        \n      }   \n    });\n\n    socket.on('set status', function(data) {\n      var status = data.status;\n\n      client.set('users:' + userKey + ':status', status, function(err, statusSet) {\n        io.sockets.emit('user-info update', {\n          username: nickname,\n          provider: provider,\n          status: status\n        });\n      });\n    });\n\n    socket.on('history request', function() {\n      var history = [];\n      var tail = require('child_process').spawn('tail', ['-n', 5, chatlogFileName]);\n      tail.stdout.on('data', function (data) {\n        var lines = data.toString('utf-8').split(\"\\n\");\n        \n        lines.forEach(function(line, index) {\n          if(line.length) {\n            var historyLine = JSON.parse(line);\n            history.push(historyLine);\n          }\n        });\n\n        socket.emit('history response', {\n          history: history\n        });\n      });\n    });\n\n    socket.on('disconnect', function() {\n      // 'sockets:at:' + room_id + ':for:' + userKey\n      client.srem('sockets:for:' + userKey + ':at:' + room_id, socket.id, function(err, removed) {\n        if(removed) {\n          client.srem('socketio:sockets', socket.id);\n          client.scard('sockets:for:' + userKey + ':at:' + room_id, function(err, members_no) {\n            if(!members_no) {\n              client.srem('rooms:' + room_id + ':online', userKey, function(err, removed) {\n                if (removed) {\n                  client.hincrby('rooms:' + room_id + ':info', 'online', -1);\n                  // chatlogWriteStream.destroySoon();\n                  io.sockets.in(room_id).emit('user leave', {\n                    nickname: nickname,\n                    provider: provider\n                  });\n                }\n              });\n            }\n          });\n        }\n      });\n    });\n  });\n\n};"
        },
        {
          "name": "strategy.js",
          "type": "blob",
          "size": 1.724609375,
          "content": "\n/*\n * Module dependencies\n */\n\nvar passport = require('passport')\n  , TwitterStrategy = require('passport-twitter').Strategy\n  , FacebookStrategy = require('passport-facebook').Strategy\n  , GitHubStrategy = require('passport-github').Strategy;\n\n/**\n * Expose Authentication Strategy\n */\n\nmodule.exports = Strategy;\n\n/*\n * Defines Passport authentication\n * strategies from application configs\n *\n * @param {Express} app `Express` instance.\n * @api public\n */\n\nfunction Strategy (app) {\n  var config = app.get('config');\n\n  passport.serializeUser(function(user, done) {\n    done(null, user);\n  });\n\n  passport.deserializeUser(function(user, done) {\n    done(null, user);\n  });\n\n  if(config.auth.twitter.consumerkey.length) {\n    passport.use(new TwitterStrategy({\n        consumerKey: config.auth.twitter.consumerkey,\n        consumerSecret: config.auth.twitter.consumersecret,\n        callbackURL: config.auth.twitter.callback\n      },\n      function(token, tokenSecret, profile, done) {\n        return done(null, profile);\n      }\n    ));\n  } \n\n  if(config.auth.facebook.clientid.length) {\n    passport.use(new FacebookStrategy({\n        clientID: config.auth.facebook.clientid,\n        clientSecret: config.auth.facebook.clientsecret,\n        callbackURL: config.auth.facebook.callback\n      },\n      function(accessToken, refreshToken, profile, done) {\n        return done(null, profile);\n      }\n    ));\n  }\n\n  if(config.auth.github.clientid.length) {\n    passport.use(new GitHubStrategy({\n        clientID: config.auth.github.clientid,\n        clientSecret: config.auth.github.clientsecret,\n        callbackURL: config.auth.github.callback\n      },\n      function(token, tokenSecret, profile, done) {\n        return done(null, profile);\n      }\n    ));\n  }\n}\n\n"
        },
        {
          "name": "utils.js",
          "type": "blob",
          "size": 4.7607421875,
          "content": "var crypto = require('crypto')\n  , type = require('component-type');\n\n/*\n * Restrict paths\n */\n\nexports.restrict = function(req, res, next){\n  if(req.isAuthenticated()) next();\n  else res.redirect('/');\n};\n\n/*\n * Generates a URI Like key for a room\n */       \n\nexports.genRoomKey = function() {\n  var shasum = crypto.createHash('sha1');\n  shasum.update(Date.now().toString());\n  return shasum.digest('hex').substr(0,6);\n};\n\n/*\n * Room name is valid\n */\n\nexports.validRoomName = function(req, res, fn) {\n  req.body.room_name = req.body.room_name.trim();\n  var nameLen = req.body.room_name.length;\n\n  if(nameLen < 255 && nameLen >0) {\n    fn();\n  } else {\n    res.redirect('back');\n  }\n};\n\n/*\n * Checks if room exists\n */\nexports.roomExists = function(req, res, client, fn) {\n  client.hget('balloons:rooms:keys', encodeURIComponent(req.body.room_name), function(err, roomKey) {\n    if(!err && roomKey) {\n      res.redirect( '/' + roomKey );\n    } else {\n      fn()\n    }\n  });\n};\n\n/*\n * Creates a room\n */       \nexports.createRoom = function(req, res, client) {\n  var roomKey = exports.genRoomKey()\n    , room = {\n        key: roomKey,\n        name: req.body.room_name,\n        admin: req.user.provider + \":\" + req.user.username,\n        locked: 0,\n        online: 0\n      };\n\n  client.hmset('rooms:' + roomKey + ':info', room, function(err, ok) {\n    if(!err && ok) {\n      client.hset('balloons:rooms:keys', encodeURIComponent(req.body.room_name), roomKey);\n      client.sadd('balloons:public:rooms', roomKey);\n      res.redirect('/' + roomKey);\n    } else {\n      res.send(500);\n    }\n  });\n};\n\n/*\n * Get Room Info\n */\n\nexports.getRoomInfo = function(req, res, client, fn) { \n  client.hgetall('rooms:' + req.params.id + ':info', function(err, room) {\n    if(!err && room && Object.keys(room).length) fn(room);\n    else res.redirect('back');\n  });\n};\n\nexports.getPublicRoomsInfo = function(client, fn) {\n  client.smembers('balloons:public:rooms', function(err, publicRooms) {\n    var rooms = []\n      , len = publicRooms.length;\n    if(!len) fn([]);\n\n    publicRooms.sort(exports.caseInsensitiveSort);\n\n    publicRooms.forEach(function(roomKey, index) {\n      client.hgetall('rooms:' + roomKey + ':info', function(err, room) {\n        // prevent for a room info deleted before this check\n        if(!err && room && Object.keys(room).length) {\n          // add room info\n          rooms.push({\n            key: room.key || room.name, // temp\n            name: room.name,\n            online: room.online || 0\n          });\n\n          // check if last room\n          if(rooms.length == len) fn(rooms);\n        } else {\n          // reduce check length\n          len -= 1;\n        }\n      });\n    });\n  });\n};\n/*\n * Get connected users at room\n */\n\nexports.getUsersInRoom = function(req, res, client, room, fn) {\n  client.smembers('rooms:' + req.params.id + ':online', function(err, online_users) {\n    var users = [];\n\n    online_users.forEach(function(userKey, index) {\n      client.get('users:' + userKey + ':status', function(err, status) {\n        var msnData = userKey.split(':')\n          , username = msnData.length > 1 ? msnData[1] : msnData[0]\n          , provider = msnData.length > 1 ? msnData[0] : \"twitter\";\n\n        users.push({\n            username: username,\n            provider: provider,\n            status: status || 'available'\n        });\n      });\n    });\n\n    fn(users);\n\n  });\n};\n\n/*\n * Get public rooms\n */\n\nexports.getPublicRooms = function(client, fn){\n  client.smembers(\"balloons:public:rooms\", function(err, rooms) {\n    if (!err && rooms) fn(rooms);\n    else fn([]);\n  });\n};\n/*\n * Get User status\n */\n\nexports.getUserStatus = function(user, client, fn){\n  client.get('users:' + user.provider + \":\" + user.username + ':status', function(err, status) {\n    if (!err && status) fn(status);\n    else fn('available');\n  });\n};\n\n/*\n * Enter to a room\n */\n\nexports.enterRoom = function(req, res, room, users, rooms, status){\n  res.locals({\n    room: room,\n    rooms: rooms,\n    user: {\n      nickname: req.user.username,\n      provider: req.user.provider,\n      status: status\n    },\n    users_list: users\n  });\n  res.render('room');\n};\n\n/*\n * Sort Case Insensitive\n */\n\nexports.caseInsensitiveSort = function (a, b) { \n   var ret = 0;\n\n   a = a.toLowerCase();\n   b = b.toLowerCase();\n\n   if(a > b) ret = 1;\n   if(a < b) ret = -1; \n\n   return ret;\n};\n\n/**\n * Merge object `b` into `a`.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api public\n */\n\nexports.merge = function merge(a, b) {\n  for (var key in b) {\n    if (exports.has.call(b, key) && b[key]) {\n      if ('object' === type(b[key])) {\n        if ('undefined' === type(a[key])) a[key] = {};\n        exports.merge(a[key], b[key]);\n      } else {\n        a[key] = b[key];\n      }\n    }\n  }\n  return a;\n};\n\n/**\n * HOP \n */\n\nexports.has = Object.prototype.hasOwnProperty;\n"
        },
        {
          "name": "views",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}