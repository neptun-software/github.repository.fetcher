{
  "metadata": {
    "timestamp": 1736711747709,
    "page": 11,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cocktailpeanut/dalai",
      "stars": 13106,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.083984375,
          "content": ".env\n.DS_Store\nvenv\nnode_modules\nllama.cpp\npackage-lock.json\nyarn.lock\nllama/\nalpaca/\n"
        },
        {
          "name": ".npmrc",
          "type": "blob",
          "size": 0.0185546875,
          "content": "engine-strict=true\n"
        },
        {
          "name": ".prettierignore",
          "type": "blob",
          "size": 0.0009765625,
          "content": "*"
        },
        {
          "name": ".prettierrc.json",
          "type": "blob",
          "size": 0.01953125,
          "content": "{\n    \"semi\": true\n}"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.626953125,
          "content": "FROM python:3.10-slim-buster\n\n# The dalai server runs on port 3000\nEXPOSE 3000\n\n# Install dependencies\nRUN apt-get update \\\n    && apt-get install -y \\\n        build-essential \\\n        curl \\\n        g++ \\\n\tgit \\\n        make \\\n        python3-venv \\\n        software-properties-common\n\n# Add NodeSource PPA to get Node.js 18.x\nRUN curl -fsSL https://deb.nodesource.com/setup_18.x | bash -\n\n# Install Node.js 18.x\nRUN apt-get update \\\n    && apt-get install -y nodejs\n\nWORKDIR /root/dalai\n\n# Install dalai and its dependencies\nRUN npm install dalai@0.3.1\n\nRUN npx dalai alpaca setup\n\n\n# Run the dalai server\nCMD [ \"npx\", \"dalai\", \"serve\" ]\n\n"
        },
        {
          "name": "alpaca.js",
          "type": "blob",
          "size": 4.7421875,
          "content": "const path = require('path');\nconst term = require( 'terminal-kit' ).terminal;\nconst git = require('isomorphic-git');\nconst Downloader = require(\"nodejs-file-downloader\");\nconst http = require('isomorphic-git/http/node');\nconst os = require('os');\nconst fs = require(\"fs\");\nconst platform = os.platform()\nclass Alpaca {\n  constructor(root) {\n    this.root = root\n    this.home = path.resolve(this.root.home, \"alpaca\")\n    //this.url = \"https://github.com/candywrap/alpaca.cpp.git\"\n    this.url = \"https://github.com/ItsPi3141/alpaca.cpp\"\n  }\n  async make() {\n    let success\n    if (platform === \"win32\") {\n      // CMake on Windows\n      const venv_path = path.join(this.root.home, \"venv\")\n      const cmake_path = path.join(venv_path, \"Scripts\", \"cmake\")\n      await this.root.exec(\"mkdir build\", this.home)      \n      await this.root.exec(`Remove-Item -path ${path.resolve(this.home, \"build\", \"CMakeCache.txt\")}`, this.home)\n\n      let PS_COUNTER = 0\n      await this.root.exec(`${cmake_path} ..`, path.resolve(this.home, \"build\"), (proc, data) => {\n        console.log(\"#\", data);\n        if (/^PS .*/.test(data)) {\n          PS_COUNTER++;\n          if (PS_COUNTER >= 2) {\n            console.log(\"KILL\")\n            proc.kill()\n          }\n        }\n      })\n      PS_COUNTER = 0;\n      await this.root.exec(`${cmake_path} --build . --config Release`, path.resolve(this.home, \"build\"), (proc, data) => {\n        console.log(\"#\", data);\n        if (/^PS .*/.test(data)) {\n          PS_COUNTER++;\n          if (PS_COUNTER >= 2) {\n            console.log(\"KILL2\")\n            proc.kill()\n          }\n        }\n      })\n    } else {\n      // Make on linux + mac\n      success = await this.root.exec(`make`, this.home)\n      if (!success) {\n        throw new Error(\"running 'make' failed\")\n      }\n    }\n  }\n  async add (...models) {\n    models = models.map((m) => {\n      return m.toUpperCase()\n    })\n    console.log(\"alpaca.add\", models)\n    for(let model of models) {\n      const venv_path = path.join(this.root.home, \"venv\")\n      const python_path = platform == \"win32\" ? path.join(venv_path, \"Scripts\", \"python.exe\") : path.join(venv_path, 'bin', 'python')\n      /**************************************************************************************************************\n      *\n      * 5. Download models + convert + quantize\n      *\n      **************************************************************************************************************/\n      const outputFile = path.resolve(this.home, 'models', model, 'ggml-model-q4_0.bin')\n      if (fs.existsSync(outputFile)) {\n        console.log(`Skip conversion, file already exists: ${outputFile}`)\n      } else {\n        const dir = path.resolve(this.home, \"models\", model)\n        console.log(\"dir\", dir)\n        await fs.promises.mkdir(dir, { recursive: true }).catch((e) => {\n          console.log(\"mkdir\", e)\n        })\n        console.log(\"downloading torrent\")\n        let url\n        switch (model) {\n          case \"7B\":\n            //await this.root.torrent.add('magnet:?xt=urn:btih:5aaceaec63b03e51a98f04fd5c42320b2a033010&dn=ggml-alpaca-7b-q4.bin&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337%2Fannounce&tr=udp%3A%2F%2Fopentracker.i2p.rocks%3A6969%2Fannounce', dir)\n            //console.log(\"renaming\")\n            //await fs.promises.rename(\n            //  path.resolve(dir, \"ggml-alpaca-7b-q4.bin\"),\n            //  path.resolve(dir, \"ggml-model-q4_0.bin\")\n            //)\n            url = \"https://huggingface.co/Pi3141/alpaca-7B-ggml/resolve/main/ggml-model-q4_0.bin\"\n            await this.root.down(url, path.resolve(dir, \"ggml-model-q4_0.bin\"))\n            break;\n          \n          case \"13B\":\n            /*\n            await this.root.torrent.add('magnet:?xt=urn:btih:053b3d54d2e77ff020ebddf51dad681f2a651071&dn=ggml-alpaca-13b-q4.bin&tr=udp%3A%2F%2Ftracker.opentrackr.org%3A1337%2Fannounce&tr=udp%3A%2F%2Fopentracker.i2p.rocks%3A6969%2Fannounce&tr=udp%3A%2F%2Ftracker.openbittorrent.com%3A6969%2Fannounce&tr=udp%3A%2F%2F9.rarbg.com%3A2810%2Fannounce', dir)\n            console.log(\"renaming\")\n            await fs.promises.rename(\n              path.resolve(dir, \"ggml-alpaca-13b-q4.bin\"),\n              path.resolve(dir, \"ggml-model-q4_0.bin\")\n            )\n            */\n            url = \"https://huggingface.co/Pi3141/alpaca-13B-ggml/resolve/main/ggml-model-q4_0.bin\"\n            await this.root.down(url, path.resolve(dir, \"ggml-model-q4_0.bin\"))\n            break;\n\n          case \"30B\":\n            url = \"https://huggingface.co/Pi3141/alpaca-30B-ggml/resolve/main/ggml-model-q4_0.bin\"\n            await this.root.down(url, path.resolve(dir, \"ggml-model-q4_0.bin\"))\n            break;\n          \n          default:\n            console.log(\"Select either model 7B, 13B, or 30B\")\n            break;\n        }\n      }\n    }\n  }\n\n}\nmodule.exports = Alpaca\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmds",
          "type": "tree",
          "content": null
        },
        {
          "name": "dalai",
          "type": "blob",
          "size": 0.03125,
          "content": "#!/bin/bash\n\nnode bin/cli.js $@\n"
        },
        {
          "name": "demo",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.1689453125,
          "content": "version: '3.7'\nservices:\n  dalai:\n    build: .\n    ports:\n      - 3000:3000\n    volumes:\n      - ./models/alpaca:/root/dalai/alpaca\n      - ./models/llama:/root/dalai/llama\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "index.js",
          "type": "blob",
          "size": 20.0390625,
          "content": "const os = require('os');\nconst pty = require('node-pty');\n//const pty = require('@cdktf/node-pty-prebuilt-multiarch');\nconst git = require('isomorphic-git');\nconst http = require('isomorphic-git/http/node');\nconst Http = require(\"http\")\nconst path = require('path');\nconst fs = require(\"fs\");\nconst tar = require('tar');\nconst { createServer } = require(\"http\");\nconst { Server } = require(\"socket.io\");\nconst { io } = require(\"socket.io-client\");\nconst term = require( 'terminal-kit' ).terminal;\nconst Downloader = require(\"nodejs-file-downloader\");\nconst semver = require('semver');\n//const _7z = require('7zip-min');\nconst axios = require('axios')\nconst platform = os.platform()\nconst shell = platform === 'win32' ? 'powershell.exe' : 'bash';\nconst L = require(\"./llama\")\nconst A = require(\"./alpaca\")\nconst TorrentDownloader = require(\"./torrent\")\nconst exists = s => new Promise(r=>fs.access(s, fs.constants.F_OK, e => r(!e)))\nconst escapeNewLine = (platform, arg) => platform === 'win32' ? arg.replaceAll(/\\n/g, \"\\\\n\").replaceAll(/\\r/g, \"\\\\r\") : arg\nconst escapeDoubleQuotes = (platform, arg) => platform === 'win32' ? arg.replaceAll(/\"/g, '`\"') : arg.replaceAll(/\"/g, '\\\\\"')\nconst stripAnsi = (str) => {\n  const pattern = [\n    '[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n    '(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]))'\n  ].join('|');\n\n  const regex = new RegExp(pattern, 'g')\n  return str.replace(regex, '');\n}\nconst winEscape = (str) => {\n  return str\n  .replaceAll(/\\\\n/g, \"\\n\")\n  .replaceAll(/\\\\r/g, \"\\r\")\n  .replaceAll(/\\\\t/g, \"\\t\")\n  .replaceAll(/\\\\b/g, \"\\b\")\n  .replaceAll(/\\\\f/g, \"\\f\")\n  .replaceAll(/\\\\/g, \"\")\n}\n\nclass Dalai {\n  constructor(home) {\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    //\n    // 1. manually set llama.cpp home\n    // 2. otherwise store llama.cpp at ~/llama.cpp\n    //\n    //  # NOTE\n    //  Could have used process.cwd() (The current execution directory) to download llama.cpp\n    //  but this makes it cumbersome as you try to build multiple apps, because by default Dalai client will\n    //  look for the current execution directory for llama.cpp.\n    //  It's simpler to set the ~/llama.cpp as the default directory and use that path as the single source\n    //  of truth and let multiple apps all connect to that path\n    //  Otherwise if you want to customize the path you can just pass in the \"home\" attribute to manually set it.\n    //\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    this.home = home ? path.resolve(home) : path.resolve(os.homedir(), \"dalai\")\n    try {\n      console.log(\"mkdir\", this.home)\n      fs.mkdirSync(this.home, { recursive: true })\n    } catch (e) {\n      console.log(\"E\", e)\n    }\n    this.torrent = new TorrentDownloader()\n    this.config = {\n      name: 'xterm-color',\n      cols: 1000,\n      rows: 30,\n    }\n    this.cores = {\n      llama: new L(this),\n      alpaca: new A(this),\n    }\n  }\n  htmlencode (str) {\n    let encodedStr = '';\n    for (let i = 0; i < str.length; i++) {\n      let charCode = str.charCodeAt(i);\n      if (charCode < 128) {\n        // ASCII characters\n        switch (str[i]) {\n          case '<': encodedStr += '&lt;'; break;\n          case '>': encodedStr += '&gt;'; break;\n          case '&': encodedStr += '&amp;'; break;\n          case '\"': encodedStr += '&quot;'; break;\n          case '\\'': encodedStr += '&#39;'; break;\n          case '\\n': encodedStr += '<br>'; break;\n          case '\\r': break; // ignore\n          case '\\t': encodedStr += '&nbsp;&nbsp;&nbsp;&nbsp;'; break;\n          case '\\b': encodedStr += '&nbsp;'; break;\n          case '\\f': encodedStr += '&nbsp;'; break;\n          default: encodedStr += String.fromCharCode(charCode); break;\n        }\n      } else {\n        // Non-ASCII characters\n        encodedStr += \"&#\" + charCode + \";\";\n      }\n    }\n    return encodedStr;\n  }\n  down(url, dest, headers) {\n    return new Promise((resolve, reject) => {\n      const task = path.basename(dest)\n      this.startProgress(task)\n      axios({\n        url,\n        method: 'GET',\n        responseType: 'stream',\n        maxContentLength: Infinity,\n        headers,\n        onDownloadProgress: progressEvent => {\n          const progress = (progressEvent.loaded / progressEvent.total) * 100;\n          this.progress(task, progress)\n        }\n\n      }).then(response => {\n        const writer = fs.createWriteStream(dest);\n        response.data.pipe(writer);\n        writer.on('finish', () => {\n          this.progressBar.update(1);\n          term(\"\\n\")\n          resolve()\n        });\n      }).catch(error => {\n        reject(error)\n      });\n    })\n  }\n  async python () {\n    // install self-contained python => only for windows for now\n    // 1. download\n    // 2. unzip\n\n    const filename = \"cpython-3.10.9+20230116-x86_64-pc-windows-msvc-shared-install_only.tar.gz\"\n    const task = \"downloading self contained python\"\n    const downloader = new Downloader({\n      url: `https://github.com/indygreg/python-build-standalone/releases/download/20230116/${filename}`,\n      directory: this.home,\n      onProgress: (percentage, chunk, remainingSize) => {\n        this.progress(task, percentage)\n      },\n    });\n    try {\n      await this.startProgress(task)\n      await downloader.download();\n    } catch (error) {\n      console.log(error);\n    }\n    this.progressBar.update(1);\n    console.log(\"extracting python\")\n    await tar.x({\n      file: path.resolve(this.home, filename),\n      C: this.home,\n      strict: true\n    })\n    console.log(\"cleaning up temp files\")\n    await fs.promises.rm(path.resolve(this.home, filename))\n  }\n//  async mingw() {\n//    const mingw = \"https://github.com/niXman/mingw-builds-binaries/releases/download/12.2.0-rt_v10-rev2/x86_64-12.2.0-release-win32-seh-msvcrt-rt_v10-rev2.7z\"\n//    const downloader = new Downloader({\n//      url: mingw,\n//      directory: this.home,\n//      onProgress: (percentage, chunk, remainingSize) => {\n//        this.progress(\"download mingw\", percentage)\n//      },\n//    });\n//    try {\n//      await this.startProgress(\"download mingw\")\n//      await downloader.download();\n//    } catch (error) {\n//      console.log(error);\n//    }\n//    this.progressBar.update(1);\n//    await new Promise((resolve, reject) => {\n//      _7z.unpack(path.resolve(this.home, \"x86_64-12.2.0-release-win32-seh-msvcrt-rt_v10-rev2.7z\"), this.home, (err) => {\n//        if (err) { \n//          reject(err)\n//        } else {\n//          resolve()\n//        }\n//      })\n//    })\n//    console.log(\"cleaning up temp files\")\n//    await fs.promises.rm(path.resolve(this.home, \"x86_64-12.2.0-release-win32-seh-msvcrt-rt_v10-rev2.7z\"))\n//  }\n  async query(req, cb) {\n    \n    console.log(`> query:`, req)\n    if (req.method === \"installed\") {\n      let models = await this.installed()\n      for(let model of models) {\n        cb(model)\n      }\n      cb('\\n\\n<end>')\n      return\n    }\n\n    if (req.prompt && req.prompt.startsWith(\"/\")) {\n      try {\n        const mod = require(`./cmds/${req.prompt.slice(1)}`)\n        if (mod) {\n          mod(this)\n          return\n        }\n      } catch (e) {\n        console.log(\"require log\", e)\n      }\n    }\n\n    if (!req.prompt) {\n      return\n    }\n\n    let [Core, Model] = req.model.split(\".\")\n    Model = Model.toUpperCase()\n\n    console.log( { Core, Model } )\n\n    let o = {\n      seed: req.seed || -1,\n      threads: req.threads || 8,\n      n_predict: req.n_predict || 128,\n      model: `models/${Model || \"7B\"}/ggml-model-q4_0.bin`,\n    }\n\n    let e = await exists(path.resolve(this.home, Core, \"models\", Model))\n    if (!e) {\n      cb(`File does not exist: ${Model}. Try \"dalai ${Core} get ${Model}\" first.`)\n      return\n    }\n\n    if (req.top_k) o.top_k = req.top_k\n    if (req.top_p) o.top_p = req.top_p\n    if (req.temp) o.temp = req.temp\n    if (req.batch_size) o.batch_size = req.batch_size\n    if (req.repeat_last_n) o.repeat_last_n = req.repeat_last_n\n    if (req.repeat_penalty) o.repeat_penalty = req.repeat_penalty\n    if (typeof req.interactive !== \"undefined\") o.interactive = req.interactive\n\n    let chunks = []\n    for(let key in o) {\n      chunks.push(`--${key} ${escapeDoubleQuotes(platform, o[key].toString())}`)\n    }\n    const escaped = escapeNewLine(platform, req.prompt)\n    const prompt = `\"${escapeDoubleQuotes(platform, escaped)}\"`\n\n    chunks.push(`-p ${prompt}`)\n\n    const main_bin_path = platform === \"win32\" ? path.resolve(this.home, Core, \"build\", \"Release\", \"main\") : path.resolve(this.home, Core, \"main\")\n    this.sessionBuffer = \"\";\n    this.bufferStarted = false;\n    if (req.full) {\n      await this.exec(`${main_bin_path} ${chunks.join(\" \")}`, this.cores[Core].home, cb)\n    } else {\n      const startpattern = /.*sampling parameters:.*/g\n      const endpattern = /.*mem per token.*/g\n      let started = req.debug\n      let ended = false\n      let writeEnd = !req.skip_end\n      await this.exec(`${main_bin_path} ${chunks.join(\" \")}`, this.cores[Core].home, (proc, msg) => {\n        if (endpattern.test(msg)) ended = true\n        if (started && !ended) {\n          this.buffer(req, msg, cb)\n        } else if (ended && writeEnd) {\n          cb('\\n\\n<end>')\n          writeEnd = false\n        }\n        if (startpattern.test(msg)) started = true\n      })\n    }\n  }\n  buffer(req, msg, cb) {\n    if (!this.queue) this.queue = []\n    if (platform === \"win32\") {\n      for(let i=0;i<msg.length; i++) {\n        if (msg[i] === \"\\\\\") {\n          this.queueActive = true\n          // start pushing to buffer\n          this.queue.push(msg[i]);\n        } else {\n          // otherwise flush\n          this.queue.push(msg[i])\n          let queueContent = this.queue.join(\"\")\n          \n          if (!this.bufferStarted && [\"\\n\", \"\\b\", \"\\f\", \"\\r\", \"\\t\"].includes(queueContent)) {\n            // if the buffer hasn't started and incoming tokens are whitespaces, ignore\n          } else {\n            if (req.html) {\n              cb(this.htmlencode(winEscape(queueContent)))\n            } else {\n              cb(winEscape(queueContent))\n            }\n            this.bufferStarted = true\n          }\n          this.queue = []\n          this.queueActive = false\n        }\n      }\n    } else {\n      if (req.html) {\n        cb(this.htmlencode(msg))\n      } else {\n        cb(msg)\n      } \n    }\n  }\n  async uninstall(core, ...models) {\n    if (models.length > 0) {\n      // delete the model folder\n      const modelsPath = path.resolve(this.home, core, \"models\")\n      for(let model of models) {\n        const modelPath = path.resolve(modelsPath, model)\n        console.log(\"rm\", modelPath)\n        await fs.promises.rm(modelPath, { recursive: true, force: true }).catch((e) => {\n          console.log(\"rm\", modelPath, e)\n        })\n      }\n    }\n  }\n  async install(core, ...models) {\n\n    let engine = this.cores[core]\n\n    const venv_path = path.join(this.home, \"venv\")\n    let ve = await exists(venv_path)\n    if (!ve) {\n      await this.setup()\n    }\n\n    // temporary\n\n    let models_path = path.resolve(engine.home, \"models\")\n    let temp_path = path.resolve(this.home, \"tmp\")\n    let temp_models_path = path.resolve(temp_path, \"models\")\n    await fs.promises.mkdir(temp_path, { recursive: true }).catch((e) => { console.log(\"1\", e) })\n    // 1. move the models folder to ../tmp\n    await fs.promises.rename(models_path, temp_models_path).catch((e) => { console.log(\"2\", e) })\n    // 2. wipe out the folder\n    await fs.promises.rm(engine.home, { recursive: true }).catch((e) => { console.log(\"3\", e) })\n    // 3. install engine\n    await this.add(core)\n    // 4. move back the files inside /tmp\n    await fs.promises.rename(temp_models_path, models_path).catch((e) => { console.log(\"4\", e) })\n\n    // next add the models\n    let res = await this.cores[core].add(...models)\n    return res\n  }\n  async installed() {\n    // get cores\n    const modelNames = []\n    for(let core of [\"alpaca\", \"llama\"]) {\n      const modelsPath = path.resolve(this.home, core, \"models\")\n      console.log(\"modelsPath\", modelsPath)\n      let modelFolders = []\n      try {\n        modelFolders = (await fs.promises.readdir(modelsPath, { withFileTypes: true }))\n          .filter(dirent => dirent.isDirectory())\n          .map(dirent => dirent.name)\n      } catch (e) {\n      }\n\n      console.log({ modelFolders })\n      for(let modelFolder of modelFolders) {\n        let e = await exists(path.resolve(modelsPath, modelFolder, 'ggml-model-q4_0.bin'))\n        if (e) {\n          modelNames.push(`${core}.${modelFolder}`)\n          console.log(\"exists\", modelFolder)\n        }\n      }\n    }\n    return modelNames\n  }\n  async add (core) {\n    /**************************************************************************************************************\n    *\n    * 2. Download Core\n    *\n    **************************************************************************************************************/\n    let engine = this.cores[core]\n    let e = await exists(path.resolve(engine.home));\n    console.log(\"mkdir\", path.resolve(engine.home))\n    await fs.promises.mkdir(path.resolve(engine.home), { recursive: true }).catch((e) => {\n      console.log(\"ERROR\" ,e)\n    })\n\n    try {\n      console.log(\"try fetching\", engine.home, engine.url)\n      await git.pull({ fs, http, dir: engine.home, url: engine.url })\n    } catch (e) {\n      console.log(\"[E] Pull\", e)\n      try {\n        console.log(\"try cloning\", engine.home, engine.url)\n        await git.clone({ fs, http, dir: engine.home, url: engine.url })\n      } catch (e2) {\n        console.log(\"[E] Clone\", e2)\n      }\n    }\n    console.log(\"next\", core, engine.make);\n    /**************************************************************************************************************\n    *\n    * 4. Compile & Build\n    *   - make: linux + mac\n    *   - cmake: windows\n    *\n    **************************************************************************************************************/\n    await engine.make()\n  }\n  async setup() {\n\n    let success;\n\n    /**************************************************************************************************************\n    *\n    * 1. Validate\n    *\n    **************************************************************************************************************/\n    // Check if current version is greater than or equal to 18\n    const node_version = process.version;\n    if (!semver.gte(node_version, '18.0.0')) {\n      throw new Error(\"outdated Node version, please install Node 18 or newer\")\n    }\n\n    /**************************************************************************************************************\n    *\n    * 3. Download Global Dependencies\n    *   - Python (windows only)\n    *   - build-essential (linux only)\n    *   - virtualenv\n    *   - torch, numpy, etc.\n    *\n    **************************************************************************************************************/\n\n    // 3.1. Python: Windows doesn't ship with python, so install a dedicated self-contained python\n    if (platform === \"win32\") {\n      await this.python() \n    }\n    const root_python_paths = (platform === \"win32\" ? [\"python3\", \"python\", path.resolve(this.home, \"python\", \"python.exe\")] : [\"python3\", \"python\"])\n    const root_pip_paths = (platform === \"win32\" ? [\"pip3\", \"pip\", path.resolve(this.home, \"python\", \"python -m pip\")] : [\"pip3\", \"pip\"])\n\n    // 3.2. Build tools\n    if (platform === \"linux\") {\n      // ubuntu debian\n      success = await this.exec(\"apt-get install build-essential python3-venv -y\")\n      if (!success) {\n        // fefdora\n        success = await this.exec(\"dnf install make automake gcc gcc-c++ kernel-devel python3-virtualenv -y\")\n      }\n    } else {\n      // for win32 / darwin\n      for(let root_pip_path of root_pip_paths) {\n        success = await this.exec(`${root_pip_path} install --user virtualenv`)\n        if (success) {\n          break;\n        }\n        success = await this.exec(`${root_pip_path} install virtualenv`)\n        if (success) {\n          break;\n        }\n      }\n      if (!success) {\n        throw new Error(\"cannot install virtualenv\")\n      }\n\n    }\n\n    // 3.3. virtualenv\n    const venv_path = path.join(this.home, \"venv\")\n    for(let root_python_path of root_python_paths) {\n      console.log(\"trying with\", root_python_path)\n      let code = await this.exec(`${root_python_path} -m venv ${venv_path}`)\n      console.log({ code })\n    }\n    /*\n    if (!success) {\n      throw new Error(\"cannot execute python3 or python\")\n      return\n    }\n    */\n\n    // 3.4. Python libraries\n    const pip_path = platform === \"win32\" ? path.join(venv_path, \"Scripts\", \"pip.exe\") : path.join(venv_path, \"bin\", \"pip\")\n    const python_path = platform == \"win32\" ? path.join(venv_path, \"Scripts\", \"python.exe\") : path.join(venv_path, 'bin', 'python')\n    // cmake (only on windows. the rest platforms use make)\n    if (platform === \"win32\") {\n      success = await this.exec(`${pip_path} install cmake`)\n      if (!success) {\n        throw new Error(\"cmake installation failed\")\n        return\n      }\n    }\n    success = await this.exec(`${pip_path} install --upgrade pip setuptools wheel`)\n    if (!success) {\n      success = await this.exec(`${pip_path} install --user --upgrade pip setuptools wheel`)\n      if (!success) {\n        throw new Error(\"pip setuptools wheel upgrade failed\")\n        return  \n      }\n    }\n    success = await this.exec(`${pip_path} install torch torchvision torchaudio sentencepiece numpy`)\n    //success = await this.exec(`${pip_path} install torch torchvision torchaudio sentencepiece numpy wget`)\n    if (!success) {\n      success = await this.exec(`${pip_path} install --user torch torchvision torchaudio sentencepiece numpy`)\n      if (!success) {\n        throw new Error(\"dependency installation failed\")\n        return  \n      }\n    }\n\n\n  }\n  serve(port, options) {\n    const httpServer = createServer();\n    const io = new Server(httpServer)\n    io.on(\"connection\", (socket) => {\n      socket.on('request', async (req) => {\n        await this.query(req, (str) => {\n          io.emit(\"result\", { response: str, request: req })\n        })\n      });\n    });\n    httpServer.listen(port)\n  }\n  http(httpServer) {\n    const io = new Server(httpServer)\n    io.on(\"connection\", (socket) => {\n      socket.on('request', async (req) => {\n        req.models = Array.from(new Set(req.models))\n        await this.query(req, (str) => {\n          io.emit(\"result\", { response: str, request: req })\n        })\n      });\n    });\n  }\n  async request(req, cb) {\n    if (req.url) {\n      await this.connect(req, cb)\n    } else {\n      await this.query(req, cb)\n    }\n  }\n  connect(req, cb) {\n    const socket = io(req.url)\n    socket.emit('request', req)\n    socket.on('response', cb)\n    socket.on('error', function(e) {\n      throw e\n    });\n  }\n  exec(cmd, cwd, cb) {\n    return new Promise((resolve, reject) => {\n      try {\n        const config = Object.assign({}, this.config)\n        if (cwd) {\n          config.cwd = path.resolve(cwd)\n        }\n        console.log(`exec: ${cmd} in ${config.cwd}`)\n        this.ptyProcess = pty.spawn(shell, [], config)\n        this.ptyProcess.onData((data) => {\n          if (cb) {\n            cb(this.ptyProcess, stripAnsi(data))\n          } else {\n            process.stdout.write(data);\n          }\n        });\n        this.ptyProcess.onExit((res) => {\n          if (res.exitCode === 0) {\n            // successful\n            resolve(true)\n          } else {\n            // something went wrong\n            resolve(false)\n          }\n        });\n\n        if (platform === \"win32\") {\n          this.ptyProcess.write(`[System.Console]::OutputEncoding=[System.Console]::InputEncoding=[System.Text.Encoding]::UTF8; ${cmd}\\r`)\n        } else {\n          this.ptyProcess.write(`${cmd}\\r`)\n        }\n        this.ptyProcess.write(\"exit\\r\")\n      } catch (e) {\n        console.log(\"caught error\", e)\n        this.ptyProcess.kill()\n        // ptyProcess.write(\"exit\\r\")\n      }\n    })\n  }\n  progress(task, percent) {\n    this.progressBar.update(percent/100);\n    //if (percent >= 100) {\n    //  setTimeout(() => {\n    //    term(\"\\n\")\n    //  }, 200)\n    //}\n  }\n  startProgress(title) {\n    this.progressBar = term.progressBar({\n      width: 120,\n      title,\n      eta: true ,\n      percent: true\n    });\n  }\n}\nmodule.exports = Dalai\n"
        },
        {
          "name": "llama.js",
          "type": "blob",
          "size": 5.6181640625,
          "content": "const path = require('path');\nconst term = require( 'terminal-kit' ).terminal;\nconst git = require('isomorphic-git');\nconst Downloader = require(\"nodejs-file-downloader\");\nconst http = require('isomorphic-git/http/node');\nconst os = require('os');\nconst fs = require(\"fs\");\nconst platform = os.platform()\nclass LLaMA {\n  constructor(root) {\n    this.root = root\n    this.home = path.resolve(this.root.home, \"llama\")\n    this.url = \"https://github.com/candywrap/llama.cpp.git\"\n  }\n  async make() {\n    console.log(\"make\")\n    let success\n    if (platform === \"win32\") {\n      // CMake on Windows\n      const venv_path = path.join(this.root.home, \"venv\")\n      const cmake_path = path.join(venv_path, \"Scripts\", \"cmake\")\n      await this.root.exec(\"mkdir build\", this.home)      \n      await this.root.exec(`Remove-Item -path ${path.resolve(this.home, \"build\", \"CMakeCache.txt\")}`, this.home)\n      let PS_COUNTER = 0\n      await this.root.exec(`${cmake_path} ..`, path.resolve(this.home, \"build\"), (proc, data) => {\n        console.log(\"# data\", data);\n        if (/^PS .*/.test(data)) {\n          PS_COUNTER++;\n          if (PS_COUNTER >= 2) {\n            console.log(\"KILL\")\n            proc.kill()\n          }\n        }\n      })\n      PS_COUNTER = 0;\n      await this.root.exec(`${cmake_path} --build . --config Release`, path.resolve(this.home, \"build\"), (proc, data) => {\n        console.log(\"# data\", data);\n        if (/^PS .*/.test(data)) {\n          PS_COUNTER++;\n          if (PS_COUNTER >= 2) {\n            console.log(\"KILL2\")\n            proc.kill()\n          }\n        }\n      })\n    } else {\n      // Make on linux + mac\n      success = await this.root.exec(`make`, this.home)\n      if (!success) {\n        throw new Error(\"running 'make' failed\")\n        return\n      }\n    }\n  }\n  async add (...models) {\n    if (models.length === 0) models = [\"7B\"]\n    models = models.map((m) => {\n      return m.toUpperCase()\n    })\n    for(let model of models) {\n      if (![\"7B\", \"13B\",  \"30B\", \"65B\"].includes(model)) {\n        console.log(`##########################################################\n#\n#   ERROR\n#   The arguments must be one or more of the following:\n# \n#   7B, 13B, 30B, 65B\n#\n##########################################################\n\n[Example]\n\n# install just 7B (default)\nnpx dalai install   \n\n# install 7B manually\nnpx dalai install 7B\n\n# install 7B and 13B\nnpx dalai install 7B 13B\n`)\n        throw new Error(\"The model name must be one of: 7B, 13B, 30B, and 65B\")\n        return\n      }\n    }\n\n    const venv_path = path.join(this.root.home, \"venv\")\n    const python_path = platform == \"win32\" ? path.join(venv_path, \"Scripts\", \"python.exe\") : path.join(venv_path, 'bin', 'python')\n    /**************************************************************************************************************\n    *\n    * 5. Download models + convert + quantize\n    *\n    **************************************************************************************************************/\n    for(let model of models) {\n      await this.download(model)\n      const outputFile = path.resolve(this.home, 'models', model, 'ggml-model-f16.bin')\n      // if (fs.existsSync(outputFile)) {\n      //   console.log(`Skip conversion, file already exists: ${outputFile}`)\n      // } else {\n        await this.root.exec(`${python_path} convert-pth-to-ggml.py models/${model}/ 1`, this.home)\n      // }\n      await this.quantize(model)\n    }\n  }\n  async quantize(model) {\n    let num = {\n      \"7B\": 1,\n      \"13B\": 2,\n      \"30B\": 4,\n      \"65B\": 8,\n    }\n    for(let i=0; i<num[model]; i++) {\n      const suffix = (i === 0 ? \"\" : `.${i}`)\n      const outputFile1 = path.resolve(this.home, `./models/${model}/ggml-model-f16.bin${suffix}`)\n      const outputFile2 = path.resolve(this.home, `./models/${model}/ggml-model-q4_0.bin${suffix}`)\n      if (fs.existsSync(outputFile1) && fs.existsSync(outputFile2)) {\n        console.log(`Skip quantization, files already exists: ${outputFile1} and ${outputFile2}}`)\n        continue\n      }\n      const bin_path = platform === \"win32\" ? path.resolve(this.home, \"build\", \"Release\") : this.home\n      await this.root.exec(`./quantize ${outputFile1} ${outputFile2} 2`, bin_path)\n    }\n  }\n  async download(model) {\n    console.log(`Download model ${model}`)\n    const venv_path = path.join(this.root.home, \"venv\")\n    const python_path = platform == \"win32\" ? path.join(venv_path, \"Scripts\", \"python.exe\") : path.join(venv_path, 'bin', 'python')\n    const num = {\n      \"7B\": 1,\n      \"13B\": 2,\n      \"30B\": 4,\n      \"65B\": 8,\n    }\n    const files = [\"checklist.chk\", \"params.json\"]\n    for(let i=0; i<num[model]; i++) {\n      files.push(`consolidated.0${i}.pth`)\n    }\n    const resolvedPath = path.resolve(this.home, \"models\", model)\n    await fs.promises.mkdir(resolvedPath, { recursive: true }).catch((e) => { })\n\n    for(let file of files) {\n     if (fs.existsSync(path.resolve(resolvedPath, file))) {\n       console.log(`Skip file download, it already exists: ${file}`)\n       continue;\n     }\n\n      const url = `https://agi.gpt4.org/llama/LLaMA/${model}/${file}`\n      await this.root.down(url, path.resolve(resolvedPath, file), {\n        \"User-Agent\": \"Mozilla/5.0\"\n      })\n    }\n\n    const files2 = [\"tokenizer_checklist.chk\", \"tokenizer.model\"]\n    for(let file of files2) {\n//      if (fs.existsSync(path.resolve(this.home, \"models\", file))) {\n//        console.log(`Skip file download, it already exists: ${file}`)\n//        continue;\n//      }\n      const url = `https://agi.gpt4.org/llama/LLaMA/${file}`\n      const dir = path.resolve(this.home, \"models\")\n      await this.root.down(url, path.resolve(dir, file), {\n        \"User-Agent\": \"Mozilla/5.0\"\n      })\n    }\n\n  }\n}\nmodule.exports = LLaMA\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.876953125,
          "content": "{\n  \"name\": \"dalai\",\n  \"version\": \"0.3.1\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"author\": \"cocktailpeanut\",\n  \"license\": \"MIT\",\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"scripts\": {\n    \"dalai:llama\": \"./dalai llama\",\n    \"start\": \"./dalai serve\",\n    \"just:run\": \"wrap () { yarn && yarn dalai:llama $1 && yarn start; }; wrap\",\n    \"just:fix\": \"npx prettier --write .\",\n    \"postinstall\": \"node setup\"\n  },\n  \"dependencies\": {\n    \"axios\": \"^1.3.4\",\n    \"ejs\": \"^3.1.8\",\n    \"express\": \"^4.18.2\",\n    \"isomorphic-git\": \"^1.22.0\",\n    \"node-pty\": \"^0.10.1\",\n    \"nodejs-file-downloader\": \"^4.10.6\",\n    \"semver\": \"^7.3.8\",\n    \"socket.io\": \"^4.6.1\",\n    \"socket.io-client\": \"^4.6.1\",\n    \"tar\": \"^6.1.13\",\n    \"terminal-kit\": \"^3.0.0\",\n    \"webtorrent\": \"1.9.7\",\n    \"yargs\": \"^17.7.1\"\n  },\n  \"devDependencies\": {\n    \"prettier\": \"^2.8.4\"\n  },\n  \"bin\": {\n    \"dalai\": \"bin/cli.js\"\n  }\n}\n"
        },
        {
          "name": "setup.js",
          "type": "blob",
          "size": 0.1767578125,
          "content": "const Dalai = require(\"./index\")\nnew Dalai().setup().then(() => {\n  console.log(\"executed setup\")\n  process.exit(0)\n}).catch((e) => {\n  console.log(\"Error\", e)\n  process.exit(1)\n})\n"
        },
        {
          "name": "torrent.js",
          "type": "blob",
          "size": 1.6083984375,
          "content": "const WebTorrent = require('webtorrent')\nconst term = require( 'terminal-kit' ).terminal;\nconst path = require('path')\nconst fs = require('fs')\nclass TorrentDownloader {\n  constructor() {\n    this.client = new WebTorrent()\n    this.start = {}\n    this.progressbar = {}\n  }\n  add(url, folder, cb) {\n    return new Promise((resolve, reject) => {\n      let e = fs.existsSync(folder)\n      if (!e) {\n        fs.mkdirSync(folder, { recursive: true })\n      }\n      this.client.add(url, { path: folder }, (torrent) => {\n        this.progressbar[url] = term.progressBar({\n          width: 120,\n          title: torrent.name,\n          eta: true,\n          percent: true\n        });\n        torrent.on('metadata', (m) => {\n          this.start[torrent.name] = Date.now()\n          console.log({ metadata: m })\n          term(\"\\n\")\n        })\n        torrent.on('download', bytes => {\n          if (cb) {\n            cb({ progress: torrent.progress, speed: torrent.downloadSpeed, downloaded: torrent.downloaded })\n          }\n          this.progressbar[url].update(torrent.progress)\n        })\n        torrent.on('done', () => {\n          console.log('torrent download finished')\n          const end = Date.now()\n          const elapsed = end - this.start[torrent.name]\n          console.log({ start: this.start[torrent.name], end: end, elapsed })\n          this.progressbar[url].update(1)\n          term(\"\\n\")\n          resolve(torrent)\n          for (const file of torrent.files) {\n            // do something with file\n            console.log(\"file\", file.name, file.size)\n          }\n        })\n      })\n    })\n  }\n}\nmodule.exports = TorrentDownloader\n"
        }
      ]
    }
  ]
}