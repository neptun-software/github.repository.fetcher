{
  "metadata": {
    "timestamp": 1736710660963,
    "page": 14,
    "hasNextPage": false,
    "endCursor": "Y3Vyc29yOjE1",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jonataslaw/getx",
      "stars": 10537,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".DS_Store",
          "type": "blob",
          "size": 10.00390625,
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.9013671875,
          "content": "# See https://www.dartlang.org/guides/libraries/private-files\n\n# See https://www.dartlang.org/guides/libraries/private-files\n\n# Files and directories created by pub\n.dart_tool/\n.packages\nbuild/\n# If you're building an application, you may want to check-in your pubspec.lock\npubspec.lock\n.pub/\n\n# Directory created by dartdoc\n# If you don't generate documentation locally you can remove this line.\ndoc/api/\n\n# Avoid committing generated Javascript files:\n*.dart.js\n*.info.json      # Produced by the --dump-info flag.\n*.js             # When generated by dart2js. Don't specify *.js if your\n                 # project includes source files written in JavaScript.\n*.js_\n*.js.deps\n*.js.map\n\n# Files and directories created when test or run example\nexample/android/local.properties\nexample/ios/\nexample/.dart_tool/\nexample/.packages\n\n# IntelliJ\n*.iml\n.idea/*\n#.idea/workspace.xml\n#.idea/tasks.xml\n#.idea/gradle.xml\n#.idea/assetWizardSettings.xml\n#.idea/dictionaries\n#.idea/libraries\n#.idea/caches\n\n# User-specific stuff\n.idea/**/workspace.xml\n.idea/**/tasks.xml\n.idea/**/dictionaries\n.idea/**/shelf\n\n# Sensitive or high-churn files\n.idea/**/dataSources/\n.idea/**/dataSources.ids\n.idea/**/dataSources.local.xml\n.idea/**/sqlDataSources.xml\n.idea/**/dynamic.xml\n.idea/**/uiDesigner.xml\n.idea/**/dbnavigator.xml\n\n# Gradle\n.idea/**/gradle.xml\n.idea/**/libraries\n\n# Android Studio Navigation editor temp files\n.navigation/\n\n# Android Studio captures folder\ncaptures/\n\n# External native build folder generated in Android Studio 2.2 and later\n.externalNativeBuild\n\n### https://raw.github.com/github/gitignore/80a8803b004013d17291196825a327b9e871f009/Global/VisualStudioCode.gitignore\n.vscode/*\n!.vscode/settings.json\n!.vscode/tasks.json\n!.vscode/launch.json\n!.vscode/extensions.json\n\nexample/macos/Flutter/ephemeral/Flutter-Generated.xcconfig\n\nexample/macos/Flutter/ephemeral/\n\nexample/macos/Flutter/GeneratedPluginRegistrant.swift\n\n# Coverage files\ncoverage/"
        },
        {
          "name": ".metadata",
          "type": "blob",
          "size": 0.2978515625,
          "content": "# This file tracks properties of this Flutter project.\n# Used by Flutter tool to assess capabilities and perform upgrades etc.\n#\n# This file should be version controlled and should not be manually edited.\n\nversion:\n  revision: 60bd88df915880d23877bfc1602e8ddcf4c4dd2a\n  channel: stable\n\nproject_type: app\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 57.0517578125,
          "content": "## [5.0.0-release-candidate-9.2.1]\n\n- Remove remaining dart:html references\n\n## [5.0.0-release-candidate-9.2]\n\n- Remove dart:html references\n\n## [5.0.0-release-candidate-9.1]\n\n- Add canPop to GetPage\n- Fix Get.offNamedUntil\n- Fix GetObserver\n\n## [5.0.0-release-candidate-9]\n\n- Fix redirectDelegate middleware\n- Fix Get.until\n\n## [5.0.0-release-candidate-8]\n\n- Add wasm compilation support to GetConnect\n- Refactor example\n\n## [5.0.0-release-candidate-7]\n\n- Fix latest flutter version\n\n## [5.0.0-release-candidate-6]\n\n-Fix Snackbar, upgrade to flutter 3.22 @Aniketkhote, improve parse route @korutx, fix popScope @wowbox, improve defaultDialog @leeyi, add support to wasm compilation @Ty, fix typos @CodeWithEmad, fix snackbar cancel @seungsuyoo update GetConnect @DaZealous and @ wheeOs, add bengali language @aratheunseen, fix lint issues: @MuhammamdArslanKhan\n\n## [5.0.0-release-candidate-5]\n\n-Fix nested route issues, fixed issues in the latest flutter version\n\n## [5.0.0-release-candidate-4]\n\n-Fix changeThemeMode and RxList\n\n## [5.0.0-release-candidate-3]\n\n-Fix changeTheme\n\n## [5.0.0-release-candidate-2]\n\nThis version adds built-in support for animation in Flutter in an easy, clear way, and without having to create a StatefulWidget with controllers and animations. All you need to do is call the name of the animation.\n\nIf you want to add a \"fadeIn\" effect to any widget, simply add .fadeIn() to the end of it.\n\n```dart\n Container(\n              color: Colors.blue,\n              height: 100,\n              width: 100,\n       ).fadeIn(),\n```\n\nhttps://user-images.githubusercontent.com/35742643/221383556-075a0b71-1617-4a31-a3c7-1acc68732f59.mp4\n\nMaybe you want to merge two or more animations, just concatenate them at the end of the widget.\n\n```dart\n Container(\n              color: Colors.blue,\n              height: 100,\n              width: 100,\n      ).fadeIn().bounce(begin: -0.8, end: 0.3),\n```\n\nhttps://user-images.githubusercontent.com/35742643/221383613-9044c92f-7c6b-48c4-aa79-0a0c20d4068a.mp4\n\nCreating animation sequences in Flutter is one of the most painful things to do with the framework. You need to create tons of AnimationControllers. Well, using GetX 5 you just need to tell your animation that it is sequential. Just like that.\n\n```dart\n const FlutterLogo(size: 110)\n                        .bounce(begin: -0.8, end: 0.4)\n                        .fadeIn()\n                        .spin(isSequential: true)\n                        .wobble(isSequential: true, begin: 0, end: 8)\n                        .flip(isSequential: true)\n                        .fadeOut(isSequential: true),\n```\n\nResult:\n\nhttps://user-images.githubusercontent.com/35742643/221393968-20cb2411-516b-44a7-8b85-45090bece532.mp4\n\n## [5.0.0-release-candidate]\n\nRefactor StateManager, RouteManager and InstanceManager from scratch\nFixed Bugs\nAdded a Scopped DI\nApi now uses Navigator 2\nAdded new RouteOutlet\nAdded a new futurize method to StateMixin, that tracks updates, errors, and states programatically,\n\n## [4.6.1]\n\nFix GetConnect on Flutter web\n\n## [4.6.0]\n\nAdd useInheritedMediaQuery to GetMaterialApp and GetCupertinoApp (@davidhole)\nAdd Circular reveal Transition (@parmarravi)\nAdd request to failed response (@heftekharm)\nFix internationalization with only country code (@codercengiz)\nAdd GetTickerProviderStateMixin when multiple AnimationController objects are used (@NatsuOnFire)\nAdd the followRedirects and maxRedirects fields to the Request object (@wei53881)\nFix to rx.trigger fires twice (@gslender)\nAdd proxy setting support to GetConnect (@jtans)\nFix markAsDirty used on permanent controllers (@zenalex)\nUpdate Korean readme (@dumbokim)\n\n## [4.5.1]\n\nFix Snackbar when it have action and icon the same time\n\n## [4.5.0] - Big Update\n\nTo have a page-agnostic snackbar, we used OverlayRoute to display a partial route.\nHowever this had several problems:\n\n1: There was no possibility to close the page without closing the snackbar\n2: Get.back() could cause problems with tests of Get.isSnackbarOpen not being properly invoked\n3: Sometimes when using iOS popGesture with an open snackbar, some visual inconsistency might appear.\n4: When going to another route, the snackbar was not displayed on the new page, and if the user clicked on the new route as soon as he received a Snackbar, he could not read it.\n\nWe remade the Snackbar from scratch, having its Api based on Overlay, and now opening a Snackbar won't be tied to a route, you can normally navigate routes while a Snackbar is shown at the top (or bottom), and even the PopGesture of the iOS is not influenced by it.\n\nUsing Get.back() is handy, it's a small command, which closes routes, dialogs, snackbars, bottomsheets, etc, however Getx 5 will prioritize code safety, and splitting will reduce the check code as well. Currently we have to check if a snackbar is open, to close the snackbar and prevent the app from going back a page, all this boilerplate code will be removed, at the cost of having what it closes in front of Get.back command.\n\nFor backwards compatibility, Get.back() still works for closing routes and overlays, however two new commands have been added: Get.closeCurrentSnackbar() and Get.closeAllSnackbars().\nMaybe we will have a clearer api in GetX 5, and maybe Get.back() will continue to do everything like it does today. The community will be consulted about the desired api. However version 5 will definitely have commands like: Get.closeCurrentSnackbar, Get.closeCurrentDialog etc. There is also the possibility to close a specific snackbar using the return of Get.snackbar, which will no longer return a void, and now return a SnackbarController.\n\nSnackbars now also have a Queue, and no longer stack one on top of the other, preventing viewing. GetX now has flexible, customizable, route-independent, and completely stable Snackbars.\n\nFixed bugs where the snackbar showed an error in debug mode for a fraction of a second. We found that Flutter has a bug with blur below 0.001, so we set the minimum overlayBlur value to this value if it is ==true.\n\nErrors with internationalization were also fixed, where if you are in UK, and the app had the en_US language, you didn't have American English by default. Now, if the country code is not present, it will automatically fetch the language code before fetching a fallbackLanguage.\n\nUpdate locale also now returns a Future, allowing you to perform an action only when the language has already changed (@MHosssam)\n\nWe are very happy to announce that GetX is now documented in Japanese as well, thanks to (@toshi-kuji)\n\nGetX has always been focused on transparency. You can tell what's going on with your app just by reading the logs on the console. However, these logs shouldn't appear in production, so it now only appears in debug mode (@maxzod)\n\n@maxzod has also started translating the docs into Arabic, we hope the documentation will be complete soon.\n\nSome remaining package logs have been moved to Get.log (@gairick-saha)\n\nRxList.removeWhere received performance optimizations (@zuvola)\n\nOptimizations in GetConnect and added the ability to modify all request items in GetConnect (@rodrigorahman)\n\nThe current route could be inconsistent if a dialog were opened after a transition, fixed by @xiangzy1\n\nFixed try/catch case missed in socket_notifier (@ShookLyngs)\n\nAlso we had fixes in the docs: @DeathGun3344 @pinguluk\n\nGetX also surpassed the incredible mark of more than 7000 likes, being the most liked package in all pub.dev, went from 99% to 100% popularity, and has more than 5.3k stars on github. Documentation is now available in 12 languages, and we're happy for all the engagement from your community.\n\nThis update is a preparation update for version 5, which will be released later this year.\n\nBreaking and Depreciation:\nGetBar is now deprecated, use GetSnackbar instead.\ndismissDirection now gets a DismissDirection, making the Snackbar more customizable.\n\n## [4.3.8]\n\n- Fix nav2 toNamed remove the route\n\n## [4.3.7]\n\n- Fix wrong currentRoute when a route is removed\n- Remove take that limits the router outlet depth (@steven-spiel)\n\n## [4.3.6]\n\n- Fix error with autodispose of additional dependencies beyond GetxController\n- Added ability to add your own delegate to RouterOutlet (@steven-spiel)\n- Added listenAndPump to Rx to give Rx the same behavior as BehaviorSubject (@steven-spiel)\n\n## [4.3.5]\n\n- Fix GetConnect timeout (@jasonlaw)\n- Improve Vietnamese docs (@hp1909)\n- Refactor placeholder name route to unnamed routes (@roipeker).\n- Fix: Navigate to a page identical to Get.offNamed.\n- Fix: Wrong nameRoute after a route is removed\n- Added assert to prevent the user from starting a route name without slash.\n\n## [4.3.4]\n\n- Improve docs\n\n## [4.3.3]\n\n- Fix Get.reset\n\n## [4.3.2]\n\n- Fix nullable on internacionalization (@jmguillens)\n- Fix nullable on Rx.stream (@steven-spiel)\n\n## [4.3.1]\n\n- Fix controller is not removed when keyboard is open.\n- Improved: Safe removal and insertion of controllers.\n\n## [4.3.0]\n\n- Added GetResponsiveWidget (@ahmednfwela)\n- Added `Get.replace()` (@jwelmac)\n- Added Improve korean doc (@sejun2)\n- Fix multiple middlewares redirect (@liasica)\n- Added gestureWidth and showCupertinoParallax to GetPage to customize cupertino transitions\n\n## [4.2.5]\n\n- Added anchorRoute and filterPages to GetRouterOutlet (@ahmednfwela)\n- Added scrollBehavior and scaffoldMessengerKey to GetMaterialapp(@ejabu and @alionour)\n- Fix error when child on MaterialApp is null (@ahmednfwela)\n- Fix Korean docs (@rws08)\n- Fix error with onClose called before routeTransition on Get.offNamed\n\n## [4.2.4]\n\n- Fix Get.offAll removing GetxServices from memory\n\n## [4.2.3]\n\n- Fix back button on navigator 2\n- Added parameters and arguments to Get.rootDelegate\n\n## [4.2.1]\n\n- Remove [] from docs to try fix pub score\n\n## [4.2.0] - Big update\n\nThis update fixes important bugs as well as integrates with Navigator 2. It also adds GetRouterOutlet, similar to angular RouterOutlet thanks to @ahmednfwela. Also, the documentation translation for Vietnamese (@khangahs) has been added, making the GetX documentation available for 11 different languages, which is just fantastic for any opensource project. GetX has achieved more than 5.4k likes from the pub, and more than 4k stars on github, has videos about it with 48k on youtube, and has communities in the 4 hemispheres of the earth, besides having a large list of contributors as you see bellow. We're all happy to facilitate development with dart and flutter, and that making programming hassle-free has been taken around the world.\n\nChanges in this version:\n\n- Fix: Navigating to the same page with Get.offNamed does not delete the controller from that page using Get.lazyPut.\n\n- Fix Readme GetMiddleware typos\n  by @nivisi\n\n- Fix url replace error\n  by @KevinZhang19870314\n\n- Changed response default encoding from latin1 to utf8\n  by @heftekharm\n\n- Add Duration in ExtensionBottomSheet\n  by @chanonpingpong\n\n- Added compatibility with dart-lang/mockito\n  by @lifez\n\n- Added extensions methods to convert value in percent value\n  by @kauemurakami\n\n- Set darkTheme equal theme when darkTheme is null\n  by @eduardoFlorence\n\n- Add padding to 'defaultDialog'\n  by @KevinZhang19870314\n\n- GraphQLResponse inherit Response info\n  by @jasonlaw\n\n- Fix Redundant concatenating base url\n  by @jasonlaw\n\n- Add content type and length into the headers when the content type is 'application/x-www-form-urlencoded'\n  by @calvingit\n\n- Make withCredentials configurable\n  by @jasonlaw\n\n- Fix flutter 2.0 error\n  by @yunchiri\n\n- Allow deleting all registered instances\n  by @lemps\n\n- Refactor/rx interface notify children\n  @by kranfix\n\n- Fixed parameter parsing and middleware sorting\n  by @ahmednfwela\n\n- Improvements to router outlet\n  by @ahmednfwela\n\n- Minor improvements and bug fixes\n  by @ahmednfwela\n\n- Adding route guards and improving navigation\n  by @ahmednfwela\n\n- Fix RxInterface.proxy losing its previous value on exception\n  by @WillowWisp\n\n- Added dispose() for bottomSheet.\n  by @furkankurt\n\n- Added Pull request template\n  by @unacorbatanegra\n\n- Fix and update documentation:\n  @Farid566,\n  @galaxykhh,\n  @arslee07,\n  @GoStaRoff,\n  @BondarenkoArtur,\n  @denisrudnei,\n  @Charly6596,\n  @nateshmbhat,\n  @hrithikrtiwari,\n  @Undeadlol1,\n  @rws08,\n  @inuyashaaa,\n  @broccolism,\n  @aadarshadhakalg,\n  @ZeroMinJeon\n\n## [4.1.4]\n\n- Adjust operator + and - to RxInt (@eduardoflorence)\n- Fix dark theme (@eduardoflorence)\n- Fix form-urlencoded on GetConnect (@aramayyes)\n\n## [4.1.3]\n\n- Fix \"Error: A value of type 'Locale?' can't be returned from a function\"on flutter web (@nickwri)\n- Fix plural translations to expressions >1 (@WolfVic)\n\n## [4.1.2]\n\n- Fix warning ˜can add data to a closed stream˜ when GetBuilder and Obx are nested\n- Fix get_connect decoder can not be null (@Goddchen)\n- Migrate example code (@3lB4rt0)\n- Fix initial value of nullables (@RafaRuiz)\n- Improve error message to navigation (@maxzod)\n- Fix typo on docs (@Rahulshahare)\n- Fixed darktheme being changed only through Get.changeTheme and not through the DarkTheme theme property in MaterialApp (@GoldenSoju)\n- Fix controller is removed when navigate to same page (@eduardoflorence)\n- Fix missing reload() and reloadAll() to Get extensions (@lkloon123)\n\n## [4.1.1]\n\n- Remove mandatory initialValue to nullables types\n\n## [4.1.0]\n\n- Added Rxn to non nullables reactives types\n\n## [4.0.3]\n\n- Added new linter rules to improve score\n\n## [4.0.2]\n\n- Removed \"!\" of if else conditions until the null-safety of the dart is consistent for using it.\n\n## [4.0.1]\n\n- Fix changelog\n\n## [4.0.0]\n\n- Added append function to StateMixin. Now is possible track loading, success and error handle of your application with ONE LINE OF CODE. Ex: append(()=> api.getUser);\n- Migrate to null-safety\n- Added ScrollMixin to controllers\n- Added loadingMore status to RxStatus\n- Fix content-type qual null (@katekko)\n- Made GetInstance non nullable (@eduardoflorence)\n- Fix multi-parameters url (@iMrLopez)\n- Fix Expected value of SkDeletable error (@obadajasm)\n- Added triggers, an Rx method that triggers events, even if they are the same as the previous event (@RafaRuiz)\n- Improve docs: (@CNAD666), (@dhhAndroid), (@Jackylee1992),\n\nSwitching to null-safety:\nYou can continue using GetX as normal, with as little breaking changes as possible.\nIt is still possible to declare the var.obs variable, and this remains the preferred way, forcing null-safety and giving you all the security that sound null-safety delivers to your app. However, if you need to use null, we also provide a solution for you.\nDeclare the variables with `?` Ex: `final Rx<int?> count = 0.obs`.\nYou can also use custom Rxn types with null-safety:\n`RxInt` == not nullable\n`RxnInt` == nullable.\n\n## [3.25.6]\n\n- Added documentation in French (@kamazoun)\n- Fix logs messages (@damphat)\n- Fix plural to zero on internacionalization (@RafaRuiz)\n- Fix error when body hasn't content on GetConnect (@jasonlaw)\n- Fix typos on readme (@bashleigh)\n- Fix group updates to GetBuilder\n\n## [3.25.5]\n\n- Fix Get.isDialogOpen when two or more open dialogs are closed\n\n## [3.25.4]\n\n- Added logs and tests to unknownRoute\n\n## [3.25.3]\n\n- Fix bindStream error 'Object.noSuchMethod'.\n\n## [3.25.2]\n\n- Improved Workers system to accept a list of works\n\n## [3.25.1]\n\n- Improved the log system to display the tag used in the controller that was created.\n\n## [3.25.0] - Big update\n\n- Added [reload] and [reloadAll] methods to reload your Controller to original values\n- Added [FullLifeCycleController] - A GetxController capable of observing all the life cycles of your application. FullLifeCycleController has the life cycles:\n  - onInit: called when the controller enters the application's memory\n  - onReady: called after onInit, when build method from widget relationed to controller is done.\n  - onClose: called when controller is deleted from memory.\n  - onPaused: called when the application is not currently visible to the user, and running in the background.\n  - onInactive: called when the application is in an inactive state and is not receiving user input, when the user receives a call, for example\n  - onResumed: The application is now visible and in the foreground\n  - onDetached: The application is still hosted on a flutter engine but is detached from any host views.\n  - didChangeMetrics: called when the window size is changed\n- Added SuperController, a complete life circle controller with StateMixin\n- Improve Iterable Rx Api. Now, you can to use dart List, Map and Set as reactive, like: List<String> names = <String>['juan', 'pedro', 'maria'].obs;\n- Added assign and assignAll extensions to default dart List\n- Added parameters options from Get.toNamed, Get.offNamed, and Get.offAllNamed (@enghitalo)\n- Improve Rx disposal logic to completely prevent memory leaks\n- Improve Capitalize methods from GetUtils (@eduardoflorence)\n- Prevent a close snackbar from close a Screen with double tap (@eduardoflorence)\n- Includes GetLifeCycleBase mixin on delete/dispose (@saviogrossi)\n- Added internacionalization example to sample app (@rodriguesJeff)\n- Added headers to Graphql query and mutation(@asalvi0)\n- Added translation with parameter extension (@CpdnCristiano)\n- Added Get.parameter access to Middleware (@eduardoflorence)\n- Fix RxBool typo (@emanuelmutschlechner)\n- Added Filter to GetBuilder\n- Added debouce to GetBuilder update\n- Added ability to insert an Enum, class, or type of an object as a GetBuilder's Id\n- Improve upload time from GetConnect\n- Create minified version to DartPad(@roipeker)\n- Suggested to use `Get.to(() => Page())` instead of `Get.to(Page())`.\n- Added more status codes to GetConnect (@romavic)\n- Fix and improve docs: @unacorbatanegra, @lsm, @nivisi, @ThinkDigitalSoftware, @martwozniak, @UsamaElgendy, @@DominusKelvin, @jintak0401, @goondeal\n\n## [3.24.0]\n\n- GetWidget has been completely redesigned.\n  Throughout its lifetime, GetWidget has always been mentioned in the documentation as \"something you shouldn't use unless you're sure you need it\", and it had a very small use case. A short time ago we realized that it could have some unexpected behaviors, when compared to GetView, so we decided to rebuild it from scratch, creating a really useful widget for the ecosystem.\n  Objectively, GetWidget is now a Widget that caches the controller and protects children from their parents' reconstructions. This means that if you have a ListView or gridview, you can add items to it without the child (being a GetWidget) being rebuilt. The api is now more concise, as you can use Get.put / Get.lazyput for global dependencies, and Get.create with GetWidget for ephemeral dependencies, or when you need several identical controllers for the same widget, eliminating the need for tags for most cases.\n\n- Workers now have error handlers, so if an error occurs in your stream, you can recover it from your workers.\n\n- `isTrue` and `isFalse` setters were added to [RxBool], this will make the code more readable, and will mitigate the use of \".value\" in Booleans.\n\n- [Patch] method was added in GetConnect.\n\n- Native methods for RxString (trim, contains, startWith, etc.) have been added.\n- Standard constructors for RxList and RxMap have been added (RxList.generate, RxList.from, Map.of, Map.from, etc).\n\n- Added \"onEmpty\" status in StateMixin (@alizera)\n\n- Added query and mutation methods of graphql for getconnect.\n- Added body string for content-type application/x-www-form-urlencoded on GetConnect (@eduardoflorence)\n\n## [3.23.1]\n\n- Fix allowSelfSigned on Flutter web\n\n## [3.23.0]\n\n- Add GetResponsive (@SchabanBo)\n- Update tests, fix predicate for offNamedUntil (@vbuberen)\n- Added Urdu Version for Pakistani Developers (@UsamaSarwar)\n- Handle for List field with native datatype on GetConnect(@jasonlaw)\n- Added WillPopScope to defaultDialog (@rakeshlanjewar)\n- Fix optional query params not attach on createUri from GetConnect (@reinaldowebdev)\n- Effective Get.testMode from navigator on tests (@eduardoflorence)\n- Fix Navigator 2.0 on GetMaterialApp and CupertinoMaterialApp (@SchabanBo)\n- Added Middlewares with initial Routes (@SchabanBo)\n- Improve PT-br Docs (@eduardoflorence)\n- Added the allowSelfSigned parameter to GetSocket(@eduardoflorence)\n- Added Indonesian version to Indonesian Developers (@pratamatama)\n\n## [3.22.2]\n\n- Fix overlayEntries is null on Master/Dev branch of Flutter\n\n## [3.22.1]\n\n- Improve: auto jsonDecode occurs only if response.header.contentType is \"application/json\"\n- Improve and fix requests types (@eduardoflorence)\n- Fix HeaderValue variables with same name (@haidang93)\n\n## [3.22.0]\n\n- Added: more multipart options. Now you can send as multipart:\n\nFile:\n'file':MultipartFile(File('./images/avatar.png'), filename: 'avatar.png'),\n\nString path:\n'file':MultipartFile('./images/avatar.png', filename: 'avatar.png'),\n\nOr bytes (Flutter web work only with bytes):\n'file':MultipartFile(File('file').readAsBytesSync(), filename: 'avatar.png'),\n\n- Added: Upload Progress to MultipartRequest\n- Added support to List<MultipartFile> (@jasonlaw)\n\n## [3.21.3]\n\n- Improve multipart file and defaultDecoder on GetConnect\n\n## [3.21.2]\n\n- Fix GetConnect.request returning a PUT request\n\n## [3.21.1]\n\n- Allow null body to POST method on GetConnect\n\n## [3.21.0] - Big update\n\n- This update attaches two nice features developed by (@SchabanBo): _GetPage Children_ And _GetMiddleware_\n  In previous versions, to create child pages, you should do something like:\n\n```dart\nGetPage(\n  name: '/home',\n  page: () => HomeView(),\n  binding: HomeBinding(),\n),\nGetPage(\n  name: '/home/products',\n  page: () => ProductsView(),\n  binding: ProductsBinding(),\n),\nGetPage(\n  name: '/home/products/electronics',\n  page: () => ElectronicsView(),\n  binding: ElectronicsBinding(),\n),\n```\n\nAlthough the feature works well, it could be improved in several ways:\n1- If you had many pages, the page file could become huge and difficult to read. Besides, it was difficult to know which page was the daughter of which module.\n2- It was not possible to delegate the function of naming routes to a subroutine file.\nWith this update, it is possible to create a declarative structure, very similar to the Flutter widget tree for your route, which might look like this:\n\n```dart\nGetPage(\n      name: '/home',\n      page: () => HomeView(),\n      binding: HomeBinding(),\n      children: [\n        GetPage(\n            name: '/products',\n            page: () => ProductsView(),\n            binding: ProductsBinding(),\n            children: [\n              GetPage(\n                 name: '/electronics',\n                 page: () => ElectronicsView(),\n                 binding: ElectronicsBinding(),\n              ),\n            ],\n          ),\n      ],\n  );\n```\n\nThus, when accessing the url: '/home/products/electronics'\nOr use Get.toNamed('/home/products/electronics') it will go directly to the page [ElectronicsView], because the child pages, automatically inherit the name of the ancestral page, so _with any small change on any father in the tree all children will be updated._ If you change [/products] to [/accessories], you don't nesse update on all child links.\n\nHowever, the most powerful feature of this version is _GetMiddlewares_.\nThe GetPage has now new property that takes a list of GetMiddleWare than can perform actions and run them in the specific order.\n\n### Priority\n\nThe Order of the Middlewares to run can pe set by the priority in the GetMiddleware.\n\n```dart\nfinal middlewares = [\n  GetMiddleware(priority: 2),\n  GetMiddleware(priority: 5),\n  GetMiddleware(priority: 4),\n  GetMiddleware(priority: -8),\n];\n```\n\nthose middlewares will be run in this order **-8 => 2 => 4 => 5**\n\n### Redirect\n\nThis function will be called when the page of the called route is being searched for. It takes RouteSettings as a result to redirect to. Or give it null and there will be no redirecting.\n\n```dart\nGetPage redirect( ) {\n  final authService = Get.find<AuthService>();\n  return authService.authed.value ? null : RouteSettings(name: '/login')\n}\n```\n\n### onPageCalled\n\nThis function will be called when this Page is called before anything created\nyou can use it to change something about the page or give it new page\n\n```dart\nGetPage onPageCalled(GetPage page) {\n  final authService = Get.find<AuthService>();\n  return page.copyWith(title: 'Welcome ${authService.UserName}');\n}\n```\n\n### OnBindingsStart\n\nThis function will be called right before the Bindings are initialize.\nHere you can change Bindings for this page.\n\n```dart\nList<Bindings> onBindingsStart(List<Bindings> bindings) {\n  final authService = Get.find<AuthService>();\n  if (authService.isAdmin) {\n    bindings.add(AdminBinding());\n  }\n  return bindings;\n}\n```\n\n### OnPageBuildStart\n\nThis function will be called right after the Bindings are initialize.\nHere you can do something after that you created the bindings and before creating the page widget.\n\n```dart\nGetPageBuilder onPageBuildStart(GetPageBuilder page) {\n  print('bindings are ready');\n  return page;\n}\n```\n\n### OnPageBuilt\n\nThis function will be called right after the GetPage.page function is called and will give you the result of the function. and take the widget that will be showed.\n\n### OnPageDispose\n\nThis function will be called right after disposing all the related objects (Controllers, views, ...) of the page.\n\n## [3.20.1]\n\n- Fix wrong reference with unnamed routes and added more tests\n\n## [3.20.0] - Big update\n\n- Added GetConnect.\n\n* GetConnect is an easy way to communicate from your back to your front. With it you can:\n* Communicate through websockets\n* Send messages and events via websockets.\n* Listen to messages and events via websockets.\n* Make http requests (GET, PUT, POST, DELETE).\n* Add request modifiers (like attaching a token to each request made).\n* Add answer modifiers (how to change a value field whenever the answer arrives)\n* Add an authenticator, if the answer is 401, you can configure the renewal of your JWT, for example, and then it will again make the http request.\n* Set the number of attempts for the authenticator\n* Define a baseUrl for all requests\n* Define a standard encoder for your Model.\n* Note1: You will never need to use jsonEncoder. It will always be called automatically with each request. If you define an encoder for your model, it will return the instance of your model class ALREADY FILLED with server data.\n* Note2: all requests are safety, you do not need to insert try / catch in requests. It will always return a response. In case of an error code, Response.hasError will return true. The error code will always be returned, unless the error was a connection error, which will be returned Response.hasError, but with error code null.\n* These are relatively new features, and also inserted in separate containers. You don't have to use it if you don't want to. As it is relatively new, some functions, such as specific http methods, may be missing.\n\n- Translation to Korean (@rws08)\n- Fix Overlays state (@eduardoflorence)\n- Update chinese docs (@jonahzheng)\n- Added context.isDarkMode to context extensions\n\n## [3.17.1]\n\n- Allow list.assignAll, map.assignAll and set.assignAll operate with null values\n\n## [3.17.0]\n\n- Added GetCupertinoApp\n- Added initial suport to navigator 2.0\n\n## [3.16.2]\n\n- Clean RxList, RxMap and RxSet implementation\n- Now when declaring an `RxList()`, it will be started empty. If you want to start a null RxList, you must use `RxList(null)`.\n  Improved GetStream to receive the same parameters as the StreamController, such as `onListen`, `onPause`, `onResume` and `onCancel`.\n- Improve docs\n\n## [3.16.1]\n\n- Fix compilation error on master\n\n## [3.16.0]\n\n- Documentation translated into Russian language. (@Renat Fakhrutdinov, @Doaxan and @BatttA)\n- Added error message callback for StateMixin (@eduardoflorence)\n- Fix incorrect Get.reference when pop route (@4mb1t)\n- Added Uppercase/Capital letter on GetUtils (@AleFachini)\n- Redraw the Streams api to use GetStream instead of StreamControllers. Why this change?\n  Dart provides a Streams API that is really rich. However, asynchronous streams add extra latency to ensure that events are delivered in the exact order.\n  It is not yet known whether this latency has any performance impact in mobile applications, and probably not, however, as GetX is also a server-side framework, we need to have the lowest latency at all, since our base is shared.\n  Dart also has a Synchronous Streams api that has very low latency, however, it is not suitable for use in state management for two reasons:\n  1- Synchronous Streams can only have one listen (see the issue opened by Hixie on dart lang for reference: https://github.com/dart-lang/sdk/issues/22240).\n  This means that we cannot use this api for more than one listener, which is the basis of global state management, where we aim to change the state of more than one location. You can test this with this simple snippet:\n\n```dart\nvoid main() {\n  var controller = StreamController(sync: true);\n  var stream = controller.stream;\n  stream.listen((data) {\n    print('$data');\n    if (data == 'test4') controller.add('test5');\n  });\n\n  print('test1');\n  controller.add('test2');\n  stream.listen((event) {}); // second listen throws a exception\n  print('test3');\n  controller.add('test4');\n  print('test6');\n  controller.add('test7');\n  print(\"test8\");\n}\n```\n\n2- Even with a single listener, the dart's Synchronous Streams api cannot deliver events in the exact order. We plan to work on a PR in the future at dart-lang to address this. So if we remove the line above that causes the exception, we will have the following output in the log:\n\n```dart\nvoid main() {\n  var controller = StreamController(sync: true);\n  var stream = controller.stream;\n  stream.listen((data) {\n    print('$data');\n    if (data == 'test4') controller.add('test5');\n  });\n\n  print('test1');\n  controller.add('test2');\n  // stream.listen((event) {}); // second listen throws a exception\n  print('test3');\n  controller.add('test4');\n  print('test6');\n  controller.add('test7');\n  print(\"test8\");\n}\n///////////////////// log:\ntest1\ntest2\ntest3\ntest4\ntest6\ntest8\ntest5\n\n```\n\nAs we can see, test 4 skips to test 6, which skips to test 8, which skips to test 5. Note that test 7 didn't even appear in the log.\n\nHowever, if we work with GetStream, everything works as expected:\n\n```dart\nvoid main() {\n  var controller = GetStream();\n  var stream = controller.stream;\n  stream.listen((data) {\n    print('$data');\n    if (data == 'test4') controller.add('test5');\n  });\n\n  print('test1');\n  controller.add('test2');\n  // stream.listen((event) {}); // second listen throws a exception\n  print('test3');\n  controller.add('test4');\n  print('test6');\n  controller.add('test7');\n  print(\"test8\");\n}\n///////////////////// log:\ntest1\ntest2\ntest3\ntest4\ntest5\ntest6\ntest7\ntest8\n\n```\n\nThe dart documentation is clear that this api should be used with caution, and in view of these tests, we were sure that it is not stable enough to be used as the core of our state management, nor of the websockets notifications and get_server requests.\n\nClarification about the controversy over benchmarks:\nIn a version prior to changeLog, we talked about the 9000% difference in performance between Streams, and GetStreams that ended up causing a lot of controversy in the community.\nInitially, we would like to clarify that this does not mean that you will have mobile applications 9000% faster. Only that one of our main resources, showed itself with a high rate of requests, 9000% faster than using traditional streams. In a real world scenario, you will hardly have so many simultaneous requests.\nSkia renders frames on new devices at up to 120fps. This means that if you have a 10 second animation, you will have 1200 reconstructions. Unless you are working with animations, or something that requires rendering at the skia boundary, you won't need that much power. So this does not mean that we are revolutionizing the mobile world, only that we have created an alternative to Stream Sincronas, which works as expected, and which has satisfactory performance for low latency resources. The benchmarks are real, but that does not mean that you will have mobile applications 9000% faster, but that you have a new feature that performs at this level to use.\nFor reference only, the benchmark can be found ([HERE](https://github.com/jonataslaw/getx/blob/master/test/benchmarks/benckmark_test.dart))\n\nIn short: asynchronous streams from dart work perfectly, but add a latency that we want to remove on Get_server.\nSynchronous dart streams have unexpected behaviors, cannot have more than 1 listener and do not deliver events in the correct order, which completely prevents their use in mobile state managements, since you run the risk of displaying data on the wrong screen, since the last event will not always be the last event entered by the sink.\nThe 9000% figures are real, however, they refer to the gross performance between Streams and GetStreams. This does not mean that this number will impact your applications, because you are unlikely to use all of that power.\n\n## [3.15.0] - Big update\n\n- **Improve Performance**: We made modifications to make GetBuilder even faster. We have improved the structure behind it so that listeners are notified faster. Perhaps in version 4.0 everything will be based on this new structure, but maintaining the power and compatibility with streams. If you want to know how much Getx is faster than pure streams or ChangeNotifier (even after the last update using LinkedList), you can create run the repository tests at: (https://github.com/jonataslaw/getx/blob/master/test/benchmarks/benckmark_test.dart)\n- **Added StateMixin**\n  StateMixin allows you to change the state of the controller, and display a loading, an error message, or a widget you want with 0 boilerplate. This makes things like API/Rest communication or websocket absurdly simple, and it's a real revolution in how state management has behaved so far.\n  You no longer need to have a ternary in your code, and you don't need a widget like FutureBuilder, StreamBuilder or even Obx/GetBuilder to encompass your Visibility. This will change with the way you manage the state of your controllers, decrease your boilerplate absurdly, and give you more security in your code.\n- **Added GetNotifier**\n  GetNotifier is a super and powerful ValueNotifier, which in addition to having the life cycle of the controllers, is extremely fast, and can manage a single state, as a simplified immutable state management solution.\n  In theory, the only difference between it and GetxController is the possibility of setting an initial value in the constructor's super (exactly as ValueNotifier does). If the initial value is null, use GetxController. If you need a starting value, GetNotifier can be more useful and have less boilerplate, but both serve the same purpose: to decouple your visualization layer from your presentation logic.\n- Other Fixes and improvements:\n  - Fixed GetxController is closed twice when smartManagement.full is turn on\n  - Fixed phone number validation\n  - Fixed some inconsistencies in GetWidget and the life cycle of controllers\n  - It made controller testing completely safe with navigation.\n  - Improve docs (@eduardoflorence)\n  - Improve security types on routes (@unacorbatanegra)\n  - Improve code structure with less duplicate code: (@kranfix)\n  - Fix named route erroring when route does not exist (@FiercestT)\n\n## [3.13.2]\n\n- Reunification of the package.\n  During the 2 week period, we try to keep this package as a compilation of smaller packages. We were successful in separating, getx is well decoupled and it was only necessary to send the internal folders as packages to pub.dev, however, it became very complicated to contribute to the package. This is because it was necessary to clone the repository, replace all pubspec packages with local paths, and after modification, return the original paths to do the PR. With that, the frequency of updates, which was about 4 to 5 days, became almost 2 weeks, and this is not legal for a community as active as Getx, which uses this package precisely in addition to being modern and performance, be constantly improving. This led contributors to the conclusion that getx works best together.\n  Additional packages will continue to be maintained, and will have the same base as the main package, however, development will take place in the full and main package, and as the addition of new features or bug fixes arrives, we will migrate to the individual packages . Getx reached the mark of 50 contributors today, more than 1500 likes in the pub, and will continue to make development easy.\n\n## [3.13.1]\n\n- Remove spaces whitespaces from dart files\n-\n\n## [3.13.0]\n\n- Fix typos on code and docs (@wbemanuel and @Goddchen)\n- Improve: typedef to GetBuilder and Getx widgets\n- Improve behaviour of null route on lastest flutter version (@FiercestT)\n- Fix onReady called twice on smartManagement.onlyBuilders\n- Fix onClose called twice when GetBuilder is used\n- Fix default customTransitions, and defaultDuration be ignored on unnamedRoutes\n- Transition.native use default Flutter transitions\n- Added Get.testMode to use contextless elements on unit tests\n- Added Get.appUpdate and improve Get.forceAppUpdate\n\n## [3.12.1]\n\n- Remove spaces whitespaces from dart files\n\n## [3.12.0]\n\n- Added BottomSheet Duration && Export SingleGetTickerProvider (@unacorbatanegra)\n- Improve docs from dependencies management (@ngxingyu)\n- Fix unknownRoute with null Custom Transition (@marcosfons)\n- Optimize capitalize method (@zl910627)\n- Added Chinese documentation (@idootop)\n- Added TextDirection property on GetMaterialApp to improve RTL layout (@justkawal)\n- Remove unnecessary files on git (@nipodemos)\n- Fix tags on Get.create() and GetWidget() (@roipeker)\n- Update mockito dependency on getTests\n- Added GetStatelessWidget, a StatelessWidget base to GetWidget with lifecycle control of controllers. Note: It's a base class, you don't need change to use it or change your GetView, GetWidget StatelessWidget to It.\n\n## [3.11.1]\n\n- Fix docs\n\n## [3.11.0]\n\n- Refactor structure from scratch to split GetX completely into separate packages. When using the main package (get) you will have everything working perfectly together. However, if you only want one of the resources, you can use the packages separately.\n- Improve Rx types\n- Added RTL support\n- Added GetTests, a set of tools to help you create unit tests using Getx\n- RAM consumption improved by dividing resources into smaller components, preventing related classes that are unnecessary from being loaded\n- Fix example app (missing activity) (@Grohden)\n- Added Get.create() lifecycle (@roipeker)\n- Added section Contribution videos and articles in Readme (@stefandevo)\n- fix isNullOrBlank extension\n- Added all operators overload (@grohden)\n- Fixes subscription for Rx::bindStream (@roipeker)\n- Added Ability to use tags with GetX widgets (@na2axl)\n- Change Arguments from Object to dynamic (@roipeker)\n- Added Persistent bottomsheet (@mohak852)\n- Improve extensions tests (@Nipodemos)\n- Refactor Route Observer (@grohden)\n- Added print extensions (@unacorbatanegra)\n- Update PT-br Readme (@eduardoflorence)\n- Fix analyzer crash (@eduardoflorence)\n- Fix for switch types usages in GetUtils (@grohden)\n- Improvement: RxList, RxSet and RxMap null check in the constructor (@Hitsu91)\n- Improve readme example (@dafinoer)\n\n## [3.10.2]\n\n- Fixed the use of tags with lazyPut and added Ability to overwrite \"tag\" in GetView and GetWidget.\n\n## [3.10.1]\n\n- Fix analyzer\n\n## [3.10.0]\n\nGetx 3.10 released with CLI and Get Server.\n\n- Added: analyser + effective dart (@Grohden)\n- Added TextStyle to generalDialog title and message (@roipeker)\n- renamed and added defaults transition duration and types in \"GetInterface\" (@roipeker)\n- added missing parameters in Get.to/Get.offAll (@roipeker)\n- added optional transitionDuration and transitionCurve to Get.dialog() (@roipeker)\n- Changed HashMap<int,GetStateUpdate> to HashSet<GetStateUpdate> and allow update IDs groups on GetBuilder (@roipeker)\n- Added a internal VoidCallback in GetStateUpdaterMixin::getUpdate (@roipeker)\n- Added Curve property to routes (@roipeker)\n- Improve docs, code cleanup, new GetStateUpdaterMixin and GetStateUpdate in favour of StateSetter on GetxController, GetBuilder, SimpleBuilder. (@roipeker)\n- Added RxBool.toggle() as an easy shortcut for switching true/false values. (@roipeker)\n- Added \\_RxImp.nil() to easily set the value to null (@roipeker)\n- Added missing docs to Rx classes. (@roipeker)\n- Added Get.delete(force:false) to Get extensions (@roipeker)\n- Added Docs and comments (@nipodemos)\n- Added docs to PT-br and fix typos (@eduardoflorence)\n- Cleanup route code (@justkawal)\n- Extension to facilitate insert widgets inside a CustomScrollView (@alexkharech)\n- Fix docs .obs examples (@kai-oswald)\n- Added tag capability to GetView\n- Improve code separation of RouteManagement and Internacionalization\n\n## [3.8.0]\n\n- Added: Snackbar Status: Open, Opening, Closing and Closed\n  example:\n\n```dart\n Get.snackbar('title', 'message', snackbarStatus: (status) {\n                  if (status == SnackbarStatus.CLOSED) {\n                    // made anything\n                  }\n                });\n```\n\n## [3.7.0]\n\n- Added: RxSet. Sets can now also be reactive.\n- Added isDesktop/isMobile (@roipeker)\n- Improve GetPlatform: It is now possible to know which device the user is using if GetPlatform.isWeb is true.\n  context.responsiveValue used device orientation based on web and non-web applications. Now it checks if it is a desktop application (web or desktop application) to do the responsiveness calculation. (@roipeker)\n- Change: The documentation previously stated that Iterables should not access the \".value\" property.\n  However, many users did not pay attention to this fact, and ended up generating unnecessary issues and bugs in their application.\n  In this version, we focus on code security. Now \".value\" is protected, so it cannot be accessed externally by Lists, Maps or Sets.\n- Change: Observable lists are now Dart Lists.\n  There is no difference in your use:\n  `RxList list = [].obs;`\n  And you use\n  `List list = [].obs;`\n- Change: You do not need to access the \".value\" property of primitives.\n  For Strings you need interpolation.\n  For num, int, double, you will have the normal operators, and use it as dart types.\n  This way, `.value` can be used exclusively in ModelClasses.\n  Example:\n\n```dart\nvar name = \"Jonny\" .obs;\n// usage:\nText (\"$name\");\n\nvar count = 0.obs;\n// usage:\nincrement() => count ++;\nText(\"$count\");\n```\n\nThus: List, Map, Set, num, int, double and String, as of this release, will no longer use the .value property.\n\nNOTE:\nThe changes were not break changes, however, you may have missed the details of the documentation, so if you faced the message: \"The member 'value' can only be used within instance members of subclasses of 'rx_list.dart' \"you just need to remove the\" .value \"property from your list, and everything will work as planned.\nThe same goes for Maps and Sets.\n\n## [3.6.2]\n\n- Fix more formatting issues\n\n## [3.6.1]\n\n- Fix formatting issues\n\n## [3.6.0]\n\n- Added RxSet\n- Change default logger to developer.log (@jorgegaticav)\n- Added BindingsBuilder, ValueBuilder, and ObxValue (@roipeker)\n- Fix fallback locale not working if missing country code (@thaihuynhxyz)\n- Fix validation of email \".com.br\"\n\n## [3.5.1]\n\n- Remove unnecessary whitespaces\n\n## [3.5.0]\n\n- Added logwritter (@stefandevo)\n- Added responsiveValue (@juanjoseleca)\n- Fixed ghost url for snackbar, bottomsheets, and dialogs and unnamed navigation.\n\n## [3.4.6]\n\n- Fix TextField dispose throw on last Flutter hotfix\n\n## [3.4.5]\n\n- Fix typo on RxList.remove that could cause type errors.\n- Remove initialization console print\n\n## [3.4.4]\n\n- Fix exception 'isInit called null' when tags are used in conjunction with dependencies. (@djade007)\n- Fix typos (@tiagocpeixoto)\n\n## [3.4.3]\n\n- Fix onInit fired only first time\n- Fix language callback(@lundin)\n- Fix docs (@nipodemos)\n\n## [3.4.2]\n\n- Fix individual imports\n\n## [3.4.1]\n\n- Structure organization, and improvements.\n\n## [3.4.0]\n\n- Added '[everAll]' Worker: Listen a List of '.obx'\n- Added Workers dispose\n- Fix transition.noTransition\n- Fix TextField and VideoPlayController dispose before transition animation\n\n## [3.3.0]\n\n- Fix extensions (@stefandevo)\n- Added CPF to utils options (@kauemurakami)\n- Added fenix mode to Get.lazyPut.\n  Use `Get.lazyPut<Controller>(()=> Controller(), fenix:true)` to have a controller that after being destroyed, has the ability to be recreated in case someone needs it. This is a function that already exists in smartManagement.keepFactory which is now also possible in full mode.\n- Fix native transition on android\n\n## [3.2.2]\n\n- Improve transitions and refactor route system\n\n## [3.2.1]\n\n- Prevent black blackground on cupertino fullscreenDialog\n\n## [3.2.0]\n\n- Improve GetBuilder ram usage\n- Added method update to Rx\n  Now you no longer need to make an entire class reactive to get an element update from it, you can simply call the update method of its instance, like this:\n\n```dart\nclass User{\n  User(this.name = '', this.age = 0);\n  String name;\n  int age;\n}\n\nfinal user = User().obs;\n\nObx(()=> Text(\"Name ${user.value.name}: Age: ${user.value.age}\"))\n\n// To update:\nuser.update((user){\nuser.name = 'Jonny';\nuser.age = 18;\n});\n```\n\nNow is also possible to access a value without using the \".value\". Just open and close parentheses.\nIn the previous example, you could do:\n\n```dart\nuser().name; // before: user.value.name\n```\n\nAnd it is also possible to set a value without using the value, inserting the value directly into the variable.\n\n```dart\nuser(User('João', 35)); // before: user.value = User('João', 35)\n```\n\nAdded fenix mode to Get.lazyPut.\n\n## [3.1.4]\n\n- Update readme banner\n\n## [3.1.3]\n\n- Activate unknownRoute on version 3\n- Go back transitions.size and transitions.cupertino\n\n## [3.1.2]\n\n- Expose GetInstance\n\n## [3.1.1]\n\n- Improvement .obs methods\n\n## [3.1.0]\n\n- Added extensions to GetUtils and fix typo on GetUtils.isEmail (@stefandevo)\n- Added .gitignore file (@hdeyana)\n\n## [3.0.1]\n\n- Breaking changes on Rx api and GetController and RxController were merged, and now you only have the 'GetxController'\n- Refactor routing system. Now you can add custom transitions and more\n- Improved the use of dynamic routes, you can now define two different pages according to your arguments.\n- Added GetView widget\n- Added internacionalization\n- Added validations\n- Added Get queqe\n- Added GetStorage (with separated package)\n- Minor bug fixes.\n\n## [2.14.0]\n\n- Added getPages API.\n- Deprecated namedPages\n- Fix default transition\n- Added Duration on Get.offAll(@kluverua)\n\n## [2.13.1]\n\n- Added sort to ListX\n- Prepared the framework for version 3\n\n## [2.13.0]\n\n- Added Get.focusScope\n\n## [2.13.0]\n\n- Update docs\n- Fix Bindings list on GetPageRoute\n\n## [2.12.5]\n\n- Update readme\n\n## [2.12.4]\n\n- Prevent exceptions on onReady with nullables\n\n## [2.12.3]\n\n- Fix List lenght == null\n\n## [2.12.2]\n\n- Fix Workers\n\n## [2.12.1]\n\n- Added: onReady on Controllers LifeCycle\n- Added: Observable maps\n- Refactor: observable variables that now consume even less RAM.\n\n## [2.11.3]\n\n- Type parameters and added docs\n\n## [2.11.2]\n\n- Added docs\n- Improvement performance of Obx\n\n## [2.11.1]\n\n- Fixed: oninit calling only once.\n\n## [2.11.0]\n\n- Added Permissions:\n  You can now revoke permissions to SmartManagement so that it cannot delete a particular controller.\n  Add to Get.put (Controller(), permanent: true); to make it indelible.\n  Get.lazyPut() will not receive this resource. Initially he had it, but we saw in internal tests that it could cause problems with the bindings API. Bindings were created to initialize and delete an instance, if it were allowed to make a controller started with lazyPut permanent, copies of that Controller would be created every time Binding was called. For the safety of users, especially new users who could easily do this, it was decided that this feature will only be present in Get.put.\n- Improve: Now a controller's life cycle has no connection with the View life cycle. It is no longer called internally in an \"initState\", it is now called when the Controller enters memory. This means that now onInit will always be called, regardless of where you started your dependency.\n- removed: this property of the update() method has been permanently removed.\n\n## [2.10.3]\n\n- GetBuilder refactor. 11% reduction in RAM consumption and 2% in CPU consumption for the sample application. (using as base Flutter for linux desktop).\n\n- The \"this\" property of the \"update\" method has been deprecated and will be removed in the next update. Please don't use it anymore. Just use \"update()\" now.\n\n## [2.10.2]\n\n- Fix Get.generalDialog default options\n\n## [2.10.1]\n\n- Fix broken links on pub\n- Fix List empty error\n\n## [2.10.0]\n\n- Added SmartManagement, your application's memory is managed intelligently like never before!\n- Added Obx, a widget that knows when to rebuild a child, without needing any type.\n- Added MixinBuilder - If you need to use GetBuilder in conjunction with GetX, use GetxController with this widget, and the changes will occur either using update (this) or changing some reactive variable. Use only if necessary, for better RAM consumption, prefer widgets in that order:\n  Obx => GetX => GetBuilder => MixinBuilder.\n  Obx is the lightest of all, and MixinBuilder is a mix of the other 3, whenever possible, use the specific widget.\n- Refactor: StateManager of Get.\n- Changed: full List API refactor, now value is no longer needed.\n- Added Workers: You can hear changes to a variable and trigger custom callbacks.\n- Added Bindings API docs.\n- Added Portuguese language to readme(@Nipodemos)\n\n# [2.7.1]\n\n- Improve list to set and get methods\n\n## [2.7.0]\n\n- Added obx, a simple state interceptor.\n- Improve Bindings, ListX, and\n- fix docs typos e broken code (@ghprod)\n\n## [2.6.3]\n\n- Flutter currently has a problem on some devices where using showModalBottomSheet() can cause TextFields to be hidden behind the keyboard (https://github.com/flutter/flutter/issues/18564) this issue is closed, even users reporting that the problem still occurs.\n  The problem happens casually, as well as the problem of the snackbar on the iPhone SE 2, and checking the code, I realized that a padding with MediaQuery.of(context).viewInsets.bottom is missing inside the bottomSheet to make it work correctly, since it does not have any constraint with the keyboard.\n  For stability, I decided not to use the standard Flutter bottomSheet, which contains many bugs, mainly related to keyboard padding, and the lack of respect for topBar's safeArea, and to use a proprietary bottomSheet implementation that is more stable. The Flutter dialog has no problem, so it will be used as the basis for Get.dialog. The bottomSheet will be based on the Flutter bottomSheet Raw API (\\_ModalBottomSheetRoute), applying bug fixes.\n- Added Get.isSnackbarOpen tests\n\n## [2.6.2]\n\n- Refactor Bindings API\n\n## [2.6.1]\n\n- Expose Bindings API\n\n## [2.6.0]\n\n- Added bindings.\n  You can now add bindings from your controllers to your routes, to prepare GetBuilder or GetX to create a dependency already declared in a Binding class. This feature is in an experimental phase, and will not be documented until the end of the tests.\n\n## [2.5.10]\n\n- Removed remnants of previousArgs on routeObserver.\n  This feature had been deprecated in previous updates, and was removed in version 2.5.8. Some remaining references on the routeObserver were causing exceptions in version 2.5.9, and were removed completely in version 2.5.10.\n\n## [2.5.9]\n\n- Fix Get.find with named instance\n\n## [2.5.8]\n\n- Added docs\n- Added tests(@chimon2000)\n\n## [2.5.7]\n\n- Fix Get.generalDialog optionals\n- Added GetX onInit support\n\n## [2.5.6]\n\n- GetBuilder refactor to work with lazyPut.\n  Now you can list your controllers in advance with Get.lazyPut, and only when it is called for the first time will it be relocated in memory.\n- Fix english typos(@gumbarros)\n\n## [2.5.5]\n\n- Fix arguments broken by new methods\n\n## [2.5.4]\n\n- Refactor methods\n\n## [2.5.3]\n\n- Fix snackbar padding on iPhone SE 2.\n- Added themes docs\n- Added ThemeMode (@RodBr)\n\n## [2.5.2]\n\n- Fix: key not found when Get.key is used with no MaterialApp\n\n## [2.5.1]\n\n- Improve - GetBuilder uses 18% less ram on more of 20 controllers.\n\n## [2.5.0]\n\n- Added List.obs\n- Now you can transform any class on obs\n\n## [2.4.0]\n\n- Added GetX, state manager rxDart based.\n- Fix error on add for non global controllers\n\n## [2.3.2]\n\n- Fix close method called on not root GetBuilder\n\n## [2.3.1]\n\n- Auto close stream inside close method\n- Added docs\n\n## [2.3.0]\n\n- Added interface to GetX support\n\n## [2.2.8]\n\n- Added api to platform brightness\n\n## [2.2.7]\n\n- Fix typos\n\n## [2.2.6]\n\n- Fix cancel button on defaultDialog don't appear when widget implementation usage\n\n## [2.2.5]\n\n- Refator defaultDialog\n\n## [2.2.4]\n\n- Clean code\n- Fix Get.LazyPut\n\n## [2.2.3]\n\n- Remove defaultDialog type\n\n## [2.2.2]\n\n- Fix GetRoute not found\n\n## [2.2.1]\n\n- Improve lazyPut and fix tag to lazyput(@rochadaniel)\n\n## [2.2.0]\n\n- Added: Ability to choose or delay a widget's state change according to its ID.\n- Added: Ability to fire triggers when loading materialApp.\n- Added: Ability to change theme dynamically.\n- Added: Ability to rebuild the entire app with one command.\n- Added: Ability to trigger events on the MaterialApp.\n- Added: Get.lazyPut (lazy loading of dependencies).\n- Added: Get.creator - a factory of dependencies .\n- Added: Capability of define abstract class on dependencies.\n\n## [2.1.2]\n\n- Get.defaultDialog refactor\n\n## [2.1.1]\n\n- fix typo\n\n## [2.1.0]\n\n- Added Get.rawSnackbar\n- Added instantInit config to snackbars\n- Refactor Get Instance Manager\n- Improved performance and bug fix to Get State Manager\n- Improved performance of GetRoute on namedRoutes\n- Hotfix on namedRoutes\n\n## [2.0.10]\n\n- Bump new Flutter version\n- Added Get.generalDialog\n\n## [2.0.6]\n\n- Fix typo on readme\n\n## [2.0.5]\n\n- Changing the bottomsheet API to comply with the documentation.\n\n## [2.0.4]\n\n- Fix type not found in some versions of Flutter stable\n\n## [2.0.3]\n\n- Update Docs\n\n## [2.0.2]\n\n- Update GetObserver\n\n## [2.0.1]\n\n- Fix docs and typos\n\n## [2.0.0]\n\n- Added easy state manager\n- Change dialog API\n- Added GetMaterialApp\n- Added new experimental APIs\n- Improve Observer\n- Added default duration on Transitions\n- Added new routeNamed sistem\n- Added Global stateManager config\n- Improve Get instance manager\n- Added routingCallback\n- Added closeOverlays to Get.back\n- Added dynamic urls\n- Cleaner code\n- Improve lib performance\n- Many others minor APIs added\n\n## [1.20.1]\n\n- Improve: Get.finds\n\n## [1.20.0]\n\n- Added Get Instance Manager\n  Get.put / Get.find / Get.delete\n\n## [1.19.1]\n\n- Fix default transitions for namedRoutes\n\n## [1.19.0]\n\n- Added nested navigators\n\n## [1.18.0]\n\n- Added SafeArea to bottomsheets\n- Added docs\n\n## [1.17.0]\n\n- Added experimental APIs\n\n## [1.16.1]\n\n- Improve: GetObserver\n\n## [1.16.0-dev]\n\n- Added Get config\n- Added logEnable\n- Added Default transition\n- Added default popGesture behaviour\n- Added overlayContext\n- Fix Duration transition\n\n## [1.14.1-dev]\n\n- Fix ternary on new dart version\n\n## [1.14.0-dev]\n\n- Added compatibility with Flutter 1.17.1\n- Added back popGesture to iOS (default) and Android (optional)\n- Improve performance\n- Decrease lib size to 94.9kb (25.4k after compiled on release)\n\n## [1.13.1-dev]\n\n- Fix back function\n\n## [1.13.0-dev]\n\n- Plugin refactor\n- Added GetPlatform\n\n## [1.12.0-dev]\n\n-Compatibility with Dev branch\n\n## [1.11.4]\n\n- Refactor code of library\n\n## [1.11.3]\n\n-Added docs\n\n## [1.11.2]\n\n-Fix flutter web platform and added GetPlatform\n\n## [1.11.1]\n\n-Improve swipe to back on iOS devices\n\n## [1.11.0]\n\n-Added experimental GetCupertino\n\n## [1.10.5]\n\n-Added setKey to improve modular compatibility\n-Added ability to define transition duration directly when calling the new route.\n\n## [1.10.4]\n\n-Improve Get.offAll() - predicate now is optional\n\n## [1.10.3]\n\n-Improve default color from dialogs\n\n## [1.10.2]\n\n-Improve snackbar text color\n-Added background color to snackbar (@claudneysessa)\n\n## [1.10.1]\n\n-Backdrop improvement\n\n## [1.10.0]\n\n-Added backdrop\n\n## [1.9.2]\n\n-Added docs to GetObserver\n\n## [1.9.1]\n\n-Fix typo on snackbar route\n\n## [1.9.0]\n\n-Added: Navigator observer\n-Added: Get.args to named routes\n-Improve snackbar performance\n\n## [1.8.1]\n\n-Fix new snackbar features\n\n## [1.8.0]\n\n-Add Get.close method.\n-Add many Snackbars features\n\n## [1.7.4]\n\n-Fix dialog child error\n\n## [1.7.3]\n\n-Added transitions docs\n\n## [1.7.2]\n\n-Fix bottomsheet on macos\n\n## [1.7.1]\n\n-Fix docs\n\n## [1.7.0]\n\n- Improve geral performance. Get.to Wrap now consumes even less RAM and CPU. In an application with 20 screens, it obtained 82% less RAM usage compared to the traditional method Navigator.push and had a CPU normalization of 23% in a Moto z2, against 64% CPU usage in Navigator.push with MaterialPageRoute. Test it for yourself!\n- Added BottomSheet with no context\n- Added modern Blur Snackbar\n- Added customs transitions\n- Improve dialogs performance\n\n## [1.6.4]\n\n- Improve performance.\n\n## [1.6.3]\n\n- Clean code.\n\n## [1.6.2]\n\n- Fix bugs on blurred Snackbars\n\n## [1.6.1]\n\n- Add docs and improve performance\n\n## [1.6.0]\n\n- Add support to snackbars\n\n## [1.5.0+1]\n\n- Add color and opacity to dialogs\n\n## [1.5.0]\n\n- Add support to dialogs\n\n## [1.4.0+7]\n\n- Add more documentation\n\n## [1.4.0+6]\n\n- Improve performance and bug fix\n\n## [1.4.0]\n\n- Added Get.removeRoute // ability to remove one route.\n  Get.until // back repeatedly until the predicate returns true.\n  Get.offUntil // go to next route and remove all the previous routes until the predicate returns true.\n  Get.offNamedUntil // go to next named route and remove all the previous routes until the predicate returns true.\n\n## [1.3.4]\n\n- Improve performance\n\n## [1.3.3]\n\n- Fix Get.back arguments\n\n## [1.3.2]\n\n- Improve performance\n\n## [1.3.1]\n\n- Update docs\n\n## [1.3.0]\n\n- Update docs, readme, and add full support to flutter_web\n\n## [1.2.1]\n\n- Fix bug currentState = null\n\n## [1.2.0]\n\n- Add routes navigation with no context\n\n## [1.1.0]\n\n- Add support to named routes\n\n## [1.0.3]\n\n- Improve Performance\n\n## [1.0.2]\n\n- Add examples\n\n## [1.0.1]\n\n- Doc changes\n\n## [1.0.0]\n\n- initial release\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "MIT License\n\nCopyright (c) 2019 Jonny Borges\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README-ar.md",
          "type": "blob",
          "size": 51.3798828125,
          "content": "![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n[![pub package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n[![popularity](https://badges.bar/get/popularity)](https://pub.dev/packages/sentry/score)\n[![likes](https://badges.bar/get/likes)](https://pub.dev/packages/get/score)\n[![pub points](https://badges.bar/get/pub%20points)](https://pub.dev/packages/get/score)\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n[![style: effective dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n[![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n[![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n<a href=\"https://github.com/Solido/awesome-flutter\">\n<img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n</a>\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n<div align=\"center\">\n\n**Languages:**\n\n[![English](https://img.shields.io/badge/Language-English-blueviolet?style=for-the-badge)](README.md)\n[![Vietnamese](https://img.shields.io/badge/Language-Vietnamese-blueviolet?style=for-the-badge)](README-vi.md)\n[![Indonesian](https://img.shields.io/badge/Language-Indonesian-blueviolet?style=for-the-badge)](README.id-ID.md)\n[![Urdu](https://img.shields.io/badge/Language-Urdu-blueviolet?style=for-the-badge)](README.ur-PK.md)\n[![Chinese](https://img.shields.io/badge/Language-Chinese-blueviolet?style=for-the-badge)](README.zh-cn.md)\n[![Portuguese](https://img.shields.io/badge/Language-Portuguese-blueviolet?style=for-the-badge)](README.pt-br.md)\n[![Spanish](https://img.shields.io/badge/Language-Spanish-blueviolet?style=for-the-badge)](README-es.md)\n[![Russian](https://img.shields.io/badge/Language-Russian-blueviolet?style=for-the-badge)](README.ru.md)\n[![Polish](https://img.shields.io/badge/Language-Polish-blueviolet?style=for-the-badge)](README.pl.md)\n[![Korean](https://img.shields.io/badge/Language-Korean-blueviolet?style=for-the-badge)](README.ko-kr.md)\n[![French](https://img.shields.io/badge/Language-French-blueviolet?style=for-the-badge)](README-fr.md)\n[![العربيه](https://img.shields.io/badge/Language-arabic-blueviolet?style=for-the-badge)](README-ar.md)\n\n</div>\n<div dir=\"rtl\">\n\n- [عن المكتبة](#عن-المكتبة)\n- [التركيب](#التركيب)\n- [بناء تطبيق العداد 🔢](#بناء-تطبيق-العداد-)\n- [The Three pillars](#the-three-pillars)\n  - [State management](#state-management)\n    - [Reactive State Manager](#reactive-state-manager)\n    - [More details about state management](#more-details-about-state-management)\n  - [Route management](#route-management)\n    - [More details about route management](#more-details-about-route-management)\n  - [Dependency management](#dependency-management)\n    - [More details about dependency management](#more-details-about-dependency-management)\n- [Utils](#utils)\n  - [Internationalization](#internationalization)\n    - [Translations](#translations)\n      - [Using translations](#using-translations)\n      - [Using translation with singular and plural](#using-translation-with-singular-and-plural)\n      - [Using translation with parameters](#using-translation-with-parameters)\n    - [Locales](#locales)\n      - [Change locale](#change-locale)\n      - [System locale](#system-locale)\n  - [Change Theme](#change-theme)\n  - [GetConnect](#getconnect)\n    - [Default configuration](#default-configuration)\n    - [Custom configuration](#custom-configuration)\n  - [GetPage Middleware](#getpage-middleware)\n    - [Priority](#priority)\n    - [Redirect](#redirect)\n    - [onPageCalled](#onpagecalled)\n    - [OnBindingsStart](#onbindingsstart)\n    - [OnPageBuildStart](#onpagebuildstart)\n    - [OnPageBuilt](#onpagebuilt)\n    - [OnPageDispose](#onpagedispose)\n  - [Other Advanced APIs](#other-advanced-apis)\n    - [Optional Global Settings and Manual configurations](#optional-global-settings-and-manual-configurations)\n    - [Local State Widgets](#local-state-widgets)\n      - [ValueBuilder](#valuebuilder)\n      - [ObxValue](#obxvalue)\n  - [Useful tips](#useful-tips)\n  - [StateMixin](#statemixin)\n      - [GetView](#getview)\n      - [GetResponsiveView](#getresponsiveview)\n        - [How to use it](#how-to-use-it)\n      - [GetWidget](#getwidget)\n      - [GetxService](#getxservice)\n    - [Tests](#tests)\n      - [Tips](#tips)\n        - [Mockito or mocktail](#mockito-or-mocktail)\n        - [Using Get.reset()](#using-getreset)\n        - [Get.testMode](#gettestmode)\n- [Breaking changes from 2.0](#breaking-changes-from-20)\n- [Why Getx?](#why-getx)\n- [Community](#community)\n  - [Community channels](#community-channels)\n  - [How to contribute](#how-to-contribute)\n  - [Articles and videos](#articles-and-videos)\n\n# عن المكتبة\n\n- `GetX` مكتبه خفيفه وقوية لفلاتر , توفر المكتبه السرعه العاليه في التحكم في الحاله , نظام حقن `Ddependency injection` ذكي , والتحكم في التنقل بين الصفحات بسرعه وسهوله\n\n- `GetX`\n- تعتمد علي 3 نقاط اساسية . **الانتاجية والسرعه والتنظيم**\n\n  - **السرعه:** `GetX` تركز علي السرعه واقل استخدام للموارد,`GetX` لا تستخدم `Streams` او `ChangeNotifier`.\n\n  - **الانتاجية:** `GetX` تستخدم طريقه سهله ومريحة في كتابة الكود , لا يهم ماذا تريد انت تبني , يوجد دائما طريقه اسهل لبناء باستخدام `GetX` , ستوفر ساعات من العمل وتوفر لك اعلي سرعه يمكن الوصل لها في تطبيقاتك عموما , يجب ان يهتم المطور بالتخلص من الموارد الغير مستخدمه من الذاكرة , مع `GetX` هذا غير ضروري لانه يتم التخلص من الموارد الغير مستخدمه من الذاكره تلقائيا, اذا اردت تركهم دائما في الذاكرة يمكنك ذلك لكن يجب عليك ان تستخدم `permanent: true` بالاضافه الي توفير الوقت تم تقليل امكانية ترك الموارد في الذاكره بدون التخلص منها , يتم حقن الموارد `lazy` افتراضيا\n\n  - **التنظيم:** `GetX` تسمح لك بفصل الـ `view` عن الـ `presentation logic` و `business logic` باكامل,\n    بالنسبة للحقن `dependency injection` و التنقل بين الشاشات لا تحتاج فيهم `context` للتنقل بين الصفحات , ولا تحتاك `context` للوصول للموارد عن طريق widget tree, لذلك يتم الفصل بالكامل بين `presentation logic` و `business logic` لا تحتاج لحقن ال `Controllers/Models/Blocs`\n    داخل شجره العناصر `Widget Tree` خلال `MultiProvider`s.\n    لان , `GetX` تستخدم نظام حقن خاص بها ويمكنك من فصل الـ `DI` عن الوجهات بالكامل .\n\n- مع `Getx` تعرف ايه يكون الكود الخاص ب كل جزء في التطبيق , تساعدك في كتابة كود نظيف , بالاضافه الي سهوله التطوير مستقبلا , وهذا يمكنك من مشاركه الاجزاء `modules` امر صعب ليصبح سهل جدا .\n  `BLOC` كان نقطه البداية لهذا الامر وتظيم الكود بهذه الطريقه في فلاتر , عن طريق فصل كود البزنس عن الواجهات , `GetX` هي التطور لذلك الامر , وذلك عن طريق الاضافه الي ذلك فصل حقن الموارد وفصل التنقل بين الشاشات ايضا , وطبقه البيانات بالكامل ايضا , تعلم اين يكون كل شي في المشروع\n\n- `Getx` توفر لك السهوله في بناء المشروع والاستقرار كلما كبر حجم المشروع واقصي سرعه ممكن , توفر لك ايضا نظام كامل يعمل في تجانس تام , سهل للمبتدئين , ومنظم للخبراء , امن , مستقر , ومحدث باستمرار ويوفر لك موجموعه من الادوات لتسهل عليك\n\n- `GetX` ليست ضخمه , تمتلك المكتبة العديد من المميزات تجعلك تبدا في البرمجه بدون القلق عن اي شي كل ميزه منهم منقسمه عن الاخري ولا يبداو الا عندما تستخدمهم , اذا استخدمت جزء التحكم في الحاله فقط لن يتم استخدام جزء التنقل بين الشاشات في تطبيقك الا `Compiled` والعكس صحيح ! .\n\n-`Getx` لديها نظام شامل , ومجتمع كبير , وعداد كبير من المطورين , وسوف يتم تحديثها باستمرار , تعمل المكتبة علي كل الانظمه بنفس الكود دون تغيير `Android`, `iOS`, `Web`, `Mac`, `Linux`, `Windows` حتي علي الخادم يمكنك استخدام `Getx` لبناء تطبيقات الويب\n**[Get Server](https://github.com/jonataslaw/get_server)**.\n\n**بالاضافه الي ذلك يمكن محاكاه الامر اكثر في فلاتر والخادم عن طريق [Get CLI](https://github.com/jonataslaw/get_cli)**.\n\n**وللمزيد من الانتاجية يمكنك استخدام اضافه للـ**\n\n- [فيجوال ستوديو كود](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets)\n- [اندرويد استوديو و انتلج](https://plugins.jetbrains.com/plugin/14975-getx-snippets)\n\n# التركيب\n\nاستخدم المكتبة في ملف `pubspec.yaml`\n\n<div dir=\"ltr\" >\n\n```yaml\ndependencies:\n  get:\n```\n\n</div>\nاستدعي المكتبة في الملفات الي ستستخدمها\n<div dir=\"ltr\" >\n\n```dart\nimport 'package:get/get.dart';\n```\n\n</div>\n\n# بناء تطبيق العداد 🔢\n\nتطبيق العداد الذي يتم انشاء مع كل مشروع جديد يتعدي ال 100 سطر (بالتعليقات) ولكي اريك مدي قوه `GetX`\nساوضح لك كيفيه بناء التطبيق مع تغير قيمه العداد مع كل ضغطه زر والتقل بين الشاشات ومشاركه الحاله كل ذلك بطريقه منذمه وفصل تام لكود البزنس عن الواجهات فقط ب 26 سطر من ضمنهم التعليقات 🔥\n\n- الخطوه الاولي :\n  اكتب `Get` امام `MaterialApp` لتصبح `GetMaterialApp`\n\n<div dir=\"ltr\" >\n\n```dart\nvoid main() => runApp(GetMaterialApp(home: Home()));\n```\n\n</div>\n\n- ملحوظه : هذا لا يعتبر تعديل علي `MaterialApp` لان , `GetMaterialApp` عباره عن عنصر معد مسبقا ويستخدم `MaterialApp` تحت الغطاء , يمكن تغير الاعدادات يدوين لكن هذا غير ضروري لان ``سيقوم بعمل المسارات و حقن العناصر والترجمه وكل شي تحتاجه ولكن اذا كنت تنوي لاستخدام المكتبة فقط للتحكم في الحاله`State managment`فهذه الخطوه غير ضرورية تكون هذه الخطوه ضرورية عندما تريد التنقل بين الشاشات او عرض`snackbars`والترجمه و اي شي يعتمد علي`context`وتقوم`getx` بتوفيره\n\n- الخطوه الثانية\n  قم بكتابة الكود داخل `class` وكتابة المتغيرات والدوال , يمكنك جعل المتغير قابلع لاعاده بناء الواجها عند تغير قيمته باستخدام ال `getter` `.obs` .\n\n<div dir=\"ltr\" >\n\n```dart\nclass Controller extends GetxController{\n  var count = 0.obs;\n  increment() => count++;\n}\n```\n\n</div>\n\n- الخطوه الثالثه\nابني الواجهه واستخدم `StatelessWidget` لتوفير الموارد , مع `Getx` يمكنك الاستغناء عن `StatefulWidget`.\n<div dir=\"ltr\" >\n\n```dart\nclass Home extends StatelessWidget {\n\n  @override\n  Widget build(context) {\n\n    // Instantiate your class using Get.put() to make it available for all \"child\" routes there.\n    final  c = Get.put(Controller());\n\n    return Scaffold(\n      // Use Obx(()=> to update Text() whenever count is changed.\n      appBar: AppBar(title: Obx(() => Text(\"Clicks: ${c.count}\"))),\n\n      // Replace the 8 lines Navigator.push by a simple Get.to(). You don't need context\n      body: Center(child: ElevatedButton(\n              child: Text(\"Go to Other\"), onPressed: () => Get.to(Other()))),\n      floatingActionButton:\n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n  }\n}\n\nclass Other extends StatelessWidget {\n  // You can ask Get to find a Controller that is being used by another page and redirect you to it.\n  final Controller c = Get.find();\n\n  @override\n  Widget build(context){\n     // Access the updated count variable\n     return Scaffold(body: Center(child: Text(\"${c.count}\")));\n  }\n}\n```\n\n</div>\n\nResult:\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/counter-app-gif.gif)\n\nThis is a simple project but it already makes clear how powerful Get is. As your project grows, this difference will become more significant.\n\nGet was designed to work with teams, but it makes the job of an individual developer simple.\n\nImprove your deadlines, deliver everything on time without losing performance. Get is not for everyone, but if you identified with that phrase, Get is for you!\n\n# The Three pillars\n\n## State management\n\nGet has two different state managers: the simple state manager (we'll call it GetBuilder) and the reactive state manager (GetX/Obx)\n\n### Reactive State Manager\n\nReactive programming can alienate many people because it is said to be complicated. GetX turns reactive programming into something quite simple:\n\n- You won't need to create StreamControllers.\n- You won't need to create a StreamBuilder for each variable\n- You will not need to create a class for each state.\n- You will not need to create a get for an initial value.\n- You will not need to use code generators\n\nReactive programming with Get is as easy as using setState.\n\nLet's imagine that you have a name variable and want that every time you change it, all widgets that use it are automatically changed.\n\nThis is your count variable:\n\n```dart\nvar name = 'Jonatas Borges';\n```\n\nTo make it observable, you just need to add \".obs\" to the end of it:\n\n```dart\nvar name = 'Jonatas Borges'.obs;\n```\n\nAnd in the UI, when you want to show that value and update the screen whenever the values changes, simply do this:\n\n```dart\nObx(() => Text(\"${controller.name}\"));\n```\n\nThat's all. It's _that_ simple.\n\n### More details about state management\n\n**See an more in-depth explanation of state management [here](./documentation/en_US/state_management.md). There you will see more examples and also the difference between the simple state manager and the reactive state manager**\n\nYou will get a good idea of GetX power.\n\n## Route management\n\nIf you are going to use routes/snackbars/dialogs/bottomsheets without context, GetX is excellent for you too, just see it:\n\nAdd \"Get\" before your MaterialApp, turning it into GetMaterialApp\n\n```dart\nGetMaterialApp( // Before: MaterialApp(\n  home: MyHome(),\n)\n```\n\nNavigate to a new screen:\n\n```dart\n\nGet.to(NextScreen());\n```\n\nNavigate to new screen with name. See more details on named routes [here](./documentation/en_US/route_management.md#navigation-with-named-routes)\n\n```dart\n\nGet.toNamed('/details');\n```\n\nTo close snackbars, dialogs, bottomsheets, or anything you would normally close with Navigator.pop(context);\n\n```dart\nGet.back();\n```\n\nTo go to the next screen and no option to go back to the previous screen (for use in SplashScreens, login screens, etc.)\n\n```dart\nGet.off(NextScreen());\n```\n\nTo go to the next screen and cancel all previous routes (useful in shopping carts, polls, and tests)\n\n```dart\nGet.offAll(NextScreen());\n```\n\nNoticed that you didn't have to use context to do any of these things? That's one of the biggest advantages of using Get route management. With this, you can execute all these methods from within your controller class, without worries.\n\n### More details about route management\n\n**Get works with named routes and also offers lower-level control over your routes! There is in-depth documentation [here](./documentation/en_US/route_management.md)**\n\n## Dependency management\n\nGet has a simple and powerful dependency manager that allows you to retrieve the same class as your Bloc or Controller with just 1 lines of code, no Provider context, no inheritedWidget:\n\n```dart\nController controller = Get.put(Controller()); // Rather Controller controller = Controller();\n```\n\n- Note: If you are using Get's State Manager, pay more attention to the bindings API, which will make it easier to connect your view to your controller.\n\nInstead of instantiating your class within the class you are using, you are instantiating it within the Get instance, which will make it available throughout your App.\nSo you can use your controller (or class Bloc) normally\n\n**Tip:** Get dependency management is decoupled from other parts of the package, so if for example, your app is already using a state manager (any one, it doesn't matter), you don't need to rewrite it all, you can use this dependency injection with no problems at all\n\n```dart\ncontroller.fetchApi();\n```\n\nImagine that you have navigated through numerous routes, and you need data that was left behind in your controller, you would need a state manager combined with the Provider or Get_it, correct? Not with Get. You just need to ask Get to \"find\" for your controller, you don't need any additional dependencies:\n\n```dart\nController controller = Get.find();\n//Yes, it looks like Magic, Get will find your controller, and will deliver it to you. You can have 1 million controllers instantiated, Get will always give you the right controller.\n```\n\nAnd then you will be able to recover your controller data that was obtained back there:\n\n```dart\nText(controller.textFromApi);\n```\n\n### More details about dependency management\n\n**See a more in-depth explanation of dependency management [here](./documentation/en_US/dependency_management.md)**\n\n# Utils\n\n## Internationalization\n\n### Translations\n\nTranslations are kept as a simple key-value dictionary map.\nTo add custom translations, create a class and extend `Translations`.\n\n```dart\nimport 'package:get/get.dart';\n\nclass Messages extends Translations {\n  @override\n  Map<String, Map<String, String>> get keys => {\n        'en_US': {\n          'hello': 'Hello World',\n        },\n        'de_DE': {\n          'hello': 'Hallo Welt',\n        }\n      };\n}\n```\n\n#### Using translations\n\nJust append `.tr` to the specified key and it will be translated, using the current value of `Get.locale` and `Get.fallbackLocale`.\n\n```dart\nText('title'.tr);\n```\n\n#### Using translation with singular and plural\n\n```dart\nvar products = [];\nText('singularKey'.trPlural('pluralKey', products.length, Args));\n```\n\n#### Using translation with parameters\n\n```dart\nimport 'package:get/get.dart';\n\n\nMap<String, Map<String, String>> get keys => {\n    'en_US': {\n        'logged_in': 'logged in as @name with email @email',\n    },\n    'es_ES': {\n       'logged_in': 'iniciado sesión como @name con e-mail @email',\n    }\n};\n\nText('logged_in'.trParams({\n  'name': 'Jhon',\n  'email': 'jhon@example.com'\n  }));\n```\n\n### Locales\n\nPass parameters to `GetMaterialApp` to define the locale and translations.\n\n```dart\nreturn GetMaterialApp(\n    translations: Messages(), // your translations\n    locale: Locale('en', 'US'), // translations will be displayed in that locale\n    fallbackLocale: Locale('en', 'UK'), // specify the fallback locale in case an invalid locale is selected.\n);\n```\n\n#### Change locale\n\nCall `Get.updateLocale(locale)` to update the locale. Translations then automatically use the new locale.\n\n```dart\nvar locale = Locale('en', 'US');\nGet.updateLocale(locale);\n```\n\n#### System locale\n\nTo read the system locale, you could use `Get.deviceLocale`.\n\n```dart\nreturn GetMaterialApp(\n    locale: Get.deviceLocale,\n);\n```\n\n## Change Theme\n\nPlease do not use any higher level widget than `GetMaterialApp` in order to update it. This can trigger duplicate keys. A lot of people are used to the prehistoric approach of creating a \"ThemeProvider\" widget just to change the theme of your app, and this is definitely NOT necessary with **GetX™**.\n\nYou can create your custom theme and simply add it within `Get.changeTheme` without any boilerplate for that:\n\n```dart\nGet.changeTheme(ThemeData.light());\n```\n\nIf you want to create something like a button that changes the Theme in `onTap`, you can combine two **GetX™** APIs for that:\n\n- The api that checks if the dark `Theme` is being used.\n- And the `Theme` Change API, you can just put this within an `onPressed`:\n\n```dart\nGet.changeTheme(Get.isDarkMode? ThemeData.light(): ThemeData.dark());\n```\n\nWhen `.darkmode` is activated, it will switch to the _light theme_, and when the _light theme_ becomes active, it will change to _dark theme_.\n\n## GetConnect\n\nGetConnect is an easy way to communicate from your back to your front with http or websockets\n\n### Default configuration\n\nYou can simply extend GetConnect and use the GET/POST/PUT/DELETE/SOCKET methods to communicate with your Rest API or websockets.\n\n```dart\nclass UserProvider extends GetConnect {\n  // Get request\n  Future<Response> getUser(int id) => get('http://youapi/users/$id');\n  // Post request\n  Future<Response> postUser(Map data) => post('http://youapi/users', body: data);\n  // Post request with File\n  Future<Response<CasesModel>> postCases(List<int> image) {\n    final form = FormData({\n      'file': MultipartFile(image, filename: 'avatar.png'),\n      'otherFile': MultipartFile(image, filename: 'cover.png'),\n    });\n    return post('http://youapi/users/upload', form);\n  }\n\n  GetSocket userMessages() {\n    return socket('https://yourapi/users/socket');\n  }\n}\n```\n\n### Custom configuration\n\nGetConnect is highly customizable You can define base Url, as answer modifiers, as Requests modifiers, define an authenticator, and even the number of attempts in which it will try to authenticate itself, in addition to giving the possibility to define a standard decoder that will transform all your requests into your Models without any additional configuration.\n\n```dart\nclass HomeProvider extends GetConnect {\n  @override\n  void onInit() {\n    // All request will pass to jsonEncode so CasesModel.fromJson()\n    httpClient.defaultDecoder = CasesModel.fromJson;\n    httpClient.baseUrl = 'https://api.covid19api.com';\n    // baseUrl = 'https://api.covid19api.com'; // It define baseUrl to\n    // Http and websockets if used with no [httpClient] instance\n\n    // It's will attach 'apikey' property on header from all requests\n    httpClient.addRequestModifier((request) {\n      request.headers['apikey'] = '12345678';\n      return request;\n    });\n\n    // Even if the server sends data from the country \"Brazil\",\n    // it will never be displayed to users, because you remove\n    // that data from the response, even before the response is delivered\n    httpClient.addResponseModifier<CasesModel>((request, response) {\n      CasesModel model = response.body;\n      if (model.countries.contains('Brazil')) {\n        model.countries.remove('Brazilll');\n      }\n    });\n\n    httpClient.addAuthenticator((request) async {\n      final response = await get(\"http://yourapi/token\");\n      final token = response.body['token'];\n      // Set the header\n      request.headers['Authorization'] = \"$token\";\n      return request;\n    });\n\n    //Autenticator will be called 3 times if HttpStatus is\n    //HttpStatus.unauthorized\n    httpClient.maxAuthRetries = 3;\n  }\n\n  @override\n  Future<Response<CasesModel>> getCases(String path) => get(path);\n}\n```\n\n## GetPage Middleware\n\nThe GetPage has now new property that takes a list of GetMiddleWare and run them in the specific order.\n\n**Note**: When GetPage has a Middlewares, all the children of this page will have the same middlewares automatically.\n\n### Priority\n\nThe Order of the Middlewares to run can be set by the priority in the GetMiddleware.\n\n```dart\nfinal middlewares = [\n  GetMiddleware(priority: 2),\n  GetMiddleware(priority: 5),\n  GetMiddleware(priority: 4),\n  GetMiddleware(priority: -8),\n];\n```\n\nthose middlewares will be run in this order **-8 => 2 => 4 => 5**\n\n### Redirect\n\nThis function will be called when the page of the called route is being searched for. It takes RouteSettings as a result to redirect to. Or give it null and there will be no redirecting.\n\n```dart\nRouteSettings redirect(String route) {\n  final authService = Get.find<AuthService>();\n  return authService.authed.value ? null : RouteSettings(name: '/login')\n}\n```\n\n### onPageCalled\n\nThis function will be called when this Page is called before anything created\nyou can use it to change something about the page or give it new page\n\n```dart\nGetPage onPageCalled(GetPage page) {\n  final authService = Get.find<AuthService>();\n  return page.copyWith(title: 'Welcome ${authService.UserName}');\n}\n```\n\n### OnBindingsStart\n\nThis function will be called right before the Bindings are initialize.\nHere you can change Bindings for this page.\n\n```dart\nList<Bindings> onBindingsStart(List<Bindings> bindings) {\n  final authService = Get.find<AuthService>();\n  if (authService.isAdmin) {\n    bindings.add(AdminBinding());\n  }\n  return bindings;\n}\n```\n\n### OnPageBuildStart\n\nThis function will be called right after the Bindings are initialize.\nHere you can do something after that you created the bindings and before creating the page widget.\n\n```dart\nGetPageBuilder onPageBuildStart(GetPageBuilder page) {\n  print('bindings are ready');\n  return page;\n}\n```\n\n### OnPageBuilt\n\nThis function will be called right after the GetPage.page function is called and will give you the result of the function. and take the widget that will be showed.\n\n### OnPageDispose\n\nThis function will be called right after disposing all the related objects (Controllers, views, ...) of the page.\n\n## Other Advanced APIs\n\n```dart\n// give the current args from currentScreen\nGet.arguments\n\n// give name of previous route\nGet.previousRoute\n\n// give the raw route to access for example, rawRoute.isFirst()\nGet.rawRoute\n\n// give access to Routing API from GetObserver\nGet.routing\n\n// check if snackbar is open\nGet.isSnackbarOpen\n\n// check if dialog is open\nGet.isDialogOpen\n\n// check if bottomsheet is open\nGet.isBottomSheetOpen\n\n// remove one route.\nGet.removeRoute()\n\n// back repeatedly until the predicate returns true.\nGet.until()\n\n// go to next route and remove all the previous routes until the predicate returns true.\nGet.offUntil()\n\n// go to next named route and remove all the previous routes until the predicate returns true.\nGet.offNamedUntil()\n\n//Check in what platform the app is running\nGetPlatform.isAndroid\nGetPlatform.isIOS\nGetPlatform.isMacOS\nGetPlatform.isWindows\nGetPlatform.isLinux\nGetPlatform.isFuchsia\n\n//Check the device type\nGetPlatform.isMobile\nGetPlatform.isDesktop\n//All platforms are supported independently in web!\n//You can tell if you are running inside a browser\n//on Windows, iOS, OSX, Android, etc.\nGetPlatform.isWeb\n\n\n// Equivalent to : MediaQuery.of(context).size.height,\n// but immutable.\nGet.height\nGet.width\n\n// Gives the current context of the Navigator.\nGet.context\n\n// Gives the context of the snackbar/dialog/bottomsheet in the foreground, anywhere in your code.\nGet.contextOverlay\n\n// Note: the following methods are extensions on context. Since you\n// have access to context in any place of your UI, you can use it anywhere in the UI code\n\n// If you need a changeable height/width (like Desktop or browser windows that can be scaled) you will need to use context.\ncontext.width\ncontext.height\n\n// Gives you the power to define half the screen, a third of it and so on.\n// Useful for responsive applications.\n// param dividedBy (double) optional - default: 1\n// param reducedBy (double) optional - default: 0\ncontext.heightTransformer()\ncontext.widthTransformer()\n\n/// Similar to MediaQuery.of(context).size\ncontext.mediaQuerySize()\n\n/// Similar to MediaQuery.of(context).padding\ncontext.mediaQueryPadding()\n\n/// Similar to MediaQuery.of(context).viewPadding\ncontext.mediaQueryViewPadding()\n\n/// Similar to MediaQuery.of(context).viewInsets;\ncontext.mediaQueryViewInsets()\n\n/// Similar to MediaQuery.of(context).orientation;\ncontext.orientation()\n\n/// Check if device is on landscape mode\ncontext.isLandscape()\n\n/// Check if device is on portrait mode\ncontext.isPortrait()\n\n/// Similar to MediaQuery.of(context).devicePixelRatio;\ncontext.devicePixelRatio()\n\n/// Similar to MediaQuery.of(context).textScaleFactor;\ncontext.textScaleFactor()\n\n/// Get the shortestSide from screen\ncontext.mediaQueryShortestSide()\n\n/// True if width be larger than 800\ncontext.showNavbar()\n\n/// True if the shortestSide is smaller than 600p\ncontext.isPhone()\n\n/// True if the shortestSide is largest than 600p\ncontext.isSmallTablet()\n\n/// True if the shortestSide is largest than 720p\ncontext.isLargeTablet()\n\n/// True if the current device is Tablet\ncontext.isTablet()\n\n/// Returns a value<T> according to the screen size\n/// can give value for:\n/// watch: if the shortestSide is smaller than 300\n/// mobile: if the shortestSide is smaller than 600\n/// tablet: if the shortestSide is smaller than 1200\n/// desktop: if width is largest than 1200\ncontext.responsiveValue<T>()\n```\n\n### Optional Global Settings and Manual configurations\n\nGetMaterialApp configures everything for you, but if you want to configure Get manually.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver()],\n);\n```\n\nYou will also be able to use your own Middleware within `GetObserver`, this will not influence anything.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [\n    GetObserver(MiddleWare.observer) // Here\n  ],\n);\n```\n\nYou can create _Global Settings_ for `Get`. Just add `Get.config` to your code before pushing any route.\nOr do it directly in your `GetMaterialApp`\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  defaultTransition: Transition.fade,\n  opaqueRoute: Get.isOpaqueRouteDefault,\n  popGesture: Get.isPopGestureEnable,\n  transitionDuration: Get.defaultDurationTransition,\n  defaultGlobalState: Get.defaultGlobalState,\n);\n\nGet.config(\n  enableLog = true,\n  defaultPopGesture = true,\n  defaultTransition = Transitions.cupertino\n)\n```\n\nYou can optionally redirect all the logging messages from `Get`.\nIf you want to use your own, favourite logging package,\nand want to capture the logs there:\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  logWriterCallback: localLogWriter,\n);\n\nvoid localLogWriter(String text, {bool isError = false}) {\n  // pass the message to your favourite logging package here\n  // please note that even if enableLog: false log messages will be pushed in this callback\n  // you get check the flag if you want through GetConfig.isLogEnable\n}\n\n```\n\n### Local State Widgets\n\nThese Widgets allows you to manage a single value, and keep the state ephemeral and locally.\nWe have flavours for Reactive and Simple.\nFor instance, you might use them to toggle obscureText in a `TextField`, maybe create a custom\nExpandable Panel, or maybe modify the current index in `BottomNavigationBar` while changing the content\nof the body in a `Scaffold`.\n\n#### ValueBuilder\n\nA simplification of `StatefulWidget` that works with a `.setState` callback that takes the updated value.\n\n```dart\nValueBuilder<bool>(\n  initialValue: false,\n  builder: (value, updateFn) => Switch(\n    value: value,\n    onChanged: updateFn, // same signature! you could use ( newValue ) => updateFn( newValue )\n  ),\n  // if you need to call something outside the builder method.\n  onUpdate: (value) => print(\"Value updated: $value\"),\n  onDispose: () => print(\"Widget unmounted\"),\n),\n```\n\n#### ObxValue\n\nSimilar to [`ValueBuilder`](#valuebuilder), but this is the Reactive version, you pass a Rx instance (remember the magical .obs?) and\nupdates automatically... isn't it awesome?\n\n```dart\nObxValue((data) => Switch(\n        value: data.value,\n        onChanged: data, // Rx has a _callable_ function! You could use (flag) => data.value = flag,\n    ),\n    false.obs,\n),\n```\n\n## Useful tips\n\n`.obs`ervables (also known as _Rx_ Types) have a wide variety of internal methods and operators.\n\n> Is very common to _believe_ that a property with `.obs` **IS** the actual value... but make no mistake!\n> We avoid the Type declaration of the variable, because Dart's compiler is smart enough, and the code\n> looks cleaner, but:\n\n```dart\nvar message = 'Hello world'.obs;\nprint( 'Message \"$message\" has Type ${message.runtimeType}');\n```\n\nEven if `message` _prints_ the actual String value, the Type is **RxString**!\n\nSo, you can't do `message.substring( 0, 4 )`.\nYou have to access the real `value` inside the _observable_:\nThe most \"used way\" is `.value`, but, did you know that you can also use...\n\n```dart\nfinal name = 'GetX'.obs;\n// only \"updates\" the stream, if the value is different from the current one.\nname.value = 'Hey';\n\n// All Rx properties are \"callable\" and returns the new value.\n// but this approach does not accepts `null`, the UI will not rebuild.\nname('Hello');\n\n// is like a getter, prints 'Hello'.\nname() ;\n\n/// numbers:\n\nfinal count = 0.obs;\n\n// You can use all non mutable operations from num primitives!\ncount + 1;\n\n// Watch out! this is only valid if `count` is not final, but var\ncount += 1;\n\n// You can also compare against values:\ncount > 2;\n\n/// booleans:\n\nfinal flag = false.obs;\n\n// switches the value between true/false\nflag.toggle();\n\n\n/// all types:\n\n// Sets the `value` to null.\nflag.nil();\n\n// All toString(), toJson() operations are passed down to the `value`\nprint( count ); // calls `toString()` inside  for RxInt\n\nfinal abc = [0,1,2].obs;\n// Converts the value to a json Array, prints RxList\n// Json is supported by all Rx types!\nprint('json: ${jsonEncode(abc)}, type: ${abc.runtimeType}');\n\n// RxMap, RxList and RxSet are special Rx types, that extends their native types.\n// but you can work with a List as a regular list, although is reactive!\nabc.add(12); // pushes 12 to the list, and UPDATES the stream.\nabc[3]; // like Lists, reads the index 3.\n\n\n// equality works with the Rx and the value, but hashCode is always taken from the value\nfinal number = 12.obs;\nprint( number == 12 ); // prints > true\n\n/// Custom Rx Models:\n\n// toJson(), toString() are deferred to the child, so you can implement override on them, and print() the observable directly.\n\nclass User {\n    String name, last;\n    int age;\n    User({this.name, this.last, this.age});\n\n    @override\n    String toString() => '$name $last, $age years old';\n}\n\nfinal user = User(name: 'John', last: 'Doe', age: 33).obs;\n\n// `user` is \"reactive\", but the properties inside ARE NOT!\n// So, if we change some variable inside of it...\nuser.value.name = 'Roi';\n// The widget will not rebuild!,\n// `Rx` don't have any clue when you change something inside user.\n// So, for custom classes, we need to manually \"notify\" the change.\nuser.refresh();\n\n// or we can use the `update()` method!\nuser.update((value){\n  value.name='Roi';\n});\n\nprint( user );\n```\n\n## StateMixin\n\nAnother way to handle your `UI` state is use the `StateMixin<T>` .\nTo implement it, use the `with` to add the `StateMixin<T>`\nto your controller which allows a T model.\n\n```dart\nclass Controller extends GetController with StateMixin<User>{}\n```\n\nThe `change()` method change the State whenever we want.\nJust pass the data and the status in this way:\n\n```dart\nchange(data, status: RxStatus.success());\n```\n\nRxStatus allow these status:\n\n```dart\nRxStatus.loading();\nRxStatus.success();\nRxStatus.empty();\nRxStatus.error('message');\n```\n\nTo represent it in the UI, use:\n\n```dart\nclass OtherClass extends GetView<Controller> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n\n      body: controller.obx(\n        (state)=>Text(state.name),\n\n        // here you can put your custom loading indicator, but\n        // by default would be Center(child:CircularProgressIndicator())\n        onLoading: CustomLoadingIndicator(),\n        onEmpty: Text('No data found'),\n\n        // here also you can set your own error widget, but by\n        // default will be an Center(child:Text(error))\n        onError: (error)=>Text(error),\n      ),\n    );\n}\n```\n\n#### GetView\n\nI love this Widget, is so simple, yet, so useful!\n\nIs a `const Stateless` Widget that has a getter `controller` for a registered `Controller`, that's all.\n\n```dart\n class AwesomeController extends GetController {\n   final String title = 'My Awesome View';\n }\n\n  // ALWAYS remember to pass the `Type` you used to register your controller!\n class AwesomeView extends GetView<AwesomeController> {\n   @override\n   Widget build(BuildContext context) {\n     return Container(\n       padding: EdgeInsets.all(20),\n       child: Text(controller.title), // just call `controller.something`\n     );\n   }\n }\n```\n\n#### GetResponsiveView\n\nExtend this widget to build responsive view.\nthis widget contains the `screen` property that have all\ninformation about the screen size and type.\n\n##### How to use it\n\nYou have two options to build it.\n\n- with `builder` method you return the widget to build.\n- with methods `desktop`, `tablet`,`phone`, `watch`. the specific\n  method will be built when the screen type matches the method\n  when the screen is [ScreenType.Tablet] the `tablet` method\n  will be exuded and so on.\n  **Note:** If you use this method please set the property `alwaysUseBuilder` to `false`\n\nWith `settings` property you can set the width limit for the screen types.\n\n![example](https://github.com/SchabanBo/get_page_example/blob/master/docs/Example.gif?raw=true)\nCode to this screen\n[code](https://github.com/SchabanBo/get_page_example/blob/master/lib/pages/responsive_example/responsive_view.dart)\n\n#### GetWidget\n\nMost people have no idea about this Widget, or totally confuse the usage of it.\nThe use case is very rare, but very specific: It `caches` a Controller.\nBecause of the _cache_, can't be a `const Stateless`.\n\n> So, when do you need to \"cache\" a Controller?\n\nIf you use, another \"not so common\" feature of **GetX**: `Get.create()`.\n\n`Get.create(()=>Controller())` will generate a new `Controller` each time you call\n`Get.find<Controller>()`,\n\nThat's where `GetWidget` shines... as you can use it, for example,\nto keep a list of Todo items. So, if the widget gets \"rebuilt\", it will keep the same controller instance.\n\n#### GetxService\n\nThis class is like a `GetxController`, it shares the same lifecycle ( `onInit()`, `onReady()`, `onClose()`).\nBut has no \"logic\" inside of it. It just notifies **GetX** Dependency Injection system, that this subclass\n**can not** be removed from memory.\n\nSo is super useful to keep your \"Services\" always reachable and active with `Get.find()`. Like:\n`ApiService`, `StorageService`, `CacheService`.\n\n```dart\nFuture<void> main() async {\n  await initServices(); /// AWAIT SERVICES INITIALIZATION.\n  runApp(SomeApp());\n}\n\n/// Is a smart move to make your Services intiialize before you run the Flutter app.\n/// as you can control the execution flow (maybe you need to load some Theme configuration,\n/// apiKey, language defined by the User... so load SettingService before running ApiService.\n/// so GetMaterialApp() doesnt have to rebuild, and takes the values directly.\nvoid initServices() async {\n  print('starting services ...');\n  /// Here is where you put get_storage, hive, shared_pref initialization.\n  /// or moor connection, or whatever that's async.\n  await Get.putAsync(() => DbService().init());\n  await Get.putAsync(SettingsService()).init();\n  print('All services started...');\n}\n\nclass DbService extends GetxService {\n  Future<DbService> init() async {\n    print('$runtimeType delays 2 sec');\n    await 2.delay();\n    print('$runtimeType ready!');\n    return this;\n  }\n}\n\nclass SettingsService extends GetxService {\n  void init() async {\n    print('$runtimeType delays 1 sec');\n    await 1.delay();\n    print('$runtimeType ready!');\n  }\n}\n\n```\n\nThe only way to actually delete a `GetxService`, is with `Get.reset()` which is like a\n\"Hot Reboot\" of your app. So remember, if you need absolute persistence of a class instance during the\nlifetime of your app, use `GetxService`.\n\n### Tests\n\nYou can test your controllers like any other class, including their lifecycles:\n\n```dart\nclass Controller extends GetxController {\n  @override\n  void onInit() {\n    super.onInit();\n    //Change value to name2\n    name.value = 'name2';\n  }\n\n  @override\n  void onClose() {\n    name.value = '';\n    super.onClose();\n  }\n\n  final name = 'name1'.obs;\n\n  void changeName() => name.value = 'name3';\n}\n\nvoid main() {\n  test('''\nTest the state of the reactive variable \"name\" across all of its lifecycles''',\n      () {\n    /// You can test the controller without the lifecycle,\n    /// but it's not recommended unless you're not using\n    ///  GetX dependency injection\n    final controller = Controller();\n    expect(controller.name.value, 'name1');\n\n    /// If you are using it, you can test everything,\n    /// including the state of the application after each lifecycle.\n    Get.put(controller); // onInit was called\n    expect(controller.name.value, 'name2');\n\n    /// Test your functions\n    controller.changeName();\n    expect(controller.name.value, 'name3');\n\n    /// onClose was called\n    Get.delete<Controller>();\n\n    expect(controller.name.value, '');\n  });\n}\n```\n\n#### Tips\n\n##### Mockito or mocktail\n\nIf you need to mock your GetxController/GetxService, you should extend GetxController, and mixin it with Mock, that way\n\n```dart\nclass NotificationServiceMock extends GetxService with Mock implements NotificationService {}\n```\n\n##### Using Get.reset()\n\nIf you are testing widgets, or test groups, use Get.reset at the end of your test or in tearDown to reset all settings from your previous test.\n\n##### Get.testMode\n\nif you are using your navigation in your controllers, use `Get.testMode = true` at the beginning of your main.\n\n# Breaking changes from 2.0\n\n1- Rx types:\n\n| Before  | After      |\n| ------- | ---------- |\n| StringX | `RxString` |\n| IntX    | `RxInt`    |\n| MapX    | `RxMap`    |\n| ListX   | `RxList`   |\n| NumX    | `RxNum`    |\n| DoubleX | `RxDouble` |\n\nRxController and GetBuilder now have merged, you no longer need to memorize which controller you want to use, just use GetxController, it will work for simple state management and for reactive as well.\n\n2- NamedRoutes\nBefore:\n\n```dart\nGetMaterialApp(\n  namedRoutes: {\n    '/': GetRoute(page: Home()),\n  }\n)\n```\n\nNow:\n\n```dart\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page: () => Home()),\n  ]\n)\n```\n\nWhy this change?\nOften, it may be necessary to decide which page will be displayed from a parameter, or a login token, the previous approach was inflexible, as it did not allow this.\nInserting the page into a function has significantly reduced the RAM consumption, since the routes will not be allocated in memory since the app was started, and it also allowed to do this type of approach:\n\n```dart\n\nGetStorage box = GetStorage();\n\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page:(){\n      return box.hasData('token') ? Home() : Login();\n    })\n  ]\n)\n```\n\n# Why Getx?\n\n1- Many times after a Flutter update, many of your packages will break. Sometimes compilation errors happen, errors often appear that there are still no answers about, and the developer needs to know where the error came from, track the error, only then try to open an issue in the corresponding repository, and see its problem solved. Get centralizes the main resources for development (State, dependency and route management), allowing you to add a single package to your pubspec, and start working. After a Flutter update, the only thing you need to do is update the Get dependency, and get to work. Get also resolves compatibility issues. How many times a version of a package is not compatible with the version of another, because one uses a dependency in one version, and the other in another version? This is also not a concern using Get, as everything is in the same package and is fully compatible.\n\n2- Flutter is easy, Flutter is incredible, but Flutter still has some boilerplate that may be unwanted for most developers, such as `Navigator.of(context).push (context, builder [...]`. Get simplifies development. Instead of writing 8 lines of code to just call a route, you can just do it: `Get.to(Home())` and you're done, you'll go to the next page. Dynamic web urls are a really painful thing to do with Flutter currently, and that with GetX is stupidly simple. Managing states in Flutter, and managing dependencies is also something that generates a lot of discussion, as there are hundreds of patterns in the pub. But there is nothing as easy as adding a \".obs\" at the end of your variable, and place your widget inside an Obx, and that's it, all updates to that variable will be automatically updated on the screen.\n\n3- Ease without worrying about performance. Flutter's performance is already amazing, but imagine that you use a state manager, and a locator to distribute your blocs/stores/controllers/ etc. classes. You will have to manually call the exclusion of that dependency when you don't need it. But have you ever thought of simply using your controller, and when it was no longer being used by anyone, it would simply be deleted from memory? That's what GetX does. With SmartManagement, everything that is not being used is deleted from memory, and you shouldn't have to worry about anything but programming. You will be assured that you are consuming the minimum necessary resources, without even having created a logic for this.\n\n4- Actual decoupling. You may have heard the concept \"separate the view from the business logic\". This is not a peculiarity of BLoC, MVC, MVVM, and any other standard on the market has this concept. However, this concept can often be mitigated in Flutter due to the use of context.\nIf you need context to find an InheritedWidget, you need it in the view, or pass the context by parameter. I particularly find this solution very ugly, and to work in teams we will always have a dependence on View's business logic. Getx is unorthodox with the standard approach, and while it does not completely ban the use of StatefulWidgets, InitState, etc., it always has a similar approach that can be cleaner. Controllers have life cycles, and when you need to make an APIREST request for example, you don't depend on anything in the view. You can use onInit to initiate the http call, and when the data arrives, the variables will be populated. As GetX is fully reactive (really, and works under streams), once the items are filled, all widgets that use that variable will be automatically updated in the view. This allows people with UI expertise to work only with widgets, and not have to send anything to business logic other than user events (like clicking a button), while people working with business logic will be free to create and test the business logic separately.\n\nThis library will always be updated and implementing new features. Feel free to offer PRs and contribute to them.\n\n# Community\n\n## Community channels\n\nGetX has a highly active and helpful community. If you have questions, or would like any assistance regarding the use of this framework, please join our community channels, your question will be answered more quickly, and it will be the most suitable place. This repository is exclusive for opening issues, and requesting resources, but feel free to be part of GetX Community.\n\n| **Slack**                                                                                                                   | **Discord**                                                                                                                 | **Telegram**                                                                                                          |\n| :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |\n| [![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx) | [![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N) | [![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g) |\n\n## How to contribute\n\n_Want to contribute to the project? We will be proud to highlight you as one of our collaborators. Here are some points where you can contribute and make Get (and Flutter) even better._\n\n- Helping to translate the readme into other languages.\n- Adding documentation to the readme (a lot of Get's functions haven't been documented yet).\n- Write articles or make videos teaching how to use Get (they will be inserted in the Readme and in the future in our Wiki).\n- Offering PRs for code/tests.\n- Including new functions.\n\nAny contribution is welcome!\n\n## Articles and videos\n\n- [Flutter Getx EcoSystem package for arabic people](https://www.youtube.com/playlist?list=PLV1fXIAyjeuZ6M8m56zajMUwu4uE3-SL0) - Tutorial by [Pesa Coder](https://github.com/UsamaElgendy).\n- [Dynamic Themes in 3 lines using GetX™](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Tutorial by [Rod Brown](https://github.com/RodBr).\n- [Complete GetX™ Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI) - Route management video by Amateur Coder.\n- [Complete GetX State Management](https://www.youtube.com/watch?v=CNpXbeI_slw) - State management video by Amateur Coder.\n- [GetX™ Other Features](https://youtu.be/ttQtlX_Q0eU) - Utils, storage, bindings and other features video by Amateur Coder.\n- [Firestore User with GetX | Todo App](https://www.youtube.com/watch?v=BiV0DcXgk58) - Video by Amateur Coder.\n- [Firebase Auth with GetX | Todo App](https://www.youtube.com/watch?v=-H-T_BSgfOE) - Video by Amateur Coder.\n- [The Flutter GetX™ Ecosystem ~ State Management](https://medium.com/flutter-community/the-flutter-getx-ecosystem-state-management-881c7235511d) - State management by [Aachman Garg](https://github.com/imaachman).\n- [The Flutter GetX™ Ecosystem ~ Dependency Injection](https://medium.com/flutter-community/the-flutter-getx-ecosystem-dependency-injection-8e763d0ec6b9) - Dependency Injection by [Aachman Garg](https://github.com/imaachman).\n- [GetX, the all-in-one Flutter package](https://www.youtube.com/watch?v=IYQgtu9TM74) - A brief tutorial covering State Management and Navigation by Thad Carnevalli.\n- [Build a To-do List App from scratch using Flutter and GetX](https://www.youtube.com/watch?v=EcnqFasHf18) - UI + State Management + Storage video by Thad Carnevalli.\n- [GetX Flutter Firebase Auth Example](https://medium.com/@jeffmcmorris/getx-flutter-firebase-auth-example-b383c1dd1de2) - Article by Jeff McMorris.\n- [Flutter State Management with GetX – Complete App](https://www.appwithflutter.com/flutter-state-management-with-getx/) - by App With Flutter.\n- [Flutter Routing with Animation using Get Package](https://www.appwithflutter.com/flutter-routing-using-get-package/) - by App With Flutter.\n- [A minimal example on dartpad](https://dartpad.dev/2b3d0d6f9d4e312c5fdbefc414c1727e?) - by [Roi Peker](https://github.com/roipeker)\n\n</div>\n"
        },
        {
          "name": "README-bn.md",
          "type": "blob",
          "size": 51.634765625,
          "content": "![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n[![pub package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n[![popularity](https://img.shields.io/pub/popularity/get?logo=dart)](https://pub.dev/packages/get/score)\n[![likes](https://img.shields.io/pub/likes/get?logo=dart)](https://pub.dev/packages/get/score)\n[![pub points](https://img.shields.io/pub/points/sentry?logo=dart)](https://pub.dev/packages/get/score)\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n[![style: effective dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n[![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n[![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n<a href=\"https://github.com/Solido/awesome-flutter\">\n<img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n</a>\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n\n- [Get সম্পর্কে](#about-get)\n- [ইনস্টল](#installing)\n- [GetX দিয়ে কাউন্টার অ্যাপ](#counter-app-with-getx)\n- [GetX এর তিনটি স্তম্ভ](#the-three-pillars)\n  - [স্টেট ব্যবস্থাপনা](#state-management)\n    - [প্রতিক্রিয়াশীল স্টেট ম্যানেজার](#reactive-state-manager)\n    - [স্টেট ব্যবস্থাপনা সম্পর্কে আরো বিস্তারিত](#more-details-about-state-management)\n  - [রুট ব্যবস্থাপনা](#route-management)\n    - [রুট ব্যবস্থাপনা সম্পর্কে আরো বিস্তারিত](#more-details-about-route-management)\n  - [ডিপেনডেন্সি ব্যবস্থাপনা](#dependency-management)\n    - [ডিপেনডেন্সি ব্যবস্থাপনা সম্পর্কে আরো বিস্তারিত](#more-details-about-dependency-management)\n- [ইউটিলিটি](#utils)\n  - [আন্তর্জাতিকীকরণ](#internationalization)\n    - [অনুবাদ](#translations)\n      - [অনুবাদের ব্যবহার](#using-translations)\n    - [লোকেল](#locales)\n      - [লোকেল পরিবর্তন করুন](#change-locale)\n      - [লোকেল পদ্ধতি](#system-locale)\n  - [থিম পরিবর্তন করুন](#change-theme)\n  - [গেট কানেক্ট](#getconnect)\n    - [ডিফল্ট কনফিগারেশন](#default-configuration)\n    - [কাস্টম কনফিগারেশন](#custom-configuration)\n  - [গেট পেজ মিডিলওয়্যার](#getpage-middleware)\n    - [অগ্রাধিকার](#priority)\n    - [পুনঃনির্দেশ](#redirect)\n    - [অন-পেজ কলড](#onpagecalled)\n    - [অন-বাইন্ডিং স্টার্ট](#onbindingsstart)\n    - [অন-পেজ বিল্ড স্টার্ট](#onpagebuildstart)\n    - [অন-পেজ বিল্ড](#onpagebuilt)\n    - [অন-পেজ ডিসপোজ](#onpagedispose)\n  - [অন্যান্য এপিআই সমূহ](#other-advanced-apis)\n    - [ঐচ্ছিক গ্লোবাল সেটিংস এবং ম্যানুয়াল কনফিগারেশন](#optional-global-settings-and-manual-configurations)\n    - [লোকাল স্টেট উইজেট](#local-state-widgets)\n      - [ভ্যালু বিল্ডার](#valuebuilder)\n      - [অব এক্স ভ্যালু](#obxvalue)\n  - [প্রয়োজনীয় পরামর্শ](#useful-tips)\n    - [গেট ভিউ](#getview)\n    - [গেট রেস্পন্সিভ ভিউ](#getresponsiveview)\n      - [কিভাবে এটি ব্যবহার করতে হয়](#how-to-use-it)\n    - [গেট উইজেট](#getwidget)\n    - [গেট এক্স সার্ভিস](#getxservice)\n- [2.0 থেকে পরিবর্তন](#breaking-changes-from-20)\n\n# Get সম্পর্কে\n\n- GetX হল ফ্লটারের জন্য একটি লাইটওয়েট এবং শক্তিশালী সমাধান। এটি দ্রুত এবং ব্যবহারিকভাবে উচ্চ-পারফরম্যান্স স্টেট ব্যবস্থাপনা, বুদ্ধিমান ডিপেনডেন্সি ইনজেকশন এবং রুট ব্যবস্থাপনাকে একত্রিত করে।\n\n- GetX এর ৩টি মৌলিক নীতি রয়েছে: **উৎপাদনশীলতা, কর্মক্ষমতা এবং সংগঠন**। এর মানে হল যে এইগুলি লাইব্রেরির সমস্ত রিসোর্স এর জন্য অগ্রাধিকার।\n\n  - **কর্মক্ষমতা:** GetX কর্মক্ষমতা এবং রিসোর্স এর ন্যূনতম ব্যবহারের উপর ফোকাস করে। এটি স্ট্রিম বা চেঞ্জনোটিফায়ার ব্যবহার করে না।\n\n  - **উৎপাদনশীলতা:** GetX একটি সহজ এবং মনোরম সিনট্যাক্স ব্যবহার করে। আপনি যা করতে চান না কেন, Getx এর সাথে সর্বদা একটি সহজ উপায় রয়েছে। এটি ডেভেলপমেন্ট এর সময় সাশ্রয় করবে এবং এটি আপনার অ্যাপ্লিকেশনটি সরবরাহ করতে পারে এমন সর্বাধিক কর্মক্ষমতা সরবরাহ করবে।\n\n  - **সংগঠন:** GetX ভিউ, প্রেজেন্টেশন লজিক, বিজনেস লজিক, ডিপেন্ডেন্সি ইনজেকশন এবং নেভিগেশনের মোট ডিকপলিং করার অনুমতি দেয়। রুটগুলির মধ্যে নেভিগেট করার জন্য আপনার কনটেক্সট (context) প্রয়োজন নেই, তাই আপনাকে এর জন্য উইজেট ট্রি (ভিজ্যুয়ালাইজেশন) এর উপর নির্ভরশীল হতে হবে না। \n\n- GetX এর একটি বিশাল ইকো সিস্টেম, একটি বৃহত সম্প্রদায়, প্রচুর সংখ্যক সহযোগী রয়েছে এবং যতক্ষণ ফ্লাটার বিদ্যমান থাকবে ততক্ষণ রক্ষণাবেক্ষণ করা হবে। গেটএক্স অ্যান্ড্রয়েড, আইওএস, ওয়েব, ম্যাক, লিনাক্স, উইন্ডোজ এবং আপনার সার্ভারে একই কোড দিয়ে চলতে সক্ষম। **[গেট সার্ভার (Get Server)](https://github.com/jonataslaw/get_server) দিয়ে আপনার ফ্রন্টএন্ডে তৈরি কোডটি পুনরায় সম্পূর্ণরূপে ব্যাকএন্ডে ব্যবহার করা সম্ভব।**\n\n**এছাড়াও সম্পূর্ণ ডেভেলপমেন্ট প্রক্রিয়া সার্ভারে এবং ফ্রন্টএন্ডে [Get CLI](https://github.com/jonataslaw/get_cli) এর মাধ্যমে স্বয়ংক্রিয়ভাবে করা যেতে পারে**।\n\n**এছাড়াও আপনার উত্পাদনশীলতা আরও বাড়াতে, আমাদের রয়েছে [VSCode extension](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets) এবং [Android Studio/Intellij extension](https://plugins.jetbrains.com/plugin/14975-getx-snippets)**।\n\n# ইনস্টল\n\nআপনার pubspec.yaml ফাইলে get যোগ করুন:\n\n```yaml\ndependencies:\n  get:\n```\n\nযে ফাইল এ ব্যবহার করবেন সেখানে ইম্পোর্ট করুন:\n\n```dart\nimport 'package:get/get.dart';\n```\n\n# GetX দিয়ে কাউন্টার অ্যাপ\n\nFlutter-এ নতুন ডিফল্ট তৈরি করা \"কাউন্টার\" প্রজেক্টে 100 টিরও বেশি লাইন রয়েছে (মন্তব্য সহ)। Get ব্যবহার করে এটি মাত্র ২৬ লাইনে করা সম্ভব (মন্তব্য সহ)।\n\n- ধাপ 1:\n  আপনার MaterialApp এর আগে \"Get\" যোগ করুন, এটিকে GetMaterialApp এ পরিণত করুন\n\n```dart\nvoid main() => runApp(GetMaterialApp(home: Home()));\n```\n\n- নোট: এটি ফ্লটারের MaterialApp পরিবর্তন করে না, GetMaterialApp একটি পরিবর্তিত MaterialApp নয়, এটি শুধুমাত্র একটি পূর্ব-কনফিগার করা উইজেট, যেটিতে একটি চাইল্ড হিসাবে ডিফল্ট MaterialApp আছে। আপনি এটি ম্যানুয়ালি কনফিগার করতে পারেন, তবে এটি অবশ্যই প্রয়োজনীয় নয়। GetMaterialApp রুট তৈরি করবে, সেগুলিকে ইনজেকশন দেবে, অনুবাদগুলি ইনজেকশন করবে, রুট নেভিগেশনের জন্য আপনার প্রয়োজনীয় সমস্ত কিছু ইনজেক্ট করবে। আপনি যদি শুধুমাত্র স্টেট ব্যবস্থাপনা বা ডিপেন্ডেন্সি ব্যবস্থাপনার জন্য Get ব্যবহার করেন, তাহলে GetMaterialApp ব্যবহার করার প্রয়োজন নেই। GetMaterialApp রুট, স্ন্যাকবার, আন্তর্জাতিকীকরণ, বটমশিট, ডায়ালগ এবং রুট সম্পর্কিত উচ্চ-স্তরের এপিএস এবং প্রসঙ্গ অনুপস্থিতির জন্য প্রয়োজনীয়।\n- নোট-²: আপনি যদি রুট ম্যানেজমেন্ট ব্যবহার করেন তবেই এই ধাপটি প্রয়োজনীয় (`Get.to()`, `Get.back()` এবং অন্যান্য)। আপনি যদি এটি ব্যবহার না করেন তবে ধাপ-1 করার দরকার নেই\n\n- ধাপ 2:\n  আপনার বিজনেস লজিক ক্লাস তৈরি করুন এবং এর ভিতরে সমস্ত ভেরিয়েবল, পদ্ধতি এবং কন্ট্রোলার রাখুন।\n  আপনি একটি সাধারণ \".obs\" ব্যবহার করে যেকোনো পরিবর্তনশীলকে পর্যবেক্ষণযোগ্য করতে পারেন।\n\n```dart\nclass Controller extends GetxController{\n  var count = 0.obs;\n  increment() => count++;\n}\n```\n\n- ধাপ 3:\n  আপনার ভিউ তৈরি করুন, স্টেটলেস উইজেট ব্যবহার করুন এবং কিছু র‌্যাম সেভ করুন, Get এর সাথে আপনাকে হয়তো আর StatefulWidget ব্যবহার করার প্রয়োজন হবে না।\n\n```dart\nclass Home extends StatelessWidget {\n\n  @override\n  Widget build(context) {\n\n    // Instantiate your class using Get.put() to make it available for all \"child\" routes there.\n    final Controller c = Get.put(Controller());\n\n    return Scaffold(\n      // Use Obx(()=> to update Text() whenever count is changed.\n      appBar: AppBar(title: Obx(() => Text(\"Clicks: ${c.count}\"))),\n\n      // Replace the 8 lines Navigator.push by a simple Get.to(). You don't need context\n      body: Center(child: ElevatedButton(\n              child: Text(\"Go to Other\"), onPressed: () => Get.to(Other()))),\n      floatingActionButton:\n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n  }\n}\n\nclass Other extends StatelessWidget {\n  // You can ask Get to find a Controller that is being used by another page and redirect you to it.\n  final Controller c = Get.find();\n\n  @override\n  Widget build(context){\n     // Access the updated count variable\n     return Scaffold(body: Center(child: Text(\"${c.count}\")));\n  }\n}\n```\n\n# GetX এর তিনটি স্তম্ভ\n\n## স্টেট ব্যবস্থাপনা\n\nGet দুই ভিন্ন স্টেট ম্যানেজার আছে: সাধারণ স্টেট ম্যানেজার (আমরা একে GetBuilder বলব) and প্রতিক্রিয়াশীল স্টেট ম্যানেজার (GetX/Obx)\n\n### প্রতিক্রিয়াশীল স্টেট ম্যানেজার\n\nপ্রতিক্রিয়াশীল প্রোগ্রামিং অনেক লোককে উদাসীন করতে পারে কারণ এটি জটিল। GetX প্রতিক্রিয়াশীল প্রোগ্রামিংকে বেশ সহজে পরিণত করে:\n\n- আপনাকে StreamControllers তৈরি করতে হবে না।\n- আপনাকে প্রতিটি ভেরিয়েবলের জন্য একটি StreamBuilder তৈরি করতে হবে না।\n- আপনাকে প্রতিটি স্টেটের জন্য একটি ক্লাস তৈরি করতে হবে না।\n- আপনাকে initial value এর জন্য get তৈরি করতে হবে না।\n- আপনাকে কোড জেনারেটর ব্যবহার করতে হবে না।\n\nGet এর সাথে প্রতিক্রিয়াশীল প্রোগ্রামিং setState ব্যবহার করার মতোই সহজ।\n\nকল্পনা করুন যে আপনার একটি নাম ভ্যারিয়েবল আছে এবং আপনি চান যে প্রতিবার আপনি এটি পরিবর্তন করবেন, এটি ব্যবহার করে এমন সমস্ত উইজেট স্বয়ংক্রিয়ভাবে পরিবর্তন করতে পারবেন।\n\nমনে করুন এটি আপনার নাম ভ্যারিয়েবল:\n\n```dart\nvar name = 'Ashiqur Rahman Alif';\n```\n\nএটিকে observable করতে, আপনাকে এটির শেষে \".obs\" যোগ করতে হবে:\n\n```dart\nvar name = 'Ashiqur Rahman Alif'.obs;\n```\n\nএবং UI-তে যখন আপনি সেই নামটি দেখাতে চান এবং যখনই মান পরিবর্তন হয় তখন স্ক্রীনটি আপডেট করতে চান, কেবল এটি করুন:\n\n```dart\nObx(() => Text(\"${controller.name}\"));\n```\n\nএখানেই শেষ। এটা এমনই সহজ।\n\n### স্টেট ব্যবস্থাপনা সম্পর্কে আরো বিস্তারিত\n\n**স্টেট পরিচালনার আরও ব্যাখ্যা দেখুন [এখানে](./documentation/en_US/state_management.md)। সেখানে আপনি আরও উদাহরণ দেখতে পাবেন এবং সাধারণ স্টেট ব্যবস্থাপক এবং প্রতিক্রিয়াশীল স্টেট ব্যবস্থাপকের মধ্যে পার্থক্যও দেখতে পাবেন**\n\nGetX পাওয়ার সম্পর্কে ভালো ধারণা পাবেন।\n\n## রুট ব্যবস্থাপনা\n\nআপনি যদি context ছাড়াই রুট/স্ন্যাকবার/ডায়ালগ/বটমশীট ব্যবহার করতে চান, GetX আপনার জন্য, এটি দেখুন:\n\nআপনার MaterialApp এর আগে \"Get\" যোগ করুন, এটিকে GetMaterialApp এ পরিণত করুন\n\n```dart\nGetMaterialApp( // Before: MaterialApp(\n  home: MyHome(),\n)\n```\n\nএকটি নতুন স্ক্রিনে নেভিগেট করুন:\n\n```dart\n\nGet.to(NextScreen());\n```\n\nনাম সহ নতুন স্ক্রিনে নেভিগেট করুন। নামযুক্ত রুট সম্পর্কিত আরও বিস্তারিত বিবরণ দেখুন [এখানে](./documentation/en_US/route_management.md#navigation-with-named-routes)\n\n```dart\n\nGet.toNamed('/details');\n```\n\nস্ন্যাকবার, ডায়ালগ, বটমশীট, বা যেকোনো কিছু বন্ধ করতে আপনি Navigator.pop(context) এর পরিবর্তে ব্যবহার করুন:\n\n```dart\nGet.back();\n```\n\nপরবর্তী স্ক্রিনে যাওয়ার পর আগের স্ক্রিনে ফিরে যাওয়া বন্ধ করুন (স্প্ল্যাশস্ক্রিন, লগইন স্ক্রিন ইত্যাদিতে ব্যবহারের জন্য)\n\n```dart\nGet.off(NextScreen());\n```\n\nপরবর্তী স্ক্রিনে যেতে এবং আগের সমস্ত রুট বাতিল করতে (শপিং কার্ট, পোল  ইত্যাদিতে ব্যবহারের জন্য)\n\n```dart\nGet.offAll(NextScreen());\n```\n\nলক্ষ্য করেছেন যে এই জিনিসগুলির কোনটি করার জন্য আপনাকে context ব্যবহার করতে হবে না? এটি Get রুট ম্যানেজমেন্ট ব্যবহার করার সবচেয়ে বড় সুবিধাগুলির মধ্যে একটি। এটির সাহায্যে, আপনি চিন্তা ছাড়াই আপনার controller class এর মধ্যে থেকে এই সমস্ত পদ্ধতিগুলি চালাতে পারেন।\n\n### রুট ব্যবস্থাপনা সম্পর্কে আরো বিস্তারিত\n\n**রুট ব্যবস্থাপনা সম্পর্কে আরো বিস্তারিত ডকুমেন্টেশন আছে [এখানে](./documentation/en_US/route_management.md)**\n\n## ডিপেনডেন্সি ব্যবস্থাপনা\n\nGet এর একটি সহজ এবং শক্তিশালী ডিপেনডেন্সি পরিচালক রয়েছে যা আপনাকে কোনও Provider context বা inheritedWidget ছাড়াই, মাত্র 1 লাইনের কোডের মাধ্যমে আপনার ব্লক বা কন্ট্রোলারের মতো একই class রিট্রিভ করতে দেয়:\n\n```dart\nController controller = Get.put(Controller()); // Rather Controller controller = Controller();\n```\n\n- দ্রষ্টব্য: আপনি যদি Get's State Manager ব্যবহার করেন, তাহলে bindings API-এ আরও মনোযোগ দিন, যা আপনার কন্ট্রোলারের সাথে আপনার ভিউকে সংযোগ করা সহজ করে তুলবে।\n\nআপনি যে ক্লাসটি ব্যবহার করছেন তার মধ্যে আপনার ক্লাসকে ইনস্ট্যান্টিয়েট করার পরিবর্তে Get ইনস্ট্যান্সের মধ্যে ইনস্ট্যান্টিয়েট করুন, যা এটিকে আপনার অ্যাপ জুড়ে উপলব্ধ করবে।\nতখন আপনি স্বাভাবিকভাবে আপনার controller (বা class Bloc) ব্যবহার করতে পারবেন।\n\n**টিপ:** Get ডিপেন্ডেন্সি ম্যানেজমেন্ট প্যাকেজের অন্যান্য অংশ থেকে ডিকপল করা হয়েছে, উদাহরণ স্বরূপ, আপনার অ্যাপ ইতিমধ্যেই একটি স্টেট ম্যানেজার ব্যবহার করে (যেকোনোটি হতে পারে, এটা কোন ব্যাপার না), তবে আপনার পুনরায় সব লেখার দরকার নেই, আপনি কোনও সমস্যা ছাড়াই এই ডিপেন্ডেন্সি ইনজেকশনটি ব্যবহার করতে পারেন।\n\n```dart\ncontroller.fetchApi();\n```\n\nকল্পনা করুন যে আপনি অসংখ্য রুটে নেভিগেট করেছেন, এবং আপনার controller এর পিছনে ফেলে আসা ডেটার প্রয়োজন, আপনার প্রোভাইডার বা Get_it এর সাথে মিলিত একটি স্টেট ম্যানেজারের প্রয়োজন হবে, তাই না? Get এর সাথে তা প্রয়োজন নেই। আপনাকে শুধু আপনার controller এর জন্য \"find\" জিজ্ঞাসা করতে হবে, আপনার কোনো অতিরিক্ত ডিপেন্ডেন্সি প্রয়োজন নেই:\n\n```dart\nController controller = Get.find();\n//Yes, it looks like Magic, Get will find your controller, and will deliver it to you. You can have 1 million controllers instantiated, Get will always give you the right controller.\n```\n\nএবং তারপরে আপনি আপনার নিয়ামক ডেটা পুনরুদ্ধার করতে সক্ষম হবেন যা সেখানে ফিরে প্রাপ্ত হয়েছিল:\n\n```dart\nText(controller.textFromApi);\n```\n\n### ডিপেনডেন্সি ব্যবস্থাপনা সম্পর্কে আরো বিস্তারিত\n\n**ডিপেনডেন্সি ব্যবস্থাপনা সম্পর্কে আরো বিস্তারিত ব্যাখ্যা দেখুন [এখানে](./documentation/en_US/dependency_management.md)**\n\n# ইউটিলিটি\n\n## আন্তর্জাতিকীকরণ\n\n### অনুবাদ\n\nঅনুবাদগুলি একটি সাধারণ কী-মানের অভিধান মানচিত্র হিসাবে রাখা হয়।\nTo add custom translations, create a class and extend `Translations`.\nকাস্টম অনুবাদ যোগ করতে, একটি class তৈরি করুন এবং `Translations` এ extends করুন।\n\n```dart\nimport 'package:get/get.dart';\n\nclass Messages extends Translations {\n  @override\n  Map<String, Map<String, String>> get keys => {\n        'en_US': {\n          'hello': 'Hello World',\n        },\n        'de_DE': {\n          'hello': 'Hallo Welt',\n        }\n      };\n}\n```\n\n#### অনুবাদের ব্যবহার\n\nশুধুমাত্র নির্দিষ্ট key তে `.tr` যোগ করুন এবং এটি অনুবাদ করা হবে, `Get.locale` এবং `Get.fallbackLocale` এর বর্তমান মান ব্যবহার করে।\n\n```dart\nText('title'.tr);\n```\n\n#### একবচন এবং বহুবচন সহ অনুবাদ ব্যবহার\n\n```dart\nvar products = [];\nText('singularKey'.trPlural('pluralKey', products.length, Args));\n```\n\n#### প্যারামিটার সহ অনুবাদ ব্যবহার\n\n```dart\nimport 'package:get/get.dart';\n\n\nMap<String, Map<String, String>> get keys => {\n    'en_US': {\n        'logged_in': 'logged in as @name with email @email',\n    },\n    'es_ES': {\n       'logged_in': 'iniciado sesión como @name con e-mail @email',\n    }\n};\n\nText('logged_in'.trParams({\n  'name': 'Jhon',\n  'email': 'jhon@example.com'\n  }));\n```\n\n### লোকেল\n\nলোকেল এবং অনুবাদ সংজ্ঞায়িত করতে `GetMaterialApp`-এ প্যারামিটার পাস করুন।\n\n```dart\nreturn GetMaterialApp(\n    translations: Messages(), // your translations\n    locale: Locale('en', 'US'), // translations will be displayed in that locale\n    fallbackLocale: Locale('en', 'UK'), // specify the fallback locale in case an invalid locale is selected.\n);\n```\n\n#### লোকেল পরিবর্তন করুন\n\nলোকেল আপডেট করতে `Get.updateLocale(locale)` কল করুন। অনুবাদগুলি তখন স্বয়ংক্রিয়ভাবে নতুন লোকেল ব্যবহার করে।\n\n```dart\nvar locale = Locale('en', 'US');\nGet.updateLocale(locale);\n```\n\n#### লোকেল পদ্ধতি\n\nসিস্টেম লোকেল পড়তে, আপনি `Get.deviceLocale` ব্যবহার করতে পারেন।\n\n```dart\nreturn GetMaterialApp(\n    locale: Get.deviceLocale,\n);\n```\n\n## থিম পরিবর্তন করুন\n\nPlease do not use any higher level widget than `GetMaterialApp` in order to update it. This can trigger duplicate keys. A lot of people are used to the prehistoric approach of creating a \"ThemeProvider\" widget just to change the theme of your app, and this is definitely NOT necessary with **GetX™**.\n\nYou can create your custom theme and simply add it within `Get.changeTheme` without any boilerplate for that:\n\n```dart\nGet.changeTheme(ThemeData.light());\n```\n\nIf you want to create something like a button that changes the Theme in `onTap`, you can combine two **GetX™** APIs for that:\n\n- The api that checks if the dark `Theme` is being used.\n- And the `Theme` Change API, you can just put this within an `onPressed`:\n\n```dart\nGet.changeTheme(Get.isDarkMode? ThemeData.light(): ThemeData.dark());\n```\n\nWhen `.darkmode` is activated, it will switch to the _light theme_, and when the _light theme_ becomes active, it will change to _dark theme_.\n\n## গেট কানেক্ট (GetConnect)\n\nGetConnect is an easy way to communicate from your back to your front with http or websockets\n\n### ডিফল্ট কনফিগারেশন\n\nYou can simply extend GetConnect and use the GET/POST/PUT/DELETE/SOCKET methods to communicate with your Rest API or websockets.\n\n```dart\nclass UserProvider extends GetConnect {\n  // Get request\n  Future<Response> getUser(int id) => get('http://youapi/users/$id');\n  // Post request\n  Future<Response> postUser(Map data) => post('http://youapi/users', body: data);\n  // Post request with File\n  Future<Response<CasesModel>> postCases(List<int> image) {\n    final form = FormData({\n      'file': MultipartFile(image, filename: 'avatar.png'),\n      'otherFile': MultipartFile(image, filename: 'cover.png'),\n    });\n    return post('http://youapi/users/upload', form);\n  }\n\n  GetSocket userMessages() {\n    return socket('https://yourapi/users/socket');\n  }\n}\n```\n\n### কাস্টম কনফিগারেশন\n\nGetConnect is highly customizable You can define base Url, as answer modifiers, as Requests modifiers, define an authenticator, and even the number of attempts in which it will try to authenticate itself, in addition to giving the possibility to define a standard decoder that will transform all your requests into your Models without any additional configuration.\n\n```dart\nclass HomeProvider extends GetConnect {\n  @override\n  void onInit() {\n    // All request will pass to jsonEncode so CasesModel.fromJson()\n    httpClient.defaultDecoder = CasesModel.fromJson;\n    httpClient.baseUrl = 'https://api.covid19api.com';\n    // baseUrl = 'https://api.covid19api.com'; // It define baseUrl to\n    // Http and websockets if used with no [httpClient] instance\n\n    // It's will attach 'apikey' property on header from all requests\n    httpClient.addRequestModifier((request) {\n      request.headers['apikey'] = '12345678';\n      return request;\n    });\n\n    // Even if the server sends data from the country \"Brazil\",\n    // it will never be displayed to users, because you remove\n    // that data from the response, even before the response is delivered\n    httpClient.addResponseModifier<CasesModel>((request, response) {\n      CasesModel model = response.body;\n      if (model.countries.contains('Brazil')) {\n        model.countries.remove('Brazilll');\n      }\n    });\n\n    httpClient.addAuthenticator((request) async {\n      final response = await get(\"http://yourapi/token\");\n      final token = response.body['token'];\n      // Set the header\n      request.headers['Authorization'] = \"$token\";\n      return request;\n    });\n\n    //Autenticator will be called 3 times if HttpStatus is\n    //HttpStatus.unauthorized\n    httpClient.maxAuthRetries = 3;\n  }\n\n  @override\n  Future<Response<CasesModel>> getCases(String path) => get(path);\n}\n```\n\n## গেট পেজ মিডিলওয়্যার\n\nThe GetPage has now new property that takes a list of GetMiddleWare and run them in the specific order.\n\n**Note**: When GetPage has a Middlewares, all the children of this page will have the same middlewares automatically.\n\n### অগ্রাধিকার (Priority)\n\nThe Order of the Middlewares to run can be set by the priority in the GetMiddleware.\n\n```dart\nfinal middlewares = [\n  GetMiddleware(priority: 2),\n  GetMiddleware(priority: 5),\n  GetMiddleware(priority: 4),\n  GetMiddleware(priority: -8),\n];\n```\n\nthose middlewares will be run in this order **-8 => 2 => 4 => 5**\n\n### পুনঃনির্দেশ (Redirect)\n\nThis function will be called when the page of the called route is being searched for. It takes RouteSettings as a result to redirect to. Or give it null and there will be no redirecting.\n\n```dart\nRouteSettings redirect(String route) {\n  final authService = Get.find<AuthService>();\n  return authService.authed.value ? null : RouteSettings(name: '/login')\n}\n```\n\n### অন-পেজ কলড (onPageCalled)\n\nThis function will be called when this Page is called before anything created\nyou can use it to change something about the page or give it new page\n\n```dart\nGetPage onPageCalled(GetPage page) {\n  final authService = Get.find<AuthService>();\n  return page.copyWith(title: 'Welcome ${authService.UserName}');\n}\n```\n\n### অন-বাইন্ডিং স্টার্ট (OnBindingsStart)\n\nThis function will be called right before the Bindings are initialize.\nHere you can change Bindings for this page.\n\n```dart\nList<Bindings> onBindingsStart(List<Bindings> bindings) {\n  final authService = Get.find<AuthService>();\n  if (authService.isAdmin) {\n    bindings.add(AdminBinding());\n  }\n  return bindings;\n}\n```\n\n### অন-পেজ বিল্ড স্টার্ট (OnPageBuildStart)\n\nThis function will be called right after the Bindings are initialize.\nHere you can do something after that you created the bindings and before creating the page widget.\n\n```dart\nGetPageBuilder onPageBuildStart(GetPageBuilder page) {\n  print('bindings are ready');\n  return page;\n}\n```\n\n### অন-পেজ বিল্ড (OnPageBuilt)\n\nThis function will be called right after the GetPage.page function is called and will give you the result of the function. and take the widget that will be showed.\n\n### অন-পেজ ডিসপোজ (OnPageDispose)\n\nThis function will be called right after disposing all the related objects (Controllers, views, ...) of the page.\n\n## অন্যান্য এপিআই সমূহ\n\n```dart\n// give the current args from currentScreen\nGet.arguments\n\n// give name of previous route\nGet.previousRoute\n\n// give the raw route to access for example, rawRoute.isFirst()\nGet.rawRoute\n\n// give access to Routing API from GetObserver\nGet.routing\n\n// check if snackbar is open\nGet.isSnackbarOpen\n\n// check if dialog is open\nGet.isDialogOpen\n\n// check if bottomsheet is open\nGet.isBottomSheetOpen\n\n// remove one route.\nGet.removeRoute()\n\n// back repeatedly until the predicate returns true.\nGet.until()\n\n// go to next route and remove all the previous routes until the predicate returns true.\nGet.offUntil()\n\n// go to next named route and remove all the previous routes until the predicate returns true.\nGet.offNamedUntil()\n\n//Check in what platform the app is running\nGetPlatform.isAndroid\nGetPlatform.isIOS\nGetPlatform.isMacOS\nGetPlatform.isWindows\nGetPlatform.isLinux\nGetPlatform.isFuchsia\n\n//Check the device type\nGetPlatform.isMobile\nGetPlatform.isDesktop\n//All platforms are supported independently in web!\n//You can tell if you are running inside a browser\n//on Windows, iOS, OSX, Android, etc.\nGetPlatform.isWeb\n\n\n// Equivalent to : MediaQuery.of(context).size.height,\n// but immutable.\nGet.height\nGet.width\n\n// Gives the current context of the Navigator.\nGet.context\n\n// Gives the context of the snackbar/dialog/bottomsheet in the foreground, anywhere in your code.\nGet.contextOverlay\n\n// Note: the following methods are extensions on context. Since you\n// have access to context in any place of your UI, you can use it anywhere in the UI code\n\n// If you need a changeable height/width (like Desktop or browser windows that can be scaled) you will need to use context.\ncontext.width\ncontext.height\n\n// Gives you the power to define half the screen, a third of it and so on.\n// Useful for responsive applications.\n// param dividedBy (double) optional - default: 1\n// param reducedBy (double) optional - default: 0\ncontext.heightTransformer()\ncontext.widthTransformer()\n\n/// Similar to MediaQuery.of(context).size\ncontext.mediaQuerySize()\n\n/// Similar to MediaQuery.of(context).padding\ncontext.mediaQueryPadding()\n\n/// Similar to MediaQuery.of(context).viewPadding\ncontext.mediaQueryViewPadding()\n\n/// Similar to MediaQuery.of(context).viewInsets;\ncontext.mediaQueryViewInsets()\n\n/// Similar to MediaQuery.of(context).orientation;\ncontext.orientation()\n\n/// Check if device is on landscape mode\ncontext.isLandscape()\n\n/// Check if device is on portrait mode\ncontext.isPortrait()\n\n/// Similar to MediaQuery.of(context).devicePixelRatio;\ncontext.devicePixelRatio()\n\n/// Similar to MediaQuery.of(context).textScaleFactor;\ncontext.textScaleFactor()\n\n/// Get the shortestSide from screen\ncontext.mediaQueryShortestSide()\n\n/// True if width be larger than 800\ncontext.showNavbar()\n\n/// True if the shortestSide is smaller than 600p\ncontext.isPhone()\n\n/// True if the shortestSide is largest than 600p\ncontext.isSmallTablet()\n\n/// True if the shortestSide is largest than 720p\ncontext.isLargeTablet()\n\n/// True if the current device is Tablet\ncontext.isTablet()\n\n/// Returns a value<T> according to the screen size\n/// can give value for:\n/// watch: if the shortestSide is smaller than 300\n/// mobile: if the shortestSide is smaller than 600\n/// tablet: if the shortestSide is smaller than 1200\n/// desktop: if width is largest than 1200\ncontext.responsiveValue<T>()\n```\n\n### ঐচ্ছিক গ্লোবাল সেটিংস এবং ম্যানুয়াল কনফিগারেশন\n\nGetMaterialApp configures everything for you, but if you want to configure Get manually.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver()],\n);\n```\n\nYou will also be able to use your own Middleware within `GetObserver`, this will not influence anything.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [\n    GetObserver(MiddleWare.observer) // Here\n  ],\n);\n```\n\nYou can create _Global Settings_ for `Get`. Just add `Get.config` to your code before pushing any route.\nOr do it directly in your `GetMaterialApp`\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  defaultTransition: Transition.fade,\n  opaqueRoute: Get.isOpaqueRouteDefault,\n  popGesture: Get.isPopGestureEnable,\n  transitionDuration: Get.defaultDurationTransition,\n  defaultGlobalState: Get.defaultGlobalState,\n);\n\nGet.config(\n  enableLog = true,\n  defaultPopGesture = true,\n  defaultTransition = Transitions.cupertino\n)\n```\n\nYou can optionally redirect all the logging messages from `Get`.\nIf you want to use your own, favourite logging package,\nand want to capture the logs there:\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  logWriterCallback: localLogWriter,\n);\n\nvoid localLogWriter(String text, {bool isError = false}) {\n  // pass the message to your favourite logging package here\n  // please note that even if enableLog: false log messages will be pushed in this callback\n  // you get check the flag if you want through GetConfig.isLogEnable\n}\n\n```\n\n### লোকাল স্টেট উইজেট\n\nThese Widgets allows you to manage a single value, and keep the state ephemeral and locally.\nWe have flavours for Reactive and Simple.\nFor instance, you might use them to toggle obscureText in a `TextField`, maybe create a custom\nExpandable Panel, or maybe modify the current index in `BottomNavigationBar` while changing the content\nof the body in a `Scaffold`.\n\n#### ভ্যালু বিল্ডার (ValueBuilder)\n\nA simplification of `StatefulWidget` that works with a `.setState` callback that takes the updated value.\n\n```dart\nValueBuilder<bool>(\n  initialValue: false,\n  builder: (value, updateFn) => Switch(\n    value: value,\n    onChanged: updateFn, // same signature! you could use ( newValue ) => updateFn( newValue )\n  ),\n  // if you need to call something outside the builder method.\n  onUpdate: (value) => print(\"Value updated: $value\"),\n  onDispose: () => print(\"Widget unmounted\"),\n),\n```\n\n#### অবএক্সভ্যালু (ObxValue)\n\nSimilar to [`ValueBuilder`](#valuebuilder), but this is the Reactive version, you pass a Rx instance (remember the magical .obs?) and\nupdates automatically... isn't it awesome?\n\n```dart\nObxValue((data) => Switch(\n        value: data.value,\n        onChanged: data, // Rx has a _callable_ function! You could use (flag) => data.value = flag,\n    ),\n    false.obs,\n),\n```\n\n## প্রয়োজনীয় পরামর্শ\n\n`.obs`ervables (also known as _Rx_ Types) have a wide variety of internal methods and operators.\n\n> Is very common to _believe_ that a property with `.obs` **IS** the actual value... but make no mistake!\n> We avoid the Type declaration of the variable, because Dart's compiler is smart enough, and the code\n> looks cleaner, but:\n\n```dart\nvar message = 'Hello world'.obs;\nprint( 'Message \"$message\" has Type ${message.runtimeType}');\n```\n\nEven if `message` _prints_ the actual String value, the Type is **RxString**!\n\nSo, you can't do `message.substring( 0, 4 )`.\nYou have to access the real `value` inside the _observable_:\nThe most \"used way\" is `.value`, but, did you know that you can also use...\n\n```dart\nfinal name = 'GetX'.obs;\n// only \"updates\" the stream, if the value is different from the current one.\nname.value = 'Hey';\n\n// All Rx properties are \"callable\" and returns the new value.\n// but this approach does not accepts `null`, the UI will not rebuild.\nname('Hello');\n\n// is like a getter, prints 'Hello'.\nname() ;\n\n/// numbers:\n\nfinal count = 0.obs;\n\n// You can use all non mutable operations from num primitives!\ncount + 1;\n\n// Watch out! this is only valid if `count` is not final, but var\ncount += 1;\n\n// You can also compare against values:\ncount > 2;\n\n/// booleans:\n\nfinal flag = false.obs;\n\n// switches the value between true/false\nflag.toggle();\n\n\n/// all types:\n\n// Sets the `value` to null.\nflag.nil();\n\n// All toString(), toJson() operations are passed down to the `value`\nprint( count ); // calls `toString()` inside  for RxInt\n\nfinal abc = [0,1,2].obs;\n// Converts the value to a json Array, prints RxList\n// Json is supported by all Rx types!\nprint('json: ${jsonEncode(abc)}, type: ${abc.runtimeType}');\n\n// RxMap, RxList and RxSet are special Rx types, that extends their native types.\n// but you can work with a List as a regular list, although is reactive!\nabc.add(12); // pushes 12 to the list, and UPDATES the stream.\nabc[3]; // like Lists, reads the index 3.\n\n\n// equality works with the Rx and the value, but hashCode is always taken from the value\nfinal number = 12.obs;\nprint( number == 12 ); // prints > true\n\n/// Custom Rx Models:\n\n// toJson(), toString() are deferred to the child, so you can implement override on them, and print() the observable directly.\n\nclass User {\n    String name, last;\n    int age;\n    User({this.name, this.last, this.age});\n\n    @override\n    String toString() => '$name $last, $age years old';\n}\n\nfinal user = User(name: 'John', last: 'Doe', age: 33).obs;\n\n// `user` is \"reactive\", but the properties inside ARE NOT!\n// So, if we change some variable inside of it...\nuser.value.name = 'Roi';\n// The widget will not rebuild!,\n// `Rx` don't have any clue when you change something inside user.\n// So, for custom classes, we need to manually \"notify\" the change.\nuser.refresh();\n\n// or we can use the `update()` method!\nuser.update((value){\n  value.name='Roi';\n});\n\nprint( user );\n```\n## StateMixin\n\nAnother way to handle your `UI` state is use the `StateMixin<T>` .\nTo implement it, use the `with` to add the `StateMixin<T>`\nto your controller which allows a T model.\n\n``` dart\nclass Controller extends GetController with StateMixin<User>{}\n```\n\nThe `change()` method change the State whenever we want.\nJust pass the data and the status in this way:\n\n```dart\nchange(data, status: RxStatus.success());\n```\n\nRxStatus allow these status:\n\n``` dart\nRxStatus.loading();\nRxStatus.success();\nRxStatus.empty();\nRxStatus.error('message');\n```\n\nTo represent it in the UI, use:\n\n```dart\nclass OtherClass extends GetView<Controller> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n\n      body: controller.obx(\n        (state)=>Text(state.name),\n        \n        // here you can put your custom loading indicator, but\n        // by default would be Center(child:CircularProgressIndicator())\n        onLoading: CustomLoadingIndicator(),\n        onEmpty: Text('No data found'),\n\n        // here also you can set your own error widget, but by\n        // default will be an Center(child:Text(error))\n        onError: (error)=>Text(error),\n      ),\n    );\n}\n```\n\n#### গেট ভিউ (GetView)\n\nI love this Widget, is so simple, yet, so useful!\n\nIs a `const Stateless` Widget that has a getter `controller` for a registered `Controller`, that's all.\n\n```dart\n class AwesomeController extends GetController {\n   final String title = 'My Awesome View';\n }\n\n  // ALWAYS remember to pass the `Type` you used to register your controller!\n class AwesomeView extends GetView<AwesomeController> {\n   @override\n   Widget build(BuildContext context) {\n     return Container(\n       padding: EdgeInsets.all(20),\n       child: Text(controller.title), // just call `controller.something`\n     );\n   }\n }\n```\n\n#### গেট রেস্পন্সিভ ভিউ (GetResponsiveView)\n\nExtend this widget to build responsive view.\nthis widget contains the `screen` property that have all\ninformation about the screen size and type.\n\n##### কিভাবে এটি ব্যবহার করতে হয়\n\nYou have two options to build it.\n\n- with `builder` method you return the widget to build.\n- with methods `desktop`, `tablet`,`phone`, `watch`. the specific\n  method will be built when the screen type matches the method\n  when the screen is [ScreenType.Tablet] the `tablet` method\n  will be exuded and so on.\n  **Note:** If you use this method please set the property `alwaysUseBuilder` to `false`\n\nWith `settings` property you can set the width limit for the screen types.\n\n![example](https://github.com/SchabanBo/get_page_example/blob/master/docs/Example.gif?raw=true)\nCode to this screen\n[code](https://github.com/SchabanBo/get_page_example/blob/master/lib/pages/responsive_example/responsive_view.dart)\n\n#### গেট উইজেট (GetWidget)\n\nMost people have no idea about this Widget, or totally confuse the usage of it.\nThe use case is very rare, but very specific: It `caches` a Controller.\nBecause of the _cache_, can't be a `const Stateless`.\n\n> So, when do you need to \"cache\" a Controller?\n\nIf you use, another \"not so common\" feature of **GetX**: `Get.create()`.\n\n`Get.create(()=>Controller())` will generate a new `Controller` each time you call\n`Get.find<Controller>()`,\n\nThat's where `GetWidget` shines... as you can use it, for example,\nto keep a list of Todo items. So, if the widget gets \"rebuilt\", it will keep the same controller instance.\n\n#### গেট এক্স সার্ভিস (GetxService)\n\nThis class is like a `GetxController`, it shares the same lifecycle ( `onInit()`, `onReady()`, `onClose()`).\nBut has no \"logic\" inside of it. It just notifies **GetX** Dependency Injection system, that this subclass\n**can not** be removed from memory.\n\nSo is super useful to keep your \"Services\" always reachable and active with `Get.find()`. Like:\n`ApiService`, `StorageService`, `CacheService`.\n\n```dart\nFuture<void> main() async {\n  await initServices(); /// AWAIT SERVICES INITIALIZATION.\n  runApp(SomeApp());\n}\n\n/// Is a smart move to make your Services intiialize before you run the Flutter app.\n/// as you can control the execution flow (maybe you need to load some Theme configuration,\n/// apiKey, language defined by the User... so load SettingService before running ApiService.\n/// so GetMaterialApp() doesnt have to rebuild, and takes the values directly.\nvoid initServices() async {\n  print('starting services ...');\n  /// Here is where you put get_storage, hive, shared_pref initialization.\n  /// or moor connection, or whatever that's async.\n  await Get.putAsync(() => DbService().init());\n  await Get.putAsync(SettingsService()).init();\n  print('All services started...');\n}\n\nclass DbService extends GetxService {\n  Future<DbService> init() async {\n    print('$runtimeType delays 2 sec');\n    await 2.delay();\n    print('$runtimeType ready!');\n    return this;\n  }\n}\n\nclass SettingsService extends GetxService {\n  void init() async {\n    print('$runtimeType delays 1 sec');\n    await 1.delay();\n    print('$runtimeType ready!');\n  }\n}\n\n```\n\nThe only way to actually delete a `GetxService`, is with `Get.reset()` which is like a\n\"Hot Reboot\" of your app. So remember, if you need absolute persistence of a class instance during the\nlifetime of your app, use `GetxService`.\n\n\n### পরীক্ষা (Tests)\n\nYou can test your controllers like any other class, including their lifecycles:\n\n```dart\nclass Controller extends GetxController {\n  @override\n  void onInit() {\n    super.onInit();\n    //Change value to name2\n    name.value = 'name2';\n  }\n\n  @override\n  void onClose() {\n    name.value = '';\n    super.onClose();\n  }\n\n  final name = 'name1'.obs;\n\n  void changeName() => name.value = 'name3';\n}\n\nvoid main() {\n  test('''\nTest the state of the reactive variable \"name\" across all of its lifecycles''',\n      () {\n    /// You can test the controller without the lifecycle,\n    /// but it's not recommended unless you're not using\n    ///  GetX dependency injection\n    final controller = Controller();\n    expect(controller.name.value, 'name1');\n\n    /// If you are using it, you can test everything,\n    /// including the state of the application after each lifecycle.\n    Get.put(controller); // onInit was called\n    expect(controller.name.value, 'name2');\n\n    /// Test your functions\n    controller.changeName();\n    expect(controller.name.value, 'name3');\n\n    /// onClose was called\n    Get.delete<Controller>();\n\n    expect(controller.name.value, '');\n  });\n}\n```\n\n#### পরামর্শ\n\n##### Mockito or mocktail\nIf you need to mock your GetxController/GetxService, you should extend GetxController, and mixin it with Mock, that way\n\n```dart\nclass NotificationServiceMock extends GetxService with Mock implements NotificationService {}\n```\n\n##### Using Get.reset()\nIf you are testing widgets, or test groups, use Get.reset at the end of your test or in tearDown to reset all settings from your previous test.\n\n##### Get.testMode \nif you are using your navigation in your controllers, use `Get.testMode = true` at the beginning of your main.\n\n\n# 2.0 থেকে পরিবর্তন\n\n1- Rx এর প্রকারভেদ :\n\n| পূর্বে  | এখন      |\n| ------- | ---------- |\n| StringX | `RxString` |\n| IntX    | `RxInt`    |\n| MapX    | `RxMap`    |\n| ListX   | `RxList`   |\n| NumX    | `RxNum`    |\n| DoubleX | `RxDouble` |\n\nRxController এবং GetBuilder এখন একত্রিত, আপনি কোন নিয়ামক ব্যবহার করতে চান তা আর মুখস্ত করার দরকার নেই, শুধু GetxController ব্যবহার করুন, এটি সাধারণ স্টেট ব্যবস্থাপনা এবং প্রতিক্রিয়াশীল স্টেট ব্যবস্থাপনা এর জন্যও কাজ করবে।\n\n2- নেমড রুটস (NamedRoutes)\n\nআগে:\n\n```dart\nGetMaterialApp(\n  namedRoutes: {\n    '/': GetRoute(page: Home()),\n  }\n)\n```\n\nএখন:\n\n```dart\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page: () => Home()),\n  ]\n)\n```\n\nকেন এই পরিবর্তন? প্রায়শই, কোন পৃষ্ঠাটি প্যারামিটার বা লগইন টোকেন থেকে প্রদর্শিত হবে তা নির্ধারণ করার প্রয়োজন হতে পারে, পূর্ববর্তী পদ্ধতিটি অনমনীয় ছিল, কারণ এটি সেই অনুমতি দিতো না।\nএটি ফাংশনে পৃষ্ঠাটি ইনসার্ট করার জন্য উল্লেখযোগ্যভাবে RAM খরচ হ্রাস করেছে, যেহেতু অ্যাপটি শুরু হওয়ার পর থেকে রুটগুলি মেমরিতে বরাদ্দ করা হবে না, এটি এই ধরণের পদ্ধতিরও অনুমতি দেয়:\n\n```dart\n\nGetStorage box = GetStorage();\n\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page:(){\n      return box.hasData('token') ? Home() : Login();\n    })\n  ]\n)\n```\n"
        },
        {
          "name": "README-es.md",
          "type": "blob",
          "size": 31.4580078125,
          "content": "![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n*Idiomas: Español (este archivo), [Vietnamita](README-vi.md), [Indonesio](README.id-ID.md), [Urdu](README.ur-PK.md), [Lengua china](README.zh-cn.md), [Inglés](README.md), [Portugués de Brasil](README.pt-br.md), [Ruso](README.ru.md), [Polaco](README.pl.md), [Coreano](README.ko-kr.md), [Francés](README-fr.md).*\n\n[![pub package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n[![popularity](https://badges.bar/get/popularity)](https://pub.dev/packages/sentry/score)\n[![likes](https://badges.bar/get/likes)](https://pub.dev/packages/get/score)\n[![pub points](https://badges.bar/get/pub%20points)](https://pub.dev/packages/get/score)\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n[![style: effective dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n[![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n[![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n<a href=\"https://github.com/Solido/awesome-flutter\">\n   <img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n</a>\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n<h3>Lamentamos la inconsistencia en la traducción. El paquete GetX se actualiza con bastante frecuencia y es posible que las traducciones a documentos no sean tan rápidas. Entonces, para que esta documentación aún tenga todo el contenido, dejaré aquí todos los textos nuevos sin traducir (considero que es mejor tener los documentos en inglés que no tenerlos), por lo que si alguien quiere traducir, sería de gran ayuda 😁</h3>\n\n- [Sobre GetX](#sobre-getx)\n- [Instalación](#instalación)\n- [Proyecto contador con GetX](#proyecto-contador-con-getx)\n- [Los tres pilares](#los-tres-pilares)\n  - [Gestión del Estado](#gestión-del-estado)\n    - [Reactivo STATE_MANAGER](#reactivo-state_manager)\n    - [Más detalles sobre la gestión del estado.](#más-detalles-sobre-la-gestión-del-estado)\n    - [Explicación en video sobre state management](#explicación-en-video-sobre-state-management)\n  - [Gestión de Rutas](#gestión-de-rutas)\n    - [Más detalles sobre la gestión de rutas.](#más-detalles-sobre-la-gestión-de-rutas)\n    - [Explicación del video](#explicación-del-video)\n  - [Gestión de dependencias](#gestión-de-dependencias)\n    - [Más detalles sobre la gestión de dependencias.](#más-detalles-sobre-la-gestión-de-dependencias)\n- [Utilidades](#utilidades)\n  - [Cambiar de tema](#cambiar-de-tema)\n  - [Otras API avanzadas y configuraciones manuales](#otras-api-avanzadas-y-configuraciones-manuales)\n    - [Configuraciones globales opcionales](#configuraciones-globales-opcionales)\n  - [Video explanation of Other GetX Features](#video-explanation-of-other-getx-features)\n- [Cambios importantes desde 2.0](#cambios-importantes-desde-20)\n- [¿Por qué Getx?](#por-qué-getx)\n- [Comunidad](#comunidad)\n  - [Canales de la comunidad](#canales-de-la-comunidad)\n  - [Cómo contribuir](#cómo-contribuir)\n  - [Artículos y vídeos](#artículos-y-vídeos-inglés)\n\n# Sobre GetX\n\n- GetX es una solución extra ligera y potente para Flutter. Combina gestión de estádo de alto rendimiento, inyección de dependencia inteligente y gestión de rutas de forma rápida y práctica.\n\n- GetX tiene 3 principios básicos, esto significa que esta es la prioridad para todos los recursos de la biblioteca.\n  - **RENDIMIENTO:** GetX se centra en el rendimiento y el consumo mínimo de recursos. Los puntos de referencia casi siempre no son importantes en el mundo real, pero si lo desea, aquí hay un indicador de consumo.([benchmarks](https://github.com/jonataslaw/benchmarks)), donde GetX lo hace mejor que otros enfoques de gestión estatal, por ejemplo. La diferencia no es grande, pero muestra nuestra preocupación por no desperdiciar sus recursos.\n  - **PRODUCTIVIDAD:** GetX utiliza una sintaxis fácil y agradable.\n  - **ORGANIZACIÓN:** GetX permite el desacoplamiento total de la vista de la lógica de negocio.\n\n* GetX ahorrará horas de desarrollo y extraerá el máximo rendimiento que su aplicación puede ofrecer, siendo fácil para los principiantes y precisa para los expertos. Navega sin contexto, abre diálogos, snackbars o bottomsheets desde cualquier lugar de tu código, gestiona estados e inyecta dependencias de forma fácil y práctica. Get es seguro, estable, actualizado y ofrece una amplia gama de API que no están presentes en el marco predeterminado.\n\n- GetX no es bloated. Tiene una multitud de características que le permiten comenzar a programar sin preocuparse por nada, pero cada una de estas características se encuentran en contenedores separados y solo se inician después de su uso. Si solo usa State Management, solo se compilará State Management. Si solo usa rutas, no se compilará nada de la administración estatal. Puede compilar el repositorio de referencia y verá que al usar solo la administración de estado de Get, la aplicación compilada con Get se ha vuelto más pequeña que todas las demás aplicaciones que solo tienen la administración de estado de otros paquetes, porque nada que no se use se compilará en su código, y cada solución GetX fue diseñada para ser muy liviana. El mérito aquí también proviene del movimiento del árbol de Flutter, que es increíble y logra eliminar los recursos no utilizados como ningún otro marco lo hace.\n\n**GetX hace que su desarrollo sea productivo, pero ¿quiere hacerlo aún más productivo? [Agregue la extensión a su VSCode](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets)**\n\n# Instalación\n\nAñada la librería Get en tu archivo pubspec.yaml:\n\n```yaml\ndependencies:\n  get:\n```\n\nImporte Get en los archivos en los que se utilizará:\n\n```dart\nimport 'package:get/get.dart';\n```\n\n# Proyecto Contador con GetX\n\nVea una explicación más detallada de la administración del estado [aquí](./documentation/es_ES/state_management.md). Allí verá más ejemplos y también la diferencia entre el Gestión del Estado simple y el Gestión del Estado reactivo\n\nEl proyecto \"contador\" creado por defecto en un nuevo proyecto en Flutter tiene más de 100 líneas (con comentarios). Para mostrar el poder de GetX, demostraré cómo hacer un \"contador\" cambiando el estado con cada clic, cambiando de página y compartiendo el estado entre pantallas, todo de manera organizada, separando la vista de la lógica de negocio, SOLO 26 LÍNEAS DE CÓDIGO INCLUIDOS COMENTARIOS.\n\n- Paso 1: Agregue \"Get\" antes de su materialApp, convirtiéndolo en GetMaterialApp\n\n```dart\nvoid main() => runApp(GetMaterialApp(home: Home()));\n```\n\n**Nota**: esto no modifica el MaterialApp del Flutter, GetMaterialApp no es una MaterialApp modificado, es solo un Widget preconfigurado que tiene como child un MaterialApp por defecto. Puede configurar esto manualmente, pero definitivamente no es necesario. GetMaterialApp creará rutas, las inyectará, inyectará traducciones, inyectará todo lo que necesita para la navegación de rutas. Si usa Get solo para la gestión de estado o dependencias, no es necesario usar GetMaterialApp. GetMaterialApp es necesario para rutas, snackbars, internacionalización, bottomSheets, diálogos y APIs de alto nivel relacionadas con rutas y ausencia de contexto.\n\n**Nota²:** Este paso solo es necesario si va a usar route management (`Get.to()`, `Get.back()` y así). Si no lo va a usar, no es necesario que realice el paso 1\n\n- Paso 2: Cree su clase con la lógica de negocio colocando todas las variables, métodos y controladores dentro de ella. Puede hacer que cualquier variable sea observable usando un simple \".obs\".\n\n```dart\nclass Controller extends GetxController {\n  var count = 0.obs;\n  increment() => count.value++;\n}\n```\n\n- Paso 3: Cree su vista, use StatelessWidget y ahorre algo de RAM, con GetX ya no necesitará usar StatefulWidget.\n\n```dart\nclass Home extends StatelessWidget {\n\n  @override\n  Widget build(context) {\n\n    // Cree una instancia de su clase usando Get.put() para que esté disponible para todas las rutas \"secundarias\" allí.\n    final Controller c = Get.put(Controller());\n    \n    return Scaffold(\n      // Utilice Obx(()=> para actualizar Text() siempre que se cambie el recuento.\n      appBar: AppBar(title: Obx(() => Text(\"Clicks: \" + c.count.string))),\n\n      // Reemplace el Navigator.push de 8 líneas por un simple Get.to(). No necesitas contexto\n      body: Center(child: ElevatedButton(\n              child: Text(\"Go to Other\"), onPressed: () => Get.to(Other()))),\n      floatingActionButton:\n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n  }\n}\n\nclass Other extends StatelessWidget {\n  // Puede pedirle a Get que busque un controlador que está siendo utilizado por otra página y le redirija a él.\n  final Controller c = Get.find();\n\n  @override\n  Widget build(context){\n     // Acceder a la variable de recuento actualizada\n     return Scaffold(body: Center(child: Text(c.count.string)));\n  }\n}\n\n```\n\nResultado:\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/counter-app-gif.gif)\n\nEste es un proyecto simple pero ya deja en claro cuán poderoso es GetX. A medida que su proyecto crezca, esta diferencia se volverá más significativa. GetX fue diseñado para trabajar con equipos, pero también simplifica el trabajo de un desarrollador individual. Mejore sus plazos, entregue todo a tiempo, sin perder rendimiento. GetX no es para todos, pero si te identificaste con esa frase, ¡GET es para ti!\n\n# Los tres pilares\n\n## Gestión del Estado\n\nActualmente hay varios State Managers para Flutter. Sin embargo, con la mayoría de ellos implica utilizar ChangeNotifier para actualizar widgets y este es un enfoque malo y muy malo para el rendimiento de aplicaciones medianas o grandes. Puede verificar en la documentación oficial de Flutter que [ChangeNotifier debe usarse con 1 o un máximo de 2 listeners](https://api.Flutter.dev/Flutter/foundation/ChangeNotifier-class.html), por lo que es prácticamente inutilizable para cualquier aplicación mediana o grande.\n\nGetX no es mejor ni peor que cualquier otro gestor de estado, pero debe analizar estos puntos, así como los puntos que se mencionan a continuación, para elegir entre usar GetX en forma pura (vanilla) o usarlo junto con otro gestor de estado.\n\nDefinitivamente, GetX no es enemigo de ningún otro gestor de estado, porque GetX es más bien un microframework, no solo un gestor de estado, y se puede usar solo o en combinación con ellos.\n\n### Reactivo STATE_MANAGER\n\nLa programación reactiva puede alienar a muchas personas porque se dice que es complicada. GetX convierte la programación reactiva en algo tan simple que puede ser aprendido y utilizado por aquellos que comenzaron en ese mismo momento en Flutter. No, no necesitará crear StreamControllers. Tampoco necesitará crear un StreamBuilder para cada variable. No necesitará crear una clase para cada estado. No necesitará crear un get para un valor inicial. La programación reactiva con GetX es tan fácil como usar setState (¡o incluso más fácil!).\n\nImaginemos que tiene una variable \"name\" y desea que cada vez que la modifique, todos los widgets que la usan cambien automáticamente.\n\nEj. esta es tu variable \"name\":\n\n```dart\nvar name = 'Jonatas Borges';\n```\n\nPara que sea observable, solo necesita agregar \".obs\" al final:\n\n```dart\nvar name = 'Jonatas Borges'.obs;\n```\n\n¿StreamBuilder? ¿initialValue? ¿builder? No, solo necesitas jugar con esta variable dentro de un widget Obx.\n\n```dart\nObx(() => Text (controller.name));\n```\n\n### Más detalles sobre la gestión del estado.\n\n**Vea una explicación más detallada de la administración del estado [aquí](./documentation/es_ES/state_management.md). Allí verá más ejemplos y también la diferencia entre el Gestión del Estado simple y el Gestión del Estado reactivo**\n\n### Explicación en video sobre state management\n\nDarwin Morocho hizo una increíble serie de videos sobre state management! Link: [Complete GetX State Management](https://www.youtube.com/watch?v=PTjj0DFK8BA&list=PLV0nOzdUS5XtParoZLgKoVwNSK9zROwuO)\n\nObtendrá una buena idea de la potencia de GetX.\n\n## Gestión de Rutas\n\nPara navegar a una nueva pantalla:\n\n```dart\nGet.to(NextScreen());\n```\n\nPara cerrar snackbars, dialogs, bottomsheets o cualquier cosa que normalmente cierre con Navigator.pop(contexto);\n\n```dart\nGet.back();\n```\n\nPara ir a la siguiente pantalla, sin opción a volver (util por ejemplo en SplashScreens, LoginScreen, etc.)\n\n```dart\nGet.off(NextScreen());\n```\n\nPara ir a la siguiente pantalla y cancelar todas las rutas anteriores (útil en carritos de compras, encuestas y exámenes)\n\n```dart\nGet.offAll(NextScreen());\n```\n\nPara navegar a la siguiente ruta y recibir o actualizar datos tan pronto como se regrese de ella:\n\n```dart\nvar data = await Get.to(Payment());\n```\n\n### Más detalles sobre la gestión de rutas.\n\n**Vea una explicación más detallada de la Gestión de Rutas [aquí](./documentation/es_ES/route_management.md).**\n\n### Explicación del video\n\nAmateur Coder hizo un excelente video que cubre route management con Get! aquí esta el link: [Complete Getx Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI)\n\n## Gestión de dependencias\n\n- Nota: si está utilizando el gestor de estado de GetX, no tiene que preocuparse por esto, solo lea para obtener información, pero preste más atención a la API de bindings, que hará todo esto automáticamente por usted.\n\n¿Ya estás utilizando GetX y quieres que tu proyecto sea lo más ágil posible? GetX tiene un gestor de dependencias simple y poderoso que le permite recuperar la misma clase que su BLoC o Controller con solo una líneas de código, sin contexto de Provider, sin inheritedWidget:\n\n```dart\nController controller = Get.put(Controller()); // Rather Controller controller = Controller();\n```\n\nEn lugar de crear una instancia de su clase dentro de la clase que está utilizando, la está creando dentro de la instancia GetX, que la hará disponible en toda su aplicación. Entonces puede usar su Controller (o BLoC) normalmente.\n\n```dart\ncontroller.fetchApi();\n```\n\nImagine que ha navegado a través de numerosas rutas y necesita datos que quedaron en su controlador, necesitaría un gestor de estado combinado con Provider o Get_it, ¿correcto? No con GetX. Solo necesita pedirle a GetX que \"encuentre\" su controlador, no necesita dependencias adicionales:\n\n```dart\nController controller = Get.find();\n//Sí, parece que es magia, Get encontrará su controlador y se lo entregará. Puede tener 1 millón de controladores instanciados, Get siempre le dará el controlador correcto.\n```\n\nY luego podrá recuperar los datos de su controlador que se obtuvieron allí:\n\n```dart\nText(controller.textFromApi);\n```\n\n¿Buscando lazy loading? Puede declarar todos sus controladores, y se llamará solo cuando alguien lo necesite. Puedes hacer esto con:\n\n```dart\nGet.lazyPut<Service>(()=> ApiMock());\n/// ApiMock solo se llamará cuando alguien use Get.find<Service> por primera vez\n```\n\n### Más detalles sobre la gestión de dependencias.\n\n**Vea una explicación más detallada de la Gestión de dependencias [aquí](./documentation/es_ES/dependency_management.md).**\n\n# Utilidades\n\n## Cambiar de tema\n\nNo utilice ningún widget de nivel superior que GetMaterialApp para actualizarlo. Esto puede activar claves duplicadas. Mucha gente está acostumbrada al enfoque prehistórico de crear un widget \"ThemeProvider\" solo para cambiar el tema de su aplicación, y esto definitivamente NO es necesario con GetX.\n\nPuede crear su tema personalizado y simplemente agregarlo dentro de Get.changeTheme sin ningún boilerplate para eso:\n\n```dart\nGet.changeTheme(ThemeData.light());\n```\n\nSi desea crear algo así como un botón que cambia el tema con onTap, puede combinar dos APIs GetX para eso, la API que verifica si se está utilizando el tema oscuro y la API de cambio de tema, simplemente puede poner esto dentro de un onPressed:\n\n```dart\nGet.changeTheme(Get.isDarkMode? ThemeData.light(): ThemeData.dark());\n```\n\nCuando el modo oscuro está activado, cambiará al tema claro, y cuando el tema claro esté activado, cambiará a oscuro.\n\nSi quieres saber en profundidad cómo cambiar el tema, puedes seguir este tutorial en Medium que incluso enseña la persistencia del tema usando GetX:\n\n- [Temas dinámicos en 3 líneas usando GetX](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Tutorial de [Rod Brown](https://github.com/RodBr).\n\n## Otras API avanzadas y configuraciones manuales\n\nGetMaterialApp configura todo para usted, pero si desea configurar GetX manualmente utilizando APIs avanzadas.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver()],\n);\n```\n\nTambién podrá usar su propio Middleware dentro de GetObserver, esto no influirá en nada.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver(MiddleWare.observer)], // Here\n);\n```\n\n```dart\n// dar los argumentos actuales de currentScreen\nGet.arguments\n\n// dar el nombre de la ruta anterior\nGet.previousRoute\n\n// dar la ruta sin procesar para acceder, por ejemplo, rawRoute.isFirst()\nGet.rawRoute\n\n// dar acceso a Routing API desde GetObserver\nGet.routing\n\n// comprobar si la cafetería está abierta\nGet.isSnackbarOpen\n\n// comprobar si el diálogo está abierto\nGet.isDialogOpen\n\n// comprobar si  bottomsheet está abierto\nGet.isBottomSheetOpen\n\n// eliminar una ruta.\nGet.removeRoute()\n\n// volver repetidamente hasta que predicate devuelva verdadero.\nGet.until()\n\n//ir a la siguiente ruta y eliminar todas las rutas anteriores hasta que predicate devuelva verdadero.\nGet.offUntil()\n\n// ir a la siguiente ruta con nombre y eliminar todas las rutas anteriores hasta que predicate devuelve verdadero.\nGet.offNamedUntil()\n\n//Verifique en qué plataforma se ejecuta la aplicación\nGetPlatform.isAndroid\nGetPlatform.isIOS\nGetPlatform.isWeb\n\n// Equivalente al método: MediaQuery.of(context).size.height, pero son inmutables.\nGet.height\nGet.width\n\n// Da el contexto de la pantalla en primer plano en cualquier parte de su código.\nGet.context\n\n// Da el contexto de la barra de bocadillos / diálogo / hoja inferior en primer plano en cualquier parte de su código.\nGet.contextOverlay\n\n// Note: los siguientes métodos son extensiones de context. Desde que tu\n// tiene acceso al contexto en cualquier lugar de su interfaz de usuario, puede usarlo en cualquier lugar del código de la interfaz de usuario\n\n// Si necesita un cambiable height/width (como las ventanas del navegador que se pueden escalar) necesitará usar context.\ncontext.width\ncontext.height\n\n\n\n// le da el poder de definir la mitad de la pantalla ahora, un tercio y así sucesivamente.\n// Útil para aplicaciones receptivas.\n// param dividedBy (double) optional - default: 1\n// param reducedBy (double) optional - default: 0\ncontext.heightTransformer()\ncontext.widthTransformer()\n\n/// Similar a MediaQuery.of(context).size\ncontext.mediaQuerySize()\n\n/// similar a MediaQuery.of(context).padding\ncontext.mediaQueryPadding()\n\n/// similar a MediaQuery.of(context).viewPadding\ncontext.mediaQueryViewPadding()\n\n/// similar a MediaQuery.of(context).viewInsets;\ncontext.mediaQueryViewInsets()\n\n/// similar a MediaQuery.of(context).orientation;\ncontext.orientation()\n\n/// comprobar si el dispositivo esta en landscape mode\ncontext.isLandscape()\n\n/// comprobar si el dispositivo esta en portrait mode\ncontext.isPortrait()\n\n/// similar a MediaQuery.of(context).devicePixelRatio;\ncontext.devicePixelRatio()\n\n/// similar a MediaQuery.of(context).textScaleFactor;\ncontext.textScaleFactor()\n\n/// obtener el lado más corto de la pantalla\ncontext.mediaQueryShortestSide()\n\n/// Verdadero si el ancho es mayor que 800\ncontext.showNavbar()\n\n/// Verdadero si el lado más corto es menor que 600p\ncontext.isPhone()\n\n/// Verdadero si el lado más corto es más grande que 600p\ncontext.isSmallTablet()\n\n/// Verdadero si el lado más corto es mayor que 720p\ncontext.isLargeTablet()\n\n/// Verdadero si el dispositivo actual es una tableta\ncontext.isTablet()\n```\n\n### Configuraciones globales opcionales\n\nPuede crear configuraciones globales para GetX. Simplemente agregue Get.config a su código antes de insertar cualquier ruta o hágalo directamente en su GetMaterialApp\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  defaultTransition: Transition.fade,\n  opaqueRoute: Get.isOpaqueRouteDefault,\n  popGesture: Get.isPopGestureEnable,\n  transitionDuration: Get.defaultDurationTransition,\n  defaultGlobalState: Get.defaultGlobalState,\n);\n\nGet.config(\n  enableLog = true,\n  defaultPopGesture = true,\n  defaultTransition = Transitions.cupertino\n)\n```\n\nOpcionalmente, puede redirigir todos los mensajes de registro de Get. Si desea utilizar su propio paquete de registro favorito y desea capturar los registros allí.\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  logWriterCallback: localLogWriter,\n);\n\nvoid localLogWriter(String text, {bool isError = false}) {\n // pase el mensaje a su paquete de registro favorito aquí\n  //Nota: incluso si los mensajes de registro están desactivados\n  // con el comando \"enableLog: false\", los mensajes seguirán pasando por aquí\n  // Debe verificar esta configuración manualmente aquí si desea respetarla\n}\n\n```\n\n## Video explanation of Other GetX Features\n\nAmateur Coder hizo un video asombroso sobre utilidades, almacenamiento, enlaces y otras características! Link: [GetX Other Features](https://youtu.be/ttQtlX_Q0eU)\n\n# Cambios importantes desde 2.0\n\n1- Rx types:\n\n| Antes   | Ahora      |\n| ------- | ---------- |\n| StringX | `RxString` |\n| IntX    | `RxInt`    |\n| MapX    | `RxMap`    |\n| ListX   | `RxList`   |\n| NumX    | `RxNum`    |\n| DoubleX | `RxDouble` |\n\nRxController y GetBuilder ahora se han fusionado, ya no necesita memorizar qué controlador desea usar, solo use GetXController, funcionará para gestión de estádo simple y también para reactivo.\n\n2- Rutas Nombradas\n\nAntes:\n\n```dart\nGetMaterialApp(\n  namedRoutes: {\n    '/': GetRoute(page: Home()),\n  }\n)\n```\n\nAhora:\n\n```dart\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page: () => Home()),\n  ]\n)\n```\n\n¿Por qué este cambio?\n\nA menudo, puede ser necesario decidir qué página se mostrará desde un parámetro o un token de inicio de sesión, el enfoque anterior era inflexible, ya que no permitía esto.\n\nInsertar la página en una función ha reducido significativamente el consumo de RAM, ya que las rutas no se asignarán en la memoria desde que se inició la aplicación, y también permitió hacer este tipo de enfoque:\n\n```dart\nGetStorage box = GetStorage();\n\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page:(){\n      return box.hasData('token') ? Home() : Login();\n    })\n  ]\n)\n```\n\n# ¿Por qué Getx?\n\n1- Después de una actualización de Flutter, muchos paquetes suelen romperse. A veces se producen errores de compilación, errores de los que aún no hay respuestas y el desarrollador necesita saber el origen del error, poder rastrear, y solo entonces intentar abrir un issue en el repositorio correspondiente, para finalmente ver su problema resuelto. Getx centraliza los principales recursos para el desarrollo (gestión de estado, dependencia y rutas), lo que le permite agregar un único paquete a su pubspec y comenzar a trabajar. Después de una actualización de Flutter, lo único que debe hacer es actualizar la dependencia Get y ponerse a trabajar. Get también resuelve problemas de compatibilidad. ¿Cuántas veces una versión de un paquete no es compatible con la versión de otro, porque una usa una dependencia en una versión y la otra en otra? Tampoco es una preocupación usando Get, ya que todo estará en el mismo paquete y será totalmente compatible.\n\n2- Flutter es fácil, Flutter es increíble, pero todavía tiene algo repetitivo que puede ser no deseado para la mayoría de los desarrolladores, como `Navigator.of(context).push (context, builder [...]`. Get simplifica el desarrollo. En lugar de escribir 8 líneas de código para simplemente llamar a una ruta, simplemente puede hacerlo: `Get.to(Home())` y listo, irá a la página siguiente. Algo doloroso de hacer con Flutter actualmente, mientras que con GetX es estúpidamente simple. Gestionar estados en Flutter y dependencias también es algo que genera mucho debate, ya que hay cientos de patrones en el pub. Pero no hay nada tan fácil como agregar un \".obs\" al final de su variable, y colocar su widget dentro de un Obx, y eso es todo, todas las actualizaciones de esa variable se actualizarán automáticamente en la pantalla.\n\n3- Facilidad sin preocuparse por el rendimiento. El rendimiento de Flutter ya es sorprendente, pero imagine que usa un gestor de estado y un localizador para distribuir sus clases de bloc/stores/controllers/ etc. Tendrá que llamar manualmente a la exclusión de esa dependencia cuando no la necesite. Pero, ¿alguna vez pensó en simplemente usar el controlador, y cuando ya no sea necesario, simplemente se elimine de la memoria? Eso es lo que hace GetX. Con SmartManagement, todo lo que no se está utilizando se elimina de la memoria, y no debería tener que preocuparse por nada más que la programación. Se le garantiza el consumo mínimo de recursos, sin siquiera haber creado una lógica para esto.\n\n4- Desacoplamiento real. Es posible que haya escuchado la idea de \"separar la vista de la lógica de negocio\". Esta no es una peculiaridad de BLoC, MVC, MVVM, cualquier otro estándar en el mercado tiene este concepto. Sin embargo, a menudo se puede mitigar en Flutter debido al uso del contexto.\nSi necesita contexto para encontrar un InheritedWidget, lo necesita en la vista o pasado por parámetro. En particular, encuentro esta solución muy fea, y para trabajar en equipo siempre tendremos una dependencia de la lógica de negocios de la vista. Getx no es ortodoxo con el enfoque estándar, y aunque no prohíbe completamente el uso de StatefulWidgets, InitState, etc., siempre tiene un enfoque similar que puede ser más limpio. Los controladores tienen ciclos de vida, y cuando necesita hacer una solicitud API REST, por ejemplo, no depende de nada en la vista. Puede usar onInit para iniciar la llamada http, y cuando lleguen los datos, se rellenarán las variables. Como GetX es completamente reactivo (realmente, y funciona bajo streams), una vez que se llenan los elementos, todos los widgets que usan esa variable se actualizarán automáticamente en la vista. Esto permite que las personas con experiencia en IU trabajen solo con widgets y no tengan que enviar nada a la lógica de negocios que no sean eventos de usuario (como hacer clic en un botón), mientras que las personas que trabajan con lógica de negocios podrán crearla y probarla por separado.\n\nEsta librería siempre se actualizará e implementará nuevas características. Siéntase libre de ofrecer PRs y contribuir a ellas.\n\n# Comunidad\n\n## Canales de la comunidad\n\nGetX tiene una comunidad muy activa e implicada. Si tiene dudas, o necesita cualquier tipo de asistencia sobre el uso de este framework, no dude en unirse a nuestr, tu duda será resuelta lo antes posible. Este repositorio es de uso exclusivo para abrir issues, pero siéntase libre de unirse a la Comunidad de GetX.\n\n\n| **Slack (🇬🇧)**                                                                                                                   | **Discord (🇬🇧 y 🇵🇹)**                                                                                                                 | **Telegram (🇵🇹)**                                                                                                          |\n| :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |\n| [![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx) | [![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N) | [![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g) |\n\n\n# Cómo contribuir\n\n_¿Quieres contribuir al proyecto? Estaremos orgullosos de destacarte como uno de nuestros colaboradores. Aquí hay algunos puntos en los que puede contribuir y hacer que GetX (y Flutter) sea aún mejor._\n\n- Ayudando a traducir el archivo Léame a otros idiomas.\n\n- Agregar documentación al archivo Léame (ni siquiera la mitad de las funciones de GetX han sido documentadas todavía).\n\n- Escriba artículos o haga videos que enseñen cómo usar GetX (se insertarán en el archivo Léame y en el futuro en nuestro Wiki).\n\n- Ofreciendo PRs para código/pruebas.\n\n- Incluyendo nuevas funciones.\n\n¡Cualquier contribución es bienvenida!\n\n## Artículos y vídeos (inglés)\n\n- [Flutter Getx EcoSystem package for arabic people](https://www.youtube.com/playlist?list=PLV1fXIAyjeuZ6M8m56zajMUwu4uE3-SL0) - Tutorial by [Pesa Coder](https://github.com/UsamaElgendy).\n- [Dynamic Themes in 3 lines using GetX™](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Tutorial by [Rod Brown](https://github.com/RodBr).\n- [Complete GetX™ Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI) - Route management video by Amateur Coder.\n- [Complete GetX State Management](https://www.youtube.com/watch?v=CNpXbeI_slw) - State management video by Amateur Coder.\n- [GetX™ Other Features](https://youtu.be/ttQtlX_Q0eU) - Utils, storage, bindings and other features video by Amateur Coder.\n- [Firestore User with GetX | Todo App](https://www.youtube.com/watch?v=BiV0DcXgk58) - Video by Amateur Coder.\n- [Firebase Auth with GetX | Todo App](https://www.youtube.com/watch?v=-H-T_BSgfOE) - Video by Amateur Coder.\n- [The Flutter GetX™ Ecosystem ~ State Management](https://medium.com/flutter-community/the-flutter-getx-ecosystem-state-management-881c7235511d) - State management by [Aachman Garg](https://github.com/imaachman).\n- [The Flutter GetX™ Ecosystem ~ Dependency Injection](https://medium.com/flutter-community/the-flutter-getx-ecosystem-dependency-injection-8e763d0ec6b9) - Dependency Injection by [Aachman Garg](https://github.com/imaachman).\n- [GetX, the all-in-one Flutter package](https://www.youtube.com/watch?v=IYQgtu9TM74) - A brief tutorial covering State Management and Navigation by Thad Carnevalli.\n- [Build a To-do List App from scratch using Flutter and GetX](https://www.youtube.com/watch?v=EcnqFasHf18) - UI + State Management + Storage video by Thad Carnevalli.\n- [GetX Flutter Firebase Auth Example](https://medium.com/@jeffmcmorris/getx-flutter-firebase-auth-example-b383c1dd1de2) - Article by Jeff McMorris.\n- [Flutter State Management with GetX – Complete App](https://www.appwithflutter.com/flutter-state-management-with-getx/) - by App With Flutter.\n- [Flutter Routing with Animation using Get Package](https://www.appwithflutter.com/flutter-routing-using-get-package/) - by App With Flutter.\n- [A minimal example on dartpad](https://dartpad.dev/2b3d0d6f9d4e312c5fdbefc414c1727e?) - by [Roi Peker](https://github.com/roipeker)\n"
        },
        {
          "name": "README-fr.md",
          "type": "blob",
          "size": 50.7666015625,
          "content": "![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n**Langues: Français (Ce fichier), [Anglais](README.md), [Vietnamien](README-vi.md), [Indonésien](README.id-ID.md), [Urdu](README.ur-PK.md), [Chinois](README.zh-cn.md), [Portuguais du Brésil](README.pt-br.md), [Espagnol](README-es.md), [Russe](README.ru.md), [Polonais](README.pl.md), [Koréen](README.ko-kr.md).**\n\n[![pub package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n[![popularity](https://badges.bar/get/popularity)](https://pub.dev/packages/sentry/score)\n[![likes](https://badges.bar/get/likes)](https://pub.dev/packages/get/score)\n[![pub points](https://badges.bar/get/pub%20points)](https://pub.dev/packages/get/score)\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n[![style: effective dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n[![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n[![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n<a href=\"https://github.com/Solido/awesome-flutter\">\n<img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n</a>\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Achetez moi un cafe\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n- [A Propos de Get](#a-propos-de-get)\n- [Installation](#installation)\n- [L'application 'Counter' avec GetX](#application-counter-avec-getx)\n- [Les trois pilliers](#les-trois-pilliers)\n  - [Gestion d'état (State management)](#gestion-d-etat)\n    - [Gestionnaire d'état réactif (Reactive State Manager)](#gestionnaire-d-etat-reactif)\n    - [Plus de détails sur la gestion d'état](#plus-de-details-sur-la-gestion-d-etat)\n  - [Gestion de route](#gestion-de-route)\n    - [Plus de détails sur la gestion de route](#plus-de-details-sur-la-gestion-de-route)\n  - [Gestion des dépendances](#gestion-des-dependances)\n    - [Plus de détails sur la gestion des dépendances](#plus-de-details-sur-la-gestion-des-dependances)\n- [Utils](#utils)\n  - [Internationalization](#internationalization)\n    - [Traductions](#traductions)\n      - [Utiliser les traductions](#utiliser-les-traductions)\n    - [Locales](#locales)\n      - [Changer la locale](#changer-la-locale)\n      - [Locale du Système](#locale-du-systeme)\n  - [Changer le Thème](#changer-le-theme)\n  - [GetConnect](#getconnect)\n    - [Configuration par défaut](#configuration-par-defaut)\n    - [Configuration personnalisée](#configuration-personnalisee)\n  - [Middleware GetPage](#middleware-getpage)\n    - [Priority](#priority)\n    - [Redirect](#redirect)\n    - [onPageCalled](#onpagecalled)\n    - [OnBindingsStart](#onbindingsstart)\n    - [OnPageBuildStart](#onpagebuildstart)\n    - [OnPageBuilt](#onpagebuilt)\n    - [OnPageDispose](#onpagedispose)\n  - [Autres APIs](#autres-apis)\n    - [Paramètres globaux et configurations manuelles facultatifs](#parametres-globaux-et-configurations-manuelles-facultatifs)\n    - [State Widgets Locaux](#state-widgets-locaux)\n      - [ValueBuilder](#valuebuilder)\n      - [ObxValue](#obxvalue)\n  - [Conseils utiles](#conseils-utiles)\n    - [GetView](#getview)\n    - [GetResponsiveView](#getresponsiveview)\n      - [Guide d'utilisation](#guide-d-utilisation)\n    - [GetWidget](#getwidget)\n    - [GetxService](#getxservice)\n- [Changements par rapport à 2.0](#changements-par-rapport-a-20)\n- [Pourquoi Getx?](#pourquoi-getx)\n- [Communité](#communite)\n  - [Chaînes communautaires](#chaines-communautaires)\n  - [Comment contribuer](#comment-contribuer)\n  - [Articles et videos](#articles-et-videos)\n\n# A Propos de Get\n\n- GetX est une solution extra-légère et puissante pour Flutter. Il combine une gestion d'état (state management) de haute performance, une injection de dépendances (dependency injection) intelligente et une gestion de route (route management) rapide et pratique.\n\n- GetX a 3 principes de base. Cela signifie que ces principes sont les priorités pour toutes les ressources de la bibliothèque GetX: **PRODUCTIVITÉ, PERFORMANCE ET ORGANIZATION.**\n\n  - **PERFORMANCE:** GetX se concentre sur la performance et la consommation minimale de ressources. GetX n'utilise ni Streams ni ChangeNotifier.\n\n  - **PRODUCTIVITÉ:** GetX utilise une syntaxe simple et agréable. Peu importe ce que vous voulez faire, il existe toujours un moyen plus simple avec GetX. Cela économisera des heures de développement et fournira les performances maximales que votre application peut offrir.\n\n    En règle générale, le développeur doit s'occuper lui-même de la suppression des contrôleurs de la mémoire. Avec GetX, cela n'est pas nécessaire car les ressources sont, par défaut, supprimées de la mémoire lorsqu'elles ne sont pas utilisées. Si vous souhaitez les conserver en mémoire, vous devez déclarer explicitement \"permanent: true\" comme paramètre lors de la création de la ressource. De cette façon, en plus de gagner du temps, vous risquez moins d'avoir des ressources inutiles dans la mémoire. L'initialisation des ressources est également 'lazy' par défaut (i.e. se fait seulement lorsque la ressource est nécessaire).\n\n  - **ORGANIZATION:** GetX permet le découplage total de la Vue (View), de la Logique de Présentation (Presentation Logic), de la Business Logic, de l'injection de dépendances (Dependency Injection) et de la Navigation. Vous n'avez pas besoin de contexte pour naviguer entre les routes, vous n'êtes donc pas dépendant de la hiérarchisation des widgets (visualisation) pour cela. Vous n'avez pas besoin de 'context' pour accéder à vos contrôleurs/blocs via un inheritedWidget, vous dissociez donc complètement votre logique de présentation (Vue) et votre Business logic de votre couche de visualisation. Vous n'avez pas besoin d'injecter vos classes Controlleûrs / Modèles / Blocs le long de la hiérarchie de Widgets via `MultiProvider`. Pour cela, GetX utilise sa propre fonction d'injection de dépendances (DI), découplant complètement la DI de sa Vue.\n\n    Avec GetX, vous savez où trouver chaque module de votre application, avec un code propre par défaut. En plus de rendre la maintenance facile, cela rend le partage de modules quelque chose qui jusque-là dans Flutter était impensable, quelque chose de totalement possible.\n    BLoC était un point de départ pour organiser le code dans Flutter, il sépare la Business logic de la visualisation. GetX en est une évolution naturelle, séparant non seulement la Business logic mais aussi la logique de présentation. L'injection de dépendances et les routes sont également découplées, et la couche de données est séparée du tout. Vous savez où tout se trouve, et tout cela d'une manière plus facile que de construire un 'Hello World''.\n    GetX est le moyen le plus simple, pratique et évolutif de créer des applications hautes performances avec le SDK Flutter. Il possède un vaste écosystème qui fonctionne parfaitement, c'est facile pour les débutants et précis pour les experts. Il est sécurisé, stable, à jour et offre une vaste gamme d'API intégrées qui ne sont pas présentes dans le SDK Flutter par défaut.\n\n- GetX possède une multitude de fonctionnalités qui vous permettent de démarrer la programmation sans vous soucier de quoi que ce soit, mais chacune de ces fonctionnalités se trouve dans des conteneurs séparés et ne démarre qu'après utilisation. Si vous n'utilisez que la gestion des états (State Management), seule la gestion des états sera compilée. Si vous n'utilisez que des routes, rien de la gestion d'état ne sera compilé.\n\n- GetX a un énorme écosystème, une grande communauté, un grand nombre de collaborateurs, et sera maintenu tant que Flutter existera. GetX est également capable de fonctionner avec le même code sur Android, iOS, Web, Mac, Linux, Windows et sur votre serveur. Il est possible de réutiliser entièrement votre code créé sur le frontend et le backend avec Get Server.\n  **Il est possible d'entièrement réutiliser votre code écrit sur le frontend, pour le backend avec [Get Server](https://github.com/jonataslaw/get_server)**.\n\n**De plus, l'ensemble du processus de développement peut être complètement automatisé, à la fois sur le serveur et sur le front-end avec [Get CLI](https://github.com/jonataslaw/get_cli)**.\n\n**De plus, pour augmenter encore votre productivité, nous avons l'[extension pour VSCode](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets) et l'[extension pour Android Studio/Intellij](https://plugins.jetbrains.com/plugin/14975-getx-snippets)**\n\n# Installation\n\nAjoutez Get à votre fichier pubspec.yaml:\n\n```yaml\ndependencies:\n  get:\n```\n\nImportez Get dans les fichiers dans lesquels il doit être utilisé:\n\n```dart\nimport 'package:get/get.dart';\n```\n\n# Application Counter avec Getx\n\nLe projet \"Counter\" créé par défaut sur chaque nouveau projet Flutter comporte plus de 100 lignes (avec commentaires). Pour montrer la puissance de Get, je vais vous montrer comment faire un \"compteur\" changeant d'état à chaque clic, naviguer entre les pages et partager l'état entre les écrans, le tout de manière organisée, en séparant la Business logic de la Vue, en SEULEMENT 26 LIGNES DE CODE INCLUANT LES COMMENTAIRES.\n\n- Step 1:\n  Ajoutez \"Get\" avant MaterialApp, pour le transformer en GetMaterialApp\n\n```dart\nvoid main() => runApp(GetMaterialApp(home: Home()));\n```\n\n- Note: cela ne modifie pas le MaterialApp de Flutter, GetMaterialApp n'est pas un MaterialApp modifié, il s'agit simplement d'un widget préconfiguré, qui a le MaterialApp par défaut comme enfant (child: ). Vous pouvez le configurer manuellement, mais ce n'est certainement pas nécessaire. GetMaterialApp créera des routes, les injectera, injectera les traductions, injectera tout ce dont vous avez besoin pour la navigation de routes. Si vous utilisez Get uniquement pour la gestion de l'état (State management) ou la gestion des dépendances (DI), il n'est pas nécessaire d'utiliser GetMaterialApp. GetMaterialApp est nécessaire pour les routes, les 'snackbars', l'internationalisation, les 'bottomSheets', les dialogues et les API de haut niveau liés aux routes et à l'absence de 'context'.\n\n- Note²: Cette étape n'est nécessaire que si vous allez utiliser la gestion de routes (Get.to(), Get.back(), etc). Si vous ne l'utiliserez pas, il n'est pas nécessaire de faire l'étape 1.\n\n- Step 2:\n  Créez votre classe de Business logic et placez-y toutes les variables, méthodes et contrôleurs.\n  Vous pouvez rendre toute variable observable en utilisant un simple \".obs\".\n\n```dart\nclass Controller extends GetxController{\n  var count = 0.obs;\n  increment() => count++;\n}\n```\n\n- Step 3:\n  Créez votre Vue, utilisez StatelessWidget et économisez de la RAM, avec Get, vous n'aurez peut-être plus besoin d'utiliser StatefulWidget.\n\n```dart\nclass Home extends StatelessWidget {\n\n  @override\n  Widget build(context) {\n\n    // Instanciez votre classe en utilisant Get.put() pour le rendre disponible pour tous les routes \"descendantes\".\n    final Controller c = Get.put(Controller());\n\n    return Scaffold(\n      // Utilisez Obx(()=> pour mettre à jour Text() chaque fois que count est changé.\n      appBar: AppBar(title: Obx(() => Text(\"Clicks: ${c.count}\"))),\n\n      // Remplacez les 8 lignes Navigator.push par un simple Get.to(). Vous n'avez pas besoin de 'context'\n      body: Center(child: ElevatedButton(\n              child: Text(\"Go to Other\"), onPressed: () => Get.to(Other()))),\n      floatingActionButton:\n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n  }\n}\n\nclass Other extends StatelessWidget {\n  // Vous pouvez demander à Get de trouver un contrôleur utilisé par une autre page et de vous y rediriger.\n  final Controller c = Get.find();\n\n  @override\n  Widget build(context){\n     // Accéder à la variable 'count' qui est mise à jour\n     return Scaffold(body: Center(child: Text(\"${c.count}\")));\n  }\n}\n```\n\nRésultat:\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/counter-app-gif.gif)\n\nC'est un projet simple mais il montre déjà à quel point Get est puissant. Au fur et à mesure que votre projet se développe, cette différence deviendra plus significative.\n\nGet a été conçu pour fonctionner avec des équipes, mais il simplifie le travail d'un développeur individuel.\n\nAméliorez vos délais, livrez tout à temps sans perte de performances. Get n'est pas pour tout le monde, mais si vous vous êtes identifié à cette phrase, Get est fait pour vous!\n\n# Les trois pilliers\n\n## Gestion d Etat\n\nGet a deux gestionnaires d'état différents: le gestionnaire d'état simple (nous l'appellerons GetBuilder) et le gestionnaire d'état réactif (GetX / Obx).\n\n### Gestionnaire d Etat Reactif\n\nLa programmation réactive peut aliéner de nombreuses personnes car on dit qu'elle est compliquée. GetX fait de la programmation réactive quelque chose d'assez simple:\n\n- Vous n'aurez pas besoin de créer des StreamControllers.\n- Vous n'aurez pas besoin de créer un StreamBuilder pour chaque variable\n- Vous n'aurez pas besoin de créer une classe pour chaque état.\n- Vous n'aurez pas besoin de créer un 'get' pour une valeur initiale.\n- Vous n'aurez pas besoin d'utiliser des générateurs de code\n\nLa programmation réactive avec Get est aussi simple que d'utiliser setState.\n\nImaginons que vous ayez une variable 'name' et que vous souhaitiez que chaque fois que vous la modifiez, tous les widgets qui l'utilisent soient automatiquement modifiés.\n\nVoici votre variable:\n\n```dart\nvar name = 'Jonatas Borges';\n```\n\nPour la rendre observable, il vous suffit d'ajouter \".obs\" à la fin:\n\n```dart\nvar name = 'Jonatas Borges'.obs;\n```\n\nEt dans l'interface utilisateur, lorsque vous souhaitez afficher cette valeur et mettre à jour l'écran chaque fois qu'elle change, faites simplement:\n\n```dart\nObx(() => Text(\"${controller.name}\"));\n```\n\nC'est _tout_. Si simple que ca.\n\n### Plus de details sur la gestion d Etat\n\n**Lire une explication plus approfondie de la gestion d'état [ici](./documentation/fr_FR/state_management.md). Là-bas, vous verrez plus d'exemples surtout pour la différence entre le gestionnaire d'état simple et le gestionnaire d'état réactif.**\n\nVous pourrez vous faire une meilleure idée de la puissance de GetX.\n\n## Gestion de route\n\nSi vous envisagez d'utiliser des routes/snackbars/dialogs/bottomsheets sans 'context', GetX est également excellent pour vous, voyez par vous-même:\n\nAjoutez \"Get\" avant votre MaterialApp, en le transformant en GetMaterialApp\n\n```dart\nGetMaterialApp( // Avant: MaterialApp(\n  home: MyHome(),\n)\n```\n\nAccédez à un nouvel écran:\n\n```dart\n\nGet.to(ÉcranSuivant());\n```\n\nAccédez au nouvel écran par le nom. Voir plus de détails sur les itinéraires nommés (named routes) [ici](./documentation/fr_FR/route_management.md#navigation-avec-des-itinraires-nomms)\n\n```dart\n\nGet.toNamed('/details');\n```\n\nPour fermer des snackbars, dialogs, bottomsheets, ou tout ce que vous auriez normalement fermé avec Navigator.pop(context);\n\n```dart\nGet.back();\n```\n\nPour aller à l'écran suivant avec aucune option pour revenir à l'écran précédent (pour une utilisation dans SplashScreens, écrans de connexion, etc.)\n\n```dart\nGet.off(NextScreen());\n```\n\nPour aller à l'écran suivant et annuler tous les itinéraires précédents (utile dans les paniers d'achat en ligne, les sondages et les tests)\n\n```dart\nGet.offAll(NextScreen());\n```\n\nAvez-vous remarqué que vous n'avez eu besoin d'utiliser 'context' pour aucune de ces opérations? C'est l'un des plus grands avantages de l'utilisation de la gestion de route avec Get. Avec cela, vous pouvez appeler toutes ces méthodes à partir de votre classe de contrôleur, sans soucis.\n\n### Plus de details sur la gestion de route\n\n**Get fonctionne avec des itinéraires nommés (named routes) et offre également un contrôle plus granulaire de vos routes! Il y a une documentation approfondie [ici](./documentation/fr_FR/route_management.md)**\n\n## Gestion des dependances\n\nGet a un gestionnaire de dépendances (dependency manager) simple et puissant qui vous permet de récupérer la même classe que votre Bloc ou Controller avec seulement 1 ligne de code, pas de 'context' Provider, pas d'inheritedWidget:\n\n```dart\nController controller = Get.put(Controller()); // Au lieu de Controller controller = Controller();\n```\n\n- Remarque: Si vous utilisez le gestionnaire d'état de Get, accordez plus d'attention à l'API 'Bindings', qui facilitera la connexion de vos Vues à vos contrôleurs.\n\nAu lieu d'instancier votre classe dans la classe que vous utilisez, vous l'instanciez dans l'instance Get, ce qui la rendra disponible dans toute votre application.\nVous pouvez donc utiliser votre contrôleur (ou classe Bloc) normalement.\n\n**Conseil:** La gestion des dépendances est découplée des autres parties du package, donc si, par exemple, votre application utilise déjà un gestionnaire d'état (n'importe lequel, peu importe), vous n'avez pas besoin de tout réécrire, vous pouvez l'utiliser avec l'injection de dépendance de Get sans aucun problème.\n\n```dart\ncontroller.fetchApi();\n```\n\nImaginez que vous ayez parcouru de nombreuses routes et que vous ayez besoin de données qui ont été laissées dans votre contrôleur, vous auriez besoin d'un gestionnaire d'état combiné avec le 'Provider' ou 'Get_it', n'est-ce pas? Pas avec Get. Il vous suffit de demander à Get de \"trouver\" votre contrôleur, vous n'avez pas besoin de dépendances supplémentaires:\n\n```dart\nController controller = Get.find();\n//Oui, cela ressemble à de la magie. Get trouvera votre contrôleur et vous le livrera. Vous pouvez avoir 1 million de contrôleurs instanciés, Get vous retournera toujours le bon contrôleur.\n```\n\nEt puis vous pourrez récupérer les données de votre contrôleur obtenu précédemment:\n\n```dart\nText(controller.textFromApi);\n```\n\n### Plus de details sur la gestion des dependances\n\n**Trouvez une explication plus détaillée sur la gestion des dépendances [ici](./documentation/fr_FR/dependency_management.md)**\n\n# Utils\n\n## Internationalization\n\n### Traductions\n\nLes traductions sont enregistrées sous forme de dictionaire clé-valeur simple.\nPour ajouter des traductions, créez une classe qui 'extend' `Translations`.\n\n```dart\nimport 'package:get/get.dart';\n\nclass Messages extends Translations {\n  @override\n  Map<String, Map<String, String>> get keys => {\n        'en_US': {\n          'hello': 'Hello World',\n        },\n        'de_DE': {\n          'hello': 'Hallo Welt',\n        }\n      };\n}\n```\n\n#### Utiliser les traductions\n\nAjouter juste `.tr` à la clé et elle sera traduite selon la valeur actuelle `Get.locale` et de `Get.fallbackLocale`.\n\n```dart\nText('title'.tr);\n```\n\n#### Utiliser les traductions avec le singulier et le pluriel\n\n```dart\nvar products = [];\nText('cléAuSingulier'.trPlural('cléAuPluriel', products.length, Args));\n```\n\n#### Utiliser les traductions avec paramètres\n\n```dart\nimport 'package:get/get.dart';\n\n\nMap<String, Map<String, String>> get keys => {\n    'en_US': {\n        'logged_in': 'logged in as @name with email @email',\n    },\n    'es_ES': {\n       'logged_in': 'iniciado sesión como @name con e-mail @email',\n    }\n};\n\nText('logged_in'.trParams({\n  'name': 'Jhon',\n  'email': 'jhon@example.com'\n  }));\n```\n\n### Locales\n\n'Locales' signifie lieux.\nPour definir les traductions, passer les paramètres 'locale' et 'translations' à GetMaterialApp.\n\n```dart\nreturn GetMaterialApp(\n    translations: Messages(), // Vos traductions\n    locale: Locale('en', 'US'), // Les traductions seront faites dans cette 'locale' (langue)\n    fallbackLocale: Locale('en', 'UK'), // definit le 'language de secours' au cas oú un language invalide est sélectionné.\n);\n```\n\n#### Changer la locale\n\nAppelez `Get.updateLocale (locale)` pour mettre à jour la locale. Les traductions utilisent alors automatiquement la nouvelle langue.\n\n```dart\nvar locale = Locale('en', 'US');\nGet.updateLocale(locale);\n```\n\n#### Locale du systeme\n\nPour lire les paramètres régionaux ('locales') du système, vous pouvez utiliser `Get.deviceLocale`.\n\n```dart\nreturn GetMaterialApp(\n    locale: Get.deviceLocale,\n);\n```\n\n## Changer le Theme\n\nVeuillez ne pas utiliser de widget de niveau supérieur à `GetMaterialApp` pour le mettre à jour. Cela peut créer des clés ('keys') en double. Beaucoup de gens sont habitués à l'approche préhistorique de la création d'un widget \"ThemeProvider\" juste pour changer le thème de votre application, et ce n'est certainement PAS nécessaire avec **GetX ™**.\n\nVous pouvez créer votre thème personnalisé et l'ajouter simplement dans `Get.changeTheme` sans aucune préconfiguration pour cela:\n\n```dart\nGet.changeTheme(ThemeData.light());\n```\n\nSi vous voulez créer quelque chose comme un bouton qui change le thème dans `onTap`, vous pouvez combiner deux API **GetX ™** pour cela:\n\n- L'API qui vérifie si le \"Thème\" sombre est utilisé.\n- Et l'API de changement de thème, vous pouvez simplement le mettre dans un 'onPressed':\n\n```dart\nGet.changeTheme(Get.isDarkMode? ThemeData.light(): ThemeData.dark());\n```\n\nLorsque 'onPressed' est appelé, si `.darkmode` est activé, il passera au _thème clair_, et lorsque le _thème clair_ est actif, il passera au _thème sombre_.\n\n## GetConnect\n\nGetConnect est un moyen facile de communiquer de votre backend à votre frontend avec http ou websockets.\n\n### Configuration par defaut\n\nVous pouvez simplement 'extends' GetConnect et utiliser les méthodes GET / POST / PUT / DELETE / SOCKET pour communiquer avec votre API Rest ou vos websockets.\n\n```dart\nclass UserProvider extends GetConnect {\n  // Get request\n  Future<Response> getUser(int id) => get('http://youapi/users/$id');\n  // Post request\n  Future<Response> postUser(Map data) => post('http://youapi/users', body: data);\n  // Post request with File\n  Future<Response<CasesModel>> postCases(List<int> image) {\n    final form = FormData({\n      'file': MultipartFile(image, filename: 'avatar.png'),\n      'otherFile': MultipartFile(image, filename: 'cover.png'),\n    });\n    return post('http://youapi/users/upload', form);\n  }\n\n  GetSocket userMessages() {\n    return socket('https://yourapi/users/socket');\n  }\n}\n```\n\n### Configuration personnalisee\n\nGetConnect est hautement personnalisable. Vous pouvez définir l'URL de base, comme modificateurs de réponse, comme modificateurs de requêtes, définir un authentificateur, et même le nombre de tentatives oú il tentera de s'authentifier, en plus de donner la possibilité de définir un décodeur standard qui transformera toutes vos Requêtes dans vos Modèles sans aucune configuration supplémentaire.\n\n```dart\nclass HomeProvider extends GetConnect {\n  @override\n  void onInit() {\n    // Toute 'Request' passera à jsonEncode donc CasesModel.fromJson()\n    httpClient.defaultDecoder = CasesModel.fromJson;\n    httpClient.baseUrl = 'https://api.covid19api.com';\n    // baseUrl = 'https://api.covid19api.com';\n    // Il définit baseUrl pour Http et websockets si utilisé sans instance [httpClient]\n\n    // Cela attachera la propriété 'apikey' sur l'en-tête ('header') de toutes les 'request's\n    httpClient.addRequestModifier((request) {\n      request.headers['apikey'] = '12345678';\n      return request;\n    });\n\n    // Même si le serveur envoie des données avec le pays \"Brésil\",\n    // cela ne sera jamais affiché aux utilisateurs, car vous supprimez\n    // ces données de la réponse, même avant que la réponse ne soit délivrée\n    httpClient.addResponseModifier<CasesModel>((request, response) {\n      CasesModel model = response.body;\n      if (model.countries.contains('Brazil')) {\n        model.countries.remove('Brazil');\n      }\n    });\n\n    httpClient.addAuthenticator((request) async {\n      final response = await get(\"http://yourapi/token\");\n      final token = response.body['token'];\n      // Définit l'en-tête\n      request.headers['Authorization'] = \"$token\";\n      return request;\n    });\n\n    // L'Autenticator sera appelé 3 fois si HttpStatus est HttpStatus.unauthorized\n    httpClient.maxAuthRetries = 3;\n  }\n\n\n  @override\n  Future<Response<CasesModel>> getCases(String path) => get(path);\n}\n```\n\n## Middleware GetPage\n\nGetPage a maintenant une nouvelle propriété qui prend une liste de GetMiddleWare et les exécute dans l'ordre spécifique.\n\n**Note**: Lorsque GetPage a un Middleware, tous les enfants de cette page auront automatiquement les mêmes middlewares.\n\n### Priority\n\nL'ordre des middlewares à exécuter peut être défini par la priorité dans GetMiddleware.\n\n```dart\nfinal middlewares = [\n  GetMiddleware(priority: 2),\n  GetMiddleware(priority: 5),\n  GetMiddleware(priority: 4),\n  GetMiddleware(priority: -8),\n];\n```\n\nces middlewares seront exécutés dans cet ordre **-8 => 2 => 4 => 5**\n\n### Redirect\n\n    Cette fonction sera appelée lors de la recherche de la page de l'itinéraire appelé. Elle reçoit RouteSettings comme résultat vers oú rediriger. Sinon donnez-lui la valeur null et il n'y aura pas de redirection.\n\n```dart\nRouteSettings redirect(String route) {\n  final authService = Get.find<AuthService>();\n  return authService.authed.value ? null : RouteSettings(name: '/login');\n}\n```\n\n### onPageCalled\n\nCette fonction sera appelée lorsque cette page sera appelée.\nVous pouvez l'utiliser pour changer quelque chose sur la page ou lui donner une nouvelle page.\n\n```dart\nGetPage onPageCalled(GetPage page) {\n  final authService = Get.find<AuthService>();\n  return page.copyWith(title: 'Welcome ${authService.UserName}');\n}\n```\n\n### OnBindingsStart\n\nCette fonction sera appelée juste avant l'initialisation des liaisons ('bidings').\nIci, vous pouvez modifier les liaisons de cette page.\n\n```dart\nList<Bindings> onBindingsStart(List<Bindings> bindings) {\n  final authService = Get.find<AuthService>();\n  if (authService.isAdmin) {\n    bindings.add(AdminBinding());\n  }\n  return bindings;\n}\n```\n\n### OnPageBuildStart\n\nCette fonction sera appelée juste après l'initialisation des liaisons ('bidings').\nIci, vous pouvez faire quelque chose après avoir créé les liaisons et avant de créer le widget de page.\n\n```dart\nGetPageBuilder onPageBuildStart(GetPageBuilder page) {\n  print('les liaisons sont prêtes');\n  return page;\n}\n```\n\n### OnPageBuilt\n\nCette fonction sera appelée juste après l'appel de la fonction GetPage.page et vous donnera le résultat de la fonction et prendra le widget qui sera affiché.\n\n### OnPageDispose\n\nCette fonction sera appelée juste après avoir disposé tous les objets associés (contrôleurs, vues, ...) à la page.\n\n## Autres APIs\n\n```dart\n// donne les arguments actuels de currentScreen\nGet.arguments\n\n// donne le nom de l'itinéraire précédent\nGet.previousRoute\n\n// donne la route brute d'accès par exemple, rawRoute.isFirst()\nGet.rawRoute\n\n// donne accès à l'API de routing de GetObserver\nGet.routing\n\n// vérifier si le snackbar est ouvert\nGet.isSnackbarOpen\n\n// vérifier si la boîte de dialogue est ouverte\nGet.isDialogOpen\n\n// vérifie si la bottomSheet est ouverte\nGet.isBottomSheetOpen\n\n// supprime une route.\nGet.removeRoute()\n\n// retourne à plusieurs reprises jusqu'à ce que le prédicat retourne 'true'.\nGet.until()\n\n// passe à la route suivante et supprime toutes les routes précédentes jusqu'à ce que le prédicat retourne 'true'.\nGet.offUntil()\n\n// passe à la route nommée suivante et supprime toutes les routes précédentes jusqu'à ce que le prédicat retourne 'true'.\nGet.offNamedUntil()\n\n// Vérifie sur quelle plate-forme l'application s'exécute\nGetPlatform.isAndroid\nGetPlatform.isIOS\nGetPlatform.isMacOS\nGetPlatform.isWindows\nGetPlatform.isLinux\nGetPlatform.isFuchsia\n\n// Vérifie le type d'appareil\nGetPlatform.isMobile\nGetPlatform.isDesktop\n// Toutes les plates-formes sont prises en charge indépendamment, dans le Web!\n// Vous pouvez dire si vous utilisez un navigateur\n// sur Windows, iOS, OSX, Android, etc.\nGetPlatform.isWeb\n\n\n// Équivaut à: MediaQuery.of(context).size.height,\n// mais immuable.\nGet.height\nGet.width\n\n// Donne le 'context' actuel de 'Navigator'.\nGet.context\n\n// Donne le contexte du snackbar / dialogue / bottomsheet au premier plan, n'importe où dans votre code.\nGet.contextOverlay\n\n// Remarque: les méthodes suivantes sont des extensions sur le 'context'. Puisque vous\n// avez accès au contexte à n'importe quel endroit de votre interface utilisateur, vous pouvez l'utiliser n'importe où dans le code de l'interface utilisateur\n\n// Si vous avez besoin d'une hauteur / largeur variable (comme les fenêtres de bureau ou de navigateur qui peuvent être mises à l'échelle), vous devrez utiliser le contexte.\ncontext.width\ncontext.height\n\n// Vous donne le pouvoir de définir la moitié de l'écran, un tiers de celui-ci et ainsi de suite.\n// Utile pour les applications responsives.\n// paramètre dividedBy (double) optionnel - par défaut: 1\n// paramètre reducedBy (double) facultatif - par défaut: 0\ncontext.heightTransformer ()\ncontext.widthTransformer ()\n\n/// Similaire à MediaQuery.of(context).size\ncontext.mediaQuerySize()\n\n/// Similaire à MediaQuery.of(context).padding\ncontext.mediaQueryPadding()\n\n/// Similaire à MediaQuery.of(context).viewPadding\ncontext.mediaQueryViewPadding()\n\n/// Similaire à MediaQuery.of(context).viewInsets;\ncontext.mediaQueryViewInsets()\n\n/// Similaire à MediaQuery.of(context).orientation;\ncontext.orientation()\n\n/// Vérifie si l'appareil est en mode paysage\ncontext.isLandscape()\n\n/// Vérifie si l'appareil est en mode portrait\ncontext.isPortrait()\n\n/// Similaire à MediaQuery.of(context).devicePixelRatio;\ncontext.devicePixelRatio()\n\n/// Similaire à MediaQuery.of(context).textScaleFactor;\ncontext.textScaleFactor()\n\n/// Obtenir le côté le plus court de l'écran\ncontext.mediaQueryShortestSide()\n\n/// Vrai si la largeur est supérieure à 800p\ncontext.showNavbar()\n\n/// Vrai si le côté le plus court est inférieur à 600p\ncontext.isPhone()\n\n/// Vrai si le côté le plus court est plus grand que 600p\ncontext.isSmallTablet()\n\n/// Vrai si le côté le plus court est plus grand que 720p\ncontext.isLargeTablet()\n\n/// Vrai si l'appareil actuel est une tablette\ncontext.isTablet()\n\n/// Renvoie une valeur <T> en fonction de la taille de l'écran\n/// peut donner une valeur pour:\n/// watch: si le côté le plus court est inférieur à 300\n/// mobile: si le côté le plus court est inférieur à 600\n/// tablette: si le côté le plus court est inférieur à 1200\n/// bureautique: si la largeur est supérieure à 1200\ncontext.responsiveValue<T>()\n```\n\n### Parametres globaux et configurations manuelles facultatifs\n\nGetMaterialApp configure tout pour vous, mais si vous souhaitez configurer Get manuellement:\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver()],\n);\n```\n\nVous pourrez également utiliser votre propre middleware dans `GetObserver`, cela n'influencera rien.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [\n    GetObserver(MiddleWare.observer) // Ici\n  ],\n);\n```\n\nVous pouvez créer _Global Settings_ pour `Get`. Ajoutez simplement `Get.config` à votre code avant de changer de route.\nOu faites-le directement dans votre `GetMaterialApp`\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  defaultTransition: Transition.fade,\n  opaqueRoute: Get.isOpaqueRouteDefault,\n  popGesture: Get.isPopGestureEnable,\n  transitionDuration: Get.defaultDurationTransition,\n  defaultGlobalState: Get.defaultGlobalState,\n);\n\nGet.config(\n  enableLog = true,\n  defaultPopGesture = true,\n  defaultTransition = Transitions.cupertino\n)\n```\n\nVous pouvez éventuellement rediriger tous les messages de journalisation (logging) de `Get`.\nSi vous souhaitez utiliser votre propre package de journalisation préféré,\net souhaitez capturer les logs là-bas:\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  logWriterCallback: localLogWriter,\n);\n\nvoid localLogWriter(String text, {bool isError = false}) {\n  // transmettez le message à votre package de journalisation préféré ici\n  // veuillez noter que même si enableLog: false, les messages du journal seront poussés dans ce 'callback'\n  // vérifiez le 'flag' si vous le souhaitez via GetConfig.isLogEnable\n}\n\n```\n\n### State Widgets Locaux\n\nCes Widgets vous permettent de gérer une valeur unique, et de garder l'état éphémère et localement.\nNous avons des saveurs pour réactif et simple.\nPar exemple, vous pouvez les utiliser pour basculer obscureText dans un `TextField`, peut-être créer un\nPanneau extensible, ou peut-être modifier l'index actuel dans `BottomNavigationBar` tout en modifiant le contenu\nde 'body' dans un `Scaffold`.\n\n#### ValueBuilder\n\nUne simplification de `StatefulWidget` qui fonctionne avec un callback `.setState` qui prend la valeur mise à jour.\n\n```dart\nValueBuilder<bool>(\n  initialValue: false,\n  builder: (value, updateFn) => Switch(\n    value: value,\n    onChanged: updateFn, // même signature! vous pouvez utiliser (newValue) => updateFn (newValue)\n  ),\n  // si vous devez appeler quelque chose en dehors de la méthode du builder.\n  onUpdate: (value) => print(\"Valeur mise à jour: $value\"),\n  onDispose: () => print(\"Widget détruit\"),\n),\n```\n\n#### ObxValue\n\nSimilaire à [`ValueBuilder`](#valuebuilder), mais c'est la version Reactive, vous passez une instance Rx (rappelez-vous les .obs magiques?) et il\nse met à jour automatiquement ... n'est-ce pas génial?\n\n```dart\nObxValue((data) => Switch(\n        value: data.value,\n        onChanged: data, // Rx a une fonction _callable_! Vous pouvez utiliser (flag) => data.value = flag,\n    ),\n    false.obs,\n),\n```\n\n## Conseils utiles\n\n`.obs`ervables (également appelés types _Rx_) ont une grande variété de méthodes et d'opérateurs internes.\n\n> Il est très courant de croire qu'une propriété avec `.obs` ** EST ** la valeur réelle ... mais ne vous y trompez pas!\n> Nous évitons la déclaration Type de la variable, car le compilateur de Dart est assez intelligent, et le code\n> semble plus propre, mais:\n\n```dart\nvar message = 'Hello world'.obs;\nprint( 'Message \"$message\" est de Type ${message.runtimeType}');\n```\n\nBien que `message` _prints_ la vraie valeur du String, le Type est **RxString**!\n\nDonc, vous ne pouvez pas faire `message.substring( 0, 4 )`.\nVous devez utiliser la vraie `valeur` dans _observable_:\nLa façon \"la plus utilisée\" est `.value`, mais, que vous pouviez aussi...\n\n```dart\nfinal name = 'GetX'.obs;\n// \"met à jour\" le flux, uniquement si la valeur est différente de la valeur actuelle.\nname.value = 'Hey';\n\n// Toutes les propriétés Rx sont \"appelables\" et renvoie la nouvelle valeur.\n// mais cette approche n'accepte pas `null`, l'interface utilisateur ne sera pas reconstruite.\nname('Hello');\n\n// est comme un getter, affiche `Hello`.\nname() ;\n\n/// nombres:\n\nfinal count = 0.obs;\n\n// Vous pouvez utiliser toutes les opérations non mutables à partir de num primitives!\ncount + 1;\n\n// Fais attention! ceci n'est valable que si `count` n'est pas final, mais var\ncount += 1;\n\n// Vous pouvez également comparer avec des valeurs:\ncount > 2;\n\n/// booleans:\n\nfinal flag = false.obs;\n\n// bascule la valeur entre true / false\nflag.toggle();\n\n\n/// tous les types:\n\n// Définit la `valeur` sur null.\nflag.nil();\n\n// Toutes les opérations toString (), toJson () sont transmises à la `valeur`\nprint( count ); // appelle `toString ()` à l'intérieur de RxInt\n\nfinal abc = [0,1,2].obs;\n// Convertit la valeur en un Array json, affiche RxList\n// Json est pris en charge par tous les types Rx!\nprint('json: ${jsonEncode(abc)}, type: ${abc.runtimeType}');\n\n// RxMap, RxList et RxSet sont des types Rx spéciaux, qui étendent leurs types natifs.\n// mais vous pouvez travailler avec une liste comme une liste régulière, bien qu'elle soit réactive!\nabc.add(12); // pousse 12 dans la liste et MET À JOUR le flux.\nabc[3]; // comme Lists, lit l'index 3.\n\n\n// l'égalité fonctionne avec le Rx et la valeur, mais hashCode est toujours pris à partir de la valeur\nfinal number = 12.obs;\nprint( number == 12 ); // retource > true\n\n/// Modèles Rx personnalisés:\n\n// toJson (), toString () sont différés à l'enfant, vous pouvez donc implémenter 'override' sur eux, et print() l'observable directement.\n\nclass User {\n    String name, last;\n    int age;\n    User({this.name, this.last, this.age});\n\n    @override\n    String toString() => '$name $last, $age ans';\n}\n\nfinal user = User(name: 'John', last: 'Doe', age: 33).obs;\n\n// `user` est\" réactif \", mais les propriétés à l'intérieur NE SONT PAS!\n// Donc, si nous changeons une variable à l'intérieur ...\nuser.value.name = 'Roi';\n// Le widget ne se reconstruira pas !,\n// `Rx` n'a aucun indice lorsque vous changez quelque chose à l'intérieur de l'utilisateur.\n// Donc, pour les classes personnalisées, nous devons \"notifier\" manuellement le changement.\nuser.refresh();\n\n// ou utiliser `update()`!\nuser.update((value){\n  value.name='Roi';\n});\n\nprint( user );\n```\n\n#### GetView\n\nJ'adore ce widget. Si simple, mais si utile!\n\nC'est un widget `const Stateless` qui a un getter` controller` pour un `Controller` enregistré, c'est tout.\n\n```dart\n class AwesomeController extends GetxController {\n   final String title = 'My Awesome View';\n }\n\n  // N'oubliez PAS de passer le `Type` que vous avez utilisé pour enregistrer votre contrôleur!\n class AwesomeView extends GetView<AwesomeController> {\n   @override\n   Widget build(BuildContext context) {\n     return Container(\n       padding: EdgeInsets.all(20),\n       child: Text(controller.title), // appelez `controller.quelqueChose`\n     );\n   }\n }\n```\n\n#### GetResponsiveView\n\nÉtendez ce widget pour créer une vue réactive.\nce widget contient la propriété `screen` qui a toutes les\ninformations sur la taille et le type de l'écran.\n\n##### Guide d utilisation\n\nVous avez deux options pour le créer:\n\n- avec la méthode `builder` vous renvoyez le widget à construire.\n- avec les méthodes `desktop`,` tablet`, `phone`,` watch`. la méthode spécifique sera exécutée lorsque le type d'écran correspond à la méthode.\n  Lorsque l'écran est [ScreenType.Tablet], la méthode `tablet` sera exécutée et ainsi de suite.\n  **Note:** Si vous utilisez cette méthode, veuillez définir la propriété `alwaysUseBuilder` à `false`\n\nAvec la propriété `settings`, vous pouvez définir la limite de largeur pour les types d'écran.\n\n![exemple](https://github.com/SchabanBo/get_page_example/blob/master/docs/Example.gif?raw=true)\nCode pour cet écran\n[code](https://github.com/SchabanBo/get_page_example/blob/master/lib/pages/responsive_example/responsive_view.dart)\n\n#### GetWidget\n\nLa plupart des gens n'ont aucune idée de ce widget ou confondent totalement son utilisation.\nLe cas d'utilisation est très rare, mais très spécifique: il `met en cache` un contrôleur.\nEn raison du _cache_, ne peut pas être un `const Stateless`.\n\n> Alors, quand avez-vous besoin de \"mettre en cache\" un contrôleur?\n\nSi vous utilisez, une autre fonctionnalité \"pas si courante\" de **GetX**: `Get.create()`.\n\n`Get.create(()=>Controller())` générera un nouveau `Controller` chaque fois que vous appelez\n`Get.find<Controller>()`.\n\nC'est là que `GetWidget` brille ... comme vous pouvez l'utiliser, par exemple,\npour conserver une liste de <Todo>s. Donc, si le widget est \"reconstruit\", il conservera la même instance de contrôleur.\n\n#### GetxService\n\nCette classe est comme un `GetxController`, elle partage le même cycle de vie ( `onInit()`, `onReady()`, `onClose()`), mais n'a pas de \"logique\" en elle.\nIl notifie simplement le **GetX** Dependency Injection system, que cette sous-classe\n**ne peut pas** être supprimé de la mémoire.\n\nDonc est très utile pour garder vos \"Services\" toujours à portée de main et actifs avec `Get.find()`. Comme:\n`ServiceAPI`, `ServiceDeSauvegarde`, `ServiceDeCaching`.\n\n```dart\nFuture<void> main() async {\n  await initServices(); /// Attend l'initialisation des services.\n  runApp(SomeApp());\n}\n\n/// Est une démarche intelligente pour que vos services s'initialisent avant d'exécuter l'application Flutter.\n/// car vous pouvez contrôler le flux d'exécution (peut-être devez-vous charger une configuration de thème,\n/// apiKey, langue définie par l'utilisateur ... donc chargez SettingService avant d'exécuter ApiService.\n/// donc GetMaterialApp () n'a pas besoin de se reconstruire et prend les valeurs directement.\nvoid initServices() async {\n  print('starting services ...');\n  /// C'est ici que vous mettez get_storage, hive, shared_pref initialization.\n  /// ou les connexions moor, ou autres choses async.\n  await Get.putAsync(() => DbService().init());\n  await Get.putAsync(SettingsService()).init();\n  print('Tous les services ont démarré...');\n}\n\nclass DbService extends GetxService {\n  Future<DbService> init() async {\n    print('$runtimeType retarde de 2 sec');\n    await 2.delay();\n    print('$runtimeType prêts!');\n    return this;\n  }\n}\n\nclass SettingsService extends GetxService {\n  void init() async {\n    print(\"$runtimeType retarde d'1 sec\");\n    await 1.delay();\n    print('$runtimeType prêts!');\n  }\n}\n\n```\n\nLa seule façon de supprimer réellement un `GetxService`, est d'utiliser`Get.reset ()`qui est comme un\n\"Hot Reboot\" de votre application. N'oubliez donc pas que si vous avez besoin d'une persistance absolue d'une instance de classe\ndurée de vie de votre application, utilisez `GetxService`.\n\n# Changements par rapport a 2.0\n\n1- Types Rx:\n\n| Avant   | Après      |\n| ------- | ---------- |\n| StringX | `RxString` |\n| IntX    | `RxInt`    |\n| MapX    | `RxMap`    |\n| ListX   | `RxList`   |\n| NumX    | `RxNum`    |\n| DoubleX | `RxDouble` |\n\nRxController et GetBuilder ont maintenant fusionné, vous n'avez plus besoin de mémoriser le contrôleur que vous souhaitez utiliser, utilisez simplement GetxController, cela fonctionnera pour une gestion simple de l'état et également pour la réactivité.\n\n2- NamedRoutes\n\nAvant:\n\n```dart\nGetMaterialApp(\n  namedRoutes: {\n    '/': GetRoute(page: Home()),\n  }\n)\n```\n\nMaintenant:\n\n```dart\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page: () => Home()),\n  ]\n)\n```\n\nPourquoi ce changement?\nSouvent, il peut être nécessaire de décider quelle page sera affichée à partir d'un paramètre, ou d'un 'login token', l'approche précédente était inflexible, car elle ne le permettait pas.\nL'insertion de la page dans une fonction a considérablement réduit la consommation de RAM, puisque les routes ne seront pas allouées en mémoire depuis le démarrage de l'application, et cela a également permis de faire ce type d'approche:\n\n```dart\n\nGetStorage box = GetStorage();\n\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page:(){\n      return box.hasData('token') ? Home() : Login();\n    })\n  ]\n)\n```\n\n# Pourquoi Getx?\n\n1- Plusieurs fois après une mise à jour de Flutter, plusieurs de vos packages seront invalides. Parfois, des erreurs de compilation se produisent, des erreurs apparaissent souvent pour lesquelles il n'y a toujours pas de réponses, et le développeur doit savoir d'où vient l'erreur, suivre l'erreur, puis seulement essayer d'ouvrir un problème dans le référentiel correspondant et voir son problème résolu. Get centralise les principales ressources pour le développement (gestion des états, des dépendances et des routes), vous permettant d'ajouter un package unique à votre pubspec et de commencer à travailler. Après une mise à jour Flutter, la seule chose à faire est de mettre à jour la dépendance Get et de vous mettre au travail. Get résout également les problèmes de compatibilité. Combien de fois une version d'un package n'est pas compatible avec la version d'un autre, parce que l'une utilise une dépendance dans une version et l'autre dans une autre version? Ce n'est pas non plus un problème avec Get, car tout est dans le même package et est entièrement compatible.\n\n2- Flutter est facile, Flutter est incroyable, mais Flutter a encore quelques règles standard qui peuvent être indésirables pour la plupart des développeurs, comme `Navigator.of (context) .push (context, builder [...]`. Get simplifie le développement. Au lieu de écrire 8 lignes de code pour simplement appeler une route, vous pouvez simplement le faire: `Get.to (Home ())` et vous avez terminé, vous passerez à la page suivante. Les URL Web dynamiques sont une chose vraiment pénible à voir avec Flutter actuellement, et cela avec GetX est stupidement simple. La gestion des états dans Flutter et la gestion des dépendances sont également quelque chose qui génère beaucoup de discussions, car il y a des centaines de modèles dans la pub. Mais rien n'est aussi simple que d'ajouter un \".obs\" à la fin de votre variable, et placez votre widget dans un Obx, et c'est tout, toutes les mises à jour de cette variable seront automatiquement mises à jour à l'écran.\n\n3- Facilité sans vous soucier des performances. Les performances de Flutter sont déjà étonnantes, mais imaginez que vous utilisez un gestionnaire d'état et un localisateur pour distribuer vos classes blocs / stores / contrôleurs / etc. Vous devrez appeler manuellement l'exclusion de cette dépendance lorsque vous n'en avez pas besoin. Mais avez-vous déjà pensé à simplement utiliser votre «contrôleur`, et quand il n'était plus utilisé par personne, il serait simplement supprimé de la mémoire? C'est ce que fait GetX. Avec SmartManagement, tout ce qui n'est pas utilisé est supprimé de la mémoire et vous ne devriez pas avoir à vous soucier d'autre chose que de la programmation. Vous serez assuré de consommer le minimum de ressources nécessaires, sans même avoir créé de logique pour cela.\n\n4- Découplage réel. Vous avez peut-être entendu le concept \"séparer la vue de la business logic\". Ce n'est pas une particularité de BLoC, MVC, MVVM, et tout autre standard sur le marché a ce concept. Cependant, ce concept peut souvent être atténué dans Flutter en raison de l'utilisation de `context`.\nSi vous avez besoin de contexte pour trouver un InheritedWidget, vous en avez besoin dans la vue, ou passez le `context` par paramètre. Je trouve particulièrement cette solution très moche, et pour travailler en équipe, nous serons toujours dépendants de la 'business logic' de View. Getx n'est pas orthodoxe avec l'approche standard, et même s'il n'interdit pas complètement l'utilisation de StatefulWidgets, InitState, etc., il a toujours une approche similaire qui peut être plus propre. Les contrôleurs ont des cycles de vie, et lorsque vous devez faire une requête APIREST par exemple, vous ne dépendez de rien de la vue. Vous pouvez utiliser onInit pour lancer l'appel http et lorsque les données arrivent, les variables sont remplies. Comme GetX est totalement réactif (vraiment, et fonctionne sous streams), une fois les éléments remplis, tous les widgets qui utilisent cette variable seront automatiquement mis à jour dans la vue.\nCela permet aux personnes ayant une expertise de l'interface utilisateur de travailler uniquement avec des widgets et de ne pas avoir à envoyer quoi que ce soit à la business logic autre que des événements utilisateur (comme cliquer sur un bouton), tandis que les personnes travaillant avec la business logic seront libres de créer et de tester la Business logic séparément.\n\n# Communite\n\n## Chaines communautaires\n\nGetX a une communauté très active et utile. Si vous avez des questions, ou souhaitez obtenir de l'aide concernant l'utilisation de ce framework, veuillez rejoindre nos canaux communautaires, votre question sera répondue plus rapidement, et ce sera l'endroit le plus approprié. Ce référentiel est exclusif pour l'ouverture des issues Github et la demande de ressources, mais n'hésitez pas à faire partie de la communauté GetX.\n| **Slack** | **Discord** | **Telegram** |\n| :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |\n| [![Get sur Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx) | [![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N) | [![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g) |\n\n## Comment contribuer\n\n_Voulez-vous contribuer au projet? Nous serons fiers de vous mettre en avant comme l'un de nos collaborateurs. Voici quelques points sur lesquels vous pouvez contribuer et améliorer encore Get (et Flutter)._\n\n- Aider à traduire les 'Readme's dans d'autres langues.\n- Ajout de documentation au readme (beaucoup de fonctions de Get n'ont pas encore été documentées).\n- Rédiger des articles ou réaliser des vidéos pour apprendre à utiliser Get (ils seront insérés dans le Readme et à l'avenir dans notre Wiki).\n- Offrir des PRs pour code / tests.\n- Ajouter de nouvelles fonctions.\n\nToute contribution est bienvenue!\n\n## Articles et videos\n\n- [Dynamic Themes in 3 lines using GetX™](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Tutorial by [Rod Brown](https://github.com/RodBr).\n- [Complete GetX™ Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI) - Route management video by Amateur Coder.\n- [Complete GetX State Management](https://www.youtube.com/watch?v=CNpXbeI_slw) - State management video by Amateur Coder.\n- [GetX™ Other Features](https://youtu.be/ttQtlX_Q0eU) - Utils, storage, bindings and other features video by Amateur Coder.\n- [Firestore User with GetX | Todo App](https://www.youtube.com/watch?v=BiV0DcXgk58) - Video by Amateur Coder.\n- [Firebase Auth with GetX | Todo App](https://www.youtube.com/watch?v=-H-T_BSgfOE) - Video by Amateur Coder.\n- [The Flutter GetX™ Ecosystem ~ State Management](https://medium.com/flutter-community/the-flutter-getx-ecosystem-state-management-881c7235511d) - State management by [Aachman Garg](https://github.com/imaachman).\n- [The Flutter GetX™ Ecosystem ~ Dependency Injection](https://medium.com/flutter-community/the-flutter-getx-ecosystem-dependency-injection-8e763d0ec6b9) - Dependency Injection by [Aachman Garg](https://github.com/imaachman).\n- [GetX, the all-in-one Flutter package](https://www.youtube.com/watch?v=IYQgtu9TM74) - A brief tutorial covering State Management and Navigation by Thad Carnevalli.\n- [Build a To-do List App from scratch using Flutter and GetX](https://www.youtube.com/watch?v=EcnqFasHf18) - UI + State Management + Storage video by Thad Carnevalli.\n- [GetX Flutter Firebase Auth Example](https://medium.com/@jeffmcmorris/getx-flutter-firebase-auth-example-b383c1dd1de2) - Article by Jeff McMorris.\n- [Flutter State Management with GetX – Complete App](https://www.appwithflutter.com/flutter-state-management-with-getx/) - by App With Flutter.\n- [Flutter Routing with Animation using Get Package](https://www.appwithflutter.com/flutter-routing-using-get-package/) - by App With Flutter.\n"
        },
        {
          "name": "README-hi.md",
          "type": "blob",
          "size": 28.3984375,
          "content": "\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n[![pub  package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n\n[![popularity](https://badges.bar/get/popularity)](https://pub.dev/packages/sentry/score)\n\n[![likes](https://badges.bar/get/likes)](https://pub.dev/packages/get/score)\n\n[![pub  points](https://badges.bar/get/pub%20points)](https://pub.dev/packages/get/score)\n\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n\n[![style:  effective  dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n\n[![Discord  Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n\n[![Get  on  Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n\n<a href=\"https://github.com/Solido/awesome-flutter\">\n\n<img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n\n</a>\n\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n<div align=\"center\">\n\n**Languages:**\n\n[![English](https://img.shields.io/badge/Language-English-blueviolet?style=for-the-badge)](README.md)\n\n[![Vietnamese](https://img.shields.io/badge/Language-Vietnamese-blueviolet?style=for-the-badge)](README-vi.md)\n\n[![Indonesian](https://img.shields.io/badge/Language-Indonesian-blueviolet?style=for-the-badge)](README.id-ID.md)\n\n[![Urdu](https://img.shields.io/badge/Language-Urdu-blueviolet?style=for-the-badge)](README.ur-PK.md)\n\n[![Chinese](https://img.shields.io/badge/Language-Chinese-blueviolet?style=for-the-badge)](README.zh-cn.md)\n\n[![Portuguese](https://img.shields.io/badge/Language-Portuguese-blueviolet?style=for-the-badge)](README.pt-br.md)\n\n[![Spanish](https://img.shields.io/badge/Language-Spanish-blueviolet?style=for-the-badge)](README-es.md)\n\n[![Russian](https://img.shields.io/badge/Language-Russian-blueviolet?style=for-the-badge)](README.ru.md)\n\n[![Polish](https://img.shields.io/badge/Language-Polish-blueviolet?style=for-the-badge)](README.pl.md)\n\n[![Korean](https://img.shields.io/badge/Language-Korean-blueviolet?style=for-the-badge)](README.ko-kr.md)\n\n[![French](https://img.shields.io/badge/Language-French-blueviolet?style=for-the-badge)](README-fr.md)\n\n[![Japanese](https://img.shields.io/badge/Language-Japanese-blueviolet?style=for-the-badge)](README.ja-JP.md)\n\n[![Turkish](https://img.shields.io/badge/Language-Turkish-blueviolet?style=for-the-badge)](README.tr-TR.md)\n\n[![Hindi](https://img.shields.io/badge/Language-Hindi-blueviolet?style=for-the-badge)](README-hi.md)\n\n</div>\n\n- [Get के बारे में](#about-get)\n\n- [इंस्टॉलिंग](#installing)\n\n- [Get के साथ काउंटर ऐप](#counter-app-with-getx)\n\n- [तीन सिद्धांत](#the-three-pillars)\n\n  - [स्टेट मैनेजमेंट](#state-management)\n\n    - [रिएक्टिव स्टेट मैनेजर ](#reactive-state-manager)\n\n    - [स्टेट मैनेजमेंट के बारे में और जाने](#more-details-about-state-management)\n\n  - [रूट मैनेजमेंट ](#route-management)\n\n    - [रूट मैनेजमेंट के बारे में और जाने](#more-details-about-route-management)\n\n  - [डिपेंडेंसी मैनेजमेंट](#dependency-management)\n\n    - [डिपेंडेंसी मैनेजमेंट के बारे में और जाने](#more-details-about-dependency-management)\n\n- [मदद करने वाले फीचर्स](#utils)\n\n  - [इंटरनॅशनलिनाइज़ेशन](#internationalization)\n\n    - [अनुवाद](#translations)\n\n      - [अनुवादों का उपयोग करना](#using-translations)\n\n    - [क्षेत्र के अनुसार पसंद](#locales)\n\n      - [लोकेल बदलें](#change-locale)\n\n      - [सिस्टम लोकेलस ](#system-locale)\n\n  - [थीम बदलें](#change-theme)\n\n  - [GetConnect](#getconnect)\n\n    - [डिफ़ॉल्ट कॉन्फ़िगरेशन ](#default-configuration)\n\n    - [कस्टम कॉन्फ़िगरेशन](#custom-configuration)\n\n  - [GetPage Middleware](#getpage-middleware)\n\n    - [वरीयता](#priority)\n\n    - [रीडायरेक्ट](#redirect)\n\n    - [पेज कॉल होने पर](#onpagecalled)\n\n    - [बाइंडिंग शुरू होने पर](#onbindingsstart)\n\n    - [पेज बिल्ड स्टार्ट पर](#onpagebuildstart)\n\n    - [पेज पूरा बन ने पर](#onpagebuilt)\n\n    - [पेज डिस्पोसे होने पर](#onpagedispose)\n\n  - [अन्य उन्नत एपीआई](#other-advanced-apis)\n\n    - [वैकल्पिक वैश्विक सेटिंग्स और मैन्युअल कॉन्फ़िगरेशन](#optional-global-settings-and-manual-configurations)\n\n    - [लोकल स्टेट विद्गेट्स ](#local-state-widgets)\n\n      - [वैल्यू बिल्डर](#valuebuilder)\n\n      - [ObxValue](#obxvalue)\n\n  - [उपयोगी सलाह](#useful-tips)\n\n    - [GetView](#getview)\n\n    - [GetResponsiveView](#getresponsiveview)\n\n      - [इसका उपयोग कैसे करना है](#how-to-use-it)\n\n    - [GetWidget](#getwidget)\n\n    - [GetxService](#getxservice)\n\n- [2.0 से बड़े बदलाव](#breaking-changes-from-20)\n\n- [क्यों GetX?](#why-getx)\n\n- [समुदाय](#community)\n\n  - [सामुदायिक चैनल](#community-channels)\n\n  - [कैसे योगदान करें](#how-to-contribute)\n\n  - [लेख और वीडियो](#articles-and-videos)\n\n# Get के बारे में\n\n- GetX, Flutter के लिए एक अतिरिक्त हल्का और शक्तिशाली समाधान है। यह स्टेट मैनेजमेंट, डिपेंडेंसी इंजेक्शन और नेविगेशन  को जल्दी और व्यावहारिक रूप से जोड़ता है।\n\n- GetX के 3 बुनियादी सिद्धांत हैं। इसका मतलब है कि पुस्तकालय में सभी संसाधनों के लिए ये प्राथमिकताएं हैं: **उत्पादकता, प्रदर्शन और संगठन।**\n\n  - **प्रदर्शन**: GetX प्रदर्शन और संसाधनों की न्यूनतम खपत पर केंद्रित है। GetX स्ट्रीम या चेंज नोटिफ़ायर का उपयोग नहीं करता है।\n\n  - **उत्पादकता**: GetX एक आसान और सुखद सिंटैक्स का उपयोग करता है। कोई फर्क नहीं पड़ता कि आप क्या करना चाहते हैं, GetX के साथ हमेशा एक आसान तरीका होता है। यह विकास के घंटों को बचाएगा और अधिकतम प्रदर्शन प्रदान करेगा जो आपका एप्लिकेशन प्रदान कर सकता है।\n\n    आम तौर पर, डेवलपर को स्मृति से नियंत्रकों को हटाने के बारे में चिंतित होना चाहिए। GetX के साथ यह आवश्यक नहीं है क्योंकि संसाधनों को स्मृति से हटा दिया जाता है जब वे डिफ़ॉल्ट रूप से उपयोग नहीं किए जाते हैं। यदि आप इसे स्मृति में रखना चाहते हैं, तो आपको अपनी निर्भरता में स्पष्ट रूप से **\"permanent: true\"** घोषित करना होगा। इस तरह, समय बचाने के अलावा, आपको स्मृति पर अनावश्यक निर्भरता होने का जोखिम कम होता है। डिपेंडेंसी लोडिंग भी डिफ़ॉल्ट रूप से आलसी है।\n\n  - **संगठन**: गेटएक्स व्यू, प्रेजेंटेशन लॉजिक, बिजनेस लॉजिक, डिपेंडेंसी इंजेक्शन और नेविगेशन को पूरी तरह से अलग करने की अनुमति देता है। आपको मार्गों के बीच नेविगेट करने के लिए संदर्भ की आवश्यकता नहीं है, इसलिए आप इसके लिए विजेट ट्री (विज़ुअलाइज़ेशन) पर निर्भर नहीं हैं। आपको विरासत में मिले विजेट के माध्यम से अपने नियंत्रकों/ब्लॉकों तक पहुँचने के लिए संदर्भ की आवश्यकता नहीं है, इसलिए आप अपने प्रस्तुति तर्क और व्यावसायिक तर्क को अपनी विज़ुअलाइज़ेशन परत से पूरी तरह से अलग कर सकते हैं। आपको मल्टीप्रोवाइडर्स के माध्यम से अपने विजेट ट्री में अपने कंट्रोलर/मॉडल/ब्लॉक क्लास को इंजेक्ट करने की आवश्यकता नहीं है। इसके लिए, GetX अपने स्वयं के निर्भरता इंजेक्शन सुविधा का उपयोग करता है, DI को अपने दृष्टिकोण से पूरी तरह से अलग करता है।\n\n    **GetX** के साथ आप जानते हैं कि डिफ़ॉल्ट रूप से क्लीन कोड वाले अपने एप्लिकेशन की प्रत्येक सुविधा को कहां खोजना है। रखरखाव को आसान बनाने के अलावा, यह मॉड्यूल के साझाकरण को कुछ ऐसा बनाता है जो तब तक फ़्लटर में अकल्पनीय था, कुछ पूरी तरह से संभव था।\n\n    **BLoC** फ़्लटर में कोड व्यवस्थित करने के लिए एक प्रारंभिक बिंदु था, यह व्यावसायिक तर्क को विज़ुअलाइज़ेशन से अलग करता है। GetX इसका एक स्वाभाविक विकास है, न केवल व्यावसायिक तर्क बल्कि प्रस्तुति तर्क को अलग करना। निर्भरता और मार्गों के बोनस इंजेक्शन को भी अलग कर दिया गया है, और डेटा स्तर इससे बाहर है। आप जानते हैं कि सब कुछ कहाँ है, और यह सब एक हैलो वर्ल्ड बनाने की तुलना में आसान तरीके से है।\n\n    Flutter SDK के साथ उच्च-प्रदर्शन अनुप्रयोगों के निर्माण के लिए गेटएक्स सबसे आसान, व्यावहारिक और स्केलेबल तरीका है। इसके चारों ओर एक बड़ा पारिस्थितिकी तंत्र है जो पूरी तरह से एक साथ काम करता है, यह शुरुआती लोगों के लिए आसान है, और यह विशेषज्ञों के लिए सटीक है। यह सुरक्षित, स्थिर, अप-टू-डेट है, और अंतर्निहित एपीआई की एक विशाल श्रृंखला प्रदान करता है जो डिफ़ॉल्ट फ़्लटर एसडीके में मौजूद नहीं हैं।\n\n- **GetX** फूला हुआ नहीं है। इसमें कई विशेषताएं हैं जो आपको बिना किसी चिंता के प्रोग्रामिंग शुरू करने की अनुमति देती हैं, लेकिन इनमें से प्रत्येक सुविधा अलग-अलग कंटेनरों में होती है और केवल उपयोग के बाद ही शुरू होती है। यदि आप केवल राज्य प्रबंधन का उपयोग करते हैं, तो केवल राज्य प्रबंधन संकलित किया जाएगा। यदि आप केवल मार्गों का उपयोग करते हैं, तो राज्य प्रबंधन से कुछ भी संकलित नहीं किया जाएगा।\n\n- GetX में एक विशाल पारिस्थितिकी तंत्र, एक बड़ा समुदाय, बड़ी संख्या में सहयोगी हैं, और जब तक फ़्लटर मौजूद है, तब तक इसे बनाए रखा जाएगा। GetX भी **Android, iOS, Web, Mac, Linux, Windows** और आपके Server पर समान Code के साथ चलने में सक्षम है।\n\n  **आपके Backend पर Frontend पर बने आपके कोड का पूरी तरह से पुन: उपयोग करना संभव है  [Get  Server](https://github.com/jonataslaw/get_server)**.\n\n**इसके अलावा, संपूर्ण विकास प्रक्रिया पूरी तरह से स्वचालित हो सकती है, दोनों सर्वर पर और फ्रंट एंड पर  [Get  CLI](https://github.com/jonataslaw/get_cli)**.\n\n**इसके अलावा, आपकी उत्पादकता को और बढ़ाने के लिए, हमारे पास है\n\n**[VSCODE के लिए एक्सटेंशन](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets)  and  the  [Android Studio और Intellij के लिए एक्सटेंशन](https://plugins.jetbrains.com/plugin/14975-getx-snippets)**\n\n# इंस्टॉलिंग\n\nअपनी ```pubspec.yaml``` फ़ाइल में Get को ऐड करे\n\n```yaml\n\ndependencies:\n  ...\n  get:\n\n```\n\nGet को अन फाइल्स में Import करे जहां आप Get को इस्तेमाल करेंगे: \n\n```dart\n\nimport 'package:get/get.dart';\n\n```\n\n# GetX के साथ काउंटर ऐप\n\nFlutter पर नए Project पर Default रूप से बनाए गए \"काउंटर\" प्रोजेक्ट में 100 से अधिक लाइनें (टिप्पणियों के साथ) हैं। Get की शक्ति दिखाने के लिए, मैं प्रदर्शित करूंगा कि प्रत्येक क्लिक के साथ राज्य को बदलने वाला \"काउंटर\" कैसे बनाया जाए, Navigation किया जाए और State Management किया जाए, सभी एक संगठित तरीके से, व्यावसायिक तर्क को दृश्य से अलग करते हुए, केवल में टिप्पणियों सहित 26 लाइन कोड।\n\n- चरण 1:\n\n  अपने **MaterialApp()** से पहले “Get” जोड़ें, इसे **GetMaterialApp()** में बदल दें\n\n```dart\n\nvoid main() => runApp(GetMaterialApp(home: Home()));\n\n```\n\n- **सूचना**: यह Flutter के MaterialApp को संशोधित नहीं करता है, GetMaterialApp एक संशोधित MaterialApp नहीं है, यह सिर्फ एक पूर्व-कॉन्फ़िगर विजेट है, जिसमें एक बच्चे के रूप में डिफ़ॉल्ट MaterialApp है। आप इसे मैन्युअल रूप से कॉन्फ़िगर कर सकते हैं, लेकिन यह निश्चित रूप से आवश्यक नहीं है। GetMaterialApp मार्ग बनाएगा, उन्हें इंजेक्ट करेगा, अनुवाद इंजेक्ट करेगा, मार्ग नेविगेशन के लिए आपको जो कुछ भी चाहिए उसे इंजेक्ट करेगा। यदि आप केवल राज्य प्रबंधन या निर्भरता प्रबंधन के लिए गेट का उपयोग करते हैं, तो GetMaterialApp का उपयोग करना आवश्यक नहीं है। GetMaterialApp मार्गों, स्नैकबार, अंतर्राष्ट्रीयकरण, बॉटमशीट, संवाद, और मार्गों से संबंधित उच्च-स्तरीय एपिस और संदर्भ की अनुपस्थिति के लिए आवश्यक है।\n\n- **सूचना²**: यह चरण केवल तभी आवश्यक है जब आप Navigation (`Get.to()`, `Get.back()` इत्यादि) का उपयोग करने वाले हों। यदि आप इसका उपयोग नहीं करने जा रहे हैं तो चरण 1 करने की आवश्यकता नहीं है।\n\n- चरण 2:\n\n  अपना व्यावसायिक तर्क वर्ग बनाएं और उसके अंदर सभी चर, विधियों और नियंत्रकों को रखें।\n\n  आप किसी भी Variable Ko \".obs\" का प्रयोग करके Observable बना सकते है\n\n```dart\n\nclass Controller extends GetxController{\n\n  var count = 0.obs;\n\n  increment() => count++;\n\n}\n\n```\n\n- चरण 3:\n\n  अपना दृश्य बनाएं, StatelessWidget का उपयोग करें और कुछ RAM सहेजें, Get के साथ आपको StatefulWidget का उपयोग करने की आवश्यकता नहीं है।\n\n```dart\n\nclass Home extends StatelessWidget {\n\n  @override\n\n  Widget build(context) {\n\n    // Get.put() का उपयोग करके अपनी Class के सभी Children के लिए उपलब्ध कराने के लिए तत्काल करें।\n\n    final Controller c = Get.put(Controller());\n\n    return Scaffold(\n\n      // जब भी गिनती बदली जाए तो Text() को अपडेट करने के लिए Obx(()=> का उपयोग करें।\n\n      appBar: AppBar(title: Obx(() => Text(\"Clicks: ${c.count}\"))),\n\n      // 8 लाइन Navigator.push() को एक साधारण Get.to() से बदलें । आपको \"context\" की आवश्यकता नहीं है ।\n\n      body: Center(child: ElevatedButton(\n\n              child: Text(\"Go to Other\"), onPressed: () => Get.to(Other()))),\n\n      floatingActionButton:\n\n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n\n  }\n\n}\n\nclass Other extends StatelessWidget {\n\n  // आप किसी अन्य Page द्वारा उपयोग किए जा रहे Controller को खोजने के लिए Get से पूछ सकते हैं और आपको उस पर Redirect कर सकते हैं।\n\n  final Controller c = Get.find();\n\n  @override\n\n  Widget build(context){\n\n     // बदले हुए count Variable को Access करें\n\n     return Scaffold(body: Center(child: Text(\"${c.count}\")));\n\n  }\n\n}\n\n```\n\n**परिणाम**:\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/counter-app-gif.gif)\n\nयह एक सरल Project है लेकिन यह पहले ही स्पष्ट कर देती है कि Get कितना शक्तिशाली है। जैसे-जैसे आपकी परियोजना बढ़ती है, यह अंतर और अधिक महत्वपूर्ण होता जाएगा।\n\nGet को टीमों के साथ काम करने के लिए डिज़ाइन किया गया था, लेकिन यह व्यक्तिगत डेवलपर के काम को आसान बनाता है।\n\nअपनी समय सीमा में सुधार करें, Performance को खोए बिना समय पर सब कुछ वितरित करें। Get हर किसी के लिए नहीं है, लेकिन अगर आपने उस वाक्यांश के साथ पहचान की है, तो Get आपके लिए है!\n\n# तीन सिद्धांत\n\n## State  management\n\nGet के दो अलग-अलग State Manager हैं: Simple State Builder (हम इसे GetBuilder कहते हैं) और Reactive State Manager (GetX/Obx)\n\n### Reactive  State  Manager\n\nReactive Programming कई लोगों को अलग-थलग कर सकती है क्योंकि इसे जटिल कहा जाता है। GetX Reactive Programming को काफी सरल बना देता है:\n\n- आपको StreamControllers बनाने की आवश्यकता नहीं होगी।\n\n- आपको प्रत्येक Variable के लिए StreamBuilder बनाने की आवश्यकता नहीं होगी\n\n- आपको प्रत्येक Class के लिए एक State बनाने की आवश्यकता नहीं होगी।\n\n- आपको Initial Value के लिए एक Get बनाने की आवश्यकता नहीं होगी।\n\n- आपको Code Generators का उपयोग करने की आवश्यकता नहीं होगी\n\n**Get** के साथ **Reactive Programming**, **\"setState()\"** का उपयोग करने जितना आसान है।\n\nआइए कल्पना करें कि आपके पास एक name Variable है और चाहते हैं कि हर बार जब आप इसे बदलते हैं, तो इसका उपयोग करने वाले सभी Widgets बदल जाएँ ।\nयह आपका count Variable है\n\n```dart\n\nvar name = 'Adison Masih';\n\n```\n\nइसे Observable बनाने के लिए, आपको बस इसके अंत में \".obs\" जोड़ना होगा:\n```dart\n\nvar name = 'Adison Masih'.obs;\n\n```\n\nअगर आप आप उस Value को दिखाना चाहते हैं और जब भी Value बदलती हैं तो स्क्रीन को करना चाहते हैं, तो यह करें:\n\n```dart\n\nObx(() => Text(\"${controller.name}\"));\n\n```\n\nबस इतना ही। यह _इत्ना_ आसान है।\n\n### State Management के बारे में अधिक जानकारी\n\nराज्य प्रबंधन की अधिक गहन व्याख्या [यहां](./documentation/en_US/state_management.md) देखें । वहां आपको अधिक उदाहरण और **Simple State Manager** और **Reactive State Manager** के बीच का अंतर दिखाई देगा\n\nआपको GetX की शक्ति का अच्छा अंदाजा हो जाएगा।\n\n## Route  प्रबंधन\n\nयदि आप बिना **context** के **Routes/Snackbars/Dialogs/Bottomsheets** का उपयोग करने जा रहे हैं, तो GetX आपके लिए भी उत्कृष्ट है, बस इसे देखें:\n\nअपने **\"MaterialApp()\"** से पहले **“Get”** जोड़ें, इसे **\"GetMaterialApp()\"** में बदल दें\n\n```dart\n\nGetMaterialApp( // यह पहले MaterialApp था\n\n  home: MyHome(),\n\n)\n\n```\n\nएक नई स्क्रीन पर Navigate करें:\n```dart\n\nGet.to(NextScreen());\n\n```\n\nनाम के साथ नई स्क्रीन पर Navigate करें। **Named Routes** पर अधिक विवरण [यहां](./documentation/en_US/route_management.md#navigation-with-named-routes) देखें।\n\n```dart\n\nGet.toNamed('/details');\n\n```\n\nSnackbar, Dialog तथा Bottomsheets या ऐसी किसी भी चीज़ को बंद करने के लिए आप आम तौर पर ```Navigator.pop(context);``` के साथ बंद करते हैं;\n\n```dart\n\nGet.back();\n\n```\nअगली Screen पर जाने के लिए और पिछली Screen पर वापस जाने का कोई विकल्प नहीं है (SplashScreens, Login Screens आदि में उपयोग के लिए)\n\n```dart\n\nGet.off(NextScreen());\n\n```\n\nअगली Screen पर जाने और पिछले सभी Routes को रद्द करने के लिए (Shopping Carts, Polls और Tests में उपयोगी)\n\n```dart\n\nGet.offAll(NextScreen());\n\n```\n\nध्यान दिया कि आपको इनमें से कोई भी काम करने के लिए **\"context\"** का उपयोग करने की आवश्यकता नहीं है? **\"Get Route Management\"** का उपयोग करने का यह सबसे बड़ा लाभ है। इसके साथ, आप इन सभी **\"Methods\"** को अपने **\"Controller Class\"** से बिना किसी चिंता के Execute कर सकते हैं।\n\n### Route Management के बारे में अधिक जानकारी\n\n**\"Named Routes\"** के साथ काम करें और अपने Routes पर **\"Lower-Level Control\"** भी प्राप्त करें! [यहां](./documentation/en_US/route_management.md) गहन दस्तावेज है\n"
        },
        {
          "name": "README-vi.md",
          "type": "blob",
          "size": 53.5341796875,
          "content": "![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n**Ngôn ngữ: Tiếng Việt (file này), [English](README.md), [Indonesian](README.id-ID.md), [Urdu](README.ur-PK.md), [Chinese](README.zh-cn.md), [Brazilian Portuguese](README.pt-br.md), [Spanish](README-es.md), [Russian](README.ru.md), [Polish](README.pl.md), [Korean](README.ko-kr.md), [French](README-fr.md).**\n\n[![pub package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n[![popularity](https://badges.bar/get/popularity)](https://pub.dev/packages/sentry/score)\n[![likes](https://badges.bar/get/likes)](https://pub.dev/packages/get/score)\n[![pub points](https://badges.bar/get/pub%20points)](https://pub.dev/packages/get/score)\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n[![style: effective dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n[![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n[![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n<a href=\"https://github.com/Solido/awesome-flutter\">\n<img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n</a>\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n- [Về GetX](#về-getx)\n- [Cài Đặt](#cài-đặt)\n- [Counter App với GetX](#counter-app-với-getx)\n- [Tam Trụ](#tam-trụ)\n  - [Quản lý State](#quản-lý-state)\n    - [Quản lý Reactive State](#quản-lý-reactive-state)\n    - [Thêm thông tin về quản lý state](#thêm-thông-tin-về-quản-lý-state)\n  - [Quản lý route](#quản-lý-route)\n    - [Thêm thông tin về quản lý route](#thêm-thông-tin-về-quản-lý-route)\n  - [Quản lý dependency](#quản-lý-dependency)\n    - [Thêm thông tin về quản lý dependency](#thêm-thông-tin-về-quản-lý-dependency)\n- [Utils](#utils)\n  - [Internationalization](#internationalization)\n    - [Dịch thuật](#dịch-thuật)\n      - [Sử dụng bản dịch thuật](#sử-dụng-bản-dịch-thuật)\n    - [Locales](#locales)\n      - [Đổi locale](#đổi-locale)\n      - [System locale](#system-locale)\n  - [Đổi Theme](#đổi-theme)\n  - [GetConnect](#getconnect)\n    - [Cấu hình mặc định](#cấu-hình-mặc-định)\n    - [Cấu hình tùy chỉnh](#cấu-hình-tùy-chỉnh)\n  - [GetPage Middleware](#getpage-middleware)\n    - [Ưu tiên](#ưu-tiên)\n    - [Chuyển hướng](#chuyển-hướng)\n    - [onPageCalled](#onpagecalled)\n    - [OnBindingsStart](#onbindingsstart)\n    - [OnPageBuildStart](#onpagebuildstart)\n    - [OnPageBuilt](#onpagebuilt)\n    - [OnPageDispose](#onpagedispose)\n  - [APIs nâng cao khác](#apis-nâng-cao-khác)\n    - [Cấu hình thủ công và cài đặt chung tuỳ chọn](#cấu-hình-thủ-công-và-cài-đặt-chung-tuỳ-chọn)\n    - [Local State Widgets](#local-state-widgets)\n      - [ValueBuilder](#valuebuilder)\n      - [ObxValue](#obxvalue)\n  - [Mẹo hữu ích](#mẹo-hữu-ích)\n    - [GetView](#getview)\n    - [GetResponsiveView](#getresponsiveview)\n      - [Hướng dẫn sử dụng trước khi dùng](#hướng-dẫn-sử-dụng-trước-khi-dùng)\n    - [GetWidget](#getwidget)\n    - [GetxService](#getxservice)\n- [Thay đổi đột phá 2.0](#thay-đổi-đột-phá-2.0)\n- [Tại sao lại dùng GetX](#tại-sao-lại-dùng-getx)\n- [Cộng đồng](#cộng-đồng)\n  - [Kênh Cộng đồng](#kênh-cộng-đồng)\n  - [Cách cống hiến](#cách-cống-hiến)\n  - [Các bài báo và video](#các-bài-báo-và-video)\n\n# Về GetX\n\n- GetX hướng tới sự nhỏ gọn và giải pháp tối ưu cho Flutter với tốc độ ưu việt trong quản lý state, nạp dependency thông minh, và quản lý route nhanh chóng và thực tế.\n\n- GetX hướng tới 3 tham vọng chính, nghĩa là tất cả các tài nguyên của thư viện sẽ dành cho những điểm ưu tiên sau: **NĂNG SUẤT, HIỆU SUẤT VÀ TỔ CHỨC.**\n\n  - **HIỆU SUẤT:** GetX tập trung vào hiệu suất và mức tiêu thụ tài nguyên tối thiểu, do đó nó không sử dụng Streams hoặc ChangeNotifier.\n\n  - **NĂNG SUẤT:** GetX sử dụng một cú pháp dễ dàng và dễ thở. Bất kể bạn muốn làm gì, luôn có một cách dễ dàng hơn với GetX. Nó sẽ tiết kiệm hàng giờ phát triển và sẽ cung cấp hiệu suất tối đa mà ứng dụng của bạn có thể mang lại.\n\n    Nói chung, nhà phát triển nên quan tâm đến việc xóa những controller ra khỏi bộ nhớ. Với GetX, mặc định các tài nguyên sẽ\n    TỰ ĐỘNG xóa khỏi bộ nhớ khi không dùng nữa. Nếu bạn muốn giữ nó trong bộ nhớ, bạn phải khai báo rõ ràng \"permanent: true\" trong phần dependency của mình. Từ đó, bạn sẽ tiết kiệm thời gian và giảm rủi ro khi phụ thuộc vào bộ nhớ. Theo mặc định, tính năng tải dependency cũng lười biếng.\n\n  - **TỔ CHỨC:**\n    GetX cho phép tách toàn bộ View, presentation logic, business logic, nạp dependencies và điều hướng. Bạn không cần \"context\" để điều hướng giữa các route, vì vậy bạn sẽ độc lập trong sơ đồ widget (trực quan hóa). Bạn không cần \"context\" để truy cập Controller / Blocs của mình thông qua một InheritedWidget, vì vậy bạn hoàn toàn tách rời presentation logic và business logic ra khỏi lớp trực quan của mình. Bạn không cần phải đưa các Controller / Models / Blocs vào sơ đồ widget của mình thông qua `MultiProvider`, vì GetX sử dụng tính năng nạp dependency của riêng nó, tách hoàn toàn DI khỏi chế độ xem của nó.\n\n    Với GetX, bạn biết nơi tìm từng tính năng ứng dụng của mình, với cơ chế clean code theo mặc định. Ngoài việc giúp bảo trì dễ dàng, GetX giúp việc chia sẻ các mô-đun trở thành khả thi trong Flutter.\n    BLoC là điểm khởi đầu để tổ chức code trong Flutter, nó tách biệt business logic ra khỏi lớp trực quan hóa (visualization). GetX nảy sinh từ điều này, không chỉ tách biệt presentation logic mà còn cả business logic. Nạp dependency bổ sung và route cũng được tách ra và lớp dữ liệu cũng biến mất. Bạn sẽ biết mọi thứ ở đâu và sẽ hình dung tất cả những điều này dễ hơn cả xây dựng chương trình \"Hello World\".\n    GetX là cách dễ nhất, thiết thực và có thể mở rộng để xây dựng các ứng dụng hiệu suất cao với Flutter SDK. GetX chứa đựng một hệ sinh thái rộng lớn xung quanh nó hoạt động hoàn hảo cùng nhau, rất dễ dàng cho người mới bắt đầu và nó chính xác cho các chuyên gia. Nó an toàn, ổn định, luôn cập nhật và cung cấp một loạt các API được tích hợp sẵn mà không có trong Flutter SDK mặc định.\n\n- GetX không cồng kềnh và có vô số tính năng cho phép bạn bắt đầu lập trình mà không cần lo lắng về bất cứ điều gì. Đặc biệt, nó cho phép mỗi tính năng này nằm trong các vùng chứa riêng biệt và chỉ được bắt đầu sau khi sử dụng. Nếu bạn chỉ sử dụng phần quản lý state của GetX thì sẽ chỉ có quản lý state được sử dụng. Nếu bạn chỉ sử dụng route, thì GetX không biên dịch phần quản lý state.\n\n- GetX có một hệ sinh thái khổng lồ, một cộng đồng lớn, một số lượng lớn cộng tác viên và sẽ được duy trì miễn là Flutter còn tồn tại. GetX có khả năng chạy cùng một mã (code) trên Android, iOS, Web, Mac, Linux, Windows và trên máy chủ của bạn.\n  **Bạn hoàn toàn có thể sử dụng lại mã của mình trên frontend qua backend với [Get Server](https://github.com/jonataslaw/get_server)**.\n\n**Ngoài ra, toàn bộ quá trình phát triển có thể hoàn toàn tự động, cả trên máy chủ và frontend với [Get CLI](https://github.com/jonataslaw/get_cli)**.\n\n**Ngoài ra, nhằm tăng thêm năng suất của bạn, chúng tôi hỗ trợ\n[tiện ích trên VSCode](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets) và [tiện ích cho Android Studio/Intellij](https://plugins.jetbrains.com/plugin/14975-getx-snippets)**\n\n# Cài Đặt\n\nThêm Get vào file pubspec.yaml:\n\n```yaml\ndependencies:\n  get:\n```\n\nImport get vào file cần sử dụng:\n\n```dart\nimport 'package:get/get.dart';\n```\n\n# Counter App với GetX\n\nDự án \"counter\" được tạo theo mặc định trên dự án mới trên Flutter có hơn 100 dòng (có comments). Để thể hiện sức mạnh của Get, tôi sẽ trình bày cách tạo \"counter\" thay đổi trạng thái với mỗi lần nhấp, chuyển đổi giữa các trang và chia sẻ trạng thái giữa các màn hình, tất cả đều theo cách có tổ chức, tách biệt logic nghiệp vụ khỏi chế độ xem, CHỈ VỚI 26 DÒNG!\n\n- Bước 1:\n  Thêm \"Get\" trước MaterialApp, nó sẽ thành GetMaterialApp\n\n```dart\nvoid main() => runApp(GetMaterialApp(home: Home()));\n```\n\n- Chú ý: điều này không sửa đổi MaterialApp của Flutter, GetMaterialApp không phải là MaterialApp được sửa đổi, nó chỉ là một Widget được tạo trước với MaterialApp mặc định là child. Bạn có thể cấu hình điều này theo cách thủ công, nhưng nó chắc chắn là không cần thiết. GetMaterialApp sẽ tạo các route, đưa chúng vào, đưa bản dịch, đưa mọi thứ bạn cần để điều hướng route. Nếu bạn chỉ sử dụng Get để quản lý trạng thái hoặc quản lý phụ thuộc, thì không cần thiết phải sử dụng GetMaterialApp. Tóm lại, GetMaterialApp chỉ cần thiết cho các route, snacksbar, internationalization, bottomSheets, Dialog và các APIs cấp cao liên quan đến route và không có \"context\".\n- Chú ý²: Một lần nữa, bước này chỉ cần thiết nếu bạn sử dụng quản lý route (`Get.to ()`, `Get.back ()`, v.v.). Nếu bạn không sử dụng nó thì không cần thực hiện bước 1\n\n- Bước 2:\n  Tạo lớp business logic của bạn và đặt tất cả các biến (variables), hàm (function) và controller bên trong nó.\n  Bạn có thể làm cho bất kỳ biến nào có thể quan sát được đơn giản bằng cách sử dụng \".obs\".\n\n```dart\nclass Controller extends GetxController{\n  var count = 0.obs;\n  increment() => count++;\n}\n```\n\n- Bước 3:\n  Tạo widget của bạn, sử dụng StatelessWidget và tiết kiệm RAM, với Get, bạn có thể không cần sử dụng StatefulWidget nữa.\n\n```dart\nclass Home extends StatelessWidget {\n\n  @override\n  Widget build(context) {\n\n    // Instantiate your class using Get.put() to make it available for all \"child\" routes there.\n    final Controller c = Get.put(Controller());\n\n    return Scaffold(\n      // Use Obx(()=> to update Text() whenever count is changed.\n      appBar: AppBar(title: Obx(() => Text(\"Clicks: ${c.count}\"))),\n\n      // Replace the 8 lines Navigator.push by a simple Get.to(). You don't need context\n      body: Center(child: ElevatedButton(\n              child: Text(\"Go to Other\"), onPressed: () => Get.to(Other()))),\n      floatingActionButton:\n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n  }\n}\n\nclass Other extends StatelessWidget {\n  // You can ask Get to find a Controller that is being used by another page and redirect you to it.\n  final Controller c = Get.find();\n\n  @override\n  Widget build(context){\n     // Access the updated count variable\n     return Scaffold(body: Center(child: Text(\"${c.count}\")));\n  }\n}\n```\n\nKết quả:\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/counter-app-gif.gif)\n\nĐây là một dự án đơn giản nhưng nó đã cho thấy rõ sức mạnh của Get. Khi dự án của bạn phát triển, sự khác biệt này sẽ trở nên đáng kể hơn.\n\nGet được thiết kế để làm việc với các nhóm, nhưng nó làm cho công việc của một nhà phát triển cá nhân trở nên đơn giản.\n\nCải thiện thời gian, giao mọi thứ đúng hạn mà không làm giảm hiệu suất. Get không dành cho tất cả mọi người, nhưng nếu bạn đã xác định gắn với Get, Get sẽ \"get\" bạn!\n\n# Tam Trụ\n\n## Quản lý State\n\nGet có 2 cách quản lý trạng thái (state managers) khác nhau : quản lý trạng thái đơn giản (chúng ta gọi nó là GetBuilder) và quản lý trạng thái phản ứng (the reactive state manager) (GetX/Obx).\n\n### Quản lý Reactive State\n\nLập trình phản ứng (reactive programming) có thể khiến nhiều người xa lánh vì nó được cho là phức tạp. GetX biến lập trình phản ứng thành một thứ khá đơn giản:\n\n- Bạn sẽ không cần tạo StreamControllers.\n- Bạn sẽ không cần tạo StreamBuilder cho mỗi biến.\n- Bạn sẽ không cần tạo một lớp (class) cho mỗi trạng thái.\n- Bạn sẽ không cần tạo get cho một giá trị ban đầu.\n- Bạn sẽ không cần sử dụng trình tạo mã.\n\nLập trình phản ứng với Get dễ dàng như sử dụng setState.\n\nHãy tưởng tượng rằng bạn có một biến tên và muốn rằng mỗi khi bạn thay đổi nó, tất cả các widget sử dụng nó sẽ được tự động thay đổi.\n\nĐây là biến đếm của bạn:\n\n```dart\nvar name = 'Jonatas Borges';\n```\n\nĐể nó có thể được lắng nghe, bạn chỉ cần thêm \".obs\" ở cuối:\n\n```dart\nvar name = 'Jonatas Borges'.obs;\n```\n\nVà trong UI, khi bạn muốn hiển thị giá trị đó và cập nhật màn hình bất cứ khi nào giá trị thay đổi, chỉ cần thực hiện điều này:\n\n```dart\nObx(() => Text(\"${controller.name}\"));\n```\n\nThế thôi. Chỉ là _thế_ thôi người ơi~.\n\n### Thêm thông tin về Quản lý state\n\n**Xem thông tin cụ thể tại [đây](./documentation/en_US/state_management.md). Tại đó, bạn có thể tham khảo ví dụ và so sánh sự khác nhau giữa quản lý state cơ bản và quản lý state reactive**\n\nBạn sẽ hình dung được sức mạnh của GetX.\n\n## Quản lý route\n\nNếu bạn chỉ sử dụng routes/snackbars/dialogs/bottomsheets không có context, GetX là lựa chọn số 2 trừ 1, nhìn đây:\n\nThêm \"Get\" trước MaterialApp, nó sẽ biến thành GetMaterialApp\n\n```dart\nGetMaterialApp( // Before: MaterialApp(\n  home: MyHome(),\n)\n```\n\nDi chuyển tới màn hình mới:\n\n```dart\n\nGet.to(NextScreen());\n```\n\nDi chuyển tới màn hình mới theo tên. Xem thêm tại [đây](./documentation/en_US/route_management.md#navigation-with-named-routes)\n\n```dart\n\nGet.toNamed('/details');\n```\n\nĐể đóng snackbars, dialogs, bottomsheets, hay bất kì thứ gì, bạn có thể xài cái này để thay Navigator.pop(context);\n\n```dart\nGet.back();\n```\n\nĐi đến màn hình kế tiếp và bỏ luôn màn hình cũ (thường dùng cho màn hình giới thiệu, màn hình đăng nhập, etc.)\n\n```dart\nGet.off(NextScreen());\n```\n\nĐi đến màn hình kế tiếp và đóng tất cả các routes (hữu dụng cho shopping cart, polls, và tests)\n\n```dart\nGet.offAll(NextScreen());\n```\n\nBạn có thấy nãy giờ chúng ta không sử dụng từ khóa \"context\"? Đây chính là thang điểm 9 + 1 của quản lý route ở Get. Với điểm mạnh trên, bạn có thể thao tác bất cứ đâu, kể cả trong controller class.\n\n### Thêm thông tin về quản lý route\n\n**Get hoạt động được với named routes và cũng cung cấp cách điều khiển ở cấp thấp (lower-level control) cho routes của bạn! Tài liệu chi tiết tại [đây](./documentation/en_US/route_management.md)**\n\n## Quản lý dependency\n\nGet hỗ trợ tính năng giúp bạn lấy class như Bloc hoặc Controller chỉ với 1 dòng, không cần Provider context hay InheritedWidget:\n\n```dart\nController controller = Get.put(Controller()); // Rather Controller controller = Controller();\n```\n\n- Chú ý: Nếu bạn dùng Get's State Manager, hãy chú ý đến việc bindings API, có thể giúp dễ dàng kết nối view đến controller.\n\nThay vì khởi tạo class của bạn trong class bạn đang sử dụng, bạn đang khởi tạo nó trong phiên bản Get, điều này sẽ làm cho nó có sẵn trên toàn bộ Ứng dụng của bạn.\nVì vậy, bạn có thể sử dụng bộ điều khiển (hoặc Bloc) của mình một cách bình thường\n\n**Mẹo:** quản lý dependency của Get được tách ra khỏi các phần khác của package, vì vậy, ví dụ: nếu ứng dụng của bạn đã sử dụng 1 trình quản lý trạng thái (bất kỳ cái nào, không quan trọng), bạn không cần phải viết lại tất cả, bạn có thể sử dụng nạp dependency của Get vô lo\n\n```dart\ncontroller.fetchApi();\n```\n\nHãy tưởng tượng rằng bạn đã điều hướng qua nhiều route và bạn cần dữ liệu bị còn sót trong controller của mình, bạn sẽ cần một trình quản lý dependency kết hợp với Provider hoặc Get_it, đúng không? Với Get, sử dụng Get để \"find\" cho controller, bạn sẽ hoàn toàn độc lập:\n\n```dart\nController controller = Get.find();\n//Yes, it looks like Magic, Get will find your controller, and will deliver it to you. You can have 1 million controllers instantiated, Get will always give you the right controller.\n```\n\nVà sau đó, bạn sẽ có thể khôi phục dữ liệu controller của mình đã lấy được ở đó:\n\n```dart\nText(controller.textFromApi);\n```\n\n### Thêm thông tin về quản lý dependency\n\n**Xem thêm tại [đây](./documentation/en_US/dependency_management.md)**\n\n# Utils\n\n## Internationalization\n\n### Dịch thuật\n\nCác bản dịch được lưu giữ như một bản đồ từ điển (dictionary map) key-value đơn giản.\nĐể thêm các bản dịch tùy chỉnh, hãy tạo một class và kế thừa (extend) từ `Translation`.\n\n```dart\nimport 'package:get/get.dart';\n\nclass Messages extends Translations {\n  @override\n  Map<String, Map<String, String>> get keys => {\n        'en_US': {\n          'hello': 'Hello World',\n        },\n        'de_DE': {\n          'hello': 'Hallo Welt',\n        }\n      };\n}\n```\n\n#### Sử dụng bản dịch thuật\n\nChỉ cần thêm `.tr` vào key được chỉ định và nó sẽ được dịch, sử dụng giá trị hiện tại của` Get.locale` và `Get.fallbackLocale`.\n\n```dart\nText('title'.tr);\n```\n\n#### Sử dụng bản dịch thuật với số ít và số nhiều\n\n```dart\nvar products = [];\nText('singularKey'.trPlural('pluralKey', products.length, Args));\n```\n\n#### Sử dụng bản dịch với tham số (parameters)\n\n```dart\nimport 'package:get/get.dart';\n\n\nMap<String, Map<String, String>> get keys => {\n    'en_US': {\n        'logged_in': 'logged in as @name with email @email',\n    },\n    'es_ES': {\n       'logged_in': 'iniciado sesión como @name con e-mail @email',\n    }\n};\n\nText('logged_in'.trParams({\n  'name': 'Jhon',\n  'email': 'jhon@example.com'\n  }));\n```\n\n### Locales\n\nChuyển các tham số (parameters) cho `GetMaterialApp` để xác định ngôn ngữ và bản dịch.\n\n```dart\nreturn GetMaterialApp(\n    translations: Messages(), // your translations\n    locale: Locale('en', 'US'), // translations will be displayed in that locale\n    fallbackLocale: Locale('en', 'UK'), // specify the fallback locale in case an invalid locale is selected.\n);\n```\n\n#### Đổi locale\n\nGọi `Get.updateLocale (locale)` 'để cập nhật ngôn ngữ. Các bản dịch sau đó sẽ tự động sử dụng ngôn ngữ mới.\n\n```dart\nvar locale = Locale('en', 'US');\nGet.updateLocale(locale);\n```\n\n#### System locale\n\nĐể đọc system locale, sử dụng `Get.deviceLocale`.\n\n```dart\nreturn GetMaterialApp(\n    locale: Get.deviceLocale,\n);\n```\n\n## Đổi chủ đề (Theme)\n\nVui lòng không sử dụng bất kỳ Widget con nào cấp cao hơn `GetMaterialApp` để cập nhật nó. Điều này có thể kích hoạt các key trùng lặp. Rất nhiều người đã quen với cách tiếp cận thời tiền sử là tạo tiện ích \"ThemeProvider\" chỉ để thay đổi chủ đề ứng dụng của bạn và điều này KHÔNG cần thiết với ** GetX ™ **.\n\nBạn có thể tạo chủ đề tùy chỉnh của mình và chỉ cần thêm nó vào trong `Get.changeTheme` mà không cần bất kỳ điều gì khác:\n\n```dart\nGet.changeTheme(ThemeData.light());\n```\n\nNếu bạn muốn tạo một cái gì đó giống như một nút thay đổi Theme với `onTap`, bạn có thể kết hợp hai API ** GetX ™ ** cho điều đó:\n\n- Api kiểm tra xem `Theme` tối có đang được sử dụng hay không.\n- Và `Theme` sẽ thay đổi API, bạn sử dụng với `onPressed`:\n\n```dart\nGet.changeTheme(Get.isDarkMode? ThemeData.light(): ThemeData.dark());\n```\n\nKhi bật `.darkmode`, nó sẽ chuyển _light theme_, và khi bật _light theme_ , nó sẽ chuyển _dark theme_.\n\n## GetConnect\n\nGetConnect tạo giao thức tới http hoặc websockets\n\n### Cấu hình mặc định\n\nĐơn giản, bạn có thể kế thừa (extend) từ GetConnect và sử dụng các phương thức GET/POST/PUT/DELETE/SOCKET khi giao tiếp với Rest API hoặc websockets.\n\n```dart\nclass UserProvider extends GetConnect {\n  // Get request\n  Future<Response> getUser(int id) => get('http://youapi/users/$id');\n  // Post request\n  Future<Response> postUser(Map data) => post('http://youapi/users', body: data);\n  // Post request with File\n  Future<Response<CasesModel>> postCases(List<int> image) {\n    final form = FormData({\n      'file': MultipartFile(image, filename: 'avatar.png'),\n      'otherFile': MultipartFile(image, filename: 'cover.png'),\n    });\n    return post('http://youapi/users/upload', form);\n  }\n\n  GetSocket userMessages() {\n    return socket('https://yourapi/users/socket');\n  }\n}\n```\n\n### Cấu hình tùy chỉnh\n\nGetConnect có khả năng tùy chỉnh cao Bạn có thể xác định Url chính như answers, modifiers như request, xác địng authenticator và thậm chí số lần thử mà nó sẽ cố gắng authenticate, ngoài việc cung cấp khả năng xác định bộ giải mã chuẩn sẽ chuyển đổi tất cả các request của bạn thành Model mà không cần bất kỳ cấu hình bổ sung nào.\n\n```dart\nclass HomeProvider extends GetConnect {\n  @override\n  void onInit() {\n    // All request will pass to jsonEncode so CasesModel.fromJson()\n    httpClient.defaultDecoder = CasesModel.fromJson;\n    httpClient.baseUrl = 'https://api.covid19api.com';\n    // baseUrl = 'https://api.covid19api.com'; // It define baseUrl to\n    // Http and websockets if used with no [httpClient] instance\n\n    // It's will attach 'apikey' property on header from all requests\n    httpClient.addRequestModifier((request) {\n      request.headers['apikey'] = '12345678';\n      return request;\n    });\n\n    // Even if the server sends data from the country \"Brazil\",\n    // it will never be displayed to users, because you remove\n    // that data from the response, even before the response is delivered\n    httpClient.addResponseModifier<CasesModel>((request, response) {\n      CasesModel model = response.body;\n      if (model.countries.contains('Brazil')) {\n        model.countries.remove('Brazilll');\n      }\n    });\n\n    httpClient.addAuthenticator((request) async {\n      final response = await get(\"http://yourapi/token\");\n      final token = response.body['token'];\n      // Set the header\n      request.headers['Authorization'] = \"$token\";\n      return request;\n    });\n\n    //Autenticator will be called 3 times if HttpStatus is\n    //HttpStatus.unauthorized\n    httpClient.maxAuthRetries = 3;\n  }\n\n  @override\n  Future<Response<CasesModel>> getCases(String path) => get(path);\n}\n```\n\n## GetPage Middleware\n\nGetPage hiện có thuộc tính mới lấy danh sách GetMiddleWare và chạy chúng theo thứ tự cụ thể.\n\n**Chú ý**: Khi GetPage có Middleware (phần trung gian), tất cả các children của trang này sẽ tự động có cùng middlewares.\n\n### Ưu tiên\n\nThứ tự ưu tiên của Middlewares có thể đặt như sau trong GetMiddleware.\n\n```dart\nfinal middlewares = [\n  GetMiddleware(priority: 2),\n  GetMiddleware(priority: 5),\n  GetMiddleware(priority: 4),\n  GetMiddleware(priority: -8),\n];\n```\n\nvà chúng sẽ chạy như thế này **-8 => 2 => 4 => 5**\n\n### Chuyển hướng\n\nKhi bạn muốn tìm kiếm trang của route được gọi, function (hàm) sẽ khởi động. Kết quả là phải có RouteSettings để chuyển hướng đến. Hoặc cung cấp cho nó null và chuyển hướng không xảy ra.\n\n```dart\nRouteSettings redirect(String route) {\n  final authService = Get.find<AuthService>();\n  return authService.authed.value ? null : RouteSettings(name: '/login')\n}\n```\n\n### onPageCalled\n\nKhi bạn gọi một trang trước mọi thứ được tạo, hàm này sẽ khởi động và\nbạn có thể sử dụng nó để thay đổi điều gì đó về trang hoặc tạo cho nó một trang mới\n\n```dart\nGetPage onPageCalled(GetPage page) {\n  final authService = Get.find<AuthService>();\n  return page.copyWith(title: 'Welcome ${authService.UserName}');\n}\n```\n\n### OnBindingsStart\n\nHàm này sẽ khởi động ngay trước khi Bindings diễn ra và bạn có thể thay đổi Bindings cho trang này.\n\n```dart\nList<Bindings> onBindingsStart(List<Bindings> bindings) {\n  final authService = Get.find<AuthService>();\n  if (authService.isAdmin) {\n    bindings.add(AdminBinding());\n  }\n  return bindings;\n}\n```\n\n### OnPageBuildStart\n\nHàm này sẽ khởi động ngay sau khi Bindings diễn ra. Ở đây, bạn có thể làm thứ gì đó sau khi bạn tạo Bindings và trước khi tạo trang widget.\n\n```dart\nGetPageBuilder onPageBuildStart(GetPageBuilder page) {\n  print('bindings are ready');\n  return page;\n}\n```\n\n### OnPageBuilt\n\nHàm này sẽ khởi động ngay sau khi GetPage.page được gọi và sẽ cho bạn kết quả của hàm và lấy widget được hiển thị.\n\n### OnPageDispose\n\nFunction này sẽ khởi động ngay sau khi hủy bỏ tất cả các đối tượng liên quan (Controller, views, ...) của trang.\n\n## APIs nâng cao khác\n\n```dart\n// give the current args from currentScreen\nGet.arguments\n\n// give name of previous route\nGet.previousRoute\n\n// give the raw route to access for example, rawRoute.isFirst()\nGet.rawRoute\n\n// give access to Routing API from GetObserver\nGet.routing\n\n// check if snackbar is open\nGet.isSnackbarOpen\n\n// check if dialog is open\nGet.isDialogOpen\n\n// check if bottomsheet is open\nGet.isBottomSheetOpen\n\n// remove one route.\nGet.removeRoute()\n\n// back repeatedly until the predicate returns true.\nGet.until()\n\n// go to next route and remove all the previous routes until the predicate returns true.\nGet.offUntil()\n\n// go to next named route and remove all the previous routes until the predicate returns true.\nGet.offNamedUntil()\n\n//Check in what platform the app is running\nGetPlatform.isAndroid\nGetPlatform.isIOS\nGetPlatform.isMacOS\nGetPlatform.isWindows\nGetPlatform.isLinux\nGetPlatform.isFuchsia\n\n//Check the device type\nGetPlatform.isMobile\nGetPlatform.isDesktop\n//All platforms are supported independently in web!\n//You can tell if you are running inside a browser\n//on Windows, iOS, OSX, Android, etc.\nGetPlatform.isWeb\n\n\n// Equivalent to : MediaQuery.of(context).size.height,\n// but immutable.\nGet.height\nGet.width\n\n// Gives the current context of the Navigator.\nGet.context\n\n// Gives the context of the snackbar/dialog/bottomsheet in the foreground, anywhere in your code.\nGet.contextOverlay\n\n// Chí ú: Nếu bạn dùng cái này, nhớ đặtt. thànhnce you\n// have access to context in any place of your UI, you can use it anywhere in the UI code\n\n// If you need a changeable height/width (like Desktop or browser windows that can be scaled) you will need to use context.\ncontext.width\ncontext.height\n\n// Gives you the power to define half the screen, a third of it and so on.\n// Useful for responsive applications.\n// param dividedBy (double) optional - default: 1\n// param reducedBy (double) optional - default: 0\ncontext.heightTransformer()\ncontext.widthTransformer()\n\n/// Similar to MediaQuery.of(context).size\ncontext.mediaQuerySize()\n\n/// Similar to MediaQuery.of(context).padding\ncontext.mediaQueryPadding()\n\n/// Similar to MediaQuery.of(context).viewPadding\ncontext.mediaQueryViewPadding()\n\n/// Similar to MediaQuery.of(context).viewInsets;\ncontext.mediaQueryViewInsets()\n\n/// Similar to MediaQuery.of(context).orientation;\ncontext.orientation()\n\n/// Check if device is on landscape mode\ncontext.isLandscape()\n\n/// Check if device is on portrait mode\ncontext.isPortrait()\n\n/// Similar to MediaQuery.of(context).devicePixelRatio;\ncontext.devicePixelRatio()\n\n/// Similar to MediaQuery.of(context).textScaleFactor;\ncontext.textScaleFactor()\n\n/// Get the shortestSide from screen\ncontext.mediaQueryShortestSide()\n\n/// True if width be larger than 800\ncontext.showNavbar()\n\n/// True if the shortestSide is smaller than 600p\ncontext.isPhone()\n\n/// True if the shortestSide is largest than 600p\ncontext.isSmallTablet()\n\n/// True if the shortestSide is largest than 720p\ncontext.isLargeTablet()\n\n/// True if the current device is Tablet\ncontext.isTablet()\n\n/// Returns a value<T> according to the screen size\n/// can give value for:\n/// watch: if the shortestSide is smaller than 300\n/// mobile: if the shortestSide is smaller than 600\n/// tablet: if the shortestSide is smaller than 1200\n/// desktop: if width is largest than 1200\ncontext.responsiveValue<T>()\n```\n\n### Cấu hình thủ công và cài đặt chung tuỳ chọn\n\nGetMaterialApp configures everything for you, but if you want to configure Get manually.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver()],\n);\n```\n\nBạn cũng sẽ có thể dùng Middleware của riêng bạn trong `GetObserver`, điều này không ảnh hưởng những thứ khác.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [\n    GetObserver(MiddleWare.observer) // Here\n  ],\n);\n```\n\nBạn có thể tạo _Global Settings_ cho `Get`. Chỉ cần thêm `Get.config` vào code của bạn trước khi đẩy (push) bất cứ route nào.\nHoặc làm nó trực tiếp trong `GetMaterialApp` của bạn.\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  defaultTransition: Transition.fade,\n  opaqueRoute: Get.isOpaqueRouteDefault,\n  popGesture: Get.isPopGestureEnable,\n  transitionDuration: Get.defaultDurationTransition,\n  defaultGlobalState: Get.defaultGlobalState,\n);\n\nGet.config(\n  enableLog = true,\n  defaultPopGesture = true,\n  defaultTransition = Transitions.cupertino\n)\n```\n\nBạn có thể tự chọn chuyển hướng tất cả logging messages từ `Get`.\nNếu bạn muốn sử dụng logging package ưa thích của riêng bạn, và muốn chụp lại những logs đó:\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  logWriterCallback: localLogWriter,\n);\n\nvoid localLogWriter(String text, {bool isError = false}) {\n  // pass the message to your favourite logging package here\n  // please note that even if enableLog: false log messages will be pushed in this callback\n  // you get check the flag if you want through GetConfig.isLogEnable\n}\n\n```\n\n### Local State Widgets\n\nCác Widget này cho phép bạn quản lý một giá trị duy nhất và giữ trạng thái tạm thời và cục bộ.\nChúng ta có các hướng đi cho Reactive và Simple.\nVí dụ: bạn có thể sử dụng chúng để chuyển đổi văn bản tối nghĩa trong một `TextField`, có thể tạo một widget\nExpandable Panel tùy chỉnh hoặc có thể sửa đổi chỉ mục hiện tại trong `BottomNavigationBar` trong khi thay đổi nội dung\nbên trong một `Scaffold`.\n\n#### ValueBuilder\n\nĐơn giản hóa của `StatefulWidget` hoạt động với lệnh gọi lại` .setState` nhận giá trị cập nhật.\n\n```dart\nValueBuilder<bool>(\n  initialValue: false,\n  builder: (value, updateFn) => Switch(\n    value: value,\n    onChanged: updateFn, // same signature! you could use ( newValue ) => updateFn( newValue )\n  ),\n  // if you need to call something outside the builder method.\n  onUpdate: (value) => print(\"Value updated: $value\"),\n  onDispose: () => print(\"Widget unmounted\"),\n),\n```\n\n#### ObxValue\n\nTương tự như [`ValueBuilder`](#valuebuilder), nhưng đây là phiên bản Reactive, bạn kèm một lệnh Rx (nhớ cái .obs không?) và nó cập nhật tự động ... hay chưa?\n\n```dart\nObxValue((data) => Switch(\n        value: data.value,\n        onChanged: data, // Rx has a _callable_ function! You could use (flag) => data.value = flag,\n    ),\n    false.obs,\n),\n```\n\n## Mẹo hữu ích\n\n`.obs` observable (variable có thể quan sát được) (còn được gọi là loại _Rx_) có nhiều phương thức và toán tử bên trong.\n\n> Is very common to _believe_ that a property with `.obs` **IS** the actual value... but make no mistake!\n> We avoid the Type declaration of the variable, because Dart's compiler is smart enough, and the code\n> looks cleaner, but:\n\n```dart\nvar message = 'Xin Chào'.obs;\nprint( 'Message \"$message\" has Type ${message.runtimeType}');\n```\n\nNgay cả khi `message` _prints_ giá trị String, thì kiểu của nó lại là ** RxString **!\n\nVì vậy, bạn không thể thực hiện `message.substring (0, 4) '. Bạn phải truy cập vào `value`thực bên trong _observable_: Cách được sử dụng nhiều nhất là`.value`, nhưng, bạn có biết rằng bạn cũng có thể sử dụng ...\n\n```dart\nfinal name = 'GetX'.obs;\n// only \"updates\" the stream, if the value is different from the current one.\nname.value = 'Hey';\n\n// All Rx properties are \"callable\" and returns the new value.\n// but this approach does not accepts `null`, the UI will not rebuild.\nname('Hello');\n\n// is like a getter, prints 'Hello'.\nname() ;\n\n/// numbers:\n\nfinal count = 0.obs;\n\n// You can use all non mutable operations from num primitives!\ncount + 1;\n\n// Watch out! this is only valid if `count` is not final, but var\ncount += 1;\n\n// You can also compare against values:\ncount > 2;\n\n/// booleans:\n\nfinal flag = false.obs;\n\n// switches the value between true/false\nflag.toggle();\n\n\n/// all types:\n\n// Sets the `value` to null.\nflag.nil();\n\n// All toString(), toJson() operations are passed down to the `value`\nprint( count ); // calls `toString()` inside  for RxInt\n\nfinal abc = [0,1,2].obs;\n// Converts the value to a json Array, prints RxList\n// Json is supported by all Rx types!\nprint('json: ${jsonEncode(abc)}, type: ${abc.runtimeType}');\n\n// RxMap, RxList and RxSet are special Rx types, that extends their native types.\n// but you can work with a List as a regular list, although is reactive!\nabc.add(12); // pushes 12 to the list, and UPDATES the stream.\nabc[3]; // like Lists, reads the index 3.\n\n\n// equality works with the Rx and the value, but hashCode is always taken from the value\nfinal number = 12.obs;\nprint( number == 12 ); // prints > true\n\n/// Custom Rx Models:\n\n// toJson(), toString() are deferred to the child, so you can implement override on them, and print() the observable directly.\n\nclass User {\n    String name, last;\n    int age;\n    User({this.name, this.last, this.age});\n\n    @override\n    String toString() => '$name $last, $age years old';\n}\n\nfinal user = User(name: 'Khang', last: 'Huỳnh', age: 33).obs;\n\n// `user` is \"reactive\", but the properties inside ARE NOT!\n// So, if we change some variable inside of it...\nuser.value.name = 'Kaiser';\n// The widget will not rebuild!,\n// `Rx` don't have any clue when you change something inside user.\n// So, for custom classes, we need to manually \"notify\" the change.\nuser.refresh();\n\n// or we can use the `update()` method!\nuser.update((value){\n  value.name='Kaiser';\n});\n\nprint( user );\n```\n\n## StateMixin\n\nMột cách khác để xử lý trạng thái `UI` của bạn là sử dụng`StateMixin <T>`.\nĐể triển khai nó, hãy sử dụng dấu `with` để thêm`StateMixin <T>` vào bộ điều khiển (controller) của bạn cho phép tích hợp kèm mô hình T.\n\n```dart\nclass Controller extends GetController with StateMixin<User>{}\n```\n\nPhương thức `change()` thay đổi trạng thái bất cứ khi nào chúng ta muốn.\nChỉ cần chuyển dữ liệu và trạng thái theo cách này:\n\n```dart\nchange(data, status: RxStatus.success());\n```\n\nRxStatus cho phép những trang thái này:\n\n```dart\nRxStatus.loading();\nRxStatus.success();\nRxStatus.empty();\nRxStatus.error('message');\n```\n\nĐể biểu hiện nó trên UI, sử dụng:\n\n```dart\nclass OtherClass extends GetView<Controller> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n\n      body: controller.obx(\n        (state)=>Text(state.name),\n\n        // here you can put your custom loading indicator, but\n        // by default would be Center(child:CircularProgressIndicator())\n        onLoading: CustomLoadingIndicator(),\n        onEmpty: Text('No data found'),\n\n        // here also you can set your own error widget, but by\n        // default will be an Center(child:Text(error))\n        onError: (error)=>Text(error),\n      ),\n    );\n}\n```\n\n#### GetView\n\nWidget này là bảo bối của GetX, rất đơn giản, nhưng rất hữu ích!\n\nLà một Widget `const Stateless` có getter` controller` cho một `Controller` đã đăng ký, chỉ vậy thôi người ơi~.\n\n```dart\n class AwesomeController extends GetController {\n   final String title = 'My Awesome View';\n }\n\n  // ALWAYS remember to pass the `Type` you used to register your controller!\n class AwesomeView extends GetView<AwesomeController> {\n   @override\n   Widget build(BuildContext context) {\n     return Container(\n       padding: EdgeInsets.all(20),\n       child: Text(controller.title), // just call `controller.something`\n     );\n   }\n }\n```\n\n#### GetResponsiveView\n\nMở rộng tiện ích này để xây dựng chế độ responsive.\nWidget này chứa thuộc tính `screen` có tất cả\nthông tin về kích thước và loại màn hình.\n\n##### Hướng dẫn sử dụng trước khi dùng\n\nBạn có hai lựa chọn để xây dựng nó.\n\n- với phương thức `builder` bạn trả về tiện ích con để xây dựng.\n- với các phương thức `desktop`,` tablet`, `phone`,` watch`. cụ thể, các phương thức này sẽ tạo các loại màn hình khớp với ngữ cảnh khi màn hình là [ScreenType.Tablet] thì phương thức `tablet` sẽ được tạo ra và cứ như vậy.\n  **Chú ý:** Nếu bạn dùng cái này, nhớ đặt `alwaysUseBuilder` thành `false`\n\nVới thuộc tính `settings` bạn có thể đặt chiều dài tối thiểu cho các loại màn hình.\n\n![example](https://github.com/SchabanBo/get_page_example/blob/master/docs/Example.gif?raw=true)\nCode to this screen\n[code](https://github.com/SchabanBo/get_page_example/blob/master/lib/pages/responsive_example/responsive_view.dart)\n\n#### GetWidget\n\nHầu hết mọi người không biết gì về Widget này, hoặc hoàn toàn nhầm lẫn về cách sử dụng nó.\nTrường hợp sử dụng rất hiếm, nhưng rất cụ thể: Nó `caches` một Bộ điều khiển.\nBởi vì _cache_ không thể là một `const Stateless`.\n\n> Vậy khi nào mình cần cache bộ điều khiển (controller)?\n\nNếu sử dụng, bạn sẽ dùng cái này **GetX**: `Get.create()`.\n\n`Get.create(()=>Controller())` sẽ tạo một `Controller` với mỗi lần gọi `Get.find<Controller>()`,\n\nĐó là nơi mà `GetWidget` tỏa sáng ... chẳng hạn như bạn có thể sử dụng nó, để giữ một danh sách các mục Todo. Vì vậy, nếu widget được \"xây dựng lại\", nó sẽ giữ nguyên phiên bản controller.\n\n#### GetxService\n\nClass này giống như một `GetxController`, nó chia sẻ cùng một vòng đời (`onInit ()`,`onReady ()`,`onClose ()`).\nNhưng không có \"logic\" bên trong của nó. Nó chỉ thông báo cho ** GetX ** Hệ thống Nạp Dependency rằng class con này ** không thể ** bị xóa khỏi bộ nhớ.\n\nVì vậy, rất hữu ích để giữ cho \"Service\" của bạn luôn có thể truy cập và hoạt động với `Get.find ()`. Giống:\n`ApiService`,` StorageService`, `CacheService`.\n\n```dart\nFuture<void> main() async {\n  await initServices(); /// AWAIT SERVICES INITIALIZATION.\n  runApp(SomeApp());\n}\n\n/// Is a smart move to make your Services intiialize before you run the Flutter app.\n/// as you can control the execution flow (maybe you need to load some Theme configuration,\n/// apiKey, language defined by the User... so load SettingService before running ApiService.\n/// so GetMaterialApp() doesnt have to rebuild, and takes the values directly.\nvoid initServices() async {\n  print('starting services ...');\n  /// Here is where you put get_storage, hive, shared_pref initialization.\n  /// or moor connection, or whatever that's async.\n  await Get.putAsync(() => DbService().init());\n  await Get.putAsync(SettingsService()).init();\n  print('All services started...');\n}\n\nclass DbService extends GetxService {\n  Future<DbService> init() async {\n    print('$runtimeType delays 2 sec');\n    await 2.delay();\n    print('$runtimeType ready!');\n    return this;\n  }\n}\n\nclass SettingsService extends GetxService {\n  void init() async {\n    print('$runtimeType delays 1 sec');\n    await 1.delay();\n    print('$runtimeType ready!');\n  }\n}\n\n```\n\nCách duy nhất để thực sự xóa một `GetxService`, là với `Get.reset ()` giống như cách thức \"Khởi động nóng\" ứng dụng của bạn. Vì vậy, hãy nhớ rằng, nếu bạn cần sự tồn tại tuyệt đối của một class trong vòng đời tồn tại của nó trong ứng dụng của bạn, hãy sử dụng `GetxService`.\n\n# Thay đổi đột phá 2.0\n\n1- Rx types:\n\n| Before  | After      |\n| ------- | ---------- |\n| StringX | `RxString` |\n| IntX    | `RxInt`    |\n| MapX    | `RxMap`    |\n| ListX   | `RxList`   |\n| NumX    | `RxNum`    |\n| DoubleX | `RxDouble` |\n\nRxController và GetBuilder bây giờ đã hợp nhất, bạn không cần phải ghi nhớ bộ điều khiển nào bạn muốn sử dụng, chỉ cần sử dụng GetxController, nó sẽ hoạt động để quản lý trạng thái đơn giản và reactive.\n\n2- NamedRoutes\nBefore:\n\n```dart\nGetMaterialApp(\n  namedRoutes: {\n    '/': GetRoute(page: Home()),\n  }\n)\n```\n\nNow:\n\n```dart\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page: () => Home()),\n  ]\n)\n```\n\nTại sao lại thay đổi?\nThông thường, có thể cần phải quyết định trang nào sẽ được hiển thị từ một tham số hoặc mã thông báo đăng nhập, cách tiếp cận trước đây không linh hoạt, vì nó không cho phép điều này.\nViệc chèn trang vào một hàm đã làm giảm đáng kể mức tiêu thụ RAM, vì các tuyến sẽ không được cấp phát trong bộ nhớ kể từ khi ứng dụng được khởi động và nó cũng cho phép thực hiện kiểu tiếp cận này:\n\n```dart\n\nGetStorage box = GetStorage();\n\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page:(){\n      return box.hasData('token') ? Home() : Login();\n    })\n  ]\n)\n```\n\n# Tại sao lại dùng GetX\n\n1- Nhiều lần sau khi cập nhật Flutter, nhiều package của bạn sẽ bị hỏng. Đôi khi lỗi biên dịch code xảy ra, lỗi thường xuất hiện mà vẫn không có câu trả lời; và, chúng ta, nhà phát triển, cần biết lỗi đến từ đâu, theo dõi lỗi, chỉ sau đó cố gắng mở một vấn đề trong kho lưu trữ tương ứng và xem vấn đề của nó đã được giải quyết. Tập trung các tài nguyên chính để phát triển (Quản lý state, dependency và route), cho phép bạn thêm một gói duy nhất vào pubspec của mình và bắt đầu hoạt động. Sau khi cập nhật Flutter, điều duy nhất bạn cần làm là cập nhật Get dependency và bắt đầu làm việc. Get cũng giải quyết các vấn đề tương thích. Có bao nhiêu lần một phiên bản của một gói không tương thích với phiên bản của gói khác, vì một gói sử dụng phần phụ thuộc trong một phiên bản và gói kia trong phiên bản khác? Đây cũng không phải là vấn đề đáng lo ngại khi sử dụng Get, vì mọi thứ đều nằm trong cùng một gói và hoàn toàn tương thích.\n\n2- Flutter dễ học, Flutter siêu phàm, nhưng Flutter vẫn có một số bản soạn sẵn có thể không mong muốn đối với hầu hết các nhà phát triển, chẳng hạn như `Navigator.of (context) .push (context, builder [...] '. Get đơn giản hóa việc phát triển. Thay vì viết 8 dòng mã chỉ để gọi một tuyến đường, bạn chỉ cần làm điều đó: `` Get.to (Home ()) 'và bạn đã hoàn tất, bạn sẽ chuyển sang trang tiếp theo. Các url web động là một điều thực sự khó khăn để làm với Flutter hiện tại và điều đó với GetX đơn giản đến đần độn :). Quản lý trạng thái trong Flutter và quản lý các phần phụ thuộc cũng là điều tạo ra nhiều cuộc thảo luận, vì có hàng trăm mẫu trong pub (Dart package website). Nhưng không có gì dễ dàng bằng việc thêm \".obs\" ở cuối biến của bạn, và đặt tiện ích của bạn bên trong Obx, và thế là xong, tất cả các cập nhật cho biến đó sẽ được tự động cập nhật trên màn hình.\n\n3- Dễ dàng mà không phải lo lắng về hiệu suất. Hiệu suất của Flutter đã đáng kinh ngạc rồi, nhưng hãy tưởng tượng rằng bạn sử dụng trình quản lý state và trình định vị để phân phối các Blocs / stores / controllers / v.v. của bạn. Bạn sẽ phải gọi thủ công loại trừ sự phụ thuộc khi bạn không cần đến chúng. Nhưng bạn đã bao giờ nghĩ chỉ cần sử dụng bộ điều khiển của mình và khi nó không còn được ai sử dụng nữa, nó sẽ đơn giản được xóa khỏi bộ nhớ? Đó là những gì GetX làm. Với SmartManagement, mọi thứ không được sử dụng sẽ được xóa khỏi bộ nhớ và bạn không phải lo lắng về bất cứ điều gì ngoài lập trình. Bạn sẽ được đảm bảo rằng bạn đang sử dụng các nguồn tài nguyên cần thiết tối thiểu mà thậm chí không cần tạo ra một logic nào cho việc này.\n\n4- Tách khỏi thực tế. Bạn có thể đã nghe đến khái niệm \"tách khung nhìn (view) khỏi business logic\". Đây không phải là đặc thù của BLoC, MVC, MVVM và bất kỳ tiêu chuẩn nào khác trên thị trường đều có khái niệm này. Tuy nhiên, khái niệm này thường có thể được giảm thiểu trong Flutter do việc sử dụng ngữ cảnh (context).\nNếu bạn cần ngữ cảnh để tìm một InheritedWidget, bạn cần nó trong dạng xem hoặc chuyển ngữ cảnh theo tham số. Tôi đặc biệt thấy giải pháp này rất chán đời; hơn nữa, để làm việc theo nhóm, chúng tôi sẽ luôn phụ thuộc vào business logic của View. GetX không chính thống với cách tiếp cận tiêu chuẩn và mặc dù nó không cấm hoàn toàn việc sử dụng StatefulWidgets, InitState, v.v., nhưng nó luôn có một cách tiếp cận tương tự có thể rõ ràng hơn. Controller có vòng đời và khi bạn cần thực hiện yêu cầu APIREST chẳng hạn, bạn độc lập với View. Bạn có thể sử dụng onInit để bắt đầu cuộc gọi http và khi dữ liệu đến, các biến sẽ được điền. Vì GetX hoạt động hoàn toàn reactive (đó là sự thực và hoạt động theo luồng), khi các mục được lấp đầy, tất cả tiện ích con sử dụng biến đó sẽ được cập nhật tự động trong View. Điều này cho phép những người có chuyên môn về UI chỉ làm việc với các widget và không phải gửi bất kỳ thứ gì đến logic nghiệp vụ ngoài các sự kiện của người dùng (như nhấp vào nút), trong khi những người làm việc với logic nghiệp vụ sẽ được tự do tạo và kiểm tra logic nghiệp vụ riêng.\n\nThư viện này sẽ luôn được cập nhật và triển khai các tính năng mới. Hãy thoải mái đưa ra các bài PR và đóng góp cho chúng.\n\n# Cộng đồng\n\n## Kênh Cộng đồng\n\nGetX có một cộng đồng rất tích cực và hữu ích. Nếu bạn có thắc mắc hoặc muốn được hỗ trợ về việc sử dụng khuôn khổ này, vui lòng tham gia các kênh cộng đồng của chúng tôi, câu hỏi của bạn sẽ được trả lời nhanh hơn và đó sẽ là nơi phù hợp nhất. Kho lưu trữ này dành riêng cho các vấn đề mở và yêu cầu tài nguyên, nhưng hãy thoải mái trở thành một phần của Cộng đồng GetX.\n\n| **Slack**                                                                                                                   | **Discord**                                                                                                                 | **Telegram**                                                                                                          |\n| :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |\n| [![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx) | [![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N) | [![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g) |\n\n## Cách cống hiến\n\n_Bạn muốn đóng góp cho dự án? Chúng tôi sẽ tự hào giới thiệu bạn với tư cách là một trong những cộng tác viên của chúng tôi. Dưới đây là một số điểm mà bạn có thể đóng góp và làm cho Get (và Flutter) tốt hơn nữa._\n\n- Giúp dịch readme sang các ngôn ngữ khác.\n- Thêm tài liệu vào readme (rất nhiều chức năng của Get chưa được tài liệu hóa).\n- Viết bài hoặc làm video dạy cách sử dụng Get (chúng sẽ được chèn vào Readme và trong tương lai trong Wiki của chúng tôi).\n- Đưa ra các PR cho mã / bài kiểm tra.\n- Bao gồm các chức năng mới.\n\nMọi đóng góp đều được hoan nghênh!\n\n## Các bài báo và video\n\n- [Flutter GetX EcoSystem package for arabic people](https://www.youtube.com/playlist?list=PLV1fXIAyjeuZ6M8m56zajMUwu4uE3-SL0) - Hướng dẫn bởi [Pesa Coder](https://github.com/UsamaElgendy).\n- [Dynamic Themes in 3 lines using GetX™](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Hướng dẫn bởi [Rod Brown](https://github.com/RodBr).\n- [Complete GetX™ Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI) - Quản lý route bởi Amateur Coder.\n- [Complete GetX State Management](https://www.youtube.com/watch?v=CNpXbeI_slw) - Quản lý State video by Amateur Coder.\n- [GetX™ Other Features](https://youtu.be/ttQtlX_Q0eU) - Utils, storage, bindings and other features video by Amateur Coder.\n- [Firestore User with GetX | Todo App](https://www.youtube.com/watch?v=BiV0DcXgk58) - Video by Amateur Coder.\n- [Firebase Auth with GetX | Todo App](https://www.youtube.com/watch?v=-H-T_BSgfOE) - Video by Amateur Coder.\n- [The Flutter GetX™ Ecosystem ~ State Management](https://medium.com/flutter-community/the-flutter-getx-ecosystem-state-management-881c7235511d) - Quản lý State by [Aachman Garg](https://github.com/imaachman).\n- [The Flutter GetX™ Ecosystem ~ Dependency Injection](https://medium.com/flutter-community/the-flutter-getx-ecosystem-dependency-injection-8e763d0ec6b9) - Nạp dependency by [Aachman Garg](https://github.com/imaachman).\n- [GetX, the all-in-one Flutter package](https://www.youtube.com/watch?v=IYQgtu9TM74) - Giới thiệu sơ lược về quản lý State and Navigation by Thad Carnevalli.\n- [Build a To-do List App from scratch using Flutter and GetX](https://www.youtube.com/watch?v=EcnqFasHf18) - UI + State Management + Storage video by Thad Carnevalli.\n- [GetX Flutter Firebase Auth Example](https://medium.com/@jeffmcmorris/getx-flutter-firebase-auth-example-b383c1dd1de2) - Article by Jeff McMorris.\n- [Flutter State Management with GetX – Complete App](https://www.appwithflutter.com/flutter-state-management-with-getx/) - by App With Flutter.\n- [Flutter Routing with Animation using Get Package](https://www.appwithflutter.com/flutter-routing-using-get-package/) - by App With Flutter.\n- [A minimal example on dartpad](https://dartpad.dev/2b3d0d6f9d4e312c5fdbefc414c1727e?) - by [Roi Peker](https://github.com/roipeker)\n"
        },
        {
          "name": "README.id-ID.md",
          "type": "blob",
          "size": 48.1142578125,
          "content": "![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n**Bahasa: Indonesia (file ini), [Inggris](README.md), [Orang Vietnam](README-vi.md), [Urdu](README.ur-PK.md), [China](README.zh-cn.md), [Portugis (Brazil)](README.pt-br.md), [Spanyol](README-es.md), [Russia](README.ru.md), [Polandia](README.pl.md), [Korea](README.ko-kr.md), [French](README-fr.md)**\n\n[![pub package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n[![popularity](https://badges.bar/get/popularity)](https://pub.dev/packages/sentry/score)\n[![likes](https://badges.bar/get/likes)](https://pub.dev/packages/get/score)\n[![pub points](https://badges.bar/get/pub%20points)](https://pub.dev/packages/get/score)\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n[![style: effective dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n[![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n[![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n<a href=\"https://github.com/Solido/awesome-flutter\">\n<img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n</a>\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n- [Tentang Get](#tentang-get)\n- [Instalasi](#instalasi)\n- [Aplikasi Counter menggunakan GetX](#aplikasi-counter-menggunakan-getx)\n- [Tiga Pilar](#tiga-pilar)\n  - [State management](#state-management)\n    - [Reactive State Manager](#reactive-state-manager)\n    - [Detail lebih lanjut mengenai state management](#detail-lebih-lanjut-mengenai-state-management)\n  - [Route management](#route-management)\n    - [Detail lebih lanjut mengenai route management](#detail-lebih-lanjut-mengenai-route-management)\n  - [Dependency management](#dependency-management)\n    - [Detail lebih lanjut mengenai dependency management](#detail-lebih-lanjut-mengenai-dependency-management)\n- [Utilitas](#utilitas)\n  - [Internasionalisasi](#internasionalisasi)\n    - [Translasi](#translasi)\n      - [Menggunakan Translasi](#menggunakan-translasi)\n    - [Lokalisasi](#lokalisasi)\n      - [Mengubah Lokal](#mengubah-lokal)\n      - [Lokal Sistem](#lokal-sistem)\n  - [Mengubah Tema](#mengubah-tema)\n  - [GetConnect](#getconnect)\n    - [Konfigurasi Default](#konfigurasi-default)\n    - [Konfigurasi Kustom](#konfigurasi-kustom)\n  - [GetPage Middleware](#getpage-middleware)\n    - [Prioritas](#prioritas)\n    - [Redirect](#redirect)\n    - [OnPageCalled](#onpagecalled)\n    - [OnBindingsStart](#onbindingsstart)\n    - [OnPageBuildStart](#onpagebuildstart)\n    - [OnPageBuilt](#onpagebuilt)\n    - [OnPageDispose](#onpagedispose)\n  - [API Lanjutan Lainnya](#api-lanjutan-lainnya)\n    - [Pengaturan Global Opsional dan Konfigurasi Manual](#pengaturan-global-opsional-dan-konfigurasi-manual)\n    - [Local State Widgets](#local-state-widgets)\n      - [ValueBuilder](#valuebuilder)\n      - [ObxValue](#obxvalue)\n  - [Tips berguna](#tips-berguna)\n      - [GetView](#getview)\n      - [GetResponsiveView](#getresponsiveview)\n        - [Cara pakai](#cara-pakai)\n      - [GetWidget](#getwidget)\n      - [GetxService](#getxservice)\n- [Breaking change dari 2.0](#breaking-change-dari-20)\n- [Mengapa Getx?](#mengapa-getx)\n- [Komunitas](#komunitas)\n  - [Channel Komunitas](#kanal-komunitas)\n  - [Cara berkontribusi](#cara-berkontribusi)\n  - [Artikel dan Video](#artikel-dan-video)\n\n# Tentang Get\n\n- GetX adalah solusi ekstra-ringan dan powerful untuk Flutter. Ini mengkombinasikan state management dengan performa tinggi, injeksi dependensi yang cerdas, dan route management secara singkat dan praktis.\n\n- GetX memiliki 3 prinsip dasar, yang menjadi prioritas untuk semua resource yang ada di dalamnya: **PRODUKTIFITAS, PERFORMA DAN ORGANISASI**\n\n  - **PERFORMA:** GetX fokus pada performa dan konsumsi resource minimum. GetX tidak menggunakan Stream atau ChangeNotifier.\n\n  - **PRODUKTIFITAS:** GetX menggunakan sintaks yang mudah dan nyaman. Tidak peduli apa yang akan anda lakukan, akan selalu ada cara yang lebih mudah dengan GetX. Ini akan menghemat waktu development, dan meng-ekstrak performa maksimum pada aplikasi anda.\n  Umumnya, developer akan selalu berhubungan dengan penghapusan controller dari memori. Dengan GetX, ini tidak diperlukan, karena resource akan dihapus dari memori secara default ketika tidak digunakan. Jika anda ingin menyimpannnya kedalam memori, anda harus secara eksplisit mendeklarasikan \"permanent: true\" pada dependensi anda. Dengan begitu, selain menghemat waktu, anda juga mengurangi resiko memiliki dependensi yang tidak diperlukan dalam memori. Pemuatan dependensi juga bersifat \"lazy\" secara default.\n\n  - **ORGANISASI:** GetX memungkinkan pemisahan View, Presentation Logic, Business Logic, Dependency Injection, dan Navigasi.\n  Anda tidak perlu konteks untuk berpindah antar halaman. Jadi, anda tidak lagi bergantung pada widget tree (visualisasi) untuk hal ini. Anda tidak perlu konteks untuk mengakses controller/bloc melalui InheritedWidget. Dengan ini, anda benar benar memisahkan presentation logic dan business logic dari lapisan visual. Anda tidak perlu menginjeksi kelas Controller/Model/Bloc kedalam widget tree melalui multiprovider, untuk hal ini GetX menggunakan fitur dependency injection nya sendiri, memisahkan DI dari View secara total.\n  Dengan GetX, anda tahu dimana harus mencari setiap fitur dalam aplikasi anda, memiliki kode yang bersih secara default. Ini selain untuk memfasilitasi maintenance, membuat pembagian modul, sesuatu yang hingga saat itu di Flutter tidak terpikirkan, sesuatu yang sangat mungkin.\n  BLoC adalah permulaan awal dalam meng-organisir kode di Flutter, ini memisahkan business logic dari visualisasi. GetX adalah evolusi natural dari ini, tidak hanya memisahkan business logic, tapi juga presentation logic. Injeksi dependensi dan route juga dipisahkan sebagai bonus, dan lapisan data benar-benar terpisah secara menyeluruh. Anda tahu dimana semuanya berada, dan segalanya dengan cara yang lebih mudah daripada membuat sebuah hello world.\n  GetX adalah cara termudah, praktis, dan scalable untuk membangun aplikasi dengan performa tinggi menggunakan Flutter SDK, dengan ekosistem besar di sekelilingnya yang bekerjasama secara sempurna, mudah dipahami untuk pemula, dan akurat untuk ahli. Aman, stabil, up-to-date, dan menawarkan banyak cakupan build-in API yang tidak tersedia di dalam default Flutter SDK.\n\n- GetX tidak \"bloated\". Dirinya memiliki banyak fitur yang memungkinkan anda memulai programming tanpa mengkhawatirkan apapun, namun setiap fiturnya terletak didalam kontainer terpisah, dan hanya dimulai setelah digunakan. Jika anda hanya menggunakan State Management, hanya State Management yang akan di-compile. Jika anda hanya menggunakan routes, state management tidak akan di-compile.\n\n- GetX memiliki ekosistem yang besar, komunitas yang juga besar, banyak kolaborator, dan akan di maintenance selama Flutter ada. GetX juga mampu berjalan dengan kode yang sama di Android, iOS, Web, Mac, Linux, Windows, dan server anda.\n**Juga memungkinkan untuk me-reuse kode yang dibuat di frontend ke backend dengan [Get Server](https://github.com/jonataslaw/get_server)**.\n\n**Selain itu, seluruh proses development bisa di automasi secara menyeluruh, untuk keduanya (server dan frontend) menggunakan [Get CLI](https://github.com/jonataslaw/get_cli)**.\n\n**Selain itu, untuk lebih meningkatkan produktifitas anda, kami memiliki [ekstensi untuk VSCode](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets) dan [ekstensi untuk Android Studio/Intellij](https://plugins.jetbrains.com/plugin/14975-getx-snippets)**\n\n# Instalasi\n\nTambahkan Get kedalam file `pubspec.yaml` anda:\n\n```yaml\ndependencies:\n  get:\n```\n\nImport get didalam file dimana get akan digunakan:\n\n```dart\nimport 'package:get/get.dart';\n```\n\n# Aplikasi Counter menggunakan GetX\n\nProyek \"counter\" yang dibuat secara default ketika membuat proyek Flutter memiliki lebih dari 100 baris (termasuk comment). Untuk menunjukkan kekuatan Get, kami akan mendemonstrasikan bagaimana cara membuat \"counter\" yang mengubah state setiap klik, berpindah, dan berbagi state antar halaman, semua dalam cara yang terorganisir, memisahkan business logic dari view, dalam HANYA 26 BARIS KODE TERMASUK COMMENT.\n\n- Langkah 1:\n  Tambahkan \"Get\" sebelum MaterialApp, mengubahnya menjadi GetMaterialApp\n\n```dart\nvoid main() => runApp(GetMaterialApp(home: Home()));\n```\n\n- Catatan: ini tidak mengubah MaterialApp bawaan Flutter, GetMaterialApp bukan sebuah MaterialApp yang dimodifikasi, itu hanyalah sebuah Widget yang telah dikonfigurasi sebelumnya, yang mana memiliki default MaterialApp sebagai child. Anda bisa mengkonfigurasinya secara manual, namun hal itu benar-benar tidak diperlukan. GetMaterialApp akan membuat route, menginjeksinya, menginjeksi translasi/terjemahan, dan semua yang anda butuhkan untuk navigasi route. Jika anda hanya menggunakan Get untuk manajemen state atau manajemen dependensi, tidak perlu menggunakan GetMaterialApp. GetMaterialApp diperlukan untuk route, snackbar, internasionalisasi/terjemahan, bottomSheet, dialog, dan high-level API yang berhubungan dengan route dan ketiadaan konteks.\n\n- Catatan²: Langkah ini hanya diperlukan jika anda akan menggunakan manajemen route (`Get.to()`, `Get.back()` dan seterusnya). Jika anda tidak menggunakannya, langkah 1 tidak diperlukan.\n\n- Langkah 2:\n  Buat file baru untuk business logic dan taruh semua variabel, metode, dan kontroler didalamnya.\n  Anda bisa membuat variabel apapun menjadi \"observable\" menggunakan notasi tambahan \".obs\".\n\n```dart\nclass Controller extends GetxController{\n  var count = 0.obs;\n  increment() => count++;\n}\n```\n\n- Langkah 3:\n  Buat file baru untuk View, gunakan StatelessWidget dan hemat penggunaan RAM, dengan Get, anda mungkin tidak perlu lagi menggunakan StatefulWidget.\n\n```dart\nclass Home extends StatelessWidget {\n\n  @override\n  Widget build(context) {\n\n    // Instansiasi kelas anda menggunakan Get.put() untuk membuatnya tersedia untuk seluruh \"child\" route dibawahnya.    \n    final Controller c = Get.put(Controller());\n\n    return Scaffold(\n      // Gunakan Obx(() => ...) untuk mengupdate Text() ketika `count` berubah.\n      appBar: AppBar(title: Obx(() => Text(\"Clicks: ${c.count}\"))),\n\n      // Ganti 8 baris Navigator.push menggunan Get.to() agar lebih sederhana. Anda tidak perlu `context`.\n      body: Center(child: ElevatedButton(\n              child: Text(\"Go to Other\"), onPressed: () => Get.to(Other()))),\n      floatingActionButton:\n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n  }\n}\n\nclass Other extends StatelessWidget {\n  // Anda bisa meminta Get untuk menemukan kontroler yang digunakan di halaman lain dan redirect ke halaman itu.\n  final Controller c = Get.find();\n\n  @override\n  Widget build(context){\n     // Akses variabel `count` yang telah di update.\n     return Scaffold(body: Center(child: Text(\"${c.count}\")));\n  }\n}\n```\n\nHasil:\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/counter-app-gif.gif)\n\nIni adalah proyek sederhana, namun sudah membuatnya terlihat jelas betapa powerful kemampuan yang dimiliki Get. Sepanjang proyek anda berkembang, perbedaan ini akan menjadi lebih signifikan.\n\nGet di desain untuk bekerja dalam tim, namun juga memudahkan pekerjaan untuk developer perseorangan dan membuatnya menjadi lebih sederhana.\n\nTingkatkan deadline anda, antarkan semuanya tanpa kehilangan performa. Get bukan untuk semua orang, namun jika anda tersinggung dengan frasa tersebut, Get cocok untukmu!\n\n# Tiga Pilar\n\n## State management\n\nGet memiliki dua state manager berbeda: Simple state manager (kami menyebutnya GetBuilder) dan Reactive state manager (GetX/Obx)\n\n### Reactive State Manager\n\nReactive programming bisa meng-alienasi banya orang karena katanya, sulit dimengerti. GetX mengubah reactive programming menjadi sesuatu yang cukup sederhana:\n\n- Anda tidak perlu membuat StreamController.\n- Anda tidak perlu membuat StreamBuilder untuk setiap variabel.\n- Anda tidak perlu membuat kelas untuk setiap state.\n- Anda tidak perlu membuat get untuk sebuah value awal (initial value).\n- Anda tidak perlu menggunakan generator kode.\n\nReactive programming dengan Get semudah menggunakan setState.\n\nBayangkan anda memiliki variabel nama, dan setiap kali anda mengubahnya, semua widget yang menggunakannya akan berubah secara otomatis.\n\nIni variabel count anda:\n\n```dart\nvar name = 'Jonatas Borges';\n```\n\nUntuk membuatnya \"observable\", anda hanya perlu menambahkan \".obs\" di belakangnya:\n\n```dart\nvar name = 'Jonatas Borges'.obs;\n```\n\nDan didalam UI, ketika anda ingin menampilkan value dan update tampilan ketika value itu berubah, cukup lakukan ini:\n\n```dart\nObx(() => Text(\"${controller.name}\"));\n```\n\nSelesai! _Sesederhana_ itu.\n\n### Detail lebih lanjut mengenai state management\n\n**Baca penjelasan lebih lanjut tentang state management [disini](./documentation/id_ID/state_management.md). Disana anda akan melihat contoh lebih banyak dan juga perbedaan diantara simple state manager dengan reactive state manager**\n\nAnda akan mendapatkan pemahaman yang baik tentang kekuatan dari GetX.\n\n## Route management\n\nJika anda ingin menggunakan routes/snackbars/dialogs/bottomsheets tanpa context, GetX luar biasa cocok untuk anda, lihat ini:\n\nTambahkan \"Get\" sebelum MaterialApp, mengubahnya menjadi GetMaterialApp\n\n```dart\nGetMaterialApp( // Sebelumnya: MaterialApp(\n  home: MyHome(),\n)\n```\n\nPindah ke halaman baru:\n\n```dart\n\nGet.to(NextScreen());\n```\n\nPindah ke halaman baru menggunakan nama. Baca detail lebih lanjut tentang penamaan route [disini](./documentation/id_ID/route_management.md#navigation-with-named-routes)\n\n```dart\n\nGet.toNamed('/details');\n```\n\nUntuk menutup snackbar, dialog, bottomsheet, atau apapun yang normalnya anda tutup menggunakan Navigator.pop(context);\n\n```dart\nGet.back();\n```\n\nUntuk pergi ke halaman baru dan mencegah user kembali ke halaman sebelumnya (biasanya digunakan untuk SplashScreen, LoginScreen, dsb).\n\n```dart\nGet.off(NextScreen());\n```\n\nUntuk pergi ke halaman baru dan batalkan navigasi sebelumnya (berguna untuk shopping cart, polls, dan test).\n\n```dart\nGet.offAll(NextScreen());\n```\n\nSadarkah bahwa anda tidak menggunakan context sama sekali untuk hal tersebut? Itu adalah keuntungan terbesar dalam menggunakan Get route management. Dengan ini, anda bisa mengeksekusi semua metode dari controller, tanpa ragu.\n\n### Detail lebih lanjut mengenai route management\n\n**Get bekerja dengan named route dan juga menawarkan kontrol dengan level yang lebih rendah untuk navigasimu! Dokumentasinya ada [disini](./documentation/id_ID/route_management.md)**\n\n## Dependency management\n\nGet memiliki dependency manager sederhana dan powerful yang memungkinkan anda mendapatkan kelas yang setara dengan Bloc atau Controller hanya dengan 1 baris kode, tanpa Provider context, tanpa inheritedWidget:\n\n```dart\nController controller = Get.put(Controller());\n```\n\n- Catatan: Jika anda menggunakan State Manager milik Get, harap untuk lebih memperhatikan [Bindings](./documentation/id_ID/dependency_management.md#bindings) api, yang mana akan membuat pengkoneksian View terhadap Controller jadi lebih mudah.\n\nDaripada menginstansiasi kelas anda didalam kelas yang anda gunakan, cukup lakukan hal itu di dalam Get instance, ini akan membuatnya tersedia di semua tempat di Aplikasimu. Jadi anda bisa menggunakan controller (atau class Bloc) secara normal.\n\n**Tips:** Dependency Management Get terpisah dari bagian lain dari package, jadi jika sebagai contoh aplikasi anda sudah menggunakan state manager (tidak peduli apapun itu), anda tidak perlu menulis ulang sama sekali, anda bisa menggunakan dependency injection tanpa masalah.\n\n```dart\ncontroller.fetchApi();\n```\n\nBayangkan anda bernavigasi melewati route yang sangat banyak, dan anda membutuhkan data yang tertinggal didalam controller jauh di belakang route sebelumnya, anda akan butuh state manager dikombinasikan dengan Provider atau Get_it, benar kan? Tidak dengan Get. Anda hanya perlu meminta Get untuk \"menemukan\" controllernya, anda tidak perlu dependensi tambahan:\n\n```dart\nController controller = Get.find();\n// Ya, terlihat seperti Sulap, Get akan menemukan controller anda, dan akan mengantarkannya ke lokasi anda.\n// Anda bisa memiliki 1 juta controller terinisialisasi, Get akan selalu memberimu controller yang tepat.\n```\n\nDan setelahnya anda bisa memperoleh data yang tertinggal sebelumnya:\n\n```dart\nText(controller.textFromApi);\n```\n\n### Detail lebih lanjut mengenai dependency management\n\n**Baca penjelasan lebih lanjut tentang dependency management [disini](./documentation/id_ID/dependency_management.md)**\n\n# Utilitas\n\n## Internasionalisasi\n\n### Translasi\n\nTranslasi disimpan sebagai key-value map sederhana.\nUntuk menambahkan translasi kustom, buat sebuah kelas dan extend `Translations`.\n\n```dart\nimport 'package:get/get.dart';\n\nclass Messages extends Translations {\n  @override\n  Map<String, Map<String, String>> get keys => {\n        'en_US': {\n          'hello': 'Hello World',\n        },\n        'id_ID': {\n          'hello': 'Halo Dunia',\n        }\n      };\n}\n```\n\n#### Menggunakan Translasi\n\nCukup tambahkan `.tr` setelah key yang disebutkan dan value nya akan diterjemahkan, menggunakan value awal dari `Get.locale` dan `Get.fallbackLocale`.\n\n```dart\nText('title'.tr);\n```\n\n### Lokalisasi\n\nBerikan parameter ke `GetMaterialApp` untuk mendefinisikan lokal dan translasi.\n\n```dart\nreturn GetMaterialApp(\n    translations: Messages(), // gunakan translasi yang anda buat\n    locale: Locale('id', 'ID'), // translasi akan ditampilkan di lokal ini\n    fallbackLocale: Locale('en', 'US'), // berikan lokal penumpu untuk berjaga-jaga jika lokal yang tidak valid dipilih\n);\n```\n\n#### Mengubah Lokal\n\nPanggil `Get.updateLocale(locale)` untuk memperbarui lokal. Setelahnya, translasi akan menggunakan lokal baru.\n\n```dart\nvar locale = Locale('en', 'US');\nGet.updateLocale(locale);\n```\n\n#### Lokal Sistem\n\nUntuk membaca lokal sistem, anda bisa menggunakan `Get.deviceLocale`.\n\n```dart\nreturn GetMaterialApp(\n    locale: Get.deviceLocale,\n);\n```\n\n## Mengubah Tema\n\nHarap untuk tidak menggunakan widget dengan level lebih tinggi daripada `GetMaterialApp` untuk memperbaruinya. Ini akan menyebabkan \"duplicate keys\". Banyak orang terbiasa menggunakan cara lama untuk membuat sebuah \"ThemeProvider\" widget hanya untuk mengubah tema aplikasi anda, dan ini tentu saja TIDAK diperlukan dengan **GetX™**.\n\nAnda bisa membuat tema kustom anda sendiri dan cukup menambahkannya kedalam `Get.changeTheme` tanpa boilerplate:\n\n```dart\nGet.changeTheme(ThemeData.light());\n```\n\nJika anda ingin membuat sesuatu seperti tombol yang mengubah Tema ketika `onPressed`, anda bisa mengkombinasikan dua **GetX™** API:\n\n- API yang melakukan pengecekan terhadap tema gelap `Get.isDarkMode`.\n- Dan API pengubah tema `Get.changeTheme`, anda cukup meletakannya didalam `onPressed`:\n\n```dart\nGet.changeTheme(Get.isDarkMode? ThemeData.light(): ThemeData.dark());\n```\n\nKetika `.darkmode` aktif, ini akan mengubah aplikasi anda ke _light theme_, dan sebaliknya, jika _light theme_ sedang aktif, ini akan mengubah aplikasi anda ke _dark theme_.\n\n## GetConnect\n\nGetConnect adalah cara mudah untuk berkomunikasi dari backend ke frontend menggunakan http atau websocket.\n\n### Konfigurasi Default\n\nAnda bisa secara sederhana meng-extend GetConnect dan menggunakan GET/POST/PUT/DELETE/SOCKET untuk berkomunikasi dengan REST API atau Websocket anda.\n\n```dart\nclass UserProvider extends GetConnect {\n  // Get request\n  Future<Response> getUser(int id) => get('http://youapi/users/$id');\n  // Post request\n  Future<Response> postUser(Map data) => post('http://youapi/users', body: data);\n  // Post request dengan File\n  Future<Response<CasesModel>> postCases(List<int> image) {\n    final form = FormData({\n      'file': MultipartFile(image, filename: 'avatar.png'),\n      'otherFile': MultipartFile(image, filename: 'cover.png'),\n    });\n    return post('http://youapi/users/upload', form);\n  }\n\n  GetSocket userMessages() {\n    return socket('https://yourapi/users/socket');\n  }\n}\n```\n\n### Konfigurasi Kustom\n\nGetConnect sangat bisa di disesuaikan, anda bisa mendefinisikan base URL, Response Modifier, Request Modifier, Authenticator, dan bahkan jumlah percobaan akses ulang (retry) yang mana akan mencoba meng-autentikasi dirinya sendiri, sebagai tambahan, anda juga bisa mendefinisikan dekoder standar yang akan mengubah seluruh request kedalam Model anda tanpa konfigurasi tambahan.\n\n```dart\nclass HomeProvider extends GetConnect {\n  @override\n  void onInit() {\n    // Semua request akan melewati jsonEncode, jadi, CasesModel.fromJson()\n    httpClient.defaultDecoder = CasesModel.fromJson;\n    httpClient.baseUrl = 'https://api.covid19api.com';\n    // baseUrl = 'https://api.covid19api.com'; // Ini akan men-setting baseUrl ke\n    // Http dan websocket jika digunakan tanpa [httpClient]\n\n    // Ini akan mengaitkan properti 'apikey' kedalam header dari semua request.\n    httpClient.addRequestModifier((request) {\n      request.headers['apikey'] = '12345678';\n      return request;\n    });\n\n    // Bahkan jika server mengirim data dari negara \"Brazil\"\n    // itu tidak akan pernah ditampilkan ke user, karena anda menghapus\n    // data tersebut sebelum response, bahkan sebelum response diantarkan.\n    httpClient.addResponseModifier<CasesModel>((request, response) {\n      CasesModel model = response.body;\n      if (model.countries.contains('Brazil')) {\n        model.countries.remove('Brazilll');\n      }\n    });\n\n    httpClient.addAuthenticator((request) async {\n      final response = await get(\"http://yourapi/token\");\n      final token = response.body['token'];\n      // Sesuaikan header\n      request.headers['Authorization'] = \"$token\";\n      return request;\n    });\n\n    // Authenticator akan dipanggil 3 kali jika\n    // HttpStatus == HttpStatus.unauthorized\n    httpClient.maxAuthRetries = 3;\n  }\n  }\n\n  @override\n  Future<Response<CasesModel>> getCases(String path) => get(path);\n}\n```\n\n## GetPage Middleware\n\nGetPage sekarang memiliki properti baru yang menerima list GetMiddleware dan menjalankannya dalam urutan spesifik.\n\n**Catatan**: Ketika GetPage memiliki middleware, seluruh child dari halaman tersebut akan secara otomatis memiliki middleware yang sama.\n\n### Prioritas\n\nUrutan dari Middleware yang akan dijalankan bisa diatur berdasarkan prioritas didalam GetMiddleware.\n\n```dart\nfinal middlewares = [\n  GetMiddleware(priority: 2),\n  GetMiddleware(priority: 5),\n  GetMiddleware(priority: 4),\n  GetMiddleware(priority: -8),\n];\n```\n\nmiddleware diatas akan dijalankan dengan urutan sebagai berikut **-8 => 2 => 4 => 5**\n\n### Redirect\n\nFungsi ini akan terpanggil ketika halaman dari route yang dipanggil sedang dicari. RouteSettings diperlukan untuk mengatur tujuan dari fungsi redirect. Atau berikan null jika tidak ingin ada redirect.\n\n```dart\nRouteSettings redirect(String route) {\n  final authService = Get.find<AuthService>();\n  return authService.authed.value ? null : RouteSettings(name: '/login')\n}\n```\n\n### OnPageCalled\n\nFungsi ini akan terpanggil ketika halaman yang dituju dipanggil sebelum apapun dibuat,\nanda bisa menggunakannya untuk mengubah sesuatu tentang halaman tersebut atau\nberikan halaman baru.\n\n```dart\nGetPage onPageCalled(GetPage page) {\n  final authService = Get.find<AuthService>();\n  return page.copyWith(title: 'Welcome ${authService.UserName}');\n}\n```\n\n### OnBindingsStart\n\nFungsi ini akan terpanggil tepat sebelum Binding ter-inisialisasi.\nDisini anda bisa mengubah Binding untuk halaman yang dituju.\n\n```dart\nList<Bindings> onBindingsStart(List<Bindings> bindings) {\n  final authService = Get.find<AuthService>();\n  if (authService.isAdmin) {\n    bindings.add(AdminBinding());\n  }\n  return bindings;\n}\n```\n\n### OnPageBuildStart\n\nFungsi ini akan terpanggil tepat setelah Binding ter-inisialisasi.\nDisini anda bisa melakukan sesuatu sebelum halaman yang dituju dibuat.\n\n```dart\nGetPageBuilder onPageBuildStart(GetPageBuilder page) {\n  print('bindings are ready');\n  return page;\n}\n```\n\n### OnPageBuilt\n\nFungsi ini akan terpanggil tepat setelah fungsi `GetPage.page` terpanggil dan akan memberikan anda hasil dari fungsinya. Dan mengambil widget yang akan ditampilkan.\n\n### OnPageDispose\n\nFungsi ini akan terpanggil tepat setelah semua objek yang berhubungan (Controller, Views, ...) ter-dispose dari halaman.\n\n## API Lanjutan Lainnya\n\n```dart\n// memberikan argument dari halaman yang sedang ditampilkan\nGet.arguments\n\n// memberikan nama dari route sebelumnya\nGet.previousRoute\n\n// memberikan akses raw route, contoh: rawRoute.isFirst()\nGet.rawRoute\n\n// memberikan akses terhadap Routing API dari GetObserver\nGet.routing\n\n// cek apakah snackbar sedang tampil\nGet.isSnackbarOpen\n\n// cek apakah dialog sedang tampil\nGet.isDialogOpen\n\n// cek apakah bottomsheet sedang tampil\nGet.isBottomSheetOpen\n\n// hapus satu route\nGet.removeRoute()\n\n// kembali berturut-turut hingga predikat mereturn nilai true.\nGet.until()\n\n// pergi ke halaman selanjutnya dan hapus semua route sebelumnya hingga predikat mereturn nilai true.\nGet.offUntil()\n\n// pergi ke halaman selanjutnya menggunakan nama dan hapus semua route sebelumnya hingga predikat mereturn nilai true.\nGet.offNamedUntil()\n\n// Cek di platform apa aplikasi sedang berjalan\nGetPlatform.isAndroid\nGetPlatform.isIOS\nGetPlatform.isMacOS\nGetPlatform.isWindows\nGetPlatform.isLinux\nGetPlatform.isFuchsia\n\n// Cek tipe perangkat\nGetPlatform.isMobile\nGetPlatform.isDesktop\n// Semua platform didukung secara independen di web!\n// Anda bisa mengetahui apakah anda menjalankannya didalam browser\n// di Windows, iOS, OSX, Android, dsb.\nGetPlatform.isWeb\n\n\n// Sama dengan : MediaQuery.of(context).size.height,\n// tapi immutable.\nGet.height\nGet.width\n\n// Memberikan konteks saat ini dari sebuah Navigator\nGet.context\n\n// Memberikan konteks dari snackbar/dialog/bottomsheet di Gives the latar depan, dimanapun di kode anda\nGet.contextOverlay\n\n// Catatan: metode berikut adalah sebuah perluasan konteks. Berhubung anda\n// memiliki akses terhadap konteks dimanapun di UI anda, anda bisa menggunakannya dimanapun di kode UI\n\n// Jika anda memerlukan height/width yang bisa dirubah (seperti Desktop atau browser yang bisa di sesuaikan) anda akan memerlukan konteks\ncontext.width\ncontext.height\n\n// Memberikan anda kemampuan untuk mendefinisikan separuh layar, sepertiga, dan seterusnya.\n// Berguna untuk aplikasi responsive.\n// param dibagi dengan (double) optional - default: 1\n// param dikurangi dengan (double) optional - default: 0\ncontext.heightTransformer()\ncontext.widthTransformer()\n\n/// Mirip seperti MediaQuery.of(context).size\ncontext.mediaQuerySize()\n\n/// Mirip seperti MediaQuery.of(context).padding\ncontext.mediaQueryPadding()\n\n/// Mirip seperti MediaQuery.of(context).viewPadding\ncontext.mediaQueryViewPadding()\n\n/// Mirip seperti MediaQuery.of(context).viewInsets;\ncontext.mediaQueryViewInsets()\n\n/// Mirip seperti MediaQuery.of(context).orientation;\ncontext.orientation()\n\n/// Cek apakah perangkat sedang dalam mode lansekap\ncontext.isLandscape()\n\n/// Cek apakah perangkat sedang dalam mode portrait\ncontext.isPortrait()\n\n/// Mirip seperti MediaQuery.of(context).devicePixelRatio;\ncontext.devicePixelRatio()\n\n/// Mirip seperti MediaQuery.of(context).textScaleFactor;\ncontext.textScaleFactor()\n\n/// Dapatkan shortestSide dari layar\ncontext.mediaQueryShortestSide()\n\n/// True jika layar lebih besar dari 800\ncontext.showNavbar()\n\n/// True jika shortestSide kurang dari 600p\ncontext.isPhone()\n\n/// True jika shortestSide lebih besar dari 600p\ncontext.isSmallTablet()\n\n/// True jika shortestSide lebih besar dari 720p\ncontext.isLargeTablet()\n\n/// True jika perangkat adalah sebuah Tablet\ncontext.isTablet()\n\n/// Memberikan sebuah value<T> berdasarkan ukuran layar\n/// dapat memberi value untuk:\n/// watch: jika shortestSide lebih kecil dari 300\n/// mobile: jika shortestSide lebih kecil dari 600\n/// tablet: jika shortestSide lebih kecil dari 1200\n/// desktop: jika lebar lebih besar dari 1200\ncontext.responsiveValue<T>()\n```\n\n### Pengaturan Global Opsional dan Konfigurasi Manual\n\nGetMaterialApp mengkonfigurasi semuanya untuk anda, namun jika anda ingin mengkonfigurasi Get secara manual.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver()],\n);\n```\n\nAnda juga bisa menggunakan Middleware anda sendiri melalui `GetObserver`, ini tidak akan mempengaruhi apapun.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [\n    GetObserver(MiddleWare.observer) // Disini\n  ],\n);\n```\n\nAnda bisa membuat _Pengaturan Global_ untuk `Get`. Cukup tambahkan `Get.config` kedalam kode anda sebelum berpindah ke route manapun.\nAtau lakukan secara langsung di `GetMaterialApp`\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  defaultTransition: Transition.fade,\n  opaqueRoute: Get.isOpaqueRouteDefault,\n  popGesture: Get.isPopGestureEnable,\n  transitionDuration: Get.defaultDurationTransition,\n  defaultGlobalState: Get.defaultGlobalState,\n);\n\nGet.config(\n  enableLog = true,\n  defaultPopGesture = true,\n  defaultTransition = Transitions.cupertino\n)\n```\n\nAnda bisa secara opsional me-redirect seluruh pesan logging dari `Get`.\nJika anda ingin menggunakan logging buatan anda sendiri, logging package favorit,\ndan ingin meng-capture lognya:\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  logWriterCallback: localLogWriter,\n);\n\nvoid localLogWriter(String text, {bool isError = false}) {\n  // oper message ke logging package favorit anda disini\n  // harap dicatat bahwa meskipun enableLog: false, pesan log akan di-push dalam callback ini,\n  // anda dapat memeriksa flag-nya jika anda mau melalui GetConfig.isLogEnable\n}\n\n```\n\n### Local State Widgets\n\nWidget ini memungkinkan anda untuk mengelola satu nilai, dan menjaga state emphemeral dan lokal.\nKita memiliki rasa untuk Reactive dan Simple.\nContohnya, anda mungkin menggunakannya untuk men-toggle obscureText di sebuah `TextField`, mungkin membuat\nExpandable Panel kustom, atau mungkin memodifikasi index saat ini dalam `BottomNavigationBar` sembari mengganti konten\ndari body didalam `Scaffold`\n\n#### ValueBuilder\n\nSebuah simplifikasi dari `StatefulWidget` yang berfungsi dengan sebuah callback `.setState` yang menerima value yang telah diperbarui.\n\n```dart\nValueBuilder<bool>(\n  initialValue: false,\n  builder: (value, updateFn) => Switch(\n    value: value,\n    onChanged: updateFn, // signaturenya sama! anda bisa menggunakan ( newValue ) => updateFn( newValue )\n  ),\n  // jika anda perlu memanggil sesuatu diluar builder method.\n  onUpdate: (value) => print(\"Value updated: $value\"),\n  onDispose: () => print(\"Widget unmounted\"),\n),\n```\n\n#### ObxValue\n\nMirip seperti [`ValueBuilder`](#valuebuilder), tapi ini versi Reactive nya, anda bisa menaruh Rx instance (ingat .obs?) dan\nakan ter-update secara otomatis... keren kan?\n\n```dart\nObxValue((data) => Switch(\n        value: data.value,\n        onChanged: data, // Rx memiliki sebuah _callable_ function! Anda bisa menggunakan (flag) => data.value = flag,\n    ),\n    false.obs,\n),\n```\n\n## Tips berguna\n\n`.obs`ervables (juga dikenal sebagai _Rx_ Types) memiliki beragam metode dan operator internal.\n\n> Sangat umum untuk _percaya_ bahwa sebuah properti dengan `.obs` **ADALAH** nilai aktual... jangan salah!\n> Kami menghindari Type declaration dari sebuah variabel, karena compiler Dart cukup pintar, dan kode nya\n> terlihat lebih bersih, tapi:\n\n```dart\nvar message = 'Hello world'.obs;\nprint( 'Message \"$message\" has Type ${message.runtimeType}');\n```\n\nMeskipun `message` _mengeluarkan output_ nilai String aktual, tipenya adalah **RxString**!\n\nJadi, anda tidak bisa melakukan `message.substring( 0, 4 )`.\nAnda perlu mengakses `value` aslinya didalam _observable_:\nCara yang paling \"sering digunakan\" adalah `.value`, tapi, tahukah anda bahwa anda juga bisa menggunakan...\n\n```dart\nfinal name = 'GetX'.obs;\n// hanya \"memperbarui\" stream, jika nilainya berbeda dari sebelumnya.\nname.value = 'Hey';\n\n// Seluruh properti Rx \"bisa dipanggil\" dan akan mereturn nilai baru.\n// tapi cara ini tidak menerima `null`, UI-nya tidak akan rebuild.\nname('Hello');\n\n// ini seperti getter, mengeluarkan output 'Hello'.\nname();\n\n/// angka:\n\nfinal count = 0.obs;\n\n// Anda bisa menggunakan semua operasi non-mutable dari primitif num!\ncount + 1;\n\n// Hati hati! ini hanya valid jika `count` tidak final, melainkan var\ncount += 1;\n\n// Anda juga bisa melakukan komparasi antar nilai:\ncount > 2;\n\n/// boolean:\n\nfinal flag = false.obs;\n\n// bertukar nilai antara true/false\nflag.toggle();\n\n\n/// semua tipe:\n\n// Atur `value` menjadi null.\nflag.nil();\n\n// Semua operasi toString(), toJson() dikirimkan ke `value`\nprint( count ); // memanggil `toString()` didalamnya untuk RxInt\n\nfinal abc = [0,1,2].obs;\n// Mengkonversi nilai dari Array json, mengeluarkan output RxList\n// Json didukung oleh semua tipe Rx!\nprint('json: ${jsonEncode(abc)}, type: ${abc.runtimeType}');\n\n// RxMap, RxList dan RxSet adalah tipe Rx spesial, mereka meng-extends native type masing-masing.\n// tapi anda bisa bekerja menggunakan List sebagai list biasa, meskipun reactive!\nabc.add(12); // memasukkan 12 kedalam list, dan MEMPERBARUI stream.\nabc[3]; // seperti List, membaca index ke 3.\n\n\n// persamaan berfungsi dengan Rx dan value nya, namun hashCode nya selalu diambil dari value\nfinal number = 12.obs;\nprint( number == 12 ); // mengeluarkan output: true\n\n/// Model Rx Kustom:\n\n// toJson(), toString() ditangguhkan ke child, jadi anda bisa mengimplementasi override pada mereka dan print() observable nya secara langsung\n\nclass User {\n    String name, last;\n    int age;\n    User({this.name, this.last, this.age});\n\n    @override\n    String toString() => '$name $last, $age years old';\n}\n\nfinal user = User(name: 'John', last: 'Doe', age: 33).obs;\n\n// `user` memang \"reaktif\", tapi properti didalamnya TIDAK REAKTIF!\n// Jadi, jika kita mengubah variabel didalamnya...\nuser.value.name = 'Roi';\n// Widget tidak akan rebuild!,\n// `Rx` tidak mengetahui apapun ketika anda mengubah sesuatu didalam user.\n// Jadi, untuk kelas kustom, kita perlu secara manual \"memberi tahu\" perubahannya.\nuser.refresh();\n\n// atau kita bisa menggunakan `update()` method!\nuser.update((value){\n  value.name='Roi';\n});\n\nprint( user );\n```\n\n#### GetView\n\nSaya menyukai Widget ini, sangat simpel dan berguna!\n\nAdalah sebuah `const Stateless` Widget yang memiliki getter `controller` untuk `Controller` yang terdaftar, itu saja.\n\n```dart\n class AwesomeController extends GetxController {\n   final String title = 'My Awesome View';\n }\n\n  // SELALU ingat untuk memberikan `Type` yang anda gunakan untuk mendaftarkan controller anda!\n class AwesomeView extends GetView<AwesomeController> {\n   @override\n   Widget build(BuildContext context) {\n     return Container(\n       padding: EdgeInsets.all(20),\n       child: Text(controller.title), // cukup panggil `controller.something`\n     );\n   }\n }\n```\n\n#### GetResponsiveView\n\nExtend widget ini untuk membuat responsive view.\nwidget ini mengandung properti `screen` yang memiliki semua\ninformasi tentang ukuran layar dan tipenya.\n\n##### Cara pakai\n\nAnda memiliki dua opsi untuk mem-buildnya.\n\n- dengan `builder` method yang anda return ke widget yang akan di-build.\n- dengan metode `desktop`, `tablet`,`phone`, `watch`. method\nspesifik akan dibuat ketika tipe layar cocok dengan method.\nketika layarnya adalah [ScreenType.Tablet] maka method `tablet`\nakan di eksekusi dan seterusnya.\n**Catatan:** Jika anda menggunakan metode ini, mohon atur properti `alwaysUseBuilder` ke `false`\n\nDengan properti `settings` anda bisa mengatur batasan lebar untuk tipe layar.\n\n![example](https://github.com/SchabanBo/get_page_example/blob/master/docs/Example.gif?raw=true)\nCode to this screen\n[code](https://github.com/SchabanBo/get_page_example/blob/master/lib/pages/responsive_example/responsive_view.dart)\n\n#### GetWidget\n\nKebanyakan orang tidak tahu untuk apa Widget ini, atau benar benar membingungkan penggunaannya.\nKasus penggunaannya sangat langka, namun sangat spesifik: Melakukan `cache` terhadap Controller.\nKarena _cache_, tidak bisa dijadikan `const Stateless`.\n\n> Lalu, kapan anda harus men-\"cache\" sebuah Controller?\n\nJika anda menggunakan, fitur \"tidak terlalu umum\" dari **GetX**: `Get.create()`.\n\n`Get.create(()=>Controller())` akan men-generate `Controller` baru setiap kali anda memanggil\n`Get.find<Controller>()`,\n\nItulah dimana `GetWidget` bercahaya... karena anda bisa menggunakannya, sebagai contoh,\nuntuk menyimpan list dari sebuah Todo item. Jadi, jika widget ter-\"rebuild\", dia akan meyimpan controller yang sama.\n\n#### GetxService\n\nKelas ini mirip seperti `GetxController`, dia berbagi lifecycle ( `onInit()`, `onReady()`, `onClose()`).\nTetapi tidak memiliki \"logic\" didalamnya. Dia hanya memberi tahu Sistem Dependency Injection **GetX**, bahwa subclass\nini **TIDAK BISA** dihapus dari memori.\n\nJadi ini sangat berguna untuk memastikan \"Service\" anda selalu dapat dijangkau dan aktif dengan `Get.find()`. Seperti:\n`ApiService`, `StorageService`, `CacheService`.\n\n```dart\nFuture<void> main() async {\n  await initServices(); /// AWAIT SERVICES INITIALIZATION.\n  runApp(SomeApp());\n}\n\n/// Adalah gerakan yang cerdas untuk membuat Service anda menginisialisasi sebelum anda menjalankan aplikasi Flutter\n/// seperti anda bisa mengontrol flow eksekusi (mungkin anda perlu memuat beberapa konfigurasi tema,\n/// apiKey, bahasa yang ditentukan oleh user...) jadi, load SettingSerice sebelum menjalankan ApiService.\n/// supaya GetMaterialApp() tidak perlu rebuild, dan mengambil nilainya secara langsung.\nvoid initServices() async {\n  print('starting services ...');\n  /// Disini adalah dimana anda meletakkan get_storage, hive, inisialisasi shared_pref.\n  /// atau koneksi moor, atau apapun yang sifatnya async.\n  await Get.putAsync(() => DbService().init());\n  await Get.putAsync(SettingsService()).init();\n  print('All services started...');\n}\n\nclass DbService extends GetxService {\n  Future<DbService> init() async {\n    print('$runtimeType delays 2 sec');\n    await 2.delay();\n    print('$runtimeType ready!');\n    return this;\n  }\n}\n\nclass SettingsService extends GetxService {\n  void init() async {\n    print('$runtimeType delays 1 sec');\n    await 1.delay();\n    print('$runtimeType ready!');\n  }\n}\n\n```\n\nThe only way to actually delete a `GetxService`, is with `Get.reset()` which is like a\n\"Hot Reboot\" of your app. So remember, if you need absolute persistence of a class instance during the\nlifetime of your app, use `GetxService`.\n\nSatu-satunya cara untuk benar benar menghapus sebuah `GetxService`, adalah dengan `Get.reset()` dimana ini seperti\n\"Hot Reboot\" dari aplikasi anda. Jadi ingat, jika anda butuh persistensi absolut dari sebuah instance kelas selama\nmasa hidup aplikasi anda, gunakan `GetxService`.\n\n# Breaking change dari 2.0\n\n1- Tipe Rx:\n\n| Sebelum | Sesudah    |\n| ------- | ---------- |\n| StringX | `RxString` |\n| IntX    | `RxInt`    |\n| MapX    | `RxMap`    |\n| ListX   | `RxList`   |\n| NumX    | `RxNum`    |\n| DoubleX | `RxDouble` |\n\nRxController dan GetBuilder sekarang digabungkan, anda tidak lagi perlu mengingat kontroler mana yang ingin anda gunakan, cukup gunakan GetxController, ini akan bekerja untuk simple state management dan reactive juga.\n\n2- NamedRoutes\nSebelumnya:\n\n```dart\nGetMaterialApp(\n  namedRoutes: {\n    '/': GetRoute(page: Home()),\n  }\n)\n```\n\nSekarang:\n\n```dart\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page: () => Home()),\n  ]\n)\n```\n\nMengapa berubah?\nSeringkali, mungkin diperlukan untuk memutuskan halaman mana yang akan ditampilkan melalui sebuah parameter, atau login token, cara sebelumnya sangat tidak fleksibel dan tidak memungkinkan untuk melakukan hal ini.\nMemasukkan data kedalam fungsi mengurangi konsumsi RAM secara signifikan, mengingat route tidak akan di alokasikan ke memori sejak aplikasi dimulai, dan ini memungkinkan kita melakukan ini:\n\n```dart\n\nGetStorage box = GetStorage();\n\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page:(){\n      return box.hasData('token') ? Home() : Login();\n    })\n  ]\n)\n```\n\n# Mengapa Getx?\n\n1- Seringkali setelah Flutter update, banyak package anda yang akan berhenti bekerja. Terkadang compilation error terjadi, error yang sering muncul dan belum ada jawabannya, dan developer perlu mengetahui dimana errornya berasal, mencari errornya, lalu kemudian mencoba membuka sebuah isu di repository yang bersangkutan, dan melihat apakah problemnya terselesaikan. Get memusatkan resource utama untuk development (State, dependency dan route management), memungkinkan anda untuk menambahkan satu package kedalam pubspec, dan mulai bekerja. Setelah Flutter update, satu-satunya hal yang anda perlu lakukan adalah memperbarui dependensi Get, dan kembali bekerja. Get juga menyelesaikan isu kompatibilitas. Berapa kali sebuah versi dari sebuah package tidak kompatibel dengan versi lainnya, karena yang satu menggunakan sebuah dependensi dalam satu versi, dan yang lain menggunakan versi lainnya? Ini juga bukan sebuah masalah menggunakan Get, yang mana semua berada di package yang sama dan kompatibel secara penuh.\n\n2- Flutter mudah digunakan, Flutter luar biasa, tetapi Flutter masih memiliki beberapa boilerplate yang mungkin tidak diinginkan untuk kebanyakan developer, seperti `Navigator.of(context).push(context builder [...]`. Get menyederhanakan proses development. Daripada menulis 8 baris kode hanya untuk memanggil route, anda bisa menggunakan: `Get.to(Home())` dan selesai, anda akan pergi ke halaman selanjutnya. URL web dinamis adalah hal yang sangat menyakitkan untuk dilakukan dengan Flutter saat ini, dan dengan GetX sangat sederhana. Mengelola state di Flutter, dan megelola dependensi juga suatu hal yang menghasilkan banyak diskusi, dengan ratusan jenis pattern di pub. Tetapi tidak ada yang semudah menambahkan \".obs\" di akhir variabel anda, dan meletakkan widget didalam Obx, dan selesai, semua update terhadap variabel tersebut akan secara otomatis terupdate di layar.\n\n3- Meringankan tanpa mengkhawatirkan performa. Performa Flutter sudah luar biasa, tetapi bayangkan anda menggunakan state manager, dan sebuah locator untuk mendistribusikan bloc/store/controller dsb, kelas. Anda perlu secara manual memanggil pengecualian terhadap dependensi ketika anda tidak membutuhkannya. Namun apakah anda pernah terfikirkan ketika simpelnya, anda menggunakan controller, dan tidak lagi digunakan oleh siapapun, akan dihapus dari memori? Itu yang GetX lakukan. Dengan SmartManagement, semua yang tidak digunakan akan dihapus dari memori, dan anda tidak perlu khawatir tentang apapun selain programming. Anda akan terjamin bahwa anda mengkonsumsi resource minimum yang diperlukan, bahkan tanpa harus membuat logic untuk hal ini.\n\n4- Actual decoupling. Anda mungkin pernah mendengar konsep \"pisahkan view dari business logic\". Ini bukanlah sebuah keanehan dari BLoC, MVC, MVVM, dan standard lainnya dalam market yang memiliki konsep ini. Namun, konsep ini terkadang termitigasi di Flutter karena penggunaan konteks.\nJika anda memerlukan konteks untuk menemukan InheritedWidget, anda membutuhkannya di view, atau mengirim konteks melalui parameter. Saya menemukan bahwa solusi ini sangat jelek, dan untuk bekerja dalam tim kami harus selalu memiliki sebuah ketergantungan pada business logic di dalam view. GetX adalah cara yang tidak lazim dengan metode standard, dan sementara itu tidak benar-benar secara penuh melarang penggunaan StatefulWidgets, InitState, dsb., ini selalu memiliki metode yang mirip dan bisa lebih bersih. Controller memiliki life cycle, dan ketika anda perlu membuat APIREST request sebagai contoh, anda tidak bergantung pada apapun didalam view. Anda bisa menggunakan onInit untuk menginisiasi pemanggilan http dan ketika datanya sampai, variabel akan dipopulasikan. GetX juga secara penuh reaktif (serius, dan bekerja dibawah stream), sekali items terisi, semua widget yang menggunakan variabel itu akan secara otomatis diperbarui didalam view. Ini memungkinkan orang orang dengan keahlian di bagian UI untuk bekerja hanya dengan widget, dan tidak perlu mengirim apapun ke business logic selain user event (seperti meng-klik sebuah tombol), sementara orang yang bekerja dengan business logic akan bebas membuat dan melakukan test terhadap business logic secara terpisah.\n\nLibrary ini akan terus diperbarui dan mengimplementasikan fitur baru. Jangan ragu untuk menawarkan PR dan berkontribusi ke mereka.\n\n# Komunitas\n\n## Channel Komunitas\n\nGetX memiliki komunitas yang sangat aktif dan membantu. Jika anda memiliki pertanyaan, atau membutuhkan bantuan mengenai penggunaan framework ini, bergabunglah dengan kanal komunitas kami, pertanyaan anda akan dijawab lebih cepat, dan akan menjadi tempat yang paling cocok. Repositori ini eksklusif untuk pembukaan isu dan permintaan resource, tapi jangan ragu untuk menjadi bagian dari Komunitas GetX.\n\n| **Slack**                                                                                                                   | **Discord**                                                                                                                 | **Telegram**                                                                                                          |\n| :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |\n| [![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx) | [![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N) | [![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g) |\n\n## Cara berkontribusi\n\n_Ingin berkontribusi kedalam proyek? Kami akan sangat bangga untuk menyorot anda sebagai salah satu dari kolaborator kami. Ini adalah beberapa point dimana anda bisa berkontribusi dan membuat Get (dan Flutter) jadi lebih baik_\n\n- Membantu menerjemahkan readme ke dalam bahasa lain.\n- Menambahkan dokumentasi ke dalam readme (banyak fungsi dari Get yang masih belum terdokumentasi).\n- Menulis artikel atau membuat video mengajarkan tentang penggunaan Get (akan dimasukkan kedalam readme dan Wiki kami di masa yang akan datang).\n- Menawarkan PR untuk kode/test.\n- Menambahkan fungsi baru.\n\nKontribusi dalam bentuk apapun dipersilahkan!\n\n## Artikel dan Video\n\n- [Dynamic Themes in 3 lines using GetX™](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Tutorial oleh [Rod Brown](https://github.com/RodBr).\n- [Complete GetX™ Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI) - Route management video oleh Amateur Coder.\n- [Complete GetX State Management](https://www.youtube.com/watch?v=CNpXbeI_slw) - State management video oleh Amateur Coder.\n- [GetX™ Other Features](https://youtu.be/ttQtlX_Q0eU) - Utils, storage, bindings and other features video oleh Amateur Coder.\n- [Firestore User with GetX | Todo App](https://www.youtube.com/watch?v=BiV0DcXgk58) - Video oleh Amateur Coder.\n- [Firebase Auth with GetX | Todo App](https://www.youtube.com/watch?v=-H-T_BSgfOE) - Video oleh Amateur Coder.\n- [The Flutter GetX™ Ecosystem ~ State Management](https://medium.com/flutter-community/the-flutter-getx-ecosystem-state-management-881c7235511d) - State management oleh [Aachman Garg](https://github.com/imaachman).\n- [The Flutter GetX™ Ecosystem ~ Dependency Injection](https://medium.com/flutter-community/the-flutter-getx-ecosystem-dependency-injection-8e763d0ec6b9) - Dependency Injection oleh [Aachman Garg](https://github.com/imaachman).\n- [GetX, the all-in-one Flutter package](https://www.youtube.com/watch?v=IYQgtu9TM74) - A brief tutorial covering State Management and Navigation oleh Thad Carnevalli.\n- [Build a To-do List App from scratch using Flutter and GetX](https://www.youtube.com/watch?v=EcnqFasHf18) - UI + State Management + Storage video oleh Thad Carnevalli.\n- [GetX Flutter Firebase Auth Example](https://medium.com/@jeffmcmorris/getx-flutter-firebase-auth-example-b383c1dd1de2) - Article oleh Jeff McMorris.\n- [Flutter State Management with GetX – Complete App](https://www.appwithflutter.com/flutter-state-management-with-getx/) - oleh App With Flutter.\n- [Flutter Routing with Animation using Get Package](https://www.appwithflutter.com/flutter-routing-using-get-package/) - oleh App With Flutter.\n"
        },
        {
          "name": "README.ja-JP.md",
          "type": "blob",
          "size": 59.8544921875,
          "content": "![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n[![pub package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n[![popularity](https://badges.bar/get/popularity)](https://pub.dev/packages/sentry/score)\n[![likes](https://badges.bar/get/likes)](https://pub.dev/packages/get/score)\n[![pub points](https://badges.bar/get/pub%20points)](https://pub.dev/packages/get/score)\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n[![style: effective dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n[![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n[![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n<a href=\"https://github.com/Solido/awesome-flutter\">\n<img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n</a>\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n\n<div align=\"center\">\n\n**言語**\n\n\n[![英語](https://img.shields.io/badge/Language-English-blueviolet?style=for-the-badge)](README.md)\n[![ベトナム語](https://img.shields.io/badge/Language-Vietnamese-blueviolet?style=for-the-badge)](README-vi.md)\n[![インドネシア語](https://img.shields.io/badge/Language-Indonesian-blueviolet?style=for-the-badge)](README.id-ID.md)\n[![ウルドゥー語](https://img.shields.io/badge/Language-Urdu-blueviolet?style=for-the-badge)](README.ur-PK.md)\n[![中国語](https://img.shields.io/badge/Language-Chinese-blueviolet?style=for-the-badge)](README.zh-cn.md)\n[![ポルトガル語](https://img.shields.io/badge/Language-Portuguese-blueviolet?style=for-the-badge)](README.pt-br.md)\n[![スペイン語](https://img.shields.io/badge/Language-Spanish-blueviolet?style=for-the-badge)](README-es.md)\n[![ロシア語](https://img.shields.io/badge/Language-Russian-blueviolet?style=for-the-badge)](README.ru.md)\n[![ポーランド語](https://img.shields.io/badge/Language-Polish-blueviolet?style=for-the-badge)](README.pl.md)\n[![韓国語](https://img.shields.io/badge/Language-Korean-blueviolet?style=for-the-badge)](README.ko-kr.md)\n[![フランス語](https://img.shields.io/badge/Language-French-blueviolet?style=for-the-badge)](README-fr.md)\n[![日本語](https://img.shields.io/badge/Language-Japanese-blueviolet?style=for-the-badge)](README-ja.md)\n\n</div>\n\n- [Getとは](#Getとは)\n- [インストール方法](#インストール方法)\n- [GetXによるカウンターアプリ](#GetXによるカウンターアプリ)\n- [三本柱](#三本柱)\n  - [状態管理](#状態管理)\n    - [リアクティブな状態管理](#リアクティブな状態管理)\n    - [状態管理に関する詳細ドキュメント](#状態管理に関する詳細ドキュメント)\n  - [Route管理](#Route管理)\n    - [Route管理に関する詳細ドキュメント](#Route管理に関する詳細ドキュメント)\n  - [依存オブジェクト管理](#依存オブジェクト管理)\n    - [依存オブジェクト管理に関する詳細ドキュメント](#依存オブジェクト管理に関する詳細ドキュメント)\n- [ユーティリティ](#ユーティリティ)\n  - [多言語対応](#多言語対応)\n    - [翻訳ファイル](#翻訳ファイル)\n      - [翻訳ファイルの利用](#翻訳ファイルの利用)\n    - [ロケール](#ロケール)\n      - [ロケールの変更](#ロケールの変更)\n      - [システムのロケールを読み込む](#システムのロケールを読み込む)\n  - [Themeの変更](#Themeの変更)\n  - [GetConnect](#getconnect)\n    - [デフォルト設定](#デフォルト設定)\n    - [カスタム設定](#カスタム設定)\n  - [GetPageにミドルウェアを設定](#GetPageにミドルウェアを設定)\n    - [実行優先度](#実行優先度)\n    - [redirect](#redirect)\n    - [onPageCalled](#onpagecalled)\n    - [onBindingsStart](#onbindingsstart)\n    - [onPageBuildStart](#onpagebuildstart)\n    - [onPageBuilt](#onpagebuilt)\n    - [onPageDispose](#onpagedispose)\n  - [その他API](#その他API)\n    - [オプションのグローバル設定と手動設定](#オプションのグローバル設定と手動設定)\n    - [ローカルステートWidget](#ローカルステートWidget)\n      - [ValueBuilder](#valuebuilder)\n      - [ObxValue](#obxvalue)\n  - [お役立ちTIPS](#お役立ちTIPS)\n    - [StateMixin](#statemixin)\n    - [GetView](#getview)\n    - [GetResponsiveView](#getresponsiveview)\n      - [使い方](#使い方])\n    - [GetWidget](#getwidget)\n    - [GetxService](#getxservice)\n  - [テストの実行](#テストの実行)\n    - [mockitoやmocktailを使う場合](#mockitoやmocktailを使う場合)\n    - [Get.reset()](#Get.reset())\n    - [Get.testMode](#Get.testMode)\n- [バージョン2.0からの破壊的変更](#バージョン2.0からの破壊的変更)\n- [なぜGetXなのか](#なぜGetXなのか)\n- [コミュニティ](#コミュニティ)\n  - [コミュニティチャンネル](#コミュニティチャンネル)\n  - [コントリビュート方法](#コントリビュート方法)\n  - [GetXに関する記事と動画](#GetXに関する記事と動画)\n\n# Getとは\n\n- GetXはFlutterのための超軽量でパワフルなソリューションです。高パフォーマンスな状態管理機能、インテリジェントな依存オブジェクト管理機能、そしてRoute管理機能の三本柱を軽量かつ実用的な形で組み合わせています。\n\n- GetXは3つの基本原則を念頭に開発されています。 **【生産性、パフォーマンス、コードの分離性】** これらはライブラリ内のすべてのリソースに優先適用されている原則です。\n\n  - **パフォーマンス:** GetXは高いパフォーマンスと最小限のリソース消費を目標にしています。GetXはでは Stream および ChangeNotifier を利用しなくて済みます。\n\n  - **生産性:** GetXはシンプルで使い心地のいいシンタックスを採用しています。あなたの実現したい機能がどんなものであれ、GetXを使えばより簡単に実現できる方法が見つかるでしょう。開発にかかる時間を短縮し、あなたのアプリケーションのパフォーマンスを最大限引き出してくれます。\n\n    開発者はメモリリソースの管理に気を配るのが常です。しかしGetXでは、リソースが使用されていないときはメモリから削除されるのがデフォルト動作のため、過度に気にかける必要はありません。（逆にメモリに残しておきたい場合は、依存オブジェクトをインスタンス化するメソッドを使う際に「permanent: true」と宣言してください）これにより時間が節約できますし、不要な依存オブジェクトがメモリ上に残るリスクも少なくなります。メモリへの読み込みについてもデフォルトは遅延読み込みであり、使用するときに初めてメモリ上に読み込まれます。\n\n  - **コードの分離性:** GetXを使うと、ビュー、プレゼンテーションロジック、ビジネスロジック、依存オブジェクトの注入、およびナビゲーション周りのコードを書き分けやすくなります。Routeのナビゲーションにはcontextを必要としないため、Widgetツリーに依存することはありません。ロジックについてもInheritedWidget経由でController/BLoCにアクセスする際のcontextは必要ありません。プレゼンテーションロジックとビジネスロジックをUIクラスから完全に切り離すことができます。また、Controller/モデル/BLoCのクラスを、`MultiProvider`を使ってWidgetツリーに注入する必要もありません。GetXでは独自の依存オブジェクト注入機能を使用し、ビュークラスからビューとは無関係なコードをなくすことができるのです。\n\n    GetXを使うことでアプリケーションの各機能がどこにあるのかがわかりやすくなり、自然と見やすいコードになります。メンテナンスが容易になるだけでなく、それまでのFlutterでは考えられなかったモジュール共有が簡単に実現できるようになりました。\n    BLoCはこの分野におけるFlutterの出発点と言えるものでしたが、GetXはこれを正統進化させており、ビジネスロジックのみならずプレゼンテーションロジックも分離することができます。そのほかデータレイヤーはもちろん、依存オブジェクトやRouteの注入に関するコードも。どこに何が配置されているのか全体の見通しがしやすくなり、Hello Worldを表示させるかのように簡単にアプリの機能を利用できるようになるでしょう。\n    Flutterアプリを作るならGetXは最も簡単で実用的、かつスケーラブルなソリューションです。強力なエコシステムも存在があるため、初心者にはわかりやすさ、プロには正確性を提供することができます。そしてFlutter SDKにはない幅広い種類のAPIを提供し、セキュアで安定的な環境を構築します。\n\n- GetXは肥大化したライブラリではありません。何も気にせずすぐに開発を始められるよう多数の機能を標準で備えていますが、それぞれの機能は個別にコンテナに入っており、使用してはじめて起動します。状態管理機能しか利用していない場合はその機能だけがコンパイルされます。Route管理機能だけを利用していれば、状態管理機能がコンパイルされることはありません。\n\n- GetXには巨大なエコシステム、コミュニティ、コラボレーターの存在があるため、Flutterが存在する限りメンテナンスされ続けます。またGetXもFlutterと同様にAndroid、iOS、Web、Mac、Linux、Windows、そしてあなたのサーバー上で、単一のコードから実行することができます。\n\n**[Get Server](https://github.com/jonataslaw/get_server)を使うことで、フロントエンドで作成したコードをバックエンドで再利用することが可能です。**\n\n**さらに、[Get CLI](https://github.com/jonataslaw/get_cli)を使えば、サーバー側でもフロントエンド側でも開発プロセス全体を自動化することができます。**\n\n**また、生産性をさらに高めるためのツールとして、[VSCode用の拡張機能](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets) と [Android Studio/Intellij用の拡張機能](https://plugins.jetbrains.com/plugin/14975-getx-snippets)があります。**\n\n# インストール方法\n\nGetパッケージを pubspec.yaml に追加します:\n\n```yaml\ndependencies:\n  get:\n```\n\n使用するときはこのようにインポートしてください:\n\n```dart\nimport 'package:get/get.dart';\n```\n\n# GetXによるカウンターアプリ\n\nFlutterで新規プロジェクトを作成する際に表示されるカウンターアプリは、コメントを含めると100行以上あります。Getの実力を示すため、このカウンターアプリを可読性を重視した形で、コメントを含めてわずか26行のコードで作成する方法を紹介します。\n\n- ステップ1:\n  MaterialAppの前に「Get」を足して、GetMaterialAppにします。\n\n```dart\nvoid main() => runApp(GetMaterialApp(home: Home()));\n```\n\n- 注1: GetMaterialAppはFlutterのMaterialAppに手を加えたものではありません。MaterialAppをchildに持ち、諸々の追加設定をしてくれるWidgetに過ぎません。この設定は手動でも可能ですが、その必要はありません。GetMaterialAppは、Routeの作成・注入、言語翻訳の注入など、ナビゲーションに必要なものをすべて注入してくれます。Getを状態管理や依存オブジェクト管理に限定して使用する場合は、GetMaterialAppを使用する必要はありません。GetMaterialAppは、Route、SnackBar、多言語対応、BottomSheet、Dialog、contextなしの高レベルAPIを利用する場合に必要です。\n- 注2: このステップは、Route管理機能（`Get.to()`や`Get.back()`など）を使用しない場合は、必要ありません。\n\n- ステップ2:\n  ビジネスロジッククラスを作成し、そこに必要な変数、メソッド、コントローラをすべて配置します。\n  変数に \".obs\" を付け足すことで、その変数の値の変化を監視することが可能になります。\n\n```dart\nclass Controller extends GetxController{\n  var count = 0.obs;\n  increment() => count++;\n}\n```\n\n- ステップ3:\n  ビューを作成します。StatelessWidgetを使用することでRAMが節約できます。GetではStatefulWidgetを使用する必要がなくなるかもしれません。\n\n```dart\nclass Home extends StatelessWidget {\n\n  @override\n  Widget build(context) {\n\n    // Get.put()を使ってクラスをインスタンス化することですべての子Routeで利用できるようになります。\n    final Controller c = Get.put(Controller());\n\n    return Scaffold(\n      // countが変わるたびにTextを更新するにはObx(()=>)を使ってください。\n      appBar: AppBar(title: Obx(() => Text(\"Clicks: ${c.count}\"))),\n\n      // 8行使っていたNavigator.pushの代わりに短い Get.to()を使ってください。context不要です。\n      body: Center(child: ElevatedButton(\n              child: Text(\"Go to Other\"), onPressed: () => Get.to(Other()))),\n      floatingActionButton:\n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n  }\n}\n\nclass Other extends StatelessWidget {\n  // 他のページで使われているコントローラーを見つけてきてくれます。\n  final Controller c = Get.find();\n\n  @override\n  Widget build(context){\n     // 最新のcount変数の値にアクセス\n     return Scaffold(body: Center(child: Text(\"${c.count}\")));\n  }\n}\n```\n\nResult:\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/counter-app-gif.gif)\n\nこれはシンプルな例ですが、すでにGetがいかに強力であるかがわかると思います。プロジェクトが大きければ大きいほど、この差はもっと開くでしょう。\n\nGetはチームでの作業を想定して設計されていますが、個人開発者の仕事もシンプルにしてくれます。\n\nパフォーマンスを落とさず納期までにすべて納品。Getはすべての人に向いているわけではありませんが、このフレーズにぴんと来た人には確実に向いています！\n\n# 三本柱\n\n## 状態管理\n\nGetの状態管理には、非リアクティブ（GetBuilder）と、リアクティブ（GetX/Obx）の2つのアプローチがあります。\n\n### リアクティブな状態管理\n\nリアクティブプログラミングは複雑であると言われ、多くの人に敬遠されています。GetXは、リアクティブプログラミングをシンプルなものに変えます:\n\n* StreamControllerを作る必要はありません。\n* 変数ごとにStreamBuilderをセットする必要はありません。\n* 状態ごとにクラスを作る必要はありません。\n* 初期値のためにgetを準備する必要はありません。\n- コードの自動生成をする必要がありません。\n\nGetにおけるリアクティブプログラミングはsetStateと同じように簡単です。\n\n例えば、名前の変数があって、それを変更するたびに、その名前を使っているすべてのWidgetを自動で更新したい場合。\n\n```dart\nvar name = 'Jonatas Borges';\n```\n\nこのnameをObservable(監視可能)にするには, \".obs\"を値の末尾に付けるだけです。\n\n```dart\nvar name = 'Jonatas Borges'.obs;\n```\n\nUIでその値を表示し、値が変わるたびに内容を更新したい場合は次のようにします。\n\n```dart\nObx(() => Text(\"${controller.name}\"));\n```\n\n以上です。こんなに簡単なんですよ。\n\n### 状態管理に関する詳細ドキュメント\n\n**状態管理に関するより詳細な説明を知りたい方は[こちらの日本語ドキュメント](./documentation/ja_JP/state_management.md)をご覧ください。多くの事例や、非リアクティブな状態管理とリアクティブな状態管理の違いについても説明されています。**\n\nGetXパワーがもたらす利点をより理解していただけると思います。\n\n## Route管理\n\nGetXはcontextなしでRoute/SnackBar/Dialog/BottomSheetを使用することができます。具体的に見ていきましょう。\n\nいつものMaterialAppの前に「Get」を付け足して、GetMaterialAppにしましょう。\n\n```dart\nGetMaterialApp( // MaterialApp の前に Get\n  home: MyHome(),\n)\n```\n\n新しいRouteに画面遷移するにはこのシンタックス。\n\n```dart\nGet.to(NextScreen());\n```\n\n名前付きRouteに画面遷移するにはこのシンタックス。名前付きRouteの詳細は[こちらの日本語ドキュメント](./documentation/ja_JP/route_management.md#navigation-with-named-routes)\n\n```dart\nGet.toNamed('/details');\n```\n\nSnackBar、Dialog、BottomSheetなど、Navigator.pop(context)で閉じられるRouteはこれで閉じます。\n\n```dart\nGet.back();\n```\n\n次の画面に移動した後、前の画面に戻れないようにする場合（スプラッシュスクリーンやログイン画面など）はこちら。\n\n```dart\nGet.off(NextScreen());\n```\n\n次の画面に進み、前のRouteをすべてキャンセルする場合（ショッピングカート、アンケート、テストなど）はこちら。\n\n```dart\nGet.offAll(NextScreen());\n```\n\n以上、contextを一度も使わなかったことに気付きましたか？これがGetでRoute管理を行う最大のメリットのひとつです。contextを使わないので、たとえばcontrollerクラスの中でも、これらのメソッドを実行することができます。\n\n### Route管理に関する詳細ドキュメント\n\n**Getは名前付きRouteでも動作し、Routeの下位レベルの制御も可能です。詳細なドキュメントは[こちらの日本語ドキュメント](./documentation/ja_JP/route_management.md)にあります。**\n\n## 依存オブジェクト管理\n\nGetにはシンプルで強力な依存オブジェクト注入機能があります。わずか1行のコードで、Provider contextやinheritedWidgetも使わず、BLoCやControllerのようなクラスのインスタンスを取得することができます。\n\n```dart\nController controller = Get.put(Controller()); // controller = Controller() とする代わりに\n```\n\n- 注: Getの状態管理機能を使用している場合は、Bindings APIにもご注目を。BindingsはビューとControllerを結びつけるのをより便利にしてくれます。\n\n一つのクラスの中でControllerクラスをインスタンス化するのではなく、Getインスタンスの中でインスタンス化することで、アプリ全体でControllerが利用できるようになります。\n\n**ヒント:** Getの依存オブジェクト注入機能の部分は、パッケージ全体の中でも他の部分と切り離されているので、たとえば、あなたのアプリがすでに状態管理機能を一部で使用していたとしても、それらを書き直す必要はなく、この依存オブジェクト注入機能をそのまま使用することができます。\n\n```dart\ncontroller.fetchApi();\n```\n\n色々なRouteを行き来した後に、あるControllerクラスのデータにアクセスする必要が生じたとしましょう。ProviderやGet_itなら再びそのクラスに依存オブジェクトを注入する必要がありますよね？Getの場合は違います。Getでは「find」と依頼するだけで、追加の依存オブジェクトの注入は必要ありません。\n\n```dart\nController controller = Get.find();\n//マジックみたいですね。Getは正しいcontrollerをきちんと探してきてくれますよ。100万のcontrollerのインスタンスがあっても、Getは必ず正しいcontrollerを探し当てます。\n```\n\nそして、findで取得したコントローラーのデータをこのように呼び出すことができます。\n\n```dart\nText(controller.textFromApi);\n```\n\n### 依存オブジェクト管理に関する詳細ドキュメント\n\n**依存オブジェクト管理に関するより詳細な説明は[こちらの日本語ドキュメント](./documentation/ja_JP/dependency_management.md)をご覧ください。**\n\n# ユーティリティ\n\n## 多言語対応\n\n### 翻訳ファイル\n\n翻訳ファイルはシンプルなキーと値のMapとして保持されます。\n翻訳を追加するには、クラスを作成して `Translations` を継承します。\n\n```dart\nimport 'package:get/get.dart';\n\nclass Messages extends Translations {\n  @override\n  Map<String, Map<String, String>> get keys => {\n        'en_US': {\n          'hello': 'Hello World',\n        },\n        'de_DE': {\n          'hello': 'Hallo Welt',\n        }\n      };\n}\n```\n\n#### 翻訳ファイルの利用\n\n指定されたキーに `.tr` （translateのtr）を追加するだけで、`Get.locale` と `Get.fallbackLocale` の現在の値をに沿って適切な言語に翻訳されます。\n\n```dart\nText('title'.tr);\n```\n\n#### 単数系と複数形に対応\n\n```dart\nvar products = [];\nText('singularKey'.trPlural('pluralKey', products.length, Args));\n```\n\n#### パラメーターに対応\n\n```dart\nimport 'package:get/get.dart';\n\n\nMap<String, Map<String, String>> get keys => {\n    'en_US': {\n        'logged_in': 'logged in as @name with email @email',\n    },\n    'es_ES': {\n       'logged_in': 'iniciado sesión como @name con e-mail @email',\n    }\n};\n\nText('logged_in'.trParams({\n  'name': 'Jhon',\n  'email': 'jhon@example.com'\n  }));\n```\n\n### ロケール\n\nロケールと翻訳を定義するため、`GetMaterialApp`にパラメータを渡します。\n\n```dart\nreturn GetMaterialApp(\n    translations: Messages(), // Translationsを継承したクラスのインスタンス\n    locale: Locale('en', 'US'), // このロケール設定に沿って翻訳が表示される\n    fallbackLocale: Locale('en', 'UK'), // 無効なロケールだったときのフォールバックを指定\n);\n```\n\n#### ロケールの変更\n\nロケールを変更するには、`Get.updateLocale(locale)`を呼び出します。翻訳は新しいロケールに沿ってなされます。\n\n```dart\nvar locale = Locale('en', 'US');\nGet.updateLocale(locale);\n```\n\n#### システムのロケールを読み込む\n\nシステムのロケールを読み込むには、`Get.deviceLocale`を使用します。\n\n```dart\nreturn GetMaterialApp(\n    locale: Get.deviceLocale,\n);\n```\n\n## Themeの変更\n\n`GetMaterialApp`より上位のWidgetを使ってThemeを変更しないでください。Keyの重複を引き起こす可能性があります。アプリのThemeを変更するためには「ThemeProvider」Widgetを作成するという前時代的なアプローチが採られることが多いですが、**GetX™**ではこのようなことは必要ありません。\n\nカスタムのThemeDataを作成したら、それを`Get.changeTheme`内に追加するだけです。\n\n```dart\nGet.changeTheme(ThemeData.light());\n```\n\nもし、`onTap`でThemeを変更するボタンを作りたいのであれば、以下の2つの**GetX™** APIを組み合わせることができます。\n\n- Dark Theme が使われているかどうかをチェックするAPI\n- Theme を変えるAPI（ボタンの`onPressed`の中に設置できます）\n\n```dart\nGet.changeTheme(Get.isDarkMode? ThemeData.light(): ThemeData.dark());\n```\n\nDarkモードが有効であれば、_light theme_に切り替わり、Lightモードが有効なら、_dark theme_に切り替わります。\n\n## GetConnect\n\nGetConnect は、http または websocket を使用してバックエンドとフロントエンド間の通信を行う機能です。\n\n### デフォルト設定\n\nGetConnectを拡張することで、GET/POST/PUT/DELETE/SOCKETメソッドを使用して、Rest APIやウェブソケットと通信することができます。\n\n```dart\nclass UserProvider extends GetConnect {\n  // Get リクエスト\n  Future<Response> getUser(int id) => get('http://youapi/users/$id');\n  // Post リクエスト\n  Future<Response> postUser(Map data) => post('http://youapi/users', body: data);\n  // File付き Post リクエスト\n  Future<Response<CasesModel>> postCases(List<int> image) {\n    final form = FormData({\n      'file': MultipartFile(image, filename: 'avatar.png'),\n      'otherFile': MultipartFile(image, filename: 'cover.png'),\n    });\n    return post('http://youapi/users/upload', form);\n  }\n\n  GetSocket userMessages() {\n    return socket('https://yourapi/users/socket');\n  }\n}\n```\n\n### カスタム設定\n\nGetConnect は高度なカスタマイズが可能です。ベースUrlの定義はもちろん、リクエストヘッダーを足したり、レスポンスボディに変更を加えたり、認証情報を追加したり、認証回数の制限を設けたりすることができるほか、リクエストをModelに変換するデコーダを定義することもできます。\n\n```dart\nclass HomeProvider extends GetConnect {\n  @override\n  void onInit() {\n    // デフォルトデコーダーをセット\n    httpClient.defaultDecoder = CasesModel.fromJson;\n    httpClient.baseUrl = 'https://api.covid19api.com';\n    // baseUrlをセット\n\n    // リクエストヘッダーに 'apikey' プロパティを付け足しています。\n    httpClient.addRequestModifier((request) {\n      request.headers['apikey'] = '12345678';\n      return request;\n    });\n\n    // サーバーが\"Brazil\"を含むデータを送ってきてもユーザーに表示されることはありません。\n    // レスポンスがUIレイヤーに届けられる前にデータが取り除かれているからです。\n    httpClient.addResponseModifier<CasesModel>((request, response) {\n      CasesModel model = response.body;\n      if (model.countries.contains('Brazil')) {\n        model.countries.remove('Brazilll');\n      }\n    });\n\n    httpClient.addAuthenticator((request) async {\n      final response = await get(\"http://yourapi/token\");\n      final token = response.body['token'];\n      // ヘッダーをセット\n      request.headers['Authorization'] = \"$token\";\n      return request;\n    });\n\n    // HttpStatus が HttpStatus.unauthorized である限り、\n    // 3回まで認証が試みられます。\n    httpClient.maxAuthRetries = 3;\n  }\n  }\n\n  @override\n  Future<Response<CasesModel>> getCases(String path) => get(path);\n}\n```\n\n## GetPageにミドルウェアを設定\n\nGetPageに新しいプロパティが追加され、GetMiddleWareのListを設定することができるようになりました。GetMiddleWareは設定した任意の順序で実行されます。\n\n**注**: GetPageにミドルウェアを設定すると、そのページの子ページはすべて同じミドルウェアを自動的に持つことになります。\n\n### 実行優先度\n\nGetMiddlewareに設定したpriority(優先度)の若い順にミドルウェアが実行されます。\n\n```dart\nfinal middlewares = [\n  GetMiddleware(priority: 2),\n  GetMiddleware(priority: 5),\n  GetMiddleware(priority: 4),\n  GetMiddleware(priority: -8),\n];\n```\n\nこの場合の実行順序は **-8 => 2 => 4 => 5**\n\n### redirect\n\nredirect関数は、Routeを呼び出してページが検索されると実行されます。リダイレクト先のRouteSettingsが戻り値となります。もしくはnullを与えれば、リダイレクトは行われません。\n\n```dart\nRouteSettings redirect(String route) {\n  final authService = Get.find<AuthService>();\n  return authService.authed.value ? null : RouteSettings(name: '/login')\n}\n```\n\n### onPageCalled\n\nonPageCalled関数は、ページが呼び出された直後に実行されます。\nこの関数を使ってページの内容を変更したり、新しいページを作成したりすることができます。\n\n```dart\nGetPage onPageCalled(GetPage page) {\n  final authService = Get.find<AuthService>();\n  return page.copyWith(title: 'Welcome ${authService.UserName}');\n}\n```\n\n### onBindingsStart\n\nonBindingsStart関数は、Bindingsが初期化される直前に実行されます。\nたとえば、ページのBindingsを変更することもできます。\n\n```dart\nList<Bindings> onBindingsStart(List<Bindings> bindings) {\n  final authService = Get.find<AuthService>();\n  if (authService.isAdmin) {\n    bindings.add(AdminBinding());\n  }\n  return bindings;\n}\n```\n\n### onPageBuildStart\n\nonPageBuildStart関数は、Bindingsが初期化された直後、ページWidgetが作成される前に実行されます。\n\n```dart\nGetPageBuilder onPageBuildStart(GetPageBuilder page) {\n  print('bindings are ready');\n  return page;\n}\n```\n\n### onPageBuilt\n\nonPageBuilt関数は、GetPage.page(ページのビルダー)が呼び出された直後に実行され、表示されるWidgetを結果として受け取ることができます。\n\n### onPageDispose\n\nonPageDispose関数は、ページに関するすべてのオブジェクト（Controller、ビューなど）が破棄された直後に実行されます。\n\n## その他API\n\n```dart\n// 現在の画面に渡されているargs(引数)を取得\nGet.arguments\n\n// 直前のRouteの名前(\"/\" など)を取得\nGet.previousRoute\n\n// 現在のRouteオブジェクトを取得\nGet.rawRoute\n\n// GetObserverからRoutingを取得\nGet.routing\n\n// SnackBarが開いているかチェック\nGet.isSnackbarOpen\n\n// Dialogが開いているかチェック\nGet.isDialogOpen\n\n// BottomSheetが開いているかチェック\nGet.isBottomSheetOpen\n\n// Routeを削除\nGet.removeRoute()\n\n// 引数のRoutePredicateがtrueを返すまで画面を戻る\nGet.until()\n\n// 引数で指定したRouteに進み、RoutePredicateがtrueを返すまで画面を戻る\nGet.offUntil()\n\n// 引数で指定した名前付きRouteに進み、RoutePredicateがtrueを返すまで画面を戻る\nGet.offNamedUntil()\n\n// アプリがどのプラットフォームで実行されているかのチェック\nGetPlatform.isAndroid\nGetPlatform.isIOS\nGetPlatform.isMacOS\nGetPlatform.isWindows\nGetPlatform.isLinux\nGetPlatform.isFuchsia\n\n// アプリがどのデバイスで実行されているかのチェック\nGetPlatform.isMobile\nGetPlatform.isDesktop\n// プラットフォームとデバイスのチェックは独立\n// 同じOSでもウェブで実行されているのか、ネイティブで実行されているのか区別\nGetPlatform.isWeb\n\n\n// MediaQuery.of(context).size.height と同じ\n// ただしimmutable\nGet.height\nGet.width\n\n// Navigatorの現在のcontextを取得\nGet.context\n\n// SnackBar/Dialog/BottomSheet などフォアグラウンドのcontextを取得\nGet.overlayContext\n\n// 注: 以降のメソッドはcontextの拡張メソッドです。\n// contextと同じくUIのどこからでもアクセスできます。\n\n// ウィンドウサイズの変更などに合わせて変わる height/width を取得\ncontext.width\ncontext.height\n\n// 画面の半分のサイズ,1/3のサイズなどを取得\n// レスポンシブなデザインの場合に便利\n// オプションのパラメーター dividedBy で割る数を指定\n// オプションのパラメーター reducedBy でパーセンテージを指定\ncontext.heightTransformer()\ncontext.widthTransformer()\n\n/// MediaQuery.of(context).size とほぼ同じ\ncontext.mediaQuerySize()\n\n/// MediaQuery.of(context).padding とほぼ同じ\ncontext.mediaQueryPadding()\n\n/// MediaQuery.of(context).viewPadding とほぼ同じ\ncontext.mediaQueryViewPadding()\n\n/// MediaQuery.of(context).viewInsets とほぼ同じ\ncontext.mediaQueryViewInsets()\n\n/// MediaQuery.of(context).orientation とほぼ同じ\ncontext.orientation()\n\n/// デバイスがランドスケープ(横長)モードかどうかチェック\ncontext.isLandscape()\n\n/// デバイスがポートレート(縦長)モードかどうかチェック\ncontext.isPortrait()\n\n/// MediaQuery.of(context).devicePixelRatio とほぼ同じ\ncontext.devicePixelRatio()\n\n/// MediaQuery.of(context).textScaleFactor とほぼ同じ\ncontext.textScaleFactor()\n\n/// 画面の短辺の長さを取得\ncontext.mediaQueryShortestSide()\n\n/// 画面の横幅が800より大きい場合にtrueを返す\ncontext.showNavbar()\n\n/// 画面の短辺が600より小さい場合にtrueを返す\ncontext.isPhone()\n\n/// 画面の短辺が600より小さい場合にtrueを返す\ncontext.isSmallTablet()\n\n/// 画面の短辺が720より大きい場合にtrueを返す\ncontext.isLargeTablet()\n\n/// デバイスがタブレットの場合にtrueを返す\ncontext.isTablet()\n\n/// 画面サイズに合わせて value<T> を返す\n/// たとえば:\n/// 短辺が300より小さい → watchパラメーターの値を返す\n/// 短辺が600より小さい → mobileパラメーターの値を返す\n/// 短辺が1200より小さい → tabletパラメーターの値を返す\n/// 横幅が1200より大きい → desktopパラメーターの値を返す\ncontext.responsiveValue<T>()\n```\n\n### オプションのグローバル設定と手動設定\n\nGetMaterialApp はすべてあなたの代わりに設定してくれますが、手動で設定を施したい場合は MaterialApp の navigatorKey と navigatorObservers の値を指定してください。\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver()],\n);\n```\n\n`GetObserver`内で独自のミドルウェアを使用することもできます。これは他に影響を及ぼすことはありません。\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [\n    GetObserver(MiddleWare.observer) // ここ\n  ],\n);\n```\n\n`Get` クラスに_グローバル設定_を施すことができます。Routeをプッシュする前のコードに `Get.config` を追加するだけです。もしくは、`GetMaterialApp` 内で直接設定することもできます。\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  defaultTransition: Transition.fade,\n  opaqueRoute: Get.isOpaqueRouteDefault,\n  popGesture: Get.isPopGestureEnable,\n  transitionDuration: Get.defaultDurationTransition,\n  defaultGlobalState: Get.defaultGlobalState,\n);\n\nGet.config(\n  enableLog = true,\n  defaultPopGesture = true,\n  defaultTransition = Transitions.cupertino\n)\n```\n\nオプションで、すべてのログメッセージを `Get` からリダイレクトさせることができます。\nお好みのロギングパッケージを使ってログを取得したい場合はこのようにしてください。\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  logWriterCallback: localLogWriter,\n);\n\nvoid localLogWriter(String text, {bool isError = false}) {\n  // ここでお好みのロギングパッケージにメッセージを渡してください\n  // enableLog: false にしても、ログメッセージはこのコールバックでプッシュされる点ご注意を\n  // ログが有効かどうかのチェックは Get.isLogEnable で可能\n}\n\n```\n\n### ローカルステートWidget\n\nローカルステートWidgetは、1つの変数の状態を一時的かつローカルに管理したい場合に便利です。\nシンプルなValueBuilderとリアクティブなObxValueの2種類があります。\nたとえば、`TextField` Widgetの obscureText プロパティを切り替えたり、折りたたみ可能なパネルをカスタムで作成したり、`BottomNavigation` の現在のインデックス値を変更して内容を変更したりといった用途に最適です。\n\n#### ValueBuilder\n\nsetStateでお馴染みの `StatefulWidget` をシンプルにしたビルダーWidgetです。\n\n```dart\nValueBuilder<bool>(\n  initialValue: false,\n  builder: (value, updateFn) => Switch(\n    value: value,\n    onChanged: updateFn, // ( newValue ) => updateFn( newValue ) も可\n  ),\n  // builderメソッドの外で何か実行する場合\n  onUpdate: (value) => print(\"Value updated: $value\"),\n  onDispose: () => print(\"Widget unmounted\"),\n),\n```\n\n#### ObxValue\n\n[`ValueBuilder`](#valuebuilder)に似ていますが、これはそのリアクティブバージョンです。Rxインスタンス(.obsを付けたときに戻る値です)を渡すと自動で更新されます。すごいでしょ？\n\n```dart\nObxValue((data) => Switch(\n        value: data.value,\n        onChanged: data,\n        // Rxには_呼び出し可能な_関数が備わっているのでこれだけでOK\n        // (flag) => data.value = flag も可能\n    ),\n    false.obs,\n),\n```\n\n## お役立ちTIPS\n\n`.obs`が付いた型(_Rx_型とも呼ばれる)には、さまざまな内部メソッドや演算子が用意されています。\n\n> `.obs`が付いたプロパティが **実際の値** だと信じてしまいがちですが...間違えないように！\n> 我々がcontrollerにおける変数の型宣言を省略してvarとしているのはDartのコンパイラが賢い上に、\n> そのほうがコードがすっきる見えるからですが…\n\n```dart\nvar message = 'Hello world'.obs;\nprint( 'Message \"$message\" has Type ${message.runtimeType}');\n```\n\n`message`を _print_ することで実際の文字列が取り出されはしますが、型は **RxString** です！\n\nそのため `message.substring( 0, 4 )` などといったことはできません。\nStringのメソッドにアクセスするには _observable_ の中にある実際の値 `value` にアクセスします。\nアクセスには `.value`を使うのが通常ですが、他の方法もあるのでご紹介します。\n\n```dart\nfinal name = 'GetX'.obs;\n// 新しい値が現在のものと異なる場合のみ Stream が更新されます。\nname.value = 'Hey';\n\n// すべてのRxプロパティは「呼び出し可能」で、valueを返してくれます。\n// ただし `null` は受付不可。nullの場合はUIが更新されない。\nname('Hello');\n\n// これはgetterみたいなものです。'Hello' を返します。\nname() ;\n\n/// num型の場合\n\nfinal count = 0.obs;\n\n// num型の非破壊的な演算子はすべて使えます。\ncount + 1;\n\n// 注意！ この場合は`count`がfinalなら有効ではないです。varなら有効。\ncount += 1;\n\n// 比較演算子も使用可能\ncount > 2;\n\n/// bool型の場合\n\nfinal flag = false.obs;\n\n// true/false を入れ替えることができます。\nflag.toggle();\n\n\n/// すべての型\n\n// `value` を null にセット。\nflag.nil();\n\n// toString(), toJson() などの操作はすべて `value` が対象になります。\nprint( count ); // RxIntの `toString()` が呼び出されて数字がprintされる。\n\nfinal abc = [0,1,2].obs;\n// json配列に変換した値と、'RxList' がprintされます。\n// JsonはすべてのRx型でサポートされています！\nprint('json: ${jsonEncode(abc)}, type: ${abc.runtimeType}');\n\n// RxMap、RxList、RxSetはそれぞれの元の型を拡張した特別なRx型です。\n// たとえばRxListは通常のListとして扱うことができる上にリアクティブです。\nabc.add(12); // 12をListにプッシュし、Streamを更新してくれます。\nabc[3]; // Listと同様にインデックス番号3の値を取得してくれます。\n\n\n// 等価演算子はRx型と元の型でも動作しますが、.hashCode は常にvalueから取得します。\nfinal number = 12.obs;\nprint( number == 12 ); // true\n\n/// カスタムのRxモデル\n\n// toJson()やtoString()をモデルクラスに設定すれば、.obsからでもprintされるように実装可能。\n\nclass User {\n    String name, last;\n    int age;\n    User({this.name, this.last, this.age});\n\n    @override\n    String toString() => '$name $last, $age years old';\n}\n\nfinal user = User(name: 'John', last: 'Doe', age: 33).obs;\n\n// `user` 自体はリアクティブですが、その中のプロパティはリアクティブではありません。\n// そのため、このようにプロパティの値を変更してもWidgetは更新されません。\nuser.value.name = 'Roi';\n// `Rx` には自ら変更を検知する手段がないからです。\n// そのため、カスタムクラスの場合はこのようにWidgetに変更を知らせる必要があります。\nuser.refresh();\n\n// もしくは `update()` メソッドを使用してください。\nuser.update((value){\n  value.name='Roi';\n});\n\nprint( user );\n```\n#### StateMixin\n\n`UI`の状態を管理するもう一つの手法として、`StateMixin<T>`を利用する方法があります。\ncontrollerクラスに`with`を使って`StateMixin<T>`を追加することで実装可能です。\n\n``` dart\nclass Controller extends GetController with StateMixin<User>{}\n```\n\n`change()`メソッドにより好きなタイミングで状態を変更することができます。\nこのようにデータと状態を渡すだけです。\n\n```dart\nchange(data, status: RxStatus.success());\n```\n\nRxStatus には以下のステータスが存在します。\n\n``` dart\nRxStatus.loading();\nRxStatus.success();\nRxStatus.empty();\nRxStatus.error('message');\n```\n\nステータスごとにUIを設定するにはこのようにします。\n\n```dart\nclass OtherClass extends GetView<Controller> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n\n      body: controller.obx(\n        (state)=>Text(state.name),\n\n        // ローディング中はカスタムのインジケーターの設定も可能ですが、\n        // デフォルトで Center(child:CircularProgressIndicator()) となります。\n        onLoading: CustomLoadingIndicator(),\n        onEmpty: Text('No data found'),\n\n        // 同様にエラーWidgetはカスタム可能ですが、\n        // デフォルトは Center(child:Text(error)) です。\n        onError: (error)=>Text(error),\n      ),\n    );\n}\n```\n\n#### GetView\n\nこのWidgetは私のお気に入りです。とてもシンプルで扱いやすいですよ！\n\nこのWidgetを一言で表現すると、「controllerをgetterに持つ `const` な StatelessWidget」です。\n\n```dart\n class AwesomeController extends GetController {\n   final String title = 'My Awesome View';\n }\n\n  // controllerの `型` を渡すのを忘れずに！\n class AwesomeView extends GetView<AwesomeController> {\n   @override\n   Widget build(BuildContext context) {\n     return Container(\n       padding: EdgeInsets.all(20),\n       child: Text(controller.title), // `controller.なんとか` でアクセス\n     );\n   }\n }\n```\n\n#### GetResponsiveView\n\nGetViewをレスポンシブデザインに対応させたい場合はこのWidgetを継承してください。\n画面サイズやデバイスタイプなどの情報を持つ `screen` プロパティを保持しています。\n\n##### 使い方\n\nWidgetをビルドする方法は2つあります。\n\n- `builder` メソッドを使う。\n- `desktop`, `tablet`, `phone`, `watch` メソッドを使う。\n  画面サイズ、デバイスタイプに応じたWidgetがビルドされます。\n  たとえば画面が [ScreenType.Tablet] なら `tablet` メソッドが実行されます。\n  **注:** `alwaysUseBuilder` プロパティをfalseにする必要があります。\n\n`settings` プロパティでブレイクポイントを設定することもできます。\n\n![例](https://github.com/SchabanBo/get_page_example/blob/master/docs/Example.gif?raw=true)\nこの画面のコード\n[コード](https://github.com/SchabanBo/get_page_example/blob/master/lib/pages/responsive_example/responsive_view.dart)\n\n#### GetWidget\n\nこのWidgetはあまり知られておらず、使用するケースは稀です。\nGetViewとの違いは、Controllerを`キャッシュ`してくれる点です。\nこのキャッシュがあるため `const` にはできません。\n\n> それでは一体いつControllerをキャッシュする必要があるのかって？\n\nそれは **GetX** のこれまた使う機会の少ない `Get.create()` を使うときです。\n\n`Get.create(()=>Controller())` は `Get.find<Controller>()` を実行するたびに\n新しいControllerインスタンスを生成します。\n\nそこで `GetWidget` の出番です。たとえば、Todoアイテムのリスト内容を保持したいとき。\nWidgetが更新されてもアイテムはControllerのキャッシュを参照してくれます。\n\n#### GetxService\n\nこのクラスは `GetxController` に似ており、同様のライフサイクル（`onInit()`, `onReady()`, `onClose()`）を共有しますが、そこに「ロジック」はありません。**GetX**の依存オブジェクト注入システムに、このサブクラスがメモリから **削除できない** ということを知らせるだけです。\n\nそのため `Get.find()` で `ApiService`, `StorageService`, `CacheService` のようなサービス系クラスにいつでもアクセスできるようにしておくと非常に便利です。\n\n```dart\nFuture<void> main() async {\n  await initServices(); /// サービスクラスの初期化をawait\n  runApp(SomeApp());\n}\n\n/// Flutterアプリ実行前にサービスクラスを初期化してフローをコントロールするのは賢いやり方です。\n/// たとえば GetMaterialAppを更新する必要がないようにUser別の\n/// Theme、apiKey、言語設定などをApiサービス実行前にロードしたり。\nvoid initServices() async {\n  print('starting services ...');\n  /// get_storage, hive, shared_pref の初期化はここで行います。\n  /// あるいは moor の connection など非同期のメソッドならなんでも。\n  await Get.putAsync(() => DbService().init());\n  await Get.putAsync(SettingsService()).init();\n  print('All services started...');\n}\n\nclass DbService extends GetxService {\n  Future<DbService> init() async {\n    print('$runtimeType delays 2 sec');\n    await 2.delay();\n    print('$runtimeType ready!');\n    return this;\n  }\n}\n\nclass SettingsService extends GetxService {\n  void init() async {\n    print('$runtimeType delays 1 sec');\n    await 1.delay();\n    print('$runtimeType ready!');\n  }\n}\n\n```\n\n`GetxService` を破棄する唯一の方法は `Get.reset()` メソッドを使うことです。\nこれはアプリにおける「ホットリブート」のようなものです。あるクラスのインスタンスを\nライフサイクルの間ずっと残しておきたい場合は `GetxService` を使うというのを覚えておいてください。\n\n\n## テストの実行\n\nControllerのライフサイクル含め、他のクラスと同様にテストを実行することができます。\n\n```dart\nclass Controller extends GetxController {\n  @override\n  void onInit() {\n    super.onInit();\n    // 値を name2 に変更\n    name.value = 'name2';\n  }\n\n  @override\n  void onClose() {\n    name.value = '';\n    super.onClose();\n  }\n\n  final name = 'name1'.obs;\n\n  void changeName() => name.value = 'name3';\n}\n\nvoid main() {\n  test('''\nTest the state of the reactive variable \"name\" across all of its lifecycles''',\n      () {\n    /// ライフサイクルごとのテストは必ずしも行う必要はありませんが、\n    /// GetXの依存オブジェクト注入機能を使用しているのであれば実行をおすすめします。\n    final controller = Controller();\n    expect(controller.name.value, 'name1');\n\n    /// このようにライフサイクル経過ごとの状態をテスト可能です。\n    Get.put(controller); // onInit が実行される\n    expect(controller.name.value, 'name2');\n\n    /// 関数もテストしましょう\n    controller.changeName();\n    expect(controller.name.value, 'name3');\n\n    /// onClose が実行される\n    Get.delete<Controller>();\n\n    expect(controller.name.value, '');\n  });\n}\n```\n\n#### mockitoやmocktailを使う場合\nGetxController/GetxService をモックする場合 Mock をミックスインしてください。\n\n```dart\nclass NotificationServiceMock extends GetxService with Mock implements NotificationService {}\n```\n\n#### Get.reset()\nWidgetやGroupのテスト時に、テストの最後かtearDownの中で Get.reset() を実行することで設定をリセットすることができます。\n\n#### Get.testMode\nControllerの中でナビゲーションを使用している場合は、`Get.testMode = true`をmainの開始で実行してください。\n\n\n# バージョン2.0からの破壊的変更\n\n1- Rx型の名称\n\n| 変更前  | 変更後     |\n| ------- | ---------- |\n| StringX | `RxString` |\n| IntX    | `RxInt`    |\n| MapX    | `RxMap`    |\n| ListX   | `RxList`   |\n| NumX    | `RxNum`    |\n| DoubleX | `RxDouble` |\n\nRxControllerとGetBuilderが統合され、Controllerにどれを使うか覚えておく必要がなくなりました。GetxControllerを使うだけで、リアクティブと非リアクティブな状態管理の両方に対応できるようになりました。\n\n2- 名前付きRoute\n変更前:\n\n```dart\nGetMaterialApp(\n  namedRoutes: {\n    '/': GetRoute(page: Home()),\n  }\n)\n```\n\n変更後:\n\n```dart\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page: () => Home()),\n  ]\n)\n```\n\n変更の効果:\nページ表示にはパラメータやログイントークンを起点にする方法もありますが、以前のアプローチではこれができず、柔軟性に欠けていました。\nページを関数から取得するよう変更したことで、このようなアプローチを可能にし、アプリ起動直後にRouteがメモリに割り当てられることもないため、RAMの消費量を大幅に削減することもできました。\n\n```dart\n\nGetStorage box = GetStorage();\n\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page:(){\n      return box.hasData('token') ? Home() : Login();\n    })\n  ]\n)\n```\n\n# なぜGetXなのか\n\n1- Flutterのアップデートが重なると、依存パッケージがうまく動かなくなることがあります。コンパイルエラーを起こしたり、その時点で解決方法がないようなエラーが発生したり。開発者はそのエラーを追跡し、該当リポジトリにissueを提起し、問題が解決されるのを待つ必要があります。Getは開発に必要な主要リソース（状態管理、依存オブジェクト管理、Route管理）を一元化し、Pubspecにパッケージを1つ追加するだけでコーディングを開始することができます。Flutterがアップデートしたときに必要なことは、Getも併せてアップデートすることだけです。それですぐに作業を再開できます。またGetはパッケージ間の互換性の問題も解消します。互いに依存するパッケージAの最新バージョンとBの最新バージョンの間に互換性がない、ということが何度あったでしょうか。Getを使えばすべてが同じパッケージ内にあるため、互換性の心配はありません。\n\n2- Flutterは手軽で素晴らしいフレームワークですが、`Navigator.of(context).push (context, builder [...]`のように、ほとんどの開発者にとって不要な定型文が一部にあります。Getを使えばそのような定型文を簡素化できます。Routeを呼ぶためだけに8行のコードを書く代わりに、`Get.to(Home())`を実行すれば、次の画面に遷移することができるのです。またウェブURLを動的なものにすることは現在Flutterでは本当に骨の折れる作業ですが、GetXを使えば非常に簡単です。そしてFlutterにおける状態管理と依存オブジェクト管理については、たくさんのパターンやパッケージがあるので多くの議論を生んでいます。しかしGetXのアプローチは大変シンプルです。これは一例ですが、変数の最後に「.obs」を追加して「Obx()」の中にWidgetを配置するだけで、その変数の状態変化が自動でWidgetに反映されます。\n\n3- GetXではパフォーマンスのことをあまり気にせず開発ができます。Flutterのパフォーマンスはそれだけで素晴らしいものですが、状態管理と併せて BLoC / データストア / Controller などを届けるためのサービスロケーターを使用することを想像してみてください。そのインスタンスが必要ないときはリソースを解放するイベントを明示的に呼び出さなければなりません。そんなとき、使用されなくなったら自動でメモリから削除してくれればいいのに、と考えたことはありませんか？それを実現してくれるのがGetXです。SmartManagement機能により未使用のリソースはすべて自動でメモリから破棄されるので、本来の開発作業に集中することができます。メモリ管理のためのロジックを作らなくても、常に必要最小限のリソースを使っていることが保証されるのです。\n\n4- コードのデカップリング（分離）がしやすい。「ビューをビジネスロジックから分離する」というコンセプトを聞いたことがあるかもしれません。これはなにもBLoC、MVC、MVVMに限ったことではなく、どのアーキテクチャパターンもこのコンセプトが考え方の基本にあると言っていいでしょう。しかし、Flutterではcontextの使用によりこのコンセプトが薄まってしまいがちです。\nInheritedWidgetを参照するためにcontextが必要なとき、ビューの中でそれを使用するか、引数としてcontextを渡しますよね？私はこの方法は美しくないと感じます。常にビュー内のビジネスロジックに依存しなければならないのは、特にチームで仕事をする場面においては不便だと感じます。GetXによるアプローチでは、StatefulWidgetやinitStateなどの使用を禁止しているわけではありませんが、それらよりもずっとスッキリ書けるようになっています。Controller自体にライフサイクルがあるため、たとえばREST APIのリクエストを行うときも、ビューの中の何かに依存するということがありません。Controllerのライフサイクルの一つである onInit を使用してhttpを呼び出し、データが到着すると変数にセットされます。GetXはリアクティブな変数を扱うことができるので、インスタンス変数が変わりし次第、その変数に依存するWidgetがすべて自動更新されます。これによりUIの担当者はWidgetの見た目に注力することができ、ボタンクリックなどのユーザーイベント以外のものをビジネスロジックに渡す必要がなくなります。その一方でビジネスロジックの担当者はビジネスロジックだけに集中し、個別のテストを簡単に行うことができます。\n\nGetXライブラリは今後も更新され続け、新しい機能を実装していきます。気軽にプルリクエストを出していただき、ライブラリの成長に貢献していただけるとうれしいです。\n\n# コミュニティ\n\n## コミュニティチャンネル\n\nGetXコミュニティは非常に活発で有益な情報であふれています。ご質問がある場合や、このフレームワークの使用に関して支援が必要な場合は、ぜひコミュニティチャンネルにご参加ください。このリポジトリは、issueの提起およびリクエスト専用ですが、気軽にコミュニティにご参加いただければ幸いです。\n\n| **Slack**                                                                                                                   | **Discord**                                                                                                                 | **Telegram**                                                                                                          |\n| :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |\n| [![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx) | [![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N) | [![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g) |\n\n## コントリビュート方法\n\n_GetXプロジェクトに貢献してみませんか？あなたをコントリビューターの一人としてご紹介できるのを楽しみにしています。GetおよびFlutterをより良いものにするためのコントリビュート例をご紹介します。_\n\n- Readmeの多言語対応。\n- Readmeの追加ドキュメント執筆 (ドキュメントで触れられていない機能がまだまだたくさんあります)。\n- Getの使い方を紹介する記事やビデオの作成（Readmeに掲載させていただきます。将来的にWikiができればそこにも掲載予定）。\n- コードやテストのプルリクエスト。\n- 新機能の提案。\n\nどのような形の貢献であれ歓迎しますので、ぜひコミュニティにご参加ください！\n\n## GetXに関する記事と動画\n\n- [Flutter Getx EcoSystem package for arabic people](https://www.youtube.com/playlist?list=PLV1fXIAyjeuZ6M8m56zajMUwu4uE3-SL0) - Tutorial by [Pesa Coder](https://github.com/UsamaElgendy).\n- [Dynamic Themes in 3 lines using GetX™](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Tutorial by [Rod Brown](https://github.com/RodBr).\n- [Complete GetX™ Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI) - Route management video by Amateur Coder.\n- [Complete GetX State Management](https://www.youtube.com/watch?v=CNpXbeI_slw) - State management video by Amateur Coder.\n- [GetX™ Other Features](https://youtu.be/ttQtlX_Q0eU) - Utils, storage, bindings and other features video by Amateur Coder.\n- [Firestore User with GetX | Todo App](https://www.youtube.com/watch?v=BiV0DcXgk58) - Video by Amateur Coder.\n- [Firebase Auth with GetX | Todo App](https://www.youtube.com/watch?v=-H-T_BSgfOE) - Video by Amateur Coder.\n- [The Flutter GetX™ Ecosystem ~ State Management](https://medium.com/flutter-community/the-flutter-getx-ecosystem-state-management-881c7235511d) - State management by [Aachman Garg](https://github.com/imaachman).\n- [The Flutter GetX™ Ecosystem ~ Dependency Injection](https://medium.com/flutter-community/the-flutter-getx-ecosystem-dependency-injection-8e763d0ec6b9) - Dependency Injection by [Aachman Garg](https://github.com/imaachman).\n- [GetX, the all-in-one Flutter package](https://www.youtube.com/watch?v=IYQgtu9TM74) - A brief tutorial covering State Management and Navigation by Thad Carnevalli.\n- [Build a To-do List App from scratch using Flutter and GetX](https://www.youtube.com/watch?v=EcnqFasHf18) - UI + State Management + Storage video by Thad Carnevalli.\n- [GetX Flutter Firebase Auth Example](https://medium.com/@jeffmcmorris/getx-flutter-firebase-auth-example-b383c1dd1de2) - Article by Jeff McMorris.\n- [Flutter State Management with GetX – Complete App](https://www.appwithflutter.com/flutter-state-management-with-getx/) - by App With Flutter.\n- [Flutter Routing with Animation using Get Package](https://www.appwithflutter.com/flutter-routing-using-get-package/) - by App With Flutter.\n- [A minimal example on dartpad](https://dartpad.dev/2b3d0d6f9d4e312c5fdbefc414c1727e?) - by [Roi Peker](https://github.com/roipeker)\n"
        },
        {
          "name": "README.ko-kr.md",
          "type": "blob",
          "size": 53.60546875,
          "content": "![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n[![pub package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n[![popularity](https://badges.bar/get/popularity)](https://pub.dev/packages/sentry/score)\n[![likes](https://badges.bar/get/likes)](https://pub.dev/packages/get/score)\n[![pub points](https://badges.bar/get/pub%20points)](https://pub.dev/packages/get/score)\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n[![style: effective dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n[![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n[![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n<a href=\"https://github.com/Solido/awesome-flutter\">\n<img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n</a>\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n\n<div align=\"center\">\n\n**Languages:**\n\n  \n[![영어](https://img.shields.io/badge/Language-English-blueviolet?style=for-the-badge)](README.md)\n[![베트남어](https://img.shields.io/badge/Language-Vietnamese-blueviolet?style=for-the-badge)](README-vi.md)\n[![인도네시아어](https://img.shields.io/badge/Language-Indonesian-blueviolet?style=for-the-badge)](README.id-ID.md)\n[![우르두어](https://img.shields.io/badge/Language-Urdu-blueviolet?style=for-the-badge)](README.ur-PK.md)\n[![중국어](https://img.shields.io/badge/Language-Chinese-blueviolet?style=for-the-badge)](README.zh-cn.md)\n[![포르투칼어](https://img.shields.io/badge/Language-Portuguese-blueviolet?style=for-the-badge)](README.pt-br.md)\n[![스페인어](https://img.shields.io/badge/Language-Spanish-blueviolet?style=for-the-badge)](README-es.md)\n[![러시아어](https://img.shields.io/badge/Language-Russian-blueviolet?style=for-the-badge)](README.ru.md)\n[![폴란드어](https://img.shields.io/badge/Language-Polish-blueviolet?style=for-the-badge)](README.pl.md)\n[![한국어](https://img.shields.io/badge/Language-Korean-blueviolet?style=for-the-badge)](README.ko-kr.md)\n[![프랑스어](https://img.shields.io/badge/Language-French-blueviolet?style=for-the-badge)](README-fr.md)\n\n</div>\n\n- [Get에 대하여](#get에-대하여)\n- [설치](#설치)\n- [GetX를 사용한 Counter 앱](#getx를-사용한-counter-앱)\n- [세가지 주요점](#세가지-주요점)\n  - [상태 관리](#상태-관리)\n    - [반응형 상태 관리자](#반응형-상태-관리자)\n    - [상태 관리에 대한 자세한 내용](#상태-관리에-대한-자세한-내용)\n  - [라우트 관리](#라우트-관리)\n    - [라우트 관리에 대한 자세한 내용](#라우트-관리에-대한-자세한-내용)\n  - [종속성 관리](#종속성-관리)\n    - [종속성 관리에 대한 자세한 내용](#종속성-관리에-대한-자세한-내용)\n- [기능들](#기능들)\n  - [국제화](#국제화)\n    - [번역](#번역)\n      - [번역 사용법](#번역-사용법)\n    - [지역화](#지역화)\n      - [지역 변경](#지역-변경)\n      - [시스템 지역](#시스템-지역)\n  - [테마 변경](#테마-변경)\n  - [GetConnect](#getconnect)\n    - [기본 구성](#기본-구성)\n    - [커스텀 구성](#커스텀-구성)\n  - [GetPage Middleware](#getpage-middleware)\n    - [Priority](#priority)\n    - [Redirect](#redirect)\n    - [onPageCalled](#onpagecalled)\n    - [OnBindingsStart](#onbindingsstart)\n    - [OnPageBuildStart](#onpagebuildstart)\n    - [OnPageBuilt](#onpagebuilt)\n    - [OnPageDispose](#onpagedispose)\n  - [기타 고급 API](#기타-고급-api)\n    - [선택적 전역 설정과 수동 구성](#선택적-전역-설정과-수동-구성)\n    - [지역 상태 위젯들](#지역-상태-위젯들)\n      - [ValueBuilder](#valuebuilder)\n      - [ObxValue](#obxvalue)\n  - [유용한 팁](#유용한-팁)\n      - [GetView](#getview)\n      - [GetResponsiveView](#getresponsiveview)\n        - [사용 방법](#사용-방법)\n      - [GetWidget](#getwidget)\n      - [GetxService](#getxservice)\n- [2.0의 주요 변경점](#20의-주요-변경점)\n- [왜 Getx인가?](#왜-getx인가)\n- [커뮤니티](#커뮤니티)\n  - [커뮤니티 채널](#커뮤니티-채널)\n  - [기여하는 방법](#기여하는-방법)\n  - [기사 및 비디오](#기사-및-비디오)\n\n# Get에 대하여\n\n- GetX는 Flutter를 위한 매우 가볍고 강력한 솔루션입니다. 고성능 상태 관리, 지능형 종속성 주입 및 빠르고 실용적인 라우트 관리가 결합되어 있습니다.\n\n- GetX는 라이브러리의 모든 사항에 대해서 **생산성, 성능, 조직화**의 3 가지 기본 원칙을 가지고 있습니다.\n\n  - **성능:** GetX는 성능과 최소한의 리소스 소비에 중점을 둡니다. GetX는 Streams나 ChangeNotifier를 사용하지 않습니다.\n  \n  - **생산성:** GetX는 쉽고 친숙한 구문을 사용합니다. 원하시는 것보다 Getx에는 항상 더 쉬운 방법이 있습니다. 개발 시간을 아끼고 애플리케이션을 최대 성능으로 제공할 수 있습니다. \n\n  일반적으로 개발자는 메모리에서 컨트롤러들을 제거하는 데 관심을 가져야합니다. GetX에서는 리소스가 기본적으로 사용되지 않으면 메모리에서 제거되므로 필요하지 않습니다. 만약 메모리에 유지하려면 종속성에서 \"permanent : true\"를 명시적으로 선언해야합니다. 이렇게하면 시간을 절약 할 수있을뿐만 아니라 불필요한 메모리 종속성이 발생할 위험이 줄어 듭니다. 종속성은 기본적으로 lazy로 로드됩니다.\n  \n  - **조직화:** GetX는 화면, 프레젠테이션 로직, 비즈니스 로직, 종속성 주입 및 네비게이션을 완전히 분리 할 수 있습니다. 라우트간 전환을 하는데에 컨텍스트가 필요하지 않아 위젯 트리(시각객체)에 독립적입니다. inheritedWidget을 통해 컨트롤러/블록에 접근하는 데 컨텍스트가 필요하지 않아 시각화 계층에서 프레젠테이션 로직과 비즈니스 로직을 완전히 분리됩니다. 이 GetX는 자체 종속성 주입 기능을 사용하여 DI를 뷰에서 완전히 분리하기 때문에 다중 Provider를 통해 위젯 트리에서 컨트롤러/모델/블록으로 주입 할 필요가 없습니다.\n\n  GetX를 사용하면 기본적으로 클린 코드를 가지게 되어 애플리케이션의 각 기능을 쉽게 찾을 수 있습니다. 이것은 유지 보수를 용이하게 하며 모듈의 공유가 가능하고 Flutter에서는 생각할 수 없었던 것들도 전부 가능합니다.\n  BLoC은 Flutter에서 코드를 구성하기 위한 시작점으로 비즈니스 로직과 시각객체를 분리합니다. Getx는 비즈니스 로직 뿐만 아니라 프레젠테이션 로직을 분리하는 자연스러운 진화입니다. 추가로 종속성 주입과 라우트 또한 분리되고 데이터 계층이 모두로부터 분리됩니다. Hello World를 구현하는 것보다 더 쉽게 모든 것이 어디 있는지 알수 있습니다.  \n  Flutter SDK와 함께 GetX를 사용하면 가장 쉽고 실용적이며 확장 가능한 고성능 어플리케이션을 만들수 있습니다. 초보자에게는 쉬우며 전문가에게는 정확하고 완벽하게 동작하는 대규모 생태계가 함께합니다. 안전하고 안정적이며 업데이트되고 기본 Flutter SDK에 없는 광범위한 API 빌드를 제공합니다.\n\n- GetX는 비대하지 않습니다. 아무 걱정없이 프로그래밍을 시작할 수 있는 다양한 기능이 있지만 각 기능은 별도의 컨테이너에 있으며 사용한 후에만 시작됩니다. 만약 상태 관리만 사용하면 오직 상태 관리만 컴파일 됩니다. 라우트만 사용하는 경우 상태 관리는 컴파일되지 않습니다.\n\n- GetX는 거대한 생태계, 대규모 커뮤니티, 수많은 공동 작업자를 보유하고 있으며 Flutter가 존재하는 한 유지됩니다. GetX도 Android, iOS, 웹, Mac, Linux, Windows 및 서버에서 동일한 코드로 실행할 수 있습니다.\n**[Get Server](https://github.com/jonataslaw/get_server)를 사용한 백엔드에는 프런트엔드에서 만든 코드를 완전히 재사용 할 수 있습니다.**\n\n**추가로 [Get CLI](https://github.com/jonataslaw/get_cli)를 프런트엔드와 서버 양쪽에서 사용하면 전체 개발 프로세스를 자동화 할 수 있습니다.**\n\n**추가로 생산성 향상을 위해 \n[VSCode 확장](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets)과 [Android Studio/Intellij 확장](https://plugins.jetbrains.com/plugin/14975-getx-snippets)이 있습니다.**\n\n# 설치\n\npubspec.yaml 파일에 Get 추가:\n\n```yaml\ndependencies:\n  get:\n```\n\n사용할 파일에 Import get:\n\n```dart\nimport 'package:get/get.dart';\n```\n\n# GetX를 사용한 Counter 앱\n\nFlutter의 새 프로젝트에서 기본적으로 생성 되는 \"counter\" 프로젝트는 100줄이 넘습니다 (코멘트 포함). Get의 강력함을 보여주기 위해 클릭 할 때마다 상태를 변경하고, 페이지 사이를 전환하고, 화면 사이의 상태를 공유하는 \"counter\"를 만드는 방법을 주석이 포함된 26줄의 코드로 보여줄 것입니다.\n\n- 1 단계:\n  MaterialApp 에 \"Get\"을 추가하여 GetMaterialApp 으로 변경합니다.\n\n```dart\nvoid main() => runApp(GetMaterialApp(home: Home()));\n```\n\n- 주석: 이는 Flutter의 MaterialApp을 변경하지 않으며 GetMaterialApp 또한 수정 된 MaterialApp이 아니고, 기본 MaterialApp을 자식으로 갖는 사전 구성된 위젯 일뿐입니다. 수동으로 구성 할 수 있지만 반드시 필요한 것은 아닙니다. GetMaterialApp은 라우트를 생성하고 추가하며, 번역을 추가하고, 라우트 탐색에 필요한 모든 것을 추가합니다. 만약 상태 관리 또는 종속성 관리에만 Get을 사용하는 경우 GetMaterialApp을 사용할 필요가 없습니다. GetMaterialApp은 라우트, 스택바, 국제화, bottomSheets, 다이얼로그 및 컨텍스트 부재와 라우트에 연관된 상위 api들에 필요합니다.\n- 주석²: 이 단계는 라우트 관리 (`Get.to ()`,`Get.back ()` 등)를 사용하려는 경우에만 필요합니다. 사용하지 않을 경우 1 단계를 수행 할 필요가 없습니다.\n\n- 2 단계:\n  비즈니스 로직 클래스를 만들고 모든 변수, 함수, 컨트롤러를 포함하십시오.\n  \".obs\"를 이용하면 간단히 모든 변수를 observable로 만들수 있습니다.\n\n```dart\nclass Controller extends GetxController{\n  var count = 0.obs;\n  increment() => count++;\n}\n```\n\n- 3 단계:\n  StatelessWidget를 이용해 View를 만들어 RAM을 아끼고 StatefulWidget은 더 이상 사용하지 않아도 됩니다.\n\n```dart\nclass Home extends StatelessWidget {\n\n  @override\n  Widget build(context) {\n\n    // Get.put()을 사용하여 클래스를 인스턴스화하여 모든 \"child'에서 사용가능하게 합니다.\n    final Controller c = Get.put(Controller());\n    \n    return Scaffold(\n      // count가 변경 될 때마다 Obx(()=> 를 사용하여 Text()에 업데이트합니다.\n      appBar: AppBar(title: Obx(() => Text(\"Clicks: ${c.count}\"))),\n\n      // 8줄의 Navigator.push를 간단한 Get.to()로 변경합니다. context는 필요없습니다.\n      body: Center(child: ElevatedButton(\n              child: Text(\"Go to Other\"), onPressed: () => Get.to(Other()))),\n      floatingActionButton:\n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n  }\n}\n\nclass Other extends StatelessWidget {\n  // 다른 페이지에서 사용되는 컨트롤러를 Get으로 찾아서 redirect 할 수 있습니다.\n  final Controller c = Get.find();\n\n  @override\n  Widget build(context){\n     // 업데이트된 count 변수에 연결\n     return Scaffold(body: Center(child: Text(\"${c.count}\")));\n  }\n}\n```\n\n결론:\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/counter-app-gif.gif)\n\n이것은 간단한 프로젝트 이지만 Get이 얼마나 강력한지 명확히 보여줍니다. 프로젝트가 성장하면 차이점이 더 커질 것 입니다.\n\nGet은 팀단위 업무에 맞춰 디자인되었지만 개별 개발자의 작업도 단순화합니다.\n\n마감일을 개선하고 성능의 손실 없이 재시간에 제공하십시오. Get은 모두를 위한 것은 아니지만 위의 설명에 해당사항이 있으면 당신을 위한 것입니다!\n\n# 세가지 주요점\n\n## 상태 관리\n\nGet은 두가지 상태 관리자가 있습니다: 단순 상태관리자(GetBuilder라고 함)와 반응형 상태관리자(GetX/Obx)\n\n### 반응형 상태 관리자\n\n반응형 프로그래밍은 복잡하다고 알려져있기 때문에 많은 사람들에게 소외될 수 있습니다. GetX가 매우 단순하게 반응형 프로그래밍을 바꿉니다:\n\n- StreamControllers를 만들 필요가 없습니다.\n- 각 변수에 대해 StreamBuilder를 만들 필요가 없습니다.\n- 각각의 상태(state)를 위한 클래스를 만들 필요가 없습니다.\n- 초기값을 위한 get이 필요하지 않습니다.\n- 코드 생성기를 사용할 필요가 없습니다.\n\nGet의 반응형 프로그램은 setState를 사용하는 것 만큼 쉽습니다.\n\n매번 변경되기를 원하고 모든 위젯에서 자동적으로 반영되는 변수가 있다고 가정해봅시다.\n\n여기 name 변수가 있습니다:\n\n```dart\nvar name = 'Jonatas Borges';\n```\n\n\".obs\"만 끝에 추가하여 observable로 만듭니다:\n\n```dart\nvar name = 'Jonatas Borges'.obs;\n```\n\n아래와 같이 간단히 보여주고 싶은 UI에 추가하면 값이 변경될때마다 화면에 업데이트 됩니다:\n\n```dart\nObx(() => Text(\"${controller.name}\"));\n```\n\n이게 다 입니다. _정말_ 간단하죠.\n\n### 상태 관리에 대한 자세한 내용\n\n**상태 관리에 대한 자세한 설명은 [여기](./documentation/kr_KO/state_management.md)를 보십시오. 여기에서 더 많은 예제와 단순 상태 관리자와 반응형 상태 관리자의 차이점을 볼 수 있습니다.**\n\nGetX 능력에 대한 좋은 아이디어를 얻을 수 있습니다.\n\n## 라우트 관리\n\n만약 라우트/스낵바/다이얼로그/bottomsheets을 context 없이 사용하려면 GetX는 훌륭한 대안입니다. 여기를 보십시오:\n\nMaterialApp 앞에 \"Get\"을 추가해서 GetMaterialApp으로 변경합니다.\n\n```dart\nGetMaterialApp( // Before: MaterialApp(\n  home: MyHome(),\n)\n```\n\n새로운 화면으로 이동합니다:\n\n```dart\n\nGet.to(NextScreen());\n```\n\n명칭으로 새로운 화면으로 이동합니다. 명칭으로 라우트하는 더 자세한 사항은 [여기](./documentation/kr_KO/route_management.md#이름있는-라우트-탐색) 있습니다.\n\n```dart\n\nGet.toNamed('/details');\n```\n\n스낵바, 다이얼로그, bottomsheets 또는 Navigator.pop(context);로 닫아야 하는 어떤것도 닫게 합니다:\n\n```dart\nGet.back();\n```\n\n다음 화면으로 이동하고 이전 화면으로 돌아갈 필요가 없는 경우 (스플래시, 로그인화면 등..)\n\n```dart\nGet.off(NextScreen());\n```\n\n다음 화면으로 이동하고 이전 화면들 모두 닫는 경우 (쇼핑카트, 투표, 테스트에 유용)\n\n```dart\nGet.offAll(NextScreen());\n```\n\n이러한 작업을 수행하기 위해 컨텍스트를 사용할 필요가 없다는 것을 보셨나요? 이것이 Get 라우트 관리를 사용하는 가장 큰 장점 중 하나입니다. 이를 통해 걱정없이 컨트롤러 클래스 내에서 이러한 모든 메서드를 실행할 수 있습니다.\n\n### 라우트 관리에 대한 자세한 내용\n\n**Get은 명명된 라우트로 작업하고 더 쉬운 방식으로 라우트의 제어를 제공합니다! [여기](./documentation/kr_KO/route_management.md)에 더 자세한 문서가 있습니다.**\n\n## 종속성 관리\n\nGet은 간단하고 강력한 종속성 관리자를 가지고 있어 Bloc나 Controller와 유사한 클래스를 Provide context, inheritedWidget 없이 1줄의 코드로 끌어낼 수 있습니다:\n\n```dart\nController controller = Get.put(Controller()); // Rather Controller controller = Controller();\n```\n\n- 주석: Get의 상태 관리자를 사용중이면 뷰를 controller에 더 쉽게 연결할 수 있는 바인딩 api에 더 주의를 기울이십시오.\n\n사용 중인 클래스에서 클래스를 인스턴스화하는 대신에 Get 인스턴스에서 인스턴스화하면 앱에서 해당 클래스를 사용할 수 있습니다.\n그래서 controller(또는 Bloc)를 정상적으로 사용할 수 있습니다.\n\n**팁:** Get 종속성 관리는 패키지의 다른 부분과 분리되어서 예제 앱이 이미 상태 관리자(하나여도 상관없음)를 사용중이면 모두 다시 작성할 필요 없이 아무 문제 없이 종속성 주입을 사용할 수 있습니다.\n\n```dart\ncontroller.fetchApi();\n```\n\n여러 경로들을 탐색했고 controller에 남아있는 데이터가 필요가 있다고 가정하십시오. Get_it이나 Provider와 조합된 상태 관리자가 필요합니다. 맞습니까? Get은 아닙니다. 다른 추가적인 종속성이 필요없이 controller를 Get의 \"find\"로 찾으면 됩니다:\n\n```dart\nController controller = Get.find();\n//마법처럼 Get이 controller를 찾아서 가져올 것 입니다. 백만개의 인스턴스화 contrller를 가질수 있고 Get은 올바른 controller를 항상 가져다 줄 것입니다.\n```\n\n그리고나서 가져온 controller 데이터를 사용할 수 있습니다:\n\n```dart\nText(controller.textFromApi);\n```\n\n### 종속성 관리에 대한 자세한 내용\n\n**종속성 관리에 대한 더 자세한 사항은 [여기](./documentation/kr_KO/dependency_management.md)에 있습니다.**\n\n# 기능들\n\n## 국제화\n\n### 번역\n\n번역은 간단한 key-value 맵으로 유지됩니다.\n커스텀 번역을 추가하려면 `Translations`으로 확장하여 클래스를 만드세요.\n\n```dart\nimport 'package:get/get.dart';\n\nclass Messages extends Translations {\n  @override\n  Map<String, Map<String, String>> get keys => {\n        'en_US': {\n          'hello': 'Hello World',\n        },\n        'de_DE': {\n          'hello': 'Hallo Welt',\n        }\n      };\n}\n```\n\n#### 번역 사용법\n\n단지 `.tr`로 명시된 키만 추가하면 `Get.locale`과 `Get.fallbackLocale`의 현재값을 사용해서 번역될 것 입니다.\n\n```dart\nText('title'.tr);\n```\n\n#### 단수와 복수의 번역 사용법\n\n```dart\nvar products = [];\nText('singularKey'.trPlural('pluralKey', products.length, Args));\n```\n\n#### 파라미터로 번역 사용하는 방법\n\n```dart\nimport 'package:get/get.dart';\n\n\nMap<String, Map<String, String>> get keys => {\n    'en_US': {\n        'logged_in': 'logged in as @name with email @email',\n    },\n    'es_ES': {\n       'logged_in': 'iniciado sesión como @name con e-mail @email',\n    }\n};\n\nText('logged_in'.trParams({\n  'name': 'Jhon',\n  'email': 'jhon@example.com'\n  }));\n```\n\n### 지역화\n\n`GetMaterialApp`의 파라미터를 전달하여 지역과 번역어를 정의합니다.\n\n```dart\nreturn GetMaterialApp(\n    translations: Messages(), // 번역들\n    locale: Locale('en', 'US'), // 해당 지역의 번역이 표시\n    fallbackLocale: Locale('en', 'UK'), // 잘못된 지역이 선택된 경우 복구될 지역을 지정\n);\n```\n\n#### 지역 변경\n\n지역을 업데이트할때 `Get.updateLocale(locale)`를 콜하십시오. 새로운 지역을 사용하여 자동적으로 번역합니다.\n\n```dart\nvar locale = Locale('en', 'US');\nGet.updateLocale(locale);\n```\n\n#### 시스템 지역\n\n`Get.deviceLocale`를 사용해서 시스템 지역을 읽어옵니다.\n\n```dart\nreturn GetMaterialApp(\n    locale: Get.deviceLocale,\n);\n```\n\n## 테마 변경\n\n테마를 업데이트하기 위해 `GetMaterialApp` 보다 더 상위 위젯을 사용하지 말아 주십시오. 이러면 중복 키가 트리거 될 수 있습니다. 많은 사람들이 테마를 바꾸기 위해 \"ThemeProvider\" 위젯을 사용하고 있는데 **GetX**는 이런 방식이 필요 없습니다.\n\n다른 표준사항은 없이 `Get.changeTheme`로 추가하고 간단하게 커스텀 테마를 만들수 있습니다:\n\n```dart\nGet.changeTheme(ThemeData.light());\n```\n\n`onTap`에 테마 변경이 있는 버튼 같은 무언가를 만들고 싶다면 두개의 **GetX™** API를 조합하여 가능합니다:\n\n- 다크`테마`를 사용중인지 확인합니다.\n- 그리고 `테마` 변경 API 를 `onPressed`에 넣으면 됩니다:\n\n```dart\nGet.changeTheme(Get.isDarkMode? ThemeData.light(): ThemeData.dark());\n```\n\n`.darkmode`가 활성화 될때 _light theme_ 로 바뀔것 이고 _light theme_ 가 활성화되면 _dark theme_ 로 변경될 것입니다.\n\n## GetConnect\n\nGetConnect는 http나 websockets으로 프론트와 백엔드의 통신을 위한 쉬운 방법입니다.\n\n### 기본 구성\n\nGetConnect를 간단하게 확장하고 Rest API나 websockets의 GET/POST/PUT/DELETE/SOCKET 메서드를 사용할 수 있습니다.\n\n```dart\nclass UserProvider extends GetConnect {\n  // Get request\n  Future<Response> getUser(int id) => get('http://youapi/users/$id');\n  // Post request\n  Future<Response> postUser(Map data) => post('http://youapi/users', body: data);\n  // Post request with File\n  Future<Response<CasesModel>> postCases(List<int> image) {\n    final form = FormData({\n      'file': MultipartFile(image, filename: 'avatar.png'),\n      'otherFile': MultipartFile(image, filename: 'cover.png'),\n    });\n    return post('http://youapi/users/upload', form);\n  }\n\n  GetSocket userMessages() {\n    return socket('https://yourapi/users/socket');\n  }\n}\n```\n\n### 커스텀 구성\n\nGetConnect는 고도로 커스텀화 할 수 있습니다. base Url을 정의하고 응답자 및 요청을 수정하고 인증자를 정의할 수 있습니다. 그리고 인증 횟수까지 정의 할 수 있습니다. 더해서 추가 구성없이 모델로 응답을 변형시킬 수 있는 표준 디코더 정의도 가능합니다.\n\n```dart\nclass HomeProvider extends GetConnect {\n  @override\n  void onInit() {\n    // 모든 요청은 jsonEncode로 CasesModel.fromJson()를 거칩니다.\n    httpClient.defaultDecoder = CasesModel.fromJson;\n    httpClient.baseUrl = 'https://api.covid19api.com';\n    // baseUrl = 'https://api.covid19api.com';\n    // [httpClient] 인스턴트 없이 사용하는경우 Http와 websockets의 baseUrl 정의\n    \n    // 모든 요청의 헤더에 'apikey' 속성을 첨부합니다.\n    httpClient.addRequestModifier((request) {\n      request.headers['apikey'] = '12345678';\n      return request;\n    });\n\n    // 서버가 \"Brazil\"이란 데이터를 보내더라도\n    // 응답이 전달되기 전에 응답의 데이터를 지우기 때문에 \n    // 사용자에게 표시되지 않을 것입니다.\n    httpClient.addResponseModifier<CasesModel>((request, response) {\n      CasesModel model = response.body;\n      if (model.countries.contains('Brazil')) {\n        model.countries.remove('Brazilll');\n      }\n    });\n\n    httpClient.addAuthenticator((request) async {\n      final response = await get(\"http://yourapi/token\");\n      final token = response.body['token'];\n      // 헤더 설정\n      request.headers['Authorization'] = \"$token\";\n      return request;\n    });\n\n    // 인증자가 HttpStatus가 HttpStatus.unauthorized이면\n    // 3번 호출됩니다.\n    httpClient.maxAuthRetries = 3;\n  }\n  }\n\n  @override\n  Future<Response<CasesModel>> getCases(String path) => get(path);\n}\n```\n\n## GetPage Middleware\n\nGetPage는 GetMiddleWare의 목록을 특정 순서로 실행하는 새로운 프로퍼티를 가집니다.\n\n**주석**: GetPage가 Middleware를 가질때 페이지의 모든 하위는 같은 Middleware를 자동적으로 가지게 됩니다.\n\n### Priority\n\nMiddleware의 실행 순서는 GetMiddleware안의 priority에 따라서 설정할 수 있습니다.\n\n```dart\nfinal middlewares = [\n  GetMiddleware(priority: 2),\n  GetMiddleware(priority: 5),\n  GetMiddleware(priority: 4),\n  GetMiddleware(priority: -8),\n];\n```\n\n이 Middleware는 다음 순서로 실행됩니다. **-8 => 2 => 4 => 5**\n\n### Redirect\n\n이 함수는 호출된 라우트의 페이지를 검색할때 호출됩니다. 리다이렉트한 결과로 RouteSettings을 사용합니다. 또는 null을 주면 리다이렉트 하지 않습니다.\n\n```dart\nRouteSettings redirect(String route) {\n  final authService = Get.find<AuthService>();\n  return authService.authed.value ? null : RouteSettings(name: '/login')\n}\n```\n\n### onPageCalled\n\n이 함수는 생성되지 않은 페이지가 호출될 때 호출됩니다.\n페이지에 대한 어떤것을 변경하는데 사용하거나 새로운 페이지를 줄 수 있습니다.\n\n```dart\nGetPage onPageCalled(GetPage page) {\n  final authService = Get.find<AuthService>();\n  return page.copyWith(title: 'Welcome ${authService.UserName}');\n}\n```\n\n### OnBindingsStart\n\n이 함수는 Bindings가 초기화되기 바로 직전에 호출됩니다.\n여기에서 이 페이지를 위해 Bindings을 변경할 수 있습니다.\n\n```dart\nList<Bindings> onBindingsStart(List<Bindings> bindings) {\n  final authService = Get.find<AuthService>();\n  if (authService.isAdmin) {\n    bindings.add(AdminBinding());\n  }\n  return bindings;\n}\n```\n\n### OnPageBuildStart\n\n이 함수는 Bindings가 초기화된 직후에 호출됩니다.\n여기에서 bindings를 생성한 후 페이지 위젯을 생성하기 전에 무엇이든 할 수 있습니다.\n\n```dart\nGetPageBuilder onPageBuildStart(GetPageBuilder page) {\n  print('bindings are ready');\n  return page;\n}\n```\n\n### OnPageBuilt\n\n이 함수는 GetPage.page 함수가 호출된 직후에 호출며 함수의 결과를 제공합니다. 그리고 표시될 위젯을 가져옵니다.\n\n### OnPageDispose\n\n이 함수는 페이지의 연관된 모든 오브젝트들(Controllers, views, ...)이 해제된 직후에 호출됩니다.\n\n## 기타 고급 API\n\n```dart\n// currentScreen에서 현재 인수들을 제공\nGet.arguments\n\n// 이전 경로의 이름을 제공\nGet.previousRoute\n\n// rawRoute.isFirst()와 같은 접근에 필요한 원시 경로를 제공\nGet.rawRoute\n\n// GetObserver로 부터 Rounting API의 접근을 제공\nGet.routing\n\n// snackbar가 열려 있는지 확인\nGet.isSnackbarOpen\n\n// dialog가 열려 있는지 확인\nGet.isDialogOpen\n\n// bottomsheet가 열려 있는지 확인\nGet.isBottomSheetOpen\n\n// 1개의 경로 제거\nGet.removeRoute()\n\n// 값이 true가 될때까지 반복적으로 되돌림\nGet.until()\n\n// 다음 경로로 이동하고 값이 true가 될때까지 이전 모든 경로를 제거\nGet.offUntil()\n\n// 명명된 다음 경로로 이동하고 값이 true가 될때까지 이전 모든 경로를 제거\nGet.offNamedUntil()\n\n// 앱이 구동중인 플랫폼을 확인\nGetPlatform.isAndroid\nGetPlatform.isIOS\nGetPlatform.isMacOS\nGetPlatform.isWindows\nGetPlatform.isLinux\nGetPlatform.isFuchsia\n\n// 장치 타입을 확인\nGetPlatform.isMobile\nGetPlatform.isDesktop\n// 모든 플랫폼은 독립적으로 웹을 제공합니다!\n// Windows, iOS, OSX, Android 등의\n// 브러우저에서 구동중이면 알 수 있습니다.\nGetPlatform.isWeb\n\n\n// MediaQuery.of(context).size.height 과 동일\n// 하지만 불변함.\nGet.height\nGet.width\n\n// Navigator의 현재 context를 제공\nGet.context\n\n// 코드 어디에서든지 foreground에서 snackbar/dialog/bottomsheet의 context를 제공\nGet.contextOverlay\n\n// 주석: 다음 메서드는 context의 확장입니다.\n// UI의 모든 위치에서 컨텍스트에 액세스 할 수 있으므로 UI 코드의 어느 곳에서나 사용할 수 있습니다.\n\n// 변경되는 height/width(데스크탑이나 브라우저와 같이 늘어날 수 있는 것)가 필요하면 context를 사용해야함\ncontext.width\ncontext.height\n\n// 화면의 절반, 1/3 등을 정의할 수 있는 기능을 제공합니다.\n// 반응성이 높은 앱에 유용합니다.\n// param dividedBy (double) optional - default: 1\n// param reducedBy (double) optional - default: 0\ncontext.heightTransformer()\ncontext.widthTransformer()\n\n/// MediaQuery.of(context).size 와 유사함\ncontext.mediaQuerySize()\n\n/// MediaQuery.of(context).padding 와 유사함\ncontext.mediaQueryPadding()\n\n/// MediaQuery.of(context).viewPadding 와 유사함\ncontext.mediaQueryViewPadding()\n\n/// MediaQuery.of(context).viewInsets; 와 유사함\ncontext.mediaQueryViewInsets()\n\n/// MediaQuery.of(context).orientation; 와 유사함\ncontext.orientation()\n\n/// 장치의 가로 모드 확인\ncontext.isLandscape()\n\n/// 장치의 세로 모드 확인\ncontext.isPortrait()\n\n/// MediaQuery.of(context).devicePixelRatio; 와 유사함\ncontext.devicePixelRatio()\n\n/// MediaQuery.of(context).textScaleFactor; 와 유사함\ncontext.textScaleFactor()\n\n/// 화면에서 shortestSide를 제공\ncontext.mediaQueryShortestSide()\n\n/// True if width be larger than 800\ncontext.showNavbar()\n\n/// shortestSide가 600p 미만이면 True\ncontext.isPhone()\n\n/// shortestSide가 600p 이상이면 True\ncontext.isSmallTablet()\n\n/// shortestSide가 720p 이상이면 True\ncontext.isLargeTablet()\n\n/// 현재 장치가 Tablet이면 True\ncontext.isTablet()\n\n/// 화면 사이즈에 따라 value<T>를 반환\n/// 반환될 수 있는 값들:\n/// watch: shortestSide가 300 미만일 때\n/// mobile: shortestSide가 600 미만일 때\n/// tablet: shortestSide가 1200 미만일 때\n/// desktop: shortestSide가 1200 이상일 때\ncontext.responsiveValue<T>()\n```\n\n### 선택적 전역 설정과 수동 구성\n\nGetMaterialApp은 모든 것이 구성되어 있지만 원한다면 수동으로 Get을 구성할 수 있습니다.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver()],\n);\n```\n\n`GetObserver`안에 Middleware를 사용할 수 있고 이로 인한 어떤 영향도 없습니다.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [\n    GetObserver(MiddleWare.observer) // Here\n  ],\n);\n```\n\n`Get`을 위한 _Global Settings_ 을 만들수 있습니다. 어떠한 라우트도 포함되기 전에 `Get.config`에 추가하십시오.\n또는 `GetMaterialApp`에 직접 추가 하십시오.\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  defaultTransition: Transition.fade,\n  opaqueRoute: Get.isOpaqueRouteDefault,\n  popGesture: Get.isPopGestureEnable,\n  transitionDuration: Get.defaultDurationTransition,\n  defaultGlobalState: Get.defaultGlobalState,\n);\n\nGet.config(\n  enableLog = true,\n  defaultPopGesture = true,\n  defaultTransition = Transitions.cupertino\n)\n```\n\n선택적으로 `Get`으로 모든 로그 메세지를 리다이렉트 할 수 있습니다.\n만약 유명한 로그 패키지를 사용하고 싶으면\n여기에서 원하는 로그가 있습니다:\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  logWriterCallback: localLogWriter,\n);\n\nvoid localLogWriter(String text, {bool isError = false}) {\n  // pass the message to your favourite logging package here\n  // please note that even if enableLog: false log messages will be pushed in this callback\n  // you get check the flag if you want through GetConfig.isLogEnable\n}\n\n```\n\n### 지역 상태 위젯들\n\n이러한 위젯은 단일값을 관리하고 지역적이고 임시적인 상태를 유지합니다.\n우리는 반응적이고 단순함을 위해 추가할 수 있습니다.\n예를 들어 `TextField`의 obscureText의 전환으로 사용하거나 \n커스텀된 확장되는 패널을 만들거나 \n`Scaffold`의 body가 변경되는 동안 `BottomNavigationBar`의 현재 index를 수정할 수 있습니다.\n\n#### ValueBuilder\n\n업데이트된 값을 되돌려 받는 `.setState`로 작동하는 `StatefulWidget`의 단순화 입니다.\n\n```dart\nValueBuilder<bool>(\n  initialValue: false,\n  builder: (value, updateFn) => Switch(\n    value: value,\n    onChanged: updateFn, // same signature! you could use ( newValue ) => updateFn( newValue )\n  ),\n  // if you need to call something outside the builder method.\n  onUpdate: (value) => print(\"Value updated: $value\"),\n  onDispose: () => print(\"Widget unmounted\"),\n),\n```\n\n#### ObxValue\n\n[`ValueBuilder`](#valuebuilder)와 비슷하지만 Rx 인스턴스(마법같은 .obs를 기억하세요)를 전달하고 \n자동적으로 업데이트되는 반응형 버전입니다... 놀랍지 않습니까?\n\n```dart\nObxValue((data) => Switch(\n        value: data.value,\n        onChanged: data, // Rx에는 호출가능한 함수가 있습니다! (flag) => data.value = flag, 가 사용가능 합니다.\n    ),\n    false.obs,\n),\n```\n\n## 유용한 팁\n\n`.obs`(_Rx_ 타입이라고 알려진)는 다양한 내부 메서드와 연산자가 있습니다.\n\n> `.obs`프로퍼티가 **실제 값**이라고 _믿는_ 것은 일반적이지만 실수하지 마십시오!\n> 다트의 컴파일러는 충분히 똑똑하고 코드가 깔끔하기 때문에 변수의 타입 선언을 하지 않습니다.\n> 하지만:\n\n```dart\nvar message = 'Hello world'.obs;\nprint( 'Message \"$message\" has Type ${message.runtimeType}');\n```\n\n`message`가 실제 String 값을 _출력_ 하더라도 타입은 **RxString**입니다!\n\n그래서 `message.substring( 0, 4 )`은 사용하지 못합니다.\n_observable(.obs)_ 안의 실제 값에 접근해야 합니다:\n가장 많이 사용되는 방법은 `.value`지만 사용할 수 있었는지 알고 있었나요...\n\n```dart\nfinal name = 'GetX'.obs;\n// 현재 값과 다른 값이면 stream을 업데이트만 합니다.\nname.value = 'Hey';\n\n// 모든 Rx 프로퍼티가 \"호출 가능\"하고 새로운 값을 반환합니다.\n// 하지만 이 접근방식은 `null`를 허용하지 않고 UI가 재구축하지 않습니다.\nname('Hello');\n\n// getter와 과 같이 'Hello'를 출력합니다.\nname() ;\n\n/// 숫자 타입들:\n\nfinal count = 0.obs;\n\n// 기존 숫자 타입으로 모든 변형 불가 작업을 사용할수 있습니다.\ncount + 1;\n\n// 주의하세요! 아래는 `count`가 final이 아닌 경우에만 유효합니다.\ncount += 1;\n\n// 값들을 비교할 수도 있습니다:\ncount > 2;\n\n/// booleans:\n\nfinal flag = false.obs;\n\n// true/false 사이의 전환이 됩니다.\nflag.toggle();\n\n\n/// 모든 타입들:\n\n// `값`을 null로 셋합니다.\nflag.nil();\n\n//  모든 toString(), toJson() 함수들은 `값`으로 전달됩니다.\nprint( count ); // RxInt 내부에서 `toString()`이 호출됩니다.\n\nfinal abc = [0,1,2].obs;\n// 값을 json 배열로 바꾸고 RxList를 출력합니다.\n// Json은 모든 Rx 타입들을 지원합니다!\nprint('json: ${jsonEncode(abc)}, type: ${abc.runtimeType}');\n\n// RxMap, RxList 그리고 RxSet은 그들의 native 타입들을 확장한 특별한 Rx 타입들입니다.\n// 반응형이긴 하지만 일반 list로서 RxList가 동작합니다!\nabc.add(12); // list에 12가 들어가고 stream을 업데이트합니다.\nabc[3]; // List와 같이 인덱스 3을 읽습니다.\n\n\n// 동등비교는 Rx와 값에서 동작하지만 해시코드는 항상 값으로부터 받습니다.\nfinal number = 12.obs;\nprint( number == 12 ); // prints > true\n\n/// 커스텀 Rx 모델들:\n\n// toJson(), toString()은 child에게 지연됩니다. 그래서 이것들을 재정의 하고 직접 관찰하여 print() 할수 있습니다.\n\nclass User {\n    String name, last;\n    int age;\n    User({this.name, this.last, this.age});\n\n    @override\n    String toString() => '$name $last, $age years old';\n}\n\nfinal user = User(name: 'John', last: 'Doe', age: 33).obs;\n\n// `user`는 \"반응형\"이지만 내부 프로퍼티들은 아닙니다!\n// 그래서 만약 내부의 변수를 바꾸면...\nuser.value.name = 'Roi';\n// 위젯은 재구성 되지 않을것 입니다!\n// user의 내부의 무언가가 바뀌어도 `Rx`는 알 수가 않습니다.\n// 그래서 커스텀 클래스들은 수동으로 바뀌었다고 \"알릴\" 필요가 있습니다.\nuser.refresh();\n\n// 또는 `update()` 함수를 사용할 수 있습니다!\nuser.update((value){\n  value.name='Roi';\n});\n\nprint( user );\n```\n## StateMixin\n\n`UI` 상태를 처리하는 또 다른 방법은 `StateMixin<T>` 를 사용하는 것입니다.\n이를 구현하려면 `with`를 사용하여 `StateMixin<T>`을 추가하고\nT 모델을 허용하는 컨트롤러에 연결합니다.\n\n``` dart\nclass Controller extends GetController with StateMixin<User>{}\n```\n\n`change()` 메소드는 우리가 원할 때마다 State를 변경합니다.\n다음과 같이 데이터와 상태를 전달하면 됩니다:\n\n```dart\nchange(data, status: RxStatus.success());\n```\n\nRxStatus는 다음 상태를 허용합니다:\n\n``` dart\nRxStatus.loading();\nRxStatus.success();\nRxStatus.empty();\nRxStatus.error('message');\n```\n\nUI에서 사용하는 방법:\n\n```dart\nclass OtherClass extends GetView<Controller> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n\n      body: controller.obx(\n        (state)=>Text(state.name),\n        \n        // 여기에 사용자 정의 로딩 표시기를 넣을 수 있지만\n        // 기본값은 Center(child:CircularProgressIndicator()) 입니다\n        onLoading: CustomLoadingIndicator(),\n        onEmpty: Text('No data found'),\n\n        // 여기에서도 자신의 오류 위젯을 설정할 수 있지만\n        // 기본값은 Center(child:Text(error)) 입니다\n        onError: (error)=>Text(error),\n      ),\n    );\n}\n```\n\n#### GetView\n\n이 위젯을 사랑합니다. 매우 간단하고 유용합니다!\n\n등록된 `Controller`인 `controller`의 getter로 가져온 `const Stateless`위젯 입니다. 이게 전부입니다.\n\n```dart\n class AwesomeController extends GetxController {\n   final String title = 'My Awesome View';\n }\n\n  // controller를 등록할때 사용한 `타입`을 전달하는 것을 항상 기억하세요!\n class AwesomeView extends GetView<AwesomeController> {\n   @override\n   Widget build(BuildContext context) {\n     return Container(\n       padding: EdgeInsets.all(20),\n       child: Text(controller.title), // 단지 `controller.something`을 호출합니다.\n     );\n   }\n }\n```\n\n#### GetResponsiveView\n\nResponsiveView 를 빌드하려면 이 위젯을 확장하세요. 이 위젯에는 화면 크기 및 유형에 대한 모든 정보가 있는 화면 속성이 포함되어 있습니다.\n\n##### 사용 방법\n\n그것을 빌드하기 위한 두가지 옵션이 있습니다.\n- `builder` method 를 사용하면 빌드 할 위젯을 반환합니다.\n- `desktop`, `tablet`, `phone`, `watch` method를 사용하면 특정 메소드는 screen type 이 일치할때 빌드됩니다. Screen type이 [ScreenType.Tablet] 일때, tablet method 가 스며나옵니다. 참고: 만약 이 method 를 사용할 경우, `alwaysUseBuilder` 프로퍼티를 `false` 로 설정해주세요.   \n \n`settings` 프로퍼티를 사용하면 screen types 를 위한 width limit 를 설정할 수 있습니다.\n\n![example](https://github.com/SchabanBo/get_page_example/blob/master/docs/Example.gif?raw=true)\nCode to this screen\n[code](https://github.com/SchabanBo/get_page_example/blob/master/lib/pages/responsive_example/responsive_view.dart)\n\n#### GetWidget\n\n대부분의 사람들이 이 위젯에대해 모르거나 사용법을 완전히 혼동합니다.\n사용 사례는 매우 드물지만 매우 구체적입니다: Controller를 `caches`합니다.\n_cache_ 이기 때문에 `const Stateless`가 될 수 없습니다.\n\n> 그러면 언제 Controller를 \"cache\"할 필요가 있을까요?\n\n만약 **GetX**의 기능 중 또 다른 \"흔하지 않은\" 기능을 사용하는 경우:`Get.create()`\n\n`Get.create(()=>Controller())`가 `Get.find<Controller>()`을 호출할 때마다 \n새로운 `Controller`를 생성할 것 입니다.\n\n여기서 `GetWidget`이 빛나게 됩니다... 예를 들어 Todo 리스트를 유지하려고 사용할 때 입니다.\n위젯이 \"재구성\"될때 동일한 controller 인스턴스를 유지할 것입니다.\n\n#### GetxService\n\n이 클래스틑 `GetxController`와 같이 동일한 생성주기(`onInit()`, `onReady()`, `onClose()`)를 공유합니다.\n하지만 이안에 \"로직\"은 없습니다. 단지 **GetX** 종속성 주입 시스템이 하위클래스를 메모리에서 \n**삭제할 수 없음**을 알립니다.\n\n그래서 `Get.find()`로 활성화하고 항상 접근하는 \"서비스들\"을 유지하는데 매우 유용합니다. :\n`ApiService`, `StorageService`, `CacheService`.\n\n```dart\nFuture<void> main() async {\n  await initServices(); /// 서비스들 초기화를 기다림.\n  runApp(SomeApp());\n}\n\n/// 플러터 앱이 실행되기 전에 서비스들을 초기화하는 현명한 방법입니다.\n/// 실행 흐름을 제어 할수 있으므로(테마 구성, apiKey, 사용자가 정의한 언어등을 로드해야 할 필요가 있으므로 \n/// ApiService의 구동전에 SettingService를 로드해야 합니다.\n/// 그래서 GetMaterialApp()은 재구성하지 않고 직접적으로 값을 가져옵니다.\nFuture<void> initServices() async {\n  print('starting services ...');\n  /// 여기에서 get_storage, hive, shared_pref 초기화를 하세요.\n  /// 또는 연결 고정 또는 비동기적인 무엇이든 하세요.\n  await Get.putAsync(() => DbService().init());\n  await Get.putAsync(SettingsService()).init();\n  print('All services started...');\n}\n\nclass DbService extends GetxService {\n  Future<DbService> init() async {\n    print('$runtimeType delays 2 sec');\n    await 2.delay();\n    print('$runtimeType ready!');\n    return this;\n  }\n}\n\nclass SettingsService extends GetxService {\n  void init() async {\n    print('$runtimeType delays 1 sec');\n    await 1.delay();\n    print('$runtimeType ready!');\n  }\n}\n\n```\n\n`GetxService`를 실질적으로 지우는 한가지 방법은 앱의 \"Hot Reboot\"과 같은 `Get.reset()`뿐 입니다.\n따라서 앱 실행중 절대로 유지되어야 하는 클래스 인스턴스가 필요하면 \n`GetxService`를 사용하세요.\n\n### 테스트\n\n당신은 당신의 컨트롤러들을 생성주기를 포함하여 다른 어떤 클래스처럼 테스트할 수 있습니다 : \n\n```dart\nclass Controller extends GetxController {\n  @override\n  void onInit() {\n    super.onInit();\n    //name2로 값 변경\n    name.value = 'name2';\n  }\n\n  @override\n  void onClose() {\n    name.value = '';\n    super.onClose();\n  }\n\n  final name = 'name1'.obs;\n\n  void changeName() => name.value = 'name3';\n}\n\nvoid main() {\n  test('''\nTest the state of the reactive variable \"name\" across all of its lifecycles''',\n      () {\n    /// 당신은 생성주기를 제외하고 컨트롤러를 테스트할 수 있습니다,\n    /// 그러나 당신이 사용하지 않는다면 추천되지 않습니다\n    ///  GetX 종속성 주입 \n    final controller = Controller();\n    expect(controller.name.value, 'name1');\n\n    /// 당신이 그것을 사용한다면, 당신은 모든 것을 테스트할 수 있습니다,\n    /// 각각의 생성주기 이후 어플리케이션의 상태를 포함하여.\n    Get.put(controller); // onInit was called\n    expect(controller.name.value, 'name2');\n\n    /// 당신의 함수를 테스트하세요\n    controller.changeName();\n    expect(controller.name.value, 'name3');\n\n    /// onClose 호출됨\n    Get.delete<Controller>();\n\n    expect(controller.name.value, '');\n  });\n}\n```\n\n#### 팁들\n\n##### Mockito 또는 mocktail\n당신이 당신의 GetxController/GetxService를 모킹하려고 한다면, 당신은 GetxController를 extend 하고, Mock과 mixin 하라, 그렇게 되면 \n\n```dart\nclass NotificationServiceMock extends GetxService with Mock implements NotificationService {}\n```\n\n##### Get.reset() 사용하기\n당신이 위젯 또는 테스트 그룹을 테스트하고 있다면, 당신의 테스트의 마지막 또는 해제 때 당신의 이전 테스트에서 모든 설정을 리셋하기 위해 Get.rest을 사용하십시오\n\n##### Get.testMode \n당신이 당신의 컨트롤러에서 당신의 네비게이션을 사용하고 있다면, 당신의 메인의 시작에 `Get.testMode = true` 를 사용하십시오.\n\n\n# 2.0의 주요 변경점\n\n1- Rx 타입들:\n\n| 이전    | 이후       |\n| ------- | ---------- |\n| StringX | `RxString` |\n| IntX    | `RxInt`    |\n| MapX    | `RxMap`    |\n| ListX   | `RxList`   |\n| NumX    | `RxNum`    |\n| DoubleX | `RxDouble` |\n\nRxController와 GetBuilder는 합쳐졌습니다. 더이상 사용할 controller를 기억시킬 필요가 없습니다. GetxController를 사용하세요. 단순 및 반응형 상태관리 모두에서 잘 동작합니다.\n\n2- 명명된 라우트\n이전:\n\n```dart\nGetMaterialApp(\n  namedRoutes: {\n    '/': GetRoute(page: Home()),\n  }\n)\n```\n\n지금:\n\n```dart\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page: () => Home()),\n  ]\n)\n```\n\n무엇이 달라졌습니까?\n종종 매개 변수 또는 로그인 토큰에 의해 표시 할 페이지를 결정해야 할 수 있습니다. 이전 접근 방식은 이를 허용하지 않았기 때문에 유연하지 않았습니다.\n페이지를 함수에 삽입하면 앱이 시작된 이후 라우트가 메모리에 할당되지 않고 이러한 유형의 접근 방식이 가능하기 때문에 RAM 소비가 크게 감소했습니다:\n\n```dart\n\nGetStorage box = GetStorage();\n\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page:(){\n      return box.hasData('token') ? Home() : Login();\n    })\n  ]\n)\n```\n\n# 왜 Getx인가?\n\n1- 플러터가 업데이트된 이후 자주 많은 패키지가 깨졌을 것입니다. 때때로 컴파일중 에러가 발생하고 종종 이에 대해 답변을 해줄 사람이 없었을 겁니다. 그리고 개발자는 에러가 어디에서 발생했는지 추적해서 알아야합니다. 그리고 오직 리포지트리를 통해서 이슈를 오픈하고 해결책을 찾아야합니다. Get은 개발을 위한 주 리소스들(상태, 종속성, 라우트 관리)을 중앙화합니다. pubspec에 단일 패키지를 추가하고 작업을 시작 할 수 있습니다. 플러터가 업데이트 된 이후에도 Get 의존을 업데이트하면 작업할 수 있습니다. Get은 호환성 이슈도 해결합니다. 한 버전에서 종속적으로 사용하여 다른 버전에서 다른 버전을 사용할때 패키지 버전이 다른 버전과 호환되지 않는 경우가 몇 번입니까? 모든 것이 동일한 패키지에 있고 완벽하게 호환되므로 Get을 사용하면 문제가 되지 않습니다.\n\n2- 플러터는 쉽고 놀랍지만 대다수의 개발자들이 원하지 않는 몇가지 상용구가 있습니다. `Navigator.of(context).push (context, builder [...]` 같은 것들 입니다. Get은 개발을 단순화합니다. 라우트를 위해 8줄의 코드를 작성하고 `Get.to(Home())`만 하면 다음 페이지로 갈 수 있습니다. 동적 웹 url은 현재 플러터에서 정말로 고통스러운 것이고 GetX로 하는 것은 정말 간단합니다. 플러터에서 상태와 종속성을 관리하는 것은 pub에서 수백가지의 패턴이라 많은 논의를 생산합니다. 그러나 변수 끝에 \".obs\"를 추가하고 위젯을 Obx 안에 배치하는 것만큼 쉬운 것은 없습니다. 이것으로 해당 변수가 업데이트되면 화면에 자동으로 업데이트됩니다.\n\n3- 성능에 대하여 걱정하지 않아도 됩니다. 플러터의 성능은 이미 놀랍습니다. 하지만 상태관리자를 사용하고 blocs/stores/controllers 등의 클래스들을 로케이터로 배포하는 것을 상상해보십시오. 종속성이 필요 없는 경우 종속성 제외를 수동으로 호출해야 합니다. 하지만 간단하게 controller를 사용하고 이것들을 더이상 사용하지 않을때 간단하게 메모리에서 삭제될수 있을까요? 이것이 GetX가 하는 일입니다. SmartManagement를 사용하면 사용하지 않는 모든것이 메모리에서 삭제되기 때문에 프로그래밍 말고 다른 걱정을 할 필요가 없습니다. 이러한 로직을 만들지 않고도 최소한의 리소스만 사용함을 보장합니다.\n\n4- 실질적으로 분리됨. \"비즈니스 로직으로부터 뷰를 분리\"라는 개념을 들어보셨을 겁니다. 이것은 BLoC, MVC, MVVM의 특징이 아니며 이미 나와 있는 또 다른 표준 개념입니다. 그러나 이 개념은 context의 사용으로 인해 플러터에서 종종 완화됩니다.\n만약 InheritedWidget을 찾기 위해 context가 필요하면 뷰나 파라미터로 context를 전달해야 합니다. 저는 특히 이 방식이 매우 별로이고 팀의 작업이 항상 뷰의 비즈니스 로직에 의존하게 됩니다. GetX는 표준 접근에서 비정통적이고 StatefulWidgets, InitState 등의 사용을 완전 배제하지 않지만 항상 깔끔하게 유사한 접근을 제공합니다. 예를 들어 Controllers의 수명주기에서 APIREST 요청이 필요할 때 뷰에 어떤 것도 의존할 필요가 없습니다. http 호출의 초기화를 onInit 에서 사용가능 하고 데이터가 도착하면 변수들이 채워집니다. GetX는 완전히 반응형이며(실제 스트림으로 동작) 아이탬중 하나가 채워지면 이 변수를 사용중인 모든 위젯이 자동적으로 화면에서 갱신됩니다. 이를 통해 UI 전문가는 위젯으로만 작업하고 사용자 이벤트(예 : 버튼 클릭) 이외의 비즈니스 로직에 아무것도 보낼 필요가 없으며 비즈니스 로직을 개발하는 사람들은 비즈니스 로직을 별도로 만들고 테스트 할 수 있습니다.\n\n이 라이브러리는 항상 업데이트되고 새로운 기능이 포함됩니다. 자유롭게 PR을 제공하고 여기에 기여하세요.\n\n# 커뮤니티\n\n## 커뮤니티 채널\n\nGetX에는 매우 활동적이고 유용한 커뮤니티가 있습니다. 이 프레임워크의 사용과 관련하여 질문이 있거나 도움이 필요한 경우 커뮤니티 채널에 가입하십시오. 질문에 대한 답변이 더 빨리 제공되며 가장 적합한 장소가 될 것입니다. 이 저장소는 이슈오픈 및 리소스 요청 전용이지만 GetX 커뮤니티의 일부에 속해있습니다.\n\n| **Slack**                                                                                                                   | **Discord**                                                                                                                 | **Telegram**                                                                                                          |\n| :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |\n| [![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx) | [![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N) | [![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g) |\n\n## 기여하는 방법\n\n_프로젝트에 기여하고 싶으신가요? 우리는 귀하를 우리의 협력자 중 한 명으로 부각시켜 자랑스럽게 생각합니다. 다음은 Get(그리고 플러터)을 더욱 향상시키고 기여할 수 있는 몇 가지 사항입니다._\n\n- readme을 다른 언어로 번역하는 데 도움이 됩니다.\n- readme에 문서를 추가합니다(Get의 많은 기능이 아직 문서화되지 않았습니다).\n- Get 사용법을 설명하는 기사를 쓰거나 비디오를 만듭니다(읽기 및 향후 위키에 삽입될 예정).\n- 코드/테스트에 대한 PR을 제공합니다.\n- 새로운 기능을 포함합니다.\n\n어떤 기여도 환영합니다!\n\n## 기사 및 비디오\n\n- [Flutter Getx EcoSystem package for arabic people](https://www.youtube.com/playlist?list=PLV1fXIAyjeuZ6M8m56zajMUwu4uE3-SL0) - Tutorial by [Pesa Coder](https://github.com/UsamaElgendy).\n- [Dynamic Themes in 3 lines using GetX™](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Tutorial by [Rod Brown](https://github.com/RodBr).\n- [Complete GetX™ Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI) - Route management video by Amateur Coder.\n- [Complete GetX State Management](https://www.youtube.com/watch?v=CNpXbeI_slw) - State management video by Amateur Coder.\n- [GetX™ Other Features](https://youtu.be/ttQtlX_Q0eU) - Utils, storage, bindings and other features video by Amateur Coder.\n- [Firestore User with GetX | Todo App](https://www.youtube.com/watch?v=BiV0DcXgk58) - Video by Amateur Coder.\n- [Firebase Auth with GetX | Todo App](https://www.youtube.com/watch?v=-H-T_BSgfOE) - Video by Amateur Coder.\n- [The Flutter GetX™ Ecosystem ~ State Management](https://medium.com/flutter-community/the-flutter-getx-ecosystem-state-management-881c7235511d) - State management by [Aachman Garg](https://github.com/imaachman).\n- [The Flutter GetX™ Ecosystem ~ Dependency Injection](https://medium.com/flutter-community/the-flutter-getx-ecosystem-dependency-injection-8e763d0ec6b9) - Dependency Injection by [Aachman Garg](https://github.com/imaachman).\n- [GetX, the all-in-one Flutter package](https://www.youtube.com/watch?v=IYQgtu9TM74) - A brief tutorial covering State Management and Navigation by Thad Carnevalli.\n- [Build a To-do List App from scratch using Flutter and GetX](https://www.youtube.com/watch?v=EcnqFasHf18) - UI + State Management + Storage video by Thad Carnevalli.\n- [GetX Flutter Firebase Auth Example](https://medium.com/@jeffmcmorris/getx-flutter-firebase-auth-example-b383c1dd1de2) - Article by Jeff McMorris.\n- [Flutter State Management with GetX – Complete App](https://www.appwithflutter.com/flutter-state-management-with-getx/) - by App With Flutter.\n- [Flutter Routing with Animation using Get Package](https://www.appwithflutter.com/flutter-routing-using-get-package/) - by App With Flutter.\n- [A minimal example on dartpad](https://dartpad.dev/2b3d0d6f9d4e312c5fdbefc414c1727e?) - by [Roi Peker](https://github.com/roipeker)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 50.3076171875,
          "content": "![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n[![pub package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n[![popularity](https://img.shields.io/pub/popularity/get?logo=dart)](https://pub.dev/packages/get/score)\n[![likes](https://img.shields.io/pub/likes/get?logo=dart)](https://pub.dev/packages/get/score)\n[![pub points](https://img.shields.io/pub/points/sentry?logo=dart)](https://pub.dev/packages/get/score)\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n[![style: effective dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n[![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n[![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n<a href=\"https://github.com/Solido/awesome-flutter\">\n<img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n</a>\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n\n<div align=\"center\">\n\n**Languages:**\n\n  \n[![English](https://img.shields.io/badge/Language-English-blueviolet?style=for-the-badge)](README.md)\n[![Vietnamese](https://img.shields.io/badge/Language-Vietnamese-blueviolet?style=for-the-badge)](README-vi.md)\n[![Indonesian](https://img.shields.io/badge/Language-Indonesian-blueviolet?style=for-the-badge)](README.id-ID.md)\n[![Urdu](https://img.shields.io/badge/Language-Urdu-blueviolet?style=for-the-badge)](README.ur-PK.md)\n[![Chinese](https://img.shields.io/badge/Language-Chinese-blueviolet?style=for-the-badge)](README.zh-cn.md)\n[![Portuguese](https://img.shields.io/badge/Language-Portuguese-blueviolet?style=for-the-badge)](README.pt-br.md)\n[![Spanish](https://img.shields.io/badge/Language-Spanish-blueviolet?style=for-the-badge)](README-es.md)\n[![Russian](https://img.shields.io/badge/Language-Russian-blueviolet?style=for-the-badge)](README.ru.md)\n[![Polish](https://img.shields.io/badge/Language-Polish-blueviolet?style=for-the-badge)](README.pl.md)\n[![Korean](https://img.shields.io/badge/Language-Korean-blueviolet?style=for-the-badge)](README.ko-kr.md)\n[![French](https://img.shields.io/badge/Language-French-blueviolet?style=for-the-badge)](README-fr.md)\n[![Japanese](https://img.shields.io/badge/Language-Japanese-blueviolet?style=for-the-badge)](README.ja-JP.md)\n[![Hindi](https://img.shields.io/badge/Language-Hindi-blueviolet?style=for-the-badge)](README-hi.md)\n[![Bangla](https://img.shields.io/badge/Language-Bangla-blueviolet?style=for-the-badge)](README-bn.md)\n  \n  \n</div>\n\n- [About Get](#about-get)\n- [Installing](#installing)\n- [Counter App with GetX](#counter-app-with-getx)\n- [The Three pillars](#the-three-pillars)\n  - [State management](#state-management)\n    - [Reactive State Manager](#reactive-state-manager)\n    - [More details about state management](#more-details-about-state-management)\n  - [Route management](#route-management)\n    - [More details about route management](#more-details-about-route-management)\n  - [Dependency management](#dependency-management)\n    - [More details about dependency management](#more-details-about-dependency-management)\n- [Utils](#utils)\n  - [Internationalization](#internationalization)\n    - [Translations](#translations)\n      - [Using translations](#using-translations)\n    - [Locales](#locales)\n      - [Change locale](#change-locale)\n      - [System locale](#system-locale)\n  - [Change Theme](#change-theme)\n  - [GetConnect](#getconnect)\n    - [Default configuration](#default-configuration)\n    - [Custom configuration](#custom-configuration)\n  - [GetPage Middleware](#getpage-middleware)\n    - [Priority](#priority)\n    - [Redirect](#redirect)\n    - [onPageCalled](#onpagecalled)\n    - [OnBindingsStart](#onbindingsstart)\n    - [OnPageBuildStart](#onpagebuildstart)\n    - [OnPageBuilt](#onpagebuilt)\n    - [OnPageDispose](#onpagedispose)\n  - [Other Advanced APIs](#other-advanced-apis)\n    - [Optional Global Settings and Manual configurations](#optional-global-settings-and-manual-configurations)\n    - [Local State Widgets](#local-state-widgets)\n      - [ValueBuilder](#valuebuilder)\n      - [ObxValue](#obxvalue)\n  - [Useful tips](#useful-tips)\n    - [GetView](#getview)\n    - [GetResponsiveView](#getresponsiveview)\n      - [How to use it](#how-to-use-it)\n    - [GetWidget](#getwidget)\n    - [GetxService](#getxservice)\n- [Breaking changes from 2.0](#breaking-changes-from-20)\n- [Why Getx?](#why-getx)\n- [Community](#community)\n  - [Community channels](#community-channels)\n  - [How to contribute](#how-to-contribute)\n  - [Articles and videos](#articles-and-videos)\n\n# About Get\n\n- GetX is an extra-light and powerful solution for Flutter. It combines high-performance state management, intelligent dependency injection, and route management quickly and practically.\n\n- GetX has 3 basic principles. This means that these are the priority for all resources in the library: **PRODUCTIVITY, PERFORMANCE AND ORGANIZATION.**\n\n  - **PERFORMANCE:** GetX is focused on performance and minimum consumption of resources. GetX does not use Streams or ChangeNotifier.\n\n  - **PRODUCTIVITY:** GetX uses an easy and pleasant syntax. No matter what you want to do, there is always an easier way with GetX. It will save hours of development and will provide the maximum performance your application can deliver.\n\n    Generally, the developer should be concerned with removing controllers from memory. With GetX this is not necessary because resources are removed from memory when they are not used by default. If you want to keep it in memory, you must explicitly declare \"permanent: true\" in your dependency. That way, in addition to saving time, you are less at risk of having unnecessary dependencies on memory. Dependency loading is also lazy by default.\n\n  - **ORGANIZATION:** GetX allows the total decoupling of the View, presentation logic, business logic, dependency injection, and navigation. You do not need context to navigate between routes, so you are not dependent on the widget tree (visualization) for this. You don't need context to access your controllers/blocs through an inheritedWidget, so you completely decouple your presentation logic and business logic from your visualization layer. You do not need to inject your Controllers/Models/Blocs classes into your widget tree through `MultiProvider`s. For this, GetX uses its own dependency injection feature, decoupling the DI from its view completely.\n\n    With GetX you know where to find each feature of your application, having clean code by default. In addition to making maintenance easy, this makes the sharing of modules something that until then in Flutter was unthinkable, something totally possible.\n    BLoC was a starting point for organizing code in Flutter, it separates business logic from visualization. GetX is a natural evolution of this, not only separating the business logic but the presentation logic. Bonus injection of dependencies and routes are also decoupled, and the data layer is out of it all. You know where everything is, and all of this in an easier way than building a hello world.\n    GetX is the easiest, practical, and scalable way to build high-performance applications with the Flutter SDK. It has a large ecosystem around it that works perfectly together, it's easy for beginners, and it's accurate for experts. It is secure, stable, up-to-date, and offers a huge range of APIs built-in that are not present in the default Flutter SDK.\n\n- GetX is not bloated. It has a multitude of features that allow you to start programming without worrying about anything, but each of these features are in separate containers and are only started after use. If you only use State Management, only State Management will be compiled. If you only use routes, nothing from the state management will be compiled.\n\n- GetX has a huge ecosystem, a large community, a large number of collaborators, and will be maintained as long as the Flutter exists. GetX too is capable of running with the same code on Android, iOS, Web, Mac, Linux, Windows, and on your server.\n  **It is possible to fully reuse your code made on the frontend on your backend with [Get Server](https://github.com/jonataslaw/get_server)**.\n\n**In addition, the entire development process can be completely automated, both on the server and on the front end with [Get CLI](https://github.com/jonataslaw/get_cli)**.\n\n**In addition, to further increase your productivity, we have the\n[extension to VSCode](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets) and the [extension to Android Studio/Intellij](https://plugins.jetbrains.com/plugin/14975-getx-snippets)**\n\n# Installing\n\nAdd Get to your pubspec.yaml file:\n\n```yaml\ndependencies:\n  get:\n```\n\nImport get in files that it will be used:\n\n```dart\nimport 'package:get/get.dart';\n```\n\n# Counter App with GetX\n\nThe \"counter\" project created by default on new project on Flutter has over 100 lines (with comments). To show the power of Get, I will demonstrate how to make a \"counter\" changing the state with each click, switching between pages and sharing the state between screens, all in an organized way, separating the business logic from the view, in ONLY 26 LINES CODE INCLUDING COMMENTS.\n\n- Step 1:\n  Add \"Get\" before your MaterialApp, turning it into GetMaterialApp\n\n```dart\nvoid main() => runApp(GetMaterialApp(home: Home()));\n```\n\n- Note: this does not modify the MaterialApp of the Flutter, GetMaterialApp is not a modified MaterialApp, it is just a pre-configured Widget, which has the default MaterialApp as a child. You can configure this manually, but it is definitely not necessary. GetMaterialApp will create routes, inject them, inject translations, inject everything you need for route navigation. If you use Get only for state management or dependency management, it is not necessary to use GetMaterialApp. GetMaterialApp is necessary for routes, snackbars, internationalization, bottomSheets, dialogs, and high-level apis related to routes and absence of context.\n- Note²: This step is only necessary if you gonna use route management (`Get.to()`, `Get.back()` and so on). If you not gonna use it then it is not necessary to do step 1\n\n- Step 2:\n  Create your business logic class and place all variables, methods and controllers inside it.\n  You can make any variable observable using a simple \".obs\".\n\n```dart\nclass Controller extends GetxController{\n  var count = 0.obs;\n  increment() => count++;\n}\n```\n\n- Step 3:\n  Create your View, use StatelessWidget and save some RAM, with Get you may no longer need to use StatefulWidget.\n\n```dart\nclass Home extends StatelessWidget {\n\n  @override\n  Widget build(context) {\n\n    // Instantiate your class using Get.put() to make it available for all \"child\" routes there.\n    final Controller c = Get.put(Controller());\n\n    return Scaffold(\n      // Use Obx(()=> to update Text() whenever count is changed.\n      appBar: AppBar(title: Obx(() => Text(\"Clicks: ${c.count}\"))),\n\n      // Replace the 8 lines Navigator.push by a simple Get.to(). You don't need context\n      body: Center(child: ElevatedButton(\n              child: Text(\"Go to Other\"), onPressed: () => Get.to(Other()))),\n      floatingActionButton:\n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n  }\n}\n\nclass Other extends StatelessWidget {\n  // You can ask Get to find a Controller that is being used by another page and redirect you to it.\n  final Controller c = Get.find();\n\n  @override\n  Widget build(context){\n     // Access the updated count variable\n     return Scaffold(body: Center(child: Text(\"${c.count}\")));\n  }\n}\n```\n\nResult:\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/counter-app-gif.gif)\n\nThis is a simple project but it already makes clear how powerful Get is. As your project grows, this difference will become more significant.\n\nGet was designed to work with teams, but it makes the job of an individual developer simple.\n\nImprove your deadlines, deliver everything on time without losing performance. Get is not for everyone, but if you identified with that phrase, Get is for you!\n\n# The Three pillars\n\n## State management\n\nGet has two different state managers: the simple state manager (we'll call it GetBuilder) and the reactive state manager (GetX/Obx)\n\n### Reactive State Manager\n\nReactive programming can alienate many people because it is said to be complicated. GetX turns reactive programming into something quite simple:\n\n- You won't need to create StreamControllers.\n- You won't need to create a StreamBuilder for each variable\n- You will not need to create a class for each state.\n- You will not need to create a get for an initial value.\n- You will not need to use code generators\n\nReactive programming with Get is as easy as using setState.\n\nLet's imagine that you have a name variable and want that every time you change it, all widgets that use it are automatically changed.\n\nThis is your count variable:\n\n```dart\nvar name = 'Jonatas Borges';\n```\n\nTo make it observable, you just need to add \".obs\" to the end of it:\n\n```dart\nvar name = 'Jonatas Borges'.obs;\n```\n\nAnd in the UI, when you want to show that value and update the screen whenever the values changes, simply do this:\n\n```dart\nObx(() => Text(\"${controller.name}\"));\n```\n\nThat's all. It's _that_ simple.\n\n### More details about state management\n\n**See an more in-depth explanation of state management [here](./documentation/en_US/state_management.md). There you will see more examples and also the difference between the simple state manager and the reactive state manager**\n\nYou will get a good idea of GetX power.\n\n## Route management\n\nIf you are going to use routes/snackbars/dialogs/bottomsheets without context, GetX is excellent for you too, just see it:\n\nAdd \"Get\" before your MaterialApp, turning it into GetMaterialApp\n\n```dart\nGetMaterialApp( // Before: MaterialApp(\n  home: MyHome(),\n)\n```\n\nNavigate to a new screen:\n\n```dart\n\nGet.to(NextScreen());\n```\n\nNavigate to new screen with name. See more details on named routes [here](./documentation/en_US/route_management.md#navigation-with-named-routes)\n\n```dart\n\nGet.toNamed('/details');\n```\n\nTo close snackbars, dialogs, bottomsheets, or anything you would normally close with Navigator.pop(context);\n\n```dart\nGet.back();\n```\n\nTo go to the next screen and no option to go back to the previous screen (for use in SplashScreens, login screens, etc.)\n\n```dart\nGet.off(NextScreen());\n```\n\nTo go to the next screen and cancel all previous routes (useful in shopping carts, polls, and tests)\n\n```dart\nGet.offAll(NextScreen());\n```\n\nNoticed that you didn't have to use context to do any of these things? That's one of the biggest advantages of using Get route management. With this, you can execute all these methods from within your controller class, without worries.\n\n### More details about route management\n\n**Get works with named routes and also offers lower-level control over your routes! There is in-depth documentation [here](./documentation/en_US/route_management.md)**\n\n## Dependency management\n\nGet has a simple and powerful dependency manager that allows you to retrieve the same class as your Bloc or Controller with just 1 lines of code, no Provider context, no inheritedWidget:\n\n```dart\nController controller = Get.put(Controller()); // Rather Controller controller = Controller();\n```\n\n- Note: If you are using Get's State Manager, pay more attention to the bindings API, which will make it easier to connect your view to your controller.\n\nInstead of instantiating your class within the class you are using, you are instantiating it within the Get instance, which will make it available throughout your App.\nSo you can use your controller (or class Bloc) normally\n\n**Tip:** Get dependency management is decoupled from other parts of the package, so if for example, your app is already using a state manager (any one, it doesn't matter), you don't need to rewrite it all, you can use this dependency injection with no problems at all\n\n```dart\ncontroller.fetchApi();\n```\n\nImagine that you have navigated through numerous routes, and you need data that was left behind in your controller, you would need a state manager combined with the Provider or Get_it, correct? Not with Get. You just need to ask Get to \"find\" for your controller, you don't need any additional dependencies:\n\n```dart\nController controller = Get.find();\n//Yes, it looks like Magic, Get will find your controller, and will deliver it to you. You can have 1 million controllers instantiated, Get will always give you the right controller.\n```\n\nAnd then you will be able to recover your controller data that was obtained back there:\n\n```dart\nText(controller.textFromApi);\n```\n\n### More details about dependency management\n\n**See a more in-depth explanation of dependency management [here](./documentation/en_US/dependency_management.md)**\n\n# Utils\n\n## Internationalization\n\n### Translations\n\nTranslations are kept as a simple key-value dictionary map.\nTo add custom translations, create a class and extend `Translations`.\n\n```dart\nimport 'package:get/get.dart';\n\nclass Messages extends Translations {\n  @override\n  Map<String, Map<String, String>> get keys => {\n        'en_US': {\n          'hello': 'Hello World',\n        },\n        'de_DE': {\n          'hello': 'Hallo Welt',\n        }\n      };\n}\n```\n\n#### Using translations\n\nJust append `.tr` to the specified key and it will be translated, using the current value of `Get.locale` and `Get.fallbackLocale`.\n\n```dart\nText('title'.tr);\n```\n\n#### Using translation with singular and plural\n\n```dart\nvar products = [];\nText('singularKey'.trPlural('pluralKey', products.length, Args));\n```\n\n#### Using translation with parameters\n\n```dart\nimport 'package:get/get.dart';\n\n\nMap<String, Map<String, String>> get keys => {\n    'en_US': {\n        'logged_in': 'logged in as @name with email @email',\n    },\n    'es_ES': {\n       'logged_in': 'iniciado sesión como @name con e-mail @email',\n    }\n};\n\nText('logged_in'.trParams({\n  'name': 'Jhon',\n  'email': 'jhon@example.com'\n  }));\n```\n\n### Locales\n\nPass parameters to `GetMaterialApp` to define the locale and translations.\n\n```dart\nreturn GetMaterialApp(\n    translations: Messages(), // your translations\n    locale: Locale('en', 'US'), // translations will be displayed in that locale\n    fallbackLocale: Locale('en', 'UK'), // specify the fallback locale in case an invalid locale is selected.\n);\n```\n\n#### Change locale\n\nCall `Get.updateLocale(locale)` to update the locale. Translations then automatically use the new locale.\n\n```dart\nvar locale = Locale('en', 'US');\nGet.updateLocale(locale);\n```\n\n#### System locale\n\nTo read the system locale, you could use `Get.deviceLocale`.\n\n```dart\nreturn GetMaterialApp(\n    locale: Get.deviceLocale,\n);\n```\n\n## Change Theme\n\nPlease do not use any higher level widget than `GetMaterialApp` in order to update it. This can trigger duplicate keys. A lot of people are used to the prehistoric approach of creating a \"ThemeProvider\" widget just to change the theme of your app, and this is definitely NOT necessary with **GetX™**.\n\nYou can create your custom theme and simply add it within `Get.changeTheme` without any boilerplate for that:\n\n```dart\nGet.changeTheme(ThemeData.light());\n```\n\nIf you want to create something like a button that changes the Theme in `onTap`, you can combine two **GetX™** APIs for that:\n\n- The api that checks if the dark `Theme` is being used.\n- And the `Theme` Change API, you can just put this within an `onPressed`:\n\n```dart\nGet.changeTheme(Get.isDarkMode? ThemeData.light(): ThemeData.dark());\n```\n\nWhen `.darkmode` is activated, it will switch to the _light theme_, and when the _light theme_ becomes active, it will change to _dark theme_.\n\n## GetConnect\n\nGetConnect is an easy way to communicate from your back to your front with http or websockets\n\n### Default configuration\n\nYou can simply extend GetConnect and use the GET/POST/PUT/DELETE/SOCKET methods to communicate with your Rest API or websockets.\n\n```dart\nclass UserProvider extends GetConnect {\n  // Get request\n  Future<Response> getUser(int id) => get('http://youapi/users/$id');\n  // Post request\n  Future<Response> postUser(Map data) => post('http://youapi/users', body: data);\n  // Post request with File\n  Future<Response<CasesModel>> postCases(List<int> image) {\n    final form = FormData({\n      'file': MultipartFile(image, filename: 'avatar.png'),\n      'otherFile': MultipartFile(image, filename: 'cover.png'),\n    });\n    return post('http://youapi/users/upload', form);\n  }\n\n  GetSocket userMessages() {\n    return socket('https://yourapi/users/socket');\n  }\n}\n```\n\n### Custom configuration\n\nGetConnect is highly customizable You can define base Url, as answer modifiers, as Requests modifiers, define an authenticator, and even the number of attempts in which it will try to authenticate itself, in addition to giving the possibility to define a standard decoder that will transform all your requests into your Models without any additional configuration.\n\n```dart\nclass HomeProvider extends GetConnect {\n  @override\n  void onInit() {\n    // All request will pass to jsonEncode so CasesModel.fromJson()\n    httpClient.defaultDecoder = CasesModel.fromJson;\n    httpClient.baseUrl = 'https://api.covid19api.com';\n    // baseUrl = 'https://api.covid19api.com'; // It define baseUrl to\n    // Http and websockets if used with no [httpClient] instance\n\n    // It's will attach 'apikey' property on header from all requests\n    httpClient.addRequestModifier((request) {\n      request.headers['apikey'] = '12345678';\n      return request;\n    });\n\n    // Even if the server sends data from the country \"Brazil\",\n    // it will never be displayed to users, because you remove\n    // that data from the response, even before the response is delivered\n    httpClient.addResponseModifier<CasesModel>((request, response) {\n      CasesModel model = response.body;\n      if (model.countries.contains('Brazil')) {\n        model.countries.remove('Brazilll');\n      }\n    });\n\n    httpClient.addAuthenticator((request) async {\n      final response = await get(\"http://yourapi/token\");\n      final token = response.body['token'];\n      // Set the header\n      request.headers['Authorization'] = \"$token\";\n      return request;\n    });\n\n    //Autenticator will be called 3 times if HttpStatus is\n    //HttpStatus.unauthorized\n    httpClient.maxAuthRetries = 3;\n  }\n\n  @override\n  Future<Response<CasesModel>> getCases(String path) => get(path);\n}\n```\n\n## GetPage Middleware\n\nThe GetPage has now new property that takes a list of GetMiddleWare and run them in the specific order.\n\n**Note**: When GetPage has a Middlewares, all the children of this page will have the same middlewares automatically.\n\n### Priority\n\nThe Order of the Middlewares to run can be set by the priority in the GetMiddleware.\n\n```dart\nfinal middlewares = [\n  GetMiddleware(priority: 2),\n  GetMiddleware(priority: 5),\n  GetMiddleware(priority: 4),\n  GetMiddleware(priority: -8),\n];\n```\n\nthose middlewares will be run in this order **-8 => 2 => 4 => 5**\n\n### Redirect\n\nThis function will be called when the page of the called route is being searched for. It takes RouteSettings as a result to redirect to. Or give it null and there will be no redirecting.\n\n```dart\nRouteSettings redirect(String route) {\n  final authService = Get.find<AuthService>();\n  return authService.authed.value ? null : RouteSettings(name: '/login')\n}\n```\n\n### onPageCalled\n\nThis function will be called when this Page is called before anything created\nyou can use it to change something about the page or give it new page\n\n```dart\nGetPage onPageCalled(GetPage page) {\n  final authService = Get.find<AuthService>();\n  return page.copyWith(title: 'Welcome ${authService.UserName}');\n}\n```\n\n### OnBindingsStart\n\nThis function will be called right before the Bindings are initialize.\nHere you can change Bindings for this page.\n\n```dart\nList<Bindings> onBindingsStart(List<Bindings> bindings) {\n  final authService = Get.find<AuthService>();\n  if (authService.isAdmin) {\n    bindings.add(AdminBinding());\n  }\n  return bindings;\n}\n```\n\n### OnPageBuildStart\n\nThis function will be called right after the Bindings are initialize.\nHere you can do something after that you created the bindings and before creating the page widget.\n\n```dart\nGetPageBuilder onPageBuildStart(GetPageBuilder page) {\n  print('bindings are ready');\n  return page;\n}\n```\n\n### OnPageBuilt\n\nThis function will be called right after the GetPage.page function is called and will give you the result of the function. and take the widget that will be showed.\n\n### OnPageDispose\n\nThis function will be called right after disposing all the related objects (Controllers, views, ...) of the page.\n\n## Other Advanced APIs\n\n```dart\n// give the current args from currentScreen\nGet.arguments\n\n// give name of previous route\nGet.previousRoute\n\n// give the raw route to access for example, rawRoute.isFirst()\nGet.rawRoute\n\n// give access to Routing API from GetObserver\nGet.routing\n\n// check if snackbar is open\nGet.isSnackbarOpen\n\n// check if dialog is open\nGet.isDialogOpen\n\n// check if bottomsheet is open\nGet.isBottomSheetOpen\n\n// remove one route.\nGet.removeRoute()\n\n// back repeatedly until the predicate returns true.\nGet.until()\n\n// go to next route and remove all the previous routes until the predicate returns true.\nGet.offUntil()\n\n// go to next named route and remove all the previous routes until the predicate returns true.\nGet.offNamedUntil()\n\n//Check in what platform the app is running\nGetPlatform.isAndroid\nGetPlatform.isIOS\nGetPlatform.isMacOS\nGetPlatform.isWindows\nGetPlatform.isLinux\nGetPlatform.isFuchsia\n\n//Check the device type\nGetPlatform.isMobile\nGetPlatform.isDesktop\n//All platforms are supported independently in web!\n//You can tell if you are running inside a browser\n//on Windows, iOS, OSX, Android, etc.\nGetPlatform.isWeb\n\n\n// Equivalent to : MediaQuery.of(context).size.height,\n// but immutable.\nGet.height\nGet.width\n\n// Gives the current context of the Navigator.\nGet.context\n\n// Gives the context of the snackbar/dialog/bottomsheet in the foreground, anywhere in your code.\nGet.contextOverlay\n\n// Note: the following methods are extensions on context. Since you\n// have access to context in any place of your UI, you can use it anywhere in the UI code\n\n// If you need a changeable height/width (like Desktop or browser windows that can be scaled) you will need to use context.\ncontext.width\ncontext.height\n\n// Gives you the power to define half the screen, a third of it and so on.\n// Useful for responsive applications.\n// param dividedBy (double) optional - default: 1\n// param reducedBy (double) optional - default: 0\ncontext.heightTransformer()\ncontext.widthTransformer()\n\n/// Similar to MediaQuery.sizeOf(context);\ncontext.mediaQuerySize()\n\n/// Similar to MediaQuery.paddingOf(context);\ncontext.mediaQueryPadding()\n\n/// Similar to MediaQuery.viewPaddingOf(context);\ncontext.mediaQueryViewPadding()\n\n/// Similar to MediaQuery.viewInsetsOf(context);\ncontext.mediaQueryViewInsets()\n\n/// Similar to MediaQuery.orientationOf(context);\ncontext.orientation()\n\n/// Check if device is on landscape mode\ncontext.isLandscape()\n\n/// Check if device is on portrait mode\ncontext.isPortrait()\n\n/// Similar to MediaQuery.devicePixelRatioOf(context);\ncontext.devicePixelRatio()\n\n/// Similar to MediaQuery.textScaleFactorOf(context);\ncontext.textScaleFactor()\n\n/// Get the shortestSide from screen\ncontext.mediaQueryShortestSide()\n\n/// True if width be larger than 800\ncontext.showNavbar()\n\n/// True if the shortestSide is smaller than 600p\ncontext.isPhone()\n\n/// True if the shortestSide is largest than 600p\ncontext.isSmallTablet()\n\n/// True if the shortestSide is largest than 720p\ncontext.isLargeTablet()\n\n/// True if the current device is Tablet\ncontext.isTablet()\n\n/// Returns a value<T> according to the screen size\n/// can give value for:\n/// watch: if the shortestSide is smaller than 300\n/// mobile: if the shortestSide is smaller than 600\n/// tablet: if the shortestSide is smaller than 1200\n/// desktop: if width is largest than 1200\ncontext.responsiveValue<T>()\n```\n\n### Optional Global Settings and Manual configurations\n\nGetMaterialApp configures everything for you, but if you want to configure Get manually.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver()],\n);\n```\n\nYou will also be able to use your own Middleware within `GetObserver`, this will not influence anything.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [\n    GetObserver(MiddleWare.observer) // Here\n  ],\n);\n```\n\nYou can create _Global Settings_ for `Get`. Just add `Get.config` to your code before pushing any route.\nOr do it directly in your `GetMaterialApp`\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  defaultTransition: Transition.fade,\n  opaqueRoute: Get.isOpaqueRouteDefault,\n  popGesture: Get.isPopGestureEnable,\n  transitionDuration: Get.defaultDurationTransition,\n  defaultGlobalState: Get.defaultGlobalState,\n);\n\nGet.config(\n  enableLog = true,\n  defaultPopGesture = true,\n  defaultTransition = Transitions.cupertino\n)\n```\n\nYou can optionally redirect all the logging messages from `Get`.\nIf you want to use your own, favourite logging package,\nand want to capture the logs there:\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  logWriterCallback: localLogWriter,\n);\n\nvoid localLogWriter(String text, {bool isError = false}) {\n  // pass the message to your favourite logging package here\n  // please note that even if enableLog: false log messages will be pushed in this callback\n  // you get check the flag if you want through GetConfig.isLogEnable\n}\n\n```\n\n### Local State Widgets\n\nThese Widgets allows you to manage a single value, and keep the state ephemeral and locally.\nWe have flavours for Reactive and Simple.\nFor instance, you might use them to toggle obscureText in a `TextField`, maybe create a custom\nExpandable Panel, or maybe modify the current index in `BottomNavigationBar` while changing the content\nof the body in a `Scaffold`.\n\n#### ValueBuilder\n\nA simplification of `StatefulWidget` that works with a `.setState` callback that takes the updated value.\n\n```dart\nValueBuilder<bool>(\n  initialValue: false,\n  builder: (value, updateFn) => Switch(\n    value: value,\n    onChanged: updateFn, // same signature! you could use ( newValue ) => updateFn( newValue )\n  ),\n  // if you need to call something outside the builder method.\n  onUpdate: (value) => print(\"Value updated: $value\"),\n  onDispose: () => print(\"Widget unmounted\"),\n),\n```\n\n#### ObxValue\n\nSimilar to [`ValueBuilder`](#valuebuilder), but this is the Reactive version, you pass a Rx instance (remember the magical .obs?) and\nupdates automatically... isn't it awesome?\n\n```dart\nObxValue((data) => Switch(\n        value: data.value,\n        onChanged: data, // Rx has a _callable_ function! You could use (flag) => data.value = flag,\n    ),\n    false.obs,\n),\n```\n\n## Useful tips\n\n`.obs`ervables (also known as _Rx_ Types) have a wide variety of internal methods and operators.\n\n> Is very common to _believe_ that a property with `.obs` **IS** the actual value... but make no mistake!\n> We avoid the Type declaration of the variable, because Dart's compiler is smart enough, and the code\n> looks cleaner, but:\n\n```dart\nvar message = 'Hello world'.obs;\nprint( 'Message \"$message\" has Type ${message.runtimeType}');\n```\n\nEven if `message` _prints_ the actual String value, the Type is **RxString**!\n\nSo, you can't do `message.substring( 0, 4 )`.\nYou have to access the real `value` inside the _observable_:\nThe most \"used way\" is `.value`, but, did you know that you can also use...\n\n```dart\nfinal name = 'GetX'.obs;\n// only \"updates\" the stream, if the value is different from the current one.\nname.value = 'Hey';\n\n// All Rx properties are \"callable\" and returns the new value.\n// but this approach does not accepts `null`, the UI will not rebuild.\nname('Hello');\n\n// is like a getter, prints 'Hello'.\nname() ;\n\n/// numbers:\n\nfinal count = 0.obs;\n\n// You can use all non mutable operations from num primitives!\ncount + 1;\n\n// Watch out! this is only valid if `count` is not final, but var\ncount += 1;\n\n// You can also compare against values:\ncount > 2;\n\n/// booleans:\n\nfinal flag = false.obs;\n\n// switches the value between true/false\nflag.toggle();\n\n\n/// all types:\n\n// Sets the `value` to null.\nflag.nil();\n\n// All toString(), toJson() operations are passed down to the `value`\nprint( count ); // calls `toString()` inside  for RxInt\n\nfinal abc = [0,1,2].obs;\n// Converts the value to a json Array, prints RxList\n// Json is supported by all Rx types!\nprint('json: ${jsonEncode(abc)}, type: ${abc.runtimeType}');\n\n// RxMap, RxList and RxSet are special Rx types, that extends their native types.\n// but you can work with a List as a regular list, although is reactive!\nabc.add(12); // pushes 12 to the list, and UPDATES the stream.\nabc[3]; // like Lists, reads the index 3.\n\n\n// equality works with the Rx and the value, but hashCode is always taken from the value\nfinal number = 12.obs;\nprint( number == 12 ); // prints > true\n\n/// Custom Rx Models:\n\n// toJson(), toString() are deferred to the child, so you can implement override on them, and print() the observable directly.\n\nclass User {\n    String name, last;\n    int age;\n    User({this.name, this.last, this.age});\n\n    @override\n    String toString() => '$name $last, $age years old';\n}\n\nfinal user = User(name: 'John', last: 'Doe', age: 33).obs;\n\n// `user` is \"reactive\", but the properties inside ARE NOT!\n// So, if we change some variable inside of it...\nuser.value.name = 'Roi';\n// The widget will not rebuild!,\n// `Rx` don't have any clue when you change something inside user.\n// So, for custom classes, we need to manually \"notify\" the change.\nuser.refresh();\n\n// or we can use the `update()` method!\nuser.update((value){\n  value.name='Roi';\n});\n\nprint( user );\n```\n## StateMixin\n\nAnother way to handle your `UI` state is use the `StateMixin<T>` .\nTo implement it, use the `with` to add the `StateMixin<T>`\nto your controller which allows a T model.\n\n``` dart\nclass Controller extends GetController with StateMixin<User>{}\n```\n\nThe `change()` method change the State whenever we want.\nJust pass the data and the status in this way:\n\n```dart\nchange(data, status: RxStatus.success());\n```\n\nRxStatus allow these status:\n\n``` dart\nRxStatus.loading();\nRxStatus.success();\nRxStatus.empty();\nRxStatus.error('message');\n```\n\nTo represent it in the UI, use:\n\n```dart\nclass OtherClass extends GetView<Controller> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n\n      body: controller.obx(\n        (state)=>Text(state.name),\n        \n        // here you can put your custom loading indicator, but\n        // by default would be Center(child:CircularProgressIndicator())\n        onLoading: CustomLoadingIndicator(),\n        onEmpty: Text('No data found'),\n\n        // here also you can set your own error widget, but by\n        // default will be an Center(child:Text(error))\n        onError: (error)=>Text(error),\n      ),\n    );\n}\n```\n\n#### GetView\n\nI love this Widget, is so simple, yet, so useful!\n\nIs a `const Stateless` Widget that has a getter `controller` for a registered `Controller`, that's all.\n\n```dart\n class AwesomeController extends GetController {\n   final String title = 'My Awesome View';\n }\n\n  // ALWAYS remember to pass the `Type` you used to register your controller!\n class AwesomeView extends GetView<AwesomeController> {\n   @override\n   Widget build(BuildContext context) {\n     return Container(\n       padding: EdgeInsets.all(20),\n       child: Text(controller.title), // just call `controller.something`\n     );\n   }\n }\n```\n\n#### GetResponsiveView\n\nExtend this widget to build responsive view.\nthis widget contains the `screen` property that have all\ninformation about the screen size and type.\n\n##### How to use it\n\nYou have two options to build it.\n\n- with `builder` method you return the widget to build.\n- with methods `desktop`, `tablet`,`phone`, `watch`. the specific\n  method will be built when the screen type matches the method\n  when the screen is [ScreenType.Tablet] the `tablet` method\n  will be exuded and so on.\n  **Note:** If you use this method please set the property `alwaysUseBuilder` to `false`\n\nWith `settings` property you can set the width limit for the screen types.\n\n![example](https://github.com/SchabanBo/get_page_example/blob/master/docs/Example.gif?raw=true)\nCode to this screen\n[code](https://github.com/SchabanBo/get_page_example/blob/master/lib/pages/responsive_example/responsive_view.dart)\n\n#### GetWidget\n\nMost people have no idea about this Widget, or totally confuse the usage of it.\nThe use case is very rare, but very specific: It `caches` a Controller.\nBecause of the _cache_, can't be a `const Stateless`.\n\n> So, when do you need to \"cache\" a Controller?\n\nIf you use, another \"not so common\" feature of **GetX**: `Get.create()`.\n\n`Get.create(()=>Controller())` will generate a new `Controller` each time you call\n`Get.find<Controller>()`,\n\nThat's where `GetWidget` shines... as you can use it, for example,\nto keep a list of Todo items. So, if the widget gets \"rebuilt\", it will keep the same controller instance.\n\n#### GetxService\n\nThis class is like a `GetxController`, it shares the same lifecycle ( `onInit()`, `onReady()`, `onClose()`).\nBut has no \"logic\" inside of it. It just notifies **GetX** Dependency Injection system, that this subclass\n**can not** be removed from memory.\n\nSo is super useful to keep your \"Services\" always reachable and active with `Get.find()`. Like:\n`ApiService`, `StorageService`, `CacheService`.\n\n```dart\nFuture<void> main() async {\n  await initServices(); /// AWAIT SERVICES INITIALIZATION.\n  runApp(SomeApp());\n}\n\n/// Is a smart move to make your Services intiialize before you run the Flutter app.\n/// as you can control the execution flow (maybe you need to load some Theme configuration,\n/// apiKey, language defined by the User... so load SettingService before running ApiService.\n/// so GetMaterialApp() doesnt have to rebuild, and takes the values directly.\nvoid initServices() async {\n  print('starting services ...');\n  /// Here is where you put get_storage, hive, shared_pref initialization.\n  /// or moor connection, or whatever that's async.\n  await Get.putAsync(() => DbService().init());\n  await Get.putAsync(SettingsService()).init();\n  print('All services started...');\n}\n\nclass DbService extends GetxService {\n  Future<DbService> init() async {\n    print('$runtimeType delays 2 sec');\n    await 2.delay();\n    print('$runtimeType ready!');\n    return this;\n  }\n}\n\nclass SettingsService extends GetxService {\n  void init() async {\n    print('$runtimeType delays 1 sec');\n    await 1.delay();\n    print('$runtimeType ready!');\n  }\n}\n\n```\n\nThe only way to actually delete a `GetxService`, is with `Get.reset()` which is like a\n\"Hot Reboot\" of your app. So remember, if you need absolute persistence of a class instance during the\nlifetime of your app, use `GetxService`.\n\n\n### Tests\n\nYou can test your controllers like any other class, including their lifecycles:\n\n```dart\nclass Controller extends GetxController {\n  @override\n  void onInit() {\n    super.onInit();\n    //Change value to name2\n    name.value = 'name2';\n  }\n\n  @override\n  void onClose() {\n    name.value = '';\n    super.onClose();\n  }\n\n  final name = 'name1'.obs;\n\n  void changeName() => name.value = 'name3';\n}\n\nvoid main() {\n  test('''\nTest the state of the reactive variable \"name\" across all of its lifecycles''',\n      () {\n    /// You can test the controller without the lifecycle,\n    /// but it's not recommended unless you're not using\n    ///  GetX dependency injection\n    final controller = Controller();\n    expect(controller.name.value, 'name1');\n\n    /// If you are using it, you can test everything,\n    /// including the state of the application after each lifecycle.\n    Get.put(controller); // onInit was called\n    expect(controller.name.value, 'name2');\n\n    /// Test your functions\n    controller.changeName();\n    expect(controller.name.value, 'name3');\n\n    /// onClose was called\n    Get.delete<Controller>();\n\n    expect(controller.name.value, '');\n  });\n}\n```\n\n#### Tips\n\n##### Mockito or mocktail\nIf you need to mock your GetxController/GetxService, you should extend GetxController, and mixin it with Mock, that way\n\n```dart\nclass NotificationServiceMock extends GetxService with Mock implements NotificationService {}\n```\n\n##### Using Get.reset()\nIf you are testing widgets, or test groups, use Get.reset at the end of your test or in tearDown to reset all settings from your previous test.\n\n##### Get.testMode \nif you are using your navigation in your controllers, use `Get.testMode = true` at the beginning of your main.\n\n\n# Breaking changes from 2.0\n\n1- Rx types:\n\n| Before  | After      |\n| ------- | ---------- |\n| StringX | `RxString` |\n| IntX    | `RxInt`    |\n| MapX    | `RxMap`    |\n| ListX   | `RxList`   |\n| NumX    | `RxNum`    |\n| DoubleX | `RxDouble` |\n\nRxController and GetBuilder now have merged, you no longer need to memorize which controller you want to use, just use GetxController, it will work for simple state management and for reactive as well.\n\n2- NamedRoutes\nBefore:\n\n```dart\nGetMaterialApp(\n  namedRoutes: {\n    '/': GetRoute(page: Home()),\n  }\n)\n```\n\nNow:\n\n```dart\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page: () => Home()),\n  ]\n)\n```\n\nWhy this change?\nOften, it may be necessary to decide which page will be displayed from a parameter, or a login token, the previous approach was inflexible, as it did not allow this.\nInserting the page into a function has significantly reduced the RAM consumption, since the routes will not be allocated in memory since the app was started, and it also allowed to do this type of approach:\n\n```dart\n\nGetStorage box = GetStorage();\n\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page:(){\n      return box.hasData('token') ? Home() : Login();\n    })\n  ]\n)\n```\n\n# Why Getx?\n\n1- Many times after a Flutter update, many of your packages will break. Sometimes compilation errors happen, errors often appear that there are still no answers about, and the developer needs to know where the error came from, track the error, only then try to open an issue in the corresponding repository, and see its problem solved. Get centralizes the main resources for development (State, dependency and route management), allowing you to add a single package to your pubspec, and start working. After a Flutter update, the only thing you need to do is update the Get dependency, and get to work. Get also resolves compatibility issues. How many times a version of a package is not compatible with the version of another, because one uses a dependency in one version, and the other in another version? This is also not a concern using Get, as everything is in the same package and is fully compatible.\n\n2- Flutter is easy, Flutter is incredible, but Flutter still has some boilerplate that may be unwanted for most developers, such as `Navigator.of(context).push (context, builder [...]`. Get simplifies development. Instead of writing 8 lines of code to just call a route, you can just do it: `Get.to(Home())` and you're done, you'll go to the next page. Dynamic web urls are a really painful thing to do with Flutter currently, and that with GetX is stupidly simple. Managing states in Flutter, and managing dependencies is also something that generates a lot of discussion, as there are hundreds of patterns in the pub. But there is nothing as easy as adding a \".obs\" at the end of your variable, and place your widget inside an Obx, and that's it, all updates to that variable will be automatically updated on the screen.\n\n3- Ease without worrying about performance. Flutter's performance is already amazing, but imagine that you use a state manager, and a locator to distribute your blocs/stores/controllers/ etc. classes. You will have to manually call the exclusion of that dependency when you don't need it. But have you ever thought of simply using your controller, and when it was no longer being used by anyone, it would simply be deleted from memory? That's what GetX does. With SmartManagement, everything that is not being used is deleted from memory, and you shouldn't have to worry about anything but programming. You will be assured that you are consuming the minimum necessary resources, without even having created a logic for this.\n\n4- Actual decoupling. You may have heard the concept \"separate the view from the business logic\". This is not a peculiarity of BLoC, MVC, MVVM, and any other standard on the market has this concept. However, this concept can often be mitigated in Flutter due to the use of context.\nIf you need context to find an InheritedWidget, you need it in the view, or pass the context by parameter. I particularly find this solution very ugly, and to work in teams we will always have a dependence on View's business logic. Getx is unorthodox with the standard approach, and while it does not completely ban the use of StatefulWidgets, InitState, etc., it always has a similar approach that can be cleaner. Controllers have life cycles, and when you need to make an APIREST request for example, you don't depend on anything in the view. You can use onInit to initiate the http call, and when the data arrives, the variables will be populated. As GetX is fully reactive (really, and works under streams), once the items are filled, all widgets that use that variable will be automatically updated in the view. This allows people with UI expertise to work only with widgets, and not have to send anything to business logic other than user events (like clicking a button), while people working with business logic will be free to create and test the business logic separately.\n\nThis library will always be updated and implementing new features. Feel free to offer PRs and contribute to them.\n\n# Community\n\n## Community channels\n\nGetX has a highly active and helpful community. If you have questions, or would like any assistance regarding the use of this framework, please join our community channels, your question will be answered more quickly, and it will be the most suitable place. This repository is exclusive for opening issues, and requesting resources, but feel free to be part of GetX Community.\n\n| **Slack**                                                                                                                   | **Discord**                                                                                                                 | **Telegram**                                                                                                          |\n| :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |\n| [![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx) | [![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N) | [![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g) |\n\n## How to contribute\n\n_Want to contribute to the project? We will be proud to highlight you as one of our collaborators. Here are some points where you can contribute and make Get (and Flutter) even better._\n\n- Helping to translate the readme into other languages.\n- Adding documentation to the readme (a lot of Get's functions haven't been documented yet).\n- Write articles or make videos teaching how to use Get (they will be inserted in the Readme and in the future in our Wiki).\n- Offering PRs for code/tests.\n- Including new functions.\n\nAny contribution is welcome!\n\n## Articles and videos\n\n- [Flutter Getx EcoSystem package for arabic people](https://www.youtube.com/playlist?list=PLV1fXIAyjeuZ6M8m56zajMUwu4uE3-SL0) - Tutorial by [Pesa Coder](https://github.com/UsamaElgendy).\n- [Dynamic Themes in 3 lines using GetX™](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Tutorial by [Rod Brown](https://github.com/RodBr).\n- [Complete GetX™ Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI) - Route management video by Amateur Coder.\n- [Complete GetX State Management](https://www.youtube.com/watch?v=CNpXbeI_slw) - State management video by Amateur Coder.\n- [GetX™ Other Features](https://youtu.be/ttQtlX_Q0eU) - Utils, storage, bindings and other features video by Amateur Coder.\n- [Firestore User with GetX | Todo App](https://www.youtube.com/watch?v=BiV0DcXgk58) - Video by Amateur Coder.\n- [Firebase Auth with GetX | Todo App](https://www.youtube.com/watch?v=-H-T_BSgfOE) - Video by Amateur Coder.\n- [The Flutter GetX™ Ecosystem ~ State Management](https://medium.com/flutter-community/the-flutter-getx-ecosystem-state-management-881c7235511d) - State management by [Aachman Garg](https://github.com/imaachman).\n- [The Flutter GetX™ Ecosystem ~ Dependency Injection](https://medium.com/flutter-community/the-flutter-getx-ecosystem-dependency-injection-8e763d0ec6b9) - Dependency Injection by [Aachman Garg](https://github.com/imaachman).\n- [GetX, the all-in-one Flutter package](https://www.youtube.com/watch?v=IYQgtu9TM74) - A brief tutorial covering State Management and Navigation by Thad Carnevalli.\n- [Build a To-do List App from scratch using Flutter and GetX](https://www.youtube.com/watch?v=EcnqFasHf18) - UI + State Management + Storage video by Thad Carnevalli.\n- [GetX Flutter Firebase Auth Example](https://medium.com/@jeffmcmorris/getx-flutter-firebase-auth-example-b383c1dd1de2) - Article by Jeff McMorris.\n- [Flutter State Management with GetX – Complete App](https://www.appwithflutter.com/flutter-state-management-with-getx/) - by App With Flutter.\n- [Flutter Routing with Animation using Get Package](https://www.appwithflutter.com/flutter-routing-using-get-package/) - by App With Flutter.\n- [A minimal example on dartpad](https://dartpad.dev/2b3d0d6f9d4e312c5fdbefc414c1727e?) - by [Roi Peker](https://github.com/roipeker)\n- [GetConnect: The best way to perform API operations in Flutter with Get.](https://absyz.com/getconnect-the-best-way-to-perform-api-operations-in-flutter-with-getx/) - by [MD Sarfaraj](https://github.com/socialmad)\n- [How To Create an App with GetX Architect in Flutter with Get CLI](https://www.youtube.com/watch?v=7mb4qBA7kTk&t=1380s) - by [MD Sarfaraj](https://github.com/socialmad)\n"
        },
        {
          "name": "README.pl.md",
          "type": "blob",
          "size": 21.3896484375,
          "content": "![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n*Languages: [English](README.md), [Wietnamski](README-vi.md), [Indonezyjski](README.id-ID.md), [Urdu](README.ur-PK.md), [Język chiński](README.zh-cn.md), [Brazilian Portuguese](README.pt-br.md), [Spanish](README-es.md), [Russian](README.ru.md),  Polish (Jesteś tu), [Koreański](README.ko-kr.md), [French](README-fr.md)*\n\n[![pub package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n[![popularity](https://badges.bar/get/popularity)](https://pub.dev/packages/sentry/score)\n[![likes](https://badges.bar/get/likes)](https://pub.dev/packages/get/score)\n[![pub points](https://badges.bar/get/pub%20points)](https://pub.dev/packages/get/score)\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n[![style: effective dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n[![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n[![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n<a href=\"https://github.com/Solido/awesome-flutter\">\n   <img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n</a>\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n- [Kanały komunikacji i wsparcia:](#kanały-komunikacji-i-wsparcia)\n- [Wprowadzenie](#wprowadzenie)\n- [Instalacja](#instalacja)\n- [Counter App z GetX](#counter-app-z-getx)\n- [Trzy filary](#trzy-filary)\n  - [Menadżer stanu](#menadżer-stanu)\n    - [Reaktywny menadżer stanu](#reaktywny-menadżer-stanu)\n    - [Bardziej szczegółowo o menadżerze stanu](#bardziej-szczegółowo-o-menadżerze-stanu)\n    - [Video tłumaczące użycie menadżera stanu](#video-tłumaczące-użycie-menadżera-stanu)\n  - [Zarządzanie routami](#zarządzanie-routami)\n    - [Więcej o routach](#więcej-o-routach)\n    - [Video tłumaczące użycie](#video-tłumaczące-użycie)\n  - [Zarządzanie dependencies](#zarządzanie-dependencies)\n    - [Bardziej szczegółowo o menadżerze dependencies](#bardziej-szczegółowo-o-menadżerze-dependencies)\n- [Jak włożyć coś od siebie](#jak-włożyć-coś-od-siebie)\n- [Narzędzia](#narzędzia)\n  - [Zmiana motywu](#zmiana-motywu)\n  - [Inne zaawansowane API](#inne-zaawansowane-api)\n    - [Opcjonalne globalne ustawienia i manualna konfiguracja](#opcjonalne-globalne-ustawienia-i-manualna-konfiguracja)\n  - [Video tłumaczące inne funkcjonalności GetX](#video-tłumaczące-inne-funkcjonalności-getx)\n- [Zmiany od 2.0](#zmiany-od-20)\n\n\n# Kanały komunikacji i wsparcia:\n\n[**Slack (English)**](https://communityinviter.com/apps/getxworkspace/getx)\n\n[**Discord (English and Portuguese)**](https://discord.com/invite/9Hpt99N)\n\n[**Telegram (Portuguese)**](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n\n# Wprowadzenie\n- GetX jest bardzo lekką, a zarazem potężną biblioteką do Flattera. Łączy wysoką wydajność menadżera stanu, inteligętne dodawanie dependencies i zarządzanie routami w szybki i praktyczny sposób.\n- GetX nie jest dla wszystkich, skupia się na jak najmniejszej konsumpcji zasobów (wydajności) ([zobacz benchmarki](https://github.com/jonataslaw/benchmarks)), używaniu łatwej skłani (produktywności) i daniu możliwości pełnego rozbicia View na z logiki biznesowej (organizacja).\n- GetX da Ci supermoce i zwiększy produktywność w tworzeniu projektu. Oszczędzi godziny zarówno początkującym jak i ekspertom.\n-  Nawiguj bez podawania `context`, używaj open `dialogs`, `snackbarów` oraz `bottomsheetów` z każdego miejsca w kodzie. Zarządzaj stanami i dodawaj dependencies w prosty i praktyczny sposób!\n- Get jest bezpieczny, stabilny i aktualny. Oprócz tego oferuje szeroki zakres API, które nie są zawarte w standardowym frameworku.\n- GetX nie jest przytłaczający. Ma wiele funkcjonalności pozwalajacych na rozpoczęcie programowania bez martwienia się zupełnie nic. Wszystkie funkcjonalności są w osobnych kontenerach, które dodawane są dopiero po ich użyciu. Jeśli tylko używasz menadżera stanu, tylko on będzie kompilowany. Jeśli używasz routów, lecz nic z menadżera stanu to nie będzie on kompilowany. Możesz skompilować repozytorium benchmark i zobaczysz że używa tylko menadżera stanu. Aplikacje używajace Get są mniejsze niz inne, ponieważ wszystkie rozwiązania GetX są projektowane z myślą o lekkości i wydajności. Jest to też zasługa Flutterowego AOT, które jest niesamowite i eliminuje nieużywane zasoby jak żaden inny framework.\n\n**GetX zwiększa twoja produktywność, lecz możesz to jeszcze przyspieszyć instalując rozszerzenie [GetX extension](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets) do swojego VSCode**. Jeszcze nie dostępne w innych IDE.\n\n# Instalacja\n\nDodaj Get do swojego pliku pubspec.yaml:\n\n```yaml\ndependencies:\n  get:\n```\n\nZaimportuj Get do plików w których chcesz go użyć:\n\n```dart\nimport 'package:get/get.dart';\n```\n\n# Counter App z GetX\n\nPrzykładowa aplikaja tworzona domyślnie podczas kreacji nowego projektu we Flaterze ma ponad 100 lini kodu (z komentarzami). By pokazać siłę Get pokażę jak zrobić \"licznik\" ze zmianą stanu przy każdym kliknięciu, zmianą stron i udostępniajac stan pomiędzy ekranami. Wszystko w zorganizowany sposób dzieląc bussines logic z view w zaledwie 26 LINI KODU WŁĄCZAJĄC W TO KOMENTARZE.\n\n-Krok 1:\nDodaj \"Get\" przed MaterialApp, zamieniając je na GetMaterialApp\n\n\n```dart\nvoid main() => runApp(GetMaterialApp(home: Home()));\n```\n\n- Note: nie jest to modyfikaja MaterialApp, ponieważ GetMaterialApp nie jest zmodyfikowanym MaterialApp z Fluttera, jest tylko skonfigurowanym Widgetem mającym domyślnie MaterialApp jako dziecko. Możesz to konfigurować ręcznie, ale nie jest to konieczne. GetMaterialApp jest niezbędne dla działania routów, snackbarów, bootomsheetów, internacjonalizacji, dialogów i wysokopoziomowych api powiązanych z routami i nieobecnościa kontekstu. Nie jest to jednak wymagane do używania zarzadzania stanem i dependencies.\n\n-Krok 2:\nTworzymy klasę business logic i umieszczmy w niej wszystkie zmienne, metody oraz kontrolery. Możesz zmienić zmiennaą na obserwowalną używajac prostego subfixu \".obs\"\n\n```dart\nclass Controller extends GetxController{\n  var count = 0.obs;\n  increment() => count.value++;\n}\n```\n- Krok 3: \nTworzymy View. Użyj StatelessWidget oszczędzajac przy tym RAM. Z Get nie będzie Ci potrzebny StatefullWidget.\n\n\n```dart\nclass Home extends StatelessWidget {\n\n  @override\n  Widget build(context) {\n\n    // Instantiate your class using Get.put() to make it available for all \"child\" routes there.\n    final Controller c = Get.put(Controller());\n\n    return Scaffold(\n      // Use Obx(()=> to update Text() whenever count is changed.\n      appBar: AppBar(title: Obx(() => Text(\"Clicks: \" + c.count.string))),\n\n      // Replace the 8 lines Navigator.push by a simple Get.to(). You don't need context\n      body: Center(child: ElevatedButton(\n              child: Text(\"Go to Other\"), onPressed: () => Get.to(Other()))),\n      floatingActionButton:\n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n  }\n}\n\nclass Other extends StatelessWidget {\n  // You can ask Get to find a Controller that is being used by another page and redirect you to it.\n  final Controller c = Get.find();\n\n  @override\n  Widget build(context){\n     // Access the updated count variable\n     return Scaffold(body: Center(child: Text(c.count.string)));\n  }\n}\n```\nWynik:\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/counter-app-gif.gif)\n\nJest to prosty projekt, ale już na jego przykładzie widać potęgę Get. Wraz ze wzrostem rozmiaru aplikacji ta różnica tylko się powiększa.\n\nGet był projektowany dla pracy z zespołem, ale równie dobrze sprawdza się w indywidualnych projektach.\n\nZawsze dotrzymuj deadlinów i dostarczaj swoje rozwiązania na czas bez straty na wydajności. Get nie jest dla wszystkich jak już wspominałem, ale jeśli identyfikujesz się z powyższym zdaniem Get jest właśnie dla Ciebie.\n\n# Trzy filary\n\n## Menadżer stanu\n\nObecnie istnieje kilka menadżeów dla Fluttera. Jednak większość z nich wymaga używania ChangeNotifier, po to aby zaktualizować widżety, co nie sprawdza się pod kątem wydajności w średnich i dużych aplikacach. Możesz sprawdzić w oficjalnej dokumentacji, że ChangeNotifier powinien być używany z maksimum dwoma listinerami (https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html), będąc praktycznie bezużytecznym w średnich i duzych projektach. \n\nGet nie jest ani lepszy, ani gorszy od innych menadżerów stanów, ale powinieneś rozpatrzyć te punkty jak i poniższe, aby wybrać między użyciem Get w czystej formie (Vanilla), albo używaniem go wraz z innym menadżerem. \n\nDefinitywnie Get nie jest przeciwnikiem żadnego innego menadżera, ponieważ jest on mikroframeworkiem, nie tylko menadżerem stanu. Może być użyty samodzielnie, lub w koegzystencji.\n\nGet ma bardzo lekki i prosty menadżer stanu (napisany w tylko 95 lini kodu), który nie używa ChangeNotifier. Sprosta on wymaganiom szczególnie nowych we Flutterze i nie sprawi problemu nawet w dużych aplikacjach.\n\n### Reaktywny menadżer stanu\n\nReaktywne programowanie może odtrącać niektórych, ponieważ powszechnie jest uważane za skomplikowane. GetX zamienia to w coś prostego:\n\n- Nie musisz tworzyć StreamControllerów,\n- Nie musisz tworzyć StreamBuildera dla każdej zmiennej,\n- Nie ma potrzeby tworzenia klasy dla każdego stanu,\n- Nie musisz tworzyć Get dla inicjalnej zmiennej\n\nWyobraź sobie, że masz zmienną i za każdym razem jak zmienisz ją chcesz żeby wszystkie widżety używające jej automatycznie się zmieniły\n\nPrzykładowa zmienna:\n```dart\nvar name = 'Jonatas Borges';\n```\n\nBy zamienić ją na obserwowalną dodaj \".obx\" na końcu:\n\n```dart\nvar name = 'Jonatas Borges'.obs;\n```\n\nI w UI, kiedy chcesz go zaktualizować przy modyfikacji zmiennej po prostu dodaj to:\n```dart\nObx (() => Text (controller.name));\n```\n\nTo wszystko. *Proste*, co nie?\n\n### Bardziej szczegółowo o menadżerze stanu\n**Zobacz bardziej szczegółowe wytłumaczenie menadżera stanu [tutaj](./documentation/en_US/state_management.md). Znajdują się  tam przykłady jak o różnice między prostym menadżerem stanu oraz reaktywnym**\n\n### Video tłumaczące użycie menadżera stanu\n\nTadas Petra nagrał o tym niezwykły film: \n\nLink: [Complete GetX State Management](https://www.youtube.com/watch?v=CNpXbeI_slw)\n\n## Zarządzanie routami\n\nJeśli chcesz używać routes/snackbars/dialogs/bottomsheets z GetX możesz to robić bez contextu.\n \nZamień MaterialApp na GetMaterialApp\n```dart\nGetMaterialApp( // Before: MaterialApp(\n  home: MyHome(),\n)\n```\n\nBy nawigować do nowego ekranu:\n\n```dart\nGet.to(NextScreen());\n```\n\nBy powrócić do poprzedniego ekranu\n\n```dart\nGet.back();\n```\n\nBy przejść do następnego ekranu bez możliwości powrotu do poprzedniego (do zastosowania SplashScreenów, ekranów logowania itd.)\n\n```dart\nGet.off(NextScreen());\n```\n\nBy przejść do następnego ekranu niszcząc poprzednie routy (użyteczne w koszykach, ankietach i testach)\n\n```dart\nGet.offAll(NextScreen());\n```\n\nBy nawigować do następnego routa i otrzymać, lub uaktualnić dane zaraz po tym jak z niego wrócisz:\n```dart\nvar data = await Get.to(Payment());\n```\nw innym ekranie wyślij dane z poprzedniego routa:featury\n\n```dart\nGet.back(result: 'sucess');\n```\nI użyj następujące np.:\n```dart\nif(data == 'sucess') madeAnything();\n```\nZobacz, ze do żadnej z tych operacji nie potrzebowałeś contextu. Jest to jedna z głównych zalet GetX oszczędzającego na niepotrzebnej obudowie w kod i dającego możliwość używania tych metod w klasie kontrolera.\n\n\n### Więcej o routach\n\n**Get używa named routes oraz oferuje niskopoziomową obsługę routów! Zobacz bardziej szczegółową dokumentacje [tutaj](./documentation/en_US/route_management.md)**\n\n### Video tłumaczące użycie\n\nTadas Petra nagrał o tym niezwykły film: \n\nLink: [Complete GetX Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI)\n\n## Zarządzanie dependencies\n\nGet  ma prosty, a zarazem potężny menadżer dependencies. Pozwala on na otrzymanie tych samych klas jak twoje Bloc lub Kontroler pisząc jedną linię kodu bez Provider context i inheritedWidget:\n\n```dart\nController controller = Get.put(Controller()); // Rather Controller controller = Controller();\n```\n\n- Note: Jeśli używasz menadżera stanu Get zwróć uwagę na binding api, które pozwoli Ci łatwiej połączyć twój widok z kontrolerem.\nhttps://github.com/jonataslaw/get\n**Tip:** Menadżer dependency Get jest oddzielony od innych części pakietu więc jeśli już używasz menadżera stanu(którego kolwiek, bez różnicy) nie musisz przepisywać tego wszystkiego na nowo. Możesz używać tego dodawania dependencies bez poroblemu.\n\n```dart\ncontroller.fetchApi();\n```\nWyobraź sobie, że musisz nawigować pomiędzy wieloma routami i potrzebujesz dane z kontrolerów z poprzednich ekranów. Musiałbyś użyć menadżera stanu z dodatkiem Providera albo Get_it, prawda? Otóż nie z Fet. Musisz po prostu poprosić Get o znalezienie tego kontrolera i nie potrzebujesz przy tym dodatkowych dependencies.\n\n```dart\nController controller = Get.find();\n//Tak, to wygląda jak Magia, Get znjadzie Twój kontroler i Ci go dostarczy. Możesz mieć nawet MILION kontrolerów, a Get zawsze da Ci prawidłowy kontroler.\n```\n\nI wtedy będziesz mógł otrzymać z niego dane bez żadnego problemu\n\n```dart\nText(controller.textFromApi);\n```\n### Bardziej szczegółowo o menadżerze dependencies\n\n**Zobzcz więcej w dokumentacji [tutaj](./documentation/en_US/dependency_management.md)**\n\n# Jak włożyć coś od siebie\n\nMożesz uczestniczyć w rozwoju projektu na różny sposób:\n- Pomagając w tłumaczeniu readme na inne języki.\n- Dodając dokumentację do readme (nawet połowa funkcji została jeszcze opisana).\n- Pisząc artykuły i nagrywając filmy pokazujące użycie biblioteki Get (będą zamieszczone w readme, a w przyszłości na naszej Wiki).\n- Oferując PR-y dla kodu i testów.\n- Dodając nowe funkcje.\n\nKażda współpraca jest mile widziana!\n\n# Narzędzia\n\n## Zmiana motywu\n\nNie powinno się używać innego widżetu niż GetMaterialApp by go zaktualizować. To może powodować duplikacje kluczy. Wiele osób nawykło do prehistorycznego podejścia tworzenia widżetu \"ThemeProvider\" tylko po to by zmienić motyw aplikacji. Z Get nie jest to wymagane.\n\nMożesz stworzyć customowy motyw i łatwo go dodać z Get.changeTheme bez niepotrzebnego kodu.\n\n```dart\nGet.changeTheme(ThemeData.light());\n```\n\nJeśli chcesz stworzyć coś jak przycisk zmieniający motyw aplikacji na onTap, możesz połączyć dwia Get API. Api sprawdzające czy ciemny motyw jest używany i Api zajmujące się zmianą motywu. Po prostu użyj tego w onPressed:\n\n```dart\nGet.changeTheme(Get.isDarkMode? ThemeData.light(): ThemeData.dark());featury\n```\n\nKiedy ciemny motyw jest aktywny zmieni się on na jasny, w przeciwnym wypadku zmieni się na ciemny.\n\nJeśli interesuje Cię jak zmieniać motywy podążaj za samouczkiem na Medium pokazującum zmianę motywu przy użyciu Get:\n\n- [Dynamic Themes in 3 lines using Get](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Samouczek stworzony przez [Rod Brown](https://github.com/RodBr).\n\n## Inne zaawansowane API\n\n```dart\n// give the current args from currentScreen\nGet.arguments\n\n// give name of previous route\nGet.previousRoute\n\n// give the raw route to access for example, rawRoute.isFirst()\nGet.rawRoute\n\n// give access to Rounting API from GetObserver\nGet.routing\n\n// check if snackbar is open\nGet.isSnackbarOpen\n\n// check if dialog is open\nGet.isDialogOpen\n\n// check if bottomsheet is opefeaturyn\nGet.isBottomSheetOpen\n\n// remove one route.\nGet.removeRoute()\n\n// back repeatedly until the predicate returns true.\nGet.until()\n\n// go to next route and remove all the previous routes until the predicate returns true.\nGet.offUntil()\n\n// go to next named route and remove all the previous routes until the predicate returns true.\nGet.offNamedUntil()\n\n//Check in what platform the app is running\nGetPlatform.isAndroid\nGetPlatform.isIOS\nGetPlatform.isWeb\n\n// Equivalent to the method: MediaQuery.of(context).size.height, but they are immutable.\nGet.height\nGet.width\n\n// Gives the current context of navigator.\nGet.context\n\n// Gives the context of the snackbar/dialog/bottomsheet in the foreground anywhere in your code.\nGet.contextOverlay\n\n// Note: the following methods are extensions on context. Since you\n// have access to context in any place of your UI, you can use it anywhere in the UI code\n\n// If you need a changeable height/width (like browser windows that can be scfeaturyaled) you will need to use context.\ncontext.width\ncontext.height\n \n// gives you the power to define half the screen now, a third of it and so on.\n//Useful for responsive applications.\n// param dividedBy (double) optional - default: 1\n// param reducedBy (double) optional - default: 0\ncontext.heightTransformer()\ncontext.widthTransformer()\n\n/// similar to MediaQuery.of(context).size\ncontext.mediaQuerySize()\n\n/// similar to MediaQuery.of(context).padding\ncontext.mediaQueryPadding()\n\n/// similar to MediaQuery.of(context).viewPadding\ncontext.mediaQueryViewPadding()\n\n/// similar to MediaQuery.of(context).viewInsets;\ncontext.mediaQueryViewInsets()\n\n/// similar to MediaQuery.of(context).orientation;\ncontext.orientation()\n\n/// check if device is on landscape mode\ncontext.isLandscape()\n\n/// check if device is on portrait mode\ncontext.isPortrait()\n\n/// similar to MediaQuery.of(context).devicePixelRatio;\ncontext.devicePixelRatio()\n\n/// similar to MediaQuery.of(context).textScaleFactor;\ncontext.textScaleFactor()\n\n/// get the shortestSide from screen\ncontext.mediaQueryShortestSide()\n\n/// True if width be larger thfeaturyan 800\ncontext.showNavbar()\n\n/// True if the shortestSide is smaller than 600p\ncontext.isPhone()\n\n/// True if the shortestSide is largest than 600p\ncontext.isSmallTablet()\n\n/// True if the shortestSide is largest than 720p\ncontext.isLargeTablet()\n\n/// True if the current device is Tablet\ncontext.isTablet()\n```\n\n### Opcjonalne globalne ustawienia i manualna konfiguracja\n\nGetMaterialApp konfiguruje wszystko za Ciebie, ale jeśli chcesz możesz konfigurować Get manualnie.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver()],\n);\n```\n\nBędziesz mógł używać swojego Midware z GetObserver, nie wpływa to na nic.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [\n    GetObserver(MiddleWare.observer) // Here\n  ],\n);\n```\n\nMozesz stworzyć globalne ustawienia dla Get. Tylko dodaj Get.config do swojego kodu przed użyciem routów, lub bezpośrednio w GetMaterialApp\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  defaultTransition: Transition.fade,\n  opaqueRoute: Get.isOpaqueRouteDefault,\n  popGesture: Get.isPopGestureEnable,\n  transitionDuration: Get.defaultDurationTransition,\n  defaultGlobalState: Get.defaultGlobalState,https://github.com/jonataslaw/ge\n);\n\nGet.config(\n  enableLog = true,\n  defaultPopGesture = true,\n  defaultTransition = Transitions.cupertino\n)\n```\n\nOpcjonalnie możesz przekierować wszystkie logi z Get by używać swojej ulubionej paczki i zbierać w niej logi.\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n    logWriterCallback: localLogWriter,\n\t);\n\tvoid localLogWriter(String text, {bool isError = false}) {\n\t  // tutaj przekaż wiadomosci do ulubionej paczki\n\t    // pamiętaj że nawet jeśli \"enableLog: false\" logi i tak będą wysłane w tym callbacku\n\t\t  // Musisz sprawdzić konfiguracje flag  jeśli chcesz przez GetConfig.isLogEnable\n\t\t  }\n```\n## Video tłumaczące inne funkcjonalności GetX\n\n\nTadas Petra nagrał niezwykły film tłumaczący powyższe zagadnienia! \n\nLink: [GetX Other Features](https://youtu.be/ttQtlX_Q0eU)\n\n\n# Zmiany od 2.0\n\n1- Typy Rx:\n\n| Przed   | Po         |\n| ------- | ---------- |\n| StringX | `RxString` |\n| IntX    | `RxInt`    |\n| MapX    | `RxMax`    |\n| ListX   | `RxList`   |\n| NumX    | `RxNum`    |\n| DoubleX | `RxDouble` |\n\nRXController i GetBuilder teraz zostały połączone. Nie musisz już pamiętać którego kontrolera chcesz użyć, po prostu korzystaj z GetxController, będzie działać zarówno dla prostego jak i reaktywnego menadżera stanów.\n\n2- NamedRoutes\nWcześniej:\n\n```dart\nGetMaterialApp(\n  namedRoutes: {\n    '/': GetRoute(page: Home()),\n  }\n)\n```\n\nTeraz:\n\n```dart\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page: () => Home()),\n  ]\n)\n```\n\nPo co ta zmiana?\nCzęsto może być niezbędnym decydowanie która strona będzie wyświetlana w zależności od parametru, lub tokenu logowania. Wczesniejsze podejście było nieelastyczne, ponieważ na to nie pozwalało. Zawarcie strony w funkcji zmniejszyło sporzycie RAM-u, ze względu na niealokowanie routów od początku działania aplikacji. Pozwoliło to także na takie podejscie:\n\n```dart\n\nGetStorage box = GetStorage();\n\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page:(){  \n      return box.hasData('token') ? Home() : Login();\n    })\n  ]\n)\n```\n"
        },
        {
          "name": "README.pt-br.md",
          "type": "blob",
          "size": 50.1884765625,
          "content": "![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n**Idiomas: [Inglês](README.md), [Vietnamita](README-vi.md), [Indonésia](README.id-ID.md), [Urdu](README.ur-PK.md), [Chinês](README.zh-cn.md), Português (este arquivo), [Espanhol](README-es.md), [Russo](README.ru.md), [Polonês](README.pl.md), [Coreano](README.ko-kr.md), [Francês](README-fr.md)**\n\n[![pub package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n[![popularity](https://badges.bar/get/popularity)](https://pub.dev/packages/sentry/score)\n[![likes](https://badges.bar/get/likes)](https://pub.dev/packages/get/score)\n[![pub points](https://badges.bar/get/pub%20points)](https://pub.dev/packages/get/score)\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n[![style: effective dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n[![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n[![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n<a href=\"https://github.com/Solido/awesome-flutter\">\n   <img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n</a>\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n<h2> Pedimos desculpas por qualquer parte não traduzida aqui. O GetX™ é atualizado com muita frequência e as traduções podem não vir ao mesmo tempo. Então, para manter essa documentação pelo menos com tudo que a versão em inglês tem, eu vou deixar todos os textos não-traduzidos aqui (eu considero que é melhor ele estar lá em inglês do que não estar), então se alguém quiser traduzir, seria muito útil 😁</h2>\n\n- [Sobre Get](#sobre-get)\n- [Instalando](#instalando)\n- [App Counter usando GetX](#app-counter-usando-getx)\n- [Os três pilares](#os-três-pilares)\n  - [Gerenciamento de estado](#gerenciamento-de-estado)\n    - [Reactive state manager](#reactive-state-manager)\n    - [Mais detalhes sobre gerenciamento de estado](#mais-detalhes-sobre-gerenciamento-de-estado)\n    - [Explicação em video do gerenciamento de estado](#explicação-em-video-do-gerenciamento-de-estado)\n  - [Gerenciamento de rotas](#gerenciamento-de-rotas)\n    - [Mais detalhes sobre gerenciamento de rotas](#mais-detalhes-sobre-gerenciamento-de-rotas)\n    - [Explicação em video do gerenciamento de rotas](#explicação-em-video-do-gerenciamento-de-rotas)\n  - [Gerenciamento de Dependência](#gerenciamento-de-dependência)\n    - [Mais detalhes sobre gerenciamento de dependências](#mais-detalhes-sobre-gerenciamento-de-dependências)\n- [Utilidades](#utilidades)\n  - [Internacionalização](#internacionalização)\n    - [Traduções](#traduções)\n      - [Usando traduções](#usando-traduções)\n    - [Localidade](#localidade)\n      - [Alterar local](#alterar-local)\n      - [Localidade do sistema operacional](#localidade-do-sistema-operacional)\n  - [Mudar tema (changeTheme)](#mudar-tema-changetheme)\n  - [GetConnect](#getconnect)\n    - [Configuração Padrão](#configuração-padrão)\n    - [Configuração Personalizada](#configuração-personalizada)\n  - [GetPage Middleware](#getpage-middleware)\n    - [Priority](#priority)\n    - [Redirect](#redirect)\n    - [onPageCalled](#onpagecalled)\n    - [OnBindingsStart](#onbindingsstart)\n    - [OnPageBuildStart](#onpagebuildstart)\n    - [OnPageBuilt](#onpagebuilt)\n    - [OnPageDispose](#onpagedispose)\n  - [Outras APIs avançadas](#outras-apis-avançadas)\n    - [Configurações Globais opcionais e configurações manuais](#configurações-globais-opcionais-e-configurações-manuais)\n    - [Widgets de Estado Local](#widgets-de-estado-local)\n      - [ValueBuilder](#valuebuilder)\n      - [ObxValue](#obxvalue)\n    - [Explicação em vídeo sobre Outras Features do GetX](#explicação-em-vídeo-sobre-outras-features-do-getx)\n  - [Dicas Úteis](#dicas-úteis)\n      - [GetView](#getview)\n      - [GetWidget](#getwidget)\n      - [GetxService](#getxservice)\n- [Breaking Changes da versão 2 para 3](#breaking-changes-da-versão-2-para-3)\n  - [Tipagem Rx](#tipagem-rx)\n  - [RxController e GetBuilder se uniram](#rxcontroller-e-getbuilder-se-uniram)\n  - [Rotas nomeadas](#rotas-nomeadas)\n    - [Porque essa mudança?](#porque-essa-mudança)\n- [Por que GetX™?](#por-que-getx)\n- [Comunidade](#comunidade)\n  - [Canais da comunidade](#canais-da-comunidade)\n  - [Como contribuir](#como-contribuir)\n  - [Artigos e vídeos](#artigos-e-vídeos)\n\n# Sobre Get\n\n- Get é uma biblioteca poderosa e extraleve para Flutter. Ela combina um gerenciador de estado de alta performance, injeção de dependência inteligente e gerenciamento de rotas de uma forma rápida e prática.\n\n- GetX™ possui 3 princípios básicos, o que significa que esta é a prioridade para todos os recursos da biblioteca: **PRODUTIVIDADE, PERFORMANCE AND ORGANIZAÇÃO.**\n\n  - **PERFOMANCE**: GetX™ é focado em desempenho e consumo mínimo de recursos. GetX não usa Streams ou ChangeNotifier. \n\n  - **PRODUTIVIDADE**: GetX™ usa uma sintaxe fácil e agradável. Não importa o que você queira fazer, sempre há uma maneira mais fácil com GetX™. Isso economizará horas de desenvolvimento e extrairá o máximo de desempenho que seu aplicativo pode oferecer.\n  Geralmente, o desenvolvedor deve se preocupar em remover os controladores da memória. Com GetX™, isso não é necessário porque, por padrão, os recursos são removidos da memória quando não são usados. Se quiser mantê-lo na memória, você deve declarar explicitamente \"permanent: true\" em sua dependência. Dessa forma, além de economizar tempo, você corre menos risco de ter dependências desnecessárias na memória. O carregamento da dependência também é lazy por padrão.\n\n  - **ORGANIZAÇÃO**: GetX™ permite o desacoplamento total da View, lógica de apresentação, lógica de negócios, injeção de dependência e navegação. Você não precisa de contexto para navegar entre as rotas, portanto, você não depende da árvore do widget (visualização) para isso. Você não precisa de contexto para acessar seus Controllers/BLoCs por meio de um inheritedWidget, então você desacopla completamente sua lógica de apresentação e lógica de negócios de sua camada de visualização. Você não precisa injetar suas classes Controllers/Models/BLoCs em sua árvore de widgets através de multiproviders, pois GetX™ usa seu próprio recurso de injeção de dependência, desacoplando a DI de sua View completamente. \n  Com GetX™ você sabe onde encontrar cada recurso de sua aplicação, tendo o código limpo por padrão. Isso além de facilitar a manutenção, torna o compartilhamento dos módulos, algo que até então em Flutter era impensável, em algo totalmente possível.\n  O BLoC foi um ponto de partida para organizar o código no Flutter, ele separa a lógica de negócios da visualização. GetX™ é uma evolução natural disso, separando não apenas a lógica de negócios, mas a lógica de apresentação. O bônus da injeção de dependências e rotas também são dissociadas e a camada de dados está fora de tudo. Você sabe onde está tudo e tudo isso de uma maneira mais fácil do que construir um hello world. \n  GetX™ é a maneira mais fácil, prática e escalonável de construir aplicativos de alto desempenho com o Flutter SDK, com um grande ecossistema em torno dele que funciona perfeitamente em conjunto, sendo fácil para iniciantes e preciso para especialistas. É seguro, estável, atualizado e oferece uma grande variedade de APIs integradas que não estão presentes no Flutter SDK padrão.\n\n- GetX™ não é inchado. Possui uma infinidade de recursos que permitem que você comece a programar sem se preocupar com nada, mas cada um desses recursos está em contêineres separados e só são iniciados após o uso. Se você usar apenas o Gerenciamento de estado, apenas o Gerenciamento de estado será compilado. Se você usar apenas rotas, nada do gerenciamento de estado será compilado. \n\n- GetX™ possui um enorme ecossistema, uma grande comunidade, um grande número de colaboradores e será mantido enquanto o Flutter existir. Getx também é capaz de rodar com o mesmo código no Android, iOS, Web, Mac, Linux, Windows e em seu servidor.\n**É possível reutilizar totalmente seu código feito no frontend em seu backend com [Get Server](https://github.com/jonataslaw/get_server)**.\n\n**Além disso, todo o processo de desenvolvimento pode ser totalmente automatizado, tanto no servidor quanto no front-end com **[Get CLI](https://github.com/jonataslaw/get_cli)**.\n\n**Além disso, para aumentar ainda mais sua produtividade, temos a [extensão para VSCode](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets) e a [extensão para Android Studio/Intellij](https://plugins.jetbrains.com/plugin/14975-getx-snippets)**\n\n# Instalando\n\nAdicione Get ao seu arquivo pubspec.yaml\n\n```yaml\ndependencies:\n  get:\n```\n\nImporte o get nos arquivos que ele for usado:\n\n```dart\nimport 'package:get/get.dart';\n```\n\n# App Counter usando GetX\n\nO app 'Counter' criado por padrão no flutter com o comando `flutter create` tem mais de 100 linhas(incluindo os comentários). Para demonstrar o poder do Get, irei demonstrar como fazer o mesmo 'Counter' mudando o estado em cada toque trocando entre páginas e compartilhando o estado entre telas. Tudo de forma organizada, separando a lógica de negócio da View, COM SOMENTE 26 LINHAS INCLUINDO COMENTÁRIOS\n\n- Passo 1:\nTroque `MaterialApp` para `GetMaterialApp`\n\n```dart\nvoid main() => runApp(GetMaterialApp(home: Home()));\n```\n\n- **Obs:** Isso não modifica o `MaterialApp` do Flutter, GetMaterialApp não é uma versão modificada do MaterialApp, é só um Widget pré-configurado, que tem como child o MaterialApp padrão. Você pode configurar isso manualmente, mas definitivamente não é necessário. GetMaterialApp vai criar rotas, injetá-las, injetar traduções, injetar tudo que você precisa para navegação por rotas (gerenciamento de rotas). Se você quer somente usar o gerenciador de estado ou somente o gerenciador de dependências, não é necessário usar o GetMaterialApp. Ele somente é necessário para:\n  - Rotas\n  - Snackbars/bottomsheets/dialogs\n  - apis relacionadas a rotas e a ausência de `context`\n  - Internacionalização\n- **Obs²:** Esse passo só é necessário se você for usar o gerenciamento de rotas (`Get.to()`, `Get.back()` e assim por diante), Se você não vai usar isso então não é necessário seguir o passo 1\n\n- Passo 2:\nCria a sua classe de regra de negócio e coloque todas as variáveis, métodos e controllers dentro dela.\nVocê pode fazer qualquer variável observável usando um simples `.obs`\n\n```dart\nclass Controller extends GetxController{\n  var count = 0.obs;\n  increment() => count.value++;\n}\n```\n\n- Passo 3:\nCrie sua View usando StatelessWidget, já que, usando Get, você não precisa mais usar StatefulWidgets.\n\n```dart\nclass Home extends StatelessWidget {\n\n  @override\n  Widget build(context) { \n\n    // Instancie sua classe usando Get.put() para torná-la disponível para todas as rotas subsequentes\n    final Controller c = Get.put(Controller());\n\n    return Scaffold(\n      // Use Obx(()=> para atualizar Text() sempre que a contagem é alterada.\n      appBar: AppBar(title: Obx(() => Text(\"Total de cliques: ${c.count}\"))),\n\n      // Troque o Navigator.push de 8 linhas por um simples Get.to(). Você não precisa do 'context'\n      body: Center(child: ElevatedButton(\n              child: Text(\"Ir pra Outra tela\"), onPressed: () => Get.to(Outra()))),\n      floatingActionButton: \n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n  } \n}\n\nclass Outra extends StatelessWidget {\n  // Você pode pedir o Get para encontrar o controller que foi usado em outra página e redirecionar você pra ele.\n  final Controller c = Get.find();\n  @override\n  Widget build(context) => Scaffold(body: Center(child: Text(\"${c.count}\")));\n}\n\n```\n\nResultado:\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/counter-app-gif.gif)\n\nEsse é um projeto simples mas já deixa claro o quão poderoso o Get é. Enquanto seu projeto cresce, essa diferença se torna bem mais significante.\n\nGet foi feito para funcionar com times, mas torna o trabalho de um desenvolvedor individual simples.\n\nMelhore seus prazos, entregue tudo a tempo sem perder performance. Get não é para todos, mas se você identificar com o que foi dito acima, Get é para você!\n\n\n# Os três pilares\n\n## Gerenciamento de estado\n\nGetX™ possui dois gerenciadores de estado diferentes: o gerenciador de estado simples (vamos chamá-lo de GetBuilder) e o gerenciador de estado reativo (GetX/Obx)\n\n### Reactive state manager\n\nProgramação reativa pode alienar muitas pessoas porque é dito que é complicado. GetX™ transforma a programação reativa em algo bem simples:\n\n* Você não precisa criar StreamControllers\n* Você não precisa criar um StreamBuilder para cada variável\n* Você não precisa criar uma classe para cada estado\n* Você não precisa criar um get para o valor inicial\n* Você não precisará usar geradores de código\n\nProgramação reativa com o Get é tão fácil quanto usar setState.\n\nVamos imaginar que você tenha uma variável e quer que toda vez que ela alterar, todos os widgets que a usam são automaticamente alterados.\n\nEssa é sua variável:\n\n```dart\nvar name = 'Jonatas Borges';\n```\n\nPara fazer dela uma variável observável, você só precisa adicionar `.obs` no final:\n\n```dart\nvar name = 'Jonatas Borges'.obs;\n```\n\nE Na UI, quando quiser mostrar a variável e escutar as mudanças dela, simplesmente faça isso:\n\n```dart\nObx (() => Text (controller.name));\n```\n\nSó isso. É *simples assim*;\n\n### Mais detalhes sobre gerenciamento de estado\n\n**Veja uma explicação mais completa do gerenciamento de estado [aqui](./documentation/pt_BR/state_management.md). Lá terá mais exemplos e também a diferença do simple state manager do reactive state manager**\n\n### Explicação em video do gerenciamento de estado\n\nAmateur Coder fez um vídeo ótimo sobre o gerenciamento de estado! (em inglês). Link: [Complete GetX State Management](https://www.youtube.com/watch?v=CNpXbeI_slw)\n\nVocê vai ter uma boa idea do poder do GetX™\n\n## Gerenciamento de rotas\n\nSe você for usar routes / snackbars / dialogs / bottomsheets sem contexto, GetX™ é excelente para você também, veja:\n\nAdicione \"Get\" antes do seu MaterialApp, transformando-o em GetMaterialApp\n\n```dart\nGetMaterialApp( // Antes: MaterialApp(\n  home: MyHome(),\n)\n```\n\nPara navegar para uma próxima tela:\n\n```dart\nGet.to(ProximaTela());\n```\n\nPara navegar para uma próxima tela com uma rota nomeada. Veja mais detalhes sobre rotas nomeadas [aqui](./documentation/pt_BR/route_management.md#navegar-com-rotas-nomeadas)\n\n```dart\nGet.toNamed('/detalhes');\n```\n\nPara fechar snackbars, dialogs, bottomsheets, ou qualquer coisa que você normalmente fecharia com o `Navigator.pop(context)` (como por exemplo fechar a View atual e voltar para a anterior):\n\n```dart\nGet.back();\n```\n\nPara ir para a próxima tela e NÃO deixar opção para voltar para a tela anterior (bom para SplashScreens, telas de login e etc.):\n\n```dart\nGet.off(ProximaTela());\n```\n\nPara ir para a próxima tela e cancelar todas as rotas anteriores (útil em telas de carrinho, votações ou testes):\n\n```dart\nGet.offAll(ProximaTela());\n```\n\nPara navegar para a próxima rota e receber ou atualizar dados assim que retornar da rota:\n\n```dart\nvar dados = await Get.to(Pagamento());\n```\n\nNotou que você não precisou usar `context` para fazer nenhuma dessas coisas? Essa é uma das maiores vantagens de usar o gerenciamento de rotas do GetX™. Com isso, você pode executar todos esse métodos de dentro da classe Controller, sem preocupações.\n\n### Mais detalhes sobre gerenciamento de rotas\n\n**GetX™ funciona com rotas nomeadas também! Veja uma explicação mais completa do gerenciamento de rotas [aqui](./documentation/pt_BR/route_management.md)**\n\n### Explicação em video do gerenciamento de rotas\n\nAmateur Coder fez um outro vídeo excelente sobre gerenciamento de rotas! Link: [Complete Getx Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI)\n\n## Gerenciamento de Dependência\n\n- Nota: Se você está usando o gerenciador de estado do Get, você não precisa se preocupar com isso, só leia a documentação, mas dê uma atenção a api `Bindings`, que vai fazer tudo isso automaticamente para você.\n\nJá está usando o Get e quer fazer seu projeto o melhor possível? Get tem um gerenciador de dependência simples e poderoso que permite você pegar a mesma classe que seu Bloc ou Controller com apenas uma linha de código, sem Provider context, sem inheritedWidget:\n\n```dart\nController controller = Get.put(Controller()); // Em vez de Controller controller = Controller();\n```\n\nEm vez de instanciar sua classe dentro da classe que você está usando, você está instanciando ele dentro da instância do Get, que vai fazer ele ficar disponível por todo o App para que então você possa usar seu controller (ou uma classe Bloc) normalmente\n\n\n**Dica:** O gerenciamento de dependência Get é desacoplado de outras partes do pacote, então se, por exemplo, seu aplicativo já estiver usando um gerenciador de estado (qualquer um, não importa), você não precisa reescrever tudo, você pode usar esta injeção de dependência sem problemas\n\n```dart\ncontroller.fetchApi();\n```\n\nAgora, imagine que você navegou por inúmeras rotas e precisa de dados que foram deixados para trás em seu controlador. Você precisaria de um gerenciador de estado combinado com o Provider ou Get_it, correto? Não com Get. Você só precisa pedir ao Get para \"procurar\" pelo seu controlador, você não precisa de nenhuma dependência adicional para isso:\n\n```dart\nController controller = Get.find();\n// Sim, parece Magia, o Get irá descobrir qual é seu controller e irá te entregar.\n// Você pode ter 1 milhão de controllers instanciados, o Get sempre te entregará o controller correto.\n// Apenas se lembre de Tipar seu controller, final controller = Get.find(); por exemplo, não irá funcionar.\n```\n\nE então você será capaz de recuperar os dados do seu controller que foram obtidos anteriormente:\n\n```dart\nText(controller.textFromApi);\n```\n\nProcurando por `lazyLoading` (carregar somente quando for usar)? Você pode declarar todos os seus controllers e eles só vão ser inicializados e chamados quando alguém precisar. Você pode fazer isso\n\n```dart\nGet.lazyPut<Service>(()=> ApiMock());\n/// ApiMock só será chamado quando alguém usar o Get.find<Service> pela primeira vez\n```\n\n### Mais detalhes sobre gerenciamento de dependências\n\n**Veja uma explicação mais completa do gerenciamento de dependência [aqui](./documentation/pt_BR/dependency_management.md)**\n\n# Utilidades\n\n## Internacionalização\n### Traduções\nNós mantemos as traduções num simples dictionary map de chave-valor.\nPara adicionar traduções personalizadas, crie uma classe e estenda `Translations`.\n\n```dart\nimport 'package:get/get.dart';\n\nclass Messages extends Translations {\n  @override\n  Map<String, Map<String, String>> get keys => {\n    'en_US': {\n      'hello': 'Hello World',\n    },\n    'de_DE': {\n      'hello': 'Hallo Welt',\n    }\n  };\n}\n```\n\n#### Usando traduções\nBasta anexar `.tr` a chave especificada e ela será traduzida, usando o valor atual de `Get.locale` ou `Get.fallbackLocale`.\n```dart\nText('hello'.tr);\n```\n\n### Localidade\nPasse parâmetros para `GetMaterialApp` definir a localidade e as traduções.\n\n```dart\nreturn GetMaterialApp(\n    translations: Messages(), // suas traduções\n    locale: Locale('en', 'US'), // as traduções serão exibidas para esta localidade\n    fallbackLocale: Locale('en', 'UK'), // especifica uma localidade em caso de falha na localidade definida\n);\n```\n\n#### Alterar local\nUse `Get.updateLocale(locale)` para atualizar a localidade. As traduções usarão automaticamente a nova localidade e a UI será atualizada.\n```dart\nvar locale = Locale('en', 'US');\nGet.updateLocale(locale);\n```\n\n#### Localidade do sistema operacional\nPara ler a localidade do sistema operacional, você pode usar `Get.deviceLocale`.\n```dart\nimport 'dart:ui' as ui;\n\nreturn GetMaterialApp(\n    locale: Get.deviceLocale,\n);\n```\n\n## Mudar tema (changeTheme)\n\nPor favor não use widget acima do GetMaterialApp para atualizar o tema. Isso pode causar keys duplicadas. Várias pessoas estão acostumadas com o jeito normal de criar um Widget `ThemeProvider` só pra alterar o tema do app, mas isso definitivamente NÃO é necessário com GetX™.\n\nVocê pode criar seu tema customizado e simplesmente adicionar dentro do `Get.changeTheme` sem nenhum boilerplate para isso:\n\n```dart\nGet.changeTheme(ThemeData.light())\n```\n\nSe você quer criar algo como um botão que muda o tema com o toque, você pode combinar duas APIs GetX™ pra isso:\n- A API que checa se o tema dark está sendo aplicado;\n- A API de mudar o tema e colocar isso no `onPressed:`\n\n```dart\nGet.changeTheme(Get.isDarkMode ? ThemeData.light() : ThemeData.dark())\n```\n\nQuando o modo Dark está ativado, ele vai trocar pro modo light e vice versa.\n\nSe você quiser saber mais como trocar o tema, você pode seguir esse tutorial no Medium que até ensina persistência do tema usando Get (e SharedPreferences):\n\n- [Dynamic Themes in 3 lines using Get](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Tutorial by [Rod Brown](https://github.com/RodBr).\n\n\n## GetConnect\nGetConnect é uma maneira fácil de se comunicar de trás para a frente com http ou websockets\n\n### Configuração Padrão\nVocê pode simplesmente estender GetConnect e usar os métodos GET/POST/PUT/DELETE/SOCKET para se comunicar com sua API Rest ou websockets.\n\n```dart\nclass UserProvider extends GetConnect {\n  // Requisição Get\n  Future<Response> getUser(int id) => get('http://youapi/users/$id');\n  // Requisição Post\n  Future<Response> postUser(Map data) => post('http://youapi/users', body: data);\n  // Requisição Post com Arquivo\n  Future<Response<CasesModel>> postCases(List<int> image) {\n    final form = FormData({\n      'file': MultipartFile(image, filename: 'avatar.png'),\n      'otherFile': MultipartFile(image, filename: 'cover.png'),\n    });\n    return post('http://youapi/users/upload', form);\n  }\n\n  GetSocket userMessages() {\n    return socket('https://yourapi/users/socket');\n  }\n}\n```\n### Configuração Personalizada\nGetConnect é altamente personalizável, você pode definir uma base Url, modificadores de resposta, modificadores de Requests, definir um autenticador e até o número de tentativas em que tentará se autenticar, além de dar a possibilidade de definir um decodificador padrão que irá transformar todas as suas solicitações em seus modelos sem qualquer configuração adicional.\n\n```dart\nclass HomeProvider extends GetConnect {\n  @override\n  void onInit() {\n    // Todas as requisições passam por jsonEncode e então por CasesModel.fromJson()\n    httpClient.defaultDecoder = CasesModel.fromJson;\n    httpClient.baseUrl = 'https://api.covid19api.com';\n    // baseUrl = 'https://api.covid19api.com'; // Define baseUrl para\n    // Http e websockets se usado sem uma instância [httpClient]\n\n    // Anexa a propriedade 'apikey' no cabeçalho de todas as requisições\n    httpClient.addRequestModifier((request) {\n      request.headers['apikey'] = '12345678';\n      return request;\n    });\n\n    // Mesmo que o servidor envie dados do país \"Brasil\",\n    // eles nunca serão exibidos para os usuários, porque você removeu\n    // os dados da resposta, mesmo antes de a resposta ser entregue\n    httpClient.addResponseModifier<CasesModel>((request, response) {\n      CasesModel model = response.body;\n      if (model.countries.contains('Brazil')) {\n        model.countries.remove('Brazil');\n      }\n    });\n\n    httpClient.addAuthenticator((request) async {\n      final response = await get(\"http://yourapi/token\");\n      final token = response.body['token'];\n      // Configurando um cabeçalho\n      request.headers['Authorization'] = \"$token\";\n      return request;\n    });\n\n    // O autenticador será chamado 3 vezes se HttpStatus for \n    // HttpStatus.unauthorized\n    httpClient.maxAuthRetries = 3;\n  }\n  }\n\n  @override\n  Future<Response<CasesModel>> getCases(String path) => get(path);\n}\n```\n\n## GetPage Middleware\n\nO GetPage agora tem uma nova propriedade que recebe uma lista de GetMiddleWare e executa cada item na ordem específica.\n\n**Nota**: Quando GetPage tem Middlewares, todos os filhos desta página terão os mesmos middlewares automaticamente.\n\n### Priority\n\nA ordem dos middlewares a serem executados pode ser definida pela prioridade no GetMiddleware.\n\n```dart\nfinal middlewares = [\n  GetMiddleware(priority: 2),\n  GetMiddleware(priority: 5),\n  GetMiddleware(priority: 4),\n  GetMiddleware(priority: -8),\n];\n```\nEsses middlewares serão executados nesta ordem:  **-8 => 2 => 4 => 5**\n\n### Redirect\n\nEsta função será chamada quando a página da rota chamada estiver sendo pesquisada. RouteSettings se torna o resultado do redirecionamento. Ou retorne nulo e não haverá redirecionamento.\n\n```dart\nRouteSettings redirect(String route) {\n  final authService = Get.find<AuthService>();\n  return authService.authed.value ? null : RouteSettings(name: '/login')\n}\n```\n\n### onPageCalled\n\nEsta função será chamada quando uma página for chamada, antes de qualquer coisa ser criada e\nvocê pode usá-la para mudar algo sobre a página ou dar-lhe uma nova página\n\n```dart\nGetPage onPageCalled(GetPage page) {\n  final authService = Get.find<AuthService>();\n  return page.copyWith(title: 'Welcome ${authService.UserName}');\n}\n```\n\n### OnBindingsStart\n\nEsta função será chamada logo antes da inicialização dos Bindings.\nAqui você pode alterar as ligações desta página.\n\n```dart\nList<Bindings> onBindingsStart(List<Bindings> bindings) {\n  final authService = Get.find<AuthService>();\n  if (authService.isAdmin) {\n    bindings.add(AdminBinding());\n  }\n  return bindings;\n}\n```\n\n### OnPageBuildStart\n\nEsta função será chamada logo após a inicialização dos Bindings.\nAqui você pode fazer algo depois de criar as ligações e antes de criar o widget da página.\n\n```dart\nGetPageBuilder onPageBuildStart(GetPageBuilder page) {\n  print('bindings are ready');\n  return page;\n}\n```\n\n### OnPageBuilt\n\nEsta função será chamada logo após a função GetPage.page ser chamada e fornecerá o resultado da função e obtém o widget que será mostrado.\n\n### OnPageDispose\n\nEsta função será chamada logo após descartar todos os objetos relacionados (controladores, visualizações, ...) da página.\n\n## Outras APIs avançadas\n\n```dart\n// fornece os arguments da tela atual\nGet.arguments\n\n// fornece o nome da rota anterior\nGet.previousRoute\n\n// fornece a rota bruta para acessar por exemplo, rawRoute.isFirst()\nGet.rawRoute\n\n// fornece acesso a API de rotas de dentro do GetObserver\nGet.routing\n\n// checa se o snackbar está aberto\nGet.isSnackbarOpen\n\n// checa se o dialog está aberto\nGet.isDialogOpen\n\n// checa se o bottomsheet está aberto\nGet.isBottomSheetOpen\n\n// remove uma rota.\nGet.removeRoute()\n\n// volta repetidamente até o predicate retorne true.\nGet.until()\n\n// vá para a próxima rota e remove todas as rotas\n//anteriores até que o predicate retorne true.\nGet.offUntil()\n\n// vá para a próxima rota nomeada e remove todas as\n//rotas anteriores até que o predicate retorne true.\nGet.offNamedUntil()\n\n// Verifica em que plataforma o app está sendo executado\n// (Esse método é completamente compatível com o FlutterWeb,\n// diferente do método do framework \"Platform.isAndroid\")\nGetPlatform.isAndroid\nGetPlatform.isIOS\nGetPlatform.isMacOS\nGetPlatform.isWindows\nGetPlatform.isLinux\nGetPlatform.isFuchsia\n\n// Verifica o tipo de dispositivo\nGetPlatform.isMobile\nGetPlatform.isDesktop\n// Todas as plataformas são suportadas de forma independente na web!\n// Você pode saber se está executando dentro de um navegador\n// no Windows, iOS, OSX, Android, etc.\nGetPlatform.isWeb\n\n// Equivalente ao método: MediaQuery.of(context).size.width ou height, mas é imutável. \n// Significa que não irá atualizar mesmo que o tamanho da tela mude (como em navegadores ou app desktop)\nGet.height\nGet.width\n\n// fornece o context da tela em qualquer lugar do seu código.\nGet.context\n\n// fornece o context de snackbar/dialog/bottomsheet em qualquer lugar do seu código.\nGet.contextOverlay\n\n// Obs: os métodos a seguir são extensions do context. Já que se\n// tem acesso ao context em qualquer lugar do código da UI, você pode usar lá\n\n// Se você precisa de um width/height adaptável (como em navegadores em que a janela pode ser redimensionada) \n// você precisa usar 'context'\ncontext.width\ncontext.height\n\n// Dá a você agora o poder de definir metade da tela, um terço da dela e assim por diante.\n// Útil para aplicativos responsivos.\n// param dividedBy (double) opcional - default: 1\n// param reducedBy (double) opcional - default: 0\ncontext.heightTransformer()\ncontext.widthTransformer()\n\n/// similar a MediaQuery.of(context).size\ncontext.mediaQuerySize()\n\n/// similar a MediaQuery.of(this).padding\ncontext.mediaQueryPadding()\n\n/// similar a MediaQuery.of(this).viewPadding\ncontext.mediaQueryViewPadding()\n\n/// similar a MediaQuery.of(this).viewInsets;\ncontext.mediaQueryViewInsets()\n\n/// similar a MediaQuery.of(this).orientation;\ncontext.orientation()\n\n/// verifica se o dispositivo está no modo paisagem\ncontext.isLandscape()\n\n/// verifica se o dispositivo está no modo retrato\ncontext.isPortrait()\n\n/// similar a MediaQuery.of(this).devicePixelRatio;\ncontext.devicePixelRatio()\n\n/// similar a MediaQuery.of(this).textScaleFactor;\ncontext.textScaleFactor()\n\n/// obtém a menor dimensão (largura ou altura) da tela\ncontext.mediaQueryShortestSide()\n\n/// retorna True se a largura da tela for maior que 800px\ncontext.showNavbar()\n\n/// retorna True se a menor dimensão (largura ou altura) da tela for menor que 600px\ncontext.isPhone()\n\n/// retorna True se a menor dimensão (largura ou altura) da tela for maior ou igual a 600px\ncontext.isSmallTablet()\n\n/// retorna True se a menor dimensão (largura ou altura) da tela for maior ou igual a 720px\ncontext.isLargeTablet()\n\n/// retorna True se o dispositivo é um Tablet\ncontext.isTablet()\n\n/// Retorna um valor de acordo com o tamanho da tela\n/// Os valores possíveis são:\n/// swatch: se a menor dimensão (largura ou altura) da tela for menor que 300px\n/// mobile: se a menor dimensão (largura ou altura) da tela for menor que 600px\n/// tablet: se a menor dimensão (largura ou altura) da tela for menor que 1200px\n/// desktop: se a largura da tela é maior ou iguial a 1200px  \ncontext.responsiveValue<T>()\n```\n\n### Configurações Globais opcionais e configurações manuais\n\nGetMaterialApp configura tudo para você, mas se quiser configurar Get manualmente, você pode.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver()],\n);\n```\n\nVocê também será capaz de usar seu próprio Middleware dentro do GetObserver, isso não irá influenciar em nada.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [\n    GetObserver(MiddleWare.observer) // Aqui\n  ],\n);\n```\n\nVocê pode criar Configurações Globais para o Get. Apenas adicione `Get.config` ao seu código antes de usar qualquer rota ou faça diretamente no seu GetMaterialApp\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  defaultTransition: Transition.fade,\n  opaqueRoute: Get.isOpaqueRouteDefault,\n  popGesture: Get.isPopGestureEnable,\n  transitionDuration: Get.defaultDurationTransition,\n  defaultGlobalState: Get.defaultGlobalState,\n);\nGet.config(\n  enableLog = true,\n  defaultPopGesture = true,\n  defaultTransition = Transitions.cupertino\n)\n```\n\nÉ possível redirecionar todas as mensagens de log do GetX™. Útil quando se tem um package de logging e vc quer que ele lide com todos os logs\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  logWriterCallback: localLogWriter,\n);\n\nvoid localLogWriter(String text, {bool isError = false}) {\n  // passage a mensagem para seu package de logging favorito aqui\n  // Obs: mesmo que as mensagens de log estejam desativadas\n  // com o comando \"enableLog: false\", as mensagens ainda vão passar por aqui\n  // Você precisa checar essa config manualmente aqui se quiser respeitá-la\n}\n```\n\n### Widgets de Estado Local\n\nEsses Widgets permitem que você gerencie um único valor e mantenha o estado efêmero e localmente. Temos versões para Reativo e Simples. Por exemplo, você pode usá-los para alternar obscureText em um `TextField`, talvez criar um painel expansível personalizado ou talvez modificar o índice atual em um `BottomNavigationBar` enquanto altera o conteúdo do corpo em um `Scaffold`.\n\n#### ValueBuilder\nUma simplificação de `StatefulWidget` que funciona com um callback de `setState` que passa o valor atualizado.\n\n\n```dart\nValueBuilder<bool>(\n  initialValue: false,\n  builder: (value, updateFn) => Switch(\n    value: value,\n    onChanged: updateFn, // mesma assinatura! Você poderia usar ( newValue ) => updateFn( newValue )\n  ),\n  // se você precisa chamar algo fora do método builder.\n  onUpdate: (value) => print(\"Valor atualizado: $value\"),\n  onDispose: () => print(\"Widget desmontado\"),   \n),\n```\n\n#### ObxValue\nSimilar a ValueBuilder, mas esta é a versão Reativa, você passa uma instância Rx (lembra do .obs mágico?) e \natualiza automaticamente... não é incrível?\n\n```dart\nObxValue(\n  (data) => Switch(\n    value: data.value,\n    onChanged: data, // Rx tem uma função _callable_! Você poderia usar (flag) => data.value = flag,\n  ),\n  false.obs,\n),\n```\n\n### Explicação em vídeo sobre Outras Features do GetX\n\nAmateur Coder fez um vídeo incrível sobre utils, storage, bindings e outras features! Link: [GetX Other Features](https://youtu.be/ttQtlX_Q0eU)\n\n\n## Dicas Úteis\n\n`.obs`ervables (também conhecidos como _Rx_ Types) possuem uma grande variedade de métodos e operadores internos.\n\n> É muito comum acreditar que uma propriedade com `.obs` **É** o valor real... mas não se engane!\n> Evitamos a declaração de tipo da variável, porque o compilador do Dart é inteligente o suficiente e o código\n> parece mais limpo, mas:\n\n```dart\nvar message = 'Hello world'.obs;\nprint( 'Message \"$message\" é do tipo ${message.runtimeType}');\n```\n\nMesmo que `message` _imprima_ o valor da string, seu tipo é **RxString**!\n\nEntão, você não pode fazer `message.substring( 0, 4 )`.\nVocê tem que acessar o `valor` real dentro do _observable_:\nA \"maneira\" mais usada é utilizando `.value`, mas, você sabia que também pode usar:\n\n```dart\nfinal name = 'GetX'.obs;\n// apenas \"atualiza\" o stream, se o valor for diferente do atual.\nname.value = 'Hey';\n\n// Todas as propriedades Rx são \"chamáveis\" e retorna o novo valor.\n// mas esta abordagem não aceita `null`, a UI não será reconstruída\nname('Hello');\n\n// é como um getter, imprime 'Hello'\nname() ;\n\n/// números:\n\nfinal count = 0.obs;\n\n// Você pode usar todas as operações não mutáveis ​​de um num! \ncount + 1;\n\n// Cuidado! isso só é válido se `count` não for final, mas var\ncount += 1;\n\n// Você também pode comparar com os valores:\ncount > 2;\n\n/// booleans:\n\nfinal flag = false.obs;\n\n// mude o valor entre true/false\nflag.toggle();\n\n\n/// todos os tipos:\n\n// Defina `value` como null.\nflag.nil();\n\n// Todas as operações toString() e toJson() são passada para `value`\nprint( count ); // chama `toString()` de RxInt\n\nfinal abc = [0,1,2].obs;\n// Converte o valor em um Array json, imprime RxList\n// Json é suportado por todos os Rx types!\nprint('json: ${jsonEncode(abc)}, type: ${abc.runtimeType}');\n\n// RxMap, RxList e RxSet são Rx types especiais, que estendem seus tipos nativos.\n// mas você pode trabalhar com uma lista como uma lista normal, embora seja reativa!\nabc.add(12); // Coloca 12 na lista, e ATUALIZA o stream.\nabc[3]; // como uma lista lê o índice 3.\n\n// a igualdade funciona com o Rx e o value do observável, mas o hashCode é sempre obtido do value \nfinal number = 12.obs;\nprint( number == 12 ); // prints > true\n\n/// Rx Models personalizados:\n\n// toJson(), toString() são transferidos para o filho, para que você possa implementar \n// override neles e imprimir o observável diretamente.\n\nclass User {\n    String name, last;\n    int age;\n    User({this.name, this.last, this.age});\n\n    @override\n    String toString() => '$name $last, $age years old';\n}\n\nfinal user = User(name: 'John', last: 'Doe', age: 33).obs;\n\n// `user` é \"reativo\", mas as propriedades dentro NÃO SÃO!\n// Então, se mudarmos alguma variável dentro dele:\nuser.value.name = 'Roi';\n// O widget não vai reconstruir!,\n// `Rx` não tem nenhuma notificação quando você muda algo dentro do usuário.\n// Portanto, para classes personalizadas, precisamos \"notificar\" manualmente a mudança.\nuser.refresh();\n\n// ou podemos usar o método `update()`!\nuser.update((value){\n  value.name='Roi';\n});\n\nprint( user ); // Resultado (toString): Roi Doe, 33 years old\n```\n\n#### GetView\n\nEu amo este Widget, é tão simples, mas tão útil!\n\nÉ um Widget `const Stateless` que tem um getter `controller` registrado para Controller, só isso.\n\n```dart\nclass AwesomeController extends GetxController {\n  final String title = 'My Awesome View';\n}\n\n// SEMPRE lembre de passar o `Type` que você usou para registrar seu controlador!\nclass AwesomeView extends GetView<AwesomeController> {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(20),\n      child: Text(controller.title ), // apenas chame `controller.something`\n    );\n  }\n}\n```\n\n#### GetWidget\n\nA maioria das pessoas não tem ideia sobre este widget, ou confunde totalmente o uso dele. \nO caso de uso é muito raro, mas muito específico: Ele armazena em `cache` um Controller. \nPor causa do _cache_, não pode ser um `const Stateless`.\n\n> Então, quando você precisa armazenar em \"cache\" um Controller?\n\nSe você usar, uma outra característica \"não tão comum\" de **GetX™**: `Get.create()`.\n\n`Get.create(()=>Controller())` irá gerar um novo `Controller` cada vez que você chamar\n`Get.find<Controller>()`,\n\nÉ aí que `GetWidget` brilha... já que você pode usá-lo, por exemplo, \npara manter uma lista de itens Todo. Portanto, se o widget for \"reconstruído\", ele manterá a mesma instância do controlador.\n\n#### GetxService\n\nEsta classe é como um `GetxController`, ele compartilha o mesmo ciclo de vida ( `onInit()`, `onReady()`, `onClose()`). \nMas não tem \"lógica\" dentro dele. Ele apenas notifica o sistema de injeção de dependência do GetX™ de que esta subclasse\n**não pode** ser removida da memória.\n\nPortanto, é muito útil manter seus \"Services\" sempre acessíveis e ativos com `Get.find()`. Como: \n`ApiService`, `StorageService`, `CacheService`.\n\n```dart\nFuture<void> main() async {\n  await initServices(); /// Aguarda a inicialização dos Services.\n  runApp(SomeApp());\n}\n\n/// É uma jogada inteligente para inicializar seus services antes de executar o aplicativo Flutter, \n/// já que você pode controlar o fluxo de execução (talvez você precise carregar alguma configuração de tema, \n/// apiKey, linguagem definida pelo usuário ... então carregue SettingService antes de executar ApiService. \n/// então GetMaterialApp() não precisa reconstruir e obtém os valores diretamente.\nvoid initServices() async {\n  print('iniciando serviços...');\n  /// Aqui é onde você coloca a inicialização de get_storage, hive, shared_pref. \n  /// ou checa a conexão, ou o que quer que seja assíncrono.\n  await Get.putAsync(() => DbService().init());\n  await Get.putAsync(SettingsService()).init();\n  print('Todos os serviços iniciados.');\n}\n\nclass DbService extends GetxService {\n  Future<DbService> init() async {\n    print('$runtimeType delays 2 sec');\n    await 2.delay();\n    print('$runtimeType ready!');\n    return this;\n  }\n}\n\nclass SettingsService extends GetxService {\n  void init() async {\n    print('$runtimeType delays 1 sec');\n    await 1.delay();\n    print('$runtimeType ready!');\n  }\n}\n```\n\nA única maneira de realmente excluir um `GetxService`, é com o `Get.reset()`, que é como uma \n\"hot restart\" do seu aplicativo. Portanto, lembre-se, se você precisar de persistência absoluta de uma instância de classe durante\no ciclo de vida de seu aplicativo, use GetxService.\n\n\n# Breaking Changes da versão 2 para 3\n\n## Tipagem Rx\n\n| Antes   | Depois     |\n| ------- | ---------- |\n| StringX | `RxString` |\n| IntX    | `RxInt`    |\n| MapX    | `RxMap`    |\n| ListX   | `RxList`   |\n| NumX    | `RxNum`    |\n| DoubleX | `RxDouble` |\n\n## RxController e GetBuilder se uniram\n\nRxController e GetBuilder agora viraram um só, você não precisa mais memorizar qual controller quer usar, apenas coloque `GetxController`, vai funcionar para os dois gerenciamento de estados\n\n```dart\n//Gerenciador de estado simples\nclass Controller extends GetXController {\n  String nome = '';\n\n  void atualizarNome(String novoNome) {\n    nome = novoNome;\n    update()\n  }\n}\n```\n\n```dart\nclass Controller extends GetXController {\n  final nome = ''.obs;\n\n  // não precisa de um método direto pra atualizar o nome\n  // só usar o nome.value\n}\n```\n\n## Rotas nomeadas\n\nAntes:\n\n```dart\nGetMaterialApp(\n  namedRoutes: {\n    '/': GetRoute(page: Home()),\n  }\n)\n```\n\nAgora:\n\n```dart\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page: () => Home()),\n  ]\n)\n```\n\n### Porque essa mudança?\n\nFrequentemente, pode ser necessário decidir qual pagina vai ser mostrada ao usuário a partir de um parâmetro, como um token de login. A forma abordada anteriormente não era flexível, já que não permitia isso.\n\nInserir a página numa função reduziu significativamente o consumo de RAM, já que as rotas não são alocadas na memória no momento que o app é iniciado e também permite fazer esse tipo de abordagem:\n\n```dart\n\nGetStorage box = GetStorage();\n\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page:(){  \n      return box.hasData('token') ? Home() : Login();\n    })\n  ]\n)\n```\n\n# Por que GetX™?\n\n1- Muitas vezes após uma atualização do Flutter, muitos dos seus packages irão quebrar. As vezes acontecem erros de compilação, muitas vezes aparecem erros que ainda não existem respostas sobre e o desenvolvedor necessita saber de onde o erro veio, rastreá-lo, para só então tentar abrir uma issue no repositório correspondente e ver seu problema resolvido. Get centraliza os principais recursos para o desenvolvimento (Gerência de estado, de dependências e de rotas), permitindo você adicionar um único package em seu pubspec e começar a trabalhar. Após uma atualização do Flutter, a única coisa que você precisa fazer é atualizar a dependencia do Get e começar a trabalhar. Get também resolve problemas de compatibilidade. Quantas vezes uma versão de um package não é compatível com a versão de outro, porque um utiliza uma dependência em uma versão e o outro em outra versão? Essa também não é uma preocupação usando Get, já que tudo está no mesmo package e é totalmente compatível.\n\n2- Flutter é fácil, Flutter é incrível, mas Flutter ainda tem algum boilerplate que pode ser indesejado para maioria dos desenvolvedores, como o Navigator.of(context).push(context, builder[...]. Get simplifica o desenvolvimento. Em vez de escrever 8 linhas de código para apenas chamar uma rota, você pode simplesmente fazer: Get.to(Home()) e pronto, você irá para a próxima página. Urls dinâmicas da web é algo realmente doloroso de fazer com o Flutter atualmente e isso com o GetX™ é estupidamente simples. Gerenciar estados no Flutter e gerenciar dependências também é algo que gera muita discussão, por haver centenas de padrões na pub. Mas não há nada que seja tão fácil quanto adicionar um \".obs\" no final de sua variável, colocar o seu widget dentro de um Obx e pronto, todas atualizações daquela variável serão automaticamente atualizadas na tela.\n\n3- Facilidade sem se preocupar com desempenho. O desempenho do Flutter já é incrível, mas imagine que você use um gerenciador de estados e um locator para distribuir suas classes blocs/stores/controllers/ etc. Você deverá chamar manualmente a exclusão daquela dependência quando não precisar dela. Mas já pensou em simplesmente usar seu controlador e quando ele não tivesse mais sendo usado por ninguém, ele simplesmente fosse excluído da memória? É isso que GetX™ faz. Com o SmartManagement, tudo que não está sendo usado é excluído da memória e você não deve se preocupar em nada além de programar. Você terá garantia que está consumindo o mínimo de recursos necessários, sem ao menos ter criado uma lógica para isso.\n\n4- Desacoplamento real. Você já deve ter ouvido o conceito \"separar a view da lógica de negócios\". Isso não é uma peculiaridade do BLoC, MVC ou MVVM, qualquer outro padrão existente no mercado tem esse conceito. No entanto, muitas vezes esse conceito pode ser mitigado no Flutter por conta do uso do context.\nSe você precisa de context para localizar um InheritedWidget, você precisa disso na view ou passar o context por parâmetro. Eu particularmente acho essa solução muito feia e para trabalhar em equipes teremos sempre uma dependência da lógica de negócios da View. GetX™ é pouco ortodoxo com a abordagem padrão e apesar de não proibir totalmente o uso de StatefulWidgets, InitState e etc, ele tem sempre uma abordagem similar que pode ser mais limpa. Os controllers tem ciclos de vida e quando você precisa fazer uma solicitação APIREST por exemplo, você não depende de nada da view. Você pode usar onInit para iniciar a chamada http e quando os dados chegarem, as variáveis serão preenchidas. Como GetX™ é totalmente reativo (de verdade e trabalha sob streams), assim que os itens forem preenchidos, automaticamente será atualizado na view todos os widgets que usam aquela variável. Isso permite que as pessoas especialistas em UI trabalhem apenas com widgets e não precisem enviar nada para a lógica de negócio além de eventos do usuário (como clicar em um botão), enquanto as pessoas que trabalham com a lógica de negócio ficarão livres para criá-la e testá-la separadamente.  \n\n# Comunidade\n\n## Canais da comunidade\n\nGetX™ tem uma comunidade altamente ativa e útil. Se você tiver dúvidas, ou quiser alguma ajuda com relação ao uso deste framework, por favor entre em nossos canais da comunidade, sua dúvida será respondida mais rapidamente, e será o lugar mais adequado. Este repositório é exclusivo para abertura de issues e solicitação de recursos, mas fique à vontade para fazer parte da Comunidade GetX™.\n\n| **Slack (Inglês)**                                                                                                          | **Discord (Inglês e Português)**                                                                                            | **Telegram (Português)**                                                                                              |\n| :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |\n| [![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx) | [![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N) | [![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g) |\n\n## Como contribuir\n\n_Quer contribuir com o projeto? Teremos o orgulho de destacá-lo como um de nossos colaboradores. Aqui estão alguns pontos onde você pode contribuir e tornar o Get (e Flutter) ainda melhor._\n\n- Ajudando a traduzir o readme para outros idiomas.\n- Adicionando documentação ao readme (muitas funções do Get ainda não foram documentadas).\n- Escreva artigos ou faça vídeos ensinando como usar o Get (eles serão inseridos no Readme e futuramente em nosso Wiki).\n- Fazendo PRs para código/testes.\n- Incluindo novas funções.\n\nQualquer contribuição é bem-vinda!\n\n\n## Artigos e vídeos\n\n- [Dynamic Themes in 3 lines using GetX™](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Tutorial by [Rod Brown](https://github.com/RodBr). (inglês)\n- [Complete GetX™ Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI) - Route management video by Amateur Coder. (inglês)\n- [Complete GetX™ State Management](https://www.youtube.com/watch?v=CNpXbeI_slw) - State management video by Amateur Coder. (inglês)\n- [GetX™ Other Features](https://youtu.be/ttQtlX_Q0eU) - Utils, storage, bindings and other features video by Amateur Coder. (inglês)\n- [Firestore User with GetX™ | Todo App](https://www.youtube.com/watch?v=BiV0DcXgk58) - Video by Amateur Coder. (inglês)\n- [Firebase Auth with GetX™ | Todo App](https://www.youtube.com/watch?v=-H-T_BSgfOE) - Video by Amateur Coder. (inglês)\n- [The Flutter GetX™ Ecosystem ~ State Management](https://medium.com/flutter-community/the-flutter-getx-ecosystem-state-management-881c7235511d) - State management by [Aachman Garg](https://github.com/imaachman). (inglês)\n- [The Flutter GetX™ Ecosystem ~ Dependency Injection](https://medium.com/flutter-community/the-flutter-getx-ecosystem-dependency-injection-8e763d0ec6b9) - Dependency Injection by [Aachman Garg](https://github.com/imaachman). (inglês)\n- [GetX™, the all-in-one Flutter package](https://www.youtube.com/watch?v=IYQgtu9TM74) - A brief tutorial covering State Management and Navigation by Thad Carnevalli. (inglês)\n- [Build a To-do List App from scratch using Flutter and GetX™](https://www.youtube.com/watch?v=EcnqFasHf18) - UI + State Management + Storage video by Thad Carnevalli. (inglês)\n- [GetX™ Flutter Firebase Auth Example](https://medium.com/@jeffmcmorris/getx-flutter-firebase-auth-example-b383c1dd1de2) - Article by Jeff McMorris. (inglês)\n- [Flutter State Management with GetX – Complete App](https://www.appwithflutter.com/flutter-state-management-with-getx/) - by App With Flutter. (inglês)\n- [Flutter Routing with Animation using Get Package](https://www.appwithflutter.com/flutter-routing-using-get-package/) - by App With Flutter. (inglês)\n"
        },
        {
          "name": "README.ru.md",
          "type": "blob",
          "size": 60.78515625,
          "content": "![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n_Языки: Русский (этот файл), [вьетнамский](README-vi.md), [индонезийский](README.id-ID.md), [урду](README.ur-PK.md), [Английский](README.md), [Китайский](README.zh-cn.md), [Бразильский Португальский](README.pt-br.md), [Испанский](README-es.md), [Польский](README.pl.md), [Kорейский](README.ko-kr.md), [French](README-fr.md)._\n\n[![pub package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n[![popularity](https://badges.bar/get/popularity)](https://pub.dev/packages/sentry/score)\n[![likes](https://badges.bar/get/likes)](https://pub.dev/packages/get/score)\n[![pub points](https://badges.bar/get/pub%20points)](https://pub.dev/packages/get/score)\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n[![style: effective dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n[![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n[![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n<a href=\"https://github.com/Solido/awesome-flutter\">\n<img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n</a>\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n- [Про Get](#про-get)\n- [Установка](#установка)\n- [Приложение \"Счётчик\" с GetX](#приложение-счётчик-с-getx)\n- [Три столпа](#три-столпа)\n  - [Управление состоянием](#управление-состоянием)\n    - [Реактивное управление состоянием](#реактивное-управление-состоянием)\n    - [Подробнее об управлении состоянием](#подробнее-об-управлении-состоянием)\n  - [Управление маршрутами](#управление-маршрутами)\n    - [Подробнее об управлении маршрутами](#подробнее-об-управлении-маршрутами)\n  - [Внедрение зависимостей](#внедрение-зависимостей)\n    - [Подробнее о внедрении зависимостей](#подробнее-о-внедрении-зависимостей)\n- [Утилиты](#утилиты)\n  - [Интернационализация](#интернационализация)\n    - [Переводы](#переводы)\n      - [Использование переводов](#использование-переводов)\n    - [Локализация](#локализация)\n      - [Изменение локализации](#изменение-локализации)\n      - [Системная локализация](#системная-локализация)\n  - [Изменение темы](#изменение-темы)\n  - [Другие API](#другие-api)\n    - [Дополнительные глобальные настройки и ручные настройки](#дополнительные-глобальные-настройки-и-ручные-настройки)\n    - [Локальные виджеты состояния](#локальные-виджеты-состояния)\n      - [ValueBuilder](#valuebuilder)\n      - [ObxValue](#obxvalue)\n  - [Полезные советы](#полезные-советы)\n      - [GetView](#getview)\n      - [GetWidget](#getwidget)\n      - [GetxService](#getxservice)\n- [Критические изменения по сравнению с версией 2.0](#критические-изменения-по-сравнению-с-версией-20)\n- [Почему Getx?](#почему-getx)\n- [Сообщества](#сообщества)\n  - [Каналы сообщества](#каналы-сообщества)\n  - [Как внести свой вклад](#как-внести-свой-вклад)\n  - [Статьи и видео](#статьи-и-видео)\n\n# Про Get\n\n- GetX  - это сверхлегкое и мощное решение для Flutter. Оно совмещает в себе высокопроизводительное управление состоянием, интеллектуальное внедрение зависимостей, управление маршрутами быстрым и практичным способом.\n\n- GetX имеет 3 базовых принципа, являющихся приоритетом для всех ресурсов в библиотеке\n\n  - **Производительность:** GetX сфокусирован на производительности и минимальном потреблении ресурсов. Бенчмарки почти всегда не имеют значения в реальном мире, но, если Вам угодно, здесь ([бенчмарки](https://github.com/jonataslaw/benchmarks)) есть индикаторы потребления, где GetX работает лучше, чем другие подходы к управлению состоянием. Разница небольшая, но демонстрирует нашу заботу о ресурсах.\n  - **Продуктивность:** GetX использует простой и приятный синтаксис. Не имеет значения, что вы хотите сделать, всегда есть более легкий способ с GetX. Это сэкономит часы разработки и обеспечит максимальную производительность, которую может обеспечить ваше приложение.\n  - **Организация:** GetX позволяет полностью разделить представление, логику представления, бизнес-логику, внедрение зависимостей и навигацию. Вам не нужен контекст для навигации между маршрутами, поэтому вы не зависите от дерева виджетов. Вам не нужен контекст для доступа к вашим контроллерам / блокам через наследуемый виджет, поэтому вы полностью отделяете логику представления и бизнес-логику от уровня визуализации. Вам не нужно внедрять классы Controllers / Models / Blocs в дерево виджетов через мультипровайдеры, поскольку GetX использует собственную функцию внедрения зависимостей, полностью отделяя DI от его представления.\n    С GetX вы знаете, где найти каждую функцию вашего приложения, имея чистый код по умолчанию. Это, помимо упрощения обслуживания, делает возможным совместное использование модулей, что до того момента во Flutter было немыслимо.\n    BLoC был отправной точкой для организации кода во Flutter, он отделяет бизнес-логику от визуализации. Getx является естественным развитием этого, разделяя не только бизнес-логику, но и логику представления. Дополнительное внедрение зависимостей и маршрутов также разделено, и уровень данных не учитывается. Вы знаете, где все находится, и это проще, чем написать \"Hello World\".\n    GetX - это самый простой, практичный и масштабируемый способ создания высокопроизводительных приложений с помощью Flutter SDK с большой экосистемой вокруг него, которая отлично работает, прост для новичков и точен для экспертов. Он безопасен, стабилен, актуален и предлагает огромный набор встроенных API, которых нет в Flutter SDK по умолчанию.\n\n- GetX не раздут. Он имеет множество функций, которые позволяют вам начать программировать, ни о чем не беспокоясь, но каждая из этих функций находится в отдельных контейнерах и запускается только после использования. Если вы используете только управление состоянием, то будет скомпилировано только управление состоянием. Если вы используете маршрутизацию, то ничего из управления состоянием не будет скомпилировано. Вы можете воспользоваться репозиторием бенчмарка, и вы увидите, что используя только управление состоянием Get, приложение, которое скомпилировано с помощью Get, имеет меньший размер, чем приложения использующие другие пакеты для управления состоянием, потому что всё, что не используется, не будет скомпилировано в Ваш код. Таким образом каждое решение GetX было спроектировано, чтобы быть сверхлёгким. Также в этом есть и заслуга Flutter, который умеет устранять неиспользуемые ресурсы, как ни один другой фреймворк.\n\n- Getx имеет огромную экосистему, способную работать с одним и тем же кодом на Android, iOS, в Интернете, Mac, Linux, Windows и на вашем сервере.\n**С помощью [Get Server](https://github.com/jonataslaw/get_server) ваш код, созданный на веб-интерфейсе, можно повторно использовать на вашем сервере.**\n\n**Кроме того, весь процесс разработки может быть полностью автоматизирован как на сервере, так и во внешнем интерфейсе с помощью [Get CLI](https://github.com/jonataslaw/get_cli)**.\n\n**Кроме того, для дальнейшего повышения вашей продуктивности у нас есть [расширение для VSCode](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets) и [расширение для Android Studio / Intellij](https://plugins.jetbrains.com/plugin/14975-getx-snippets).**\n\n# Установка\n\nДобавьте Get в файл pubspec.yaml:\n\n```yaml\ndependencies:\n  get:\n```\n\nИмпортируйте Get в файлы, в которых планируете его использовать:\n\n```dart\nimport 'package:get/get.dart';\n```\n\n# Приложение \"Счётчик\" с GetX\n\nПроект \"Счётчик\", созданный по умолчанию для нового проекта на Flutter, имеет более 100 строк (с комментариями). Чтобы показать возможности Get, я продемонстрирую, как сделать \"Счётчик\", изменяющий состояние при каждом клике, переключении между страницами и передаче состояния между экранами. Всё это вместе с разделением бизнес логики от представления занимает ВСЕГО ЛИШЬ 26 СТРОК КОДА, ВКЛЮЧАЯ КОММЕНТАРИИ.\n\n- Шаг 1:\n  Добавьте \"Get\" перед вашим MaterialApp, превращая его в GetMaterialApp\n\n```dart\nvoid main() => runApp(GetMaterialApp(home: Home()));\n```\n\n- Примечание: это не изменяет MaterialApp, GetMaterialApp не является модифицированным MaterialApp, это просто предварительно настроенный виджет, у которого в качестве дочернего по умолчанию используется MaterialApp. Вы можете настроить это вручную, но это не обязательно. GetMaterialApp будет создавать маршруты, вводить их, вводить переводы, вводить всё, что вам нужно для навигации. Если вы используете Get только для управления состоянием или зависимостями, нет необходимости использовать GetMaterialApp. GetMaterialApp необходим для навигации, снекбаров, интернационализации, bottomSheets, диалогов и API, связанных с маршрутами и отсутствием контекста.\n- Примечание²: Этот шаг необходим только в том случае, если вы собираетесь использовать управление маршрутами (`Get.to()`, `Get.back()` и так далее). Если вы не собираетесь его использовать, то шаг 1 выполнять необязательно.\n\n- Шаг 2:\n  Создайте свой класс бизнес-логики и поместите в него все переменные, методы и контроллеры.\n  Вы можете сделать любую переменную наблюдаемой, используя простой \".obs\".\n\n```dart\nclass Controller extends GetxController{\n  var count = 0.obs;\n  increment() => count++;\n}\n```\n\n- Шаг 3:\n  Создайте свой View, используйте StatelessWidget и сэкономьте немного оперативной памяти, с Get вам больше не нужно использовать StatefulWidget.\n\n```dart\nclass Home extends StatelessWidget {\n\n  @override\n  Widget build(context) {\n    \n    // Создайте экземпляр вашего класса с помощью Get.put(), чтобы сделать его доступным для всех \"дочерних\" маршрутов.\n    final Controller c = Get.put(Controller());\n\n    return Scaffold(\n      // Используйте Obx(()=> чтобы обновить Text() как только count изменится.\n      appBar: AppBar(title: Obx(() => Text(\"Кликов: ${c.count}\"))),\n\n      // Замените 8 строк Navigator.push простым Get.to(). Вам не нужен context!\n      body: Center(child: ElevatedButton(\n              child: Text(\"Перейти к Other\"), onPressed: () => Get.to(Other()))),\n      floatingActionButton:\n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n  }\n}\n\nclass Other extends StatelessWidget {\n  // \"Попросите\" Get найти и предоставить вам ваш Controller, используемый на другой странице.\n  final Controller c = Get.find();\n\n  @override\n  Widget build(context){\n     // Получите доступ к обновленной переменной count\n     return Scaffold(body: Center(child: Text(\"${c.count}\")));\n  }\n}\n```\n\nРезультат:\n\n![](counter-app-gif.gif)\n\nЭто простой проект, но он уже дает понять, насколько мощным является Get. По мере роста вашего проекта эта разница будет становиться все более значительной.\n\nGet был разработан для работы с командами, но он упрощает работу отдельного разработчика.\n\nОптимизируйте ваши сроки, доставляйте всё вовремя без потери производительности. Get не для всех, но, если вы идентифицировали себя с предыщим предложением, Get для вас!\n\n# Три столпа\n\n## Управление состоянием\n\nВ настоящее время для Flutter есть несколько менеджеров состояний. Однако большинство из них связано с использованием ChangeNotifier для обновления виджетов, и это плохой и очень плохой подход к производительности для средних или больших приложений. Вы можете проверить в официальной документации Flutter, что [ChangeNotifier следует использовать с 1 или максимум 2 слушателями](https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html), что делает его практически непригодным для любого приложения среднего или большого размера.\n\nGet не лучше и не хуже, чем любой другой менеджер состояний, но вам следует проанализировать его, а также пункты ниже, чтобы выбрать между использованием Get в чистой форме (Vanilla), либо совместно с другим менеджером состояний.\n\nОпределенно, Get не враг любого другого менеджера состояний, потому что Get - это микрофреймворк, а не просто менеджер состояний, и его можно использовать отдельно или вместе с ними.\n\nGet имеет два разных менеджера состояний: простой менеджер состояний (мы назовем его GetBuilder) и реактивный менеджер состояний (который называется GetX).\n\n### Реактивное управление состоянием\n\nРеактивное программирование может оттолкнуть многих людей, потому что считается сложным. GetX превращает реактивное программирование в нечто довольно простое:\n\n- Вам не нужно создавать StreamControllers.\n- Вам не нужно создавать StreamBuilder для каждой переменной.\n- Вам не нужно создавать класс для каждого состояния.\n- Вам не нужно создавать геттер начального значения.\n\nРеактивное программирование с Get так же просто, как использование setState.\n\nПредставим, что у вас есть переменная name и вы хотите, чтобы каждый раз, когда вы её изменяете, все виджеты, которые её используют, менялись автоматически.\n\nЭто ваша переменная:\n\n```dart\nvar name = 'Джонатас Борхес';\n```\n\nЧтобы сделать его наблюдаемым, вам просто нужно добавить в конец \".obs\":\n\n```dart\nvar name = 'Джонатас Борхес'.obs;\n```\n\nА в пользовательском интерфейсе, если вы хотите отображать это значение и обновлять экран при изменении значений, просто сделайте следующее:\n\n```dart\nObx(() => Text(\"${controller.name}\"));\n```\n\nВот и всё. Это _так_ просто.\n\n### Подробнее об управлении состоянием\n\n**Более подробное объяснение управления состоянием [здесь](./documentation/ru_RU/state_management.md). Там вы увидите больше примеров, а также разницу между простым менеджером состояния и реактивным менеджером состояния.**\n\nВы получите хорошее представление о мощности GetX.\n\n## Управление маршрутами\n\nЕсли вы собираетесь использовать маршруты / снекбары / диалоги / bottomsheets без контекста, GetX отлично подойдёт вам, просто посмотрите:\n\nДобавьте \"Get\" перед MaterialApp, превратив его в GetMaterialApp.\n\n```dart\nGetMaterialApp( // Ранее: MaterialApp(\n  home: MyHome(),\n)\n```\n\nПерейдите на новый экран:\n\n```dart\n\nGet.to(NextScreen());\n```\n\nПерейдите на новый экран с именем. Более подробную информацию об именованных маршрутах смотрите [здесь](./documentation/ru_RU/route_management.md#navigation-with-named-routes)\n\n```dart\n\nGet.toNamed('/details');\n```\n\nЗакрыть снекбар, диалог, bottomsheets, или что-то иное, что вы обычно закрывали с помощью Navigator.pop(context);\n\n```dart\nGet.back();\n```\n\nДля перехода к следующему экрану без возможности вернуться к предыдущему экрану (для использования в SplashScreens, экранах входа и т. д.)\n\n```dart\nGet.off(NextScreen());\n```\n\nДля перехода к следующему экрану и отмены всех предыдущих маршрутов (полезно в корзинах для покупок, опросах и тестах)\n\n```dart\nGet.offAll(NextScreen());\n```\n\nЗаметили, что вам не нужно было использовать контекст, чтобы делать что-либо из этого? Это одно из самых больших преимуществ использования Get. Благодаря этому вы можете без проблем выполнять все эти методы из класса контроллера.\n\n### Подробнее об управлении маршрутами\n\n**Get работает с именованными маршрутами, а также предлагает более низкий уровень контроля над вашими маршрутами! [Здесь](./documentation/ru_RU/route_management.md) есть подробная документация.**\n\n## Внедрение зависимостей\n\nGet имеет простой и мощный менеджер зависимостей, который позволяет вам получить тот же класс, что и ваш BLoC или контроллер, всего одной строкой кода, без Provider context, без InheritedWidget:\n\n```dart\nController controller = Get.put(Controller()); // Вместо Controller controller = Controller();\n```\n\n- Примечание: Если вы используете Get State Manager, обратите больше внимания на API привязок, который упростит подключение вашего представления к контроллеру.\n\nВместо того, чтобы создавать экземпляр вашего класса внутри класса, который вы используете, вы создаете его в экземпляре Get, что сделает его доступным во всем приложении. Таким образом, вы можете использовать свой контроллер (или BLoC) в обычном режиме.\n\n**Совет:** Управление зависимостями Get не связано с другими частями пакета, поэтому, если, например, ваше приложение уже использует менеджер состояний (любой, не имеет значения), вам не нужно все это переписывать, вы можете использовать это внедрение зависимостей без проблем.\n\n```dart\ncontroller.fetchApi();\n```\n\nПредставьте, что вы прошли через множество маршрутов и вам нужны данные, которые остались в вашем контроллере, вам понадобится менеджер состояний в сочетании с Provider или Get_it, верно? Только не с Get. Вам просто нужно попросить Get «найти» ваш контроллер, никаких дополнительных зависимостей вам не потребуется:\n\n```dart\nController controller = Get.find();\n// Да, это выглядит как Магия! Get найдет ваш controller и доставит его вам. У вас может быть миллион созданных контроллеров, и Get всегда найдет нужный.\n```\n\nИ тогда вы сможете восстановить данные вашего контроллера, которые были там получены:\n\n```dart\nText(controller.textFromApi);\n```\n\n### Подробнее о внедрении зависимостей\n\n**Более подробное объяснение управления зависимостями [здесь](./documentation/ru_RU/dependency_management.md)**\n\n# Утилиты\n\n## Интернационализация\n\n### Переводы\n\nПереводы хранятся в виде карты пар \"ключ-значение\". Чтобы добавить собственные переводы, создайте класс и расширьте `Translations`.\n\n```dart\nimport 'package:get/get.dart';\n\nclass Messages extends Translations {\n  @override\n  Map<String, Map<String, String>> get keys => {\n        'en_US': {\n          'hello': 'Hello World',\n        },\n        'de_DE': {\n          'hello': 'Hallo Welt',\n        }\n      };\n}\n```\n\n#### Использование переводов\n\nПросто добавьте `.tr` к указанному ключу, и он будет переведен с использованием текущего значения `Get.locale` и `Get.fallbackLocale`.\n\n```dart\nText('title'.tr);\n```\n\n### Локализация\n\nПередайте параметры в `GetMaterialApp`, чтобы определить языковой стандарт и переводы.\n\n```dart\nreturn GetMaterialApp(\n    translations: Messages(), // ваши переводы\n    locale: Locale('en', 'US'), // перевод будет осуществлен в этой локализации\n    fallbackLocale: Locale('en', 'UK'), // установите резервную локализацию на случай если будет выбрана невалидный локализация.\n);\n```\n\n#### Изменение локализации\n\nВызовите `Get.updateLocale(locale)`, чтобы обновить локализацию. Затем переводы автоматически используют новый языковой стандарт.\n\n```dart\nvar locale = Locale('en', 'US');\nGet.updateLocale(locale);\n```\n\n#### Системная локализация\n\nЧтобы узнать системную локализацию, вам следует использовать `window.locale`.\n\n```dart\nimport 'dart:ui' as ui;\n\nreturn GetMaterialApp(\n    locale: ui.window.locale,\n);\n```\n\n## Изменение темы\n\nПожалуйста, не используйте виджет более высокого уровня, чем `GetMaterialApp`, для его обновления. Это может вызвать повторяющиеся ключи. Многие люди привыкли к старому подходу к созданию виджета «ThemeProvider» только для того, чтобы изменить тему вашего приложения, а это НЕ требуется с GetX ™.\n\nВы можете создать свою собственную тему и просто добавить ее в `Get.changeTheme` без повторяющегося кода:\n\n```dart\nGet.changeTheme(ThemeData.light());\n```\n\nЕсли вы хотите создать что-то вроде кнопки, которая изменяет тему, вы можете объединить для этого два API **GetX ™**:\n\n- API, который проверяет, используется ли темная тема.\n- И API смены темы.\n\nВы можете просто поместить это в `onPressed`:\n\n```dart\nGet.changeTheme(Get.isDarkMode? ThemeData.light(): ThemeData.dark());\n```\n\nКогда `.darkmode` активен, он переключится на _light theme_, и когда _light theme_ станет активной, он изменится на _dark theme_.\n\n## Другие API\n\n```dart\n// получить текущие аргументы текущего экрана\nGet.arguments\n\n// получить аргументы предыдущего маршрута\nGet.previousArguments\n\n// получить имя предыдущего маршрута\nGet.previousRoute\n\n// получить чистый маршрут, например, чтобы узнать: rawRoute.isFirst()\nGet.rawRoute\n\n// получить доступ к Rounting API из GetObserver\nGet.routing\n\n// проверить, открыт ли снекбар\nGet.isSnackbarOpen\n\n// открыт ли диалог\nGet.isDialogOpen\n\n// открыт ли bottomsheets\nGet.isBottomSheetOpen\n\n// удалить один маршрут\nGet.removeRoute()\n\n// возвращаться назад, пока данный предикат не выполнится\nGet.until()\n\n// идти вперед, удалив предыдущие маршруты, пока данный предикат не выполнится\nGet.offUntil()\n\n// перейти к следующему именованному маршруту, удалив предыдущие маршруты, пока данный предикат не выполнится\nGet.offNamedUntil()\n\n// проверить на какой платформе работает приложение\nGetPlatform.isAndroid\nGetPlatform.isIOS\nGetPlatform.isMacOS\nGetPlatform.isWindows\nGetPlatform.isLinux\nGetPlatform.isFuchsia\n\n// проверить тип устройства\nGetPlatform.isMobile\nGetPlatform.isDesktop\n// В вебе все платформы поддерживаются независимо!\n// Можно узнать, работает ли приложение сейчас в браузере\n// и на Windows, и на iOS, и на OSX, и на Android и так далее\nGetPlatform.isWeb\n\n\n// Эквивалент : MediaQuery.of(context).size.height,\n// но неизменяемый.\nGet.height\nGet.width\n\n// Текущий контекст навигации\nGet.context\n\n// Получить контекст показанного снекбара/диалога/bottomsheets в любом месте вызова.\nGet.contextOverlay\n\n// Внимание: методы ниже являются расширениями класса BuildContext.\n// Поскольку доступ к контексту есть в любом месте из вашего UI,\n// вы можете использовать расширения в любом месте UI кода\n\n// Если вам нужна изменяемая высота/ширина (например, настольное или браузерное окно, размер которого можно изменить), вам нужно использовать context\ncontext.width\ncontext.height\n\n// Дает возможность определить половину экрана, треть и так далее.\n// Полезно для отзывчивых приложений.\n// param dividedBy (double) optional - default: 1\n// param reducedBy (double) optional - default: 0\ncontext.heightTransformer()\ncontext.widthTransformer()\n\n/// Схоже с MediaQuery.of(context).size\ncontext.mediaQuerySize()\n\n/// Схоже с MediaQuery.of(context).padding\ncontext.mediaQueryPadding()\n\n/// Схоже с MediaQuery.of(context).viewPadding\ncontext.mediaQueryViewPadding()\n\n/// Схоже с MediaQuery.of(context).viewInsets;\ncontext.mediaQueryViewInsets()\n\n/// Схоже с MediaQuery.of(context).orientation;\ncontext.orientation()\n\n/// Проверить, в горизонтальном ли режиме устройство\ncontext.isLandscape()\n\n/// Проверить, в вертикальном ли режиме устройство\ncontext.isPortrait()\n\n/// Схоже с to MediaQuery.of(context).devicePixelRatio;\ncontext.devicePixelRatio()\n\n/// Схоже с MediaQuery.of(context).textScaleFactor;\ncontext.textScaleFactor()\n\n/// Получить shortestSide экрана\ncontext.mediaQueryShortestSide()\n\n/// Вернет True, если ширина больше 800\ncontext.showNavbar()\n\n/// Вернет True, если меньшая сторона меньше 600p\ncontext.isPhone()\n\n/// Вернет True, если меньшая сторона больше 600p\ncontext.isSmallTablet()\n\n/// Вернет True, если меньшая сторона больше 720p\ncontext.isLargeTablet()\n\n/// Вернет True, если текущее устройство — Планшет\ncontext.isTablet()\n\n/// Возвращает value<T> в зависимости от размера экрана\n/// Можно устанавливать значения для:\n/// watch: Если меньшая сторона меньше 300\n/// mobile: Если меньшая сторона меньше 600\n/// tablet: Если меньшая сторона меньше 1200\n/// desktop: Если ширина больше 1200\ncontext.responsiveValue<T>()\n```\n\n### Дополнительные глобальные настройки и ручные настройки\n\nGetMaterialApp настраивает все за вас, но если вы хотите настроить Get вручную.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver()],\n);\n```\n\nВы также сможете использовать собственное промежуточное ПО в `GetObserver`, это ни на что не повлияет.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [\n    GetObserver(MiddleWare.observer) // Here\n  ],\n);\n```\n\nВы можете создать _Глобальные Настройки_ Для `Get`. Просто добавьте `Get.config` в ваш код прежде чем нажимать на любой из маршрутов.\nИли сделайте это прямо в `GetMaterialApp`\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  defaultTransition: Transition.fade,\n  opaqueRoute: Get.isOpaqueRouteDefault,\n  popGesture: Get.isPopGestureEnable,\n  transitionDuration: Get.defaultDurationTransition,\n  defaultGlobalState: Get.defaultGlobalState,\n);\n\nGet.config(\n  enableLog = true,\n  defaultPopGesture = true,\n  defaultTransition = Transitions.cupertino\n)\n```\n\nПри желании, вы сможете перенаправить все сообщения из `Get`.\nЕсли вы хотите использовать свой любимый пакет для логирования и собирать логи там:\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  logWriterCallback: localLogWriter,\n);\n\nvoid localLogWriter(String text, {bool isError = false}) {\n  // передайте сообщение вашей любимой log-библиотеке\n  // но учитывайте, что даже если enableLog: false, сообщения все равно будут передаваться сюда\n  // узнать значение этого флага можно с помощью GetConfig.isLogEnable\n}\n\n```\n\n### Локальные виджеты состояния\n\nЭти виджеты позволяют управлять одним значением, сохраняя состояние эфемерным и локальным.\nУ нас есть варианты для Reactive и Simple.\nНапример, вы можете использовать их для переключения obscureText в `TextField`, возможно, для создания кастомного ExpandablePanel или, возможно, для изменения текущего индекса в `BottomNavigationBar` при изменении содержимого body в `Scaffold`.\n\n#### ValueBuilder\n\nУпрощение `StatefulWidget` который работает с вызовом `.setState` принимающим обновленное значение.\n\n```dart\nValueBuilder<bool>(\n  initialValue: false,\n  builder: (value, updateFn) => Switch(\n    value: value,\n    onChanged: updateFn, // такая же сигнатура! Вы можете использовать ( newValue ) => updateFn( newValue )\n  ),\n  // Если нужно вызвать что-то вне метода builder\n  onUpdate: (value) => print(\"Значение обновлено: $value\"),\n  onDispose: () => print(\"Виджет удален\"),\n),\n```\n\n#### ObxValue\n\nПохож на [`ValueBuilder`](#valuebuilder), но это реактивная версия, вы передаёте Rx экземпляр (помните волшебный .obs?) и\nавтоматически обновляетесь... разве это не великолепно?\n\n```dart\nObxValue((data) => Switch(\n        value: data.value,\n        onChanged: data, // У Rx есть _callable_ функция! Вы можете использовать (flag) => data.value = flag,\n    ),\n    false.obs,\n),\n```\n\n## Полезные советы\n\n`.obs`ervables (наблюдатели) (также известные как Rx-типы) имеют широкий спектр внутренних методов и операторов\n\n> Очень распространено _мнение_, что свойство с `.obs` **ЯВЛЯЕТСЯ** действительным значением... но не ошибайтесь!\n> Мы избегаем объявления типа переменной, потому что компилятор Dart достаточно умен, и\n> код выглядит чище, но:\n\n```dart\nvar message = 'Привет, мир'.obs;\nprint( 'Тип \"$message\" — ${message.runtimeType}');\n```\n\nДаже если `message` _выводит_ значение String, его тип - **RxString**!\n\nИтак, вы не сможете сделать `message.substring( 0, 4 )`.\nВы должны получить доступ к реальному `value` внутри _observable_:\nСамый \"используемый способ\" это `.value`, но, знаете ли вы, что вы также можете использовать ...\n\n```dart\nfinal name = 'GetX'.obs;\n// \"обновляет\" поток только если значение отличается от текущего.\nname.value = 'Хей';\n\n// Все свойства Rx являются \"вызываемыми\" и возвращают новые значения.\n// но это не работает с `null`: UI не будет перестроен.\nname('Привет');\n\n// как геттер, напечатает 'Привет'.\nname() ;\n\n/// числа:\n\nfinal count = 0.obs;\n\n// Вы можете использовать все неизменяемые операции с числами!\ncount + 1;\n\n// Осторожно! Это можно использовать только если `count` не final, а var\ncount += 1;\n\n// Сравнения так же работают:\ncount > 2;\n\n/// логические:\n\nfinal flag = false.obs;\n\n// переключает значение между true/false\nflag.toggle();\n\n\n/// все типы:\n\n// обнуляет значение переменной `value`.\nflag.nil();\n\n// Все toString(), toJson() операции применяются к `value`\nprint( count ); // вызывает `toString()` внутри RxInt\n\nfinal abc = [0,1,2].obs;\n// Преобразует значение в json массив, выводит RxList\n// Json поддерживается всеми Rx типами!\nprint('json: ${jsonEncode(abc)}, тип: ${abc.runtimeType}');\n\n// RxMap, RxList и RxSet являются особенными Rx типами: они расширяют нативные типы.\n// Но вы можете работать со списком как и с обычным списком, хоть и реактивным!\nabc.add(12); // добавлеет 12 в список, and ОБНОВЛЯЕТ поток.\nabc[3]; // как списки, возвращает значение с индексом 3.\n\n\n// Сравнение равенства работает с Rx и с его value, но хэш код всегда берется у value\nfinal number = 12.obs;\nprint( number == 12 ); // печатает true\n\n/// Кастомные Rx Модели:\n\n// toJson(), toString() передаются child, так что вы можете перегрузить эти методы в нем, и вызвать print напрямую.\n\nclass User {\n    String name, last;\n    int age;\n    User({this.name, this.last, this.age});\n\n    @override\n    String toString() => '$name $last, возраст: $age';\n}\n\nfinal user = User(name: 'Джон', last: 'Доу', age: 33).obs;\n\n// `user` – \"реактивный\", но его свойства – НЕТ!\n// Так что если мы обновим что-либо внутри user...\nuser.value.name = 'Рой';\n// Виджет перестроен не будет!\n// `Rx` не знает, изменили ли вы что-то у user.\n// Так что для кастомных классов вам нужно явно \"уведомлять\" об изменении.\nuser.refresh();\n\n// или мы можем использовать метод `update()`!\nuser.update((value){\n  value.name='Рой';\n});\n\nprint( user );\n```\n\n#### GetView\n\nЯ люблю этот виджет, он такой простой, но такой полезный!\n\nЭто `const Stateless` виджет, который имеет геттер `controller` для зарегистрированного `Controller`, вот и всё.\n\n```dart\n class AwesomeController extends GetxController {\n   final String title = 'Моя Удивительная View';\n }\n\n  // ВСЕГДА передавайте `Тип` вашего контроллера!\n class AwesomeView extends GetView<AwesomeController> {\n   @override\n   Widget build(BuildContext context) {\n     return Container(\n       padding: EdgeInsets.all(20),\n       child: Text( controller.title ), // просто вызовите `controller.что-то`\n     );\n   }\n }\n```\n\n#### GetWidget\n\nБольшинство людей понятия не имеют об этом виджете или путаются при его применении.\nВариант его использования редок, но конкретен: он кэширует Controller.\nПоэтому из-за _cache_, он не может быть `const Stateless`.\n\n> Итак, когда вам нужно «кэшировать» контроллер?\n\nВ случаях использования другой \"не распространённой\" фичи **GetX**: `Get.create()`.\n\n`Get.create(()=>Controller())` будет создавать новый `Controller` каждый раз при вызове\n`Get.find<Controller>()`,\n\nЭто тот самый случай, когда `GetWidget` блистает... поскольку вы можете использовать его, например, для хранения списка элементов Todo. Итак, если виджет будет «перестроен», он сохранит тот же экземпляр контроллера.\n\n#### GetxService\n\nЭтот класс похож на `GetxController`, у него такой же жизненный цикл ( `onInit()`, `onReady()`, `onClose()`).\nНо внутри нет никакой «логики». Он просто уведомляет систему **GetX** Dependency Injection о том, что этот подкласс **нельзя** удалить из памяти.\n\nТак что очень полезно держать ваши «Сервисы» всегда доступными и активными с помощью `Get.find()`. Например:\n`ApiService`, `StorageService`, `CacheService`.\n\n```dart\nFuture<void> main() async {\n  await initServices(); /// ПОДОЖДИТЕ ИНИЦИАЛИЗАЦИЮ СЕРВИСОВ.\n  runApp(SomeApp());\n}\n\n/// Умным решением будет проинициализировать сервисы перед вызовом runApp,\n/// поскольку вы можете контроллировать процесс инициализации\n/// (может, вам нужно загрузить конфигурацию Темы, ключи API, язык, определенный пользователем...\n/// Загружайте SettingService прежде чем запускать ApiService.\n/// Таким образом GetMaterialApp() принимает параметры напрямую, и ему не нужно будет перезагружаться\nvoid initServices() async {\n  print('запуск сервисов ...');\n  /// Здесь вы инициализируете get_storage, hive, shared_pref,\n  /// или что-либо другое асинхронное.\n  await Get.putAsync(() => DbService().init());\n  await Get.putAsync(SettingsService()).init();\n  print('Все сервисы запущены...');\n}\n\nclass DbService extends GetxService {\n  Future<DbService> init() async {\n    print('$runtimeType задержка 2 секунды');\n    await 2.delay();\n    print('$runtimeType готов!');\n    return this;\n  }\n}\n\nclass SettingsService extends GetxService {\n  void init() async {\n    print('$runtimeType задержка 1 секунду');\n    await 1.delay();\n    print('$runtimeType готов!');\n  }\n}\n\n```\n\nЕдинственный способ удалить `GetxService` - использовать `Get.reset()`,  который похож на «горячую перезагрузку» вашего приложения. Так что помните, если вам нужен постоянный экземпляр класса в течение всего жизненного цикла вашего приложения, используйте `GetxService`.\n\n# Критические изменения по сравнению с версией 2.0\n\n1- Rx типы:\n\n| До      | После      |\n| ------- | ---------- |\n| StringX | `RxString` |\n| IntX    | `RxInt`    |\n| MapX    | `RxMap`    |\n| ListX   | `RxList`   |\n| NumX    | `RxNum`    |\n| DoubleX | `RxDouble` |\n\nRxController и GetBuilder теперь объединены, вам больше не нужно запоминать, какой контроллер вы хотите использовать, просто используйте GetxController, он будет работать как для простого управления состоянием, так и для реактивного.\n\n2- NamedRoutes\nДо:\n\n```dart\nGetMaterialApp(\n  namedRoutes: {\n    '/': GetRoute(page: Home()),\n  }\n)\n```\n\nСейчас:\n\n```dart\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page: () => Home()),\n  ]\n)\n```\n\nДля чего это изменение?\nЧасто может потребоваться решить, какая страница будет отображаться с помощью параметра или токена входа, предыдущий подход был негибким, так как он не позволял этого.\nВставка страницы в функцию значительно снизила потребление оперативной памяти, поскольку маршруты не будут выделяться в памяти с момента запуска приложения, а также позволил использовать такой подход:\n\n```dart\n\nGetStorage box = GetStorage();\n\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page:(){\n      return box.hasData('token') ? Home() : Login();\n    })\n  ]\n)\n```\n\n# Почему Getx?\n\n1- Много раз после обновления Flutter многие из ваших пакетов ломались. Иногда случаются ошибки компиляции, часто возникают ошибки, на которые до сих пор нет ответов, и разработчику необходимо знать, откуда возникла ошибка, отслеживать ошибку, только затем попытаться открыть проблему в соответствующем репозитории и увидеть, как проблема решена. Get централизует основные ресурсы для разработки (управление состоянием, зависимостями и маршрутами), позволяя вам добавить один пакет в свой pubspec и начать работу. После обновления Flutter единственное, что вам нужно сделать, это обновить зависимость Get и приступить к работе. Get также решает проблемы совместимости. Как часто бывало, что одна версия пакета несовместима с другой, потому что одна использует зависимость в одной версии, а другая - в другой? Это не проблема при использовании Get, поскольку все находится в одном пакете и полностью совместимо.\n\n2- Flutter - это просто, Flutter - это невероятно, но у Flutter все еще некоторый шаблонный код, который может быть нежелательным для большинства разработчиков, например `Navigator.of(context).push (context, builder [...]`. Get упрощает разработку. Вместо того, чтобы писать 8 строк кода для вызова маршрута, вы можете просто сделать это: `Get.to(Home())` и всё готово, вы перейдёте на следующую страницу. Динамические URL-адреса - это действительно болезненная вещь, которую нужно решать во Flutter в настоящее время, а с GetX это элементарно. Управление состояниями во Flutter и управление зависимостями также вызывает много споров, поскольку в pub есть сотни паттернов. Но нет ничего проще, чем добавить «.obs» в конец вашей переменной и поместить ваш виджет внутри Obx, и всё, все обновления этой переменной будут автоматически обновляться на экране.\n\n3- Лёгкость, не беспокоясь о производительности. Производительность Flutter уже потрясающая, но представьте, что вы используете диспетчер состояний и локатор для распределения классов блоков / хранилищ / контроллеров / и других классов. Вам придётся вручную вызывать исключение этой зависимости, когда она вам не нужна. Но вы когда-нибудь думали о том, чтобы просто использовать свой контроллер, и когда он больше никем не использовался, он просто был бы удален из памяти? Это то, что делает GetX. Благодаря SmartManagement всё, что не используется, удаляется из памяти, и вам не нужно беспокоиться ни о чем, кроме программирования. Вы будете уверены, что потребляете минимум необходимых ресурсов, даже не создав для этого логики.\n\n4- Действительное разделение. Вы могли слышать о концепции разделения представления от бизнес логики. Это не исключительная особенность BLoC, MVC, MVVM и тд, любой стандарт реализует эту концепцию. Однако во Flutter возможно ослабление этой концепции из-за необходимости использования контекста.\nЕсли вам нужен контекст для поиска InheritedWidget, он вам нужен в представлении, либо нужно передать контекст как параметр. Мы считаем это решение очень уродливым, и для работы в команде мы всегда будем зависеть от логики представления (View). Getx - необычный подход со стандартным доступом, который хоть и не запрещает использование StatefulWidgets, InitState, и т.д., всегда имеет более чистый аналог. У контроллеров есть жизненные циклы, и когда вам нужно сделать, например, запрос APIREST, вы не зависите ни от чего в представлении. Вы можете использовать onInit для инициирования http-вызова, и когда данные поступят, переменные будут заполнены. Поскольку GetX полностью реактивен (действительно реактивен и работает с потоками), после заполнения элементов все виджеты, использующие эту переменную, будут автоматически обновлены в представлении. Это позволяет людям с опытом работы с пользовательским интерфейсом работать только с виджетами и не отправлять в бизнес-логику ничего, кроме пользовательских событий (например, нажатия кнопки), в то время как люди, работающие с бизнес-логикой, смогут создавать и тестировать бизнес-логику отдельно.\n\nЭта библиотека всегда будет обновляться и реализовывать новые функции. Не стесняйтесь предлагать PR.\n\n# Сообщества\n\n## Каналы сообщества\n\nУ GetX очень активное и готовое к взаимовыручке сообщество. Если у вас есть вопросы или вы хотите получить какую-либо помощь относительно использования этого фреймворка, присоединяйтесь к нашим каналам сообщества, на ваш вопрос ответят быстро. Этот репозиторий предназначен исключительно для открытия проблем и запроса ресурсов, но не стесняйтесь быть частью сообщества GetX.\n\n| **Slack**                                                                                                                   | **Discord**                                                                                                                 | **Telegram**                                                                                                          |\n| :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |\n| [![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx) | [![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N) | [![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g) |\n\n## Как внести свой вклад\n\n_Хотите внести свой вклад в проект? Вы будем рады отметить вас как одного из наших соавторов. Вот несколько направлений, где вы можете сделать Get (и Flutter) лучше._\n\n- Помощь в переводе readme на другие языки.\n- Добавление документации в readme (многие функции Get еще не задокументированы).\n- Напишите статью или сделайте видео, обучающие использованию Get (они будут вставлены в Readme и в будущем в нашу Wiki).\n- Предложите PRs для кода/тестов.\n- Новые фичи.\n\nПриветствуется любой вклад!\n\n## Статьи и видео\n\n- [Dynamic Themes in 3 lines using GetX™](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Tutorial by [Rod Brown](https://github.com/RodBr).\n- [Complete GetX™ Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI) - Route management video by Amateur Coder.\n- [Complete GetX State Management](https://www.youtube.com/watch?v=CNpXbeI_slw) - State management video by Amateur Coder.\n- [GetX™ Other Features](https://youtu.be/ttQtlX_Q0eU) - Utils, storage, bindings and other features video by Amateur Coder.\n- [Firestore User with GetX | Todo App](https://www.youtube.com/watch?v=BiV0DcXgk58) - Video by Amateur Coder.\n- [Firebase Auth with GetX | Todo App](https://www.youtube.com/watch?v=-H-T_BSgfOE) - Video by Amateur Coder.\n- [The Flutter GetX™ Ecosystem ~ State Management](https://medium.com/flutter-community/the-flutter-getx-ecosystem-state-management-881c7235511d) - State management by [Aachman Garg](https://github.com/imaachman).\n- [GetX, the all-in-one Flutter package](https://www.youtube.com/watch?v=IYQgtu9TM74) - A brief tutorial covering State Management and Navigation by Thad Carnevalli.\n- [Build a To-do List App from scratch using Flutter and GetX](https://www.youtube.com/watch?v=EcnqFasHf18) - UI + State Management + Storage video by Thad Carnevalli.\n- [GetX Flutter Firebase Auth Example](https://medium.com/@jeffmcmorris/getx-flutter-firebase-auth-example-b383c1dd1de2) - Article by Jeff McMorris.\n"
        },
        {
          "name": "README.tr-TR.md",
          "type": "blob",
          "size": 54.6669921875,
          "content": "![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n[![pub package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n[![popularity](https://badges.bar/get/popularity)](https://pub.dev/packages/sentry/score)\n[![likes](https://badges.bar/get/likes)](https://pub.dev/packages/get/score)\n[![pub points](https://badges.bar/get/pub%20points)](https://pub.dev/packages/get/score)\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n[![style: effective dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n[![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n[![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n<a href=\"https://github.com/Solido/awesome-flutter\">\n<img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n</a>\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n\n<div align=\"center\">\n\n**Languages:**\n\n  \n[![English](https://img.shields.io/badge/Language-English-blueviolet?style=for-the-badge)](README.md)\n[![Vietnamese](https://img.shields.io/badge/Language-Vietnamese-blueviolet?style=for-the-badge)](README-vi.md)\n[![Indonesian](https://img.shields.io/badge/Language-Indonesian-blueviolet?style=for-the-badge)](README.id-ID.md)\n[![Urdu](https://img.shields.io/badge/Language-Urdu-blueviolet?style=for-the-badge)](README.ur-PK.md)\n[![Chinese](https://img.shields.io/badge/Language-Chinese-blueviolet?style=for-the-badge)](README.zh-cn.md)\n[![Portuguese](https://img.shields.io/badge/Language-Portuguese-blueviolet?style=for-the-badge)](README.pt-br.md)\n[![Spanish](https://img.shields.io/badge/Language-Spanish-blueviolet?style=for-the-badge)](README-es.md)\n[![Russian](https://img.shields.io/badge/Language-Russian-blueviolet?style=for-the-badge)](README.ru.md)\n[![Polish](https://img.shields.io/badge/Language-Polish-blueviolet?style=for-the-badge)](README.pl.md)\n[![Korean](https://img.shields.io/badge/Language-Korean-blueviolet?style=for-the-badge)](README.ko-kr.md)\n[![French](https://img.shields.io/badge/Language-French-blueviolet?style=for-the-badge)](README-fr.md)\n[![Japanese](https://img.shields.io/badge/Language-Japanese-blueviolet?style=for-the-badge)](README.ja-JP.md)\n[![Turkish](https://img.shields.io/badge/Language-Turkish-blueviolet?style=for-the-badge)](README.tr-TR.md)\n\n</div>\n\n- [Get Hakkında](#get-hakkında)\n- [Kurulum](#kurulum)\n- [GetX ile Sayaç Uygulaması](#getx-ile-sayaç-uygulaması)\n- [Üç Temel Kavram](#üç-temel-kavram)\n  - [State Management (Durum Yönetimi)](#state-management-durum-yönetimi)\n    - [Reactive State Manager (Reaktif Durum Yönetimi)](#reactive-state-manager-reaktif-durum-yönetimi)\n    - [State Management Hakkında Daha Fazla Bilgi](#state-management-hakkında-daha-fazla-bilgi)\n  - [Route Management (Rota Yönetimi)](#route-management-rota-yönetimi)\n    - [Route Management Hakkında Daha Fazla Bilgi](#route-management-hakkında-daha-fazla-bilgi)\n  - [Dependency Management (Bağımlılık Yönetimi)](#dependency-management-bağımlılık-yönetimi)\n    - [Dependency Management Hakkında Daha Fazla Bilgi](#dependency-management-hakkında-daha-fazla-bilgi)\n- [Utils](#utils)\n  - [Internationalization (Uluslararasılaştırma)](#internationalization-uluslararasılaştırma)\n    - [Translations (Çeviriler)](#translations-çeviriler)\n      - [Translations Kullanımı](#translations-kullanımı)\n    - [Locales (Yerel Ayarlar)](#locales-yerel-ayarlar)\n      - [Locale Değiştirme](#locale-değiştirme)\n      - [System locale (Yerel Sistem Ayarları)](#system-locale-yerel-sistem-ayarları)\n  - [Tema Değiştirme](#tema-değiştirme)\n  - [GetConnect](#getconnect)\n    - [Varsayılan Ayarlar](#varsayılan-ayarlar)\n    - [Özel Ayarlarlamalar](#özel-ayarlamalar)\n  - [GetPage Middleware](#getpage-middleware)\n    - [Priority (Öncelik)](#priority-öncelik)\n    - [Redirect (Yönlendirme)](#redirect-yönlendirme)\n    - [onPageCalled](#onpagecalled)\n    - [OnBindingsStart](#onbindingsstart)\n    - [OnPageBuildStart](#onpagebuildstart)\n    - [OnPageBuilt](#onpagebuilt)\n    - [OnPageDispose](#onpagedispose)\n  - [Advanced APIs (Gelişmiş API'ler)](#advanced-apis-gelişmiş-apiler)\n    - [Opsiyonel Genel Ayarlar ve Manuel Ayarlamalar](#opsiyonel-genel-ayarlar-ve-manuel-ayarlamalar)\n    - [Local State Widgets (Yerel Durum Widgetları)](#local-state-widgets-yerel-durum-widgetları)\n      - [ValueBuilder](#valuebuilder)\n      - [ObxValue](#obxvalue)\n  - [Faydalı İpuçları](#faydalı-ipuçları)\n    - [GetView](#getview)\n    - [GetResponsiveView](#getresponsiveview)\n      - [Nasıl Kullanılır?](#nasıl-kullanılır)\n    - [GetWidget](#getwidget)\n    - [GetxService](#getxservice)\n- [2.0 İle Gelen Büyük Değişiklikler](#20-ile-gelen-büyük-değişiklikler)\n- [Neden Getx?](#neden-getx)\n- [Topluluk](#topluluk)\n  - [Topluluk Kanalları](#topluluk-kanalları)\n  - [Nasıl katkıda bulunulur?](#nasıl-katkıda-bulunulur)\n  - [Makaleler ve Videolar](#makaleler-ve-videolar)\n\n# Get Hakkında\n\n- GetX, Flutter için oldukça basit ve güçlü bir çözüm yoludur. Yüksek performanslı state managment (durum yönetimi), yetenekli dependency injection (bağımlılık enjeksiyonu) ve route management'ı (rota yönetimi) hızlı ve pratik şekilde bir araya getirir.\n\n- GetX'in 3 temel ilkesi vardır. Bu ilkeler kütüphanedeki tüm kaynaklar için önemlidir: **ÜRETKENLİK, PERFORMANS VE ORGANİZASYON.**\n\n  - **PERFORMANS:** GetX, performansa ve kaynakların minimum düzeyde tüketimine odaklanmıştır. GetX, Streams ya da ChangeNotifier kullanmaz.\n\n  - **ÜRETKENLİK:** GetX kolay ve keyifli bir syntax (yazım kuralları) kullanır. Ne yapmak istersen iste GetX'de her zaman kolay bir çözüm yolu vardır. Saatlerce süren geliştirmeden tasarruf etmeyi ve uygulanın size sağladığı  performansı maksimum seviyede kullanmayı mümkün kılar.\n\n    Normalde geliştirici, controller'ları hafızadan kaldırmakla ilgilenmelidir. GetX ile bunu yapmaya gerek kalmaz çünkü varsayılan olarak kaynaklar kullanılmadığı zaman hafızadan kendiliğinden kaldırılır. Eğer hafızada tutmak istiyorsanız, dependency içinde \"permanent: true\" olarak tanımlanmanız gerekmektedir. Bu şekilde hem zaman tasarrufu hem de hafızadaki gereksiz dependency'lerin oluşturabileceği riskler azaltmış olur. Dependency yüklemesi varsayılan olarak lazy'dir (tembeldir).\n\n  - **ORGANİZASYON:**  GetX, presentation logic'i (sunum mantığını, business logic'i (iş mantığını), dependency injection'ı, navigasyonu View'dan tamamen ayırmayı sağlar. Route'lar arasında navigasyon için context'e gerek duyulmaz bu sayede widget tree'ye (widget ağacına) bağımlı kalmazsınız. Controllers ya da blocs'daki inheritedWidget'a erişmek için context'e ihtiyaç duyulmaz böylelikle presentation logic ve business logic, view katmanından tamamen ayrılır. Controllers/Models/Blocs sınıflarını widget tree'ye inject (aktarırken) ederken `MultiProvider`'lar kullanılmasına ihtiyaç yoktur. GetX'in kendine ait dependency injection özelliği sayesinde DI'yi de view'dan tamamen ayrır.\n\n    GetX ile varsayılan olarak temiz kod kullanılarak uygulamadaki her bir özelliğin nerede bulunduğuna ulaşabilirsiniz. Bakım kolaylığının yanı sıra Flutter'da düşünüleyemeyen bir şey olan modülleri paylaşmayı tamamen mümkün kılar.\n    BLoC, Flutter'daki kodları organize etmenin başlangıç noktasıdır. Business logic'i, view'dan ayırır. Bunun gelişmiş hali olarak ortaya çıkan GetX sadece business logic'i ayırmakla kalmayıp aynı zamanda dependency injection'ları, route'ları ve presentation logic'i de view'dan ayırır. Data layer (Veri katmanı) bu sayede bütün katmanların dışında bırakılır. Her şeyin nerde olduğunu bilmek \"hello word\" oluşturmaktan çok daha kolay bir yoldur.\n    GetX, Flutter SDK'sı ile çok kolay, pratik ve ölçeklenebilir yüksek performanslı uygulamalar yapmanızı sağlar. Birlikte çalışılabilen büyük bir ekosistem içerir. Yeni başlayanlar için oldukça kolay ve uzmanlar için de doğru olandır. Güvenli, stabil, güncel ve Flutter SDK'da varsayılan olarak olmayan büyük kapsamlı APIs kullanabilmeyi sağlar.\n\n- GetX şişkin değildir. Çoklu davranış içeren özellikleri kullanarak, herhangi bir endişe olmaksızın programlamaya başlamanızı sağlar. Ancak bu özellikler farklı taraflarda olup sadece kullanıldıktan sonra başlatılır. Sadece state management kullanıyorsanız, sadece bu derlenir. Sadece routes kullanırsanız, state management'dan hiçbir şey derlenmez.\n\n- GetX büyük bir ekosistemdir. Geniş bir topluluk, çok sayıda destekçi içerir ve Flutter var olduğu sürece bu korunacaktır. GetX, tek bir kod ile Android, iOS, Web, Mac, Linux, Windows veya kendi server'ınız (sunucunuz) üzerinde çalışmaya elverişlidir.\n  **[Get Server](https://github.com/jonataslaw/get_server) ile frontend üzerinde yaptığınız kodu backend üzerinde tamamen yeniden kullanmanız mümkün**.\n\n**Ek olarak, tüm geliştirme süreci hem server'da hem de frontend'de [Get CLI](https://github.com/jonataslaw/get_cli) ile tamamen otomatikleştirilebilir**.\n\n**Ayrıca üretkenliğinizi arttırmak için \n[VSCode eklentileri](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets) ve the [Android Studio/Intellij eklentileri](https://plugins.jetbrains.com/plugin/14975-getx-snippets) vardır.**\n\n# Kurulum\n\npubspec.yaml dosyasına Get’i ekleyin:\n\n```yaml\ndependencies:\n  get:\n```\n\nGet’i kullanılacak sayfaya import ediyoruz:\n\n```dart\nimport 'package:get/get.dart';\n```\n\n# GetX ile Sayaç Uygulaması\n\n“Sayaç” projesi yeni bir Flutter projesi oluştururken varsayılan olarak gelir. Yorum satırları ile birlikte toplam 100 satır içerir. Get’in gücünü göstermek gerekirse, size bir “sayaç” uygulamasının her bir tıklamada durumunu değiştirip, sayfalar arasında hareket edip ve bunu yaparken state'leri (durumları) aktarıp aynı zamanda organize bir yol izleyerek business logic'i view'dan ayıracağız ve bu YORUM SATIRLARI DAHİL SADECE 26 SATIR İÇERECEK.\n\n- 1.Adım:\n  “Get”’i MaterialApp’den önce  GetMaterialApp'e dönüştürerek ekliyoruz.\n\n```dart\nvoid main() => runApp(GetMaterialApp(home: Home()));\n```\n\n- Not: Bu kullanım Flutter’ın sağladığı MaterialApp’i modifiye etmez. Sadece child'ı (çocuğu) MaterialApp olan ve bir öncesinde konfigüre edilmiş bir widget’tır. Kendiniz de manuel olarak konfigüre edebilirsiniz fakat buna gerek yoktur. GetMaterialApp, route’ları oluşturacak ve içine bunları, translation’ları ve route navigation için ihtiyacınız olabilecek olan her şeyi inject edecektir. Eğer Get’i sadece state management ya da dependency management olarak kullanmak isterseniz, GetMaterialApp kullanmanıza gerek yoktur. Bu yapı routes, snackbars, internationalization, bottomSheets, dialogs, ve route'lara bağlı high-level apis kullanımlarında ek olarak da context'in yokluğundaki durumlarda kullanılmalıdır.\n- Not²: Bu adım sadece route management kullanıldığında gereklidir (`Get.to()`, `Get.back()` ve bunlar gibi). Kullanmayacaksanız 1. adımı yapmanıza gerek yoktur.\n\n- 2.Adım:\n  İş mantıklarını içeren sınıfı oluşturup içine tüm değişkenleri metodları ve controller'ları ekleyin.İstediğiniz herhangi bir değişkeni \".obs\" ile gözlemlenebilir yapabilirsiniz.\n\n```dart\nclass Controller extends GetxController{\n  var count = 0.obs;\n  increment() => count++;\n}\n```\n\n- 3.Adım:\n  View'ı oluşturun ve içine StatelessWidget (bu RAM'den tasarruf sağlar) yerleştirin. Get sayesinde StatefulWidget kullanmanıza gerek yoktur.\n\n```dart\nclass Home extends StatelessWidget {\n\n  @override\n  Widget build(context) {\n\n    // Sınıfınızın nesnesini getirmek için Get.put() kullanılır. Bu içindeki tüm \"child\" route'ları görüntülenebilir yapar.\n    final Controller c = Get.put(Controller());\n\n    return Scaffold(\n      // Sayaç her değiştiğinde Text() içindeki değerin güncellenmesi için Obx(()=> kullanılır\n      appBar: AppBar(title: Obx(() => Text(\"Clicks: ${c.count}\"))),\n\n      // Navigator.push içeren 8 satırı basit bir şekilde Get.to() ile değiştirin. Bunda context'e ihtiyacınız kalmamaktadır.\n      body: Center(child: ElevatedButton(\n              child: Text(\"Go to Other\"), onPressed: () => Get.to(Other()))),\n      floatingActionButton:\n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n  }\n}\n\nclass Other extends StatelessWidget {\n  // Önceki sayfada zaten kulllandığımız  Controller'ı, Get'de \"find\" diyerek getirmesinini istiyoruz.\n  final Controller c = Get.find();\n\n  @override\n  Widget build(context){\n     // Güncellenen sayaç değişkenine erişiyoruz.\n     return Scaffold(body: Center(child: Text(\"${c.count}\")));\n  }\n}\n```\n\nSonuç:\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/counter-app-gif.gif)\n\nBu basit bir proje ama Get'in ne kadar güçlü olduğunu zaten açıkça ortaya koyuyor. Projeniz büyüdükçe bu gücü daha iyi anlacaksınız.\n\nGet, ekiplerle çalışmak üzere tasarlanmıştır. Ayrıca bireysel geliştiricinin de işini oldukça kolaylaştırır.\n\nPerformanstan ödün vermeden her şeyi zamanında teslim etmenize yardımcı olur. Get tam olarak sana layık!\n\n# Üç Temel Kavram\n\n## State management (Durum Yönetimi)\n\nGet iki farklı state manager içerir: simple state manager (GetBuilder da denilir) ve reactive state manager (GetX/Obx)\n\n### Reactive State Manager (Reaktif Durum Yönetimi)\n\nReaktif programlama, birçok kişi tarafından karmaşık olduğu söylendiği için kafa karışıklığına yol açabilir. Ancak GetX, reaktif programlamayı oldukça basit bir hale dönüştürür:\n\n- StreamController'ları oluşturmanıza ihtiyacınız yoktur.\n- Her bir değişken için StreamBuilder oluşturmanıza gerekmez.\n-  Her state için sınıf oluşturmanıza gerek yoktur.\n- Başlangıç değerleri için get metodu oluşturmaya ihtiyaç olmaz.\n- Code generators kullanmanız gerekmez.\n\nGet, reaktif programlamayı setState kullanmak kadar kolay yapmaktadır.\n\nBir isim değişkeniniz olduğunu ve onu her değiştirdiğinizde, onu kullanan tüm widget'ların otomatik olarak güncellendiğini düşünün.\n\nBu sizin sayaç değişkeniniz:\n\n```dart\nvar name = 'Jonatas Borges';\n```\n\nGözlemlenebilir yapmak için \".obs\" ekliyorsunuz ve bu şekli alıyor:\n\n```dart\nvar name = 'Jonatas Borges'.obs;\n```\n\nUI'da (kullanıcı arayüzünde) bu değeri göstermek ve değerler değiştiğinde ekranı güncellemek istediğinizde, hemen şunu yapın:\n\n```dart\nObx(() => Text(\"${controller.name}\"));\n```\n\nHepsi bu. İşte _bu kadar_ basit.\n\n### State Management Hakkında Daha Fazla Bilgi\n\n**State Management'ın daha ayrıntılı bir açıklamasına [buradan](./documentation/en_US/state_management.md) erişebilirsiniz. Orada daha fazla örnek ile simple state manager ve reactive state manager arasındaki farkı görebilirsiniz**\n\nGetX'in gücü hakkında daha iyi bir fikir edineceksiniz.\n\n## Route Management (Rota Yönetimi)\n\nEğer routes/snackbars/dialogs/bottomsheets yapılarını context'e ihtiyaç duymadan kullanmak istedğinizde, GetX bunun için biçilmiş kaftan.\n\nMaterialApp'i GetMaterialApp ile değiştiriyoruz.\n\n```dart\nGetMaterialApp( // Önceki hal: MaterialApp(\n  home: MyHome(),\n)\n```\n\nYeni ekrana geçmek için:\n\n```dart\n\nGet.to(NextScreen());\n```\n\nName (isim) ile yeni sayfaya geçiş yapılabilir. Named routes (İsimli rotalar) hakkında daha çok bilgiye [buradan](./documentation/tr_TR/route_management.md#navigation-with-named-routes) ulaşabilirsiniz.\n\n```dart\n\nGet.toNamed('/details');\n```\n\nSnackbars, dialogs, bottomsheets ve normalde Navigator.pop(context) ile kapatacağınız herhangi bir şeyi kapatmak için;\n\n```dart\nGet.back();\n```\n\nÖnceki ekrana geri dönme seçeneğinin olmadan bir sonraki ekrana gitmek için (örnek olarak SplashScreens, login screens, vs.)\n\n```dart\nGet.off(NextScreen());\n```\n\nSonraki ekrana gitmek ve önceki tüm route'ları kapatmak için shopping carts, polls, ve test'lerde kullanılır)\n\n```dart\nGet.offAll(NextScreen());\n```\n\nBunlardan herhangi birini yapmak için context kullanmanız gerekmediğini fark ettiniz mi? Get route management'ı kullanmanın en büyük avantajlarından biri de budur. Böylelikle controller sınıfınızda olan tüm metodları endişe olmadan çalıştırabilirsiniz.\n\n### Route Management Hakkında Daha Fazla Bilgi\n\n**Get, named routes ile çalışırken route'lar arası geçişleri kolayca kontrol etmenizi sağlar. Daha ayrıntılı doküman için [buraya](./documentation/tr_TR/route_management.md) tıklayabilirsiniz.**\n\n## Dependency Management (Bağımlılık Yönetimi)\n\nGet basit ve güçlü bir dependency manager içerir. Sadece tek satır kod ile Bloc ya da Controller'ınızın aynı sınıf nesnesini getirmenizi sağlar. Ayrıca Provider context, ya da inheritedWidget kullanmanıza gerek kalmaz:\n\n```dart\nController controller = Get.put(Controller()); // Controller controller = Controller(); yazmak yerine\n```\n\n- Not: Get'in State Manager'ını kullanıyorsanız, API bağlamaya daha çok dikkat edin ki onlar view'ı controller'a kolayca bağlamanızı sağlayacaktır.\n\nKullanacağınız sınıfın içinde başka bir sınıfın nesnesini oluşturmak yerine, Get instance sayesinde uygulamanızın her yerinde aynı sınıf nesnesini kullanabilir hale getirebilirsiniz.\nBöylelikle controller (ya da Bloc sınıfını) normal bir şekilde kullanabilirsiniz.\n\n**İpucu:** Get dependency management, kütüphanenin diğer parçalarından ayrıdır. Örnek olarak eğer uygulamanızda hali hazırda state manager kullanıyorsanız (hangisi olduğu fark etmez), en baştan yazmaya gerek yoktur. Bu dependency injection'ı problem olmadan kullanabilirsiniz.\n\n```dart\ncontroller.fetchApi();\n```\n\nFarzedin ki çok fazla sayıda route'larınız ve controller'larınızda erişmeniz gereken data'lar olsun, state manager'ı Provider ya da Get_it gibi kütüphaneler ile bağlamanız gerekmekedir. Get kullanarak bunları bağlamaya ihtiyacınız kalmaz. Get'e sadece \"find\" diyerek controller'ınızı bulmasını istemeniz yeterlidir. Fazladan dependency'lere ihtiyacınız yoktur:\n\n```dart\nController controller = Get.find();\n// Evet, inanılmaz değil mi? Get, controller'ınızı bulup getirecek. Get, milyonlarca controller tanımlanmış da olsa size her zaman doğrusunu getirecektir.\n```\n\nSonrasında üstte alınan controller'daki verilerinizi kullanabileceksiniz:\n\n```dart\nText(controller.textFromApi);\n```\n\n### Dependency Management Hakkında Daha Fazla Bilgi\n\n**Dependency management'a daha derinden bakmak için [buraya](./documentation/tr_TR/dependency_management.md) tıklayabilirsiniz**\n\n# Utils\n\n## Internationalization (Uluslararasılaştırma)\n\n### Translations (Çeviriler)\n\nTranslations, map halinde basit key-value değerleri tutar.\nÖzel translation'larınızı eklemek için bir sınıf oluşturup `Translations`sınıfını extend edebilirsiniz.\n\n```dart\nimport 'package:get/get.dart';\n\nclass Messages extends Translations {\n  @override\n  Map<String, Map<String, String>> get keys => {\n        'en_US': {\n          'hello': 'Hello World',\n        },\n        'de_DE': {\n          'hello': 'Hallo Welt',\n        }\n      };\n}\n```\n\n#### Translations kullanımı\n\nÖnecen belirlenmiş key'e sadece `.tr` eklenince `Get.locale` ve `Get.fallbackLocale` şimdiki değerleri kullanarak otomatik çeviriyi yapacaktır.\n\n\n```dart\nText('title'.tr);\n```\n\n#### Tekil ve çoğul çevirisi yapımı\n\n```dart\nvar products = [];\nText('singularKey'.trPlural('pluralKey', products.length, Args));\n```\n\n#### Parametreler ile çeviri yapımı\n\n```dart\nimport 'package:get/get.dart';\n\n\nMap<String, Map<String, String>> get keys => {\n    'en_US': {\n        'logged_in': 'logged in as @name with email @email',\n    },\n    'es_ES': {\n       'logged_in': 'iniciado sesión como @name con e-mail @email',\n    }\n};\n\nText('logged_in'.trParams({\n  'name': 'Jhon',\n  'email': 'jhon@example.com'\n  }));\n```\n\n### Locales (Yerel Ayarlar)\n\nLocale ve translation'lar`GetMaterialApp`'in parametreleri içinde atanabilir.\n\n```dart\nreturn GetMaterialApp(\n    translations: Messages(), //Çevirileriniz\n    locale: Locale('en', 'US'), //Çeviriler bu locale dilinde gösterilecek\n    fallbackLocale: Locale('en', 'UK'), // Eğer yanlış bir locale olması durumunda gösterilecek fallback locale\n);\n```\n\n#### Locale değiştirme\n\n`Get.updateLocale(locale)` çağrılarak locale güncellenebilir. Çeviriler otomatik olarak yeni locale dilinde olacaktır.\n\n```dart\nvar locale = Locale('en', 'US');\nGet.updateLocale(locale);\n```\n\n#### System locale (Yerel Sistem Ayarları)\n\nSistem locale'i okumak için `Get.deviceLocale` kullanılır.\n\n```dart\nreturn GetMaterialApp(\n    locale: Get.deviceLocale,\n);\n```\n\n## Tema Değiştirme\n\nGüncellemek için`GetMaterialApp`'in üstüne bir widget koymayın. Bu, kopya key'ler oluşmasını tetikler. Birçok kişi tema değiştirmek için tarih öncesi bir yöntem olan \"ThemeProvider\" widget'ı oluşturmayı tercih eder. **GetX™** ile buna HİÇ gerek duyulmaz.\n\n`Get.changeTheme`ile kendi oluşturduğunuz temanızı hızlı bir şekilde ekleyebilirsiniz:\n\n```dart\nGet.changeTheme(ThemeData.light());\n```\n\n`onTap`'de Temayı değiştiren bir buton oluşturmak istiyorsanız, bunun için iki **GetX™** API'sini birleştirebilirsiniz:\n\n- API, karanlık `Theme`'in kullanıp kullanılmadığını kontrol eder.\n- `Theme` Change API'yi `onPressed`içine koyabilirsiniz:\n\n```dart\nGet.changeTheme(Get.isDarkMode? ThemeData.light(): ThemeData.dark());\n```\n\n`.darkmode` aktif hale geldiğinde, tıklandığında _light theme_ 'e döner, _light theme_ aktif olduğunda,  _dark theme_'e geçer.\n\n## GetConnect\n\nGetConnect backend ile frontend'in http ya da websockets ile kolayca iletişime geçmesini sağlar.\n\n### Varsayılan Ayarlar\n\nSadece GetConnect'den extend ederek gelen GET/POST/PUT/DELETE/SOCKET metodlarını kullanarak Rest API ya da websockets ile kolayca iletişim kurabilirsiniz.\n\n```dart\nclass UserProvider extends GetConnect {\n  // Get request\n  Future<Response> getUser(int id) => get('http://youapi/users/$id');\n  // Post request\n  Future<Response> postUser(Map data) => post('http://youapi/users', body: data);\n  // File  ile Post request\n  Future<Response<CasesModel>> postCases(List<int> image) {\n    final form = FormData({\n      'file': MultipartFile(image, filename: 'avatar.png'),\n      'otherFile': MultipartFile(image, filename: 'cover.png'),\n    });\n    return post('http://youapi/users/upload', form);\n  }\n\n  GetSocket userMessages() {\n    return socket('https://yourapi/users/socket');\n  }\n}\n```\n\n### Özel Ayarlamalar\n\nGetConnect oldukça düzenlenebilir. Kendi base Url'nizi tanımlayabilir, cevapları ve Request'leri düzenleyebilirsiniz. Authenticator oluşturup kendiliğinden authenticate olmasını sağlayabilirsiniz. Size verilen standart decoder ile tüm request'leri ek bir ayar olmadan modellerinize aktarabilirsiniz.\n\n```dart\nclass HomeProvider extends GetConnect {\n  @override\n  void onInit() {\n    // Tüm request'ler jsonEncode'a gider: CasesModel.fromJson()\n    httpClient.defaultDecoder = CasesModel.fromJson;\n    httpClient.baseUrl = 'https://api.covid19api.com';\n    // baseUrl = 'https://api.covid19api.com'; //baseUrl'yi bu şekilde tanımlar\n    // Http ve websockets kullanılmış ise [httpClient] instance'ına ihtiyaç yoktur.\n\n\n    // Gelen tüm request'ler \"apikey\"'in header özelliğine gier.\n    httpClient.addRequestModifier((request) {\n      request.headers['apikey'] = '12345678';\n      return request;\n    });\n\n    // Eğer sunucu \"Brazilya\"'dan bir veri gönderse bile\n    // response'dan veriyi kaldırdığın için kullanıcılar göremez.\n    // response önceden getirişmiş olsa bile \n    httpClient.addResponseModifier<CasesModel>((request, response) {\n      CasesModel model = response.body;\n      if (model.countries.contains('Brazil')) {\n        model.countries.remove('Brazilll');\n      }\n    });\n\n    httpClient.addAuthenticator((request) async {\n      final response = await get(\"http://yourapi/token\");\n      final token = response.body['token'];\n      // header veriliyor\n      request.headers['Authorization'] = \"$token\";\n      return request;\n    });\n\n    // HttpStatus, HttpStatus.unauthorized ise \n    // Autenticator 3 defa çağırılır.\n    httpClient.maxAuthRetries = 3;\n  }\n  }\n\n  @override\n  Future<Response<CasesModel>> getCases(String path) => get(path);\n}\n```\n\n## GetPage Middleware\n\nGetPage'in GetMiddleWare listesi oluşturan ve bunları özel bir sırada çalıştıran bir özelliği vardır.\n\n**Not**: GetPage, Middlewares içeriyor ise bu sayfanın tüm çocukları da aynı middlewares'i otomatik olarak içerir.\n\n### Priority (Öncelik)\n\nMiddlewares'in sıralı çalışması için GetMiddleware'lerin priority'leri (öncelikleri) düzenlenmelidir.\n\n```dart\nfinal middlewares = [\n  GetMiddleware(priority: 2),\n  GetMiddleware(priority: 5),\n  GetMiddleware(priority: 4),\n  GetMiddleware(priority: -8),\n];\n```\n\nMiddleware'ler bu sırada çalışacaktır:   **-8 => 2 => 4 => 5**\n\n### Redirect (Yönlendirme)\n\n Çağrılan route'un sayfası arandığında, fonsyon çağırılmış olacaktır. Redirect için RouteSettings kullanılır. Name değeri null verilebilir ve bu olduğu zaman herhangi bir redirect olmayacaktır.\n\n```dart\nRouteSettings redirect(String route) {\n  final authService = Get.find<AuthService>();\n  return authService.authed.value ? null : RouteSettings(name: '/login')\n}\n```\n\n### onPageCalled\n\nBu fonsyon, herhangi bir şey oluşmadan önce sayfa çağırılmak istenildiğinde kullanılır. Sayfada bir şey değiştirmek için ya da yeni bir sayfa vermek için kullanabilirsiniz.\n\n```dart\nGetPage onPageCalled(GetPage page) {\n  final authService = Get.find<AuthService>();\n  return page.copyWith(title: 'Welcome ${authService.UserName}');\n}\n```\n\n### OnBindingsStart\n\nBu fonsyon Bindings başlatılmadan hemen önce çalışır.\nBu sayfa için Bindings'i şu şekilde değiştirebilirsiniz.\n\n```dart\nList<Bindings> onBindingsStart(List<Bindings> bindings) {\n  final authService = Get.find<AuthService>();\n  if (authService.isAdmin) {\n    bindings.add(AdminBinding());\n  }\n  return bindings;\n}\n```\n\n### OnPageBuildStart\n\nBu fonsyon Bindings başlatıldıktan hemen sonra çalışır.\nBindings oluşturulduktan hemen sonra ve widget sayfası oluşturulmadan önce kullanabilirsiniz.\n\n```dart\nGetPageBuilder onPageBuildStart(GetPageBuilder page) {\n  print('bindings are ready');\n  return page;\n}\n```\n\n### OnPageBuilt\n\nBu fonskyon GetPage.page fonskyonu çağrıldıktan hemen sonra çalışır ve fonksyonun sonucunu verir. Sonrasında gösterilecek widget'ı alır.\n\n### OnPageDispose\n\nBu fonsyon sayfadaki ilgili tüm objelerin (Controllers, views, ...) dispose olmasından hemen sonra çalışır.\n\n## Advanced APIs (Gelişmiş API'ler)\n\n```dart\n// currentScreen'deki arg'ı verir\nGet.arguments\n\n// Önceki route'un name'ini verir.\nGet.previousRoute\n\n// Erişmek için raw route'u verir. Örnek olarak: rawRoute.isFirst()\nGet.rawRoute\n\n// GetObserver'dan Routing API'ye erişim verir.\nGet.routing\n\n// Snackbar açık mı kontrolü yaplır.\nGet.isSnackbarOpen\n\n// Dialog açık mı kontrolü yaplır.\nGet.isDialogOpen\n\n// Bottomsheet açık mı kontrolü yaplır.\nGet.isBottomSheetOpen\n\n// Tek route kaldırılır.\nGet.removeRoute()\n\n// predicate, true döndürene kadar terarlanarak geri gelir.\nGet.until()\n\n// Yeni route a gider ve eski tüm route'ları, predicate, true döndürene kadar kaldırır.\nGet.offUntil()\n\n// named route'a gider ve eski tüm route'ları, predicate, true döndürene kadar kaldırır.\nGet.offNamedUntil()\n\n//Hangi platformda çalıştığı kontrol edilir.\nGetPlatform.isAndroid\nGetPlatform.isIOS\nGetPlatform.isMacOS\nGetPlatform.isWindows\nGetPlatform.isLinux\nGetPlatform.isFuchsia\n\n//Cihaz türü kontrol edilir.\nGetPlatform.isMobile\nGetPlatform.isDesktop\n//Web'de tüm platformlar bağımsız olarak desteklenir!\n//Bir tarayıcının içinde çalışıp çalışmadığınızı anlayabilirsiniz\n//Windows, iOS, OSX, Android, vs. gibi\nGetPlatform.isWeb\n\n\n// Aşağıdakine eşittir : MediaQuery.of(context).size.height,\n// fakat immutable'dır (sabittir).\nGet.height\nGet.width\n\n// Navigator'e şimdiki context'i verir.\nGet.context\n\n// Önde olan snackbar/dialog/bottomsheet'a nerede olursanız olun context'i verir. \nGet.contextOverlay\n\n// Not: aşağıdaki metodlar context üzerine olan extension'lardır.\n// UI'ın herhangi bir yerinde context'e erişebilirsiniz ve istediğiniz yerde kullanabilirsiniz.\n\n// Eğer değişken bir height/width verileri varsa (örnek olarak Masaüstü ya da tarayıcı gibi ölçeği değişebilen pencereler) context'i kullanmaya ihtiyacınız vardır.\ncontext.width\ncontext.height\n\n// Size ekranın yarısını, üçte birini vb. tanımlamayı sağlar.\n// Responsive uygulamalar için kullanışlıdır.\n// param dividedBy (double) optional - default: 1\n// param reducedBy (double) optional - default: 0\ncontext.heightTransformer()\ncontext.widthTransformer()\n\n/// MediaQuery.of(context).size'a benzer\ncontext.mediaQuerySize()\n\n/// MediaQuery.of(context).padding'e benzer\ncontext.mediaQueryPadding()\n\n/// MediaQuery.of(context).viewPadding'e benzer\ncontext.mediaQueryViewPadding()\n\n/// MediaQuery.of(context).viewInsets;'e benzer\ncontext.mediaQueryViewInsets()\n\n/// MediaQuery.of(context).orientation;'a benzer\ncontext.orientation()\n\n/// Cihazın yatay modda olup olmadığını kontrol eder.\ncontext.isLandscape()\n\n/// Cihazın dikey modda olup olmadığını kontrol eder.\ncontext.isPortrait()\n\n/// MediaQuery.of(context).devicePixelRatio;'ya benzer\ncontext.devicePixelRatio()\n\n/// MediaQuery.of(context).textScaleFactor;'e benzer\ncontext.textScaleFactor()\n\n/// Ekranın en kısa kenarını getirir\ncontext.mediaQueryShortestSide()\n\n/// width 800'den büyük ise true döndürür.\ncontext.showNavbar()\n\n/// Kısa kenar 600p'den küçük ise true döndürür.\ncontext.isPhone()\n\n/// Kısa kenar 600p'den büyük ise true döndürür.\ncontext.isSmallTablet()\n\n/// Kısa kenar 720p'den büyük ise true döndürür.\ncontext.isLargeTablet()\n\n/// Cihaz tablet ise true döndürür.\ncontext.isTablet()\n\n/// Ekran boyutuna göre <T> değerini döndürür\n/// için değer verebilir:\n/// watch: Kısa kenar 300'den küçük ise\n/// mobile: Kısa kenar 600'den küçük ise\n/// tablet: Kısa kenar 1200'den küçük ise\n/// desktop: width 1200'den büyük ise\n\ncontext.responsiveValue<T>()\n```\n\n### Opsiyonel Genel Ayarlar ve Manuel Ayarlamalar\n\nGetMaterialApp çoğu şeyi sizin için otomatik olarak ayarlar, ayrıca kendiniz de isterseniz Get'i manuel olarak ayarlayabilirsiniz.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver()],\n);\n```\n\n`GetObserver` içinde kendi Middleware'ınızı kullanabilirsiniz ve bu hiçbir şeyi etkilemez.\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [\n    GetObserver(MiddleWare.observer) // Burası\n  ],\n);\n```\n\n`Get` için _Global Settings_ oluşturabilirsiniz. Herhangi bir route'a push yapmadan önce kodunuza `Get.config` eklemeniz yeterli. \nYa da doğrudan  `GetMaterialApp` içinde tanımlayabilirsiniz.\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  defaultTransition: Transition.fade,\n  opaqueRoute: Get.isOpaqueRouteDefault,\n  popGesture: Get.isPopGestureEnable,\n  transitionDuration: Get.defaultDurationTransition,\n  defaultGlobalState: Get.defaultGlobalState,\n);\n\nGet.config(\n  enableLog = true,\n  defaultPopGesture = true,\n  defaultTransition = Transitions.cupertino\n)\n```\n\nİsteğe bağlı olarak tüm logging mesajlarını `Get` üzerinden yönlendirebilirsiniz. \nKendi istediğiniz logging paketinizi kullanmak \nve oradaki log'ları yakalamak istiyorsanız:\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  logWriterCallback: localLogWriter,\n);\n\nvoid localLogWriter(String text, {bool isError = false}) {\n  // istediğiniz logging paketine mesajı aktarır\n  // eğer, enableLog: false ise log mesajları bu callback içine gönderilir\n  // GetConfig.isLogEnable aracılığıyla isterseniz kontrol edebilirsiniz\n}\n\n```\n\n### Local State Widgets (Yerel Durum Widgetları)\n\nBu widget'lar tek bir değeri kontrol etmenize ve durumu geçici ya da yerel olarak tutmanızı sağlar.\nReactive ve simple olan yapılar içerir.\nÖrneğin bunları `TextField` içindeki obscureText parametresine bağlayabilirsiniz. İsterseniz kendinizinkini (Expandable Panel vs.) de oluşturabilirsiniz ya da `Scaffold`'daki body'nin içeriği değişirken `BottomNavigationBar` içindeki current index'i değiştirebilirsiniz.\n\n#### ValueBuilder\n\nVeri güncellemenin bir yolu olan  `StatefulWidget`'daki  `.setState` yapısının basitleştirilmiş halidir.\n\n```dart\nValueBuilder<bool>(\n  initialValue: false,\n  builder: (value, updateFn) => Switch(\n    value: value,\n    onChanged: updateFn, // tamamen aynısı! ( newValue ) => updateFn( newValue ) yapısını da kullanabilirsiniz\n  ),\n  // eğer builder metodu dışından bir çağırma işlemi yapılacak ise\n  onUpdate: (value) => print(\"Value updated: $value\"),\n  onDispose: () => print(\"Widget unmounted\"),\n),\n```\n\n#### ObxValue\n\n[`ValueBuilder`](#valuebuilder)'a oldukça benzer olmasının yanında bu Reactive halidir. Rx nesnesine aktarabilir ( .obs yapısını hatıladınız mı?) ve otomatik olarak güncellenmensini sağlayabilirsiniz, resmen muhteşem değil mi ?  \n\n```dart\nObxValue((data) => Switch(\n        value: data.value,\n        onChanged: data, // Rx, çağrılabilen fonsyon içerir. (flag) => data.value = flag şeklinde kullanılablir.\n    ),\n    false.obs,\n),\n```\n\n## Faydalı Ipuçları\n\n`.obs` yapıları olan gözlemlenebilirler ( _Rx_ tipleri olarak da bilinirler) oldukça çeşitli internal metodlara ve operatörlere sahiptirler.\n\n>  `.obs` yapısının gerçek değer olduğunu düşünenler oldukça yaygındır fakat bu yanlış bir düşüncedir.\n> Değişkenleri, Type declaration yapmaktan kaçınmalıyız. Çünkü Dart'ın derleyicisi zaten bunu anlayacak kadar zekidir.\n> Kodunuzu daha temiz gösterir fakat:\n\n```dart\nvar message = 'Hello world'.obs;\nprint( 'Message \"$message\" has Type ${message.runtimeType}');\n```\n\n`message`, gerçek String Type değerini yazdırsa bile aslında bu bir **RxString** Type değeridir!\n\nYani `message.substring( 0, 4 )` şeklinde kullanmazsınız.\n _observable_ içindeki gerçek `value`'ya (değere) erişmelisiniz.\nEn çok \"kullanılan yol\"  `.value` yapısı ile erişmektir fakat şu şekilde kullanabileceğiniz bir yol daha var...\n\n\n```dart\nfinal name = 'GetX'.obs;\n// eğer değer şimdikinden farklı ise, sadece stream'i \"günceller\"\nname.value = 'Hey';\n\n// Tüm Rx özellikleri \"çağrılabilir\" ve geriye yeni bir değer döndürür.\n// Fakat bu yaklaşım `null` değerleri kabul etmez, sonucunda UI rebuild (tekrardan oluşturulmaz) edilmez.\nname('Hello');\n\n// getter yapmak gibi, 'Hello'yazdırır.\n\nname() ;\n\n/// numbers:\n\nfinal count = 0.obs;\n\n// Tüm non mutable (değişken olmayan) işlemleri num primitives üzerinden yapabilirsiniz.\ncount + 1;\n\n// Dikkat edin! Bu sadece `count` değerinin 'final' olmayıp 'var' olduğu değerlerde mümkündür.\ncount += 1;\n\n// Ayrıca değerleri kıyaslayabilirsiniz:\ncount > 2;\n\n/// booleans:\n\nfinal flag = false.obs;\n\n// değer true/false arasında değişir.\nflag.toggle();\n\n\n/// tüm tipler için:\n\n// \"value\"'ları null'a çevirir.\nflag.nil();\n\n// Tüm toString(), toJson() işlemleri `value`'ya aktarılır.\nprint( count ); // RxInt içinden `toString()` çağrılır.\n\nfinal abc = [0,1,2].obs;\n// Değeri bir json Array (dizi) yapısına çevirir ve RxList şeklinde yazdırır.\n// Json tüm Rx tipleri tarafından desteklenir.\nprint('json: ${jsonEncode(abc)}, type: ${abc.runtimeType}');\n\n// RxMap, RxList ve RxSet kendi native tiplerinden extend edilen özel Rx tipleridir.\n// Fakat List ile çalışmak normal listelerle çalışmak gibidir. Reaktiv olmasına rağmen.\nabc.add(12); // '12' listeye eklenir ve stream GÜNCELLENİR.\nabc[3]; // List'deki gibi 3. index okunur.\n\n\n// Rx ve value ile çalışmak aynıdır fakat hashCode her zaman value'dan alınır.\nfinal number = 12.obs;\nprint( number == 12 ); // çıktı: true\n\n/// Özel Rx Modelleri:\n\n\n// toJson(), toString() child'a gönderilir. Böylelikle override'ları onlara implement edebilirsiniz ve doğrudan gözlemlenebiliri print() edebilirsiniz.\n\nclass User {\n    String name, last;\n    int age;\n    User({this.name, this.last, this.age});\n\n    @override\n    String toString() => '$name $last, $age years old';\n}\n\nfinal user = User(name: 'John', last: 'Doe', age: 33).obs;\n\n// `user`,\"reactive\" yapıdadır. Fakat içinde özellikleri DEĞİLDİR.\n// Yani eğer içindeki bazı değerleri değiştirirsek\nuser.value.name = 'Roi';\n//widget, rebuild olmayacaktır!,\n//`Rx`, user içindeki bir şeyi değiştirdiğinizde, bundan haberi olmayacaktır.\n// Özel sınıflar oluşturmak için, manuel olarak değişiklikleri \"notify\" etmeliyiz.\nuser.refresh();\n\n// Ya da `update()` metodunu kullanabiliriz\nuser.update((value){\n  value.name='Roi';\n});\n\nprint( user );\n```\n## StateMixin\n\n`UI` state ile başa çıkmanın başka bir yolu da `StateMixin<T>`  kullanmaktır.\nBunu implement yapmak için, controller'ınıza  `with` kullanarak yanına `StateMixin<T>` eklemekle olur.\nBu sizin T modelini kullanmanızı sağlar.\n\n\n``` dart\nclass Controller extends GetController with StateMixin<User>{}\n```\n\n`change()` metodu istediğiniz yerde State'i değiştirmemizi sağlar.\nVeri(data) ve durum(status) aktarmak için kullanılan yol:\n\n```dart\nchange(data, status: RxStatus.success());\n```\n\nRxStatus şu durumları kullanmanızı sağlar:\n\n``` dart\nRxStatus.loading();\nRxStatus.success();\nRxStatus.empty();\nRxStatus.error('message');\n```\n\nUI'ın içinde temsil edilmesi için şu şekilde kullanılır:\n\n```dart\nclass OtherClass extends GetView<Controller> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n\n      body: controller.obx(\n        (state)=>Text(state.name),\n        \n        // Kendi yüklenme göstergenizi (loading indicator) buraya eklebilirsiniz\n        // hali hazırda gelen yapı şudur: Center(child:CircularProgressIndicator())\n        onLoading: CustomLoadingIndicator(),\n        onEmpty: Text('No data found'),\n\n        // Keni hata widget'ınızı buraya yazabilirsiniz\n        // hali hazırda gelen yapı şudur: Center(child:Text(error))\n        onError: (error)=>Text(error),\n      ),\n    );\n}\n```\n\n#### GetView\n\nBu widget'ı çok seviyorum, oldukça basit ve çok kullanışlı!\n\n`const Stateless` Widget, `Controller`'ı tanımlamak için `controller` özelliği içerir. \n\n```dart\n class AwesomeController extends GetController {\n   final String title = 'My Awesome View';\n }\n\n  // controller'ınızı register etmek için bunu kullandığınız `Type`'a geçirmeyi asla unutmayın.\n class AwesomeView extends GetView<AwesomeController> {\n   @override\n   Widget build(BuildContext context) {\n     return Container(\n       padding: EdgeInsets.all(20),\n       child: Text(controller.title), // sadece `controller.something` deyin\n     );\n   }\n }\n```\n\n#### GetResponsiveView\n\nResponsive view oluşturmak için bu widget'tan extend edilir.\nBu widget ekran size ve type hakkında bilgiler içeren  \n`screen` özelliğini taşır.\n\n##### Nasıl kullanılır?\n\nbuild yapmanız için 2 yönteminiz vardır.\n\n- build yapmak için `builder` metodu ile widget döndürmek\n- `desktop`, `tablet`,`phone`, `watch`  metodları ile \n  bu özel metodlar ekran türü bu metodlarla eşitlendiiği zaman build metodunu tetikler.\n  Mesela ekran [ScreenType.Tablet] ise `tablet` metodu çalışrıtılacaktır.\n  **Not:** Eğer bu metodu kullanırsanız, lütfen  `alwaysUseBuilder` özelliğini `false` olarak işaretleyin.\n\n`settings` özelliği sayesinde ekranın türüne göre genişlik limiti koyabilirsiniz.\n\n![örnek](https://github.com/SchabanBo/get_page_example/blob/master/docs/Example.gif?raw=true)\nBu ekranın kodları\n[burada](https://github.com/SchabanBo/get_page_example/blob/master/lib/pages/responsive_example/responsive_view.dart)\n\n#### GetWidget\n\nÇoğu kişinin widget'lar hakkında hiçbir fikri yok ya da kullanırken inanılmaz kafası karışıyor.\nBu kullanım oldukça nadir fakat özel: Controller `caches`'leme işlemi _cache_ yüzünden asla bir  `const Stateless` oluşamaz.\n\n> Peki ne zaman Controller'ı \"cache\"'yemeye ihtiyacınız olacak?\n\n\"Çok da yaygın olmayan\" bir **GetX** özelliğini kullanıyorsanız: `Get.create()`.\n\n`Get.create(()=>Controller())` yapısı siz her `Get.find<Controller>()` dediğinizde size yeni bir `Controller` oluşturacak.\n\n`GetWidget`'ın ışığı burada parlıyor. Örnek olarak bir listede \n\nTodo ögelerini tutmak istiyorsanız kullanılır. Eğer widget'ın \"rebuilt\" olursa, yapı yine aynı controller nesnesini tutmaya devam edecektir.\n\n#### GetxService\n\nBu sınıf `GetxController`' bezer. Uygulamanın lifecycle'larını (hayat döngüsü metodlarını) içerir ( `onInit()`, `onReady()`, `onClose()`).\nFakat içinde hiçbir mantıksal yapı bulunmaz. Sadece **GetX**'in Dependency Injection sistemini bilgilendirir. \n\nBunun alt sınıfları, memory (bellekten) hiçbir şekilde **kaldırılamaz**. \n\n\nBu yöntem \"Servislerinizi\" tutmak için oldukça kullanışlıdır. Servisleriniz bu şekilde her zaman ulaşılabilir ve aktif olur.  `Get.find()` metodu buna yeter. Örnek olarak:`ApiService`, `StorageService`, `CacheService`.\n\n\n```dart\nFuture<void> main() async {\n  await initServices(); /// SERVİSLERİN BAŞLATILMASI BEKLENİR\n  runApp(SomeApp());\n}\n\n/// Servislerinizi Flutter uygulaması çalışmadan önce başlatılması oldukça mantıklı bir harekettir.\n/// Uygulama akışını kontrol edebilirsiniz. (belki de birkaç tane Tema düzenlemesi ya da\n/// apiKey, kulllanıcıdan gelen  dil tanımlaması gibi düzenlemeler yapmanız lazımdır...Bu durumna SettingService'i ApiService'den önce çalışması gerekmektedir.\n/// GetMaterialApp() 'in rebuild yapmasına gerek yoktur. Çünkü değerleri doğrudan alır.\nvoid initServices() async {\n  print('starting services ...');\n  /// Burası sizin get_storage, hive, shared_pref gibi yükelemeleri yaptığınız yer.\n  /// ya da daha fazla özellik bağlamak ve ya async yapıları kullanmak için\n  await Get.putAsync(() => DbService().init());\n  await Get.putAsync(SettingsService()).init();\n  print('All services started...');\n}\n\nclass DbService extends GetxService {\n  Future<DbService> init() async {\n    print('$runtimeType delays 2 sec');\n    await 2.delay();\n    print('$runtimeType ready!');\n    return this;\n  }\n}\n\nclass SettingsService extends GetxService {\n  void init() async {\n    print('$runtimeType delays 1 sec');\n    await 1.delay();\n    print('$runtimeType ready!');\n  }\n}\n\n```\n\n`GetxService`'lerini silmenin tek bir yolu vardır o da `Get.reset()`. \nBu yöntem uygulamanıza \"Hot Reboot\" yapmak gibidir. Eğer uygulamanızın hayat süresi boyunca mutlaka kalıcılığı olmasını istediğiniz bir sınıfın nesnesini oluşturmak istediğiniz zaman  `GetxService`'i kullanın.\n\n\n### Testler\n\nController'larınızı lifecycle'ları (hayat döngüleri) dahil olmak üzere diğer sınıflar gibi test edebilirsiniz:\n\n```dart\nclass Controller extends GetxController {\n  @override\n  void onInit() {\n    super.onInit();\n    //Değeri name2 ile değiştirme\n\n    name.value = 'name2';\n  }\n\n  @override\n  void onClose() {\n    name.value = '';\n    super.onClose();\n  }\n\n  final name = 'name1'.obs;\n\n  void changeName() => name.value = 'name3';\n}\n\nvoid main() {\n  test('''\nTest the state of the reactive variable \"name\" across all of its lifecycles''',\n      () {\n    /// Controller'ınızı lifecycle dışında test edebilirsiniz.\n    /// Fakat bunu GetX dependency injection kullanmadığınız taktirde \n    /// kullanmanız önerilmiyor.\n    final controller = Controller();\n    expect(controller.name.value, 'name1');\n\n    /// Eğer kullanıyorsanı istediğiniz her şeyi test edebilirsiniz.\n    /// Her lifecycle sonrası uygulamanızın durumu dahil olmak üzere.\n    Get.put(controller); // onInit çağrıldıktan sonra\n    expect(controller.name.value, 'name2');\n\n    /// Bu fonksoynu test edin\n    controller.changeName();\n    expect(controller.name.value, 'name3');\n\n    /// onClose çağrıldıktan sonra\n    Get.delete<Controller>();\n\n    expect(controller.name.value, '');\n  });\n}\n```\n\n#### Ipuçları\n\n##### Mockito or mocktail\nEğer GetxController/GetxService'inizi mock yapmaya ihtiyacınız varsa GetxController'dan extend etmeniz ve Mock ile mixin'lemelisiniz.\n\n```dart\nclass NotificationServiceMock extends GetxService with Mock implements NotificationService {}\n```\n\n##### Using Get.reset()\nEğer widget'ları ya da widget grupllarını test etmek istiyorsanız, testinizin sonunda Get.reset'i kullanın ya da önceki testinizden kalma tüm ayarları sıfırlayın.\n\n##### Get.testMode \nEğer controller'larınızın içinden navigation kullanmak istiyorsanız. Main'den önce  `Get.testMode = true` şeklinde kullanın.\n\n\n# 2.0 Ile Gelen Büyük Değişiklikler\n\n1- Rx Types :\n\n| Önce    |    Sonra   |\n| ------- | ---------- |\n| StringX | `RxString` |\n| IntX    | `RxInt`    |\n| MapX    | `RxMap`    |\n| ListX   | `RxList`   |\n| NumX    | `RxNum`    |\n| DoubleX | `RxDouble` |\n\nRxController ve GetBuilder şimdi birleştiler. Artık hangi controller'ı kullanmak istediğinizi hatırlamak zorunda değilsiniz. SAdece GetxController diyerek halledin. Bu simple state management ve reactive ile düzgün çalışacaktır.\n\n2- NamedRoutes\n\nÖnce:\n\n```dart\nGetMaterialApp(\n  namedRoutes: {\n    '/': GetRoute(page: Home()),\n  }\n)\n```\n\nŞimdiki:\n\n```dart\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page: () => Home()),\n  ]\n)\n```\nNeden bu değişiklik?\n\nGenellikle, hangi sayfanın bir parametreden görüntüleneceğine veya bir giriş belirteciden görüntüleneceğine karar vermek gerekebilir, önceki yaklaşım buna izin vermediği için esnek değildi.\nSayfayı bir fonksiyona sokmak, RAM tüketimini önemli ölçüde azaltır, çünkü rotalar uygulama başlatılmasından bu yana belleğe tahsis edilmeyecek ve aynı zamanda bu tür bir yaklaşım yapmasına izin verilmeyecek:\n\n```dart\n\nGetStorage box = GetStorage();\n\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page:(){\n      return box.hasData('token') ? Home() : Login();\n    })\n  ]\n)\n```\n\n# Neden Getx?\n\n1- Birçok kez Flutter güncellendikten sonra, birçok paket çalışmaz hale gelecek. Genelde derleme hataları gerçekleşir. Bu hataların hala cevabı olmayabilir. Geliştiricinin bu hatanın nerden geldiğini bilmesi gereklidir. Sonrasında bu hatayı izleyip bunun hakkında repository'de issue açması ve sorunun çözülmesini beklemelidir. Get, geliştirme için gereken ana kaynaklarını  (State, dependency ve route management) merkezde toplar, pubspec'e tek bir paket eklemeye izin verir ve çalışmaya başlar. Flutter güncellendikten sonra tek yapmanız gereken Get dependency'yi güncellemek ve çalışmaya başlamaktır. Get uyumluluk problemlerini de çözer. Paketler arasında genelde güncellemeler sonrası uyumsuzluklar olabilir. Get'in kendi içinde her şey birbiri ile uyumlu olduğundan bunun için endişelenmenize gerek yoktur.\n\n2- Flutter oldukça kolay kullanımı olan inanılmaz olmasının yanı sıra birçok geliştirici tarafından istenmeyen `Navigator.of(context).push (context, builder [...]` gibi ezber yapılar içerir. Get geliştirmeyi basitleştirir. Route çağırmak için 8 kod yazmak yerine sadece `Get.to(Home())` diyerek bir sonraki sayfaya geçebilirsin. Dynamic web urls ile çalışmak mevcut Flutter ile çalışırken zorlayıcı olabilir. Get ile durum tam tersi hal alır ve işleri çok kolay bir hale getirir. Flutter'da State'leri yönetmek için dependency'leri pub içerindeki yüzlerce kütüphane arasından seçmek birçok tartışmayı da beraberinde getiren bir konudur. Get sayesinde ekranda değişkeni otomatik olarak güncellemesini sağlamak için değişkeninizin sonuna \".obs\" eklemek ve widget'ınızı Obx ile sarmalamak yeterlidir.\n\n3- Performansı kafaya takmayın. Flutter'ın performansı zaten çok iyi. Bir de state manager kullanırken ve blocs/stores/controllers gibi sınıflarınızı locator ile yönetirken de aynı performansı aldığınızı düşünün. İhtiyacınız olmadığında  dependency'lerinizi dışarıdan çağırmak zorunda kalacaksınız. Hiç düşündünüz mü, basitçe kullandığınız controller'ınızın artık kimse tarafından kullanılmadığında kolayca bellekten silindiğini? İşte  GetX bunu yapar. SmartManagement sayesinde kullanılmayan her şey endişelenmenize gerek kalmadan otomatik olarak hafızadan silinir. Bunun için bir logic yaratmaya gerek bile kalmadan, kaynakları minimum ölçüde tükettiğinize emin olabilirsiniz. \n\n4- Gerçek ayrıştırma: \"View ile the business logic (iş mantığını) birbirlerinden ayırmak\" kavramını duymuş olabilirsiniz. Bu sadece BLoC, MVC, MVVM'ye özgü bir özellik değildir, piyasadaki diğer standart tasarım desenlerinde de mevcuttur. Ancak bu kavram Flutter'da context kullanımına bağlı olarak kolaylaştırılabilir.\nBir InheritedWidget bulabilmek için context'e ihtiyaç duyduğunuzda, bunu view'da yapmalı ya da parametre ile aktarmalıyız. Ben bu yöntemi oldukça çirkin buluyorum. Ayrıca bir ekip ile çalışırken  View'daki iş mantığına hep bağımlı olacağız. GetX standart yaklaşımı benimsemez ve StatefulWidgets, InitState, vb. yapılarını tamamen ortadan kaldırmaz. Daha temiz bir yaklaşım sunar. Controller'ların yaşam döngüleri vardır. Mesela APIREST talebi yaptığında view'a bağlı olmak zorunda değilsin. Http çağrısı başlatmak için \"onInit\" kullanabilirsiniz. Veriler geldiğinde yerleştirilecektir. GEtX tamamen reaktif  (cidden,stream'lerin altında çalışır) olduğu için tüm item'lar doldurulduğunda o değişkeni kullanan tüm widget'lar view'da otomatik olarak güncellenecektir. Bu UI uzmanlığına sahip kişilerin sadece widget'larla çalışmasını sağlar ve kullanıcı etkinlikleri dışında iş mantığına hiçbir şey göndermek zorunda değildir (bir düğmeye tıklamak gibi). İş mantığı ile çalışan insanlar, bunu ayrı olarak oluşturmak ve test etmek konusunda serbest olacaktır.\n\nBu kütüphane her zaman güncellenebilir ve yeni özellikler eklenebilir olacaktır. PR ve contribute yapmakta tamamen özgürsünüz.\n\n# Topluluk\n\n## Topluluk Kanalları\n\nGetX oldukça aktif ve yardımsever bir topluluğa sahiptir. Bu framework kullanımıyla ilgili sorularınız varsa veya herhangi bir yardım istiyorsanız, lütfen topluluk kanallarımıza katılın, sorunuz daha hızlı yanıtlanacak ki bunun için en uygun yer burasıdır. Repository'de issues açabilir ve kaynak talep edebilirsiniz.  GetX topluluğunun bir parçası olmaktan çekinmeyin.\n\n| **Slack**                                                                                                                   | **Discord**                                                                                                                 | **Telegram**                                                                                                          |\n| :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |\n| [![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx) | [![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N) | [![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g) |\n\n## Nasıl katkıda bulunulur?\n\n_Projeye katkıda bulunmak ister misiniz? Sizi destekçilerimizden biri olarak öne çıkarmaktan gurur duyacağız. İşte katkıda bulunabileceğiniz ve Get'i (ve Flutter'ı) daha da iyi hale getirebileceğiniz bazı noktalar._\n\n- Readme dosyasının diğer dillere çevrilmesine yardımcı olmak.\n- Readme'ye dokümanlar eklemek (birçok Get fonsyonu henüz belgelenmedi).\n- Get'in kullanımını öğretmek için makaleler yazabilir ya da videolar çekebilirsiniz (Bunlar Readme ve gelecekte Wiki'ye eklenecek).\n- Kod ve test PR'ları önermek.\n- Yeni fonksiyonlar eklemek.\n\nHer türlü yardım için teşekkürler.\n\n\n## Makaleler ve videolar\n\n- [Flutter Getx EcoSystem package for arabic people](https://www.youtube.com/playlist?list=PLV1fXIAyjeuZ6M8m56zajMUwu4uE3-SL0) - Tutorial by [Pesa Coder](https://github.com/UsamaElgendy).\n- [Dynamic Themes in 3 lines using GetX™](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Tutorial by [Rod Brown](https://github.com/RodBr).\n- [Complete GetX™ Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI) - Route management video by Amateur Coder.\n- [Complete GetX State Management](https://www.youtube.com/watch?v=CNpXbeI_slw) - State management video by Amateur Coder.\n- [GetX™ Other Features](https://youtu.be/ttQtlX_Q0eU) - Utils, storage, bindings and other features video by Amateur Coder.\n- [Firestore User with GetX | Todo App](https://www.youtube.com/watch?v=BiV0DcXgk58) - Video by Amateur Coder.\n- [Firebase Auth with GetX | Todo App](https://www.youtube.com/watch?v=-H-T_BSgfOE) - Video by Amateur Coder.\n- [The Flutter GetX™ Ecosystem ~ State Management](https://medium.com/flutter-community/the-flutter-getx-ecosystem-state-management-881c7235511d) - State management by [Aachman Garg](https://github.com/imaachman).\n- [The Flutter GetX™ Ecosystem ~ Dependency Injection](https://medium.com/flutter-community/the-flutter-getx-ecosystem-dependency-injection-8e763d0ec6b9) - Dependency Injection by [Aachman Garg](https://github.com/imaachman).\n- [GetX, the all-in-one Flutter package](https://www.youtube.com/watch?v=IYQgtu9TM74) - A brief tutorial covering State Management and Navigation by Thad Carnevalli.\n- [Build a To-do List App from scratch using Flutter and GetX](https://www.youtube.com/watch?v=EcnqFasHf18) - UI + State Management + Storage video by Thad Carnevalli.\n- [GetX Flutter Firebase Auth Example](https://medium.com/@jeffmcmorris/getx-flutter-firebase-auth-example-b383c1dd1de2) - Article by Jeff McMorris.\n- [Flutter State Management with GetX – Complete App](https://www.appwithflutter.com/flutter-state-management-with-getx/) - by App With Flutter.\n- [Flutter Routing with Animation using Get Package](https://www.appwithflutter.com/flutter-routing-using-get-package/) - by App With Flutter.\n- [A minimal example on dartpad](https://dartpad.dev/2b3d0d6f9d4e312c5fdbefc414c1727e?) - by [Roi Peker](https://github.com/roipeker)\n"
        },
        {
          "name": "README.ur-PK.md",
          "type": "blob",
          "size": 60.9775390625,
          "content": "﻿![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n**🌎 اردو ( Selected ✔) [| انگریزی |](README.md) [| ویتنامی |](README-vi.md) [| انڈونیشی |](README.id-ID.md) [چینی |](README.zh-cn.md) [برازیلی پرتگالی |](README.pt-br.md) [ہسپانوی |](README-es.md) [روسی |](README.ru.md) [پولش |](README.pl.md) [کورین |](README.ko-kr.md), [French](README-fr.md)**\n\n[![pub package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n[![popularity](https://badges.bar/get/popularity)](https://pub.dev/packages/sentry/score)\n[![likes](https://badges.bar/get/likes)](https://pub.dev/packages/get/score)\n[![pub points](https://badges.bar/get/pub%20points)](https://pub.dev/packages/get/score)\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n[![style: effective dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n[![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n[![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n<a href=\"https://github.com/Solido/awesome-flutter\">\n<img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n</a>\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n- [تعارف](#تعارف)\n- [انسٹال](#انسٹال)\n- [کاؤنٹرایپ](#کاؤنٹرایپ)\n- [تین ستون](#تین-ستون)\n  - [اسٹیٹ مینجمنٹ](#اسٹیٹ-مینجمنٹ)\n    - [ری ایکٹو اسٹیٹ منیجر](#ری-ایکٹو-اسٹیٹ-منیجر)\n    - [اسٹیٹ مینجمنٹ کے بارے میں مزید تفصیلات](#اسٹیٹ-مینجمنٹ-کے-بارے-میں-مزید-تفصیلات)\n  - [روٹ مینجمنٹ](#روٹ-مینجمنٹ)\n    - [روٹ مینجمنٹ کے بارے میں مزید تفصیلات](#روٹ-مینجمنٹ-کے-بارے-میں-مزید-تفصیلات)\n  - [انحصار کا انتظام](#انحصار-کا-انتظام)\n    - [انحصار کے انتظام کے بارے میں مزید تفصیلات](#انحصار-کے-انتظام-کے-بارے-میں-مزید-تفصیلات)\n- [استعمال](#استعمال)\n  - [عالمگیریت](#عالمگیریت)\n    - [ترجمہ](#ترجمہ)\n      - [ترجمہ کا استعمال](#ترجمہ-کا-استعمال)\n    - [مقامی](#مقامی)\n      - [مقام کی تبدیلی](#مقام-کی-تبدیلی)\n      - [سسٹم لوکیشن](#سسٹم-لوکیشن)\n  - [تھیم کی تبدیلی](#تھیم-کی-تبدیلی)\n  - [رابطے کا قیام](#رابطے-کا-قیام)\n    - [ڈیفالٹ کنکشن کا قیام](#ڈیفالٹ-کنکشن-کا-قیام)\n    - [خود سے رابطے کا قیام](#خود-سے-رابطے-کا-قیام)\n  - [گیٹ پیج مڈل ویئر](#گیٹ-پیج-مڈل-ویئر)\n    - [ترجیح](#ترجیح)\n    - [ری ڈائریکٹ](#ری-ڈائریکٹ)\n    - [جب پیج کی درخواست کی جائے](#جب-پیج-کی-درخواست-کی-جائے)\n    - [آنبائنڈنگ اسٹارٹ](#آنبائنڈنگ-اسٹارٹ)\n    - [آنپیج بلڈ اسٹارٹ](#آنپیج-بلڈ-اسٹارٹ)\n    - [جب پیج لوڈ ہو](#جب-پیج-لوڈ-ہو)\n    - [جب صفحہ تصرف ہوجائے](#جب-صفحہ-تصرف-ہوجائے)\n  - [دوسرے اعلی درجے کی APIs](#دوسرے-اعلی-درجے-کی-apis)\n    - [اختیاری عالمی ترتیبات اور دستی تشکیلات](#اختیاری-عالمی-ترتیبات-اور-دستی-تشکیلات)\n    - [مقامی اسٹیٹ ویجٹ](#مقامی-اسٹیٹ-ویجٹ)\n      - [ویلیو بلڈر](#ویلیو-بلڈر)\n      - [اوبکس ویلیو](#اوبکس-ویلیو)\n  - [کارآمد نکات](#کارآمد-نکات)\n      - [گیٹ ویو](#گیٹ-ویو)\n      - [گیٹ ویجٹ](#گیٹ-ویجٹ)\n      - [گیٹکس سروس](#گیٹکس-سروس)\n- [پچھلے ورژن سے اہم تبدیلیاں](#پچھلے-ورژن-سے-اہم-تبدیلیاں)\n- [گیٹکس کیوں؟](#گیٹکس-کیوں)\n- [سماجی خدمات](#سماجی-خدمات)\n  - [کمیونٹی چینلز](#کمیونٹی-چینلز)\n  - [کس طرح شراکت کریں](#کس-طرح-شراکت-کریں)\n  - [مضامین اور ویڈیوز](#مضامین-اور-ویڈیوز)\n\n# تعارف\n\nگیٹ ایکس  اسٹیٹ مینجمنٹ کے لئے ایک ہلکا پھلکا اور طاقتور حل ہے۔ یہ تیز اور عملی انداز میں اعلی کارکردگی والی اسٹسٹ مینجمنٹ ، ذہین انحصار انجکشن ، اور روٹ مینجمنٹ کو یکجا کرتا ہے۔ گیٹ ایکس کے 3 بنیادی اصول ہیں ، اس کا مطلب یہ ہے کہ لائبریری میں موجود تمام وسائل کی ترجیح یہی ہے: **پروڈکٹیوٹی,  کارکردگی اور تنظیم**\n\n **پروڈکٹیوٹی :** گیٹ ایکس کارکردگی اور وسائل کی کم سے کم کھپت پر مرکوز ہے۔ گیٹ ایکس اسٹریمز یا چینج نوٹیفائر استعمال نہیں کرتا ہے۔\n  \n **کارکردگی :** گیٹ ایکس ایک آسان اور خوشگوار ترکیب استعمال کرتا ہے۔ اس سے کوئی فرق نہیں پڑتا ہے کہ آپ کیا کرنا چاہتے ہیں ، گیٹ-ایکس کے ساتھ ہمیشہ ایک آسان راستہ رہتا ہے۔ اس سے کوڈنگ کے کئی گھنٹوں کی بچت ہوگی اور یہ آپ کی ایپلیکیشن فراہم کرنے والی زیادہ سے زیادہ کارکردگی کو نکال دے گی۔ عام طور پر ، ڈویلپر میموری سے کنٹرولرز کو ہٹانے سے متعلق رہنا چاہئے۔ گیٹ-ایکس کے ساتھ یہ ضروری نہیں ہے ، کیونکہ وسائل میموری سے حذف ہوجاتے ہیں جب وہ بطور ڈیفالٹ استعمال نہیں ہوتے ہیں۔ اگر آپ اسے یاد میں رکھنا چاہتے ہیں تو ، آپ کو اپنی انحصار میں واضح طور پر \"مستقل: سچ\" کا اعلان کرنا ہوگا۔ اس طرح ، وقت کی بچت کے علاوہ ، آپ کو میموری پر غیر ضروری انحصار کرنے کا خطرہ بھی کم ہوتا ہے۔ انحصار لوڈنگ ڈیفالٹ کے لحاظ سے بھی سست ہے۔\n\n **تنظیم :** گیٹ-ایکس کی مدد سے منظر ، نمائش کی منطق ، کاروباری منطق ، انحصار انجیکشن ، اور نیویگیشن کی مجموعی ڈوپولنگ کی اجازت دیتا ہے۔ راستوں کے مابین تشریف لے جانے کے لئے سیاق و سباق کی ضرورت نہیں ہے ، لہذا ، آپ اس کے لئے ویجیٹ ٹری (ویژنائزیشن) پر منحصر نہیں ہیں۔ وراثت میں ملنے والے ویجیٹ کے ذریعے اپنے کنٹرولرز / بلاکس تک رسائی حاصل کرنے کے لئے سیاق و سباق کی ضرورت نہیں ہے ، لہذا آپ اپنی پریزنٹیشن منطق اور کاروباری منطق کو اپنی نظریاتی پرت سے مکمل طور پر ڈوپل کرتے ہیں۔ آپ کو متعدد فراہم کنندگان کے ذریعہ اپنے ویجیٹ ٹری میں اپنے کنٹرولرز / ماڈلز / بلاکس کی کلاسیں انجیکشن کرنے کی ضرورت نہیں ہے ، کیونکہ یہ گیٹ ایکس اپنی انحصار انجیکشن کی خصوصیت استعمال کرتا ہے ، جس سے ڈی آئی کو اس کے نظارے کو مکمل طور پر خارج کردیتی ہے۔ گیٹ-ایکس کے ذریعے آپ جانتے ہو کہ اپنی درخواست کی ہر خصوصیت کو کہاں تلاش کرنا ہے ، بطور ڈیفالٹ صاف ستھرا۔ بحالی کی سہولت فراہم کرنے کے علاوہ ، یہ ماڈیولوں کی شیئرنگ کو بھی یقینی بناتا ہے ، ایسی کوئی چیز جو اس وقت تک پھڑپھڑ پھینک کر ناقابل فہم تھی ، اور کچھ مکمل طور پر ممکن تھا۔\nبی ایل او سی پھڑپھڑا میں کوڈ کو منظم کرنے کا نقطہ آغاز تھا ، یہ کاروباری منطق کو تصور سے الگ کرتا ہے۔ گیٹ ایکس اس کا فطری ارتقا ہے ، جس سے نہ صرف کاروباری منطق کو الگ کیا جائے بلکہ پیش کش کی منطق بھی۔ انحصار اور راستوں کا بونس انجیکشن بھی ڈوپل ہوچکا ہے ، اور ڈیٹا لیئر ان سب سے باہر ہے۔ آپ جانتے ہیں کہ سب کچھ کہاں ہے ، اور یہ سب کچھ ہیلو دنیا کی تعمیر سے زیادہ آسان طریقے سے ہے۔ گیٹ-ایکس ، فلٹر ایس ڈی کے کے ساتھ اعلی کارکردگی کی ایپلی کیشنز کی تعمیر کا آسان ترین ، عملی اور اسکیل ایبل طریقہ ہے ، جس کے ارد گرد ایک بہت بڑا ماحولیاتی نظام ہے جو کامل کے ساتھ مل کر کام کرتا ہے ، ابتدائی افراد کے لئے آسان اور ماہرین کے لئے درست ہے۔ یہ محفوظ ، مستحکم ، تازہ ترین ہے ، اور APIs کی ایک بہت بڑی رینج پیش کرتا ہے جو پہلے سے طے شدہ فلوٹر SDK پر موجود نہیں ہے۔\n\nگیٹ ایکس پھولا ہوا نہیں ہے۔ اس میں بہت ساری خصوصیات ہیں جو آپ کو کسی بھی چیز کی فکر کیے بغیر پروگرامنگ شروع کرنے کی اجازت دیتی ہیں ، لیکن ان خصوصیات میں سے ہر ایک الگ الگ کنٹینر میں ہے ، اور صرف استعمال کے بعد شروع کی گئی ہے۔ اگر آپ صرف اسٹیٹ مینجمنٹ کا استعمال کرتے ہیں تو صرف اسٹیٹ مینجمنٹ مرتب کی جائے گی۔ اگر آپ صرف راستے ہی استعمال کرتے ہیں تو ، اسٹیٹ مینجمنٹ کی طرف سے کوئی بھی چیز مرتب نہیں کی جائے گی۔\n\nگیٹ ایکس میں ایک بہت بڑا ماحولیاتی نظام ، ایک بڑی برادری ، بڑی تعداد میں تعاون کار موجود ہے ، اور جب تک پھڑپھڑ موجود ہے اس کو برقرار رکھا جائے گا۔ گیٹ ایکس بھی اسی کوڈ کے ساتھ اینڈروئیڈ ، آئی او ایس ، ویب ، میک ، لینکس ، ونڈوز اور اپنے سرور پر چلنے کے قابل ہے۔\n**یہ ممکن ہے کہ اپنے پس منظر میں فرنٹ اینڈ پر تیار کردہ اپنے کوڈ کو پوری طرح سے استعمال کریں [گیٹ ایکس سرور](https://github.com/jonataslaw/get_server)**.\n\n**اس کے علاوہ ، سرور پر اور سامنے والے اختتام پر ، پوری ترقی کا عمل مکمل طور پر خودکار ہوسکتا ہے [CLI حاصل کریں](https://github.com/jonataslaw/get_cli)**.\n\n**اس کے علاوہ ، آپ کی پیداوری کو مزید بڑھانے کے لئے ، ہمارے پاس ہے\n[VSCode](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets) اور [Android Studio/Intellij](https://plugins.jetbrains.com/plugin/14975-getx-snippets)**\n\n# انسٹال\nکوڈ میں گیٹ ایکس کی تنصیب\n```yaml\n# pubspec.yaml\ndependencies:\n  get:\n```\nان فائلوں میں امپورٹ کریں جو استعمال ہوں گی\n```dart\nimport 'package:get/get.dart';\n```\n\n# کاؤنٹرایپ\n\nگیٹ-ایکس کی طاقت کو ظاہر کرنے کے ل I ، میں یہ ظاہر کروں گا کہ کس طرح ہر کلک کے ساتھ \"کاؤنٹر\" بنانا ہے ، کس طرح صفحات کے مابین تبادلہ کرنا اور اسکرینوں کے درمیان اسٹسٹ کو مشترکہ انداز میں بانٹنا ، کاروباری منطق کو صرف نظر سے الگ کرنا ، 26 لائنز کوڈ شامل تبصرے۔\n\n- پہلا قدم :\n  اپنے میٹریل ایپ سے پہلے \"گیٹ\" شامل کریں ، اسے گیٹ میٹریئل ایپ میں تبدیل کریں\n\n```dart\nvoid main() => runApp(GetMaterialApp(home: Home()));\n```\n\nنوٹ: اس سے مٹیریل ایپ میں ترمیم نہیں ہوتی ، گیٹ میٹیرال ایپ کوئی ترمیم شدہ میٹریل ایپ نہیں ہے ، یہ ایک کنفیگریڈ ویجیٹ ہے ، جس میں بطور سی سی فلڈ میٹریل ایپ ہے۔ آپ اسے دستی طور پر تشکیل دے سکتے ہیں ، لیکن یہ یقینی طور پر ضروری نہیں ہے۔ گیٹ میٹریئل ایپ راستوں کو تخلیق کرے گی ، انہیں انجیکشن دے گی ، ترجمہ انجیکشن کرے گی ، روٹ نیویگیشن کے لئے آپ کی ضرورت کی ہر چیز کو انجیکشن دے گی۔ اگر آپ صرف ریاستی انتظام یا انحصار کے انتظام کے لئے گیٹیکس کا استعمال کرتے ہیں تو ، گیٹ میٹریئل ایپ کو استعمال کرنے کی ضرورت نہیں ہے۔ گیٹ میٹیرال ایپ راستوں ، سنیکبارز ، عالمگیریت ، نچلی شیٹس ، مکالموں ، اور روٹس سے متعلق اعلی سطحی اپس اور سیاق و سباق کی عدم موجودگی کے لئے ضروری ہے۔\nیہ اقدام صرف اس صورت میں ضروری ہے اگر آپ روٹ مینجمنٹ کا استعمال کریں گے (`Get.to()`, `Get.back()`). اگر آپ اسے استعمال نہیں کریں گے تو پھر ضروری نہیں ہے کہ قدم 1 کریں\n\n- دوسرا مرحلہ :\n  اپنی کاروباری منطق کلاس بنائیں اور اس کے اندر تمام متغیرات ، طریقے اور کنٹرولر رکھیں۔\n   کا استعمال کرتے ہوئے کسی بھی متغیر کو قابل مشاہدہ کرسکتے ہیں \".obs\".\n\n```dart\nclass Controller extends GetxController{\n  var count = 0.obs;\n  increment() => count++;\n}\n```\n\n- تیسرا قدم :\n  اپنا نظارہ بنائیں ، اسٹیٹ لیس ویجیٹ استعمال کریں اور کچھ رام کو بچائیں ، گیٹ-ایکس کی مدد سے آپ کو اب اسٹیٹ فل ویجٹ استعمال کرنے کی ضرورت نہیں ہوگی۔\n\n```dart\nclass Home extends StatelessWidget {\n\n  @override\n  Widget build(context) {\n    // آپ کی کلاس کا آغاز\n    // Instantiate your class using Get.put() to make it available for all \"child\" routes there.\n    final Controller c = Get.put(Controller());\n\n    return Scaffold(\n      // Use Obx(()=> to update Text() whenever count is changed.\n      appBar: AppBar(title: Obx(() => Text(\"Clicks: ${c.count}\"))),\n\n      // Replace the 8 lines Navigator.push by a simple Get.to(). You don't need context\n      body: Center(child: ElevatedButton(\n              child: Text(\"Go to Other\"), onPressed: () => Get.to(Other()))),\n      floatingActionButton:\n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n  }\n}\n\nclass Other extends StatelessWidget {\n  // You can ask Get to find a Controller that is being used by another page and redirect you to it.\n  final Controller c = Get.find();\n\n  @override\n  Widget build(context){\n     // Access the updated count variable\n     return Scaffold(body: Center(child: Text(\"${c.count}\")));\n  }\n}\n```\n\nنتیجہ\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/counter-app-gif.gif)\nیہ ایک سادہ پروجیکٹ ہے لیکن اس سے پہلے ہی یہ واضح ہوجاتا ہے کہ گیٹ کتنا طاقتور ہے۔ جیسے جیسے آپ کا پروجیکٹ بڑھتا جائے گا ، یہ فرق مزید نمایاں ہوتا جائے گا۔\nگیٹ کو ٹیموں کے ساتھ کام کرنے کے لئے ڈیزائن کیا گیا تھا ، لیکن اس سے ایک فرد ڈویلپر کا کام آسان ہوجاتا ہے۔\nاپنی آخری تاریخ کو بہتر بنائیں ، کارکردگی کو کھونے کے بغیر وقت پر سب کچھ فراہم کریں۔ اگر آپ نے اس جملے کی نشاندہی کی ہے تو ، گیٹ-ایکس آپ کے لئے ہے!\n# تین ستون\n## اسٹیٹ مینجمنٹ\nگیٹ کے دو مختلف مینیجر ہوتے ہیں: سادہ ریاستی مینیجر (ہم اسے گیٹ بلڈر کہیں گے) اور رد عمل کا مظاہرہ کرنے والے مینیجر (گیٹ-ایکس / اوب-ایکس)\n### ری ایکٹو اسٹیٹ منیجر\nری ایکٹیو پروگرامنگ بہت سے لوگوں کو اجنبی بنا سکتا ہے کیونکہ ایسا کہا جاتا ہے کہ یہ پیچیدہ ہے۔ گیٹ ایکس نے رد عمل مندانہ پروگرامنگ کو کسی آسان چیز میں تبدیل کردیا:\n- آپ کو اسٹریمکنٹرولر بنانے کی ضرورت نہیں ہوگی\n- آپ کو ہر متغیر کے لئے ایک اسٹریم بلڈر بنانے کی ضرورت نہیں ہوگی\n- آپ کو ہر ریاست کے لئے کلاس بنانے کی ضرورت نہیں ہوگی\n- آپ کو ابتدائی قدر کے لئے گیٹ ایکس بنانے کی ضرورت نہیں ہوگی\n- آپ کو کوڈ جنریٹر استعمال کرنے کی ضرورت نہیں ہوگی\n\n\nگیٹ-ایکس کے ساتھ قابل عمل پروگرامنگ اتنا ہی آسان ہے جتنا سیٹ اسٹیٹ کے استعمال سے۔\n\nآئیے تصور کریں کہ آپ کے پاس متغیر ہے اور چاہتے ہیں کہ جب بھی آپ اسے تبدیل کریں ، اس کا استعمال کرنے والے تمام وجیٹس خود بخود تبدیل ہوجائیں۔\n\nیہ آپ کی گنتی متغیر ہے:\n\n```dart\nvar name = 'Jonatas Borges';\n```\n\n\".obs\" اسے مشاہدہ کرنے کے لئے؛ آپ کو اس کے آخر میں  شامل کرنے کی ضرورت ہے\n\n```dart\nvar name = 'Jonatas Borges'.obs;\n```\n\nاور صارف کے انٹرفیس میں ، جب آپ اس نمبر کو دکھانا چاہتے ہیں اور جب بھی اس کی اہمیت بدل جاتی ہے تو اسکرین کو اپ ڈیٹ کرنا چاہتے ہیں ، صرف یہ کریں:\n\n```dart\nObx(() => Text(\"${controller.name}\"));\n```\n\nبس۔ یہ آسان ہے.\n\n### اسٹیٹ مینجمنٹ کے بارے میں مزید تفصیلات\n\n**اسٹیٹ مینجمنٹ کی مزید گہرائی سے وضاحت ملاحظہ کریں [یہاں](./documentation/en_US/state_management.md).  وہاں آپ مزید مثالیں دیکھیں گے اور آسان ریاستی مینیجر اور رد عمل ریاست کے مینیجر کے مابین بھی فرق**\n\nآپ کو گیٹ ایکس پاور کا ایک اچھا خیال ملے گا۔\n\n## روٹ مینجمنٹ\nاگر آپ سیاق و سباق کے بغیر راستے / سنیکبارز / مکالمے / بوتل شیٹ استعمال کرنے جارہے ہیں تو گیٹ ایکس آپ کے لئے بھی بہترین ہے ، بس اسے دیکھیں:\nاپنے میٹریل ایپ سے پہلے \"گیٹ\" شامل کریں ، اسے گیٹ میٹریئل ایپ میں تبدیل کریں\n```dart\nGetMaterialApp( // Before: MaterialApp(\n  home: MyHome(),\n)\n```\n\nنئی اسکرین پر جائیں:\n\n```dart\n\nGet.to(NextScreen());\n```\n\nنام کے ساتھ نئی اسکرین پر جائیں۔ نامزد راستوں کے بارے میں مزید تفصیلات دیکھیں [یہاں](./documentation/en_US/route_management.md#navigation-with-named-routes)\n\n```dart\n\nGet.toNamed('/details');\n```\n\nسنیک بار ، ڈائیلاگ ، نیچے شیٹ کو بند کریں \nNavigator.pop(context);\n\n```dart\nGet.back();\n```\n\nاگلی اسکرین پر جانے کے لئے اور پچھلی اسکرین پر واپس جانے کا کوئی آپشن نہیں (اسپلش اسکرین ، لاگ ان اسکرینوں وغیرہ میں استعمال کیلئے)\n\n```dart\nGet.off(NextScreen());\n```\n\nاگلی سکرین پر جانے اور پچھلے سبھی راستوں کو منسوخ کرنے کے لئے (شاپنگ کارٹس ، پولز اور ٹیسٹوں میں کارآمد)\n\n```dart\nGet.offAll(NextScreen());\n```\n\nغور کیا کہ آپ کو ان میں سے کوئی بھی کام کرنے کے لئے سیاق و سباق کا استعمال نہیں کرنا پڑا؟ گیٹ روٹ مینجمنٹ کو استعمال کرنے کا سب سے بڑا فائدہ یہ ہے۔ اس کی مدد سے ، آپ اپنے کنٹرولر کلاس کے اندر ، تشویش کے بغیر ، ان تمام طریقوں کو انجام دے سکتے ہیں۔\n\n### روٹ مینجمنٹ کے بارے میں مزید تفصیلات\n\n**گیٹ ایکس نامی روٹ کے ساتھ کام کرتا ہے اور اپنے راستوں پر نچلی سطح کا کنٹرول بھی پیش کرتا ہے! ایک گہرائی میں دستاویزات موجود ہیں [یہاں](./documentation/en_US/route_management.md)**\n\n## انحصار کا انتظام\n\nگیٹ ایکس کے پاس ایک سادہ اور طاقتور انحصار منیجر ہے جو آپ کو اپنے بلاک یا کنٹرولر کی طرح ایک ہی کلاس کو دوبارہ حاصل کرنے کی سہولت دیتا ہے جس میں کوڈ کی صرف 1 لائنز ، کوئی فراہم کنندہ سیاق و سباق ، کوئی وراثت والا ویجٹ نہیں ہے۔\n\n```dart\nController controller = Get.put(Controller()); // Rather Controller controller = Controller();\n```\nنوٹ: اگر آپ گیٹ اسٹیٹ منیجر استعمال کررہے ہیں تو ، اے پی آئی کی پابندیوں پر زیادہ توجہ دیں ، جس سے آپ کے قول کو اپنے کنٹرولر سے مربوط کرنے میں آسانی ہوگی۔\n\nآپ جس کلاس کو استعمال کررہے ہیں اس میں اپنی کلاس کو تیز کرنے کے بجائے ، آپ اسے حاصل کریں مثال کے طور پر اندر داخل کررہے ہیں ، جس سے یہ آپ کے ایپ میں دستیاب ہوگا۔\nلہذا آپ اپنے کنٹرولر (یا کلاس بلاک) کو عام طور پر استعمال کرسکتے ہیں\n\n**اشارہ:**گیٹ ایکس انحصار کا انتظام پیکیج کے دوسرے حصوں سے گر گیا ہے ، لہذا اگر مثال کے طور پر آپ کی ایپ پہلے ہی اسٹیٹ مینیجر کو استعمال کررہی ہے (کوئی بھی ، اس سے کوئی فرق نہیں پڑتا ہے) ، آپ کو یہ سب کچھ دوبارہ لکھنے کی ضرورت نہیں ہے ، آپ اس انحصار کو استعمال کرسکتے ہیں۔\n```dart\ncontroller.fetchApi();\n```\n\nذرا تصور کریں کہ آپ نے متعدد راستوں سے گھوما ہوا ہے ، اور آپ کو ایک ایسے ڈیٹا کی ضرورت ہے جو آپ کے کنٹرولر میں پیچھے رہ گیا ہو ، آپ کو فراہم کنندہ یا گیٹ_یٹ کے ساتھ مل کر ایک ریاستی مینیجر کی ضرورت ہوگی ، صحیح؟ گیٹ ایکس کے ساتھ نہیں۔ آپ کو اپنے کنٹرولر کے ل \"\" ڈھونڈنے \"کے لئے گیٹ ایکس سے پوچھنے کی ضرورت ہے ، آپ کو کسی بھی اضافی انحصار کی ضرورت نہیں ہے۔\n\n```dart\nController controller = Get.find();\n```\n\nاور پھر آپ اپنا کنٹرولر ڈیٹا دوبارہ حاصل کرنے میں کامیاب ہوجائیں گے جو وہاں واپس حاصل کیا گیا تھا\n\n```dart\nText(controller.textFromApi);\n```\n\n### انحصار کے انتظام کے بارے میں مزید تفصیلات\n\n**انحصار کے انتظام کی مزید گہرائی سے وضاحت ملاحظہ کریں [یہاں](./documentation/en_US/dependency_management.md)**\n\n# استعمال\n\n## عالمگیریت\n\n### ترجمہ\n\nترجمہ کو ایک آسان کلیدی قدر والے لغت کے نقشے کے طور پر رکھا جاتا ہے۔\nحسب ضرورت ترجمہ شامل کرنے کے لئے ، ایک کلاس تشکیل دیں اور توسیع کریں \n`Translations`\n```dart\nimport 'package:get/get.dart';\n\nclass Messages extends Translations {\n  @override\n  Map<String, Map<String, String>> get keys => {\n        'en_US': {\n          'hello': 'Hello World',\n        },\n        'de_DE': {\n          'hello': 'Hallo Welt',\n        }\n      };\n}\n```\n\n#### ترجمہ کا استعمال\n\nبس ضمیمہ کریں `.tr` مخصوص کی میں اور اس کی موجودہ قیمت کا استعمال کرتے ہوئے ترجمہ کیا جائے گا`Get.locale` اور `Get.fallbackLocale`.\n\n```dart\nText('title'.tr);\n```\n\n### مقامی\n\nمقام اور ترجمے کی وضاحت کے لئے پیرامیٹرز کو `گیٹ میٹیرال ایپ` پاس کریں۔\n\n```dart\nreturn GetMaterialApp(\n    translations: Messages(), // your translations\n    locale: Locale('en', 'US'), // translations will be displayed in that locale\n    fallbackLocale: Locale('en', 'UK'), // specify the fallback locale in case an invalid locale is selected.\n);\n```\n\n#### مقام کی تبدیلی\n\nلوکل کو اپ ڈیٹ کرنے کے لئے کال کریں گیٹ۔ اپ ڈیٹ لوکل (لوکل)۔ پھر ترجمے خود بخود نیا مقام استعمال کرتے ہیں۔\n\n```dart\nvar locale = Locale('en', 'US');\nGet.updateLocale(locale);\n```\n\n#### سسٹم لوکیشن\n\nڈیوائس لوکل حاصل کرنے کے لئے اس لائن کو استعمال کریں\n\n```dart\nreturn GetMaterialApp(\n    locale: Get.deviceLocale,\n);\n```\n\n## تھیم کی تبدیلی\n\nبرائے کرم `گیٹ میٹرال ایپ` سے زیادہ کسی بھی اعلی سطح کے ویجیٹ کو اپ ڈیٹ کرنے کیلئے استعمال نہ کریں۔ اس سے ڈپلیکیٹ کیز کو متحرک کیا جاسکتا ہے۔ بہت سارے لوگ صرف اپنی ایپ کے تھیم کو تبدیل کرنے کے لئے \"تھیم پیڈائزر\" ویجیٹ بنانے کے پراگیتہاسک نقطہ نظر کے عادی ہیں ، اور یہ ** گیٹ ایکس ™ ** کے ساتھ یقینی طور پر ضروری نہیں ہے۔\n\nآپ اپنا کسٹم تھیم تشکیل دے سکتے ہیں اور اس کے لئے کسی بھی بوائلر پلیٹ کے بغیر اسے `گیٹ.چینج تھیم` میں شامل کرسکتے ہیں:\n\n```dart\nGet.changeTheme(ThemeData.light());\n```\n\n\nاگر آپ بٹن کی طرح کوئی چیز بنانا چاہتے ہیں جو تھیم کو `آن ٹیپ میں تبدیل کردے ، تو آپ اس کے لئے دو ** گیٹ ایکس ™ ** اے پی پی کو جوڑ سکتے ہیں:\n\n- اے پی آئی جو چیک کرتا ہے کہ آیا گہرا `تھیم` استعمال کیا جارہا ہے۔\n- اور `تھیم` کی تبدیلی ، آپ اسے صرف `آن پیسڈ` میں ڈال سکتے ہیں۔\n\n```dart\nGet.changeTheme(Get.isDarkMode? ThemeData.light(): ThemeData.dark());\n```\n\nجب ڈارک موڈ چالو ہوجاتا ہے ، تو وہ _ لائٹ تھیم_ میں تبدیل ہوجائے گا ، اور جب _ لائٹ تھیم_ فعال ہوجائے گا ، تو یہ _ ڈارک تھیم_ میں بدل جائے گا۔\n\n## رابطے کا قیام\nگیٹ کنیکٹ آپ کی پیٹھ سے اپنے سامنے تک HTTP یا ویب ساکٹس کے ذریعہ مواصلت کرنے کا ایک آسان طریقہ ہے\n\n### ڈیفالٹ کنکشن کا قیام\nآپ آرام سے گیٹ کنیکٹ کو بڑھا سکتے ہیں اور GET / POST / PUT / DELETE / SOCKET طریقوں کو اپنے ریسٹ API یا ویب ساکٹس کے ساتھ بات چیت کرسکتے ہیں۔\n\n```dart\nclass UserProvider extends GetConnect {\n  // Get request\n  Future<Response> getUser(int id) => get('http://youapi/users/$id');\n  // Post request\n  Future<Response> postUser(Map data) => post('http://youapi/users', body: data);\n  // Post request with File\n  Future<Response<CasesModel>> postCases(List<int> image) {\n    final form = FormData({\n      'file': MultipartFile(image, filename: 'avatar.png'),\n      'otherFile': MultipartFile(image, filename: 'cover.png'),\n    });\n    return post('http://youapi/users/upload', form);\n  }\n\n  GetSocket userMessages() {\n    return socket('https://yourapi/users/socket');\n  }\n}\n```\n### خود سے رابطے کا قیام\n\nگیٹ کنیکٹ انتہائی حسب ضرورت ہے آپ درخواست کو تبدیل کرنے والے ، جواب دہندگان کے بطور ، جواب دہندگان کی حیثیت سے ، ایک مستند کی وضاحت ، اور حتی کہ کوششوں کی تعداد بھی کرسکتے ہیں جس میں وہ خود کو مستند کرنے کی کوشش کرے گی ، اس کے علاوہ یہ ایک معیاری ڈیکوڈر کی وضاحت کے امکان کو بھی فراہم کرے گی جو تبدیل ہوجائے گی۔ آپ کی ساری درخواستیں آپ میں اضافی تشکیل کے بغیر ماڈل کرتی ہیں۔\n\n```dart\nclass HomeProvider extends GetConnect {\n  @override\n  void onInit() {\n    // All request will pass to jsonEncode so CasesModel.fromJson()\n    httpClient.defaultDecoder = CasesModel.fromJson;\n    httpClient.baseUrl = 'https://api.covid19api.com';\n    // baseUrl = 'https://api.covid19api.com'; // It define baseUrl to\n    // Http and websockets if used with no [httpClient] instance\n\n    // It's will attach 'apikey' property on header from all requests\n    httpClient.addRequestModifier((request) {\n      request.headers['apikey'] = '12345678';\n      return request;\n    });\n\n    // Even if the server sends data from the country \"Brazil\",\n    // it will never be displayed to users, because you remove\n    // that data from the response, even before the response is delivered\n    httpClient.addResponseModifier<CasesModel>((request, response) {\n      CasesModel model = response.body;\n      if (model.countries.contains('Brazil')) {\n        model.countries.remove('Brazilll');\n      }\n    });\n\n    httpClient.addAuthenticator((request) async {\n      final response = await get(\"http://yourapi/token\");\n      final token = response.body['token'];\n      // Set the header\n      request.headers['Authorization'] = \"$token\";\n      return request;\n    });\n\n    //Autenticator will be called 3 times if HttpStatus is \n    //HttpStatus.unauthorized\n    httpClient.maxAuthRetries = 3;\n  }\n\n  @override\n  Future<Response<CasesModel>> getCases(String path) => get(path);\n}\n```\n\n## گیٹ پیج مڈل ویئر\n\nگیٹ پیج کے پاس اب نئی پراپرٹی ہے جو گیٹ میڈل ویئر کی فہرست لیتی ہے اور انہیں مخصوص ترتیب میں چلاتی ہے۔\n\nنوٹ: جب گیٹ پیج کے مڈل ویئرز ہوں گے تو ، اس صفحے کے سبھی بچوں میں ایک جیسے مڈل ویئرز خودبخود ہوں گے۔\n\n### ترجیح\n\nمڈل ویئر کو چلانے کا آرڈر گیٹ میڈل ویئر میں ترجیحی طور پر ترتیب دیا جاسکتا ہے۔\n\n```dart\nfinal middlewares = [\n  GetMiddleware(priority: 2),\n  GetMiddleware(priority: 5),\n  GetMiddleware(priority: 4),\n  GetMiddleware(priority: -8),\n];\n```\nوہ مڈل ویئر اسی ترتیب سے چلائے جائیں گے **-8 => 2 => 4 => 5**\n\n### ری ڈائریکٹ\n\nاس فنکشن کو اس وقت کہا جائے گا جب کال والے راستے کے صفحے کی تلاش کی جا رہی ہو۔ اس کو ری ڈائریکٹ کرنے کے نتیجے میں روٹ سیٹنگز لیتے ہیں۔ یا اسے کالعدم کردیں اور کوئی ردوبدل نہیں ہوگا۔\n\n```dart\nRouteSettings redirect(String route) {\n  final authService = Get.find<AuthService>();\n  return authService.authed.value ? null : RouteSettings(name: '/login')\n}\n```\n\n### جب پیج کی درخواست کی جائے\n\nجب اس صفحے کو کچھ بھی تخلیق کرنے سے پہلے بلایا جائے گا تو اس فنکشن کو کہا جائے گا\nآپ اسے صفحہ کے بارے میں کچھ تبدیل کرنے یا نیا صفحہ دینے کیلئے استعمال کرسکتے ہیں\n\n```dart\nGetPage onPageCalled(GetPage page) {\n  final authService = Get.find<AuthService>();\n  return page.copyWith(title: 'Welcome ${authService.UserName}');\n}\n```\n\n### آنبائنڈنگ اسٹارٹ\n\nاس فنکشن کو بائنڈنگ شروع کرنے سے پہلے ہی کہا جائے گا۔\nیہاں آپ اس صفحے کے لئے پابندیوں کو تبدیل کرسکتے ہیں۔\n\n```dart\nList<Bindings> onBindingsStart(List<Bindings> bindings) {\n  final authService = Get.find<AuthService>();\n  if (authService.isAdmin) {\n    bindings.add(AdminBinding());\n  }\n  return bindings;\n}\n```\n\n### آنپیج بلڈ اسٹارٹ\n\nاس فنکشن کو بائنڈنگ شروع کرنے کے بعد ہی کہا جائے گا۔\nیہاں آپ اس کے بعد اور پیج ویجیٹ بنانے سے پہلے پابندیوں کو تخلیق کرنے کے بعد کچھ کرسکتے ہیں۔\n\n```dart\nGetPageBuilder onPageBuildStart(GetPageBuilder page) {\n  print('bindings are ready');\n  return page;\n}\n```\n\n### جب پیج لوڈ ہو\n\nاس فنکشن کو گیٹ پیج ڈاٹ پیج فنکشن کے بلانے کے ٹھیک ہی بعد میں کہا جائے گا اور آپ کو اس فنکشن کا نتیجہ پیش کرے گا۔ اور دکھایا جائے گا کہ ویجیٹ لے لو.\n\n### جب صفحہ تصرف ہوجائے\n\nاس فنکشن کو صفحے کے تمام متعلقہ اشیاء (کنٹرولرز ، آراء ، ...) کو ضائع کرنے کے بعد ہی کہا جائے گا۔\n\n## دوسرے اعلی درجے کی APIs\n\n```dart\n// give the current args from currentScreen\nGet.arguments\n\n// give name of previous route\nGet.previousRoute\n\n// give the raw route to access for example, rawRoute.isFirst()\nGet.rawRoute\n\n// give access to Routing API from GetObserver\nGet.routing\n\n// check if snackbar is open\nGet.isSnackbarOpen\n\n// check if dialog is open\nGet.isDialogOpen\n\n// check if bottomsheet is open\nGet.isBottomSheetOpen\n\n// remove one route.\nGet.removeRoute()\n\n// back repeatedly until the predicate returns true.\nGet.until()\n\n// go to next route and remove all the previous routes until the predicate returns true.\nGet.offUntil()\n\n// go to next named route and remove all the previous routes until the predicate returns true.\nGet.offNamedUntil()\n\n//Check in what platform the app is running\nGetPlatform.isAndroid\nGetPlatform.isIOS\nGetPlatform.isMacOS\nGetPlatform.isWindows\nGetPlatform.isLinux\nGetPlatform.isFuchsia\n\n//Check the device type\nGetPlatform.isMobile\nGetPlatform.isDesktop\n//All platforms are supported independently in web!\n//You can tell if you are running inside a browser\n//on Windows, iOS, OSX, Android, etc.\nGetPlatform.isWeb\n\n\n// Equivalent to : MediaQuery.of(context).size.height,\n// but immutable.\nGet.height\nGet.width\n\n// Gives the current context of the Navigator.\nGet.context\n\n// Gives the context of the snackbar/dialog/bottomsheet in the foreground, anywhere in your code.\nGet.contextOverlay\n\n// Note: the following methods are extensions on context. Since you\n// have access to context in any place of your UI, you can use it anywhere in the UI code\n\n// If you need a changeable height/width (like Desktop or browser windows that can be scaled) you will need to use context.\ncontext.width\ncontext.height\n\n// Gives you the power to define half the screen, a third of it and so on.\n// Useful for responsive applications.\n// param dividedBy (double) optional - default: 1\n// param reducedBy (double) optional - default: 0\ncontext.heightTransformer()\ncontext.widthTransformer()\n\n/// Similar to MediaQuery.of(context).size\ncontext.mediaQuerySize()\n\n/// Similar to MediaQuery.of(context).padding\ncontext.mediaQueryPadding()\n\n/// Similar to MediaQuery.of(context).viewPadding\ncontext.mediaQueryViewPadding()\n\n/// Similar to MediaQuery.of(context).viewInsets;\ncontext.mediaQueryViewInsets()\n\n/// Similar to MediaQuery.of(context).orientation;\ncontext.orientation()\n\n/// Check if device is on landscape mode\ncontext.isLandscape()\n\n/// Check if device is on portrait mode\ncontext.isPortrait()\n\n/// Similar to MediaQuery.of(context).devicePixelRatio;\ncontext.devicePixelRatio()\n\n/// Similar to MediaQuery.of(context).textScaleFactor;\ncontext.textScaleFactor()\n\n/// Get the shortestSide from screen\ncontext.mediaQueryShortestSide()\n\n/// True if width be larger than 800\ncontext.showNavbar()\n\n/// True if the shortestSide is smaller than 600p\ncontext.isPhone()\n\n/// True if the shortestSide is largest than 600p\ncontext.isSmallTablet()\n\n/// True if the shortestSide is largest than 720p\ncontext.isLargeTablet()\n\n/// True if the current device is Tablet\ncontext.isTablet()\n\n/// اسکرین کے سائز کے مطابق <T> ایک قیمت لوٹاتا ہے\n/// اس کی قیمت دے سکتے ہیں:\n/// واچ: اگر مختصر ترین جگہ 300 سے چھوٹی ہے\n/// موبائل: اگر مختصر ترین سائٹ 600 سے چھوٹی ہے\n/// ٹیبلٹ: اگر مختصر ترین سائٹ 1200 سے چھوٹی ہے\n/// ڈیسک ٹاپ: اگر چوڑائی 1200 سے زیادہ ہے\ncontext.responsiveValue<T>()\n```\n\n### اختیاری عالمی ترتیبات اور دستی تشکیلات\n\nگیٹ میٹریئل ایپ آپ کے لئے ہر چیز کو کنفیگر کرتی ہے ، لیکن اگر آپ تشکیل کرنا چاہتے ہیں تو دستی طور پر حاصل کریں۔\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver()],\n);\n```\n\nآپ `گیٹ اوزرور` کے اندر اپنا مڈل ویئر بھی استعمال کرسکیں گے ، اس سے کسی بھی چیز پر اثر نہیں پڑے گا۔\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [\n    GetObserver(MiddleWare.observer) // Here\n  ],\n);\n```\n\nآپ `گیٹ` کیلئے _ عالمی ترتیبات_ تشکیل دے سکتے ہیں۔ کسی بھی راستے کو آگے بڑھانے سے پہلے صرف اپنے کوڈ میں `گیٹ کنفیگ` شامل کریں۔\nیا اسے اپنے `گیٹ میٹیرال ایپ` میں براہ راست کریں\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  defaultTransition: Transition.fade,\n  opaqueRoute: Get.isOpaqueRouteDefault,\n  popGesture: Get.isPopGestureEnable,\n  transitionDuration: Get.defaultDurationTransition,\n  defaultGlobalState: Get.defaultGlobalState,\n);\n\nGet.config(\n  enableLog = true,\n  defaultPopGesture = true,\n  defaultTransition = Transitions.cupertino\n)\n```\n\nآپ لاگ ان پیغامات کو اختیاری طور پر `گیٹ` سے دوبارہ بھیج سکتے ہیں۔\nاگر آپ خود اپنا ، پسندیدہ لاگنگ پیکیج استعمال کرنا چاہتے ہیں تو ،\nاور وہاں موجود نوشتہ جات پر قبضہ کرنا چاہتے ہیں:\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  logWriterCallback: localLogWriter,\n);\n\nvoid localLogWriter(String text, {bool isError = false}) {\n  // pass the message to your favourite logging package here\n  // please note that even if enableLog: false log messages will be pushed in this callback\n  // you get check the flag if you want through GetConfig.isLogEnable\n}\n\n```\n\n### مقامی اسٹیٹ ویجٹ\n\nیہ وجیٹس آپ کو ایک ہی قیمت کا انتظام کرنے ، اور مقامی طور پر ریاست کو دائمی اور مقامی رکھنے کی اجازت دیتے ہیں۔\nہمارے پاس ری ایکٹیو اور سادہ ذائقے ہیں۔\nمثال کے طور پر ، آپ ان کو ٹیکسٹ فیلڈ میں چھپے ہوئے متن کو ٹوگل کرنے کے لئے استعمال کرسکتے ہیں ، شاید کوئی رواج بنائیں\nتوسیع پذیر پینل ، یا ہوسکتا ہے کہ موجودہ فہرست میں ترمیم کرکے نیچے کی نیویگیشن بار میں مواد کو تبدیل کرتے ہوئے\n`Scaffold` میں جسم کا\n\n#### ویلیو بلڈر\n\n`StatefulWidget` کی ایک سادگی جو` .setState` کال بیک کے ساتھ کام کرتی ہے جو تازہ ترین قیمت لیتی ہے۔\n\n```dart\nValueBuilder<bool>(\n  initialValue: false,\n  builder: (value, updateFn) => Switch(\n    value: value,\n    onChanged: updateFn, // same signature! you could use ( newValue ) => updateFn( newValue )\n  ),\n  // if you need to call something outside the builder method.\n  onUpdate: (value) => print(\"Value updated: $value\"),\n  onDispose: () => print(\"Widget unmounted\"),\n),\n```\n\n#### اوبکس ویلیو\n\nاس طرح آپ کو قیمت ملتی ہے\n\n```dart\nObxValue((data) => Switch(\n        value: data.value,\n        onChanged: data, // Rx has a _callable_ function! You could use (flag) => data.value = flag,\n    ),\n    false.obs,\n),\n```\n\n## کارآمد نکات\n\n`.obs`ervables ( _Rx_ Types) \n```dart\nvar message = 'Hello world'.obs;\nprint( 'Message \"$message\" has Type ${message.runtimeType}');\n```\n\n `message`  --> **RxString**\n\n[x] `message.substring( 0, 4 )`.\n[o] `.value`\n\n```dart\nfinal name = 'GetX'.obs;\n// only \"updates\" the stream, if the value is different from the current one.\nname.value = 'Hey';\n\n// All Rx properties are \"callable\" and returns the new value.\n// but this approach does not accepts `null`, the UI will not rebuild.\nname('Hello');\n\n// is like a getter, prints 'Hello'.\nname() ;\n\n/// numbers:\n\nfinal count = 0.obs;\n\n// You can use all non mutable operations from num primitives!\ncount + 1;\n\n// Watch out! this is only valid if `count` is not final, but var\ncount += 1;\n\n// You can also compare against values:\ncount > 2;\n\n/// booleans:\n\nfinal flag = false.obs;\n\n// switches the value between true/false\nflag.toggle();\n\n\n/// all types:\n\n// Sets the `value` to null.\nflag.nil();\n\n// All toString(), toJson() operations are passed down to the `value`\nprint( count ); // calls `toString()` inside  for RxInt\n\nfinal abc = [0,1,2].obs;\n// Converts the value to a json Array, prints RxList\n// Json is supported by all Rx types!\nprint('json: ${jsonEncode(abc)}, type: ${abc.runtimeType}');\n\n// RxMap, RxList and RxSet are special Rx types, that extends their native types.\n// but you can work with a List as a regular list, although is reactive!\nabc.add(12); // pushes 12 to the list, and UPDATES the stream.\nabc[3]; // like Lists, reads the index 3.\n\n\n// equality works with the Rx and the value, but hashCode is always taken from the value\nfinal number = 12.obs;\nprint( number == 12 ); // prints > true\n\n/// Custom Rx Models:\n\n// toJson(), toString() are deferred to the child, so you can implement override on them, and print() the observable directly.\n\nclass User {\n    String name, last;\n    int age;\n    User({this.name, this.last, this.age});\n\n    @override\n    String toString() => '$name $last, $age years old';\n}\n\nfinal user = User(name: 'John', last: 'Doe', age: 33).obs;\n\n// `user` is \"reactive\", but the properties inside ARE NOT!\n// So, if we change some variable inside of it...\nuser.value.name = 'Roi';\n// The widget will not rebuild!,\n// `Rx` don't have any clue when you change something inside user.\n// So, for custom classes, we need to manually \"notify\" the change.\nuser.refresh();\n\n// or we can use the `update()` method!\nuser.update((value){\n  value.name='Roi';\n});\n\nprint( user );\n```\n\n#### گیٹ ویو\n\n\nمجھے یہ ویجیٹ پسند ہے ، بہت آسان ، پھر بھی ، اتنا مفید ہے!\n\nایک کانسٹیٹ اسٹیٹ لیس ویجیٹ ہے جس میں رجسٹرڈ `کنٹرولر` کے لئے حاصل کرنے والا `کنٹرولر` ہے ، بس۔\n\n```dart\n class AwesomeController extends GetxController {\n   final String title = 'My Awesome View';\n }\n\n  // ALWAYS remember to pass the `Type` you used to register your controller!\n class AwesomeView extends GetView<AwesomeController> {\n   @override\n   Widget build(BuildContext context) {\n     return Container(\n       padding: EdgeInsets.all(20),\n       child: Text(controller.title), // just call `controller.something`\n     );\n   }\n }\n```\n\n#### گیٹ ویجٹ\n\nزیادہ تر لوگوں کو اس ویجیٹ کے بارے میں کوئی اندازہ نہیں ہے ، یا اس کے استعمال کو پوری طرح سے الجھن میں ہے\nاستعمال کا معاملہ بہت کم ہے ، لیکن بہت ہی خاص ہے: یہ ایک کنٹرولر کی مدد کرتا ہے\nکیچ_کی وجہ سے ، `مجاز اسٹیٹ لیس  نہیں ہوسکتا ہے\n\n> تو ، جب آپ کو ایک کنٹرولر \"کیش\" کرنے کی ضرورت ہے؟\n\nاگر آپ استعمال کرتے ہیں تو ، ** گیٹ ایکس ** کی ایک اور \"اتنی عام نہیں\" خصوصیت: `گیٹ.کریٹ`۔\n\n`Get.create(()=>Controller())` ایک نیا پیدا کرے گا `Controller` ہر بار جب آپ کال کریں گے\n`Get.find<Controller>()`,\n\nاسی جگہ پر `گیٹ ویجٹ` چمکتا ہے ... جیسے کہ آپ اسے استعمال کرسکتے ہیں ، مثال کے طور پر ،\nٹوڈو اشیاء کی ایک فہرست رکھنے کے ل. لہذا ، اگر آپکے پاس وجٹس کو \"دوبارہ تعمیر\" ہو جاتا ہے تو ، یہ وہی کنٹرولر مثال برقرار رکھے گا۔\n\n#### گیٹکس سروس\n\nThis class is like a `GetxController`, it shares the same lifecycle ( `onInit()`, `onReady()`, `onClose()`).\nBut has no \"logic\" inside of it. It just notifies **GetX** Dependency Injection system, that this subclass\n**can not** be removed from memory.\n\nSo is super useful to keep your \"Services\" always reachable and active with `Get.find()`. Like:\n`ApiService`, `StorageService`, `CacheService`.\n\n```dart\nFuture<void> main() async {\n  await initServices(); /// AWAIT SERVICES INITIALIZATION.\n  runApp(SomeApp());\n}\n\n/// Is a smart move to make your Services intiialize before you run the Flutter app.\n/// as you can control the execution flow (maybe you need to load some Theme configuration,\n/// apiKey, language defined by the User... so load SettingService before running ApiService.\n/// so GetMaterialApp() doesnt have to rebuild, and takes the values directly.\nvoid initServices() async {\n  print('starting services ...');\n  /// Here is where you put get_storage, hive, shared_pref initialization.\n  /// or moor connection, or whatever that's async.\n  await Get.putAsync(() => DbService().init());\n  await Get.putAsync(SettingsService()).init();\n  print('All services started...');\n}\n\nclass DbService extends GetxService {\n  Future<DbService> init() async {\n    print('$runtimeType delays 2 sec');\n    await 2.delay();\n    print('$runtimeType ready!');\n    return this;\n  }\n}\n\nclass SettingsService extends GetxService {\n  void init() async {\n    print('$runtimeType delays 1 sec');\n    await 1.delay();\n    print('$runtimeType ready!');\n  }\n}\n\n```\n\n`گیٹکسسروس` کو اصل میں حذف کرنے کا واحد راستہ ،`گیٹ.ریسیٹ`  ہے جو ایک جیسے ہے\nآپ کی ایپ کا \"گرم ریبوٹ\"۔ لہذا ، یاد رکھیں ، اگر آپ کو دوران کلاس مثال کے طور پر مطلق استقامت کی ضرورت ہو\nاپنی ایپ کی زندگی بھر ، `گیٹکسسروس` استعمال کریں۔\n\n# پچھلے ورژن سے اہم تبدیلیاں\n\n1.  آر ایکس اقسام:\n\n| Before  | After      |\n| ------- | ---------- |\n| StringX | `RxString` |\n| IntX    | `RxInt`    |\n| MapX    | `RxMap`    |\n| ListX   | `RxList`   |\n| NumX    | `RxNum`    |\n| DoubleX | `RxDouble` |\n\nآر ایکس کنٹرولر اور گیٹ بلڈر اب آپس میں مل گئے ہیں ، اب آپ کو یہ حفظ کرنے کی ضرورت نہیں ہے کہ آپ کون سے کنٹرولر استعمال کرنا چاہتے ہیں ، صرف گیٹکسکنٹرولر کا استعمال کریں ، یہ سادہ سسٹم مینجمنٹ اور رد عمل کے  بھی کام کرے گا۔\n\n2.  نامزد روٹس\nپہلے:\n\n```dart\nGetMaterialApp(\n  namedRoutes: {\n    '/': GetRoute(page: Home()),\n  }\n)\n```\n\nاب:\n\n```dart\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page: () => Home()),\n  ]\n)\n```\n\nیہ تبدیلی کیوں؟\nاکثر ، یہ فیصلہ کرنا ضروری ہوسکتا ہے کہ پیرامیٹر ، یا لاگ ان ٹوکن سے کون سا صفحہ ڈسپلے ہوگا ، پچھلا نقطہ نظر پیچیدہ تھا ، کیونکہ اس نے اس کی اجازت نہیں دی۔\nصفحہ کو کسی فنکشن میں داخل کرنے سے رام کی کھپت میں نمایاں کمی واقع ہوئی ہے ، کیونکہ ایپ شروع ہونے کے بعد سے روٹوں کو میموری میں مختص نہیں کیا جائے گا ، اور اس طرح اس طرح کے نقطہ نظر کو کرنے کی بھی اجازت دی گئی ہے۔\n\n```dart\n\nGetStorage box = GetStorage();\n\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page:(){\n      return box.hasData('token') ? Home() : Login();\n    })\n  ]\n)\n```\n\n# گیٹکس کیوں؟\n\n1.  فلٹر کی تازہ کاری کے بعد ، آپ کے بہت سے پیکیجز ٹوٹ جائیں گے۔ بعض اوقات تالیف کی غلطیاں ہوتی ہیں ، غلطیاں اکثر ظاہر ہوتی ہیں کہ اب بھی اس کے بارے میں کوئی جواب نہیں ملتا ہے ، اور ڈویلپر کو یہ جاننے کی ضرورت ہوتی ہے کہ غلطی کہاں سے ہوئی ہے ، غلطی کو ٹریک کریں ، تب ہی متعلقہ ذخیرہ میں کوئی مسئلہ کھولنے کی کوشش کریں ، اور دیکھیں کہ اس کا مسئلہ حل ہوتا ہے۔ ترقی کے مرکزی وسائل کو مرکز بنائیں (ریاست ، انحصار اور روٹ مینجمنٹ) ، آپ کو اپنے پبسپیک میں ایک پیکیج شامل کرنے اور کام شروع کرنے کی اجازت دے۔ پھڑپھڑانے کی تازہ کاری کے بعد ، آپ کو صرف انحصار کرنے کی ضرورت ہے گیٹ انحصار کو اپ ڈیٹ کریں ، اور کام کریں۔ مطابقت کے مسائل کو بھی حل کریں حاصل کریں۔ ایک پیکج کا ورژن کتنی بار دوسرے کے ورژن کے ساتھ مطابقت نہیں رکھتا ہے ، کیونکہ ایک ورژن میں انحصار استعمال کرتا ہے ، اور دوسرا دوسرے ورژن میں۔ گیٹ کو استعمال کرنے میں بھی یہ کوئی تشویش نہیں ہے ، کیونکہ سب کچھ ایک ہی پیکج میں ہے اور مکمل طور پر ہم آہنگ ہے۔\n\n2. فلٹر آسان ہے .فلٹر ناقابل یقین ہے ، لیکن .فلٹر کے پاس اب بھی کچھ بوائلرپلیٹ موجود ہے جو زیادہ تر ڈویلپرز کے لئے ناپسندیدہ ہوسکتا ہے ، جیسے `Navigator.of(context).push (context, builder [...]`. پروگرامنگ کو آسان بنائیں۔ صرف راستے پر کال کرنے کے لئے 8 لائنوں کے کوڈ لکھنے کے بجائے ، آپ صرف یہ کرسکتے ہیں: `Get.to(Home())` اور آپ کر چکے ہیں ، آپ اگلے صفحے پر جائیں گے۔ متحرک ویب یو آر ایل ایک بہت تکلیف دہ چیز ہے جس کے ساتھ کرنا ہے ۔فلٹر فی الحال ، اور یہ کہ گیٹیکس کے ساتھ احمقانہ حد تک آسان ہے۔ .. فلٹر میں ریاستوں کا انتظام کرنا ، اور انحصار کا انتظام کرنا بھی ایک ایسی چیز ہے جو بہت ساری بحثیں پیدا کرتی ہے ، کیوں کہ پب میں سیکڑوں نمونوں کی موجودگی موجود ہے۔ لیکن آپ کے متغیر کے اختتام پر `.obs` شامل کرنے جتنا آسان کوئی چیز نہیں ہے ، اور اپنے ویجیٹ کو کسی اوکس کے اندر رکھ دیں ، اور بات یہ ہے کہ اس متغیر کی تمام تر تازہ کاری خود بخود اسکرین پر اپ ڈیٹ ہوجائے گی۔\n\n3. کارکردگی کی فکر کئے بغیر آسانی۔ .فلٹر کی کارکردگی پہلے ہی حیرت انگیز ہے ، لیکن تصور کریں کہ آپ اپنے بلاکس / اسٹورز / کنٹرولرز / وغیرہ کلاسوں کو تقسیم کرنے کے لئے اسٹیٹ مینیجر اور لوکیٹر کا استعمال کرتے ہیں۔ جب آپ کو ضرورت نہ ہو تو آپ کو دستی طور پر اس انحصار کے اخراج کو کال کرنا پڑے گا۔ لیکن کیا آپ نے کبھی اپنے کنٹرولر کو محض استعمال کرنے کے بارے میں سوچا ہے ، اور جب اب یہ کسی کے ذریعہ استعمال نہیں ہو رہا تھا تو ، اسے آسانی سے میموری سے حذف کردیا جائے گا؟ گیٹ ایکس یہی کرتا ہے۔ اسمارٹ مینجمنٹ کے ساتھ ، ہر وہ چیز جو استعمال نہیں ہورہی ہے اسے میموری سے حذف کردیا جاتا ہے ، اور آپ کو پروگرامنگ کے علاوہ کسی بھی چیز کی فکر کرنے کی ضرورت نہیں ہے۔ آپ کو یقین دلایا جائے گا کہ آپ کم از کم ضروری وسائل بروئے کار لا رہے ہیں ، حتی کہ اس کے لئے بھی کوئی منطق پیدا نہیں کیا۔\n\n4. اصل ڈیکوپلنگ۔ آپ نے یہ نظریہ \"کاروبار کی منطق سے نظریہ کو الگ کریں\" سنا ہوگا۔ یہ ریاستی انتظام کے دیگر حلوں کی کوئی خاصیت نہیں ہے اور مارکیٹ میں کسی دوسرے معیار کا یہ تصور ہے۔ تاہم ، سیاق و سباق کے استعمال کی وجہ سے پھڑپھڑ میں اکثر اس تصور کو کم کیا جاسکتا ہے۔\nاگر آپ کو وراثت والے ویجیٹ کو تلاش کرنے کے لئے سیاق و سباق کی ضرورت ہوتی ہے تو ، آپ کو اس کی نظر میں ضرورت ہوگی ، یا پیرامیٹر کے ذریعہ سیاق و سباق کو منتقل کریں۔ مجھے خاص طور پر یہ حل بہت ہی بدصورت معلوم ہوتا ہے ، اور ٹیموں میں کام کرنے کے لئے ہمیں ہمیشہ ویو کی کاروباری منطق پر انحصار کرنا پڑے گا۔ گیٹکس معیاری نقطہ نظر کے ساتھ غیر روایتی ہے ، اور اگرچہ اس میں اسٹیٹ فل وِیجٹس ، انیسٹیٹ وغیرہ کے استعمال پر مکمل پابندی نہیں ہے تو ، اس کا ہمیشہ ایسا ہی نقطہ نظر ہوتا ہے جو صاف ستھرا ہوسکتا ہے۔ کنٹرولرز کے پاس زندگی کا دور رہتا ہے ، اور جب آپ کو مثال کے طور پر درخواست دینے کی ضرورت ہوتی ہے تو ، آپ کو نظر میں کسی چیز پر انحصار نہیں کرنا ہوتا ہے۔ آپ ایچ ٹی ٹی پی کال شروع کرنے کے لئے اونٹ کا استعمال کرسکتے ہیں ، اور جب ڈیٹا آجائے گا تو متغیرات آباد ہوجائیں گے۔ چونکہ گیٹ ایکس مکمل طور پر رد عمل مند ہے (واقعتا، ، اور نہروں کے تحت کام کرتا ہے) ، ایک بار جب سامان بھر جاتا ہے تو ، اس متغیر کو استعمال کرنے والے تمام ویجٹ خود بخود منظر میں اپ ڈیٹ ہوجائیں گے۔ اس سے UI کی مہارت رکھنے والے افراد کو صرف وگیٹس کے ساتھ کام کرنے کا موقع ملتا ہے ، اور صارف کے واقعات (جیسے بٹن پر کلک کرنے کے علاوہ) کے علاوہ کاروباری منطق پر کچھ بھی نہیں بھیجنا پڑتا ہے ، جبکہ کاروباری منطق کے ساتھ کام کرنے والے افراد الگ الگ کاروبار کی منطق کی تخلیق اور جانچ کر سکتے ہیں۔\n\nاس لائبریری کو ہمیشہ اپ ڈیٹ کیا جائے گا اور نئی خصوصیات کو نافذ کیا جائے گا۔ بلا جھجک پی آر پیش کریں اور ان میں اپنا حصہ ڈالیں۔\n\n# سماجی خدمات\n\n## کمیونٹی چینلز\n\nگیٹ ایکس میں انتہائی فعال اور مددگار کمیونٹی ہے۔ اگر آپ کے ذہن میں سوالات ہیں ، یا اس فریم ورک کے استعمال کے سلسلے میں کوئی مدد چاہتے ہیں تو ، براہ کرم ہمارے کمیونٹی چینلز میں شامل ہوں ، آپ کے سوال کا زیادہ جلد جواب دیا جائے گا ، اور یہ سب سے موزوں جگہ ہوگی۔ یہ ذخیر. مسائل کو کھولنے ، اور وسائل کی درخواست کرنے کے لئے خصوصی ہے ، لیکن گیٹ ایکس کمیونٹی کا حصہ بننے میں آزاد محسوس کرتے ہیں۔\n\n| **Slack**                                                                                                                   | **Discord**                                                                                                                 | **Telegram**                                                                                                          |\n| :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |\n| [![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx) | [![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N) | [![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g) |\n\n## کس طرح شراکت کریں\n\n\nمنصوبے میں شراکت کرنا چاہتے ہیں؟ ہمیں اپنے ایک ساتھی کی حیثیت سے آپ کو اجاگر کرنے پر فخر ہوگا۔ یہاں کچھ نکات ہیں جہاں آپ اپنا حصہ ڈال سکتے ہیں اور گیٹ (اور پھڑپھڑنا) کو اور بہتر بنا سکتے ہیں۔\n\n- ریڈمی کو دوسری زبانوں میں ترجمہ کرنے میں مدد کرنا۔\n- دستاویزات کو ریڈ می میں شامل کرنا (گیٹ کے بہت سارے کام ابھی دستاویزی نہیں ہوئے ہیں)۔\n- مضامین لکھیں یا ویڈیوز بنائیں جس کی تعلیم دیتے ہیں کہ گیٹ (ان کو ریڈیم میں اور مستقبل میں ہمارے ویکی میں داخل کیا جائے گا) کو کس طرح استعمال کیا جائے۔\n- کوڈ / ٹیسٹ کے لئے پی آر پیش کرنا۔\n- نئے افعال سمیت.\n\nکسی بھی شراکت کا خیرمقدم ہے!\n\n## مضامین اور ویڈیوز\n\n- [Dynamic Themes in 3 lines using GetX™](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Tutorial by [Rod Brown](https://github.com/RodBr).\n- [Complete GetX™ Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI) - Route management video by Amateur Coder.\n- [Complete GetX State Management](https://www.youtube.com/watch?v=CNpXbeI_slw) - State management video by Amateur Coder.\n- [GetX™ Other Features](https://youtu.be/ttQtlX_Q0eU) - Utils, storage, bindings and other features video by Amateur Coder.\n- [Firestore User with GetX | Todo App](https://www.youtube.com/watch?v=BiV0DcXgk58) - Video by Amateur Coder.\n- [Firebase Auth with GetX | Todo App](https://www.youtube.com/watch?v=-H-T_BSgfOE) - Video by Amateur Coder.\n- [The Flutter GetX™ Ecosystem ~ State Management](https://medium.com/flutter-community/the-flutter-getx-ecosystem-state-management-881c7235511d) - State management by [Aachman Garg](https://github.com/imaachman).\n- [The Flutter GetX™ Ecosystem ~ Dependency Injection](https://medium.com/flutter-community/the-flutter-getx-ecosystem-dependency-injection-8e763d0ec6b9) - Dependency Injection by [Aachman Garg](https://github.com/imaachman).\n- [GetX, the all-in-one Flutter package](https://www.youtube.com/watch?v=IYQgtu9TM74) - A brief tutorial covering State Management and Navigation by Thad Carnevalli.\n- [Build a To-do List App from scratch using Flutter and GetX](https://www.youtube.com/watch?v=EcnqFasHf18) - UI + State Management + Storage video by Thad Carnevalli.\n- [GetX Flutter Firebase Auth Example](https://medium.com/@jeffmcmorris/getx-flutter-firebase-auth-example-b383c1dd1de2) - Article by Jeff McMorris.\n- [Flutter State Management with GetX – Complete App](https://www.appwithflutter.com/flutter-state-management-with-getx/) - by App With Flutter.\n- [Flutter Routing with Animation using Get Package](https://www.appwithflutter.com/flutter-routing-using-get-package/) - by App With Flutter.\n\n\n"
        },
        {
          "name": "README.zh-cn.md",
          "type": "blob",
          "size": 40.8408203125,
          "content": "![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/get.png)\n\n_语言: 中文, [英文](README.md), [越南文](README-vi.md), [印度尼西亚](README.id-ID.md), [乌尔都语](README.ur-PK.md), [巴西葡萄牙语](README.pt-br.md), [俄语](README.ru.md), [西班牙语](README-es.md), [波兰语](README.pl.md), [韩国语](README.ko-kr.md), [法语](README-fr.md), [French](README-fr.md)._\n\n[![pub package](https://img.shields.io/pub/v/get.svg?label=get&color=blue)](https://pub.dev/packages/get)\n[![popularity](https://badges.bar/get/popularity)](https://pub.dev/packages/sentry/score)\n[![likes](https://badges.bar/get/likes)](https://pub.dev/packages/get/score)\n[![pub points](https://badges.bar/get/pub%20points)](https://pub.dev/packages/get/score)\n![building](https://github.com/jonataslaw/get/workflows/build/badge.svg)\n[![style: effective dart](https://img.shields.io/badge/style-effective_dart-40c4ff.svg)](https://pub.dev/packages/effective_dart)\n[![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N)\n[![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx)\n[![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g)\n<a href=\"https://github.com/Solido/awesome-flutter\">\n<img alt=\"Awesome Flutter\" src=\"https://img.shields.io/badge/Awesome-Flutter-blue.svg?longCache=true&style=flat-square\" />\n</a>\n<a href=\"https://www.buymeacoffee.com/jonataslaw\" target=\"_blank\"><img src=\"https://i.imgur.com/aV6DDA7.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important; box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" > </a>\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/getx.png)\n\n- [关于Get](#关于get)\n- [安装](#安装)\n- [GetX的计数器示例](#getx的计数器示例)\n- [三大功能](#三大功能)\n  - [状态管理](#状态管理)\n    - [响应式状态管理器](#响应式状态管理器)\n    - [关于状态管理的更多细节](#关于状态管理的更多细节)\n  - [路由管理](#路由管理)\n    - [关于路由管理的更多细节](#关于路由管理的更多细节)\n  - [依赖管理](#依赖管理)\n    - [关于依赖管理的更多细节](#关于依赖管理的更多细节)\n- [实用工具](#实用工具)\n  - [国际化](#国际化)\n    - [翻译](#翻译)\n      - [使用翻译](#使用翻译)\n    - [语言](#语言)\n      - [改变语言](#改变语言)\n      - [系统语言](#系统语言)\n  - [改变主题](#改变主题)\n  - [GetConnect](#getconnect)\n    - [默认配置](#默认配置)\n    - [自定义配置](#自定义配置)\n  - [GetPage 中间件](#getpage-中间件)\n    - [优先级](#优先级)\n    - [Redirect](#redirect)\n    - [onPageCalled](#onpagecalled)\n    - [OnBindingsStart](#onbindingsstart)\n    - [OnPageBuildStart](#onpagebuildstart)\n    - [OnPageBuilt](#onpagebuilt)\n    - [OnPageDispose](#onpagedispose)\n  - [其他高级API](#其他高级api)\n    - [可选的全局设置和手动配置](#可选的全局设置和手动配置)\n    - [局部状态组件](#局部状态组件)\n      - [ValueBuilder](#valuebuilder)\n      - [ObxValue](#obxvalue)\n  - [有用的提示](#有用的提示)\n      - [GetView](#getview)\n      - [GetWidget](#getwidget)\n      - [GetxService](#getxservice)\n- [从2.0开始的兼容性变化](#从20开始的兼容性变化)\n- [为什么选择Getx？](#为什么选择getx)\n- [社区](#社区)\n  - [社区渠道](#社区渠道)\n  - [如何做贡献](#如何做贡献)\n  - [文章和视频](#文章和视频)\n\n# 关于Get\n\n- GetX 是 Flutter 上的一个轻量且强大的解决方案：高性能的状态管理、智能的依赖注入和便捷的路由管理。\n\n- GetX 有3个基本原则：\n\n  - **性能：** GetX 专注于性能和最小资源消耗。GetX 打包后的apk占用大小和运行时的内存占用与其他状态管理插件不相上下。如果你感兴趣，这里有一个[性能测试](https://github.com/jonataslaw/benchmarks)。\n  - **效率：** GetX 的语法非常简捷，并保持了极高的性能，能极大缩短你的开发时长。\n  - **结构：** GetX 可以将界面、逻辑、依赖和路由完全解耦，用起来更清爽，逻辑更清晰，代码更容易维护。\n  \n- GetX 并不臃肿，却很轻量。如果你只使用状态管理，只有状态管理模块会被编译，其他没用到的东西都不会被编译到你的代码中。它拥有众多的功能，但这些功能都在独立的容器中，只有在使用后才会启动。\n\n- Getx有一个庞大的生态系统，能够在Android、iOS、Web、Mac、Linux、Windows和你的服务器上用同样的代码运行。\n**通过[Get Server](https://github.com/jonataslaw/get_server)** 可以在你的后端完全重用你在前端写的代码。\n\n**此外，通过[Get CLI](https://github.com/jonataslaw/get_cli)**，无论是在服务器上还是在前端，整个开发过程都可以完全自动化。\n\n**此外，为了进一步提高您的生产效率，我们还为您准备了一些插件**\n\n- **getx_template**：一键生成每个页面必需的文件夹、文件、模板代码等等\n  - [Android Studio/Intellij插件](https://plugins.jetbrains.com/plugin/15919-getx)\n- **GetX Snippets**：输入少量字母，自动提示选择后，可生成常用的模板代码\n  - [Android Studio/Intellij扩展](https://plugins.jetbrains.com/plugin/14975-getx-snippets)\n  - [VSCode扩展](https://marketplace.visualstudio.com/items?itemName=get-snippets.get-snippets)\n\n# 安装\n\n将 Get 添加到你的 pubspec.yaml 文件中。\n\n```yaml\ndependencies:\n  get:\n```\n\n在需要用到的文件中导入，它将被使用。\n\n```dart\nimport 'package:get/get.dart';\n```\n\n# GetX的计数器示例\n\nFlutter默认创建的 \"计数器 \"项目有100多行（含注释），为了展示Get的强大功能，我将使用 GetX 重写一个\"计数器 Plus版\"，实现：\n- 每次点击都能改变状态\n- 在不同页面之间切换\n- 在不同页面之间共享状态\n- 将业务逻辑与界面分离\n\n而完成这一切只需 **26 行代码（含注释）** \n\n- 步骤1.\n在你的MaterialApp前添加 \"Get\"，将其变成GetMaterialApp。\n\n```dart\nvoid main() => runApp(GetMaterialApp(home: Home()));\n```\n\n- 注意：这并不能修改Flutter的MaterialApp，GetMaterialApp并不是修改后的MaterialApp，它只是一个预先配置的Widget，它的子组件是默认的MaterialApp。你可以手动配置，但绝对没有必要。GetMaterialApp会创建路由，注入它们，注入翻译，注入你需要的一切路由导航。如果你只用Get来进行状态管理或依赖管理，就没有必要使用GetMaterialApp。GetMaterialApp对于路由、snackbar、国际化、bottomSheet、对话框以及与路由相关的高级apis和没有上下文（context）的情况下是必要的。\n- 注2: 只有当你要使用路由管理(`Get.to()`, `Get.back()`等)时才需要这一步。如果你不打算使用它，那么就不需要做第1步。\n\n- 第二步：\n  创建你的业务逻辑类，并将所有的变量，方法和控制器放在里面。\n  你可以使用一个简单的\".obs \"使任何变量成为可观察的。\n\n```dart\nclass Controller extends GetxController{\n  var count = 0.obs;\n  increment() => count++;\n}\n```\n\n- 第三步:\n  创建你的界面，使用StatelessWidget节省一些内存，使用Get你可能不再需要使用StatefulWidget。\n\n```dart\nclass Home extends StatelessWidget {\n\n  @override\n  Widget build(context) {\n\n    // 使用Get.put()实例化你的类，使其对当下的所有子路由可用。\n    final Controller c = Get.put(Controller());\n\n    return Scaffold(\n      // 使用Obx(()=>每当改变计数时，就更新Text()。\n      appBar: AppBar(title: Obx(() => Text(\"Clicks: ${c.count}\"))),\n\n      // 用一个简单的Get.to()即可代替Navigator.push那8行，无需上下文！\n      body: Center(child: ElevatedButton(\n              child: Text(\"Go to Other\"), onPressed: () => Get.to(Other()))),\n      floatingActionButton:\n          FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment));\n  }\n}\n\nclass Other extends StatelessWidget {\n  // 你可以让Get找到一个正在被其他页面使用的Controller，并将它返回给你。\n  final Controller c = Get.find();\n\n  @override\n  Widget build(context){\n     // 访问更新后的计数变量\n     return Scaffold(body: Center(child: Text(\"${c.count}\")));\n  }\n}\n```\n\n结果：\n\n![](https://raw.githubusercontent.com/jonataslaw/getx-community/master/counter-app-gif.gif)\n\n这是一个简单的项目，但它已经让人明白Get的强大。随着项目的发展，这种差异将变得更加显著。\n\nGet的设计是为了与团队合作，但它也可以让个人开发者的工作变得更简单。\n\n加快开发速率，在不损失性能的情况下按时交付一切。Get并不适合每一个人，但如果你认同这句话，Get就是为你准备的!\n\n# 三大功能\n\n## 状态管理\n\n目前，Flutter有几种状态管理器。但是，它们中的大多数都涉及到使用ChangeNotifier来更新widget，这对于中大型应用的性能来说是一个很糟糕的方法。你可以在Flutter的官方文档中查看到，[ChangeNotifier应该使用1个或最多2个监听器](https://api.flutter.dev/flutter/foundation/ChangeNotifier-class.html)，这使得它们实际上无法用于任何中等或大型应用。\n\nGet 并不是比任何其他状态管理器更好或更差，而是说你应该分析这些要点以及下面的要点来选择只用Get，还是与其他状态管理器结合使用。\n\nGet不是其他状态管理器的敌人，因为Get是一个微框架，而不仅仅是一个状态管理器，既可以单独使用，也可以与其他状态管理器结合使用。\n\nGet有两个不同的状态管理器：简单的状态管理器（GetBuilder）和响应式状态管理器（GetX）。\n\n### 响应式状态管理器\n\n响应式编程可能会让很多人感到陌生，因为觉得它很复杂，但是GetX将响应式编程变得非常简单。\n\n- 你不需要创建StreamControllers.\n- 你不需要为每个变量创建一个StreamBuilder。\n- 你不需要为每个状态创建一个类。\n- 你不需要为一个初始值创建一个get。\n\n使用 Get 的响应式编程就像使用 setState 一样简单。\n\n让我们想象一下，你有一个名称变量，并且希望每次你改变它时，所有使用它的小组件都会自动刷新。\n\n这就是你的计数变量。\n\n```dart\nvar name = 'Jonatas Borges';\n```\n\n要想让它变得可观察，你只需要在它的末尾加上\".obs\"。\n\n```dart\nvar name = 'Jonatas Borges'.obs;\n```\n\n而在UI中，当你想显示该值并在值变化时更新页面，只需这样做。\n\n```dart\nObx(() => Text(\"${controller.name}\"));\n```\n\n这就是全部，就这么简单。\n\n### 关于状态管理的更多细节\n\n**关于状态管理更深入的解释请查看[这里](./documentation/zh_CN/state_management.md)。在那里你将看到更多的例子，以及简单的状态管理器和响应式状态管理器之间的区别**。\n\n你会对GetX的能力有一个很好的了解。\n\n## 路由管理\n\n如果你想免上下文（context）使用路由/snackbars/dialogs/bottomsheets，GetX对你来说也是极好的，来吧展示：\n\n在你的MaterialApp前加上 \"Get\"，把它变成GetMaterialApp。\n\n```dart\nGetMaterialApp( // Before: MaterialApp(\n  home: MyHome(),\n)\n```\n\n导航到新页面\n\n```dart\n\nGet.to(NextScreen());\n```\n\n用别名导航到新页面。查看更多关于命名路由的详细信息[这里](./documentation/zh_CN/route_management.md#navigation-with-named-routes)\n\n```dart\n\nGet.toNamed('/details');\n```\n\n要关闭snackbars, dialogs, bottomsheets或任何你通常会用Navigator.pop(context)关闭的东西。\n\n```dart\nGet.back();\n```\n\n进入下一个页面，但没有返回上一个页面的选项（用于闪屏页，登录页面等）。\n\n```dart\nGet.off(NextScreen());\n```\n\n进入下一个页面并取消之前的所有路由（在购物车、投票和测试中很有用）。\n\n```dart\nGet.offAll(NextScreen());\n```\n\n注意到你不需要使用context来做这些事情吗？这就是使用Get路由管理的最大优势之一。有了它，你可以在你的控制器类中执行所有这些方法，而不用担心context在哪里。\n\n### 关于路由管理的更多细节\n\n**关于别名路由，和对路由的低级控制，请看[这里](./documentation/zh_CN/route_management.md)**。\n\n## 依赖管理\n\nGet有一个简单而强大的依赖管理器，它允许你只用1行代码就能检索到与你的Bloc或Controller相同的类，无需Provider context，无需inheritedWidget。\n\n```dart\nController controller = Get.put(Controller()); // 而不是 Controller controller = Controller();\n```\n\n- 注意：如果你使用的是Get的状态管理器，请多注意绑定api，这将使你的界面更容易连接到你的控制器。\n\n你是在Get实例中实例化它，而不是在你使用的类中实例化你的类，这将使它在整个App中可用。\n所以你可以正常使用你的控制器（或类Bloc）。\n\n**提示：** Get依赖管理与包的其他部分是解耦的，所以如果你的应用已经使用了一个状态管理器（任何一个，都没关系），你不需要全部重写，你可以使用这个依赖注入。\n\n```dart\ncontroller.fetchApi();\n```\n\n想象一下，你已经浏览了无数条路由，现在你需要拿到一个被遗留在控制器中的数据，那你需要一个状态管理器与Provider或Get_it一起使用来拿到它，对吗？用Get则不然，Get会自动为你的控制器找到你想要的数据，而你甚至不需要任何额外的依赖关系。\n\n```dart\nController controller = Get.find();\n//是的，它看起来像魔术，Get会找到你的控制器，并将其提供给你。你可以实例化100万个控制器，Get总会给你正确的控制器。\n```\n\n然后你就可以恢复你在后面获得的控制器数据。\n\n```dart\nText(controller.textFromApi);\n```\n\n### 关于依赖管理的更多细节\n\n**关于依赖管理的更深入解释请看[此处](./documentation/zh_CN/dependency_management.md)**。\n\n# 实用工具\n\n## 国际化\n\n### 翻译\n\n翻译被保存为一个简单的键值字典映射。\n要添加自定义翻译，请创建一个类并扩展`翻译`。\n\n```dart\nimport 'package:get/get.dart';\n\nclass Messages extends Translations {\n  @override\n  Map<String, Map<String, String>> get keys => {\n        'zh_CN': {\n          'hello': '你好 世界',\n        },\n        'de_DE': {\n          'hello': 'Hallo Welt',\n        }\n      };\n}\n```\n\n#### 使用翻译\n\n只要将`.tr`追加到指定的键上，就会使用`Get.locale`和`Get.fallbackLocale`的当前值进行翻译。\n\n```dart\nText('title'.tr);\n```\n\n### 语言\n\n传递参数给`GetMaterialApp`来定义语言和翻译。\n\n```dart\nreturn GetMaterialApp(\n    translations: Messages(), // 你的翻译\n    locale: Locale('zh', 'CN'), // 将会按照此处指定的语言翻译\n    fallbackLocale: Locale('en', 'US'), // 添加一个回调语言选项，以备上面指定的语言翻译不存在\n);\n```\n\n#### 改变语言\n\n调用`Get.updateLocale(locale)`来更新语言环境。然后翻译会自动使用新的locale。\n\n```dart\nvar locale = Locale('en', 'US');\nGet.updateLocale(locale);\n```\n\n#### 系统语言\n\n要读取系统语言，可以使用`window.locale`。\n\n```dart\nimport 'dart:ui' as ui;\n\nreturn GetMaterialApp(\n    locale: ui.window.locale,\n);\n```\n\n## 改变主题\n\n请不要使用比`GetMaterialApp`更高级别的widget来更新主题，这可能会造成键重复。很多人习惯于创建一个 \"ThemeProvider \"的widget来改变应用主题，这在**GetX™**中是绝对没有必要的。\n\n你可以创建你的自定义主题，并简单地将其添加到`Get.changeTheme`中，而无需任何模板。\n\n```dart\nGet.changeTheme(ThemeData.light());\n```\n\n如果你想在 \"onTap \"中创建类似于改变主题的按钮，你可以结合两个**GetX™** API来实现。\n\n- 检查是否使用了深色的 \"Theme \"的API，以及 \"Theme \"更改API。\n- 而`Theme` Change API，你可以把下面的代码放在`onPressed`里。\n\n```dart\nGet.changeTheme(Get.isDarkMode? ThemeData.light(): ThemeData.dark());\n```\n\n当`.darkmode`被激活时，它将切换到light主题，当light主题被激活时，它将切换到dark主题。\n\n## GetConnect\n\nGetConnect可以便捷的通过http或websockets进行前后台通信。\n\n### 默认配置\n\n你能轻松的通过extend GetConnect就能使用GET/POST/PUT/DELETE/SOCKET方法与你的Rest API或websockets通信。\n\n```dart\nclass UserProvider extends GetConnect {\n  // Get request\n  Future<Response> getUser(int id) => get('http://youapi/users/$id');\n  // Post request\n  Future<Response> postUser(Map data) => post('http://youapi/users', body: data);\n  // Post request with File\n  Future<Response<CasesModel>> postCases(List<int> image) {\n    final form = FormData({\n      'file': MultipartFile(image, filename: 'avatar.png'),\n      'otherFile': MultipartFile(image, filename: 'cover.png'),\n    });\n    return post('http://youapi/users/upload', form);\n  }\n\n  GetSocket userMessages() {\n    return socket('https://yourapi/users/socket');\n  }\n}\n```\n\n### 自定义配置\n\nGetConnect具有多种自定义配置。你可以配置base Url，配置响应，配置请求，添加权限验证，甚至是尝试认证的次数，除此之外，还可以定义一个标准的解码器，该解码器将把您的所有请求转换为您的模型，而不需要任何额外的配置。\n\n```dart\nclass HomeProvider extends GetConnect {\n  @override\n  void onInit() {\n    // All request will pass to jsonEncode so CasesModel.fromJson()\n    httpClient.defaultDecoder = CasesModel.fromJson;\n    httpClient.baseUrl = 'https://api.covid19api.com';\n    // baseUrl = 'https://api.covid19api.com'; // It define baseUrl to\n    // Http and websockets if used with no [httpClient] instance\n\n    // It's will attach 'apikey' property on header from all requests\n    httpClient.addRequestModifier((request) {\n      request.headers['apikey'] = '12345678';\n      return request;\n    });\n\n    // Even if the server sends data from the country \"Brazil\",\n    // it will never be displayed to users, because you remove\n    // that data from the response, even before the response is delivered\n    httpClient.addResponseModifier<CasesModel>((request, response) {\n      CasesModel model = response.body;\n      if (model.countries.contains('Brazil')) {\n        model.countries.remove('Brazilll');\n      }\n    });\n\n    httpClient.addAuthenticator((request) async {\n      final response = await get(\"http://yourapi/token\");\n      final token = response.body['token'];\n      // Set the header\n      request.headers['Authorization'] = \"$token\";\n      return request;\n    });\n\n    //Autenticator will be called 3 times if HttpStatus is\n    //HttpStatus.unauthorized\n    httpClient.maxAuthRetries = 3;\n  }\n\n  @override\n  Future<Response<CasesModel>> getCases(String path) => get(path);\n}\n```\n\n## GetPage 中间件\n\nGetPage现在有个新的参数可以把列表中的Get中间件按指定顺序执行。\n\n**注意**: 当GetPage有中间件时，所有的子page会自动有相同的中间件。\n\n### 优先级\n\n设置中间件的优先级定义Get中间件的执行顺序。\n\n```dart\nfinal middlewares = [\n  GetMiddleware(priority: 2),\n  GetMiddleware(priority: 5),\n  GetMiddleware(priority: 4),\n  GetMiddleware(priority: -8),\n];\n```\n\n这些中间件会按这个顺序执行 **-8 => 2 => 4 => 5**\n\n### Redirect\n\n当被调用路由的页面被搜索时，这个函数将被调用。它将RouteSettings作为重定向的结果。或者给它null，就没有重定向了。\n\n```dart\nRouteSettings redirect(String route) {\n  final authService = Get.find<AuthService>();\n  return authService.authed.value ? null : RouteSettings(name: '/login')\n}\n```\n\n### onPageCalled\n\n在调用页面时，创建任何东西之前，这个函数会先被调用。\n您可以使用它来更改页面的某些内容或给它一个新页面。\n\n```dart\nGetPage onPageCalled(GetPage page) {\n  final authService = Get.find<AuthService>();\n  return page.copyWith(title: 'Welcome ${authService.UserName}');\n}\n```\n\n### OnBindingsStart\n\n这个函数将在绑定初始化之前被调用。\n在这里，您可以更改此页面的绑定。\n\n```dart\nList<Bindings> onBindingsStart(List<Bindings> bindings) {\n  final authService = Get.find<AuthService>();\n  if (authService.isAdmin) {\n    bindings.add(AdminBinding());\n  }\n  return bindings;\n}\n```\n\n### OnPageBuildStart\n\n这个函数将在绑定初始化之后被调用。\n在这里，您可以在创建绑定之后和创建页面widget之前执行一些操作。\n\n```dart\nGetPageBuilder onPageBuildStart(GetPageBuilder page) {\n  print('bindings are ready');\n  return page;\n}\n```\n\n### OnPageBuilt\n\n这个函数将在GetPage.page调用后被调用，并给出函数的结果，并获取将要显示的widget。\n\n### OnPageDispose\n\n这个函数将在处理完页面的所有相关对象(Controllers, views, ...)之后被调用。\n\n## 其他高级API\n\n```dart\n// 给出当前页面的args。\nGet.arguments\n\n//给出以前的路由名称\nGet.previousRoute\n\n// 给出要访问的原始路由，例如，rawRoute.isFirst()\nGet.rawRoute\n\n// 允许从GetObserver访问Rounting API。\nGet.routing\n\n// 检查 snackbar 是否打开\nGet.isSnackbarOpen\n\n// 检查 dialog 是否打开\nGet.isDialogOpen\n\n// 检查 bottomsheet 是否打开\nGet.isBottomSheetOpen\n\n// 删除一个路由。\nGet.removeRoute()\n\n//反复返回，直到表达式返回真。\nGet.until()\n\n// 转到下一条路由，并删除所有之前的路由，直到表达式返回true。\nGet.offUntil()\n\n// 转到下一个命名的路由，并删除所有之前的路由，直到表达式返回true。\nGet.offNamedUntil()\n\n//检查应用程序在哪个平台上运行。\nGetPlatform.isAndroid\nGetPlatform.isIOS\nGetPlatform.isMacOS\nGetPlatform.isWindows\nGetPlatform.isLinux\nGetPlatform.isFuchsia\n\n//检查设备类型\nGetPlatform.isMobile\nGetPlatform.isDesktop\n//所有平台都是独立支持web的!\n//你可以知道你是否在浏览器内运行。\n//在Windows、iOS、OSX、Android等系统上。\nGetPlatform.isWeb\n\n\n// 相当于.MediaQuery.of(context).size.height,\n//但不可改变。\nGet.height\nGet.width\n\n// 提供当前上下文。\nGet.context\n\n// 在你的代码中的任何地方，在前台提供 snackbar/dialog/bottomsheet 的上下文。\nGet.contextOverlay\n\n// 注意：以下方法是对上下文的扩展。\n// 因为在你的UI的任何地方都可以访问上下文，你可以在UI代码的任何地方使用它。\n\n// 如果你需要一个可改变的高度/宽度（如桌面或浏览器窗口可以缩放），你将需要使用上下文。\ncontext.width\ncontext.height\n\n// 让您可以定义一半的页面、三分之一的页面等。\n// 对响应式应用很有用。\n// 参数： dividedBy (double) 可选 - 默认值：1\n// 参数： reducedBy (double) 可选 - 默认值：0。\ncontext.heightTransformer()\ncontext.widthTransformer()\n\n/// 类似于 MediaQuery.of(context).size。\ncontext.mediaQuerySize()\n\n/// 类似于 MediaQuery.of(context).padding。\ncontext.mediaQueryPadding()\n\n/// 类似于 MediaQuery.of(context).viewPadding。\ncontext.mediaQueryViewPadding()\n\n/// 类似于 MediaQuery.of(context).viewInsets。\ncontext.mediaQueryViewInsets()\n\n/// 类似于 MediaQuery.of(context).orientation;\ncontext.orientation()\n\n///检查设备是否处于横向模式\ncontext.isLandscape()\n\n///检查设备是否处于纵向模式。\ncontext.isPortrait()\n\n///类似于MediaQuery.of(context).devicePixelRatio。\ncontext.devicePixelRatio()\n\n///类似于MediaQuery.of(context).textScaleFactor。\ncontext.textScaleFactor()\n\n///查询设备最短边。\ncontext.mediaQueryShortestSide()\n\n///如果宽度大于800，则为真。\ncontext.showNavbar()\n\n///如果最短边小于600p，则为真。\ncontext.isPhone()\n\n///如果最短边大于600p，则为真。\ncontext.isSmallTablet()\n\n///如果最短边大于720p，则为真。\ncontext.isLargeTablet()\n\n///如果当前设备是平板电脑，则为真\ncontext.isTablet()\n\n///根据页面大小返回一个值<T>。\n///可以给值为：\n///watch：如果最短边小于300\n///mobile：如果最短边小于600\n///tablet：如果最短边（shortestSide）小于1200\n///desktop：如果宽度大于1200\ncontext.responsiveValue<T>()\n```\n\n### 可选的全局设置和手动配置\n\nGetMaterialApp为你配置了一切，但如果你想手动配置Get。\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [GetObserver()],\n);\n```\n\n你也可以在`GetObserver`中使用自己的中间件，这不会影响任何事情。\n\n```dart\nMaterialApp(\n  navigatorKey: Get.key,\n  navigatorObservers: [\n    GetObserver(MiddleWare.observer) // Here\n  ],\n);\n```\n\n你可以为 \"Get \"创建_全局设置。只需在推送任何路由之前将`Get.config`添加到你的代码中。\n或者直接在你的`GetMaterialApp`中做。\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  defaultTransition: Transition.fade,\n  opaqueRoute: Get.isOpaqueRouteDefault,\n  popGesture: Get.isPopGestureEnable,\n  transitionDuration: Get.defaultDurationTransition,\n  defaultGlobalState: Get.defaultGlobalState,\n);\n\nGet.config(\n  enableLog = true,\n  defaultPopGesture = true,\n  defaultTransition = Transitions.cupertino\n)\n```\n\n你可以选择重定向所有来自`Get`的日志信息。\n如果你想使用你自己喜欢的日志包，并想查看那里的日志。\n\n```dart\nGetMaterialApp(\n  enableLog: true,\n  logWriterCallback: localLogWriter,\n);\n\nvoid localLogWriter(String text, {bool isError = false}) {\n  // 在这里把信息传递给你最喜欢的日志包。\n  // 请注意，即使enableLog: false，日志信息也会在这个回调中被推送。\n  // 如果你想的话，可以通过GetConfig.isLogEnable来检查这个标志。\n}\n\n```\n\n### 局部状态组件\n\n这些Widgets允许您管理一个单一的值，并保持状态的短暂性和本地性。\n我们有Reactive和Simple两种风格。\n例如，你可以用它们来切换`TextField`中的obscureText，也许可以创建一个自定义的可扩展面板（Expandable Panel），或者在\"Scaffold \"的主体中改变内容的同时修改`BottomNavigationBar`中的当前索引。\n\n\n#### ValueBuilder\n\n`StatefulWidget`的简化，它与`.setState`回调一起工作，并接受更新的值。\n\n```dart\nValueBuilder<bool>(\n  initialValue: false,\n  builder: (value, updateFn) => Switch(\n    value: value,\n    onChanged: updateFn, // 你可以用( newValue )=> updateFn( newValue )。\n  ),\n  // 如果你需要调用 builder 方法之外的东西。\n  onUpdate: (value) => print(\"Value updated: $value\"),\n  onDispose: () => print(\"Widget unmounted\"),\n),\n```\n\n#### ObxValue\n\n类似于[`ValueBuilder`](#valuebuilder)，但这是Reactive版本，你需要传递一个Rx实例（还记得神奇的.obs吗？自动更新......是不是很厉害？）\n\n```dart\nObxValue((data) => Switch(\n        value: data.value,\n        onChanged: data, // Rx 有一个 _callable_函数! 你可以使用 (flag) => data.value = flag,\n    ),\n    false.obs,\n),\n```\n\n## 有用的提示\n\n`.obs`ervables (也称为_Rx_ Types)有各种各样的内部方法和操作符。\n\n> `.obs`的属性**是**实际值，不要搞错了!\n> 我们避免了变量的类型声明，因为Dart的编译器足够聪明，而且代码\n> 看起来更干净，但：\n\n```dart\nvar message = 'Hello world'.obs;\nprint( 'Message \"$message\" has Type ${message.runtimeType}');\n```\n\n即使`message` _prints_实际的字符串值，类型也是**RxString**！\n所以，你不能做`message.substring( 0, 4 )`。\n你必须在_observable_里面访问真正的`value`。\n最常用的方法是\".value\", 但是你也可以用...\n\n```dart\nfinal name = 'GetX'.obs;\n//只有在值与当前值不同的情况下，才会 \"更新 \"流。\nname.value = 'Hey';\n\n// 所有Rx属性都是 \"可调用 \"的，并返回新的值。\n//但这种方法不接受 \"null\"，UI将不会重建。\nname('Hello');\n\n// 就像一个getter，打印'Hello'。\nname() ;\n\n///数字。\n\nfinal count = 0.obs;\n\n// 您可以使用num基元的所有不可变操作!\ncount + 1;\n\n// 注意！只有当 \"count \"不是final时，这才有效，除了var\ncount += 1;\n\n// 你也可以与数值进行比较。\ncount > 2;\n\n/// booleans:\n\nfinal flag = false.obs;\n\n// 在真/假之间切换数值\nflag.toggle();\n\n\n/// 所有类型。\n\n// 将 \"value \"设为空。\nflag.nil();\n\n// 所有的toString()、toJson()操作都会向下传递到`value`。\nprint( count ); // 在内部调用 \"toString() \"来GetRxInt\n\nfinal abc = [0,1,2].obs;\n// 将值转换为json数组，打印RxList。\n// 所有Rx类型都支持Json!\nprint('json: ${jsonEncode(abc)}, type: ${abc.runtimeType}');\n\n// RxMap, RxList 和 RxSet 是特殊的 Rx 类型，扩展了它们的原生类型。\n// 但你可以像使用普通列表一样使用列表，尽管它是响应式的。\nabc.add(12); // 将12添加到列表中，并更新流。\nabc[3]; // 和Lists一样，读取索引3。\n\n\n// Rx和值是平等的，但hashCode总是从值中提取。\nfinal number = 12.obs;\nprint( number == 12 ); // prints > true\n\n///自定义Rx模型。\n\n// toJson(), toString()都是递延给子代的，所以你可以在它们上实现覆盖，并直接打印()可观察的内容。\n\nclass User {\n    String name, last;\n    int age;\n    User({this.name, this.last, this.age});\n\n    @override\n    String toString() => '$name $last, $age years old';\n}\n\nfinal user = User(name: 'John', last: 'Doe', age: 33).obs;\n\n// `user`是 \"响应式 \"的，但里面的属性却不是!\n// 所以，如果我们改变其中的一些变量：\nuser.value.name = 'Roi';\n// 小部件不会重建！ \n// 对于自定义类，我们需要手动 \"通知 \"改变。\nuser.refresh();\n\n// 或者我们可以使用`update()`方法!\nuser.update((value){\n  value.name='Roi';\n});\n\nprint( user );\n```\n\n#### GetView\n\n我很喜欢这个Widget，很简单，很有用。\n\n它是一个对已注册的`Controller`有一个名为`controller`的getter的`const Stateless`的Widget，仅此而已。\n\n```dart\n class AwesomeController extends GetxController {\n   final String title = 'My Awesome View';\n }\n\n  // 一定要记住传递你用来注册控制器的`Type`!\n class AwesomeView extends GetView<AwesomeController> {\n   @override\n   Widget build(BuildContext context) {\n     return Container(\n       padding: EdgeInsets.all(20),\n       child: Text( controller.title ), // 只需调用 \"controller.something\"。\n     );\n   }\n }\n```\n\n#### GetWidget\n\n大多数人都不知道这个Widget，或者完全搞不清它的用法。\n这个用例非常少见且特殊：它 \"缓存 \"了一个Controller，由于_cache_，不能成为一个 \"const Stateless\"（因为_cache_，所以不能成为一个`const Stateless`）。\n\n> 那么，什么时候你需要 \"缓存 \"一个Controller？\n\n如果你使用了**GetX**的另一个 \"不常见 \"的特性 `Get.create()`\n\n`Get.create(()=>Controller())` 会在每次调用时生成一个新的`Controller`\n`Get.find<Controller>()`\n\n你可以用它来保存Todo项目的列表，如果小组件被 \"重建\"，它将保持相同的控制器实例。\n\n#### GetxService\n\n这个类就像一个 \"GetxController\"，它共享相同的生命周期（\"onInit()\"、\"onReady()\"、\"onClose()\"）。\n但里面没有 \"逻辑\"。它只是通知**GetX**的依赖注入系统，这个子类**不能**从内存中删除。\n\n所以这对保持你的 \"服务 \"总是可以被`Get.find()`获取到并保持运行是超级有用的。比如\n`ApiService`，`StorageService`，`CacheService`。\n\n```dart\nFuture<void> main() async {\n  await initServices(); /// 等待服务初始化.\n  runApp(SomeApp());\n}\n\n/// 在你运行Flutter应用之前，让你的服务初始化是一个明智之举。\n////因为你可以控制执行流程（也许你需要加载一些主题配置，apiKey，由用户自定义的语言等，所以在运行ApiService之前加载SettingService。\n///所以GetMaterialApp()不需要重建，可以直接取值。\nvoid initServices() async {\n  print('starting services ...');\n  ///这里是你放get_storage、hive、shared_pref初始化的地方。\n  ///或者moor连接，或者其他什么异步的东西。\n  await Get.putAsync(() => DbService().init());\n  await Get.putAsync(SettingsService()).init();\n  print('All services started...');\n}\n\nclass DbService extends GetxService {\n  Future<DbService> init() async {\n    print('$runtimeType delays 2 sec');\n    await 2.delay();\n    print('$runtimeType ready!');\n    return this;\n  }\n}\n\nclass SettingsService extends GetxService {\n  void init() async {\n    print('$runtimeType delays 1 sec');\n    await 1.delay();\n    print('$runtimeType ready!');\n  }\n}\n\n```\n\n实际删除一个`GetxService`的唯一方法是使用`Get.reset()`，它就像\"热重启 \"你的应用程序。\n\n所以如果你需要在你的应用程序的生命周期内对一个类实例进行绝对的持久化，请使用`GetxService`。\n\n# 从2.0开始的兼容性变化\n\n1- Rx类型。\n\n| Before  | After      |\n| ------- | ---------- |\n| StringX | `RxString` |\n| IntX    | `RxInt`    |\n| MapX    | `RxMap`    |\n| ListX   | `RxList`   |\n| NumX    | `RxNum`    |\n| DoubleX | `RxDouble` |\n\n现在RxController和GetBuilder已经合并了，你不再需要记住你要用哪个控制器，只要用GetxController就可以了，它可以用于简单的状态管理，也可以用于响应式。\n\n2- 别名路由\n之前：\n\n```dart\nGetMaterialApp(\n  namedRoutes: {\n    '/': GetRoute(page: Home()),\n  }\n)\n```\n\n现在:\n\n```dart\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page: () => Home()),\n  ]\n)\n```\n\n为什么要做这样的改变？\n通常情况下，可能需要通过一个参数，或者一个登录令牌来决定显示哪个页面。\n将页面插入到一个函数中，大大降低了RAM的消耗，因为自从应用程序启动后，路由将不会在内存中分配。\n\n```dart\n\nGetStorage box = GetStorage();\n\nGetMaterialApp(\n  getPages: [\n    GetPage(name: '/', page:(){\n      return box.hasData('token') ? Home() : Login();\n    })\n  ]\n)\n```\n\n# 为什么选择Getx？\n\n1- Flutter更新后，很多时候，你的很多包都会坏掉。有时会发生编译错误，经常出现的错误，至今仍没有答案，开发者需要知道错误的来源，跟踪错误，才会尝试在相应的仓库中开一个问题，并看到其问题的解决。Get集中了开发的主要资源（状态、依赖和路由管理），让你可以在pubspec中添加一个包，然后开始工作。Flutter更新后，你唯一需要做的就是更新Get依赖，然后开始工作。Get还可以解决兼容性问题。有多少次，一个包的版本与另一个包的版本不兼容，因为一个包在一个版本中使用了依赖，而另一个包在另一个版本中使用了依赖？使用Get也不用担心这个问题，因为所有的东西都在同一个包里，是完全兼容的。\n\n2- Flutter很简单，Flutter很不可思议，但是Flutter仍然有一些代码，对于大多数开发者来说可能是不需要的，比如`Navigator.of(context).push (context, builder [...]`，你写了8行代码仅仅只为了调用一个路由。而使用Get只需`Get.to(Home())`就完成了，你将进入下一个页面。动态网页URL是目前Flutter中非常痛苦的一件事，而用GetX则非常简单。在Flutter中管理状态，管理依赖关系也产生了很多讨论，因为pub中的模式有上百种。但是没有什么比在你的变量末尾加一个\".obs \"更简单的了，把你的widget放在一个Obx里面，就这样，所有对这个变量的更新都会在页面上自动更新。\n\n3-轻松，不用担心性能。Flutter的性能已经很惊人了，但是想象一下，你使用一个状态管理器，和一个定位器来分布你的blocs/stores/controllers/等等类。当你不需要那个依赖的时候，你必须手动调用排除它。但是，你有没有想过简单地使用你的控制器，当它不再被任何人使用时，它会简单地从内存中删除？这就是GetX所做的。有了SmartManagement，所有不被使用的东西都会从内存中删除，除了编程，您不应该担心任何事情。GetX将保证您消耗的是最低限度的必要资源，甚至没有为此创建一个逻辑。\n\n4-实际解耦。你可能听说过 \"将界面与业务逻辑分离 \"的概念。这并不是BLoC、MVC、MVVM的特例，市面上的其他标准都有这个概念。但是，由于使用了上下文（context），这个概念在Flutter中往往可以得到缓解。\n如果你需要上下文来寻找InheritedWidget，你需要在界面中找到它，或者通过参数传递上下文。我特别觉得这种解决方案非常丑陋，要在团队中工作，我们总会对View的业务逻辑产生依赖。Getx与标准的做法不一样，虽然它并没有完全禁止使用StatefulWidgets、InitState等，但它总有类似的方法，可以更干净。控制器是有生命周期的，例如当你需要进行APIREST请求时，你不依赖于界面中的任何东西。你可以使用onInit来启动http调用，当数据到达时，变量将被填充。由于GetX是完全响应式的（真的，在流下工作），一旦项目被填充，所有使用该变量的widgets将在界面中自动更新。这使得具有UI专业知识的人只需要处理widget，除了用户事件（比如点击按钮）之外，不需要向业务逻辑发送任何东西，而处理业务逻辑的人将可以自由地单独创建和测试业务逻辑。\n\n这个库会一直更新和实现新的功能。欢迎提供PR，并为其做出贡献。\n\n# 社区\n\n## 社区渠道\n\nGetX拥有一个非常活跃且乐于助人的社区。如果你有问题，或者想得到关于这个框架使用的任何帮助，请加入我们的社区频道。这个资源库是提问、申请资源的专用库，欢迎随时加入GetX社区。\n\n| **Slack**                                                                                                                   | **Discord**                                                                                                                 | **Telegram**                                                                                                          |\n| :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------- |\n| [![Get on Slack](https://img.shields.io/badge/slack-join-orange.svg)](https://communityinviter.com/apps/getxworkspace/getx) | [![Discord Shield](https://img.shields.io/discord/722900883784073290.svg?logo=discord)](https://discord.com/invite/9Hpt99N) | [![Telegram](https://img.shields.io/badge/chat-on%20Telegram-blue.svg)](https://t.me/joinchat/PhdbJRmsZNpAqSLJL6bH7g) |\n\n## 如何做贡献\n\n_想为项目做贡献吗？我们将自豪地强调你是我们的合作者之一。以下是您可以做出贡献并使Get（和Flutter）变得更好的几点。\n\n- 帮助将readme翻译成其他语言。\n- 为readme添加文档（Get的很多功能还没有被记录下来）。\n- 撰写文章或制作视频，教大家如何使用Get（它们将被记录到readme和未来的Wiki中）。\n- 提供代码/测试的PR。\n- 包括新功能。\n\n欢迎任何贡献\n\n## 文章和视频\n\n- [Dynamic Themes in 3 lines using GetX™](https://medium.com/swlh/flutter-dynamic-themes-in-3-lines-c3b375f292e3) - Tutorial by [Rod Brown](https://github.com/RodBr).\n- [Complete GetX™ Navigation](https://www.youtube.com/watch?v=RaqPIoJSTtI) - Route management video by Amateur Coder.\n- [Complete GetX State Management](https://www.youtube.com/watch?v=CNpXbeI_slw) - State management video by Amateur Coder.\n- [GetX™ Other Features](https://youtu.be/ttQtlX_Q0eU) - utils, storage, bindings and other features video by Amateur Coder.\n- [Firestore User with GetX | Todo App](https://www.youtube.com/watch?v=BiV0DcXgk58) - Video by Amateur Coder.\n- [Firebase Auth with GetX | Todo App](https://www.youtube.com/watch?v=-H-T_BSgfOE) - Video by Amateur Coder.\n- [The Flutter GetX™ Ecosystem ~ State Management](https://medium.com/flutter-community/the-flutter-getx-ecosystem-state-management-881c7235511d) - State management by [Aachman Garg](https://github.com/imaachman).\n- [GetX, the all-in-one Flutter package](https://www.youtube.com/watch?v=IYQgtu9TM74) - A brief tutorial covering State Management and Navigation by Thad Carnevalli.\n- [Build a To-do List App from scratch using Flutter and GetX](https://www.youtube.com/watch?v=EcnqFasHf18) - UI + State Management + Storage video by Thad Carnevalli.\n- [GetX Flutter Firebase Auth Example](https://medium.com/@jeffmcmorris/getx-flutter-firebase-auth-example-b383c1dd1de2) - Article by Jeff McMorris.\n- [Flutter State Management with GetX – Complete App](https://www.appwithflutter.com/flutter-state-management-with-getx/) - by App With Flutter.\n- [Flutter Routing with Animation using Get Package](https://www.appwithflutter.com/flutter-routing-using-get-package/) - by App With Flutter.\n- [Flutter GetX use --- simple charm!](https://github.com/CNAD666/getx_template/blob/main/docs/Use%20of%20Flutter%20GetX---simple%20charm!.md) - CNAD666\n  - [Flutter GetX使用---简洁的魅力！](https://juejin.cn/post/6924104248275763208)\n\n"
        },
        {
          "name": "_config.yml",
          "type": "blob",
          "size": 0.025390625,
          "content": "theme: jekyll-theme-cayman"
        },
        {
          "name": "analysis_options.yaml",
          "type": "blob",
          "size": 0.1484375,
          "content": "# Include option is buggy:\ninclude: package:flutter_lints/flutter.yaml\n# In case the include issue gets fixed, lines below INCLUDE_FIX\n# can be removed\n"
        },
        {
          "name": "documentation",
          "type": "tree",
          "content": null
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "example_nav2",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "pubspec.yaml",
          "type": "blob",
          "size": 1.69140625,
          "content": "name: get\ndescription: Open screens/snackbars/dialogs without context, manage states and inject dependencies easily with GetX.\nversion: 5.0.0-release-candidate-9.2.1\nhomepage: https://github.com/jonataslaw/getx\n\nenvironment:\n  sdk: \">=3.4.0 <4.0.0\"\n  flutter: \">=3.22.0\"\n\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_web_plugins:\n    sdk: flutter\n  web: \">=0.5.0 <2.0.0\"\n\ndev_dependencies:\n  flutter_lints: ^4.0.0\n  flutter_test:\n    sdk: flutter\n\n# For information on the generic Dart part of this file, see the\n# following page: https://dart.dev/tools/pub/pubspec\n\n# The following section is specific to Flutter.\nflutter:\n\n  # To add assets to your package, add an assets section, like this:\n  # assets:\n  #  - images/a_dot_burr.jpeg\n  #  - images/a_dot_ham.jpeg\n  #\n  # For details regarding assets in packages, see\n  # https://flutter.dev/assets-and-images/#from-packages\n  #\n  # An image asset can refer to one or more resolution-specific \"variants\", see\n  # https://flutter.dev/assets-and-images/#resolution-aware.\n\n  # To add custom fonts to your package, add a fonts section here,\n  # in this \"flutter\" section. Each entry in this list should have a\n  # \"family\" key with the font family name, and a \"fonts\" key with a\n  # list giving the asset and other descriptors for the font. For\n  # example:\n  # fonts:\n  #   - family: Schyler\n  #     fonts:\n  #       - asset: fonts/Schyler-Regular.ttf\n  #       - asset: fonts/Schyler-Italic.ttf\n  #         style: italic\n  #   - family: Trajan Pro\n  #     fonts:\n  #       - asset: fonts/TrajanPro.ttf\n  #       - asset: fonts/TrajanPro_Bold.ttf\n  #         weight: 700\n  #\n  # For details regarding fonts in packages, see\n  # https://flutter.dev/custom-fonts/#from-packages\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}