{
  "metadata": {
    "timestamp": 1736710563685,
    "page": 153,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "brianegan/flutter_redux",
      "stars": 1656,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1328125,
          "content": ".DS_Store\n.atom/\n.idea\n.packages\n.dart_tool/\n.pub/\nbuild/\nios/.generated/\npackages\npubspec.lock\n.flutter-plugins\n*.iml\n/coverage/\n*.log\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 4.1982421875,
          "content": "## 0.10.0\n\n  * `onDidChange` now passed proper old and new value\n  \n## 0.10.0-beta.1\n\n  * Remove deprecated null check against `WidgetsBinding.instance`\n  \n## 0.9.0\n\n  * Throw Errors from onWillChange and onDidChange callbacks\n\n## 0.8.2\n\n  * Nullable ViewModels for callback functions as well as build\n\n## 0.8.1\n\n  * Support nullable ViewModels\n\n## 0.8.0\n\n  * Breaking Change: added null-safety\n  * Breaking Change: updated to redux 5.0.0\n\n## 0.7.0\n\n  * Improved error messages in converters\n  * Update InheritedWidget methods to latest version\n\n## 0.6.0\n\n  * Breaking Change: `onWillChange` now receives previous and new `ViewModel`\n  * Breaking Change: Supports Redux 4.x - 5.0 \n\n## 0.5.4\n\n  * Bugfix: Rebuilding the Widget will always rebuild with latest data\n  * Enforce pedantic lint rules\n  * Docs\n    - Document all public members \n    - Add more examples to README\n\n## 0.5.3\n\n  * Maintenance update\n      * Remove dependency on test package, conflicts with latest Flutter\n      * Update docs\n      * Update example dependencies to latest versions\n      * Apply stricter analysis options\n\n## 0.5.2\n\n  * Add `onDidChange` -- This callback will be run after the ViewModel has changed and the builder method is called\n  * Add `onInitialBuild` -- This callback will be run after the builder method is called the first time\n\n## 0.5.1\n\n  * Add more advice to error message\n\n## 0.5.0\n\n  * Updated to work with latest version of Redux: 3.0.0\n\n## 0.4.1\n\n  * Update example to wrap entire app with StoreProvider\n  * Throw more helpful error message if no StoreProvider is found in the tree\n\n## 0.4.0\n\n  * Works with Dart 2 (no longer supports Dart 1)\n  * Stronger Type info Required\n  * Breaking Changes: \n    * `StoreProvider` now requires generic type info: `new StoreProvider<AppState>`\n    * `new StoreProvider.of(context).store` is now `StoreProvider.of<AppState>(context)`\n    \n## 0.3.6\n\n  * Add `onWillChange`. This function will be called before the builder and can be used for working with Imperative APIs, such as Navigator, TextEditingController, or TabController.\n\n## 0.3.6\n\n  * Add `onWillChange`. This function will be called before the builder and can be used for working with Imperative APIs, such as Navigator, TextEditingController, or TabController.\n\n## 0.3.5\n\n  * Bugfix: `onInit` was not called before the initial ViewModel is constructed. \n\n## 0.3.4\n\n  * Fix Changelog. \n\n## 0.3.3\n\n  * Optional `onDispose` function - The `StoreConnector` and `StoreBuilder` Widgets now accept an `onDispose` function that will be run when the Widget is removed from the Widget tree (using State.dispose under the hood). The `onDispose` function takes the Store as the first parameter, and can be used to dispatch actions that remove stale data from your State tree.\n  * Move to github\n\n## 0.3.2\n\n  * Optional `onInit` function - The `StoreConnector` and `StoreBuilder` Widgets now accept an `onInit` function that will be run the first time the Widget is created (using State.initState under the hood). The `onInit` function takes the Store as the first parameter, and can be used to dispatch actions when your Widget is first starting up. This can be useful for data fetching.\n  * `ignoreChange` function - `StoreConnector` now takes an advanced usage / optional function `ignoreChange`. It will be run on every store `onChange` event to determine whether or not the `ViewModel` and `Widget` should be rebuilt. This can be useful in some edge cases, such as displaying information that has been deleted from the store while it is animating off screen. \n  * Documentation updates\n\n## 0.3.1\n\n  * Add the ability to build only once, while avoiding rebuilding on change. This can be handy if you need to manage access to the Store, but want to handle when to update your own Widgets. \n  \n## 0.3.0\n\n  * Make `StoreProvider.of` a factory rather than a static method\n  * Additional documentation based on questions from the community\n  \n## 0.2.0\n\n  * Update for Redux 2.0.0\n  \n## 0.1.1\n\n  * Update documentation\n\n## 0.1.0\n\nInitial Version of the library. \n\n  * Includes the ability to pass a Redux `Store` down to descendant Widgets using a `StoreProvider`. \n  * Includes the `StoreConnector` and `StoreBuilder` Widgets that capture the `Store` from the `StoreProvider` and build a Widget in response.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05078125,
          "content": "The MIT License (MIT)\nCopyright (c) 2017 Brian Egan\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without restriction,\nincluding without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software,\nand to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\nUSE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.7802734375,
          "content": "# flutter_redux\n\n[![Build Status](https://travis-ci.org/brianegan/flutter_redux.svg?branch=master)](https://travis-ci.org/brianegan/flutter_redux)  [![codecov](https://codecov.io/gh/brianegan/flutter_redux/branch/master/graph/badge.svg)](https://codecov.io/gh/brianegan/flutter_redux)\n\nA set of utilities that allow you to easily consume a\n[Redux](https://pub.dartlang.org/packages/redux) Store to build Flutter Widgets.\n\nThis package supports null-safety and is built to work with\n[Redux.dart](https://pub.dartlang.org/packages/redux) 5.0.0+ and Flutter 3+.\n\n## Redux Widgets \n\n  * `StoreProvider` - The base Widget. It will pass the given Redux Store to all descendants that request it.\n  * `StoreBuilder` - A descendant Widget that gets the Store from a `StoreProvider` and passes it to a Widget `builder` function.\n  * `StoreConnector` - A descendant Widget that gets the Store from the nearest `StoreProvider` ancestor, converts the `Store` into a `ViewModel` with the given `converter` function, and passes the `ViewModel` to a `builder` function. Any time the Store emits a change event, the Widget will automatically be rebuilt. No need to manage subscriptions!\n\n## Examples\n\n  * [Simple example](https://github.com/brianegan/flutter_redux/tree/master/example/counter) - a port of the standard \"Counter Button\" example from Flutter\n  * [Github Search](https://github.com/brianegan/flutter_redux/tree/master/example/github_search) - an example of how to search as a user types, demonstrating both the Middleware and Epic approaches.\n  * [Todo app](https://github.com/brianegan/flutter_architecture_samples/tree/master/redux) - a more complete example, with persistence, routing, and nested state.\n  * [Timy Messenger](https://github.com/janoodleFTW/timy-messenger) - large open source app that uses flutter_redux together with Firebase Firestore.\n  \n### Companion Libraries\n  * [flipperkit_redux_middleware](https://pub.dartlang.org/packages/flipperkit_redux_middleware) - Redux Inspector (use [Flutter Debugger](https://github.com/blankapp/flutter-debugger)) for Flutter Redux apps\n  * [flutter_redux_dev_tools](https://pub.dartlang.org/packages/flutter_redux_dev_tools) - Time Travel Dev Tools for Flutter Redux apps\n  * [redux_persist](https://github.com/Cretezy/redux_persist) - Persist Redux State   \n  * [flutter_redux_navigation](https://github.com/flutterings/flutter_redux_navigation) - Use redux events for navigation\n  * [flutter_redux_gen](https://marketplace.visualstudio.com/items?itemName=BalaDhruv.flutter-redux-gen) - VS Code Extension to generate redux code.\n \n## Usage\n\nLet's demo the basic usage with the all-time favorite: A counter example!\n\nNote: This example requires flutter_redux 0.4.0+ and Dart 2! If you're using\nDart 1, [see the old\nexample](https://github.com/brianegan/flutter_redux/blob/eb4289795a5a70517686ccd1d161abdb8cc08af5/example/lib/main.dart).\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_redux/flutter_redux.dart';\nimport 'package:redux/redux.dart';\n\n// One simple action: Increment\nenum Actions { Increment }\n\n// The reducer, which takes the previous count and increments it in response\n// to an Increment action.\nint counterReducer(int state, dynamic action) {\n  return action == Actions.Increment ? state + 1 : state;\n}\n\nvoid main() {\n  // Create your store as a final variable in the main function or inside a\n  // State object. This works better with Hot Reload than creating it directly\n  // in the `build` function.\n  final store = Store<int>(counterReducer, initialState: 0);\n\n  runApp(FlutterReduxApp(\n    title: 'Flutter Redux Demo',\n    store: store,\n  ));\n}\n\nclass FlutterReduxApp extends StatelessWidget {\n  final Store<int> store;\n  final String title;\n\n  FlutterReduxApp({Key key, this.store, this.title}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    // The StoreProvider should wrap your MaterialApp or WidgetsApp. This will\n    // ensure all routes have access to the store.\n    return StoreProvider<int>(\n      // Pass the store to the StoreProvider. Any ancestor `StoreConnector`\n      // Widgets will find and use this value as the `Store`.\n      store: store,\n      child: MaterialApp(\n        theme: ThemeData.dark(),\n        title: title,\n        home: Scaffold(\n          appBar: AppBar(title: Text(title)),\n          body: Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                // Connect the Store to a Text Widget that renders the current\n                // count.\n                //\n                // We'll wrap the Text Widget in a `StoreConnector` Widget. The\n                // `StoreConnector` will find the `Store` from the nearest\n                // `StoreProvider` ancestor, convert it into a String of the\n                // latest count, and pass that String  to the `builder` function\n                // as the `count`.\n                //\n                // Every time the button is tapped, an action is dispatched and\n                // run through the reducer. After the reducer updates the state,\n                // the Widget will be automatically rebuilt with the latest\n                // count. No need to manually manage subscriptions or Streams!\n                StoreConnector<int, String>(\n                  converter: (store) => store.state.toString(),\n                  builder: (context, count) {\n                    return Text(\n                      'The button has been pushed this many times: $count',\n                      style: Theme.of(context).textTheme.display1,\n                    );\n                  },\n                )\n              ],\n            ),\n          ),\n          // Connect the Store to a FloatingActionButton. In this case, we'll\n          // use the Store to build a callback that will dispatch an Increment\n          // Action.\n          //\n          // Then, we'll pass this callback to the button's `onPressed` handler.\n          floatingActionButton: StoreConnector<int, VoidCallback>(\n            converter: (store) {\n              // Return a `VoidCallback`, which is a fancy name for a function\n              // with no parameters and no return value. \n              // It only dispatches an Increment action.\n              return () => store.dispatch(Actions.Increment);\n            },\n            builder: (context, callback) {\n              return FloatingActionButton(\n                // Attach the `callback` to the `onPressed` attribute\n                onPressed: callback,\n                tooltip: 'Increment',\n                child: Icon(Icons.add),\n              );\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n```    \n\n## Purpose\n\nOne question that [reasonable people might\nask](https://www.reddit.com/r/FlutterDev/comments/6vscdy/a_set_of_utilities_that_allow_you_to_easily/dm3ll7d/):\nWhy do you need all of this if `StatefulWidget` exists?\n\nMy advice is the same as the original Redux.JS author: If you've got a simple\napp, use the most straightforward thing possible. In Flutter, `StatefulWidget` is perfect\nfor a simple counter app.\n\nHowever, say you have the more complex app, such as an E-commerce app with a\nShopping Cart. The Shopping Cart should appear on multiple screens in your app\nand should be updated by many different types of Widgets on those different\nscreens (An \"Add Item to Cart\" Widget on all your Product Screens, \"Remove Item\nfrom Cart\" Widget on the Shopping Cart Screen, \"Change quantity\" Widgets, etc.).\n\nAdditionally, you want to test this logic, as it's the core business\nlogic to your app!\n\nNow, in this case, you could create a Testable `ShoppingCart` class as a\nSingleton or Create a Root `StatefulWidget` that passes the `ShoppingCart `*Down\nDown Down* through your widget hierarchy to the \"add to cart\" or \"remove from\ncart\" Widgets.\n\nSingletons can be problematic for testing, and Flutter doesn't have a great\nDependency Injection library (such as Dagger2) just yet, so I'd prefer to avoid\nthose.\n\n\tYet passing the ShoppingCart all over the place can get messy. It also means\nit's way harder to move that \"Add to Item\" button to a new location b/c you'd\nneed up update the Widgets throughout your app that passes the state down.\n\nFurthermore, you'd need a way to Observe when the `ShoppingCart` Changes so you\ncould rebuild your Widgets when it does (from an \"Add\" button to an \"Added\"\nbutton, as an example).\n\nOne way to handle it would be to simply `setState` every time the `ShoppingCart`\nchanges in your Root Widget, but then your whole app below the RootWidget would\nbe required to rebuild as well! Flutter is fast, but we should be thoughtful about\nwhat we ask Flutter to rebuild!\n\nTherefore, `redux` & `redux_flutter` was born for more complex stories like this\none. It gives you a set of tools that allow your Widgets to `dispatch` actions\nin a naive way, then writes the business logic in another place that will take\nthose actions and update the `ShoppingCart` in a safe, testable way.\n\nEven more, once the `ShoppingCart` has been updated in the `Store`, the `Store`\nwill emit an `onChange` event. This lets you listen to `Store` updates and\nrebuild your UI in the right places when it changes! Now, you can separate your\nbusiness logic from your UI logic in a testable, observable way, without having\nto Wire up a bunch of stuff yourself!\n\nSimilar patterns in Android are the MVP Pattern or using Rx Observables to\nmanage a View's State.\n\n`flutter_redux` handles passing your `Store` down to all of your\ndescendant `StoreConnector` Widgets. If your State emits a change event, only\nthe `StoreConnector` Widgets and their descendants will be automatically rebuilt\nwith the latest State of the `Store`!\n\nThis allows you to focus on what your app should look like and how it should\nwork without thinking about all the glue code to hook everything together!\n\n### Contributors\n\n  * [Brian Egan](https://github.com/brianegan)\n  * [Chris Bird](https://github.com/chrisabird)\n"
        },
        {
          "name": "analysis_options.yaml",
          "type": "blob",
          "size": 0.1708984375,
          "content": "include: package:pedantic/analysis_options.yaml\n\nanalyzer:\n  strong-mode:\n    implicit-casts: false\n    implicit-dynamic: false\n\nlinter:\n  rules:\n    - public_member_api_docs\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "pubspec.yaml",
          "type": "blob",
          "size": 0.3583984375,
          "content": "name: flutter_redux\ndescription: A set of utility Widgets that Provide and Connect to a Redux Store\nversion: 0.10.0\nhomepage: https://github.com/brianegan/flutter_redux\n\nenvironment:\n  sdk: \">=2.12.0 <3.0.0\"\n\ndependencies:\n  redux: \">=5.0.0 <6.0.0\"\n  flutter:\n    sdk: flutter\n\ndev_dependencies:\n  pedantic: ^1.10.0\n  flutter_test:\n    sdk: flutter\n  mockito: ^5.0.0\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}