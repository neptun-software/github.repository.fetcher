{
  "metadata": {
    "timestamp": 1736710519974,
    "page": 61,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "peng8350/flutter_pulltorefresh",
      "stars": 2719,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.15625,
          "content": ".DS_Store\n.dart_tool/\n\n.packages\n.pub/\n\nbuild/\nios/.generated/\nios/Flutter/Generated.xcconfig\nios/Runner/GeneratedPluginRegistrant.*\n\n*.iml\npubspec.lock\n.idea\n\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 15.8828125,
          "content": "## 2.0.0\n### Breaking Changes:\n* Remove onOffsetChange in SmartRefresher,autoLoad in RefreshConfiguration,scrollController in RefreshController\n* add argument to onTwoLevel(callback when closed)\n\n### features\n* migrate null-safety\n* add needCallback in requestRefresh and requestLoading for avflutoiding the callback of onRefresh or onLoading\n\n### Bug fix\n* In NestedScrollView+ClampingScrollPhysics(Android ScrollBehaviour),header can be seen when fling to top.\n* unMounted widget used crash error when fast rebuild in requestRefresh\n* fix sliverRefreshBody layoutSize instead of -0.001,it will crash error when viewportMainAxis=0\n\n### Other\n* Add assert to avoid invalid usage\n\n\n\n## 1.6.5\n* fix check full page logic.\n* fix crash \"locking up a deactive widget is unsafe\".\n\n## 1.6.4\n* fix error crash by deprecated function removed \n* add extra ScrollView reference parameter\n\n\n## 1.6.3\n* fix bug:gesture disabled after refresh complete in an error refreshState\n* fix problem:Footer hide back suddenly(this cause by the flutter breaking change)\n* add vibrate option to enable vibrate when trigger onRefresh or onLoading\n* fix SmartRefresher key in mutiple widgets\n* add other languages\n\n## 1.6.2\n* fix \"_pendingDimenssion is not true\" error with the breaking change\n\n## 1.6.1\n* fix NestedScrollView requetRefresh error\n* fix NestedScollView cast error\n* fix twiceloadng when no data return\n* add support for update refreshcontroller\n* add other language\n\n## 1.6.0\n* fix slow bounce back when load more too fast\n* fix footer renderError with reverse:true,behaviour return to 1.5.7\n* add check null in requestRefresh()\n* fix refreshText reverse error(ClassicHeader) when reverse:true\n\n## 1.5.8\n* fix breaking change crash error after flutter 1.13.6 upgrade\n* add other language\n* fix material header frequently setState slow down the performance\n* fix bug:loadFinish throw error when dispose widget(short time to trigger)\n* fix WaterDropMaterialHeader \"color\" invalid\n\n## 1.5.7\n* add three national language: French,Russian,...\n* fix endLoading logic error in callback\n* add enableLoadMoreWhenNoMoreData,enable switch to decide whether auto load more when footer state is noMore\n* fix requestRefresh callback onRefresh immediately\n\n## 1.5.6\n* add new feature:refresh localizations\n* The footer layout size should be added to calculate whether the Viewport is full of a screen\n* fix physics check error when theme use other platform\n* add topHitBoundary,bottomHitBoundary in RefreshConfiguration\n* move headerOffset from RefreshConfiguration,move to indicator setting\n* In Android systems,default change: fast fling will be stopped in 0 pixels\n* Optimized part indicator,auto attach primaryColor from Theme,text style adjust etc..\n* Optimize requestRefresh() and requestLoading(),avoid spring back when far from target point,add one parameter controll whether to move down or top\n\n## 1.5.5\n\n### breaking change\n* add new canLoading state for footer\n* add canLoadingText,canLoadingIcon,completeDuration in footer\n* enableLoadingWhenFailed default value change to true\n* shouldFollowContentWhenNotFull: in noMore state default return true\n\n### twoLevel\n* add TwoLevelHeader,reduce the difficulty of using the second floor function\n\n\n### Bug fix\n* twoLevel bug: fix viewportDimenssion use error,which lead to height dynamic error\n* fix underScroll bug when footer is noMore state or hideWhenNotFull=true and viewport not full one screen in Android\n* NeverScrollPhysics is ignored,when passing NeverScrollPhysics,it should disable scroll\n\n### other\n* add enableBallisticLoad(same with enableBallisticRefresh) in RefreshConfiguration\n* add requestTwoLevel method in RefreshController\n* add endLoading,readyToLoad for CustomFooter\n* add ScrollView's props to SmartRefresher,mostly for SingleChildView not ScrollView\n\n## 1.5.4\n* add new RefreshConfiguration constructor \"copyAncestor\"\n* fix bug 1: when !enablePullDown && !enablePullUp crash error\n* fix bug 2: \"pixels\" call on null when refresh completed and ready to springback In a very short time and disposed\n* enable \"primary\" attr working,Avoiding clicking on the status bar to cause scrolling to the top in some stiuation\n* requestRefresh() and requestLoading() change to return a future\n\n## 1.5.3\n* add new indicator: BezierCircleHeader\n* change spring default value ,make it fast and smooth\n* fix cast ScrollPosition error with NestedScrollView\n\n## 1.5.2\n* change maxOverScrollExtent default to 60\n* maxScrollExtent should subtract layoutExtent instead of boxExtent when indicator not floating\n* add SmartRefresher builder constructor for some special use stage\n* when child is not extends scrollView,it should convert height to viewport's height when child's height is infite,such as PageView,emptyWidget with Center,else it will use LayoutBuilder get height\n* header,footer now unlimit the type ,convert to widget,but only sliver widget,Considering the problem of combined indicators\n* CustomHeader,CustomFooter expose inner indicator event\n* resetNoData should only can work when footer indicator is noMore state\n* fix twolevel and refresh prior problem\n\n## 1.5.1\n* add api docs in code\n* add test to prevent previous bugs as much as possible\n* enableScrollWhenCompleted default value change to false,when header spring back,doesn't allow to scroll by gesture\n* improve enableScrollWhenCompleted safety ,fix trigger disable scroll times error\n* maxScrollExtent should subtract boxExtent when floating(indicator layoutExtent != 0) or not\n* maxOverScrollExtent default change to 30.0 in Android,maxUnderScrollExtent default change to 0.0 in Android\n* Fix footer onClick not working when click near footer edge\n* fix canTwoLevel text showing in other twoLevel state\n* when enablePullDown= false && enableTwoLevel = true,it should add header into Viewport\n* remove reverse in some header indicators,inner auto check direction,no need to pass paramter\n* fix render error in footer when asix = Horizontal & reverse = true\n\n## 1.5.0\n* Fix a Big Bug in FrontStyle:When overScroll(pixels <0.0),it shouldn't be disabled gesture\n* add shouldFollowContentWhenNotFull \n* add support to scrollable widget\n* Fix ignore reverse load more paintOrigin issue \n* change hideFooterWhenNotfull default value to false\n* update header default releaseIcon and footer idle default Icon\n\n## 1.4.9\n* Fix MaterialClassicHeader,WaterDropHeader some err\n* Optimze WaterdropMaterial\n* remove hit top in clamping physics\n* add springDescrition,dragSpeedRatio in RefreshConfiguration\n* fix BehindStyle layoutExtent error\n\n## 1.4.8\n* provide three load more style:ShowAlways,HideAlways,ShowWhenLoading\n* add linkFooter\n* Fix Bug: requestRefresh() interupted when physics =Clamping && offset !=0\n* Fix Bug: When viewport not enough onepage ,pull up will change the state to loading,but not callback onLoading\n* revert change before:SmartRefresher change Stateless,Fix position may be null in some stiuations\n* add enableScrollWhenRefreshCompleted,enableBallisticRefresh,enableLoadingWhenFailed bool in RefreshConfiguration\n* enable footerTriggerdistance pass Negative\n\n## 1.4.7\nnew Feature:\n* Add twoLevel refresh feature\n* Add linkHeader to link other place header\n\nSmartRefresher:\n* Remove headerInsertIndex(only first sliver)\n* Fix ignore padding attr when child is BoxScrollView\n* add enableTwoLevel,onTwoLevel attr\n\nRefreshConfiguration:\n* add enableScrollWhenTwoLevel,closeTwoLevelDistance for twoLevel setting\n\nRefreshController:\n* Add refreshToidle, twoLevelComplete new api\n* Add initalRefreshStatus,initalLoadStatus new parameter setting default value\n\nClassicalIndicator:\n* remove decoration\n* add outerBuilder replace decoration\n* add other attr for twoLevel\n\nBug Fix:\n* Fix clicking footer trigger loading when no more state\n* footer indicator shouldn't hide when state in noMore,failed and not full in one page\n\nother:\n* Remove asSliver usage in all indicators(no need to use,only support first sliver)\n* make indicator auto fit boxSize,just like SliverToBoxAdapter\n\n## 1.4.6\n* Add horizontal refresh support\n* Fix 1.4.5  default physics Bug  in Android simulation\n* Fix Problem: when enablePullDown or enablePullUp = false,it still can overScroll or underScroll when use ClampingScrollPhysics\n* Add maxOverScrollExtent and maxUnderScrollExtent in RefreshConfiguration\n\n## 1.4.5\n* Remake FrontStyle implements principle,Make it close to the first three styles,Fix some small problems also:\n1.when tap StatusBar,it will trigger refresh instead of scroll to top\n2.It seems odd to set aside 100 heights in front of scrollOffset for FrontStyle\n3.When hideWhenNotFull = false, dragging to pull down will cause loading together\n\n* Remake RefreshPhysics,Simpify code,child support physics setting now.\n* ClassicIndicator default refreshingIcon:in iOS use ActivityIndicator,in Android use CircularProgressIndicator\n\n## 1.4.4\n* Fix Bug:Multiples ScrollPositions shared one ScrollController,when calling controller.requestRefresh cause refresh together( such as keepAlive Widget )\n* When the user Dragging ScrollView(pull up), disable make it change to loading state\n* Add one new LoadStatus:failed(provide click to retry loading)\n* Fix some defaultIcon:noMoreIcon default Invisible\n\n## 1.4.3\n* change \"child\" attr limit type from ScrollView to Widget\n\n## 1.4.2\n* Improving hideWhenNotFull judgment mechanism\n* Fix triggerDistance error after 1.4.0-1.4.1\n\n## 1.4.1\n* Remove isNestedWrapped(deprecated from 1.3.8)\n* Add headerInsertIndex attr in SmartRefresher\n* Rename IndicatorConfiguration to RefreshConfiguration\n* Move some attr from Indicator to RefreshConfiguration:offset,skipCanRefresh,triggerDistance,autoLoad,hideWhenNotFull\n* Add decoration for classicIndicator(both header and footer)\n* Add Fade effect for WaterDropHeader when dismiss\n* Simplify reverse operation,Add MaterialClassicHeader,WaterDropMaterialHeader reverse feature\n\n## 1.4.0\n* Fix one serious Bug after 1.3.8 upgrade to 1.3.9:enablePullDown = false throw error\n\n## 1.3.9\n* Avoid inner inject padding by buildSlivers in child(ListView,GridView)\n* Add initialRefresh in RefreshController(when you need to requestRefresh in initState)\n* Fix exception RefreshBouncingPhysics velocity value\n* Add IndicatorConfiguration for build indicator for subtrees SmartRefresher\n* Add SkipCanRefresh,CompleteDuration attr in header\n* Fix trigger more times loading when no data come in and too fast loadComplete\n* remove center,anchor in CustomScrollView to Compatible with old versions\n\n## 1.3.8\n* Temporary fix deadly bug: PrimaryScrollController cannot shared by multiple Indicators\n\n## 1.3.7\n* Adding an asSlivers constructor can be inserted into slivers as a Sliver\n* Fix FrontStyle cannot support dynamic change enablePullDown\n* Fix FrontStyle cannot enter refresh state when init\n* Optimize indicator internal code to avoid locking widgets\n* Fix iOS click status cannot roll back without ScrollController in child\n* Fix one ignored situation after finish refresh -> completed(not in visual range)\n\n## 1.3.6\n* Fix NestedScrollView issue in 1.3.5\n* decrease default triggerDistance from 100.0 to 80.0\n* improve dragging scrolling speed of Front Style\n* Add offset attr in Front Style\n\n## 1.3.5\n* Add hideWhenNotFull bool to disable auto hide footer when  data not enough one page\n* Add one new RefreshStyle:Front(just like RefreshIndicator)\n* Fix a bug: When the head overflows the view area, there is no clipping operation\n* Add material header(two indicator for FrontStyle)\n* Remove enableOverScroll\n\n## 1.3.3\n* Fixed the request Refresh problem: Sometimes it takes two times to be effective\n* Add child key support\n* Fix Bug:Pull-down triggers need to be pulled down more distances to trigger\n* Add resetNoData to resume footer state to idle\n\n## 1.3.2\n* Fix WaterDropHeader some attributes invalid\n* Fix enablePullUp and enablePullDown Dynamic set\n* implements auto hide FooterView when less than one page,no need to set enablePullUp to false\n* improve safety after disposed\n\n## 1.3.1\n* Add onClick CallBack for LoadIndicator\n* Fix enablepullUp or down invalid\n* Fix error Loading after 1.3.0 updated\n\n## 1.3.0\n### Total\n* Support reverse ScrollView\n* Remove RefreshConfig,LoadConfig,Move to indicator setting\n* Add isNestWrapped to Compatible NestedScrollView\n* replace headerBuilder,footerBuilder attribute to header,footer\n* Separate header and footer operations:onRefresh and onLoading Callback,RefreshStatus is separated into RefreshStatus.LoadStatus\n* Fix Bug: twice loading (the footer state change before the ui update)\n\n### RefreshController\n* Remove sendBack method,replaced by LoadComplete,RefreshComplete ,RefreshFailed,LoadNoData\n* Separate refresh and load operations\n* Add dispose method for Safety in some situation\n\n### Indicator\n* Use another way to achieve drop-down refresh\n* Add drop-down refresh indicator style(Follow,UnFollow,Behind)\n* Add WaterDropIndicator,CustomIndicator\n* Make Custom Indicator easily\n\n## 1.2.0\n* Fixed the problem that ScrollController was not applied to internal controls\n* Optimize RefreshController\n* RefreshController changed to  required now\n* Add feature:reuqestRefresh can jumpTo Bottom or Top\n* Fix problem: Refresh can still be triggered when ScrollView is nested internally\n* Remove rendered twice to get indicator height,replaced by using height attribute in Config\n* change RefreshStatus from int to enum\n\n## 1.1.6\n* Fix Compile error after flutter update\n\n## 1.1.5\n* Fix problem of offsetChange\n* Fix CustomScrollView didn't work\n* Fix refreshIcon not reference in ClassialIndicator\n\n## 1.1.4\n* Fix enableOverScroll does not work\n* Add default IndicatorBuilder when headerBuilder or footerBuilder is null\n* Fix cannot loading when user loosen gesture and listview enter the rebounding\n\n## 1.1.3\n* Fix contentList's item cannot be cached,Remove shrinkWrap,physics limit\n* Fix onOffsetChange callback error,In completion, failure, refresh state is also callback\n* Add unfollowIndicator implement in Demo(Example3)\n\n## 1.1.2\n* Fix Bug:Refreshing the indicator requires multiple dragging to refresh\n* Fix ClassialIndicator syntax errors and display status when no data is added.\n\n## 1.1.1\n* Make triigerDistance be equally vaild for LoadWrapper\n* Add enableOverScroll attribute\n\n## 1.1.0\nNotice: This version of the code changes much, Api too\n* Transfer state changes to Wrapper of indicator to reduce unnecessary interface refresh.\n* No longer using Refreshmode or LoadMode,replaced int because the state is hard to determine.\n* Now support the ScrollView in the reverse mode\n* The indicators are divided into two categories, loadIndicator and refreshIndicator, and the two support header and footer\n* provided a controller to invoke some essential operations inside.\n* Move triggerDistance,completeTime such props to Config\n* Add ClassicIndicator Convenient construction indicator\n\n## 1.0.8\n* Reproducing bottom indicator, no more manual drag to load more\n* Control property values change more,Mainly:1.onModeChange => onRefreshChange,onLoadChange, 2.Add enableAutoLoadMore,3.Remove bottomVisiableRange\n\n## 1.0.7\n* Fix Bug1: The use of ListView as a container to cause a fatal error (continuous sliding) when the bottom control is reclaimed, using the SingleChildScrollView instead of preventing the base control from recovering many times from the exception\n* Fix Bug2: When the user continues to call at the same time in the two states of pull-down and drop down, the animation has no callback problem when it enters or fails.\n\n## 1.0.6\n* Use Material default LoadingBar\n* Add a bool paramter to onOffsetChange to know if pullup or pulldown\n* Fix Bug: when pulled up or pull-down, sizeAnimation and IOS elasticity conflict, resulting in beating.\n\n## 1.0.5\n* Remove headerHeight,footerHeight to get height inital\n* Make footer stay at the bottom of the world forever\n* replace idle to idel(my English mistake)\n* Fix defaultIndictor error Icon display\n\n## 1.0.4\n* Update README and demo\n\n## 1.0.3\n* Fix error Props\n* Add  interupt Scroll when failure status\n\n## 1.0.2\n* Add Failed RefreshMode when catch data failed\n* ReMake Default  header and footer builder\n* Replace RefreshMode,loadMode to refreshing,loading\n* Replace onModeChange to onRefresh,onLoadMore\n\n## 1.0.1\n* Remove bottomColor\n\n## 1.0.0\n* initRelease\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.037109375,
          "content": "MIT License\n\nCopyright (c) 2018 Jpeng\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 13.818359375,
          "content": "# flutter_pulltorefresh\n<a href=\"https://pub.dev/packages/pull_to_refresh\">\n  <img src=\"https://img.shields.io/pub/v/pull_to_refresh.svg\"/>\n</a>\n<a href=\"https://flutter.dev/\">\n  <img src=\"https://img.shields.io/badge/flutter-%3E%3D%202.0.0-green.svg\"/>\n</a>\n<a href=\"https://opensource.org/licenses/MIT\">\n  <img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\"/>\n</a>\n\n## Intro\na widget provided to the flutter scroll component drop-down refresh and pull up load.support android and ios.\nIf you are Chinese,click here([中文文档](https://github.com/peng8350/flutter_pulltorefresh/blob/master/README_CN.md))\n\n\n\n## Features\n* pull up load and pull down refresh\n* It's almost fit for all Scroll witgets,like GridView,ListView...\n* provide global setting of default indicator and property\n* provide some most common indicators\n* Support Android and iOS default ScrollPhysics,the overScroll distance can be controlled,custom spring animate,damping,speed.\n* horizontal and vertical refresh,support reverse ScrollView also(four direction)\n* provide more refreshStyle: Behind,Follow,UnFollow,Front,provide more loadmore style\n* Support twoLevel refresh,implments just like TaoBao twoLevel,Wechat TwoLevel\n* enable link indicator which placing other place,just like Wechat FriendCircle refresh effect\n\n## Usage\n\nadd this line to pubspec.yaml\n\n```yaml\n\n   dependencies:\n\n    pull_to_refresh: ^2.0.0\n\n\n```\n\nimport package\n\n```dart\n\n    import 'package:pull_to_refresh/pull_to_refresh.dart';\n\n```\n\nsimple example,***It must be noted here that ListView must be the child of SmartRefresher and cannot be separated from it. For detailed reasons, see <a href=\"child\">here</a>***\n\n```dart\n\n\n  List<String> items = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"];\n  RefreshController _refreshController =\n      RefreshController(initialRefresh: false);\n\n  void _onRefresh() async{\n    // monitor network fetch\n    await Future.delayed(Duration(milliseconds: 1000));\n    // if failed,use refreshFailed()\n    _refreshController.refreshCompleted();\n  }\n\n  void _onLoading() async{\n    // monitor network fetch\n    await Future.delayed(Duration(milliseconds: 1000));\n    // if failed,use loadFailed(),if no data return,use LoadNodata()\n    items.add((items.length+1).toString());\n    if(mounted)\n    setState(() {\n\n    });\n    _refreshController.loadComplete();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: SmartRefresher(\n        enablePullDown: true,\n        enablePullUp: true,\n        header: WaterDropHeader(),\n        footer: CustomFooter(\n          builder: (BuildContext context,LoadStatus mode){\n            Widget body ;\n            if(mode==LoadStatus.idle){\n              body =  Text(\"pull up load\");\n            }\n            else if(mode==LoadStatus.loading){\n              body =  CupertinoActivityIndicator();\n            }\n            else if(mode == LoadStatus.failed){\n              body = Text(\"Load Failed!Click retry!\");\n            }\n            else if(mode == LoadStatus.canLoading){\n                body = Text(\"release to load more\");\n            }\n            else{\n              body = Text(\"No more Data\");\n            }\n            return Container(\n              height: 55.0,\n              child: Center(child:body),\n            );\n          },\n        ),\n        controller: _refreshController,\n        onRefresh: _onRefresh,\n        onLoading: _onLoading,\n        child: ListView.builder(\n          itemBuilder: (c, i) => Card(child: Center(child: Text(items[i]))),\n          itemExtent: 100.0,\n          itemCount: items.length,\n        ),\n      ),\n    );\n  }\n\n  // from 1.5.0, it is not necessary to add this line\n  //@override\n // void dispose() {\n    // TODO: implement dispose\n  //  _refreshController.dispose();\n  //  super.dispose();\n // }\n\n```\n\nThe global configuration RefreshConfiguration, which configures all Smart Refresher representations under the subtree, is generally stored at the root of MaterialApp and is similar in usage to ScrollConfiguration.\nIn addition, if one of your SmartRefresher behaves differently from the rest of the world, you can use RefreshConfiguration.copyAncestor() to copy attributes from your ancestor RefreshConfiguration and replace\nattributes that are not empty.\n\n```dart\n    // Smart Refresher under the global configuration subtree, here are a few particularly important attributes\n     RefreshConfiguration(\n         headerBuilder: () => WaterDropHeader(),        // Configure the default header indicator. If you have the same header indicator for each page, you need to set this\n         footerBuilder:  () => ClassicFooter(),        // Configure default bottom indicator\n         headerTriggerDistance: 80.0,        // header trigger refresh trigger distance\n         springDescription:SpringDescription(stiffness: 170, damping: 16, mass: 1.9),         // custom spring back animate,the props meaning see the flutter api\n         maxOverScrollExtent :100, //The maximum dragging range of the head. Set this property if a rush out of the view area occurs\n         maxUnderScrollExtent:0, // Maximum dragging range at the bottom\n         enableScrollWhenRefreshCompleted: true, //This property is incompatible with PageView and TabBarView. If you need TabBarView to slide left and right, you need to set it to true.\n         enableLoadingWhenFailed : true, //In the case of load failure, users can still trigger more loads by gesture pull-up.\n         hideFooterWhenNotFull: false, // Disable pull-up to load more functionality when Viewport is less than one screen\n         enableBallisticLoad: true, // trigger load more by BallisticScrollActivity\n        child: MaterialApp(\n            ........\n        )\n    );\n\n```\n\n1.5.6 add new feather: localization ,you can add following code in MaterialApp or CupertinoApp:\n\n```dart\n\n    MaterialApp(\n            localizationsDelegates: [\n              // this line is important\n              RefreshLocalizations.delegate,\n              GlobalWidgetsLocalizations.delegate,\n              GlobalMaterialLocalizations.delegate\n            ],\n            supportedLocales: [\n              const Locale('en'),\n              const Locale('zh'),\n            ],\n            localeResolutionCallback:\n                (Locale locale, Iterable<Locale> supportedLocales) {\n              //print(\"change language\");\n              return locale;\n            },\n    )\n\n```\n\n\n## ScreenShots\n\n\n\n### Examples\n|Style| [basic](example/lib/ui/example/useStage/basic.dart) | [header in other place](example/lib/ui/example/customindicator/link_header_example.dart) | [reverse + horizontal](example/lib/ui/example/useStage/horizontal+reverse.dart) |\n|:---:|:---:|:---:|:---:|\n|| ![](arts/example1.gif) | ![](arts/example2.gif) |![](arts/example3.gif) |\n\n|Style|  [twoLevel](example/lib/ui/example/useStage/twolevel_refresh.dart) |[use with other widgets](example/lib/ui/example/otherwidget) |  [chat](example/lib/ui/example/useStage/qq_chat_list.dart) |\n|:---:|:---:|:---:|:---:|\n||  ![](arts/example4.gif) |![](arts/example5.gif) | ![](arts/example6.gif) |\n\n\n|Style| [simple custom header(使用SpinKit)](example/lib/ui/example/customindicator/spinkit_header.dart)| [dragableScrollSheet+LoadMore](example/lib/ui/example/otherwidget/draggable_bottomsheet_loadmore.dart)|[Gif Indicator](example/lib/ui/example/customindicator/gif_indicator_example1.dart) |\n|:---:|:---:|:---:|:---:|\n|| ![](arts/example7.gif) | ![](arts/example8.gif) | ![](arts/gifindicator.gif) |\n\n\n\n### Indicator\n\n### 各种指示器\n\n| refresh style |   |pull up load style| |\n|:---:|:---:|:---:|:---:|\n| RefreshStyle.Follow <br>![Follow](example/images/refreshstyle1.gif)|RefreshStyle.UnFollow <br> ![不跟随](example/images/refreshstyle2.gif)| LoadStyle.ShowAlways <br>  ![永远显示](example/images/loadstyle1.gif) | LoadStyle.HideAlways<br> ![永远隐藏](example/images/loadstyle2.gif)|\n| RefreshStyle.Behind <br> ![背部](example/images/refreshstyle3.gif)| RefreshStyle.Front <br> ![前面悬浮](example/images/refreshstyle4.gif)| LoadStyle.ShowWhenLoading<br>  ![当加载中才显示,其它隐藏](example/images/loadstyle3.gif) | |\n\n|Style| [ClassicIndicator](https://github.com/peng8350/flutter_pulltorefresh/blob/master/lib/src/indicator/classic_indicator.dart) | [WaterDropHeader](https://github.com/peng8350/flutter_pulltorefresh/blob/master/lib/src/indicator/waterdrop_header.dart) | [MaterialClassicHeader](https://github.com/peng8350/flutter_pulltorefresh/blob/master/lib/src/indicator/material_indicator.dart) |\n|:---:|:---:|:---:|:---:|\n|| ![](example/images/classical_follow.gif) | ![](example/images/warterdrop.gif) | ![](example/images/material_classic.gif) |\n\n|Style|  [WaterDropMaterialHeader](https://github.com/peng8350/flutter_pulltorefresh/blob/master/lib/src/indicator/material_indicator.dart) | [Shimmer Indicator](example/lib/ui/example/customindicator/shimmer_indicator.dart) |[Bezier+Circle](https://github.com/peng8350/flutter_pulltorefresh/blob/master/lib/src/indicator/bezier_indicator.dart) |\n|:---:|:---:|:---:|:---:|\n||  ![](example/images/material_waterdrop.gif) |![](example/images/shimmerindicator.gif) | ![](example/images/bezier.gif) |\n\n\n<a name=\"child\"></a>\n\n## about SmartRefresher's child explain\n\nSince 1.4.3, the child attribute has changed from ScrollView to Widget, but this does not mean that all widgets are processed the same. SmartRefresher's internal implementation mechanism is not like  NestedScrollView<br><br>\nThere are two main types of processing mechanisms here, `the first category`is the component inherited from ScrollView. At present, there are only three types,\n `ListView`, `GridView`, `CustomScrollView`. ` The second category ` is components that are not inherited from ScrollView, which generally put empty views,\n  NoScrollable views (NoScrollable convert Scrollable), PageView, and you don't need to estimate height  by `LayoutBuilder` yourself.\n<br><br>\nFor the first type of mechanism, slivers are taken out of the system \"illegally\". The second is to put children directly into classes such as `SliverToBox Adapter'. By splicing headers and footers back and forth to form slivers, and then putting slivers inside Smart Refresher into CustomScrollView, you can understand Smart Refresher as CustomScrollView,\nbecause the inside is to return to CustomScrollView. So, there's a big difference between a child node and a ScrollView.\n<br><br>\nNow, guess you have a requirement: you need to add background, scrollbars or something outside ScrollView. Here's a demonstration of errors and correct practices\n\n```dart\n\n   //error\n   SmartRefresher(\n      child: ScrollBar(\n          child: ListView(\n             ....\n      )\n    )\n   )\n\n   // right\n   ScrollBar(\n      child: SmartRefresher(\n          child: ListView(\n             ....\n      )\n    )\n   )\n\n```\n\nDemonstrate another wrong doing,put ScrollView in another widget\n\n```dart\n\n   //error\n   SmartRefresher(\n      child:MainView()\n   )\n\n   class MainView extends StatelessWidget{\n       Widget build(){\n          return ListView(\n             ....\n          );\n       }\n\n   }\n\n```\n\nThe above mistake led to scrollable nesting another scrollable, causing you to not see the header and footer no matter how slippery you are.\nSimilarly, you may need to work with components like NotificationListener, ScrollConfiguration..., remember, don't store them outside ScrollView (you want to add refresh parts) and Smart Refresher memory.。\n\n\n## More\n- [Property Document](propertys_en.md) or [Api/Doc](https://pub.dev/documentation/pull_to_refresh/latest/pulltorefresh/SmartRefresher-class.html)\n- [Custom Indicator](custom_indicator_en.md)\n- [Inner Attribute Of Indicators](indicator_attribute_en.md)\n- [Update Log](CHANGELOG.md)\n- [Notice](notice_en.md)\n- [FAQ](problems_en.md)\n\n\n## Exist Problems\n* about NestedScrollView,When you slide down and then slide up quickly, it will return back. The main reason is that\n NestedScrollView does not consider the problem of cross-border elasticity under\n bouncingScrollPhysics. Relevant flutter issues: 34316, 33367, 29264. This problem\n can only wait for flutter to fix this.\n* SmartRefresher does not have refresh injection into ScrollView under the subtree, that is, if you put AnimatedList or RecordableListView in the child\n is impossible. I have tried many ways to solve this problem and failed. Because of the\n principle of implementation, I have to append it to the head and tail of slivers. In fact, the problem is not that much of my\nComponent issues, such as AnimatedList, can't be used with AnimatedList and GridView unless\n I convert AnimatedList to SliverAnimatedList is the solution. At the moment,\n I have a temporary solution to this problem, but it's a bit cumbersome to rewrite the code inside it and then outside ScrollView.\nAdd SmartRefresher, see my two examples [Example 1](example/lib/other/refresh_animatedlist.dart)和[Example 2](example/lib/other/refresh_recordable_listview.dart)\n\n## Thanks\n\n[SmartRefreshLayout](https://github.com/scwang90/SmartRefreshLayout)\n\n## LICENSE\n\n\n```\n\nMIT License\n\nCopyright (c) 2018 Jpeng\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n\n ```\n"
        },
        {
          "name": "README_CN.md",
          "type": "blob",
          "size": 13.0439453125,
          "content": "# flutter_pulltorefresh\n<a href=\"https://pub.dev/packages/pull_to_refresh\">\n  <img src=\"https://img.shields.io/pub/v/pull_to_refresh.svg\"/>\n</a>\n<a href=\"https://flutter.dev/\">\n  <img src=\"https://img.shields.io/badge/flutter-%3E%3D%202.0.0-green.svg\"/>\n</a>\n<a href=\"https://opensource.org/licenses/MIT\">\n  <img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\"/>\n</a>\n\n## 介绍\n一个提供上拉加载和下拉刷新的组件,同时支持Android和Ios<br>\n\n\n\n## 特性\n* 提供上拉加载和下拉刷新\n* 几乎适合所有部件\n* 提供全局设置默认指示器和属性\n* 提供多种比较常用的指示器\n* 支持Android和iOS默认滑动引擎,可限制越界距离,打造自定义弹性动画,速度,阻尼等。\n* 支持水平和垂直刷新,同时支持翻转列表(四个方向)\n* 提供多种刷新指示器风格:跟随,不跟随,位于背部,位于前部, 提供多种加载更多风格\n* 提供二楼刷新,可实现类似淘宝二楼,微信二楼,携程二楼\n* 允许关联指示器存放在Viewport外部,即朋友圈刷新效果\n\n## 用法\n\n添加这一行到pubspec.yaml\n\n```yaml\n\n   dependencies:\n\n    pull_to_refresh: ^2.0.0\n\n\n```\n\n导包\n\n```dart\n\n    import 'package:pull_to_refresh/pull_to_refresh.dart';\n\n```\n\n简单例子如下,***这里一定要注意的是,ListView一定要作为SmartRefresher的child,不能与其分开,详细原因看 <a href=\"child\">下面</a>***\n\n```dart\n\n  List<String> items = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"];\n  RefreshController _refreshController =\n      RefreshController(initialRefresh: false);\n\n  void _onRefresh() async{\n    // monitor network fetch\n    await Future.delayed(Duration(milliseconds: 1000));\n    // if failed,use refreshFailed()\n    _refreshController.refreshCompleted();\n  }\n\n  void _onLoading() async{\n    // monitor network fetch\n    await Future.delayed(Duration(milliseconds: 1000));\n    // if failed,use loadFailed(),if no data return,use LoadNodata()\n    items.add((items.length+1).toString());\n    if(mounted)\n    setState(() {\n\n    });\n    _refreshController.loadComplete();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: SmartRefresher(\n        enablePullDown: true,\n        enablePullUp: true,\n        header: WaterDropHeader(),\n        footer: CustomFooter(\n          builder: (BuildContext context,LoadStatus mode){\n            Widget body ;\n            if(mode==LoadStatus.idle){\n              body =  Text(\"上拉加载\");\n            }\n            else if(mode==LoadStatus.loading){\n              body =  CupertinoActivityIndicator();\n            }\n            else if(mode == LoadStatus.failed){\n              body = Text(\"加载失败！点击重试！\");\n            }\n            else if(mode == LoadStatus.canLoading){\n               body = Text(\"松手,加载更多!\");\n            }\n            else{\n              body = Text(\"没有更多数据了!\");\n            }\n            return Container(\n              height: 55.0,\n              child: Center(child:body),\n            );\n          },\n        ),\n        controller: _refreshController,\n        onRefresh: _onRefresh,\n        onLoading: _onLoading,\n        child: ListView.builder(\n          itemBuilder: (c, i) => Card(child: Center(child: Text(items[i]))),\n          itemExtent: 100.0,\n          itemCount: items.length,\n        ),\n      ),\n    );\n  }\n\n  // 1.5.0后,应该没有必要加这一行了\n // @override\n // void dispose() {\n    // TODO: implement dispose\n //   _refreshController.dispose();\n//    super.dispose();\n//  }\n\n```\n\n全局配置RefreshConfiguration,配置子树下的所有SmartRefresher表现,一般存放于MaterialApp的根部,用法和ScrollConfiguration是类似的。\n另外,假如你某一个SmartRefresher表现和全局不一样的情况,你可以使用RefreshConfiguration.copyAncestor从祖先RefreshConfiguration复制属性过来并替换不为空的属性。\n\n```dart\n    // 全局配置子树下的SmartRefresher,下面列举几个特别重要的属性\n     RefreshConfiguration(\n         headerBuilder: () => WaterDropHeader(),        // 配置默认头部指示器,假如你每个页面的头部指示器都一样的话,你需要设置这个\n         footerBuilder:  () => ClassicFooter(),        // 配置默认底部指示器\n         headerTriggerDistance: 80.0,        // 头部触发刷新的越界距离\n         springDescription:SpringDescription(stiffness: 170, damping: 16, mass: 1.9),         // 自定义回弹动画,三个属性值意义请查询flutter api\n         maxOverScrollExtent :100, //头部最大可以拖动的范围,如果发生冲出视图范围区域,请设置这个属性\n         maxUnderScrollExtent:0, // 底部最大可以拖动的范围\n         enableScrollWhenRefreshCompleted: true, //这个属性不兼容PageView和TabBarView,如果你特别需要TabBarView左右滑动,你需要把它设置为true\n         enableLoadingWhenFailed : true, //在加载失败的状态下,用户仍然可以通过手势上拉来触发加载更多\n         hideFooterWhenNotFull: false, // Viewport不满一屏时,禁用上拉加载更多功能\n         enableBallisticLoad: true, // 可以通过惯性滑动触发加载更多\n        child: MaterialApp(\n            ........\n        )\n    );\n\n```\n\n1.5.6新增国际化处理特性,你可以在MaterialApp或者CupertinoApp追加如下代码:\n\n```dart\n\n    MaterialApp(\n            localizationsDelegates: [\n              // 这行是关键\n              RefreshLocalizations.delegate,\n              GlobalWidgetsLocalizations.delegate,\n              GlobalMaterialLocalizations.delegate\n            ],\n            supportedLocales: [\n              const Locale('en'),\n              const Locale('zh'),\n            ],\n            localeResolutionCallback:\n                (Locale locale, Iterable<Locale> supportedLocales) {\n              //print(\"change language\");\n              return locale;\n            },\n    )\n\n```\n\n\n\n## 截图\n### 例子\n|Style| [基础用法](example/lib/ui/example/useStage/basic.dart) | [header放在其他位置](example/lib/ui/example/customindicator/link_header_example.dart) | [水平+翻转刷新](example/lib/ui/example/useStage/horizontal+reverse.dart) |\n|:---:|:---:|:---:|:---:|\n|| ![](arts/example1.gif) | ![](arts/example2.gif) |![](arts/example3.gif) |\n\n|Style|  [二楼刷新](example/lib/ui/example/useStage/twolevel_refresh.dart) |[兼容其他特殊组件](example/lib/ui/example/otherwidget) |  [聊天列表](example/lib/ui/example/useStage/qq_chat_list.dart) |\n|:---:|:---:|:---:|:---:|\n||  ![](arts/example4.gif) |![](arts/example5.gif) | ![](arts/example6.gif) |\n\n\n|Style| [简单自定义刷新指示器(使用SpinKit)](example/lib/ui/example/customindicator/spinkit_header.dart)| [dragableScrollSheet+LoadMore](example/lib/ui/example/otherwidget/draggable_bottomsheet_loadmore.dart)|[Gif Indicator](example/lib/ui/example/customindicator/gif_indicator_example1.dart) |\n|:---:|:---:|:---:|:---:|\n|| ![](arts/example7.gif) | ![](arts/example8.gif) | ![](arts/gifindicator.gif) |\n\n### 各种指示器\n\n| 下拉刷新风格 |   |上拉加载风格| |\n|:---:|:---:|:---:|:---:|\n| RefreshStyle.Follow <br> ![跟随](example/images/refreshstyle1.gif) |RefreshStyle.UnFollow <br>  ![不跟随](example/images/refreshstyle2.gif)| LoadStyle.ShowAlways <br> ![永远显示](example/images/loadstyle1.gif) | LoadStyle.HideAlways<br>  ![永远隐藏](example/images/loadstyle2.gif)|\n| RefreshStyle.Behind <br> ![背部](example/images/refreshstyle3.gif)| RefreshStyle.Front <br> ![前面悬浮](example/images/refreshstyle4.gif)| LoadStyle.ShowWhenLoading<br> ![当加载中才显示,其它隐藏](example/images/loadstyle3.gif) | |\n\n|Style| [ClassicIndicator](https://github.com/peng8350/flutter_pulltorefresh/blob/master/lib/src/indicator/classic_indicator.dart) | [WaterDropHeader](https://github.com/peng8350/flutter_pulltorefresh/blob/master/lib/src/indicator/waterdrop_header.dart) | [MaterialClassicHeader](https://github.com/peng8350/flutter_pulltorefresh/blob/master/lib/src/indicator/material_indicator.dart) |\n|:---:|:---:|:---:|:---:|\n|| ![](example/images/classical_follow.gif) | ![](example/images/warterdrop.gif) | ![](example/images/material_classic.gif) |\n\n|Style|  [WaterDropMaterialHeader](https://github.com/peng8350/flutter_pulltorefresh/blob/master/lib/src/indicator/material_indicator.dart) | [Bezier+circle](example/lib/ui/example/customindicator/shimmer_indicator.dart) |[Bezier+Circle](https://github.com/peng8350/flutter_pulltorefresh/blob/master/lib/src/indicator/bezier_indicator.dart) |\n|:---:|:---:|:---:|:---:|\n||  ![](example/images/material_waterdrop.gif) |![](example/images/shimmerindicator.gif) | ![](example/images/bezier.gif) |\n\n<a name=\"child\"></a>\n\n## 对SmartRefresher里child详细说明\n\n自1.4.3,child属性从ScrollView转变为Widget,但是这并不意味着对于所有Widget处理是一样的。SmartRefresher内部实现机制并非是类如NestedScrollView<br><br>\n这里的处理机制分了两个大类,`第一类`是继承于ScrollView的那一类组件,目前来说,就只有这三种,`ListView`,`GridView`,`CustomScrollView`。`第二类`,是非继承于ScrollView的那类组件,一般是存放空视图,非滚动视图(非滚动转化为滚动),PageView,无需你自己通过`LayoutBuilder`估计高度。<br><br>\n对于第一类的处理机制是从内部\"非法\"取出slivers。第二类,则是把child直接放进类如`SliverToBoxAdapter`。通过前后拼接header和footer组成slivers,然后SmartRefresher内部把slivers放进`CustomScrollView`,你可以把SmartRefresher理解成`CustomScrollView`,因为内部就是返回CustomScrollView。所以,这里child结点是不是ScrollView区别是很大的。\n<br><br>\n现在,猜想你有一个需求:需要在ScrollView外部增加背景,滚动条什么的。下面演示错误和正确的做法\n\n```dart\n\n   // 错误的做法\n   SmartRefresher(\n      child: ScrollBar(\n          child: ListView(\n             ....\n      )\n    )\n   )\n\n   // 正确的做法\n   ScrollBar(\n      child: SmartRefresher(\n          child: ListView(\n             ....\n      )\n    )\n   )\n\n```\n\n再演示多一种错误做法,把ScrollView存放到另外一个widget\n\n```dart\n\n   //error\n   SmartRefresher(\n      child:MainView()\n   )\n\n   class MainView extends StatelessWidget{\n       Widget build(){\n          return ListView(\n             ....\n          );\n       }\n\n   }\n\n```\n\n上面的错误做法就导致了scrollable再嵌套一个scrollable了,导致你无论怎么滑也看不到header和footer。\n同理的,你可能需要配合NotificationListener,ScrollConfiguration...这类组件,记住,千万别在ScrollView(你想增加刷新部分)外和SmartRefresher内存放。\n\n\n\n\n\n## 更多\n- [属性文档](propertys.md) 或者 [Api/Doc](https://pub.dev/documentation/pull_to_refresh/latest/pulltorefresh/SmartRefresher-class.html)\n- [自定义指示器](custom_indicator.md)\n- [指示器内部属性介绍](indicator_attribute.md)\n- [更新日志](CHANGELOG.md)\n- [注意地方](notice.md)\n- [常见问题](problems.md)\n\n## 暂时存在的问题\n* 关于配合NestedScrollView一起使用,会出现很多奇怪的现象,当你下滑然后快速上滑,\n它会出现跳动,主要是NestedScrollView没有考虑到在BouncingScrollPhysics下的越界问题,相关flutter issue:\n34316,33367,29264,这个问题只能等待flutter修复。\n* SmartRefresher不具有向子树下的ScrollView注入刷新功能,也就是如果直接把AnimatedList,RecordableListView放在child结点是不行的,这个问题我尝试过很多个方法都失败了,由于实现原理,我必须得在slivers头部和尾部追加,事实上,这个问题也不大是我组件的问题,比如说AnimatedList,假如我要结合AnimatedList和GridView一起使用是没办法的,唯有把AnimatedList转换为SliverAnimatedList才能解决。目前呢,面对这种问题的话,我已经有临时的解决方案,但有点麻烦,要重写它内部的代码,然后在ScrollView外部\n增加SmartRefresher,详见我这两个例子[例子1](example/lib/other/refresh_animatedlist.dart)和[例子2](example/lib/other/refresh_recordable_listview.dart)\n\n\n## 感谢\n\n[SmartRefreshLayout](https://github.com/scwang90/SmartRefreshLayout)\n\n\n## 开源协议\n\n```\n\nMIT License\n\nCopyright (c) 2018 Jpeng\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n\n ```"
        },
        {
          "name": "arts",
          "type": "tree",
          "content": null
        },
        {
          "name": "custom_indicator.md",
          "type": "blob",
          "size": 8.6474609375,
          "content": "# 关于自定义指示器\n有时,我们可能嫌弃提供指示器不太好看,或者不符合自己要求,需要自己去定义一个属于自己App的指示器。\n现提供两种自定义指示器的方法。\n\n## 第一种\n假设你要实现的指示器功能不是太过于复杂,可以使用CustomHeader或者CustomFooter,利用SmartRefresher里的onOffsetChange回调可完成一些简单的动画。(1.5.2新增参数回调,你也可以直接用这个实现复杂的动画效果)\n\n```dart\n   Widget buildHeader(BuildContext context,RefreshStatus mode){\n      return Center(\n          child:Text(mode==RefreshStatus.idle?\"下拉刷新\":mode==RefreshStatus.refreshing?\"刷新中...\":\n          mode==RefreshStatus.canRefresh?\"可以松手了!\":mode==RefreshStatus.completed?\"刷新成功!\":\"刷新失败\");\n      )\n   }\n\n   SmartRefresher(\n      ...\n      header: CustomHeader(\n         builder:buildHeader\n         onOffsetChange:(offset){\n                 //do some ani\n         }\n      )\n\n      ...\n   )\n\n```\n\n## 第二种\n\n这种方式可能相对上面难说实现起来是相对来说比较复杂的,但通过这种方式可以更好的实现一些比较绚丽的动画。\n首先,头部指示器(下拉刷新)有四种风格:Follow,UnFollow,Behind,Front,底部指示器(加载更多)只有一种风格:Follow\n先来了解一下这四种风格到底有什么区别?\n\n* Follow: 高度不会变化,而位置会随着列表的移动而移动\n* UnFollow: 高度不会变化,位置不变，但不是跟着列表变化,当它完全可以被看见时，不会再跟随列表。\n* Behind:高度会随着越界拖动距离变化,不会移动。\n* Front: 和前面三种机制不一样,高度不会变动,位置也不会变动。一直卡在列表顶端。\n\n\n首先,头部指示器继承RefreshIndicator,底部指示器继承LoadIndicator,同时内部已经封装好State(RefreshIndicatorState,LoadIndicatorState)。\n这里,你不需要去关心一些问题就是:通过什么去监听指示器offset的变化?如何去让指示器进入某个状态?怎么根据offset来决定是否进入刷新状态?\n怎么颁布刷新状态变化逻辑? 上述这些问题你不需要去关心,因为我内部已经处理好这些问题。你只需要关心以下东西:\n不同的状态要返回什么布局,根据offset变化来设置一些动画的进度,进入刷新状态前执行什么操作等等。\n\n下面直接以实现一个简单的指示器为例子,这样才能更好的明白怎么设计一个指示器。\n现在,猜想我们要实现一个这样的指示器,如下图:\n![](arts/custom_header.gif)\n\n拖动时,随着offset的变化而变化图片大小,然后刷新完毕后,调用一个平移动画形成跑过去的效果。\n那么,问题来了,我们应该要怎么去实现这样的功能呢?\n首先,我准备了一张jpg和一个gif,jpg表示gif第一帧,当然如果你想控制gif,也是有办法的,一个gif够了\n定义一个类继承RefreshIndicator(注意material包重名)\n\n```dart\n\nclass RunningHeader extends RefreshIndicator {\n  RunningHeader({@required OnRefresh onRefresh})\n      : super(\n            refreshStyle: RefreshStyle.Follow,\n            height: 80.0,\n            onRefresh: onRefresh);\n\n  @override\n  State<StatefulWidget> createState() {\n    // TODO: implement createState\n    return RunningHeaderState();\n  }\n}\n\n```\n如上,RefreshIndicator具体有什么属性,可以看[这里](indicator_attribute.md),利用super(refreshStyle:)可以指定指示器的风格,因为这里我觉得\nFollow更适合一点,所以就选Follow了。\n\n接下来RunningHeaderState是重点部分,它继承于RefreshIndicatorState而不是State。内部有一个必须得重写的方法buildContent,用来指定指示器要显示什么,这个我相信绝大数人都能明白,就不细说了。\n第一步,如何实现拖动手势过程中人缩小放大?缩小放大肯定是要用ScaleTransition,那么问题又来了,那我怎么去知道当前offset是多少呢?\n内部有一个onOffsetChange的回调方法,这个方法触发的时机是任何时候都会触发的,如果你不想在刷新过程中或者布局浮动的状态下触发,你可以利用floating这个属性,这个\n属性表示指示器是否占有一个高度的状态,假如占有一个高度,它就能被看到,假如没有,就滚回去隐藏掉了。\n\n```dart\n\nclass RunningHeaderState extends RefreshIndicatorState<RunningHeader>\n    with TickerProviderStateMixin {\n\n    AnimationController _scaleAnimation;\n\n    void onOffsetChange(){\n         if (!floating) {\n              _scaleAnimation.value = offset / 80.0;\n            }\n         //call super,will call setState\n         super.onOffsetChange(offset);\n    }\n    Widget buildContent(BuildContext context, RefreshStatus mode){\n        return ScaleTransition(\n                child: (mode != RefreshStatus.idle || mode != RefreshStatus.canRefresh)\n                    ? Image.asset(\"images/custom_2.gif\")\n                    : Image.asset(\"images/custom_1.jpg\"),\n                scale: _scaleAnimation,\n        );\n    }\n\n}\n\n\n```\n\n第二步,那个刷新完成之后人跑过去的效果怎么弄?这点需要endRefresh这个方法,这个方法要返回一个Future。注意,这个方法调用,此时的状态是RefreshStatus.completed或者failed\n,然后当这个方法执行完毕,此时,floating =false,header就会开始隐藏掉。\n\n```dart\n\n    @override\n    Future<void> endRefresh() {\n      // TODO: implement endRefresh\n      return _offsetController.animateTo(1.0).whenComplete(() {});\n    }\n\n\n  Widget buildContent(BuildContext context, RefreshStatus mode) {\n    // TODO: implement buildContent\n    return SlideTransition(\n      child: ScaleTransition(\n        child: (mode != RefreshStatus.idle || mode != RefreshStatus.canRefresh)\n            ? Image.asset(\"images/custom_2.gif\")\n            : Image.asset(\"images/custom_1.jpg\"),\n        scale: _scaleAnimation,\n      ),\n      position: offsetTween.animate(_offsetController),\n    );\n  }\n\n```\n\n实现到这里,这个指示器基本就差不多完成了。但是,还有一步,就是你那些动画总得要还原到原来的位置吧,总不能还在那个位置停留。下次用户下拉刷新的时候就可能还是那个状态值。\n那这里,应该怎么做？内部没有特定方法,但是可以利用RefreshStatus的状态还原为idle后,接着再还原controller里的值,里面有暴露一个resetValue的方法\n\n```dart\n\n  @override\n  void resetValue() {\n    // TODO: implement handleModeChange\n      _scaleAnimation.value = 0.0;\n      _offsetController.value = 0.0;\n  }\n\n```\n\n这个header就不放到packages中了,因为大多人用不上,只是作为一个例子。[代码](example/lib/other/RunningHeader.dart)\n\nRefreshIndicatorState里一些非常重要的可重写方法和属性\n\n```dart\n   /*\n  \t\t 代表指示器有没有布局的高度,假如占有高度,指示器将会展示在顶部,假如没有,指示器将会滚动回去隐藏掉。\n    */\n   bool floating;\n   //指示器的状态\n   RefreshStatus mode;\n\n\n   /*\n     这个方法里的参数返回一个值,代表指示器可见的距离或者ScrollView顶部越界的距离。\n     你可以利用这个方法来实现一些漂亮的拖动动画。比如WaterDropHeader里水滴拖动的效果,\n     就是要依赖到这个函数。最后,调用父类的onOffsetChange可以更新界面。\n   */\n   void onOffsetChange(double offset) ;\n\n    // 当指示器状态发生改变时,会回调\n   void onModeChange(RefreshStatus mode);\n\n   /*\n     这个方法表示即将进入刷新状态时需要执行的操作,返回一个Future。这个方法调用完毕才能进入刷新状态。\n    */\n  Future<void> readyToRefresh();\n\n  /**\n     结束刷新状态时的操作。这个方法是在状态改变为成功或者失败后触发的。\n     这个方法执行完毕后,指示器会变为无布局(floating = false)状态\n  */\n  Future<void> endRefresh();\n\n  // 根据不同的状态,返回不同的内容\n  Widget buildContent(BuildContext context,RefreshStatus mode);\n\n\n```\n\n\nLoadIndicatorState就不展开介绍了,和上面同理,只不过上面的比较多。\n\n## 第三种(1.5.2支持,推荐使用这种方法!)\n1.5.2把footer,header转换为Widget限制类型,这样的好处是为了更容易组合指示器来使用,更符合flutter的设计规则,而不是返回一个函数\n我们可以把CustomHeader封装在一个StatelessWidget和StatefulWidget里。当我们需要组合其他组件时,可以向上回调函数来使用,参考BeizerHeader。\n你也可以组合ClassicHeader来使用,TwoLevelHeader也是基于ClassicHeader来组合使用。CustomHeader里面的参数和上面方法意思一样。\n\n```dart\n\n    class XXXXHeader extends StatelessWidget{\n\n       Widget build(){\n\n           return CustomHeader(\n                ....\n           );\n       }\n\n    }\n\n\n```\n"
        },
        {
          "name": "custom_indicator_en.md",
          "type": "blob",
          "size": 8.7939453125,
          "content": "# About Custom Indicator\n\n## First\nAssuming that the indicator function you want to implement is not too complex, you can use CustomHeader or CustomFooter, and use the onOffset Change\n callback in Smart Refresher to complete some simple animations.((1.5.2 add new callback in CustomHeader and customFooter,you can use this to implements complex animation))\n\n```dart\n   Widget buildHeader(BuildContext context,RefreshStatus mode){\n      .....\n   }\n\n   SmartRefresher(\n      ...\n      header: CustomHeader(builder:buildHeader,\n             onOffsetChange:(offset){\n                  //do some ani\n             }\n     ),\n\n      ...\n   )\n\n```\n\n## Second\n\n\nThis method may be relatively difficult to say above to achieve is relatively complex, but through this way can better achieve some of the more gorgeous animation.\nFirst, the head indicator (drop-down refresh) has four styles: Follow, UnFollow, Behind, Front, and the bottom indicator (load more) has only one style: Follow\nLet's first understand the difference between these four styles.\n\n* Follow: Height will not change, but position moves as the list moves.\n* UnFollow: Height does not change, location does not change, but does not follow the list, when it is fully visible, will not follow the list.\n* Behind:Height will vary with the distance across the boundary and will not move.\n* Front: Unlike the previous three mechanisms, height and position will not change. It's stuck at the top of the list.\n\n\nFirst,header Indicator need to extend RefreshIndicator,footer Indicator need to extend LoadIndicator,At the same time, the State has been encapsulated internally((RefreshIndicatorState,LoadIndicatorState)。)\nHere, you don't need to worry about the following questions: how to monitor the offset changes of the indicator, how to get the indicator into a certain state, and how to decide whether to enter a refresh state based on offset?\nHow to promulgate the refresh state change logic? You don't need to care about these problems, because I have dealt with them internally. You only need to care about the following things:\nWhat layout to return to in different states, how to set the progress of some animations according to offset changes, what operations to perform before entering refresh state, and so on.\nLet's take a simple indicator as an example, so that we can better understand how to design an indicator.\nNow, suppose we want to implement an indicator like this, as follows:\n\n![](arts/custom_header.gif)\n\nWhen dragging, change the size of the picture as offset changes, and then after refreshing, call a moving picture to form the effect of running past.\nSo, the question arises, how should we achieve such a function?\nFirst of all, I prepared a JPG and a gif. JPG represents the first frame of gif. Of course, if you want to control gif, there is a way. A GIF is enough.\nDefine a class to inherit RefreshIndicator (note the material package rename)\n\n```dart\n\nclass RunningHeader extends RefreshIndicator {\n  RunningHeader({@required OnRefresh onRefresh})\n      : super(\n            refreshStyle: RefreshStyle.Follow,\n            height: 80.0,\n            onRefresh: onRefresh);\n\n  @override\n  State<StatefulWidget> createState() {\n    // TODO: implement createState\n    return RunningHeaderState();\n  }\n}\n\n```\nAs mentioned above, RefreshIndicator has specific attributes, you can see [here](indicator_attribute.md), and you can specify the style of the indicator by using super (refreshStyle:), because here I think\nFollow is more suitable, so I chose Follow.\n\nNext, Running Header State is the key part, which inherits from Refresh Indicator State rather than State. There is a built Content method that must be rewritten inside to specify what the indicator will display, which I believe most people can understand, let alone go into details.\nThe first step is how to zoom in and out in the process of dragging gestures. Scale Transition must be used to zoom in and out. Then the problem arises again. How can I know the current offset?\nThere's an onOffsetChange callback method inside, which triggers at any time. If you don't want to trigger during refresh or when the layout is floating, you can use the floating property, which is\nAttributes indicate whether the indicator occupies a high state. If it occupies a high state, it can be seen. If it does not, it rolls back and hides.\n\n```dart\n\nclass RunningHeaderState extends RefreshIndicatorState<RunningHeader>\n    with TickerProviderStateMixin {\n\n    AnimationController _scaleAnimation;\n\n    void onOffsetChange(){\n         if (!floating) {\n              _scaleAnimation.value = offset / 80.0;\n            }\n         //call super,will call setState\n         super.onOffsetChange(offset);\n    }\n    Widget buildContent(BuildContext context, RefreshStatus mode){\n        return ScaleTransition(\n                child: (mode != RefreshStatus.idle || mode != RefreshStatus.canRefresh)\n                    ? Image.asset(\"images/custom_2.gif\")\n                    : Image.asset(\"images/custom_1.jpg\"),\n                scale: _scaleAnimation,\n        );\n    }\n\n}\n\n\n```\n\nThe second step is what happens when the refresh is complete. This requires the endRefresh method, which returns to a Future. Note that this method call is in RefreshStatus. completed or failed state\nThen when this method is finished, floating = false, the header starts to hide.\n\n```dart\n\n    @override\n    Future<void> endRefresh() {\n      // TODO: implement endRefresh\n      return _offsetController.animateTo(1.0).whenComplete(() {});\n    }\n\n\n  Widget buildContent(BuildContext context, RefreshStatus mode) {\n    // TODO: implement buildContent\n    return SlideTransition(\n      child: ScaleTransition(\n        child: (mode != RefreshStatus.idle || mode != RefreshStatus.canRefresh)\n            ? Image.asset(\"images/custom_2.gif\")\n            : Image.asset(\"images/custom_1.jpg\"),\n        scale: _scaleAnimation,\n      ),\n      position: offsetTween.animate(_offsetController),\n    );\n  }\n\n```\n\nSo far, the indicator is almost complete. But one more step is that your animations have to be restored to their original position, and you can't stay there. The next time the user drops down and refreshes, it may still be that state value.\nSo what should we do here? There is no specific method inside, but you can restore the status of RefreshStatus to idle, and then restore the value in the controller, which exposes a resetValue method.\n\n```dart\n\n  @override\n  void resetValue() {\n    // TODO: implement handleModeChange\n      _scaleAnimation.value = 0.0;\n      _offsetController.value = 0.0;\n  }\n\n```\n\nThis header is not included in packages, because most people don't use it, just as an example.。[Code](example/lib/other/RunningHeader.dart)\n\n\n the most important api in RefreshIndicatorState\n\n```dart\n   /*\n  \tRepresents whether the indicator has a layout height. If it occupies a height, the indicator will be displayed at the top.\n  \tIf not, the indicator will scroll back and hide.\n    */\n   bool floating;\n   // the state of RefreshIndicator\n   RefreshStatus mode;\n\n\n   /*\n       The parameter in this method returns a value representing the distance visible to the indicator or the distance across the top of the ScrollView.\n       You can use this method to achieve some beautiful drag animation. For example, the effect of droplet dragging in WaterDropHeader.\n       It depends on this function. Finally, the onOffsetChange of the parent class is called to update the interface.\n   */\n   void onOffsetChange(double offset) ;\n\n   // When the indicator status changes, it calls back\n   void onModeChange(RefreshStatus mode);\n\n   /*\n     This method represents the operation to be performed when the refresh state is about to enter, and returns a Future. This method cannot be refreshed until it has been called.\n\n    */\n  Future<void> readyToRefresh();\n\n  /**\n     End the operation when refreshing the status. This method is triggered when the state changes to success or failure.\n     When this method is executed, the indicator becomes floating = false\n  */\n  Future<void> endRefresh();\n\n  // Return different content depending on the RefreshStatus\n  Widget buildContent(BuildContext context,RefreshStatus mode);\n\n\n```\n\n\nLoadIndicatorState does not expand on the introduction, which is similar to the above.\n\n\n## Third(support after 1.5.2,recommended!)\n\n1.5.2 converts footer and header to Widget restriction type, which has the advantage of making it easier to combine indicators. This design is more in line with flutter's design rules than returning a function\nWe can encapsulate CustomHeader in a StatelessWidget and StatefulWidget. When we need to combine other components, we can use the callback function up, refer to BeizerHeader.\nYou can also combine Classic Header and TwoLevel Header based on Classic Header.\n\n```dart\n\n    class XXXXHeader extends StatelessWidget{\n\n       Widget build(){\n\n           return CustomHeader(\n                ....\n           );\n       }\n\n    }\n\n\n```\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "indicator_attribute.md",
          "type": "blob",
          "size": 1.7978515625,
          "content": "# 指示器属性说明\n\n## 头部常见属性(不代表每个指示器都有,但是大多数都有这些属性)\n* double  height: 1.4.7更新说明,这个指的是刷新状态时指示器的可视范围\n* refreshStyle: 用于限定头部刷新指示器的风格,四种:Front,Behind,Follow(默认),UnFollow\n* completeDuration: 完成或者失败状态停留的时间\n\n\n## 底部通用属性\n* double  height: 1.4.7更新说明,这个指的是刷新状态时指示器的可视范围\n* () => {} onClick：点击指示器的回调方法,用于手动进行加载数据或者reset没有数据的状态\n* loadStyle: 用于限定尾部刷新指示器的风格,三种:HideAlways,ShowAlways(默认),ShowWhenLoading\n\n## ClassicHeader,ClassicFooter\n* outerBuilder: 用于给child基础上,再封装,比如追加背景,增加padding等等。\n* String idleText:指示器空闲时显示的文字\n* Widget idleIcon:指示器空闲时显示的图标\n* String  refreshingText:指示器刷新时显示的文字\n* Widget  refreshingIcon:指示器刷新时显示的图标\n* .....以此类推\n* double spacing: 图标和文字的间距\n* TextStyle textStyle: 设置文字的风格\n* IconPosition iconPos:图标的位置,是位于文字左边,右边，上方，底部\n\n\n## WaterDropHeader\n* Color waterDropColor:水滴颜色\n* Widget idleIcon:指的是用户拖动过程中水滴中间的部件\n* Widget refresh: 刷新过程中显示内容\n* Widget complete:刷新完成显示内容\n* Widget failed:刷新失败显示的内容\n\n## MaterialClassicHeader,WaterDropMaterialHeader\n这个内部实现是拿flutter RefreshIndicator内部的东西来实现的，所以它里面很多属性意思是和它一样的，所以我就不列举出来\n* double distance:当准备触发刷新时,指示器要放在距离顶部多少个距离,注意这个距离不能超过100.0\n"
        },
        {
          "name": "indicator_attribute_en.md",
          "type": "blob",
          "size": 1.880859375,
          "content": "# Indicator properties\n\n## Common header attributes (not every indicator, but most have these attributes)\n* double  height: 1.4.7 updated,it mean the visual height of indicator\n* refreshStyle: Styles used to define header refresh indicators,There is four style:Front,Behind,Follow(default),UnFollow\n* completeDuration: stop time when state in success or fail\n\n## common Footer attributes\n* double  height: 1.4.7 updated,it mean the visual height of indicator\n* () => {} onClick：click footer indicator callback\n* loadStyle:Styles used to define footer load indicators,There is four style:ShowWhenLoading,ShowAlways(default),hideAlways\n\n\n## ClassicHeader,ClassicFooter(Not Support Behind)\n* outerBuilder: use to give child extra feature,such as background,padding\n* String idleText:Text displayed when the indicator is idle\n* Widget idleIcon:Icon displayed when the indicator is idle\n* String  refreshingText:Text displayed when the indicator is refreshing\n* Widget  refreshingIcon:Icon displayed when the indicator is refreshing\n* .....the same above\n* double spacing: Spacing between icons and text\n* TextStyle textStyle: textStyle\n* IconPosition iconPos:IconPosition(Left,Top,Right,Bottom)\n* RefreshStyle refreshStyle,height,triggerDistance,autoLoad: the same Above\n\n\n## WaterDropHeader\n* Color waterDropColor:WaterDrop Color\n* Widget idleIcon:It refers to the middle part of the water droplet in the process of user dragging.\n* Widget refresh: Content displayed during refresh\n* Widget complete:Content displayed during complete\n* Widget failed:Content displayed during fail\n\n## MaterialClassicHeader,WaterDropMaterialHeader\nThis internal implementation is implemented with something inside the flutter RefreshIndicator.many of its attributes mean the same thing, so I won't list them.\n* double distance:When preparing to trigger refresh, the indicator should be placed at a distance of not more than 100.0 from the top.\n\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "notice.md",
          "type": "blob",
          "size": 1.974609375,
          "content": "# 注意地方\n\n## RefreshController\n* RefreshController不支持多次new,请保持和SmartRefresher同样的生命周期。\n* RefreshController只能对应一个SmartRefresher,不要尝试给把RefreshController赋予多个SmartRefresher,很常见应用场景就是TabBarView和PageView\n\n## SmartRefresher\n* 当你想要关闭掉下拉和上拉的功能,可利用enablePullUp和enablePullDown这两个属性\n* 不要把你想要追加指示器的ScrollView组件放到一个组件的子树下,由于实现机制,不是利用NotificationListener这类组件来实现的\n* 当child不是继承ScrollView时,要注意盒子约束,在SmartRefresher下高度是unbounded\n* 不支持SingleChildScrollView,直接在SmartRefresher child存放即可,SmartRefresher里child为非ScrollView时,当作SingleChildScrollView来使用。\n* 当想在ScrollView增加背景时,记住别在child节点给ListView或者GridView包装Container,请在SmartRefresher外部包装Container\n\n## Behind刷新样式\n* 这种样式的实现事实上就是采用高度的动态变化来实现的,试试外围多利用Align属性,会有不同的滑动效果。\n\n## 底部指示器\n* 对于不满足一页隐藏的问题,虽然内部采取通过precedingScrollExtent来判断前面有多少个距离,但是这种方法也是不可取的,有一种情况就是某一个sliver只占用scrollExtent而不占用\n  layoutExtent的情况。所以假如你内部slivers有这种sliver,我内部判断是不合法的,需要你手动去判断。设置hideWhenNotFull为false,然后用布尔值决定。\n\n## NestedScrollView(非必要情况避免使用)\n* 如何去获取内部的scrollController?通过refreshController.scrollController获取\n\n## CustomScrollView\n* 对于UnFollow刷新风格,当你slivers第一个元素带有SliverAppbar,Sliverheader时,会出现很奇怪的现象,不知道怎么描述,就是SliverAppBar位置会随着指示器位置的变化而变化。对于这种情况,你可以尝试在slivers第一个元素追加SliverToBoxAdapter。"
        },
        {
          "name": "notice_en.md",
          "type": "blob",
          "size": 2.4267578125,
          "content": "# Notice\n\n## RefreshController\n* RefreshController not support new multiple times,please keep the same lifecircle with SmartRefresher\n* RefreshController can only correspond to one Smart Refresher. Don't try to assign RefreshController to multiple Smart Refreshers. The most common application scenarios are TabBarView and PageView.\n\n## SmartRefresher\n* Don't put the ScrollView component you want to add an indicator under a component's subtree. Because of the implementation mechanism, it's not implemented with components like NotificationListener.\n* When you want to turn off drop-down and pull-up functions, you can use enablePullUp and enablePullDown attributes\n* When child does not inherit ScrollView, note that box constraints are unbounded in height under Smart Refresher\n* not support SingleChildView,put it into SmartRefresher's child instead.\n* When you want to add background to ScrollView, remember not to wrap Container for ListView or GridView at the child node, wrap Container outside Smart Refresher\n\n\n## Behind RefreshStyle\n* In fact, the realization of this style is realized by the dynamic change of height. Try to use Align attributes more in the periphery, and there will be different sliding effects.\n* It has been found that this style does not support Icon as a widget, i.e. Classial Header. It does not support Icon. Using this indicator,\nyou will find that Icon will be suspended in the attempt area for reasons I have not found out yet.\n\n## footer indicator\n* For the problem of not satisfying one page hiding, although the internal use of precedingScrollExtent to determine how many distances ahead, but this method is not advisable, there is a case that a sliver only occupies scrollExtent but not scrollExtent.\n  The case of layoutExtent. So if your internal slivers have this kind of sliver, my internal judgment is not legitimate, you need to judge manually. Set hideWhenNotFull to false, and then use Boolean values to determine.\n\n## NestedScrollView(Not advice to use unless necessary)\n* ScrollController need to be placed in NestedScrollView,there is not work just placed in \"child\"。\n\n## CustomScrollView\n* For UnFollow refresh style, when you slivers first element with Sliver Appbar, Sliver Rheader, there will be a very strange phenomenon, do not know how to describe, that is,\n the location of Sliver AppBar will change with the position of the indicator. In this case, you can try adding SliverToBox Adapter to the first element of slivers."
        },
        {
          "name": "problems.md",
          "type": "blob",
          "size": 4.42578125,
          "content": "1. <h3>怎么去监听ScrollView的位置变化啊?也就是要用到ScrollController.addListener?</h3>\n在child里的scrollView直接设置controller给它即可。\n\n2. <h3>在RefreshController暴露了position和scrollContorller目的是什么?</h3>\n首先,scrollController是先前的api就有的,后面改动的时候发现scrollController存在共用的问题,所以就弃用了,不打算删除,\n主要是可能有一部分人引用了它,删了就会造成有的人更新报错。而暴露这两个东西,主要是为了在某些情况下,不需要addListener,只需要\n控制跳转的情况。比如我实现聊天列表,我只需要控制ScrollView滚动到最下方,但我不需要监听它的位置的情况。\n\n3. <h3>报错,有这个提示\"Horizontal viewport was given unbounded height.\",如何解决?</h3>\n有这个报错提示的话,一般都是因为在child没有限定高度,比如说PageView,你不能直接在child里放进去,你需要给予PageView\n一个高度的限制\n\n4. <h3>我有一个需求,需要当不满一个屏幕,就禁用掉上拉加载，但是我不知道怎么计算ScrollView里的高度,每个item高度不一样,如何解决?</h3>\n在RefreshConfiguration有提供一个属性hideFooterWhenNotFull,绝大多数的情况,它可以帮你计算并判断是否隐藏。\n\n5. <h3>指示器支持自定义帧动画吗?比如,我想随着下拉拖动改变gif进度,到达某个状态开始循环播放</h3>\n这个问题我内部已经有完美的解决方法,需要依赖到我的三方插件来解决控制gif进度的问题,用法详见[这里](https://github.com/peng8350/flutter_gifimage),[例子](example/lib/ui/example/customindicator/gif_indicator_example1.dart)\n\n\n6. <h3>关于改变回弹动画的问题,SpringDecription里三个变量值是什么关系?怎么利用这三个值达到我要的回弹效果?</h3>\n这个问题建议你去查flutter里的api,需要明白一定的物理和数学知识。事实上,我也不知道怎么算\n\n7. <h3>在Android下,footer使用ShowAlways,我不想让它回弹怎么办?</h3>\nRefreshConfiguration配置属性maxUnderScrollExtent,自己判断平台然后,0.0代表不回弹\n\n8. <h3>我想在距离屏幕一半就开始加载数据,怎么设置?</h3>\nRefreshConfiguration配置属性footerTriggerDistance,屏幕一半你可以借助MediaContent或者LayoutBuilder来计算屏幕高度\n\n9. <h3>IOS状态栏双击为什么ListView不自动滚动到顶部?</h3>\n第一种可能,就是你把给予了ScrollController给child,所以不是Scaffold里的PrimaryScrollController,所以不跳转\n第二种可能,就是你外部的Scaffold不是你最顶层的Scaffold\n\n10. <h3>为什么使用CuperNavigationBar后(不只这一个情况),上面好像被遮住了一部分</h3>\n因为我内部就是采用CustomScrollView来实现的,而CustomScrollView它不像BoxScrollView会帮你注入padding,所以需要你自己注入padding或者使用SafeArea\n\n11. <h3>兼容性方面?</h3>\n自1.3.0换了一套新的方法去实现指示器，内部指示器实现是通过监听scrollController位置变化来实现的，并没有使用到类如NotificationListener和GestureDector这类可能引起滑动手势冲突的方法，\n所以应该可以兼容大多需要利用到手势之间的库。但是，可能不兼容一些库需要改写ScrollPhysics，内部的FrontStyle就很明显需要用到这个。\n\n12. <h3>我有这样一个需求:当footer为没有更多数据的状态时,我想让它追随内容的尾部,其他状态就一直居于底部,是否可以实现?</h3>\n参见RefreshConfiguration里的shouldFooterFollowWhenNotFull，可完美解决。\n\n13. <h3>为什么不兼容SingleChildView?</h3>\n因为SingleChildView它内部采用的Viewport是SingleChild,而其他Viewport基本都是MultipleChild,所以我内部是没办法取它的Viewport里的sliver,取了也\n不能添加header和footer,直接把child存放在SmartRefresher child里即可,child为非ScrollView,作用等同于SingleChildScrollView\n\n14.为什么拖到最大的距离不能触发刷新?为什么加载更多不触发?\n这类问题一般发生在Android系统，绝大数情况是因为maxOverScrollExtent和maxUnderScrollExtent限制了最大拖动的高度问题,你需要确保它要大于triggerDistance,因为内部\n没有帮你自动识别判断\n\n15.为什么引用库后,随着数据量大时越来越卡顿?\n这种情况绝大多数都是因为开启了shrinkWrap=true和设置physic:NeverScrollPhysics,ScrollView一定要作为SmartRefresher's child,不可分开。\n"
        },
        {
          "name": "problems_en.md",
          "type": "blob",
          "size": 4.7705078125,
          "content": "1.  <h3>How to monitor the location change of ScrollView? it mean I need to use ScrollController.addListener?</h3>\nset controller to the child(ScrollView) attribute \n\n2.  <h3>What is the purpose of position and scroll Contorller exposed in RefreshController?</h3>\nFirst of all, scrollController is a pre-existing api. When it was changed later, it was found that scrollController had a share problem, so it was abandoned and was not intended to be deleted.\nMaybe some people quote it, deleting it will cause some people having problems. The main reason for exposing these two things is that in some cases, addListener is not needed, but only needed.\nControl the jump. For example, when I implement a chat list, I just need to control ScrollView to scroll to the bottom, but I don't need to monitor its location.\n\n3.  <h3>throw error,with a hit text\"Horizontal viewport was given unbounded height.\",How to solve?</h3>\nIf you have this error message, it's usually because there's no limit on the height of the child. For example, PageView, you can't put it in the child directly. You need to give PageView a limit on the height.\n\n4.  <h3>I have a need to disable pull-up loading when I don't have a screen, but I don't know how to calculate the height in ScrollView. Each item has a different height. How to solve it?</h3>\nIn RefreshConfiguration, there is an attribute hideFooterWhenNotFull, which in most cases can help you calculate and determine whether or not to hide.\n\n5.  <h3>Does the indicator support custom frame animation? For example, I want to change the GIF schedule with drag-and-drop, reach a certain state and start cycling.</h3>\nNow this question has been solved ,check out this [plugin](https://github.com/peng8350/flutter_gifimage),can help you controll gif progress,and [example](example/lib/ui/example/customindicator/gif_indicator_example1.dart) is here\n\n6.  <h3>What is the relationship between the values of three variables in Spring Decription and how to use these values to achieve the rebound effect I want?</h3>\nThis question suggests that you look up the API in flutter, and you need to understand a certain amount of physics and mathematics. Actually, I don't know how to calculate it.\n\n7.  <h3>Under Android, footer uses ShowAlways style. What if I don't want it to bounce back?</h3>\nRefreshConfiguration have a contribute maxUnderScrollExtent,0.0 indicate no rebound\n\n8.  <h3>I want to start loading data half way from the screen. How do I set it up?</h3>\nRefreshConfigurationhave a contribute footerTriggerDistance,you can use MediaContent or LayoutBuilder compute screen height\n\n9. <h3>IOS Status Bar Double-click Why ListView does not automatically scroll to the top?</h3>\nthe one,You give ScrollController to the child, so it's not PrimaryScrollController in Scaffold, so it doesn't jump.\nThe second possibility is that your external Scaffold is not your ancestry Scaffold.\n\n10. <h3>Why is it that after using Cuper Navigation Bar (and not just this case), part of the list header is obscured?</h3>\nBecause I use CustomScrollView internally, and CustomScrollView doesn't inject padding like BoxScrollView does, so you need to inject padding or SafeArea yourself.\n\n11. <h3>Compatiable?</h3>\n1.3.0 replaces a new method to implement the indicator. The internal indicator is implemented by monitoring scroll Controller position changes. There are no methods such as NotificationListener and GestureDector that may cause sliding gesture conflicts.\nSo it should be compatible with most of the libraries that need to be used between gestures. However, some libraries may not be compatible and ScrollPhysics needs to be rewritten, which is clearly required for internal FrontStyle.\n\n12.  <h3>I have a requirement that when footer is in a state where there is no more data, I want it to follow the end of the content and the other states remain at the bottom. Is that possible?</h3>\nRefreshConfiguration's shouldFooterFollowWhenNotFull can solve\n\n13.  <h3>Why not compatible with SingleChildView?</h3>\nBecause SingleChildView uses SingleChild as its internal Viewport, while other Viewports are basically MultipleChild, so I can't get sliver from its Viewport internally.\nYou can't add header and footer. just put it into SmartRefresher's child instead.\n\n14. Why can't dragging to the maximum distance trigger refresh? Why load more without triggering?\nThis kind of problem usually occurs on Android systems, mostly because maxOverScrollExtent and maxUnderScrollExtent limit the height of the maximum drag. You need to make sure that it is larger than triggerDistance because it's internal.\nNot automatically identifying and judging for you\n\n15.Why performance become more and more slow with the large amount of data?\nthis situation is mostly because the setting shrinkWrap=true and physic:NeverScrollPhysics,ScrollView must be as SmartRefresher's child。\n\n"
        },
        {
          "name": "propertys.md",
          "type": "blob",
          "size": 5.5400390625,
          "content": "\n# SmartRefresher\n\n| Attribute Name     |     Attribute Explain     | Parameter Type | Default Value  | requirement |\n|---------|--------------------------|:-----:|:-----:|:-----:|\n| controller | 控制内部状态  | RefreshController | null | 必要 |\n| child      | 你的内容部件   | ? extends Widget   |   null |  可选 |\n| header | 头部指示器构造  | ? extends Widget  | ClassicHeader | 可选|\n| footer | 尾部指示器构造     | ? extends Widget | ClassicFooter | 可选 |\n| enablePullDown | 是否允许下拉     | boolean | true | 可选 |\n| enableTwoLevel |   是否允许打开头部指示器二楼的功能 | boolean | false | 可选 |\n| enablePullUp |   是否允许上拉 | boolean | false | 可选 |\n| onRefresh | 进入下拉刷新时的回调   | () => Void | null | 可选 |\n| onLoading | 进入上拉加载时的回调   | () => Void | null | 可选 |\n| onOffsetChange(2.0.0 removed) | 它将在超出边缘范围拖动时回调  | (bool,double) => Void | null | 可选 |\n| onTwoLevel | 当准备打开二楼时的回调   | () => Void | null | 可选 |\n\n\n# RefreshController Api\n\n```\n      //  请求顶部指示器刷新,触发onRefresh\n      void requestRefresh(\n          {Duration duration: const Duration(milliseconds: 300),\n          Curve curve: Curves.linear});\n     // 请求底部指示器加载数据,触发onLoading\n      void requestLoading(\n          {Duration duration: const Duration(milliseconds: 300),\n          Curve curve: Curves.linear}) ;\n      //  主动打开二楼\n      void requestTwoLevel(\n                {Duration duration: const Duration(milliseconds: 300),\n                Curve curve: Curves.linear});\n\n      // 顶部指示器刷新成功,是否要还原底部没有更多数据状态\n      void refreshCompleted({bool resetFooterState:false});\n      // 不显示任何状态,直接变成idle状态隐藏掉\n      void refreshToIdle();\n      // 顶部指示器刷新失败\n      void refreshFailed();\n      // 关闭二楼\n      void twoLevelComplete(\n       {Duration duration: const Duration(milliseconds: 500),\n       Curve curve: Curves.linear};\n      // 底部指示器加载完成\n      void loadComplete();\n      // 底部指示器进入一个没有更多数据的状态\n      void loadNoData();\n      // 底部加载失败\n      void loadFailed()\n      // 刷新底部指示器状态为idle\n      void resetNoData();\n\n```\n\n# RefreshConfiguration\n\n| Attribute Name     |     Attribute Explain     | Parameter Type | Default Value  | requirement |\n|---------|--------------------------|:-----:|:-----:|:-----:|\n| child | 不用解析你明白  | Widget  | null | 必要|\n| springDescription | 自定义弹性动画的配置,三个属性  | SpringDescription | default | 可选 |\n| dragSpeedRatio | 越界回弹时拖动的速度比例,公式:原始滑动引擎拖动速度*dragSpeedRatio  | double | 1.0 | 可选 |\n\n刷新全局设置(header):\n\n| Attribute Name     |     Attribute Explain     | Parameter Type | Default Value  | requirement |\n|---------|--------------------------|:-----:|:-----:|:-----:|\n| headerBuilder | 默认头部指示器全局构造器  | () =>  ? extends RefreshIndicator | null | 可选 |\n| headerTriggerDistance | 触发下拉刷新的越界距离     | double | 80.0 | 可选 |\n| maxOverScrollExtent | 最大顶部越界距离(拖动时)  | double | ios:inf,android:60 | 可选 |\n| skipCanRefresh | 直接跳过canRefresh状态进入刷新   | bool | false | 可选 |\n| enableScrollWhenTwoLevel | 当进入二楼时,是否允许上下滑动   | bool | false | 可选 |\n| twiceTriggerDistance | 触发进入二楼的越界距离   | double | 150.0 | 可选 |\n| closeTwoLevelDistance | 关闭二楼底部的底部越界距离,前提enableScrollWhenTwoLevel要为true  | double | 80.0 | 可选 |\n| enableBallisticRefresh | 是否可以通过惯性来触发刷新  | bool | false | 可选 |\n| enableScrollWhenRefreshCompleted |是否允许用户手势滑动当刷新完毕准备回弹回去时 | bool | true | 可选 |\n| topHitBoundary | 当快速惯性滑动时,顶部位置应该要在哪个位置停下来  | double | ios:inf,android:0 | 可选 |\n\n\n加载更多全局设置(footer):\n\n| Attribute Name     |     Attribute Explain     | Parameter Type | Default Value  | requirement |\n|---------|--------------------------|:-----:|:-----:|:-----:|\n| footerBuilder      | 默认尾部指示器全局构造器   | () =>  ? extends LoadIndicator  |   null |  可选 |\n| hideWhenNotFull | 当ScrollView不满一页时,是否要隐藏底部指示器   | bool | false | 可选 |\n| autoLoad(2.0.0 removed) | 自动加载更多,假如为false,滑动底部不会触发,但提供点击加载更多的方法  | bool | true | 可选 |\n| enableLoadingWhenFailed |  是否允许通过手势来触发加载更多当失败的状态  | bool | true| 可选 |\n| enableLoadingWhenNodata |  是否允许通过手势来触发加载更多当没有更多数据的状态  | bool | false| 可选 |\n| footerTriggerDistance |   距离底部边缘触发加载更多的距离,注意这个属性和header的不同,它可以为负数,负数代表越界 | double | 15.0 | 可选 |\n| maxUnderScrollExtent | 最大底部越界距离(拖动时)   | double | ios:inf,android:0 | 可选 |\n| enableBallisticLoad | 是否可以通过惯性来触发加载更多  | bool | true | 可选 |\n| shouldFooterFollowWhenNotFull | 当不满一个屏幕时,对于不同状态要不要跟随内容列表,前提hideFooterWhenNotFull = false | (LoadStatus) => bool | () => false | 可选 |\n| bottomHitBoundary | 当快速惯性滑动时,底部位置应该要在哪个位置停下来   | double | ios:inf,android:0 | 可选 |"
        },
        {
          "name": "propertys_en.md",
          "type": "blob",
          "size": 5.4267578125,
          "content": "\n# SmartRefresher\n\n| Attribute Name     |     Attribute Explain     | Parameter Type | Default Value  | requirement |\n|---------|--------------------------|:-----:|:-----:|:-----:|\n| controller | controll inner headerMode and footerMode  | RefreshController | null | necessary |\n| child      | your content  Widget   | ? extends Wiget   |   null |  optional |\n| header | refresh indicator  | ? extends Widget  | ClassicHeader | optional|\n| footer | load indicator     | ? extends Widget | ClassicFooter | optional |\n| enablePullDown | switch of pulldownrefresh     | boolean | true | optional |\n| enableTwoLevel |   whether to open the function of twoLevel for header | boolean | false | 可选 |\n| enablePullUp |   switch of pullupload | boolean | false | optional |\n| onRefresh | callback when refreshing  | () => Void | null | optional |\n| onLoading | callback when loading   | () => Void | null | optional |\n| onOffsetChange(2.0.0 removed) | callBack the Visible range of indicator  | (bool,double) => Void | null | optional |\n| onTwoLevel | callback when second floor is opening   | () => Void | null | 可选 |\n\n\n# RefreshController Api\n\n```\n      //  Request top indicator refresh to trigger onRefresh\n      void requestRefresh(\n          {Duration duration: const Duration(milliseconds: 300),\n          Curve curve: Curves.linear});\n     // Request bottom indicator to load data and trigger onLoading\n      void requestLoading(\n          {Duration duration: const Duration(milliseconds: 300),\n          Curve curve: Curves.linear}) ;\n      // Top Indicator Refresh Success\n      void refreshCompleted({});\n      // Top Indicator Refresh Failed\n      void refreshFailed();\n      // Bottom Indicator Loading Completed\n      // set to idle, and hide back\n      void refreshToIdle();\n       // close second floor\n       void twoLevelComplete(\n             {Duration duration: const Duration(milliseconds: 500),\n             Curve curve: Curves.linear};\n      void loadComplete();\n      // The bottom indicator enters a state without more data\n      void loadNoData();\n      // Refresh the bottom indicator status to idle\n      // footer load failed\n      void loadFailed()\n      void resetNoData();\n\n```\n\n# RefreshConfiguration\n\n| Attribute Name     |     Attribute Explain     | Parameter Type | Default Value  | requirement |\n|---------|--------------------------|:-----:|:-----:|:-----:|\n| child | you know,no need to explain  | Widget | null | 必要|\n| springDescription | custom spring animate config  | SpringDescription | default | 可选 |\n| dragSpeedRatio | the speed ratio when dragging overscroll ,compute=origin physics dragging speed *dragSpeedRatio  | double | 1.0 | 可选 |\n\nRefresh(header):\n\n| Attribute Name     |     Attribute Explain     | Parameter Type | Default Value  | requirement |\n|---------|--------------------------|:-----:|:-----:|:-----:|\n| headerBuilder | the header indicator builder  | () =>  ? extends RefreshIndicator | null | 可选 |\n| headerTriggerDistance | overScroll distance of  trigger refresh     | double | 80.0 | 可选 |\n| maxOverScrollExtent | max overScroll distance   | double | ios:inf,android:60 | 可选 |\n| skipCanRefresh | if skip canRefresh state,enter refreshing state directly  | bool | false | 可选 |\n| enableScrollWhenTwoLevel | whether enable scroll when into twoLevel   | bool | false | 可选 |\n| twiceTriggerDistance | the overScroll distance of trigger twoLevel  | double | 150.0 | 可选 |\n| closeTwoLevelDistance | Close the bottom crossing distance on the second floor, premise:enableScrollWhenTwoLevel is true  | double | 80.0 | 可选 |\n| enableBallisticRefresh | whether trigger refresh by BallisticScrollActivity(it mean use is not dragging on the screen)  | bool | false | 可选 |\n| enableScrollWhenRefreshCompleted | Whether the user is allowed to slide scrollable when the refresh is complete and ready to bounce back  | bool | true | 可选 |\n| topHitBoundary | When fast fling to top, setting a top boundary make the bouncing stop     | double | ios:inf,android:0 | 可选 |\n\n\nLoad more(footer):\n\n| Attribute Name     |     Attribute Explain     | Parameter Type | Default Value  | requirement |\n|---------|--------------------------|:-----:|:-----:|:-----:|\n| footerBuilder      | the footer indicator builder   | () =>  ? extends LoadIndicator  |   null |  可选 |\n| hideWhenNotFull | whether to hide footer when scrollview not enough one page   | bool | true | 可选 |\n| autoLoad(2.0.0 removed) | Autoload more, if false, sliding bottom will not trigger, but provide more click loading methods  | bool | true | 可选 |\n| enableLoadingWhenFailed |  whether allowed to use gesture pull-up trigger to load more when failed state  | bool | true| 可选 |\n| enableLoadingWhenNoData |  whether allowed to use gesture pull-up trigger to load more when no more data state  | bool | false| 可选 |\n| maxUnderScrollExtent | max underScroll distance  | double | ios:inf,android:0 | 可选 |\n| footerTriggerDistance |   the extentAfter distance of  trigger loading  | double | 15.0 | 可选 |\n\n| enableBallisticRefresh | whether trigger loading by BallisticScrollActivity(it mean use is not dragging on the screen)  | bool | true | 可选 |\n| shouldFooterFollowWhenNotFull | When not full one page,If it should follow content for different status,premise: hideFooterWhenNotFull = false | (LoadStatus) => bool | () => false | 可选 |\n| bottomHitBoundary | When fast fling to bottom, setting a bottom boundary make the bouncing stop     | double | ios:inf,android:0 | 可选 |"
        },
        {
          "name": "pubspec.yaml",
          "type": "blob",
          "size": 0.380859375,
          "content": "name: pull_to_refresh\ndescription: a widget provided to the flutter scroll component drop-down refresh and pull up load.\nversion: 2.0.0\nhomepage: https://github.com/peng8350/flutter_pulltorefresh\n\nenvironment:\n  sdk: \">=2.12.0 <3.0.0\"\n  flutter: \">=2.0.0\"\n\ndependencies:\n  flutter:\n    sdk: flutter\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n\nflutter:\n  uses-material-design: true\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}