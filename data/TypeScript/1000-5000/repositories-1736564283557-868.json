{
  "metadata": {
    "timestamp": 1736564283557,
    "page": 868,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cawa-93/vite-electron-builder",
      "stars": 2494,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.3486328125,
          "content": "# EditorConfig is awesome: http://EditorConfig.org\n\n# https://github.com/jokeyrhyme/standard-editorconfig\n\n# top-most EditorConfig file\nroot = true\n\n# defaults\n[*]\ncharset = utf-8\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\nindent_size = 2\nindent_style = space\n\n[*.md]\ntrim_trailing_whitespace = false\nmax_line_length = 200\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.142578125,
          "content": ".github/actions/**/*.js linguist-detectable=false\nscripts/*.js linguist-detectable=false\n*.config.js linguist-detectable=false\n* text=auto eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 1.1494140625,
          "content": "node_modules\n.DS_Store\ndist\n*.local\nthumbs.db\n\n.eslintcache\n\n# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio, WebStorm and Rider\n# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839\n\n# User-specific stuff\n.idea/**/workspace.xml\n.idea/**/tasks.xml\n.idea/**/usage.statistics.xml\n.idea/**/dictionaries\n.idea/**/shelf\n\n# Generated files\n.idea/**/contentModel.xml\n\n# Sensitive or high-churn files\n.idea/**/dataSources/\n.idea/**/dataSources.ids\n.idea/**/dataSources.local.xml\n.idea/**/sqlDataSources.xml\n.idea/**/dynamic.xml\n.idea/**/uiDesigner.xml\n.idea/**/dbnavigator.xml\n\n# Gradle\n.idea/**/gradle.xml\n.idea/**/libraries\n\n# Gradle and Maven with auto-import\n# When using Gradle or Maven with auto-import, you should exclude module files,\n# since they will be recreated, and may cause churn.  Uncomment if using\n# auto-import.\n .idea/artifacts\n .idea/compiler.xml\n .idea/jarRepositories.xml\n .idea/modules.xml\n .idea/*.iml\n .idea/modules\n *.iml\n *.ipr\n\n# Mongo Explorer plugin\n.idea/**/mongoSettings.xml\n\n# File-based project format\n*.iws\n\n# Editor-based Rest Client\n.idea/httpRequests\n/.idea/csv-plugin.xml\n"
        },
        {
          "name": ".idea",
          "type": "tree",
          "content": null
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.2529296875,
          "content": "# Contributing\n\nFirst and foremost, thank you! We appreciate that you want to contribute to vite-electron-builder.\n\n## Issues\n- All reports of bugs, problems, and flaws are welcome.\n- Improvements of documentation are welcome as well.\n- If you have a question or a request for help, please prefer to create it in the discussion section.\n\n## Pull Requests\n- Developing this template is no different from using it to develop an end application. Just follow the [README.md](README.md) for instructions to set up. \n  It also describes the structure of the template and the available commands.\n- Save your time. Before proposing any changes to the main repository, create an issue for discussion a proposal.\n- When creating this template, I try to stick to minimalism. Please prefer to use the native features of the platform and avoid adding third-party dependencies without a really good reason.\n- I follow the idea that code style should be left to the end template-user, so this repo does not contain any linters or formatters by default.\n  I also don't make any requirements for strict adherence to the code style.\n  That's up to you. Try to keep things consistent and don't go crazy.\n- This repo has configured end-to-end tests. If you can't run tests locally - make a PR in draft.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "MIT License\n\nCopyright (c) 2021 Alex Kozack\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.0673828125,
          "content": "\n> [!Important]\n> This project is maintained by developer from Ukraine ğŸ‡ºğŸ‡¦\n> \n> I do my best, but due to Russia's ongoing full-scale invasion of Ukraine, I barely have the energy to support open source projects.\n>\n> If my work has been useful to you, please consider [supporting Ukraine](https://stand-with-ukraine.pp.ua/) or [me personally](https://send.monobank.ua/6SmojkkR9i). Even your **$1** has an impact!\n\n![IMG_0875](https://github.com/user-attachments/assets/590de304-e2c4-4935-9814-c18ade52fd8e)\n\n\n# Vite Electron Builder Boilerplate\n\n![GitHub last commit](https://img.shields.io/github/last-commit/cawa-93/vite-electron-builder?label=last%20update)\n![GitHub package.json dev/peer/optional dependency version](https://img.shields.io/github/package-json/dependency-version/cawa-93/vite-electron-builder/dev/electron) \n![GitHub package.json dev/peer/optional dependency version](https://img.shields.io/github/package-json/dependency-version/cawa-93/vite-electron-builder/dev/electron-builder)\n![GitHub package.json dev/peer/optional dependency version](https://img.shields.io/github/package-json/dependency-version/cawa-93/vite-electron-builder/dev/vite?filename=packages%2Fmain%2Fpackage.json)\n![GitHub package.json dev/peer/optional dependency version](https://img.shields.io/github/package-json/dependency-version/cawa-93/vite-electron-builder/dev/playwright)\n\nThis is a template for secure electron applications. Written following the latest safety requirements, recommendations\nand best practices.\n\n## Get started\n\nFollow these steps to get started with the template:\n\n1. Click the **[Use this template](https://github.com/cawa-93/vite-electron-builder/generate)** button (you must be logged in) or just clone this repo.\n2. Go to project folder and run `npm run init`.\n3. Start application in development mode by `npm start`.\n4. Compile executable by `npm run compile`.\n \nThat's all you need. ğŸ˜‰\n\n> [!TIP]\n> You can explore the demo application for various frameworks and operating systems in the [Deployment](https://github.com/cawa-93/vite-electron-builder/deployments) section.\n> This will allow you to see how the application performs across different environments.\n> Additionally, you can verify the auto-update functionality by installing an outdated version of the application.\n\nâ¤ï¸ **If you like this template, give a â­ or [send support](https://www.buymeacoffee.com/kozack/)!**\n\n## Features\n\n### Lightweight\nWhen designing this template, I tried to keep ÑˆĞµ minimal, using the platform's native features to the maximum and minimizing the number of third-party dependencies.\n\n### Electron\n\n- This template uses the latest electron version with all the latest security patches.\n- The architecture of the application is built according to the security [guides](https://www.electronjs.org/docs/tutorial/security) and best practices.\n- The latest version of the [electron-builder] is used to package the application.\n\n### Automatic tests\n\n- End-to-end are placed in the root [`tests`](tests) directory and use [playwright].\n- You may write any unit tests inside each package and use whatever you ~~want~~ need.\n\n### Continuous Integration\n\n- The configured workflow will check the types for each push and PR.\n- Code signing supported. See [code-signing documentation](https://www.electron.build/code-signing.html).\n\n### Auto-update\n\nEach time you push changes to the `main` branch,\nthe [`ci`](.github/workflows/ci.yml) workflow starts to create and deploy a new application version with then will be downloaded and applied by each app instance.\n\n## Project Structure\n\nThe project is designed as monorepo where each part of the application is an independent package.\nEach package could have own tech stack, tests, dependencies, frameworks, etc.\nAll internal names are prefixed by `@vite-electron-builder/*`.\nThere are no technical reasons for this.\nIt's just for you to make it easier to understand the architecture.\n\nInitially, the repository contains only a few packages.4\n\n### Packages with building tools:\n\n- [`packages/integrate-renderer`](packages/integrate-renderer) - A helper package that is not included in the runtime.\n  It is used in `npm run init` to configure a new interface package.\n- [`packages/electron-versions`](packages/electron-versions) - A set of helper functions to get the versions of internal components bundled within Electron.\n\n### Packages with app logic:\n\n- [`packages/main`](packages/main) - Implementation of Electron's [**main script**](https://www.electronjs.org/docs/tutorial/quick-start#create-the-main-script-file).\n- [`packages/preload`](packages/preload) - Implementation of Electron's [**preload scripts**](https://www.electronjs.org/docs/latest/tutorial/tutorial-preload).\n\n### Renderer is not included\n\nAs you may have noticed, the repository does **not** contain a package that implements the application interface.\nThe reason is that since the entire application is a mono-repository,\nyou can use any web application based on any framework or bundler as a package for the interface.\n\nThere is only one requirement: the template expects to import renderer by `@vite-electron-builder/renderer` name.\n\n> [!TIP]\n> You can create new renderer package in interactive mode by `npm run init`.\n\n> [!NOTE]\n> If you are using a bundler other than vite,\n> you may need to slightly change the [dev-mode.js](packages/dev-mode.js) script to run it correctly.\n\n## How It works\n\n### Compile executable\n\nWhen an application is ready to distribute, you need to compile it into executable.\nWe are using [electron-builder] for\nthis.\n\n- You can compile application locally by `npm run compile`.\n  In this case, you will get executable that you cat share, but it will not support auto-updates out-of-box.\n- To have auto-updater, you should compile an application and publish it to one or more supported sources for distribution. In this case, all application instances will download and apply all new updates. This is done by GitHub action in [release.yml](.github/workflows/release.yml).\n\n> [!TIP]\n> This template is configured to use GitHub Releases to distribute updates, but you can configure whatever you need.\n> Find more in [electron-builder docs](https://www.electron.build/configuration/publish).\n\n\n### Working with third-party dependencies\n\nBecause the `renderer` works and builds like a _regular web application_, you can only use dependencies that support the\nbrowser or compile to a browser-friendly format.\n\nThis means that in the `renderer` you are free to use any frontend dependencies such as Vue, React, lodash, axios and so\non. However, you _CANNOT_ use any native Node.js APIs, such as, `systeminformation`. These APIs are _only_ available in\na Node.js runtime environment and will cause your application to crash if used in the `renderer` layer. Instead, if you\nneed access to Node.js runtime APIs in your frontend, export a function form the `preload` package.\n\nAll dependencies that require Node.js api can be used in\nthe [`preload` script](https://www.electronjs.org/docs/latest/tutorial/process-model#preload-scripts).\n\n#### Expose in the main world\n\nHere is an example. Let's say you need to read some data from the file system or database in the renderer.\n\nIn the preload context, create a function that reads and returns data. To make the function announced in the preload\navailable in the render, you usually need to call\nthe [`electron.contextBridge.exposeInMainWorld`](https://www.electronjs.org/ru/docs/latest/api/context-bridge).\n\nHowever, this template is designed to use all power of ES modules.\nYou can import anything from `preload` in `renderer`.\nAll the data will quietly throw through the `electron.contextBridge.exposeInMainWorld()`,\nso you don't need to worry about it.\n\n```ts\n// preload/src/index.ts\nimport {readFile} from 'node:fs/promises';\n\n// Encapsulate types if you use typescript\ninterface UserData {\n  prop: string\n}\n\n// Will call `electron.contextBridge.exposeInMainWorld('getUserData', getUserData)`\nexport function getUserData(): Promise<UserData> {\n  return readFile('/path/to/file/in/user/filesystem.json', {encoding: 'utf8'}).then(JSON.parse);\n}\n```\n\nNow you can import and call the method in renderer\n\n```ts\n// renderer/src/anywere/component.ts\nimport {getUserData} from '@vite-electron-builder/preload'\n\n// Method will came from exposed context\n// const userData = globalThis['getUserData']\nconst userData = await getUserData()\n```\n\n> [!TIP]\n> Find more\n> in [Context Isolation tutorial](https://www.electronjs.org/docs/tutorial/context-isolation#security-considerations).\n\n### Working with Electron API\n\nAlthough the preload has access to all of Node.js API, it **still runs in the BrowserWindow context**, so only limited\nelectron modules are available in it.\n\n> [!TIP]\n> Check the [electron docs](https://www.electronjs.org/ru/docs/latest/api/clipboard) for the full list of available\n> methods.\n\nAll other electron methods can be invoked in the `main`.\n\nAs a result, the architecture of interaction between all modules is as follows:\n\n```mermaid\nsequenceDiagram\nrenderer->>+preload: Read data from file system\npreload->>-renderer: Data\nrenderer->>preload: Maximize window\nactivate preload\npreload-->>main: Invoke IPC command\nactivate main\nmain-->>preload: IPC response\ndeactivate main\npreload->>renderer: Window maximized\ndeactivate preload\n```\n\n> [!TIP]\n> Find more in [Inter-Process Communication tutorial](https://www.electronjs.org/docs/latest/tutorial/ipc).\n\n### Modes and Environment Variables\n\nAll environment variables are set as part of the `import.meta`, so you can access them vie the following\nway: `import.meta.env`.\n\n> [!NOTE]\n> If you are using TypeScript and want to get code completion,\n> you must add all the environment variables to the [`ImportMetaEnv` in `types/env.d.ts`](types/env.d.ts).\n\nThe mode option is used to specify the value of `import.meta.env.MODE` and the corresponding environment variables files\nthat need to be loaded.\n\nBy default, there are two modes:\n\n- `production` is used by default\n- `development` is used by `npm start` script\n\nWhen running the build script, the environment variables are loaded from the following files in your project root:\n\n```\n.env                # loaded in all cases\n.env.local          # loaded in all cases, ignored by git\n.env.[mode]         # only loaded in specified env mode\n.env.[mode].local   # only loaded in specified env mode, ignored by git\n```\n\n> [!WARNING]\n> To prevent accidentally leaking env variables to the client, only variables prefixed with `VITE_` are exposed to your\n> Vite-processed code.\n\nFor example, let's take the following `.env` file:\n\n```\nDB_PASSWORD=foobar\nVITE_SOME_KEY=123\n```\n\nOnly `VITE_SOME_KEY` will be exposed as `import.meta.env.VITE_SOME_KEY` to your client source code, but `DB_PASSWORD`\nwill not.\n\n> [!TIP]\n> You can change that prefix or add another. See [`envPrefix`](https://vitejs.dev/config/shared-options.html#envprefix).\n\n### NPM Scripts\n\n```sh\nnpm start\n```\nStart application in development more with hot-reload.\n\n---\n```sh\nnpm run build\n```\nRuns the `build` command in all workspaces if present.\n\n---\n```sh\nnpm run compile\n```\nFirst runs the `build` script,\nthen compiles the project into executable using `electron-builder` with the specified configuration.\n\n---\n```sh\nnpm run compile -- --dir -c.asar=false\n```\nSame as `npm run compile` but pass to `electron-builder` additional parameters to disable asar archive and installer\ncreating.\nUseful for debugging compiled application.\n\n---\n```sh\nnpm run test\n```\nExecutes end-to-end tests on **compiled app** using Playwright.\n\n---\n```sh\nnpm run typecheck\n```\nRuns the `typecheck` command in all workspaces if present.\n\n---\n```sh\nnpm run create-renderer\n```\nInitializes a new Vite project named `renderer`. Basically same as `npm create vite`.\n\n---\n```sh\nnpm run integrate-renderer\n```\nStarts the integration process of the renderer using the Vite Electron builder.\n\n---\n```sh\nnpm run init\n```\nSet up the initial environment by creating a new renderer, integrating it, and installing the necessary packages.\n\n## Contribution\n\nSee [Contributing Guide](CONTRIBUTING.md).\n\n\n[vite]: https://github.com/vitejs/vite/\n\n[electron]: https://github.com/electron/electron\n\n[electron-builder]: https://github.com/electron-userland/electron-builder\n\n[playwright]: https://playwright.dev\n"
        },
        {
          "name": "buildResources",
          "type": "tree",
          "content": null
        },
        {
          "name": "electron-builder.mjs",
          "type": "blob",
          "size": 3.2626953125,
          "content": "import pkg from './package.json' with {type: 'json'};\nimport mapWorkspaces from '@npmcli/map-workspaces';\nimport {join} from 'node:path';\nimport {pathToFileURL} from 'node:url';\n\nexport default /** @type import('electron-builder').Configuration */\n({\n  directories: {\n    output: 'dist',\n    buildResources: 'buildResources',\n  },\n  generateUpdatesFilesForAllChannels: true,\n  linux: {\n    target: ['deb'],\n  },\n  /**\n   * It is recommended to avoid using non-standard characters such as spaces in artifact names,\n   * as they can unpredictably change during deployment, making them impossible to locate and download for update.\n   */\n  artifactName: '${productName}-${version}-${os}-${arch}.${ext}',\n  files: [\n    'LICENSE*',\n    'packages/entry-point.js',\n    '!node_modules/@vite-electron-builder/**',\n    ...await getListOfFilesFromEachWorkspace(),\n  ],\n});\n\n/**\n * By default, electron-builder copies each package into the output compilation entirety,\n * including the source code, tests, configuration, assets, and any other files.\n *\n * So you may get compiled app structure like this:\n * ```\n * app/\n * â”œâ”€â”€ node_modules/\n * â”‚   â””â”€â”€ workspace-packages/\n * â”‚       â”œâ”€â”€ package-a/\n * â”‚       â”‚   â”œâ”€â”€ src/            # Garbage. May be safely removed\n * â”‚       â”‚   â”œâ”€â”€ dist/\n * â”‚       â”‚   â”‚   â””â”€â”€ index.js    # Runtime code\n * â”‚       â”‚   â”œâ”€â”€ vite.config.js  # Garbage\n * â”‚       â”‚   â”œâ”€â”€ .env            # some sensitive config\n * â”‚       â”‚   â””â”€â”€ package.json\n * â”‚       â”œâ”€â”€ package-b/\n * â”‚       â”œâ”€â”€ package-c/\n * â”‚       â””â”€â”€ package-d/\n * â”œâ”€â”€ packages/\n * â”‚   â””â”€â”€ entry-point.js\n * â””â”€â”€ package.json\n * ```\n *\n * To prevent this, we read the â€œfilesâ€\n * property from each package's package.json\n * and add all files that do not match the patterns to the exclusion list.\n *\n * This way,\n * each package independently determines which files will be included in the final compilation and which will not.\n *\n * So if `package-a` in its `package.json` describes\n * ```json\n * {\n *   \"name\": \"package-a\",\n *   \"files\": [\n *     \"dist/**\\/\"\n *   ]\n * }\n * ```\n *\n * Then in the compilation only those files and `package.json` will be included:\n * ```\n * app/\n * â”œâ”€â”€ node_modules/\n * â”‚   â””â”€â”€ workspace-packages/\n * â”‚       â”œâ”€â”€ package-a/\n * â”‚       â”‚   â”œâ”€â”€ dist/\n * â”‚       â”‚   â”‚   â””â”€â”€ index.js    # Runtime code\n * â”‚       â”‚   â””â”€â”€ package.json\n * â”‚       â”œâ”€â”€ package-b/\n * â”‚       â”œâ”€â”€ package-c/\n * â”‚       â””â”€â”€ package-d/\n * â”œâ”€â”€ packages/\n * â”‚   â””â”€â”€ entry-point.js\n * â””â”€â”€ package.json\n * ```\n */\nasync function getListOfFilesFromEachWorkspace() {\n\n  /**\n   * @type {Map<string, string>}\n   */\n  const workspaces = await mapWorkspaces({\n    cwd: process.cwd(),\n    pkg,\n  });\n\n  const allFilesToInclude = [];\n\n  for (const [name, path] of workspaces) {\n    const pkgPath = join(path, 'package.json');\n    const {default: workspacePkg} = await import(pathToFileURL(pkgPath), {with: {type: 'json'}});\n\n    let patterns = workspacePkg.files || ['dist/**', 'package.json'];\n\n    patterns = patterns.map(p => join('node_modules', name, p));\n    allFilesToInclude.push(...patterns);\n  }\n\n  return allFilesToInclude;\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.2275390625,
          "content": "{\n  \"name\": \"root\",\n  \"description\": \"Secure boilerplate for Electron app based on Vite\",\n  \"version\": \"3.1.0\",\n  \"private\": true,\n  \"type\": \"module\",\n  \"author\": {\n    \"email\": \"kozackunisoft@gmail.com\",\n    \"name\": \"Alex Kozack\",\n    \"url\": \"https://kozack.me\"\n  },\n  \"main\": \"packages/entry-point.js\",\n  \"workspaces\": [\n    \"packages/*\"\n  ],\n  \"engines\": {\n    \"node\": \">=23.0.0\"\n  },\n  \"scripts\": {\n    \"build\": \"npm run build -ws --if-present\",\n    \"compile\": \"npm run build && electron-builder build --config electron-builder.mjs\",\n    \"test\": \"npx playwright test ./tests/e2e.spec.ts\",\n    \"start\": \"node packages/dev-mode.js\",\n    \"typecheck\": \"npm run typecheck -ws --if-present\",\n    \"create-renderer\": \"cd packages && npm create vite@latest renderer\",\n    \"integrate-renderer\": \"npm start --workspace @vite-electron-builder/integrate-renderer\",\n    \"init\": \"npm run create-renderer && npm run integrate-renderer && npm install\"\n  },\n  \"devDependencies\": {\n    \"@npmcli/map-workspaces\": \"4.0.2\",\n    \"@playwright/test\": \"1.49.0\",\n    \"@types/node\": \"22.10.2\",\n    \"electron\": \"33.2.1\",\n    \"electron-builder\": \"26.0.0-alpha.8\",\n    \"glob\": \"11.0.0\",\n    \"playwright\": \"1.49.0\"\n  },\n  \"dependencies\": {\n    \"@vite-electron-builder/main\": \"*\"\n  }\n}\n"
        },
        {
          "name": "packages",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "types",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}