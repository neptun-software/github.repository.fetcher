{
  "metadata": {
    "timestamp": 1736563989670,
    "page": 530,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "YousefED/typescript-json-schema",
      "stars": 3191,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.037109375,
          "content": "bin/typescript-json-schema text eol=lf"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1220703125,
          "content": "node_modules\ntest/*.js\ntest/*.d.ts\ntest/*.map\n.vscode/*.*\nnpm-debug.log\nyarn-error.log\n.idea\n*~\n.#*\ndist/\n.DS_Store\n.history/"
        },
        {
          "name": ".npmignore",
          "type": "blob",
          "size": 0.1181640625,
          "content": ".DS_Store\n.gitattributes\n.github\n.travis.yml\n.vscode/*.*\nexample/\nnode_modules\ntest/\ntypings/\nyarn-error.log\ndist/test/*\n"
        },
        {
          "name": ".prettierrc.json",
          "type": "blob",
          "size": 0.2294921875,
          "content": "{\n  \"printWidth\": 120,\n  \"tabWidth\": 4,\n  \"overrides\": [\n    {\n      \"files\": \"*.json\",\n      \"options\": {\n        \"tabWidth\": 2\n      }\n    },\n    {\n      \"files\": \"*.yml\",\n      \"options\": {\n        \"tabWidth\": 2\n      }\n    }\n  ]\n}\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4697265625,
          "content": "Copyright (c) 2016, typescript-json-schema contributors\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.0322265625,
          "content": "# typescript-json-schema\n\n[![npm version](https://img.shields.io/npm/v/typescript-json-schema.svg)](https://www.npmjs.com/package/typescript-json-schema) ![Test](https://github.com/YousefED/typescript-json-schema/workflows/Test/badge.svg)\n\nGenerate json-schemas from your Typescript sources. This library is lightweight and more or less in maintenance mode. For a more complete JSON schema generator, take a look at [ts-json-schema-generator](https://github.com/vega/ts-json-schema-generator).\n\n## Features\n\n- Compiles your Typescript program to get complete type information.\n- Translates required properties, extends, annotation keywords, property initializers as defaults. You can find examples for these features in the [api doc](https://github.com/YousefED/typescript-json-schema/tree/master/api.md) or the [test examples](https://github.com/YousefED/typescript-json-schema/tree/master/test/programs).\n\n## Usage\n\n### Command line\n\n- Install with `npm install typescript-json-schema -g`\n- Generate schema from a typescript type: `typescript-json-schema project/directory/tsconfig.json TYPE`\n\nTo generate files for only _some_ types in `tsconfig.json` specify\nfilenames or globs with the `--include` option. This is especially useful for large projects.\n\nIn case no `tsconfig.json` is available for your project, you can directly specify the .ts files (this in this case we use some built-in compiler presets):\n\n- Generate schema from a typescript type: `typescript-json-schema \"project/directory/**/*.ts\" TYPE`\n\nThe `TYPE` can either be a single, fully qualified type or `\"*\"` to generate the schema for all types.\n\n```\nUsage: typescript-json-schema <path-to-typescript-files-or-tsconfig> <type>\n\nOptions:\n  --refs                Create shared ref definitions.                               [boolean] [default: true]\n  --aliasRefs           Create shared ref definitions for the type aliases.          [boolean] [default: false]\n  --topRef              Create a top-level ref definition.                           [boolean] [default: false]\n  --titles              Creates titles in the output schema.                         [boolean] [default: false]\n  --defaultProps        Create default properties definitions.                       [boolean] [default: false]\n  --noExtraProps        Disable additional properties in objects by default.         [boolean] [default: false]\n  --propOrder           Create property order definitions.                           [boolean] [default: false]\n  --required            Create required array for non-optional properties.           [boolean] [default: false]\n  --strictNullChecks    Make values non-nullable by default.                         [boolean] [default: false]\n  --esModuleInterop     Use esModuleInterop when loading typescript modules.         [boolean] [default: false]\n  --skipLibCheck        Use skipLibCheck when loading typescript modules.            [boolean] [default: false]\n  --useTypeOfKeyword    Use `typeOf` keyword (https://goo.gl/DC6sni) for functions.  [boolean] [default: false]\n  --out, -o             The output file, defaults to using stdout\n  --validationKeywords  Provide additional validation keywords to include            [array]   [default: []]\n  --include             Further limit tsconfig to include only matching files        [array]   [default: []]\n  --ignoreErrors        Generate even if the program has errors.                     [boolean] [default: false]\n  --excludePrivate      Exclude private members from the schema                      [boolean] [default: false]\n  --uniqueNames         Use unique names for type symbols.                           [boolean] [default: false]\n  --rejectDateType      Rejects Date fields in type definitions.                     [boolean] [default: false]\n  --id                  Set schema id.                                               [string]  [default: \"\"]\n  --defaultNumberType   Default number type.                                         [choices: \"number\", \"integer\"] [default: \"number\"]\n  --tsNodeRegister      Use ts-node/register (needed for require typescript files).  [boolean] [default: false]\n  --constAsEnum         Use enums with a single value when declaring constants.      [boolean] [default: false]\n  --experimentalDecorators  Use experimentalDecorators when loading typescript modules.\n   [boolean] [default: true]\n```\n\n### Programmatic use\n\n```ts\nimport { resolve } from \"path\";\n\nimport * as TJS from \"typescript-json-schema\";\n\n// optionally pass argument to schema generator\nconst settings: TJS.PartialArgs = {\n    required: true,\n};\n\n// optionally pass ts compiler options\nconst compilerOptions: TJS.CompilerOptions = {\n    strictNullChecks: true,\n};\n\n// optionally pass a base path\nconst basePath = \"./my-dir\";\n\nconst program = TJS.getProgramFromFiles(\n  [resolve(\"my-file.ts\")],\n  compilerOptions,\n  basePath\n);\n\n// We can either get the schema for one file and one type...\nconst schema = TJS.generateSchema(program, \"MyType\", settings);\n\n// ... or a generator that lets us incrementally get more schemas\n\nconst generator = TJS.buildGenerator(program, settings);\n\n// generator can be also reused to speed up generating the schema if usecase allows:\nconst schemaWithReusedGenerator = TJS.generateSchema(program, \"MyType\", settings, [], generator);\n\n// all symbols\nconst symbols = generator.getUserSymbols();\n\n// Get symbols for different types from generator.\ngenerator.getSchemaForSymbol(\"MyType\");\ngenerator.getSchemaForSymbol(\"AnotherType\");\n```\n\n```ts\n// In larger projects type names may not be unique,\n// while unique names may be enabled.\nconst settings: TJS.PartialArgs = {\n    uniqueNames: true,\n};\n\nconst generator = TJS.buildGenerator(program, settings);\n\n// A list of all types of a given name can then be retrieved.\nconst symbolList = generator.getSymbols(\"MyType\");\n\n// Choose the appropriate type, and continue with the symbol's unique name.\ngenerator.getSchemaForSymbol(symbolList[1].name);\n\n// Also it is possible to get a list of all symbols.\nconst fullSymbolList = generator.getSymbols();\n```\n\n`getSymbols('<SymbolName>')` and `getSymbols()` return an array of `SymbolRef`, which is of the following format:\n\n```ts\ntype SymbolRef = {\n    name: string;\n    typeName: string;\n    fullyQualifiedName: string;\n    symbol: ts.Symbol;\n};\n```\n\n`getUserSymbols` and `getMainFileSymbols` return an array of `string`.\n\n### Annotations\n\nThe schema generator converts annotations to JSON schema properties.\n\nFor example\n\n```ts\nexport interface Shape {\n    /**\n     * The size of the shape.\n     *\n     * @minimum 0\n     * @TJS-type integer\n     */\n    size: number;\n}\n```\n\nwill be translated to\n\n```json\n{\n    \"$ref\": \"#/definitions/Shape\",\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"definitions\": {\n        \"Shape\": {\n            \"properties\": {\n                \"size\": {\n                    \"description\": \"The size of the shape.\",\n                    \"minimum\": 0,\n                    \"type\": \"integer\"\n                }\n            },\n            \"type\": \"object\"\n        }\n    }\n}\n```\n\nNote that we needed to use `@TJS-type` instead of just `@type` because of an [issue with the typescript compiler](https://github.com/Microsoft/TypeScript/issues/13498).\n\nYou can also override the type of array items, either listing each field in its own annotation or one\nannotation with the full JSON of the spec (for special cases). This replaces the item types that would\nhave been inferred from the TypeScript type of the array elements.\n\nExample:\n\n```ts\nexport interface ShapesData {\n    /**\n     * Specify individual fields in items.\n     *\n     * @items.type integer\n     * @items.minimum 0\n     */\n    sizes: number[];\n\n    /**\n     * Or specify a JSON spec:\n     *\n     * @items {\"type\":\"string\",\"format\":\"email\"}\n     */\n    emails: string[];\n}\n```\n\nTranslation:\n\n```json\n{\n    \"$ref\": \"#/definitions/ShapesData\",\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"definitions\": {\n        \"Shape\": {\n            \"properties\": {\n                \"sizes\": {\n                    \"description\": \"Specify individual fields in items.\",\n                    \"items\": {\n                        \"minimum\": 0,\n                        \"type\": \"integer\"\n                    },\n                    \"type\": \"array\"\n                },\n                \"emails\": {\n                    \"description\": \"Or specify a JSON spec:\",\n                    \"items\": {\n                        \"format\": \"email\",\n                        \"type\": \"string\"\n                    },\n                    \"type\": \"array\"\n                }\n            },\n            \"type\": \"object\"\n        }\n    }\n}\n```\n\nThis same syntax can be used for `contains` and `additionalProperties`.\n\n### `integer` type alias\n\nIf you create a type alias `integer` for `number` it will be mapped to the `integer` type in the generated JSON schema.\n\nExample:\n\n```typescript\ntype integer = number;\ninterface MyObject {\n    n: integer;\n}\n```\n\nNote: this feature doesn't work for generic types & array types, it mainly works in very simple cases.\n\n### `require` a variable from a file\n\n(for requiring typescript files is needed to set argument `tsNodeRegister` to true)\n\nWhen you want to import for example an object or an array into your property defined in annotation, you can use `require`.\n\nExample:\n\n```ts\nexport interface InnerData {\n    age: number;\n    name: string;\n    free: boolean;\n}\n\nexport interface UserData {\n    /**\n     * Specify required object\n     *\n     * @examples require(\"./example.ts\").example\n     */\n    data: InnerData;\n}\n```\n\nfile `example.ts`\n\n```ts\nexport const example: InnerData[] = [{\n  age: 30,\n  name: \"Ben\",\n  free: false\n}]\n```\n\nTranslation:\n\n```json\n{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"properties\": {\n        \"data\": {\n            \"description\": \"Specify required object\",\n            \"examples\": [\n                {\n                    \"age\": 30,\n                    \"name\": \"Ben\",\n                    \"free\": false\n                }\n            ],\n            \"type\": \"object\",\n            \"properties\": {\n                \"age\": { \"type\": \"number\" },\n                \"name\": { \"type\": \"string\" },\n                \"free\": { \"type\": \"boolean\" }\n            },\n            \"required\": [\"age\", \"free\", \"name\"]\n        }\n    },\n    \"required\": [\"data\"],\n    \"type\": \"object\"\n}\n```\n\nAlso you can use `require(\".\").example`, which will try to find exported variable with name 'example' in current file. Or you can use `require(\"./someFile.ts\")`, which will try to use default exported variable from 'someFile.ts'.\n\nNote: For `examples` a required variable must be an array.\n\n## Background\n\nInspired and builds upon [Typson](https://github.com/lbovet/typson/), but typescript-json-schema is compatible with more recent Typescript versions. Also, since it uses the Typescript compiler internally, more advanced scenarios are possible. If you are looking for a library that uses the AST instead of the type hierarchy and therefore better support for type aliases, have a look at [vega/ts-json-schema-generator](https://github.com/vega/ts-json-schema-generator).\n\n## Debugging\n\n`npm run debug -- test/programs/type-alias-single/main.ts --aliasRefs true MyString`\n\nAnd connect via the debugger protocol.\n"
        },
        {
          "name": "api.md",
          "type": "blob",
          "size": 33.5595703125,
          "content": "_Auto-generated file. Updated with NPM deploy. Update manually with 'yarn docs'._\n\n# typescript-json-schema test examples\n\n## [abstract-class](./test/programs/abstract-class)\n\n```ts\nexport abstract class AbstractBase {\n    propA:number;\n    propB:string;\n\n    abstract doNotInclude(): void;\n}\n\n```\n\n\n## [abstract-extends](./test/programs/abstract-extends)\n\n```ts\nimport { AbstractBase } from \"../abstract-class/main\";\n\nclass MyObjectFromAbstract extends AbstractBase {\n    doNotInclude(): void { }\n\n    propB:string;\n    propC:number;\n}\n```\n\n\n## [annotation-default](./test/programs/annotation-default)\n\n```ts\ninterface MyObject {\n  /**\n   * @default true\n   */\n  varBoolean: boolean;\n  /**\n   * @default 123\n   */\n  varInteger: number;\n  /**\n   * @default 3.21\n   */\n  varFloat: number;\n  /**\n   * @default \"foo\"\n   */\n  varString: string;\n  /**\n   * @default [true, false, true]\n   */\n  varBooleanArray: boolean[];\n  /**\n   * @default [1, 2, 3, 4, 5]\n   */\n  varIntegerArray: number[];\n  /**\n   * @default [1.23, 65.21, -123.40, 0, 1000000.0001]\n   */\n  varFloatArray: number[];\n  /**\n   * @default [\"a\", \"b\", \"c\", \"...\"]\n   */\n  varStringArray: string[];\n  /**\n   * @default [true, 123, 3.21, \"foo\"]\n   */\n  varMixedArray: any[];\n}\n```\n\n\n## [annotation-id](./test/programs/annotation-id)\n\n```ts\n/**\n * @$id filled#\n */\ninterface MySubObject {\n    a: boolean;\n}\n\ninterface MyObject {\n    /**\n     * @$id empty#\n     */\n    empty;\n\n    filled: MySubObject;\n}\n```\n\n\n## [annotation-items](./test/programs/annotation-items)\n\n```ts\ninterface MyObject {\n  /**\n   * @items {\"type\":\"integer\"}\n   */\n  a: number[];\n\n  /**\n   * @items {\"type\":\"integer\", \"minimum\":0}\n   */\n  b: number[];\n\n  /**\n   * @items.type integer\n   * @items.minimum 0\n   */\n  c: number[];\n\n  /**\n   * @items.type integer\n   */\n  d: number[];\n\n  /**\n   * @items {\"type\":\"string\", \"format\":\"email\"}\n   */\n  emails: string[];\n\n  /**\n   * @items.type string\n   * @items.format email\n   */\n  emails2: string[];\n\n}\n```\n\n\n## [annotation-ref](./test/programs/annotation-ref)\n\n```ts\ninterface MySubObject {}\n\ninterface MyObject {\n    /**\n     * @$ref http://my-schema.org\n     */\n    externalRef;\n\n    /**\n     * @$ref http://my-schema.org\n     */\n    externalRefOverride: MySubObject;\n}\n```\n\n\n## [annotation-required](./test/programs/annotation-required)\n\n```ts\nimport { MyDefaultObject, MySubObject2 } from \"./main\";\n\nexport const mySubObject2Example: MySubObject2[] = [{\n    bool: true,\n    string: \"string\",\n    object: { prop: 1 }\n}];\n\nconst myDefaultExample: MyDefaultObject[] = [{\n    age: 30,\n    name: \"me\",\n    free: true\n}]\n\nexport default myDefaultExample;\n```\n\n\n## [annotation-required](./test/programs/annotation-required)\n\n```ts\ninterface MySubObject {\n    bool: boolean;\n    string: string;\n    object: object | null;\n    /**\n     * @examples require('./examples.ts').mySubObject2Example\n     */\n    subObject?: MySubObject2;\n}\n\nexport interface MySubObject2 {\n    bool: boolean;\n    string: string;\n    object: object;\n}\n\nexport interface MyDefaultObject {\n  age: number;\n  name: string;\n  free?: boolean;\n}\n\nexport interface MyObject {\n    /**\n     * @examples require(\".\").innerExample\n     */\n    filled: MySubObject;\n    /**\n     * @examples require('./examples.ts')\n     */\n    defaultObject: MyDefaultObject;\n}\n\nexport const innerExample: MySubObject[] = [\n    {\n        bool: true,\n        string: \"string\",\n        object: {}\n    },\n];\n```\n\n\n## [annotation-title](./test/programs/annotation-title)\n\n```ts\n/**\n * @title filled#\n */\ninterface MySubObject {\n    a: boolean;\n}\n\ninterface AnotherSubObject {\n    b: boolean;\n}\n\ninterface MyObject {\n    /**\n     * @title empty#\n     */\n    empty;\n    /**\n     * @title filled\n     */\n    filled: MySubObject;\n    nonTitled: AnotherSubObject;\n}\n```\n\n\n## [annotation-tjs](./test/programs/annotation-tjs)\n\n```ts\n// All of these formats are defined in this specification: http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.3\n\ninterface MyRef {}\n\ninterface MyObject {\n    /**\n     * @TJS-format date-time\n     */\n    dateTime: string;\n\n    /**\n     * @TJS-format email\n     */\n    email: string;\n\n    /**\n     * @TJS-format hostname\n     */\n    hostname: string;\n\n    /**\n     * @TJS-format ipv4\n     */\n    ipv4: string;\n\n    /**\n     * @TJS-format ipv6\n     */\n    ipv6: string;\n\n    /**\n     * @TJS-format uri\n     */\n    uri: string;\n\n    /**\n     * @TJS-format uri-reference\n     */\n    uriReference: string;\n\n    /**\n     * @TJS-format uri-template\n     */\n    uriTemplate: string;\n\n    /**\n     * @TJS-format json-pointer\n     */\n    jsonPointer: string;\n\n    /**\n     * @TJS-pattern ^[a-zA-Z0-9]{4}-abc_123$\n     */\n    regexPattern: string;\n\n    /**\n     * @TJS-pattern ^[a-zA-Z0-9]{4}-abc_123$\n     */\n    regexPatternWithWhitespace: string;\n\n    /**\n     * @TJS-minimum 5\n     */\n    oneCharacter: number;\n\n    /**\n     * @TJS-examples [\"foo\", 1]\n     */\n    examples: string;\n\n    /**\n     * @TJS-hide\n     */\n    booleanAnnotationDefaultValue: string;\n\n    /**\n     * @TJS-hide true\n     */\n    booleanAnnotationWithTrue: string;\n\n    /**\n     * @TJS-hide false\n     */\n    booleanAnnotationWithFalse: string;\n\n    /**\n     * @TJS-ignore\n     */\n    complexWithRefIgnored: MyRef;\n}\n```\n\n\n## [any-unknown](./test/programs/any-unknown)\n\n```ts\nexport interface MyObject {\n    a: any;\n    b: unknown;\n}\n```\n\n\n## [argument-id](./test/programs/argument-id)\n\n```ts\ninterface MyObject {\n    someProp: string;\n    referenceType: ReferenceType;\n}\n\ninterface ReferenceType {\n    reference: true;\n}\n```\n\n\n## [array-and-description](./test/programs/array-and-description)\n\n```ts\nexport interface MyObject {\n  /**\n   * A name\n   */\n  name?: string;\n  description?: string;\n  test: any[];\n}\n```\n\n\n## [array-empty](./test/programs/array-empty)\n\n```ts\ntype MyEmptyArray = [];\n```\n\n\n## [array-readonly](./test/programs/array-readonly)\n\n```ts\nexport type MyReadOnlyArray = ReadonlyArray<number>;\n```\n\n\n## [array-types](./test/programs/array-types)\n\n```ts\ntype MyArray = Array<string | number>;\n```\n\n\n## [builtin-names](./test/programs/builtin-names)\n\n```ts\ndeclare namespace Ext {\n    export class Array {\n    }\n\n    export class Foo {\n        bar: Ext.Array;\n    }\n}\n```\n\n\n## [class-extends](./test/programs/class-extends)\n\n```ts\nclass Base {\n    propA:number;\n}\n\nclass MyObject extends Base {\n    propB:number;\n}\n```\n\n\n## [class-single](./test/programs/class-single)\n\n```ts\nclass MyObject {\n    constructor() {}\n    propA:number;\n    propB:number;\n    doNotInclude(): void {}\n}\n```\n\n\n## [comments](./test/programs/comments)\n\n```ts\n\n/**\n * Description of Vector3D, a type alias to a array of integers with length 3\n * If run without useTypeAliasRef, this comment should be ignored but\n * the other annotations should be inherited\n * @minItems 3\n * @maxItems 3\n */\ntype Vector3D = number[];\n\n/**\n * Description of MyObject, a top level object,\n * which also has a comment that spans\n * multiple lines\n *\n * @additionalProperties false\n * @unsupportedAnnotationThatShouldBeIgnored\n */\ninterface MyObject {\n\n    /**\n     * Description of opacity, a field with min/max values\n     * @minimum 0\n     * @maximum 100\n     */\n    opacity: number;\n\n    /**\n     * Description of field position, of aliased type Vector3D, which should inherit its annotations\n     */\n    position: Vector3D;\n\n    /**\n     * Description of rotation, a field with an anonymous type\n     */\n    rotation: {\n        /**\n         * Description of the value yaw inside an anonymous type, with min/max annotations\n         * @minimum -90\n         * @maximum 90\n         */\n        yaw: number;\n    };\n}\n```\n\n\n## [comments-comment](./test/programs/comments-comment)\n\n```ts\n/**\n * @$comment Object comment\n */\ninterface MyObject {\n  /**\n   * @$comment Property comment\n   */\n  text: string;\n}\n```\n\n\n## [comments-from-lib](./test/programs/comments-from-lib)\n\n```ts\n/**\n * Use this comment\n */\nexport type MyObject = Pick<BigThing, \"prop1\">;\n\n/**\n * Not this comment though\n */\ninterface BigThing {\n  prop1: string;\n  prop2: string;\n};\n```\n\n\n## [comments-imports](./test/programs/comments-imports)\n\n```ts\n/**\n * Description of Color.\n *\n * @pattern ^[0-9a-f]{6}$\n */\nexport type Color = string;\n```\n\n\n## [comments-imports](./test/programs/comments-imports)\n\n```ts\nimport { Color } from \"./color\";\nimport { Text } from \"./text\";\n\n/** Description of MyObject */\nexport interface MyObject {\n    /** Description of MyObject color property. */\n    color: Color;\n\n    /** Description of MyObject text property. */\n    text: Text;\n}\n```\n\n\n## [comments-imports](./test/programs/comments-imports)\n\n```ts\nimport { Color } from \"./color\";\n\n/**\n * Description of Text interface.\n */\nexport interface Text {\n    /** Description of text property. */\n    text: string;\n\n    /** Description of text color property. */\n    color: Color;\n}\n```\n\n\n## [comments-inline-tags](./test/programs/comments-inline-tags)\n\n```ts\n/**\n * This is MyOtherObject\n */\ninterface MyOtherObject {\n  prop1: string;\n}\n\n/**\n * This is MyObject. It extends {@link MyOtherObject} and {@link SomeOtherObject}.\n */\ninterface MyObject extends MyOtherObject {\n  prop2: string;\n}\n```\n\n\n## [comments-override](./test/programs/comments-override)\n\n```ts\n\n/**\n * Type-level description\n * @additionalProperties true\n */\nexport interface MySubObject {\n    value: string;\n}\n\nexport interface MyObject {\n    list: MySubObject[];\n\n    sub1: MySubObject;\n\n    /**\n     * Property-level description\n     * @additionalProperties false\n     */\n    sub2: MySubObject;\n\n    /**\n     * Date property description\n     */\n    date: Date;\n}\n```\n\n\n## [const-as-enum](./test/programs/const-as-enum)\n\n```ts\nexport interface MyObject {\n    reference: true;\n}\n```\n\n\n## [const-keyword](./test/programs/const-keyword)\n\n```ts\nconst fn = <const T>(value: T) =>\n  ({ value });\n\nexport type Object = ReturnType<typeof fn<\"value\">>;\n```\n\n\n## [custom-dates](./test/programs/custom-dates)\n\n```ts\nnamespace foo {\n  export interface Date {\n    day?: number;\n    month?: number;\n    year?: number;\n  }\n\n  export interface Bar {\n    date: Date;\n  }\n}\n```\n\n\n## [dates](./test/programs/dates)\n\n```ts\ntype DateAlias = Date;\n\ninterface MyObject {\n    var1: Date;\n    var2: DateAlias;\n    /**\n     * @format date\n     */\n    var3: Date;\n    /**\n     * @format date\n     */\n    var4: DateAlias;\n}\n```\n\n\n## [default-properties](./test/programs/default-properties)\n\n```ts\ntype Foo = \"a\" | \"b\" | \"c\" | boolean | number;\n\nclass MyObject {\n    varBoolean: Foo = <any> false;\n    varInteger: Foo = <any> 123;\n    varString: Foo = <any> \"123\";\n}\n```\n\n\n## [enums-compiled-compute](./test/programs/enums-compiled-compute)\n\n```ts\nenum Enum {\n  X = 1 << 1,\n  Y = 1 << 2,\n  Z = X | Y,\n  A = 1,\n}\n```\n\n\n## [enums-mixed](./test/programs/enums-mixed)\n\n```ts\nenum Enum {\n    A, // = 0\n    B = 1,\n    C = true as any,\n    D = \"str\" as any,\n    E = null\n}\n\ninterface MyObject {\n  foo: Enum;\n}\n```\n\n\n## [enums-number](./test/programs/enums-number)\n\n```ts\nenum Enum {\n  X = 1,\n  Y = 2\n}\n\ninterface MyObject {\n  foo: Enum;\n}\n```\n\n\n## [enums-number-initialized](./test/programs/enums-number-initialized)\n\n```ts\nenum Enum {\n  X = 10,\n  Y,\n  Z,\n  A = 1,\n}\n```\n\n\n## [enums-string](./test/programs/enums-string)\n\n```ts\nenum Enum {\n    X = \"x\" as any,\n    Y = \"y\" as any,\n    Z = \"123\" as any\n}\n\ninterface MyObject {\n    foo: Enum;\n}\n```\n\n\n## [enums-value-in-interface](./test/programs/enums-value-in-interface)\n\n```ts\nexport enum A {\n  B,\n  C,\n  D,\n};\n\nexport interface MyObject {\n  code: A.B;\n};\n```\n\n\n## [extra-properties](./test/programs/extra-properties)\n\n```ts\nexport interface MyObject {\n    required: string;\n    optional?: number;\n    [name: string]: string|number;\n}\n```\n\n\n## [force-type](./test/programs/force-type)\n\n```ts\n/** @TJS-type number */\nexport class Widget {}\n\nexport interface MyObject {\n    name: string;\n\n    mainWidget: Widget;\n    otherWidgets: Widget[];\n}\n```\n\n\n## [force-type-imported](./test/programs/force-type-imported)\n\n```ts\nimport { Widget } from \"./widget\";\n\nexport interface MyObject {\n    name: string;\n\n    mainWidget: Widget;\n    otherWidgets: Widget[];\n}\n```\n\n\n## [force-type-imported](./test/programs/force-type-imported)\n\n```ts\n/** @TJS-type number */\nexport class Widget {}\n```\n\n\n## [generate-all-types](./test/programs/generate-all-types)\n\n```ts\n\n\ninterface MyInterface {\n\n}\n\nclass MyObject {\n\n}\n\nenum MyEnum {\n    Value = 0\n}\n```\n\n\n## [generic-anonymous](./test/programs/generic-anonymous)\n\n```ts\ninterface MyGeneric<A, B> {\n    a: A;\n    b: B;\n}\n\nexport interface MyObject {\n    value1: MyGeneric<string, number>;\n    value2: MyGeneric<number, string>;\n}\n```\n\n\n## [generic-arrays](./test/programs/generic-arrays)\n\n```ts\nexport interface MyObject {\n    numberArray: Array<number>;\n    stringArray: ReadonlyArray<string>;\n}\n```\n\n\n## [generic-hell](./test/programs/generic-hell)\n\n```ts\nexport interface GenericA<A> {\n    a: A;\n}\nexport interface B {\n    b: number;\n}\nexport interface GenericC<C> {\n    c: C;\n}\n\nexport type SomeAlias<T> = SomeGeneric<T, T>;\nexport interface SomeGeneric<A, B> {\n    a: A;\n    b: B;\n    c: GenericA<A>;\n    d: GenericC<B>;\n}\n\nexport interface MyObject extends GenericC<GenericC<GenericC<GenericA<string>>>>, B {\n    someGeneric: SomeGeneric<1, 2>;\n    someAlias: SomeAlias<\"alias\">;\n}\n```\n\n\n## [generic-multiargs](./test/programs/generic-multiargs)\n\n```ts\nexport interface MyGeneric<A, B> {\n    a: A;\n    b: B;\n}\n\nexport interface MyObject {\n    value1: MyGeneric<string, number>;\n    value2: MyGeneric<number, string>;\n}\n```\n\n\n## [generic-multiple](./test/programs/generic-multiple)\n\n```ts\nexport interface MyGeneric<T> {\n    field: T;\n}\n\nexport interface MyObject {\n    value1: MyGeneric<number>;\n    value2: MyGeneric<string>;\n}\n```\n\n\n## [generic-recursive](./test/programs/generic-recursive)\n\n```ts\nexport interface MyGeneric<A, B> {\n    field: MyGeneric<B, A>;\n}\n\nexport interface MyObject {\n    value: MyGeneric<string, number>;\n}\n```\n\n\n## [generic-simple](./test/programs/generic-simple)\n\n```ts\nexport interface MyGeneric<T> {\n    field: T;\n}\n\nexport interface MyObject {\n    value: MyGeneric<number>;\n}\n```\n\n\n## [ignored-required](./test/programs/ignored-required)\n\n```ts\ninterface MyObject {\n    /**\n     * @ignore\n     */\n    ignored: boolean;\n\n    /**\n     * @ignore\n     */\n    ignoredOptional?: boolean;\n\n    required: boolean;\n    optional?: boolean;\n}\n```\n\n\n## [imports](./test/programs/imports)\n\n```ts\n\n// This file imports \"MyInterface\" from the other 2 files\n// while also declaring a MyInterface type\n\nimport { MyInterface as module1_MyInterface } from \"./module1\";\nimport * as module2 from \"./module2\";\n\nclass MyInterface {\n    fieldInMain: number;\n}\n\nclass MyObject {\n    a: MyInterface;\n    b: module1_MyInterface;\n    c: module2.MyInterface;\n}\n```\n\n\n## [imports](./test/programs/imports)\n\n```ts\n\nexport class MyInterface {\n    fieldInModule1: string;\n}\n\n```\n\n\n## [imports](./test/programs/imports)\n\n```ts\n\nexport class MyInterface {\n    fieldInModule2: number;\n}\n\n```\n\n\n## [interface-extends](./test/programs/interface-extends)\n\n```ts\ninterface Base {\n    propA: number;\n}\n\nexport interface MyObject extends Base {\n    propB: number;\n}\n```\n\n\n## [interface-extra-props](./test/programs/interface-extra-props)\n\n```ts\nexport interface MyObject {\n    required: string;\n    optional?: number;\n    [name: string]: string|number;\n}\n```\n\n\n## [interface-multi](./test/programs/interface-multi)\n\n```ts\ninterface MyObject {\n    subA: MySubObject;\n    subB: MySubObject;\n}\ninterface MySubObject {\n    propA: number;\n    propB: number;\n}\n```\n\n\n## [interface-recursion](./test/programs/interface-recursion)\n\n```ts\ninterface MyObject {\n    propA: number;\n    propB: MyObject;\n}\n```\n\n\n## [interface-single](./test/programs/interface-single)\n\n```ts\nexport interface MyObject {\n    propA: number;\n    propB: number;\n}\n```\n\n\n## [key-in-key-of-multi](./test/programs/key-in-key-of-multi)\n\n```ts\ntype Util = {\n    utilKey1: {\n        utilDeepKey11: string;\n        utilDeepKey12: number;\n    };\n    utilKey2: {\n        utilDeepKey21: boolean;\n        utilDeepKey22: null;\n    };\n};\n\nexport type Main = {\n    [Key in keyof Util]: {\n        [key: string]: Util[Key];\n    };\n};\n```\n\n\n## [key-in-key-of-multi-underscores](./test/programs/key-in-key-of-multi-underscores)\n\n```ts\ntype Util = {\n    __2Underscores: {\n        utilDeepKey2: string;\n    };\n    ___3Underscores: {\n        utilDeepKey3: string;\n    };\n    ____4Underscores: {\n        utilDeepKey4: string;\n    };\n};\n\nexport type Main = {\n    [Key in keyof Util]: {\n        [key: string]: Util[Key];\n    };\n};\n```\n\n\n## [key-in-key-of-single](./test/programs/key-in-key-of-single)\n\n```ts\ntype Util = {\n    utilKey: {\n        utilDeepKey: string;\n    };\n};\n\nexport type Main = {\n    [Key in keyof Util]: {\n        [key: string]: Util[Key];\n    };\n};\n```\n\n\n## [map-types](./test/programs/map-types)\n\n```ts\n\ninterface MyType {}\n\ninterface MyMap1 {\n    [id: string]: MyType;\n}\n\n/**\n * The additionalProperties annotation should be ignored\n * @additionalProperties false\n */\ninterface MyMap2 {\n    [id: string]: (string | number);\n}\n\ntype MyMap3 = Readonly<MyMap2>;\n\ninterface MyObject {\n    map1: MyMap1;\n    map2: MyMap2;\n    map3: MyMap3;\n}\n```\n\n\n## [module-interface-deep](./test/programs/module-interface-deep)\n\n```ts\nmodule MyModule {\n    export interface Def {\n        nest: Def;\n        prev: MyModule.Def;\n        propA: SubModule.HelperA;\n        propB: SubModule.HelperB;\n    }\n    export module SubModule {\n        export interface HelperA {\n            propA: number;\n            propB: HelperB;\n        }\n        export interface HelperB {\n            propA: SubModule.HelperA;\n            propB: Def;\n        }\n    }\n}\n```\n\n\n## [module-interface-single](./test/programs/module-interface-single)\n\n```ts\nmodule MyModule {\n    interface MyObject {\n        propA: number;\n        propB: number;\n    }\n}\n```\n\n\n## [namespace](./test/programs/namespace)\n\n```ts\nexport namespace Types {\n  export const X: \"x\" = \"x\";\n  export const Y: \"y\" = \"y\";\n}\n\nexport type Type = typeof Types.X | typeof Types.Y;\n```\n\n\n## [namespace-deep-1](./test/programs/namespace-deep-1)\n\n```ts\nnamespace RootNamespace {\n    export interface Def {\n        nest: Def;\n        prev: RootNamespace.Def;\n\n        propA: SubNamespace.HelperA;\n        propB: SubNamespace.HelperB;\n    }\n\n    export namespace SubNamespace {\n        export interface HelperA {\n            propA: number;\n            propB: HelperB;\n        }\n        export interface HelperB {\n            propA: SubNamespace.HelperA;\n            propB: Def;\n        }\n    }\n}\n```\n\n\n## [namespace-deep-2](./test/programs/namespace-deep-2)\n\n```ts\nnamespace RootNamespace {\n    export interface Def {\n        nest: Def;\n        prev: RootNamespace.Def;\n\n        propA: SubNamespace.HelperA;\n        propB: SubNamespace.HelperB;\n    }\n\n    export namespace SubNamespace {\n        export interface HelperA {\n            propA: number;\n            propB: HelperB;\n        }\n        export interface HelperB {\n            propA: SubNamespace.HelperA;\n            propB: Def;\n        }\n    }\n}\n```\n\n\n## [never](./test/programs/never)\n\n```ts\nexport interface Never {\n  neverProp: never;\n  propA: string;\n}\n```\n\n\n## [no-ref](./test/programs/no-ref)\n\n```ts\ntype MySubType = {\n    id: string;\n};\n\nexport type MyModule = {\n    address: MySubType & { extraProp: number };\n    address2: MySubType;\n    address3: MySubType;\n};\n```\n\n\n## [no-unrelated-definitions](./test/programs/no-unrelated-definitions)\n\n```ts\nexport interface MyObject {\n  sub: SomeDefinition;\n}\n\ninterface SomeDefinition {\n  is: string;\n}\n\nexport interface MyOtherObject {\n  sub: SomeOtherDefinition;\n}\n\ninterface SomeOtherDefinition {\n  is: string;\n}\n```\n\n\n## [numeric-keys-and-others](./test/programs/numeric-keys-and-others)\n\n```ts\ninterface NumericKeysAndOthers {\n    [key: number]: number;\n    a: string;\n    b: boolean;\n}\n```\n\n\n## [object-numeric-index](./test/programs/object-numeric-index)\n\n```ts\ninterface IndexInterface {\n  [index: number]: number;\n}\n```\n\n\n## [object-numeric-index-as-property](./test/programs/object-numeric-index-as-property)\n\n```ts\ninterface Target {\n  objAnonymous: {\n    [index: number]: number;\n  };\n  objInterface: IndexInterface;\n  indexInType: { [index in number]?: number };\n  indexInInline: { [index in number]: number };\n  indexInPartialType: IndexInPartial;\n  indexInPartialInline: { [index in number]?: number };\n}\ninterface IndexInterface {\n  [index: number]: number;\n}\n\ntype IndexIn = { [index in number]: number };\ntype IndexInPartial = { [index in number]?: number };\n```\n\n\n## [optionals](./test/programs/optionals)\n\n```ts\ninterface MyObject {\n    required:number;\n    optional?:number;\n}\n```\n\n\n## [optionals-derived](./test/programs/optionals-derived)\n\n```ts\ninterface MyBase {\n    baseRequired : number;\n    baseOptional?: number;\n}\n\ninterface MyDerived extends MyBase {\n    derivedRequired : number;\n    derivedOptional?: number;\n}\n```\n\n\n## [private-members](./test/programs/private-members)\n\n```ts\nexport class MyObject {\n    publicMember: string;\n    private privateMember: string;\n}\n```\n\n\n## [prop-override](./test/programs/prop-override)\n\n```ts\nimport type { ObjectId } from './third-party'\n\nexport type MyObject = {\n  /**\n   * @TJS-type string\n   * @description Overrides aliased type definition with this JSDoc if at least TJS-type annotation is present\n   */\n  _id: ObjectId\n}\n```\n\n\n## [prop-override](./test/programs/prop-override)\n\n```ts\n// cannot modify with JSDoc because third-party sources\nexport class ObjectId {}\n```\n\n\n## [satisfies-keyword](./test/programs/satisfies-keyword)\n\n```ts\ninterface Basic {\n    a: string;\n    b: number;\n    c: boolean;\n}\n\nconst myObject = {\n    a: \"a\" as const,\n    b: 1 as const,\n    c: true as const,\n// tslint:disable-next-line:variable-name\n} satisfies Basic;\n\nexport type Specific = typeof myObject;\n```\n\n\n## [strict-null-checks](./test/programs/strict-null-checks)\n\n```ts\n\nclass MyObject {\n     val: number;\n     valNullable: number | null;\n     valUndef: number | undefined;\n     valOpt?: number;\n     valVoid: number | void;\n\n     valTrueOpt?: true;\n     valTrueOrNull: true|null;\n     valTrue: true|true; // twice to check that it will appear only once\n}\n```\n\n\n## [string-literals](./test/programs/string-literals)\n\n```ts\ntype result = \"ok\" | \"fail\" | \"abort\" | \"\";\n\nclass MyObject {\n    foo: result;\n    bar: result | string;\n}\n```\n\n\n## [string-literals-inline](./test/programs/string-literals-inline)\n\n```ts\nclass MyObject {\n    foo: \"ok\" | \"fail\" | \"abort\" | \"\";\n    bar: \"ok\" | \"fail\" | \"abort\" | string;\n}\n```\n\n\n## [string-template-literal](./test/programs/string-template-literal)\n\n```ts\ninterface MyObject {\n  a: `@${string}`,\n  b: `@${number}`,\n  c: `@${bigint}`,\n  d: `@${boolean}`,\n  e: `@${undefined}`,\n  f: `@${null}`,\n  g: `${string}@`,\n  h: `${number}@`,\n  i: `${string}@${number}`,\n  j: `${string}.${string}`,\n}\n```\n\n\n## [symbol](./test/programs/symbol)\n\n```ts\nexport type MyObject = {\n    a: symbol;\n};\n```\n\n\n## [tsconfig](./test/programs/tsconfig)\n\n```ts\n// This file is ignored.\n\nexport interface Excluded {\n    a: string;\n}\n```\n\n\n## [tsconfig](./test/programs/tsconfig)\n\n```ts\n// This file is included by tsconfig.json and --include.\n\nexport interface IncludedAlways {\n    a: string;\n};\n```\n\n\n## [tsconfig](./test/programs/tsconfig)\n\n```ts\n// This file is included by tsconfig.json.\n\nexport interface IncludedOnlyByTsConfig {\n    a: string;\n};\n```\n\n\n## [type-alias-never](./test/programs/type-alias-never)\n\n```ts\nexport type MyNever = never;\n```\n\n\n## [type-alias-or](./test/programs/type-alias-or)\n\n```ts\ninterface A {}\ninterface B {}\n\ntype C = A | B;\n\ninterface MyObject {\n    c: C;\n}\n```\n\n\n## [type-alias-schema-override](./test/programs/type-alias-schema-override)\n\n```ts\ninterface All {}\n\ntype Some = Partial<All>;\n\ninterface MyObject {\n  some?: Some;\n}\n```\n\n\n## [type-alias-single](./test/programs/type-alias-single)\n\n```ts\ntype MyString = string;\n```\n\n\n## [type-alias-single-annotated](./test/programs/type-alias-single-annotated)\n\n```ts\n/**\n * This is a description\n * @pattern ^mystring-[a-zA-Z0-9]+$\n * @minLength 10\n * @maxLength 24\n */\ntype MyString = string;\n```\n\n\n## [type-alias-undefined](./test/programs/type-alias-undefined)\n\n```ts\nexport type MyUndefined = undefined;\n```\n\n\n## [type-aliases](./test/programs/type-aliases)\n\n```ts\n/**\n * My string\n */\ntype MyString = string;\n\n/**\n * My type alias\n */\ntype MyAlias = MySubObject;\n\n/**\n * My sub object\n */\ninterface MySubObject {\n    propA: number;\n    propB: number;\n}\n\n/**\n * My Object\n */\ninterface MyObject {\n    primitive: MyString;\n    object: MySubObject;\n    alias: MyAlias;\n}\n```\n\n\n## [type-aliases-alias-ref](./test/programs/type-aliases-alias-ref)\n\n```ts\n\ninterface MyObject {\n    prop: number;\n}\n\ntype MyAlias = MyObject;\n```\n\n\n## [type-aliases-alias-ref-topref](./test/programs/type-aliases-alias-ref-topref)\n\n```ts\n\ninterface MyObject {\n    prop: number;\n}\n\ntype MyAlias = MyObject;\n```\n\n\n## [type-aliases-anonymous](./test/programs/type-aliases-anonymous)\n\n```ts\nexport type MyExportString = string;\ntype MyPrivateString = string;\n\nexport interface MyObject {\n    export: MyExportString;\n    private: MyPrivateString;\n}\n```\n\n\n## [type-aliases-fixed-size-array](./test/programs/type-aliases-fixed-size-array)\n\n```ts\ntype MyFixedSizeArray = [string, number];\n\n```\n\n\n## [type-aliases-local-namespace](./test/programs/type-aliases-local-namespace)\n\n```ts\nnamespace A {\n    export interface A { a: any; }\n}\nnamespace B {\n    export interface B { b: any; }\n}\nnamespace C {\n    import A = B.B;\n    export interface C { c: A; }\n}\nnamespace D {\n    import A = C.C;\n    export interface D { d: A; }\n}\n\nexport interface MyObject extends D.D {}\n```\n\n\n## [type-aliases-local-namsepace](./test/programs/type-aliases-local-namsepace)\n\n```ts\nnamespace A {\n    export interface A {a: any;}\n}\nnamespace B {\n    export interface B {b: any;}\n}\nnamespace C {\n    import A = B.B;\n    export interface C {c: A;}\n}\nnamespace D {\n    import A = C.C;\n    export interface D {d: A;}\n}\n\ninterface MyObject extends D.D {}\n```\n\n\n## [type-aliases-mixed](./test/programs/type-aliases-mixed)\n\n```ts\nexport type MyString = string;\n\nexport interface MySubObject {\n    propA: number;\n    propB: number;\n}\n\nexport interface MyObject {\n    primitive: MyString;\n    object: MySubObject;\n}\n```\n\n\n## [type-aliases-multitype-array](./test/programs/type-aliases-multitype-array)\n\n```ts\n\ntype BasicArray = (string | number)[];\n\ninterface MyObject {\n    array: BasicArray;\n}\n\ntype MyArray = (string | MyObject)[];\n```\n\n\n## [type-aliases-object](./test/programs/type-aliases-object)\n\n```ts\n\nexport interface MyObject {\n    number: number;\n    string: string;\n}\n\nexport type MyAlias = MyObject;\n```\n\n\n## [type-aliases-partial](./test/programs/type-aliases-partial)\n\n```ts\nexport interface Foo {\n    x: number;\n    y: number;\n}\n\nexport interface Bar {\n    a: number;\n    b: number;\n}\n\nexport interface MyObject {\n    foo: Partial<Foo>;\n    bar: Partial<Bar>;\n}\n```\n\n\n## [type-aliases-primitive](./test/programs/type-aliases-primitive)\n\n```ts\nexport type MyString = string;\n```\n\n\n## [type-aliases-recursive-alias-topref](./test/programs/type-aliases-recursive-alias-topref)\n\n```ts\n\ninterface MyObject {\n    alias: MyAlias;\n    self: MyObject;\n}\n\ntype MyAlias = MyObject;\n```\n\n\n## [type-aliases-recursive-anonymous](./test/programs/type-aliases-recursive-anonymous)\n\n```ts\ninterface MyObject {\n    alias: MyAlias;\n    self: MyObject;\n}\n\nexport type MyAlias = MyObject;\n```\n\n\n## [type-aliases-recursive-export](./test/programs/type-aliases-recursive-export)\n\n```ts\nexport interface MyObject {\n    alias: MyAlias;\n    self: MyObject;\n}\n\nexport type MyAlias = MyObject;\n```\n\n\n## [type-aliases-recursive-object-topref](./test/programs/type-aliases-recursive-object-topref)\n\n```ts\n\ninterface MyObject {\n    alias: MyAlias;\n    self: MyObject;\n}\n\ntype MyAlias = MyObject;\n```\n\n\n## [type-aliases-tuple](./test/programs/type-aliases-tuple)\n\n```ts\nexport type MyTuple = [string, number];\n```\n\n\n## [type-aliases-tuple-of-variable-length](./test/programs/type-aliases-tuple-of-variable-length)\n\n```ts\nexport type MyTuple = [string, number, boolean?];\n```\n\n\n## [type-aliases-tuple-with-rest-element](./test/programs/type-aliases-tuple-with-rest-element)\n\n```ts\nexport type MyTuple = [string, ...number[]];\n```\n\n\n## [type-aliases-union](./test/programs/type-aliases-union)\n\n```ts\n\ntype BasicArray = (string | number)[];\n\nexport interface MyObject {\n    array: BasicArray;\n}\n\nexport type MyUnion = (string | MyObject)[];\n```\n\n\n## [type-aliases-union-namespace](./test/programs/type-aliases-union-namespace)\n\n```ts\n\nexport namespace Cardinal {\n    export const NORTH: \"north\" = \"north\";\n    export const SOUTH: \"south\" = \"south\";\n    export const EAST: \"east\" = \"east\";\n    export const WEST: \"west\" = \"west\";\n}\n\nexport type Cardinal = typeof Cardinal.NORTH | typeof Cardinal.SOUTH | typeof Cardinal.EAST | typeof Cardinal.WEST;\n\nexport interface MyModel {\n    direction: Cardinal;\n}\n```\n\n\n## [type-anonymous](./test/programs/type-anonymous)\n\n```ts\n interface MyObject {\n    FieldWithAnonType: {\n        SubfieldA: number;\n        SubfieldB: (string | number);\n        SubfieldC: {\n            SubsubfieldA: number[];\n        }\n    };\n}\n```\n\n\n## [type-default-number-as-integer](./test/programs/type-default-number-as-integer)\n\n```ts\ninterface MyObject {\n    as_integer: number;\n\n    /** @TJS-type number */\n    as_number: number;\n}\n```\n\n\n## [type-function](./test/programs/type-function)\n\n```ts\ninterface MyObject {\n    myFunction: Function;\n}\n```\n\n\n## [type-globalThis](./test/programs/type-globalThis)\n\n```ts\nexport type Test = typeof globalThis;\n```\n\n\n## [type-intersection](./test/programs/type-intersection)\n\n```ts\ninterface Type1 {\n    value1: string;\n    value2: number;\n}\ninterface Type2 {\n    value2: number;\n    value3: boolean;\n}\n\ninterface MyObject {\n    value: Type1 & Type2;\n}\n```\n\n\n## [type-intersection-recursive](./test/programs/type-intersection-recursive)\n\n```ts\ninterface ChildFoo {\n}\n\ninterface Foo {\n    readonly childFoos: Foo | ChildFoo;\n}\n```\n\n\n## [type-intersection-recursive-no-additional](./test/programs/type-intersection-recursive-no-additional)\n\n```ts\ntype MyRecursiveNode = {\n    next?: MyNode;\n}\n\ntype MyNode = {\n    val: string;\n} & MyRecursiveNode;\n\ntype MyLinkedList = MyNode;\n```\n\n\n## [type-literals](./test/programs/type-literals)\n\n```ts\ntype MyObject = {\n    param1: \"1\" | \"2\" | \"3\";\n    param2: \"1\" | \"2\" | 3 | true;\n    /** @enum {string} */\n    param3: \"1\" | \"2\" | \"3\";\n    /** @enum {unknown} */\n    param4: \"1\" | \"2\" | 3 | true;\n};\n```\n\n\n## [type-mapped-types](./test/programs/type-mapped-types)\n\n```ts\ntype Keys = \"str1\" | \"str2\";\n\ntype MyMappedType = {\n  [key in Keys]: string;\n};\n```\n\n\n## [type-no-aliases-recursive-topref](./test/programs/type-no-aliases-recursive-topref)\n\n```ts\n\ninterface MyObject {\n    alias: MyAlias;\n    self: MyObject;\n}\n\ntype MyAlias = MyObject;\n```\n\n\n## [type-nullable](./test/programs/type-nullable)\n\n```ts\n\n/** @nullable */\ntype MyType1 = string;\n\n/** @nullable */\ntype MyType2 = string | number;\n\n/** @nullable */\ntype MyType3 = string | number[];\n\n/** @nullable */\ntype MyType4 = number[];\n\ntype Ref = { foo: number };\n\n/** @nullable */\ntype MyType5 = Ref;\n\ninterface MyType6 {};\n\ninterface MyObject {\n    var1: MyType1;\n    var2: MyType2;\n    var3: MyType3;\n    var4: MyType4;\n    var5: MyType5;\n\n    /**\n     * @nullable\n     */\n    var6: MyType6;\n    var7: MyType6;\n}\n```\n\n\n## [type-primitives](./test/programs/type-primitives)\n\n```ts\n/* tslint:disable:no-inferrable-types */\n\n// Special type, should not appear in the schema\ntype integer = number;\n\nclass MyObject {\n\n    boolean1: boolean     = true;\n\n    number1: number       = 1;\n\n    /** @TJS-type integer */\n    integer1: number      = 1;\n    integer2: integer     = 1;\n\n    string1: string       = \"defaultValue\";\n\n    array1: Array<any>    = null;\n    array2: Array<number> = null;\n\n    object1: any          = null;\n    object2: {}           = null;\n    object3: object       = null;\n\n}\n```\n\n\n## [type-recursive](./test/programs/type-recursive)\n\n```ts\n/**\n * A recursive type\n */\nexport type TestChildren = TestChild | Array<TestChild | TestChildren>;\n\ninterface TestChild {\n    type: string;\n}\n```\n\n\n## [type-union](./test/programs/type-union)\n\n```ts\n\n// Simple union (generates \"type\": [...])\ntype MyType1 = string | number;\n\n// Non-simple union (generates a \"oneOf\"/\"anyOf\")\ntype MyType2 = string | number[];\n\ninterface MyObject {\n    var1: MyType1;\n    var2: MyType2;\n}\n```\n\n\n## [type-union-strict-null-keep-description](./test/programs/type-union-strict-null-keep-description)\n\n```ts\n/**\n * Description of InnerObject.\n */\ntype InnerObject = {\n\t/**\n\t * Description of foo.\n\t */\n\tfoo: string;\n};\n\n/**\n * Description of MyObject.\n */\ntype MyObject = {\n\n\tinner1?: InnerObject;\n\n\t/**\n\t * Override description.\n\t */\n\tinner2?: InnerObject;\n};\n```\n\n\n## [type-union-tagged](./test/programs/type-union-tagged)\n\n```ts\n\ninterface Square {\n    kind: \"square\";\n    size: number;\n}\n\ninterface Rectangle {\n    kind: \"rectangle\";\n    width: number;\n    height: number;\n}\n\ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n\ntype Shape = Square | Rectangle | Circle;\n```\n\n\n## [typeof-keyword](./test/programs/typeof-keyword)\n\n```ts\ninterface MyObject {\n  foo: () => string;\n}\n```\n\n\n## [undefined-property](./test/programs/undefined-property)\n\n```ts\nexport type MyObject = {\n    a: string;\n    b: undefined;\n};\n```\n\n\n## [unique-names](./test/programs/unique-names)\n\n```ts\nimport \"./other\";\n\nclass MyObject {\n  is: \"MyObject_1\";\n}\n```\n\n\n## [unique-names](./test/programs/unique-names)\n\n```ts\nclass MyObject {\n  is: \"MyObject_2\";\n}\n```\n\n\n## [unique-names-multiple-subdefinitions](./test/programs/unique-names-multiple-subdefinitions)\n\n```ts\nimport \"./other\";\n\nclass SubObject {\n  is: \"SubObject_1\";\n}\n\nclass MyObject {\n  sub: SubObject;\n}\n```\n\n\n## [unique-names-multiple-subdefinitions](./test/programs/unique-names-multiple-subdefinitions)\n\n```ts\nclass SubObject {\n  is: \"SubObject_2\";\n}\n```\n\n\n## [user-symbols](./test/programs/user-symbols)\n\n```ts\nexport interface Context {\n  ip: string;\n}\n```\n\n\n## [user-validation-keywords](./test/programs/user-validation-keywords)\n\n```ts\nexport interface MyObject {\n  /**\n   * Must be 'first' or 'last'\n   *\n   * @minLength 1\n   * @chance {\n   *   \"pickone\": [ [ \"first\", \"last\" ] ]\n   * }\n   * @ignoreThis 2\n   * @important\n   */\n  name: string;\n}\n```\n\n\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 2.1533203125,
          "content": "{\n  \"name\": \"typescript-json-schema\",\n  \"version\": \"0.65.1\",\n  \"description\": \"typescript-json-schema generates JSON Schema files from your Typescript sources\",\n  \"main\": \"dist/typescript-json-schema.js\",\n  \"typings\": \"dist/typescript-json-schema.d.ts\",\n  \"bin\": {\n    \"typescript-json-schema\": \"./bin/typescript-json-schema\"\n  },\n  \"author\": \"Yousef El-Dardiry and Dominik Moritz\",\n  \"contributors\": [\n    {\n      \"name\": \"Yousef El-Dardiry\",\n      \"email\": \"yousef@tweetbeam.com\",\n      \"url\": \"http://www.twitter.com/yousefed\"\n    },\n    {\n      \"name\": \"Dominik Moritz\",\n      \"email\": \"domoritz@gmail.com\",\n      \"url\": \"https://www.domoritz.de/\"\n    },\n    {\n      \"name\": \"Vladimir Krivosheev\",\n      \"email\": \"develar@gmail.com\"\n    },\n    {\n      \"name\": \"Fabian Pirklbauer\",\n      \"email\": \"hi@fabiandev.io\"\n    }\n  ],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git@github.com:YousefED/typescript-json-schema.git\"\n  },\n  \"license\": \"BSD-3-Clause\",\n  \"keywords\": [\n    \"typescript\",\n    \"json\",\n    \"forms\",\n    \"jsonschema\",\n    \"schema\"\n  ],\n  \"dependencies\": {\n    \"@types/json-schema\": \"^7.0.9\",\n    \"@types/node\": \"^18.11.9\",\n    \"glob\": \"^7.1.7\",\n    \"path-equal\": \"^1.2.5\",\n    \"safe-stable-stringify\": \"^2.2.0\",\n    \"ts-node\": \"^10.9.1\",\n    \"typescript\": \"~5.5.0\",\n    \"yargs\": \"^17.1.1\"\n  },\n  \"devDependencies\": {\n    \"@types/chai\": \"^4.2.21\",\n    \"@types/glob\": \"^7.1.4\",\n    \"@types/mocha\": \"^9.0.0\",\n    \"ajv\": \"^8.6.3\",\n    \"ajv-formats\": \"^2.1.1\",\n    \"chai\": \"^4.3.4\",\n    \"mocha\": \"^9.1.3\",\n    \"prettier\": \"^2.4.1\",\n    \"source-map-support\": \"^0.5.20\",\n    \"tslint\": \"^6.1.3\"\n  },\n  \"scripts\": {\n    \"prepare\": \"tsc && yarn docs\",\n    \"test\": \"tsc && mocha -t 5000 --require source-map-support/register dist/test\",\n    \"debug\": \"node --inspect=19248 --inspect-brk -r ts-node/register typescript-json-schema-cli.ts\",\n    \"docs\": \"./update-docs.js\",\n    \"run\": \"ts-node typescript-json-schema-cli.ts\",\n    \"build\": \"tsc\",\n    \"lint\": \"tslint --project tsconfig.json -c tslint.json --exclude '**/*.d.ts'\",\n    \"style\": \"prettier --write *.js *.ts test/*.ts\",\n    \"dev\": \"tsc -w\",\n    \"test:dev\": \"mocha -t 5000 --watch --require source-map-support/register dist/test\"\n  }\n}\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tsconfig.json",
          "type": "blob",
          "size": 0.8935546875,
          "content": "{\n    \"compilerOptions\": {\n        \"target\": \"es5\",\n        \"module\": \"commonjs\",\n        \"moduleResolution\": \"node\",\n        \"outDir\": \"dist\",\n        \"isolatedModules\": false,\n        \"experimentalDecorators\": true,\n        \"emitDecoratorMetadata\": true,\n        \"declaration\": true,\n        \"noImplicitAny\": true,\n        \"strictNullChecks\": true,\n        \"noImplicitReturns\": true,\n        \"noFallthroughCasesInSwitch\": true,\n        \"noUnusedLocals\": true,\n        \"noUnusedParameters\": true,\n        \"removeComments\": true,\n        \"noLib\": false,\n        \"preserveConstEnums\": true,\n        \"sourceMap\": true,\n        \"typeRoots\" : [\"node_modules/@types\"],\n    },\n    \"include\": [\n        \"**/*.ts\",\n        \"node_modules/@types/**/*.d.ts\"\n    ],\n    \"exclude\": [\n        \"node_modules\",\n        \"example\",\n        \"test/programs\",\n        \"dist\"\n    ],\n    \"compileOnSave\": true,\n    \"buildOnSave\": false\n}\n"
        },
        {
          "name": "tslint.json",
          "type": "blob",
          "size": 1.3896484375,
          "content": "{\n  \"rules\": {\n    \"ban\": true,\n    \"class-name\": true,\n    \"eofline\": true,\n    \"indent\": [true, \"spaces\"],\n    \"comment-format\": [true, \"check-space\"],\n    \"curly\": true,\n    \"forin\": true,\n    \"label-position\": true,\n    \"no-arg\": true,\n    \"no-any\": false,\n    \"jsdoc-format\": true,\n    \"semicolon\": [true, \"always\"],\n    \"no-duplicate-variable\": true,\n    \"no-consecutive-blank-lines\": [false, 2],\n    \"no-console\": [\n      true,\n      \"debug\",\n      \"info\",\n      \"time\",\n      \"timeEnd\",\n      \"trace\"\n    ],\n    \"no-debugger\": true,\n    \"no-eval\": true,\n    \"no-inferrable-types\": [true, \"ignore-params\"],\n    \"no-shadowed-variable\": true,\n    \"no-string-literal\": false,\n    \"no-trailing-whitespace\": true,\n    \"no-unused-expression\": true,\n    \"one-line\": [\n      true,\n      \"check-open-brace\",\n      \"check-catch\",\n      \"check-else\",\n      \"check-whitespace\"\n    ],\n    \"typedef-whitespace\": [\n      true,\n      {\n        \"call-signature\": \"nospace\",\n        \"index-signature\": \"nospace\",\n        \"parameter\": \"nospace\",\n        \"property-declaration\": \"nospace\",\n        \"variable-declaration\": \"nospace\"\n      }\n    ],\n    \"no-switch-case-fall-through\": true,\n    \"quotemark\": [true, \"double\", \"avoid-escape\"],\n    \"triple-equals\": [true, \"allow-null-check\"],\n    \"variable-name\": [true, \"check-format\", \"allow-leading-underscore\", \"ban-keywords\"],\n    \"object-literal-key-quotes\": [true, \"as-needed\"]\n  }\n}\n"
        },
        {
          "name": "typescript-json-schema-cli.ts",
          "type": "blob",
          "size": 5.279296875,
          "content": "import { exec, getDefaultArgs } from \"./typescript-json-schema\";\n\nexport function run() {\n    var helpText = \"Usage: typescript-json-schema <path-to-typescript-files-or-tsconfig> <type>\";\n    const defaultArgs = getDefaultArgs();\n\n    // prettier-ignore\n    var args = require(\"yargs\")\n        .usage(helpText)\n        .demand(2)\n        .boolean(\"refs\").default(\"refs\", defaultArgs.ref)\n            .describe(\"refs\", \"Create shared ref definitions.\")\n        .boolean(\"aliasRefs\").default(\"aliasRefs\", defaultArgs.aliasRef)\n            .describe(\"aliasRefs\", \"Create shared ref definitions for the type aliases.\")\n        .boolean(\"topRef\").default(\"topRef\", defaultArgs.topRef)\n            .describe(\"topRef\", \"Create a top-level ref definition.\")\n        .boolean(\"titles\").default(\"titles\", defaultArgs.titles)\n            .describe(\"titles\", \"Creates titles in the output schema.\")\n        .boolean(\"defaultProps\").default(\"defaultProps\", defaultArgs.defaultProps)\n            .describe(\"defaultProps\", \"Create default properties definitions.\")\n        .boolean(\"noExtraProps\").default(\"noExtraProps\", defaultArgs.noExtraProps)\n            .describe(\"noExtraProps\", \"Disable additional properties in objects by default.\")\n        .boolean(\"propOrder\").default(\"propOrder\", defaultArgs.propOrder)\n            .describe(\"propOrder\", \"Create property order definitions.\")\n        .boolean(\"useTypeOfKeyword\").default(\"useTypeOfKeyword\", defaultArgs.typeOfKeyword)\n            .describe(\"useTypeOfKeyword\", \"Use typeOf keyword (https://goo.gl/DC6sni) for functions.\")\n        .boolean(\"required\").default(\"required\", defaultArgs.required)\n            .describe(\"required\", \"Create required array for non-optional properties.\")\n        .boolean(\"strictNullChecks\").default(\"strictNullChecks\", defaultArgs.strictNullChecks)\n            .describe(\"strictNullChecks\", \"Make values non-nullable by default.\")\n        .boolean(\"esModuleInterop\").default(\"esModuleInterop\", defaultArgs.esModuleInterop)\n            .describe(\"esModuleInterop\", \"Use esModuleInterop when loading typescript modules.\")\n        .boolean(\"skipLibCheck\").default(\"skipLibCheck\", defaultArgs.skipLibCheck)\n            .describe(\"skipLibCheck\", \"Use skipLibCheck when loading typescript modules.\")\n        .boolean(\"experimentalDecorators\").default(\"experimentalDecorators\", defaultArgs.experimentalDecorators)\n            .describe(\"skipLibCheck\", \"Use experimentalDecorators when loading typescript modules.\")\n        .boolean(\"ignoreErrors\").default(\"ignoreErrors\", defaultArgs.ignoreErrors)\n            .describe(\"ignoreErrors\", \"Generate even if the program has errors.\")\n        .alias(\"out\", \"o\")\n            .describe(\"out\", \"The output file, defaults to using stdout\")\n        .array(\"validationKeywords\").default(\"validationKeywords\", defaultArgs.validationKeywords)\n            .describe(\"validationKeywords\", \"Provide additional validation keywords to include.\")\n        .boolean(\"excludePrivate\").default(\"excludePrivate\", defaultArgs.excludePrivate)\n            .describe(\"excludePrivate\", \"Exclude private members from the schema.\")\n        .boolean(\"uniqueNames\").default(\"uniqueNames\", defaultArgs.uniqueNames)\n            .describe(\"uniqueNames\", \"Use unique names for type symbols.\")\n        .array(\"include\").default(\"*\", defaultArgs.include)\n            .describe(\"include\", \"Further limit tsconfig to include only matching files.\")\n        .boolean(\"rejectDateType\").default(\"rejectDateType\", defaultArgs.rejectDateType)\n            .describe(\"rejectDateType\", \"Rejects Date fields in type definitions.\")\n        .string(\"id\").default(\"id\", defaultArgs.id)\n            .describe(\"id\", \"ID of schema.\")\n        .option(\"defaultNumberType\").choices(\"defaultNumberType\", [\"number\", \"integer\"])\n            .default(\"defaultNumberType\", defaultArgs.defaultNumberType)\n            .describe(\"defaultNumberType\", \"Default number type.\")\n        .boolean(\"tsNodeRegister\").default(\"tsNodeRegister\", defaultArgs.tsNodeRegister)\n            .describe(\"tsNodeRegister\", \"Use ts-node/register (needed for requiring typescript files).\")\n        .boolean(\"constAsEnum\").default(\"constAsEnum\", defaultArgs.constAsEnum)\n            .describe(\"constAsEnum\", \"Use enums with a single value when declaring constants. Needed for OpenAPI compatibility\")\n        .argv;\n\n    exec(args._[0], args._[1], {\n        ref: args.refs,\n        aliasRef: args.aliasRefs,\n        topRef: args.topRef,\n        titles: args.titles,\n        defaultProps: args.defaultProps,\n        noExtraProps: args.noExtraProps,\n        propOrder: args.propOrder,\n        typeOfKeyword: args.useTypeOfKeyword,\n        required: args.required,\n        strictNullChecks: args.strictNullChecks,\n        esModuleInterop: args.esModuleInterop,\n        skipLibCheck: args.skipLibCheck,\n        experimentalDecorators: args.experimentalDecorators,\n        ignoreErrors: args.ignoreErrors,\n        out: args.out,\n        validationKeywords: args.validationKeywords,\n        include: args.include,\n        excludePrivate: args.excludePrivate,\n        uniqueNames: args.uniqueNames,\n        rejectDateType: args.rejectDateType,\n        id: args.id,\n        defaultNumberType: args.defaultNumberType,\n        tsNodeRegister: args.tsNodeRegister,\n        constAsEnum: args.constAsEnum,\n    });\n}\n\nif (typeof window === \"undefined\" && require.main === module) {\n    run();\n}\n"
        },
        {
          "name": "typescript-json-schema.ts",
          "type": "blob",
          "size": 71.6416015625,
          "content": "import * as glob from \"glob\";\nimport { stringify } from \"safe-stable-stringify\";\nimport * as path from \"path\";\nimport { createHash } from \"crypto\";\nimport * as ts from \"typescript\";\nimport { JSONSchema7, JSONSchema7TypeName } from \"json-schema\";\nimport { pathEqual } from \"path-equal\";\nexport { Program, CompilerOptions, Symbol } from \"typescript\";\n\nconst vm = require(\"vm\");\n\nconst REGEX_FILE_NAME_OR_SPACE = /(\\bimport\\(\".*?\"\\)|\".*?\")\\.| /g;\nconst REGEX_TSCONFIG_NAME = /^.*\\.json$/;\nconst REGEX_TJS_JSDOC = /^-([\\w]+)\\s+(\\S|\\S[\\s\\S]*\\S)\\s*$/g;\nconst REGEX_GROUP_JSDOC = /^[.]?([\\w]+)\\s+(\\S|\\S[\\s\\S]*\\S)\\s*$/g;\n/**\n * Resolve required file, his path and a property name,\n *      pattern: require([file_path]).[property_name]\n *\n * the part \".[property_name]\" is optional in the regex\n *\n * will match:\n *\n *      require('./path.ts')\n *      require('./path.ts').objectName\n *      require(\"./path.ts\")\n *      require(\"./path.ts\").objectName\n *      require('@module-name')\n *\n *      match[2] = file_path (a path to the file with quotes)\n *      match[3] = (optional) property_name (a property name, exported in the file)\n *\n * for more details, see tests/require.test.ts\n */\nconst REGEX_REQUIRE = /^(\\s+)?require\\((\\'@?[a-zA-Z0-9.\\/_-]+\\'|\\\"@?[a-zA-Z0-9.\\/_-]+\\\")\\)(\\.([a-zA-Z0-9_$]+))?(\\s+|$)/;\nconst NUMERIC_INDEX_PATTERN = \"^[0-9]+$\";\n\nexport function getDefaultArgs(): Args {\n    return {\n        ref: true,\n        aliasRef: false,\n        topRef: false,\n        titles: false,\n        defaultProps: false,\n        noExtraProps: false,\n        propOrder: false,\n        typeOfKeyword: false,\n        required: false,\n        strictNullChecks: false,\n        esModuleInterop: false,\n        skipLibCheck: false,\n        experimentalDecorators: true,\n        ignoreErrors: false,\n        out: \"\",\n        validationKeywords: [],\n        include: [],\n        excludePrivate: false,\n        uniqueNames: false,\n        rejectDateType: false,\n        id: \"\",\n        defaultNumberType: \"number\",\n        tsNodeRegister: false,\n        constAsEnum: false,\n    };\n}\n\nexport type ValidationKeywords = {\n    [prop: string]: boolean;\n};\n\nexport type Args = {\n    ref: boolean;\n    aliasRef: boolean;\n    topRef: boolean;\n    titles: boolean;\n    defaultProps: boolean;\n    noExtraProps: boolean;\n    propOrder: boolean;\n    typeOfKeyword: boolean;\n    required: boolean;\n    strictNullChecks: boolean;\n    esModuleInterop: boolean;\n    skipLibCheck: boolean;\n    ignoreErrors: boolean;\n    experimentalDecorators: boolean;\n    out: string;\n    validationKeywords: string[];\n    include: string[];\n    excludePrivate: boolean;\n    uniqueNames: boolean;\n    rejectDateType: boolean;\n    id: string;\n    defaultNumberType: \"number\" | \"integer\";\n    tsNodeRegister: boolean;\n    constAsEnum: boolean;\n};\n\nexport type PartialArgs = Partial<Args>;\n\nexport type PrimitiveType = number | boolean | string | null;\n\ntype MetaDefinitionFields = \"ignore\";\ntype RedefinedFields =\n    | \"items\"\n    | \"additionalItems\"\n    | \"contains\"\n    | \"properties\"\n    | \"patternProperties\"\n    | \"additionalProperties\"\n    | \"dependencies\"\n    | \"propertyNames\"\n    | \"if\"\n    | \"then\"\n    | \"else\"\n    | \"allOf\"\n    | \"anyOf\"\n    | \"oneOf\"\n    | \"not\"\n    | \"definitions\";\nexport type DefinitionOrBoolean = Definition | boolean;\nexport interface Definition extends Omit<JSONSchema7, RedefinedFields> {\n    // Non-standard fields\n    propertyOrder?: string[];\n    defaultProperties?: string[];\n    typeof?: \"function\";\n\n    // Fields that must be redefined because they make use of this definition itself\n    items?: DefinitionOrBoolean | DefinitionOrBoolean[];\n    additionalItems?: DefinitionOrBoolean;\n    contains?: JSONSchema7;\n    properties?: {\n        [key: string]: DefinitionOrBoolean;\n    };\n    patternProperties?: {\n        [key: string]: DefinitionOrBoolean;\n    };\n    additionalProperties?: DefinitionOrBoolean;\n    dependencies?: {\n        [key: string]: DefinitionOrBoolean | string[];\n    };\n    propertyNames?: DefinitionOrBoolean;\n    if?: DefinitionOrBoolean;\n    then?: DefinitionOrBoolean;\n    else?: DefinitionOrBoolean;\n    allOf?: DefinitionOrBoolean[];\n    anyOf?: DefinitionOrBoolean[];\n    oneOf?: DefinitionOrBoolean[];\n    not?: DefinitionOrBoolean;\n    definitions?: {\n        [key: string]: DefinitionOrBoolean;\n    };\n}\n\n/** A looser Definition type that allows for indexing with arbitrary strings. */\ntype DefinitionIndex = { [key: string]: Definition[keyof Definition] };\n\nexport type SymbolRef = {\n    name: string;\n    typeName: string;\n    fullyQualifiedName: string;\n    symbol: ts.Symbol;\n};\n\nfunction extend(target: any, ..._: any[]): any {\n    if (target == null) {\n        // TypeError if undefined or null\n        throw new TypeError(\"Cannot convert undefined or null to object\");\n    }\n\n    const to = Object(target);\n\n    for (var index = 1; index < arguments.length; index++) {\n        const nextSource = arguments[index];\n\n        if (nextSource != null) {\n            // Skip over if undefined or null\n            for (const nextKey in nextSource) {\n                // Avoid bugs when hasOwnProperty is shadowed\n                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                    to[nextKey] = nextSource[nextKey];\n                }\n            }\n        }\n    }\n    return to;\n}\n\nfunction unique(arr: string[]): string[] {\n    const temp: Record<string, true> = {};\n    for (const e of arr) {\n        temp[e] = true;\n    }\n    const r: string[] = [];\n    for (const k in temp) {\n        // Avoid bugs when hasOwnProperty is shadowed\n        if (Object.prototype.hasOwnProperty.call(temp, k)) {\n            r.push(k);\n        }\n    }\n    return r;\n}\n\n/**\n * Resolve required file\n */\nfunction resolveRequiredFile(symbol: ts.Symbol, key: string, fileName: string, objectName: string): any {\n    const sourceFile = getSourceFile(symbol);\n    const requiredFilePath = /^[.\\/]+/.test(fileName)\n        ? fileName === \".\"\n            ? path.resolve(sourceFile.fileName)\n            : path.resolve(path.dirname(sourceFile.fileName), fileName)\n        : fileName;\n    const requiredFile = require(requiredFilePath);\n    if (!requiredFile) {\n        throw Error(\"Required: File couldn't be loaded\");\n    }\n    const requiredObject = objectName ? requiredFile[objectName] : requiredFile.default;\n    if (requiredObject === undefined) {\n        throw Error(\"Required: Variable is undefined\");\n    }\n    if (typeof requiredObject === \"function\") {\n        throw Error(\"Required: Can't use function as a variable\");\n    }\n    if (key === \"examples\" && !Array.isArray(requiredObject)) {\n        throw Error(\"Required: Variable isn't an array\");\n    }\n    return requiredObject;\n}\n\nexport function regexRequire(value: string) {\n    return REGEX_REQUIRE.exec(value);\n}\n\n/**\n * Try to parse a value and returns the string if it fails.\n */\nfunction parseValue(symbol: ts.Symbol, key: string, value: string): any {\n    const match = regexRequire(value);\n    if (match) {\n        const fileName = match[2].substr(1, match[2].length - 2).trim();\n        const objectName = match[4];\n        return resolveRequiredFile(symbol, key, fileName, objectName);\n    }\n    try {\n        return JSON.parse(value);\n    } catch (error) {\n        return value;\n    }\n}\n\nfunction extractLiteralValue(typ: ts.Type): PrimitiveType | undefined {\n    let str = (<ts.LiteralType>typ).value;\n    if (str === undefined) {\n        str = (typ as any).text;\n    }\n    if (typ.flags & ts.TypeFlags.StringLiteral) {\n        return str as string;\n    } else if (typ.flags & ts.TypeFlags.BooleanLiteral) {\n        return (typ as any).intrinsicName === \"true\";\n    } else if (typ.flags & ts.TypeFlags.EnumLiteral) {\n        // or .text for old TS\n        const num = parseFloat(str as string);\n        return isNaN(num) ? (str as string) : num;\n    } else if (typ.flags & ts.TypeFlags.NumberLiteral) {\n        return parseFloat(str as string);\n    }\n    return undefined;\n}\n\n/**\n * Checks whether a type is a tuple type.\n */\nfunction resolveTupleType(propertyType: ts.Type): ts.TupleTypeNode | null {\n    if (\n        !propertyType.getSymbol() &&\n        propertyType.getFlags() & ts.TypeFlags.Object &&\n        (<ts.ObjectType>propertyType).objectFlags & ts.ObjectFlags.Reference\n    ) {\n        return (propertyType as ts.TypeReference).target as any;\n    }\n    if (\n        !(\n            propertyType.getFlags() & ts.TypeFlags.Object &&\n            (<ts.ObjectType>propertyType).objectFlags & ts.ObjectFlags.Tuple\n        )\n    ) {\n        return null;\n    }\n    return propertyType as any;\n}\n\nconst simpleTypesAllowedProperties: Record<string, true> = {\n    type: true,\n    description: true,\n};\n\nfunction addSimpleType(def: Definition, type: JSONSchema7TypeName): boolean {\n    for (const k in def) {\n        if (!simpleTypesAllowedProperties[k]) {\n            return false;\n        }\n    }\n\n    if (!def.type) {\n        def.type = type;\n    } else if (typeof def.type !== \"string\") {\n        if (\n            !(<Object[]>def.type).every((val) => {\n                return typeof val === \"string\";\n            })\n        ) {\n            return false;\n        }\n\n        if (def.type.indexOf(\"null\") === -1) {\n            def.type.push(\"null\");\n        }\n    } else {\n        if (typeof def.type !== \"string\") {\n            return false;\n        }\n\n        if (def.type !== \"null\") {\n            def.type = [def.type, \"null\"];\n        }\n    }\n    return true;\n}\n\nfunction makeNullable(def: Definition): Definition {\n    if (!addSimpleType(def, \"null\")) {\n        const union = def.oneOf || def.anyOf;\n        if (union) {\n            union.push({ type: \"null\" });\n        } else {\n            const subdef: DefinitionIndex = {};\n            for (var k in def as any) {\n                if (def.hasOwnProperty(k)) {\n                    subdef[k] = def[k as keyof Definition];\n                    delete def[k as keyof typeof def];\n                }\n            }\n            def.anyOf = [subdef, { type: \"null\" }];\n        }\n    }\n    return def;\n}\n\n/**\n * Given a Symbol, returns a canonical Definition. That can be either:\n * 1) The Symbol's valueDeclaration parameter if defined, or\n * 2) The sole entry in the Symbol's declarations array, provided that array has a length of 1.\n *\n * valueDeclaration is listed as a required parameter in the definition of a Symbol, but I've\n * experienced crashes when it's undefined at runtime, which is the reason for this function's\n * existence. Not sure if that's a compiler API bug or what.\n */\nfunction getCanonicalDeclaration(sym: ts.Symbol): ts.Declaration {\n    if (sym.valueDeclaration !== undefined) {\n        return sym.valueDeclaration;\n    } else if (sym.declarations?.length === 1) {\n        return sym.declarations[0];\n    }\n\n    const declarationCount = sym.declarations?.length ?? 0;\n    throw new Error(`Symbol \"${sym.name}\" has no valueDeclaration and ${declarationCount} declarations.`);\n}\n\n/**\n * Given a Symbol, finds the place it was declared and chases parent pointers until we find a\n * node where SyntaxKind === SourceFile.\n */\nfunction getSourceFile(sym: ts.Symbol): ts.SourceFile {\n    let currentDecl: ts.Node = getCanonicalDeclaration(sym);\n\n    while (currentDecl.kind !== ts.SyntaxKind.SourceFile) {\n        if (currentDecl.parent === undefined) {\n            throw new Error(`Unable to locate source file for declaration \"${sym.name}\".`);\n        }\n        currentDecl = currentDecl.parent;\n    }\n\n    return currentDecl as ts.SourceFile;\n}\n\n/**\n * JSDoc keywords that should be used to annotate the JSON schema.\n *\n * Many of these validation keywords are defined here: http://json-schema.org/latest/json-schema-validation.html\n */\n// prettier-ignore\nconst validationKeywords = {\n    multipleOf: true,               // 6.1.\n    maximum: true,                  // 6.2.\n    exclusiveMaximum: true,         // 6.3.\n    minimum: true,                  // 6.4.\n    exclusiveMinimum: true,         // 6.5.\n    maxLength: true,                // 6.6.\n    minLength: true,                // 6.7.\n    pattern: true,                  // 6.8.\n    items: true,                    // 6.9.\n    // additionalItems: true,          // 6.10.\n    maxItems: true,                 // 6.11.\n    minItems: true,                 // 6.12.\n    uniqueItems: true,              // 6.13.\n    contains: true,                 // 6.14.\n    maxProperties: true,            // 6.15.\n    minProperties: true,            // 6.16.\n    // required: true,                 // 6.17.  This is not required. It is auto-generated.\n    // properties: true,               // 6.18.  This is not required. It is auto-generated.\n    // patternProperties: true,        // 6.19.\n    additionalProperties: true,     // 6.20.\n    // dependencies: true,             // 6.21.\n    // propertyNames: true,            // 6.22.\n    enum: true,                     // 6.23.\n    // const: true,                    // 6.24.\n    type: true,                     // 6.25.\n    // allOf: true,                    // 6.26.\n    // anyOf: true,                    // 6.27.\n    // oneOf: true,                    // 6.28.\n    // not: true,                      // 6.29.\n    examples: true,                    // Draft 6 (draft-handrews-json-schema-validation-01)\n\n    ignore: true,\n    description: true,\n    format: true,\n    default: true,\n    $ref: true,\n    id: true,\n    $id: true,\n    $comment: true,\n    title: true\n};\n\n/**\n * Subset of descriptive, non-type keywords that are permitted alongside a $ref.\n * Prior to JSON Schema draft 2019-09, $ref is a special keyword that doesn't\n * permit keywords alongside it, and so AJV may raise warnings if it encounters\n * any type-related keywords; see https://github.com/ajv-validator/ajv/issues/1121\n */\nconst annotationKeywords: { [k in keyof typeof validationKeywords]?: true } = {\n    description: true,\n    default: true,\n    examples: true,\n    title: true,\n    // A JSDoc $ref annotation can appear as a $ref.\n    $ref: true,\n};\n\nconst subDefinitions: Record<string, true> = {\n    items: true,\n    additionalProperties: true,\n    contains: true,\n};\n\nexport class JsonSchemaGenerator {\n    private tc: ts.TypeChecker;\n\n    /**\n     * Holds all symbols within a custom SymbolRef object, containing useful\n     * information.\n     */\n    private symbols: SymbolRef[];\n    /**\n     * All types for declarations of classes, interfaces, enums, and type aliases\n     * defined in all TS files.\n     */\n    private allSymbols: { [name: string]: ts.Type };\n    /**\n     * All symbols for declarations of classes, interfaces, enums, and type aliases\n     * defined in non-default-lib TS files.\n     */\n    private userSymbols: { [name: string]: ts.Symbol };\n    /**\n     * Maps from the names of base types to the names of the types that inherit from\n     * them.\n     */\n    private inheritingTypes: { [baseName: string]: string[] };\n\n    /**\n     * This map holds references to all reffed definitions, including schema\n     * overrides and generated definitions.\n     */\n    private reffedDefinitions: { [key: string]: Definition } = {};\n\n    /**\n     * This map only holds explicit schema overrides. This helps differentiate between\n     * user defined schema overrides and generated definitions.\n     */\n    private schemaOverrides = new Map<string, Definition>();\n\n    /**\n     * This is a set of all the user-defined validation keywords.\n     */\n    private userValidationKeywords: ValidationKeywords;\n\n    /**\n     * If true, this makes constants be defined as enums with a single value. This is useful\n     * for cases where constant values are not supported, such as OpenAPI.\n     */\n    private constAsEnum: boolean;\n\n    /**\n     * Types are assigned names which are looked up by their IDs.  This is the\n     * map from type IDs to type names.\n     */\n    private typeNamesById: { [id: number]: string } = {};\n    /**\n     * Whenever a type is assigned its name, its entry in this dictionary is set,\n     * so that we don't give the same name to two separate types.\n     */\n    private typeIdsByName: { [name: string]: number } = {};\n\n    constructor(\n        symbols: SymbolRef[],\n        allSymbols: { [name: string]: ts.Type },\n        userSymbols: { [name: string]: ts.Symbol },\n        inheritingTypes: { [baseName: string]: string[] },\n        tc: ts.TypeChecker,\n        private args = getDefaultArgs()\n    ) {\n        this.symbols = symbols;\n        this.allSymbols = allSymbols;\n        this.userSymbols = userSymbols;\n        this.inheritingTypes = inheritingTypes;\n        this.tc = tc;\n        this.userValidationKeywords = args.validationKeywords.reduce((acc, word) => ({ ...acc, [word]: true }), {});\n        this.constAsEnum = args.constAsEnum;\n    }\n\n    public get ReffedDefinitions(): { [key: string]: Definition } {\n        return this.reffedDefinitions;\n    }\n\n    private isFromDefaultLib(symbol: ts.Symbol) {\n        const declarations = symbol.getDeclarations();\n        if (declarations && declarations.length > 0 && declarations[0].parent) {\n            return declarations[0].parent.getSourceFile().hasNoDefaultLib;\n        }\n        return false;\n    }\n\n    private resetSchemaSpecificProperties(includeAllOverrides: boolean = false) {\n        this.reffedDefinitions = {};\n        this.typeIdsByName = {};\n        this.typeNamesById = {};\n\n        // restore schema overrides\n        if (includeAllOverrides) {\n            this.schemaOverrides.forEach((value, key) => {\n                this.reffedDefinitions[key] = value;\n            });\n        }\n    }\n\n    /**\n     * Parse the comments of a symbol into the definition and other annotations.\n     */\n    private parseCommentsIntoDefinition(symbol: ts.Symbol, definition: Definition, otherAnnotations: Record<string, true>): void {\n        if (!symbol) {\n            return;\n        }\n\n        if (!this.isFromDefaultLib(symbol)) {\n            // the comments for a symbol\n            const comments = symbol.getDocumentationComment(this.tc);\n\n            if (comments.length) {\n                definition.description = comments\n                    .map((comment) => {\n                        const newlineNormalizedComment = comment.text.replace(/\\r\\n/g, \"\\n\");\n\n                        // If a comment contains a \"{@link XYZ}\" inline tag that could not be\n                        // resolved by the TS checker, then this comment will contain a trailing\n                        // whitespace that we need to remove.\n                        if (comment.kind === \"linkText\") {\n                            return newlineNormalizedComment.trim();\n                        }\n\n                        return newlineNormalizedComment;\n                    })\n                    .join(\"\").trim();\n            }\n        }\n\n        // jsdocs are separate from comments\n        const jsdocs = symbol.getJsDocTags();\n        jsdocs.forEach((doc) => {\n            // if we have @TJS-... annotations, we have to parse them\n            let name = doc.name;\n            const originalText = doc.text ? doc.text.map((t) => t.text).join(\"\") : \"\";\n            let text = originalText;\n            // In TypeScript versions prior to 3.7, it stops parsing the annotation\n            // at the first non-alphanumeric character and puts the rest of the line as the\n            // \"text\" of the annotation, so we have a little hack to check for the name\n            // \"TJS\" and then we sort of re-parse the annotation to support prior versions\n            // of TypeScript.\n            if (name.startsWith(\"TJS-\")) {\n                name = name.slice(4);\n                if (!text) {\n                    text = \"true\";\n                }\n            } else if (name === \"TJS\" && text.startsWith(\"-\")) {\n                let match: string[] | RegExpExecArray | null = new RegExp(REGEX_TJS_JSDOC).exec(originalText);\n                if (match) {\n                    name = match[1];\n                    text = match[2];\n                } else {\n                    // Treat empty text as boolean true\n                    name = (text as string).replace(/^[\\s\\-]+/, \"\");\n                    text = \"true\";\n                }\n            }\n\n            // In TypeScript ~3.5, the annotation name splits at the dot character so we have\n            // to process the \".\" and beyond from the value\n            if (subDefinitions[name]) {\n                const match: string[] | RegExpExecArray | null = new RegExp(REGEX_GROUP_JSDOC).exec(text);\n                if (match) {\n                    const k = match[1];\n                    const v = match[2];\n                    (definition as DefinitionIndex)[name] = { ...(definition as Record<string, Record<string, unknown>>)[name], [k]: v ? parseValue(symbol, k, v) : true };\n                    return;\n                }\n            }\n\n            // In TypeScript 3.7+, the \".\" is kept as part of the annotation name\n            if (name.includes(\".\")) {\n                const parts = name.split(\".\");\n                const key = parts[0] as keyof Definition;\n                if (parts.length === 2 && subDefinitions[key]) {\n                    (definition as DefinitionIndex)[key] = {\n                        ...definition[key] as Record<string, unknown>,\n                        [parts[1]]: text ? parseValue(symbol, name, text) : true,\n                    };\n                }\n            }\n\n            if (validationKeywords[name as keyof typeof validationKeywords] || this.userValidationKeywords[name]) {\n                (definition as DefinitionIndex)[name] = text === undefined ? \"\" : parseValue(symbol, name, text);\n            } else {\n                // special annotations\n                otherAnnotations[doc.name] = true;\n            }\n        });\n    }\n\n    private getDefinitionForRootType(\n        propertyType: ts.Type,\n        reffedType: ts.Symbol,\n        definition: Definition,\n        defaultNumberType = this.args.defaultNumberType,\n        ignoreUndefined = false,\n    ): Definition {\n        const tupleType = resolveTupleType(propertyType);\n\n        if (tupleType) {\n            // tuple\n            const elemTypes: ts.NodeArray<ts.TypeNode> = (propertyType as any).typeArguments;\n            const targetTupleType = (propertyType as ts.TupleTypeReference).target;\n\n            const fixedTypes = elemTypes.map((elType, index) => {\n                const def = this.getTypeDefinition(elType as any);\n                const label = targetTupleType.labeledElementDeclarations?.[index]?.name?.getFullText().trim();\n                if (label) {\n                    def.title = label;\n                }\n                return def;\n            });\n            definition.type = \"array\";\n            if (fixedTypes.length > 0) {\n                definition.items = fixedTypes;\n            }\n            definition.minItems = targetTupleType.minLength;\n            if (targetTupleType.hasRestElement) {\n                definition.additionalItems = fixedTypes[fixedTypes.length - 1];\n                fixedTypes.splice(fixedTypes.length - 1, 1);\n            } else {\n                definition.maxItems = targetTupleType.fixedLength;\n            }\n        } else {\n            const propertyTypeString = this.tc.typeToString(\n                propertyType,\n                undefined,\n                ts.TypeFormatFlags.UseFullyQualifiedType\n            );\n            const flags = propertyType.flags;\n            const arrayType = this.tc.getIndexTypeOfType(propertyType, ts.IndexKind.Number);\n\n            if (flags & ts.TypeFlags.String) {\n                definition.type = \"string\";\n            } else if (flags & ts.TypeFlags.Number) {\n                const isInteger =\n                    definition.type === \"integer\" ||\n                    reffedType?.getName() === \"integer\" ||\n                    defaultNumberType === \"integer\";\n                definition.type = isInteger ? \"integer\" : \"number\";\n            } else if (flags & ts.TypeFlags.Boolean) {\n                definition.type = \"boolean\";\n            } else if (flags & ts.TypeFlags.ESSymbol) {\n                definition.type = \"object\";\n            } else if (flags & ts.TypeFlags.Null) {\n                definition.type = \"null\";\n            } else if (flags & ts.TypeFlags.Undefined || propertyTypeString === \"void\") {\n                if (!ignoreUndefined) {\n                    throw new Error(\"Not supported: root type undefined\");\n                }\n                // will be deleted\n                definition.type = \"undefined\" as any;\n            } else if (flags & ts.TypeFlags.Any || flags & ts.TypeFlags.Unknown) {\n                // no type restriction, so that anything will match\n            } else if (propertyTypeString === \"Date\" && !this.args.rejectDateType) {\n                definition.type = \"string\";\n                definition.format = definition.format || \"date-time\";\n            } else if (propertyTypeString === \"object\") {\n                definition.type = \"object\";\n                definition.properties = {};\n                definition.additionalProperties = true;\n            } else if (propertyTypeString === \"bigint\") {\n                definition.type = \"number\";\n                definition.properties = {};\n                definition.additionalProperties = false;\n            } else {\n                const value = extractLiteralValue(propertyType);\n                if (value !== undefined) {\n                    // typeof value can be: \"string\", \"boolean\", \"number\", or \"object\" if value is null\n                    const typeofValue = typeof value;\n                    switch (typeofValue) {\n                        case \"string\":\n                        case \"boolean\":\n                            definition.type = typeofValue;\n                            break;\n                        case \"number\":\n                            definition.type = this.args.defaultNumberType;\n                            break;\n                        case \"object\":\n                            definition.type = \"null\";\n                            break;\n                        default:\n                            throw new Error(`Not supported: ${value} as a enum value`);\n                    }\n                    if (this.constAsEnum) {\n                        definition.enum = [value];\n                    } else {\n                        definition.const = value;\n                    }\n                } else if (arrayType !== undefined) {\n                    if (\n                        propertyType.flags & ts.TypeFlags.Object &&\n                        (propertyType as ts.ObjectType).objectFlags &\n                        (ts.ObjectFlags.Anonymous | ts.ObjectFlags.Interface | ts.ObjectFlags.Mapped)\n                    ) {\n                        definition.type = \"object\";\n                        definition.additionalProperties = false;\n                        definition.patternProperties = {\n                            [NUMERIC_INDEX_PATTERN]: this.getTypeDefinition(arrayType),\n                        };\n                        if (!!Array.from((<any>propertyType).members)?.find((member: [string]) => member[0] !== \"__index\")) {\n                            this.getClassDefinition(propertyType, definition);\n                        }\n                    } else if (propertyType.flags & ts.TypeFlags.TemplateLiteral) {\n                        definition.type = \"string\";\n                        // @ts-ignore\n                        const {texts, types} = propertyType;\n                        const pattern = [];\n                        for (let i = 0; i < texts.length; i++) {\n                            const text = texts[i].replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\");\n                            const type = types[i];\n\n                            if (i === 0) {\n                                pattern.push(`^`);\n                            }\n\n                            if (type) {\n                                if (type.flags & ts.TypeFlags.String) {\n                                    pattern.push(`${text}.*`);\n                                }\n\n                                if (type.flags & ts.TypeFlags.Number\n                                    || type.flags & ts.TypeFlags.BigInt) {\n                                    pattern.push(`${text}[0-9]*`);\n                                }\n\n                                if (type.flags & ts.TypeFlags.Undefined) {\n                                    pattern.push(`${text}undefined`);\n                                }\n\n                                if (type.flags & ts.TypeFlags.Null) {\n                                    pattern.push(`${text}null`);\n                                }\n                            }\n\n\n                            if (i === texts.length - 1) {\n                                pattern.push(`${text}$`);\n                            }\n                        }\n                        definition.pattern = pattern.join(\"\");\n                    } else {\n                        definition.type = \"array\";\n                        if (!definition.items) {\n                            definition.items = this.getTypeDefinition(arrayType);\n                        }\n                    }\n                } else {\n                    // Report that type could not be processed\n                    const error = new TypeError(\"Unsupported type: \" + propertyTypeString);\n                    (error as any).type = propertyType;\n                    throw error;\n                    // definition = this.getTypeDefinition(propertyType, tc);\n                }\n            }\n        }\n\n        return definition;\n    }\n\n    private getReferencedTypeSymbol(prop: ts.Symbol): ts.Symbol | undefined {\n        const decl = prop.getDeclarations();\n        if (decl?.length) {\n            const type = <ts.TypeReferenceNode>(<any>decl[0]).type;\n            if (type && type.kind & ts.SyntaxKind.TypeReference && type.typeName) {\n                const symbol = this.tc.getSymbolAtLocation(type.typeName);\n                if (symbol && symbol.flags & ts.SymbolFlags.Alias) {\n                    return this.tc.getAliasedSymbol(symbol);\n                }\n                return symbol;\n            }\n        }\n        return undefined;\n    }\n\n    private getDefinitionForProperty(prop: ts.Symbol, node: ts.Node): Definition | null {\n        if (prop.flags & ts.SymbolFlags.Method) {\n            return null;\n        }\n        const propertyName = prop.getName();\n        const propertyType = this.tc.getTypeOfSymbolAtLocation(prop, node);\n\n        const reffedType = this.getReferencedTypeSymbol(prop);\n\n        const definition = this.getTypeDefinition(propertyType, undefined, undefined, prop, reffedType);\n\n        if (this.args.titles) {\n            definition.title = propertyName;\n        }\n\n        if (definition.hasOwnProperty(\"ignore\")) {\n            return null;\n        }\n\n        // try to get default value\n        const valDecl = prop.valueDeclaration as ts.VariableDeclaration;\n        if (valDecl?.initializer) {\n            let initial = valDecl.initializer;\n\n            while (ts.isTypeAssertionExpression(initial)) {\n                initial = initial.expression;\n            }\n\n            if ((<any>initial).expression) {\n                // node\n                console.warn(\"initializer is expression for property \" + propertyName);\n            } else if ((<any>initial).kind && (<any>initial).kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral) {\n                definition.default = initial.getText();\n            } else {\n                try {\n                    const sandbox = { sandboxvar: null as any };\n                    vm.runInNewContext(\"sandboxvar=\" + initial.getText(), sandbox);\n\n                    const val = sandbox.sandboxvar;\n                    if (\n                        val === null ||\n                        typeof val === \"string\" ||\n                        typeof val === \"number\" ||\n                        typeof val === \"boolean\" ||\n                        Object.prototype.toString.call(val) === \"[object Array]\"\n                    ) {\n                        definition.default = val;\n                    } else if (val) {\n                        console.warn(\"unknown initializer for property \" + propertyName + \": \" + val);\n                    }\n                } catch (e) {\n                    console.warn(\"exception evaluating initializer for property \" + propertyName);\n                }\n            }\n        }\n\n        return definition;\n    }\n\n    private getEnumDefinition(clazzType: ts.Type, definition: Definition): Definition {\n        const node = clazzType.getSymbol()!.getDeclarations()![0];\n        const fullName = this.tc.typeToString(clazzType, undefined, ts.TypeFormatFlags.UseFullyQualifiedType);\n        const members: ts.NodeArray<ts.EnumMember> =\n            node.kind === ts.SyntaxKind.EnumDeclaration\n                ? (node as ts.EnumDeclaration).members\n                : ts.factory.createNodeArray([node as ts.EnumMember]);\n        var enumValues: (number | boolean | string | null)[] = [];\n        const enumTypes: JSONSchema7TypeName[] = [];\n\n        const addType = (type: JSONSchema7TypeName) => {\n            if (enumTypes.indexOf(type) === -1) {\n                enumTypes.push(type);\n            }\n        };\n\n        members.forEach((member) => {\n            const caseLabel = (<ts.Identifier>member.name).text;\n            const constantValue = this.tc.getConstantValue(member);\n            if (constantValue !== undefined) {\n                enumValues.push(constantValue);\n                addType(typeof constantValue as JSONSchema7TypeName); // can be only string or number;\n            } else {\n                // try to extract the enums value; it will probably by a cast expression\n                const initial: ts.Expression | undefined = member.initializer;\n                if (initial) {\n                    if ((<any>initial).expression) {\n                        // node\n                        const exp = (<any>initial).expression;\n                        const text = (<any>exp).text;\n                        // if it is an expression with a text literal, chances are it is the enum convention:\n                        // CASELABEL = 'literal' as any\n                        if (text) {\n                            enumValues.push(text);\n                            addType(\"string\");\n                        } else if (exp.kind === ts.SyntaxKind.TrueKeyword || exp.kind === ts.SyntaxKind.FalseKeyword) {\n                            enumValues.push(exp.kind === ts.SyntaxKind.TrueKeyword);\n                            addType(\"boolean\");\n                        } else {\n                            console.warn(\"initializer is expression for enum: \" + fullName + \".\" + caseLabel);\n                        }\n                    } else if (initial.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral) {\n                        enumValues.push(initial.getText());\n                        addType(\"string\");\n                    } else if (initial.kind === ts.SyntaxKind.NullKeyword) {\n                        enumValues.push(null);\n                        addType(\"null\");\n                    }\n                }\n            }\n        });\n\n        if (enumTypes.length) {\n            definition.type = enumTypes.length === 1 ? enumTypes[0] : enumTypes;\n        }\n\n        if (enumValues.length > 0) {\n            if (enumValues.length > 1) {\n                definition.enum = enumValues;\n            } else {\n                definition.const = enumValues[0];\n            }\n        }\n\n        return definition;\n    }\n\n    private getUnionDefinition(\n        unionType: ts.UnionType,\n        unionModifier: keyof Definition,\n        definition: Definition\n    ): Definition {\n        const enumValues: PrimitiveType[] = [];\n        const simpleTypes: JSONSchema7TypeName[] = [];\n        const schemas: Definition[] = [];\n\n        const pushSimpleType = (type: JSONSchema7TypeName) => {\n            if (simpleTypes.indexOf(type) === -1) {\n                simpleTypes.push(type);\n            }\n        };\n\n        const pushEnumValue = (val: PrimitiveType) => {\n            if (enumValues.indexOf(val) === -1) {\n                enumValues.push(val);\n            }\n        };\n\n        for (const valueType of unionType.types) {\n            const value = extractLiteralValue(valueType);\n            if (value !== undefined) {\n                pushEnumValue(value);\n            } else {\n                const symbol = valueType.aliasSymbol;\n                const def = this.getTypeDefinition(valueType, undefined, undefined, symbol, symbol, undefined, undefined, true);\n                if (def.type === \"undefined\" as any) {\n                    continue;\n                }\n                const keys = Object.keys(def);\n                if (keys.length === 1 && keys[0] === \"type\") {\n                    if (typeof def.type !== \"string\") {\n                        console.error(\"Expected only a simple type.\");\n                    } else {\n                        pushSimpleType(def.type);\n                    }\n                } else {\n                    schemas.push(def);\n                }\n            }\n        }\n\n        if (enumValues.length > 0) {\n            // If the values are true and false, just add \"boolean\" as simple type\n            const isOnlyBooleans =\n                enumValues.length === 2 &&\n                typeof enumValues[0] === \"boolean\" &&\n                typeof enumValues[1] === \"boolean\" &&\n                enumValues[0] !== enumValues[1];\n\n            if (isOnlyBooleans) {\n                pushSimpleType(\"boolean\");\n            } else {\n                const enumSchema: Definition = enumValues.length > 1 ? { enum: enumValues.sort() } : { const: enumValues[0] };\n\n                // If all values are of the same primitive type, add a \"type\" field to the schema\n                if (\n                    enumValues.every((x) => {\n                        return typeof x === \"string\";\n                    })\n                ) {\n                    enumSchema.type = \"string\";\n                } else if (\n                    enumValues.every((x) => {\n                        return typeof x === \"number\";\n                    })\n                ) {\n                    enumSchema.type = \"number\";\n                } else if (\n                    enumValues.every((x) => {\n                        return typeof x === \"boolean\";\n                    })\n                ) {\n                    enumSchema.type = \"boolean\";\n                }\n\n                schemas.push(enumSchema);\n            }\n        }\n\n        if (simpleTypes.length > 0) {\n            schemas.push({ type: simpleTypes.length === 1 ? simpleTypes[0] : simpleTypes });\n        }\n\n        if (schemas.length === 1) {\n            for (const k in schemas[0]) {\n                if (schemas[0].hasOwnProperty(k)) {\n                    if (k === \"description\" && definition.hasOwnProperty(k)) {\n                        // If we already have a more specific description, don't overwrite it.\n                        continue;\n                    }\n                    (definition as DefinitionIndex)[k] = schemas[0][k as keyof Definition];\n                }\n            }\n        } else {\n            (definition as DefinitionIndex)[unionModifier] = schemas;\n        }\n        return definition;\n    }\n\n    private getIntersectionDefinition(intersectionType: ts.IntersectionType, definition: Definition): Definition {\n        const simpleTypes: JSONSchema7TypeName[] = [];\n        const schemas: Definition[] = [];\n\n        const pushSimpleType = (type: JSONSchema7TypeName) => {\n            if (simpleTypes.indexOf(type) === -1) {\n                simpleTypes.push(type);\n            }\n        };\n\n        for (const intersectionMember of intersectionType.types) {\n            const def = this.getTypeDefinition(intersectionMember);\n            const keys = Object.keys(def);\n            if (keys.length === 1 && keys[0] === \"type\") {\n                if (typeof def.type !== \"string\") {\n                    console.error(\"Expected only a simple type.\");\n                } else {\n                    pushSimpleType(def.type);\n                }\n            } else {\n                schemas.push(def);\n            }\n        }\n\n        if (simpleTypes.length > 0) {\n            schemas.push({ type: simpleTypes.length === 1 ? simpleTypes[0] : simpleTypes });\n        }\n\n        if (schemas.length === 1) {\n            for (const k in schemas[0]) {\n                if (schemas[0].hasOwnProperty(k)) {\n                    (definition as DefinitionIndex)[k] = schemas[0][k as keyof Definition];\n                }\n            }\n        } else {\n            definition.allOf = schemas;\n        }\n        return definition;\n    }\n\n    private getClassDefinition(clazzType: ts.Type, definition: Definition): Definition {\n        const node = clazzType.getSymbol()!.getDeclarations()![0];\n\n        // Example: typeof globalThis may not have any declaration\n        if (!node) {\n            definition.type = \"object\";\n            return definition;\n        }\n\n        if (this.args.typeOfKeyword && node.kind === ts.SyntaxKind.FunctionType) {\n            definition.typeof = \"function\";\n            return definition;\n        }\n\n        const clazz = <ts.ClassDeclaration>node;\n        const props = this.tc.getPropertiesOfType(clazzType).filter((prop) => {\n            // filter never and undefined\n            const propertyFlagType = this.tc.getTypeOfSymbolAtLocation(prop, node).getFlags();\n            if (ts.TypeFlags.Never === propertyFlagType || ts.TypeFlags.Undefined === propertyFlagType) {\n                return false;\n            }\n            if (!this.args.excludePrivate) {\n                return true;\n            }\n\n            const decls = prop.declarations;\n            return !(\n                decls &&\n                decls.filter((decl) => {\n                    const mods = (decl as any).modifiers;\n                    return mods && mods.filter((mod: any) => mod.kind === ts.SyntaxKind.PrivateKeyword).length > 0;\n                }).length > 0\n            );\n        });\n        const fullName = this.tc.typeToString(clazzType, undefined, ts.TypeFormatFlags.UseFullyQualifiedType);\n\n        const modifierFlags = ts.getCombinedModifierFlags(node);\n\n        if (modifierFlags & ts.ModifierFlags.Abstract && this.inheritingTypes[fullName]) {\n            const oneOf = this.inheritingTypes[fullName].map((typename) => {\n                return this.getTypeDefinition(this.allSymbols[typename]);\n            });\n\n            definition.oneOf = oneOf;\n        } else {\n            if (clazz.members) {\n                const indexSignatures =\n                    clazz.members == null ? [] : clazz.members.filter((x) => x.kind === ts.SyntaxKind.IndexSignature);\n                if (indexSignatures.length === 1) {\n                    // for case \"array-types\"\n                    const indexSignature = indexSignatures[0] as ts.IndexSignatureDeclaration;\n                    if (indexSignature.parameters.length !== 1) {\n                        throw new Error(\"Not supported: IndexSignatureDeclaration parameters.length != 1\");\n                    }\n                    const indexSymbol: ts.Symbol = (<any>indexSignature.parameters[0]).symbol;\n                    const indexType = this.tc.getTypeOfSymbolAtLocation(indexSymbol, node);\n                    const isIndexedObject = indexType.flags === ts.TypeFlags.String || indexType.flags === ts.TypeFlags.Number;\n                    if (indexType.flags !== ts.TypeFlags.Number && !isIndexedObject) {\n                        throw new Error(\n                            \"Not supported: IndexSignatureDeclaration with index symbol other than a number or a string\"\n                        );\n                    }\n\n                    const typ = this.tc.getTypeAtLocation(indexSignature.type!);\n                    let def: Definition | undefined;\n                    if (typ.flags & ts.TypeFlags.IndexedAccess) {\n                        const targetName = ts.escapeLeadingUnderscores((<any>clazzType).mapper?.target?.value);\n                        const indexedAccessType = <ts.IndexedAccessType>typ;\n                        const symbols: Map<ts.__String, ts.Symbol> = (<any>indexedAccessType.objectType).members;\n                        const targetSymbol = symbols?.get(targetName);\n\n                        if (targetSymbol) {\n                            const targetNode = targetSymbol.getDeclarations()![0];\n                            const targetDef = this.getDefinitionForProperty(targetSymbol, targetNode);\n                            if (targetDef) {\n                                def = targetDef;\n                            }\n                        }\n                    }\n                    if (!def) {\n                        def = this.getTypeDefinition(typ, undefined, \"anyOf\");\n                    }\n                    if (isIndexedObject) {\n                        definition.type = \"object\";\n                        if (!Object.keys(definition.patternProperties || {}).length) {\n                            definition.additionalProperties = def;\n                        }\n                    } else {\n                        definition.type = \"array\";\n                        if (!definition.items) {\n                            definition.items = def;\n                        }\n                    }\n                }\n            }\n\n            const propertyDefinitions = props.reduce<Record<string, Definition>>((all, prop) => {\n                const propertyName = prop.getName();\n                const propDef = this.getDefinitionForProperty(prop, node);\n                if (propDef != null) {\n                    all[propertyName] = propDef;\n                }\n                return all;\n            }, {});\n\n            if (definition.type === undefined) {\n                definition.type = \"object\";\n            }\n\n            if (definition.type === \"object\" && Object.keys(propertyDefinitions).length > 0) {\n                definition.properties = propertyDefinitions;\n            }\n\n            if (this.args.defaultProps) {\n                definition.defaultProperties = [];\n            }\n            if (this.args.noExtraProps && definition.additionalProperties === undefined) {\n                definition.additionalProperties = false;\n            }\n            if (this.args.propOrder) {\n                // propertyOrder is non-standard, but useful:\n                // https://github.com/json-schema/json-schema/issues/87\n                const propertyOrder = props.reduce((order: string[], prop: ts.Symbol) => {\n                    order.push(prop.getName());\n                    return order;\n                }, []);\n\n                definition.propertyOrder = propertyOrder;\n            }\n            if (this.args.required) {\n                const requiredProps = props.reduce((required: string[], prop: ts.Symbol) => {\n                    const def = {};\n                    this.parseCommentsIntoDefinition(prop, def, {});\n                    const allUnionTypesFlags: number[] = (<any>prop).links?.type?.types?.map?.((t: any) => t.flags) || [];\n                    if (\n                        !(prop.flags & ts.SymbolFlags.Optional) &&\n                        !(prop.flags & ts.SymbolFlags.Method) &&\n                        !allUnionTypesFlags.includes(ts.TypeFlags.Undefined) &&\n                        !allUnionTypesFlags.includes(ts.TypeFlags.Void) &&\n                        !def.hasOwnProperty(\"ignore\")\n                    ) {\n                        required.push(prop.getName());\n                    }\n                    return required;\n                }, []);\n\n                if (requiredProps.length > 0) {\n                    definition.required = unique(requiredProps).sort();\n                }\n            }\n        }\n        return definition;\n    }\n\n    /**\n     * Gets/generates a globally unique type name for the given type\n     */\n    private getTypeName(typ: ts.Type): string {\n        const id = (typ as any).id as number;\n        if (this.typeNamesById[id]) {\n            // Name already assigned?\n            return this.typeNamesById[id];\n        }\n        return this.makeTypeNameUnique(\n            typ,\n            this.tc\n                .typeToString(\n                    typ,\n                    undefined,\n                    ts.TypeFormatFlags.NoTruncation | ts.TypeFormatFlags.UseFullyQualifiedType\n                )\n                .replace(REGEX_FILE_NAME_OR_SPACE, \"\")\n        );\n    }\n\n    private makeTypeNameUnique(typ: ts.Type, baseName: string): string {\n        const id = (typ as any).id as number;\n\n        let name = baseName;\n        // If a type with same name exists\n        // Try appending \"_1\", \"_2\", etc.\n        for (let i = 1; this.typeIdsByName[name] !== undefined && this.typeIdsByName[name] !== id; ++i) {\n            name = baseName + \"_\" + i;\n        }\n\n        this.typeNamesById[id] = name;\n        this.typeIdsByName[name] = id;\n        return name;\n    }\n\n    private recursiveTypeRef = new Map();\n\n    private getTypeDefinition(\n        typ: ts.Type,\n        asRef = this.args.ref,\n        unionModifier: keyof Definition = \"anyOf\",\n        prop?: ts.Symbol,\n        reffedType?: ts.Symbol,\n        pairedSymbol?: ts.Symbol,\n        forceNotRef: boolean = false,\n        ignoreUndefined = false,\n    ): Definition {\n        const definition: Definition = {}; // real definition\n\n        // Ignore any number of Readonly and Mutable type wrappings, since they only add and remove readonly modifiers on fields and JSON Schema is not concerned with mutability\n        while (\n            typ.aliasSymbol &&\n            (typ.aliasSymbol.escapedName === \"Readonly\" || typ.aliasSymbol.escapedName === \"Mutable\") &&\n            typ.aliasTypeArguments &&\n            typ.aliasTypeArguments[0]\n        ) {\n            typ = typ.aliasTypeArguments[0];\n            reffedType = undefined;\n        }\n\n        if (\n            this.args.typeOfKeyword &&\n            typ.flags & ts.TypeFlags.Object &&\n            (<ts.ObjectType>typ).objectFlags & ts.ObjectFlags.Anonymous\n        ) {\n            definition.typeof = \"function\";\n            return definition;\n        }\n\n        let returnedDefinition = definition; // returned definition, may be a $ref\n\n        // Parse property comments now to skip recursive if ignore.\n        if (prop) {\n            const defs: Definition & { [k in MetaDefinitionFields]?: \"\" } = {};\n            const others = {};\n            this.parseCommentsIntoDefinition(prop, defs, others);\n            if (defs.hasOwnProperty(\"ignore\") || defs.hasOwnProperty(\"type\")) {\n                return defs;\n            }\n        }\n\n        const symbol = typ.getSymbol();\n        // FIXME: We can't just compare the name of the symbol - it ignores the namespace\n        let isRawType =\n            !symbol ||\n            // Window is incorrectly marked as rawType here for some reason\n            (this.tc.getFullyQualifiedName(symbol) !== \"Window\" &&\n                (this.tc.getFullyQualifiedName(symbol) === \"Date\" ||\n                    symbol.name === \"integer\" ||\n                    this.tc.getIndexInfoOfType(typ, ts.IndexKind.Number) !== undefined));\n\n        if (isRawType && (typ as any).aliasSymbol?.escapedName && (typ as any).types) {\n            isRawType = false;\n        }\n\n        // special case: an union where all child are string literals -> make an enum instead\n        let isStringEnum = false;\n        if (typ.flags & ts.TypeFlags.Union) {\n            const unionType = <ts.UnionType>typ;\n            isStringEnum = unionType.types.every((propType) => {\n                return (propType.getFlags() & ts.TypeFlags.StringLiteral) !== 0;\n            });\n        }\n\n        // aliased types must be handled slightly different\n        const asTypeAliasRef = asRef && reffedType && (this.args.aliasRef || isStringEnum);\n        if (!asTypeAliasRef) {\n            if (\n                isRawType ||\n                (typ.getFlags() & ts.TypeFlags.Object && (<ts.ObjectType>typ).objectFlags & ts.ObjectFlags.Anonymous)\n            ) {\n                asRef = false; // raw types and inline types cannot be reffed,\n                // unless we are handling a type alias\n                // or it is recursive type - see below\n            }\n        }\n\n        let fullTypeName = \"\";\n        if (asTypeAliasRef) {\n            const typeName = this.tc\n                .getFullyQualifiedName(\n                    reffedType!.getFlags() & ts.SymbolFlags.Alias ? this.tc.getAliasedSymbol(reffedType!) : reffedType!\n                )\n                .replace(REGEX_FILE_NAME_OR_SPACE, \"\");\n            if (this.args.uniqueNames && reffedType) {\n                const sourceFile = getSourceFile(reffedType);\n                const relativePath = path.relative(process.cwd(), sourceFile.fileName);\n                fullTypeName = `${typeName}.${generateHashOfNode(getCanonicalDeclaration(reffedType!), relativePath)}`;\n            } else {\n                fullTypeName = this.makeTypeNameUnique(typ, typeName);\n            }\n        } else {\n            // typ.symbol can be undefined\n            if (this.args.uniqueNames && typ.symbol) {\n                const sym = typ.symbol;\n                const sourceFile = getSourceFile(sym);\n                const relativePath = path.relative(process.cwd(), sourceFile.fileName);\n                fullTypeName = `${this.getTypeName(typ)}.${generateHashOfNode(\n                    getCanonicalDeclaration(sym),\n                    relativePath\n                )}`;\n            } else if (reffedType && this.schemaOverrides.has(reffedType.escapedName as string)) {\n                fullTypeName = reffedType.escapedName as string;\n            } else {\n                fullTypeName = this.getTypeName(typ);\n            }\n        }\n\n        // Handle recursive types\n        if (!isRawType || !!typ.aliasSymbol) {\n            if (this.recursiveTypeRef.has(fullTypeName) && !forceNotRef) {\n                asRef = true;\n            } else {\n                this.recursiveTypeRef.set(fullTypeName, definition);\n            }\n        }\n\n        if (asRef) {\n            // We don't return the full definition, but we put it into\n            // reffedDefinitions below.\n            returnedDefinition = {\n                $ref: `${this.args.id}#/definitions/` + fullTypeName,\n            };\n        }\n\n        // Parse comments\n        const otherAnnotations: Record<string, true> = {};\n        this.parseCommentsIntoDefinition(reffedType!, definition, otherAnnotations); // handle comments in the type alias declaration\n        this.parseCommentsIntoDefinition(symbol!, definition, otherAnnotations);\n        this.parseCommentsIntoDefinition(typ.aliasSymbol!, definition, otherAnnotations);\n        if (prop) {\n            this.parseCommentsIntoDefinition(prop, returnedDefinition, otherAnnotations);\n        }\n        if (pairedSymbol && symbol && this.isFromDefaultLib(symbol)) {\n            this.parseCommentsIntoDefinition(pairedSymbol, definition, otherAnnotations);\n        }\n\n        // Create the actual definition only if is an inline definition, or\n        // if it will be a $ref and it is not yet created.\n        // Prioritise overrides.\n        const overrideDefinition = this.schemaOverrides.get(fullTypeName);\n        if (overrideDefinition) {\n            this.reffedDefinitions[fullTypeName] = overrideDefinition;\n        } else if (!asRef || !this.reffedDefinitions[fullTypeName]) {\n            if (asRef) {\n                // must be here to prevent recursivity problems\n                let reffedDefinition: Definition;\n                if (asTypeAliasRef && reffedType && typ.symbol !== reffedType && symbol) {\n                    reffedDefinition = this.getTypeDefinition(typ, true, undefined, symbol, symbol);\n                } else {\n                    reffedDefinition = definition;\n                }\n                this.reffedDefinitions[fullTypeName] = reffedDefinition;\n                if (this.args.titles && fullTypeName) {\n                    definition.title = fullTypeName;\n                }\n            }\n            const node = symbol?.getDeclarations() !== undefined ? symbol.getDeclarations()![0] : null;\n\n            if (definition.type === undefined) {\n                // if users override the type, do not try to infer it\n                if (typ.flags & ts.TypeFlags.Union && (node === null || node.kind !== ts.SyntaxKind.EnumDeclaration)) {\n                    this.getUnionDefinition(typ as ts.UnionType, unionModifier, definition);\n                } else if (typ.flags & ts.TypeFlags.Intersection) {\n                    if (this.args.noExtraProps) {\n                        // extend object instead of using allOf because allOf does not work well with additional properties. See #107\n                        if (this.args.noExtraProps) {\n                            definition.additionalProperties = false;\n                        }\n\n                        const types = (<ts.IntersectionType>typ).types;\n                        for (const member of types) {\n                            const other = this.getTypeDefinition(member, false, undefined, undefined, undefined, undefined, true);\n                            definition.type = other.type; // should always be object\n                            definition.properties = {\n                                ...definition.properties,\n                                ...other.properties,\n                            };\n\n                            if (Object.keys(other.default || {}).length > 0) {\n                                definition.default = extend(definition.default || {}, other.default);\n                            }\n                            if (other.required) {\n                                definition.required = unique((definition.required || []).concat(other.required)).sort();\n                            }\n                        }\n                    } else {\n                        this.getIntersectionDefinition(typ as ts.IntersectionType, definition);\n                    }\n                } else if (isRawType) {\n                    if (pairedSymbol) {\n                        this.parseCommentsIntoDefinition(pairedSymbol, definition, {});\n                    }\n                    this.getDefinitionForRootType(typ, reffedType!, definition, undefined, ignoreUndefined);\n                } else if (\n                    node &&\n                    (node.kind === ts.SyntaxKind.EnumDeclaration || node.kind === ts.SyntaxKind.EnumMember)\n                ) {\n                    this.getEnumDefinition(typ, definition);\n                } else if (\n                    symbol &&\n                    symbol.flags & ts.SymbolFlags.TypeLiteral &&\n                    symbol.members!.size === 0 &&\n                    !(node && node.kind === ts.SyntaxKind.MappedType)\n                ) {\n                    // {} is TypeLiteral with no members. Need special case because it doesn't have declarations.\n                    definition.type = \"object\";\n                    definition.properties = {};\n                } else {\n                    this.getClassDefinition(typ, definition);\n                }\n            }\n        }\n\n        if (this.recursiveTypeRef.get(fullTypeName) === definition) {\n            this.recursiveTypeRef.delete(fullTypeName);\n            // If the type was recursive (there is reffedDefinitions) - lets replace it to reference\n            if (this.reffedDefinitions[fullTypeName]) {\n                const annotations = Object.entries(returnedDefinition).reduce<Record<string, unknown>>((acc, [key, value]) => {\n                    if (annotationKeywords[key as keyof typeof annotationKeywords] && typeof value !== undefined) {\n                        acc[key] = value;\n                    }\n                    return acc;\n                }, {});\n\n                returnedDefinition = {\n                    $ref: `${this.args.id}#/definitions/` + fullTypeName,\n                    ...annotations,\n                };\n            }\n        }\n\n        if (otherAnnotations[\"nullable\"]) {\n            makeNullable(returnedDefinition);\n        }\n\n        return returnedDefinition;\n    }\n\n    public setSchemaOverride(symbolName: string, schema: Definition): void {\n        this.schemaOverrides.set(symbolName, schema);\n    }\n\n    public getSchemaForSymbol(symbolName: string, includeReffedDefinitions: boolean = true, includeAllOverrides: boolean = false): Definition {\n        const overrideDefinition = this.schemaOverrides.get(symbolName);\n        if (!this.allSymbols[symbolName] && !overrideDefinition) {\n            throw new Error(`type ${symbolName} not found`);\n        }\n\n        this.resetSchemaSpecificProperties(includeAllOverrides);\n\n        let def;\n        if (overrideDefinition) {\n            def = { ...overrideDefinition };\n        } else {\n            def = overrideDefinition ? overrideDefinition : this.getTypeDefinition(\n              this.allSymbols[symbolName],\n              this.args.topRef,\n              undefined,\n              undefined,\n              undefined,\n              this.userSymbols[symbolName] || undefined\n            );\n        }\n\n        if (this.args.ref && includeReffedDefinitions && Object.keys(this.reffedDefinitions).length > 0) {\n            def.definitions = this.reffedDefinitions;\n        }\n        def[\"$schema\"] = \"http://json-schema.org/draft-07/schema#\";\n        const id = this.args.id;\n        if (id) {\n            def[\"$id\"] = this.args.id;\n        }\n        return def;\n    }\n\n    public getSchemaForSymbols(symbolNames: string[], includeReffedDefinitions: boolean = true, includeAllOverrides: boolean = false): Definition {\n        const root: {\n            $id?: string,\n            $schema: string,\n            definitions: Record<string, Definition>\n        } = {\n            $schema: \"http://json-schema.org/draft-07/schema#\",\n            definitions: {},\n        };\n\n        this.resetSchemaSpecificProperties(includeAllOverrides);\n\n        const id = this.args.id;\n\n        if (id) {\n            root[\"$id\"] = id;\n        }\n\n        for (const symbolName of symbolNames) {\n            root.definitions[symbolName] = this.getTypeDefinition(\n                this.allSymbols[symbolName],\n                this.args.topRef,\n                undefined,\n                undefined,\n                undefined,\n                this.userSymbols[symbolName]\n            );\n        }\n        if (this.args.ref && includeReffedDefinitions && Object.keys(this.reffedDefinitions).length > 0) {\n            root.definitions = { ...root.definitions, ...this.reffedDefinitions };\n        }\n        return root;\n    }\n\n    public getSymbols(name?: string): SymbolRef[] {\n        if (name === void 0) {\n            return this.symbols;\n        }\n\n        return this.symbols.filter((symbol) => symbol.typeName === name);\n    }\n\n    public getUserSymbols(): string[] {\n        return Object.keys(this.userSymbols);\n    }\n\n    public getMainFileSymbols(program: ts.Program, onlyIncludeFiles?: string[]): string[] {\n        function includeFile(file: ts.SourceFile): boolean {\n            if (onlyIncludeFiles === undefined) {\n                return !file.isDeclarationFile;\n            }\n            return onlyIncludeFiles.filter((f) => pathEqual(f, file.fileName)).length > 0;\n        }\n        const files = program.getSourceFiles().filter(includeFile);\n        if (files.length) {\n            return Object.keys(this.userSymbols).filter((key) => {\n                const symbol = this.userSymbols[key];\n                if (!symbol || !symbol.declarations || !symbol.declarations.length) {\n                    return false;\n                }\n                let node: ts.Node = symbol.declarations[0];\n                while (node?.parent) {\n                    node = node.parent;\n                }\n                return files.indexOf(node.getSourceFile()) > -1;\n            });\n        }\n        return [];\n    }\n}\n\nexport function getProgramFromFiles(\n    files: string[],\n    jsonCompilerOptions: any = {},\n    basePath: string = \"./\"\n): ts.Program {\n    // use built-in default options\n    const compilerOptions = ts.convertCompilerOptionsFromJson(jsonCompilerOptions, basePath).options;\n    const options: ts.CompilerOptions = {\n        noEmit: true,\n        emitDecoratorMetadata: true,\n        experimentalDecorators: true,\n        target: ts.ScriptTarget.ES5,\n        module: ts.ModuleKind.CommonJS,\n        allowUnusedLabels: true,\n    };\n    for (const k in compilerOptions) {\n        if (compilerOptions.hasOwnProperty(k)) {\n            options[k] = compilerOptions[k];\n        }\n    }\n    return ts.createProgram(files, options);\n}\n\nfunction generateHashOfNode(node: ts.Node, relativePath: string): string {\n    return createHash(\"md5\").update(relativePath).update(node.pos.toString()).digest(\"hex\").substring(0, 8);\n}\n\nexport function buildGenerator(\n    program: ts.Program,\n    args: PartialArgs = {},\n    onlyIncludeFiles?: string[]\n): JsonSchemaGenerator | null {\n    function isUserFile(file: ts.SourceFile): boolean {\n        if (onlyIncludeFiles === undefined) {\n            return !file.hasNoDefaultLib;\n        }\n        return onlyIncludeFiles.indexOf(file.fileName) >= 0;\n    }\n    // Use defaults unless otherwise specified\n    const settings = getDefaultArgs();\n\n    for (const pref in args) {\n        if (args.hasOwnProperty(pref)) {\n            (settings as Record<string, Partial<Args>[keyof Args]>)[pref as keyof Args] = args[pref as keyof Args];\n        }\n    }\n\n    if (args.tsNodeRegister) {\n        require(\"ts-node/register\");\n    }\n\n    let diagnostics: ReadonlyArray<ts.Diagnostic> = [];\n\n    if (!args.ignoreErrors) {\n        diagnostics = ts.getPreEmitDiagnostics(program);\n    }\n\n    if (diagnostics.length === 0) {\n        const typeChecker = program.getTypeChecker();\n\n        const symbols: SymbolRef[] = [];\n        const allSymbols: { [name: string]: ts.Type } = {};\n        const userSymbols: { [name: string]: ts.Symbol } = {};\n        const inheritingTypes: { [baseName: string]: string[] } = {};\n        const workingDir = program.getCurrentDirectory();\n\n        program.getSourceFiles().forEach((sourceFile, _sourceFileIdx) => {\n            const relativePath = path.relative(workingDir, sourceFile.fileName);\n\n            function inspect(node: ts.Node, tc: ts.TypeChecker) {\n                if (\n                    node.kind === ts.SyntaxKind.ClassDeclaration ||\n                    node.kind === ts.SyntaxKind.InterfaceDeclaration ||\n                    node.kind === ts.SyntaxKind.EnumDeclaration ||\n                    node.kind === ts.SyntaxKind.TypeAliasDeclaration\n                ) {\n                    const symbol: ts.Symbol = (<any>node).symbol;\n                    const nodeType = tc.getTypeAtLocation(node);\n                    const fullyQualifiedName = tc.getFullyQualifiedName(symbol);\n                    const typeName = fullyQualifiedName.replace(/\".*\"\\./, \"\");\n                    const name = !args.uniqueNames ? typeName : `${typeName}.${generateHashOfNode(node, relativePath)}`;\n\n                    symbols.push({ name, typeName, fullyQualifiedName, symbol });\n                    if (!userSymbols[name]) {\n                        allSymbols[name] = nodeType;\n                    }\n\n                    if (isUserFile(sourceFile)) {\n                        userSymbols[name] = symbol;\n                    }\n\n                    const baseTypes = nodeType.getBaseTypes() || [];\n\n                    baseTypes.forEach((baseType) => {\n                        var baseName = tc.typeToString(baseType, undefined, ts.TypeFormatFlags.UseFullyQualifiedType);\n                        if (!inheritingTypes[baseName]) {\n                            inheritingTypes[baseName] = [];\n                        }\n                        inheritingTypes[baseName].push(name);\n                    });\n                } else {\n                    ts.forEachChild(node, (n) => inspect(n, tc));\n                }\n            }\n            inspect(sourceFile, typeChecker);\n        });\n\n        return new JsonSchemaGenerator(symbols, allSymbols, userSymbols, inheritingTypes, typeChecker, settings);\n    } else {\n        diagnostics.forEach((diagnostic) => {\n            const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, \"\\n\");\n            if (diagnostic.file) {\n                const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start!);\n                console.error(`${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`);\n            } else {\n                console.error(message);\n            }\n        });\n        return null;\n    }\n}\n\nexport function generateSchema(\n    program: ts.Program,\n    fullTypeName: string,\n    args: PartialArgs = {},\n    onlyIncludeFiles?: string[],\n    externalGenerator?: JsonSchemaGenerator\n): Definition | null {\n    const generator = externalGenerator ?? buildGenerator(program, args, onlyIncludeFiles);\n\n    if (generator === null) {\n        return null;\n    }\n\n    if (fullTypeName === \"*\") {\n        // All types in file(s)\n        return generator.getSchemaForSymbols(generator.getMainFileSymbols(program, onlyIncludeFiles), true, true);\n    } else if (args.uniqueNames) {\n        // Find the hashed type name to use as the root object\n        const matchingSymbols = generator.getSymbols(fullTypeName);\n        if (matchingSymbols.length === 1) {\n            return generator.getSchemaForSymbol(matchingSymbols[0].name);\n        } else {\n            throw new Error(`${matchingSymbols.length} definitions found for requested type \"${fullTypeName}\".`);\n        }\n    } else {\n        // Use specific type as root object\n        return generator.getSchemaForSymbol(fullTypeName);\n    }\n}\n\nexport function programFromConfig(configFileName: string, onlyIncludeFiles?: string[]): ts.Program {\n    // basically a copy of https://github.com/Microsoft/TypeScript/blob/3663d400270ccae8b69cbeeded8ffdc8fa12d7ad/src/compiler/tsc.ts -> parseConfigFile\n    const result = ts.parseConfigFileTextToJson(configFileName, ts.sys.readFile(configFileName)!);\n    const configObject = result.config;\n\n    const configParseResult = ts.parseJsonConfigFileContent(\n        configObject,\n        ts.sys,\n        path.dirname(configFileName),\n        {},\n        path.basename(configFileName)\n    );\n    const options = configParseResult.options;\n    options.noEmit = true;\n    delete options.out;\n    delete options.outDir;\n    delete options.outFile;\n    delete options.declaration;\n    delete options.declarationDir;\n    delete options.declarationMap;\n\n    const program = ts.createProgram({\n        rootNames: onlyIncludeFiles || configParseResult.fileNames,\n        options,\n        projectReferences: configParseResult.projectReferences,\n    });\n    return program;\n}\n\nfunction normalizeFileName(fn: string): string {\n    while (fn.substr(0, 2) === \"./\") {\n        fn = fn.substr(2);\n    }\n    return fn;\n}\n\nexport async function exec(filePattern: string, fullTypeName: string, args = getDefaultArgs()): Promise<void> {\n    let program: ts.Program;\n    let onlyIncludeFiles: string[] | undefined = undefined;\n    if (REGEX_TSCONFIG_NAME.test(path.basename(filePattern))) {\n        if (args.include && args.include.length > 0) {\n            const globs: string[][] = args.include.map((f) => glob.sync(f));\n            onlyIncludeFiles = ([] as string[]).concat(...globs).map(normalizeFileName);\n        }\n        program = programFromConfig(filePattern, onlyIncludeFiles);\n    } else {\n        onlyIncludeFiles = glob.sync(filePattern);\n        program = getProgramFromFiles(onlyIncludeFiles, {\n            strictNullChecks: args.strictNullChecks,\n            esModuleInterop: args.esModuleInterop,\n            skipLibCheck: args.skipLibCheck,\n            emitDecoratorMetadata: args.experimentalDecorators,\n            experimentalDecorators: args.experimentalDecorators,\n        });\n        onlyIncludeFiles = onlyIncludeFiles.map(normalizeFileName);\n    }\n\n    const definition = generateSchema(program, fullTypeName, args, onlyIncludeFiles);\n    if (definition === null) {\n        throw new Error(\"No output definition. Probably caused by errors prior to this?\");\n    }\n\n    const json = stringify(definition, null, 4) + \"\\n\\n\";\n    if (args.out) {\n        return new Promise((resolve, reject) => {\n            const fs = require(\"fs\");\n            fs.mkdir(path.dirname(args.out), { recursive: true }, function (mkErr: Error) {\n                if (mkErr) {\n                    return reject(new Error(\"Unable to create parent directory for output file: \" + mkErr.message));\n                }\n                fs.writeFile(args.out, json, function (wrErr: Error) {\n                    if (wrErr) {\n                        return reject(new Error(\"Unable to write output file: \" + wrErr.message));\n                    }\n                    resolve();\n                });\n            });\n        });\n    } else {\n        const hasBeenBuffered = process.stdout.write(json);\n        if (hasBeenBuffered) {\n            return new Promise((resolve) => process.stdout.on(\"drain\", () => resolve()));\n        }\n    }\n}\n"
        },
        {
          "name": "update-docs.js",
          "type": "blob",
          "size": 1.0048828125,
          "content": "#!/usr/bin/env node\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nfunction getFiles(base) {\n    const directory = fs.readdirSync(base, { withFileTypes: true });\n    const files = directory.map((dir) => {\n        const res = path.resolve(base, dir.name);\n        return dir.isDirectory() ? getFiles(res) : res;\n    });\n    return Array.prototype.concat(...files).filter((file) => file.indexOf(\".ts\") > 0);\n}\n\nconst tests = getFiles(\"./test/programs\");\nconst ensureTrailingLineBrake = (contents) => (contents[contents.length - 1] === \"\\n\" ? contents : contents + \"\\n\");\n\nlet source =\n    \"_Auto-generated file. Updated with NPM deploy. Update manually with 'yarn docs'._\\n\\n\" +\n    \"# typescript-json-schema test examples\\n\\n\";\ntests.forEach((file) => {\n    const contents = fs.readFileSync(file, \"utf8\");\n    const folder = file.split(\"/\").slice(-2)[0];\n    source += `## [${folder}](./test/programs/${folder})\\n\\n\\`\\`\\`ts\\n${ensureTrailingLineBrake(contents)}\\`\\`\\`\\n\\n\\n`;\n});\n\nfs.writeFileSync(\"./api.md\", source);\n"
        },
        {
          "name": "yarn.lock",
          "type": "blob",
          "size": 38.119140625,
          "content": "# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v1\n\n\n\"@babel/code-frame@^7.0.0\":\n  version \"7.14.5\"\n  resolved \"https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.14.5.tgz\"\n  integrity sha512-9pzDqyc6OLDaqe+zbACgFkb6fKMNG6CObKpnYXChRsvYGyEdc7CA2BaqeOM+vOtCS5ndmJicPJhKAwYRI6UfFw==\n  dependencies:\n    \"@babel/highlight\" \"^7.14.5\"\n\n\"@babel/helper-validator-identifier@^7.14.5\":\n  version \"7.14.9\"\n  resolved \"https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.14.9.tgz\"\n  integrity sha512-pQYxPY0UP6IHISRitNe8bsijHex4TWZXi2HwKVsjPiltzlhse2znVcm9Ace510VT1kxIHjGJCZZQBX2gJDbo0g==\n\n\"@babel/highlight@^7.14.5\":\n  version \"7.14.5\"\n  resolved \"https://registry.npmjs.org/@babel/highlight/-/highlight-7.14.5.tgz\"\n  integrity sha512-qf9u2WFWVV0MppaL877j2dBtQIDgmidgjGk5VIMw3OadXvYaXn66U1BFlH2t4+t3i+8PhedppRv+i40ABzd+gg==\n  dependencies:\n    \"@babel/helper-validator-identifier\" \"^7.14.5\"\n    chalk \"^2.0.0\"\n    js-tokens \"^4.0.0\"\n\n\"@cspotcode/source-map-support@^0.8.0\":\n  version \"0.8.1\"\n  resolved \"https://registry.npmjs.org/@cspotcode/source-map-support/-/source-map-support-0.8.1.tgz\"\n  integrity sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==\n  dependencies:\n    \"@jridgewell/trace-mapping\" \"0.3.9\"\n\n\"@jridgewell/resolve-uri@^3.0.3\":\n  version \"3.1.0\"\n  resolved \"https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.0.tgz\"\n  integrity sha512-F2msla3tad+Mfht5cJq7LSXcdudKTWCVYUgw6pLFOOHSTtZlj6SWNYAp+AhuqLmWdBO2X5hPrLcu8cVP8fy28w==\n\n\"@jridgewell/sourcemap-codec@^1.4.10\":\n  version \"1.4.14\"\n  resolved \"https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.4.14.tgz\"\n  integrity sha512-XPSJHWmi394fuUuzDnGz1wiKqWfo1yXecHQMRf2l6hztTO+nPru658AyDngaBe7isIxEkRsPR3FZh+s7iVa4Uw==\n\n\"@jridgewell/trace-mapping@0.3.9\":\n  version \"0.3.9\"\n  resolved \"https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.9.tgz\"\n  integrity sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==\n  dependencies:\n    \"@jridgewell/resolve-uri\" \"^3.0.3\"\n    \"@jridgewell/sourcemap-codec\" \"^1.4.10\"\n\n\"@tsconfig/node10@^1.0.7\":\n  version \"1.0.8\"\n  resolved \"https://registry.npmjs.org/@tsconfig/node10/-/node10-1.0.8.tgz\"\n  integrity sha512-6XFfSQmMgq0CFLY1MslA/CPUfhIL919M1rMsa5lP2P097N2Wd1sSX0tx1u4olM16fLNhtHZpRhedZJphNJqmZg==\n\n\"@tsconfig/node12@^1.0.7\":\n  version \"1.0.9\"\n  resolved \"https://registry.npmjs.org/@tsconfig/node12/-/node12-1.0.9.tgz\"\n  integrity sha512-/yBMcem+fbvhSREH+s14YJi18sp7J9jpuhYByADT2rypfajMZZN4WQ6zBGgBKp53NKmqI36wFYDb3yaMPurITw==\n\n\"@tsconfig/node14@^1.0.0\":\n  version \"1.0.1\"\n  resolved \"https://registry.npmjs.org/@tsconfig/node14/-/node14-1.0.1.tgz\"\n  integrity sha512-509r2+yARFfHHE7T6Puu2jjkoycftovhXRqW328PDXTVGKihlb1P8Z9mMZH04ebyajfRY7dedfGynlrFHJUQCg==\n\n\"@tsconfig/node16@^1.0.2\":\n  version \"1.0.2\"\n  resolved \"https://registry.npmjs.org/@tsconfig/node16/-/node16-1.0.2.tgz\"\n  integrity sha512-eZxlbI8GZscaGS7kkc/trHTT5xgrjH3/1n2JDwusC9iahPKWMRvRjJSAN5mCXviuTGQ/lHnhvv8Q1YTpnfz9gA==\n\n\"@types/chai@^4.2.21\":\n  version \"4.2.21\"\n  resolved \"https://registry.npmjs.org/@types/chai/-/chai-4.2.21.tgz\"\n  integrity sha512-yd+9qKmJxm496BOV9CMNaey8TWsikaZOwMRwPHQIjcOJM9oV+fi9ZMNw3JsVnbEEbo2gRTDnGEBv8pjyn67hNg==\n\n\"@types/glob@^7.1.4\":\n  version \"7.1.4\"\n  resolved \"https://registry.npmjs.org/@types/glob/-/glob-7.1.4.tgz\"\n  integrity sha512-w+LsMxKyYQm347Otw+IfBXOv9UWVjpHpCDdbBMt8Kz/xbvCYNjP+0qPh91Km3iKfSRLBB0P7fAMf0KHrPu+MyA==\n  dependencies:\n    \"@types/minimatch\" \"*\"\n    \"@types/node\" \"*\"\n\n\"@types/json-schema@^7.0.9\":\n  version \"7.0.9\"\n  resolved \"https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.9.tgz\"\n  integrity sha512-qcUXuemtEu+E5wZSJHNxUXeCZhAfXKQ41D+duX+VYPde7xyEVZci+/oXKJL13tnRs9lR2pr4fod59GT6/X1/yQ==\n\n\"@types/minimatch@*\":\n  version \"3.0.5\"\n  resolved \"https://registry.npmjs.org/@types/minimatch/-/minimatch-3.0.5.tgz\"\n  integrity sha512-Klz949h02Gz2uZCMGwDUSDS1YBlTdDDgbWHi+81l29tQALUtvz4rAYi5uoVhE5Lagoq6DeqAUlbrHvW/mXDgdQ==\n\n\"@types/mocha@^9.0.0\":\n  version \"9.0.0\"\n  resolved \"https://registry.npmjs.org/@types/mocha/-/mocha-9.0.0.tgz\"\n  integrity sha512-scN0hAWyLVAvLR9AyW7HoFF5sJZglyBsbPuHO4fv7JRvfmPBMfp1ozWqOf/e4wwPNxezBZXRfWzMb6iFLgEVRA==\n\n\"@types/node@*\":\n  version \"16.18.13\"\n  resolved \"https://registry.npmjs.org/@types/node/-/node-16.18.13.tgz\"\n  integrity sha512-l0/3XZ153UTlNOnZK8xSNoJlQda9/WnYgiTdcKKPJSZjdjI9MU+A9oMXOesAWLSnqAaaJhj3qfQsU07Dr8OUwg==\n\n\"@types/node@^18.11.9\":\n  version \"18.19.43\"\n  resolved \"https://registry.yarnpkg.com/@types/node/-/node-18.19.43.tgz#fe01bb599b60bb3279c26d0fdb751d2f3e299ae0\"\n  integrity sha512-Mw/YlgXnyJdEwLoFv2dpuJaDFriX+Pc+0qOBJ57jC1H6cDxIj2xc5yUrdtArDVG0m+KV6622a4p2tenEqB3C/g==\n  dependencies:\n    undici-types \"~5.26.4\"\n\n\"@ungap/promise-all-settled@1.1.2\":\n  version \"1.1.2\"\n  resolved \"https://registry.npmjs.org/@ungap/promise-all-settled/-/promise-all-settled-1.1.2.tgz\"\n  integrity sha512-sL/cEvJWAnClXw0wHk85/2L0G6Sj8UB0Ctc1TEMbKSsmpRosqhwj9gWgFRZSrBr2f9tiXISwNhCPmlfqUqyb9Q==\n\nacorn-walk@^8.1.1:\n  version \"8.2.0\"\n  resolved \"https://registry.npmjs.org/acorn-walk/-/acorn-walk-8.2.0.tgz\"\n  integrity sha512-k+iyHEuPgSw6SbuDpGQM+06HQUa04DZ3o+F6CSzXMvvI5KMvnaEqXe+YVe555R9nn6GPt404fos4wcgpw12SDA==\n\nacorn@^8.4.1:\n  version \"8.5.0\"\n  resolved \"https://registry.npmjs.org/acorn/-/acorn-8.5.0.tgz\"\n  integrity sha512-yXbYeFy+jUuYd3/CDcg2NkIYE991XYX/bje7LmjJigUciaeO1JR4XxXgCIV1/Zc/dRuFEyw1L0pbA+qynJkW5Q==\n\najv-formats@^2.1.1:\n  version \"2.1.1\"\n  resolved \"https://registry.npmjs.org/ajv-formats/-/ajv-formats-2.1.1.tgz\"\n  integrity sha512-Wx0Kx52hxE7C18hkMEggYlEifqWZtYaRgouJor+WMdPnQyEK13vgEWyVNup7SoeeoLMsr4kf5h6dOW11I15MUA==\n  dependencies:\n    ajv \"^8.0.0\"\n\najv@^8.0.0, ajv@^8.6.3:\n  version \"8.6.3\"\n  resolved \"https://registry.npmjs.org/ajv/-/ajv-8.6.3.tgz\"\n  integrity sha512-SMJOdDP6LqTkD0Uq8qLi+gMwSt0imXLSV080qFVwJCpH9U6Mb+SUGHAXM0KNbcBPguytWyvFxcHgMLe2D2XSpw==\n  dependencies:\n    fast-deep-equal \"^3.1.1\"\n    json-schema-traverse \"^1.0.0\"\n    require-from-string \"^2.0.2\"\n    uri-js \"^4.2.2\"\n\nansi-colors@4.1.1:\n  version \"4.1.1\"\n  resolved \"https://registry.npmjs.org/ansi-colors/-/ansi-colors-4.1.1.tgz\"\n  integrity sha512-JoX0apGbHaUJBNl6yF+p6JAFYZ666/hhCGKN5t9QFjbJQKUU/g8MNbFDbvfrgKXvI1QpZplPOnwIo99lX/AAmA==\n\nansi-regex@^5.0.0:\n  version \"5.0.1\"\n  resolved \"https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz\"\n  integrity sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==\n\nansi-styles@^3.2.1:\n  version \"3.2.1\"\n  resolved \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz\"\n  integrity sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==\n  dependencies:\n    color-convert \"^1.9.0\"\n\nansi-styles@^4.0.0, ansi-styles@^4.1.0:\n  version \"4.3.0\"\n  resolved \"https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz\"\n  integrity sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==\n  dependencies:\n    color-convert \"^2.0.1\"\n\nanymatch@~3.1.2:\n  version \"3.1.2\"\n  resolved \"https://registry.npmjs.org/anymatch/-/anymatch-3.1.2.tgz\"\n  integrity sha512-P43ePfOAIupkguHUycrc4qJ9kz8ZiuOUijaETwX7THt0Y/GNK7v0aa8rY816xWjZ7rJdA5XdMcpVFTKMq+RvWg==\n  dependencies:\n    normalize-path \"^3.0.0\"\n    picomatch \"^2.0.4\"\n\narg@^4.1.0:\n  version \"4.1.3\"\n  resolved \"https://registry.npmjs.org/arg/-/arg-4.1.3.tgz\"\n  integrity sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==\n\nargparse@^1.0.7:\n  version \"1.0.10\"\n  resolved \"https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz\"\n  integrity sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==\n  dependencies:\n    sprintf-js \"~1.0.2\"\n\nargparse@^2.0.1:\n  version \"2.0.1\"\n  resolved \"https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz\"\n  integrity sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==\n\nassertion-error@^1.1.0:\n  version \"1.1.0\"\n  resolved \"https://registry.npmjs.org/assertion-error/-/assertion-error-1.1.0.tgz\"\n  integrity sha512-jgsaNduz+ndvGyFt3uSuWqvy4lCnIJiovtouQN5JZHOKCS2QuhEdbcQHFhVksz2N2U9hXJo8odG7ETyWlEeuDw==\n\nbalanced-match@^1.0.0:\n  version \"1.0.2\"\n  resolved \"https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz\"\n  integrity sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==\n\nbinary-extensions@^2.0.0:\n  version \"2.2.0\"\n  resolved \"https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.2.0.tgz\"\n  integrity sha512-jDctJ/IVQbZoJykoeHbhXpOlNBqGNcwXJKJog42E5HDPUwQTSdjCHdihjj0DlnheQ7blbT6dHOafNAiS8ooQKA==\n\nbrace-expansion@^1.1.7:\n  version \"1.1.11\"\n  resolved \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\"\n  integrity sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\n  dependencies:\n    balanced-match \"^1.0.0\"\n    concat-map \"0.0.1\"\n\nbraces@~3.0.2:\n  version \"3.0.2\"\n  resolved \"https://registry.npmjs.org/braces/-/braces-3.0.2.tgz\"\n  integrity sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==\n  dependencies:\n    fill-range \"^7.0.1\"\n\nbrowser-stdout@1.3.1:\n  version \"1.3.1\"\n  resolved \"https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.1.tgz\"\n  integrity sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw==\n\nbuffer-from@^1.0.0:\n  version \"1.1.2\"\n  resolved \"https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz\"\n  integrity sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==\n\nbuiltin-modules@^1.1.1:\n  version \"1.1.1\"\n  resolved \"https://registry.npmjs.org/builtin-modules/-/builtin-modules-1.1.1.tgz\"\n  integrity sha1-Jw8HbFpywC9bZaR9+Uxf46J4iS8=\n\ncamelcase@^6.0.0:\n  version \"6.2.0\"\n  resolved \"https://registry.npmjs.org/camelcase/-/camelcase-6.2.0.tgz\"\n  integrity sha512-c7wVvbw3f37nuobQNtgsgG9POC9qMbNuMQmTCqZv23b6MIz0fcYpBiOlv9gEN/hdLdnZTDQhg6e9Dq5M1vKvfg==\n\nchai@^4.3.4:\n  version \"4.3.4\"\n  resolved \"https://registry.npmjs.org/chai/-/chai-4.3.4.tgz\"\n  integrity sha512-yS5H68VYOCtN1cjfwumDSuzn/9c+yza4f3reKXlE5rUg7SFcCEy90gJvydNgOYtblyf4Zi6jIWRnXOgErta0KA==\n  dependencies:\n    assertion-error \"^1.1.0\"\n    check-error \"^1.0.2\"\n    deep-eql \"^3.0.1\"\n    get-func-name \"^2.0.0\"\n    pathval \"^1.1.1\"\n    type-detect \"^4.0.5\"\n\nchalk@^2.0.0, chalk@^2.3.0:\n  version \"2.4.2\"\n  resolved \"https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz\"\n  integrity sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==\n  dependencies:\n    ansi-styles \"^3.2.1\"\n    escape-string-regexp \"^1.0.5\"\n    supports-color \"^5.3.0\"\n\nchalk@^4.1.0:\n  version \"4.1.2\"\n  resolved \"https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz\"\n  integrity sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==\n  dependencies:\n    ansi-styles \"^4.1.0\"\n    supports-color \"^7.1.0\"\n\ncheck-error@^1.0.2:\n  version \"1.0.2\"\n  resolved \"https://registry.npmjs.org/check-error/-/check-error-1.0.2.tgz\"\n  integrity sha1-V00xLt2Iu13YkS6Sht1sCu1KrII=\n\nchokidar@3.5.2:\n  version \"3.5.2\"\n  resolved \"https://registry.npmjs.org/chokidar/-/chokidar-3.5.2.tgz\"\n  integrity sha512-ekGhOnNVPgT77r4K/U3GDhu+FQ2S8TnK/s2KbIGXi0SZWuwkZ2QNyfWdZW+TVfn84DpEP7rLeCt2UI6bJ8GwbQ==\n  dependencies:\n    anymatch \"~3.1.2\"\n    braces \"~3.0.2\"\n    glob-parent \"~5.1.2\"\n    is-binary-path \"~2.1.0\"\n    is-glob \"~4.0.1\"\n    normalize-path \"~3.0.0\"\n    readdirp \"~3.6.0\"\n  optionalDependencies:\n    fsevents \"~2.3.2\"\n\ncliui@^7.0.2:\n  version \"7.0.4\"\n  resolved \"https://registry.npmjs.org/cliui/-/cliui-7.0.4.tgz\"\n  integrity sha512-OcRE68cOsVMXp1Yvonl/fzkQOyjLSu/8bhPDfQt0e0/Eb283TKP20Fs2MqoPsr9SwA595rRCA+QMzYc9nBP+JQ==\n  dependencies:\n    string-width \"^4.2.0\"\n    strip-ansi \"^6.0.0\"\n    wrap-ansi \"^7.0.0\"\n\ncolor-convert@^1.9.0:\n  version \"1.9.3\"\n  resolved \"https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz\"\n  integrity sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==\n  dependencies:\n    color-name \"1.1.3\"\n\ncolor-convert@^2.0.1:\n  version \"2.0.1\"\n  resolved \"https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz\"\n  integrity sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==\n  dependencies:\n    color-name \"~1.1.4\"\n\ncolor-name@1.1.3:\n  version \"1.1.3\"\n  resolved \"https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz\"\n  integrity sha1-p9BVi9icQveV3UIyj3QIMcpTvCU=\n\ncolor-name@~1.1.4:\n  version \"1.1.4\"\n  resolved \"https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz\"\n  integrity sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==\n\ncommander@^2.12.1:\n  version \"2.20.3\"\n  resolved \"https://registry.npmjs.org/commander/-/commander-2.20.3.tgz\"\n  integrity sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==\n\nconcat-map@0.0.1:\n  version \"0.0.1\"\n  resolved \"https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz\"\n  integrity sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=\n\ncreate-require@^1.1.0:\n  version \"1.1.1\"\n  resolved \"https://registry.npmjs.org/create-require/-/create-require-1.1.1.tgz\"\n  integrity sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==\n\ndebug@4.3.2:\n  version \"4.3.2\"\n  resolved \"https://registry.npmjs.org/debug/-/debug-4.3.2.tgz\"\n  integrity sha512-mOp8wKcvj7XxC78zLgw/ZA+6TSgkoE2C/ienthhRD298T7UNwAg9diBpLRxC0mOezLl4B0xV7M0cCO6P/O0Xhw==\n  dependencies:\n    ms \"2.1.2\"\n\ndecamelize@^4.0.0:\n  version \"4.0.0\"\n  resolved \"https://registry.npmjs.org/decamelize/-/decamelize-4.0.0.tgz\"\n  integrity sha512-9iE1PgSik9HeIIw2JO94IidnE3eBoQrFJ3w7sFuzSX4DpmZ3v5sZpUiV5Swcf6mQEF+Y0ru8Neo+p+nyh2J+hQ==\n\ndeep-eql@^3.0.1:\n  version \"3.0.1\"\n  resolved \"https://registry.npmjs.org/deep-eql/-/deep-eql-3.0.1.tgz\"\n  integrity sha512-+QeIQyN5ZuO+3Uk5DYh6/1eKO0m0YmJFGNmFHGACpf1ClL1nmlV/p4gNgbl2pJGxgXb4faqo6UE+M5ACEMyVcw==\n  dependencies:\n    type-detect \"^4.0.0\"\n\ndiff@5.0.0:\n  version \"5.0.0\"\n  resolved \"https://registry.npmjs.org/diff/-/diff-5.0.0.tgz\"\n  integrity sha512-/VTCrvm5Z0JGty/BWHljh+BAiw3IK+2j87NGMu8Nwc/f48WoDAC395uomO9ZD117ZOBaHmkX1oyLvkVM/aIT3w==\n\ndiff@^4.0.1:\n  version \"4.0.2\"\n  resolved \"https://registry.npmjs.org/diff/-/diff-4.0.2.tgz\"\n  integrity sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==\n\nemoji-regex@^8.0.0:\n  version \"8.0.0\"\n  resolved \"https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz\"\n  integrity sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==\n\nescalade@^3.1.1:\n  version \"3.1.1\"\n  resolved \"https://registry.npmjs.org/escalade/-/escalade-3.1.1.tgz\"\n  integrity sha512-k0er2gUkLf8O0zKJiAhmkTnJlTvINGv7ygDNPbeIsX/TJjGJZHuh9B2UxbsaEkmlEo9MfhrSzmhIlhRlI2GXnw==\n\nescape-string-regexp@4.0.0:\n  version \"4.0.0\"\n  resolved \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz\"\n  integrity sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==\n\nescape-string-regexp@^1.0.5:\n  version \"1.0.5\"\n  resolved \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz\"\n  integrity sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=\n\nesprima@^4.0.0:\n  version \"4.0.1\"\n  resolved \"https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz\"\n  integrity sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==\n\nfast-deep-equal@^3.1.1:\n  version \"3.1.3\"\n  resolved \"https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz\"\n  integrity sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==\n\nfill-range@^7.0.1:\n  version \"7.0.1\"\n  resolved \"https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz\"\n  integrity sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==\n  dependencies:\n    to-regex-range \"^5.0.1\"\n\nfind-up@5.0.0:\n  version \"5.0.0\"\n  resolved \"https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz\"\n  integrity sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==\n  dependencies:\n    locate-path \"^6.0.0\"\n    path-exists \"^4.0.0\"\n\nflat@^5.0.2:\n  version \"5.0.2\"\n  resolved \"https://registry.npmjs.org/flat/-/flat-5.0.2.tgz\"\n  integrity sha512-b6suED+5/3rTpUBdG1gupIl8MPFCAMA0QXwmljLhvCUKcUvdE4gWky9zpuGCcXHOsz4J9wPGNWq6OKpmIzz3hQ==\n\nfs.realpath@^1.0.0:\n  version \"1.0.0\"\n  resolved \"https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz\"\n  integrity sha1-FQStJSMVjKpA20onh8sBQRmU6k8=\n\nfsevents@~2.3.2:\n  version \"2.3.2\"\n  resolved \"https://registry.yarnpkg.com/fsevents/-/fsevents-2.3.2.tgz#8a526f78b8fdf4623b709e0b975c52c24c02fd1a\"\n  integrity sha512-xiqMQR4xAeHTuB9uWm+fFRcIOgKBMiOBP+eXiyT7jsgVCq1bkVygt00oASowB7EdtpOHaaPgKt812P9ab+DDKA==\n\nfunction-bind@^1.1.1:\n  version \"1.1.1\"\n  resolved \"https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz\"\n  integrity sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A==\n\nget-caller-file@^2.0.5:\n  version \"2.0.5\"\n  resolved \"https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz\"\n  integrity sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==\n\nget-func-name@^2.0.0:\n  version \"2.0.0\"\n  resolved \"https://registry.npmjs.org/get-func-name/-/get-func-name-2.0.0.tgz\"\n  integrity sha1-6td0q+5y4gQJQzoGY2YCPdaIekE=\n\nglob-parent@~5.1.2:\n  version \"5.1.2\"\n  resolved \"https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz\"\n  integrity sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==\n  dependencies:\n    is-glob \"^4.0.1\"\n\nglob@7.1.7, glob@^7.1.1, glob@^7.1.7:\n  version \"7.1.7\"\n  resolved \"https://registry.npmjs.org/glob/-/glob-7.1.7.tgz\"\n  integrity sha512-OvD9ENzPLbegENnYP5UUfJIirTg4+XwMWGaQfQTY0JenxNvvIKP3U3/tAQSPIu/lHxXYSZmpXlUHeqAIdKzBLQ==\n  dependencies:\n    fs.realpath \"^1.0.0\"\n    inflight \"^1.0.4\"\n    inherits \"2\"\n    minimatch \"^3.0.4\"\n    once \"^1.3.0\"\n    path-is-absolute \"^1.0.0\"\n\ngrowl@1.10.5:\n  version \"1.10.5\"\n  resolved \"https://registry.npmjs.org/growl/-/growl-1.10.5.tgz\"\n  integrity sha512-qBr4OuELkhPenW6goKVXiv47US3clb3/IbuWF9KNKEijAy9oeHxU9IgzjvJhHkUzhaj7rOUD7+YGWqUjLp5oSA==\n\nhas-flag@^3.0.0:\n  version \"3.0.0\"\n  resolved \"https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz\"\n  integrity sha1-tdRU3CGZriJWmfNGfloH87lVuv0=\n\nhas-flag@^4.0.0:\n  version \"4.0.0\"\n  resolved \"https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz\"\n  integrity sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==\n\nhas@^1.0.3:\n  version \"1.0.3\"\n  resolved \"https://registry.npmjs.org/has/-/has-1.0.3.tgz\"\n  integrity sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==\n  dependencies:\n    function-bind \"^1.1.1\"\n\nhe@1.2.0:\n  version \"1.2.0\"\n  resolved \"https://registry.npmjs.org/he/-/he-1.2.0.tgz\"\n  integrity sha512-F/1DnUGPopORZi0ni+CvrCgHQ5FyEAHRLSApuYWMmrbSwoN2Mn/7k+Gl38gJnR7yyDZk6WLXwiGod1JOWNDKGw==\n\ninflight@^1.0.4:\n  version \"1.0.6\"\n  resolved \"https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz\"\n  integrity sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\n  dependencies:\n    once \"^1.3.0\"\n    wrappy \"1\"\n\ninherits@2:\n  version \"2.0.4\"\n  resolved \"https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz\"\n  integrity sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==\n\nis-binary-path@~2.1.0:\n  version \"2.1.0\"\n  resolved \"https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz\"\n  integrity sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==\n  dependencies:\n    binary-extensions \"^2.0.0\"\n\nis-core-module@^2.2.0:\n  version \"2.6.0\"\n  resolved \"https://registry.npmjs.org/is-core-module/-/is-core-module-2.6.0.tgz\"\n  integrity sha512-wShG8vs60jKfPWpF2KZRaAtvt3a20OAn7+IJ6hLPECpSABLcKtFKTTI4ZtH5QcBruBHlq+WsdHWyz0BCZW7svQ==\n  dependencies:\n    has \"^1.0.3\"\n\nis-extglob@^2.1.1:\n  version \"2.1.1\"\n  resolved \"https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz\"\n  integrity sha1-qIwCU1eR8C7TfHahueqXc8gz+MI=\n\nis-fullwidth-code-point@^3.0.0:\n  version \"3.0.0\"\n  resolved \"https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz\"\n  integrity sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==\n\nis-glob@^4.0.1, is-glob@~4.0.1:\n  version \"4.0.1\"\n  resolved \"https://registry.npmjs.org/is-glob/-/is-glob-4.0.1.tgz\"\n  integrity sha512-5G0tKtBTFImOqDnLB2hG6Bp2qcKEFduo4tZu9MT/H6NQv/ghhy30o55ufafxJ/LdH79LLs2Kfrn85TLKyA7BUg==\n  dependencies:\n    is-extglob \"^2.1.1\"\n\nis-number@^7.0.0:\n  version \"7.0.0\"\n  resolved \"https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz\"\n  integrity sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==\n\nis-plain-obj@^2.1.0:\n  version \"2.1.0\"\n  resolved \"https://registry.npmjs.org/is-plain-obj/-/is-plain-obj-2.1.0.tgz\"\n  integrity sha512-YWnfyRwxL/+SsrWYfOpUtz5b3YD+nyfkHvjbcanzk8zgyO4ASD67uVMRt8k5bM4lLMDnXfriRhOpemw+NfT1eA==\n\nis-unicode-supported@^0.1.0:\n  version \"0.1.0\"\n  resolved \"https://registry.npmjs.org/is-unicode-supported/-/is-unicode-supported-0.1.0.tgz\"\n  integrity sha512-knxG2q4UC3u8stRGyAVJCOdxFmv5DZiRcdlIaAQXAbSfJya+OhopNotLQrstBhququ4ZpuKbDc/8S6mgXgPFPw==\n\nisexe@^2.0.0:\n  version \"2.0.0\"\n  resolved \"https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz\"\n  integrity sha1-6PvzdNxVb/iUehDcsFctYz8s+hA=\n\njs-tokens@^4.0.0:\n  version \"4.0.0\"\n  resolved \"https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz\"\n  integrity sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==\n\njs-yaml@4.1.0:\n  version \"4.1.0\"\n  resolved \"https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz\"\n  integrity sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==\n  dependencies:\n    argparse \"^2.0.1\"\n\njs-yaml@^3.13.1:\n  version \"3.14.1\"\n  resolved \"https://registry.npmjs.org/js-yaml/-/js-yaml-3.14.1.tgz\"\n  integrity sha512-okMH7OXXJ7YrN9Ok3/SXrnu4iX9yOk+25nqX4imS2npuvTYDmo/QEZoqwZkYaIDk3jVvBOTOIEgEhaLOynBS9g==\n  dependencies:\n    argparse \"^1.0.7\"\n    esprima \"^4.0.0\"\n\njson-schema-traverse@^1.0.0:\n  version \"1.0.0\"\n  resolved \"https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz\"\n  integrity sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==\n\nlocate-path@^6.0.0:\n  version \"6.0.0\"\n  resolved \"https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz\"\n  integrity sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==\n  dependencies:\n    p-locate \"^5.0.0\"\n\nlog-symbols@4.1.0:\n  version \"4.1.0\"\n  resolved \"https://registry.npmjs.org/log-symbols/-/log-symbols-4.1.0.tgz\"\n  integrity sha512-8XPvpAA8uyhfteu8pIvQxpJZ7SYYdpUivZpGy6sFsBuKRY/7rQGavedeB8aK+Zkyq6upMFVL/9AW6vOYzfRyLg==\n  dependencies:\n    chalk \"^4.1.0\"\n    is-unicode-supported \"^0.1.0\"\n\nmake-error@^1.1.1:\n  version \"1.3.6\"\n  resolved \"https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz\"\n  integrity sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==\n\nminimatch@3.0.4, minimatch@^3.0.4:\n  version \"3.0.4\"\n  resolved \"https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz\"\n  integrity sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==\n  dependencies:\n    brace-expansion \"^1.1.7\"\n\nminimist@^1.2.5:\n  version \"1.2.5\"\n  resolved \"https://registry.npmjs.org/minimist/-/minimist-1.2.5.tgz\"\n  integrity sha512-FM9nNUYrRBAELZQT3xeZQ7fmMOBg6nWNmJKTcgsJeaLstP/UODVpGsr5OhXhhXg6f+qtJ8uiZ+PUxkDWcgIXLw==\n\nmkdirp@^0.5.3:\n  version \"0.5.5\"\n  resolved \"https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.5.tgz\"\n  integrity sha512-NKmAlESf6jMGym1++R0Ra7wvhV+wFW63FaSOFPwRahvea0gMUcGUhVeAg/0BC0wiv9ih5NYPB1Wn1UEI1/L+xQ==\n  dependencies:\n    minimist \"^1.2.5\"\n\nmocha@^9.1.3:\n  version \"9.1.3\"\n  resolved \"https://registry.npmjs.org/mocha/-/mocha-9.1.3.tgz\"\n  integrity sha512-Xcpl9FqXOAYqI3j79pEtHBBnQgVXIhpULjGQa7DVb0Po+VzmSIK9kanAiWLHoRR/dbZ2qpdPshuXr8l1VaHCzw==\n  dependencies:\n    \"@ungap/promise-all-settled\" \"1.1.2\"\n    ansi-colors \"4.1.1\"\n    browser-stdout \"1.3.1\"\n    chokidar \"3.5.2\"\n    debug \"4.3.2\"\n    diff \"5.0.0\"\n    escape-string-regexp \"4.0.0\"\n    find-up \"5.0.0\"\n    glob \"7.1.7\"\n    growl \"1.10.5\"\n    he \"1.2.0\"\n    js-yaml \"4.1.0\"\n    log-symbols \"4.1.0\"\n    minimatch \"3.0.4\"\n    ms \"2.1.3\"\n    nanoid \"3.1.25\"\n    serialize-javascript \"6.0.0\"\n    strip-json-comments \"3.1.1\"\n    supports-color \"8.1.1\"\n    which \"2.0.2\"\n    workerpool \"6.1.5\"\n    yargs \"16.2.0\"\n    yargs-parser \"20.2.4\"\n    yargs-unparser \"2.0.0\"\n\nms@2.1.2:\n  version \"2.1.2\"\n  resolved \"https://registry.npmjs.org/ms/-/ms-2.1.2.tgz\"\n  integrity sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==\n\nms@2.1.3:\n  version \"2.1.3\"\n  resolved \"https://registry.npmjs.org/ms/-/ms-2.1.3.tgz\"\n  integrity sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==\n\nnanoid@3.1.25:\n  version \"3.1.25\"\n  resolved \"https://registry.npmjs.org/nanoid/-/nanoid-3.1.25.tgz\"\n  integrity sha512-rdwtIXaXCLFAQbnfqDRnI6jaRHp9fTcYBjtFKE8eezcZ7LuLjhUaQGNeMXf1HmRoCH32CLz6XwX0TtxEOS/A3Q==\n\nnormalize-path@^3.0.0, normalize-path@~3.0.0:\n  version \"3.0.0\"\n  resolved \"https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz\"\n  integrity sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==\n\nonce@^1.3.0:\n  version \"1.4.0\"\n  resolved \"https://registry.npmjs.org/once/-/once-1.4.0.tgz\"\n  integrity sha1-WDsap3WWHUsROsF9nFC6753Xa9E=\n  dependencies:\n    wrappy \"1\"\n\np-limit@^3.0.2:\n  version \"3.1.0\"\n  resolved \"https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz\"\n  integrity sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==\n  dependencies:\n    yocto-queue \"^0.1.0\"\n\np-locate@^5.0.0:\n  version \"5.0.0\"\n  resolved \"https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz\"\n  integrity sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==\n  dependencies:\n    p-limit \"^3.0.2\"\n\npath-equal@^1.2.5:\n  version \"1.2.5\"\n  resolved \"https://registry.yarnpkg.com/path-equal/-/path-equal-1.2.5.tgz#9fcbdd5e5daee448e96f43f3bac06c666b5e982a\"\n  integrity sha512-i73IctDr3F2W+bsOWDyyVm/lqsXO47aY9nsFZUjTT/aljSbkxHxxCoyZ9UUrM8jK0JVod+An+rl48RCsvWM+9g==\n\npath-exists@^4.0.0:\n  version \"4.0.0\"\n  resolved \"https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz\"\n  integrity sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==\n\npath-is-absolute@^1.0.0:\n  version \"1.0.1\"\n  resolved \"https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz\"\n  integrity sha1-F0uSaHNVNP+8es5r9TpanhtcX18=\n\npath-parse@^1.0.6:\n  version \"1.0.7\"\n  resolved \"https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz\"\n  integrity sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==\n\npathval@^1.1.1:\n  version \"1.1.1\"\n  resolved \"https://registry.npmjs.org/pathval/-/pathval-1.1.1.tgz\"\n  integrity sha512-Dp6zGqpTdETdR63lehJYPeIOqpiNBNtc7BpWSLrOje7UaIsE5aY92r/AunQA7rsXvet3lrJ3JnZX29UPTKXyKQ==\n\npicomatch@^2.0.4, picomatch@^2.2.1:\n  version \"2.3.0\"\n  resolved \"https://registry.npmjs.org/picomatch/-/picomatch-2.3.0.tgz\"\n  integrity sha512-lY1Q/PiJGC2zOv/z391WOTD+Z02bCgsFfvxoXXf6h7kv9o+WmsmzYqrAwY63sNgOxE4xEdq0WyUnXfKeBrSvYw==\n\nprettier@^2.4.1:\n  version \"2.4.1\"\n  resolved \"https://registry.npmjs.org/prettier/-/prettier-2.4.1.tgz\"\n  integrity sha512-9fbDAXSBcc6Bs1mZrDYb3XKzDLm4EXXL9sC1LqKP5rZkT6KRr/rf9amVUcODVXgguK/isJz0d0hP72WeaKWsvA==\n\npunycode@^2.1.0:\n  version \"2.1.1\"\n  resolved \"https://registry.npmjs.org/punycode/-/punycode-2.1.1.tgz\"\n  integrity sha512-XRsRjdf+j5ml+y/6GKHPZbrF/8p2Yga0JPtdqTIY2Xe5ohJPD9saDJJLPvp9+NSBprVvevdXZybnj2cv8OEd0A==\n\nrandombytes@^2.1.0:\n  version \"2.1.0\"\n  resolved \"https://registry.npmjs.org/randombytes/-/randombytes-2.1.0.tgz\"\n  integrity sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==\n  dependencies:\n    safe-buffer \"^5.1.0\"\n\nreaddirp@~3.6.0:\n  version \"3.6.0\"\n  resolved \"https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz\"\n  integrity sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==\n  dependencies:\n    picomatch \"^2.2.1\"\n\nrequire-directory@^2.1.1:\n  version \"2.1.1\"\n  resolved \"https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz\"\n  integrity sha1-jGStX9MNqxyXbiNE/+f3kqam30I=\n\nrequire-from-string@^2.0.2:\n  version \"2.0.2\"\n  resolved \"https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz\"\n  integrity sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==\n\nresolve@^1.3.2:\n  version \"1.20.0\"\n  resolved \"https://registry.npmjs.org/resolve/-/resolve-1.20.0.tgz\"\n  integrity sha512-wENBPt4ySzg4ybFQW2TT1zMQucPK95HSh/nq2CFTZVOGut2+pQvSsgtda4d26YrYcr067wjbmzOG8byDPBX63A==\n  dependencies:\n    is-core-module \"^2.2.0\"\n    path-parse \"^1.0.6\"\n\nsafe-buffer@^5.1.0:\n  version \"5.2.1\"\n  resolved \"https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz\"\n  integrity sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==\n\nsafe-stable-stringify@^2.2.0:\n  version \"2.2.0\"\n  resolved \"https://registry.npmjs.org/safe-stable-stringify/-/safe-stable-stringify-2.2.0.tgz\"\n  integrity sha512-C6AuMdYPuPV/P1leplHNu0lgc2LAElq/g3TdoksDCIVtBhr78o/CH03bt/9SKqugFbKU9CUjsNlCu0fjtQzQUw==\n\nsemver@^5.3.0:\n  version \"5.7.1\"\n  resolved \"https://registry.npmjs.org/semver/-/semver-5.7.1.tgz\"\n  integrity sha512-sauaDf/PZdVgrLTNYHRtpXa1iRiKcaebiKQ1BJdpQlWH2lCvexQdX55snPFyK7QzpudqbCI0qXFfOasHdyNDGQ==\n\nserialize-javascript@6.0.0:\n  version \"6.0.0\"\n  resolved \"https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-6.0.0.tgz\"\n  integrity sha512-Qr3TosvguFt8ePWqsvRfrKyQXIiW+nGbYpy8XK24NQHE83caxWt+mIymTT19DGFbNWNLfEwsrkSmN64lVWB9ag==\n  dependencies:\n    randombytes \"^2.1.0\"\n\nsource-map-support@^0.5.20:\n  version \"0.5.20\"\n  resolved \"https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.20.tgz\"\n  integrity sha512-n1lZZ8Ve4ksRqizaBQgxXDgKwttHDhyfQjA6YZZn8+AroHbsIz+JjwxQDxbp+7y5OYCI8t1Yk7etjD9CRd2hIw==\n  dependencies:\n    buffer-from \"^1.0.0\"\n    source-map \"^0.6.0\"\n\nsource-map@^0.6.0:\n  version \"0.6.1\"\n  resolved \"https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz\"\n  integrity sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==\n\nsprintf-js@~1.0.2:\n  version \"1.0.3\"\n  resolved \"https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.0.3.tgz\"\n  integrity sha1-BOaSb2YolTVPPdAVIDYzuFcpfiw=\n\nstring-width@^4.1.0, string-width@^4.2.0:\n  version \"4.2.2\"\n  resolved \"https://registry.npmjs.org/string-width/-/string-width-4.2.2.tgz\"\n  integrity sha512-XBJbT3N4JhVumXE0eoLU9DCjcaF92KLNqTmFCnG1pf8duUxFGwtP6AD6nkjw9a3IdiRtL3E2w3JDiE/xi3vOeA==\n  dependencies:\n    emoji-regex \"^8.0.0\"\n    is-fullwidth-code-point \"^3.0.0\"\n    strip-ansi \"^6.0.0\"\n\nstrip-ansi@^6.0.0:\n  version \"6.0.0\"\n  resolved \"https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.0.tgz\"\n  integrity sha512-AuvKTrTfQNYNIctbR1K/YGTR1756GycPsg7b9bdV9Duqur4gv6aKqHXah67Z8ImS7WEz5QVcOtlfW2rZEugt6w==\n  dependencies:\n    ansi-regex \"^5.0.0\"\n\nstrip-json-comments@3.1.1:\n  version \"3.1.1\"\n  resolved \"https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz\"\n  integrity sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==\n\nsupports-color@8.1.1:\n  version \"8.1.1\"\n  resolved \"https://registry.npmjs.org/supports-color/-/supports-color-8.1.1.tgz\"\n  integrity sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==\n  dependencies:\n    has-flag \"^4.0.0\"\n\nsupports-color@^5.3.0:\n  version \"5.5.0\"\n  resolved \"https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz\"\n  integrity sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==\n  dependencies:\n    has-flag \"^3.0.0\"\n\nsupports-color@^7.1.0:\n  version \"7.2.0\"\n  resolved \"https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz\"\n  integrity sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==\n  dependencies:\n    has-flag \"^4.0.0\"\n\nto-regex-range@^5.0.1:\n  version \"5.0.1\"\n  resolved \"https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz\"\n  integrity sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==\n  dependencies:\n    is-number \"^7.0.0\"\n\nts-node@^10.9.1:\n  version \"10.9.1\"\n  resolved \"https://registry.npmjs.org/ts-node/-/ts-node-10.9.1.tgz\"\n  integrity sha512-NtVysVPkxxrwFGUUxGYhfux8k78pQB3JqYBXlLRZgdGUqTO5wU/UyHop5p70iEbGhB7q5KmiZiU0Y3KlJrScEw==\n  dependencies:\n    \"@cspotcode/source-map-support\" \"^0.8.0\"\n    \"@tsconfig/node10\" \"^1.0.7\"\n    \"@tsconfig/node12\" \"^1.0.7\"\n    \"@tsconfig/node14\" \"^1.0.0\"\n    \"@tsconfig/node16\" \"^1.0.2\"\n    acorn \"^8.4.1\"\n    acorn-walk \"^8.1.1\"\n    arg \"^4.1.0\"\n    create-require \"^1.1.0\"\n    diff \"^4.0.1\"\n    make-error \"^1.1.1\"\n    v8-compile-cache-lib \"^3.0.1\"\n    yn \"3.1.1\"\n\ntslib@^1.13.0, tslib@^1.8.1:\n  version \"1.14.1\"\n  resolved \"https://registry.npmjs.org/tslib/-/tslib-1.14.1.tgz\"\n  integrity sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==\n\ntslint@^6.1.3:\n  version \"6.1.3\"\n  resolved \"https://registry.npmjs.org/tslint/-/tslint-6.1.3.tgz\"\n  integrity sha512-IbR4nkT96EQOvKE2PW/djGz8iGNeJ4rF2mBfiYaR/nvUWYKJhLwimoJKgjIFEIDibBtOevj7BqCRL4oHeWWUCg==\n  dependencies:\n    \"@babel/code-frame\" \"^7.0.0\"\n    builtin-modules \"^1.1.1\"\n    chalk \"^2.3.0\"\n    commander \"^2.12.1\"\n    diff \"^4.0.1\"\n    glob \"^7.1.1\"\n    js-yaml \"^3.13.1\"\n    minimatch \"^3.0.4\"\n    mkdirp \"^0.5.3\"\n    resolve \"^1.3.2\"\n    semver \"^5.3.0\"\n    tslib \"^1.13.0\"\n    tsutils \"^2.29.0\"\n\ntsutils@^2.29.0:\n  version \"2.29.0\"\n  resolved \"https://registry.npmjs.org/tsutils/-/tsutils-2.29.0.tgz\"\n  integrity sha512-g5JVHCIJwzfISaXpXE1qvNalca5Jwob6FjI4AoPlqMusJ6ftFE7IkkFoMhVLRgK+4Kx3gkzb8UZK5t5yTTvEmA==\n  dependencies:\n    tslib \"^1.8.1\"\n\ntype-detect@^4.0.0, type-detect@^4.0.5:\n  version \"4.0.8\"\n  resolved \"https://registry.npmjs.org/type-detect/-/type-detect-4.0.8.tgz\"\n  integrity sha512-0fr/mIH1dlO+x7TlcMy+bIDqKPsw/70tVyeHW787goQjhmqaZe10uwLujubK9q9Lg6Fiho1KUKDYz0Z7k7g5/g==\n\ntypescript@~5.5.0:\n  version \"5.5.4\"\n  resolved \"https://registry.yarnpkg.com/typescript/-/typescript-5.5.4.tgz#d9852d6c82bad2d2eda4fd74a5762a8f5909e9ba\"\n  integrity sha512-Mtq29sKDAEYP7aljRgtPOpTvOfbwRWlS6dPRzwjdE+C0R4brX/GUyhHSecbHMFLNBLcJIPt9nl9yG5TZ1weH+Q==\n\nundici-types@~5.26.4:\n  version \"5.26.5\"\n  resolved \"https://registry.yarnpkg.com/undici-types/-/undici-types-5.26.5.tgz#bcd539893d00b56e964fd2657a4866b221a65617\"\n  integrity sha512-JlCMO+ehdEIKqlFxk6IfVoAUVmgz7cU7zD/h9XZ0qzeosSHmUJVOzSQvvYSYWXkFXC+IfLKSIffhv0sVZup6pA==\n\nuri-js@^4.2.2:\n  version \"4.4.1\"\n  resolved \"https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz\"\n  integrity sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==\n  dependencies:\n    punycode \"^2.1.0\"\n\nv8-compile-cache-lib@^3.0.1:\n  version \"3.0.1\"\n  resolved \"https://registry.npmjs.org/v8-compile-cache-lib/-/v8-compile-cache-lib-3.0.1.tgz\"\n  integrity sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==\n\nwhich@2.0.2:\n  version \"2.0.2\"\n  resolved \"https://registry.npmjs.org/which/-/which-2.0.2.tgz\"\n  integrity sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==\n  dependencies:\n    isexe \"^2.0.0\"\n\nworkerpool@6.1.5:\n  version \"6.1.5\"\n  resolved \"https://registry.npmjs.org/workerpool/-/workerpool-6.1.5.tgz\"\n  integrity sha512-XdKkCK0Zqc6w3iTxLckiuJ81tiD/o5rBE/m+nXpRCB+/Sq4DqkfXZ/x0jW02DG1tGsfUGXbTJyZDP+eu67haSw==\n\nwrap-ansi@^7.0.0:\n  version \"7.0.0\"\n  resolved \"https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz\"\n  integrity sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==\n  dependencies:\n    ansi-styles \"^4.0.0\"\n    string-width \"^4.1.0\"\n    strip-ansi \"^6.0.0\"\n\nwrappy@1:\n  version \"1.0.2\"\n  resolved \"https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz\"\n  integrity sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=\n\ny18n@^5.0.5:\n  version \"5.0.8\"\n  resolved \"https://registry.npmjs.org/y18n/-/y18n-5.0.8.tgz\"\n  integrity sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==\n\nyargs-parser@20.2.4, yargs-parser@^20.2.2:\n  version \"20.2.4\"\n  resolved \"https://registry.npmjs.org/yargs-parser/-/yargs-parser-20.2.4.tgz\"\n  integrity sha512-WOkpgNhPTlE73h4VFAFsOnomJVaovO8VqLDzy5saChRBFQFBoMYirowyW+Q9HB4HFF4Z7VZTiG3iSzJJA29yRA==\n\nyargs-unparser@2.0.0:\n  version \"2.0.0\"\n  resolved \"https://registry.npmjs.org/yargs-unparser/-/yargs-unparser-2.0.0.tgz\"\n  integrity sha512-7pRTIA9Qc1caZ0bZ6RYRGbHJthJWuakf+WmHK0rVeLkNrrGhfoabBNdue6kdINI6r4if7ocq9aD/n7xwKOdzOA==\n  dependencies:\n    camelcase \"^6.0.0\"\n    decamelize \"^4.0.0\"\n    flat \"^5.0.2\"\n    is-plain-obj \"^2.1.0\"\n\nyargs@16.2.0:\n  version \"16.2.0\"\n  resolved \"https://registry.npmjs.org/yargs/-/yargs-16.2.0.tgz\"\n  integrity sha512-D1mvvtDG0L5ft/jGWkLpG1+m0eQxOfaBvTNELraWj22wSVUMWxZUvYgJYcKh6jGGIkJFhH4IZPQhR4TKpc8mBw==\n  dependencies:\n    cliui \"^7.0.2\"\n    escalade \"^3.1.1\"\n    get-caller-file \"^2.0.5\"\n    require-directory \"^2.1.1\"\n    string-width \"^4.2.0\"\n    y18n \"^5.0.5\"\n    yargs-parser \"^20.2.2\"\n\nyargs@^17.1.1:\n  version \"17.1.1\"\n  resolved \"https://registry.npmjs.org/yargs/-/yargs-17.1.1.tgz\"\n  integrity sha512-c2k48R0PwKIqKhPMWjeiF6y2xY/gPMUlro0sgxqXpbOIohWiLNXWslsootttv7E1e73QPAMQSg5FeySbVcpsPQ==\n  dependencies:\n    cliui \"^7.0.2\"\n    escalade \"^3.1.1\"\n    get-caller-file \"^2.0.5\"\n    require-directory \"^2.1.1\"\n    string-width \"^4.2.0\"\n    y18n \"^5.0.5\"\n    yargs-parser \"^20.2.2\"\n\nyn@3.1.1:\n  version \"3.1.1\"\n  resolved \"https://registry.npmjs.org/yn/-/yn-3.1.1.tgz\"\n  integrity sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==\n\nyocto-queue@^0.1.0:\n  version \"0.1.0\"\n  resolved \"https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz\"\n  integrity sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==\n"
        }
      ]
    }
  ]
}