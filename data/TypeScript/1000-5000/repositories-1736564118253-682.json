{
  "metadata": {
    "timestamp": 1736564118253,
    "page": 682,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tj/connect-redis",
      "stars": 2806,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.11328125,
          "content": "node_modules\ncoverage\n.nyc_output\nyarn-error.log\npackage-lock.json\nyarn.lock\n.DS_Store\ndump.rdb\npnpm-lock.yaml\ndist\n"
        },
        {
          "name": ".npmignore",
          "type": "blob",
          "size": 0.08203125,
          "content": "testdata\ncoverage\n.nyc_output\n\npackage-lock.json\nyarn.lock\npnpm-lock.yaml\n\ndump.rdb\n"
        },
        {
          "name": ".prettierrc",
          "type": "blob",
          "size": 0.095703125,
          "content": "{\n  \"semi\": false,\n  \"bracketSpacing\": false,\n  \"plugins\": [\"prettier-plugin-organize-imports\"]\n}\n"
        },
        {
          "name": "eslint.config.js",
          "type": "blob",
          "size": 0.5888671875,
          "content": "import js from \"@eslint/js\"\nimport prettier from \"eslint-plugin-prettier/recommended\"\nimport ts from \"typescript-eslint\"\n\nexport default ts.config({\n  extends: [js.configs.recommended, ...ts.configs.recommended, prettier],\n  rules: {\n    \"prefer-const\": 0,\n    \"@typescript-eslint/no-explicit-any\": 0,\n    \"@typescript-eslint/no-unused-vars\": [\n      \"error\",\n      {\n        argsIgnorePattern: \"^_\",\n        caughtErrorsIgnorePattern: \"^_\",\n        destructuredArrayIgnorePattern: \"^_\",\n        varsIgnorePattern: \"^_\",\n        ignoreRestSiblings: true,\n      },\n    ],\n  },\n  ignores: [\"dist/**\"],\n})\n"
        },
        {
          "name": "index.ts",
          "type": "blob",
          "size": 5.30078125,
          "content": "import {SessionData, Store} from \"express-session\"\n\nconst noop = (_err?: unknown, _data?: any) => {}\n\ninterface NormalizedRedisClient {\n  get(key: string): Promise<string | null>\n  set(key: string, value: string, ttl?: number): Promise<string | null>\n  expire(key: string, ttl: number): Promise<number | boolean>\n  scanIterator(match: string, count: number): AsyncIterable<string>\n  del(key: string[]): Promise<number>\n  mget(key: string[]): Promise<(string | null)[]>\n}\n\ninterface Serializer {\n  parse(s: string): SessionData | Promise<SessionData>\n  stringify(s: SessionData): string\n}\n\ninterface RedisStoreOptions {\n  client: any\n  prefix?: string\n  scanCount?: number\n  serializer?: Serializer\n  ttl?: number | {(sess: SessionData): number}\n  disableTTL?: boolean\n  disableTouch?: boolean\n}\n\nexport class RedisStore extends Store {\n  client: NormalizedRedisClient\n  prefix: string\n  scanCount: number\n  serializer: Serializer\n  ttl: number | {(sess: SessionData): number}\n  disableTTL: boolean\n  disableTouch: boolean\n\n  constructor(opts: RedisStoreOptions) {\n    super()\n    this.prefix = opts.prefix == null ? \"sess:\" : opts.prefix\n    this.scanCount = opts.scanCount || 100\n    this.serializer = opts.serializer || JSON\n    this.ttl = opts.ttl || 86400 // One day in seconds.\n    this.disableTTL = opts.disableTTL || false\n    this.disableTouch = opts.disableTouch || false\n    this.client = this.normalizeClient(opts.client)\n  }\n\n  // Create a redis and ioredis compatible client\n  private normalizeClient(client: any): NormalizedRedisClient {\n    let isRedis = \"scanIterator\" in client\n    return {\n      get: (key) => client.get(key),\n      set: (key, val, ttl) => {\n        if (ttl) {\n          return isRedis\n            ? client.set(key, val, {EX: ttl})\n            : client.set(key, val, \"EX\", ttl)\n        }\n        return client.set(key, val)\n      },\n      del: (key) => client.del(key),\n      expire: (key, ttl) => client.expire(key, ttl),\n      mget: (keys) => (isRedis ? client.mGet(keys) : client.mget(keys)),\n      scanIterator: (match, count) => {\n        if (isRedis) return client.scanIterator({MATCH: match, COUNT: count})\n\n        // ioredis impl.\n        return (async function* () {\n          let [c, xs] = await client.scan(\"0\", \"MATCH\", match, \"COUNT\", count)\n          for (let key of xs) yield key\n          while (c !== \"0\") {\n            ;[c, xs] = await client.scan(c, \"MATCH\", match, \"COUNT\", count)\n            for (let key of xs) yield key\n          }\n        })()\n      },\n    }\n  }\n\n  async get(sid: string, cb = noop) {\n    let key = this.prefix + sid\n    try {\n      let data = await this.client.get(key)\n      if (!data) return cb()\n      return cb(null, await this.serializer.parse(data))\n    } catch (err) {\n      return cb(err)\n    }\n  }\n\n  async set(sid: string, sess: SessionData, cb = noop) {\n    let key = this.prefix + sid\n    let ttl = this._getTTL(sess)\n    try {\n      let val = this.serializer.stringify(sess)\n      if (ttl > 0) {\n        if (this.disableTTL) await this.client.set(key, val)\n        else await this.client.set(key, val, ttl)\n        return cb()\n      } else {\n        return this.destroy(sid, cb)\n      }\n    } catch (err) {\n      return cb(err)\n    }\n  }\n\n  async touch(sid: string, sess: SessionData, cb = noop) {\n    let key = this.prefix + sid\n    if (this.disableTouch || this.disableTTL) return cb()\n    try {\n      await this.client.expire(key, this._getTTL(sess))\n      return cb()\n    } catch (err) {\n      return cb(err)\n    }\n  }\n\n  async destroy(sid: string, cb = noop) {\n    let key = this.prefix + sid\n    try {\n      await this.client.del([key])\n      return cb()\n    } catch (err) {\n      return cb(err)\n    }\n  }\n\n  async clear(cb = noop) {\n    try {\n      let keys = await this._getAllKeys()\n      if (!keys.length) return cb()\n      await this.client.del(keys)\n      return cb()\n    } catch (err) {\n      return cb(err)\n    }\n  }\n\n  async length(cb = noop) {\n    try {\n      let keys = await this._getAllKeys()\n      return cb(null, keys.length)\n    } catch (err) {\n      return cb(err)\n    }\n  }\n\n  async ids(cb = noop) {\n    let len = this.prefix.length\n    try {\n      let keys = await this._getAllKeys()\n      return cb(\n        null,\n        keys.map((k) => k.substring(len)),\n      )\n    } catch (err) {\n      return cb(err)\n    }\n  }\n\n  async all(cb = noop) {\n    let len = this.prefix.length\n    try {\n      let keys = await this._getAllKeys()\n      if (keys.length === 0) return cb(null, [])\n\n      let data = await this.client.mget(keys)\n      let results = data.reduce((acc, raw, idx) => {\n        if (!raw) return acc\n        let sess = this.serializer.parse(raw) as any\n        sess.id = keys[idx].substring(len)\n        acc.push(sess)\n        return acc\n      }, [] as SessionData[])\n      return cb(null, results)\n    } catch (err) {\n      return cb(err)\n    }\n  }\n\n  private _getTTL(sess: SessionData) {\n    if (typeof this.ttl === \"function\") {\n      return this.ttl(sess)\n    }\n\n    let ttl\n    if (sess && sess.cookie && sess.cookie.expires) {\n      let ms = Number(new Date(sess.cookie.expires)) - Date.now()\n      ttl = Math.ceil(ms / 1000)\n    } else {\n      ttl = this.ttl\n    }\n    return ttl\n  }\n\n  private async _getAllKeys() {\n    let pattern = this.prefix + \"*\"\n    let keys = []\n    for await (let key of this.client.scanIterator(pattern, this.scanCount)) {\n      keys.push(key)\n    }\n    return keys\n  }\n}\n"
        },
        {
          "name": "index_test.ts",
          "type": "blob",
          "size": 3.3603515625,
          "content": "import {Cookie} from \"express-session\"\nimport {Redis} from \"ioredis\"\nimport {promisify} from \"node:util\"\nimport {createClient} from \"redis\"\nimport {expect, test} from \"vitest\"\nimport {RedisStore} from \"./\"\nimport * as redisSrv from \"./testdata/server\"\n\ntest(\"setup\", async () => {\n  await redisSrv.connect()\n})\n\ntest(\"defaults\", async () => {\n  let client = createClient({url: `redis://localhost:${redisSrv.port}`})\n  await client.connect()\n\n  let store = new RedisStore({client})\n\n  expect(store.client).toBeDefined()\n  expect(store.prefix).toBe(\"sess:\")\n  expect(store.ttl).toBe(86400) // defaults to one day\n  expect(store.scanCount).toBe(100)\n  expect(store.serializer).toBe(JSON)\n  expect(store.disableTouch).toBe(false)\n  expect(store.disableTTL).toBe(false)\n  await client.disconnect()\n})\n\ntest(\"redis\", async () => {\n  let client = createClient({url: `redis://localhost:${redisSrv.port}`})\n  await client.connect()\n  let store = new RedisStore({client})\n  await lifecycleTest(store, client)\n  await client.disconnect()\n})\n\ntest(\"ioredis\", async () => {\n  let client = new Redis(`redis://localhost:${redisSrv.port}`)\n  let store = new RedisStore({client})\n  await lifecycleTest(store, client)\n  client.disconnect()\n})\n\ntest(\"teardown\", redisSrv.disconnect)\n\nasync function lifecycleTest(store: RedisStore, client: any): Promise<void> {\n  const P = (f: any) => promisify(f).bind(store)\n  let res = await P(store.clear)()\n\n  let sess = {foo: \"bar\"}\n  await P(store.set)(\"123\", sess)\n\n  res = await P(store.get)(\"123\")\n  expect(res).toEqual(sess)\n\n  let ttl = await client.ttl(\"sess:123\")\n  expect(ttl).toBeGreaterThanOrEqual(86399)\n\n  ttl = 60\n  let expires = new Date(Date.now() + ttl * 1000).toISOString()\n  await P(store.set)(\"456\", {cookie: {expires}})\n  ttl = await client.ttl(\"sess:456\")\n  expect(ttl).toBeLessThanOrEqual(60)\n\n  ttl = 90\n  let expires2 = new Date(Date.now() + ttl * 1000).toISOString()\n  await P(store.touch)(\"456\", {cookie: {expires: expires2}})\n  ttl = await client.ttl(\"sess:456\")\n  expect(ttl).toBeGreaterThan(60)\n\n  res = await P(store.length)()\n  expect(res).toBe(2) // stored two keys length\n\n  res = await P(store.ids)()\n  res.sort()\n  expect(res).toEqual([\"123\", \"456\"])\n\n  res = await P(store.all)()\n  res.sort((a: any, b: any) => (a.id > b.id ? 1 : -1))\n  expect(res).toEqual([\n    {id: \"123\", foo: \"bar\"},\n    {id: \"456\", cookie: {expires}},\n  ])\n\n  await P(store.destroy)(\"456\")\n  res = await P(store.length)()\n  expect(res).toBe(1) // one key remains\n\n  res = await P(store.clear)()\n\n  res = await P(store.length)()\n  expect(res).toBe(0) // no keys remain\n\n  let count = 1000\n  await load(store, count)\n\n  res = await P(store.length)()\n  expect(res).toBe(count)\n\n  await P(store.clear)()\n  res = await P(store.length)()\n  expect(res).toBe(0)\n\n  expires = new Date(Date.now() + ttl * 1000).toISOString() // expires in the future\n  res = await P(store.set)(\"789\", {cookie: {expires}})\n\n  res = await P(store.length)()\n  expect(res).toBe(1)\n\n  expires = new Date(Date.now() - ttl * 1000).toISOString() // expires in the past\n  await P(store.set)(\"789\", {cookie: {expires}})\n\n  res = await P(store.length)()\n  expect(res).toBe(0) // no key remains and that includes session 789\n}\n\nasync function load(store: RedisStore, count: number) {\n  let cookie = new Cookie()\n  for (let sid = 0; sid < count; sid++) {\n    cookie.expires = new Date(Date.now() + 1000)\n    await store.set(\"s\" + sid, {cookie})\n  }\n}\n"
        },
        {
          "name": "license",
          "type": "blob",
          "size": 1.05078125,
          "content": "MIT License\n\nCopyright (c) 2010-2023 TJ Holowaychuk\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 1.85546875,
          "content": "{\n  \"name\": \"connect-redis\",\n  \"description\": \"Redis session store for Connect\",\n  \"version\": \"8.0.1\",\n  \"author\": \"TJ Holowaychuk <tj@vision-media.ca>\",\n  \"contributors\": [\n    \"Marc Harter <wavded@gmail.com>\"\n  ],\n  \"license\": \"MIT\",\n  \"type\": \"module\",\n  \"main\": \"./dist/connect-redis.cjs\",\n  \"module\": \"./dist/connect-redis.js\",\n  \"types\": \"./dist/connect-redis.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"import\": {\n        \"types\": \"./dist/connect-redis.d.ts\",\n        \"default\": \"./dist/connect-redis.js\"\n      },\n      \"require\": {\n        \"types\": \"./dist/connect-redis.d.cts\",\n        \"default\": \"./dist/connect-redis.cjs\"\n      }\n    }\n  },\n  \"scripts\": {\n    \"prepublishOnly\": \"vite build\",\n    \"build\": \"vite build\",\n    \"test\": \"vitest run --silent --coverage\",\n    \"lint\": \"tsc --noemit && eslint --max-warnings 0 testdata *.ts\",\n    \"fmt\": \"prettier --write .\",\n    \"fmt-check\": \"prettier --check .\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+ssh://git@github.com/tj/connect-redis.git\"\n  },\n  \"devDependencies\": {\n    \"@eslint/js\": \"^9.15.0\",\n    \"@types/eslint__js\": \"^8.42.3\",\n    \"@types/express-session\": \"^1.18.1\",\n    \"@types/node\": \"^20.17.8\",\n    \"@vitest/coverage-v8\": \"^2.1.6\",\n    \"eslint\": \"^9.15.0\",\n    \"eslint-config-prettier\": \"^9.1.0\",\n    \"eslint-plugin-prettier\": \"^5.2.1\",\n    \"express-session\": \"^1.18.1\",\n    \"ioredis\": \"^5.4.1\",\n    \"prettier\": \"^3.4.1\",\n    \"prettier-plugin-organize-imports\": \"^4.1.0\",\n    \"redis\": \"^4.7.0\",\n    \"ts-node\": \"^10.9.2\",\n    \"typescript\": \"^5.7.2\",\n    \"typescript-eslint\": \"^8.16.0\",\n    \"vite\": \"^6.0.1\",\n    \"vite-plugin-dts\": \"^4.3.0\",\n    \"vitest\": \"^2.1.6\"\n  },\n  \"peerDependencies\": {\n    \"express-session\": \">=1\"\n  },\n  \"engines\": {\n    \"node\": \">=18\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/tj/connect-redis/issues\"\n  },\n  \"keywords\": [\n    \"connect\",\n    \"redis\",\n    \"session\",\n    \"express\"\n  ]\n}\n"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 4.3232421875,
          "content": "![Build Status](https://github.com/tj/connect-redis/workflows/build/badge.svg?branch=master) [![npm](https://img.shields.io/npm/v/connect-redis.svg)](https://npmjs.com/package/connect-redis) [![code-style](https://img.shields.io/badge/code_style-prettier-ff69b4.svg)](https://gitter.im/jlongster/prettier) ![Downloads](https://img.shields.io/npm/dm/connect-redis.svg)\n\n**connect-redis** provides Redis session storage for Express.\n\n## Installation\n\n**connect-redis** requires `express-session` to installed and one of the following compatible Redis clients:\n\n- [`redis`][1]\n- [`ioredis`][2]\n\nInstall with `redis`:\n\n```sh\nnpm install redis connect-redis express-session\n```\n\nInstall with `ioredis`:\n\n```sh\nnpm install ioredis connect-redis express-session\n```\n\n## Importing\n\n**connect-redis** supports both CommonJS (`require`) and ESM (`import`) modules.\n\nImport using ESM/Typescript:\n\n```js\nimport {RedisStore} from \"connect-redis\"\n```\n\nRequire using CommonJS:\n\n```js\nconst {RedisStore} = require(\"connect-redis\")\n```\n\n## API\n\nFull setup using [`redis`][1] package:\n\n```js\nimport {RedisStore} from \"connect-redis\"\nimport session from \"express-session\"\nimport {createClient} from \"redis\"\n\n// Initialize client.\nlet redisClient = createClient()\nredisClient.connect().catch(console.error)\n\n// Initialize store.\nlet redisStore = new RedisStore({\n  client: redisClient,\n  prefix: \"myapp:\",\n})\n\n// Initialize session storage.\napp.use(\n  session({\n    store: redisStore,\n    resave: false, // required: force lightweight session keep alive (touch)\n    saveUninitialized: false, // recommended: only save session when data exists\n    secret: \"keyboard cat\",\n  }),\n)\n```\n\n### RedisStore(options)\n\n#### Options\n\n##### client\n\nAn instance of [`redis`][1] or [`ioredis`][2].\n\n##### prefix\n\nKey prefix in Redis (default: `sess:`).\n\n**Note**: This prefix appends to whatever prefix you may have set on the `client` itself.\n\n**Note**: You may need unique prefixes for different applications sharing the same Redis instance. This limits bulk commands exposed in `express-session` (like `length`, `all`, `keys`, and `clear`) to a single application's data.\n\n##### ttl\n\nIf the session cookie has a `expires` date, `connect-redis` will use it as the TTL.\n\nOtherwise, it will expire the session using the `ttl` option (default: `86400` seconds or one day).\n\n```ts\ninterface RedisStoreOptions {\n  ...\n  ttl?: number | {(sess: SessionData): number}\n}\n```\n\n`ttl` also has external callback support. You can use it for dynamic TTL generation. It has access to `session` data.\n\n**Note**: The TTL is reset every time a user interacts with the server. You can disable this behavior in _some_ instances by using `disableTouch`.\n\n**Note**: `express-session` does not update `expires` until the end of the request life cycle. _Calling `session.save()` manually beforehand will have the previous value_.\n\n##### disableTouch\n\nDisables resetting the TTL when using `touch` (default: `false`)\n\nThe `express-session` package uses `touch` to signal to the store that the user has interacted with the session but hasn't changed anything in its data. Typically, this helps keep the users session alive if session changes are infrequent but you may want to disable it to cut down the extra calls or to prevent users from keeping sessions open too long. Also consider enabling if you store a lot of data on the session.\n\nRef: <https://github.com/expressjs/session#storetouchsid-session-callback>\n\n##### disableTTL\n\nDisables key expiration completely (default: `false`)\n\nThis option disables key expiration requiring the user to manually manage key cleanup outside of `connect-redis`. Only use if you know what you are doing and have an exceptional case where you need to manage your own expiration in Redis.\n\n**Note**: This has no effect on `express-session` setting cookie expiration.\n\n##### serializer\n\nProvide a custom encoder/decoder to use when storing and retrieving session data from Redis (default: `JSON.parse` and `JSON.stringify`).\n\nOptionally `parse` method can be async if need be.\n\n```ts\ninterface Serializer {\n  parse(string): object | Promise<object>\n  stringify(object): string\n}\n```\n\n##### scanCount\n\nValue used for _count_ parameter in [Redis `SCAN` command](https://redis.io/commands/scan#the-count-option). Used for `ids()` and `all()` methods (default: `100`).\n\n[1]: https://github.com/NodeRedis/node-redis\n[2]: https://github.com/luin/ioredis\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "tsconfig.json",
          "type": "blob",
          "size": 0.3798828125,
          "content": "{\n  \"compilerOptions\": {\n    \"target\": \"es2022\",\n    \"module\": \"esnext\",\n    \"strict\": true,\n    \"isolatedModules\": true,\n    \"skipLibCheck\": true,\n    \"noImplicitReturns\": true,\n    \"noUnusedLocals\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true\n  },\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n"
        },
        {
          "name": "vite.config.ts",
          "type": "blob",
          "size": 0.806640625,
          "content": "import {copyFileSync} from \"node:fs\"\nimport dts from \"vite-plugin-dts\"\nimport {defineConfig} from \"vitest/config\"\n\n// https://vitest.dev/config/\nexport default defineConfig({\n  build: {\n    lib: {\n      entry: \"index.ts\",\n      name: \"connect-redis\",\n      formats: [\"es\", \"cjs\"],\n    },\n    emptyOutDir: true,\n    minify: false,\n    rollupOptions: {\n      external: [\"express-session\"],\n      treeshake: false,\n    },\n    target: \"node18\",\n  },\n  plugins: [\n    // @ts-expect-error Type mismatch, revisit.\n    dts({\n      include: [\"index.ts\"],\n      rollupTypes: true,\n      insertTypesEntry: true,\n      afterBuild: () => {\n        copyFileSync(\"dist/connect-redis.d.ts\", \"dist/connect-redis.d.cts\")\n      },\n    }),\n  ],\n  test: {\n    include: [\"**/*_test.[jt]s\"],\n    coverage: {\n      reporter: [\"text\"],\n    },\n  },\n})\n"
        }
      ]
    }
  ]
}