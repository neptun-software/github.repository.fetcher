{
  "metadata": {
    "timestamp": 1736564571081,
    "page": 208,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ianstormtaylor/superstruct",
      "stars": 7061,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1640625,
          "content": "root = true\n\n[*]\nindent_style = space\nindent_size = 2\nend_of_line = lf\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\nmax_line_length = 80\n"
        },
        {
          "name": ".eslintrc",
          "type": "blob",
          "size": 2.5166015625,
          "content": "{\n  \"extends\": [\"prettier\"],\n  \"plugins\": [\"@typescript-eslint\", \"prettier/recommended\"],\n  \"parser\": \"@typescript-eslint/parser\",\n  \"parserOptions\": {\n    \"sourceType\": \"module\",\n    \"ecmaVersion\": 2020,\n    \"ecmaFeatures\": {\n      \"jsx\": true\n    }\n  },\n  \"env\": {\n    \"browser\": true,\n    \"es6\": true,\n    \"mocha\": true,\n    \"node\": true\n  },\n  \"rules\": {\n    \"@typescript-eslint/no-unused-vars\": [\n      \"error\",\n      { \"vars\": \"all\", \"args\": \"none\" }\n    ],\n    \"constructor-super\": \"error\",\n    \"dot-notation\": [\"error\", { \"allowKeywords\": true }],\n    \"eqeqeq\": [\"error\", \"smart\"],\n    \"linebreak-style\": \"error\",\n    \"new-parens\": \"error\",\n    \"no-array-constructor\": \"error\",\n    \"no-class-assign\": \"error\",\n    \"no-console\": \"error\",\n    \"no-const-assign\": \"error\",\n    \"no-debugger\": \"error\",\n    \"no-dupe-args\": \"error\",\n    \"no-dupe-class-members\": \"error\",\n    \"no-dupe-keys\": \"error\",\n    \"no-duplicate-case\": \"error\",\n    \"no-empty\": \"error\",\n    \"no-empty-character-class\": \"error\",\n    \"no-empty-pattern\": \"error\",\n    \"no-ex-assign\": \"error\",\n    \"no-extend-native\": \"error\",\n    \"no-extra-boolean-cast\": \"error\",\n    \"no-func-assign\": \"error\",\n    \"no-invalid-regexp\": \"error\",\n    \"no-lonely-if\": \"error\",\n    \"no-native-reassign\": \"error\",\n    \"no-negated-in-lhs\": \"error\",\n    \"no-new-object\": \"error\",\n    \"no-new-symbol\": \"error\",\n    \"no-path-concat\": \"error\",\n    \"no-redeclare\": \"error\",\n    \"no-regex-spaces\": \"error\",\n    \"no-sequences\": \"error\",\n    \"no-shadow\": \"error\",\n    \"no-shadow-restricted-names\": \"error\",\n    \"no-tabs\": \"error\",\n    \"no-this-before-super\": \"error\",\n    \"no-throw-literal\": \"error\",\n    \"no-unneeded-ternary\": \"error\",\n    \"no-unreachable\": \"error\",\n    \"no-unsafe-finally\": \"error\",\n    \"no-unsafe-negation\": \"error\",\n    \"no-unused-expressions\": \"error\",\n    \"no-unused-vars\": \"off\",\n    \"no-useless-call\": \"error\",\n    \"no-useless-computed-key\": \"error\",\n    \"no-useless-constructor\": \"error\",\n    \"no-useless-rename\": \"error\",\n    \"no-var\": \"error\",\n    \"no-void\": \"error\",\n    \"no-with\": \"error\",\n    \"object-shorthand\": [\"error\", \"always\"],\n    \"prefer-arrow-callback\": \"error\",\n    \"prefer-const\": [\n      \"error\",\n      { \"destructuring\": \"all\", \"ignoreReadBeforeAssign\": true }\n    ],\n    \"prefer-rest-params\": \"error\",\n    \"prefer-spread\": \"error\",\n    \"prefer-template\": \"error\",\n    \"radix\": \"error\",\n    \"spaced-comment\": [\"error\", \"always\", { \"exceptions\": [\"-\"] }],\n    \"use-isnan\": \"error\",\n    \"valid-typeof\": \"error\",\n    \"yield-star-spacing\": [\"error\", \"after\"],\n    \"yoda\": [\"error\", \"never\"]\n  }\n}\n"
        },
        {
          "name": ".gitbook.yaml",
          "type": "blob",
          "size": 0.068359375,
          "content": "root: ./docs\nstructure:\n  readme: ./readme.md\n  summary: ./summary.md\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0556640625,
          "content": "dist/\nnode_modules/\nnpm-debug.log\npackage-lock.json\ntmp/\n"
        },
        {
          "name": ".prettierignore",
          "type": "blob",
          "size": 0.01953125,
          "content": "dist/\nnode_modules/\n"
        },
        {
          "name": ".prettierrc",
          "type": "blob",
          "size": 0.0673828125,
          "content": "{\n  \"singleQuote\": true,\n  \"semi\": false,\n  \"trailingComma\": \"es5\"\n}\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "Changelog.md",
          "type": "blob",
          "size": 24.6005859375,
          "content": "# Changelog\n\nThis document maintains a list of major changes to Superstruct with each new release.\n\n### `2.0.0` - July 3, 2024\n\nSome changes in Superstruct v2.0 are _potentially_ breaking if you were using the library in unusual and/or undocumented ways. Since it has been almost 2 years since the last significant release, we want to make sure that we don't ruin someone's day by surprising them with a fix that changes [buggy behavior they were relying on](https://xkcd.com/1172/). For this reason, some changes that would ordinarily be considered a fix are marked as breaking.\n\n**:rocket: For the absolute majority of users, this should be a smooth upgrade that will not require any changes.**\n\n#### Breaking\n\n- Validation now correctly fails when arrays are passed to `object()`, `type()`, and `record()` structs.\n- When coercing an `object()` (via `mask()`, `create()` or `validate()` with the `coerce: true` option), arrays will no longer be automatically converted to objects with indexes as keys. [See this PR comment](https://github.com/ianstormtaylor/superstruct/pull/1196#issuecomment-1858924264).\n\n#### New\n\n- The library and its TypeScript typings are now compatible with NodeNext/Node16 module resolution. This means that if you are using the library with TypeScript and ECMAScript modules at the same time, you should no longer run into issues!\n\n#### Fixed\n\n- Using `mask()` with `union()` now correctly masks union members instead of incorrectly failing validation.\n\n#### Deprecations\n\n- Use with Node.js v14 is now deprecated. Due to incompatible tooling, we are no longer able to test Superstruct on this version of Node.js. Use at your own risk.\n\n#### New Maintainers & Next Steps\n\nProject maintenance has moved to a new volunteer team: [@arturmuller](https://github.com/arturmuller) and [@yeoffrey](https://github.com/yeoffrey). Hello there! :wave: We are currently going through the existing issues and PRs, trying to resolve or close the backlog. This might take a little while so please bear with us.\n\nIf you are interested in **contributing** — or helping us process the backlog — we would love your help. Don't hesitate to help us triage, open an issue, or submit a PR. You can also join our Superstruct maintainers Discord: https://discord.gg/pdHrQBjQ96.\n\nIf you have **questions, suggestions, or are just not sure about something** related to Superstruct, head over to GitHub Discussions! We have recently enabled this feature to help us differentiate between actual issues/bugs and everything else. We hope this will be a great new place where Superstruct users can get quick help from us — the maintainers — but also from the community as a whole.\n\nSee you at the next release! :v:\n\n### `1.0.0` — November 17, 2022\n\n###### NEW\n\n**Added an optional `message` argument to override error messages.** You can now pass in a `message` argument to all of the error checking functions which will override any error message with your own message. If you do, Superstruct's original descriptive message will still be accessible via [`error.cause`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause).\n\n```ts\nassert(data, User, 'The user is invalid!')\n// StructError: The user is invalid!\n```\n\n### BREAKING\n\n**No breaking changes.** This just marks Superstruct being stable for a long time, so better to move to a non `0.*` numbering scheme.\n\n### `0.16.0` — June 6, 2022\n\n###### BREAKING\n\n**Refinement functions are now called with valid, but potentially unrefined values.** Previously the functions passed in to `refine` would always be called with sub-elements (eg. when using objects or arrays) that were completely valid **and** refined. However, this prevented collecting all the refinement errors from subelements in a validation in one go, which is common when validating forms. _Note: this should not have any affect on almost all use cases, so you're safe to upgrade._\n\n### `0.15.0` — March 25, 2021\n\n###### FIXED\n\n**Unions can now be coerced.** Previously unions created a barrier in coercion such that structs nested inside unions would not have their coercion logic triggered, but this has been fixed.\n\n**Assigning preserves `type` structs.** Previously using the `assign` helper would implicitly convert `type` structs into `object` structs which wasn't expected and confusing, but this has been fixed.\n\n### `0.14.0` — January 26, 2021\n\n###### BREAKING\n\n**The `mask` helper now works for nested objects.** Previously it would only mask the properties at the top-level of a struct, however now it acts deeply. You can use it to define object structs once, but use them either strictly or loosely.\n\n**The `masked` coercion has been removed.** This previously allowed you to mix in masking to a specific struct, but the `mask` helper is a more robust way to do this, and it doesn't force you to maintain two separate structs.\n\n### `0.13.0` — December 11, 2020\n\n###### NEW\n\n**Structs can now define an `entries` iterator for nested values.** Previously iterating through nested values was defined in a one-off manner inside certain structs, but this led to non-uniform support. Now, any struct can define an `entries` iterator that will cause nested values to be automatically coerced and validated.\n\n**Coercion receives `context` objects and supports nested values.** Previously context objects were only passed to the validations and refinements. But now the same context is passed to coercions too so you can implement more complex logic. And coercions are automatically applied to nested values thanks to the addition of `entries`.\n\n**Iteration logic has gotten simpler, and more performant.** The addition of the `entries` logic has enabled us to only ever iterate through a tree of values one time for coercion and validation, instead of once each. This should speed up most standard use cases.\n\n###### BREAKING\n\n**The `ctx.fail()` function has been removed.** Previously you'd use it to return more information about a failure inside a struct. Now you can simply return a partial failure object.\n\n**The `ctx.check()` function has been removed.** Previously you'd use it to validate nested objects in more complex struct shapes. Now you can use the new `entries` property for this instead.\n\n**The `context.struct` and `context.value` properties have been removed.** These properties were previously available, but unnecessary since anywhere you have the context object you will also know the `value` and the specific struct that is being validated. Keeping them around required extra unnecessary plumbing in the library that made composing structs much more difficult so they were removed.\n\n### `0.12.0` — November 24, 2020\n\n###### NEW\n\n**New `Describe` utility type.** This new utility lets you define a struct from an existing TypeScript type and ensure that the struct's validation matches it, otherwise TypeScript's compiler will error. For example:\n\n```ts\ntype User = {\n  id: number\n  name: string\n}\n\nconst User: Describe<User> = object({\n  id: string(), // This mistake will fail to pass type checking!\n  name: string(),\n})\n```\n\n###### BREAKING\n\n**The `coerce` helper has changed to be more type-safe!** Previously `coerce` functions were called with `value: unknown` because they ran before all validation. However, now they take a new second argument that is another struct to narrow the cases where coercions occurs. This means the `value` for coercion will now be type-safe.\n\n```ts\n// Previously\nconst MyNumber = coerce(number(), (value) => {\n  return typeof value === 'string' ? parseFloat(value) : value\n})\n\n// Now\nconst MyNumber = coerce(number(), string(), (value) => {\n  return parseFloat(value)\n})\n```\n\n### `0.11.0` — November 20, 2020\n\n###### NEW\n\n**New `assign`, `pick`, and `omit` object utilities.** These utilities make composing object structs together possible, which should make re-using structs in your codebase easier.\n\n```ts\n// Combine two structs with `assign`:\nconst a = object({ id: number() })\nconst b = object({ name: string() })\nconst c = assign([a, b])\n\n// Pick out specific properties with `pick`:\nconst a2 = pick(c, ['id'])\n\n// Omit specific properties with `omit`:\nconst a3 = omit(c, ['name'])\n```\n\n**New `unknown` struct.** This is the same as the existing `any` struct, but it will ensure that in TypeScript the value is of the more restrictive `unknown` type so it encourages better type safety.\n\n```ts\nconst Shape = type({\n  id: number(),\n  name: string(),\n  other: unknown(),\n})\n```\n\n**New `integer`, `regexp`, and `func` structs.** These are just simple additions for common use cases of ensuring a value is an integer, a regular expression object (not a string!), or a function.\n\n```ts\nconst Shape = type({\n  id: integer(),\n  matches: regexp(),\n  send: func(),\n})\n```\n\n**New `max/min` refinements.** For refining `number` (or `integer`) or `date` structs to ensure they are greater than or less than a specific threshold. The third argument can indicate whether to make the threshold exclusive (instead of the default inclusive).\n\n```ts\nconst Index = min(number(), 0)\nconst PastOrPresent = max(date(), new Date())\nconst Past = max(date(), new Date(), { exclusive: true })\n```\n\n**Even more information on errors.** Errors now expose the `error.refinement` property when the failure originated in a refinement validation. And they also now have an `error.key` property which is the key for the failure in the case of complex values like arrays/objects. (Previously the key was retrievable by checking `error.path`, but this will make the 90% case easier.)\n\n###### BREAKING\n\n**The `coerce` helper has been renamed to `create`.** This will hopefully make it more clear that it's fully coercing and validating a value against a struct, throwing errors if the value was invalid. This has caused confusion for people who though it would just coerce the value and return the unvalidated-but-coerced version.\n\n```ts\n// Previously\nconst user = coerce(data, User)\n\n// Now\nconst user = create(data, User)\n```\n\n**The `struct`, `refinement` and `coercion` factories have been renamed.** This renaming is purely for keeping things slightly cleaner and easier to understand. The new names are `define`, `refine`, and `coerce`. Separating them slightly from the noun-based names used for the types themselves.\n\n```ts\n// Previously\nconst Email = struct('email', isEmail)\nconst Positive = refinement('positive', number(), n => n > 0)\nconst Trimmed = coercion(string(), s => s.trim()\n\n// Now\nconst Email = define('email', isEmail)\nconst Positive = refine(number(), 'positive', n => n > 0)\nconst Trimmed = coerce(string(), s => s.trim())\n```\n\n_Note that the order of `refine` arguments has changed to be slightly more natural, and encourage scoped refinement names._\n\n**The `length` refinement has been renamed to `size`.** This is to match with the expansion of it's abilities from purely strings and arrays to also now include numbers, maps, and sets. In addition you can also omit the `max` argument to specify an exact size:\n\n```ts\n// Previously\nconst Name = length(string(), 1, 100)\nconst MyArray = length(array(string()), 3, 3)\n\n// Now\nconst Name = size(string(), 1, 100)\nconst MyArray = size(array(string()), 3)\nconst Id = size(integer(), 1, Infinity)\nconst MySet = size(set(), 1, 9)\n```\n\n**The `StructType` inferring helper has been renamed to `Infer`.** This just makes it slightly easier to read what's going on when you're inferring a type.\n\n```ts\n// Previously\ntype User = StructType<typeof User>\n\n// Now\ntype User = Infer<typeof User>\n```\n\n**The `error.type` property has been standardized.** Previously it was a human-readable description that sort of incorporated the schema. Now it is simple the plain lowercase name of the struct in question, making it something you can use programmatically when formatting errors.\n\n```ts\n// Previously\n'Array<string>'\n'[string,number]'\n'Map<string,number>'\n\n// Now\n'array'\n'tuple'\n'map'\n```\n\n### `0.10.0` — June 6, 2020\n\nThe `0.10` version is a complete overhaul with the goal of making Superstruct much simpler and easier to understand, and with complete support for runtime type signatures TypeScript.\n\nThis makes it much more powerful, however the core architecture has had to change to make it happen. It will still look very similar, but migrating between the versions _will be more work than usual_. There's no requirement to upgrade, although if you're using Superstruct in concert with TypeScript you will have a much better experience.\n\n###### BREAKING\n\n**All types are created from factories.** Previously depending on whether the type was a complex type or a scalar type they'd be defined different. Complex types used factories, whereas scalars used strings. Now all types are exposed as factories.\n\nFor example, previously:\n\n```ts\nimport { struct } from 'superstruct'\n\nconst User = struct.object({\n  name: 'string',\n  age: 'number',\n})\n```\n\nNow becomes:\n\n```ts\nimport { object, string, number } from 'superstruct'\n\nconst User = object({\n  name: string(),\n  age: number(),\n})\n```\n\n**Custom scalars are no longer pre-defined as strings.** Previously, you would define all of your \"custom\" types in a single place in your codebase and then refer to them in structs later on with a string value. This worked, but added a layer of unnecessary indirection, and made it impossible to accomodate runtime type signatures.\n\nIn the new version, custom types are defined extremely similarly to non-custom types. And this has the added benefit that you can easily trace the custom type definitions by just following `import` statements.\n\nHere's how it used to work:\n\n```ts\nimport { superstruct } from 'superstruct'\nimport isEmail from 'is-email'\n\nconst struct = superstruct({\n  types: {\n    email: isEmail,\n  },\n})\n\nconst Email = struct('email')\n```\n\nAnd here's what it would look like now:\n\n```ts\nimport { struct } from 'superstruct'\nimport isEmail from 'is-email'\n\nconst Email = struct('email', isEmail)\n```\n\n**Validation logic has been moved to helper functions.** Previously the `assert` and `is` helpers lived on the struct objects themselves. Now, these functions have been extracted into separate helpers. This was unfortunately necessary to work around limitations in TypeScript's `asserts` keyword.\n\nFor example, before:\n\n```ts\nUser.assert(data)\n```\n\nNow would be:\n\n```ts\nimport { assert } from 'superstruct'\n\nassert(data, User)\n```\n\n**Coercion is now separate from validation.** Previously there was native logic for handling default values for structs when validating them. This has been abstracted into the ability to define _any_ custom coercion logic for structs, and it has been separate from validation to make it very clear when data can change and when it cannot.\n\nFor example, previously:\n\n```ts\nconst output = User.assert(input)\n```\n\nWould now be:\n\n```ts\nconst input = coerce(input, User)\n```\n\nThe `coerce` step is the only time that data will be transformed at all by coercion logic, and the `assert` step no longer needs to return any values. This makes it easy to do things like:\n\n```ts\nif (is(input, User)) {\n  // ...\n}\n```\n\n**Validation context is now a dictionary of properties.** Previously when performing complex validation logic that was dependent on other properties on the root object, you could use the second `branch` argument to the validation function. This argument has been changed to be a `context` dictionary with more information. The same branch argument can now be accessed as `context.branch`, along with the new information.\n\n**Unknown properties of objects now have a `'never'` type.** Previously unknown properties would throw errors with `type === null`, however the newly introduced `'never'` type is now used instead.\n\n**Defaults are now defined with a separate coercion helper.** Previously all structs took a second argument that defined the default value to use if an `undefined` value was present. This has been pulled out into a separate helper now to clearly distinguish coercion logic.\n\nFor example, previously you'd do:\n\n```ts\nconst Article = struct.object(\n  {\n    title: 'string',\n  },\n  {\n    title: 'Untitled',\n  }\n)\n```\n\nWhereas now you'd do:\n\n```ts\nconst Article = defaulted(\n  object({\n    title: string(),\n  }),\n  {\n    title: 'Untitled',\n  }\n)\n```\n\n**Optional arguments are now defined with a seperate factory.** Similarly to defaults, there is a new `optional` factory for defined values that can also be `undefined`.\n\nPreviously you'd do:\n\n```ts\nconst Flag = struct('string?')\n```\n\nNow you'd do:\n\n```ts\nconst Flag = optional(string())\n```\n\n**Several structs have been renamed.** This was necessary because structs are now exposed directly as variables, which runs afoul of reserved words. So the following renames have been applied:\n\n- `interface` -> `type`\n- `enum` -> `enums`\n- `function` -> `func`\n\n### `0.8.0` — October 8, 2019\n\n###### BREAKING\n\n**Several structs have been renamed!** Superstruct tries to mimic established naming schemes whenever possible for its API, and TypeScript is one of our main comparisons. To make things easier for people, we've renamed a few structs to more closely match their TypeScript counterparts:\n\n- The `list` struct is now called `array`.\n- The `partial` struct is now called `pick`.\n- The `dict` struct is now called `record`.\n\nHopefully this will make them easier to understand at a glance!\n\n**The `enums` struct has been removed!** This was special-cased in the API previously, but you can get the exact same behavior by creating an using the `array` and `enum` structs:\n\n```js\nstruct.array(struct.enum(['red', 'blue', 'green']))\n```\n\n**The `any` struct has been removed! (Not the scalar though.)** Previously `struct.any()` was exposed that did the same thing as `struct()`, allowing you to use shorthands for common structs. But this was confusingly named because it has nothing to do with the `'any'` scalar type. And since it was redundant it has been removed.\n\n**The `interface` struct now returns the original, unaltered value!** In an effort to make things more familiar, the `interface` struct now always returns the object that it is called with when it passes validation. So if the object was a function, a function will be returned. This makes it match more closely with the idea of \"structural typing\" that TypeScript and other typing systems are based on. \\_If you want the old behavior, use the `pick` struct.\n\n**Computed values function signatures have changed!** Previously a computed value would be called with a signature of `(value, root)` in some cases and `(value, parent)` in others. This was confusing, and the cause for the inconsistency was complex. This logic has been simplified, and now computed values are called with `(value, branch, path)` in all cases.\n\n```js\nstruct.dynamic((value, branch, path) => {\n  value === branch[branch.length - 1] // you can get the value...\n  const parent = branch[branch.length - 2] // ...and the parent...\n  const key = path[path.length - 1] // ...and the key...\n  value === parent[key]\n  const root = branch[0] // ...and the root!\n})\n```\n\nThe `path` is an array of keys representing the nested value's location in the root value. And the `branch` is an array of all of the sub values along the path to get to the current one. This allows you to always be able to receive both the **parent** and the **root** values from any location—as well as any value in between.\n\n**The `error.errors` property has been renamed `error.failures`, and isn't cyclical.** It being cyclical caused lots of issues whenever an `StructError` object was attempted to be serialized. And the `errors` property was slightly confusing because the elements of the array weren't full error objects. The new structure is easier to understand and work with.\n\n**The `error.reason` property is no longer special-cased.** Previously you could return a \"reason\" string from validator functions and it would be added to error objects. However, now you must return an error properties object (with a `reason` property if you'd like), and all of the properties will be added to the error object. This makes Superstruct even more flexible as far as custom error details go.\n\n**The `type` property of structs have been rewritten to be more clear.** This is an implementation mostly, but the `struct.type` string which shows up in error messages have been tweaked to be slightly more clear exactly what type they are checking for.\n\n###### NEW\n\n**Superstruct is now written in TypeScript.** It was rewritten from the ground up to make use of types, and to have better inline documented if you use a TypeScript-compatible IDE. There are probably improvements that can be made, so if you'd like to contribute please do!\n\n**A new `partial` struct mimics TypeScript's `Partial` utility.** The new struct validates that its input partially matches an object defined as a set of properties with associated types. All of the properties of the object are optional.\n\n**A new `size` struct allows validating array and string lengths.** The new struct validates that its input has a certain size, by checking its `length` property. This works strings or arrays.\n\n**You can now provide a custom `Error` setting.** By passing in your own constructor when configuring Superstruct you can have complete control over the exact errors that are generated by structs that fail validation.\n\n### `0.7.0` — September 21, 2019\n\n###### BREAKING\n\n- **The build process now outputs ES5 code.** Previously it was outputting ES6 code, which posed problems for some builders. This change shouldn't really affect anyone negatively, but it's being released as a breaking version just in case.\n\n---\n\n### `0.6.0` — September 13, 2018\n\n###### BREAKING\n\n- **Invalid `Date` objects are now considered invalid.** Previously using the built-in `'date'` validator would only check that the object was a `Date` instance, and not that it was a valid one. This has been fixed, and although it is technically a breaking change, most everyone would have expected this behavior to begin with.\n\n---\n\n### `0.5.0` — December 21, 2017\n\n###### BREAKING\n\n- **Validators must now return `true`, `false` or an error reason string.** Previously any truthy value would be considered valid. Now you can provide more information for the thrown errors by providing a string which will be attached as `error.reason`. However, this means that truthy string values now equate to invalid, not valid.\n\n- **Property validators now receive `data` as their second argument.** Previously you only had access to the property `value`, but now you also have access to the entire object's `data`.\n\n###### NEW\n\n- **Errors can now contain reason information.** Validator functions can now return string instead of a boolean, denoting the reason a value was invalid. This can then be used to create more helpful error messages.\n\n---\n\n### `0.4.0` — December 1, 2017\n\n###### BREAKING\n\n- **`object` structs are no longer optional-ish.** Previously object struct types would not throw if `undefined` was passed and no properties were required. This was not only confusing, but complex to maintain. Now if you want an object struct to be optional, use the `struct.optional(...)` helper.\n\n- **Removed the `Struct.default` method.** If you need to get the default value, use the `Struct.validate` or `Struct.assert` methods's return value instead.\n\n###### NEW\n\n- **Added the `dict`, `enum`, `intersection`, `union` and `tuple` structs.** These are all available as `struct.dict`, `struct.enum`, etc.\n\n---\n\n### `0.3.0` — November 30, 2017\n\n###### BREAKING\n\n- **The `validate()` method now returns `[ error, result ]`.** Previously it only had a single return value, which necessitated extra type checking to see if the value was an error or a result. Now you can just destructure the array to get either return value, for easier coding.\n\n- **Errors have been simplified, removing \"codes\".** Previously there were multiple types of errors that were thrown and you could differentiate between them with the `error.code` property. But the other properties of the error already let you infer the code, so having multiple types of errors made for a larger API surface without much benefit.\n\n---\n\n### `0.2.0` — November 30, 2017\n\n###### BREAKING\n\n- **Structs are now functions again.** :smile: They are built on the same underlying schema classes underneath though, since that helps the code structure. But to allow for the `struct = Struct({ ... })` syntax the structs themselves have changed to be function.\n\n###### NEW\n\n- **The basic case is now `Struct(data)`.** Previously you had to use `Struct.assert(data)`. Although the `assert` method (and others) are still there, the basic case is a bit terser and more similar to the struct-initializing APIs in other languages.\n\n---\n\n### `0.1.0` — November 29, 2017\n\n###### BREAKING\n\n- **Structs are now classes instead of functions.** This is better in terms of the API being a bit less magic-y. It's also useful so that we can add other helpful methods to structs besides the `assert` method. What was previously `struct(data)` is now `struct.assert(data)`.\n\n---\n\n### `0.0.0` — November 24, 2017\n\n:tada:\n"
        },
        {
          "name": "License.md",
          "type": "blob",
          "size": 1.0849609375,
          "content": "The MIT License\n\nCopyright &copy; 2017, [Ian Storm Taylor](https://ianstormtaylor.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Readme.md",
          "type": "blob",
          "size": 9.4580078125,
          "content": "<p align=\"center\">\n  <a href=\"#\"><img src=\"./docs/images/banner.png\" /></a>\n</p>\n\n<p align=\"center\">\n  A simple and composable way  <br/>\n  to validate data in JavaScript (and TypeScript).\n</p>\n<br/>\n<br/>\n\n<p align=\"center\">\n  <a href=\"#usage\">Usage</a> •\n  <a href=\"#why\">Why?</a> •\n  <a href=\"#principles\">Principles</a> •\n  <a href=\"#demo\">Demo</a> •\n  <a href=\"#examples\">Examples</a> •\n  <a href=\"#documentation\">Documentation</a>\n</p>\n\n<p align=\"center\">\n  <a href=\"https://unpkg.com/superstruct/umd/superstruct.min.js\">\n    <img src=\"https://badgen.net/bundlephobia/minzip/superstruct?color=green&label=size\" alt=\"\">\n  </a>\n  <a href=\"./package.json\">\n    <img src=\"https://badgen.net/npm/v/superstruct?color=blue&label=version\" alt=\"\">\n  </a>\n  <a href=\"https://jsr.io/@superstruct/core\">\n    <img src=\"https://jsr.io/badges/@superstruct/core\" alt=\"\">\n  </a>\n</p>\n\n<br/>\n<br/>\n\nSuperstruct makes it easy to define interfaces and then validate JavaScript data against them. Its type annotation API was inspired by [Typescript](https://www.typescriptlang.org/docs/handbook/basic-types.html), [Flow](https://flow.org/en/docs/types/), [Go](https://gobyexample.com/structs), and [GraphQL](http://graphql.org/learn/schema/), giving it a familiar and easy to understand API.\n\nBut Superstruct is designed for validating data at runtime, so it throws (or returns) detailed runtime errors for you or your end users. This is especially useful in situations like accepting arbitrary input in a REST or GraphQL API. But it can even be used to validate internal data structures at runtime when needed.\n\n<br/>\n\n### Usage\n\nSuperstruct allows you to define the shape of data you want to validate:\n\n```js\nimport { assert, object, number, string, array } from 'superstruct'\n\nconst Article = object({\n  id: number(),\n  title: string(),\n  tags: array(string()),\n  author: object({\n    id: number(),\n  }),\n})\n\nconst data = {\n  id: 34,\n  title: 'Hello World',\n  tags: ['news', 'features'],\n  author: {\n    id: 1,\n  },\n}\n\nassert(data, Article)\n// This will throw an error when the data is invalid.\n// If you'd rather not throw, you can use `is()` or `validate()`.\n```\n\nSuperstruct ships with validators for all the common JavaScript data types, and you can define custom ones too:\n\n```js\nimport { is, define, object, string } from 'superstruct'\nimport isUuid from 'is-uuid'\nimport isEmail from 'is-email'\n\nconst Email = define('Email', isEmail)\nconst Uuid = define('Uuid', isUuid.v4)\n\nconst User = object({\n  id: Uuid,\n  email: Email,\n  name: string(),\n})\n\nconst data = {\n  id: 'c8d63140-a1f7-45e0-bfc6-df72973fea86',\n  email: 'jane@example.com',\n  name: 'Jane',\n}\n\nif (is(data, User)) {\n  // Your data is guaranteed to be valid in this block.\n}\n```\n\nSuperstruct can also handle coercion of your data before validating it, for example to mix in default values:\n\n```ts\nimport { create, object, number, string, defaulted } from 'superstruct'\n\nlet i = 0\n\nconst User = object({\n  id: defaulted(number(), () => i++),\n  name: string(),\n})\n\nconst data = {\n  name: 'Jane',\n}\n\n// You can apply the defaults to your data while validating.\nconst user = create(data, User)\n// {\n//   id: 0,\n//   name: 'Jane',\n// }\n```\n\nAnd if you use TypeScript, Superstruct automatically ensures that your data has proper typings whenever you validate it:\n\n```ts\nimport { is, object, number, string } from 'superstruct'\n\nconst User = object({\n  id: number(),\n  name: string()\n})\n\nconst data: unknown = { ... }\n\nif (is(data, User)) {\n  // TypeScript knows the shape of `data` here, so it is safe to access\n  // properties like `data.id` and `data.name`.\n}\n```\n\nSuperstruct supports more complex use cases too like defining arrays or nested objects, composing structs inside each other, returning errors instead of throwing them, and more! For more information read the full [Documentation](#documentation).\n\n<br/>\n\n### Why?\n\nThere are lots of existing validation libraries—[`joi`](https://github.com/hapijs/joi), [`express-validator`](https://github.com/ctavan/express-validator), [`validator.js`](https://github.com/chriso/validator.js), [`yup`](https://github.com/jquense/yup), [`ajv`](https://github.com/epoberezkin/ajv), [`is-my-json-valid`](https://github.com/mafintosh/is-my-json-valid)... But they exhibit many issues that lead to your codebase becoming hard to maintain...\n\n- **They don't expose detailed errors.** Many validators simply return string-only errors or booleans without any details as to why, making it difficult to customize the errors to be helpful for end-users.\n\n- **They make custom types hard.** Many validators ship with built-in types like emails, URLs, UUIDs, etc. with no way to know what they check for, and complicated APIs for defining new types.\n\n- **They don't encourage single sources of truth.** Many existing APIs encourage re-defining custom data types over and over, with the source of truth being spread out across your entire code base.\n\n- **They don't throw errors.** Many don't actually throw the errors, forcing you to wrap everywhere. Although helpful in the days of callbacks, not using `throw` in modern JavaScript makes code much more complex.\n\n- **They're tightly coupled to other concerns.** Many validators are tightly coupled to Express or other frameworks, which results in one-off, confusing code that isn't reusable across your code base.\n\n- **They use JSON Schema.** Don't get me wrong, JSON Schema _can_ be useful. But it's kind of like HATEOAS—it's usually way more complexity than you need and you aren't using any of its benefits. (Sorry, I said it.)\n\nOf course, not every validation library suffers from all of these issues, but most of them exhibit at least one. If you've run into this problem before, you might like Superstruct.\n\nWhich brings me to how Superstruct solves these issues...\n\n<br/>\n\n### Principles\n\n1. **Customizable types.** Superstruct's power is in making it easy to define an entire set of custom data types that are specific to your application, and defined in a _single_ place, so you have full control over your requirements.\n\n2. **Unopinionated defaults.** Superstruct ships with native JavaScript types, and everything else is customizable, so you never have to fight to override decisions made by \"core\" that differ from your application's needs.\n\n3. **Composable interfaces.** Superstruct interfaces are composable, so you can break down commonly-repeated pieces of data into components, and compose them to build up the more complex objects.\n\n4. **Useful errors.** The errors that Superstruct throws contain all the information you need to convert them into your own application-specific errors easy, which means more helpful errors for your end users!\n\n5. **Familiar API.** The Superstruct API was heavily inspired by [Typescript](https://www.typescriptlang.org/docs/handbook/basic-types.html), [Flow](https://flow.org/en/docs/types/), [Go](https://gobyexample.com/structs), and [GraphQL](http://graphql.org/learn/schema/). If you're familiar with any of those, then its schema definition API will feel very natural to use, so you can get started quickly.\n\n<br/>\n\n### Demo\n\nTry out the [live demo on CodeSandbox](https://codesandbox.io/s/bold-water-s2cr8d?file=/index.js) to get an idea for how the API works, or to quickly verify your use case:\n\n[![Demo screenshot.](./docs/images/demo-screenshot.png)](https://codesandbox.io/s/bold-water-s2cr8d?file=/index.js)\n\n<br/>\n\n### Examples\n\nSuperstruct's API is very flexible, allowing it to be used for a variety of use cases on your servers and in the browser. Here are a few examples of common patterns...\n\n- [Basic Validation](./examples/basic-validation.js)\n- [Custom Types](./examples/custom-types.js)\n- [Default Values](./examples/default-values.js)\n- [Optional Values](./examples/optional-values.js)\n- [Composing Structs](./examples/composing-structs.js)\n- [Throwing Errors](./examples/throwing-errors.js)\n- [Returning Errors](./examples/returning-errors.js)\n- [Testing Values](./examples/testing-values.js)\n- [Custom Errors](./examples/custom-errors.js)\n\n<br/>\n\n### Documentation\n\nRead the getting started guide to familiarize yourself with how Superstruct works. After that, check out the full API reference for more detailed information about structs, types and errors...\n\n- [**Guide**](https://docs.superstructjs.org/guides/01-getting-started)\n  - [Getting Started](https://docs.superstructjs.org/guides/01-getting-started)\n  - [Validating Data](https://docs.superstructjs.org/guides/02-validating-data)\n  - [Coercing Data](https://docs.superstructjs.org/guides/03-coercing-data)\n  - [Refining Validation](https://docs.superstructjs.org/guides/04-refining-validation)\n  - [Handling Errors](https://docs.superstructjs.org/guides/05-handling-errors)\n  - [Using TypeScript](https://docs.superstructjs.org/guides/06-using-typescript)\n- [**Reference**](https://docs.superstructjs.org/api-reference/core)\n  - [Core](https://docs.superstructjs.org/api-reference/core)\n  - [Types](https://docs.superstructjs.org/api-reference/types)\n  - [Refinements](https://docs.superstructjs.org/api-reference/refinements)\n  - [Coercions](https://docs.superstructjs.org/api-reference/coercions)\n  - [Utilities](https://docs.superstructjs.org/api-reference/utilities)\n  - [Errors](https://docs.superstructjs.org/api-reference/errors)\n  - [TypeScript](https://docs.superstructjs.org/api-reference/typescript)\n- [**FAQ**](https://docs.superstructjs.org/resources/faq)\n- [**Resources**](https://docs.superstructjs.org/resources/links)\n\n[![Docs screenshot.](./docs/images/docs-screenshot.png)](https://docs.superstructjs.org)\n\n<br/>\n\n### License\n\nThis package is [MIT-licensed](./License.md).\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "jsr.json",
          "type": "blob",
          "size": 0.2177734375,
          "content": "{\n  \"$schema\": \"https://jsr.io/schema/config-file.v1.json\",\n  \"name\": \"@superstruct/core\",\n  \"version\": \"2.0.2\",\n  \"exports\": \"./src/index.ts\",\n  \"publish\": {\n    \"include\": [\"Readme.md\", \"License.md\", \"src\", \"docs\"]\n  }\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 2.177734375,
          "content": "{\n  \"name\": \"superstruct\",\n  \"description\": \"A simple and composable way to validate data in JavaScript (and TypeScript).\",\n  \"version\": \"2.0.2\",\n  \"license\": \"MIT\",\n  \"repository\": \"git://github.com/ianstormtaylor/superstruct.git\",\n  \"type\": \"module\",\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"sideEffects\": false,\n  \"files\": [\n    \"dist\"\n  ],\n  \"publishConfig\": {\n    \"registry\": \"https://registry.npmjs.org\"\n  },\n  \"engines\": {\n    \"node\": \">=14.0.0\"\n  },\n  \"devDependencies\": {\n    \"@rollup/plugin-typescript\": \"^11.1.6\",\n    \"@types/expect\": \"^24.3.0\",\n    \"@types/lodash\": \"^4.14.144\",\n    \"@types/node\": \"^18.7.14\",\n    \"@typescript-eslint/eslint-plugin\": \"^7.1.1\",\n    \"@typescript-eslint/parser\": \"^7.1.1\",\n    \"eslint\": \"^8.57.0\",\n    \"eslint-config-prettier\": \"^9.1.0\",\n    \"eslint-plugin-prettier\": \"^5.1.3\",\n    \"lodash\": \"^4.17.15\",\n    \"np\": \"^10.0.0\",\n    \"prettier\": \"^3.2.5\",\n    \"rollup\": \"^4.12.1\",\n    \"typescript\": \"^4.8.3\",\n    \"vitest\": \"^1.6.0\"\n  },\n  \"scripts\": {\n    \"build\": \"rm -rf ./{dist} && rollup --config ./rollup.config.js\",\n    \"clean\": \"rm -rf ./{dist,node_modules}\",\n    \"fix\": \"npm run fix:eslint && npm run fix:prettier\",\n    \"fix:eslint\": \"npm run lint:eslint --fix\",\n    \"fix:prettier\": \"prettier '**/*.{js,json,ts}' --write\",\n    \"lint\": \"npm run lint:eslint && npm run lint:prettier\",\n    \"lint:eslint\": \"eslint '{src,test}/*.{js,ts}'\",\n    \"lint:prettier\": \"prettier '**/*.{js,json,ts}' --check\",\n    \"release\": \"npm run build && npm run lint && np\",\n    \"test\": \"npm run build && npm run test:types && npm run test:vitest\",\n    \"test:types\": \"tsc --noEmit && tsc --project ./test/tsconfig.json --noEmit\",\n    \"test:vitest\": \"vitest run\",\n    \"test:watch\": \"vitest\",\n    \"watch\": \"npm run build -- --watch\"\n  },\n  \"keywords\": [\n    \"api\",\n    \"array\",\n    \"assert\",\n    \"cast\",\n    \"check\",\n    \"checker\",\n    \"collection\",\n    \"data\",\n    \"error\",\n    \"express\",\n    \"hapi\",\n    \"interface\",\n    \"invalid\",\n    \"joi\",\n    \"json\",\n    \"list\",\n    \"model\",\n    \"object\",\n    \"orm\",\n    \"scalar\",\n    \"schema\",\n    \"struct\",\n    \"throw\",\n    \"type\",\n    \"types\",\n    \"valid\",\n    \"validate\",\n    \"validation\",\n    \"validator\"\n  ]\n}\n"
        },
        {
          "name": "rollup.config.js",
          "type": "blob",
          "size": 0.3896484375,
          "content": "import { defineConfig } from 'rollup'\nimport typescript from '@rollup/plugin-typescript'\n\nexport default defineConfig({\n  input: './src/index.ts',\n  plugins: [typescript()],\n  output: [\n    {\n      file: './dist/index.mjs',\n      format: 'esm',\n      sourcemap: true,\n    },\n    {\n      file: './dist/index.cjs',\n      format: 'umd',\n      name: 'Superstruct',\n      sourcemap: true,\n    },\n  ],\n})\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tsconfig.json",
          "type": "blob",
          "size": 0.390625,
          "content": "{\n  \"include\": [\"./src/**/*.ts\"],\n  \"compilerOptions\": {\n    \"allowSyntheticDefaultImports\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"esnext\"],\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"outDir\": \"./dist\",\n    \"sourceMap\": true,\n    \"strict\": true,\n    \"suppressImplicitAnyIndexErrors\": true,\n    \"target\": \"es2020\"\n  }\n}\n"
        }
      ]
    }
  ]
}