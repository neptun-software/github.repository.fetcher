{
  "metadata": {
    "timestamp": 1736564748534,
    "page": 438,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "oakserver/oak",
      "stars": 5238,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".devcontainer",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.064453125,
          "content": "!.vscode\n.tool-versions\noak.bundle.js\ncov.lcov\njunit.xml\ncov/\nnpm/"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 36.580078125,
          "content": "# oak Change Log\n\n## Version 17.1.4\n\n- fix: close file on readAll exception (#682)\n- chore: update vulnerable path-to-regexp version (#684)\n- chore: make it clear that the npm package is deprecated (3dfcbaf)\n- chore: cleanup dependencies (d982240)\n- chore: update copyright year (a98f613)\n- docs: update info around `.handle()` method (26ae6bd)\n\n## Version 17.1.3\n\n- fix: decode path to avoid bypassing security checks (4b2f27e)\n\n## Version 17.1.2\n\n- fix: allow proxy middleware to reuse body from memo (#679)\n\n  Thanks @bodograumann\n\n## Version 17.1.1\n\n- fix: properly handle invalid URLs in router (05ab3b5)\n\n## Version 17.1.0\n\n- fix: updates to support Deno 2 (de20780)\n\n## Version 17.0.0\n\nReleasing as a major release out of the abundance of caution in that the ability\nto re-read the body request is a breaking change (in a good way), but the update\nto oak/commons v1 and deno/std v1 introduced a couple of knock on minor breaking\nchanges that might change some behaviors in unexpected ways.\n\nThere were no changes to support Deno v2 release candidate, but this is the\nfirst release to be tested against Deno v2.\n\n- feat: ability to re-read the body of the request (e099557)\n\n  When the body API was re-aligned to the Fetch Request API in v13, it also\n  followed that the body can only be consumed a single time. This is unexpected\n  for those using a middleware framework, where people generally expect to be\n  able to read the body several times as they process the request.\n\n  This feature memoizes the body based on the type it was originally read as and\n  then can be subsequently read as a compatible type.\n\n  If you read it first as one type and then switch to an incompatible type, the\n  method will throw (for example, reading as an array buffer but then attempting\n  to read as text).\n\n- refactor: use PropertyKey instead of key list (#662)\n- chore: run CI on canary (#672)\n- chore: migrate to std and commons v1 (d6f9d38)\n\n  There were some minor behavioral changes with media-types and HTTP errors that\n  have impacted the behavior of oak.\n\n## Version 16.1.0\n\n- feat: support authority pseudo header for request (0c8b8da)\n- chore: create jekyll-gh-pages.yml (e1bceb9)\n- chore: redirect root github pages (4e4f5cd)\n- chore: migrate to commons 0.11 (cbf6ac1)\n\n## Version 16.0.0\n\n- feat: remove helpers module (3cd8bf5)\n\n  **BREAKING CHANGE** the helpers module was removed, it only provided a single\n  function which was of little value.\n\n- fix: bun and node server respect abort signal (662d1fe)\n- refactor: break apart util, move form_data to commons (ba0ecaf)\n- refactor: move etag to middleware/etag and remove re-exports from std\n  (70e4cbf)\n\n  **BREAKING CHANGE** The following APIs were being re-exported from etag, but\n  have been present in Deno @std/http/etag for an extended period of time and\n  the re-exports have been removed:\n\n  - `calculate`\n  - `type ETagOptions`\n  - `type FileInfo`\n  - `ifMatch`\n  - `ifNoneMatch`\n\n- chore: fix linting issues (785867e)\n- chore: publish more modules for documentation purposes (90db374)\n- chore: update to std 0.223 (7a766dc)\n- chore: add copyright header (9f6263e)\n- chore: additional infrastructure cleanup (3e875c9)\n- chore: more cleanup of unused fixtures (bbd2111)\n\n## Version 15.0.0\n\n- feat: migrate to @oak/commons/range (de1026f)\n\n  **BREAKING CHANGE** The migration to @oak/commons/range was a total rewrite of\n  the range logic that was implemented in oak, and the previous exported APIs\n  were no longer compatible, and therefore are no longer available in the\n  `mod.ts`. If you are looking for lower level range support, see\n  [@oak/commons/range](https://jsr.io/@oak/commons/doc/range/~)\n\n- chore: add publish workflow (c8e535f)\n- chore: update to std 0.222 and commons 0.8 (1265cde)\n- chore: fix linting in examples (c8ac46a)\n- chore: remove unused config file (f2df0ee)\n- chore: add publish exclusions (d2057e)\n- docs: fix typo in README (dd9cbda)\n\n## Version 14.2.0\n\n- chore: update codecov config (fcc7c96)\n- chore: update codecov config (af33378)\n- chore: update CI config (7a000b1)\n- chore: more CI changes (b6bfa86)\n- chore: merge in jsr changes (5e80e65)\n- chore: migrate to @oak/commmons 0.7.0 (8293071)\n- chore: remove npm build (1345298)\n- chore: move examples to use jsr, update inline docs (a746485)\n- docs: update README badges (b057920)\n- docs: update main export inline docs (98f4261)\n\n## Version 14.1.1\n\n- chore: update to std 0.218.2 (298bc6f)\n- docs: update router module doc (6a41fff)\n\n## Version 14.1.0\n\n- feat: add support for Bun (c7d6ae3)\n\n  oak natively supports the built in Bun HTTP server.\n\n- feat: initial Cloudflare Worker support (a7f87e5)\n\n  The oak application provides a Fetch Handler for Cloudflare Workers.\n\n- tests: ignore specific bun test (f3dc3d5)\n- chore: cleanup on http_server_native_request (27cf442)\n- docs: improve inline documentation (928d9f0)\n- docs: update readme (b46ee42)\n\n## Version 14.0.0\n\n- feat: send events immediately sends response to client (a3f0076)\n\n  **BREAKING CHANGE** Previous versions of oak would return a\n  `ServerSentEventTarget` when calling `.sendEvents()` on the context, but would\n  not send the response to the client until all the middleware completed\n  processing. Now, the response is sent back to the client immediately (like the\n  websocket `.upgrade()` method) which results in the `ServerSentEventTarget`\n  being returned in a promise and also preventing any further changes to\n  response by other middleware.\n\n  This has the benefit of meaning any events dispatched from within the main\n  flow of the current middleware are sent to the client straight away instead of\n  appearing to be buffered.\n\n- fix: http_server_native when closing with signal abort event (#639)\n- chore: update to std 0.217.0 (bc88315)\n\n## Version 13.2.5\n\n- fix: wrong file dynamically imported (#638)\n- fix: tag server constructors (120a024)\n- refactor: move to std assert (f8ab89e)\n- chore: update to std 0.215.0 (5b45806)\n- chore: update oak commons (151c6bd)\n\n## Version 13.2.4\n\n- fix: more global namespace fixes for node (f1b7d46)\n\n## Version 13.2.3\n\n- fix: shim more globals for node (d879951)\n\n## Version 13.2.2\n\n- fix: handle accessing Deno namespace better (4150b36)\n\n## Version 13.2.1\n\n- fix: don't access Deno namespace unguarded (5b49419)\n\n## Version 13.2.0\n\n- feat: use dynamic imports for node compat (db116d1)\n\n  Instead of depending on dnt to swap out modules for Node compatibility, there\n  is a single codebase which dynamically imports modules based on runtime\n  detection of the environment.\n\n- fix: fast check fixes (c6db0ac)\n- docs: update README badges (aafc571)\n- docs: fix typo in README badge (af7dc72)\n- chore: update https server example (#637)\n- chore: update github actions (44ddcbf)\n\n## Version 13.1.0\n\n- feat: make interop with Fetch API easier (4d4034b)\n\n  For code designed to work with the Fetch API's `Request` and `Response` (like\n  `Deno.serve()`) there are now several features that make interop easier. There\n  is now the `serve()` and `route()` middleware which will wrap a handler\n  function to operate with oak.\n\n- fix: don't set content-type on body FormData (2e2f5da)\n\n  This was causing the boundary to not be set when responding with a `FormData`\n  body and therefore making the browser unable to decode the body.\n\n- refactor: migrate to oak commons for media type utils (b075f2e)\n- refactor: migrate from .d.ts to .ts for type information (e3fcbcb)\n- tests: bulk refactor (81c81fe)\n- chore: update copyright dates (436577a)\n- chore: integrate import map into deno config (3d328cf)\n- docs: fix typo in README (567245e)\n\n## Version 13.0.1\n\n- fix: explicit typings for body (43bcd82)\n- fix: add type to body blob (b74b374)\n- chore: update to oak commons 0.5.2 (25d82e1)\n- docs: document body API in README (43de84a)\n\n## Version 13.0.0\n\n- feat: align request body better to Fetch API (bb996fe)\n\n  **BREAKING CHANGE** Previous versions of oak had a request body API that was\n  fairly convoluted as oak evolved from the early days of Deno where there\n  wasn't a built in APIs for handling HTTP requests. The Fetch API `Request` and\n  `Response` have become the standard almost everywhere and make it easy to get\n  ahold of a request body in many forms.\n\n  Inspired by this the `ctx.request.body` aligns to this API for the most part,\n  but also still retains some of the advantages that oak provided like providing\n  a `ctx.request.body.type` to help figure out what sort of body you are looking\n  at as well as support for `ctx.request.body.form()`.\n\n  This also leverages native Fetch API where possible which resolved a lot of\n  issues with decoding multi-part forms. This does mean files that are uploaded\n  to oak become web standard `File`s that are entries in `FormData`. This means\n  `multipart.ts` has been removed from oak and the\n\n- refactor: use Deno.serve() instead of Deno.serveHttp() (bbae544)\n\n  **BREAKING CHANGE** As of Deno 1.40.0, `Deno.serveHttp()` is deprecated and\n  will be removed in Deno 2.0. The Deno implementation of oak finally migrates\n  to `Deno.serve()`. While this should be transparent in most cases, it has\n  changed some of the options that can be used when using `app.listen()` to\n  align to the `Deno.serve()` options. Also, unlike unstable `Deno.serverHttp()`\n  `Deno.serve()` doesn't support HTTP/2, therefore it isn't currently possible\n  to support HTTP/2 in oak.\n\n- fix: remove deprecated API, work around Deno bug (71a1d92)\n\n  There were a few other APIs that were deprecated in Deno 1.40.0 that did not\n  impact the oak APIs, as well as a regression that has been fixed in patch\n  releases that was worked around.\n\n- fix: issues in current versions of node (43733a0)\n\n  Current versions of Node.js had some issues that were not present in Node.js\n  16. These were resolved.\n\n- fix: application errors dispatched after default logic (f37796b)\n\n  Resolved #630\n\n- tests: add descriptions to some tests (9fb56b3)\n- chore: rework exports (4bb93fb)\n- chore: fix exports (6e2d9b3)\n- chore: remove unused dep (ebe6801)\n- chore: migrate to oak commons 0.5.0 (d5752e6)\n- chore: remove unstable tests (9dc5ca7)\n- chore: remove unused import (09fd336)\n- chore: update to std 0.212.0 (a854c72)\n- chore: fix exports (d416773)\n\n## Version 12.6.3\n\n- chore: add jsr metadata (6c30bdf)\n- chore: rename deno.jsonc to deno.json (681da74)\n- docs: fix typo in index.md (#600)\n\n## Version 12.6.2\n\n- chore: update to std 0.211.0, commons 0.4.0, dnt 0.39.0 (494aa7b)\n- chore: remove deno bundle ci task (8db4394)\n\n## Version 12.6.1\n\n- fix: untrack http conns when closed (da6d30d)\n- chore: remove unused lint pragma (614df5e)\n- chore: update to std 0.200.0 and dnt 0.38.1 (eb51995)\n- chore: fix type checking issue in build script (5ca2870)\n\n## Version 12.6.0\n\n- feat: add userAgent to request (e292470)\n\n  `ctx.request` now contains an object representing the user agent in a property\n  called `.userAgent`.\n\n  See\n  [std/http/user_agent#UserAgent](https://deno.land/std@0.193.0/http/user_agent.ts?s=UserAgent)\n  for more information. Inspired by #603.\n\n- chore: update to std 0.190.0 (4bf071d)\n- chore: update to dnt 0.36.0 (2f394bf)\n- chore: update dnt 0.37.0, std 0.193.0 (c052b2b)\n- docs: remove outdated comment (f0ad28b)\n\n## Version 12.5.0\n\n- feat: body parsing throws HTTP errors. (79349d7)\n\n  Now when parsing the body of a request, when an error is encountered, an HTTP\n  error is thrown instead of a SyntaxError or TypeError. This makes it easier to\n  respond to \"bad requests\" without additional error handling in middleware.\n\n- fix: allow setting headers and expose on `Context.prototype.assert()` (#605)\n\n  After migrating to HTTP errors from Deno std library, there were some\n  regressions in functionality when passing options. This restores this lost\n  functionality.\n\n- chore: update to std 0.188.0 (1534696)\n- chore: update to dnt 0.35.0 (02612c9)\n- chore: revert CI to stable (635af06)\n- chore: revert format change (91bf20f)\n- chore: migrate to std for method, `ErrorStatus`, `RedirectStatus` (4870970)\n- chore: update copyright years (022d50e)\n- docs: remove extra words in FAQ.md (#606)\n\n## Version 12.4.0\n\n- feat: add context to fetch for proxy (b025488)\n\n  When providing a `fetch()` method on proxy middleware init options, the method\n  will be called with an init of `{ context }` which includes the current\n  context. This allows advanced usage cases where the context impacts how the\n  fetch is handled (e.g. like setting upstream request headers, etc.).\n\n- chore: update to std 0.185.0 (07a011a)\n- chore: update to dnt 0.34.0 (5064a71)\n- chore: update to Deno 1.33 (e564135)\n- chore: move CI to deno canary (811f531)\n\n## Version 12.3.1\n\n- **SECURITY** fix: avoid parse middleware DDOS (03c6b74)\n\n  The parse middleware was using an exponentially complex regular expression to\n  validate the `Forwarded` header on requests, making it trivial to create a\n  request that would cause CPU exhaustion. This is now fixed.\n\n- chore: reduce `50MB.zip` size (#487)\n\n## Version 12.3.0\n\n- feat: add `MiddlewareObject` (#589)\n\n  Middleware can be registered as a middleware function or a `MiddlewareObject`\n  which is an object which has a `handleRequest()` method and optionally an\n  `init()` which will be called when the application starts listening.\n\n- feat: add `\"close\"` event to Application (f564e38)\n\n  The `Application` now emits a `\"close\"` event when it has stopped handling\n  requests.\n\n- feat: add `Router.prototype.add` to allow specifying methods (b8d0e80)\n\n  The `.add()` method can be used on router instances to register middleware\n  with arbitrary sets of HTTP methods. This allows usage of uncommon HTTP\n  methods as well as potentially procedural configuration of the router.\n\n- feat: add type guard (#502)\n\n  The `isNativeRequest()` type guard is added which makes it easier to detect if\n  a request is a Deno native request in order to be able to safely access the\n  original request.\n\n- fix: cleanup SSE and web socket on application close (11e4172)\n\n  Previously, if the application stopped listening (closed), it would not close\n  down SSE or socket connections, therefore making it difficult to shutdown\n  cleanly. Now it should.\n\n- fix: set body and headers when init'ing SSE (8685c7a)\n\n  oak 12.2.0 did not properly convert over to the std libraries SSE target. It\n  now handles this properly.\n\n- docs: add \"The response is not writable.\" to FAQs (be310ee)\n- docs: add \"early eof\" to FAQs (6d21b7a)\n\n## Version 12.2.0\n\n- feat: remove experimental support for Deno flash server (d9f8829)\n\n  Version 1.35 of Deno will remove the\n  [experimental flash server](https://github.com/denoland/deno/pull/18568). The\n  abstraction to the HTTP server that will be stabilised provides no benefit to\n  oak, so the support for \"flash\" is being removed.\n\n- refactor: use SSE from std (9a6ae5d)\n\n  oak contributed `http/server_sent_event` to the Deno std library, and is now\n  migrating to that.\n\n- refactor: use std library for etag (e95bc10)\n\n  oak contributed `http/etag` to the Deno std library, and is now migrating to\n  that.\n\n- fix: update sseServer example (14a5b5c)\n- docs: remove experimental flash content from README (024aa8a)\n\n## Version 12.1.0\n\n- refactor: use `KeyStack` from std (d2eff20)\n\n  oak contributed `KeyStack` to the Deno std library, and is now migrating to\n  that.\n\n- refactor: migrate to `SecureCookieMap` from std (b136fdc)\n\n  oak contributed its cookie management to the Deno std library, and is now\n  migrating to that.\n\n## Version 12.0.1\n\n- fix: decode empty request bodies for JSON as null (fa98626)\n- fix: handle throwing in context construction (ba9b7cc)\n- fix: send() doesn't set content-length header (b62de95)\n\n## Version 12.0.0\n\n- feat: `Router.prototype.all` uses all methods (4ddc851)\n\n  **BREAKING** when using `Router.prototype.all()` to register middleware, it\n  will now use all the methods (except `OPTIONS`) to register the middleware\n  instead of an arbitrary set of common methods.\n\n- fix: use null prototype with cookie match cache (798eca7)\n- fix: `Router.prototype.all` omit `OPTIONS` method (98067a4)\n- fix: use `\"Allow\"` versus `\"Allowed\"` header for `OPTIONS` (3bcd4eb)\n- fix: update types for TypeScript 4.9 (31a1c7f)\n- fix: save route name during route matching (#574)\n- fix: zero `content-length` triggering max body size error (#552)\n- fix: remove unused function from flash server (01264e6)\n- chore: fix node tests (5ea9729)\n- chore: update checkout action (811e0ea)\n- chore: lint (b2a7356)\n- chore: fmt (507990e)\n- chore: rework ci (08a6e78)\n- chore: update to std@0.178 and dnt@0.33.1 (0a7d616)\n- tests: improve headers test coverage (#562)\n- docs: update info on handling formdata files (#555)\n\n## Version 11.1.0\n\n- feat: provide options for JSON replacing and reviving (855ecf0)\n\n  You can now set `jsonBodyReplacer` and `jsonBodyReviver` to assist when\n  automatic decoding of JSON bodies in requests or responses occur. This allows\n  custom logic to achieve things like handling bigints, circular references, and\n  custom serialization of things like `RegExp`.\n\n- fix: add missing generic parameters for multiple middlewares (#549)\n- fix: refactor flash to align to Deno 1.25 release (f3976fc)\n- fix: add flash support to staticServer example (48130a2)\n- docs: repoint doc URL to just deno.land/x (8237e7a)\n\n## Version 11.0.0\n\n- feat: make overriding router parameter types easier (#513)\n\n  When route type inference breaks down, it was previously difficult to provide\n  a different set of asserted route parameters. This now makes it easier.\n\n- feat: support Deno's experimental flash server (#545)\n\n  As of this release Deno canary includes the experimental flash HTTP server\n  which dramatically increases performance when running in Deno CLI. It is\n  expected to ship as unstable in Deno 1.25. See the README and module doc for\n  information on how to enable the flash server.\n\n  oak's support for flash is also experimental at this point.\n\n- refactor: update deps, migrate more to std/http\n\n  Much of the common parts of oak have been being contributed back to `std/http`\n  and refactoring to support this migration is underway. Because there are\n  likely to be minor and subtle differences in how things operate, this release\n  of oak is a major release. I am not currently aware of any major breaking\n  changes, but wanted to ensure that people were consciously aware.\n\n- docs: don't await body.value in examples (dbabc1c)\n- docs: fix typo in multipart.ts JSDocs (#466)\n- docs: improve maxSize and maxFileSize in multipart.ts (#467)\n- chore: unpin deno version for CI (728ba71)\n\n## Version 10.6.0\n\n- feat: expose createHttpError (#525)\n- fix: don't block subsequent requests on a connection (#529)\n- fix: Deno.ListenTlsOptions detection (#521)\n- docs: add missing await in README static content example. (#506)\n- docs: \"sever\" to \"server\" in README (#509)\n- docs: fix FAQ entry for addEventListener (#511)\n- docs: fix typo in `multipart.ts` (#527)\n- chore: update to Deno 1.22.0, std 0.140.0, media_types 3.0.3 (17d9e61)\n- chore: fix ci (00ddfcd)\n\n## Version 10.5.1\n\n- chore: update to std 0.131.0, media_types 3.0.2, dnt 0.22.0 (c1e0ea9)\n- chore: update codecov action (#494)\n- chore: migrate to deno task and deno.jsonc (ccc39db)\n\n## Version 10.5.0\n\n- feat: application supports omitting options, defaults to port 0\n\n  You can now avoid \"boilerplate\" code, especially on Deploy with `Application`\n  `listen()` by not passing any config options to start listening.\n\n- fix: update npm and fix issues\n- tests: de-duplicate test name\n- docs: add await to `etag.calculate` example (#480)\n- chore: update to Deno 1.19.2, std 0.128.0, media_types 2.12.3\n\n## Version 10.4.0\n\n- feat: support CJS for npm package (2f38652)\n\n  The npm distribution now includes ESM and CJS modules, enabling oak to be\n  imported with `require()` in Node.js.\n\n- refactor: remove dynamic import (e776011)\n\n## Version 10.3.0\n\n- feat: add experimental support for Node.js (#479)\n\n  oak is now available as an Node.js npm package: `@oakserver/oak`. See\n  [oak and Node.js](https://oakserver.github.io/oak/node) for more information.\n\n- chore: update to Deno 1.19.0, media_types 2.12.2 (a4104a6)\n\n## Version 10.2.1\n\n- docs: improve inline documentation (bd7e692)\n- chore: remove a workaround for a Deno bug (60327f9)\n\n## Version 10.2.0\n\n- feat: add support for custom content types when reading formdata (6cd2d53)\n\n  When reading a form data body, you can now supply a record of custom content\n  types to extension to use when handling custom content types.\n\n- chore: update to Deno 1.18.1, std 0.123.0, media_types 2.12.1 (f399784)\n- docs: improve inline docs (8831d51)\n\n## Version 10.1.1\n\n- fix: correct negotiation algorithm (ad6b896)\n- fix: use interface to represent Deno.core instead of modifying global type\n  scope (#444)\n- chore: update to Deno 1.18, std 0.122.0, media_types 2.12.0 (26a22e9)\n- chore: update CI to Deno 1.18 (a4d4c47)\n- chore: update copyright dates (dd3910f)\n- docs: Update README to represent changes made (#447)\n- docs: improve static content (#450)\n\n## Version 10.1.0\n\n- fix: type assignment issues with TS 4.5 and later (2e76d12)\n- fix: implement mock for Request#accepts (#432)\n- chore: update to Deno 1.17.0, std 0.118.0 and media_types 2.11.1 (aa4e961)\n- chore: remove dectyl (5aa9d23)\n- chore: add bundling tests (50f311e)\n\n## Version 10.0.0\n\n- feat: remove `std/http` and `std/ws` (#408)\n\n  **BREAKING CHANGE**\n\n  All HTTP native server implementations have been stabilized in Deno, so the\n  support of `std/http` and `std/ws` have been removed. There is no way to\n  \"force\" oak to use the Deno `std/http`.\n\n- feat: remove deprecated fetchEventHandler (6749922)\n\n  **BREAKING CHANGE**\n\n  The `.fetchEventHandler()` used with Deno Deploy which was deprecated has been\n  removed. Deploy users should invoke oak just like they were using oak in the\n  Deno CLI.\n\n- feat: add limit when getting a request body (34c179b)\n\n  **BREAKING CHANGE**\n\n  There is a default limit when reading a body to avoid DDOS attacks where a\n  malicious client can send a body that is too large for the server to handle.\n  To disable the feature, set the `limit` option when reading a body to `0` or\n  `Infinity`.\n\n- feat: mocked contexts provide the cookies property (#422)\n\n  The testing utilities now allow cookies to be provided when creating a mock\n  context.\n\n- feat: infer RouteParam types (9cf12d0)\n\n  **BREAKING CHANGE**\n\n  When using the `Router()` and adding middleware, the types have been updated\n  to infer the route params property of the context from the route provided.\n\n  This means in certain situations where the route params were asserted by\n  setting the generic value is no longer necessary and can actually cause type\n  errors. Users should just remove explicit generic settings and instead allow\n  the type to be inferred from the route string.\n\n- feat: add ignoreInsecure when setting a cookie (16cdcc1)\n\n  Users attempting to set secure cookies in what appears to be an insecure\n  context can use the `ignoreInsecure` option when setting the cookie to\n  suppress the error.\n\n- fix: refactor `request.hasBody` and `request.body()` (b1e2921)\n\n  In HTTP/2 many requests with a body would actually be set to a zero length\n  body, since the body cannot be reliably determined until it is attempted to be\n  read. As of Deno 1.16.1 this behavior is also reflected in HTTP/1.1 requests.\n  This highlighted that `.hasBody` is not a reliable API, and code was\n  refactored to handle this better, as well as handle zero length and undefined\n  bodies in `request.body()`. When asserting a specific body type, and there is\n  not a body present, a zero length body of the type requested is returned,\n  previously this would have thrown. This means it is now always safe to request\n  a specific body type from `request.body()`.\n\n- fix: proxy middleware doesn't use global flag on regex (#429)\n- fix: decode path as URL, not component (dd4c091)\n\n  This fixed issues where path separators that are encoded in the path are not\n  decoded, which is better aligned to expectations and other middleware\n  frameworks.\n\n- docs: fix typo in Middleware import (#426)\n- docs: Improved readability for getting started section (#421)\n- docs: simplify code example (#414)\n- chore: update to Deno 1.16.1, std 0.114.0, media_types 2.11.0 (1a4e488)\n- chore: re-enable code cov upload (14b61cc)\n- chore: ignore lint rule (950cf48)\n- chore: update router examples (8463c22)\n\n## Version 9.0.1\n\n- feat: rename logging errors to uncaught application errors (be0390c)\n\n  For clarity, application errors are no longer labelled as coming from oak, but\n  instead are labelled as uncaught application errors.\n\n- fix: ensure can close the native server by closing open http connections\n  (#389)\n- fix: ensure code works with no check (6157784)\n- fix: upgrading connection to WebSocket (#401)\n- docs: fix typo in FAQs (#390)\n- docs: fix typo in README (#395)\n- chore: add jobs flag to tests in ci (50bbe52)\n- chore: only generate lcov on linux on ci (b956357)\n- chore: make `useUnknownInCatchVariables` type safe (6f680c9)\n- chore: move ci to Deno 1.14.0\n\n## Version 9.0.0\n\n- **BREAKING CHANGE** refactor: move to web crypto for cookie signing (14c6b47)\n\n  Use the web crypto APIs for cookie signing and validation instead of the Deno\n  `std` library. This introduces a **breaking change** in that getting and\n  setting cookies are now performed asynchronously due to async nature of the\n  web crypto APIs. Both `.cookies.get()` and `.cookies.set()` return promises\n  which should be awaited.\n\n- feat: support request event interface for Deploy (2aadac6)\n\n  Add support for the request event interface for Deno Deploy, which is the same\n  API as the _native_ Deno CLI http server API. This means that Deploy\n  applications are started in the same way as if they are one the CLI, likely\n  meaning that there is no change to using oak when moving between Deno CLI and\n  Deploy. Deploy users should just `await app.listen()` like they would with CLI\n  applications.\n\n  This also _deprecates_ the `app.fetchEventHandler()` method. The method will\n  be removed in future version of oak.\n\n- refactor: move to web crypto instead of std createHash (2156f76)\n\n  The web crypto APIs are now used for internal purposes like creating etags and\n  generating temporary directories.\n\n- refactor: clean-up of logic in `HttpError` constructor (#381)\n- fix: listen event occurs on listen and contains correct info (44ab231)\n\n  The listen event would not be dispatched at the right time and potentially not\n  contain correct information. This has been fixed.\n\n- fix: range requests properly handle single last byte requests (#373)\n\n  Fixes an edge case where range requests requesting a single last byte would\n  fail.\n\n- fix: issue with types when using dom libs (7fcc494)\n- fix: allow streaming the request body multiple times (#384)\n- fix: malformed request url doesn't cause uncaught error (046c732)\n- fix: clear headers properly when uncaught error (83f0841)\n- chore: add easy dev container support (5eb2177)\n\n  The repository contains dev container information, making it easy to clone the\n  repo on GitHub and have a development environment.\n\n- chore: update to Deno 1.13.1, std 0.105.0, media_types 2.10.1 (bc9b82b)\n- chore: update to dectyl 0.10.3 (bc81512)\n- docs: update request body types documentation in readme (#383)\n- docs: update information about cookies API (d08dce7)\n\n## Version 8.0.0\n\n- **BREAKING CHANGE** feat: add native request web socket support (9d1b770)\n\n  The ability to upgrade Deno native HTTP requests is support by Deno 1.12 and\n  later and has been integrated into oak.\n\n  This also introduces a **breaking change**, where if using the `std` server\n  with oak, the `ctx.upgrade()` will resolve with a web standard `WebSocket`\n  interface, where previously it resolved with the non-standard `std` server\n  interface.\n\n- **BREAKING CHANGE** feat: options for the way state is create for a context\n  (f360e3f)\n\n  In oak v6 and prior, the context's `.state` was simply an alias to the\n  application's `.state`. In v7, the context's `.state` was a clone of the\n  application's `.state`. The problem was that not everything that could be\n  assigned to the application's state was cloneable, leading to runtime errors\n  when trying to handle requests.\n\n  In v8, the default behavior is similar to v7, but non-clone-able properties of\n  the applications `.state` are skipped. In addition, there is a new application\n  option which can be passed up creating a new application named `contextState`\n  which takes one of several values:\n\n  - `\"clone\"` - this is the default behavior mentioned above.\n  - `\"alias\"` - this is the behavior of oak v6 and prior, where the\n    application's `.state` strictly equals the context's `.state`.\n  - `\"prototype\"` - this creates a new `.state` for each context, using the\n    application's `.state` as the prototype.\n  - `\"empty\"` - a new empty object is created for each context's `.state`.\n\n- feat: allow setting of an extension/content type map for send() (f8ee902)\n\n  `send()` takes a new option of `contextTypes` which is a record of extensions\n  and content types to use. This allows extending and overriding of the existing\n  `media_types` database when serving files.\n\n- feat: log uncaught errors by default (7669d12)\n\n  While the application has emitted `\"error\"` events for quite a while, many\n  users are not aware of how listen for errors. Therefore by default, the\n  application will log to stderr any uncaught errors that occur within the\n  application. This behavior can be turned off by setting the application option\n  `logErrors` to `false` when creating a new application.\n\n- fix(#352): fix content-length in Range requests (#353)\n\n- fix(#362): handle errors occurring during finalizing response (7d39e1f)\n\n  Previously, if there were issues finalizing the response, such as attempting\n  to serialize to JSON the response's body, the error would be dispatched on the\n  application, but a response would not be sent back to the client, just\n  \"hanging\" the client. Now, an error response (500) should be sent back to the\n  client.\n\n- docs: update readme (6efacb1)\n- chore: update to Deno 1.12.1, std 0.102.0, media_types 2.9.3 (4bc080c)\n- chore: update vscode settings (f4138f9)\n\n## Version 7.7.0\n\n- feat: improve inspection/console logging (bfbf061)\n\n  Most oak classes now utilise Deno's custom inspect API to provide better\n  logging information.\n\n- feat: SSE can send keep-alive comments (3d27096)\n\n  When upgrading a connection to a server-sent-event target, the `keepAlive`\n  option can be set to allow \"polling\" of the connection to keep it alive (as\n  well as detect client disconnections without having to dispatch and event).\n\n- fix(proxy): Retain original search parameters (#347)\n\n  Search parameters in a proxied request are now forwarded.\n\n- fix(#343): parse out unique set-cookie headers\n\n  When setting multiple cookies in a response, adding additional cookies works\n  properly.\n\n- fix: SSEStreamTarget handles connections closing properly (0678104)\n\n  When using SSE with the native HTTP, client connections closing will now\n  trigger the `\"close\"` event properly.\n\n- chore: change ci to Deno 1.11.2 (bbd5fe4)\n- chore: restore lint comments until Deno 1.12 (93323c3)\n\n## Version 7.6.3\n\n- fix: type check under other targets (6fdb123)\n- fix: formatting (e51751c)\n- docs: correct typo (#342)\n\n## Version 7.6.2\n\n- feat: proxy supports content type callback (d471d1d)\n\n## Version 7.6.1\n\n- fix: handleError works correctly under Deploy (0d929ea)\n\n## Version 7.6.0\n\n- feat: improve support for Deno Deploy (2426ff2)\n\n  Fix issues with parsing certain request fields when running under deploy.\n\n- feat: add testing utilities (7baf73c)\n\n  Add utilities for make testing oak middleware easier. See\n  [Testing oak](https://oakserver.github.io/oak/testing) for more information.\n\n- feat: proxy middleware (bbc7ab7)\n\n  Add built in proxy middleware that makes it easier to do back to back proxy\n  requests using Deno CLI or Deno Deploy.\n\n- fix(#328): use Referer instead of Referrer header (a9c56c7)\n- fix(#335): remove extra CRLF in multipart (#338)\n- fix(#333): if proxy is true, then parse headers for url (9a628e3)\n- fix(#327): properly handle setting multiple cookies (275fe08)\n- tests: fix response test fixture (5d66aa1)\n- tests: async try catch throws (b6288d6)\n- chore: refactor based on canary Deno updating to TS 4.3 (43d2699)\n- chore: incorporate upcoming Deno changes (7a69a57)\n- chore: update to Deno 1.11.1, std 0.99.0, media_types 2.9.0 (d9e5387)\n\n## Version 7.5.0\n\n- feat: allow overriding std/native HTTP servers (771e7b0)\n\n  Exported `HttpSeverStd` and `HttpServerNative` to allow these to be supplied\n  when creating the application by passing the `serverConstructor` option, as\n  well as updated documentation around how to accomplish this.\n\n- fix(#282): `router.redirect()` destination can be arbitrary URL (802435c)\n- fix(#319): ensure that at least one middleware is present in types (29326ef)\n- fix: upcoming TypeScript 4.3 changes (fe7ad3c)\n- docs: add information about Deno Deploy (3faadda)\n\n## Version 7.4.1\n\n- chore: update to Deno 1.10.1, std 0.96.0, media_types 2.8.4\n\n## Version 7.4.0\n\n- feat: add range support for send() (#303)\n\n  When using `.send()` oak announces support for ranges and is able to process\n  the `Range` header along with `If-Range` header.\n\n- feat: add support for nested routers (#275)\n\n  Routers can now support \"sub\" or nested routers.\n\n- fix: properly close native listener (a7e053c)\n- fix: handle http connection errors (6d5f6d6)\n- fix: `context.app.state` is properly typed (81fcefa)\n- fix: setting response body to `null` or `undefined` returns 204 (af21480)\n- fix: no response body is `null` or `undefined`, not falsy (1481508)\n- refactor: allow non-void returns from middleware (b86f1da)\n- chore: restore Deno 1.9.1 to CI (9696760)\n- chore: Deno fmt updates (8398d6e)\n- chore: add example nested routing server (0d4b5d8)\n\n## Version 7.3.0\n\n- feat: better handling of readable streams in response body (#301)\n\n  Before, streams set as a body would always be assumed to be an Uint8Array\n  readable stream. Now any readable stream set as the response body will be\n  transformed automatically to an Uint8Array. In addition, when using the\n  `std/http` version, readable streams were treated as async iterators, now they\n  will be directly converted into a `Deno.Reader`.\n\n- fix: Deno 1.9.1 breaking changes (2527604)\n- fix: Deno 1.9.1 changes to native HTTP (0b8a7d8)\n- fix: better support for native HTTPS (e6d3e72)\n- chore: fix test cases for native request (8490b6f)\n- chore: update to Deno 1.9.1, std 0.94.0, media_types 2.8.2 (78c0997)\n- chore: revert to canary in CI until 1.9.1 available as action\n\n## Version 7.2.0\n\nBecause one minor release a day isn't good enough and:\n\n- feat: add app.fetchEventHandler() (#296)\n\n  Add a method which provides everything needed for handling Deno Deploy's\n  `FetchEvent`s.\n\n## Version 7.1.0\n\n- feat: enable server-sent events for native HTTP bindings (#293)\n\n  Server-sent events now work on both the `std/http` and the native HTTP server\n  with Deno.\n\n- refactor: make connection optional for app.handle() (#294)\n\n  This was required to support Deno Deploy.\n\n- refactor: add fallback for structured clone when core unavailable (#295)\n\n  This was also required to support Deno Deploy, as it currently doesn't expose\n  the low level APIs required to do structured cloning.\n\n## Version 7.0.0\n\n- feat: context.state is cloned from app.state (1590ac9)\n\n  This is also a **breaking change,** but in a way that is consistent with\n  general expectations about how state works, in that `Context::state` is no\n  longer global.\n\n- feat: add etag support (2a38d15)\n\n  The `etag.ts` module provides middleware and other tools to support `ETag`s.\n\n- feat: `.send()` supports ETag and If-None-Match automatically (be80283)\n\n  Using `.send()` to send files in responses will automatically handle setting\n  and validating `ETag`s from clients to deal with determining if files have\n  changed.\n\n- feat: Support Deno's native HTTP server (59e7a00)\n\n  As of Deno 1.9.0, Deno supports a _native_ HTTP server and now oak supports\n  both the `std/http` server and the native one. It does this transparently to\n  the user, so if the new native APIs are available, they will be used.\n\n  Currently to have the APIs available, you have to start Deno with the\n  `--unstable` flag.\n\n- refactor: support native HTTP request on request body (96373ac)\n\n  Using the `Request::body` is fully supported with the native HTTP server and\n  because of this the request body type of `\"stream\"` is supported, which will\n  return the body as a `ReadableStream<Uint8Array>`.\n\n  This also makes a **breaking change** where the `\"raw\"` body type was renamed\n  `\"bytes\"` to better reflect what is occurring.\n\n  This also works around an issue with Deno where when reading the response\n  body, the response fails.\n\n- refactor: minor refactors and removal of deprecated Deno APIs (993efa7)\n- chore: remove unused import (33f7463)\n- chore: remove unused lint rule (0ff0574)\n- chore: chore: update to Deno 1.9.0, std 0.93.0, media_types 2.8.1 (ac5c426)\n\n## Version 6.5.1\n\n- chore: Update to Deno 1.8.3, std 0.92.0, media_types 2.8.0\n- chore: add code coverage and badge to README\n- chore: migrate CI to official Deno actions\n- docs: minor type fixes\n- docs: add this CHANGELOG\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0517578125,
          "content": "MIT License\n\nCopyright (c) 2018-2025 the oak authors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 33.091796875,
          "content": "# oak\n\n[![jsr.io/@oak/oak](https://jsr.io/badges/@oak/oak)](https://jsr.io/@oak/oak)\n[![jsr.io/@oak/oak score](https://jsr.io/badges/@oak/oak/score)](https://jsr.io/@oak/oak)\n[![deno.land/x/oak](https://deno.land/badge/oak/version)](https://deno.land/x/oak)\n[![npm Version](https://img.shields.io/npm/v/@oakserver/oak)](https://www.npmjs.com/package/@oakserver/oak)\n\n[![oak ci](https://github.com/oakserver/oak/workflows/ci/badge.svg)](https://github.com/oakserver/oak)\n[![codecov](https://codecov.io/gh/oakserver/oak/branch/main/graph/badge.svg?token=KEKZ52NXGP)](https://codecov.io/gh/oakserver/oak)\n\nA middleware framework for Deno's native HTTP server,\n[Deno Deploy](https://deno.com/deploy), Node.js 16.5 and later,\n[Cloudflare Workers](https://workers.cloudflare.com/) and\n[Bun](https://bun.sh/). It also includes a middleware router.\n\nThis middleware framework is inspired by [Koa](https://github.com/koajs/koa/)\nand middleware router inspired by\n[@koa/router](https://github.com/koajs/router/).\n\nThis README focuses on the mechanics of the oak APIs and is intended for those\nwho are familiar with JavaScript middleware frameworks like Express and Koa as\nwell as a decent understanding of Deno. If you aren't familiar with these,\nplease check out documentation on\n[oakserver.github.io/oak](https://oakserver.github.io/oak/).\n\nAlso, check out our [FAQs](https://oakserver.github.io/oak/FAQ) and the\n[awesome-oak](https://oakserver.github.io/awesome-oak/) site of community\nresources.\n\n> [!NOTE]\n> The examples in this README pull from `main` and are designed for Deno CLI or\n> Deno Deploy, which may not make sense to do when you are looking to actually\n> deploy a workload. You would want to \"pin\" to a particular version which is\n> compatible with the version of Deno you are using and has a fixed set of APIs\n> you would expect. `https://deno.land/x/` supports using git tags in the URL to\n> direct you at a particular version. So to use version 13.0.0 of oak, you would\n> want to import `https://deno.land/x/oak@v13.0.0/mod.ts`.\n\n## Usage\n\n### Deno CLI and Deno Deploy\n\noak is available on both [deno.land/x](https://deno.land/x/oak/) and\n[JSR](https://jsr.io/@oak/oak). To use from `deno.land/x`, import into a module:\n\n```ts\nimport { Application } from \"https://deno.land/x/oak/mod.ts\";\n```\n\nTo use from JSR, import into a module:\n\n```ts\nimport { Application } from \"jsr:@oak/oak\";\n```\n\nOr use the Deno CLI to add it to your project:\n\n```\ndeno add jsr:@oak/oak\n```\n\n### Node.js\n\noak is available for Node.js on both\n[npm](https://www.npmjs.com/package/@oakserver/oak) and\n[JSR](https://jsr.io/@oak/oak). To use from npm, install the package:\n\n```\nnpm i @oakserver/oak\n```\n\nAnd then import into a module:\n\n```js\nimport { Application } from \"@oakserver/oak\";\n```\n\nTo use from JSR, install the package:\n\n```\nnpx jsr i @oak/oak\n```\n\nAnd then import into a module:\n\n```js\nimport { Application } from \"@oak/oak/application\";\n```\n\n> [!NOTE]\n> Send, websocket upgrades and serving over TLS/HTTPS are not currently\n> supported.\n>\n> In addition the Cloudflare Worker environment and execution context are not\n> currently exposed to middleware.\n\n### Cloudflare Workers\n\noak is available for [Cloudflare Workers](https://workers.cloudflare.com/) on\n[JSR](https://jsr.io/@oak/oak). To use add the package to your Cloudflare Worker\nproject:\n\n```\nnpx jsr add @oak/oak\n```\n\nAnd then import into a module:\n\n```ts\nimport { Application } from \"@oak/oak/application\";\n```\n\nUnlike other runtimes, the oak application doesn't listen for incoming requests,\ninstead it handles worker fetch requests. A minimal example server would be:\n\n```ts\nimport { Application } from \"@oak/oak/application\";\n\nconst app = new Application();\n\napp.use((ctx) => {\n  ctx.response.body = \"Hello CFW!\";\n});\n\nexport default { fetch: app.fetch };\n```\n\n> [!NOTE]\n> Send and websocket upgrades are not currently supported.\n\n### Bun\n\noak is available for Bun on [JSR](https://jsr.io/@oak/oak). To use install the\npackage:\n\n```\nbunx jsr i @oak/oak\n```\n\nAnd then import into a module:\n\n```ts\nimport { Application } from \"@oak/oak/application\";\n```\n\n> [!NOTE]\n> Send and websocket upgrades are not currently supported.\n\n## Application, middleware, and context\n\nThe `Application` class coordinates managing the HTTP server, running\nmiddleware, and handling errors that occur when processing requests. Two of the\nmethods are generally used: `.use()` and `.listen()`. Middleware is added via\nthe `.use()` method and the `.listen()` method will start the server and start\nprocessing requests with the registered middleware.\n\nA basic usage, responding to every request with _Hello World!_:\n\n```ts\nimport { Application } from \"jsr:@oak/oak/application\";\n\nconst app = new Application();\n\napp.use((ctx) => {\n  ctx.response.body = \"Hello World!\";\n});\n\nawait app.listen({ port: 8000 });\n```\n\nYou would then run this script in Deno like:\n\n```\n> deno run --allow-net helloWorld.ts\n```\n\nFor more information on running code under Deno, or information on how to\ninstall the Deno CLI, check out the [Deno manual](https://deno.land/manual).\n\nThe middleware is processed as a stack, where each middleware function can\ncontrol the flow of the response. When the middleware is called, it is passed a\ncontext and reference to the \"next\" method in the stack.\n\nA more complex example:\n\n```ts\nimport { Application } from \"jsr:@oak/oak/application\";\n\nconst app = new Application();\n\n// Logger\napp.use(async (ctx, next) => {\n  await next();\n  const rt = ctx.response.headers.get(\"X-Response-Time\");\n  console.log(`${ctx.request.method} ${ctx.request.url} - ${rt}`);\n});\n\n// Timing\napp.use(async (ctx, next) => {\n  const start = Date.now();\n  await next();\n  const ms = Date.now() - start;\n  ctx.response.headers.set(\"X-Response-Time\", `${ms}ms`);\n});\n\n// Hello World!\napp.use((ctx) => {\n  ctx.response.body = \"Hello World!\";\n});\n\nawait app.listen({ port: 8000 });\n```\n\nTo provide an HTTPS server, then the `app.listen()` options need to include the\noptions `.secure` option set to `true` and supply a `.certFile` and a `.keyFile`\noptions as well.\n\n### `.handle()` method\n\nThe `.handle()` method is used to process requests and receive responses without\nhaving the application manage the server aspect. This though is advanced usage\nand most users will want to use `.listen()`.\n\nThe `.handle()` method accepts up to three arguments. The first being a\n[`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) argument,\nand the second being a `Deno.Conn` argument. The third optional argument is a\nflag to indicate if the request was \"secure\" in the sense it originated from a\nTLS connection to the remote client. The method resolved with a\n[`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) object\nor `undefined` if the `ctx.respond === true`.\n\nAn example:\n\n```ts\nimport { Application } from \"jsr:@oak/oak/application\";\n\nconst app = new Application();\n\napp.use((ctx) => {\n  ctx.response.body = \"Hello World!\";\n});\n\nDeno.serve(async (request, info) => {\n  const res = await app.handle(request, info.remoteAddr);\n  return res ?? Response.error();\n});\n```\n\nAn instance of application has some properties as well:\n\n- `contextState` - Determines the method used to create state for a new context.\n  A value of `\"clone\"` will set the state as a clone of the app state. A value\n  of `\"prototype\"` means the app's state will be used as the prototype of the\n  context's state. A value of `\"alias\"` means that the application's state and\n  the context's state will be a reference to the same object. A value of\n  `\"empty\"` will initialize the context's state with an empty object.\n\n- `.jsonBodyReplacer` - An optional replacer function which will be applied to\n  JSON bodies when forming a response.\n\n- `.jsonBodyReviver` - An optional reviver function which will be applied when\n  reading JSON bodies in a request.\n\n- `.keys`\n\n  Keys to be used when signing and verifying cookies. The value can be set to an\n  array of keys, and instance of `KeyStack`, or an object which provides the\n  same interface as `KeyStack` (e.g. an instance of\n  [keygrip](https://github.com/crypto-utils/keygrip)). If just the keys are\n  passed, oak will manage the keys via `KeyStack` which allows easy key rotation\n  without requiring re-signing of data values.\n\n- `.proxy`\n\n  This defaults to `false`, but can be set via the `Application` constructor\n  options. This is intended to indicate the application is behind a proxy and\n  will use `X-Forwarded-Proto`, `X-Forwarded-Host`, and `X-Forwarded-For` when\n  processing the request, which should provide more accurate information about\n  the request.\n\n- `.state`\n\n  A record of application state, which can be strongly typed by specifying a\n  generic argument when constructing an `Application()`, or inferred by passing\n  a state object (e.g. `Application({ state })`).\n\n### Context\n\nThe context passed to middleware has several properties:\n\n- `.app`\n\n  A reference to the `Application` that is invoking this middleware.\n\n- `.cookies`\n\n  The `Cookies` instance for this context which allows you to read and set\n  cookies.\n\n- `.request`\n\n  The `Request` object which contains details about the request.\n\n- `.respond`\n\n  Determines if when middleware finishes processing, the application should send\n  the `.response` to the client. If `true` the response will be sent, and if\n  `false` the response will not be sent. The default is `true` but certain\n  methods, like `.upgrade()` and `.sendEvents()` will set this to `false`.\n\n- `.response`\n\n  The `Response` object which will be used to form the response sent back to the\n  requestor.\n\n- `.socket`\n\n  This will be `undefined` if the connection has not been upgraded to a web\n  socket. If the connection has been upgraded, the `.socket` interface will be\n  set.\n\n- `.state`\n\n  A record of application state, which can be strongly typed by specifying a\n  generic argument when constructing an `Application()`, or inferred by passing\n  a state object (e.g. `Application({ state })`).\n\nThe context passed to middleware has some methods:\n\n- `.assert()`\n\n  Makes an assertion, which if not true, throws an `HTTPError`, which subclass\n  is identified by the second argument, with the message being the third\n  argument.\n\n- `.send()`\n\n  Stream a file to the requesting client. See [Static content](#static-content)\n  below for more information.\n\n- `.sendEvents()`\n\n  Convert the current connection into a server-sent event response and return a\n  `ServerSentEventTarget` where messages and events can be streamed to the\n  client. This will set `.respond` to `false`.\n\n- `.throw()`\n\n  Throws an `HTTPError`, which subclass is identified by the first argument,\n  with the message being passed as the second.\n\n- `.upgrade()`\n\n  Attempt to upgrade the connection to a web socket connection, and return a\n  `WebSocket` interface. Previous version of oak, this would be a `Promise`\n  resolving with a `std/ws` web socket.\n\nUnlike other middleware frameworks, `context` does not have a significant amount\nof aliases. The information about the request is only located in `.request` and\nthe information about the response is only located in `.response`.\n\n#### Cookies\n\nThe `context.cookies` allows access to the values of cookies in the request, and\nallows cookies to be set in the response. It automatically secures cookies if\nthe `.keys` property is set on the application. Because `.cookies` uses the web\ncrypto APIs to sign and validate cookies, and those APIs work in an asynchronous\nway, the cookie APIs work in an asynchronous way. It has several methods:\n\n- `.get(key: string, options?: CookieGetOptions): Promise<string | undefined>`\n\n  Attempts to retrieve the cookie out of the request and returns the value of\n  the cookie based on the key. If the applications `.keys` is set, then the\n  cookie will be verified against a signed version of the cookie. If the cookie\n  is valid, the promise will resolve with the value. If it is invalid, the\n  cookie signature will be set to deleted on the response. If the cookie was not\n  signed by the current key, it will be resigned and added to the response.\n\n- `.set(key: string, value: string, options?: CookieSetDeleteOptions): Promise<void>`\n\n  Will set a cookie in the response based on the provided key, value and any\n  options. If the applications `.keys` is set, then the cookie will be signed\n  and the signature added to the response. As the keys are signed\n  asynchronously, awaiting the `.set()` method is advised.\n\n#### Request\n\nThe `context.request` contains information about the request. It contains\nseveral properties:\n\n- `.body`\n\n  An object which provides access to the body of the request. See below for\n  details about the request body API.\n\n- `.hasBody`\n\n  Set to `true` if the request might have a body, or `false` if it does not. It\n  does not validate if the body is supported by the built in body parser though.\n\n  > [!WARNING]\n  > This is an unreliable API. In HTTP/2 in many situations you cannot determine\n  > if a request has a body or not unless you attempt to read the body, due to\n  > the streaming nature of HTTP/2. As of Deno 1.16.1, for HTTP/1.1, Deno\n  > also reflects that behavior. The only reliable way to determine if a request\n  > has a body or not is to attempt to read the body.\n\n  It is best to determine if a body might be meaningful to you with a given\n  method, and then attempt to read and process the body if it is meaningful in a\n  given context. For example `GET` and `HEAD` should never have a body, but\n  methods like `DELETE` and `OPTIONS` _might_ have a body and should be have\n  their body conditionally processed if it is meaningful to your application.\n\n- `.headers`\n\n  The headers for the request, an instance of `Headers`.\n\n- `.method`\n\n  A string that represents the HTTP method for the request.\n\n- `.originalRequest`\n\n  **DEPRECATED** this will be removed in a future release of oak.\n\n  The \"raw\" `NativeServer` request, which is an abstraction over the DOM\n  `Request` object. `.originalRequest.request` is the DOM `Request` instance\n  that is being processed. Users should generally avoid using these.\n\n- `.secure`\n\n  A shortcut for `.protocol`, returning `true` if HTTPS otherwise `false`.\n\n- `.source`\n\n  When running under Deno, `.source` will be set to the source web standard\n  `Request`. When running under NodeJS, this will be `undefined`.\n\n- `.url`\n\n  An instance of [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL)\n  which is based on the full URL for the request. This is in place of having\n  parts of the URL exposed on the rest of the request object.\n\nAnd several methods:\n\n- `.accepts(...types: string[])`\n\n  Negotiates the content type supported by the request for the response. If no\n  content types are passed, the method returns a prioritized array of accepted\n  content types. If content types are passed, the best negotiated content type\n  is returned. If no content type match `undefined` is returned.\n\n- `.acceptsEncodings(...encodings: string[])`\n\n  Negotiates the content encoding supported by the request for the response. If\n  no encodings are passed, the method returns a prioritized array of accepted\n  encodings. If encodings are passed, the best negotiated encoding is returned.\n  If no encodings match `undefined` is returned.\n\n- `.acceptsLanguages(...languages: string[])`\n\n  Negotiates the language the client is able to understand. Where a locale\n  variant takes preference. If no encodings are passed, the method returns a\n  prioritized array of understood languages. If languages are passed, the best\n  negotiated language is returned. If no languages match `undefined` is\n  returned.\n\n##### Request Body\n\n> [!IMPORTANT]\n> This API changed significantly in oak v13 and later. The previous API had\n> grown organically since oak was created in 2018 and didn't represent any other\n> common API. The API introduced in v13 aligns better to the Fetch API's\n> `Request` way of dealing with the body, and should be more familiar to\n> developers coming to oak for the first time.\n\nThe API for the oak request `.body` is inspired by the Fetch API's `Request` but\nwith some add functionality. The context's `request.body` is an instance of an\nobject which provides several properties:\n\n- `.has`\n\n  Set to `true` if the request might have a body, or `false` if it does not. It\n  does not validate if the body is supported by the built in body parser though.\n\n  > [!IMPORTANT]\n  > This is an unreliable API. In HTTP/2 in many situations you cannot determine\n  > if a request has a body or not unless you attempt to read the body, due to\n  > the streaming nature of HTTP/2. As of Deno 1.16.1, for HTTP/1.1, Deno\n  > also reflects that behavior. The only reliable way to determine if a request\n  > has a body or not is to attempt to read the body.\n\n  It is best to determine if a body might be meaningful to you with a given\n  method, and then attempt to read and process the body if it is meaningful in a\n  given context. For example `GET` and `HEAD` should never have a body, but\n  methods like `DELETE` and `OPTIONS` _might_ have a body and should be have\n  their body conditionally processed if it is meaningful to your application.\n\n- `.stream`\n\n  A `ReadableStream<Uint8Array>` that will allow reading of the body in\n  `Uint8Array` chunks. This is akin the `.body` property in a Fetch API\n  `Request`.\n\n- `.used`\n\n  Set to `true` if the body has been used, otherwise set to `false`.\n\nIt also has several methods:\n\n- `arrayBuffer()`\n\n  Resolves with an `ArrayBuffer` that contains the contents of the body, if any.\n  Suitable for reading/handling binary data.\n\n- `blob()`\n\n  Resolves with a `Blob` that contains the contents of the body. Suitable for\n  reading/handling binary data.\n\n- `form()`\n\n  Resolves with a `URLSearchParams` which has been decoded from the contents of\n  a body. This is appropriate for a body with a content type of\n  `application/x-www-form-urlencoded`.\n\n- `formData()`\n\n  Resolves with a `FormData` instance which has been decoded from the contents\n  of a body. This is appropriate for a body with a content type of\n  `multipart/form-data`.\n\n- `json()`\n\n  Resolves with the data from the body parsed as JSON. If a `jsonBodyReviver`\n  has been specified in the application, it will be used when parsing the JSON.\n\n- `text()`\n\n  Resolves with a string that represents the contents of the body.\n\n- `type()`\n\n  Attempts to provide guidance of how the body is encoded which can be used to\n  determine what method to use to decode the body. The method returns a string\n  that represents the interpreted body type:\n\n  | Value         | Description                                                                                                                              |\n  | ------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |\n  | `\"binary\"`    | The body has a content type that indicates binary data and the `.arrayBuffer()`, `.blob()` or `.stream` should be used to read the body. |\n  | `\"form\"`      | The body is encoded as form data and `.form()` should be used to read the body.                                                          |\n  | `\"form-data\"` | The body is encoded as a multi-part form and `.formData()` should be used to read the body.                                              |\n  | `\"json\"`      | The body is encoded as JSON data and `.json()` should be used to read the body.                                                          |\n  | `\"text\"`      | The body is encoded as text and `.text()` should be used to read the body.                                                               |\n  | `\"unknown\"`   | Either there is no body or it was not possible to determine the body type based on the content type.                                     |\n\n  The `.type()` method also takes an optional argument of custom media types\n  that will be used when attempting to determine the type of the body. These are\n  then incorporated into the default media types. The value is an object where\n  the key is one of `binary`, `form`, `form-data`, `json`, or `text` and the\n  value is the appropriate media type in a format compatible with the\n  [type-is format](https://github.com/jshttp/type-is/?tab=readme-ov-file#typeisrequest-types).\n\n#### Response\n\nThe `context.response` contains information about the response which will be\nsent back to the requestor. It contains several properties:\n\n- `.body`\n\n  The body of the response, which can often be handled by the automatic response\n  body handling documented below.\n\n- `.headers`\n\n  A `Headers` instance which contains the headers for the response.\n\n- `.status`\n\n  An HTTP `Status` code that will be sent back with the response. If this is not\n  set before responding, oak will default to `200 OK` if there is a `.body`,\n  otherwise `404 Not Found`.\n\n- `.type`\n\n  A media type or extension to set the `Content-Type` header for the response.\n  For example, you can provide `txt` or `text/plain` to describe the body.\n\nAnd several methods:\n\n- `.redirect(url?: string | URL | REDIRECT_BACK, alt?: string | URL)`\n\n  A method to simplify redirecting the response to another URL. It will set the\n  `Location` header to the supplied `url` and the status to `302 Found` (unless\n  the status is already a `3XX` status). The use of symbol `REDIRECT_BACK` as\n  the `url` indicates that the `Referer` header in the request should be used as\n  the direction, with the `alt` being the alternative location if the `Referer`\n  is not set. If neither the `alt` nor the `Referer` are set, the redirect will\n  occur to `/`. A basic HTML (if the requestor supports it) or a text body will\n  be set explaining they are being redirected.\n\n- `.toDomResponse()`\n\n  This converts the information oak understands about the response to the Fetch\n  API `Response`. This will finalize the response, resulting in any further\n  attempt to modify the response to throw. This is intended to be used\n  internally within oak to be able to respond to requests.\n\n- `.with(response: Response)` and `.with(body?: BodyInit, init?: ResponseInit)`\n\n  This sets the response to a web standard `Response`. Note that this will\n  ignore/override any other information set on the response by other middleware\n  including things like headers or cookies to be set.\n\n### Automatic response body handling\n\nWhen the response `Content-Type` is not set in the headers of the `.response`,\noak will automatically try to determine the appropriate `Content-Type`. First it\nwill look at `.response.type`. If assigned, it will try to resolve the\nappropriate media type based on treating the value of `.type` as either the\nmedia type, or resolving the media type based on an extension. For example if\n`.type` was set to `\"html\"`, then the `Content-Type` will be set to\n`\"text/html\"`.\n\nIf `.type` is not set with a value, then oak will inspect the value of\n`.response.body`. If the value is a `string`, then oak will check to see if the\nstring looks like HTML, if so, `Content-Type` will be set to `text/html`\notherwise it will be set to `text/plain`. If the value is an object, other than\na `Uint8Array`, a `Deno.Reader`, or `null`, the object will be passed to\n`JSON.stringify()` and the `Content-Type` will be set to `application/json`.\n\nIf the type of body is a number, bigint or symbol, it will be coerced to a\nstring and treated as text.\n\nIf the value of body is a function, the function will be called with no\narguments. If the return value of the function is promise like, that will be\nawait, and the resolved value will be processed as above. If the value is not\npromise like, it will be processed as above.\n\n### Opening the server\n\nThe application method `.listen()` is used to open the server, start listening\nfor requests, and processing the registered middleware for each request. This\nmethod returns a promise when the server closes.\n\nOnce the server is open, before it starts processing requests, the application\nwill fire a `\"listen\"` event, which can be listened for via the\n`.addEventListener()` method. For example:\n\n```ts\nimport { Application } from \"jsr:@oak/oak/application\";\n\nconst app = new Application();\n\napp.addEventListener(\"listen\", ({ hostname, port, secure }) => {\n  console.log(\n    `Listening on: ${secure ? \"https://\" : \"http://\"}${\n      hostname ?? \"localhost\"\n    }:${port}`,\n  );\n});\n\n// register some middleware\n\nawait app.listen({ port: 80 });\n```\n\n### Closing the server\n\nIf you want to close the application, the application supports the option of an\n[abort signal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal).\nHere is an example of using the signal:\n\n```ts\nimport { Application } from \"jsr:@oak/oak/application\";\n\nconst app = new Application();\n\nconst controller = new AbortController();\nconst { signal } = controller;\n\n// Add some middleware using `app.use()`\n\nconst listenPromise = app.listen({ port: 8000, signal });\n\n// In order to close the server...\ncontroller.abort();\n\n// Listen will stop listening for requests and the promise will resolve...\nawait listenPromise;\n// and you can do something after the close to shutdown\n```\n\n### Error handling\n\nMiddleware can be used to handle other errors with middleware. Awaiting other\nmiddleware to execute while trapping errors works. So if you had an error\nhandling middleware that provides a well managed response to errors would work\nlike this:\n\n```ts\nimport { Application } from \"jsr:@oak/oak/application\";\nimport { isHttpError } from \"jsr:@oak/commons/http_errors\";\nimport { Status } from \"jsr:@oak/commons/status\";\n\nconst app = new Application();\n\napp.use(async (ctx, next) => {\n  try {\n    await next();\n  } catch (err) {\n    if (isHttpError(err)) {\n      switch (err.status) {\n        case Status.NotFound:\n          // handle NotFound\n          break;\n        default:\n          // handle other statuses\n      }\n    } else {\n      // rethrow if you can't handle the error\n      throw err;\n    }\n  }\n});\n```\n\nUncaught middleware exceptions will be caught by the application. `Application`\nextends the global `EventTarget` in Deno, and when uncaught errors occur in the\nmiddleware or sending of responses, an `EventError` will be dispatched to the\napplication. To listen for these errors, you would add an event handler to the\napplication instance:\n\n```ts\nimport { Application } from \"jsr:@oak/oak/application\";\n\nconst app = new Application();\n\napp.addEventListener(\"error\", (evt) => {\n  // Will log the thrown error to the console.\n  console.log(evt.error);\n});\n\napp.use((ctx) => {\n  // Will throw a 500 on every request.\n  ctx.throw(500);\n});\n\nawait app.listen({ port: 80 });\n```\n\n## Router\n\nThe `Router` class produces middleware which can be used with an `Application`\nto enable routing based on the pathname of the request.\n\n### Basic usage\n\nThe following example serves up a _RESTful_ service of a map of books, where\n`http://localhost:8000/book/` will return an array of books and\n`http://localhost:8000/book/1` would return the book with ID `\"1\"`:\n\n```ts\nimport { Application } from \"jsr:@oak/oak/application\";\nimport { Router } from \"jsr:@oak/oak/router\";\n\nconst books = new Map<string, any>();\nbooks.set(\"1\", {\n  id: \"1\",\n  title: \"The Hound of the Baskervilles\",\n  author: \"Conan Doyle, Arthur\",\n});\n\nconst router = new Router();\nrouter\n  .get(\"/\", (context) => {\n    context.response.body = \"Hello world!\";\n  })\n  .get(\"/book\", (context) => {\n    context.response.body = Array.from(books.values());\n  })\n  .get(\"/book/:id\", (context) => {\n    if (books.has(context?.params?.id)) {\n      context.response.body = books.get(context.params.id);\n    }\n  });\n\nconst app = new Application();\napp.use(router.routes());\napp.use(router.allowedMethods());\n\nawait app.listen({ port: 8000 });\n```\n\nA route passed is converted to a regular expression using\n[path-to-regexp](https://github.com/pillarjs/path-to-regexp), which means\nparameters expressed in the pattern will be converted. `path-to-regexp` has\nadvanced usage which can create complex patterns which can be used for matching.\nCheck out the\n[documentation for that library](https://github.com/pillarjs/path-to-regexp#parameters)\nif you have advanced use cases.\n\nIn most cases, the type of `context.params` is automatically inferred from the\npath template string through typescript magic. In more complex scenarios this\nmight not yield the correct result however. In that case you can override the\ntype with `router.get<RouteParams>`, where `RouteParams` is the explicit type\nfor `context.params`.\n\n### Nested routers\n\nNesting routers is supported. The following example responds to\n`http://localhost:8000/forums/oak/posts` and\n`http://localhost:8000/forums/oak/posts/nested-routers`.\n\n```typescript\nimport { Application } from \"jsr:@oak/oak/application\";\nimport { Router } from \"jsr:@oak/oak/router\";\n\nconst posts = new Router()\n  .get(\"/\", (ctx) => {\n    ctx.response.body = `Forum: ${ctx.params.forumId}`;\n  })\n  .get(\"/:postId\", (ctx) => {\n    ctx.response.body =\n      `Forum: ${ctx.params.forumId}, Post: ${ctx.params.postId}`;\n  });\n\nconst forums = new Router().use(\n  \"/forums/:forumId/posts\",\n  posts.routes(),\n  posts.allowedMethods(),\n);\n\nawait new Application().use(forums.routes()).listen({ port: 8000 });\n```\n\n## Static content\n\nThe function `send()` is designed to serve static content as part of a\nmiddleware function. In the most straight forward usage, a root is provided and\nrequests provided to the function are fulfilled with files from the local file\nsystem relative to the root from the requested path.\n\nA basic usage would look something like this:\n\n```ts\nimport { Application } from \"jsr:@oak/oak/application\";\n\nconst app = new Application();\n\napp.use(async (context, next) => {\n  try {\n    await context.send({\n      root: `${Deno.cwd()}/examples/static`,\n      index: \"index.html\",\n    });\n  } catch {\n    await next();\n  }\n});\n\nawait app.listen({ port: 8000 });\n```\n\n`send()` automatically supports features like providing `ETag` and\n`Last-Modified` headers in the response as well as processing `If-None-Match`\nand `If-Modified-Since` headers in the request. This means when serving up\nstatic content, clients will be able to rely upon their cached versions of\nassets instead of re-downloading them.\n\n### ETag support\n\nThe `send()` method automatically supports generating an `ETag` header for\nstatic assets. The header allows the client to determine if it needs to\nre-download an asset or not, but it can be useful to calculate `ETag`s for other\nscenarios.\n\nThere is a middleware function that assesses the `context.reponse.body` and\ndetermines if it can create an `ETag` header for that body type, and if so sets\nthe `ETag` header on the response. Basic usage would look something like this:\n\n```ts\nimport { Application } from \"jsr:@oak/oak/application\";\nimport { factory } from \"jsr:@oak/oak/etag\";\n\nconst app = new Application();\n\napp.use(factory());\n\n// ... other middleware for the application\n```\n\nThere is also a function which retrieves an entity for a given context based on\nwhat it logical to read into memory which can be passed to the etag calculate\nthat is part of the Deno std library:\n\n```ts\nimport { Application } from \"jsr:@oak/oak/application\";\nimport { getEntity } from \"jsr:@oak/oak/etag\";\nimport { calculate } from \"jsr:@std/http/etag\";\n\nconst app = new Application();\n\n// The context.response.body has already been set...\n\napp.use(async (ctx) => {\n  const entity = await getEntity(ctx);\n  if (entity) {\n    const etag = await calculate(entity);\n  }\n});\n```\n\n## Fetch API and `Deno.serve()` migration\n\nIf you are migrating from `Deno.serve()` or adapting code that is designed for\nthe web standard Fetch API `Request` and `Response`, there are a couple features\nof oak to assist.\n\n### `ctx.request.source`\n\nWhen running under Deno, this will be set to a Fetch API `Request`, giving\ndirect access to the original request.\n\n### `ctx.response.with()`\n\nThis method will accept a Fetch API `Response` or create a new response based\non the provided `BodyInit` and `ResponseInit`. This will also finalize the\nresponse and ignores anything that may have been set on the oak `.response`.\n\n### `middleware/serve#serve()` and `middelware/serve#route()`\n\nThese two middleware generators can be used to adapt code that operates more\nlike the `Deno.serve()` in that it provides a Fetch API `Request` and expects\nthe handler to resolve with a Fetch API `Response`.\n\nAn example of using `serve()` with `Application.prototype.use()`:\n\n```ts\nimport { Application } from \"jsr:@oak/oak/application\";\nimport { serve } from \"jsr:@oak/oak/serve\";\n\nconst app = new Application();\n\napp.use(serve((req, ctx) => {\n  console.log(req.url);\n  return new Response(\"Hello world!\");\n}));\n\napp.listen();\n```\n\nAnd a similar solution works with `route()` where the context contains the\ninformation about the router, like the params:\n\n```ts\nimport { Application } from \"jsr:@oak/oak/application\";\nimport { Router } from \"jsr:@oak/oak/router\";\nimport { route } from \"jsr:@oak/oak/serve\";\n\nconst app = new Application;\n\nconst router = new Router();\n\nrouter.get(\"/books/:id\", route((req, ctx) => {\n  console.log(ctx.params.id);\n  return Response.json({ title: \"hello world\", id: ctx.params.id });\n}));\n\napp.use(router.routes());\n\napp.listen();\n```\n\n## Testing\n\nThe `mod.ts` exports an object named `testing` which contains some utilities for\ntesting oak middleware you might create. See the\n[Testing with oak](https://oakserver.github.io/oak/testing) for more\ninformation.\n\n---\n\nThere are several modules that are directly adapted from other modules. They\nhave preserved their individual licenses and copyrights. All of the modules,\nincluding those directly adapted are licensed under the MIT License.\n\nAll additional work is copyright 2018 - 2025 the oak authors. All rights\nreserved.\n"
        },
        {
          "name": "application.test.ts",
          "type": "blob",
          "size": 27.8427734375,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n// deno-lint-ignore-file\n\nimport {\n  assertEquals,\n  assertRejects,\n  assertStrictEquals,\n} from \"./deps_test.ts\";\n\nimport { Application } from \"./application.ts\";\nimport type {\n  ApplicationErrorEvent,\n  ListenOptions,\n  ListenOptionsTls,\n  State,\n} from \"./application.ts\";\nimport { Context } from \"./context.ts\";\nimport { assert, errors, KeyStack, Status } from \"./deps.ts\";\nimport { Server } from \"./http_server_native.ts\";\nimport { NativeRequest } from \"./http_server_native_request.ts\";\nimport type {\n  Data,\n  Listener,\n  OakServer,\n  ServeOptions,\n  ServerConstructor,\n  ServerRequest,\n  ServeTlsOptions,\n} from \"./types.ts\";\nimport { isNode } from \"./utils/type_guards.ts\";\nimport { createPromiseWithResolvers } from \"./utils/create_promise_with_resolvers.ts\";\n\nlet optionsStack: Array<ListenOptions | ListenOptionsTls> = [];\nlet serverClosed = false;\n\nfunction teardown() {\n  optionsStack = [];\n  serverClosed = false;\n}\n\nfunction setup(\n  ...requests: ([string?, RequestInit?])[]\n): [ServerConstructor<NativeRequest>, Response[]] {\n  const responseStack: Response[] = [];\n\n  function createRequest(\n    url = \"http://localhost/index.html\",\n    requestInit?: RequestInit,\n  ): NativeRequest {\n    const request = new Request(url, requestInit);\n\n    const nativeRequest = new NativeRequest(request, {});\n    nativeRequest.response.then((response) => responseStack.push(response));\n    return nativeRequest;\n  }\n\n  const mockRequests = requests.map((r) => createRequest(...r));\n\n  return [\n    class MockNativeServer<AS extends State = Record<string, any>>\n      implements OakServer<ServerRequest> {\n      constructor(\n        _app: Application<AS>,\n        private options: ServeOptions | ServeTlsOptions,\n      ) {\n        optionsStack.push(options);\n      }\n\n      close(): Promise<void> {\n        serverClosed = true;\n        return Promise.resolve();\n      }\n\n      listen(): Listener {\n        this.options.signal?.addEventListener(\n          \"abort\",\n          () => serverClosed = true,\n        );\n        return {\n          addr: {\n            transport: \"tcp\",\n            hostname: this.options.hostname ?? \"localhost\",\n            port: this.options.port,\n          },\n        } as Listener;\n      }\n\n      async *[Symbol.asyncIterator]() {\n        for await (const request of mockRequests) {\n          yield request;\n        }\n      }\n    },\n    responseStack,\n  ];\n}\n\nfunction setupClosed(\n  ...requests: ([string?, RequestInit?])[]\n): [ServerConstructor<NativeRequest>, Response[]] {\n  const responseStack: Response[] = [];\n\n  function createRequest(\n    url = \"http://localhost/index.html\",\n    requestInit?: RequestInit,\n  ): NativeRequest {\n    const request = new Request(url, requestInit);\n\n    Object.defineProperty(request, \"headers\", {\n      get() {\n        throw new TypeError(\"cannot read headers: request closed\");\n      },\n    });\n\n    const nativeRequest = new NativeRequest(request, {});\n    nativeRequest.response.then((response) => responseStack.push(response));\n    return nativeRequest;\n  }\n\n  const mockRequests = requests.map((r) => createRequest(...r));\n\n  return [\n    class MockNativeServer<AS extends State = Record<string, any>>\n      implements OakServer<ServerRequest> {\n      constructor(\n        _app: Application<AS>,\n        private options: Omit<ServeOptions | ServeTlsOptions, \"signal\">,\n      ) {\n        optionsStack.push(options);\n      }\n\n      close(): void {\n        serverClosed = true;\n      }\n\n      listen(): Listener {\n        return {\n          addr: {\n            transport: \"tcp\",\n            hostname: this.options.hostname ?? \"localhost\",\n            port: this.options.port,\n          },\n        } as Listener;\n      }\n\n      async *[Symbol.asyncIterator]() {\n        for await (const request of mockRequests) {\n          yield request;\n        }\n      }\n    },\n    responseStack,\n  ];\n}\n\nDeno.test({\n  name: \"construct App()\",\n  fn() {\n    const app = new Application();\n    assert(app instanceof Application);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"register middleware\",\n  async fn() {\n    const [serverConstructor] = setup([]);\n    const app = new Application({ serverConstructor });\n    let called = 0;\n    app.use((context, next) => {\n      assert(context instanceof Context);\n      assertEquals(typeof next, \"function\");\n      called++;\n    });\n\n    await app.listen(\":8000\");\n    assertEquals(called, 1);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"register middleware - accepts non void\",\n  fn() {\n    const [serverConstructor] = setup();\n    const app = new Application({ serverConstructor });\n    app.use((ctx) => ctx.response.body = \"hello world\");\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"middleware execution order 1\",\n  async fn() {\n    const [serverConstructor] = setup([]);\n    const app = new Application({ serverConstructor });\n    const callStack: number[] = [];\n    app.use(() => {\n      callStack.push(1);\n    });\n\n    app.use(() => {\n      callStack.push(2);\n    });\n\n    await app.listen(\":8000\");\n    assertEquals(callStack, [1]);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"middleware execution order 2\",\n  async fn() {\n    const [serverConstructor] = setup([]);\n    const app = new Application({ serverConstructor });\n    const callStack: number[] = [];\n    app.use((_context, next) => {\n      callStack.push(1);\n      next();\n    });\n\n    app.use(() => {\n      callStack.push(2);\n    });\n\n    await app.listen(\":8000\");\n    assertEquals(callStack, [1, 2]);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"middleware execution order 3\",\n  async fn() {\n    const [serverConstructor] = setup([]);\n    const app = new Application({ serverConstructor });\n    const callStack: number[] = [];\n    app.use((_context, next) => {\n      callStack.push(1);\n      next();\n      callStack.push(2);\n    });\n\n    app.use(async () => {\n      callStack.push(3);\n      await Promise.resolve();\n      callStack.push(4);\n    });\n\n    await app.listen(\":8000\");\n    assertEquals(callStack, [1, 3, 2, 4]);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"middleware execution order 4\",\n  async fn() {\n    const [serverConstructor] = setup([]);\n    const app = new Application({ serverConstructor });\n    const callStack: number[] = [];\n    app.use(async (_context, next) => {\n      callStack.push(1);\n      await next();\n      callStack.push(2);\n    });\n\n    app.use(async () => {\n      callStack.push(3);\n      await Promise.resolve();\n      callStack.push(4);\n    });\n\n    await app.listen(\":8000\");\n    assertEquals(callStack, [1, 3, 4, 2]);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app.listen\",\n  async fn() {\n    const [serverConstructor] = setup();\n    const app = new Application({ serverConstructor });\n    app.use(() => {});\n    await app.listen(\"127.0.0.1:8080\");\n    assertEquals(optionsStack, [{\n      hostname: \"127.0.0.1\",\n      port: 8080,\n    }]);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app.listen native\",\n  async fn() {\n    const [serverConstructor] = setup();\n    const app = new Application({ serverConstructor });\n    app.use(() => {});\n    await app.listen(\"127.0.0.1:8080\");\n    assertEquals(optionsStack, [{ hostname: \"127.0.0.1\", port: 8080 }]);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app.listen IPv6 Loopback\",\n  async fn() {\n    const [serverConstructor] = setup();\n    const app = new Application({ serverConstructor });\n    app.use(() => {});\n    await app.listen(\"[::1]:8080\");\n    assertEquals(optionsStack, [{ hostname: \"::1\", port: 8080 }]);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app.listen(options)\",\n  async fn() {\n    const [serverConstructor] = setup();\n    const app = new Application({ serverConstructor });\n    app.use(() => {});\n    await app.listen({ port: 8000 });\n    assertEquals(optionsStack, [{ port: 8000 }]);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app.listenTLS\",\n  async fn() {\n    const [serverConstructor] = setup();\n    const app = new Application({ serverConstructor });\n    app.use(() => {});\n    await app.listen({\n      port: 8000,\n      secure: true,\n      certFile: \"\",\n      keyFile: \"\",\n    });\n    assertEquals(optionsStack, [{\n      port: 8000,\n      secure: true,\n      certFile: \"\",\n      keyFile: \"\",\n    }]);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app.state\",\n  async fn() {\n    const [serverConstructor] = setup([]);\n    const app = new Application<{ foo?: string }>({\n      state: {},\n      serverConstructor,\n    });\n    app.state.foo = \"bar\";\n    let called = false;\n    app.use((context) => {\n      assertEquals(context.state, { foo: \"bar\" });\n      called = true;\n    });\n    await app.listen(\":8000\");\n    assert(called);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app - contextState - clone\",\n  async fn() {\n    const [serverConstructor] = setup([]);\n    const app = new Application({\n      contextState: \"clone\",\n      state: {\n        a() {},\n        b: \"string\",\n        c: /c/,\n      },\n      serverConstructor,\n    });\n    let called = false;\n    app.use((ctx) => {\n      // @ts-ignore we shouldn't have type inference in asserts!\n      assertEquals(ctx.state, { b: \"string\", c: /c/ });\n      assert(ctx.state !== ctx.app.state);\n      called = true;\n    });\n    await app.listen({ port: 8000 });\n    assert(called);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app - contextState - prototype\",\n  async fn() {\n    const state = {\n      a: \"a\",\n      b: { c: \"c\" },\n    };\n    const [serverConstructor] = setup([]);\n    const app = new Application({\n      contextState: \"prototype\",\n      state,\n      serverConstructor,\n    });\n    let called = false;\n    app.use<typeof state & { d: string }>((ctx) => {\n      assert(ctx.state !== ctx.app.state);\n      assert(Object.getPrototypeOf(ctx.state) === ctx.app.state);\n      assertEquals(ctx.state.a, \"a\");\n      assertEquals(ctx.state.b, { c: \"c\" });\n      ctx.state.a = \"f\";\n      ctx.state.d = \"d\";\n      ctx.state.b.c = \"e\";\n      assertEquals(ctx.app.state, { a: \"a\", b: { c: \"e\" } });\n      called = true;\n    });\n    await app.listen({ port: 8000 });\n    assert(called);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app - contextState - alias\",\n  async fn() {\n    const [serverConstructor] = setup([]);\n    const app = new Application({\n      contextState: \"alias\",\n      state: {\n        a() {},\n        b: \"string\",\n        c: /c/,\n      },\n      serverConstructor,\n    });\n    let called = false;\n    app.use((ctx) => {\n      assertStrictEquals(ctx.state, ctx.app.state);\n      called = true;\n    });\n    await app.listen({ port: 8000 });\n    assert(called);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app - contextState - empty\",\n  async fn() {\n    const [serverConstructor] = setup([]);\n    const app = new Application({\n      contextState: \"empty\",\n      state: {\n        a() {},\n        b: \"string\",\n        c: /c/,\n      },\n      serverConstructor,\n    });\n    let called = false;\n    app.use((ctx) => {\n      assert(ctx.state !== ctx.app.state);\n      assertEquals(Object.entries(ctx.state).length, 0);\n      ctx.state.b = \"b\";\n      assertEquals(ctx.app.state.b, \"string\");\n      called = true;\n    });\n    await app.listen({ port: 8000 });\n    assert(called);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app.keys undefined\",\n  fn() {\n    const app = new Application();\n    assertEquals(app.keys, undefined);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app.keys passed as array\",\n  fn() {\n    const app = new Application({ keys: [\"foo\"] });\n    assert(app.keys instanceof KeyStack);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app.keys passed as KeyStack-like\",\n  fn() {\n    const keys = {\n      sign(_data: Data) {\n        return Promise.resolve(\"\");\n      },\n      verify(_data: Data, _digest: string) {\n        return Promise.resolve(true);\n      },\n      indexOf(_data: Data, _digest: string) {\n        return Promise.resolve(0);\n      },\n    } as KeyStack;\n    const app = new Application({ keys });\n    assert(app.keys === keys);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app.keys set as array\",\n  fn() {\n    const app = new Application();\n    app.keys = [\"foo\"];\n    assert(app.keys instanceof KeyStack);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app.listen({ signal }) no requests in flight\",\n  async fn() {\n    const [serverConstructor] = setup();\n    const app = new Application({ serverConstructor });\n    const abortController = new AbortController();\n    app.use(() => {});\n    const p = app.listen({ port: 8000, signal: abortController.signal });\n    abortController.abort();\n    await p;\n    assertEquals(serverClosed, true);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app.listen({ signal }) requests in flight\",\n  async fn() {\n    const [serverConstructor] = setup([], [], [], [], []);\n    const app = new Application({ serverConstructor });\n    const abortController = new AbortController();\n    let count = 0;\n    app.use(() => {\n      assertEquals(serverClosed, false);\n      count++;\n      if (count === 2) {\n        abortController.abort();\n      }\n    });\n    await app.listen({ port: 8000, signal: abortController.signal });\n    assertEquals(count, 2);\n    assertEquals(serverClosed, true);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app.addEventListener()\",\n  async fn() {\n    const [serverConstructor] = setup([]);\n    const app = new Application({\n      serverConstructor,\n      logErrors: false,\n    });\n    app.addEventListener(\"error\", (evt) => {\n      assert(evt.error instanceof errors.InternalServerError);\n    });\n    app.use((ctx) => {\n      ctx.throw(500, \"oops!\");\n    });\n    await app.listen({ port: 8000 });\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app emits close event\",\n  async fn() {\n    const [serverConstructor] = setup();\n    const app = new Application({ serverConstructor });\n    let closeFired = false;\n    app.addEventListener(\"close\", () => {\n      closeFired = true;\n    });\n    const abortController = new AbortController();\n    app.use(() => {});\n    const p = app.listen({ port: 8000, signal: abortController.signal });\n    abortController.abort();\n    await p;\n    assert(closeFired);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"closed native request is handled properly\",\n  async fn() {\n    const [serverConstructor] = setupClosed([]);\n    const app = new Application({ serverConstructor, logErrors: false });\n    app.use((ctx) => {\n      ctx.throw(500, \"oops!\");\n    });\n    const errors: string[] = [];\n    app.addEventListener(\"error\", ({ context, message }) => {\n      assert(!context);\n      errors.push(message);\n    });\n    await app.listen({ port: 8000 });\n    teardown();\n    assertEquals(errors, [\"cannot read headers: request closed\"]);\n  },\n});\n\nDeno.test({\n  name: \"uncaught errors impact response\",\n  async fn() {\n    const [serverConstructor, responseStack] = setup([]);\n    const app = new Application({ serverConstructor, logErrors: false });\n    app.use((ctx) => {\n      ctx.throw(404, \"File Not Found\");\n    });\n    await app.listen({ port: 8000 });\n    const [response] = responseStack;\n    assertEquals(response.status, 404);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"uncaught errors clear headers properly\",\n  async fn() {\n    const [serverConstructor, responseStack] = setup([]);\n    const app = new Application({\n      serverConstructor,\n      logErrors: false,\n    });\n    app.use((ctx) => {\n      ctx.response.headers.append(\"a\", \"b\");\n      ctx.response.headers.append(\"b\", \"c\");\n      ctx.response.headers.append(\"c\", \"d\");\n      ctx.response.headers.append(\"d\", \"e\");\n      ctx.response.headers.append(\"f\", \"g\");\n      ctx.throw(500, \"Internal Error\");\n    });\n    await app.listen({ port: 8000 });\n    const [response] = responseStack;\n    assertEquals([...response.headers], [[\n      \"content-type\",\n      \"text/plain; charset=UTF-8\",\n    ]]);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"uncaught errors log by default\",\n  async fn() {\n    const errorLogStack: any[][] = [];\n    const originalConsoleError = Object.getOwnPropertyDescriptor(\n      console,\n      \"error\",\n    );\n    assert(originalConsoleError);\n    Object.defineProperty(console, \"error\", {\n      value(...args: any[]) {\n        errorLogStack.push(args);\n      },\n      configurable: true,\n    });\n    const [serverConstructor] = setup([]);\n    const app = new Application({ serverConstructor });\n    app.use((ctx) => {\n      ctx.throw(404, \"File Not Found\");\n    });\n    await app.listen({ port: 8000 });\n    Object.defineProperty(console, \"error\", originalConsoleError);\n    assertEquals(errorLogStack.length, 4);\n    assert(errorLogStack[0][0].startsWith(\"[uncaught application error]\"));\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"errors call event handler properly\",\n  async fn() {\n    const [serverConstructor, responseStack] = setup([]);\n    const app = new Application({ serverConstructor, logErrors: false });\n    app.use((ctx) => {\n      ctx.throw(400, \"Bad Request\");\n    });\n    const errStatusStack: (Status | undefined)[] = [];\n    app.addEventListener(\"error\", (evt) => {\n      errStatusStack.push(evt.context?.response.status);\n    });\n    await app.listen({ port: 8000 });\n    const [response] = responseStack;\n    assertEquals(response.status, 400);\n    assertEquals(errStatusStack.length, 1);\n    assertEquals(errStatusStack[0], Status.BadRequest);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"caught errors don't dispatch error events\",\n  async fn() {\n    const [serverConstructor, responseStack] = setup([]);\n    const app = new Application({ serverConstructor });\n    const errStack: any[] = [];\n    app.use(async (_ctx, next) => {\n      try {\n        await next();\n      } catch (err) {\n        errStack.push(err);\n      }\n    });\n    app.use((ctx) => {\n      ctx.throw(404, \"File Not Found\");\n    });\n    const errEventStack: ApplicationErrorEvent<any, any>[] = [];\n    app.addEventListener(\"error\", (evt) => {\n      errEventStack.push(evt);\n    });\n    await app.listen({ port: 8000 });\n    const [response] = responseStack;\n    assertEquals(response.status, 404);\n    assertEquals(errStack.length, 1);\n    assertEquals(errEventStack.length, 0);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"thrown errors in a catch block\",\n  async fn() {\n    const errors: ApplicationErrorEvent<any, any>[] = [];\n    const [serverConstructor, responseStack] = setup([]);\n    const app = new Application({\n      serverConstructor,\n      logErrors: false,\n    });\n\n    app.addEventListener(\"error\", (evt) => {\n      errors.push(evt);\n    });\n\n    app.use(async () => {\n      try {\n        throw new Error(\"catch me\");\n      } catch {\n        throw new Error(\"caught\");\n      }\n    });\n\n    await app.listen({ port: 8000 });\n    const [response] = responseStack;\n    assertEquals(response.status, 500);\n    assertEquals(errors.length, 1);\n    assertEquals(errors[0].error.message, \"caught\");\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"errors when generating native response\",\n  async fn() {\n    const [serverConstructor, responseStack] = setup([]);\n    const errors: ApplicationErrorEvent<any, any>[] = [];\n    const app = new Application({\n      serverConstructor,\n      logErrors: false,\n    });\n\n    app.addEventListener(\"error\", (evt) => {\n      errors.push(evt);\n    });\n\n    app.use(async (ctx) => {\n      ctx.response.body = { a: 4600119228n };\n    });\n\n    await app.listen({ port: 8000 });\n    const [response] = responseStack;\n    assertEquals(response.status, 500);\n    assertEquals(errors.length, 1);\n    assertEquals(\n      errors[0].error.message,\n      \"Do not know how to serialize a BigInt\",\n    );\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app.listen() without middleware\",\n  async fn() {\n    const [serverConstructor] = setup([]);\n    const app = new Application({ serverConstructor });\n    await assertRejects(async () => {\n      await app.listen(\":8000\");\n    }, TypeError);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"app.state type handling\",\n  fn() {\n    const app = new Application({ state: { id: 1 } });\n    app.use((ctx: Context<{ session: number }>) => {\n      ctx.state.session = 0;\n    }).use((ctx) => {\n      ctx.state.id = 1;\n      ctx.state.session = 2;\n      // @ts-expect-error\n      ctx.state.bar = 3;\n      ctx.app.state.id = 4;\n      ctx.app.state.session = 5;\n      // @ts-expect-error\n      ctx.app.state.bar = 6;\n    });\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"application listen event\",\n  async fn() {\n    const [serverConstructor] = setup();\n    const app = new Application({ serverConstructor });\n    let called = 0;\n    app.addEventListener(\"listen\", (evt) => {\n      called++;\n      assertEquals(evt.hostname, \"localhost\");\n      assertEquals(evt.port, 80);\n      assertEquals(evt.secure, false);\n    });\n    app.use((ctx) => {\n      ctx.response.body = \"hello world\";\n    });\n    await app.listen({ hostname: \"localhost\", port: 80 });\n    assertEquals(called, 1);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"application doesn't respond on ctx.respond === false\",\n  async fn() {\n    const [serverConstructor, responseStack] = setup([]);\n    const app = new Application({ serverConstructor });\n    app.use((ctx) => {\n      ctx.respond = false;\n    });\n    await app.listen({ port: 8000 });\n    assertEquals(responseStack.length, 0);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"application passes proxy\",\n  async fn() {\n    const [serverConstructor, responseStack] = setup([\n      \"http://localhost/index.html\",\n      {\n        headers: {\n          \"host\": \"10.255.255.255\",\n          \"x-forwarded-proto\": \"https\",\n          \"x-forwarded-for\": \"10.10.10.10, 192.168.1.1, 10.255.255.255\",\n          \"x-forwarded-host\": \"10.10.10.10\",\n        },\n      },\n    ]);\n    const app = new Application({\n      serverConstructor,\n      proxy: true,\n    });\n    let called = false;\n    app.use((ctx) => {\n      called = true;\n      assertEquals(String(ctx.request.url), \"https://10.10.10.10/index.html\");\n    });\n    await app.listen({ port: 8000 });\n    assert(called);\n    assertEquals(responseStack.length, 1);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"application .handle()\",\n  async fn() {\n    const app = new Application();\n    let called = 0;\n    app.use((context, next) => {\n      assert(context instanceof Context);\n      assertEquals(typeof next, \"function\");\n      called++;\n    });\n    const actual = await app.handle(new Request(\"http://localhost/index.html\"));\n    assertEquals(called, 1);\n    assert(actual);\n    assertEquals(actual.body, null);\n    assertEquals(actual.status, Status.NotFound);\n    assertEquals([...actual.headers], [[\"content-length\", \"0\"]]);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"application .handle() native request\",\n  async fn() {\n    const app = new Application();\n    let called = 0;\n    app.use((context, next) => {\n      assert(context instanceof Context);\n      assertEquals(context.request.ip, \"example.com\");\n      assertEquals(typeof next, \"function\");\n      called++;\n    });\n    const request = new Request(\"http://localhost:8080/\", {\n      method: \"POST\",\n      body: `{\"a\":\"b\"}`,\n    });\n    const remoteAddr = {\n      transport: \"tcp\",\n      hostname: \"example.com\",\n      port: 4747,\n    } as const;\n    const actual = await app.handle(request, remoteAddr);\n    assertEquals(called, 1);\n    assert(actual instanceof Response);\n    assertEquals(actual.body, null);\n    assertEquals(actual.status, Status.NotFound);\n    assertEquals([...actual.headers], [[\"content-length\", \"0\"]]);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"application .handle() omit connection\",\n  async fn() {\n    const app = new Application();\n    let called = 0;\n    app.use((context, next) => {\n      assert(context instanceof Context);\n      assertEquals(context.request.ip, \"\");\n      assertEquals(typeof next, \"function\");\n      called++;\n    });\n    const request = new Request(\"http://localhost:8080/\", {\n      method: \"POST\",\n      body: `{\"a\":\"b\"}`,\n    });\n    const actual = await app.handle(request);\n    assertEquals(called, 1);\n    assert(actual instanceof Response);\n    assertEquals(actual.body, null);\n    assertEquals(actual.status, Status.NotFound);\n    assertEquals([...actual.headers], [[\"content-length\", \"0\"]]);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"application .handle() no response\",\n  async fn() {\n    const app = new Application();\n    app.use((context) => {\n      context.respond = false;\n    });\n    const actual = await app.handle(new Request(\"http://localhost/index.html\"));\n    assertEquals(actual, undefined);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"application .handle() no middleware throws\",\n  async fn() {\n    const app = new Application();\n    await assertRejects(async () => {\n      await app.handle(new Request(\"http://localhost/index.html\"));\n    }, TypeError);\n    teardown();\n  },\n});\n\nfunction isBigInitValue(value: unknown): value is { __bigint: string } {\n  return value != null && typeof value === \"object\" && \"__bigint\" in value &&\n    typeof (value as any).__bigint === \"string\";\n}\n\nDeno.test({\n  name: \"application - json reviver is passed\",\n  async fn() {\n    let called = 0;\n    const app = new Application({\n      jsonBodyReviver(_, value, ctx) {\n        assert(ctx);\n        called++;\n        if (isBigInitValue(value)) {\n          return BigInt(value.__bigint);\n        } else {\n          return value;\n        }\n      },\n    });\n    app.use(async (ctx) => {\n      const body = ctx.request.body;\n      assert(body.type() === \"json\");\n      const actual = await body.json();\n      assertEquals(actual, { a: 123456n });\n      ctx.response.body = {};\n      called++;\n    });\n    const body = JSON.stringify({\n      a: {\n        __bigint: \"123456\",\n      },\n    });\n    const actual = await app.handle(\n      new Request(\"http://localhost/index.html\", {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n          \"content-length\": String(body.length),\n        },\n        body,\n      }),\n    );\n    assertEquals(called, 4);\n    assertEquals(actual?.status, 200);\n  },\n});\n\nDeno.test({\n  name: \"application - json replacer is passed\",\n  async fn() {\n    let called = 0;\n    const app = new Application({\n      jsonBodyReplacer(_, value, ctx) {\n        assert(ctx);\n        called++;\n        return typeof value === \"bigint\"\n          ? { __bigint: value.toString(10) }\n          : value;\n      },\n    });\n    app.use(async (ctx) => {\n      ctx.response.body = { a: 123456n };\n    });\n    const actual = await app.handle(new Request(\"http://localhost/index.html\"));\n    assertEquals(called, 3);\n    const body = await actual?.json();\n    assertEquals(body, { a: { __bigint: \"123456\" } });\n  },\n});\n\nDeno.test({\n  name: \"application.use() - type checking - at least one middleware is passed\",\n  fn() {\n    const app = new Application();\n    try {\n      // @ts-expect-error\n      app.use();\n    } catch {\n      //\n    }\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"new Application() - HttpServerNative\",\n  fn() {\n    new Application({ serverConstructor: Server });\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"Application - inspecting\",\n  fn() {\n    assertEquals(\n      Deno.inspect(new Application()),\n      isNode()\n        ? `Application { '#middleware': [], keys: undefined, proxy: false, state: {} }`\n        : `Application { \"#middleware\": [], keys: undefined, proxy: false, state: {} }`,\n    );\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"Application.listen() - no options\",\n  // ignore: isNode(),\n  ignore: true, // there is a challenge with serve and the abort controller that\n  // needs to be isolated\n  async fn() {\n    const controller = new AbortController();\n    const app = new Application();\n    app.use((ctx) => {\n      ctx.response.body = \"hello world\";\n    });\n    const { signal } = controller;\n    const p = app.listen({ signal });\n    controller.abort();\n    await p;\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"Application load correct default server\",\n  ignore: isNode(), // this just hangs on node, because we can't close down\n  sanitizeOps: false,\n  sanitizeResources: false,\n  fn() {\n    const app = new Application();\n    const { promise, resolve, reject } = createPromiseWithResolvers<void>();\n    app.addEventListener(\"listen\", ({ serverType }) => {\n      try {\n        assertEquals(serverType, isNode() ? \"node\" : \"native\");\n      } catch (e) {\n        reject(e);\n      }\n      resolve();\n    });\n    app.use((_ctx) => {});\n    app.listen();\n    teardown();\n    return promise;\n  },\n});\n"
        },
        {
          "name": "application.ts",
          "type": "blob",
          "size": 30.2236328125,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n/**\n * Contains the core concept of oak, the middleware application. Typical usage\n * is the creation of an application instance, registration of middleware, and\n * then starting to listen for requests.\n *\n * # Example\n *\n * ```ts\n * import { Application } from \"jsr:@oak/oak/application\";\n *\n * const app = new Application();\n * app.use((ctx) => {\n *   ctx.response.body = \"hello world!\";\n * });\n *\n * app.listen({ port: 8080 });\n * ```\n *\n * @module\n */\n\nimport { Context } from \"./context.ts\";\nimport { assert, KeyStack, type Status, STATUS_TEXT } from \"./deps.ts\";\nimport type { NativeRequest } from \"./http_server_native_request.ts\";\nimport {\n  compose,\n  isMiddlewareObject,\n  type MiddlewareOrMiddlewareObject,\n} from \"./middleware.ts\";\nimport { cloneState } from \"./utils/clone_state.ts\";\nimport { createPromiseWithResolvers } from \"./utils/create_promise_with_resolvers.ts\";\nimport type {\n  Key,\n  Listener,\n  NetAddr,\n  OakServer,\n  ServerConstructor,\n  ServerRequest,\n} from \"./types.ts\";\nimport { isBun, isNetAddr, isNode } from \"./utils/type_guards.ts\";\n\n/** Base interface for application listening options. */\nexport interface ListenOptionsBase {\n  /** The port to listen on. If not specified, defaults to `0`, which allows the\n   * operating system to determine the value. */\n  port?: number;\n  /** A literal IP address or host name that can be resolved to an IP address.\n   * If not specified, defaults to `0.0.0.0`.\n   *\n   * __Note about `0.0.0.0`__ While listening `0.0.0.0` works on all platforms,\n   * the browsers on Windows don't work with the address `0.0.0.0`.\n   * You should show the message like `server running on localhost:8080` instead of\n   * `server running on 0.0.0.0:8080` if your program supports Windows. */\n  hostname?: string;\n  secure?: false;\n  /** An optional abort signal which can be used to close the listener. */\n  signal?: AbortSignal;\n}\n\ninterface TlsCertifiedKeyPem {\n  /** The format of this key material, which must be PEM. */\n  keyFormat?: \"pem\";\n  /** Private key in `PEM` format. RSA, EC, and PKCS8-format keys are supported. */\n  key: string;\n  /** Certificate chain in `PEM` format. */\n  cert: string;\n}\n\ninterface TlsCertifiedKeyFromFile {\n  /** Path to a file containing a PEM formatted CA certificate. Requires\n   * `--allow-read`.\n   *\n   * @tags allow-read\n   * @deprecated This will be removed in Deno 2.0. See the\n   * {@link https://docs.deno.com/runtime/manual/advanced/migrate_deprecations | Deno 1.x to 2.x Migration Guide}\n   * for migration instructions.\n   */\n  certFile: string;\n  /** Path to a file containing a private key file. Requires `--allow-read`.\n   *\n   * @tags allow-read\n   * @deprecated This will be removed in Deno 2.0. See the\n   * {@link https://docs.deno.com/runtime/manual/advanced/migrate_deprecations | Deno 1.x to 2.x Migration Guide}\n   * for migration instructions.\n   */\n  keyFile: string;\n}\n\ninterface TlsCertifiedKeyConnectTls {\n  /**\n   * Certificate chain in `PEM` format.\n   *\n   * @deprecated This will be removed in Deno 2.0. See the\n   * {@link https://docs.deno.com/runtime/manual/advanced/migrate_deprecations | Deno 1.x to 2.x Migration Guide}\n   * for migration instructions.\n   */\n  certChain: string;\n  /**\n   * Private key in `PEM` format. RSA, EC, and PKCS8-format keys are supported.\n   *\n   * @deprecated This will be removed in Deno 2.0. See the\n   * {@link https://docs.deno.com/runtime/manual/advanced/migrate_deprecations | Deno 1.x to 2.x Migration Guide}\n   * for migration instructions.\n   */\n  privateKey: string;\n}\n\ntype TlsCertifiedKeyOptions =\n  | TlsCertifiedKeyPem\n  | TlsCertifiedKeyFromFile\n  | TlsCertifiedKeyConnectTls;\n\n/** Interface options when listening on TLS. */\nexport type ListenOptionsTls = {\n  /** The port to listen on. */\n  port: number;\n  /** A literal IP address or host name that can be resolved to an IP address.\n   *\n   * __Note about `0.0.0.0`__ While listening `0.0.0.0` works on all platforms,\n   * the browsers on Windows don't work with the address `0.0.0.0`.\n   * You should show the message like `server running on localhost:8080` instead of\n   * `server running on 0.0.0.0:8080` if your program supports Windows.\n   *\n   * @default {\"0.0.0.0\"} */\n  hostname?: string;\n\n  transport?: \"tcp\";\n\n  /** Application-Layer Protocol Negotiation (ALPN) protocols to announce to\n   * the client. If not specified, no ALPN extension will be included in the\n   * TLS handshake.\n   */\n  alpnProtocols?: string[];\n  secure: true;\n  /** An optional abort signal which can be used to close the listener. */\n  signal?: AbortSignal;\n} & TlsCertifiedKeyOptions;\n\ninterface HandleMethod {\n  /** Handle an individual server request, returning the server response.  This\n   * is similar to `.listen()`, but opening the connection and retrieving\n   * requests are not the responsibility of the application.  If the generated\n   * context gets set to not to respond, then the method resolves with\n   * `undefined`, otherwise it resolves with a DOM `Response` object. */\n  (\n    request: Request,\n    remoteAddr?: NetAddr,\n    secure?: boolean,\n  ): Promise<Response | undefined>;\n}\n\ninterface CloudflareExecutionContext {\n  waitUntil(promise: Promise<unknown>): void;\n  passThroughOnException(): void;\n}\n\ninterface CloudflareFetchHandler<\n  Env extends Record<string, string> = Record<string, string>,\n> {\n  /** A method that is compatible with the Cloudflare Worker\n   * [Fetch Handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/)\n   * and can be exported to handle Cloudflare Worker fetch requests.\n   *\n   * # Example\n   *\n   * ```ts\n   * import { Application } from \"@oak/oak\";\n   *\n   * const app = new Application();\n   * app.use((ctx) => {\n   *   ctx.response.body = \"hello world!\";\n   * });\n   *\n   * export default { fetch: app.fetch };\n   * ```\n   */\n  (\n    request: Request,\n    env: Env,\n    ctx: CloudflareExecutionContext,\n  ): Promise<Response>;\n}\n\n/** Options which can be specified when listening. */\nexport type ListenOptions = ListenOptionsTls | ListenOptionsBase;\n\ninterface ApplicationCloseEventListener {\n  (evt: ApplicationCloseEvent): void | Promise<void>;\n}\n\ninterface ApplicationCloseEventListenerObject {\n  handleEvent(evt: ApplicationCloseEvent): void | Promise<void>;\n}\n\ntype ApplicationCloseEventListenerOrEventListenerObject =\n  | ApplicationCloseEventListener\n  | ApplicationCloseEventListenerObject;\n\ninterface ApplicationErrorEventListener<S extends AS, AS extends State> {\n  (evt: ApplicationErrorEvent<S, AS>): void | Promise<void>;\n}\n\ninterface ApplicationErrorEventListenerObject<S extends AS, AS extends State> {\n  handleEvent(evt: ApplicationErrorEvent<S, AS>): void | Promise<void>;\n}\n\ninterface ApplicationErrorEventInit<S extends AS, AS extends State>\n  extends ErrorEventInit {\n  context?: Context<S, AS>;\n}\n\ntype ApplicationErrorEventListenerOrEventListenerObject<\n  S extends AS,\n  AS extends State,\n> =\n  | ApplicationErrorEventListener<S, AS>\n  | ApplicationErrorEventListenerObject<S, AS>;\n\ninterface ApplicationListenEventListener {\n  (evt: ApplicationListenEvent): void | Promise<void>;\n}\n\ninterface ApplicationListenEventListenerObject {\n  handleEvent(evt: ApplicationListenEvent): void | Promise<void>;\n}\n\ninterface ApplicationListenEventInit extends EventInit {\n  hostname: string;\n  listener: Listener;\n  port: number;\n  secure: boolean;\n  serverType: \"native\" | \"node\" | \"bun\" | \"custom\";\n}\n\ntype ApplicationListenEventListenerOrEventListenerObject =\n  | ApplicationListenEventListener\n  | ApplicationListenEventListenerObject;\n\n/** Available options that are used when creating a new instance of\n * {@linkcode Application}. */\nexport interface ApplicationOptions<S extends State, R extends ServerRequest> {\n  /** Determine how when creating a new context, the state from the application\n   * should be applied. A value of `\"clone\"` will set the state as a clone of\n   * the app state. Any non-cloneable or non-enumerable properties will not be\n   * copied. A value of `\"prototype\"` means that the application's state will be\n   * used as the prototype of the the context's state, meaning shallow\n   * properties on the context's state will not be reflected in the\n   * application's state. A value of `\"alias\"` means that application's `.state`\n   * and the context's `.state` will be a reference to the same object. A value\n   * of `\"empty\"` will initialize the context's `.state` with an empty object.\n   *\n   * The default value is `\"clone\"`.\n   */\n  contextState?: \"clone\" | \"prototype\" | \"alias\" | \"empty\";\n\n  /** An optional replacer function to be used when serializing a JSON\n   * response. The replacer will be used with `JSON.stringify()` to encode any\n   * response bodies that need to be converted before sending the response.\n   *\n   * This is intended to allow responses to contain bigints and circular\n   * references and encoding other values which JSON does not support directly.\n   *\n   * This can be used in conjunction with `jsonBodyReviver` to handle decoding\n   * of request bodies if the same semantics are used for client requests.\n   *\n   * If more detailed or conditional usage is required, then serialization\n   * should be implemented directly in middleware. */\n  jsonBodyReplacer?: (\n    key: string,\n    value: unknown,\n    context: Context<S>,\n  ) => unknown;\n\n  /** An optional reviver function to be used when parsing a JSON request. The\n   * reviver will be used with `JSON.parse()` to decode any response bodies that\n   * are being converted as JSON.\n   *\n   * This is intended to allow requests to deserialize to bigints, circular\n   * references, or other values which JSON does not support directly.\n   *\n   * This can be used in conjunction with `jsonBodyReplacer` to handle decoding\n   * of response bodies if the same semantics are used for responses.\n   *\n   * If more detailed or conditional usage is required, then deserialization\n   * should be implemented directly in the middleware.\n   */\n  jsonBodyReviver?: (\n    key: string,\n    value: unknown,\n    context: Context<S>,\n  ) => unknown;\n\n  /** An initial set of keys (or instance of {@linkcode KeyStack}) to be used for signing\n   * cookies produced by the application. */\n  keys?: KeyStack | Key[];\n\n  /** If `true`, any errors handled by the application will be logged to the\n   * stderr. If `false` nothing will be logged. The default is `true`.\n   *\n   * All errors are available as events on the application of type `\"error\"` and\n   * can be accessed for custom logging/application management via adding an\n   * event listener to the application:\n   *\n   * ```ts\n   * const app = new Application({ logErrors: false });\n   * app.addEventListener(\"error\", (evt) => {\n   *   // evt.error will contain what error was thrown\n   * });\n   * ```\n   */\n  logErrors?: boolean;\n\n  /** If set to `true`, proxy headers will be trusted when processing requests.\n   * This defaults to `false`. */\n  proxy?: boolean;\n\n  /** A server constructor to use instead of the default server for receiving\n   * requests.\n   *\n   * Generally this is only used for testing. */\n  serverConstructor?: ServerConstructor<R>;\n\n  /** The initial state object for the application, of which the type can be\n   * used to infer the type of the state for both the application and any of the\n   * application's context. */\n  state?: S;\n}\n\ninterface RequestState {\n  handling: Set<Promise<void>>;\n  closing: boolean;\n  closed: boolean;\n  server: OakServer<ServerRequest>;\n}\n\n/** The base type of state which is associated with an application or\n * context. */\n// deno-lint-ignore no-explicit-any\nexport type State = Record<PropertyKey, any>;\n\nconst ADDR_REGEXP = /^\\[?([^\\]]*)\\]?:([0-9]{1,5})$/;\n\nlet DefaultServerCtor: ServerConstructor<ServerRequest> | undefined;\nlet NativeRequestCtor: typeof NativeRequest | undefined;\n\n/** An event that occurs when the application closes. */\nexport class ApplicationCloseEvent extends Event {\n  constructor(eventInitDict: EventInit) {\n    super(\"close\", eventInitDict);\n  }\n}\n\n/** An event that occurs when an application error occurs.\n *\n * When the error occurs related to the handling of a request, the `.context`\n * property will be populated.\n */\nexport class ApplicationErrorEvent<S extends AS, AS extends State>\n  extends ErrorEvent {\n  context?: Context<S, AS>;\n\n  constructor(eventInitDict: ApplicationErrorEventInit<S, AS>) {\n    super(\"error\", eventInitDict);\n    this.context = eventInitDict.context;\n  }\n}\n\nfunction logErrorListener<S extends AS, AS extends State>(\n  { error, context }: ApplicationErrorEvent<S, AS>,\n) {\n  if (error instanceof Error) {\n    console.error(\n      `[uncaught application error]: ${error.name} - ${error.message}`,\n    );\n  } else {\n    console.error(`[uncaught application error]\\n`, error);\n  }\n  if (context) {\n    let url: string;\n    try {\n      url = context.request.url.toString();\n    } catch {\n      url = \"[malformed url]\";\n    }\n    console.error(`\\nrequest:`, {\n      url,\n      method: context.request.method,\n      hasBody: context.request.hasBody,\n    });\n    console.error(`response:`, {\n      status: context.response.status,\n      type: context.response.type,\n      hasBody: !!context.response.body,\n      writable: context.response.writable,\n    });\n  }\n  if (error instanceof Error && error.stack) {\n    console.error(`\\n${error.stack.split(\"\\n\").slice(1).join(\"\\n\")}`);\n  }\n}\n\n/**\n * An event that occurs when the application starts listening for requests.\n */\nexport class ApplicationListenEvent extends Event {\n  hostname: string;\n  listener: Listener;\n  port: number;\n  secure: boolean;\n  serverType: \"native\" | \"node\" | \"bun\" | \"custom\";\n\n  constructor(eventInitDict: ApplicationListenEventInit) {\n    super(\"listen\", eventInitDict);\n    this.hostname = eventInitDict.hostname;\n    this.listener = eventInitDict.listener;\n    this.port = eventInitDict.port;\n    this.secure = eventInitDict.secure;\n    this.serverType = eventInitDict.serverType;\n  }\n}\n\n/** A class which registers middleware (via `.use()`) and then processes\n * inbound requests against that middleware (via `.listen()`).\n *\n * The `context.state` can be typed via passing a generic argument when\n * constructing an instance of `Application`. It can also be inferred by setting\n * the {@linkcode ApplicationOptions.state} option when constructing the\n * application.\n *\n * ### Basic example\n *\n * ```ts\n * import { Application } from \"jsr:@oak/oak/application\";\n *\n * const app = new Application();\n *\n * app.use((ctx, next) => {\n *   // called on each request with the context (`ctx`) of the request,\n *   // response, and other data.\n *   // `next()` is use to modify the flow control of the middleware stack.\n * });\n *\n * app.listen({ port: 8080 });\n * ```\n *\n * @template AS the type of the application state which extends\n *              {@linkcode State} and defaults to a simple string record.\n */\n// deno-lint-ignore no-explicit-any\nexport class Application<AS extends State = Record<string, any>>\n  extends EventTarget {\n  #composedMiddleware?: (context: Context<AS, AS>) => Promise<unknown>;\n  #contextOptions: Pick<\n    ApplicationOptions<AS, ServerRequest>,\n    \"jsonBodyReplacer\" | \"jsonBodyReviver\"\n  >;\n  #contextState: \"clone\" | \"prototype\" | \"alias\" | \"empty\";\n  #keys?: KeyStack;\n  #middleware: MiddlewareOrMiddlewareObject<State, Context<State, AS>>[] = [];\n  #serverConstructor: ServerConstructor<ServerRequest> | undefined;\n\n  /** A set of keys, or an instance of `KeyStack` which will be used to sign\n   * cookies read and set by the application to avoid tampering with the\n   * cookies. */\n  get keys(): KeyStack | Key[] | undefined {\n    return this.#keys;\n  }\n\n  set keys(keys: KeyStack | Key[] | undefined) {\n    if (!keys) {\n      this.#keys = undefined;\n      return;\n    } else if (Array.isArray(keys)) {\n      this.#keys = new KeyStack(keys);\n    } else {\n      this.#keys = keys;\n    }\n  }\n\n  /** If `true`, proxy headers will be trusted when processing requests.  This\n   * defaults to `false`. */\n  proxy: boolean;\n\n  /** Generic state of the application, which can be specified by passing the\n   * generic argument when constructing:\n   *\n   *       const app = new Application<{ foo: string }>();\n   *\n   * Or can be contextually inferred based on setting an initial state object:\n   *\n   *       const app = new Application({ state: { foo: \"bar\" } });\n   *\n   * When a new context is created, the application's state is cloned and the\n   * state is unique to that request/response.  Changes can be made to the\n   * application state that will be shared with all contexts.\n   */\n  state: AS;\n\n  constructor(options: ApplicationOptions<AS, ServerRequest> = {}) {\n    super();\n    const {\n      state,\n      keys,\n      proxy,\n      serverConstructor,\n      contextState = \"clone\",\n      logErrors = true,\n      ...contextOptions\n    } = options;\n\n    this.proxy = proxy ?? false;\n    this.keys = keys;\n    this.state = state ?? {} as AS;\n    this.#serverConstructor = serverConstructor;\n    this.#contextOptions = contextOptions;\n    this.#contextState = contextState;\n\n    if (logErrors) {\n      this.addEventListener(\"error\", logErrorListener);\n    }\n  }\n\n  #getComposed(): (context: Context<AS, AS>) => Promise<unknown> {\n    if (!this.#composedMiddleware) {\n      this.#composedMiddleware = compose(this.#middleware);\n    }\n    return this.#composedMiddleware;\n  }\n\n  #getContextState(): AS {\n    switch (this.#contextState) {\n      case \"alias\":\n        return this.state;\n      case \"clone\":\n        return cloneState(this.state);\n      case \"empty\":\n        return {} as AS;\n      case \"prototype\":\n        return Object.create(this.state);\n    }\n  }\n\n  /** Deal with uncaught errors in either the middleware or sending the\n   * response. */\n  // deno-lint-ignore no-explicit-any\n  #handleError(context: Context<AS>, error: any): void {\n    if (!(error instanceof Error)) {\n      error = new Error(`non-error thrown: ${JSON.stringify(error)}`);\n    }\n    const { message } = error;\n    if (!context.response.writable) {\n      this.dispatchEvent(\n        new ApplicationErrorEvent({ context, message, error }),\n      );\n      return;\n    }\n    for (const key of [...context.response.headers.keys()]) {\n      context.response.headers.delete(key);\n    }\n    if (error.headers && error.headers instanceof Headers) {\n      for (const [key, value] of error.headers) {\n        context.response.headers.set(key, value);\n      }\n    }\n    context.response.type = \"text\";\n    const status: Status = context.response.status =\n      globalThis.Deno && Deno.errors && error instanceof Deno.errors.NotFound\n        ? 404\n        : error.status && typeof error.status === \"number\"\n        ? error.status\n        : 500;\n    context.response.body = error.expose ? error.message : STATUS_TEXT[status];\n    this.dispatchEvent(new ApplicationErrorEvent({ context, message, error }));\n  }\n\n  /** Processing registered middleware on each request. */\n  async #handleRequest(\n    request: ServerRequest,\n    secure: boolean,\n    state: RequestState,\n  ): Promise<void> {\n    let context: Context<AS, AS> | undefined;\n    try {\n      context = new Context(\n        this,\n        request,\n        this.#getContextState(),\n        { secure, ...this.#contextOptions },\n      );\n    } catch (e) {\n      const error = e instanceof Error\n        ? e\n        : new Error(`non-error thrown: ${JSON.stringify(e)}`);\n      const { message } = error;\n      this.dispatchEvent(new ApplicationErrorEvent({ message, error }));\n      return;\n    }\n    assert(context, \"Context was not created.\");\n    const { promise, resolve } = createPromiseWithResolvers<void>();\n    state.handling.add(promise);\n    if (!state.closing && !state.closed) {\n      try {\n        await this.#getComposed()(context);\n      } catch (err) {\n        this.#handleError(context, err);\n      }\n    }\n    if (context.respond === false) {\n      context.response.destroy();\n      resolve!();\n      state.handling.delete(promise);\n      return;\n    }\n    let closeResources = true;\n    let response: Response;\n    try {\n      closeResources = false;\n      response = await context.response.toDomResponse();\n    } catch (err) {\n      this.#handleError(context, err);\n      response = await context.response.toDomResponse();\n    }\n    assert(response);\n    try {\n      await request.respond(response);\n    } catch (err) {\n      this.#handleError(context, err);\n    } finally {\n      context.response.destroy(closeResources);\n      resolve!();\n      state.handling.delete(promise);\n      if (state.closing) {\n        await state.server.close();\n        if (!state.closed) {\n          this.dispatchEvent(new ApplicationCloseEvent({}));\n        }\n        state.closed = true;\n      }\n    }\n  }\n\n  /** Add an event listener for a `\"close\"` event which occurs when the\n   * application is closed and no longer listening or handling requests. */\n  override addEventListener<S extends AS>(\n    type: \"close\",\n    listener: ApplicationCloseEventListenerOrEventListenerObject | null,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  /** Add an event listener for an `\"error\"` event which occurs when an\n   * un-caught error occurs when processing the middleware or during processing\n   * of the response. */\n  override addEventListener<S extends AS>(\n    type: \"error\",\n    listener: ApplicationErrorEventListenerOrEventListenerObject<S, AS> | null,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  /** Add an event listener for a `\"listen\"` event which occurs when the server\n   * has successfully opened but before any requests start being processed. */\n  override addEventListener(\n    type: \"listen\",\n    listener: ApplicationListenEventListenerOrEventListenerObject | null,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  /** Add an event listener for an event.  Currently valid event types are\n   * `\"error\"` and `\"listen\"`. */\n  override addEventListener(\n    type: \"close\" | \"error\" | \"listen\",\n    listener: EventListenerOrEventListenerObject | null,\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    super.addEventListener(type, listener, options);\n  }\n\n  /** A method that is compatible with the Cloudflare Worker\n   * [Fetch Handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/)\n   * and can be exported to handle Cloudflare Worker fetch requests.\n   *\n   * # Example\n   *\n   * ```ts\n   * import { Application } from \"@oak/oak\";\n   *\n   * const app = new Application();\n   * app.use((ctx) => {\n   *   ctx.response.body = \"hello world!\";\n   * });\n   *\n   * export default { fetch: app.fetch };\n   * ```\n   */\n  fetch: CloudflareFetchHandler = async <\n    Env extends Record<string, string> = Record<string, string>,\n  >(\n    request: Request,\n    _env: Env,\n    _ctx: CloudflareExecutionContext,\n  ): Promise<Response> => {\n    if (!this.#middleware.length) {\n      throw new TypeError(\"There is no middleware to process requests.\");\n    }\n    if (!NativeRequestCtor) {\n      const { NativeRequest } = await import(\"./http_server_native_request.ts\");\n      NativeRequestCtor = NativeRequest;\n    }\n    let remoteAddr: NetAddr | undefined;\n    const hostname = request.headers.get(\"CF-Connecting-IP\") ?? undefined;\n    if (hostname) {\n      remoteAddr = { hostname, port: 0, transport: \"tcp\" };\n    }\n    const contextRequest = new NativeRequestCtor(request, { remoteAddr });\n    const context = new Context(\n      this,\n      contextRequest,\n      this.#getContextState(),\n      this.#contextOptions,\n    );\n    try {\n      await this.#getComposed()(context);\n      const response = await context.response.toDomResponse();\n      context.response.destroy(false);\n      return response;\n    } catch (err) {\n      this.#handleError(context, err);\n      throw err;\n    }\n  };\n\n  /** Handle an individual server request, returning the server response.  This\n   * is similar to `.listen()`, but opening the connection and retrieving\n   * requests are not the responsibility of the application.  If the generated\n   * context gets set to not to respond, then the method resolves with\n   * `undefined`, otherwise it resolves with a standard {@linkcode Response}. */\n  handle: HandleMethod = (async (\n    request: Request,\n    secureOrAddr: NetAddr | boolean | undefined,\n    secure: boolean | undefined = false,\n  ): Promise<Response | undefined> => {\n    if (!this.#middleware.length) {\n      throw new TypeError(\"There is no middleware to process requests.\");\n    }\n    assert(isNetAddr(secureOrAddr) || typeof secureOrAddr === \"undefined\");\n    if (!NativeRequestCtor) {\n      const { NativeRequest } = await import(\"./http_server_native_request.ts\");\n      NativeRequestCtor = NativeRequest;\n    }\n    const contextRequest = new NativeRequestCtor(request, {\n      remoteAddr: secureOrAddr,\n    });\n    const context = new Context(\n      this,\n      contextRequest,\n      this.#getContextState(),\n      { secure, ...this.#contextOptions },\n    );\n    try {\n      await this.#getComposed()(context);\n    } catch (err) {\n      this.#handleError(context, err);\n    }\n    if (context.respond === false) {\n      context.response.destroy();\n      return;\n    }\n    try {\n      const response = await context.response.toDomResponse();\n      context.response.destroy(false);\n      return response;\n    } catch (err) {\n      this.#handleError(context, err);\n      throw err;\n    }\n  });\n\n  /** Start listening for requests, processing registered middleware on each\n   * request.  If the options `.secure` is undefined or `false`, the listening\n   * will be over HTTP.  If the options `.secure` property is `true`, a\n   * `.certFile` and a `.keyFile` property need to be supplied and requests\n   * will be processed over HTTPS. */\n  async listen(addr: string): Promise<void>;\n  /** Start listening for requests, processing registered middleware on each\n   * request.  If the options `.secure` is undefined or `false`, the listening\n   * will be over HTTP.  If the options `.secure` property is `true`, a\n   * `.certFile` and a `.keyFile` property need to be supplied and requests\n   * will be processed over HTTPS.\n   *\n   * Omitting options will default to `{ port: 0 }` which allows the operating\n   * system to select the port. */\n  async listen(options?: ListenOptions): Promise<void>;\n  async listen(options: string | ListenOptions = { port: 0 }): Promise<void> {\n    if (!this.#middleware.length) {\n      throw new TypeError(\"There is no middleware to process requests.\");\n    }\n    for (const middleware of this.#middleware) {\n      if (isMiddlewareObject(middleware) && middleware.init) {\n        await middleware.init();\n      }\n    }\n    if (typeof options === \"string\") {\n      const match = ADDR_REGEXP.exec(options);\n      if (!match) {\n        throw TypeError(`Invalid address passed: \"${options}\"`);\n      }\n      const [, hostname, portStr] = match;\n      options = { hostname, port: parseInt(portStr, 10) };\n    }\n    options = Object.assign({ port: 0 }, options);\n    if (!this.#serverConstructor) {\n      if (!DefaultServerCtor) {\n        const { Server } = await (isBun()\n          ? import(\"./http_server_bun.ts\")\n          : isNode()\n          ? import(\"./http_server_node.ts\")\n          : import(\"./http_server_native.ts\"));\n        DefaultServerCtor = Server as ServerConstructor<ServerRequest>;\n      }\n      this.#serverConstructor = DefaultServerCtor;\n    }\n    const server = new this.#serverConstructor(this, options);\n    const state = {\n      closed: false,\n      closing: false,\n      handling: new Set<Promise<void>>(),\n      server,\n    };\n    const { signal } = options;\n    if (signal) {\n      signal.addEventListener(\"abort\", () => {\n        if (!state.handling.size) {\n          state.closed = true;\n          this.dispatchEvent(new ApplicationCloseEvent({}));\n        }\n        state.closing = true;\n      }, { once: true });\n    }\n    const { secure = false } = options;\n    const serverType = this.#serverConstructor.type ?? \"custom\";\n    const listener = await server.listen();\n    const { hostname, port } = listener.addr;\n    this.dispatchEvent(\n      new ApplicationListenEvent({\n        hostname,\n        listener,\n        port,\n        secure,\n        serverType,\n      }),\n    );\n    try {\n      for await (const request of server) {\n        this.#handleRequest(request, secure, state);\n      }\n      await Promise.all(state.handling);\n    } catch (error) {\n      const message = error instanceof Error\n        ? error.message\n        : \"Application Error\";\n      this.dispatchEvent(\n        new ApplicationErrorEvent({ message, error }),\n      );\n    }\n  }\n\n  /** Register middleware to be used with the application.  Middleware will\n   * be processed in the order it is added, but middleware can control the flow\n   * of execution via the use of the `next()` function that the middleware\n   * function will be called with.  The `context` object provides information\n   * about the current state of the application.\n   *\n   * Basic usage:\n   *\n   * ```ts\n   * const import { Application } from \"jsr:@oak/oak/application\";\n   *\n   * const app = new Application();\n   *\n   * app.use((ctx, next) => {\n   *   ctx.request; // contains request information\n   *   ctx.response; // setups up information to use in the response;\n   *   await next(); // manages the flow control of the middleware execution\n   * });\n   *\n   * await app.listen({ port: 80 });\n   * ```\n   */\n  use<S extends State = AS>(\n    middleware: MiddlewareOrMiddlewareObject<S, Context<S, AS>>,\n    ...middlewares: MiddlewareOrMiddlewareObject<S, Context<S, AS>>[]\n  ): Application<S extends AS ? S : (S & AS)>;\n  use<S extends State = AS>(\n    ...middleware: MiddlewareOrMiddlewareObject<S, Context<S, AS>>[]\n  ): Application<S extends AS ? S : (S & AS)> {\n    this.#middleware.push(...middleware);\n    this.#composedMiddleware = undefined;\n    // deno-lint-ignore no-explicit-any\n    return this as Application<any>;\n  }\n\n  [Symbol.for(\"Deno.customInspect\")](\n    inspect: (value: unknown) => string,\n  ): string {\n    const { keys, proxy, state } = this;\n    return `${this.constructor.name} ${\n      inspect({ \"#middleware\": this.#middleware, keys, proxy, state })\n    }`;\n  }\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")](\n    depth: number,\n    // deno-lint-ignore no-explicit-any\n    options: any,\n    inspect: (value: unknown, options?: unknown) => string,\n    // deno-lint-ignore no-explicit-any\n  ): any {\n    if (depth < 0) {\n      return options.stylize(`[${this.constructor.name}]`, \"special\");\n    }\n\n    const newOptions = Object.assign({}, options, {\n      depth: options.depth === null ? null : options.depth - 1,\n    });\n    const { keys, proxy, state } = this;\n    return `${options.stylize(this.constructor.name, \"special\")} ${\n      inspect(\n        { \"#middleware\": this.#middleware, keys, proxy, state },\n        newOptions,\n      )\n    }`;\n  }\n}\n"
        },
        {
          "name": "body.test.ts",
          "type": "blob",
          "size": 11.8662109375,
          "content": "import { Body } from \"./body.ts\";\nimport { assert, concat, isHttpError, Status } from \"./deps.ts\";\nimport { assertEquals, assertRejects, timingSafeEqual } from \"./deps_test.ts\";\nimport type { ServerRequest } from \"./types.ts\";\n\nconst MULTIPART_BODY_FIXTURE =\n  `--OAK-SERVER-BOUNDARY\\r\\nContent-Disposition: form-data; name=\"hello\"\\r\\n\\r\\nworld\\r\\n--OAK-SERVER-BOUNDARY--\\r\\n`;\n\nconst MULTIPART_CONTENTTYPE_FIXTURE =\n  `multipart/form-data; boundary=OAK-SERVER-BOUNDARY`;\n\nconst encoder = new TextEncoder();\n\nfunction nativeToServer(\n  request: Request,\n): Pick<ServerRequest, \"request\" | \"headers\" | \"getBody\"> {\n  return {\n    request,\n    headers: request.headers,\n    getBody() {\n      return request.body;\n    },\n  };\n}\n\nfunction nodeToServer(\n  headers: HeadersInit,\n  body: BodyInit,\n): Pick<ServerRequest, \"request\" | \"headers\" | \"getBody\"> {\n  const req = new Request(\"https://localhost\", {\n    method: \"POST\",\n    body,\n    headers,\n  });\n  return {\n    headers: req.headers,\n    getBody() {\n      return req.body;\n    },\n  };\n}\n\nDeno.test({\n  name: \"body - form - native request\",\n  async fn() {\n    const rBody = `foo=bar&bar=1&baz=qux+%2B+quux`;\n    const body = new Body(nativeToServer(\n      new Request(\n        \"http://localhost/index.html\",\n        {\n          body: rBody,\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"Content-Length\": String(rBody.length),\n          },\n        },\n      ),\n    ));\n    assert(body.has);\n    assertEquals(body.type(), \"form\");\n    const actual = await body.form();\n    assertEquals(\n      Array.from(actual.entries()),\n      [[\"foo\", \"bar\"], [\"bar\", \"1\"], [\"baz\", \"qux + quux\"]],\n    );\n  },\n});\n\nDeno.test({\n  name: \"body - form - node request\",\n  async fn() {\n    const rBody = `foo=bar&bar=1&baz=qux+%2B+quux`;\n    const body = new Body(nodeToServer(\n      {\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n        \"Content-Length\": String(rBody.length),\n      },\n      rBody,\n    ));\n    assert(body.has);\n    assertEquals(body.type(), \"form\");\n    const actual = await body.form();\n    assertEquals(\n      Array.from(actual.entries()),\n      [[\"foo\", \"bar\"], [\"bar\", \"1\"], [\"baz\", \"qux + quux\"]],\n    );\n  },\n});\n\nDeno.test({\n  name: \"body - formData - native request\",\n  async fn() {\n    const body = new Body(nativeToServer(\n      new Request(\n        \"http://localhost/index.html\",\n        {\n          body: MULTIPART_BODY_FIXTURE,\n          method: \"POST\",\n          headers: {\n            \"content-type\": MULTIPART_CONTENTTYPE_FIXTURE,\n          },\n        },\n      ),\n    ));\n    assert(body.has);\n    assertEquals(body.type(), \"form-data\");\n    const actual = await body.formData();\n    assertEquals([...actual], [\n      [\"hello\", \"world\"],\n    ]);\n  },\n});\n\nDeno.test({\n  name: \"body - formData - node request\",\n  async fn() {\n    const body = new Body(\n      nodeToServer(\n        { \"content-type\": MULTIPART_CONTENTTYPE_FIXTURE },\n        MULTIPART_BODY_FIXTURE,\n      ),\n    );\n    assert(body.has);\n    assertEquals(body.type(), \"form-data\");\n    const actual = await body.formData();\n    assertEquals([...actual], [\n      [\"hello\", \"world\"],\n    ]);\n  },\n});\n\nDeno.test({\n  name: \"body - json - native request\",\n  async fn() {\n    const rBody = JSON.stringify({ hello: \"world\" });\n    const body = new Body(\n      nativeToServer(\n        new Request(\n          \"http://localhost/index.html\",\n          {\n            body: rBody,\n            method: \"POST\",\n            headers: {\n              \"content-type\": \"application/json\",\n              \"content-length\": String(rBody.length),\n            },\n          },\n        ),\n      ),\n    );\n    assert(body.has);\n    assertEquals(body.type(), \"json\");\n    assertEquals(await body.json(), { hello: \"world\" });\n  },\n});\n\nDeno.test({\n  name: \"body - json - native request - reread does not throw\",\n  async fn() {\n    const rBody = JSON.stringify({ hello: \"world\" });\n    const body = new Body(\n      nativeToServer(\n        new Request(\n          \"http://localhost/index.html\",\n          {\n            body: rBody,\n            method: \"POST\",\n            headers: {\n              \"content-type\": \"application/json\",\n              \"content-length\": String(rBody.length),\n            },\n          },\n        ),\n      ),\n    );\n    assert(body.has);\n    assertEquals(body.type(), \"json\");\n    assertEquals(await body.json(), { hello: \"world\" });\n    assertEquals(body.used, true);\n    assertEquals(await body.json(), { hello: \"world\" });\n  },\n});\n\nDeno.test({\n  name: \"body - json - native request - read as text first\",\n  async fn() {\n    const rBody = JSON.stringify({ hello: \"world\" });\n    const body = new Body(\n      nativeToServer(\n        new Request(\n          \"http://localhost/index.html\",\n          {\n            body: rBody,\n            method: \"POST\",\n            headers: {\n              \"content-type\": \"application/json\",\n              \"content-length\": String(rBody.length),\n            },\n          },\n        ),\n      ),\n    );\n    assert(body.has);\n    assertEquals(body.type(), \"json\");\n    assertEquals(await body.text(), rBody);\n    assertEquals(body.used, true);\n    assertEquals(await body.json(), { hello: \"world\" });\n  },\n});\n\nDeno.test({\n  name: \"body - json - node request\",\n  async fn() {\n    const rBody = JSON.stringify({ hello: \"world\" });\n    const body = new Body(\n      nodeToServer(\n        {\n          \"content-type\": \"application/json\",\n          \"content-length\": String(rBody.length),\n        },\n        rBody,\n      ),\n    );\n    assert(body.has);\n    assertEquals(body.type(), \"json\");\n    assertEquals(await body.json(), { hello: \"world\" });\n  },\n});\n\nDeno.test({\n  name: \"body - json - node request - reread body does not throw\",\n  async fn() {\n    const rBody = JSON.stringify({ hello: \"world\" });\n    const body = new Body(\n      nodeToServer(\n        {\n          \"content-type\": \"application/json\",\n          \"content-length\": String(rBody.length),\n        },\n        rBody,\n      ),\n    );\n    assert(body.has);\n    assertEquals(body.type(), \"json\");\n    assertEquals(await body.json(), { hello: \"world\" });\n    assertEquals(body.used, true);\n    assertEquals(await body.json(), { hello: \"world\" });\n  },\n});\n\nDeno.test({\n  name: \"body - json - node request - read as text first then json\",\n  async fn() {\n    const rBody = JSON.stringify({ hello: \"world\" });\n    const body = new Body(\n      nodeToServer(\n        {\n          \"content-type\": \"application/json\",\n          \"content-length\": String(rBody.length),\n        },\n        rBody,\n      ),\n    );\n    assert(body.has);\n    assertEquals(body.type(), \"json\");\n    assertEquals(await body.text(), rBody);\n    assertEquals(body.used, true);\n    assertEquals(await body.json(), { hello: \"world\" });\n  },\n});\n\nDeno.test({\n  name: \"body - json does not parse - native request\",\n  async fn() {\n    const rBody = `{ hello: \"world\" }`;\n    const body = new Body(\n      nativeToServer(\n        new Request(\n          \"http://localhost/index.html\",\n          {\n            body: rBody,\n            method: \"POST\",\n            headers: {\n              \"content-type\": \"application/json\",\n              \"content-length\": String(rBody.length),\n            },\n          },\n        ),\n      ),\n    );\n    assert(body.has);\n    assertEquals(body.type(), \"json\");\n    const err = await assertRejects(async () => {\n      await body.json();\n    }, Error);\n    assert(isHttpError(err));\n    assertEquals(err.status, Status.BadRequest);\n  },\n});\n\nDeno.test({\n  name: \"body - json does not parse - node request\",\n  async fn() {\n    const rBody = `{ hello: \"world\" }`;\n    const body = new Body(\n      nodeToServer(\n        {\n          \"content-type\": \"application/json\",\n          \"content-length\": String(rBody.length),\n        },\n        rBody,\n      ),\n    );\n    assert(body.has);\n    assertEquals(body.type(), \"json\");\n    const err = await assertRejects(async () => {\n      await body.json();\n    }, Error);\n    assert(isHttpError(err));\n    assertEquals(err.status, Status.BadRequest);\n  },\n});\n\nDeno.test({\n  name: \"body - text - native request\",\n  async fn() {\n    const rBody = \"hello world\";\n    const body = new Body(\n      nativeToServer(\n        new Request(\"http://localhost:8080\", {\n          body: rBody,\n          method: \"POST\",\n          headers: { \"content-type\": \"text/plain\" },\n        }),\n      ),\n    );\n    assert(body.has);\n    assertEquals(body.type(), \"text\");\n    assertEquals(await body.text(), rBody);\n  },\n});\n\nDeno.test({\n  name: \"body - text - node request\",\n  async fn() {\n    const rBody = \"hello world\";\n    const body = new Body(\n      nodeToServer({ \"content-type\": \"text/plain\" }, rBody),\n    );\n    assert(body.has);\n    assertEquals(body.type(), \"text\");\n    assertEquals(await body.text(), rBody);\n  },\n});\n\nDeno.test({\n  name: \"body - arrayBuffer - native request\",\n  async fn() {\n    const rBody = \"hello world\";\n    const expected = encoder.encode(rBody);\n    const body = new Body(nativeToServer(\n      new Request(\"http://localhost:8080\", {\n        body: rBody,\n        method: \"POST\",\n        headers: { \"content-type\": \"application/octet-stream\" },\n      }),\n    ));\n    assert(body.has);\n    assertEquals(body.type(), \"binary\");\n    assert(timingSafeEqual(await body.arrayBuffer(), expected));\n  },\n});\n\nDeno.test({\n  name: \"body - arrayBuffer - node request\",\n  async fn() {\n    const rBody = \"hello world\";\n    const expected = encoder.encode(rBody);\n    const body = new Body(\n      nodeToServer({ \"content-type\": \"application/octet-stream\" }, rBody),\n    );\n    assert(body.has);\n    assertEquals(body.type(), \"binary\");\n    assert(timingSafeEqual(await body.arrayBuffer(), expected));\n  },\n});\n\nDeno.test({\n  name: \"body - blob - native request\",\n  async fn() {\n    const rBody = \"hello world\";\n    const expected = encoder.encode(rBody);\n    const body = new Body(nativeToServer(\n      new Request(\"http://localhost:8080\", {\n        body: rBody,\n        method: \"POST\",\n        headers: { \"content-type\": \"application/octet-stream\" },\n      }),\n    ));\n    assert(body.has);\n    assertEquals(body.type(), \"binary\");\n    const actual = await body.blob();\n    assert(timingSafeEqual(await actual.arrayBuffer(), expected));\n  },\n});\n\nDeno.test({\n  name: \"body - blob - node request\",\n  async fn() {\n    const rBody = \"hello world\";\n    const expected = encoder.encode(rBody);\n    const body = new Body(\n      nodeToServer({ \"content-type\": \"application/octet-stream\" }, rBody),\n    );\n    assert(body.has);\n    assertEquals(body.type(), \"binary\");\n    const actual = await body.blob();\n    assert(timingSafeEqual(await actual.arrayBuffer(), expected));\n  },\n});\n\nDeno.test({\n  name: \"body - stream - native request\",\n  async fn() {\n    const rBody = \"hello world\";\n    const expected = encoder.encode(rBody);\n    const body = new Body(nativeToServer(\n      new Request(\"http://localhost:8080\", {\n        body: rBody,\n        method: \"POST\",\n        headers: { \"content-type\": \"application/octet-stream\" },\n      }),\n    ));\n    assert(body.has);\n    assertEquals(body.type(), \"binary\");\n    assert(body.stream);\n    let actual = new Uint8Array();\n    for await (const chunk of body.stream) {\n      actual = concat([actual, chunk]);\n    }\n    assert(timingSafeEqual(actual, expected));\n  },\n});\n\nDeno.test({\n  name: \"body - stream - node request\",\n  async fn() {\n    const rBody = \"hello world\";\n    const expected = encoder.encode(rBody);\n    const body = new Body(\n      nodeToServer({ \"content-type\": \"application/octet-stream\" }, rBody),\n    );\n    assert(body.has);\n    assertEquals(body.type(), \"binary\");\n    assert(body.stream);\n    let actual = new Uint8Array();\n    for await (const chunk of body.stream) {\n      actual = concat([actual, chunk]);\n    }\n    assert(timingSafeEqual(actual, expected));\n  },\n});\n\nDeno.test({\n  name: \"body - empty\",\n  async fn() {\n    const body = new Body(nativeToServer(\n      new Request(\n        \"http://localhost/index.html\",\n        {\n          method: \"GET\",\n        },\n      ),\n    ));\n    assert(!body.has);\n    assertEquals(await body.init(), null);\n  },\n});\n"
        },
        {
          "name": "body.ts",
          "type": "blob",
          "size": 8.6435546875,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n/**\n * Contains the oak abstraction to represent a request {@linkcode Body}.\n *\n * This is not normally used directly by end users.\n *\n * @module\n */\n\nimport { createHttpError, matches, parseFormData, Status } from \"./deps.ts\";\nimport type { ServerRequest } from \"./types.ts\";\n\ntype JsonReviver = (key: string, value: unknown) => unknown;\n\nexport type BodyType =\n  | \"binary\"\n  | \"form\"\n  | \"form-data\"\n  | \"json\"\n  | \"text\"\n  | \"unknown\";\n\nconst KNOWN_BODY_TYPES: [bodyType: BodyType, knownMediaTypes: string[]][] = [\n  [\"binary\", [\"image\", \"audio\", \"application/octet-stream\"]],\n  [\"form\", [\"urlencoded\"]],\n  [\"form-data\", [\"multipart\"]],\n  [\"json\", [\"json\", \"application/*+json\", \"application/csp-report\"]],\n  [\"text\", [\"text\"]],\n];\n\nasync function readBlob(\n  body?: ReadableStream<Uint8Array> | null,\n  type?: string | null,\n): Promise<Blob> {\n  if (!body) {\n    return new Blob(undefined, type ? { type } : undefined);\n  }\n  const chunks: Uint8Array[] = [];\n  for await (const chunk of body) {\n    chunks.push(chunk);\n  }\n  return new Blob(chunks, type ? { type } : undefined);\n}\n\n/** An object which encapsulates information around a request body. */\nexport class Body {\n  #body?: ReadableStream<Uint8Array> | null;\n  #memo: Promise<ArrayBuffer | Blob | FormData | string> | null = null;\n  #memoType: \"arrayBuffer\" | \"blob\" | \"formData\" | \"text\" | null = null;\n  #headers?: Headers;\n  #request?: Request;\n  #reviver?: JsonReviver;\n  #type?: BodyType;\n  #used = false;\n\n  constructor(\n    serverRequest: Pick<ServerRequest, \"request\" | \"headers\" | \"getBody\">,\n    reviver?: JsonReviver,\n  ) {\n    if (serverRequest.request) {\n      this.#request = serverRequest.request;\n    } else {\n      this.#headers = serverRequest.headers;\n      this.#body = serverRequest.getBody();\n    }\n    this.#reviver = reviver;\n  }\n\n  /** Is `true` if the request might have a body, otherwise `false`.\n   *\n   * **WARNING** this is an unreliable API. In HTTP/2 in many situations you\n   * cannot determine if a request has a body or not unless you attempt to read\n   * the body, due to the streaming nature of HTTP/2. As of Deno 1.16.1, for\n   * HTTP/1.1, Deno also reflects that behavior.  The only reliable way to\n   * determine if a request has a body or not is to attempt to read the body.\n   */\n  get has(): boolean {\n    return !!(this.#request ? this.#request.body : this.#body);\n  }\n\n  /** Exposes the \"raw\" `ReadableStream` of the body. */\n  get stream(): ReadableStream<Uint8Array> | null {\n    return this.#request ? this.#request.body : this.#body!;\n  }\n\n  /** Returns `true` if the body has been consumed yet, otherwise `false`. */\n  get used(): boolean {\n    return this.#request?.bodyUsed ?? !!this.#used;\n  }\n\n  /** Return the body to be reused as BodyInit. */\n  async init(): Promise<BodyInit | null> {\n    if (!this.has) {\n      return null;\n    }\n    return await this.#memo ?? this.stream;\n  }\n\n  /** Reads a body to the end and resolves with the value as an\n   * {@linkcode ArrayBuffer} */\n  async arrayBuffer(): Promise<ArrayBuffer> {\n    if (this.#memoType === \"arrayBuffer\") {\n      return this.#memo as Promise<ArrayBuffer>;\n    } else if (this.#memoType) {\n      throw new TypeError(\"Body already used as a different type.\");\n    }\n    this.#memoType = \"arrayBuffer\";\n    if (this.#request) {\n      return this.#memo = this.#request.arrayBuffer();\n    }\n    this.#used = true;\n    return this.#memo = (await readBlob(this.#body)).arrayBuffer();\n  }\n\n  /** Reads a body to the end and resolves with the value as a\n   * {@linkcode Blob}. */\n  blob(): Promise<Blob> {\n    if (this.#memoType === \"blob\") {\n      return this.#memo as Promise<Blob>;\n    } else if (this.#memoType) {\n      throw new TypeError(\"Body already used as a different type.\");\n    }\n    this.#memoType = \"blob\";\n    if (this.#request) {\n      return this.#memo = this.#request.blob();\n    }\n    this.#used = true;\n    return this.#memo = readBlob(\n      this.#body,\n      this.#headers?.get(\"content-type\"),\n    );\n  }\n\n  /** Reads a body as a URL encoded form, resolving the value as\n   * {@linkcode URLSearchParams}. */\n  async form(): Promise<URLSearchParams> {\n    const text = await this.text();\n    return new URLSearchParams(text);\n  }\n\n  /** Reads a body to the end attempting to parse the body as a set of\n   * {@linkcode FormData}. */\n  formData(): Promise<FormData> {\n    if (this.#memoType === \"formData\") {\n      return this.#memo as Promise<FormData>;\n    } else if (this.#memoType) {\n      throw new TypeError(\"Body already used as a different type.\");\n    }\n    this.#memoType = \"formData\";\n    if (this.#request) {\n      return this.#memo = this.#request.formData();\n    }\n    this.#used = true;\n    if (this.#body && this.#headers) {\n      const contentType = this.#headers.get(\"content-type\");\n      if (contentType) {\n        return this.#memo = parseFormData(contentType, this.#body);\n      }\n    }\n    throw createHttpError(Status.BadRequest, \"Missing content type.\");\n  }\n\n  /** Reads a body to the end attempting to parse the body as a JSON value.\n   *\n   * If a JSON reviver has been assigned, it will be used to parse the body.\n   */\n  // deno-lint-ignore no-explicit-any\n  async json(): Promise<any> {\n    try {\n      return JSON.parse(await this.text(), this.#reviver);\n    } catch (err) {\n      if (err instanceof Error) {\n        throw createHttpError(Status.BadRequest, err.message);\n      }\n      throw createHttpError(Status.BadRequest, JSON.stringify(err));\n    }\n  }\n\n  /** Reads the body to the end resolving with a string. */\n  async text(): Promise<string> {\n    if (this.#memoType === \"text\") {\n      return this.#memo as Promise<string>;\n    } else if (this.#memoType) {\n      throw new TypeError(\"Body already used as a different type.\");\n    }\n    this.#memoType = \"text\";\n    if (this.#request) {\n      return this.#memo = this.#request.text();\n    }\n    this.#used = true;\n    return this.#memo = (await readBlob(this.#body)).text();\n  }\n\n  /** Attempts to determine what type of the body is to help determine how best\n   * to attempt to decode the body. This performs analysis on the supplied\n   * `Content-Type` header of the request.\n   *\n   * **Note** these are not authoritative and should only be used as guidance.\n   *\n   * There is the ability to provide custom types when attempting to discern\n   * the type. Custom types are provided in the format of an object where the\n   * key is on of {@linkcode BodyType} and the value is an array of media types\n   * to attempt to match. Values supplied will be additive to known media types.\n   *\n   * The returned value is one of the following:\n   *\n   * - `\"binary\"` - The body appears to be binary data and should be consumed as\n   *   an array buffer, readable stream or blob.\n   * - `\"form\"` - The value appears to be an URL encoded form and should be\n   *   consumed as a form (`URLSearchParams`).\n   * - `\"form-data\"` - The value appears to be multipart form data and should be\n   *   consumed as form data.\n   * - `\"json\"` - The value appears to be JSON data and should be consumed as\n   *   decoded JSON.\n   * - `\"text\"` - The value appears to be text data and should be consumed as\n   *   text.\n   * - `\"unknown\"` - Either there is no body or the body type could not be\n   *   determined.\n   */\n  type(customMediaTypes?: Partial<Record<BodyType, string[]>>): BodyType {\n    if (this.#type && !customMediaTypes) {\n      return this.#type;\n    }\n    customMediaTypes = customMediaTypes ?? {};\n    const headers = this.#request?.headers ?? this.#headers;\n    const contentType = headers?.get(\"content-type\");\n    if (contentType) {\n      for (const [bodyType, knownMediaTypes] of KNOWN_BODY_TYPES) {\n        const customTypes = customMediaTypes[bodyType] ?? [];\n        if (matches(contentType, [...knownMediaTypes, ...customTypes])) {\n          this.#type = bodyType;\n          return this.#type;\n        }\n      }\n    }\n    return this.#type = \"unknown\";\n  }\n\n  [Symbol.for(\"Deno.customInspect\")](\n    inspect: (value: unknown) => string,\n  ): string {\n    const { has, used } = this;\n    return `${this.constructor.name} ${inspect({ has, used })}`;\n  }\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")](\n    depth: number,\n    // deno-lint-ignore no-explicit-any\n    options: any,\n    inspect: (value: unknown, options?: unknown) => string,\n    // deno-lint-ignore no-explicit-any\n  ): any {\n    if (depth < 0) {\n      return options.stylize(`[${this.constructor.name}]`, \"special\");\n    }\n\n    const newOptions = Object.assign({}, options, {\n      depth: options.depth === null ? null : options.depth - 1,\n    });\n    const { has, used } = this;\n    return `${options.stylize(this.constructor.name, \"special\")} ${\n      inspect(\n        { has, used },\n        newOptions,\n      )\n    }`;\n  }\n}\n"
        },
        {
          "name": "context.test.ts",
          "type": "blob",
          "size": 11.3671875,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n// deno-lint-ignore-file\n\nimport { assertEquals, assertStrictEquals, assertThrows } from \"./deps_test.ts\";\nimport type { Application, State } from \"./application.ts\";\nimport { Context } from \"./context.ts\";\nimport { assert, errors, SecureCookieMap, Status } from \"./deps.ts\";\nimport { NativeRequest } from \"./http_server_native_request.ts\";\nimport type {} from \"./http_server_native.ts\";\nimport { Request as OakRequest } from \"./request.ts\";\nimport { Response as OakResponse } from \"./response.ts\";\nimport type { UpgradeWebSocketFn, UpgradeWebSocketOptions } from \"./types.ts\";\nimport { cloneState } from \"./utils/clone_state.ts\";\nimport { isNode } from \"./utils/type_guards.ts\";\nimport { createPromiseWithResolvers } from \"./utils/create_promise_with_resolvers.ts\";\n\nfunction createMockApp<S extends State = Record<string, any>>(\n  state = {} as S,\n): Application<S> {\n  let listeners: any[] = [];\n  return {\n    state,\n    listeners,\n    dispatchEvent() {},\n    addEventListener(event: string) {\n      listeners.push(event);\n    },\n    [Symbol.for(\"Deno.customInspect\")]() {\n      return `MockApplication {}`;\n    },\n    [Symbol.for(\"nodejs.util.inspect.custom\")](\n      depth: number,\n      options: any,\n      inspect: (value: unknown, options?: unknown) => string,\n    ) {\n      if (depth < 0) {\n        return options.stylize(`[MockApplication]`, \"special\");\n      }\n\n      const newOptions = Object.assign({}, options, {\n        depth: options.depth === null ? null : options.depth - 1,\n      });\n      return `${options.stylize(\"MockApplication\", \"special\")} ${\n        inspect({}, newOptions)\n      }`;\n    },\n  } as any;\n}\n\ninterface MockNativeOptions {\n  url?: string;\n  requestInit?: RequestInit;\n  upgradeThrow?: boolean;\n  upgradeUndefined?: boolean;\n}\n\nlet respondWithStack: (Response | Promise<Response>)[] = [];\nlet upgradeWebSocketStack: [Request, UpgradeWebSocketOptions | undefined][] =\n  [];\n\nconst mockWebSocket = {} as WebSocket;\nconst mockResponse = {} as Response;\n\nfunction createMockNativeRequest(\n  {\n    url = \"http://localhost/\",\n    requestInit = { headers: [[\"host\", \"localhost\"]] },\n    upgradeThrow = true,\n    upgradeUndefined = false,\n  }: MockNativeOptions = {},\n) {\n  respondWithStack = [];\n  upgradeWebSocketStack = [];\n  const request = new Request(url, requestInit);\n  const upgradeWebSocket: UpgradeWebSocketFn | undefined = upgradeUndefined\n    ? undefined\n    : (request, options) => {\n      if (upgradeThrow) {\n        throw new TypeError(\"Cannot upgrade connection.\");\n      }\n      upgradeWebSocketStack.push([request, options]);\n      return { response: mockResponse, socket: mockWebSocket };\n    };\n  const nativeRequest = new NativeRequest(request, { upgradeWebSocket });\n  const { promise, resolve } = createPromiseWithResolvers<Response>();\n  respondWithStack.push(promise);\n  nativeRequest.response.then((response) => resolve(response));\n  return nativeRequest;\n}\n\nDeno.test({\n  name: \"context\",\n  fn() {\n    const app = createMockApp();\n    const serverRequest = createMockNativeRequest();\n    const context = new Context(app, serverRequest, cloneState(app.state));\n    assert(context instanceof Context);\n    assertEquals(context.state, app.state);\n    assertStrictEquals(context.app, app);\n    assert(context.cookies instanceof SecureCookieMap);\n    assert(context.request instanceof OakRequest);\n    assert(context.request.source instanceof Request);\n    assert(context.response instanceof OakResponse);\n  },\n});\n\nDeno.test({\n  name: \"context.assert()\",\n  fn() {\n    const context: Context = new Context(\n      createMockApp(),\n      createMockNativeRequest(),\n      {},\n    );\n    assertThrows(\n      () => {\n        let loggedIn: string | undefined;\n        context.assert(loggedIn, 401, \"Unauthorized\");\n      },\n      errors.Unauthorized,\n      \"Unauthorized\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"context.assert() headers\",\n  fn() {\n    const context: Context = new Context(\n      createMockApp(),\n      createMockNativeRequest(),\n      {},\n    );\n    assertThrows(\n      () => {\n        let loggedIn: string | undefined;\n        context.assert(loggedIn, 401, \"Unauthorized\", {\n          headers: new Headers({\n            \"WWW-Authenticate\":\n              'Bearer realm=\"oak-tests\",error=\"invalid_token\"',\n          }),\n        });\n      },\n      errors.Unauthorized,\n      \"Unauthorized\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"context.assert() expose\",\n  fn() {\n    const context: Context = new Context(\n      createMockApp(),\n      createMockNativeRequest(),\n      {},\n    );\n    assertThrows(\n      () => {\n        let loggedIn: string | undefined;\n        context.assert(loggedIn, 401, \"Unauthorized\", {\n          expose: true,\n        });\n      },\n      errors.Unauthorized,\n      \"Unauthorized\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"context.assert() no redundant status\",\n  fn() {\n    const context: Context = new Context(\n      createMockApp(),\n      createMockNativeRequest(),\n      {},\n    );\n    assertThrows(\n      () => {\n        let loggedIn: string | undefined;\n        context.assert(loggedIn, 401, \"Unauthorized\", {\n          status: Status.Unauthorized,\n        });\n      },\n      TypeError,\n      \"Cannot set property status of Error which has only a getter\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"context.throw()\",\n  fn() {\n    const context = new Context(createMockApp(), createMockNativeRequest(), {});\n    assertThrows(\n      () => {\n        context.throw(404, \"foobar\");\n      },\n      errors.NotFound,\n      \"foobar\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"context.send() default path\",\n  async fn() {\n    const context = new Context(\n      createMockApp(),\n      createMockNativeRequest({ url: \"http://localhost/test.html\" }),\n      {},\n    );\n    const fixture = await Deno.readFile(\"./fixtures/test.html\");\n    await context.send({ root: \"./fixtures\", maxbuffer: 0 });\n    const response = await context.response.toDomResponse();\n    const ab = await response.arrayBuffer();\n    assertEquals(new Uint8Array(ab), fixture);\n    assertEquals(context.response.type, \".html\");\n    assert(context.response.headers.get(\"last-modified\") != null);\n    assertEquals(context.response.headers.get(\"cache-control\"), \"max-age=0\");\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"context.send() specified path\",\n  async fn() {\n    const context = new Context(createMockApp(), createMockNativeRequest(), {});\n    const fixture = await Deno.readFile(\"./fixtures/test.html\");\n    await context.send({\n      path: \"/test.html\",\n      root: \"./fixtures\",\n      maxbuffer: 0,\n    });\n    const response = await context.response.toDomResponse();\n    const ab = await response.arrayBuffer();\n    assertEquals(new Uint8Array(ab), fixture);\n    assertEquals(context.response.type, \".html\");\n    assert(context.response.headers.get(\"last-modified\") != null);\n    assertEquals(context.response.headers.get(\"cache-control\"), \"max-age=0\");\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"context.upgrade()\",\n  async fn() {\n    const context = new Context(\n      createMockApp(),\n      createMockNativeRequest({\n        url: \"http://localhost/\",\n        requestInit: {\n          headers: [\n            [\"upgrade\", \"websocket\"],\n            [\"sec-websocket-key\", \"abc\"],\n            [\"host\", \"localhost\"],\n          ],\n        },\n        upgradeThrow: false,\n      }),\n      {},\n    );\n    assert(context.socket === undefined);\n    const ws = context.upgrade();\n    assert(ws);\n    assertStrictEquals(context.socket, ws);\n    assertStrictEquals(ws, mockWebSocket);\n    assertEquals(context.respond, false);\n    assertEquals(respondWithStack.length, 1);\n    assertStrictEquals(await respondWithStack[0], mockResponse);\n    assertEquals(upgradeWebSocketStack.length, 1);\n    assertEquals((context.app as any).listeners, [\"close\"]);\n  },\n});\n\nDeno.test({\n  name: \"context.upgrade() - not supported\",\n  async fn() {\n    const context = new Context(\n      createMockApp(),\n      createMockNativeRequest({\n        url: \"http://localhost/\",\n        requestInit: {\n          headers: [\n            [\"upgrade\", \"websocket\"],\n            [\"sec-websocket-key\", \"abc\"],\n            [\"host\", \"localhost\"],\n          ],\n        },\n        upgradeUndefined: true,\n      }),\n      {},\n    );\n    assert(context.socket === undefined);\n    assertThrows(\n      () => {\n        context.upgrade();\n      },\n      TypeError,\n      \"Upgrading web sockets not supported.\",\n    );\n    assert(context.socket === undefined);\n    assertEquals(context.respond, true);\n  },\n});\n\nDeno.test({\n  name: \"context.upgrade() failure does not set socket/respond\",\n  async fn() {\n    const context = new Context(createMockApp(), createMockNativeRequest(), {});\n    assert(context.socket === undefined);\n    assertThrows(() => {\n      context.upgrade();\n    });\n    assert(context.socket === undefined);\n    assertEquals(context.respond, true);\n  },\n});\n\nDeno.test({\n  name: \"context.isUpgradable true\",\n  async fn() {\n    const context = new Context(\n      createMockApp(),\n      createMockNativeRequest({\n        url: \"http://localhost/\",\n        requestInit: {\n          headers: [\n            [\"upgrade\", \"websocket\"],\n            [\"sec-websocket-key\", \"abc\"],\n            [\"host\", \"localhost\"],\n          ],\n        },\n      }),\n      {},\n    );\n    assertEquals(context.isUpgradable, true);\n  },\n});\n\nDeno.test({\n  name: \"context.isUpgradable false\",\n  async fn() {\n    const context = new Context(\n      createMockApp(),\n      createMockNativeRequest({\n        url: \"http://localhost/\",\n        requestInit: {\n          headers: [\n            [\"upgrade\", \"websocket\"],\n          ],\n        },\n      }),\n      {},\n    );\n    assertEquals(context.isUpgradable, false);\n  },\n});\n\nDeno.test({\n  name: \"context.sendEvents()\",\n  async fn() {\n    const context = new Context(createMockApp(), createMockNativeRequest(), {});\n    const sse = await context.sendEvents();\n    assertEquals((context.app as any).listeners, [\"close\"]);\n    sse.dispatchComment(`hello world`);\n    await sse.close();\n  },\n});\n\nDeno.test({\n  name: \"context create secure\",\n  fn() {\n    const context = new Context(\n      createMockApp(),\n      createMockNativeRequest(),\n      {},\n      { secure: true },\n    );\n    assertEquals(context.request.secure, true);\n  },\n});\n\nDeno.test({\n  name: \"Context - inspecting\",\n  fn() {\n    const app = createMockApp();\n    const req = createMockNativeRequest();\n    assertEquals(\n      Deno.inspect(new Context(app, req, {}), { depth: 1 }),\n      isNode()\n        ? `Context {\\n  app: [MockApplication],\\n  cookies: [SecureCookieMap],\\n  isUpgradable: false,\\n  respond: true,\\n  request: [Request],\\n  response: [Response],\\n  socket: undefined,\\n  state: {}\\n}`\n        : `Context {\\n  app: MockApplication {},\\n  cookies: SecureCookieMap [],\\n  isUpgradable: false,\\n  respond: true,\\n  request: Request {\\n  body: Body { has: false, used: false },\\n  hasBody: false,\\n  headers: Headers { host: \"localhost\" },\\n  ip: \"\",\\n  ips: [],\\n  method: \"GET\",\\n  secure: false,\\n  url: \"http://localhost/\",\\n  userAgent: UserAgent {\\n  browser: { name: undefined, version: undefined, major: undefined },\\n  cpu: { architecture: undefined },\\n  device: { model: undefined, type: undefined, vendor: undefined },\\n  engine: { name: undefined, version: undefined },\\n  os: { name: undefined, version: undefined },\\n  ua: \"\"\\n}\\n},\\n  response: Response {\\n  body: undefined,\\n  headers: Headers {},\\n  status: 404,\\n  type: undefined,\\n  writable: true\\n},\\n  socket: undefined,\\n  state: {}\\n}`,\n    );\n  },\n});\n"
        },
        {
          "name": "context.ts",
          "type": "blob",
          "size": 10.8388671875,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n/**\n * Contains the {@linkcode Context} class which is the context that is provided\n * to middleware.\n *\n * Typically this is not used directly by end users except when creating\n * re-usable middleware.\n *\n * @module\n */\n\nimport type { Application, State } from \"./application.ts\";\nimport {\n  createHttpError,\n  type ErrorStatus,\n  type HttpErrorOptions,\n  type KeyStack,\n  SecureCookieMap,\n  type ServerSentEventTarget,\n  type ServerSentEventTargetOptions,\n} from \"./deps.ts\";\nimport { Request } from \"./request.ts\";\nimport { Response } from \"./response.ts\";\nimport { send, type SendOptions } from \"./send.ts\";\nimport type { ServerRequest, UpgradeWebSocketOptions } from \"./types.ts\";\n\n/** Options that can be supplied when creating a {@linkcode Context} */\nexport interface ContextOptions<\n  S extends AS = State,\n  // deno-lint-ignore no-explicit-any\n  AS extends State = Record<string, any>,\n> {\n  jsonBodyReplacer?: (\n    key: string,\n    value: unknown,\n    context: Context<S>,\n  ) => unknown;\n  jsonBodyReviver?: (\n    key: string,\n    value: unknown,\n    context: Context<S>,\n  ) => unknown;\n  secure?: boolean;\n}\n\n/** Options that can be supplied when using the `.send()` method. */\nexport interface ContextSendOptions extends SendOptions {\n  /** The filename to send, which will be resolved based on the other options.\n   * If this property is omitted, the current context's `.request.url.pathname`\n   * will be used. */\n  path?: string;\n}\n\n/** Provides context about the current request and response to middleware\n * functions, and the current instance being processed is the first argument\n * provided a {@linkcode Middleware} function.\n *\n * _Typically this is only used as a type annotation and shouldn't be\n * constructed directly._\n *\n * ### Example\n *\n * ```ts\n * import { Application, Context } from \"jsr:@oak/oak/\";\n *\n * const app = new Application();\n *\n * app.use((ctx) => {\n *   // information about the request is here:\n *   ctx.request;\n *   // information about the response is here:\n *   ctx.response;\n *   // the cookie store is here:\n *   ctx.cookies;\n * });\n *\n * // Needs a type annotation because it cannot be inferred.\n * function mw(ctx: Context) {\n *   // process here...\n * }\n *\n * app.use(mw);\n * ```\n *\n * @template S the state which extends the application state (`AS`)\n * @template AS the type of the state derived from the application\n */\nexport class Context<\n  S extends AS = State,\n  // deno-lint-ignore no-explicit-any\n  AS extends State = Record<string, any>,\n> {\n  #socket?: WebSocket;\n  #sse?: ServerSentEventTarget;\n\n  #wrapReviverReplacer(\n    reviver?: (key: string, value: unknown, context: this) => unknown,\n  ): undefined | ((key: string, value: unknown) => unknown) {\n    return reviver\n      ? (key: string, value: unknown) => reviver(key, value, this)\n      : undefined;\n  }\n\n  /** A reference to the current application. */\n  app: Application<AS>;\n\n  /** An object which allows access to cookies, mediating both the request and\n   * response. */\n  cookies: SecureCookieMap;\n\n  /** Is `true` if the current connection is upgradeable to a web socket.\n   * Otherwise the value is `false`.  Use `.upgrade()` to upgrade the connection\n   * and return the web socket. */\n  get isUpgradable(): boolean {\n    const upgrade = this.request.headers.get(\"upgrade\");\n    if (!upgrade || upgrade.toLowerCase() !== \"websocket\") {\n      return false;\n    }\n    const secKey = this.request.headers.get(\"sec-websocket-key\");\n    return typeof secKey === \"string\" && secKey != \"\";\n  }\n\n  /** Determines if the request should be responded to.  If `false` when the\n   * middleware completes processing, the response will not be sent back to the\n   * requestor.  Typically this is used if the middleware will take over low\n   * level processing of requests and responses, for example if using web\n   * sockets.  This automatically gets set to `false` when the context is\n   * upgraded to a web socket via the `.upgrade()` method.\n   *\n   * The default is `true`. */\n  respond: boolean;\n\n  /** An object which contains information about the current request. */\n  request: Request;\n\n  /** An object which contains information about the response that will be sent\n   * when the middleware finishes processing. */\n  response: Response;\n\n  /** If the the current context has been upgraded, then this will be set to\n   * with the current web socket, otherwise it is `undefined`. */\n  get socket(): WebSocket | undefined {\n    return this.#socket;\n  }\n\n  /** The object to pass state to front-end views.  This can be typed by\n   * supplying the generic state argument when creating a new app.  For\n   * example:\n   *\n   * ```ts\n   * const app = new Application<{ foo: string }>();\n   * ```\n   *\n   * Or can be contextually inferred based on setting an initial state object:\n   *\n   * ```ts\n   * const app = new Application({ state: { foo: \"bar\" } });\n   * ```\n   *\n   * On each request/response cycle, the context's state is cloned from the\n   * application state. This means changes to the context's `.state` will be\n   * dropped when the request drops, but \"defaults\" can be applied to the\n   * application's state.  Changes to the application's state though won't be\n   * reflected until the next request in the context's state.\n   */\n  state: S;\n\n  constructor(\n    app: Application<AS>,\n    serverRequest: ServerRequest,\n    state: S,\n    {\n      secure = false,\n      jsonBodyReplacer,\n      jsonBodyReviver,\n    }: ContextOptions<S, AS> = {},\n  ) {\n    this.app = app;\n    this.state = state;\n    const { proxy } = app;\n    this.request = new Request(\n      serverRequest,\n      {\n        proxy,\n        secure,\n        jsonBodyReviver: this.#wrapReviverReplacer(jsonBodyReviver),\n      },\n    );\n    this.respond = true;\n    this.response = new Response(\n      this.request,\n      this.#wrapReviverReplacer(jsonBodyReplacer),\n    );\n    this.cookies = new SecureCookieMap(serverRequest, {\n      keys: this.app.keys as KeyStack | undefined,\n      response: this.response,\n      secure: this.request.secure,\n    });\n  }\n\n  /** Asserts the condition and if the condition fails, creates an HTTP error\n   * with the provided status (which defaults to `500`).  The error status by\n   * default will be set on the `.response.status`.\n   *\n   * Because of limitation of TypeScript, any assertion type function requires\n   * specific type annotations, so the {@linkcode Context} type should be used\n   * even if it can be inferred from the context.\n   *\n   * ### Example\n   *\n   * ```ts\n   * import { Context, Status } from \"jsr:@oak/oak/\";\n   *\n   * export function mw(ctx: Context) {\n   *   const body = ctx.request.body();\n   *   ctx.assert(body.type === \"json\", Status.NotAcceptable);\n   *   // process the body and send a response...\n   * }\n   * ```\n   */\n  assert(\n    condition: unknown,\n    errorStatus: ErrorStatus = 500,\n    message?: string,\n    props?: Record<string, unknown> & Omit<HttpErrorOptions, \"status\">,\n  ): asserts condition {\n    if (condition) {\n      return;\n    }\n    const httpErrorOptions: HttpErrorOptions = {};\n    if (typeof props === \"object\") {\n      if (\"expose\" in props) {\n        httpErrorOptions.expose = props.expose;\n        delete props.expose;\n      }\n    }\n    const err = createHttpError(errorStatus, message, httpErrorOptions);\n    if (props) {\n      Object.assign(err, props);\n    }\n    throw err;\n  }\n\n  /** Asynchronously fulfill a response with a file from the local file\n   * system.\n   *\n   * If the `options.path` is not supplied, the file to be sent will default\n   * to this `.request.url.pathname`.\n   *\n   * Requires Deno read permission. */\n  send(options: ContextSendOptions): Promise<string | undefined> {\n    const { path = this.request.url.pathname, ...sendOptions } = options;\n    return send(this, path, sendOptions);\n  }\n\n  /** Convert the connection to stream events, resolving with an event target\n   * for sending server sent events.  Events dispatched on the returned target\n   * will be sent to the client and be available in the client's `EventSource`\n   * that initiated the connection.\n   *\n   * Invoking this will cause the a response to be sent to the client\n   * immediately to initialize the stream of events, and therefore any further\n   * changes to the response, like headers will not reach the client.\n   */\n  async sendEvents(\n    options?: ServerSentEventTargetOptions,\n  ): Promise<ServerSentEventTarget> {\n    if (!this.#sse) {\n      const sse = this.#sse = await this.request.sendEvents(options, {\n        headers: this.response.headers,\n      });\n      this.app.addEventListener(\"close\", () => sse.close());\n      this.respond = false;\n    }\n    return this.#sse;\n  }\n\n  /** Create and throw an HTTP Error, which can be used to pass status\n   * information which can be caught by other middleware to send more\n   * meaningful error messages back to the client.  The passed error status will\n   * be set on the `.response.status` by default as well.\n   */\n  throw(\n    errorStatus: ErrorStatus,\n    message?: string,\n    props?: Record<string, unknown>,\n  ): never {\n    const err = createHttpError(errorStatus, message);\n    if (props) {\n      Object.assign(err, props);\n    }\n    throw err;\n  }\n\n  /** Take the current request and upgrade it to a web socket, resolving with\n   * the a web standard `WebSocket` object. This will set `.respond` to\n   * `false`.  If the socket cannot be upgraded, this method will throw. */\n  upgrade(options?: UpgradeWebSocketOptions): WebSocket {\n    if (!this.#socket) {\n      const socket = this.#socket = this.request.upgrade(options);\n      this.app.addEventListener(\"close\", () => socket.close());\n      this.respond = false;\n    }\n    return this.#socket;\n  }\n\n  [Symbol.for(\"Deno.customInspect\")](\n    inspect: (value: unknown) => string,\n  ): string {\n    const {\n      app,\n      cookies,\n      isUpgradable,\n      respond,\n      request,\n      response,\n      socket,\n      state,\n    } = this;\n    return `${this.constructor.name} ${\n      inspect({\n        app,\n        cookies,\n        isUpgradable,\n        respond,\n        request,\n        response,\n        socket,\n        state,\n      })\n    }`;\n  }\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")](\n    depth: number,\n    // deno-lint-ignore no-explicit-any\n    options: any,\n    inspect: (value: unknown, options?: unknown) => string,\n    // deno-lint-ignore no-explicit-any\n  ): any {\n    if (depth < 0) {\n      return options.stylize(`[${this.constructor.name}]`, \"special\");\n    }\n\n    const newOptions = Object.assign({}, options, {\n      depth: options.depth === null ? null : options.depth - 1,\n    });\n    const {\n      app,\n      cookies,\n      isUpgradable,\n      respond,\n      request,\n      response,\n      socket,\n      state,\n    } = this;\n    return `${options.stylize(this.constructor.name, \"special\")} ${\n      inspect({\n        app,\n        cookies,\n        isUpgradable,\n        respond,\n        request,\n        response,\n        socket,\n        state,\n      }, newOptions)\n    }`;\n  }\n}\n"
        },
        {
          "name": "deno.json",
          "type": "blob",
          "size": 1.267578125,
          "content": "{\n  \"name\": \"@oak/oak\",\n  \"version\": \"17.1.4\",\n  \"exports\": {\n    \".\": \"./mod.ts\",\n    \"./application\": \"./application.ts\",\n    \"./body\": \"./body.ts\",\n    \"./context\": \"./context.ts\",\n    \"./etag\": \"./middleware/etag.ts\",\n    \"./http_server_bun\": \"./http_server_bun.ts\",\n    \"./http_server_native\": \"./http_server_native.ts\",\n    \"./http_server_node\": \"./http_server_node.ts\",\n    \"./middleware\": \"./middleware.ts\",\n    \"./proxy\": \"./middleware/proxy.ts\",\n    \"./request\": \"./request.ts\",\n    \"./response\": \"./response.ts\",\n    \"./router\": \"./router.ts\",\n    \"./send\": \"./send.ts\",\n    \"./serve\": \"./middleware/serve.ts\",\n    \"./testing\": \"./testing.ts\"\n  },\n  \"publish\": {\n    \"exclude\": [\n      \".devcontainer\",\n      \".github\",\n      \".vscode\",\n      \"examples\",\n      \"fixtures\",\n      \"docs\",\n      \"**/*.test.ts\",\n      \"test_deps.ts\"\n    ]\n  },\n  \"tasks\": {\n    \"coverage\": \"deno coverage --lcov ./cov\",\n    \"example\": \"deno run --allow-net examples/echoServer.ts\",\n    \"test\": \"deno test --allow-read --allow-write --allow-net --parallel --ignore=npm\",\n    \"test:coverage\": \"deno test --coverage=./cov --junit-path=junit.xml --allow-read --allow-write --allow-net --cert ./examples/tls/RootCA.crt --parallel --ignore=npm\"\n  },\n  \"fmt\": {\n    \"exclude\": [\"README.md\"]\n  },\n  \"lock\": false\n}\n"
        },
        {
          "name": "deps.ts",
          "type": "blob",
          "size": 1.94140625,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n// This file contains the external dependencies that oak depends upon\n\n// jsr dependencies\n\nexport { assert } from \"jsr:@std/assert@^1.0/assert\";\nexport { concat } from \"jsr:@std/bytes@^1.0/concat\";\nexport {\n  eTag,\n  type ETagOptions,\n  type FileInfo,\n  ifNoneMatch,\n} from \"jsr:@std/http@^1.0/etag\";\nexport {\n  accepts,\n  acceptsEncodings,\n  acceptsLanguages,\n} from \"jsr:@std/http@^1.0/negotiation\";\nexport { UserAgent } from \"jsr:@std/http@^1.0/user-agent\";\nexport { contentType } from \"jsr:@std/media-types@^1.0/content-type\";\nexport {\n  basename,\n  extname,\n  isAbsolute,\n  join,\n  normalize,\n  parse,\n  SEPARATOR,\n} from \"jsr:@std/path@^1.0/\";\n\n// 3rd party dependencies\n\nexport {\n  SecureCookieMap,\n  type SecureCookieMapGetOptions,\n  type SecureCookieMapSetDeleteOptions,\n} from \"jsr:@oak/commons@^1.0/cookie_map\";\nexport { parse as parseFormData } from \"jsr:@oak/commons@^1.0/form_data\";\nexport { parse as parseForwarded } from \"jsr:@oak/commons@^1.0/forwarded\";\nexport {\n  createHttpError,\n  errors,\n  HttpError,\n  type HttpErrorOptions,\n  isHttpError,\n} from \"jsr:@oak/commons@^1.0/http_errors\";\nexport { KeyStack } from \"jsr:@oak/commons@^1.0/keystack\";\nexport { matches } from \"jsr:@oak/commons@^1.0/media_types\";\nexport { type HttpMethod as HTTPMethods } from \"jsr:@oak/commons@^1.0/method\";\nexport {\n  type ByteRange,\n  range,\n  responseRange,\n} from \"jsr:@oak/commons@^1.0/range\";\nexport {\n  ServerSentEvent,\n  type ServerSentEventInit,\n  ServerSentEventStreamTarget,\n  type ServerSentEventTarget,\n  type ServerSentEventTargetOptions,\n} from \"jsr:@oak/commons@^1.0/server_sent_event\";\nexport {\n  type ErrorStatus,\n  isErrorStatus,\n  isRedirectStatus,\n  type RedirectStatus,\n  Status,\n  STATUS_TEXT,\n} from \"jsr:@oak/commons@^1.0/status\";\n\nexport {\n  compile,\n  type Key,\n  parse as pathParse,\n  type ParseOptions,\n  pathToRegexp,\n  type TokensToRegexpOptions,\n} from \"npm:path-to-regexp@^6.3.0\";\n"
        },
        {
          "name": "deps_test.ts",
          "type": "blob",
          "size": 0.5244140625,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\nexport { assertEquals } from \"jsr:@std/assert@^1.0/equals\";\nexport { assertInstanceOf } from \"jsr:@std/assert@^1.0/instance-of\";\nexport { assertRejects } from \"jsr:@std/assert@^1.0/rejects\";\nexport { assertStrictEquals } from \"jsr:@std/assert@^1.0/strict-equals\";\nexport { assertThrows } from \"jsr:@std/assert@^1.0/throws\";\nexport { unreachable } from \"jsr:@std/assert@^1.0/unreachable\";\nexport { timingSafeEqual } from \"jsr:@std/crypto@^1.0/timing-safe-equal\";\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fixtures",
          "type": "tree",
          "content": null
        },
        {
          "name": "http_server_bun.test.ts",
          "type": "blob",
          "size": 3.9833984375,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n// deno-lint-ignore-file no-explicit-any\n\nimport { assert } from \"./deps.ts\";\nimport { assertEquals } from \"./deps_test.ts\";\nimport { createMockApp } from \"./testing.ts\";\n\nimport { Server } from \"./http_server_bun.ts\";\n\ninterface SocketAddress {\n  address: string;\n  port: number;\n  family: \"IPv4\" | \"IPv6\";\n}\n\nlet currentServer: MockBunServer | undefined;\nlet requests: Request[] = [];\n\nclass MockBunServer {\n  stoppedCount = 0;\n  fetch: (\n    req: Request,\n    server: this,\n  ) => Response | Promise<Response>;\n  responses: Response[] = [];\n  runPromise: Promise<void>;\n\n  development: boolean;\n  hostname: string;\n  port: number;\n  pendingRequests = 0;\n\n  async #run() {\n    for (const req of requests) {\n      const res = await this.fetch(req, this);\n      this.responses.push(res);\n    }\n  }\n\n  constructor(\n    { fetch, hostname, port, development }: {\n      fetch: (\n        req: Request,\n        server: unknown,\n      ) => Response | Promise<Response>;\n      hostname?: string;\n      port?: number;\n      development?: boolean;\n      error?: (error: Error) => Response | Promise<Response>;\n      tls?: {\n        key?: string;\n        cert?: string;\n      };\n    },\n  ) {\n    this.fetch = fetch;\n    this.development = development ?? false;\n    this.hostname = hostname ?? \"localhost\";\n    this.port = port ?? 567890;\n    currentServer = this;\n    this.runPromise = this.#run();\n  }\n\n  requestIP(_req: Request): SocketAddress | null {\n    return { address: \"127.0.0.0\", port: 567890, family: \"IPv4\" };\n  }\n\n  stop(): void {\n    this.stoppedCount++;\n  }\n}\n\nfunction setup(reqs?: Request[]) {\n  if (reqs) {\n    requests = reqs;\n  }\n  (globalThis as any)[\"Bun\"] = {\n    serve(options: any) {\n      return new MockBunServer(options);\n    },\n  };\n}\n\nfunction teardown() {\n  delete (globalThis as any)[\"Bun\"];\n  currentServer = undefined;\n}\n\nDeno.test({\n  name: \"bun server can listen\",\n  async fn() {\n    setup();\n    const server = new Server(createMockApp(), { port: 8080 });\n    const listener = await server.listen();\n    assertEquals(listener, { addr: { hostname: \"localhost\", port: 8080 } });\n    assert(currentServer);\n    assertEquals(currentServer.stoppedCount, 0);\n    await server.close();\n    assertEquals(currentServer.stoppedCount, 1);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"bun server can process requests\",\n  // this is working but there is some sort of hanging promise somewhere I can't\n  // narrow down at the moment\n  ignore: true,\n  async fn() {\n    setup([new Request(new URL(\"http://localhost:8080/\"))]);\n    const server = new Server(createMockApp(), { port: 8080 });\n    const listener = await server.listen();\n    assertEquals(listener, { addr: { hostname: \"localhost\", port: 8080 } });\n    assert(currentServer);\n    for await (const req of server) {\n      assert(!req.body);\n      assertEquals(req.url, \"/\");\n      await req.respond(new Response(\"hello world\"));\n    }\n    await server.close();\n    await currentServer.runPromise;\n    assertEquals(currentServer.stoppedCount, 1);\n    assertEquals(currentServer.responses.length, 1);\n    teardown();\n  },\n});\n\nDeno.test({\n  name: \"bun server closes on abort signal\",\n  // this is working but there is some sort of hanging promise somewhere I can't\n  // narrow down at the moment\n  ignore: true,\n  async fn() {\n    setup([new Request(new URL(\"http://localhost:8080/\"))]);\n    const controller = new AbortController();\n    const { signal } = controller;\n    const server = new Server(createMockApp(), { port: 8080, signal });\n    const listener = await server.listen();\n    assertEquals(listener, { addr: { hostname: \"localhost\", port: 8080 } });\n    assert(currentServer);\n    for await (const req of server) {\n      assert(!req.body);\n      assertEquals(req.url, \"/\");\n      await req.respond(new Response(\"hello world\"));\n    }\n    controller.abort();\n    await currentServer.runPromise;\n    assertEquals(currentServer.stoppedCount, 1);\n    assertEquals(currentServer.responses.length, 1);\n    teardown();\n  },\n});\n"
        },
        {
          "name": "http_server_bun.ts",
          "type": "blob",
          "size": 5.5791015625,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n/** The abstraction that oak uses when dealing with requests and responses\n * within the Bun runtime that leverages the built in HTTP server.\n *\n * @module\n */\n\nimport type { Application } from \"./application.ts\";\nimport type {\n  Listener,\n  OakServer,\n  ServeOptions,\n  ServerRequest,\n  ServeTlsOptions,\n} from \"./types.ts\";\nimport { createPromiseWithResolvers } from \"./utils/create_promise_with_resolvers.ts\";\n\ntype TypedArray =\n  | Uint8Array\n  | Uint16Array\n  | Uint32Array\n  | Int8Array\n  | Int16Array\n  | Int32Array\n  | Float32Array\n  | Float64Array\n  | BigInt64Array\n  | BigUint64Array\n  | Uint8ClampedArray;\ntype BunFile = File;\n\ninterface Bun {\n  serve(options: {\n    fetch: (req: Request, server: BunServer) => Response | Promise<Response>;\n    hostname?: string;\n    port?: number;\n    development?: boolean;\n    error?: (error: Error) => Response | Promise<Response>;\n    tls?: {\n      key?:\n        | string\n        | TypedArray\n        | BunFile\n        | Array<string | TypedArray | BunFile>;\n      cert?:\n        | string\n        | TypedArray\n        | BunFile\n        | Array<string | TypedArray | BunFile>;\n      ca?: string | TypedArray | BunFile | Array<string | TypedArray | BunFile>;\n      passphrase?: string;\n      dhParamsFile?: string;\n    };\n    maxRequestBodySize?: number;\n    lowMemoryMode?: boolean;\n  }): BunServer;\n}\n\ninterface BunServer {\n  development: boolean;\n  hostname: string;\n  port: number;\n  pendingRequests: number;\n  requestIP(req: Request): SocketAddress | null;\n  stop(): void;\n  upgrade(req: Request, options?: {\n    headers?: HeadersInit;\n    //deno-lint-ignore no-explicit-any\n    data?: any;\n  }): boolean;\n}\n\ninterface SocketAddress {\n  address: string;\n  port: number;\n  family: \"IPv4\" | \"IPv6\";\n}\n\ndeclare const Bun: Bun;\n\nfunction isServeTlsOptions(\n  value: Omit<ServeOptions | ServeTlsOptions, \"signal\">,\n): value is Omit<ServeTlsOptions, \"signal\"> {\n  return !!(\"cert\" in value && \"key\" in value);\n}\n\nclass BunRequest implements ServerRequest {\n  #hostname: string | undefined;\n  // deno-lint-ignore no-explicit-any\n  #reject: (reason?: any) => void;\n  #request: Request;\n  #resolve: (value: Response) => void;\n  #resolved = false;\n  #promise: Promise<Response>;\n\n  get body(): ReadableStream<Uint8Array> | null {\n    return this.#request.body;\n  }\n\n  get headers(): Headers {\n    return this.#request.headers;\n  }\n\n  get method(): string {\n    return this.#request.method;\n  }\n\n  get remoteAddr(): string | undefined {\n    return this.#hostname;\n  }\n\n  get request(): Request {\n    return this.#request;\n  }\n\n  get response(): Promise<Response> {\n    return this.#promise;\n  }\n\n  get url(): string {\n    try {\n      const url = new URL(this.#request.url);\n      return this.#request.url.replace(url.origin, \"\");\n    } catch {\n      // we don't care about errors, we just want to fall back\n    }\n    return this.#request.url;\n  }\n\n  get rawUrl(): string {\n    return this.#request.url;\n  }\n\n  constructor(request: Request, server: BunServer) {\n    this.#request = request;\n    this.#hostname = server.requestIP(request)?.address;\n    const { resolve, reject, promise } = createPromiseWithResolvers<Response>();\n    this.#resolve = resolve;\n    this.#reject = reject;\n    this.#promise = promise;\n  }\n\n  // deno-lint-ignore no-explicit-any\n  error(reason?: any): void {\n    if (this.#resolved) {\n      throw new Error(\"Request already responded to.\");\n    }\n    this.#resolved = true;\n    this.#reject(reason);\n  }\n\n  getBody(): ReadableStream<Uint8Array> | null {\n    return this.#request.body;\n  }\n\n  respond(response: Response): void | Promise<void> {\n    if (this.#resolved) {\n      throw new Error(\"Request already responded to.\");\n    }\n    this.#resolved = true;\n    this.#resolve(response);\n  }\n}\n\n/** An implementation of the oak server abstraction for handling requests on\n * Bun using the built in Bun http server. */\nexport class Server implements OakServer<BunRequest> {\n  #options: ServeOptions | ServeTlsOptions;\n  #server?: BunServer;\n  #stream?: ReadableStream<BunRequest>;\n\n  constructor(\n    _app: Application,\n    options: ServeOptions | ServeTlsOptions,\n  ) {\n    this.#options = options;\n  }\n\n  close(): void | Promise<void> {\n    if (this.#server) {\n      this.#server.stop();\n    }\n  }\n\n  listen(): Listener | Promise<Listener> {\n    if (this.#server) {\n      throw new Error(\"Server already listening.\");\n    }\n    const { onListen, hostname, port, signal } = this.#options;\n    const tls = isServeTlsOptions(this.#options)\n      ? { key: this.#options.key, cert: this.#options.cert }\n      : undefined;\n    const { promise, resolve } = createPromiseWithResolvers<Listener>();\n    this.#stream = new ReadableStream<BunRequest>({\n      start: (controller) => {\n        this.#server = Bun.serve({\n          fetch(req, server) {\n            const request = new BunRequest(req, server);\n            controller.enqueue(request);\n            return request.response;\n          },\n          hostname,\n          port,\n          tls,\n        });\n        signal?.addEventListener(\"abort\", () => {\n          controller.close();\n          this.close();\n        }, { once: true });\n        {\n          const { hostname, port } = this.#server;\n          if (onListen) {\n            onListen({ hostname, port });\n          }\n          resolve({ addr: { hostname, port } });\n        }\n      },\n    });\n    return promise;\n  }\n\n  [Symbol.asyncIterator](): AsyncIterableIterator<BunRequest> {\n    if (!this.#stream) {\n      throw new TypeError(\"Server hasn't started listening.\");\n    }\n    return this.#stream[Symbol.asyncIterator]();\n  }\n\n  static type: \"bun\" = \"bun\";\n}\n"
        },
        {
          "name": "http_server_native.test.ts",
          "type": "blob",
          "size": 2.4794921875,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\nimport { assertEquals, assertStrictEquals, unreachable } from \"./deps_test.ts\";\n\nimport { Server } from \"./http_server_native.ts\";\nimport { NativeRequest } from \"./http_server_native_request.ts\";\n\nimport { Application } from \"./application.ts\";\nimport { isNode } from \"./utils/type_guards.ts\";\n\nfunction createMockNetAddr(): Deno.NetAddr {\n  return { transport: \"tcp\", hostname: \"remote\", port: 4567 };\n}\n\nDeno.test({\n  name: \"NativeRequest\",\n  ignore: isNode(),\n  async fn() {\n    const respondWithStack: Array<Response | Promise<Response>> = [];\n    const request = new Request(\"http://localhost:8000/\", {\n      method: \"POST\",\n      body: `{\"a\":\"b\"}`,\n    });\n    const remoteAddr = createMockNetAddr();\n    const nativeRequest = new NativeRequest(request, { remoteAddr });\n    assertEquals(nativeRequest.url, `/`);\n    const response = new Response(\"hello deno\");\n    nativeRequest.respond(response);\n    respondWithStack.push(await nativeRequest.response);\n    assertStrictEquals(await respondWithStack[0], response);\n  },\n});\n\nDeno.test({\n  name: \"HttpServer closes gracefully after serving requests\",\n  ignore: isNode(),\n  async fn() {\n    const abortController = new AbortController();\n    const app = new Application();\n    const listenOptions = { port: 4505, signal: abortController.signal };\n\n    const server = new Server(app, listenOptions);\n    server.listen();\n\n    const expectedBody = \"test-body\";\n\n    (async () => {\n      for await (const nativeRequest of server) {\n        nativeRequest.respond(new Response(expectedBody));\n      }\n    })();\n\n    try {\n      const response = await fetch(`http://localhost:${listenOptions.port}`);\n      assertEquals(await response.text(), expectedBody);\n    } catch (e) {\n      console.error(e);\n      unreachable();\n    } finally {\n      abortController.abort();\n    }\n  },\n});\n\nDeno.test({\n  name:\n    \"HttpServer manages errors from mis-use in the application handler gracefully\",\n  ignore: isNode(),\n  async fn() {\n    const app = new Application();\n    const listenOptions = { port: 4506 };\n\n    const server = new Server(app, listenOptions);\n    server.listen();\n\n    (async () => {\n      for await (const nativeRequest of server) {\n        // deno-lint-ignore no-explicit-any\n        nativeRequest.respond(null as any);\n      }\n    })();\n\n    const res = await fetch(`http://localhost:${listenOptions.port}`);\n    assertEquals(res.status, 500);\n    await res.text();\n    return server.close();\n  },\n});\n"
        },
        {
          "name": "http_server_native.ts",
          "type": "blob",
          "size": 3.0458984375,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n/** The abstraction that oak uses when dealing with requests and responses\n * within the Deno runtime.\n *\n * @module\n */\n\nimport type { Application, State } from \"./application.ts\";\nimport { NativeRequest } from \"./http_server_native_request.ts\";\nimport type {\n  HttpServer,\n  Listener,\n  OakServer,\n  ServeInit,\n  ServeOptions,\n  ServeTlsOptions,\n} from \"./types.ts\";\nimport { createPromiseWithResolvers } from \"./utils/create_promise_with_resolvers.ts\";\n\nconst serve:\n  | ((\n    options: ServeInit & (ServeOptions | ServeTlsOptions),\n  ) => HttpServer)\n  | undefined = \"Deno\" in globalThis && \"serve\" in globalThis.Deno\n    ? globalThis.Deno.serve.bind(globalThis.Deno)\n    : undefined;\n\n/** The oak abstraction of the Deno native HTTP server which is used internally\n * for handling native HTTP requests. Generally users of oak do not need to\n * worry about this class. */\n// deno-lint-ignore no-explicit-any\nexport class Server<AS extends State = Record<string, any>>\n  implements OakServer<NativeRequest> {\n  #app: Application<AS>;\n  #closed = false;\n  #httpServer?: HttpServer;\n  #options: ServeOptions | ServeTlsOptions;\n  #stream?: ReadableStream<NativeRequest>;\n\n  constructor(\n    app: Application<AS>,\n    options: Omit<ServeOptions | ServeTlsOptions, \"signal\">,\n  ) {\n    if (!serve) {\n      throw new Error(\n        \"The native bindings for serving HTTP are not available.\",\n      );\n    }\n    this.#app = app;\n    this.#options = options;\n  }\n\n  get app(): Application<AS> {\n    return this.#app;\n  }\n\n  get closed(): boolean {\n    return this.#closed;\n  }\n\n  async close(): Promise<void> {\n    if (this.#closed) {\n      return;\n    }\n\n    if (this.#httpServer) {\n      this.#httpServer.unref();\n      await this.#httpServer.shutdown();\n      this.#httpServer = undefined;\n    }\n    this.#closed = true;\n  }\n\n  listen(): Promise<Listener> {\n    if (this.#httpServer) {\n      throw new Error(\"Server already listening.\");\n    }\n    const { signal } = this.#options;\n    const { onListen, ...options } = this.#options;\n    const { promise, resolve } = createPromiseWithResolvers<Listener>();\n    this.#stream = new ReadableStream<NativeRequest>({\n      start: (controller) => {\n        this.#httpServer = serve?.({\n          handler: (req, info) => {\n            const nativeRequest = new NativeRequest(req, info);\n            controller.enqueue(nativeRequest);\n            return nativeRequest.response;\n          },\n          onListen({ hostname, port }) {\n            if (onListen) {\n              onListen({ hostname, port });\n            }\n            resolve({ addr: { hostname, port } });\n          },\n          signal,\n          ...options,\n        });\n      },\n    });\n\n    signal?.addEventListener(\"abort\", () => this.close(), { once: true });\n    return promise;\n  }\n\n  [Symbol.asyncIterator](): AsyncIterableIterator<NativeRequest> {\n    if (!this.#stream) {\n      throw new TypeError(\"Server hasn't started listening.\");\n    }\n    return this.#stream[Symbol.asyncIterator]();\n  }\n\n  static type: \"native\" = \"native\";\n}\n"
        },
        {
          "name": "http_server_native_request.ts",
          "type": "blob",
          "size": 3.3916015625,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\nimport type {\n  NetAddr,\n  ServerRequest,\n  UpgradeWebSocketFn,\n  UpgradeWebSocketOptions,\n} from \"./types.ts\";\nimport { createPromiseWithResolvers } from \"./utils/create_promise_with_resolvers.ts\";\n\n// deno-lint-ignore no-explicit-any\nexport const DomResponse: typeof Response = (globalThis as any).Response ??\n  class MockResponse {};\n\nconst maybeUpgradeWebSocket: UpgradeWebSocketFn | undefined =\n  \"Deno\" in globalThis && \"upgradeWebSocket\" in globalThis.Deno\n    // deno-lint-ignore no-explicit-any\n    ? (Deno as any).upgradeWebSocket.bind(Deno)\n    : undefined;\n\nexport function isNativeRequest(r: ServerRequest): r is NativeRequest {\n  return r instanceof NativeRequest;\n}\n\nexport interface NativeRequestInfo {\n  remoteAddr?: NetAddr;\n  upgradeWebSocket?: UpgradeWebSocketFn;\n}\n\n/** An internal oak abstraction for handling a Deno native request. Most users\n * of oak do not need to worry about this abstraction. */\nexport class NativeRequest implements ServerRequest {\n  #remoteAddr?: NetAddr;\n  // deno-lint-ignore no-explicit-any\n  #reject: (reason?: any) => void;\n  #request: Request;\n  #resolve: (value: Response) => void;\n  #resolved = false;\n  #response: Promise<Response>;\n  #upgradeWebSocket?: UpgradeWebSocketFn;\n\n  constructor(\n    request: Request,\n    info: NativeRequestInfo,\n  ) {\n    this.#remoteAddr = info.remoteAddr;\n    // this allows for the value to be explicitly undefined in the options\n    this.#upgradeWebSocket = \"upgradeWebSocket\" in info\n      ? info.upgradeWebSocket\n      : maybeUpgradeWebSocket;\n    this.#request = request;\n    const { resolve, reject, promise } = createPromiseWithResolvers<Response>();\n    this.#resolve = resolve;\n    this.#reject = reject;\n    this.#response = promise;\n  }\n\n  get body(): ReadableStream<Uint8Array> | null {\n    return this.#request.body;\n  }\n\n  get headers(): Headers {\n    return this.#request.headers;\n  }\n\n  get method(): string {\n    return this.#request.method;\n  }\n\n  get remoteAddr(): string | undefined {\n    return this.#remoteAddr?.hostname;\n  }\n\n  get request(): Request {\n    return this.#request;\n  }\n\n  get response(): Promise<Response> {\n    return this.#response;\n  }\n\n  get url(): string {\n    try {\n      const url = new URL(this.#request.url);\n      return this.#request.url.replace(url.origin, \"\");\n    } catch {\n      // we don't care about errors, we just want to fall back\n    }\n    return this.#request.url;\n  }\n\n  get rawUrl(): string {\n    return this.#request.url;\n  }\n\n  // deno-lint-ignore no-explicit-any\n  error(reason?: any): void {\n    if (this.#resolved) {\n      throw new Error(\"Request already responded to.\");\n    }\n    this.#reject(reason);\n    this.#resolved = true;\n  }\n\n  getBody(): ReadableStream<Uint8Array> | null {\n    return this.#request.body;\n  }\n\n  respond(response: Response): void {\n    if (this.#resolved) {\n      throw new Error(\"Request already responded to.\");\n    }\n    this.#resolved = true;\n    this.#resolve(response);\n  }\n\n  upgrade(options?: UpgradeWebSocketOptions): WebSocket {\n    if (this.#resolved) {\n      throw new Error(\"Request already responded to.\");\n    }\n    if (!this.#upgradeWebSocket) {\n      throw new TypeError(\"Upgrading web sockets not supported.\");\n    }\n    const { response, socket } = this.#upgradeWebSocket(\n      this.#request,\n      options,\n    );\n    this.#resolve(response);\n    this.#resolved = true;\n    return socket;\n  }\n}\n"
        },
        {
          "name": "http_server_node.test.ts",
          "type": "blob",
          "size": 2.5595703125,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n// deno-lint-ignore-file no-explicit-any\n\nimport { assertEquals, unreachable } from \"./deps_test.ts\";\n\nimport {\n  type IncomingMessage,\n  NodeRequest,\n  Server,\n  type ServerResponse,\n} from \"./http_server_node.ts\";\n\nimport { Application } from \"./application.ts\";\n\nconst destroyCalls: any[][] = [];\nconst setHeaderCalls: any[][] = [];\nconst writeCalls: any[][] = [];\nconst writeHeadCalls: any[][] = [];\n\nfunction createMockReqRes(\n  url = \"/\",\n  headers: Record<string, string> = {},\n  method = \"GET\",\n  address = \"127.0.0.1\",\n): [req: IncomingMessage, res: ServerResponse] {\n  destroyCalls.length = 0;\n  setHeaderCalls.length = 0;\n  writeCalls.length = 0;\n  writeHeadCalls.length = 0;\n  const req = {\n    headers,\n    method,\n    socket: {\n      address() {\n        return {\n          addr: {\n            address,\n          },\n        };\n      },\n    },\n    url,\n    on(_method: string, _listener: (arg?: any) => void) {},\n  };\n  const res = {\n    destroy(...args: any[]) {\n      destroyCalls.push(args);\n    },\n    end(callback?: () => void) {\n      if (callback) {\n        callback();\n      }\n    },\n    setHeader(...args: any[]) {\n      setHeaderCalls.push(args);\n    },\n    write(chunk: unknown, callback?: (err: Error | null) => void) {\n      writeCalls.push([chunk, callback]);\n      if (callback) {\n        callback(null);\n      }\n    },\n    writeHead(...args: any[]) {\n      writeHeadCalls.push(args);\n    },\n  };\n  return [req, res];\n}\n\nDeno.test({\n  name: \"NodeRequest\",\n  async fn() {\n    const nodeRequest = new NodeRequest(\n      ...createMockReqRes(\"/\", {}, \"POST\", \"127.0.0.1\"),\n    );\n    assertEquals(nodeRequest.url, `/`);\n    const response = new Response(\"hello deno\");\n    await nodeRequest.respond(response);\n    assertEquals(writeHeadCalls, [[200, \"\"]]);\n  },\n});\n\nDeno.test({\n  name: \"HttpServer closes gracefully after serving requests\",\n  // TODO(@kitsonk) this is failing locally for me, figure out what is wrong.\n  ignore: true,\n  async fn() {\n    const app = new Application();\n    const listenOptions = { port: 4508 };\n\n    const server = new Server(app, listenOptions);\n    await server.listen();\n\n    const expectedBody = \"test-body\";\n\n    (async () => {\n      for await (const nodeRequest of server) {\n        nodeRequest.respond(new Response(expectedBody));\n      }\n    })();\n\n    try {\n      const response = await fetch(`http://localhost:${listenOptions.port}`);\n      assertEquals(await response.text(), expectedBody);\n    } catch {\n      unreachable();\n    } finally {\n      server.close();\n    }\n  },\n});\n"
        },
        {
          "name": "http_server_node.ts",
          "type": "blob",
          "size": 5.400390625,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n/** The abstraction that oak uses when dealing with requests and responses\n * within the Node.js runtime.\n *\n * @module\n */\n\nimport type {\n  Listener,\n  OakServer,\n  ServeOptions,\n  ServerRequest,\n  ServeTlsOptions,\n} from \"./types.ts\";\nimport { createPromiseWithResolvers } from \"./utils/create_promise_with_resolvers.ts\";\n\n// There are quite a few differences between Deno's `std/node/http` and the\n// typings for Node.js for `\"http\"`. Since we develop everything in Deno, but\n// type check in Deno and Node.js we have to provide the API surface we depend\n// on here, instead of accepting what comes in via the import.\nexport type IncomingMessage = {\n  headers: Record<string, string>;\n  method: string | null;\n  socket: {\n    address(): {\n      addr: null | {\n        address: string;\n      };\n    };\n  };\n  url: string | null;\n\n  on(method: \"data\", listener: (chunk: Uint8Array) => void): void;\n  on(method: \"error\", listener: (err: Error) => void): void;\n  on(method: \"end\", listener: () => void): void;\n};\ntype NodeHttpServer = {\n  listen(options: { port: number; host: string; signal: AbortSignal }): void;\n};\nexport type ServerResponse = {\n  destroy(error?: Error): void;\n  end(callback?: () => void): void;\n  setHeader(key: string, value: string): void;\n  write(chunk: unknown, callback?: (err: Error | null) => void): void;\n  writeHead(status: number, statusText?: string): void;\n};\n\nexport class NodeRequest implements ServerRequest {\n  #request: IncomingMessage;\n  #response: ServerResponse;\n  #responded = false;\n\n  get remoteAddr(): string | undefined {\n    const addr = this.#request.socket.address();\n    // deno-lint-ignore no-explicit-any\n    return addr && (addr as any)?.address;\n  }\n\n  get headers(): Headers {\n    return new Headers(this.#request.headers as Record<string, string>);\n  }\n\n  get method(): string {\n    return this.#request.method ?? \"GET\";\n  }\n\n  get url(): string {\n    return this.#request.url ?? \"\";\n  }\n\n  constructor(\n    request: IncomingMessage,\n    response: ServerResponse,\n  ) {\n    this.#request = request;\n    this.#response = response;\n  }\n\n  // deno-lint-ignore no-explicit-any\n  error(reason?: any) {\n    if (this.#responded) {\n      throw new Error(\"Request already responded to.\");\n    }\n    let error;\n    if (reason) {\n      error = reason instanceof Error ? reason : new Error(String(reason));\n    }\n    this.#response.destroy(error);\n    this.#responded = true;\n  }\n\n  getBody(): ReadableStream<Uint8Array> | null {\n    let body: ReadableStream<Uint8Array> | null;\n    if (this.method === \"GET\" || this.method === \"HEAD\") {\n      body = null;\n    } else {\n      body = new ReadableStream<Uint8Array>({\n        start: (controller) => {\n          this.#request.on(\"data\", (chunk: Uint8Array) => {\n            controller.enqueue(chunk);\n          });\n          this.#request.on(\"error\", (err: Error) => {\n            controller.error(err);\n          });\n          this.#request.on(\"end\", () => {\n            controller.close();\n          });\n        },\n      });\n    }\n    return body;\n  }\n\n  async respond(response: Response) {\n    if (this.#responded) {\n      throw new Error(\"Requested already responded to.\");\n    }\n    for (const [key, value] of response.headers) {\n      this.#response.setHeader(key, value);\n    }\n    this.#response.writeHead(response.status, response.statusText);\n    if (response.body) {\n      for await (const chunk of response.body) {\n        const { promise, resolve, reject } = createPromiseWithResolvers<void>();\n        // deno-lint-ignore no-explicit-any\n        this.#response.write(chunk, (err: any) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n        await promise;\n      }\n    }\n    const { promise, resolve } = createPromiseWithResolvers<void>();\n    this.#response.end(resolve);\n    await promise;\n    this.#responded = true;\n  }\n}\n\nexport class Server implements OakServer<NodeRequest> {\n  #abortController = new AbortController();\n  #host: string;\n  #port: number;\n  #requestStream: ReadableStream<NodeRequest> | undefined;\n\n  constructor(\n    _app: unknown,\n    options: ServeOptions | ServeTlsOptions,\n  ) {\n    this.#host = options.hostname ?? \"127.0.0.1\";\n    this.#port = options.port ?? 80;\n    options.signal?.addEventListener(\"abort\", () => {\n      this.close();\n    }, { once: true });\n  }\n\n  close(): void {\n    this.#abortController.abort();\n  }\n\n  async listen(): Promise<Listener> {\n    const { createServer } = await import(\"node:http\");\n    let server: NodeHttpServer;\n    this.#requestStream = new ReadableStream({\n      start: (controller) => {\n        server = createServer((req, res) => {\n          // deno-lint-ignore no-explicit-any\n          controller.enqueue(new NodeRequest(req as any, res as any));\n        });\n        this.#abortController.signal.addEventListener(\n          \"abort\",\n          () => controller.close(),\n          { once: true },\n        );\n      },\n    });\n    server!.listen({\n      port: this.#port,\n      host: this.#host,\n      signal: this.#abortController.signal,\n    });\n    return {\n      addr: {\n        port: this.#port,\n        hostname: this.#host,\n      },\n    };\n  }\n\n  [Symbol.asyncIterator](): AsyncIterableIterator<NodeRequest> {\n    if (!this.#requestStream) {\n      throw new TypeError(\"stream not properly initialized\");\n    }\n    return this.#requestStream[Symbol.asyncIterator]();\n  }\n\n  static type: \"node\" = \"node\";\n}\n"
        },
        {
          "name": "middleware.test.ts",
          "type": "blob",
          "size": 3.236328125,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n// deno-lint-ignore-file\n\nimport { assertEquals, assertStrictEquals } from \"./deps_test.ts\";\nimport { assert, errors } from \"./deps.ts\";\nimport { createMockContext } from \"./testing.ts\";\nimport {\n  compose,\n  isMiddlewareObject,\n  type Middleware,\n  type MiddlewareObject,\n  type Next,\n} from \"./middleware.ts\";\nimport { Context } from \"./context.ts\";\n\nDeno.test({\n  name: \"test compose()\",\n  async fn() {\n    const callStack: number[] = [];\n    const mockContext = createMockContext();\n    const mw1: Middleware = async (context, next) => {\n      assertStrictEquals(context, mockContext);\n      assertEquals(typeof next, \"function\");\n      callStack.push(1);\n      await next();\n    };\n    const mw2: Middleware = async (context, next) => {\n      assertStrictEquals(context, mockContext);\n      assertEquals(typeof next, \"function\");\n      callStack.push(2);\n      await next();\n    };\n    await compose([mw1, mw2])(mockContext);\n    assertEquals(callStack, [1, 2]);\n  },\n});\n\nDeno.test({\n  name: \"isMiddlewareObject()\",\n  async fn() {\n    class MockMiddlewareObject implements MiddlewareObject {\n      handleRequest(\n        _context: Context<Record<string, any>, Record<string, any>>,\n        _next: Next,\n      ): unknown {\n        return;\n      }\n    }\n\n    assert(isMiddlewareObject(new MockMiddlewareObject()));\n    assert(isMiddlewareObject({ handleRequest() {} }));\n    assert(!isMiddlewareObject(function () {}));\n  },\n});\n\nDeno.test({\n  name: \"middleware objects are composed correctly\",\n  async fn() {\n    const callStack: number[] = [];\n    const mockContext = createMockContext();\n\n    class MockMiddlewareObject implements MiddlewareObject {\n      #counter = 0;\n\n      async handleRequest(_context: any, next: Next) {\n        assertEquals(typeof next, \"function\");\n        callStack.push(this.#counter++);\n        await next();\n      }\n    }\n\n    const mwo = new MockMiddlewareObject();\n    const fn = compose([mwo]);\n\n    await fn(mockContext);\n    await fn(mockContext);\n    assertEquals(callStack, [0, 1]);\n  },\n});\n\nDeno.test({\n  name: \"next() is catchable\",\n  async fn() {\n    let caught: any;\n    const mw1: Middleware = async (ctx, next) => {\n      try {\n        await next();\n      } catch (err) {\n        caught = err;\n      }\n    };\n    const mw2: Middleware = async (ctx) => {\n      ctx.throw(500);\n    };\n    const context = createMockContext();\n    await compose([mw1, mw2])(context);\n    assert(caught instanceof errors.InternalServerError);\n  },\n});\n\nDeno.test({\n  name: \"composed middleware accepts next middleware\",\n  async fn() {\n    const callStack: number[] = [];\n    const mockContext = createMockContext();\n\n    const mw0: Middleware = async (context, next): Promise<void> => {\n      assertEquals(typeof next, \"function\");\n      callStack.push(3);\n      await next();\n    };\n\n    const mw1: Middleware = async (context, next) => {\n      assertEquals(typeof next, \"function\");\n      callStack.push(1);\n      await next();\n    };\n    const mw2: Middleware = async (context, next) => {\n      assertEquals(typeof next, \"function\");\n      callStack.push(2);\n      await next();\n    };\n\n    await compose([mw1, mw2])(mockContext, mw0 as () => Promise<void>);\n    assertEquals(callStack, [1, 2, 3]);\n  },\n});\n"
        },
        {
          "name": "middleware.ts",
          "type": "blob",
          "size": 2.9248046875,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n/**\n * The internal middleware interfaces and abstractions used by oak.\n *\n * Outside of the {@linkcode Middleware} interface, items are not generally\n * used by end users, but {@linkcode compose} can be used for advanced use\n * cases.\n *\n * @module\n */\n\n// deno-lint-ignore-file\n\nimport type { State } from \"./application.ts\";\nimport type { Context } from \"./context.ts\";\n\n/** A function for chaining middleware. */\nexport type Next = () => Promise<unknown>;\n\n/** Middleware are functions which are chained together to deal with\n * requests. */\nexport interface Middleware<\n  S extends State = Record<string, any>,\n  T extends Context = Context<S>,\n> {\n  (context: T, next: Next): Promise<unknown> | unknown;\n}\n\n/** Middleware objects allow encapsulation of middleware along with the ability\n * to initialize the middleware upon listen. */\nexport interface MiddlewareObject<\n  S extends State = Record<string, any>,\n  T extends Context<S> = Context<S>,\n> {\n  /** Optional function for delayed initialization which will be called when\n   * the application starts listening. */\n  init?: () => Promise<unknown> | unknown;\n  /** The method to be called to handle the request. */\n  handleRequest(context: T, next: Next): Promise<unknown> | unknown;\n}\n\n/** Type that represents {@linkcode Middleware} or\n * {@linkcode MiddlewareObject}. */\nexport type MiddlewareOrMiddlewareObject<\n  S extends State = Record<string, any>,\n  T extends Context = Context<S>,\n> = Middleware<S, T> | MiddlewareObject<S, T>;\n\n/** A type guard that returns true if the value is\n * {@linkcode MiddlewareObject}. */\nexport function isMiddlewareObject<\n  S extends State = Record<string, any>,\n  T extends Context = Context<S>,\n>(value: MiddlewareOrMiddlewareObject<S, T>): value is MiddlewareObject<S, T> {\n  return value && typeof value === \"object\" && \"handleRequest\" in value;\n}\n\n/** Compose multiple middleware functions into a single middleware function. */\nexport function compose<\n  S extends State = Record<string, any>,\n  T extends Context = Context<S>,\n>(\n  middleware: MiddlewareOrMiddlewareObject<S, T>[],\n): (context: T, next?: Next) => Promise<unknown> {\n  return function composedMiddleware(\n    context: T,\n    next?: Next,\n  ): Promise<unknown> {\n    let index = -1;\n\n    async function dispatch(i: number): Promise<void> {\n      if (i <= index) {\n        throw new Error(\"next() called multiple times.\");\n      }\n      index = i;\n      let m: MiddlewareOrMiddlewareObject<S, T> | undefined = middleware[i];\n      let fn: Middleware<S, T> | undefined;\n      if (typeof m === \"function\") {\n        fn = m;\n      } else if (m && typeof m.handleRequest === \"function\") {\n        fn = (m as MiddlewareObject).handleRequest.bind(m);\n      }\n      if (i === middleware.length) {\n        fn = next;\n      }\n      if (!fn) {\n        return;\n      }\n      await fn(context, dispatch.bind(null, i + 1));\n    }\n\n    return dispatch(0);\n  };\n}\n"
        },
        {
          "name": "middleware",
          "type": "tree",
          "content": null
        },
        {
          "name": "mod.test.ts",
          "type": "blob",
          "size": 1.7509765625,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\nimport { assert } from \"./deps.ts\";\nimport { assertEquals } from \"./deps_test.ts\";\nimport * as mod from \"./mod.ts\";\n\nDeno.test({\n  name: \"public API assertions\",\n  fn() {\n    assert(mod != null);\n    assertEquals(typeof mod.Application, \"function\");\n    assertEquals(typeof mod.Context, \"function\");\n    assertEquals(typeof mod.etag, \"object\");\n    assertEquals(typeof mod.etag.getEntity, \"function\");\n    assertEquals(typeof mod.etag.factory, \"function\");\n    assertEquals(typeof mod.HttpError, \"function\");\n    assertEquals(typeof mod.httpErrors, \"object\");\n    assertEquals(typeof mod.HttpServerNative, \"function\");\n    assertEquals(typeof mod.isErrorStatus, \"function\");\n    assertEquals(typeof mod.isHttpError, \"function\");\n    assertEquals(typeof mod.isRedirectStatus, \"function\");\n    assertEquals(typeof mod.composeMiddleware, \"function\");\n    assertEquals(typeof mod.Cookies, \"function\");\n    assertEquals(typeof mod.proxy, \"function\");\n    assertEquals(typeof mod.REDIRECT_BACK, \"symbol\");\n    assertEquals(typeof mod.Request, \"function\");\n    assertEquals(typeof mod.Response, \"function\");\n    assertEquals(typeof mod.route, \"function\");\n    assertEquals(typeof mod.RouteContext, \"function\");\n    assertEquals(typeof mod.Router, \"function\");\n    assertEquals(typeof mod.ServerSentEvent, \"function\");\n    assertEquals(typeof mod.serve, \"function\");\n    assertEquals(typeof mod.ServeContext, \"function\");\n    assertEquals(typeof mod.STATUS_TEXT, \"object\");\n    assertEquals(typeof mod.Status, \"object\");\n    assertEquals(typeof mod.send, \"function\");\n    assertEquals(typeof mod.testing, \"object\");\n    assertEquals(Object.keys(mod.testing).length, 4);\n    assertEquals(Object.keys(mod).length, 26);\n  },\n});\n"
        },
        {
          "name": "mod.ts",
          "type": "blob",
          "size": 3.9287109375,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n/**\n * A middleware framework for handling HTTP with [Deno CLI](https://deno.land),\n * [Deno Deploy](https://deno.com/deploy),\n * [Cloudflare Workers](https://workers.cloudflare.com/),\n * [Node.js](https://nodejs.org/), and [Bun](https://bun.sh/).\n *\n * oak is inspired by [koa](https://koajs.com/).\n *\n * ## Example server\n *\n * A minimal router server which responds with content on `/`.\n *\n * ### Deno CLI and Deno Deploy\n *\n * ```ts\n * import { Application } from \"jsr:@oak/oak/application\";\n * import { Router } from \"jsr:@oak/oak/router\";\n *\n * const router = new Router();\n * router.get(\"/\", (ctx) => {\n *   ctx.response.body = `<!DOCTYPE html>\n *     <html>\n *       <head><title>Hello oak!</title><head>\n *       <body>\n *         <h1>Hello oak!</h1>\n *       </body>\n *     </html>\n *   `;\n * });\n *\n * const app = new Application();\n * app.use(router.routes());\n * app.use(router.allowedMethods());\n *\n * app.listen({ port: 8080 });\n * ```\n *\n * ### Node.js and Bun\n *\n * You will have to install the package and then:\n *\n * ```ts\n * import { Application } from \"@oak/oak/application\";\n * import { Router } from \"@oak/oak/router\";\n *\n * const router = new Router();\n * router.get(\"/\", (ctx) => {\n *   ctx.response.body = `<!DOCTYPE html>\n *     <html>\n *       <head><title>Hello oak!</title><head>\n *       <body>\n *         <h1>Hello oak!</h1>\n *       </body>\n *     </html>\n *   `;\n * });\n *\n * const app = new Application();\n * app.use(router.routes());\n * app.use(router.allowedMethods());\n *\n * app.listen({ port: 8080 });\n * ```\n *\n * ### Cloudflare Workers\n *\n * You will have to install the package and then:\n *\n * ```ts\n * import { Application } from \"@oak/oak/application\";\n * import { Router } from \"@oak/oak/router\";\n *\n * const router = new Router();\n * router.get(\"/\", (ctx) => {\n *   ctx.response.body = `<!DOCTYPE html>\n *     <html>\n *       <head><title>Hello oak!</title><head>\n *       <body>\n *         <h1>Hello oak!</h1>\n *       </body>\n *     </html>\n *   `;\n * });\n *\n * const app = new Application();\n * app.use(router.routes());\n * app.use(router.allowedMethods());\n *\n * export default { fetch: app.fetch };\n * ```\n *\n * @module\n */\n\nexport {\n  Application,\n  type ApplicationOptions,\n  type ListenOptions,\n  type ListenOptionsBase,\n  type ListenOptionsTls,\n  type State,\n} from \"./application.ts\";\nexport type { BodyType } from \"./body.ts\";\nexport { Context, type ContextSendOptions } from \"./context.ts\";\nexport { Server as HttpServerNative } from \"./http_server_native.ts\";\nexport { type NativeRequest } from \"./http_server_native_request.ts\";\nexport * as etag from \"./middleware/etag.ts\";\nexport { proxy, type ProxyOptions } from \"./middleware/proxy.ts\";\nexport {\n  route,\n  RouteContext,\n  serve,\n  ServeContext,\n} from \"./middleware/serve.ts\";\nexport {\n  compose as composeMiddleware,\n  type Middleware,\n  type MiddlewareObject,\n  type MiddlewareOrMiddlewareObject,\n  type Next,\n} from \"./middleware.ts\";\nexport { Request } from \"./request.ts\";\nexport { REDIRECT_BACK, Response } from \"./response.ts\";\nexport {\n  type Route,\n  type RouteParams,\n  Router,\n  type RouterAllowedMethodsOptions,\n  type RouterContext,\n  type RouterMiddleware,\n  type RouterOptions,\n  type RouterParamMiddleware,\n} from \"./router.ts\";\nexport { send, type SendOptions } from \"./send.ts\";\n/** Utilities for making testing oak servers easier. */\nexport * as testing from \"./testing.ts\";\nexport { type ServerConstructor } from \"./types.ts\";\n\n// Re-exported from `std/http`\nexport {\n  createHttpError,\n  errors as httpErrors,\n  type ErrorStatus,\n  HttpError,\n  type HTTPMethods,\n  isErrorStatus,\n  isHttpError,\n  isRedirectStatus,\n  type RedirectStatus,\n  SecureCookieMap as Cookies,\n  type SecureCookieMapGetOptions as CookiesGetOptions,\n  type SecureCookieMapSetDeleteOptions as CookiesSetDeleteOptions,\n  ServerSentEvent,\n  type ServerSentEventInit,\n  type ServerSentEventTarget,\n  Status,\n  STATUS_TEXT,\n} from \"./deps.ts\";\n"
        },
        {
          "name": "node_shims.ts",
          "type": "blob",
          "size": 1.5693359375,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\nclass ErrorEvent extends Event {\n  #message: string;\n  #filename: string;\n  #lineno: number;\n  #colno: number;\n  // deno-lint-ignore no-explicit-any\n  #error: any;\n\n  get message(): string {\n    return this.#message;\n  }\n  get filename(): string {\n    return this.#filename;\n  }\n  get lineno(): number {\n    return this.#lineno;\n  }\n  get colno(): number {\n    return this.#colno;\n  }\n  // deno-lint-ignore no-explicit-any\n  get error(): any {\n    return this.#error;\n  }\n\n  constructor(type: string, eventInitDict: ErrorEventInit = {}) {\n    super(type, eventInitDict);\n    const { message = \"error\", filename = \"\", lineno = 0, colno = 0, error } =\n      eventInitDict;\n    this.#message = message;\n    this.#filename = filename;\n    this.#lineno = lineno;\n    this.#colno = colno;\n    this.#error = error;\n  }\n}\n\nif (!(\"ErrorEvent\" in globalThis)) {\n  Object.defineProperty(globalThis, \"ErrorEvent\", {\n    value: ErrorEvent,\n    writable: true,\n    enumerable: false,\n    configurable: true,\n  });\n}\n\nif (!(\"ReadableStream\" in globalThis) || !(\"TransformStream\" in globalThis)) {\n  (async () => {\n    const { ReadableStream, TransformStream } = await import(\"node:stream/web\");\n    Object.defineProperties(globalThis, {\n      \"ReadableStream\": {\n        value: ReadableStream,\n        writable: true,\n        enumerable: false,\n        configurable: true,\n      },\n      \"TransformStream\": {\n        value: TransformStream,\n        writable: true,\n        enumerable: false,\n        configurable: true,\n      },\n    });\n  })();\n}\n"
        },
        {
          "name": "request.test.ts",
          "type": "blob",
          "size": 8.6572265625,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n// deno-lint-ignore-file\n\nimport { assert, isHttpError, Status } from \"./deps.ts\";\nimport {\n  assertEquals,\n  assertRejects,\n  assertStrictEquals,\n} from \"./deps_test.ts\";\nimport { NativeRequest } from \"./http_server_native_request.ts\";\nimport type { NativeRequestInfo } from \"./http_server_native_request.ts\";\nimport { Request } from \"./request.ts\";\nimport { isNode } from \"./utils/type_guards.ts\";\n\nfunction createMockNativeRequest(\n  url = \"http://localhost/index.html\",\n  requestInit: RequestInit = {},\n  options: NativeRequestInfo = {},\n) {\n  const request: globalThis.Request = new (globalThis as any).Request(\n    url,\n    requestInit,\n  );\n\n  return new NativeRequest(request, options);\n}\n\nDeno.test({\n  name: \"request.searchParams\",\n  fn() {\n    const request = new Request(\n      createMockNativeRequest(\"http://localhost/foo?bar=baz&qat=qux\"),\n      {},\n    );\n    assertEquals(request.url.pathname, \"/foo\");\n    assertEquals(request.url.search, \"?bar=baz&qat=qux\");\n    assertEquals(request.method, \"GET\");\n    assertEquals(Array.from(request.url.searchParams.entries()), [\n      [\"bar\", \"baz\"],\n      [\"qat\", \"qux\"],\n    ]);\n  },\n});\n\nDeno.test({\n  name: \"request.url\",\n  fn() {\n    const mockServerRequest = createMockNativeRequest(\n      \"https://oakserver.github.io:8080/foo/bar/baz?up=down\",\n    );\n    const request = new Request(mockServerRequest, {\n      proxy: false,\n      secure: true,\n    });\n    assert(request.url instanceof URL);\n    assertEquals(request.url.protocol, \"https:\");\n    assertEquals(request.url.hostname, \"oakserver.github.io\");\n    assertEquals(request.url.host, \"oakserver.github.io:8080\");\n    assertEquals(request.url.pathname, \"/foo/bar/baz\");\n  },\n});\n\nDeno.test({\n  name: \"request.userAgent\",\n  fn() {\n    const mockServerRequest = createMockNativeRequest(\n      \"https://localhost/index.html\",\n      {\n        headers: {\n          \"User-Agent\":\n            \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36\",\n        },\n      },\n    );\n    const request = new Request(mockServerRequest);\n    assertStrictEquals(request.userAgent.browser.name, \"Chrome\");\n    assertStrictEquals(request.userAgent.device.model, \"Macintosh\");\n  },\n});\n\nDeno.test({\n  name: \"request.serverRequest\",\n  fn() {\n    const mockServerRequest = createMockNativeRequest();\n    const request = new Request(mockServerRequest);\n    assertStrictEquals(request.originalRequest, mockServerRequest);\n  },\n});\n\nDeno.test({\n  name: \"request.acceptsEncodings\",\n  fn() {\n    const request = new Request(\n      createMockNativeRequest(\"https://localhost/index.html\", {\n        headers: {\n          \"Accept-Encoding\": \"gzip, compress;q=0.2, identity;q=0.5\",\n        },\n      }),\n    );\n    assertEquals(request.acceptsEncodings(\"gzip\", \"identity\"), \"gzip\");\n  },\n});\n\nDeno.test({\n  name: \"request.acceptsEncodings - no header\",\n  fn() {\n    const request = new Request(\n      createMockNativeRequest(\"https://localhost/index.html\"),\n    );\n    assertEquals(request.acceptsEncodings(\"gzip\", \"identity\"), \"gzip\");\n  },\n});\n\nDeno.test({\n  name: \"request.acceptsEncodings - no header no encodings\",\n  fn() {\n    const request = new Request(\n      createMockNativeRequest(\"https://localhost/index.html\"),\n    );\n    assertEquals(request.acceptsEncodings(), [\"*\"]);\n  },\n});\n\nDeno.test({\n  name: \"request.accepts()\",\n  fn() {\n    const request = new Request(\n      createMockNativeRequest(\"https://localhost/index.html\", {\n        headers: {\n          Accept: \"application/json;q=0.2, text/html\",\n        },\n      }),\n    );\n    assertEquals(request.accepts(\"application/json\", \"text/html\"), \"text/html\");\n  },\n});\n\nDeno.test({\n  name: \"request.accepts not provided\",\n  fn() {\n    const request = new Request(\n      createMockNativeRequest(\"https://localhost/index.html\", {\n        headers: {\n          Accept: \"application/json;q=0.2, text/html\",\n        },\n      }),\n    );\n    assertEquals(request.accepts(), [\"text/html\", \"application/json\"]);\n  },\n});\n\nDeno.test({\n  name: \"request.accepts no header\",\n  fn() {\n    const request = new Request(createMockNativeRequest(\"https://localhost/\"));\n    assertEquals(request.accepts(\"application/json\"), \"application/json\");\n  },\n});\n\nDeno.test({\n  name: \"request.accepts no header, no args\",\n  fn() {\n    const request = new Request(createMockNativeRequest(\"https://localhost/\"));\n    assertEquals(request.accepts(), [\"*/*\"]);\n  },\n});\n\nDeno.test({\n  name: \"request.accepts no match\",\n  fn() {\n    const request = new Request(\n      createMockNativeRequest(\"https://localhost/index.html\", {\n        headers: { Accept: \"text/html\" },\n      }),\n    );\n    assertEquals(request.accepts(\"application/json\"), undefined);\n  },\n});\n\nDeno.test({\n  name: \"request.body()\",\n  async fn() {\n    const body = JSON.stringify({ hello: \"world\" });\n    const request = new Request(\n      createMockNativeRequest(\"https://localhost/index.html\", {\n        body,\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n          \"content-length\": String(body.length),\n        },\n      }),\n    );\n    assert(request.hasBody);\n    assert(request.body.has);\n    const actual = await request.body.json();\n    assertEquals(actual, { hello: \"world\" });\n  },\n});\n\nDeno.test({\n  name: \"request.secure is false\",\n  fn() {\n    const request = new Request(createMockNativeRequest());\n    assertEquals(request.secure, false);\n  },\n});\n\nDeno.test({\n  name: \"request.secure is true\",\n  fn() {\n    const request = new Request(\n      createMockNativeRequest(\"https://localhost/index.html\"),\n      { proxy: false, secure: true },\n    );\n    assertEquals(request.secure, true);\n  },\n});\n\nDeno.test({\n  name: \"request with proxy true\",\n  fn() {\n    const request = new Request(\n      createMockNativeRequest(\"https://example.com/index.html\", {\n        headers: {\n          \"x-forwarded-host\": \"10.10.10.10\",\n          \"x-forwarded-proto\": \"http\",\n          \"x-forwarded-for\": \"10.10.10.10, 192.168.1.1, 10.255.255.255\",\n        },\n      }, {\n        remoteAddr: {\n          transport: \"tcp\",\n          port: 8080,\n          hostname: \"10.255.255.255\",\n        },\n      }),\n      { proxy: true, secure: true },\n    );\n    assertEquals(request.secure, true);\n    assertEquals(request.url.hostname, \"10.10.10.10\");\n    assertEquals(request.url.protocol, \"http:\");\n    assertEquals(request.ip, \"10.10.10.10\");\n    assertEquals(request.ips, [\"10.10.10.10\", \"192.168.1.1\", \"10.255.255.255\"]);\n  },\n});\n\nDeno.test({\n  name: \"request with invalid JSON\",\n  async fn() {\n    const body = \"random text, but not JSON\";\n    const request = new Request(\n      createMockNativeRequest(\"http://localhost/index.html\", {\n        body,\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json\",\n          \"content-length\": String(body.length),\n        },\n      }),\n    );\n    assert(request.hasBody, \"should have body\");\n    const err = await assertRejects(\n      async () => {\n        await request.body.json();\n      },\n    );\n    assert(isHttpError(err));\n    assertEquals(err.status, Status.BadRequest);\n  },\n});\n\nDeno.test({\n  name: \"Request - inspecting\",\n  fn() {\n    assertEquals(\n      Deno.inspect(\n        new Request(\n          createMockNativeRequest(\"http://localhost/foo?bar=baz&qat=qux\", {\n            headers: { host: \"localhost\" },\n          }),\n        ),\n      ),\n      isNode()\n        ? `Request {\\n  body: Body { has: false, used: false },\\n  hasBody: false,\\n  headers: HeadersList {\\n    cookies: null,\\n    [Symbol(headers map)]: [Map],\\n    [Symbol(headers map sorted)]: null\\n  },\\n  ip: '',\\n  ips: [],\\n  method: 'GET',\\n  secure: false,\\n  url: URL {\\n    href: 'http://localhost/foo?bar=baz&qat=qux',\\n    origin: 'http://localhost',\\n    protocol: 'http:',\\n    username: '',\\n    password: '',\\n    host: 'localhost',\\n    hostname: 'localhost',\\n    port: '',\\n    pathname: '/foo',\\n    search: '?bar=baz&qat=qux',\\n    searchParams: URLSearchParams { 'bar' => 'baz', 'qat' => 'qux' },\\n    hash: ''\\n  },\\n  userAgent: UserAgent {\\n    browser: [Object],\\n    cpu: [Object],\\n    device: [Object],\\n    engine: [Object],\\n    os: [Object],\\n    ua: ''\\n  }\\n}`\n        : `Request {\\n  body: Body { has: false, used: false },\\n  hasBody: false,\\n  headers: Headers { host: \"localhost\" },\\n  ip: \"\",\\n  ips: [],\\n  method: \"GET\",\\n  secure: false,\\n  url: \"http://localhost/foo?bar=baz&qat=qux\",\\n  userAgent: UserAgent {\\n  browser: { name: undefined, version: undefined, major: undefined },\\n  cpu: { architecture: undefined },\\n  device: { model: undefined, type: undefined, vendor: undefined },\\n  engine: { name: undefined, version: undefined },\\n  os: { name: undefined, version: undefined },\\n  ua: \"\"\\n}\\n}`,\n    );\n  },\n});\n"
        },
        {
          "name": "request.ts",
          "type": "blob",
          "size": 10.8798828125,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n/**\n * Contains the {@linkcode Request} abstraction used by oak.\n *\n * Most end users would not need to directly access this module.\n *\n * @module\n */\n\nimport { Body } from \"./body.ts\";\nimport { ServerSentEventStreamTarget } from \"./deps.ts\";\nimport {\n  accepts,\n  acceptsEncodings,\n  acceptsLanguages,\n  type HTTPMethods,\n  type ServerSentEventTarget,\n  type ServerSentEventTargetOptions,\n  UserAgent,\n} from \"./deps.ts\";\nimport type { ServerRequest, UpgradeWebSocketOptions } from \"./types.ts\";\n\ninterface OakRequestOptions {\n  jsonBodyReviver?: (key: string, value: unknown) => unknown;\n  proxy?: boolean;\n  secure?: boolean;\n}\n\n/** An interface which provides information about the current request. The\n * instance related to the current request is available on the\n * {@linkcode Context}'s `.request` property.\n *\n * The interface contains several properties to get information about the\n * request as well as several methods, which include content negotiation and\n * the ability to decode a request body.\n */\nexport class Request {\n  #body: Body;\n  #proxy: boolean;\n  #secure: boolean;\n  #serverRequest: ServerRequest;\n  #url?: URL;\n  #userAgent: UserAgent;\n\n  #getRemoteAddr(): string {\n    return this.#serverRequest.remoteAddr ?? \"\";\n  }\n\n  /** An interface to access the body of the request. This provides an API that\n   * aligned to the **Fetch Request** API, but in a dedicated API.\n   */\n  get body(): Body {\n    return this.#body;\n  }\n\n  /** Is `true` if the request might have a body, otherwise `false`.\n   *\n   * **WARNING** this is an unreliable API. In HTTP/2 in many situations you\n   * cannot determine if a request has a body or not unless you attempt to read\n   * the body, due to the streaming nature of HTTP/2. As of Deno 1.16.1, for\n   * HTTP/1.1, Deno also reflects that behaviour.  The only reliable way to\n   * determine if a request has a body or not is to attempt to read the body.\n   */\n  get hasBody(): boolean {\n    return this.#body.has;\n  }\n\n  /** The `Headers` supplied in the request. */\n  get headers(): Headers {\n    return this.#serverRequest.headers;\n  }\n\n  /** Request remote address. When the application's `.proxy` is true, the\n   * `X-Forwarded-For` will be used to determine the requesting remote address.\n   */\n  get ip(): string {\n    return (this.#proxy ? this.ips[0] : this.#getRemoteAddr()) ?? \"\";\n  }\n\n  /** When the application's `.proxy` is `true`, this will be set to an array of\n   * IPs, ordered from upstream to downstream, based on the value of the header\n   * `X-Forwarded-For`.  When `false` an empty array is returned. */\n  get ips(): string[] {\n    return this.#proxy\n      ? (this.#serverRequest.headers.get(\"x-forwarded-for\") ??\n        this.#getRemoteAddr()).split(/\\s*,\\s*/)\n      : [];\n  }\n\n  /** The HTTP Method used by the request. */\n  get method(): HTTPMethods {\n    return this.#serverRequest.method as HTTPMethods;\n  }\n\n  /** Shortcut to `request.url.protocol === \"https:\"`. */\n  get secure(): boolean {\n    return this.#secure;\n  }\n\n  /** Set to the value of the low level oak server request abstraction.\n   *\n   * @deprecated this will be removed in future versions of oak. Accessing this\n   * abstraction is not useful to end users and is now a bit of a misnomer.\n   */\n  get originalRequest(): ServerRequest {\n    return this.#serverRequest;\n  }\n\n  /** Returns the original Fetch API `Request` if available.\n   *\n   * This should be set with requests on Deno, but will not be set when running\n   * on Node.js.\n   */\n  get source(): globalThis.Request | undefined {\n    return this.#serverRequest.request;\n  }\n\n  /** A parsed URL for the request which complies with the browser standards.\n   * When the application's `.proxy` is `true`, this value will be based off of\n   * the `X-Forwarded-Proto` and `X-Forwarded-Host` header values if present in\n   * the request. */\n  get url(): URL {\n    if (!this.#url) {\n      const serverRequest = this.#serverRequest;\n      // between Deno 1.9.0 and 1.9.1 the request.url of the native HTTP started\n      // returning the full URL, where previously it only returned the path\n      // so we will try to use that URL here, but default back to old logic\n      // if the URL isn't valid.\n      try {\n        if (serverRequest.rawUrl) {\n          this.#url = new URL(serverRequest.rawUrl);\n        }\n      } catch {\n        // we don't care about errors here\n      }\n      if (this.#proxy || !this.#url) {\n        let proto: string;\n        let host: string;\n        if (this.#proxy) {\n          proto = serverRequest\n            .headers.get(\"x-forwarded-proto\")?.split(/\\s*,\\s*/, 1)[0] ??\n            \"http\";\n          host = serverRequest.headers.get(\"x-forwarded-host\") ??\n            this.#url?.hostname ??\n            serverRequest.headers.get(\"host\") ??\n            serverRequest.headers.get(\":authority\") ?? \"\";\n        } else {\n          proto = this.#secure ? \"https\" : \"http\";\n          host = serverRequest.headers.get(\"host\") ??\n            serverRequest.headers.get(\":authority\") ?? \"\";\n        }\n        try {\n          this.#url = new URL(`${proto}://${host}${serverRequest.url}`);\n        } catch {\n          throw new TypeError(\n            `The server request URL of \"${proto}://${host}${serverRequest.url}\" is invalid.`,\n          );\n        }\n      }\n    }\n    return this.#url;\n  }\n\n  /** An object representing the requesting user agent. If the `User-Agent`\n   * header isn't defined in the request, all the properties will be undefined.\n   *\n   * See [std/http/user_agent#UserAgent](https://deno.land/std@0.223/http/user_agent.ts?s=UserAgent)\n   * for more information.\n   */\n  get userAgent(): UserAgent {\n    return this.#userAgent;\n  }\n\n  constructor(\n    serverRequest: ServerRequest,\n    { proxy = false, secure = false, jsonBodyReviver }: OakRequestOptions = {},\n  ) {\n    this.#proxy = proxy;\n    this.#secure = secure;\n    this.#serverRequest = serverRequest;\n    this.#body = new Body(serverRequest, jsonBodyReviver);\n    this.#userAgent = new UserAgent(serverRequest.headers.get(\"user-agent\"));\n  }\n\n  /** Returns an array of media types, accepted by the requestor, in order of\n   * preference.  If there are no encodings supplied by the requestor,\n   * then accepting any is implied is returned.\n   */\n  accepts(): string[] | undefined;\n  /** For a given set of media types, return the best match accepted by the\n   * requestor.  If there are no encoding that match, then the method returns\n   * `undefined`.\n   */\n  accepts(...types: string[]): string | undefined;\n  accepts(...types: string[]): string | string[] | undefined {\n    if (!this.#serverRequest.headers.has(\"Accept\")) {\n      return types.length ? types[0] : [\"*/*\"];\n    }\n    if (types.length) {\n      return accepts(this.#serverRequest, ...types);\n    }\n    return accepts(this.#serverRequest);\n  }\n\n  /** Returns an array of encodings, accepted by the requestor, in order of\n   * preference.  If there are no encodings supplied by the requestor,\n   * then `[\"*\"]` is returned, matching any.\n   */\n  acceptsEncodings(): string[] | undefined;\n  /** For a given set of encodings, return the best match accepted by the\n   * requestor.  If there are no encodings that match, then the method returns\n   * `undefined`.\n   *\n   * **NOTE:** You should always supply `identity` as one of the encodings\n   * to ensure that there is a match when the `Accept-Encoding` header is part\n   * of the request.\n   */\n  acceptsEncodings(...encodings: string[]): string | undefined;\n  acceptsEncodings(...encodings: string[]): string[] | string | undefined {\n    if (!this.#serverRequest.headers.has(\"Accept-Encoding\")) {\n      return encodings.length ? encodings[0] : [\"*\"];\n    }\n    if (encodings.length) {\n      return acceptsEncodings(this.#serverRequest, ...encodings);\n    }\n    return acceptsEncodings(this.#serverRequest);\n  }\n\n  /** Returns an array of languages, accepted by the requestor, in order of\n   * preference.  If there are no languages supplied by the requestor,\n   * `[\"*\"]` is returned, indicating any language is accepted.\n   */\n  acceptsLanguages(): string[] | undefined;\n  /** For a given set of languages, return the best match accepted by the\n   * requestor.  If there are no languages that match, then the method returns\n   * `undefined`. */\n  acceptsLanguages(...langs: string[]): string | undefined;\n  acceptsLanguages(...langs: string[]): string[] | string | undefined {\n    if (!this.#serverRequest.headers.get(\"Accept-Language\")) {\n      return langs.length ? langs[0] : [\"*\"];\n    }\n    if (langs.length) {\n      return acceptsLanguages(this.#serverRequest, ...langs);\n    }\n    return acceptsLanguages(this.#serverRequest);\n  }\n\n  /** Take the current request and initiate server sent event connection.\n   *\n   * > ![WARNING]\n   * > This is not intended for direct use, as it will not manage the target in\n   * > the overall context or ensure that additional middleware does not attempt\n   * > to respond to the request.\n   */\n  async sendEvents(\n    options?: ServerSentEventTargetOptions,\n    init?: RequestInit,\n  ): Promise<ServerSentEventTarget> {\n    const sse = new ServerSentEventStreamTarget(options);\n    await this.#serverRequest.respond(sse.asResponse(init));\n    return sse;\n  }\n\n  /** Take the current request and upgrade it to a web socket, returning a web\n   * standard `WebSocket` object.\n   *\n   * If the underlying server abstraction does not support upgrades, this will\n   * throw.\n   *\n   * > ![WARNING]\n   * > This is not intended for direct use, as it will not manage the websocket\n   * > in the overall context or ensure that additional middleware does not\n   * > attempt to respond to the request.\n   */\n  upgrade(options?: UpgradeWebSocketOptions): WebSocket {\n    if (!this.#serverRequest.upgrade) {\n      throw new TypeError(\"Web sockets upgrade not supported in this runtime.\");\n    }\n    return this.#serverRequest.upgrade(options);\n  }\n\n  [Symbol.for(\"Deno.customInspect\")](\n    inspect: (value: unknown) => string,\n  ): string {\n    const { body, hasBody, headers, ip, ips, method, secure, url, userAgent } =\n      this;\n    return `${this.constructor.name} ${\n      inspect({\n        body,\n        hasBody,\n        headers,\n        ip,\n        ips,\n        method,\n        secure,\n        url: url.toString(),\n        userAgent,\n      })\n    }`;\n  }\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")](\n    depth: number,\n    // deno-lint-ignore no-explicit-any\n    options: any,\n    inspect: (value: unknown, options?: unknown) => string,\n    // deno-lint-ignore no-explicit-any\n  ): any {\n    if (depth < 0) {\n      return options.stylize(`[${this.constructor.name}]`, \"special\");\n    }\n\n    const newOptions = Object.assign({}, options, {\n      depth: options.depth === null ? null : options.depth - 1,\n    });\n    const { body, hasBody, headers, ip, ips, method, secure, url, userAgent } =\n      this;\n    return `${options.stylize(this.constructor.name, \"special\")} ${\n      inspect(\n        { body, hasBody, headers, ip, ips, method, secure, url, userAgent },\n        newOptions,\n      )\n    }`;\n  }\n}\n"
        },
        {
          "name": "response.test.ts",
          "type": "blob",
          "size": 14.0869140625,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\nimport { assert, Status } from \"./deps.ts\";\nimport { assertEquals, assertThrows } from \"./deps_test.ts\";\nimport type { Request } from \"./request.ts\";\nimport { REDIRECT_BACK, Response } from \"./response.ts\";\nimport { isNode } from \"./utils/type_guards.ts\";\n\nfunction createMockRequest({\n  headers,\n  accepts = (_contentType: string) => {\n    return true;\n  },\n}: {\n  headers?: [string, string][];\n  accepts?: (contentType: string) => boolean;\n} = {}): Request {\n  // deno-lint-ignore no-explicit-any\n  return { accepts, headers: new Headers(headers) } as any;\n}\n\nDeno.test({\n  name: \"response empty\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(nativeResponse.body, null);\n    assertEquals(nativeResponse.status, 404);\n    assertEquals(Array.from(nativeResponse.headers.entries()).length, 1);\n    assertEquals(nativeResponse.headers.get(\"Content-Length\"), \"0\");\n  },\n});\n\nDeno.test({\n  name: \"response.status set\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.status = 302;\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(nativeResponse.body, null);\n    assertEquals(nativeResponse.status, 302);\n    assertEquals(Array.from(nativeResponse.headers.entries()).length, 1);\n    assertEquals(nativeResponse.headers.get(\"Content-Length\"), \"0\");\n  },\n});\n\nDeno.test({\n  name: \"response.body as text\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.body = \"Hello world!\";\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(await nativeResponse.text(), \"Hello world!\");\n    assertEquals(nativeResponse.status, 200);\n    assertEquals(\n      nativeResponse.headers.get(\"content-type\"),\n      \"text/plain; charset=UTF-8\",\n    );\n    assertEquals(Array.from(nativeResponse.headers.entries()).length, 1);\n  },\n});\n\nDeno.test({\n  name: \"response.body as HTML\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.body = \"<!DOCTYPE html><html><body>Hello world!</body></html>\";\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(\n      await nativeResponse.text(),\n      \"<!DOCTYPE html><html><body>Hello world!</body></html>\",\n    );\n    assertEquals(nativeResponse.status, 200);\n    assertEquals(\n      nativeResponse.headers.get(\"content-type\"),\n      \"text/html; charset=UTF-8\",\n    );\n    assertEquals(Array.from(nativeResponse.headers.entries()).length, 1);\n  },\n});\n\nDeno.test({\n  name: \"response.body as JSON\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.body = { foo: \"bar\" };\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(await nativeResponse.text(), `{\"foo\":\"bar\"}`);\n    assertEquals(nativeResponse.status, 200);\n    assertEquals(\n      nativeResponse.headers.get(\"content-type\"),\n      \"application/json; charset=UTF-8\",\n    );\n    assertEquals(Array.from(nativeResponse.headers.entries()).length, 1);\n  },\n});\n\nDeno.test({\n  name: \"response.body as symbol\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.body = Symbol(\"foo\");\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(await nativeResponse.text(), \"Symbol(foo)\");\n    assertEquals(nativeResponse.status, 200);\n    assertEquals(\n      nativeResponse.headers.get(\"content-type\"),\n      \"text/plain; charset=UTF-8\",\n    );\n    assertEquals(Array.from(nativeResponse.headers.entries()).length, 1);\n  },\n});\n\nDeno.test({\n  name: \"response.body as Uint8Array\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.body = new TextEncoder().encode(\"Hello world!\");\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(await nativeResponse.text(), \"Hello world!\");\n    assertEquals(nativeResponse.status, 200);\n    assertEquals(Array.from(nativeResponse.headers.entries()).length, 0);\n  },\n});\n\nDeno.test({\n  name: \"response.body as function\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.body = () => \"Hello world!\";\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(await nativeResponse.text(), \"Hello world!\");\n    assertEquals(nativeResponse.status, 200);\n    assertEquals(\n      nativeResponse.headers.get(\"content-type\"),\n      \"text/plain; charset=UTF-8\",\n    );\n    assertEquals(Array.from(nativeResponse.headers.entries()).length, 1);\n  },\n});\n\nDeno.test({\n  name: \"response.body as readable stream\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.body = new ReadableStream<string>({\n      start(controller) {\n        controller.enqueue(\"hello \");\n        controller.enqueue(\"deno\");\n        controller.close();\n      },\n    });\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(await nativeResponse.text(), \"hello deno\");\n    assertEquals(nativeResponse.status, 200);\n  },\n});\n\nDeno.test({\n  name: \"response.body as async iterable\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.body = {\n      async *[Symbol.asyncIterator]() {\n        yield \"hello \";\n        yield \"deno\";\n        return;\n      },\n    };\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(await nativeResponse.text(), \"hello deno\");\n    assertEquals(nativeResponse.status, 200);\n  },\n});\n\nDeno.test({\n  name: \"response.body as async function\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.body = () => Promise.resolve(\"Hello world!\");\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(await nativeResponse.text(), \"Hello world!\");\n    assertEquals(nativeResponse.status, 200);\n    assertEquals(\n      nativeResponse.headers.get(\"content-type\"),\n      \"text/plain; charset=UTF-8\",\n    );\n    assertEquals(Array.from(nativeResponse.headers.entries()).length, 1);\n  },\n});\n\nDeno.test({\n  name: \"response.body as FormData\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    const formData = new FormData();\n    formData.append(\"a\", \"value\");\n    formData.append(\n      \"b\",\n      new Blob([\"some string\"], { type: \"text/plain\" }),\n      \"file.txt\",\n    );\n    response.body = formData;\n    const nativeResponse = await response.toDomResponse();\n    assert(\n      nativeResponse.headers.get(\"content-type\")?.startsWith(\n        \"multipart/form-data; boundary=\",\n      ),\n    );\n  },\n});\n\nDeno.test({\n  name: \"response.type\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.type = \"js\";\n    response.body = \"console.log('hello world');\";\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(\n      await nativeResponse.text(),\n      \"console.log('hello world');\",\n    );\n    assertEquals(nativeResponse.status, 200);\n    assertEquals(\n      nativeResponse.headers.get(\"content-type\"),\n      \"text/javascript; charset=UTF-8\",\n    );\n    assertEquals(Array.from(nativeResponse.headers.entries()).length, 1);\n  },\n});\n\nDeno.test({\n  name: \"response.type does not overwrite\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.type = \"js\";\n    response.body = \"console.log('hello world');\";\n    response.headers.set(\"content-type\", \"text/plain\");\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(\n      await nativeResponse.text(),\n      \"console.log('hello world');\",\n    );\n    assertEquals(nativeResponse.status, 200);\n    assertEquals(nativeResponse.headers.get(\"Content-Type\"), \"text/plain\");\n    assertEquals(Array.from(nativeResponse.headers.entries()).length, 1);\n  },\n});\n\nDeno.test({\n  name: \"empty response sets contentLength to 0\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(nativeResponse.headers.get(\"Content-Length\"), \"0\");\n  },\n});\n\nDeno.test({\n  name: \"response.redirect('./foo')\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.redirect(\"./foo\");\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(nativeResponse.status, Status.Found);\n    assertEquals(\n      await nativeResponse.text(),\n      `Redirecting to <a href=\"./foo\">./foo</a>.`,\n    );\n    assertEquals(nativeResponse.headers.get(\"Location\"), \"./foo\");\n    assertEquals(\n      nativeResponse.headers.get(\"Content-Type\"),\n      \"text/html; charset=UTF-8\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"response.redirect(URL)\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    const url = new URL(\"https://example.com/foo\");\n    response.redirect(url);\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(nativeResponse.status, Status.Found);\n    assertEquals(\n      await nativeResponse.text(),\n      `Redirecting to <a href=\"https://example.com/foo\">https://example.com/foo</a>.`,\n    );\n    assertEquals(\n      nativeResponse.headers.get(\"Location\"),\n      \"https://example.com/foo\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"response.redirect(REDIRECT_BACK)\",\n  async fn() {\n    const response = new Response(\n      createMockRequest({ headers: [[\"referer\", \"https://example.com/foo\"]] }),\n    );\n    response.redirect(REDIRECT_BACK);\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(nativeResponse.status, Status.Found);\n    assertEquals(\n      await nativeResponse.text(),\n      `Redirecting to <a href=\"https://example.com/foo\">https://example.com/foo</a>.`,\n    );\n    assertEquals(\n      nativeResponse.headers.get(\"Location\"),\n      \"https://example.com/foo\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"response.redirect(REDIRECT_BACK) no referrer, but alt\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.redirect(REDIRECT_BACK, new URL(\"https://example.com/foo\"));\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(nativeResponse.status, Status.Found);\n    assertEquals(\n      await nativeResponse.text(),\n      `Redirecting to <a href=\"https://example.com/foo\">https://example.com/foo</a>.`,\n    );\n    assertEquals(\n      nativeResponse.headers.get(\"Location\"),\n      \"https://example.com/foo\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"response.redirect(REDIRECT_BACK) no referrer, no alt\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.redirect(REDIRECT_BACK);\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(nativeResponse.status, Status.Found);\n    assertEquals(\n      await nativeResponse.text(),\n      `Redirecting to <a href=\"/\">/</a>.`,\n    );\n    assertEquals(nativeResponse.headers.get(\"Location\"), \"/\");\n  },\n});\n\nDeno.test({\n  name: \"response.redirect() no html\",\n  async fn() {\n    const response = new Response(createMockRequest({\n      accepts(value) {\n        return value === \"html\" ? false : true;\n      },\n    }));\n    response.redirect(\"https://example.com/foo\");\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(nativeResponse.status, Status.Found);\n    assertEquals(\n      await nativeResponse.text(),\n      `Redirecting to https://example.com/foo.`,\n    );\n    assertEquals(\n      nativeResponse.headers.get(\"Location\"),\n      \"https://example.com/foo\",\n    );\n    assertEquals(\n      nativeResponse.headers.get(\"Content-Type\"),\n      \"text/plain; charset=UTF-8\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"response.redirect() with url on query string\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.redirect(\n      \"https://example.com/foo?redirect=https%3A%2F%2Fdeno.land\",\n    );\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(nativeResponse.status, Status.Found);\n    assertEquals(\n      nativeResponse.headers.get(\"Location\"),\n      \"https://example.com/foo?redirect=https%3A%2F%2Fdeno.land\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"response.status reflects body state\",\n  fn() {\n    const response = new Response(createMockRequest());\n    assertEquals(response.status, Status.NotFound);\n    response.body = \"hello\";\n    assertEquals(response.status, Status.OK);\n    response.body = null;\n    assertEquals(response.status, Status.NoContent);\n    response.status = Status.PartialContent;\n    assertEquals(response.status, Status.PartialContent);\n  },\n});\n\nDeno.test({\n  name: \"response.toDomResponse() is a memo\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    const sr1 = await response.toDomResponse();\n    const sr2 = await response.toDomResponse();\n    assert(sr1 === sr2);\n  },\n});\n\nDeno.test({\n  name: \"response.body cannot be set after server response\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    await response.toDomResponse();\n    assertThrows(() => {\n      response.body = \"\";\n    }, Error);\n  },\n});\n\nDeno.test({\n  name: \"response.status cannot be set after server response\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    await response.toDomResponse();\n    assertThrows(() => {\n      response.status = Status.Found;\n    }, Error);\n  },\n});\n\nDeno.test({\n  name: \"response.body handles null\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.body = null;\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(nativeResponse.status, Status.NoContent);\n  },\n});\n\nDeno.test({\n  name: \"response.body handles falsy values\",\n  async fn() {\n    const response = new Response(createMockRequest());\n    response.body = 0;\n    const nativeResponse = await response.toDomResponse();\n    assertEquals(nativeResponse.status, Status.OK);\n  },\n});\n\nDeno.test({\n  name: \"Response - inspecting\",\n  fn() {\n    assertEquals(\n      Deno.inspect(new Response(createMockRequest())),\n      isNode()\n        ? `Response {\\n  body: undefined,\\n  headers: HeadersList {\\n    cookies: null,\\n    [Symbol(headers map)]: Map(0) {},\\n    [Symbol(headers map sorted)]: null\\n  },\\n  status: 404,\\n  type: undefined,\\n  writable: true\\n}`\n        : `Response {\\n  body: undefined,\\n  headers: Headers {},\\n  status: 404,\\n  type: undefined,\\n  writable: true\\n}`,\n    );\n  },\n});\n"
        },
        {
          "name": "response.ts",
          "type": "blob",
          "size": 12.54296875,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n/**\n * Contains the {@linkcode Response} abstraction used by oak.\n *\n * Most end users would not need to directly access this module.\n *\n * @module\n */\n\nimport { contentType, isRedirectStatus, Status, STATUS_TEXT } from \"./deps.ts\";\nimport { DomResponse } from \"./http_server_native_request.ts\";\nimport type { Request } from \"./request.ts\";\nimport { isAsyncIterable, isFsFile, isHtml } from \"./utils/type_guards.ts\";\nimport { BODY_TYPES } from \"./utils/consts.ts\";\nimport { encodeUrl } from \"./utils/encode_url.ts\";\nimport {\n  readableStreamFromAsyncIterable,\n  Uint8ArrayTransformStream,\n} from \"./utils/streams.ts\";\n\n/** The various types of bodies supported when setting the value of `.body`\n * on a {@linkcode Response} */\nexport type ResponseBody =\n  | string\n  | number\n  | bigint\n  | boolean\n  | symbol\n  | object\n  | undefined\n  | null;\n\n/** A function that when invoked returns or resolves to a\n * {@linkcode ResponseBody}. */\nexport type ResponseBodyFunction = () => ResponseBody | Promise<ResponseBody>;\n\n/** A symbol that indicates to `response.redirect()` to attempt to redirect\n * back to the request referrer.  For example:\n *\n * ```ts\n * import { Application, REDIRECT_BACK } from \"jsr:@oak/oak/\";\n *\n * const app = new Application();\n *\n * app.use((ctx) => {\n *   if (ctx.request.url.pathName === \"/back\") {\n *     ctx.response.redirect(REDIRECT_BACK, \"/\");\n *   }\n * });\n *\n * await app.listen({ port: 80 });\n * ```\n */\nexport const REDIRECT_BACK = Symbol(\"redirect backwards\");\n\nasync function convertBodyToBodyInit(\n  body: ResponseBody | ResponseBodyFunction,\n  type?: string,\n  jsonBodyReplacer?: (key: string, value: unknown) => unknown,\n): Promise<[globalThis.BodyInit | undefined, string | undefined]> {\n  let result: globalThis.BodyInit | undefined;\n  if (BODY_TYPES.includes(typeof body)) {\n    result = String(body);\n    type = type ?? (isHtml(result) ? \"html\" : \"text/plain\");\n  } else if (isFsFile(body)) {\n    result = body.readable;\n  } else if (\n    ArrayBuffer.isView(body) || body instanceof ArrayBuffer ||\n    body instanceof Blob || body instanceof URLSearchParams\n  ) {\n    // deno-lint-ignore no-explicit-any\n    result = body as any;\n  } else if (body instanceof ReadableStream) {\n    result = body.pipeThrough(new Uint8ArrayTransformStream());\n  } else if (body instanceof FormData) {\n    result = body;\n    type = undefined;\n  } else if (isAsyncIterable(body)) {\n    result = readableStreamFromAsyncIterable(body);\n  } else if (body && typeof body === \"object\") {\n    result = JSON.stringify(body, jsonBodyReplacer);\n    type = type ?? \"json\";\n  } else if (typeof body === \"function\") {\n    const result = body.call(null);\n    return convertBodyToBodyInit(await result, type, jsonBodyReplacer);\n  } else if (body) {\n    throw new TypeError(\"Response body was set but could not be converted.\");\n  }\n  return [result, type];\n}\n\n/** An interface to control what response will be sent when the middleware\n * finishes processing the request.\n *\n * The response is usually accessed via the context's `.response` property.\n *\n * ### Example\n *\n * ```ts\n * import { Application, Status } from \"jsr:@oak/oak/\";\n *\n * const app = new Application();\n *\n * app.use((ctx) => {\n *   ctx.response.body = { hello: \"oak\" };\n *   ctx.response.type = \"json\";\n *   ctx.response.status = Status.OK;\n * });\n * ```\n */\nexport class Response {\n  #body?: ResponseBody | ResponseBodyFunction;\n  #bodySet = false;\n  #domResponse?: globalThis.Response;\n  #headers = new Headers();\n  #jsonBodyReplacer?: (key: string, value: unknown) => unknown;\n  #request: Request;\n  #resources: { close(): void }[] = [];\n  #status?: Status;\n  #type?: string;\n  #writable = true;\n\n  async #getBodyInit(): Promise<globalThis.BodyInit | undefined> {\n    const [body, type] = await convertBodyToBodyInit(\n      this.body,\n      this.type,\n      this.#jsonBodyReplacer,\n    );\n    this.type = type;\n    return body;\n  }\n\n  #setContentType(): void {\n    if (this.type) {\n      const contentTypeString = contentType(this.type);\n      if (contentTypeString && !this.headers.has(\"Content-Type\")) {\n        this.headers.append(\"Content-Type\", contentTypeString);\n      }\n    }\n  }\n\n  /** The body of the response.  The body will be automatically processed when\n   * the response is being sent and converted to a `Uint8Array` or a\n   * `Deno.Reader`.\n   *\n   * Automatic conversion to a `Deno.Reader` occurs for async iterables. */\n  get body(): ResponseBody | ResponseBodyFunction {\n    return this.#body;\n  }\n\n  /** The body of the response.  The body will be automatically processed when\n   * the response is being sent and converted to a `Uint8Array` or a\n   * `Deno.Reader`.\n   *\n   * Automatic conversion to a `Deno.Reader` occurs for async iterables. */\n  set body(value: ResponseBody | ResponseBodyFunction) {\n    if (!this.#writable) {\n      throw new Error(\"The response is not writable.\");\n    }\n    this.#bodySet = true;\n    this.#body = value;\n  }\n\n  /** Headers that will be returned in the response. */\n  get headers(): Headers {\n    return this.#headers;\n  }\n\n  /** Headers that will be returned in the response. */\n  set headers(value: Headers) {\n    if (!this.#writable) {\n      throw new Error(\"The response is not writable.\");\n    }\n    this.#headers = value;\n  }\n\n  /** The HTTP status of the response.  If this has not been explicitly set,\n   * reading the value will return what would be the value of status if the\n   * response were sent at this point in processing the middleware.  If the body\n   * has been set, the status will be `200 OK`.  If a value for the body has\n   * not been set yet, the status will be `404 Not Found`. */\n  get status(): Status {\n    if (this.#status) {\n      return this.#status;\n    }\n    return this.body != null\n      ? Status.OK\n      : this.#bodySet\n      ? Status.NoContent\n      : Status.NotFound;\n  }\n\n  /** The HTTP status of the response.  If this has not been explicitly set,\n   * reading the value will return what would be the value of status if the\n   * response were sent at this point in processing the middleware.  If the body\n   * has been set, the status will be `200 OK`.  If a value for the body has\n   * not been set yet, the status will be `404 Not Found`. */\n  set status(value: Status) {\n    if (!this.#writable) {\n      throw new Error(\"The response is not writable.\");\n    }\n    this.#status = value;\n  }\n\n  /** The media type, or extension of the response.  Setting this value will\n   * ensure an appropriate `Content-Type` header is added to the response. */\n  get type(): string | undefined {\n    return this.#type;\n  }\n  /** The media type, or extension of the response.  Setting this value will\n   * ensure an appropriate `Content-Type` header is added to the response. */\n  set type(value: string | undefined) {\n    if (!this.#writable) {\n      throw new Error(\"The response is not writable.\");\n    }\n    this.#type = value;\n  }\n\n  /** A read-only property which determines if the response is writable or not.\n   * Once the response has been processed, this value is set to `false`. */\n  get writable(): boolean {\n    return this.#writable;\n  }\n\n  constructor(\n    request: Request,\n    jsonBodyReplacer?: (key: string, value: unknown) => unknown,\n  ) {\n    this.#request = request;\n    this.#jsonBodyReplacer = jsonBodyReplacer;\n  }\n\n  /** Add a resource to the list of resources that will be closed when the\n   * request is destroyed. */\n  addResource(resource: { close(): void }): void {\n    this.#resources.push(resource);\n  }\n\n  /** Release any resources that are being tracked by the response.\n   *\n   * @param closeResources close any resource IDs registered with the response\n   */\n  destroy(closeResources = true): void {\n    this.#writable = false;\n    this.#body = undefined;\n    this.#domResponse = undefined;\n    if (closeResources) {\n      for (const resource of this.#resources) {\n        try {\n          resource.close();\n        } catch {\n          // we don't care about errors here\n        }\n      }\n    }\n  }\n\n  /** Sets the response to redirect to the supplied `url`.\n   *\n   * If the `.status` is not currently a redirect status, the status will be set\n   * to `302 Found`.\n   *\n   * The body will be set to a message indicating the redirection is occurring.\n   */\n  redirect(url: string | URL): void;\n  /** Sets the response to redirect back to the referrer if available, with an\n   * optional `alt` URL if there is no referrer header on the request.  If there\n   * is no referrer header, nor an `alt` parameter, the redirect is set to `/`.\n   *\n   * If the `.status` is not currently a redirect status, the status will be set\n   * to `302 Found`.\n   *\n   * The body will be set to a message indicating the redirection is occurring.\n   */\n  redirect(url: typeof REDIRECT_BACK, alt?: string | URL): void;\n  redirect(\n    url: string | URL | typeof REDIRECT_BACK,\n    alt: string | URL = \"/\",\n  ): void {\n    if (url === REDIRECT_BACK) {\n      url = this.#request.headers.get(\"Referer\") ?? String(alt);\n    } else if (typeof url === \"object\") {\n      url = String(url);\n    }\n    this.headers.set(\"Location\", encodeUrl(url));\n    if (!this.status || !isRedirectStatus(this.status)) {\n      this.status = Status.Found;\n    }\n\n    if (this.#request.accepts(\"html\")) {\n      url = encodeURI(url);\n      this.type = \"text/html; charset=UTF-8\";\n      this.body = `Redirecting to <a href=\"${url}\">${url}</a>.`;\n      return;\n    }\n    this.type = \"text/plain; charset=UTF-8\";\n    this.body = `Redirecting to ${url}.`;\n  }\n\n  async toDomResponse(): Promise<globalThis.Response> {\n    if (this.#domResponse) {\n      return this.#domResponse;\n    }\n\n    const bodyInit = await this.#getBodyInit();\n\n    this.#setContentType();\n\n    const { headers } = this;\n\n    // If there is no body and no content type and no set length, then set the\n    // content length to 0\n    if (\n      !(\n        bodyInit ||\n        headers.has(\"Content-Type\") ||\n        headers.has(\"Content-Length\")\n      )\n    ) {\n      headers.append(\"Content-Length\", \"0\");\n    }\n\n    this.#writable = false;\n\n    const status = this.status;\n    const responseInit: ResponseInit = {\n      headers,\n      status,\n      statusText: STATUS_TEXT[status],\n    };\n\n    return this.#domResponse = new DomResponse(bodyInit, responseInit);\n  }\n\n  /** Instead of responding based on the values of the response, explicitly set\n   * the response with a Fetch API `Response`.\n   *\n   * If the response is already finalized, this will throw. You can check\n   * the `.writable` property to determine the state if you are unsure.\n   *\n   * > [!NOTE]\n   * > This will ignore/override values set in the response like the body,\n   * > headers and status, meaning things like cookie management and automatic\n   * > body typing will be ignored.\n   */\n  with(response: globalThis.Response): void;\n  /** Instead of responding based on the values of the response, explicitly set\n   * the response by providing the initialization to create a Fetch API\n   * `Response`.\n   *\n   * If the response is already finalized, this will throw. You can check\n   * the `.writable` property to determine the state if you are unsure.\n   *\n   * > [!NOTE]\n   * > This will ignore/override values set in the response like the body,\n   * > headers and status, meaning things like cookie management and automatic\n   * > body typing will be ignored.\n   */\n  with(body?: BodyInit | null, init?: ResponseInit): void;\n  with(\n    responseOrBody?: globalThis.Response | BodyInit | null,\n    init?: ResponseInit,\n  ): void {\n    if (this.#domResponse || !this.#writable) {\n      throw new Error(\"A response has already been finalized.\");\n    }\n    this.#writable = false;\n    this.#domResponse = responseOrBody instanceof DomResponse\n      ? responseOrBody\n      : new DomResponse(responseOrBody, init);\n  }\n\n  [Symbol.for(\"Deno.customInspect\")](\n    inspect: (value: unknown) => string,\n  ): string {\n    const { body, headers, status, type, writable } = this;\n    return `${this.constructor.name} ${\n      inspect({ body, headers, status, type, writable })\n    }`;\n  }\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")](\n    depth: number,\n    // deno-lint-ignore no-explicit-any\n    options: any,\n    inspect: (value: unknown, options?: unknown) => string,\n    // deno-lint-ignore no-explicit-any\n  ): any {\n    if (depth < 0) {\n      return options.stylize(`[${this.constructor.name}]`, \"special\");\n    }\n\n    const newOptions = Object.assign({}, options, {\n      depth: options.depth === null ? null : options.depth - 1,\n    });\n    const { body, headers, status, type, writable } = this;\n    return `${options.stylize(this.constructor.name, \"special\")} ${\n      inspect(\n        { body, headers, status, type, writable },\n        newOptions,\n      )\n    }`;\n  }\n}\n"
        },
        {
          "name": "router.test.ts",
          "type": "blob",
          "size": 25.2724609375,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n// deno-lint-ignore-file\n\nimport {\n  assertEquals,\n  assertRejects,\n  assertStrictEquals,\n} from \"./deps_test.ts\";\nimport type { Application } from \"./application.ts\";\nimport type { Context } from \"./context.ts\";\nimport { errors, Status } from \"./deps.ts\";\nimport { Router, RouterContext } from \"./router.ts\";\n\nfunction createMockApp<\n  S extends Record<PropertyKey, any> = Record<string, any>,\n>(\n  state = {} as S,\n): Application<S> {\n  const app = {\n    state,\n    use() {\n      return app;\n    },\n  };\n  return app as any;\n}\n\nfunction createMockContext<\n  S extends Record<PropertyKey, any> = Record<string, any>,\n>(\n  app: Application<S>,\n  path = \"/\",\n  method = \"GET\",\n) {\n  const headers = new Headers();\n  return ({\n    app,\n    request: {\n      headers: new Headers(),\n      method,\n      url: new URL(path, \"https://localhost/\"),\n    },\n    response: {\n      status: undefined,\n      body: undefined,\n      redirect(url: string | URL) {\n        headers.set(\"Location\", encodeURI(String(url)));\n      },\n      headers,\n    },\n    state: app.state,\n  } as unknown) as Context<S>;\n}\n\nfunction createMockNext() {\n  return async function next() {};\n}\n\nfunction setup<\n  S extends Record<PropertyKey, any> = Record<string, any>,\n>(\n  path = \"/\",\n  method = \"GET\",\n): {\n  app: Application<S>;\n  context: Context<S>;\n  next: () => Promise<void>;\n} {\n  const app = createMockApp<S>();\n  const context = createMockContext<S>(app, path, method);\n  const next = createMockNext();\n  return { app, context, next };\n}\n\nDeno.test({\n  name: \"router empty routes\",\n  async fn() {\n    const { context, next } = setup();\n\n    const router = new Router();\n    const mw = router.routes();\n    assertEquals(await mw(context, next), undefined);\n  },\n});\n\nDeno.test({\n  name: \"router accepts non-void middleware\",\n  fn() {\n    const router = new Router();\n    router.get(\"/\", (ctx) => ctx.response.body = \"hello oak\");\n  },\n});\n\nDeno.test({\n  name: \"router get single match\",\n  async fn() {\n    const { app, context, next } = setup(\"/\", \"GET\");\n\n    const callStack: number[] = [];\n    const router = new Router();\n    router.get(\"/\", (context) => {\n      assertStrictEquals(context.router, router);\n      assertStrictEquals(context.app, app);\n      callStack.push(1);\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [1]);\n  },\n});\n\nDeno.test({\n  name: \"router match single param\",\n  async fn() {\n    const { context, next } = setup(\"/foo/bar\", \"GET\");\n\n    const callStack: number[] = [];\n    const router = new Router();\n    router.get(\"/\", (context) => {\n      callStack.push(1);\n    });\n    router.get(\"/foo\", (context) => {\n      callStack.push(2);\n    });\n    router.get(\"/foo/:id\", (context) => {\n      callStack.push(3);\n      assertEquals(context.params.id, \"bar\");\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [3]);\n  },\n});\n\nDeno.test({\n  name: \"router match with next\",\n  async fn() {\n    const { context, next } = setup(\"/foo\", \"GET\");\n\n    const callStack: number[] = [];\n    const router = new Router();\n    router.get(\"/\", (_context) => {\n      callStack.push(1);\n    });\n    router.get(\"/foo\", async (_context, next) => {\n      callStack.push(2);\n      await next();\n    });\n    router.get(\"/foo\", () => {\n      callStack.push(3);\n    });\n    router.get(\"/foo\", () => {\n      callStack.push(4);\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [2, 3]);\n  },\n});\n\nDeno.test({\n  name: \"router match delete\",\n  async fn() {\n    const { context, next } = setup(\"/\", \"DELETE\");\n\n    const callStack: number[] = [];\n    const router = new Router();\n    router.all(\"/\", async (_context, next) => {\n      callStack.push(0);\n      await next();\n    });\n    router.delete(\"/\", () => {\n      callStack.push(1);\n    });\n    router.get(\"/\", () => {\n      callStack.push(2);\n    });\n    router.head(\"/\", () => {\n      callStack.push(3);\n    });\n    router.options(\"/\", () => {\n      callStack.push(4);\n    });\n    router.patch(\"/\", () => {\n      callStack.push(5);\n    });\n    router.post(\"/\", () => {\n      callStack.push(6);\n    });\n    router.put(\"/\", () => {\n      callStack.push(7);\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [0, 1]);\n  },\n});\n\nDeno.test({\n  name: \"router match get\",\n  async fn() {\n    const { context, next } = setup(\"/\", \"GET\");\n\n    const callStack: number[] = [];\n    const router = new Router();\n    router.all(\"/\", async (_context, next) => {\n      callStack.push(0);\n      await next();\n    });\n    router.delete(\"/\", () => {\n      callStack.push(1);\n    });\n    router.get(\"/\", () => {\n      callStack.push(2);\n    });\n    router.head(\"/\", () => {\n      callStack.push(3);\n    });\n    router.options(\"/\", () => {\n      callStack.push(4);\n    });\n    router.patch(\"/\", () => {\n      callStack.push(5);\n    });\n    router.post(\"/\", () => {\n      callStack.push(6);\n    });\n    router.put(\"/\", () => {\n      callStack.push(7);\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [0, 2]);\n  },\n});\n\nDeno.test({\n  name: \"router match head\",\n  async fn() {\n    const { context, next } = setup(\"/\", \"HEAD\");\n\n    const callStack: number[] = [];\n    const router = new Router();\n    router.all(\"/\", async (_context, next) => {\n      callStack.push(0);\n      await next();\n    });\n    router.delete(\"/\", () => {\n      callStack.push(1);\n    });\n    router.head(\"/\", () => {\n      callStack.push(3);\n    });\n    router.get(\"/\", () => {\n      callStack.push(2);\n    });\n    router.options(\"/\", () => {\n      callStack.push(4);\n    });\n    router.patch(\"/\", () => {\n      callStack.push(5);\n    });\n    router.post(\"/\", () => {\n      callStack.push(6);\n    });\n    router.put(\"/\", () => {\n      callStack.push(7);\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [0, 3]);\n  },\n});\n\nDeno.test({\n  name: \"router match options\",\n  async fn() {\n    const { context, next } = setup(\"/\", \"OPTIONS\");\n\n    const callStack: number[] = [];\n    const router = new Router();\n    router.delete(\"/\", () => {\n      callStack.push(1);\n    });\n    router.get(\"/\", () => {\n      callStack.push(2);\n    });\n    router.head(\"/\", () => {\n      callStack.push(3);\n    });\n    router.options(\"/\", () => {\n      callStack.push(4);\n    });\n    router.patch(\"/\", () => {\n      callStack.push(5);\n    });\n    router.post(\"/\", () => {\n      callStack.push(6);\n    });\n    router.put(\"/\", () => {\n      callStack.push(7);\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [4]);\n  },\n});\n\nDeno.test({\n  name: \"router match patch\",\n  async fn() {\n    const { context, next } = setup(\"/\", \"PATCH\");\n\n    const callStack: number[] = [];\n    const router = new Router();\n    router.delete(\"/\", () => {\n      callStack.push(1);\n    });\n    router.get(\"/\", () => {\n      callStack.push(2);\n    });\n    router.head(\"/\", () => {\n      callStack.push(3);\n    });\n    router.options(\"/\", () => {\n      callStack.push(4);\n    });\n    router.patch(\"/\", () => {\n      callStack.push(5);\n    });\n    router.post(\"/\", () => {\n      callStack.push(6);\n    });\n    router.put(\"/\", () => {\n      callStack.push(7);\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [5]);\n  },\n});\n\nDeno.test({\n  name: \"router match post\",\n  async fn() {\n    const { context, next } = setup(\"/\", \"POST\");\n\n    const callStack: number[] = [];\n    const router = new Router();\n    router.all(\"/\", async (_context, next) => {\n      callStack.push(0);\n      await next();\n    });\n    router.delete(\"/\", () => {\n      callStack.push(1);\n    });\n    router.get(\"/\", () => {\n      callStack.push(2);\n    });\n    router.head(\"/\", () => {\n      callStack.push(3);\n    });\n    router.options(\"/\", () => {\n      callStack.push(4);\n    });\n    router.patch(\"/\", () => {\n      callStack.push(5);\n    });\n    router.post(\"/\", () => {\n      callStack.push(6);\n    });\n    router.put(\"/\", () => {\n      callStack.push(7);\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [0, 6]);\n  },\n});\n\nDeno.test({\n  name: \"router match put\",\n  async fn() {\n    const { context, next } = setup(\"/\", \"PUT\");\n\n    const callStack: number[] = [];\n    const router = new Router();\n    router.all(\"/\", async (_context, next) => {\n      callStack.push(0);\n      await next();\n    });\n    router.delete(\"/\", () => {\n      callStack.push(1);\n    });\n    router.get(\"/\", () => {\n      callStack.push(2);\n    });\n    router.head(\"/\", () => {\n      callStack.push(3);\n    });\n    router.options(\"/\", () => {\n      callStack.push(4);\n    });\n    router.patch(\"/\", () => {\n      callStack.push(5);\n    });\n    router.post(\"/\", () => {\n      callStack.push(6);\n    });\n    router.put(\"/\", () => {\n      callStack.push(7);\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [0, 7]);\n  },\n});\n\nDeno.test({\n  name: \"router match using add\",\n  async fn() {\n    const { context, next } = setup(\"/\", \"PUT\");\n\n    const callStack: number[] = [];\n    const router = new Router();\n    router.all(\"/\", (_ctx, next) => {\n      callStack.push(0);\n      return next();\n    });\n    router.add(\"PUT\", \"/\", (_ctx, next) => {\n      callStack.push(1);\n      return next();\n    });\n    router.add([\"PUT\", \"GET\"], \"/\", (_ctx, next) => {\n      callStack.push(2);\n      return next();\n    });\n    router.add(\"POST\", \"/\", (_ctx, next) => {\n      callStack.push(3);\n      return next();\n    });\n    router.add([\"POST\"], \"/\", (_ctx, next) => {\n      callStack.push(4);\n      return next();\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [0, 1, 2]);\n  },\n});\n\nDeno.test({\n  name: \"router patch prefix\",\n  async fn() {\n    const { context, next } = setup(\"/route1/action1\", \"GET\");\n    const callStack: number[] = [];\n    const router = new Router({ prefix: \"/route1\" });\n    router.get(\"/action1\", () => {\n      callStack.push(0);\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [0]);\n  },\n});\n\nDeno.test({\n  name: \"router match strict\",\n  async fn() {\n    const { context, next } = setup(\"/route\", \"GET\");\n    const callStack: number[] = [];\n    const router = new Router({ strict: true });\n    router.get(\"/route\", () => {\n      callStack.push(0);\n    });\n    router.get(\"/route/\", () => {\n      callStack.push(1);\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [0]);\n  },\n});\n\nDeno.test({\n  name: \"router match encoded path\",\n  async fn() {\n    const { context, next } = setup(\"/user%2f1\", \"GET\");\n    const callStack: number[] = [];\n    const router = new Router();\n    router.get(\"/user/:id\", () => {\n      callStack.push(0);\n    });\n    router.get(\"/:path\", () => {\n      callStack.push(1);\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [1]);\n  },\n});\n\nDeno.test({\n  name: \"router as iterator\",\n  fn() {\n    const router = new Router();\n    router.all(\"/route\", () => {});\n    router.delete(\"/route/:id\", () => {});\n    router.patch(\"/route/:id\", () => {});\n    const routes = [...router];\n    assertEquals(routes.length, 3);\n    assertEquals(routes[0].path, \"/route\");\n    assertEquals(routes[0].methods, [\n      \"HEAD\",\n      \"DELETE\",\n      \"GET\",\n      \"HEAD\",\n      \"PATCH\",\n      \"POST\",\n      \"PUT\",\n    ]);\n    assertEquals(routes[0].middleware.length, 1);\n  },\n});\n\nDeno.test({\n  name: \"route throws\",\n  async fn() {\n    const { context, next } = setup();\n    const router = new Router();\n    router.all(\"/\", (ctx) => {\n      ctx.throw(404);\n    });\n    const mw = router.routes();\n    await assertRejects(async () => {\n      await mw(context, next);\n    });\n  },\n});\n\nDeno.test({\n  name: \"router prefix, default route\",\n  async fn() {\n    const { context, next } = setup(\"/foo\");\n    let called = 0;\n    const router = new Router({\n      prefix: \"/foo\",\n    });\n    router.all(\"/\", () => {\n      called++;\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(called, 1);\n  },\n});\n\nDeno.test({\n  name: \"router redirect\",\n  async fn() {\n    const { context, next } = setup(\"/foo\");\n    const router = new Router();\n    router.redirect(\"/foo\", \"/bar\");\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(context.response.status, Status.Found);\n    assertEquals(context.response.headers.get(\"Location\"), \"/bar\");\n  },\n});\n\nDeno.test({\n  name: \"router redirect, 301 Moved Permanently\",\n  async fn() {\n    const { context, next } = setup(\"/foo\");\n    const router = new Router();\n    router.redirect(\"/foo\", \"/bar\", Status.MovedPermanently);\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(context.response.status, Status.MovedPermanently);\n    assertEquals(context.response.headers.get(\"Location\"), \"/bar\");\n  },\n});\n\nDeno.test({\n  name: \"router redirect, arbitrary URL\",\n  async fn() {\n    const { context, next } = setup(\"/foo\");\n    const router = new Router();\n    router.redirect(\"/foo\", \"https://example.com/\", Status.MovedPermanently);\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(context.response.status, Status.MovedPermanently);\n    assertEquals(\n      context.response.headers.get(\"Location\"),\n      \"https://example.com/\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"router param middleware\",\n  async fn() {\n    const { context, next } = setup(\"/book/1234/price\");\n    const router = new Router<{ id: string }>();\n    const callStack: string[] = [];\n    router.param(\"id\", (param, ctx, next) => {\n      callStack.push(\"param\");\n      assertEquals(param, \"1234\");\n      assertEquals(ctx.params.id, \"1234\");\n      return next();\n    });\n    router.all(\"/book/:id/price\", (ctx, next) => {\n      callStack.push(\"all\");\n      assertEquals(ctx.params.id, \"1234\");\n      return next();\n    });\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [\"param\", \"all\"]);\n  },\n});\n\nDeno.test({\n  name: \"router allowedMethods() OPTIONS\",\n  async fn() {\n    const { context, next } = setup(\"/foo\", \"OPTIONS\");\n    const router = new Router();\n    router.put(\"/foo\", (_ctx, next) => {\n      return next();\n    });\n    router.patch(\"/foo\", (_ctx, next) => {\n      return next();\n    });\n    const routes = router.routes();\n    const mw = router.allowedMethods();\n    await routes(context, next);\n    await mw(context, next);\n    assertEquals(context.response.status, Status.OK);\n    assertEquals(context.response.headers.get(\"Allow\"), \"PUT, PATCH\");\n  },\n});\n\nDeno.test({\n  name: \"router allowedMethods() Not Implemented\",\n  async fn() {\n    const { context, next } = setup(\"/foo\", \"PATCH\");\n    const router = new Router({ methods: [\"GET\"] });\n    router.get(\"/foo\", (_ctx, next) => {\n      return next();\n    });\n    const routes = router.routes();\n    const mw = router.allowedMethods();\n    await routes(context, next);\n    await mw(context, next);\n    assertEquals(context.response.status, Status.NotImplemented);\n  },\n});\n\nDeno.test({\n  name: \"router allowedMethods() Method Not Allowed\",\n  async fn() {\n    const { context, next } = setup(\"/foo\", \"PUT\");\n    const router = new Router();\n    router.get(\"/foo\", (_ctx, next) => {\n      return next();\n    });\n    const routes = router.routes();\n    const mw = router.allowedMethods();\n    await routes(context, next);\n    await mw(context, next);\n    assertEquals(context.response.status, Status.MethodNotAllowed);\n  },\n});\n\nDeno.test({\n  name: \"router allowedMethods() throws Not Implemented\",\n  async fn() {\n    const { context, next } = setup(\"/foo\", \"PATCH\");\n    const router = new Router({ methods: [\"GET\"] });\n    router.get(\"/foo\", (_ctx, next) => {\n      return next();\n    });\n    const routes = router.routes();\n    const mw = router.allowedMethods({ throw: true });\n    await routes(context, next);\n    await assertRejects(async () => {\n      await mw(context, next);\n    }, errors.NotImplemented);\n  },\n});\n\nDeno.test({\n  name: \"router allowedMethods() throws Method Not Allowed\",\n  async fn() {\n    const { context, next } = setup(\"/foo\", \"PUT\");\n    const router = new Router();\n    router.get(\"/foo\", (_ctx, next) => {\n      return next();\n    });\n    const routes = router.routes();\n    const mw = router.allowedMethods({ throw: true });\n    await routes(context, next);\n    await assertRejects(async () => {\n      await mw(context, next);\n    }, errors.MethodNotAllowed);\n  },\n});\n\nDeno.test({\n  name: \"router allowedMethods() with all() route uses all methods\",\n  async fn() {\n    const { context, next } = setup(\"/foo\", \"OPTIONS\");\n    const router = new Router();\n    router.all(\"/foo\", (_ctx, next) => {\n      return next();\n    });\n    const routes = router.routes();\n    const mw = router.allowedMethods();\n    await routes(context, next);\n    await mw(context, next);\n    assertEquals(context.response.status, Status.OK);\n    assertEquals(\n      context.response.headers.get(\"Allow\"),\n      \"HEAD, DELETE, GET, PATCH, POST, PUT\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"router named route - get URL\",\n  fn() {\n    const router = new Router<{ id: string }>();\n    router.get(\"get_book\", \"/book/:id\", (ctx, next) => next());\n    assertEquals(router.url(\"get_book\", { id: \"1234\" }), \"/book/1234\");\n    assertEquals(\n      router.url(\"get_book\", { id: \"1234\" }, { query: { sort: \"ASC\" } }),\n      \"/book/1234?sort=ASC\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"router types\",\n  fn() {\n    const app = createMockApp<{ id: string }>();\n    const router = new Router();\n\n    app.use(\n      router.get(\n        \"/:id\",\n        (ctx) => {\n          ctx.params.id;\n          ctx.state.session;\n        },\n      ).get(\"/:id/names\", (ctx) => {\n        ctx.params.id;\n        ctx.state.session;\n      }).put(\"/:page\", (ctx) => {\n        ctx.params.page;\n      }).put(\"/value\", (ctx) => {\n        ctx.params.id;\n        ctx.params.page;\n        ctx.state.session;\n      }).post<{ id: string }>(\"/:id\\\\:archive\", (ctx) => {\n        ctx.params.id;\n        // @ts-expect-error\n        ctx.params[\"id:archive\"];\n        // @ts-expect-error\n        ctx.params[\"id\\\\:archive\"];\n      }).routes(),\n    ).use((ctx) => {\n      ctx.state.id;\n    });\n  },\n});\n\nDeno.test({\n  name: \"router state types\",\n  fn() {\n    const router = new Router<{ foo: string }>();\n    router.patch<{ id: string }>(\n      \"/:id\\\\:archive\",\n      (ctx) => {\n        ctx.params.id;\n        ctx.state.foo;\n      },\n      (ctx) => {\n        ctx.params.id;\n        ctx.state.foo;\n      },\n    );\n  },\n});\n\nDeno.test({\n  name: \"middleware returned from router.routes() passes next\",\n  async fn() {\n    const { context } = setup(\"/foo\", \"GET\");\n\n    const callStack: number[] = [];\n\n    async function next() {\n      callStack.push(4);\n    }\n\n    const router = new Router();\n    router.get(\"/\", (_context) => {\n      callStack.push(1);\n    });\n    router.get(\"/foo\", async (_context, next) => {\n      callStack.push(2);\n      await next();\n    });\n    router.get(\"/foo\", async (_context, next) => {\n      callStack.push(3);\n      await next();\n    });\n\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [2, 3, 4]);\n  },\n});\n\nDeno.test({\n  name: \"router routes decode pathname before matching\",\n  async fn() {\n    const path = encodeURIComponent(\"chne\");\n    const { context } = setup(`/${path}`, \"GET\");\n\n    const callStack: number[] = [];\n\n    async function next() {\n      callStack.push(3);\n    }\n\n    const router = new Router();\n    router.get(\"/chne\", () => {\n      callStack.push(2);\n    });\n\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [2]);\n  },\n});\n\nDeno.test({\n  name: \"router handling of bad request urls\",\n  async fn() {\n    const headers = new Headers();\n    const app = createMockApp<{ id: string }>();\n    let context = ({\n      app,\n      request: {\n        headers: new Headers(),\n        method: \"GET\",\n        get url() {\n          throw new TypeError(\"bad url\");\n        },\n      },\n      response: {\n        status: undefined,\n        body: undefined,\n        redirect(url: string | URL) {\n          headers.set(\"Location\", encodeURI(String(url)));\n        },\n        headers,\n      },\n      state: app.state,\n    } as unknown) as Context<{ id: string }>;\n\n    const callStack: number[] = [];\n    async function next() {\n      callStack.push(1);\n    }\n\n    const router = new Router();\n    router.get(\"/a\", () => {\n      callStack.push(2);\n    });\n\n    const mw = router.routes();\n    assertRejects(\n      async () => await mw(context, next),\n      TypeError,\n      \"bad url\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"sub router get single match\",\n  async fn() {\n    const { app, context, next } = setup(\"/foo/bar\", \"GET\");\n\n    const callStack: number[] = [];\n    const router = new Router();\n    const subRouter = new Router();\n    const subSubRouter = new Router();\n    subSubRouter.get(\"/\", (context) => {\n      assertStrictEquals(context.router, router);\n      assertStrictEquals(context.app, app);\n      callStack.push(1);\n    });\n    subRouter.use(\"/bar\", subSubRouter.routes());\n    router.use(\"/foo\", subRouter.routes());\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [1]);\n    assertStrictEquals((context as RouterContext<\"/foo/bar\">).router, router);\n  },\n});\n\nDeno.test({\n  name: \"sub router match with next\",\n  async fn() {\n    const { context, next } = setup(\"/foo/bar/baz\", \"GET\");\n\n    const callStack: number[] = [];\n    const router = new Router();\n    const subRouter = new Router();\n    const subSubRouter = new Router();\n    subSubRouter.get(\"/\", () => {\n      callStack.push(3);\n    });\n    subSubRouter.get(\"/baz\", async (ctx, next) => {\n      callStack.push(4);\n      await next();\n    });\n    subSubRouter.get(\"/baz\", () => {\n      callStack.push(5);\n    });\n    subSubRouter.get(\"/baz\", () => {\n      callStack.push(6);\n    });\n    subRouter.get(\"/bar/(.*)\", async (ctx, next) => {\n      callStack.push(2);\n      await next();\n    });\n    subRouter.use(\"/bar\", subSubRouter.routes());\n    router.get(\"/foo/(.*)\", async (ctx, next) => {\n      callStack.push(1);\n      await next();\n    });\n    router.use(\"/foo\", subRouter.routes());\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [1, 2, 4, 5]);\n  },\n});\n\nDeno.test({\n  name: \"sub router match single param\",\n  async fn() {\n    const { context, next } = setup(\"/foo/bar/baz/beep\", \"GET\");\n\n    const callStack: number[] = [];\n    const router = new Router();\n    const subRouter = new Router();\n    const subSubRouter = new Router();\n    subSubRouter.get(\"/\", (context) => {\n      assertEquals(context.params.id, \"bar\");\n      assertEquals(context.params.name, \"beep\");\n      callStack.push(1);\n    });\n    subRouter.get(\"/baz\", () => {\n      callStack.push(2);\n    });\n    subRouter.use(\"/baz/:name\", subSubRouter.routes());\n    router.get(\"/foo\", () => {\n      callStack.push(3);\n    });\n    router.use(\"/foo/:id\", subRouter.routes());\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [1]);\n    assertStrictEquals((context as RouterContext<string>).router, router);\n  },\n});\n\nDeno.test({\n  name: \"sub router patch prefix with param\",\n  async fn() {\n    const { context, next } = setup(\"/foo/bar/baz\", \"GET\");\n    const callStack: number[] = [];\n    const router = new Router();\n    const subRouter = new Router({ prefix: \"/:bar\" });\n    subRouter.get(\"/baz\", (ctx) => {\n      assertEquals(ctx.params.bar, \"bar\");\n      callStack.push(0);\n    });\n    router.use(\"/foo\", subRouter.routes());\n    const mw = router.routes();\n    await mw(context, next);\n    assertEquals(callStack, [0]);\n  },\n});\n\nDeno.test({\n  name: \"sub router match layer prefix\",\n  async fn() {\n    let callStack: number[] = [];\n    let matches: string[] = [];\n    const router = new Router();\n    const subRouter = new Router();\n    const subSubRouter = new Router();\n\n    subSubRouter.get(\"/bar\", async (ctx, next) => {\n      callStack.push(1);\n      matches.push(...(ctx.matched?.map((layer) => layer.path) ?? []));\n      await next();\n    });\n    subRouter.use(subSubRouter.routes());\n    subRouter.use(\"(.*)\", subSubRouter.routes());\n    router.use(\"/foo\", subRouter.routes());\n    const mw = router.routes();\n\n    const { context, next } = setup(\"/foo/bar\", \"GET\");\n    await mw(context, next);\n    assertEquals(callStack, [1, 1]);\n    assertEquals(matches, [\n      \"/foo/bar\",\n      \"/foo(.*)/bar\",\n      \"/foo/bar\",\n      \"/foo(.*)/bar\",\n    ]);\n    assertStrictEquals((context as RouterContext<string>).router, router);\n\n    callStack = [];\n    matches = [];\n\n    const { context: context2, next: next2 } = setup(\"/foo/123/bar\", \"GET\");\n    await mw(context2, next2);\n    assertEquals(callStack, [1]);\n    assertEquals(matches, [\n      \"/foo(.*)/bar\",\n    ]);\n    assertStrictEquals((context2 as RouterContext<string>).router, router);\n  },\n});\n\nDeno.test({\n  name: \"router - type checking - ensure at least one middleware is passed\",\n  fn() {\n    const router = new Router();\n\n    try {\n      // @ts-expect-error\n      router.all(\"/\");\n      // @ts-expect-error\n      router.delete(\"/\");\n      // @ts-expect-error\n      router.get(\"/\");\n      // @ts-expect-error\n      router.head(\"/\");\n      // @ts-expect-error\n      router.options(\"/\");\n      // @ts-expect-error\n      router.patch(\"/\");\n      // @ts-expect-error\n      router.post(\"/\");\n      // @ts-expect-error\n      router.put(\"/\");\n      // @ts-expect-error\n      router.use();\n    } catch {\n      //\n    }\n  },\n});\n"
        },
        {
          "name": "router.ts",
          "type": "blob",
          "size": 42.97265625,
          "content": "/**\n * Contains the router of oak. Typical usage is the creation of an application\n * instance, the creation of a router instance, registration of route\n * middleware, registration of router with the application, and then starting to\n * listen for requests.\n *\n * # Example\n *\n * ```ts\n * import { Application } from \"jsr:@oak/oak/application\";\n * import { Router } from \"jsr:@oak/oak/router\";\n *\n * const app = new Application();\n * const router = new Router();\n * router.get(\"/\", (ctx) => {\n *   ctx.response.body = \"hello world!\";\n * });\n * app.use(router.routes());\n * app.use(router.allowedMethods());\n *\n * app.listen();\n * ```\n *\n * @module\n */\n\n/**\n * Adapted directly from @koa/router at\n * https://github.com/koajs/router/ which is licensed as:\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2015 Alexander C. Mingoia\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nimport type { State } from \"./application.ts\";\nimport type { Context } from \"./context.ts\";\nimport {\n  assert,\n  compile,\n  errors,\n  type HTTPMethods,\n  type Key,\n  type ParseOptions,\n  pathParse,\n  pathToRegexp,\n  type RedirectStatus,\n  Status,\n  type TokensToRegexpOptions,\n} from \"./deps.ts\";\nimport { compose, type Middleware } from \"./middleware.ts\";\nimport { decode } from \"./utils/decode.ts\";\nimport { decodeComponent } from \"./utils/decode_component.ts\";\n\ninterface Matches<R extends string> {\n  path: Layer<R>[];\n  pathAndMethod: Layer<R>[];\n  route: boolean;\n  name?: string;\n}\n\n/** Options which can be specified when calling the `.allowedMethods()` method\n * on a {@linkcode Router} instance. */\nexport interface RouterAllowedMethodsOptions {\n  /** Use the value returned from this function instead of an HTTP error\n   * `MethodNotAllowed`. */\n  // deno-lint-ignore no-explicit-any\n  methodNotAllowed?(): any;\n\n  /** Use the value returned from this function instead of an HTTP error\n   * `NotImplemented`. */\n  // deno-lint-ignore no-explicit-any\n  notImplemented?(): any;\n\n  /** When dealing with a non-implemented method or a method not allowed, throw\n   * an error instead of setting the status and header for the response. */\n  throw?: boolean;\n}\n\n/** The internal abstraction of a route used by the oak {@linkcode Router}. */\nexport interface Route<\n  R extends string,\n  P extends RouteParams<R> = RouteParams<R>,\n  // deno-lint-ignore no-explicit-any\n  S extends State = Record<string, any>,\n> {\n  /** The HTTP methods that this route handles. */\n  methods: HTTPMethods[];\n\n  /** The middleware that will be applied to this route. */\n  middleware: RouterMiddleware<R, P, S>[];\n\n  /** An optional name for the route. */\n  name?: string;\n\n  /** Options that were used to create the route. */\n  options: LayerOptions;\n\n  /** The parameters that are identified in the route that will be parsed out\n   * on matched requests. */\n  paramNames: (keyof P)[];\n\n  /** The path that this route manages. */\n  path: string;\n\n  /** The regular expression used for matching and parsing parameters for the\n   * route. */\n  regexp: RegExp;\n}\n\n/** The context passed router middleware.  */\nexport interface RouterContext<\n  R extends string,\n  P extends RouteParams<R> = RouteParams<R>,\n  // deno-lint-ignore no-explicit-any\n  S extends State = Record<string, any>,\n> extends Context<S> {\n  /** When matching the route, an array of the capturing groups from the regular\n   * expression. */\n  captures: string[];\n\n  /** The routes that were matched for this request. */\n  matched?: Layer<R, P, S>[];\n\n  /** Any parameters parsed from the route when matched. */\n  params: P;\n\n  /** A reference to the router instance. */\n  router: Router;\n\n  /** If the matched route has a `name`, the matched route name is provided\n   * here. */\n  routeName?: string;\n\n  /** Overrides the matched path for future route middleware, when a\n   * `routerPath` option is not defined on the `Router` options. */\n  routerPath?: string;\n}\n\n/** The interface that {@linkcode Router} middleware should adhere to. */\nexport interface RouterMiddleware<\n  R extends string,\n  P extends RouteParams<R> = RouteParams<R>,\n  // deno-lint-ignore no-explicit-any\n  S extends State = Record<string, any>,\n> {\n  (context: RouterContext<R, P, S>, next: () => Promise<unknown>):\n    | Promise<unknown>\n    | unknown;\n  /** For route parameter middleware, the `param` key for this parameter will\n   * be set. */\n  param?: keyof P;\n  // deno-lint-ignore no-explicit-any\n  router?: Router<any>;\n}\n\n/** Options which can be specified when creating a new instance of a\n * {@linkcode Router}. */\nexport interface RouterOptions {\n  /** Override the default set of methods supported by the router. */\n  methods?: HTTPMethods[];\n\n  /** Only handle routes where the requested path starts with the prefix. */\n  prefix?: string;\n\n  /** Override the `request.url.pathname` when matching middleware to run. */\n  routerPath?: string;\n\n  /** Determines if routes are matched in a case sensitive way.  Defaults to\n   * `false`. */\n  sensitive?: boolean;\n\n  /** Determines if routes are matched strictly, where the trailing `/` is not\n   * optional.  Defaults to `false`. */\n  strict?: boolean;\n}\n\n/** Middleware that will be called by the router when handling a specific\n * parameter, which the middleware will be called when a request matches the\n * route parameter. */\nexport interface RouterParamMiddleware<\n  R extends string,\n  P extends RouteParams<R> = RouteParams<R>,\n  // deno-lint-ignore no-explicit-any\n  S extends State = Record<string, any>,\n> {\n  (\n    param: string,\n    context: RouterContext<R, P, S>,\n    next: () => Promise<unknown>,\n  ): Promise<unknown> | unknown;\n  // deno-lint-ignore no-explicit-any\n  router?: Router<any>;\n}\n\ninterface ParamsDictionary {\n  [key: string]: string;\n}\n\ntype RemoveTail<S extends string, Tail extends string> = S extends\n  `${infer P}${Tail}` ? P : S;\n\ntype GetRouteParams<S extends string> = RemoveTail<\n  RemoveTail<RemoveTail<S, `/${string}`>, `-${string}`>,\n  `.${string}`\n>;\n\n/** A dynamic type which attempts to determine the route params based on\n * matching the route string. */\nexport type RouteParams<Route extends string> = string extends Route\n  ? ParamsDictionary\n  : Route extends `${string}(${string}` ? ParamsDictionary\n  : Route extends `${string}:${infer Rest}` ?\n      & (\n        GetRouteParams<Rest> extends never ? ParamsDictionary\n          : GetRouteParams<Rest> extends `${infer ParamName}?`\n            ? { [P in ParamName]?: string }\n          : { [P in GetRouteParams<Rest>]: string }\n      )\n      & (Rest extends `${GetRouteParams<Rest>}${infer Next}` ? RouteParams<Next>\n        : unknown)\n  : Record<string | number, string | undefined>;\n\ntype LayerOptions = TokensToRegexpOptions & ParseOptions & {\n  ignoreCaptures?: boolean;\n  name?: string;\n};\n\ntype RegisterOptions = LayerOptions & {\n  ignorePrefix?: boolean;\n};\n\ntype UrlOptions = TokensToRegexpOptions & ParseOptions & {\n  /** When generating a URL from a route, add the query to the URL.  If an\n   * object */\n  query?: URLSearchParams | Record<string, string> | string;\n};\n\n/** Generate a URL from a string, potentially replace route params with\n * values. */\nfunction toUrl<R extends string>(\n  url: string,\n  params = {} as RouteParams<R>,\n  options?: UrlOptions,\n) {\n  const tokens = pathParse(url);\n  let replace = {} as RouteParams<R>;\n\n  if (tokens.some((token) => typeof token === \"object\")) {\n    replace = params;\n  } else {\n    options = params;\n  }\n\n  const toPath = compile(url, options);\n  const replaced = toPath(replace);\n\n  if (options && options.query) {\n    const url = new URL(replaced, \"http://oak\");\n    if (typeof options.query === \"string\") {\n      url.search = options.query;\n    } else {\n      url.search = String(\n        options.query instanceof URLSearchParams\n          ? options.query\n          : new URLSearchParams(options.query),\n      );\n    }\n    return `${url.pathname}${url.search}${url.hash}`;\n  }\n  return replaced;\n}\n\n/** An internal class used to group together middleware when using multiple\n * middlewares with a router. */\nexport class Layer<\n  R extends string,\n  P extends RouteParams<R> = RouteParams<R>,\n  // deno-lint-ignore no-explicit-any\n  S extends State = Record<string, any>,\n> {\n  #opts: LayerOptions;\n  #paramNames: Key[] = [];\n  #regexp: RegExp;\n\n  methods: HTTPMethods[];\n  name?: string;\n  path: string;\n  stack: RouterMiddleware<R, P, S>[];\n\n  constructor(\n    path: string,\n    methods: HTTPMethods[],\n    middleware: RouterMiddleware<R, P, S> | RouterMiddleware<R, P, S>[],\n    { name, ...opts }: LayerOptions = {},\n  ) {\n    this.#opts = opts;\n    this.name = name;\n    this.methods = [...methods];\n    if (this.methods.includes(\"GET\")) {\n      this.methods.unshift(\"HEAD\");\n    }\n    this.stack = Array.isArray(middleware) ? middleware.slice() : [middleware];\n    this.path = path;\n    this.#regexp = pathToRegexp(path, this.#paramNames, this.#opts);\n  }\n\n  clone(): Layer<R, P, S> {\n    return new Layer(\n      this.path,\n      this.methods,\n      this.stack,\n      { name: this.name, ...this.#opts },\n    );\n  }\n\n  match(path: string): boolean {\n    return this.#regexp.test(path);\n  }\n\n  params(\n    captures: string[],\n    existingParams: RouteParams<R> = {} as RouteParams<R>,\n  ): RouteParams<R> {\n    const params = existingParams;\n    for (let i = 0; i < captures.length; i++) {\n      if (this.#paramNames[i]) {\n        const c = captures[i];\n        params[this.#paramNames[i].name] = c ? decodeComponent(c) : c;\n      }\n    }\n    return params;\n  }\n\n  captures(path: string): string[] {\n    if (this.#opts.ignoreCaptures) {\n      return [];\n    }\n    return path.match(this.#regexp)?.slice(1) ?? [];\n  }\n\n  url(\n    params: RouteParams<R> = {} as RouteParams<R>,\n    options?: UrlOptions,\n  ): string {\n    const url = this.path.replace(/\\(\\.\\*\\)/g, \"\");\n    return toUrl(url, params, options);\n  }\n\n  param(\n    param: string,\n    // deno-lint-ignore no-explicit-any\n    fn: RouterParamMiddleware<any, any, any>,\n  ): this {\n    const stack = this.stack;\n    const params = this.#paramNames;\n    const middleware: RouterMiddleware<R> = function (\n      this: Router,\n      ctx,\n      next,\n    ): Promise<unknown> | unknown {\n      const p = ctx.params[param];\n      assert(p);\n      return fn.call(this, p, ctx, next);\n    };\n    middleware.param = param;\n\n    const names = params.map((p) => p.name);\n\n    const x = names.indexOf(param);\n    if (x >= 0) {\n      for (let i = 0; i < stack.length; i++) {\n        const fn = stack[i];\n        if (!fn.param || names.indexOf(fn.param as (string | number)) > x) {\n          stack.splice(i, 0, middleware);\n          break;\n        }\n      }\n    }\n    return this;\n  }\n\n  setPrefix(prefix: string): this {\n    if (this.path) {\n      this.path = this.path !== \"/\" || this.#opts.strict === true\n        ? `${prefix}${this.path}`\n        : prefix;\n      this.#paramNames = [];\n      this.#regexp = pathToRegexp(this.path, this.#paramNames, this.#opts);\n    }\n    return this;\n  }\n\n  // deno-lint-ignore no-explicit-any\n  toJSON(): Route<any, any, any> {\n    return {\n      methods: [...this.methods],\n      middleware: [...this.stack],\n      paramNames: this.#paramNames.map((key) => key.name),\n      path: this.path,\n      regexp: this.#regexp,\n      options: { ...this.#opts },\n    };\n  }\n\n  [Symbol.for(\"Deno.customInspect\")](\n    inspect: (value: unknown) => string,\n  ): string {\n    return `${this.constructor.name} ${\n      inspect({\n        methods: this.methods,\n        middleware: this.stack,\n        options: this.#opts,\n        paramNames: this.#paramNames.map((key) => key.name),\n        path: this.path,\n        regexp: this.#regexp,\n      })\n    }`;\n  }\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")](\n    depth: number,\n    // deno-lint-ignore no-explicit-any\n    options: any,\n    inspect: (value: unknown, options?: unknown) => string,\n    // deno-lint-ignore no-explicit-any\n  ): any {\n    if (depth < 0) {\n      return options.stylize(`[${this.constructor.name}]`, \"special\");\n    }\n\n    const newOptions = Object.assign({}, options, {\n      depth: options.depth === null ? null : options.depth - 1,\n    });\n    return `${options.stylize(this.constructor.name, \"special\")} ${\n      inspect(\n        {\n          methods: this.methods,\n          middleware: this.stack,\n          options: this.#opts,\n          paramNames: this.#paramNames.map((key) => key.name),\n          path: this.path,\n          regexp: this.#regexp,\n        },\n        newOptions,\n      )\n    }`;\n  }\n}\n\n/** An interface for registering middleware that will run when certain HTTP\n * methods and paths are requested, as well as provides a way to parameterize\n * parts of the requested path.\n *\n * ### Basic example\n *\n * ```ts\n * import { Application, Router } from \"jsr:@oak/oak/\";\n *\n * const router = new Router();\n * router.get(\"/\", (ctx, next) => {\n *   // handle the GET endpoint here\n * });\n * router.all(\"/item/:item\", (ctx, next) => {\n *   // called for all HTTP verbs/requests\n *   ctx.params.item; // contains the value of `:item` from the parsed URL\n * });\n *\n * const app = new Application();\n * app.use(router.routes());\n * app.use(router.allowedMethods());\n *\n * app.listen({ port: 8080 });\n * ```\n */\nexport class Router<\n  // deno-lint-ignore no-explicit-any\n  RS extends State = Record<string, any>,\n> {\n  #opts: RouterOptions;\n  #methods: HTTPMethods[];\n  // deno-lint-ignore no-explicit-any\n  #params: Record<string, RouterParamMiddleware<any, any, any>> = {};\n  #stack: Layer<string>[] = [];\n\n  #match(path: string, method: HTTPMethods): Matches<string> {\n    const matches: Matches<string> = {\n      path: [],\n      pathAndMethod: [],\n      route: false,\n    };\n\n    for (const route of this.#stack) {\n      if (route.match(path)) {\n        matches.path.push(route);\n        if (route.methods.length === 0 || route.methods.includes(method)) {\n          matches.pathAndMethod.push(route);\n          if (route.methods.length) {\n            matches.route = true;\n            matches.name = route.name;\n          }\n        }\n      }\n    }\n\n    return matches;\n  }\n\n  #register(\n    path: string | string[],\n    middlewares: RouterMiddleware<string>[],\n    methods: HTTPMethods[],\n    options: RegisterOptions = {},\n  ): void {\n    if (Array.isArray(path)) {\n      for (const p of path) {\n        this.#register(p, middlewares, methods, options);\n      }\n      return;\n    }\n\n    let layerMiddlewares: RouterMiddleware<string>[] = [];\n    for (const middleware of middlewares) {\n      if (!middleware.router) {\n        layerMiddlewares.push(middleware);\n        continue;\n      }\n\n      if (layerMiddlewares.length) {\n        this.#addLayer(path, layerMiddlewares, methods, options);\n        layerMiddlewares = [];\n      }\n\n      const router = middleware.router.#clone();\n\n      for (const layer of router.#stack) {\n        if (!options.ignorePrefix) {\n          layer.setPrefix(path);\n        }\n        if (this.#opts.prefix) {\n          layer.setPrefix(this.#opts.prefix);\n        }\n        this.#stack.push(layer);\n      }\n\n      for (const [param, mw] of Object.entries(this.#params)) {\n        router.param(param, mw);\n      }\n    }\n\n    if (layerMiddlewares.length) {\n      this.#addLayer(path, layerMiddlewares, methods, options);\n    }\n  }\n\n  #addLayer(\n    path: string,\n    middlewares: RouterMiddleware<string>[],\n    methods: HTTPMethods[],\n    options: LayerOptions = {},\n  ) {\n    const {\n      end,\n      name,\n      sensitive = this.#opts.sensitive,\n      strict = this.#opts.strict,\n      ignoreCaptures,\n    } = options;\n    const route = new Layer(path, methods, middlewares, {\n      end,\n      name,\n      sensitive,\n      strict,\n      ignoreCaptures,\n    });\n\n    if (this.#opts.prefix) {\n      route.setPrefix(this.#opts.prefix);\n    }\n\n    for (const [param, mw] of Object.entries(this.#params)) {\n      route.param(param, mw);\n    }\n\n    this.#stack.push(route);\n  }\n\n  #route(name: string): Layer<string> | undefined {\n    for (const route of this.#stack) {\n      if (route.name === name) {\n        return route;\n      }\n    }\n  }\n\n  #useVerb(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string>,\n    middleware: RouterMiddleware<string>[],\n    methods: HTTPMethods[],\n  ): void {\n    let name: string | undefined = undefined;\n    let path: string;\n    if (typeof pathOrMiddleware === \"string\") {\n      name = nameOrPath;\n      path = pathOrMiddleware;\n    } else {\n      path = nameOrPath;\n      middleware.unshift(pathOrMiddleware);\n    }\n\n    this.#register(path, middleware, methods, { name });\n  }\n\n  #clone(): Router<RS> {\n    const router = new Router<RS>(this.#opts);\n    router.#methods = router.#methods.slice();\n    router.#params = { ...this.#params };\n    router.#stack = this.#stack.map((layer) => layer.clone());\n    return router;\n  }\n\n  constructor(opts: RouterOptions = {}) {\n    this.#opts = opts;\n    this.#methods = opts.methods ?? [\n      \"DELETE\",\n      \"GET\",\n      \"HEAD\",\n      \"OPTIONS\",\n      \"PATCH\",\n      \"POST\",\n      \"PUT\",\n    ];\n  }\n\n  /** Register named middleware for the specified routes when specified methods\n   * are requested. */\n  add<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    methods: HTTPMethods[] | HTTPMethods,\n    name: string,\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the specified methods is\n   * requested. */\n  add<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    methods: HTTPMethods[] | HTTPMethods,\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the specified methods\n   * are requested with explicit path parameters. */\n  add<\n    P extends RouteParams<string>,\n    S extends State = RS,\n  >(\n    methods: HTTPMethods[] | HTTPMethods,\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  add<\n    P extends RouteParams<string> = RouteParams<string>,\n    S extends State = RS,\n  >(\n    methods: HTTPMethods[] | HTTPMethods,\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)> {\n    this.#useVerb(\n      nameOrPath,\n      pathOrMiddleware as (string | RouterMiddleware<string>),\n      middleware as RouterMiddleware<string>[],\n      typeof methods === \"string\" ? [methods] : methods,\n    );\n    return this;\n  }\n\n  /** Register named middleware for the specified routes when the `DELETE`,\n   * `GET`, `POST`, or `PUT` method is requested. */\n  all<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    name: string,\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `DELETE`,\n   * `GET`, `POST`, or `PUT` method is requested. */\n  all<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `DELETE`,\n   * `GET`, `POST`, or `PUT` method is requested with explicit path parameters.\n   */\n  all<\n    P extends RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  all<\n    P extends RouteParams<string> = RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)> {\n    this.#useVerb(\n      nameOrPath,\n      pathOrMiddleware as (string | RouterMiddleware<string>),\n      middleware as RouterMiddleware<string>[],\n      this.#methods.filter((method) => method !== \"OPTIONS\"),\n    );\n    return this;\n  }\n\n  /** Middleware that handles requests for HTTP methods registered with the\n   * router.  If none of the routes handle a method, then \"not allowed\" logic\n   * will be used.  If a method is supported by some routes, but not the\n   * particular matched router, then \"not implemented\" will be returned.\n   *\n   * The middleware will also automatically handle the `OPTIONS` method,\n   * responding with a `200 OK` when the `Allowed` header sent to the allowed\n   * methods for a given route.\n   *\n   * By default, a \"not allowed\" request will respond with a `405 Not Allowed`\n   * and a \"not implemented\" will respond with a `501 Not Implemented`. Setting\n   * the option `.throw` to `true` will cause the middleware to throw an\n   * `HTTPError` instead of setting the response status.  The error can be\n   * overridden by providing a `.notImplemented` or `.notAllowed` method in the\n   * options, of which the value will be returned will be thrown instead of the\n   * HTTP error. */\n  allowedMethods(\n    options: RouterAllowedMethodsOptions = {},\n  ): Middleware {\n    const implemented = this.#methods;\n\n    const allowedMethods: Middleware = async (context, next) => {\n      const ctx = context as RouterContext<string>;\n      await next();\n      if (!ctx.response.status || ctx.response.status === Status.NotFound) {\n        assert(ctx.matched);\n        const allowed = new Set<HTTPMethods>();\n        for (const route of ctx.matched) {\n          for (const method of route.methods) {\n            allowed.add(method);\n          }\n        }\n\n        const allowedStr = [...allowed].join(\", \");\n        if (!implemented.includes(ctx.request.method)) {\n          if (options.throw) {\n            throw options.notImplemented\n              ? options.notImplemented()\n              : new errors.NotImplemented();\n          } else {\n            ctx.response.status = Status.NotImplemented;\n            ctx.response.headers.set(\"Allow\", allowedStr);\n          }\n        } else if (allowed.size) {\n          if (ctx.request.method === \"OPTIONS\") {\n            ctx.response.status = Status.OK;\n            ctx.response.headers.set(\"Allow\", allowedStr);\n          } else if (!allowed.has(ctx.request.method)) {\n            if (options.throw) {\n              throw options.methodNotAllowed\n                ? options.methodNotAllowed()\n                : new errors.MethodNotAllowed();\n            } else {\n              ctx.response.status = Status.MethodNotAllowed;\n              ctx.response.headers.set(\"Allow\", allowedStr);\n            }\n          }\n        }\n      }\n    };\n\n    return allowedMethods;\n  }\n\n  /** Register named middleware for the specified routes when the `DELETE`,\n   *  method is requested. */\n  delete<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    name: string,\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `DELETE`,\n   * method is requested. */\n  delete<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `DELETE`,\n   * method is requested with explicit path parameters. */\n  delete<\n    P extends RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  delete<\n    P extends RouteParams<string> = RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)> {\n    this.#useVerb(\n      nameOrPath,\n      pathOrMiddleware as (string | RouterMiddleware<string>),\n      middleware as RouterMiddleware<string>[],\n      [\"DELETE\"],\n    );\n    return this;\n  }\n\n  /** Iterate over the routes currently added to the router.  To be compatible\n   * with the iterable interfaces, both the key and value are set to the value\n   * of the route. */\n  *entries(): IterableIterator<[Route<string>, Route<string>]> {\n    for (const route of this.#stack) {\n      const value = route.toJSON();\n      yield [value, value];\n    }\n  }\n\n  /** Iterate over the routes currently added to the router, calling the\n   * `callback` function for each value. */\n  forEach(\n    callback: (\n      value1: Route<string>,\n      value2: Route<string>,\n      router: this,\n    ) => void,\n    // deno-lint-ignore no-explicit-any\n    thisArg: any = null,\n  ): void {\n    for (const route of this.#stack) {\n      const value = route.toJSON();\n      callback.call(thisArg, value, value, this);\n    }\n  }\n\n  /** Register named middleware for the specified routes when the `GET`,\n   *  method is requested. */\n  get<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    name: string,\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `GET`,\n   * method is requested. */\n  get<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `GET`,\n   * method is requested with explicit path parameters. */\n  get<\n    P extends RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  get<\n    P extends RouteParams<string> = RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)> {\n    this.#useVerb(\n      nameOrPath,\n      pathOrMiddleware as (string | RouterMiddleware<string>),\n      middleware as RouterMiddleware<string>[],\n      [\"GET\"],\n    );\n    return this;\n  }\n\n  /** Register named middleware for the specified routes when the `HEAD`,\n   *  method is requested. */\n  head<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    name: string,\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `HEAD`,\n   * method is requested. */\n  head<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `HEAD`,\n   * method is requested with explicit path parameters. */\n  head<\n    P extends RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  head<\n    P extends RouteParams<string> = RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)> {\n    this.#useVerb(\n      nameOrPath,\n      pathOrMiddleware as (string | RouterMiddleware<string>),\n      middleware as RouterMiddleware<string>[],\n      [\"HEAD\"],\n    );\n    return this;\n  }\n\n  /** Iterate over the routes currently added to the router.  To be compatible\n   * with the iterable interfaces, the key is set to the value of the route. */\n  *keys(): IterableIterator<Route<string>> {\n    for (const route of this.#stack) {\n      yield route.toJSON();\n    }\n  }\n\n  /** Register named middleware for the specified routes when the `OPTIONS`,\n   * method is requested. */\n  options<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    name: string,\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `OPTIONS`,\n   * method is requested. */\n  options<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `OPTIONS`,\n   * method is requested with explicit path parameters. */\n  options<\n    P extends RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  options<\n    P extends RouteParams<string> = RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)> {\n    this.#useVerb(\n      nameOrPath,\n      pathOrMiddleware as (string | RouterMiddleware<string>),\n      middleware as RouterMiddleware<string>[],\n      [\"OPTIONS\"],\n    );\n    return this;\n  }\n\n  /** Register param middleware, which will be called when the particular param\n   * is parsed from the route. */\n  param<R extends string, S extends State = RS>(\n    param: keyof RouteParams<R>,\n    middleware: RouterParamMiddleware<R, RouteParams<R>, S>,\n  ): Router<S> {\n    this.#params[param as string] = middleware;\n    for (const route of this.#stack) {\n      route.param(param as string, middleware);\n    }\n    return this;\n  }\n\n  /** Register named middleware for the specified routes when the `PATCH`,\n   * method is requested. */\n  patch<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    name: string,\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `PATCH`,\n   * method is requested. */\n  patch<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `PATCH`,\n   * method is requested with explicit path parameters. */\n  patch<\n    P extends RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  patch<\n    P extends RouteParams<string> = RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)> {\n    this.#useVerb(\n      nameOrPath,\n      pathOrMiddleware as (string | RouterMiddleware<string>),\n      middleware as RouterMiddleware<string>[],\n      [\"PATCH\"],\n    );\n    return this;\n  }\n\n  /** Register named middleware for the specified routes when the `POST`,\n   * method is requested. */\n  post<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    name: string,\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `POST`,\n   * method is requested. */\n  post<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `POST`,\n   * method is requested with explicit path parameters. */\n  post<\n    P extends RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  post<\n    P extends RouteParams<string> = RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)> {\n    this.#useVerb(\n      nameOrPath,\n      pathOrMiddleware as (string | RouterMiddleware<string>),\n      middleware as RouterMiddleware<string>[],\n      [\"POST\"],\n    );\n    return this;\n  }\n\n  /** Set the router prefix for this router. */\n  prefix(prefix: string): this {\n    prefix = prefix.replace(/\\/$/, \"\");\n    this.#opts.prefix = prefix;\n    for (const route of this.#stack) {\n      route.setPrefix(prefix);\n    }\n    return this;\n  }\n\n  /** Register named middleware for the specified routes when the `PUT`\n   * method is requested. */\n  put<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    name: string,\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `PUT`\n   * method is requested. */\n  put<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware for the specified routes when the `PUT`\n   * method is requested with explicit path parameters. */\n  put<\n    P extends RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  put<\n    P extends RouteParams<string> = RouteParams<string>,\n    S extends State = RS,\n  >(\n    nameOrPath: string,\n    pathOrMiddleware: string | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)> {\n    this.#useVerb(\n      nameOrPath,\n      pathOrMiddleware as (string | RouterMiddleware<string>),\n      middleware as RouterMiddleware<string>[],\n      [\"PUT\"],\n    );\n    return this;\n  }\n\n  /** Register a direction middleware, where when the `source` path is matched\n   * the router will redirect the request to the `destination` path.  A `status`\n   * of `302 Found` will be set by default.\n   *\n   * The `source` and `destination` can be named routes. */\n  redirect(\n    source: string,\n    destination: string | URL,\n    status: RedirectStatus = Status.Found,\n  ): this {\n    if (source[0] !== \"/\") {\n      const s = this.url(source);\n      if (!s) {\n        throw new RangeError(`Could not resolve named route: \"${source}\"`);\n      }\n      source = s;\n    }\n    if (typeof destination === \"string\") {\n      if (destination[0] !== \"/\") {\n        const d = this.url(destination);\n        if (!d) {\n          try {\n            const url = new URL(destination);\n            destination = url;\n          } catch {\n            throw new RangeError(`Could not resolve named route: \"${source}\"`);\n          }\n        } else {\n          destination = d;\n        }\n      }\n    }\n\n    this.all(source, async (ctx, next) => {\n      await next();\n      ctx.response.redirect(destination);\n      ctx.response.status = status;\n    });\n    return this;\n  }\n\n  /** Return middleware that will do all the route processing that the router\n   * has been configured to handle.  Typical usage would be something like this:\n   *\n   * ```ts\n   * import { Application, Router } from \"jsr:@oak/oak/\";\n   *\n   * const app = new Application();\n   * const router = new Router();\n   *\n   * // register routes\n   *\n   * app.use(router.routes());\n   * app.use(router.allowedMethods());\n   * await app.listen({ port: 80 });\n   * ```\n   */\n  routes(): Middleware {\n    const dispatch = (\n      context: Context,\n      next: () => Promise<unknown>,\n    ): Promise<unknown> => {\n      const ctx = context as RouterContext<string>;\n      let pathname: string;\n      let method: HTTPMethods;\n      try {\n        const { url: { pathname: p }, method: m } = ctx.request;\n        pathname = p;\n        method = m;\n      } catch (e) {\n        return Promise.reject(e);\n      }\n      const path = this.#opts.routerPath ?? ctx.routerPath ?? decode(pathname);\n      const matches = this.#match(path, method);\n\n      if (ctx.matched) {\n        ctx.matched.push(...matches.path);\n      } else {\n        ctx.matched = [...matches.path];\n      }\n\n      // deno-lint-ignore no-explicit-any\n      ctx.router = this as Router<any>;\n\n      if (!matches.route) return next();\n\n      ctx.routeName = matches.name;\n\n      const { pathAndMethod: matchedRoutes } = matches;\n\n      const chain = matchedRoutes.reduce(\n        (prev, route) => [\n          ...prev,\n          (ctx, next) => {\n            ctx.captures = route.captures(path);\n            ctx.params = route.params(ctx.captures, ctx.params);\n            return next();\n          },\n          ...route.stack,\n        ],\n        [] as RouterMiddleware<string>[],\n      );\n      return compose(chain)(ctx, next);\n    };\n    dispatch.router = this;\n    return dispatch;\n  }\n\n  /** Generate a URL pathname for a named route, interpolating the optional\n   * params provided.  Also accepts an optional set of options. */\n  url<P extends RouteParams<string> = RouteParams<string>>(\n    name: string,\n    params?: P,\n    options?: UrlOptions,\n  ): string | undefined {\n    const route = this.#route(name);\n\n    if (route) {\n      return route.url(params, options);\n    }\n  }\n\n  /** Register middleware to be used on every matched route. */\n  use<\n    P extends RouteParams<string> = RouteParams<string>,\n    S extends State = RS,\n  >(\n    middleware: RouterMiddleware<string, P, S>,\n    ...middlewares: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware to be used on every route that matches the supplied\n   * `path`. */\n  use<\n    R extends string,\n    P extends RouteParams<R> = RouteParams<R>,\n    S extends State = RS,\n  >(\n    path: R,\n    middleware: RouterMiddleware<R, P, S>,\n    ...middlewares: RouterMiddleware<R, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  /** Register middleware to be used on every route that matches the supplied\n   * `path` with explicit path parameters. */\n  use<\n    P extends RouteParams<string>,\n    S extends State = RS,\n  >(\n    path: string,\n    middleware: RouterMiddleware<string, P, S>,\n    ...middlewares: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  use<\n    P extends RouteParams<string> = RouteParams<string>,\n    S extends State = RS,\n  >(\n    path: string[],\n    middleware: RouterMiddleware<string, P, S>,\n    ...middlewares: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)>;\n  use<\n    P extends RouteParams<string> = RouteParams<string>,\n    S extends State = RS,\n  >(\n    pathOrMiddleware: string | string[] | RouterMiddleware<string, P, S>,\n    ...middleware: RouterMiddleware<string, P, S>[]\n  ): Router<S extends RS ? S : (S & RS)> {\n    let path: string | string[] | undefined;\n    if (\n      typeof pathOrMiddleware === \"string\" || Array.isArray(pathOrMiddleware)\n    ) {\n      path = pathOrMiddleware;\n    } else {\n      middleware.unshift(pathOrMiddleware);\n    }\n\n    this.#register(\n      path ?? \"(.*)\",\n      middleware as RouterMiddleware<string>[],\n      [],\n      { end: false, ignoreCaptures: !path, ignorePrefix: !path },\n    );\n\n    return this;\n  }\n\n  /** Iterate over the routes currently added to the router. */\n  *values(): IterableIterator<Route<string, RouteParams<string>, RS>> {\n    for (const route of this.#stack) {\n      yield route.toJSON();\n    }\n  }\n\n  /** Provide an iterator interface that iterates over the routes registered\n   * with the router. */\n  *[Symbol.iterator](): IterableIterator<\n    Route<string, RouteParams<string>, RS>\n  > {\n    for (const route of this.#stack) {\n      yield route.toJSON();\n    }\n  }\n\n  /** Generate a URL pathname based on the provided path, interpolating the\n   * optional params provided.  Also accepts an optional set of options. */\n  static url<R extends string>(\n    path: R,\n    params?: RouteParams<R>,\n    options?: UrlOptions,\n  ): string {\n    return toUrl(path, params, options);\n  }\n\n  [Symbol.for(\"Deno.customInspect\")](\n    inspect: (value: unknown) => string,\n  ): string {\n    return `${this.constructor.name} ${\n      inspect({ \"#params\": this.#params, \"#stack\": this.#stack })\n    }`;\n  }\n\n  [Symbol.for(\"nodejs.util.inspect.custom\")](\n    depth: number,\n    // deno-lint-ignore no-explicit-any\n    options: any,\n    inspect: (value: unknown, options?: unknown) => string,\n    // deno-lint-ignore no-explicit-any\n  ): any {\n    if (depth < 0) {\n      return options.stylize(`[${this.constructor.name}]`, \"special\");\n    }\n\n    const newOptions = Object.assign({}, options, {\n      depth: options.depth === null ? null : options.depth - 1,\n    });\n    return `${options.stylize(this.constructor.name, \"special\")} ${\n      inspect(\n        { \"#params\": this.#params, \"#stack\": this.#stack },\n        newOptions,\n      )\n    }`;\n  }\n}\n"
        },
        {
          "name": "send.test.ts",
          "type": "blob",
          "size": 16.14453125,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\nimport {\n  assertEquals,\n  assertRejects,\n  assertStrictEquals,\n} from \"./deps_test.ts\";\nimport {\n  createMockApp,\n  createMockContext,\n  mockContextState,\n} from \"./testing.ts\";\n\nimport type { Application } from \"./application.ts\";\nimport type { Context } from \"./context.ts\";\nimport { assert, errors, eTag } from \"./deps.ts\";\nimport type { RouteParams } from \"./router.ts\";\nimport { send } from \"./send.ts\";\nimport { isNode } from \"./utils/type_guards.ts\";\nimport { httpErrors } from \"./mod.ts\";\n\nfunction setup<\n  // deno-lint-ignore no-explicit-any\n  S extends Record<PropertyKey, any> = Record<string, any>,\n>(\n  path = \"/\",\n  method = \"GET\",\n): {\n  app: Application<S>;\n  context: Context<S>;\n} {\n  mockContextState.encodingsAccepted = \"identity\";\n  // deno-lint-ignore no-explicit-any\n  const app = createMockApp<any>();\n  const context = createMockContext<string, RouteParams<string>, S>({\n    app,\n    path,\n    method,\n  });\n  return { app, context };\n}\n\nDeno.test({\n  name: \"send HTML\",\n  async fn() {\n    const { context } = setup(\"/test.html\");\n    const fixture = await Deno.readFile(\"./fixtures/test.html\");\n    await send(context, context.request.url.pathname, {\n      root: \"./fixtures\",\n      maxbuffer: 0,\n    });\n    const nativeResponse = await context.response.toDomResponse();\n    const ab = await nativeResponse.arrayBuffer();\n    assertEquals(new Uint8Array(ab), fixture);\n    assertEquals(context.response.type, \".html\");\n    assert(context.response.headers.get(\"last-modified\") != null);\n    assertEquals(context.response.headers.get(\"cache-control\"), \"max-age=0\");\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"send gzip\",\n  async fn() {\n    const { context } = setup(\"/test.json\");\n    const fixture = await Deno.readFile(\"./fixtures/test.json.gz\");\n    mockContextState.encodingsAccepted = \"gzip\";\n    await send(context, context.request.url.pathname, {\n      root: \"./fixtures\",\n      maxbuffer: 0,\n    });\n    const nativeResponse = await context.response.toDomResponse();\n    assertEquals(new Uint8Array(await nativeResponse.arrayBuffer()), fixture);\n    assertEquals(context.response.type, \".json\");\n    assertEquals(context.response.headers.get(\"content-encoding\"), \"gzip\");\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"send brotli\",\n  async fn() {\n    const { context } = setup(\"/test.json\");\n    const fixture = await Deno.readFile(\"./fixtures/test.json.br\");\n    mockContextState.encodingsAccepted = \"br\";\n    await send(context, context.request.url.pathname, {\n      root: \"./fixtures\",\n      maxbuffer: 0,\n    });\n    const nativeResponse = await context.response.toDomResponse();\n    assertEquals(new Uint8Array(await nativeResponse.arrayBuffer()), fixture);\n    assertEquals(context.response.type, \".json\");\n    assertEquals(context.response.headers.get(\"content-encoding\"), \"br\");\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"send identity\",\n  async fn() {\n    const { context } = setup(\"/test.json\");\n    const fixture = await Deno.readFile(\"./fixtures/test.json\");\n    await send(context, context.request.url.pathname, {\n      root: \"./fixtures\",\n      maxbuffer: 0,\n    });\n    const nativeResponse = await context.response.toDomResponse();\n    assertEquals(new Uint8Array(await nativeResponse.arrayBuffer()), fixture);\n    assertEquals(context.response.type, \".json\");\n    assertStrictEquals(context.response.headers.get(\"content-encoding\"), null);\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"send 404\",\n  async fn() {\n    const { context } = setup(\"/foo.txt\");\n    mockContextState.encodingsAccepted = \"identity\";\n    let didThrow = false;\n    try {\n      await send(context, context.request.url.pathname, {\n        root: \"./fixtures\",\n      });\n    } catch (e) {\n      assert(e instanceof errors.NotFound);\n      didThrow = true;\n    }\n    assert(didThrow);\n  },\n});\n\nDeno.test({\n  name: \"send file with spaces\",\n  async fn() {\n    const { context } = setup(\"/test%20file.json\");\n    const fixture = await Deno.readFile(\"./fixtures/test file.json\");\n    await send(context, context.request.url.pathname, {\n      root: \"./fixtures\",\n      maxbuffer: 0,\n    });\n    const nativeResponse = await context.response.toDomResponse();\n    assertEquals(new Uint8Array(await nativeResponse.arrayBuffer()), fixture);\n    assertEquals(context.response.type, \".json\");\n    assertStrictEquals(context.response.headers.get(\"content-encoding\"), null);\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"send hidden file throws 403\",\n  async fn() {\n    const { context } = setup(\"/.test.json\");\n    mockContextState.encodingsAccepted = \"identity\";\n    let didThrow = false;\n    try {\n      await send(context, context.request.url.pathname, {\n        root: \"./fixtures\",\n      });\n    } catch (e) {\n      assert(e instanceof errors.Forbidden);\n      didThrow = true;\n    }\n    assert(didThrow);\n  },\n});\n\nDeno.test({\n  name: \"send file from hidden dir throws 403\",\n  async fn() {\n    const { context } = setup(\"/.test/test.json\");\n    mockContextState.encodingsAccepted = \"identity\";\n    let didThrow = false;\n    try {\n      await send(context, context.request.url.pathname, {\n        root: \"./fixtures\",\n      });\n    } catch (e) {\n      assert(e instanceof errors.Forbidden);\n      didThrow = true;\n    }\n    assert(didThrow);\n  },\n});\n\nDeno.test({\n  name: \"send hidden file succeeds when hidden:true\",\n  async fn() {\n    const { context } = setup(\"/.test.json\");\n    const fixture = await Deno.readFile(\"./fixtures/.test.json\");\n    await send(context, context.request.url.pathname, {\n      root: \"./fixtures\",\n      hidden: true,\n      maxbuffer: 0,\n    });\n    const nativeResponse = await context.response.toDomResponse();\n    assertEquals(new Uint8Array(await nativeResponse.arrayBuffer()), fixture);\n    assertEquals(context.response.type, \".json\");\n    assertStrictEquals(context.response.headers.get(\"content-encoding\"), null);\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"send file from hidden root succeeds\",\n  async fn() {\n    const { context } = setup(\"/test.json\");\n    const fixture = await Deno.readFile(\"./fixtures/.test/test.json\");\n    await send(context, context.request.url.pathname, {\n      root: \"./fixtures/.test\",\n      maxbuffer: 0,\n    });\n    const nativeResponse = await context.response.toDomResponse();\n    assertEquals(new Uint8Array(await nativeResponse.arrayBuffer()), fixture);\n    assertEquals(context.response.type, \".json\");\n    assertStrictEquals(context.response.headers.get(\"content-encoding\"), null);\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"send url: /../file sends /file\",\n  async fn() {\n    const { context } = setup(\"/../test.json\");\n    const fixture = await Deno.readFile(\"./fixtures/test.json\");\n    await send(context, context.request.url.pathname, {\n      root: \"./fixtures\",\n      maxbuffer: 0,\n    });\n    const nativeResponse = await context.response.toDomResponse();\n    assertEquals(new Uint8Array(await nativeResponse.arrayBuffer()), fixture);\n    assertEquals(context.response.type, \".json\");\n    assertStrictEquals(context.response.headers.get(\"content-encoding\"), null);\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"send path: /../file throws 403\",\n  async fn() {\n    const { context } = setup(\"/../test.json\");\n    mockContextState.encodingsAccepted = \"identity\";\n    let didThrow = false;\n    try {\n      await send(context, \"/../test.json\", {\n        root: \"./fixtures\",\n      });\n    } catch (e) {\n      assert(e instanceof errors.Forbidden);\n      didThrow = true;\n    }\n    assert(didThrow);\n  },\n});\n\nDeno.test({\n  name: \"send allows .. in root\",\n  async fn() {\n    const { context } = setup(\"/test.json\");\n    const fixture = await Deno.readFile(\"./fixtures/test.json\");\n    await send(context, context.request.url.pathname, {\n      root: isNode() ? \"../esm/fixtures\" : \"../oak/fixtures\",\n      maxbuffer: 0,\n    });\n    const nativeResponse = await context.response.toDomResponse();\n    assertEquals(new Uint8Array(await nativeResponse.arrayBuffer()), fixture);\n    assertEquals(context.response.type, \".json\");\n    assertStrictEquals(context.response.headers.get(\"content-encoding\"), null);\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"send If-Modified-Since and it doesn't modified\",\n  async fn() {\n    const { context } = setup(\"/test.json\");\n    const fixtureStat = await Deno.stat(\"./fixtures/test.json\");\n    context.request.headers.set(\n      \"If-Modified-Since\",\n      fixtureStat.mtime!.toUTCString(),\n    );\n    await send(context, context.request.url.pathname, {\n      root: \"./fixtures\",\n      maxbuffer: 0,\n    });\n    const nativeResponse = await context.response.toDomResponse();\n    assertStrictEquals(nativeResponse.body, null);\n    assertEquals(nativeResponse.status, 304);\n    assertEquals(context.response.type, \".json\");\n    assertStrictEquals(context.response.headers.get(\"content-encoding\"), null);\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"send If-Modified-Since and it does modified\",\n  async fn() {\n    const { context } = setup(\"/test.json\");\n    const fixture = await Deno.readFile(\"./fixtures/test.json\");\n    const fixtureStat = await Deno.stat(\"./fixtures/test.json\");\n    context.request.headers.set(\n      \"If-Modified-Since\",\n      new Date(fixtureStat.mtime!.getTime() - 10000).toUTCString(),\n    );\n    await send(context, context.request.url.pathname, {\n      root: \"./fixtures\",\n      maxbuffer: 0,\n    });\n    const nativeResponse = await context.response.toDomResponse();\n    assertEquals(new Uint8Array(await nativeResponse.arrayBuffer()), fixture);\n    assertEquals(nativeResponse.status, 200);\n    assertEquals(context.response.type, \".json\");\n    assertStrictEquals(context.response.headers.get(\"content-encoding\"), null);\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"send sets etag header - less than maxbuffer\",\n  async fn() {\n    const { context } = setup(\"/test.json\");\n    const fixture = await Deno.readFile(\"./fixtures/test.json\");\n    await send(context, context.request.url.pathname, { root: \"./fixtures\" });\n    const nativeResponse = await context.response.toDomResponse();\n    assertEquals(new Uint8Array(await nativeResponse.arrayBuffer()), fixture);\n    assertEquals(nativeResponse.status, 200);\n    assertEquals(context.response.type, \".json\");\n    assertStrictEquals(context.response.headers.get(\"content-encoding\"), null);\n    const etagHeader = context.response.headers.get(\"etag\");\n    assertEquals(etagHeader, await eTag(fixture));\n  },\n});\n\nDeno.test({\n  name: \"send sets etag header - greater than maxbuffer\",\n  async fn() {\n    const { context } = setup(\"/test.jpg\");\n    const fixture = await Deno.readFile(\"./fixtures/test.jpg\");\n    await send(context, context.request.url.pathname, {\n      root: \"./fixtures\",\n      maxbuffer: 300000,\n    });\n    const nativeResponse = await context.response.toDomResponse();\n    assertEquals(new Uint8Array(await nativeResponse.arrayBuffer()), fixture);\n    assertEquals(nativeResponse.status, 200);\n    assertEquals(context.response.type, \".jpg\");\n    assertStrictEquals(context.response.headers.get(\"content-encoding\"), null);\n    const etagHeader = context.response.headers.get(\"etag\");\n    assert(etagHeader && etagHeader.startsWith(`W/\"4a3b7-`));\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"if-none-match header - not modified\",\n  async fn() {\n    const { context } = setup(\"/test.jpg\");\n    const fixture = await Deno.readFile(\"./fixtures/test.jpg\");\n    const ifNoneMatch = await eTag(fixture);\n    assert(ifNoneMatch);\n    context.request.headers.set(\"If-None-Match\", ifNoneMatch);\n    await send(context, context.request.url.pathname, { root: \"./fixtures\" });\n    const nativeResponse = await context.response.toDomResponse();\n    assertEquals(nativeResponse.status, 304);\n    assertEquals(\n      context.response.headers.get(\"etag\"),\n      await eTag(fixture),\n    );\n  },\n});\n\nDeno.test({\n  name: \"if-none-match header - modified\",\n  async fn() {\n    const { context } = setup(\"/test.jpg\");\n    const fixture = await Deno.readFile(\"./fixtures/test.jpg\");\n    context.request.headers.set(\n      \"If-None-Match\",\n      `\"17-dFpfAd6+866Bo994m4Epzil7k2A\"`,\n    );\n    await send(context, context.request.url.pathname, { root: \"./fixtures\" });\n    const nativeResponse = await context.response.toDomResponse();\n    assertEquals(nativeResponse.status, 200);\n    assertEquals(context.response.type, \".jpg\");\n    assertStrictEquals(context.response.headers.get(\"content-encoding\"), null);\n    assertEquals(\n      context.response.headers.get(\"etag\"),\n      await eTag(fixture),\n    );\n  },\n});\n\nDeno.test({\n  name: \"range header\",\n  ignore: Deno.build.os === \"windows\",\n  async fn() {\n    const { context } = setup(\"/test.json\");\n    context.request.headers.set(\"Range\", \"bytes=0-5\");\n    await send(context, context.request.url.pathname, { root: \"./fixtures\" });\n    const response = await context.response.toDomResponse();\n    assertEquals(response.status, 206);\n    assertEquals(context.response.type, \".json\");\n    assertEquals(await response.text(), `{\\n  \"h`);\n  },\n});\n\nDeno.test({\n  name: \"range header from 0-\",\n  ignore: Deno.build.os === \"windows\",\n  async fn() {\n    const { context } = setup(\"/test.json\");\n    context.request.headers.set(\"Range\", \"bytes=0-\");\n    await send(context, context.request.url.pathname, { root: \"./fixtures\" });\n    const response = await context.response.toDomResponse();\n    assertEquals(response.status, 206);\n    assertEquals(context.response.type, \".json\");\n    assertEquals(await response.text(), `{\\n  \"hello\": \"world\"\\n}\\n`);\n  },\n});\n\nDeno.test({\n  name: \"range header - multiple ranges\",\n  ignore: Deno.build.os === \"windows\",\n  async fn() {\n    const { context } = setup(\"/test.json\");\n    context.request.headers.set(\"Range\", \"bytes=0-5, 6-9\");\n    await send(context, context.request.url.pathname, { root: \"./fixtures\" });\n    const response = await context.response.toDomResponse();\n    assertEquals(response.status, 206);\n    assert(\n      response.headers.get(\"content-type\")!.startsWith(\n        `multipart/byteranges; boundary=`,\n      ),\n    );\n    const actual = await response.text();\n    assert(\n      actual.includes(\n        `\\r\\nContent-Type: application/json; charset=UTF-8\\r\\nContent-Range: 0-5/23\\r\\n\\r\\n{\\n  \"h\\r\\n`,\n      ),\n    );\n    assert(\n      actual.includes(\n        `\\r\\nContent-Type: application/json; charset=UTF-8\\r\\nContent-Range: 6-9/23\\r\\n\\r\\nello\\r\\n`,\n      ),\n    );\n  },\n});\n\nDeno.test({\n  name: \"send - contentTypes - custom\",\n  async fn() {\n    const { context } = setup(\"/test.importmap\");\n    const fixture = await Deno.readFile(\"./fixtures/test.importmap\");\n    await send(context, context.request.url.pathname, {\n      root: \"./fixtures\",\n      contentTypes: {\n        \".importmap\": \"application/importmap+json\",\n      },\n      maxbuffer: 0,\n    });\n    const nativeResponse = await context.response.toDomResponse();\n    assertEquals(new Uint8Array(await nativeResponse.arrayBuffer()), fixture);\n    assertEquals(context.response.type, \"application/importmap+json\");\n    assert(context.response.headers.get(\"last-modified\") != null);\n    assertEquals(context.response.headers.get(\"cache-control\"), \"max-age=0\");\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"send - contentTypes - override\",\n  async fn() {\n    const { context } = setup(\"/test.html\");\n    const fixture = await Deno.readFile(\"./fixtures/test.html\");\n    await send(context, context.request.url.pathname, {\n      root: \"./fixtures\",\n      contentTypes: {\n        \".html\": \"plain/text\",\n      },\n      maxbuffer: 0,\n    });\n    const nativeResponse = await context.response.toDomResponse();\n    assertEquals(new Uint8Array(await nativeResponse.arrayBuffer()), fixture);\n    assertEquals(context.response.type, \"plain/text\");\n    assert(context.response.headers.get(\"last-modified\") != null);\n    assertEquals(context.response.headers.get(\"cache-control\"), \"max-age=0\");\n    context.response.destroy();\n  },\n});\n\nDeno.test({\n  name: \"send - security - decoding paths to subvert checks\",\n  async fn() {\n    const { context } = setup(\"/poc%2f../.test.json\");\n    await assertRejects(async () => {\n      await send(context, context.request.url.pathname, {\n        root: \"./fixtures\",\n        hidden: false,\n      });\n    }, httpErrors.NotFound);\n  },\n});\n"
        },
        {
          "name": "send.ts",
          "type": "blob",
          "size": 9.5205078125,
          "content": "/*!\n * Adapted from koa-send at https://github.com/koajs/send and which is licensed\n * with the MIT license.\n */\n\n/**\n * Contains the send function which can be used to send static assets while\n * supporting a range of HTTP capabilities.\n *\n * This is integrated into the oak context via the `.send()` method.\n *\n * @module\n */\n\nimport type { Context } from \"./context.ts\";\nimport {\n  basename,\n  type ByteRange,\n  contentType,\n  createHttpError,\n  eTag,\n  extname,\n  type FileInfo,\n  ifNoneMatch,\n  parse,\n  range,\n  responseRange,\n  Status,\n} from \"./deps.ts\";\nimport type { Response } from \"./response.ts\";\nimport { isNode } from \"./utils/type_guards.ts\";\nimport { decode } from \"./utils/decode.ts\";\nimport { resolvePath } from \"./utils/resolve_path.ts\";\n\nif (isNode()) {\n  console.warn(\"oak send() does not work under Node.js.\");\n}\n\nconst MAXBUFFER_DEFAULT = 1_048_576; // 1MiB;\n\n/** Options which can be specified when using the {@linkcode send}\n * middleware. */\nexport interface SendOptions {\n  /** Try to serve the brotli version of a file automatically when brotli is\n   * supported by a client and if the requested file with `.br` extension\n   * exists. (defaults to `true`) */\n  brotli?: boolean;\n\n  /** A record of extensions and content types that should be used when\n   * determining the content of a file being served. By default, the\n   * [`media_type`](https://github.com/oakserver/media_types/) database is used\n   * to map an extension to the served content-type. The keys of the map are\n   * extensions, and values are the content types to use. The content type can\n   * be a partial content type, which will be resolved to a full content type\n   * header.\n   *\n   * Any extensions matched will override the default behavior. Key should\n   * include the leading dot (e.g. `.ext` instead of just `ext`).\n   *\n   * ### Example\n   *\n   * ```ts\n   * app.use((ctx) => {\n   *   return send(ctx, ctx.request.url.pathname, {\n   *     contentTypes: {\n   *       \".importmap\": \"application/importmap+json\"\n   *     },\n   *     root: \".\",\n   *   })\n   * });\n   * ```\n   */\n  contentTypes?: Record<string, string>;\n\n  /** Try to match extensions from passed array to search for file when no\n   * extension is sufficed in URL. First found is served. (defaults to\n   * `undefined`) */\n  extensions?: string[];\n\n  /** If `true`, format the path to serve static file servers and not require a\n   * trailing slash for directories, so that you can do both `/directory` and\n   * `/directory/`. (defaults to `true`) */\n  format?: boolean;\n\n  /** Try to serve the gzipped version of a file automatically when gzip is\n   * supported by a client and if the requested file with `.gz` extension\n   * exists. (defaults to `true`). */\n  gzip?: boolean;\n\n  /** Allow transfer of hidden files. (defaults to `false`) */\n  hidden?: boolean;\n\n  /** Tell the browser the resource is immutable and can be cached\n   * indefinitely. (defaults to `false`) */\n  immutable?: boolean;\n\n  /** Name of the index file to serve automatically when visiting the root\n   * location. (defaults to none) */\n  index?: string;\n\n  /** Browser cache max-age in milliseconds. (defaults to `0`) */\n  maxage?: number;\n\n  /** A size in bytes where if the file is less than this size, the file will\n   * be read into memory by send instead of returning a file handle.  Files less\n   * than the byte size will send an \"strong\" `ETag` header while those larger\n   * than the bytes size will only be able to send a \"weak\" `ETag` header (as\n   * they cannot hash the contents of the file). (defaults to 1MiB)\n   */\n  maxbuffer?: number;\n\n  /** Root directory to restrict file access. */\n  root: string;\n}\n\nfunction isHidden(path: string) {\n  const pathArr = path.split(\"/\");\n  for (const segment of pathArr) {\n    if (segment[0] === \".\" && segment !== \".\" && segment !== \"..\") {\n      return true;\n    }\n    return false;\n  }\n}\n\nasync function exists(path: string): Promise<boolean> {\n  try {\n    return (await Deno.stat(path)).isFile;\n  } catch {\n    return false;\n  }\n}\n\nasync function getEntity(\n  path: string,\n  mtime: number,\n  stats: Deno.FileInfo,\n  maxbuffer: number,\n  response: Response,\n): Promise<[Uint8Array | Deno.FsFile, Uint8Array | FileInfo, FileInfo]> {\n  let body: Uint8Array | Deno.FsFile;\n  let entity: Uint8Array | FileInfo;\n  const fileInfo = { mtime: new Date(mtime), size: stats.size };\n  if (stats.size < maxbuffer) {\n    const buffer = await Deno.readFile(path);\n    body = entity = buffer;\n  } else {\n    const file = await Deno.open(path, { read: true });\n    response.addResource(file);\n    body = file;\n    entity = fileInfo;\n  }\n  return [body, entity, fileInfo];\n}\n\n/** Asynchronously fulfill a response with a file from the local file\n * system.\n *\n * Requires Deno read permission for the `root` directory. */\nexport async function send(\n  // deno-lint-ignore no-explicit-any\n  { request, response }: Context<any>,\n  path: string,\n  options: SendOptions = { root: \"\" },\n): Promise<string | undefined> {\n  const {\n    brotli = true,\n    contentTypes = {},\n    extensions,\n    format = true,\n    gzip = true,\n    hidden = false,\n    immutable = false,\n    index,\n    maxbuffer = MAXBUFFER_DEFAULT,\n    maxage = 0,\n    root,\n  } = options;\n  const trailingSlash = path[path.length - 1] === \"/\";\n  path = decode(path.substring(parse(path).root.length));\n  if (index && trailingSlash) {\n    path += index;\n  }\n\n  if (!hidden && isHidden(path)) {\n    throw createHttpError(403);\n  }\n\n  path = resolvePath(root, path);\n\n  let encodingExt = \"\";\n  if (\n    brotli &&\n    request.acceptsEncodings(\"br\", \"identity\") === \"br\" &&\n    (await exists(`${path}.br`))\n  ) {\n    path = `${path}.br`;\n    response.headers.set(\"Content-Encoding\", \"br\");\n    response.headers.delete(\"Content-Length\");\n    encodingExt = \".br\";\n  } else if (\n    gzip &&\n    request.acceptsEncodings(\"gzip\", \"identity\") === \"gzip\" &&\n    (await exists(`${path}.gz`))\n  ) {\n    path = `${path}.gz`;\n    response.headers.set(\"Content-Encoding\", \"gzip\");\n    response.headers.delete(\"Content-Length\");\n    encodingExt = \".gz\";\n  }\n\n  if (extensions && !/\\.[^/]*$/.exec(path)) {\n    for (let ext of extensions) {\n      if (!/^\\./.exec(ext)) {\n        ext = `.${ext}`;\n      }\n      if (await exists(`${path}${ext}`)) {\n        path += ext;\n        break;\n      }\n    }\n  }\n\n  let stats: Deno.FileInfo;\n  try {\n    stats = await Deno.stat(path);\n\n    if (stats.isDirectory) {\n      if (format && index) {\n        path += `/${index}`;\n        stats = await Deno.stat(path);\n      } else {\n        return;\n      }\n    }\n  } catch (err) {\n    if (err instanceof Deno.errors.NotFound) {\n      throw createHttpError(404, err.message);\n    }\n    // TODO(@kitsonk) remove when https://github.com/denoland/node_deno_shims/issues/87 resolved\n    if (err instanceof Error && err.message.startsWith(\"ENOENT:\")) {\n      throw createHttpError(404, err.message);\n    }\n    throw createHttpError(\n      500,\n      err instanceof Error ? err.message : \"[non-error thrown]\",\n    );\n  }\n\n  let mtime: number | null = null;\n  if (response.headers.has(\"Last-Modified\")) {\n    mtime = new Date(response.headers.get(\"Last-Modified\")!).getTime();\n  } else if (stats.mtime) {\n    // Round down to second because it's the precision of the UTC string.\n    mtime = stats.mtime.getTime();\n    mtime -= mtime % 1000;\n    response.headers.set(\"Last-Modified\", new Date(mtime).toUTCString());\n  }\n\n  if (!response.headers.has(\"Cache-Control\")) {\n    const directives = [`max-age=${(maxage / 1000) | 0}`];\n    if (immutable) {\n      directives.push(\"immutable\");\n    }\n    response.headers.set(\"Cache-Control\", directives.join(\",\"));\n  }\n  if (!response.type) {\n    response.type = encodingExt !== \"\"\n      ? extname(basename(path, encodingExt))\n      : contentTypes[extname(path)] ?? extname(path);\n  }\n\n  let entity: Uint8Array | FileInfo | null = null;\n  let body: Uint8Array | Deno.FsFile | null = null;\n  let fileInfo: FileInfo | null = null;\n\n  if (request.headers.has(\"If-None-Match\") && mtime) {\n    [body, entity, fileInfo] = await getEntity(\n      path,\n      mtime,\n      stats,\n      maxbuffer,\n      response,\n    );\n    const etag = await eTag(entity as FileInfo);\n    if (\n      etag && (!ifNoneMatch(request.headers.get(\"If-None-Match\")!, etag))\n    ) {\n      response.headers.set(\"ETag\", etag);\n      response.status = 304;\n      return path;\n    }\n  }\n\n  if (request.headers.has(\"If-Modified-Since\") && mtime) {\n    const ifModifiedSince = new Date(request.headers.get(\"If-Modified-Since\")!);\n    if (ifModifiedSince.getTime() >= mtime) {\n      response.status = 304;\n      return path;\n    }\n  }\n\n  if (!body || !entity || !fileInfo) {\n    [body, entity, fileInfo] = await getEntity(\n      path,\n      mtime ?? 0,\n      stats,\n      maxbuffer,\n      response,\n    );\n  }\n\n  let returnRanges: ByteRange[] | undefined = undefined;\n  let size: number | undefined = undefined;\n\n  if (request.source && body && entity) {\n    const { ok, ranges } = ArrayBuffer.isView(body)\n      ? await range(request.source, body, fileInfo)\n      : await range(request.source, fileInfo);\n    if (ok && ranges) {\n      size = ArrayBuffer.isView(entity) ? entity.byteLength : entity.size;\n      returnRanges = ranges;\n    } else if (!ok) {\n      response.status = Status.RequestedRangeNotSatisfiable;\n    }\n  }\n\n  if (!response.headers.has(\"ETag\")) {\n    const etag = await eTag(entity as FileInfo);\n    if (etag) {\n      response.headers.set(\"ETag\", etag);\n    }\n  }\n\n  if (returnRanges && size) {\n    response.with(\n      responseRange(body, size, returnRanges, { headers: response.headers }, {\n        type: response.type ? contentType(response.type) : \"\",\n      }),\n    );\n  } else {\n    response.body = body;\n  }\n\n  return path;\n}\n"
        },
        {
          "name": "testing.test.ts",
          "type": "blob",
          "size": 2.294921875,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\nimport { assert } from \"./deps.ts\";\nimport { assertEquals, assertStrictEquals } from \"./deps_test.ts\";\n\nimport {\n  createMockApp,\n  createMockContext,\n  createMockNext,\n  mockContextState,\n} from \"./testing.ts\";\n\nDeno.test({\n  name: \"testing - createMockApp()\",\n  fn() {\n    const app = createMockApp();\n    assertEquals(app.state, {});\n  },\n});\n\nDeno.test({\n  name: \"testing - createMockApp() - with state\",\n  fn() {\n    const app = createMockApp({ a: \"a\" });\n    assertEquals(app.state, { a: \"a\" });\n  },\n});\n\nDeno.test({\n  name: \"testing - createMockContext()\",\n  fn() {\n    const ctx = createMockContext();\n    assert(ctx.app);\n    assertEquals(ctx.request.method, \"GET\");\n    assertStrictEquals(ctx.params, undefined);\n    assertEquals(ctx.request.url.pathname, \"/\");\n    assertEquals(ctx.state, {});\n    assertEquals(ctx.request.acceptsEncodings(\"identity\"), \"identity\");\n    ctx.response.redirect(\"/hello/world\");\n    assertEquals(ctx.response.headers.get(\"Location\"), \"/hello/world\");\n  },\n});\n\nDeno.test({\n  name: \"testing - mockContextState\",\n  fn() {\n    mockContextState.encodingsAccepted = \"gzip\";\n    const ctx = createMockContext();\n    try {\n      assertEquals(ctx.request.acceptsEncodings(\"gzip\"), \"gzip\");\n    } finally {\n      mockContextState.encodingsAccepted = \"identity\";\n    }\n  },\n});\n\nDeno.test({\n  name: \"testing - ctx.cookies.set()\",\n  async fn() {\n    const ctx = createMockContext();\n    await ctx.cookies.set(\n      \"sessionID\",\n      \"S7GhXzJF3n4j8JwTupr7H-h25qtt_vs0stdETXZb-Ro\",\n      { httpOnly: true },\n    );\n    assertEquals([...ctx.response.headers], [\n      [\n        \"set-cookie\",\n        \"sessionID=S7GhXzJF3n4j8JwTupr7H-h25qtt_vs0stdETXZb-Ro; path=/; httponly\",\n      ],\n    ]);\n  },\n});\n\nDeno.test({\n  name: \"testing - ctx.cookies.get()\",\n  async fn() {\n    const ctx = createMockContext({\n      headers: [[\n        \"cookie\",\n        \"sessionID=S7GhXzJF3n4j8JwTupr7H-h25qtt_vs0stdETXZb-Ro;\",\n      ]],\n    });\n    assertEquals(\n      await ctx.cookies.get(\"sessionID\"),\n      \"S7GhXzJF3n4j8JwTupr7H-h25qtt_vs0stdETXZb-Ro\",\n    );\n  },\n});\n\nDeno.test({\n  name: \"testing - createMockNext()\",\n  fn() {\n    const next = createMockNext();\n    assertStrictEquals(typeof next, \"function\");\n    assert(next() instanceof Promise);\n  },\n});\n"
        },
        {
          "name": "testing.ts",
          "type": "blob",
          "size": 4.8935546875,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\n// deno-lint-ignore-file no-explicit-any\n\n/**\n * A collection of utility APIs which can make testing of an oak application\n * easier.\n *\n * @module\n */\n\nimport type { Application, State } from \"./application.ts\";\nimport {\n  accepts,\n  createHttpError,\n  type ErrorStatus,\n  SecureCookieMap,\n} from \"./deps.ts\";\nimport { Body } from \"./body.ts\";\nimport type { RouteParams, RouterContext } from \"./router.ts\";\nimport type { Request } from \"./request.ts\";\nimport { Response } from \"./response.ts\";\n\n/** Creates a mock of `Application`. */\nexport function createMockApp<\n  S extends Record<PropertyKey, any> = Record<string, any>,\n>(\n  state: S = {} as S,\n): Application<S> {\n  const app = {\n    state,\n    use() {\n      return app;\n    },\n    [Symbol.for(\"Deno.customInspect\")]() {\n      return \"MockApplication {}\";\n    },\n    [Symbol.for(\"nodejs.util.inspect.custom\")](\n      depth: number,\n      options: any,\n      inspect: (value: unknown, options?: unknown) => string,\n    ) {\n      if (depth < 0) {\n        return options.stylize(`[MockApplication]`, \"special\");\n      }\n\n      const newOptions = Object.assign({}, options, {\n        depth: options.depth === null ? null : options.depth - 1,\n      });\n      return `${options.stylize(\"MockApplication\", \"special\")} ${\n        inspect({}, newOptions)\n      }`;\n    },\n  } as any;\n  return app;\n}\n\n/** Options that can be set in a mock context. */\nexport interface MockContextOptions<\n  R extends string,\n  P extends RouteParams<R> = RouteParams<R>,\n  S extends State = Record<string, any>,\n> {\n  app?: Application<S>;\n  ip?: string;\n  method?: string;\n  params?: P;\n  path?: string;\n  state?: S;\n  headers?: [string, string][];\n  body?: ReadableStream;\n}\n\n/** Allows external parties to modify the context state. */\nexport const mockContextState = {\n  /** Adjusts the return value of the `acceptedEncodings` in the context's\n   * `request` object. */\n  encodingsAccepted: \"identity\",\n};\n\n/** Create a mock of `Context` or `RouterContext`. */\nexport function createMockContext<\n  R extends string,\n  P extends RouteParams<R> = RouteParams<R>,\n  S extends State = Record<string, any>,\n>(\n  {\n    ip = \"127.0.0.1\",\n    method = \"GET\",\n    params,\n    path = \"/\",\n    state,\n    app = createMockApp(state),\n    headers: requestHeaders,\n    body = undefined,\n  }: MockContextOptions<R> = {},\n): RouterContext<R, P, S> {\n  function createMockRequest(): Request {\n    const headers = new Headers(requestHeaders);\n    return {\n      get source(): globalThis.Request | undefined {\n        return new globalThis.Request(new URL(path, \"http://localhost/\"), {\n          method,\n          headers,\n        });\n      },\n      accepts(...types: string[]) {\n        if (!headers.has(\"Accept\")) {\n          return;\n        }\n        if (types.length) {\n          return accepts({ headers }, ...types);\n        }\n        return accepts({ headers });\n      },\n      acceptsEncodings() {\n        return mockContextState.encodingsAccepted;\n      },\n      headers,\n      ip,\n      method,\n      path,\n      search: undefined,\n      searchParams: new URLSearchParams(),\n      url: new URL(path, \"http://localhost/\"),\n      hasBody: !!body,\n      body: body ? new Body({ headers, getBody: () => body }) : undefined,\n    } as any;\n  }\n\n  const request = createMockRequest();\n  const response = new Response(request);\n  const cookies = new SecureCookieMap(request, { response });\n\n  return ({\n    app,\n    params,\n    request,\n    cookies,\n    response,\n    state: Object.assign({}, app.state),\n    assert(\n      condition: any,\n      errorStatus: ErrorStatus = 500,\n      message?: string,\n      props?: Record<string, unknown>,\n    ): asserts condition {\n      if (condition) {\n        return;\n      }\n      const err = createHttpError(errorStatus, message);\n      if (props) {\n        Object.assign(err, props);\n      }\n      throw err;\n    },\n    throw(\n      errorStatus: ErrorStatus,\n      message?: string,\n      props?: Record<string, unknown>,\n    ): never {\n      const err = createHttpError(errorStatus, message);\n      if (props) {\n        Object.assign(err, props);\n      }\n      throw err;\n    },\n    [Symbol.for(\"Deno.customInspect\")]() {\n      return `MockContext {}`;\n    },\n    [Symbol.for(\"nodejs.util.inspect.custom\")](\n      depth: number,\n      options: any,\n      inspect: (value: unknown, options?: unknown) => string,\n    ) {\n      if (depth < 0) {\n        return options.stylize(`[MockContext]`, \"special\");\n      }\n\n      const newOptions = Object.assign({}, options, {\n        depth: options.depth === null ? null : options.depth - 1,\n      });\n      return `${options.stylize(\"MockContext\", \"special\")} ${\n        inspect({}, newOptions)\n      }`;\n    },\n  } as unknown) as RouterContext<R, P, S>;\n}\n\n/** Creates a mock `next()` function which can be used when calling\n * middleware. */\nexport function createMockNext(): () => Promise<void> {\n  return async function next() {};\n}\n"
        },
        {
          "name": "types.ts",
          "type": "blob",
          "size": 2.431640625,
          "content": "// Copyright 2018-2025 the oak authors. All rights reserved. MIT license.\n\nimport type { Application, State } from \"./application.ts\";\n\nexport interface Listener {\n  addr: { hostname: string; port: number };\n}\n\nexport interface OakServer<T> extends AsyncIterable<T> {\n  close(): void | Promise<void>;\n  listen(): Listener | Promise<Listener>;\n  [Symbol.asyncIterator](): AsyncIterableIterator<T>;\n}\n\nexport interface ServerRequest {\n  readonly headers: Headers;\n  readonly method: string;\n  readonly rawUrl?: string;\n  readonly remoteAddr: string | undefined;\n  readonly request?: Request;\n  readonly url: string;\n  // deno-lint-ignore no-explicit-any\n  error(reason?: any): void;\n  getBody(): ReadableStream<Uint8Array> | null;\n  respond(response: Response): void | Promise<void>;\n  upgrade?(options?: UpgradeWebSocketOptions): WebSocket;\n}\n\n/** The abstract constructor interface that custom servers need to adhere to\n * when using with an {@linkcode Application}. */\nexport interface ServerConstructor<T extends ServerRequest> {\n  // deno-lint-ignore no-explicit-any\n  new <AS extends State = Record<string, any>>(\n    app: Application<AS>,\n    options: Omit<ServeOptions | ServeTlsOptions, \"signal\">,\n  ): OakServer<T>;\n  prototype: OakServer<T>;\n  type?: \"native\" | \"node\" | \"bun\";\n}\n\nexport type Data = string | number[] | ArrayBuffer | Uint8Array;\nexport type Key = string | number[] | ArrayBuffer | Uint8Array;\n\nexport interface UpgradeWebSocketOptions {\n  protocol?: string;\n}\n\nexport type UpgradeWebSocketFn = (\n  request: Request,\n  options?: UpgradeWebSocketOptions,\n) => WebSocketUpgrade;\n\ninterface WebSocketUpgrade {\n  response: Response;\n  socket: WebSocket;\n}\n\nexport interface NetAddr {\n  transport: \"tcp\" | \"udp\";\n  hostname: string;\n  port: number;\n}\n\nexport interface ServeHandlerInfo {\n  remoteAddr: Deno.NetAddr;\n}\n\nexport type ServeHandler = (\n  request: Request,\n  info: ServeHandlerInfo,\n) => Response | Promise<Response>;\n\nexport interface ServeOptions {\n  port?: number;\n  hostname?: string;\n  signal?: AbortSignal;\n  reusePort?: boolean;\n  onError?: (error: unknown) => Response | Promise<Response>;\n  onListen?: (params: { hostname: string; port: number }) => void;\n}\n\nexport interface ServeTlsOptions extends ServeOptions {\n  cert: string;\n  key: string;\n}\n\nexport interface ServeInit {\n  handler: ServeHandler;\n}\n\nexport interface HttpServer extends AsyncDisposable {\n  finished: Promise<void>;\n  ref(): void;\n  unref(): void;\n  shutdown(): Promise<void>;\n}\n"
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}