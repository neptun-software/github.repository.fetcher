{
  "metadata": {
    "timestamp": 1736564476331,
    "page": 87,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gibbok/typescript-book",
      "stars": 8522,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0263671875,
          "content": "node_modules\ntemp\n!.vscode\n"
        },
        {
          "name": "LICENSE.MD",
          "type": "blob",
          "size": 0.181640625,
          "content": "# Licence\n\nThe Concise TypeScript Book © by Simone Poggiali is licensed under Attribution 4.0 International.\n\nFor more information visit:\n<https://creativecommons.org/licenses/by/4.0/>\n"
        },
        {
          "name": "README-zh_CN.md",
          "type": "blob",
          "size": 145.1767578125,
          "content": "# 简洁的TypeScript之书\n\n《Concise TypeScript Book》全面而简洁地概述了 TypeScript 的功能。它提供了清晰的解释，涵盖了该语言最新版本中的所有方面，从强大的类型系统到高级功能。无论您是初学者还是经验丰富的开发人员，本书都是增强您对 TypeScript 的理解和熟练程度的宝贵资源。\n\n本书完全免费且开源。\n\n如果您发现这本 TypeScript 书籍很有价值并希望做出贡献，请考虑通过 PayPal 支持我的努力。谢谢！\n\n[![Donate](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://www.paypal.com/donate/?business=QW82ZS956XLFY&no_recurring=0&currency_code=EUR)\n\n## 翻译\n\n本书已被翻译成多种语言版本，包括：\n\n[中文](https://github.com/gibbok/typescript-book/blob/main/README-zh_CN.md)\n\n## 下载和网站\n\n您还可以下载 Epub 版本：\n\n[https://github.com/gibbok/typescript-book/tree/main/downloads](https://github.com/gibbok/typescript-book/tree/main/downloads)\n\n在线版本可在以下位置获得：\n\n[https://gibbok.github.io/typescript-book](https://gibbok.github.io/typescript-book)\n\n## 目录表\n\n<!-- markdownlint-disable MD004 -->\n- [简洁的TypeScript之书](#简洁的typescript之书)\n  - [翻译](#翻译)\n  - [下载和网站](#下载和网站)\n  - [目录表](#目录表)\n  - [介绍](#介绍)\n  - [关于作者](#关于作者)\n  - [TypeScript简介](#typescript简介)\n    - [什么是TypeScript？](#什么是typescript)\n    - [为什么选择 TypeScript？](#为什么选择-typescript)\n    - [TypeScript 和 JavaScript](#typescript-和-javascript)\n    - [TypeScript 代码生成](#typescript-代码生成)\n    - [现在的现代 JavaScript（降级）](#现在的现代-javascript降级)\n  - [TypeScript 入门](#typescript-入门)\n    - [安装](#安装)\n    - [配置](#配置)\n    - [TypeScript 的配置文件](#typescript-的配置文件)\n      - [target](#target)\n      - [lib](#lib)\n      - [strict](#strict)\n      - [module](#module)\n      - [moduleResolution](#moduleresolution)\n      - [esModuleInterop](#esmoduleinterop)\n      - [jsx](#jsx)\n      - [skipLibCheck](#skiplibcheck)\n      - [files](#files)\n      - [include](#include)\n      - [exclude](#exclude)\n    - [importHelpers](#importhelpers)\n    - [迁移到 TypeScript 的建议](#迁移到-typescript-的建议)\n  - [探索类型系统](#探索类型系统)\n    - [TypeScript 的语言服务](#typescript-的语言服务)\n    - [结构类型](#结构类型)\n    - [TypeScript 的基本比较规则](#typescript-的基本比较规则)\n    - [类型作为集合](#类型作为集合)\n    - [赋值类型：类型声明和类型断言](#赋值类型类型声明和类型断言)\n      - [类型声明](#类型声明)\n      - [类型断言](#类型断言)\n      - [非空断言](#非空断言)\n      - [环境声明](#环境声明)\n    - [属性检测和多余属性检测](#属性检测和多余属性检测)\n    - [弱类型](#弱类型)\n    - [严格的对象字面量检测 (Freshness)](#严格的对象字面量检测-freshness)\n    - [类型推断](#类型推断)\n    - [更高级的推断](#更高级的推断)\n    - [类型加宽](#类型加宽)\n    - [常量](#常量)\n      - [类型参数的 const 修饰符](#类型参数的-const-修饰符)\n    - [常量断言](#常量断言)\n    - [显式类型注释](#显式类型注释)\n    - [类型缩小](#类型缩小)\n      - [条件](#条件)\n      - [抛错或者返回](#抛错或者返回)\n      - [可区分联合](#可区分联合)\n      - [用户定义的类型保护](#用户定义的类型保护)\n  - [原始类型](#原始类型)\n    - [string](#string)\n    - [boolean](#boolean)\n    - [number](#number)\n    - [bigInt](#bigint)\n    - [symbol](#symbol)\n    - [null and undefined](#null-and-undefined)\n    - [Array](#array)\n    - [any](#any)\n  - [类型注释](#类型注释)\n  - [可选属性](#可选属性)\n  - [只读属性](#只读属性)\n  - [索引签名](#索引签名)\n  - [扩展类型](#扩展类型)\n  - [字面量类型](#字面量类型)\n  - [字面量推断](#字面量推断)\n  - [严格空检查](#严格空检查)\n  - [枚举](#枚举)\n    - [数字枚举](#数字枚举)\n    - [字符串枚举](#字符串枚举)\n    - [常量枚举](#常量枚举)\n    - [反向映射](#反向映射)\n    - [环境枚举](#环境枚举)\n    - [计算成员和常量成员](#计算成员和常量成员)\n  - [缩小范围](#缩小范围)\n    - [typeof 类型保护](#typeof-类型保护)\n    - [真实性缩小](#真实性缩小)\n    - [相等缩小](#相等缩小)\n    - [In运算符缩小](#in运算符缩小)\n    - [instanceof 缩小](#instanceof-缩小)\n  - [赋值](#赋值)\n  - [控制流分析](#控制流分析)\n  - [类型谓词](#类型谓词)\n  - [可区分联合](#可区分联合-1)\n  - [never 类型](#never-类型)\n  - [详尽性检查](#详尽性检查)\n  - [对象类型](#对象类型)\n  - [元组类型（匿名）](#元组类型匿名)\n  - [命名元组类型（已标记）](#命名元组类型已标记)\n  - [固定长度元组](#固定长度元组)\n  - [联合类型](#联合类型)\n  - [交集类型](#交集类型)\n  - [类型索引](#类型索引)\n  - [值的类型](#值的类型)\n  - [Func 返回值的类型](#func-返回值的类型)\n  - [模块的类型](#模块的类型)\n  - [映射类型](#映射类型)\n  - [映射类型修饰符](#映射类型修饰符)\n  - [条件类型](#条件类型)\n  - [分配条件类型](#分配条件类型)\n  - [infer 条件类型中的类型推断](#infer-条件类型中的类型推断)\n  - [预定义条件类型](#预定义条件类型)\n  - [模板联合类型](#模板联合类型)\n  - [任意类型](#任意类型)\n  - [未知类型](#未知类型)\n  - [空类型](#空类型)\n  - [Never类型](#never类型)\n  - [接口及类型](#接口及类型)\n    - [通用语法](#通用语法)\n    - [基本类型](#基本类型)\n    - [对象和接口](#对象和接口)\n    - [并集和交集类型](#并集和交集类型)\n  - [内置原始数据类型](#内置原始数据类型)\n  - [常见的内置JS对象](#常见的内置js对象)\n  - [重载](#重载)\n  - [合并与扩展](#合并与扩展)\n  - [类型和接口之间的差异](#类型和接口之间的差异)\n  - [Class](#class)\n    - [通用语法](#通用语法-1)\n    - [构造函数](#构造函数)\n    - [私有和受保护的构造函数](#私有和受保护的构造函数)\n    - [访问修饰符](#访问修饰符)\n    - [Get 与 Set](#get-与-set)\n    - [类中的自动访问器](#类中的自动访问器)\n    - [this](#this)\n    - [参数属性](#参数属性)\n    - [抽象类](#抽象类)\n    - [使用泛型](#使用泛型)\n    - [装饰器](#装饰器)\n      - [类装饰器](#类装饰器)\n      - [属性装饰器](#属性装饰器)\n      - [方法装饰器](#方法装饰器)\n      - [Getter 和 Setter 装饰器](#getter-和-setter-装饰器)\n    - [装饰器元数据](#装饰器元数据)\n    - [继承](#继承)\n    - [静态成员](#静态成员)\n    - [属性初始化](#属性初始化)\n    - [方法重载](#方法重载)\n  - [泛型](#泛型)\n    - [泛型类型](#泛型类型)\n    - [泛型类](#泛型类)\n    - [泛型约束](#泛型约束)\n    - [泛型上下文缩小](#泛型上下文缩小)\n  - [擦除的结构类型](#擦除的结构类型)\n  - [命名空间](#命名空间)\n  - [Symbols](#symbols)\n  - [三斜杠指令](#三斜杠指令)\n  - [类型操作](#类型操作)\n    - [从类型创建类型](#从类型创建类型)\n    - [索引访问类型](#索引访问类型)\n    - [工具类型](#工具类型)\n      - [Awaited\\<T\\>](#awaitedt)\n      - [Partial\\<T\\>](#partialt)\n      - [Required\\<T\\>](#requiredt)\n      - [Readonly\\<T\\>](#readonlyt)\n      - [Record\\<K, T\\>](#recordk-t)\n      - [Pick\\<T, K\\>](#pickt-k)\n      - [Omit\\<T, K\\>](#omitt-k)\n      - [Exclude\\<T, U\\>](#excludet-u)\n      - [Extract\\<T, U\\>](#extractt-u)\n      - [NonNullable\\<T\\>](#nonnullablet)\n      - [Parameters\\<T\\>](#parameterst)\n      - [ConstructorParameters\\<T\\>](#constructorparameterst)\n      - [ReturnType\\<T\\>](#returntypet)\n      - [InstanceType\\<T\\>](#instancetypet)\n      - [ThisParameterType\\<T\\>](#thisparametertypet)\n      - [OmitThisParameter\\<T\\>](#omitthisparametert)\n      - [ThisType\\<T\\>](#thistypet)\n      - [Uppercase\\<T\\>](#uppercaset)\n      - [Lowercase\\<T\\>](#lowercaset)\n      - [Capitalize\\<T\\>](#capitalizet)\n      - [Uncapitalize\\<T\\>](#uncapitalizet)\n      - [NoInfer\\<T\\>](#noinfert)\n  - [其他](#其他)\n    - [错误和异常处理](#错误和异常处理)\n    - [混合类](#混合类)\n    - [异步语言特性](#异步语言特性)\n    - [迭代器和生成器](#迭代器和生成器)\n    - [TsDocs JSDoc 参考](#tsdocs-jsdoc-参考)\n    - [@types](#types)\n    - [JSX](#jsx-1)\n    - [ES6 模块](#es6-模块)\n    - [ES7 求幂运算符](#es7-求幂运算符)\n    - [for-await-of 语句](#for-await-of-语句)\n    - [New target 元属性](#new-target-元属性)\n    - [动态导入表达式](#动态导入表达式)\n    - [\"tsc –watch\"](#tsc-watch)\n    - [默认声明](#默认声明)\n    - [可选链](#可选链)\n    - [空合并运算符](#空合并运算符)\n    - [模板字符串类型](#模板字符串类型)\n    - [函数重载](#函数重载)\n    - [递归类型](#递归类型)\n    - [递归条件类型](#递归条件类型)\n    - [Node 中的 ECMAScript 模块支持](#node-中的-ecmascript-模块支持)\n    - [断言函数](#断言函数)\n    - [可变参数元组类型](#可变参数元组类型)\n    - [装箱类型](#装箱类型)\n    - [TypeScript 中的协变和逆变](#typescript-中的协变和逆变)\n      - [类型参数的可选方差注释](#类型参数的可选方差注释)\n    - [模板字符串模式索引签名](#模板字符串模式索引签名)\n    - [satisfies操作符](#satisfies操作符)\n    - [仅类型导入和导出](#仅类型导入和导出)\n    - [使用声明和显式资源管理](#使用声明和显式资源管理)\n      - [使用声明等待](#使用声明等待)\n    - [导入属性](#导入属性)\n<!-- markdownlint-enable MD004 -->\n\n## 介绍\n\n欢迎来到简洁的TypeScript之书！本指南为您提供有效 TypeScript 开发的基本知识和实践技能。发现编写干净、健壮的代码的关键概念和技术。无论您是初学者还是经验丰富的开发人员，本书都可以作为在项目中利用 TypeScript 强大功能的综合指南和便捷参考。\n\n本书涵盖了 TypeScript 5.2。\n\n## 关于作者\n\nSimone Poggiali 是一位经验丰富的高级前端开发人员，自 90 年代以来就热衷于编写专业级代码。在他的国际职业生涯中，他为从初创公司到大型组织的广泛客户提供了众多项目。HelloFresh、Siemens、O2 和 Leroy Merlin 等著名公司都受益于他的专业知识和奉献精神。\n\n您可以通过以下平台联系 Simone Poggiali：\n\n* 领英: [https://www.linkedin.com/in/simone-poggiali](https://www.linkedin.com/in/simone-poggiali)\n* GitHub: [https://github.com/gibbok](https://github.com/gibbok)\n* X.com: [https://x.com/gibbok_coding](https://x.com/gibbok_coding)\n* 电子邮箱: gibbok.coding📧gmail.com\n\n## TypeScript简介\n\n### 什么是TypeScript？\n\nTypeScript 是一种基于 JavaScript 构建的强类型编程语言。它最初由 Anders Hejlsberg 于 2012 年设计，目前由 Microsoft 作为开源项目开发和维护。\n\nTypeScript 编译为 JavaScript，并且可以在任何 JavaScript 运行时（例如浏览器或服务器 Node.js）中执行。\n\nTypeScript 支持多种编程范式，例如函数式、泛型、命令式和面向对象。TypeScript 既不是解释型语言，也不是编译型语言。\n\n### 为什么选择 TypeScript？\n\nTypeScript 是一种强类型语言，有助于防止常见的编程错误，并在程序执行之前避免某些类型的运行时错误。\n\n强类型语言允许开发人员在数据类型定义中指定各种程序约束和行为，从而有助于验证软件的正确性并防止缺陷。这在大规模应用中尤其有价值。\n\nTypeScript 的一些好处\n\n* 静态类型，可选强类型\n* 类型推断\n* 能使用ES6和ES7的新功能\n* 跨平台和跨浏览器兼容性 \\* IntelliSense 工具支持\n\n### TypeScript 和 JavaScript\n\nTypeScript是用`.ts`或`.tsx`文件编写的, 而JavaScript是用`.js`或`.jsx`文件编写的。\n\n扩展名为.tsx或.jsx的文件可以包含 JavaScript 语法扩展 JSX，该扩展在 React 中用于 UI 开发。\n\n就语法而言，TypeScript 是 JavaScript (ECMAScript 2015) 的类型化超集。所有 JavaScript 代码都是有效的 TypeScript 代码，但反之则不然。\n\n例如，考虑 JavaScript 文件中具有.js扩展名的函数，如下所示：\n\n<!-- skip -->\n```typescript\nconst sum = (a, b) => a + b;\n```\n\n该函数可以通过将文件扩展名更改为 .TypeScript 来转换和使用.ts。但是，如果同一个函数使用 TypeScript 类型进行注释，则未经编译就无法在任何 JavaScript 运行时中执行。如果未编译以下 TypeScript 代码，将会产生语法错误\n\n<!-- skip -->\n```typescript\nconst sum = (a: number, b: number): number => a + b;\n```\n\nTypeScript 旨在通过让开发人员使用类型注释定义意图来检测编译期间运行时可能发生的异常。此外，如果没有提供类型注释，TypeScript 也可以捕获问题。例如，以下代码片段未指定任何 TypeScript 类型：\n\n<!-- skip -->\n```typescript\nconst items = [{ x: 1 }, { x: 2 }];\nconst result = items.filter(item => item.y);\n```\n\n在这种情况下，TypeScript 检测到错误并报告：\n\n```text\n类型 '{ x: number; }' 上不存在属性 'y' 。\n```\n\nTypeScript 的类型系统很大程度上受到 JavaScript 运行时行为的影响。例如，加法运算符 (+) 在 JavaScript 中可以执行字符串连接或数字加法，在 TypeScript 中以相同的方式建模：\n\n```typescript\nconst result = '1' + 1; // 结果是string类型\n```\n\nTypeScript 背后的团队经过深思熟虑，决定将 JavaScript 的异常使用标记为错误。例如，考虑以下有效的 JavaScript 代码：\n\n<!-- skip -->\n```typescript\nconst result = 1 + true; // 在JavaScript中, 结果等于2\n```\n\n但是，TypeScript 会抛出错误：\n\n```text\n运算符\"+\"不能应用于类型\"number\"和\"boolean\"。\n``````\n\n出现此错误的原因是 TypeScript 严格强制执行类型兼容性，在这种情况下，它标识了数字和布尔值之间的无效操作。\n\n### TypeScript 代码生成\n\nTypeScript 编译器有两个主要职责：检查类型错误和编译为 JavaScript。这两个过程是相互独立的。类型不会影响 JavaScript 运行时中代码的执行，因为它们在编译过程中会被完全擦除。即使存在类型错误，TypeScript 仍然可以输出 JavaScript。以下是存在类型错误的 TypeScript 代码示例：\n\n<!-- skip -->\n```typescript\nconst add = (a: number, b: number): number => a + b;\nconst result = add('x', 'y'); // \"字符串\"类型的参数不可赋值给\"数字\"类型的参数\n```\n\n但是，它仍然可以生成可执行的 JavaScript 输出：\n\n<!-- skip -->\n```typescript\n'use strict';\nconst add = (a, b) => a + b;\nconst result = add('x', 'y'); // xy\n```\n\n无法在运行时检查 TypeScript 类型。例如：\n\n<!-- skip -->\n```typescript\ninterface Animal {\n    name: string;\n}\ninterface Dog extends Animal {\n    bark: () => void;\n}\ninterface Cat extends Animal {\n    meow: () => void;\n}\nconst makeNoise = (animal: Animal) => {\n    if (animal instanceof Dog) {\n        // \"Dog\"仅指一种类型，但在这里用作值。\n        // ...\n    }\n};\n```\n\n由于编译后类型被删除，因此无法在 JavaScript 中运行此代码。为了在运行时识别类型，我们需要使用另一种机制。TypeScript 提供了多种选项，其中常见的一个是 \"标签联合（tagged union）\"。例如：\n\n```typescript\ninterface Dog {\n    kind: 'dog'; // 标签联合\n    bark: () => void;\n}\ninterface Cat {\n    kind: 'cat'; // 标签联合\n    meow: () => void;\n}\ntype Animal = Dog | Cat;\n\nconst makeNoise = (animal: Animal) => {\n    if (animal.kind === 'dog') {\n        animal.bark();\n    } else {\n        animal.meow();\n    }\n};\n\nconst dog: Dog = {\n    kind: 'dog',\n    bark: () => console.log('bark'),\n};\nmakeNoise(dog);\n```\n\n属性\"kind\"是一个可以在运行时用来区分 JavaScript 中的对象的值。\n\n运行时的值也可能具有与类型声明中声明的类型不同的类型。例如，如果开发人员误解了 API 类型并对其进行了错误注释。\n\nTypeScript 是 JavaScript 的超集，因此\"class\"关键字可以在运行时用作类型和值。\n\n```typescript\nclass Animal {\n    constructor(public name: string) {}\n}\nclass Dog extends Animal {\n    constructor(public name: string, public bark: () => void) {\n        super(name);\n    }\n}\nclass Cat extends Animal {\n    constructor(public name: string, public meow: () => void) {\n        super(name);\n    }\n}\ntype Mammal = Dog | Cat;\n\nconst makeNoise = (mammal: Mammal) => {\n    if (mammal instanceof Dog) {\n        mammal.bark();\n    } else {\n        mammal.meow();\n    }\n};\n\nconst dog = new Dog('Fido', () => console.log('bark'));\nmakeNoise(dog);\n```\n\n在 JavaScript 中，\"类\"具有\"prototype\"属性，\"instanceof\"运算符可用于测试构造函数的原型属性是否出现在对象原型链中的任何位置。\n\nTypeScript 对运行时性能没有影响，因为所有类型都将被删除。然而，TypeScript 确实引入了一些构建时间开销。\n\n### 现在的现代 JavaScript（降级）\n\nTypeScript 可以将代码编译为自 ECMAScript 3 (1999) 以来任何已发布的 JavaScript 版本。这意味着 TypeScript 可以将代码从最新的 JavaScript 功能转换为旧版本，这一过程称为降级。这允许使用现代 JavaScript，同时保持与旧运行时环境的最大兼容性。\n\n值得注意的是，在转换为旧版本 JavaScript 的过程中，TypeScript 可能会生成与本机实现相比会产生性能开销的代码。\n\n以下是一些可以在 TypeScript 中使用的现代 JavaScript 功能：\n\n* ECMAScript 模块，而不是 AMD 风格的\"define\"回调或 CommonJS 的\"require\"语句。\n* 用类代替原型。\n* 变量声明使用\"let\"或\"const\"而不是\"var\"。\n* \"for-of\"循环或\".forEach\"而不是传统的\"for\"循环。\n* 用箭头函数代替函数表达式。\n* 解构赋值。\n* 简写属性/方法名称和计算属性名称。\n* 默认函数参数。\n\n通过利用这些现代 JavaScript 功能，开发人员可以在 TypeScript 中编写更具表现力和简洁的代码。\n\n## TypeScript 入门\n\n### 安装\n\nVisual Studio Code 为 TypeScript 语言提供了出色的支持，但不包含 TypeScript 编译器。要安装 TypeScript 编译器，您可以使用包管理器，例如 npm 或yarn：\n\n```shell\nnpm install typescript --save-dev\n```\n\n或者\n\n```shell\nyarn add typescript --dev\n```\n\n确保提交生成的锁定文件，以确保每个团队成员使用相同版本的 TypeScript。\n\n要运行TypeScript编译器，可以使用以下命令\n\n```shell\nnpx tsc\n```\n\n或者\n\n```shell\nyarn tsc\n```\n\n建议按项目安装 TypeScript，而不是全局安装，因为它提供了更可预测的构建过程。但是，对于一次性情况，您可以使用以下命令：\n\n```shell\nnpx tsc\n```\n\n或者安装到全局：\n\n```shell\nnpm install -g typescript\n```\n\n如果您使用的是 Microsoft Visual Studio，则可以在 NuGet 中为 MSBuild 项目获取作为包的 TypeScript。在 NuGet 包管理器控制台中，运行以下命令：\n\n```shell\nInstall-Package Microsoft.TypeScript.MSBuild\n```\n\n在 TypeScript 安装过程中，会安装两个可执行文件：\"tsc\"作为 TypeScript 编译器，\"tsserver\"作为 TypeScript 独立服务器。独立服务器包含编译器和语言服务，编辑器和 IDE 可以利用它们来提供智能代码补全。\n\n此外，还有几种兼容 TypeScript 的转译器可用，例如 Babel（通过插件）或 swc。这些转译器可用于将 TypeScript 代码转换为其他目标语言或版本。\n\n### 配置\n\n可以使用 tsc CLI 选项或利用位于项目根目录中名为 tsconfig.json 的专用配置文件来配置 TypeScript。\n\n要生成预填充推荐设置的 tsconfig.json 文件，您可以使用以下命令：\n\n```shell\ntsc --init\n```\n\n在本地执行tsc命令时，TypeScript 将使用最近的 tsconfig.json 文件中指定的配置来编译代码。\n\n以下是使用默认设置运行的 CLI 命令的一些示例：\n\n```shell\ntsc main.ts // 将一个特定的文件 (main.ts) 编译成 JavaScript\ntsc src/*.ts // 将 'src' 文件夹下任意的 .ts 文件编译成 JavaScript\ntsc app.ts util.ts --outfile index.js // 将 2 个 TypeScript 文件 (app.ts 和 util.ts) 编译成 1 个 JavaScript 文件 (index.js)\n```\n\n### TypeScript 的配置文件\n\ntsconfig.json 文件用于配置 TypeScript 编译器 (tsc)。通常，它与文件一起添加到项目的根目录中package.json。\n\n注意：\n\n* tsconfig.json 即使是 json 格式也接受注释。\n* 建议使用此配置文件而不是命令行选项。\n\n在以下链接中，您可以找到完整的文档及其配置示例：\n\n[https://www.typescriptlang.org/tsconfig](https://www.typescriptlang.org/tsconfig)\n\n[http://json.schemastore.org/tsconfig](http://json.schemastore.org/tsconfig)\n\n以下列出了常见且有用的配置：\n\n#### target\n\n\"target\"属性用于指定 TypeScript 应发出/编译到哪个版本的 JavaScript ECMAScript 版本。对于现代浏览器，ES6是一个不错的选择，对于较旧的浏览器，建议使用ES5。\n\n#### lib\n\n\"lib\"属性用于指定编译时要包含哪些库文件。TypeScript 自动包含\"目标\"属性中指定功能的 API，但可以根据特定需求省略或选择特定库。例如，如果您正在开发服务器项目，则可以排除\"DOM\"库，该库仅在浏览器环境中有用。\n\n#### strict\n\n\"strict\"属性可以提供更强有力的保证并增强类型安全性。建议始终将此属性包含在项目的 tsconfig.json 文件中。启用\"strict\"属性允许 TypeScript ：\n\n* 触发每个源文件的代码使用\"use strict\"。\n* 在类型检查过程中考虑\"null\"和\"undefined\"\n* 当不存在类型注释时禁用\"any\"类型的使用。\n* 在使用\"this\"表达式时引发错误，否则\"this\"会被视为任意类型。\n\n#### module\n\n\"module\"属性设置编译程序支持的模块系统。在运行时，模块加载器用于根据指定的模块系统定位并执行依赖项。\nJavaScript 中最常见的模块加载器是用于服务器端应用程序的 Node.js 的CommonJS和用于基于浏览器的 Web 应用程序中的 AMD 模块的 RequireJS。\nTypeScript 可以为各种模块系统生成代码，包括 UMD、System、ESNext、ES2015/ES6 和 ES2020。\n\n注意：应根据目标环境和该环境中可用的模块加载机制来选择模块系统。\n\n#### moduleResolution\n\n\"moduleResolution\"属性指定模块解析策略。对现代TypeScript代码使用\"node\"，\"classic\"仅用于旧版本的 TypeScript（1.6 之前）。\n\n#### esModuleInterop\n\n\"esModuleInterop\"属性允许从未使用\"default\"属性导出的 CommonJS 模块导入默认值，此属性提供了一个兼容以确保生成的 JavaScript 的兼容性。启用此选项后，我们可以使用 `import MyLibrary from \"my-library\"` 而不是 `import * as MyLibrary from \"my-library\"`。\n\n#### jsx\n\n\"jsx\"属性仅适用于 ReactJS 中使用的 .tsx 文件，并控制 JSX 构造如何编译为 JavaScript。一个常见的选项是\"preserve\"，它将编译为 .jsx 文件，保持 JSX 不变，以便可以将其传递给 Babel 等不同工具进行进一步转换。\n\n#### skipLibCheck\n\n\"skipLibCheck\"属性将阻止 TypeScript 对整个导入的第三方包进行类型检查。此属性将减少项目的编译时间。TypeScript 仍会根据这些包提供的类型定义检查您的代码。\n\n#### files\n\n\"files\"属性向编译器指示必须始终包含在程序中的文件列表。\n\n#### include\n\n<!-- markdownlint-disable MD049 -->\n\"include\"属性向编译器指示我们想要包含的文件列表。此属性允许类似 glob 的模式，例如 \"\\*_\" 表示任何子目录，\"_\" 表示任何文件名，\"?\" 表示可选字符。\n<!-- markdownlint-enable MD049 -->\n\n#### exclude\n\n\"exclude\"属性向编译器指示不应包含在编译中的文件列表。这可以包括\"node_modules\"等文件或测试文件\n注意：tsconfig.json 允许注释。\n\n### importHelpers\n\nTypeScript 在为某些高级或低级 JavaScript 功能生成代码时使用帮助程序代码。 默认情况下，这些助手会在使用它们的文件中复制。 `importHelpers` 选项从 `tslib` 模块导入这些帮助器，从而使 JavaScript 输出更加高效。\n\n### 迁移到 TypeScript 的建议\n\n对于大型项目，建议采用逐渐过渡的方式，其中 TypeScript 和 JavaScript 代码最初共存。只有小型项目才能一次性迁移到 TypeScript。\n\n此转变的第一步是将 TypeScript 引入构建链过程。这可以通过使用\"allowJs\"编译器选项来完成，该选项允许 .ts 和 .tsx 文件与现有 JavaScript 文件共存。由于当 TypeScript 无法从 JavaScript 文件推断类型时，它会回退到变量的\"any\"类型，因此建议在迁移开始时在编译器选项中禁用\"noImplicitAny\"。\n\n第二步是确保您的 JavaScript 测试与 TypeScript 文件一起工作，以便您可以在转换每个模块时运行测试。如果您正在使用 Jest，请考虑使用ts-jest，它允许您使用 Jest 测试 TypeScript 项目。\n\n第三步是在项目中包含第三方库的类型声明。 这些声明可以第三方库的类型声明文件或专门的声明包中找到，你能通过 [https://www.typescriptlang.org/dt/search](https://www.typescriptlang.org/dt/search) 搜索并安装它们。:\n\n```shell\nnpm install --save-dev @types/package-name or yarn add --dev @types/package-name.\n```\n\n第四步是使用自下而上的方法逐个模块地迁移，遵循从叶开始的依赖关系图。这个想法是开始转换不依赖于其他模块的模块。要可视化依赖关系图，您可以使用该madge工具。\n\n有一些对于转换成 TypeScript 比较友好的模块（外部 API 或规范相关的实用函数和代码），比如Swagger、GraphQL 或 JSONSchema 自动生成 TypeScript 类型定义，并使用在您的项目中。\n\n当没有可用的规范或官方架构时，您可以从原始数据生成类型，例如服务器返回的 JSON。但是，建议从规范而不是数据生成类型，以避免丢失边缘情况。\n\n在迁移过程中，不要进行代码重构，而只专注于向模块添加类型。\n\n第五步是启用\"noImplicitAny\"，这将强制所有类型都是已知和定义的，从而为您的项目提供更好的 TypeScript 体验。\n\n在迁移过程中，您可以使用该@ts-check指令，该指令在 JavaScript 文件中启用 TypeScript 类型检查。该指令提供了宽松版本的类型检查，最初可用于识别 JavaScript 文件中的问题。当@ts-check包含在文件中时，TypeScript 将尝试使用 JSDoc 风格的注释来推断定义。但是，仅在迁移的早期阶段考虑使用 JSDoc 注释。\n\n考虑在你的tsconfig.json文件中将 `noEmitOnError` 设置为 false，即使报告错误，这也将允许您输出 JavaScript 源代码。\n\n## 探索类型系统\n\n### TypeScript 的语言服务\n\nTypeScript 的语言服务, 也被称为 tsserver，提供了各种功能，例如错误报告、诊断、保存时编译、重命名、跳转到定义、补全列表、签名帮助等。 它主要由集成开发环境 (IDE) 使用来提供 IntelliSense 支持。它与 Visual Studio Code 无缝集成，并由 Conquer of Completion (Coc) 等工具使用。\n\n开发人员可以利用专用 API 并创建自己的自定义语言服务插件来增强 TypeScript 编辑体验。这对于实现特殊的 linting 功能或启用自定义模板语言的自动完成特别有用。\n\n<!-- markdownlint-disable MD044 -->\n现实世界中的自定义插件的一个示例是\"typescript-styled-plugin\"，它为样式组件中的 CSS 属性提供语法错误报告和 IntelliSense 支持。\n<!-- markdownlint-enable MD044 -->\n\n有关更多信息和快速入门指南，您可以参考 GitHub 上的官方 TypeScript Wiki： [https://github.com/microsoft/TypeScript/wiki/](https://github.com/microsoft/TypeScript/wiki/)\n\n### 结构类型\n\nTypeScript 基于结构类型系统。这意味着类型的兼容性和等效性由类型的实际结构或定义决定，而不是由其名称或声明位置决定，如 C# 或 C 等主要类型系统中那样。\n\nTypeScript 的结构类型系统是基于 JavaScript 的动态 duck 类型系统在运行时的工作方式而设计的。\n\n以下示例是有效的 TypeScript 代码。正如您所观察到的，\"X\"和\"Y\"具有相同的成员\"a\"，尽管它们具有不同的声明名称。类型由其结构决定，在这种情况下，由于结构相同，因此它们是兼容且有效的。\n\n```typescript\ntype X = {\n    a: string;\n};\ntype Y = {\n    a: string;\n};\nconst x: X = { a: 'a' };\nconst y: Y = x; // 有效\n```\n\n### TypeScript 的基本比较规则\n\nTypeScript 比较过程是递归的，并在任何级别嵌套的类型上执行。\n\n如果\"Y\"至少具有与\"X\"相同的成员，则类型\"X\"与\"Y\"兼容。\n\n```typescript\ntype X = {\n    a: string;\n};\nconst y = { a: 'A', b: 'B' }; // 有效, 至少它拥有相同的成员 X\nconst r: X = y;\n```\n\n函数参数按类型进行比较，而不是按名称进行比较：\n\n```typescript\ntype X = (a: number) => void;\ntype Y = (a: number) => void;\nlet x: X = (j: number) => undefined;\nlet y: Y = (k: number) => undefined;\ny = x; // 有效\nx = y; // 有效\n```\n\n函数返回类型必须相同：\n\n<!-- skip -->\n```typescript\ntype X = (a: number) => undefined;\ntype Y = (a: number) => number;\nlet x: X = (a: number) => undefined;\nlet y: Y = (a: number) => 1;\ny = x; // 无效\nx = y; // 无效\n```\n\n源函数的返回类型必须是目标函数的返回类型的子类型：\n\n<!-- skip -->\n```typescript\nlet x = () => ({ a: 'A' });\nlet y = () => ({ a: 'A', b: 'B' });\nx = y; // 有效\ny = x; // 无效，缺少 b 成员\n```\n\n允许丢弃函数参数，因为这是 JavaScript 中的常见做法，例如使用 \"Array.prototype.map()\"：\n\n```typescript\n[1, 2, 3].map((element, _index, _array) => element + 'x');\n```\n\n因此，以下类型声明是完全有效的：\n\n```typescript\ntype X = (a: number) => undefined;\ntype Y = (a: number, b: number) => undefined;\nlet x: X = (a: number) => undefined;\nlet y: Y = (a: number) => undefined; // 缺少 b 参数\ny = x; // 有效\n```\n\n源类型的任何附加可选参数都是有效的：\n\n```typescript\ntype X = (a: number, b?: number, c?: number) => undefined;\ntype Y = (a: number) => undefined;\nlet x: X = a => undefined;\nlet y: Y = a => undefined;\ny = x; // 有效\nx = y; // 有效\n```\n\n目标类型的任何可选参数在源类型中没有对应的参数都是有效的并且不是错误：\n\n```typescript\ntype X = (a: number) => undefined;\ntype Y = (a: number, b?: number) => undefined;\nlet x: X = a => undefined;\nlet y: Y = a => undefined;\ny = x; // 有效\nx = y; // 有效\n```\n\n其余参数被视为无限系列的可选参数：\n\n```typescript\ntype X = (a: number, ...rest: number[]) => undefined;\nlet x: X = a => undefined; // 有效\n```\n\n如果重载签名与其实现签名兼容，则具有重载的函数有效：\n\n<!-- skip -->\n```typescript\nfunction x(a: string): void;\nfunction x(a: string, b: number): void;\nfunction x(a: string, b?: number): void {\n    console.log(a, b);\n}\nx('a'); // 有效\nx('a', 1); // 有效\n\nfunction y(a: string): void; // 无效, 不兼容重载的签名\nfunction y(a: string, b: number): void;\nfunction y(a: string, b: number): void {\n    console.log(a, b);\n}\ny('a');\ny('a', 1);\n```\n\n如果源参数和目标参数可赋值给超类型或子类型（Bivariance 双变），则函数参数比较成功。\n\n```typescript\n// 超类\nclass X {\n    a: string;\n    constructor(value: string) {\n        this.a = value;\n    }\n}\n// 子类\nclass Y extends X {}\n// 子类\nclass Z extends X {}\n\ntype GetA = (x: X) => string;\nconst getA: GetA = x => x.a;\n\n// 双变（Bivariance） 确实接收超类\nconsole.log(getA(new X('x'))); // 有效\nconsole.log(getA(new Y('Y'))); // 有效\nconsole.log(getA(new Z('z'))); // 有效\n```\n\n枚举与数字具有可比性和有效性，反之亦然，但比较不同枚举类型的枚举值是无效的。\n\n<!-- skip -->\n```typescript\nenum X {\n    A,\n    B,\n}\nenum Y {\n    A,\n    B,\n    C,\n}\nconst xa: number = X.A; // 有效\nconst ya: Y = 0; // 有效\nX.A === Y.A; // 无效\n```\n\n类的实例需要对其私有成员和受保护成员进行兼容性检查：\n\n<!-- skip -->\n```typescript\nclass X {\n    public a: string;\n    constructor(value: string) {\n        this.a = value;\n    }\n}\n\nclass Y {\n    private a: string;\n    constructor(value: string) {\n        this.a = value;\n    }\n}\n\nlet x: X = new Y('y'); // 无效\n```\n\n比较检查不考虑不同的继承层次结构，例如：\n\n```typescript\nclass X {\n    public a: string;\n    constructor(value: string) {\n        this.a = value;\n    }\n}\nclass Y extends X {\n    public a: string;\n    constructor(value: string) {\n        super(value);\n        this.a = value;\n    }\n}\nclass Z {\n    public a: string;\n    constructor(value: string) {\n        this.a = value;\n    }\n}\nlet x: X = new X('x');\nlet y: Y = new Y('y');\nlet z: Z = new Z('z');\nx === y; // 有效\nx === z; // 有效即使 z 来自不同的继承层次结构\n```\n\n泛型根据应用泛型参数后的结果类型使用其结构进行比较，仅将最终结果作为非泛型类型进行比较。\n\n<!-- skip -->\n```typescript\ninterface X<T> {\n    a: T;\n}\nlet x: X<number> = { a: 1 };\nlet y: X<string> = { a: 'a' };\nx === y; // 无效，因为最终结构中使用了类型参数\n```\n\n```typescript\ninterface X<T> {}\nconst x: X<number> = 1;\nconst y: X<string> = 'a';\nx === y; // 有效，因为最终结构中没有使用类型参数\n```\n\n当泛型未指定其类型参数时，所有未指定的参数都将被视为带有\"any\"的类型：\n\n```typescript\ntype X = <T>(x: T) => T;\ntype Y = <K>(y: K) => K;\nlet x: X = x => x;\nlet y: Y = y => y;\nx = y; // 有效\n```\n\n记住：\n\n<!-- skip -->\n```typescript\nlet a: number = 1;\nlet b: number = 2;\na = b; // 有效，一切都可以赋值给自己\n\nlet c: any;\nc = 1; // 有效，所有类型都可以赋值给any\n\nlet d: unknown;\nd = 1; // 有效，所有类型都可以赋值给unknown\n\nlet e: unknown;\nlet e1: unknown = e; // 有效, unknown只能赋值给自己和any\nlet e2: any = e; // 有效\nlet e3: number = e; // 无效\n\nlet f: never;\nf = 1; // 无效, 所有类型不能赋值给never\n\nlet g: void;\nlet g1: any;\ng = 1; // 无效, void不可赋值给除\"any\"之外的任何内容或从任何内容赋值\ng = g1; // 有效\n```\n\n请注意，当启用\"strictNullChecks\"时，\"null\"和\"undefined\"的处理方式与\"void\"类似；否则，它们类似于\"never\"。\n\n### 类型作为集合\n\n在 TypeScript 中，类型是一组可能的值。该集合也称为类型的域。类型的每个值都可以被视为集合中的一个元素。类型建立了集合中的每个元素必须满足才能被视为该集合的成员的约束。TypeScript 的主要任务是检查并验证一组是否是另一组的子集。\n\nTypeScript 支持各种类型的集合：\n\n| Set term | TypeScript                      | Notes                                                                          |\n| -------- | ------------------------------- | ------------------------------------------------------------------------------ |\n| 空集     | never                           | \"never\" 包含除自身之外的任何类型                                               |\n| 单元素集 | undefined / null / literal type |                                                                                |\n| 有限集   | boolean / union                 |                                                                                |\n| 无限集   | string / number / object        |                                                                                |\n| 通用集   | any / unknown                   | 每个元素都是\"any\"的成员，每个集合都是它的子集/\"unknown\"是\"any\"的类型安全对应项 |\n\n这里有几个例子：\n\n| TypScript             | Set term         | Example                                                          |\n| --------------------- | ---------------- | ---------------------------------------------------------------- |\n| never                 | ∅ (空集)         | const x: never = 'x'; // 错误: 'string'类似不能赋值给'never'类型 |\n|                       |                  |\n| Literal type          | 单元素集         | type X = 'X';                                                    |\n|                       |                  | type Y = 7;                                                      |\n|                       |                  |\n| Value assignable to T | Value ∈ T (属于) | type XY = 'X' \\| 'Y';                                            |\n|                       |                  | const x: XY = 'X';                                               |\n|                       |                  |\n| T1 assignable to T2   | T1 ⊆ T2 (子集)   | type XY = 'X' \\| 'Y';                                            |\n|                       |                  | const x: XY = 'X';                                               |\n|                       |                  | const j: XY = 'J'; // 类型'\"J\"' 不能赋值给 'XY' 类型.            |\n|                       |                  |                                                                  |\n| T1 extends T2         | T1 ⊆ T2 (子集)   | type X = 'X' extends string ? true : false;                      |\n|                       |                  |\n| T1 \\| T2              | T1 ∪ T2 (并集)   | type XY = 'X' \\| 'Y';                                            |\n|                       |                  | type JK = 1 \\| 2;                                                |\n|                       |                  |\n| T1 & T2               | T1 ∩ T2 (交集)   | type X = \\{ a: string \\}                                           |\n|                       |                  | type Y = \\{ b: string \\}                                           |\n|                       |                  | type XY = X & Y                                                  |\n|                       |                  | const x: XY = \\{ a: 'a', b: 'b' \\}                                 |\n|                       |                  |\n| unknown               | 通用集           | const x: unknown = 1                                             |\n\n并集 (T1 | T2) 创建一个更广泛的集合（两者）：\n\n```typescript\ntype X = {\n    a: string;\n};\ntype Y = {\n    b: string;\n};\ntype XY = X | Y;\nconst r: XY = { a: 'a', b: 'x' }; // 有效\n```\n\n交集（T1 & T2）创建一个更窄的集合（仅共享）：\n\n<!-- skip -->\n```typescript\ntype X = {\n    a: string;\n};\ntype Y = {\n    a: string;\n    b: string;\n};\ntype XY = X & Y;\nconst r: XY = { a: 'a' }; // 无效\nconst j: XY = { a: 'a', b: 'b' }; // 有效\n```\n\n在这种情况下，关键字extends可以被视为\"的子集\"。它为类型设置约束。与泛型一起使用的扩展将泛型视为无限集，并将其限制为更具体的类型。请注意，这extends与 OOP 意义上的层次结构无关（TypScript 中没有这个概念）。TypeScript 使用集合并且没有严格的层次结构，事实上，如下面的示例所示，两种类型可以重叠，而不会成为另一种类型的子类型（TypScript 考虑对象的结构和形状）。\n\n```typescript\ninterface X {\n    a: string;\n}\ninterface Y extends X {\n    b: string;\n}\ninterface Z extends Y {\n    c: string;\n}\nconst z: Z = { a: 'a', b: 'b', c: 'c' };\ninterface X1 {\n    a: string;\n}\ninterface Y1 {\n    a: string;\n    b: string;\n}\ninterface Z1 {\n    a: string;\n    b: string;\n    c: string;\n}\nconst z1: Z1 = { a: 'a', b: 'b', c: 'c' };\n\nconst r: Z1 = z; // 有效\n```\n\n### 赋值类型：类型声明和类型断言\n\n在 TypeScript 中可以通过不同的方式赋值类型：\n\n#### 类型声明\n\n在下面的示例中，我们使用 x:X(\":Type\") 来声明变量 x 的类型。\n\n```typescript\ntype X = {\n    a: string;\n};\n\n// 类型声明\nconst x: X = {\n    a: 'a',\n};\n```\n\n如果变量不是指定的格式，TypeScript 将报告错误。例如：\n\n<!-- skip -->\n```typescript\ntype X = {\n    a: string;\n};\n\nconst x: X = {\n    a: 'a',\n    b: 'b', // 错误: 对象字面量只能指定已知属性\n};\n```\n\n#### 类型断言\n\n可以使用as关键字添加断言。这告诉编译器开发人员拥有有关类型的更多信息并消除可能发生的任何错误。\n\n例如：\n\n```typescript\ntype X = {\n    a: string;\n};\nconst x = {\n    a: 'a',\n    b: 'b',\n} as X;\n```\n\n在上面的示例中，使用 as 关键字将对象 x 断言为类型 X。这通知 TypeScript 编译器该对象符合指定的类型，即使它具有类型定义中不存在的附加属性 b。\n\n类型断言在需要指定更具体类型的情况下非常有用，尤其是在使用 DOM 时。例如：\n\n```typescript\nconst myInput = document.getElementById('my_input') as HTMLInputElement;\n```\n\n此处，类型断言 HTMLInputElement 用于告诉 TypeScript getElementById 的结果应被视为 HTMLInputElement。类型断言还可以用于重新映射键，如下面使用模板文字的示例所示：\n\n```typescript\ntype J<Type> = {\n    [Property in keyof Type as `prefix_${string &\n        Property}`]: () => Type[Property];\n};\ntype X = {\n    a: string;\n    b: number;\n};\ntype Y = J<X>;\n```\n\n在此示例中，类型 J 使用带有模板文字的映射类型来重新映射 Type 的键。它创建新属性，并在每个键上添加 prefix_ ，它们对应的值是返回原始属性值的函数。\n\n值得注意的是，当使用类型断言时，TypeScript 不会执行多余的属性检查。因此，当预先知道对象的结构时，通常最好使用类型声明。\n\n#### 非空断言\n\n此断言是使用后缀表达式!运算符应用的，它告诉 TypeScript 值不能为 null 或未定义。\n\n```typescript\nlet x: null | number;\nlet y = x!; // number\n```\n\n#### 环境声明\n\n环境声明是描述 JavaScript 代码类型的文件，它们的文件名格式为.d.ts.. 它们通常被导入并用于注释现有的 JavaScript 库或向项目中的现有 JS 文件添加类型。\n\n许多常见的库类型可以在以下位置找到：\n[https://github.com/DefinitelyTyped/DefinitelyTyped/](https://github.com/DefinitelyTyped/DefinitelyTyped/)\n\n```shell\nnpm install --save-dev @types/library-name\n```\n\n对于您定义的环境声明，您可以使用\"三斜杠\"引用导入：\n\n<!-- skip -->\n```typescript\n/// <reference path=\"./library-types.d.ts\" />\n```\n\n即使在 JavaScript 文件中，您也可以通过 `// @ts-check` 使用环境声明。\n\n`declare` 关键字可以为现有的 JavaScript 代码启用类型定义，而无需导入它，作为来自另一个文件或全局的类型的占位符。\n\n### 属性检测和多余属性检测\n\nTypeScript 基于结构类型系统，但过多的属性检查是 TypeScript 的一个属性，它允许它检查对象是否具有类型中指定的确切属性。\n\n例如，在将对象字面量赋值给变量或将它们作为参数传递给函数的多余属性时，会执行多余属性检查。\n\n<!-- skip -->\n```typescript\ntype X = {\n    a: string;\n};\nconst y = { a: 'a', b: 'b' };\nconst x: X = y; // 有效，因为结构类型\nconst w: X = { a: 'a', b: 'b' }; // 无效，因为多余属性检测\n```\n\n### 弱类型\n\n当一个类型只包含一组全可选属性时，该类型被认为是弱类型：\n\n```typescript\ntype X = {\n    a?: string;\n    b?: string;\n};\n```\n\n当没有重叠时，TypeScript 认为将任何内容赋值给弱类型是错误的，例如，以下会引发错误：\n\n<!-- skip -->\n```typescript\ntype Options = {\n    a?: string;\n    b?: string;\n};\n\nconst fn = (options: Options) => undefined;\n\nfn({ c: 'c' }); // 无效\n```\n\n尽管不推荐，但如果需要，可以使用类型断言绕过此检查：\n\n```typescript\ntype Options = {\n    a?: string;\n    b?: string;\n};\nconst fn = (options: Options) => undefined;\nfn({ c: 'c' } as Options); // 有效\n```\n\n或者通过将unknown索引签名添加到弱类型：\n\n```typescript\ntype Options = {\n    [prop: string]: unknown;\n    a?: string;\n    b?: string;\n};\n\nconst fn = (options: Options) => undefined;\nfn({ c: 'c' }); // 有效\n```\n\n### 严格的对象字面量检测 (Freshness)\n\n严格的对象字面量检查（有时称为“新鲜度”）是 TypeScript 中的一项功能，有助于捕获多余或拼写错误的属性，否则这些属性在正常结构类型检查中会被忽视。\n\n创建对象字面量时，TypeScript 编译器认为它是“新鲜的”。 如果将对象字面量分配给变量或作为参数传递，并且对象字面量指定目标类型中不存在的属性，则 TypeScript 将引发错误。\n\n然而，当扩展对象文字或使用类型断言时，“新鲜感”就会消失。\n\n下面举一些例子来说明：\n\n<!-- skip -->\n```typescript\ntype X = { a: string };\ntype Y = { a: string; b: string };\n\nlet x: X;\nx = { a: 'a', b: 'b' }; // 严格的对象字面量检查：无效的赋值\nvar y: Y;\ny = { a: 'a', bx: 'bx' }; // 严格的对象字面量检查：无效的赋值\n\nconst fn = (x: X) => console.log(x.a);\n\nfn(x);\nfn(y); // 类型加宽：没有错误, 结构类型兼容\n\nfn({ a: 'a', bx: 'b' }); // 严格的对象字面量检查：无效的参数\n\nlet c: X = { a: 'a' };\nlet d: Y = { a: 'a', b: '' };\nc = d; // 类型加宽：没有严格的对象字面量检查\n```\n\n### 类型推断\n\n当在以下期间未提供注释时，TypeScript 可以推断类型：\n\n* 变量初始化\n* 成员初始化。\n* 设置参数的默认值。\n* 函数返回类型。\n\n例如：\n\n```typescript\nlet x = 'x'; // 推断的类型是 string\n```\n\nTypeScript 编译器分析值或表达式并根据可用信息确定其类型。\n\n### 更高级的推断\n\n当在类型推断中使用多个表达式时，TypeScript 会查找\"最佳常见类型\"。例如：\n\n```typescript\nlet x = [1, 'x', 1, null]; // 类型推断为: (string | number | null)[]\n```\n\n如果编译器找不到最佳通用类型，它将返回联合类型。例如：\n\n```typescript\nlet x = [new RegExp('x'), new Date()]; // 类型推断为: (RegExp | Date)[]\n```\n\nTypeScript 利用基于变量位置的\"上下文类型\"来推断类型。在下面的示例中，编译器知道它的e类型是MouseEvent，因为在lib.d.ts 文件中定义了click事件类型，该文件包含各种常见 JavaScript 构造和 DOM 的环境声明：\n\n```typescript\nwindow.addEventListener('click', function (e) {}); // e 的类型被推断为 MouseEvent\n```\n\n### 类型加宽\n\n类型加宽是 TypeScript 将类型分配给未提供类型注释时初始化的变量的过程。它允许从窄到宽的类型，但反之则不然。在以下示例中：\n\n<!-- skip -->\n```typescript\nlet x = 'x'; // TypeScript 推断为字符串，一种宽类型\nlet y: 'y' | 'x' = 'y'; // y 类型是字面量类型的联合\ny = x; // 无效，字符串不可分配给类型 'x' | 'y'。\n```\n\nTypeScript根据初始化期间提供的单个值（`x`），将 `string` 赋予给 `x`，这是一个扩展的示例。\n\nTypeScript 提供了控制加宽过程的方法，例如使用\"const\"。\n\n### 常量\n\n在声明变量时使用 `const` 关键字会导致 TypeScript 中的类型推断范围更窄。\n\nFor example:\n\n```typescript\nconst x = 'x'; // TypeScript 将 x 的类型推断为 'x'，一种较窄的类型\nlet y: 'y' | 'x' = 'y';\ny = x; // 有效: x的类型推断为 'x'\n```\n\n通过使用 const 声明变量 x，其类型被缩小为特定的文字值\"x\"。由于 x 的类型被缩小，因此可以将其赋值给变量 y 而不会出现任何错误。可以推断类型的原因是因为 const 变量无法重新分配，因此它们的类型可以缩小到特定的文字类型，在本例中为字面量类型\"x\"。\n\n#### 类型参数的 const 修饰符\n\n从 TypeScript 5.0 版本开始，可以 `const` 在泛型类型参数上指定属性。这可以推断出最精确的类型。让我们看一个不使用 `const` 的示例：\n\n```typescript\nfunction identity<T>(value: T) {\n    // 这里没有const\n    return value;\n}\nconst values = identity({ a: 'a', b: 'b' }); // 类型推断为: { a: string; b: string; }\n```\n\n正如您所看到的，属性a和b是通过 类型推断出来的string 。\n\n现在，让我们看看 `const` 版本的差异：\n\n```typescript\nfunction identity<const T>(value: T) {\n    // 对类型参数使用 const 修饰符\n    return value;\n}\nconst values = identity({ a: 'a', b: 'b' }); // 类型推断为: { a: \"a\"; b: \"b\"; }\n```\n\n现在我们可以看到属性 `a` 和 `b` 被推断为const，因此 `a` 和 `b`被视为字符串文字而不仅仅是 `string` 类型。\n\n### 常量断言\n\n此功能允许您根据变量的初始化值声明具有更精确的文字类型的变量，这向编译器表明该值应被视为不可变文字。 这里有一些例子：\n\n在单个属性上：\n\n```typescript\nconst v = {\n    x: 3 as const,\n};\nv.x = 3;\n```\n\n在整个对象上：\n\n```typescript\nconst v = {\n    x: 1,\n    y: 2,\n} as const;\n```\n\n这在定义元组的类型时特别有用：\n\n```typescript\nconst x = [1, 2, 3]; // number[]\nconst y = [1, 2, 3] as const; // 只读数组 [1, 2, 3]\n```\n\n### 显式类型注释\n\n我们可以具体地传递一个类型，在下面的示例中，属性x的类型是number：\n\n```typescript\nconst v = {\n    x: 1, // 推断类型: number (加宽了)\n};\nv.x = 3; // 有效\n```\n\n我们可以通过使用字面量类型的联合使类型注释更加具体：\n\n<!-- skip -->\n```typescript\nconst v: { x: 1 | 2 | 3 } = {\n    x: 1, // x 现在是字面量的联合类型： 1 | 2 | 3\n};\nv.x = 3; // 有效\nv.x = 100; // 无效的\n```\n\n### 类型缩小\n\n类型缩小是 TypeScript 中的一个过程，其中一般类型缩小为更具体的类型。当 TypeScript 分析代码并确定某些条件或操作可以细化类型信息时，就会发生这种情况。\n\n缩小类型可以通过不同的方式发生，包括：\n\n#### 条件\n\n通过使用条件语句（比如 `if` 或 `switch`），TypeScript 可以根据条件的结果缩小类型范围。例如：\n\n```typescript\nlet x: number | undefined = 10;\n\nif (x !== undefined) {\n    x += 100; // 由于条件判断，类型被缩小为 number\n}\n```\n\n#### 抛错或者返回\n\n抛出错误或从分支提前返回可用于帮助 TypeScript 缩小类型范围。例如：\n\n```typescript\nlet x: number | undefined = 10;\n\nif (x === undefined) {\n    throw 'error';\n}\nx += 100;\n```\n\n在 TypeScript 中缩小类型范围的其他方法包括：\n\n* `instanceof` 操作: 用于检查对象是否是特定类的实例。\n* `in` 操作: 用于检查对象中是否存在属性。\n* `typeof` 操作: 用于在运行时检查值的类型。\n* 内部函数，比如: `Array.isArray()`: 用于检查值是否为数组。\n\n#### 可区分联合\n\n使用\"可区分联合\"是 TypeScript 中的一种模式，其中向对象添加显式\"标签\"以区分联合内的不同类型。该模式也称为\"标记联合\"。在以下示例中，\"tag\"由属性\"type\"表示：\n\n```typescript\ntype A = { type: 'type_a'; value: number };\ntype B = { type: 'type_b'; value: string };\n\nconst x = (input: A | B): string | number => {\n    switch (input.type) {\n        case 'type_a':\n            return input.value + 100; // 类型为 A\n        case 'type_b':\n            return input.value + 'extra'; // 类型为 B\n    }\n};\n```\n\n#### 用户定义的类型保护\n\n在 TypeScript 无法确定类型的情况下，可以编写一个称为\"用户定义类型保护\"的辅助函数。在下面的示例中，我们将在应用某些过滤后利用类型谓词来缩小类型范围：\n\n```typescript\nconst data = ['a', null, 'c', 'd', null, 'f'];\n\nconst r1 = data.filter(x => x != null); // 类型为 (string | null)[], TypeScript 不能准确推断类型\n\nconst isValid = (item: string | null): item is string => item !== null; // 自定义类型保护\n\nconst r2 = data.filter(isValid); // 类型现在为 string[], 通过使用断言类型保护，我们能够缩小类型\n```\n\n## 原始类型\n\nTypeScript 支持 7 种基本类型。原始数据类型是指不是对象并且没有任何与其关联的方法的类型。在 TypeScript 中，所有原始类型都是不可变的，这意味着它们的值一旦分配就无法更改。\n\n### string\n\n原始 `string` 类型存储文本数据，并且值始终是双引号或单引号的。\n\n```typescript\nconst x: string = 'x';\nconst y: string = 'y';\n```\n\n如果字符串被反引号 (`) 字符包围，则字符串可以跨越多行：\n\n```typescript\nlet sentence: string = `xxx,\n   yyy`;\n```\n\n### boolean\n\nTypeScript 中的数据 `boolean` 类型存储二进制值，或者true或false。\n\n```typescript\nconst isReady: boolean = true;\n```\n\n### number\n\nTypeScript 中的数据类型 `number` 用 64 位浮点值表示。类型 `number` 可以表示整数和分数。TypeScript 还支持十六进制、二进制和八进制，例如：\n\n```typescript\nconst decimal: number = 10;\nconst hexadecimal: number = 0xa00d; // 十六进制数以 0x 开始\nconst binary: number = 0b1010; // 二进制数以 0b 开始\nconst octal: number = 0o633; // 八进制数以 0o 开始\n```\n\n### bigInt\n\n`bigInt` 表示无法用 `number` 表示的非常大的数值 (253 – 1)。\n\n`bigInt` 可以通过调用内置函数 `BigInt()` 或添加 `n` 到任何整数数字字面量的末尾来创建：\n\n```typescript\nconst x: bigint = BigInt(9007199254740991);\nconst y: bigint = 9007199254740991n;\n```\n\n笔记：\n\n* `bigInt` 值不能与 `number` 混合，也不能与内置的 `Math` 一起使用，它们必须强制为相同的类型。\n* 仅当目标配置为 ES2020 或更高版本时，“bigInt”值才可用。\n\n### symbol\n\nJavaScript 有一个原始函数 Symbol()，它创建一个全局唯一的引用。\n\n```typescript\nlet sym = Symbol('x'); // symbol 类型\n```\n\n### null and undefined\n\n`null`和 `undefined` 类型都表示没有值或不存在任何值。\n\n`undefined` 类型意味着该值未分配或初始化，或者指示无意中缺少值。\n\n`null` 类型意味着我们知道该字段没有值，因此值不可用，这表明故意不存在值。\n\n### Array\n\n`array` 是一种可以存储多个相同类型或不同类型的值的数据类型。可以使用以下语法定义它：\n\n```typescript\nconst x: string[] = ['a', 'b'];\nconst y: Array<string> = ['a', 'b'];\nconst j: Array<string | number> = ['a', 1, 'b', 2];\n```\n\nTypeScript 使用以下语法支持只读数组：\n\n<!-- skip -->\n```typescript\nconst x: readonly string[] = ['a', 'b']; // 只读修饰符\nconst y: ReadonlyArray<string> = ['a', 'b'];\nconst j: ReadonlyArray<string | number> = ['a', 1, 'b', 2];\nj.push('x'); // 有效\n```\n\nTypeScript 支持数组和只读数组：\n\n```typescript\nconst x: [string, number] = ['a', 1];\nconst y: readonly [string, number] = ['a', 1];\n```\n\n### any\n\n数据 `any` 类型字面上代表\"任何\"值，当 TypeScript 无法推断类型或未指定时，它是默认值。\n\n使用 `any` 时，TypeScript编译器会跳过类型检查，因此 `any` 使用时不存在类型安全。通常，当发生错误时不要使用 `any` 静默编译器，而是专注于修复错误，因为使用 `any` 它可能会破坏契约，并且我们会失去 TypeScript 自动完成的好处。\n\n在从 JavaScript 逐步迁移到 TypeScript 的过程中，该 `any` 类型可能很有用，因为它可以让编译器保持沉默。\n\n对于新项目，请使用 TypeScript 配置 `noImplicitAny` ，该配置使 TypeScript 能够在any使用或推断时发出错误。\n\n`any` 通常是错误的来源，它可以掩盖类型的实际问题。尽可能避免使用它。\n\n## 类型注释\n\n在使用 `var` 、 `let` 和 `const` 声明变量时，可以选择添加类型：\n\n```typescript\nconst x: number = 1;\n```\n\nTypeScript 在推断类型方面做得很好，尤其是简单类型时，因此在大多数情况下这些声明是不必要的。\n\n在函数上可以向参数添加类型注释：\n\n```typescript\nfunction sum(a: number, b: number) {\n    return a + b;\n}\n```\n\n以下是使用匿名函数（所谓的 lambda 函数）的示例：\n\n```typescript\nconst sum = (a: number, b: number) => a + b;\n```\n\n当参数存在默认值时可以避免这些注释：\n\n```typescript\nconst sum = (a = 10, b: number) => a + b;\n```\n\n可以将返回类型注释添加到函数中：\n\n```typescript\nconst sum = (a = 10, b: number): number => a + b;\n```\n\n这对于更复杂的函数尤其有用，因为在实现之前编写显式返回类型可以帮助更好地思考该函数。\n\n通常考虑注释类型签名，但不注释主体局部变量，并始终将类型添加到对象字面量中。\n\n## 可选属性\n\n对象可以通过在属性名称末尾添加问号 `?` 来指定可选属性：\n\n```typescript\ntype X = {\n    a: number;\n    b?: number; // 可选的\n};\n```\n\n当属性是可选的时，可以指定默认值\n\n```typescript\ntype X = {\n    a: number;\n    b?: number;\n};\nconst x = ({ a, b = 100 }: X) => a + b;\n```\n\n## 只读属性\n\n是否可以通过使用修饰符来防止对属性进行写入，`readonly` 以确保该属性不能被重写，但不提供任何完全不变性的保证：\n\n```typescript\ninterface Y {\n    readonly a: number;\n}\n\ntype X = {\n    readonly a: number;\n};\n\ntype J = Readonly<{\n    a: number;\n}>;\n\ntype K = {\n    readonly [index: number]: string;\n};\n```\n\n## 索引签名\n\n在 TypeScript 中，我们可以使用 `string` 、`number` 和 `symbol` 作为索引签名：\n\n```typescript\ntype K = {\n    [name: string | number]: string;\n};\nconst k: K = { x: 'x', 1: 'b' };\nconsole.log(k['x']);\nconsole.log(k[1]);\nconsole.log(k['1']); // 同 k[1] 的结果相同\n```\n\n请注意，JavaScript 会自动将 `number` 的索引转换相同值的 'string'索引, 比如 `k[1]` 和 `k[\"1\"]` 返回相同值。\n\n## 扩展类型\n\n可以扩展 `interface`（从另一种类型复制成员）：\n\n```typescript\ninterface X {\n    a: string;\n}\ninterface Y extends X {\n    b: string;\n}\n```\n\n还可以从多种 `interface` 进行扩展：\n\n```typescript\ninterface A {\n    a: string;\n}\ninterface B {\n    b: string;\n}\ninterface Y extends A, B {\n    y: string;\n}\n```\n\n该 `extends` 关键字仅适用于 `interface`，因为 `type` 使用交集：\n\n```typescript\ntype A = {\n    a: number;\n};\ntype B = {\n    b: number;\n};\ntype C = A & B;\n```\n\n可以使用 `interface` 来扩展类 `type`，但反之则不然：\n\n```typescript\ntype A = {\n    a: string;\n};\ninterface B extends A {\n    b: string;\n}\n```\n\n## 字面量类型\n\n文字类型是来自集体类型的单个元素集，它定义了一个非常精确的值，即 JavaScript 原始数据。\n\nTypeScript 中的文字类型是数字、字符串和布尔值。\n\n示例如下:\n\n```typescript\nconst a = 'a'; // 字符串字面量类型\nconst b = 1; // 数字字面量类型\nconst c = true; // 布尔字面量类型\n```\n\n字符串、数字和布尔字面量类型用于联合、类型保护和类型别名。在下面的示例中，您可以看到类型别名联合，O可以是指定的唯一值，而不是任何其他字符串：\n\n```typescript\ntype O = 'a' | 'b' | 'c';\n```\n\n## 字面量推断\n\n字面量推断是 TypeScript 中的一项功能，允许根据变量或参数的值推断其类型。\n\n在下面的示例中，我们可以看到 TypeScript 认为x文字类型是因为该值以后不能随时更改，而y被推断为字符串，因为它以后可以随时修改。\n\n```typescript\nconst x = 'x'; // x 为字面量类型, 因为值不能改变\nlet y = 'y'; // string, 我们能改变这个值\n```\n\n在下面的示例中，我们可以看到 `o.x` 被推断为 `string`（而不是字面量的a），因为 TypeScript 认为该值可以在以后随时更改。\n\n<!-- skip -->\n```typescript\ntype X = 'a' | 'b';\n\nlet o = {\n    x: 'a', // 这是一个更宽的 string\n};\n\nconst fn = (x: X) => `${x}-foo`;\n\nconsole.log(fn(o.x)); // 'string' 类型的参数不能赋值给 'X' 类型的参数\n```\n\n正如你所看到的代码在传递 `o.x` 给 `fn` 作为一个狭窄类型时，抛出了一个错误。\n\n我们能通过使用 `const` 或者 `X` 来借助类型推断解决这个问题：\n\n<!-- skip -->\n```typescript\nlet o = {\n    x: 'a' as const,\n};\n```\n\nor:\n\n<!-- skip -->\n```typescript\nlet o = {\n    x: 'a' as X,\n};\n```\n\n## 严格空检查\n\n`strictNullChecks` 是一个 TypeScript 编译器选项，强制执行严格的 null 检查。启用此选项后，只有在变量和参数已使用联合类型 `null` | `undefined` 显式声明为该类型时，才可以对其进行赋值`null` 或者 `undefined`。如果变量或参数未显式声明为可为空，TypeScript 将生成错误以防止潜在的运行时错误。\n\n## 枚举\n\n在 TypeScript 中，枚举是一组命名常量值。\n\n```typescript\nenum Color {\n    Red = '#ff0000',\n    Green = '#00ff00',\n    Blue = '#0000ff',\n}\n```\n\n枚举可以用不同的方式定义：\n\n### 数字枚举\n\n在 TypeScript 中，数字枚举是一个枚举，其中每个常量都分配有一个数值，默认从 0 开始。\n\n```typescript\nenum Size {\n    Small, // 值从 0 开始\n    Medium,\n    Large,\n}\n```\n\n可以通过显式分配来指定自定义值：\n\n```typescript\nenum Size {\n    Small = 10,\n    Medium,\n    Large,\n}\nconsole.log(Size.Medium); // 11\n```\n\n### 字符串枚举\n\n在 TypeScript 中，字符串枚举是每个常量都分配有一个字符串值的枚举。\n\n```typescript\nenum Language {\n    English = 'EN',\n    Spanish = 'ES',\n}\n```\n\n注意：TypeScript 允许使用异构枚举，其中字符串和数字成员可以共存。\n\n### 常量枚举\n\nTypeScript 中的常量枚举是一种特殊类型的枚举，其中所有值在编译时都是已知的，并且在使用枚举的任何地方都会内联，从而产生更高效的代码。\n\n```typescript\nconst enum Language {\n    English = 'EN',\n    Spanish = 'ES',\n}\nconsole.log(Language.English);\n```\n\n将被编译成：\n\n```typescript\nconsole.log('EN' /* Language.English */);\n```\n\n注意：常量枚举具有硬编码值，擦除枚举，这在独立库中可能更有效，但通常是不可取的。此外，常量枚举不能有计算成员。\n\n### 反向映射\n\n在 TypeScript 中，枚举中的反向映射是指从值中检索枚举成员名称的能力。默认情况下，枚举成员具有从名称到值的正向映射，但可以通过为每个成员显式设置值来创建反向映射。当您需要按枚举成员的值查找枚举成员，或者需要迭代所有枚举成员时，反向映射非常有用。需要注意的是，只有数字类型的枚举成员会生成反向映射，字符串类型的枚举成员则不会。\n\n以下枚举：\n\n```typescript\nenum Grade {\n    A = 90,\n    B = 80,\n    C = 70,\n    F = 'fail',\n}\n```\n\n编译为：\n\n<!-- skip -->\n```javascript\n'use strict';\nvar Grade;\n(function (Grade) {\n    Grade[(Grade['A'] = 90)] = 'A';\n    Grade[(Grade['B'] = 80)] = 'B';\n    Grade[(Grade['C'] = 70)] = 'C';\n    Grade['F'] = 'fail';\n})(Grade || (Grade = {}));\n```\n\n由此可见，对数字类型的枚举成员，可以从枚举值映射回枚举名称，但对字符串类型的枚举成员无法这样做。\n\n<!-- skip -->\n```typescript\nenum Grade {\n    A = 90,\n    B = 80,\n    C = 70,\n    F = 'fail',\n}\nconst myGrade = Grade.A;\nconsole.log(Grade[myGrade]); // A\nconsole.log(Grade[90]); // A\n\nconst failGrade = Grade.F;\nconsole.log(failGrade); // fail\nconsole.log(Grade[failGrade]); // 因为索引表达式的类型不是 'number'，所以元素是隐式的 'any' 类型。\n```\n\n### 环境枚举\n\nTypeScript 中的环境枚举是一种在声明文件 (*.d.ts) 中定义的枚举类型，没有关联的实现。它允许您定义一组命名常量，这些常量可以在不同文件中以类型安全的方式使用，而无需在每个文件中导入实现细节。\n\n### 计算成员和常量成员\n\n在 TypeScript 中，计算成员是枚举的成员，其值在运行时计算，而常量成员是其值在编译时设置且在运行时无法更改的成员。常规枚举中允许使用计算成员，而常规枚举和常量枚举中都允许使用常量成员。\n\n```typescript\n// 常量成员\nenum Color {\n    Red = 1,\n    Green = 5,\n    Blue = Red + Green,\n}\nconsole.log(Color.Blue); // 6 编译时生成\n```\n\n```typescript\n// 计算成员\nenum Color {\n    Red = 1,\n    Green = Math.pow(2, 2),\n    Blue = Math.floor(Math.random() * 3) + 1,\n}\nconsole.log(Color.Blue); // 运行时生成的随机数\n```\n\n枚举由包含其成员类型的联合表示。每个成员的值可以通过常量或非常量表达式确定，拥有常量值的成员被分配字面量类型。为了说明这一点，请考虑类型 E 及其子类型 E.A、E.B 和 E.C 的声明。在本例中，E 表​​示联合 E.A | E.B | E.C 。\n\n```typescript\nconst identity = (value: number) => value;\n\nenum E {\n    A = 2 * 5, // 数字字面量\n    B = 'bar', // 字符串字面量\n    C = identity(42), // 不透明计算\n}\n\nconsole.log(E.C); //42\n```\n\n## 缩小范围\n\nTypeScript 缩小范围是细化条件块内变量类型的过程。这在使用联合类型时很有用，其中一个变量可以有多个类型。\n\nTypeScript 可识别多种缩小类型范围的方法：\n\n### typeof 类型保护\n\ntypeof 类型保护是 TypeScript 中的一种特定类型保护，它根据变量的内置 JavaScript 类型检查变量的类型。\n\n```typescript\nconst fn = (x: number | string) => {\n    if (typeof x === 'number') {\n        return x + 1; // x 是数字\n    }\n    return -1;\n};\n```\n\n### 真实性缩小\n\nTypeScript 中的真实性缩小是通过检查变量是真还是假来相应地缩小其类型来实现的。\n\n```typescript\nconst toUpperCase = (name: string | null) => {\n    if (name) {\n        return name.toUpperCase();\n    } else {\n        return null;\n    }\n};\n```\n\n### 相等缩小\n\nTypeScript 中的相等缩小通过检查变量是否等于特定值来相应缩小其类型。\n\n它与`switch`语句和等号运算符（例如`===`、`!==`、`==`和`!=`）结合使用来缩小类型范围。\n\n```typescript\nconst checkStatus = (status: 'success' | 'error') => {\n    switch (status) {\n        case 'success':\n            return true\n        case 'error':\n            return null\n    }\n};\n```\n\n### In运算符缩小\n\nTypeScript 中的 `in` 运算符缩小范围是一种根据变量类型中是否存在属性来缩小变量类型的方法。\n\n```typescript\ntype Dog = {\n    name: string;\n    breed: string;\n};\n\ntype Cat = {\n    name: string;\n    likesCream: boolean;\n};\n\nconst getAnimalType = (pet: Dog | Cat) => {\n    if ('breed' in pet) {\n        return 'dog';\n    } else {\n        return 'cat';\n    }\n};\n```\n\n### instanceof 缩小\n\nTypeScript 中的 `instanceof` 运算符缩小是一种根据变量的构造函数缩小变量类型的方法，方法是检查对象是否是某个类或接口的实例。\n\n```typescript\nclass Square {\n    constructor(public width: number) {}\n}\nclass Rectangle {\n    constructor(\n        public width: number,\n        public height: number\n    ) {}\n}\nfunction area(shape: Square | Rectangle) {\n    if (shape instanceof Square) {\n        return shape.width * shape.width;\n    } else {\n        return shape.width * shape.height;\n    }\n}\nconst square = new Square(5);\nconst rectangle = new Rectangle(5, 10);\nconsole.log(area(square)); // 25\nconsole.log(area(rectangle)); // 50\n```\n\n## 赋值\n\n使用赋值缩小 TypeScript 是一种根据分配给变量的值来缩小变量类型的方法。当为变量分配值时，TypeScript 会根据分配的值推断其类型，并缩小变量的类型以匹配推断的类型。\n\n```typescript\nlet value: string | number;\nvalue = 'hello';\nif (typeof value === 'string') {\n    console.log(value.toUpperCase());\n}\nvalue = 42;\nif (typeof value === 'number') {\n    console.log(value.toFixed(2));\n}\n```\n\n## 控制流分析\n\nTypeScript 中的控制流分析是一种静态分析代码流以推断变量类型的方法，允许编译器根据分析结果根据需要缩小这些变量的类型。\n\n在 TypeScript 4.4 之前，代码流分析仅适用于 if 语句中的代码，但从 TypeScript 4.4 开始，它还可以应用于条件表达式和通过 const 变量间接引用的判别式属性访问。\n\n例如：\n\n```typescript\nconst f1 = (x: unknown) => {\n    const isString = typeof x === 'string';\n    if (isString) {\n        x.length;\n    }\n};\n\nconst f2 = (\n    obj: { kind: 'foo'; foo: string } | { kind: 'bar'; bar: number }\n) => {\n    const isFoo = obj.kind === 'foo';\n    if (isFoo) {\n        obj.foo;\n    } else {\n        obj.bar;\n    }\n};\n```\n\n一些未发生缩小的示例：\n\n<!-- skip -->\n```typescript\nconst f1 = (x: unknown) => {\n    let isString = typeof x === 'string';\n    if (isString) {\n        x.length; // 错误, 没有缩小，因为 isString 不是常量\n    }\n};\n\nconst f6 = (\n    obj: { kind: 'foo'; foo: string } | { kind: 'bar'; bar: number }\n) => {\n    const isFoo = obj.kind === 'foo';\n    obj = obj;\n    if (isFoo) {\n        obj.foo; // 错误, 没有缩小，因为 obj 在函数体中被赋值\n    }\n};\n```\n\n注意： 在条件表达式中最多分析五个间接级别。\n\n## 类型谓词\n\nTypeScript 中的类型谓词是返回布尔值的函数，用于将变量的类型缩小为更具体的类型。\n\n```typescript\nconst isString = (value: unknown): value is string => typeof value === 'string';\n\nconst foo = (bar: unknown) => {\n    if (isString(bar)) {\n        console.log(bar.toUpperCase());\n    } else {\n        console.log('not a string');\n    }\n};\n```\n\n## 可区分联合\n\nTypeScript 中的可区分联合是一种联合类型，它使用称为判别式的公共属性来缩小联合的可能类型集。\n\n```typescript\ntype Square = {\n    kind: 'square'; // 判别式\n    size: number;\n};\n\ntype Circle = {\n    kind: 'circle'; // 判别式\n    radius: number;\n};\n\ntype Shape = Square | Circle;\n\nconst area = (shape: Shape) => {\n    switch (shape.kind) {\n        case 'square':\n            return Math.pow(shape.size, 2);\n        case 'circle':\n            return Math.PI * Math.pow(shape.radius, 2);\n    }\n};\n\nconst square: Square = { kind: 'square', size: 5 };\nconst circle: Circle = { kind: 'circle', radius: 2 };\n\nconsole.log(area(square)); // 25\nconsole.log(area(circle)); // 12.566370614359172\n```\n\n## never 类型\n\n当变量缩小为不能包含任何值的类型时，TypeScript 编译器将推断该变量必须属于该never类型。这是因为 never 类型代表永远无法生成的值。\n\n```typescript\nconst printValue = (val: string | number) => {\n    if (typeof val === 'string') {\n        console.log(val.toUpperCase());\n    } else if (typeof val === 'number') {\n        console.log(val.toFixed(2));\n    } else {\n        // val 在这里的类型为 never，因为它只能是字符串或数字\n        const neverVal: never = val;\n        console.log(`Unexpected value: ${neverVal}`);\n    }\n};\n```\n\n## 详尽性检查\n\n详尽性检查是 TypeScript 中的一项功能，可确保在 `switch` 语句或 `if` 语句中处理可区分联合的所有可能情况。\n\n```typescript\ntype Direction = 'up' | 'down';\n\nconst move = (direction: Direction) => {\n    switch (direction) {\n        case 'up':\n            console.log('Moving up');\n            break;\n        case 'down':\n            console.log('Moving down');\n            break;\n        default:\n            const exhaustiveCheck: never = direction;\n            console.log(exhaustiveCheck); // 这行永远不会被执行\n    }\n};\n```\n\n该 `never` 类型用于确保默认情况是详尽的，并且如果将新值添加到 Direction 类型而未在 switch 语句中进行处理，则 TypeScript 将引发错误。\n\n## 对象类型\n\n在 TypeScript 中，对象类型描述对象的形状。它们指定对象属性的名称和类型，以及这些属性是必需的还是可选的。\n\n在 TypeScript 中，您可以通过两种主要方式定义对象类型：\n\n通过指定对象属性的名称、类型和可选性来定义对象的形状的接口。\n\n```typescript\ninterface User {\n    name: string;\n    age: number;\n    email?: string;\n}\n```\n\n类型别名与接口类似，定义了对象的形状。但是，它还可以基于现有类型或现有类型的组合创建新的自定义类型。这包括定义联合类型、交集类型和其他复杂类型。\n\n```typescript\ntype Point = {\n    x: number;\n    y: number;\n};\n```\n\n也可以匿名定义类型：\n\n```typescript\nconst sum = (x: { a: number; b: number }) => x.a + x.b;\nconsole.log(sum({ a: 5, b: 1 }));\n```\n\n## 元组类型（匿名）\n\n元组类型是一种表示具有固定数量的元素及其相应类型的数组的类型。元组类型以固定顺序强制执行特定数量的元素及其各自的类型。当您想要表示具有特定类型的值的集合时，元组类型非常有用，其中数组中每个元素的位置都有特定的含义。\n\n```typescript\ntype Point = [number, number];\n```\n\n## 命名元组类型（已标记）\n\n元组类型可以包含每个元素的可选标签或名称。 这些标签用于提高可读性和工具帮助，不会影响您可以使用它们执行的操作。\n\n```typescript\ntype T = string;\ntype Tuple1 = [T, T];\ntype Tuple2 = [a: T, b: T];\ntype Tuple3 = [a: T, T]; // 命名元组加匿名元组\n```\n\n## 固定长度元组\n\n固定长度元组是一种特定类型的元组，它强制执行特定类型的固定数量的元素，并且一旦定义元组就不允许对其长度进行任何修改。\n\n当您需要表示具有特定数量的元素和特定类型的值的集合，并且您希望确保元组的长度和类型不会无意中更改时，固定长度元组非常有用。\n\n<!-- skip -->\n```typescript\nconst x = [10, 'hello'] as const;\nx.push(2); // 错误\n```\n\n## 联合类型\n\n联合类型是一种表示值的类型，该值可以是多种类型之一。联合类型使用 `|` 表示 每种可能类型之间的符号。\n\n```typescript\nlet x: string | number;\nx = 'hello'; // 有效\nx = 123; // 有效\n```\n\n## 交集类型\n\n交集类型是表示具有两种或多种类型的所有属性的值的类型。交叉类型在每种类型之间使用 & 符号表示。\n\n```typescript\ntype X = {\n    a: string;\n};\n\ntype Y = {\n    b: string;\n};\n\ntype J = X & Y; // 交集\n\nconst j: J = {\n    a: 'a',\n    b: 'b',\n};\n```\n\n## 类型索引\n\n类型索引是指能够通过预先未知的键来定义可以索引的类型，使用索引签名来指定未显式声明的属性的类型。\n\n```typescript\ntype Dictionary<T> = {\n    [key: string]: T;\n};\nconst myDict: Dictionary<string> = { a: 'a', b: 'b' };\nconsole.log(myDict['a']); // 返回 a\n```\n\n## 值的类型\n\nTypeScript 中的\"Type from Value\"是指通过类型推断从值或表达式自动推断出类型。\n\n```typescript\nconst x = 'x'; // TypeScript 可以自动推断变量的类型是 string\n```\n\n## Func 返回值的类型\n\nFunc Return 中的类型是指根据函数的实现自动推断函数的返回类型的能力。这允许 TypeScript 无需显式类型注释即可确定函数返回值的类型。\n\n```typescript\nconst add = (x: number, y: number) => x + y; // TypeScript 可以推断函数的返回类型是数字\n```\n\n## 模块的类型\n\n模块的类型是指使用模块的导出值自动推断其类型的能力。当模块导出特定类型的值时，TypeScript 可以使用该信息在将该值导入到另一个模块时自动推断该值的类型。\n\n<!-- skip -->\n```typescript\nexport const add = (x: number, y: number) => x + y;\n// index.ts\nimport { add } from 'calc';\nconst r = add(1, 2); // r 是 number 类型\n```\n\n## 映射类型\n\nTypeScript 中的映射类型允许您通过使用映射函数转换每个属性来基于现有类型创建新类型。通过映射现有类型，您可以创建以不同格式表示相同信息的新类型。要创建映射类型，您可以使用运算符访问现有类型的属性 `keyof` ，然后更改它们以生成新类型。在以下示例中：\n\n```typescript\ntype MyMappedType<T> = {\n    [P in keyof T]: T[P][];\n};\ntype MyType = {\n    foo: string;\n    bar: number;\n};\ntype MyNewType = MyMappedType<MyType>;\nconst x: MyNewType = {\n    foo: ['hello', 'world'],\n    bar: [1, 2, 3],\n};\n```\n\n我们定义 MyMappedType 来映射 T 的属性，创建一个新类型，其中每个属性都是其原始类型的数组。使用它，我们创建 MyNewType 来表示与 MyType 相同的信息，但每个属性都是一个数组。\n\n## 映射类型修饰符\n\nTypeScript 中的映射类型修饰符支持对现有类型中的属性进行转换：\n\n* `readonly` 或 `+readonly`：这会将映射类型中的属性呈现为只读。\n* `-readonly`：这允许映射类型中的属性是可变的。\n* `?`：这将映射类型中的属性指定为可选。\n\n例子：\n\n```typescript\ntype ReadOnly<T> = { readonly [P in keyof T]: T[P] }; // 所有属性标记为只读\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] }; // 所有标记为可变的属性\n\ntype MyPartial<T> = { [P in keyof T]?: T[P] }; // 所有标记为可选的属性\n````\n\n## 条件类型\n\n条件类型是一种创建依赖于条件的类型的方法，其中要创建的类型是根据条件的结果确定的。它们是使用 `extends` 关键字和三元运算符来定义的，以便有条件地在两种类型之间进行选择。\n\n```typescript\ntype IsArray<T> = T extends any[] ? true : false;\n\nconst myArray = [1, 2, 3];\nconst myNumber = 42;\n\ntype IsMyArrayAnArray = IsArray<typeof myArray>; // true 类型\ntype IsMyNumberAnArray = IsArray<typeof myNumber>; // false 类型\n```\n\n## 分配条件类型\n\n分布式条件类型是一种功能，通过单独对联合的每个成员应用转换，允许类型分布在类型的联合上。当使用映射类型或高阶类型时，这尤其有用。\n\n```typescript\ntype Nullable<T> = T extends any ? T | null : never;\ntype NumberOrBool = number | boolean;\ntype NullableNumberOrBool = Nullable<NumberOrBool>; // number | boolean | null\n```\n\n## infer 条件类型中的类型推断\n\n`infer` 关键字在条件类型中使用，用于从依赖于泛型参数的类型中推断（提取）泛型参数的类型。这允许您编写更灵活且可重用的类型定义。\n\n```typescript\ntype ElementType<T> = T extends (infer U)[] ? U : never;\ntype Numbers = ElementType<number[]>; // number\ntype Strings = ElementType<string[]>; // string\n```\n\n## 预定义条件类型\n\n在 TypeScript 中，预定义的条件类型是语言提供的内置条件类型。它们旨在根据给定类型的特征执行常见的类型转换。\n\n`Exclude<UnionType, ExcludedType>`: 此类型从 Type 中删除可分配给 ExcludedType 的所有类型。\n\n`Extract<Type, Union>`: 此类型从 Union 中提取可分配给 Type 的所有类型。\n\n`NonNullable<Type>`: 此类型从 Type 中删除 null 和 undefined。\n\n`ReturnType<Type>`: 此类型提取函数 Type 的返回类型。\n\n`Parameters<Type>`: 该类型提取函数类型的参数类型。\n\n`Required<Type>`: 此类型使 Type 中的所有属性成为必需。\n\n`Partial<Type>`: 此类型使 Type 中的所有属性都是可选的。\n\n`Readonly<Type>`: 此类型使 Type 中的所有属性变为只读。\n\n## 模板联合类型\n\n模板联合类型可用于合并和操作类型系统内的文本，例如：\n\n```typescript\ntype Status = 'active' | 'inactive';\ntype Products = 'p1' | 'p2';\ntype ProductId = `id-${Products}-${Status}`; // \"id-p1-active\" | \"id-p1-inactive\" | \"id-p2-active\" | \"id-p2-inactive\"\n```\n\n## 任意类型\n\n`any` 类型是一种特殊类型（通用超类型），可用于表示任何类型的值（基元、对象、数组、函数、错误、符号）。它通常用于编译时未知值类型的情况，或者使用来自没有 TypeScript 类型的外部 API 或库的值时。\n\n通过使用任何类型，您向 TypeScript 编译器指示值应该不受任何限制地表示。为了最大限度地提高代码中的类型安全性，请考虑以下事项：\n\n* 将 `any` 的使用限制在类型确实未知的特定情况下。\n* 不要从函数返回 `any` 类型，因为使用该函数会在代码中失去类型安全性，从而削弱类型安全性。\n* 如果您需要使编译器保持沉默，请使用 `@ts-ignore` 而不是 `any`。\n\n```typescript\nlet value: any;\nvalue = true; // 有效\nvalue = 7; // 有效\n```\n\n## 未知类型\n\n在 TypeScript 中，未知类型表示未知类型的值。与允许任何类型值的 `any` 类型不同，`unknown` 需要在以特定方式使用它之前进行类型检查或断言，因此在未首先断言或缩小到更具体的类型的情况下，不允许对 `unknown` 进行任何操作 。\n\n`unknown` 类型只能分配给任何类型和未知类型本身，它是any 的类型安全替代方案。\n\n<!-- skip -->\n```typescript\nlet value: unknown;\n\nlet value1: unknown = value; // 有效\nlet value2: any = value; // 有效\nlet value3: boolean = value; // 无效\nlet value4: number = value; // 无效\n```\n\n```typescript\nconst add = (a: unknown, b: unknown): number | undefined =>\n    typeof a === 'number' && typeof b === 'number' ? a + b : undefined;\nconsole.log(add(1, 2)); // 3\nconsole.log(add('x', 2)); // undefined\n```\n\n## 空类型\n\n`void` 类型用于指示函数不返回值。\n\n```typescript\nconst sayHello = (): void => {\n    console.log('Hello!');\n};\n```\n\n## Never类型\n\n`never` 类型表示从未出现过的值。它用于表示从不返回或抛出错误的函数或表达式。\n\n例如无限循环：\n\n```typescript\nconst infiniteLoop = (): never => {\n    while (true) {\n        // 做点什么\n    }\n};\n```\n\n抛出错误：\n\n```typescript\nconst throwError = (message: string): never => {\n    throw new Error(message);\n};\n```\n\n`never` 类型对于确保类型安全和捕获代码中的潜在错误很有用。当与其他类型和控制流语句结合使用时，它可以帮助 TypeScript 分析和推断更精确的类型，例如：\n\n```typescript\ntype Direction = 'up' | 'down';\nconst move = (direction: Direction): void => {\n    switch (direction) {\n        case 'up':\n            // 向上移动\n            break;\n        case 'down':\n            // 向下移动\n            break;\n        default:\n            const exhaustiveCheck: never = direction;\n            throw new Error(`Unhandled direction: ${exhaustiveCheck}`);\n    }\n};\n```\n\n## 接口及类型\n\n### 通用语法\n\n在 TypeScript 中，接口定义对象的结构，指定对象必须具有的属性或方法的名称和类型。在 TypeScript 中定义接口的常用语法如下：\n\n<!-- skip -->\n```typescript\ninterface InterfaceName {\n    property1: Type1;\n    // ...\n    method1(arg1: ArgType1, arg2: ArgType2): ReturnType;\n    // ...\n}\n```\n\n类型定义也类似：\n\n<!-- skip -->\n```typescript\ntype TypeName = {\n    property1: Type1;\n    // ...\n    method1(arg1: ArgType1, arg2: ArgType2): ReturnType;\n    // ...\n};\n```\n\n`interface InterfaceName` 或者 `type TypeName`: 定义接口的名称。\n`property1`: `Type1`: 指定接口的属性及其相应的类型。可以定义多个属性，每个属性用分号分隔。\n`method1(arg1: ArgType1, arg2: ArgType2): ReturnType;`: 指定接口的方法。方法用其名称进行定义，后跟括号中的参数列表和返回类型。可以定义多个方法，每个方法用分号分隔。\n\n接口示例:\n\n```typescript\ninterface Person {\n    name: string;\n    age: number;\n    greet(): void;\n}\n```\n\n类型示例:\n\n```typescript\ntype TypeName = {\n    property1: string;\n    method1(arg1: string, arg2: string): string;\n};\n```\n\n在 TypeScript 中，类型用于定义数据的形状并强制执行类型检查。在 TypeScript 中定义类型有几种常见的语法，具体取决于具体的用例。这里有些例子：\n\n### 基本类型\n\n```typescript\nlet myNumber: number = 123; // 数字类型\nlet myBoolean: boolean = true; // 布尔类型\nlet myArray: string[] = ['a', 'b']; // 字符串数组\nlet myTuple: [string, number] = ['a', 123]; // 元组\n```\n\n### 对象和接口\n\n```typescript\nconst x: { name: string; age: number } = { name: 'Simon', age: 7 };\n```\n\n### 并集和交集类型\n\n```typescript\ntype MyType = string | number; // 并集\nlet myUnion: MyType = 'hello'; // 可以是字符串\nmyUnion = 123; // 或者是一个数字\n\ntype TypeA = { name: string };\ntype TypeB = { age: number };\ntype CombinedType = TypeA & TypeB; // 交集\nlet myCombined: CombinedType = { name: 'John', age: 25 }; // 对象同时有name和age属性\n```\n\n## 内置原始数据类型\n\nTypeScript 有几个内置的原属数据类型，可用于定义变量、函数参数和返回类型：\n\n`number`: 表示数值，包括整数和浮点数。\n`string`: 代表文本数据。\n`boolean`: 代表逻辑值，可以是 true 或 false。\n`null`:  表示没有值。\n`undefined`: 表示尚未赋值或未定义的值。\n`symbol`: 代表唯一标识符。符号通常用作对象属性的键。\n`bigint`: 表示任意精度整数。\n`any`: 代表动态或未知类型。any 类型的变量可以保存任何类型的值，并且它们绕过类型检查。\n`void`: 表示不存在任何类型。它通常用作不返回值的函数的返回类型。\n`never`: 表示从未出现过的值的类型。它通常用作引发错误或进入无限循环的函数的返回类型。\n\n## 常见的内置JS对象\n\nTypeScript 是 JavaScript 的超集，它包含所有常用的内置 JavaScript 对象。您可以在 Mozilla 开发者网络 (MDN) 文档网站上找到这些对象的详细列表：\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects)\n\n以下是一些常用的内置 JavaScript 对象的列表：\n\n* Function\n* Object\n* Boolean\n* Error\n* Number\n* BigInt\n* Math\n* Date\n* String\n* RegExp\n* Array\n* Map\n* Set\n* Promise\n* Intl\n\n## 重载\n\nTypeScript 中的函数重载允许您为单个函数名称定义多个函数签名，从而使您能够定义可以多种方式调用的函数。这是一个例子：\n\n```typescript\n// 重载\nfunction sayHi(name: string): string;\nfunction sayHi(names: string[]): string[];\n\n// 实现\nfunction sayHi(name: unknown): unknown {\n    if (typeof name === 'string') {\n        return `Hi, ${name}!`;\n    } else if (Array.isArray(name)) {\n        return name.map(name => `Hi, ${name}!`);\n    }\n    throw new Error('Invalid value');\n}\n\nsayHi('xx'); // 有效\nsayHi(['aa', 'bb']); // 有效\n```\n\n这是在 `class` 中使用函数重载的另一个示例：\n\n```typescript\nclass Greeter {\n    message: string;\n\n    constructor(message: string) {\n        this.message = message;\n    }\n\n    // 重载\n    sayHi(name: string): string;\n    sayHi(names: string[]): ReadonlyArray<string>;\n\n    // 实现\n    sayHi(name: unknown): unknown {\n        if (typeof name === 'string') {\n            return `${this.message}, ${name}!`;\n        } else if (Array.isArray(name)) {\n            return name.map(name => `${this.message}, ${name}!`);\n        }\n        throw new Error('value is invalid');\n    }\n}\nconsole.log(new Greeter('Hello').sayHi('Simon'));\n```\n\n## 合并与扩展\n\n合并和扩展是指与使用类型和接口相关的两个不同概念。\n\n合并允许您将多个同名声明合并到一个定义中，例如，当您多次定义同名接口时：\n\n```typescript\ninterface X {\n    a: string;\n}\n\ninterface X {\n    b: number;\n}\n\nconst person: X = {\n    a: 'a',\n    b: 7,\n};\n```\n\n扩展是指扩展或继承现有类型或接口以创建新类型或接口的能力。它是一种向现有类型添加附加属性或方法而不修改其原始定义的机制。例子：\n\n```typescript\ninterface Animal {\n    name: string;\n    eat(): void;\n}\n\ninterface Bird extends Animal {\n    sing(): void;\n}\n\nconst dog: Bird = {\n    name: 'Bird 1',\n    eat() {\n        console.log('Eating');\n    },\n    sing() {\n        console.log('Singing');\n    },\n};\n```\n\n## 类型和接口之间的差异\n\n声明合并（增强）：\n\n接口支持声明合并，这意味着您可以定义多个具有相同名称的接口，TypeScript 会将它们合并为具有组合属性和方法的单个接口。 另一方面，类型不支持声明合并。 当您想要添加额外的功能或自定义现有类型而不修改原始定义或修补丢失或不正确的类型时，这可能会很有帮助。\n\n```typescript\ninterface A {\n    x: string;\n}\ninterface A {\n    y: string;\n}\nconst j: A = {\n    x: 'xx',\n    y: 'yy',\n};\n```\n\n扩展其他类型/接口：\n\n类型和接口都可以扩展其他类型/接口，但语法不同。 对于接口，您可以使用“extends”关键字从其他接口继承属性和方法。 但是，接口无法扩展像联合类型这样的复杂类型。\n\n```typescript\ninterface A {\n    x: string;\n    y: number;\n}\ninterface B extends A {\n    z: string;\n}\nconst car: B = {\n    x: 'x',\n    y: 123,\n    z: 'z',\n};\n```\n\n对于类型，您可以使用 & 运算符将多个类型合并为单个类型（交集）。\n\n```typescript\ninterface A {\n    x: string;\n    y: number;\n}\n\ntype B = A & {\n    j: string;\n};\n\nconst c: B = {\n    x: 'x',\n    y: 123,\n    j: 'j',\n};\n```\n\n并集和交集类型：\n\n在定义并集和交集类型时，类型更加灵活。 通过“type”关键字，您可以使用“|”运算符轻松创建联合类型，并使用“&”运算符创建交集类型。 虽然接口也可以间接表示联合类型，但它们没有对交集类型的内置支持。\n\n```typescript\ntype Department = 'dep-x' | 'dep-y'; // 并集\n\ntype Person = {\n    name: string;\n    age: number;\n};\n\ntype Employee = {\n    id: number;\n    department: Department;\n};\n\ntype EmployeeInfo = Person & Employee; // 交集\n```\n\n接口示例：\n\n```typescript\ninterface A {\n    x: 'x';\n}\ninterface B {\n    y: 'y';\n}\n\ntype C = A | B; // 接口的并集\n```\n\n## Class\n\n### 通用语法\n\nTypeScript 中使用关键字 `class` 来定义类。下面，您可以看到一个示例：\n\n```typescript\nclass Person {\n    private name: string;\n    private age: number;\n    constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n    }\n    public sayHi(): void {\n        console.log(\n            `Hello, my name is ${this.name} and I am ${this.age} years old.`\n        );\n    }\n}\n```\n\n`class` 关键字用于定义名为 `Person` 的类。\n\n该类有两个私有属性：类型名称 `string` 和类型年龄 `number`。\n\n构造函数是使用 `constructor` 关键字定义的。它将姓名和年龄作为参数并将它们分配给相应的属性。\n\n该类有一个 `public` 名为 `sayHi` 的方法，用于记录问候消息。\n\n要在 TypeScript 中创建类的实例，可以使用 `new` 关键字，后跟类名，然后使用括号 `()`。例如：\n\n<!-- skip -->\n```typescript\nconst myObject = new Person('John Doe', 25);\nmyObject.sayHi(); // 输出：Hello, my name is John Doe and I am 25 years old.\n```\n\n### 构造函数\n\n构造函数是类中的特殊方法，用于在创建类的实例时初始化对象的属性。\n\n```typescript\nclass Person {\n    public name: string;\n    public age: number;\n\n    constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n    }\n\n    sayHello() {\n        console.log(\n            `Hello, my name is ${this.name} and I'm ${this.age} years old.`\n        );\n    }\n}\n\nconst john = new Person('Simon', 17);\njohn.sayHello();\n```\n\n可以使用以下语法重载构造函数：\n\n```typescript\ntype Sex = 'm' | 'f';\n\nclass Person {\n    name: string;\n    age: number;\n    sex: Sex;\n\n    constructor(name: string, age: number, sex?: Sex);\n    constructor(name: string, age: number, sex: Sex) {\n        this.name = name;\n        this.age = age;\n        this.sex = sex ?? 'm';\n    }\n}\n\nconst p1 = new Person('Simon', 17);\nconst p2 = new Person('Alice', 22, 'f');\n```\n\n在 TypeScript 中，可以定义多个构造函数重载，但只能有一个必须与所有重载兼容的实现，这可以通过使用可选参数来实现。\n\n```typescript\nclass Person {\n    name: string;\n    age: number;\n\n    constructor();\n    constructor(name: string);\n    constructor(name: string, age: number);\n    constructor(name?: string, age?: number) {\n        this.name = name ?? 'Unknown';\n        this.age = age ?? 0;\n    }\n\n    displayInfo() {\n        console.log(`Name: ${this.name}, Age: ${this.age}`);\n    }\n}\n\nconst person1 = new Person();\nperson1.displayInfo(); // Name: Unknown, Age: 0\n\nconst person2 = new Person('John');\nperson2.displayInfo(); // Name: John, Age: 0\n\nconst person3 = new Person('Jane', 25);\nperson3.displayInfo(); // Name: Jane, Age: 25\n```\n\n### 私有和受保护的构造函数\n\n在 TypeScript 中，构造函数可以标记为私有或受保护，这限制了它们的可访问性和使用。\n\n私有构造函数：只能在类本身内调用。私有构造函数通常用于以下场景：您想要强制执行单例模式或将实例的创建限制为类中的工厂方法\n\n受保护的构造函数：当您想要创建一个不应直接实例化但可以由子类扩展的基类时，受保护的构造函数非常有用。\n\n```typescript\nclass BaseClass {\n    protected constructor() {}\n}\n\nclass DerivedClass extends BaseClass {\n    private value: number;\n\n    constructor(value: number) {\n        super();\n        this.value = value;\n    }\n}\n\n// 尝试直接实例化基类将导致错误\n// const baseObj = new BaseClass(); // 错误：类\"BaseClass\"的构造函数受到保护。\n\n// 创建派生类的实例\nconst derivedObj = new DerivedClass(10);\n```\n\n### 访问修饰符\n\n访问修饰符 `private` 、`protected` 和 `public` 用于控制 TypeScript 类中类成员（例如属性和方法）的可见性和可访问性。这些修饰符对于强制封装以及建立访问和修改类内部状态的边界至关重要。\n\n修饰符 `private` 仅限制对包含类中的类成员的访问。\n\n修饰符 `protected` 允许访问包含类及其派生类中的类成员。\n\n修饰符 `public` 提供对类成员的不受限制的访问，允许从任何地方访问它。\n\n### Get 与 Set\n\nGetter 和 Setter 是特殊方法，允许您定义类属性的自定义访问和修改行为。它们使您能够封装对象的内部状态，并在获取或设置属性值时提供附加逻辑。在 TypeScript 中，getter 和 setter 分别使用 `get` 和 `set` 关键字定义。这是一个例子：\n\n```typescript\nclass MyClass {\n    private _myProperty: string;\n\n    constructor(value: string) {\n        this._myProperty = value;\n    }\n    get myProperty(): string {\n        return this._myProperty;\n    }\n    set myProperty(value: string) {\n        this._myProperty = value;\n    }\n}\n```\n\n### 类中的自动访问器\n\nTypeScript 版本 4.9 添加了对自动访问器的支持，这是即将推出的 ECMAScript 功能。它们类似于类属性，但使用\"accessor\"关键字声明。\n\n```typescript\nclass Animal {\n    accessor name: string;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n```\n\n自动访问器被\"脱糖\"为私有get访问set器，在无法访问的属性上运行。\n\n<!-- skip -->\n```typescript\nclass Animal {\n    #__name: string;\n\n    get name() {\n        return this.#__name;\n    }\n    set name(value: string) {\n        this.#__name = name;\n    }\n\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n```\n\n### this\n\n在 TypeScript 中，`this` 关键字指的是类的方法或构造函数中的当前实例。它允许您在类自己的范围内访问和修改类的属性和方法。它提供了一种在对象自己的方法中访问和操作对象内部状态的方法。\n\n```typescript\nclass Person {\n    private name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    public introduce(): void {\n        console.log(`Hello, my name is ${this.name}.`);\n    }\n}\n\nconst person1 = new Person('Alice');\nperson1.introduce(); // Hello, my name is Alice.\n```\n\n### 参数属性\n\n参数属性允许您直接在构造函数参数中声明和初始化类属性，从而避免样板代码，例如：\n\n```typescript\nclass Person {\n    constructor(\n        private name: string,\n        public age: number\n    ) {\n        // 构造函数中的\"private\"和\"public\"关键字自动声明并初始化相应的类属性。\n    }\n    public introduce(): void {\n        console.log(\n            `Hello, my name is ${this.name} and I am ${this.age} years old.`\n        );\n    }\n}\nconst person = new Person('Alice', 25);\nperson.introduce();\n```\n\n### 抽象类\n\n抽象类在 TypeScript 中主要用于继承，它们提供了一种定义可由子类继承的公共属性和方法的方法。当您想要定义常见行为并强制子类实现某些方法时，这非常有用。它们提供了一种创建类层次结构的方法，其中抽象基类为子类提供共享接口和通用功能。\n\n```typescript\nabstract class Animal {\n    protected name: string;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    abstract makeSound(): void;\n}\n\nclass Cat extends Animal {\n    makeSound(): void {\n        console.log(`${this.name} meows.`);\n    }\n}\n\nconst cat = new Cat('Whiskers');\ncat.makeSound(); // 输出：Whiskers meows.\n```\n\n### 使用泛型\n\n具有泛型的类允许您定义可以与不同类型一起使用的可重用类。\n\n```typescript\nclass Container<T> {\n    private item: T;\n\n    constructor(item: T) {\n        this.item = item;\n    }\n\n    getItem(): T {\n        return this.item;\n    }\n\n    setItem(item: T): void {\n        this.item = item;\n    }\n}\n\nconst container1 = new Container<number>(42);\nconsole.log(container1.getItem()); //  42\n\nconst container2 = new Container<string>('Hello');\ncontainer2.setItem('World');\nconsole.log(container2.getItem()); // World\n```\n\n### 装饰器\n\n装饰器提供了一种添加元数据、修改行为、验证或扩展目标元素功能的机制。它们是在运行时执行的函数。多个装饰器可以应用于一个声明。\n\n装饰器是实验性功能，以下示例仅与使用 ES6 的 TypeScript 版本 5 或更高版本兼容。\n\n对于 5 之前的 TypeScript 版本，应在您的 `tsconfig.json` 中使用使`experimentalDecorators` 或在命令行中使用 `--experimentalDecorators` 来启用它们（但以下示例不起作用）。\n\n装饰器的一些常见用例包括：\n\n* 观察属性变化。\n* 观察方法调用。\n* 添加额外的属性或方法。\n* 运行时验证。\n* 自动序列化和反序列化。\n* 日志记录。\n* 授权和认证。\n* 错误防护。\n\n注意：版本 5 的装饰器不允许装饰参数。\n\n装饰器的类型：\n\n#### 类装饰器\n\n类装饰器对于扩展现有类非常有用，例如添加属性或方法，或者收集类的实例。在下面的示例中，我们添加一个 `toString` 将类转换为字符串表示形式的方法。\n\n```typescript\ntype Constructor<T = {}> = new (...args: any[]) => T;\n\nfunction toString<Class extends Constructor>(\n    Value: Class,\n    context: ClassDecoratorContext<Class>\n) {\n    return class extends Value {\n        constructor(...args: any[]) {\n            super(...args);\n            console.log(JSON.stringify(this));\n            console.log(JSON.stringify(context));\n        }\n    };\n}\n\n@toString\nclass Person {\n    name: string;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    greet() {\n        return 'Hello, ' + this.name;\n    }\n}\nconst person = new Person('Simon');\n/* Logs:\n{\"name\":\"Simon\"}\n{\"kind\":\"class\",\"name\":\"Person\"}\n*/\n```\n\n#### 属性装饰器\n\n属性装饰器对于修改属性的行为非常有用，例如更改初始化值。在下面的代码中，我们有一个脚本将属性设置为始终大写：\n\n```typescript\nfunction upperCase<T>(\n    target: undefined,\n    context: ClassFieldDecoratorContext<T, string>\n) {\n    return function (this: T, value: string) {\n        return value.toUpperCase();\n    };\n}\n\nclass MyClass {\n    @upperCase\n    prop1 = 'hello!';\n}\n\nconsole.log(new MyClass().prop1); // 日志：HELLO!\n```\n\n#### 方法装饰器\n\n方法装饰器允许您更改或增强方法的行为。下面是一个简单记录器的示例：\n\n```typescript\nfunction log<This, Args extends any[], Return>(\n    target: (this: This, ...args: Args) => Return,\n    context: ClassMethodDecoratorContext<\n        This,\n        (this: This, ...args: Args) => Return\n    >\n) {\n    const methodName = String(context.name);\n\n    function replacementMethod(this: This, ...args: Args): Return {\n        console.log(`LOG: Entering method '${methodName}'.`);\n        const result = target.call(this, ...args);\n        console.log(`LOG: Exiting method '${methodName}'.`);\n        return result;\n    }\n\n    return replacementMethod;\n}\n\nclass MyClass {\n    @log\n    sayHello() {\n        console.log('Hello!');\n    }\n}\n\nnew MyClass().sayHello();\n```\n\n它记录：\n\n```shell\nLOG: Entering method 'sayHello'.\nHello!\nLOG: Exiting method 'sayHello'.\n```\n\n#### Getter 和 Setter 装饰器\n\ngetter 和 setter 装饰器允许您更改或增强类访问器的行为。例如，它们对于验证属性分配很有用。这是 getter 装饰器的一个简单示例：\n\n```typescript\nfunction range<This, Return extends number>(min: number, max: number) {\n    return function (\n        target: (this: This) => Return,\n        context: ClassGetterDecoratorContext<This, Return>\n    ) {\n        return function (this: This): Return {\n            const value = target.call(this);\n            if (value < min || value > max) {\n                throw 'Invalid';\n            }\n            Object.defineProperty(this, context.name, {\n                value,\n                enumerable: true,\n            });\n            return value;\n        };\n    };\n}\n\nclass MyClass {\n    private _value = 0;\n\n    constructor(value: number) {\n        this._value = value;\n    }\n    @range(1, 100)\n    get getValue(): number {\n        return this._value;\n    }\n}\n\nconst obj = new MyClass(10);\nconsole.log(obj.getValue); // 有效: 10\n\nconst obj2 = new MyClass(999);\nconsole.log(obj2.getValue); // 抛出异常: Invalid!\n```\n\n### 装饰器元数据\n\n装饰器元数据简化了装饰器在任何类中应用和利用元数据的过程。 他们可以访问上下文对象上的新元数据属性，该属性可以充当基元和对象的密钥。\n可以通过\"Symbol.metadata\"在类上访问元数据信息。\n\n元数据可用于各种目的，例如调试、序列化或使用装饰器的依赖项注入。\n\n```typescript\n//@ts-ignore\nSymbol.metadata ??= Symbol('Symbol.metadata'); // 简单的兼容性填充\n\ntype Context =\n    | ClassFieldDecoratorContext\n    | ClassAccessorDecoratorContext\n    | ClassMethodDecoratorContext; // 上下文对象包含属性元数据: 装饰器元数据\n\nfunction setMetadata(_target: any, context: Context) {\n    // 使用基本类型值设置元数据对象\n    context.metadata[context.name] = true;\n}\n\nclass MyClass {\n    @setMetadata\n    a = 123;\n\n    @setMetadata\n    accessor b = 'b';\n\n    @setMetadata\n    fn() {}\n}\n\nconst metadata = MyClass[Symbol.metadata]; // 获取元数据对象信息\n\nconsole.log(JSON.stringify(metadata)); // {\"bar\":true,\"baz\":true,\"foo\":true}\n```\n\n### 继承\n\n继承是指一个类可以从另一个类（称为基类或超类）继承属性和方法的机制。派生类也称为子类或子类，可以通过添加新的属性和方法或重写现有的属性和方法来扩展和专门化基类的功能。\n\n```typescript\nclass Animal {\n    name: string;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    speak(): void {\n        console.log('The animal makes a sound');\n    }\n}\n\nclass Dog extends Animal {\n    breed: string;\n\n    constructor(name: string, breed: string) {\n        super(name);\n        this.breed = breed;\n    }\n\n    speak(): void {\n        console.log('Woof! Woof!');\n    }\n}\n\n// 创建基类的一个实例\nconst animal = new Animal('Generic Animal');\nanimal.speak(); // The animal makes a sound\n\n// 创建派生类的一个实例\nconst dog = new Dog('Max', 'Labrador');\ndog.speak(); // Woof! Woof!\"\n```\n\nTypeScript 不支持传统意义上的多重继承，而是允许从单个基类继承。TypeScript 支持多种接口。接口可以定义对象结构的契约，类可以实现多个接口。这允许类从多个源继承行为和结构。\n\n```typescript\ninterface Flyable {\n    fly(): void;\n}\n\ninterface Swimmable {\n    swim(): void;\n}\n\nclass FlyingFish implements Flyable, Swimmable {\n    fly() {\n        console.log('Flying...');\n    }\n\n    swim() {\n        console.log('Swimming...');\n    }\n}\n\nconst flyingFish = new FlyingFish();\nflyingFish.fly();\nflyingFish.swim();\n```\n\nTypeScript 中的关键字 `class` 与 JavaScript 类似，通常被称为语法糖。它是在 ECMAScript 2015 (ES6) 中引入的，旨在提供更熟悉的语法，以基于类的方式创建和使用对象。然而，值得注意的是，TypeScript 作为 JavaScript 的超集，最终会编译为 JavaScript，而 JavaScript 的核心仍然是基于原型的。\n\n### 静态成员\n\nTypeScript 有静态成员。要访问类的静态成员，可以使用类名后跟一个点，而不需要创建对象。\n\n```typescript\nclass OfficeWorker {\n    static memberCount: number = 0;\n\n    constructor(private name: string) {\n        OfficeWorker.memberCount++;\n    }\n}\n\nconst w1 = new OfficeWorker('James');\nconst w2 = new OfficeWorker('Simon');\nconst total = OfficeWorker.memberCount;\nconsole.log(total); // 2\n```\n\n### 属性初始化\n\n在 TypeScript 中初始化类的属性有多种方法：\n\n内嵌：\n\n在下面的示例中，创建类的实例时将使用这些初始值。\n\n```typescript\nclass MyClass {\n    property1: string = 'default value';\n    property2: number = 42;\n}\n```\n\n在构造函数中：\n\n```typescript\nclass MyClass {\n    property1: string;\n    property2: number;\n\n    constructor() {\n        this.property1 = 'default value';\n        this.property2 = 42;\n    }\n}\n```\n\n使用构造函数参数：\n\n```typescript\nclass MyClass {\n    constructor(\n        private property1: string = 'default value',\n        public property2: number = 42\n    ) {\n        // 无需显式地将值分配给属性。\n    }\n    log() {\n        console.log(this.property2);\n    }\n}\nconst x = new MyClass();\nx.log();\n```\n\n### 方法重载\n\n方法重载允许一个类有多个名称相同但参数类型不同或参数数量不同的方法。这允许我们根据传递的参数以不同的方式调用方法。\n\n```typescript\nclass MyClass {\n    add(a: number, b: number): number; // 重载签名 1\n    add(a: string, b: string): string; // 重载签名 2\n\n    add(a: number | string, b: number | string): number | string {\n        if (typeof a === 'number' && typeof b === 'number') {\n            return a + b;\n        }\n        if (typeof a === 'string' && typeof b === 'string') {\n            return a.concat(b);\n        }\n        throw new Error('Invalid arguments');\n    }\n}\n\nconst r = new MyClass();\nconsole.log(r.add(10, 5)); // 日志：15\n```\n\n## 泛型\n\n泛型允许您创建可与多种类型一起使用的可重用组件和函数。使用泛型，您可以参数化类型、函数和接口，从而允许它们对不同类型进行操作，而无需事先显式指定它们。\n\n泛型允许您使代码更加灵活和可重用。\n\n### 泛型类型\n\n要定义泛型类型，可以使用尖括号 (`<>`) 来指定类型参数，例如：\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\nconst a = identity('x');\nconst b = identity(123);\n\nconst getLen = <T,>(data: ReadonlyArray<T>) => data.length;\nconst len = getLen([1, 2, 3]);\n```\n\n### 泛型类\n\n泛型也可以应用于类，这样它们就可以通过使用类型参数来处理多种类型。这对于创建可重用的类定义非常有用，这些定义可以在保持类型安全的同时对不同的数据类型进行操作。\n\n```typescript\nclass Container<T> {\n    private item: T;\n\n    constructor(item: T) {\n        this.item = item;\n    }\n\n    getItem(): T {\n        return this.item;\n    }\n}\n\nconst numberContainer = new Container<number>(123);\nconsole.log(numberContainer.getItem()); // 123\n\nconst stringContainer = new Container<string>('hello');\nconsole.log(stringContainer.getItem()); // hello\n```\n\n### 泛型约束\n\n可以使用关键字 `extends` 后跟类型参数必须满足的类型或接口来约束泛型参数。\n\n在下面的示例中，T 必须正确包含 `length` 才能有效：\n\n<!-- skip -->\n```typescript\nconst printLen = <T extends { length: number }>(value: T): void => {\n    console.log(value.length);\n};\n\nprintLen('Hello'); // 5\nprintLen([1, 2, 3]); // 3\nprintLen({ length: 10 }); // 10\nprintLen(123); // 无效\n```\n\n3.4 RC 版中引入的泛型的一个有趣功能是高阶函数类型推断，它引入了传播泛型类型参数：\n\n```typescript\ndeclare function pipe<A extends any[], B, C>(\n    ab: (...args: A) => B,\n    bc: (b: B) => C\n): (...args: A) => C;\n\ndeclare function list<T>(a: T): T[];\ndeclare function box<V>(x: V): { value: V };\n\nconst listBox = pipe(list, box); // <T>(a: T) => { value: T[] }\nconst boxList = pipe(box, list); // <V>(x: V) => { value: V }[]\n```\n\n此功能允许更轻松地键入安全的无点风格编程，这在函数式编程中很常见。\n\n### 泛型上下文缩小\n\n泛型上下文缩小是 TypeScript 中的机制，允许编译器根据使用泛型参数的上下文来缩小泛型参数的类型，在条件语句中使用泛型类型时非常有用：\n\n```typescript\nfunction process<T>(value: T): void {\n    if (typeof value === 'string') {\n        // Value 的类型被缩小到 'string' 类型\n        console.log(value.length);\n    } else if (typeof value === 'number') {\n        // Value 的类型被缩小到 'number' 类型\n        console.log(value.toFixed(2));\n    }\n}\n\nprocess('hello'); // 5\nprocess(3.14159); // 3.14\n```\n\n## 擦除的结构类型\n\n在 TypeScript 中，对象不必匹配特定的、精确的类型。例如，如果我们创建一个满足接口要求的对象，我们就可以在需要该接口的地方使用该对象，即使它们之间没有显式连接。例子：\n\n```typescript\ntype NameProp1 = {\n    prop1: string;\n};\n\nfunction log(x: NameProp1) {\n    console.log(x.prop1);\n}\n\nconst obj = {\n    prop2: 123,\n    prop1: 'Origin',\n};\n\nlog(obj); // 有效\n```\n\n## 命名空间\n\n在 TypeScript 中，命名空间用于将代码组织到逻辑容器中，防止命名冲突并提供一种将相关代码分组在一起的方法。使用关键字 `export` 允许在\"外部\"模块中访问名称空间。\n\n```typescript\nexport namespace MyNamespace {\n    export interface MyInterface1 {\n        prop1: boolean;\n    }\n    export interface MyInterface2 {\n        prop2: string;\n    }\n}\n\nconst a: MyNamespace.MyInterface1 = {\n    prop1: true,\n};\n```\n\n## Symbols\n\n符号是一种原始数据类型，表示不可变值，保证在程序的整个生命周期中全局唯一。\n\n符号可以用作对象属性的键，并提供一种创建不可枚举属性的方法。\n\n```typescript\nconst key1: symbol = Symbol('key1');\nconst key2: symbol = Symbol('key2');\n\nconst obj = {\n    [key1]: 'value 1',\n    [key2]: 'value 2',\n};\n\nconsole.log(obj[key1]); // value 1\nconsole.log(obj[key2]); // value 2\n```\n\n在 WeakMap 和 WeakSet 中，现在允许符号作为键。\n\n## 三斜杠指令\n\n三斜杠指令是特殊注释，为编译器提供有关如何处理文件的说明。这些指令以三个连续斜杠 (`///`) 开头，通常放置在 TypeScript 文件的顶部，对运行时行为没有影响。\n\n三斜杠指令用于引用外部依赖项、指定模块加载行为、启用/禁用某些编译器功能等等。几个例子：\n\n引用声明文件：\n\n<!-- skip -->\n```typescript\n/// <reference path=\"path/to/declaration/file.d.ts\" />\n```\n\n指明模块格式：\n\n<!-- skip -->\n```typescript\n/// <amd|commonjs|system|umd|es6|es2015|none>\n```\n\n启用编译器选项，在以下示例中严格模式：\n\n<!-- skip -->\n```typescript\n/// <strict|noImplicitAny|noUnusedLocals|noUnusedParameters>\n```\n\n## 类型操作\n\n### 从类型创建类型\n\n是否可以通过组合、操作或转换现有类型来创建新类型。\n\n交集类型 ( &):\n\n允许您将多种类型组合成单一类型：\n\n```typescript\ntype A = { foo: number };\ntype B = { bar: string };\ntype C = A & B; // A和B的交集\nconst obj: C = { foo: 42, bar: 'hello' };\n```\n\n联合类型 (`|`):\n\n允许您定义可以是以下几种类型之一的类型\n\n```typescript\ntype Result = string | number;\nconst value1: Result = 'hello';\nconst value2: Result = 42;\n```\n\n映射类型：\n\n允许您转换现有类型的属性以创建新类型：\n\n```typescript\ntype Mutable<T> = {\n    readonly [P in keyof T]: T[P];\n};\ntype Person = {\n    name: string;\n    age: number;\n};\ntype ImmutablePerson = Mutable<Person>; // 属性变为只读\n```\n\n条件类型：\n\n允许您根据某些条件创建类型：\n\n```typescript\ntype ExtractParam<T> = T extends (param: infer P) => any ? P : never;\ntype MyFunction = (name: string) => number;\ntype ParamType = ExtractParam<MyFunction>; // string\n```\n\n### 索引访问类型\n\n在 TypeScript 中，可以使用索引访问和操作另一个类型中的属性类型 `Type[Key]`。\n\n```typescript\ntype Person = {\n    name: string;\n    age: number;\n};\n\ntype AgeType = Person['age']; // number\n```\n\n```typescript\ntype MyTuple = [string, number, boolean];\ntype MyType = MyTuple[2]; // boolean\n```\n\n### 工具类型\n\n可以使用几种内置工具来操作类型，下面列出了最常用的：\n\n#### Awaited\\<T\\>\n\n构造一个递归解包 Promise 的类型。\n\n```typescript\ntype A = Awaited<Promise<string>>; // string\n```\n\n#### Partial\\<T\\>\n\n构造一个类型，并将 T 的所有属性设置为可选。\n\n```typescript\ntype Person = {\n    name: string;\n    age: number;\n};\n\ntype A = Partial<Person>; // { name?: string | undefined; age?: number | undefined; }\n```\n\n#### Required\\<T\\>\n\n构造一个类型，并将 T 的所有属性设置为必需。\n\n```typescript\ntype Person = {\n    name?: string;\n    age?: number;\n};\n\ntype A = Required<Person>; // { name: string; age: number; }\n```\n\n#### Readonly\\<T\\>\n\n构造一个类型，并将 T 的所有属性设置为只读。\n\n<!-- skip -->\n```typescript\ntype Person = {\n    name: string;\n    age: number;\n};\n\ntype A = Readonly<Person>;\n\nconst a: A = { name: 'Simon', age: 17 };\na.name = 'John'; // 无效\n```\n\n#### Record\\<K, T\\>\n\n构造一个具有类型 T 的一组属性 K 的类型。\n\n```typescript\ntype Product = {\n    name: string;\n    price: number;\n};\n\nconst products: Record<string, Product> = {\n    apple: { name: 'Apple', price: 0.5 },\n    banana: { name: 'Banana', price: 0.25 },\n};\n\nconsole.log(products.apple); // { name: 'Apple', price: 0.5 }\n```\n\n#### Pick\\<T, K\\>\n\n通过从 T 中选取指定属性 K 来构造类型。\n\n```typescript\ntype Product = {\n    name: string;\n    price: number;\n};\n\ntype Price = Pick<Product, 'price'>; // { price: number; }\n```\n\n#### Omit\\<T, K\\>\n\n通过从 T 中省略指定属性 K 来构造类型。\n\n```typescript\ntype Product = {\n    name: string;\n    price: number;\n};\n\ntype Name = Omit<Product, 'price'>; // { name: string; }\n```\n\n#### Exclude\\<T, U\\>\n\n通过从 T 中排除类型 U 的所有值来构造类型。\n\n```typescript\ntype Union = 'a' | 'b' | 'c';\ntype MyType = Exclude<Union, 'a' | 'c'>; // b\n```\n\n#### Extract\\<T, U\\>\n\n通过从 T 中提取类型 U 的所有值来构造类型。\n\n```typescript\ntype Union = 'a' | 'b' | 'c';\ntype MyType = Extract<Union, 'a' | 'c'>; // a | c\n```\n\n#### NonNullable\\<T\\>\n\n通过从 T 中排除 null 和 undefined 来构造类型。\n\n```typescript\ntype Union = 'a' | null | undefined | 'b';\ntype MyType = NonNullable<Union>; // 'a' | 'b'\n```\n\n#### Parameters\\<T\\>\n\n提取函数类型 T 的参数类型。\n\n```typescript\ntype Func = (a: string, b: number) => void;\ntype MyType = Parameters<Func>; // [a: string, b: number]\n```\n\n#### ConstructorParameters\\<T\\>\n\n提取构造函数类型 T 的参数类型。\n\n```typescript\nclass Person {\n    constructor(\n        public name: string,\n        public age: number\n    ) {}\n}\ntype PersonConstructorParams = ConstructorParameters<typeof Person>; // [name: string, age: number]\nconst params: PersonConstructorParams = ['John', 30];\nconst person = new Person(...params);\nconsole.log(person); // Person { name: 'John', age: 30 }\n```\n\n#### ReturnType\\<T\\>\n\n提取函数类型 T 的返回类型。\n\n```typescript\ntype Func = (name: string) => number;\ntype MyType = ReturnType<Func>; // number\n```\n\n#### InstanceType\\<T\\>\n\n提取类类型 T 的实例类型。\n\n```typescript\nclass Person {\n    name: string;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    sayHello() {\n        console.log(`Hello, my name is ${this.name}!`);\n    }\n}\n\ntype PersonInstance = InstanceType<typeof Person>;\n\nconst person: PersonInstance = new Person('John');\n\nperson.sayHello(); // Hello, my name is John!\n```\n\n#### ThisParameterType\\<T\\>\n\n从函数类型 T 中提取\"this\"参数的类型。\n\n```typescript\ninterface Person {\n    name: string;\n    greet(this: Person): void;\n}\ntype PersonThisType = ThisParameterType<Person['greet']>; // Person\n```\n\n#### OmitThisParameter\\<T\\>\n\n从函数类型 T 中删除\"this\"参数。\n\n```typescript\nfunction capitalize(this: String) {\n    return this[0].toUpperCase + this.substring(1).toLowerCase();\n}\n\ntype CapitalizeType = OmitThisParameter<typeof capitalize>; // () => string\n```\n\n#### ThisType\\<T\\>\n\n作为上下文类型 `this` 的一部分。\n\n<!-- skip -->\n```typescript\ntype Logger = {\n    log: (error: string) => void;\n};\n\nlet helperFunctions: { [name: string]: Function } & ThisType<Logger> = {\n    hello: function () {\n        this.log('some error'); // 有效，因为\"log\"是\"this\"的一部分\n        this.update(); // 无效\n    },\n};\n```\n\n#### Uppercase\\<T\\>\n\n将输入类型 T 的名称设为大写。\n\n```typescript\ntype MyType = Uppercase<'abc'>; // \"ABC\"\n```\n\n#### Lowercase\\<T\\>\n\n将输入类型 T 的名称设为小写。\n\n```typescript\ntype MyType = Lowercase<'ABC'>; // \"abc\"\n```\n\n#### Capitalize\\<T\\>\n\n输入类型 T 的名称大写。\n\n```typescript\ntype MyType = Capitalize<'abc'>; // \"Abc\"\n```\n\n#### Uncapitalize\\<T\\>\n\n将输入类型 T 的名称取消大写。\n\n```typescript\ntype MyType = Uncapitalize<'Abc'>; // \"abc\"\n```\n\n#### NoInfer\\<T\\>\n\nNoInfer 是一种实用类型，旨在阻止泛型函数范围内类型的自动推断。\n\n示例：\n\n```typescript\n// 泛型函数范围内类型的自动推断。\nfunction fn<T extends string>(x: T[], y: T) {\n    return x.concat(y);\n}\nconst r = fn(['a', 'b'], 'c'); // 此处的类型为 (\"a\" | \"b\" | \"c\")[]\n```\n\n使用 NoInfer：\n\n<!-- skip -->\n```typescript\n// 使用 NoInfer 阻止类型推断的示例函数\nfunction fn2<T extends string>(x: T[], y: NoInfer<T>) {\n  return x.concat(y);\n}\n\nconst r2 = fn2([\"a\", \"b\"], \"c\"); // 错误：类型为“c”的类型参数不能分配给类型为“a”|“b”的参数。\n```\n\n## 其他\n\n### 错误和异常处理\n\nTypeScript 允许您使用标准 JavaScript 错误处理机制捕获和处理错误：\n\nTry-Catch-Finally 块：\n\n```typescript\ntry {\n    // 可能会抛出异常的代码\n} catch (error) {\n    // 处理错误\n} finally {\n    // 总是会执行的代码, finally 是可选的\n}\n```\n\n您还可以处理不同类型的错误：\n\n```typescript\ntry {\n    // 可能会抛出不同类型错误的代码\n} catch (error) {\n    if (error instanceof TypeError) {\n        // 处理 TypeError\n    } else if (error instanceof RangeError) {\n        // 处理 RangeError\n    } else {\n        // 处理其他的错误\n    }\n}\n```\n\n自定义错误类型：\n\n可以通过扩展 Error 来指定更具体的错误 `class` ：\n\n```typescript\nclass CustomError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\nthrow new CustomError('This is a custom error.');\n```\n\n### 混合类\n\nMixin 类允许您将多个类的行为组合并组合成一个类。它们提供了一种重用和扩展功能的方法，而不需要深层继承链。\n\n```typescript\nabstract class Identifiable {\n    name: string = '';\n    logId() {\n        console.log('id:', this.name);\n    }\n}\nabstract class Selectable {\n    selected: boolean = false;\n    select() {\n        this.selected = true;\n        console.log('Select');\n    }\n    deselect() {\n        this.selected = false;\n        console.log('Deselect');\n    }\n}\nclass MyClass {\n    constructor() {}\n}\n\n// 扩展 MyClass 以包含可识别和可选择的行为\ninterface MyClass extends Identifiable, Selectable {}\n\n// 将 mixins 应用于类的函数\nfunction applyMixins(source: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            let descriptor = Object.getOwnPropertyDescriptor(\n                baseCtor.prototype,\n                name\n            );\n            if (descriptor) {\n                Object.defineProperty(source.prototype, name, descriptor);\n            }\n        });\n    });\n}\n\n// 将 mixins 应用到 MyClass\napplyMixins(MyClass, [Identifiable, Selectable]);\nlet o = new MyClass();\no.name = 'abc';\no.logId();\no.select();\n```\n\n### 异步语言特性\n\n由于 TypeScript 是 JavaScript 的超集，因此它内置了 JavaScript 的异步语言功能，例如：\n\nPromises：\n\nPromise 是一种处理异步操作及其结果的方法，使用 `.then()`和等方法 `.catch()` 来处理成功和错误条件。\n\n要了解更多信息： [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n\nAsync/await:\n\nAsync/await 关键字是一种为处理 Promise 提供看起来更同步的语法的方法。`async` 关键字用于定义异步函数，并且 `await` 关键字在异步函数中使用以暂停执行，直到 Promise 被解决或拒绝。\n\n要了解更多信息：\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)\n\nTypeScript 很好地支持以下 API：\n\nFetch API:\n[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)\n\nWeb Workers:\n[https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)\n\nShared Workers:\n[https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker)\n\nWebSocket:\n[https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)\n\n### 迭代器和生成器\n\nTypeScript 很好地支持交互器和生成器。\n\n迭代器是实现迭代器协议的对象，提供了一种逐个访问集合或序列元素的方法。它是一个包含指向迭代中下一个元素的指针的结构。他们有一个 `next()` 方法返回序列中的下一个值以及指示序列是否为 的布尔值 `done` 。\n\n```typescript\nclass NumberIterator implements Iterable<number> {\n    private current: number;\n\n    constructor(\n        private start: number,\n        private end: number\n    ) {\n        this.current = start;\n    }\n\n    public next(): IteratorResult<number> {\n        if (this.current <= this.end) {\n            const value = this.current;\n            this.current++;\n            return { value, done: false };\n        } else {\n            return { value: undefined, done: true };\n        }\n    }\n\n    [Symbol.iterator](): Iterator<number> {\n        return this;\n    }\n}\n\nconst iterator = new NumberIterator(1, 3);\n\nfor (const num of iterator) {\n    console.log(num);\n}\n```\n\n生成器是使用 `function*` 简化迭代器创建的语法定义的特殊函数。它们使用 `yield` 关键字来定义值的序列，并在请求值时自动暂停和恢复执行。\n\n生成器使创建迭代器变得更加容易，并且对于处理大型或无限序列特别有用。\n\n例子：\n\n```typescript\nfunction* numberGenerator(start: number, end: number): Generator<number> {\n    for (let i = start; i <= end; i++) {\n        yield i;\n    }\n}\n\nconst generator = numberGenerator(1, 5);\n\nfor (const num of generator) {\n    console.log(num);\n}\n```\n\nTypeScript 还支持异步迭代器和异步生成器。\n\n要了解更多信息：\n\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator)\n\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator)\n\n### TsDocs JSDoc 参考\n\n使用 JavaScript 代码库时，可以通过使用 JSDoc 注释和附加注释来提供类型信息，帮助 TypeScript 推断正确的类型。\n\n例子：\n\n```typescript\n/**\n * Computes the power of a given number\n * @constructor\n * @param {number} base – The base value of the expression\n * @param {number} exponent – The exponent value of the expression\n */\nfunction power(base: number, exponent: number) {\n    return Math.pow(base, exponent);\n}\npower(10, 2); // function power(base: number, exponent: number): number\n```\n\n此链接提供了完整文档：\n[https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)\n\n从版本 3.7 开始，可以从 JavaScript JSDoc 语法生成 .d.ts 类型定义。更多信息可以在这里找到：\n[https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html](https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html)\n\n### @types\n\n@types 组织下的包是特殊的包命名约定，用于为现有 JavaScript 库或模块提供类型定义。例如使用：\n\n```shell\nnpm install --save-dev @types/lodash\n```\n\n将在您当前的项目中安装 `lodash` 的类型定义。\n\n要为 @types 包的类型定义做出贡献，请向 [https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped) 提交pr请求。\n\n### JSX\n\nJSX (JavaScript XML) 是 JavaScript 语言语法的扩展，允许您在 JavaScript 或 TypeScript 文件中编写类似 HTML 的代码。它通常在 React 中用来定义 HTML 结构。\n\nTypeScript 通过提供类型检查和静态分析来扩展 JSX 的功能。\n\n要使用 JSX，您需要在文件 `tsconfig.json` 中设置 `jsx` 编译器选项。两个常见的配置选项：\n\n* \"preserve\": 触发 .jsx 文件且 JSX 不变. 此选项告诉 TypeScript 按原样保留 JSX 语法，而不是在编译过程中对其进行转换。 如果您有单独的工具（例如 Babel）来处理转换，则可以使用此选项。\n* \"react\": 启用 TypeScript 的内置 JSX 转换。 将使用 React.createElement 。\n\n所有选项均可在此处使用：\n[https://www.typescriptlang.org/tsconfig#jsx](https://www.typescriptlang.org/tsconfig#jsx)\n\n### ES6 模块\n\nTypeScript 确实支持 ES6 (ECMAScript 2015) 和许多后续版本。这意味着您可以使用 ES6 语法，例如箭头函数、模板文字、类、模块、解构等等。\n\n要在项目中启用 ES6 功能，您可以在 `tsconfig.json` 中指定 `target` 属性。\n\n配置示例：\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es6\",\n    \"module\": \"es6\",\n    \"moduleResolution\": \"node\",\n    \"sourceMap\": true,\n    \"outDir\": \"dist\"\n  },\n  \"include\": [\"src\"]\n}\n```\n\n### ES7 求幂运算符\n\n求幂 (`**`) 运算符计算通过将第一个操作数进行第二个操作数的幂获得的值。它的功能与 `Math.pow()` 类似，但增加了接受 BigInts 作为操作数的功能。TypeScript 完全支持在 `tsconfig.json` 文件中设置 `target` 为 `es2016`或更大版本来使用此运算符。\n\n```typescript\nconsole.log(2 ** (2 ** 2)); // 16\n```\n\n### for-await-of 语句\n\n这是 TypeScript 完全支持的 JavaScript 功能，它允许您从目标版本 `es2018` 迭代异步可迭代对象。\n\n```typescript\nasync function* asyncNumbers(): AsyncIterableIterator<number> {\n    yield Promise.resolve(1);\n    yield Promise.resolve(2);\n    yield Promise.resolve(3);\n}\n\n(async () => {\n    for await (const num of asyncNumbers()) {\n        console.log(num);\n    }\n})();\n```\n\n### New target 元属性\n\n您可以在 TypeScript 中使用 `new.target` 元属性，该属性使您能够确定是否使用 new 运算符调用函数或构造函数。它允许您检测对象是否是由于构造函数调用而创建的。\n\n```typescript\nclass Parent {\n    constructor() {\n        console.log(new.target); // 记录用于创建实例的构造函数\n    }\n}\n\nclass Child extends Parent {\n    constructor() {\n        super();\n    }\n}\n\nconst parentX = new Parent(); // [Function: Parent]\nconst child = new Child(); // [Function: Child]\n```\n\n### 动态导入表达式\n\n可以使用 TypeScript 支持的动态导入 ECMAScript 建议有条件地加载模块或按需延迟加载模块。\n\nTypeScript 中动态导入表达式的语法如下：\n\n<!-- skip -->\n```typescript\nasync function renderWidget() {\n    const container = document.getElementById('widget');\n    if (container !== null) {\n        const widget = await import('./widget'); // 动态导入\n        widget.render(container);\n    }\n}\n\nrenderWidget();\n```\n\n### \"tsc –watch\"\n\n此命令使用 `--watch` 参数启动 TypeScript 编译器，能够在修改 TypeScript 文件时自动重新编译它们。\n\n```shell\ntsc --watch\n```\n\n从 TypeScript 4.9 版本开始，文件监控主要依赖于文件系统事件，如果无法建立基于事件的观察程序，则会自动诉诸轮询。\n\n### 默认声明\n\n当为变量或参数分配默认值时，将使用默认声明。这意味着如果没有为该变量或参数提供值，则将使用默认值。\n\n```typescript\nfunction greet(name: string = 'Anonymous'): void {\n    console.log(`Hello, ${name}!`);\n}\ngreet(); // Hello, Anonymous!\ngreet('John'); // Hello, John!\n```\n\n### 可选链\n\n可选的链接运算符 `?.` 与常规点运算符 (`.`) 一样用于访问属性或方法。但是，它通过优雅处理 `undefined` 和 `null` 来终止表达式并返回 `undefined`，而不是抛出错误。\n\n```typescript\ntype Person = {\n    name: string;\n    age?: number;\n    address?: {\n        street?: string;\n        city?: string;\n    };\n};\n\nconst person: Person = {\n    name: 'John',\n};\n\nconsole.log(person.address?.city); // undefined\n```\n\n### 空合并运算符\n\n如果 `??` 左侧是 `null` 或者 `undefined` ，则空合并运算符返回右侧值，否则，它返回左侧值。\n\n```typescript\nconst foo = null ?? 'foo';\nconsole.log(foo); // foo\n\nconst baz = 1 ?? 'baz';\nconst baz2 = 0 ?? 'baz';\nconsole.log(baz); // 1\nconsole.log(baz2); // 0\n```\n\n### 模板字符串类型\n\n模板字符串类型允许在类型级别操作字符串值并基于现有字符串生成新的字符串类型。它们对于从基于字符串的操作创建更具表现力和更精确的类型非常有用。\n\n```typescript\ntype Department = 'enginnering' | 'hr';\ntype Language = 'english' | 'spanish';\ntype Id = `${Department}-${Language}-id`; // \"enginnering-english-id\" | \"enginnering-spanish-id\" | \"hr-english-id\" | \"hr-spanish-id\"\n```\n\n### 函数重载\n\n函数重载允许您为同一函数名定义多个函数签名，每个函数签名具有不同的参数类型和返回类型。当您调用重载函数时，TypeScript 使用提供的参数来确定正确的函数签名：\n\n```typescript\nfunction makeGreeting(name: string): string;\nfunction makeGreeting(names: string[]): string[];\n\nfunction makeGreeting(person: unknown): unknown {\n    if (typeof person === 'string') {\n        return `Hi ${person}!`;\n    } else if (Array.isArray(person)) {\n        return person.map(name => `Hi, ${name}!`);\n    }\n    throw new Error('Unable to greet');\n}\n\nmakeGreeting('Simon');\nmakeGreeting(['Simone', 'John']);\n```\n\n### 递归类型\n\n递归类型是可以引用自身的类型。 这对于定义具有分层或递归结构（可能无限嵌套）的数据结构非常有用，例如链表、树和图。\n\n```typescript\ntype ListNode<T> = {\n    data: T;\n    next: ListNode<T> | undefined;\n};\n```\n\n### 递归条件类型\n\n可以使用 TypeScript 中的逻辑和递归来定义复杂的类型关系。让我们简单地分解一下：\n\n条件类型：允许您基于布尔条件定义类型：\n\n```typescript\ntype CheckNumber<T> = T extends number ? 'Number' : 'Not a number';\ntype A = CheckNumber<123>; // 'Number'\ntype B = CheckNumber<'abc'>; // 'Not a number'\n```\n\n递归：是指在自己的定义中引用自身的类型定义：\n\n```typescript\ntype Json = string | number | boolean | null | Json[] | { [key: string]: Json };\n\nconst data: Json = {\n    prop1: true,\n    prop2: 'prop2',\n    prop3: {\n        prop4: [],\n    },\n};\n```\n\n递归条件类型结合了条件逻辑和递归。这意味着类型定义可以通过条件逻辑依赖于自身，从而创建复杂且灵活的类型关系。\n\n```typescript\ntype Flatten<T> = T extends Array<infer U> ? Flatten<U> : T;\n\ntype NestedArray = [1, [2, [3, 4], 5], 6];\ntype FlattenedArray = Flatten<NestedArray>; // 2 | 3 | 4 | 5 | 1 | 6\n```\n\n### Node 中的 ECMAScript 模块支持\n\nNode.js 从 15.3.0 版本开始添加了对 ECMAScript 模块的支持，而 TypeScript 从 4.7 版本开始增加了对 Node.js 的 ECMAScript 模块支持。可以通过将 `tsconfig.json` 文件中的`module`属性的值设置为 `nodenext` 来启用此支持。这是一个例子：\n\n```json\n{\n  \"compilerOptions\": {\n    \"module\": \"nodenext\",\n    \"outDir\": \"./lib\",\n    \"declaration\": true\n  }\n}\n```\n\nNode.js 支持两种模块文件扩展名：`.mjs` 的ES 模块和 `.cjs` 的CommonJS 模块。TypeScript 中的等效文件扩展名适用 `.mts` 于 ES 模块和 `.cts` 于CommonJS 模块。当 TypeScript 编译器将这些文件转译为 JavaScript 时，它将分别创建 `.mjs` 和 `.cjs` 文件。\n\n如果您想在项目中使用 ES 模块，可以type在 package.json 文件中将该属性设置为\"module\"。这指示 Node.js 将项目视为 ES 模块项目。\n\n此外，TypeScript 还支持 .d.ts 文件中的类型声明。这些声明文件为用 TypeScript 编写的库或模块提供类型信息，允许其他开发人员通过 TypeScript 的类型检查和自动完成功能来利用它们。\n\n### 断言函数\n\n在 TypeScript 中，断言函数是根据返回值指示特定条件验证的函数。在最简单的形式中，断言函数检查提供的谓词，并在谓词计算结果为 false 时引发错误。\n\n```typescript\nfunction isNumber(value: unknown): asserts value is number {\n    if (typeof value !== 'number') {\n        throw new Error('Not a number');\n    }\n}\n```\n\n或者可以声明为函数表达式：\n\n```typescript\ntype AssertIsNumber = (value: unknown) => asserts value is number;\nconst isNumber: AssertIsNumber = value => {\n    if (typeof value !== 'number') {\n        throw new Error('Not a number');\n    }\n};\n```\n\n断言函数与类型保护有相似之处。类型保护最初是为了执行运行时检查并确保值的类型在特定范围内而引入的。具体来说，类型保护是一个计算类型谓词并返回指示谓词是真还是假的布尔值的函数。这与断言函数略有不同，断言函数的目的是在不满足谓词时抛出错误而不是返回 false。\n\n类型保护示例：\n\n```typescript\nconst isNumber = (value: unknown): value is number => typeof value === 'number';\n```\n\n### 可变参数元组类型\n\n可变元组类型是 TypeScript 4.0 版本中引入的一个功能，让我们通过回顾什么是元组来开始学习它们：\n\n元组类型是一个具有定义长度的数组，并且每个元素的类型已知：\n\n```typescript\ntype Student = [string, number];\nconst [name, age]: Student = ['Simone', 20];\n```\n\n术语\"可变参数\"意味着不定数量（接受可变数量的参数）。\n\n可变参数元组是一种元组类型，它具有以前的所有属性，但确切的形状尚未定义：\n\n```typescript\ntype Bar<T extends unknown[]> = [boolean, ...T, number];\n\ntype A = Bar<[boolean]>; // [boolean, boolean, number]\ntype B = Bar<['a', 'b']>; // [boolean, 'a', 'b', number]\ntype C = Bar<[]>; // [boolean, number]\n```\n\n在前面的代码中我们可以看到元组形状是由T传入的泛型定义的。\n\n可变参数元组可以接受多个泛型，这使得它们非常灵活：\n\n```typescript\ntype Bar<T extends unknown[], G extends unknown[]> = [...T, boolean, ...G];\n\ntype A = Bar<[number], [string]>; // [number, boolean, string]\ntype B = Bar<['a', 'b'], [boolean]>; // [\"a\", \"b\", boolean, boolean]\n```\n\n使用新的可变参数元组，我们可以使用：\n\n* 元组类型语法中的扩展现在可以是通用的，因此即使我们不知道我们正在操作的实际类型，我们也可以表示元组和数组上的高阶操作\n* 其余元素可以出现在元组中的任何位置。\n\n例子：\n\n```typescript\ntype Items = readonly unknown[];\n\nfunction concat<T extends Items, U extends Items>(\n    arr1: T,\n    arr2: U\n): [...T, ...U] {\n    return [...arr1, ...arr2];\n}\n\nconcat([1, 2, 3], ['4', '5', '6']); // [1, 2, 3, \"4\", \"5\", \"6\"]\n```\n\n### 装箱类型\n\n装箱类型是指用于将基本类型表示为对象的包装对象。这些包装器对象提供了原始值无法直接使用的附加功能和方法。\n\n当你访问原始 `string` 上的 `charAt` 或者 `normalize` 方法时，JavaScript 将其包装在 `String` 类型的对象中，调用该方法，然后丢弃该对象\n\n示范：\n\n```typescript\nconst originalNormalize = String.prototype.normalize;\nString.prototype.normalize = function () {\n    console.log(this, typeof this);\n    return originalNormalize.call(this);\n};\nconsole.log('\\u0041'.normalize());\n```\n\nTypeScript 通过为原语及其相应的对象包装器提供单独的类型来表示这种区别：\n\n* string => String\n* number => Number\n* boolean => Boolean\n* symbol => Symbol\n* bigint => BigInt\n\n通常不需要盒装类型。避免使用装箱类型，而是使用基元类型，例如 `string` 代替 `String`。\n\n### TypeScript 中的协变和逆变\n\n协变和逆变用于描述在处理类型的继承或赋值时关系如何工作。\n\n协变意味着类型关系保留继承或赋值的方向，因此如果类型 A 是类型 B 的子类型，则类型 A 的数组也被视为类型 B 的数组的子类型。这里需要注意的重要事项是维持子类型关系，这意味着协变接受子类型但不接受超类型。\n\n逆变意味着类型关系颠倒了继承或赋值的方向，因此如果类型 A 是类型 B 的子类型，则类型 B 的数组被视为类型 A 数组的子类型。子类型关系颠倒了，这意味着该逆变接受超类型但不接受子类型。\n\n注意：双变量意味着同时接受超类型和子类型。\n\n示例：假设我们有一个适合所有动物的空间和一个专门适合狗的单独空间。\n\n在协方差中，您可以将所有狗放入动物空间中，因为狗是一种动物。但你不能把所有的动物都放在狗的空间里，因为可能还有其他动物混在一起。\n\n在逆变中，您不能将所有动物放入狗空间中，因为动物空间也可能包含其他动物。然而，你可以把所有的狗都放在动物空间里，因为所有的狗也是动物。\n\n<!-- skip -->\n```typescript\n// 协变示例\nclass Animal {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n\nclass Dog extends Animal {\n    breed: string;\n    constructor(name: string, breed: string) {\n        super(name);\n        this.breed = breed;\n    }\n}\n\nlet animals: Animal[] = [];\nlet dogs: Dog[] = [];\n\n// 协变允许将子类型（狗）数组分配给超类型（动物）数组\nanimals = dogs;\ndogs = animals; // 无效: 'Animal[]' 不能赋值给 'Dog[]'\n\n// 逆变示例\ntype Feed<in T> = (animal: T) => void;\n\nlet feedAnimal: Feed<Animal> = (animal: Animal) => {\n    console.log(`Animal name: ${animal.name}`);\n};\n\nlet feedDog: Feed<Dog> = (dog: Dog) => {\n    console.log(`Dog name: ${dog.name}, Breed: ${dog.breed}`);\n};\n\n// 逆变允许将超类型（动物）回调赋值给子类型（狗）回调\nfeedDog = feedAnimal;\nfeedAnimal = feedDog; // 无效: Type 'Feed<Dog>' 不能赋值给 'Feed<Animal>'.\n```\n\n在 TypeScript 中，数组的类型关系是协变的，而函数参数的类型关系是逆变的。这意味着 TypeScript 同时表现出协变和逆变，具体取决于上下文。\n\n#### 类型参数的可选方差注释\n\n从 TypeScript 4.7.0 开始，我们可以使用out和in关键字来具体说明方差注释。\n\n对于协变，使用out关键字：\n\n```typescript\ntype AnimalCallback<out T> = () => T; // 此处 T 是协变的\n```\n\n对于逆变，使用in关键字：\n\n```typescript\ntype AnimalCallback<in T> = (value: T) => void; // 此处 T 是逆变的\n```\n\n### 模板字符串模式索引签名\n\n模板字符串模式索引签名允许我们使用模板字符串模式定义灵活的索引签名。 此功能使我们能够创建可以使用特定字符串键模式进行索引的对象，从而在访问和操作属性时提供更多控制和特异性。\n\nTypeScript 4.4 版开始允许符号和模板字符串模式的索引签名。\n\n```typescript\nconst uniqueSymbol = Symbol('description');\n\ntype MyKeys = `key-${string}`;\n\ntype MyObject = {\n    [uniqueSymbol]: string;\n    [key: MyKeys]: number;\n};\n\nconst obj: MyObject = {\n    [uniqueSymbol]: 'Unique symbol key',\n    'key-a': 123,\n    'key-b': 456,\n};\n\nconsole.log(obj[uniqueSymbol]); // Unique symbol key\nconsole.log(obj['key-a']); // 123\nconsole.log(obj['key-b']); // 456\n```\n\n### satisfies操作符\n\n`satisfies` 允许您检查给定类型是否满足特定接口或条件。换句话说，它确保类型具有特定接口所需的所有属性和方法。这是确保变量适合类型定义的一种方法。\n\n下面是一个示例：\n\n<!-- skip -->\n```typescript\ntype Columns = 'name' | 'nickName' | 'attributes';\n\ntype User = Record<Columns, string | string[] | undefined>;\n\n// `User`的类型注释\nconst user: User = {\n    name: 'Simone',\n    nickName: undefined,\n    attributes: ['dev', 'admin'],\n};\n\n// 在以下几行中，TypeScript 将无法正确推断\nuser.attributes?.map(console.log); // 'string | string[]' 中不存在属性 'map'。'string' 中不存在属性 'map'。\nuser.nickName; // string | string[] | undefined\n\n// 类型断言 `as`\nconst user2 = {\n    name: 'Simon',\n    nickName: undefined,\n    attributes: ['dev', 'admin'],\n} as User;\n\n// 这里也一样的， TypeScript 将无法正确推断\nuser2.attributes?.map(console.log); //'string | string[]' 中不存在属性 'map'。'string' 中不存在属性 'map'。\nuser2.nickName; // string | string[] | undefined\n\n// 使用\"satisfies\"运算符我们现在可以正确推断类型\nconst user3 = {\n    name: 'Simon',\n    nickName: undefined,\n    attributes: ['dev', 'admin'],\n} satisfies User;\n\nuser3.attributes?.map(console.log); // TypeScript 推断正确: string[]\nuser3.nickName; // TypeScript 推断正确: undefined\n```\n\n### 仅类型导入和导出\n\n仅类型导入和导出允许您导入或导出类型，而无需导入或导出与这些类型关联的值或函数。 这对于减小捆绑包的大小很有用。\n\n要使用仅类型导入，您可以使用`import type`关键字。\n\nTypeScript 允许在仅类型导入中使用声明和实现文件扩展名（.ts、.mts、.cts 和 .tsx），无论`allowImportingTsExtensions`设置如何。\n\n例如：\n\n<!-- skip -->\n```typescript\nimport type { House } from './house.ts';\n```\n\n以下是支持的形式：\n\n<!-- skip -->\n```typescript\nimport type T from './mod';\nimport type { A, B } from './mod';\nimport type * as Types from './mod';\nexport type { T };\nexport type { T } from './mod';\n```\n\n### 使用声明和显式资源管理\n\n\"using\"声明是块范围的、不可变的绑定，类似于\"const\"，用于管理一次性资源。 当使用值初始化时，该值的\"Symbol.dispose\"方法将被记录，并随后在退出封闭块作用域时执行。\n\n这是基于 ECMAScript 的资源管理功能，该功能对于在对象创建后执行基本的清理任务非常有用，例如关闭连接、删除文件和释放内存。\n\n笔记：\n\n* 由于最近在 TypeScript 5.2 版中引入，大多数运行时缺乏本机支持。 您将需要以下功能的填充：`Symbol.dispose`、`Symbol.asyncDispose`、`DisposableStack`、`AsyncDisposableStack`、`SuppressedError`。\n* 此外，您需要按如下方式配置 tsconfig.json：\n\n```json\n{\n    \"compilerOptions\": {\n        \"target\": \"es2022\",\n        \"lib\": [\"es2022\", \"esnext.disposable\", \"dom\"]\n    }\n}\n````\n\n例子：\n\n<!-- skip -->\n```typescript\n//@ts-ignore\nSymbol.dispose ??= Symbol('Symbol.dispose'); // 简单的兼容性填充\n\nconst doWork = (): Disposable => {\n    return {\n        [Symbol.dispose]: () => {\n            console.log('disposed');\n        },\n    };\n};\n\nconsole.log(1);\n\n{\n    using work = doWork(); // 资源被声明\n    console.log(2);\n} // 资源被释放 (例如, `work[Symbol.dispose]()` 被执行)\n\nconsole.log(3);\n```\n\n该代码将记录：\n\n```shell\n1\n2\ndisposed\n3\n```\n\n符合处置条件的资源必须遵守 `Disposable` 接口：\n\n```typescript\n// lib.esnext.disposable.d.ts\ninterface Disposable {\n    [Symbol.dispose](): void;\n}\n```\n\n\"using\"声明在堆栈中记录资源处置操作，确保它们以与声明相反的顺序处置：\n\n<!-- skip -->\n```typescript\n{\n    using j = getA(),\n        y = getB();\n    using k = getC();\n} // 先释放 `C`, 然后 `B`, 然后 `A`.\n```\n\n即使发生后续代码或异常，也保证会释放资源。 这可能会导致处置可能引发异常，并可能抑制另一个异常。 为了保留有关被抑制错误的信息，引入了一个新的本机异常\"SuppressedError\"。\n\n#### 使用声明等待\n\n\"await using\"声明处理异步一次性资源。 该值必须具有\"Symbol.asyncDispose\"方法，该方法将在块末尾等待。\n\n<!-- skip -->\n```typescript\nasync function doWorkAsync() {\n    await using work = doWorkAsync(); // 资源被声明\n} // // 资源被释放 (例如, `await work[Symbol.asyncDispose]()` 被执行)\n```\n\n对于异步可处置资源，它必须遵守\"Disposable\"或\"AsyncDisposable\"接口：\n\n```typescript\n// lib.esnext.disposable.d.ts\ninterface AsyncDisposable {\n    [Symbol.asyncDispose](): Promise<void>;\n}\n```\n\n<!-- skip -->\n```typescript\n//@ts-ignore\nSymbol.asyncDispose ??= Symbol('Symbol.asyncDispose'); // Simple polify\n\nclass DatabaseConnection implements AsyncDisposable {\n    // 当对象被异步释放时会被调用的方法\n    [Symbol.asyncDispose]() {\n        // Close the connection and return a promise\n        return this.close();\n    }\n\n    async close() {\n        console.log('Closing the connection...');\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        console.log('Connection closed.');\n    }\n}\n\nasync function doWork() {\n    // 创建一个新的连接，并在其超出作用域时进行异步释放\n    await using connection = new DatabaseConnection(); // 资源被声明\n    console.log('Doing some work...');\n} // 资源被释放 (例如, `await connection[Symbol.asyncDispose]()` 被执行)\n\ndoWork();\n```\n\n代码日志：\n\n```shell\nDoing some work...\nClosing the connection...\nConnection closed.\n```\n\n语句中允许使用\"using\"和\"await using\"声明：\"for\"、\"for-in\"、\"for-of\"、\"for-await-of\"、\"switch\"。\n\n### 导入属性\n\nTypeScript 5.3 的导入属性（导入标签）告诉运行时如何处理模块（JSON 等）。这通过确保干净的导入来提高安全性，并与内容安全策略 (CSP) 保持一致，以实现更安全的资源加载。TypeScript 确保它们有效，但让运行时处理它们的解释以进行特定的模块处理。\n\n示例：\n\n<!-- skip -->\n```typescript\nimport config from './config.json' with { type: 'json' };\n```\n\n使用动态导入：\n\n<!-- skip -->\n```typescript\nconst config = import(\"./config.json\", { with: { type: \"json\" } })\n```\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 159.2060546875,
          "content": "# The Concise TypeScript Book\n\nThe Concise TypeScript Book provides a comprehensive and succinct overview of TypeScript's capabilities. It offers clear explanations covering all aspects found in the latest version of the language, from its powerful type system to advanced features. Whether you're a beginner or an experienced developer, this book is an invaluable resource to enhance your understanding and proficiency in TypeScript.\n\nThis book is completely Free and Open Source.\n\nIf you found this TypeScript book valuable and wish to contribute, consider supporting my efforts via PayPal. Thanks!\n\n[![Donate](https://img.shields.io/badge/Donate-PayPal-green.svg)](https://www.paypal.com/donate/?business=QW82ZS956XLFY&no_recurring=0&currency_code=EUR)\n\n## Translations\n\nThis book has been translated into several language versions, including:\n\n[Chinese](https://github.com/gibbok/typescript-book/blob/main/README-zh_CN.md)\n\n## Downloads and website\n\nYou can also download the Epub version:\n\n[https://github.com/gibbok/typescript-book/tree/main/downloads](https://github.com/gibbok/typescript-book/tree/main/downloads)\n\nAn online version is available at:\n\n[https://gibbok.github.io/typescript-book](https://gibbok.github.io/typescript-book)\n\n## Table of Contents\n\n<!-- markdownlint-disable MD004 -->\n- [The Concise TypeScript Book](#the-concise-typescript-book)\n  - [Translations](#translations)\n  - [Downloads and website](#downloads-and-website)\n  - [Table of Contents](#table-of-contents)\n  - [Introduction](#introduction)\n  - [About the Author](#about-the-author)\n  - [TypeScript Introduction](#typescript-introduction)\n    - [What is TypeScript?](#what-is-typescript)\n    - [Why TypeScript?](#why-typescript)\n    - [TypeScript and JavaScript](#typescript-and-javascript)\n    - [TypeScript Code Generation](#typescript-code-generation)\n    - [Modern JavaScript Now (Downleveling)](#modern-javascript-now-downleveling)\n  - [Getting Started With TypeScript](#getting-started-with-typescript)\n    - [Installation](#installation)\n    - [Configuration](#configuration)\n    - [TypeScript Configuration File](#typescript-configuration-file)\n      - [target](#target)\n      - [lib](#lib)\n      - [strict](#strict)\n      - [module](#module)\n      - [moduleResolution](#moduleresolution)\n      - [esModuleInterop](#esmoduleinterop)\n      - [jsx](#jsx)\n      - [skipLibCheck](#skiplibcheck)\n      - [files](#files)\n      - [include](#include)\n      - [exclude](#exclude)\n    - [importHelpers](#importhelpers)\n    - [Migration to TypeScript Advice](#migration-to-typescript-advice)\n  - [Exploring the Type System](#exploring-the-type-system)\n    - [The TypeScript Language Service](#the-typescript-language-service)\n    - [Structural Typing](#structural-typing)\n    - [TypeScript Fundamental Comparison Rules](#typescript-fundamental-comparison-rules)\n    - [Types as Sets](#types-as-sets)\n    - [Assign a type: Type Declarations and Type Assertions](#assign-a-type-type-declarations-and-type-assertions)\n      - [Type Declaration](#type-declaration)\n      - [Type Assertion](#type-assertion)\n      - [Ambient Declarations](#ambient-declarations)\n    - [Property Checking and Excess Property Checking](#property-checking-and-excess-property-checking)\n    - [Weak Types](#weak-types)\n    - [Strict Object Literal Checking (Freshness)](#strict-object-literal-checking-freshness)\n    - [Type Inference](#type-inference)\n    - [More Advanced Inferences](#more-advanced-inferences)\n    - [Type Widening](#type-widening)\n    - [Const](#const)\n      - [Const Modifier on Type Parameters](#const-modifier-on-type-parameters)\n      - [Const assertion](#const-assertion)\n    - [Explicit Type Annotation](#explicit-type-annotation)\n    - [Type Narrowing](#type-narrowing)\n      - [Conditions](#conditions)\n      - [Throwing or returning](#throwing-or-returning)\n      - [Discriminated Union](#discriminated-union)\n      - [User-Defined Type Guards](#user-defined-type-guards)\n  - [Primitive Types](#primitive-types)\n    - [string](#string)\n    - [boolean](#boolean)\n    - [number](#number)\n    - [bigInt](#bigint)\n    - [Symbol](#symbol)\n    - [null and undefined](#null-and-undefined)\n    - [Array](#array)\n    - [any](#any)\n  - [Type Annotations](#type-annotations)\n  - [Optional Properties](#optional-properties)\n  - [Readonly Properties](#readonly-properties)\n  - [Index Signatures](#index-signatures)\n  - [Extending Types](#extending-types)\n  - [Literal Types](#literal-types)\n  - [Literal Inference](#literal-inference)\n  - [strictNullChecks](#strictnullchecks)\n  - [Enums](#enums)\n    - [Numeric enums](#numeric-enums)\n    - [String enums](#string-enums)\n    - [Constant enums](#constant-enums)\n    - [Reverse mapping](#reverse-mapping)\n    - [Ambient enums](#ambient-enums)\n    - [Computed and constant members](#computed-and-constant-members)\n  - [Narrowing](#narrowing)\n    - [typeof type guards](#typeof-type-guards)\n    - [Truthiness narrowing](#truthiness-narrowing)\n    - [Equality narrowing](#equality-narrowing)\n    - [In Operator narrowing](#in-operator-narrowing)\n    - [instanceof narrowing](#instanceof-narrowing)\n  - [Assignments](#assignments)\n  - [Control Flow Analysis](#control-flow-analysis)\n  - [Type Predicates](#type-predicates)\n  - [Discriminated Unions](#discriminated-unions)\n  - [The never Type](#the-never-type)\n  - [Exhaustiveness checking](#exhaustiveness-checking)\n  - [Object Types](#object-types)\n  - [Tuple Type (Anonymous)](#tuple-type-anonymous)\n  - [Named Tuple Type (Labeled)](#named-tuple-type-labeled)\n  - [Fixed Length Tuple](#fixed-length-tuple)\n  - [Union Type](#union-type)\n  - [Intersection Types](#intersection-types)\n  - [Type Indexing](#type-indexing)\n  - [Type from Value](#type-from-value)\n  - [Type from Func Return](#type-from-func-return)\n  - [Type from Module](#type-from-module)\n  - [Mapped Types](#mapped-types)\n  - [Mapped Type Modifiers](#mapped-type-modifiers)\n  - [Conditional Types](#conditional-types)\n  - [Distributive Conditional Types](#distributive-conditional-types)\n  - [infer Type Inference in Conditional Types](#infer-type-inference-in-conditional-types)\n  - [Predefined Conditional Types](#predefined-conditional-types)\n  - [Template Union Types](#template-union-types)\n  - [Any type](#any-type)\n  - [Unknown type](#unknown-type)\n  - [Void type](#void-type)\n  - [Never type](#never-type)\n  - [Interface and Type](#interface-and-type)\n    - [Common Syntax](#common-syntax)\n    - [Basic Types](#basic-types)\n    - [Objects and Interfaces](#objects-and-interfaces)\n    - [Union and Intersection Types](#union-and-intersection-types)\n  - [Built-in Type Primitives](#built-in-type-primitives)\n  - [Common Built-in JS Objects](#common-built-in-js-objects)\n  - [Overloads](#overloads)\n  - [Merging and Extension](#merging-and-extension)\n  - [Differences between Type and Interface](#differences-between-type-and-interface)\n  - [Class](#class)\n    - [Class Common Syntax](#class-common-syntax)\n    - [Constructor](#constructor)\n    - [Private and Protected Constructors](#private-and-protected-constructors)\n    - [Access Modifiers](#access-modifiers)\n    - [Get and Set](#get-and-set)\n    - [Auto-Accessors in Classes](#auto-accessors-in-classes)\n    - [this](#this)\n    - [Parameter Properties](#parameter-properties)\n    - [Abstract Classes](#abstract-classes)\n    - [With Generics](#with-generics)\n    - [Decorators](#decorators)\n      - [Class Decorators](#class-decorators)\n      - [Property Decorator](#property-decorator)\n      - [Method Decorator](#method-decorator)\n      - [Getter and Setter Decorators](#getter-and-setter-decorators)\n      - [Decorator Metadata](#decorator-metadata)\n    - [Inheritance](#inheritance)\n    - [Statics](#statics)\n    - [Property initialization](#property-initialization)\n    - [Method overloading](#method-overloading)\n  - [Generics](#generics)\n    - [Generic Type](#generic-type)\n    - [Generic Classes](#generic-classes)\n    - [Generic Constraints](#generic-constraints)\n    - [Generic contextual narrowing](#generic-contextual-narrowing)\n  - [Erased Structural Types](#erased-structural-types)\n  - [Namespacing](#namespacing)\n  - [Symbols](#symbols)\n  - [Triple-Slash Directives](#triple-slash-directives)\n  - [Type Manipulation](#type-manipulation)\n    - [Creating Types from Types](#creating-types-from-types)\n    - [Indexed Access Types](#indexed-access-types)\n    - [Utility Types](#utility-types)\n      - [Awaited\\<T\\>](#awaitedt)\n      - [Partial\\<T\\>](#partialt)\n      - [Required\\<T\\>](#requiredt)\n      - [Readonly\\<T\\>](#readonlyt)\n      - [Record\\<K, T\\>](#recordk-t)\n      - [Pick\\<T, K\\>](#pickt-k)\n      - [Omit\\<T, K\\>](#omitt-k)\n      - [Exclude\\<T, U\\>](#excludet-u)\n      - [Extract\\<T, U\\>](#extractt-u)\n      - [NonNullable\\<T\\>](#nonnullablet)\n      - [Parameters\\<T\\>](#parameterst)\n      - [ConstructorParameters\\<T\\>](#constructorparameterst)\n      - [ReturnType\\<T\\>](#returntypet)\n      - [InstanceType\\<T\\>](#instancetypet)\n      - [ThisParameterType\\<T\\>](#thisparametertypet)\n      - [OmitThisParameter\\<T\\>](#omitthisparametert)\n      - [ThisType\\<T\\>](#thistypet)\n      - [Uppercase\\<T\\>](#uppercaset)\n      - [Lowercase\\<T\\>](#lowercaset)\n      - [Capitalize\\<T\\>](#capitalizet)\n      - [Uncapitalize\\<T\\>](#uncapitalizet)\n      - [NoInfer\\<T\\>](#noinfert)\n  - [Others](#others)\n    - [Errors and Exception Handling](#errors-and-exception-handling)\n    - [Mixin classes](#mixin-classes)\n    - [Asynchronous Language Features](#asynchronous-language-features)\n    - [Iterators and Generators](#iterators-and-generators)\n    - [TsDocs JSDoc Reference](#tsdocs-jsdoc-reference)\n    - [@types](#types)\n    - [JSX](#jsx-1)\n    - [ES6 Modules](#es6-modules)\n    - [ES7 Exponentiation Operator](#es7-exponentiation-operator)\n    - [The for-await-of Statement](#the-for-await-of-statement)\n    - [New target meta-property](#new-target-meta-property)\n    - [Dynamic Import Expressions](#dynamic-import-expressions)\n    - [\"tsc –watch\"](#tsc-watch)\n    - [Non-null Assertion Operator](#non-null-assertion-operator)\n    - [Defaulted declarations](#defaulted-declarations)\n    - [Optional Chaining](#optional-chaining)\n    - [Nullish coalescing operator](#nullish-coalescing-operator)\n    - [Template Literal Types](#template-literal-types)\n    - [Function overloading](#function-overloading)\n    - [Recursive Types](#recursive-types)\n    - [Recursive Conditional Types](#recursive-conditional-types)\n    - [ECMAScript Module Support in Node](#ecmascript-module-support-in-node)\n    - [Assertion Functions](#assertion-functions)\n    - [Variadic Tuple Types](#variadic-tuple-types)\n    - [Boxed types](#boxed-types)\n    - [Covariance and Contravariance in TypeScript](#covariance-and-contravariance-in-typescript)\n      - [Optional Variance Annotations for Type Parameters](#optional-variance-annotations-for-type-parameters)\n    - [Template String Pattern Index Signatures](#template-string-pattern-index-signatures)\n    - [The satisfies Operator](#the-satisfies-operator)\n    - [Type-Only Imports and Export](#type-only-imports-and-export)\n    - [using declaration and Explicit Resource Management](#using-declaration-and-explicit-resource-management)\n      - [await using declaration](#await-using-declaration)\n    - [Import Attributes](#import-attributes)\n<!-- markdownlint-enable MD004 -->\n\n## Introduction\n\nWelcome to The Concise TypeScript Book! This guide equips you with essential knowledge and practical skills for effective TypeScript development. Discover key concepts and techniques to write clean, robust code. Whether you're a beginner or an experienced developer, this book serves as both a comprehensive guide and a handy reference for leveraging TypeScript's power in your projects.\n\nThis book covers TypeScript 5.2.\n\n## About the Author\n\nSimone Poggiali is an experienced Senior Front-end Developer with a passion for writing professional-grade code since the 90s. Throughout his international career, he has contributed to numerous projects for a wide range of clients, from startups to large organizations. Notable companies such as HelloFresh, Siemens, O2, and Leroy Merlin have benefited from his expertise and dedication.\n\nYou can reach Simone Poggiali on the following platforms:\n\n* LinkedIn: [https://www.linkedin.com/in/simone-poggiali](https://www.linkedin.com/in/simone-poggiali)\n* GitHub: [https://github.com/gibbok](https://github.com/gibbok)\n* X.com: [https://x.com/gibbok_coding](https://x.com/gibbok_coding)\n* Email: gibbok.coding📧gmail.com\n\n## TypeScript Introduction\n\n### What is TypeScript?\n\nTypeScript is a strongly typed programming language that builds on JavaScript. It was originally designed by Anders Hejlsberg in 2012 and is currently developed and maintained by Microsoft as an open source project.\n\nTypeScript compiles to JavaScript and can be executed in any JavaScript runtime (e.g., a browser or server Node.js).\n\nTypeScript supports multiple programming paradigms such as functional, generic, imperative, and object-oriented. TypeScript is neither an interpreted nor a compiled language.\n\n### Why TypeScript?\n\nTypeScript is a strongly typed language that helps prevent common programming mistakes and avoid certain kinds of run-time errors before the program is executed.\n\nA strongly typed language allows the developer to specify various program constraints and behaviors in the data type definitions, facilitating the ability to verify the correctness of the software and prevent defects. This is especially valuable in large-scale applications.\n\nSome of the benefits of TypeScript:\n\n* Static typing, optionally strongly typed\n* Type Inference\n* Access to ES6 and ES7 features\n* Cross-Platform and Cross-browser Compatibility\n* Tooling support with IntelliSense\n\n### TypeScript and JavaScript\n\nTypeScript is written in `.ts` or `.tsx` files, while JavaScript files are written in `.js` or `.jsx`.\n\nFiles with the extension `.tsx` or `.jsx` can contain JavaScript Syntax Extension JSX, which is used in React for UI development.\n\nTypeScript is a typed superset of JavaScript (ECMAScript 2015) in terms of syntax. All JavaScript code is valid TypeScript code, but the reverse is not always true.\n\nFor instance, consider a function in a JavaScript file with the `.js` extension, such as the following:\n\n<!-- skip -->\n```typescript\nconst sum = (a, b) => a + b;\n```\n\nThe function can be converted and used in TypeScript by changing the file extension to `.ts`. However, if the same function is annotated with TypeScript types, it cannot be executed in any JavaScript runtime without compilation. The following TypeScript code will produce a syntax error if it is not compiled:\n\n<!-- skip -->\n```typescript\nconst sum = (a: number, b: number): number => a + b;\n```\n\nTypeScript was designed to detect possible exceptions that can occur at runtime during compilation time by having the developer define the intent with type annotations. In addition, TypeScript can also catch issues if no type annotation is provided. For instance, the following code snippet does not specify any TypeScript types:\n\n<!-- skip -->\n```typescript\nconst items = [{ x: 1 }, { x: 2 }];\nconst result = items.filter(item => item.y);\n```\n\nIn this case, TypeScript detects an error and reports:\n\n```text\nProperty 'y' does not exist on type '{ x: number; }'.\n```\n\nTypeScript's type system is largely influenced by the runtime behavior of JavaScript. For example, the addition operator (+), which in JavaScript can either perform string concatenation or numeric addition, is modeled in the same way in TypeScript:\n\n```typescript\nconst result = '1' + 1; // Result is of type string\n```\n\nThe team behind TypeScript has made a deliberate decision to flag unusual usage of JavaScript as errors. For instance, consider the following valid JavaScript code:\n\n<!-- skip -->\n```typescript\nconst result = 1 + true; // In JavaScript, the result is equal 2\n```\n\nHowever, TypeScript throws an error:\n\n```text\nOperator '+' cannot be applied to types 'number' and 'boolean'.\n```\n\nThis error occurs because TypeScript strictly enforces type compatibility, and in this case, it identifies an invalid operation between a number and a boolean.\n\n### TypeScript Code Generation\n\nThe TypeScript compiler has two main responsibilities: checking for type errors and compiling to JavaScript. These two processes are independent of each other. Types do not affect the execution of the code in a JavaScript runtime, as they are completely erased during compilation. TypeScript can still output JavaScript even in the presence of type errors.\nHere is an example of TypeScript code with a type error:\n\n<!-- skip -->\n```typescript\nconst add = (a: number, b: number): number => a + b;\nconst result = add('x', 'y'); // Argument of type 'string' is not assignable to parameter of type 'number'.\n```\n\nHowever, it can still produce executable JavaScript output:\n\n<!-- skip -->\n```typescript\n'use strict';\nconst add = (a, b) => a + b;\nconst result = add('x', 'y'); // xy\n```\n\nIt is not possible to check TypeScript types at runtime. For example:\n\n<!-- skip -->\n```typescript\ninterface Animal {\n    name: string;\n}\ninterface Dog extends Animal {\n    bark: () => void;\n}\ninterface Cat extends Animal {\n    meow: () => void;\n}\nconst makeNoise = (animal: Animal) => {\n    if (animal instanceof Dog) {\n        // 'Dog' only refers to a type, but is being used as a value here.\n        // ...\n    }\n};\n```\n\nAs the types are erased after compilation, there is no way to run this code in JavaScript. To recognize types at runtime, we need to use another mechanism. TypeScript provides several options, with a common one being \"tagged union\". For example:\n\n```typescript\ninterface Dog {\n    kind: 'dog'; // Tagged union\n    bark: () => void;\n}\ninterface Cat {\n    kind: 'cat'; // Tagged union\n    meow: () => void;\n}\ntype Animal = Dog | Cat;\n\nconst makeNoise = (animal: Animal) => {\n    if (animal.kind === 'dog') {\n        animal.bark();\n    } else {\n        animal.meow();\n    }\n};\n\nconst dog: Dog = {\n    kind: 'dog',\n    bark: () => console.log('bark'),\n};\nmakeNoise(dog);\n```\n\nThe property \"kind\" is a value that can be used at runtime to distinguish between objects in JavaScript.\n\nIt is also possible for a value at runtime to have a type different from the one declared in the type declaration. For instance, if the developer has misinterpreted an API type and annotated it incorrectly.\n\nTypeScript is a superset of JavaScript, so the \"class\" keyword can be used as a type and value at runtime.\n\n```typescript\nclass Animal {\n    constructor(public name: string) {}\n}\nclass Dog extends Animal {\n    constructor(\n        public name: string,\n        public bark: () => void\n    ) {\n        super(name);\n    }\n}\nclass Cat extends Animal {\n    constructor(\n        public name: string,\n        public meow: () => void\n    ) {\n        super(name);\n    }\n}\ntype Mammal = Dog | Cat;\n\nconst makeNoise = (mammal: Mammal) => {\n    if (mammal instanceof Dog) {\n        mammal.bark();\n    } else {\n        mammal.meow();\n    }\n};\n\nconst dog = new Dog('Fido', () => console.log('bark'));\nmakeNoise(dog);\n```\n\nIn JavaScript, a \"class\" has a \"prototype\" property, and the \"instanceof\" operator can be used to test if the prototype property of a constructor appears anywhere in the prototype chain of an object.\n\nTypeScript has no effect on runtime performance, as all types will be erased. However, TypeScript does introduce some build time overhead.\n\n### Modern JavaScript Now (Downleveling)\n\nTypeScript can compile code to any released version of JavaScript since ECMAScript 3 (1999). This means that TypeScript can transpile code from the latest JavaScript features to older versions, a process known as Downleveling. This allows the usage of modern JavaScript while maintaining maximum compatibility with older runtime environments.\n\nIt's important to note that during transpilation to an older version of JavaScript, TypeScript may generate code that could incur a performance overhead compared to native implementations.\n\nHere are some of the modern JavaScript features that can be used in TypeScript:\n\n* ECMAScript modules instead of AMD-style \"define\" callbacks or CommonJS \"require\" statements.\n* Classes instead of prototypes.\n* Variables declaration using \"let\" or \"const\" instead of \"var\".\n* \"for-of\" loop or \".forEach\" instead of the traditional \"for\" loop.\n* Arrow functions instead of function expressions.\n* Destructuring assignment.\n* Shorthand property/method names and computed property names.\n* Default function parameters.\n\nBy leveraging these modern JavaScript features, developers can write more expressive and concise code in TypeScript.\n\n## Getting Started With TypeScript\n\n### Installation\n\nVisual Studio Code provides excellent support for the TypeScript language but does not include the TypeScript compiler. To install the TypeScript compiler, you can use a package manager like npm or yarn:\n\n```shell\nnpm install typescript --save-dev\n```\n\nor\n\n```shell\nyarn add typescript --dev\n```\n\nMake sure to commit the generated lockfile to ensure that every team member uses the same version of TypeScript.\n\nTo run the TypeScript compiler, you can use the following commands\n\n```shell\nnpx tsc\n```\n\nor\n\n```shell\nyarn tsc\n```\n\nIt is recommended to install TypeScript project-wise rather than globally, as it provides a more predictable build process. However, for one-off occasions, you can use the following command:\n\n```shell\nnpx tsc\n```\n\nor installing it globally:\n\n```shell\nnpm install -g typescript\n```\n\nIf you are using Microsoft Visual Studio, you can obtain TypeScript as a package in NuGet for your MSBuild projects. In the NuGet Package Manager Console, run the following command:\n\n```shell\nInstall-Package Microsoft.TypeScript.MSBuild\n```\n\nDuring the TypeScript installation, two executables are installed: \"tsc\" as the TypeScript compiler and \"tsserver\" as the TypeScript standalone server. The standalone server contains the compiler and language services that can be utilized by editors and IDEs to provide intelligent code completion.\n\nAdditionally, there are several TypeScript-compatible transpilers available, such as Babel (via a plugin) or swc. These transpilers can be used to convert TypeScript code into other target languages or versions.\n\n### Configuration\n\nTypeScript can be configured using the tsc CLI options or by utilizing a dedicated configuration file called tsconfig.json placed in the root of the project.\n\nTo generate a tsconfig.json file prepopulated with recommended settings, you can use the following command:\n\n```shell\ntsc --init\n```\n\nWhen executing the `tsc` command locally, TypeScript will compile the code using the configuration specified in the nearest tsconfig.json file.\n\nHere are some examples of CLI commands that run with the default settings:\n\n```shell\ntsc main.ts // Compile a specific file (main.ts) to JavaScript\ntsc src/*.ts // Compile any .ts files under the 'src' folder to JavaScript\ntsc app.ts util.ts --outfile index.js // Compile two TypeScript files (app.ts and util.ts) into a single JavaScript file (index.js)\n```\n\n### TypeScript Configuration File\n\nA tsconfig.json file is used to configure the TypeScript Compiler (tsc). Usually, it is added to the root of the project, together with the `package.json` file.\n\nNotes:\n\n* tsconfig.json accepts comments even if it is in json format.\n* It is advisable to use this configuration file instead of the command-line options.\n\nAt the following link you can find the complete documentation and its schema:\n\n[https://www.typescriptlang.org/tsconfig](https://www.typescriptlang.org/tsconfig)\n\n[http://json.schemastore.org/tsconfig](http://json.schemastore.org/tsconfig)\n\nThe following represents a list of the common and useful configurations:\n\n#### target\n\nThe \"target\" property is used to specify which version of JavaScript ECMAScript version your TypeScript should emit/compile into. For modern browsers ES6 is a good option, for older browsers, ES5 is recommended.\n\n#### lib\n\nThe \"lib\" property is used to specify which library files to include at compilation time. TypeScript automatically includes APIs for features specified in the \"target\" property, but it is possible to omit or pick specific libraries for particular needs. For instance, if you are working on a server project, you could exclude the \"DOM\" library, which is useful only in a browser environment.\n\n#### strict\n\nThe \"strict\" property enables stronger guarantees and enhances type safety. It is advisable to always include this property in your project's tsconfig.json file. Enabling the \"strict\" property allows TypeScript to:\n\n* Emit code using \"use strict\" for each source file.\n* Consider \"null\" and \"undefined\" in the type checking process.\n* Disable the usage of the \"any\" type when no type annotations are present.\n* Raise an error on the usage of the \"this\" expression, which would otherwise imply the \"any\" type.\n\n#### module\n\nThe \"module\" property sets the module system supported for the compiled program. During runtime, a module loader is used to locate and execute dependencies based on the specified module system.\n\nThe most common module loaders used in JavaScript are Node.js CommonJS for server-side applications and RequireJS for AMD modules in browser-based web applications. TypeScript can emit code for various module systems, including UMD, System, ESNext, ES2015/ES6, and ES2020.\n\nNote: The module system should be chosen based on the target environment and the module loading mechanism available in that environment.\n\n#### moduleResolution\n\nThe \"moduleResolution\" property specifies the module resolution strategy. Use \"node\" for modern TypeScript code, the \"classic\" strategy is used only for old versions of TypeScript (before 1.6).\n\n#### esModuleInterop\n\nThe \"esModuleInterop\" property allows import default from CommonJS modules that did not export using the \"default\" property, this property provides a shim to ensure compatibility in the emitted JavaScript. After enabling this option we can use `import MyLibrary from \"my-library\"` instead of `import * as MyLibrary from \"my-library\"`.\n\n#### jsx\n\nThe \"jsx\" property applies only to .tsx files used in ReactJS and controls how JSX constructs are compiled into JavaScript. A common option is \"preserve\" which will compile to a .jsx file keeping unchanged the JSX so it can be passed to different tools like Babel for further transformations.\n\n#### skipLibCheck\n\nThe \"skipLibCheck'' property will prevent TypeScript from type-checking the entire imported third-party packages. This property will reduce the compile time of a project. TypeScript will still check your code against the type definitions provided by these packages.\n\n#### files\n\nThe \"files\" property indicates to the compiler a list of files that must always be included in the program.\n\n#### include\n\n<!-- markdownlint-disable MD049 -->\nThe \"include\" property indicates to the compiler a list of files that we would like to include. This property allows glob-like patterns, such as \"\\*_\" for any subdirectory, \"_\" for any file name, and \"?\" for optional characters.\n<!-- markdownlint-enable MD049 -->\n\n#### exclude\n\nThe \"exclude\" property indicates to the compiler a list of files that should not be included in the compilation. This can include files such as \"node_modules\" or test files.\nNote: tsconfig.json allows comments.\n\n### importHelpers\n\nTypeScript uses helper code when generating code for certain advanced or down-leveled JavaScript features. By default, these helpers are duplicated in files using them. The `importHelpers` option imports these helpers from the `tslib` module instead, making the JavaScript output more efficient.\n\n### Migration to TypeScript Advice\n\nFor large projects, it is recommended to adopt a gradual transition where TypeScript and JavaScript code will initially coexist. Only small projects can be migrated to TypeScript in one go.\n\nThe first step of this transition is to introduce TypeScript into the build chain process. This can be done by using the \"allowJs\" compiler option, which permits .ts and .tsx files to coexist with existing JavaScript files. As TypeScript will fall back to a type of \"any\" for a variable when it cannot infer the type from JavaScript files, it is recommended to disable \"noImplicitAny\" in your compiler options at the beginning of the migration.\n\nThe second step is to ensure that your JavaScript tests work alongside TypeScript files so that you can run tests as you convert each module. If you are using Jest, consider using `ts-jest`, which allows you to test TypeScript projects with Jest.\n\nThe third step is to include type declarations for third-party libraries in your project. These declarations can be found either bundled or on DefinitelyTyped. You can search for them using [https://www.typescriptlang.org/dt/search](https://www.typescriptlang.org/dt/search) and install them using:\n\n```shell\nnpm install --save-dev @types/package-name or yarn add --dev @types/package-name.\n```\n\nThe fourth step is to migrate module by module with a bottom-up approach, following your Dependency Graph starting with the leaves. The idea is to start converting Modules that do not depend on other Modules. To visualize the dependency graphs, you can use the \"madge\" tool.\n\nGood candidate modules for these initial conversions are utility functions and code related to external APIs or specifications. It is possible to automatically generate TypeScript type definitions from Swagger contracts, GraphQL or JSON schemas to be included in your project.\n\nWhen there are no specifications or official schemas available, you can generate types from raw data, such as JSON returned by a server. However, it is recommended to generate types from specifications instead of data to avoid missing edge cases.\n\nDuring the migration, refrain from code refactoring and focus only on adding types to your modules.\n\nThe fifth step is to enable \"noImplicitAny,\" which will enforce that all types are known and defined, providing a better TypeScript experience for your project.\n\nDuring the migration, you can use the `@ts-check` directive, which enables TypeScript type checking in a JavaScript file. This directive provides a loose version of type checking and can be initially used to identify issues in JavaScript files. When `@ts-check` is included in a file, TypeScript will try to deduce definitions using JSDoc-style comments. However, consider using JSDoc annotations only at a very early stage of the migration.\n\nConsider keeping the default value of `noEmitOnError` in your tsconfig.json as false. This will allow you to output JavaScript source code even if errors are reported.\n\n## Exploring the Type System\n\n### The TypeScript Language Service\n\nThe TypeScript Language Service, also known as tsserver, offers various features such as error reporting, diagnostics, compile-on-save, renaming, go to definition, completion lists, signature help, and more. It is primarily used by integrated development environments (IDEs) to provide IntelliSense support. It seamlessly integrates with Visual Studio Code and is utilized by tools like Conquer of Completion (Coc).\n\nDevelopers can leverage a dedicated API and create their own custom language service plugins to enhance the TypeScript editing experience. This can be particularly useful for implementing special linting features or enabling auto-completion for a custom templating language.\n\n<!-- markdownlint-disable MD044 -->\nAn example of a real-world custom plugin is \"typescript-styled-plugin\", which provides syntax error reporting and IntelliSense support for CSS properties in styled components.\n<!-- markdownlint-enable MD044 -->\n\nFor more information and quick start guides, you can refer to the official TypeScript Wiki on GitHub: [https://github.com/microsoft/TypeScript/wiki/](https://github.com/microsoft/TypeScript/wiki/)\n\n### Structural Typing\n\nTypeScript is based on a structural type system. This means that the compatibility and equivalence of types are determined by the type's actual structure or definition, rather than its name or place of declaration, as in nominative type systems like C# or C.\n\nTypeScript's structural type system was designed based on how JavaScript's dynamic duck typing system works during runtime.\n\nThe following example is valid TypeScript code. As you can observe, \"X\" and \"Y\" have the same member \"a,\" even though they have different declaration names. The types are determined by their structures, and in this case, since the structures are the same, they are compatible and valid.\n\n```typescript\ntype X = {\n    a: string;\n};\ntype Y = {\n    a: string;\n};\nconst x: X = { a: 'a' };\nconst y: Y = x; // Valid\n```\n\n### TypeScript Fundamental Comparison Rules\n\nThe TypeScript comparison process is recursive and executed on types nested at any level.\n\nA type \"X\" is compatible with \"Y\" if \"Y\" has at least the same members as \"X\".\n\n```typescript\ntype X = {\n    a: string;\n};\nconst y = { a: 'A', b: 'B' }; // Valid, as it has at least the same members as X\nconst r: X = y;\n```\n\nFunction parameters are compared by types, not by their names:\n\n```typescript\ntype X = (a: number) => void;\ntype Y = (a: number) => void;\nlet x: X = (j: number) => undefined;\nlet y: Y = (k: number) => undefined;\ny = x; // Valid\nx = y; // Valid\n```\n\nFunction return types must be the same:\n\n<!-- skip -->\n```typescript\ntype X = (a: number) => undefined;\ntype Y = (a: number) => number;\nlet x: X = (a: number) => undefined;\nlet y: Y = (a: number) => 1;\ny = x; // Invalid\nx = y; // Invalid\n```\n\nThe return type of a source function must be a subtype of the return type of a target function:\n\n<!-- skip -->\n```typescript\nlet x = () => ({ a: 'A' });\nlet y = () => ({ a: 'A', b: 'B' });\nx = y; // Valid\ny = x; // Invalid member b is missing\n```\n\nDiscarding function parameters is allowed, as it is a common practice in JavaScript, for instance using \"Array.prototype.map()\":\n\n```typescript\n[1, 2, 3].map((element, _index, _array) => element + 'x');\n```\n\nTherefore, the following type declarations are completely valid:\n\n```typescript\ntype X = (a: number) => undefined;\ntype Y = (a: number, b: number) => undefined;\nlet x: X = (a: number) => undefined;\nlet y: Y = (a: number) => undefined; // Missing b parameter\ny = x; // Valid\n```\n\nAny additional optional parameters of the source type are valid:\n\n```typescript\ntype X = (a: number, b?: number, c?: number) => undefined;\ntype Y = (a: number) => undefined;\nlet x: X = a => undefined;\nlet y: Y = a => undefined;\ny = x; // Valid\nx = y; //Valid\n```\n\nAny optional parameters of the target type without corresponding parameters in the source type are valid and not an error:\n\n```typescript\ntype X = (a: number) => undefined;\ntype Y = (a: number, b?: number) => undefined;\nlet x: X = a => undefined;\nlet y: Y = a => undefined;\ny = x; // Valid\nx = y; // Valid\n```\n\nThe rest parameter is treated as an infinite series of optional parameters:\n\n```typescript\ntype X = (a: number, ...rest: number[]) => undefined;\nlet x: X = a => undefined; //valid\n```\n\nFunctions with overloads are valid if the overload signature is compatible with its implementation signature:\n\n<!-- skip -->\n```typescript\nfunction x(a: string): void;\nfunction x(a: string, b: number): void;\nfunction x(a: string, b?: number): void {\n    console.log(a, b);\n}\nx('a'); // Valid\nx('a', 1); // Valid\n\nfunction y(a: string): void; // Invalid, not compatible with implementation signature\nfunction y(a: string, b: number): void;\nfunction y(a: string, b: number): void {\n    console.log(a, b);\n}\ny('a');\ny('a', 1);\n```\n\nFunction parameter comparison succeeds if the source and target parameters are assignable to supertypes or subtypes (bivariance).\n\n```typescript\n// Supertype\nclass X {\n    a: string;\n    constructor(value: string) {\n        this.a = value;\n    }\n}\n// Subtype\nclass Y extends X {}\n// Subtype\nclass Z extends X {}\n\ntype GetA = (x: X) => string;\nconst getA: GetA = x => x.a;\n\n// Bivariance does accept supertypes\nconsole.log(getA(new X('x'))); // Valid\nconsole.log(getA(new Y('Y'))); // Valid\nconsole.log(getA(new Z('z'))); // Valid\n```\n\nEnums are comparable and valid with numbers and vice versa, but comparing Enum values from different Enum types is invalid.\n\n<!-- skip -->\n```typescript\nenum X {\n    A,\n    B,\n}\nenum Y {\n    A,\n    B,\n    C,\n}\nconst xa: number = X.A; // Valid\nconst ya: Y = 0; // Valid\nX.A === Y.A; // Invalid\n```\n\nInstances of a class are subject to a compatibility check for their private and protected members:\n\n<!-- skip -->\n```typescript\nclass X {\n    public a: string;\n    constructor(value: string) {\n        this.a = value;\n    }\n}\n\nclass Y {\n    private a: string;\n    constructor(value: string) {\n        this.a = value;\n    }\n}\n\nlet x: X = new Y('y'); // Invalid\n```\n\nThe comparison check does not take into consideration the different inheritance hierarchy, for instance:\n\n```typescript\nclass X {\n    public a: string;\n    constructor(value: string) {\n        this.a = value;\n    }\n}\nclass Y extends X {\n    public a: string;\n    constructor(value: string) {\n        super(value);\n        this.a = value;\n    }\n}\nclass Z {\n    public a: string;\n    constructor(value: string) {\n        this.a = value;\n    }\n}\nlet x: X = new X('x');\nlet y: Y = new Y('y');\nlet z: Z = new Z('z');\nx === y; // Valid\nx === z; // Valid even if z is from a different inheritance hierarchy\n```\n\nGenerics are compared using their structures based on the resulting type after applying the generic parameter, only the final result is compared as a non-generic type.\n\n<!-- skip -->\n```typescript\ninterface X<T> {\n    a: T;\n}\nlet x: X<number> = { a: 1 };\nlet y: X<string> = { a: 'a' };\nx === y; // Invalid as the type argument is used in the final structure\n```\n\n```typescript\ninterface X<T> {}\nconst x: X<number> = 1;\nconst y: X<string> = 'a';\nx === y; // Valid as the type argument is not used in the final structure\n```\n\nWhen generics do not have their type argument specified, all the unspecified arguments are treated as types with \"any\":\n\n```typescript\ntype X = <T>(x: T) => T;\ntype Y = <K>(y: K) => K;\nlet x: X = x => x;\nlet y: Y = y => y;\nx = y; // Valid\n```\n\nRemember:\n\n<!-- skip -->\n```typescript\nlet a: number = 1;\nlet b: number = 2;\na = b; // Valid, everything is assignable to itself\n\nlet c: any;\nc = 1; // Valid, all types are assignable to any\n\nlet d: unknown;\nd = 1; // Valid, all types are assignable to unknown\n\nlet e: unknown;\nlet e1: unknown = e; // Valid, unknown is only assignable to itself and any\nlet e2: any = e; // Valid\nlet e3: number = e; // Invalid\n\nlet f: never;\nf = 1; // Invalid, nothing is assignable to never\n\nlet g: void;\nlet g1: any;\ng = 1; // Invalid, void is not assignable to or from anything expect any\ng = g1; // Valid\n```\n\nPlease note that when \"strictNullChecks\" is enabled, \"null\" and \"undefined\" are treated similarly to \"void\"; otherwise, they are similar to \"never\".\n\n### Types as Sets\n\nIn TypeScript, a type is a set of possible values. This set is also referred to as the domain of the type. Each value of a type can be viewed as an element in a set. A type establishes the constraints that every element in the set must satisfy to be considered a member of that set.\nThe primary task of TypeScript is to check and verify whether one set is a subset of another.\n\nTypeScript supports various types of sets:\n\n| Set term           | TypeScript                      | Notes                                                                                                              |\n| ------------------ | ------------------------------- | ------------------------------------------------------------------------------------------------------------------ |\n| Empty set          | never                           | \"never\" contains anything apart itself                                                                             |\n| Single element set | undefined / null / literal type |                                                                                                                    |\n| Finite set         | boolean / union                 |                                                                                                                    |\n| Infinite set       | string / number / object        |                                                                                                                    |\n| Universal set      | any / unknown                   | Every element is a member of \"any\" and every set is a subset of it / \"unknown\" is a type-safe counterpart of \"any\" |\n\nHere few examples:\n\n| TypeScript            | Set term               | Example                                                                         |\n| --------------------- | ---------------------- | ------------------------------------------------------------------------------- |\n| never                 | ∅ (empty set)          | const x: never = 'x'; // Error: Type 'string' is not assignable to type 'never' |\n|                       |                        |\n| Literal type          | Single element set     | type X = 'X';                                                                   |\n|                       |                        | type Y = 7;                                                                     |\n|                       |                        |\n| Value assignable to T | Value ∈ T (member of)  | type XY = 'X' \\| 'Y';                                                           |\n|                       |                        | const x: XY = 'X';                                                              |\n|                       |                        |\n| T1 assignable to T2   | T1 ⊆ T2 (subset of)    | type XY = 'X' \\| 'Y';                                                           |\n|                       |                        | const x: XY = 'X';                                                              |\n|                       |                        | const j: XY = 'J'; // Type '\"J\"' is not assignable to type 'XY'.                |\n|                       |                        |                                                                                 |\n| T1 extends T2         | T1 ⊆ T2 (subset of)    | type X = 'X' extends string ? true : false;                                     |\n|                       |                        |\n| T1 \\| T2              | T1 ∪ T2 (union)        | type XY = 'X' \\| 'Y';                                                           |\n|                       |                        | type JK = 1 \\| 2;                                                               |\n|                       |                        |\n| T1 & T2               | T1 ∩ T2 (intersection) | type X = \\{ a: string \\}                                                          |\n|                       |                        | type Y = \\{ b: string \\}                                                          |\n|                       |                        | type XY = X & Y                                                                 |\n|                       |                        | const x: XY = \\{ a: 'a', b: 'b' \\}                                                |\n|                       |                        |\n| unknown               | Universal set          | const x: unknown = 1                                                            |\n\nAn union, (T1 | T2) creates a wider set (both):\n\n```typescript\ntype X = {\n    a: string;\n};\ntype Y = {\n    b: string;\n};\ntype XY = X | Y;\nconst r: XY = { a: 'a', b: 'x' }; // Valid\n```\n\nAn intersection, (T1 & T2) create a narrower set (only shared):\n\n<!-- skip -->\n```typescript\ntype X = {\n    a: string;\n};\ntype Y = {\n    a: string;\n    b: string;\n};\ntype XY = X & Y;\nconst r: XY = { a: 'a' }; // Invalid\nconst j: XY = { a: 'a', b: 'b' }; // Valid\n```\n\nThe `extends` keyword could be considered as a \"subset of\" in this context. It sets a constraint for a type. The extends used with a generic, take the generic as an infinite set and it will constrain it to a more specific type.\nPlease note that `extends` has nothing to do with hierarchy in a OOP sense (there is no this concept in TypeScript).\nTypeScript works with sets and does not have a strict hierarchy, infact, as in the example below, two types could overlap without either being a subtype of the other type (TypeScript considers the structure, shape of the objects).\n\n```typescript\ninterface X {\n    a: string;\n}\ninterface Y extends X {\n    b: string;\n}\ninterface Z extends Y {\n    c: string;\n}\nconst z: Z = { a: 'a', b: 'b', c: 'c' };\ninterface X1 {\n    a: string;\n}\ninterface Y1 {\n    a: string;\n    b: string;\n}\ninterface Z1 {\n    a: string;\n    b: string;\n    c: string;\n}\nconst z1: Z1 = { a: 'a', b: 'b', c: 'c' };\n\nconst r: Z1 = z; // Valid\n```\n\n### Assign a type: Type Declarations and Type Assertions\n\nA type can be assigned in different ways in TypeScript:\n\n#### Type Declaration\n\nIn the following example, we use x: X (\": Type\") to declare a type for the variable x.\n\n```typescript\ntype X = {\n    a: string;\n};\n\n// Type declaration\nconst x: X = {\n    a: 'a',\n};\n```\n\nIf the variable is not in the specified format, TypeScript will report an error. For instance:\n\n<!-- skip -->\n```typescript\ntype X = {\n    a: string;\n};\n\nconst x: X = {\n    a: 'a',\n    b: 'b', // Error: Object literal may only specify known properties\n};\n```\n\n#### Type Assertion\n\nIt is possible to add an assertion by using the `as` keyword. This tells the compiler that the developer has more information about a type and silences any errors that may occur.\n\nFor example:\n\n```typescript\ntype X = {\n    a: string;\n};\nconst x = {\n    a: 'a',\n    b: 'b',\n} as X;\n```\n\nIn the above example, the object x is asserted to have the type X using the as keyword. This informs the TypeScript compiler that the object conforms to the specified type, even though it has an additional property b not present in the type definition.\n\nType assertions are useful in situations where a more specific type needs to be specified, especially when working with the DOM. For instance:\n\n```typescript\nconst myInput = document.getElementById('my_input') as HTMLInputElement;\n```\n\nHere, the type assertion as HTMLInputElement is used to tell TypeScript that the result of getElementById should be treated as an HTMLInputElement.\nType assertions can also be used to remap keys, as shown in the example below with template literals:\n\n```typescript\ntype J<Type> = {\n    [Property in keyof Type as `prefix_${string &\n        Property}`]: () => Type[Property];\n};\ntype X = {\n    a: string;\n    b: number;\n};\ntype Y = J<X>;\n```\n\nIn this example, the type `J<Type>` uses a mapped type with a template literal to remap the keys of Type. It creates new properties with a \"prefix_\" added to each key, and their corresponding values are functions returning the original property values.\n\nIt is worth noting that when using a type assertion, TypeScript will not execute excess property checking. Therefore, it is generally preferable to use a Type Declaration when the structure of the object is known in advance.\n\n#### Ambient Declarations\n\nAmbient declarations are files that describe types for JavaScript code, they have a file name format as `.d.ts.`. They are usually imported and used to annotate existing JavaScript libraries or to add types to existing JS files in your project.\n\nMany common libraries types can be found at:\n[https://github.com/DefinitelyTyped/DefinitelyTyped/](https://github.com/DefinitelyTyped/DefinitelyTyped/)\n\nand can be installed using:\n\n```shell\nnpm install --save-dev @types/library-name\n```\n\nFor your defined Ambient Declarations, you can import using the \"triple-slash\" reference:\n\n<!-- skip -->\n```typescript\n/// <reference path=\"./library-types.d.ts\" />\n```\n\nYou can use Ambient Declarations even within JavaScript files using `// @ts-check`.\n\nThe `declare` keyword enables type definitions for existing JavaScript code without importing it, serving as a placeholder for types from another file or globally.\n\n### Property Checking and Excess Property Checking\n\nTypeScript is based on a structural type system but excess property checking is a property of TypeScript which allows it to check whether an object has the exact properties specified in the type.\n\nExcess Property Checking is performed when assigning object literals to variables or when passing them as arguments to the function's excess property, for instance.\n\n<!-- skip -->\n```typescript\ntype X = {\n    a: string;\n};\nconst y = { a: 'a', b: 'b' };\nconst x: X = y; // Valid because structural typing\nconst w: X = { a: 'a', b: 'b' }; // Invalid because excess property checking\n```\n\n### Weak Types\n\nA type is considered weak when it contains nothing but a set of all-optional properties:\n\n```typescript\ntype X = {\n    a?: string;\n    b?: string;\n};\n```\n\nTypeScript considers an error to assign anything to a weak type when there is no overlap, for instance, the following throws an error:\n\n<!-- skip -->\n```typescript\ntype Options = {\n    a?: string;\n    b?: string;\n};\n\nconst fn = (options: Options) => undefined;\n\nfn({ c: 'c' }); // Invalid\n```\n\nAlthough not recommended, if needed, it is possible to bypass this check by using type assertion:\n\n```typescript\ntype Options = {\n    a?: string;\n    b?: string;\n};\nconst fn = (options: Options) => undefined;\nfn({ c: 'c' } as Options); // Valid\n```\n\nOr by adding `unknown` to the index signature to the weak type:\n\n```typescript\ntype Options = {\n    [prop: string]: unknown;\n    a?: string;\n    b?: string;\n};\n\nconst fn = (options: Options) => undefined;\nfn({ c: 'c' }); // Valid\n```\n\n### Strict Object Literal Checking (Freshness)\n\nStrict object literal checking, sometimes referred to as \"freshness\", is a feature in TypeScript that helps catch excess or misspelled properties that would otherwise go unnoticed in normal structural type checks.\n\nWhen creating an object literal, the TypeScript compiler considers it \"fresh.\" If the object literal is assigned to a variable or passed as a parameter, TypeScript will throw an error if the object literal specifies properties that do not exist in the target type.\n\nHowever, \"freshness\" disappears when an object literal is widened or a type assertion is used.\n\nHere are some examples to illustrate:\n\n<!-- skip -->\n```typescript\ntype X = { a: string };\ntype Y = { a: string; b: string };\n\nlet x: X;\nx = { a: 'a', b: 'b' }; // Freshness check: Invalid assignment\nvar y: Y;\ny = { a: 'a', bx: 'bx' }; // Freshness check: Invalid assignment\n\nconst fn = (x: X) => console.log(x.a);\n\nfn(x);\nfn(y); // Widening: No errors, structurally type compatible\n\nfn({ a: 'a', bx: 'b' }); // Freshness check: Invalid argument\n\nlet c: X = { a: 'a' };\nlet d: Y = { a: 'a', b: '' };\nc = d; // Widening: No Freshness check\n```\n\n### Type Inference\n\nTypeScript can infer types when no annotation is provided during:\n\n* Variable initialization.\n* Member initialization.\n* Setting defaults for parameters.\n* Function return type.\n\nFor example:\n\n```typescript\nlet x = 'x'; // The type inferred is string\n```\n\nThe TypeScript compiler analyzes the value or expression and determines its type based on the available information.\n\n### More Advanced Inferences\n\nWhen multiple expressions are used in type inference, TypeScript looks for the \"best common types.\" For instance:\n\n```typescript\nlet x = [1, 'x', 1, null]; // The type inferred is: (string | number | null)[]\n```\n\nIf the compiler cannot find the best common types, it returns a union type. For example:\n\n```typescript\nlet x = [new RegExp('x'), new Date()]; // Type inferred is: (RegExp | Date)[]\n```\n\nTypeScript utilizes \"contextual typing\" based on the variable's location to infer types. In the following example, the compiler knows that `e` is of type `MouseEvent` because of the `click` event type defined in the lib.d.ts file, which contains ambient declarations for various common JavaScript constructs and the DOM:\n\n```typescript\nwindow.addEventListener('click', function (e) {}); // The inferred type of e is MouseEvent\n```\n\n### Type Widening\n\nType widening is the process in which TypeScript assigns a type to a variable initialized when no type annotation was provided. It allows narrow to wider types but not vice versa.\nIn the following example:\n\n<!-- skip -->\n```typescript\nlet x = 'x'; // TypeScript infers as string, a wide type\nlet y: 'y' | 'x' = 'y'; // y types is a union of literal types\ny = x; // Invalid Type 'string' is not assignable to type '\"x\" | \"y\"'.\n```\n\nTypeScript assigns `string` to `x` based on the single value provided during initialization (`x`), this is an example of widening.\n\nTypeScript provides ways to have control of the widening process, for instance using \"const\".\n\n### Const\n\nUsing the `const` keyword when declaring a variable results in a narrower type inference in TypeScript.\n\nFor example:\n\n```typescript\nconst x = 'x'; // TypeScript infers the type of x as 'x', a narrower type\nlet y: 'y' | 'x' = 'y';\ny = x; // Valid: The type of x is inferred as 'x'\n```\n\nBy using `const` to declare the variable x, its type is narrowed to the specific literal value 'x'. Since the type of x is narrowed, it can be assigned to the variable y without any error.\nThe reason the type can be inferred is because `const` variables cannot be reassigned, so their type can be narrowed down to a specific literal type, in this case, the literal type 'x'.\n\n#### Const Modifier on Type Parameters\n\nFrom version 5.0 of TypeScript, it is possible to specify the `const` attribute on a generic type parameter. This allows for inferring the most precise type possible. Let's see an example without using `const`:\n\n```typescript\nfunction identity<T>(value: T) {\n    // No const here\n    return value;\n}\nconst values = identity({ a: 'a', b: 'b' }); // Type infered is: { a: string; b: string; }\n```\n\nAs you can see, the properties `a` and `b` are inferred with a type of `string`   .\n\nNow, let's see the difference with the `const` version:\n\n```typescript\nfunction identity<const T>(value: T) {\n    // Using const modifier on type parameters\n    return value;\n}\nconst values = identity({ a: 'a', b: 'b' }); // Type infered is: { a: \"a\"; b: \"b\"; }\n```\n\nNow we can see that the properties `a` and `b` are inferred as `const`, so `a` and `b` are treated as string literals rather than just `string` types.\n\n#### Const assertion\n\nThis feature allows you to declare a variable with a more precise literal type based on its initialization value, signifying to the compiler that the value should be treated as an immutable literal. Here are a few examples:\n\nOn a single property:\n\n```typescript\nconst v = {\n    x: 3 as const,\n};\nv.x = 3;\n```\n\nOn an entire object:\n\n```typescript\nconst v = {\n    x: 1,\n    y: 2,\n} as const;\n```\n\nThis can be particularly useful when defining the type for a tuple:\n\n```typescript\nconst x = [1, 2, 3]; // number[]\nconst y = [1, 2, 3] as const; // Tuple of readonly [1, 2, 3]\n```\n\n### Explicit Type Annotation\n\nWe can be specific and pass a type, in the following example property `x` is of type `number`:\n\n```typescript\nconst v = {\n    x: 1, // Inferred type: number (widening)\n};\nv.x = 3; // Valid\n```\n\nWe can make the type annotation more specific by using a union of literal types:\n\n<!-- skip -->\n```typescript\nconst v: { x: 1 | 2 | 3 } = {\n    x: 1, // x is now a union of literal types: 1 | 2 | 3\n};\nv.x = 3; // Valid\nv.x = 100; // Invalid\n```\n\n### Type Narrowing\n\nType Narrowing is the process in TypeScript where a general type is narrowed down to a more specific type. This occurs when TypeScript analyzes the code and determines that certain conditions or operations can refine the type information.\n\nNarrowing types can occur in different ways, including:\n\n#### Conditions\n\nBy using conditional statements, such as `if` or `switch`, TypeScript can narrow down the type based on the outcome of the condition. For example:\n\n```typescript\nlet x: number | undefined = 10;\n\nif (x !== undefined) {\n    x += 100; // The type is number, which had been narrowed by the condition\n}\n```\n\n#### Throwing or returning\n\nThrowing an error or returning early from a branch can be used to help TypeScript narrow down a type. For example:\n\n```typescript\nlet x: number | undefined = 10;\n\nif (x === undefined) {\n    throw 'error';\n}\nx += 100;\n```\n\nOther ways to narrow down types in TypeScript include:\n\n* `instanceof` operator: Used to check if an object is an instance of a specific class.\n* `in` operator: Used to check if a property exists in an object.\n* `typeof` operator: Used to check the type of a value at runtime.\n* Built-in functions like `Array.isArray()`: Used to check if a value is an array.\n\n#### Discriminated Union\n\nUsing a \"Discriminated Union\" is a pattern in TypeScript where an explicit \"tag\" is added to objects to distinguish between different types within a union. This pattern is also referred to as a \"tagged union.\" In the following example, the \"tag\" is represented by the property \"type\":\n\n```typescript\ntype A = { type: 'type_a'; value: number };\ntype B = { type: 'type_b'; value: string };\n\nconst x = (input: A | B): string | number => {\n    switch (input.type) {\n        case 'type_a':\n            return input.value + 100; // type is A\n        case 'type_b':\n            return input.value + 'extra'; // type is B\n    }\n};\n```\n\n#### User-Defined Type Guards\n\nIn cases where TypeScript is unable to determine a type, it is possible to write a helper function known as a \"user-defined type guard.\" In the following example, we will utilize a Type Predicate to narrow down the type after applying certain filtering:\n\n```typescript\nconst data = ['a', null, 'c', 'd', null, 'f'];\n\nconst r1 = data.filter(x => x != null); // The type is (string | null)[], TypeScript was not able to infer the type properly\n\nconst isValid = (item: string | null): item is string => item !== null; // Custom type guard\n\nconst r2 = data.filter(isValid); // The type is fine now string[], by using the predicate type guard we were able to narrow the type\n```\n\n## Primitive Types\n\nTypeScript supports 7 primitive types. A primitive data type refers to a type that is not an object and does not have any methods associated with it. In TypeScript, all primitive types are immutable, meaning their values cannot be changed once they are assigned.\n\n### string\n\nThe `string` primitive type stores textual data, and the value is always double or single-quoted.\n\n```typescript\nconst x: string = 'x';\nconst y: string = 'y';\n```\n\nStrings can span multiple lines if surrounded by the backtick (`) character:\n\n```typescript\nlet sentence: string = `xxx,\n   yyy`;\n```\n\n### boolean\n\nThe `boolean` data type in TypeScript stores a binary value, either `true` or `false`.\n\n```typescript\nconst isReady: boolean = true;\n```\n\n### number\n\nA `number` data type in TypeScript is represented with a 64-bit floating point value. A `number` type can represent integers and fractions.\nTypeScript also supports hexadecimal, binary, and octal, for instance:\n\n```typescript\nconst decimal: number = 10;\nconst hexadecimal: number = 0xa00d; // Hexadecimal starts with 0x\nconst binary: number = 0b1010; // Binary starts with 0b\nconst octal: number = 0o633; // Octal starts with 0o\n```\n\n### bigInt\n\nA `bigInt` represents numeric values that are very large (253 – 1) and cannot be represented with a `number`.\n\nA `bigInt` can be created by calling the built-in function `BigInt()` or by adding `n` to the end of any integer numeric literal:\n\n```typescript\nconst x: bigint = BigInt(9007199254740991);\nconst y: bigint = 9007199254740991n;\n```\n\nNotes:\n\n* `bigInt` values cannot be mixed with `number` and cannot be used with built-in `Math`, they must be coerced to the same type.\n* `bigInt` values are available only if target configuration is ES2020 or higher.\n\n### Symbol\n\nSymbols are unique identifiers that can be used as property keys in objects to prevent naming conflicts.\n\n```typescript\ntype Obj = {\n    [sym: symbol]: number;\n};\n\nconst a = Symbol('a');\nconst b = Symbol('b');\nlet obj: Obj = {};\nobj[a] = 123;\nobj[b] = 456;\n\nconsole.log(obj[a]); // 123\nconsole.log(obj[b]); // 456\n```\n\n### null and undefined\n\n`null` and `undefined` types both represent no value or the absence of any value.\n\nThe `undefined` type means the value is not assigned or initialized or indicates an unintentional absence of value.\n\nThe `null` type means that we know that the field does not have a value, so value is unavailable, it indicates an intentional absence of value.\n\n### Array\n\nAn `array` is a data type that can store multiple values of the same type or not. It can be defined using the following syntax:\n\n```typescript\nconst x: string[] = ['a', 'b'];\nconst y: Array<string> = ['a', 'b'];\nconst j: Array<string | number> = ['a', 1, 'b', 2]; // Union\n```\n\nTypeScript supports readonly arrays using the following syntax:\n\n<!-- skip -->\n```typescript\nconst x: readonly string[] = ['a', 'b']; // Readonly modifier\nconst y: ReadonlyArray<string> = ['a', 'b'];\nconst j: ReadonlyArray<string | number> = ['a', 1, 'b', 2];\nj.push('x'); // Invalid\n```\n\nTypeScript supports tuple and readonly tuple:\n\n```typescript\nconst x: [string, number] = ['a', 1];\nconst y: readonly [string, number] = ['a', 1];\n```\n\n### any\n\nThe `any` data type represents literally \"any\" value, it is the default value when TypeScript cannot infer the type or is not specified.\n\nWhen using `any` TypeScript compiler skips the type checking so there is no type safety when `any` is being used. Generally do not use `any` to silence the compiler when an error occurs, instead focus on fixing the error as with using `any`  it is possible to break contracts and we lose the benefits of TypeScript autocomplete.\n\nThe `any` type could be useful during a gradual migration from JavaScript to TypeScript, as it can silence the compiler.\n\nFor new projects use TypeScript configuration `noImplicitAny` which enables TypeScript to issue errors where `any` is used or inferred.\n\nThe `any`type  is usually a source of errors which can mask real problems with your types. Avoid using it as much as possible.\n\n## Type Annotations\n\nOn variables declared using `var`, `let` and `const`, it is possible to optionally add a type:\n\n```typescript\nconst x: number = 1;\n```\n\nTypeScript does a good job of inferring types, especially when simple one, so these declarations in most cases are not necessary.\n\nOn functions is possible to add type annotations to parameters:\n\n```typescript\nfunction sum(a: number, b: number) {\n    return a + b;\n}\n```\n\nThe following is an example using a anonymous functions (so called lambda function):\n\n```typescript\nconst sum = (a: number, b: number) => a + b;\n```\n\nThese annotation can be avoided when a default value for a parameter is present:\n\n```typescript\nconst sum = (a = 10, b: number) => a + b;\n```\n\nReturn type annotations can be added to functions:\n\n```typescript\nconst sum = (a = 10, b: number): number => a + b;\n```\n\nThis is useful especially for  more complex functions as writing expliciting the return type before an implementation can help better think about the function.\n\nGenerally consider annotating type signatures but not the body local variables and add types always to object literals.\n\n## Optional Properties\n\nAn object can specify Optional Properties by adding a question mark `?` to the end of the property name:\n\n```typescript\ntype X = {\n    a: number;\n    b?: number; // Optional\n};\n```\n\nIt is possible to specify a default value when a property is optional\"\n\n```typescript\ntype X = {\n    a: number;\n    b?: number;\n};\nconst x = ({ a, b = 100 }: X) => a + b;\n```\n\n## Readonly Properties\n\nIs it possible to prevent writing on a property by using the modifier `readonly`which  makes sure that the property cannot be re-written but does not provide any guarantee of total immutability:\n\n```typescript\ninterface Y {\n    readonly a: number;\n}\n\ntype X = {\n    readonly a: number;\n};\n\ntype J = Readonly<{\n    a: number;\n}>;\n\ntype K = {\n    readonly [index: number]: string;\n};\n```\n\n## Index Signatures\n\nIn TypeScript we can use as index signature `string`, `number`, and `symbol`:\n\n```typescript\ntype K = {\n    [name: string | number]: string;\n};\nconst k: K = { x: 'x', 1: 'b' };\nconsole.log(k['x']);\nconsole.log(k[1]);\nconsole.log(k['1']); // Same result as k[1]\n```\n\nPlease note that JavaScript automatically converts an index with `number` to an index with `string` so `k[1]` or `k[\"1\"]` return the same value.\n\n## Extending Types\n\nIt is possible to extend an `interface` (copy members from another type):\n\n```typescript\ninterface X {\n    a: string;\n}\ninterface Y extends X {\n    b: string;\n}\n```\n\nIt is also possible to extend from multiple types:\n\n```typescript\ninterface A {\n    a: string;\n}\ninterface B {\n    b: string;\n}\ninterface Y extends A, B {\n    y: string;\n}\n```\n\nThe `extends` keyword works only on interfaces and classes, for types use an intersection:\n\n```typescript\ntype A = {\n    a: number;\n};\ntype B = {\n    b: number;\n};\ntype C = A & B;\n```\n\nIt is possible to extend a type using an inference but not vice versa:\n\n```typescript\ntype A = {\n    a: string;\n};\ninterface B extends A {\n    b: string;\n}\n```\n\n## Literal Types\n\nA Literal Type is a single element set from a collective type, it defines a very exact value that is a JavaScript primitive.\n\nLiteral Types in TypeScript are numbers, strings, and booleans.\n\nExample of literals:\n\n```typescript\nconst a = 'a'; // String literal type\nconst b = 1; // Numeric literal type\nconst c = true; // Boolean literal type\n```\n\nString, Numeric, and Boolean Literal Types are used in the union, type guard, and type aliases.\nIn the following example you can see a type alias union, `O` can be the only value specified and not any other string:\n\n```typescript\ntype O = 'a' | 'b' | 'c';\n```\n\n## Literal Inference\n\nLiteral Inference is a feature in TypeScript that allows the type of a variable or parameter to be inferred based on its value.\n\nIn the following example we can see that TypeScript considers `x` a literal type as the value cannot be changed any time later, when instead `y` is inferred as string as it can be modified any time later.\n\n```typescript\nconst x = 'x'; // Literal type of 'x', because this value cannot be changed\nlet y = 'y'; // Type string, as we can change this value\n```\n\nIn the following example we can see that `o.x` was inferred as a `string` (and not a literal of `a`) as TypeScript considers that the value can be changed any time later.\n\n<!-- skip -->\n```typescript\ntype X = 'a' | 'b';\n\nlet o = {\n    x: 'a', // This is a wider string\n};\n\nconst fn = (x: X) => `${x}-foo`;\n\nconsole.log(fn(o.x)); // Argument of type 'string' is not assignable to parameter of type 'X'\n```\n\nAs you can see the code throws an error when passing `o.x` to `fn` as X is a narrower type.\n\nWe can solve this issue by using type assertion using `const` or the `X` type:\n\n<!-- skip -->\n```typescript\nlet o = {\n    x: 'a' as const,\n};\n```\n\nor:\n\n<!-- skip -->\n```typescript\nlet o = {\n    x: 'a' as X,\n};\n```\n\n## strictNullChecks\n\n`strictNullChecks` is a TypeScript compiler option that enforces strict null checking. When this option is enabled, variables and parameters can only be assigned `null` or `undefined` if they have been explicitly declared to be of that type using the union type `null` | `undefined`. If a variable or parameter is not explicitly declared as nullable, TypeScript will generate an error to prevent potential runtime errors.\n\n## Enums\n\nIn TypeScript, an `enum` is a set of named constant values.\n\n```typescript\nenum Color {\n    Red = '#ff0000',\n    Green = '#00ff00',\n    Blue = '#0000ff',\n}\n```\n\nEnums can be defined in different ways:\n\n### Numeric enums\n\nIn TypeScript, a Numeric Enum is an Enum where each constant is assigned a numeric value, starting from 0 by default.\n\n```typescript\nenum Size {\n    Small, // value starts from 0\n    Medium,\n    Large,\n}\n```\n\nIt is possible to specify custom values by explicitly assigning them:\n\n```typescript\nenum Size {\n    Small = 10,\n    Medium,\n    Large,\n}\nconsole.log(Size.Medium); // 11\n```\n\n### String enums\n\nIn TypeScript, a String enum is an Enum where each constant is assigned a string value.\n\n```typescript\nenum Language {\n    English = 'EN',\n    Spanish = 'ES',\n}\n```\n\nNote: TypeScript allows the usage of heterogeneous Enums where string and numeric members can coexist.\n\n### Constant enums\n\nA constant enum in TypeScript is a special type of Enum where all the values are known at compile time and are inlined wherever the enum is used, resulting in more efficient code.\n\n```typescript\nconst enum Language {\n    English = 'EN',\n    Spanish = 'ES',\n}\nconsole.log(Language.English);\n```\n\nWill be compiled into:\n\n```typescript\nconsole.log('EN' /* Language.English */);\n```\n\nNotes:\nConst Enums have hardcoded values, erasing the Enum, which can be more efficient in self-contained libraries but is generally not desirable. Also, Const enums cannot have computed members.\n\n### Reverse mapping\n\nIn TypeScript, reverse mappings in Enums refer to the ability to retrieve the Enum member name from its value. By default, Enum members have forward mappings from name to value, but reverse mappings can be created by explicitly setting values for each member. Reverse mappings are useful when you need to look up an Enum member by its value, or when you need to iterate over all the Enum members. Note that only numeric enums members will generate reverse mappings, while String Enum members do not get a reverse mapping generated at all.\n\nThe following enum:\n\n```typescript\nenum Grade {\n    A = 90,\n    B = 80,\n    C = 70,\n    F = 'fail',\n}\n```\n\nCompiles to:\n\n<!-- skip -->\n```javascript\n'use strict';\nvar Grade;\n(function (Grade) {\n    Grade[(Grade['A'] = 90)] = 'A';\n    Grade[(Grade['B'] = 80)] = 'B';\n    Grade[(Grade['C'] = 70)] = 'C';\n    Grade['F'] = 'fail';\n})(Grade || (Grade = {}));\n```\n\nTherefore, mapping values to keys works for numeric enum members, but not for string enum members:\n\n<!-- skip -->\n```typescript\nenum Grade {\n    A = 90,\n    B = 80,\n    C = 70,\n    F = 'fail',\n}\nconst myGrade = Grade.A;\nconsole.log(Grade[myGrade]); // A\nconsole.log(Grade[90]); // A\n\nconst failGrade = Grade.F;\nconsole.log(failGrade); // fail\nconsole.log(Grade[failGrade]); // Element implicitly has an 'any' type because index expression is not of type 'number'.\n```\n\n### Ambient enums\n\nAn ambient enum in TypeScript is a type of Enum that is defined in a declaration file (*.d.ts) without an associated implementation. It allows you to define a set of named constants that can be used in a type-safe way across different files without having to import the implementation details in each file.\n\n### Computed and constant members\n\nIn TypeScript, a computed member is a member of an Enum that has a value calculated at runtime, while a constant member is a member whose value is set at compile-time and cannot be changed during runtime. Computed members are allowed in regular Enums, while constant members are allowed in both regular and const enums.\n\n```typescript\n// Constant members\nenum Color {\n    Red = 1,\n    Green = 5,\n    Blue = Red + Green,\n}\nconsole.log(Color.Blue); // 6 generation at compilation time\n```\n\n```typescript\n// Computed members\nenum Color {\n    Red = 1,\n    Green = Math.pow(2, 2),\n    Blue = Math.floor(Math.random() * 3) + 1,\n}\nconsole.log(Color.Blue); // random number generated at run time\n```\n\nEnums are denoted by unions comprising their member types. The values of each member can be determined through constant or non-constant expressions, with members possessing constant values being assigned literal types. To illustrate, consider the declaration of type E and its subtypes E.A, E.B, and E.C. In this case, E represents the union E.A | E.B | E.C.\n\n```typescript\nconst identity = (value: number) => value;\n\nenum E {\n    A = 2 * 5, // Numeric literal\n    B = 'bar', // String literal\n    C = identity(42), // Opaque computed\n}\n\nconsole.log(E.C); //42\n```\n\n## Narrowing\n\nTypeScript narrowing is the process of refining the type of a variable within a conditional block. This is useful when working with union types, where a variable can have more than one type.\n\nTypeScript recognizes several ways to narrow the type:\n\n### typeof type guards\n\nThe typeof type guard is one specific type guard in TypeScript that checks the type of a variable based on its built-in JavaScript type.\n\n```typescript\nconst fn = (x: number | string) => {\n    if (typeof x === 'number') {\n        return x + 1; // x is number\n    }\n    return -1;\n};\n```\n\n### Truthiness narrowing\n\nTruthiness narrowing in TypeScript works by checking whether a variable is truthy or falsy to narrow its type accordingly.\n\n```typescript\nconst toUpperCase = (name: string | null) => {\n    if (name) {\n        return name.toUpperCase();\n    } else {\n        return null;\n    }\n};\n```\n\n### Equality narrowing\n\nEquality narrowing in TypeScript works by checking whether a variable is equal to a specific value or not, to narrow its type accordingly.\n\nIt is used in conjunction with `switch` statements and equality operators such as `===`, `!==`, `==`, and `!=` to narrow down types.\n\n```typescript\nconst checkStatus = (status: 'success' | 'error') => {\n    switch (status) {\n        case 'success':\n            return true;\n        case 'error':\n            return null;\n    }\n};\n```\n\n### In Operator narrowing\n\nThe `in` Operator narrowing in TypeScript is a way to narrow the type of a variable based on whether a property exists within the variable's type.\n\n```typescript\ntype Dog = {\n    name: string;\n    breed: string;\n};\n\ntype Cat = {\n    name: string;\n    likesCream: boolean;\n};\n\nconst getAnimalType = (pet: Dog | Cat) => {\n    if ('breed' in pet) {\n        return 'dog';\n    } else {\n        return 'cat';\n    }\n};\n```\n\n### instanceof narrowing\n\nThe `instanceof` operator narrowing in TypeScript is a way to narrow the type of a variable based on its constructor function, by checking if an object is an instance of a certain class or interface.\n\n```typescript\nclass Square {\n    constructor(public width: number) {}\n}\nclass Rectangle {\n    constructor(\n        public width: number,\n        public height: number\n    ) {}\n}\nfunction area(shape: Square | Rectangle) {\n    if (shape instanceof Square) {\n        return shape.width * shape.width;\n    } else {\n        return shape.width * shape.height;\n    }\n}\nconst square = new Square(5);\nconst rectangle = new Rectangle(5, 10);\nconsole.log(area(square)); // 25\nconsole.log(area(rectangle)); // 50\n```\n\n## Assignments\n\nTypeScript narrowing using assignments is a way to narrow the type of a variable based on the value assigned to it. When a variable is assigned a value, TypeScript infers its type based on the assigned value, and it narrows the type of the variable to match the inferred type.\n\n```typescript\nlet value: string | number;\nvalue = 'hello';\nif (typeof value === 'string') {\n    console.log(value.toUpperCase());\n}\nvalue = 42;\nif (typeof value === 'number') {\n    console.log(value.toFixed(2));\n}\n```\n\n## Control Flow Analysis\n\nControl Flow Analysis in TypeScript is a way to statically analyze the code flow to infer the types of variables, allowing the compiler to narrow the types of those variables as needed, based on the results of the analysis.\n\nPrior to TypeScript 4.4, code flow analysis would only be applied to code within an if statement, but from TypeScript 4.4, it can also be applied to conditional expressions and discriminant property accesses indirectly referenced through const variables.\n\nFor example:\n\n```typescript\nconst f1 = (x: unknown) => {\n    const isString = typeof x === 'string';\n    if (isString) {\n        x.length;\n    }\n};\n\nconst f2 = (\n    obj: { kind: 'foo'; foo: string } | { kind: 'bar'; bar: number }\n) => {\n    const isFoo = obj.kind === 'foo';\n    if (isFoo) {\n        obj.foo;\n    } else {\n        obj.bar;\n    }\n};\n```\n\nSome examples where narrowing does not occur:\n\n<!-- skip -->\n```typescript\nconst f1 = (x: unknown) => {\n    let isString = typeof x === 'string';\n    if (isString) {\n        x.length; // Error, no narrowing because isString it is not const\n    }\n};\n\nconst f6 = (\n    obj: { kind: 'foo'; foo: string } | { kind: 'bar'; bar: number }\n) => {\n    const isFoo = obj.kind === 'foo';\n    obj = obj;\n    if (isFoo) {\n        obj.foo; // Error, no narrowing because obj is assigned in function body\n    }\n};\n```\n\nNotes: Up to five levels of indirection are analyzed in conditional expressions.\n\n## Type Predicates\n\nType Predicates in TypeScript are functions that return a boolean value and are used to narrow the type of a variable to a more specific type.\n\n```typescript\nconst isString = (value: unknown): value is string => typeof value === 'string';\n\nconst foo = (bar: unknown) => {\n    if (isString(bar)) {\n        console.log(bar.toUpperCase());\n    } else {\n        console.log('not a string');\n    }\n};\n```\n\n## Discriminated Unions\n\nDiscriminated Unions in TypeScript are a type of union type that uses a common property, known as the discriminant, to narrow down the set of possible types for the union.\n\n```typescript\ntype Square = {\n    kind: 'square'; // Discriminant\n    size: number;\n};\n\ntype Circle = {\n    kind: 'circle'; // Discriminant\n    radius: number;\n};\n\ntype Shape = Square | Circle;\n\nconst area = (shape: Shape) => {\n    switch (shape.kind) {\n        case 'square':\n            return Math.pow(shape.size, 2);\n        case 'circle':\n            return Math.PI * Math.pow(shape.radius, 2);\n    }\n};\n\nconst square: Square = { kind: 'square', size: 5 };\nconst circle: Circle = { kind: 'circle', radius: 2 };\n\nconsole.log(area(square)); // 25\nconsole.log(area(circle)); // 12.566370614359172\n```\n\n## The never Type\n\nWhen a variable is narrowed to a type that cannot contain any values, the TypeScript compiler will infer that the variable must be of the `never` type. This is because The never Type represents a value that can never be produced.\n\n```typescript\nconst printValue = (val: string | number) => {\n    if (typeof val === 'string') {\n        console.log(val.toUpperCase());\n    } else if (typeof val === 'number') {\n        console.log(val.toFixed(2));\n    } else {\n        // val has type never here because it can never be anything other than a string or a number\n        const neverVal: never = val;\n        console.log(`Unexpected value: ${neverVal}`);\n    }\n};\n```\n\n## Exhaustiveness checking\n\nExhaustiveness checking is a feature in TypeScript that ensures all possible cases of a discriminated union are handled in a `switch` statement or an `if` statement.\n\n```typescript\ntype Direction = 'up' | 'down';\n\nconst move = (direction: Direction) => {\n    switch (direction) {\n        case 'up':\n            console.log('Moving up');\n            break;\n        case 'down':\n            console.log('Moving down');\n            break;\n        default:\n            const exhaustiveCheck: never = direction;\n            console.log(exhaustiveCheck); // This line will never be executed\n    }\n};\n```\n\nThe `never` type is used to ensure that the default case is exhaustive and that TypeScript will raise an error if a new value is added to the Direction type without being handled in the switch statement.\n\n## Object Types\n\nIn TypeScript, object types describe the shape of an object. They specify the names and types of the object's properties, as well as whether those properties are required or optional.\n\nIn TypeScript, you can define object types in two primary ways:\n\nInterface which defines the shape of an object by specifying the names, types, and optionality of its properties.\n\n```typescript\ninterface User {\n    name: string;\n    age: number;\n    email?: string;\n}\n```\n\nType alias, similar to an interface, defines the shape of an object. However, it can also create a new custom type that is based on an existing type or a combination of existing types. This includes defining union types, intersection types, and other complex types.\n\n```typescript\ntype Point = {\n    x: number;\n    y: number;\n};\n```\n\nIt also possible to define a type anonymously:\n\n```typescript\nconst sum = (x: { a: number; b: number }) => x.a + x.b;\nconsole.log(sum({ a: 5, b: 1 }));\n```\n\n## Tuple Type (Anonymous)\n\nA Tuple Type is a type that represents an array with a fixed number of elements and their corresponding types. A tuple type enforces a specific number of elements and their respective types in a fixed order. Tuple types are useful when you want to represent a collection of values with specific types, where the position of each element in the array has a specific meaning.\n\n```typescript\ntype Point = [number, number];\n```\n\n## Named Tuple Type (Labeled)\n\nTuple types can include optional labels or names for each element. These labels are for readability and tooling assistance, and do not affect the operations you can perform with them.\n\n```typescript\ntype T = string;\ntype Tuple1 = [T, T];\ntype Tuple2 = [a: T, b: T];\ntype Tuple3 = [a: T, T]; // Named Tuple plus Anonymous Tuple\n```\n\n## Fixed Length Tuple\n\nA Fixed Length Tuple is a specific type of tuple that enforces a fixed number of elements of specific types, and disallows any modifications to the length of the tuple once it is defined.\n\nFixed Length Tuples are useful when you need to represent a collection of values with a specific number of elements and specific types, and you want to ensure that the length and types of the tuple cannot be changed inadvertently.\n\n<!-- skip -->\n```typescript\nconst x = [10, 'hello'] as const;\nx.push(2); // Error\n```\n\n## Union Type\n\nA Union Type is a type that represents a value that can be one of several types. Union Types are denoted using the `|` symbol between each possible type.\n\n```typescript\nlet x: string | number;\nx = 'hello'; // Valid\nx = 123; // Valid\n```\n\n## Intersection Types\n\nAn Intersection Type is a type that represents a value that has all the properties of two or more types. Intersection Types are denoted using the `&` symbol between each type.\n\n```typescript\ntype X = {\n    a: string;\n};\n\ntype Y = {\n    b: string;\n};\n\ntype J = X & Y; // Intersection\n\nconst j: J = {\n    a: 'a',\n    b: 'b',\n};\n```\n\n## Type Indexing\n\nType indexing refers to the ability to define types that can be indexed by a key that is not known in advance, using an index signature to specify the type for properties that are not explicitly declared.\n\n```typescript\ntype Dictionary<T> = {\n    [key: string]: T;\n};\nconst myDict: Dictionary<string> = { a: 'a', b: 'b' };\nconsole.log(myDict['a']); // Returns a\n```\n\n## Type from Value\n\nType from Value in TypeScript refers to the automatic inference of a type from a value or expression through type inference.\n\n```typescript\nconst x = 'x'; // TypeScript can automatically infer that the type of the message variable is string\n```\n\n## Type from Func Return\n\nType from Func Return refers to the ability to automatically infer the return type of a function based on its implementation. This allows TypeScript to determine the type of the value returned by the function without explicit type annotations.\n\n```typescript\nconst add = (x: number, y: number) => x + y; // TypeScript can infer that the return type of the function is a number\n```\n\n## Type from Module\n\nType from Module refers to the ability to use a module's exported values to automatically infer their types. When a module exports a value with a specific type, TypeScript can use that information to automatically infer the type of that value when it is imported into another module.\n\n<!-- skip -->\n```typescript\n// calc.ts\nexport const add = (x: number, y: number) => x + y;\n// index.ts\nimport { add } from 'calc';\nconst r = add(1, 2); // r is number\n```\n\n## Mapped Types\n\nMapped Types in TypeScript allow you to create new types based on an existing type by transforming each property using a mapping function. By mapping existing types, you can create new types that represent the same information in a different format. To create a mapped type, you access the properties of an existing type using the `keyof` operator and then alter them to produce a new type.\nIn the following example:\n\n```typescript\ntype MyMappedType<T> = {\n    [P in keyof T]: T[P][];\n};\ntype MyType = {\n    foo: string;\n    bar: number;\n};\ntype MyNewType = MyMappedType<MyType>;\nconst x: MyNewType = {\n    foo: ['hello', 'world'],\n    bar: [1, 2, 3],\n};\n```\n\nwe define MyMappedType to map over T's properties, creating a new type with each property as an array of its original type. Using this, we create MyNewType to represent the same info as MyType, but with each property as an array.\n\n## Mapped Type Modifiers\n\nMapped Type Modifiers in TypeScript enable the transformation of properties within an existing type:\n\n* `readonly` or `+readonly`: This renders a property in the mapped type as read-only.\n* `-readonly`: This allows a property in the mapped type to be mutable.\n* `?`: This designates a property in the mapped type as optional.\n\nExamples:\n\n```typescript\ntype ReadOnly<T> = { readonly [P in keyof T]: T[P] }; // All properties marked as read-only\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] }; // All properties marked as mutable\n\ntype MyPartial<T> = { [P in keyof T]?: T[P] }; // All properties marked as optional\n```\n\n## Conditional Types\n\nConditional Types are a way to create a type that depends on a condition, where the type to be created is determined based on the result of the condition. They are defined using the `extends` keyword and a ternary operator to conditionally choose between two types.\n\n```typescript\ntype IsArray<T> = T extends any[] ? true : false;\n\nconst myArray = [1, 2, 3];\nconst myNumber = 42;\n\ntype IsMyArrayAnArray = IsArray<typeof myArray>; // Type true\ntype IsMyNumberAnArray = IsArray<typeof myNumber>; // Type false\n```\n\n## Distributive Conditional Types\n\nDistributive Conditional Types are a feature that allow a type to be distributed over a union of types, by applying a transformation to each member of the union individually.\nThis can be especially useful when working with mapped types or higher-order types.\n\n```typescript\ntype Nullable<T> = T extends any ? T | null : never;\ntype NumberOrBool = number | boolean;\ntype NullableNumberOrBool = Nullable<NumberOrBool>; // number | boolean | null\n```\n\n## infer Type Inference in Conditional Types\n\nThe `infer`keyword is used in conditional types to infer (extract) the type of a generic parameter from a type that depends on it. This allows you to write more flexible and reusable type definitions.\n\n```typescript\ntype ElementType<T> = T extends (infer U)[] ? U : never;\ntype Numbers = ElementType<number[]>; // number\ntype Strings = ElementType<string[]>; // string\n```\n\n## Predefined Conditional Types\n\nIn TypeScript, Predefined Conditional Types are built-in conditional types provided by the language. They are designed to perform common type transformations based on the characteristics of a given type.\n\n`Exclude<UnionType, ExcludedType>`: This type removes all the types from Type that are assignable to ExcludedType.\n\n`Extract<Type, Union>`: This type extracts all the types from Union that are assignable to Type.\n\n`NonNullable<Type>`: This type removes null and undefined from Type.\n\n`ReturnType<Type>`: This type extracts the return type of a function Type.\n\n`Parameters<Type>`: This type extracts the parameter types of a function Type.\n\n`Required<Type>`: This type makes all properties in Type required.\n\n`Partial<Type>`: This type makes all properties in Type optional.\n\n`Readonly<Type>`: This type makes all properties in Type readonly.\n\n## Template Union Types\n\nTemplate union types can be used to merge and manipulate text inside the type system for instance:\n\n```typescript\ntype Status = 'active' | 'inactive';\ntype Products = 'p1' | 'p2';\ntype ProductId = `id-${Products}-${Status}`; // \"id-p1-active\" | \"id-p1-inactive\" | \"id-p2-active\" | \"id-p2-inactive\"\n```\n\n## Any type\n\nThe `any` type is a special type (universal supertype) that can be used to represent any type of value (primitives, objects, arrays, functions, errors, symbols). It is often used in situations where the type of a value is not known at compile time, or when working with values from external APIs or libraries that do not have TypeScript typings.\n\nBy utilizing `any` type, you are indicating to the TypeScript compiler that values should be represented without any limitations. In order to maximizing type safety in your code consider the following:\n\n* Limit the usage of `any` to specific cases where the type is truly unknown.\n* Do not return `any` types from a function as you will lose type safety in the code using that function weakening your type safety.\n* Instead of `any` use `@ts-ignore` if you need to silence the compiler.\n\n```typescript\nlet value: any;\nvalue = true; // Valid\nvalue = 7; // Valid\n```\n\n## Unknown type\n\nIn TypeScript, the `unknown` type represents a value that is of an unknown type. Unlike `any` type, which allows for any type of value, `unknown` requires a type check or assertion before it can be used in a specific way so no operations are permitted on an `unknown` without first asserting or narrowing to a more specific type.\n\nThe `unknown` type is only assignable to any type and the `unknown` type itself, it is a type-safe alternative to `any`.\n\n<!-- skip -->\n```typescript\nlet value: unknown;\n\nlet value1: unknown = value; // Valid\nlet value2: any = value; // Valid\nlet value3: boolean = value; // Invalid\nlet value4: number = value; // Invalid\n```\n\n```typescript\nconst add = (a: unknown, b: unknown): number | undefined =>\n    typeof a === 'number' && typeof b === 'number' ? a + b : undefined;\nconsole.log(add(1, 2)); // 3\nconsole.log(add('x', 2)); // undefined\n```\n\n## Void type\n\nThe `void` type is used to indicate that a function does not return a value.\n\n```typescript\nconst sayHello = (): void => {\n    console.log('Hello!');\n};\n```\n\n## Never type\n\nThe `never` type represents values that never occur. It is used to denote functions or expressions that never return or throw an error.\n\nFor instance an infinite loop:\n\n```typescript\nconst infiniteLoop = (): never => {\n    while (true) {\n        // do something\n    }\n};\n```\n\nThrowing an error:\n\n```typescript\nconst throwError = (message: string): never => {\n    throw new Error(message);\n};\n```\n\nThe `never` type is useful in ensuring type safety and catching potential errors in your code. It helps TypeScript analyze and infer more precise types when used in combination with other types and control flow statements, for instance:\n\n```typescript\ntype Direction = 'up' | 'down';\nconst move = (direction: Direction): void => {\n    switch (direction) {\n        case 'up':\n            // move up\n            break;\n        case 'down':\n            // move down\n            break;\n        default:\n            const exhaustiveCheck: never = direction;\n            throw new Error(`Unhandled direction: ${exhaustiveCheck}`);\n    }\n};\n```\n\n## Interface and Type\n\n### Common Syntax\n\nIn TypeScript, interfaces define the structure of objects, specifying the names and types of properties or methods that an object must have. The common syntax for defining an interface in TypeScript is as follows:\n\n<!-- skip -->\n```typescript\ninterface InterfaceName {\n    property1: Type1;\n    // ...\n    method1(arg1: ArgType1, arg2: ArgType2): ReturnType;\n    // ...\n}\n```\n\nSimilarly for type definition:\n\n<!-- skip -->\n```typescript\ntype TypeName = {\n    property1: Type1;\n    // ...\n    method1(arg1: ArgType1, arg2: ArgType2): ReturnType;\n    // ...\n};\n```\n\n`interface InterfaceName` or `type TypeName`: Defines the name of the interface.\n`property1`: `Type1`: Specifies the properties of the interface along with their corresponding types. Multiple properties can be defined, each separated by a semicolon.\n`method1(arg1: ArgType1, arg2: ArgType2): ReturnType;`: Specifies the methods of the interface. Methods are defined with their names, followed by a parameter list in parentheses and the return type. Multiple methods can be defined, each separated by a semicolon.\n\nExample interface:\n\n```typescript\ninterface Person {\n    name: string;\n    age: number;\n    greet(): void;\n}\n```\n\nExample of type:\n\n```typescript\ntype TypeName = {\n    property1: string;\n    method1(arg1: string, arg2: string): string;\n};\n```\n\nIn TypeScript, types are used to define the shape of data and enforce type checking. There are several common syntaxes for defining types in TypeScript, depending on the specific use case. Here are some examples:\n\n### Basic Types\n\n```typescript\nlet myNumber: number = 123; // number type\nlet myBoolean: boolean = true; // boolean type\nlet myArray: string[] = ['a', 'b']; // array of strings\nlet myTuple: [string, number] = ['a', 123]; // tuple\n```\n\n### Objects and Interfaces\n\n```typescript\nconst x: { name: string; age: number } = { name: 'Simon', age: 7 };\n```\n\n### Union and Intersection Types\n\n```typescript\ntype MyType = string | number; // Union type\nlet myUnion: MyType = 'hello'; // Can be a string\nmyUnion = 123; // Or a number\n\ntype TypeA = { name: string };\ntype TypeB = { age: number };\ntype CombinedType = TypeA & TypeB; // Intersection type\nlet myCombined: CombinedType = { name: 'John', age: 25 }; // Object with both name and age properties\n```\n\n## Built-in Type Primitives\n\nTypeScript has several built-in type primitives that can be used to define variables, function parameters, and return types:\n\n* `number`: Represents numeric values, including integers and floating-point numbers.\n* `string`: Represents textual data\n* `boolean`: Represents logical values, which can be either true or false.\n* `null`: Represents the absence of a value.\n* `undefined`: Represents a value that has not been assigned or has not been defined.\n* `symbol`: Represents a unique identifier. Symbols are typically used as keys for object properties.\n* `bigint`: Represents arbitrary-precision integers.\n* `any`: Represents a dynamic or unknown type. Variables of type any can hold values of any type, and they bypass type checking.\n* `void`: Represents the absence of any type. It is commonly used as the return type of functions that do not return a value.\n* `never`: Represents a type for values that never occur. It is typically used as the return type of functions that throw an error or enter an infinite loop.\n\n## Common Built-in JS Objects\n\nTypeScript is a superset of JavaScript, it includes all the commonly used built-in JavaScript objects. You can find an extensive list of these objects on the Mozilla Developer Network (MDN) documentation website:\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects)\n\nHere is a list of some commonly used built-in JavaScript objects:\n\n* Function\n* Object\n* Boolean\n* Error\n* Number\n* BigInt\n* Math\n* Date\n* String\n* RegExp\n* Array\n* Map\n* Set\n* Promise\n* Intl\n\n## Overloads\n\nFunction overloads in TypeScript allow you to define multiple function signatures for a single function name, enabling you to define functions that can be called in multiple ways. Here's an example:\n\n```typescript\n// Overloads\nfunction sayHi(name: string): string;\nfunction sayHi(names: string[]): string[];\n\n// Implementation\nfunction sayHi(name: unknown): unknown {\n    if (typeof name === 'string') {\n        return `Hi, ${name}!`;\n    } else if (Array.isArray(name)) {\n        return name.map(name => `Hi, ${name}!`);\n    }\n    throw new Error('Invalid value');\n}\n\nsayHi('xx'); // Valid\nsayHi(['aa', 'bb']); // Valid\n```\n\nHere's another example of using function overloads within a `class`:\n\n```typescript\nclass Greeter {\n    message: string;\n\n    constructor(message: string) {\n        this.message = message;\n    }\n\n    // overload\n    sayHi(name: string): string;\n    sayHi(names: string[]): ReadonlyArray<string>;\n\n    // implementation\n    sayHi(name: unknown): unknown {\n        if (typeof name === 'string') {\n            return `${this.message}, ${name}!`;\n        } else if (Array.isArray(name)) {\n            return name.map(name => `${this.message}, ${name}!`);\n        }\n        throw new Error('value is invalid');\n    }\n}\nconsole.log(new Greeter('Hello').sayHi('Simon'));\n```\n\n## Merging and Extension\n\nMerging and extension refer to two different concepts related to working with types and interfaces.\n\nMerging allows you to combine multiple declarations of the same name into a single definition, for example, when you define an interface with the same name multiple times:\n\n```typescript\ninterface X {\n    a: string;\n}\n\ninterface X {\n    b: number;\n}\n\nconst person: X = {\n    a: 'a',\n    b: 7,\n};\n```\n\nExtension refers to the ability to extend or inherit from existing types or interfaces to create new ones. It is a mechanism to add additional properties or methods to an existing type without modifying its original definition. Example:\n\n```typescript\ninterface Animal {\n    name: string;\n    eat(): void;\n}\n\ninterface Bird extends Animal {\n    sing(): void;\n}\n\nconst dog: Bird = {\n    name: 'Bird 1',\n    eat() {\n        console.log('Eating');\n    },\n    sing() {\n        console.log('Singing');\n    },\n};\n```\n\n## Differences between Type and Interface\n\nDeclaration merging (augmentation):\n\nInterfaces support declaration merging, which means that you can define multiple interfaces with the same name, and TypeScript will merge them into a single interface with the combined properties and methods. On the other hand, types do not support declaration merging. This can be helpful when you want to add extra functionality or customize existing types without modifying the original definitions or patching missing or incorrect types.\n\n```typescript\ninterface A {\n    x: string;\n}\ninterface A {\n    y: string;\n}\nconst j: A = {\n    x: 'xx',\n    y: 'yy',\n};\n```\n\nExtending other types/interfaces:\n\nBoth types and interfaces can extend other types/interfaces, but the syntax is different. With interfaces, you use the `extends` keyword to inherit properties and methods from other interfaces. However, an interface cannot extend a complex type like a union type.\n\n```typescript\ninterface A {\n    x: string;\n    y: number;\n}\ninterface B extends A {\n    z: string;\n}\nconst car: B = {\n    x: 'x',\n    y: 123,\n    z: 'z',\n};\n```\n\nFor types, you use the & operator to combine multiple types into a single type (intersection).\n\n```typescript\ninterface A {\n    x: string;\n    y: number;\n}\n\ntype B = A & {\n    j: string;\n};\n\nconst c: B = {\n    x: 'x',\n    y: 123,\n    j: 'j',\n};\n```\n\nUnion and Intersection Types:\n\nTypes are more flexible when it comes to defining Union and Intersection Types. With the `type` keyword, you can easily create union types using the `|` operator and intersection types using the `&` operator. While interfaces can also represent union types indirectly, they don't have built-in support for intersection types.\n\n```typescript\ntype Department = 'dep-x' | 'dep-y'; // Union\n\ntype Person = {\n    name: string;\n    age: number;\n};\n\ntype Employee = {\n    id: number;\n    department: Department;\n};\n\ntype EmployeeInfo = Person & Employee; // Intersection\n```\n\nExample with interfaces:\n\n```typescript\ninterface A {\n    x: 'x';\n}\ninterface B {\n    y: 'y';\n}\n\ntype C = A | B; // Union of interfaces\n```\n\n## Class\n\n### Class Common Syntax\n\nThe `class` keyword is used in TypeScript to define a class. Below, you can see an example:\n\n```typescript\nclass Person {\n    private name: string;\n    private age: number;\n    constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n    }\n    public sayHi(): void {\n        console.log(\n            `Hello, my name is ${this.name} and I am ${this.age} years old.`\n        );\n    }\n}\n```\n\nThe `class` keyword is used to define a class named \"Person\".\n\nThe class has two private properties: name of type `string` and age of type `number`.\n\nThe constructor is defined using the `constructor` keyword. It takes name and age as parameters and assigns them to the corresponding properties.\n\nThe class has a `public` method named sayHi that logs a greeting message.\n\nTo create an instance of a class in TypeScript, you can use the `new` keyword followed by the class name, followed by parentheses `()`. For instance:\n\n<!-- skip -->\n```typescript\nconst myObject = new Person('John Doe', 25);\nmyObject.sayHi(); // Output: Hello, my name is John Doe and I am 25 years old.\n```\n\n### Constructor\n\nConstructors are special methods within a class that are used to initialize the object's properties when an instance of the class is created.\n\n```typescript\nclass Person {\n    public name: string;\n    public age: number;\n\n    constructor(name: string, age: number) {\n        this.name = name;\n        this.age = age;\n    }\n\n    sayHello() {\n        console.log(\n            `Hello, my name is ${this.name} and I'm ${this.age} years old.`\n        );\n    }\n}\n\nconst john = new Person('Simon', 17);\njohn.sayHello();\n```\n\nIt is possible to overload a constructor using the following syntax:\n\n```typescript\ntype Sex = 'm' | 'f';\n\nclass Person {\n    name: string;\n    age: number;\n    sex: Sex;\n\n    constructor(name: string, age: number, sex?: Sex);\n    constructor(name: string, age: number, sex: Sex) {\n        this.name = name;\n        this.age = age;\n        this.sex = sex ?? 'm';\n    }\n}\n\nconst p1 = new Person('Simon', 17);\nconst p2 = new Person('Alice', 22, 'f');\n```\n\nIn TypeScript, it is possible to define multiple constructor overloads, but you can have only one implementation that must be compatible with all the overloads, this can be achieved  by using an optional parameter.\n\n```typescript\nclass Person {\n    name: string;\n    age: number;\n\n    constructor();\n    constructor(name: string);\n    constructor(name: string, age: number);\n    constructor(name?: string, age?: number) {\n        this.name = name ?? 'Unknown';\n        this.age = age ?? 0;\n    }\n\n    displayInfo() {\n        console.log(`Name: ${this.name}, Age: ${this.age}`);\n    }\n}\n\nconst person1 = new Person();\nperson1.displayInfo(); // Name: Unknown, Age: 0\n\nconst person2 = new Person('John');\nperson2.displayInfo(); // Name: John, Age: 0\n\nconst person3 = new Person('Jane', 25);\nperson3.displayInfo(); // Name: Jane, Age: 25\n```\n\n### Private and Protected Constructors\n\nIn TypeScript, constructors can be marked as private or protected, which restricts their accessibility and usage.\n\nPrivate Constructors:\nCan be called only within the class itself. Private constructors are often used in scenarios where you want to enforce a singleton pattern or restrict the creation of instances to a factory method within the class\n\nProtected Constructors:\nProtected constructors are useful when you want to create a base class that should not be instantiated directly but can be extended by subclasses.\n\n```typescript\nclass BaseClass {\n    protected constructor() {}\n}\n\nclass DerivedClass extends BaseClass {\n    private value: number;\n\n    constructor(value: number) {\n        super();\n        this.value = value;\n    }\n}\n\n// Attempting to instantiate the base class directly will result in an error\n// const baseObj = new BaseClass(); // Error: Constructor of class 'BaseClass' is protected.\n\n// Create an instance of the derived class\nconst derivedObj = new DerivedClass(10);\n```\n\n### Access Modifiers\n\nAccess Modifiers `private`, `protected`, and `public` are used to control the visibility and accessibility of class members, such as properties and methods, in TypeScript classes. These modifiers are essential for enforcing encapsulation and establishing boundaries for accessing and modifying the internal state of a class.\n\nThe `private` modifier restricts access to the class member only within the containing class.\n\nThe `protected` modifier allows access to the class member within the containing class and its derived classes.\n\nThe `public` modifier provides unrestricted access to the class member, allowing it to be accessed from anywhere.\"\n\n### Get and Set\n\nGetters and setters are special methods that allow you to define custom access and modification behavior for class properties. They enable you to encapsulate the internal state of an object and provide additional logic when getting or setting the values of properties.\nIn TypeScript, getters and setters are defined using the `get` and `set` keywords respectively. Here's an example:\n\n```typescript\nclass MyClass {\n    private _myProperty: string;\n\n    constructor(value: string) {\n        this._myProperty = value;\n    }\n    get myProperty(): string {\n        return this._myProperty;\n    }\n    set myProperty(value: string) {\n        this._myProperty = value;\n    }\n}\n```\n\n### Auto-Accessors in Classes\n\nTypeScript version 4.9 adds support for auto-accessors, a forthcoming ECMAScript feature. They resemble class properties but are declared with the \"accessor\" keyword.\n\n```typescript\nclass Animal {\n    accessor name: string;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n```\n\nAuto-accessors are \"de-sugared\" into private `get` and `set` accessors, operating on an inaccessible property.\n\n<!-- skip -->\n```typescript\nclass Animal {\n    #__name: string;\n\n    get name() {\n        return this.#__name;\n    }\n    set name(value: string) {\n        this.#__name = name;\n    }\n\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n```\n\n### this\n\nIn TypeScript, the `this` keyword refers to the current instance of a class within its methods or constructors. It allows you to access and modify the properties and methods of the class from within its own scope.\nIt provides a way to access and manipulate the internal state of an object within its own methods.\n\n```typescript\nclass Person {\n    private name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    public introduce(): void {\n        console.log(`Hello, my name is ${this.name}.`);\n    }\n}\n\nconst person1 = new Person('Alice');\nperson1.introduce(); // Hello, my name is Alice.\n```\n\n### Parameter Properties\n\nParameter properties allow you to declare and initialize class properties directly within the constructor parameters avoiding boilerplate code, example:\n\n```typescript\nclass Person {\n    constructor(\n        private name: string,\n        public age: number\n    ) {\n        // The \"private\" and \"public\" keywords in the constructor\n        // automatically declare and initialize the corresponding class properties.\n    }\n    public introduce(): void {\n        console.log(\n            `Hello, my name is ${this.name} and I am ${this.age} years old.`\n        );\n    }\n}\nconst person = new Person('Alice', 25);\nperson.introduce();\n```\n\n### Abstract Classes\n\nAbstract Classes are used in TypeScript mainly for inheritance, they provide a way to define common properties and methods that can be inherited by subclasses.\nThis is useful when you want to define common behavior and enforce that subclasses implement certain methods. They provide a way to create a hierarchy of classes where the abstract base class provides a shared interface and common functionality for the subclasses.\n\n```typescript\nabstract class Animal {\n    protected name: string;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    abstract makeSound(): void;\n}\n\nclass Cat extends Animal {\n    makeSound(): void {\n        console.log(`${this.name} meows.`);\n    }\n}\n\nconst cat = new Cat('Whiskers');\ncat.makeSound(); // Output: Whiskers meows.\n```\n\n### With Generics\n\nClasses with generics allow you to define reusable classes which can work with different types.\n\n```typescript\nclass Container<T> {\n    private item: T;\n\n    constructor(item: T) {\n        this.item = item;\n    }\n\n    getItem(): T {\n        return this.item;\n    }\n\n    setItem(item: T): void {\n        this.item = item;\n    }\n}\n\nconst container1 = new Container<number>(42);\nconsole.log(container1.getItem()); //  42\n\nconst container2 = new Container<string>('Hello');\ncontainer2.setItem('World');\nconsole.log(container2.getItem()); // World\n```\n\n### Decorators\n\nDecorators provide a mechanism to add metadata, modify behavior, validate, or extend the functionality of the target element. They are functions that execute at runtime. Multiple decorators can be applied to a declaration.\n\nDecorators are experimental features, and the following examples are only compatible with TypeScript version 5 or above using ES6.\n\nFor TypeScript versions prior to 5, they should be enabled using the `experimentalDecorators` property in your `tsconfig.json` or by using `--experimentalDecorators` in your command line (but the following example won't work).\n\nSome of the common use cases for decorators include:\n\n* Watching property changes.\n* Watching method calls.\n* Adding extra properties or methods.\n* Runtime validation.\n* Automatic serialization and deserialization.\n* Logging.\n* Authorization and authentication.\n* Error guarding.\n\nNote: Decorators for version 5 do not allow decorating parameters.\n\nTypes of decorators:\n\n#### Class Decorators\n\nClass Decorators are useful for extending an existing class, such as adding properties or methods, or collecting instances of a class. In the following example, we add a `toString` method that converts the class into a string representation.\n\n```typescript\ntype Constructor<T = {}> = new (...args: any[]) => T;\n\nfunction toString<Class extends Constructor>(\n    Value: Class,\n    context: ClassDecoratorContext<Class>\n) {\n    return class extends Value {\n        constructor(...args: any[]) {\n            super(...args);\n            console.log(JSON.stringify(this));\n            console.log(JSON.stringify(context));\n        }\n    };\n}\n\n@toString\nclass Person {\n    name: string;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    greet() {\n        return 'Hello, ' + this.name;\n    }\n}\nconst person = new Person('Simon');\n/* Logs:\n{\"name\":\"Simon\"}\n{\"kind\":\"class\",\"name\":\"Person\"}\n*/\n```\n\n#### Property Decorator\n\nProperty decorators are useful for modifying the behavior of a property, such as changing the initialization values. In the following code, we have a script that sets a property to always be in uppercase:\n\n```typescript\nfunction upperCase<T>(\n    target: undefined,\n    context: ClassFieldDecoratorContext<T, string>\n) {\n    return function (this: T, value: string) {\n        return value.toUpperCase();\n    };\n}\n\nclass MyClass {\n    @upperCase\n    prop1 = 'hello!';\n}\n\nconsole.log(new MyClass().prop1); // Logs: HELLO!\n```\n\n#### Method Decorator\n\nMethod decorators allow you to change or enhance the behavior of methods. Below is an example of a simple logger:\n\n```typescript\nfunction log<This, Args extends any[], Return>(\n    target: (this: This, ...args: Args) => Return,\n    context: ClassMethodDecoratorContext<\n        This,\n        (this: This, ...args: Args) => Return\n    >\n) {\n    const methodName = String(context.name);\n\n    function replacementMethod(this: This, ...args: Args): Return {\n        console.log(`LOG: Entering method '${methodName}'.`);\n        const result = target.call(this, ...args);\n        console.log(`LOG: Exiting method '${methodName}'.`);\n        return result;\n    }\n\n    return replacementMethod;\n}\n\nclass MyClass {\n    @log\n    sayHello() {\n        console.log('Hello!');\n    }\n}\n\nnew MyClass().sayHello();\n```\n\nIt logs:\n\n```shell\nLOG: Entering method 'sayHello'.\nHello!\nLOG: Exiting method 'sayHello'.\n```\n\n#### Getter and Setter Decorators\n\nGetter and setter decorators allow you to change or enhance the behavior of class accessors. They are useful, for instance, for validating property assignments. Here's a simple example for a getter decorator:\n\n```typescript\nfunction range<This, Return extends number>(min: number, max: number) {\n    return function (\n        target: (this: This) => Return,\n        context: ClassGetterDecoratorContext<This, Return>\n    ) {\n        return function (this: This): Return {\n            const value = target.call(this);\n            if (value < min || value > max) {\n                throw 'Invalid';\n            }\n            Object.defineProperty(this, context.name, {\n                value,\n                enumerable: true,\n            });\n            return value;\n        };\n    };\n}\n\nclass MyClass {\n    private _value = 0;\n\n    constructor(value: number) {\n        this._value = value;\n    }\n    @range(1, 100)\n    get getValue(): number {\n        return this._value;\n    }\n}\n\nconst obj = new MyClass(10);\nconsole.log(obj.getValue); // Valid: 10\n\nconst obj2 = new MyClass(999);\nconsole.log(obj2.getValue); // Throw: Invalid!\n```\n\n#### Decorator Metadata\n\nDecorator Metadata simplifies the process for decorators to apply and utilize metadata in any class. They can access a new metadata property on the context object, which can serve as a key for both primitives and objects.\nMetadata information can be accessed on the class via `Symbol.metadata`.\n\nMetadata can be used for various purposes, such as debugging, serialization, or dependency injection with decorators.\n\n```typescript\n//@ts-ignore\nSymbol.metadata ??= Symbol('Symbol.metadata'); // Simple polify\n\ntype Context =\n    | ClassFieldDecoratorContext\n    | ClassAccessorDecoratorContext\n    | ClassMethodDecoratorContext; // Context contains property metadata: DecoratorMetadata\n\nfunction setMetadata(_target: any, context: Context) {\n    // Set the metadata object with a primitive value\n    context.metadata[context.name] = true;\n}\n\nclass MyClass {\n    @setMetadata\n    a = 123;\n\n    @setMetadata\n    accessor b = 'b';\n\n    @setMetadata\n    fn() {}\n}\n\nconst metadata = MyClass[Symbol.metadata]; // Get metadata information\n\nconsole.log(JSON.stringify(metadata)); // {\"bar\":true,\"baz\":true,\"foo\":true}\n```\n\n### Inheritance\n\nInheritance refers to the mechanism by which a class can inherit properties and methods from another class, known as the base class or superclass. The derived class, also called the child class or subclass, can extend and specialize the functionality of the base class by adding new properties and methods or overriding existing ones.\n\n```typescript\nclass Animal {\n    name: string;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    speak(): void {\n        console.log('The animal makes a sound');\n    }\n}\n\nclass Dog extends Animal {\n    breed: string;\n\n    constructor(name: string, breed: string) {\n        super(name);\n        this.breed = breed;\n    }\n\n    speak(): void {\n        console.log('Woof! Woof!');\n    }\n}\n\n// Create an instance of the base class\nconst animal = new Animal('Generic Animal');\nanimal.speak(); // The animal makes a sound\n\n// Create an instance of the derived class\nconst dog = new Dog('Max', 'Labrador');\ndog.speak(); // Woof! Woof!\"\n```\n\nTypeScript does not support multiple inheritance in the traditional sense and instead allows inheritance from a single base class.\nTypeScript supports multiple interfaces. An interface can define a contract for the structure of an object, and a class can implement multiple interfaces. This allows a class to inherit behavior and structure from multiple sources.\n\n```typescript\ninterface Flyable {\n    fly(): void;\n}\n\ninterface Swimmable {\n    swim(): void;\n}\n\nclass FlyingFish implements Flyable, Swimmable {\n    fly() {\n        console.log('Flying...');\n    }\n\n    swim() {\n        console.log('Swimming...');\n    }\n}\n\nconst flyingFish = new FlyingFish();\nflyingFish.fly();\nflyingFish.swim();\n```\n\nThe `class` keyword in TypeScript, similar to JavaScript, is often referred to as syntactic sugar. It was introduced in ECMAScript 2015 (ES6) to offer a more familiar syntax for creating and working with objects in a class-based manner. However, it's important to note that TypeScript, being a superset of JavaScript, ultimately compiles down to JavaScript, which remains prototype-based at its core.\n\n### Statics\n\nTypeScript has static members. To access the static members of a class, you can use the class name followed by a dot, without the need to create an object.\n\n```typescript\nclass OfficeWorker {\n    static memberCount: number = 0;\n\n    constructor(private name: string) {\n        OfficeWorker.memberCount++;\n    }\n}\n\nconst w1 = new OfficeWorker('James');\nconst w2 = new OfficeWorker('Simon');\nconst total = OfficeWorker.memberCount;\nconsole.log(total); // 2\n```\n\n### Property initialization\n\nThere are several ways how you can initialize properties for a class in TypeScript:\n\nInline:\n\nIn the following example these initial values will be used when an instance of the class is created.\n\n```typescript\nclass MyClass {\n    property1: string = 'default value';\n    property2: number = 42;\n}\n```\n\nIn the constructor:\n\n```typescript\nclass MyClass {\n    property1: string;\n    property2: number;\n\n    constructor() {\n        this.property1 = 'default value';\n        this.property2 = 42;\n    }\n}\n```\n\nUsing constructor parameters:\n\n```typescript\nclass MyClass {\n    constructor(\n        private property1: string = 'default value',\n        public property2: number = 42\n    ) {\n        // There is no need to assign the values to the properties explicitly.\n    }\n    log() {\n        console.log(this.property2);\n    }\n}\nconst x = new MyClass();\nx.log();\n```\n\n### Method overloading\n\nMethod overloading allows a class to have multiple methods with the same name but different parameter types or a different number of parameters. This allows us to call a method in different ways based on the arguments passed.\n\n```typescript\nclass MyClass {\n    add(a: number, b: number): number; // Overload signature 1\n    add(a: string, b: string): string; // Overload signature 2\n\n    add(a: number | string, b: number | string): number | string {\n        if (typeof a === 'number' && typeof b === 'number') {\n            return a + b;\n        }\n        if (typeof a === 'string' && typeof b === 'string') {\n            return a.concat(b);\n        }\n        throw new Error('Invalid arguments');\n    }\n}\n\nconst r = new MyClass();\nconsole.log(r.add(10, 5)); // Logs 15\n```\n\n## Generics\n\nGenerics allow you to create reusable components and functions that can work with multiple types. With generics, you can parameterize types, functions, and interfaces, allowing them to operate on different types without explicitly specifying them beforehand.\n\nGenerics allow you to make code more flexible and reusable.\n\n### Generic Type\n\nTo define a generic type, you use angle brackets (`<>`) to specify the type parameters, for instance:\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\nconst a = identity('x');\nconst b = identity(123);\n\nconst getLen = <T,>(data: ReadonlyArray<T>) => data.length;\nconst len = getLen([1, 2, 3]);\n```\n\n### Generic Classes\n\nGenerics can be applied also to classes, in this way they can work with multiple types by using type parameters. This is useful to create reusable class definitions that can operate on different data types while maintaining type safety.\n\n```typescript\nclass Container<T> {\n    private item: T;\n\n    constructor(item: T) {\n        this.item = item;\n    }\n\n    getItem(): T {\n        return this.item;\n    }\n}\n\nconst numberContainer = new Container<number>(123);\nconsole.log(numberContainer.getItem()); // 123\n\nconst stringContainer = new Container<string>('hello');\nconsole.log(stringContainer.getItem()); // hello\n```\n\n### Generic Constraints\n\nGeneric parameters can be constrained using the `extends` keyword followed by a type or interface that the type parameter must satisfy.\n\nIn the following example T it is must containing a properly `length` in order to be valid:\n\n<!-- skip -->\n```typescript\nconst printLen = <T extends { length: number }>(value: T): void => {\n    console.log(value.length);\n};\n\nprintLen('Hello'); // 5\nprintLen([1, 2, 3]); // 3\nprintLen({ length: 10 }); // 10\nprintLen(123); // Invalid\n```\n\nAn interesting feature of generic introduced in version 3.4 RC is Higher order function type inference which introduced  propagated generic type arguments:\n\n```typescript\ndeclare function pipe<A extends any[], B, C>(\n    ab: (...args: A) => B,\n    bc: (b: B) => C\n): (...args: A) => C;\n\ndeclare function list<T>(a: T): T[];\ndeclare function box<V>(x: V): { value: V };\n\nconst listBox = pipe(list, box); // <T>(a: T) => { value: T[] }\nconst boxList = pipe(box, list); // <V>(x: V) => { value: V }[]\n```\n\nThis functionality allows more easily typed safe pointfree style programming which is common in functional programming.\n\n### Generic contextual narrowing\n\nContextual narrowing for generics is the mechanism in TypeScript that allows the compiler to narrow down the type of a generic parameter based on the context in which it is used, it is useful when working with generic types in conditional statements:\n\n```typescript\nfunction process<T>(value: T): void {\n    if (typeof value === 'string') {\n        // Value is narrowed down to type 'string'\n        console.log(value.length);\n    } else if (typeof value === 'number') {\n        // Value is narrowed down to type 'number'\n        console.log(value.toFixed(2));\n    }\n}\n\nprocess('hello'); // 5\nprocess(3.14159); // 3.14\n```\n\n## Erased Structural Types\n\nIn TypeScript, objects do not have to match a specific, exact type. For instance, if we create an object that fulfills an interface's requirements, we can utilize that object in places where that interface is required, even if there was no explicit connection between them.\nExample:\n\n```typescript\ntype NameProp1 = {\n    prop1: string;\n};\n\nfunction log(x: NameProp1) {\n    console.log(x.prop1);\n}\n\nconst obj = {\n    prop2: 123,\n    prop1: 'Origin',\n};\n\nlog(obj); // Valid\n```\n\n## Namespacing\n\nIn TypeScript, namespaces are used to organize code into logical containers, preventing naming collisions and providing a way to group related code together.\nThe usage of the `export` keywords allows access to the namespace in \"outside\" modules.\n\n```typescript\nexport namespace MyNamespace {\n    export interface MyInterface1 {\n        prop1: boolean;\n    }\n    export interface MyInterface2 {\n        prop2: string;\n    }\n}\n\nconst a: MyNamespace.MyInterface1 = {\n    prop1: true,\n};\n```\n\n## Symbols\n\nSymbols are a primitive data type that represents an immutable value which is guaranteed to be globally unique throughout the lifetime of the program.\n\nSymbols can be used as keys for object properties and provide a way to create non-enumerable properties.\n\n```typescript\nconst key1: symbol = Symbol('key1');\nconst key2: symbol = Symbol('key2');\n\nconst obj = {\n    [key1]: 'value 1',\n    [key2]: 'value 2',\n};\n\nconsole.log(obj[key1]); // value 1\nconsole.log(obj[key2]); // value 2\n```\n\nIn WeakMaps and WeakSets, symbols are now permissible as keys.\n\n## Triple-Slash Directives\n\nTriple-slash directives are special comments that provide instructions to the compiler about how to process a file. These directives begin with three consecutive slashes (`///`) and are typically placed at the top of a TypeScript file and have no effects on the runtime behavior.\n\nTriple-slash directives are used to reference external dependencies, specify module loading behavior, enable/disable certain compiler features, and more. Few examples:\n\nReferencing a declaration file:\n\n<!-- skip -->\n```typescript\n/// <reference path=\"path/to/declaration/file.d.ts\" />\n```\n\nIndicate the module format:\n\n<!-- skip -->\n```typescript\n/// <amd|commonjs|system|umd|es6|es2015|none>\n```\n\nEnable compiler options, in the following example strict mode:\n\n<!-- skip -->\n```typescript\n/// <strict|noImplicitAny|noUnusedLocals|noUnusedParameters>\n```\n\n## Type Manipulation\n\n### Creating Types from Types\n\nIs it possible to create new types composing, manipulating or transforming existing types.\n\nIntersection Types (`&`):\n\nAllow you to combine multiple types into a single  type:\n\n```typescript\ntype A = { foo: number };\ntype B = { bar: string };\ntype C = A & B; // Intersection of A and B\nconst obj: C = { foo: 42, bar: 'hello' };\n```\n\nUnion Types (`|`):\n\nAllow you to define a type that can be one of several types:\n\n```typescript\ntype Result = string | number;\nconst value1: Result = 'hello';\nconst value2: Result = 42;\n```\n\nMapped Types:\n\nAllow you to transform the properties of an existing type to create new type:\n\n```typescript\ntype Mutable<T> = {\n    readonly [P in keyof T]: T[P];\n};\ntype Person = {\n    name: string;\n    age: number;\n};\ntype ImmutablePerson = Mutable<Person>; // Properties become read-only\n```\n\nConditional types:\n\nAllow you to create types based on some conditions:\n\n```typescript\ntype ExtractParam<T> = T extends (param: infer P) => any ? P : never;\ntype MyFunction = (name: string) => number;\ntype ParamType = ExtractParam<MyFunction>; // string\n```\n\n### Indexed Access Types\n\nIn TypeScript is it possible to access and manipulate  the types of properties within another type using an index, `Type[Key]`.\n\n```typescript\ntype Person = {\n    name: string;\n    age: number;\n};\n\ntype AgeType = Person['age']; // number\n```\n\n```typescript\ntype MyTuple = [string, number, boolean];\ntype MyType = MyTuple[2]; // boolean\n```\n\n### Utility Types\n\nSeveral built-in utility types can be used to manipulate types, below a list of the most common used:\n\n#### Awaited\\<T\\>\n\nConstructs a type recursively unwrap Promises.\n\n```typescript\ntype A = Awaited<Promise<string>>; // string\n```\n\n#### Partial\\<T\\>\n\nConstructs a type with all properties of T set to optional.\n\n```typescript\ntype Person = {\n    name: string;\n    age: number;\n};\n\ntype A = Partial<Person>; // { name?: string | undefined; age?: number | undefined; }\n```\n\n#### Required\\<T\\>\n\nConstructs a type with all properties of T set to required.\n\n```typescript\ntype Person = {\n    name?: string;\n    age?: number;\n};\n\ntype A = Required<Person>; // { name: string; age: number; }\n```\n\n#### Readonly\\<T\\>\n\nConstructs a type with all properties of T set to readonly.\n\n<!-- skip -->\n```typescript\ntype Person = {\n    name: string;\n    age: number;\n};\n\ntype A = Readonly<Person>;\n\nconst a: A = { name: 'Simon', age: 17 };\na.name = 'John'; // Invalid\n```\n\n#### Record\\<K, T\\>\n\nConstructs a type with a set of properties K of type T.\n\n```typescript\ntype Product = {\n    name: string;\n    price: number;\n};\n\nconst products: Record<string, Product> = {\n    apple: { name: 'Apple', price: 0.5 },\n    banana: { name: 'Banana', price: 0.25 },\n};\n\nconsole.log(products.apple); // { name: 'Apple', price: 0.5 }\n```\n\n#### Pick\\<T, K\\>\n\nConstructs a type by picking the specified properties K from T.\n\n```typescript\ntype Product = {\n    name: string;\n    price: number;\n};\n\ntype Price = Pick<Product, 'price'>; // { price: number; }\n```\n\n#### Omit\\<T, K\\>\n\nConstructs a type by omitting the specified properties K from T.\n\n```typescript\ntype Product = {\n    name: string;\n    price: number;\n};\n\ntype Name = Omit<Product, 'price'>; // { name: string; }\n```\n\n#### Exclude\\<T, U\\>\n\nConstructs a type by excluding all values of type U from T.\n\n```typescript\ntype Union = 'a' | 'b' | 'c';\ntype MyType = Exclude<Union, 'a' | 'c'>; // b\n```\n\n#### Extract\\<T, U\\>\n\nConstructs a type by extracting all values of type U from T.\n\n```typescript\ntype Union = 'a' | 'b' | 'c';\ntype MyType = Extract<Union, 'a' | 'c'>; // a | c\n```\n\n#### NonNullable\\<T\\>\n\nConstructs a type by excluding null and undefined from T.\n\n```typescript\ntype Union = 'a' | null | undefined | 'b';\ntype MyType = NonNullable<Union>; // 'a' | 'b'\n```\n\n#### Parameters\\<T\\>\n\nExtracts the parameter types of a function type T.\n\n```typescript\ntype Func = (a: string, b: number) => void;\ntype MyType = Parameters<Func>; // [a: string, b: number]\n```\n\n#### ConstructorParameters\\<T\\>\n\nExtracts the parameter types of a constructor function type T.\n\n```typescript\nclass Person {\n    constructor(\n        public name: string,\n        public age: number\n    ) {}\n}\ntype PersonConstructorParams = ConstructorParameters<typeof Person>; // [name: string, age: number]\nconst params: PersonConstructorParams = ['John', 30];\nconst person = new Person(...params);\nconsole.log(person); // Person { name: 'John', age: 30 }\n```\n\n#### ReturnType\\<T\\>\n\nExtracts the return type of a function type T.\n\n```typescript\ntype Func = (name: string) => number;\ntype MyType = ReturnType<Func>; // number\n```\n\n#### InstanceType\\<T\\>\n\nExtracts the instance type of a class type T.\n\n```typescript\nclass Person {\n    name: string;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    sayHello() {\n        console.log(`Hello, my name is ${this.name}!`);\n    }\n}\n\ntype PersonInstance = InstanceType<typeof Person>;\n\nconst person: PersonInstance = new Person('John');\n\nperson.sayHello(); // Hello, my name is John!\n```\n\n#### ThisParameterType\\<T\\>\n\nExtracts the type of 'this' parameter from a function type T.\n\n```typescript\ninterface Person {\n    name: string;\n    greet(this: Person): void;\n}\ntype PersonThisType = ThisParameterType<Person['greet']>; // Person\n```\n\n#### OmitThisParameter\\<T\\>\n\nRemoves the 'this' parameter from a function type T.\n\n```typescript\nfunction capitalize(this: String) {\n    return this[0].toUpperCase + this.substring(1).toLowerCase();\n}\n\ntype CapitalizeType = OmitThisParameter<typeof capitalize>; // () => string\n```\n\n#### ThisType\\<T\\>\n\nServers as a market for a contextual `this` type.\n\n<!-- skip -->\n```typescript\ntype Logger = {\n    log: (error: string) => void;\n};\n\nlet helperFunctions: { [name: string]: Function } & ThisType<Logger> = {\n    hello: function () {\n        this.log('some error'); // Valid as \"log\" is a part of \"this\".\n        this.update(); // Invalid\n    },\n};\n```\n\n#### Uppercase\\<T\\>\n\nMake uppercase the name of the input type T.\n\n```typescript\ntype MyType = Uppercase<'abc'>; // \"ABC\"\n```\n\n#### Lowercase\\<T\\>\n\nMake lowercase the name of the input type T.\n\n```typescript\ntype MyType = Lowercase<'ABC'>; // \"abc\"\n```\n\n#### Capitalize\\<T\\>\n\nCapitalize the name of the input type T.\n\n```typescript\ntype MyType = Capitalize<'abc'>; // \"Abc\"\n```\n\n#### Uncapitalize\\<T\\>\n\nUncapitalize the name of the input type T.\n\n```typescript\ntype MyType = Uncapitalize<'Abc'>; // \"abc\"\n```\n\n#### NoInfer\\<T\\>\n\nNoInfer is a utility type designed to block the automatic inference of types within the scope of a generic function.\n\nExample:\n\n```typescript\n// Automatic inference of types within the scope of a generic function.\nfunction fn<T extends string>(x: T[], y: T) {\n    return x.concat(y);\n}\nconst r = fn(['a', 'b'], 'c'); // Type here is (\"a\" | \"b\" | \"c\")[]\n```\n\nWith NoInfer:\n\n<!-- skip -->\n```typescript\n// Example function that uses NoInfer to prevent type inference\nfunction fn2<T extends string>(x: T[], y: NoInfer<T>) {\n    return x.concat(y);\n}\n\nconst r2 = fn2(['a', 'b'], 'c'); // Error: Type Argument of type '\"c\"' is not assignable to parameter of type '\"a\" | \"b\"'.\n```\n\n## Others\n\n### Errors and Exception Handling\n\nTypeScript allows you to catch and handle errors using standard JavaScript error handling mechanisms:\n\nTry-Catch-Finally Blocks:\n\n```typescript\ntry {\n    // Code that might throw an error\n} catch (error) {\n    // Handle the error\n} finally {\n    // Code that always executes, finally is optional\n}\n```\n\nYou can also handle different types of error:\n\n```typescript\ntry {\n    // Code that might throw different types of errors\n} catch (error) {\n    if (error instanceof TypeError) {\n        // Handle TypeError\n    } else if (error instanceof RangeError) {\n        // Handle RangeError\n    } else {\n        // Handle other errors\n    }\n}\n```\n\nCustom Error Types:\n\nIt is possible to specify more specific error by extending on the Error `class`:\n\n```typescript\nclass CustomError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = 'CustomError';\n    }\n}\n\nthrow new CustomError('This is a custom error.');\n```\n\n### Mixin classes\n\nMixin classes allow you to combine and compose behavior from multiple classes into a single class. They provide a way to reuse and extend functionality without the need for deep inheritance chains.\n\n```typescript\nabstract class Identifiable {\n    name: string = '';\n    logId() {\n        console.log('id:', this.name);\n    }\n}\nabstract class Selectable {\n    selected: boolean = false;\n    select() {\n        this.selected = true;\n        console.log('Select');\n    }\n    deselect() {\n        this.selected = false;\n        console.log('Deselect');\n    }\n}\nclass MyClass {\n    constructor() {}\n}\n\n// Extend MyClass to include the behavior of Identifiable and Selectable\ninterface MyClass extends Identifiable, Selectable {}\n\n// Function to apply mixins to a class\nfunction applyMixins(source: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            let descriptor = Object.getOwnPropertyDescriptor(\n                baseCtor.prototype,\n                name\n            );\n            if (descriptor) {\n                Object.defineProperty(source.prototype, name, descriptor);\n            }\n        });\n    });\n}\n\n// Apply the mixins to MyClass\napplyMixins(MyClass, [Identifiable, Selectable]);\nlet o = new MyClass();\no.name = 'abc';\no.logId();\no.select();\n```\n\n### Asynchronous Language Features\n\nAs TypeScript is a superset of JavaScript, it has built-in asynchronous language features of JavaScript as:\n\nPromises:\n\nPromises are a way to handle asynchronous operations and their results using methods like `.then()` and `.catch()` to handle success and error conditions.\n\nTo learn more: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)\n\nAsync/await:\n\nAsync/await keywords are a way to provide a more synchronous-looking syntax for working with Promises. The `async` keyword is used to define an asynchronous function, and the `await` keyword is used within an async function to pause execution until a Promise is resolved or rejected.\n\nTo learn more:\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)\n\nThe following API are well supported in TypeScript:\n\nFetch API:\n[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)\n\nWeb Workers:\n[https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)\n\nShared Workers:\n[https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker)\n\nWebSocket:\n[https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)\n\n### Iterators and Generators\n\nBoth Interators and Generators are well supported in TypeScript.\n\nIterators are objects that implement the iterator protocol, providing a way to access elements of a collection or sequence one by one. It is a structure that contains a pointer to the next element in the iteration. They have a `next()` method that returns the next value in the sequence along with a boolean indicating if the sequence is `done`.\n\n```typescript\nclass NumberIterator implements Iterable<number> {\n    private current: number;\n\n    constructor(\n        private start: number,\n        private end: number\n    ) {\n        this.current = start;\n    }\n\n    public next(): IteratorResult<number> {\n        if (this.current <= this.end) {\n            const value = this.current;\n            this.current++;\n            return { value, done: false };\n        } else {\n            return { value: undefined, done: true };\n        }\n    }\n\n    [Symbol.iterator](): Iterator<number> {\n        return this;\n    }\n}\n\nconst iterator = new NumberIterator(1, 3);\n\nfor (const num of iterator) {\n    console.log(num);\n}\n```\n\nGenerators are special functions defined using the `function*` syntax that simplifies the creation of iterators. They use the `yield` keyword to define the sequence of values and automatically pause and resume execution when values are requested.\n\nGenerators make it easier to create iterators and are especially useful for working with large or infinite sequences.\n\nExample:\n\n```typescript\nfunction* numberGenerator(start: number, end: number): Generator<number> {\n    for (let i = start; i <= end; i++) {\n        yield i;\n    }\n}\n\nconst generator = numberGenerator(1, 5);\n\nfor (const num of generator) {\n    console.log(num);\n}\n```\n\nTypeScript also supports async iterators and async Generators.\n\nTo learn more:\n\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator)\n\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator)\n\n### TsDocs JSDoc Reference\n\nWhen working with a JavaScript code base, it is possible to help TypeScript to infer the right Type by using JSDoc comments with additional annotation to provide type information.\n\nExample:\n\n```typescript\n/**\n * Computes the power of a given number\n * @constructor\n * @param {number} base – The base value of the expression\n * @param {number} exponent – The exponent value of the expression\n */\nfunction power(base: number, exponent: number) {\n    return Math.pow(base, exponent);\n}\npower(10, 2); // function power(base: number, exponent: number): number\n```\n\nFull documentation is provided to this link:\n[https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html)\n\nFrom version 3.7 it is possible to generate .d.ts type definitions from JavaScript JSDoc syntax.\nMore information can be found here:\n[https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html](https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html)\n\n### @types\n\nPackages under the @types organization are special package naming conventions used to provide type definitions for existing JavaScript libraries or modules. For instance using:\n\n```shell\nnpm install --save-dev @types/lodash\n```\n\nWill install the type definitions of `lodash` in your current project.\n\nTo contribute to the type definitions of @types package, please submit a pull request to [https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped).\n\n### JSX\n\nJSX (JavaScript XML) is an extension to the JavaScript language syntax that allows you to write HTML-like code within your JavaScript or TypeScript files. It is commonly used in React to define the HTML structure.\n\nTypeScript extends the capabilities of JSX by providing type checking and static analysis.\n\nTo use JSX you need to set the `jsx` compiler option in your `tsconfig.json` file. Two common configuration options:\n\n* \"preserve\": emit .jsx files with the JSX unchanged. This option tells TypeScript to keep the JSX syntax as-is and not transform it during the compilation process. You can use this option if you have a separate tool, like Babel, that handles the transformation.\n* \"react\": enables TypeScript's built-in JSX transformation. React.createElement will be used.\n\nAll options are available here:\n[https://www.typescriptlang.org/tsconfig#jsx](https://www.typescriptlang.org/tsconfig#jsx)\n\n### ES6 Modules\n\nTypeScript does support ES6 (ECMAScript 2015) and many subsequent versions. This means you can use ES6 syntax, such as arrow functions, template literals, classes, modules, destructuring, and more.\n\nTo enable ES6 features in your project, you can specify the `target` property in the tsconfig.json.\n\nA configuration example:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es6\",\n    \"module\": \"es6\",\n    \"moduleResolution\": \"node\",\n    \"sourceMap\": true,\n    \"outDir\": \"dist\"\n  },\n  \"include\": [\"src\"]\n}\n```\n\n### ES7 Exponentiation Operator\n\nThe exponentiation (`**`) operator computes the value obtained by raising the first operand to the power of the second operand. It functions similarly to `Math.pow()`, but with the added capability of accepting BigInts as operands.\nTypeScript fully supports this operator using as `target` in your tsconfig.json file `es2016` or larger version.\n\n```typescript\nconsole.log(2 ** (2 ** 2)); // 16\n```\n\n### The for-await-of Statement\n\nThis is a JavaScript feature fully supported in TypeScript which allows you to iterate over asynchronous iterable objects from target version es2018.\n\n```typescript\nasync function* asyncNumbers(): AsyncIterableIterator<number> {\n    yield Promise.resolve(1);\n    yield Promise.resolve(2);\n    yield Promise.resolve(3);\n}\n\n(async () => {\n    for await (const num of asyncNumbers()) {\n        console.log(num);\n    }\n})();\n```\n\n### New target meta-property\n\nYou can use in TypeScript the `new.target` meta-property which enables you to determine if a function or constructor was invoked using the new operator. It allows you to detect whether an object was created as a result of a constructor call.\n\n```typescript\nclass Parent {\n    constructor() {\n        console.log(new.target); // Logs the constructor function used to create an instance\n    }\n}\n\nclass Child extends Parent {\n    constructor() {\n        super();\n    }\n}\n\nconst parentX = new Parent(); // [Function: Parent]\nconst child = new Child(); // [Function: Child]\n```\n\n### Dynamic Import Expressions\n\nIt is possible to conditionally load modules or lazy load them on-demand using the ECMAScript proposal for dynamic import which is supported in TypeScript.\n\nThe syntax for dynamic import expressions in TypeScript is as follows:\n\n<!-- skip -->\n```typescript\nasync function renderWidget() {\n    const container = document.getElementById('widget');\n    if (container !== null) {\n        const widget = await import('./widget'); // Dynamic import\n        widget.render(container);\n    }\n}\n\nrenderWidget();\n```\n\n### \"tsc –watch\"\n\nThis command starts a TypeScript compiler with `--watch` parameter, with the ability to automatically recompile TypeScript files whenever they are modified.\n\n```shell\ntsc --watch\n```\n\nStarting from TypeScript version 4.9, file monitoring primarily relies on file system events, automatically resorting to polling if an event-based watcher cannot be established.\n\n### Non-null Assertion Operator\n\nThe Non-null Assertion Operator (Postfix !) also called Definite Assignment Assertions is a TypeScript feature that allows you to assert that a variable or property is not null or undefined, even if TypeScript's static type analysis suggests that it might be. With this feature it is possible to remove any explicit checking.\n\n```typescript\ntype Person = {\n    name: string;\n};\n\nconst printName = (person?: Person) => {\n    console.log(`Name is ${person!.name}`);\n};\n```\n\n### Defaulted declarations\n\nDefaulted declarations are used when a variable or parameter is assigned a default value. This means that if no value is provided for that variable or parameter, the default value will be used instead.\n\n```typescript\nfunction greet(name: string = 'Anonymous'): void {\n    console.log(`Hello, ${name}!`);\n}\ngreet(); // Hello, Anonymous!\ngreet('John'); // Hello, John!\n```\n\n### Optional Chaining\n\nThe optional chaining operator `?.` works like the regular dot operator (`.`) for accessing properties or methods. However, it gracefully handles null or undefined values by terminating the expression and returning `undefined`, instead of throwing an error.\n\n```typescript\ntype Person = {\n    name: string;\n    age?: number;\n    address?: {\n        street?: string;\n        city?: string;\n    };\n};\n\nconst person: Person = {\n    name: 'John',\n};\n\nconsole.log(person.address?.city); // undefined\n```\n\n### Nullish coalescing operator\n\nThe nullish coalescing operator `??` returns the right-hand side value if the left-hand side is `null` or `undefined`; otherwise, it returns the left-hand side value.\n\n```typescript\nconst foo = null ?? 'foo';\nconsole.log(foo); // foo\n\nconst baz = 1 ?? 'baz';\nconst baz2 = 0 ?? 'baz';\nconsole.log(baz); // 1\nconsole.log(baz2); // 0\n```\n\n### Template Literal Types\n\nTemplate Literal Types allow to manipulate string value at type level and generate new string types based on existing ones. They are useful to create more expressive and precise types from string-based operations.\n\n```typescript\ntype Department = 'engineering' | 'hr';\ntype Language = 'english' | 'spanish';\ntype Id = `${Department}-${Language}-id`; // \"engineering-english-id\" | \"engineering-spanish-id\" | \"hr-english-id\" | \"hr-spanish-id\"\n```\n\n### Function overloading\n\nFunction overloading allows you to define multiple function signatures for the same function name, each with different parameter types and return type.\nWhen you call an overloaded function, TypeScript uses the provided arguments to determine the correct function signature:\n\n```typescript\nfunction makeGreeting(name: string): string;\nfunction makeGreeting(names: string[]): string[];\n\nfunction makeGreeting(person: unknown): unknown {\n    if (typeof person === 'string') {\n        return `Hi ${person}!`;\n    } else if (Array.isArray(person)) {\n        return person.map(name => `Hi, ${name}!`);\n    }\n    throw new Error('Unable to greet');\n}\n\nmakeGreeting('Simon');\nmakeGreeting(['Simone', 'John']);\n```\n\n### Recursive Types\n\nA Recursive Type is a type that can refer to itself. This is useful for defining data structures that have a hierarchical or recursive structure (potentially infinite nesting), such as linked lists, trees, and graphs.\n\n```typescript\ntype ListNode<T> = {\n    data: T;\n    next: ListNode<T> | undefined;\n};\n```\n\n### Recursive Conditional Types\n\nIt is possible to define complex type relationships using logic and recursion in TypeScript.\nLet’s break it down in simple terms:\n\nConditional Types: allows you to define types based on boolean conditions:\n\n```typescript\ntype CheckNumber<T> = T extends number ? 'Number' : 'Not a number';\ntype A = CheckNumber<123>; // 'Number'\ntype B = CheckNumber<'abc'>; // 'Not a number'\n```\n\nRecursion: means a type definition that refers to itself within its own definition:\n\n```typescript\ntype Json = string | number | boolean | null | Json[] | { [key: string]: Json };\n\nconst data: Json = {\n    prop1: true,\n    prop2: 'prop2',\n    prop3: {\n        prop4: [],\n    },\n};\n```\n\nRecursive Conditional Types combine both conditional logic and recursion. It means that a type definition can depend on itself through conditional logic, creating complex and flexible type relationships.\n\n```typescript\ntype Flatten<T> = T extends Array<infer U> ? Flatten<U> : T;\n\ntype NestedArray = [1, [2, [3, 4], 5], 6];\ntype FlattenedArray = Flatten<NestedArray>; // 2 | 3 | 4 | 5 | 1 | 6\n```\n\n### ECMAScript Module Support in Node\n\nNode.js added support for ECMAScript Modules starting from version 15.3.0, and TypeScript has had ECMAScript Module Support for Node.js since version 4.7. This support can be enabled by using the `module` property with the value `nodenext` in the tsconfig.json file. Here's an example:\n\n```json\n{\n  \"compilerOptions\": {\n    \"module\": \"nodenext\",\n    \"outDir\": \"./lib\",\n    \"declaration\": true\n  }\n}\n```\n\nNode.js supports two file extensions for modules: `.mjs` for ES modules and `.cjs` for CommonJS modules. The equivalent file extensions in TypeScript are `.mts` for ES modules and `.cts` for CommonJS modules. When the TypeScript compiler transpiles these files to JavaScript, it will create `.mjs` and `.cjs` files.\n\nIf you want to use ES modules in your project, you can set the `type` property to \"module\" in your package.json file. This instructs Node.js to treat the project as an ES module project.\n\nAdditionally, TypeScript also supports type declarations in .d.ts files. These declaration files provide type information for libraries or modules written in TypeScript, allowing other developers to utilize them with TypeScript's type checking and auto-completion features.\n\n### Assertion Functions\n\nIn TypeScript, assertion functions are functions that indicate the verification of a specific condition based on their return value. In their simplest form, an assert function examines a provided predicate and raises an error when the predicate evaluates to false.\n\n```typescript\nfunction isNumber(value: unknown): asserts value is number {\n    if (typeof value !== 'number') {\n        throw new Error('Not a number');\n    }\n}\n```\n\nOr can be declared as function expression:\n\n```typescript\ntype AssertIsNumber = (value: unknown) => asserts value is number;\nconst isNumber: AssertIsNumber = value => {\n    if (typeof value !== 'number') {\n        throw new Error('Not a number');\n    }\n};\n```\n\nAssertion functions share similarities with type guards. Type guards were initially introduced to perform runtime checks and ensure the type of a value within a specific scope.\nSpecifically, a type guard is a function that evaluates a type predicate and returns a boolean value indicating whether the predicate is true or false. This differs slightly from assertion functions,where the intention is to throw an error rather than returning false when the predicate is not satisfied.\n\nExample of type guard:\n\n```typescript\nconst isNumber = (value: unknown): value is number => typeof value === 'number';\n```\n\n### Variadic Tuple Types\n\nVariadic Tuple Types are a features introduces in TypeScript version 4.0, let’s start to learn them by revise what is a tuple:\n\nA tuple type is an array which has a defined length, and were the type of each element is known:\n\n```typescript\ntype Student = [string, number];\nconst [name, age]: Student = ['Simone', 20];\n```\n\nThe term \"variadic\" means indefinite arity (accept a variable number of arguments).\n\nA variadic tuple is a tuple type which has all the property as before but the exact shape is not defined yet:\n\n```typescript\ntype Bar<T extends unknown[]> = [boolean, ...T, number];\n\ntype A = Bar<[boolean]>; // [boolean, boolean, number]\ntype B = Bar<['a', 'b']>; // [boolean, 'a', 'b', number]\ntype C = Bar<[]>; // [boolean, number]\n```\n\nIn the previous code we can see that the tuple shape is defined by the `T` generic passed in.\n\nVariadic tuples can accept multiple generics make them very flexible:\n\n```typescript\ntype Bar<T extends unknown[], G extends unknown[]> = [...T, boolean, ...G];\n\ntype A = Bar<[number], [string]>; // [number, boolean, string]\ntype B = Bar<['a', 'b'], [boolean]>; // [\"a\", \"b\", boolean, boolean]\n```\n\nWith the new variadic tuples we can use:\n\n* The spreads in tuple type syntax can now be generic, so we can represent higher-order operation on tuples and arrays even when we do not know the actual types we are operating over.\n* The rest elements can occur anywhere in a tuple.\n\nExample:\n\n```typescript\ntype Items = readonly unknown[];\n\nfunction concat<T extends Items, U extends Items>(\n    arr1: T,\n    arr2: U\n): [...T, ...U] {\n    return [...arr1, ...arr2];\n}\n\nconcat([1, 2, 3], ['4', '5', '6']); // [1, 2, 3, \"4\", \"5\", \"6\"]\n```\n\n### Boxed types\n\nBoxed types refer to the wrapper objects that are used to represent primitive types as objects. These wrapper objects provide additional functionality and methods that are not available directly on the primitive values.\n\nWhen you access a method like `charAt` or `normalize` on a `string` primitive, JavaScript wraps it in a `String` object, calls the method, and then throws the object away.\n\nDemonstration:\n\n```typescript\nconst originalNormalize = String.prototype.normalize;\nString.prototype.normalize = function () {\n    console.log(this, typeof this);\n    return originalNormalize.call(this);\n};\nconsole.log('\\u0041'.normalize());\n```\n\nTypeScript represents this differentiation by providing separate types for the primitives and their corresponding object wrappers:\n\n* string => String\n* number => Number\n* boolean => Boolean\n* symbol => Symbol\n* bigint => BigInt\n\nThe boxed types are usually not needed. Avoid using boxed types and instead use type for the primitives,  for instance `string` instead of `String`.\n\n### Covariance and Contravariance in TypeScript\n\nCovariance and Contravariance are used to describe how relationships work when dealing with inheritance or assignment of types.\n\nCovariance means that a type relationship preserves the direction of inheritance or assignment, so if a type A is a subtype of type B, then an array of type A is also considered a subtype of an array of type B. The important thing to note here is that the subtype relationship is maintained this means that Covariance accept subtype but doesn't accept supertype.\n\nContravariance means that a type relationship reverses the direction of inheritance or assignment, so if a type A is a subtype of type B, then an array of type B is considered a subtype of an array of type A. The subtype relationship is reversed this means that Contravariance accept supertype but doesn't accept subtype.\n\nNotes: Bivariance means accept both supertype & subtype.\n\nExample: Let's say we have a space for all animals and a separate space just for dogs.\n\nIn Covariance, you can put all the dogs in the animals space because dogs are a type of animal. But you cannot put all the animals in the dog space because there might be other animals mixed in.\n\nIn Contravariance, you cannot put all the animals in the dogs space because the animals space might contain other animals as well. However, you can put all the dogs in the animal space because all dogs are also animals.\n\n<!-- skip -->\n```typescript\n// Covariance example\nclass Animal {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n\nclass Dog extends Animal {\n    breed: string;\n    constructor(name: string, breed: string) {\n        super(name);\n        this.breed = breed;\n    }\n}\n\nlet animals: Animal[] = [];\nlet dogs: Dog[] = [];\n\n// Covariance allows assigning subtype (Dog) array to supertype (Animal) array\nanimals = dogs;\ndogs = animals; // Invalid: Type 'Animal[]' is not assignable to type 'Dog[]'\n\n// Contravariance example\ntype Feed<in T> = (animal: T) => void;\n\nlet feedAnimal: Feed<Animal> = (animal: Animal) => {\n    console.log(`Animal name: ${animal.name}`);\n};\n\nlet feedDog: Feed<Dog> = (dog: Dog) => {\n    console.log(`Dog name: ${dog.name}, Breed: ${dog.breed}`);\n};\n\n// Contravariance allows assigning supertype (Animal) callback to subtype (Dog) callback\nfeedDog = feedAnimal;\nfeedAnimal = feedDog; // Invalid: Type 'Feed<Dog>' is not assignable to type 'Feed<Animal>'.\n```\n\nIn TypeScript, type relationships for arrays are covariant, while type relationships for function parameters are contravariant. This means that TypeScript exhibits both covariance and contravariance, depending on the context.\n\n#### Optional Variance Annotations for Type Parameters\n\nAs of TypeScript 4.7.0, we can use the `out` and `in` keywords to be specific about Variance annotation.\n\nFor Covariant, use the `out` keyword:\n\n```typescript\ntype AnimalCallback<out T> = () => T; // T is Covariant here\n```\n\nAnd for Contravariant, use the `in` keyword:\n\n```typescript\ntype AnimalCallback<in T> = (value: T) => void; // T is Contravariance here\n```\n\n### Template String Pattern Index Signatures\n\nTemplate string pattern index signatures allow us to define flexible index signatures using template string patterns. This feature enables us to create objects that can be indexed with specific patterns of string keys, providing more control and specificity when accessing and manipulating properties.\n\nTypeScript from version 4.4 allows index signatures for symbols and template string patterns.\n\n```typescript\nconst uniqueSymbol = Symbol('description');\n\ntype MyKeys = `key-${string}`;\n\ntype MyObject = {\n    [uniqueSymbol]: string;\n    [key: MyKeys]: number;\n};\n\nconst obj: MyObject = {\n    [uniqueSymbol]: 'Unique symbol key',\n    'key-a': 123,\n    'key-b': 456,\n};\n\nconsole.log(obj[uniqueSymbol]); // Unique symbol key\nconsole.log(obj['key-a']); // 123\nconsole.log(obj['key-b']); // 456\n```\n\n### The satisfies Operator\n\nThe `satisfies`  allows you to check if a given type satisfies a specific interface or condition. In other words, it ensures that a type has all the required properties and methods of a specific interface. It is a way to ensure a variable fits into a definition of a type\nHere is an example:\n\n<!-- skip -->\n```typescript\ntype Columns = 'name' | 'nickName' | 'attributes';\n\ntype User = Record<Columns, string | string[] | undefined>;\n\n// Type Annotation using `User`\nconst user: User = {\n    name: 'Simone',\n    nickName: undefined,\n    attributes: ['dev', 'admin'],\n};\n\n// In the following lines, TypeScript won't be able to infer properly\nuser.attributes?.map(console.log); // Property 'map' does not exist on type 'string | string[]'. Property 'map' does not exist on type 'string'.\nuser.nickName; // string | string[] | undefined\n\n// Type assertion using `as`\nconst user2 = {\n    name: 'Simon',\n    nickName: undefined,\n    attributes: ['dev', 'admin'],\n} as User;\n\n// Here too, TypeScript won't be able to infer properly\nuser2.attributes?.map(console.log); // Property 'map' does not exist on type 'string | string[]'. Property 'map' does not exist on type 'string'.\nuser2.nickName; // string | string[] | undefined\n\n// Using `satisfies` operators we can properly infer the types now\nconst user3 = {\n    name: 'Simon',\n    nickName: undefined,\n    attributes: ['dev', 'admin'],\n} satisfies User;\n\nuser3.attributes?.map(console.log); // TypeScript infers correctly: string[]\nuser3.nickName; // TypeScript infers correctly: undefined\n```\n\n### Type-Only Imports and Export\n\nType-Only Imports and Export allows you to import or export types without importing or exporting the values or functions associated with those types. This can be useful for reducing the size of your bundle.\n\nTo use type-only imports, you can use the `import type` keyword.\n\nTypeScript permits using both declaration and implementation file extensions (.ts, .mts, .cts, and .tsx) in type-only imports, regardless of `allowImportingTsExtensions` settings.\n\nFor example:\n\n<!-- skip -->\n```typescript\nimport type { House } from './house.ts';\n```\n\nThe following are supported forms:\n\n<!-- skip -->\n```typescript\nimport type T from './mod';\nimport type { A, B } from './mod';\nimport type * as Types from './mod';\nexport type { T };\nexport type { T } from './mod';\n```\n\n### using declaration and Explicit Resource Management\n\nA `using` declaration is a block-scoped, immutable binding, similar to `const`, used for managing disposable resources. When initialized with a value, the `Symbol.dispose` method of that value is recorded and subsequently executed upon exiting the enclosing block scope.\n\nThis is based on ECMAScript's Resource Management feature, which is useful for performing essential cleanup tasks after object creation, such as closing connections, deleting files, and releasing memory.\n\nNotes:\n\n* Due to its recent introduction in TypeScript version 5.2, most runtimes lack native support. You'll need polyfills for: `Symbol.dispose`, `Symbol.asyncDispose`, `DisposableStack`, `AsyncDisposableStack`, `SuppressedError`.\n* Additionally, you will need to configure your tsconfig.json as follows:\n\n```json\n{\n    \"compilerOptions\": {\n        \"target\": \"es2022\",\n        \"lib\": [\"es2022\", \"esnext.disposable\", \"dom\"]\n    }\n}\n```\n\nExample:\n\n<!-- skip -->\n```typescript\n//@ts-ignore\nSymbol.dispose ??= Symbol('Symbol.dispose'); // Simple polify\n\nconst doWork = (): Disposable => {\n    return {\n        [Symbol.dispose]: () => {\n            console.log('disposed');\n        },\n    };\n};\n\nconsole.log(1);\n\n{\n    using work = doWork(); // Resource is declared\n    console.log(2);\n} // Resource is disposed (e.g., `work[Symbol.dispose]()` is evaluated)\n\nconsole.log(3);\n```\n\nThe code will log:\n\n```shell\n1\n2\ndisposed\n3\n```\n\nA resource eligible for disposal must adhere to the `Disposable` interface:\n\n```typescript\n// lib.esnext.disposable.d.ts\ninterface Disposable {\n    [Symbol.dispose](): void;\n}\n```\n\nThe `using` declarations record resource disposal operations in a stack, ensuring they are disposed in reverse order of declaration:\n\n<!-- skip -->\n```typescript\n{\n    using j = getA(),\n        y = getB();\n    using k = getC();\n} // disposes `C`, then `B`, then `A`.\n```\n\nResources are guaranteed to be disposed, even if subsequent code or exceptions occur. This may lead to disposal potentially throwing an exception, possibly suppressing another. To retain information on suppressed errors, a new native exception, `SuppressedError`, is introduced.\n\n#### await using declaration\n\nAn `await using` declaration handles an asynchronously disposable resource. The value must have a `Symbol.asyncDispose` method, which will be awaited at the block's end.\n\n<!-- skip -->\n```typescript\nasync function doWorkAsync() {\n    await using work = doWorkAsync(); // Resource is declared\n} // Resource is disposed (e.g., `await work[Symbol.asyncDispose]()` is evaluated)\n```\n\nFor an asynchronously disposable resource, it must adhere to either the `Disposable` or `AsyncDisposable` interface:\n\n```typescript\n// lib.esnext.disposable.d.ts\ninterface AsyncDisposable {\n    [Symbol.asyncDispose](): Promise<void>;\n}\n```\n\n<!-- skip -->\n```typescript\n//@ts-ignore\nSymbol.asyncDispose ??= Symbol('Symbol.asyncDispose'); // Simple polify\n\nclass DatabaseConnection implements AsyncDisposable {\n    // A method that is called when the object is disposed asynchronously\n    [Symbol.asyncDispose]() {\n        // Close the connection and return a promise\n        return this.close();\n    }\n\n    async close() {\n        console.log('Closing the connection...');\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        console.log('Connection closed.');\n    }\n}\n\nasync function doWork() {\n    // Create a new connection and dispose it asynchronously when it goes out of scope\n    await using connection = new DatabaseConnection(); //  Resource is declared\n    console.log('Doing some work...');\n} // Resource is disposed (e.g., `await connection[Symbol.asyncDispose]()` is evaluated)\n\ndoWork();\n```\n\nThe code logs:\n\n```shell\nDoing some work...\nClosing the connection...\nConnection closed.\n```\n\nThe `using` and `await using` declarations are allowed in Statements: `for`, `for-in`, `for-of`, `for-await-of`, `switch`.\n\n### Import Attributes\n\nTypeScript 5.3's Import Attributes (labels for imports) tell the runtime how to handle modules (JSON, etc.). This improves security by ensuring clear imports and aligns with Content Security Policy (CSP) for safer resource loading. TypeScript ensures they are valid but lets the runtime handle their interpretation for specific module handling.\n\nExample:\n\n<!-- skip -->\n```typescript\nimport config from './config.json' with { type: 'json' };\n```\n\nwith dynamic import:\n\n<!-- skip -->\n```typescript\nconst config = import('./config.json', { with: { type: 'json' } });\n```\n"
        },
        {
          "name": "downloads",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "website",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}