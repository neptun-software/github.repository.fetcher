{
  "metadata": {
    "timestamp": 1736557262003,
    "page": 132,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "swiftlang/swift",
      "stars": 67864,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.06,
          "content": "BasedOnStyle: LLVM\nAlwaysBreakTemplateDeclarations: true\n"
        },
        {
          "name": ".clang-tidy",
          "type": "blob",
          "size": 0.29,
          "content": "# See https://clang.llvm.org/extra/clang-tidy/checks/list.html\n\nChecks: '\n-*,\nllvm-*,\nmisc-*,\n-misc-const-correctness,\n-misc-unused-parameters,\n-misc-non-private-member-variables-in-classes,\n-misc-no-recursion,\n-misc-use-anonymous-namespace,\n-readability-qualified-auto,\n-llvm-qualified-auto\n'\n"
        },
        {
          "name": ".dir-locals.el",
          "type": "blob",
          "size": 1.47,
          "content": ";;; Directory Local Variables\n;;; For more information see (info \"(emacs) Directory Variables\")\n\n((nil\n  (eval let*\n        ((x (dir-locals-find-file default-directory))\n         (this-directory (if (listp x) (car x) (file-name-directory x))))\n        (unless (or (featurep 'swift-project-settings) \n                    (and (fboundp 'tramp-tramp-file-p)\n                         (tramp-tramp-file-p this-directory)))\n          (add-to-list 'load-path\n                       (concat this-directory \"utils\")\n                       :append)\n          (defvar swift-project-directory)\n          (let ((swift-project-directory this-directory))\n            (require 'swift-project-settings)))\n        (set (make-local-variable 'swift-project-directory)\n         this-directory)\n        )\n  (fill-column . 80)\n  (c-file-style . \"swift\"))\n (c++-mode\n  (whitespace-style face lines indentation:space)\n  (flycheck-clang-language-standard . \"c++14\"))\n (c-mode\n  (whitespace-style face lines indentation:space))\n (objc-mode\n  (whitespace-style face lines indentation:space))\n (prog-mode\n  (eval add-hook 'prog-mode-hook\n        (lambda nil\n          (whitespace-mode 1))\n        (not :APPEND)\n        :BUFFER-LOCAL))\n (swift-mode\n  (swift-find-executable-fn . swift-project-executable-find)\n  (swift-syntax-check-fn . swift-project-swift-syntax-check)\n  (whitespace-style face lines indentation:space)\n  (swift-basic-offset . 2)\n  (tab-always-indent . t)))\n\n\n\n;; Local Variables:\n;; eval: (whitespace-mode -1)\n;; End:\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.13,
          "content": "# editorconfig.org\n\nroot = true\n\n[*]\nindent_style = space\nindent_size = 2\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n"
        },
        {
          "name": ".flake8",
          "type": "blob",
          "size": 1.91,
          "content": "[flake8]\n\nfilename =\n    *.py,\n\n    ./benchmark/scripts/Benchmark_Driver,\n    ./benchmark/scripts/Benchmark_DTrace.in,\n    ./benchmark/scripts/Benchmark_GuardMalloc.in,\n    ./benchmark/scripts/Benchmark_QuickCheck.in,\n    ./benchmark/scripts/Benchmark_RuntimeLeaksRunner.in,\n    ./benchmark/scripts/run_smoke_bench,\n\n    ./docs/scripts/ns-html2rst,\n\n    ./test/Driver/Inputs/fake-toolchain/ld,\n\n    ./utils/80+-check,\n    ./utils/backtrace-check,\n    ./utils/build-script,\n    ./utils/check-incremental,\n    ./utils/coverage/coverage-build-db,\n    ./utils/coverage/coverage-generate-data,\n    ./utils/coverage/coverage-query-db,\n    ./utils/coverage/coverage-touch-tests,\n    ./utils/dev-scripts/blockifyasm,\n    ./utils/dev-scripts/split-cmdline,\n    ./utils/gyb,\n    ./utils/line-directive,\n    ./utils/PathSanitizingFileCheck,\n    ./utils/recursive-lipo,\n    ./utils/round-trip-syntax-test,\n    ./utils/rth,\n    ./utils/run-test,\n    ./utils/scale-test,\n    ./utils/submit-benchmark-results,\n    ./utils/swift_build_support/tests/mock-distcc,\n    ./utils/symbolicate-linux-fatal,\n    ./utils/update-checkout,\n    ./utils/viewcfg,\n\n    # TODO: We should be linting the lit configs.\n    #lit.cfg,\n\nexclude =\n    .git,\n    __pycache__,\n    .build,\n\nignore =\n    # The black tool treats slices consistently, the E203 warning is not PEP8\n    # compliant (https://github.com/psf/black#slices).\n    E203,\n\n    # Line breaks before binary operators are not explicitly disallowed in\n    # PEP8, rather it should be consistent throughout the project. The black\n    # tool puts them on new lines which is to be considered a best practice\n    # in the future.\n    W503,\n\n    # Similarly ignore line break after binary operators.\n    W504,\n\n    # TODO: Ignore Bugbear lints for now, but we should enable these in the\n    # future.\n    B,\n\n# 10% larger than the standard 80 character limit. Conforms to the black\n# standard and Bugbear's B950.\nmax-line-length = 88\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.09,
          "content": "*.swift.gyb linguist-language=Swift\n*.cpp.gyb linguist-language=C++\n*.bat text eol=crlf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 2.71,
          "content": "#==============================================================================#\n# This file specifies intentionally untracked files that git should ignore.\n# See: http://www.kernel.org/pub/software/scm/git/docs/gitignore.html\n#\n# This file is intentionally different from the output of `git svn show-ignore`,\n# as most of those are useless.\n#==============================================================================#\n\n#==============================================================================#\n# File extensions to be ignored anywhere in the tree.\n#==============================================================================#\n# Temp files created by most text editors.\n*~\n# Merge files created by git.\n*.orig\n# Byte compiled Python modules.\n*.pyc\n# vim swap files\n.*.sw[a-z]\n.sw?\n\n#==============================================================================#\n# Explicit files to ignore (only matches one).\n#==============================================================================#\nBrewfile.lock.json\ncscope.files\ncscope.out\n.vimrc\ntags\n\n#==============================================================================#\n# Directories to ignore (do not add trailing '/'s, they skip symlinks).\n#==============================================================================#\n# Generated docs\ndocs/_build\n\n# Finder metadata\n.DS_Store\n\n# Visual Studio metadata\n.vs\n\n# Visual Studio Code Configurations\n.vscode\n\n# JetBrains\n.idea\n\n# clangd\n.cache\n.clangd\n\n# SwiftPM\n.build\n.index-build\n.swiftpm\n\n#==============================================================================#\n# Ignore CMake temporary files\n#==============================================================================#\nCMakeCache.txt\nCMakeFiles\n.atom-build.json\n\n# Generated by JetBrains IDEs\ncmake-build-*\n\n#==============================================================================#\n# Ignore compile database\n#==============================================================================#\ncompile_commands.json\n\n#==============================================================================#\n# Ignore generated GYB files until we fix the workaround on Windows\n#==============================================================================#\n8\n4\nSortedCFDatabase.def\nhtmlcov\n.coverage\n/benchmark/scripts/Benchmark_Driverc\n\n#==============================================================================#\n# Ignore copied Swift Stdlib files while migrating stdlib\n#==============================================================================#\nRuntimes/**/*.swift\nRuntimes/**/*.h\nRuntimes/**/*.cpp\nRuntimes/**/*.c\nRuntimes/**/*.m\nRuntimes/**/*.mm\nRuntimes/**/*.def\nRuntimes/**/*.gyb\nRuntimes/**/*.apinotes\nRuntimes/**/*.yaml\nRuntimes/**/*.inc\nRuntimes/**/*.json\nRuntimes/**/*.modulemap\n"
        },
        {
          "name": ".mailmap",
          "type": "blob",
          "size": 8.34,
          "content": "Adrian-Constantin Popescu <epsilon.gamma@gmail.com> <adrian-constantin.popescu@outlook.com>\nAlex Blewitt <alblue@apple.com> <alex.blewitt@gmail.com>\nAlex Hoppen <ahoppen@apple.com> <alex@alexhoppen.de>\nAlex Hoppen <ahoppen@apple.com> <alex@ateamer.de>\nAlexis Beingessner <abeingessner@apple.com> <a.beingessner@gmail.com>\nAlper Çugun <github@alper.nl> <alper@users.noreply.github.com>\nAmr Aboelela <amraboelela@gmail.com> <amraboelela@users.noreply.github.com>\nAnkit Aggarwal <ankit_aggarwal@apple.com> <ankit.spd@gmail.com>\nArgyrios Kyrtzidis <kyrtzidis@apple.com> <akyrtzi@gmail.com>\nArsen Gasparyan <to.arsen.gasparyan@gmail.com> <frootloops@users.noreply.github.com>\nAshley Garland <acgarland@apple.com> <dfarler@apple.com>\nBecca Royal-Gordon <beccadax@apple.com> <becca@beccadax.com>\nBecca Royal-Gordon <beccadax@apple.com> <brent@brentdax.com>\nBecca Royal-Gordon <beccadax@apple.com> <brentdax@apple.com>\nBecca Royal-Gordon <beccadax@apple.com> <broyalgordon@apple.com>\nBen Cohen <ben_cohen@apple.com>\nBen Cohen <ben_cohen@apple.com> <airspeedswift@users.noreply.github.com>\nBen Cohen <ben_cohen@apple.com> <ben@airspeedvelocity.net>\nBen Langmuir <blangmuir@apple.com> <ben.langmuir@gmail.com>\nBrian Croom <bcroom@apple.com> <brian.s.croom@gmail.com>\nBrian Gesiak <bgesiak@fb.com> <modocache@gmail.com>\nBryan Chan <bryan.chan@ca.ibm.com> <bryanpkc@gmail.com>\nCalvin Hill <mr_j.c.h@hotmail.com> <return@users.noreply.github.com>\nChris Bieneman <beanz@apple.com>\nChris Bieneman <beanz@apple.com> <cbieneman@apple.com>\nChris Lattner <clattner@nondot.org> <clattner@apple.com>\nChris Lattner <clattner@nondot.org> <lattner@users.noreply.github.com>\nChris Lattner <clattner@nondot.org> <sabre@iMac.local>\nChris Williams <cwilliams@fitbit.com> <ultramiraculous@users.noreply.github.com>\ncodester <sahil.profile@gmail.com> codestergit <sahil.profile@gmail.com>\nDan Liew <dliew@apple.com> <36706441+danliew-apple@users.noreply.github.com>\nDaniel Duan <daniel@duan.org> <danmarner@gmail.com>\nDante Broggi <34220985+Dante-Broggi@users.noreply.github.com>\nDave <davesweeris@mac.com>\nDave Abrahams <dabrahams@apple.com> <dave@boostpro.com>\nDave Abrahams <dabrahams@apple.com> <dave@Skree.local>\nDave Abrahams <dabrahams@apple.com> <dave@Wingy.local>\nDave Lee <davelee.com@gmail.com> <davelee@lyft.com>\nDavid Rönnqvist <david.ronnqvist@gmail.com>\nDavid Rönnqvist <david.ronnqvist@gmail.com> <david.ronnqvist@skype.net>\nDavid Ungar <dungar@apple.com> <ungar@mac.com>\nDavid Zarzycki <dave@znu.io> <zarzycki@apple.com>\nDavid Zarzycki <dave@znu.io> <zarzycki@icloud.com>\nDavid Zarzycki <dave@znu.io> <zarzycki@mac.com>\nDavide Italiano <ditaliano@apple.com> <dcci@users.noreply.github.com>\nDavide Italiano <ditaliano@apple.com> <dccitaliano@gmail.com>\nDmitri Gribenko <gribozavr@gmail.com> <dgribenko@apple.com>\nDoug Coleman <doug_coleman@apple.com> <doug.coleman@gmail.com>\nEnrico Granata <egranata@apple.com> <granata.enrico@gmail.com>\nErik Eckstein <eeckstein@apple.com>\nErik Verbruggen <erik.verbruggen@me.com> <erikjv@users.noreply.github.com>\nEwa Matejska <ematejska@apple.com>\nEwa Matejska <ematejska@apple.com> <ematejska@Ewas-MacBook-Pro.local>\nEwa Matejska <ematejska@apple.com> <ewamatejska@Ewas-iMac.local>\nFlorent Bruneau <florent.bruneau@intersec.com> <florent.bruneau_github@m4x.org>\nFrancis Ricci <fjricci@fb.com> <francisjricci@gmail.com>\nGauravDS <er.gauravds@gmail.com> <gaurav.sharma@punchh.com>\nGraydon Hoare <ghoare@apple.com> <graydon@users.noreply.github.com>\nGreg Parker <gparker@apple.com> <gparker-github@sealiesoftware.com>\nGreg Titus <gregomni@gmail.com>\nGuillaume Lessard <dhtnstff@gmail.com> <glessard@users.noreply.github.com>\nHamish Knight <hamish_knight@apple.com> <hamish2knight@gmail.com>\nHamish Knight <hamish_knight@apple.com> <hamish_github@mediocremail.com>\nHan Sangjin <tinysun@jssolution.co.kr> <tinysun.net@gmail.com>\nHarlan Haskins <harlan@apple.com> <harlan@harlanhaskins.com>\nHarlan Haskins <harlan@apple.com> <hbh@google.com>\nHitster GTD <hitstergtd@users.noreply.github.com>\nHuon Wilson <huon@apple.com> <dbau.pp+github@gmail.com>\nIngmar Stein <IngmarStein@users.noreply.github.com>\nItai Ferber <iferber@apple.com> <itai@itaiferber.net>\nJacob Bandes-Storch <jacob@bandes-stor.ch> <jacob@bandes-storch.net>\nJacob Mizraji <jmizraji@apple.com> <jacobmizraji@gmail.com>\nJanosch Hildebrand <jnosh@jnosh.com> <jnosh+git@jnosh.com>\nJanosch Hildebrand <jnosh@jnosh.com> <jnosh+github@jnosh.com>\nJavier Soto <jsbustos@twitch.tv> <javier.api@gmail.com>\nJavier Soto <jsbustos@twitch.tv> <javiers@twitter.com>\nJoe <joe@iachieved.it>\nJoe <joewillsher@icloud.com>\njoe DeCapo <joe@polka.cat>\nJoe Groff <jgroff@apple.com> <arcata@gmail.com>\nJoe Shajrawi <shajrawi@apple.com> <joeshajrawi@iMac-2.local>\nJoe Shajrawi <shajrawi@apple.com> <joeshajrawi@Joes-iMac-Pro.local>\nJohannes Weiß <johannesweiss@apple.com> <github@tux4u.de>\nJohn Regner <john@johnregner.com> <regnerjr@gmail.com>\nKaroy Lorentey <klorentey@apple.com> <karoly@lorentey.hu>\nKavon Farvardin <kfarvardin@apple.com> <kavon@farvard.in>\nKeith Smiley <k@keith.so> <keithbsmiley@gmail.com>\nKevin Saldaña <ksaldana1@gmail.com>\nKim Topley <ktopley@apple.com>\nKosuke Ogawa <ogawa_kousuke@aratana.jp> <koogawa.app@gmail.com>\nKuba Mracek <mracek@apple.com>\nKuba Mracek <mracek@apple.com> <jbrecka@apple.com>\nLily Ballard <lily@sb.org> <kevin.ballard@postmates.com>\nLily Ballard <lily@sb.org> <kevin@sb.org>\nLuiz Fernando Silva <luizinho_mack@yahoo.com.br>\nLuqman Aden <luqman@apple.com> <luqman_aden@apple.com>\nMarcelo Fabri <me@marcelofabri.com> <marcelofabri@users.noreply.github.com>\nMark Lacey <mark.lacey@apple.com> <rudkx@icloud.com>\nMark Lacey <mark.lacey@apple.com> <rudkx@users.noreply.github.com>\nMatt Rajca <matt.rajca@me.com> <mattrajca@users.noreply.github.com>\nMax Moiseev <moiseev@apple.com>\nMax Moiseev <moiseev@apple.com> <maxim.moiseev@gmail.com>\nMax Moiseev <moiseev@apple.com> <moiseev@users.noreply.github.com>\nMaxwell Swadling <maxs@apple.com> <maxwellswadling@gmail.com>\nMaxwell Swadling <maxs@apple.com> <mswadling@apple.com>\nMayur Raiturkar <mayur@mayur.xyz> <mayurkr@users.noreply.github.com>\nMegan Batty <megan@stormbrew.ca> <graham.batty@apple.com>\nMichael Gottesman <mgottesman@apple.com> <gottesmm@users.noreply.github.com>\nMichael Ilseman <milseman@apple.com> <michael.ilseman@gmail.com>\nMike Ash <mikeash@apple.com> <mike@mikeash.com>\nMike Ferris <mferris@apple.com> <mike@lorax.com>\nMishal Awadah <mawadah@apple.com>\nMishal Shah <mishal_shah@apple.com>\nMishal Shah <mishal_shah@apple.com> <shahmishal@users.noreply.github.com>\nNadav Rotem <nrotem@apple.com> <nadavrot@users.noreply.github.com>\nNate Cook <natecook@apple.com> <nate@Nates-MacBook-Pro.local>\nNate Cook <natecook@apple.com> <natecook1000@users.noreply.github.com>\nNate Cook <natecook@apple.com> <natecook@gmail.com>\nNate Cook <natecook@apple.com> <nmersethcook@apple.com>\nNathan Lanza <lanza@fb.com> <nathan@lanza.io>\nNicole Jacque <jacque@apple.com>\nNiels Andriesse <andriesseniels@gmail.com> <nielsandriesse@users.noreply.github.com>\nPaul Meng <mno2@mno2.org> <mno2.csie@gmail.com>\nPavel Yaskevich <pyaskevich@apple.com> <xedin@apache.org>\nPaweł Szot <pszot@pgs-soft.com>\nPaweł Szot <pszot@pgs-soft.com> <qwertyszot@gmail.com>\nPete Cooper <peter_cooper@apple.com>\nPhilip Ridgeway <pridgeway@vernier.com> <philip.ridgeway@gmail.com>\nRichard Wei <rxwei@apple.com> <rxwei@google.com>\nRintaro Ishizaki <rishizaki@apple.com> <fs.output@gmail.com>\nRobert Widmann <rwidmann@apple.com> <devteam.codafi@gmail.com>\nRoman Levenstein <rlevenstein@apple.com> <swiftix@users.noreply.github.com>\nRoss Bayer <ross.m.bayer@gmail.com>\nRoss Bayer <ross.m.bayer@gmail.com> <Rostepher@users.noreply.github.com>\nRuss Bishop <rbishopjr@apple.com> <russ@plangrid.com>\nRyan Lovelett <ryan@lovelett.me> <RLovelett@users.noreply.github.com>\nShawn Erickson <shawn.erickson@citrix.com> <shawnce@gmail.com>\nSlava Pestov <spestov@apple.com> <sviatoslav.pestov@gmail.com>\nStephen Canon <scanon@apple.com>\nStephen Canon <scanon@apple.com> <stephentyrone@gmail.com>\nSukolsak Sakshuwong <sukolsak@gmail.com>\nTodd Fiala <tfiala@apple.com> <todd.fiala@gmail.com>\nToni Suter <tonisuter@me.com> <tonisuter@users.noreply.github.com>\nVedant Kumar <vsk@apple.com> <vk@vedantk.com>\nXin Tong <xin_tong@apple.com> <trent.xin.tong@gmail.com>\nXin Tong <xin_tong@apple.com> <trentxintong@Xins-MacBook-Pro.local>\nYuka Ezura <ezura@users.noreply.github.com> <2020337+ezura@users.noreply.github.com>\nYurii Samsoniuk <ura@google.com> <mr.sigito@gmail.com>\nZac Bowling <zbowling@google.com> <zac@zacbowling.com>\n"
        },
        {
          "name": "Brewfile",
          "type": "blob",
          "size": 0.04,
          "content": "brew \"cmake\"\nbrew \"ninja\"\nbrew \"sccache\"\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 374.9,
          "content": "# CHANGELOG\n\n> [!NOTE]\n> This is in reverse chronological order, so newer entries are added to the top.\n\n## Swift 6.1\n\n* Projected value initializers are now correctly injected into calls when\n  an argument exactly matches a parameter with an external property wrapper.\n\n  For example:\n\n  ```swift\n  struct Binding {\n    ...\n\tinit(projectedValue: Self) { ... }\n  }\n\n  func checkValue(@Binding value: Int) {}\n\n  func use(v: Binding<Int>) {\n    checkValue($value: v)\n\t// Transformed into: `checkValue(value: Binding(projectedValue: v))`\n  }\n  ```\n\n  Previous versions of the Swift compiler incorrectly omitted projected value\n  initializer injection in the call to `checkValue` because the argument type\n  matched the parameter type exactly.\n\n* [SE-0444][]:\n  When the upcoming feature `MemberImportVisibility` is enabled, Swift will\n  require that a module be directly imported in a source file when resolving\n  member declarations from that module:\n  \n  ```swift\n  let recipe = \"2 slices of bread, 1.5 tbs peanut butter\".parse()\n  // error: instance method 'parse()' is inaccessible due to missing import of\n  //        defining module 'RecipeKit'\n  // note:  add import of module 'RecipeKit'\n  ```\n  \n  This new behavior prevents ambiguities from arising when a transitively\n  imported module declares a member that conflicts with a member of a directly\n  imported module.\n\n* Syntactic SourceKit queries no longer attempt to provide information\n  within the inactive `#if` regions. For example, given:\n\n  ```swift\n  #if DEBUG\n  extension MyType: CustomDebugStringConvertible {\n    var debugDescription: String { ... }\n  }\n  #endif\n  ```\n\n  If `DEBUG` is not set, SourceKit results will not involve the\n  inactive code. Clients should use either SourceKit-LSP or\n  swift-syntax for syntactic queries that are independent of the\n  specific build configuration.\n\n* [SE-0442][]:\n  TaskGroups can now be created without explicitly specifying their child task's result types:\n\n  Previously the child task type would have to be specified explicitly when creating the task group:\n\n  ```swift\n  await withTaskGroup(of: Int.self) { group in \n    group.addTask { 12 }\n\n    return await group.next()\n  } \n  ```\n\n  Now the type is inferred based on the first use of the task group within the task group's body:\n\n  ```swift\n  await withTaskGroup { group in \n    group.addTask { 12 }\n\n    return await group.next()\n  } \n  ```\n\n\n## Swift 6.0\n\n### 2024-09-17 (Xcode 16.0)\n\n* Swift 6 comes with a new language mode that prevents the risk of data races\n  at compile time. This guarantee is accomplished through _data isolation_; the\n  compiler will validate that data passed over a boundary between concurrently\n  executing code is either safe to reference concurrently, or mutually\n  exclusive access to the value is enforced.\n\n  The data-race safety checks were previously available in Swift 5.10 through\n  the `-strict-concurrency=complete` compiler flag. Complete concurrency\n  checking in Swift 5.10 was overly restrictive, and Swift 6 removes many\n  false-positive data-race warnings through better `Sendable` inference,\n  new analysis that proves mutually exclusive access when passing values with\n  non-`Sendable` type over isolation boundaries, and more.\n\n  You can enable the Swift 6 language mode using the `-swift-version 6`\n  compiler flag.\n\n* [SE-0428][]:\n  Distributed actors now have the ability to support complete split server / \n  client systems, thanks to the new `@Resolvable` macro and runtime changes.\n\n  It is now possible to share an \"API module\" between a client and server \n  application, declare a resolvable distributed actor protocol with the expected \n  API contract and perform calls on it, without knowing the specific type the \n  server is implementing those actors as. \n\n  Declaring such protocol looks like this:\n\n```swift\nimport Distributed \n\n@Resolvable\nprotocol Greeter where ActorSystem: DistributedActorSystem<any Codable> {\n  distributed func greet(name: String) -> String\n}\n```\n\nAnd the module structure to support such applications looks like this:\n\n```\n                         ┌────────────────────────────────────────┐\n                         │                API Module              │\n                         │========================================│\n                         │ @Resolvable                            │\n                         │ protocol Greeter: DistributedActor {   │\n                 ┌───────┤   distributed func greet(name: String) ├───────┐\n                 │       │ }                                      │       │\n                 │       └────────────────────────────────────────┘       │\n                 │                                                        │\n                 ▼                                                        ▼   \n┌────────────────────────────────────────────────┐      ┌──────────────────────────────────────────────┐\n│             Client Module                      │      │               Server Module                  │\n│================================================│      │==============================================│\n│ let g = try $Greeter.resolve(...) /*new*/      │      │ distributed actor EnglishGreeter: Greeter {  │\n│ try await greeter.hello(name: ...)             │      │   distributed func greet(name: String) {     │\n└────────────────────────────────────────────────┘      │     \"Greeting in english, for \\(name)!\"      │\n/* Client cannot know about EnglishGreeter type */      │   }                                          │      \n                                                        │ }                                            │\n                                                        └──────────────────────────────────────────────┘\n```\n\n* [SE-0424][]:\n  Serial executor gains a new customization point `checkIsolation()`, which can be\n  implemented by custom executor implementations in order to provide a last resort  \n  check before the isolation asserting APIs such as `Actor.assumeIsolated` or\n  `assertIsolated` fail and crash.\n\n  This specifically enables Dispatch to implement more sophisticated isolation\n  checking, and now even an actor which is \"on a queue which is targeting \n  another specific queue\" can be properly detected using these APIs.\n\n* Closures can now appear in pack expansion expressions, which allows you to\n  construct a parameter pack of closures where each closure captures the\n  corresponding element of some other parameter pack. For example:\n\n  ```swift\n  struct Manager<each T> {\n    let fn: (repeat () -> (each T))\n\n    init(_ t: repeat each T) {\n      fn = (repeat { each t })\n    }\n  }\n  ```\n\n* [SE-0431][]:\n  You can now require a function value to carry its actor isolation\n  dynamically in a way that can be directly read by clients:\n\n  ```swift\n  func apply<R>(count: Int,\n                operation: @isolated(any) async () -> R) async -> [R]\n      where R: Sendable {\n    // implementation\n  }\n  ```\n\n  The isolation can read with the `.isolation` property, which has type\n  `(any Actor)?`:\n\n  ```swift\n  let iso = operation.isolation\n  ```\n\n  This capability has been adopted by the task-creation APIs in the\n  standard library.  As a result, creating a task with an actor-isolated\n  function will now synchronously enqueue the task on the actor, which\n  can be used for transitive event-ordering guarantees if the actor\n  guarantees that jobs will be run in the order they are enqueued, as\n  `@MainActor` does.  If the function is not explicitly isolated, Swift\n  still retains the right to optimize enqueues for functions that actually\n  start by doing work with different isolation from their formal isolation.\n\n* [SE-0423][]:\n  You can now use `@preconcurrency` attribute to replace static actor isolation\n  checking with dynamic checks for witnesses of synchronous nonisolated protocol\n  requirements when the witness is isolated. This is common when Swift programs\n  need to interoperate with frameworks written in C/C++/Objective-C whose\n  implementations cannot participate in static data race safety.\n\n  ```swift\n  public protocol ViewDelegateProtocol {\n    func respondToUIEvent()\n  }\n  ```\n\n  It's now possible for a `@MainActor`-isolated type to conform to\n  `ViewDelegateProtocol` by marking conformance declaration as `@preconcurrency`:\n\n  ```swift\n  @MainActor\n  class MyViewController: @preconcurrency ViewDelegateProtocol {\n    func respondToUIEvent() {\n      // implementation...\n    }\n  }\n  ```\n\n  The compiler would emit dynamic checks into the `respondToUIEvent()` witness\n  to make sure that it's always executed in `@MainActor` isolated context.\n\n  Additionally, the compiler would emit dynamic actor isolation checks for:\n\n  - `@objc` thunks of synchronous actor-isolated members of classes.\n\n  - Synchronous actor-isolated function values passed to APIs that\n    erase actor isolation and haven't yet adopted strict concurrency checking.\n\n  - Call-sites of synchronous actor-isolated functions imported from Swift 6 libraries.\n\n  The dynamic actor isolation checks can be disabled using the flag\n  `-disable-dynamic-actor-isolation`.\n\n* [SE-0420][]:\n  `async` functions can now explicitly inherit the isolation of their caller\n  by declaring an `isolated` parameter with the default value of `#isolation`:\n\n  ```swift\n  func poll(isolation: isolated (any Actor)? = #isolation) async -> [Item] {\n    // implementation\n  }\n  ```\n\n  When the caller is actor-isolated, this allows it to pass isolated state\n  to the function, which would otherwise have concurrency problems.  The\n  function may also be able to eliminate unwanted scheduling changes, such\n  as when it can quickly return in a fast path without needing to suspend.\n\n* [SE-0418][]:\n\n  The compiler would now automatically employ `Sendable` on functions\n  and key path literal expressions that cannot capture non-Sendable values.\n\n  This includes partially-applied and unapplied instance methods of `Sendable`\n  types, as well as non-local functions. Additionally, it is now disallowed\n  to utilize `@Sendable` on instance methods of non-Sendable types.\n\n  Let's use the following type to illustrate the new inference rules:\n\n  ```swift\n  public struct User {\n    var name: String\n\n    func getAge() -> Int { ... }\n  }\n  ```\n\n  Key path `\\User.name` would be inferred as `WritableKeyPath<User, String> & Sendable`\n  because it doesn't capture any non-Sendable values.\n\n  The same applies to keypath-as-function conversions:\n\n  ```swift\n  let _: @Sendable (User) -> String = \\User.name // Ok\n  ```\n\n  A function value produced by an un-applied reference to `getAge`\n  would be marked as `@Sendable` because `User` is a `Sendable` struct:\n\n  ```swift\n  let _ = User.getAge // Inferred as `@Sendable (User) -> @Sendable () -> Int`\n\n  let user = User(...)\n  user.getAge // Inferred as `@Sendable () -> Int`\n  ```\n\n* [SE-0432][]:\n  Noncopyable enums can be pattern-matched with switches without consuming the\n  value you switch over:\n\n  ```swift\n  enum Lunch: ~Copyable {\n    case soup\n    case salad\n    case sandwich\n  }\n  \n  func isSoup(_ lunch: borrowing Lunch) -> Bool {\n    switch lunch {\n      case .soup: true\n      default: false\n    }\n  }\n  ```\n\n\n* [SE-0429][]:\n  The noncopyable fields of certain types can now be consumed individually:\n\n  ```swift\n  struct Token: ~Copyable {}\n\n  struct Authentication: ~Copyable {\n    let id: Token\n    let name: String\n\n    mutating func exchange(_ new: consuming Token) -> Token {\n      let old = self.id  // <- partial consumption of 'self'\n      self = .init(id: new, name: self.name)\n      return old\n    }\n  }\n  ```\n\n* [SE-0430][]:\n\n  Region Based Isolation is now extended to enable the application of an\n  explicit `sending` annotation to function parameters and results. A function\n  parameter or result that is annotated with `sending` is required to be\n  disconnected at the function boundary and thus possesses the capability of\n  being safely sent across an isolation domain or merged into an actor-isolated\n  region in the function's body or the function's caller respectively. Example:\n  \n  ```swift\n  func parameterWithoutSending(_ x: NonSendableType) async {\n    // Error! Cannot send a task-isolated value to the main actor!\n    await transferToMainActor(x)\n  }\n  \n  func parameterWithSending(_ x: sending NonSendableType) async {\n    // Ok since `x` is `sending` and thus disconnected.\n    await transferToMainActor(x)\n  }\n  ```\n\n* [SE-0414][]:\n\n  The compiler is now capable of determining whether or not a value that does\n  not conform to the `Sendable` protocol can safely be sent over an isolation\n  boundary. This is done by introducing the concept of *isolation regions* that\n  allows the compiler to reason conservatively if two values can affect each\n  other. Through the usage of isolation regions, the compiler can now prove that\n  sending a value that does not conform to the `Sendable` protocol over an\n  isolation boundary cannot result in races because the value (and any other\n  value that might reference it) is not used in the caller after the point of\n  sending allowing code like the following to compile:\n  \n  ```swift\n  actor MyActor {\n      init(_ x: NonSendableType) { ... }\n  }\n  \n  func useValue() {\n    let x = NonSendableType()\n    let a = await MyActor(x) // Error without Region Based Isolation!\n  }\n  ```\n\n* [SE-0427][]:\n  You can now suppress `Copyable` on protocols, generic parameters, \n  and existentials:\n\n  ```swift\n  // Protocol does not require conformers to be Copyable.\n  protocol Flower: ~Copyable {\n    func bloom()\n  }\n\n  // Noncopyable type\n  struct Marigold: Flower, ~Copyable {\n    func bloom() { print(\"Marigold blooming!\") }\n  }\n\n  // Copyable type\n  struct Hibiscus: Flower {\n    func bloom() { print(\"Hibiscus blooming!\") }\n  }\n\n  func startSeason(_ flower: borrowing some Flower & ~Copyable) {\n    flower.bloom()\n  }\n\n  startSeason(Marigold())\n  startSeason(Hibiscus())\n  ```\n\n  By writing `~Copyable` on a generic type, you're suppressing a default\n  `Copyable` constraint that would otherwise appear on that type. This permits\n  noncopyable types, which have no `Copyable` conformance, to conform to such \n  protocols and be substituted for those generic types. Full functionality of this\n  feature requires the newer Swift 6 runtime.\n\n* Since its introduction in Swift 5.1 the @TaskLocal property wrapper was used to   \n  create and access task-local value bindings. Property wrappers introduce mutable storage,\n  which was now properly flagged as potential source of concurrency unsafety.\n \n  In order for Swift 6 language mode to not flag task-locals as potentially thread-unsafe,\n  task locals are now implemented using a macro. The macro has the same general semantics \n  and usage patterns, however there are two source-break situations which the Swift 6 \n  task locals cannot handle:\n\n  Using an implicit default `nil` value for task local initialization, when combined with a type alias:\n  ```swift\n  // allowed in Swift 5.x, not allowed in Swift 6.x\n  \n  typealias MyValue = Optional<Int> \n  \n  @TaskLocal\n  static var number: MyValue // Swift 6: error, please specify default value explicitly\n  \n  // Solution 1: Specify the default value\n  @TaskLocal\n  static var number: MyValue = nil\n  \n  // Solution 2: Avoid the type-alias\n  @TaskLocal\n  static var number: Optional<Int>\n  ```\n\n  At the same time, task locals can now be declared as global properties, which wasn't possible before.\n\n* Swift 5.10 missed a semantic check from [SE-0309][]. In type context, a reference to a\n  protocol `P` that has associated types or `Self` requirements should use\n  the `any` keyword, but this was not enforced in nested generic argument positions.\n  This is now an error as required by the proposal:\n\n  ```swift\n  protocol P { associatedtype A }\n  struct Outer<T> { struct Inner<U> { } }\n  let x = Outer<P>.Inner<P>()  // error\n  ```\n  To correct the error, add `any` where appropriate, for example\n  `Outer<any P>.Inner<any P>`.\n\n* Swift 5.10 accepted certain invalid opaque return types from [SE-0346][].\n  If a generic argument of a constrained opaque return type did not\n  satisfy the requirements on the primary associated type, the generic\n  argument was silently ignored and type checking would proceed as if it\n  weren't stated. This now results in a diagnostic:\n\n  ```swift\n  protocol P<A> { associatedtype A: Sequence }\n  struct G<A: Sequence>: P {}\n\n  func f() -> some P<Int> { return G<Array<Int>>() }  // error\n  ```\n\n  The return type above should be written as `some P<Array<Int>>` to match\n  the return statement. The old broken behavior in this situation can also\n  be restored, by removing the erroneous constraint and using the more general\n  upper bound `some P`.\n\n* [SE-0408][]:\n  A `for`-`in` loop statement can now accept a pack expansion expression,\n  enabling iteration over the elements of its respective value pack. This form\n  supports pattern matching, control transfer statements, and other features\n  available to a `Sequence`-driven `for`-`in` loop, except for the `where`\n  clause. Below is an example implementation of the equality operator for\n  tuples of arbitrary length using pack iteration:\n\n  ```swift\n  func == <each Element: Equatable>(lhs: (repeat each Element),\n                                    rhs: (repeat each Element)) -> Bool {\n\n    for (left, right) in repeat (each lhs, each rhs) {\n      guard left == right else { return false }\n    }\n    return true\n  }\n  ```\n\n  The elements of the value pack corresponding to the pack expansion expression\n  are evaluated on demand, meaning the i<sup>th</sup> element is evaluated on\n  the i<sup>th</sup> iteration:\n\n  ```swift\n  func doSomething(_: some Any) {}\n\n  func evaluateFirst<each T>(_ t: repeat each T) {\n    for _ in repeat doSomething(each t) {\n      break\n    }\n  }\n\n  evaluateFirst(1, 2, 3) \n  // 'doSomething' will be called only on the first element of the pack.\n  ```\n\n* [SE-0352][]:\n  The Swift 6 language mode will open existential values with\n  \"self-conforming\" types (such as `any Error` or `@objc` protocols)\n  passed to generic functions. For example:\n\n  ```swift\n  func takeError<E: Error>(_ error: E) { }\n\n  func passError(error: any Error) {\n    takeError(error)  // Swift 5 does not open `any Error`, Swift 6 does\n  }\n  ```\n\n  This behavior can be enabled prior to the Swift 6 language mode\n  using the upcoming language feature `ImplicitOpenExistentials`.\n\n* [SE-0422][]:\n  Non-built-in expression macros can now be used as default arguments that\n  expand at each call site. For example, a custom `#CurrentFile` macro used as\n  a default argument in 'Library.swift' won't be expanded to `\"Library.swift\"`:\n\n  ```swift\n  @freestanding(expression)\n  public macro CurrentFile() -> String = ...\n\n  public func currentFile(name: String = #CurrentFile) { name }\n  ```\n\n  Instead, it will be expanded at where the function is called:\n  \n  ```swift\n  print(currentFile())\n  // Prints \"main.swift\"\n  ```\n\n  The expanded code can also use declarations from the caller side context:\n\n  ```swift\n  var person = \"client\"\n  greetPerson(/* greeting: #informalGreeting */)\n  // Prints \"Hi client\" if macro expands to \"Hi \\(person)\"\n  ```\n\n* [SE-0417][]:\n  Tasks now gain the ability to respect Task Executor preference.\n  This allows tasks executing default actors (which do not declare a custom executor),\n  and nonisolated asynchronous functions to fall back to a preferred executor, rather than always\n  executing on the default global pool.\n\n  The executor preference may be stated using the `withTaskExecutorPreference` function:\n\n  ```swift\n  nonisolated func doSomething() async { ... }\n  \n  await withTaskExecutorPreference(preferredExecutor) {\n    doSomething()\n  ```\n\n  Or when creating new unstructured or child-tasks (e.g. in a task group):\n\n  ```swift\n  Task(executorPreference: preferredExecutor) {\n    // executes on 'preferredExecutor'\n    await doSomething() // doSomething body would execute on 'preferredExecutor'\n  }\n  ```\n\n* [SE-0413][]:\n\n  Functions can now specify the type of error that they throw as part of the\n  function signature. For example:\n\n  ```swift\n  func parseRecord(from string: String) throws(ParseError) -> Record { ... }\n  ```\n\n  A call to `parseRecord(from:)` will either return a `Record` instance or throw\n  an error of type `ParseError`. For example, a `do..catch` block will infer\n  the `error` variable as being of type `ParseError`:\n\n  ```swift\n  do {\n    let record = try parseRecord(from: myString)\n  } catch {\n    // error has type ParseError\n  }\n  ```\n\n  Typed throws generalizes over throwing and non-throwing functions. A function\n  that is specified as `throws` (without an explicitly-specified error type) is\n  equivalent to one that specifies `throws(any Error)`, whereas a non-throwing\n  is equivalent to one that specifies `throws(Never)`. Calls to functions that\n  are `throws(Never)` are non-throwing.\n\n  Typed throws can also be used in generic functions to propagate error types\n  from parameters, in a manner that is more precise than `rethrows`. For\n  example, the `Sequence.map` operation can propagate the thrown error type from\n  its closure parameter, indicating that it only throws errors of the same type\n  as that closure does:\n\n  ```swift\n  extension Sequence {\n    func map<T, E>(_ body: (Element) throws(E) -> T) throws(E) -> [T] { ... }\n  }\n  ```\n\n  When given a non-throwing closure as a parameter, `map` will not throw.\n\n* [#70065][]:\n\n  With the implementation of [SE-0110][], a closure parameter syntax consisting\n  of only a parameter type — and no parameter name — was accidentally made legal\n  for certain unambiguous type syntaxes in Swift 4. For example:\n\n  ```swift\n  let closure = { ([Int]) in }\n  ```\n\n  Having been [gated](https://github.com/apple/swift/pull/28171) behind a\n  compiler warning since at least Swift 5.2, this syntax is now rejected.\n\n* [#71075][]:\n\n  \\_SwiftConcurrencyShims used to declare the `exit` function, even though it\n  might not be available. The declaration has been removed, and must be imported\n  from the appropriate C library module (e.g. Darwin or SwiftGlibc)\n  \n* [SE-0270][]:\n\n  The Standard Library now provides APIs for performing collection operations\n  over noncontiguous elements. For example:\n  \n  ```swift\n  var numbers = Array(1...15)\n\n  // Find the indices of all the even numbers\n  let indicesOfEvens = numbers.indices(where: { $0.isMultiple(of: 2) })\n\n  // Perform an operation with just the even numbers\n  let sumOfEvens = numbers[indicesOfEvens].reduce(0, +)\n  // sumOfEvens == 56\n\n  // You can gather the even numbers at the beginning\n  let rangeOfEvens = numbers.moveSubranges(indicesOfEvens, to: numbers.startIndex)\n  // numbers == [2, 4, 6, 8, 10, 12, 14, 1, 3, 5, 7, 9, 11, 13, 15]\n  // numbers[rangeOfEvens] == [2, 4, 6, 8, 10, 12, 14]\n  ```\n  \n  The standard library now provides a new `indices(where:)` function which creates\n  a `RangeSet` - a new type representing a set of discontiguous indices. `RangeSet`\n  is generic over its index type and can be used to execute operations over\n  noncontiguous indices such as collecting, moving, or removing elements from a\n  collection. Additionally, `RangeSet` is generic over any `Comparable` collection\n  index and can be used to represent a selection of items in a list or a refinement\n  of a filter or search result.\n\n## Swift 5.10\n\n### 2024-03-05 (Xcode 15.3)\n\n* Swift 5.10 closes all known static data-race safety holes in complete strict\nconcurrency checking.\n\n  When writing code against `-strict-concurrency=complete`, Swift 5.10 will\n  diagnose all potential for data races at compile time unless an explicit\n  unsafe opt out, such as `nonisolated(unsafe)` or `@unchecked Sendable`, is\n  used.\n\n  For example, in Swift 5.9, the following code crashes at runtime due to a\n  `@MainActor`-isolated initializer being evaluated outside the actor, but it\n  was not diagnosed under `-strict-concurrency=complete`:\n\n  ```swift\n  @MainActor\n  class MyModel {\n    init() {\n      MainActor.assertIsolated()\n    }\n\n    static let shared = MyModel()\n  }\n\n  func useShared() async {\n    let model = MyModel.shared\n  }\n\n  await useShared()\n  ```\n\n  The above code admits data races because a `@MainActor`-isolated static\n  variable, which evaluates a `@MainActor`-isolated initial value upon first\n  access, is accessed synchronously from a `nonisolated` context. In Swift\n  5.10, compiling the code with `-strict-concurrency=complete` produces a\n  warning that the access must be done asynchronously:\n\n  ```\n  warning: expression is 'async' but is not marked with 'await'\n    let model = MyModel.shared\n                ^~~~~~~~~~~~~~\n                await\n  ```\n\n  Swift 5.10 fixed numerous other bugs in `Sendable` and actor isolation\n  checking to strengthen the guarantees of complete concurrency checking.\n\n  Note that the complete concurrency model in Swift 5.10 is conservative.\n  Several Swift Evolution proposals are in active development to improve the\n  usability of strict concurrency checking ahead of Swift 6.\n\n* [SE-0412][]:\n\n  Global and static variables are prone to data races because they provide memory that can be accessed from any program context.  Strict concurrency checking in Swift 5.10 prevents data races on global and static variables by requiring them to be either:\n\n    1. isolated to a global actor, or\n    2. immutable and of `Sendable` type.\n\n  For example:\n\n  ```swift\n  var mutableGlobal = 1\n  // warning: var 'mutableGlobal' is not concurrency-safe because it is non-isolated global shared mutable state\n  // (unless it is top-level code which implicitly isolates to @MainActor)\n\n  @MainActor func mutateGlobalFromMain() {\n    mutableGlobal += 1\n  }\n\n  nonisolated func mutateGlobalFromNonisolated() async {\n    mutableGlobal += 10\n  }\n\n  struct S {\n    static let immutableSendable = 10\n    // okay; 'immutableSendable' is safe to access concurrently because it's immutable and 'Int' is 'Sendable'\n  }\n  ```\n\n  A new `nonisolated(unsafe)` modifier can be used to annotate a global or static variable to suppress data isolation violations when manual synchronization is provided:\n\n  ```swift\n  // This global is only set in one part of the program\n  nonisolated(unsafe) var global: String!\n  ```\n\n  `nonisolated(unsafe)` can be used on any form of storage, including stored properties and local variables, as a more granular opt out for `Sendable` checking, eliminating the need for `@unchecked Sendable` wrapper types in many use cases:\n\n  ```swift\n  import Dispatch\n\n  // 'MutableData' is not 'Sendable'\n  class MutableData { ... } \n\n  final class MyModel: Sendable {\n    private let queue = DispatchQueue(...)\n    // 'protectedState' is manually isolated by 'queue'\n    nonisolated(unsafe) private var protectedState: MutableData\n  }\n  ```\n\n  Note that without correct implementation of a synchronization mechanism to achieve data isolation, dynamic run-time analysis from exclusivity enforcement or tools such as the Thread Sanitizer could still identify failures.\n\n* [SE-0411][]:\n\n  Swift 5.10 closes a data-race safety hole that previously permitted isolated\n  default stored property values to be synchronously evaluated from outside the\n  actor. For example, the following code compiles warning-free under\n  `-strict-concurrency=complete` in Swift 5.9, but it will crash at runtime at\n  the call to `MainActor.assertIsolated()`:\n\n  ```swift\n  @MainActor func requiresMainActor() -> Int {\n    MainActor.assertIsolated()\n    return 0\n  }\n\n  @MainActor struct S {\n    var x = requiresMainActor()\n    var y: Int\n  }\n\n  nonisolated func call() async {\n    let s = await S(y: 10)\n  }\n\n  await call()\n  ```\n\n  This happens because `requiresMainActor()` is used as a default argument to\n  the member-wise initializer of `S`, but default arguments are always\n  evaluated in the caller. In this case, the caller runs on the generic\n  executor, so the default argument evaluation crashes.\n\n  Under `-strict-concurrency=complete` in Swift 5.10, default argument values\n  can safely share the same isolation as the enclosing function or stored\n  property. The above code is still valid, but the isolated default argument is\n  guaranteed to be evaluated in the callee's isolation domain.\n\n## Swift 5.9.2\n\n### 2023-12-11 (Xcode 15.1)\n\n* [SE-0407][]:\n\n  Member macros can specify a list of protocols via the `conformances` argument to the macro role. The macro implementation will be provided with those protocols that are listed but have not already been implemented by the type to which the member macro is attached, in the same manner as extension macros.\n\n  ```swift\n  @attached(member, conformances: Decodable, Encodable, names: named(init(from:), encode(to:)))\n  @attached(extension, conformances: Decodable, Encodable, names: named(init(from:), encode(to:)))\n  macro Codable() = #externalMacro(module: \"MyMacros\", type: \"CodableMacro\")\n  ```\n\n## Swift 5.9\n\n### 2023-09-18 (Xcode 15.0)\n\n* [SE-0382][], [SE-0389][], [SE-0394][], [SE-0397][]:\n\n  Swift 5.9 includes a new macro system that can be used to eliminate boilerplate and provide new forms of expressive APIs. Macros are declared with the new `macro` introducer:\n\n  ```swift\n  @freestanding(expression)\n  macro assert(_ condition: Bool) = #externalMacro(module: \"PowerAssertMacros\", type: \"AssertMacro\")\n  ```\n\n  Macros have parameter and result types, like functions, but are defined as separate programs that operate on syntax trees (using [swift-syntax][]) and produce new syntax trees that are incorporated into the program. Freestanding macros, indicated with the `@freestanding` attribute, are expanded in source code with a leading `#`:\n\n  ```swift\n  #assert(x + y == z) // expands to check the result of x + y == z and report failure if it's false\n  ```\n\n  Macros can also be marked as `@attached`, in which case they will be meaning that they will be expanded using custom attribute syntax. For example:\n\n  ```swift\n  @attached(peer, names: overloaded)\n  macro AddCompletionHandler() = #externalMacro(\n    module: \"ConcurrencyHelperMacros\",\n    type: \"AddCompletionHandlerMacro\"\n  )\n  \n  @AddCompletionHandler\n  func fetchAvatar(from url: URL) throws -> Image { ... }\n  \n  // expands to...\n  func fetchAvatar(from url: URL, completionHandler: @escaping (Result<Image, Error>) -> Void) {\n    Task.detached {\n      do {\n        let result = try await fetchAvatar(from: url)\n        completionHandler(.success(result))\n      } catch {\n        completionHandler(.failure(error))\n      }\n    }\n  }\n  ```\n\n  Macros are implemented in separate programs, which are executed by the Swift compiler. The Swift Package Manager's manifest provides a new `macro` target type to describe macros:\n\n  ```swift\n  import PackageDescription\n  import CompilerPluginSupport\n  \n  let package = Package(\n      name: \"ConcurrencyHelpers\",\n      dependencies: [\n          .package(url: \"https://github.com/apple/swift-syntax\", from: \"509.0.0\"),\n      ],\n      targets: [\n          .macro(name: \"ConcurrencyHelperMacros\",\n                 dependencies: [\n                     .product(name: \"SwiftSyntaxMacros\", package: \"swift-syntax\"),\n                     .product(name: \"SwiftCompilerPlugin\", package: \"swift-syntax\")\n                 ]),\n          .target(name: \"ConcurrencyHelpers\", dependencies: [\"ConcurrencyHelperMacros\"]),\n          .testTarget(name: \"ConcurrencyHelperMacroTests\", dependencies: [\"ConcurrencyHelperMacros\"]),\n      ]\n  )\n  ```\n\n* [SE-0380][]:\n\n  `if` and `switch` statements may now be used as expressions to:\n\n  * Return values from functions, properties, and closures (either with\n    implicit or explicit `return`)\n  * Throw errors using `throw`\n  * Assign values to variables\n  * Declare variables\n\n  Each branch of the `if` or `switch` must be a single expression, the value\n  of which becomes the value of the overall expression when that branch is\n  chosen.\n\n  ```swift\n  let bullet =\n    if isRoot && (count == 0 || !willExpand) { \"\" }\n    else if count == 0 { \"- \" }\n    else if maxDepth <= 0 { \"▹ \" }\n    else { \"▿ \" }\n  ```\n\n  ```swift\n  public static func width(_ x: Unicode.Scalar) -> Int {\n    switch x.value {\n      case 0..<0x80: 1\n      case 0x80..<0x0800: 2\n      case 0x0800..<0x1_0000: 3\n      default: 4\n    }\n  }\n  ```\n\n* [#64927][]:\n\n  Swift 5.9 introduces warnings that catch conversions from an inout\n  argument in the caller to an `UnsafeRawPointer` in the callee\n  whenever the original type contains an object reference.\n\n  ```swift\n  func inspectString(string: inout String) {\n    readBytes(&string)\n    // warning: forming an 'UnsafeRawPointer' to an inout variable of type String\n    // exposes the internal representation rather than the string contents.\n  }\n  ```\n\n  ```swift\n  func inspectData(data: inout Data) {\n    readBytes(&data)\n    // warning: forming an 'UnsafeRawPointer' to a variable of type 'T';\n    // this is likely incorrect because 'T' may contain an object reference.\n  }\n  ```\n\n  Please see the \"Workarounds for common cases\" section link in github\n  issue #64927.\n\n* Marking stored properties as unavailable with `@available` has been banned,\n  closing an unintentional soundness hole that had allowed arbitrary\n  unavailable code to run and unavailable type metadata to be used at runtime:\n  \n  ```swift\n  @available(*, unavailable)\n  struct Unavailable {\n    init() {\n      print(\"Unavailable.init()\")\n    }\n  }\n\n  struct S {\n    @available(*, unavailable)\n    var x = Unavailable()\n  }\n\n  _ = S() // prints \"Unavailable.init()\"\n  ```\n  \n  Marking `deinit` as unavailable has also been banned for similar reasons.\n\n* [SE-0366][]:\n\n  The lifetime of a local variable value can be explicitly ended using the\n  `consume` operator, forwarding ownership to the surrounding call, assignment,\n  or initialization without copying:\n\n  ```swift\n  var x: [String] = []\n  x.append(\"apples\")\n  x.append(\"bananas\")\n  x.append(\"oranges\")\n\n  process(consume x) // forward the current value, without copying\n\n  x = [] // start building a new value\n  x.append(\"broccoli\")\n  x.append(\"cauliflower\")\n  x.append(\"asparagus\")\n  ...\n  ```\n\n* [SE-0377][]:\n\n  Functions can now declare whether they take value parameters by `borrowing`\n  access to a value provided by the caller, or by `consuming` a value that the\n  callee is allowed to take ownership of:\n\n  ```swift\n  struct HealthyFoods {\n    var values: [String] = []\n\n    // Ask to `consume` the parameter, since we want to use it\n    // to incorporate into our own `values` array\n    mutating func add(_ value: consuming String) {\n        values.append(value)\n    }\n  }\n  ```\n\n## Swift 5.8\n\n### 2023-03-30 (Xcode 14.3)\n\n* [SE-0376][]:\n\n  The `@backDeployed(before:)` attribute may now be used to extend the availability of a function to OS releases prior to the introduction of that function as ABI.\n  \n  For example, suppose that `struct Temperature` was introduced in a macOS SDK framework in macOS 12. Later in macOS 13 the framework authors decided to add a `degreesFahrenheit` property as a convenience:\n  \n  ```swift\n  @available(macOS 12, *)\n  public struct Temperature {\n    public var degreesCelsius: Double\n    \n    // ...\n  }\n  \n  extension Temperature {\n    @available(macOS 12, *)\n    @backDeployed(before: macOS 13)\n    public var degreesFahrenheit: Double {\n      return (degreesCelsius * 9 / 5) + 32\n    }\n  }\n  ```\n  \n  Adding the `@backDeployed` attribute to `degreesFahrenheit` enables the framework author to make this new declaration available to apps with a minimum deployment target of macOS 12, even though the ABI entry point for `degreesFahrenheit` is only present in macOS 13 and up.\n  \n  When a function with `@backDeployed` is called, the compiler wraps the invocation of the function in a thunk. The thunk checks whether the library entry point for the declaration is available at runtime, and invokes it if it is. Otherwise, a copy of the function that was emitted into the client is called instead.\n\n* [#56139][]:\n\n  Сollection downcasts in cast patterns are now supported. For example:\n\n  ```swift\n  func collectionDowncast(_ arr: [Any]) {\n    switch arr {\n    case let ints as [Int]:\n      // ...\n    case is [Bool]:\n      // ...\n    }\n  }\n  ``` \n* [SE-0370][]:\n\n  The API of `UnsafeMutableRawPointer`, `UnsafeMutableBufferPointer`, `UnsafeMutableRawBufferPointer` were improved, adding previously missing initialization (and deinitialization) methods, including more performant initialization from `Collection` types.\n\n  For `UnsafeMutablePointer<T>` and `UnsafeMutableBufferPointer<T>`, method names containing the word \"assign\" were renamed to use the word \"update\", and many more were added. Every multi-element initialization method of `UnsafeMutablePointer` and `UnsafeMutableBufferPointer` now has a corresponding \"update\" method.\n\n  Slices of `UnsafeBufferPointer`, `UnsafeRawBufferPointer`, `UnsafeMutableBufferPointer` and `UnsafeMutableRawBufferPointer` now share the collection-like API of their base type. For example, given an initialized `b: UnsafeMutableBufferPointer<Int>`, the following lines are synonymous:\n  ```swift\n  b.update(repeating: 0)\n  b[b.startIndex..<b.endIndex].update(repeating: 0)\n  ```\n\n* [SE-0365][]:\n \n  Implicit `self` is now permitted for `weak self` captures, after `self` is unwrapped.\n\n  For example, the usage of implicit `self` below is permitted:\n\n  ```swift\n  class ViewController {\n    let button: Button\n\n    func setup() {\n        button.tapHandler = { [weak self] in\n            guard let self else { return }\n            dismiss() // refers to `self.dismiss()`\n        }\n    }\n\n    func dismiss() { ... }\n  }\n  ```\n\n  In Swift 5 language modes, implicit `self` is permitted for `weak self` captures in _non-escaping_ closures even before `self` is unwrapped. For example, this code compiles successfully in Swift 5 language mode:\n\n  ```swift\n  class ExampleClass {\n    func makeArray() -> [String] {\n      // `Array.map` takes a non-escaping closure:\n      [\"foo\", \"bar\", \"baaz\"].map { [weak self] string in\n        double(string) // implicitly refers to `self!.double(string)`\n      }\n    } \n\n    func double(_ string: String) -> String {\n      string + string\n    }\n  }\n  ```\n\n  In Swift 6, the above code will no longer compile. `weak self` captures in non-escaping closures now have the same behavior as captures in escaping closures (as described in [SE-0365][]). Code relying on the previous behavior will need to be updated to either unwrap `self` (e.g. by adding a `guard let self else return` statement), or to use a different capture method (e.g. using `[self]` or `[unowned self]` instead of `[weak self]`).\n\n* [SE-0362][]:\n\n  The compiler flag `-enable-upcoming-feature X` can now be used to enable a specific feature `X` that has been accepted by the evolution process, but whose introduction into the language is waiting for the next major version (e.g., version 6). The `X` is specified by any proposal that falls into this category:\n  * `ConciseMagicFile` enables the new `#file` semantics in [SE-0274][].\n  * `ForwardTrailingClosures` disables the \"backward\" scanning behavior of [SE-0286][].\n  * `BareSlashRegexLiterals` enables the regex literal syntax of [SE-0354][].\n\n  Features can be detected in source code with `#if hasFeature(X)`.\n\n## Swift 5.7\n\n### 2022-09-12 (Xcode 14.0)\n\n* [SE-0327][]:\n\n  There are a few notable changes in Swift 5.7 with respect to SE-0327.\n\n  First, the deinitializer and most kinds of initializers for `actor` types, and types constrained by a global actor like the `@MainActor`, have revised rules about what expressions are permitted in their body. The goal of these revisions has been to improve language expressivity and safety. In particular, many more programming patterns are now permitted in these initializers.\n\n  For example, a non-async initializer of an `actor` prior to Swift 5.7 would raise a diagnostic any time `self` escapes the initializer before returning. That diagnostic's purpose was to protect against a possible data race when accessing isolated stored proeprties. But, that diagnostic was emitted even if there was no dangerous racy access.\n\n  In Swift 5.7, the compiler now checks these initializers for dangerous accesses to isolated stored properties that occur after an escape of `self`:\n\n  ```swift\n  actor Database {\n    // ... other properties ...\n    var rows: Int = 0\n\n    init(_ world: DataUser) {\n      defer {\n        print(\"last = \\(self.rows)\") // ❌ this access to 'rows' is illegal.\n      }\n\n      print(\"before = \\(self.rows)\") // ✅ this access to 'rows' is OK\n      world.publishDatabase(self)    // ✅ passing 'self' is OK in Swift 5.7+\n      print(\"after = \\(self.rows)\")  // ❌ this access to 'rows' is illegal. \n\n      Task { [weak self] in          // ✅ capturing 'self' is OK in Swift 5.7+\n        while let db = self { await db.prune() }\n      }\n    }\n  }\n  ```\n\n  This is a control-flow sensitive check, meaning an illegal access does not necessarily appear on a source line after an escape of `self` (in the example above, consider _when_ the `defer` is executed). The compiler will always point out one of the escapes of `self` that is causing an access to become illegal.\n\n  Next, delegating initializers of an actor are no longer always non-isolated. This means an `async` delegating initializer can do the same things as a non-delegating one.\n\n  Finally, the diagnostic about non-isolated default-value expressions introduced for Swift 5.6 in the Xcode 13.3 release has been removed. The proposed rule was not precise enough to avoid flagging an innocuous yet common pattern in SwiftUI code involving `@StateObject` properties and `@MainActor`.\n\n* The Swift compiler no longer warns about redundant requirements in generic declarations. For example,\n  the following code diagnosed a warning in Swift 5.6 about the `T.Iterator : IteratorProtocol`\n  requirement being redundant, because it is implied by `T : Sequence`:\n\n  ```swift\n  func firstElement<T: Sequence>(_: T) -> T.Element where T.Iterator: IteratorProtocol {...}\n  ```\n\n  A redundant requirement does not indicate a coding error, and sometimes it is desirable to spell them\n  out for documentation purposes. For this reason these warnings are now disabled by default.\n\n  To restore the previous behavior, pass the `-Xfrontend -warn-redundant-requirements`\n  compiler flag.\n\n* [SE-0338][]:\n\n  Non-isolated async functions now always execute on the global concurrent pool,\n  so calling a non-isolated async function from actor-isolated code will leave\n  the actor. For example:\n\n  ```swift\n  class C { }\n\n  func f(_: C) async { /* always executes on the global concurrent pool */ }\n\n  actor A {\n    func g(c: C) async {\n      /* always executes on the actor */\n      print(\"on the actor\")\n\n      await f(c)\n    }\n  }\n  ```\n\n  Prior to this change, the call from `f` to `g` might have started execution of\n  `g` on the actor, which could lead to actors being busy longer than strictly\n  necessary. Now, the non-isolated async function will always hop to the global\n  cooperative pool, not run on the actor. This can result in a behavior change\n  for programs that assumed that a non-isolated async function called from a\n  `@MainActor` context will be executed on the main actor, although such\n  programs were already technically incorrect.\n\n  Additionally, when leaving an actor to execution on the global cooperative\n  pool, `Sendable` checking will be performed, so the compiler will emit a\n  diagnostic in the call to `f` if `c` is not of `Sendable` type.\n\n* [SE-0350][]:\n\n  The standard library has a new `Regex<Output>` type.\n\n  This type represents an _extended regular expression_, allowing more fluent\n  string processing operations. A `Regex` may be created by\n  [initialization from a string][SE-0355]:\n\n  ```swift\n  let pattern = \"a[bc]+\" // matches \"a\" followed by one or more instances\n                         // of either \"b\" or \"c\"\n  let regex = try! Regex(pattern)\n  ```\n\n  Or via a [regex literal][SE-0354]:\n\n  ```swift\n  let regex = #/a[bc]+/#\n  ```\n\n  In Swift 6, `/` will also be supported as a delimiter for `Regex` literals.\n  You can enable this mode in Swift 5.7 with the `-enable-bare-slash-regex`\n  flag. Doing so will cause some existing expressions that use `/` as an \n  operator to no longer compile; you can add parentheses or line breaks as a\n  workaround.\n\n  There are [new string-processing algorithms][SE-0357] that support\n  `String`, `Regex` and arbitrary `Collection` types.\n\n* [SE-0329][]:\n\n  New types representing time and clocks were introduced. This includes a protocol `Clock` defining clocks which allow for defining a concept of now and a way to wake up after a given instant. Additionally a new protocol `InstantProtocol` for defining instants in time was added. Furthermore a new protocol `DurationProtocol` was added to define an elapsed duration between two given `InstantProtocol` types. Most commonly the `Clock` types for general use are the `SuspendingClock` and `ContinuousClock` which represent the most fundamental clocks for the system. The `SuspendingClock` type does not progress while the machine is suspended whereas the `ContinuousClock` progresses no matter the state of the machine. \n\n  ```swift\n  func delayedHello() async throws {\n    try await Task.sleep(until: .now + .milliseconds(123), clock: .continuous)\n    print(\"hello delayed world\")\n  }\n  ```\n\n  `Clock` also has methods to measure the elapsed duration of the execution of work. In the case of the `SuspendingClock` and `ContinuousClock` this measures with high resolution and is suitable for benchmarks.\n\n  ```swift\n  let clock = ContinuousClock()\n  let elapsed = clock.measure {\n    someLongRunningWork()\n  }\n  ```\n\n* [SE-0309][]:\n\n  Protocols with associated types and `Self` requirements can now be used as the\n  types of values with the `any` keyword.\n\n  Protocol methods that return associated types can be called on an `any` type;\n  the result is type-erased to the associated type's upper bound, which is another\n  `any` type having the same constraints as the associated type. For example:\n\n  ```swift\n  protocol Surface {...}\n  \n  protocol Solid {\n    associatedtype SurfaceType: Surface\n    func boundary() -> SurfaceType\n  }\n  \n  let solid: any Solid = ...\n  \n  // Type of 'boundary' is 'any Surface'\n  let boundary = solid.boundary()\n  ```\n\n  Protocol methods that take an associated type or `Self` cannot be used with `any`,\n  however in conjunction with [SE-0352][], you can pass the `any` type to a function\n  taking a generic parameter constrained to the protocol. Within the generic context,\n  type relationships are explicit and all protocol methods can be used.\n\n* [SE-0346][]:\n\n  Protocols can now declare a list of one or more _primary associated types_, which enable writing same-type requirements on those associated types using angle bracket syntax:\n\n  ```swift\n  protocol Graph<Vertex, Edge> {\n    associatedtype Vertex\n    associatedtype Edge\n  }\n  ```\n\n  You can now write a protocol name followed by type arguments in angle brackets, like\n  `Graph<Int, String>`, anywhere that a protocol conformance requirement may appear:\n\n  ```swift\n  func shortestPath<V, E>(_: some Graph<V, E>, from: V, to: V) -> [E]\n\n  extension Graph<Int, String> {...}\n\n  func build() -> some Graph<Int, String> {}\n  ```\n\n  A protocol name followed by angle brackets is shorthand for a conformance requirement,\n  together with a same-type requirement for the protocol's primary associated types.\n  The first two examples above are equivalent to the following:\n\n  ```swift\n  func shortestPath<V, E, G>(_: G, from: V, to: V) -> [E]\n    where G: Graph, G.Vertex == V, G.Edge == E\n\n  extension Graph where Vertex == Int, Edge == String {...}\n  ```\n\n  The `build()` function returning `some Graph<Int, String>` can't be written using a\n  `where` clause; this is an example of a constrained opaque result type, which is new expressivity in Swift 5.7.\n\n* [SE-0353][]:\n\n  Protocols with primary associated types can now be used in existential types,\n  enabling same-type constraints on those associated types.\n\n  ```swift\n  let strings: any Collection<String> = [ \"Hello\" ]\n  ```\n\n  Note that language features requiring runtime support like dynamic casts\n  (`is`, `as?`, `as!`), as well as generic usages of parameterized existentials\n  in generic types (e.g. `Array<any Collection<Int>>`) involve additional\n  availability checks to use. Back-deploying usages in generic position can be\n  worked around with a generic type-erasing wrapper struct, which is now much\n  simpler to implement:\n\n  ```swift\n  struct AnyCollection<T> {\n    var wrapped: any Collection<T>\n  }\n\n  let arrayOfCollections: [AnyCollection<T>] = [ /**/ ]\n  ```\n\n* [SE-0358][]:\n\n  Various protocols in the standard library now declare primary associated types, for\n  example `Sequence` and `Collection` declare a single primary associated type `Element`.\n  For example, this allows writing down the types `some Collection<Int>` and\n  `any Collection<Int>`.\n\n* References to `optional` methods on a protocol metatype, as well as references to dynamically looked up methods on `AnyObject` are now supported on par with other function references. The type of such a reference (formerly an immediate optional by mistake) has been altered to that of a function that takes a single argument and returns an optional value of function type:\n\n  ```swift\n  class Object {\n    @objc func getTag() -> Int { ... }\n  }\n\n  let getTag: (AnyObject) -> (() -> Int)? = AnyObject.getTag\n\n  @objc protocol Delegate {\n    @objc optional func didUpdateObject(withTag tag: Int)\n  }\n\n  let didUpdateObjectWithTag: (Delegate) -> ((Int) -> Void)? = Delegate.didUpdateObject\n  ```\n\n  > **Warning**  \n  > Due to the type change, selectors for aforementioned method references that require writing out their type explicitly for disambiguation will no longer compile. To fix this, simply adjust the written type, or resort to a `#if swift(<5.7)` directive when compatibility with older compiler versions is warranted. For example:\n  >\n  > ```swift\n  > #if swift(<5.7)\n  > let decidePolicyForNavigationAction = #selector(WKNavigationDelegate.webView(_:decidePolicyFor:decisionHandler:) as ((WKNavigationDelegate) -> (WKWebView, WKNavigationAction, @escaping (WKNavigationActionPolicy) -> Void) -> Void)?)\n  > #else\n  > let decidePolicyForNavigationAction = #selector(WKNavigationDelegate.webView(_:decidePolicyFor:decisionHandler:) as (WKNavigationDelegate) -> ((WKWebView, WKNavigationAction, @escaping (WKNavigationActionPolicy) -> Void) -> Void)?)\n  > #endif\n  > ```\n\n* [SE-0349][]:\n\n  Loading data from raw memory represented by `UnsafeRawPointer`,\n  `UnsafeRawBufferPointer` and their mutable counterparts now supports unaligned\n  accesses. This previously required a workaround involving an intermediate\n  copy:\n\n  ```swift\n  let result = unalignedData.withUnsafeBytes { buffer -> UInt32 in\n    var storage = UInt32.zero\n    withUnsafeMutableBytes(of: &storage) {\n      $0.copyBytes(from: buffer.prefix(MemoryLayout<UInt32>.size))\n    }\n    return storage\n  }\n  ```\n  Now:\n  ```swift\n  let result = unalignedData.withUnsafeBytes { $0.loadUnaligned(as: UInt32.self) }\n  ```\n  Additionally, the counterpart `storeBytes(of:toByteOffset:as:)` had its\n  alignment restriction lifted, so that storing to arbitrary offsets of raw\n  memory can now succeed.\n\n* [SE-0334][]:\n\n  - `UnsafeRawPointer` and `UnsafeMutableRawPointer` have new functionality for\n  pointer arithmetic, adding functions to obtain a pointer advanced to the next\n  or previous alignment boundary:\n\n    ```swift\n    extension UnsafeRawPointer {\n      public func alignedUp<T>(for: T.type) -> UnsafeRawPointer\n      public func alignedDown<T>(for: T.type) -> UnsafeRawPointer\n      public func alignedUp(toMultipleOf alignment: Int) -> UnsafeRawPointer\n      public func alignedDown(toMultipleOf alignment: Int) -> UnsafeRawPointer\n    }\n    ```\n  - It is now possible to use a pointer to `struct` to obtain a pointer to one\n  of its stored properties:\n\n    ```swift\n    withUnsafeMutablePointer(to: &myStruct) {\n      let interiorPointer = $0.pointer(to: \\.myProperty)!\n      return myCFunction(interiorPointer)\n    }\n    ```\n  - Comparisons between pointers have been simplified by being more permissive.\n  Since pointers are representations of memory locations within a single pool of\n  underlying memory, Swift now allows comparing pointers without requiring type\n  conversions with the `==`, `!=`, `<`,`<=`,`>`, and `>=` operators. \n\n* [SE-0333][]:\n\n  It is now possible to use the `withMemoryRebound<T>()` method on raw memory,\n  that is `UnsafeRawPointer` , `UnsafeRawBufferPointer` and their mutable\n  counterparts. Additionally, we clarified the semantics of\n  `withMemoryRebound<T>()` when used on typed memory (`UnsafePointer<Pointee>`,\n  `UnsafeBufferPointer<Pointee>` and their mutable counterparts). Whereas\n  `Pointee` and `T` were previously required to have the same stride, you can\n  now rebind in cases where `Pointee` is an aggregate of `T` or vice-versa. For\n  example, given an `UnsafeMutableBufferPointer<CGPoint>`, you can now use\n  `withMemoryRebound` to operate temporarily on a\n  `UnsafeMutableBufferPointer<CGFloat>`, because `CGPoint` is an aggregate of\n  `CGFloat`.\n\n* [SE-0352][]:\n\n  It's now possible to call a generic function with a value of protocol type\n  in places that would previously fail because `any` types do not conform\n  to their protocols. For example:\n\n  ```swift\n  protocol P {\n    associatedtype A\n    func getA() -> A\n  }\n\n  func takeP<T: P>(_ value: T) { }\n\n  func test(p: any P) {\n    takeP(p) // was an error \"type 'any P' cannot conform to 'P'\", now accepted\n  }\n  ```\n\n  This operates by \"opening\" the value of protocol type and passing the\n  underlying type directly to the generic function.\n\n* [SE-0347][]:\n\n  It's now possible to use a default value expression with a generic parameter type\n  to default the argument and its type:\n\n  ```swift\n  func compute<C: Collection>(_ values: C = [0, 1, 2]) {\n    ...\n  }\n  ```\n\n  `compute` is now accepted by compiler and `[Int]` is going to be inferred\n  for `C` at call sites that do not provide the argument explicitly.\n\n* [SE-0326][]:\n\n  It's now possible to infer parameter and result types from the body of a multi-statement\n  closure. The distinction between single- and multi-statement closures has been removed.\n\n  Use of closures becomes less cumbersome by removing the need to constantly specify explicit\n  closure types which sometimes could be pretty large e.g. when there are multiple parameters\n  or a complex tuple result type.\n\n  For example:\n\n  ```swift\n  func map<T>(fn: (Int) -> T) -> T {\n    return fn(42)\n  }\n\n  func computeResult<U: BinaryInteger>(_: U) -> U { /* processing */ }\n\n  let _ = map {\n    if let $0 < 0 {\n       // do some processing\n    }\n\n    return computeResult($0)\n  }\n  ```\n\n  The result type of `map` can now be inferred from the body of the trailing closure\n  passed as an argument.\n\n* [SE-0345][]:\n\n  It is now possible to unwrap optional variables with a shorthand syntax that\n  shadows the existing declaration. For example, the following:\n  \n  ```swift\n  let foo: String? = \"hello world\"\n  \n  if let foo {\n    print(foo) // prints \"hello world\"\n  }\n  ```\n  \n  is equivalent to:\n  \n  ```swift\n  let foo: String? = \"hello world\"\n  \n  if let foo = foo {\n    print(foo) // prints \"hello world\"\n  }\n  ```\n\n* [SE-0340][]:\n\n  It is now possible to make declarations unavailable from use in asynchronous\n  contexts with the `@available(*, noasync)` attribute.\n\n  This is to protect the consumers of an API against undefined behavior that can\n  occur when the API uses thread-local storage, or encourages using thread-local\n  storage, across suspension points, or protect developers against holding locks\n  across suspension points which may lead to undefined behavior, priority\n  inversions, or deadlocks.\n\n* [SE-0343][]:\n\n  Top-level scripts support asynchronous calls.\n\n  Using an `await` by calling an asynchronous function or accessing an isolated\n  variable transitions the top-level to an asynchronous context. As an\n  asynchronous context, top-level variables are `@MainActor`-isolated and the\n  top-level is run on the `@MainActor`.\n\n  Note that the transition affects function overload resolution and starts an\n  implicit run loop to drive the concurrency machinery.\n\n  Unmodified scripts are not affected by this change unless `-warn-concurrency` is\n  passed to the compiler invocation. With `-warn-concurrency`, variables in the\n  top-level are isolated to the main actor and the top-level context is isolated\n  to the main actor, but is not an asynchronous context.\n\n* [SE-0336][]:\n\n  It is now possible to declare `distributed actor` and `distributed func`s inside of them.\n\n  Distributed actors provide stronger isolation guarantees than \"local\" actors, and enable additional checks to be made on return types and parameters of distributed methods, e.g. checking if they conform to `Codable`. Distributed methods can be called on \"remote\" references of distributed actors, turning those invocations into remote procedure calls, by means of pluggable and user extensible distributed actor system implementations. \n  \n  Swift does not provide any specific distributed actor system by itself, however, packages in the ecosystem fulfill the role of providing those implementations.\n  \n  ```swift\n  distributed actor Greeter { \n    var greetingsSent = 0\n    \n    distributed func greet(name: String) -> String {\n      greetingsSent += 1\n      return \"Hello, \\(name)!\"\n    }\n  }\n  \n  func talkTo(greeter: Greeter) async throws {\n    // isolation of distributed actors is stronger, it is impossible to refer to\n    // any stored properties of distributed actors from outside of them:\n    greeter.greetingsSent // distributed actor-isolated property 'name' can not be accessed from a non-isolated context\n    \n    // remote calls are implicitly throwing and async, \n    // to account for the potential networking involved:\n    let greeting = try await greeter.greet(name: \"Alice\")\n    print(greeting) // Hello, Alice!\n  }\n  ```\n\n* The compiler now emits a warning when a non-final class conforms to a protocol that imposes a same-type requirement between `Self` and an associated type. This is because such a requirement makes the conformance unsound for subclasses.\n\n  For example, Swift 5.6 would allow the following code, which at runtime would construct an instance of `C` and not `SubC` as expected:\n\n  ```swift\n  protocol P {\n    associatedtype A : Q where Self == Self.A.B\n  }\n  \n  protocol Q {\n    associatedtype B\n  \n    static func getB() -> B\n  }\n  \n  class C : P {\n    typealias A = D\n  }\n  \n  class D : Q {\n    typealias B = C\n  \n    static func getB() -> C { return C() }\n  }\n  \n  extension P {\n    static func getAB() -> Self {\n      // This is well-typed, because `Self.A.getB()` returns\n      // `Self.A.B`, which is equivalent to `Self`.\n      return Self.A.getB()\n    }\n  }\n  \n  class SubC : C {}\n  \n  // P.getAB() declares a return type of `Self`, so it should\n  // return `SubC`, but it actually returns a `C`.\n  print(SubC.getAB())\n  ```\n\n  To make the above example correct, either the class `C` needs to become `final` (in which case `SubC` cannot be declared) or protocol `P` needs to be re-designed to not include the same-type requirement `Self == Self.A.B`.\n\n* [SE-0341][]:\n\n  Opaque types can now be used in the parameters of functions and subscripts, when they provide a shorthand syntax for the introduction of a generic parameter. For example, the following:\n\n  ```swift\n  func horizontal(_ v1: some View, _ v2: some View) -> some View {\n    HStack {\n      v1\n      v2\n    }\n  }\n  ```\n\n  is equivalent to\n\n  ```swift\n  func horizontal<V1: View, V2: View>(_ v1: V1, _ v2: V2) -> some View {\n    HStack {\n      v1\n      v2\n    }\n  }\n  ```\n\n  With this, `some` in a parameter type provides a generalization where the\n  caller chooses the parameter's type as well as its value, whereas `some` in\n  the result type provides a generalization where the callee chooses the\n  resulting type and value.\n\n* The compiler now correctly emits errors for `@available` attributes on stored properties with the `lazy` modifier or with attached property wrappers. Previously, the attribute was accepted on this subset of stored properties but the resulting binary would crash at runtime when type metadata was unavailable.\n\n  ```swift\n  struct S {\n    @available(macOS 99, *) // error: stored properties cannot be marked potentially unavailable with '@available'\n    lazy var a: Int = 42\n\n    @available(macOS 99, *) // error: stored properties cannot be marked potentially unavailable with '@available'\n    @Wrapper var b: Int\n  }\n  ```\n\n* The compiler now correctly emits warnings for more kinds of expressions where a protocol conformance is used and may be unavailable at runtime. Previously, member reference expressions and type erasing expressions that used potentially unavailable conformances were not diagnosed, leading to potential crashes at runtime.\n\n  ```swift\n  struct Pancake {}\n  protocol Food {}\n\n  extension Food {\n    var isGlutenFree: Bool { false }\n  }\n\n  @available(macOS 12.0, *)\n  extension Pancake: Food {}\n\n  @available(macOS 11.0, *)\n  func eatPancake(_ pancake: Pancake) {\n    if (pancake.isGlutenFree) { // warning: conformance of 'Pancake' to 'Food' is only available in macOS 12.0 or newer\n      eatFood(pancake) // warning: conformance of 'Pancake' to 'Food' is only available in macOS 12.0 or newer\n    }\n  }\n\n  func eatFood(_ food: Food) {}\n  ```\n\n* [SE-0328][]:\n\n  Opaque types (expressed with `some`) can now be used in structural positions\n  within a result type, including having multiple opaque types in the same\n  result. For example:\n\n  ```swift\n  func getSomeDictionary() -> [some Hashable: some Codable] {\n    return [ 1: \"One\", 2: \"Two\" ]\n  }\n  ```\n\n## Swift 5.6\n\n### 2022-03-14 (Xcode 13.3)\n\n* [SE-0327][]:\n\n  In Swift 5 mode, a warning is now emitted if the default-value expression of an\n  instance-member property requires global-actor isolation. For example:\n\n  ```swift\n  @MainActor\n  func partyGenerator() -> [PartyMember] { fatalError(\"todo\") }\n  \n  class Party {\n    @MainActor var members: [PartyMember] = partyGenerator()\n    //                                      ^~~~~~~~~~~~~~~~\n    // warning: expression requiring global actor 'MainActor' cannot\n    //          appear in default-value expression of property 'members'\n  }\n  ```\n  \n  Previously, the isolation granted by the type checker matched the isolation of\n  the property itself, but at runtime that is not guaranteed. In Swift 6, \n  such default-value expressions will become an error if they require isolation.\n\n* Actor isolation checking now understands that `defer` bodies share the isolation of their enclosing function.\n\n  ```swift\n  // Works on global actors\n  @MainActor\n  func runAnimation(controller: MyViewController) async {\n    controller.hasActiveAnimation = true\n    defer { controller.hasActiveAnimation = false }\n\n    // do the animation here...\n  }\n\n  // Works on actor instances\n  actor OperationCounter {\n    var activeOperationCount = 0\n\n    func operate() async {\n      activeOperationCount += 1\n      defer { activeOperationCount -= 1 }\n\n      // do work here...\n    }\n  }\n  ```\n\n* [SE-0335][]:\n\n  Swift now allows existential types to be explicitly written with the `any`\n  keyword, creating a syntactic distinction between existential types and\n  protocol conformance constraints. For example:\n\n  ```swift\n  protocol P {}\n\n  func generic<T>(value: T) where T: P {\n    ...\n  }\n\n  func existential(value: any P) {\n     ...\n  }\n  ```\n\n* [SE-0337][]:\n\n  Swift now provides an incremental migration path to data race safety, allowing\n  APIs to adopt concurrency without breaking their clients that themselves have\n  not adopted concurrency. An existing declaration can introduce\n  concurrency-related annotations (such as making its closure parameters\n  `@Sendable`) and use the `@preconcurrency` attribute to maintain its behavior\n  for clients who have not themselves adopted concurrency:\n\n  ```swift\n  // module A\n  @preconcurrency func runOnSeparateTask(_ workItem: @Sendable () -> Void)\n\n  // module B\n  import A\n\n  class MyCounter {\n    var value = 0\n  }\n\n  func doesNotUseConcurrency(counter: MyCounter) {\n    runOnSeparateTask {\n      counter.value += 1 // no warning, because this code hasn't adopted concurrency\n    }\n  }\n\n  func usesConcurrency(counter: MyCounter) async {\n    runOnSeparateTask {\n      counter.value += 1 // warning: capture of non-Sendable type 'MyCounter'\n    }\n  }\n  ```\n\n  One can enable warnings about data race safety within a module with the\n  `-warn-concurrency` compiler option. When using a module that does not yet\n  provide `Sendable` annotations, one can suppress warnings for types from that\n  module by marking the import with `@preconcurrency`:\n\n  ```swift\n  /// module C\n  public struct Point {\n    public var x, y: Double\n  }\n\n  // module D\n  @preconcurrency import C\n\n  func centerView(at location: Point) {\n    Task {\n      await mainView.center(at: location) // no warning about non-Sendable 'Point' because the @preconcurrency import suppresses it\n    }\n  }\n  ```\n\n* [SE-0302][]:\n\n  Swift will now produce warnings to indicate potential data races when\n  non-`Sendable` types are passed across actor or task boundaries. For\n  example:\n\n  ```swift\n  class MyCounter {\n    var value = 0\n  }\n\n  func f() -> MyCounter {\n    let counter = MyCounter()\n    Task {\n      counter.value += 1  // warning: capture of non-Sendable type 'MyCounter'\n    }\n    return counter\n  }\n  ```\n\n* [SE-0331][]:\n\n  The conformance of the unsafe pointer types (e.g., `UnsafePointer`,\n  `UnsafeMutableBufferPointer`) to the `Sendable` protocols has been removed,\n  because pointers cannot safely be transferred across task or actor boundaries.\n\n* References to `Self` or so-called \"`Self` requirements\" in the type signatures\n  of protocol members are now correctly detected in the parent of a nested type.\n  As a result, protocol members that fall under this overlooked case are no longer\n  available on values of protocol type:\n\n  ```swift\n  struct Outer<T> {\n    struct Inner {}\n  }\n\n  protocol P {}\n  extension P {\n    func method(arg: Outer<Self>.Inner) {}\n  }\n\n  func test(p: P) {\n    // error: 'method' has a 'Self' requirement and cannot be used on a value of\n    // protocol type (use a generic constraint instead).\n    _ = p.method\n  }\n  ```\n\n* [SE-0324][]:\n\n  Relax diagnostics for pointer arguments to C functions. The Swift\n  compiler now accepts limited pointer type mismatches when directly\n  calling functions imported from C as long as the C language allows\n  those pointer types to alias. Consequently, any Swift\n  `Unsafe[Mutable]Pointer<T>` or `Unsafe[Mutable]RawPointer` may be\n  passed to C function arguments declared as `[signed|unsigned] char\n  *`. Swift `Unsafe[Mutable]Pointer<T>` can also be passed to C\n  function arguments with an integer type that differs from `T` only\n  in its signedness.\n\n  For example, after importing a C function declaration:\n  ```c\n  long long decode_int64(const char *ptr_to_int64);\n  ```\n  Swift can now directly pass a raw pointer as the function argument:\n  ```swift\n  func decodeAsInt64(data: Data) -> Int64 {\n      data.withUnsafeBytes { (bytes: UnsafeRawBufferPointer) in\n          decode_int64(bytes.baseAddress!)\n      }\n  }\n  ```\n\n* [SE-0322][]:\n\n  The standard library now provides a new operation\n  `withUnsafeTemporaryAllocation` which provides an efficient temporarily\n  allocation within a limited scope, which will be optimized to use stack\n  allocation when possible.\n\n* [SE-0320][]:\n\n  Dictionaries with keys of any type conforming to the new protocol\n  `CodingKeyRepresentable` can now be encoded and decoded. Formerly, encoding\n  and decoding was limited to keys of type `String` or `Int`.\n\n* [SE-0315][]:\n\n  Type expressions and annotations can now include \"type placeholders\" which\n  directs the compiler to fill in that portion of the type according to the usual\n  type inference rules. Type placeholders are spelled as an underscore (\"`_`\") in\n  a type name. For instance:\n  \n  ```swift\n  // This is OK--the compiler can infer the key type as `Int`.\n  let dict: [_: String] = [0: \"zero\", 1: \"one\", 2: \"two\"]\n  ```\n\n* [SE-0290][]:\n\n  It is now possible to write inverted availability conditions by using the new `#unavailable` keyword:\n\n  ```swift\n  if #unavailable(iOS 15.0) {\n      // Old functionality\n  } else {\n      // iOS 15 functionality \n  }\n  ```\n\n## Swift 5.5\n\n### 2021-09-20 (Xcode 13.0)\n\n* [SE-0323][]:\n\n  The main function is executed with `MainActor` isolation applied, so functions\n  and variables with `MainActor` isolation may be called and modified\n  synchronously from the main function. If the main function is annotated with a\n  global actor explicitly, it must be the main actor or an error is emitted. If\n  no global actor annotation is present, the main function is implicitly run on\n  the main actor.\n\n  The main function is executed synchronously up to the first suspension point.\n  Any tasks enqueued by initializers in Objective-C or C++ will run after the\n  main function runs to the first suspension point. At the suspension point, the\n  main function suspends and the tasks are executed according to the Swift\n  concurrency mechanisms.\n\n* [SE-0313][]:\n\n  Parameters of actor type can be declared as `isolated`, which means that they\n  represent the actor on which that code will be executed. `isolated` parameters\n  extend the actor-isolated semantics of the `self` parameter of actor methods\n  to arbitrary parameters. For example:\n\n  ```swift\n  actor MyActor {\n    func f() { }\n  }\n\n  func g(actor: isolated MyActor) {\n    actor.f()   // okay, this code is always executing on \"actor\"\n  }\n\n  func h(actor: MyActor) async {\n    g(actor: actor)        // error, call must be asynchronous\n    await g(actor: actor)  // okay, hops to \"actor\" before calling g\n  }\n  ```\n\n  The `self` parameter of actor methods are implicitly `isolated`. The\n  `nonisolated` keyword makes the `self` parameter no longer `isolated`.\n\n* [#57081][]:\n\n  The compiler now correctly rejects the application of generic arguments to the\n  special `Self` type:\n\n  ```swift\n  struct Box<T> {\n    // previously interpreted as a return type of Box<T>, ignoring the <Int> part;\n    // now we diagnose an error with a fix-it suggesting replacing `Self` with `Box`\n    static func makeBox() -> Self<Int> {...}\n  }\n  ```\n\n* [#57225][]:\n\n  The compiler now correctly rejects `@available` annotations on enum cases with\n  associated values with an OS version newer than the current deployment target:\n\n  ```swift\n  @available(macOS 12, *)\n  public struct Crayon {}\n\n  public enum Pen {\n    case pencil\n\n    @available(macOS 12, *)\n    case crayon(Crayon)\n  }\n  ```\n\n  While this worked with some examples, there is no way for the Swift runtime to\n  perform the requisite dynamic layout needed to support this in general, which\n  could cause crashes at runtime.\n\n  Note that conditional availability on stored properties in structs and classes\n  is not supported for similar reasons; it was already correctly detected and\n  diagnosed.\n\n* [SE-0311][]:\n\n  Task local values can be defined using the new `@TaskLocal` property wrapper.\n  Such values are carried implicitly by the task in which the binding was made,\n  as well as any child-tasks, and unstructured task created from the tasks context.\n  \n  ```swift\n  struct TraceID { \n    @TaskLocal\n    static var current: TraceID? \n  }\n  \n  func printTraceID() {\n    if let traceID = TraceID.current {\n      print(\"\\(traceID)\")\n    } else {\n      print(\"nil\")\n    }\n  }\n  \n  func run() async { \n    printTraceID()    // prints: nil\n    TraceID.$current.withValue(\"1234-5678\") { \n      printTraceID()  // prints: 1234-5678\n      inner()         // prints: 1234-5678\n    }\n    printTraceID()    // prints: nil\n  }\n  \n  func inner() {\n    // if called from a context in which the task-local value\n    // was bound, it will print it (or 'nil' otherwise)\n    printTraceID()\n  }\n  ```\n\n* [SE-0316][]:\n\n\tA type can be defined as a global actor. Global actors extend the notion\n\tof actor isolation outside of a single actor type, so that global state\n\t(and the functions that access it) can benefit from actor isolation,\n\teven if the state and functions are scattered across many different\n\ttypes, functions and modules. Global actors make it possible to safely\n\twork with global variables in a concurrent program, as well as modeling\n\tother global program constraints such as code that must only execute on\n  the \"main thread\" or \"UI thread\". A new global actor can be defined with\n  the `globalActor` attribute:\n\n  ```swift\n  @globalActor\n  struct DatabaseActor {\n    actor ActorType { }\n\n    static let shared: ActorType = ActorType()\n  }\n  ```\n\n  Global actor types can be used as custom attributes on various declarations,\n  which ensures that those declarations are only accessed on the actor described\n  by the global actor's `shared` instance. For example:\n\n  ```swift\n  @DatabaseActor func queryDB(query: Query) throws -> QueryResult\n\n  func runQuery(queryString: String) async throws -> QueryResult {\n    let query = try Query(parsing: queryString)\n    return try await queryDB(query: query) // 'await' because this implicitly hops to DatabaseActor.shared\n  }\n  ```\n\n  The concurrency library defines one global actor, `MainActor`, which\n  represents the main thread of execution. It should be used for any code that\n  must execute on the main thread, e.g., for updating UI.\n\n* [SE-0313][]:\n\n  Declarations inside an actor that would normally be actor-isolated can\n  explicitly become non-isolated using the `nonisolated` keyword. Non-isolated\n  declarations can be used to conform to synchronous protocol requirements:\n\n  ```swift\n  actor Account: Hashable {\n    let idNumber: Int\n    var balance: Double\n\n    nonisolated func hash(into hasher: inout Hasher) { // okay, non-isolated satisfies synchronous requirement\n      hasher.combine(idNumber) // okay, can reference idNumber from outside the let\n      hasher.combine(balance) // error: cannot synchronously access actor-isolated property\n    }\n  }\n  ```\n\n* [SE-0300][]:\n\n  Async functions can now be suspended using the `withUnsafeContinuation`\n  and `withUnsafeThrowingContinuation` functions. These both take a closure,\n  and then suspend the current async task, executing that closure with a\n  continuation value for the current task. The program must use that\n  continuation at some point in the future to resume the task, passing in\n  a value or error, which then becomes the result of the `withUnsafeContinuation`\n  call in the resumed task.\n\n* Type names are no longer allowed as an argument to a subscript parameter that expects a metatype type\n\n  ```swift\n  struct MyValue {\n  }\n\n  struct MyStruct {\n    subscript(a: MyValue.Type) -> Int { get { ... } }\n  }\n\n  func test(obj: MyStruct) {\n    let _ = obj[MyValue]\n  }\n  ```\n\n  Accepting subscripts with `MyValue` as an argument was an oversight because `MyValue` requires explicit `.self`\n  to reference its metatype, so correct syntax would be to use `obj[MyValue.self]`.\n\n* [SE-0310][]:\n  \n  Read-only computed properties and subscripts can now define their `get` accessor to be `async` and/or `throws`, by writing one or both of those keywords between the `get` and `{`.  Thus, these members can now make asynchronous calls or throw errors in the process of producing a value:\n  ```swift\n  class BankAccount: FinancialAccount {\n    var manager: AccountManager?\n\n    var lastTransaction: Transaction {\n      get async throws {\n        guard manager != nil else { throw BankError.notInYourFavor }\n        return await manager!.getLastTransaction()\n      }\n    }\n\n    subscript(_ day: Date) -> [Transaction] {\n      get async {\n        return await manager?.getTransactions(onDay: day) ?? []\n      }\n    }\n  }\n\n  protocol FinancialAccount {\n    associatedtype T\n    var lastTransaction: T { get async throws }\n    subscript(_ day: Date) -> [T] { get async }\n  }\n  ```\n  Accesses to such members, like `lastTransaction` above, will require appropriate marking with `await` and/or `try`:\n  ```swift\n  extension BankAccount {\n    func meetsTransactionLimit(_ limit: Amount) async -> Bool {\n      return try! await self.lastTransaction.amount < limit\n      //                    ^~~~~~~~~~~~~~~~ this access is async & throws\n    }                \n  }\n\n    \n  func hadWithdrawalOn(_ day: Date, from acct: BankAccount) async -> Bool {\n    return await !acct[day].allSatisfy { $0.amount >= Amount.zero }\n    //            ^~~~~~~~~ this access is async\n  }\n  ```\n\n* [SE-0306][]:\n\n  Swift 5.5 includes support for actors, a new kind of type that isolates its instance data to protect it from concurrent access. Accesses to an actor's instance declarations from outside the must be asynchronous:\n\n  ```swift\n  actor Counter {\n    var value = 0\n\n    func increment() {\n      value = value + 1\n    }\n  }\n\n  func useCounter(counter: Counter) async {\n    print(await counter.value) // interaction must be async\n    await counter.increment()  // interaction must be async\n  }\n  ```\n\n* The determination of whether a call to a `rethrows` function can throw now considers default arguments of `Optional` type.\n\n  In Swift 5.4, such default arguments were ignored entirely by `rethrows` checking. This meant that the following example was accepted:\n\n  ```swift\n  func foo(_: (() throws -> ())? = nil) rethrows {}\n  foo()  // no 'try' needed\n  ```\n\n  However, it also meant that the following was accepted, even though the call to `foo()` can throw and the call site is not marked with `try`:\n\n  ```swift\n  func foo(_: (() throws -> ())? = { throw myError }) rethrows {}\n  foo()  // 'try' *should* be required here\n  ```\n\n  The new behavior is that the first example is accepted because the default argument is syntactically written as `nil`, which is known not to throw. The second example is correctly rejected, on account of missing a `try` since the default argument *can* throw.\n\n* [SE-0293][]:\n\n  Property wrappers can now be applied to function and closure parameters:\n\n  ```swift\n  @propertyWrapper\n  struct Wrapper<Value> {\n    var wrappedValue: Value\n\n    var projectedValue: Self { return self }\n\n    init(wrappedValue: Value) { ... }\n\n    init(projectedValue: Self) { ... }\n  }\n\n  func test(@Wrapper value: Int) {\n    print(value)\n    print($value)\n    print(_value)\n  }\n\n  test(value: 10)\n\n  let projection = Wrapper(wrappedValue: 10)\n  test($value: projection)\n  ```\n\n  The call-site can pass a wrapped value or a projected value, and the property wrapper will be initialized using `init(wrappedValue:)` or `init(projectedValue:)`, respectively.\n\n* [SE-0299][]:\n\n  It is now possible to use leading-dot syntax in generic contexts to access static members of protocol extensions where `Self` is constrained to a fully concrete type:\n\n  ```swift\n  public protocol ToggleStyle { ... }\n\n  public struct DefaultToggleStyle: ToggleStyle { ... }\n\n  extension ToggleStyle where Self == DefaultToggleStyle {\n    public static var `default`: Self { .init() }\n  }\n\n  struct Toggle {\n    func applyToggle<T: ToggleStyle>(_ style: T) { ... }\n  }\n\n  Toggle(...).applyToggle(.default)\n  ```\n\n* Whenever a reference to `Self` does not impede the usage of a protocol as a value type, or a protocol member on a value of protocol type, the same is now true for references to `[Self]` and `[Key : Self]`:\n\n  ```swift\n  protocol Copyable {\n    func copy() -> Self\n    func copy(count: Int) -> [Self]\n  }\n\n  func test(c: Copyable) {\n    let copy: Copyable = c.copy() // OK\n    let copies: [Copyable] = c.copy(count: 5) // also OK\n  }\n  ```\n\n* [SE-0296][]:\n\n  Asynchronous programming is now natively supported using async/await. Asynchronous functions can be defined using `async`:\n\n  ```swift\n  func loadWebResource(_ path: String) async throws -> Resource { ... }\n  func decodeImage(_ r1: Resource, _ r2: Resource) async throws -> Image\n  func dewarpAndCleanupImage(_ i : Image) async -> Image\n  ```\n\n  Calls to `async` functions may suspend, meaning that they give up the thread on which they are executing and will be scheduled to run again later. The potential for suspension on asynchronous calls requires the `await` keyword, similarly to the way in which `try` acknowledges a call to a `throws` function:\n\n  ```swift\n  func processImageData() async throws -> Image {\n    let dataResource  = try await loadWebResource(\"dataprofile.txt\")\n    let imageResource = try await loadWebResource(\"imagedata.dat\")\n    let imageTmp      = try await decodeImage(dataResource, imageResource)\n    let imageResult   = await dewarpAndCleanupImage(imageTmp)\n    return imageResult\n  }\n  ```\n\n* The `lazy` keyword now works in local contexts, making the following valid:\n\n  ```swift\n  func test(useIt: Bool) {\n    lazy var result = getPotentiallyExpensiveResult()\n    if useIt {\n      doIt(result)\n    }\n  }\n  ```\n\n* [SE-0297][]:\n\n  An Objective-C method that delivers its results asynchronously via a completion handler block will be translated into an `async` method that directly returns the result (or throws). For example, the following Objective-C method from [CloudKit](https://developer.apple.com/documentation/cloudkit/ckcontainer/1640387-fetchshareparticipantwithuserrec):\n\n  ```objc\n  - (void)fetchShareParticipantWithUserRecordID:(CKRecordID *)userRecordID\n      completionHandler:(void (^)(CKShareParticipant * _Nullable, NSError * _Nullable))completionHandler;\n  ```\n\n  will be translated into an `async throws` method that returns the participant instance:\n\n  ```swift\n  func fetchShareParticipant(\n      withUserRecordID userRecordID: CKRecord.ID\n  ) async throws -> CKShare.Participant\n  ```\n\n  Swift callers can invoke this `async` method within an `await` expression:\n\n  ```swift\n  guard let participant = try? await container.fetchShareParticipant(withUserRecordID: user) else {\n      return nil\n  }\n  ```\n\n* [SE-0298][]:\n\n  The \"for\" loop can be used to traverse asynchronous sequences in asynchronous code:\n\n  ```swift\n  for try await line in myFile.lines() {\n    // Do something with each line\n  }\n  ```\n\n  Asynchronous for loops use asynchronous sequences, defined by the protocol\n  `AsyncSequence` and its corresponding `AsyncIterator`.\n\n## Swift 5.4\n\n### 2021-04-26 (Xcode 12.5)\n\n* Protocol conformance checking now considers `where` clauses when evaluating if a `typealias` is a suitable witness for an associated type requirement. The following code is now rejected:\n\n  ```swift\n  protocol Holder {\n    associatedtype Contents\n  }\n\n  struct Box<T> : Holder {}\n  // error: type 'Box<T>' does not conform to protocol 'Holder'\n\n  extension Box where T : Hashable {\n    typealias Contents = T\n  }\n  ```\n\n  In most cases, the compiler would either crash or produce surprising results when making use of a `typealias` with an unsatisfied `where` clause, but it is possible that some previously-working code is now rejected. In the above example, the conformance can be fixed in one of various ways:\n\n  1) making it conditional (moving the `: Holder` from the definition of `Box` to the extension)\n  2) moving the `typealias` from the extension to the type itself\n  3) relaxing the `where` clause on the extension\n\n* Availability checking now rejects protocols that refine less available protocols. Previously, this was accepted by the compiler but could result in linker errors or runtime crashes:\n\n  ```swift\n  @available(macOS 11, *)\n  protocol Base {}\n\n  protocol Bad : Base {}\n  // error: 'Base' is only available in macOS 11 or newer\n\n  @available(macOS 11, *)\n  protocol Good : Base {} // OK\n  ```\n\n* The `@available` attribute is no longer permitted on generic parameters, where it had no effect:\n\n  ```swift\n  struct Bad<@available(macOS 11, *) T> {}\n  // error: '@available' attribute cannot be applied to this declaration\n\n  struct Good<T> {} // equivalent\n  ```\n\n* If a type is made to conform to a protocol via an extension, the availability of the extension is now taken into account when forming generic types that use this protocol conformance. For example, consider a `Box` type whose conformance to `Hashable` uses features only available on macOS 11:\n\n  ```swift\n  public struct Box {}\n\n  @available(macOS 11, *)\n  extension Box : Hashable {\n    func hash(into: inout Hasher) {\n      // call some new API to hash the value...\n    }\n  }\n\n  public func findBad(_: Set<Box>) -> Box {}\n  // warning: conformance of 'Box' to 'Hashable' is only available in macOS 11 or newer\n\n  @available(macOS 11, *)\n  public func findGood(_: Set<Box>) -> Box {} // OK\n  ```\n\n  In the above code, it is not valid for `findBad()` to take a `Set<Box>`, since `Set` requires that its element type conform to `Hashable`; however the conformance of `Box` to `Hashable` is not available prior to macOS 11.\n\n  Note that using an unavailable protocol conformance is a warning, not an error, to avoid potential source compatibility issues. This is because it was technically possible to write code in the past that made use of unavailable protocol conformances but worked anyway, if the optimizer had serendipitously eliminated all runtime dispatch through this conformance, or the code in question was entirely unreachable at runtime.\n\n  Protocol conformances can also be marked as completely unavailable or deprecated, by placing an appropriate `@available` attribute on the extension:\n\n  ```swift\n  @available(*, unavailable, message: \"Not supported anymore\")\n  extension Box : Hashable {}\n\n  @available(*, deprecated, message: \"Suggest using something else\")\n  extension Box : Hashable {}\n  ```\n\n  If a protocol conformance is defined on the type itself, it inherits availability from the type. You can move the protocol conformance to an extension if you need it to have narrower availability than the type.\n\n* When `swift` is run with no arguments, it starts a REPL (read eval print loop) that uses LLDB. The compiler also had a second REPL implementation, known as the \"integrated REPL\", formerly accessible by running `swift -frontend -repl`. The \"integrated REPL\" was only intended for use by compiler developers, and has now been removed.\n\n  Note that this does not take away the ability to put Swift code in a script and run it with `swift myScript.swift`. This so-called \"script mode\" is distinct from the integrated REPL, and continues to be supported.\n\n* Property wrappers now work in local contexts, making the following valid:\n\n  ```swift\n  @propertyWrapper\n  struct Wrapper<T> {\n    var wrappedValue: T\n  }\n\n  func test() {\n    @Wrapper var value = 10\n  }\n  ```\n\n* [#52471][]:\n\n  Function overloading now works in local contexts, making the following valid:\n\n  ```swift\n  func outer(x: Int, y: String) {\n    func doIt(_: Int) {}\n    func doIt(_: String) {}\n\n    doIt(x) // calls the first 'doIt(_:)' with an Int value\n    doIt(y) // calls the second 'doIt(_:)' with a String value\n  }\n  ```\n\n* [SE-0284][]:\n\n  Functions, subscripts, and initializers may now have more than one variadic parameter, as long as all parameters which follow variadic parameters are labeled. This makes declarations like the following valid:\n\n  ```swift\n  func foo(_ a: Int..., b: Double...) { }\n\n  struct Bar {\n    subscript(a: Int..., b b: Int...) -> [Int] { a + b }\n\n    init(a: String..., b: Float...) { }\n  }\n  ```\n\n* [SE-0287][]:\n\n  Implicit member expressions now support chains of member accesses, making the following valid:\n  \n  ```swift\n  let milky: UIColor = .white.withAlphaComponent(0.5)\n  let milky2: UIColor = .init(named: \"white\")!.withAlphaComponent(0.5)\n  let milkyChance: UIColor? = .init(named: \"white\")?.withAlphaComponent(0.5)\n  ```\n  \n  As is the case with the existing implicit member expression syntax, the resulting type of the chain must be the same as the (implicit) base, so it is not well-formed to write:\n  \n  ```swift\n  let cgMilky: CGColor = .white.withAlphaComponent(0.5).cgColor\n  ```\n  \n  (Unless, of course, appropriate `white` and `withAlphaComponent` members were defined on `CGColor`.)\n  \n  Members of a \"chain\" can be properties, method calls, subscript accesses, force unwraps, or optional chaining question marks. Furthermore, the type of each member along the chain is permitted to differ (again, as long as the base of the chain matches the resulting type) meaning the following successfully typechecks:\n  \n  ```swift\n  struct Foo {\n    static var foo = Foo()\n    static var bar = Bar()\n    \n    var anotherFoo: Foo { Foo() }\n    func getFoo() -> Foo { Foo() }\n    var optionalFoo: Foo? { Foo() }\n    subscript() -> Foo { Foo() }\n  }\n  \n  struct Bar {\n    var anotherFoo = Foo()\n  }\n\n  let _: Foo? = .bar.anotherFoo.getFoo().optionalFoo?.optionalFoo![]\n  ```\n\n## Swift 5.3\n\n### 2020-09-16 (Xcode 12.0)\n\n* [SE-0279][] & [SE-0286][]:\n\n  Trailing closure syntax has been extended to allow additional labeled closures to follow the initial unlabeled closure:\n  \n  ```swift\n  // Single trailing closure argument\n  UIView.animate(withDuration: 0.3) {\n    self.view.alpha = 0\n  }\n  // Multiple trailing closure arguments\n  UIView.animate(withDuration: 0.3) {\n    self.view.alpha = 0\n  } completion: { _ in\n    self.view.removeFromSuperview()\n  }\n  ```\n  \n  Additionally, trailing closure arguments now match the appropriate parameter according to a forward-scan rule (as opposed to the previous backward-scan rule):\n  \n  ```swift\n  func takesClosures(first: () -> Void, second: (Int) -> Void = { _ in }) {}\n  \n  takesClosures {\n    print(\"First\")\n  }\n  ```\n  \n  In the above example, the trailing closure argument matches parameter `first`, whereas pre-Swift-5.3 it would have matched `second`. In order to ease the transition to this new rule, cases in which the forward-scan and backward-scan match a single trailing closure to different parameters, the backward-scan result is preferred and a warning is emitted. This is expected to be upgraded to an error in the next major version of Swift.\n\n* [#49631][]:\n\n  Property observers such as `willSet` and `didSet` are now supported on `lazy` properties:\n\n  ```swift\n  class C {\n    lazy var property: Int = 0 {\n      willSet { print(\"willSet called!\") } // Okay\n      didSet { print(\"didSet called!\") } // Okay\n    }\n  }\n  ```\n\n  Note that the initial value of the property will be forced and made available as the `oldValue` for the `didSet` observer, if the property hasn't been accessed yet.\n  \n  ```swift\n  class C {\n    lazy var property: Int = 0 {\n      didSet { print(\"Old value: \", oldValue) }\n    }\n  }\n\n  let c = C()\n  c.property = 1 // Prints 'Old value: 0'\n  ```\n\n  This could have side-effects, for example if the lazy property's initializer is doing other work.\n\n* [#54108][]:\n\n  Exclusivity violations within code that computes the `default`\n  argument during Dictionary access are now diagnosed.\n\n  ```swift\n  struct Container {\n     static let defaultKey = 0\n\n     var dictionary = [defaultKey:0]\n\n     mutating func incrementValue(at key: Int) {\n       dictionary[key, default: dictionary[Container.defaultKey]!] += 1\n     }\n  }\n  // error: overlapping accesses to 'self.dictionary', but modification requires exclusive access; consider copying to a local variable\n  //     dictionary[key, default: dictionary[Container.defaultKey]!] += 1\n  //     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  // note: conflicting access is here\n  //     dictionary[key, default: dictionary[Container.defaultKey]!] += 1\n  //                              ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~\n  ```\n\n  The exclusivity violation can be avoided by precomputing the `default`\n  argument using a local variable.\n\n  ```swift\n  struct Container {\n    static let defaultKey = 0\n\n    var dictionary = [defaultKey:0]\n\n    mutating func incrementValue(at key: Int) {\n      let defaultValue = dictionary[Container.defaultKey]!\n      dictionary[key, default: defaultValue] += 1\n    }\n  }\n  // No error.\n  ```\n\n* [SE-0268][]:\n  \n  A `didSet` observer which does not refer to the `oldValue` in its body or does not explicitly request it by placing it in the parameter list (i.e. `didSet(oldValue)`) will no longer trigger a call to the property getter to fetch the `oldValue`.\n  \n  ```swift\n  class C {\n    var value: Int = 0 {\n      didSet { print(\"didSet called!\") }\n    }\n  }\n  \n  let c = C()\n  // This does not trigger a call to the getter for 'value'\n  // because the 'didSet' observer on 'value' does not\n  // refer to the 'oldValue' in its body, which means\n  // the 'oldValue' does not need to be fetched.\n  c.value = 1\n  ```\n  \n* [SE-0276][]:\n\n  Catch clauses in a `do`-`catch` statement can now include multiple patterns in a comma-separated list. The body of a `catch` clause will be executed if a thrown error matches any of its patterns.\n\n  ```swift\n  do {\n    try performTask()\n  } catch TaskError.someFailure(let msg),\n          TaskError.anotherFailure(let msg) {\n    showMessage(msg)\n  }\n  ```\n\n* [SE-0280][]:\n  \n  Enum cases can now satisfy static protocol requirements. A static get-only property of type `Self` can be witnessed by an enum case with no associated values and a static function with arguments and returning `Self` can be witnessed by an enum case with associated values.\n  \n  ```swift\n  protocol P {\n    static var foo: Self { get }\n    static func bar(value: Int) -> Self\n  }\n  \n  enum E: P {\n    case foo // matches 'static var foo'\n    case bar(value: Int) // matches 'static func bar(value:)'\n  }\n  ```\n\n* [SE-0267][]:\n  \n  Non-generic members that support a generic parameter list, including nested type declarations, are now allowed to carry a contextual `where` clause against outer generic parameters. Previously, such declarations could only be expressed by placing the member inside a dedicated constrained extension.\n\n  ```swift\n  struct Box<Wrapped> {\n    func boxes() -> [Box<Wrapped.Element>] where Wrapped: Sequence { ... }\n  }\n  ```\n  Since contextual `where` clauses are effectively visibility constraints, overrides adopting this feature must be at least as visible as the overridden method. In practice, this implies any instance of `Derived` that can access `Base.foo` must also be able to access `Derived.foo`.\n  \n  ```swift\n  class Base<T> {\n    func foo() where T == Int { ... }\n  }\n  \n  class Derived<U>: Base<U> {\n    // OK, <U where U: Equatable> has broader visibility than <T where T == Int>\n    override func foo() where U: Equatable { ... } \n  }\n\n* [#42697][]:\n\n  Unapplied references to protocol methods are now supported. Previously this\n  only worked for methods defined in structs, enums and classes.\n\n  ```swift\n  protocol Cat {\n    func play(catToy: Toy)\n  }\n\n  let fn = Cat.play(catToy:)\n  fn(myCat)(myToy)\n  ```\n\n* [SE-0266][]:\n  \n  Enumerations with no associated values, or only `Comparable` associated values, can opt-in to synthesized `Comparable` conformance by declaring conformance to the `Comparable` protocol. The synthesized implementation orders the cases first by case-declaration order, and then by lexicographic order of the associated values (if any).\n  \n  ```swift\n  enum Foo: Comparable {\n    case a(Int), b(Int), c\n  }\n  \n  // .a(0) < .a(1) < .b(0) < .b(1) < .c\n  ```\n\n* [SE-0269][]:\n\n  When an escaping closure explicitly captures `self` in its capture list, the\n  use of implicit `self` is enabled within that closure. This means that the\n  following code is now valid:\n  \n  ```swift\n  func doStuff(_ stuff: @escaping () -> Void) {}\n  \n  class C {\n    var x = 0\n\n    func method() {\n      doStuff { [self] in\n        x += 1\n      }\n    }\n  }\n  ```\n  \n  This proposal also introduces new diagnostics for inserting `self` into the\n  closure's capture list in addition to the existing 'use `self.` explicitly'\n  fix-it.\n\n## Swift 5.2\n\n### 2020-03-24 (Xcode 11.4)\n\n* [#54246][]:\n\n  When chaining calls to `filter(_:)` on a lazy sequence or collection, the\n  filtering predicates will now be called in the same order as eager filters.\n  \n  ```swift\n  let evens = (1...10).lazy\n      .filter { $0.isMultiple(of: 2) }\n      .filter { print($0); return true }\n  _ = evens.count\n  // Prints 2, 4, 6, 8, and 10 on separate lines\n  ```\n  \n  Previously, the predicates were called in reverse order.\n  \n* [apple/swift-corelibs-foundation#4326][]:\n\n  The compiler will now emit a warning when attempting to pass a temporary\n  pointer argument produced from an array, string, or inout argument to a\n  parameter which is known to escape it. This includes the various initializers \n  for the `UnsafePointer`/`UnsafeBufferPointer` family of types, as well as\n  memberwise initializers.\n\n  ```swift\n  struct S {\n    var ptr: UnsafePointer<Int8>\n  }\n\n  func foo() {\n    var i: Int8 = 0\n    let ptr = UnsafePointer(&i)\n    // warning: initialization of 'UnsafePointer<Int8>' results in a \n    // dangling pointer\n    \n    let s1 = S(ptr: [1, 2, 3]) \n    // warning: passing '[Int8]' to parameter, but argument 'ptr' should be a\n    // pointer that outlives the call to 'init(ptr:)'\n    \n    let s2 = S(ptr: \"hello\")\n    // warning: passing 'String' to parameter, but argument 'ptr' should be a\n    // pointer that outlives the call to 'init(ptr:)'\n  }\n  ```\n\n  All 3 of the above examples are unsound because each argument produces a\n  temporary pointer only valid for the duration of the call they are passed to.\n  Therefore the returned value in each case references a dangling pointer.\n\n* [#44797][]:\n\n  The compiler now supports local functions whose default arguments capture\n  values from outer scopes.\n\n  ```swift\n  func outer(x: Int) -> (Int, Int) {\n    func inner(y: Int = x) -> Int {\n      return y\n    }\n\n    return (inner(), inner(y: 0))\n  }\n  ```\n\n* [#53830][]:\n\n  The compiler will now correctly strip argument labels from function references\n  used with the `as` operator in a function call. As a result, the `as` operator\n  can now be used to disambiguate a call to a function with argument labels. \n  \n  ```swift\n  func foo(x: Int) {}\n  func foo(x: UInt) {}\n  \n  (foo as (Int) -> Void)(5)  // Calls foo(x: Int)\n  (foo as (UInt) -> Void)(5) // Calls foo(x: UInt)\n  ```\n  \n  Previously this was only possible for functions without argument labels.\n  \n  This change also means that a generic type alias can no longer be used to\n  preserve the argument labels of a function reference through the `as`\n  operator. The following is now rejected:\n  \n  ```swift\n  typealias Magic<T> = T\n  func foo(x: Int) {}\n  (foo as Magic)(x: 5) // error: Extraneous argument label 'x:' in call\n  ```\n  \n  The function value must instead be called without argument labels:\n  \n  ```swift\n  (foo as Magic)(5)\n  ```\n\n* [#53699][]:\n\n  A class-constrained protocol extension, where the extended protocol does\n  not impose a class constraint, will now infer the constraint implicitly.\n\n  ```swift\n  protocol Foo {}\n  class Bar: Foo {\n    var someProperty: Int = 0\n  }\n\n  // Even though 'Foo' does not impose a class constraint, it is automatically\n  // inferred due to the Self: Bar constraint.\n  extension Foo where Self: Bar {\n    var anotherProperty: Int {\n      get { return someProperty }\n      // As a result, the setter is now implicitly nonmutating, just like it would\n      // be if 'Foo' had a class constraint.\n      set { someProperty = newValue }\n    }\n  }\n  ```\n\n* [SE-0253][]:\n\n  Values of types that declare `func callAsFunction` methods can be called\n  like functions. The call syntax is shorthand for applying\n  `func callAsFunction` methods.\n\n  ```swift\n  struct Adder {\n    var base: Int\n    func callAsFunction(_ x: Int) -> Int {\n      return x + base\n    }\n  }\n  var adder = Adder(base: 3)\n  adder(10) // returns 13, same as `adder.callAsFunction(10)`\n  ```\n\n  * `func callAsFunction` argument labels are required at call sites.\n  * Multiple `func callAsFunction` methods on a single type are supported.\n  * `mutating func callAsFunction` is supported.\n  * `func callAsFunction` works with `throws` and `rethrows`.\n  * `func callAsFunction` works with trailing closures.\n  \n* [SE-0249][]:\n\n  A `\\Root.value` key path expression is now allowed wherever a `(Root) -> Value` \n  function is allowed. Such an expression is implicitly converted to a key path \n  application of `{ $0[keyPath: \\Root.value] }`.\n  \n  For example:\n  \n  ```swift\n  struct User {\n    let email: String\n    let isAdmin: Bool\n  }\n  \n  users.map(\\.email) // this is equivalent to: users.map { $0[keyPath: \\User.email] }\n  ```\n\n* [#46789][]:\n\n  A method override is no longer allowed to have a generic signature with\n  requirements not imposed by the base method. For example:\n\n  ```swift\n  protocol P {}\n  \n  class Base {\n    func foo<T>(arg: T) {}\n  }\n  \n  class Derived: Base {\n    override func foo<T: P>(arg: T) {}\n  }\n  ```\n\n  will now be diagnosed as an error.\n\n* [#48673][]:\n\n  Subscripts can now declare default arguments:\n\n  ```swift\n  struct Subscriptable {\n    subscript(x: Int, y: Int = 0) {\n      ...\n    }\n  }\n\n  let s = Subscriptable()\n  print(s[0])\n  ```\n\n## Swift 5.1\n\n### 2019-09-20 (Xcode 11.0)\n\n* [#51478][]:\n\n  Duplicate tuple element labels are no longer allowed, because it leads\n  to incorrect behavior. For example:\n\n  ```swift\n  let dupLabels: (foo: Int, foo: Int) = (foo: 1, foo: 2)\n\n  enum Foo { case bar(x: Int, x: Int) }\n  let f: Foo = .bar(x: 0, x: 1)\n  ```\n\n  will now be diagnosed as an error. \n\n  Note: You can still use duplicate argument labels when declaring functions and\n  subscripts, as long as the internal parameter names are different. For example:\n\n  ```swift\n  func foo(bar x: Int, bar y: Int) {}\n  subscript(a x: Int, a y: Int) -> Int {}\n  ```\n\n* [SE-0244][]:\n\n  Functions can now hide their concrete return type by declaring what protocols\n  it conforms to instead of specifying the exact return type:\n\n  ```swift\n  func makeMeACollection() -> some Collection {\n    return [1, 2, 3]\n  }\n  ```\n\n  Code that calls the function can use the interface of the protocol, but\n  does not have visibility into the underlying type.\n\n* [SE-0254][]:\n\n  Subscripts can now be declared `static` or (inside classes) `class`.\n\n* [SE-0252][]:\n\n  The existing `@dynamicMemberLookup` attribute has been extended with a\n  support for strongly-typed keypath implementations:\n\n  ```swift\n  @dynamicMemberLookup\n  struct Lens<T> {\n    let getter: () -> T\n    let setter: (T) -> Void\n\n    var value: T {\n      get {\n        return getter()\n      }\n      set {\n        setter(newValue)\n      }\n    }\n\n    subscript<U>(dynamicMember keyPath: WritableKeyPath<T, U>) -> Lens<U> {\n      return Lens<U>(\n          getter: { self.value[keyPath: keyPath] },\n          setter: { self.value[keyPath: keyPath] = $0 })\n    }\n  }\n  ```\n\n* [#51064][], [#51546][]:\n\n  More thorough checking has been implemented for restrictions around\n  escaping closures capturing `inout` parameters or values of noescape type.\n  While most code should not be affected, there are edge cases where\n  the Swift 5.0 compiler would accept code violating these restrictions.\n  This could result in runtime crashes or silent data corruption.\n  \n  An example of invalid code which was incorrectly accepted by the Swift 5.0\n  compiler is an `@escaping` closure calling a local function which\n  references an `inout` parameter from an outer scope:\n\n  ```swift\n  struct BadCaptureExample {\n    var escapingClosure: () -> ()\n\n    mutating func takesInOut(_ x: inout Int) {\n      func localFunction() {\n        x += 1\n      }\n\n      escapingClosure = { localFunction() }\n    }\n  }\n  ```\n\n  The compiler now correctly diagnoses the above code by pointing out that\n  the capture of `x` by `localFunction()` is invalid, since `localFunction()`\n  is referenced from an `@escaping` closure.\n\n  This also addresses certain cases where the compiler incorrectly diagnosed\n  certain code as invalid, when in fact no violation of restrictions had\n  taken place. For example,\n\n  ```swift\n  func takesNoEscape(_ fn: () -> ()) {\n    func localFunction() {\n      fn()\n    }\n\n    { localFunction() }()\n  }\n  ```\n\n* [#45277][]:\n\n  Conversions between tuple types are now fully implemented.\n  Previously, the following would diagnose an error:\n\n  ```swift\n  let values: (Int, Int) = (10, 15)\n  let converted: (Int?, Any) = values\n\n* [SE-0242][]:\n\n  The memberwise initializer for structures now provide default values for variables that hold default expressions.\n\n  ```swift\n  struct Dog {\n    var name = \"Generic dog name\"\n    var age = 0\n\n    // The synthesized memberwise initializer\n    init(name: String = \"Generic dog name\", age: Int = 0)\n  }\n\n  let sparky = Dog(name: \"Sparky\") // Dog(name: \"Sparky\", age: 0)\n  ```\n\n* [SE-0068][]:\n\n  It is now possible to use `Self` to refer to the innermost nominal\n  type inside struct, enum and class declarations. For example, the\n  two method declarations inside this struct are equivalent:\n  \n  ```swift\n  struct Box<Value> {\n    func transform1() -> Self { return self }\n    func transform2() -> Box<Value> { return self }\n  }\n  ```\n\n  In classes, `Self` is the dynamic type of the `self` value, as before.\n  Existing restrictions on `Self` in declaration types still apply;\n  that is, `Self` can only appear as the return type of a method.\n  However, `Self` can now be used inside the body of a method\n  without limitation.\n\n* [#50338][]:\n\n  Enum cases can now be matched against an optional enum without\n  requiring a '?' at the end of the pattern.\n\n  ```swift\n  enum Foo { case zero, one }\n\n  let foo: Foo? = .zero\n\n  switch foo {\n    case .zero: break\n    case .one: break\n    case .none: break\n  }\n  ```\n\n* [#52244][]:\n\n  `weak` and `unowned` stored properties no longer inhibit the\n   automatic synthesis of `Equatable` or `Hashable` conformance.\n\n* [#45293][]:\n\n  An `@autoclosure` parameter can now be declared with a typealias type.\n\n  ```swift\n  class Foo {\n    typealias FooClosure = () -> String\n    func fooFunction(closure: @autoclosure FooClosure) {}\n  }\n  ```\n\n* [#50143][]:\n\n  Methods declared `@objc` inside a class can now return `Self`:\n\n  ```swift\n  class MyClass : NSObject {\n    @objc func clone() -> Self { return self }\n  }\n  ```\n\n* [#44784][]:\n\n  Assigning '.none' to an optional enum which also has a 'none' case\n  or comparing such an enum with '.none' will now warn. Such expressions\n  create an ambiguity because the compiler chooses Optional.none\n  over Foo.none.\n\n  ```swift\n  enum Foo { case none }\n\n  // Assigned Optional.none instead of Foo.none\n  let foo: Foo? = .none\n  // Comparing with Optional.none instead of Foo.none\n  let isEqual = foo == .none\n  ```\n\n  The compiler will provide a warning along with a fix-it to\n  replace '.none' with 'Optional.none' or 'Foo.none' to resolve\n  the ambiguity.\n\n* Key path expressions can now include references to tuple elements.\n\n* Single-parameter functions accepting values of type `Any` are no\n  longer preferred over other functions.\n\n  ```swift\n  func foo(_: Any) { print(\"Any\") }\n  func foo<T>(_: T) { print(\"T\") }\n  foo(0) // prints \"Any\" in Swift < 5.1, \"T\" in Swift 5.1\n  ```\n\n* [SE-0245][]:\n\n  `Array` and `ContiguousArray` now have `init(unsafeUninitializedCapacity:initializingWith:)`,\n  which provides access to the array's uninitialized storage.\n\n## Swift 5.0\n\n### 2019-03-25 (Xcode 10.2)\n\n* [SE-0235][]:\n\n  The standard library now contains a `Result` type for manually propagating errors.\n  \n  ```swift\n  enum Result<Success, Failure: Error> {\n      case success(Success)\n      case failure(Failure)\n  }\n  ```\n  \n  This type serves a complementary role to that of throwing functions and initializers. \n  Use `Result` in situations where automatic error propagation or `try`-`catch` \n  blocks are undesirable, such as in asynchronous code or when accumulating the \n  results of successive error-producing operations.\n  \n* `Error` now conforms to itself. This allows for the use of `Error` itself as \n  the argument for a generic parameter constrained to `Error`.\n\n* Swift 3 mode has been removed. Supported values for the `-swift-version`\n  flag are `4`, `4.2`, and `5`.\n\n* [SE-0228][]:\n\n  String interpolation has been overhauled to improve its performance,\n  clarity, and efficiency.\n\n  Note that the old `_ExpressibleByStringInterpolation` protocol has been\n  removed; any code making use of this protocol will need to be updated\n  for the new design. An `#if compiler` block can be used to conditionalize\n  code between 4.2 and 5.0, for example:\n  \n  ```swift\n  #if compiler(<5.0)\n  extension MyType : _ExpressibleByStringInterpolation { ... }\n  #else\n  extension MyType : ExpressibleByStringInterpolation { ... }\n  #endif\n  ```\n\n* [SE-0213][]:\n\n  If `T` conforms to one of the `ExpressibleBy*` protocols and `literal` is a\n  literal expression, then `T(literal)` will construct a literal of type `T`\n  using the corresponding protocol, rather than calling a constructor member\n  of `T` with a value of  the protocol's default literal type.\n\n  For example, expressions like `UInt64(0xffff_ffff_ffff_ffff)` are now valid,\n  where previously they would overflow the default integer literal type of `Int`.\n\n* [SE-0230][]:\n\n  In Swift 5 mode, `try?` with an expression of Optional type will flatten the\n  resulting Optional, instead of returning an Optional of an Optional.\n\n* [#48289][]:\n\n  In Swift 5 mode, `@autoclosure` parameters can no longer be forwarded to\n  `@autoclosure` arguments in another function call. Instead, you must explicitly\n  call the function value with `()`; the call itself is wrapped inside an\n  implicit closure, guaranteeing the same behavior as in Swift 4 mode.\n\n  Example:\n\n  ```swift\n  func foo(_ fn: @autoclosure () -> Int) {}\n  func bar(_ fn: @autoclosure () -> Int) {\n    foo(fn)   // Incorrect, `fn` can't be forwarded and has to be called\n    foo(fn()) // Ok\n  }\n  ```\n\n* [#50641][]:\n\n  Single-element labeled tuple expressions, for example `(label: 123)`, were\n  allowed in some contexts but often resulted in surprising, inconsistent\n  behavior that varied across compiler releases. They are now completely\n  disallowed.\n\n  Note that single-element labeled _types_, for example `var x: (label: Int)`,\n  have already been prohibited since Swift 3.\n\n* [#43310][]:\n\n  In Swift 5 mode, a class method returning `Self` can no longer be overridden\n  with a method returning a non-final concrete class type. Such code is not\n  type safe and will need to be updated.\n\n  For example,\n\n  ```swift\n  class Base {\n    class func factory() -> Self { ... }\n  }\n\n  class Derived : Base {\n    class override func factory() -> Derived { ... }\n  }\n  ```\n\n* In Swift 5 mode, the type of `self` in a convenience initializer of a non-final\n  class is now the dynamic `Self` type, and not the concrete class type.\n\n* [#48153][]:\n\n  Protocols can now constrain their conforming types to those that subclasses a\n  given class. Two equivalent forms are supported:\n\n  ```swift\n  protocol MyView : UIView { ... }\n  protocol MyView where Self : UIView { ... }\n  ```\n\n  Note that Swift 4.2 accepted the second form, but it was not fully implemented\n  and could sometimes crash at compile time or run time.\n\n* [#43248][]:\n\n  Extension binding now supports extensions of nested types which themselves are\n  defined inside extensions. Previously this could fail with some declaration orders,\n  producing spurious \"undeclared type\" errors.\n\n* [#49687][]:\n\n  Exclusive memory access is now enforced at runtime by default in\n  optimized (`-O`/`-Osize`) builds. Programs that violate exclusivity will\n  trap at runtime with an \"overlapping access\" diagnostic\n  message. This can be disabled via a command line flag:\n  `-enforce-exclusivity=unchecked`, but doing so may result in undefined\n  behavior.\n\n  Runtime violations of exclusivity typically result from\n  simultaneous access of class properties, global variables (including\n  variables in top-level code), or variables captured by escaping\n  closures.\n\n* [SE-0216][]:\n\n  The `@dynamicCallable` attribute enables nominal types to be \"callable\" via a\n  simple syntactic sugar. The primary use case is dynamic language\n  interoperability.\n\n  Toy example:\n\n  ```swift\n  @dynamicCallable\n  struct ToyCallable {\n    func dynamicallyCall(withArguments: [Int]) {}\n    func dynamicallyCall(withKeywordArguments: KeyValuePairs<String, Int>) {}\n  }\n  let x = ToyCallable()\n  x(1, 2, 3) // desugars to `x.dynamicallyCall(withArguments: [1, 2, 3])`\n  x(label: 1, 2) // desugars to `x.dynamicallyCall(withKeywordArguments: [\"label\": 1, \"\": 2])`\n  ```\n\n* [#49799][]:\n\n  In Swift 5 mode, attempting to declare a static property with the same name as a\n  nested type is now always correctly rejected. Previously, it was possible to\n  perform such a redeclaration in an extension of a generic type.\n  \n  For example:\n  ```swift\n  struct Foo<T> {}\n  extension Foo {\n    struct i {}\n    \n    // compiler error: Invalid redeclaration of 'i'\n    // (prior to Swift 5, this did not produce an error)\n    static var i: Int { return 0 }\n  }\n  ```\n\n* [#46831][]:\n\n  In Swift 5 mode, when casting an optional value to a generic placeholder type,\n  the compiler will be more conservative with the unwrapping of the value. The \n  result of such a cast now more closely matches the result you would get in a\n  non-generic context.\n  \n  For example:\n  ```swift\n  func forceCast<U>(_ value: Any?, to type: U.Type) -> U {\n    return value as! U\n  }\n\n  let value: Any? = 42\n  print(forceCast(value, to: Any.self)) \n  // prints: Optional(42)\n  // (prior to Swift 5, this would print: 42)\n  \n  print(value as! Any)                  \n  // prints: Optional(42)\n  ```\n\n* [SE-0227][]:\n\n  Key paths now support the `\\.self` keypath, which is a `WritableKeyPath`\n  that refers to its entire input value:\n\n    ```swift\n    let id = \\Int.self\n\n    var x = 2\n    print(x[keyPath: id]) // prints 2\n    x[keyPath: id] = 3\n    print(x[keyPath: id]) // prints 3\n    ```\n\n* [SE-0214][]:\n\n  The `DictionaryLiteral` type has been renamed to `KeyValuePairs`.\n  A typealias preserves the old name for compatibility.\n\n* [#45213][]\n\n  Default arguments are now printed in SourceKit-generated interfaces for Swift\n  modules, instead of just using a placeholder `default`.\n\n* `unowned` and `unowned(unsafe)` variables now support Optional types.\n\n* Designated initializers with variadic parameters are now correctly inherited\n  in subclasses.\n\n* Extensions of concrete subclasses of generic classes can now contain\n  `@objc` members.\n\n* Complex recursive type definitions involving classes and generics that would\n  previously cause deadlocks at run time are now fully supported.\n\n* [#43036][]\n\n  In Swift 5 mode, when setting a property from within its own `didSet` or\n  `willSet` observer, the observer will now only avoid being recursively called\n  if the property is set on `self` (either implicitly or explicitly).\n\n  For example:\n  ```swift\n  class Node {\n    var children = [Node]()\n\n    var depth: Int = 0 {\n      didSet {\n        if depth < 0 {\n          // Will not recursively call didSet, as setting depth on self (same\n          // with `self.depth = 0`).\n          depth = 0\n        }\n\n        // Will call didSet for each of the children, as we're not setting the\n        // property on self (prior to Swift 5, this did not trigger property\n        // observers to be called again).\n        for child in children {\n          child.depth = depth + 1\n        }\n      }\n    }\n  }\n  ```\n\n## Swift 4.2\n\n### 2018-09-17 (Xcode 10.0)\n\n* [SE-0202][]\n\n  The standard library now provides a unified set of randomization functionality.\n  Integer types, floating point types, and Bool all introduce a new static\n  method that creates a random value.\n  \n  ```swift\n  let diceRoll = Int.random(in: 1 ... 6)\n  let randomUnit = Double.random(in: 0 ..< 1)\n  let randomBool = Bool.random()\n  ```\n  \n  There are also additions to select a random element from a collection or\n  shuffle its contents.\n  \n  ```swift\n  let greetings = [\"hey\", \"hello\", \"hi\", \"hola\"]\n  let randomGreeting = greetings.randomElement()! // This returns an Optional\n  let newGreetings = greetings.shuffled() // [\"hola\", \"hi\", \"hey\", \"hello\"]\n  ```\n\n  Core to the randomization functionality is a new `RandomNumberGenerator`\n  protocol. The standard library defines its own random number generator\n  called `SystemRandomNumberGenerator` which is backed by a secure and\n  thread-safe random number generator on each platform. All the randomization\n  functions have a `using:` parameter that take a `RandomNumberGenerator` that\n  users can pass in their own random number generator.\n  \n  ```swift\n  struct MersenneTwister: RandomNumberGenerator {\n    func next() -> UInt64 {\n      // implementation\n    }\n  }\n  \n  var mt = MersenneTwister()\n  let diceRoll = Int.random(in: 1 ... 6, using: &mt)\n  ```\n\n* [SE-0194][]\n\n  The new CaseIterable protocol describes types which have a static\n  “allCases” property that is used to describe all of the cases of the\n  type. Swift will synthesize this “allCases” property for enums that\n  have no associated values. For example:\n\n  ```swift\n  enum Suit: CaseIterable {\n    case heart\n    case club\n    case diamond\n    case spade\n  }\n\n  print(Suit.allCases) // prints [Suit.heart, Suit.club, Suit.diamond, Suit.spade]\n  ```\n\n* [SE-0185][]\n\n  Protocol conformances are now able to be synthesized in extensions in the same\n  file as the type definition, allowing automatic synthesis of conditional\n  conformances to `Hashable`, `Equatable` and `Codable` (both `Encodable` and\n  `Decodable`). For instance, if there is a generic wrapper type that can only\n  be `Equatable` when its wrapped type is also `Equatable`, the `==` method can\n  be automatically constructed by the compiler:\n\n  ```swift\n  struct Generic<Param> {\n    var property: Param\n  }\n\n  extension Generic: Equatable where Param: Equatable {}\n  // Automatically synthesized inside the extension:\n  // static func ==(lhs: Generic, rhs: Generic) -> Bool {\n  //   return lhs.property == rhs.property\n  // }\n  ```\n\n  Code that wants to be as precise as possible should generally not\n  conditionally conform to `Codable` directly, but rather its two constituent\n  protocols `Encodable` and `Decodable`, or else one can only (for instance)\n  decode a `Generic<Param>` if `Param` is `Encodable` in addition to\n  `Decodable`, even though `Encodable` is likely not required:\n\n  ```swift\n  // Unnecessarily restrictive:\n  extension Generic: Codable where Param: Codable {}\n\n  // More precise:\n  extension Generic: Encodable where Param: Encodable {}\n  extension Generic: Decodable where Param: Decodable {}\n  ```\n\n  Finally, due to `Decodable` having an `init` requirement, it is not possible\n  to conform to `Decodable` in an extension of a non-final class: such a class\n  needs to have any `init`s from protocols be `required`, which means they need\n  to be in the class definition.\n\n\n* [SE-0054][]\n\n  `ImplicitlyUnwrappedOptional<T>` is now an unavailable typealias of `Optional<T>`.\n  Declarations annotated with `!` have the type `Optional<T>`. If an\n  expression involving one of these values will not compile successfully with the\n  type `Optional<T>`, it is implicitly unwrapped, producing a value of type `T`.\n\n  In some cases this change will cause code that previously compiled to\n  need to be adjusted. Please see [this blog post](https://swift.org/blog/iuo/)\n  for more information.\n\n* [SE-0206][]\n\n    The standard library now uses a high-quality, randomly seeded, universal\n    hash function, represented by the new public `Hasher` struct.\n  \n    “Random seeding” varies the result of `hashValue` on each execution of a\n    Swift program, improving the reliability of the standard library's hashed\n    collections such as `Set` and `Dictionary`. In particular, random seeding\n    enables better protection against (accidental or deliberate) hash-flooding\n    attacks.\n    \n    This change fulfills a long-standing prophecy in Hashable's documentation:\n\n    > Hash values are not guaranteed to be equal across different executions of\n    > your program. Do not save hash values to use during a future execution.\n    \n    As a consequence of random seeding, the elements in `Set` and `Dictionary`\n    values may have a different order on each execution. This may expose some\n    bugs in existing code that accidentally relies on repeatable ordering.\n\n    Additionally, the `Hashable` protocol now includes an extra function\n    requirement, `hash(into:)`. The new requirement is designed to be much\n    easier to implement than the old `hashValue` property, and it generally\n    provides better hashing. To implement `hash(into:)`, simply feed the exact\n    same components of your type that you compare in `Equatable`'s `==`\n    implementation to the supplied `Hasher`:\n    \n    ```swift\n    struct Foo: Hashable {\n      var a: String?\n      var b: [Int]\n      var c: [String: Int]\n      \n      static func ==(lhs: Foo, rhs: Foo) -> Bool {\n        return lhs.a == rhs.a && lhs.b == rhs.b && lhs.c == rhs.c\n      }\n      \n      func hash(into hasher: inout Hasher) {\n        hasher.combine(a)\n        hasher.combine(b)\n        hasher.combine(c)\n      }\n    }\n    ```\n    \n    Automatic synthesis for `Hashable` ([SE-0185]) has been updated to generate\n    `hash(into:)` implementations. For example, the `==` and `hash(into:)`\n    implementations above are equivalent to the ones synthesized by the\n    compiler, and can be removed without changing the meaning of the code.\n    \n    Synthesis has also been extended to support deriving `hashValue` from\n    `hash(into:)`, and vice versa. Therefore, code that only implements\n    `hashValue` continues to work in Swift 4.2. This new compiler functionality\n    works for all types that can implement `Hashable`, including classes.\n    \n    Note that these changes don't affect Foundation's hashing interface. Classes\n    that subclass `NSObject` should override the `hash` property, like before.\n\n    In certain controlled environments, such as while running particular tests,\n    it may be helpful to selectively disable hash seed randomization, so that\n    hash values and the order of elements in `Set`/`Dictionary` values remain\n    consistent across executions. You can disable hash seed randomization by\n    defining the environment variable `SWIFT_DETERMINISTIC_HASHING` with the\n    value of `1`. The Swift runtime looks at this variable during process\n    startup and, if it is defined, replaces the random seed with a constant\n    value.\n  \n* [#42728][]\n\n  The behavior of `.description` and `.debugDescription` for floating-point\n  numbers has been changed. Previously these unconditionally printed a fixed\n  number of decimal digits (e.g. 15 and 17 for Double, respectively). They now\n  print exactly as many digits as are needed for the resulting string to\n  convert back to the original source value, and no more. For more details,\n  see the original bug report and the linked pull request.\n\n* [SE-0193][]\n\n  Various function-like declarations can now be marked as `@inlinable`,\n  making their bodies available for optimizations from other modules.\n\n  Inlinable function bodies must only reference public declarations, unless\n  the referenced declaration is marked as `@usableFromInline`.\n\n  Note that the presence of the attribute itself does not force inlining or\n  any other optimization to be performed, nor does it have any effect on\n  optimizations performed within a single module.\n\n* The C `long double` type is now imported as `Float80` on i386 and x86_64\n  macOS and Linux. The tgmath functions in the Darwin and glibc modules now\n  support `Float80` as well as `Float` and `Double`. Several tgmath\n  functions have been made generic over `[Binary]FloatingPoint` so that they\n  will automatically be available for any conforming type.\n\n* [SE-0143][]\n\n  The standard library types `Optional`, `Array`, `ArraySlice`,\n  `ContiguousArray`, `Dictionary`, `Range`, and `ClosedRange` now conform to the\n  `Hashable` protocol when their element or bound types (as the case may be)\n  conform to `Hashable`.  This makes synthesized `Hashable` implementations\n  available for types that include stored properties of these types.\n\n* [SE-0196][]\n  \n  Custom compile-time warnings or error messages can be emitted using the\n  `#warning(_:)` and `#error(_:)` directives.\n\n  ```swift\n  #warning(\"this is incomplete\")\n\n  #if MY_BUILD_CONFIG && MY_OTHER_BUILD_CONFIG\n    #error(\"MY_BUILD_CONFIG and MY_OTHER_BUILD_CONFIG cannot both be set\")\n  #endif\n  ```\n\n* Public classes may now have internal `required` initializers. The rule for\n  `required` initializers is that they must be available everywhere the class\n  can be subclassed, but previously we said that `required` initializers on\n  public classes needed to be public themselves. (This limitation is a holdover\n  from before the introduction of the open/public distinction in Swift 3.)\n\n* C macros containing casts are no longer imported to Swift if the type in the\n  cast is unavailable or deprecated, or produces some other diagnostic when\n  referenced. (These macros were already only imported under very limited\n  circumstances with very simple values, so this is unlikely to affect\n  real-world code.)\n\n* [SE-0143][]\n\n  Runtime query of conditional conformances is now implemented. Therefore,\n  a dynamic cast such as `value as? P`, where the dynamic type of `value`\n  conditionally conforms to `P`, will succeed when the conditional\n  requirements are met.\n\n## Swift 4.1\n\n### 2018-03-29 (Xcode 9.3)\n\n* [SE-0075][]\n\n  Compile-time testing for the existence and importability of modules is now\n  implemented as a build configuration test.  The `canImport` test allows\n  the development of features that require a possibly-failing import \n  declaration across multiple platforms.  \n\n  ```swift\n  #if canImport(UIKit)\n    import UIKit\n    class MyView : UIView {}\n  #elseif canImport(AppKit)\n    import AppKit\n    class MyView : NSView {}\n  #else\n    class MyView : CustomView {}\n  #endif\n  ```\n\n* [SE-0189][]\n\n  If an initializer is declared in a different module from a struct, it must\n  use `self.init(…)` or `self = …` before returning or accessing `self`.\n  Failure to do so will produce a warning in Swift 4 and an error in Swift 5.\n  This is to keep a client app from accidentally depending on a library's\n  implementation details, and matches an existing restriction for classes,\n  where cross-module initializers must be convenience initializers.\n\n  This will most commonly affect code that extends a struct imported from C.\n  However, most imported C structs are given a zeroing no-argument initializer,\n  which can be called as `self.init()` before modifying specific properties.\n\n  Swift library authors who wish to continue allowing initialization on a\n  per-member basis should explicitly declare a public memberwise initializer\n  for clients in other modules to use.\n\n* [SE-0166][] / [SE-0143][]\n\n  The standard library now defines the conformances of `Optional`,\n  `Array`, `Dictionary`, and `Set` to `Encodable` and `Decodable` as\n  conditional conformances, available only when their type parameters\n  conform to `Encodable` or `Decodable`, respectively.\n\n* [SE-0188][] \n  \n  Index types for most standard library collections now conform to `Hashable`. \n  These indices can now be used in key-path subscripts and hashed collections:\n  \n  ```swift\n  let s = \"Hashable\"\n  let p = \\String.[s.startIndex]\n  s[keyPath: p] // \"H\"\n  ```\n\n* [SE-0143][] The standard library types `Optional`, `Array`, `ArraySlice`,\n  `ContiguousArray`, and `Dictionary` now conform to the `Equatable` protocol\n  when their element types conform to `Equatable`. This allows the `==` operator\n  to compose (e.g., one can compare two values of type `[Int : [Int?]?]` with\n  `==`), as well as use various algorithms defined for `Equatable` element\n  types, such as `index(of:)`.\n\n* [SE-0157][] is implemented. Associated types can now declare \"recursive\"\n  constraints, which require that the associated type conform to the enclosing\n  protocol. The standard library protocols have been updated to make use of\n  recursive constraints. For example, the `SubSequence` associated type of\n  `Sequence` follows the enclosing protocol:\n\n  ```swift\n  protocol Sequence {\n    associatedtype Element\n    associatedtype SubSequence: Sequence\n      where SubSequence.Element == Element,\n            SubSequence.SubSequence == SubSequence\n    // ...\n  }\n\n  protocol Collection: Sequence where Self.SubSequence: Collection {\n    // ...\n  }\n  ```\n\n  As a result, a number of new constraints have been introduced into the\n  standard library protocols:\n\n  * Make the `Indices` associated type have the same traversal requirements as\n    its enclosing protocol, e.g., `Collection.Indices` conforms to\n    `Collection`, `BidirectionalCollection.Indices` conforms to\n    `BidirectionalCollection`, and so on\n  * Make `Numeric.Magnitude` conform to `Numeric`\n  * Use more efficient `SubSequence` types for lazy filter and map\n  * Eliminate the `*Indexable` protocols\n\n* [SE-0161][] is fully implemented. KeyPaths now support subscript, optional\n  chaining, and optional force-unwrapping components.\n\n* [SE-0186][]\n\n  It is no longer valid to use the ownership keywords `weak` and `unowned` for property declarations in protocols. These keywords are meaningless and misleading when used in a protocol as they don't have any effect.\n\n  In Swift 3 and 4 mode the following example will produce a warning with a fix-it to remove the keyword. In Swift 5 mode and above an error will be produced.\n\n  ```swift\n  class A {}\n\n  protocol P {\n      weak var weakVar: A? { get set }\n      unowned var unownedVar: A { get set }\n  }\n  ```\n\n* [SE-0185][]\n\n  Structs and enums that declare a conformance to `Equatable`/`Hashable` now get an automatically synthesized implementation of `==`/`hashValue`. For structs, all stored properties must be `Equatable`/`Hashable`. For enums, all enum cases with associated values must be `Equatable`/`Hashable`.\n\n  ```swift\n  public struct Point: Hashable {\n    public let x: Int\n    public let y: Int\n\n    public init(x: Int, y: Int) {\n      self.x = x\n      self.y = y\n    }\n  }\n\n  Point(3, 0) == Point(0, 3)  // false\n  Point(3, 0) == Point(3, 0)  // true\n  Point(3, 0).hashValue       // -2942920663782199421\n\n  public enum Token: Hashable {\n    case comma\n    case identifier(String)\n    case number(Int)\n  }\n\n  Token.identifier(\"x\") == .number(5)        // false\n  Token.identifier(\"x\") == .identifier(\"x\")  // true\n  Token.number(50).hashValue                 // -2002318238093721609\n  ```\n\n  If you wish to provide your own implementation of `==`/`hashValue`, you still can; a custom implementation will replace the one synthesized by the compiler.\n\n## Swift 4.0\n\n### 2017-09-19 (Xcode 9.0)\n\n* [SE-0165][] and [SE-0154][]\n\n  The standard library's `Dictionary` and `Set` types have some new features. You can now create a new dictionary from a sequence of keys and values, and merge keys and values into an existing dictionary.\n\n  ```swift\n  let asciiTable = Dictionary(uniqueKeysWithValues: zip(\"abcdefghijklmnopqrstuvwxyz\", 97...))\n  // [\"w\": 119, \"n\": 110, \"u\": 117, \"v\": 118, \"x\": 120, \"q\": 113, ...]\n\n  let vegetables = [\"tomato\", \"carrot\", \"onion\", \"onion\", \"carrot\", \"onion\"]\n  var vegetableCounts = Dictionary(zip(vegetables, repeatElement(1, count: Int.max)),\n                                   uniquingKeysWith: +)\n  vegetableCounts.merge([(\"tomato\", 1)], uniquingKeysWith: +)\n  // [\"tomato\": 2, \"carrot\": 2, \"onion\": 3]\n  ```\n\n  Filtering a set or a dictionary now results in the same type. You can also now transform just the values of a dictionary, keeping the same keys, using the `mapValues(_:)` method.\n\n  ```swift\n  let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  let asciiVowels = asciiTable.filter({ vowels.contains($0.key) })\n  asciiVowels[\"a\"]  // 97\n  asciiVowels[\"b\"]  // nil\n\n  let asciiHexTable = asciiTable.mapValues({ \"0x\" + String($0, radix: 16) })\n  // [\"w\": \"0x77\", \"n\": \"0x6e\", \"u\": \"0x75\", \"v\": \"0x76\", \"x\": \"0x78\", ...]\n  ```\n\n  When using a key as a dictionary subscript, you can now supply a default value to be returned if the key is not present in the dictionary.\n\n  ```swift\n  for veg in [\"tomato\", \"cauliflower\"] {\n      vegetableCounts[veg, default: 0] += 1\n  }\n  // [\"tomato\": 3, \"carrot\": 2, \"onion\": 3, \"cauliflower\": 1]\n  ```\n\n  Use the new `init(grouping:by:)` initializer to convert an array or other sequence into a dictionary, grouped by a particular trait.\n\n  ```swift\n  let buttons = // an array of button instances\n  let buttonsByStatus = Dictionary(grouping: buttons, by: { $0.isEnabled })\n  // How many enabled buttons?\n  print(\"Enabled:\", buttonsByStatus[true]?.count ?? 0)\n  ```\n\n  Additionally, dictionaries and sets now have a visible `capacity` property and a `reserveCapacity(_:)` method similar to arrays, and a dictionary's `keys` and `values` properties are represented by specialized collections.\n\n* [SE-0161][] is partially implemented. Swift now natively supports key path\n  objects for properties. Similar to KVC key path strings in Cocoa, key path\n  objects allow a property to be referenced independently of accessing it\n  from a value:\n\n    ```swift\n    struct Point {\n      var x, y: Double\n    }\n    let x = \\Point.x\n    let y = \\Point.y\n\n    let p = Point(x: 3, y: 4)\n    p[keyPath: x] // gives 3\n    p[keyPath: y] // gives 4\n    ```\n\n* Core Foundation types implicitly conform to Hashable (and Equatable), using\n  CFHash and CFEqual as the implementation. This change applies even to \"Swift\n  3 mode\", so if you were previously adding this conformance yourself, use\n  `#if swift(>=3.2)` to restrict the extension to Swift 3.1 and below.\n  ([#44995][])\n\n* [SE-0156][]\n\n  Protocol composition types can now contain one or more class type terms,\n  forming a class-constrained protocol composition.\n\n  For example:\n\n  ```swift\n  protocol Paintable {\n    func paint()\n  }\n\n  class Canvas {\n    var origin: CGPoint\n  }\n\n  class Wall : Canvas, Paintable {\n    func paint() { ... }\n  }\n\n  func render(_: Canvas & Paintable) { ... }\n\n  render(Wall())\n  ```\n\n  Note that class-constrained protocol compositions can be written and\n  used in both Swift 3 and Swift 4 mode.\n\n  Generated headers for Swift APIs will map class-constrained protocol\n  compositions to Objective-C protocol-qualified class types in both\n  Swift 3 and Swift 4 mode (for instance, `NSSomeClass & SomeProto &\n  OtherProto` in Swift becomes `NSSomeClass <SomeProto, OtherProto>`\n  in Objective-C).\n\n  Objective-C APIs which use protocol-qualified class types differ in\n  behavior when imported by a module compiled in Swift 3 mode and\n  Swift 4 mode. In Swift 3 mode, these APIs will continue to import as\n  protocol compositions without a class constraint\n  (eg, `SomeProto & OtherProto`).\n\n  In Swift 4 mode, protocol-qualified class types import as\n  class-constrained protocol compositions, for a more faithful mapping\n  of APIs from Objective-C to Swift.\n\n  Note that the current implementation of class-constrained protocol\n  compositions lacks three features outlined in the Swift evolution proposal:\n\n  - In the evolution proposal, a class-constrained is permitted to contain\n    two different classes as long as one is a superclass of the other.\n    The current implementation only allows multiple classes to appear in\n    the composition if they are identical.\n\n  - In the evolution proposal, associated type and class inheritance clauses\n    are generalized to allow class-constrained protocol compositions. The\n    current implementation does not allow this.\n\n  - In the evolution proposal, protocol inheritance clauses are allowed to\n    contain a class, placing a requirement that all conforming types are\n    a subclass of the given class. The current implementation does not\n    allow this.\n\n  These missing aspects of the proposal can be introduced in a future\n  release without breaking source compatibility with existing code.\n\n* [SE-0142][]\n\n  Protocols and associated types can now contain `where` clauses that\n  provide additional restrictions on associated types. For example:\n\n    ```swift\n    protocol StringRepresentable: RawRepresentable\n    where RawValue == String { }\n\n    protocol RawStringWrapper {\n      associatedtype Wrapped: RawRepresentable\n        where Wrapper.RawValue == String\n    }\n    ```\n\n* [SE-0160][]\n\n  In Swift 4 mode, a declaration is inferred to be `@objc` where it is required for semantic consistency of the programming model. Specifically, it is inferred when:\n\n    * The declaration is an override of an `@objc` declaration\n    * The declaration satisfies a requirement in an `@objc` protocol\n    * The declaration has one of the following attributes: `@IBAction`, `@IBOutlet`, `@IBInspectable`, `@GKInspectable`, or `@NSManaged`\n\n  Additionally, in Swift 4 mode, `dynamic` declarations that don't\n  have `@objc` inferred based on the rules above will need to be\n  explicitly marked `@objc`.\n\n  Swift 3 compatibility mode retains the more-permissive Swift 3\n  rules for inference of `@objc` within subclasses of\n  `NSObject`. However, the compiler will emit warnings about places\n  where the Objective-C entry points for these inference cases are\n  used, e.g., in a `#selector` or `#keyPath` expression, via\n  messaging through `AnyObject`, or direct uses in Objective-C code\n  within a mixed project. The warnings can be silenced by adding an\n  explicit `@objc`. Uses of these entrypoints that are not\n  statically visible to the compiler can be diagnosed at runtime by\n  setting the environment variable\n  `SWIFT_DEBUG_IMPLICIT_OBJC_ENTRYPOINT` to a value between 1 and 3\n  and testing the application. See the [migration discussion in\n  SE-0160](https://github.com/apple/swift-evolution/blob/main/proposals/0160-objc-inference.md#minimal-migration-workflow).\n\n* [SE-0138](https://github.com/apple/swift-evolution/blob/main/proposals/0138-unsaferawbufferpointer.md#amendment-to-normalize-the-slice-type):\n\n  Slicing a raw buffer no longer results in the same raw buffer\n  type. Specifically, `Unsafe[Mutable]BufferPointer.SubSequence` now has type\n  `[Mutable]RandomAccessSlice<Unsafe[Mutable]RawBufferPointer>`. Therefore,\n  indexing into a raw buffer slice is no longer zero-based. This is required for\n  raw buffers to fully conform to generic `Collection`. Changing the slice type\n  resulted in the following behavioral changes:\n\n  Passing a region within buffer to another function that takes a buffer can no\n  longer be done via subscript:\n\n  Incorrect: `takesRawBuffer(buffer[i..<j])`\n\n  This now requires explicit initialization, using a `rebasing:` initializer,\n  which converts from a slice to a zero-based `Unsafe[Mutable]RawBufferPointer`:\n\n  Correct: `takesRawBuffer(UnsafeRawBufferPointer(rebasing: buffer[i..<j]))`\n\n  Subscript assignment directly from a buffer no longer compiles:\n\n  Incorrect: `buffer[n..<m] = smaller_buffer`\n\n  This now requires creation of a slice from the complete source buffer:\n\n  Correct: `buffer[n..<m] = smaller_buffer.suffix(from: 0)`\n\n  `UnsafeRawBufferPointer`'s slice type no longer has a nonmutating subscript\n  setter. So assigning into a mutable `let` buffer no longer compiles:\n\n  ```swift\n  let slice = buffer[n..<m]\n  slice[i..<j] = buffer[k..<l]\n  ```\n\n  The assigned buffer slice now needs to be a `var`.\n\n  ```swift\n  var slice = buffer[n..<m]\n  slice[i..<j] = buffer[k..<l]\n  ```\n\n* [#44138][]:\n\n  Covariant method overrides are now fully supported, fixing many crashes\n  and compile-time assertions when defining or calling such methods.\n  Examples:\n\n  ```swift\n  class Bed {}\n  class Nook : Bed {}\n\n  class Cat<T> {\n    func eat(snack: T) {}\n    func play(game: String) {}\n    func sleep(where: Nook) {}\n  }\n\n  class Dog : Cat<(Int, Int)> {\n    // 'T' becomes concrete\n    override func eat(snack: (Int, Int)) {}\n\n    // 'game' becomes optional\n    override func play(game: String?) {}\n\n    // 'where' becomes a superclass\n    override func sleep(where: Bed) {}\n  }\n  ```\n\n* [SE-0148][]:\n\n  Subscript declarations can now be defined to have generic parameter lists.\n  Example:\n\n  ```swift\n  extension JSON {\n    subscript<T>(key: String) -> T?\n        where T : JSONConvertible {\n      // ...\n    }\n  }\n  ```\n\n* [SE-0110][]:\n\n  In Swift 4 mode, Swift's type system properly distinguishes between functions that\n  take one tuple argument, and functions that take multiple arguments.\n\n* More types of C macros which define integer constants are supported by the\n  importer. Specifically the `+, -, *, /, ^, >>, ==, <, <=, >, >=` operators\n  are now recognized, and the previously-supported `<<, &&, ||, &, |`\n  operators always look through importable macros on each side of the operator.\n  Logical AND and OR macros (`&&` and `||`) are now imported as Boolean\n  constants, rather than integers of value 0 or 1.\n\n  ```c\n  #define HIGHER    (5 + 5)\n  #define THE_EDGE  (INT64_MAX - 1)\n  #define FORTY_TWO (6 * 9)\n  #define SPLIT     (THE_EDGE / FORTY_TWO)\n\n  #define HALF_AND_HALF (UINT64_MAX ^ UINT32_MAX)\n\n  #define SMALL   (BITWIDTH == 32)\n  #define TINY    (BITWIDTH <= 16)\n  #define LIMITED (SMALL || TINY)   // now imported as Bool.\n  ```\n\n## Swift 3.1\n\n### 2017-03-27 (Xcode 8.3)\n\n* [SE-0080][]:\n\n  Adds a new family of conversion initializers to all numeric types that\n  either complete successfully without loss of information or return nil.\n\n* Swift will now warn when an `NSObject` subclass attempts to override the\n  class `initialize` method. Swift doesn't guarantee that references to class\n  names trigger Objective-C class realization if they have no other\n  side effects, leading to bugs when Swift code attempted to override\n  `initialize`.\n\n* [#45001][]\n\n  C functions that \"return twice\" are no longer imported into Swift. Instead,\n  they are explicitly made unavailable, so attempting to reference them will\n  result in a compilation error.\n\n  Examples of functions that \"return twice\" include `vfork` and `setjmp`.\n  These functions change the control flow of a program in ways that Swift\n  has never supported. For example, definitive initialization of variables,\n  a core Swift language feature, could not be guaranteed when these functions\n  were used.\n\n  Swift code that references these functions will no longer compile. Although\n  this could be considered a source-breaking change, it's important to note that\n  any use of these functions would have most likely crashed at runtime. Now,\n  the compiler will prevent them from being used in the first place.\n\n* Indirect fields from C structures and unions are now always imported, while\n  they previously weren't imported if they belonged to a union. This is done by\n  naming anonymous fields. For example:\n\n  ```c\n  typedef struct foo_t {\n    union {\n      int a;\n      double b;\n    };\n  } foo_t;\n  ```\n\n  Get imported as:\n\n  ```swift\n  struct foo_t {\n    struct __Unnamed_union___Anonymous_field0 {\n      var a : Int { get set }\n      var b : Double { get set }\n    }\n    var __Anonymous_field0 : foo_t.__Unnamed_union___Anonymous_field0\n\n    // a and b are computed properties accessing the content of __Anonymous_field0\n    var a : Int { get set }\n    var b : Double { get set }\n  }\n  ```\n\n  Since new symbols are exposed from imported structure/unions, this may conflict\n  with existing code that extended C types in order to provide their own accessors\n  to the indirect fields.\n\n* The `withoutActuallyEscaping` function from [SE-0103][] has been implemented.\n  To pass off a non-escaping closure to an API that formally takes an\n  `@escaping` closure, but which is used in a way that will not in fact\n  escape it in practice, use `withoutActuallyEscaping` to get an escapable\n  copy of the closure and delimit its expected lifetime. For example:\n\n  ```swift\n  func doSimultaneously(_ f: () -> (), and g: () -> (), on q: DispatchQueue) {\n    // DispatchQueue.async normally has to be able to escape its closure\n    // since it may be called at any point after the operation is queued.\n    // By using a barrier, we ensure it does not in practice escape.\n    withoutActuallyEscaping(f) { escapableF in\n      withoutActuallyEscaping(g) { escapableG in\n        q.async(escapableF)\n        q.async(escapableG)\n        q.sync(flags: .barrier) {}\n      }\n    }\n    // `escapableF` and `escapableG` must be dequeued by the point\n    // `withoutActuallyEscaping` returns.\n  }\n  ```\n\n  The old workaround of using `unsafeBitCast` to cast to an `@escaping` type\n  is not guaranteed to work in future versions of Swift, and will\n  now raise a warning.\n\n* [#44055][]\n\n  Nested types may now appear inside generic types, and nested types may have their own generic parameters:\n\n  ```swift\n  struct OuterNonGeneric {\n      struct InnerGeneric<T> {}\n  }\n\n  struct OuterGeneric<T> {\n      struct InnerNonGeneric {}\n\n      struct InnerGeneric<T> {}\n  }\n\n  extension OuterNonGeneric.InnerGeneric {}\n  extension OuterGeneric.InnerNonGeneric {}\n  extension OuterGeneric.InnerGeneric {}\n  ```\n\n* [#43621][]:\n\n  Constrained extensions allow same-type constraints between generic parameters and concrete types. This enables you to create extensions, for example, on `Array` with `Int` elements:\n\n  ```swift\n  extension Array where Element == Int { }\n  ```\n\n* [SE-0045][]:\n\n  The `Sequence` protocol adds two new members `prefix(while:)` and\n  `drop(while:)` for common utility. `prefix(while:)` requests the longest subsequence\n  satisfying a predicate.  `drop(while:)` requests the remaining\n  subsequence after dropping the longest subsequence satisfying a\n  predicate.\n\n## Swift 3.0\n\n### 2016-09-13 (Xcode 8.0)\n\n* [SE-0101][]:\n\n  The functions `sizeof()`, `strideof()`, and `alignof()` have been removed.\n  Memory layout properties for a type `T` are now spelled\n  `MemoryLayout<T>.size`, `MemoryLayout<T>.stride`, and\n  `MemoryLayout<T>.alignment`, respectively.\n\n* [SE-0136][]:\n\n  The functions `sizeofValue()`, `strideofValue()`, and `alignofValue()` have been renamed to `MemoryLayout.size(ofValue:)`, `MemoryLayout.stride(ofValue:)`,\n  and `MemoryLayout.alignment(ofValue:)`.\n\n* [SE-0125][]:\n\n  The functions `isUniquelyReferenced()` and `isUniquelyReferencedNonObjC()`\n  have been removed. Call the function `isKnownUniquelyReferenced()` instead.\n\n  Classes using `isUniquelyReferenced()` needed to inherit from `NonObjectiveCBase`. The `NonObjectiveCBase` class has been removed.\n\n  The method `ManagedBufferPointer.holdsUniqueReference` has been renamed to\n  `ManagedBufferPointer.isUniqueReference`.\n\n  ```swift\n  // old\n  class SwiftKlazz : NonObjectiveCBase {}\n  expectTrue(isUniquelyReferenced(SwiftKlazz()))\n\n  var managedPtr : ManagedBufferPointer = ...\n  if !managedPtr.holdsUniqueReference() {\n    print(\"not unique\")\n  }\n\n  // new\n  class SwiftKlazz {}\n  expectTrue(isKnownUniquelyReferenced(SwiftKlazz()))\n\n  var managedPtr : ManagedBufferPointer = ...\n  if !managedPtr.isUniqueReference() {\n    print(\"not unique\")\n  }\n  ```\n\n* [SE-0124][]:\n\n  Initializers on `Int` and `UInt` that accept an `ObjectIdentifier` must now use an explicit `bitPattern` label.\n\n  ```swift\n  let x: ObjectIdentifier = ...\n\n  // old\n  let u = UInt(x)\n  let i = Int(x)\n\n  // new\n  let u = UInt(bitPattern: x)\n  let i = Int(bitPattern: x)\n  ```\n\n* [SE-0120][]:\n\n  The collection methods `partition()` and `partition(isOrderedBefore:)` have been removed from Swift. They are replaced by the method `partition(by:)` which takes a unary predicate.\n\n  Calls to the `partition()` method can be replaced by the following code.\n\n  ```swift\n  // old\n  let p = c.partition()\n\n  // new\n  let p = c.first.flatMap({ first in\n      c.partition(by: { $0 >= first })\n  }) ?? c.startIndex\n  ```\n\n* [SE-0103][]:\n\n  Closure parameters are now non-escaping by default and do not require `@noescape` annotation. Use `@escaping` to indicate that a closure parameter can escape. `@autoclosure(escaping)` is now spelled `@autoclosure @escaping`. `@noescape` and `@autoclosure(escaping)` are deprecated.\n\n* [SE-0115][]:\n\n  To clarify their roles, `*LiteralConvertible` protocols have been renamed to `ExpressibleBy*Literal`.  The protocol requirements are unchanged.\n\n* [SE-0107][]:\n\n  An `Unsafe[Mutable]RawPointer` type has been introduced. It replaces\n  `Unsafe[Mutable]Pointer<Void>`. Conversion from `UnsafePointer<T>`\n  to `UnsafePointer<U>` has been disallowed. `Unsafe[Mutable]RawPointer`\n  provides an API for untyped memory access, and an API for binding memory\n  to a type. Binding memory allows for safe conversion between pointer types.\n\n  For detailed instructions on how to migrate your code to the new API refer to the [UnsafeRawPointer migration guide](https://swift.org/migration-guide/se-0107-migrate.html). See also: See `bindMemory(to:capacity:)`, `assumingMemoryBound(to:)`, and\n  `withMemoryRebound(to:capacity:)`.\n\n* [SE-0096][]:\n\n  The `dynamicType` keyword has been removed from Swift.  It's replaced by a new primitive function `type(of:)`.  Existing code\nusing the `.dynamicType` member to retrieve the type of an expression should migrate to this new primitive.  Code using `.dynamicType` in conjunction with `sizeof` should migrate to the `MemoryLayout` structure introduced by [SE-0101][].\n\n* [SE-0113][]:\n\n  The following two methods were added to `FloatingPoint`:\n\n  ```swift\n  func rounded(_ rule: FloatingPointRoundingRule) -> Self\n  mutating func round( _ rule: FloatingPointRoundingRule)\n  ```\n\n  These methods bind the IEEE 754 roundToIntegral operations. They provide the functionality of the C / C++ `round()`, `ceil()`, `floor()`, and `trunc()` functions along with other rounding operations.\n\n  Following onto [SE-0113][] and [SE-0067][], the following `Darwin.C` and `glibc` module mathematical operations now operate on any type conforming to `FloatingPoint`: `fabs`, `sqrt`, `fma`,\n  `remainder`, `fmod`, `ceil`, `floor`, `round`, and `trunc`.\n\n  See also: the changes associated with [SE-0067][].\n\n* [SE-0067][]:\n\n  The `FloatingPoint` protocol has been expanded to include most IEEE 754\n  required operations. A number of useful properties have been added to the\n  protocol, representing quantities like the largest finite value or\n  the smallest positive normal value (these correspond to the macros such as\n  FLT_MAX defined in C).\n\n  While almost all of the changes are additive, four changes impact existing code:\n\n  - The `%` operator is no longer available for `FloatingPoint` types. It\n  was difficult to use correctly and its semantics did not match\n  those of the corresponding integer operation. This made it something of an attractive nuisance. The new method `formTruncatingRemainder(dividingBy:)`\n  provides the old semantics if they are needed.\n\n  - The static property `.NaN` has been renamed `.nan`.\n\n  - The static property `.quietNaN` was redundant and has been removed. Use\n  `.nan` instead.\n\n  - The predicate `isSignaling` has been renamed `isSignalingNaN`.\n\n  See also: the changes associated with [SE-0113][].\n\n* [SE-0111][]:\n\n  Argument labels have been removed from Swift function types. They are now\n  part of the name of a function, subscript, or initializer. Calls to a function or initializer, and subscript uses, still require argument labels as they always have:\n\n  ```swift\n  func doSomething(x: Int, y: Int) { }\n  doSomething(x: 0, y: 0)     // argument labels are required\n  ```\n\n  Unapplied references to functions or initializers no longer carry argument labels. For example:\n\n  ```swift\n  let f = doSomething(x:y:)     // inferred type is now (Int, Int) -> Void\n  ```\n\n  Explicitly-written function types can no longer carry argument labels. You can still provide parameter names for documentation purposes using the '_' in the argument label position:\n\n  ```swift\n  typealias CompletionHandler =\n     (token: Token, error: Error?) -> Void   // error: function types cannot have argument labels\n\n  typealias CompletionHandler =\n     (_ token: Token, _ error: Error?) -> Void   // okay: names are for documentation purposes\n  ```\n\n* [SE-0025][]:\n\n  The access level formerly known as `private` is now called `fileprivate`. A Swift 3 declaration marked `private` can no longer be accessed outside its lexical scope (essentially its enclosing curly braces `{}`). A `private` declaration at the top level of a file can be accessed anywhere within the same file, as it could in Swift 2.\n\n* [SE-0131][]:\n\n  The standard library introduces the `AnyHashable` type for use in hashed heterogeneous collections. Untyped `NSDictionary` and `NSSet` Objective-C APIs now import as `[AnyHashable: Any]` and `Set<AnyHashable>`.\n\n* [SE-0102][]:\n\n  Swift removes the `@noreturn` attribute on function declarations and replaces the attribute with an empty `Never` type:\n\n  ```swift\n  @noreturn func fatalError(msg: String) { ... }  // old\n  func fatalError(msg: String) -> Never { ... }   // new\n\n  func performOperation<T>(continuation: @noreturn T -> ()) { ... }  // old\n  func performOperation<T>(continuation: T -> Never) { ... }         // new\n  ```\n\n* [SE-0116][]:\n\n  Swift now imports Objective-C `id` APIs as `Any`. In Swift 2, `id` imported as `AnyObject`. Swift also imports untyped `NSArray` and `NSDictionary` as `[Any]` and `[AnyHashable: Any]`, respectively.\n\n* [SE-0072][]:\n\n  Swift eliminates implicit bridging conversions. Use `as` to force the conversion from a Swift value type to its corresponding object. For example, use `string as NSString`. Use `as AnyObject` to convert a Swift value to its boxed `id` representation.\n\n* Collection subtype conversions and dynamic casts now work with protocol types:\n\n    ```swift\n    protocol P {}; extension Int: P {}\n    var x: [Int] = [1, 2, 3]\n    var p: [P] = x\n    var x2 = p as! [Int]\n    ```\n\n* [#44739][]:\n\n  The `hasPrefix` and `hasSuffix` functions now consider the empty string to be a prefix and suffix of all strings.\n\n* [SE-0128][]:\n\n  Some non-failable UnicodeScalar initializers now return an Optional. When a UnicodeScalar cannot be constructed, these initializers return nil.\n\n  ```swift\n  // Old\n  var string = \"\"\n  let codepoint: UInt32 = 55357 // Invalid\n  let ucode = UnicodeScalar(codepoint) // Program crashes here.\n  string.append(ucode)\n  ```\n\n  The updated initializers allow users to write code that safely works around invalid codepoints, like this example:\n\n  ```swift\n  // New\n  var string = \"\"\n  let codepoint: UInt32 = 55357 // Invalid\n  if let ucode = UnicodeScalar(codepoint) {\n      string.append(ucode)\n  } else {\n      // do something else\n  }\n  ```\n\n* [SE-0095][]:\n\n  Swift removes the `protocol<...>` composition construct and introduces an infix type operator `&` in its place.\n\n  ```swift\n  let a: Foo & Bar\n  let b = value as? A & B & C\n  func foo<T : Foo & Bar>(x: T) { ... }\n  func bar(x: Foo & Bar) { ... }\n  typealias G = GenericStruct<Foo & Bar>\n  ```\n\n  Swift previously defined the empty protocol composition (the `Any` type) as `protocol<>`. This definition has been removed from the standard library. The `Any` keyword behavior remains unchanged.\n\n* [SE-0091][]:\n\n  Swift permits you to define operators within types or their extensions. For example:\n\n  ```swift\n  struct Foo: Equatable {\n    let value: Int\n\n    static func ==(lhs: Foo, rhs: Foo) -> Bool {\n      return lhs.value == rhs.value\n    }\n  }\n  ```\n\n  You must declare these operators as `static` (or, within a class, `class\n  final`) and they must use the same signature as their global counterparts. As part of this change, protocol-declared operator requirements must be declared `static` explicitly:\n\n  ```swift\n  protocol Equatable {\n    static func ==(lhs: Self, rhs: Self) -> Bool\n  }\n  ```\n\n  Note: The type checker performance optimization described by [SE-0091][]\n  is not yet implemented.\n\n* [SE-0099][]:\n\n  Condition clauses in `if`, `guard`, and `while` statements now use a more\n  regular syntax. Each pattern or optional binding must be prefixed with `case`\n  or `let` respectively, and all conditions are separated by `,` instead of\n  `where`.\n\n  ```swift\n  // before\n  if let a = a, b = b where a == b { }\n\n  // after\n  if let a = a, let b = b, a == b { }\n  ```\n\n* [SE-0112][]:\n\n  The `NSError` type now bridges to the Swift `Error` protocol type (formerly `ErrorProtocol` in Swift 3, `ErrorType` in Swift 2)\n  in Objective-C APIs. `NSError` now bridges like other Objective-C types, e.g., `NSString` bridges to `String`.\n\n  For\n  example, the `UIApplicationDelegate` method\n  `applicate(_:didFailToRegisterForRemoteNotificationsWithError:)`\n  previously accepted an `NSError` argument:\n\n  ```swift\n  optional func application(_ application: UIApplication,\n    didFailToRegisterForRemoteNotificationsWithError error: NSError)\n  ```\n\n  Now it accepts an `Error` argument:\n\n  ```swift\n  optional func application(_ application: UIApplication,\n    didFailToRegisterForRemoteNotificationsWithError error: Error)\n  ```\n\n  Error types imported from Cocoa[Touch] maintain all of\n  the information in the corresponding `NSError`. You no longer `catch let as NSError` to extract, for example, the user-info\n  dictionary.\n\n  Specific error types now contain typed accessors for\n  their common user-info keys. For example:\n\n  ```swift\n  catch let error as CocoaError where error.code == .fileReadNoSuchFileError {\n    print(\"No such file: \\(error.url)\")\n  }\n  ```\n\n  Swift-defined error types can now provide localized error\n  descriptions by adopting the new `LocalizedError` protocol, e.g.,\n\n  ```swift\n  extension HomeworkError : LocalizedError {\n    var errorDescription: String? {\n      switch self {\n      case .forgotten: return NSLocalizedString(\"I forgot it\")\n      case .lost: return NSLocalizedString(\"I lost it\")\n      case .dogAteIt: return NSLocalizedString(\"The dog ate it\")\n      }\n    }\n  }\n  ```\n\n  New `RecoverableError` and `CustomNSError` protocols\n  allow additional control over the handling of the error.\n\n* [SE-0060][]:\n\n  Function parameters with defaulted arguments are specified in\n  declaration order. Call sites must now supply those arguments using that order:\n\n    ```swift\n    func requiredArguments(a: Int, b: Int, c: Int) {}\n    func defaultArguments(a: Int = 0, b: Int = 0, c: Int = 0) {}\n\n    requiredArguments(a: 0, b: 1, c: 2)\n    requiredArguments(b: 0, a: 1, c: 2) // error\n    defaultArguments(a: 0, b: 1, c: 2)\n    defaultArguments(b: 0, a: 1, c: 2) // error\n    ```\n\n    Labeled parameters with default arguments may still be elided, so long as included arguments follow declaration order:\n\n    ```swift\n    defaultArguments(a: 0) // ok\n    defaultArguments(b: 1) // ok\n    defaultArguments(c: 2) // ok\n    defaultArguments(a: 1, c: 2) // ok\n    defaultArguments(b: 1, c: 2) // ok\n    defaultArguments(c: 1, b: 2) // error\n    ```\n\n* Traps from force-unwrapping nil `Optional`s now show the source location of the force unwrap operator.\n\n* [SE-0093][]:\n\n  Slice types add a `base` property that allows public readonly access to their base collections.\n\n* Nested generic functions may now capture bindings from the environment, for example:\n\n    ```swift\n    func outer<T>(t: T) -> T {\n      func inner<U>(u: U) -> (T, U) {\n        return (t, u)\n      }\n      return inner(u: (t, t)).0\n    }\n    ```\n\n* Initializers are now inherited even if the base class or derived class is generic:\n\n    ```swift\n    class Base<T> {\n      let t: T\n\n      init(t: T) {\n        self.t = t\n      }\n    }\n\n    class Derived<T> : Base<T> {\n      // init(t: T) is now synthesized to call super.init(t: t)\n    }\n    ```\n\n* [SE-0081][]:\n\n  \"Move `where` clause to end of declaration\" is now implemented. This change allows you to write `where` clauses after a declaration signature and before its body.  For example, before this change was implemented, you'd write:\n\n    ```swift\n    func anyCommonElements<T : SequenceType, U : SequenceType\n        where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element>\n        (lhs: T, _ rhs: U) -> Bool\n    {\n        ...\n    }\n    ```\n\n  Now the `where` clause appears just before the body:\n\n    ```swift\n    func anyCommonElements<T : SequenceType, U : SequenceType>(lhs: T, _ rhs: U) -> Bool\n        where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element\n    {\n        ...\n    }\n    ```\n\n  The old form is currently accepted for compatibility. It will eventually be rejected.\n\n* [SE-0071][]:\n\n  \"Allow (most) keywords in member references\" is implemented.  This change allows the use of members after a dot without backticks, e.g. \"foo.default\", even though `default` is a keyword for `switch` statements.\n\n* [SE-0057][]:\n\n  Objective-C lightweight generic classes are now imported as generic types\n  in Swift. Some limitations apply because Objective-C generics are not represented at runtime:\n\n  - When an ObjC generic class is used in a checked `as?`, `as!`, or `is` cast, the generic parameters are not checked at runtime. The cast succeeds if the operand is an instance of the ObjC class, regardless of parameters.\n\n    ```swift\n    let x = NSFoo<NSNumber>(value: NSNumber(integer: 0))\n    let y: AnyObject = x\n    let z = y as! NSFoo<NSString> // Succeeds\n    ```\n\n  - Swift subclasses can only inherit from an ObjC generic class when its generic parameters are fully specified.\n\n    ```swift\n    // Error: Can't inherit ObjC generic class with unbound parameter T\n    class SwiftFoo1<T>: NSFoo<T> { }\n\n    // OK: Can inherit ObjC generic class with specific parameters\n    class SwiftFoo2<T>: NSFoo<NSString> { }\n    ```\n\n  - Swift can extend ObjC generic classes but the extensions cannot be constrained, and definitions inside the extension don't have access to the class's generic parameters.\n\n    ```swift\n    extension NSFoo {\n      // Error: Can't access generic param T\n      func foo() -> T {\n        return T()\n      }\n    }\n\n    // Error: extension can't be constrained\n    extension NSFoo where T: NSString {\n    }\n    ```\n\n  - Foundation container classes `NS[Mutable]Array`, `NS[Mutable]Set`, and `NS[Mutable]Dictionary` are still imported as nongeneric classes for the time being.\n\n* [SE-0036][]:\n\n  Enum elements can no longer be accessed as instance members in instance methods.\n\n  * As part of the changes for [SE-0055][] (see below), the *pointee* types of imported pointers (e.g. the `id` in `id *`) are no longer assumed to always be `_Nullable` even if annotated otherwise.\n  * An implicit or explicit annotation of `_Null_unspecified` on a pointee type still imports as `Optional`.\n\n* [SE-0055][]:\n\n  The types `UnsafePointer`, `UnsafeMutablePointer`,\n  `AutoreleasingUnsafeMutablePointer`, `OpaquePointer`, `Selector`, and `Zone` (formerly `NSZone`) now represent non-nullable pointers, i.e. pointers that are never `nil`. A nullable pointer is now represented using `Optional`, e.g. `UnsafePointer<Int>?` For types imported from C, non-object pointers (such as `int *`) now have their nullability taken into account.\n\n  One possible area of difficulty is passing a nullable pointer to a function that uses C variadics. Swift will not permit this directly. As a workaround, use the following idiom to pass a pointer-sized integer value instead:\n\n  ```swift\n  unsafeBitCast(nullablePointer, to: Int.self)\n  ```\n\n* [SE-0046][]:\n\n  Function parameters adopt consistent labeling across all function parameters. With this update, first parameter declarations match the existing behavior of the second and later parameters. This change makes the language simpler.\n\n  Functions that were written and called as follows:\n\n  ```swift\n  func foo(x: Int, y: Int) {}\n  foo(1, y: 2)\n\n  func bar(a a: Int, b: Int) {}\n  bar(a: 3, b: 4)\n  ```\n\n  Are now written as follows with the same behavior at call sites:\n\n  ```swift\n  func foo(_ x: Int, y: Int) {}\n  foo(1, y: 2)\n\n  func bar(a: Int, b: Int) {}\n  bar(a: 3, b: 4)\n  ```\n\n* [SE-0037][]:\n\n  Comments are now treated as whitespace when determining whether an operator is prefix, postfix, or binary. For example, these now work:\n\n  ```swift\n  if /*comment*/!foo { ... }\n  1 +/*comment*/2\n  ```\n\n  Comments can no longer appear between a unary operator and its argument.\n\n  ```swift\n  foo/* comment */! // no longer works\n  ```\n\n  Parse errors resulting from this change can be resolved by moving the comment outside the expression.\n\n* [SE-0031][]:\n\n  The location of the inout attribute moves to after the colon (`:`) and before the parameter type.\n\n  ```swift\n  func foo(inout x: Int) {\n  }\n  ```\n\n  will now be written as:\n\n  ```swift\n  func foo(x: inout Int) {\n  }\n  ```\n\n* [SE-0053][]:\n\n  `let` is no longer accepted as a parameter attribute for functions. The compiler provides a fixit to remove it from the function declaration.\n\n* [SE-0003][]:\n\n  `var` is no longer accepted as a parameter attribute for functions. The compiler provides a fixit to create a shadow copy in the function body.\n\n  ```swift\n  func foo(var x: Int) {\n  }\n  ```\n\n  will now be written as:\n\n  ```swift\n  func foo(x: Int) {\n    var x = x\n  }\n  ```\n\n* The \"none\" members of imported NS_OPTIONS option sets are marked as unavailable when they are imported.  Use `[]` to make an empty option set, instead of a None member.\n\n* [SE-0043][]\n\n  Adds the ability to declare variables in multiple patterns in cases.\n\n* [SE-0005][]\n\n  Allows the Clang importer to import ObjC symbols using substantially different Swift-like naming paradigms:\n\n  * These updates generalize the use of `swift_name`, allowing arbitrary C and Objective-C entity import names. This adds fine-grained control over the import process.\n  * Redundant type names are pruned (`documentForURL(_: NSURL)` becomes `document(for: URL)`). Selectors are guaranteed to never be empty, to be transformed into Swift keywords, to be vacuously named (like `get`, `set`, `with`, `for`). Additional pruning rules preserve readability and sense.\n  * Common arguments are sensibly defaulted where the Objective-C API strongly hints at the need for a default argument. (For example,  nullable trailing closures default to `nil`, option sets to `[]`, and `NSDictionary` parameters to `[:]`.) First argument labels are added for defaulted arguments.\n  * Boolean properties are prepended with `is`, and read as assertions on the receiver.\n  * Non-type values, including enumerators, are lowercased.\n  * Classes that implement `compare(_:) -> NSComparisonResult` automatically import as `Comparable`.\n\n* [SE-0040][]\n\n  Attributes change from using `=` in parameters lists\n  to using `:`, aligning with function call syntax.\n\n  ```swift\n  // before\n  @available(*, unavailable, renamed=\"MyRenamedProtocol\")\n\n  // after\n  @available(*, unavailable, renamed: \"MyRenamedProtocol\")\n  ```\n\n* [SE-0048][]\n\n  Generic typealiases are now supported. For example:\n\n  ```swift\n  typealias StringDictionary<T> = Dictionary<String, T>\n  typealias IntFunction<T> = (T) -> Int\n  typealias MatchingTriple<T> = (T, T, T)\n  typealias BackwardTriple<T1, T2, T3> = (T3, T2, T1)\n  ```\n\n  etc.\n\n* [SE-0049][]\n\n  The `@noescape` attribute is extended to be a more general type attribute. You can now declare values of `@noescape` function type, e.g. in manually curried function signatures.  You can now also declare local variables of `@noescape` type, and use `@noescape` in `typealiases`.  For example, this is now valid code:\n\n  ```swift\n  func apply<T, U>(@noescape f: T -> U,\n                   @noescape g: (@noescape T -> U) -> U) -> U {\n    return g(f)\n  }\n  ```\n\n* [SE-0034][]\n\n  The `#line` directive (which resets the logical\n  source location for diagnostics and debug information) is renamed to `#sourceLocation`.\n\n* [SE-0002][]\n\n  Curried function syntax (with successive parenthesized groups of arguments) is removed, and now produces a compile-time error. Use chained functional return types instead.\n\n  ```swift\n  // Before\n  public func project(function f: FunctionType)(p0: CGPoint, p1: CGPoint)(x: CGFloat) -> CGPoint\n\n  // After\n  public func project(function f: FunctionType) -> (p0: CGPoint, p1: CGPoint) -> (x: CGFloat) -> CGPoint\n  ```\n\n* Generic signatures can now contain superclass requirements with generic parameter types, for example:\n\n  ```swift\n  func f<Food : Chunks<Meat>, Meat : Molerat>(f: Food, m: Meat) {}\n  ```\n\n* Section markers are created in ELF binaries through special objects during link time. These objects allow for the deletion of `swift.ld` and the use of non-BFD linkers. A new argument to swiftc is provided to select the linker used, and the gold linker is set as the default for arm-based platforms.\n\n* Catch blocks in `rethrows` functions may now `throw` errors. For example:\n\n    ```swift\n    func process(f: () throws -> Int) rethrows -> Int {\n        do {\n            return try f()\n        } catch is SomeError {\n            throw OtherError()\n        }\n    }\n    ```\n\n* Throwing closure arguments of a rethrowing function may now be optional. For example:\n\n    ```swift\n    func executeClosureIfNotNil(closure: (() throws -> Void)?) rethrows {\n        try closure?()\n    }\n    ```\n\n* [SE-0064][]:\n\n  The Objective-C selectors for the getter or setter of a property can now be referenced with `#selector`. For example:\n\n    ```swift\n    let sel1 = #selector(getter: UIView.backgroundColor) // sel1 has type Selector\n    let sel2 = #selector(setter: UIView.backgroundColor) // sel2 has type Selector\n    ```\n\n* [SE-0062][]:\n\n  A key-path can now be formed with `#keyPath`. For example:\n\n    ```swift\n    person.valueForKeyPath(#keyPath(Person.bestFriend.lastName))\n    ```\n\n## Swift 2.2\n\n### 2016-03-21 (Xcode 7.3)\n\n* [SE-0011][]:\n\n  Associated types in protocols can now be specified with a new `associatedtype`\n  declaration, to replace the use of `typealias`:\n\n    ```swift\n    protocol P {\n      associatedtype Ty\n    }\n    ```\n\n  The `typealias` keyword is still allowed (but deprecated and produces a warning)\n  in Swift 2.2. This warning will become an error in Swift 3.0.\n\n* [SE-0002][]:\n\n  Curried function syntax has been deprecated, and is slated to be removed in\n  Swift 3.0.\n\n* [SE-0004][]:\n\n  The `++` and `--` operators have been deprecated, and are slated to be removed in\n  Swift 3.0.  As a replacement, please use `x += 1` on integer or floating point\n  types, and `x = x.successor()` on Index types.\n\n* [SE-0029][]:\n\n  The implicit tuple splat behavior in function application has been deprecated\n  and will be removed in Swift 3.0.  For example, this code:\n\n    ```swift\n    func foo(a : Int, b : Int) { ... }\n    let x = (1, b: 2)\n    foo(x)   // Warning, deprecated.\n    ```\n\n  should move to being written as:\n\n    ```swift\n    foo(x.0, x.b)\n    ```\n\n* [SE-0028][]:\n\n  New `#file`, `#line`, `#column`, and `#function` expressions have been introduced to\n  replace the existing `__FILE__`, `__LINE__`, `__COLUMN__`, and `__FUNCTION__` symbols.\n  The `__FILE__`-style symbols have been deprecated, and will be removed in\n  Swift 3.0.\n\n* The operator identifier lexer grammar has been revised to simplify the rules\n  for operators that start with a dot (\".\").  The new rule is that an operator\n  that starts with a dot may contain other dots in it, but operators that start\n  with some other character may not contain dots.  For example:\n\n    ```swift\n    x....foo   --> \"x\" \"....\" \"foo\"\n    x&%^.foo   --> \"x\" \"&%^\"  \".foo\"\n    ```\n\n  This eliminates a special case for the `..<` operator, folding it into a simple\n  and consistent rule.\n\n* [SE-0007][]:\n\n  The \"C-style for loop\", which is spelled `for init; comparison; increment {}`\n  has been deprecated and is slated for removal in Swift 3.0.\n\n* Three new doc comment fields, namely `- keyword:`, `- recommended:`\n  and `- recommendedover:`, allow Swift users to cooperate with code\n  completion engine to deliver more effective code completion results.\n  The `- keyword:` field specifies concepts that are not fully manifested in\n  declaration names. `- recommended:` indicates other declarations are preferred\n  to the one decorated; to the contrary, `- recommendedover:` indicates\n  the decorated declaration is preferred to those declarations whose names\n  are specified.\n\n* Designated class initializers declared as failable or throwing may now\n  return `nil` or throw an error, respectively, before the object has been\n  fully initialized. For example:\n\n    ```swift\n    class Widget : Gadget {\n      let complexity: Int\n\n      init(complexity: Int, elegance: Int) throws {\n        if complexity > 3 { throw WidgetError.TooComplex }\n        self.complexity = complexity\n\n        try super.init(elegance: elegance)\n      }\n    }\n    ```\n\n* All slice types now have `removeFirst()` and `removeLast()` methods.\n\n* `ArraySlice.removeFirst()` now preserves element indices.\n\n* Global `anyGenerator()` functions have been changed into initializers on\n  `AnyGenerator`, making the API more intuitive and idiomatic.  They have been\n  deprecated in Swift 2.2, and will be removed in Swift 3.0.\n\n* Closures appearing inside generic types and generic methods can now be\n  converted to C function pointers, as long as no generic type parameters\n  are referenced in the closure's argument list or body. A conversion of\n  a closure that references generic type parameters now produces a\n  diagnostic instead of crashing.\n\n  **(rdar://problem/22204968)**\n\n* Anonymously-typed members of C structs and unions can now be accessed\n  from Swift. For example, given the following struct 'Pie', the 'crust'\n  and 'filling' members are now imported:\n\n    ```swift\n    struct Pie {\n      struct { bool crispy; } crust;\n      union { int fruit; } filling;\n    }\n    ```\n\n  Since Swift does not support anonymous structs, these fields are\n  imported as properties named `crust` and `filling` having nested types\n  named `Pie.__Unnamed_crust` and `Pie.__Unnamed_filling`.\n\n  **(rdar://problem/21683348)**\n\n* [SE-0001][]:\n\n  Argument labels and parameter names can now be any keyword except\n  `var`, `let`, or `inout`. For example:\n\n  ```swift\n  NSURLProtectionSpace(host: \"somedomain.com\", port: 443, protocol: \"https\",\n                       realm: \"Some Domain\", authenticationMethod: \"Basic\")\n  ```\n\n  would previously have required `protocol` to be surrounded in\n  back-ticks.\n\n* [SE-0015][]:\n\n  Tuples (up to arity 6) whose elements are all `Comparable` or `Equatable` now\n  implement the full set of comparison/equality operators. The comparison\n  operators are defined in terms of\n  [lexicographical order](https://en.wikipedia.org/wiki/Lexicographical_order).\n\n* The `@objc(SomeName)` attribute is now supported on enums and enum cases to\n  rename the generated Objective-C declaration.\n\n  **(rdar://problem/21930334)**\n\n* [SE-0021][]:\n\n  When referencing a function or initializer, one can provide the\n  complete name, including argument labels. For example:\n\n  ```swift\n  let fn1 = someView.insertSubview(_:at:)\n  let fn2 = someView.insertSubview(_:aboveSubview:)\n\n  let buttonFactory = UIButton.init(type:)\n  ```\n\n* [SE-0020][]:\n\n  There is a new build configuration function, `#if swift(>=x.y)`, which\n  tests if the current Swift language version is at least `x.y`. This\n  allows you to conditionally compile code for multiple language\n  versions in the same file, even with different syntax, by deactivating\n  parsing in inactive code blocks. For example:\n\n  ```swift\n  #if swift(>=2.2)\n    // Only this code will be parsed in Swift 3.0\n    func foo(x: Int) -> (y: Int) -> () {}\n  #else\n    // This code is ignored entirely.\n    func foo(x: Int)(y: Int) {}\n  #endif\n  ```\n\n* [SE-0022][]:\n\n  The Objective-C selector of a Swift method can now be determined\n  directly with the #selector expression, e.g.,:\n\n  ```swift\n  let sel = #selector(insertSubview(_:aboveSubview:)) // sel has type Selector\n  ```\n\n  Along with this change, the use of string literals as selectors has\n  been deprecated, e.g.,\n\n  ```swift\n  let sel: Selector = \"insertSubview:aboveSubview:\"\n  ```\n\n  Generally, such string literals should be replaced with uses of\n  `#selector`, and the compiler will provide Fix-Its that use\n  `#selector`. In cases where this is not possible (e.g., when referring\n  to the getter of a property), one can still directly construct\n  selectors, e.g.:\n\n  ```swift\n  let sel = Selector(\"propertyName\")\n  ```\n\n  Note that the compiler is now checking the string literals used to\n  construct Selectors to ensure that they are well-formed Objective-C\n  selectors and that there is an `@objc` method with that selector.\n\n## Swift 2.1\n\n### 2015-10-21 (Xcode 7.1)\n\n* Enums imported from C now automatically conform to the `Equatable` protocol,\n  including a default implementation of the `==` operator. This conformance\n  allows you to use C enum pattern matching in switch statements with no\n  additional code. **(17287720)**\n\n* The `NSNumber.unsignedIntegerValue` property now has the type `UInt` instead\n  of `Int`, as do other methods and properties that use the `NSUInteger` type\n  in Objective-C and whose names contain `unsigned..`. Most other uses of\n  `NSUInteger` in system frameworks are imported as `Int` as they were in\n  Xcode 7. **(19134055)**\n\n* Field getters and setters are now created for named unions imported from C.\n  In addition, an initializer with a named parameter for the field is provided.\n  For example, given the following Objective-C `typedef`:\n\n  ```objc\n  typedef union IntOrFloat {\n    int intField;\n    float floatField;\n  } IntOrFloat;\n  ```\n\n  Importing this `typedef` into Swift generates the following interface:\n\n  ```swift\n  struct IntOrFloat {\n    var intField: Int { get set }\n    init(intField: Int)\n\n    var floatField: Float { get set }\n    init(floatField: Float)\n  }\n  ```\n\n  **(19660119)**\n\n* Bitfield members of C structs are now imported into Swift. **(21702107)**\n\n* The type `dispatch_block_t` now refers to the type\n  `@convention(block) () -> Void`, as it did in Swift 1.2.\n  This change allows programs using `dispatch_block_create` to work as expected,\n  solving an issue that surfaced in Xcode 7.0 with Swift 2.0.\n\n  **Note:** Converting to a Swift closure value and back is not guaranteed to\n  preserve the identity of a `dispatch_block_t`.\n  **(22432170)**\n\n* Editing a file does not trigger a recompile of files that depend upon it if\n  the edits only modify declarations marked private. **(22239821)**\n\n* Expressions interpolated in strings may now contain string literals.\n  For example, `My name is \\(attributes[\"name\"]!)` is now a valid expression.\n  **(14050788)**\n\n* Error messages produced when the type checker cannot solve its constraint\n  system continue to improve in many cases.\n\n  For example, errors in the body of generic closures (for instance, the\n  argument closure to `map`) are much more usefully diagnosed. **(18835890)**\n\n* Conversions between function types are supported, exhibiting covariance in\n  function result types and contravariance in function parameter types.\n  For example, it is legal to assign a function of type `Any -> Int` to a\n  variable of type `String -> Any`. **(19517003)**\n\n## Swift 2.0\n\n### 2015-09-17 (Xcode 7.0)\n\n#### Swift Language Features\n\n* New `defer` statement. This statement runs cleanup code when the scope is\n  exited, which is particularly useful in conjunction with the new error\n  handling model. For example:\n\n  ```swift\n  func xyz() throws {\n     let f = fopen(\"x.txt\", \"r\")\n     defer { fclose(f) }\n     try foo(f)                    // f is closed if an error is propagated.\n     let f2 = fopen(\"y.txt\", \"r\")\n     defer { fclose(f2) }\n     try bar(f, f2)                // f2 is closed, then f is closed if an error is propagated.\n  }                                // f2 is closed, then f is closed on a normal path\n  ```\n\n  **(17302850)**\n\n* Printing values of certain `enum` types shows the enum `case` and payload, if\n  any. This is not supported for `@objc` enums or certain enums with multiple\n  payloads. **(18334936)**\n\n* You can specify availability information on your own declarations with the\n  `@available()` attribute.\n\n  For example:\n\n  ```swift\n  @available(iOS 8.0, OSX 10.10, *)\n  func startUserActivity() -> NSUserActivity {\n    ...\n  }\n  ```\n\n  This code fragment indicates that the `startUserActivity()` method is\n  available on iOS 8.0+, on OS X v10.10+, and on all versions of any other\n  platform. **(20938565)**\n\n* A new `@nonobjc` attribute is introduced to selectively suppress ObjC export\n  for instance members that would otherwise be `@objc`. **(16763754)**\n\n* Nongeneric classes may now inherit from generic classes. **(15520519)**\n\n* Public extensions of generic types are now permitted.\n\n  ```swift\n  public extension Array { ... }\n  ```\n\n  **(16974298)**\n\n* Enums now support multiple generic associated values, for example:\n\n  ```swift\n  enum Either<T, U> {\n     case Left(T), Right(U)\n  }\n  ```\n\n  **(15666173)**\n\n* **Protocol extensions**: Extensions can be written for protocol types.\n  With these extensions, methods and properties can be added to any type that\n  conforms to a particular protocol, allowing you to reuse more of your code.\n  This leads to more natural caller side \"dot\" method syntax that follows the\n  principle of \"fluent interfaces\" and that makes the definition of generic\n  code simpler (reducing \"angle bracket blindness\"). **(11735843)**\n\n* **Protocol default implementations**: Protocols can have default\n  implementations for requirements specified in a protocol extension, allowing\n  \"mixin\" or \"trait\" like patterns.\n\n* **Availability checking**. Swift reports an error at compile time if you call an\n  API that was introduced in a version of the operating system newer than the\n  currently selected deployment target.\n\n  To check whether a potentially unavailable API is available at runtime, use\n  the new `#available()` condition in an if or guard statement. For example:\n\n  ```swift\n  if #available(iOS 8.0, OSX 10.10, *) {\n    // Use Handoff APIs when available.\n    let activity =\n      NSUserActivity(activityType:\"com.example.ShoppingList.view\")\n    activity.becomeCurrent()\n  } else {\n    // Fall back when Handoff APIs not available.\n  }\n  ```\n\n  **(14586648)**\n\n* Native support for C function pointers: C functions that take function pointer\n  arguments can be called using closures or global functions, with the\n  restriction that the closure must not capture any of its local context.\n  For example, the standard C qsort function can be invoked as follows:\n\n  ```swift\n  var array = [3, 14, 15, 9, 2, 6, 5]\n  qsort(&array, array.count, sizeofValue(array[0])) { a, b in\n    return Int32(UnsafePointer<Int>(a).memory - UnsafePointer<Int>(b).memory)\n  }\n  print(array)\n  ```\n\n  **(16339559)**\n\n* **Error handling**. You can create functions that `throw`, `catch`, and manage\n  errors in Swift.\n\n  Using this capability, you can surface and deal with recoverable\n  errors, such as \"file-not-found\" or network timeouts. Swift's error handling\n  interoperates with `NSError`. **(17158652)**\n\n* **Testability**: Tests of Swift 2.0 frameworks and apps are written without\n  having to make internal routines public.\n\n  Use `@testable import {ModuleName}` in your test source code to make all\n  public and internal routines usable. The app or framework target needs to be\n  compiled with the `Enable Testability` build setting set to `Yes`. The `Enable\n  Testability` build setting should be used only in your Debug configuration,\n  because it prohibits optimizations that depend on not exporting internal\n  symbols from the app or framework. **(17732115)**\n\n* if statements can be labeled, and labeled break statements can be used as a\n  jump out of the matching if statement.\n\n  An unlabeled break does not exit the if statement. It exits the enclosing\n  loop or switch statement, or it is illegal if none exists. (19150249)\n\n* A new `x?` pattern can be used to pattern match against optionals as a\n  synonym for `.Some(x)`. **(19382878)**\n\n* Concatenation of Swift string literals, including across multiple lines, is\n  now a guaranteed compile-time optimization, even at `-Onone`. **(19125926)**\n\n* Nested functions can now recursively reference themselves and other nested\n  functions. **(11266246)**\n\n* Improved diagnostics:\n  - A warning has been introduced to encourage the use of let instead of var\n    when appropriate.\n  - A warning has been introduced to signal unused variables.\n  - Invalid mutation diagnostics are more precise.\n  - Unreachable switch cases cause a warning.\n  - The switch statement \"exhaustiveness checker\" is smarter.\n  **(15975935,20130240)**\n\n* Failable convenience initializers are allowed to return `nil` before calling\n  `self.init`.\n\n  Designated initializers still must initialize all stored properties before\n  returning `nil`; this is a known limitation. **(20193929)**\n\n* A new `readLine()` function has been added to the standard library.\n  **(15911365)**\n\n* **SIMD Support**: Clang extended vectors are imported and usable in Swift.\n\n  This capability enables many graphics and other low-level numeric APIs\n  (for example, `simd.h`) to be usable in Swift.\n\n* New `guard` statement: This statement allows you to model an early exit out\n  of a scope.\n\n  For example:\n\n  ```swift\n  guard let z = bar() else { return }\n  use(z)\n  ```\n\n  The `else` block is required to exit the scope (for example, with `return`,\n  `throw`, `break`, `continue`, and so forth) or end in a call to a `@noreturn`\n  function. **(20109722)**\n\n* Improved pattern matching: `switch`/`case` pattern matching is available to\n  many new conditional control flow statements, including `if`/`case`,\n  `while`/`case`, `guard`/`case`, and `for-in`/`case`. `for-in` statements can\n  also have `where` clauses, which combine to support many of the features of\n  list comprehensions in other languages.\n\n* A new `do` statement allows scopes to be introduced with the `do` statement.\n\n  For example:\n\n  ```swift\n  do {\n      //new scope\n      do {\n          //another scope\n      }\n  }\n  ```\n\n#### Swift Enhancements and Changes\n\n* A new keyword `try?` has been added to Swift.\n\n  `try?` attempts to perform an operation that may throw. If the operation\n  succeeds, the result is wrapped in an optional; if it fails (that is, if an\n  error is thrown), the result is `nil` and the error is discarded.\n\n  For example:\n\n  ```swift\n  func produceGizmoUsingTechnology() throws -> Gizmo { ... }\n  func produceGizmoUsingMagic() throws -> Gizmo { ... }\n\n  if let result = try? produceGizmoUsingTechnology() { return result }\n  if let result = try? produceGizmoUsingMagic() { return result }\n  print(\"warning: failed to produce a Gizmo in any way\")\n  return nil\n  ```\n\n  `try?` always adds an extra level of `Optional` to the result type of the\n  expression being evaluated. If a throwing function's normal return type is\n  `Int?`, the result of calling it with `try?` will be `Int??`, or\n  `Optional<Optional<Int>>`. **(21692467)**\n\n* Type names and enum cases now print and convert to `String` without\n  qualification by default. `debugPrint` or `String(reflecting:)` can still be\n  used to get fully qualified names. For example:\n\n  ```swift\n  enum Fruit { case Apple, Banana, Strawberry }\n  print(Fruit.Apple)      // \"Apple\"\n  debugPrint(Fruit.Apple) // \"MyApp.Fruit.Apple\")\n  ```\n\n  **(21788604)**\n\n* C `typedef`s of block types are imported as `typealias`s for Swift closures.\n\n  The primary result of this is that `typedef`s for blocks with a parameter of\n  type `BOOL` are imported as closures with a parameter of type `Bool` (rather\n  than `ObjCBool` as in the previous release). This matches the behavior of\n  block parameters to imported Objective-C methods. **(22013912)**\n\n* The type `Boolean` in `MacTypes.h` is imported as `Bool` in contexts that allow\n  bridging between Swift and Objective-C types.\n\n  In cases where the representation is significant, `Boolean` is imported as a\n  distinct `DarwinBoolean` type, which is `BooleanLiteralConvertible` and can be\n  used in conditions (much like the `ObjCBool` type). **(19013551)**\n\n* Fields of C structs that are marked `__unsafe_unretained` are presented in\n  Swift using `Unmanaged`.\n\n  It is not possible for the Swift compiler to know if these references are\n  really intended to be strong (+1) or unretained (+0). **(19790608)**\n\n* The `NS_REFINED_FOR_SWIFT` macro can be used to move an Objective-C\n  declaration aside to provide a better version of the same API in Swift,\n  while still having the original implementation available. (For example, an\n  Objective-C API that takes a `Class` could offer a more precise parameter\n  type in Swift.)\n\n  The `NS_REFINED_FOR_SWIFT` macro operates differently on different declarations:\n\n  - `init` methods will be imported with the resulting Swift initializer having\n    `__` prepended to its first external parameter name.\n\n    ```objc\n    // Objective-C\n    - (instancetype)initWithClassName:(NSString *)name NS_REFINED_FOR_SWIFT;\n    ```\n\n    ```swift\n    // Swift\n    init(__className: String)\n    ```\n\n  - Other methods will be imported with `__` prepended to their base name.\n\n    ```objc\n    // Objective-C\n    - (NSString *)displayNameForMode:(DisplayMode)mode NS_REFINED_FOR_SWIFT;\n    ```\n\n    ```swift\n    // Swift\n    func __displayNameForMode(mode: DisplayMode) -> String\n    ```\n\n  - Subscript methods will be treated like any other methods and will not be\n    imported as subscripts.\n\n  - Other declarations will have `__` prepended to their name.\n\n    ```objc\n    // Objective-C\n    @property DisplayMode mode NS_REFINED_FOR_SWIFT;\n    ```\n\n    ```swift\n    // Swift\n    var __mode: DisplayMode { get set }\n    ```\n\n  **(20070465)**\n\n* Xcode provides context-sensitive code completions for enum elements and\n  option sets when using the shorter dot syntax. **(16659653)**\n\n* The `NSManaged` attribute can be used with methods as well as properties,\n  for access to Core Data's automatically generated Key-Value-Coding-compliant\n  to-many accessors.\n\n  ```swift\n  @NSManaged var employees: NSSet\n\n  @NSManaged func addEmployeesObject(employee: Employee)\n  @NSManaged func removeEmployeesObject(employee: Employee)\n  @NSManaged func addEmployees(employees: NSSet)\n  @NSManaged func removeEmployees(employees: NSSet)\n  ```\n\n  These can be declared in your `NSManagedObject` subclass. **(17583057)**\n\n* The grammar has been adjusted so that lines beginning with '.' are always\n  parsed as method or property lookups following the previous line, allowing\n  for code formatted like this to work:\n\n  ```swift\n  foo\n    .bar\n    .bas = 68000\n  ```\n\n  It is no longer possible to begin a line with a contextual static member\n  lookup (for example, to say `.staticVar = MyType()`). **(20238557)**\n\n* Code generation for large `struct` and `enum` types has been improved to reduce\n  code size. **(20598289)**\n\n* Nonmutating methods of structs, enums, and protocols may now be partially\n  applied to their self parameter:\n\n  ```swift\n  let a: Set<Int> = [1, 2, 3]\n  let b: [Set<Int>] = [[1], [4]]\n  b.map(a.union) // => [[1, 2, 3], [1, 2, 3, 4]]\n  ```\n\n  **(21091944)**\n\n* Swift documentation comments recognize a new top-level list\n  item: `- Throws: ...`\n\n  This item is used to document what errors can be thrown and why. The\n  documentation appears alongside parameters and return descriptions in Xcode\n  QuickHelp. **(21621679)**\n\n* Unnamed parameters now require an explicit `_:` to indicate that they are\n  unnamed. For example, the following is now an error:\n\n  ```swift\n  func f(Int) { }\n  ```\n\n  and must be written as:\n\n  ```swift\n  func f(_: Int) { }\n  ```\n\n  This simplifies the argument label model and also clarifies why cases like\n  `func f((a: Int, b: Int))` do not have parameters named `a` and `b`.\n  **(16737312)**\n\n* It is now possible to append a tuple to an array. **(17875634)**\n\n* The ability to refer to the 0 element of a scalar value (producing the\n  scalar value itself) has been removed. **(17963034)**\n\n* Variadic parameters can now appear anywhere in the parameter list for a\n  function or initializer. For example:\n\n  ```swift\n  func doSomethingToValues(values: Int... , options: MyOptions = [], fn: (Int) -&gt; Void) { ... }\n  ```\n\n  **(20127197)**\n\n* Generic subclasses of Objective-C classes are now supported. **(18505295)**\n\n* If an element of an enum with string raw type does not have an explicit raw\n  value, it will default to the text of the enum's name. For example:\n\n  ```swift\n  enum WorldLayer : String {\n      case Ground, BelowCharacter, Character\n  }\n  ```\n\n  is equivalent to:\n\n  ```swift\n  enum WorldLayer : String {\n      case Ground = \"Ground\"\n      case BelowCharacter = \"BelowCharacter\"\n      case Character = \"Character\"\n  }\n  ```\n\n  **(15819953)**\n\n* The `performSelector` family of APIs is now available for Swift code.\n  **(17227475)**\n\n* When delegating or chaining to a failable initializer (for example, with\n  `self.init(...)` or `super.init(...)`), one can now force-unwrap the result with\n  `!`. For example:\n\n  ```swift\n  extension UIImage {\n    enum AssetIdentifier: String {\n      case Isabella\n      case William\n      case Olivia\n    }\n\n    convenience init(assetIdentifier: AssetIdentifier) {\n      self.init(named: assetIdentifier.rawValue)!\n    }\n  }\n  ```\n\n  **(18497407)**\n\n* Initializers can now be referenced like static methods by referring to\n  `.init` on a static type reference or type object. For example:\n\n  ```swift\n  let x = String.init(5)\n  let stringType = String.self\n  let y = stringType.init(5)\n\n  let oneTwoThree = [1, 2, 3].map(String.init).reduce(\"\", combine: +)\n  ```\n\n  `.init` is still implicit when constructing using a static type, as in\n  `String(5)`. `.init` is required when using dynamic type objects or when\n  referring to the initializer as a function value. **(21375845)**\n\n* Enums and cases can now be marked indirect, which causes the associated\n  value for the enum to be stored indirectly, allowing for recursive data\n  structures to be defined. For example:\n\n  ```swift\n    enum List<T> {\n    case Nil\n    indirect case Cons(head: T, tail: List<T>)\n  }\n\n  indirect enum Tree<T> {\n    case Leaf(T)\n    case Branch(left: Tree<T>, right: Tree<T>)\n  }\n  ```\n\n  **(21643855)**\n\n* Formatting for Swift expression results has changed significantly when\n  using `po` or `expr -O`. Customization that was introduced has been refined\n  in the following ways:\n\n  - The formatted summary provided by either `debugDescription` or\n    `description` methods will always be used for types that conform to\n    `CustomDebugStringConvertible` or `CustomStringConvertible` respectively.\n    When neither conformance is present, the type name is displayed and\n    reference types also display the referenced address to more closely mimic\n    existing behavior for Objective-C classes.\n\n  - Value types such as enums, tuples, and structs display all members\n    indented below the summary by default, while reference types will not. This\n    behavior can be customized for all types by implementing\n    `CustomReflectable`.\n\n  These output customizations can be bypassed by using `p` or `expr` without\n  the `-O` argument to provide a complete list of all fields and their values.\n  **(21463866)**\n\n* Properties and methods using `Unmanaged` can now be exposed to Objective-C.\n  **(16832080)**\n\n* Applying the `@objc` attribute to a class changes that class's compile-time\n  name in the target's generated Objective-C header as well as changing its\n  runtime name. This applies to protocols as well. For example:\n\n  ```swift\n  // Swift\n  @objc(MyAppDelegate)\n  class AppDelegate : NSObject, UIApplicationDelegate {\n    // ...\n  }\n  ```\n\n  ```objc\n  // Objective-C\n  @interface MyAppDelegate : NSObject <UIApplicationDelegate>\n    // ...\n  @end\n  ```\n\n  **(17469485)**\n\n* Collections containing types that are not Objective-C compatible are no\n  longer considered Objective-C compatible types themselves.\n\n  For example, previously `Array<SwiftClassType>` was permitted as the type\n  of a property marked `@objc`; this is no longer the case. **(19787270)**\n\n* Generic subclasses of Objective-C classes, as well as nongeneric classes\n  that inherit from such a class, require runtime metadata instantiation and\n  cannot be directly named from Objective-C code.\n\n  When support for generic subclasses of Objective-C classes was first added,\n  the generated Objective-C bridging header erroneously listed such classes,\n  which, when used, could lead to incorrect runtime behavior or compile-time\n  errors. This has been fixed.\n\n  The behavior of the `@objc` attribute on a class has been clarified such that\n  applying `@objc` to a class which cannot appear in a bridging header is now\n  an error.\n\n  Note that this change does not result in a change of behavior with valid\n  code because members of a class are implicitly `@objc` if any superclass of\n  the class is an `@objc` class, and all `@objc` classes must inherit from\n  NSObject. **(21342574)**\n\n* The performance of `-Onone` (debug) builds has been improved by using\n  prespecialized instances of generics in the standard library. It produces\n  significantly faster executables in debug builds in many cases, without\n  impacting compile time. **(20486658)**\n\n* `AnyObject` and `NSObject` variables that refer to class objects can be cast\n  back to class object types. For example, this code succeeds:\n\n  ```swift\n  let x: AnyObject = NSObject.self\n  let y = x as! NSObject.Type\n  ```\n\n  Arrays, dictionaries, and sets that contain class objects successfully\n  bridge with `NSArray`, `NSDictionary`, and `NSSet` as well. Objective-C APIs\n  that provide `NSArray<Class> *` objects, such as `-[NSURLSessionConfiguration\n  protocolClasses]`, now work correctly when used in Swift. **(16238475)**\n\n* `print()` and reflection via Mirrors is able to report both the current\n  case and payload for all enums with multiple payload types. The only\n  remaining enum types that do not support reflection are `@objc` enums and\n  enums imported from C. **(21739870)**\n\n* Enum cases with payloads can be used as functions. For example:\n\n  ```swift\n  enum Either<T, U> { case Left(T), Right(U) }\n  let lefts: [Either<Int, String>] = [1, 2, 3].map(Either.Left)\n  let rights: [Either<Int, String>] = [\"one\", \"two\", \"three\"].map(Either.Right)\n  ```\n\n  **(19091028)**\n\n* `ExtensibleCollectionType` has been folded into\n  `RangeReplaceableCollectionType`. In addition, default implementations have\n  been added as methods, which should be used instead of the free Swift\n  module functions related to these protocols. **(18220295)**\n\n#### Swift Standard Library\n\n* The standard library moved many generic global functions (such as `map`,\n  `filter`, and `sort`) to be methods written with protocol extensions. This\n  allows those methods to be pervasively available on all sequence and\n  collection types and allowed the removal of the global functions.\n\n* Deprecated enum elements no longer affect the names of nondeprecated\n  elements when an Objective-C enum is imported into Swift. This may cause\n  the Swift names of some enum elements to change. **(17686122)**\n\n* All enums imported from C are `RawRepresentable`, including those not\n  declared with `NS_ENUM` or `NS_OPTIONS`. As part of this change, the value\n  property of such enums has been renamed `rawValue`. **(18702016)**\n\n* Swift documentation comments use a syntax based on the Markdown format,\n  aligning them with rich comments in playgrounds.\n\n  - Outermost list items are interpreted as special fields and are highlighted\n    in Xcode QuickHelp.\n\n  - There are two methods of documenting parameters: parameter outlines and\n    separate parameter fields. You can mix and match these forms as you see\n    fit in any order or continuity throughout the doc comment. Because these\n    are parsed as list items, you can nest arbitrary content underneath them.\n\n  - Parameter outline syntax:\n\n    ```swift\n    - Parameters:\n      - x: ...\n      - y: ...\n    ```\n\n  - Separate parameter fields:\n\n    ```swift\n    - parameter x: ...\n    - parameter y: ...\n    ```\n\n  - Documenting return values:\n\n    ```swift\n    - returns: ...\n    ```\n\n  Other special fields are highlighted in QuickHelp, as well as rendering\n  support for all of Markdown. (20180161)\n\n* The `CFunctionPointer<T -> U>` type has been removed. C function types are\n  specified using the new `@convention(c)` attribute. Like other function\n  types, `@convention(c) T -> U` is not nullable unless made optional. The\n  `@objc_block` attribute for specifying block types has also been removed and\n  replaced with `@convention(block)`.\n\n* Methods and functions have the same rules for parameter names. You can omit\n  providing an external parameter name with `_`. To further simplify the model,\n  the shorthand `#` for specifying a parameter name has been removed, as have\n  the special rules for default arguments.\n\n  ```swift\n  // Declaration\n    func printFunction(str: String, newline: Bool)\n    func printMethod(str: String, newline: Bool)\n    func printFunctionOmitParameterName(str: String, _  newline: Bool)\n\n  // Call\n    printFunction(\"hello\", newline: true)\n    printMethod(\"hello\", newline: true)\n    printFunctionOmitParameterName(\"hello\", true)\n  ```\n\n  **(17218256)**\n\n* `NS_OPTIONS` types get imported as conforming to the `OptionSetType` protocol,\n  which presents a set-like interface for options. Instead of using bitwise\n  operations such as:\n\n  ```swift\n  // Swift 1.2:\n  object.invokeMethodWithOptions(.OptionA | .OptionB)\n  object.invokeMethodWithOptions(nil)\n\n  if options @ .OptionC == .OptionC {\n    // .OptionC is set\n  }\n  ```\n\n  Option sets support set literal syntax, and set-like methods such as contains:\n\n  ```swift\n  object.invokeMethodWithOptions([.OptionA, .OptionB])\n  object.invokeMethodWithOptions([])\n\n  if options.contains(.OptionC) {\n    // .OptionC is set\n  }\n  ```\n\n  A new option set type can be written in Swift as a struct that conforms to\n  the `OptionSetType` protocol. If the type specifies a `rawValue` property and\n  option constants as `static let` constants, the standard library will provide\n  default implementations of the rest of the option set API:\n\n  ```swift\n  struct MyOptions: OptionSetType {\n    let rawValue: Int\n\n    static let TuringMachine  = MyOptions(rawValue: 1)\n    static let LambdaCalculus = MyOptions(rawValue: 2)\n    static let VonNeumann     = MyOptions(rawValue: 4)\n  }\n\n  let churchTuring: MyOptions = [.TuringMachine, .LambdaCalculus]\n  ```\n\n  **(18069205)**\n\n* Type annotations are no longer allowed in patterns and are considered part\n  of the outlying declaration. This means that code previously written as:\n\n  ```swift\n  var (a : Int, b : Float) = foo()\n  ```\n\n  needs to be written as:\n\n  ```swift\n  var (a, b) : (Int, Float) = foo()\n  ```\n\n  if an explicit type annotation is needed. The former syntax was ambiguous\n  with tuple element labels. **(20167393)**\n\n* The `do`/`while` loop is renamed to `repeat`/`while` to make it obvious\n  whether a statement is a loop from its leading keyword.\n\n  In Swift 1.2:\n\n  ```swift\n  do {\n  ...\n  } while <condition>\n  ```\n\n  In Swift 2.0:\n\n  ```swift\n  repeat {\n  ...\n  } while <condition>\n  ```\n\n  **(20336424)**\n\n* `forEach` has been added to `SequenceType`. This lets you iterate over\n  elements of a sequence, calling a body closure on each. For example:\n\n  ```swift\n  (0..<10).forEach {\n    print($0)\n  }\n  ```\n\n  This is very similar to the following:\n\n  ```swift\n  for x in 0..<10 {\n    print(x)\n  }\n  ```\n\n  But take note of the following differences:\n\n  - Unlike for-in loops, you can't use `break` or `continue` to exit the current\n    call of the body closure or skip subsequent calls.\n\n  - Also unlike for-in loops, using `return` in the body closure only exits from\n    the current call to the closure, not any outer scope, and won't skip\n    subsequent calls.\n\n  **(18231840)**\n\n* The `Word` and `UWord` types have been removed from the standard library; use\n  `Int` and `UInt` instead. **(18693488)**\n\n* Most standard library APIs that take closures or `@autoclosure` parameters\n  now use `rethrows`. This allows the closure parameters to methods like `map`\n  and `filter` to throw errors, and allows short-circuiting operators like `&&`,\n  `||`, and `??` to work with expressions that may produce errors.\n  **(21345565)**\n\n* SIMD improvements: Integer vector types in the simd module now only support\n  unchecked arithmetic with wraparound semantics using the `&+`, `&-`, and `&*`\n  operators, in order to better support the machine model for vectors.\n  The `+`, `-`, and `*` operators are unavailable on integer vectors, and Xcode\n  automatically suggests replacing them with the wrapping operators.\n\n  Code generation for vector types in the simd module has been improved to\n  better utilize vector hardware, leading to dramatically improved performance\n  in many cases. **(21574425)**\n\n* All `CollectionType` objects are now sliceable. `SequenceType` now has a notion\n  of `SubSequence`, which is a type that represents only some of the values but\n  in the same order. For example, the `ArraySubSequence` type is `ArraySlice`,\n  which is an efficient view on the `Array` type's buffer that avoids copying as\n  long as it uniquely references the `Array` from which it came.\n\n  The following free Swift functions for splitting/slicing sequences have been\n  removed and replaced by method requirements on the `SequenceType` protocol\n  with default implementations in protocol extensions. `CollectionType` has\n  specialized implementations, where possible, to take advantage of efficient\n  access of its elements.\n\n  ```swift\n  /// Returns the first `maxLength` elements of `self`,\n  /// or all the elements if `self` has fewer than `maxLength` elements.\n  prefix(maxLength: Int) -> SubSequence\n\n  /// Returns the last `maxLength` elements of `self`,\n  /// or all the elements if `self` has fewer than `maxLength` elements.\n  suffix(maxLength: Int) -> SubSequence\n\n  /// Returns all but the first `n` elements of `self`.\n  dropFirst(n: Int) -> SubSequence\n\n  /// Returns all but the last `n` elements of `self`.\n  dropLast(n: Int) -> SubSequence\n\n  /// Returns the maximal `SubSequence`s of `self`, in order, that\n  /// don't contain elements satisfying the predicate `isSeparator`.\n  split(maxSplits maxSplits: Int, allowEmptySlices: Bool, @noescape isSeparator: (Generator.Element) -> Bool) -> [SubSequence]\n  ```\n\n  The following convenience extension is provided for `split`:\n\n  ```swift\n  split(separator: Generator.Element, maxSplit: Int, allowEmptySlices: Bool) -> [SubSequence]\n  ```\n\n  Also, new protocol requirements and default implementations on\n  `CollectionType` are now available:\n\n  ```swift\n  /// Returns `self[startIndex..<end]`\n  prefixUpTo(end: Index) -> SubSequence\n\n  /// Returns `self[start..<endIndex]`\n  suffixFrom(start: Index) -> SubSequence\n\n  /// Returns `prefixUpTo(position.successor())`\n  prefixThrough(position: Index) -> SubSequence\n  ```\n\n  **(21663830)**\n\n* The `print` and `debugPrint` functions are improved:\n  - Both functions have become variadic, and you can print any number of items\n    with a single call.\n  - `separator: String = \" \"` was added so you can control how the items are\n    separated.\n  - `terminator: String = \"\\n\"` replaced `appendNewline: bool = true.`  With\n    this change, `print(x, appendNewline: false)` is expressed as\n    `print(x, terminator: \"\")`.\n\n  - For the variants that take an output stream, the argument label `toStream`\n    was added to the stream argument.\n\n  The `println` function from Swift 1.2 has been removed. **(21788540)**\n\n* For consistency and better composition of generic code, `ArraySlice` indices\n  are no longer always zero-based but map directly onto the indices of the\n  collection they are slicing and maintain that mapping even after mutations.\n\n  Before:\n\n  ```swift\n  var a = Array(0..<10)\n  var s = a[5..<10]\n  s.indices        // 0..<5\n  s[0] = 111\n  s                // [111, 6, 7, 8, 9]\n  s.removeFirst()\n  s.indices        // 1..<5\n  ```\n\n  After:\n\n  ```swift\n  var a = Array(0..<10)\n  var s = a[5..<10]\n  s.indices        // 5..<10\n  s[5] = 99\n  s                // [99, 6, 7, 8, 9]\n  s.removeFirst()\n  s.indices        // 6..<10\n  ```\n\n  Rather than define variants of collection algorithms that take explicit\n  subrange arguments, such as `a.sortSubrangeInPlace(3..<7)`, the Swift\n  standard library provides \"slicing,\" which composes well with algorithms.\n  This enables you to write `a[3..<7].sortInPlace()`, for example. With most\n  collections, these algorithms compose naturally.\n\n  For example, before this change was incorporated:\n\n  ```swift\n  extension MyIntCollection {\n    func prefixThroughFirstNegativeSubrange() -> SubSequence {\n      // Find the first negative element\n      let firstNegative = self.indexOf { $0 < 0 } ?? endIndex\n\n      // Slice off non-negative prefix\n      let startsWithNegative = self.suffixFrom(firstNegative)\n\n      // Find the first non-negative position in the slice\n      let end = startsWithNegative.indexOf { $0 >= 0 } ?? endIndex\n      return self[startIndex..<end]\n    }\n  }\n  ```\n\n  The above code would work for any collection of `Int`s unless the collection\n  is an `Array<Int>`. Unfortunately, when array slice indices are zero-based,\n  the last two lines of the method need to change to:\n\n  ```swift\n  let end = startsWithNegative.indexOf { $0 >= 0 }\n    ?? startsWithNegative.endIndex\n  return self[startIndex..<end + firstNegative]\n  ```\n\n  These differences made working with slices awkward, error-prone, and\n  nongeneric.\n\n  After this change, Swift collections start to provide a guarantee that, at\n  least until there is a mutation, slice indices are valid in the collection\n  from which they were sliced, and refer to the same elements. **(21866825)**\n\n* The method `RangeReplaceableCollectionType.extend()` was renamed to\n  `appendContentsOf()`, and the `splice()` method was renamed to\n  `insertContentsOf()`. **(21972324)**\n\n* `find` has been renamed to `indexOf()`, sort has been renamed to\n  `sortInPlace()`, and `sorted()` becomes `sort()`.\n\n* `String.toInt()` has been renamed to a failable `Int(String)` initializer,\n  since initialization syntax is the preferred style for type conversions.\n\n* `String` no longer conforms to `SequenceType` in order to prevent non-Unicode\n  correct sequence algorithms from being prominently available on String. To\n  perform grapheme-cluster-based, UTF-8-based, or UTF-16-based algorithms, use\n  the `.characters`, `.utf8`, and `.utf16` projections respectively.\n\n* Generic functions that declare type parameters not used within the generic\n  function's type produce a compiler error. For example:\n\n  ```swift\n  func foo<T>() { } // error: generic parameter 'T' is not used in function signature\n  ```\n\n* The `Dictionary.removeAtIndex(_:)` method now returns the key-value pair\n  being removed as a two-element tuple (rather than returning `Void`).\n  Similarly, the `Set.removeAtIndex(_:)` method returns the element being\n  removed. **(20299881)**\n\n* Generic parameters on types in the Swift standard library have been renamed\n  to reflect the role of the types in the API. For example, `Array<T>` became\n  `Array<Element>`, `UnsafePointer<T>` became `UnsafePointer<Memory>`, and so\n  forth. **(21429126)**\n\n* The `SinkType` protocol and `SinkOf` struct have been removed from the standard\n  library in favor of `(T) -> ()` closures. **(21663799)**\n\n## Swift 1.2\n\n### 2015-04-08 (Xcode 6.3)\n\n#### Swift Language Changes\n\n* The notions of guaranteed conversion and \"forced failable\" conversion are now\n  separated into two operators. Forced failable conversion now uses the `as!`\n  operator. The `!` makes it clear to readers of code that the cast may fail and\n  produce a runtime error. The `as` operator remains for upcasts\n  (e.g. `someDerivedValue as Base`) and type annotations (`0 as Int8`) which\n  are guaranteed to never fail. **(19031957)**\n\n* Immutable (`let`) properties in `struct` and `class` initializers have been\n  revised to standardize on a general \"`let`s are singly initialized but never\n  reassigned or mutated\" model. Previously, they were completely mutable\n  within the body of initializers. Now, they are only allowed to be assigned\n  to once to provide their value. If the property has an initial value in its\n  declaration, that counts as the initial value for all initializers.\n  **(19035287)**\n\n* The implicit conversions from bridged Objective-C classes\n  (`NSString`/`NSArray`/`NSDictionary`) to their corresponding Swift value types\n  (`String`/`Array`/`Dictionary`) have been removed, making the Swift type\n  system simpler and more predictable.\n\n  This means that the following code will no longer work:\n\n  ```swift\n  import Foundation\n  func log(s: String) { println(x) }\n  let ns: NSString = \"some NSString\" // okay: literals still work\n  log(ns)     // fails with the error\n              // \"'NSString' is not convertible to 'String'\"\n  ```\n\n  In order to perform such a bridging conversion, make the conversion explicit\n  with the as keyword:\n\n  ```swift\n  log(ns as String) // succeeds\n  ```\n\n  Implicit conversions from Swift value types to their bridged Objective-C\n  classes are still permitted. For example:\n\n  ```swift\n  func nsLog(ns: NSString) { println(ns) }\n  let s: String = \"some String\"\n  nsLog(s) // okay: implicit conversion from String to NSString is permitted\n  ```\n\n  Note that these Cocoa types in Objective-C headers are still automatically\n  bridged to their corresponding Swift type, which means that code is only\n  affected if it is explicitly referencing (for example) `NSString` in a Swift\n  source file. It is recommended you use the corresponding Swift types (for\n  example, `String`) directly unless you are doing something advanced, like\n  implementing a subclass in the class cluster. **(18311362)**\n\n* The `@autoclosure` attribute is now an attribute on a parameter, not an\n  attribute on the parameter's type.\n\n  Where before you might have used\n\n  ```swift\n  func assert(predicate : @autoclosure () -> Bool) {...}\n  ```\n\n  you now write this as\n\n  ```swift\n  func assert(@autoclosure predicate : () -> Bool) {...}\n  ```\n\n  **(15217242)**\n\n* The `@autoclosure` attribute on parameters now implies the new `@noescape`\n  attribute.\n\n* Curried function parameters can now specify argument labels.\n\n  For example:\n\n  ```swift\n  func curryUnnamed(a: Int)(_ b: Int) { return a + b }\n  curryUnnamed(1)(2)\n\n  func curryNamed(first a: Int)(second b: Int) -> Int { return a + b }\n  curryNamed(first: 1)(second: 2)\n  ```\n\n  **(17237268)**\n\n* Swift now detects discrepancies between overloading and overriding in the\n  Swift type system and the effective behavior seen via the Objective-C runtime.\n\n  For example, the following conflict between the Objective-C setter for\n  `property` in a class and the method `setProperty` in its extension is now\n  diagnosed:\n\n  ```swift\n  class A : NSObject {\n  var property: String = \"Hello\" // note: Objective-C method 'setProperty:'\n      // previously declared by setter for\n      // 'property' here\n  }\n\n  extension A {\n  func setProperty(str: String) { }     // error: method 'setProperty'\n      // redeclares Objective-C method\n      //'setProperty:'\n  }\n  ```\n\n  Similar checking applies to accidental overrides in the Objective-C runtime:\n\n  ```swift\n  class B : NSObject {\n  func method(arg: String) { }     // note: overridden declaration\n      // here has type '(String) -> ()'\n  }\n\n  class C : B {\n  func method(arg: [String]) { } // error: overriding method with\n      // selector 'method:' has incompatible\n      // type '([String]) -> ()'\n  }\n  ```\n\n  as well as protocol conformances:\n\n  ```swift\n  class MyDelegate : NSObject, NSURLSessionDelegate {\n  func URLSession(session: NSURLSession, didBecomeInvalidWithError:\n      Bool){ } // error: Objective-C method 'URLSession:didBecomeInvalidWithError:'\n      // provided by method 'URLSession(_:didBecomeInvalidWithError:)'\n      // conflicts with optional requirement method\n      // 'URLSession(_:didBecomeInvalidWithError:)' in protocol\n      // 'NSURLSessionDelegate'\n  }\n  ```\n\n  **(18391046, 18383574)**\n\n* The precedence of the Nil Coalescing Operator (`??`) has been raised to bind\n  tighter than short-circuiting logical and comparison operators, but looser\n  than as conversions and range operators. This provides more useful behavior\n  for expressions like:\n\n  ```swift\n  if allowEmpty || items?.count ?? 0 > 0 {...}\n  ```\n\n* The `&/` and `&%` operators were removed, to simplify the language and\n  improve consistency.\n\n  Unlike the `&+`, `&-`, and `&*` operators, these operators did not provide\n  two's-complement arithmetic behavior; they provided special case behavior\n  for division, remainder by zero, and `Int.min/-1`. These tests should be\n  written explicitly in the code as comparisons if needed. **(17926954)**\n\n* Constructing a `UInt8` from an ASCII value now requires the ascii keyword\n  parameter. Using non-ASCII unicode scalars will cause this initializer to\n  trap. **(18509195)**\n\n* The C `size_t` family of types are now imported into Swift as `Int`, since\n  Swift prefers sizes and counts to be represented as signed numbers, even if\n  they are non-negative.\n\n  This change decreases the amount of explicit type conversion between `Int`\n  and `UInt`, better aligns with `sizeof` returning `Int`, and provides safer\n  arithmetic properties. **(18949559)**\n\n* Classes that do not inherit from `NSObject` but do adopt an `@objc` protocol\n  will need to explicitly mark those methods, properties, and initializers\n  used to satisfy the protocol requirements as `@objc`.\n\n  For example:\n\n  ```swift\n  @objc protocol SomethingDelegate {\n      func didSomething()\n  }\n\n  class MySomethingDelegate : SomethingDelegate {\n      @objc func didSomething() { ... }\n  }\n  ```\n\n#### Swift Language Fixes\n\n* Dynamic casts (`as!`, `as?` and `is`) now work with Swift protocol types, so\n  long as they have no associated types. **(18869156)**\n\n* Adding conformances within a Playground now works as expected.\n\n  For example:\n\n  ```swift\n  struct Point {\n    var x, y: Double\n  }\n\n  extension Point : Printable {\n    var description: String {\n      return \"(\\(x), \\(y))\"\n    }\n  }\n\n  var p1 = Point(x: 1.5, y: 2.5)\n  println(p1) // prints \"(1.5, 2.5)\"\n  ```\n\n* Imported `NS_ENUM` types with undocumented values, such as\n  `UIViewAnimationCurve`, can now be converted from their raw integer values\n  using the `init(rawValue:)` initializer without being reset to `nil`. Code\n  that used `unsafeBitCast` as a workaround for this issue can be written to\n  use the raw value initializer.\n\n  For example,\n\n  ```swift\n  let animationCurve =\n    unsafeBitCast(userInfo[UIKeyboardAnimationCurveUserInfoKey].integerValue,\n    UIViewAnimationCurve.self)\n  ```\n\n  can now be written instead as\n\n  ```swift\n  let animationCurve = UIViewAnimationCurve(rawValue:\n    userInfo[UIKeyboardAnimationCurveUserInfoKey].integerValue)!\n  ```\n\n  **(19005771)**\n\n* Negative floating-point literals are now accepted as raw values in enums.\n  **(16504472)**\n\n* Unowned references to Objective-C objects, or Swift objects inheriting from\n  Objective-C objects, no longer cause a crash if the object holding the\n  unowned reference is deallocated after the referenced object has been\n  released. **(18091547)**\n\n* Variables and properties with observing accessors no longer require an\n  explicit type if it can be inferred from the initial value expression.\n  **(18148072)**\n\n* Generic curried functions no longer produce random results when fully\n  applied. **(18988428)**\n\n* Comparing the result of a failed `NSClassFromString` lookup against `nil` now\n  behaves correctly. **(19318533)**\n\n* Subclasses that override base class methods with co- or contravariance in\n  Optional types no longer cause crashes at runtime.\n\n  For example:\n\n  ```swift\n  class Base {\n    func foo(x: String) -> String? { return x }\n  }\n  class Derived: Base {\n    override func foo(x: String?) -> String { return x! }\n  }\n  ```\n\n  **(19321484)**\n\n#### Swift Language Enhancements\n\n* Swift now supports building targets incrementally, i.e. not rebuilding\n  every Swift source file in a target when a single file is changed.\n\n  The incremental build capability is based on a conservative dependency\n  analysis, so you may still see more files rebuilding than absolutely\n  necessary. If you find any cases where a file is not rebuilt when it should\n  be, please file a bug report. Running Clean on your target afterwards should\n  allow you to complete your build normally. **(18248514)**\n\n* A new `Set` data structure is included which provides a generic collection of\n  unique elements with full value semantics. It bridges with `NSSet`, providing\n  functionality analogous to `Array` and `Dictionary`. **(14661754)**\n\n* The `if-let` construct has been expanded to allow testing multiple optionals\n  and guarding conditions in a single `if` (or `while`) statement using syntax\n  similar to generic constraints:\n\n  ```swift\n  if let a = foo(), b = bar() where a < b,\n     let c = baz() {\n  }\n  ```\n\n  This allows you to test multiple optionals and include intervening boolean\n  conditions, without introducing undesirable nesting (for instance, to avoid\n  the optional unwrapping _\"pyramid of doom\"_).\n\n  Further, `if-let` now also supports a single leading boolean condition along\n  with optional binding `let` clauses. For example:\n\n  ```swift\n  if someValue > 42 && someOtherThing < 19, let a = getOptionalThing() where a > someValue {\n  }\n  ```\n\n  **(19797158, 19382942)**\n\n* The `if-let` syntax has been extended to support a single leading boolean\n  condition along with optional binding `let` clauses.\n\n  For example:\n\n  ```swift\n  if someValue > 42 && someOtherThing < 19, let a = getOptionalThing() where a > someValue {\n  }\n  ```\n\n  **(19797158)**\n\n* `let` constants have been generalized to no longer require immediate\n  initialization. The new rule is that a `let` constant must be initialized\n  before use (like a `var`), and that it may only be initialized: not\n  reassigned or mutated after initialization. This enables patterns such as:\n\n  ```swift\n  let x: SomeThing\n  if condition {\n    x = foo()\n  } else {\n    x = bar()\n  }\n  use(x)\n  ```\n\n  which formerly required the use of a `var`, even though there is no mutation\n  taking place. **(16181314)**\n\n* `static` methods and properties are now allowed in classes (as an alias for\n  `class final`). You are now allowed to declare static stored properties in\n  classes, which have global storage and are lazily initialized on first\n  access (like global variables). Protocols now declare type requirements as\n  static requirements instead of declaring them as class requirements.\n  **(17198298)**\n\n* Type inference for single-expression closures has been improved in several ways:\n  - Closures that are comprised of a single return statement are now type\n    checked as single-expression closures.\n  - Unannotated single-expression closures with non-`Void` return types can now\n    be used in `Void` contexts.\n  - Situations where a multi-statement closure's type could not be inferred\n    because of a missing return-type annotation are now properly diagnosed.\n\n* Swift enums can now be exported to Objective-C using the `@objc` attribute.\n  `@objc` enums must declare an integer raw type, and cannot be generic or use\n  associated values. Because Objective-C enums are not namespaced, enum cases\n  are imported into Objective-C as the concatenation of the enum name and\n  case name.\n\n  For example, this Swift declaration:\n\n  ```swift\n  // Swift\n  @objc\n  enum Bear: Int {\n     case Black, Grizzly, Polar\n  }\n  ```\n\n  imports into Objective-C as:\n\n  ```objc\n  // Objective-C\n  typedef NS_ENUM(NSInteger, Bear) {\n     BearBlack, BearGrizzly, BearPolar\n  };\n  ```\n\n  **(16967385)**\n\n* Objective-C language extensions are now available to indicate the nullability\n  of pointers and blocks in Objective-C APIs, allowing your Objective-C APIs\n  to be imported without `ImplicitlyUnwrappedOptional`. (See items below for\n  more details.) **(18868820)**\n\n* Swift can now partially import C aggregates containing unions, bitfields,\n  SIMD vector types, and other C language features that are not natively\n  supported in Swift. The unsupported fields will not be accessible from\n  Swift, but C and Objective-C APIs that have arguments and return values of\n  these types can be used in Swift. This includes the Foundation `NSDecimal`\n  type and the `GLKit` `GLKVector` and `GLKMatrix` types, among others.\n  **(15951448)**\n\n* Imported C structs now have a default initializer in Swift that initializes\n  all of the struct's fields to zero.\n\n  For example:\n\n  ```swift\n  import Darwin\n  var devNullStat = stat()\n  stat(\"/dev/null\", &devNullStat)\n  ```\n\n  If a structure contains fields that cannot be correctly zero initialized\n  (i.e. pointer fields marked with the new `__nonnull` modifier), this default\n  initializer will be suppressed. **(18338802)**\n\n* New APIs for converting among the `Index` types for `String`,\n  `String.UnicodeScalarView`, `String.UTF16View`, and `String.UTF8View` are\n  available, as well as APIs for converting each of the `String` views into\n  `String`s. **(18018911)**\n\n* Type values now print as the full demangled type name when used with\n  `println` or string interpolation.\n\n  ```swift\n  toString(Int.self)          // prints \"Swift.Int\"\n  println([Float].self)       // prints \"Swift.Array&lt;Swift.Float&gt;\"\n  println((Int, String).self) // prints \"(Swift.Int, Swift.String)\"\n  ```\n\n  **(18947381)**\n\n* A new `@noescape` attribute may be used on closure parameters to functions.\n  This indicates that the parameter is only ever called (or passed as an\n  `@noescape` parameter in a call), which means that it cannot outlive the\n  lifetime of the call. This enables some minor performance optimizations,\n  but more importantly disables the `self.` requirement in closure arguments.\n  This enables control-flow-like functions to be more transparent about their\n  behavior. In a future beta, the standard library will adopt this attribute\n  in functions like `autoreleasepool()`.\n\n  ```swift\n  func autoreleasepool(@noescape code: () -> ()) {\n     pushAutoreleasePool()\n     code()\n     popAutoreleasePool()\n  }\n  ```\n\n  **(16323038)**\n\n* Performance is substantially improved over Swift 1.1 in many cases. For\n  example, multidimensional arrays are algorithmically faster in some cases,\n  unoptimized code is much faster in many cases, and many other improvements\n  have been made.\n\n* The diagnostics emitted for expression type check errors are greatly\n  improved in many cases. **(18869019)**\n\n* Type checker performance for many common expression kinds has been greatly\n  improved. This can significantly improve build times and reduces the number\n  of \"expression too complex\" errors. **(18868985)**\n\n* The `@autoclosure` attribute has a second form, `@autoclosure(escaping)`, that\n  provides the same caller-side syntax as `@autoclosure` but allows the\n  resulting closure to escape in the implementation.\n\n  For example:\n\n  ```swift\n  func lazyAssertion(@autoclosure(escaping) condition: () -> Bool,\n                     message: String = \"\") {\n    lazyAssertions.append(condition) // escapes\n    }\n  lazyAssertion(1 == 2, message: \"fail eventually\")\n  ```\n\n  **(19499207)**\n\n#### Swift Performance\n\n* A new compilation mode has been introduced for Swift called Whole Module\n  Optimization. This option optimizes all of the files in a target together\n  and enables better performance (at the cost of increased compile time). The\n  new flag can be enabled in Xcode using the `Whole Module Optimization` build\n  setting or by using the `swiftc` command line tool with the flag\n  `-whole-module-optimization`. **(18603795)**\n\n#### Swift Standard Library Enhancements and Changes\n\n* `flatMap` was added to the standard library. `flatMap` is the function that\n  maps a function over something and returns the result flattened one level.\n  `flatMap` has many uses, such as to flatten an array:\n\n  ```swift\n  [[1,2],[3,4]].flatMap { $0 }\n  ```\n\n  or to chain optionals with functions:\n\n  ```swift\n  [[1,2], [3,4]].first.flatMap { find($0, 1) }\n  ```\n\n  **(19881534)**\n\n* The function `zip` was added. It joins two sequences together into one\n  sequence of tuples. **(17292393)**\n\n* `utf16Count` is removed from `String`. Instead use count on the `UTF16` view\n  of the `String`.\n\n  For example:\n\n  ```swift\n  count(string.utf16)\n  ```\n\n  **(17627758)**\n\n## Swift 1.1\n\n### 2014-12-02 (Xcode 6.1.1)\n\n* Class methods and initializers that satisfy protocol requirements now properly\n  invoke subclass overrides when called in generic contexts. For example:\n\n    ```swift\n    protocol P {\n      class func foo()\n    }\n\n    class C: P {\n      class func foo() { println(\"C!\") }\n    }\n\n    class D: C {\n      override class func foo() { println(\"D!\") }\n    }\n\n    func foo<T: P>(x: T) {\n      x.dynamicType.foo()\n    }\n\n    foo(C()) // Prints \"C!\"\n    foo(D()) // Used to incorrectly print \"C!\", now prints \"D!\"\n    ```\n\n  **(18828217)**\n\n### 2014-10-09 (Xcode 6.1)\n\n* Values of type `Any` can now contain values of function type. **(16406907)**\n\n* Documentation for the standard library (displayed in quick help and in the\n  synthesized header for the Swift module) is improved. **(16462500)**\n\n* Class properties don't need to be marked final to avoid `O(n)` mutations on\n  value semantic types. **(17416120)**\n\n* Casts can now be performed between `CF` types (such as `CFString`, `CGImage`,\n  and `SecIdentity`) and AnyObject. Such casts will always succeed at run-time.\n  For example:\n\n  ```swift\n  var cfStr: CFString = ...\n  var obj: AnyObject = cfStr as AnyObject\n  var cfStr = obj as CFString\n  ```\n\n  **(18088474)**\n\n* `HeapBuffer<Value, Element>`, `HeapBufferStorage<Value, Element>`, and\n  `OnHeap<Value>` were never really useful, because their APIs were\n  insufficiently public.  They have been replaced with a single class,\n  `ManagedBuffer<Value, Element>`.  See also the new function\n  `isUniquelyReferenced(x)` which is often useful in conjunction with\n  `ManagedBuffer`.\n\n* The `Character` enum has been turned into a struct, to avoid\n  exposing its internal implementation details.\n\n* The `countElements` function has been renamed `count`, for better\n  consistency with our naming conventions.\n\n* Mixed-sign addition and subtraction operations, that were\n  unintentionally allowed in previous versions, now cause a\n  compilation error.\n\n* OS X apps can now apply the `@NSApplicationMain` attribute to their app delegate\n  class in order to generate an implicit `main` for the app. This works like\n  the `@UIApplicationMain` attribute for iOS apps.\n\n* Objective-C `init` and factory methods are now imported as failable\n  initializers when they can return `nil`. In the absence of information\n  about a potentially-`nil` result, an Objective-C `init` or factory\n  method will be imported as `init!`.\n\n  As part of this change, factory methods that have NSError**\n  parameters, such as `+[NSString\n  stringWithContentsOfFile:encoding:error:]`, will now be imported as\n  (failable) initializers, e.g.,\n\n    ```swift\n    init?(contentsOfFile path: String,\n          encoding: NSStringEncoding,\n          error: NSErrorPointer)\n    ```\n\n* Nested classes explicitly marked `@objc` will now properly be included in a\n  target's generated header as long as the containing context is also\n  (implicitly or explicitly) `@objc`. Nested classes not explicitly marked\n  `@objc` will never be printed in the generated header, even if they extend an\n  Objective-C class.\n\n* All of the `*LiteralConvertible` protocols, as well as\n  `StringInterpolationConvertible`, now use initializers for their\n  requirements rather than static methods starting with\n  `convertFrom`. For example, `IntegerLiteralConvertible` now has the\n  following initializer requirement:\n\n    ```swift\n    init(integerLiteral value: IntegerLiteralType)\n    ```\n  Any type that previously conformed to one of these protocols will\n  need to replace its `convertFromXXX` static methods with the\n  corresponding initializer.\n\n## Swift 1.0\n\n### 2014-09-15 (Xcode 6.0)\n\n* Initializers can now fail by returning `nil`. A failable initializer is\n  declared with `init?` (to return an explicit optional) or `init!` (to return\n  an implicitly-unwrapped optional). For example, you could implement\n  `String.toInt` as a failable initializer of `Int` like this:\n\n    ```swift\n    extension Int {\n      init?(fromString: String) {\n        if let i = fromString.toInt() {\n          // Initialize\n          self = i\n        } else {\n          // Discard self and return 'nil'.\n          return nil\n        }\n      }\n    }\n    ```\n\n  The result of constructing a value using a failable initializer then becomes\n  optional:\n\n    ```swift\n    if let twentytwo = Int(fromString: \"22\") {\n      println(\"the number is \\(twentytwo)\")\n    } else {\n      println(\"not a number\")\n    }\n    ```\n\n  In the current implementation, struct and enum initializers can return `nil`\n  at any point inside the initializer, but class initializers can only return\n  `nil` after all of the stored properties of the object have been initialized\n  and `self.init` or `super.init` has been called. If `self.init` or\n  `super.init` is used to delegate to a failable initializer, then the `nil`\n  return is implicitly propagated through the current initializer if the\n  called initializer fails.\n\n* The `RawRepresentable` protocol that enums with raw types implicitly conform\n  to has been redefined to take advantage of failable initializers. The\n  `fromRaw(RawValue)` static method has been replaced with an initializer\n  `init?(rawValue: RawValue)`, and the `toRaw()` method has been replaced with\n  a `rawValue` property. Enums with raw types can now be used like this:\n\n    ```swift\n    enum Foo: Int { case A = 0, B = 1, C = 2 }\n    let foo = Foo(rawValue: 2)! // formerly 'Foo.fromRaw(2)!'\n    println(foo.rawValue) // formerly 'foo.toRaw()'\n    ```\n\n### 2014-09-02\n\n* Characters can no longer be concatenated using `+`.  Use `String(c1) +\n  String(c2)` instead.\n\n### 2014-08-18\n\n* When force-casting between arrays of class or `@objc` protocol types\n  using `a as [C]`, type checking is now deferred until the moment\n  each element is accessed.  Because bridging conversions from NSArray\n  are equivalent to force-casts from `[NSArray]`, this makes certain\n  Array round-trips through Objective-C code `O(1)` instead of `O(N)`.\n\n### 2014-08-04\n\n* `RawOptionSetType` now implements `BitwiseOperationsType`, so imported\n  `NS_OPTIONS` now support the bitwise assignment operators `|=`, `&=`,\n  and `^=`. It also no longer implements `BooleanType`; to check if an option\n  set is empty, compare it to `nil`.\n\n* Types implementing `BitwiseOperationsType` now automatically support\n  the bitwise assignment operators `|=`, `&=`, and `^=`.\n\n* Optionals can now be coalesced with default values using the `??` operator.\n  `??` is a short-circuiting operator that takes an optional on the left and\n  a non-optional expression on the right. If the optional has a value, its\n  value is returned as a non-optional; otherwise, the expression on the right\n  is evaluated and returned:\n\n    ```swift\n    var sequence: [Int] = []\n    sequence.first ?? 0 // produces 0, because sequence.first is nil\n    sequence.append(22)\n    sequence.first ?? 0 // produces 22, the value of sequence.first\n    ```\n\n* The optional chaining `?` operator can now be mutated through, like `!`.\n  The assignment and the evaluation of the right-hand side of the operator\n  are conditional on the presence of the optional value:\n\n    ```swift\n    var sequences = [\"fibonacci\": [1, 1, 2, 3, 4], \"perfect\": [6, 28, 496]]\n    sequences[\"fibonacci\"]?[4]++ // Increments element 4 of key \"fibonacci\"\n    sequences[\"perfect\"]?.append(8128) // Appends to key \"perfect\"\n\n    sequences[\"cubes\"]?[3] = 3*3*3 // Does nothing; no \"cubes\" key\n    ```\n\n  Note that optional chaining still flows to the right, so prefix increment\n  operators are *not* included in the chain, so this won't type-check:\n\n    ```swift\n    ++sequences[\"fibonacci\"]?[4] // Won't type check, can't '++' Int?\n    ```\n\n### 2014-07-28\n\n* The swift command line interface is now divided into an interactive driver\n  `swift`, and a batch compiler `swiftc`:\n\n  ```\n  swift [options] input-file [program-arguments]\n    Runs the script 'input-file' immediately, passing any program-arguments\n    to the script. Without any input files, invokes the repl.\n\n  swiftc [options] input-filenames\n    The familiar swift compiler interface: compiles the input-files according\n    to the mode options like -emit-object, -emit-executable, etc.\n  ```\n\n* For greater clarity and explicitness when bypassing the type system,\n  `reinterpretCast` has been renamed `unsafeBitCast`, and it has acquired\n  a (required) explicit type parameter.  So\n\n    ```swift\n    let x: T = reinterpretCast(y)\n    ```\n\n  becomes\n\n    ```swift\n    let x = unsafeBitCast(y, T.self)\n    ```\n\n* Because their semantics were unclear, the methods `asUnsigned` (on\n  the signed integer types) and `asSigned` (on the unsigned integer\n  types) have been replaced.  The new idiom is explicit construction\n  of the target type using the `bitPattern:` argument label.  So,\n\n    ```swift\n    myInt.asUnsigned()\n    ```\n\n  has become\n\n    ```swift\n    UInt(bitPattern: myInt)\n    ```\n\n* To better follow Cocoa naming conventions and to encourage\n  immutability, The following pointer types were renamed:\n\n  | Old Name                        | New Name                               |\n  |---------------------------------|----------------------------------------|\n  | `UnsafePointer<T>`              | `UnsafeMutablePointer<T>`              |\n  | `ConstUnsafePointer<T>`         | `UnsafePointer<T>`                     |\n  | `AutoreleasingUnsafePointer<T>` | `AutoreleasingUnsafeMutablePointer<T>` |\n\n  Note that the meaning of `UnsafePointer` has changed from mutable to\n  immutable. As a result, some of your code may fail to compile when\n  assigning to an `UnsafePointer.memory` property.  The fix is to\n  change your `UnsafePointer<T>` into an `UnsafeMutablePointer<T>`.\n\n* The optional unwrapping operator `x!` can now be assigned through, and\n  mutating methods and operators can be applied through it:\n\n    ```swift\n    var x: Int! = 0\n    x! = 2\n    x!++\n\n    // Nested dictionaries can now be mutated directly:\n    var sequences = [\"fibonacci\": [1, 1, 2, 3, 0]]\n    sequences[\"fibonacci\"]![4] = 5\n    sequences[\"fibonacci\"]!.append(8)\n    ```\n\n* The `@auto_closure` attribute has been renamed to `@autoclosure`.\n\n* There is a new `dynamic` declaration modifier. When applied to a method,\n  property, subscript, or initializer, it guarantees that references to the\n  declaration are always dynamically dispatched and never inlined or\n  devirtualized, and that the method binding can be reliably changed at runtime.\n  The implementation currently relies on the Objective-C runtime, so `dynamic`\n  can only be applied to `@objc-compatible` declarations for now. `@objc` now\n  only makes a declaration visible to Objective-C; the compiler may now use\n  vtable lookup or direct access to access (non-dynamic) `@objc` declarations.\n\n    ```swift\n    class Foo {\n      // Always accessed by objc_msgSend\n      dynamic var x: Int\n\n      // Accessed by objc_msgSend from ObjC; may be accessed by vtable\n      // or by static reference in Swift\n      @objc var y: Int\n\n      // Not exposed to ObjC (unless Foo inherits NSObject)\n      var z: Int\n    }\n    ```\n\n  `dynamic` enables KVO, proxying, and other advanced Cocoa features to work\n  reliably with Swift declarations.\n\n* Clang submodules can now be imported:\n\n    ```swift\n    import UIKit.UIGestureRecognizerSubclass\n    ```\n\n* The numeric optimization levels `-O[0-3]` have been removed in favor of the\n  named levels `-Onone` and `-O`.\n\n* The `-Ofast` optimization flag has been renamed to `-Ounchecked`. We will accept\n  both names for now and remove `-Ofast` in a later build.\n\n* An initializer that overrides a designated initializer from its\n  superclass must be marked with the `override` keyword, so that all\n  overrides in the language consistently require the use of\n  `override`. For example:\n\n    ```swift\n    class A {\n      init() { }\n    }\n\n    class B : A {\n      override init() { super.init() }\n    }\n    ```\n\n* Required initializers are now more prominent in several ways. First,\n  a (non-final) class that conforms to a protocol that contains an\n  initializer requirement must provide a required initializer to\n  satisfy that requirement. This ensures that subclasses will also\n  conform to the protocol, and will be most visible with classes that\n  conform to `NSCoding`:\n\n    ```swift\n    class MyClass : NSObject, NSCoding {\n      required init(coder aDecoder: NSCoder!) { /*... */ }\n      func encodeWithCoder(aCoder: NSCoder!) { /* ... */ }\n    }\n    ```\n  Second, because `required` places a significant requirement on all\n  subclasses, the `required` keyword must be placed on overrides of a\n  required initializer:\n\n    ```swift\n    class MySubClass : MyClass {\n      var title: String = \"Untitled\"\n\n      required init(coder aDecoder: NSCoder!) { /*... */ }\n      override func encodeWithCoder(aCoder: NSCoder!) { /* ... */ }\n    }\n    ```\n  Finally, required initializers can now be inherited like any other\n  initializer:\n\n    ```swift\n    class MySimpleSubClass : MyClass { } // inherits the required init(coder:).\n    ```\n\n### 2014-07-21\n\n* Access control has been implemented.\n\n  - `public` declarations can be accessed from any module.\n  - `internal` declarations (the default) can be accessed from within the\n    current module.\n  - `private` declarations can be accessed only from within the current file.\n\n  There are still details to iron out here, but the model is in place.\n  The general principle is that an entity cannot be defined in terms of another\n  entity with less accessibility.\n\n  Along with this, the generated header for a framework will only include\n  public declarations. Generated headers for applications will include public\n  and internal declarations.\n\n* `CGFloat` is now a distinct floating-point type that wraps either a\n  `Float` (on 32-bit architectures) or a `Double` (on 64-bit\n  architectures). It provides all of the same comparison and\n  arithmetic operations of Float and Double, and can be created using\n  numeric literals.\n\n* The immediate mode `swift -i` now works for writing `#!` scripts that take\n  command line arguments. The `-i` option to the swift driver must now come at\n  the end of the compiler arguments, directly before the input filename. Any\n  arguments that come after `-i` and the input filename are treated as arguments\n  to the interpreted file and forwarded to `Process.arguments`.\n\n* Type inference for `for..in` loops has been improved to consider the\n  sequence along with the element pattern. For example, this accepts\n  the following loops that were previously rejected:\n\n    ```swift\n    for i: Int8 in 0..<10 { }\n    for i: Float in 0.0...10.0 { }\n    ```\n\n* Introduced the new `BooleanLiteralConvertible` protocol, which allows\n  user-defined types to support Boolean literals. `true` and `false`\n  are now `Boolean` constants and keywords.\n\n* The `@final`, `@lazy`, `@required` and `@optional` attributes are now\n  considered to be declaration modifiers - they no longer require (or allow) an\n  `@` sign.\n\n* The `@prefix`, `@infix`, and `@postfix` attributes have been changed to\n  declaration modifiers, so they are no longer spelled with an `@` sign.\n  Operator declarations have been rearranged from `operator prefix +` to\n  `prefix operator +` for consistency.\n\n### 2014-07-03\n\n* C function pointer types are now imported as `CFunctionPointer<T>`, where `T`\n  is a Swift function type. `CFunctionPointer` and `COpaquePointer` can be\n  explicitly constructed from one another, but they do not freely convert, nor\n  is `CFunctionPointer` compatible with Swift closures.\n\n  Example: `int (*)(void)` becomes `CFunctionPointer<(Int) -> Void>`.\n\n* The interop model for pointers in C APIs has been simplified. Most code that\n  calls C functions by passing arrays, UnsafePointers, or the addresses of\n  variables with `&x` does not need to change. However, the `CConstPointer` and\n  `CMutablePointer` bridging types have been removed, and functions and methods\n  are now imported as and overridden by taking UnsafePointer and\n  `ConstUnsafePointer` directly. `Void` pointers are now imported as\n  `(Const)UnsafePointer<Void>`; `COpaquePointer` is only imported for opaque\n  types now.\n\n* `Array` types are now spelled with the brackets surrounding the\n  element type. For example, an array of `Int` is written as:\n\n    ```swift\n    var array: [Int]\n    ```\n\n* `Dictionary` types can now be spelled with the syntax `[K : V]`, where `K`\n  is the key type and `V` is the value type. For example:\n\n    ```swift\n    var dict: [String : Int] = [\"Hello\" : 1, \"World\" : 2]\n    ```\n\n  The type `[K : V]` is syntactic sugar for `Dictionary<K, V>`; nothing\n  else has changed.\n\n* The `@IBOutlet` attribute no longer implicitly (and invisibly) changes the type\n  of the declaration it is attached to.  It no longer implicitly makes variables\n  be an implicitly unwrapped optional and no longer defaults them to weak.\n\n* The `\\x`, `\\u` and `\\U` escape sequences in string literals have been\n  consolidated into a single and less error prone `\\u{123456}` syntax.\n\n### 2014-06-23\n\n* The half-open range operator has been renamed from `..` to `..<` to reduce\n  confusion.  The `..<` operator is precedented in Groovy (among other languages)\n  and makes it much more clear that it doesn't include the endpoint.\n\n* Class objects such as `NSObject.self` can now be converted to `AnyObject` and\n  used as object values.\n\n* Objective-C protocol objects such as `NSCopying.self` can now be used as\n  instances of the `Protocol` class, such as in APIs such as XPC.\n\n* Arrays now have full value semantics: both assignment and\n  initialization create a logically-distinct object\n\n* The `sort` function and array method modify the target in-place.  A\n  new `sorted` function and array method are non-mutating, creating\n  and returning a new collection.\n\n### 2014-05-19\n\n* `sort`, `map`, `filter`, and `reduce` methods on `Array`s accept trailing\n  closures:\n\n    ```swift\n    let a = [5, 6, 1, 3, 9]\n    a.sort{ $0 > $1 }\n    println(a)                                 // [9, 6, 5, 3, 1]\n    println(a.map{ $0 * 2 })                   // [18, 12, 10, 6, 2]\n    println(a.map{ $0 * 2 }.filter{ $0 < 10})  // [6, 2]\n    println(a.reduce(1000){ $0 + $1 })         // 1024 (no kidding)\n    ```\n\n* A lazy `map()` function in the standard library works on any `Sequence`.\n  Example:\n\n    ```swift\n    class X {\n      var value: Int\n\n      init(_ value: Int) {\n        self.value = value\n        println(\"created X(\\(value))\")\n      }\n    }\n\n    // logically, this sequence is X(0), X(1), X(2), ... X(50)\n    let lazyXs = map(0..50){ X($0) }\n\n    // Prints \"created X(...)\" 4 times\n    for x in lazyXs {\n      if x.value == 4 {\n        break\n      }\n    }\n    ```\n\n* There's a similar lazy `filter()` function:\n\n    ```swift\n    // 0, 10, 20, 30, 40\n    let tens = filter(0..50) { $0 % 10 == 0 }\n    let tenX = map(tens){ X($0) }    // 5 lazy Xs\n    let tenXarray = Array(tenX)      // Actually creates those Xs\n    ```\n\n* Weak pointers of classbound protocol type work now.\n\n* `IBOutlets` now default to weak pointers with implicit optional type (`T!`).\n\n* `NSArray*` parameters and result types of Objective-C APIs are now\n  imported as `AnyObject[]!`, i.e., an implicitly unwrapped optional\n  array storing `AnyObject` values. For example, `NSView`'s constraints\n  property\n\n    ```objc\n    @property (readonly) NSArray *constraints;\n    ```\n\n  is now imported as\n\n    ```swift\n    var constraints: AnyObject[]!\n    ```\n\n  Note that one can implicitly convert between an `AnyObject[]` and an\n  `NSArray` (in both directions), so (for example) one can still\n  explicitly use `NSArray` if desired:\n\n    ```swift\n    var array: NSArray = view.constraints\n    ```\n\n  Swift arrays bridge to `NSArray` similarly to the way Swift\n  strings bridge to `NSString`.\n\n* `ObjCMutablePointer` has been renamed `AutoreleasingUnsafePointer`.\n\n* `UnsafePointer` (and `AutoreleasingUnsafePointer`)'s `set()` and `get()`\n  have been replaced with a property called `memory`.\n\n  - Previously you would write:\n\n    ```swift\n    val = p.get()\n    p.set(val)\n    ```\n\n  - Now you write:\n\n    ```swift\n    val = p.memory\n    p.memory = val\n    ```\n\n* Removed shorthand `x as T!`; instead use `(x as T)!`\n\n  - `x as T!` now means \"x as implicitly unwrapped optional\".\n\n* Range operators `..` and `...` have been switched.\n\n  - `1..3` now means 1,2\n  - `1...3` now means 1,2,3\n\n* The pound sign (`#`) is now used instead of the back-tick (\\`) to mark\n  an argument name as a keyword argument, e.g.,\n\n    ```swift\n    func moveTo(#x: Int, #y: Int) { ... }\n    moveTo(x: 5, y: 7)\n    ```\n\n* Objective-C factory methods are now imported as initializers. For\n  example, `NSColor`'s `+colorWithRed:green:blue:alpha` becomes\n\n    ```swift\n    init(red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat)\n    ```\n\n  which allows an `NSColor` to be created as, e.g.,\n\n    ```swift\n    NSColor(red: 0.5, green: 0.25, blue: 0.25, alpha: 0.5)\n    ```\n\n  Factory methods are identified by their kind (class methods), name\n  (starts with words that match the words that end the class name),\n  and result type (`instancetype` or the class type).\n\n* Objective-C properties of some `CF` type are no longer imported as `Unmanaged`.\n\n* REPL mode now uses LLDB, for a greatly-expanded set of features. The colon\n  prefix now treats the rest of the line as a command for LLDB, and entering\n  a single colon will drop you into the debugging command prompt. Most\n  importantly, crashes in the REPL will now drop you into debugging mode to\n  see what went wrong.\n\n  If you do have a need for the previous REPL, pass `-integrated-repl`.\n\n* In a UIKit-based application, you can now eliminate your 'main.swift' file\n  and instead apply the `@UIApplicationMain` attribute to your\n  `UIApplicationDelegate` class. This will cause the `main` entry point to the\n  application to be automatically generated as follows:\n\n    ```swift\n    UIApplicationMain(argc, argv, nil,\n                      NSStringFromClass(YourApplicationDelegate.self))\n    ```\n\n  If you need nontrivial logic in your application entry point, you can still\n  write out a `main.swift`. Note that `@UIApplicationMain` and `main.swift` are\n  mutually exclusive.\n\n### 2014-05-13\n\n* weak pointers now work with implicitly unchecked optionals, enabling usecases\n  where you don't want to `!` every use of a weak pointer.  For example:\n\n     ```swift\n     weak var myView : NSView!\n     ```\n\n  of course, they still work with explicitly checked optionals like `NSView?`\n\n* Dictionary subscripting now takes/returns an optional type.  This allows\n  querying a dictionary via subscripting to gracefully fail.  It also enables\n  the idiom of removing values from a dictionary using `dict[key] = nil`.\n  As part of this, `deleteKey` is no longer available.\n\n* Stored properties may now be marked with the `@lazy` attribute, which causes\n  their initializer to be evaluated the first time the property is touched\n  instead of when the enclosing type is initialized.  For example:\n\n    ```swift\n    func myInitializer() -> Int { println(\"hello\\n\"); return 42 }\n    class MyClass {\n      @lazy var aProperty = myInitializer()\n    }\n\n    var c = MyClass()     // doesn't print hello\n    var tmp = c.aProperty // prints hello on first access\n    tmp = c.aProperty     // doesn't print on subsequent loads.\n\n    c = MyClass()         // doesn't print hello\n    c.aProperty = 57      // overwriting the value prevents it from ever running\n    ```\n\n  Because lazy properties inherently rely on mutation of the property, they\n  cannot be `let`s.  They are currently also limited to being members of structs\n  and classes (they aren't allowed as local or global variables yet) and cannot\n  be observed with `willSet`/`didSet` yet.\n\n* Closures can now specify a capture list to indicate with what strength they\n  want to capture a value, and to bind a particular field value if they want to.\n\n  Closure capture lists are square-bracket delimited and specified before the\n  (optional) argument list in a closure.  Each entry may be specified as `weak`\n  or `unowned` to capture the value with a weak or unowned pointer, and may\n  contain an explicit expression if desired.  Some examples:\n\n    ```swift\n    takeClosure { print(self.title) }                    // strong capture\n    takeClosure { [weak self] in print(self!.title) }    // weak capture\n    takeClosure { [unowned self] in print(self.title) }  // unowned capture\n    ```\n\n  You can also bind arbitrary expression to named values in the capture list.\n  The expression is evaluated when the closure is formed, and captured with the\n  specified strength.  For example:\n\n    ```swift\n    // weak capture of \"self.parent\"\n    takeClosure { [weak tmp = self.parent] in print(tmp!.title) }\n    ```\n\n  The full form of a closure can take a signature (an argument list and\n  optionally a return type) if needed.  To use either the capture list or the\n  signature, you must specify the context sensitive `in` keyword.  Here is a\n  (weird because there is no need for `unowned`) example of a closure with both:\n\n    ```swift\n    myNSSet.enumerateObjectsUsingBlock { [unowned self] (obj, stop) in\n      self.considerWorkingWith(obj)\n    }\n    ```\n\n* The word `with` is now removed from the first keyword argument name\n  if an initialized imported from Objective-C. For example, instead of\n  building `UIColor` as:\n\n    ```swift\n    UIColor(withRed: r, green: g, blue: b, alpha: a)\n    ```\n\n  it will now be:\n\n    ```swift\n    UIColor(red: r, green: g, blue: b, alpha: a)\n    ```\n\n* `Dictionary` can be bridged to `NSDictionary` and vice versa:\n\n  - `NSDictionary` has an implicit conversion to `Dictionary<NSObject,\n    AnyObject>`.  It bridges in O(1), without memory allocation.\n\n  - `Dictionary<K, V>` has an implicit conversion to `NSDictionary`.\n    `Dictionary<K, V>` bridges to `NSDictionary` iff both `K` and `V` are\n    bridged.  Otherwise, a runtime error is raised.\n\n    Depending on `K` and `V` the operation can be `O(1)` without memory\n    allocation, or `O(N)` with memory allocation.\n\n* Single-quoted literals are no longer recognized.  Use double-quoted literals\n  and an explicit type annotation to define `Characters` and `UnicodeScalars`:\n\n    ```swift\n    var ch: Character = \"a\"\n    var us: UnicodeScalar = \"a\"\n    ```\n\n### 2014-05-09\n\n* The use of keyword arguments is now strictly enforced at the call\n  site. For example, consider this method along with a call to it:\n\n    ```swift\n    class MyColor {\n      func mixColorWithRed(red: Float, green: Float, blue: Float) { /* ... */ }\n    }\n\n    func mix(color: MyColor, r: Float, g: Float, b: Float) {\n      color.mixColorWithRed(r, g, b)\n    }\n    ```\n\n  The compiler will now complain about the missing `green:` and\n  `blue:` labels, with a Fix-It to correct the code:\n\n    ```\n    color.swift:6:24: error: missing argument labels 'green:blue:' in call\n      color.mixColorWithRed(r, g, b)\n                           ^\n                               green:  blue:\n    ```\n\n  The compiler handles missing, extraneous, and incorrectly-typed\n  argument labels in the same manner. Recall that one can make a\n  parameter a keyword argument with the back-tick or remove a keyword\n  argument with the underscore.\n\n    ```swift\n    class MyColor {\n      func mixColor(`red: Float, green: Float, blue: Float) { /* ... */ }\n      func mixColorGuess(red: Float, _ green: Float, _ blue: Float) { /* ... */ }\n    }\n\n    func mix(color: MyColor, r: Float, g: Float, b: Float) {\n      color.mixColor(red: r, green: g, blue: b) // okay: all keyword arguments\n      color.mixColorGuess(r, g, b) // okay: no keyword arguments\n    }\n    ```\n\n  Arguments cannot be re-ordered unless the corresponding parameters\n  have default arguments. For example, given:\n\n    ```swift\n    func printNumber(`number: Int, radix: Int = 10, separator: String = \",\") { }\n    ```\n\n  The following three calls are acceptable because only the arguments for\n  defaulted parameters are re-ordered relative to each other:\n\n    ```swift\n    printNumber(number: 256, radix: 16, separator: \"_\")\n    printNumber(number: 256, separator: \"_\")\n    printNumber(number: 256, separator: \",\", radix: 16)\n    ```\n\n  However, this call:\n\n    ```swift\n    printNumber(separator: \",\", radix: 16, number: 256)\n    ```\n\n  results in an error due to the re-ordering:\n\n    ```\n    printnum.swift:7:40: error: argument 'number' must precede argument 'separator'\n    printNumber(separator: \",\", radix: 16, number: 256)\n                ~~~~~~~~~~~~~~             ^       ~~~\n    ```\n\n* `;` can no longer be used to demarcate an empty case in a switch statement,\n  use `break` instead.\n\n### 2014-05-07\n\n* The compiler's ability to diagnose many common kinds of type check errors has\n  improved. (`expression does not type-check` has been retired.)\n\n* Ranges can be formed with floating point numbers, e.g. `0.0 .. 100.0`.\n\n* Convenience initializers are now spelled as `convenience init` instead of with\n  the `-> Self` syntax.  For example:\n\n    ```swift\n    class Foo {\n      init(x : Int) {}  // designated initializer\n\n      convenience init() { self.init(42) } // convenience initializer\n    }\n    ```\n\n  You still cannot declare designated initializers in extensions, only\n  convenience initializers are allowed.\n\n* Reference types using the CoreFoundation runtime are now imported as\n  class types.  This means that Swift will automatically manage the\n  lifetime of a `CFStringRef` the same way that it manages the lifetime\n  of an `NSString`.\n\n  In many common cases, this will just work.  Unfortunately, values\n  are returned from `CF`-style APIs in a wide variety of ways, and\n  unlike Objective-C methods, there simply isn't enough consistency\n  for Swift to be able to safely apply the documented conventions\n  universally.  The framework teams have already audited many of the\n  most important `CF`-style APIs, and those APIs should be imported\n  without a hitch into Swift.  For all the APIs which haven't yet\n  been audited, we must import return types using the `Unmanaged` type.\n  This type allows the programmer to control exactly how the object\n  is passed.\n\n  For example:\n\n    ```swift\n    // CFBundleGetAllBundles() returns an Unmanaged<CFArrayRef>.\n    // From the documentation, we know that it returns a +0 value.\n    let bundles = CFBundleGetAllBundles().takeUnretainedValue()\n\n    // CFRunLoopCopyAllModes() returns an Unmanaged<CFArrayRef>.\n    // From the documentation, we know that it returns a +1 value.\n    let modes = CFRunLoopCopyAllModes(CFRunLoopGetMain()).takeRetainedValue()\n    ```\n\n  You can also use `Unmanaged` types to pass and return objects\n  indirectly, as well as to generate unbalanced retains and releases\n  if you really require them.\n\n  The API of the Unmanaged type is still in flux, and your feedback\n  would be greatly appreciated.\n\n### 2014-05-03\n\n* The `@NSManaged` attribute can be applied to the properties of an\n  `NSManagedObject` subclass to indicate that they should be handled by\n  CoreData:\n\n    ```swift\n    class Employee : NSManagedObject {\n      @NSManaged var name: String\n      @NSManaged var department: Department\n    }\n    ```\n\n* The `@weak` and `@unowned` attributes have become context sensitive keywords\n  instead of attributes.  To declare a `weak` or `unowned` pointer, use:\n\n    ```swift\n    weak var someOtherWindow : NSWindow?\n    unowned var someWindow : NSWindow\n    ```\n  ... with no `@` on the `weak`/`unowned`.\n\n### 2014-04-30\n\n* Swift now supports a `#elseif` form for build configurations, e.g.:\n\n    ```swift\n    #if os(OSX)\n      typealias SKColor = NSColor\n    #elseif os(iOS)\n      typealias SKColor = UIColor\n    #else\n      typealias SKColor = Green\n    #endif\n    ```\n\n* You can now use the `true` and `false` constants in build configurations,\n  allowing you to emulate the C idioms of `#if 0` (but spelled `#if false`).\n\n* `break` now breaks out of switch statements.\n\n* It is no longer possible to specify `@mutating` as an attribute, you may only\n  use it as a keyword, e.g.:\n\n    ```swift\n    struct Pair {\n      var x, y : Int\n      mutating func nuke() { x = 0; y = 0 }\n    }\n    ```\n  The former `@!mutating` syntax used to mark setters as non-mutating is now\n  spelled with the `nonmutating` keyword.  Both mutating and nonmutating are\n  context sensitive keywords.\n\n* `NSLog` is now available from Swift code.\n\n* The parser now correctly handles expressions like `var x = Int[]()` to\n  create an empty array of integers.  Previously you'd have to use syntax like\n  `Array<Int>()` to get this.  Now that this is all working, please prefer to\n  use `Int[]` consistently instead of `Array<Int>`.\n\n* `Character` is the new character literal type:\n\n    ```swift\n    var x = 'a' // Infers 'Character' type\n    ```\n\n  You can force inference of `UnicodeScalar` like this:\n\n    ```swift\n    var scalar: UnicodeScalar = 'a'\n    ```\n\n  `Character` type represents a Unicode extended grapheme cluster (to put it\n  simply, a grapheme cluster is what users think of as a character: a base plus\n  any combining marks, or other cases explained in\n  [Unicode Standard Annex #29](http://unicode.org/reports/tr29/)).\n\n### 2014-04-22\n\n* Loops and switch statements can now carry labels, and you can\n  `break`/`continue` to those labels.  These use conventional C-style label\n  syntax, and should be dedented relative to the code they are in.  An example:\n\n    ```swift\n    func breakContinue(x : Int) -> Int {\n    Outer:\n      for a in 0..1000 {\n\n      Switch:\n        switch x {\n        case 42: break Outer\n        case 97: continue Outer\n        case 102: break Switch\n        case 13: continue // continue always works on loops.\n        case 139: break   // break will break out of the switch (but see below)\n        }\n      }\n    }\n    ```\n\n* We are changing the behavior of `break` to provide C-style semantics, to allow\n  breaking out of a switch statement.  Previously, break completely ignored\n  switches so that it would break out of the nearest loop. In the example above,\n  `case 139` would break out of the `Outer` loop, not the `Switch`.\n\n  In order to avoid breaking existing code, we're making this a compile time\n  error instead of a silent behavior change.  If you need a solution for the\n  previous behavior, use labeled break.\n\n  This error will be removed in a week or two.\n\n* Cocoa methods and properties that are annotated with the\n  `NS_RETURNS_INNER_POINTER` attribute, including `-[NSData bytes]` and\n  `-[{NS,UI}Color CGColor]`, are now safe to use and follow the same lifetime\n  extension semantics as ARC.\n\n### 2014-04-18\n\n* Enabling/disabling of asserts\n\n    ```swift\n    assert(condition, msg)\n    ```\n\n  is enabled/disabled dependent on the optimization level. In debug mode at\n  `-O0` asserts are enabled. At higher optimization levels asserts are disabled\n  and no code is generated for them. However, asserts are always type checked\n  even at higher optimization levels.\n\n  Alternatively, assertions can be disabled/enabled by using the frontend flag\n  `-assert-config Debug`, or `-assert-config Release`.\n\n* Added optimization flag `-Ofast`. It disables all assertions (`assert`), and\n  runtime overflow and type checks.\n\n* The \"selector-style\" function and initializer declaration syntax is\n  being phased out. For example, this:\n\n    ```\n    init withRed(red: CGFloat) green(CGFloat) blue(CGFloat) alpha(CGFloat)\n    ```\n\n  will now be written as:\n\n    ```swift\n    init(withRed red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat)\n    ```\n\n  For each parameter, one can have both an argument API name (i.e.,\n  `withRed`, which comes first and is used at the call site) and an\n  internal parameter name that follows it (i.e. `red`, which comes\n  second and is used in the implementation). When the two names are\n  the same, one can simply write the name once and it will be used for\n  both roles (as with `green`, `blue`, and `alpha` above). The\n  underscore (`_`) can be used to mean \"no name\", as when the\n  following function/method:\n\n    ```\n    func murderInRoom(room:String) withWeapon(weapon: String)\n    ```\n\n  is translated to:\n\n    ```swift\n    func murderInRoom(_ room: String, withWeapon weapon: String)\n    ```\n\n  The compiler now complains when it sees the selector-style syntax\n  and will provide Fix-Its to rewrite to the newer syntax.\n\n  Note that the final form of selector syntax is still being hammered\n  out, but only having one declaration syntax, which will be very\n  close to this, is a known.\n\n* Stored properties can now be marked with the `@NSCopying` attribute, which\n  causes their setter to be synthesized with a copy to `copyWithZone:`.  This may\n  only be used with types that conform to the `NSCopying` protocol, or option\n  types thereof.  For example:\n\n    ```swift\n    @NSCopying var myURL : NSURL\n    ```\n\n  This fills the same niche as the (`copy`) attribute on Objective-C properties.\n\n### 2014-04-16\n\n* Optional variables and properties are now default-initialized to `nil`:\n\n    ```swift\n    class MyClass {\n      var cachedTitle: String?       // \"= nil\" is implied\n    }\n    ```\n\n* `@IBOutlet` has been improved in a few ways:\n\n  - `IBOutlets` can now be `@unchecked` optional.\n\n  - An `IBOutlet` declared as non-optional, i.e.,\n\n    ```swift\n    @IBOutlet var button: NSButton\n    ```\n\n    will be treated as an `@unchecked` optional.  This is considered to\n    be the best practice way to write an outlet, unless you want to explicitly\n    handle the null case - in which case, use `NSButton?` as the type. Either\n    way, the `= nil` that was formerly required is now implicit.\n\n* The precedence of `is` and `as` is now higher than comparisons, allowing the\n  following sorts of things to be written without parens:\n\n    ```swift\n    if x is NSButton && y is NSButtonCell { ... }\n\n    if 3/4 as Float == 6/8 as Float { ... }\n    ```\n\n* Objective-C blocks are now transparently bridged to Swift closures. You never\n  have to write `@objc_block` when writing Objective-C-compatible methods anymore.\n  Block parameters are now imported as unchecked optional closure types,\n  allowing `nil` to be passed.\n\n### 2014-04-09\n\n* `Dictionary` changes:\n\n  - `Elements` are now tuples, so you can write\n\n    ```swift\n    for (k, v) in d {\n      // ...\n    }\n    ```\n\n  - `keys` and `values` properties, which are `Collections` projecting\n    the corresponding aspect of each element.  `Dictionary` indices are\n    usable with their `keys` and `values` properties, so:\n\n    ```swift\n    for i in indices(d) {\n      let (k, v) = d[i]\n      assert(k == d.keys[i])\n      assert(v == d.values[i])\n    }\n    ```\n\n* Semicolon can be used as a single no-op statement in otherwise empty cases in\n  `switch` statements:\n\n    ```swift\n    switch x {\n    case 1, 2, 3:\n      print(\"x is 1, 2 or 3\")\n    default:\n      ;\n    }\n    ```\n\n* `override` is now a context sensitive keyword, instead of an attribute:\n\n    ```swift\n    class Base {\n      var property: Int { return 0 }\n      func instanceFunc() {}\n      class func classFunc() {}\n    }\n    class Derived : Base {\n      override var property: Int { return 1 }\n      override func instanceFunc() {}\n      override class func classFunc() {}\n    }\n    ```\n\n### 2014-04-02\n\n* Prefix splitting for imported enums has been revised again due to feedback:\n  - If stripping off a prefix would leave an invalid identifier (like `10_4`),\n    leave one more word in the result than would otherwise be there\n    (`Behavior10_4`).\n  - If all enumerators have a `k` prefix (for `constant`) and the enum doesn't,\n    the `k` should not be considered when finding the common prefix.\n  - If the enum name is a plural (like `NSSomethingOptions`) and the enumerator\n    names use the singular form (`NSSomethingOptionMagic`), this is considered\n    a matching prefix (but only if nothing follows the plural).\n\n* Cocoa APIs that take pointers to plain C types as arguments now get imported\n  as taking the new `CMutablePointer<T>` and `CConstPointer<T>` types instead\n  of `UnsafePointer<T>`. These new types allow implicit conversions from\n  Swift `inout` parameters and from Swift arrays:\n\n    ```swift\n    let rgb = CGColorSpaceCreateDeviceRGB()\n    // CGColorRef CGColorCreate(CGColorSpaceRef, const CGFloat*);\n    let white = CGColorCreate(rgb, [1.0, 1.0, 1.0])\n\n    var s = 0.0, c = 0.0\n    // void sincos(double, double*, double*);\n    sincos(M_PI/2, &s, &c)\n    ```\n\n  Pointers to pointers to ObjC classes, such as `NSError**`, get imported as\n  `ObjCMutablePointer<NSError?>`. This type doesn't work with arrays, but\n  accepts inouts or `nil`:\n\n    ```swift\n    var error: NSError?\n    let words = NSString.stringWithContentsOfFile(\"/usr/share/dict/words\",\n      encoding: .UTF8StringEncoding,\n      error: &error)\n    ```\n\n  `Void` pointer parameters can be passed an array or inout of any type:\n\n    ```swift\n    // + (NSData*)dataWithBytes:(const void*)bytes length:(NSUInteger)length;\n    let data = NSData.dataWithBytes([1.5, 2.25, 3.125],\n                                    length: sizeof(Double.self) * 3)\n    var fromData = [0.0, 0.0, 0.0]\n    // - (void)getBytes:(void*)bytes length:(NSUInteger)length;\n    data.getBytes(&fromData, length: sizeof(Double.self) * 3)\n    ```\n\n  Note that we don't know whether an API reads or writes the C pointer, so\n  you need to explicitly initialize values (like `s` and `c` above) even if\n  you know that the API overwrites them.\n\n  This pointer bridging only applies to arguments, and only works with well-\n  behaved C and ObjC APIs that don't keep the pointers they receive as\n  arguments around or do other dirty pointer tricks. Nonstandard use of pointer\n  arguments still requires `UnsafePointer`.\n\n* Objective-C pointer types now get imported by default as the `@unchecked T?`\n  optional type.  Swift class types no longer implicitly include `nil`.\n\n  A value of `@unchecked T?` can be implicitly used as a value of `T`.\n  Swift will implicitly cause a reliable failure if the value is `nil`,\n  rather than introducing undefined behavior (as in Objective-C ivar\n  accesses or everything in C/C++) or silently ignoring the operation\n  (as in Objective-C message sends).\n\n  A value of `@unchecked T?` can also be implicitly used as a value of `T?`,\n  allowing you explicitly handle the case of a `nil` value.  For example,\n  if you would like to just silently ignore a message send a la Objective-C,\n  you can use the postfix `?` operator like so:\n\n    ```swift\n    fieldsForKeys[kHeroFieldKey]?.setEditable(true)\n    ```\n\n  This design allows you to isolate and handle `nil` values in Swift code\n  without requiring excessive \"bookkeeping\" boilerplate to use values that\n  you expect to be non-`nil`.\n\n  For now, we will continue to import C pointers as non-optional\n  `UnsafePointer` and `C*Pointer` types; that will be evaluated separately.\n\n  We intend to provide attributes for Clang to allow APIs to opt in to\n  importing specific parameters, return types, etc. as either the\n  explicit optional type `T?` or the simple non-optional type `T`.\n\n* The \"separated\" call syntax, i.e.,\n\n    ```\n    NSColor.colorWithRed(r) green(g) blue(b) alpha(a)\n    UIColor.init withRed(r) green(g) blue(b) alpha(a)\n    ```\n\n  is being removed. The compiler will now produce an error and provide\n  Fix-Its to rewrite calls to the \"keyword-argument\" syntax:\n\n    ```swift\n    NSColor.colorWithRed(r, green: g, blue: b, alpha: a)\n    UIColor(withRed: r, green:g, blue:b, alpha: a)\n    ```\n\n* The `objc` attribute now optionally accepts a name, which can be\n  used to provide the name for an entity as seen in Objective-C. For\n  example:\n\n    ```swift\n    class MyType {\n      var enabled: Bool {\n        @objc(isEnabled) get {\n          // ...\n        }\n      }\n    }\n    ```\n\n  The `@objc` attribute can be used to name initializers, methods,\n  getters, setters, classes, and protocols.\n\n* Methods, properties and subscripts in classes can now be marked with the\n  `@final` attribute.  This attribute prevents overriding the declaration in any\n  subclass, and provides better performance (since dynamic dispatch is avoided\n  in many cases).\n\n### 2014-03-26\n\n* Attributes on declarations are no longer comma separated.\n\n  Old syntax:\n\n    ```\n    @_silgen_name(\"foo\"), @objc func bar() {}\n    ```\n\n  New syntax:\n\n    ```swift\n    @_silgen_name(\"foo\") @objc\n    ```\n\n  The `,` was vestigial when the attribute syntax consisted of bracket lists.\n\n* `switch` now always requires a statement after a `case` or `default`.\n\n  Old syntax:\n\n    ```swift\n    switch x {\n    case .A:\n    case .B(1):\n      println(\".A or .B(1)\")\n    default:\n      // Ignore it.\n    }\n    ```\n\n  New syntax:\n\n    ```swift\n    switch x {\n    case .A, .B(1):\n      println(\".A or .B(1)\")\n    default:\n      () // Ignore it.\n    }\n    ```\n\n  The following syntax can be used to introduce guard expressions for patterns\n  inside the `case`:\n\n    ```swift\n    switch x {\n    case .A where isFoo(),\n         .B(1) where isBar():\n      ...\n    }\n    ```\n\n* Observing properties can now `@override` properties in a base class, so you\n  can observe changes that happen to them.\n\n     ```swift\n     class MyAwesomeView : SomeBasicView {\n      @override\n      var enabled : Bool {\n        didSet {\n          println(\"Something changed\")\n        }\n      }\n      ...\n    }\n    ```\n\n  Observing properties still invoke the base class getter/setter (or storage)\n  when accessed.\n\n* An `as` cast can now be forced using the postfix `!` operator without using\n  parens:\n\n    ```swift\n    class B {}\n    class D {}\n\n    let b: B = D()\n\n    // Before\n    let d1: D = (b as D)!\n    // After\n    let d2: D = b as D!\n    ```\n\n  Casts can also be chained without parens:\n\n    ```swift\n    // Before\n    let b2: B = (((D() as B) as D)!) as B\n    // After\n    let b3: B = D() as B as D! as B\n    ```\n\n* `as` can now be used in `switch` cases to match the result of a checked cast:\n\n    ```swift\n    func printHand(hand: Any) {\n      switch hand {\n      case 1 as Int:\n        print(\"ace\")\n      case 11 as Int:\n        print(\"jack\")\n      case 12 as Int:\n        print(\"queen\")\n      case 13 as Int:\n        print(\"king\")\n      case let numberCard as Int:\n        print(\"\\(numberCard)\")\n      case let (a, b) as (Int, Int) where a == b:\n        print(\"two \")\n        printHand(a)\n        print(\"s\")\n      case let (a, b) as (Int, Int):\n        printHand(a)\n        print(\" and a \")\n        printHand(b)\n      case let (a, b, c) as (Int, Int, Int) where a == b && b == c:\n        print(\"three \")\n        printHand(a)\n        print(\"s\")\n      case let (a, b, c) as (Int, Int, Int):\n        printHand(a)\n        print(\", \")\n        printHand(b)\n        print(\", and a \")\n        printHand(c)\n      default:\n        print(\"unknown hand\")\n      }\n    }\n    printHand(1, 1, 1) // prints \"three aces\"\n    printHand(12, 13) // prints \"queen and a king\"\n    ```\n\n* Enums and option sets imported from C/Objective-C still strip common\n  prefixes, but the name of the enum itself is now taken into consideration as\n  well. This keeps us from dropping important parts of a name that happen to be\n  shared by all members.\n\n    ```objc\n    // NSFileManager.h\n    typedef NS_OPTIONS(NSUInteger, NSDirectoryEnumerationOptions) {\n        NSDirectoryEnumerationSkipsSubdirectoryDescendants = 1UL << 0,\n        NSDirectoryEnumerationSkipsPackageDescendants      = 1UL << 1,\n        NSDirectoryEnumerationSkipsHiddenFiles             = 1UL << 2\n    } NS_ENUM_AVAILABLE(10_6, 4_0);\n    ```\n\n    ```swift\n    // Swift\n    let opts: NSDirectoryEnumerationOptions = .SkipsPackageDescendants\n    ```\n\n* `init` methods in Objective-C protocols are now imported as\n  initializers. To conform to `NSCoding`, you will now need to provide\n\n    ```swift\n    init withCoder(aDecoder: NSCoder) { ... }\n    ```\n\n  rather than\n\n    ```swift\n    func initWithCoder(aDecoder: NSCoder) { ... }\n    ```\n\n### 2014-03-19\n\n* When a class provides no initializers of its own but has default\n  values for all of its stored properties, it will automatically\n  inherit all of the initializers of its superclass. For example:\n\n    ```swift\n    class Document {\n      var title: String\n\n      init() -> Self {\n        self.init(withTitle: \"Default title\")\n      }\n\n      init withTitle(title: String) {\n        self.title = title\n      }\n    }\n\n    class VersionedDocument : Document {\n      var version = 0\n\n      // inherits 'init' and 'init withTitle:' from Document\n    }\n    ```\n\n  When one does provide a designated initializer in a subclass, as in\n  the following example:\n\n    ```swift\n    class SecureDocument : Document {\n      var key: CryptoKey\n\n      init withKey(key: CryptoKey) -> Self {\n        self.init(withKey: key, title: \"Default title\")\n      }\n\n      init withKey(key: CryptoKey) title(String) {\n        self.key = key\n        super.init(withTitle: title)\n      }\n    }\n    ```\n\n  the compiler emits Objective-C method stubs for all of the\n  designated initializers of the parent class that will abort at\n  runtime if called, and which indicate which initializer needs to be\n  implemented. This provides memory safety for cases where an\n  Objective-C initializer (such as `-[Document init]` in this example)\n  appears to be inherited, but isn't actually implemented.\n\n* `nil` may now be used as a Selector value. This allows calls to Cocoa methods\n  that accept `nil` selectors.\n\n* `[]` and `[:]` can now be used as the empty array and dictionary literal,\n  respectively.  Because these carry no information about their element types,\n  they may only be used in a context that provides this information through type\n  inference (e.g. when passing a function argument).\n\n* Properties defined in classes are now dynamically dispatched and can be\n  overridden with `@override`.  Currently `@override` only works with computed properties\n  overriding other computed properties, but this will be enhanced in coming weeks.\n\n### 2014-03-12\n\n* The `didSet` accessor of an observing property now gets passed in the old value,\n  so you can easily implement an action for when a property changes value.  For\n  example:\n\n    ```swift\n    class MyAwesomeView : UIView {\n      var enabled : Bool = false {\n      didSet(oldValue):\n        if oldValue != enabled {\n          self.needsDisplay = true\n        }\n      }\n      ...\n    }\n    ```\n\n* The implicit argument name for set and willSet property specifiers has been\n  renamed from `(value)` to `(newValue)`.  For example:\n\n    ```swift\n    var i : Int {\n      get {\n        return 42\n      }\n      set {  // defaults to (newValue) instead of (value)\n        print(newValue)\n      }\n    }\n    ```\n\n* The magic identifier `__FUNCTION__` can now be used to get the name of the\n  current function as a string. Like `__FILE__` and `__LINE__`, if\n  `__FUNCTION__` is used as a default argument, the function name of the caller\n  is passed as the argument.\n\n    ```swift\n    func malkovich() {\n      println(__FUNCTION__)\n    }\n    malkovich() // prints \"malkovich\"\n\n    func nameCaller(name: String = __FUNCTION__) -> String {\n      return name\n    }\n\n    func foo() {\n      println(nameCaller()) // prints \"foo\"\n    }\n\n    func foo(x: Int) bar(y: Int) {\n      println(nameCaller()) // prints \"foo:bar:\"\n    }\n    ```\n\n  At top level, `__FUNCTION__` gives the module name:\n\n    ```swift\n    println(nameCaller()) // prints your module name\n    ```\n\n* Selector-style methods can now be referenced without applying arguments\n  using member syntax `foo.bar:bas:`, for instance, to test for the availability\n  of an optional protocol method:\n\n    ```swift\n    func getFrameOfObjectValueForColumn(ds: NSTableViewDataSource,\n                                        tableView: NSTableView,\n                                        column: NSTableColumn,\n                                        row: Int) -> AnyObject? {\n      if let getObjectValue = ds.tableView:objectValueForTableColumn:row: {\n        return getObjectValue(tableView, column, row)\n      }\n      return nil\n    }\n    ```\n\n* The compiler now warns about cases where a variable is inferred to have\n  `AnyObject`, `AnyClass`, or `()` type, since type inference can turn a simple\n  mistake (e.g. failing to cast an `AnyObject` when you meant to) into something\n  with ripple effects.  Here is a simple example:\n\n    ```\n    t.swift:4:5: warning: variable 'fn' inferred to have type '()', which may be unexpected\n    var fn = abort()\n        ^\n    t.swift:4:5: note: add an explicit type annotation to silence this warning\n    var fn = abort()\n        ^\n          : ()\n    ```\n\n  If you actually did intend to declare a variable of one of these types, you\n  can silence this warning by adding an explicit type (indicated by the Fixit).\n  See **rdar://15263687 and rdar://16252090** for more rationale.\n\n* `x.type` has been renamed to `x.dynamicType`, and you can use `type` as a\n  regular identifier again.\n\n### 2014-03-05\n\n* C macros that expand to a single constant string are now imported as global\n  constants. Normal string literals are imported as `CString`; `NSString` literals\n  are imported as `String`.\n\n* All values now have a `self` property, exactly equivalent to the value\n  itself:\n\n    ```swift\n    let x = 0\n    let x2 = x.self\n    ```\n\n  Types also have a `self` property that is the type object for that\n  type:\n\n    ```swift\n    let theClass = NSObject.self\n    let theObj = theClass()\n    ```\n\n  References to type names are now disallowed outside of a constructor call\n  or member reference; to get a type object as a value, `T.self` is required.\n  This prevents the mistake of intending to construct an instance of a\n  class but forgetting the parens and ending up with the class object instead:\n\n    ```swift\n    let x = MyObject // oops, I meant MyObject()...\n    return x.description() // ...and I accidentally called +description\n                           //    instead of -description\n    ```\n\n* Initializers are now classified as **designated initializers**, which\n  are responsible for initializing the current class object and\n  chaining via `super.init`, and **convenience initializers**, which\n  delegate to another initializer and can be inherited. For example:\n\n    ```swift\n    class A {\n      var str: String\n\n      init() -> Self { // convenience initializer\n        self.init(withString: \"hello\")\n      }\n\n      init withString(str: String) { // designated initializer\n        self.str = str\n      }\n    }\n    ```\n\n  When a subclass overrides all of its superclass's designated\n  initializers, the convenience initializers are inherited:\n\n    ```swift\n    class B {\n      init withString(str: String) { // designated initializer\n        super.init(withString: str)\n      }\n\n      // inherits A.init()\n    }\n    ```\n\n  Objective-C classes that provide `NS_DESIGNATED_INITIALIZER`\n  annotations will have their init methods mapped to designated\n  initializers or convenience initializers as appropriate; Objective-C\n  classes without `NS_DESIGNATED_INITIALIZER` annotations have all of\n  their `init` methods imported as designated initializers, which is\n  safe (but can be verbose for subclasses). Note that the syntax and\n  terminology is still somewhat in flux.\n\n* Initializers can now be marked as `required` with an attribute,\n  meaning that every subclass is required to provide that initializer\n  either directly or by inheriting it from a superclass. To construct\n\n    ```swift\n    class View {\n      @required init withFrame(frame: CGRect) { ... }\n    }\n\n    func buildView(subclassObj: View.Type, frame: CGRect) -> View {\n      return subclassObj(withFrame: frame)\n    }\n\n    class MyView : View {\n      @required init withFrame(frame: CGRect) {\n        super.init(withFrame: frame)\n      }\n    }\n\n    class MyOtherView : View {\n      // error: must override init withFrame(CGRect).\n    }\n    ```\n\n* Properties in Objective-C protocols are now correctly imported as properties.\n  (Previously the getter and setter were imported as methods.)\n\n* Simple enums with no payloads, including `NS_ENUM`s imported\n  from Cocoa, now implicitly conform to the Equatable and Hashable protocols.\n  This means they can be compared with the `==` and `!=` operators and can\n  be used as `Dictionary` keys:\n\n    ```swift\n    enum Flavor {\n      case Lemon, Banana, Cherry\n    }\n\n    assert(Flavor.Lemon == .Lemon)\n    assert(Flavor.Banana != .Lemon)\n\n    struct Profile {\n      var sweet, sour: Bool\n    }\n\n    let flavorProfiles: Dictionary<Flavor, Profile> = [\n      .Lemon:  Profile(sweet: false, sour: true ),\n      .Banana: Profile(sweet: true,  sour: false),\n      .Cherry: Profile(sweet: true,  sour: true ),\n    ]\n    assert(flavorProfiles[.Lemon].sour)\n    ```\n\n* `val` has been removed.  Long live `let`!\n\n* Values whose names clash with Swift keywords, such as Cocoa methods or\n  properties named `class`, `protocol`, `type`, etc., can now be defined and\n  accessed by wrapping reserved keywords in backticks to suppress their builtin\n  meaning:\n\n    ```swift\n    let `class` = 0\n    let `type` = 1\n    let `protocol` = 2\n    println(`class`)\n    println(`type`)\n    println(`protocol`)\n\n    func foo(Int) `class`(Int) {}\n    foo(0, `class`: 1)\n    ```\n\n### 2014-02-26\n\n* The `override` attribute is now required when overriding a method,\n  property, or subscript from a superclass. For example:\n\n    ```swift\n    class A {\n      func foo() { }\n    }\n\n    class B : A {\n      @override func foo() { } // 'override' is required here\n    }\n    ```\n\n* We're renaming `val` back to `let`.  The compiler accepts both for this week,\n  next week it will just accept `let`.  Please migrate your code this week, sorry\n  for the back and forth on this.\n\n* Swift now supports `#if`, `#else` and `#endif` blocks, along with target\n  configuration expressions, to allow for conditional compilation within\n  declaration and statement contexts.\n\n  Target configurations represent certain static information about the\n  compile-time build environment.  They are implicit, hard-wired into the\n  compiler, and can only be referenced within the conditional expression of an\n  `#if` block.\n\n  Target configurations are tested against their values via a pseudo-function\n  invocation expression, taking a single argument expressed as an identifier.\n  The argument represents certain static build-time information.\n\n  There are currently two supported target configurations:\n    `os`, which can have the values `OSX` or `iOS`\n    `arch`, which can have the values `i386`, `x86_64`, `arm` and `arm64`\n\n  Within the context of an `#if` block's conditional expression, a target\n  configuration expression can evaluate to either `true` or `false`.\n\n  For example:\n\n    ```swift\n    #if arch(x86_64)\n      println(\"Building for x86_64\")\n    #else\n      println(\"Not building for x86_64\")\n    #endif\n\n    class C {\n    #if os(OSX)\n      func foo() {\n        // OSX stuff goes here\n      }\n    #else\n      func foo() {\n        // non-OSX stuff goes here\n      }\n    #endif\n    }\n    ```\n\n  The conditional expression of an `#if` block can be composed of one or more of\n  the following expression types:\n    - A unary expression, using `!`\n    - A binary expression, using `&&` or `||`\n    - A parenthesized expression\n    - A target configuration expression\n\n  For example:\n\n    ```swift\n    #if os(iOS) && !arch(I386)\n    ...\n    #endif\n    ```\n\n  Note that `#if`/`#else`/`#endif` blocks do not constitute a preprocessor, and\n  must form valid and complete expressions or statements. Hence, the following\n  produces a parser error:\n\n    ```swift\n    class C {\n\n    #if os(iOS)\n      func foo() {}\n    }\n    #else\n      func bar() {}\n      func baz() {}\n    }\n    #endif\n    ```\n\n  Also note that \"active\" code will be parsed, typechecked and emitted, while\n  \"inactive\" code will only be parsed.  This is why code in an inactive `#if` or\n  `#else` block will produce parser errors for malformed code.  This allows the\n  compiler to detect basic errors in inactive regions.\n\n  This is the first step to getting functionality parity with the important\n  subset of the C preprocessor.  Further refinements are planned for later.\n\n* Swift now has both fully-closed ranges, which include their endpoint, and\n  half-open ranges, which don't.\n\n    ```swift\n    (swift) for x in 0...5 { print(x) } ; print('\\n') // half-open range\n    01234\n    (swift) for x in 0..5 { print(x) } ; print('\\n')  // fully-closed range\n    012345\n    ```\n\n* Property accessors have a new brace-based syntax, instead of using the former\n  \"label like\" syntax.  The new syntax is:\n\n  ```swift\n  var computedProperty: Int {\n    get {\n      return _storage\n    }\n    set {\n      _storage = value\n    }\n  }\n\n  var implicitGet: Int {    // This form still works.\n    return 42\n  }\n\n  var storedPropertyWithObservingAccessors: Int = 0 {\n    willSet { ... }\n    didSet { ... }\n  }\n  ```\n\n* Properties and subscripts now work in protocols, allowing you to do things\n  like:\n\n    ```swift\n    protocol Subscriptable {\n      subscript(idx1: Int, idx2: Int) -> Int { get set }\n      var prop: Int { get }\n    }\n\n    func foo(s: Subscriptable) {\n      return s.prop + s[42, 19]\n    }\n    ```\n\n  These can be used for generic algorithms now as well.\n\n* The syntax for referring to the type of a type, `T.metatype`, has been\n  changed to `T.Type`. The syntax for getting the type of a value, `typeof(x)`,\n  has been changed to `x.type`.\n\n* `DynamicSelf` is now called `Self`; the semantics are unchanged.\n\n* `destructor` has been replaced with `deinit`, to emphasize that it\n  is related to `init`. We will refer to these as\n  `deinitializers`. We've also dropped the parentheses, i.e.:\n\n    ```swift\n    class MyClass {\n      deinit {\n        // release any resources we might have acquired, etc.\n      }\n    }\n    ```\n\n* Class methods defined within extensions of Objective-C classes can\n  now refer to `self`, including using `instancetype` methods. As a\n  result, `NSMutableString`, `NSMutableArray`, and `NSMutableDictionary`\n  objects can now be created with their respective literals, i.e.,\n\n    ```swift\n    var dict: NSMutableDictionary = [\"a\" : 1, \"b\" : 2]\n    ```\n\n### 2014-02-19\n\n* The `Stream` protocol has been renamed back to `Generator,` which is\n  precedented in other languages and causes less confusion with I/O\n  streaming.\n\n* The `type` keyword was split into two: `static` and `class`.  One can define\n  static functions and static properties in structs and enums like this:\n\n    ```swift\n    struct S {\n      static func foo() {}\n      static var bar: Int = 0\n    }\n    enum E {\n      static func foo() {}\n    }\n    ```\n\n  `class` keyword allows one to define class properties and class methods in\n  classes and protocols:\n\n    ```swift\n    class C {\n      class func foo() {}\n      class var bar: Int = 0\n    }\n    protocol P {\n      class func foo() {}\n      class var bar: Int = 0\n    }\n    ```\n\n  When using `class` and `static` in the extension, the choice of keyword\n  depends on the type being extended:\n\n    ```swift\n    extension S {\n      static func baz() {}\n    }\n    extension C {\n      class func baz() {}\n    }\n    ```\n\n* The `let` keyword is no longer recognized.  Please move to `val`.\n\n* The standard library has been renamed to `Swift` (instead of `swift`) to be\n  more consistent with other modules on our platforms.\n\n* `NSInteger` and other types that are layout-compatible with Swift standard\n  library types are now imported directly as those standard library types.\n\n* Optional types now support a convenience method named \"cache\" to cache the\n  result of a closure. For example:\n\n  ```swift\n  class Foo {\n    var _lazyProperty: Int?\n    var property: Int {\n      return _lazyProperty.cache { computeLazyProperty() }\n    }\n  }\n  ```\n\n### 2014-02-12\n\n* We are experimenting with a new message send syntax. For example:\n\n    ```swift\n    SKAction.colorizeWithColor(SKColor.whiteColor()) colorBlendFactor(1.0) duration(0.0)\n    ```\n\n  When the message send is too long to fit on a single line, subsequent lines\n  must be indented from the start of the statement or declaration. For\n  example, this is a single message send:\n\n    ```swift\n    SKAction.colorizeWithColor(SKColor.whiteColor())\n             colorBlendFactor(1.0)\n             duration(0.0)\n    ```\n\n  while this is a message send to colorizeWithColor: followed by calls\n  to `colorBlendFactor` and `duration` (on self or to a global function):\n\n    ```swift\n    SKAction.colorizeWithColor(SKColor.whiteColor())\n    colorBlendFactor(1.0) // call to 'colorBlendFactor'\n    duration(0.0) // call to 'duration'\n    ```\n\n* We are renaming the `let` keyword to `val`.  The `let` keyword didn't work\n  out primarily because it is not a noun, so \"defining a let\" never sounded\n  right.  We chose `val` over `const` and other options because `var` and `val`\n  have similar semantics (making syntactic similarity useful), because `const`\n  has varied and sordid connotations in C that we don't want to bring over, and\n  because we don't want to punish the \"preferred\" case with a longer keyword.\n\n  For migration purposes, the compiler now accepts `let` and `val` as synonyms,\n  `let` will be removed next week.\n\n* Selector arguments in function arguments with only a type are now implicitly\n  named after the selector chunk that contains them.  For example, instead of:\n\n    ```swift\n    func addIntsWithFirst(first : Int) second(second : Int) -> Int {\n      return first+second\n    }\n    ```\n\n  you can now write:\n\n    ```swift\n    func addIntsWithFirst(first : Int) second(Int) -> Int {\n      return first+second\n    }\n    ```\n\n  if you want to explicitly want to ignore an argument, it is recommended that\n  you continue to use the `_` to discard it, as in:\n\n    ```swift\n    func addIntsWithFirst(first : Int) second(_ : Int) -> Int {...}\n    ```\n\n* The `@inout` attribute in argument lists has been promoted to a\n  context-sensitive keyword.  Where before you might have written:\n\n    ```swift\n    func swap<T>(a : @inout T, b : @inout T) {\n      (a, b) = (b, a)\n    }\n    ```\n\n  You are now required to write:\n\n    ```swift\n    func swap<T>(inout a : T, inout b : T) {\n      (a, b) = (b, a)\n    }\n    ```\n\n  We made this change because `inout` is a fundamental part of the type\n  system, which attributes are a poor match for.  The inout keyword is\n  also orthogonal to the `var` and `let` keywords (which may be specified in\n  the same place), so it fits naturally there.\n\n* The `@mutating` attribute (which can be used on functions in structs,\n  enums, and protocols) has been promoted to a context-sensitive keyword.\n  Mutating struct methods are now written as:\n\n    ```swift\n    struct SomeStruct {\n      mutating func f() {}\n    }\n    ```\n\n* Half-open ranges (those that don't include their endpoint) are now\n  spelled with three `.`s instead of two, for consistency with Ruby.\n\n    ```swift\n    (swift) for x in 0...5 { print(x) } ; print('\\n') // new syntax\n    01234\n    ```\n\n  Next week, we'll introduce a fully-closed range which does include\n  its endpoint.  This will provide:\n\n    ```swift\n    (swift) for x in 0..5 { print(x) } ; print('\\n')  // coming soon\n    012345\n    ```\n\n  These changes are being released separately so that users have a\n  chance to update their code before its semantics changes.\n\n* Objective-C properties with custom getters/setters are now imported\n  into Swift as properties. For example, the Objective-C property\n\n    ```swift\n    @property (getter=isEnabled) BOOL enabled;\n    ```\n\n  was previously imported as getter (`isEnabled`) and setter\n  (`setEnabled`) methods. Now, it is imported as a property (`enabled`).\n\n* `didSet`/`willSet` properties may now have an initial value specified:\n\n    ```swift\n    class MyAwesomeView : UIView {\n      var enabled : Bool = false {       // Initial value.\n      didSet: self.needsDisplay = true\n      }\n      ...\n    }\n    ```\n\n  they can also be used as non-member properties now, e.g. as a global\n  variable or a local variable in a function.\n\n* Objective-C instancetype methods are now imported as methods that\n  return Swift's `DynamicSelf` type. While `DynamicSelf` is not\n  generally useful for defining methods in Swift, importing to it\n  eliminates the need for casting with the numerous `instancetype` APIs,\n  e.g.,\n\n    ```swift\n    let tileNode: SKSpriteNode = SKSpriteNode.spriteNodeWithTexture(tileAtlas.textureNamed(\"tile\\(tileNumber).png\"))!\n    ```\n\n  becomes\n\n    ```swift\n    let tileNode = SKSpriteNode.spriteNodeWithTexture(tileAtlas.textureNamed(\"tile\\(tileNumber).png\"))\n    ```\n\n  `DynamicSelf` will become more interesting in the coming weeks.\n\n### 2014-02-05\n\n* `if` and `while` statements can now conditionally bind variables. If the\n  condition of an `if` or `while` statement is a `let` declaration, then the\n  right-hand expression is evaluated as an `Optional` value, and control flow\n  proceeds by considering the binding to be `true` if the `Optional` contains a\n  value, or `false` if it is empty, and the variables are available in the true\n  branch. This allows for elegant testing of dynamic types, methods, nullable\n  pointers, and other Optional things:\n\n    ```swift\n    class B : NSObject {}\n    class D : B {\n      func foo() { println(\"we have a D\") }\n    }\n    var b: B = D()\n    if let d = b as D {\n      d.foo()\n    }\n    var id: AnyObject = D()\n    if let foo = id.foo {\n      foo()\n    }\n    ```\n\n* When referring to a member of an `AnyObject` (or `AnyClass`) object\n  and using it directly (such as calling it, subscripting, or\n  accessing a property on it), one no longer has to write the `?` or\n  `!`. The run-time check will be performed implicitly. For example:\n\n    ```swift\n    func doSomethingOnViews(views: NSArray) {\n      for view in views {\n          view.updateLayer() // no '!' needed\n      }\n    }\n    ```\n\n  Note that one can still test whether the member is available at\n  runtime using `?`, testing the optional result, or conditionally\n  binding a variable to the resulting member.\n\n* The `swift` command line tool can now create executables and libraries\n  directly, just like Clang. Use `swift main.swift` to create an executable and\n  `swift -emit-library -o foo.dylib foo.swift` to create a library.\n\n* Object files emitted by Swift are not debuggable on their own, even if you\n  compiled them with the `-g` option. This was already true if you had multiple\n  files in your project. To produce a debuggable Swift binary from the command\n  line, you must compile and link in a single step with `swift`, or pass object\n  files AND swiftmodule files back into `swift` after compilation.\n  (Or use Xcode.)\n\n* `import` will no longer import other source files, only built modules.\n\n* The current directory is no longer implicitly an import path. Use `-I .` if\n  you have modules in your current directory.\n\n### 2014-01-29\n\n* Properties in structs and classes may now have `willSet:` and `didSet:`\n  observing accessors defined on them:\n\n  For example, where before you may have written something like this in a class:\n\n    ```swift\n    class MyAwesomeView : UIView {\n      var _enabled : Bool  // storage\n      var enabled : Bool { // computed property\n      get:\n        return _enabled\n      set:\n        _enabled = value\n        self.needDisplay = true\n      }\n      ...\n    }\n    ```\n\n  you can now simply write:\n\n    ```swift\n    class MyAwesomeView : UIView {\n      var enabled : Bool {  // Has storage & observing methods\n      didSet: self.needDisplay = true\n      }\n      ...\n    }\n    ```\n\n  Similarly, if you want notification before the value is stored, you can use\n  `willSet`, which gets the incoming value before it is stored:\n\n    ```swift\n    var x : Int {\n    willSet(value):  // value is the default and may be elided, as with set:\n      println(\"changing from \\(x) to \\(value)\")\n    didSet:\n      println(\"we've got a value of \\(x) now.\\n\")\n    }\n    ```\n\n  The `willSet`/`didSet` observers are triggered on any store to the property,\n  except stores from `init()`, destructors, or from within the observers\n  themselves.\n\n  Overall, a property now may either be \"stored\" (the default), \"computed\"\n  (have a `get:` and optionally a `set:` specifier), or an observed\n  (`willSet`/`didSet`) property.  It is not possible to have a custom getter\n  or setter on an observed property, since they have storage.\n\n  Two known-missing bits are:\n  - **(rdar://problem/15920332) didSet/willSet variables need to allow initializers**\n  - **(rdar://problem/15922884) support non-member didset/willset properties**\n\n  Because of the first one, for now, you need to explicitly store an initial\n  value to the property in your `init()` method.\n\n* Objective-C properties with custom getter or setter names are (temporarily)\n  not imported into Swift; the getter and setter will be imported individually\n  as methods instead. Previously, they would appear as properties within the\n  Objective-C class, but attempting to use the accessor with the customized\n  name would result in a crash.\n\n  The long-term fix is tracked as **(rdar://problem/15877160)**.\n\n* Computed 'type' properties (that is, properties of types, rather\n  than of values of the type) are now permitted on classes, on generic\n  structs and enums, and in extensions.  Stored 'type' properties in\n  these contexts remain unimplemented.\n\n  The implementation of stored 'type' properties is tracked as\n  **(rdar://problem/15915785)** (for classes) and **(rdar://problem/15915867)**\n  (for generic types).\n\n* The following command-line flags have been deprecated in favor of new\n  spellings. The old spellings will be removed in the following week's build:\n\n  | Old Spelling             | New Spelling                  |\n  |--------------------------|-------------------------------|\n  | `-emit-llvm`             | `-emit-ir`                    |\n  | `-triple`                | `-target`                     |\n  | `-serialize-diagnostics` | `-serialize-diagnostics-path` |\n\n* Imported `NS_OPTIONS` types now have a default initializer which produces a\n  value with no options set. They can also be initialized to the empty set with\n  `nil`. These are equivalent:\n\n    ```swift\n    var x = NSMatchingOptions()\n    var y: NSMatchingOptions = nil\n    ```\n\n### 2014-01-22\n\n* The swift binary no longer has an SDK set by default. Instead, you must do\n  one of the following:\n    - pass an explicit `-sdk /path/to/sdk`\n    - set `SDKROOT` in your environment\n    - run `swift` through `xcrun`, which sets `SDKROOT` for you\n\n* `let` declarations can now be used as struct/class properties.  A `let`\n  property is mutable within `init()`, and immutable everywhere else.\n\n    ```swift\n    class C {\n      let x = 42\n      let y : Int\n      init(y : Int) {\n        self.y = y   // ok, self.y is mutable in init()\n      }\n\n      func test() {\n        y = 42       // error: 'y' isn't mutable\n      }\n    }\n    ```\n\n* The immutability model for structs and enums is complete, and arguments are\n  immutable by default.  This allows the compiler to reject mutations of\n  temporary objects, catching common bugs.  For example, this is rejected:\n\n    ```swift\n    func setTo4(a : Double[]) {\n      a[10] = 4.0     // error: 'a' isn't mutable\n    }\n    ...\n    setTo4(someArray)\n    ```\n\n  since `a` is semantically a copy of the array passed into the function.  The\n  proper fix in this case is to mark the argument is `@inout`, so the effect is\n  visible in the caller:\n\n    ```swift\n    func setTo4(a : @inout Double[]) {\n      a[10] = 4.0     // ok: 'a' is a mutable reference\n    }\n    ...\n    setTo4(&someArray)\n    ```\n\n  Alternatively, if you really just want a local copy of the argument, you can\n  mark it `var`.  The effects aren't visible in the caller, but this can be\n  convenient in some cases:\n\n    ```swift\n    func doStringStuff(var s : String) {\n      s += \"foo\"\n      print(s)\n    }\n    ```\n\n* Objective-C instance variables are no longer imported from headers written in\n  Objective-C. Previously, they would appear as properties within the\n  Objective-C class, but trying to access them would result in a crash.\n  Additionally, their names can conflict with property names, which confuses\n  the Swift compiler, and there are no patterns in our frameworks that expect\n  you to access a parent or other class's instance variables directly. Use\n  properties instead.\n\n* The `NSObject` protocol is now imported under the name\n  `NSObjectProtocol` (rather than `NSObjectProto`).\n\n### 2014-01-15\n\n* Improved deallocation of Swift classes that inherit from Objective-C\n  classes: Swift destructors are implemented as `-dealloc` methods that\n  automatically call the superclass's `-dealloc`. Stored properties are\n  released right before the object is deallocated (using the same\n  mechanism as ARC), allowing properties to be safely used in\n  destructors.\n\n* Subclasses of `NSManagedObject` are now required to provide initial\n  values for each of their stored properties. This permits\n  initialization of these stored properties directly after +alloc to\n  provide memory safety with CoreData's dynamic subclassing scheme.\n\n* `let` declarations are continuing to make slow progress. Curried\n  and selector-style arguments are now immutable by default, and\n  `let` declarations now get proper debug information.\n\n### 2014-01-08\n\n* The `static` keyword changed to `type`. One can now define \"type\n  functions\" and \"type variables\" which are functions and variables\n  defined on a type (rather than on an instance of the type), e.g.,\n\n    ```swift\n    class X {\n      type func factory() -> X { ... }\n\n      type var version: Int\n    }\n    ```\n\n  The use of `static` was actively misleading, since type methods\n  on classes are dynamically dispatched (the same as Objective-C\n  `+` methods).\n\n  Note that `type` is a context-sensitive keyword; it can still be\n  used as an identifier.\n\n* Strings have a new native UTF-16 representation that can be\n  converted back and forth to `NSString` at minimal cost. String\n  literals are emitted as UTF-16 for string types that support it\n  (including Swift's `String`).\n\n* Initializers can now delegate to other initializers within the same\n  class by calling `self.init`. For example:\n\n    ```swift\n    class A { }\n\n    class B : A {\n      var title: String\n\n      init() {\n        // note: cannot access self before delegating\n        self.init(withTitle: \"My Title\")\n      }\n\n      init withTitle(title: String) {\n        self.title = title\n        super.init()\n      }\n    }\n    ```\n\n* Objective-C protocols no longer have the `Proto` suffix unless there\n  is a collision with a class name. For example, `UITableViewDelegate` is\n  now imported as `UITableViewDelegate` rather than\n  `UITableViewDelegateProto`. Where there is a conflict with a class,\n  the protocol will be suffixed with `Proto`, as in `NSObject` (the\n  class) and `NSObjectProto` (the protocol).\n\n### 2014-01-01\n\n* Happy New Year\n\n* Division and remainder arithmetic now trap on overflow. Like with the other\n  operators, one can use the \"masking\" alternatives to get non-trapping\n  behavior. The behavior of the non-trapping masking operators is defined:\n\n    ```swift\n    x &/ 0 == 0\n    x &% 0 == 0\n    SIGNED_MIN_FOR_TYPE &/ -1 == -1 // i.e. Int8: -0x80 / -1 == -0x80\n    SIGNED_MIN_FOR_TYPE &% -1 == 0\n    ```\n\n* Protocol conformance checking for `@mutating` methods is now implemented: an\n  `@mutating` struct method only fulfills a protocol requirement if the protocol\n  method was itself marked `@mutating`:\n\n    ```swift\n    protocol P {\n      func nonmutating()\n      @mutating\n      func mutating()\n    }\n\n    struct S : P {\n      // Error, @mutating method cannot implement non-@mutating requirement.\n      @mutating\n      func nonmutating() {}\n\n      // Ok, mutating allowed, but not required.\n      func mutating() {}\n    }\n    ```\n\n  As before, class methods never need to be marked `@mutating` (and indeed, they\n  aren't allowed to be marked as such).\n\n### 2013-12-25\n\n* Merry Christmas\n\n* The setters of properties on value types (structs/enums) are now `@mutating` by\n  default.  To mark a setter non-mutating, use the `@!mutating` attribute.\n\n* Compiler inserts calls to `super.init()` into the class initializers that do\n  not call any initializers explicitly.\n\n* A `map` method with the semantics of Haskell's `fmap` was added to\n  `Array<T>`.  Map applies a function `f: T->U` to the values stored in\n  the array and returns an `Array<U>`.  So,\n\n    ```swift\n    (swift) func names(x: Int[]) -> String[] {\n              return x.map { \"<\" + String($0) + \">\" }\n            }\n    (swift) names(Array<Int>())\n    // r0 : String[] = []\n    (swift) names([3, 5, 7, 9])\n    // r1 : String[] = [\"<3>\", \"<5>\", \"<7>\", \"<9>\"]\n    ```\n\n### 2013-12-18\n\n* Global variables and static properties are now lazily initialized on first\n  use. Where you would use `dispatch_once` to lazily initialize a singleton\n  object in Objective-C, you can simply declare a global variable with an\n  initializer in Swift. Like `dispatch_once`, this lazy initialization is thread\n  safe.\n\n  Unlike C++ global variable constructors, Swift global variables and\n  static properties now never emit static constructors (and thereby don't\n  raise build warnings). Also unlike C++, lazy initialization naturally follows\n  dependency order, so global variable initializers that cross module\n  boundaries don't have undefined behavior or fragile link order dependencies.\n\n* Swift has the start of an immutability model for value types. As part of this,\n  you can now declare immutable value bindings with a new `let` declaration,\n  which is semantically similar to defining a get-only property:\n\n    ```swift\n    let x = foo()\n    print(x)        // ok\n    x = bar()       // error: cannot modify an immutable value\n    swap(&x, &y)    // error: cannot pass an immutable value as @inout parameter\n    x.clear()       // error: cannot call mutating method on immutable value\n    getX().clear()  // error: cannot mutate a temporary\n    ```\n\n  In the case of bindings of class type, the bound object itself is still\n  mutable, but you cannot change the binding.\n\n    ```swift\n    let r = Rocket()\n    r.blastOff()    // Ok, your rocket is mutable.\n    r = Rocket()    // error: cannot modify an immutable binding.\n    ```\n\n  In addition to the `let` declaration itself, `self` on classes, and a few\n  other minor things have switched to immutable bindings.\n\n  A pivotal part of this is that methods of value types (structs and enums) need\n  to indicate whether they can mutate self - mutating methods need to be\n  disallowed on let values (and get-only property results, temporaries, etc) but\n  non-mutating methods need to be allowed.  The default for a method is that it\n  does not mutate `self`, though you can opt into mutating behavior with a new\n  `@mutating` attribute:\n\n    ```swift\n    struct MyWeirdCounter {\n      var count : Int\n\n      func empty() -> Bool { return count == 0 }\n\n      @mutating\n      func reset() {\n        count = 0\n      }\n      ...\n    }\n\n    let x = MyWeirdCounter()\n    x.empty()   // ok\n    x.reset()   // error, cannot mutate immutable 'let' value\n    ```\n\n   One missing piece is that the compiler does not yet reject mutations of self\n   in a method that isn't marked `@mutating`.  That will be coming soon.  Related\n   to methods are properties.  Getters and setters can be marked mutating as\n   well:\n\n   ```swift\n   extension MyWeirdCounter {\n      var myproperty : Int {\n      get:\n        return 42\n\n      @mutating\n      set:\n        count = value*2\n      }\n    }\n    ```\n\n  The intention is for setters to default to mutating, but this has not been\n  implemented yet.  There is more to come here.\n\n* A `map` method with the semantics of Haskell's `fmap` was added to\n  `Optional<T>`.  Map applies a function `f: T->U` to any value stored in\n  an `Optional<T>`, and returns an `Optional<U>`.  So,\n\n    ```swift\n   (swift) func nameOf(x: Int?) -> String? {\n             return x.map { \"<\" + String($0) + \">\" }\n           }\n   (swift)\n   (swift) var no = nameOf(.None) // Empty optional in...\n   // no : String? = <unprintable value>\n   (swift) no ? \"yes\" : \"no\"      // ...empty optional out\n   // r0 : String = \"no\"\n   (swift)\n   (swift) nameOf(.Some(42))      // Non-empty in\n   // r1 : String? = <unprintable value>\n   (swift) nameOf(.Some(42))!     // Non-empty out\n   // r2 : String = \"<42>\"\n   ```\n\n* Cocoa types declared with the `NS_OPTIONS` macro are now available in Swift.\n  Like `NS_ENUM` types, their values are automatically shortened based\n  on the common prefix of the value names in Objective-C, and the name can\n  be elided when type context provides it. They can be used in `if` statements\n  using the `&`, `|`, `^`, and `~` operators as in C:\n\n    ```swift\n    var options: NSJSONWritingOptions = .PrettyPrinted\n    if options & .PrettyPrinted {\n      println(\"pretty-printing enabled\")\n    }\n    ```\n\n  We haven't yet designed a convenient way to author `NS_OPTIONS`-like types\n  in Swift.\n\n### 2013-12-11\n\n* Objective-C `id` is now imported as `AnyObject` (formerly known as\n `DynamicLookup`), Objective-C `Class` is imported as `AnyClass`.\n\n* The casting syntax `x as T` now permits both implicit conversions\n  (in which case it produces a value of type `T`) and for\n  runtime-checked casts (in which case it produces a value of type `T?`\n  that will be `.Some(casted x)` on success and `.None` on failure). An\n  example:\n\n    ```swift\n    func f(x: AnyObject, y: NSControl) {\n      var view = y as NSView                  // has type 'NSView'\n      var maybeView = x as NSView             // has type NSView?\n    }\n    ```\n\n* The precedence levels of binary operators has been redefined, with a much\n  simpler model than C's.  This is with a goal to define away classes of bugs\n  such as those caught by Clang's `-Wparentheses` warnings, and to make it\n  actually possible for normal humans to reason about the precedence\n  relationships without having to look them up.\n\n  We ended up with 6 levels, from tightest binding to loosest:\n    ```\n    exponentiative: <<, >>\n    multiplicative: *, /, %, &\n    additive: +, -, |, ^\n    comparative: ==, !=, <, <=, >=, >\n    conjunctive: &&\n    disjunctive: ||\n    ```\n\n* The `Enumerable` protocol has been renamed `Sequence`.\n\n* The `Char` type has been renamed `UnicodeScalar`.  The preferred\n  unit of string fragments for users is called `Character`.\n\n* Initialization semantics for classes, structs and enums init methods are now\n  properly diagnosed by the compiler.  Instance variables now follow the same\n  initialization rules as local variables: they must be defined before use.  The\n  initialization model requires that all properties with storage in the current\n  class be initialized before `super.init` is called (or, in a root class, before\n  any method is called on `self,` and before the final return).\n\n  For example, this will yield an error:\n\n    ```swift\n    class SomeClass : SomeBase {\n      var x : Int\n\n      init() {\n        // error: property 'self.x' not initialized at super.init call\n        super.init()\n      }\n    }\n    ```\n\n  A simple fix for this is to change the property definition to `var x = 0`,\n  or to explicitly assign to it before calling `super.init()`.\n\n* Relatedly, the compiler now diagnoses incorrect calls to `super.init()`.  It\n  validates that any path through an initializer calls `super.init()` exactly once,\n  that all ivars are defined before the call to super.init, and that any uses\n  which require the entire object to be initialized come after the `super.init`\n  call.\n\n* Type checker performance has improved considerably (but we still\n  have much work to do here).\n\n### 2013-12-04\n\n* The \"slice\" versus \"array\" subtlety is now dead. `Slice<T>` has been folded\n  into `Array<T>` and `T[]` is just sugar for `Array<T>`.\n\n### 2013-11-20\n\n* Unreachable code warning has been added:\n\n    ```swift\n    var y: Int = 1\n    if y == 1 { // note: condition always evaluates to true\n      return y\n    }\n    return 1 // warning: will never be executed\n    ```\n\n* Overflows on integer type conversions are now detected at runtime and, when\n  dealing with constants, at compile time:\n\n    ```swift\n    var i: Int = -129\n    var i8 = Int8(i)\n    // error: integer overflows when converted from 'Int' to 'Int8'\n\n    var si = Int8(-1)\n    var ui = UInt8(si)\n    // error: negative integer cannot be converted to unsigned type 'UInt8'\n    ```\n\n* `def` keyword was changed back to `func`.\n\n### 2013-11-13\n\n* Objective-C-compatible protocols can now contain optional\n  requirements, indicated by the `@optional` attribute:\n\n    ```swift\n    @class_protocol @objc protocol NSWobbling {\n      @optional def wobble()\n    }\n    ```\n\n  A class that conforms to the `NSWobbling` protocol above can (but does\n  not have to) implement `wobble`. When referring to the `wobble`\n  method for a value of type `NSWobbling` (or a value of generic type\n  that is bounded by `NSWobbling`), the result is an optional value\n  indicating whether the underlying object actually responds to the\n  given selector, using the same mechanism as messaging `id`. One can\n  use `!` to assume that the method is always there, `?` to chain the\n  optional, or conditional branches to handle each case distinctly:\n\n    ```swift\n    def tryToWobble(w : NSWobbling) {\n      w.wobble()   // error: cannot call a value of optional type\n      w.wobble!()  // okay: calls -wobble, but fails at runtime if not there\n      w.wobble?()  // okay: calls -wobble only if it's there, otherwise no-op\n      if w.wobble {\n        // okay: we know -wobble is there\n      } else {\n        // okay: we know -wobble is not there\n      }\n    }\n    ```\n\n* Enums from Cocoa that are declared with the `NS_ENUM` macro are now imported\n  into Swift as Swift enums. Like all Swift enums, the constants of the Cocoa\n  enum are scoped as members of the enum type, so the importer strips off the\n  common prefix of all of the constant names in the enum when forming the Swift\n  interface. For example, this Objective-C declaration:\n\n    ```objc\n    typedef NS_ENUM(NSInteger, NSComparisonResult) {\n      NSOrderedAscending,\n      NSOrderedSame,\n      NSOrderedDescending,\n    };\n    ```\n\n  shows up in Swift as:\n\n    ```swift\n    enum NSComparisonResult : Int {\n      case Ascending, Same, Descending\n    }\n    ```\n\n  The `enum` cases can then take advantage of type inference from context.\n  In Objective-C, you would write:\n\n    ```objc\n    NSNumber *foo = [NSNumber numberWithInt: 1];\n    NSNumber *bar = [NSNumber numberWithInt: 2];\n\n    switch ([foo compare: bar]) {\n    case NSOrderedAscending:\n      NSLog(@\"ascending\\n\");\n      break;\n    case NSOrderedSame:\n      NSLog(@\"same\\n\");\n      break;\n    case NSOrderedDescending:\n      NSLog(@\"descending\\n\");\n      break;\n    }\n    ```\n\n  In Swift, this becomes:\n\n    ```swift\n    var foo: NSNumber = 1\n    var bar: NSNumber = 2\n\n    switch foo.compare(bar) {\n    case .Ascending:\n      println(\"ascending\")\n    case .Same:\n      println(\"same\")\n    case .Descending:\n      println(\"descending\")\n    }\n    ```\n\n* Work has begun on implementing static properties. Currently they are supported\n  for nongeneric structs and enums.\n\n    ```swift\n    struct Foo {\n      static var foo: Int = 2\n    }\n    enum Bar {\n      static var bar: Int = 3\n    }\n    println(Foo.foo)\n    println(Bar.bar)\n    ```\n\n### 2013-11-06\n\n* `func` keyword was changed to `def`.\n\n* Implicit conversions are now allowed from an optional type `T?` to another\n  optional type `U?` if `T` is implicitly convertible to `U`. For example,\n  optional subclasses convert to their optional base classes:\n\n    ```swift\n    class Base {}\n    class Derived : Base {}\n\n    var d: Derived? = Derived()\n    var b: Base? = d\n    ```\n\n### 2013-10-30\n\n* Type inference for variables has been improved, allowing any\n  variable to have its type inferred from its initializer, including\n  global and instance variables:\n\n    ```swift\n    class MyClass {\n      var size = 0 // inferred to Int\n    }\n\n    var name = \"Swift\"\n    ```\n\n  Additionally, the arguments of a generic type can also be inferred\n  from the initializer:\n\n    ```swift\n    // infers Dictionary<String, Int>\n    var dict: Dictionary = [\"Hello\": 1, \"World\": 2]\n    ```\n\n### 2013-10-23\n\n* Missing return statement from a non-`Void` function is diagnosed as an error.\n\n* `Vector<T>` has been replaced with `Array<T>`. This is a complete rewrite to use\n  value-semantics and copy-on-write behavior. The former means that you never\n  need to defensively copy again (or remember to attribute a property as \"copy\")\n  and the latter yields better performance than defensive copying. `Dictionary<T>`\n  is next.\n\n* `switch` can now pattern-match into structs and classes, using the syntax\n  `case Type(property1: pattern1, property2: pattern2, ...):`.\n\n    ```swift\n    struct Point { var x, y: Double }\n    struct Size { var w, h: Double }\n    struct Rect { var origin: Point; var size: Size }\n\n    var square = Rect(Point(0, 0), Size(10, 10))\n\n    switch square {\n    case Rect(size: Size(w: var w, h: var h)) where w == h:\n      println(\"square\")\n    case Rect(size: Size(w: var w, h: var h)) where w > h:\n      println(\"long rectangle\")\n    default:\n      println(\"tall rectangle\")\n    }\n    ```\n\n  Currently only stored properties (\"ivars\" in ObjC terminology) are\n  supported by the implementation.\n\n* Array and dictionary literals allow an optional trailing comma:\n\n    ```swift\n    var a = [1, 2,]\n    var d = [\"a\": 1, \"b\": 2,]\n    ```\n\n### 2013-10-16\n\n* Unlike in Objective-C, objects of type `id` in Swift do not\n  implicitly convert to any class type. For example, the following\n  code is ill-formed:\n\n    ```swift\n    func getContentViewBounds(window : NSWindow) -> NSRect {\n      var view : NSView = window.contentView() // error: 'id' doesn't implicitly convert to NSView\n     return view.bounds()\n    }\n    ```\n\n  because `contentView()` returns an `id`. One can now use the postfix\n  `!` operator to allow an object of type `id` to convert to any class\n  type, e.g.,\n\n    ```swift\n    func getContentViewBounds(window : NSWindow) -> NSRect {\n      var view : NSView = window.contentView()! // ok: checked conversion to NSView\n     return view.bounds()\n    }\n    ```\n\n  The conversion is checked at run-time, and the program will fail if\n  the object is not an NSView. This is shorthand for\n\n    ```swift\n    var view : NSView = (window.contentView() as NSView)!\n    ```\n\n  which checks whether the content view is an `NSView` (via the `as\n  NSView`). That operation returns an optional `NSView` (written\n  `NSView?`) and the `!` operation assumes that the cast succeeded,\n  i.e., that the optional has a value in it.\n\n* The unconditional checked cast syntax `x as! T` has been removed. Many cases\n  where conversion from `id` is necessary can now be handled by postfix `!`\n  (see above). Fully general unconditional casts can still be expressed using\n  `as` and postfix `!` together, `(x as T)!`.\n\n* The old \"square bracket\" attribute syntax has been removed.\n\n* Overflows on construction of integer and floating point values from integer\n  literals that are too large to fit the type are now reported by the compiler.\n  Here are some examples:\n\n    ```swift\n    var x = Int8(-129)\n    // error: integer literal overflows when stored into 'Int8'\n\n    var y: Int = 0xFFFF_FFFF_FFFF_FFFF_F\n    // error: integer literal overflows when stored into 'Int'\n    ```\n\n  Overflows in constant integer expressions are also reported by the compiler.\n\n    ```swift\n    var x: Int8 = 125\n    var y: Int8 = x + 125\n    // error: arithmetic operation '125 + 125' (on type 'Int8') results in\n    //        an overflow\n    ```\n\n* Division by zero in constant expressions is now detected by the compiler:\n\n    ```swift\n    var z: Int = 0\n    var x = 5 / z  // error: division by zero\n    ```\n\n* Generic structs with type parameters as field types are now fully supported.\n\n    ```swift\n    struct Pair<T, U> {\n      var first: T\n      var second: U\n    }\n    ```\n\n### 2013-10-09\n\n* Autorelease pools can now be created using the `autoreleasepool` function.\n\n    ```swift\n    autoreleasepool {\n      // code\n    }\n    ```\n\n  Note that the wrapped code is a closure, so constructs like `break` and\n  `continue` and `return` do not behave as they would inside an Objective-C\n  `@autoreleasepool` statement.\n\n* Enums can now declare a \"raw type\", and cases can declare \"raw values\",\n  similar to the integer underlying type of C enums:\n\n    ```swift\n    // Declare the underlying type as in Objective-C or C++11, with\n    // ': Type'\n    enum AreaCode : Int {\n      // Assign explicit values to cases with '='\n      case SanFrancisco = 415\n      case EastBay = 510\n      case Peninsula = 650\n      case SanJose = 408\n      // Values are also assignable by implicit auto-increment\n      case Galveston // = 409\n      case Baltimore // = 410\n    }\n    ```\n\n  This introduces `fromRaw` and `toRaw` methods on the enum to perform\n  conversions from and to the raw type:\n\n    ```swift\n    /* As if declared:\n        extension AreaCode {\n          // Take a raw value, and produce the corresponding enum value,\n          // or None if there is no corresponding enum value\n          static func fromRaw(raw:Int) -> AreaCode?\n\n          // Return the corresponding raw value for 'self'\n          func toRaw() -> Int\n        }\n     */\n\n    AreaCode.fromRaw(415) // => .Some(.SanFrancisco)\n    AreaCode.fromRaw(111) // => .None\n    AreaCode.SanJose.toRaw() // => 408\n    ```\n\n  Raw types are not limited to integer types--they can additionally be\n  character, floating-point, or string values:\n\n    ```swift\n    enum State : String {\n      case CA = \"California\"\n      case OR = \"Oregon\"\n      case WA = \"Washington\"\n    }\n\n    enum SquareRootOfInteger : Float {\n      case One = 1.0\n      case Two = 1.414\n      case Three = 1.732\n      case Four = 2.0\n    }\n    ```\n\n  Raw types are currently limited to simple C-like enums with no payload cases.\n  The raw values are currently restricted to simple literal values; expressions\n  such as `1 + 1` or references to other enum cases are not yet supported.\n  Raw values are also currently required to be unique for each case in an enum.\n\n  Enums with raw types implicitly conform to the `RawRepresentable` protocol,\n  which exposes the fromRaw and toRaw methods to generics:\n\n    ```swift\n    protocol RawRepresentable {\n      typealias RawType\n      static func fromRaw(raw: RawType) -> Self?\n      func toRaw() -> RawType\n    }\n    ```\n\n* Attribute syntax has been redesigned (see **(rdar://10700853)** and\n  **(rdar://14462729)**) so that attributes now precede the declaration and use\n  the `@` character to signify them.  Where before you might have written:\n\n    ```swift\n    func [someattribute=42] foo(a : Int) {}\n    ```\n\n  you now write:\n\n    ```swift\n    @someattribute=42\n    func foo(a : Int) {}\n    ```\n\n  This flows a lot better (attributes don't push the name for declarations away),\n  and means that square brackets are only used for array types, collection\n  literals, and subscripting operations.\n\n* The `for` loop now uses the Generator protocol instead of the `Enumerator`\n  protocol to iterate a sequence. This protocol looks like this:\n\n    ```swift\n    protocol Generator {\n      typealias Element\n      func next() -> Element?\n    }\n    ```\n\n  The single method `next()` advances the generator and returns an\n  Optional, which is either `.Some(value)`, wrapping the next value out\n  of the underlying sequence, or `.None` to signal that there are no\n  more elements. This is an improvement over the previous Enumerator\n  protocol because it eliminates the separate `isEmpty()` query and\n  better reflects the semantics of ephemeral sequences like\n  un-buffered input streams.\n\n### 2013-10-02\n\n* The `[byref]` attribute has been renamed to `[inout]`.  When applied to a logical\n  property, the getter is invoked before a call and the setter is applied to\n  write back the result.  `inout` conveys this better and aligns with existing\n  Objective-C practice better.\n\n* `[inout]` arguments can now be captured into closures. The semantics of a\n  inout capture are that the captured variable is an independent local variable\n  of the callee, and the inout is updated to contain the value of that local\n  variable at function exit.\n\n  In the common case, most closure arguments do not outlive the duration of\n  their callee, and the observable behavior is unchanged.  However, if the\n  captured variable outlives the function, you can observe this.  For example,\n  this code:\n\n    ```swift\n    func foo(x : [inout] Int) -> () -> Int {\n      func bar() -> Int {\n        x += 1\n        return x\n      }\n      // Call 'bar' once while the inout is active.\n      bar()\n      return bar\n    }\n\n    var x = 219\n    var f = foo(&x)\n    // x is updated to the value of foo's local x at function exit.\n    println(\"global x = \\(x)\")\n    // These calls only update the captured local 'x', which is now independent\n    // of the inout parameter.\n    println(\"local x = \\(f())\")\n    println(\"local x = \\(f())\")\n    println(\"local x = \\(f())\")\n\n    println(\"global x = \\(x)\")\n    ```\n\n  will print:\n\n    ```\n    global x = 220\n    local x = 221\n    local x = 222\n    local x = 223\n    global x = 220\n    ```\n\n  In no case will you end up with a dangling pointer or other unsafe construct.\n\n* `x as T` now performs a checked cast to `T?`, producing `.Some(t)` if the\n  cast succeeds, or `.None` if the cast fails.\n\n* The ternary expression (`x ? y : z`) now requires whitespace between the\n  first expression and the question mark.  This permits `?` to be used\n  as a postfix operator.\n\n* A significant new piece of syntactic sugar has been added to ease working\n  with optional values.  The `?` postfix operator is analogous to `!`, but\n  instead of asserting on None, it causes all the following postfix\n  operators to get skipped and return `None`.\n\n  In a sense, this generalizes (and makes explicit) the Objective-C behavior\n  where message sends to `nil` silently produce the zero value of the result.\n\n  For example, this code\n\n    ```swift\n    object?.parent.notifyChildEvent?(object!, .didExplode)\n    ```\n\n  first checks whether `object` has a value; if so, it drills to its\n  parent and checks whether that object implements the `notifyChildEvent`\n  method; if so, it calls that method.  (Note that we do not yet have\n  generalized optional methods.)\n\n  This code:\n\n    ```swift\n    var titleLength = object?.title.length\n    ```\n\n  checks whether `object` has a value and, if so, asks for the length of\n  its title.  `titleLength` will have type `Int?`, and if `object` was\n  missing, the variable will be initialized to None.\n\n* Objects with type `id` can now be used as the receiver of property\n  accesses and subscript operations to get (but not set) values. The\n  result is of optional type. For example, for a variable `obj` of\n  type `id`, the expression\n\n    ```swift\n    obj[0]\n    ```\n\n  will produce a value of type `id`, which will either contain the\n  result of the message send objectAtIndexedSubscript(0) (wrapped in an\n  optional type) or, if the object does not respond to\n  `objectAtIndexedSubscript:`, an empty optional. The same approach\n  applies to property accesses.\n\n* `_` can now be used not only in `var` bindings, but in assignments as well,\n  to ignore elements of a tuple assignment, or to explicitly ignore values.\n\n    ```swift\n    var a = (1, 2.0, 3)\n    var x = 0, y = 0\n    _ = a           // explicitly load and discard 'a'\n    (x, _, y) = a   // assign a.0 to x and a.2 to y\n    ```\n\n### 2013-09-24\n\n* The `union` keyword has been replaced with `enum`.  Unions and enums\n  are semantically identical in swift (the former just has data\n  associated with its discriminators) and `enum` is the vastly more\n  common case.  For more rationale, please see\n  [docs/proposals/Enums.rst](https://github.com/apple/swift/blob/main/docs/proposals/Enums.rst)\n\n* The Optional type `T?` is now represented as an `enum`:\n\n    ```swift\n    enum Optional<T> {\n      case None\n      case Some(T)\n    }\n    ```\n\n  This means that, in addition to the existing Optional APIs, it can be\n  pattern-matched with switch:\n\n    ```swift\n    var x : X?, y : Y?\n    switch (x, y) {\n    // Both are present\n    case (.Some(var a), .Some(var b)):\n      println(\"both\")\n\n    // One is present\n    case (.Some, .None):\n    case (.None, .Some):\n      println(\"one\")\n\n    // Neither is present\n    case (.None, .None):\n      println(\"neither\")\n    }\n    ```\n\n* Enums now allow multiple cases to be declared in a comma-separated list\n  in a single `case` declaration:\n\n    ```swift\n    enum Color {\n      case Red, Green, Blue\n    }\n    ```\n\n* The Objective-C `id` and `Class` types now support referring to\n  methods declared in any class or protocol without a downcast. For\n  example, given a variable `sender` of type `id`, one can refer to\n  `-isEqual: with:`\n\n    ```swift\n    sender.isEqual\n    ```\n\n  The actual object may or may not respond to `-isEqual`, so this\n  expression returns result of optional type whose value is determined via a\n  compiler-generated `-respondsToSelector` send. When it succeeds, the\n  optional contains the method; when it fails, the optional is empty.\n\n  To safely test the optional, one can use, e.g.,\n\n    ```swift\n    var senderIsEqual = sender.isEqual\n    if senderIsEqual {\n      // this will never trigger an \"unrecognized selector\" failure\n      var equal = senderIsEqual!(other)\n    } else {\n      // sender does not respond to -isEqual:\n    }\n    ```\n\n  When you *know* that the method is there, you can use postfix `!` to\n  force unwrapping of the optional, e.g.,\n\n    ```swift\n    sender.isEqual!(other)\n    ```\n\n  This will fail at runtime if in fact sender does not respond to `-isEqual:`.\n  We have some additional syntactic optimizations planned for testing\n  an optional value and handling both the success and failure cases\n  concisely. Watch this space.\n\n* Weak references now always have optional type.  If a weak variable\n  has an explicit type, it must be an optional type:\n\n    ```swift\n    var [weak] x : NSObject?\n    ```\n\n  If the variable is not explicitly typed, its type will still be\n  inferred to be an optional type.\n\n* There is now an implicit conversion from `T` to `T?`.\n\n### 2013-09-17\n\n* Constructor syntax has been improved to align better with\n  Objective-C's `init` methods. The `constructor` keyword has been\n  replaced with `init`, and the selector style of declaration used for\n  func declarations is now supported. For example:\n\n    ```swift\n    class Y : NSObject {\n      init withInt(i : Int) string(s : String) {\n        super.init() // call superclass initializer\n      }\n    }\n    ```\n\n  One can use this constructor to create a `Y` object with, e.g.,\n\n    ```swift\n    Y(withInt:17, string:\"Hello\")\n    ```\n\n  Additionally, the rules regarding the selector corresponding to such\n  a declaration have been revised. The selector for the above\n  initializer is `initWithInt:string:`; the specific rules are\n  described in the documentation.\n\n  Finally, Swift initializers now introduce Objective-C entry points,\n  so a declaration such as:\n\n    ```swift\n    class X : NSObject {\n      init() {\n        super.init()\n      }\n    }\n    ```\n\n  Overrides `NSObject`'s `-init` method (which it calls first) as well\n  as introducing the 'allocating' entry point so that one can create a\n  new `X` instance with the syntax `X()`.\n\n* Variables in top-level code (i.e. scripts, but not global variables in\n  libraries) that lack an initializer now work just like local variables:\n  they must be explicitly assigned-to sometime before any use, instead of\n  being default constructed.  Instance variables are still on the TODO\n  list.\n\n* Generic unions with a single payload case and any number of empty cases\n  are now implemented, for example:\n\n    ```swift\n    union Maybe<T> {\n      case Some(T)\n      case None\n    }\n\n    union Tristate<T> {\n      case Initialized(T)\n      case Initializing\n      case Uninitialized\n    }\n    ```\n\n  Generic unions with multiple payload cases are still not yet implemented.\n\n### 2013-09-11\n\n* The implementation now supports partial application of class and struct\n  methods:\n\n    ```swift\n    (swift) class B { func foo() { println(\"B\") } }\n    (swift) class D : B { func foo() { println(\"D\") } }\n    (swift) var foo = B().foo\n    // foo : () -> () = <unprintable value>\n    (swift) foo()\n    B\n    (swift) foo = D().foo\n    (swift) foo()\n    D\n    ```\n\n  Support for partial application of Objective-C class methods and methods in\n  generic contexts is still incomplete.\n\n### 2013-09-04\n\n* Local variable declarations without an initializer are no longer implicitly\n  constructed.  The compiler now verifies that they are initialized on all\n  paths leading to a use of the variable.  This means that constructs like this\n  are now allowed:\n\n    ```swift\n    var p : SomeProtocol\n    if whatever {\n      p = foo()\n    } else {\n      p = bar()\n    }\n    ```\n\n  where before, the compiler would reject the definition of `p` saying that it\n  needed an initializer expression.\n\n  Since all local variables must be initialized before use, simple things like\n  this are now rejected as well:\n\n    ```swift\n    var x : Int\n    print(x)\n    ```\n\n  The fix is to initialize the value on all paths, or to explicitly default\n  initialize the value in the declaration, e.g. with `var x = 0` or with\n  `var x = Int()` (which works for any default-constructible type).\n\n* The implementation now supports unions containing protocol types and weak\n  reference types.\n\n* The type annotation syntax, `x as T`, has been removed from the language.\n  The checked cast operations `x as! T` and `x is T` still remain.\n\n### 2013-08-28\n\n* `this` has been renamed to `self`.  Similarly, `This` has been renamed to\n  `Self`.\n\n* Swift now supports unions. Unlike C unions, Swift's `union` is type-safe\n  and always knows what type it contains at runtime. Union members are labeled\n  using `case` declarations; each case may have a different set of\n  types or no type:\n\n    ```swift\n    union MaybeInt {\n      case Some(Int)\n      case None\n    }\n\n    union HTMLTag {\n      case A(href:String)\n      case IMG(src:String, alt:String)\n      case BR\n    }\n    ```\n\n  Each `case` with a type defines a static constructor function for the union\n  type. `case` declarations without types become static members:\n\n    ```swift\n    var br = HTMLTag.BR\n    var a = HTMLTag.A(href:\"http://www.apple.com/\")\n    // 'HTMLTag' scope deduced for '.IMG' from context\n    var img : HTMLTag = .IMG(src:\"http://www.apple.com/mac-pro.png\",\n                             alt:\"The new Mac Pro\")\n    ```\n\n  Cases can be pattern-matched using `switch`:\n\n    ```swift\n    switch tag {\n    case .BR:\n      println(\"<br>\")\n    case .IMG(var src, var alt):\n      println(\"<img src=\\\"\\(escape(src))\\\" alt=\\\"\\(escape(alt))\\\">\")\n    case .A(var href):\n      println(\"<a href=\\\"\\(escape(href))\\\">\")\n    }\n    ```\n\n  Due to implementation limitations, recursive unions are not yet supported.\n\n* Swift now supports autolinking, so importing frameworks or Swift libraries\n  should no longer require adding linker flags or modifying your project file.\n\n### 2013-08-14\n\n* Swift now supports weak references by applying the `[weak]` attribute to a\n  variable declaration.\n\n    ```swift\n    (swift) var x = NSObject()\n    // x : NSObject = <NSObject: 0x7f95d5804690>\n    (swift) var [weak] w = x\n    // w : NSObject = <NSObject: 0x7f95d5804690>\n    (swift) w == nil\n    // r2 : Bool = false\n    (swift) x = NSObject()\n    (swift) w == nil\n    // r3 : Bool = true\n    ```\n\n  Swift also supports a special form of weak reference, called `[unowned]`, for\n  references that should never be `nil` but are required to be weak to break\n  cycles, such as parent or sibling references. Accessing an `[unowned]`\n  reference asserts that the reference is still valid and implicitly promotes\n  the loaded reference to a strong reference, so it does not need to be loaded\n  and checked for nullness before use like a true `[weak]` reference.\n\n    ```swift\n    class Parent {\n      var children : Array<Child>\n\n      func addChild(c:Child) {\n        c.parent = this\n        children.append(c)\n      }\n    }\n\n    class Child {\n      var [unowned] parent : Parent\n    }\n    ```\n\n### 2013-07-31\n\n* Numeric literals can now use underscores as separators. For example:\n\n    ```swift\n    var billion = 1_000_000_000\n    var crore = 1_00_00_000\n    var MAXINT = 0x7FFF_FFFF_FFFF_FFFF\n    var SMALLEST_DENORM = 0x0.0000_0000_0000_1p-1022\n    ```\n\n* Types conforming to protocols now must always declare the conformance in\n  their inheritance clause.\n\n* The build process now produces serialized modules for the standard library,\n  greatly improving build times.\n\n### 2013-07-24\n\n* Arithmetic operators `+`, `-`, `*`, and `/` on integer types now do\n  overflow checking and trap on overflow. A parallel set of masking operators,\n  `&+`, `&-`, `&*`, and `&/`, are defined to perform two's complement wrapping\n  arithmetic for all signed and unsigned integer types.\n\n* Debugger support. Swift has a `-g` command line switch that turns on\n  debug info for the compiled output. Using the standard lldb debugger\n  this will allow single-stepping through Swift programs, printing\n  backtraces, and navigating through stack frames; all in sync with\n  the corresponding Swift source code. An unmodified lldb cannot\n  inspect any variables.\n\n  Example session:\n\n    ```\n    $ echo 'println(\"Hello World\")' >hello.swift\n    $ swift hello.swift -c -g -o hello.o\n    $ ld hello.o \"-dynamic\" \"-arch\" \"x86_64\" \"-macosx_version_min\" \"10.9.0\" \\\n         -framework Foundation lib/swift/libswift_stdlib_core.dylib \\\n         lib/swift/libswift_stdlib_posix.dylib -lSystem -o hello\n    $ lldb hello\n    Current executable set to 'hello' (x86_64).\n    (lldb) b top_level_code\n    Breakpoint 1: where = hello`top_level_code + 26 at hello.swift:1, addre...\n    (lldb) r\n    Process 38592 launched: 'hello' (x86_64)\n    Process 38592 stopped\n    * thread #1: tid = 0x1599fb, 0x0000000100000f2a hello`top_level_code + ...\n        frame #0: 0x0000000100000f2a hello`top_level_code + 26 at hello.shi...\n    -> 1         println(\"Hello World\")\n    (lldb) bt\n    * thread #1: tid = 0x1599fb, 0x0000000100000f2a hello`top_level_code + ...\n        frame #0: 0x0000000100000f2a hello`top_level_code + 26 at hello.shi...\n        frame #1: 0x0000000100000f5c hello`main + 28\n        frame #2: 0x00007fff918605fd libdyld.dylib`start + 1\n        frame #3: 0x00007fff918605fd libdyld.dylib`start + 1\n    ```\n\n  Also try `s`, `n`, `up`, `down`.\n\n### 2013-07-17\n\n* Swift now has a `switch` statement, supporting pattern matching of\n  multiple values with variable bindings, guard expressions, and range\n  comparisons. For example:\n\n    ```swift\n    func classifyPoint(point:(Int, Int)) {\n      switch point {\n      case (0, 0):\n        println(\"origin\")\n\n      case (_, 0):\n        println(\"on the x axis\")\n\n      case (0, _):\n        println(\"on the y axis\")\n\n      case (var x, var y) where x == y:\n        println(\"on the y = x diagonal\")\n\n      case (var x, var y) where -x == y:\n        println(\"on the y = -x diagonal\")\n\n      case (-10..10, -10..10):\n        println(\"close to the origin\")\n\n      case (var x, var y):\n        println(\"length \\(sqrt(x*x + y*y))\")\n      }\n    }\n    ```\n\n### 2013-07-10\n\n* Swift has a new closure syntax. The new syntax eliminates the use of\n  pipes. Instead, the closure signature is written the same way as a\n  function type and is separated from the body by the `in`\n  keyword. For example:\n\n    ```swift\n    sort(fruits) { (lhs : String, rhs : String) -> Bool in\n      return lhs > rhs\n    }\n    ```\n\n  When the types are omitted, one can also omit the parentheses, e.g.,\n\n    ```swift\n    sort(fruits) { lhs, rhs in lhs > rhs }\n    ```\n\n  Closures with no parameters or that use the anonymous parameters\n  (`$0`, `$1`, etc.) don't need the `in`, e.g.,\n\n    ```swift\n    sort(fruits) { $0 > $1 }\n    ```\n\n* `nil` can now be used without explicit casting. Previously, `nil` had\n  type `NSObject`, so one would have to write (e.g.) `nil as! NSArray`\n  to create a `nil` `NSArray`. Now, `nil` picks up the type of its\n  context.\n\n* `POSIX.EnvironmentVariables` and `swift.CommandLineArguments` global variables\n  were merged into a `swift.Process` variable.  Now you can access command line\n  arguments with `Process.arguments`.  In order to access environment variables\n  add `import POSIX` and use `Process.environmentVariables`.\n\n<!-- References -->\n\n[SE-0001]: <https://github.com/apple/swift-evolution/blob/main/proposals/0001-keywords-as-argument-labels.md>\n[SE-0002]: <https://github.com/apple/swift-evolution/blob/main/proposals/0002-remove-currying.md>\n[SE-0003]: <https://github.com/apple/swift-evolution/blob/main/proposals/0003-remove-var-parameters.md>\n[SE-0004]: <https://github.com/apple/swift-evolution/blob/main/proposals/0004-remove-pre-post-inc-decrement.md>\n[SE-0005]: <https://github.com/apple/swift-evolution/blob/main/proposals/0005-objective-c-name-translation.md>\n[SE-0006]: <https://github.com/apple/swift-evolution/blob/main/proposals/0006-apply-api-guidelines-to-the-standard-library.md>\n[SE-0007]: <https://github.com/apple/swift-evolution/blob/main/proposals/0007-remove-c-style-for-loops.md>\n[SE-0008]: <https://github.com/apple/swift-evolution/blob/main/proposals/0008-lazy-flatmap-for-optionals.md>\n[SE-0009]: <https://github.com/apple/swift-evolution/blob/main/proposals/0009-require-self-for-accessing-instance-members.md>\n[SE-0010]: <https://github.com/apple/swift-evolution/blob/main/proposals/0010-add-staticstring-unicodescalarview.md>\n[SE-0011]: <https://github.com/apple/swift-evolution/blob/main/proposals/0011-replace-typealias-associated.md>\n[SE-0012]: <https://github.com/apple/swift-evolution/blob/main/proposals/0012-add-noescape-to-public-library-api.md>\n[SE-0013]: <https://github.com/apple/swift-evolution/blob/main/proposals/0013-remove-partial-application-super.md>\n[SE-0014]: <https://github.com/apple/swift-evolution/blob/main/proposals/0014-constrained-AnySequence.md>\n[SE-0015]: <https://github.com/apple/swift-evolution/blob/main/proposals/0015-tuple-comparison-operators.md>\n[SE-0016]: <https://github.com/apple/swift-evolution/blob/main/proposals/0016-initializers-for-converting-unsafe-pointers-to-ints.md>\n[SE-0017]: <https://github.com/apple/swift-evolution/blob/main/proposals/0017-convert-unmanaged-to-use-unsafepointer.md>\n[SE-0018]: <https://github.com/apple/swift-evolution/blob/main/proposals/0018-flexible-memberwise-initialization.md>\n[SE-0019]: <https://github.com/apple/swift-evolution/blob/main/proposals/0019-package-manager-testing.md>\n[SE-0020]: <https://github.com/apple/swift-evolution/blob/main/proposals/0020-if-swift-version.md>\n[SE-0021]: <https://github.com/apple/swift-evolution/blob/main/proposals/0021-generalized-naming.md>\n[SE-0022]: <https://github.com/apple/swift-evolution/blob/main/proposals/0022-objc-selectors.md>\n[SE-0023]: <https://github.com/apple/swift-evolution/blob/main/proposals/0023-api-guidelines.md>\n[SE-0024]: <https://github.com/apple/swift-evolution/blob/main/proposals/0024-optional-value-setter.md>\n[SE-0025]: <https://github.com/apple/swift-evolution/blob/main/proposals/0025-scoped-access-level.md>\n[SE-0026]: <https://github.com/apple/swift-evolution/blob/main/proposals/0026-abstract-classes-and-methods.md>\n[SE-0027]: <https://github.com/apple/swift-evolution/blob/main/proposals/0027-string-from-code-units.md>\n[SE-0028]: <https://github.com/apple/swift-evolution/blob/main/proposals/0028-modernizing-debug-identifiers.md>\n[SE-0029]: <https://github.com/apple/swift-evolution/blob/main/proposals/0029-remove-implicit-tuple-splat.md>\n[SE-0030]: <https://github.com/apple/swift-evolution/blob/main/proposals/0030-property-behavior-decls.md>\n[SE-0031]: <https://github.com/apple/swift-evolution/blob/main/proposals/0031-adjusting-inout-declarations.md>\n[SE-0032]: <https://github.com/apple/swift-evolution/blob/main/proposals/0032-sequencetype-find.md>\n[SE-0033]: <https://github.com/apple/swift-evolution/blob/main/proposals/0033-import-objc-constants.md>\n[SE-0034]: <https://github.com/apple/swift-evolution/blob/main/proposals/0034-disambiguating-line.md>\n[SE-0035]: <https://github.com/apple/swift-evolution/blob/main/proposals/0035-limit-inout-capture.md>\n[SE-0036]: <https://github.com/apple/swift-evolution/blob/main/proposals/0036-enum-dot.md>\n[SE-0037]: <https://github.com/apple/swift-evolution/blob/main/proposals/0037-clarify-comments-and-operators.md>\n[SE-0038]: <https://github.com/apple/swift-evolution/blob/main/proposals/0038-swiftpm-c-language-targets.md>\n[SE-0039]: <https://github.com/apple/swift-evolution/blob/main/proposals/0039-playgroundliterals.md>\n[SE-0040]: <https://github.com/apple/swift-evolution/blob/main/proposals/0040-attributecolons.md>\n[SE-0041]: <https://github.com/apple/swift-evolution/blob/main/proposals/0041-conversion-protocol-conventions.md>\n[SE-0042]: <https://github.com/apple/swift-evolution/blob/main/proposals/0042-flatten-method-types.md>\n[SE-0043]: <https://github.com/apple/swift-evolution/blob/main/proposals/0043-declare-variables-in-case-labels-with-multiple-patterns.md>\n[SE-0044]: <https://github.com/apple/swift-evolution/blob/main/proposals/0044-import-as-member.md>\n[SE-0045]: <https://github.com/apple/swift-evolution/blob/main/proposals/0045-scan-takewhile-dropwhile.md>\n[SE-0046]: <https://github.com/apple/swift-evolution/blob/main/proposals/0046-first-label.md>\n[SE-0047]: <https://github.com/apple/swift-evolution/blob/main/proposals/0047-nonvoid-warn.md>\n[SE-0048]: <https://github.com/apple/swift-evolution/blob/main/proposals/0048-generic-typealias.md>\n[SE-0049]: <https://github.com/apple/swift-evolution/blob/main/proposals/0049-noescape-autoclosure-type-attrs.md>\n[SE-0050]: <https://github.com/apple/swift-evolution/blob/main/proposals/0050-floating-point-stride.md>\n[SE-0051]: <https://github.com/apple/swift-evolution/blob/main/proposals/0051-stride-semantics.md>\n[SE-0052]: <https://github.com/apple/swift-evolution/blob/main/proposals/0052-iterator-post-nil-guarantee.md>\n[SE-0053]: <https://github.com/apple/swift-evolution/blob/main/proposals/0053-remove-let-from-function-parameters.md>\n[SE-0054]: <https://github.com/apple/swift-evolution/blob/main/proposals/0054-abolish-iuo.md>\n[SE-0055]: <https://github.com/apple/swift-evolution/blob/main/proposals/0055-optional-unsafe-pointers.md>\n[SE-0056]: <https://github.com/apple/swift-evolution/blob/main/proposals/0056-trailing-closures-in-guard.md>\n[SE-0057]: <https://github.com/apple/swift-evolution/blob/main/proposals/0057-importing-objc-generics.md>\n[SE-0058]: <https://github.com/apple/swift-evolution/blob/main/proposals/0058-objectivecbridgeable.md>\n[SE-0059]: <https://github.com/apple/swift-evolution/blob/main/proposals/0059-updated-set-apis.md>\n[SE-0060]: <https://github.com/apple/swift-evolution/blob/main/proposals/0060-defaulted-parameter-order.md>\n[SE-0061]: <https://github.com/apple/swift-evolution/blob/main/proposals/0061-autoreleasepool-signature.md>\n[SE-0062]: <https://github.com/apple/swift-evolution/blob/main/proposals/0062-objc-keypaths.md>\n[SE-0063]: <https://github.com/apple/swift-evolution/blob/main/proposals/0063-swiftpm-system-module-search-paths.md>\n[SE-0064]: <https://github.com/apple/swift-evolution/blob/main/proposals/0064-property-selectors.md>\n[SE-0065]: <https://github.com/apple/swift-evolution/blob/main/proposals/0065-collections-move-indices.md>\n[SE-0066]: <https://github.com/apple/swift-evolution/blob/main/proposals/0066-standardize-function-type-syntax.md>\n[SE-0067]: <https://github.com/apple/swift-evolution/blob/main/proposals/0067-floating-point-protocols.md>\n[SE-0068]: <https://github.com/apple/swift-evolution/blob/main/proposals/0068-universal-self.md>\n[SE-0069]: <https://github.com/apple/swift-evolution/blob/main/proposals/0069-swift-mutability-for-foundation.md>\n[SE-0070]: <https://github.com/apple/swift-evolution/blob/main/proposals/0070-optional-requirements.md>\n[SE-0071]: <https://github.com/apple/swift-evolution/blob/main/proposals/0071-member-keywords.md>\n[SE-0072]: <https://github.com/apple/swift-evolution/blob/main/proposals/0072-eliminate-implicit-bridging-conversions.md>\n[SE-0073]: <https://github.com/apple/swift-evolution/blob/main/proposals/0073-noescape-once.md>\n[SE-0074]: <https://github.com/apple/swift-evolution/blob/main/proposals/0074-binary-search.md>\n[SE-0075]: <https://github.com/apple/swift-evolution/blob/main/proposals/0075-import-test.md>\n[SE-0076]: <https://github.com/apple/swift-evolution/blob/main/proposals/0076-copying-to-unsafe-mutable-pointer-with-unsafe-pointer-source.md>\n[SE-0077]: <https://github.com/apple/swift-evolution/blob/main/proposals/0077-operator-precedence.md>\n[SE-0078]: <https://github.com/apple/swift-evolution/blob/main/proposals/0078-rotate-algorithm.md>\n[SE-0079]: <https://github.com/apple/swift-evolution/blob/main/proposals/0079-upgrade-self-from-weak-to-strong.md>\n[SE-0080]: <https://github.com/apple/swift-evolution/blob/main/proposals/0080-failable-numeric-initializers.md>\n[SE-0081]: <https://github.com/apple/swift-evolution/blob/main/proposals/0081-move-where-expression.md>\n[SE-0082]: <https://github.com/apple/swift-evolution/blob/main/proposals/0082-swiftpm-package-edit.md>\n[SE-0083]: <https://github.com/apple/swift-evolution/blob/main/proposals/0083-remove-bridging-from-dynamic-casts.md>\n[SE-0084]: <https://github.com/apple/swift-evolution/blob/main/proposals/0084-trailing-commas.md>\n[SE-0085]: <https://github.com/apple/swift-evolution/blob/main/proposals/0085-package-manager-command-name.md>\n[SE-0086]: <https://github.com/apple/swift-evolution/blob/main/proposals/0086-drop-foundation-ns.md>\n[SE-0087]: <https://github.com/apple/swift-evolution/blob/main/proposals/0087-lazy-attribute.md>\n[SE-0088]: <https://github.com/apple/swift-evolution/blob/main/proposals/0088-libdispatch-for-swift3.md>\n[SE-0089]: <https://github.com/apple/swift-evolution/blob/main/proposals/0089-rename-string-reflection-init.md>\n[SE-0090]: <https://github.com/apple/swift-evolution/blob/main/proposals/0090-remove-dot-self.md>\n[SE-0091]: <https://github.com/apple/swift-evolution/blob/main/proposals/0091-improving-operators-in-protocols.md>\n[SE-0092]: <https://github.com/apple/swift-evolution/blob/main/proposals/0092-typealiases-in-protocols.md>\n[SE-0093]: <https://github.com/apple/swift-evolution/blob/main/proposals/0093-slice-base.md>\n[SE-0094]: <https://github.com/apple/swift-evolution/blob/main/proposals/0094-sequence-function.md>\n[SE-0095]: <https://github.com/apple/swift-evolution/blob/main/proposals/0095-any-as-existential.md>\n[SE-0096]: <https://github.com/apple/swift-evolution/blob/main/proposals/0096-dynamictype.md>\n[SE-0097]: <https://github.com/apple/swift-evolution/blob/main/proposals/0097-negative-attributes.md>\n[SE-0098]: <https://github.com/apple/swift-evolution/blob/main/proposals/0098-didset-capitalization.md>\n[SE-0099]: <https://github.com/apple/swift-evolution/blob/main/proposals/0099-conditionclauses.md>\n[SE-0100]: <https://github.com/apple/swift-evolution/blob/main/proposals/0100-add-sequence-based-init-and-merge-to-dictionary.md>\n[SE-0101]: <https://github.com/apple/swift-evolution/blob/main/proposals/0101-standardizing-sizeof-naming.md>\n[SE-0102]: <https://github.com/apple/swift-evolution/blob/main/proposals/0102-noreturn-bottom-type.md>\n[SE-0103]: <https://github.com/apple/swift-evolution/blob/main/proposals/0103-make-noescape-default.md>\n[SE-0104]: <https://github.com/apple/swift-evolution/blob/main/proposals/0104-improved-integers.md>\n[SE-0105]: <https://github.com/apple/swift-evolution/blob/main/proposals/0105-remove-where-from-forin-loops.md>\n[SE-0106]: <https://github.com/apple/swift-evolution/blob/main/proposals/0106-rename-osx-to-macos.md>\n[SE-0107]: <https://github.com/apple/swift-evolution/blob/main/proposals/0107-unsaferawpointer.md>\n[SE-0108]: <https://github.com/apple/swift-evolution/blob/main/proposals/0108-remove-assoctype-inference.md>\n[SE-0109]: <https://github.com/apple/swift-evolution/blob/main/proposals/0109-remove-boolean.md>\n[SE-0110]: <https://github.com/apple/swift-evolution/blob/main/proposals/0110-distinguish-single-tuple-arg.md>\n[SE-0111]: <https://github.com/apple/swift-evolution/blob/main/proposals/0111-remove-arg-label-type-significance.md>\n[SE-0112]: <https://github.com/apple/swift-evolution/blob/main/proposals/0112-nserror-bridging.md>\n[SE-0113]: <https://github.com/apple/swift-evolution/blob/main/proposals/0113-rounding-functions-on-floatingpoint.md>\n[SE-0114]: <https://github.com/apple/swift-evolution/blob/main/proposals/0114-buffer-naming.md>\n[SE-0115]: <https://github.com/apple/swift-evolution/blob/main/proposals/0115-literal-syntax-protocols.md>\n[SE-0116]: <https://github.com/apple/swift-evolution/blob/main/proposals/0116-id-as-any.md>\n[SE-0117]: <https://github.com/apple/swift-evolution/blob/main/proposals/0117-non-public-subclassable-by-default.md>\n[SE-0118]: <https://github.com/apple/swift-evolution/blob/main/proposals/0118-closure-parameter-names-and-labels.md>\n[SE-0119]: <https://github.com/apple/swift-evolution/blob/main/proposals/0119-extensions-access-modifiers.md>\n[SE-0120]: <https://github.com/apple/swift-evolution/blob/main/proposals/0120-revise-partition-method.md>\n[SE-0121]: <https://github.com/apple/swift-evolution/blob/main/proposals/0121-remove-optional-comparison-operators.md>\n[SE-0122]: <https://github.com/apple/swift-evolution/blob/main/proposals/0122-use-colons-for-subscript-type-declarations.md>\n[SE-0123]: <https://github.com/apple/swift-evolution/blob/main/proposals/0123-disallow-value-to-optional-coercion-in-operator-arguments.md>\n[SE-0124]: <https://github.com/apple/swift-evolution/blob/main/proposals/0124-bitpattern-label-for-int-initializer-objectidentfier.md>\n[SE-0125]: <https://github.com/apple/swift-evolution/blob/main/proposals/0125-remove-nonobjectivecbase.md>\n[SE-0126]: <https://github.com/apple/swift-evolution/blob/main/proposals/0126-refactor-metatypes-repurpose-t-dot-self-and-mirror.md>\n[SE-0127]: <https://github.com/apple/swift-evolution/blob/main/proposals/0127-cleaning-up-stdlib-ptr-buffer.md>\n[SE-0128]: <https://github.com/apple/swift-evolution/blob/main/proposals/0128-unicodescalar-failable-initializer.md>\n[SE-0129]: <https://github.com/apple/swift-evolution/blob/main/proposals/0129-package-manager-test-naming-conventions.md>\n[SE-0130]: <https://github.com/apple/swift-evolution/blob/main/proposals/0130-string-initializers-cleanup.md>\n[SE-0131]: <https://github.com/apple/swift-evolution/blob/main/proposals/0131-anyhashable.md>\n[SE-0132]: <https://github.com/apple/swift-evolution/blob/main/proposals/0132-sequence-end-ops.md>\n[SE-0133]: <https://github.com/apple/swift-evolution/blob/main/proposals/0133-rename-flatten-to-joined.md>\n[SE-0134]: <https://github.com/apple/swift-evolution/blob/main/proposals/0134-rename-string-properties.md>\n[SE-0135]: <https://github.com/apple/swift-evolution/blob/main/proposals/0135-package-manager-support-for-differentiating-packages-by-swift-version.md>\n[SE-0136]: <https://github.com/apple/swift-evolution/blob/main/proposals/0136-memory-layout-of-values.md>\n[SE-0137]: <https://github.com/apple/swift-evolution/blob/main/proposals/0137-avoiding-lock-in.md>\n[SE-0138]: <https://github.com/apple/swift-evolution/blob/main/proposals/0138-unsaferawbufferpointer.md>\n[SE-0139]: <https://github.com/apple/swift-evolution/blob/main/proposals/0139-bridge-nsnumber-and-nsvalue.md>\n[SE-0140]: <https://github.com/apple/swift-evolution/blob/main/proposals/0140-bridge-optional-to-nsnull.md>\n[SE-0141]: <https://github.com/apple/swift-evolution/blob/main/proposals/0141-available-by-swift-version.md>\n[SE-0142]: <https://github.com/apple/swift-evolution/blob/main/proposals/0142-associated-types-constraints.md>\n[SE-0143]: <https://github.com/apple/swift-evolution/blob/main/proposals/0143-conditional-conformances.md>\n[SE-0144]: <https://github.com/apple/swift-evolution/blob/main/proposals/0144-allow-single-dollar-sign-as-valid-identifier.md>\n[SE-0145]: <https://github.com/apple/swift-evolution/blob/main/proposals/0145-package-manager-version-pinning.md>\n[SE-0146]: <https://github.com/apple/swift-evolution/blob/main/proposals/0146-package-manager-product-definitions.md>\n[SE-0147]: <https://github.com/apple/swift-evolution/blob/main/proposals/0147-move-unsafe-initialize-from.md>\n[SE-0148]: <https://github.com/apple/swift-evolution/blob/main/proposals/0148-generic-subscripts.md>\n[SE-0149]: <https://github.com/apple/swift-evolution/blob/main/proposals/0149-package-manager-top-of-tree.md>\n[SE-0150]: <https://github.com/apple/swift-evolution/blob/main/proposals/0150-package-manager-branch-support.md>\n[SE-0151]: <https://github.com/apple/swift-evolution/blob/main/proposals/0151-package-manager-swift-language-compatibility-version.md>\n[SE-0152]: <https://github.com/apple/swift-evolution/blob/main/proposals/0152-package-manager-tools-version.md>\n[SE-0153]: <https://github.com/apple/swift-evolution/blob/main/proposals/0153-compensate-for-the-inconsistency-of-nscopyings-behaviour.md>\n[SE-0154]: <https://github.com/apple/swift-evolution/blob/main/proposals/0154-dictionary-key-and-value-collections.md>\n[SE-0155]: <https://github.com/apple/swift-evolution/blob/main/proposals/0155-normalize-enum-case-representation.md>\n[SE-0156]: <https://github.com/apple/swift-evolution/blob/main/proposals/0156-subclass-existentials.md>\n[SE-0157]: <https://github.com/apple/swift-evolution/blob/main/proposals/0157-recursive-protocol-constraints.md>\n[SE-0158]: <https://github.com/apple/swift-evolution/blob/main/proposals/0158-package-manager-manifest-api-redesign.md>\n[SE-0159]: <https://github.com/apple/swift-evolution/blob/main/proposals/0159-fix-private-access-levels.md>\n[SE-0160]: <https://github.com/apple/swift-evolution/blob/main/proposals/0160-objc-inference.md>\n[SE-0161]: <https://github.com/apple/swift-evolution/blob/main/proposals/0161-key-paths.md>\n[SE-0162]: <https://github.com/apple/swift-evolution/blob/main/proposals/0162-package-manager-custom-target-layouts.md>\n[SE-0163]: <https://github.com/apple/swift-evolution/blob/main/proposals/0163-string-revision-1.md>\n[SE-0164]: <https://github.com/apple/swift-evolution/blob/main/proposals/0164-remove-final-support-in-protocol-extensions.md>\n[SE-0165]: <https://github.com/apple/swift-evolution/blob/main/proposals/0165-dict.md>\n[SE-0166]: <https://github.com/apple/swift-evolution/blob/main/proposals/0166-swift-archival-serialization.md>\n[SE-0167]: <https://github.com/apple/swift-evolution/blob/main/proposals/0167-swift-encoders.md>\n[SE-0168]: <https://github.com/apple/swift-evolution/blob/main/proposals/0168-multi-line-string-literals.md>\n[SE-0169]: <https://github.com/apple/swift-evolution/blob/main/proposals/0169-improve-interaction-between-private-declarations-and-extensions.md>\n[SE-0170]: <https://github.com/apple/swift-evolution/blob/main/proposals/0170-nsnumber_bridge.md>\n[SE-0171]: <https://github.com/apple/swift-evolution/blob/main/proposals/0171-reduce-with-inout.md>\n[SE-0172]: <https://github.com/apple/swift-evolution/blob/main/proposals/0172-one-sided-ranges.md>\n[SE-0173]: <https://github.com/apple/swift-evolution/blob/main/proposals/0173-swap-indices.md>\n[SE-0174]: <https://github.com/apple/swift-evolution/blob/main/proposals/0174-filter-range-replaceable.md>\n[SE-0175]: <https://github.com/apple/swift-evolution/blob/main/proposals/0175-package-manager-revised-dependency-resolution.md>\n[SE-0176]: <https://github.com/apple/swift-evolution/blob/main/proposals/0176-enforce-exclusive-access-to-memory.md>\n[SE-0177]: <https://github.com/apple/swift-evolution/blob/main/proposals/0177-add-clamped-to-method.md>\n[SE-0178]: <https://github.com/apple/swift-evolution/blob/main/proposals/0178-character-unicode-view.md>\n[SE-0179]: <https://github.com/apple/swift-evolution/blob/main/proposals/0179-swift-run-command.md>\n[SE-0180]: <https://github.com/apple/swift-evolution/blob/main/proposals/0180-string-index-overhaul.md>\n[SE-0181]: <https://github.com/apple/swift-evolution/blob/main/proposals/0181-package-manager-cpp-language-version.md>\n[SE-0182]: <https://github.com/apple/swift-evolution/blob/main/proposals/0182-newline-escape-in-strings.md>\n[SE-0183]: <https://github.com/apple/swift-evolution/blob/main/proposals/0183-substring-affordances.md>\n[SE-0184]: <https://github.com/apple/swift-evolution/blob/main/proposals/0184-unsafe-pointers-add-missing.md>\n[SE-0185]: <https://github.com/apple/swift-evolution/blob/main/proposals/0185-synthesize-equatable-hashable.md>\n[SE-0186]: <https://github.com/apple/swift-evolution/blob/main/proposals/0186-remove-ownership-keyword-support-in-protocols.md>\n[SE-0187]: <https://github.com/apple/swift-evolution/blob/main/proposals/0187-introduce-filtermap.md>\n[SE-0188]: <https://github.com/apple/swift-evolution/blob/main/proposals/0188-stdlib-index-types-hashable.md>\n[SE-0189]: <https://github.com/apple/swift-evolution/blob/main/proposals/0189-restrict-cross-module-struct-initializers.md>\n[SE-0190]: <https://github.com/apple/swift-evolution/blob/main/proposals/0190-target-environment-platform-condition.md>\n[SE-0191]: <https://github.com/apple/swift-evolution/blob/main/proposals/0191-eliminate-indexdistance.md>\n[SE-0192]: <https://github.com/apple/swift-evolution/blob/main/proposals/0192-non-exhaustive-enums.md>\n[SE-0193]: <https://github.com/apple/swift-evolution/blob/main/proposals/0193-cross-module-inlining-and-specialization.md>\n[SE-0194]: <https://github.com/apple/swift-evolution/blob/main/proposals/0194-derived-collection-of-enum-cases.md>\n[SE-0195]: <https://github.com/apple/swift-evolution/blob/main/proposals/0195-dynamic-member-lookup.md>\n[SE-0196]: <https://github.com/apple/swift-evolution/blob/main/proposals/0196-diagnostic-directives.md>\n[SE-0197]: <https://github.com/apple/swift-evolution/blob/main/proposals/0197-remove-where.md>\n[SE-0198]: <https://github.com/apple/swift-evolution/blob/main/proposals/0198-playground-quicklook-api-revamp.md>\n[SE-0199]: <https://github.com/apple/swift-evolution/blob/main/proposals/0199-bool-toggle.md>\n[SE-0200]: <https://github.com/apple/swift-evolution/blob/main/proposals/0200-raw-string-escaping.md>\n[SE-0201]: <https://github.com/apple/swift-evolution/blob/main/proposals/0201-package-manager-local-dependencies.md>\n[SE-0202]: <https://github.com/apple/swift-evolution/blob/main/proposals/0202-random-unification.md>\n[SE-0203]: <https://github.com/apple/swift-evolution/blob/main/proposals/0203-rename-sequence-elements-equal.md>\n[SE-0204]: <https://github.com/apple/swift-evolution/blob/main/proposals/0204-add-last-methods.md>\n[SE-0205]: <https://github.com/apple/swift-evolution/blob/main/proposals/0205-withUnsafePointer-for-lets.md>\n[SE-0206]: <https://github.com/apple/swift-evolution/blob/main/proposals/0206-hashable-enhancements.md>\n[SE-0207]: <https://github.com/apple/swift-evolution/blob/main/proposals/0207-containsOnly.md>\n[SE-0208]: <https://github.com/apple/swift-evolution/blob/main/proposals/0208-package-manager-system-library-targets.md>\n[SE-0209]: <https://github.com/apple/swift-evolution/blob/main/proposals/0209-package-manager-swift-lang-version-update.md>\n[SE-0210]: <https://github.com/apple/swift-evolution/blob/main/proposals/0210-key-path-offset.md>\n[SE-0211]: <https://github.com/apple/swift-evolution/blob/main/proposals/0211-unicode-scalar-properties.md>\n[SE-0212]: <https://github.com/apple/swift-evolution/blob/main/proposals/0212-compiler-version-directive.md>\n[SE-0213]: <https://github.com/apple/swift-evolution/blob/main/proposals/0213-literal-init-via-coercion.md>\n[SE-0214]: <https://github.com/apple/swift-evolution/blob/main/proposals/0214-DictionaryLiteral.md>\n[SE-0215]: <https://github.com/apple/swift-evolution/blob/main/proposals/0215-conform-never-to-hashable-and-equatable.md>\n[SE-0216]: <https://github.com/apple/swift-evolution/blob/main/proposals/0216-dynamic-callable.md>\n[SE-0217]: <https://github.com/apple/swift-evolution/blob/main/proposals/0217-bangbang.md>\n[SE-0218]: <https://github.com/apple/swift-evolution/blob/main/proposals/0218-introduce-compact-map-values.md>\n[SE-0219]: <https://github.com/apple/swift-evolution/blob/main/proposals/0219-package-manager-dependency-mirroring.md>\n[SE-0220]: <https://github.com/apple/swift-evolution/blob/main/proposals/0220-count-where.md>\n[SE-0221]: <https://github.com/apple/swift-evolution/blob/main/proposals/0221-character-properties.md>\n[SE-0222]: <https://github.com/apple/swift-evolution/blob/main/proposals/0222-lazy-compactmap-sequence.md>\n[SE-0223]: <https://github.com/apple/swift-evolution/blob/main/proposals/0223-array-uninitialized-initializer.md>\n[SE-0224]: <https://github.com/apple/swift-evolution/blob/main/proposals/0224-ifswift-lessthan-operator.md>\n[SE-0225]: <https://github.com/apple/swift-evolution/blob/main/proposals/0225-binaryinteger-iseven-isodd-ismultiple.md>\n[SE-0226]: <https://github.com/apple/swift-evolution/blob/main/proposals/0226-package-manager-target-based-dep-resolution.md>\n[SE-0227]: <https://github.com/apple/swift-evolution/blob/main/proposals/0227-identity-keypath.md>\n[SE-0228]: <https://github.com/apple/swift-evolution/blob/main/proposals/0228-fix-expressiblebystringinterpolation.md>\n[SE-0230]: <https://github.com/apple/swift-evolution/blob/main/proposals/0230-flatten-optional-try.md>\n[SE-0235]: <https://github.com/apple/swift-evolution/blob/main/proposals/0235-add-result.md>\n[SE-0242]: <https://github.com/apple/swift-evolution/blob/main/proposals/0242-default-values-memberwise.md>\n[SE-0244]: <https://github.com/apple/swift-evolution/blob/main/proposals/0244-opaque-result-types.md>\n[SE-0245]: <https://github.com/apple/swift-evolution/blob/main/proposals/0245-array-uninitialized-initializer.md>\n[SE-0249]: <https://github.com/apple/swift-evolution/blob/main/proposals/0249-key-path-literal-function-expressions.md>\n[SE-0252]: <https://github.com/apple/swift-evolution/blob/main/proposals/0252-keypath-dynamic-member-lookup.md>\n[SE-0253]: <https://github.com/apple/swift-evolution/blob/main/proposals/0253-callable.md>\n[SE-0254]: <https://github.com/apple/swift-evolution/blob/main/proposals/0254-static-subscripts.md>\n[SE-0266]: <https://github.com/apple/swift-evolution/blob/main/proposals/0266-synthesized-comparable-for-enumerations.md>\n[SE-0267]: <https://github.com/apple/swift-evolution/blob/main/proposals/0267-where-on-contextually-generic.md>\n[SE-0268]: <https://github.com/apple/swift-evolution/blob/main/proposals/0268-didset-semantics.md>\n[SE-0269]: <https://github.com/apple/swift-evolution/blob/main/proposals/0269-implicit-self-explicit-capture.md>\n[SE-0270]: <https://github.com/apple/swift-evolution/blob/main/proposals/0270-rangeset-and-collection-operations.md>\n[SE-0274]: <https://github.com/apple/swift-evolution/blob/main/proposals/0274-magic-file.md>\n[SE-0276]: <https://github.com/apple/swift-evolution/blob/main/proposals/0276-multi-pattern-catch-clauses.md>\n[SE-0279]: <https://github.com/apple/swift-evolution/blob/main/proposals/0279-multiple-trailing-closures.md>\n[SE-0280]: <https://github.com/apple/swift-evolution/blob/main/proposals/0280-enum-cases-as-protocol-witnesses.md>\n[SE-0284]: <https://github.com/apple/swift-evolution/blob/main/proposals/0284-multiple-variadic-parameters.md>\n[SE-0286]: <https://github.com/apple/swift-evolution/blob/main/proposals/0286-forward-scan-trailing-closures.md>\n[SE-0287]: <https://github.com/apple/swift-evolution/blob/main/proposals/0287-implicit-member-chains.md>\n[SE-0290]: <https://github.com/apple/swift-evolution/blob/main/proposals/0290-negative-availability.md>\n[SE-0293]: <https://github.com/apple/swift-evolution/blob/main/proposals/0293-extend-property-wrappers-to-function-and-closure-parameters.md>\n[SE-0296]: <https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md>\n[SE-0297]: <https://github.com/apple/swift-evolution/blob/main/proposals/0297-concurrency-objc.md>\n[SE-0298]: <https://github.com/apple/swift-evolution/blob/main/proposals/0298-asyncsequence.md>\n[SE-0299]: <https://github.com/apple/swift-evolution/blob/main/proposals/0299-extend-generic-static-member-lookup.md>\n[SE-0300]: <https://github.com/apple/swift-evolution/blob/main/proposals/0300-continuation.md>\n[SE-0302]: <https://github.com/apple/swift-evolution/blob/main/proposals/0302-concurrent-value-and-concurrent-closures.md>\n[SE-0306]: <https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md>\n[SE-0309]: <https://github.com/apple/swift-evolution/blob/main/proposals/0309-unlock-existential-types-for-all-protocols.md>\n[SE-0310]: <https://github.com/apple/swift-evolution/blob/main/proposals/0310-effectful-readonly-properties.md>\n[SE-0311]: <https://github.com/apple/swift-evolution/blob/main/proposals/0311-task-locals.md>\n[SE-0313]: <https://github.com/apple/swift-evolution/blob/main/proposals/0313-actor-isolation-control.md>\n[SE-0315]: <https://github.com/apple/swift-evolution/blob/main/proposals/0315-placeholder-types.md>\n[SE-0316]: <https://github.com/apple/swift-evolution/blob/main/proposals/0316-global-actors.md>\n[SE-0320]: <https://github.com/apple/swift-evolution/blob/main/proposals/0320-codingkeyrepresentable.md>\n[SE-0322]: <https://github.com/apple/swift-evolution/blob/main/proposals/0322-temporary-buffers.md>\n[SE-0323]: <https://github.com/apple/swift-evolution/blob/main/proposals/0323-async-main-semantics.md>\n[SE-0324]: <https://github.com/apple/swift-evolution/blob/main/proposals/0324-c-lang-pointer-arg-conversion.md>\n[SE-0326]: <https://github.com/apple/swift-evolution/blob/main/proposals/0326-extending-multi-statement-closure-inference.md>\n[SE-0327]: <https://github.com/apple/swift-evolution/blob/main/proposals/0327-actor-initializers.md>\n[SE-0328]: <https://github.com/apple/swift-evolution/blob/main/proposals/0328-structural-opaque-result-types.md>\n[SE-0329]: <https://github.com/apple/swift-evolution/blob/main/proposals/0329-clock-instant-duration.md>\n[SE-0331]: <https://github.com/apple/swift-evolution/blob/main/proposals/0331-remove-sendable-from-unsafepointer.md>\n[SE-0333]: <https://github.com/apple/swift-evolution/blob/main/proposals/0333-with-memory-rebound.md>\n[SE-0334]: <https://github.com/apple/swift-evolution/blob/main/proposals/0334-pointer-usability-improvements.md>\n[SE-0335]: <https://github.com/apple/swift-evolution/blob/main/proposals/0335-existential-any.md>\n[SE-0336]: <https://github.com/apple/swift-evolution/blob/main/proposals/0336-distributed-actor-isolation.md>\n[SE-0337]: <https://github.com/apple/swift-evolution/blob/main/proposals/0337-support-incremental-migration-to-concurrency-checking.md>\n[SE-0338]: <https://github.com/apple/swift-evolution/blob/main/proposals/0338-clarify-execution-non-actor-async.md>\n[SE-0340]: <https://github.com/apple/swift-evolution/blob/main/proposals/0340-swift-noasync.md>\n[SE-0341]: <https://github.com/apple/swift-evolution/blob/main/proposals/0341-opaque-parameters.md>\n[SE-0343]: <https://github.com/apple/swift-evolution/blob/main/proposals/0343-top-level-concurrency.md>\n[SE-0345]: <https://github.com/apple/swift-evolution/blob/main/proposals/0345-if-let-shorthand.md>\n[SE-0346]: <https://github.com/apple/swift-evolution/blob/main/proposals/0346-light-weight-same-type-syntax.md>\n[SE-0347]: <https://github.com/apple/swift-evolution/blob/main/proposals/0347-type-inference-from-default-exprs.md>\n[SE-0349]: <https://github.com/apple/swift-evolution/blob/main/proposals/0349-unaligned-loads-and-stores.md>\n[SE-0350]: <https://github.com/apple/swift-evolution/blob/main/proposals/0350-regex-type-overview.md>\n[SE-0352]: <https://github.com/apple/swift-evolution/blob/main/proposals/0352-implicit-open-existentials.md>\n[SE-0353]: <https://github.com/apple/swift-evolution/blob/main/proposals/0353-constrained-existential-types.md>\n[SE-0354]: <https://github.com/apple/swift-evolution/blob/main/proposals/0354-regex-literals.md>\n[SE-0355]: <https://github.com/apple/swift-evolution/blob/main/proposals/0355-regex-syntax-run-time-construction.md>\n[SE-0357]: <https://github.com/apple/swift-evolution/blob/main/proposals/0357-regex-string-processing-algorithms.md>\n[SE-0358]: <https://github.com/apple/swift-evolution/blob/main/proposals/0358-primary-associated-types-in-stdlib.md>\n[SE-0362]: <https://github.com/apple/swift-evolution/blob/main/proposals/0362-piecemeal-future-features.md>\n[SE-0365]: <https://github.com/apple/swift-evolution/blob/main/proposals/0365-implicit-self-weak-capture.md>\n[SE-0366]: <https://github.com/apple/swift-evolution/blob/main/proposals/0366-move-function.md>\n[SE-0370]: <https://github.com/apple/swift-evolution/blob/main/proposals/0370-pointer-family-initialization-improvements.md>\n[SE-0376]: <https://github.com/apple/swift-evolution/blob/main/proposals/0376-function-back-deployment.md>\n[SE-0377]: <https://github.com/apple/swift-evolution/blob/main/proposals/0377-parameter-ownership-modifiers.md>\n[SE-0380]: <https://github.com/apple/swift-evolution/blob/main/proposals/0380-if-switch-expressions.md>\n[SE-0382]: https://github.com/apple/swift-evolution/blob/main/proposals/0382-expression-macros.md\n[SE-0389]: https://github.com/apple/swift-evolution/blob/main/proposals/0389-attached-macros.md\n[SE-0394]: https://github.com/apple/swift-evolution/blob/main/proposals/0394-swiftpm-expression-macros.md\n[SE-0397]: https://github.com/apple/swift-evolution/blob/main/proposals/0397-freestanding-declaration-macros.md\n[SE-0407]: https://github.com/apple/swift-evolution/blob/main/proposals/0407-member-macro-conformances.md\n[SE-0408]: https://github.com/apple/swift-evolution/blob/main/proposals/0408-pack-iteration.md\n[SE-0411]: https://github.com/apple/swift-evolution/blob/main/proposals/0411-isolated-default-values.md\n[SE-0412]: https://github.com/apple/swift-evolution/blob/main/proposals/0412-strict-concurrency-for-global-variables.md\n[SE-0413]: https://github.com/apple/swift-evolution/blob/main/proposals/0413-typed-throws.md\n[SE-0414]: https://github.com/apple/swift-evolution/blob/main/proposals/0414-region-based-isolation.md\n[SE-0417]: https://github.com/apple/swift-evolution/blob/main/proposals/0417-task-executor-preference.md\n[SE-0418]: https://github.com/apple/swift-evolution/blob/main/proposals/0418-inferring-sendable-for-methods.md\n[SE-0420]: https://github.com/apple/swift-evolution/blob/main/proposals/0420-inheritance-of-actor-isolation.md\n[SE-0422]: https://github.com/apple/swift-evolution/blob/main/proposals/0422-caller-side-default-argument-macro-expression.md\n[SE-0423]: https://github.com/apple/swift-evolution/blob/main/proposals/0423-dynamic-actor-isolation.md\n[SE-0427]: https://github.com/apple/swift-evolution/blob/main/proposals/0427-noncopyable-generics.md\n[SE-0429]: https://github.com/apple/swift-evolution/blob/main/proposals/0429-partial-consumption.md\n[SE-0432]: https://github.com/apple/swift-evolution/blob/main/proposals/0432-noncopyable-switch.md\n[SE-0430]: https://github.com/apple/swift-evolution/blob/main/proposals/0430-transferring-parameters-and-results.md\n[SE-0418]: https://github.com/apple/swift-evolution/blob/main/proposals/0418-inferring-sendable-for-methods.md\n[SE-0423]: https://github.com/apple/swift-evolution/blob/main/proposals/0423-dynamic-actor-isolation.md\n[SE-0424]: https://github.com/apple/swift-evolution/blob/main/proposals/0424-custom-isolation-checking-for-serialexecutor.md\n[SE-0428]: https://github.com/apple/swift-evolution/blob/main/proposals/0428-resolve-distributed-actor-protocols.md\n[SE-0431]: https://github.com/apple/swift-evolution/blob/main/proposals/0431-isolated-any-functions.md\n[SE-0442]: https://github.com/swiftlang/swift-evolution/blob/main/proposals/0442-allow-taskgroup-childtaskresult-type-to-be-inferred.md\n[SE-0444]: https://github.com/swiftlang/swift-evolution/blob/main/proposals/0444-member-import-visibility.md\n[#64927]: <https://github.com/apple/swift/issues/64927>\n[#42697]: <https://github.com/apple/swift/issues/42697>\n[#42728]: <https://github.com/apple/swift/issues/42728>\n[#43036]: <https://github.com/apple/swift/issues/43036>\n[#43248]: <https://github.com/apple/swift/issues/43248>\n[#43310]: <https://github.com/apple/swift/issues/43310>\n[#43621]: <https://github.com/apple/swift/issues/43621>\n[#44055]: <https://github.com/apple/swift/issues/44055>\n[#44138]: <https://github.com/apple/swift/issues/44138>\n[#44739]: <https://github.com/apple/swift/issues/44739>\n[#44784]: <https://github.com/apple/swift/issues/44784>\n[#44797]: <https://github.com/apple/swift/issues/44797>\n[#44995]: <https://github.com/apple/swift/issues/44995>\n[#45001]: <https://github.com/apple/swift/issues/45001>\n[#45213]: <https://github.com/apple/swift/issues/45213>\n[#45277]: <https://github.com/apple/swift/issues/45277>\n[#45293]: <https://github.com/apple/swift/issues/45293>\n[apple/swift-corelibs-foundation#4326]: <https://github.com/apple/swift-corelibs-foundation/issues/4326>\n[#46789]: <https://github.com/apple/swift/issues/46789>\n[#46831]: <https://github.com/apple/swift/issues/46831>\n[#48153]: <https://github.com/apple/swift/issues/48153>\n[#48289]: <https://github.com/apple/swift/issues/48289>\n[#48673]: <https://github.com/apple/swift/issues/48673>\n[#49631]: <https://github.com/apple/swift/issues/49631>\n[#49687]: <https://github.com/apple/swift/issues/49687>\n[#49799]: <https://github.com/apple/swift/issues/49799>\n[#50143]: <https://github.com/apple/swift/issues/50143>\n[#50338]: <https://github.com/apple/swift/issues/50338>\n[#50641]: <https://github.com/apple/swift/issues/50641>\n[#51064]: <https://github.com/apple/swift/issues/51064>\n[#51478]: <https://github.com/apple/swift/issues/51478>\n[#51546]: <https://github.com/apple/swift/issues/51546>\n[#52244]: <https://github.com/apple/swift/issues/52244>\n[#52471]: <https://github.com/apple/swift/issues/52471>\n[#53699]: <https://github.com/apple/swift/issues/53699>\n[#53830]: <https://github.com/apple/swift/issues/53830>\n[#54108]: <https://github.com/apple/swift/issues/54108>\n[#54246]: <https://github.com/apple/swift/issues/54246>\n[#57081]: <https://github.com/apple/swift/issues/57081>\n[#57225]: <https://github.com/apple/swift/issues/57225>\n[#56139]: <https://github.com/apple/swift/issues/56139>\n[#70065]: <https://github.com/apple/swift/pull/70065>\n[#71075]: <https://github.com/apple/swift/pull/71075>\n[swift-syntax]: https://github.com/apple/swift-syntax\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 60,
          "content": "cmake_minimum_required(VERSION 3.19.6)\n\n\n#  set_property(GLOBAL PROPERTY GLOBAL_DEPENDS_DEBUG_MODE 1)\n\n# TODO: Fix RPATH usage to be CMP0068 compliant\n# Disable Policy CMP0068 for CMake 3.9\n# rdar://37725888\nif(POLICY CMP0068)\n  cmake_policy(SET CMP0068 OLD)\nendif()\n\n# Honour CMAKE_CXX_STANDARD in try_compile(), needed for check_cxx_native_regex.\nif(POLICY CMP0067)\n  cmake_policy(SET CMP0067 NEW)\nendif()\n\n# Convert relative paths to absolute for subdirectory `target_sources`\nif(POLICY CMP0076)\n  cmake_policy(SET CMP0076 NEW)\nendif()\n\n# Don't clobber existing variable values when evaluating `option()` declarations.\nif(POLICY CMP0077)\n  cmake_policy(SET CMP0077 NEW)\nendif()\n\n# Add path for custom CMake modules.\nlist(APPEND CMAKE_MODULE_PATH\n    \"${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules\")\n\nset(CMAKE_DISABLE_IN_SOURCE_BUILD YES)\n\nif(DEFINED CMAKE_JOB_POOLS)\n  # CMake < 3.11 doesn't support CMAKE_JOB_POOLS. Manually set the property.\n  set_property(GLOBAL PROPERTY JOB_POOLS \"${CMAKE_JOB_POOLS}\")\nelse()\n  # Make a job pool for things that can't yet be distributed\n  cmake_host_system_information(\n    RESULT localhost_logical_cores QUERY NUMBER_OF_LOGICAL_CORES)\n  set_property(GLOBAL APPEND PROPERTY JOB_POOLS local_jobs=${localhost_logical_cores})\n  # Put linking in that category\n  set(CMAKE_JOB_POOL_LINK local_jobs)\nendif()\n\nenable_language(C)\nenable_language(CXX)\n\n# On Windows, use MASM or MARMASM\nset(SWIFT_ASM_DIALECT ASM)\nset(SWIFT_ASM_EXT S)\nset(SWIFT_ASM_AVAILABLE YES)\nif(CMAKE_SYSTEM_NAME STREQUAL \"Windows\")\n  if(CMAKE_SYSTEM_PROCESSOR MATCHES \"ARM64\")\n    if(CMAKE_VERSION VERSION_LESS \"3.26\")\n      message(WARNING \"We can't build assembly language for ARM64 until CMake 3.26\")\n      set(SWIFT_ASM_AVAILABLE NO)\n    else()\n      set(SWIFT_ASM_DIALECT ASM_MARMASM)\n    endif()\n  else()\n    set(SWIFT_ASM_DIALECT ASM_MASM)\n  endif()\n  set(SWIFT_ASM_EXT asm)\nendif()\n\nif(SWIFT_ASM_AVAILABLE)\n  enable_language(${SWIFT_ASM_DIALECT})\nendif()\n\n# Use C++17.\nset(SWIFT_MIN_CXX_STANDARD 17)\n\n# Unset CMAKE_CXX_STANDARD if it's too low and in the CMakeCache.txt\nif($CACHE{CMAKE_CXX_STANDARD} AND $CACHE{CMAKE_CXX_STANDARD} LESS ${SWIFT_MIN_CXX_STANDARD})\n  message(WARNING \"Resetting cache value for CMAKE_CXX_STANDARD to ${SWIFT_MIN_CXX_STANDARD}\")\n  unset(CMAKE_CXX_STANDARD CACHE)\nendif()\n\n# Allow manually specified CMAKE_CXX_STANDARD if it's greater than the minimum\n# required C++ version\nif(DEFINED CMAKE_CXX_STANDARD AND CMAKE_CXX_STANDARD LESS ${SWIFT_MIN_CXX_STANDARD})\n  message(FATAL_ERROR \"Requested CMAKE_CXX_STANDARD=${CMAKE_CXX_STANDARD} which is less than the minimum C++ standard ${SWIFT_MIN_CXX_STANDARD}\")\nendif()\n\nset(CMAKE_CXX_STANDARD ${SWIFT_MIN_CXX_STANDARD} CACHE STRING \"C++ standard to conform to\")\nset(CMAKE_CXX_STANDARD_REQUIRED YES)\nset(CMAKE_CXX_EXTENSIONS NO)\n\n# First include general CMake utilities.\ninclude(SwiftUtils)\ninclude(CheckSymbolExists)\ninclude(CMakeDependentOption)\ninclude(CheckLanguage)\ninclude(GNUInstallDirs)\ninclude(SwiftCompilerCapability)\ninclude(FetchContent)\n\n# Enable Swift for the host compiler build if we have the language. It is\n# optional until we have a bootstrap story.\ncheck_language(Swift)\nif(CMAKE_Swift_COMPILER)\n  # we are not interested in logging any Swift module used\n  # when configuring the build system -- those are not useful\n  # since they will not contribute to the build of the compiler itself\n  unset(ENV{SWIFT_LOADED_MODULE_TRACE_FILE})\n\n  enable_language(Swift)\n  set(DEFAULT_SWIFT_MIN_RUNTIME_VERSION \"${CMAKE_Swift_COMPILER_VERSION}\")\nelse()\n  message(WARNING \"Swift compiler not found on path.\n  Cannot build compiler sources written in Swift.\n  If this is unexpected, please pass the path to the swiftc binary by defining the `CMAKE_Swift_COMPILER` variable.\")\n  set(DEFAULT_SWIFT_MIN_RUNTIME_VERSION)\nendif()\n\n# A convenience pattern to match Darwin platforms. Example:\n#  if(SWIFT_HOST_VARIANT MATCHES \"${SWIFT_DARWIN_VARIANTS}\")\n#     ...\n#  endif()\nset(SWIFT_DARWIN_VARIANTS \"^(macosx|iphoneos|iphonesimulator|appletvos|appletvsimulator|watchos|watchsimulator)\")\nset(SWIFT_DARWIN_EMBEDDED_VARIANTS \"^(iphoneos|iphonesimulator|appletvos|appletvsimulator|watchos|watchsimulator)\")\n\n# A convenient list to match Darwin SDKs. Example:\n#  if(\"${SWIFT_HOST_VARIANT_SDK}\" IN_LIST SWIFT_DARWIN_PLATFORMS)\n#    ...\n#  endif()\nset(SWIFT_DARWIN_PLATFORMS \"IOS\" \"IOS_SIMULATOR\" \"TVOS\" \"TVOS_SIMULATOR\" \"WATCHOS\" \"WATCHOS_SIMULATOR\" \"OSX\" \"XROS\" \"XROS_SIMULATOR\")\n\nset(SWIFT_APPLE_PLATFORMS ${SWIFT_DARWIN_PLATFORMS})\nif(SWIFT_FREESTANDING_FLAVOR STREQUAL \"apple\")\n  list(APPEND SWIFT_APPLE_PLATFORMS \"FREESTANDING\")\n  if(SWIFT_FREESTANDING_IS_DARWIN)\n    list(APPEND SWIFT_DARWIN_PLATFORMS \"FREESTANDING\")\n  endif()\nendif()\n\n# If SWIFT_HOST_VARIANT_SDK not given, try to detect from the CMAKE_SYSTEM_NAME.\nif(SWIFT_HOST_VARIANT_SDK)\n  set(SWIFT_HOST_VARIANT_SDK_default \"${SWIFT_HOST_VARIANT_SDK}\")\nelse()\n  if(\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Linux\")\n    set(SWIFT_HOST_VARIANT_SDK_default \"LINUX\")\n  elseif(\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"FreeBSD\")\n    set(SWIFT_HOST_VARIANT_SDK_default \"FREEBSD\")\n  elseif(\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"OpenBSD\")\n    set(SWIFT_HOST_VARIANT_SDK_default \"OPENBSD\")\n  elseif(\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"CYGWIN\")\n    set(SWIFT_HOST_VARIANT_SDK_default \"CYGWIN\")\n  elseif(\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Windows\")\n    set(SWIFT_HOST_VARIANT_SDK_default \"WINDOWS\")\n  elseif(\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Haiku\")\n    set(SWIFT_HOST_VARIANT_SDK_default \"HAIKU\")\n  elseif(\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Android\")\n    set(SWIFT_HOST_VARIANT_SDK_default \"ANDROID\")\n  elseif(\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Darwin\")\n    set(SWIFT_HOST_VARIANT_SDK_default \"OSX\")\n  elseif(\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"WASI\")\n    set(SWIFT_HOST_VARIANT_SDK_default \"WASI\")\n  else()\n    message(FATAL_ERROR \"Unable to detect SDK for host system: ${CMAKE_SYSTEM_NAME}\")\n  endif()\nendif()\n\n# If SWIFT_HOST_VARIANT_ARCH not given, try to detect from the CMAKE_SYSTEM_PROCESSOR.\nif(SWIFT_HOST_VARIANT_ARCH)\n  set(SWIFT_HOST_VARIANT_ARCH_default \"${SWIFT_HOST_VARIANT_ARCH}\")\nelse()\n  if(CMAKE_SYSTEM_PROCESSOR MATCHES \"x86_64|AMD64|amd64\")\n    set(SWIFT_HOST_VARIANT_ARCH_default \"x86_64\")\n  elseif(CMAKE_SYSTEM_PROCESSOR MATCHES \"aarch64|ARM64|arm64\")\n    if(SWIFT_HOST_VARIANT_SDK_default STREQUAL \"OSX\")\n      set(SWIFT_HOST_VARIANT_ARCH_default \"arm64\")\n    else()\n      set(SWIFT_HOST_VARIANT_ARCH_default \"aarch64\")\n    endif()\n  elseif(\"${CMAKE_SYSTEM_PROCESSOR}\" STREQUAL \"ppc64\")\n    set(SWIFT_HOST_VARIANT_ARCH_default \"powerpc64\")\n  elseif(\"${CMAKE_SYSTEM_PROCESSOR}\" STREQUAL \"ppc\")\n    set(SWIFT_HOST_VARIANT_ARCH_default \"powerpc\")\n  elseif(\"${CMAKE_SYSTEM_PROCESSOR}\" STREQUAL \"ppc64le\")\n    set(SWIFT_HOST_VARIANT_ARCH_default \"powerpc64le\")\n  elseif(\"${CMAKE_SYSTEM_PROCESSOR}\" STREQUAL \"s390x\")\n    set(SWIFT_HOST_VARIANT_ARCH_default \"s390x\")\n  elseif(\"${CMAKE_SYSTEM_PROCESSOR}\" MATCHES \"armv5|armv5te\")\n    set(SWIFT_HOST_VARIANT_ARCH_default \"armv5\")\n  # FIXME: Only matches v6l/v7l - by far the most common variants\n  elseif(\"${CMAKE_SYSTEM_PROCESSOR}\" STREQUAL \"armv6l\")\n    set(SWIFT_HOST_VARIANT_ARCH_default \"armv6\")\n  elseif(\"${CMAKE_SYSTEM_PROCESSOR}\" MATCHES \"armv7l|armv7-a\")\n    set(SWIFT_HOST_VARIANT_ARCH_default \"armv7\")\n  elseif(\"${CMAKE_SYSTEM_PROCESSOR}\" STREQUAL \"IA64\")\n    set(SWIFT_HOST_VARIANT_ARCH_default \"itanium\")\n  elseif(\"${CMAKE_SYSTEM_PROCESSOR}\" MATCHES \"(x86|i686)\")\n    set(SWIFT_HOST_VARIANT_ARCH_default \"i686\")\n  elseif(\"${CMAKE_SYSTEM_PROCESSOR}\" STREQUAL \"wasm32\")\n    set(SWIFT_HOST_VARIANT_ARCH_default \"wasm32\")\n  else()\n    message(FATAL_ERROR \"Unrecognized architecture on host system: ${CMAKE_SYSTEM_PROCESSOR}\")\n  endif()\nendif()\n\nset(SWIFT_HOST_VARIANT_SDK \"${SWIFT_HOST_VARIANT_SDK_default}\" CACHE STRING\n    \"Deployment sdk for Swift host tools (the compiler).\")\nset(SWIFT_HOST_VARIANT_ARCH \"${SWIFT_HOST_VARIANT_ARCH_default}\" CACHE STRING\n    \"Deployment arch for Swift host tools (the compiler).\")\n\n#\n# User-configurable options that control the inclusion and default build\n# behavior for components which may not strictly be necessary (tools, examples,\n# and tests).\n#\n# This is primarily to support building smaller or faster project files.\n#\n\noption(SWIFT_APPEND_VC_REV\n  \"Embed the version control system revision in Swift\"\n  TRUE)\n\noption(SWIFT_INCLUDE_TOOLS\n    \"Generate build targets for swift tools\"\n    TRUE)\n\noption(SWIFT_BUILD_REMOTE_MIRROR\n    \"Build the Swift Remote Mirror Library\"\n    TRUE)\n\noption(SWIFT_BUILD_DYNAMIC_STDLIB\n    \"Build dynamic variants of the Swift standard library\"\n    TRUE)\n\noption(SWIFT_BUILD_STATIC_STDLIB\n    \"Build static variants of the Swift standard library\"\n    FALSE)\n\noption(SWIFT_STDLIB_STATIC_PRINT\n    \"Build compile-time evaluated vprintf()\"\n    FALSE)\n\noption(SWIFT_STDLIB_ENABLE_UNICODE_DATA\n    \"Include Unicode data files in the standard library.\n    NOTE: Disabling this will cause many String methods to crash.\"\n    TRUE)\n\noption(SWIFT_BUILD_CLANG_OVERLAYS\n  \"Build Swift overlays for the clang builtin modules\"\n  TRUE)\n\n# The SDK overlay is provided by the SDK itself on Darwin platforms.\nif(SWIFT_HOST_VARIANT_SDK IN_LIST SWIFT_DARWIN_PLATFORMS)\n  set(SWIFT_BUILD_DYNAMIC_SDK_OVERLAY_default FALSE)\nelse()\n  set(SWIFT_BUILD_DYNAMIC_SDK_OVERLAY_default TRUE)\nendif()\n\noption(SWIFT_BUILD_DYNAMIC_SDK_OVERLAY\n    \"Build dynamic variants of the Swift SDK overlay\"\n    \"${SWIFT_BUILD_DYNAMIC_SDK_OVERLAY_default}\")\n\noption(SWIFT_BUILD_STATIC_SDK_OVERLAY\n    \"Build static variants of the Swift SDK overlay\"\n    FALSE)\n\noption(SWIFT_BUILD_STDLIB_EXTRA_TOOLCHAIN_CONTENT\n    \"If not building stdlib, controls whether to build 'stdlib/toolchain' content\"\n    TRUE)\n\noption(SWIFT_BUILD_STDLIB_CXX_MODULE\n  \"If not building stdlib, controls whether to build the Cxx module\"\n  TRUE)\n\n# In many cases, the CMake build system needs to determine whether to include\n# a directory, or perform other actions, based on whether the stdlib or SDK is\n# being built at all -- statically or dynamically. Please note that these\n# flags are not related to the deprecated build-script-impl arguments\n# 'build-swift-stdlib' and 'build-swift-sdk-overlay'. These are not flags that\n# the build script should be able to set.\nif(SWIFT_BUILD_DYNAMIC_STDLIB OR SWIFT_BUILD_STATIC_STDLIB)\n  set(SWIFT_BUILD_STDLIB TRUE)\nelse()\n  set(SWIFT_BUILD_STDLIB FALSE)\nendif()\n\nif(SWIFT_BUILD_DYNAMIC_SDK_OVERLAY OR SWIFT_BUILD_STATIC_SDK_OVERLAY)\n  set(SWIFT_BUILD_SDK_OVERLAY TRUE)\nelse()\n  set(SWIFT_BUILD_SDK_OVERLAY FALSE)\nendif()\n\noption(SWIFT_BUILD_PERF_TESTSUITE\n    \"Create in-tree targets for building swift performance benchmarks.\"\n    FALSE)\n\noption(SWIFT_INCLUDE_TESTS \"Create targets for building/running tests.\" TRUE)\n\noption(SWIFT_INCLUDE_TEST_BINARIES\n  \"Create targets for building/running test binaries even if SWIFT_INCLUDE_TESTS is disabled\"\n  TRUE)\n\noption(SWIFT_INCLUDE_DOCS\n    \"Create targets for building docs.\"\n    TRUE)\n\nset(_swift_include_apinotes_default FALSE)\nif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n  set(_swift_include_apinotes_default TRUE)\nendif()\n\noption(SWIFT_INCLUDE_APINOTES\n  \"Create targets for installing the remaining apinotes in the built toolchain.\"\n  ${_swift_include_apinotes_default})\n\n#\n# Miscellaneous User-configurable options.\n#\n# TODO: Please categorize these!\n#\n\nif (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)\n  set(CMAKE_BUILD_TYPE \"Debug\" CACHE STRING\n      \"Build type for Swift [Debug, RelWithDebInfo, Release, MinSizeRel]\"\n      FORCE)\n  message(STATUS \"No build type was specified, will default to ${CMAKE_BUILD_TYPE}\")\nendif()\n\nset(SWIFT_ANALYZE_CODE_COVERAGE FALSE CACHE STRING\n    \"Build Swift with code coverage instrumenting enabled [FALSE, NOT-MERGED, MERGED]\")\n\ninclude(${CMAKE_CURRENT_LIST_DIR}/cmake/SwiftVersion.cmake)\n\nset(SWIFT_VENDOR \"\" CACHE STRING\n    \"The vendor name of the Swift compiler\")\nset(SWIFT_COMPILER_VERSION \"\" CACHE STRING\n    \"The internal version of the Swift compiler\")\nset(CLANG_COMPILER_VERSION \"\" CACHE STRING\n    \"The internal version of the Clang compiler\")\n\noption(SWIFT_DISABLE_DEAD_STRIPPING\n      \"Turn off Darwin-specific dead stripping for Swift host tools.\" FALSE)\n\nset(SWIFT_TOOLS_ENABLE_LTO OFF CACHE STRING \"Build Swift tools with LTO. One\n    must specify the form of LTO by setting this to one of: 'full', 'thin'. This\n    option only affects the tools that run on the host (the compiler), and has\n    no effect on the target libraries (the standard library and the runtime).\")\n\noption(SWIFT_TOOLS_LD64_LTO_CODEGEN_ONLY_FOR_SUPPORTING_TARGETS\n    \"When building ThinLTO using ld64 on Darwin, controls whether to opt out of\n    LLVM IR optimizations when linking targets that will get\n    little benefit from it (e.g. tools for bootstrapping or\n    debugging Swift)\"\n    FALSE)\n\nset(BOOTSTRAPPING_MODE HOSTTOOLS CACHE STRING [=[\nHow to build the swift compiler modules. Possible values are\n    HOSTTOOLS:     build with a pre-installed toolchain\n    BOOTSTRAPPING: build with a 2-stage bootstrapping process\n    BOOTSTRAPPING-WITH-HOSTLIBS:   build with a 2-stage bootstrapping process,\n                   but the compiler links against the host system swift libs (macOS only)\n    CROSSCOMPILE:  cross-compiledwith a native host compiler, provided in\n                   `SWIFT_NATIVE_SWIFT_TOOLS_PATH` (non-Darwin only)\n    CROSSCOMPILE-WITH-HOSTLIBS:    build with a bootstrapping-with-hostlibs compiled\n                                   compiler, provided in `SWIFT_NATIVE_SWIFT_TOOLS_PATH`\n]=])\n\noption(BRIDGING_MODE [=[\nHow swift-C++ bridging code is compiled:\n    INLINE:       uses full swift C++ interop and briding functions are inlined\n    PURE:         uses limited C++ interp an bridging functions are not inlined\n    DEFAULT:      based on the build configuration\n]=] DEFAULT)\n\noption(SWIFT_USE_SYMLINKS \"Use symlinks instead of copying binaries\" ${CMAKE_HOST_UNIX})\nset(SWIFT_COPY_OR_SYMLINK \"copy_if_different\")\nset(SWIFT_COPY_OR_SYMLINK_DIR \"copy_directory\")\nif(SWIFT_USE_SYMLINKS)\n  set(SWIFT_COPY_OR_SYMLINK \"create_symlink\")\n  set(SWIFT_COPY_OR_SYMLINK_DIR \"create_symlink\")\nendif()\n\n# The following only works with the Ninja generator in CMake >= 3.0.\nset(SWIFT_PARALLEL_LINK_JOBS \"\" CACHE STRING\n  \"Define the maximum number of linker jobs for swift.\")\n\noption(SWIFT_FORCE_OPTIMIZED_TYPECHECKER \"Override the optimization setting of\n  the type checker so that it always compiles with optimization. This eases\n  debugging after type checking occurs by speeding up type checking\" FALSE)\n\n# Allow building Swift with Clang's Profile Guided Optimization\nif(SWIFT_PROFDATA_FILE AND EXISTS ${SWIFT_PROFDATA_FILE})\n  if(NOT CMAKE_C_COMPILER_ID MATCHES Clang)\n    message(FATAL_ERROR \"SWIFT_PROFDATA_FILE can only be specified when compiling with clang\")\n  endif()\n  add_definitions(\"-fprofile-instr-use=${SWIFT_PROFDATA_FILE}\")\nendif()\n\nset(SWIFT_TOOLS_INSTALL_DIR \"${CMAKE_INSTALL_BINDIR}\" CACHE PATH\n  \"Path for binary subdirectory to use during installation.\n  Used by add_swift_tool_symlink in AddSwift.cmake so that llvm_install_symlink generates the installation script properly.\")\n\n#\n# User-configurable Swift Standard Library specific options.\n#\n# TODO: Once the stdlib/compiler builds are split, this should be sunk into the\n# stdlib cmake.\n#\n\nset(SWIFT_STDLIB_BUILD_TYPE \"${CMAKE_BUILD_TYPE}\" CACHE STRING\n    \"Build type for the Swift standard library and SDK overlays [Debug, RelWithDebInfo, Release, MinSizeRel]\")\n# Allow the user to specify the standard library CMAKE_MSVC_RUNTIME_LIBRARY\n# value.  The following values are valid:\n#   - MultiThreaded (/MT)\n#   - MultiThreadedDebug (/MTd)\n#   - MultiThreadedDLL (/MD)\n#   - MultiThreadedDebugDLL (/MDd)\nif(CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n  set(SWIFT_STDLIB_MSVC_RUNTIME_LIBRARY_default MultiThreadedDebugDLL)\nelse()\n  set(SWIFT_STDLIB_MSVC_RUNTIME_LIBRARY_default MultiThreadedDLL)\nendif()\nset(SWIFT_STDLIB_MSVC_RUNTIME_LIBRARY\n  ${SWIFT_STDLIB_MSVC_RUNTIME_LIBRARY_default}\n  CACHE STRING \"MSVC Runtime Library for the standard library\")\n\nif(\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Windows\" AND BOOTSTRAPPING_MODE STREQUAL \"HOSTTOOLS\" AND\n    CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n  # Building with the host Swift toolchain requires linking just-built binaries\n  # against the host Swift runtime. In debug builds, that means linking a debug\n  # binary against a release binary. The MSVC linker does not normally permit\n  # this, since debug builds enable bounds-checked C++ iterators by default,\n  # which are not ABI-compatible with regular iterators. Let's instruct MSVC to\n  # disable bounds-checked iterators to make it possible to do a debug build of\n  # the Swift compiler with a host toolchain.\n  add_definitions(-D_ITERATOR_DEBUG_LEVEL=0)\nendif()\n\nif(BRIDGING_MODE STREQUAL \"DEFAULT\" OR NOT BRIDGING_MODE)\n  if(CMAKE_BUILD_TYPE STREQUAL \"Debug\" OR \"${SWIFT_HOST_VARIANT_SDK}\" STREQUAL \"WINDOWS\" OR (CMAKE_Swift_COMPILER AND CMAKE_Swift_COMPILER_VERSION VERSION_LESS 5.8))\n    # In debug builds, to workaround a problem with LLDB's `po` command (rdar://115770255).\n    # If the host Swift version is less than 5.8, use pure mode to workaround a C++ interop compiler crash.\n    set(BRIDGING_MODE \"PURE\")\n  else()\n    set(BRIDGING_MODE \"INLINE\")\n  endif()\nendif()\n\nis_build_type_optimized(\"${SWIFT_STDLIB_BUILD_TYPE}\" swift_optimized)\nif(swift_optimized)\n  set(SWIFT_STDLIB_ASSERTIONS_default FALSE)\nelse()\n  set(SWIFT_STDLIB_ASSERTIONS_default TRUE)\nendif()\noption(SWIFT_STDLIB_ASSERTIONS\n    \"Enable internal checks for the Swift standard library (useful for debugging the library itself, does not affect checks required for safety)\"\n    \"${SWIFT_STDLIB_ASSERTIONS_default}\")\n\noption(SWIFT_BUILD_RUNTIME_WITH_HOST_COMPILER\n       \"Use the host compiler and not the internal clang to build the swift runtime\"\n       FALSE)\n\noption(SWIFT_RUN_TESTS_WITH_HOST_COMPILER\n       \"Run tests against the host compiler and not the just built swift\"\n       FALSE)\n\nset(SWIFT_SDKS \"\" CACHE STRING\n    \"If non-empty, limits building target binaries only to specified SDKs (despite other SDKs being available)\")\n\nset(SWIFT_PRIMARY_VARIANT_SDK \"\" CACHE STRING\n    \"Primary SDK for target binaries\")\nset(SWIFT_PRIMARY_VARIANT_ARCH \"\" CACHE STRING\n    \"Primary arch for target binaries\")\n\nset(SWIFT_NATIVE_LLVM_TOOLS_PATH \"\" CACHE STRING\n    \"Path to the directory that contains LLVM tools that are executable on the build machine\")\n\nset(SWIFT_NATIVE_CLANG_TOOLS_PATH \"\" CACHE STRING\n    \"Path to the directory that contains Clang tools that are executable on the build machine\")\n\nset(SWIFT_NATIVE_SWIFT_TOOLS_PATH \"\" CACHE STRING\n   \"Path to the directory that contains Swift tools that are executable on the build machine\")\n\noption(SWIFT_STDLIB_ENABLE_SIB_TARGETS\n       \"Should we generate sib targets for the stdlib or not?\"\n       FALSE)\n\noption(SWIFT_STDLIB_BUILD_SYMBOL_GRAPHS\n       \"Whether to build symbol graphs for the stdlib, for use in documentation.\"\n       FALSE)\n\n\nset(SWIFT_DARWIN_SUPPORTED_ARCHS \"\" CACHE STRING\n  \"Semicolon-separated list of architectures to configure on Darwin platforms. \\\nIf left empty all default architectures are configured.\")\n\nset(SWIFT_DARWIN_MODULE_ARCHS \"\" CACHE STRING\n  \"Semicolon-separated list of architectures to configure Swift module-only \\\ntargets on Darwin platforms. These targets are in addition to the full \\\nlibrary targets.\")\n\nset(SWIFT_MIN_RUNTIME_VERSION \"${DEFAULT_SWIFT_MIN_RUNTIME_VERSION}\" CACHE STRING\n  \"Specify the minimum version of the runtime that we target when building \\\nthe compiler itself. This is used on non-Darwin platforms to ensure \\\nthat it's possible to build the compiler using host tools.\")\n\n#\n# User-configurable Linux specific options.\n#\n\nset(SWIFT_MUSL_PATH \"/usr/local/musl\" CACHE STRING\n  \"Path to the directory that contains the Musl headers and libraries. \\\nThis is only required if we have been asked to build the Musl SDK, and \\\ndefaults to the default install location for Musl.\")\n\nset(SWIFT_SDK_LINUX_STATIC_ARCHITECTURES \"\" CACHE STRING\n  \"The architectures to configure when using the static Linux SDK.\")\n\nset(SWIFT_SDK_LINUX_ARCHITECTURES \"\" CACHE STRING\n  \"The architectures to configure when using the Linux SDK.\")\n\n#\n# User-configurable Android specific options.\n#\n\nset(SWIFT_ANDROID_API_LEVEL \"\" CACHE STRING\n  \"Version number for the Android API\")\n\nset(SWIFT_ANDROID_NDK_PATH \"\" CACHE STRING\n  \"Path to the directory that contains the Android NDK tools that are executable on the build machine\")\nset(SWIFT_ANDROID_DEPLOY_DEVICE_PATH \"\" CACHE STRING\n  \"Path on an Android device where build products will be pushed. These are used when running the test suite against the device\")\n\n#\n# User-configurable WebAssembly specific options.\n#\n\noption(SWIFT_ENABLE_WASI_THREADS\n  \"Build the Standard Library with WASI threads support\"\n  FALSE)\n\n#\n# User-configurable Darwin-specific options.\n#\noption(SWIFT_EMBED_BITCODE_SECTION\n    \"If non-empty, embeds LLVM bitcode binary sections in the standard library and overlay binaries for supported platforms\"\n    FALSE)\n\noption(SWIFT_EMBED_BITCODE_SECTION_HIDE_SYMBOLS\n  \"If non-empty, when embedding the LLVM bitcode binary sections into the relevant binaries, pass in -bitcode_hide_symbols. Does nothing if SWIFT_EMBED_BITCODE_SECTION is set to false.\"\n  FALSE)\n\nif(\"${SWIFT_HOST_VARIANT_SDK}\" MATCHES \"(OSX|IOS*|TVOS*|WATCHOS*)\")\n  set(SWIFT_RUNTIME_CRASH_REPORTER_CLIENT_default TRUE)\nelse()\n  set(SWIFT_RUNTIME_CRASH_REPORTER_CLIENT_default FALSE)\nendif()\n\noption(SWIFT_RUNTIME_CRASH_REPORTER_CLIENT\n    \"Whether to enable CrashReporter integration\"\n    \"${SWIFT_RUNTIME_CRASH_REPORTER_CLIENT_default}\")\n\nset(SWIFT_DARWIN_XCRUN_TOOLCHAIN \"XcodeDefault\" CACHE STRING\n    \"The name of the toolchain to pass to 'xcrun'\")\n\nset(SWIFT_DARWIN_STDLIB_INSTALL_NAME_DIR \"/usr/lib/swift\" CACHE STRING\n    \"The directory of the install_name for standard library dylibs\")\n\n# We don't want to use the same install_name_dir as the standard library which\n# will be installed in /usr/lib/swift. These private libraries should continue\n# to use @rpath for now.\nset(SWIFT_DARWIN_STDLIB_PRIVATE_INSTALL_NAME_DIR \"@rpath\" CACHE STRING\n    \"The directory of the install_name for the private standard library dylibs\")\n\noption(SWIFT_ALLOW_LINKING_SWIFT_CONTENT_IN_DARWIN_TOOLCHAIN\n  \"Adds search paths for libraries in the toolchain\n   when building Swift programs.\n   This is needed to support Apple internal configurations.\"\n  FALSE)\n\nset(SWIFT_DARWIN_DEPLOYMENT_VERSION_OSX \"13.0\" CACHE STRING\n    \"Minimum deployment target version for OS X\")\n\nset(SWIFT_DARWIN_DEPLOYMENT_VERSION_IOS \"16.0\" CACHE STRING\n    \"Minimum deployment target version for iOS\")\n\nset(SWIFT_DARWIN_DEPLOYMENT_VERSION_TVOS \"16.0\" CACHE STRING\n    \"Minimum deployment target version for tvOS\")\n\nset(SWIFT_DARWIN_DEPLOYMENT_VERSION_WATCHOS \"6.0\" CACHE STRING\n    \"Minimum deployment target version for watchOS\")\n\nset(SWIFT_DARWIN_DEPLOYMENT_VERSION_XROS \"1.0\" CACHE STRING\n    \"Minimum deployment target version for xrOS\")\n\n#\n#  Compatibility library deployment versions\n#\n\nset(COMPATIBILITY_MINIMUM_DEPLOYMENT_VERSION_OSX \"10.9\")\nset(COMPATIBILITY_MINIMUM_DEPLOYMENT_VERSION_IOS \"7.0\")\nset(COMPATIBILITY_MINIMUM_DEPLOYMENT_VERSION_TVOS \"9.0\")\nset(COMPATIBILITY_MINIMUM_DEPLOYMENT_VERSION_WATCHOS \"2.0\")\nset(COMPATIBILITY_MINIMUM_DEPLOYMENT_VERSION_XROS \"1.0\")\nset(COMPATIBILITY_MINIMUM_DEPLOYMENT_VERSION_MACCATALYST \"13.1\")\n\n#\n# User-configurable debugging options.\n#\n\noption(SWIFT_SIL_VERIFY_ALL\n    \"Run SIL verification after each transform when building Swift files in the build process\"\n    FALSE)\n\noption(SWIFT_SIL_VERIFY_ALL_MACOS_ONLY\n    \"Run SIL verification after each transform when building the macOS stdlib\"\n    FALSE)\n\noption(SWIFT_EMIT_SORTED_SIL_OUTPUT\n    \"Sort SIL output by name to enable diffing of output\"\n    FALSE)\n\nif(SWIFT_STDLIB_ASSERTIONS)\n  set(SWIFT_RUNTIME_CLOBBER_FREED_OBJECTS_default TRUE)\nelse()\n  set(SWIFT_RUNTIME_CLOBBER_FREED_OBJECTS_default FALSE)\nendif()\n\noption(SWIFT_RUNTIME_CLOBBER_FREED_OBJECTS\n    \"Overwrite memory for deallocated Swift objects\"\n    \"${SWIFT_RUNTIME_CLOBBER_FREED_OBJECTS_default}\")\n\noption(SWIFT_STDLIB_SIL_DEBUGGING\n    \"Compile the Swift standard library with -sil-based-debuginfo to enable debugging and profiling on SIL level\"\n    FALSE)\n\noption(SWIFT_CHECK_INCREMENTAL_COMPILATION\n    \"Check if incremental compilation works when compiling the Swift libraries\"\n    FALSE)\n\noption(SWIFT_ENABLE_ARRAY_COW_CHECKS\n    \"Compile the stdlib with Array COW checks enabled (only relevant for assert builds)\"\n    FALSE)\n\noption(SWIFT_REPORT_STATISTICS\n    \"Create json files which contain internal compilation statistics\"\n    FALSE)\n\n# Only Darwin platforms enable ObjC interop by default.\nif(\"${SWIFT_HOST_VARIANT_SDK}\" MATCHES \"(OSX|IOS*|TVOS*|WATCHOS*|XROS*)\")\n  set(SWIFT_STDLIB_ENABLE_OBJC_INTEROP_default TRUE)\nelse()\n  set(SWIFT_STDLIB_ENABLE_OBJC_INTEROP_default FALSE)\nendif()\n\n# Used by stdlib/toolchain as well, so this cannot be in stdlib/CMakeLists.txt\noption(SWIFT_STDLIB_ENABLE_OBJC_INTEROP\n       \"Should stdlib be built with Obj-C interop.\"\n       \"${SWIFT_STDLIB_ENABLE_OBJC_INTEROP_default}\")\n\nset(SWIFT_DEBUGINFO_NON_LTO_ARGS \"-g\" CACHE STRING\n    \"Compiler options to use when building the compiler in debug or debuginfo mode. These do not apply when linking with LTO\")\n\n#\n# User-configurable experimental options.  Do not use in production builds.\n#\n\nset(SWIFT_EXPERIMENTAL_EXTRA_FLAGS \"\" CACHE STRING\n    \"Extra flags to pass when compiling swift files.  Use this option *only* for one-off experiments\")\n\nset(SWIFT_EXPERIMENTAL_EXTRA_REGEXP_FLAGS \"\" CACHE STRING\n  \"A list of [module_regexp1;flags1;module_regexp2;flags2,...] which can be used to apply specific flags to modules that match a cmake regexp. It always applies the first regexp that matches.\")\n\nset(SWIFT_EXPERIMENTAL_EXTRA_NEGATIVE_REGEXP_FLAGS \"\" CACHE STRING\n    \"A list of [module_regexp1;flags1;module_regexp2;flags2,...] which can be used to apply specific flags to modules that do not match a cmake regexp. It always applies the first regexp that does not match. The reason this is necessary is that cmake does not provide negative matches in the regex. Instead you have to use NOT in the if statement requiring a separate variable.\")\n\noption(SWIFT_RUNTIME_ENABLE_LEAK_CHECKER\n  \"Should the runtime be built with support for non-thread-safe leak detecting entrypoints\"\n  FALSE)\n\noption(SWIFT_ENABLE_RUNTIME_FUNCTION_COUNTERS\n  \"Enable runtime function counters and expose the API.\"\n  FALSE)\n\noption(SWIFT_ENABLE_STDLIBCORE_EXCLUSIVITY_CHECKING\n  \"Build stdlibCore with exclusivity checking enabled\"\n  FALSE)\n\noption(SWIFT_STDLIB_ENABLE_DEBUG_PRECONDITIONS_IN_RELEASE\n  \"Enable _debugPrecondition checks in the stdlib in Release configurations\"\n  FALSE)\n\noption(SWIFT_ENABLE_EXPERIMENTAL_DIFFERENTIABLE_PROGRAMMING\n  \"Enable experimental Swift differentiable programming features\"\n  FALSE)\n\noption(SWIFT_IMPLICIT_CONCURRENCY_IMPORT\n  \"Implicitly import the Swift concurrency module\"\n  TRUE)\n\noption(SWIFT_IMPLICIT_BACKTRACING_IMPORT\n  \"Implicitly import the Swift backtracing module\"\n  FALSE)\n\noption(SWIFT_ENABLE_EXPERIMENTAL_CONCURRENCY\n  \"Enable build of the Swift concurrency module\"\n  FALSE)\n\noption(SWIFT_ENABLE_EXPERIMENTAL_CXX_INTEROP\n  \"Enable experimental C++ interop modules\"\n  TRUE)\n\noption(SWIFT_ENABLE_CXX_INTEROP_SWIFT_BRIDGING_HEADER\n  \"Install the <swift/bridging> C++ interoperability header alongside compiler\"\n  TRUE)\n\noption(SWIFT_ENABLE_EXPERIMENTAL_DISTRIBUTED\n  \"Enable experimental distributed actors and functions\"\n  FALSE)\n\noption(SWIFT_ENABLE_EXPERIMENTAL_STRING_PROCESSING\n  \"Enable experimental string processing\"\n  FALSE)\n\noption(SWIFT_ENABLE_EXPERIMENTAL_OBSERVATION\n  \"Enable build of the Swift observation module\"\n  FALSE)\n\noption(SWIFT_STDLIB_ENABLE_STRICT_CONCURRENCY_COMPLETE\n  \"Build the stdlib with -strict-concurrency=complete\"\n  FALSE)\n\noption(SWIFT_ENABLE_SYNCHRONIZATION\n  \"Enable build of the Swift Synchronization module\"\n  FALSE)\n\noption(SWIFT_ENABLE_VOLATILE\n  \"Enable build of the Swift Volatile module\"\n  FALSE)\n\noption(SWIFT_ENABLE_DISPATCH\n  \"Enable use of libdispatch\"\n  TRUE)\n\noption(SWIFT_ENABLE_GLOBAL_ISEL_ARM64\n  \"Enable global isel on arm64\"\n  FALSE)\n\noption(SWIFT_ENABLE_EXPERIMENTAL_PARSER_VALIDATION\n  \"Enable experimental SwiftParser validation by default\"\n  FALSE)\n\ncmake_dependent_option(SWIFT_BUILD_SOURCEKIT\n  \"Build SourceKit\" TRUE\n  \"SWIFT_ENABLE_DISPATCH\" FALSE)\ncmake_dependent_option(SWIFT_ENABLE_SOURCEKIT_TESTS\n  \"Enable running SourceKit tests\" TRUE\n  \"SWIFT_BUILD_SOURCEKIT\" FALSE)\n\noption(SWIFT_THREADING_PACKAGE\n  \"Override the threading package used for the build.  This can either be a\n   single package name, or a semicolon separated sequence of sdk:package pairs.\n   Valid package names are 'pthreads', 'darwin', 'linux', 'win32', 'c11', 'none'\n   or the empty string for the SDK default.\")\n\noption(SWIFT_THREADING_HAS_DLSYM\n  \"Enable the use of the dlsym() function.  This gets used to provide TSan\n   support on some platforms.\"\n  TRUE)\n\noption(SWIFT_ENABLE_MACCATALYST\n  \"Build the Standard Library and overlays with MacCatalyst support\"\n  FALSE)\n\noption(SWIFT_ENABLE_BACKTRACING\n  \"Build backtracing runtime support\"\n  FALSE)\n\nset(SWIFT_DARWIN_DEPLOYMENT_VERSION_MACCATALYST \"14.5\" CACHE STRING\n  \"Minimum deployment target version for macCatalyst\")\n\n#\n# End of user-configurable options.\n#\n\nset(SWIFT_BUILT_STANDALONE FALSE)\nif(\"${CMAKE_SOURCE_DIR}\" STREQUAL \"${CMAKE_CURRENT_SOURCE_DIR}\")\n  set(SWIFT_BUILT_STANDALONE TRUE)\nendif()\n\nif(SWIFT_BUILT_STANDALONE)\n  project(Swift C CXX ${SWIFT_ASM_DIALECT})\nendif()\n\nif(MSVC OR \"${CMAKE_SIMULATE_ID}\" STREQUAL \"MSVC\")\n  include(ClangClCompileRules)\nelseif(UNIX)\n  include(UnixCompileRules)\nendif()\n\nif(CMAKE_C_COMPILER_ID MATCHES Clang)\n  add_compile_options($<$<OR:$<COMPILE_LANGUAGE:C>,$<COMPILE_LANGUAGE:CXX>>:-Werror=gnu>)\nendif()\n\n# Make some warnings errors as they are commonly occurring and flood the build\n# with unnecessary noise.\nif(CMAKE_C_COMPILER_ID MATCHES Clang)\n  add_compile_options($<$<COMPILE_LANGUAGE:CXX>:-Werror=c++98-compat-extra-semi>)\nendif()\n\noption(SWIFT_BUILD_SWIFT_SYNTAX\n  \"Enable building swift syntax\"\n  FALSE)\n\noption(SWIFT_BUILD_REGEX_PARSER_IN_COMPILER\n    \"Build the Swift regex parser as part of the compiler.\"\n    TRUE)\nif(SWIFT_BUILD_REGEX_PARSER_IN_COMPILER AND NOT SWIFT_BUILD_SWIFT_SYNTAX)\n  message(WARNING \"Force setting SWIFT_BUILD_REGEX_PARSER_IN_COMPILER=OFF because Swift parser integration is disabled\")\n  set(SWIFT_BUILD_REGEX_PARSER_IN_COMPILER OFF)\nendif()\n\nset(SWIFT_BUILD_HOST_DISPATCH FALSE)\nif(SWIFT_ENABLE_DISPATCH AND NOT CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n  # Only build libdispatch for the host if the host tools are being built and\n  # specifically if these two libraries that depend on it are built.\n  if(SWIFT_INCLUDE_TOOLS AND SWIFT_BUILD_SOURCEKIT)\n    set(SWIFT_BUILD_HOST_DISPATCH TRUE)\n  endif()\n\n  if(SWIFT_BUILD_HOST_DISPATCH)\n    if(NOT EXISTS \"${SWIFT_PATH_TO_LIBDISPATCH_SOURCE}\")\n      message(SEND_ERROR \"SourceKit requires libdispatch on non-Darwin hosts.  Please specify SWIFT_PATH_TO_LIBDISPATCH_SOURCE\")\n    endif()\n  endif()\nendif()\n\nfile(STRINGS \"utils/availability-macros.def\" SWIFT_STDLIB_AVAILABILITY_DEFINITIONS)\nlist(FILTER SWIFT_STDLIB_AVAILABILITY_DEFINITIONS EXCLUDE REGEX \"^\\\\s*(#.*)?$\")\n\n#\n# Include CMake modules\n#\n\ninclude(CheckCXXSourceRuns)\ninclude(CMakeParseArguments)\ninclude(CMakePushCheckState)\n\n# Print out path and version of any installed commands\nmessage(STATUS \"CMake (${CMAKE_COMMAND}) Version: ${CMAKE_VERSION}\")\nif(XCODE)\n  set(version_flag -version)\nelse()\n  set(version_flag --version)\nendif()\nexecute_process(COMMAND ${CMAKE_MAKE_PROGRAM} ${version_flag}\n  OUTPUT_VARIABLE _CMAKE_MAKE_PROGRAM_VERSION\n  OUTPUT_STRIP_TRAILING_WHITESPACE)\nmessage(STATUS \"CMake Make Program (${CMAKE_MAKE_PROGRAM}) Version: ${_CMAKE_MAKE_PROGRAM_VERSION}\")\nmessage(STATUS \"C Compiler (${CMAKE_C_COMPILER}) Version: ${CMAKE_C_COMPILER_VERSION}\")\nmessage(STATUS \"C++ Compiler (${CMAKE_CXX_COMPILER}) Version: ${CMAKE_CXX_COMPILER_VERSION}\")\nmessage(STATUS \"Assembler (${CMAKE_${SWIFT_ASM_DIALECT}_COMPILER}) Version: ${CMAKE_${SWIFT_ASM_DIALECT}_COMPILER_VERSION}\")\nif (CMAKE_Swift_COMPILER)\n  message(STATUS \"Swift Compiler (${CMAKE_Swift_COMPILER}) Version: ${CMAKE_Swift_COMPILER_VERSION}\")\n\n  # Check if the current Swift compiler has implicit _StringProcessing module.\n  swift_supports_implicit_module(\"string-processing\"\n    SWIFT_SUPPORTS_DISABLE_IMPLICIT_STRING_PROCESSING_MODULE_IMPORT)\n  message(STATUS \"  Implicit 'string-processing' import: ${SWIFT_SUPPORTS_DISABLE_IMPLICIT_STRING_PROCESSING_MODULE_IMPORT}\")\n\n  # Same for _Backtracing.\n  swift_supports_implicit_module(\"backtracing\"\n    SWIFT_SUPPORTS_DISABLE_IMPLICIT_BACKTRACING_MODULE_IMPORT)\n  message(STATUS \"  Implicit 'backtracing' import: ${SWIFT_SUPPORTS_DISABLE_IMPLICIT_BACKTRACING_MODULE_IMPORT}\")\n\n  swift_get_package_cmo_support(\n    Swift_COMPILER_PACKAGE_CMO_SUPPORT)\n  message(STATUS \"  Package CMO: ${Swift_COMPILER_PACKAGE_CMO_SUPPORT}\")\nelse()\n  message(STATUS \"Swift Compiler (None).\")\nendif()\n\nset(THREADS_PREFER_PTHREAD_FLAG YES)\ninclude(FindThreads)\n\nif(SWIFT_PATH_TO_CMARK_BUILD)\n  execute_process(COMMAND ${SWIFT_PATH_TO_CMARK_BUILD}/src/cmark --version\n    OUTPUT_VARIABLE _CMARK_VERSION\n    OUTPUT_STRIP_TRAILING_WHITESPACE)\n  message(STATUS \"CMark Version: ${_CMARK_VERSION}\")\nelseif(SWIFT_INCLUDE_TOOLS)\n  find_package(cmark-gfm CONFIG REQUIRED)\nendif()\nmessage(STATUS \"\")\n\n# Check if a prebuilt clang path was passed in, as this variable will be\n# assigned if not, in SwiftSharedCMakeConfig.\nif(\"${SWIFT_NATIVE_CLANG_TOOLS_PATH}\" STREQUAL \"\")\n  set(SWIFT_PREBUILT_CLANG FALSE)\nelse()\n  set(SWIFT_PREBUILT_CLANG TRUE)\nendif()\n\n# Also mark if we have a prebuilt swift before we do anything.\nif(\"${SWIFT_NATIVE_SWIFT_TOOLS_PATH}\" STREQUAL \"\")\n  set(SWIFT_PREBUILT_SWIFT FALSE)\nelse()\n  set(SWIFT_PREBUILT_SWIFT TRUE)\nendif()\n\ninclude(SwiftSharedCMakeConfig)\n\n# NOTE: We include this before SwiftComponents as it relies on some LLVM CMake\n# functionality.\n# Support building Swift as a standalone project, using LLVM as an\n# external library.\nif(SWIFT_BUILT_STANDALONE)\n  swift_common_standalone_build_config(SWIFT)\nelse()\n  swift_common_unified_build_config(SWIFT)\nendif()\n\ninclude(SwiftComponents)\ninclude(SwiftHandleGybSources)\ninclude(SwiftSetIfArchBitness)\ninclude(AddSwift)\ninclude(SwiftConfigureSDK)\ninclude(SwiftComponents)\ninclude(SwiftList)\ninclude(AddPureSwift)\n\n# Configure swift include, install, build components.\nswift_configure_components()\n\n# lipo is used to create universal binaries.\ninclude(SwiftToolchainUtils)\nif(NOT SWIFT_LIPO)\n  find_toolchain_tool(SWIFT_LIPO \"${SWIFT_DARWIN_XCRUN_TOOLCHAIN}\" lipo)\nendif()\n\nget_filename_component(SWIFT_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR} REALPATH)\nset(SWIFT_BINARY_DIR \"${CMAKE_CURRENT_BINARY_DIR}\")\nset(SWIFT_CMAKE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules\")\nset(SWIFT_MAIN_INCLUDE_DIR \"${SWIFT_SOURCE_DIR}/include\")\nset(SWIFT_SHIMS_INCLUDE_DIR \"${SWIFT_SOURCE_DIR}/stdlib/public/SwiftShims\")\nset(SWIFT_INCLUDE_DIR \"${CMAKE_CURRENT_BINARY_DIR}/include\")\n\nif (NOT BOOTSTRAPPING_MODE)\n  message(FATAL_ERROR \"turning off bootstrapping is not supported anymore\")\nendif()\n\nset(SWIFT_RUNTIME_OUTPUT_INTDIR \"${CMAKE_BINARY_DIR}/${CMAKE_CFG_INTDIR}/bin\")\nset(SWIFT_LIBRARY_OUTPUT_INTDIR \"${CMAKE_BINARY_DIR}/${CMAKE_CFG_INTDIR}/lib\")\nif(\"${SWIFT_NATIVE_SWIFT_TOOLS_PATH}\" STREQUAL \"\")\n  # This is the normal case. We are not cross-compiling.\n  set(SWIFT_NATIVE_SWIFT_TOOLS_PATH \"${SWIFT_RUNTIME_OUTPUT_INTDIR}\")\n  set(SWIFT_EXEC_FOR_SWIFT_MODULES \"${CMAKE_Swift_COMPILER}\")\n  if(NOT SWIFT_EXEC_FOR_SWIFT_MODULES)\n    message(WARNING \"BOOTSTRAPPING set to OFF because no Swift compiler is defined\")\n    set(BOOTSTRAPPING_MODE \"OFF\")\n  endif()\nelseif(BOOTSTRAPPING_MODE MATCHES \"BOOTSTRAPPING.*\")\n  # If cross-compiling, we don't have to bootstrap. We can just use the previously\n  # built native swiftc to build the swift compiler modules.\n  message(STATUS \"Building swift modules with previously built tools instead of bootstrapping\")\n  set(SWIFT_EXEC_FOR_SWIFT_MODULES \"${SWIFT_NATIVE_SWIFT_TOOLS_PATH}/swiftc\")\n  if(BOOTSTRAPPING_MODE STREQUAL \"BOOTSTRAPPING-WITH-HOSTLIBS\")\n    set(BOOTSTRAPPING_MODE \"CROSSCOMPILE-WITH-HOSTLIBS\")\n  elseif(BOOTSTRAPPING_MODE STREQUAL \"BOOTSTRAPPING\")\n    set(BOOTSTRAPPING_MODE \"CROSSCOMPILE\")\n  else()\n    set(BOOTSTRAPPING_MODE \"HOSTTOOLS\")\n  endif()\nelseif(BOOTSTRAPPING_MODE STREQUAL \"HOSTTOOLS\" OR SWIFT_BUILD_SWIFT_SYNTAX)\n  # We are building using a pre-installed host toolchain but not bootstrapping\n  # the Swift modules. This happens when building using 'build-tooling-libs'\n  # where we haven't built a new Swift compiler. Use the Swift compiler from the\n  # pre-installed host toolchain to build the Swift modules.\n  set(SWIFT_EXEC_FOR_SWIFT_MODULES \"${CMAKE_Swift_COMPILER}\")\nendif()\n\nif(SWIFT_INCLUDE_TOOLS AND SWIFT_BUILD_SWIFT_SYNTAX)\n  # Only \"HOSTTOOLS\" is supported in Linux when Swift parser integration is enabled.\n  if(SWIFT_HOST_VARIANT_SDK MATCHES \"LINUX|OPENBSD|FREEBSD\" AND NOT BOOTSTRAPPING_MODE STREQUAL \"HOSTTOOLS\")\n    message(WARNING \"Force setting BOOTSTRAPPING=HOSTTOOLS because Swift parser integration is enabled\")\n    set(BOOTSTRAPPING_MODE \"HOSTTOOLS\")\n    if(NOT CMAKE_Swift_COMPILER)\n      message(SEND_ERROR \"No Swift compiler found.\\n\"\n        \"Tell CMake where to find the Swift compiler by setting either the \"\n        \"environment variable \\\"SWIFTC\\\" or the CMake cache entry \"\n        \"CMAKE_Swift_COMPILER to the full path of the compiler, or to the \"\n        \"compiler name if it is in the PATH\")\n    endif()\n  endif()\n  add_definitions(-DSWIFT_BUILD_SWIFT_SYNTAX)\nendif()\n\nif(BOOTSTRAPPING_MODE MATCHES \"HOSTTOOLS|.*-WITH-HOSTLIBS\")\n  if(SWIFT_ENABLE_ARRAY_COW_CHECKS)\n    message(STATUS \"array COW checks disabled when building the swift modules with host libraries\")\n    set(SWIFT_ENABLE_ARRAY_COW_CHECKS FALSE)\n  endif()\nendif()\n\n# This setting causes all CMakeLists.txt to automatically have\n# ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CURRENT_SOURCE_DIR} as an\n# include_directories path. This is done for developer\n# convenience. Additionally, LLVM/Clang build with this option enabled, so we\n# should match them unless it is removed from LLVM/Clang as well.\n#\n# *NOTE* Even though these directories are added to the include path for a\n# specific CMakeLists.txt, these include paths are not propagated down to\n# subdirectories.\nset(CMAKE_INCLUDE_CURRENT_DIR ON)\n\n# We'll need this once we have generated headers\ninclude_directories(BEFORE\n  ${SWIFT_MAIN_INCLUDE_DIR}\n  ${SWIFT_INCLUDE_DIR}\n  ${SWIFT_SHIMS_INCLUDE_DIR}\n  )\n\n# Configuration flags passed to all of our invocations of gyb.  Try to\n# avoid making up new variable names here if you can find a CMake\n# variable that will do the job.\nset(SWIFT_GYB_FLAGS\n    \"-DunicodeGraphemeBreakPropertyFile=${SWIFT_SOURCE_DIR}/utils/UnicodeData/GraphemeBreakProperty.txt\"\n    \"-DunicodeGraphemeBreakTestFile=${SWIFT_SOURCE_DIR}/utils/UnicodeData/GraphemeBreakTest.txt\")\n\n# Directory to use as the Clang module cache when building Swift source files.\nset(SWIFT_MODULE_CACHE_PATH\n    \"${CMAKE_BINARY_DIR}/${CMAKE_CFG_INTDIR}/module-cache\")\n\n# Xcode: use libc++ and c++11 using proper build settings.\nif(XCODE)\n  swift_common_xcode_cxx_config()\nendif()\n\n# Check what linux distribution is being used.\n# This can be used to determine the default linker to use.\nif(CMAKE_VERSION VERSION_GREATER_EQUAL \"3.22\")\n  cmake_host_system_information(RESULT DISTRO_NAME  QUERY DISTRIB_PRETTY_NAME)\nendif()\n\n# Which default linker to use. Prefer LLVM_USE_LINKER if it set, otherwise use\n# our own defaults. This should only be possible in a unified (not stand alone)\n# build environment.\ninclude(GoldVersion)\n\nif(LLVM_USE_LINKER)\n  set(SWIFT_USE_LINKER_default \"${LLVM_USE_LINKER}\")\nelseif(SWIFT_HOST_VARIANT_SDK STREQUAL \"ANDROID\")\n  set(SWIFT_USE_LINKER_default \"lld\")\nelseif(CMAKE_SYSTEM_NAME STREQUAL \"Windows\" AND NOT CMAKE_HOST_SYSTEM_NAME STREQUAL \"Windows\")\n  set(SWIFT_USE_LINKER_default \"lld\")\nelseif(CMAKE_SYSTEM_NAME STREQUAL \"Darwin\")\n  set(SWIFT_USE_LINKER_default \"\")\nelseif(DISTRO_NAME STREQUAL \"Amazon Linux 2023\")\n  set(SWIFT_USE_LINKER_default \"lld\")\nelse()\n  get_gold_version(gold_version)\n  if(NOT gold_version)\n    message(STATUS \"GNU Gold not found; using lld instead\")\n    set(SWIFT_USE_LINKER_default \"lld\")\n  elseif(gold_version VERSION_LESS \"2.36\")\n    message(STATUS \"GNU Gold is too old (${gold_version}); using lld instead\")\n    set(SWIFT_USE_LINKER_default \"lld\")\n  else()\n    message(STATUS \"Using GNU Gold ${gold_version}\")\n    set(SWIFT_USE_LINKER_default \"gold\")\n  endif()\nendif()\nset(SWIFT_USE_LINKER ${SWIFT_USE_LINKER_default} CACHE STRING\n    \"Build Swift with a non-default linker\")\n\ninclude(CheckLinkerFlag)\n\n# Apple's linker complains about duplicate libraries, which CMake likes to do\n# to support ELF platforms. To silence that warning, we can use\n# -no_warn_duplicate_libraries, but only in versions of the linker that\n# support that flag.\nif(NOT LLVM_USE_LINKER AND ${CMAKE_SYSTEM_NAME} MATCHES \"Darwin\")\n  check_linker_flag(C \"-Wl,-no_warn_duplicate_libraries\" SWIFT_LINKER_SUPPORTS_NO_WARN_DUPLICATE_LIBRARIES)\nelse()\n  set(SWIFT_LINKER_SUPPORTS_NO_WARN_DUPLICATE_LIBRARIES OFF CACHE INTERNAL \"\")\nendif()\n\n#\n# Enable additional warnings.\n#\nswift_common_cxx_warnings()\n\n# Check if we're build with MSVC or Clang-cl, as these compilers have similar command line arguments.\nif(\"${CMAKE_C_COMPILER_ID}\" STREQUAL \"MSVC\" OR \"${CMAKE_CXX_SIMULATE_ID}\" STREQUAL \"MSVC\")\n  set(SWIFT_COMPILER_IS_MSVC_LIKE TRUE)\nendif()\n\n#\n# Display a message if the threading package has been overridden\n#\n\nif(SWIFT_THREADING_PACKAGE)\n  message(STATUS \"\")\n  message(STATUS \"Threading package override enabled\")\n  foreach(elt ${SWIFT_THREADING_PACKAGE})\n    string(REPLACE \":\" \";\" elt_list \"${elt}\")\n    list(LENGTH elt_list elt_list_len)\n    if(elt_list_len EQUAL 1)\n      set(elt_sdk \"Global\")\n      list(GET elt_list 0 elt_package)\n    elseif(elt_list_len EQUAL 2)\n      list(GET elt_list 0 elt_sdk)\n      list(GET elt_list 1 elt_package)\n      string(TOUPPER \"${elt_sdk}\" elt_sdk)\n    else()\n      message(FATAL_ERROR \"Bad threading override \\\"${elt}\\\" - SWIFT_THREADING_PACKAGE must be a semicolon separated list of package or sdk:package pairs.\")\n    endif()\n    string(TOLOWER \"${elt_package}\" elt_package)\n    message(STATUS \"  ${elt_sdk}: ${elt_package}\")\n  endforeach()\n  message(STATUS \"\")\nendif()\n\n#\n# Configure SDKs.\n#\n\nif(XCODE)\n  # FIXME: It used to be the case that Xcode would force\n  # -m${platform}-version-min flags that would conflict with those computed\n  # by build-script. version-min flags are deprecated in favor of -target since\n  # clang-11, so we might be able to undo this.\n  set(SWIFT_SDKS \"OSX\")\nendif()\n\n# FIXME: the parameters we specify in SWIFT_SDKS are lacking architecture specifics,\n# so we need to hard-code it. For example, the SDK for Android is just 'ANDROID',\n# and we have to specify SWIFT_SDK_ANDROID_ARCHITECTURES separately.\n# The iOS SDKs all have their architectures hardcoded because they are just specified by name (e.g. 'IOS' or 'WATCHOS').\n# We can't cross-compile the standard library for another linux architecture,\n# because the SDK list would just be 'LINUX' and we couldn't disambiguate it from the host.\n#\n# To fix it, we would need to append the architecture to the SDKs,\n# for example: 'OSX-x86_64;IOS-armv7;...etc'.\n# We could easily do that - we have all of that information in build-script-impl.\n# Darwin targets cheat and use `xcrun`.\n\nif(\"${SWIFT_HOST_VARIANT_SDK}\" STREQUAL \"LINUX\")\n\n  set(SWIFT_HOST_VARIANT \"linux\" CACHE STRING\n      \"Deployment OS for Swift host tools (the compiler) [linux].\")\n\n  is_sdk_requested(LINUX swift_build_linux)\n  if(swift_build_linux)\n    if(\"${SWIFT_SDK_LINUX_ARCHITECTURES}\" STREQUAL \"\")\n      set(SWIFT_SDK_LINUX_ARCHITECTURES \"${SWIFT_HOST_VARIANT_ARCH}\")\n    endif()\n\n    configure_sdk_unix(\"Linux\" \"${SWIFT_SDK_LINUX_ARCHITECTURES}\")\n  endif()\n\n  is_sdk_requested(LINUX_STATIC swift_build_linux_static)\n  if(swift_build_linux_static)\n    if(\"${SWIFT_MUSL_PATH}\" STREQUAL \"\")\n      message(FATAL_ERROR \"You must set SWIFT_MUSL_PATH to point to the Musl libraries and headers.  Specifically, we expect to find Musl at <SWIFT_MUSL_PATH>/<arch> for each requested architecture.\")\n    endif()\n\n    if(\"${SWIFT_SDK_LINUX_STATIC_ARCHITECTURES}\" STREQUAL \"\")\n      set(SWIFT_SDK_LINUX_STATIC_ARCHITECTURES \"aarch64;x86_64\")\n    endif()\n\n    configure_sdk_unix(\"Linux_Static\" \"${SWIFT_SDK_LINUX_STATIC_ARCHITECTURES}\")\n  endif()\n\n  is_sdk_requested(FREESTANDING swift_build_freestanding)\n  if(swift_build_freestanding AND (SWIFT_FREESTANDING_FLAVOR STREQUAL \"linux\"))\n    # TODO\n    # configure_sdk_unix(\"FREESTANDING\" \"${SWIFT_HOST_VARIANT_ARCH}\")\n  endif()\n\n  # Default is Linux SDK for host\n  set(SWIFT_PRIMARY_VARIANT_SDK_default  \"${SWIFT_HOST_VARIANT_SDK}\")\n  set(SWIFT_PRIMARY_VARIANT_ARCH_default \"${SWIFT_HOST_VARIANT_ARCH}\")\n\nelseif(\"${SWIFT_HOST_VARIANT_SDK}\" STREQUAL \"FREEBSD\")\n\n  set(SWIFT_HOST_VARIANT \"freebsd\" CACHE STRING\n      \"Deployment OS for Swift host tools (the compiler) [freebsd].\")\n\n  configure_sdk_unix(\"FreeBSD\" \"${SWIFT_HOST_VARIANT_ARCH}\")\n  set(SWIFT_PRIMARY_VARIANT_SDK_default  \"${SWIFT_HOST_VARIANT_SDK}\")\n  set(SWIFT_PRIMARY_VARIANT_ARCH_default \"${SWIFT_HOST_VARIANT_ARCH}\")\n\nelseif(\"${SWIFT_HOST_VARIANT_SDK}\" STREQUAL \"OPENBSD\")\n\n  set(SWIFT_HOST_VARIANT \"openbsd\" CACHE STRING\n      \"Deployment OS for Swift host tools (the compiler) [openbsd].\")\n\n  configure_sdk_unix(\"OpenBSD\" \"${SWIFT_HOST_VARIANT_ARCH}\")\n  set(SWIFT_PRIMARY_VARIANT_SDK_default  \"${SWIFT_HOST_VARIANT_SDK}\")\n  set(SWIFT_PRIMARY_VARIANT_ARCH_default \"${SWIFT_HOST_VARIANT_ARCH}\")\n\nelseif(\"${SWIFT_HOST_VARIANT_SDK}\" STREQUAL \"CYGWIN\")\n\n  set(SWIFT_HOST_VARIANT \"cygwin\" CACHE STRING\n      \"Deployment OS for Swift host tools (the compiler) [cygwin].\")\n\n  configure_sdk_unix(\"Cygwin\" \"${SWIFT_HOST_VARIANT_ARCH}\")\n  set(SWIFT_PRIMARY_VARIANT_SDK_default \"${SWIFT_HOST_VARIANT_SDK}\")\n  set(SWIFT_PRIMARY_VARIANT_ARCH_default \"${SWIFT_HOST_VARIANT_ARCH}\")\n\nelseif(\"${SWIFT_HOST_VARIANT_SDK}\" STREQUAL \"WINDOWS\")\n\n  set(SWIFT_HOST_VARIANT \"windows\" CACHE STRING\n      \"Deployment OS for Swift host tools (the compiler) [windows].\")\n\n  configure_sdk_windows(\"Windows\" \"msvc\" \"${SWIFT_HOST_VARIANT_ARCH}\")\n  set(SWIFT_PRIMARY_VARIANT_SDK_default  \"${SWIFT_HOST_VARIANT_SDK}\")\n  set(SWIFT_PRIMARY_VARIANT_ARCH_default \"${SWIFT_HOST_VARIANT_ARCH}\")\n\nelseif(\"${SWIFT_HOST_VARIANT_SDK}\" STREQUAL \"HAIKU\")\n\n  set(SWIFT_HOST_VARIANT \"haiku\" CACHE STRING\n      \"Deployment OS for Swift host tools (the compiler) [haiku].\")\n\n  configure_sdk_unix(\"Haiku\" \"${SWIFT_HOST_VARIANT_ARCH}\")\n  set(SWIFT_PRIMARY_VARIANT_SDK_default  \"${SWIFT_HOST_VARIANT_SDK}\")\n  set(SWIFT_PRIMARY_VARIANT_ARCH_default \"${SWIFT_HOST_VARIANT_ARCH}\")\n\nelseif(\"${SWIFT_HOST_VARIANT_SDK}\" STREQUAL \"ANDROID\")\n\n  set(SWIFT_HOST_VARIANT \"android\" CACHE STRING\n      \"Deployment OS for Swift host tools (the compiler) [android]\")\n\n  set(SWIFT_ANDROID_NATIVE_SYSROOT \"/data/data/com.termux/files\" CACHE STRING\n      \"Path to Android sysroot, default initialized to the Termux app's layout\")\n\n  if(\"${SWIFT_SDK_ANDROID_ARCHITECTURES}\" STREQUAL \"\")\n    set(SWIFT_SDK_ANDROID_ARCHITECTURES ${SWIFT_HOST_VARIANT_ARCH})\n  endif()\n\n  configure_sdk_unix(\"Android\" \"${SWIFT_SDK_ANDROID_ARCHITECTURES}\")\n  set(SWIFT_PRIMARY_VARIANT_SDK_default  \"${SWIFT_HOST_VARIANT_SDK}\")\n  set(SWIFT_PRIMARY_VARIANT_ARCH_default \"${SWIFT_HOST_VARIANT_ARCH}\")\n\nelseif(\"${SWIFT_HOST_VARIANT_SDK}\" STREQUAL \"WASI\")\n  set(SWIFT_HOST_VARIANT \"wasi\" CACHE STRING\n      \"Deployment OS for Swift host tools (the compiler) [wasi]\")\n\n  configure_sdk_unix(\"WASI\" \"wasm32\")\n  set(SWIFT_PRIMARY_VARIANT_SDK_default  \"${SWIFT_HOST_VARIANT_SDK}\")\n  set(SWIFT_PRIMARY_VARIANT_ARCH_default \"${SWIFT_HOST_VARIANT_ARCH}\")\n\nelseif(\"${SWIFT_HOST_VARIANT_SDK}\" MATCHES \"(OSX|IOS*|TVOS*|WATCHOS*|XROS*)\")\n\n  set(SWIFT_HOST_VARIANT \"macosx\" CACHE STRING\n      \"Deployment OS for Swift host tools (the compiler) [macosx, iphoneos].\")\n\n  # Display Xcode toolchain version.\n  # The SDK configuration below prints each SDK version.\n  execute_process(\n    COMMAND \"xcodebuild\" \"-version\"\n    OUTPUT_VARIABLE xcode_version\n    OUTPUT_STRIP_TRAILING_WHITESPACE)\n  string(REPLACE \"\\n\" \", \" xcode_version \"${xcode_version}\")\n  message(STATUS \"${xcode_version}\")\n  message(STATUS \"\")\n\n  include(DarwinSDKs)\n\n  # FIXME: guess target variant based on the host.\n  # if(SWIFT_HOST_VARIANT MATCHES \"^macosx\")\n  #   set(SWIFT_PRIMARY_VARIANT_GUESS \"OSX-R\")\n  # elseif(SWIFT_HOST_VARIANT MATCHES \"^iphoneos\")\n  #   set(SWIFT_PRIMARY_VARIANT_GUESS \"IOS-R\")\n  # else()\n  #   message(FATAL_ERROR \"Unknown SWIFT_HOST_VARIANT '${SWIFT_HOST_VARIANT}'\")\n  # endif()\n  #\n  # set(SWIFT_PRIMARY_VARIANT ${SWIFT_PRIMARY_VARIANT_GUESS} CACHE STRING\n  #    \"[OSX-DA, OSX-RA, OSX-R, IOS-DA, IOS-RA, IOS-R, IOS_SIMULATOR-DA, IOS_SIMULATOR-RA, IOS_SIMULATOR-R]\")\n  #\n  # Primary variant is always OSX; even on iOS hosts.\n  set(SWIFT_PRIMARY_VARIANT_SDK_default \"OSX\")\n  set(SWIFT_PRIMARY_VARIANT_ARCH_default \"${CMAKE_HOST_SYSTEM_PROCESSOR}\")\n\nendif()\n\nif(\"${SWIFT_PRIMARY_VARIANT_SDK}\" STREQUAL \"\")\n  set(SWIFT_PRIMARY_VARIANT_SDK \"${SWIFT_PRIMARY_VARIANT_SDK_default}\")\nendif()\nif(\"${SWIFT_PRIMARY_VARIANT_ARCH}\" STREQUAL \"\")\n  set(SWIFT_PRIMARY_VARIANT_ARCH \"${SWIFT_PRIMARY_VARIANT_ARCH_default}\")\nendif()\n\n# Should we cross-compile the standard library for Android?\nis_sdk_requested(ANDROID swift_build_android)\nif(swift_build_android AND NOT \"${SWIFT_HOST_VARIANT_SDK}\" STREQUAL \"ANDROID\")\n  if (\"${SWIFT_ANDROID_NDK_PATH}\" STREQUAL \"\")\n    message(FATAL_ERROR \"You must set SWIFT_ANDROID_NDK_PATH to cross-compile the Swift runtime for Android\")\n  endif()\n  if (NOT (\"${CMAKE_HOST_SYSTEM_NAME}\" STREQUAL \"Darwin\" OR \"${CMAKE_HOST_SYSTEM_NAME}\" STREQUAL \"Linux\"))\n    message(FATAL_ERROR \"A Darwin or Linux host is required to build the Swift runtime for Android\")\n  endif()\n\n  if(\"${SWIFT_SDK_ANDROID_ARCHITECTURES}\" STREQUAL \"\")\n    set(SWIFT_SDK_ANDROID_ARCHITECTURES armv7;aarch64)\n  endif()\n  configure_sdk_unix(\"Android\" \"${SWIFT_SDK_ANDROID_ARCHITECTURES}\")\nendif()\n\n# Should we cross-compile the standard library for Windows?\nis_sdk_requested(WINDOWS swift_build_windows)\nif(swift_build_windows AND NOT \"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Windows\")\n  if(\"${SWIFT_SDK_WINDOWS_ARCHITECTURES}\" STREQUAL \"\")\n    set(SWIFT_SDK_WINDOWS_ARCHITECTURES aarch64;armv7;i686;x86_64)\n  endif()\n  configure_sdk_windows(\"Windows\" \"msvc\" \"${SWIFT_SDK_WINDOWS_ARCHITECTURES}\")\nendif()\n\n# Should we cross-compile the standard library for WASI?\nis_sdk_requested(WASI swift_build_wasm)\nif(swift_build_wasm AND NOT \"${SWIFT_HOST_VARIANT_SDK}\" STREQUAL \"WASI\")\n  configure_sdk_unix(WASI wasm32)\nendif()\n\nif(\"${SWIFT_SDKS}\" STREQUAL \"\")\n  set(SWIFT_SDKS \"${SWIFT_CONFIGURED_SDKS}\")\nendif()\n\nlist_subtract(\"${SWIFT_SDKS}\" \"${SWIFT_CONFIGURED_SDKS}\" unknown_sdks)\n\nprecondition(unknown_sdks NEGATE MESSAGE \"Unknown SDKs: ${unknown_sdks}\")\nprecondition(SWIFT_CONFIGURED_SDKS MESSAGE \"No SDKs selected.\")\nprecondition(SWIFT_HOST_VARIANT_SDK MESSAGE \"No SDK for host tools.\")\nprecondition(SWIFT_HOST_VARIANT_ARCH MESSAGE \"No arch for host tools\")\n\nset(SWIFT_PRIMARY_VARIANT_SUFFIX\n    \"-${SWIFT_SDK_${SWIFT_PRIMARY_VARIANT_SDK}_LIB_SUBDIR}-${SWIFT_PRIMARY_VARIANT_ARCH}\")\n\n# Clear universal library names to prevent adding duplicates\nforeach(sdk ${SWIFT_SDKS})\n  unset(UNIVERSAL_LIBRARY_NAMES_${SWIFT_SDK_${sdk}_LIB_SUBDIR} CACHE)\nendforeach()\n\nif(SWIFT_PARALLEL_LINK_JOBS)\n  if(NOT CMAKE_MAKE_PROGRAM MATCHES \"ninja\")\n    message(WARNING \"Job pooling is only available with Ninja generators.\")\n  else()\n    set_property(GLOBAL APPEND PROPERTY JOB_POOLS swift_link_job_pool=${SWIFT_PARALLEL_LINK_JOBS})\n    set(CMAKE_JOB_POOL_LINK swift_link_job_pool)\n  endif()\nendif()\n\n# Set the CMAKE_OSX_* variables in a way that minimizes conflicts.\nif(\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Darwin\" AND NOT CMAKE_CROSSCOMPILING)\n  set(CMAKE_OSX_SYSROOT \"${SWIFT_SDK_${SWIFT_HOST_VARIANT_SDK}_PATH}\")\n  set(CMAKE_OSX_ARCHITECTURES \"\")\n  set(CMAKE_OSX_DEPLOYMENT_TARGET \"\")\nendif()\n\nswift_get_host_triple(SWIFT_HOST_TRIPLE)\nset(SWIFT_HOST_MODULE_TRIPLE \"${SWIFT_SDK_${SWIFT_HOST_VARIANT_SDK}_ARCH_${SWIFT_HOST_VARIANT_ARCH}_MODULE}\")\nset(SWIFT_HOST_LIBRARIES_DEST_DIR \"${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/swift/host\")\n\nif(SWIFT_INCLUDE_TOOLS)\n  message(STATUS \"Building host Swift tools for ${SWIFT_HOST_VARIANT_SDK} ${SWIFT_HOST_VARIANT_ARCH}\")\n  message(STATUS \"  Build type:     ${CMAKE_BUILD_TYPE}\")\n  message(STATUS \"  Assertions:     ${LLVM_ENABLE_ASSERTIONS}\")\n  message(STATUS \"  LTO:            ${SWIFT_TOOLS_ENABLE_LTO}\")\n  message(STATUS \"  Bootstrapping:  ${BOOTSTRAPPING_MODE}\")\n  message(STATUS \"  C++ Bridging:   ${BRIDGING_MODE}\")\n  message(STATUS \"  Swift parser:   ${SWIFT_BUILD_SWIFT_SYNTAX}\")\n  message(STATUS \"\")\nelse()\n  message(STATUS \"Not building host Swift tools\")\n  message(STATUS \"\")\nendif()\n\nif(SWIFT_BUILD_STDLIB OR SWIFT_BUILD_SDK_OVERLAY)\n  message(STATUS \"Building Swift standard library and overlays for SDKs: ${SWIFT_SDKS}\")\n  message(STATUS \"  Build type:       ${SWIFT_STDLIB_BUILD_TYPE}\")\n  message(STATUS \"  Assertions:       ${SWIFT_STDLIB_ASSERTIONS}\")\n  message(STATUS \"\")\n\n  message(STATUS \"Building Swift runtime with:\")\n  message(STATUS \"  Leak Detection Checker Entrypoints: ${SWIFT_RUNTIME_ENABLE_LEAK_CHECKER}\")\n  message(STATUS \"\")\n\n  message(STATUS \"Differentiable Programming Support: ${SWIFT_ENABLE_EXPERIMENTAL_DIFFERENTIABLE_PROGRAMMING}\")\n  message(STATUS \"Concurrency Support:                ${SWIFT_ENABLE_EXPERIMENTAL_CONCURRENCY}\")\n  message(STATUS \"Distributed Support:                ${SWIFT_ENABLE_EXPERIMENTAL_DISTRIBUTED}\")\n  message(STATUS \"String Processing Support:          ${SWIFT_ENABLE_EXPERIMENTAL_STRING_PROCESSING}\")\n  message(STATUS \"Backtracing Support:                ${SWIFT_ENABLE_BACKTRACING}\")\n  message(STATUS \"Unicode Support:                    ${SWIFT_STDLIB_ENABLE_UNICODE_DATA}\")\n  message(STATUS \"Observation Support:                ${SWIFT_ENABLE_EXPERIMENTAL_OBSERVATION}\")\n  message(STATUS \"Synchronization Support:            ${SWIFT_ENABLE_SYNCHRONIZATION}\")\n  message(STATUS \"Volatile Support:                   ${SWIFT_ENABLE_VOLATILE}\")\n  message(STATUS \"\")\nelse()\n  message(STATUS \"Not building Swift standard library, SDK overlays, and runtime\")\n  message(STATUS \"\")\nendif()\n\nif(SWIFT_BUILD_LIBEXEC)\n  message(STATUS \"Building Swift auxiliary executables for SDKs: ${SWIFT_SDKS}\")\n  message(STATUS \"\")\nendif()\n\nif(SWIFT_BUILD_REMOTE_MIRROR)\n  message(STATUS \"Building Swift Remote Mirror for SDKs: ${SWIFT_SDKS}\")\n  message(STATUS \"\")\nendif()\n\n#\n# Find required dependencies.\n#\n\nfind_package(Python3 3.6 COMPONENTS Interpreter REQUIRED)\n\n#\n# Find optional dependencies.\n#\n\nif(LLVM_ENABLE_LIBXML2)\n  find_package(LibXml2 REQUIRED)\nelse()\n  find_package(LibXml2)\nendif()\n\nif(LLVM_ENABLE_LIBEDIT)\n  find_package(LibEdit REQUIRED)\nelse()\n  find_package(LibEdit)\nendif()\n\nif(LibEdit_FOUND)\n  cmake_push_check_state()\n  list(APPEND CMAKE_REQUIRED_INCLUDES ${LibEdit_INCLUDE_DIRS})\n  list(APPEND CMAKE_REQUIRED_LIBRARIES ${LibEdit_LIBRARIES})\n  check_symbol_exists(el_wgets \"histedit.h\" HAVE_EL_WGETS)\n  if(HAVE_EL_WGETS)\n    set(LibEdit_HAS_UNICODE YES)\n  else()\n    set(LibEdit_HAS_UNICODE NO)\n  endif()\n  cmake_pop_check_state()\nendif()\n\ncheck_symbol_exists(wait4 \"sys/wait.h\" HAVE_WAIT4)\n\ncheck_symbol_exists(proc_pid_rusage \"libproc.h\" HAVE_PROC_PID_RUSAGE)\nif(HAVE_PROC_PID_RUSAGE)\n    list(APPEND CMAKE_REQUIRED_LIBRARIES proc)\nendif()\n\nif (LLVM_ENABLE_DOXYGEN)\n  message(STATUS \"Doxygen: enabled\")\nendif()\n\nif(SWIFT_ENABLE_DISPATCH)\n  include(Libdispatch)\nendif()\n\n# Add all of the subdirectories, where we actually do work.\nadd_subdirectory(include)\nif(SWIFT_INCLUDE_TOOLS)\n  add_subdirectory(lib)\nendif()\n\n###############\n# PLEASE READ #\n###############\n#\n# We have to include stdlib/ before tools/.\n# Do not move add_subdirectory(stdlib) after add_subdirectory(tools)!\n#\n# We must include stdlib/ before tools/ because stdlib/CMakeLists.txt\n# declares the swift-stdlib-* set of targets. These targets will then\n# implicitly depend on any targets declared with IS_STDLIB.\n#\n# https://github.com/apple/swift/issues/48534\nif(SWIFT_BUILD_STDLIB)\n  add_subdirectory(stdlib)\nelse()\n  set(SWIFT_STDLIB_SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/stdlib\")\n  # Some of the things below depend on the threading library\n  add_subdirectory(stdlib/public/Threading)\n\n  if(SWIFT_BUILD_STDLIB_EXTRA_TOOLCHAIN_CONTENT)\n    add_subdirectory(stdlib/toolchain)\n\n    if(SWIFT_BUILD_STDLIB_CXX_MODULE)\n      add_subdirectory(stdlib/public/Cxx)\n    endif()\n  endif()\n\n  # Some tools (e.g. swift-reflection-dump) rely on a host swiftRemoteInspection,\n  # so ensure we build that when building tools.\n  if(SWIFT_INCLUDE_TOOLS OR SWIFT_BUILD_STDLIB_CXX_MODULE)\n    add_subdirectory(stdlib/public/SwiftShims/swift/shims)\n  endif()\n\n  # We might want to build Remote Mirror separately\n  if(SWIFT_BUILD_REMOTE_MIRROR)\n    add_subdirectory(stdlib/public/LLVMSupport)\n    add_subdirectory(stdlib/public/Demangling)\n    add_subdirectory(stdlib/public/RemoteInspection)\n    add_subdirectory(stdlib/public/SwiftRemoteMirror)\n  endif()\n\n  # We might also want to build the things in libexec seaprately\n  if(SWIFT_BUILD_LIBEXEC)\n    add_subdirectory(stdlib/public/libexec)\n  endif()\nendif()\n\nif(SWIFT_INCLUDE_APINOTES)\n  add_subdirectory(apinotes)\nendif()\n\nif(SWIFT_INCLUDE_TOOLS)\n  add_subdirectory(SwiftCompilerSources)\n\n  # Always include this after including stdlib/!\n  # Refer to the large comment above the add_subdirectory(stdlib) call.\n  # https://github.com/apple/swift/issues/48534\n  add_subdirectory(tools)\n\n  # Localization targets are configured in a way that assume the swift\n  # frontend is being built, so trying to include them for other builds\n  # (like stdlib) fail!\n  #\n  # Diagnostics information is only useful for the frontend compiler\n  # anyway, so let's only include it if the compiler is being built,\n  # which at the moment seems like if SWIFT_INCLUDE_TOOLS is defined.\n  add_subdirectory(localization)\nendif()\n\nadd_subdirectory(utils)\n\nadd_subdirectory(userdocs)\n\nif (\"${CMAKE_SYSTEM_NAME}\" STREQUAL \"Darwin\")\n  if(SWIFT_BUILD_PERF_TESTSUITE)\n    add_subdirectory(benchmark)\n  endif()\nendif()\n\nif(SWIFT_INCLUDE_TESTS)\n  add_subdirectory(test)\n  add_subdirectory(unittests)\nendif()\nif(SWIFT_INCLUDE_DOCS)\n  add_subdirectory(docs)\nendif()\n\nadd_subdirectory(cmake/modules)\n\nswift_install_in_component(FILES \"LICENSE.txt\"\n                           DESTINATION \"share/swift\"\n                           COMPONENT license)\n\n# Add a documentation target so that documentation shows up in the\n# Xcode project.\nif(XCODE)\n  add_custom_target(Documentation\n      SOURCES\n        README.md\n        docs)\n\n  file(GLOB SWIFT_TOPLEVEL_HEADERS\n      ${CMAKE_CURRENT_SOURCE_DIR}/include/swift${dir}/*.h\n      ${CMAKE_CURRENT_SOURCE_DIR}/include/swift${dir}/*.td\n      ${CMAKE_CURRENT_SOURCE_DIR}/include/swift${dir}/*.def)\n  add_custom_target(Miscellaneous\n      SOURCES ${SWIFT_TOPLEVEL_HEADERS})\nendif()\n\n# New standard library build\noption(SWIFT_ENABLE_NEW_RUNTIME_BUILD \"Build Swift runtimes with new build system\" OFF)\nif(SWIFT_ENABLE_NEW_RUNTIME_BUILD)\n\n  add_custom_target(PopulateRuntimeSourceDir\n    COMMAND \"${CMAKE_COMMAND}\" -P \"${CMAKE_CURRENT_SOURCE_DIR}/Runtimes/Resync.cmake\"\n    COMMENT \"Copying sources into new runtime build\")\n\n  foreach(sdk ${SWIFT_SDKS})\n    foreach(arch ${SWIFT_SDK_${sdk}_ARCHITECTURES})\n      # Provide a mechanism to skip building one of these runtimes\n      if(SWIFT_SKIP_${sdk}_${arch}_RUNTIME)\n        message(STATUS \"Skipping: ${arch}-${sdk} runtime build\")\n        continue()\n      endif()\n      set(stdlib_target \"swift-stdlib-${SWIFT_SDK_${sdk}_LIB_SUBDIR}-${arch}\")\n      if(${SWIFT_SDK_${sdk}_${arch}_CACHE})\n        set(stdlib_cache_file_flag -C ${SWIFT_SDK_${sdk}_${arch}_CACHE})\n      endif()\n      ExternalProject_Add(\"${stdlib_target}-core\"\n        SOURCE_DIR \"${CMAKE_CURRENT_SOURCE_DIR}/Runtimes/Core\"\n        # TODO: Add this once we're ready to start swapping out the libraries\n        #       for testing\n        # INSTALL_DIR \"${CMAKE_BINARY_DIR}/\"\n\n        DEPENDS PopulateRuntimeSourceDir\n        CMAKE_ARGS\n          -DCMAKE_INSTALL_LIBDIR:FILEPATH=lib/swift/${SWIFT_SDK_${sdk}_LIB_SUBDIR}/${arch}\n          # Compiler will see mismatched swift modules and fail initial checks\n          -DCMAKE_Swift_COMPILER_WORKS:BOOLEAN=YES\n          -DBUILD_SHARED_LIBS:BOOLEAN=YES # TODO: Make this configurable\n          ${stdlib_cache_file_flag}\n          -DCMAKE_BUILD_TYPE:STRING=${CMAKE_BUILD_TYPE}\n          -DCMAKE_INSTALL_PREFIX:FILEPATH=<INSTALL_DIR>\n          -DCMAKE_Swift_COMPILER:FILEPATH=$<IF:$<BOOL:${CMAKE_CROSSCOMPILING}>,${CMAKE_Swift_COMPILER},$<PATH:REPLACE_FILENAME,$<TARGET_FILE:swift-frontend>,swiftc>>\n          -DCMAKE_C_COMPILER:FILEPATH=${CMAKE_C_COMPILER}\n          -DCMAKE_CXX_COMPILER:FILEPATH=${CMAKE_CXX_COMPILER}\n          -DCMAKE_COLOR_DIAGNOSTICS:BOOLEAN=${CMAKE_COLOR_DIAGNOSTICS}\n          -DCMAKE_MAKE_PROGRAM=${CMAKE_MAKE_PROGRAM})\n      if(NOT ${CMAKE_CROSSCOMPILING})\n        add_dependencies(\"${stdlib_target}\" swift-frontend)\n      endif()\n    endforeach()\n  endforeach()\nendif()\n"
        },
        {
          "name": "CODE_OWNERS.TXT",
          "type": "blob",
          "size": 1.75,
          "content": "This file is a list of the people responsible for ensuring that patches for a\nparticular part of Swift are reviewed, either by themselves or by someone else.\nThey are also the gatekeepers for their part of Swift, with the final word on\nwhat goes in or not.\n\nThe list is sorted by surname and formatted to allow easy grepping and\nbeautification by scripts.  The fields are: name (N), email (E),\nGitHub account (G), description (D).\n\nN: Ben Cohen\nE: ben_cohen@apple.com\nG: airspeedswift\nD: Swift standard library\n\nN: Brian Croom\nE: bcroom@apple.com\nG: briancroom\nD: XCTest overlay\n\nN: Erik Eckstein\nE: eeckstein@apple.com\nG: eeckstein\nD: SILOptimizer, Swift Benchmark Suite\n\nN: Xi Ge\nE: xi_ge@apple.com\nG: nkcsgexi\nD: Markup, Migrator, lib/Syntax\n\nN: Doug Gregor\nE: dgregor@apple.com\nG: DougGregor\nD: AST, Basic, Parse, Sema\n\nN: Joe Groff\nE: jgroff@apple.com\nG: jckarter\nD: SIL, SILGen, everything in Swift not covered by someone else\n\nN: Argyrios Kyrtzidis\nE: kyrtzidis@apple.com\nG: akyrtzi\nD: IDE, Index, SourceKit, swift-ide-test\n\nN: John McCall\nE: rjmccall@apple.com\nG: rjmccall\nD: Demangler, IRGen, Runtime\n\nN: Victoria Mitchell\nE: victoria_m@apple.com\nG: QuietMisdreavus\nD: SymbolGraphGen\n\nN: Max Moiseev\nE: moiseev@apple.com\nG: moiseev\nD: Apple contact for non-corelibs overlays\n\nN: Tony Parker\nE: anthony.parker@apple.com\nG: parkera\nD: Foundation overlay\n\nN: Slava Pestov\nE: spestov@apple.com\nG: slavapestov\nD: Reflection, SwiftRemoteMirror\n\nN: Adrian Prantl\nE: aprantl@apple.com\nG: adrian-prantl\nD: Debug info\n\nN: Jordan Rose\nE: jordan_rose@apple.com\nG: jrose-apple\nD: ClangImporter, Serialization, PrintAsClang, Driver, Frontend\n\nN: Daniel Steffen\nE: dsteffen@apple.com\nG: das\nD: Dispatch overlay\n\nN: Anna Zaks\nE: ganna@apple.com\nG: AnnaZaks\nD: SIL diagnostics passes, sanitizers\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 18.98,
          "content": "# Contributing to Swift\n\nContributions to Swift are welcomed and encouraged!\nFor contributions to the broader Swift project, please see the\n[Contributing to Swift guide](https://swift.org/contributing/).\n\nTo give clarity of what is expected of our members, Swift has adopted the code of conduct defined by the [Contributor Covenant](http://contributor-covenant.org/).\nThis document is used across many open source communities, and it articulates our values.\nFor more detail, read the project's [Code of Conduct](https://swift.org/code-of-conduct/).\n\nIt is highly recommended that you become familiar with using Swift in your own projects before contributing directly to the language itself.\nWe put together handy [Getting Started](https://www.swift.org/getting-started/) guide and tutorials with step-by-step instructions to get you up and running.\n\n## Reporting Bugs\n\nReporting bugs is a great way for anyone to help improve Swift.\nThe open source Swift project uses GitHub Issues for tracking bugs.\n\n> [!NOTE]\n> If a bug can be reproduced only within an Xcode project or a playground, or if the bug is associated with an Apple NDA, please file a report to Apple’s [bug reporter](https://bugreport.apple.com/) instead.\n\nBecause Swift is under very active development, we receive a lot of bug reports.\nBefore opening a new issue, take a moment to [browse our existing issues](https://github.com/swiftlang/swift/issues) to reduce the chance of reporting a duplicate.\n\n## Good First Issues\n\nGood first issues are bugs, ideas, and tasks that are intended to be accessible for contributors that are new to working on the Swift project, and even new to the patterns and concepts behind subprojects such as the Swift compiler.\nGood first issues are decorated with a corresponding label and are most easily found by visiting https://github.com/swiftlang/swift/contribute.\nThey are expected to be low-priority and of modest scope, and not require excessive refactoring, research, or debugging — rather, they should encourage newcomers to dip their toes in some part of Swift, learn more about it, and make a real contribution.\n\nAnyone with [commit access](https://www.swift.org/contributing/#commit-access) and insight into a particular area is welcome and encouraged to pin down or think up good first issues.\n\n## Contributing Code\n\nIf you are interested in:\n\n- Contributing fixes and features to the compiler: See our\n  [How to Submit Your First Pull Request guide](/docs/HowToGuides/FirstPullRequest.md).\n- Building the compiler as a one-off: See our [Getting Started guide](/docs/HowToGuides/GettingStarted.md).\n\nWe also host answers to [Frequently Asked Questions](/docs/HowToGuides/FAQ.md) that may be of interest.\n\n### Proposing changes - Swift Evolution\n\nShaping the future of Swift is a community effort that anyone can participate in via the [Evolution sections on the Swift forums](https://www.swift.org/community/#swift-evolution).\nThe [Swift evolution process](https://github.com/swiftlang/swift-evolution/blob/main/process.md) covers all changes to the Swift language and the public interface of the Swift standard library, including new language features and APIs, changes to existing language features or APIs, removal of existing features, and so on.\n\nSee the [Swift evolution review schedule](https://www.swift.org/swift-evolution) for current and upcoming proposal reviews.\n\n### Incremental Development\n\nThe Swift project uses small, incremental changes as its preferred development model.\nSometimes these changes are small bug fixes.\nOther times, these changes are small steps along the path to reaching larger stated goals.\nIn contrast, long-term development branches can leave the community without a voice during development. Some additional problems with long-term branches include:\n\n- Resolving merge conflicts can take a lot of time if branch development and mainline development occur in the same pieces of code.\n- People in the community tend to ignore work on branches.\n- Very large changes are difficult to code review.\n- Branches are not routinely tested by the continuous integration infrastructure.\n\nTo address these problems, Swift uses an incremental development style. Small changes are preferred whenever possible.\nWe require contributors to follow this practice when making large or otherwise invasive changes. Some tips follow:\n\n- Large or invasive changes usually have secondary changes that must be made before the large change (for example, API cleanup or addition).\nCommit these changes before the major change, independently of that work.\n\n- If possible, decompose the remaining interrelated work into unrelated sets of changes.\nNext, define the first increment and get consensus on the development goal of the change.\n\n- Make each change in the set either stand alone (for example, to fix a bug) or part of a planned series of changes that work toward the development goal.\nExplaining these relationships to the community can be helpful.\n\nIf you are interested in making a large change and feel unsure about its overall effect, please make sure to first discuss the change and reach a consensus through the [Swift Forums](https://forums.swift.org).\nThen ask about the best way to go about making the change.\n\n### Commit Messages\n\nAlthough we don’t enforce a strict format for commit messages, we prefer that you follow the guidelines below, which are common among open source projects.\nFollowing these guidelines helps with the review process, searching commit logs, and email formatting.\nAt a high level, the contents of the commit message should be to convey the rationale of the change, without delving into much detail.\nFor example, “bits were not set right” leaves the reviewer wondering about which bits and why they weren’t “right”.\nIn contrast, “Correctly compute ‘is dependent type’ bits in ‘Type’” conveys almost all there is to the change.\n\nBelow are some guidelines about the format of the commit message itself:\n\n- Separate the commit message into a single-line title and a separate body that describes the change.\n- Make the title concise to be easily read within a commit log and to fit in the subject line of a commit email.\n- In changes that are restricted to a specific part of the code, include a [tag] at the start of the line in square brackets—for example, “[stdlib] …” or “[SILGen] …”.\nThis tag helps email filters and searches for post-commit reviews.\n- When there is a body, separate it from the title by an empty line.\n- Make body concise, while including the complete reasoning.\nUnless required to understand the change, additional code examples or other details should be left to bug comments or the mailing list.\n- If the commit fixes an issue in the bug tracking system, include a link to the issue in the message.\n- For text formatting and spelling, follow the same rules as documentation and in-code comments—for example, the use of capitalization and periods.\n- If the commit is a bug fix on top of another recently committed change, or a revert or reapply of a patch, include the Git revision number of the prior related commit, for example “Revert abcdef because it caused bug#”.\n\n\n\n### Attribution of Changes\n\nWhen contributors submit a change to a Swift subproject, after that change is approved, other developers with commit access may commit it for the author.\nWhen doing so, it is important to retain correct attribution of the contribution. Generally speaking, Git handles attribution automatically.\n\nWe do not want the source code to be littered with random attributions like “this code written by J. Random Hacker”, which is noisy and distracting.\nDo not add contributor names to the source code or documentation.\n\nIn addition, don’t commit changes authored by others unless they have submitted the change to the project or you have been authorized to submit on their behalf — for example, you work together and your company authorized you to contribute the changes.\n\n### Code Templates\n\nCode Templates\n\nThe license and copyright protections for Swift.org code are called out at the top of every source code file.\nIf you contribute a change that includes a new source file, ensure that the header is filled out appropriately.\n\nFor Swift source files the code header should look this:\n\n```swift\n//===----------------------------------------------------------------------===//\n//\n// This source file is part of the Swift.org open source project\n//\n// Copyright (c) 2024 Apple Inc. and the Swift project authors\n// Licensed under Apache License v2.0 with Runtime Library Exception\n//\n// See https://swift.org/LICENSE.txt for license information\n// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors\n//\n//===----------------------------------------------------------------------===//\n```\n\nFor C or C++ source or header files, the code header should look this:\n\n```c\n//===-- subfolder/Filename.h - Very brief description -----------*- C++ -*-===//\n//\n// This source file is part of the Swift.org open source project\n//\n// Copyright (c) 2024 Apple Inc. and the Swift project authors\n// Licensed under Apache License v2.0 with Runtime Library Exception\n//\n// See https://swift.org/LICENSE.txt for license information\n// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file contains stuff that I am describing here in the header and will\n/// be sure to keep up to date.\n///\n//===----------------------------------------------------------------------===//\n```\n\nThe divider lines should be exactly 80 characters wide to aid in adherence to the code style guidelines.\nThe bottom section contains an optional description intended for generated documentation (these lines begin with `///` rather than `//`).\nIf there is no description, this area can be skipped.\n\n### Code Review\n\nThe Swift project relies heavily on code review to improve software quality:\n\n- All significant changes, by all developers, must be reviewed before they are committed to the repository.\nSmaller changes (or changes where the developer owns the component) can be reviewed after being committed.\n- Code reviews are conducted on GitHub.\n- The developer responsible for a code change is also responsible for making all necessary review-related changes.\n\nCode review can be an iterative process, which continues until the change is ready to be merged.\nAfter a change is sent out for review it needs an explicit approval before it’s submitted.\nDo not assume silent approval or request active objections to the patch by setting a deadline.\n\nSometimes code reviews will take longer than you would hope for, especially for larger features.\nHere are some accepted ways to speed up review times for your patches:\n\n- **Review other people’s changes**. If you help out, everybody will be more willing to do the same for you. Goodwill is our currency.\n- **Split your change into multiple smaller changes**. The smaller your change, the higher the probability that somebody will take a quick look at it.\n- **Ping the change**. If it is urgent, provide reasons why it is important to get this change landed and ping it every couple of days.\nIf it is not urgent, the common courtesy ping rate is one week. Remember that you’re asking for valuable time from other professional developers.\n\nNote that anyone is welcome to review and give feedback on a change, but only people with commit access to the repository can approve it.\n\n### Testing\n\nDevelopers are required to create test cases for any bugs fixed and any new features added, and to contribute them along with the changes.\n\n- All feature and regression test cases are added to the appropriate test directory—for example, the `swift/test` directory.\n- Write test cases at the abstraction level nearest to the actual feature.\nFor example, if it’s a Swift language feature, write it in Swift; if it’s a SIL optimization, write it in SIL.\n- Reduce test cases as much as possible, especially for regressions.\nIt’s unacceptable to place an entire failing program into `swift/test` because this slows down testing for all developers.\nPlease keep them short.\n\n### Quality\n\nPeople depend on Swift to create their production software.\nThis means that a bug in Swift could cause bugs in thousands, even millions of developers’ products.\nBecause of this, the Swift project maintains a high bar for quality.\nThe minimum quality standards that any change must satisfy before being committed to the main development branch include:\n\n1. Code must compile without errors on all supported platforms and should be free of warnings on at least one platform.\n2. Bug fixes and new features must include a test case to pinpoint any future regressions, or include a justification for why a test case would be impractical.\n3. Code must pass the appropriate test suites—for example, the `swift/test` and `swift/validation-test` test suites in the Swift compiler.\n\nAdditionally, the committer is responsible for addressing any problems found in the future that the change may cause.\nThis responsibility means that you may need to update your change in order to:\n\n- Ensure the code compiles cleanly on all primary platforms.\n- Fix any correctness regressions found in other test suites.\n- Fix any major performance regressions.\n- Fix any performance or correctness regressions in the downstream Swift tools.\n- Fix any performance or correctness regressions that result in customer code that uses Swift.\n- Address any bugs that appear in the bug tracker as a result from your change.\n\nCommits that clearly violate these quality standards may be reverted, in particular when the change blocks other developers from making progress.\nThe developer is welcome to recommit the change after the problem has been fixed.\n\n### Release Branch Pull Requests\n\nA pull request targeting a release branch (`release/x.y` or `swift/release/x.y`) cannot be merged without a GitHub approval by a corresponding branch manager.\nIn order for a change to be considered for inclusion in a release branch, the pull request must have:\n\nA title starting with a designation containing the release version number of the target branch.\n\n[This form](https://github.com/swiftlang/.github/blob/main/PULL_REQUEST_TEMPLATE/release.md?plain=1) filled out in its description.\nAn item that is not applicable may be left blank or completed with an indication thereof, but must not be omitted altogether.\n\nTo switch to this template when drafting a pull request in a [swiftlang](https://github.com/swiftlang) repository in a browser, append the `template=release.md` query parameter to the current URL and refresh. For example:\n\n```diff\n-https://github.com/swiftlang/swift/compare/main...my-branch?quick_pull=1\n+https://github.com/swiftlang/swift/compare/main...my-branch?quick_pull=1&template=release.md\n```\n\n[Here](https://github.com/swiftlang/swift/pull/73697) is an example.\n\n### Commit Access\n\nCommit access is granted to contributors with a track record of submitting high-quality changes.\nIf you would like commit access, please send an email to [the code owners list](mailto:code-owners@forums.swift.org) with the GitHub user name that you want to use and a list of 5 non-trivial pull requests that were accepted without modifications.\n\nOnce you’ve been granted commit access, you will be able to commit to all of the GitHub repositories that host Swift.org projects.\nTo verify that your commit access works, please make a test commit (for example, change a comment or add a blank line). The following policies apply to users with commit access:\n\n- You are granted commit-after-approval to all parts of Swift.\nTo get approval, create a pull request. When the pull request is approved, you may merge it yourself.\n\n- You may commit an obvious change without first getting approval.\nThe community expects you to use good judgment.\nExamples are reverting obviously broken patches, correcting code comments, and other minor changes.\n\nMultiple violations of these policies or a single egregious violation may cause commit access to be revoked.\nEven with commit access, your changes are still subject to [code review](#code-review).\nOf course, you are also encouraged to review other peoples’ changes.\n\n### Adding External Library Dependencies\n\nThere may be times where it is appropriate for one of the Swift projects (compiler, Core Libraries, etc.) to make use of libraries that provide functionality on a given platform.\nAdding library dependencies impacts the portability of Swift projects, and may involve legal questions as well.\n\nAs a rule, all new library dependencies must be explicitly approved by the [Project lead](https://www.swift.org/community/#community-structure).\n\n## LLVM and Swift\n\nSwift is built on the [LLVM Compiler Infrastructure](http://llvm.org/).\nSwift uses the LLVM Core for code generation and optimization (among other things), [Clang](http://clang.llvm.org/) for interoperability with C and Objective-C, and [LLDB](http://lldb.llvm.org/) for debugging and the REPL.\n\nApple maintains a fork of the [LLVM Core](https://github.com/llvm/llvm-project) source repository on GitHub at [llvm-project](https://github.com/apple/llvm-project).\nThis repository track upstreams LLVM development and contains additional changes for Swift.\nThe upstream LLVM repository are merged into the Swift-specific repository frequently.\nEvery attempt is made to minimize the differences between upstream LLVM and the Apple fork to only those changes specifically required for Swift.\n\n### Where Do LLVM Changes Go?\n\nSwift follows a policy of making a change in the most upstream repository that is feasible.\nContributions to Swift that involve Apple’s version of LLVM Project should go directly into the upstream LLVM repository unless they are specific to Swift.\nFor example, an improvement to LLDB’s data formatters for a Swift type belongs in the Apple LLVM Project repository, whereas a bug fix to an LLVM optimizer—even if it’s only been observed when operating on Swift-generated LLVM IR—belongs in upstream LLVM.\n\nCommits to an upstream LLVM repository are automatically merged into the appropriate upstream branches in the corresponding Swift repository (`next`) in the [llvm-project](https://github.com/swiftlang/llvm-project).\n\n### Swift and LLVM Developer Policies\n\nContributions to [llvm-project clone](https://github.com/swiftlang/llvm-project) are governed by the [LLVM Developer Policy](http://llvm.org/docs/DeveloperPolicy.html) and should follow the appropriate [licensing](http://llvm.org/docs/DeveloperPolicy.html#copyright-license-and-patents) and [coding standards](http://llvm.org/docs/CodingStandards.html).\nIssues with LLVM code are tracked using the [LLVM bug database](https://github.com/llvm/llvm-project/issues).\nFor LLDB, changes to files with llvm.org comment headers must go to the [upstream LLDB at llvm.org](https://github.com/llvm/llvm-project/tree/main/lldb) and abide by the [LLVM Developer Policy](http://llvm.org/docs/DeveloperPolicy.html) and [LLDB coding conventions](https://llvm.org/docs/CodingStandards.html).\nContributions to the Swift-specific parts of LLDB (that is, those with a Swift.org comment header) use the [Swift license](https://www.swift.org/community/#license) but still follow the LLDB coding conventions.\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 11.48,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n    1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n    2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n    3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n    4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n    5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n    6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n    7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n    8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n    9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n    END OF TERMS AND CONDITIONS\n\n    APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n    Copyright [yyyy] [name of copyright owner]\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n\n\n## Runtime Library Exception to the Apache 2.0 License: ##\n\n\n    As an exception, if you use this Software to compile your source code and\n    portions of this Software are embedded into the binary product as a result,\n    you may redistribute such product without providing attribution as would\n    otherwise be required by Sections 4(a), 4(b) and 4(d) of the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.47,
          "content": "<picture>\n  <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://www.swift.org/assets/images/swift~dark.svg\">\n  <img src=\"https://www.swift.org/assets/images/swift.svg\" alt=\"Swift logo\" height=\"70\">\n</picture>\n\n# Swift Programming Language\n\n\n| | **Architecture** | **Build** |\n|---|:---:|:---:|\n| **macOS**        | x86_64 |[![Build Status](https://ci.swift.org/job/oss-swift-package-macos/lastCompletedBuild/badge/icon)](https://ci.swift.org/job/oss-swift-package-macos)|\n| **Ubuntu 20.04** | x86_64 |[![Build Status](https://ci.swift.org/job/oss-swift-package-ubuntu-20_04/lastCompletedBuild/badge/icon)](https://ci.swift.org/job/oss-swift-package-ubuntu-20_04)|\n| **Ubuntu 20.04** | AArch64 |[![Build Status](https://ci.swift.org/job/oss-swift-package-ubuntu-20_04-aarch64/lastCompletedBuild/badge/icon)](https://ci.swift.org/job/oss-swift-package-ubuntu-20_04-aarch64)|\n| **Ubuntu 22.04** | x86_64 |[![Build Status](https://ci.swift.org/job/oss-swift-package-ubuntu-22_04/lastCompletedBuild/badge/icon)](https://ci.swift.org/job/oss-swift-package-ubuntu-22_04)|\n| **Ubuntu 22.04** | AArch64 |[![Build Status](https://ci.swift.org/job/oss-swift-package-ubuntu-22_04-aarch64/lastCompletedBuild/badge/icon)](https://ci.swift.org/job/oss-swift-package-ubuntu-22_04-aarch64)|\n| **Ubuntu 24.04** | x86_64 |[![Build Status](https://ci.swift.org/job/oss-swift-package-ubuntu-24_04/lastCompletedBuild/badge/icon)](https://ci.swift.org/job/oss-swift-package-ubuntu-24_04)|\n| **Ubuntu 24.04** | AArch64 |[![Build Status](https://ci.swift.org/job/oss-swift-package-ubuntu-24_04-aarch64/lastCompletedBuild/badge/icon)](https://ci.swift.org/job/oss-swift-package-ubuntu-24_04-aarch64)|\n| **Amazon Linux 2** | x86_64 |[![Build Status](https://ci.swift.org/job/oss-swift-package-amazon-linux-2/lastCompletedBuild/badge/icon)](https://ci.swift.org/job/oss-swift-package-amazon-linux-2)|\n| **Amazon Linux 2** | AArch64 |[![Build Status](https://ci.swift.org/job/oss-swift-package-amazon-linux-2-aarch64/lastCompletedBuild/badge/icon)](https://ci.swift.org/job/oss-swift-package-amazon-linux-2-aarch64)|\n| **Universal Base Image 9** | x86_64 |[![Build Status](https://ci.swift.org/job/oss-swift-package-ubi-9/lastCompletedBuild/badge/icon)](https://ci.swift.org/job/oss-swift-package-ubi-9)|\n| **Debian 12** | x86_64 |[![Build Status](https://ci.swift.org/job/oss-swift-package-debian-12/lastCompletedBuild/badge/icon)](https://ci.swift.org/job/oss-swift-package-debian-12)|\n| **Debian 12** | AArch64 |[![Build Status](https://ci.swift.org/job/oss-swift-package-debian-12-aarch64/lastCompletedBuild/badge/icon)](https://ci.swift.org/job/oss-swift-package-debian-12-aarch64)|\n| **Fedora 39** | x86_64 |[![Build Status](https://ci.swift.org/job/oss-swift-package-fedora-39/lastCompletedBuild/badge/icon)](https://ci.swift.org/job/oss-swift-package-fedora-39)|\n| **Fedora 39** | AArch64 |[![Build Status](https://ci.swift.org/job/oss-swift-package-fedora-39-aarch64/lastCompletedBuild/badge/icon)](https://ci.swift.org/job/oss-swift-package-fedora-39-aarch64)|\n| **Windows 10** | x86_64 |[![Build Status](https://ci-external.swift.org/job/swift-main-windows-toolchain/lastCompletedBuild/badge/icon)](https://ci-external.swift.org/job/swift-main-windows-toolchain)|\n| **Windows 10** | ARM64 |[![Build Status](https://ci-external.swift.org/job/swift-main-windows-toolchain-arm64/lastCompletedBuild/badge/icon)](https://ci-external.swift.org/job/swift-main-windows-toolchain-arm64)|\n\n**Cross-Compilation Targets**\n\n| **Target** | **Build** |\n|:---:|:---:|\n| **wasm32-unknown-wasi** |[![Build Status](https://ci.swift.org/job/oss-swift-pr-test-crosscompile-wasm-ubuntu-20_04/lastCompletedBuild/badge/icon)](https://ci.swift.org/job/oss-swift-pr-test-crosscompile-wasm-ubuntu-20_04)|\n\n**Swift Community-Hosted CI Platforms**\n\n| **OS** | **Architecture** | **Build** |\n|---|:---:|:---:|\n|**[Android](https://github.com/apple/swift-community-hosted-continuous-integration/blob/main/nodes/x86_64_ubuntu_16_04_LTS_android.json)** | ARMv7 |[![Build Status](https://ci-external.swift.org/job/oss-swift-RA-linux-ubuntu-16.04-android/lastCompletedBuild/badge/icon)](https://ci-external.swift.org/job/oss-swift-RA-linux-ubuntu-16.04-android)|\n|**[Android](https://github.com/apple/swift-community-hosted-continuous-integration/blob/main/nodes/x86_64_ubuntu_16_04_LTS_android.json)** | AArch64 |[![Build Status](https://ci-external.swift.org/job/oss-swift-RA-linux-ubuntu-16.04-android-arm64/lastCompletedBuild/badge/icon)](https://ci-external.swift.org/job/oss-swift-RA-linux-ubuntu-16.04-android-arm64)|\n|**[Windows 2019 (VS 2019)](https://github.com/apple/swift-community-hosted-continuous-integration/blob/main/nodes/x86_64_windows_2019_VS2019.json)** | x86_64 | [![Build Status](https://ci-external.swift.org/job/oss-swift-windows-x86_64-vs2019/lastCompletedBuild/badge/icon)](https://ci-external.swift.org/job/oss-swift-windows-x86_64-vs2019)|\n\n## Welcome to Swift\n\nSwift is a high-performance system programming language.  It has a clean\nand modern syntax, offers seamless access to existing C and Objective-C code\nand frameworks, and is memory-safe by default.\n\nAlthough inspired by Objective-C and many other languages, Swift is not itself a\nC-derived language. As a complete and independent language, Swift packages core\nfeatures like flow control, data structures, and functions, with high-level\nconstructs like objects, protocols, closures, and generics. Swift embraces\nmodules, eliminating the need for headers and the code duplication they entail.\n\nTo learn more about the programming language, visit [swift.org](https://swift.org/documentation/).\n\n- [Contributing to Swift](#contributing-to-swift)\n- [Getting Started](#getting-started)\n  - [Swift Toolchains](#swift-toolchains)\n  - [Build Failures](#build-failures)\n- [Learning More](#learning-more)\n\n## Contributing to Swift\n\nContributions to Swift are welcomed and encouraged! Please see the\n[Contributing to Swift guide](https://swift.org/contributing/).\n\nBefore submitting the pull request, please make sure you have [tested your\n changes](https://github.com/apple/swift/blob/main/docs/ContinuousIntegration.md)\n and that they follow the Swift project [guidelines for contributing\n code](https://swift.org/contributing/#contributing-code).\n\nTo be a truly great community, [Swift.org](https://swift.org/) needs to welcome\ndevelopers from all walks of life, with different backgrounds, and with a wide\nrange of experience. A diverse and friendly community will have more great\nideas, more unique perspectives, and produce more great code. We will work\ndiligently to make the Swift community welcoming to everyone.\n\nTo give clarity of what is expected of our members, Swift has adopted the\ncode of conduct defined by the Contributor Covenant. This document is used\nacross many open source communities, and we think it articulates our values\nwell. For more, see the [Code of Conduct](https://swift.org/code-of-conduct/).\n\n## Getting Started\n\nIf you are interested in:\n- Contributing fixes and features to the compiler: See our\n  [How to Submit Your First Pull Request guide](/docs/HowToGuides/FirstPullRequest.md).\n- Building the compiler as a one-off: See our [Getting Started guide][].\n- Building a toolchain as a one-off: Follow the [Getting Started guide][]\n  up until the \"Building the project\" section. After that, follow the\n  instructions in the [Swift Toolchains](#swift-toolchains) section below.\n\nWe also have an [FAQ](/docs/HowToGuides/FAQ.md) that answers common questions.\n\n[Getting Started guide]: /docs/HowToGuides/GettingStarted.md\n\n### Swift Toolchains\n\n#### Building\n\nSwift toolchains are created using the script\n[build-toolchain](https://github.com/apple/swift/blob/main/utils/build-toolchain). This\nscript is used by swift.org's CI to produce snapshots and can allow for one to\nlocally reproduce such builds for development or distribution purposes. A typical \ninvocation looks like the following:\n\n```sh\n  $ ./swift/utils/build-toolchain $BUNDLE_PREFIX\n```\n\nwhere ``$BUNDLE_PREFIX`` is a string that will be prepended to the build \ndate to give the bundle identifier of the toolchain's ``Info.plist``. For \ninstance, if ``$BUNDLE_PREFIX`` was ``com.example``, the toolchain \nproduced will have the bundle identifier ``com.example.YYYYMMDD``. It \nwill be created in the directory you run the script with a filename \nof the form: ``swift-LOCAL-YYYY-MM-DD-a-osx.tar.gz``.\n\nBeyond building the toolchain, ``build-toolchain`` also supports the \nfollowing (non-exhaustive) set of useful options:\n\n- ``--dry-run``: Perform a dry run build. This is off by default.\n- ``--test``: Test the toolchain after it has been compiled. This is off by default.\n- ``--distcc``: Use distcc to speed up the build by distributing the C++ part of\n  the swift build. This is off by default.\n- ``--sccache``: Use sccache to speed up subsequent builds of the compiler by\n  caching more C++ build artifacts. This is off by default.\n\nMore options may be added over time. Please pass ``--help`` to\n``build-toolchain`` to see the full set of options.\n\n#### Installing into Xcode\n\nOn macOS if one wants to install such a toolchain into Xcode:\n\n1. Untar and copy the toolchain to one of `/Library/Developer/Toolchains/` or\n   `~/Library/Developer/Toolchains/`. E.g.:\n\n```sh\n  $ sudo tar -xzf swift-LOCAL-YYYY-MM-DD-a-osx.tar.gz -C /\n  $ tar -xzf swift-LOCAL-YYYY-MM-DD-a-osx.tar.gz -C ~/\n```\n\nThe script also generates an archive containing debug symbols which\ncan be installed over the main archive allowing symbolication of any\ncompiler crashes.\n\n```sh\n  $ sudo tar -xzf swift-LOCAL-YYYY-MM-DD-a-osx-symbols.tar.gz -C /\n  $ tar -xzf swift-LOCAL-YYYY-MM-DD-a-osx-symbols.tar.gz -C ~/\n```\n\n2. Specify the local toolchain for Xcode's use via `Xcode->Toolchains`.\n\n### Build Failures\n\nTry the suggestions in\n[Troubleshooting build issues](/docs/HowToGuides/GettingStarted.md#troubleshooting-build-issues).\n\nMake sure you are using the\n[correct release](/docs/HowToGuides/GettingStarted.md#installing-dependencies)\nof Xcode.\n\nIf you have changed Xcode versions but still encounter errors that appear to\nbe related to the Xcode version, try passing `--clean` to `build-script`.\n\nWhen a new version of Xcode is released, you can update your build without\nrecompiling the entire project by passing `--reconfigure` to `build-script`.\n\n## Learning More\n\nBe sure to look at the [documentation index](/docs/README.md) for a bird's eye\nview of the available documentation. In particular, the documents titled\n[Debugging the Swift Compiler](docs/DebuggingTheCompiler.md) and\n[Continuous Integration for Swift](docs/ContinuousIntegration.md) are very\nhelpful to understand before submitting your first PR.\n"
        },
        {
          "name": "Runtimes",
          "type": "tree",
          "content": null
        },
        {
          "name": "SwiftCompilerSources",
          "type": "tree",
          "content": null
        },
        {
          "name": "apinotes",
          "type": "tree",
          "content": null
        },
        {
          "name": "benchmark",
          "type": "tree",
          "content": null
        },
        {
          "name": "bindings",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "localization",
          "type": "tree",
          "content": null
        },
        {
          "name": "stdlib",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "unittests",
          "type": "tree",
          "content": null
        },
        {
          "name": "userdocs",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        },
        {
          "name": "validation-test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}