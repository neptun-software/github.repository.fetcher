{
  "metadata": {
    "timestamp": 1736557653766,
    "page": 748,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "kodecocodes/swift-algorithm-club",
      "stars": 28901,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.34,
          "content": "# Xcode\nbuild/\nDerivedData/\n\n*.pbxuser\n*.mode1v3\n*.mode2v3\n*.perspectivev3\n*.xccheckout\n*.moved-aside\n*.xcuserstate\n\nxcuserdata\n\n!default.pbxuser\n!default.mode1v3\n!default.mode2v3\n!default.perspectivev3\n!default.xcworkspace\n\nprofile\n*.hmap\n*.ipa\n\n# CocoaPods\nPods/\n!Podfile.lock\n\n# Temporary files\n.DS_Store\n.Trashes\n.Spotlight-V100\n*.swp\n*.lock\n"
        },
        {
          "name": ".swiftlint.yml",
          "type": "blob",
          "size": 0.49,
          "content": "cyclomatic_complexity: 12\nfile_length: 550\nfunction_body_length: 80\nfunction_parameter_count: 8\nline_length: 150\ntype_body_length: 300\nvariable_name:\n  min_length:\n    error: 1\n    warning: 1\n  excluded:\n    - N\n\ndisabled_rules:\n  - valid_docs\n\ncustom_rules:\n  smiley_face:\n    name: \"Smiley Face\"\n    regex: '( :\\))'\n    match_kinds:\n      - comment\n      - string\n    message: \"A closing parenthesis smiley :) creates a half-hearted smile, and thus is not preferred. Use :]\"\n    severity: warning\n"
        },
        {
          "name": "3Sum and 4Sum",
          "type": "tree",
          "content": null
        },
        {
          "name": "A-Star",
          "type": "tree",
          "content": null
        },
        {
          "name": "AVL Tree",
          "type": "tree",
          "content": null
        },
        {
          "name": "Algorithm Design.markdown",
          "type": "blob",
          "size": 1.88,
          "content": "# Algorithm design techniques\n\nWhat to do when you're faced with a new problem and you need to find an algorithm for it.\n\n### Is it similar to another problem?\n\nIf you can frame your problem in terms of another, more general problem, then you might be able to use an existing algorithm. Why reinvent the wheel?\n\nOne thing I like about [The Algorithm Design Manual](http://www.algorist.com) by Steven Skiena is that it includes a catalog of problems and solutions you can try. (See also his [algorithm repository](http://www3.cs.stonybrook.edu/~algorith/).)\n\n### It's OK to start with brute force\n\nNaive, brute force solutions are often too slow for practical use but they're a good starting point. By writing the brute force solution, you learn to understand what the problem is really all about.\n\nOnce you have a brute force implementation you can use that to verify that any improvements you come up with are correct. \n\nAnd if you only work with small datasets, then a brute force approach may actually be good enough on its own. Don't fall into the trap of premature optimization!\n\n### Divide and conquer\n\n>\"When you change the way you look at things, the things you look at change.\"</br>\n>Max Planck, Quantum theorist and Nobel Prize Winner\n\nDivide and conquer is a way of dealing with a large problem by breaking it down into bits and pieces and working your way up towards the solution.\n\nInstead of seeing the whole problem as a single, huge and complex task you divide the problem in relatively smaller problems that are easier to understand and deal with.\n\nYou solve smaller problems and aggregate the solution until you are left with the solution only. At each step the problem at hand shrinks and the solution gets mature until you have the final correct solution.\n\nSolving the smaller task and applying the same solution repetitively ( or often times recursively) to other chunks give you the result in less time.\n"
        },
        {
          "name": "All-Pairs Shortest Paths",
          "type": "tree",
          "content": null
        },
        {
          "name": "Array2D",
          "type": "tree",
          "content": null
        },
        {
          "name": "B-Tree",
          "type": "tree",
          "content": null
        },
        {
          "name": "Big-O Notation.markdown",
          "type": "blob",
          "size": 6.03,
          "content": "# A note on Big-O notation\n\nIt's useful to know how fast an algorithm is and how much space it needs. This allows you to pick the right algorithm for the job.\n\nBig-O notation gives you a rough indication of the running time of an algorithm and the amount of memory it uses. When someone says, \"This algorithm has worst-case running time of **O(n^2)** and uses **O(n)** space,\" they mean it's kinda slow but doesn't need lots of extra memory.\n\nFiguring out the Big-O of an algorithm is usually done through mathematical analysis. We're skipping the math here, but it's useful to know what the different values mean, so here's a handy table. **n** refers to the number of data items that you're processing. For example, when sorting an array of 100 items, **n = 100**.\n\nBig-O | Name | Description\n------| ---- | -----------\n**O(1)** | constant | **This is the best.** The algorithm always takes the same amount of time, regardless of how much data there is. Example: looking up an element of an array by its index.\n**O(log n)** | logarithmic | **Pretty great.** These kinds of algorithms halve the amount of data with each iteration. If you have 100 items, it takes about 7 steps to find the answer. With 1,000 items, it takes 10 steps. And 1,000,000 items only take 20 steps. This is super fast even for large amounts of data. Example: binary search.\n**O(n)** | linear | **Good performance.** If you have 100 items, this does 100 units of work. Doubling the number of items makes the algorithm take exactly twice as long (200 units of work). Example: sequential search.\n**O(n log n)** | \"linearithmic\" | **Decent performance.** This is slightly worse than linear but not too bad. Example: the fastest general-purpose sorting algorithms.\n**O(n^2)** | quadratic | **Kinda slow.** If you have 100 items, this does 100^2 = 10,000 units of work. Doubling the number of items makes it four times slower (because 2 squared equals 4). Example: algorithms using nested loops, such as insertion sort.\n**O(n^3)** | cubic | **Poor performance.** If you have 100 items, this does 100^3 = 1,000,000 units of work. Doubling the input size makes it eight times slower. Example: matrix multiplication.\n**O(2^n)** | exponential | **Very poor performance.** You want to avoid these kinds of algorithms, but sometimes you have no choice. Adding just one bit to the input doubles the running time. Example: traveling salesperson problem.\n**O(n!)** | factorial | **Intolerably slow.** It literally takes a million years to do anything.  \n\n\n\n![Comparison of Big O computations](https://upload.wikimedia.org/wikipedia/commons/7/7e/Comparison_computational_complexity.svg)\n\n\n\nBelow are some examples for each category of performance:\n\n**O(1)**\n\n  The most common example with O(1) complexity is accessing an array index.\n\n  ```swift\n  let value = array[5]\n  ```\n\n  Another example of O(1) is pushing and popping from Stack.\n\n\n**O(log n)**\n\n  ```swift\n  var j = 1\n  while j < n {\n    // do constant time stuff\n    j *= 2\n  }\n  ```  \n\n  Instead of simply incrementing, 'j' is increased by 2 times itself in each run.\n\n  Binary Search Algorithm is an example of O(log n) complexity.\n\n\n**O(n)**\n\n  ```swift\n  for i in stride(from: 0, to: n, by: 1) {\n    print(array[i])\n  }\n  ```\n\n  Array Traversal and Linear Search are examples of O(n) complexity.  \n\n\n**O(n log n)**\n\n  ```swift\n  for i in stride(from: 0, to: n, by: 1) {\n  var j = 1\n    while j < n {\n      j *= 2\n      // do constant time stuff\n    }\n  }\n  ```\n\n  OR\n\n  ```swift\n  for i in stride(from: 0, to: n, by: 1) {\n    func index(after i: Int) -> Int? { // multiplies `i` by 2 until `i` >= `n`\n      return i < n ? i * 2 : nil\n    }\n    for j in sequence(first: 1, next: index(after:)) {\n      // do constant time stuff\n    }\n  }\n  ```\n\n  Merge Sort and Heap Sort are examples of O(n log n) complexity.  \n\n\n**O(n^2)**\n\n  ```swift\n  for i  in stride(from: 0, to: n, by: 1) {\n    for j in stride(from: 1, to: n, by: 1) {\n      // do constant time stuff\n    }\n  }\n  ```\n\n  Traversing a simple 2-D array and Bubble Sort are examples of O(n^2) complexity.\n\n\n**O(n^3)**\n\n  ```swift\n  for i in stride(from: 0, to: n, by: 1) {\n    for j in stride(from: 1, to: n, by: 1) {\n      for k in stride(from: 1, to: n, by: 1) {\n        // do constant time stuff\n      }\n    }\n  }\n  ```  \n\n**O(2^n)**\n\n  Algorithms with running time O(2^N) are often recursive algorithms that solve a problem of size N by recursively solving two smaller problems of size N-1.\n  The following example prints all the moves necessary to solve the famous \"Towers of Hanoi\" problem for N disks.\n\n  ```swift\n  func solveHanoi(n: Int, from: String, to: String, spare: String) {\n    guard n >= 1 else { return }\n    if n > 1 {\n        solveHanoi(n: n - 1, from: from, to: spare, spare: to)\n        solveHanoi(n: n - 1, from: spare, to: to, spare: from)\n    }\n  }\n  ```\n\n\n**O(n!)**\n\n  The most trivial example of function that takes O(n!) time is given below.\n\n  ```swift\n  func nFactFunc(n: Int) {\n    for i in stride(from: 0, to: n, by: 1) {\n      nFactFunc(n: n - 1)\n    }\n  }\n  ```\n\nOften you don't need math to figure out what the Big-O of an algorithm is but you can simply use your intuition. If your code uses a single loop that looks at all **n** elements of your input, the algorithm is **O(n)**. If the code has two nested loops, it is **O(n^2)**. Three nested loops gives **O(n^3)**, and so on.\n\nNote that Big-O notation is an estimate and is only really useful for large values of **n**. For example, the worst-case running time for the [insertion sort](Insertion%20Sort/) algorithm is **O(n^2)**. In theory that is worse than the running time for [merge sort](Merge%20Sort/), which is **O(n log n)**. But for small amounts of data, insertion sort is actually faster, especially if the array is partially sorted already!\n\nIf you find this confusing, don't let this Big-O stuff bother you too much. It's mostly useful when comparing two algorithms to figure out which one is better. But in the end you still want to test in practice which one really is the best. And if the amount of data is relatively small, then even a slow algorithm will be fast enough for practical use.\n"
        },
        {
          "name": "Binary Search Tree",
          "type": "tree",
          "content": null
        },
        {
          "name": "Binary Search",
          "type": "tree",
          "content": null
        },
        {
          "name": "Binary Tree",
          "type": "tree",
          "content": null
        },
        {
          "name": "Bit Set",
          "type": "tree",
          "content": null
        },
        {
          "name": "Bloom Filter",
          "type": "tree",
          "content": null
        },
        {
          "name": "Bounded Priority Queue",
          "type": "tree",
          "content": null
        },
        {
          "name": "Boyer-Moore-Horspool",
          "type": "tree",
          "content": null
        },
        {
          "name": "Breadth-First Search",
          "type": "tree",
          "content": null
        },
        {
          "name": "Brute-Force String Search",
          "type": "tree",
          "content": null
        },
        {
          "name": "Bubble Sort",
          "type": "tree",
          "content": null
        },
        {
          "name": "Bucket Sort",
          "type": "tree",
          "content": null
        },
        {
          "name": "Closest Pair",
          "type": "tree",
          "content": null
        },
        {
          "name": "Comb Sort",
          "type": "tree",
          "content": null
        },
        {
          "name": "Combinatorics",
          "type": "tree",
          "content": null
        },
        {
          "name": "Convex Hull",
          "type": "tree",
          "content": null
        },
        {
          "name": "Count Occurrences",
          "type": "tree",
          "content": null
        },
        {
          "name": "CounterClockWise",
          "type": "tree",
          "content": null
        },
        {
          "name": "Counting Sort",
          "type": "tree",
          "content": null
        },
        {
          "name": "Depth-First Search",
          "type": "tree",
          "content": null
        },
        {
          "name": "Deque",
          "type": "tree",
          "content": null
        },
        {
          "name": "Dijkstra Algorithm",
          "type": "tree",
          "content": null
        },
        {
          "name": "DiningPhilosophers",
          "type": "tree",
          "content": null
        },
        {
          "name": "Egg Drop Problem",
          "type": "tree",
          "content": null
        },
        {
          "name": "Encode and Decode Tree",
          "type": "tree",
          "content": null
        },
        {
          "name": "Fixed Size Array",
          "type": "tree",
          "content": null
        },
        {
          "name": "Fizz Buzz",
          "type": "tree",
          "content": null
        },
        {
          "name": "GCD",
          "type": "tree",
          "content": null
        },
        {
          "name": "Genetic",
          "type": "tree",
          "content": null
        },
        {
          "name": "Graph",
          "type": "tree",
          "content": null
        },
        {
          "name": "Hash Set",
          "type": "tree",
          "content": null
        },
        {
          "name": "Hash Table",
          "type": "tree",
          "content": null
        },
        {
          "name": "Hashed Heap",
          "type": "tree",
          "content": null
        },
        {
          "name": "HaversineDistance",
          "type": "tree",
          "content": null
        },
        {
          "name": "Heap Sort",
          "type": "tree",
          "content": null
        },
        {
          "name": "Heap",
          "type": "tree",
          "content": null
        },
        {
          "name": "Huffman Coding",
          "type": "tree",
          "content": null
        },
        {
          "name": "Images",
          "type": "tree",
          "content": null
        },
        {
          "name": "Insertion Sort",
          "type": "tree",
          "content": null
        },
        {
          "name": "Introsort",
          "type": "tree",
          "content": null
        },
        {
          "name": "K-Means",
          "type": "tree",
          "content": null
        },
        {
          "name": "Karatsuba Multiplication",
          "type": "tree",
          "content": null
        },
        {
          "name": "Knuth-Morris-Pratt",
          "type": "tree",
          "content": null
        },
        {
          "name": "Kth Largest Element",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.07,
          "content": "Copyright (c) 2016 Matthijs Hollemans and contributors\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n"
        },
        {
          "name": "LRU Cache",
          "type": "tree",
          "content": null
        },
        {
          "name": "Linear Regression",
          "type": "tree",
          "content": null
        },
        {
          "name": "Linear Search",
          "type": "tree",
          "content": null
        },
        {
          "name": "Linked List",
          "type": "tree",
          "content": null
        },
        {
          "name": "Longest Common Subsequence",
          "type": "tree",
          "content": null
        },
        {
          "name": "Merge Sort",
          "type": "tree",
          "content": null
        },
        {
          "name": "Miller-Rabin Primality Test",
          "type": "tree",
          "content": null
        },
        {
          "name": "Minimum Edit Distance",
          "type": "tree",
          "content": null
        },
        {
          "name": "Minimum Spanning Tree (Unweighted)",
          "type": "tree",
          "content": null
        },
        {
          "name": "Minimum Spanning Tree",
          "type": "tree",
          "content": null
        },
        {
          "name": "MinimumCoinChange",
          "type": "tree",
          "content": null
        },
        {
          "name": "Monty Hall Problem",
          "type": "tree",
          "content": null
        },
        {
          "name": "Multiset",
          "type": "tree",
          "content": null
        },
        {
          "name": "Myers Difference Algorithm",
          "type": "tree",
          "content": null
        },
        {
          "name": "Naive Bayes Classifier",
          "type": "tree",
          "content": null
        },
        {
          "name": "Octree",
          "type": "tree",
          "content": null
        },
        {
          "name": "Ordered Array",
          "type": "tree",
          "content": null
        },
        {
          "name": "Ordered Set",
          "type": "tree",
          "content": null
        },
        {
          "name": "Palindromes",
          "type": "tree",
          "content": null
        },
        {
          "name": "Points Lines Planes",
          "type": "tree",
          "content": null
        },
        {
          "name": "Priority Queue",
          "type": "tree",
          "content": null
        },
        {
          "name": "QuadTree",
          "type": "tree",
          "content": null
        },
        {
          "name": "Queue",
          "type": "tree",
          "content": null
        },
        {
          "name": "Quicksort",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.markdown",
          "type": "blob",
          "size": 13.97,
          "content": "![Swift Algorithm Club](Images/SwiftAlgorithm-410-transp.png)\n\n# Welcome to the Swift Algorithm Club!\n\nHere you'll find implementations of popular algorithms and data structures in everyone's favorite new language Swift, with detailed explanations of how they work.\n\nIf you're a computer science student who needs to learn this stuff for exams -- or if you're a self-taught programmer who wants to brush up on the theory behind your craft -- you've come to the right place!\n\nThe goal of this project is to **explain how algorithms work**. The focus is on clarity and readability of the code, not on making a reusable library that you can drop into your own projects. That said, most of the code should be ready for production use but you may need to tweak it to fit into your own codebase.\n\nCode is compatible with **Xcode 10** and **Swift 4.2**. We'll keep this updated with the latest version of Swift. If you're interested in a GitHub pages version of the repo, check out [this](https://aquarchitect.github.io/swift-algorithm-club/).\n\n:heart_eyes: **Suggestions and contributions are welcome!** :heart_eyes:\n\n## Important links\n\n[What are algorithms and data structures?](What%20are%20Algorithms.markdown) Pancakes!\n\n[Why learn algorithms?](Why%20Algorithms.markdown) Worried this isn't your cup of tea? Then read this.\n\n[Big-O notation](Big-O%20Notation.markdown). We often say things like, \"This algorithm is **O(n)**.\" If you don't know what that means, read this first.\n\n[Algorithm design techniques](Algorithm%20Design.markdown). How do you create your own algorithms?\n\n[How to contribute](https://github.com/raywenderlich/swift-algorithm-club/blob/master/.github/CONTRIBUTING.md). Report an issue to leave feedback, or submit a pull request.\n\n## Where to start?\n\nIf you're new to algorithms and data structures, here are a few good ones to start out with:\n\n- [Stack](Stack/)\n- [Queue](Queue/)\n- [Insertion Sort](Insertion%20Sort/)\n- [Binary Search](Binary%20Search/) and [Binary Search Tree](Binary%20Search%20Tree/)\n- [Merge Sort](Merge%20Sort/)\n- [Boyer-Moore string search](Boyer-Moore-Horspool/)\n\n## The algorithms\n\n### Searching\n\n- [Linear Search](Linear%20Search/). Find an element in an array.\n- [Binary Search](Binary%20Search/). Quickly find elements in a sorted array.\n- [Count Occurrences](Count%20Occurrences/). Count how often a value appears in an array.\n- [Select Minimum / Maximum](Select%20Minimum%20Maximum). Find the minimum/maximum value in an array.\n- [k-th Largest Element](Kth%20Largest%20Element/). Find the *k*-th largest element in an array, such as the median.\n- [Selection Sampling](Selection%20Sampling/). Randomly choose a bunch of items from a collection.\n- [Union-Find](Union-Find/). Keeps track of disjoint sets and lets you quickly merge them.\n\n\n### String Search\n\n- [Brute-Force String Search](Brute-Force%20String%20Search/). A naive method.\n- [Boyer-Moore](Boyer-Moore-Horspool/). A fast method to search for substrings. It skips ahead based on a look-up table, to avoid looking at every character in the text.\n- [Knuth-Morris-Pratt](Knuth-Morris-Pratt/). A linear-time string algorithm that returns indexes of all occurrencies of a given pattern.\n- [Rabin-Karp](Rabin-Karp/)  Faster search by using hashing.\n- [Longest Common Subsequence](Longest%20Common%20Subsequence/). Find the longest sequence of characters that appear in the same order in both strings.\n- [Z-Algorithm](Z-Algorithm/). Finds all instances of a pattern in a String, and returns the indexes of where the pattern starts within the String.\n\n### Sorting\n\nIt's fun to see how sorting algorithms work, but in practice you'll almost never have to provide your own sorting routines. Swift's own `sort()` is more than up to the job. But if you're curious, read on...\n\nBasic sorts:\n\n- [Insertion Sort](Insertion%20Sort/)\n- [Selection Sort](Selection%20Sort/)\n- [Shell Sort](Shell%20Sort/)\n\nFast sorts:\n\n- [Quicksort](Quicksort/)\n- [Merge Sort](Merge%20Sort/)\n- [Heap Sort](Heap%20Sort/)\n\nHybrid sorts:\n\n- [Introsort](Introsort/)\n\nSpecial-purpose sorts:\n\n- [Counting Sort](Counting%20Sort/)\n- [Radix Sort](Radix%20Sort/)\n- [Topological Sort](Topological%20Sort/)\n\nBad sorting algorithms (don't use these!):\n\n- [Bubble Sort](Bubble%20Sort/)\n- [Slow Sort](Slow%20Sort/)\n\n### Compression\n\n- [Run-Length Encoding (RLE)](Run-Length%20Encoding/). Store repeated values as a single byte and a count.\n- [Huffman Coding](Huffman%20Coding/). Store more common elements using a smaller number of bits.\n\n### Miscellaneous\n\n- [Shuffle](Shuffle/). Randomly rearranges the contents of an array.\n- [Comb Sort](Comb%20Sort/). An improve upon the Bubble Sort algorithm.\n- [Convex Hull](Convex%20Hull/).\n- [Miller-Rabin Primality Test](Miller-Rabin%20Primality%20Test/). Is the number a prime number?\n- [MinimumCoinChange](MinimumCoinChange/). A showcase for dynamic programming.\n- [Genetic](Genetic/). A simple example on how to slowly mutate a value to its ideal form, in the context of biological evolution.\n- [Myers Difference Algorithm](Myers%20Difference%20Algorithm/). Finding the longest common subsequence of two sequences.\n### Mathematics\n\n- [Greatest Common Divisor (GCD)](GCD/). Special bonus: the least common multiple.\n- [Permutations and Combinations](Combinatorics/). Get your combinatorics on!\n- [Shunting Yard Algorithm](Shunting%20Yard/). Convert infix expressions to postfix.\n- [Karatsuba Multiplication](Karatsuba%20Multiplication/). Another take on elementary multiplication.\n- [Haversine Distance](HaversineDistance/). Calculating the distance between 2 points from a sphere.\n- [Strassen's Multiplication Matrix](Strassen%20Matrix%20Multiplication/). Efficient way to handle matrix multiplication.\n- [CounterClockWise](/CounterClockWise/). Determining the area of a simple polygon.\n\n### Machine learning\n\n- [k-Means Clustering](K-Means/). Unsupervised classifier that partitions data into *k* clusters.\n- k-Nearest Neighbors\n- [Linear Regression](Linear%20Regression/). A technique for creating a model of the relationship between two (or more) variable quantities.\n- Logistic Regression\n- Neural Networks\n- PageRank\n- [Naive Bayes Classifier](Naive%20Bayes%20Classifier/)\n- [Simulated annealing](Simulated%20annealing/). Probabilistic technique for approximating the global maxima in a (often discrete) large search space.\n\n## Data structures\n\nThe choice of data structure for a particular task depends on a few things.\n\nFirst, there is the shape of your data and the kinds of operations that you'll need to perform on it. If you want to look up objects by a key you need some kind of dictionary; if your data is hierarchical in nature you want a tree structure of some sort; if your data is sequential you want a stack or queue.\n\nSecond, it matters what particular operations you'll be performing most, as certain data structures are optimized for certain actions. For example, if you often need to find the most important object in a collection, then a heap or priority queue is more optimal than a plain array.\n\nMost of the time using just the built-in `Array`, `Dictionary`, and `Set` types is sufficient, but sometimes you may want something more fancy...\n\n### Variations on arrays\n\n- [Array2D](Array2D/). A two-dimensional array with fixed dimensions. Useful for board games.\n- [Bit Set](Bit%20Set/). A fixed-size sequence of *n* bits.\n- [Fixed Size Array](Fixed%20Size%20Array/). When you know beforehand how large your data will be, it might be more efficient to use an old-fashioned array with a fixed size.\n- [Ordered Array](Ordered%20Array/). An array that is always sorted.\n- [Rootish Array Stack](Rootish%20Array%20Stack/). A space and time efficient variation on Swift arrays.\n\n### Queues\n\n- [Stack](Stack/). Last-in, first-out!\n- [Queue](Queue/). First-in, first-out!\n- [Deque](Deque/). A double-ended queue.\n- [Priority Queue](Priority%20Queue). A queue where the most important element is always at the front.\n- [Ring Buffer](Ring%20Buffer/). Also known as a circular buffer. An array of a certain size that conceptually wraps around back to the beginning.\n\n### Lists\n\n- [Linked List](Linked%20List/). A sequence of data items connected through links. Covers both singly and doubly linked lists.\n- [Skip-List](Skip-List/). Skip List is a probabilistic data-structure with same logarithmic time bound and efficiency as AVL/ or Red-Black tree and provides a clever compromise to efficiently support search and update operations.\n\n### Trees\n\n- [Tree](Tree/). A general-purpose tree structure.\n- [Binary Tree](Binary%20Tree/). A tree where each node has at most two children.\n- [Binary Search Tree (BST)](Binary%20Search%20Tree/). A binary tree that orders its nodes in a way that allows for fast queries.\n- [Red-Black Tree](Red-Black%20Tree/). A self balancing binary search tree.\n- [Splay Tree](Splay%20Tree/). A self balancing binary search tree that enables fast retrieval of recently updated elements.\n- [Threaded Binary Tree](Threaded%20Binary%20Tree/). A binary tree that maintains a few extra variables for cheap and fast in-order traversals.\n- [Segment Tree](Segment%20Tree/). Can quickly compute a function over a portion of an array.\n  - [Lazy Propagation](https://github.com/raywenderlich/swift-algorithm-club/tree/master/Segment%20Tree/LazyPropagation)\n- kd-Tree\n- [Sparse Table](Sparse%20Table/). Another take on quickly computing a function over a portion of an array, but this time we'll make it even quicker!.\n- [Heap](Heap/). A binary tree stored in an array, so it doesn't use pointers. Makes a great priority queue.\n- Fibonacci Heap\n- [Trie](Trie/). A special type of tree used to store associative data structures.\n- [B-Tree](B-Tree/). A self-balancing search tree, in which nodes can have more than two children.\n- [QuadTree](QuadTree/). A tree with 4 children.\n- [Octree](Octree/). A tree with 8 children.\n\n### Hashing\n\n- [Hash Table](Hash%20Table/). Allows you to store and retrieve objects by a key. This is how the dictionary type is usually implemented.\n- Hash Functions\n\n### Sets\n\n- [Bloom Filter](Bloom%20Filter/). A constant-memory data structure that probabilistically tests whether an element is in a set.\n- [Hash Set](Hash%20Set/). A set implemented using a hash table.\n- [Multiset](Multiset/). A set where the number of times an element is added matters. (Also known as a bag.)\n- [Ordered Set](Ordered%20Set/). A set where the order of items matters.\n\n### Graphs\n\n- [Graph](Graph/)\n- [Breadth-First Search (BFS)](Breadth-First%20Search/)\n- [Depth-First Search (DFS)](Depth-First%20Search/)\n- [Shortest Path](Shortest%20Path%20%28Unweighted%29/) on an unweighted tree\n- [Single-Source Shortest Paths](Single-Source%20Shortest%20Paths%20(Weighted)/)\n- [Minimum Spanning Tree](Minimum%20Spanning%20Tree%20%28Unweighted%29/) on an unweighted tree\n- [Minimum Spanning Tree](Minimum%20Spanning%20Tree/)\n- [All-Pairs Shortest Paths](All-Pairs%20Shortest%20Paths/)\n- [Dijkstra's shortest path algorithm](Dijkstra%20Algorithm/)\n- [A-Star](A-Star/)\n\n## Puzzles\n\nA lot of software developer interview questions consist of algorithmic puzzles. Here is a small selection of fun ones. For more puzzles (with answers), see [here](http://elementsofprogramminginterviews.com/) and [here](http://www.crackingthecodinginterview.com).\n\n- [Two-Sum Problem](Two-Sum%20Problem/)\n- [Three-Sum/Four-Sum Problem](3Sum%20and%204Sum/)\n- [Fizz Buzz](Fizz%20Buzz/)\n- [Monty Hall Problem](Monty%20Hall%20Problem/)\n- [Finding Palindromes](Palindromes/)\n- [Dining Philosophers](DiningPhilosophers/)\n- [Egg Drop Problem](Egg%20Drop%20Problem/)\n- [Encoding and Decoding Binary Tree](Encode%20and%20Decode%20Tree/)\n- [Closest Pair](Closest%20Pair/)\n\n## Learn more!\n\nLike what you see? Check out [Data Structures & Algorithms in Swift](https://store.raywenderlich.com/products/data-structures-and-algorithms-in-swift), the official book by the Swift Algorithm Club team!\n\n![Data Structures & Algorithms in Swift Book](Images/DataStructuresAndAlgorithmsInSwiftBook.png)\n\nYou’ll start with the fundamental structures of linked lists, queues and stacks, and see how to implement them in a highly Swift-like way. Move on to working with various types of trees, including general purpose trees, binary trees, AVL trees, binary search trees, and tries. \n\nGo beyond bubble and insertion sort with better-performing algorithms, including mergesort, radix sort, heap sort, and quicksort. Learn how to construct directed, non-directed and weighted graphs to represent many real-world models, and traverse graphs and trees efficiently with breadth-first, depth-first, Dijkstra’s and Prim’s algorithms to solve problems such as finding the shortest path or lowest cost in a network.\n\nBy the end of this book, you’ll have hands-on experience solving common issues with data structures and algorithms — and you’ll be well on your way to developing your own efficient and useful implementations!\n\nYou can find the book on the [raywenderlich.com store](https://store.raywenderlich.com/products/data-structures-and-algorithms-in-swift).\n\n## Credits\n\nThe Swift Algorithm Club was originally created by [Matthijs Hollemans](https://github.com/hollance).\n\nIt is now maintained by [Vincent Ngo](https://www.raywenderlich.com/u/jomoka), [Kelvin Lau](https://github.com/kelvinlauKL), and [Richard Ash](https://github.com/richard-ash).\n\nThe Swift Algorithm Club is a collaborative effort from the [most algorithmic members](https://github.com/raywenderlich/swift-algorithm-club/graphs/contributors) of the [raywenderlich.com](https://www.raywenderlich.com) community. We're always looking for help - why not [join the club](.github/CONTRIBUTING.md)? :]\n\n## License\n\nAll content is licensed under the terms of the MIT open source license.\n\nBy posting here, or by submitting any pull request through this forum, you agree that all content you submit or create, both code and text, is subject to this license.  Razeware, LLC, and others will have all the rights described in the license regarding this content.  The precise terms of this license may be found [here](https://github.com/raywenderlich/swift-algorithm-club/blob/master/LICENSE.txt).\n\n[![Build Status](https://travis-ci.org/raywenderlich/swift-algorithm-club.svg?branch=master)](https://travis-ci.org/raywenderlich/swift-algorithm-club)\n"
        },
        {
          "name": "Rabin-Karp",
          "type": "tree",
          "content": null
        },
        {
          "name": "Radix Sort",
          "type": "tree",
          "content": null
        },
        {
          "name": "Radix Tree",
          "type": "tree",
          "content": null
        },
        {
          "name": "Red-Black Tree",
          "type": "tree",
          "content": null
        },
        {
          "name": "Ring Buffer",
          "type": "tree",
          "content": null
        },
        {
          "name": "Rootish Array Stack",
          "type": "tree",
          "content": null
        },
        {
          "name": "Run-Length Encoding",
          "type": "tree",
          "content": null
        },
        {
          "name": "Segment Tree",
          "type": "tree",
          "content": null
        },
        {
          "name": "Select Minimum Maximum",
          "type": "tree",
          "content": null
        },
        {
          "name": "Selection Sampling",
          "type": "tree",
          "content": null
        },
        {
          "name": "Selection Sort",
          "type": "tree",
          "content": null
        },
        {
          "name": "Set Cover (Unweighted)",
          "type": "tree",
          "content": null
        },
        {
          "name": "Shell Sort",
          "type": "tree",
          "content": null
        },
        {
          "name": "Shortest Path (Unweighted)",
          "type": "tree",
          "content": null
        },
        {
          "name": "Shuffle",
          "type": "tree",
          "content": null
        },
        {
          "name": "Shunting Yard",
          "type": "tree",
          "content": null
        },
        {
          "name": "Simulated annealing",
          "type": "tree",
          "content": null
        },
        {
          "name": "Single-Source Shortest Paths (Weighted)",
          "type": "tree",
          "content": null
        },
        {
          "name": "Singly Linked List",
          "type": "tree",
          "content": null
        },
        {
          "name": "Skip-List",
          "type": "tree",
          "content": null
        },
        {
          "name": "Slow Sort",
          "type": "tree",
          "content": null
        },
        {
          "name": "Sorted Set",
          "type": "tree",
          "content": null
        },
        {
          "name": "Sparse Table",
          "type": "tree",
          "content": null
        },
        {
          "name": "Splay Tree",
          "type": "tree",
          "content": null
        },
        {
          "name": "Stack",
          "type": "tree",
          "content": null
        },
        {
          "name": "Strassen Matrix Multiplication",
          "type": "tree",
          "content": null
        },
        {
          "name": "Ternary Search Tree",
          "type": "tree",
          "content": null
        },
        {
          "name": "Threaded Binary Tree",
          "type": "tree",
          "content": null
        },
        {
          "name": "Topological Sort",
          "type": "tree",
          "content": null
        },
        {
          "name": "Treap",
          "type": "tree",
          "content": null
        },
        {
          "name": "Tree",
          "type": "tree",
          "content": null
        },
        {
          "name": "Trie",
          "type": "tree",
          "content": null
        },
        {
          "name": "Two-Sum Problem",
          "type": "tree",
          "content": null
        },
        {
          "name": "Under Construction.markdown",
          "type": "blob",
          "size": 0.94,
          "content": "# Under Construction :construction:\n\nHere you'll find algorithms that are currently under construction. Suggestions and feedback is welcome!\n\n### Sorting\n\nSpecial-purpose sorts:\n - [Radix Sort](Radix%20Sort/)\n\n### Special-purpose sorts:\n\n- [Bucket Sort](Bucket%20Sort/)\n\n### Queues\n\n- [Bounded Priority Queue](Bounded%20Priority%20Queue). A queue that is bounded to have a limited number of elements.\n\n### Trees\n\n- [AVL Tree](AVL%20Tree/). A binary search tree that balances itself using rotations.\n- [Red-Black Tree](Red-Black%20Tree/)\n- [Threaded Binary Tree](Threaded%20Binary%20Tree/)\n- [Ternary Search Tree](Ternary%20Search%20Tree/)\n- [Trie](Trie/)\n- [Radix Tree](Radix%20Tree/)\n\n### Miscellaneous\n\n- [Minimum Edit Distance](Minimum%20Edit%20Distance/). Measure the similarity of two strings by counting the number of operations required to transform one string into the other.\n- [Treap](Treap/)\n- [Set Cover (Unweighted)](Set%20Cover%20(Unweighted)/)\n"
        },
        {
          "name": "Union-Find",
          "type": "tree",
          "content": null
        },
        {
          "name": "What are Algorithms.markdown",
          "type": "blob",
          "size": 1.26,
          "content": "# What are algorithms and data structures?\n\nAn algorithm is a recipe for making the computer do something. If you know how to cook, you understand algorithms!\n\nHere's a [recipe for pancakes](http://allrecipes.com/recipe/21014/good-old-fashioned-pancakes/):\n\n1. In a large bowl, sift together flour, baking powder, salt and sugar.\n2. Pour in the milk, egg, and melted butter.\n3. Mix until smooth.\n4. Heat a frying pan over medium heat.\n5. Scoop the batter into the pan, using approximately 1/4 cup for each pancake.\n6. Brown the pancake on both sides.\n\nThe recipe consists of a series of steps that you perform one after the other. An algorithm is just like that, except that it contains instructions for a computer to perform, not for a cook.\n\nThe ingredients -- flour, milk, eggs, butter -- are the data that the algorithm works on. The data goes into the algorithm in one form (raw, separate ingredients) and comes out in another (delicious pancakes!).\n\nSo what are the data structures? They are the containers that hold the data while the algorithm works on it. In the pancake recipe, the data structures are the bag that holds the flour, the mixing bowl where you combine everything, the frying pan that browns the pancake, and finally the plate used to serve the finished pancake.\n"
        },
        {
          "name": "Why Algorithms.markdown",
          "type": "blob",
          "size": 2.29,
          "content": "# Why learn algorithms and data structures?\n\nIf you've been coding for while you may wonder what the point is of learning about algorithms and data structures, especially if you don't have a formal computer science or engineering background.\n\nAfter all, how often do you actually have to use a linked list or write your own sort routine when you're making apps? The answer is: almost never.\n\n#### **However...**\n\nKnowing a little bit about the strategies used by algorithms to solve tricky problems gives you ideas for improvements you can make to your own code.\n\nKnowing more data structures than just the standard array and dictionary gives you a bigger collection of tools you can use to build your own apps.\n\nIt will make you a better developer! (And better developers make more $$$.)\n\n#### Algorithms lets you build software you couldn't otherwise build\n\nThere have been apps that I've been unable to create in the past because I got stuck on fundamental issues.\n\nOften it was a matter of speed: I just couldn't make the program go fast enough. Thinking back on this now, I had chosen the wrong algorithms for these problems. If I had known more about the difference between **O(n)** and **O(n^2)**, then maybe I would have had better luck.\n\nNaive brute-force solutions work fine for small amounts of data, but sometimes you need to deal with lots of data. And then you need smarter algorithms.\n\nThere were also times I wasn't able to solve my programming problems at all, not even slowly. I simply didn't know where to begin. Understanding a bit of algorithm theory gives you various tactics you can try.\n\n#### Don't spend any time memorizing algorithms\n\nThat's not the point. Instead, try to understand how different algorithms approach different problems.\n\nLearn about techniques such as divide-and-conquer, dynamic programming, greedy algorithms. See what makes one approach slow and another fast, and learn what the tradeoffs are.\n\nThe key thing here is to get insight in how we can make computers do things.\n\n#### It's not as scary as it sounds\n\nA lot of algorithm textbooks start with a bunch of math. Truth is, the math is useful but most of the time you won't need it. So don't let that scare you. If you can write code, you can also understand all these fancy algorithms and data structures.\n\nTrust me, algorithms are fun. :-)\n"
        },
        {
          "name": "Z-Algorithm",
          "type": "tree",
          "content": null
        },
        {
          "name": "gfm-render.sh",
          "type": "blob",
          "size": 3.37,
          "content": "#!/usr/bin/env bash\n\nset -e\n\n# $1 - readme file name\nfunction render_markdown_to_html {\n  # escape escaping characters on Darwin only\n  content=$(\n    cat \"$1\"                                          \\\n      | sed 's/\\\\/\\\\\\\\/g'                             \\\n      | sed 's/\"/\\\\\"/g'                               \\\n      | sed $'s/\\t/\\\\\\\\t/g'                           \\\n      | sed -e ':a' -e 'N' -e '$!ba' -e 's/\\n/\\\\\\n/g' \\\n  )\n\n  # network call to GitHub API\n  json=\"{\\\"text\\\":\\\"$content\\\",\\\"mode\\\":\\\"gfm\\\",\\\"context\\\":\\\"$USERNAME/swift-algorithm-club\\\"}\"\n  echo -e \"$(curl -s --data \"$json\" -u $USERNAME:$TOKEN https://api.github.com/markdown)\"\n}\n\n# download github systax highlight stylesheet\necho \"> Downloading github-light.css...\"\ncurl -s -O https://raw.githubusercontent.com/primer/github-syntax-light/master/lib/github-light.css\n\n# slightly modify the main stylesheet\necho \"> Modifying github-light.css...\"\ncat >> github-light.css << EOF\n#container {\n  margin: 0 auto;\n  width: 75%;\n  min-width: 768px;\n  max-width: 896px;\n  position: relative;\n}\n\nbody {\n  font-size: 18px;\n}\n\ncode {\n    padding: 0.2em;\n    margin: 0;\n    font-size: 85%;\n    background-color: #f6f8fa;\n    line-height: 1.45;\n    border-radius: 3px\n}\n\npre code {\n    padding: 0px;\n    background-color: transparent;\n}\n\n.highlight {\n  margin: 0px;\n  padding: 0px 16px;\n  font-size: 85%;\n  line-height: 1.45;\n  overflow: auto;\n  background-color: #f6f8fa;\n  border-radius: 3px;\n}\n\n@media (max-width: 768px) {\n  #container {\n    position: absolute;\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    min-width: 100%;\n  }\n}\nEOF\n\n# other markdown articles\nfor title in \"What are Algorithms\" \"Big-O Notation\" \"Algorithm Design\" \"Why Algorithms\"; do\n  echo \"> Generating $title.html...\"\n\n  cat > \"$title.html\" << EOF\n<!DOCTYPE html>\n<head>\n  <title>$title</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"github-light.css\">\n</head>\n<body>\n  <div id=\"container\">$(render_markdown_to_html \"$title.markdown\")</div>\n</body>\n</html>\nEOF\ndone\n\n# if index.html does not exist, create one;\n# otherwise, empty its content.\necho \"> Generating index.html...\"\ncat > index.html << EOF\n<!DOCTYPE html>\n<head>\n  <title>Swift Algorithm Club</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"github-light.css\">\n</head>\n<body>\n  <div id=\"container\">$(render_markdown_to_html README.markdown | sed 's/.markdown/.html/g')</div>\n</body>\n</html>\nEOF\n\n# iterate immediate directories\nfind . -maxdepth 1 -type d | while read folder; do\n  readme=''\n\n  # get the right extension for the README file if there is one\n  if [[ -f $folder/README.md ]]; then readme=\"$folder/README.md\"; fi\n  if [[ -f $folder/README.markdown ]]; then readme=\"$folder/README.markdown\"; fi\n\n  # skip if there is no README or it it the README of the repository\n  if [[ (-z $readme) || $readme == \"./README.markdown\" ]]; then continue; fi\n\n  # render README to HTML\n  name=$(basename \"$folder\")\n  echo \"> Generating $name/index.html...\"\n\n  cat > \"$folder/index.html\" << EOF\n<!DOCTYPE html>\n<head>\n  <title>$name</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"../github-light.css\">\n</head>\n<body>\n  <div id=\"container\">$(render_markdown_to_html \"$readme\")</div>\n</body>\n</html>\nEOF\ndone\n\n# push to gh-pages\nif [[ $CI = true ]]; then\n  git checkout -b gh-pages\n  git add .\n  git commit -m \"$Generated by TravisCI on $(date +%D)\"\n  git push -f https://$TOKEN@github.com/$USERNAME/swift-algorithm-club.git gh-pages\nfi\n"
        },
        {
          "name": "install_swiftlint.sh",
          "type": "blob",
          "size": 0.71,
          "content": "#!/bin/bash\n\n# Installs the SwiftLint package.\n# Tries to get the precompiled .pkg file from Github, but if that\n# fails just recompiles from source.\n\nset -e\n\nSWIFTLINT_PKG_PATH=\"/tmp/SwiftLint.pkg\"\nSWIFTLINT_PKG_URL=\"https://github.com/realm/SwiftLint/releases/download/0.10.0/SwiftLint.pkg\"\n\nwget --output-document=$SWIFTLINT_PKG_PATH $SWIFTLINT_PKG_URL\n\nif [ -f $SWIFTLINT_PKG_PATH ]; then\n  echo \"SwiftLint package exists! Installing it...\"\n  sudo installer -pkg $SWIFTLINT_PKG_PATH -target /\nelse\n  echo \"SwiftLint package doesn't exist. Compiling from source...\" &&\n  git clone https://github.com/realm/SwiftLint.git /tmp/SwiftLint &&\n  cd /tmp/SwiftLint &&\n  git submodule update --init --recursive &&\n  sudo make install\nfi\n"
        }
      ]
    }
  ]
}