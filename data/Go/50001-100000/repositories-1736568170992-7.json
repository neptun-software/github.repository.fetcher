{
  "metadata": {
    "timestamp": 1736568170992,
    "page": 7,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "caddyserver/caddy",
      "stars": 60374,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.09375,
          "content": "[*]\nend_of_line = lf\n\n[caddytest/integration/caddyfile_adapt/*.caddyfiletest]\nindent_style = tab"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.015625,
          "content": "*.go text eol=lf"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.333984375,
          "content": "_gitignore/\n*.log\nCaddyfile\nCaddyfile.*\n!caddyfile/\n!caddyfile.go\n\n# artifacts from pprof tooling\n*.prof\n*.test\n\n# build artifacts and helpers\ncmd/caddy/caddy\ncmd/caddy/caddy.exe\ncmd/caddy/tmp/*.exe\ncmd/caddy/.env\n\n# mac specific\n.DS_Store\n\n# go modules\nvendor\n\n# goreleaser artifacts\ndist\ncaddy-build\ncaddy-dist\n\n# IDE files\n.idea/\n.vscode/\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 4.1884765625,
          "content": "linters-settings:\n  errcheck:\n    exclude-functions:\n      - fmt.*\n      - (go.uber.org/zap/zapcore.ObjectEncoder).AddObject\n      - (go.uber.org/zap/zapcore.ObjectEncoder).AddArray\n  gci:\n    sections:\n      - standard # Standard section: captures all standard packages.\n      - default # Default section: contains all imports that could not be matched to another section type.\n      - prefix(github.com/caddyserver/caddy/v2/cmd) # ensure that this is always at the top and always has a line break.\n      - prefix(github.com/caddyserver/caddy) # Custom section: groups all imports with the specified Prefix.\n    # Skip generated files.\n    # Default: true\n    skip-generated: true\n    # Enable custom order of sections.\n    # If `true`, make the section order the same as the order of `sections`.\n    # Default: false\n    custom-order: true\n  exhaustive:\n    ignore-enum-types: reflect.Kind|svc.Cmd\n\nlinters:\n  disable-all: true\n  enable:\n    - asasalint\n    - asciicheck\n    - bidichk\n    - bodyclose\n    - decorder\n    - dogsled\n    - dupl\n    - dupword\n    - durationcheck\n    - errcheck\n    - errname\n    - exhaustive\n    - gci\n    - gofmt\n    - goimports\n    - gofumpt\n    - gosec\n    - gosimple\n    - govet\n    - ineffassign\n    - importas\n    - misspell\n    - prealloc\n    - promlinter\n    - sloglint\n    - sqlclosecheck\n    - staticcheck\n    - tenv\n    - testableexamples\n    - testifylint\n    - tparallel\n    - typecheck\n    - unconvert\n    - unused\n    - wastedassign\n    - whitespace\n    - zerologlint\n  # these are implicitly disabled:\n  # - containedctx\n  # - contextcheck\n  # - cyclop\n  # - depguard\n  # - errchkjson\n  # - errorlint\n  # - exhaustruct\n  # - execinquery\n  # - exhaustruct\n  # - forbidigo\n  # - forcetypeassert\n  # - funlen\n  # - ginkgolinter\n  # - gocheckcompilerdirectives\n  # - gochecknoglobals\n  # - gochecknoinits\n  # - gochecksumtype\n  # - gocognit\n  # - goconst\n  # - gocritic\n  # - gocyclo\n  # - godot\n  # - godox\n  # - goerr113\n  # - goheader\n  # - gomnd\n  # - gomoddirectives\n  # - gomodguard\n  # - goprintffuncname\n  # - gosmopolitan\n  # - grouper\n  # - inamedparam\n  # - interfacebloat\n  # - ireturn\n  # - lll\n  # - loggercheck\n  # - maintidx\n  # - makezero\n  # - mirror\n  # - musttag\n  # - nakedret\n  # - nestif\n  # - nilerr\n  # - nilnil\n  # - nlreturn\n  # - noctx\n  # - nolintlint\n  # - nonamedreturns\n  # - nosprintfhostport\n  # - paralleltest\n  # - perfsprint\n  # - predeclared\n  # - protogetter\n  # - reassign\n  # - revive\n  # - rowserrcheck\n  # - stylecheck\n  # - tagalign\n  # - tagliatelle\n  # - testpackage\n  # - thelper\n  # - unparam\n  # - usestdlibvars\n  # - varnamelen\n  # - wrapcheck\n  # - wsl\n\nrun:\n  # default concurrency is a available CPU number.\n  # concurrency: 4 # explicitly omit this value to fully utilize available resources.\n  timeout: 5m\n  issues-exit-code: 1\n  tests: false\n\n# output configuration options\noutput:\n  formats:\n    - format: 'colored-line-number'\n  print-issued-lines: true\n  print-linter-name: true\n\nissues:\n  exclude-rules:\n    - text: 'G115' # TODO: Either we should fix the issues or nuke the linter if it's bad\n      linters:\n        - gosec\n    # we aren't calling unknown URL\n    - text: 'G107' # G107: Url provided to HTTP request as taint input\n      linters:\n        - gosec\n    # as a web server that's expected to handle any template, this is totally in the hands of the user.\n    - text: 'G203' # G203: Use of unescaped data in HTML templates\n      linters:\n        - gosec\n    # we're shelling out to known commands, not relying on user-defined input.\n    - text: 'G204' # G204: Audit use of command execution\n      linters:\n        - gosec\n    # the choice of weakrand is deliberate, hence the named import \"weakrand\"\n    - path: modules/caddyhttp/reverseproxy/selectionpolicies.go\n      text: 'G404' # G404: Insecure random number source (rand)\n      linters:\n        - gosec\n    - path: modules/caddyhttp/reverseproxy/streaming.go\n      text: 'G404' # G404: Insecure random number source (rand)\n      linters:\n        - gosec\n    - path: modules/logging/filters.go\n      linters:\n        - dupl\n    - path: modules/caddyhttp/matchers.go\n      linters:\n        - dupl\n    - path: modules/caddyhttp/vars.go\n      linters:\n        - dupl\n    - path: _test\\.go\n      linters:\n        - errcheck\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 5.8173828125,
          "content": "version: 2\n\nbefore:\n  hooks:\n    # The build is done in this particular way to build Caddy in a designated directory named in .gitignore.\n    # This is so we can run goreleaser on tag without Git complaining of being dirty. The main.go in cmd/caddy directory \n    # cannot be built within that directory due to changes necessary for the build causing Git to be dirty, which\n    # subsequently causes gorleaser to refuse running.\n    - rm -rf caddy-build caddy-dist vendor\n    # vendor Caddy deps\n    - go mod vendor\n    - mkdir -p caddy-build\n    - cp cmd/caddy/main.go caddy-build/main.go\n    - /bin/sh -c 'cd ./caddy-build && go mod init caddy'\n    # prepare syso files for windows embedding\n    - /bin/sh -c 'for a in amd64 arm arm64; do XCADDY_SKIP_BUILD=1 GOOS=windows GOARCH=$a xcaddy build {{.Env.TAG}}; done'\n    - /bin/sh -c 'mv /tmp/buildenv_*/*.syso caddy-build'\n    # GoReleaser doesn't seem to offer {{.Tag}} at this stage, so we have to embed it into the env\n    # so we run: TAG=$(git describe --abbrev=0) goreleaser release --rm-dist --skip-publish --skip-validate\n    - go mod edit -require=github.com/caddyserver/caddy/v2@{{.Env.TAG}} ./caddy-build/go.mod\n    # as of Go 1.16, `go` commands no longer automatically change go.{mod,sum}. We now have to explicitly\n    # run `go mod tidy`. The `/bin/sh -c '...'` is because goreleaser can't find cd in PATH without shell invocation.\n    - /bin/sh -c 'cd ./caddy-build && go mod tidy'\n    # vendor the deps of the prepared to-build module\n    - /bin/sh -c 'cd ./caddy-build && go mod vendor'\n    - git clone --depth 1 https://github.com/caddyserver/dist caddy-dist\n    - mkdir -p caddy-dist/man\n    - go mod download\n    - go run cmd/caddy/main.go manpage --directory ./caddy-dist/man\n    - gzip -r ./caddy-dist/man/\n    - /bin/sh -c 'go run cmd/caddy/main.go completion bash > ./caddy-dist/scripts/bash-completion'\n\nbuilds:\n- env:\n  - CGO_ENABLED=0\n  - GO111MODULE=on\n  dir: ./caddy-build\n  binary: caddy\n  goos:\n  - darwin\n  - linux\n  - windows\n  - freebsd\n  goarch:\n  - amd64\n  - arm\n  - arm64\n  - s390x\n  - ppc64le\n  - riscv64\n  goarm:\n  - \"5\"\n  - \"6\"\n  - \"7\"\n  ignore:\n    - goos: darwin\n      goarch: arm\n    - goos: darwin\n      goarch: ppc64le\n    - goos: darwin\n      goarch: s390x\n    - goos: darwin\n      goarch: riscv64\n    - goos: windows\n      goarch: ppc64le\n    - goos: windows\n      goarch: s390x\n    - goos: windows\n      goarch: riscv64\n    - goos: freebsd\n      goarch: ppc64le\n    - goos: freebsd\n      goarch: s390x\n    - goos: freebsd\n      goarch: riscv64\n    - goos: freebsd\n      goarch: arm\n      goarm: \"5\"\n  flags:\n  - -trimpath\n  - -mod=readonly\n  ldflags:\n  - -s -w\n  tags:\n  - nobadger\n  - nomysql\n  - nopgx\n\nsigns:\n  - cmd: cosign\n    signature: \"${artifact}.sig\"\n    certificate: '{{ trimsuffix (trimsuffix .Env.artifact \".zip\") \".tar.gz\" }}.pem'\n    args: [\"sign-blob\", \"--yes\", \"--output-signature=${signature}\", \"--output-certificate\", \"${certificate}\", \"${artifact}\"]\n    artifacts: all\n\nsboms:\n  - artifacts: binary\n    documents:\n      - >-\n        {{ .ProjectName }}_\n        {{- .Version }}_\n        {{- if eq .Os \"darwin\" }}mac{{ else }}{{ .Os }}{{ end }}_\n        {{- .Arch }}\n        {{- with .Arm }}v{{ . }}{{ end }}\n        {{- with .Mips }}_{{ . }}{{ end }}\n        {{- if not (eq .Amd64 \"v1\") }}{{ .Amd64 }}{{ end }}.sbom\n    cmd: syft\n    args: [\"$artifact\", \"--file\", \"${document}\", \"--output\", \"cyclonedx-json\"]\n\narchives:\n  - id: default\n    format_overrides:\n      - goos: windows\n        format: zip\n    name_template: >-\n      {{ .ProjectName }}_\n      {{- .Version }}_\n      {{- if eq .Os \"darwin\" }}mac{{ else }}{{ .Os }}{{ end }}_\n      {{- .Arch }}\n      {{- with .Arm }}v{{ . }}{{ end }}\n      {{- with .Mips }}_{{ . }}{{ end }}\n      {{- if not (eq .Amd64 \"v1\") }}{{ .Amd64 }}{{ end }}\n  \n  # package the 'caddy-build' directory into a tarball,\n  # allowing users to build the exact same set of files as ours.\n  - id: source\n    meta: true\n    name_template: \"{{ .ProjectName }}_{{ .Version }}_buildable-artifact\"\n    files:\n      - src: LICENSE\n        dst: ./LICENSE\n      - src: README.md\n        dst: ./README.md\n      - src: AUTHORS\n        dst: ./AUTHORS\n      - src: ./caddy-build\n        dst: ./\n\nsource:\n  enabled: true\n  name_template: '{{ .ProjectName }}_{{ .Version }}_src'\n  format: 'tar.gz'\n\n  # Additional files/template/globs you want to add to the source archive.\n  #\n  # Default: empty.\n  files:\n    - vendor\n\n\nchecksum:\n  algorithm: sha512\n\nnfpms:\n  - id: default\n    package_name: caddy\n\n    vendor: Dyanim\n    homepage: https://caddyserver.com\n    maintainer: Matthew Holt <mholt@users.noreply.github.com>\n    description: |\n      Caddy - Powerful, enterprise-ready, open source web server with automatic HTTPS written in Go\n    license: Apache 2.0\n\n    formats:\n      - deb\n      # - rpm\n\n    bindir: /usr/bin\n    contents:\n      - src: ./caddy-dist/init/caddy.service\n        dst: /lib/systemd/system/caddy.service\n        \n      - src: ./caddy-dist/init/caddy-api.service\n        dst: /lib/systemd/system/caddy-api.service\n      \n      - src: ./caddy-dist/welcome/index.html\n        dst: /usr/share/caddy/index.html\n      \n      - src: ./caddy-dist/scripts/bash-completion\n        dst: /etc/bash_completion.d/caddy\n    \n      - src: ./caddy-dist/config/Caddyfile\n        dst: /etc/caddy/Caddyfile\n        type: config\n\n      - src: ./caddy-dist/man/*\n        dst: /usr/share/man/man8/\n\n    scripts:\n      postinstall: ./caddy-dist/scripts/postinstall.sh\n      preremove: ./caddy-dist/scripts/preremove.sh\n      postremove: ./caddy-dist/scripts/postremove.sh\n\n    provides:\n      - httpd\n\nrelease:\n  github:\n    owner: caddyserver\n    name: caddy\n  draft: true\n  prerelease: auto\n\nchangelog:\n  sort: asc\n  filters:\n    exclude:\n    - '^chore:'\n    - '^ci:'\n    - '^docs?:'\n    - '^readme:'\n    - '^tests?:'\n    - '^\\w+\\s+' # a hack to remove commit messages without colons thus don't correspond to a package\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.3896484375,
          "content": "# This is the official list of Caddy Authors for copyright purposes.\n# Authors may be either individual people or legal entities.\n#\n# Not all individual contributors are authors. For the full list of\n# contributors, refer to the project's page on GitHub or the repo's\n# commit history.\n\nMatthew Holt <Matthew.Holt@gmail.com>\nLight Code Labs <sales@lightcodelabs.com>\nArdan Labs <info@ardanlabs.com>\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.091796875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.720703125,
          "content": "<p align=\"center\">\n\t<a href=\"https://caddyserver.com\">\n\t\t<picture>\n\t\t\t<source media=\"(prefers-color-scheme: dark)\" srcset=\"https://user-images.githubusercontent.com/1128849/210187358-e2c39003-9a5e-4dd5-a783-6deb6483ee72.svg\">\n\t\t\t<source media=\"(prefers-color-scheme: light)\" srcset=\"https://user-images.githubusercontent.com/1128849/210187356-dfb7f1c5-ac2e-43aa-bb23-fc014280ae1f.svg\">\n\t\t\t<img src=\"https://user-images.githubusercontent.com/1128849/210187356-dfb7f1c5-ac2e-43aa-bb23-fc014280ae1f.svg\" alt=\"Caddy\" width=\"550\">\n\t\t</picture>\n\t</a>\n\t<br>\n\t<h3 align=\"center\">a <a href=\"https://zerossl.com\"><img src=\"https://user-images.githubusercontent.com/55066419/208327323-2770dc16-ec09-43a0-9035-c5b872c2ad7f.svg\" height=\"28\" style=\"vertical-align: -7.7px\" valign=\"middle\"></a> project</h3>\n</p>\n<hr>\n<h3 align=\"center\">Every site on HTTPS</h3>\n<p align=\"center\">Caddy is an extensible server platform that uses TLS by default.</p>\n<p align=\"center\">\n\t<a href=\"https://github.com/caddyserver/caddy/actions/workflows/ci.yml\"><img src=\"https://github.com/caddyserver/caddy/actions/workflows/ci.yml/badge.svg\"></a>\n\t<a href=\"https://pkg.go.dev/github.com/caddyserver/caddy/v2\"><img src=\"https://img.shields.io/badge/godoc-reference-%23007d9c.svg\"></a>\n\t<br>\n\t<a href=\"https://twitter.com/caddyserver\" title=\"@caddyserver on Twitter\"><img src=\"https://img.shields.io/badge/twitter-@caddyserver-55acee.svg\" alt=\"@caddyserver on Twitter\"></a>\n\t<a href=\"https://caddy.community\" title=\"Caddy Forum\"><img src=\"https://img.shields.io/badge/community-forum-ff69b4.svg\" alt=\"Caddy Forum\"></a>\n\t<br>\n\t<a href=\"https://sourcegraph.com/github.com/caddyserver/caddy?badge\" title=\"Caddy on Sourcegraph\"><img src=\"https://sourcegraph.com/github.com/caddyserver/caddy/-/badge.svg\" alt=\"Caddy on Sourcegraph\"></a>\n\t<a href=\"https://cloudsmith.io/~caddy/repos/\"><img src=\"https://img.shields.io/badge/OSS%20hosting%20by-cloudsmith-blue?logo=cloudsmith\" alt=\"Cloudsmith\"></a>\n</p>\n<p align=\"center\">\n\t<a href=\"https://github.com/caddyserver/caddy/releases\">Releases</a> Â·\n\t<a href=\"https://caddyserver.com/docs/\">Documentation</a> Â·\n\t<a href=\"https://caddy.community\">Get Help</a>\n</p>\n\n\n\n### Menu\n\n- [Features](#features)\n- [Install](#install)\n- [Build from source](#build-from-source)\n\t- [For development](#for-development)\n\t- [With version information and/or plugins](#with-version-information-andor-plugins)\n- [Quick start](#quick-start)\n- [Overview](#overview)\n- [Full documentation](#full-documentation)\n- [Getting help](#getting-help)\n- [About](#about)\n\n<p align=\"center\">\n\t<b>Powered by</b>\n\t<br>\n\t<a href=\"https://github.com/caddyserver/certmagic\">\n\t\t<picture>\n\t\t\t<source media=\"(prefers-color-scheme: dark)\" srcset=\"https://user-images.githubusercontent.com/55066419/206946718-740b6371-3df3-4d72-a822-47e4c48af999.png\">\n\t\t\t<source media=\"(prefers-color-scheme: light)\" srcset=\"https://user-images.githubusercontent.com/1128849/49704830-49d37200-fbd5-11e8-8385-767e0cd033c3.png\">\n\t\t\t<img src=\"https://user-images.githubusercontent.com/1128849/49704830-49d37200-fbd5-11e8-8385-767e0cd033c3.png\" alt=\"CertMagic\" width=\"250\">\n\t\t</picture>\n\t</a>\n</p>\n\n\n## [Features](https://caddyserver.com/features)\n\n- **Easy configuration** with the [Caddyfile](https://caddyserver.com/docs/caddyfile)\n- **Powerful configuration** with its [native JSON config](https://caddyserver.com/docs/json/)\n- **Dynamic configuration** with the [JSON API](https://caddyserver.com/docs/api)\n- [**Config adapters**](https://caddyserver.com/docs/config-adapters) if you don't like JSON\n- **Automatic HTTPS** by default\n\t- [ZeroSSL](https://zerossl.com) and [Let's Encrypt](https://letsencrypt.org) for public names\n\t- Fully-managed local CA for internal names & IPs\n\t- Can coordinate with other Caddy instances in a cluster\n\t- Multi-issuer fallback\n- **Stays up when other servers go down** due to TLS/OCSP/certificate-related issues\n- **Production-ready** after serving trillions of requests and managing millions of TLS certificates\n- **Scales to hundreds of thousands of sites** as proven in production\n- **HTTP/1.1, HTTP/2, and HTTP/3** all supported by default\n- **Highly extensible** [modular architecture](https://caddyserver.com/docs/architecture) lets Caddy do anything without bloat\n- **Runs anywhere** with **no external dependencies** (not even libc)\n- Written in Go, a language with higher **memory safety guarantees** than other servers\n- Actually **fun to use**\n- So much more to [discover](https://caddyserver.com/features)\n\n## Install\n\nThe simplest, cross-platform way to get started is to download Caddy from [GitHub Releases](https://github.com/caddyserver/caddy/releases) and place the executable file in your PATH.\n\nSee [our online documentation](https://caddyserver.com/docs/install) for other install instructions.\n\n## Build from source\n\nRequirements:\n\n- [Go 1.22.3 or newer](https://golang.org/dl/)\n\n### For development\n\n_**Note:** These steps [will not embed proper version information](https://github.com/golang/go/issues/29228). For that, please follow the instructions in the next section._\n\n```bash\n$ git clone \"https://github.com/caddyserver/caddy.git\"\n$ cd caddy/cmd/caddy/\n$ go build\n```\n\nWhen you run Caddy, it may try to bind to low ports unless otherwise specified in your config. If your OS requires elevated privileges for this, you will need to give your new binary permission to do so. On Linux, this can be done easily with: `sudo setcap cap_net_bind_service=+ep ./caddy`\n\nIf you prefer to use `go run` which only creates temporary binaries, you can still do this with the included `setcap.sh` like so:\n\n```bash\n$ go run -exec ./setcap.sh main.go\n```\n\nIf you don't want to type your password for `setcap`, use `sudo visudo` to edit your sudoers file and allow your user account to run that command without a password, for example:\n\n```\nusername ALL=(ALL:ALL) NOPASSWD: /usr/sbin/setcap\n```\n\nreplacing `username` with your actual username. Please be careful and only do this if you know what you are doing! We are only qualified to document how to use Caddy, not Go tooling or your computer, and we are providing these instructions for convenience only; please learn how to use your own computer at your own risk and make any needful adjustments.\n\n### With version information and/or plugins\n\nUsing [our builder tool, `xcaddy`](https://github.com/caddyserver/xcaddy)...\n\n```\n$ xcaddy build\n```\n\n...the following steps are automated:\n\n1. Create a new folder: `mkdir caddy`\n2. Change into it: `cd caddy`\n3. Copy [Caddy's main.go](https://github.com/caddyserver/caddy/blob/master/cmd/caddy/main.go) into the empty folder. Add imports for any custom plugins you want to add.\n4. Initialize a Go module: `go mod init caddy`\n5. (Optional) Pin Caddy version: `go get github.com/caddyserver/caddy/v2@version` replacing `version` with a git tag, commit, or branch name.\n6. (Optional) Add plugins by adding their import: `_ \"import/path/here\"`\n7. Compile: `go build -tags=nobadger,nomysql,nopgx`\n\n\n\n\n## Quick start\n\nThe [Caddy website](https://caddyserver.com/docs/) has documentation that includes tutorials, quick-start guides, reference, and more.\n\n**We recommend that all users -- regardless of experience level -- do our [Getting Started](https://caddyserver.com/docs/getting-started) guide to become familiar with using Caddy.**\n\nIf you've only got a minute, [the website has several quick-start tutorials](https://caddyserver.com/docs/quick-starts) to choose from! However, after finishing a quick-start tutorial, please read more documentation to understand how the software works. ðŸ™‚\n\n\n\n\n## Overview\n\nCaddy is most often used as an HTTPS server, but it is suitable for any long-running Go program. First and foremost, it is a platform to run Go applications. Caddy \"apps\" are just Go programs that are implemented as Caddy modules. Two apps -- `tls` and `http` -- ship standard with Caddy.\n\nCaddy apps instantly benefit from [automated documentation](https://caddyserver.com/docs/json/), graceful on-line [config changes via API](https://caddyserver.com/docs/api), and unification with other Caddy apps.\n\nAlthough [JSON](https://caddyserver.com/docs/json/) is Caddy's native config language, Caddy can accept input from [config adapters](https://caddyserver.com/docs/config-adapters) which can essentially convert any config format of your choice into JSON: Caddyfile, JSON 5, YAML, TOML, NGINX config, and more.\n\nThe primary way to configure Caddy is through [its API](https://caddyserver.com/docs/api), but if you prefer config files, the [command-line interface](https://caddyserver.com/docs/command-line) supports those too.\n\nCaddy exposes an unprecedented level of control compared to any web server in existence. In Caddy, you are usually setting the actual values of the initialized types in memory that power everything from your HTTP handlers and TLS handshakes to your storage medium. Caddy is also ridiculously extensible, with a powerful plugin system that makes vast improvements over other web servers.\n\nTo wield the power of this design, you need to know how the config document is structured. Please see [our documentation site](https://caddyserver.com/docs/) for details about [Caddy's config structure](https://caddyserver.com/docs/json/).\n\nNearly all of Caddy's configuration is contained in a single config document, rather than being scattered across CLI flags and env variables and a configuration file as with other web servers. This makes managing your server config more straightforward and reduces hidden variables/factors.\n\n\n## Full documentation\n\nOur website has complete documentation:\n\n**https://caddyserver.com/docs/**\n\nThe docs are also open source. You can contribute to them here: https://github.com/caddyserver/website\n\n\n\n## Getting help\n\n- We advise companies using Caddy to secure a support contract through [Ardan Labs](https://www.ardanlabs.com/my/contact-us?dd=caddy) before help is needed.\n\n- A [sponsorship](https://github.com/sponsors/mholt) goes a long way! We can offer private help to sponsors. If Caddy is benefitting your company, please consider a sponsorship. This not only helps fund full-time work to ensure the longevity of the project, it provides your company the resources, support, and discounts you need; along with being a great look for your company to your customers and potential customers!\n\n- Individuals can exchange help for free on our community forum at https://caddy.community. Remember that people give help out of their spare time and good will. The best way to get help is to give it first!\n\nPlease use our [issue tracker](https://github.com/caddyserver/caddy/issues) only for bug reports and feature requests, i.e. actionable development items (support questions will usually be referred to the forums).\n\n\n\n## About\n\nMatthew Holt began developing Caddy in 2014 while studying computer science at Brigham Young University. (The name \"Caddy\" was chosen because this software helps with the tedious, mundane tasks of serving the Web, and is also a single place for multiple things to be organized together.) It soon became the first web server to use HTTPS automatically and by default, and now has hundreds of contributors and has served trillions of HTTPS requests.\n\n**The name \"Caddy\" is trademarked.** The name of the software is \"Caddy\", not \"Caddy Server\" or \"CaddyServer\". Please call it \"Caddy\" or, if you wish to clarify, \"the Caddy web server\". Caddy is a registered trademark of Stack Holdings GmbH.\n\n- _Project on Twitter: [@caddyserver](https://twitter.com/caddyserver)_\n- _Author on Twitter: [@mholt6](https://twitter.com/mholt6)_\n\nCaddy is a project of [ZeroSSL](https://zerossl.com), a Stack Holdings company.\n\nDebian package repository hosting is graciously provided by [Cloudsmith](https://cloudsmith.com). Cloudsmith is the only fully hosted, cloud-native, universal package management solution, that enables your organization to create, store and share packages in any format, to any place, with total confidence.\n"
        },
        {
          "name": "admin.go",
          "type": "blob",
          "size": 44.5517578125,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"expvar\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/pprof\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"regexp\"\n\t\"slices\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/caddyserver/certmagic\"\n\t\"github.com/cespare/xxhash/v2\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\nfunc init() {\n\t// The hard-coded default `DefaultAdminListen` can be overridden\n\t// by setting the `CADDY_ADMIN` environment variable.\n\t// The environment variable may be used by packagers to change\n\t// the default admin address to something more appropriate for\n\t// that platform. See #5317 for discussion.\n\tif env, exists := os.LookupEnv(\"CADDY_ADMIN\"); exists {\n\t\tDefaultAdminListen = env\n\t}\n}\n\n// AdminConfig configures Caddy's API endpoint, which is used\n// to manage Caddy while it is running.\ntype AdminConfig struct {\n\t// If true, the admin endpoint will be completely disabled.\n\t// Note that this makes any runtime changes to the config\n\t// impossible, since the interface to do so is through the\n\t// admin endpoint.\n\tDisabled bool `json:\"disabled,omitempty\"`\n\n\t// The address to which the admin endpoint's listener should\n\t// bind itself. Can be any single network address that can be\n\t// parsed by Caddy. Accepts placeholders.\n\t// Default: the value of the `CADDY_ADMIN` environment variable,\n\t// or `localhost:2019` otherwise.\n\t//\n\t// Remember: When changing this value through a config reload,\n\t// be sure to use the `--address` CLI flag to specify the current\n\t// admin address if the currently-running admin endpoint is not\n\t// the default address.\n\tListen string `json:\"listen,omitempty\"`\n\n\t// If true, CORS headers will be emitted, and requests to the\n\t// API will be rejected if their `Host` and `Origin` headers\n\t// do not match the expected value(s). Use `origins` to\n\t// customize which origins/hosts are allowed. If `origins` is\n\t// not set, the listen address is the only value allowed by\n\t// default. Enforced only on local (plaintext) endpoint.\n\tEnforceOrigin bool `json:\"enforce_origin,omitempty\"`\n\n\t// The list of allowed origins/hosts for API requests. Only needed\n\t// if accessing the admin endpoint from a host different from the\n\t// socket's network interface or if `enforce_origin` is true. If not\n\t// set, the listener address will be the default value. If set but\n\t// empty, no origins will be allowed. Enforced only on local\n\t// (plaintext) endpoint.\n\tOrigins []string `json:\"origins,omitempty\"`\n\n\t// Options pertaining to configuration management.\n\tConfig *ConfigSettings `json:\"config,omitempty\"`\n\n\t// Options that establish this server's identity. Identity refers to\n\t// credentials which can be used to uniquely identify and authenticate\n\t// this server instance. This is required if remote administration is\n\t// enabled (but does not require remote administration to be enabled).\n\t// Default: no identity management.\n\tIdentity *IdentityConfig `json:\"identity,omitempty\"`\n\n\t// Options pertaining to remote administration. By default, remote\n\t// administration is disabled. If enabled, identity management must\n\t// also be configured, as that is how the endpoint is secured.\n\t// See the neighboring \"identity\" object.\n\t//\n\t// EXPERIMENTAL: This feature is subject to change.\n\tRemote *RemoteAdmin `json:\"remote,omitempty\"`\n\n\t// Holds onto the routers so that we can later provision them\n\t// if they require provisioning.\n\trouters []AdminRouter\n}\n\n// ConfigSettings configures the management of configuration.\ntype ConfigSettings struct {\n\t// Whether to keep a copy of the active config on disk. Default is true.\n\t// Note that \"pulled\" dynamic configs (using the neighboring \"load\" module)\n\t// are not persisted; only configs that are pushed to Caddy get persisted.\n\tPersist *bool `json:\"persist,omitempty\"`\n\n\t// Loads a new configuration. This is helpful if your configs are\n\t// managed elsewhere and you want Caddy to pull its config dynamically\n\t// when it starts. The pulled config completely replaces the current\n\t// one, just like any other config load. It is an error if a pulled\n\t// config is configured to pull another config without a load_delay,\n\t// as this creates a tight loop.\n\t//\n\t// EXPERIMENTAL: Subject to change.\n\tLoadRaw json.RawMessage `json:\"load,omitempty\" caddy:\"namespace=caddy.config_loaders inline_key=module\"`\n\n\t// The duration after which to load config. If set, config will be pulled\n\t// from the config loader after this duration. A delay is required if a\n\t// dynamically-loaded config is configured to load yet another config. To\n\t// load configs on a regular interval, ensure this value is set the same\n\t// on all loaded configs; it can also be variable if needed, and to stop\n\t// the loop, simply remove dynamic config loading from the next-loaded\n\t// config.\n\t//\n\t// EXPERIMENTAL: Subject to change.\n\tLoadDelay Duration `json:\"load_delay,omitempty\"`\n}\n\n// IdentityConfig configures management of this server's identity. An identity\n// consists of credentials that uniquely verify this instance; for example,\n// TLS certificates (public + private key pairs).\ntype IdentityConfig struct {\n\t// List of names or IP addresses which refer to this server.\n\t// Certificates will be obtained for these identifiers so\n\t// secure TLS connections can be made using them.\n\tIdentifiers []string `json:\"identifiers,omitempty\"`\n\n\t// Issuers that can provide this admin endpoint its identity\n\t// certificate(s). Default: ACME issuers configured for\n\t// ZeroSSL and Let's Encrypt. Be sure to change this if you\n\t// require credentials for private identifiers.\n\tIssuersRaw []json.RawMessage `json:\"issuers,omitempty\" caddy:\"namespace=tls.issuance inline_key=module\"`\n\n\tissuers []certmagic.Issuer\n}\n\n// RemoteAdmin enables and configures remote administration. If enabled,\n// a secure listener enforcing mutual TLS authentication will be started\n// on a different port from the standard plaintext admin server.\n//\n// This endpoint is secured using identity management, which must be\n// configured separately (because identity management does not depend\n// on remote administration). See the admin/identity config struct.\n//\n// EXPERIMENTAL: Subject to change.\ntype RemoteAdmin struct {\n\t// The address on which to start the secure listener. Accepts placeholders.\n\t// Default: :2021\n\tListen string `json:\"listen,omitempty\"`\n\n\t// List of access controls for this secure admin endpoint.\n\t// This configures TLS mutual authentication (i.e. authorized\n\t// client certificates), but also application-layer permissions\n\t// like which paths and methods each identity is authorized for.\n\tAccessControl []*AdminAccess `json:\"access_control,omitempty\"`\n}\n\n// AdminAccess specifies what permissions an identity or group\n// of identities are granted.\ntype AdminAccess struct {\n\t// Base64-encoded DER certificates containing public keys to accept.\n\t// (The contents of PEM certificate blocks are base64-encoded DER.)\n\t// Any of these public keys can appear in any part of a verified chain.\n\tPublicKeys []string `json:\"public_keys,omitempty\"`\n\n\t// Limits what the associated identities are allowed to do.\n\t// If unspecified, all permissions are granted.\n\tPermissions []AdminPermissions `json:\"permissions,omitempty\"`\n\n\tpublicKeys []crypto.PublicKey\n}\n\n// AdminPermissions specifies what kinds of requests are allowed\n// to be made to the admin endpoint.\ntype AdminPermissions struct {\n\t// The API paths allowed. Paths are simple prefix matches.\n\t// Any subpath of the specified paths will be allowed.\n\tPaths []string `json:\"paths,omitempty\"`\n\n\t// The HTTP methods allowed for the given paths.\n\tMethods []string `json:\"methods,omitempty\"`\n}\n\n// newAdminHandler reads admin's config and returns an http.Handler suitable\n// for use in an admin endpoint server, which will be listening on listenAddr.\nfunc (admin *AdminConfig) newAdminHandler(addr NetworkAddress, remote bool, _ Context) adminHandler {\n\tmuxWrap := adminHandler{mux: http.NewServeMux()}\n\n\t// secure the local or remote endpoint respectively\n\tif remote {\n\t\tmuxWrap.remoteControl = admin.Remote\n\t} else {\n\t\tmuxWrap.enforceHost = !addr.isWildcardInterface()\n\t\tmuxWrap.allowedOrigins = admin.allowedOrigins(addr)\n\t\tmuxWrap.enforceOrigin = admin.EnforceOrigin\n\t}\n\n\taddRouteWithMetrics := func(pattern string, handlerLabel string, h http.Handler) {\n\t\tlabels := prometheus.Labels{\"path\": pattern, \"handler\": handlerLabel}\n\t\th = instrumentHandlerCounter(\n\t\t\tadminMetrics.requestCount.MustCurryWith(labels),\n\t\t\th,\n\t\t)\n\t\tmuxWrap.mux.Handle(pattern, h)\n\t}\n\t// addRoute just calls muxWrap.mux.Handle after\n\t// wrapping the handler with error handling\n\taddRoute := func(pattern string, handlerLabel string, h AdminHandler) {\n\t\twrapper := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\terr := h.ServeHTTP(w, r)\n\t\t\tif err != nil {\n\t\t\t\tlabels := prometheus.Labels{\n\t\t\t\t\t\"path\":    pattern,\n\t\t\t\t\t\"handler\": handlerLabel,\n\t\t\t\t\t\"method\":  strings.ToUpper(r.Method),\n\t\t\t\t}\n\t\t\t\tadminMetrics.requestErrors.With(labels).Inc()\n\t\t\t}\n\t\t\tmuxWrap.handleError(w, r, err)\n\t\t})\n\t\taddRouteWithMetrics(pattern, handlerLabel, wrapper)\n\t}\n\n\tconst handlerLabel = \"admin\"\n\n\t// register standard config control endpoints\n\taddRoute(\"/\"+rawConfigKey+\"/\", handlerLabel, AdminHandlerFunc(handleConfig))\n\taddRoute(\"/id/\", handlerLabel, AdminHandlerFunc(handleConfigID))\n\taddRoute(\"/stop\", handlerLabel, AdminHandlerFunc(handleStop))\n\n\t// register debugging endpoints\n\taddRouteWithMetrics(\"/debug/pprof/\", handlerLabel, http.HandlerFunc(pprof.Index))\n\taddRouteWithMetrics(\"/debug/pprof/cmdline\", handlerLabel, http.HandlerFunc(pprof.Cmdline))\n\taddRouteWithMetrics(\"/debug/pprof/profile\", handlerLabel, http.HandlerFunc(pprof.Profile))\n\taddRouteWithMetrics(\"/debug/pprof/symbol\", handlerLabel, http.HandlerFunc(pprof.Symbol))\n\taddRouteWithMetrics(\"/debug/pprof/trace\", handlerLabel, http.HandlerFunc(pprof.Trace))\n\taddRouteWithMetrics(\"/debug/vars\", handlerLabel, expvar.Handler())\n\n\t// register third-party module endpoints\n\tfor _, m := range GetModules(\"admin.api\") {\n\t\trouter := m.New().(AdminRouter)\n\t\tfor _, route := range router.Routes() {\n\t\t\taddRoute(route.Pattern, handlerLabel, route.Handler)\n\t\t}\n\t\tadmin.routers = append(admin.routers, router)\n\t}\n\n\treturn muxWrap\n}\n\n// provisionAdminRouters provisions all the router modules\n// in the admin.api namespace that need provisioning.\nfunc (admin *AdminConfig) provisionAdminRouters(ctx Context) error {\n\tfor _, router := range admin.routers {\n\t\tprovisioner, ok := router.(Provisioner)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\terr := provisioner.Provision(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// We no longer need the routers once provisioned, allow for GC\n\tadmin.routers = nil\n\n\treturn nil\n}\n\n// allowedOrigins returns a list of origins that are allowed.\n// If admin.Origins is nil (null), the provided listen address\n// will be used as the default origin. If admin.Origins is\n// empty, no origins will be allowed, effectively bricking the\n// endpoint for non-unix-socket endpoints, but whatever.\nfunc (admin AdminConfig) allowedOrigins(addr NetworkAddress) []*url.URL {\n\tuniqueOrigins := make(map[string]struct{})\n\tfor _, o := range admin.Origins {\n\t\tuniqueOrigins[o] = struct{}{}\n\t}\n\tif admin.Origins == nil {\n\t\tif addr.isLoopback() {\n\t\t\tif addr.IsUnixNetwork() || addr.IsFdNetwork() {\n\t\t\t\t// RFC 2616, Section 14.26:\n\t\t\t\t// \"A client MUST include a Host header field in all HTTP/1.1 request\n\t\t\t\t// messages. If the requested URI does not include an Internet host\n\t\t\t\t// name for the service being requested, then the Host header field MUST\n\t\t\t\t// be given with an empty value.\"\n\t\t\t\t//\n\t\t\t\t// UPDATE July 2023: Go broke this by patching a minor security bug in 1.20.6.\n\t\t\t\t// Understandable, but frustrating. See:\n\t\t\t\t// https://github.com/golang/go/issues/60374\n\t\t\t\t// See also the discussion here:\n\t\t\t\t// https://github.com/golang/go/issues/61431\n\t\t\t\t//\n\t\t\t\t// We can no longer conform to RFC 2616 Section 14.26 from either Go or curl\n\t\t\t\t// in purity. (Curl allowed no host between 7.40 and 7.50, but now requires a\n\t\t\t\t// bogus host; see https://superuser.com/a/925610.) If we disable Host/Origin\n\t\t\t\t// security checks, the infosec community assures me that it is secure to do\n\t\t\t\t// so, because:\n\t\t\t\t// 1) Browsers do not allow access to unix sockets\n\t\t\t\t// 2) DNS is irrelevant to unix sockets\n\t\t\t\t//\n\t\t\t\t// I am not quite ready to trust either of those external factors, so instead\n\t\t\t\t// of disabling Host/Origin checks, we now allow specific Host values when\n\t\t\t\t// accessing the admin endpoint over unix sockets. I definitely don't trust\n\t\t\t\t// DNS (e.g. I don't trust 'localhost' to always resolve to the local host),\n\t\t\t\t// and IP shouldn't even be used, but if it is for some reason, I think we can\n\t\t\t\t// at least be reasonably assured that 127.0.0.1 and ::1 route to the local\n\t\t\t\t// machine, meaning that a hypothetical browser origin would have to be on the\n\t\t\t\t// local machine as well.\n\t\t\t\tuniqueOrigins[\"\"] = struct{}{}\n\t\t\t\tuniqueOrigins[\"127.0.0.1\"] = struct{}{}\n\t\t\t\tuniqueOrigins[\"::1\"] = struct{}{}\n\t\t\t} else {\n\t\t\t\tuniqueOrigins[net.JoinHostPort(\"localhost\", addr.port())] = struct{}{}\n\t\t\t\tuniqueOrigins[net.JoinHostPort(\"::1\", addr.port())] = struct{}{}\n\t\t\t\tuniqueOrigins[net.JoinHostPort(\"127.0.0.1\", addr.port())] = struct{}{}\n\t\t\t}\n\t\t}\n\t\tif !addr.IsUnixNetwork() && !addr.IsFdNetwork() {\n\t\t\tuniqueOrigins[addr.JoinHostPort(0)] = struct{}{}\n\t\t}\n\t}\n\tallowed := make([]*url.URL, 0, len(uniqueOrigins))\n\tfor originStr := range uniqueOrigins {\n\t\tvar origin *url.URL\n\t\tif strings.Contains(originStr, \"://\") {\n\t\t\tvar err error\n\t\t\torigin, err = url.Parse(originStr)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\torigin.Path = \"\"\n\t\t\torigin.RawPath = \"\"\n\t\t\torigin.Fragment = \"\"\n\t\t\torigin.RawFragment = \"\"\n\t\t\torigin.RawQuery = \"\"\n\t\t} else {\n\t\t\torigin = &url.URL{Host: originStr}\n\t\t}\n\t\tallowed = append(allowed, origin)\n\t}\n\treturn allowed\n}\n\n// replaceLocalAdminServer replaces the running local admin server\n// according to the relevant configuration in cfg. If no configuration\n// for the admin endpoint exists in cfg, a default one is used, so\n// that there is always an admin server (unless it is explicitly\n// configured to be disabled).\n// Critically note that some elements and functionality of the context\n// may not be ready, e.g. storage. Tread carefully.\nfunc replaceLocalAdminServer(cfg *Config, ctx Context) error {\n\t// always* be sure to close down the old admin endpoint\n\t// as gracefully as possible, even if the new one is\n\t// disabled -- careful to use reference to the current\n\t// (old) admin endpoint since it will be different\n\t// when the function returns\n\t// (* except if the new one fails to start)\n\toldAdminServer := localAdminServer\n\tvar err error\n\tdefer func() {\n\t\t// do the shutdown asynchronously so that any\n\t\t// current API request gets a response; this\n\t\t// goroutine may last a few seconds\n\t\tif oldAdminServer != nil && err == nil {\n\t\t\tgo func(oldAdminServer *http.Server) {\n\t\t\t\terr := stopAdminServer(oldAdminServer)\n\t\t\t\tif err != nil {\n\t\t\t\t\tLog().Named(\"admin\").Error(\"stopping current admin endpoint\", zap.Error(err))\n\t\t\t\t}\n\t\t\t}(oldAdminServer)\n\t\t}\n\t}()\n\n\t// set a default if admin wasn't otherwise configured\n\tif cfg.Admin == nil {\n\t\tcfg.Admin = &AdminConfig{\n\t\t\tListen: DefaultAdminListen,\n\t\t}\n\t}\n\n\t// if new admin endpoint is to be disabled, we're done\n\tif cfg.Admin.Disabled {\n\t\tLog().Named(\"admin\").Warn(\"admin endpoint disabled\")\n\t\treturn nil\n\t}\n\n\t// extract a singular listener address\n\taddr, err := parseAdminListenAddr(cfg.Admin.Listen, DefaultAdminListen)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\thandler := cfg.Admin.newAdminHandler(addr, false, ctx)\n\n\tln, err := addr.Listen(context.TODO(), 0, net.ListenConfig{})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tserverMu.Lock()\n\tlocalAdminServer = &http.Server{\n\t\tAddr:              addr.String(), // for logging purposes only\n\t\tHandler:           handler,\n\t\tReadTimeout:       10 * time.Second,\n\t\tReadHeaderTimeout: 5 * time.Second,\n\t\tIdleTimeout:       60 * time.Second,\n\t\tMaxHeaderBytes:    1024 * 64,\n\t}\n\tserverMu.Unlock()\n\n\tadminLogger := Log().Named(\"admin\")\n\tgo func() {\n\t\tserverMu.Lock()\n\t\tserver := localAdminServer\n\t\tserverMu.Unlock()\n\t\tif err := server.Serve(ln.(net.Listener)); !errors.Is(err, http.ErrServerClosed) {\n\t\t\tadminLogger.Error(\"admin server shutdown for unknown reason\", zap.Error(err))\n\t\t}\n\t}()\n\n\tadminLogger.Info(\"admin endpoint started\",\n\t\tzap.String(\"address\", addr.String()),\n\t\tzap.Bool(\"enforce_origin\", cfg.Admin.EnforceOrigin),\n\t\tzap.Array(\"origins\", loggableURLArray(handler.allowedOrigins)))\n\n\tif !handler.enforceHost {\n\t\tadminLogger.Warn(\"admin endpoint on open interface; host checking disabled\",\n\t\t\tzap.String(\"address\", addr.String()))\n\t}\n\n\treturn nil\n}\n\n// manageIdentity sets up automated identity management for this server.\nfunc manageIdentity(ctx Context, cfg *Config) error {\n\tif cfg == nil || cfg.Admin == nil || cfg.Admin.Identity == nil {\n\t\treturn nil\n\t}\n\n\t// set default issuers; this is pretty hacky because we can't\n\t// import the caddytls package -- but it works\n\tif cfg.Admin.Identity.IssuersRaw == nil {\n\t\tcfg.Admin.Identity.IssuersRaw = []json.RawMessage{\n\t\t\tjson.RawMessage(`{\"module\": \"acme\"}`),\n\t\t}\n\t}\n\n\t// load and provision issuer modules\n\tif cfg.Admin.Identity.IssuersRaw != nil {\n\t\tval, err := ctx.LoadModule(cfg.Admin.Identity, \"IssuersRaw\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"loading identity issuer modules: %s\", err)\n\t\t}\n\t\tfor _, issVal := range val.([]any) {\n\t\t\tcfg.Admin.Identity.issuers = append(cfg.Admin.Identity.issuers, issVal.(certmagic.Issuer))\n\t\t}\n\t}\n\n\t// we'll make a new cache when we make the CertMagic config, so stop any previous cache\n\tif identityCertCache != nil {\n\t\tidentityCertCache.Stop()\n\t}\n\n\tlogger := Log().Named(\"admin.identity\")\n\tcmCfg := cfg.Admin.Identity.certmagicConfig(logger, true)\n\n\t// issuers have circular dependencies with the configs because,\n\t// as explained in the caddytls package, they need access to the\n\t// correct storage and cache to solve ACME challenges\n\tfor _, issuer := range cfg.Admin.Identity.issuers {\n\t\t// avoid import cycle with caddytls package, so manually duplicate the interface here, yuck\n\t\tif annoying, ok := issuer.(interface{ SetConfig(cfg *certmagic.Config) }); ok {\n\t\t\tannoying.SetConfig(cmCfg)\n\t\t}\n\t}\n\n\t// obtain and renew server identity certificate(s)\n\treturn cmCfg.ManageAsync(ctx, cfg.Admin.Identity.Identifiers)\n}\n\n// replaceRemoteAdminServer replaces the running remote admin server\n// according to the relevant configuration in cfg. It stops any previous\n// remote admin server and only starts a new one if configured.\nfunc replaceRemoteAdminServer(ctx Context, cfg *Config) error {\n\tif cfg == nil {\n\t\treturn nil\n\t}\n\n\tremoteLogger := Log().Named(\"admin.remote\")\n\n\toldAdminServer := remoteAdminServer\n\tdefer func() {\n\t\tif oldAdminServer != nil {\n\t\t\tgo func(oldAdminServer *http.Server) {\n\t\t\t\terr := stopAdminServer(oldAdminServer)\n\t\t\t\tif err != nil {\n\t\t\t\t\tLog().Named(\"admin\").Error(\"stopping current secure admin endpoint\", zap.Error(err))\n\t\t\t\t}\n\t\t\t}(oldAdminServer)\n\t\t}\n\t}()\n\n\tif cfg.Admin == nil || cfg.Admin.Remote == nil {\n\t\treturn nil\n\t}\n\n\taddr, err := parseAdminListenAddr(cfg.Admin.Remote.Listen, DefaultRemoteAdminListen)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// make the HTTP handler but disable Host/Origin enforcement\n\t// because we are using TLS authentication instead\n\thandler := cfg.Admin.newAdminHandler(addr, true, ctx)\n\n\t// create client certificate pool for TLS mutual auth, and extract public keys\n\t// so that we can enforce access controls at the application layer\n\tclientCertPool := x509.NewCertPool()\n\tfor i, accessControl := range cfg.Admin.Remote.AccessControl {\n\t\tfor j, certBase64 := range accessControl.PublicKeys {\n\t\t\tcert, err := decodeBase64DERCert(certBase64)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"access control %d public key %d: parsing base64 certificate DER: %v\", i, j, err)\n\t\t\t}\n\t\t\taccessControl.publicKeys = append(accessControl.publicKeys, cert.PublicKey)\n\t\t\tclientCertPool.AddCert(cert)\n\t\t}\n\t}\n\n\t// create TLS config that will enforce mutual authentication\n\tif identityCertCache == nil {\n\t\treturn fmt.Errorf(\"cannot enable remote admin without a certificate cache; configure identity management to initialize a certificate cache\")\n\t}\n\tcmCfg := cfg.Admin.Identity.certmagicConfig(remoteLogger, false)\n\ttlsConfig := cmCfg.TLSConfig()\n\ttlsConfig.NextProtos = nil // this server does not solve ACME challenges\n\ttlsConfig.ClientAuth = tls.RequireAndVerifyClientCert\n\ttlsConfig.ClientCAs = clientCertPool\n\n\t// convert logger to stdlib so it can be used by HTTP server\n\tserverLogger, err := zap.NewStdLogAt(remoteLogger, zap.DebugLevel)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tserverMu.Lock()\n\t// create secure HTTP server\n\tremoteAdminServer = &http.Server{\n\t\tAddr:              addr.String(), // for logging purposes only\n\t\tHandler:           handler,\n\t\tTLSConfig:         tlsConfig,\n\t\tReadTimeout:       10 * time.Second,\n\t\tReadHeaderTimeout: 5 * time.Second,\n\t\tIdleTimeout:       60 * time.Second,\n\t\tMaxHeaderBytes:    1024 * 64,\n\t\tErrorLog:          serverLogger,\n\t}\n\tserverMu.Unlock()\n\n\t// start listener\n\tlnAny, err := addr.Listen(ctx, 0, net.ListenConfig{})\n\tif err != nil {\n\t\treturn err\n\t}\n\tln := lnAny.(net.Listener)\n\tln = tls.NewListener(ln, tlsConfig)\n\n\tgo func() {\n\t\tserverMu.Lock()\n\t\tserver := remoteAdminServer\n\t\tserverMu.Unlock()\n\t\tif err := server.Serve(ln); !errors.Is(err, http.ErrServerClosed) {\n\t\t\tremoteLogger.Error(\"admin remote server shutdown for unknown reason\", zap.Error(err))\n\t\t}\n\t}()\n\n\tremoteLogger.Info(\"secure admin remote control endpoint started\",\n\t\tzap.String(\"address\", addr.String()))\n\n\treturn nil\n}\n\nfunc (ident *IdentityConfig) certmagicConfig(logger *zap.Logger, makeCache bool) *certmagic.Config {\n\tvar cmCfg *certmagic.Config\n\tif ident == nil {\n\t\t// user might not have configured identity; that's OK, we can still make a\n\t\t// certmagic config, although it'll be mostly useless for remote management\n\t\tident = new(IdentityConfig)\n\t}\n\ttemplate := certmagic.Config{\n\t\tStorage: DefaultStorage, // do not act as part of a cluster (this is for the server's local identity)\n\t\tLogger:  logger,\n\t\tIssuers: ident.issuers,\n\t}\n\tif makeCache {\n\t\tidentityCertCache = certmagic.NewCache(certmagic.CacheOptions{\n\t\t\tGetConfigForCert: func(certmagic.Certificate) (*certmagic.Config, error) {\n\t\t\t\treturn cmCfg, nil\n\t\t\t},\n\t\t\tLogger: logger.Named(\"cache\"),\n\t\t})\n\t}\n\tcmCfg = certmagic.New(identityCertCache, template)\n\treturn cmCfg\n}\n\n// IdentityCredentials returns this instance's configured, managed identity credentials\n// that can be used in TLS client authentication.\nfunc (ctx Context) IdentityCredentials(logger *zap.Logger) ([]tls.Certificate, error) {\n\tif ctx.cfg == nil || ctx.cfg.Admin == nil || ctx.cfg.Admin.Identity == nil {\n\t\treturn nil, fmt.Errorf(\"no server identity configured\")\n\t}\n\tident := ctx.cfg.Admin.Identity\n\tif len(ident.Identifiers) == 0 {\n\t\treturn nil, fmt.Errorf(\"no identifiers configured\")\n\t}\n\tif logger == nil {\n\t\tlogger = Log()\n\t}\n\tmagic := ident.certmagicConfig(logger, false)\n\treturn magic.ClientCredentials(ctx, ident.Identifiers)\n}\n\n// enforceAccessControls enforces application-layer access controls for r based on remote.\n// It expects that the TLS server has already established at least one verified chain of\n// trust, and then looks for a matching, authorized public key that is allowed to access\n// the defined path(s) using the defined method(s).\nfunc (remote RemoteAdmin) enforceAccessControls(r *http.Request) error {\n\tfor _, chain := range r.TLS.VerifiedChains {\n\t\tfor _, peerCert := range chain {\n\t\t\tfor _, adminAccess := range remote.AccessControl {\n\t\t\t\tfor _, allowedKey := range adminAccess.publicKeys {\n\t\t\t\t\t// see if we found a matching public key; the TLS server already verified the chain\n\t\t\t\t\t// so we know the client possesses the associated private key; this handy interface\n\t\t\t\t\t// doesn't appear to be defined anywhere in the std lib, but was implemented here:\n\t\t\t\t\t// https://github.com/golang/go/commit/b5f2c0f50297fa5cd14af668ddd7fd923626cf8c\n\t\t\t\t\tcomparer, ok := peerCert.PublicKey.(interface{ Equal(crypto.PublicKey) bool })\n\t\t\t\t\tif !ok || !comparer.Equal(allowedKey) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\t// key recognized; make sure its HTTP request is permitted\n\t\t\t\t\tfor _, accessPerm := range adminAccess.Permissions {\n\t\t\t\t\t\t// verify method\n\t\t\t\t\t\tmethodFound := accessPerm.Methods == nil || slices.Contains(accessPerm.Methods, r.Method)\n\t\t\t\t\t\tif !methodFound {\n\t\t\t\t\t\t\treturn APIError{\n\t\t\t\t\t\t\t\tHTTPStatus: http.StatusForbidden,\n\t\t\t\t\t\t\t\tMessage:    \"not authorized to use this method\",\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// verify path\n\t\t\t\t\t\tpathFound := accessPerm.Paths == nil\n\t\t\t\t\t\tfor _, allowedPath := range accessPerm.Paths {\n\t\t\t\t\t\t\tif strings.HasPrefix(r.URL.Path, allowedPath) {\n\t\t\t\t\t\t\t\tpathFound = true\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif !pathFound {\n\t\t\t\t\t\t\treturn APIError{\n\t\t\t\t\t\t\t\tHTTPStatus: http.StatusForbidden,\n\t\t\t\t\t\t\t\tMessage:    \"not authorized to access this path\",\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// public key authorized, method and path allowed\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// in theory, this should never happen; with an unverified chain, the TLS server\n\t// should not accept the connection in the first place, and the acceptable cert\n\t// pool is configured using the same list of public keys we verify against\n\treturn APIError{\n\t\tHTTPStatus: http.StatusUnauthorized,\n\t\tMessage:    \"client identity not authorized\",\n\t}\n}\n\nfunc stopAdminServer(srv *http.Server) error {\n\tif srv == nil {\n\t\treturn fmt.Errorf(\"no admin server\")\n\t}\n\tctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n\tdefer cancel()\n\terr := srv.Shutdown(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"shutting down admin server: %v\", err)\n\t}\n\tLog().Named(\"admin\").Info(\"stopped previous server\", zap.String(\"address\", srv.Addr))\n\treturn nil\n}\n\n// AdminRouter is a type which can return routes for the admin API.\ntype AdminRouter interface {\n\tRoutes() []AdminRoute\n}\n\n// AdminRoute represents a route for the admin endpoint.\ntype AdminRoute struct {\n\tPattern string\n\tHandler AdminHandler\n}\n\ntype adminHandler struct {\n\tmux *http.ServeMux\n\n\t// security for local/plaintext endpoint\n\tenforceOrigin  bool\n\tenforceHost    bool\n\tallowedOrigins []*url.URL\n\n\t// security for remote/encrypted endpoint\n\tremoteControl *RemoteAdmin\n}\n\n// ServeHTTP is the external entry point for API requests.\n// It will only be called once per request.\nfunc (h adminHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tip, port, err := net.SplitHostPort(r.RemoteAddr)\n\tif err != nil {\n\t\tip = r.RemoteAddr\n\t\tport = \"\"\n\t}\n\tlog := Log().Named(\"admin.api\").With(\n\t\tzap.String(\"method\", r.Method),\n\t\tzap.String(\"host\", r.Host),\n\t\tzap.String(\"uri\", r.RequestURI),\n\t\tzap.String(\"remote_ip\", ip),\n\t\tzap.String(\"remote_port\", port),\n\t\tzap.Reflect(\"headers\", r.Header),\n\t)\n\tif r.TLS != nil {\n\t\tlog = log.With(\n\t\t\tzap.Bool(\"secure\", true),\n\t\t\tzap.Int(\"verified_chains\", len(r.TLS.VerifiedChains)),\n\t\t)\n\t}\n\tif r.RequestURI == \"/metrics\" {\n\t\tlog.Debug(\"received request\")\n\t} else {\n\t\tlog.Info(\"received request\")\n\t}\n\th.serveHTTP(w, r)\n}\n\n// serveHTTP is the internal entry point for API requests. It may\n// be called more than once per request, for example if a request\n// is rewritten (i.e. internal redirect).\nfunc (h adminHandler) serveHTTP(w http.ResponseWriter, r *http.Request) {\n\tif h.remoteControl != nil {\n\t\t// enforce access controls on secure endpoint\n\t\tif err := h.remoteControl.enforceAccessControls(r); err != nil {\n\t\t\th.handleError(w, r, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif strings.Contains(r.Header.Get(\"Upgrade\"), \"websocket\") {\n\t\t// I've never been able demonstrate a vulnerability myself, but apparently\n\t\t// WebSocket connections originating from browsers aren't subject to CORS\n\t\t// restrictions, so we'll just be on the safe side\n\t\th.handleError(w, r, fmt.Errorf(\"websocket connections aren't allowed\"))\n\t\treturn\n\t}\n\n\tif h.enforceHost {\n\t\t// DNS rebinding mitigation\n\t\terr := h.checkHost(r)\n\t\tif err != nil {\n\t\t\th.handleError(w, r, err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif h.enforceOrigin {\n\t\t// cross-site mitigation\n\t\torigin, err := h.checkOrigin(r)\n\t\tif err != nil {\n\t\t\th.handleError(w, r, err)\n\t\t\treturn\n\t\t}\n\n\t\tif r.Method == http.MethodOptions {\n\t\t\tw.Header().Set(\"Access-Control-Allow-Methods\", \"OPTIONS, GET, POST, PUT, PATCH, DELETE\")\n\t\t\tw.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type, Content-Length, Cache-Control\")\n\t\t\tw.Header().Set(\"Access-Control-Allow-Credentials\", \"true\")\n\t\t}\n\t\tw.Header().Set(\"Access-Control-Allow-Origin\", origin)\n\t}\n\n\th.mux.ServeHTTP(w, r)\n}\n\nfunc (h adminHandler) handleError(w http.ResponseWriter, r *http.Request, err error) {\n\tif err == nil {\n\t\treturn\n\t}\n\tif err == errInternalRedir {\n\t\th.serveHTTP(w, r)\n\t\treturn\n\t}\n\n\tapiErr, ok := err.(APIError)\n\tif !ok {\n\t\tapiErr = APIError{\n\t\t\tHTTPStatus: http.StatusInternalServerError,\n\t\t\tErr:        err,\n\t\t}\n\t}\n\tif apiErr.HTTPStatus == 0 {\n\t\tapiErr.HTTPStatus = http.StatusInternalServerError\n\t}\n\tif apiErr.Message == \"\" && apiErr.Err != nil {\n\t\tapiErr.Message = apiErr.Err.Error()\n\t}\n\n\tLog().Named(\"admin.api\").Error(\"request error\",\n\t\tzap.Error(err),\n\t\tzap.Int(\"status_code\", apiErr.HTTPStatus),\n\t)\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(apiErr.HTTPStatus)\n\tencErr := json.NewEncoder(w).Encode(apiErr)\n\tif encErr != nil {\n\t\tLog().Named(\"admin.api\").Error(\"failed to encode error response\", zap.Error(encErr))\n\t}\n}\n\n// checkHost returns a handler that wraps next such that\n// it will only be called if the request's Host header matches\n// a trustworthy/expected value. This helps to mitigate DNS\n// rebinding attacks.\nfunc (h adminHandler) checkHost(r *http.Request) error {\n\tallowed := slices.ContainsFunc(h.allowedOrigins, func(u *url.URL) bool {\n\t\treturn r.Host == u.Host\n\t})\n\tif !allowed {\n\t\treturn APIError{\n\t\t\tHTTPStatus: http.StatusForbidden,\n\t\t\tErr:        fmt.Errorf(\"host not allowed: %s\", r.Host),\n\t\t}\n\t}\n\treturn nil\n}\n\n// checkOrigin ensures that the Origin header, if\n// set, matches the intended target; prevents arbitrary\n// sites from issuing requests to our listener. It\n// returns the origin that was obtained from r.\nfunc (h adminHandler) checkOrigin(r *http.Request) (string, error) {\n\toriginStr, origin := h.getOrigin(r)\n\tif origin == nil {\n\t\treturn \"\", APIError{\n\t\t\tHTTPStatus: http.StatusForbidden,\n\t\t\tErr:        fmt.Errorf(\"required Origin header is missing or invalid\"),\n\t\t}\n\t}\n\tif !h.originAllowed(origin) {\n\t\treturn \"\", APIError{\n\t\t\tHTTPStatus: http.StatusForbidden,\n\t\t\tErr:        fmt.Errorf(\"client is not allowed to access from origin '%s'\", originStr),\n\t\t}\n\t}\n\treturn origin.String(), nil\n}\n\nfunc (h adminHandler) getOrigin(r *http.Request) (string, *url.URL) {\n\torigin := r.Header.Get(\"Origin\")\n\tif origin == \"\" {\n\t\torigin = r.Header.Get(\"Referer\")\n\t}\n\toriginURL, err := url.Parse(origin)\n\tif err != nil {\n\t\treturn origin, nil\n\t}\n\toriginURL.Path = \"\"\n\toriginURL.RawPath = \"\"\n\toriginURL.Fragment = \"\"\n\toriginURL.RawFragment = \"\"\n\toriginURL.RawQuery = \"\"\n\treturn origin, originURL\n}\n\nfunc (h adminHandler) originAllowed(origin *url.URL) bool {\n\tfor _, allowedOrigin := range h.allowedOrigins {\n\t\tif allowedOrigin.Scheme != \"\" && origin.Scheme != allowedOrigin.Scheme {\n\t\t\tcontinue\n\t\t}\n\t\tif origin.Host == allowedOrigin.Host {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// etagHasher returns a the hasher we used on the config to both\n// produce and verify ETags.\nfunc etagHasher() hash.Hash { return xxhash.New() }\n\n// makeEtag returns an Etag header value (including quotes) for\n// the given config path and hash of contents at that path.\nfunc makeEtag(path string, hash hash.Hash) string {\n\treturn fmt.Sprintf(`\"%s %x\"`, path, hash.Sum(nil))\n}\n\n// This buffer pool is used to keep buffers for\n// reading the config file during eTag header generation\nvar bufferPool = sync.Pool{\n\tNew: func() any {\n\t\treturn new(bytes.Buffer)\n\t},\n}\n\nfunc handleConfig(w http.ResponseWriter, r *http.Request) error {\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\thash := etagHasher()\n\n\t\t// Read the config into a buffer instead of writing directly to\n\t\t// the response writer, as we want to set the ETag as the header,\n\t\t// not the trailer.\n\t\tbuf := bufferPool.Get().(*bytes.Buffer)\n\t\tbuf.Reset()\n\t\tdefer bufferPool.Put(buf)\n\n\t\tconfigWriter := io.MultiWriter(buf, hash)\n\t\terr := readConfig(r.URL.Path, configWriter)\n\t\tif err != nil {\n\t\t\treturn APIError{HTTPStatus: http.StatusBadRequest, Err: err}\n\t\t}\n\n\t\t// we could consider setting up a sync.Pool for the summed\n\t\t// hashes to reduce GC pressure.\n\t\tw.Header().Set(\"Etag\", makeEtag(r.URL.Path, hash))\n\t\t_, err = w.Write(buf.Bytes())\n\t\tif err != nil {\n\t\t\treturn APIError{HTTPStatus: http.StatusInternalServerError, Err: err}\n\t\t}\n\n\t\treturn nil\n\n\tcase http.MethodPost,\n\t\thttp.MethodPut,\n\t\thttp.MethodPatch,\n\t\thttp.MethodDelete:\n\n\t\t// DELETE does not use a body, but the others do\n\t\tvar body []byte\n\t\tif r.Method != http.MethodDelete {\n\t\t\tif ct := r.Header.Get(\"Content-Type\"); !strings.Contains(ct, \"/json\") {\n\t\t\t\treturn APIError{\n\t\t\t\t\tHTTPStatus: http.StatusBadRequest,\n\t\t\t\t\tErr:        fmt.Errorf(\"unacceptable content-type: %v; 'application/json' required\", ct),\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbuf := bufPool.Get().(*bytes.Buffer)\n\t\t\tbuf.Reset()\n\t\t\tdefer bufPool.Put(buf)\n\n\t\t\t_, err := io.Copy(buf, r.Body)\n\t\t\tif err != nil {\n\t\t\t\treturn APIError{\n\t\t\t\t\tHTTPStatus: http.StatusBadRequest,\n\t\t\t\t\tErr:        fmt.Errorf(\"reading request body: %v\", err),\n\t\t\t\t}\n\t\t\t}\n\t\t\tbody = buf.Bytes()\n\t\t}\n\n\t\tforceReload := r.Header.Get(\"Cache-Control\") == \"must-revalidate\"\n\n\t\terr := changeConfig(r.Method, r.URL.Path, body, r.Header.Get(\"If-Match\"), forceReload)\n\t\tif err != nil && !errors.Is(err, errSameConfig) {\n\t\t\treturn err\n\t\t}\n\n\tdefault:\n\t\treturn APIError{\n\t\t\tHTTPStatus: http.StatusMethodNotAllowed,\n\t\t\tErr:        fmt.Errorf(\"method %s not allowed\", r.Method),\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc handleConfigID(w http.ResponseWriter, r *http.Request) error {\n\tidPath := r.URL.Path\n\n\tparts := strings.Split(idPath, \"/\")\n\tif len(parts) < 3 || parts[2] == \"\" {\n\t\treturn APIError{\n\t\t\tHTTPStatus: http.StatusBadRequest,\n\t\t\tErr:        fmt.Errorf(\"request path is missing object ID\"),\n\t\t}\n\t}\n\tif parts[0] != \"\" || parts[1] != \"id\" {\n\t\treturn APIError{\n\t\t\tHTTPStatus: http.StatusBadRequest,\n\t\t\tErr:        fmt.Errorf(\"malformed object path\"),\n\t\t}\n\t}\n\tid := parts[2]\n\n\t// map the ID to the expanded path\n\trawCfgMu.RLock()\n\texpanded, ok := rawCfgIndex[id]\n\trawCfgMu.RUnlock()\n\tif !ok {\n\t\treturn APIError{\n\t\t\tHTTPStatus: http.StatusNotFound,\n\t\t\tErr:        fmt.Errorf(\"unknown object ID '%s'\", id),\n\t\t}\n\t}\n\n\t// piece the full URL path back together\n\tparts = append([]string{expanded}, parts[3:]...)\n\tr.URL.Path = path.Join(parts...)\n\n\treturn errInternalRedir\n}\n\nfunc handleStop(w http.ResponseWriter, r *http.Request) error {\n\tif r.Method != http.MethodPost {\n\t\treturn APIError{\n\t\t\tHTTPStatus: http.StatusMethodNotAllowed,\n\t\t\tErr:        fmt.Errorf(\"method not allowed\"),\n\t\t}\n\t}\n\n\texitProcess(context.Background(), Log().Named(\"admin.api\"))\n\treturn nil\n}\n\n// unsyncedConfigAccess traverses into the current config and performs\n// the operation at path according to method, using body and out as\n// needed. This is a low-level, unsynchronized function; most callers\n// will want to use changeConfig or readConfig instead. This requires a\n// read or write lock on currentCtxMu, depending on method (GET needs\n// only a read lock; all others need a write lock).\nfunc unsyncedConfigAccess(method, path string, body []byte, out io.Writer) error {\n\tvar err error\n\tvar val any\n\n\t// if there is a request body, decode it into the\n\t// variable that will be set in the config according\n\t// to method and path\n\tif len(body) > 0 {\n\t\terr = json.Unmarshal(body, &val)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"decoding request body: %v\", err)\n\t\t}\n\t}\n\n\tenc := json.NewEncoder(out)\n\n\tcleanPath := strings.Trim(path, \"/\")\n\tif cleanPath == \"\" {\n\t\treturn fmt.Errorf(\"no traversable path\")\n\t}\n\n\tparts := strings.Split(cleanPath, \"/\")\n\tif len(parts) == 0 {\n\t\treturn fmt.Errorf(\"path missing\")\n\t}\n\n\t// A path that ends with \"...\" implies:\n\t// 1) the part before it is an array\n\t// 2) the payload is an array\n\t// and means that the user wants to expand the elements\n\t// in the payload array and append each one into the\n\t// destination array, like so:\n\t//     array = append(array, elems...)\n\t// This special case is handled below.\n\tellipses := parts[len(parts)-1] == \"...\"\n\tif ellipses {\n\t\tparts = parts[:len(parts)-1]\n\t}\n\n\tvar ptr any = rawCfg\n\ntraverseLoop:\n\tfor i, part := range parts {\n\t\tswitch v := ptr.(type) {\n\t\tcase map[string]any:\n\t\t\t// if the next part enters a slice, and the slice is our destination,\n\t\t\t// handle it specially (because appending to the slice copies the slice\n\t\t\t// header, which does not replace the original one like we want)\n\t\t\tif arr, ok := v[part].([]any); ok && i == len(parts)-2 {\n\t\t\t\tvar idx int\n\t\t\t\tif method != http.MethodPost {\n\t\t\t\t\tidxStr := parts[len(parts)-1]\n\t\t\t\t\tidx, err = strconv.Atoi(idxStr)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"[%s] invalid array index '%s': %v\",\n\t\t\t\t\t\t\tpath, idxStr, err)\n\t\t\t\t\t}\n\t\t\t\t\tif idx < 0 || idx >= len(arr) {\n\t\t\t\t\t\treturn fmt.Errorf(\"[%s] array index out of bounds: %s\", path, idxStr)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch method {\n\t\t\t\tcase http.MethodGet:\n\t\t\t\t\terr = enc.Encode(arr[idx])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"encoding config: %v\", err)\n\t\t\t\t\t}\n\t\t\t\tcase http.MethodPost:\n\t\t\t\t\tif ellipses {\n\t\t\t\t\t\tvalArray, ok := val.([]any)\n\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\treturn fmt.Errorf(\"final element is not an array\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv[part] = append(arr, valArray...)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv[part] = append(arr, val)\n\t\t\t\t\t}\n\t\t\t\tcase http.MethodPut:\n\t\t\t\t\t// avoid creation of new slice and a second copy (see\n\t\t\t\t\t// https://github.com/golang/go/wiki/SliceTricks#insert)\n\t\t\t\t\tarr = append(arr, nil)\n\t\t\t\t\tcopy(arr[idx+1:], arr[idx:])\n\t\t\t\t\tarr[idx] = val\n\t\t\t\t\tv[part] = arr\n\t\t\t\tcase http.MethodPatch:\n\t\t\t\t\tarr[idx] = val\n\t\t\t\tcase http.MethodDelete:\n\t\t\t\t\tv[part] = append(arr[:idx], arr[idx+1:]...)\n\t\t\t\tdefault:\n\t\t\t\t\treturn fmt.Errorf(\"unrecognized method %s\", method)\n\t\t\t\t}\n\t\t\t\tbreak traverseLoop\n\t\t\t}\n\n\t\t\tif i == len(parts)-1 {\n\t\t\t\tswitch method {\n\t\t\t\tcase http.MethodGet:\n\t\t\t\t\terr = enc.Encode(v[part])\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"encoding config: %v\", err)\n\t\t\t\t\t}\n\t\t\t\tcase http.MethodPost:\n\t\t\t\t\t// if the part is an existing list, POST appends to\n\t\t\t\t\t// it, otherwise it just sets or creates the value\n\t\t\t\t\tif arr, ok := v[part].([]any); ok {\n\t\t\t\t\t\tif ellipses {\n\t\t\t\t\t\t\tvalArray, ok := val.([]any)\n\t\t\t\t\t\t\tif !ok {\n\t\t\t\t\t\t\t\treturn fmt.Errorf(\"final element is not an array\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tv[part] = append(arr, valArray...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tv[part] = append(arr, val)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv[part] = val\n\t\t\t\t\t}\n\t\t\t\tcase http.MethodPut:\n\t\t\t\t\tif _, ok := v[part]; ok {\n\t\t\t\t\t\treturn APIError{\n\t\t\t\t\t\t\tHTTPStatus: http.StatusConflict,\n\t\t\t\t\t\t\tErr:        fmt.Errorf(\"[%s] key already exists: %s\", path, part),\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv[part] = val\n\t\t\t\tcase http.MethodPatch:\n\t\t\t\t\tif _, ok := v[part]; !ok {\n\t\t\t\t\t\treturn APIError{\n\t\t\t\t\t\t\tHTTPStatus: http.StatusNotFound,\n\t\t\t\t\t\t\tErr:        fmt.Errorf(\"[%s] key does not exist: %s\", path, part),\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv[part] = val\n\t\t\t\tcase http.MethodDelete:\n\t\t\t\t\tif _, ok := v[part]; !ok {\n\t\t\t\t\t\treturn APIError{\n\t\t\t\t\t\t\tHTTPStatus: http.StatusNotFound,\n\t\t\t\t\t\t\tErr:        fmt.Errorf(\"[%s] key does not exist: %s\", path, part),\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdelete(v, part)\n\t\t\t\tdefault:\n\t\t\t\t\treturn fmt.Errorf(\"unrecognized method %s\", method)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// if we are \"PUTting\" a new resource, the key(s) in its path\n\t\t\t\t// might not exist yet; that's OK but we need to make them as\n\t\t\t\t// we go, while we still have a pointer from the level above\n\t\t\t\tif v[part] == nil && method == http.MethodPut {\n\t\t\t\t\tv[part] = make(map[string]any)\n\t\t\t\t}\n\t\t\t\tptr = v[part]\n\t\t\t}\n\n\t\tcase []any:\n\t\t\tpartInt, err := strconv.Atoi(part)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"[/%s] invalid array index '%s': %v\",\n\t\t\t\t\tstrings.Join(parts[:i+1], \"/\"), part, err)\n\t\t\t}\n\t\t\tif partInt < 0 || partInt >= len(v) {\n\t\t\t\treturn fmt.Errorf(\"[/%s] array index out of bounds: %s\",\n\t\t\t\t\tstrings.Join(parts[:i+1], \"/\"), part)\n\t\t\t}\n\t\t\tptr = v[partInt]\n\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"invalid traversal path at: %s\", strings.Join(parts[:i+1], \"/\"))\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// RemoveMetaFields removes meta fields like \"@id\" from a JSON message\n// by using a simple regular expression. (An alternate way to do this\n// would be to delete them from the raw, map[string]any\n// representation as they are indexed, then iterate the index we made\n// and add them back after encoding as JSON, but this is simpler.)\nfunc RemoveMetaFields(rawJSON []byte) []byte {\n\treturn idRegexp.ReplaceAllFunc(rawJSON, func(in []byte) []byte {\n\t\t// matches with a comma on both sides (when \"@id\" property is\n\t\t// not the first or last in the object) need to keep exactly\n\t\t// one comma for correct JSON syntax\n\t\tcomma := []byte{','}\n\t\tif bytes.HasPrefix(in, comma) && bytes.HasSuffix(in, comma) {\n\t\t\treturn comma\n\t\t}\n\t\treturn []byte{}\n\t})\n}\n\n// AdminHandler is like http.Handler except ServeHTTP may return an error.\n//\n// If any handler encounters an error, it should be returned for proper\n// handling.\ntype AdminHandler interface {\n\tServeHTTP(http.ResponseWriter, *http.Request) error\n}\n\n// AdminHandlerFunc is a convenience type like http.HandlerFunc.\ntype AdminHandlerFunc func(http.ResponseWriter, *http.Request) error\n\n// ServeHTTP implements the Handler interface.\nfunc (f AdminHandlerFunc) ServeHTTP(w http.ResponseWriter, r *http.Request) error {\n\treturn f(w, r)\n}\n\n// APIError is a structured error that every API\n// handler should return for consistency in logging\n// and client responses. If Message is unset, then\n// Err.Error() will be serialized in its place.\ntype APIError struct {\n\tHTTPStatus int    `json:\"-\"`\n\tErr        error  `json:\"-\"`\n\tMessage    string `json:\"error\"`\n}\n\nfunc (e APIError) Error() string {\n\tif e.Err != nil {\n\t\treturn e.Err.Error()\n\t}\n\treturn e.Message\n}\n\n// parseAdminListenAddr extracts a singular listen address from either addr\n// or defaultAddr, returning the network and the address of the listener.\nfunc parseAdminListenAddr(addr string, defaultAddr string) (NetworkAddress, error) {\n\tinput, err := NewReplacer().ReplaceOrErr(addr, true, true)\n\tif err != nil {\n\t\treturn NetworkAddress{}, fmt.Errorf(\"replacing listen address: %v\", err)\n\t}\n\tif input == \"\" {\n\t\tinput = defaultAddr\n\t}\n\tlistenAddr, err := ParseNetworkAddress(input)\n\tif err != nil {\n\t\treturn NetworkAddress{}, fmt.Errorf(\"parsing listener address: %v\", err)\n\t}\n\tif listenAddr.PortRangeSize() != 1 {\n\t\treturn NetworkAddress{}, fmt.Errorf(\"must be exactly one listener address; cannot listen on: %s\", listenAddr)\n\t}\n\treturn listenAddr, nil\n}\n\n// decodeBase64DERCert base64-decodes, then DER-decodes, certStr.\nfunc decodeBase64DERCert(certStr string) (*x509.Certificate, error) {\n\tderBytes, err := base64.StdEncoding.DecodeString(certStr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn x509.ParseCertificate(derBytes)\n}\n\ntype loggableURLArray []*url.URL\n\nfunc (ua loggableURLArray) MarshalLogArray(enc zapcore.ArrayEncoder) error {\n\tif ua == nil {\n\t\treturn nil\n\t}\n\tfor _, u := range ua {\n\t\tenc.AppendString(u.String())\n\t}\n\treturn nil\n}\n\nvar (\n\t// DefaultAdminListen is the address for the local admin\n\t// listener, if none is specified at startup.\n\tDefaultAdminListen = \"localhost:2019\"\n\n\t// DefaultRemoteAdminListen is the address for the remote\n\t// (TLS-authenticated) admin listener, if enabled and not\n\t// specified otherwise.\n\tDefaultRemoteAdminListen = \":2021\"\n)\n\n// PIDFile writes a pidfile to the file at filename. It\n// will get deleted before the process gracefully exits.\nfunc PIDFile(filename string) error {\n\tpid := []byte(strconv.Itoa(os.Getpid()) + \"\\n\")\n\terr := os.WriteFile(filename, pid, 0o600)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpidfile = filename\n\treturn nil\n}\n\n// idRegexp is used to match ID fields and their associated values\n// in the config. It also matches adjacent commas so that syntax\n// can be preserved no matter where in the object the field appears.\n// It supports string and most numeric values.\nvar idRegexp = regexp.MustCompile(`(?m),?\\s*\"` + idKey + `\"\\s*:\\s*(-?[0-9]+(\\.[0-9]+)?|(?U)\".*\")\\s*,?`)\n\n// pidfile is the name of the pidfile, if any.\nvar pidfile string\n\n// errInternalRedir indicates an internal redirect\n// and is useful when admin API handlers rewrite\n// the request; in that case, authentication and\n// authorization needs to happen again for the\n// rewritten request.\nvar errInternalRedir = fmt.Errorf(\"internal redirect; re-authorization required\")\n\nconst (\n\trawConfigKey = \"config\"\n\tidKey        = \"@id\"\n)\n\nvar bufPool = sync.Pool{\n\tNew: func() any {\n\t\treturn new(bytes.Buffer)\n\t},\n}\n\n// keep a reference to admin endpoint singletons while they're active\nvar (\n\tserverMu                            sync.Mutex\n\tlocalAdminServer, remoteAdminServer *http.Server\n\tidentityCertCache                   *certmagic.Cache\n)\n"
        },
        {
          "name": "admin_test.go",
          "type": "blob",
          "size": 5.654296875,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"sync\"\n\t\"testing\"\n)\n\nvar testCfg = []byte(`{\n\t\t\t\"apps\": {\n\t\t\t\t\"http\": {\n\t\t\t\t\t\"servers\": {\n\t\t\t\t\t\t\"myserver\": {\n\t\t\t\t\t\t\t\"listen\": [\"tcp/localhost:8080-8084\"],\n\t\t\t\t\t\t\t\"read_timeout\": \"30s\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"yourserver\": {\n\t\t\t\t\t\t\t\"listen\": [\"127.0.0.1:5000\"],\n\t\t\t\t\t\t\t\"read_header_timeout\": \"15s\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t`)\n\nfunc TestUnsyncedConfigAccess(t *testing.T) {\n\t// each test is performed in sequence, so\n\t// each change builds on the previous ones;\n\t// the config is not reset between tests\n\tfor i, tc := range []struct {\n\t\tmethod    string\n\t\tpath      string // rawConfigKey will be prepended\n\t\tpayload   string\n\t\texpect    string // JSON representation of what the whole config is expected to be after the request\n\t\tshouldErr bool\n\t}{\n\t\t{\n\t\t\tmethod:  \"POST\",\n\t\t\tpath:    \"\",\n\t\t\tpayload: `{\"foo\": \"bar\", \"list\": [\"a\", \"b\", \"c\"]}`, // starting value\n\t\t\texpect:  `{\"foo\": \"bar\", \"list\": [\"a\", \"b\", \"c\"]}`,\n\t\t},\n\t\t{\n\t\t\tmethod:  \"POST\",\n\t\t\tpath:    \"/foo\",\n\t\t\tpayload: `\"jet\"`,\n\t\t\texpect:  `{\"foo\": \"jet\", \"list\": [\"a\", \"b\", \"c\"]}`,\n\t\t},\n\t\t{\n\t\t\tmethod:  \"POST\",\n\t\t\tpath:    \"/bar\",\n\t\t\tpayload: `{\"aa\": \"bb\", \"qq\": \"zz\"}`,\n\t\t\texpect:  `{\"foo\": \"jet\", \"bar\": {\"aa\": \"bb\", \"qq\": \"zz\"}, \"list\": [\"a\", \"b\", \"c\"]}`,\n\t\t},\n\t\t{\n\t\t\tmethod: \"DELETE\",\n\t\t\tpath:   \"/bar/qq\",\n\t\t\texpect: `{\"foo\": \"jet\", \"bar\": {\"aa\": \"bb\"}, \"list\": [\"a\", \"b\", \"c\"]}`,\n\t\t},\n\t\t{\n\t\t\tmethod:    \"DELETE\",\n\t\t\tpath:      \"/bar/qq\",\n\t\t\texpect:    `{\"foo\": \"jet\", \"bar\": {\"aa\": \"bb\"}, \"list\": [\"a\", \"b\", \"c\"]}`,\n\t\t\tshouldErr: true,\n\t\t},\n\t\t{\n\t\t\tmethod:  \"POST\",\n\t\t\tpath:    \"/list\",\n\t\t\tpayload: `\"e\"`,\n\t\t\texpect:  `{\"foo\": \"jet\", \"bar\": {\"aa\": \"bb\"}, \"list\": [\"a\", \"b\", \"c\", \"e\"]}`,\n\t\t},\n\t\t{\n\t\t\tmethod:  \"PUT\",\n\t\t\tpath:    \"/list/3\",\n\t\t\tpayload: `\"d\"`,\n\t\t\texpect:  `{\"foo\": \"jet\", \"bar\": {\"aa\": \"bb\"}, \"list\": [\"a\", \"b\", \"c\", \"d\", \"e\"]}`,\n\t\t},\n\t\t{\n\t\t\tmethod: \"DELETE\",\n\t\t\tpath:   \"/list/3\",\n\t\t\texpect: `{\"foo\": \"jet\", \"bar\": {\"aa\": \"bb\"}, \"list\": [\"a\", \"b\", \"c\", \"e\"]}`,\n\t\t},\n\t\t{\n\t\t\tmethod:  \"PATCH\",\n\t\t\tpath:    \"/list/3\",\n\t\t\tpayload: `\"d\"`,\n\t\t\texpect:  `{\"foo\": \"jet\", \"bar\": {\"aa\": \"bb\"}, \"list\": [\"a\", \"b\", \"c\", \"d\"]}`,\n\t\t},\n\t\t{\n\t\t\tmethod:  \"POST\",\n\t\t\tpath:    \"/list/...\",\n\t\t\tpayload: `[\"e\", \"f\", \"g\"]`,\n\t\t\texpect:  `{\"foo\": \"jet\", \"bar\": {\"aa\": \"bb\"}, \"list\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]}`,\n\t\t},\n\t} {\n\t\terr := unsyncedConfigAccess(tc.method, rawConfigKey+tc.path, []byte(tc.payload), nil)\n\n\t\tif tc.shouldErr && err == nil {\n\t\t\tt.Fatalf(\"Test %d: Expected error return value, but got: %v\", i, err)\n\t\t}\n\t\tif !tc.shouldErr && err != nil {\n\t\t\tt.Fatalf(\"Test %d: Should not have had error return value, but got: %v\", i, err)\n\t\t}\n\n\t\t// decode the expected config so we can do a convenient DeepEqual\n\t\tvar expectedDecoded any\n\t\terr = json.Unmarshal([]byte(tc.expect), &expectedDecoded)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Test %d: Unmarshaling expected config: %v\", i, err)\n\t\t}\n\n\t\t// make sure the resulting config is as we expect it\n\t\tif !reflect.DeepEqual(rawCfg[rawConfigKey], expectedDecoded) {\n\t\t\tt.Fatalf(\"Test %d:\\nExpected:\\n\\t%#v\\nActual:\\n\\t%#v\",\n\t\t\t\ti, expectedDecoded, rawCfg[rawConfigKey])\n\t\t}\n\t}\n}\n\n// TestLoadConcurrent exercises Load under concurrent conditions\n// and is most useful under test with `-race` enabled.\nfunc TestLoadConcurrent(t *testing.T) {\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 100; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\t_ = Load(testCfg, true)\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\ntype fooModule struct {\n\tIntField int\n\tStrField string\n}\n\nfunc (fooModule) CaddyModule() ModuleInfo {\n\treturn ModuleInfo{\n\t\tID:  \"foo\",\n\t\tNew: func() Module { return new(fooModule) },\n\t}\n}\nfunc (fooModule) Start() error { return nil }\nfunc (fooModule) Stop() error  { return nil }\n\nfunc TestETags(t *testing.T) {\n\tRegisterModule(fooModule{})\n\n\tif err := Load([]byte(`{\"admin\": {\"listen\": \"localhost:2999\"}, \"apps\": {\"foo\": {\"strField\": \"abc\", \"intField\": 0}}}`), true); err != nil {\n\t\tt.Fatalf(\"loading: %s\", err)\n\t}\n\n\tconst key = \"/\" + rawConfigKey + \"/apps/foo\"\n\n\t// try update the config with the wrong etag\n\terr := changeConfig(http.MethodPost, key, []byte(`{\"strField\": \"abc\", \"intField\": 1}}`), fmt.Sprintf(`\"/%s not_an_etag\"`, rawConfigKey), false)\n\tif apiErr, ok := err.(APIError); !ok || apiErr.HTTPStatus != http.StatusPreconditionFailed {\n\t\tt.Fatalf(\"expected precondition failed; got %v\", err)\n\t}\n\n\t// get the etag\n\thash := etagHasher()\n\tif err := readConfig(key, hash); err != nil {\n\t\tt.Fatalf(\"reading: %s\", err)\n\t}\n\n\t// do the same update with the correct key\n\terr = changeConfig(http.MethodPost, key, []byte(`{\"strField\": \"abc\", \"intField\": 1}`), makeEtag(key, hash), false)\n\tif err != nil {\n\t\tt.Fatalf(\"expected update to work; got %v\", err)\n\t}\n\n\t// now try another update. The hash should no longer match and we should get precondition failed\n\terr = changeConfig(http.MethodPost, key, []byte(`{\"strField\": \"abc\", \"intField\": 2}`), makeEtag(key, hash), false)\n\tif apiErr, ok := err.(APIError); !ok || apiErr.HTTPStatus != http.StatusPreconditionFailed {\n\t\tt.Fatalf(\"expected precondition failed; got %v\", err)\n\t}\n}\n\nfunc BenchmarkLoad(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tLoad(testCfg, true)\n\t}\n}\n"
        },
        {
          "name": "caddy.go",
          "type": "blob",
          "size": 32.5439453125,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/caddyserver/certmagic\"\n\t\"github.com/google/uuid\"\n\t\"go.uber.org/zap\"\n\n\t\"github.com/caddyserver/caddy/v2/internal/filesystems\"\n\t\"github.com/caddyserver/caddy/v2/notify\"\n)\n\n// Config is the top (or beginning) of the Caddy configuration structure.\n// Caddy config is expressed natively as a JSON document. If you prefer\n// not to work with JSON directly, there are [many config adapters](/docs/config-adapters)\n// available that can convert various inputs into Caddy JSON.\n//\n// Many parts of this config are extensible through the use of Caddy modules.\n// Fields which have a json.RawMessage type and which appear as dots (â€¢â€¢â€¢) in\n// the online docs can be fulfilled by modules in a certain module\n// namespace. The docs show which modules can be used in a given place.\n//\n// Whenever a module is used, its name must be given either inline as part of\n// the module, or as the key to the module's value. The docs will make it clear\n// which to use.\n//\n// Generally, all config settings are optional, as it is Caddy convention to\n// have good, documented default values. If a parameter is required, the docs\n// should say so.\n//\n// Go programs which are directly building a Config struct value should take\n// care to populate the JSON-encodable fields of the struct (i.e. the fields\n// with `json` struct tags) if employing the module lifecycle (e.g. Provision\n// method calls).\ntype Config struct {\n\tAdmin   *AdminConfig `json:\"admin,omitempty\"`\n\tLogging *Logging     `json:\"logging,omitempty\"`\n\n\t// StorageRaw is a storage module that defines how/where Caddy\n\t// stores assets (such as TLS certificates). The default storage\n\t// module is `caddy.storage.file_system` (the local file system),\n\t// and the default path\n\t// [depends on the OS and environment](/docs/conventions#data-directory).\n\tStorageRaw json.RawMessage `json:\"storage,omitempty\" caddy:\"namespace=caddy.storage inline_key=module\"`\n\n\t// AppsRaw are the apps that Caddy will load and run. The\n\t// app module name is the key, and the app's config is the\n\t// associated value.\n\tAppsRaw ModuleMap `json:\"apps,omitempty\" caddy:\"namespace=\"`\n\n\tapps    map[string]App\n\tstorage certmagic.Storage\n\n\tcancelFunc context.CancelFunc\n\n\t// filesystems is a dict of filesystems that will later be loaded from and added to.\n\tfilesystems FileSystems\n}\n\n// App is a thing that Caddy runs.\ntype App interface {\n\tStart() error\n\tStop() error\n}\n\n// Run runs the given config, replacing any existing config.\nfunc Run(cfg *Config) error {\n\tcfgJSON, err := json.Marshal(cfg)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn Load(cfgJSON, true)\n}\n\n// Load loads the given config JSON and runs it only\n// if it is different from the current config or\n// forceReload is true.\nfunc Load(cfgJSON []byte, forceReload bool) error {\n\tif err := notify.Reloading(); err != nil {\n\t\tLog().Error(\"unable to notify service manager of reloading state\", zap.Error(err))\n\t}\n\n\t// after reload, notify system of success or, if\n\t// failure, update with status (error message)\n\tvar err error\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tif notifyErr := notify.Error(err, 0); notifyErr != nil {\n\t\t\t\tLog().Error(\"unable to notify to service manager of reload error\",\n\t\t\t\t\tzap.Error(notifyErr),\n\t\t\t\t\tzap.String(\"reload_err\", err.Error()))\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif err := notify.Ready(); err != nil {\n\t\t\tLog().Error(\"unable to notify to service manager of ready state\", zap.Error(err))\n\t\t}\n\t}()\n\n\terr = changeConfig(http.MethodPost, \"/\"+rawConfigKey, cfgJSON, \"\", forceReload)\n\tif errors.Is(err, errSameConfig) {\n\t\terr = nil // not really an error\n\t}\n\n\treturn err\n}\n\n// changeConfig changes the current config (rawCfg) according to the\n// method, traversed via the given path, and uses the given input as\n// the new value (if applicable; i.e. \"DELETE\" doesn't have an input).\n// If the resulting config is the same as the previous, no reload will\n// occur unless forceReload is true. If the config is unchanged and not\n// forcefully reloaded, then errConfigUnchanged This function is safe for\n// concurrent use.\n// The ifMatchHeader can optionally be given a string of the format:\n//\n//\t\"<path> <hash>\"\n//\n// where <path> is the absolute path in the config and <hash> is the expected hash of\n// the config at that path. If the hash in the ifMatchHeader doesn't match\n// the hash of the config, then an APIError with status 412 will be returned.\nfunc changeConfig(method, path string, input []byte, ifMatchHeader string, forceReload bool) error {\n\tswitch method {\n\tcase http.MethodGet,\n\t\thttp.MethodHead,\n\t\thttp.MethodOptions,\n\t\thttp.MethodConnect,\n\t\thttp.MethodTrace:\n\t\treturn fmt.Errorf(\"method not allowed\")\n\t}\n\n\trawCfgMu.Lock()\n\tdefer rawCfgMu.Unlock()\n\n\tif ifMatchHeader != \"\" {\n\t\t// expect the first and last character to be quotes\n\t\tif len(ifMatchHeader) < 2 || ifMatchHeader[0] != '\"' || ifMatchHeader[len(ifMatchHeader)-1] != '\"' {\n\t\t\treturn APIError{\n\t\t\t\tHTTPStatus: http.StatusBadRequest,\n\t\t\t\tErr:        fmt.Errorf(\"malformed If-Match header; expect quoted string\"),\n\t\t\t}\n\t\t}\n\n\t\t// read out the parts\n\t\tparts := strings.Fields(ifMatchHeader[1 : len(ifMatchHeader)-1])\n\t\tif len(parts) != 2 {\n\t\t\treturn APIError{\n\t\t\t\tHTTPStatus: http.StatusBadRequest,\n\t\t\t\tErr:        fmt.Errorf(\"malformed If-Match header; expect format \\\"<path> <hash>\\\"\"),\n\t\t\t}\n\t\t}\n\n\t\t// get the current hash of the config\n\t\t// at the given path\n\t\thash := etagHasher()\n\t\terr := unsyncedConfigAccess(http.MethodGet, parts[0], nil, hash)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif hex.EncodeToString(hash.Sum(nil)) != parts[1] {\n\t\t\treturn APIError{\n\t\t\t\tHTTPStatus: http.StatusPreconditionFailed,\n\t\t\t\tErr:        fmt.Errorf(\"If-Match header did not match current config hash\"),\n\t\t\t}\n\t\t}\n\t}\n\n\terr := unsyncedConfigAccess(method, path, input, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// the mutation is complete, so encode the entire config as JSON\n\tnewCfg, err := json.Marshal(rawCfg[rawConfigKey])\n\tif err != nil {\n\t\treturn APIError{\n\t\t\tHTTPStatus: http.StatusBadRequest,\n\t\t\tErr:        fmt.Errorf(\"encoding new config: %v\", err),\n\t\t}\n\t}\n\n\t// if nothing changed, no need to do a whole reload unless the client forces it\n\tif !forceReload && bytes.Equal(rawCfgJSON, newCfg) {\n\t\tLog().Info(\"config is unchanged\")\n\t\treturn errSameConfig\n\t}\n\n\t// find any IDs in this config and index them\n\tidx := make(map[string]string)\n\terr = indexConfigObjects(rawCfg[rawConfigKey], \"/\"+rawConfigKey, idx)\n\tif err != nil {\n\t\treturn APIError{\n\t\t\tHTTPStatus: http.StatusInternalServerError,\n\t\t\tErr:        fmt.Errorf(\"indexing config: %v\", err),\n\t\t}\n\t}\n\n\t// load this new config; if it fails, we need to revert to\n\t// our old representation of caddy's actual config\n\terr = unsyncedDecodeAndRun(newCfg, true)\n\tif err != nil {\n\t\tif len(rawCfgJSON) > 0 {\n\t\t\t// restore old config state to keep it consistent\n\t\t\t// with what caddy is still running; we need to\n\t\t\t// unmarshal it again because it's likely that\n\t\t\t// pointers deep in our rawCfg map were modified\n\t\t\tvar oldCfg any\n\t\t\terr2 := json.Unmarshal(rawCfgJSON, &oldCfg)\n\t\t\tif err2 != nil {\n\t\t\t\terr = fmt.Errorf(\"%v; additionally, restoring old config: %v\", err, err2)\n\t\t\t}\n\t\t\trawCfg[rawConfigKey] = oldCfg\n\t\t}\n\n\t\treturn fmt.Errorf(\"loading new config: %v\", err)\n\t}\n\n\t// success, so update our stored copy of the encoded\n\t// config to keep it consistent with what caddy is now\n\t// running (storing an encoded copy is not strictly\n\t// necessary, but avoids an extra json.Marshal for\n\t// each config change)\n\trawCfgJSON = newCfg\n\trawCfgIndex = idx\n\n\treturn nil\n}\n\n// readConfig traverses the current config to path\n// and writes its JSON encoding to out.\nfunc readConfig(path string, out io.Writer) error {\n\trawCfgMu.RLock()\n\tdefer rawCfgMu.RUnlock()\n\treturn unsyncedConfigAccess(http.MethodGet, path, nil, out)\n}\n\n// indexConfigObjects recursively searches ptr for object fields named\n// \"@id\" and maps that ID value to the full configPath in the index.\n// This function is NOT safe for concurrent access; obtain a write lock\n// on currentCtxMu.\nfunc indexConfigObjects(ptr any, configPath string, index map[string]string) error {\n\tswitch val := ptr.(type) {\n\tcase map[string]any:\n\t\tfor k, v := range val {\n\t\t\tif k == idKey {\n\t\t\t\tswitch idVal := v.(type) {\n\t\t\t\tcase string:\n\t\t\t\t\tindex[idVal] = configPath\n\t\t\t\tcase float64: // all JSON numbers decode as float64\n\t\t\t\t\tindex[fmt.Sprintf(\"%v\", idVal)] = configPath\n\t\t\t\tdefault:\n\t\t\t\t\treturn fmt.Errorf(\"%s: %s field must be a string or number\", configPath, idKey)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// traverse this object property recursively\n\t\t\terr := indexConfigObjects(val[k], path.Join(configPath, k), index)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase []any:\n\t\t// traverse each element of the array recursively\n\t\tfor i := range val {\n\t\t\terr := indexConfigObjects(val[i], path.Join(configPath, strconv.Itoa(i)), index)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// unsyncedDecodeAndRun removes any meta fields (like @id tags)\n// from cfgJSON, decodes the result into a *Config, and runs\n// it as the new config, replacing any other current config.\n// It does NOT update the raw config state, as this is a\n// lower-level function; most callers will want to use Load\n// instead. A write lock on rawCfgMu is required! If\n// allowPersist is false, it will not be persisted to disk,\n// even if it is configured to.\nfunc unsyncedDecodeAndRun(cfgJSON []byte, allowPersist bool) error {\n\t// remove any @id fields from the JSON, which would cause\n\t// loading to break since the field wouldn't be recognized\n\tstrippedCfgJSON := RemoveMetaFields(cfgJSON)\n\n\tvar newCfg *Config\n\terr := StrictUnmarshalJSON(strippedCfgJSON, &newCfg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// prevent recursive config loads; that is a user error, and\n\t// although frequent config loads should be safe, we cannot\n\t// guarantee that in the presence of third party plugins, nor\n\t// do we want this error to go unnoticed (we assume it was a\n\t// pulled config if we're not allowed to persist it)\n\tif !allowPersist &&\n\t\tnewCfg != nil &&\n\t\tnewCfg.Admin != nil &&\n\t\tnewCfg.Admin.Config != nil &&\n\t\tnewCfg.Admin.Config.LoadRaw != nil &&\n\t\tnewCfg.Admin.Config.LoadDelay <= 0 {\n\t\treturn fmt.Errorf(\"recursive config loading detected: pulled configs cannot pull other configs without positive load_delay\")\n\t}\n\n\t// run the new config and start all its apps\n\tctx, err := run(newCfg, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// swap old context (including its config) with the new one\n\tcurrentCtxMu.Lock()\n\toldCtx := currentCtx\n\tcurrentCtx = ctx\n\tcurrentCtxMu.Unlock()\n\n\t// Stop, Cleanup each old app\n\tunsyncedStop(oldCtx)\n\n\t// autosave a non-nil config, if not disabled\n\tif allowPersist &&\n\t\tnewCfg != nil &&\n\t\t(newCfg.Admin == nil ||\n\t\t\tnewCfg.Admin.Config == nil ||\n\t\t\tnewCfg.Admin.Config.Persist == nil ||\n\t\t\t*newCfg.Admin.Config.Persist) {\n\t\tdir := filepath.Dir(ConfigAutosavePath)\n\t\terr := os.MkdirAll(dir, 0o700)\n\t\tif err != nil {\n\t\t\tLog().Error(\"unable to create folder for config autosave\",\n\t\t\t\tzap.String(\"dir\", dir),\n\t\t\t\tzap.Error(err))\n\t\t} else {\n\t\t\terr := os.WriteFile(ConfigAutosavePath, cfgJSON, 0o600)\n\t\t\tif err == nil {\n\t\t\t\tLog().Info(\"autosaved config (load with --resume flag)\", zap.String(\"file\", ConfigAutosavePath))\n\t\t\t} else {\n\t\t\t\tLog().Error(\"unable to autosave config\",\n\t\t\t\t\tzap.String(\"file\", ConfigAutosavePath),\n\t\t\t\t\tzap.Error(err))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// run runs newCfg and starts all its apps if\n// start is true. If any errors happen, cleanup\n// is performed if any modules were provisioned;\n// apps that were started already will be stopped,\n// so this function should not leak resources if\n// an error is returned. However, if no error is\n// returned and start == false, you should cancel\n// the config if you are not going to start it,\n// so that each provisioned module will be\n// cleaned up.\n//\n// This is a low-level function; most callers\n// will want to use Run instead, which also\n// updates the config's raw state.\nfunc run(newCfg *Config, start bool) (Context, error) {\n\tctx, err := provisionContext(newCfg, start)\n\tif err != nil {\n\t\tglobalMetrics.configSuccess.Set(0)\n\t\treturn ctx, err\n\t}\n\n\tif !start {\n\t\treturn ctx, nil\n\t}\n\n\t// Provision any admin routers which may need to access\n\t// some of the other apps at runtime\n\terr = ctx.cfg.Admin.provisionAdminRouters(ctx)\n\tif err != nil {\n\t\tglobalMetrics.configSuccess.Set(0)\n\t\treturn ctx, err\n\t}\n\n\t// Start\n\terr = func() error {\n\t\tstarted := make([]string, 0, len(ctx.cfg.apps))\n\t\tfor name, a := range ctx.cfg.apps {\n\t\t\terr := a.Start()\n\t\t\tif err != nil {\n\t\t\t\t// an app failed to start, so we need to stop\n\t\t\t\t// all other apps that were already started\n\t\t\t\tfor _, otherAppName := range started {\n\t\t\t\t\terr2 := ctx.cfg.apps[otherAppName].Stop()\n\t\t\t\t\tif err2 != nil {\n\t\t\t\t\t\terr = fmt.Errorf(\"%v; additionally, aborting app %s: %v\",\n\t\t\t\t\t\t\terr, otherAppName, err2)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn fmt.Errorf(\"%s app module: start: %v\", name, err)\n\t\t\t}\n\t\t\tstarted = append(started, name)\n\t\t}\n\t\treturn nil\n\t}()\n\tif err != nil {\n\t\tglobalMetrics.configSuccess.Set(0)\n\t\treturn ctx, err\n\t}\n\tglobalMetrics.configSuccess.Set(1)\n\tglobalMetrics.configSuccessTime.SetToCurrentTime()\n\t// now that the user's config is running, finish setting up anything else,\n\t// such as remote admin endpoint, config loader, etc.\n\treturn ctx, finishSettingUp(ctx, ctx.cfg)\n}\n\n// provisionContext creates a new context from the given configuration and provisions\n// storage and apps.\n// If `newCfg` is nil a new empty configuration will be created.\n// If `replaceAdminServer` is true any currently active admin server will be replaced\n// with a new admin server based on the provided configuration.\nfunc provisionContext(newCfg *Config, replaceAdminServer bool) (Context, error) {\n\t// because we will need to roll back any state\n\t// modifications if this function errors, we\n\t// keep a single error value and scope all\n\t// sub-operations to their own functions to\n\t// ensure this error value does not get\n\t// overridden or missed when it should have\n\t// been set by a short assignment\n\tvar err error\n\n\tif newCfg == nil {\n\t\tnewCfg = new(Config)\n\t}\n\n\t// create a context within which to load\n\t// modules - essentially our new config's\n\t// execution environment; be sure that\n\t// cleanup occurs when we return if there\n\t// was an error; if no error, it will get\n\t// cleaned up on next config cycle\n\tctx, cancel := NewContext(Context{Context: context.Background(), cfg: newCfg})\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tglobalMetrics.configSuccess.Set(0)\n\t\t\t// if there were any errors during startup,\n\t\t\t// we should cancel the new context we created\n\t\t\t// since the associated config won't be used;\n\t\t\t// this will cause all modules that were newly\n\t\t\t// provisioned to clean themselves up\n\t\t\tcancel()\n\n\t\t\t// also undo any other state changes we made\n\t\t\tif currentCtx.cfg != nil {\n\t\t\t\tcertmagic.Default.Storage = currentCtx.cfg.storage\n\t\t\t}\n\t\t}\n\t}()\n\tnewCfg.cancelFunc = cancel // clean up later\n\n\t// set up logging before anything bad happens\n\tif newCfg.Logging == nil {\n\t\tnewCfg.Logging = new(Logging)\n\t}\n\terr = newCfg.Logging.openLogs(ctx)\n\tif err != nil {\n\t\treturn ctx, err\n\t}\n\n\t// start the admin endpoint (and stop any prior one)\n\tif replaceAdminServer {\n\t\terr = replaceLocalAdminServer(newCfg, ctx)\n\t\tif err != nil {\n\t\t\treturn ctx, fmt.Errorf(\"starting caddy administration endpoint: %v\", err)\n\t\t}\n\t}\n\n\t// create the new filesystem map\n\tnewCfg.filesystems = &filesystems.FilesystemMap{}\n\n\t// prepare the new config for use\n\tnewCfg.apps = make(map[string]App)\n\n\t// set up global storage and make it CertMagic's default storage, too\n\terr = func() error {\n\t\tif newCfg.StorageRaw != nil {\n\t\t\tval, err := ctx.LoadModule(newCfg, \"StorageRaw\")\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"loading storage module: %v\", err)\n\t\t\t}\n\t\t\tstor, err := val.(StorageConverter).CertMagicStorage()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"creating storage value: %v\", err)\n\t\t\t}\n\t\t\tnewCfg.storage = stor\n\t\t}\n\n\t\tif newCfg.storage == nil {\n\t\t\tnewCfg.storage = DefaultStorage\n\t\t}\n\t\tcertmagic.Default.Storage = newCfg.storage\n\n\t\treturn nil\n\t}()\n\tif err != nil {\n\t\treturn ctx, err\n\t}\n\n\t// Load and Provision each app and their submodules\n\terr = func() error {\n\t\tfor appName := range newCfg.AppsRaw {\n\t\t\tif _, err := ctx.App(appName); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}()\n\treturn ctx, err\n}\n\n// ProvisionContext creates a new context from the configuration and provisions storage\n// and app modules.\n// The function is intended for testing and advanced use cases only, typically `Run` should be\n// use to ensure a fully functional caddy instance.\n// EXPERIMENTAL: While this is public the interface and implementation details of this function may change.\nfunc ProvisionContext(newCfg *Config) (Context, error) {\n\treturn provisionContext(newCfg, false)\n}\n\n// finishSettingUp should be run after all apps have successfully started.\nfunc finishSettingUp(ctx Context, cfg *Config) error {\n\t// establish this server's identity (only after apps are loaded\n\t// so that cert management of this endpoint doesn't prevent user's\n\t// servers from starting which likely also use HTTP/HTTPS ports;\n\t// but before remote management which may depend on these creds)\n\terr := manageIdentity(ctx, cfg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"provisioning remote admin endpoint: %v\", err)\n\t}\n\n\t// replace any remote admin endpoint\n\terr = replaceRemoteAdminServer(ctx, cfg)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"provisioning remote admin endpoint: %v\", err)\n\t}\n\n\t// if dynamic config is requested, set that up and run it\n\tif cfg != nil && cfg.Admin != nil && cfg.Admin.Config != nil && cfg.Admin.Config.LoadRaw != nil {\n\t\tval, err := ctx.LoadModule(cfg.Admin.Config, \"LoadRaw\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"loading config loader module: %s\", err)\n\t\t}\n\n\t\tlogger := Log().Named(\"config_loader\").With(\n\t\t\tzap.String(\"module\", val.(Module).CaddyModule().ID.Name()),\n\t\t\tzap.Int(\"load_delay\", int(cfg.Admin.Config.LoadDelay)))\n\n\t\trunLoadedConfig := func(config []byte) error {\n\t\t\tlogger.Info(\"applying dynamically-loaded config\")\n\t\t\terr := changeConfig(http.MethodPost, \"/\"+rawConfigKey, config, \"\", false)\n\t\t\tif errors.Is(err, errSameConfig) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(\"failed to run dynamically-loaded config\", zap.Error(err))\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tlogger.Info(\"successfully applied dynamically-loaded config\")\n\t\t\treturn nil\n\t\t}\n\n\t\tif cfg.Admin.Config.LoadDelay > 0 {\n\t\t\tgo func() {\n\t\t\t\t// the loop is here to iterate ONLY if there is an error, a no-op config load,\n\t\t\t\t// or an unchanged config; in which case we simply wait the delay and try again\n\t\t\t\tfor {\n\t\t\t\t\ttimer := time.NewTimer(time.Duration(cfg.Admin.Config.LoadDelay))\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-timer.C:\n\t\t\t\t\t\tloadedConfig, err := val.(ConfigLoader).LoadConfig(ctx)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tlogger.Error(\"failed loading dynamic config; will retry\", zap.Error(err))\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif loadedConfig == nil {\n\t\t\t\t\t\t\tlogger.Info(\"dynamically-loaded config was nil; will retry\")\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\terr = runLoadedConfig(loadedConfig)\n\t\t\t\t\t\tif errors.Is(err, errSameConfig) {\n\t\t\t\t\t\t\tlogger.Info(\"dynamically-loaded config was unchanged; will retry\")\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\tif !timer.Stop() {\n\t\t\t\t\t\t\t<-timer.C\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlogger.Info(\"stopping dynamic config loading\")\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}()\n\t\t} else {\n\t\t\t// if no LoadDelay is provided, will load config synchronously\n\t\t\tloadedConfig, err := val.(ConfigLoader).LoadConfig(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"loading dynamic config from %T: %v\", val, err)\n\t\t\t}\n\t\t\t// do this in a goroutine so current config can finish being loaded; otherwise deadlock\n\t\t\tgo func() { _ = runLoadedConfig(loadedConfig) }()\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ConfigLoader is a type that can load a Caddy config. If\n// the return value is non-nil, it must be valid Caddy JSON;\n// if nil or with non-nil error, it is considered to be a\n// no-op load and may be retried later.\ntype ConfigLoader interface {\n\tLoadConfig(Context) ([]byte, error)\n}\n\n// Stop stops running the current configuration.\n// It is the antithesis of Run(). This function\n// will log any errors that occur during the\n// stopping of individual apps and continue to\n// stop the others. Stop should only be called\n// if not replacing with a new config.\nfunc Stop() error {\n\tcurrentCtxMu.RLock()\n\tctx := currentCtx\n\tcurrentCtxMu.RUnlock()\n\n\trawCfgMu.Lock()\n\tunsyncedStop(ctx)\n\n\tcurrentCtxMu.Lock()\n\tcurrentCtx = Context{}\n\tcurrentCtxMu.Unlock()\n\n\trawCfgJSON = nil\n\trawCfgIndex = nil\n\trawCfg[rawConfigKey] = nil\n\trawCfgMu.Unlock()\n\n\treturn nil\n}\n\n// unsyncedStop stops ctx from running, but has\n// no locking around ctx. It is a no-op if ctx has a\n// nil cfg. If any app returns an error when stopping,\n// it is logged and the function continues stopping\n// the next app. This function assumes all apps in\n// ctx were successfully started first.\n//\n// A lock on rawCfgMu is required, even though this\n// function does not access rawCfg, that lock\n// synchronizes the stop/start of apps.\nfunc unsyncedStop(ctx Context) {\n\tif ctx.cfg == nil {\n\t\treturn\n\t}\n\n\t// stop each app\n\tfor name, a := range ctx.cfg.apps {\n\t\terr := a.Stop()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[ERROR] stop %s: %v\", name, err)\n\t\t}\n\t}\n\n\t// clean up all modules\n\tctx.cfg.cancelFunc()\n}\n\n// Validate loads, provisions, and validates\n// cfg, but does not start running it.\nfunc Validate(cfg *Config) error {\n\t_, err := run(cfg, false)\n\tif err == nil {\n\t\tcfg.cancelFunc() // call Cleanup on all modules\n\t}\n\treturn err\n}\n\n// exitProcess exits the process as gracefully as possible,\n// but it always exits, even if there are errors doing so.\n// It stops all apps, cleans up external locks, removes any\n// PID file, and shuts down admin endpoint(s) in a goroutine.\n// Errors are logged along the way, and an appropriate exit\n// code is emitted.\nfunc exitProcess(ctx context.Context, logger *zap.Logger) {\n\t// let the rest of the program know we're quitting; only do it once\n\tif !atomic.CompareAndSwapInt32(exiting, 0, 1) {\n\t\treturn\n\t}\n\n\t// give the OS or service/process manager our 2 weeks' notice: we quit\n\tif err := notify.Stopping(); err != nil {\n\t\tLog().Error(\"unable to notify service manager of stopping state\", zap.Error(err))\n\t}\n\n\tif logger == nil {\n\t\tlogger = Log()\n\t}\n\tlogger.Warn(\"exiting; byeee!! ðŸ‘‹\")\n\n\texitCode := ExitCodeSuccess\n\tlastContext := ActiveContext()\n\n\t// stop all apps\n\tif err := Stop(); err != nil {\n\t\tlogger.Error(\"failed to stop apps\", zap.Error(err))\n\t\texitCode = ExitCodeFailedQuit\n\t}\n\n\t// clean up certmagic locks\n\tcertmagic.CleanUpOwnLocks(ctx, logger)\n\n\t// remove pidfile\n\tif pidfile != \"\" {\n\t\terr := os.Remove(pidfile)\n\t\tif err != nil {\n\t\t\tlogger.Error(\"cleaning up PID file:\",\n\t\t\t\tzap.String(\"pidfile\", pidfile),\n\t\t\t\tzap.Error(err))\n\t\t\texitCode = ExitCodeFailedQuit\n\t\t}\n\t}\n\n\t// execute any process-exit callbacks\n\tfor _, exitFunc := range lastContext.exitFuncs {\n\t\texitFunc(ctx)\n\t}\n\texitFuncsMu.Lock()\n\tfor _, exitFunc := range exitFuncs {\n\t\texitFunc(ctx)\n\t}\n\texitFuncsMu.Unlock()\n\n\t// shut down admin endpoint(s) in goroutines so that\n\t// if this function was called from an admin handler,\n\t// it has a chance to return gracefully\n\t// use goroutine so that we can finish responding to API request\n\tgo func() {\n\t\tdefer func() {\n\t\t\tlogger = logger.With(zap.Int(\"exit_code\", exitCode))\n\t\t\tif exitCode == ExitCodeSuccess {\n\t\t\t\tlogger.Info(\"shutdown complete\")\n\t\t\t} else {\n\t\t\t\tlogger.Error(\"unclean shutdown\")\n\t\t\t}\n\t\t\tos.Exit(exitCode)\n\t\t}()\n\n\t\tif remoteAdminServer != nil {\n\t\t\terr := stopAdminServer(remoteAdminServer)\n\t\t\tif err != nil {\n\t\t\t\texitCode = ExitCodeFailedQuit\n\t\t\t\tlogger.Error(\"failed to stop remote admin server gracefully\", zap.Error(err))\n\t\t\t}\n\t\t}\n\t\tif localAdminServer != nil {\n\t\t\terr := stopAdminServer(localAdminServer)\n\t\t\tif err != nil {\n\t\t\t\texitCode = ExitCodeFailedQuit\n\t\t\t\tlogger.Error(\"failed to stop local admin server gracefully\", zap.Error(err))\n\t\t\t}\n\t\t}\n\t}()\n}\n\nvar exiting = new(int32) // accessed atomically\n\n// Exiting returns true if the process is exiting.\n// EXPERIMENTAL API: subject to change or removal.\nfunc Exiting() bool { return atomic.LoadInt32(exiting) == 1 }\n\n// OnExit registers a callback to invoke during process exit.\n// This registration is PROCESS-GLOBAL, meaning that each\n// function should only be registered once forever, NOT once\n// per config load (etc).\n//\n// EXPERIMENTAL API: subject to change or removal.\nfunc OnExit(f func(context.Context)) {\n\texitFuncsMu.Lock()\n\texitFuncs = append(exitFuncs, f)\n\texitFuncsMu.Unlock()\n}\n\nvar (\n\texitFuncs   []func(context.Context)\n\texitFuncsMu sync.Mutex\n)\n\n// Duration can be an integer or a string. An integer is\n// interpreted as nanoseconds. If a string, it is a Go\n// time.Duration value such as `300ms`, `1.5h`, or `2h45m`;\n// valid units are `ns`, `us`/`Âµs`, `ms`, `s`, `m`, `h`, and `d`.\ntype Duration time.Duration\n\n// UnmarshalJSON satisfies json.Unmarshaler.\nfunc (d *Duration) UnmarshalJSON(b []byte) error {\n\tif len(b) == 0 {\n\t\treturn io.EOF\n\t}\n\tvar dur time.Duration\n\tvar err error\n\tif b[0] == byte('\"') && b[len(b)-1] == byte('\"') {\n\t\tdur, err = ParseDuration(strings.Trim(string(b), `\"`))\n\t} else {\n\t\terr = json.Unmarshal(b, &dur)\n\t}\n\t*d = Duration(dur)\n\treturn err\n}\n\n// ParseDuration parses a duration string, adding\n// support for the \"d\" unit meaning number of days,\n// where a day is assumed to be 24h. The maximum\n// input string length is 1024.\nfunc ParseDuration(s string) (time.Duration, error) {\n\tif len(s) > 1024 {\n\t\treturn 0, fmt.Errorf(\"parsing duration: input string too long\")\n\t}\n\tvar inNumber bool\n\tvar numStart int\n\tfor i := 0; i < len(s); i++ {\n\t\tch := s[i]\n\t\tif ch == 'd' {\n\t\t\tdaysStr := s[numStart:i]\n\t\t\tdays, err := strconv.ParseFloat(daysStr, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\thours := days * 24.0\n\t\t\thoursStr := strconv.FormatFloat(hours, 'f', -1, 64)\n\t\t\ts = s[:numStart] + hoursStr + \"h\" + s[i+1:]\n\t\t\ti--\n\t\t\tcontinue\n\t\t}\n\t\tif !inNumber {\n\t\t\tnumStart = i\n\t\t}\n\t\tinNumber = (ch >= '0' && ch <= '9') || ch == '.' || ch == '-' || ch == '+'\n\t}\n\treturn time.ParseDuration(s)\n}\n\n// InstanceID returns the UUID for this instance, and generates one if it\n// does not already exist. The UUID is stored in the local data directory,\n// regardless of storage configuration, since each instance is intended to\n// have its own unique ID.\nfunc InstanceID() (uuid.UUID, error) {\n\tappDataDir := AppDataDir()\n\tuuidFilePath := filepath.Join(appDataDir, \"instance.uuid\")\n\tuuidFileBytes, err := os.ReadFile(uuidFilePath)\n\tif errors.Is(err, fs.ErrNotExist) {\n\t\tuuid, err := uuid.NewRandom()\n\t\tif err != nil {\n\t\t\treturn uuid, err\n\t\t}\n\t\terr = os.MkdirAll(appDataDir, 0o700)\n\t\tif err != nil {\n\t\t\treturn uuid, err\n\t\t}\n\t\terr = os.WriteFile(uuidFilePath, []byte(uuid.String()), 0o600)\n\t\treturn uuid, err\n\t} else if err != nil {\n\t\treturn [16]byte{}, err\n\t}\n\treturn uuid.ParseBytes(uuidFileBytes)\n}\n\n// CustomVersion is an optional string that overrides Caddy's\n// reported version. It can be helpful when downstream packagers\n// need to manually set Caddy's version. If no other version\n// information is available, the short form version (see\n// Version()) will be set to CustomVersion, and the full version\n// will include CustomVersion at the beginning.\n//\n// Set this variable during `go build` with `-ldflags`:\n//\n//\t-ldflags '-X github.com/caddyserver/caddy/v2.CustomVersion=v2.6.2'\n//\n// for example.\nvar CustomVersion string\n\n// Version returns the Caddy version in a simple/short form, and\n// a full version string. The short form will not have spaces and\n// is intended for User-Agent strings and similar, but may be\n// omitting valuable information. Note that Caddy must be compiled\n// in a special way to properly embed complete version information.\n// First this function tries to get the version from the embedded\n// build info provided by go.mod dependencies; then it tries to\n// get info from embedded VCS information, which requires having\n// built Caddy from a git repository. If no version is available,\n// this function returns \"(devel)\" because Go uses that, but for\n// the simple form we change it to \"unknown\". If still no version\n// is available (e.g. no VCS repo), then it will use CustomVersion;\n// CustomVersion is always prepended to the full version string.\n//\n// See relevant Go issues: https://github.com/golang/go/issues/29228\n// and https://github.com/golang/go/issues/50603.\n//\n// This function is experimental and subject to change or removal.\nfunc Version() (simple, full string) {\n\t// the currently-recommended way to build Caddy involves\n\t// building it as a dependency so we can extract version\n\t// information from go.mod tooling; once the upstream\n\t// Go issues are fixed, we should just be able to use\n\t// bi.Main... hopefully.\n\tvar module *debug.Module\n\tbi, ok := debug.ReadBuildInfo()\n\tif !ok {\n\t\tif CustomVersion != \"\" {\n\t\t\tfull = CustomVersion\n\t\t\tsimple = CustomVersion\n\t\t\treturn\n\t\t}\n\t\tfull = \"unknown\"\n\t\tsimple = \"unknown\"\n\t\treturn\n\t}\n\t// find the Caddy module in the dependency list\n\tfor _, dep := range bi.Deps {\n\t\tif dep.Path == ImportPath {\n\t\t\tmodule = dep\n\t\t\tbreak\n\t\t}\n\t}\n\tif module != nil {\n\t\tsimple, full = module.Version, module.Version\n\t\tif module.Sum != \"\" {\n\t\t\tfull += \" \" + module.Sum\n\t\t}\n\t\tif module.Replace != nil {\n\t\t\tfull += \" => \" + module.Replace.Path\n\t\t\tif module.Replace.Version != \"\" {\n\t\t\t\tsimple = module.Replace.Version + \"_custom\"\n\t\t\t\tfull += \"@\" + module.Replace.Version\n\t\t\t}\n\t\t\tif module.Replace.Sum != \"\" {\n\t\t\t\tfull += \" \" + module.Replace.Sum\n\t\t\t}\n\t\t}\n\t}\n\n\tif full == \"\" {\n\t\tvar vcsRevision string\n\t\tvar vcsTime time.Time\n\t\tvar vcsModified bool\n\t\tfor _, setting := range bi.Settings {\n\t\t\tswitch setting.Key {\n\t\t\tcase \"vcs.revision\":\n\t\t\t\tvcsRevision = setting.Value\n\t\t\tcase \"vcs.time\":\n\t\t\t\tvcsTime, _ = time.Parse(time.RFC3339, setting.Value)\n\t\t\tcase \"vcs.modified\":\n\t\t\t\tvcsModified, _ = strconv.ParseBool(setting.Value)\n\t\t\t}\n\t\t}\n\n\t\tif vcsRevision != \"\" {\n\t\t\tvar modified string\n\t\t\tif vcsModified {\n\t\t\t\tmodified = \"+modified\"\n\t\t\t}\n\t\t\tfull = fmt.Sprintf(\"%s%s (%s)\", vcsRevision, modified, vcsTime.Format(time.RFC822))\n\t\t\tsimple = vcsRevision\n\n\t\t\t// use short checksum for simple, if hex-only\n\t\t\tif _, err := hex.DecodeString(simple); err == nil {\n\t\t\t\tsimple = simple[:8]\n\t\t\t}\n\n\t\t\t// append date to simple since it can be convenient\n\t\t\t// to know the commit date as part of the version\n\t\t\tif !vcsTime.IsZero() {\n\t\t\t\tsimple += \"-\" + vcsTime.Format(\"20060102\")\n\t\t\t}\n\t\t}\n\t}\n\n\tif full == \"\" {\n\t\tif CustomVersion != \"\" {\n\t\t\tfull = CustomVersion\n\t\t} else {\n\t\t\tfull = \"unknown\"\n\t\t}\n\t} else if CustomVersion != \"\" {\n\t\tfull = CustomVersion + \" \" + full\n\t}\n\n\tif simple == \"\" || simple == \"(devel)\" {\n\t\tif CustomVersion != \"\" {\n\t\t\tsimple = CustomVersion\n\t\t} else {\n\t\t\tsimple = \"unknown\"\n\t\t}\n\t}\n\n\treturn\n}\n\n// ActiveContext returns the currently-active context.\n// This function is experimental and might be changed\n// or removed in the future.\nfunc ActiveContext() Context {\n\tcurrentCtxMu.RLock()\n\tdefer currentCtxMu.RUnlock()\n\treturn currentCtx\n}\n\n// CtxKey is a value type for use with context.WithValue.\ntype CtxKey string\n\n// This group of variables pertains to the current configuration.\nvar (\n\t// currentCtx is the root context for the currently-running\n\t// configuration, which can be accessed through this value.\n\t// If the Config contained in this value is not nil, then\n\t// a config is currently active/running.\n\tcurrentCtx   Context\n\tcurrentCtxMu sync.RWMutex\n\n\t// rawCfg is the current, generic-decoded configuration;\n\t// we initialize it as a map with one field (\"config\")\n\t// to maintain parity with the API endpoint and to avoid\n\t// the special case of having to access/mutate the variable\n\t// directly without traversing into it.\n\trawCfg = map[string]any{\n\t\trawConfigKey: nil,\n\t}\n\n\t// rawCfgJSON is the JSON-encoded form of rawCfg. Keeping\n\t// this around avoids an extra Marshal call during changes.\n\trawCfgJSON []byte\n\n\t// rawCfgIndex is the map of user-assigned ID to expanded\n\t// path, for converting /id/ paths to /config/ paths.\n\trawCfgIndex map[string]string\n\n\t// rawCfgMu protects all the rawCfg fields and also\n\t// essentially synchronizes config changes/reloads.\n\trawCfgMu sync.RWMutex\n)\n\n// errSameConfig is returned if the new config is the same\n// as the old one. This isn't usually an actual, actionable\n// error; it's mostly a sentinel value.\nvar errSameConfig = errors.New(\"config is unchanged\")\n\n// ImportPath is the package import path for Caddy core.\n// This identifier may be removed in the future.\nconst ImportPath = \"github.com/caddyserver/caddy/v2\"\n"
        },
        {
          "name": "caddy_test.go",
          "type": "blob",
          "size": 1.6279296875,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestParseDuration(t *testing.T) {\n\tconst day = 24 * time.Hour\n\tfor i, tc := range []struct {\n\t\tinput  string\n\t\texpect time.Duration\n\t}{\n\t\t{\n\t\t\tinput:  \"3h\",\n\t\t\texpect: 3 * time.Hour,\n\t\t},\n\t\t{\n\t\t\tinput:  \"1d\",\n\t\t\texpect: day,\n\t\t},\n\t\t{\n\t\t\tinput:  \"1d30m\",\n\t\t\texpect: day + 30*time.Minute,\n\t\t},\n\t\t{\n\t\t\tinput:  \"1m2d\",\n\t\t\texpect: time.Minute + day*2,\n\t\t},\n\t\t{\n\t\t\tinput:  \"1m2d30s\",\n\t\t\texpect: time.Minute + day*2 + 30*time.Second,\n\t\t},\n\t\t{\n\t\t\tinput:  \"1d2d\",\n\t\t\texpect: 3 * day,\n\t\t},\n\t\t{\n\t\t\tinput:  \"1.5d\",\n\t\t\texpect: time.Duration(1.5 * float64(day)),\n\t\t},\n\t\t{\n\t\t\tinput:  \"4m1.25d\",\n\t\t\texpect: 4*time.Minute + time.Duration(1.25*float64(day)),\n\t\t},\n\t\t{\n\t\t\tinput:  \"-1.25d12h\",\n\t\t\texpect: time.Duration(-1.25*float64(day)) - 12*time.Hour,\n\t\t},\n\t} {\n\t\tactual, err := ParseDuration(tc.input)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Test %d ('%s'): Got error: %v\", i, tc.input, err)\n\t\t\tcontinue\n\t\t}\n\t\tif actual != tc.expect {\n\t\t\tt.Errorf(\"Test %d ('%s'): Expected=%s Actual=%s\", i, tc.input, tc.expect, actual)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "caddyconfig",
          "type": "tree",
          "content": null
        },
        {
          "name": "caddytest",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 20.951171875,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"log/slog\"\n\t\"reflect\"\n\n\t\"github.com/caddyserver/certmagic\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/collectors\"\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/exp/zapslog\"\n\n\t\"github.com/caddyserver/caddy/v2/internal/filesystems\"\n)\n\n// Context is a type which defines the lifetime of modules that\n// are loaded and provides access to the parent configuration\n// that spawned the modules which are loaded. It should be used\n// with care and wrapped with derivation functions from the\n// standard context package only if you don't need the Caddy\n// specific features. These contexts are canceled when the\n// lifetime of the modules loaded from it is over.\n//\n// Use NewContext() to get a valid value (but most modules will\n// not actually need to do this).\ntype Context struct {\n\tcontext.Context\n\n\tmoduleInstances map[string][]Module\n\tcfg             *Config\n\tancestry        []Module\n\tcleanupFuncs    []func()                // invoked at every config unload\n\texitFuncs       []func(context.Context) // invoked at config unload ONLY IF the process is exiting (EXPERIMENTAL)\n\tmetricsRegistry *prometheus.Registry\n}\n\n// NewContext provides a new context derived from the given\n// context ctx. Normally, you will not need to call this\n// function unless you are loading modules which have a\n// different lifespan than the ones for the context the\n// module was provisioned with. Be sure to call the cancel\n// func when the context is to be cleaned up so that\n// modules which are loaded will be properly unloaded.\n// See standard library context package's documentation.\nfunc NewContext(ctx Context) (Context, context.CancelFunc) {\n\tnewCtx := Context{moduleInstances: make(map[string][]Module), cfg: ctx.cfg, metricsRegistry: prometheus.NewPedanticRegistry()}\n\tc, cancel := context.WithCancel(ctx.Context)\n\twrappedCancel := func() {\n\t\tcancel()\n\n\t\tfor _, f := range ctx.cleanupFuncs {\n\t\t\tf()\n\t\t}\n\n\t\tfor modName, modInstances := range newCtx.moduleInstances {\n\t\t\tfor _, inst := range modInstances {\n\t\t\t\tif cu, ok := inst.(CleanerUpper); ok {\n\t\t\t\t\terr := cu.Cleanup()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Printf(\"[ERROR] %s (%p): cleanup: %v\", modName, inst, err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnewCtx.Context = c\n\tnewCtx.initMetrics()\n\treturn newCtx, wrappedCancel\n}\n\n// OnCancel executes f when ctx is canceled.\nfunc (ctx *Context) OnCancel(f func()) {\n\tctx.cleanupFuncs = append(ctx.cleanupFuncs, f)\n}\n\n// Filesystems returns a ref to the FilesystemMap.\n// EXPERIMENTAL: This API is subject to change.\nfunc (ctx *Context) Filesystems() FileSystems {\n\t// if no config is loaded, we use a default filesystemmap, which includes the osfs\n\tif ctx.cfg == nil {\n\t\treturn &filesystems.FilesystemMap{}\n\t}\n\treturn ctx.cfg.filesystems\n}\n\n// Returns the active metrics registry for the context\n// EXPERIMENTAL: This API is subject to change.\nfunc (ctx *Context) GetMetricsRegistry() *prometheus.Registry {\n\treturn ctx.metricsRegistry\n}\n\nfunc (ctx *Context) initMetrics() {\n\tctx.metricsRegistry.MustRegister(\n\t\tcollectors.NewBuildInfoCollector(),\n\t\tcollectors.NewProcessCollector(collectors.ProcessCollectorOpts{}),\n\t\tcollectors.NewGoCollector(),\n\t\tadminMetrics.requestCount,\n\t\tadminMetrics.requestErrors,\n\t\tglobalMetrics.configSuccess,\n\t\tglobalMetrics.configSuccessTime,\n\t)\n}\n\n// OnExit executes f when the process exits gracefully.\n// The function is only executed if the process is gracefully\n// shut down while this context is active.\n//\n// EXPERIMENTAL API: subject to change or removal.\nfunc (ctx *Context) OnExit(f func(context.Context)) {\n\tctx.exitFuncs = append(ctx.exitFuncs, f)\n}\n\n// LoadModule loads the Caddy module(s) from the specified field of the parent struct\n// pointer and returns the loaded module(s). The struct pointer and its field name as\n// a string are necessary so that reflection can be used to read the struct tag on the\n// field to get the module namespace and inline module name key (if specified).\n//\n// The field can be any one of the supported raw module types: json.RawMessage,\n// []json.RawMessage, map[string]json.RawMessage, or []map[string]json.RawMessage.\n// ModuleMap may be used in place of map[string]json.RawMessage. The return value's\n// underlying type mirrors the input field's type:\n//\n//\tjson.RawMessage              => any\n//\t[]json.RawMessage            => []any\n//\t[][]json.RawMessage          => [][]any\n//\tmap[string]json.RawMessage   => map[string]any\n//\t[]map[string]json.RawMessage => []map[string]any\n//\n// The field must have a \"caddy\" struct tag in this format:\n//\n//\tcaddy:\"key1=val1 key2=val2\"\n//\n// To load modules, a \"namespace\" key is required. For example, to load modules\n// in the \"http.handlers\" namespace, you'd put: `namespace=http.handlers` in the\n// Caddy struct tag.\n//\n// The module name must also be available. If the field type is a map or slice of maps,\n// then key is assumed to be the module name if an \"inline_key\" is NOT specified in the\n// caddy struct tag. In this case, the module name does NOT need to be specified in-line\n// with the module itself.\n//\n// If not a map, or if inline_key is non-empty, then the module name must be embedded\n// into the values, which must be objects; then there must be a key in those objects\n// where its associated value is the module name. This is called the \"inline key\",\n// meaning the key containing the module's name that is defined inline with the module\n// itself. You must specify the inline key in a struct tag, along with the namespace:\n//\n//\tcaddy:\"namespace=http.handlers inline_key=handler\"\n//\n// This will look for a key/value pair like `\"handler\": \"...\"` in the json.RawMessage\n// in order to know the module name.\n//\n// To make use of the loaded module(s) (the return value), you will probably want\n// to type-assert each 'any' value(s) to the types that are useful to you\n// and store them on the same struct. Storing them on the same struct makes for\n// easy garbage collection when your host module is no longer needed.\n//\n// Loaded modules have already been provisioned and validated. Upon returning\n// successfully, this method clears the json.RawMessage(s) in the field since\n// the raw JSON is no longer needed, and this allows the GC to free up memory.\nfunc (ctx Context) LoadModule(structPointer any, fieldName string) (any, error) {\n\tval := reflect.ValueOf(structPointer).Elem().FieldByName(fieldName)\n\ttyp := val.Type()\n\n\tfield, ok := reflect.TypeOf(structPointer).Elem().FieldByName(fieldName)\n\tif !ok {\n\t\tpanic(fmt.Sprintf(\"field %s does not exist in %#v\", fieldName, structPointer))\n\t}\n\n\topts, err := ParseStructTag(field.Tag.Get(\"caddy\"))\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"malformed tag on field %s: %v\", fieldName, err))\n\t}\n\n\tmoduleNamespace, ok := opts[\"namespace\"]\n\tif !ok {\n\t\tpanic(fmt.Sprintf(\"missing 'namespace' key in struct tag on field %s\", fieldName))\n\t}\n\tinlineModuleKey := opts[\"inline_key\"]\n\n\tvar result any\n\n\tswitch val.Kind() {\n\tcase reflect.Slice:\n\t\tif isJSONRawMessage(typ) {\n\t\t\t// val is `json.RawMessage` ([]uint8 under the hood)\n\n\t\t\tif inlineModuleKey == \"\" {\n\t\t\t\tpanic(\"unable to determine module name without inline_key when type is not a ModuleMap\")\n\t\t\t}\n\t\t\tval, err := ctx.loadModuleInline(inlineModuleKey, moduleNamespace, val.Interface().(json.RawMessage))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tresult = val\n\t\t} else if isJSONRawMessage(typ.Elem()) {\n\t\t\t// val is `[]json.RawMessage`\n\n\t\t\tif inlineModuleKey == \"\" {\n\t\t\t\tpanic(\"unable to determine module name without inline_key because type is not a ModuleMap\")\n\t\t\t}\n\t\t\tvar all []any\n\t\t\tfor i := 0; i < val.Len(); i++ {\n\t\t\t\tval, err := ctx.loadModuleInline(inlineModuleKey, moduleNamespace, val.Index(i).Interface().(json.RawMessage))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, fmt.Errorf(\"position %d: %v\", i, err)\n\t\t\t\t}\n\t\t\t\tall = append(all, val)\n\t\t\t}\n\t\t\tresult = all\n\t\t} else if typ.Elem().Kind() == reflect.Slice && isJSONRawMessage(typ.Elem().Elem()) {\n\t\t\t// val is `[][]json.RawMessage`\n\n\t\t\tif inlineModuleKey == \"\" {\n\t\t\t\tpanic(\"unable to determine module name without inline_key because type is not a ModuleMap\")\n\t\t\t}\n\t\t\tvar all [][]any\n\t\t\tfor i := 0; i < val.Len(); i++ {\n\t\t\t\tinnerVal := val.Index(i)\n\t\t\t\tvar allInner []any\n\t\t\t\tfor j := 0; j < innerVal.Len(); j++ {\n\t\t\t\t\tinnerInnerVal, err := ctx.loadModuleInline(inlineModuleKey, moduleNamespace, innerVal.Index(j).Interface().(json.RawMessage))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"position %d: %v\", j, err)\n\t\t\t\t\t}\n\t\t\t\t\tallInner = append(allInner, innerInnerVal)\n\t\t\t\t}\n\t\t\t\tall = append(all, allInner)\n\t\t\t}\n\t\t\tresult = all\n\t\t} else if isModuleMapType(typ.Elem()) {\n\t\t\t// val is `[]map[string]json.RawMessage`\n\n\t\t\tvar all []map[string]any\n\t\t\tfor i := 0; i < val.Len(); i++ {\n\t\t\t\tthisSet, err := ctx.loadModulesFromSomeMap(moduleNamespace, inlineModuleKey, val.Index(i))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tall = append(all, thisSet)\n\t\t\t}\n\t\t\tresult = all\n\t\t}\n\n\tcase reflect.Map:\n\t\t// val is a ModuleMap or some other kind of map\n\t\tresult, err = ctx.loadModulesFromSomeMap(moduleNamespace, inlineModuleKey, val)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unrecognized type for module: %s\", typ)\n\t}\n\n\t// we're done with the raw bytes; allow GC to deallocate\n\tval.Set(reflect.Zero(typ))\n\n\treturn result, nil\n}\n\n// loadModulesFromSomeMap loads modules from val, which must be a type of map[string]any.\n// Depending on inlineModuleKey, it will be interpreted as either a ModuleMap (key is the module\n// name) or as a regular map (key is not the module name, and module name is defined inline).\nfunc (ctx Context) loadModulesFromSomeMap(namespace, inlineModuleKey string, val reflect.Value) (map[string]any, error) {\n\t// if no inline_key is specified, then val must be a ModuleMap,\n\t// where the key is the module name\n\tif inlineModuleKey == \"\" {\n\t\tif !isModuleMapType(val.Type()) {\n\t\t\tpanic(fmt.Sprintf(\"expected ModuleMap because inline_key is empty; but we do not recognize this type: %s\", val.Type()))\n\t\t}\n\t\treturn ctx.loadModuleMap(namespace, val)\n\t}\n\n\t// otherwise, val is a map with modules, but the module name is\n\t// inline with each value (the key means something else)\n\treturn ctx.loadModulesFromRegularMap(namespace, inlineModuleKey, val)\n}\n\n// loadModulesFromRegularMap loads modules from val, where val is a map[string]json.RawMessage.\n// Map keys are NOT interpreted as module names, so module names are still expected to appear\n// inline with the objects.\nfunc (ctx Context) loadModulesFromRegularMap(namespace, inlineModuleKey string, val reflect.Value) (map[string]any, error) {\n\tmods := make(map[string]any)\n\titer := val.MapRange()\n\tfor iter.Next() {\n\t\tk := iter.Key()\n\t\tv := iter.Value()\n\t\tmod, err := ctx.loadModuleInline(inlineModuleKey, namespace, v.Interface().(json.RawMessage))\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"key %s: %v\", k, err)\n\t\t}\n\t\tmods[k.String()] = mod\n\t}\n\treturn mods, nil\n}\n\n// loadModuleMap loads modules from a ModuleMap, i.e. map[string]any, where the key is the\n// module name. With a module map, module names do not need to be defined inline with their values.\nfunc (ctx Context) loadModuleMap(namespace string, val reflect.Value) (map[string]any, error) {\n\tall := make(map[string]any)\n\titer := val.MapRange()\n\tfor iter.Next() {\n\t\tk := iter.Key().Interface().(string)\n\t\tv := iter.Value().Interface().(json.RawMessage)\n\t\tmoduleName := namespace + \".\" + k\n\t\tif namespace == \"\" {\n\t\t\tmoduleName = k\n\t\t}\n\t\tval, err := ctx.LoadModuleByID(moduleName, v)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"module name '%s': %v\", k, err)\n\t\t}\n\t\tall[k] = val\n\t}\n\treturn all, nil\n}\n\n// LoadModuleByID decodes rawMsg into a new instance of mod and\n// returns the value. If mod.New is nil, an error is returned.\n// If the module implements Validator or Provisioner interfaces,\n// those methods are invoked to ensure the module is fully\n// configured and valid before being used.\n//\n// This is a lower-level method and will usually not be called\n// directly by most modules. However, this method is useful when\n// dynamically loading/unloading modules in their own context,\n// like from embedded scripts, etc.\nfunc (ctx Context) LoadModuleByID(id string, rawMsg json.RawMessage) (any, error) {\n\tmodulesMu.RLock()\n\tmodInfo, ok := modules[id]\n\tmodulesMu.RUnlock()\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"unknown module: %s\", id)\n\t}\n\n\tif modInfo.New == nil {\n\t\treturn nil, fmt.Errorf(\"module '%s' has no constructor\", modInfo.ID)\n\t}\n\n\tval := modInfo.New()\n\n\t// value must be a pointer for unmarshaling into concrete type, even if\n\t// the module's concrete type is a slice or map; New() *should* return\n\t// a pointer, otherwise unmarshaling errors or panics will occur\n\tif rv := reflect.ValueOf(val); rv.Kind() != reflect.Ptr {\n\t\tlog.Printf(\"[WARNING] ModuleInfo.New() for module '%s' did not return a pointer,\"+\n\t\t\t\" so we are using reflection to make a pointer instead; please fix this by\"+\n\t\t\t\" using new(Type) or &Type notation in your module's New() function.\", id)\n\t\tval = reflect.New(rv.Type()).Elem().Addr().Interface().(Module)\n\t}\n\n\t// fill in its config only if there is a config to fill in\n\tif len(rawMsg) > 0 {\n\t\terr := StrictUnmarshalJSON(rawMsg, &val)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"decoding module config: %s: %v\", modInfo, err)\n\t\t}\n\t}\n\n\tif val == nil {\n\t\t// returned module values are almost always type-asserted\n\t\t// before being used, so a nil value would panic; and there\n\t\t// is no good reason to explicitly declare null modules in\n\t\t// a config; it might be because the user is trying to achieve\n\t\t// a result the developer isn't expecting, which is a smell\n\t\treturn nil, fmt.Errorf(\"module value cannot be null\")\n\t}\n\n\tctx.ancestry = append(ctx.ancestry, val)\n\n\tif prov, ok := val.(Provisioner); ok {\n\t\terr := prov.Provision(ctx)\n\t\tif err != nil {\n\t\t\t// incomplete provisioning could have left state\n\t\t\t// dangling, so make sure it gets cleaned up\n\t\t\tif cleanerUpper, ok := val.(CleanerUpper); ok {\n\t\t\t\terr2 := cleanerUpper.Cleanup()\n\t\t\t\tif err2 != nil {\n\t\t\t\t\terr = fmt.Errorf(\"%v; additionally, cleanup: %v\", err, err2)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"provision %s: %v\", modInfo, err)\n\t\t}\n\t}\n\n\tif validator, ok := val.(Validator); ok {\n\t\terr := validator.Validate()\n\t\tif err != nil {\n\t\t\t// since the module was already provisioned, make sure we clean up\n\t\t\tif cleanerUpper, ok := val.(CleanerUpper); ok {\n\t\t\t\terr2 := cleanerUpper.Cleanup()\n\t\t\t\tif err2 != nil {\n\t\t\t\t\terr = fmt.Errorf(\"%v; additionally, cleanup: %v\", err, err2)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil, fmt.Errorf(\"%s: invalid configuration: %v\", modInfo, err)\n\t\t}\n\t}\n\n\tctx.moduleInstances[id] = append(ctx.moduleInstances[id], val)\n\n\treturn val, nil\n}\n\n// loadModuleInline loads a module from a JSON raw message which decodes to\n// a map[string]any, where one of the object keys is moduleNameKey\n// and the corresponding value is the module name (as a string) which can\n// be found in the given scope. In other words, the module name is declared\n// in-line with the module itself.\n//\n// This allows modules to be decoded into their concrete types and used when\n// their names cannot be the unique key in a map, such as when there are\n// multiple instances in the map or it appears in an array (where there are\n// no custom keys). In other words, the key containing the module name is\n// treated special/separate from all the other keys in the object.\nfunc (ctx Context) loadModuleInline(moduleNameKey, moduleScope string, raw json.RawMessage) (any, error) {\n\tmoduleName, raw, err := getModuleNameInline(moduleNameKey, raw)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tval, err := ctx.LoadModuleByID(moduleScope+\".\"+moduleName, raw)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"loading module '%s': %v\", moduleName, err)\n\t}\n\n\treturn val, nil\n}\n\n// App returns the configured app named name. If that app has\n// not yet been loaded and provisioned, it will be immediately\n// loaded and provisioned. If no app with that name is\n// configured, a new empty one will be instantiated instead.\n// (The app module must still be registered.) This must not be\n// called during the Provision/Validate phase to reference a\n// module's own host app (since the parent app module is still\n// in the process of being provisioned, it is not yet ready).\n//\n// We return any type instead of the App type because it is NOT\n// intended for the caller of this method to be the one to start\n// or stop App modules. The caller is expected to assert to the\n// concrete type.\nfunc (ctx Context) App(name string) (any, error) {\n\tif app, ok := ctx.cfg.apps[name]; ok {\n\t\treturn app, nil\n\t}\n\tappRaw := ctx.cfg.AppsRaw[name]\n\tmodVal, err := ctx.LoadModuleByID(name, appRaw)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"loading %s app module: %v\", name, err)\n\t}\n\tif appRaw != nil {\n\t\tctx.cfg.AppsRaw[name] = nil // allow GC to deallocate\n\t}\n\tctx.cfg.apps[name] = modVal.(App)\n\treturn modVal, nil\n}\n\n// AppIfConfigured is like App, but it returns an error if the\n// app has not been configured. This is useful when the app is\n// required and its absence is a configuration error; or when\n// the app is optional and you don't want to instantiate a\n// new one that hasn't been explicitly configured. If the app\n// is not in the configuration, the error wraps ErrNotConfigured.\nfunc (ctx Context) AppIfConfigured(name string) (any, error) {\n\tif ctx.cfg == nil {\n\t\treturn nil, fmt.Errorf(\"app module %s: %w\", name, ErrNotConfigured)\n\t}\n\tif app, ok := ctx.cfg.apps[name]; ok {\n\t\treturn app, nil\n\t}\n\tappRaw := ctx.cfg.AppsRaw[name]\n\tif appRaw == nil {\n\t\treturn nil, fmt.Errorf(\"app module %s: %w\", name, ErrNotConfigured)\n\t}\n\treturn ctx.App(name)\n}\n\n// ErrNotConfigured indicates a module is not configured.\nvar ErrNotConfigured = fmt.Errorf(\"module not configured\")\n\n// Storage returns the configured Caddy storage implementation.\nfunc (ctx Context) Storage() certmagic.Storage {\n\treturn ctx.cfg.storage\n}\n\n// Logger returns a logger that is intended for use by the most\n// recent module associated with the context. Callers should not\n// pass in any arguments unless they want to associate with a\n// different module; it panics if more than 1 value is passed in.\n//\n// Originally, this method's signature was `Logger(mod Module)`,\n// requiring that an instance of a Caddy module be passed in.\n// However, that is no longer necessary, as the closest module\n// most recently associated with the context will be automatically\n// assumed. To prevent a sudden breaking change, this method's\n// signature has been changed to be variadic, but we may remove\n// the parameter altogether in the future. Callers should not\n// pass in any argument. If there is valid need to specify a\n// different module, please open an issue to discuss.\n//\n// PARTIALLY DEPRECATED: The Logger(module) form is deprecated and\n// may be removed in the future. Do not pass in any arguments.\nfunc (ctx Context) Logger(module ...Module) *zap.Logger {\n\tif len(module) > 1 {\n\t\tpanic(\"more than 1 module passed in\")\n\t}\n\tif ctx.cfg == nil {\n\t\t// often the case in tests; just use a dev logger\n\t\tl, err := zap.NewDevelopment()\n\t\tif err != nil {\n\t\t\tpanic(\"config missing, unable to create dev logger: \" + err.Error())\n\t\t}\n\t\treturn l\n\t}\n\tmod := ctx.Module()\n\tif len(module) > 0 {\n\t\tmod = module[0]\n\t}\n\tif mod == nil {\n\t\treturn Log()\n\t}\n\treturn ctx.cfg.Logging.Logger(mod)\n}\n\n// Slogger returns a slog logger that is intended for use by\n// the most recent module associated with the context.\nfunc (ctx Context) Slogger() *slog.Logger {\n\tif ctx.cfg == nil {\n\t\t// often the case in tests; just use a dev logger\n\t\tl, err := zap.NewDevelopment()\n\t\tif err != nil {\n\t\t\tpanic(\"config missing, unable to create dev logger: \" + err.Error())\n\t\t}\n\t\treturn slog.New(zapslog.NewHandler(l.Core(), nil))\n\t}\n\tmod := ctx.Module()\n\tif mod == nil {\n\t\treturn slog.New(zapslog.NewHandler(Log().Core(), nil))\n\t}\n\treturn slog.New(zapslog.NewHandler(ctx.cfg.Logging.Logger(mod).Core(),\n\t\tzapslog.WithName(string(mod.CaddyModule().ID)),\n\t))\n}\n\n// Modules returns the lineage of modules that this context provisioned,\n// with the most recent/current module being last in the list.\nfunc (ctx Context) Modules() []Module {\n\tmods := make([]Module, len(ctx.ancestry))\n\tcopy(mods, ctx.ancestry)\n\treturn mods\n}\n\n// Module returns the current module, or the most recent one\n// provisioned by the context.\nfunc (ctx Context) Module() Module {\n\tif len(ctx.ancestry) == 0 {\n\t\treturn nil\n\t}\n\treturn ctx.ancestry[len(ctx.ancestry)-1]\n}\n\n// WithValue returns a new context with the given key-value pair.\nfunc (ctx *Context) WithValue(key, value any) Context {\n\treturn Context{\n\t\tContext:         context.WithValue(ctx.Context, key, value),\n\t\tmoduleInstances: ctx.moduleInstances,\n\t\tcfg:             ctx.cfg,\n\t\tancestry:        ctx.ancestry,\n\t\tcleanupFuncs:    ctx.cleanupFuncs,\n\t\texitFuncs:       ctx.exitFuncs,\n\t}\n}\n"
        },
        {
          "name": "context_test.go",
          "type": "blob",
          "size": 4.115234375,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n)\n\nfunc ExampleContext_LoadModule() {\n\t// this whole first part is just setting up for the example;\n\t// note the struct tags - very important; we specify inline_key\n\t// because that is the only way to know the module name\n\tvar ctx Context\n\tmyStruct := &struct {\n\t\t// This godoc comment will appear in module documentation.\n\t\tGuestModuleRaw json.RawMessage `json:\"guest_module,omitempty\" caddy:\"namespace=example inline_key=name\"`\n\n\t\t// this is where the decoded module will be stored; in this\n\t\t// example, we pretend we need an io.Writer but it can be\n\t\t// any interface type that is useful to you\n\t\tguestModule io.Writer\n\t}{\n\t\tGuestModuleRaw: json.RawMessage(`{\"name\":\"module_name\",\"foo\":\"bar\"}`),\n\t}\n\n\t// if a guest module is provided, we can load it easily\n\tif myStruct.GuestModuleRaw != nil {\n\t\tmod, err := ctx.LoadModule(myStruct, \"GuestModuleRaw\")\n\t\tif err != nil {\n\t\t\t// you'd want to actually handle the error here\n\t\t\t// return fmt.Errorf(\"loading guest module: %v\", err)\n\t\t}\n\t\t// mod contains the loaded and provisioned module,\n\t\t// it is now ready for us to use\n\t\tmyStruct.guestModule = mod.(io.Writer)\n\t}\n\n\t// use myStruct.guestModule from now on\n}\n\nfunc ExampleContext_LoadModule_array() {\n\t// this whole first part is just setting up for the example;\n\t// note the struct tags - very important; we specify inline_key\n\t// because that is the only way to know the module name\n\tvar ctx Context\n\tmyStruct := &struct {\n\t\t// This godoc comment will appear in module documentation.\n\t\tGuestModulesRaw []json.RawMessage `json:\"guest_modules,omitempty\" caddy:\"namespace=example inline_key=name\"`\n\n\t\t// this is where the decoded module will be stored; in this\n\t\t// example, we pretend we need an io.Writer but it can be\n\t\t// any interface type that is useful to you\n\t\tguestModules []io.Writer\n\t}{\n\t\tGuestModulesRaw: []json.RawMessage{\n\t\t\tjson.RawMessage(`{\"name\":\"module1_name\",\"foo\":\"bar1\"}`),\n\t\t\tjson.RawMessage(`{\"name\":\"module2_name\",\"foo\":\"bar2\"}`),\n\t\t},\n\t}\n\n\t// since our input is []json.RawMessage, the output will be []any\n\tmods, err := ctx.LoadModule(myStruct, \"GuestModulesRaw\")\n\tif err != nil {\n\t\t// you'd want to actually handle the error here\n\t\t// return fmt.Errorf(\"loading guest modules: %v\", err)\n\t}\n\tfor _, mod := range mods.([]any) {\n\t\tmyStruct.guestModules = append(myStruct.guestModules, mod.(io.Writer))\n\t}\n\n\t// use myStruct.guestModules from now on\n}\n\nfunc ExampleContext_LoadModule_map() {\n\t// this whole first part is just setting up for the example;\n\t// note the struct tags - very important; we don't specify\n\t// inline_key because the map key is the module name\n\tvar ctx Context\n\tmyStruct := &struct {\n\t\t// This godoc comment will appear in module documentation.\n\t\tGuestModulesRaw ModuleMap `json:\"guest_modules,omitempty\" caddy:\"namespace=example\"`\n\n\t\t// this is where the decoded module will be stored; in this\n\t\t// example, we pretend we need an io.Writer but it can be\n\t\t// any interface type that is useful to you\n\t\tguestModules map[string]io.Writer\n\t}{\n\t\tGuestModulesRaw: ModuleMap{\n\t\t\t\"module1_name\": json.RawMessage(`{\"foo\":\"bar1\"}`),\n\t\t\t\"module2_name\": json.RawMessage(`{\"foo\":\"bar2\"}`),\n\t\t},\n\t}\n\n\t// since our input is map[string]json.RawMessage, the output will be map[string]any\n\tmods, err := ctx.LoadModule(myStruct, \"GuestModulesRaw\")\n\tif err != nil {\n\t\t// you'd want to actually handle the error here\n\t\t// return fmt.Errorf(\"loading guest modules: %v\", err)\n\t}\n\tfor modName, mod := range mods.(map[string]any) {\n\t\tmyStruct.guestModules[modName] = mod.(io.Writer)\n\t}\n\n\t// use myStruct.guestModules from now on\n}\n"
        },
        {
          "name": "duration_fuzz.go",
          "type": "blob",
          "size": 0.751953125,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build gofuzz\n\npackage caddy\n\nfunc FuzzParseDuration(data []byte) int {\n\t_, err := ParseDuration(string(data))\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn 1\n}\n"
        },
        {
          "name": "filepath.go",
          "type": "blob",
          "size": 1.1708984375,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build !windows\n\npackage caddy\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// FastAbs is an optimized version of filepath.Abs for Unix systems,\n// since we don't expect the working directory to ever change once\n// Caddy is running. Avoid the os.Getwd() syscall overhead.\n// It's overall the same as stdlib's implementation, the difference\n// being cached working directory.\nfunc FastAbs(path string) (string, error) {\n\tif filepath.IsAbs(path) {\n\t\treturn filepath.Clean(path), nil\n\t}\n\tif wderr != nil {\n\t\treturn \"\", wderr\n\t}\n\treturn filepath.Join(wd, path), nil\n}\n\nvar wd, wderr = os.Getwd()\n"
        },
        {
          "name": "filepath_windows.go",
          "type": "blob",
          "size": 0.916015625,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"path/filepath\"\n)\n\n// FastAbs can't be optimized on Windows because there\n// are special file paths that require the use of syscall.FullPath\n// to handle correctly.\n// Just call stdlib's implementation which uses that function.\nfunc FastAbs(path string) (string, error) {\n\treturn filepath.Abs(path)\n}\n"
        },
        {
          "name": "filesystem.go",
          "type": "blob",
          "size": 0.7578125,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport \"io/fs\"\n\ntype FileSystems interface {\n\tRegister(k string, v fs.FS)\n\tUnregister(k string)\n\tGet(k string) (v fs.FS, ok bool)\n\tDefault() fs.FS\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 6.90234375,
          "content": "module github.com/caddyserver/caddy/v2\n\ngo 1.22.3\n\ntoolchain go1.23.0\n\nrequire (\n\tgithub.com/BurntSushi/toml v1.4.0\n\tgithub.com/Masterminds/sprig/v3 v3.3.0\n\tgithub.com/alecthomas/chroma/v2 v2.14.0\n\tgithub.com/aryann/difflib v0.0.0-20210328193216-ff5ff6dc229b\n\tgithub.com/caddyserver/certmagic v0.21.7-0.20250109205135-32654015b016\n\tgithub.com/caddyserver/zerossl v0.1.3\n\tgithub.com/dustin/go-humanize v1.0.1\n\tgithub.com/go-chi/chi/v5 v5.0.12\n\tgithub.com/google/cel-go v0.21.0\n\tgithub.com/google/uuid v1.6.0\n\tgithub.com/klauspost/compress v1.17.11\n\tgithub.com/klauspost/cpuid/v2 v2.2.9\n\tgithub.com/mholt/acmez/v3 v3.0.1\n\tgithub.com/prometheus/client_golang v1.19.1\n\tgithub.com/quic-go/quic-go v0.48.2\n\tgithub.com/smallstep/certificates v0.26.1\n\tgithub.com/smallstep/nosql v0.6.1\n\tgithub.com/smallstep/truststore v0.13.0\n\tgithub.com/spf13/cobra v1.8.1\n\tgithub.com/spf13/pflag v1.0.5\n\tgithub.com/stretchr/testify v1.9.0\n\tgithub.com/tailscale/tscert v0.0.0-20240608151842-d3f834017e53\n\tgithub.com/yuin/goldmark v1.7.8\n\tgithub.com/yuin/goldmark-highlighting/v2 v2.0.0-20230729083705-37449abec8cc\n\tgo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.56.0\n\tgo.opentelemetry.io/contrib/propagators/autoprop v0.42.0\n\tgo.opentelemetry.io/otel v1.31.0\n\tgo.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.31.0\n\tgo.opentelemetry.io/otel/sdk v1.31.0\n\tgo.uber.org/automaxprocs v1.6.0\n\tgo.uber.org/zap v1.27.0\n\tgo.uber.org/zap/exp v0.3.0\n\tgolang.org/x/crypto v0.31.0\n\tgolang.org/x/crypto/x509roots/fallback v0.0.0-20241104001025-71ed71b4faf9\n\tgolang.org/x/net v0.33.0\n\tgolang.org/x/sync v0.10.0\n\tgolang.org/x/term v0.27.0\n\tgolang.org/x/time v0.7.0\n\tgopkg.in/natefinch/lumberjack.v2 v2.2.1\n\tgopkg.in/yaml.v3 v3.0.1\n)\n\nrequire (\n\tdario.cat/mergo v1.0.1 // indirect\n\tgithub.com/Microsoft/go-winio v0.6.0 // indirect\n\tgithub.com/antlr4-go/antlr/v4 v4.13.0 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/francoispqt/gojay v1.2.13 // indirect\n\tgithub.com/fxamacker/cbor/v2 v2.6.0 // indirect\n\tgithub.com/go-jose/go-jose/v3 v3.0.3 // indirect\n\tgithub.com/go-kit/log v0.2.1 // indirect\n\tgithub.com/golang/glog v1.2.2 // indirect\n\tgithub.com/google/certificate-transparency-go v1.1.8-0.20240110162603-74a5dd331745 // indirect\n\tgithub.com/google/go-tpm v0.9.0 // indirect\n\tgithub.com/google/go-tspi v0.3.0 // indirect\n\tgithub.com/google/pprof v0.0.0-20231212022811-ec68065c825e // indirect\n\tgithub.com/grpc-ecosystem/grpc-gateway/v2 v2.22.0 // indirect\n\tgithub.com/onsi/ginkgo/v2 v2.13.2 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/quic-go/qpack v0.5.1 // indirect\n\tgithub.com/smallstep/go-attestation v0.4.4-0.20240109183208-413678f90935 // indirect\n\tgithub.com/smallstep/pkcs7 v0.0.0-20231024181729-3b98ecc1ca81 // indirect\n\tgithub.com/smallstep/scep v0.0.0-20231024192529-aee96d7ad34d // indirect\n\tgithub.com/x448/float16 v0.8.4 // indirect\n\tgithub.com/zeebo/blake3 v0.2.4 // indirect\n\tgo.opentelemetry.io/contrib/propagators/aws v1.17.0 // indirect\n\tgo.opentelemetry.io/contrib/propagators/b3 v1.17.0 // indirect\n\tgo.opentelemetry.io/contrib/propagators/jaeger v1.17.0 // indirect\n\tgo.opentelemetry.io/contrib/propagators/ot v1.17.0 // indirect\n\tgo.uber.org/mock v0.4.0 // indirect\n\tgolang.org/x/exp v0.0.0-20240506185415-9bf2ced13842 // indirect\n\tgoogle.golang.org/genproto/googleapis/api v0.0.0-20241007155032-5fefd90f89a9 // indirect\n\tgoogle.golang.org/genproto/googleapis/rpc v0.0.0-20241007155032-5fefd90f89a9 // indirect\n)\n\nrequire (\n\tfilippo.io/edwards25519 v1.1.0 // indirect\n\tgithub.com/AndreasBriese/bbloom v0.0.0-20190825152654-46b345b51c96 // indirect\n\tgithub.com/Masterminds/goutils v1.1.1 // indirect\n\tgithub.com/Masterminds/semver/v3 v3.3.0 // indirect\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/cenkalti/backoff/v4 v4.3.0 // indirect\n\tgithub.com/cespare/xxhash v1.1.0 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.3.0\n\tgithub.com/chzyer/readline v1.5.1 // indirect\n\tgithub.com/cpuguy83/go-md2man/v2 v2.0.4 // indirect\n\tgithub.com/dgraph-io/badger v1.6.2 // indirect\n\tgithub.com/dgraph-io/badger/v2 v2.2007.4 // indirect\n\tgithub.com/dgraph-io/ristretto v0.1.0 // indirect\n\tgithub.com/dgryski/go-farm v0.0.0-20200201041132-a6ae2369ad13 // indirect\n\tgithub.com/dlclark/regexp2 v1.11.0 // indirect\n\tgithub.com/felixge/httpsnoop v1.0.4 // indirect\n\tgithub.com/go-kit/kit v0.13.0 // indirect\n\tgithub.com/go-logfmt/logfmt v0.6.0 // indirect\n\tgithub.com/go-logr/logr v1.4.2 // indirect\n\tgithub.com/go-logr/stdr v1.2.2 // indirect\n\tgithub.com/go-sql-driver/mysql v1.7.1 // indirect\n\tgithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572 // indirect\n\tgithub.com/golang/protobuf v1.5.4 // indirect\n\tgithub.com/golang/snappy v0.0.4 // indirect\n\tgithub.com/huandu/xstrings v1.5.0 // indirect\n\tgithub.com/inconshreveable/mousetrap v1.1.0 // indirect\n\tgithub.com/jackc/chunkreader/v2 v2.0.1 // indirect\n\tgithub.com/jackc/pgconn v1.14.3 // indirect\n\tgithub.com/jackc/pgio v1.0.0 // indirect\n\tgithub.com/jackc/pgpassfile v1.0.0 // indirect\n\tgithub.com/jackc/pgproto3/v2 v2.3.3 // indirect\n\tgithub.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect\n\tgithub.com/jackc/pgtype v1.14.0 // indirect\n\tgithub.com/jackc/pgx/v4 v4.18.3 // indirect\n\tgithub.com/libdns/libdns v0.2.2\n\tgithub.com/manifoldco/promptui v0.9.0 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/mgutz/ansi v0.0.0-20200706080929-d51e80ef957d // indirect\n\tgithub.com/miekg/dns v1.1.62 // indirect\n\tgithub.com/mitchellh/copystructure v1.2.0 // indirect\n\tgithub.com/mitchellh/go-ps v1.0.0 // indirect\n\tgithub.com/mitchellh/reflectwalk v1.0.2 // indirect\n\tgithub.com/pires/go-proxyproto v0.7.1-0.20240628150027-b718e7ce4964\n\tgithub.com/pkg/errors v0.9.1 // indirect\n\tgithub.com/prometheus/client_model v0.5.0 // indirect\n\tgithub.com/prometheus/common v0.48.0 // indirect\n\tgithub.com/prometheus/procfs v0.12.0 // indirect\n\tgithub.com/rs/xid v1.5.0 // indirect\n\tgithub.com/russross/blackfriday/v2 v2.1.0 // indirect\n\tgithub.com/shopspring/decimal v1.4.0 // indirect\n\tgithub.com/shurcooL/sanitized_anchor_name v1.0.0 // indirect\n\tgithub.com/sirupsen/logrus v1.9.3 // indirect\n\tgithub.com/slackhq/nebula v1.6.1 // indirect\n\tgithub.com/spf13/cast v1.7.0 // indirect\n\tgithub.com/stoewer/go-strcase v1.2.0 // indirect\n\tgithub.com/urfave/cli v1.22.14 // indirect\n\tgo.etcd.io/bbolt v1.3.9 // indirect\n\tgo.opentelemetry.io/otel/exporters/otlp/otlptrace v1.31.0 // indirect\n\tgo.opentelemetry.io/otel/metric v1.31.0 // indirect\n\tgo.opentelemetry.io/otel/trace v1.31.0\n\tgo.opentelemetry.io/proto/otlp v1.3.1 // indirect\n\tgo.step.sm/cli-utils v0.9.0 // indirect\n\tgo.step.sm/crypto v0.45.0\n\tgo.step.sm/linkedca v0.20.1 // indirect\n\tgo.uber.org/multierr v1.11.0 // indirect\n\tgolang.org/x/mod v0.18.0 // indirect\n\tgolang.org/x/sys v0.28.0\n\tgolang.org/x/text v0.21.0 // indirect\n\tgolang.org/x/tools v0.22.0 // indirect\n\tgoogle.golang.org/grpc v1.67.1 // indirect\n\tgoogle.golang.org/protobuf v1.35.1 // indirect\n\thowett.net/plist v1.0.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 73.177734375,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.31.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.37.0/go.mod h1:TS1dMSSfndXH133OKGwekG838Om/cQT0BUHV3HcBgoo=\ncloud.google.com/go v0.112.1 h1:uJSeirPke5UNZHIb4SxfZklVSiWWVqW4oXlETwZziwM=\ncloud.google.com/go/auth v0.4.1 h1:Z7YNIhlWRtrnKlZke7z3GMqzvuYzdc2z98F9D1NV5Hg=\ncloud.google.com/go/auth v0.4.1/go.mod h1:QVBuVEKpCn4Zp58hzRGvL0tjRGU0YqdRTdCHM1IHnro=\ncloud.google.com/go/auth/oauth2adapt v0.2.2 h1:+TTV8aXpjeChS9M+aTtN/TjdQnzJvmzKFt//oWu7HX4=\ncloud.google.com/go/auth/oauth2adapt v0.2.2/go.mod h1:wcYjgpZI9+Yu7LyYBg4pqSiaRkfEK3GQcpb7C/uyF1Q=\ncloud.google.com/go/compute v1.23.3 h1:6sVlXXBmbd7jNX0Ipq0trII3e4n1/MsADLK6a+aiVlk=\ncloud.google.com/go/compute/metadata v0.5.0 h1:Zr0eK8JbFv6+Wi4ilXAR8FJ3wyNdpxHKJNPos6LTZOY=\ncloud.google.com/go/compute/metadata v0.5.0/go.mod h1:aHnloV2TPI38yx4s9+wAZhHykWvVCfu7hQbF+9CWoiY=\ncloud.google.com/go/iam v1.1.8 h1:r7umDwhj+BQyz0ScZMp4QrGXjSTI3ZINnpgU2nlB/K0=\ncloud.google.com/go/iam v1.1.8/go.mod h1:GvE6lyMmfxXauzNq8NbgJbeVQNspG+tcdL/W8QO1+zE=\ncloud.google.com/go/kms v1.16.0 h1:1yZsRPhmargZOmY+fVAh8IKiR9HzCb0U1zsxb5g2nRY=\ncloud.google.com/go/kms v1.16.0/go.mod h1:olQUXy2Xud+1GzYfiBO9N0RhjsJk5IJLU6n/ethLXVc=\ncloud.google.com/go/longrunning v0.5.7 h1:WLbHekDbjK1fVFD3ibpFFVoyizlLRl73I7YKuAKilhU=\ncloud.google.com/go/longrunning v0.5.7/go.mod h1:8GClkudohy1Fxm3owmBGid8W0pSgodEMwEAztp38Xng=\ndario.cat/mergo v1.0.1 h1:Ra4+bf83h2ztPIQYNP99R6m+Y7KfnARDfID+a+vLl4s=\ndario.cat/mergo v1.0.1/go.mod h1:uNxQE+84aUszobStD9th8a29P2fMDhsBdgRYvZOxGmk=\ndmitri.shuralyov.com/app/changes v0.0.0-20180602232624-0a106ad413e3/go.mod h1:Yl+fi1br7+Rr3LqpNJf1/uxUdtRUV+Tnj0o93V2B9MU=\ndmitri.shuralyov.com/html/belt v0.0.0-20180602232347-f7d459c86be0/go.mod h1:JLBrvjyP0v+ecvNYvCpyZgu5/xkfAUhi6wJj28eUfSU=\ndmitri.shuralyov.com/service/change v0.0.0-20181023043359-a85b471d5412/go.mod h1:a1inKt/atXimZ4Mv927x+r7UpyzRUf4emIoiiSC2TN4=\ndmitri.shuralyov.com/state v0.0.0-20180228185332-28bcc343414c/go.mod h1:0PRwlb0D6DFvNNtx+9ybjezNCa8XF0xaYcETyp6rHWU=\nfilippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=\nfilippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=\ngit.apache.org/thrift.git v0.0.0-20180902110319-2566ecd5d999/go.mod h1:fPE2ZNJGynbRyZ4dJvy6G277gSllfV2HJqblrnkyeyg=\ngithub.com/AndreasBriese/bbloom v0.0.0-20190825152654-46b345b51c96 h1:cTp8I5+VIoKjsnZuH8vjyaysT/ses3EvZeaV/1UkF2M=\ngithub.com/AndreasBriese/bbloom v0.0.0-20190825152654-46b345b51c96/go.mod h1:bOvUY6CB00SOBii9/FifXqc0awNKxLFCL/+pkDPuyl8=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/BurntSushi/toml v1.3.2/go.mod h1:CxXYINrC8qIiEnFrOxCa7Jy5BFHlXnUU2pbicEuybxQ=\ngithub.com/BurntSushi/toml v1.4.0 h1:kuoIxZQy2WRRk1pttg9asf+WVv6tWQuBNVmK8+nqPr0=\ngithub.com/BurntSushi/toml v1.4.0/go.mod h1:ukJfTF/6rtPPRCnwkur4qwRxa8vTRFBF0uk2lLoLwho=\ngithub.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=\ngithub.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=\ngithub.com/Masterminds/semver/v3 v3.1.1/go.mod h1:VPu/7SZ7ePZ3QOrcuXROw5FAcLl4a0cBrbBpGY/8hQs=\ngithub.com/Masterminds/semver/v3 v3.3.0 h1:B8LGeaivUe71a5qox1ICM/JLl0NqZSW5CHyL+hmvYS0=\ngithub.com/Masterminds/semver/v3 v3.3.0/go.mod h1:4V+yj/TJE1HU9XfppCwVMZq3I84lprf4nC11bSS5beM=\ngithub.com/Masterminds/sprig/v3 v3.3.0 h1:mQh0Yrg1XPo6vjYXgtf5OtijNAKJRNcTdOOGZe3tPhs=\ngithub.com/Masterminds/sprig/v3 v3.3.0/go.mod h1:Zy1iXRYNqNLUolqCpL4uhk6SHUMAOSCzdgBfDb35Lz0=\ngithub.com/Microsoft/go-winio v0.6.0 h1:slsWYD/zyx7lCXoZVlvQrj0hPTM1HI4+v1sIda2yDvg=\ngithub.com/Microsoft/go-winio v0.6.0/go.mod h1:cTAf44im0RAYeL23bpB+fzCyDH2MJiz2BO69KH/soAE=\ngithub.com/OneOfOne/xxhash v1.2.2 h1:KMrpdQIwFcEqXDklaen+P1axHaj9BSKzvpUUfnHldSE=\ngithub.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=\ngithub.com/alecthomas/assert/v2 v2.7.0 h1:QtqSACNS3tF7oasA8CU6A6sXZSBDqnm7RfpLl9bZqbE=\ngithub.com/alecthomas/assert/v2 v2.7.0/go.mod h1:Bze95FyfUr7x34QZrjL+XP+0qgp/zg8yS+TtBj1WA3k=\ngithub.com/alecthomas/chroma/v2 v2.2.0/go.mod h1:vf4zrexSH54oEjJ7EdB65tGNHmH3pGZmVkgTP5RHvAs=\ngithub.com/alecthomas/chroma/v2 v2.14.0 h1:R3+wzpnUArGcQz7fCETQBzO5n9IMNi13iIs46aU4V9E=\ngithub.com/alecthomas/chroma/v2 v2.14.0/go.mod h1:QolEbTfmUHIMVpBqxeDnNBj2uoeI4EbYP4i6n68SG4I=\ngithub.com/alecthomas/repr v0.0.0-20220113201626-b1b626ac65ae/go.mod h1:2kn6fqh/zIyPLmm3ugklbEi5hg5wS435eygvNfaDQL8=\ngithub.com/alecthomas/repr v0.4.0 h1:GhI2A8MACjfegCPVq9f1FLvIBS+DrQ2KQBFZP1iFzXc=\ngithub.com/alecthomas/repr v0.4.0/go.mod h1:Fr0507jx4eOXV7AlPV6AVZLYrLIuIeSOWtW57eE/O/4=\ngithub.com/anmitsu/go-shlex v0.0.0-20161002113705-648efa622239/go.mod h1:2FmKhYUyUczH0OGQWaF5ceTx0UBShxjsH6f8oGKYe2c=\ngithub.com/antlr4-go/antlr/v4 v4.13.0 h1:lxCg3LAv+EUK6t1i0y1V6/SLeUi0eKEKdhQAlS8TVTI=\ngithub.com/antlr4-go/antlr/v4 v4.13.0/go.mod h1:pfChB/xh/Unjila75QW7+VU4TSnWnnk9UTnmpPaOR2g=\ngithub.com/armon/consul-api v0.0.0-20180202201655-eb2c6b5be1b6/go.mod h1:grANhF5doyWs3UAsr3K4I6qtAmlQcZDesFNEHPZAzj8=\ngithub.com/aryann/difflib v0.0.0-20210328193216-ff5ff6dc229b h1:uUXgbcPDK3KpW29o4iy7GtuappbWT0l5NaMo9H9pJDw=\ngithub.com/aryann/difflib v0.0.0-20210328193216-ff5ff6dc229b/go.mod h1:DAHtR1m6lCRdSC2Tm3DSWRPvIPr6xNKyeHdqDQSQT+A=\ngithub.com/aws/aws-sdk-go-v2 v1.26.1 h1:5554eUqIYVWpU0YmeeYZ0wU64H2VLBs8TlhRB2L+EkA=\ngithub.com/aws/aws-sdk-go-v2 v1.26.1/go.mod h1:ffIFB97e2yNsv4aTSGkqtHnppsIJzw7G7BReUZ3jCXM=\ngithub.com/aws/aws-sdk-go-v2/config v1.27.13 h1:WbKW8hOzrWoOA/+35S5okqO/2Ap8hkkFUzoW8Hzq24A=\ngithub.com/aws/aws-sdk-go-v2/config v1.27.13/go.mod h1:XLiyiTMnguytjRER7u5RIkhIqS8Nyz41SwAWb4xEjxs=\ngithub.com/aws/aws-sdk-go-v2/credentials v1.17.13 h1:XDCJDzk/u5cN7Aple7D/MiAhx1Rjo/0nueJ0La8mRuE=\ngithub.com/aws/aws-sdk-go-v2/credentials v1.17.13/go.mod h1:FMNcjQrmuBYvOTZDtOLCIu0esmxjF7RuA/89iSXWzQI=\ngithub.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.1 h1:FVJ0r5XTHSmIHJV6KuDmdYhEpvlHpiSd38RQWhut5J4=\ngithub.com/aws/aws-sdk-go-v2/feature/ec2/imds v1.16.1/go.mod h1:zusuAeqezXzAB24LGuzuekqMAEgWkVYukBec3kr3jUg=\ngithub.com/aws/aws-sdk-go-v2/internal/configsources v1.3.5 h1:aw39xVGeRWlWx9EzGVnhOR4yOjQDHPQ6o6NmBlscyQg=\ngithub.com/aws/aws-sdk-go-v2/internal/configsources v1.3.5/go.mod h1:FSaRudD0dXiMPK2UjknVwwTYyZMRsHv3TtkabsZih5I=\ngithub.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.5 h1:PG1F3OD1szkuQPzDw3CIQsRIrtTlUC3lP84taWzHlq0=\ngithub.com/aws/aws-sdk-go-v2/internal/endpoints/v2 v2.6.5/go.mod h1:jU1li6RFryMz+so64PpKtudI+QzbKoIEivqdf6LNpOc=\ngithub.com/aws/aws-sdk-go-v2/internal/ini v1.8.0 h1:hT8rVHwugYE2lEfdFE0QWVo81lF7jMrYJVDWI+f+VxU=\ngithub.com/aws/aws-sdk-go-v2/internal/ini v1.8.0/go.mod h1:8tu/lYfQfFe6IGnaOdrpVgEL2IrrDOf6/m9RQum4NkY=\ngithub.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.2 h1:Ji0DY1xUsUr3I8cHps0G+XM3WWU16lP6yG8qu1GAZAs=\ngithub.com/aws/aws-sdk-go-v2/service/internal/accept-encoding v1.11.2/go.mod h1:5CsjAbs3NlGQyZNFACh+zztPDI7fU6eW9QsxjfnuBKg=\ngithub.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.7 h1:ogRAwT1/gxJBcSWDMZlgyFUM962F51A5CRhDLbxLdmo=\ngithub.com/aws/aws-sdk-go-v2/service/internal/presigned-url v1.11.7/go.mod h1:YCsIZhXfRPLFFCl5xxY+1T9RKzOKjCut+28JSX2DnAk=\ngithub.com/aws/aws-sdk-go-v2/service/kms v1.31.1 h1:5wtyAwuUiJiM3DHYeGZmP5iMonM7DFBWAEaaVPHYZA0=\ngithub.com/aws/aws-sdk-go-v2/service/kms v1.31.1/go.mod h1:2snWQJQUKsbN66vAawJuOGX7dr37pfOq9hb0tZDGIqQ=\ngithub.com/aws/aws-sdk-go-v2/service/sso v1.20.6 h1:o5cTaeunSpfXiLTIBx5xo2enQmiChtu1IBbzXnfU9Hs=\ngithub.com/aws/aws-sdk-go-v2/service/sso v1.20.6/go.mod h1:qGzynb/msuZIE8I75DVRCUXw3o3ZyBmUvMwQ2t/BrGM=\ngithub.com/aws/aws-sdk-go-v2/service/ssooidc v1.24.0 h1:Qe0r0lVURDDeBQJ4yP+BOrJkvkiCo/3FH/t+wY11dmw=\ngithub.com/aws/aws-sdk-go-v2/service/ssooidc v1.24.0/go.mod h1:mUYPBhaF2lGiukDEjJX2BLRRKTmoUSitGDUgM4tRxak=\ngithub.com/aws/aws-sdk-go-v2/service/sts v1.28.7 h1:et3Ta53gotFR4ERLXXHIHl/Uuk1qYpP5uU7cvNql8ns=\ngithub.com/aws/aws-sdk-go-v2/service/sts v1.28.7/go.mod h1:FZf1/nKNEkHdGGJP/cI2MoIMquumuRK6ol3QQJNDxmw=\ngithub.com/aws/smithy-go v1.20.2 h1:tbp628ireGtzcHDDmLT/6ADHidqnwgF57XOXZe6tp4Q=\ngithub.com/aws/smithy-go v1.20.2/go.mod h1:krry+ya/rV9RDcV/Q16kpu6ypI4K2czasz0NC3qS14E=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\ngithub.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/bradfitz/go-smtpd v0.0.0-20170404230938-deb6d6237625/go.mod h1:HYsPBTaaSFSlLx/70C2HPIMNZpVV8+vt/A+FMnYP11g=\ngithub.com/buger/jsonparser v0.0.0-20181115193947-bf1c66bbce23/go.mod h1:bbYlZJ7hK1yFx9hf58LP0zeX7UjIGs20ufpu3evjr+s=\ngithub.com/caddyserver/certmagic v0.21.7-0.20250109205135-32654015b016 h1:bwnFMkCXIgw3WO7vvMwpr7Zf8qfADmMzYe6mxSKC7zI=\ngithub.com/caddyserver/certmagic v0.21.7-0.20250109205135-32654015b016/go.mod h1:LCPG3WLxcnjVKl/xpjzM0gqh0knrKKKiO5WVttX2eEI=\ngithub.com/caddyserver/zerossl v0.1.3 h1:onS+pxp3M8HnHpN5MMbOMyNjmTheJyWRaZYwn+YTAyA=\ngithub.com/caddyserver/zerossl v0.1.3/go.mod h1:CxA0acn7oEGO6//4rtrRjYgEoa4MFw/XofZnrYwGqG4=\ngithub.com/cenkalti/backoff/v4 v4.3.0 h1:MyRJ/UdXutAwSAT+s3wNd7MfTIcy71VQueUuFK343L8=\ngithub.com/cenkalti/backoff/v4 v4.3.0/go.mod h1:Y3VNntkOUPxTVeUxJ/G5vcM//AlwfmyYozVcomhLiZE=\ngithub.com/cespare/xxhash v1.1.0 h1:a6HrQnmkObjyL+Gs60czilIUGqrzKutQD6XZog3p+ko=\ngithub.com/cespare/xxhash v1.1.0/go.mod h1:XrSqR1VqqWfGrhpAt58auRo0WTKS1nRRg3ghfAqPWnc=\ngithub.com/cespare/xxhash/v2 v2.1.1/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=\ngithub.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\ngithub.com/chzyer/logex v1.2.1 h1:XHDu3E6q+gdHgsdTPH6ImJMIp436vR6MPtH8gP05QzM=\ngithub.com/chzyer/logex v1.2.1/go.mod h1:JLbx6lG2kDbNRFnfkgvh4eRJRPX1QCoOIWomwysCBrQ=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\ngithub.com/chzyer/readline v1.5.1 h1:upd/6fQk4src78LMRzh5vItIt361/o4uq553V8B5sGI=\ngithub.com/chzyer/readline v1.5.1/go.mod h1:Eh+b79XXUwfKfcPLepksvw2tcLE/Ct21YObkaSkeBlk=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngithub.com/chzyer/test v1.0.0 h1:p3BQDXSxOhOG0P9z6/hGnII4LGiEPOYBhs8asl/fC04=\ngithub.com/chzyer/test v1.0.0/go.mod h1:2JlltgoNkt4TW/z9V/IzDdFaMTM2JPIi26O1pF38GC8=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/cockroachdb/apd v1.1.0 h1:3LFP3629v+1aKXU5Q37mxmRxX/pIu1nijXydLShEq5I=\ngithub.com/cockroachdb/apd v1.1.0/go.mod h1:8Sl8LxpKi29FqWXR16WEFZRNSz3SoPzUzeMeY4+DwBQ=\ngithub.com/coreos/etcd v3.3.10+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=\ngithub.com/coreos/go-etcd v2.0.0+incompatible/go.mod h1:Jez6KQU2B/sWsbdaef3ED8NzMklzPG4d5KIOhIy30Tk=\ngithub.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=\ngithub.com/coreos/go-systemd v0.0.0-20181012123002-c6f51f82210d/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/coreos/go-systemd v0.0.0-20190719114852-fd7a80b32e1f/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/cpuguy83/go-md2man v1.0.10/go.mod h1:SmD6nW6nTyfqj6ABTjUi3V3JVMnlJmwcJI5acqYI6dE=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.2/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.4 h1:wfIWP927BUkWJb2NmU/kNDYIBTh/ziUX91+lVfRxZq4=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.4/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com/creack/pty v1.1.7/go.mod h1:lj5s0c3V2DBrqTV7llrYr5NG6My20zk30Fl46Y7DoTY=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dgraph-io/badger v1.6.2 h1:mNw0qs90GVgGGWylh0umH5iag1j6n/PeJtNvL6KY/x8=\ngithub.com/dgraph-io/badger v1.6.2/go.mod h1:JW2yswe3V058sS0kZ2h/AXeDSqFjxnZcRrVH//y2UQE=\ngithub.com/dgraph-io/badger/v2 v2.2007.4 h1:TRWBQg8UrlUhaFdco01nO2uXwzKS7zd+HVdwV/GHc4o=\ngithub.com/dgraph-io/badger/v2 v2.2007.4/go.mod h1:vSw/ax2qojzbN6eXHIx6KPKtCSHJN/Uz0X0VPruTIhk=\ngithub.com/dgraph-io/ristretto v0.0.2/go.mod h1:KPxhHT9ZxKefz+PCeOGsrHpl1qZ7i70dGTu2u+Ahh6E=\ngithub.com/dgraph-io/ristretto v0.0.3-0.20200630154024-f66de99634de/go.mod h1:KPxhHT9ZxKefz+PCeOGsrHpl1qZ7i70dGTu2u+Ahh6E=\ngithub.com/dgraph-io/ristretto v0.1.0 h1:Jv3CGQHp9OjuMBSne1485aDpUkTKEcUqF+jm/LuerPI=\ngithub.com/dgraph-io/ristretto v0.1.0/go.mod h1:fux0lOrBhrVCJd3lcTHsIJhq1T2rokOu6v9Vcb3Q9ug=\ngithub.com/dgryski/go-farm v0.0.0-20190423205320-6a90982ecee2/go.mod h1:SqUrOPUnsFjfmXRMNPybcSiG0BgUW2AuFH8PAnS2iTw=\ngithub.com/dgryski/go-farm v0.0.0-20200201041132-a6ae2369ad13 h1:fAjc9m62+UWV/WAFKLNi6ZS0675eEUC9y3AlwSbQu1Y=\ngithub.com/dgryski/go-farm v0.0.0-20200201041132-a6ae2369ad13/go.mod h1:SqUrOPUnsFjfmXRMNPybcSiG0BgUW2AuFH8PAnS2iTw=\ngithub.com/dlclark/regexp2 v1.4.0/go.mod h1:2pZnwuY/m+8K6iRw6wQdMtk+rH5tNGR1i55kozfMjCc=\ngithub.com/dlclark/regexp2 v1.7.0/go.mod h1:DHkYz0B9wPfa6wondMfaivmHpzrQ3v9q8cnmRbL6yW8=\ngithub.com/dlclark/regexp2 v1.11.0 h1:G/nrcoOa7ZXlpoa/91N3X7mM3r8eIlMBBJZvsz/mxKI=\ngithub.com/dlclark/regexp2 v1.11.0/go.mod h1:DHkYz0B9wPfa6wondMfaivmHpzrQ3v9q8cnmRbL6yW8=\ngithub.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=\ngithub.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=\ngithub.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=\ngithub.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=\ngithub.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=\ngithub.com/flynn/go-shlex v0.0.0-20150515145356-3f9db97f8568/go.mod h1:xEzjJPgXI435gkrCt3MPfRiAkVrwSbHsst4LCFVfpJc=\ngithub.com/francoispqt/gojay v1.2.13 h1:d2m3sFjloqoIUQU3TsHBgj6qg/BVGlTBeHDUmyJnXKk=\ngithub.com/francoispqt/gojay v1.2.13/go.mod h1:ehT5mTG4ua4581f1++1WLG0vPdaA9HaiDsoyrBGkyDY=\ngithub.com/frankban/quicktest v1.14.6 h1:7Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=\ngithub.com/frankban/quicktest v1.14.6/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/fxamacker/cbor/v2 v2.6.0 h1:sU6J2usfADwWlYDAFhZBQ6TnLFBHxgesMrQfQgk1tWA=\ngithub.com/fxamacker/cbor/v2 v2.6.0/go.mod h1:pxXPTn3joSm21Gbwsv0w9OSA2y1HFR9qXEeXQVeNoDQ=\ngithub.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=\ngithub.com/gliderlabs/ssh v0.1.1/go.mod h1:U7qILu1NlMHj9FlMhZLlkCdDnU1DBEAqr0aevW3Awn0=\ngithub.com/go-chi/chi/v5 v5.0.12 h1:9euLV5sTrTNTRUU9POmDUvfxyj6LAABLUcEWO+JJb4s=\ngithub.com/go-chi/chi/v5 v5.0.12/go.mod h1:DslCQbL2OYiznFReuXYUmQ2hGd1aDpCnlMNITLSKoi8=\ngithub.com/go-errors/errors v1.0.1/go.mod h1:f4zRHt4oKfwPJE5k8C9vpYG+aDHdBFUsgrm6/TyX73Q=\ngithub.com/go-jose/go-jose/v3 v3.0.3 h1:fFKWeig/irsp7XD2zBxvnmA/XaRWp5V3CBsZXJF7G7k=\ngithub.com/go-jose/go-jose/v3 v3.0.3/go.mod h1:5b+7YgP7ZICgJDBdfjZaIt+H/9L9T/YQrVfLAMboGkQ=\ngithub.com/go-kit/kit v0.4.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-kit/kit v0.13.0 h1:OoneCcHKHQ03LfBpoQCUfCluwd2Vt3ohz+kvbJneZAU=\ngithub.com/go-kit/kit v0.13.0/go.mod h1:phqEHMMUbyrCFCTgH48JueqrM3md2HcAZ8N3XE4FKDg=\ngithub.com/go-kit/log v0.1.0/go.mod h1:zbhenjAZHb184qTLMA9ZjW7ThYL0H2mk7Q6pNt4vbaY=\ngithub.com/go-kit/log v0.2.1 h1:MRVx0/zhvdseW+Gza6N9rVzU/IVzaeE1SFI4raAhmBU=\ngithub.com/go-kit/log v0.2.1/go.mod h1:NwTd00d/i8cPZ3xOwwiv2PO5MOcx78fFErGNcVmBjv0=\ngithub.com/go-logfmt/logfmt v0.5.0/go.mod h1:wCYkCAKZfumFQihp8CzCvQ3paCTfi41vtzG1KdI/P7A=\ngithub.com/go-logfmt/logfmt v0.5.1/go.mod h1:WYhtIu8zTZfxdn5+rREduYbwxfcBr/Vr6KEVveWlfTs=\ngithub.com/go-logfmt/logfmt v0.6.0 h1:wGYYu3uicYdqXVgoYbvnkrPVXkuLM1p1ifugDMEdRi4=\ngithub.com/go-logfmt/logfmt v0.6.0/go.mod h1:WYhtIu8zTZfxdn5+rREduYbwxfcBr/Vr6KEVveWlfTs=\ngithub.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=\ngithub.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\ngithub.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=\ngithub.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=\ngithub.com/go-sql-driver/mysql v1.7.1 h1:lUIinVbN1DY0xBg0eMOzmmtGoHwWBbvnWubQUrtU8EI=\ngithub.com/go-sql-driver/mysql v1.7.1/go.mod h1:OXbVy3sEdcQ2Doequ6Z5BW6fXNQTmx+9S1MCJN5yJMI=\ngithub.com/go-stack/stack v1.6.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\ngithub.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\ngithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572 h1:tfuBGBXKqDEevZMzYi5KSi8KkcZtzBcTgAUUtapy0OI=\ngithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572/go.mod h1:9Pwr4B2jHnOSGXyyzV8ROjYa2ojvAY6HCGYYfMoC3Ls=\ngithub.com/gofrs/uuid v4.0.0+incompatible h1:1SD/1F5pU8p29ybwgQSwpQk+mwdRrXCYuPhW6m+TnJw=\ngithub.com/gofrs/uuid v4.0.0+incompatible/go.mod h1:b2aQJv3Z4Fp6yNu3cdSllBxTCLRxnplIgP/c0N/04lM=\ngithub.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/glog v1.2.2 h1:1+mZ9upx1Dh6FmUTFR1naJ77miKiXgALjWOZ3NVFPmY=\ngithub.com/golang/glog v1.2.2/go.mod h1:6AhwSGph0fcJtXVM/PEHPqZlFeoLxhs7/t5UDAwmO+w=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da h1:oI5xCqsCo564l8iNU+DwB5epxmsaqB+rhGL0m5jtYqE=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/lint v0.0.0-20180702182130-06c8688daad7/go.mod h1:tluoj9z5200jBnyusfRPU2LqT6J+DAorxEvtC7LHB+E=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=\ngithub.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=\ngithub.com/golang/snappy v0.0.3/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=\ngithub.com/golang/snappy v0.0.4 h1:yAGX7huGHXlcLOEtBnF4w7FQwA26wojNCwOYAEhLjQM=\ngithub.com/golang/snappy v0.0.4/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=\ngithub.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/btree v1.1.2 h1:xf4v41cLI2Z6FxbKm+8Bu+m8ifhj15JuZ9sa0jZCMUU=\ngithub.com/google/btree v1.1.2/go.mod h1:qOPhT0dTNdNzV6Z/lhRX0YXUafgPLFUh+gZMl761Gm4=\ngithub.com/google/cel-go v0.21.0 h1:cl6uW/gxN+Hy50tNYvI691+sXxioCnstFzLp2WO4GCI=\ngithub.com/google/cel-go v0.21.0/go.mod h1:rHUlWCcBKgyEk+eV03RPdZUekPp6YcJwV0FxuUksYxc=\ngithub.com/google/certificate-transparency-go v1.0.21/go.mod h1:QeJfpSbVSfYc7RgB3gJFj9cbuQMMchQxrWXz8Ruopmg=\ngithub.com/google/certificate-transparency-go v1.1.8-0.20240110162603-74a5dd331745 h1:heyoXNxkRT155x4jTAiSv5BVSVkueifPUm+Q8LUXMRo=\ngithub.com/google/certificate-transparency-go v1.1.8-0.20240110162603-74a5dd331745/go.mod h1:zN0wUQgV9LjwLZeFHnrAbQi8hzMVvEWePyk+MhPOk7k=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/go-github v17.0.0+incompatible/go.mod h1:zLgOLi98H3fifZn+44m+umXrS52loVEgC2AApnigrVQ=\ngithub.com/google/go-querystring v1.0.0/go.mod h1:odCYkC5MyYFN7vkCjXpyrEuKhc/BUO6wN/zVPAxq5ck=\ngithub.com/google/go-tpm v0.9.0 h1:sQF6YqWMi+SCXpsmS3fd21oPy/vSddwZry4JnmltHVk=\ngithub.com/google/go-tpm v0.9.0/go.mod h1:FkNVkc6C+IsvDI9Jw1OveJmxGZUUaKxtrpOS47QWKfU=\ngithub.com/google/go-tpm-tools v0.4.4 h1:oiQfAIkc6xTy9Fl5NKTeTJkBTlXdHsxAofmQyxBKY98=\ngithub.com/google/go-tpm-tools v0.4.4/go.mod h1:T8jXkp2s+eltnCDIsXR84/MTcVU9Ja7bh3Mit0pa4AY=\ngithub.com/google/go-tspi v0.3.0 h1:ADtq8RKfP+jrTyIWIZDIYcKOMecRqNJFOew2IT0Inus=\ngithub.com/google/go-tspi v0.3.0/go.mod h1:xfMGI3G0PhxCdNVcYr1C4C+EizojDg/TXuX5by8CiHI=\ngithub.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=\ngithub.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/google/pprof v0.0.0-20231212022811-ec68065c825e h1:bwOy7hAFd0C91URzMIEBfr6BAz29yk7Qj0cy6S7DJlU=\ngithub.com/google/pprof v0.0.0-20231212022811-ec68065c825e/go.mod h1:czg5+yv1E0ZGTi6S6vVK1mke0fV+FaUhNGcd6VRS9Ik=\ngithub.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=\ngithub.com/google/s2a-go v0.1.7 h1:60BLSyTrOV4/haCDW4zb1guZItoSq8foHCXrAnjBo/o=\ngithub.com/google/s2a-go v0.1.7/go.mod h1:50CgR4k1jNlWBu4UfS4AcfhVe1r6pdZPygJ3R8F0Qdw=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/googleapis/enterprise-certificate-proxy v0.3.2 h1:Vie5ybvEvT75RniqhfFxPRy3Bf7vr3h0cechB90XaQs=\ngithub.com/googleapis/enterprise-certificate-proxy v0.3.2/go.mod h1:VLSiSSBs/ksPL8kq3OBOQ6WRI2QnaFynd1DCjZ62+V0=\ngithub.com/googleapis/gax-go v2.0.0+incompatible h1:j0GKcs05QVmm7yesiZq2+9cxHkNK9YM6zKx4D2qucQU=\ngithub.com/googleapis/gax-go v2.0.0+incompatible/go.mod h1:SFVmujtThgffbyetf+mdk2eWhX2bMyUtNHzFKcPA9HY=\ngithub.com/googleapis/gax-go/v2 v2.0.3/go.mod h1:LLvjysVCY1JZeum8Z6l8qUty8fiNwE08qbEPm1M08qg=\ngithub.com/googleapis/gax-go/v2 v2.12.4 h1:9gWcmF85Wvq4ryPFvGFaOgPIs1AQX0d0bcbGw4Z96qg=\ngithub.com/googleapis/gax-go/v2 v2.12.4/go.mod h1:KYEYLorsnIGDi/rPC8b5TdlB9kbKoFubselGIoBMCwI=\ngithub.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\ngithub.com/gregjones/httpcache v0.0.0-20180305231024-9cad4c3443a7/go.mod h1:FecbI9+v66THATjSRHfNgh1IVFe/9kFxbXtjV0ctIMA=\ngithub.com/grpc-ecosystem/grpc-gateway v1.5.0/go.mod h1:RSKVYQBd5MCa4OVpNdGskqpgL2+G+NZTnrVHpWWfpdw=\ngithub.com/grpc-ecosystem/grpc-gateway/v2 v2.22.0 h1:asbCHRVmodnJTuQ3qamDwqVOIjwqUPTYmYuemVOx+Ys=\ngithub.com/grpc-ecosystem/grpc-gateway/v2 v2.22.0/go.mod h1:ggCgvZ2r7uOoQjOyu2Y1NhHmEPPzzuhWgcza5M1Ji1I=\ngithub.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=\ngithub.com/hexops/gotextdiff v1.0.3 h1:gitA9+qJrrTCsiCl7+kh75nPqQt1cx4ZkudSTLoUqJM=\ngithub.com/hexops/gotextdiff v1.0.3/go.mod h1:pSWU5MAI3yDq+fZBTazCSJysOMbxWL1BSow5/V2vxeg=\ngithub.com/huandu/xstrings v1.5.0 h1:2ag3IFq9ZDANvthTwTiqSSZLjDc+BedvHPAp5tJy2TI=\ngithub.com/huandu/xstrings v1.5.0/go.mod h1:y5/lhBue+AyNmUVz9RLU9xbLR0o4KIIExikq4ovT0aE=\ngithub.com/inconshreveable/mousetrap v1.0.0/go.mod h1:PxqpIevigyE2G7u3NXJIT2ANytuPF1OarO4DADm73n8=\ngithub.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=\ngithub.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=\ngithub.com/jackc/chunkreader v1.0.0/go.mod h1:RT6O25fNZIuasFJRyZ4R/Y2BbhasbmZXF9QQ7T3kePo=\ngithub.com/jackc/chunkreader/v2 v2.0.0/go.mod h1:odVSm741yZoC3dpHEUXIqA9tQRhFrgOHwnPIn9lDKlk=\ngithub.com/jackc/chunkreader/v2 v2.0.1 h1:i+RDz65UE+mmpjTfyz0MoVTnzeYxroil2G82ki7MGG8=\ngithub.com/jackc/chunkreader/v2 v2.0.1/go.mod h1:odVSm741yZoC3dpHEUXIqA9tQRhFrgOHwnPIn9lDKlk=\ngithub.com/jackc/pgconn v0.0.0-20190420214824-7e0022ef6ba3/go.mod h1:jkELnwuX+w9qN5YIfX0fl88Ehu4XC3keFuOJJk9pcnA=\ngithub.com/jackc/pgconn v0.0.0-20190824142844-760dd75542eb/go.mod h1:lLjNuW/+OfW9/pnVKPazfWOgNfH2aPem8YQ7ilXGvJE=\ngithub.com/jackc/pgconn v0.0.0-20190831204454-2fabfa3c18b7/go.mod h1:ZJKsE/KZfsUgOEh9hBm+xYTstcNHg7UPMVJqRfQxq4s=\ngithub.com/jackc/pgconn v1.8.0/go.mod h1:1C2Pb36bGIP9QHGBYCjnyhqu7Rv3sGshaQUvmfGIB/o=\ngithub.com/jackc/pgconn v1.9.0/go.mod h1:YctiPyvzfU11JFxoXokUOOKQXQmDMoJL9vJzHH8/2JY=\ngithub.com/jackc/pgconn v1.9.1-0.20210724152538-d89c8390a530/go.mod h1:4z2w8XhRbP1hYxkpTuBjTS3ne3J48K83+u0zoyvg2pI=\ngithub.com/jackc/pgconn v1.14.3 h1:bVoTr12EGANZz66nZPkMInAV/KHD2TxH9npjXXgiB3w=\ngithub.com/jackc/pgconn v1.14.3/go.mod h1:RZbme4uasqzybK2RK5c65VsHxoyaml09lx3tXOcO/VM=\ngithub.com/jackc/pgio v1.0.0 h1:g12B9UwVnzGhueNavwioyEEpAmqMe1E/BN9ES+8ovkE=\ngithub.com/jackc/pgio v1.0.0/go.mod h1:oP+2QK2wFfUWgr+gxjoBH9KGBb31Eio69xUb0w5bYf8=\ngithub.com/jackc/pgmock v0.0.0-20190831213851-13a1b77aafa2/go.mod h1:fGZlG77KXmcq05nJLRkk0+p82V8B8Dw8KN2/V9c/OAE=\ngithub.com/jackc/pgmock v0.0.0-20201204152224-4fe30f7445fd/go.mod h1:hrBW0Enj2AZTNpt/7Y5rr2xe/9Mn757Wtb2xeBzPv2c=\ngithub.com/jackc/pgmock v0.0.0-20210724152146-4ad1a8207f65 h1:DadwsjnMwFjfWc9y5Wi/+Zz7xoE5ALHsRQlOctkOiHc=\ngithub.com/jackc/pgmock v0.0.0-20210724152146-4ad1a8207f65/go.mod h1:5R2h2EEX+qri8jOWMbJCtaPWkrrNc7OHwsp2TCqp7ak=\ngithub.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=\ngithub.com/jackc/pgpassfile v1.0.0/go.mod h1:CEx0iS5ambNFdcRtxPj5JhEz+xB6uRky5eyVu/W2HEg=\ngithub.com/jackc/pgproto3 v1.1.0/go.mod h1:eR5FA3leWg7p9aeAqi37XOTgTIbkABlvcPB3E5rlc78=\ngithub.com/jackc/pgproto3/v2 v2.0.0-alpha1.0.20190420180111-c116219b62db/go.mod h1:bhq50y+xrl9n5mRYyCBFKkpRVTLYJVWeCc+mEAI3yXA=\ngithub.com/jackc/pgproto3/v2 v2.0.0-alpha1.0.20190609003834-432c2951c711/go.mod h1:uH0AWtUmuShn0bcesswc4aBTWGvw0cAxIJp+6OB//Wg=\ngithub.com/jackc/pgproto3/v2 v2.0.0-rc3/go.mod h1:ryONWYqW6dqSg1Lw6vXNMXoBJhpzvWKnT95C46ckYeM=\ngithub.com/jackc/pgproto3/v2 v2.0.0-rc3.0.20190831210041-4c03ce451f29/go.mod h1:ryONWYqW6dqSg1Lw6vXNMXoBJhpzvWKnT95C46ckYeM=\ngithub.com/jackc/pgproto3/v2 v2.0.6/go.mod h1:WfJCnwN3HIg9Ish/j3sgWXnAfK8A9Y0bwXYU5xKaEdA=\ngithub.com/jackc/pgproto3/v2 v2.1.1/go.mod h1:WfJCnwN3HIg9Ish/j3sgWXnAfK8A9Y0bwXYU5xKaEdA=\ngithub.com/jackc/pgproto3/v2 v2.3.3 h1:1HLSx5H+tXR9pW3in3zaztoEwQYRC9SQaYUHjTSUOag=\ngithub.com/jackc/pgproto3/v2 v2.3.3/go.mod h1:WfJCnwN3HIg9Ish/j3sgWXnAfK8A9Y0bwXYU5xKaEdA=\ngithub.com/jackc/pgservicefile v0.0.0-20200714003250-2b9c44734f2b/go.mod h1:vsD4gTJCa9TptPL8sPkXrLZ+hDuNrZCnj29CQpr4X1E=\ngithub.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a h1:bbPeKD0xmW/Y25WS6cokEszi5g+S0QxI/d45PkRi7Nk=\ngithub.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a/go.mod h1:5TJZWKEWniPve33vlWYSoGYefn3gLQRzjfDlhSJ9ZKM=\ngithub.com/jackc/pgtype v0.0.0-20190421001408-4ed0de4755e0/go.mod h1:hdSHsc1V01CGwFsrv11mJRHWJ6aifDLfdV3aVjFF0zg=\ngithub.com/jackc/pgtype v0.0.0-20190824184912-ab885b375b90/go.mod h1:KcahbBH1nCMSo2DXpzsoWOAfFkdEtEJpPbVLq8eE+mc=\ngithub.com/jackc/pgtype v0.0.0-20190828014616-a8802b16cc59/go.mod h1:MWlu30kVJrUS8lot6TQqcg7mtthZ9T0EoIBFiJcmcyw=\ngithub.com/jackc/pgtype v1.8.1-0.20210724151600-32e20a603178/go.mod h1:C516IlIV9NKqfsMCXTdChteoXmwgUceqaLfjg2e3NlM=\ngithub.com/jackc/pgtype v1.14.0 h1:y+xUdabmyMkJLyApYuPj38mW+aAIqCe5uuBB51rH3Vw=\ngithub.com/jackc/pgtype v1.14.0/go.mod h1:LUMuVrfsFfdKGLw+AFFVv6KtHOFMwRgDDzBt76IqCA4=\ngithub.com/jackc/pgx/v4 v4.0.0-20190420224344-cc3461e65d96/go.mod h1:mdxmSJJuR08CZQyj1PVQBHy9XOp5p8/SHH6a0psbY9Y=\ngithub.com/jackc/pgx/v4 v4.0.0-20190421002000-1b8f0016e912/go.mod h1:no/Y67Jkk/9WuGR0JG/JseM9irFbnEPbuWV2EELPNuM=\ngithub.com/jackc/pgx/v4 v4.0.0-pre1.0.20190824185557-6972a5742186/go.mod h1:X+GQnOEnf1dqHGpw7JmHqHc1NxDoalibchSk9/RWuDc=\ngithub.com/jackc/pgx/v4 v4.12.1-0.20210724153913-640aa07df17c/go.mod h1:1QD0+tgSXP7iUjYm9C1NxKhny7lq6ee99u/z+IHFcgs=\ngithub.com/jackc/pgx/v4 v4.18.3 h1:dE2/TrEsGX3RBprb3qryqSV9Y60iZN1C6i8IrmW9/BA=\ngithub.com/jackc/pgx/v4 v4.18.3/go.mod h1:Ey4Oru5tH5sB6tV7hDmfWFahwF15Eb7DNXlRKx2CkVw=\ngithub.com/jackc/puddle v0.0.0-20190413234325-e4ced69a3a2b/go.mod h1:m4B5Dj62Y0fbyuIc15OsIqK0+JU8nkqQjsgx7dvjSWk=\ngithub.com/jackc/puddle v0.0.0-20190608224051-11cab39313c9/go.mod h1:m4B5Dj62Y0fbyuIc15OsIqK0+JU8nkqQjsgx7dvjSWk=\ngithub.com/jackc/puddle v1.1.3/go.mod h1:m4B5Dj62Y0fbyuIc15OsIqK0+JU8nkqQjsgx7dvjSWk=\ngithub.com/jellevandenhooff/dkim v0.0.0-20150330215556-f50fe3d243e1/go.mod h1:E0B/fFc00Y+Rasa88328GlI/XbtyysCtTHZS8h7IrBU=\ngithub.com/jessevdk/go-flags v1.4.0/go.mod h1:4FA24M0QyGHXBuZZK/XkWh8h0e1EYbRYJSGM75WSRxI=\ngithub.com/json-iterator/go v1.1.6/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=\ngithub.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/klauspost/compress v1.12.3/go.mod h1:8dP1Hq4DHOhN9w426knH3Rhby4rFm6D8eO+e+Dq5Gzg=\ngithub.com/klauspost/compress v1.17.11 h1:In6xLpyWOi1+C7tXUUWv2ot1QvBjxevKAaI6IXrJmUc=\ngithub.com/klauspost/compress v1.17.11/go.mod h1:pMDklpSncoRMuLFrf1W9Ss9KT+0rH90U12bZKk7uwG0=\ngithub.com/klauspost/cpuid/v2 v2.2.9 h1:66ze0taIn2H33fBvCkXuv9BmCwDfafmiIVpKV9kKGuY=\ngithub.com/klauspost/cpuid/v2 v2.2.9/go.mod h1:rqkxqrZ1EhYM9G+hXH7YdowN5R5RGN6NK4QwQ3WMXF8=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.2/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pretty v0.2.0/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/pty v1.1.3/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/pty v1.1.8/go.mod h1:O1sed60cT9XZ5uDucP5qwvh+TE3NnUj51EiZO/lmSfw=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/lib/pq v1.0.0/go.mod h1:5WUZQaWbwv1U+lTReE5YruASi9Al49XbQIvNi/34Woo=\ngithub.com/lib/pq v1.1.0/go.mod h1:5WUZQaWbwv1U+lTReE5YruASi9Al49XbQIvNi/34Woo=\ngithub.com/lib/pq v1.2.0/go.mod h1:5WUZQaWbwv1U+lTReE5YruASi9Al49XbQIvNi/34Woo=\ngithub.com/lib/pq v1.10.2/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=\ngithub.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=\ngithub.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=\ngithub.com/libdns/libdns v0.2.2 h1:O6ws7bAfRPaBsgAYt8MDe2HcNBGC29hkZ9MX2eUSX3s=\ngithub.com/libdns/libdns v0.2.2/go.mod h1:4Bj9+5CQiNMVGf87wjX4CY3HQJypUHRuLvlsfsZqLWQ=\ngithub.com/lunixbochs/vtclean v1.0.0/go.mod h1:pHhQNgMf3btfWnGBVipUOjRYhoOsdGqdm/+2c2E2WMI=\ngithub.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=\ngithub.com/mailru/easyjson v0.0.0-20190312143242-1de009706dbe/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=\ngithub.com/manifoldco/promptui v0.9.0 h1:3V4HzJk1TtXW1MTZMP7mdlwbBpIinw3HztaIlYthEiA=\ngithub.com/manifoldco/promptui v0.9.0/go.mod h1:ka04sppxSGFAtxX0qhlYQjISsg9mR4GWtQEhdbn6Pgg=\ngithub.com/mattn/go-colorable v0.1.1/go.mod h1:FuOcm+DKB9mbwrcAfNl7/TZVBZ6rcnceauSikq3lYCQ=\ngithub.com/mattn/go-colorable v0.1.6/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.5/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/mattn/go-isatty v0.0.7/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=\ngithub.com/mgutz/ansi v0.0.0-20200706080929-d51e80ef957d h1:5PJl274Y63IEHC+7izoQE9x6ikvDFZS2mDVS3drnohI=\ngithub.com/mgutz/ansi v0.0.0-20200706080929-d51e80ef957d/go.mod h1:01TrycV0kFyexm33Z7vhZRXopbI8J3TDReVlkTgMUxE=\ngithub.com/mholt/acmez/v3 v3.0.1 h1:4PcjKjaySlgXK857aTfDuRbmnM5gb3Ruz3tvoSJAUp8=\ngithub.com/mholt/acmez/v3 v3.0.1/go.mod h1:L1wOU06KKvq7tswuMDwKdcHeKpFFgkppZy/y0DFxagQ=\ngithub.com/microcosm-cc/bluemonday v1.0.1/go.mod h1:hsXNsILzKxV+sX77C5b8FSuKF00vh2OMYv+xgHpAMF4=\ngithub.com/miekg/dns v1.1.62 h1:cN8OuEF1/x5Rq6Np+h1epln8OiyPWV+lROx9LxcGgIQ=\ngithub.com/miekg/dns v1.1.62/go.mod h1:mvDlcItzm+br7MToIKqkglaGhlFMHJ9DTNNWONWXbNQ=\ngithub.com/mitchellh/copystructure v1.2.0 h1:vpKXTN4ewci03Vljg/q9QvCGUDttBOGBIa15WveJJGw=\ngithub.com/mitchellh/copystructure v1.2.0/go.mod h1:qLl+cE2AmVv+CoeAwDPye/v+N2HKCj9FbZEVFJRxO9s=\ngithub.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=\ngithub.com/mitchellh/go-ps v1.0.0 h1:i6ampVEEF4wQFF+bkYfwYgY+F/uYJDktmvLPf7qIgjc=\ngithub.com/mitchellh/go-ps v1.0.0/go.mod h1:J4lOc8z8yJs6vUwklHw2XEIiT4z4C40KtWVN3nvg8Pg=\ngithub.com/mitchellh/mapstructure v1.1.2/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=\ngithub.com/mitchellh/reflectwalk v1.0.2 h1:G2LzWKi524PWgd3mLHV8Y5k7s6XUvT0Gef6zxSIeXaQ=\ngithub.com/mitchellh/reflectwalk v1.0.2/go.mod h1:mSTlrgnPZtwu0c4WaC2kGObEpuNDbx0jmZXqmk4esnw=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v1.0.1/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/neelance/astrewrite v0.0.0-20160511093645-99348263ae86/go.mod h1:kHJEU3ofeGjhHklVoIGuVj85JJwZ6kWPaJwCIxgnFmo=\ngithub.com/neelance/sourcemap v0.0.0-20151028013722-8c68805598ab/go.mod h1:Qr6/a/Q4r9LP1IltGz7tA7iOK1WonHEYhu1HRBA7ZiM=\ngithub.com/onsi/ginkgo/v2 v2.13.2 h1:Bi2gGVkfn6gQcjNjZJVO8Gf0FHzMPf2phUei9tejVMs=\ngithub.com/onsi/ginkgo/v2 v2.13.2/go.mod h1:XStQ8QcGwLyF4HdfcZB8SFOS/MWCgDuXMSBe6zrvLgM=\ngithub.com/onsi/gomega v1.29.0 h1:KIA/t2t5UBzoirT4H9tsML45GEbo3ouUnBHsCfD2tVg=\ngithub.com/onsi/gomega v1.29.0/go.mod h1:9sxs+SwGrKI0+PWe4Fxa9tFQQBG5xSsSbMXOI8PPpoQ=\ngithub.com/openzipkin/zipkin-go v0.1.1/go.mod h1:NtoC/o8u3JlF1lSlyPNswIbeQH9bJTmOf0Erfk+hxe8=\ngithub.com/pelletier/go-toml v1.2.0/go.mod h1:5z9KED0ma1S8pY6P1sdut58dfprrGBbd/94hg7ilaic=\ngithub.com/peterbourgon/diskv/v3 v3.0.1 h1:x06SQA46+PKIUftmEujdwSEpIx8kR+M9eLYsUxeYveU=\ngithub.com/peterbourgon/diskv/v3 v3.0.1/go.mod h1:kJ5Ny7vLdARGU3WUuy6uzO6T0nb/2gWcT1JiBvRmb5o=\ngithub.com/pires/go-proxyproto v0.7.1-0.20240628150027-b718e7ce4964 h1:ct/vxNBgHpASQ4sT8NaBX9LtsEtluZqaUJydLG50U3E=\ngithub.com/pires/go-proxyproto v0.7.1-0.20240628150027-b718e7ce4964/go.mod h1:iknsfgnH8EkjrMeMyvfKByp9TiBZCKZM0jx2xmKqnVY=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prashantv/gostub v1.1.0 h1:BTyx3RfQjRHnUWaGF9oQos79AlQ5k8WNktv7VGvVH4g=\ngithub.com/prashantv/gostub v1.1.0/go.mod h1:A5zLQHz7ieHGG7is6LLXLz7I8+3LZzsrV0P1IAHhP5U=\ngithub.com/prometheus/client_golang v0.8.0/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=\ngithub.com/prometheus/client_golang v1.19.1 h1:wZWJDwK+NameRJuPGDhlnFgx8e8HN3XHQeLaYJFJBOE=\ngithub.com/prometheus/client_golang v1.19.1/go.mod h1:mP78NwGzrVks5S2H6ab8+ZZGJLZUq1hoULYBAYBw1Ho=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.5.0 h1:VQw1hfvPvk3Uv6Qf29VrPF32JB6rtbgI6cYPYQjL0Qw=\ngithub.com/prometheus/client_model v0.5.0/go.mod h1:dTiFglRmd66nLR9Pv9f0mZi7B7fk5Pm3gvsjB5tr+kI=\ngithub.com/prometheus/common v0.0.0-20180801064454-c7de2306084e/go.mod h1:daVV7qP5qjZbuso7PdcryaAu0sAZbrN9i7WWcTMWvro=\ngithub.com/prometheus/common v0.48.0 h1:QO8U2CdOzSn1BBsmXJXduaaW+dY/5QLjfB8svtSzKKE=\ngithub.com/prometheus/common v0.48.0/go.mod h1:0/KsvlIEfPQCQ5I2iNSAWKPZziNCvRs5EC6ILDTlAPc=\ngithub.com/prometheus/procfs v0.0.0-20180725123919-05ee40e3a273/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.12.0 h1:jluTpSng7V9hY0O2R9DzzJHYb2xULk9VTR1V1R/k6Bo=\ngithub.com/prometheus/procfs v0.12.0/go.mod h1:pcuDEFsWDnvcgNzo4EEweacyhjeA9Zk3cnaOZAZEfOo=\ngithub.com/quic-go/qpack v0.5.1 h1:giqksBPnT/HDtZ6VhtFKgoLOWmlyo9Ei6u9PqzIMbhI=\ngithub.com/quic-go/qpack v0.5.1/go.mod h1:+PC4XFrEskIVkcLzpEkbLqq1uCoxPhQuvK5rH1ZgaEg=\ngithub.com/quic-go/quic-go v0.48.2 h1:wsKXZPeGWpMpCGSWqOcqpW2wZYic/8T3aqiOID0/KWE=\ngithub.com/quic-go/quic-go v0.48.2/go.mod h1:yBgs3rWBOADpga7F+jJsb6Ybg1LSYiQvwWlLX+/6HMs=\ngithub.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=\ngithub.com/rogpeppe/go-internal v1.13.1 h1:KvO1DLK/DRN07sQ1LQKScxyZJuNnedQ5/wKSR38lUII=\ngithub.com/rogpeppe/go-internal v1.13.1/go.mod h1:uMEvuHeurkdAXX61udpOXGD/AzZDWNMNyH2VO9fmH0o=\ngithub.com/rs/xid v1.2.1/go.mod h1:+uKXf+4Djp6Md1KODXJxgGQPKngRmWyn10oCKFzNHOQ=\ngithub.com/rs/xid v1.5.0 h1:mKX4bl4iPYJtEIxp6CYiUuLQ/8DYMoz0PUdtGgMFRVc=\ngithub.com/rs/xid v1.5.0/go.mod h1:trrq9SKmegXys3aeAKXMUTdJsYXVwGY3RLcfgqegfbg=\ngithub.com/rs/zerolog v1.13.0/go.mod h1:YbFCdg8HfsridGWAh22vktObvhZbQsZXe4/zB0OKkWU=\ngithub.com/rs/zerolog v1.15.0/go.mod h1:xYTKnLHcpfU2225ny5qZjxnj9NvkumZYjJHlAThCjNc=\ngithub.com/russross/blackfriday v1.5.2/go.mod h1:JO/DiYxRf+HjHt06OyowR9PTA263kcR/rfWxYHBV53g=\ngithub.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=\ngithub.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/satori/go.uuid v1.2.0/go.mod h1:dA0hQrYB0VpLJoorglMZABFdXlWrHn1NEOzdhQKdks0=\ngithub.com/schollz/jsonstore v1.1.0 h1:WZBDjgezFS34CHI+myb4s8GGpir3UMpy7vWoCeO0n6E=\ngithub.com/schollz/jsonstore v1.1.0/go.mod h1:15c6+9guw8vDRyozGjN3FoILt0wpruJk9Pi66vjaZfg=\ngithub.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAmXWZgo=\ngithub.com/shopspring/decimal v0.0.0-20180709203117-cd690d0c9e24/go.mod h1:M+9NzErvs504Cn4c5DxATwIqPbtswREoFCre64PpcG4=\ngithub.com/shopspring/decimal v1.2.0/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o=\ngithub.com/shopspring/decimal v1.4.0 h1:bxl37RwXBklmTi0C79JfXCEBD1cqqHt0bbgBAGFp81k=\ngithub.com/shopspring/decimal v1.4.0/go.mod h1:gawqmDU56v4yIKSwfBSFip1HdCCXN8/+DMd9qYNcwME=\ngithub.com/shurcooL/component v0.0.0-20170202220835-f88ec8f54cc4/go.mod h1:XhFIlyj5a1fBNx5aJTbKoIq0mNaPvOagO+HjB3EtxrY=\ngithub.com/shurcooL/events v0.0.0-20181021180414-410e4ca65f48/go.mod h1:5u70Mqkb5O5cxEA8nxTsgrgLehJeAw6Oc4Ab1c/P1HM=\ngithub.com/shurcooL/github_flavored_markdown v0.0.0-20181002035957-2122de532470/go.mod h1:2dOwnU2uBioM+SGy2aZoq1f/Sd1l9OkAeAUvjSyvgU0=\ngithub.com/shurcooL/go v0.0.0-20180423040247-9e1955d9fb6e/go.mod h1:TDJrrUr11Vxrven61rcy3hJMUqaf/CLWYhHNPmT14Lk=\ngithub.com/shurcooL/go-goon v0.0.0-20170922171312-37c2f522c041/go.mod h1:N5mDOmsrJOB+vfqUK+7DmDyjhSLIIBnXo9lvZJj3MWQ=\ngithub.com/shurcooL/gofontwoff v0.0.0-20180329035133-29b52fc0a18d/go.mod h1:05UtEgK5zq39gLST6uB0cf3NEHjETfB4Fgr3Gx5R9Vw=\ngithub.com/shurcooL/gopherjslib v0.0.0-20160914041154-feb6d3990c2c/go.mod h1:8d3azKNyqcHP1GaQE/c6dDgjkgSx2BZ4IoEi4F1reUI=\ngithub.com/shurcooL/highlight_diff v0.0.0-20170515013008-09bb4053de1b/go.mod h1:ZpfEhSmds4ytuByIcDnOLkTHGUI6KNqRNPDLHDk+mUU=\ngithub.com/shurcooL/highlight_go v0.0.0-20181028180052-98c3abbbae20/go.mod h1:UDKB5a1T23gOMUJrI+uSuH0VRDStOiUVSjBTRDVBVag=\ngithub.com/shurcooL/home v0.0.0-20181020052607-80b7ffcb30f9/go.mod h1:+rgNQw2P9ARFAs37qieuu7ohDNQ3gds9msbT2yn85sg=\ngithub.com/shurcooL/htmlg v0.0.0-20170918183704-d01228ac9e50/go.mod h1:zPn1wHpTIePGnXSHpsVPWEktKXHr6+SS6x/IKRb7cpw=\ngithub.com/shurcooL/httperror v0.0.0-20170206035902-86b7830d14cc/go.mod h1:aYMfkZ6DWSJPJ6c4Wwz3QtW22G7mf/PEgaB9k/ik5+Y=\ngithub.com/shurcooL/httpfs v0.0.0-20171119174359-809beceb2371/go.mod h1:ZY1cvUeJuFPAdZ/B6v7RHavJWZn2YPVFQ1OSXhCGOkg=\ngithub.com/shurcooL/httpgzip v0.0.0-20180522190206-b1c53ac65af9/go.mod h1:919LwcH0M7/W4fcZ0/jy0qGght1GIhqyS/EgWGH2j5Q=\ngithub.com/shurcooL/issues v0.0.0-20181008053335-6292fdc1e191/go.mod h1:e2qWDig5bLteJ4fwvDAc2NHzqFEthkqn7aOZAOpj+PQ=\ngithub.com/shurcooL/issuesapp v0.0.0-20180602232740-048589ce2241/go.mod h1:NPpHK2TI7iSaM0buivtFUc9offApnI0Alt/K8hcHy0I=\ngithub.com/shurcooL/notifications v0.0.0-20181007000457-627ab5aea122/go.mod h1:b5uSkrEVM1jQUspwbixRBhaIjIzL2xazXp6kntxYle0=\ngithub.com/shurcooL/octicon v0.0.0-20181028054416-fa4f57f9efb2/go.mod h1:eWdoE5JD4R5UVWDucdOPg1g2fqQRq78IQa9zlOV1vpQ=\ngithub.com/shurcooL/reactions v0.0.0-20181006231557-f2e0b4ca5b82/go.mod h1:TCR1lToEk4d2s07G3XGfz2QrgHXg4RJBvjrOozvoWfk=\ngithub.com/shurcooL/sanitized_anchor_name v0.0.0-20170918181015-86672fcb3f95/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\ngithub.com/shurcooL/sanitized_anchor_name v1.0.0 h1:PdmoCO6wvbs+7yrJyMORt4/BmY5IYyJwS/kOiWx8mHo=\ngithub.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\ngithub.com/shurcooL/users v0.0.0-20180125191416-49c67e49c537/go.mod h1:QJTqeLYEDaXHZDBsXlPCDqdhQuJkuw4NOtaxYe3xii4=\ngithub.com/shurcooL/webdavfs v0.0.0-20170829043945-18c3829fa133/go.mod h1:hKmq5kWdCj2z2KEozexVbfEZIWiTjhE0+UjmZgPqehw=\ngithub.com/sirupsen/logrus v1.4.1/go.mod h1:ni0Sbl8bgC9z8RoU9G6nDWqqs/fq4eDPysMBDgk/93Q=\ngithub.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=\ngithub.com/sirupsen/logrus v1.7.0/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=\ngithub.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=\ngithub.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=\ngithub.com/slackhq/nebula v1.6.1 h1:/OCTR3abj0Sbf2nGoLUrdDXImrCv0ZVFpVPP5qa0DsM=\ngithub.com/slackhq/nebula v1.6.1/go.mod h1:UmkqnXe4O53QwToSl/gG7sM4BroQwAB7dd4hUaT6MlI=\ngithub.com/smallstep/assert v0.0.0-20200723003110-82e2b9b3b262 h1:unQFBIznI+VYD1/1fApl1A+9VcBk+9dcqGfnePY87LY=\ngithub.com/smallstep/assert v0.0.0-20200723003110-82e2b9b3b262/go.mod h1:MyOHs9Po2fbM1LHej6sBUT8ozbxmMOFG+E+rx/GSGuc=\ngithub.com/smallstep/certificates v0.26.1 h1:FIUliEBcExSfJJDhRFA/s8aZgMIFuorexnRSKQd884o=\ngithub.com/smallstep/certificates v0.26.1/go.mod h1:OQMrW39IrGKDViKSHrKcgSQArMZ8c7EcjhYKK7mYqis=\ngithub.com/smallstep/go-attestation v0.4.4-0.20240109183208-413678f90935 h1:kjYvkvS/Wdy0PVRDUAA0gGJIVSEZYhiAJtfwYgOYoGA=\ngithub.com/smallstep/go-attestation v0.4.4-0.20240109183208-413678f90935/go.mod h1:vNAduivU014fubg6ewygkAvQC0IQVXqdc8vaGl/0er4=\ngithub.com/smallstep/nosql v0.6.1 h1:X8IBZFTRIp1gmuf23ne/jlD/BWKJtDQbtatxEn7Et1Y=\ngithub.com/smallstep/nosql v0.6.1/go.mod h1:vrN+CftYYNnDM+DQqd863ATynvYFm/6FuY9D4TeAm2Y=\ngithub.com/smallstep/pkcs7 v0.0.0-20231024181729-3b98ecc1ca81 h1:B6cED3iLJTgxpdh4tuqByDjRRKan2EvtnOfHr2zHJVg=\ngithub.com/smallstep/pkcs7 v0.0.0-20231024181729-3b98ecc1ca81/go.mod h1:SoUAr/4M46rZ3WaLstHxGhLEgoYIDRqxQEXLOmOEB0Y=\ngithub.com/smallstep/scep v0.0.0-20231024192529-aee96d7ad34d h1:06LUHn4Ia2X6syjIaCMNaXXDNdU+1N/oOHynJbWgpXw=\ngithub.com/smallstep/scep v0.0.0-20231024192529-aee96d7ad34d/go.mod h1:4d0ub42ut1mMtvGyMensjuHYEUpRrASvkzLEJvoRQcU=\ngithub.com/smallstep/truststore v0.13.0 h1:90if9htAOblavbMeWlqNLnO9bsjjgVv2hQeQJCi/py4=\ngithub.com/smallstep/truststore v0.13.0/go.mod h1:3tmMp2aLKZ/OA/jnFUB0cYPcho402UG2knuJoPh4j7A=\ngithub.com/sourcegraph/annotate v0.0.0-20160123013949-f4cad6c6324d/go.mod h1:UdhH50NIW0fCiwBSr0co2m7BnFLdv4fQTgdqdJTHFeE=\ngithub.com/sourcegraph/syntaxhighlight v0.0.0-20170531221838-bd320f5d308e/go.mod h1:HuIsMU8RRBOtsCgI77wP899iHVBQpCmg4ErYMZB+2IA=\ngithub.com/spaolacci/murmur3 v0.0.0-20180118202830-f09979ecbc72/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=\ngithub.com/spaolacci/murmur3 v1.1.0 h1:7c1g84S4BPRrfL5Xrdp6fOJ206sU9y293DDHaoy0bLI=\ngithub.com/spaolacci/murmur3 v1.1.0/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=\ngithub.com/spf13/afero v1.1.2/go.mod h1:j4pytiNVoe2o6bmDsKpLACNPDBIoEAkihy7loJ1B0CQ=\ngithub.com/spf13/cast v1.3.0/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=\ngithub.com/spf13/cast v1.7.0 h1:ntdiHjuueXFgm5nzDRdOS4yfT43P5Fnud6DH50rz/7w=\ngithub.com/spf13/cast v1.7.0/go.mod h1:ancEpBxwJDODSW/UG4rDrAqiKolqNNh2DX3mk86cAdo=\ngithub.com/spf13/cobra v0.0.5/go.mod h1:3K3wKZymM7VvHMDS9+Akkh4K60UwM26emMESw8tLCHU=\ngithub.com/spf13/cobra v1.8.1 h1:e5/vxKd/rZsfSJMUX1agtjeTDf+qv1/JdBF8gg5k9ZM=\ngithub.com/spf13/cobra v1.8.1/go.mod h1:wHxEcudfqmLYa8iTfL+OuZPbBZkmvliBWKIezN3kD9Y=\ngithub.com/spf13/jwalterweatherman v1.0.0/go.mod h1:cQK4TGJAtQXfYWX+Ddv3mKDzgVb68N+wFjFa4jdeBTo=\ngithub.com/spf13/pflag v1.0.3/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/spf13/viper v1.3.2/go.mod h1:ZiWeW+zYFKm7srdB9IoDzzZXaJaI5eL9QjNiN/DMA2s=\ngithub.com/stoewer/go-strcase v1.2.0 h1:Z2iHWqGXH00XYgqDmNgQbIBxf3wrNq0F3feEy0ainaU=\ngithub.com/stoewer/go-strcase v1.2.0/go.mod h1:IBiWB2sKIp3wVVQ3Y035++gc+knqhUQag1KpM8ahLw8=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.2.0/go.mod h1:qt09Ya8vawLte6SNmTgCsAVtYtaKzEcn8ATUoHMkEqE=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/tailscale/tscert v0.0.0-20240608151842-d3f834017e53 h1:uxMgm0C+EjytfAqyfBG55ZONKQ7mvd7x4YYCWsf8QHQ=\ngithub.com/tailscale/tscert v0.0.0-20240608151842-d3f834017e53/go.mod h1:kNGUQ3VESx3VZwRwA9MSCUegIl6+saPL8Noq82ozCaU=\ngithub.com/tarm/serial v0.0.0-20180830185346-98f6abe2eb07/go.mod h1:kDXzergiv9cbyO7IOYJZWg1U88JhDg3PB6klq9Hg2pA=\ngithub.com/ugorji/go/codec v0.0.0-20181204163529-d75b2dcb6bc8/go.mod h1:VFNgLljTbGfSG7qAOspJ7OScBnGdDN/yBr0sguwnwf0=\ngithub.com/urfave/cli v1.22.14 h1:ebbhrRiGK2i4naQJr+1Xj92HXZCrK7MsyTS/ob3HnAk=\ngithub.com/urfave/cli v1.22.14/go.mod h1:X0eDS6pD6Exaclxm99NJ3FiCDRED7vIHpx2mDOHLvkA=\ngithub.com/viant/assertly v0.4.8/go.mod h1:aGifi++jvCrUaklKEKT0BU95igDNaqkvz+49uaYMPRU=\ngithub.com/viant/toolbox v0.24.0/go.mod h1:OxMCG57V0PXuIP2HNQrtJf2CjqdmbrOx5EkMILuUhzM=\ngithub.com/x448/float16 v0.8.4 h1:qLwI1I70+NjRFUR3zs1JPUCgaCXSh3SW62uAKT1mSBM=\ngithub.com/x448/float16 v0.8.4/go.mod h1:14CWIYCyZA/cWjXOioeEpHeN/83MdbZDRQHoFcYsOfg=\ngithub.com/xordataexchange/crypt v0.0.3-0.20170626215501-b2862e3d0a77/go.mod h1:aYKd//L2LvnjZzWKhF00oedf4jCCReLcmhLdhm1A27Q=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngithub.com/yuin/goldmark v1.4.15/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngithub.com/yuin/goldmark v1.7.8 h1:iERMLn0/QJeHFhxSt3p6PeN9mGnvIKSpG9YYorDMnic=\ngithub.com/yuin/goldmark v1.7.8/go.mod h1:uzxRWxtg69N339t3louHJ7+O03ezfj6PlliRlaOzY1E=\ngithub.com/yuin/goldmark-highlighting/v2 v2.0.0-20230729083705-37449abec8cc h1:+IAOyRda+RLrxa1WC7umKOZRsGq4QrFFMYApOeHzQwQ=\ngithub.com/yuin/goldmark-highlighting/v2 v2.0.0-20230729083705-37449abec8cc/go.mod h1:ovIvrum6DQJA4QsJSovrkC4saKHQVs7TvcaeO8AIl5I=\ngithub.com/zeebo/assert v1.1.0 h1:hU1L1vLTHsnO8x8c9KAR5GmM5QscxHg5RNU5z5qbUWY=\ngithub.com/zeebo/assert v1.1.0/go.mod h1:Pq9JiuJQpG8JLJdtkwrJESF0Foym2/D9XMU5ciN/wJ0=\ngithub.com/zeebo/blake3 v0.2.4 h1:KYQPkhpRtcqh0ssGYcKLG1JYvddkEA8QwCM/yBqhaZI=\ngithub.com/zeebo/blake3 v0.2.4/go.mod h1:7eeQ6d2iXWRGF6npfaxl2CU+xy2Fjo2gxeyZGCRUjcE=\ngithub.com/zeebo/pcg v1.0.1 h1:lyqfGeWiv4ahac6ttHs+I5hwtH/+1mrhlCtVNQM2kHo=\ngithub.com/zeebo/pcg v1.0.1/go.mod h1:09F0S9iiKrwn9rlI5yjLkmrug154/YRW6KnnXVDM/l4=\ngithub.com/zenazn/goji v0.9.0/go.mod h1:7S9M489iMyHBNxwZnk9/EHS098H4/F6TATF2mIxtB1Q=\ngo.etcd.io/bbolt v1.3.9 h1:8x7aARPEXiXbHmtUwAIv7eV2fQFHrLLavdiJ3uzJXoI=\ngo.etcd.io/bbolt v1.3.9/go.mod h1:zaO32+Ti0PK1ivdPtgMESzuzL2VPoIG1PCQNvOdo/dE=\ngo.opencensus.io v0.18.0/go.mod h1:vKdFvxhtzZ9onBp9VKHK8z/sRpBMnKAsufL7wlDrCOA=\ngo.opencensus.io v0.24.0 h1:y73uSU6J157QMP2kn2r30vwW1A2W2WFwSCGnAVxeaD0=\ngo.opencensus.io v0.24.0/go.mod h1:vNK8G9p7aAivkbmorf4v+7Hgx+Zs0yY+0fOtgBfjQKo=\ngo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0 h1:4Pp6oUg3+e/6M4C0A/3kJ2VYa++dsWVTtGgLVj5xtHg=\ngo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0/go.mod h1:Mjt1i1INqiaoZOMGR1RIUJN+i3ChKoFRqzrRQhlkbs0=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.56.0 h1:UP6IpuHFkUgOQL9FFQFrZ+5LiwhhYRbi7VZSIx6Nj5s=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.56.0/go.mod h1:qxuZLtbq5QDtdeSHsS7bcf6EH6uO6jUAgk764zd3rhM=\ngo.opentelemetry.io/contrib/propagators/autoprop v0.42.0 h1:s2RzYOAqHVgG23q8fPWYChobUoZM6rJZ98EnylJr66w=\ngo.opentelemetry.io/contrib/propagators/autoprop v0.42.0/go.mod h1:Mv/tWNtZn+NbALDb2XcItP0OM3lWWZjAfSroINxfW+Y=\ngo.opentelemetry.io/contrib/propagators/aws v1.17.0 h1:IX8d7l2uRw61BlmZBOTQFaK+y22j6vytMVTs9wFrO+c=\ngo.opentelemetry.io/contrib/propagators/aws v1.17.0/go.mod h1:pAlCYRWff4uGqRXOVn3WP8pDZ5E0K56bEoG7a1VSL4k=\ngo.opentelemetry.io/contrib/propagators/b3 v1.17.0 h1:ImOVvHnku8jijXqkwCSyYKRDt2YrnGXD4BbhcpfbfJo=\ngo.opentelemetry.io/contrib/propagators/b3 v1.17.0/go.mod h1:IkfUfMpKWmynvvE0264trz0sf32NRTZL4nuAN9AbWRc=\ngo.opentelemetry.io/contrib/propagators/jaeger v1.17.0 h1:Zbpbmwav32Ea5jSotpmkWEl3a6Xvd4tw/3xxGO1i05Y=\ngo.opentelemetry.io/contrib/propagators/jaeger v1.17.0/go.mod h1:tcTUAlmO8nuInPDSBVfG+CP6Mzjy5+gNV4mPxMbL0IA=\ngo.opentelemetry.io/contrib/propagators/ot v1.17.0 h1:ufo2Vsz8l76eI47jFjuVyjyB3Ae2DmfiCV/o6Vc8ii0=\ngo.opentelemetry.io/contrib/propagators/ot v1.17.0/go.mod h1:SbKPj5XGp8K/sGm05XblaIABgMgw2jDczP8gGeuaVLk=\ngo.opentelemetry.io/otel v1.31.0 h1:NsJcKPIW0D0H3NgzPDHmo0WW6SptzPdqg/L1zsIm2hY=\ngo.opentelemetry.io/otel v1.31.0/go.mod h1:O0C14Yl9FgkjqcCZAsE053C13OaddMYr/hz6clDkEJE=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace v1.31.0 h1:K0XaT3DwHAcV4nKLzcQvwAgSyisUghWoY20I7huthMk=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace v1.31.0/go.mod h1:B5Ki776z/MBnVha1Nzwp5arlzBbE3+1jk+pGmaP5HME=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.31.0 h1:FFeLy03iVTXP6ffeN2iXrxfGsZGCjVx0/4KlizjyBwU=\ngo.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.31.0/go.mod h1:TMu73/k1CP8nBUpDLc71Wj/Kf7ZS9FK5b53VapRsP9o=\ngo.opentelemetry.io/otel/metric v1.31.0 h1:FSErL0ATQAmYHUIzSezZibnyVlft1ybhy4ozRPcF2fE=\ngo.opentelemetry.io/otel/metric v1.31.0/go.mod h1:C3dEloVbLuYoX41KpmAhOqNriGbA+qqH6PQ5E5mUfnY=\ngo.opentelemetry.io/otel/sdk v1.31.0 h1:xLY3abVHYZ5HSfOg3l2E5LUj2Cwva5Y7yGxnSW9H5Gk=\ngo.opentelemetry.io/otel/sdk v1.31.0/go.mod h1:TfRbMdhvxIIr/B2N2LQW2S5v9m3gOQ/08KsbbO5BPT0=\ngo.opentelemetry.io/otel/trace v1.31.0 h1:ffjsj1aRouKewfr85U2aGagJ46+MvodynlQ1HYdmJys=\ngo.opentelemetry.io/otel/trace v1.31.0/go.mod h1:TXZkRk7SM2ZQLtR6eoAWQFIHPvzQ06FJAsO1tJg480A=\ngo.opentelemetry.io/proto/otlp v1.3.1 h1:TrMUixzpM0yuc/znrFTP9MMRh8trP93mkCiDVeXrui0=\ngo.opentelemetry.io/proto/otlp v1.3.1/go.mod h1:0X1WI4de4ZsLrrJNLAQbFeLCm3T7yBkR0XqQ7niQU+8=\ngo.step.sm/cli-utils v0.9.0 h1:55jYcsQbnArNqepZyAwcato6Zy2MoZDRkWW+jF+aPfQ=\ngo.step.sm/cli-utils v0.9.0/go.mod h1:Y/CRoWl1FVR9j+7PnAewufAwKmBOTzR6l9+7EYGAnp8=\ngo.step.sm/crypto v0.45.0 h1:Z0WYAaaOYrJmKP9sJkPW+6wy3pgN3Ija8ek/D4serjc=\ngo.step.sm/crypto v0.45.0/go.mod h1:6IYlT0L2jfj81nVyCPpvA5cORy0EVHPhieSgQyuwHIY=\ngo.step.sm/linkedca v0.20.1 h1:bHDn1+UG1NgRrERkWbbCiAIvv4lD5NOFaswPDTyO5vU=\ngo.step.sm/linkedca v0.20.1/go.mod h1:Vaq4+Umtjh7DLFI1KuIxeo598vfBzgSYZUjgVJ7Syxw=\ngo.uber.org/atomic v1.3.2/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=\ngo.uber.org/atomic v1.4.0/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=\ngo.uber.org/atomic v1.5.0/go.mod h1:sABNBOSYdrvTF6hTgEIbc7YasKWGhgEQZyfxyTvoXHQ=\ngo.uber.org/atomic v1.6.0/go.mod h1:sABNBOSYdrvTF6hTgEIbc7YasKWGhgEQZyfxyTvoXHQ=\ngo.uber.org/automaxprocs v1.6.0 h1:O3y2/QNTOdbF+e/dpXNNW7Rx2hZ4sTIPyybbxyNqTUs=\ngo.uber.org/automaxprocs v1.6.0/go.mod h1:ifeIMSnPZuznNm6jmdzmU3/bfk01Fe2fotchwEFJ8r8=\ngo.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=\ngo.uber.org/goleak v1.3.0/go.mod h1:CoHD4mav9JJNrW/WLlf7HGZPjdw8EucARQHekz1X6bE=\ngo.uber.org/mock v0.4.0 h1:VcM4ZOtdbR4f6VXfiOpwpVJDL6lCReaZ6mw31wqh7KU=\ngo.uber.org/mock v0.4.0/go.mod h1:a6FSlNadKUHUa9IP5Vyt1zh4fC7uAwxMutEAscFbkZc=\ngo.uber.org/multierr v1.1.0/go.mod h1:wR5kodmAFQ0UK8QlbwjlSNy0Z68gJhDJUG5sjR94q/0=\ngo.uber.org/multierr v1.3.0/go.mod h1:VgVr7evmIr6uPjLBxg28wmKNXyqE9akIJ5XnfpiKl+4=\ngo.uber.org/multierr v1.5.0/go.mod h1:FeouvMocqHpRaaGuG9EjoKcStLC43Zu/fmqdUMPcKYU=\ngo.uber.org/multierr v1.11.0 h1:blXXJkSxSSfBVBlC76pxqeO+LN3aDfLQo+309xJstO0=\ngo.uber.org/multierr v1.11.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=\ngo.uber.org/tools v0.0.0-20190618225709-2cfd321de3ee/go.mod h1:vJERXedbb3MVM5f9Ejo0C68/HhF8uaILCdgjnY+goOA=\ngo.uber.org/zap v1.9.1/go.mod h1:vwi/ZaCAaUcBkycHslxD9B2zi4UTXhF60s6SWpuDF0Q=\ngo.uber.org/zap v1.10.0/go.mod h1:vwi/ZaCAaUcBkycHslxD9B2zi4UTXhF60s6SWpuDF0Q=\ngo.uber.org/zap v1.13.0/go.mod h1:zwrFLgMcdUuIBviXEYEH1YKNaOBnKXsx2IPda5bBwHM=\ngo.uber.org/zap v1.27.0 h1:aJMhYGrd5QSmlpLMr2MftRKl7t8J8PTZPA732ud/XR8=\ngo.uber.org/zap v1.27.0/go.mod h1:GB2qFLM7cTU87MWRP2mPIjqfIDnGu+VIO4V/SdhGo2E=\ngo.uber.org/zap/exp v0.3.0 h1:6JYzdifzYkGmTdRR59oYH+Ng7k49H9qVpWwNSsGJj3U=\ngo.uber.org/zap/exp v0.3.0/go.mod h1:5I384qq7XGxYyByIhHm6jg5CHkGY0nsTfbDLgDDlgJQ=\ngo4.org v0.0.0-20180809161055-417644f6feb5/go.mod h1:MkTOUMDaeVYJUOUsaDXIhWPZYa1yOyC1qaOBpL57BhE=\ngolang.org/x/build v0.0.0-20190111050920-041ab4dc3f9d/go.mod h1:OWs+y06UdEOHN4y+MfF/py+xQ/tYqIWW03b70/CG9Rw=\ngolang.org/x/crypto v0.0.0-20181030102418-4d3f4d9ffa16/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20181203042331-505ab145d0a9/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190411191339-88737f569e3a/go.mod h1:WFFai1msRO1wXaEeE5yQxYXgSfI8pQAWXbQop6sCtWE=\ngolang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190820162420-60c769a6c586/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20201203163018-be400aefbc4c/go.mod h1:jdWPYTVW3xRLrWPugEBEK3UY2ZEsg3UU495nc5E+M+I=\ngolang.org/x/crypto v0.0.0-20210616213533-5ff15b29337e/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.0.0-20210711020723-a769d52b0f97/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/crypto/x509roots/fallback v0.0.0-20241104001025-71ed71b4faf9 h1:4cEcP5+OjGppY79LCQ5Go2B1Boix2x0v6pvA01P3FoA=\ngolang.org/x/crypto/x509roots/fallback v0.0.0-20241104001025-71ed71b4faf9/go.mod h1:kNa9WdvYnzFwC79zRpLRMJbdEFlhyM5RPFBBZp/wWH8=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20240506185415-9bf2ced13842 h1:vr/HnozRka3pE4EsMEg1lgkXJkTFJCVUX+S/ZT6wYzM=\ngolang.org/x/exp v0.0.0-20240506185415-9bf2ced13842/go.mod h1:XtvwrStGgqGPLc4cjQfWqZHG1YFdYs6swckp8vpsjnc=\ngolang.org/x/lint v0.0.0-20180702182130-06c8688daad7/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=\ngolang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.18.0 h1:5+9lSbEzPSdWkH32vYPBwEpX8KwDbM52Ud9xBUvNlb0=\ngolang.org/x/mod v0.18.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181029044818-c44066c5c816/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181106065722-10aee1819953/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190313220215-9f648a60d977/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190813141303-74dc4d7220e7/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20181017192945-9dcd33a902f4/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20181203162652-d668ce993890/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.22.0 h1:BzDx2FehcG7jJwgWLELCdmLuxk2i+x9UDpSiss2u0ZA=\ngolang.org/x/oauth2 v0.22.0/go.mod h1:XYTD2NtWslqkgxebSiOHnXEap4TF09sJSc7H1sXbhtI=\ngolang.org/x/perf v0.0.0-20180704124530-6e6d33e29852/go.mod h1:JLpeXjPJfIyPr5TlbXLkXWLhP8nz10XfvxElABhCtcw=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181029174526-d69651ed3497/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181122145206-62eef0e2fa9b/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181205085412-a5c9d58dba9a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190316082340-a2f829d7f35f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190403152447-81d4e9dc473e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190422165155-953cdadca894/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190626221950-04f50cda93cb/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190813064441-fde4db37ae7a/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220310020820-b874c991c1a5/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201117132131-f5c789dd3221/go.mod h1:Nr5EML6q2oocZ2LXRh80K7BxOlk5/8JxuGnuhpl+muw=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\ngolang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\ngolang.org/x/term v0.27.0 h1:WP60Sv1nlK1T6SupCHbXzSaN0b9wUmsPoRS9b61A23Q=\ngolang.org/x/term v0.27.0/go.mod h1:iMsnZpn0cago0GOrHO2+Y7u7JPn5AylBrcoWkElMTSM=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.4/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/time v0.0.0-20180412165947-fbb02b2291d2/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.7.0 h1:ntUhktv3OPE6TgYxXWv9vKvUSJyIFJlyohwbkEwPrKQ=\ngolang.org/x/time v0.7.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\ngolang.org/x/tools v0.0.0-20180828015842-6cd1fcedba52/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20181030000716-a0a13e073c7b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190425163242-31fd60d6bfdc/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190621195816-6e04913cbbac/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190823170909-c4a336ef6a2f/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191029041327-9cc4af7d6b2c/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191029190741-b9c20aec41a5/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20200103221440-774c71fcf114/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/tools v0.22.0 h1:gqSGLZqv+AI9lIQzniJ0nZDRG5GBPsSi+DRNHWNz6yA=\ngolang.org/x/tools v0.22.0/go.mod h1:aCwcsjqvq7Yqt6TNyX7QMU2enbQ/Gt0bo6krSeEri+c=\ngolang.org/x/xerrors v0.0.0-20190410155217-1f06c39b4373/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20190513163551-3ee3066db522/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/api v0.0.0-20180910000450-7ca32eb868bf/go.mod h1:4mhQ8q/RsB7i+udVvVy5NUi08OU8ZlA0gRVgrF7VFY0=\ngoogle.golang.org/api v0.0.0-20181030000543-1d582fd0359e/go.mod h1:4mhQ8q/RsB7i+udVvVy5NUi08OU8ZlA0gRVgrF7VFY0=\ngoogle.golang.org/api v0.1.0/go.mod h1:UGEZY7KEX120AnNLIHFMKIo4obdJhkp2tPbaPlQx13Y=\ngoogle.golang.org/api v0.180.0 h1:M2D87Yo0rGBPWpo1orwfCLehUUL6E7/TYe5gvMQWDh4=\ngoogle.golang.org/api v0.180.0/go.mod h1:51AiyoEg1MJPSZ9zvklA8VnRILPXxn1iVen9v25XHAE=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.2.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.3.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20180831171423-11092d34479b/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20181029155118-b69ba1387ce2/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20181202183823-bd91e49a0898/go.mod h1:7Ep/1NZk928CDR8SjdVbjWNpdIf6nzjE3BTgJDr2Atg=\ngoogle.golang.org/genproto v0.0.0-20190306203927-b5d61aea6440/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20240401170217-c3f982113cda h1:wu/KJm9KJwpfHWhkkZGohVC6KRrc1oJNr4jwtQMOQXw=\ngoogle.golang.org/genproto v0.0.0-20240401170217-c3f982113cda/go.mod h1:g2LLCvCeCSir/JJSWosk19BR4NVxGqHUC6rxIRsd7Aw=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20241007155032-5fefd90f89a9 h1:T6rh4haD3GVYsgEfWExoCZA2o2FmbNyKpTuAxbEFPTg=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20241007155032-5fefd90f89a9/go.mod h1:wp2WsuBYj6j8wUdo3ToZsdxxixbvQNAHqVJrTgi5E5M=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20241007155032-5fefd90f89a9 h1:QCqS/PdaHTSWGvupk2F/ehwHtGc0/GYkT+3GAcR1CCc=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20241007155032-5fefd90f89a9/go.mod h1:GX3210XPVPUjJbTUbvwI8f2IpZDMZuPJWDzDuebbviI=\ngoogle.golang.org/grpc v1.14.0/go.mod h1:yo6s7OP7yaDglbqo1J04qKzAhqBH6lvTonzMVmEdcZw=\ngoogle.golang.org/grpc v1.16.0/go.mod h1:0JHn/cJsOMiMfNA9+DeHDlAU7KAAB5GDlYFpa9MZMio=\ngoogle.golang.org/grpc v1.17.0/go.mod h1:6QZJwpn2B+Zp71q/5VxRsJ6NXXVCE5NRUHRo+f3cWCs=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.67.1 h1:zWnc1Vrcno+lHZCOofnIMvycFcc0QRGIzm9dhnDX68E=\ngoogle.golang.org/grpc v1.67.1/go.mod h1:1gLDyUQU7CTLJI90u3nXZ9ekeghjeM7pTDZlqFNg2AA=\ngoogle.golang.org/protobuf v1.35.1 h1:m3LfL6/Ca+fqnjnlqQXNpFPABW1UD7mjh8KO2mKFytA=\ngoogle.golang.org/protobuf v1.35.1/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=\ngopkg.in/inconshreveable/log15.v2 v2.0.0-20180818164646-67afb5ed74ec/go.mod h1:aPpfJ7XW+gOuirDoZ8gHhLh3kZ1B08FtV2bbmy7Jv3s=\ngopkg.in/inf.v0 v0.9.1/go.mod h1:cWUDdTG/fYaXco+Dcufb5Vnc6Gp2YChqWtbxRZE0mXw=\ngopkg.in/natefinch/lumberjack.v2 v2.2.1 h1:bBRl1b0OH9s/DuPhuXpNl+VtCaJXFZ5/uEFST95x9zc=\ngopkg.in/natefinch/lumberjack.v2 v2.2.1/go.mod h1:YD8tP3GAjkrDg1eZH7EGmyESg/lsYskCTPBJVb9jqSc=\ngopkg.in/yaml.v1 v1.0.0-20140924161607-9f9df34309c0/go.mod h1:WDnlLJ4WF5VGsH/HVa3CI79GS0ol3YnhVnKP89i0kNg=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngrpc.go4.org v0.0.0-20170609214715-11d0a25b4919/go.mod h1:77eQGdRu53HpSqPFJFmuJdjuHRquDANNeA4x7B8WQ9o=\nhonnef.co/go/tools v0.0.0-20180728063816-88497007e858/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=\nhowett.net/plist v1.0.0 h1:7CrbWYbPPO/PyNy38b2EB/+gYbjCe2DXBxgtOOZbSQM=\nhowett.net/plist v1.0.0/go.mod h1:lqaXoTrLY4hg8tnEzNru53gicrbv7rrk+2xJA/7hw9g=\nsourcegraph.com/sourcegraph/go-diff v0.5.0/go.mod h1:kuch7UrkMzY0X+p9CRK03kfuPQ2zzQcaEFbx8wA8rck=\nsourcegraph.com/sqs/pbtypes v0.0.0-20180604144634-d3ebe8f20ae4/go.mod h1:ketZ/q3QxT9HOBeFhu6RdvsftgpsbFHBF5Cas6cDKZ0=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "listen.go",
          "type": "blob",
          "size": 9.4599609375,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build !unix || solaris\n\npackage caddy\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"slices\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n)\n\nfunc reuseUnixSocket(_, _ string) (any, error) {\n\treturn nil, nil\n}\n\nfunc listenReusable(ctx context.Context, lnKey string, network, address string, config net.ListenConfig) (any, error) {\n\tvar socketFile *os.File\n\n\tfd := slices.Contains([]string{\"fd\", \"fdgram\"}, network)\n\tif fd {\n\t\tsocketFd, err := strconv.ParseUint(address, 0, strconv.IntSize)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid file descriptor: %v\", err)\n\t\t}\n\n\t\tfunc() {\n\t\t\tsocketFilesMu.Lock()\n\t\t\tdefer socketFilesMu.Unlock()\n\n\t\t\tsocketFdWide := uintptr(socketFd)\n\t\t\tvar ok bool\n\n\t\t\tsocketFile, ok = socketFiles[socketFdWide]\n\n\t\t\tif !ok {\n\t\t\t\tsocketFile = os.NewFile(socketFdWide, lnKey)\n\t\t\t\tif socketFile != nil {\n\t\t\t\t\tsocketFiles[socketFdWide] = socketFile\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tif socketFile == nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid socket file descriptor: %d\", socketFd)\n\t\t}\n\t}\n\n\tdatagram := slices.Contains([]string{\"udp\", \"udp4\", \"udp6\", \"unixgram\", \"fdgram\"}, network)\n\tif datagram {\n\t\tsharedPc, _, err := listenerPool.LoadOrNew(lnKey, func() (Destructor, error) {\n\t\t\tvar (\n\t\t\t\tpc  net.PacketConn\n\t\t\t\terr error\n\t\t\t)\n\t\t\tif fd {\n\t\t\t\tpc, err = net.FilePacketConn(socketFile)\n\t\t\t} else {\n\t\t\t\tpc, err = config.ListenPacket(ctx, network, address)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn &sharedPacketConn{PacketConn: pc, key: lnKey}, nil\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &fakeClosePacketConn{sharedPacketConn: sharedPc.(*sharedPacketConn)}, nil\n\t}\n\n\tsharedLn, _, err := listenerPool.LoadOrNew(lnKey, func() (Destructor, error) {\n\t\tvar (\n\t\t\tln  net.Listener\n\t\t\terr error\n\t\t)\n\t\tif fd {\n\t\t\tln, err = net.FileListener(socketFile)\n\t\t} else {\n\t\t\tln, err = config.Listen(ctx, network, address)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &sharedListener{Listener: ln, key: lnKey}, nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &fakeCloseListener{sharedListener: sharedLn.(*sharedListener), keepAlivePeriod: config.KeepAlive}, nil\n}\n\n// fakeCloseListener is a private wrapper over a listener that\n// is shared. The state of fakeCloseListener is not shared.\n// This allows one user of a socket to \"close\" the listener\n// while in reality the socket stays open for other users of\n// the listener. In this way, servers become hot-swappable\n// while the listener remains running. Listeners should be\n// re-wrapped in a new fakeCloseListener each time the listener\n// is reused. This type is atomic and values must not be copied.\ntype fakeCloseListener struct {\n\tclosed          int32 // accessed atomically; belongs to this struct only\n\t*sharedListener       // embedded, so we also become a net.Listener\n\tkeepAlivePeriod time.Duration\n}\n\ntype canSetKeepAlive interface {\n\tSetKeepAlivePeriod(d time.Duration) error\n\tSetKeepAlive(bool) error\n}\n\nfunc (fcl *fakeCloseListener) Accept() (net.Conn, error) {\n\t// if the listener is already \"closed\", return error\n\tif atomic.LoadInt32(&fcl.closed) == 1 {\n\t\treturn nil, fakeClosedErr(fcl)\n\t}\n\n\t// call underlying accept\n\tconn, err := fcl.sharedListener.Accept()\n\tif err == nil {\n\t\t// if 0, do nothing, Go's default is already set\n\t\t// and if the connection allows setting KeepAlive, set it\n\t\tif tconn, ok := conn.(canSetKeepAlive); ok && fcl.keepAlivePeriod != 0 {\n\t\t\tif fcl.keepAlivePeriod > 0 {\n\t\t\t\terr = tconn.SetKeepAlivePeriod(fcl.keepAlivePeriod)\n\t\t\t} else { // negative\n\t\t\t\terr = tconn.SetKeepAlive(false)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tLog().With(zap.String(\"server\", fcl.sharedListener.key)).Warn(\"unable to set keepalive for new connection:\", zap.Error(err))\n\t\t\t}\n\t\t}\n\t\treturn conn, nil\n\t}\n\n\t// since Accept() returned an error, it may be because our reference to\n\t// the listener (this fakeCloseListener) may have been closed, i.e. the\n\t// server is shutting down; in that case, we need to clear the deadline\n\t// that we set when Close() was called, and return a non-temporary and\n\t// non-timeout error value to the caller, masking the \"true\" error, so\n\t// that server loops / goroutines won't retry, linger, and leak\n\tif atomic.LoadInt32(&fcl.closed) == 1 {\n\t\t// we dereference the sharedListener explicitly even though it's embedded\n\t\t// so that it's clear in the code that side-effects are shared with other\n\t\t// users of this listener, not just our own reference to it; we also don't\n\t\t// do anything with the error because all we could do is log it, but we\n\t\t// explicitly assign it to nothing so we don't forget it's there if needed\n\t\t_ = fcl.sharedListener.clearDeadline()\n\n\t\tif netErr, ok := err.(net.Error); ok && netErr.Timeout() {\n\t\t\treturn nil, fakeClosedErr(fcl)\n\t\t}\n\t}\n\n\treturn nil, err\n}\n\n// Close stops accepting new connections without closing the\n// underlying listener. The underlying listener is only closed\n// if the caller is the last known user of the socket.\nfunc (fcl *fakeCloseListener) Close() error {\n\tif atomic.CompareAndSwapInt32(&fcl.closed, 0, 1) {\n\t\t// There are two ways I know of to get an Accept()\n\t\t// function to return to the server loop that called\n\t\t// it: close the listener, or set a deadline in the\n\t\t// past. Obviously, we can't close the socket yet\n\t\t// since others may be using it (hence this whole\n\t\t// file). But we can set the deadline in the past,\n\t\t// and this is kind of cheating, but it works, and\n\t\t// it apparently even works on Windows.\n\t\t_ = fcl.sharedListener.setDeadline()\n\t\t_, _ = listenerPool.Delete(fcl.sharedListener.key)\n\t}\n\treturn nil\n}\n\n// sharedListener is a wrapper over an underlying listener. The listener\n// and the other fields on the struct are shared state that is synchronized,\n// so sharedListener structs must never be copied (always use a pointer).\ntype sharedListener struct {\n\tnet.Listener\n\tkey        string // uniquely identifies this listener\n\tdeadline   bool   // whether a deadline is currently set\n\tdeadlineMu sync.Mutex\n}\n\nfunc (sl *sharedListener) clearDeadline() error {\n\tvar err error\n\tsl.deadlineMu.Lock()\n\tif sl.deadline {\n\t\tswitch ln := sl.Listener.(type) {\n\t\tcase *net.TCPListener:\n\t\t\terr = ln.SetDeadline(time.Time{})\n\t\t}\n\t\tsl.deadline = false\n\t}\n\tsl.deadlineMu.Unlock()\n\treturn err\n}\n\nfunc (sl *sharedListener) setDeadline() error {\n\ttimeInPast := time.Now().Add(-1 * time.Minute)\n\tvar err error\n\tsl.deadlineMu.Lock()\n\tif !sl.deadline {\n\t\tswitch ln := sl.Listener.(type) {\n\t\tcase *net.TCPListener:\n\t\t\terr = ln.SetDeadline(timeInPast)\n\t\t}\n\t\tsl.deadline = true\n\t}\n\tsl.deadlineMu.Unlock()\n\treturn err\n}\n\n// Destruct is called by the UsagePool when the listener is\n// finally not being used anymore. It closes the socket.\nfunc (sl *sharedListener) Destruct() error {\n\treturn sl.Listener.Close()\n}\n\n// fakeClosePacketConn is like fakeCloseListener, but for PacketConns,\n// or more specifically, *net.UDPConn\ntype fakeClosePacketConn struct {\n\tclosed            int32 // accessed atomically; belongs to this struct only\n\t*sharedPacketConn       // embedded, so we also become a net.PacketConn; its key is used in Close\n}\n\nfunc (fcpc *fakeClosePacketConn) ReadFrom(p []byte) (n int, addr net.Addr, err error) {\n\t// if the listener is already \"closed\", return error\n\tif atomic.LoadInt32(&fcpc.closed) == 1 {\n\t\treturn 0, nil, &net.OpError{\n\t\t\tOp:   \"readfrom\",\n\t\t\tNet:  fcpc.LocalAddr().Network(),\n\t\t\tAddr: fcpc.LocalAddr(),\n\t\t\tErr:  errFakeClosed,\n\t\t}\n\t}\n\n\t// call underlying readfrom\n\tn, addr, err = fcpc.sharedPacketConn.ReadFrom(p)\n\tif err != nil {\n\t\t// this server was stopped, so clear the deadline and let\n\t\t// any new server continue reading; but we will exit\n\t\tif atomic.LoadInt32(&fcpc.closed) == 1 {\n\t\t\tif netErr, ok := err.(net.Error); ok && netErr.Timeout() {\n\t\t\t\tif err = fcpc.SetReadDeadline(time.Time{}); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\n\treturn\n}\n\n// Close won't close the underlying socket unless there is no more reference, then listenerPool will close it.\nfunc (fcpc *fakeClosePacketConn) Close() error {\n\tif atomic.CompareAndSwapInt32(&fcpc.closed, 0, 1) {\n\t\t_ = fcpc.SetReadDeadline(time.Now()) // unblock ReadFrom() calls to kick old servers out of their loops\n\t\t_, _ = listenerPool.Delete(fcpc.sharedPacketConn.key)\n\t}\n\treturn nil\n}\n\nfunc (fcpc *fakeClosePacketConn) Unwrap() net.PacketConn {\n\treturn fcpc.sharedPacketConn.PacketConn\n}\n\n// sharedPacketConn is like sharedListener, but for net.PacketConns.\ntype sharedPacketConn struct {\n\tnet.PacketConn\n\tkey string\n}\n\n// Destruct closes the underlying socket.\nfunc (spc *sharedPacketConn) Destruct() error {\n\treturn spc.PacketConn.Close()\n}\n\n// Unwrap returns the underlying socket\nfunc (spc *sharedPacketConn) Unwrap() net.PacketConn {\n\treturn spc.PacketConn\n}\n\n// Interface guards (see https://github.com/caddyserver/caddy/issues/3998)\nvar (\n\t_ (interface {\n\t\tUnwrap() net.PacketConn\n\t}) = (*fakeClosePacketConn)(nil)\n)\n\n// socketFiles is a fd -> *os.File map used to make a FileListener/FilePacketConn from a socket file descriptor.\nvar socketFiles = map[uintptr]*os.File{}\n\n// socketFilesMu synchronizes socketFiles insertions\nvar socketFilesMu sync.Mutex\n"
        },
        {
          "name": "listen_unix.go",
          "type": "blob",
          "size": 8.611328125,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Even though the filename ends in _unix.go, we still have to specify the\n// build constraint here, because the filename convention only works for\n// literal GOOS values, and \"unix\" is a shortcut unique to build tags.\n//go:build unix && !solaris\n\npackage caddy\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"net\"\n\t\"os\"\n\t\"slices\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// reuseUnixSocket copies and reuses the unix domain socket (UDS) if we already\n// have it open; if not, unlink it so we can have it.\n// No-op if not a unix network.\nfunc reuseUnixSocket(network, addr string) (any, error) {\n\tsocketKey := listenerKey(network, addr)\n\n\tsocket, exists := unixSockets[socketKey]\n\tif exists {\n\t\t// make copy of file descriptor\n\t\tsocketFile, err := socket.File() // does dup() deep down\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// use copied fd to make new Listener or PacketConn, then replace\n\t\t// it in the map so that future copies always come from the most\n\t\t// recent fd (as the previous ones will be closed, and we'd get\n\t\t// \"use of closed network connection\" errors) -- note that we\n\t\t// preserve the *pointer* to the counter (not just the value) so\n\t\t// that all socket wrappers will refer to the same value\n\t\tswitch unixSocket := socket.(type) {\n\t\tcase *unixListener:\n\t\t\tln, err := net.FileListener(socketFile)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tatomic.AddInt32(unixSocket.count, 1)\n\t\t\tunixSockets[socketKey] = &unixListener{ln.(*net.UnixListener), socketKey, unixSocket.count}\n\n\t\tcase *unixConn:\n\t\t\tpc, err := net.FilePacketConn(socketFile)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tatomic.AddInt32(unixSocket.count, 1)\n\t\t\tunixSockets[socketKey] = &unixConn{pc.(*net.UnixConn), socketKey, unixSocket.count}\n\t\t}\n\n\t\treturn unixSockets[socketKey], nil\n\t}\n\n\t// from what I can tell after some quick research, it's quite common for programs to\n\t// leave their socket file behind after they close, so the typical pattern is to\n\t// unlink it before you bind to it -- this is often crucial if the last program using\n\t// it was killed forcefully without a chance to clean up the socket, but there is a\n\t// race, as the comment in net.UnixListener.close() explains... oh well, I guess?\n\tif err := syscall.Unlink(addr); err != nil && !errors.Is(err, fs.ErrNotExist) {\n\t\treturn nil, err\n\t}\n\n\treturn nil, nil\n}\n\n// listenReusable creates a new listener for the given network and address, and adds it to listenerPool.\nfunc listenReusable(ctx context.Context, lnKey string, network, address string, config net.ListenConfig) (any, error) {\n\t// even though SO_REUSEPORT lets us bind the socket multiple times,\n\t// we still put it in the listenerPool so we can count how many\n\t// configs are using this socket; necessary to ensure we can know\n\t// whether to enforce shutdown delays, for example (see #5393).\n\tvar (\n\t\tln         io.Closer\n\t\terr        error\n\t\tsocketFile *os.File\n\t)\n\n\tfd := slices.Contains([]string{\"fd\", \"fdgram\"}, network)\n\tif fd {\n\t\tsocketFd, err := strconv.ParseUint(address, 0, strconv.IntSize)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid file descriptor: %v\", err)\n\t\t}\n\n\t\tfunc() {\n\t\t\tsocketFilesMu.Lock()\n\t\t\tdefer socketFilesMu.Unlock()\n\n\t\t\tsocketFdWide := uintptr(socketFd)\n\t\t\tvar ok bool\n\n\t\t\tsocketFile, ok = socketFiles[socketFdWide]\n\n\t\t\tif !ok {\n\t\t\t\tsocketFile = os.NewFile(socketFdWide, lnKey)\n\t\t\t\tif socketFile != nil {\n\t\t\t\t\tsocketFiles[socketFdWide] = socketFile\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tif socketFile == nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid socket file descriptor: %d\", socketFd)\n\t\t}\n\t} else {\n\t\t// wrap any Control function set by the user so we can also add our reusePort control without clobbering theirs\n\t\toldControl := config.Control\n\t\tconfig.Control = func(network, address string, c syscall.RawConn) error {\n\t\t\tif oldControl != nil {\n\t\t\t\tif err := oldControl(network, address, c); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn reusePort(network, address, c)\n\t\t}\n\t}\n\n\tdatagram := slices.Contains([]string{\"udp\", \"udp4\", \"udp6\", \"unixgram\", \"fdgram\"}, network)\n\tif datagram {\n\t\tif fd {\n\t\t\tln, err = net.FilePacketConn(socketFile)\n\t\t} else {\n\t\t\tln, err = config.ListenPacket(ctx, network, address)\n\t\t}\n\t} else {\n\t\tif fd {\n\t\t\tln, err = net.FileListener(socketFile)\n\t\t} else {\n\t\t\tln, err = config.Listen(ctx, network, address)\n\t\t}\n\t}\n\n\tif err == nil {\n\t\tlistenerPool.LoadOrStore(lnKey, nil)\n\t}\n\n\tif datagram {\n\t\tif !fd {\n\t\t\t// TODO: Not 100% sure this is necessary, but we do this for net.UnixListener, so...\n\t\t\tif unix, ok := ln.(*net.UnixConn); ok {\n\t\t\t\tone := int32(1)\n\t\t\t\tln = &unixConn{unix, lnKey, &one}\n\t\t\t\tunixSockets[lnKey] = ln.(*unixConn)\n\t\t\t}\n\t\t}\n\t\t// lightly wrap the connection so that when it is closed,\n\t\t// we can decrement the usage pool counter\n\t\tif specificLn, ok := ln.(net.PacketConn); ok {\n\t\t\tln = deletePacketConn{specificLn, lnKey}\n\t\t}\n\t} else {\n\t\tif !fd {\n\t\t\t// if new listener is a unix socket, make sure we can reuse it later\n\t\t\t// (we do our own \"unlink on close\" -- not required, but more tidy)\n\t\t\tif unix, ok := ln.(*net.UnixListener); ok {\n\t\t\t\tunix.SetUnlinkOnClose(false)\n\t\t\t\tone := int32(1)\n\t\t\t\tln = &unixListener{unix, lnKey, &one}\n\t\t\t\tunixSockets[lnKey] = ln.(*unixListener)\n\t\t\t}\n\t\t}\n\t\t// lightly wrap the listener so that when it is closed,\n\t\t// we can decrement the usage pool counter\n\t\tif specificLn, ok := ln.(net.Listener); ok {\n\t\t\tln = deleteListener{specificLn, lnKey}\n\t\t}\n\t}\n\n\t// other types, I guess we just return them directly\n\treturn ln, err\n}\n\n// reusePort sets SO_REUSEPORT. Ineffective for unix sockets.\nfunc reusePort(network, address string, conn syscall.RawConn) error {\n\tif IsUnixNetwork(network) {\n\t\treturn nil\n\t}\n\treturn conn.Control(func(descriptor uintptr) {\n\t\tif err := unix.SetsockoptInt(int(descriptor), unix.SOL_SOCKET, unixSOREUSEPORT, 1); err != nil {\n\t\t\tLog().Error(\"setting SO_REUSEPORT\",\n\t\t\t\tzap.String(\"network\", network),\n\t\t\t\tzap.String(\"address\", address),\n\t\t\t\tzap.Uintptr(\"descriptor\", descriptor),\n\t\t\t\tzap.Error(err))\n\t\t}\n\t})\n}\n\ntype unixListener struct {\n\t*net.UnixListener\n\tmapKey string\n\tcount  *int32 // accessed atomically\n}\n\nfunc (uln *unixListener) Close() error {\n\tnewCount := atomic.AddInt32(uln.count, -1)\n\tif newCount == 0 {\n\t\tfile, err := uln.File()\n\t\tvar name string\n\t\tif err == nil {\n\t\t\tname = file.Name()\n\t\t}\n\t\tdefer func() {\n\t\t\tunixSocketsMu.Lock()\n\t\t\tdelete(unixSockets, uln.mapKey)\n\t\t\tunixSocketsMu.Unlock()\n\t\t\tif err == nil {\n\t\t\t\t_ = syscall.Unlink(name)\n\t\t\t}\n\t\t}()\n\t}\n\treturn uln.UnixListener.Close()\n}\n\ntype unixConn struct {\n\t*net.UnixConn\n\tmapKey string\n\tcount  *int32 // accessed atomically\n}\n\nfunc (uc *unixConn) Close() error {\n\tnewCount := atomic.AddInt32(uc.count, -1)\n\tif newCount == 0 {\n\t\tfile, err := uc.File()\n\t\tvar name string\n\t\tif err == nil {\n\t\t\tname = file.Name()\n\t\t}\n\t\tdefer func() {\n\t\t\tunixSocketsMu.Lock()\n\t\t\tdelete(unixSockets, uc.mapKey)\n\t\t\tunixSocketsMu.Unlock()\n\t\t\tif err == nil {\n\t\t\t\t_ = syscall.Unlink(name)\n\t\t\t}\n\t\t}()\n\t}\n\treturn uc.UnixConn.Close()\n}\n\nfunc (uc *unixConn) Unwrap() net.PacketConn {\n\treturn uc.UnixConn\n}\n\n// unixSockets keeps track of the currently-active unix sockets\n// so we can transfer their FDs gracefully during reloads.\nvar unixSockets = make(map[string]interface {\n\tFile() (*os.File, error)\n})\n\n// socketFiles is a fd -> *os.File map used to make a FileListener/FilePacketConn from a socket file descriptor.\nvar socketFiles = map[uintptr]*os.File{}\n\n// socketFilesMu synchronizes socketFiles insertions\nvar socketFilesMu sync.Mutex\n\n// deleteListener is a type that simply deletes itself\n// from the listenerPool when it closes. It is used\n// solely for the purpose of reference counting (i.e.\n// counting how many configs are using a given socket).\ntype deleteListener struct {\n\tnet.Listener\n\tlnKey string\n}\n\nfunc (dl deleteListener) Close() error {\n\t_, _ = listenerPool.Delete(dl.lnKey)\n\treturn dl.Listener.Close()\n}\n\n// deletePacketConn is like deleteListener, but\n// for net.PacketConns.\ntype deletePacketConn struct {\n\tnet.PacketConn\n\tlnKey string\n}\n\nfunc (dl deletePacketConn) Close() error {\n\t_, _ = listenerPool.Delete(dl.lnKey)\n\treturn dl.PacketConn.Close()\n}\n\nfunc (dl deletePacketConn) Unwrap() net.PacketConn {\n\treturn dl.PacketConn\n}\n"
        },
        {
          "name": "listen_unix_setopt.go",
          "type": "blob",
          "size": 0.126953125,
          "content": "//go:build unix && !freebsd && !solaris\n\npackage caddy\n\nimport \"golang.org/x/sys/unix\"\n\nconst unixSOREUSEPORT = unix.SO_REUSEPORT\n"
        },
        {
          "name": "listen_unix_setopt_freebsd.go",
          "type": "blob",
          "size": 0.109375,
          "content": "//go:build freebsd\n\npackage caddy\n\nimport \"golang.org/x/sys/unix\"\n\nconst unixSOREUSEPORT = unix.SO_REUSEPORT_LB\n"
        },
        {
          "name": "listeners.go",
          "type": "blob",
          "size": 22.72265625,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"net\"\n\t\"net/netip\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/quic-go/quic-go\"\n\t\"github.com/quic-go/quic-go/http3\"\n\t\"github.com/quic-go/quic-go/qlog\"\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/time/rate\"\n\n\t\"github.com/caddyserver/caddy/v2/internal\"\n)\n\n// NetworkAddress represents one or more network addresses.\n// It contains the individual components for a parsed network\n// address of the form accepted by ParseNetworkAddress().\ntype NetworkAddress struct {\n\t// Should be a network value accepted by Go's net package or\n\t// by a plugin providing a listener for that network type.\n\tNetwork string\n\n\t// The \"main\" part of the network address is the host, which\n\t// often takes the form of a hostname, DNS name, IP address,\n\t// or socket path.\n\tHost string\n\n\t// For addresses that contain a port, ranges are given by\n\t// [StartPort, EndPort]; i.e. for a single port, StartPort\n\t// and EndPort are the same. For no port, they are 0.\n\tStartPort uint\n\tEndPort   uint\n}\n\n// ListenAll calls Listen for all addresses represented by this struct, i.e. all ports in the range.\n// (If the address doesn't use ports or has 1 port only, then only 1 listener will be created.)\n// It returns an error if any listener failed to bind, and closes any listeners opened up to that point.\nfunc (na NetworkAddress) ListenAll(ctx context.Context, config net.ListenConfig) ([]any, error) {\n\tvar listeners []any\n\tvar err error\n\n\t// if one of the addresses has a failure, we need to close\n\t// any that did open a socket to avoid leaking resources\n\tdefer func() {\n\t\tif err == nil {\n\t\t\treturn\n\t\t}\n\t\tfor _, ln := range listeners {\n\t\t\tif cl, ok := ln.(io.Closer); ok {\n\t\t\t\tcl.Close()\n\t\t\t}\n\t\t}\n\t}()\n\n\t// an address can contain a port range, which represents multiple addresses;\n\t// some addresses don't use ports at all and have a port range size of 1;\n\t// whatever the case, iterate each address represented and bind a socket\n\tfor portOffset := uint(0); portOffset < na.PortRangeSize(); portOffset++ {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\t// create (or reuse) the listener ourselves\n\t\tvar ln any\n\t\tln, err = na.Listen(ctx, portOffset, config)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlisteners = append(listeners, ln)\n\t}\n\n\treturn listeners, nil\n}\n\n// Listen is similar to net.Listen, with a few differences:\n//\n// Listen announces on the network address using the port calculated by adding\n// portOffset to the start port. (For network types that do not use ports, the\n// portOffset is ignored.)\n//\n// First Listen checks if a plugin can provide a listener from this address. Otherwise,\n// the provided ListenConfig is used to create the listener. Its Control function,\n// if set, may be wrapped by an internally-used Control function. The provided\n// context may be used to cancel long operations early. The context is not used\n// to close the listener after it has been created.\n//\n// Caddy's listeners can overlap each other: multiple listeners may be created on\n// the same socket at the same time. This is useful because during config changes,\n// the new config is started while the old config is still running. How this is\n// accomplished varies by platform and network type. For example, on Unix, SO_REUSEPORT\n// is set except on Unix sockets, for which the file descriptor is duplicated and\n// reused; on Windows, the close logic is virtualized using timeouts. Like normal\n// listeners, be sure to Close() them when you are done.\n//\n// This method returns any type, as the implementations of listeners for various\n// network types are not interchangeable. The type of listener returned is switched\n// on the network type. Stream-based networks (\"tcp\", \"unix\", \"unixpacket\", etc.)\n// return a net.Listener; datagram-based networks (\"udp\", \"unixgram\", etc.) return\n// a net.PacketConn; and so forth. The actual concrete types are not guaranteed to\n// be standard, exported types (wrapping is necessary to provide graceful reloads).\n//\n// Unix sockets will be unlinked before being created, to ensure we can bind to\n// it even if the previous program using it exited uncleanly; it will also be\n// unlinked upon a graceful exit (or when a new config does not use that socket).\n// Listen synchronizes binds to unix domain sockets to avoid race conditions\n// while an existing socket is unlinked.\nfunc (na NetworkAddress) Listen(ctx context.Context, portOffset uint, config net.ListenConfig) (any, error) {\n\tif na.IsUnixNetwork() {\n\t\tunixSocketsMu.Lock()\n\t\tdefer unixSocketsMu.Unlock()\n\t}\n\n\t// check to see if plugin provides listener\n\tif ln, err := getListenerFromPlugin(ctx, na.Network, na.Host, na.port(), portOffset, config); ln != nil || err != nil {\n\t\treturn ln, err\n\t}\n\n\t// create (or reuse) the listener ourselves\n\treturn na.listen(ctx, portOffset, config)\n}\n\nfunc (na NetworkAddress) listen(ctx context.Context, portOffset uint, config net.ListenConfig) (any, error) {\n\tvar (\n\t\tln           any\n\t\terr          error\n\t\taddress      string\n\t\tunixFileMode fs.FileMode\n\t)\n\n\t// split unix socket addr early so lnKey\n\t// is independent of permissions bits\n\tif na.IsUnixNetwork() {\n\t\taddress, unixFileMode, err = internal.SplitUnixSocketPermissionsBits(na.Host)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else if na.IsFdNetwork() {\n\t\taddress = na.Host\n\t} else {\n\t\taddress = na.JoinHostPort(portOffset)\n\t}\n\n\tif strings.HasPrefix(na.Network, \"ip\") {\n\t\tln, err = config.ListenPacket(ctx, na.Network, address)\n\t} else {\n\t\tif na.IsUnixNetwork() {\n\t\t\t// if this is a unix socket, see if we already have it open\n\t\t\tln, err = reuseUnixSocket(na.Network, address)\n\t\t}\n\n\t\tif ln == nil && err == nil {\n\t\t\t// otherwise, create a new listener\n\t\t\tlnKey := listenerKey(na.Network, address)\n\t\t\tln, err = listenReusable(ctx, lnKey, na.Network, address, config)\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif ln == nil {\n\t\treturn nil, fmt.Errorf(\"unsupported network type: %s\", na.Network)\n\t}\n\n\tif IsUnixNetwork(na.Network) {\n\t\tisAbstractUnixSocket := strings.HasPrefix(address, \"@\")\n\t\tif !isAbstractUnixSocket {\n\t\t\terr = os.Chmod(address, unixFileMode)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"unable to set permissions (%s) on %s: %v\", unixFileMode, address, err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ln, nil\n}\n\n// IsUnixNetwork returns true if na.Network is\n// unix, unixgram, or unixpacket.\nfunc (na NetworkAddress) IsUnixNetwork() bool {\n\treturn IsUnixNetwork(na.Network)\n}\n\n// IsUnixNetwork returns true if na.Network is\n// fd or fdgram.\nfunc (na NetworkAddress) IsFdNetwork() bool {\n\treturn IsFdNetwork(na.Network)\n}\n\n// JoinHostPort is like net.JoinHostPort, but where the port\n// is StartPort + offset.\nfunc (na NetworkAddress) JoinHostPort(offset uint) string {\n\tif na.IsUnixNetwork() || na.IsFdNetwork() {\n\t\treturn na.Host\n\t}\n\treturn net.JoinHostPort(na.Host, strconv.FormatUint(uint64(na.StartPort+offset), 10))\n}\n\n// Expand returns one NetworkAddress for each port in the port range.\nfunc (na NetworkAddress) Expand() []NetworkAddress {\n\tsize := na.PortRangeSize()\n\taddrs := make([]NetworkAddress, size)\n\tfor portOffset := uint(0); portOffset < size; portOffset++ {\n\t\taddrs[portOffset] = na.At(portOffset)\n\t}\n\treturn addrs\n}\n\n// At returns a NetworkAddress with a port range of just 1\n// at the given port offset; i.e. a NetworkAddress that\n// represents precisely 1 address only.\nfunc (na NetworkAddress) At(portOffset uint) NetworkAddress {\n\tna2 := na\n\tna2.StartPort, na2.EndPort = na.StartPort+portOffset, na.StartPort+portOffset\n\treturn na2\n}\n\n// PortRangeSize returns how many ports are in\n// pa's port range. Port ranges are inclusive,\n// so the size is the difference of start and\n// end ports plus one.\nfunc (na NetworkAddress) PortRangeSize() uint {\n\tif na.EndPort < na.StartPort {\n\t\treturn 0\n\t}\n\treturn (na.EndPort - na.StartPort) + 1\n}\n\nfunc (na NetworkAddress) isLoopback() bool {\n\tif na.IsUnixNetwork() || na.IsFdNetwork() {\n\t\treturn true\n\t}\n\tif na.Host == \"localhost\" {\n\t\treturn true\n\t}\n\tif ip, err := netip.ParseAddr(na.Host); err == nil {\n\t\treturn ip.IsLoopback()\n\t}\n\treturn false\n}\n\nfunc (na NetworkAddress) isWildcardInterface() bool {\n\tif na.Host == \"\" {\n\t\treturn true\n\t}\n\tif ip, err := netip.ParseAddr(na.Host); err == nil {\n\t\treturn ip.IsUnspecified()\n\t}\n\treturn false\n}\n\nfunc (na NetworkAddress) port() string {\n\tif na.StartPort == na.EndPort {\n\t\treturn strconv.FormatUint(uint64(na.StartPort), 10)\n\t}\n\treturn fmt.Sprintf(\"%d-%d\", na.StartPort, na.EndPort)\n}\n\n// String reconstructs the address string for human display.\n// The output can be parsed by ParseNetworkAddress(). If the\n// address is a unix socket, any non-zero port will be dropped.\nfunc (na NetworkAddress) String() string {\n\tif na.Network == \"tcp\" && (na.Host != \"\" || na.port() != \"\") {\n\t\tna.Network = \"\" // omit default network value for brevity\n\t}\n\treturn JoinNetworkAddress(na.Network, na.Host, na.port())\n}\n\n// IsUnixNetwork returns true if the netw is a unix network.\nfunc IsUnixNetwork(netw string) bool {\n\treturn strings.HasPrefix(netw, \"unix\")\n}\n\n// IsFdNetwork returns true if the netw is a fd network.\nfunc IsFdNetwork(netw string) bool {\n\treturn strings.HasPrefix(netw, \"fd\")\n}\n\n// ParseNetworkAddress parses addr into its individual\n// components. The input string is expected to be of\n// the form \"network/host:port-range\" where any part is\n// optional. The default network, if unspecified, is tcp.\n// Port ranges are inclusive.\n//\n// Network addresses are distinct from URLs and do not\n// use URL syntax.\nfunc ParseNetworkAddress(addr string) (NetworkAddress, error) {\n\treturn ParseNetworkAddressWithDefaults(addr, \"tcp\", 0)\n}\n\n// ParseNetworkAddressWithDefaults is like ParseNetworkAddress but allows\n// the default network and port to be specified.\nfunc ParseNetworkAddressWithDefaults(addr, defaultNetwork string, defaultPort uint) (NetworkAddress, error) {\n\tvar host, port string\n\tnetwork, host, port, err := SplitNetworkAddress(addr)\n\tif err != nil {\n\t\treturn NetworkAddress{}, err\n\t}\n\tif network == \"\" {\n\t\tnetwork = defaultNetwork\n\t}\n\tif IsUnixNetwork(network) {\n\t\t_, _, err := internal.SplitUnixSocketPermissionsBits(host)\n\t\treturn NetworkAddress{\n\t\t\tNetwork: network,\n\t\t\tHost:    host,\n\t\t}, err\n\t}\n\tif IsFdNetwork(network) {\n\t\treturn NetworkAddress{\n\t\t\tNetwork: network,\n\t\t\tHost:    host,\n\t\t}, nil\n\t}\n\tvar start, end uint64\n\tif port == \"\" {\n\t\tstart = uint64(defaultPort)\n\t\tend = uint64(defaultPort)\n\t} else {\n\t\tbefore, after, found := strings.Cut(port, \"-\")\n\t\tif !found {\n\t\t\tafter = before\n\t\t}\n\t\tstart, err = strconv.ParseUint(before, 10, 16)\n\t\tif err != nil {\n\t\t\treturn NetworkAddress{}, fmt.Errorf(\"invalid start port: %v\", err)\n\t\t}\n\t\tend, err = strconv.ParseUint(after, 10, 16)\n\t\tif err != nil {\n\t\t\treturn NetworkAddress{}, fmt.Errorf(\"invalid end port: %v\", err)\n\t\t}\n\t\tif end < start {\n\t\t\treturn NetworkAddress{}, fmt.Errorf(\"end port must not be less than start port\")\n\t\t}\n\t\tif (end - start) > maxPortSpan {\n\t\t\treturn NetworkAddress{}, fmt.Errorf(\"port range exceeds %d ports\", maxPortSpan)\n\t\t}\n\t}\n\treturn NetworkAddress{\n\t\tNetwork:   network,\n\t\tHost:      host,\n\t\tStartPort: uint(start),\n\t\tEndPort:   uint(end),\n\t}, nil\n}\n\n// SplitNetworkAddress splits a into its network, host, and port components.\n// Note that port may be a port range (:X-Y), or omitted for unix sockets.\nfunc SplitNetworkAddress(a string) (network, host, port string, err error) {\n\tbeforeSlash, afterSlash, slashFound := strings.Cut(a, \"/\")\n\tif slashFound {\n\t\tnetwork = strings.ToLower(strings.TrimSpace(beforeSlash))\n\t\ta = afterSlash\n\t\tif IsUnixNetwork(network) || IsFdNetwork(network) {\n\t\t\thost = a\n\t\t\treturn\n\t\t}\n\t}\n\n\thost, port, err = net.SplitHostPort(a)\n\tfirstErr := err\n\n\tif err != nil {\n\t\t// in general, if there was an error, it was likely \"missing port\",\n\t\t// so try removing square brackets around an IPv6 host, adding a bogus\n\t\t// port to take advantage of standard library's robust parser, then\n\t\t// strip the artificial port.\n\t\thost, _, err = net.SplitHostPort(net.JoinHostPort(strings.Trim(a, \"[]\"), \"0\"))\n\t\tport = \"\"\n\t}\n\n\tif err != nil {\n\t\terr = errors.Join(firstErr, err)\n\t}\n\n\treturn\n}\n\n// JoinNetworkAddress combines network, host, and port into a single\n// address string of the form accepted by ParseNetworkAddress(). For\n// unix sockets, the network should be \"unix\" (or \"unixgram\" or\n// \"unixpacket\") and the path to the socket should be given as the\n// host parameter.\nfunc JoinNetworkAddress(network, host, port string) string {\n\tvar a string\n\tif network != \"\" {\n\t\ta = network + \"/\"\n\t}\n\tif (host != \"\" && port == \"\") || IsUnixNetwork(network) || IsFdNetwork(network) {\n\t\ta += host\n\t} else if port != \"\" {\n\t\ta += net.JoinHostPort(host, port)\n\t}\n\treturn a\n}\n\n// ListenQUIC returns a http3.QUICEarlyListener suitable for use in a Caddy module.\n//\n// The network will be transformed into a QUIC-compatible type if the same address can be used with\n// different networks. Currently this just means that for tcp, udp will be used with the same\n// address instead.\n//\n// NOTE: This API is EXPERIMENTAL and may be changed or removed.\nfunc (na NetworkAddress) ListenQUIC(ctx context.Context, portOffset uint, config net.ListenConfig, tlsConf *tls.Config) (http3.QUICEarlyListener, error) {\n\tlnKey := listenerKey(\"quic\"+na.Network, na.JoinHostPort(portOffset))\n\n\tsharedEarlyListener, _, err := listenerPool.LoadOrNew(lnKey, func() (Destructor, error) {\n\t\tlnAny, err := na.Listen(ctx, portOffset, config)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tln := lnAny.(net.PacketConn)\n\n\t\th3ln := ln\n\t\tfor {\n\t\t\t// retrieve the underlying socket, so quic-go can optimize.\n\t\t\tif unwrapper, ok := h3ln.(interface{ Unwrap() net.PacketConn }); ok {\n\t\t\t\th3ln = unwrapper.Unwrap()\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tsqs := newSharedQUICState(tlsConf)\n\t\t// http3.ConfigureTLSConfig only uses this field and tls App sets this field as well\n\t\t//nolint:gosec\n\t\tquicTlsConfig := &tls.Config{GetConfigForClient: sqs.getConfigForClient}\n\t\t// Require clients to verify their source address when we're handling more than 1000 handshakes per second.\n\t\t// TODO: make tunable?\n\t\tlimiter := rate.NewLimiter(1000, 1000)\n\t\ttr := &quic.Transport{\n\t\t\tConn:                h3ln,\n\t\t\tVerifySourceAddress: func(addr net.Addr) bool { return !limiter.Allow() },\n\t\t}\n\t\tearlyLn, err := tr.ListenEarly(\n\t\t\thttp3.ConfigureTLSConfig(quicTlsConfig),\n\t\t\t&quic.Config{\n\t\t\t\tAllow0RTT: true,\n\t\t\t\tTracer:    qlog.DefaultConnectionTracer,\n\t\t\t},\n\t\t)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// TODO: figure out when to close the listener and the transport\n\t\t// using the original net.PacketConn to close them properly\n\t\treturn &sharedQuicListener{EarlyListener: earlyLn, packetConn: ln, sqs: sqs, key: lnKey}, nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsql := sharedEarlyListener.(*sharedQuicListener)\n\t// add current tls.Config to sqs, so GetConfigForClient will always return the latest tls.Config in case of context cancellation\n\tctx, cancel := sql.sqs.addState(tlsConf)\n\n\treturn &fakeCloseQuicListener{\n\t\tsharedQuicListener: sql,\n\t\tcontext:            ctx,\n\t\tcontextCancel:      cancel,\n\t}, nil\n}\n\n// ListenerUsage returns the current usage count of the given listener address.\nfunc ListenerUsage(network, addr string) int {\n\tcount, _ := listenerPool.References(listenerKey(network, addr))\n\treturn count\n}\n\n// contextAndCancelFunc groups context and its cancelFunc\ntype contextAndCancelFunc struct {\n\tcontext.Context\n\tcontext.CancelFunc\n}\n\n// sharedQUICState manages GetConfigForClient\n// see issue: https://github.com/caddyserver/caddy/pull/4849\ntype sharedQUICState struct {\n\trmu           sync.RWMutex\n\ttlsConfs      map[*tls.Config]contextAndCancelFunc\n\tactiveTlsConf *tls.Config\n}\n\n// newSharedQUICState creates a new sharedQUICState\nfunc newSharedQUICState(tlsConfig *tls.Config) *sharedQUICState {\n\tsqtc := &sharedQUICState{\n\t\ttlsConfs:      make(map[*tls.Config]contextAndCancelFunc),\n\t\tactiveTlsConf: tlsConfig,\n\t}\n\tsqtc.addState(tlsConfig)\n\treturn sqtc\n}\n\n// getConfigForClient is used as tls.Config's GetConfigForClient field\nfunc (sqs *sharedQUICState) getConfigForClient(ch *tls.ClientHelloInfo) (*tls.Config, error) {\n\tsqs.rmu.RLock()\n\tdefer sqs.rmu.RUnlock()\n\treturn sqs.activeTlsConf.GetConfigForClient(ch)\n}\n\n// addState adds tls.Config and activeRequests to the map if not present and returns the corresponding context and its cancelFunc\n// so that when cancelled, the active tls.Config will change\nfunc (sqs *sharedQUICState) addState(tlsConfig *tls.Config) (context.Context, context.CancelFunc) {\n\tsqs.rmu.Lock()\n\tdefer sqs.rmu.Unlock()\n\n\tif cacc, ok := sqs.tlsConfs[tlsConfig]; ok {\n\t\treturn cacc.Context, cacc.CancelFunc\n\t}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\twrappedCancel := func() {\n\t\tcancel()\n\n\t\tsqs.rmu.Lock()\n\t\tdefer sqs.rmu.Unlock()\n\n\t\tdelete(sqs.tlsConfs, tlsConfig)\n\t\tif sqs.activeTlsConf == tlsConfig {\n\t\t\t// select another tls.Config, if there is none,\n\t\t\t// related sharedQuicListener will be destroyed anyway\n\t\t\tfor tc := range sqs.tlsConfs {\n\t\t\t\tsqs.activeTlsConf = tc\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tsqs.tlsConfs[tlsConfig] = contextAndCancelFunc{ctx, wrappedCancel}\n\t// there should be at most 2 tls.Configs\n\tif len(sqs.tlsConfs) > 2 {\n\t\tLog().Warn(\"quic listener tls configs are more than 2\", zap.Int(\"number of configs\", len(sqs.tlsConfs)))\n\t}\n\treturn ctx, wrappedCancel\n}\n\n// sharedQuicListener is like sharedListener, but for quic.EarlyListeners.\ntype sharedQuicListener struct {\n\t*quic.EarlyListener\n\tpacketConn net.PacketConn // we have to hold these because quic-go won't close listeners it didn't create\n\tsqs        *sharedQUICState\n\tkey        string\n}\n\n// Destruct closes the underlying QUIC listener and its associated net.PacketConn.\nfunc (sql *sharedQuicListener) Destruct() error {\n\t// close EarlyListener first to stop any operations being done to the net.PacketConn\n\t_ = sql.EarlyListener.Close()\n\t// then close the net.PacketConn\n\treturn sql.packetConn.Close()\n}\n\n// fakeClosedErr returns an error value that is not temporary\n// nor a timeout, suitable for making the caller think the\n// listener is actually closed\nfunc fakeClosedErr(l interface{ Addr() net.Addr }) error {\n\treturn &net.OpError{\n\t\tOp:   \"accept\",\n\t\tNet:  l.Addr().Network(),\n\t\tAddr: l.Addr(),\n\t\tErr:  errFakeClosed,\n\t}\n}\n\n// errFakeClosed is the underlying error value returned by\n// fakeCloseListener.Accept() after Close() has been called,\n// indicating that it is pretending to be closed so that the\n// server using it can terminate, while the underlying\n// socket is actually left open.\nvar errFakeClosed = fmt.Errorf(\"listener 'closed' ðŸ˜‰\")\n\ntype fakeCloseQuicListener struct {\n\tclosed              int32 // accessed atomically; belongs to this struct only\n\t*sharedQuicListener       // embedded, so we also become a quic.EarlyListener\n\tcontext             context.Context\n\tcontextCancel       context.CancelFunc\n}\n\n// Currently Accept ignores the passed context, however a situation where\n// someone would need a hotswappable QUIC-only (not http3, since it uses context.Background here)\n// server on which Accept would be called with non-empty contexts\n// (mind that the default net listeners' Accept doesn't take a context argument)\n// sounds way too rare for us to sacrifice efficiency here.\nfunc (fcql *fakeCloseQuicListener) Accept(_ context.Context) (quic.EarlyConnection, error) {\n\tconn, err := fcql.sharedQuicListener.Accept(fcql.context)\n\tif err == nil {\n\t\treturn conn, nil\n\t}\n\n\t// if the listener is \"closed\", return a fake closed error instead\n\tif atomic.LoadInt32(&fcql.closed) == 1 && errors.Is(err, context.Canceled) {\n\t\treturn nil, fakeClosedErr(fcql)\n\t}\n\treturn nil, err\n}\n\nfunc (fcql *fakeCloseQuicListener) Close() error {\n\tif atomic.CompareAndSwapInt32(&fcql.closed, 0, 1) {\n\t\tfcql.contextCancel()\n\t\t_, _ = listenerPool.Delete(fcql.sharedQuicListener.key)\n\t}\n\treturn nil\n}\n\n// RegisterNetwork registers a network type with Caddy so that if a listener is\n// created for that network type, getListener will be invoked to get the listener.\n// This should be called during init() and will panic if the network type is standard\n// or reserved, or if it is already registered. EXPERIMENTAL and subject to change.\nfunc RegisterNetwork(network string, getListener ListenerFunc) {\n\tnetwork = strings.TrimSpace(strings.ToLower(network))\n\n\tif network == \"tcp\" || network == \"tcp4\" || network == \"tcp6\" ||\n\t\tnetwork == \"udp\" || network == \"udp4\" || network == \"udp6\" ||\n\t\tnetwork == \"unix\" || network == \"unixpacket\" || network == \"unixgram\" ||\n\t\tstrings.HasPrefix(\"ip:\", network) || strings.HasPrefix(\"ip4:\", network) || strings.HasPrefix(\"ip6:\", network) ||\n\t\tnetwork == \"fd\" || network == \"fdgram\" {\n\t\tpanic(\"network type \" + network + \" is reserved\")\n\t}\n\n\tif _, ok := networkTypes[strings.ToLower(network)]; ok {\n\t\tpanic(\"network type \" + network + \" is already registered\")\n\t}\n\n\tnetworkTypes[network] = getListener\n}\n\nvar unixSocketsMu sync.Mutex\n\n// getListenerFromPlugin returns a listener on the given network and address\n// if a plugin has registered the network name. It may return (nil, nil) if\n// no plugin can provide a listener.\nfunc getListenerFromPlugin(ctx context.Context, network, host, port string, portOffset uint, config net.ListenConfig) (any, error) {\n\t// get listener from plugin if network type is registered\n\tif getListener, ok := networkTypes[network]; ok {\n\t\tLog().Debug(\"getting listener from plugin\", zap.String(\"network\", network))\n\t\treturn getListener(ctx, network, host, port, portOffset, config)\n\t}\n\n\treturn nil, nil\n}\n\nfunc listenerKey(network, addr string) string {\n\treturn network + \"/\" + addr\n}\n\n// ListenerFunc is a function that can return a listener given a network and address.\n// The listeners must be capable of overlapping: with Caddy, new configs are loaded\n// before old ones are unloaded, so listeners may overlap briefly if the configs\n// both need the same listener. EXPERIMENTAL and subject to change.\ntype ListenerFunc func(ctx context.Context, network, host, portRange string, portOffset uint, cfg net.ListenConfig) (any, error)\n\nvar networkTypes = map[string]ListenerFunc{}\n\n// ListenerWrapper is a type that wraps a listener\n// so it can modify the input listener's methods.\n// Modules that implement this interface are found\n// in the caddy.listeners namespace. Usually, to\n// wrap a listener, you will define your own struct\n// type that embeds the input listener, then\n// implement your own methods that you want to wrap,\n// calling the underlying listener's methods where\n// appropriate.\ntype ListenerWrapper interface {\n\tWrapListener(net.Listener) net.Listener\n}\n\n// listenerPool stores and allows reuse of active listeners.\nvar listenerPool = NewUsagePool()\n\nconst maxPortSpan = 65535\n"
        },
        {
          "name": "listeners_fuzz.go",
          "type": "blob",
          "size": 0.763671875,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build gofuzz\n\npackage caddy\n\nfunc FuzzParseNetworkAddress(data []byte) int {\n\t_, err := ParseNetworkAddress(string(data))\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn 1\n}\n"
        },
        {
          "name": "listeners_test.go",
          "type": "blob",
          "size": 14.03515625,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/caddyserver/caddy/v2/internal\"\n)\n\nfunc TestSplitNetworkAddress(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tinput         string\n\t\texpectNetwork string\n\t\texpectHost    string\n\t\texpectPort    string\n\t\texpectErr     bool\n\t}{\n\t\t{\n\t\t\tinput:     \"\",\n\t\t\texpectHost: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"foo\",\n\t\t\texpectHost: \"foo\",\n\t\t},\n\t\t{\n\t\t\tinput: \":\", // empty host & empty port\n\t\t},\n\t\t{\n\t\t\tinput:     \"::\",\n\t\t\texpectHost: \"::\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"[::]\",\n\t\t\texpectHost: \"::\",\n\t\t},\n\t\t{\n\t\t\tinput:      \":1234\",\n\t\t\texpectPort: \"1234\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"foo:1234\",\n\t\t\texpectHost: \"foo\",\n\t\t\texpectPort: \"1234\",\n\t\t},\n\t\t{\n\t\t\tinput:      \"foo:1234-5678\",\n\t\t\texpectHost: \"foo\",\n\t\t\texpectPort: \"1234-5678\",\n\t\t},\n\t\t{\n\t\t\tinput:         \"udp/foo:1234\",\n\t\t\texpectNetwork: \"udp\",\n\t\t\texpectHost:    \"foo\",\n\t\t\texpectPort:    \"1234\",\n\t\t},\n\t\t{\n\t\t\tinput:         \"tcp6/foo:1234-5678\",\n\t\t\texpectNetwork: \"tcp6\",\n\t\t\texpectHost:    \"foo\",\n\t\t\texpectPort:    \"1234-5678\",\n\t\t},\n\t\t{\n\t\t\tinput:         \"udp/\",\n\t\t\texpectNetwork: \"udp\",\n\t\t\texpectHost:    \"\",\n\t\t},\n\t\t{\n\t\t\tinput:         \"unix//foo/bar\",\n\t\t\texpectNetwork: \"unix\",\n\t\t\texpectHost:    \"/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tinput:         \"unixgram//foo/bar\",\n\t\t\texpectNetwork: \"unixgram\",\n\t\t\texpectHost:    \"/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tinput:         \"unixpacket//foo/bar\",\n\t\t\texpectNetwork: \"unixpacket\",\n\t\t\texpectHost:    \"/foo/bar\",\n\t\t},\n\t} {\n\t\tactualNetwork, actualHost, actualPort, err := SplitNetworkAddress(tc.input)\n\t\tif tc.expectErr && err == nil {\n\t\t\tt.Errorf(\"Test %d: Expected error but got %v\", i, err)\n\t\t}\n\t\tif !tc.expectErr && err != nil {\n\t\t\tt.Errorf(\"Test %d: Expected no error but got %v\", i, err)\n\t\t}\n\t\tif actualNetwork != tc.expectNetwork {\n\t\t\tt.Errorf(\"Test %d: Expected network '%s' but got '%s'\", i, tc.expectNetwork, actualNetwork)\n\t\t}\n\t\tif actualHost != tc.expectHost {\n\t\t\tt.Errorf(\"Test %d: Expected host '%s' but got '%s'\", i, tc.expectHost, actualHost)\n\t\t}\n\t\tif actualPort != tc.expectPort {\n\t\t\tt.Errorf(\"Test %d: Expected port '%s' but got '%s'\", i, tc.expectPort, actualPort)\n\t\t}\n\t}\n}\n\nfunc TestJoinNetworkAddress(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tnetwork, host, port string\n\t\texpect              string\n\t}{\n\t\t{\n\t\t\tnetwork: \"\", host: \"\", port: \"\",\n\t\t\texpect: \"\",\n\t\t},\n\t\t{\n\t\t\tnetwork: \"tcp\", host: \"\", port: \"\",\n\t\t\texpect: \"tcp/\",\n\t\t},\n\t\t{\n\t\t\tnetwork: \"\", host: \"foo\", port: \"\",\n\t\t\texpect: \"foo\",\n\t\t},\n\t\t{\n\t\t\tnetwork: \"\", host: \"\", port: \"1234\",\n\t\t\texpect: \":1234\",\n\t\t},\n\t\t{\n\t\t\tnetwork: \"\", host: \"\", port: \"1234-5678\",\n\t\t\texpect: \":1234-5678\",\n\t\t},\n\t\t{\n\t\t\tnetwork: \"\", host: \"foo\", port: \"1234\",\n\t\t\texpect: \"foo:1234\",\n\t\t},\n\t\t{\n\t\t\tnetwork: \"udp\", host: \"foo\", port: \"1234\",\n\t\t\texpect: \"udp/foo:1234\",\n\t\t},\n\t\t{\n\t\t\tnetwork: \"udp\", host: \"\", port: \"1234\",\n\t\t\texpect: \"udp/:1234\",\n\t\t},\n\t\t{\n\t\t\tnetwork: \"unix\", host: \"/foo/bar\", port: \"\",\n\t\t\texpect: \"unix//foo/bar\",\n\t\t},\n\t\t{\n\t\t\tnetwork: \"unix\", host: \"/foo/bar\", port: \"0\",\n\t\t\texpect: \"unix//foo/bar\",\n\t\t},\n\t\t{\n\t\t\tnetwork: \"unix\", host: \"/foo/bar\", port: \"1234\",\n\t\t\texpect: \"unix//foo/bar\",\n\t\t},\n\t\t{\n\t\t\tnetwork: \"\", host: \"::1\", port: \"1234\",\n\t\t\texpect: \"[::1]:1234\",\n\t\t},\n\t} {\n\t\tactual := JoinNetworkAddress(tc.network, tc.host, tc.port)\n\t\tif actual != tc.expect {\n\t\t\tt.Errorf(\"Test %d: Expected '%s' but got '%s'\", i, tc.expect, actual)\n\t\t}\n\t}\n}\n\nfunc TestParseNetworkAddress(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tinput          string\n\t\tdefaultNetwork string\n\t\tdefaultPort    uint\n\t\texpectAddr     NetworkAddress\n\t\texpectErr      bool\n\t}{\n\t\t{\n\t\t\tinput:     \"\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \":\",\n\t\t\tdefaultNetwork: \"udp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork: \"udp\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"[::]\",\n\t\t\tdefaultNetwork: \"udp\",\n\t\t\tdefaultPort:    53,\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork:   \"udp\",\n\t\t\t\tHost:      \"::\",\n\t\t\t\tStartPort: 53,\n\t\t\t\tEndPort:   53,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \":1234\",\n\t\t\tdefaultNetwork: \"udp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork:   \"udp\",\n\t\t\t\tHost:      \"\",\n\t\t\t\tStartPort: 1234,\n\t\t\t\tEndPort:   1234,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"udp/:1234\",\n\t\t\tdefaultNetwork: \"udp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork:   \"udp\",\n\t\t\t\tHost:      \"\",\n\t\t\t\tStartPort: 1234,\n\t\t\t\tEndPort:   1234,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"tcp6/:1234\",\n\t\t\tdefaultNetwork: \"tcp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork:   \"tcp6\",\n\t\t\t\tHost:      \"\",\n\t\t\t\tStartPort: 1234,\n\t\t\t\tEndPort:   1234,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"tcp4/localhost:1234\",\n\t\t\tdefaultNetwork: \"tcp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork:   \"tcp4\",\n\t\t\t\tHost:      \"localhost\",\n\t\t\t\tStartPort: 1234,\n\t\t\t\tEndPort:   1234,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"unix//foo/bar\",\n\t\t\tdefaultNetwork: \"tcp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork: \"unix\",\n\t\t\t\tHost:    \"/foo/bar\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"localhost:1234-1234\",\n\t\t\tdefaultNetwork: \"tcp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork:   \"tcp\",\n\t\t\t\tHost:      \"localhost\",\n\t\t\t\tStartPort: 1234,\n\t\t\t\tEndPort:   1234,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"localhost:2-1\",\n\t\t\tdefaultNetwork: \"tcp\",\n\t\t\texpectErr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:          \"localhost:0\",\n\t\t\tdefaultNetwork: \"tcp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork:   \"tcp\",\n\t\t\t\tHost:      \"localhost\",\n\t\t\t\tStartPort: 0,\n\t\t\t\tEndPort:   0,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"localhost:1-999999999999\",\n\t\t\tdefaultNetwork: \"tcp\",\n\t\t\texpectErr:      true,\n\t\t},\n\t} {\n\t\tactualAddr, err := ParseNetworkAddressWithDefaults(tc.input, tc.defaultNetwork, tc.defaultPort)\n\t\tif tc.expectErr && err == nil {\n\t\t\tt.Errorf(\"Test %d: Expected error but got: %v\", i, err)\n\t\t}\n\t\tif !tc.expectErr && err != nil {\n\t\t\tt.Errorf(\"Test %d: Expected no error but got: %v\", i, err)\n\t\t}\n\n\t\tif actualAddr.Network != tc.expectAddr.Network {\n\t\t\tt.Errorf(\"Test %d: Expected network '%v' but got '%v'\", i, tc.expectAddr, actualAddr)\n\t\t}\n\t\tif !reflect.DeepEqual(tc.expectAddr, actualAddr) {\n\t\t\tt.Errorf(\"Test %d: Expected addresses %v but got %v\", i, tc.expectAddr, actualAddr)\n\t\t}\n\t}\n}\n\nfunc TestParseNetworkAddressWithDefaults(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tinput          string\n\t\tdefaultNetwork string\n\t\tdefaultPort    uint\n\t\texpectAddr     NetworkAddress\n\t\texpectErr      bool\n\t}{\n\t\t{\n\t\t\tinput:     \"\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \":\",\n\t\t\tdefaultNetwork: \"udp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork: \"udp\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"[::]\",\n\t\t\tdefaultNetwork: \"udp\",\n\t\t\tdefaultPort:    53,\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork:   \"udp\",\n\t\t\t\tHost:      \"::\",\n\t\t\t\tStartPort: 53,\n\t\t\t\tEndPort:   53,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \":1234\",\n\t\t\tdefaultNetwork: \"udp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork:   \"udp\",\n\t\t\t\tHost:      \"\",\n\t\t\t\tStartPort: 1234,\n\t\t\t\tEndPort:   1234,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"udp/:1234\",\n\t\t\tdefaultNetwork: \"udp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork:   \"udp\",\n\t\t\t\tHost:      \"\",\n\t\t\t\tStartPort: 1234,\n\t\t\t\tEndPort:   1234,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"tcp6/:1234\",\n\t\t\tdefaultNetwork: \"tcp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork:   \"tcp6\",\n\t\t\t\tHost:      \"\",\n\t\t\t\tStartPort: 1234,\n\t\t\t\tEndPort:   1234,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"tcp4/localhost:1234\",\n\t\t\tdefaultNetwork: \"tcp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork:   \"tcp4\",\n\t\t\t\tHost:      \"localhost\",\n\t\t\t\tStartPort: 1234,\n\t\t\t\tEndPort:   1234,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"unix//foo/bar\",\n\t\t\tdefaultNetwork: \"tcp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork: \"unix\",\n\t\t\t\tHost:    \"/foo/bar\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"localhost:1234-1234\",\n\t\t\tdefaultNetwork: \"tcp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork:   \"tcp\",\n\t\t\t\tHost:      \"localhost\",\n\t\t\t\tStartPort: 1234,\n\t\t\t\tEndPort:   1234,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"localhost:2-1\",\n\t\t\tdefaultNetwork: \"tcp\",\n\t\t\texpectErr:      true,\n\t\t},\n\t\t{\n\t\t\tinput:          \"localhost:0\",\n\t\t\tdefaultNetwork: \"tcp\",\n\t\t\texpectAddr: NetworkAddress{\n\t\t\t\tNetwork:   \"tcp\",\n\t\t\t\tHost:      \"localhost\",\n\t\t\t\tStartPort: 0,\n\t\t\t\tEndPort:   0,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput:          \"localhost:1-999999999999\",\n\t\t\tdefaultNetwork: \"tcp\",\n\t\t\texpectErr:      true,\n\t\t},\n\t} {\n\t\tactualAddr, err := ParseNetworkAddressWithDefaults(tc.input, tc.defaultNetwork, tc.defaultPort)\n\t\tif tc.expectErr && err == nil {\n\t\t\tt.Errorf(\"Test %d: Expected error but got: %v\", i, err)\n\t\t}\n\t\tif !tc.expectErr && err != nil {\n\t\t\tt.Errorf(\"Test %d: Expected no error but got: %v\", i, err)\n\t\t}\n\n\t\tif actualAddr.Network != tc.expectAddr.Network {\n\t\t\tt.Errorf(\"Test %d: Expected network '%v' but got '%v'\", i, tc.expectAddr, actualAddr)\n\t\t}\n\t\tif !reflect.DeepEqual(tc.expectAddr, actualAddr) {\n\t\t\tt.Errorf(\"Test %d: Expected addresses %v but got %v\", i, tc.expectAddr, actualAddr)\n\t\t}\n\t}\n}\n\nfunc TestJoinHostPort(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tpa     NetworkAddress\n\t\toffset uint\n\t\texpect string\n\t}{\n\t\t{\n\t\t\tpa: NetworkAddress{\n\t\t\t\tNetwork:   \"tcp\",\n\t\t\t\tHost:      \"localhost\",\n\t\t\t\tStartPort: 1234,\n\t\t\t\tEndPort:   1234,\n\t\t\t},\n\t\t\texpect: \"localhost:1234\",\n\t\t},\n\t\t{\n\t\t\tpa: NetworkAddress{\n\t\t\t\tNetwork:   \"tcp\",\n\t\t\t\tHost:      \"localhost\",\n\t\t\t\tStartPort: 1234,\n\t\t\t\tEndPort:   1235,\n\t\t\t},\n\t\t\texpect: \"localhost:1234\",\n\t\t},\n\t\t{\n\t\t\tpa: NetworkAddress{\n\t\t\t\tNetwork:   \"tcp\",\n\t\t\t\tHost:      \"localhost\",\n\t\t\t\tStartPort: 1234,\n\t\t\t\tEndPort:   1235,\n\t\t\t},\n\t\t\toffset: 1,\n\t\t\texpect: \"localhost:1235\",\n\t\t},\n\t\t{\n\t\t\tpa: NetworkAddress{\n\t\t\t\tNetwork: \"unix\",\n\t\t\t\tHost:    \"/run/php/php7.3-fpm.sock\",\n\t\t\t},\n\t\t\texpect: \"/run/php/php7.3-fpm.sock\",\n\t\t},\n\t} {\n\t\tactual := tc.pa.JoinHostPort(tc.offset)\n\t\tif actual != tc.expect {\n\t\t\tt.Errorf(\"Test %d: Expected '%s' but got '%s'\", i, tc.expect, actual)\n\t\t}\n\t}\n}\n\nfunc TestExpand(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tinput  NetworkAddress\n\t\texpect []NetworkAddress\n\t}{\n\t\t{\n\t\t\tinput: NetworkAddress{\n\t\t\t\tNetwork:   \"tcp\",\n\t\t\t\tHost:      \"localhost\",\n\t\t\t\tStartPort: 2000,\n\t\t\t\tEndPort:   2000,\n\t\t\t},\n\t\t\texpect: []NetworkAddress{\n\t\t\t\t{\n\t\t\t\t\tNetwork:   \"tcp\",\n\t\t\t\t\tHost:      \"localhost\",\n\t\t\t\t\tStartPort: 2000,\n\t\t\t\t\tEndPort:   2000,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: NetworkAddress{\n\t\t\t\tNetwork:   \"tcp\",\n\t\t\t\tHost:      \"localhost\",\n\t\t\t\tStartPort: 2000,\n\t\t\t\tEndPort:   2002,\n\t\t\t},\n\t\t\texpect: []NetworkAddress{\n\t\t\t\t{\n\t\t\t\t\tNetwork:   \"tcp\",\n\t\t\t\t\tHost:      \"localhost\",\n\t\t\t\t\tStartPort: 2000,\n\t\t\t\t\tEndPort:   2000,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tNetwork:   \"tcp\",\n\t\t\t\t\tHost:      \"localhost\",\n\t\t\t\t\tStartPort: 2001,\n\t\t\t\t\tEndPort:   2001,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tNetwork:   \"tcp\",\n\t\t\t\t\tHost:      \"localhost\",\n\t\t\t\t\tStartPort: 2002,\n\t\t\t\t\tEndPort:   2002,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: NetworkAddress{\n\t\t\t\tNetwork:   \"tcp\",\n\t\t\t\tHost:      \"localhost\",\n\t\t\t\tStartPort: 2000,\n\t\t\t\tEndPort:   1999,\n\t\t\t},\n\t\t\texpect: []NetworkAddress{},\n\t\t},\n\t\t{\n\t\t\tinput: NetworkAddress{\n\t\t\t\tNetwork:   \"unix\",\n\t\t\t\tHost:      \"/foo/bar\",\n\t\t\t\tStartPort: 0,\n\t\t\t\tEndPort:   0,\n\t\t\t},\n\t\t\texpect: []NetworkAddress{\n\t\t\t\t{\n\t\t\t\t\tNetwork:   \"unix\",\n\t\t\t\t\tHost:      \"/foo/bar\",\n\t\t\t\t\tStartPort: 0,\n\t\t\t\t\tEndPort:   0,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t} {\n\t\tactual := tc.input.Expand()\n\t\tif !reflect.DeepEqual(actual, tc.expect) {\n\t\t\tt.Errorf(\"Test %d: Expected %+v but got %+v\", i, tc.expect, actual)\n\t\t}\n\t}\n}\n\nfunc TestSplitUnixSocketPermissionsBits(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tinput          string\n\t\texpectNetwork  string\n\t\texpectPath     string\n\t\texpectFileMode string\n\t\texpectErr      bool\n\t}{\n\t\t{\n\t\t\tinput:          \"./foo.socket\",\n\t\t\texpectPath:     \"./foo.socket\",\n\t\t\texpectFileMode: \"--w-------\",\n\t\t},\n\t\t{\n\t\t\tinput:          `.\\relative\\path.socket`,\n\t\t\texpectPath:     `.\\relative\\path.socket`,\n\t\t\texpectFileMode: \"--w-------\",\n\t\t},\n\t\t{\n\t\t\t// literal colon in resulting address\n\t\t\t// and defaulting to 0200 bits\n\t\t\tinput:          \"./foo.socket:0666\",\n\t\t\texpectPath:     \"./foo.socket:0666\",\n\t\t\texpectFileMode: \"--w-------\",\n\t\t},\n\t\t{\n\t\t\tinput:          \"./foo.socket|0220\",\n\t\t\texpectPath:     \"./foo.socket\",\n\t\t\texpectFileMode: \"--w--w----\",\n\t\t},\n\t\t{\n\t\t\tinput:          \"/var/run/foo|222\",\n\t\t\texpectPath:     \"/var/run/foo\",\n\t\t\texpectFileMode: \"--w--w--w-\",\n\t\t},\n\t\t{\n\t\t\tinput:          \"./foo.socket|0660\",\n\t\t\texpectPath:     \"./foo.socket\",\n\t\t\texpectFileMode: \"-rw-rw----\",\n\t\t},\n\t\t{\n\t\t\tinput:          \"./foo.socket|0666\",\n\t\t\texpectPath:     \"./foo.socket\",\n\t\t\texpectFileMode: \"-rw-rw-rw-\",\n\t\t},\n\t\t{\n\t\t\tinput:          \"/var/run/foo|666\",\n\t\t\texpectPath:     \"/var/run/foo\",\n\t\t\texpectFileMode: \"-rw-rw-rw-\",\n\t\t},\n\t\t{\n\t\t\tinput:          `c:\\absolute\\path.socket|220`,\n\t\t\texpectPath:     `c:\\absolute\\path.socket`,\n\t\t\texpectFileMode: \"--w--w----\",\n\t\t},\n\t\t{\n\t\t\t// symbolic permission representation is not supported for now\n\t\t\tinput:     \"./foo.socket|u=rw,g=rw,o=rw\",\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\t// octal (base-8) permission representation has to be between\n\t\t\t// `0` for no read, no write, no exec (`---`) and\n\t\t\t// `7` for read (4), write (2), exec (1) (`rwx` => `4+2+1 = 7`)\n\t\t\tinput:     \"./foo.socket|888\",\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\t// too many colons in address\n\t\t\tinput:     \"./foo.socket|123456|0660\",\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\t// owner is missing write perms\n\t\t\tinput:     \"./foo.socket|0522\",\n\t\t\texpectErr: true,\n\t\t},\n\t} {\n\t\tactualPath, actualFileMode, err := internal.SplitUnixSocketPermissionsBits(tc.input)\n\t\tif tc.expectErr && err == nil {\n\t\t\tt.Errorf(\"Test %d: Expected error but got: %v\", i, err)\n\t\t}\n\t\tif !tc.expectErr && err != nil {\n\t\t\tt.Errorf(\"Test %d: Expected no error but got: %v\", i, err)\n\t\t}\n\t\tif actualPath != tc.expectPath {\n\t\t\tt.Errorf(\"Test %d: Expected path '%s' but got '%s'\", i, tc.expectPath, actualPath)\n\t\t}\n\t\t// fileMode.Perm().String() parses 0 to \"----------\"\n\t\tif !tc.expectErr && actualFileMode.Perm().String() != tc.expectFileMode {\n\t\t\tt.Errorf(\"Test %d: Expected perms '%s' but got '%s'\", i, tc.expectFileMode, actualFileMode.Perm().String())\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "logging.go",
          "type": "blob",
          "size": 23.8994140625,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/zapcore\"\n\t\"golang.org/x/term\"\n)\n\nfunc init() {\n\tRegisterModule(StdoutWriter{})\n\tRegisterModule(StderrWriter{})\n\tRegisterModule(DiscardWriter{})\n}\n\n// Logging facilitates logging within Caddy. The default log is\n// called \"default\" and you can customize it. You can also define\n// additional logs.\n//\n// By default, all logs at INFO level and higher are written to\n// standard error (\"stderr\" writer) in a human-readable format\n// (\"console\" encoder if stdout is an interactive terminal, \"json\"\n// encoder otherwise).\n//\n// All defined logs accept all log entries by default, but you\n// can filter by level and module/logger names. A logger's name\n// is the same as the module's name, but a module may append to\n// logger names for more specificity. For example, you can\n// filter logs emitted only by HTTP handlers using the name\n// \"http.handlers\", because all HTTP handler module names have\n// that prefix.\n//\n// Caddy logs (except the sink) are zero-allocation, so they are\n// very high-performing in terms of memory and CPU time. Enabling\n// sampling can further increase throughput on extremely high-load\n// servers.\ntype Logging struct {\n\t// Sink is the destination for all unstructured logs emitted\n\t// from Go's standard library logger. These logs are common\n\t// in dependencies that are not designed specifically for use\n\t// in Caddy. Because it is global and unstructured, the sink\n\t// lacks most advanced features and customizations.\n\tSink *SinkLog `json:\"sink,omitempty\"`\n\n\t// Logs are your logs, keyed by an arbitrary name of your\n\t// choosing. The default log can be customized by defining\n\t// a log called \"default\". You can further define other logs\n\t// and filter what kinds of entries they accept.\n\tLogs map[string]*CustomLog `json:\"logs,omitempty\"`\n\n\t// a list of all keys for open writers; all writers\n\t// that are opened to provision this logging config\n\t// must have their keys added to this list so they\n\t// can be closed when cleaning up\n\twriterKeys []string\n}\n\n// openLogs sets up the config and opens all the configured writers.\n// It closes its logs when ctx is canceled, so it should clean up\n// after itself.\nfunc (logging *Logging) openLogs(ctx Context) error {\n\t// make sure to deallocate resources when context is done\n\tctx.OnCancel(func() {\n\t\terr := logging.closeLogs()\n\t\tif err != nil {\n\t\t\tLog().Error(\"closing logs\", zap.Error(err))\n\t\t}\n\t})\n\n\t// set up the \"sink\" log first (std lib's default global logger)\n\tif logging.Sink != nil {\n\t\terr := logging.Sink.provision(ctx, logging)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"setting up sink log: %v\", err)\n\t\t}\n\t}\n\n\t// as a special case, set up the default structured Caddy log next\n\tif err := logging.setupNewDefault(ctx); err != nil {\n\t\treturn err\n\t}\n\n\t// then set up any other custom logs\n\tfor name, l := range logging.Logs {\n\t\t// the default log is already set up\n\t\tif name == DefaultLoggerName {\n\t\t\tcontinue\n\t\t}\n\n\t\terr := l.provision(ctx, logging)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"setting up custom log '%s': %v\", name, err)\n\t\t}\n\n\t\t// Any other logs that use the discard writer can be deleted\n\t\t// entirely. This avoids encoding and processing of each\n\t\t// log entry that would just be thrown away anyway. Notably,\n\t\t// we do not reach this point for the default log, which MUST\n\t\t// exist, otherwise core log emissions would panic because\n\t\t// they use the Log() function directly which expects a non-nil\n\t\t// logger. Even if we keep logs with a discard writer, they\n\t\t// have a nop core, and keeping them at all seems unnecessary.\n\t\tif _, ok := l.writerOpener.(*DiscardWriter); ok {\n\t\t\tdelete(logging.Logs, name)\n\t\t\tcontinue\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (logging *Logging) setupNewDefault(ctx Context) error {\n\tif logging.Logs == nil {\n\t\tlogging.Logs = make(map[string]*CustomLog)\n\t}\n\n\t// extract the user-defined default log, if any\n\tnewDefault := new(defaultCustomLog)\n\tif userDefault, ok := logging.Logs[DefaultLoggerName]; ok {\n\t\tnewDefault.CustomLog = userDefault\n\t} else {\n\t\t// if none, make one with our own default settings\n\t\tvar err error\n\t\tnewDefault, err = newDefaultProductionLog()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"setting up default Caddy log: %v\", err)\n\t\t}\n\t\tlogging.Logs[DefaultLoggerName] = newDefault.CustomLog\n\t}\n\n\t// options for the default logger\n\toptions, err := newDefault.CustomLog.buildOptions()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"setting up default log: %v\", err)\n\t}\n\n\t// set up this new log\n\terr = newDefault.CustomLog.provision(ctx, logging)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"setting up default log: %v\", err)\n\t}\n\tnewDefault.logger = zap.New(newDefault.CustomLog.core, options...)\n\n\t// redirect the default caddy logs\n\tdefaultLoggerMu.Lock()\n\toldDefault := defaultLogger\n\tdefaultLogger = newDefault\n\tdefaultLoggerMu.Unlock()\n\n\t// if the new writer is different, indicate it in the logs for convenience\n\tvar newDefaultLogWriterKey, currentDefaultLogWriterKey string\n\tvar newDefaultLogWriterStr, currentDefaultLogWriterStr string\n\tif newDefault.writerOpener != nil {\n\t\tnewDefaultLogWriterKey = newDefault.writerOpener.WriterKey()\n\t\tnewDefaultLogWriterStr = newDefault.writerOpener.String()\n\t}\n\tif oldDefault.writerOpener != nil {\n\t\tcurrentDefaultLogWriterKey = oldDefault.writerOpener.WriterKey()\n\t\tcurrentDefaultLogWriterStr = oldDefault.writerOpener.String()\n\t}\n\tif newDefaultLogWriterKey != currentDefaultLogWriterKey {\n\t\toldDefault.logger.Info(\"redirected default logger\",\n\t\t\tzap.String(\"from\", currentDefaultLogWriterStr),\n\t\t\tzap.String(\"to\", newDefaultLogWriterStr),\n\t\t)\n\t}\n\n\treturn nil\n}\n\n// closeLogs cleans up resources allocated during openLogs.\n// A successful call to openLogs calls this automatically\n// when the context is canceled.\nfunc (logging *Logging) closeLogs() error {\n\tfor _, key := range logging.writerKeys {\n\t\t_, err := writers.Delete(key)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"[ERROR] Closing log writer %v: %v\", key, err)\n\t\t}\n\t}\n\treturn nil\n}\n\n// Logger returns a logger that is ready for the module to use.\nfunc (logging *Logging) Logger(mod Module) *zap.Logger {\n\tmodID := string(mod.CaddyModule().ID)\n\tvar cores []zapcore.Core\n\tvar options []zap.Option\n\n\tif logging != nil {\n\t\tfor _, l := range logging.Logs {\n\t\t\tif l.matchesModule(modID) {\n\t\t\t\tif len(l.Include) == 0 && len(l.Exclude) == 0 {\n\t\t\t\t\tcores = append(cores, l.core)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif len(options) == 0 {\n\t\t\t\t\tnewOptions, err := l.buildOptions()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tLog().Error(\"building options for logger\", zap.String(\"module\", modID), zap.Error(err))\n\t\t\t\t\t}\n\t\t\t\t\toptions = newOptions\n\t\t\t\t}\n\t\t\t\tcores = append(cores, &filteringCore{Core: l.core, cl: l})\n\t\t\t}\n\t\t}\n\t}\n\n\tmultiCore := zapcore.NewTee(cores...)\n\n\treturn zap.New(multiCore, options...).Named(modID)\n}\n\n// openWriter opens a writer using opener, and returns true if\n// the writer is new, or false if the writer already exists.\nfunc (logging *Logging) openWriter(opener WriterOpener) (io.WriteCloser, bool, error) {\n\tkey := opener.WriterKey()\n\twriter, loaded, err := writers.LoadOrNew(key, func() (Destructor, error) {\n\t\tw, err := opener.OpenWriter()\n\t\treturn writerDestructor{w}, err\n\t})\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\tlogging.writerKeys = append(logging.writerKeys, key)\n\treturn writer.(io.WriteCloser), !loaded, nil\n}\n\n// WriterOpener is a module that can open a log writer.\n// It can return a human-readable string representation\n// of itself so that operators can understand where\n// the logs are going.\ntype WriterOpener interface {\n\tfmt.Stringer\n\n\t// WriterKey is a string that uniquely identifies this\n\t// writer configuration. It is not shown to humans.\n\tWriterKey() string\n\n\t// OpenWriter opens a log for writing. The writer\n\t// should be safe for concurrent use but need not\n\t// be synchronous.\n\tOpenWriter() (io.WriteCloser, error)\n}\n\n// IsWriterStandardStream returns true if the input is a\n// writer-opener to a standard stream (stdout, stderr).\nfunc IsWriterStandardStream(wo WriterOpener) bool {\n\tswitch wo.(type) {\n\tcase StdoutWriter, StderrWriter,\n\t\t*StdoutWriter, *StderrWriter:\n\t\treturn true\n\t}\n\treturn false\n}\n\ntype writerDestructor struct {\n\tio.WriteCloser\n}\n\nfunc (wdest writerDestructor) Destruct() error {\n\treturn wdest.Close()\n}\n\n// BaseLog contains the common logging parameters for logging.\ntype BaseLog struct {\n\t// The module that writes out log entries for the sink.\n\tWriterRaw json.RawMessage `json:\"writer,omitempty\" caddy:\"namespace=caddy.logging.writers inline_key=output\"`\n\n\t// The encoder is how the log entries are formatted or encoded.\n\tEncoderRaw json.RawMessage `json:\"encoder,omitempty\" caddy:\"namespace=caddy.logging.encoders inline_key=format\"`\n\n\t// Tees entries through a zap.Core module which can extract\n\t// log entry metadata and fields for further processing.\n\tCoreRaw json.RawMessage `json:\"core,omitempty\" caddy:\"namespace=caddy.logging.cores inline_key=module\"`\n\n\t// Level is the minimum level to emit, and is inclusive.\n\t// Possible levels: DEBUG, INFO, WARN, ERROR, PANIC, and FATAL\n\tLevel string `json:\"level,omitempty\"`\n\n\t// Sampling configures log entry sampling. If enabled,\n\t// only some log entries will be emitted. This is useful\n\t// for improving performance on extremely high-pressure\n\t// servers.\n\tSampling *LogSampling `json:\"sampling,omitempty\"`\n\n\t// If true, the log entry will include the caller's\n\t// file name and line number. Default off.\n\tWithCaller bool `json:\"with_caller,omitempty\"`\n\n\t// If non-zero, and `with_caller` is true, this many\n\t// stack frames will be skipped when determining the\n\t// caller. Default 0.\n\tWithCallerSkip int `json:\"with_caller_skip,omitempty\"`\n\n\t// If not empty, the log entry will include a stack trace\n\t// for all logs at the given level or higher. See `level`\n\t// for possible values. Default off.\n\tWithStacktrace string `json:\"with_stacktrace,omitempty\"`\n\n\twriterOpener WriterOpener\n\twriter       io.WriteCloser\n\tencoder      zapcore.Encoder\n\tlevelEnabler zapcore.LevelEnabler\n\tcore         zapcore.Core\n}\n\nfunc (cl *BaseLog) provisionCommon(ctx Context, logging *Logging) error {\n\tif cl.WriterRaw != nil {\n\t\tmod, err := ctx.LoadModule(cl, \"WriterRaw\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"loading log writer module: %v\", err)\n\t\t}\n\t\tcl.writerOpener = mod.(WriterOpener)\n\t}\n\tif cl.writerOpener == nil {\n\t\tcl.writerOpener = StderrWriter{}\n\t}\n\tvar err error\n\tcl.writer, _, err = logging.openWriter(cl.writerOpener)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"opening log writer using %#v: %v\", cl.writerOpener, err)\n\t}\n\n\t// set up the log level\n\tcl.levelEnabler, err = parseLevel(cl.Level)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif cl.EncoderRaw != nil {\n\t\tmod, err := ctx.LoadModule(cl, \"EncoderRaw\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"loading log encoder module: %v\", err)\n\t\t}\n\t\tcl.encoder = mod.(zapcore.Encoder)\n\n\t\t// if the encoder module needs the writer to determine\n\t\t// the correct default to use for a nested encoder, we\n\t\t// pass it down as a secondary provisioning step\n\t\tif cfd, ok := mod.(ConfiguresFormatterDefault); ok {\n\t\t\tif err := cfd.ConfigureDefaultFormat(cl.writerOpener); err != nil {\n\t\t\t\treturn fmt.Errorf(\"configuring default format for encoder module: %v\", err)\n\t\t\t}\n\t\t}\n\t}\n\tif cl.encoder == nil {\n\t\tcl.encoder = newDefaultProductionLogEncoder(cl.writerOpener)\n\t}\n\tcl.buildCore()\n\tif cl.CoreRaw != nil {\n\t\tmod, err := ctx.LoadModule(cl, \"CoreRaw\")\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"loading log core module: %v\", err)\n\t\t}\n\t\tcore := mod.(zapcore.Core)\n\t\tcl.core = zapcore.NewTee(cl.core, core)\n\t}\n\treturn nil\n}\n\nfunc (cl *BaseLog) buildCore() {\n\t// logs which only discard their output don't need\n\t// to perform encoding or any other processing steps\n\t// at all, so just shortcut to a nop core instead\n\tif _, ok := cl.writerOpener.(*DiscardWriter); ok {\n\t\tcl.core = zapcore.NewNopCore()\n\t\treturn\n\t}\n\tc := zapcore.NewCore(\n\t\tcl.encoder,\n\t\tzapcore.AddSync(cl.writer),\n\t\tcl.levelEnabler,\n\t)\n\tif cl.Sampling != nil {\n\t\tif cl.Sampling.Interval == 0 {\n\t\t\tcl.Sampling.Interval = 1 * time.Second\n\t\t}\n\t\tif cl.Sampling.First == 0 {\n\t\t\tcl.Sampling.First = 100\n\t\t}\n\t\tif cl.Sampling.Thereafter == 0 {\n\t\t\tcl.Sampling.Thereafter = 100\n\t\t}\n\t\tc = zapcore.NewSamplerWithOptions(c, cl.Sampling.Interval,\n\t\t\tcl.Sampling.First, cl.Sampling.Thereafter)\n\t}\n\tcl.core = c\n}\n\nfunc (cl *BaseLog) buildOptions() ([]zap.Option, error) {\n\tvar options []zap.Option\n\tif cl.WithCaller {\n\t\toptions = append(options, zap.AddCaller())\n\t\tif cl.WithCallerSkip != 0 {\n\t\t\toptions = append(options, zap.AddCallerSkip(cl.WithCallerSkip))\n\t\t}\n\t}\n\tif cl.WithStacktrace != \"\" {\n\t\tlevelEnabler, err := parseLevel(cl.WithStacktrace)\n\t\tif err != nil {\n\t\t\treturn options, fmt.Errorf(\"setting up default Caddy log: %v\", err)\n\t\t}\n\t\toptions = append(options, zap.AddStacktrace(levelEnabler))\n\t}\n\treturn options, nil\n}\n\n// SinkLog configures the default Go standard library\n// global logger in the log package. This is necessary because\n// module dependencies which are not built specifically for\n// Caddy will use the standard logger. This is also known as\n// the \"sink\" logger.\ntype SinkLog struct {\n\tBaseLog\n}\n\nfunc (sll *SinkLog) provision(ctx Context, logging *Logging) error {\n\tif err := sll.provisionCommon(ctx, logging); err != nil {\n\t\treturn err\n\t}\n\n\toptions, err := sll.buildOptions()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlogger := zap.New(sll.core, options...)\n\tctx.cleanupFuncs = append(ctx.cleanupFuncs, zap.RedirectStdLog(logger))\n\treturn nil\n}\n\n// CustomLog represents a custom logger configuration.\n//\n// By default, a log will emit all log entries. Some entries\n// will be skipped if sampling is enabled. Further, the Include\n// and Exclude parameters define which loggers (by name) are\n// allowed or rejected from emitting in this log. If both Include\n// and Exclude are populated, their values must be mutually\n// exclusive, and longer namespaces have priority. If neither\n// are populated, all logs are emitted.\ntype CustomLog struct {\n\tBaseLog\n\n\t// Include defines the names of loggers to emit in this\n\t// log. For example, to include only logs emitted by the\n\t// admin API, you would include \"admin.api\".\n\tInclude []string `json:\"include,omitempty\"`\n\n\t// Exclude defines the names of loggers that should be\n\t// skipped by this log. For example, to exclude only\n\t// HTTP access logs, you would exclude \"http.log.access\".\n\tExclude []string `json:\"exclude,omitempty\"`\n}\n\nfunc (cl *CustomLog) provision(ctx Context, logging *Logging) error {\n\tif err := cl.provisionCommon(ctx, logging); err != nil {\n\t\treturn err\n\t}\n\n\t// If both Include and Exclude lists are populated, then each item must\n\t// be a superspace or subspace of an item in the other list, because\n\t// populating both lists means that any given item is either a rule\n\t// or an exception to another rule. But if the item is not a super-\n\t// or sub-space of any item in the other list, it is neither a rule\n\t// nor an exception, and is a contradiction. Ensure, too, that the\n\t// sets do not intersect, which is also a contradiction.\n\tif len(cl.Include) > 0 && len(cl.Exclude) > 0 {\n\t\t// prevent intersections\n\t\tfor _, allow := range cl.Include {\n\t\t\tfor _, deny := range cl.Exclude {\n\t\t\t\tif allow == deny {\n\t\t\t\t\treturn fmt.Errorf(\"include and exclude must not intersect, but found %s in both lists\", allow)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// ensure namespaces are nested\n\touter:\n\t\tfor _, allow := range cl.Include {\n\t\t\tfor _, deny := range cl.Exclude {\n\t\t\t\tif strings.HasPrefix(allow+\".\", deny+\".\") ||\n\t\t\t\t\tstrings.HasPrefix(deny+\".\", allow+\".\") {\n\t\t\t\t\tcontinue outer\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"when both include and exclude are populated, each element must be a superspace or subspace of one in the other list; check '%s' in include\", allow)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (cl *CustomLog) matchesModule(moduleID string) bool {\n\treturn cl.loggerAllowed(moduleID, true)\n}\n\n// loggerAllowed returns true if name is allowed to emit\n// to cl. isModule should be true if name is the name of\n// a module and you want to see if ANY of that module's\n// logs would be permitted.\nfunc (cl *CustomLog) loggerAllowed(name string, isModule bool) bool {\n\t// accept all loggers by default\n\tif len(cl.Include) == 0 && len(cl.Exclude) == 0 {\n\t\treturn true\n\t}\n\n\t// append a dot so that partial names don't match\n\t// (i.e. we don't want \"foo.b\" to match \"foo.bar\"); we\n\t// will also have to append a dot when we do HasPrefix\n\t// below to compensate for when namespaces are equal\n\tif name != \"\" && name != \"*\" && name != \".\" {\n\t\tname += \".\"\n\t}\n\n\tvar longestAccept, longestReject int\n\n\tif len(cl.Include) > 0 {\n\t\tfor _, namespace := range cl.Include {\n\t\t\tvar hasPrefix bool\n\t\t\tif isModule {\n\t\t\t\thasPrefix = strings.HasPrefix(namespace+\".\", name)\n\t\t\t} else {\n\t\t\t\thasPrefix = strings.HasPrefix(name, namespace+\".\")\n\t\t\t}\n\t\t\tif hasPrefix && len(namespace) > longestAccept {\n\t\t\t\tlongestAccept = len(namespace)\n\t\t\t}\n\t\t}\n\t\t// the include list was populated, meaning that\n\t\t// a match in this list is absolutely required\n\t\t// if we are to accept the entry\n\t\tif longestAccept == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tif len(cl.Exclude) > 0 {\n\t\tfor _, namespace := range cl.Exclude {\n\t\t\t// * == all logs emitted by modules\n\t\t\t// . == all logs emitted by core\n\t\t\tif (namespace == \"*\" && name != \".\") ||\n\t\t\t\t(namespace == \".\" && name == \".\") {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif strings.HasPrefix(name, namespace+\".\") &&\n\t\t\t\tlen(namespace) > longestReject {\n\t\t\t\tlongestReject = len(namespace)\n\t\t\t}\n\t\t}\n\t\t// the reject list is populated, so we have to\n\t\t// reject this entry if its match is better\n\t\t// than the best from the accept list\n\t\tif longestReject > longestAccept {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn (longestAccept > longestReject) ||\n\t\t(len(cl.Include) == 0 && longestReject == 0)\n}\n\n// filteringCore filters log entries based on logger name,\n// according to the rules of a CustomLog.\ntype filteringCore struct {\n\tzapcore.Core\n\tcl *CustomLog\n}\n\n// With properly wraps With.\nfunc (fc *filteringCore) With(fields []zapcore.Field) zapcore.Core {\n\treturn &filteringCore{\n\t\tCore: fc.Core.With(fields),\n\t\tcl:   fc.cl,\n\t}\n}\n\n// Check only allows the log entry if its logger name\n// is allowed from the include/exclude rules of fc.cl.\nfunc (fc *filteringCore) Check(e zapcore.Entry, ce *zapcore.CheckedEntry) *zapcore.CheckedEntry {\n\tif fc.cl.loggerAllowed(e.LoggerName, false) {\n\t\treturn fc.Core.Check(e, ce)\n\t}\n\treturn ce\n}\n\n// LogSampling configures log entry sampling.\ntype LogSampling struct {\n\t// The window over which to conduct sampling.\n\tInterval time.Duration `json:\"interval,omitempty\"`\n\n\t// Log this many entries within a given level and\n\t// message for each interval.\n\tFirst int `json:\"first,omitempty\"`\n\n\t// If more entries with the same level and message\n\t// are seen during the same interval, keep one in\n\t// this many entries until the end of the interval.\n\tThereafter int `json:\"thereafter,omitempty\"`\n}\n\ntype (\n\t// StdoutWriter writes logs to standard out.\n\tStdoutWriter struct{}\n\n\t// StderrWriter writes logs to standard error.\n\tStderrWriter struct{}\n\n\t// DiscardWriter discards all writes.\n\tDiscardWriter struct{}\n)\n\n// CaddyModule returns the Caddy module information.\nfunc (StdoutWriter) CaddyModule() ModuleInfo {\n\treturn ModuleInfo{\n\t\tID:  \"caddy.logging.writers.stdout\",\n\t\tNew: func() Module { return new(StdoutWriter) },\n\t}\n}\n\n// CaddyModule returns the Caddy module information.\nfunc (StderrWriter) CaddyModule() ModuleInfo {\n\treturn ModuleInfo{\n\t\tID:  \"caddy.logging.writers.stderr\",\n\t\tNew: func() Module { return new(StderrWriter) },\n\t}\n}\n\n// CaddyModule returns the Caddy module information.\nfunc (DiscardWriter) CaddyModule() ModuleInfo {\n\treturn ModuleInfo{\n\t\tID:  \"caddy.logging.writers.discard\",\n\t\tNew: func() Module { return new(DiscardWriter) },\n\t}\n}\n\nfunc (StdoutWriter) String() string  { return \"stdout\" }\nfunc (StderrWriter) String() string  { return \"stderr\" }\nfunc (DiscardWriter) String() string { return \"discard\" }\n\n// WriterKey returns a unique key representing stdout.\nfunc (StdoutWriter) WriterKey() string { return \"std:out\" }\n\n// WriterKey returns a unique key representing stderr.\nfunc (StderrWriter) WriterKey() string { return \"std:err\" }\n\n// WriterKey returns a unique key representing discard.\nfunc (DiscardWriter) WriterKey() string { return \"discard\" }\n\n// OpenWriter returns os.Stdout that can't be closed.\nfunc (StdoutWriter) OpenWriter() (io.WriteCloser, error) {\n\treturn notClosable{os.Stdout}, nil\n}\n\n// OpenWriter returns os.Stderr that can't be closed.\nfunc (StderrWriter) OpenWriter() (io.WriteCloser, error) {\n\treturn notClosable{os.Stderr}, nil\n}\n\n// OpenWriter returns io.Discard that can't be closed.\nfunc (DiscardWriter) OpenWriter() (io.WriteCloser, error) {\n\treturn notClosable{io.Discard}, nil\n}\n\n// notClosable is an io.WriteCloser that can't be closed.\ntype notClosable struct{ io.Writer }\n\nfunc (fc notClosable) Close() error { return nil }\n\ntype defaultCustomLog struct {\n\t*CustomLog\n\tlogger *zap.Logger\n}\n\n// newDefaultProductionLog configures a custom log that is\n// intended for use by default if no other log is specified\n// in a config. It writes to stderr, uses the console encoder,\n// and enables INFO-level logs and higher.\nfunc newDefaultProductionLog() (*defaultCustomLog, error) {\n\tcl := new(CustomLog)\n\tcl.writerOpener = StderrWriter{}\n\tvar err error\n\tcl.writer, err = cl.writerOpener.OpenWriter()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcl.encoder = newDefaultProductionLogEncoder(cl.writerOpener)\n\tcl.levelEnabler = zapcore.InfoLevel\n\n\tcl.buildCore()\n\n\tlogger := zap.New(cl.core)\n\n\t// capture logs from other libraries which\n\t// may not be using zap logging directly\n\t_ = zap.RedirectStdLog(logger)\n\n\treturn &defaultCustomLog{\n\t\tCustomLog: cl,\n\t\tlogger:    logger,\n\t}, nil\n}\n\nfunc newDefaultProductionLogEncoder(wo WriterOpener) zapcore.Encoder {\n\tencCfg := zap.NewProductionEncoderConfig()\n\tif IsWriterStandardStream(wo) && term.IsTerminal(int(os.Stderr.Fd())) {\n\t\t// if interactive terminal, make output more human-readable by default\n\t\tencCfg.EncodeTime = func(ts time.Time, encoder zapcore.PrimitiveArrayEncoder) {\n\t\t\tencoder.AppendString(ts.UTC().Format(\"2006/01/02 15:04:05.000\"))\n\t\t}\n\t\tif coloringEnabled {\n\t\t\tencCfg.EncodeLevel = zapcore.CapitalColorLevelEncoder\n\t\t}\n\n\t\treturn zapcore.NewConsoleEncoder(encCfg)\n\t}\n\treturn zapcore.NewJSONEncoder(encCfg)\n}\n\nfunc parseLevel(levelInput string) (zapcore.LevelEnabler, error) {\n\trepl := NewReplacer()\n\tlevel, err := repl.ReplaceOrErr(levelInput, true, true)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid log level: %v\", err)\n\t}\n\tlevel = strings.ToLower(level)\n\n\t// set up the log level\n\tswitch level {\n\tcase \"debug\":\n\t\treturn zapcore.DebugLevel, nil\n\tcase \"\", \"info\":\n\t\treturn zapcore.InfoLevel, nil\n\tcase \"warn\":\n\t\treturn zapcore.WarnLevel, nil\n\tcase \"error\":\n\t\treturn zapcore.ErrorLevel, nil\n\tcase \"panic\":\n\t\treturn zapcore.PanicLevel, nil\n\tcase \"fatal\":\n\t\treturn zapcore.FatalLevel, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unrecognized log level: %s\", level)\n\t}\n}\n\n// Log returns the current default logger.\nfunc Log() *zap.Logger {\n\tdefaultLoggerMu.RLock()\n\tdefer defaultLoggerMu.RUnlock()\n\treturn defaultLogger.logger\n}\n\nvar (\n\tcoloringEnabled  = os.Getenv(\"NO_COLOR\") == \"\" && os.Getenv(\"TERM\") != \"xterm-mono\"\n\tdefaultLogger, _ = newDefaultProductionLog()\n\tdefaultLoggerMu  sync.RWMutex\n)\n\nvar writers = NewUsagePool()\n\n// ConfiguresFormatterDefault is an optional interface that\n// encoder modules can implement to configure the default\n// format of their encoder. This is useful for encoders\n// which nest an encoder, that needs to know the writer\n// in order to determine the correct default.\ntype ConfiguresFormatterDefault interface {\n\tConfigureDefaultFormat(WriterOpener) error\n}\n\nconst DefaultLoggerName = \"default\"\n\n// Interface guards\nvar (\n\t_ io.WriteCloser = (*notClosable)(nil)\n\t_ WriterOpener   = (*StdoutWriter)(nil)\n\t_ WriterOpener   = (*StderrWriter)(nil)\n)\n"
        },
        {
          "name": "metrics.go",
          "type": "blob",
          "size": 2.572265625,
          "content": "package caddy\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\n\t\"github.com/caddyserver/caddy/v2/internal/metrics\"\n)\n\n// define and register the metrics used in this package.\nfunc init() {\n\tconst ns, sub = \"caddy\", \"admin\"\n\tadminMetrics.requestCount = prometheus.NewCounterVec(prometheus.CounterOpts{\n\t\tNamespace: ns,\n\t\tSubsystem: sub,\n\t\tName:      \"http_requests_total\",\n\t\tHelp:      \"Counter of requests made to the Admin API's HTTP endpoints.\",\n\t}, []string{\"handler\", \"path\", \"code\", \"method\"})\n\tadminMetrics.requestErrors = prometheus.NewCounterVec(prometheus.CounterOpts{\n\t\tNamespace: ns,\n\t\tSubsystem: sub,\n\t\tName:      \"http_request_errors_total\",\n\t\tHelp:      \"Number of requests resulting in middleware errors.\",\n\t}, []string{\"handler\", \"path\", \"method\"})\n\tglobalMetrics.configSuccess = prometheus.NewGauge(prometheus.GaugeOpts{\n\t\tName: \"caddy_config_last_reload_successful\",\n\t\tHelp: \"Whether the last configuration reload attempt was successful.\",\n\t})\n\tglobalMetrics.configSuccessTime = prometheus.NewGauge(prometheus.GaugeOpts{\n\t\tName: \"caddy_config_last_reload_success_timestamp_seconds\",\n\t\tHelp: \"Timestamp of the last successful configuration reload.\",\n\t})\n}\n\n// adminMetrics is a collection of metrics that can be tracked for the admin API.\nvar adminMetrics = struct {\n\trequestCount  *prometheus.CounterVec\n\trequestErrors *prometheus.CounterVec\n}{}\n\n// globalMetrics is a collection of metrics that can be tracked for Caddy global state\nvar globalMetrics = struct {\n\tconfigSuccess     prometheus.Gauge\n\tconfigSuccessTime prometheus.Gauge\n}{}\n\n// Similar to promhttp.InstrumentHandlerCounter, but upper-cases method names\n// instead of lower-casing them.\n//\n// Unlike promhttp.InstrumentHandlerCounter, this assumes a \"code\" and \"method\"\n// label is present, and will panic otherwise.\nfunc instrumentHandlerCounter(counter *prometheus.CounterVec, next http.Handler) http.HandlerFunc {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\td := newDelegator(w)\n\t\tnext.ServeHTTP(d, r)\n\t\tcounter.With(prometheus.Labels{\n\t\t\t\"code\":   metrics.SanitizeCode(d.status),\n\t\t\t\"method\": metrics.SanitizeMethod(r.Method),\n\t\t}).Inc()\n\t})\n}\n\nfunc newDelegator(w http.ResponseWriter) *delegator {\n\treturn &delegator{\n\t\tResponseWriter: w,\n\t}\n}\n\ntype delegator struct {\n\thttp.ResponseWriter\n\tstatus int\n}\n\nfunc (d *delegator) WriteHeader(code int) {\n\td.status = code\n\td.ResponseWriter.WriteHeader(code)\n}\n\n// Unwrap returns the underlying ResponseWriter, necessary for\n// http.ResponseController to work correctly.\nfunc (d *delegator) Unwrap() http.ResponseWriter {\n\treturn d.ResponseWriter\n}\n"
        },
        {
          "name": "modules.go",
          "type": "blob",
          "size": 11.6572265625,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// Module is a type that is used as a Caddy module. In\n// addition to this interface, most modules will implement\n// some interface expected by their host module in order\n// to be useful. To learn which interface(s) to implement,\n// see the documentation for the host module. At a bare\n// minimum, this interface, when implemented, only provides\n// the module's ID and constructor function.\n//\n// Modules will often implement additional interfaces\n// including Provisioner, Validator, and CleanerUpper.\n// If a module implements these interfaces, their\n// methods are called during the module's lifespan.\n//\n// When a module is loaded by a host module, the following\n// happens: 1) ModuleInfo.New() is called to get a new\n// instance of the module. 2) The module's configuration is\n// unmarshaled into that instance. 3) If the module is a\n// Provisioner, the Provision() method is called. 4) If the\n// module is a Validator, the Validate() method is called.\n// 5) The module will probably be type-asserted from\n// 'any' to some other, more useful interface expected\n// by the host module. For example, HTTP handler modules are\n// type-asserted as caddyhttp.MiddlewareHandler values.\n// 6) When a module's containing Context is canceled, if it is\n// a CleanerUpper, its Cleanup() method is called.\ntype Module interface {\n\t// This method indicates that the type is a Caddy\n\t// module. The returned ModuleInfo must have both\n\t// a name and a constructor function. This method\n\t// must not have any side-effects.\n\tCaddyModule() ModuleInfo\n}\n\n// ModuleInfo represents a registered Caddy module.\ntype ModuleInfo struct {\n\t// ID is the \"full name\" of the module. It\n\t// must be unique and properly namespaced.\n\tID ModuleID\n\n\t// New returns a pointer to a new, empty\n\t// instance of the module's type. This\n\t// method must not have any side-effects,\n\t// and no other initialization should\n\t// occur within it. Any initialization\n\t// of the returned value should be done\n\t// in a Provision() method (see the\n\t// Provisioner interface).\n\tNew func() Module\n}\n\n// ModuleID is a string that uniquely identifies a Caddy module. A\n// module ID is lightly structured. It consists of dot-separated\n// labels which form a simple hierarchy from left to right. The last\n// label is the module name, and the labels before that constitute\n// the namespace (or scope).\n//\n// Thus, a module ID has the form: <namespace>.<name>\n//\n// An ID with no dot has the empty namespace, which is appropriate\n// for app modules (these are \"top-level\" modules that Caddy core\n// loads and runs).\n//\n// Module IDs should be lowercase and use underscores (_) instead of\n// spaces.\n//\n// Examples of valid IDs:\n// - http\n// - http.handlers.file_server\n// - caddy.logging.encoders.json\ntype ModuleID string\n\n// Namespace returns the namespace (or scope) portion of a module ID,\n// which is all but the last label of the ID. If the ID has only one\n// label, then the namespace is empty.\nfunc (id ModuleID) Namespace() string {\n\tlastDot := strings.LastIndex(string(id), \".\")\n\tif lastDot < 0 {\n\t\treturn \"\"\n\t}\n\treturn string(id)[:lastDot]\n}\n\n// Name returns the Name (last element) of a module ID.\nfunc (id ModuleID) Name() string {\n\tif id == \"\" {\n\t\treturn \"\"\n\t}\n\tparts := strings.Split(string(id), \".\")\n\treturn parts[len(parts)-1]\n}\n\nfunc (mi ModuleInfo) String() string { return string(mi.ID) }\n\n// ModuleMap is a map that can contain multiple modules,\n// where the map key is the module's name. (The namespace\n// is usually read from an associated field's struct tag.)\n// Because the module's name is given as the key in a\n// module map, the name does not have to be given in the\n// json.RawMessage.\ntype ModuleMap map[string]json.RawMessage\n\n// RegisterModule registers a module by receiving a\n// plain/empty value of the module. For registration to\n// be properly recorded, this should be called in the\n// init phase of runtime. Typically, the module package\n// will do this as a side-effect of being imported.\n// This function panics if the module's info is\n// incomplete or invalid, or if the module is already\n// registered.\nfunc RegisterModule(instance Module) {\n\tmod := instance.CaddyModule()\n\n\tif mod.ID == \"\" {\n\t\tpanic(\"module ID missing\")\n\t}\n\tif mod.ID == \"caddy\" || mod.ID == \"admin\" {\n\t\tpanic(fmt.Sprintf(\"module ID '%s' is reserved\", mod.ID))\n\t}\n\tif mod.New == nil {\n\t\tpanic(\"missing ModuleInfo.New\")\n\t}\n\tif val := mod.New(); val == nil {\n\t\tpanic(\"ModuleInfo.New must return a non-nil module instance\")\n\t}\n\n\tmodulesMu.Lock()\n\tdefer modulesMu.Unlock()\n\n\tif _, ok := modules[string(mod.ID)]; ok {\n\t\tpanic(fmt.Sprintf(\"module already registered: %s\", mod.ID))\n\t}\n\tmodules[string(mod.ID)] = mod\n}\n\n// GetModule returns module information from its ID (full name).\nfunc GetModule(name string) (ModuleInfo, error) {\n\tmodulesMu.RLock()\n\tdefer modulesMu.RUnlock()\n\tm, ok := modules[name]\n\tif !ok {\n\t\treturn ModuleInfo{}, fmt.Errorf(\"module not registered: %s\", name)\n\t}\n\treturn m, nil\n}\n\n// GetModuleName returns a module's name (the last label of its ID)\n// from an instance of its value. If the value is not a module, an\n// empty string will be returned.\nfunc GetModuleName(instance any) string {\n\tvar name string\n\tif mod, ok := instance.(Module); ok {\n\t\tname = mod.CaddyModule().ID.Name()\n\t}\n\treturn name\n}\n\n// GetModuleID returns a module's ID from an instance of its value.\n// If the value is not a module, an empty string will be returned.\nfunc GetModuleID(instance any) string {\n\tvar id string\n\tif mod, ok := instance.(Module); ok {\n\t\tid = string(mod.CaddyModule().ID)\n\t}\n\treturn id\n}\n\n// GetModules returns all modules in the given scope/namespace.\n// For example, a scope of \"foo\" returns modules named \"foo.bar\",\n// \"foo.loo\", but not \"bar\", \"foo.bar.loo\", etc. An empty scope\n// returns top-level modules, for example \"foo\" or \"bar\". Partial\n// scopes are not matched (i.e. scope \"foo.ba\" does not match\n// name \"foo.bar\").\n//\n// Because modules are registered to a map under the hood, the\n// returned slice will be sorted to keep it deterministic.\nfunc GetModules(scope string) []ModuleInfo {\n\tmodulesMu.RLock()\n\tdefer modulesMu.RUnlock()\n\n\tscopeParts := strings.Split(scope, \".\")\n\n\t// handle the special case of an empty scope, which\n\t// should match only the top-level modules\n\tif scope == \"\" {\n\t\tscopeParts = []string{}\n\t}\n\n\tvar mods []ModuleInfo\niterateModules:\n\tfor id, m := range modules {\n\t\tmodParts := strings.Split(id, \".\")\n\n\t\t// match only the next level of nesting\n\t\tif len(modParts) != len(scopeParts)+1 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// specified parts must be exact matches\n\t\tfor i := range scopeParts {\n\t\t\tif modParts[i] != scopeParts[i] {\n\t\t\t\tcontinue iterateModules\n\t\t\t}\n\t\t}\n\n\t\tmods = append(mods, m)\n\t}\n\n\t// make return value deterministic\n\tsort.Slice(mods, func(i, j int) bool {\n\t\treturn mods[i].ID < mods[j].ID\n\t})\n\n\treturn mods\n}\n\n// Modules returns the names of all registered modules\n// in ascending lexicographical order.\nfunc Modules() []string {\n\tmodulesMu.RLock()\n\tdefer modulesMu.RUnlock()\n\n\tnames := make([]string, 0, len(modules))\n\tfor name := range modules {\n\t\tnames = append(names, name)\n\t}\n\n\tsort.Strings(names)\n\n\treturn names\n}\n\n// getModuleNameInline loads the string value from raw of moduleNameKey,\n// where raw must be a JSON encoding of a map. It returns that value,\n// along with the result of removing that key from raw.\nfunc getModuleNameInline(moduleNameKey string, raw json.RawMessage) (string, json.RawMessage, error) {\n\tvar tmp map[string]any\n\terr := json.Unmarshal(raw, &tmp)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\tmoduleName, ok := tmp[moduleNameKey].(string)\n\tif !ok || moduleName == \"\" {\n\t\treturn \"\", nil, fmt.Errorf(\"module name not specified with key '%s' in %+v\", moduleNameKey, tmp)\n\t}\n\n\t// remove key from the object, otherwise decoding it later\n\t// will yield an error because the struct won't recognize it\n\t// (this is only needed because we strictly enforce that\n\t// all keys are recognized when loading modules)\n\tdelete(tmp, moduleNameKey)\n\tresult, err := json.Marshal(tmp)\n\tif err != nil {\n\t\treturn \"\", nil, fmt.Errorf(\"re-encoding module configuration: %v\", err)\n\t}\n\n\treturn moduleName, result, nil\n}\n\n// Provisioner is implemented by modules which may need to perform\n// some additional \"setup\" steps immediately after being loaded.\n// Provisioning should be fast (imperceptible running time). If\n// any side-effects result in the execution of this function (e.g.\n// creating global state, any other allocations which require\n// garbage collection, opening files, starting goroutines etc.),\n// be sure to clean up properly by implementing the CleanerUpper\n// interface to avoid leaking resources.\ntype Provisioner interface {\n\tProvision(Context) error\n}\n\n// Validator is implemented by modules which can verify that their\n// configurations are valid. This method will be called after\n// Provision() (if implemented). Validation should always be fast\n// (imperceptible running time) and an error must be returned if\n// the module's configuration is invalid.\ntype Validator interface {\n\tValidate() error\n}\n\n// CleanerUpper is implemented by modules which may have side-effects\n// such as opened files, spawned goroutines, or allocated some sort\n// of non-stack state when they were provisioned. This method should\n// deallocate/cleanup those resources to prevent memory leaks. Cleanup\n// should be fast and efficient. Cleanup should work even if Provision\n// returns an error, to allow cleaning up from partial provisionings.\ntype CleanerUpper interface {\n\tCleanup() error\n}\n\n// ParseStructTag parses a caddy struct tag into its keys and values.\n// It is very simple. The expected syntax is:\n// `caddy:\"key1=val1 key2=val2 ...\"`\nfunc ParseStructTag(tag string) (map[string]string, error) {\n\tresults := make(map[string]string)\n\tpairs := strings.Split(tag, \" \")\n\tfor i, pair := range pairs {\n\t\tif pair == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tbefore, after, isCut := strings.Cut(pair, \"=\")\n\t\tif !isCut {\n\t\t\treturn nil, fmt.Errorf(\"missing key in '%s' (pair %d)\", pair, i)\n\t\t}\n\t\tresults[before] = after\n\t}\n\treturn results, nil\n}\n\n// StrictUnmarshalJSON is like json.Unmarshal but returns an error\n// if any of the fields are unrecognized. Useful when decoding\n// module configurations, where you want to be more sure they're\n// correct.\nfunc StrictUnmarshalJSON(data []byte, v any) error {\n\tdec := json.NewDecoder(bytes.NewReader(data))\n\tdec.DisallowUnknownFields()\n\treturn dec.Decode(v)\n}\n\n// isJSONRawMessage returns true if the type is encoding/json.RawMessage.\nfunc isJSONRawMessage(typ reflect.Type) bool {\n\treturn typ.PkgPath() == \"encoding/json\" && typ.Name() == \"RawMessage\"\n}\n\n// isModuleMapType returns true if the type is map[string]json.RawMessage.\n// It assumes that the string key is the module name, but this is not\n// always the case. To know for sure, this function must return true, but\n// also the struct tag where this type appears must NOT define an inline_key\n// attribute, which would mean that the module names appear inline with the\n// values, not in the key.\nfunc isModuleMapType(typ reflect.Type) bool {\n\treturn typ.Kind() == reflect.Map &&\n\t\ttyp.Key().Kind() == reflect.String &&\n\t\tisJSONRawMessage(typ.Elem())\n}\n\nvar (\n\tmodules   = make(map[string]ModuleInfo)\n\tmodulesMu sync.RWMutex\n)\n"
        },
        {
          "name": "modules",
          "type": "tree",
          "content": null
        },
        {
          "name": "modules_test.go",
          "type": "blob",
          "size": 2.4462890625,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetModules(t *testing.T) {\n\tmodulesMu.Lock()\n\tmodules = map[string]ModuleInfo{\n\t\t\"a\":      {ID: \"a\"},\n\t\t\"a.b\":    {ID: \"a.b\"},\n\t\t\"a.b.c\":  {ID: \"a.b.c\"},\n\t\t\"a.b.cd\": {ID: \"a.b.cd\"},\n\t\t\"a.c\":    {ID: \"a.c\"},\n\t\t\"a.d\":    {ID: \"a.d\"},\n\t\t\"b\":      {ID: \"b\"},\n\t\t\"b.a\":    {ID: \"b.a\"},\n\t\t\"b.b\":    {ID: \"b.b\"},\n\t\t\"b.a.c\":  {ID: \"b.a.c\"},\n\t\t\"c\":      {ID: \"c\"},\n\t}\n\tmodulesMu.Unlock()\n\n\tfor i, tc := range []struct {\n\t\tinput  string\n\t\texpect []ModuleInfo\n\t}{\n\t\t{\n\t\t\tinput: \"\",\n\t\t\texpect: []ModuleInfo{\n\t\t\t\t{ID: \"a\"},\n\t\t\t\t{ID: \"b\"},\n\t\t\t\t{ID: \"c\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"a\",\n\t\t\texpect: []ModuleInfo{\n\t\t\t\t{ID: \"a.b\"},\n\t\t\t\t{ID: \"a.c\"},\n\t\t\t\t{ID: \"a.d\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"a.b\",\n\t\t\texpect: []ModuleInfo{\n\t\t\t\t{ID: \"a.b.c\"},\n\t\t\t\t{ID: \"a.b.cd\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"a.b.c\",\n\t\t},\n\t\t{\n\t\t\tinput: \"b\",\n\t\t\texpect: []ModuleInfo{\n\t\t\t\t{ID: \"b.a\"},\n\t\t\t\t{ID: \"b.b\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"asdf\",\n\t\t},\n\t} {\n\t\tactual := GetModules(tc.input)\n\t\tif !reflect.DeepEqual(actual, tc.expect) {\n\t\t\tt.Errorf(\"Test %d: Expected %v but got %v\", i, tc.expect, actual)\n\t\t}\n\t}\n}\n\nfunc TestModuleID(t *testing.T) {\n\tfor i, tc := range []struct {\n\t\tinput           ModuleID\n\t\texpectNamespace string\n\t\texpectName      string\n\t}{\n\t\t{\n\t\t\tinput:           \"foo\",\n\t\t\texpectNamespace: \"\",\n\t\t\texpectName:      \"foo\",\n\t\t},\n\t\t{\n\t\t\tinput:           \"foo.bar\",\n\t\t\texpectNamespace: \"foo\",\n\t\t\texpectName:      \"bar\",\n\t\t},\n\t\t{\n\t\t\tinput:           \"a.b.c\",\n\t\t\texpectNamespace: \"a.b\",\n\t\t\texpectName:      \"c\",\n\t\t},\n\t} {\n\t\tactualNamespace := tc.input.Namespace()\n\t\tif actualNamespace != tc.expectNamespace {\n\t\t\tt.Errorf(\"Test %d: Expected namespace '%s' but got '%s'\", i, tc.expectNamespace, actualNamespace)\n\t\t}\n\t\tactualName := tc.input.Name()\n\t\tif actualName != tc.expectName {\n\t\t\tt.Errorf(\"Test %d: Expected name '%s' but got '%s'\", i, tc.expectName, actualName)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "notify",
          "type": "tree",
          "content": null
        },
        {
          "name": "replacer.go",
          "type": "blob",
          "size": 12.0185546875,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n)\n\n// NewReplacer returns a new Replacer.\nfunc NewReplacer() *Replacer {\n\trep := &Replacer{\n\t\tstatic:   make(map[string]any),\n\t\tmapMutex: &sync.RWMutex{},\n\t}\n\trep.providers = []replacementProvider{\n\t\tglobalDefaultReplacementProvider{},\n\t\tfileReplacementProvider{},\n\t\tReplacerFunc(rep.fromStatic),\n\t}\n\treturn rep\n}\n\n// NewEmptyReplacer returns a new Replacer,\n// without the global default replacements.\nfunc NewEmptyReplacer() *Replacer {\n\trep := &Replacer{\n\t\tstatic:   make(map[string]any),\n\t\tmapMutex: &sync.RWMutex{},\n\t}\n\trep.providers = []replacementProvider{\n\t\tReplacerFunc(rep.fromStatic),\n\t}\n\treturn rep\n}\n\n// Replacer can replace values in strings.\n// A default/empty Replacer is not valid;\n// use NewReplacer to make one.\ntype Replacer struct {\n\tproviders []replacementProvider\n\tstatic    map[string]any\n\tmapMutex  *sync.RWMutex\n}\n\n// WithoutFile returns a copy of the current Replacer\n// without support for the {file.*} placeholder, which\n// may be unsafe in some contexts.\n//\n// EXPERIMENTAL: Subject to change or removal.\nfunc (r *Replacer) WithoutFile() *Replacer {\n\trep := &Replacer{static: r.static}\n\tfor _, v := range r.providers {\n\t\tif _, ok := v.(fileReplacementProvider); ok {\n\t\t\tcontinue\n\t\t}\n\t\trep.providers = append(rep.providers, v)\n\t}\n\treturn rep\n}\n\n// Map adds mapFunc to the list of value providers.\n// mapFunc will be executed only at replace-time.\nfunc (r *Replacer) Map(mapFunc ReplacerFunc) {\n\tr.providers = append(r.providers, mapFunc)\n}\n\n// Set sets a custom variable to a static value.\nfunc (r *Replacer) Set(variable string, value any) {\n\tr.mapMutex.Lock()\n\tr.static[variable] = value\n\tr.mapMutex.Unlock()\n}\n\n// Get gets a value from the replacer. It returns\n// the value and whether the variable was known.\nfunc (r *Replacer) Get(variable string) (any, bool) {\n\tfor _, mapFunc := range r.providers {\n\t\tif val, ok := mapFunc.replace(variable); ok {\n\t\t\treturn val, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\n// GetString is the same as Get, but coerces the value to a\n// string representation as efficiently as possible.\nfunc (r *Replacer) GetString(variable string) (string, bool) {\n\ts, found := r.Get(variable)\n\treturn ToString(s), found\n}\n\n// Delete removes a variable with a static value\n// that was created using Set.\nfunc (r *Replacer) Delete(variable string) {\n\tr.mapMutex.Lock()\n\tdelete(r.static, variable)\n\tr.mapMutex.Unlock()\n}\n\n// fromStatic provides values from r.static.\nfunc (r *Replacer) fromStatic(key string) (any, bool) {\n\tr.mapMutex.RLock()\n\tdefer r.mapMutex.RUnlock()\n\tval, ok := r.static[key]\n\treturn val, ok\n}\n\n// ReplaceOrErr is like ReplaceAll, but any placeholders\n// that are empty or not recognized will cause an error to\n// be returned.\nfunc (r *Replacer) ReplaceOrErr(input string, errOnEmpty, errOnUnknown bool) (string, error) {\n\treturn r.replace(input, \"\", false, errOnEmpty, errOnUnknown, nil)\n}\n\n// ReplaceKnown is like ReplaceAll but only replaces\n// placeholders that are known (recognized). Unrecognized\n// placeholders will remain in the output.\nfunc (r *Replacer) ReplaceKnown(input, empty string) string {\n\tout, _ := r.replace(input, empty, false, false, false, nil)\n\treturn out\n}\n\n// ReplaceAll efficiently replaces placeholders in input with\n// their values. All placeholders are replaced in the output\n// whether they are recognized or not. Values that are empty\n// string will be substituted with empty.\nfunc (r *Replacer) ReplaceAll(input, empty string) string {\n\tout, _ := r.replace(input, empty, true, false, false, nil)\n\treturn out\n}\n\n// ReplaceFunc is the same as ReplaceAll, but calls f for every\n// replacement to be made, in case f wants to change or inspect\n// the replacement.\nfunc (r *Replacer) ReplaceFunc(input string, f ReplacementFunc) (string, error) {\n\treturn r.replace(input, \"\", true, false, false, f)\n}\n\nfunc (r *Replacer) replace(input, empty string,\n\ttreatUnknownAsEmpty, errOnEmpty, errOnUnknown bool,\n\tf ReplacementFunc,\n) (string, error) {\n\tif !strings.Contains(input, string(phOpen)) && !strings.Contains(input, string(phClose)) {\n\t\treturn input, nil\n\t}\n\n\tvar sb strings.Builder\n\n\t// it is reasonable to assume that the output\n\t// will be approximately as long as the input\n\tsb.Grow(len(input))\n\n\t// iterate the input to find each placeholder\n\tvar lastWriteCursor int\n\n\t// fail fast if too many placeholders are unclosed\n\tvar unclosedCount int\n\nscan:\n\tfor i := 0; i < len(input); i++ {\n\t\t// check for escaped braces\n\t\tif i > 0 && input[i-1] == phEscape && (input[i] == phClose || input[i] == phOpen) {\n\t\t\tsb.WriteString(input[lastWriteCursor : i-1])\n\t\t\tlastWriteCursor = i\n\t\t\tcontinue\n\t\t}\n\n\t\tif input[i] != phOpen {\n\t\t\tcontinue\n\t\t}\n\n\t\t// our iterator is now on an unescaped open brace (start of placeholder)\n\n\t\t// too many unclosed placeholders in absolutely ridiculous input can be extremely slow (issue #4170)\n\t\tif unclosedCount > 100 {\n\t\t\treturn \"\", fmt.Errorf(\"too many unclosed placeholders\")\n\t\t}\n\n\t\t// find the end of the placeholder\n\t\tend := strings.Index(input[i:], string(phClose)) + i\n\t\tif end < i {\n\t\t\tunclosedCount++\n\t\t\tcontinue\n\t\t}\n\n\t\t// if necessary look for the first closing brace that is not escaped\n\t\tfor end > 0 && end < len(input)-1 && input[end-1] == phEscape {\n\t\t\tnextEnd := strings.Index(input[end+1:], string(phClose))\n\t\t\tif nextEnd < 0 {\n\t\t\t\tunclosedCount++\n\t\t\t\tcontinue scan\n\t\t\t}\n\t\t\tend += nextEnd + 1\n\t\t}\n\n\t\t// write the substring from the last cursor to this point\n\t\tsb.WriteString(input[lastWriteCursor:i])\n\n\t\t// trim opening bracket\n\t\tkey := input[i+1 : end]\n\n\t\t// try to get a value for this key, handle empty values accordingly\n\t\tval, found := r.Get(key)\n\t\tif !found {\n\t\t\t// placeholder is unknown (unrecognized); handle accordingly\n\t\t\tif errOnUnknown {\n\t\t\t\treturn \"\", fmt.Errorf(\"unrecognized placeholder %s%s%s\",\n\t\t\t\t\tstring(phOpen), key, string(phClose))\n\t\t\t} else if !treatUnknownAsEmpty {\n\t\t\t\t// if treatUnknownAsEmpty is true, we'll handle an empty\n\t\t\t\t// val later; so only continue otherwise\n\t\t\t\tlastWriteCursor = i\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// apply any transformations\n\t\tif f != nil {\n\t\t\tvar err error\n\t\t\tval, err = f(key, val)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t}\n\n\t\t// convert val to a string as efficiently as possible\n\t\tvalStr := ToString(val)\n\n\t\t// write the value; if it's empty, either return\n\t\t// an error or write a default value\n\t\tif valStr == \"\" {\n\t\t\tif errOnEmpty {\n\t\t\t\treturn \"\", fmt.Errorf(\"evaluated placeholder %s%s%s is empty\",\n\t\t\t\t\tstring(phOpen), key, string(phClose))\n\t\t\t} else if empty != \"\" {\n\t\t\t\tsb.WriteString(empty)\n\t\t\t}\n\t\t} else {\n\t\t\tsb.WriteString(valStr)\n\t\t}\n\n\t\t// advance cursor to end of placeholder\n\t\ti = end\n\t\tlastWriteCursor = i + 1\n\t}\n\n\t// flush any unwritten remainder\n\tsb.WriteString(input[lastWriteCursor:])\n\n\treturn sb.String(), nil\n}\n\n// ToString returns val as a string, as efficiently as possible.\n// EXPERIMENTAL: may be changed or removed later.\nfunc ToString(val any) string {\n\tswitch v := val.(type) {\n\tcase nil:\n\t\treturn \"\"\n\tcase string:\n\t\treturn v\n\tcase fmt.Stringer:\n\t\treturn v.String()\n\tcase error:\n\t\treturn v.Error()\n\tcase byte:\n\t\treturn string(v)\n\tcase []byte:\n\t\treturn string(v)\n\tcase []rune:\n\t\treturn string(v)\n\tcase int:\n\t\treturn strconv.Itoa(v)\n\tcase int32:\n\t\treturn strconv.Itoa(int(v))\n\tcase int64:\n\t\treturn strconv.Itoa(int(v))\n\tcase uint:\n\t\treturn strconv.FormatUint(uint64(v), 10)\n\tcase uint32:\n\t\treturn strconv.FormatUint(uint64(v), 10)\n\tcase uint64:\n\t\treturn strconv.FormatUint(v, 10)\n\tcase float32:\n\t\treturn strconv.FormatFloat(float64(v), 'f', -1, 32)\n\tcase float64:\n\t\treturn strconv.FormatFloat(v, 'f', -1, 64)\n\tcase bool:\n\t\tif v {\n\t\t\treturn \"true\"\n\t\t}\n\t\treturn \"false\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"%+v\", v)\n\t}\n}\n\n// ReplacerFunc is a function that returns a replacement for the\n// given key along with true if the function is able to service\n// that key (even if the value is blank). If the function does\n// not recognize the key, false should be returned.\ntype ReplacerFunc func(key string) (any, bool)\n\nfunc (f ReplacerFunc) replace(key string) (any, bool) {\n\treturn f(key)\n}\n\n// replacementProvider is a type that can provide replacements\n// for placeholders. Allows for type assertion to determine\n// which type of provider it is.\ntype replacementProvider interface {\n\treplace(key string) (any, bool)\n}\n\n// fileReplacementsProvider handles {file.*} replacements,\n// reading a file from disk and replacing with its contents.\ntype fileReplacementProvider struct{}\n\nfunc (f fileReplacementProvider) replace(key string) (any, bool) {\n\tif !strings.HasPrefix(key, filePrefix) {\n\t\treturn nil, false\n\t}\n\n\tfilename := key[len(filePrefix):]\n\tmaxSize := 1024 * 1024\n\tbody, err := readFileIntoBuffer(filename, maxSize)\n\tif err != nil {\n\t\twd, _ := os.Getwd()\n\t\tLog().Error(\"placeholder: failed to read file\",\n\t\t\tzap.String(\"file\", filename),\n\t\t\tzap.String(\"working_dir\", wd),\n\t\t\tzap.Error(err))\n\t\treturn nil, true\n\t}\n\tbody = bytes.TrimSuffix(body, []byte(\"\\n\"))\n\tbody = bytes.TrimSuffix(body, []byte(\"\\r\"))\n\treturn string(body), true\n}\n\n// globalDefaultReplacementsProvider handles replacements\n// that can be used in any context, such as system variables,\n// time, or environment variables.\ntype globalDefaultReplacementProvider struct{}\n\nfunc (f globalDefaultReplacementProvider) replace(key string) (any, bool) {\n\t// check environment variable\n\tconst envPrefix = \"env.\"\n\tif strings.HasPrefix(key, envPrefix) {\n\t\treturn os.Getenv(key[len(envPrefix):]), true\n\t}\n\n\tswitch key {\n\tcase \"system.hostname\":\n\t\t// OK if there is an error; just return empty string\n\t\tname, _ := os.Hostname()\n\t\treturn name, true\n\tcase \"system.slash\":\n\t\treturn string(filepath.Separator), true\n\tcase \"system.os\":\n\t\treturn runtime.GOOS, true\n\tcase \"system.wd\":\n\t\t// OK if there is an error; just return empty string\n\t\twd, _ := os.Getwd()\n\t\treturn wd, true\n\tcase \"system.arch\":\n\t\treturn runtime.GOARCH, true\n\tcase \"time.now\":\n\t\treturn nowFunc(), true\n\tcase \"time.now.http\":\n\t\t// According to the comment for http.TimeFormat, the timezone must be in UTC\n\t\t// to generate the correct format.\n\t\t// https://github.com/caddyserver/caddy/issues/5773\n\t\treturn nowFunc().UTC().Format(http.TimeFormat), true\n\tcase \"time.now.common_log\":\n\t\treturn nowFunc().Format(\"02/Jan/2006:15:04:05 -0700\"), true\n\tcase \"time.now.year\":\n\t\treturn strconv.Itoa(nowFunc().Year()), true\n\tcase \"time.now.unix\":\n\t\treturn strconv.FormatInt(nowFunc().Unix(), 10), true\n\tcase \"time.now.unix_ms\":\n\t\treturn strconv.FormatInt(nowFunc().UnixNano()/int64(time.Millisecond), 10), true\n\t}\n\n\treturn nil, false\n}\n\n// readFileIntoBuffer reads the file at filePath into a size limited buffer.\nfunc readFileIntoBuffer(filename string, size int) ([]byte, error) {\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer file.Close()\n\n\tbuffer := make([]byte, size)\n\tn, err := file.Read(buffer)\n\tif err != nil && err != io.EOF {\n\t\treturn nil, err\n\t}\n\n\t// slice the buffer to the actual size\n\treturn buffer[:n], nil\n}\n\n// ReplacementFunc is a function that is called when a\n// replacement is being performed. It receives the\n// variable (i.e. placeholder name) and the value that\n// will be the replacement, and returns the value that\n// will actually be the replacement, or an error. Note\n// that errors are sometimes ignored by replacers.\ntype ReplacementFunc func(variable string, val any) (any, error)\n\n// nowFunc is a variable so tests can change it\n// in order to obtain a deterministic time.\nvar nowFunc = time.Now\n\n// ReplacerCtxKey is the context key for a replacer.\nconst ReplacerCtxKey CtxKey = \"replacer\"\n\nconst phOpen, phClose, phEscape = '{', '}', '\\\\'\n\nconst filePrefix = \"file.\"\n"
        },
        {
          "name": "replacer_fuzz.go",
          "type": "blob",
          "size": 0.9931640625,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build gofuzz\n\npackage caddy\n\nfunc FuzzReplacer(data []byte) (score int) {\n\tNewReplacer().ReplaceAll(string(data), \"\")\n\tNewReplacer().ReplaceAll(NewReplacer().ReplaceAll(string(data), \"\"), \"\")\n\tNewReplacer().ReplaceAll(NewReplacer().ReplaceAll(string(data), \"\"), NewReplacer().ReplaceAll(string(data), \"\"))\n\tNewReplacer().ReplaceAll(string(data[:len(data)/2]), string(data[len(data)/2:]))\n\treturn 0\n}\n"
        },
        {
          "name": "replacer_test.go",
          "type": "blob",
          "size": 11.0439453125,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sync\"\n\t\"testing\"\n)\n\nfunc TestReplacer(t *testing.T) {\n\ttype testCase struct {\n\t\tinput, expect, empty string\n\t}\n\n\trep := testReplacer()\n\n\t// ReplaceAll\n\tfor i, tc := range []testCase{\n\t\t{\n\t\t\tinput:  \"{\",\n\t\t\texpect: \"{\",\n\t\t},\n\t\t{\n\t\t\tinput:  `\\{`,\n\t\t\texpect: `{`,\n\t\t},\n\t\t{\n\t\t\tinput:  \"foo{\",\n\t\t\texpect: \"foo{\",\n\t\t},\n\t\t{\n\t\t\tinput:  `foo\\{`,\n\t\t\texpect: `foo{`,\n\t\t},\n\t\t{\n\t\t\tinput:  \"foo{bar\",\n\t\t\texpect: \"foo{bar\",\n\t\t},\n\t\t{\n\t\t\tinput:  `foo\\{bar`,\n\t\t\texpect: `foo{bar`,\n\t\t},\n\t\t{\n\t\t\tinput:  \"foo{bar}\",\n\t\t\texpect: \"foo\",\n\t\t},\n\t\t{\n\t\t\tinput:  `foo\\{bar\\}`,\n\t\t\texpect: `foo{bar}`,\n\t\t},\n\t\t{\n\t\t\tinput:  \"}\",\n\t\t\texpect: \"}\",\n\t\t},\n\t\t{\n\t\t\tinput:  `\\}`,\n\t\t\texpect: `}`,\n\t\t},\n\t\t{\n\t\t\tinput:  \"{}\",\n\t\t\texpect: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:  `\\{\\}`,\n\t\t\texpect: `{}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `{\"json\": \"object\"}`,\n\t\t\texpect: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:  `\\{\"json\": \"object\"}`,\n\t\t\texpect: `{\"json\": \"object\"}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `\\{\"json\": \"object\"\\}`,\n\t\t\texpect: `{\"json\": \"object\"}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `\\{\"json\": \"object{bar}\"\\}`,\n\t\t\texpect: `{\"json\": \"object\"}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `\\{\"json\": \\{\"nested\": \"object\"\\}\\}`,\n\t\t\texpect: `{\"json\": {\"nested\": \"object\"}}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `\\{\"json\": \\{\"nested\": \"{bar}\"\\}\\}`,\n\t\t\texpect: `{\"json\": {\"nested\": \"\"}}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `pre \\{\"json\": \\{\"nested\": \"{bar}\"\\}\\}`,\n\t\t\texpect: `pre {\"json\": {\"nested\": \"\"}}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `\\{\"json\": \\{\"nested\": \"{bar}\"\\}\\} post`,\n\t\t\texpect: `{\"json\": {\"nested\": \"\"}} post`,\n\t\t},\n\t\t{\n\t\t\tinput:  `pre \\{\"json\": \\{\"nested\": \"{bar}\"\\}\\} post`,\n\t\t\texpect: `pre {\"json\": {\"nested\": \"\"}} post`,\n\t\t},\n\t\t{\n\t\t\tinput:  `{{`,\n\t\t\texpect: \"{{\",\n\t\t},\n\t\t{\n\t\t\tinput:  `{{}`,\n\t\t\texpect: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:  `{\"json\": \"object\"\\}`,\n\t\t\texpect: \"\",\n\t\t},\n\t\t{\n\t\t\tinput:  `{unknown}`,\n\t\t\tempty:  \"-\",\n\t\t\texpect: \"-\",\n\t\t},\n\t\t{\n\t\t\tinput:  `back\\slashes`,\n\t\t\texpect: `back\\slashes`,\n\t\t},\n\t\t{\n\t\t\tinput:  `double back\\\\slashes`,\n\t\t\texpect: `double back\\\\slashes`,\n\t\t},\n\t\t{\n\t\t\tinput:  `placeholder {with \\{ brace} in name`,\n\t\t\texpect: `placeholder  in name`,\n\t\t},\n\t\t{\n\t\t\tinput:  `placeholder {with \\} brace} in name`,\n\t\t\texpect: `placeholder  in name`,\n\t\t},\n\t\t{\n\t\t\tinput:  `placeholder {with \\} \\} braces} in name`,\n\t\t\texpect: `placeholder  in name`,\n\t\t},\n\t\t{\n\t\t\tinput:  `\\{'group':'default','max_age':3600,'endpoints':[\\{'url':'https://some.domain.local/a/d/g'\\}],'include_subdomains':true\\}`,\n\t\t\texpect: `{'group':'default','max_age':3600,'endpoints':[{'url':'https://some.domain.local/a/d/g'}],'include_subdomains':true}`,\n\t\t},\n\t\t{\n\t\t\tinput:  `{}{}{}{\\\\\\\\}\\\\\\\\`,\n\t\t\texpect: `{\\\\\\}\\\\\\\\`,\n\t\t},\n\t\t{\n\t\t\tinput:  string([]byte{0x26, 0x00, 0x83, 0x7B, 0x84, 0x07, 0x5C, 0x7D, 0x84}),\n\t\t\texpect: string([]byte{0x26, 0x00, 0x83, 0x7B, 0x84, 0x07, 0x7D, 0x84}),\n\t\t},\n\t\t{\n\t\t\tinput:  `\\\\}`,\n\t\t\texpect: `\\}`,\n\t\t},\n\t} {\n\t\tactual := rep.ReplaceAll(tc.input, tc.empty)\n\t\tif actual != tc.expect {\n\t\t\tt.Errorf(\"Test %d: '%s': expected '%s' but got '%s'\",\n\t\t\t\ti, tc.input, tc.expect, actual)\n\t\t}\n\t}\n}\n\nfunc TestReplacerSet(t *testing.T) {\n\trep := testReplacer()\n\n\tfor _, tc := range []struct {\n\t\tvariable string\n\t\tvalue    any\n\t}{\n\t\t{\n\t\t\tvariable: \"test1\",\n\t\t\tvalue:    \"val1\",\n\t\t},\n\t\t{\n\t\t\tvariable: \"asdf\",\n\t\t\tvalue:    \"123\",\n\t\t},\n\t\t{\n\t\t\tvariable: \"numbers\",\n\t\t\tvalue:    123.456,\n\t\t},\n\t\t{\n\t\t\tvariable: \"Ã¤Ã¶Ã¼\",\n\t\t\tvalue:    \"Ã¶Ã¶_Ã¤Ã¼\",\n\t\t},\n\t\t{\n\t\t\tvariable: \"with space\",\n\t\t\tvalue:    \"space value\",\n\t\t},\n\t\t{\n\t\t\tvariable: \"1\",\n\t\t\tvalue:    \"test-123\",\n\t\t},\n\t\t{\n\t\t\tvariable: \"mySuper_IP\",\n\t\t\tvalue:    \"1.2.3.4\",\n\t\t},\n\t\t{\n\t\t\tvariable: \"testEmpty\",\n\t\t\tvalue:    \"\",\n\t\t},\n\t} {\n\t\trep.Set(tc.variable, tc.value)\n\n\t\t// test if key is added\n\t\tif val, ok := rep.static[tc.variable]; ok {\n\t\t\tif val != tc.value {\n\t\t\t\tt.Errorf(\"Expected value '%s' for key '%s' got '%s'\", tc.value, tc.variable, val)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Errorf(\"Expected existing key '%s' found nothing\", tc.variable)\n\t\t}\n\t}\n\n\t// test if all keys are still there (by length)\n\tlength := len(rep.static)\n\tif len(rep.static) != 8 {\n\t\tt.Errorf(\"Expected length '%v' got '%v'\", 7, length)\n\t}\n}\n\nfunc TestReplacerReplaceKnown(t *testing.T) {\n\trep := Replacer{\n\t\tmapMutex: &sync.RWMutex{},\n\t\tproviders: []replacementProvider{\n\t\t\t// split our possible vars to two functions (to test if both functions are called)\n\t\t\tReplacerFunc(func(key string) (val any, ok bool) {\n\t\t\t\tswitch key {\n\t\t\t\tcase \"test1\":\n\t\t\t\t\treturn \"val1\", true\n\t\t\t\tcase \"asdf\":\n\t\t\t\t\treturn \"123\", true\n\t\t\t\tcase \"Ã¤Ã¶Ã¼\":\n\t\t\t\t\treturn \"Ã¶Ã¶_Ã¤Ã¼\", true\n\t\t\t\tcase \"with space\":\n\t\t\t\t\treturn \"space value\", true\n\t\t\t\tdefault:\n\t\t\t\t\treturn \"NOOO\", false\n\t\t\t\t}\n\t\t\t}),\n\t\t\tReplacerFunc(func(key string) (val any, ok bool) {\n\t\t\t\tswitch key {\n\t\t\t\tcase \"1\":\n\t\t\t\t\treturn \"test-123\", true\n\t\t\t\tcase \"mySuper_IP\":\n\t\t\t\t\treturn \"1.2.3.4\", true\n\t\t\t\tcase \"testEmpty\":\n\t\t\t\t\treturn \"\", true\n\t\t\t\tdefault:\n\t\t\t\t\treturn \"NOOO\", false\n\t\t\t\t}\n\t\t\t}),\n\t\t},\n\t}\n\n\tfor _, tc := range []struct {\n\t\ttestInput string\n\t\texpected  string\n\t}{\n\t\t{\n\t\t\t// test vars without space\n\t\t\ttestInput: \"{test1}{asdf}{Ã¤Ã¶Ã¼}{1}{with space}{mySuper_IP}\",\n\t\t\texpected:  \"val1123Ã¶Ã¶_Ã¤Ã¼test-123space value1.2.3.4\",\n\t\t},\n\t\t{\n\t\t\t// test vars with space\n\t\t\ttestInput: \"{test1} {asdf} {Ã¤Ã¶Ã¼} {1} {with space} {mySuper_IP} \",\n\t\t\texpected:  \"val1 123 Ã¶Ã¶_Ã¤Ã¼ test-123 space value 1.2.3.4 \",\n\t\t},\n\t\t{\n\t\t\t// test with empty val\n\t\t\ttestInput: \"{test1} {testEmpty} {asdf} {1} \",\n\t\t\texpected:  \"val1 EMPTY 123 test-123 \",\n\t\t},\n\t\t{\n\t\t\t// test vars with not finished placeholders\n\t\t\ttestInput: \"{te{test1}{as{{df{1}\",\n\t\t\texpected:  \"{teval1{as{{dftest-123\",\n\t\t},\n\t\t{\n\t\t\t// test with non existing vars\n\t\t\ttestInput: \"{test1} {nope} {1} \",\n\t\t\texpected:  \"val1 {nope} test-123 \",\n\t\t},\n\t} {\n\t\tactual := rep.ReplaceKnown(tc.testInput, \"EMPTY\")\n\n\t\t// test if all are replaced as expected\n\t\tif actual != tc.expected {\n\t\t\tt.Errorf(\"Expected '%s' got '%s' for '%s'\", tc.expected, actual, tc.testInput)\n\t\t}\n\t}\n}\n\nfunc TestReplacerDelete(t *testing.T) {\n\trep := Replacer{\n\t\tmapMutex: &sync.RWMutex{},\n\t\tstatic: map[string]any{\n\t\t\t\"key1\": \"val1\",\n\t\t\t\"key2\": \"val2\",\n\t\t\t\"key3\": \"val3\",\n\t\t\t\"key4\": \"val4\",\n\t\t},\n\t}\n\n\tstartLen := len(rep.static)\n\n\ttoDel := []string{\n\t\t\"key2\", \"key4\",\n\t}\n\n\tfor _, key := range toDel {\n\t\trep.Delete(key)\n\n\t\t// test if key is removed from static map\n\t\tif _, ok := rep.static[key]; ok {\n\t\t\tt.Errorf(\"Expected '%s' to be removed. It is still in static map.\", key)\n\t\t}\n\t}\n\n\t// check if static slice is smaller\n\texpected := startLen - len(toDel)\n\tactual := len(rep.static)\n\tif len(rep.static) != expected {\n\t\tt.Errorf(\"Expected length '%v' got length '%v'\", expected, actual)\n\t}\n}\n\nfunc TestReplacerMap(t *testing.T) {\n\trep := testReplacer()\n\n\tfor i, tc := range []ReplacerFunc{\n\t\tfunc(key string) (val any, ok bool) {\n\t\t\treturn \"\", false\n\t\t},\n\t\tfunc(key string) (val any, ok bool) {\n\t\t\treturn \"\", false\n\t\t},\n\t} {\n\t\trep.Map(tc)\n\n\t\t// test if function (which listens on specific key) is added by checking length\n\t\tif len(rep.providers) == i+1 {\n\t\t\t// check if the last function is the one we just added\n\t\t\tpTc := fmt.Sprintf(\"%p\", tc)\n\t\t\tpRep := fmt.Sprintf(\"%p\", rep.providers[i])\n\t\t\tif pRep != pTc {\n\t\t\t\tt.Errorf(\"Expected func pointer '%s' got '%s'\", pTc, pRep)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Errorf(\"Expected providers length '%v' got length '%v'\", i+1, len(rep.providers))\n\t\t}\n\t}\n}\n\nfunc TestReplacerNew(t *testing.T) {\n\trepl := NewReplacer()\n\n\tif len(repl.providers) != 3 {\n\t\tt.Errorf(\"Expected providers length '%v' got length '%v'\", 3, len(repl.providers))\n\t}\n\n\t// test if default global replacements are added as the first provider\n\thostname, _ := os.Hostname()\n\twd, _ := os.Getwd()\n\tos.Setenv(\"CADDY_REPLACER_TEST\", \"envtest\")\n\tdefer os.Setenv(\"CADDY_REPLACER_TEST\", \"\")\n\n\tfor _, tc := range []struct {\n\t\tvariable string\n\t\tvalue    string\n\t}{\n\t\t{\n\t\t\tvariable: \"system.hostname\",\n\t\t\tvalue:    hostname,\n\t\t},\n\t\t{\n\t\t\tvariable: \"system.slash\",\n\t\t\tvalue:    string(filepath.Separator),\n\t\t},\n\t\t{\n\t\t\tvariable: \"system.os\",\n\t\t\tvalue:    runtime.GOOS,\n\t\t},\n\t\t{\n\t\t\tvariable: \"system.arch\",\n\t\t\tvalue:    runtime.GOARCH,\n\t\t},\n\t\t{\n\t\t\tvariable: \"system.wd\",\n\t\t\tvalue:    wd,\n\t\t},\n\t\t{\n\t\t\tvariable: \"env.CADDY_REPLACER_TEST\",\n\t\t\tvalue:    \"envtest\",\n\t\t},\n\t} {\n\t\tif val, ok := repl.providers[0].replace(tc.variable); ok {\n\t\t\tif val != tc.value {\n\t\t\t\tt.Errorf(\"Expected value '%s' for key '%s' got '%s'\", tc.value, tc.variable, val)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Errorf(\"Expected key '%s' to be recognized by first provider\", tc.variable)\n\t\t}\n\t}\n\n\t// test if file provider is added as the second provider\n\tfor _, tc := range []struct {\n\t\tvariable string\n\t\tvalue    string\n\t}{\n\t\t{\n\t\t\tvariable: \"file.caddytest/integration/testdata/foo.txt\",\n\t\t\tvalue:    \"foo\",\n\t\t},\n\t\t{\n\t\t\tvariable: \"file.caddytest/integration/testdata/foo_with_trailing_newline.txt\",\n\t\t\tvalue:    \"foo\",\n\t\t},\n\t\t{\n\t\t\tvariable: \"file.caddytest/integration/testdata/foo_with_multiple_trailing_newlines.txt\",\n\t\t\tvalue:    \"foo\" + getEOL(),\n\t\t},\n\t} {\n\t\tif val, ok := repl.providers[1].replace(tc.variable); ok {\n\t\t\tif val != tc.value {\n\t\t\t\tt.Errorf(\"Expected value '%s' for key '%s' got '%s'\", tc.value, tc.variable, val)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Errorf(\"Expected key '%s' to be recognized by second provider\", tc.variable)\n\t\t}\n\t}\n}\n\nfunc getEOL() string {\n\tif os.PathSeparator == '\\\\' {\n\t\treturn \"\\r\\n\" // Windows EOL\n\t}\n\treturn \"\\n\" // Unix and modern macOS EOL\n}\n\nfunc TestReplacerNewWithoutFile(t *testing.T) {\n\trepl := NewReplacer().WithoutFile()\n\n\tfor _, tc := range []struct {\n\t\tvariable string\n\t\tvalue    string\n\t\tnotFound bool\n\t}{\n\t\t{\n\t\t\tvariable: \"file.caddytest/integration/testdata/foo.txt\",\n\t\t\tnotFound: true,\n\t\t},\n\t\t{\n\t\t\tvariable: \"system.os\",\n\t\t\tvalue:    runtime.GOOS,\n\t\t},\n\t} {\n\t\tif val, ok := repl.Get(tc.variable); ok && !tc.notFound {\n\t\t\tif val != tc.value {\n\t\t\t\tt.Errorf(\"Expected value '%s' for key '%s' got '%s'\", tc.value, tc.variable, val)\n\t\t\t}\n\t\t} else if !tc.notFound {\n\t\t\tt.Errorf(\"Expected key '%s' to be recognized\", tc.variable)\n\t\t}\n\t}\n}\n\nfunc BenchmarkReplacer(b *testing.B) {\n\ttype testCase struct {\n\t\tname, input, empty string\n\t}\n\n\trep := testReplacer()\n\trep.Set(\"str\", \"a string\")\n\trep.Set(\"int\", 123.456)\n\n\tfor _, bm := range []testCase{\n\t\t{\n\t\t\tname:  \"no placeholder\",\n\t\t\tinput: `simple string`,\n\t\t},\n\t\t{\n\t\t\tname:  \"string replacement\",\n\t\t\tinput: `str={str}`,\n\t\t},\n\t\t{\n\t\t\tname:  \"int replacement\",\n\t\t\tinput: `int={int}`,\n\t\t},\n\t\t{\n\t\t\tname:  \"placeholder\",\n\t\t\tinput: `{\"json\": \"object\"}`,\n\t\t},\n\t\t{\n\t\t\tname:  \"escaped placeholder\",\n\t\t\tinput: `\\{\"json\": \\{\"nested\": \"{bar}\"\\}\\}`,\n\t\t},\n\t} {\n\t\tb.Run(bm.name, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\trep.ReplaceAll(bm.input, bm.empty)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc testReplacer() Replacer {\n\treturn Replacer{\n\t\tproviders: make([]replacementProvider, 0),\n\t\tstatic:    make(map[string]any),\n\t\tmapMutex:  &sync.RWMutex{},\n\t}\n}\n"
        },
        {
          "name": "service_windows.go",
          "type": "blob",
          "size": 1.53125,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"golang.org/x/sys/windows/svc\"\n\n\t\"github.com/caddyserver/caddy/v2/notify\"\n)\n\nfunc init() {\n\tisService, err := svc.IsWindowsService()\n\tif err != nil || !isService {\n\t\treturn\n\t}\n\n\t// Windows services always start in the system32 directory, try to\n\t// switch into the directory where the caddy executable is.\n\texecPath, err := os.Executable()\n\tif err == nil {\n\t\t_ = os.Chdir(filepath.Dir(execPath))\n\t}\n\n\tgo func() {\n\t\t_ = svc.Run(\"\", runner{})\n\t}()\n}\n\ntype runner struct{}\n\nfunc (runner) Execute(args []string, request <-chan svc.ChangeRequest, status chan<- svc.Status) (bool, uint32) {\n\tnotify.SetGlobalStatus(status)\n\tstatus <- svc.Status{State: svc.StartPending}\n\n\tfor {\n\t\treq := <-request\n\t\tswitch req.Cmd {\n\t\tcase svc.Interrogate:\n\t\t\tstatus <- req.CurrentStatus\n\t\tcase svc.Stop, svc.Shutdown:\n\t\t\tstatus <- svc.Status{State: svc.StopPending}\n\t\t\texitProcessFromSignal(\"SIGINT\")\n\t\t\treturn false, 0\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "sigtrap.go",
          "type": "blob",
          "size": 1.9853515625,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"os/signal\"\n\n\t\"go.uber.org/zap\"\n)\n\n// TrapSignals create signal/interrupt handlers as best it can for the\n// current OS. This is a rather invasive function to call in a Go program\n// that captures signals already, so in that case it would be better to\n// implement these handlers yourself.\nfunc TrapSignals() {\n\ttrapSignalsCrossPlatform()\n\ttrapSignalsPosix()\n}\n\n// trapSignalsCrossPlatform captures SIGINT or interrupt (depending\n// on the OS), which initiates a graceful shutdown. A second SIGINT\n// or interrupt will forcefully exit the process immediately.\nfunc trapSignalsCrossPlatform() {\n\tgo func() {\n\t\tshutdown := make(chan os.Signal, 1)\n\t\tsignal.Notify(shutdown, os.Interrupt)\n\n\t\tfor i := 0; true; i++ {\n\t\t\t<-shutdown\n\n\t\t\tif i > 0 {\n\t\t\t\tLog().Warn(\"force quit\", zap.String(\"signal\", \"SIGINT\"))\n\t\t\t\tos.Exit(ExitCodeForceQuit)\n\t\t\t}\n\n\t\t\tLog().Info(\"shutting down\", zap.String(\"signal\", \"SIGINT\"))\n\t\t\tgo exitProcessFromSignal(\"SIGINT\")\n\t\t}\n\t}()\n}\n\n// exitProcessFromSignal exits the process from a system signal.\nfunc exitProcessFromSignal(sigName string) {\n\tlogger := Log().With(zap.String(\"signal\", sigName))\n\texitProcess(context.TODO(), logger)\n}\n\n// Exit codes. Generally, you should NOT\n// automatically restart the process if the\n// exit code is ExitCodeFailedStartup (1).\nconst (\n\tExitCodeSuccess = iota\n\tExitCodeFailedStartup\n\tExitCodeForceQuit\n\tExitCodeFailedQuit\n)\n"
        },
        {
          "name": "sigtrap_nonposix.go",
          "type": "blob",
          "size": 0.6806640625,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build windows || plan9 || nacl || js\n\npackage caddy\n\nfunc trapSignalsPosix() {}\n"
        },
        {
          "name": "sigtrap_posix.go",
          "type": "blob",
          "size": 2.0625,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build !windows && !plan9 && !nacl && !js\n\npackage caddy\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/caddyserver/certmagic\"\n\t\"go.uber.org/zap\"\n)\n\n// trapSignalsPosix captures POSIX-only signals.\nfunc trapSignalsPosix() {\n\t// Ignore all SIGPIPE signals to prevent weird issues with systemd: https://github.com/dunglas/frankenphp/issues/1020\n\t// Docker/Moby has a similar hack: https://github.com/moby/moby/blob/d828b032a87606ae34267e349bf7f7ccb1f6495a/cmd/dockerd/docker.go#L87-L90\n\tsignal.Ignore(syscall.SIGPIPE)\n\n\tgo func() {\n\t\tsigchan := make(chan os.Signal, 1)\n\t\tsignal.Notify(sigchan, syscall.SIGTERM, syscall.SIGHUP, syscall.SIGQUIT, syscall.SIGUSR1, syscall.SIGUSR2)\n\n\t\tfor sig := range sigchan {\n\t\t\tswitch sig {\n\t\t\tcase syscall.SIGQUIT:\n\t\t\t\tLog().Info(\"quitting process immediately\", zap.String(\"signal\", \"SIGQUIT\"))\n\t\t\t\tcertmagic.CleanUpOwnLocks(context.TODO(), Log()) // try to clean up locks anyway, it's important\n\t\t\t\tos.Exit(ExitCodeForceQuit)\n\n\t\t\tcase syscall.SIGTERM:\n\t\t\t\tLog().Info(\"shutting down apps, then terminating\", zap.String(\"signal\", \"SIGTERM\"))\n\t\t\t\texitProcessFromSignal(\"SIGTERM\")\n\n\t\t\tcase syscall.SIGUSR1:\n\t\t\t\tLog().Info(\"not implemented\", zap.String(\"signal\", \"SIGUSR1\"))\n\n\t\t\tcase syscall.SIGUSR2:\n\t\t\t\tLog().Info(\"not implemented\", zap.String(\"signal\", \"SIGUSR2\"))\n\n\t\t\tcase syscall.SIGHUP:\n\t\t\t\t// ignore; this signal is sometimes sent outside of the user's control\n\t\t\t\tLog().Info(\"not implemented\", zap.String(\"signal\", \"SIGHUP\"))\n\t\t\t}\n\t\t}\n\t}()\n}\n"
        },
        {
          "name": "storage.go",
          "type": "blob",
          "size": 4.9873046875,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\n\t\"github.com/caddyserver/certmagic\"\n\t\"go.uber.org/zap\"\n)\n\n// StorageConverter is a type that can convert itself\n// to a valid, usable certmagic.Storage value. (The\n// value might be short-lived.) This interface allows\n// us to adapt any CertMagic storage implementation\n// into a consistent API for Caddy configuration.\ntype StorageConverter interface {\n\tCertMagicStorage() (certmagic.Storage, error)\n}\n\n// HomeDir returns the best guess of the current user's home\n// directory from environment variables. If unknown, \".\" (the\n// current directory) is returned instead, except GOOS=android,\n// which returns \"/sdcard\".\nfunc HomeDir() string {\n\thome := homeDirUnsafe()\n\tif home == \"\" && runtime.GOOS == \"android\" {\n\t\thome = \"/sdcard\"\n\t}\n\tif home == \"\" {\n\t\thome = \".\"\n\t}\n\treturn home\n}\n\n// homeDirUnsafe is a low-level function that returns\n// the user's home directory from environment\n// variables. Careful: if it cannot be determined, an\n// empty string is returned. If not accounting for\n// that case, use HomeDir() instead; otherwise you\n// may end up using the root of the file system.\nfunc homeDirUnsafe() string {\n\thome := os.Getenv(\"HOME\")\n\tif home == \"\" && runtime.GOOS == \"windows\" {\n\t\tdrive := os.Getenv(\"HOMEDRIVE\")\n\t\tpath := os.Getenv(\"HOMEPATH\")\n\t\thome = drive + path\n\t\tif drive == \"\" || path == \"\" {\n\t\t\thome = os.Getenv(\"USERPROFILE\")\n\t\t}\n\t}\n\tif home == \"\" && runtime.GOOS == \"plan9\" {\n\t\thome = os.Getenv(\"home\")\n\t}\n\treturn home\n}\n\n// AppConfigDir returns the directory where to store user's config.\n//\n// If XDG_CONFIG_HOME is set, it returns: $XDG_CONFIG_HOME/caddy.\n// Otherwise, os.UserConfigDir() is used; if successful, it appends\n// \"Caddy\" (Windows & Mac) or \"caddy\" (every other OS) to the path.\n// If it returns an error, the fallback path \"./caddy\" is returned.\n//\n// The config directory is not guaranteed to be different from\n// AppDataDir().\n//\n// Unlike os.UserConfigDir(), this function prefers the\n// XDG_CONFIG_HOME env var on all platforms, not just Unix.\n//\n// Ref: https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\nfunc AppConfigDir() string {\n\tif basedir := os.Getenv(\"XDG_CONFIG_HOME\"); basedir != \"\" {\n\t\treturn filepath.Join(basedir, \"caddy\")\n\t}\n\tbasedir, err := os.UserConfigDir()\n\tif err != nil {\n\t\tLog().Warn(\"unable to determine directory for user configuration; falling back to current directory\", zap.Error(err))\n\t\treturn \"./caddy\"\n\t}\n\tsubdir := \"caddy\"\n\tswitch runtime.GOOS {\n\tcase \"windows\", \"darwin\":\n\t\tsubdir = \"Caddy\"\n\t}\n\treturn filepath.Join(basedir, subdir)\n}\n\n// AppDataDir returns a directory path that is suitable for storing\n// application data on disk. It uses the environment for finding the\n// best place to store data, and appends a \"caddy\" or \"Caddy\" (depending\n// on OS and environment) subdirectory.\n//\n// For a base directory path:\n// If XDG_DATA_HOME is set, it returns: $XDG_DATA_HOME/caddy; otherwise,\n// on Windows it returns: %AppData%/Caddy,\n// on Mac: $HOME/Library/Application Support/Caddy,\n// on Plan9: $home/lib/caddy,\n// on Android: $HOME/caddy,\n// and on everything else: $HOME/.local/share/caddy.\n//\n// If a data directory cannot be determined, it returns \"./caddy\"\n// (this is not ideal, and the environment should be fixed).\n//\n// The data directory is not guaranteed to be different from AppConfigDir().\n//\n// Ref: https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\nfunc AppDataDir() string {\n\tif basedir := os.Getenv(\"XDG_DATA_HOME\"); basedir != \"\" {\n\t\treturn filepath.Join(basedir, \"caddy\")\n\t}\n\tswitch runtime.GOOS {\n\tcase \"windows\":\n\t\tappData := os.Getenv(\"AppData\")\n\t\tif appData != \"\" {\n\t\t\treturn filepath.Join(appData, \"Caddy\")\n\t\t}\n\tcase \"darwin\":\n\t\thome := homeDirUnsafe()\n\t\tif home != \"\" {\n\t\t\treturn filepath.Join(home, \"Library\", \"Application Support\", \"Caddy\")\n\t\t}\n\tcase \"plan9\":\n\t\thome := homeDirUnsafe()\n\t\tif home != \"\" {\n\t\t\treturn filepath.Join(home, \"lib\", \"caddy\")\n\t\t}\n\tcase \"android\":\n\t\thome := homeDirUnsafe()\n\t\tif home != \"\" {\n\t\t\treturn filepath.Join(home, \"caddy\")\n\t\t}\n\tdefault:\n\t\thome := homeDirUnsafe()\n\t\tif home != \"\" {\n\t\t\treturn filepath.Join(home, \".local\", \"share\", \"caddy\")\n\t\t}\n\t}\n\treturn \"./caddy\"\n}\n\n// ConfigAutosavePath is the default path to which the last config will be persisted.\nvar ConfigAutosavePath = filepath.Join(AppConfigDir(), \"autosave.json\")\n\n// DefaultStorage is Caddy's default storage module.\nvar DefaultStorage = &certmagic.FileStorage{Path: AppDataDir()}\n"
        },
        {
          "name": "usagepool.go",
          "type": "blob",
          "size": 6.564453125,
          "content": "// Copyright 2015 Matthew Holt and The Caddy Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage caddy\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\n// UsagePool is a thread-safe map that pools values\n// based on usage (reference counting). Values are\n// only inserted if they do not already exist. There\n// are two ways to add values to the pool:\n//\n//  1. LoadOrStore will increment usage and store the\n//     value immediately if it does not already exist.\n//  2. LoadOrNew will atomically check for existence\n//     and construct the value immediately if it does\n//     not already exist, or increment the usage\n//     otherwise, then store that value in the pool.\n//     When the constructed value is finally deleted\n//     from the pool (when its usage reaches 0), it\n//     will be cleaned up by calling Destruct().\n//\n// The use of LoadOrNew allows values to be created\n// and reused and finally cleaned up only once, even\n// though they may have many references throughout\n// their lifespan. This is helpful, for example, when\n// sharing thread-safe io.Writers that you only want\n// to open and close once.\n//\n// There is no way to overwrite existing keys in the\n// pool without first deleting it as many times as it\n// was stored. Deleting too many times will panic.\n//\n// The implementation does not use a sync.Pool because\n// UsagePool needs additional atomicity to run the\n// constructor functions when creating a new value when\n// LoadOrNew is used. (We could probably use sync.Pool\n// but we'd still have to layer our own additional locks\n// on top.)\n//\n// An empty UsagePool is NOT safe to use; always call\n// NewUsagePool() to make a new one.\ntype UsagePool struct {\n\tsync.RWMutex\n\tpool map[any]*usagePoolVal\n}\n\n// NewUsagePool returns a new usage pool that is ready to use.\nfunc NewUsagePool() *UsagePool {\n\treturn &UsagePool{\n\t\tpool: make(map[any]*usagePoolVal),\n\t}\n}\n\n// LoadOrNew loads the value associated with key from the pool if it\n// already exists. If the key doesn't exist, it will call construct\n// to create a new value and then stores that in the pool. An error\n// is only returned if the constructor returns an error. The loaded\n// or constructed value is returned. The loaded return value is true\n// if the value already existed and was loaded, or false if it was\n// newly constructed.\nfunc (up *UsagePool) LoadOrNew(key any, construct Constructor) (value any, loaded bool, err error) {\n\tvar upv *usagePoolVal\n\tup.Lock()\n\tupv, loaded = up.pool[key]\n\tif loaded {\n\t\tatomic.AddInt32(&upv.refs, 1)\n\t\tup.Unlock()\n\t\tupv.RLock()\n\t\tvalue = upv.value\n\t\terr = upv.err\n\t\tupv.RUnlock()\n\t} else {\n\t\tupv = &usagePoolVal{refs: 1}\n\t\tupv.Lock()\n\t\tup.pool[key] = upv\n\t\tup.Unlock()\n\t\tvalue, err = construct()\n\t\tif err == nil {\n\t\t\tupv.value = value\n\t\t} else {\n\t\t\tupv.err = err\n\t\t\tup.Lock()\n\t\t\t// this *should* be safe, I think, because we have a\n\t\t\t// write lock on upv, but we might also need to ensure\n\t\t\t// that upv.err is nil before doing this, since we\n\t\t\t// released the write lock on up during construct...\n\t\t\t// but then again it's also after midnight...\n\t\t\tdelete(up.pool, key)\n\t\t\tup.Unlock()\n\t\t}\n\t\tupv.Unlock()\n\t}\n\treturn\n}\n\n// LoadOrStore loads the value associated with key from the pool if it\n// already exists, or stores it if it does not exist. It returns the\n// value that was either loaded or stored, and true if the value already\n// existed and was loaded, false if the value didn't exist and was stored.\nfunc (up *UsagePool) LoadOrStore(key, val any) (value any, loaded bool) {\n\tvar upv *usagePoolVal\n\tup.Lock()\n\tupv, loaded = up.pool[key]\n\tif loaded {\n\t\tatomic.AddInt32(&upv.refs, 1)\n\t\tup.Unlock()\n\t\tupv.Lock()\n\t\tif upv.err == nil {\n\t\t\tvalue = upv.value\n\t\t} else {\n\t\t\tupv.value = val\n\t\t\tupv.err = nil\n\t\t}\n\t\tupv.Unlock()\n\t} else {\n\t\tupv = &usagePoolVal{refs: 1, value: val}\n\t\tup.pool[key] = upv\n\t\tup.Unlock()\n\t\tvalue = val\n\t}\n\treturn\n}\n\n// Range iterates the pool similarly to how sync.Map.Range() does:\n// it calls f for every key in the pool, and if f returns false,\n// iteration is stopped. Ranging does not affect usage counts.\n//\n// This method is somewhat naive and acquires a read lock on the\n// entire pool during iteration, so do your best to make f() really\n// fast, m'kay?\nfunc (up *UsagePool) Range(f func(key, value any) bool) {\n\tup.RLock()\n\tdefer up.RUnlock()\n\tfor key, upv := range up.pool {\n\t\tupv.RLock()\n\t\tif upv.err != nil {\n\t\t\tupv.RUnlock()\n\t\t\tcontinue\n\t\t}\n\t\tval := upv.value\n\t\tupv.RUnlock()\n\t\tif !f(key, val) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// Delete decrements the usage count for key and removes the\n// value from the underlying map if the usage is 0. It returns\n// true if the usage count reached 0 and the value was deleted.\n// It panics if the usage count drops below 0; always call\n// Delete precisely as many times as LoadOrStore.\nfunc (up *UsagePool) Delete(key any) (deleted bool, err error) {\n\tup.Lock()\n\tupv, ok := up.pool[key]\n\tif !ok {\n\t\tup.Unlock()\n\t\treturn false, nil\n\t}\n\trefs := atomic.AddInt32(&upv.refs, -1)\n\tif refs == 0 {\n\t\tdelete(up.pool, key)\n\t\tup.Unlock()\n\t\tupv.RLock()\n\t\tval := upv.value\n\t\tupv.RUnlock()\n\t\tif destructor, ok := val.(Destructor); ok {\n\t\t\terr = destructor.Destruct()\n\t\t}\n\t\tdeleted = true\n\t} else {\n\t\tup.Unlock()\n\t\tif refs < 0 {\n\t\t\tpanic(fmt.Sprintf(\"deleted more than stored: %#v (usage: %d)\",\n\t\t\t\tupv.value, upv.refs))\n\t\t}\n\t}\n\treturn\n}\n\n// References returns the number of references (count of usages) to a\n// key in the pool, and true if the key exists, or false otherwise.\nfunc (up *UsagePool) References(key any) (int, bool) {\n\tup.RLock()\n\tupv, loaded := up.pool[key]\n\tup.RUnlock()\n\tif loaded {\n\t\t// I wonder if it'd be safer to read this value during\n\t\t// our lock on the UsagePool... guess we'll see...\n\t\trefs := atomic.LoadInt32(&upv.refs)\n\t\treturn int(refs), true\n\t}\n\treturn 0, false\n}\n\n// Constructor is a function that returns a new value\n// that can destruct itself when it is no longer needed.\ntype Constructor func() (Destructor, error)\n\n// Destructor is a value that can clean itself up when\n// it is deallocated.\ntype Destructor interface {\n\tDestruct() error\n}\n\ntype usagePoolVal struct {\n\trefs  int32 // accessed atomically; must be 64-bit aligned for 32-bit systems\n\tvalue any\n\terr   error\n\tsync.RWMutex\n}\n"
        }
      ]
    }
  ]
}