{
  "metadata": {
    "timestamp": 1736568166433,
    "page": 2,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gin-gonic/gin",
      "stars": 79810,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.107421875,
          "content": "vendor/*\n!vendor/vendor.json\ncoverage.out\ncount.out\ntest\nprofile.out\ntmp.out\n\n# Develop tools\n.idea/\n.vscode/\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 1.2607421875,
          "content": "run:\n  timeout: 5m\nlinters:\n  enable:\n    - asciicheck\n    - dogsled\n    - durationcheck\n    - errcheck\n    - errorlint\n    - exportloopref\n    - gci\n    - gofmt\n    - goimports\n    - gosec\n    - misspell\n    - nakedret\n    - nilerr\n    - nolintlint\n    - perfsprint\n    - revive\n    - testifylint\n    - usestdlibvars\n    - wastedassign\n\nlinters-settings:\n  gosec:\n    # To select a subset of rules to run.\n    # Available rules: https://github.com/securego/gosec#available-rules\n    # Default: [] - means include all rules\n    includes:\n      - G102\n      - G106\n      - G108\n      - G109\n      - G111\n      - G112\n      - G201\n      - G203\n  perfsprint:\n    err-error: true\n    errorf: true\n    fiximports: true\n    int-conversion: true\n    sprintf1: true\n    strconcat: true\n  testifylint:\n    enable-all: true\n\nissues:\n  exclude-rules:\n    - linters:\n        - structcheck\n        - unused\n      text: \"`data` is unused\"\n    - linters:\n        - staticcheck\n      text: \"SA1019:\"\n    - linters:\n        - revive\n      text: \"var-naming:\"\n    - linters:\n        - revive\n      text: \"exported:\"\n    - path: _test\\.go\n      linters:\n        - gosec # security is not make sense in tests\n    - linters:\n        - revive\n      path: _test\\.go\n    - path: gin.go\n      linters:\n        - gci\n"
        },
        {
          "name": ".goreleaser.yaml",
          "type": "blob",
          "size": 1.66015625,
          "content": "project_name: gin\n\nbuilds:\n  - # If true, skip the build.\n    # Useful for library projects.\n    # Default is false\n    skip: true\n\nchangelog:\n  # Set it to true if you wish to skip the changelog generation.\n  # This may result in an empty release notes on GitHub/GitLab/Gitea.\n  disable: false\n\n  # Changelog generation implementation to use.\n  #\n  # Valid options are:\n  # - `git`: uses `git log`;\n  # - `github`: uses the compare GitHub API, appending the author login to the changelog.\n  # - `gitlab`: uses the compare GitLab API, appending the author name and email to the changelog.\n  # - `github-native`: uses the GitHub release notes generation API, disables the groups feature.\n  #\n  # Defaults to `git`.\n  use: github\n\n  # Sorts the changelog by the commit's messages.\n  # Could either be asc, desc or empty\n  # Default is empty\n  sort: asc\n\n  # Group commits messages by given regex and title.\n  # Order value defines the order of the groups.\n  # Proving no regex means all commits will be grouped under the default group.\n  # Groups are disabled when using github-native, as it already groups things by itself.\n  #\n  # Default is no groups.\n  groups:\n    - title: Features\n      regexp: \"^.*feat[(\\\\w)]*:+.*$\"\n      order: 0\n    - title: \"Bug fixes\"\n      regexp: \"^.*fix[(\\\\w)]*:+.*$\"\n      order: 1\n    - title: \"Enhancements\"\n      regexp: \"^.*chore[(\\\\w)]*:+.*$\"\n      order: 2\n    - title: \"Refactor\"\n      regexp: \"^.*refactor[(\\\\w)]*:+.*$\"\n      order: 3\n    - title: \"Build process updates\"\n      regexp: ^.*?(build|ci)(\\(.+\\))??!?:.+$\n      order: 4\n    - title: \"Documentation updates\"\n      regexp: ^.*?docs?(\\(.+\\))??!?:.+$\n      order: 4\n    - title: Others\n      order: 999\n"
        },
        {
          "name": "AUTHORS.md",
          "type": "blob",
          "size": 15.9033203125,
          "content": "List of all the awesome people working to make Gin the best Web Framework in Go.\n\n## gin 1.x series authors\n\n**Gin Core Team:** Bo-Yi Wu (@appleboy), thinkerou (@thinkerou), Javier Provecho (@javierprovecho)\n\n## gin 0.x series authors\n\n**Maintainers:** Manu Martinez-Almeida (@manucorporat), Javier Provecho (@javierprovecho)\n\n------\n\nPeople and companies, who have contributed, in alphabetical order.\n\n- 178inaba <178inaba@users.noreply.github.com>\n- A. F <hello@clivern.com>\n- ABHISHEK SONI <abhishek.rocks26@gmail.com>\n- Abhishek Chanda <achanda@users.noreply.github.com>\n- Abner Chen <houjunchen@gmail.com>\n- AcoNCodes <acongame@gmail.com>\n- Adam Dratwinski <adam.dratwinski@gmail.com>\n- Adam Mckaig <adam.mckaig@gmail.com>\n- Adam Zielinski <MusicAdam@users.noreply.github.com>\n- Adonis <donileo@gmail.com>\n- Alan Wang <azzwacb9001@126.com>\n- Albin Gilles <gilles.albin@gmail.com>\n- Aleksandr Didenko <aa.didenko@yandex.ru>\n- Alessandro (Ale) Segala <43508+ItalyPaleAle@users.noreply.github.com>\n- Alex <AWulkan@users.noreply.github.com>\n- Alexander <alexanderchenmh@gmail.com>\n- Alexander Lokhman <alex.lokhman@gmail.com>\n- Alexander Melentyev <55826637+alexander-melentyev@users.noreply.github.com>\n- Alexander Nyquist <nyquist.alexander@gmail.com>\n- Allen Ren <kulong0105@gmail.com>\n- AllinGo <tanhp@outlook.com>\n- Ammar Bandukwala <ammar@ammar.io>\n- An Xiao (Luffy) <hac@zju.edu.cn>\n- Andre Dublin <81dublin@gmail.com>\n- Andrew Szeto <github@jabagawee.com>\n- Andrey Abramov <andreyabramov.aaa@gmail.com>\n- Andrey Nering <andrey.nering@gmail.com>\n- Andrey Smirnov <Smirnov.Andrey@gmail.com>\n- Andrii Bubis <firstrow@gmail.com>\n- Andr√© Bazaglia <bazaglia@users.noreply.github.com>\n- Andy Pan <panjf2000@gmail.com>\n- Antoine GIRARD <sapk@users.noreply.github.com>\n- Anup Kumar Panwar <1anuppanwar@gmail.com>\n- Aravinth Sundaram <gosh.aravind@gmail.com>\n- Artem <horechek@gmail.com>\n- Ashwani <ashwanisharma686@gmail.com>\n- Aurelien Regat-Barrel <arb@cyberkarma.net>\n- Austin Heap <me@austinheap.com>\n- Barnabus <jbampton@users.noreply.github.com>\n- Bo-Yi Wu <appleboy.tw@gmail.com>\n- Boris Borshevsky <BorisBorshevsky@gmail.com>\n- Boyi Wu <p581581@gmail.com>\n- BradyBromley <51128276+BradyBromley@users.noreply.github.com>\n- Brendan Fosberry <brendan@shopkeep.com>\n- Brian Wigginton <brianwigginton@gmail.com>\n- Carlos Eduardo <carlosedp@gmail.com>\n- Chad Russell <chaddouglasrussell@gmail.com>\n- Charles <cxjava@gmail.com>\n- Christian Muehlhaeuser <muesli@gmail.com>\n- Christian Persson <saser@live.se>\n- Christopher Harrington <ironiridis@gmail.com>\n- Damon Zhao <yijun.zhao@outlook.com>\n- Dan Markham <dmarkham@gmail.com>\n- Dang Nguyen <hoangdang.me@gmail.com>\n- Daniel Krom <kromdan@gmail.com>\n- Daniel M. Lambea <dmlambea@gmail.com>\n- Danieliu <liudanking@gmail.com>\n- David Irvine <aviddiviner@gmail.com>\n- David Zhang <crispgm@gmail.com>\n- Davor Kapsa <dvrkps@users.noreply.github.com>\n- DeathKing <DeathKing@users.noreply.github.com>\n- Dennis Cho <47404603+forest747@users.noreply.github.com>\n- Dmitry Dorogin <dmirogin@ya.ru>\n- Dmitry Kutakov <vkd.castle@gmail.com>\n- Dmitry Sedykh <dmitrys@d3h.local>\n- Don2Quixote <35610661+Don2Quixote@users.noreply.github.com>\n- Donn Pebe <iam@donnpebe.com>\n- Dustin Decker <dustindecker@protonmail.com>\n- Eason Lin <easonlin404@gmail.com>\n- Edward Betts <edward@4angle.com>\n- Egor Seredin <4819888+agmt@users.noreply.github.com>\n- Emmanuel Goh <emmanuel@visenze.com>\n- Equim <sayaka@ekyu.moe>\n- Eren A. Akyol <eren@redmc.me>\n- Eric_Lee <xplzv@126.com>\n- Erik Bender <erik.bender@develerik.dev>\n- Ethan Kan <ethankan@neoplot.com>\n- Evgeny Persienko <e.persienko@office.ngs.ru>\n- Faisal Alam <ifaisalalam@gmail.com>\n- Fareed Dudhia <fareeddudhia@googlemail.com>\n- Filip Figiel <figiel.filip@gmail.com>\n- Florian Polster <couchpolster@icqmail.com>\n- Frank Bille <github@frankbille.dk>\n- Franz Bettag <franz@bett.ag>\n- Ganlv <ganlvtech@users.noreply.github.com>\n- Gaozhen Ying <yinggaozhen@hotmail.com>\n- George Gabolaev <gabolaev98@gmail.com>\n- George Kirilenko <necryin@users.noreply.github.com>\n- Georges Varouchas <georges.varouchas@gmail.com>\n- Gordon Tyler <gordon@doxxx.net>\n- Harindu Perera <harinduenator@gmail.com>\n- Helios <674876158@qq.com>\n- Henry Kwan <piengeng@users.noreply.github.com>\n- Henry Yee <henry@yearning.io>\n- Himanshu Mishra <OrkoHunter@users.noreply.github.com>\n- Hiroyuki Tanaka <h.tanaka.0325@gmail.com>\n- Ibraheem Ahmed <ibrah1440@gmail.com>\n- Ignacio Galindo <joiggama@gmail.com>\n- Igor H. Vieira <zignd.igor@gmail.com>\n- Ildar1111 <54001462+Ildar1111@users.noreply.github.com>\n- Iskander (Alex) Sharipov <iskander.sharipov@intel.com>\n- Ismail Gjevori <isgjevori@protonmail.com>\n- Ivan Chen <allenivan@gmail.com>\n- JINNOUCHI Yasushi <delphinus@remora.cx>\n- James Pettyjohn <japettyjohn@users.noreply.github.com>\n- Jamie Stackhouse <jamie.stackhouse@redspace.com>\n- Jason Lee <jawc@hotmail.com>\n- Javier Provecho <j.provecho@dartekstudios.com>\n- Javier Provecho <javier.provecho@bq.com>\n- Javier Provecho <javiertitan@gmail.com>\n- Javier Provecho Fernandez <j.provecho@dartekstudios.com>\n- Javier Provecho Fernandez <javiertitan@gmail.com>\n- Jean-Christophe Lebreton <jclebreton@gmail.com>\n- Jeff <laojianzi1994@gmail.com>\n- Jeremy Loy <jeremy.b.loy@icloud.com>\n- Jim Filippou <p3160253@aueb.gr>\n- Jimmy Pettersson <jimmy@expertmaker.com>\n- John Bampton <jbampton@users.noreply.github.com>\n- Johnny Dallas <johnnydallas0308@gmail.com>\n- Johnny Dallas <theonlyjohnny@theonlyjohnny.sh>\n- Jonathan (JC) Chen <jc@dijonkitchen.org>\n- Josep Jesus Bigorra Algaba <42377845+averageflow@users.noreply.github.com>\n- Josh Horowitz <joshua.m.horowitz@gmail.com>\n- Joshua Loper <josh.el3@gmail.com>\n- Julien Schmidt <github@julienschmidt.com>\n- Jun Kimura <jksmphone@gmail.com>\n- Justin Beckwith <justin.beckwith@gmail.com>\n- Justin Israel <justinisrael@gmail.com>\n- Justin Mayhew <mayhew@live.ca>\n- J√©r√¥me Laforge <jerome-laforge@users.noreply.github.com>\n- Kacper BƒÖk <56700396+53jk1@users.noreply.github.com>\n- Kamron Batman <kamronbatman@users.noreply.github.com>\n- Kane Rogers <kane@cleanstream.com.au>\n- Kaushik Neelichetty <kaushikneelichetty6132@gmail.com>\n- Keiji Yoshida <yoshida.keiji.84@gmail.com>\n- Kel Cecil <kel.cecil@listhub.com>\n- Kevin Mulvey <kmulvey@linux.com>\n- Kevin Zhu <ipandtcp@gmail.com>\n- Kirill Motkov <motkov.kirill@gmail.com>\n- Klemen Sever <ksever@student.42.fr>\n- Kristoffer A. Iversen <kristoffer.a.iversen@gmail.com>\n- Krzysztof Szafra≈Ñski <k.p.szafranski@gmail.com>\n- Kumar McMillan <kumar.mcmillan@gmail.com>\n- Kyle Mcgill <email@kylescottmcgill.com>\n- Lanco <35420416+lancoLiu@users.noreply.github.com>\n- Levi Olson <olson.levi@gmail.com>\n- Lin Kao-Yuan <mosdeo@gmail.com>\n- Linus Unneb√§ck <linus@folkdatorn.se>\n- Lucas Clemente <lucas@clemente.io>\n- Ludwig Valda Vasquez <bredov@gmail.com>\n- Luis GG <lggomez@users.noreply.github.com>\n- MW Lim <williamchange@gmail.com>\n- Maksimov Sergey <konjoot@gmail.com>\n- Manjusaka <lizheao940510@gmail.com>\n- Manu MA <manu.mtza@gmail.com>\n- Manu MA <manu.valladolid@gmail.com>\n- Manu Mtz-Almeida <manu.valladolid@gmail.com>\n- Manu Mtz.-Almeida <manu.valladolid@gmail.com>\n- Manuel Alonso <manuelalonso@invisionapp.com>\n- Mara Kim <hacker.root@gmail.com>\n- Mario Kostelac <mario@intercom.io>\n- Martin Karlsch <martin@karlsch.com>\n- Matt Newberry <mnewberry@opentable.com>\n- Matt Williams <gh@mattyw.net>\n- Matthieu MOREL <mmorel-35@users.noreply.github.com>\n- Max Hilbrunner <mhilbrunner@users.noreply.github.com>\n- Maxime Soul√© <btik-git@scoubidou.com>\n- MetalBreaker <johnymichelson@gmail.com>\n- Michael Puncel <mpuncel@squareup.com>\n- MichaelDeSteven <51652084+MichaelDeSteven@users.noreply.github.com>\n- Mike <38686456+icy4ever@users.noreply.github.com>\n- Mike Stipicevic <mst@ableton.com>\n- Miki Tebeka <miki.tebeka@gmail.com>\n- Miles <MilesLin@users.noreply.github.com>\n- Mirza Ceric <mirza.ceric@b2match.com>\n- Mykyta Semenistyi <nikeiwe@gmail.com>\n- Naoki Takano <honten@tinkermode.com>\n- Ngalim Siregar <ngalim.siregar@gmail.com>\n- Ni Hao <supernihaooo@qq.com>\n- Nick Gerakines <nick@gerakines.net>\n- Nikifor Seryakov <nikandfor@gmail.com>\n- Notealot <714804968@qq.com>\n- Olivier Mengu√© <dolmen@cpan.org>\n- Olivier Robardet <orobardet@users.noreply.github.com>\n- Pablo Moncada <pablo.moncada@bq.com>\n- Pablo Moncada <pmoncadaisla@gmail.com>\n- Panmax <967168@qq.com>\n- Peperoncino <2wua4nlyi@gmail.com>\n- Philipp Meinen <philipp@bind.ch>\n- Pierre Massat <pierre@massat.io>\n- Qt <golang.chen@gmail.com>\n- Quentin ROYER <aydendevg@gmail.com>\n- README Bot <35302948+codetriage-readme-bot@users.noreply.github.com>\n- Rafal Zajac <rzajac@gmail.com>\n- Rahul Datta Roy <rahuldroy@users.noreply.github.com>\n- Rajiv Kilaparti <rajivk085@gmail.com>\n- Raphael Gavache <raphael.gavache@datadoghq.com>\n- Ray Rodriguez <rayrod2030@gmail.com>\n- Regner Blok-Andersen <shadowdf@gmail.com>\n- Remco <remco@dutchcoders.io>\n- Rex Lee(Êùé‰øä) <duguying2008@gmail.com>\n- Richard Lee <dlackty@gmail.com>\n- Riverside <wangyb65@gmail.com>\n- Robert Wilkinson <wilkinson.robert.a@gmail.com>\n- Rogier Lommers <rogier@lommers.org>\n- Rohan Pai <me@rohanpai.com>\n- Romain Beuque <rbeuque74@gmail.com>\n- Roman Belyakovsky <ihryamzik@gmail.com>\n- Roman Zaynetdinov <627197+zaynetro@users.noreply.github.com>\n- Roman Zaynetdinov <roman.zaynetdinov@lekane.com>\n- Ronald Petty <ronald.petty@rx-m.com>\n- Ross Wolf <31489089+rw-access@users.noreply.github.com>\n- Roy Lou <roylou@gmail.com>\n- Rubi <14269809+codenoid@users.noreply.github.com>\n- Ryan <46182144+ryanker@users.noreply.github.com>\n- Ryan J. Yoder <me@ryanjyoder.com>\n- SRK.Lyu <superalsrk@gmail.com>\n- Sai <sairoutine@gmail.com>\n- Samuel Abreu <sdepaula@gmail.com>\n- Santhosh Kumar <santhoshkumarr1096@gmail.com>\n- Sasha Melentyev <sasha@melentyev.io>\n- Sasha Myasoedov <msoedov@gmail.com>\n- Segev Finer <segev208@gmail.com>\n- Sergey Egorov <egorovhome@gmail.com>\n- Sergey Fedchenko <seregayoga@bk.ru>\n- Sergey Gonimar <sergey.gonimar@gmail.com>\n- Sergey Ponomarev <me@sergey-ponomarev.ru>\n- Serica <943914044@qq.com>\n- Shamus Taylor <Shamus03@me.com>\n- Shilin Wang <jarvisfironman@gmail.com>\n- Shuo <openset.wang@gmail.com>\n- Skuli Oskarsson <skuli@codeiak.io>\n- Snawoot <vladislav-ex-github@vm-0.com>\n- Sridhar Ratnakumar <srid@srid.ca>\n- Steeve Chailloux <steeve@chaahk.com>\n- Sudhir Mishra <sudhirxps@gmail.com>\n- Suhas Karanth <sudo-suhas@users.noreply.github.com>\n- TaeJun Park <miking38@gmail.com>\n- Tatsuya Hoshino <tatsuya7.hoshino7@gmail.com>\n- Tevic <tevic.tt@gmail.com>\n- Tevin Jeffrey <tev.jeffrey@gmail.com>\n- The Gitter Badger <badger@gitter.im>\n- Thibault Jamet <tjamet@users.noreply.github.com>\n- Thomas Boerger <thomas@webhippie.de>\n- Thomas Schaffer <loopfz@gmail.com>\n- Tommy Chu <tommychu2256@gmail.com>\n- Tudor Roman <tudurom@gmail.com>\n- Uwe Dauernheim <djui@users.noreply.github.com>\n- Valentine Oragbakosi <valentine13400@gmail.com>\n- Vas N <pnvasanth@users.noreply.github.com>\n- Vasilyuk Vasiliy <By-Vasiliy@users.noreply.github.com>\n- Victor Castell <victor@victorcastell.com>\n- Vince Yuan <vince.yuan@gmail.com>\n- Vyacheslav Dubinin <vyacheslav.dubinin@gmail.com>\n- Waynerv <ampedee@gmail.com>\n- Weilin Shi <934587911@qq.com>\n- Xudong Cai <fifsky@gmail.com>\n- Yasuhiro Matsumoto <mattn.jp@gmail.com>\n- Yehezkiel Syamsuhadi <ybs@ybs.im>\n- Yoshiki Nakagawa <yyoshiki41@gmail.com>\n- Yoshiyuki Kinjo <yskkin+github@gmail.com>\n- Yue Yang <g1enyy0ung@gmail.com>\n- ZYunH <zyunhjob@163.com>\n- Zach Newburgh <zach.newburgh@gmail.com>\n- Zasda Yusuf Mikail <zasdaym@gmail.com>\n- ZhangYunHao <zyunhjob@163.com>\n- ZhiFeng Hu <hufeng1987@gmail.com>\n- Zhu Xi <zhuxi910511@163.com>\n- a2tt <usera2tt@gmail.com>\n- ahuigo <1781999+ahuigo@users.noreply.github.com>\n- ali <anio@users.noreply.github.com>\n- aljun <salameryy@163.com>\n- andrea <crypto.andrea@protonmail.ch>\n- andriikushch <andrii.kushch@gmail.com>\n- anoty <anjunyou@foxmail.com>\n- awkj <hzzbiu@gmail.com>\n- axiaoxin <254606826@qq.com>\n- bbiao <bbbiao@gmail.com>\n- bestgopher <84328409@qq.com>\n- betahu <zhong.wenhuang@foxmail.com>\n- bigwheel <k.bigwheel+eng@gmail.com>\n- bn4t <17193640+bn4t@users.noreply.github.com>\n- bullgare <bullgare@gmail.com>\n- chainhelen <chainhelen@gmail.com>\n- chenyang929 <chenyang929code@gmail.com>\n- chriswhelix <chris.williams@helix.com>\n- collinmsn <4130944@qq.com>\n- cssivision <cssivision@gmail.com>\n- danielalves <alves.lopes.dan@gmail.com>\n- delphinus <delphinus@remora.cx>\n- dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>\n- dickeyxxx <jeff@dickeyxxx.com>\n- edebernis <emeric.debernis@gmail.com>\n- error10 <error@ioerror.us>\n- esplo <esplo@users.noreply.github.com>\n- eudore <30709860+eudore@users.noreply.github.com>\n- ffhelicopter <32922889+ffhelicopter@users.noreply.github.com>\n- filikos <11477309+filikos@users.noreply.github.com>\n- forging2012 <forging2012@users.noreply.github.com>\n- goqihoo <goqihoo@gmail.com>\n- grapeVine <treeui.old@gmail.com>\n- guonaihong <guonaihong@qq.com>\n- heige <daheige@users.noreply.github.com>\n- heige <zhuwei313@hotmail.com>\n- hellojukay <hellojukay@163.com>\n- henrylee2cn <henrylee2cn@gmail.com>\n- htobenothing <htobenothing@gmail.com>\n- iamhesir <78344375+iamhesir@users.noreply.github.com>\n- ijaa <kailiu2013@gmail.com>\n- ishanray <ishan.iipm@gmail.com>\n- ishanray <ishanray@users.noreply.github.com>\n- itcloudy <272685110@qq.com>\n- jarodsong6 <jarodsong6@gmail.com>\n- jasonrhansen <jasonrodneyhansen@gmail.com>\n- jincheng9 <perfume0607@gmail.com>\n- joeADSP <75027008+joeADSP@users.noreply.github.com>\n- junfengye <junfeng.yejf@gmail.com>\n- kaiiak <aNxFi37X@outlook.com>\n- kebo <kevinke2020@outlook.com>\n- keke <19yamashita15@gmail.com>\n- kishor kunal raj <68464660+kishorkunal-raj@users.noreply.github.com>\n- kyledinh <kyledinh@gmail.com>\n- lantw44 <lantw44@gmail.com>\n- likakuli <1154584512@qq.com>\n- linfangrong <linfangrong.liuxin@qq.com>\n- linzi <873804682@qq.com>\n- llgoer <yanghuxiao@vip.qq.com>\n- long-road <13412081338@163.com>\n- mbesancon <mathieu.besancon@gmail.com>\n- mehdy <mehdy.khoshnoody@gmail.com>\n- metal A-wing <freedom.awing.777@gmail.com>\n- micanzhang <micanzhang@gmail.com>\n- minarc <ragnhildmowinckel@gmail.com>\n- mllu <mornlyn@gmail.com>\n- mopemoepe <yutaka.matsubara@gmail.com>\n- msoedov <msoedov@gmail.com>\n- mstmdev <mstmdev@gmail.com>\n- novaeye <fcoffee@gmail.com>\n- olebedev <oolebedev@gmail.com>\n- phithon <phith0n@users.noreply.github.com>\n- pjgg <pablo.gonzalez.granados@gmail.com>\n- qm012 <67568757+qm012@users.noreply.github.com>\n- raymonder jin <rayjingithub@gmail.com>\n- rns <ruslan.shvedov@gmail.com>\n- root@andrea:~# <crypto.andrea@protonmail.ch>\n- sekky0905 <20237968+sekky0905@users.noreply.github.com>\n- senhtry <w169q169@gmail.com>\n- shadrus <shadrus@gmail.com>\n- silasb <silas.baronda@gmail.com>\n- solos <lxl1217@gmail.com>\n- songjiayang <songjiayang@users.noreply.github.com>\n- sope <shenshouer@163.com>\n- srt180 <30768686+srt180@users.noreply.github.com>\n- stackerzzq <foo_stacker@yeah.net>\n- sunshineplan <sunshineplan@users.noreply.github.com>\n- syssam <s.y.s.sam.sys@gmail.com>\n- techjanitor <puntme@gmail.com>\n- techjanitor <techjanitor@users.noreply.github.com>\n- thinkerou <thinkerou@gmail.com>\n- thinkgo <49174849+thinkgos@users.noreply.github.com>\n- tsirolnik <tsirolnik@users.noreply.github.com>\n- tyltr <31768692+tylitianrui@users.noreply.github.com>\n- vinhha96 <anhvinha1@gmail.com>\n- voidman <retmain@foxmail.com>\n- vz <vzvway@gmail.com>\n- wei <wei840222@gmail.com>\n- weibaohui <weibaohui@yeah.net>\n- whirosan <whirosan@users.noreply.github.com>\n- willnewrelic <will@newrelic.com>\n- wssccc <wssccc@qq.com>\n- wuhuizuo <wuhuizuo@126.com>\n- xyb <xyb4638@gmail.com>\n- y-yagi <yuuji.yaginuma@gmail.com>\n- yiranzai <wuqingdzx@gmail.com>\n- youzeliang <youzel@126.com>\n- yugu <chenzilong_1227@foxmail.com>\n- yuyabe <yuyabee@gmail.com>\n- zebozhuang <zebozhuang@163.com>\n- zero11-0203 <93071220+zero11-0203@users.noreply.github.com>\n- zesani <7sin@outlook.co.th>\n- zhanweidu <zhanweidu@163.com>\n- zhing <zqwillseven@gmail.com>\n- ziheng <zihenglv@gmail.com>\n- zzjin <zzjin@users.noreply.github.com>\n- Ê£Æ ÂÑ™Â§™ <59682979+uta-mori@users.noreply.github.com>\n- Êù∞Âì• <858806258@qq.com>\n- Ê∂õÂèî <hi@taoshu.in>\n- Â∏ÇÊ∞ë233 <mengrenxiong@gmail.com>\n- Â∞πÂÆùÂº∫ <wmdandme@gmail.com>\n- Ê¢¶Ê∫™Á¨îË∞à <loongmxbt@gmail.com>\n- È£ûÈõ™Êó†ÊÉÖ <ls8707@gmail.com>\n- ÂØªÂØªËßÖËßÖÁöÑGopher <zoujh99@qq.com>\n"
        },
        {
          "name": "BENCHMARKS.md",
          "type": "blob",
          "size": 52.8994140625,
          "content": "\n# Benchmark System\n\n**VM HOST:** Travis\n**Machine:** Ubuntu 16.04.6 LTS x64\n**Date:** May 04th, 2020\n**Version:** Gin v1.6.3\n**Go Version:** 1.14.2 linux/amd64\n**Source:** [Go HTTP Router Benchmark](https://github.com/gin-gonic/go-http-routing-benchmark)\n**Result:** [See the gist](https://gist.github.com/appleboy/b5f2ecfaf50824ae9c64dcfb9165ae5e) or [Travis result](https://travis-ci.org/github/gin-gonic/go-http-routing-benchmark/jobs/682947061)\n\n## Static Routes: 157\n\n```sh\nGin: 34936 Bytes\n\nHttpServeMux: 14512 Bytes\nAce: 30680 Bytes\nAero: 34536 Bytes\nBear: 30456 Bytes\nBeego: 98456 Bytes\nBone: 40224 Bytes\nChi: 83608 Bytes\nDenco: 10216 Bytes\nEcho: 80328 Bytes\nGocraftWeb: 55288 Bytes\nGoji: 29744 Bytes\nGojiv2: 105840 Bytes\nGoJsonRest: 137496 Bytes\nGoRestful: 816936 Bytes\nGorillaMux: 585632 Bytes\nGowwwRouter: 24968 Bytes\nHttpRouter: 21712 Bytes\nHttpTreeMux: 73448 Bytes\nKocha: 115472 Bytes\nLARS: 30640 Bytes\nMacaron: 38592 Bytes\nMartini: 310864 Bytes\nPat: 19696 Bytes\nPossum: 89920 Bytes\nR2router: 23712 Bytes\nRivet: 24608 Bytes\nTango: 28264 Bytes\nTigerTonic: 78768 Bytes\nTraffic: 538976 Bytes\nVulcan: 369960 Bytes\n```\n\n## GithubAPI Routes: 203\n\n```sh\nGin: 58512 Bytes\n\nAce: 48688 Bytes\nAero: 318568 Bytes\nBear: 84248 Bytes\nBeego: 150936 Bytes\nBone: 100976 Bytes\nChi: 95112 Bytes\nDenco: 36736 Bytes\nEcho: 100296 Bytes\nGocraftWeb: 95432 Bytes\nGoji: 49680 Bytes\nGojiv2: 104704 Bytes\nGoJsonRest: 141976 Bytes\nGoRestful: 1241656 Bytes\nGorillaMux: 1322784 Bytes\nGowwwRouter: 80008 Bytes\nHttpRouter: 37144 Bytes\nHttpTreeMux: 78800 Bytes\nKocha: 785120 Bytes\nLARS: 48600 Bytes\nMacaron: 92784 Bytes\nMartini: 485264 Bytes\nPat: 21200 Bytes\nPossum: 85312 Bytes\nR2router: 47104 Bytes\nRivet: 42840 Bytes\nTango: 54840 Bytes\nTigerTonic: 95264 Bytes\nTraffic: 921744 Bytes\nVulcan: 425992 Bytes\n```\n\n## GPlusAPI Routes: 13\n\n```sh\nGin: 4384 Bytes\n\nAce: 3712 Bytes\nAero: 26056 Bytes\nBear: 7112 Bytes\nBeego: 10272 Bytes\nBone: 6688 Bytes\nChi: 8024 Bytes\nDenco: 3264 Bytes\nEcho: 9688 Bytes\nGocraftWeb: 7496 Bytes\nGoji: 3152 Bytes\nGojiv2: 7376 Bytes\nGoJsonRest: 11400 Bytes\nGoRestful: 74328 Bytes\nGorillaMux: 66208 Bytes\nGowwwRouter: 5744 Bytes\nHttpRouter: 2808 Bytes\nHttpTreeMux: 7440 Bytes\nKocha: 128880 Bytes\nLARS: 3656 Bytes\nMacaron: 8656 Bytes\nMartini: 23920 Bytes\nPat: 1856 Bytes\nPossum: 7248 Bytes\nR2router: 3928 Bytes\nRivet: 3064 Bytes\nTango: 5168 Bytes\nTigerTonic: 9408 Bytes\nTraffic: 46400 Bytes\nVulcan: 25544 Bytes\n```\n\n## ParseAPI Routes: 26\n\n```sh\nGin: 7776 Bytes\n\nAce: 6704 Bytes\nAero: 28488 Bytes\nBear: 12320 Bytes\nBeego: 19280 Bytes\nBone: 11440 Bytes\nChi: 9744 Bytes\nDenco: 4192 Bytes\nEcho: 11664 Bytes\nGocraftWeb: 12800 Bytes\nGoji: 5680 Bytes\nGojiv2: 14464 Bytes\nGoJsonRest: 14072 Bytes\nGoRestful: 116264 Bytes\nGorillaMux: 105880 Bytes\nGowwwRouter: 9344 Bytes\nHttpRouter: 5072 Bytes\nHttpTreeMux: 7848 Bytes\nKocha: 181712 Bytes\nLARS: 6632 Bytes\nMacaron: 13648 Bytes\nMartini: 45888 Bytes\nPat: 2560 Bytes\nPossum: 9200 Bytes\nR2router: 7056 Bytes\nRivet: 5680 Bytes\nTango: 8920 Bytes\nTigerTonic: 9840 Bytes\nTraffic: 79096 Bytes\nVulcan: 44504 Bytes\n```\n\n## Static Routes\n\n```sh\nBenchmarkGin_StaticAll                   62169         19319 ns/op           0 B/op           0 allocs/op\n\nBenchmarkAce_StaticAll                   65428         18313 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_StaticAll                 121132          9632 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpServeMux_StaticAll          52626         22758 ns/op           0 B/op           0 allocs/op\nBenchmarkBeego_StaticAll                  9962        179058 ns/op       55264 B/op         471 allocs/op\nBenchmarkBear_StaticAll                  14894         80966 ns/op       20272 B/op         469 allocs/op\nBenchmarkBone_StaticAll                  18718         64065 ns/op           0 B/op           0 allocs/op\nBenchmarkChi_StaticAll                   10000        149827 ns/op       67824 B/op         471 allocs/op\nBenchmarkDenco_StaticAll                211393          5680 ns/op           0 B/op           0 allocs/op\nBenchmarkEcho_StaticAll                  49341         24343 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_StaticAll            10000        126209 ns/op       46312 B/op         785 allocs/op\nBenchmarkGoji_StaticAll                  27956         43174 ns/op           0 B/op           0 allocs/op\nBenchmarkGojiv2_StaticAll                 3430        370718 ns/op      205984 B/op        1570 allocs/op\nBenchmarkGoJsonRest_StaticAll             9134        188888 ns/op       51653 B/op        1727 allocs/op\nBenchmarkGoRestful_StaticAll               706       1703330 ns/op      613280 B/op        2053 allocs/op\nBenchmarkGorillaMux_StaticAll             1268        924083 ns/op      153233 B/op        1413 allocs/op\nBenchmarkGowwwRouter_StaticAll           63374         18935 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpRouter_StaticAll           109938         10902 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_StaticAll          109166         10861 ns/op           0 B/op           0 allocs/op\nBenchmarkKocha_StaticAll                 92258         12992 ns/op           0 B/op           0 allocs/op\nBenchmarkLARS_StaticAll                  65200         18387 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_StaticAll                5671        291501 ns/op      115553 B/op        1256 allocs/op\nBenchmarkMartini_StaticAll                 807       1460498 ns/op      125444 B/op        1717 allocs/op\nBenchmarkPat_StaticAll                     513       2342396 ns/op      602832 B/op       12559 allocs/op\nBenchmarkPossum_StaticAll                10000        128270 ns/op       65312 B/op         471 allocs/op\nBenchmarkR2router_StaticAll              16726         71760 ns/op       22608 B/op         628 allocs/op\nBenchmarkRivet_StaticAll                 41722         28723 ns/op           0 B/op           0 allocs/op\nBenchmarkTango_StaticAll                  7606        205082 ns/op       39209 B/op        1256 allocs/op\nBenchmarkTigerTonic_StaticAll            26247         45806 ns/op        7376 B/op         157 allocs/op\nBenchmarkTraffic_StaticAll                 550       2284518 ns/op      754864 B/op       14601 allocs/op\nBenchmarkVulcan_StaticAll                10000        131343 ns/op       15386 B/op         471 allocs/op\n```\n\n## Micro Benchmarks\n\n```sh\nBenchmarkGin_Param                    18785022          63.9 ns/op           0 B/op           0 allocs/op\n\nBenchmarkAce_Param                    14689765          81.5 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_Param                   23094770          51.2 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_Param                    1417045           845 ns/op         456 B/op           5 allocs/op\nBenchmarkBeego_Param                   1000000          1080 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_Param                    1000000          1463 ns/op         816 B/op           6 allocs/op\nBenchmarkChi_Param                     1378756           885 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_Param                   8557899           143 ns/op          32 B/op           1 allocs/op\nBenchmarkEcho_Param                   16433347          75.5 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_Param              1000000          1218 ns/op         648 B/op           8 allocs/op\nBenchmarkGoji_Param                    1921248           617 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_Param                   561848          2156 ns/op        1328 B/op          11 allocs/op\nBenchmarkGoJsonRest_Param              1000000          1358 ns/op         649 B/op          13 allocs/op\nBenchmarkGoRestful_Param                224857          5307 ns/op        4192 B/op          14 allocs/op\nBenchmarkGorillaMux_Param               498313          2459 ns/op        1280 B/op          10 allocs/op\nBenchmarkGowwwRouter_Param             1864354           654 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_Param             26269074          47.7 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_Param             2109829           557 ns/op         352 B/op           3 allocs/op\nBenchmarkKocha_Param                   5050216           243 ns/op          56 B/op           3 allocs/op\nBenchmarkLARS_Param                   19811712          59.9 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_Param                  662746          2329 ns/op        1072 B/op          10 allocs/op\nBenchmarkMartini_Param                  279902          4260 ns/op        1072 B/op          10 allocs/op\nBenchmarkPat_Param                     1000000          1382 ns/op         536 B/op          11 allocs/op\nBenchmarkPossum_Param                  1000000          1014 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_Param                1712559           707 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_Param                   6648086           182 ns/op          48 B/op           1 allocs/op\nBenchmarkTango_Param                   1221504           994 ns/op         248 B/op           8 allocs/op\nBenchmarkTigerTonic_Param               891661          2261 ns/op         776 B/op          16 allocs/op\nBenchmarkTraffic_Param                  350059          3598 ns/op        1856 B/op          21 allocs/op\nBenchmarkVulcan_Param                  2517823           472 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_Param5                    9214365           130 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_Param5                  15369013          77.9 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_Param5                   1000000          1113 ns/op         501 B/op           5 allocs/op\nBenchmarkBeego_Param5                  1000000          1269 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_Param5                    986820          1873 ns/op         864 B/op           6 allocs/op\nBenchmarkChi_Param5                    1000000          1156 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_Param5                  3036331           400 ns/op         160 B/op           1 allocs/op\nBenchmarkEcho_Param5                   6447133           186 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_Param5                   10786068           110 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_Param5              844820          1944 ns/op         920 B/op          11 allocs/op\nBenchmarkGoji_Param5                   1474965           827 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_Param5                  442820          2516 ns/op        1392 B/op          11 allocs/op\nBenchmarkGoJsonRest_Param5              507555          2711 ns/op        1097 B/op          16 allocs/op\nBenchmarkGoRestful_Param5               216481          6093 ns/op        4288 B/op          14 allocs/op\nBenchmarkGorillaMux_Param5              314402          3628 ns/op        1344 B/op          10 allocs/op\nBenchmarkGowwwRouter_Param5            1624660           733 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_Param5            13167324          92.0 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_Param5            1000000          1295 ns/op         576 B/op           6 allocs/op\nBenchmarkKocha_Param5                  1000000          1138 ns/op         440 B/op          10 allocs/op\nBenchmarkLARS_Param5                  11580613           105 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_Param5                 473596          2755 ns/op        1072 B/op          10 allocs/op\nBenchmarkMartini_Param5                 230756          5111 ns/op        1232 B/op          11 allocs/op\nBenchmarkPat_Param5                     469190          3370 ns/op         888 B/op          29 allocs/op\nBenchmarkPossum_Param5                 1000000          1002 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_Param5               1422129           844 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_Param5                  2263789           539 ns/op         240 B/op           1 allocs/op\nBenchmarkTango_Param5                  1000000          1256 ns/op         360 B/op           8 allocs/op\nBenchmarkTigerTonic_Param5              175500          7492 ns/op        2279 B/op          39 allocs/op\nBenchmarkTraffic_Param5                 233631          5816 ns/op        2208 B/op          27 allocs/op\nBenchmarkVulcan_Param5                 1923416           629 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_Param20                   4321266           281 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_Param20                 31501641          35.2 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_Param20                   335204          3489 ns/op        1665 B/op           5 allocs/op\nBenchmarkBeego_Param20                  503674          2860 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_Param20                   298922          4741 ns/op        2031 B/op           6 allocs/op\nBenchmarkChi_Param20                    878181          1957 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_Param20                 1000000          1360 ns/op         640 B/op           1 allocs/op\nBenchmarkEcho_Param20                  2104946           580 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_Param20                   4167204           290 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_Param20             173064          7514 ns/op        3796 B/op          15 allocs/op\nBenchmarkGoji_Param20                   458778          2651 ns/op        1247 B/op           2 allocs/op\nBenchmarkGojiv2_Param20                 364862          3178 ns/op        1632 B/op          11 allocs/op\nBenchmarkGoJsonRest_Param20             125514          9760 ns/op        4485 B/op          20 allocs/op\nBenchmarkGoRestful_Param20              101217         11964 ns/op        6715 B/op          18 allocs/op\nBenchmarkGorillaMux_Param20             147654          8132 ns/op        3452 B/op          12 allocs/op\nBenchmarkGowwwRouter_Param20           1000000          1225 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_Param20            4920895           247 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_Param20            173202          6605 ns/op        3196 B/op          10 allocs/op\nBenchmarkKocha_Param20                  345988          3620 ns/op        1808 B/op          27 allocs/op\nBenchmarkLARS_Param20                  4592326           262 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_Param20                166492          7286 ns/op        2924 B/op          12 allocs/op\nBenchmarkMartini_Param20                122162         10653 ns/op        3595 B/op          13 allocs/op\nBenchmarkPat_Param20                     78630         15239 ns/op        4424 B/op          93 allocs/op\nBenchmarkPossum_Param20                1000000          1008 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_Param20               294981          4587 ns/op        2284 B/op           7 allocs/op\nBenchmarkRivet_Param20                  691798          2090 ns/op        1024 B/op           1 allocs/op\nBenchmarkTango_Param20                  842440          2505 ns/op         856 B/op           8 allocs/op\nBenchmarkTigerTonic_Param20              38614         31509 ns/op        9870 B/op         119 allocs/op\nBenchmarkTraffic_Param20                 57633         21107 ns/op        7853 B/op          47 allocs/op\nBenchmarkVulcan_Param20                1000000          1178 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_ParamWrite                7330743           180 ns/op           8 B/op           1 allocs/op\nBenchmarkAero_ParamWrite              13833598          86.7 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_ParamWrite               1363321           867 ns/op         456 B/op           5 allocs/op\nBenchmarkBeego_ParamWrite              1000000          1104 ns/op         360 B/op           4 allocs/op\nBenchmarkBone_ParamWrite               1000000          1475 ns/op         816 B/op           6 allocs/op\nBenchmarkChi_ParamWrite                1320590           892 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_ParamWrite              7093605           172 ns/op          32 B/op           1 allocs/op\nBenchmarkEcho_ParamWrite               8434424           161 ns/op           8 B/op           1 allocs/op\nBenchmarkGin_ParamWrite               10377034           118 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_ParamWrite         1000000          1266 ns/op         656 B/op           9 allocs/op\nBenchmarkGoji_ParamWrite               1874168           654 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_ParamWrite              459032          2352 ns/op        1360 B/op          13 allocs/op\nBenchmarkGoJsonRest_ParamWrite          499434          2145 ns/op        1128 B/op          18 allocs/op\nBenchmarkGoRestful_ParamWrite           241087          5470 ns/op        4200 B/op          15 allocs/op\nBenchmarkGorillaMux_ParamWrite          425686          2522 ns/op        1280 B/op          10 allocs/op\nBenchmarkGowwwRouter_ParamWrite         922172          1778 ns/op         976 B/op           8 allocs/op\nBenchmarkHttpRouter_ParamWrite        15392049          77.7 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_ParamWrite        1973385           597 ns/op         352 B/op           3 allocs/op\nBenchmarkKocha_ParamWrite              4262500           281 ns/op          56 B/op           3 allocs/op\nBenchmarkLARS_ParamWrite              10764410           113 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_ParamWrite             486769          2726 ns/op        1176 B/op          14 allocs/op\nBenchmarkMartini_ParamWrite             264804          4842 ns/op        1176 B/op          14 allocs/op\nBenchmarkPat_ParamWrite                 735116          2047 ns/op         960 B/op          15 allocs/op\nBenchmarkPossum_ParamWrite             1000000          1004 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_ParamWrite           1592136           768 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_ParamWrite              3582051           339 ns/op         112 B/op           2 allocs/op\nBenchmarkTango_ParamWrite              2237337           534 ns/op         136 B/op           4 allocs/op\nBenchmarkTigerTonic_ParamWrite          439608          3136 ns/op        1216 B/op          21 allocs/op\nBenchmarkTraffic_ParamWrite             306979          4328 ns/op        2280 B/op          25 allocs/op\nBenchmarkVulcan_ParamWrite             2529973           472 ns/op          98 B/op           3 allocs/op\n```\n\n## GitHub\n\n```sh\nBenchmarkGin_GithubStatic             15629472          76.7 ns/op           0 B/op           0 allocs/op\n\nBenchmarkAce_GithubStatic             15542612          75.9 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_GithubStatic            24777151          48.5 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_GithubStatic             2788894           435 ns/op         120 B/op           3 allocs/op\nBenchmarkBeego_GithubStatic            1000000          1064 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_GithubStatic               93507         12838 ns/op        2880 B/op          60 allocs/op\nBenchmarkChi_GithubStatic              1387743           860 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_GithubStatic           39384996          30.4 ns/op           0 B/op           0 allocs/op\nBenchmarkEcho_GithubStatic            12076382          99.1 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_GithubStatic       1596495           756 ns/op         296 B/op           5 allocs/op\nBenchmarkGoji_GithubStatic             6364876           189 ns/op           0 B/op           0 allocs/op\nBenchmarkGojiv2_GithubStatic            550202          2098 ns/op        1312 B/op          10 allocs/op\nBenchmarkGoRestful_GithubStatic         102183         12552 ns/op        4256 B/op          13 allocs/op\nBenchmarkGoJsonRest_GithubStatic       1000000          1029 ns/op         329 B/op          11 allocs/op\nBenchmarkGorillaMux_GithubStatic        255552          5190 ns/op         976 B/op           9 allocs/op\nBenchmarkGowwwRouter_GithubStatic     15531916          77.1 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpRouter_GithubStatic      27920724          43.1 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_GithubStatic     21448953          55.8 ns/op           0 B/op           0 allocs/op\nBenchmarkKocha_GithubStatic           21405310          56.0 ns/op           0 B/op           0 allocs/op\nBenchmarkLARS_GithubStatic            13625156          89.0 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_GithubStatic          1000000          1747 ns/op         736 B/op           8 allocs/op\nBenchmarkMartini_GithubStatic           187186          7326 ns/op         768 B/op           9 allocs/op\nBenchmarkPat_GithubStatic               109143         11563 ns/op        3648 B/op          76 allocs/op\nBenchmarkPossum_GithubStatic           1575898           770 ns/op         416 B/op           3 allocs/op\nBenchmarkR2router_GithubStatic         3046231           404 ns/op         144 B/op           4 allocs/op\nBenchmarkRivet_GithubStatic           11484826           105 ns/op           0 B/op           0 allocs/op\nBenchmarkTango_GithubStatic            1000000          1153 ns/op         248 B/op           8 allocs/op\nBenchmarkTigerTonic_GithubStatic       4929780           249 ns/op          48 B/op           1 allocs/op\nBenchmarkTraffic_GithubStatic           106351         11819 ns/op        4664 B/op          90 allocs/op\nBenchmarkVulcan_GithubStatic           1613271           722 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_GithubParam               8386032           143 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_GithubParam             11816200           102 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_GithubParam              1000000          1012 ns/op         496 B/op           5 allocs/op\nBenchmarkBeego_GithubParam             1000000          1157 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_GithubParam               184653          6912 ns/op        1888 B/op          19 allocs/op\nBenchmarkChi_GithubParam               1000000          1102 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_GithubParam             3484798           352 ns/op         128 B/op           1 allocs/op\nBenchmarkEcho_GithubParam              6337380           189 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_GithubParam               9132032           131 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_GithubParam        1000000          1446 ns/op         712 B/op           9 allocs/op\nBenchmarkGoji_GithubParam              1248640           977 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_GithubParam             383233          2784 ns/op        1408 B/op          13 allocs/op\nBenchmarkGoJsonRest_GithubParam        1000000          1991 ns/op         713 B/op          14 allocs/op\nBenchmarkGoRestful_GithubParam           76414         16015 ns/op        4352 B/op          16 allocs/op\nBenchmarkGorillaMux_GithubParam         150026          7663 ns/op        1296 B/op          10 allocs/op\nBenchmarkGowwwRouter_GithubParam       1592044           751 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_GithubParam       10420628           115 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_GithubParam       1403755           835 ns/op         384 B/op           4 allocs/op\nBenchmarkKocha_GithubParam             2286170           533 ns/op         128 B/op           5 allocs/op\nBenchmarkLARS_GithubParam              9540374           129 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_GithubParam            533154          2742 ns/op        1072 B/op          10 allocs/op\nBenchmarkMartini_GithubParam            119397          9638 ns/op        1152 B/op          11 allocs/op\nBenchmarkPat_GithubParam                150675          8858 ns/op        2408 B/op          48 allocs/op\nBenchmarkPossum_GithubParam            1000000          1001 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_GithubParam          1602886           761 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_GithubParam             2986579           409 ns/op          96 B/op           1 allocs/op\nBenchmarkTango_GithubParam             1000000          1356 ns/op         344 B/op           8 allocs/op\nBenchmarkTigerTonic_GithubParam         388899          3429 ns/op        1176 B/op          22 allocs/op\nBenchmarkTraffic_GithubParam            123160          9734 ns/op        2816 B/op          40 allocs/op\nBenchmarkVulcan_GithubParam            1000000          1138 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_GithubAll                   40543         29670 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_GithubAll                  57632         20648 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_GithubAll                   9234        216179 ns/op       86448 B/op         943 allocs/op\nBenchmarkBeego_GithubAll                  7407        243496 ns/op       71456 B/op         609 allocs/op\nBenchmarkBone_GithubAll                    420       2922835 ns/op      720160 B/op        8620 allocs/op\nBenchmarkChi_GithubAll                    7620        238331 ns/op       87696 B/op         609 allocs/op\nBenchmarkDenco_GithubAll                 18355         64494 ns/op       20224 B/op         167 allocs/op\nBenchmarkEcho_GithubAll                  31251         38479 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_GithubAll                   43550         27364 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_GithubAll             4117        300062 ns/op      131656 B/op        1686 allocs/op\nBenchmarkGoji_GithubAll                   3274        416158 ns/op       56112 B/op         334 allocs/op\nBenchmarkGojiv2_GithubAll                 1402        870518 ns/op      352720 B/op        4321 allocs/op\nBenchmarkGoJsonRest_GithubAll             2976        401507 ns/op      134371 B/op        2737 allocs/op\nBenchmarkGoRestful_GithubAll               410       2913158 ns/op      910144 B/op        2938 allocs/op\nBenchmarkGorillaMux_GithubAll              346       3384987 ns/op      251650 B/op        1994 allocs/op\nBenchmarkGowwwRouter_GithubAll           10000        143025 ns/op       72144 B/op         501 allocs/op\nBenchmarkHttpRouter_GithubAll            55938         21360 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_GithubAll           10000        153944 ns/op       65856 B/op         671 allocs/op\nBenchmarkKocha_GithubAll                 10000        106315 ns/op       23304 B/op         843 allocs/op\nBenchmarkLARS_GithubAll                  47779         25084 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_GithubAll                3266        371907 ns/op      149409 B/op        1624 allocs/op\nBenchmarkMartini_GithubAll                 331       3444706 ns/op      226551 B/op        2325 allocs/op\nBenchmarkPat_GithubAll                     273       4381818 ns/op     1483152 B/op       26963 allocs/op\nBenchmarkPossum_GithubAll                10000        164367 ns/op       84448 B/op         609 allocs/op\nBenchmarkR2router_GithubAll              10000        160220 ns/op       77328 B/op         979 allocs/op\nBenchmarkRivet_GithubAll                 14625         82453 ns/op       16272 B/op         167 allocs/op\nBenchmarkTango_GithubAll                  6255        279611 ns/op       63826 B/op        1618 allocs/op\nBenchmarkTigerTonic_GithubAll             2008        687874 ns/op      193856 B/op        4474 allocs/op\nBenchmarkTraffic_GithubAll                 355       3478508 ns/op      820744 B/op       14114 allocs/op\nBenchmarkVulcan_GithubAll                 6885        193333 ns/op       19894 B/op         609 allocs/op\n```\n\n## Google+\n\n```sh\nBenchmarkGin_GPlusStatic              19247326          62.2 ns/op           0 B/op           0 allocs/op\n\nBenchmarkAce_GPlusStatic              20235060          59.2 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_GPlusStatic             31978935          37.6 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_GPlusStatic              3516523           341 ns/op         104 B/op           3 allocs/op\nBenchmarkBeego_GPlusStatic             1212036           991 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_GPlusStatic              6736242           183 ns/op          32 B/op           1 allocs/op\nBenchmarkChi_GPlusStatic               1490640           814 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_GPlusStatic            55006856          21.8 ns/op           0 B/op           0 allocs/op\nBenchmarkEcho_GPlusStatic             17688258          67.9 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_GPlusStatic        1829181           666 ns/op         280 B/op           5 allocs/op\nBenchmarkGoji_GPlusStatic              9147451           130 ns/op           0 B/op           0 allocs/op\nBenchmarkGojiv2_GPlusStatic             594015          2063 ns/op        1312 B/op          10 allocs/op\nBenchmarkGoJsonRest_GPlusStatic        1264906           950 ns/op         329 B/op          11 allocs/op\nBenchmarkGoRestful_GPlusStatic          231558          5341 ns/op        3872 B/op          13 allocs/op\nBenchmarkGorillaMux_GPlusStatic         908418          1809 ns/op         976 B/op           9 allocs/op\nBenchmarkGowwwRouter_GPlusStatic      40684604          29.5 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpRouter_GPlusStatic       46742804          25.7 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_GPlusStatic      32567161          36.9 ns/op           0 B/op           0 allocs/op\nBenchmarkKocha_GPlusStatic            33800060          35.3 ns/op           0 B/op           0 allocs/op\nBenchmarkLARS_GPlusStatic             20431858          60.0 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_GPlusStatic           1000000          1745 ns/op         736 B/op           8 allocs/op\nBenchmarkMartini_GPlusStatic            442248          3619 ns/op         768 B/op           9 allocs/op\nBenchmarkPat_GPlusStatic               4328004           292 ns/op          96 B/op           2 allocs/op\nBenchmarkPossum_GPlusStatic            1570753           763 ns/op         416 B/op           3 allocs/op\nBenchmarkR2router_GPlusStatic          3339474           355 ns/op         144 B/op           4 allocs/op\nBenchmarkRivet_GPlusStatic            18570961          64.7 ns/op           0 B/op           0 allocs/op\nBenchmarkTango_GPlusStatic             1388702           860 ns/op         200 B/op           8 allocs/op\nBenchmarkTigerTonic_GPlusStatic        7803543           159 ns/op          32 B/op           1 allocs/op\nBenchmarkTraffic_GPlusStatic            878605          2171 ns/op        1112 B/op          16 allocs/op\nBenchmarkVulcan_GPlusStatic            2742446           437 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_GPlusParam               11626975           105 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_GPlusParam              16914322          71.6 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_GPlusParam               1405173           832 ns/op         480 B/op           5 allocs/op\nBenchmarkBeego_GPlusParam              1000000          1075 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_GPlusParam               1000000          1557 ns/op         816 B/op           6 allocs/op\nBenchmarkChi_GPlusParam                1347926           894 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_GPlusParam              5513000           212 ns/op          64 B/op           1 allocs/op\nBenchmarkEcho_GPlusParam              11884383           101 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_GPlusParam               12898952          93.1 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_GPlusParam         1000000          1194 ns/op         648 B/op           8 allocs/op\nBenchmarkGoji_GPlusParam               1857229           645 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_GPlusParam              520939          2322 ns/op        1328 B/op          11 allocs/op\nBenchmarkGoJsonRest_GPlusParam         1000000          1536 ns/op         649 B/op          13 allocs/op\nBenchmarkGoRestful_GPlusParam           205449          5800 ns/op        4192 B/op          14 allocs/op\nBenchmarkGorillaMux_GPlusParam          395310          3188 ns/op        1280 B/op          10 allocs/op\nBenchmarkGowwwRouter_GPlusParam        1851798           667 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_GPlusParam        18420789          65.2 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_GPlusParam        1878463           629 ns/op         352 B/op           3 allocs/op\nBenchmarkKocha_GPlusParam              4495610           273 ns/op          56 B/op           3 allocs/op\nBenchmarkLARS_GPlusParam              14615976          83.2 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_GPlusParam             584145          2549 ns/op        1072 B/op          10 allocs/op\nBenchmarkMartini_GPlusParam             250501          4583 ns/op        1072 B/op          10 allocs/op\nBenchmarkPat_GPlusParam                1000000          1645 ns/op         576 B/op          11 allocs/op\nBenchmarkPossum_GPlusParam             1000000          1008 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_GPlusParam           1708191           688 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_GPlusParam              5795014           211 ns/op          48 B/op           1 allocs/op\nBenchmarkTango_GPlusParam              1000000          1091 ns/op         264 B/op           8 allocs/op\nBenchmarkTigerTonic_GPlusParam          760221          2489 ns/op         856 B/op          16 allocs/op\nBenchmarkTraffic_GPlusParam             309774          4039 ns/op        1872 B/op          21 allocs/op\nBenchmarkVulcan_GPlusParam             1935730           623 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_GPlus2Params              9158314           134 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_GPlus2Params            11300517           107 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_GPlus2Params             1239238           961 ns/op         496 B/op           5 allocs/op\nBenchmarkBeego_GPlus2Params            1000000          1202 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_GPlus2Params              335576          3725 ns/op        1168 B/op          10 allocs/op\nBenchmarkChi_GPlus2Params              1000000          1014 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_GPlus2Params            4394598           280 ns/op          64 B/op           1 allocs/op\nBenchmarkEcho_GPlus2Params             7851861           154 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_GPlus2Params              9958588           120 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_GPlus2Params       1000000          1433 ns/op         712 B/op           9 allocs/op\nBenchmarkGoji_GPlus2Params             1325134           909 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_GPlus2Params            405955          2870 ns/op        1408 B/op          14 allocs/op\nBenchmarkGoJsonRest_GPlus2Params        977038          1987 ns/op         713 B/op          14 allocs/op\nBenchmarkGoRestful_GPlus2Params         205018          6142 ns/op        4384 B/op          16 allocs/op\nBenchmarkGorillaMux_GPlus2Params        205641          6015 ns/op        1296 B/op          10 allocs/op\nBenchmarkGowwwRouter_GPlus2Params      1748542           684 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_GPlus2Params      14047102          87.7 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_GPlus2Params      1418673           828 ns/op         384 B/op           4 allocs/op\nBenchmarkKocha_GPlus2Params            2334562           520 ns/op         128 B/op           5 allocs/op\nBenchmarkLARS_GPlus2Params            11954094           101 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_GPlus2Params           491552          2890 ns/op        1072 B/op          10 allocs/op\nBenchmarkMartini_GPlus2Params           120532          9545 ns/op        1200 B/op          13 allocs/op\nBenchmarkPat_GPlus2Params               194739          6766 ns/op        2168 B/op          33 allocs/op\nBenchmarkPossum_GPlus2Params           1201224          1009 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_GPlus2Params         1575535           756 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_GPlus2Params            3698930           325 ns/op          96 B/op           1 allocs/op\nBenchmarkTango_GPlus2Params            1000000          1212 ns/op         344 B/op           8 allocs/op\nBenchmarkTigerTonic_GPlus2Params        349350          3660 ns/op        1200 B/op          22 allocs/op\nBenchmarkTraffic_GPlus2Params           169714          7862 ns/op        2248 B/op          28 allocs/op\nBenchmarkVulcan_GPlus2Params           1222288           974 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_GPlusAll                   845606          1398 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_GPlusAll                 1000000          1009 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_GPlusAll                  103830         11386 ns/op        5488 B/op          61 allocs/op\nBenchmarkBeego_GPlusAll                  82653         14784 ns/op        4576 B/op          39 allocs/op\nBenchmarkBone_GPlusAll                   36601         33123 ns/op       11744 B/op         109 allocs/op\nBenchmarkChi_GPlusAll                    95264         12831 ns/op        5616 B/op          39 allocs/op\nBenchmarkDenco_GPlusAll                 567681          2950 ns/op         672 B/op          11 allocs/op\nBenchmarkEcho_GPlusAll                  720366          1665 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_GPlusAll                  1000000          1185 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_GPlusAll             71575         16365 ns/op        8040 B/op         103 allocs/op\nBenchmarkGoji_GPlusAll                  136352          9191 ns/op        3696 B/op          22 allocs/op\nBenchmarkGojiv2_GPlusAll                 38006         31802 ns/op       17616 B/op         154 allocs/op\nBenchmarkGoJsonRest_GPlusAll             57238         21561 ns/op        8117 B/op         170 allocs/op\nBenchmarkGoRestful_GPlusAll              15147         79276 ns/op       55520 B/op         192 allocs/op\nBenchmarkGorillaMux_GPlusAll             24446         48410 ns/op       16112 B/op         128 allocs/op\nBenchmarkGowwwRouter_GPlusAll           150112          7770 ns/op        4752 B/op          33 allocs/op\nBenchmarkHttpRouter_GPlusAll           1367820           878 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_GPlusAll           166628          8004 ns/op        4032 B/op          38 allocs/op\nBenchmarkKocha_GPlusAll                 265694          4570 ns/op         976 B/op          43 allocs/op\nBenchmarkLARS_GPlusAll                 1000000          1068 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_GPlusAll                54564         23305 ns/op        9568 B/op         104 allocs/op\nBenchmarkMartini_GPlusAll                16274         73845 ns/op       14016 B/op         145 allocs/op\nBenchmarkPat_GPlusAll                    27181         44478 ns/op       15264 B/op         271 allocs/op\nBenchmarkPossum_GPlusAll                122587         10277 ns/op        5408 B/op          39 allocs/op\nBenchmarkR2router_GPlusAll              130137          9297 ns/op        5040 B/op          63 allocs/op\nBenchmarkRivet_GPlusAll                 532438          3323 ns/op         768 B/op          11 allocs/op\nBenchmarkTango_GPlusAll                  86054         14531 ns/op        3656 B/op         104 allocs/op\nBenchmarkTigerTonic_GPlusAll             33936         35356 ns/op       11600 B/op         242 allocs/op\nBenchmarkTraffic_GPlusAll                17833         68181 ns/op       26248 B/op         341 allocs/op\nBenchmarkVulcan_GPlusAll                120109          9861 ns/op        1274 B/op          39 allocs/op\n```\n\n## Parse.com\n\n```sh\nBenchmarkGin_ParseStatic              18877833          63.5 ns/op           0 B/op           0 allocs/op\n\nBenchmarkAce_ParseStatic              19663731          60.8 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_ParseStatic             28967341          41.5 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_ParseStatic              3006984           402 ns/op         120 B/op           3 allocs/op\nBenchmarkBeego_ParseStatic             1000000          1031 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_ParseStatic              1782482           675 ns/op         144 B/op           3 allocs/op\nBenchmarkChi_ParseStatic               1453261           819 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_ParseStatic            45023595          26.5 ns/op           0 B/op           0 allocs/op\nBenchmarkEcho_ParseStatic             17330470          69.3 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_ParseStatic        1644006           731 ns/op         296 B/op           5 allocs/op\nBenchmarkGoji_ParseStatic              7026930           170 ns/op           0 B/op           0 allocs/op\nBenchmarkGojiv2_ParseStatic             517618          2037 ns/op        1312 B/op          10 allocs/op\nBenchmarkGoJsonRest_ParseStatic        1227080           975 ns/op         329 B/op          11 allocs/op\nBenchmarkGoRestful_ParseStatic          192458          6659 ns/op        4256 B/op          13 allocs/op\nBenchmarkGorillaMux_ParseStatic         744062          2109 ns/op         976 B/op           9 allocs/op\nBenchmarkGowwwRouter_ParseStatic      37781062          31.8 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpRouter_ParseStatic       45311223          26.5 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_ParseStatic      21383475          56.1 ns/op           0 B/op           0 allocs/op\nBenchmarkKocha_ParseStatic            29953290          40.1 ns/op           0 B/op           0 allocs/op\nBenchmarkLARS_ParseStatic             20036196          62.7 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_ParseStatic           1000000          1740 ns/op         736 B/op           8 allocs/op\nBenchmarkMartini_ParseStatic            404156          3801 ns/op         768 B/op           9 allocs/op\nBenchmarkPat_ParseStatic               1547180           772 ns/op         240 B/op           5 allocs/op\nBenchmarkPossum_ParseStatic            1608991           757 ns/op         416 B/op           3 allocs/op\nBenchmarkR2router_ParseStatic          3177936           385 ns/op         144 B/op           4 allocs/op\nBenchmarkRivet_ParseStatic            17783205          67.4 ns/op           0 B/op           0 allocs/op\nBenchmarkTango_ParseStatic             1210777           990 ns/op         248 B/op           8 allocs/op\nBenchmarkTigerTonic_ParseStatic        5316440           231 ns/op          48 B/op           1 allocs/op\nBenchmarkTraffic_ParseStatic            496050          2539 ns/op        1256 B/op          19 allocs/op\nBenchmarkVulcan_ParseStatic            2462798           488 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_ParseParam               13393669          89.6 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_ParseParam              19836619          60.4 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_ParseParam               1405954           864 ns/op         467 B/op           5 allocs/op\nBenchmarkBeego_ParseParam              1000000          1065 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_ParseParam               1000000          1698 ns/op         896 B/op           7 allocs/op\nBenchmarkChi_ParseParam                1356037           873 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_ParseParam              6241392           204 ns/op          64 B/op           1 allocs/op\nBenchmarkEcho_ParseParam              14088100          85.1 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_ParseParam               17426064          68.9 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_ParseParam         1000000          1254 ns/op         664 B/op           8 allocs/op\nBenchmarkGoji_ParseParam               1682574           713 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_ParseParam              502224          2333 ns/op        1360 B/op          12 allocs/op\nBenchmarkGoJsonRest_ParseParam         1000000          1401 ns/op         649 B/op          13 allocs/op\nBenchmarkGoRestful_ParseParam           182623          7097 ns/op        4576 B/op          14 allocs/op\nBenchmarkGorillaMux_ParseParam          482332          2477 ns/op        1280 B/op          10 allocs/op\nBenchmarkGowwwRouter_ParseParam        1834873           657 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_ParseParam        23593393          51.0 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_ParseParam        2100160           574 ns/op         352 B/op           3 allocs/op\nBenchmarkKocha_ParseParam              4837220           252 ns/op          56 B/op           3 allocs/op\nBenchmarkLARS_ParseParam              18411192          66.2 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_ParseParam             571870          2398 ns/op        1072 B/op          10 allocs/op\nBenchmarkMartini_ParseParam             286262          4268 ns/op        1072 B/op          10 allocs/op\nBenchmarkPat_ParseParam                 692906          2157 ns/op         992 B/op          15 allocs/op\nBenchmarkPossum_ParseParam             1000000          1011 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_ParseParam           1722735           697 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_ParseParam              6058054           203 ns/op          48 B/op           1 allocs/op\nBenchmarkTango_ParseParam              1000000          1061 ns/op         280 B/op           8 allocs/op\nBenchmarkTigerTonic_ParseParam          890275          2277 ns/op         784 B/op          15 allocs/op\nBenchmarkTraffic_ParseParam             351322          3543 ns/op        1896 B/op          21 allocs/op\nBenchmarkVulcan_ParseParam             2076544           572 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_Parse2Params             11718074           101 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_Parse2Params            16264988          73.4 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_Parse2Params             1238322           973 ns/op         496 B/op           5 allocs/op\nBenchmarkBeego_Parse2Params            1000000          1120 ns/op         352 B/op           3 allocs/op\nBenchmarkBone_Parse2Params             1000000          1632 ns/op         848 B/op           6 allocs/op\nBenchmarkChi_Parse2Params              1239477           955 ns/op         432 B/op           3 allocs/op\nBenchmarkDenco_Parse2Params            4944133           245 ns/op          64 B/op           1 allocs/op\nBenchmarkEcho_Parse2Params            10518286           114 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_Parse2Params             14505195          82.7 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_Parse2Params       1000000          1437 ns/op         712 B/op           9 allocs/op\nBenchmarkGoji_Parse2Params             1689883           707 ns/op         336 B/op           2 allocs/op\nBenchmarkGojiv2_Parse2Params            502334          2308 ns/op        1344 B/op          11 allocs/op\nBenchmarkGoJsonRest_Parse2Params       1000000          1771 ns/op         713 B/op          14 allocs/op\nBenchmarkGoRestful_Parse2Params         159092          7583 ns/op        4928 B/op          14 allocs/op\nBenchmarkGorillaMux_Parse2Params        417548          2980 ns/op        1296 B/op          10 allocs/op\nBenchmarkGowwwRouter_Parse2Params      1751737           686 ns/op         432 B/op           3 allocs/op\nBenchmarkHttpRouter_Parse2Params      18089204          66.3 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_Parse2Params      1556986           777 ns/op         384 B/op           4 allocs/op\nBenchmarkKocha_Parse2Params            2493082           485 ns/op         128 B/op           5 allocs/op\nBenchmarkLARS_Parse2Params            15350108          78.5 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_Parse2Params           530974          2605 ns/op        1072 B/op          10 allocs/op\nBenchmarkMartini_Parse2Params           247069          4673 ns/op        1152 B/op          11 allocs/op\nBenchmarkPat_Parse2Params               816295          2126 ns/op         752 B/op          16 allocs/op\nBenchmarkPossum_Parse2Params           1000000          1002 ns/op         496 B/op           5 allocs/op\nBenchmarkR2router_Parse2Params         1569771           733 ns/op         432 B/op           5 allocs/op\nBenchmarkRivet_Parse2Params            4080546           295 ns/op          96 B/op           1 allocs/op\nBenchmarkTango_Parse2Params            1000000          1121 ns/op         312 B/op           8 allocs/op\nBenchmarkTigerTonic_Parse2Params        399556          3470 ns/op        1168 B/op          22 allocs/op\nBenchmarkTraffic_Parse2Params           314194          4159 ns/op        1944 B/op          22 allocs/op\nBenchmarkVulcan_Parse2Params           1827559           664 ns/op          98 B/op           3 allocs/op\nBenchmarkAce_ParseAll                   478395          2503 ns/op           0 B/op           0 allocs/op\nBenchmarkAero_ParseAll                  715392          1658 ns/op           0 B/op           0 allocs/op\nBenchmarkBear_ParseAll                   59191         20124 ns/op        8928 B/op         110 allocs/op\nBenchmarkBeego_ParseAll                  45507         27266 ns/op        9152 B/op          78 allocs/op\nBenchmarkBone_ParseAll                   29328         41459 ns/op       16208 B/op         147 allocs/op\nBenchmarkChi_ParseAll                    48531         25053 ns/op       11232 B/op          78 allocs/op\nBenchmarkDenco_ParseAll                 325532          4284 ns/op         928 B/op          16 allocs/op\nBenchmarkEcho_ParseAll                  433771          2759 ns/op           0 B/op           0 allocs/op\nBenchmarkGin_ParseAll                   576316          2082 ns/op           0 B/op           0 allocs/op\nBenchmarkGocraftWeb_ParseAll             41500         29692 ns/op       13728 B/op         181 allocs/op\nBenchmarkGoji_ParseAll                   80833         15563 ns/op        5376 B/op          32 allocs/op\nBenchmarkGojiv2_ParseAll                 19836         60335 ns/op       34448 B/op         277 allocs/op\nBenchmarkGoJsonRest_ParseAll             32210         38027 ns/op       13866 B/op         321 allocs/op\nBenchmarkGoRestful_ParseAll               6644        190842 ns/op      117600 B/op         354 allocs/op\nBenchmarkGorillaMux_ParseAll             12634         95894 ns/op       30288 B/op         250 allocs/op\nBenchmarkGowwwRouter_ParseAll            98152         12159 ns/op        6912 B/op          48 allocs/op\nBenchmarkHttpRouter_ParseAll            933208          1273 ns/op           0 B/op           0 allocs/op\nBenchmarkHttpTreeMux_ParseAll           107191         11554 ns/op        5728 B/op          51 allocs/op\nBenchmarkKocha_ParseAll                 184862          6225 ns/op        1112 B/op          54 allocs/op\nBenchmarkLARS_ParseAll                  644546          1858 ns/op           0 B/op           0 allocs/op\nBenchmarkMacaron_ParseAll                26145         46484 ns/op       19136 B/op         208 allocs/op\nBenchmarkMartini_ParseAll                10000        121838 ns/op       25072 B/op         253 allocs/op\nBenchmarkPat_ParseAll                    25417         47196 ns/op       15216 B/op         308 allocs/op\nBenchmarkPossum_ParseAll                 58550         20735 ns/op       10816 B/op          78 allocs/op\nBenchmarkR2router_ParseAll               72732         16584 ns/op        8352 B/op         120 allocs/op\nBenchmarkRivet_ParseAll                 281365          4968 ns/op         912 B/op          16 allocs/op\nBenchmarkTango_ParseAll                  42831         28668 ns/op        7168 B/op         208 allocs/op\nBenchmarkTigerTonic_ParseAll             23774         49972 ns/op       16048 B/op         332 allocs/op\nBenchmarkTraffic_ParseAll                10000        104679 ns/op       45520 B/op         605 allocs/op\nBenchmarkVulcan_ParseAll                 64810         18108 ns/op        2548 B/op          78 allocs/op\n```\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 38.94921875,
          "content": "# Gin ChangeLog\n\n## Gin v1.10.0\n\n### Features\n\n* feat(auth): add proxy-server authentication (#3877) (@EndlessParadox1)\n* feat(bind): ShouldBindBodyWith shortcut and change doc (#3871) (@RedCrazyGhost)\n* feat(binding): Support custom BindUnmarshaler for binding. (#3933) (@dkkb)\n* feat(binding): support override default binding implement (#3514) (@ssfyn)\n* feat(engine): Added `OptionFunc` and `With` (#3572) (@flc1125)\n* feat(logger): ability to skip logs based on user-defined logic (#3593) (@palvaneh)\n\n### Bug fixes\n\n* Revert \"fix(uri): query binding bug (#3236)\" (#3899) (@appleboy)\n* fix(binding): binding error while not upload file (#3819) (#3820) (@clearcodecn)\n* fix(binding): dereference pointer to struct (#3199) (@echovl)\n* fix(context): make context Value method adhere to Go standards (#3897) (@FarmerChillax)\n* fix(engine): fix unit test (#3878) (@flc1125)\n* fix(header): Allow header according to RFC 7231 (HTTP 405) (#3759) (@Crocmagnon)\n* fix(route): Add fullPath in context copy (#3784) (@KarthikReddyPuli)\n* fix(router): catch-all conflicting wildcard (#3812) (@FirePing32)\n* fix(sec): upgrade golang.org/x/crypto to 0.17.0 (#3832) (@chncaption)\n* fix(tree): correctly expand the capacity of params (#3502) (@georgijd-form3)\n* fix(uri): query binding bug (#3236) (@illiafox)\n* fix: Add pointer support for url query params (#3659) (#3666) (@omkar-foss)\n* fix: protect Context.Keys map when call Copy method (#3873) (@kingcanfish)\n \n### Enhancements\n\n* chore(CI): update release args (#3595) (@qloog)\n* chore(IP): add TrustedPlatform constant for Fly.io. (#3839) (@ab)\n* chore(debug): add ability to override the debugPrint statement (#2337) (@josegonzalez)\n* chore(deps): update dependencies to latest versions (#3835) (@appleboy)\n* chore(header): Add support for RFC 9512: application/yaml (#3851) (@vincentbernat)\n* chore(http): use white color for HTTP 1XX (#3741) (@viralparmarme)\n* chore(optimize): the ShouldBindUri method of the Context struct (#3911) (@1911860538)\n* chore(perf): Optimize the Copy method of the Context struct (#3859) (@1911860538)\n* chore(refactor): modify interface check way (#3855) (@demoManito)\n* chore(request): check reader if it's nil before reading (#3419) (@noahyao1024)\n* chore(security): upgrade Protobuf for CVE-2024-24786 (#3893) (@Fotkurz)\n* chore: refactor CI and update dependencies (#3848) (@appleboy)\n* chore: refactor configuration files for better readability (#3951) (@appleboy)\n* chore: update GitHub Actions configuration (#3792) (@appleboy)\n* chore: update changelog categories and improve documentation (#3917) (@appleboy)\n* chore: update dependencies to latest versions (#3694) (@appleboy)\n* chore: update external dependencies to latest versions (#3950) (@appleboy)\n* chore: update various Go dependencies to latest versions (#3901) (@appleboy)\n\n### Build process updates\n\n* build(codecov): Added a codecov configuration (#3891) (@flc1125)\n* ci(Makefile): vet command add .PHONY (#3915) (@imalasong)\n* ci(lint): update tooling and workflows for consistency (#3834) (@appleboy)\n* ci(release): refactor changelog regex patterns and exclusions (#3914) (@appleboy)\n* ci(testing): add go1.22 version (#3842) (@appleboy)\n\n### Documentation updates\n\n* docs(context): Added deprecation comments to BindWith (#3880) (@flc1125)\n* docs(middleware): comments to function `BasicAuthForProxy` (#3881) (@EndlessParadox1)\n* docs: Add document  to constant `AuthProxyUserKey` and  `BasicAuthForProxy`. (#3887) (@EndlessParadox1)\n* docs: fix typo in comment (#3868) (@testwill)\n* docs: fix typo in function documentation (#3872) (@TotomiEcio)\n* docs: remove redundant comments (#3765) (@WeiTheShinobi)\n* feat: update version constant to v1.10.0 (#3952) (@appleboy)\n\n### Others\n\n* Upgrade golang.org/x/net -> v0.13.0 (#3684) (@cpcf)\n* test(git): gitignore add develop tools (#3370) (@demoManito)\n* test(http): use constant instead of numeric literal (#3863) (@testwill)\n* test(path): Optimize unit test execution results (#3883) (@flc1125)\n* test(render): increased unit tests coverage (#3691) (@araujo88)\n\n## Gin v1.9.1\n\n### BUG FIXES\n\n* fix Request.Context() checks [#3512](https://github.com/gin-gonic/gin/pull/3512)\n\n### SECURITY\n\n* fix lack of escaping of filename in Content-Disposition [#3556](https://github.com/gin-gonic/gin/pull/3556) \n\n### ENHANCEMENTS\n\n* refactor: use bytes.ReplaceAll directly [#3455](https://github.com/gin-gonic/gin/pull/3455)\n* convert strings and slices using the officially recommended way [#3344](https://github.com/gin-gonic/gin/pull/3344)\n* improve render code coverage [#3525](https://github.com/gin-gonic/gin/pull/3525)\n\n### DOCS\n\n* docs: changed documentation link for trusted proxies [#3575](https://github.com/gin-gonic/gin/pull/3575)\n* chore: improve linting, testing, and GitHub Actions setup [#3583](https://github.com/gin-gonic/gin/pull/3583)\n\n## Gin v1.9.0\n\n### BREAK CHANGES\n\n* Stop useless panicking in context and render [#2150](https://github.com/gin-gonic/gin/pull/2150)\n\n### BUG FIXES\n\n* fix(router): tree bug where loop index is not decremented. [#3460](https://github.com/gin-gonic/gin/pull/3460)\n* fix(context): panic on NegotiateFormat - index out of range [#3397](https://github.com/gin-gonic/gin/pull/3397)\n* Add escape logic for header [#3500](https://github.com/gin-gonic/gin/pull/3500) and [#3503](https://github.com/gin-gonic/gin/pull/3503)\n\n### SECURITY\n\n* Fix the GO-2022-0969 and GO-2022-0288 vulnerabilities [#3333](https://github.com/gin-gonic/gin/pull/3333)\n* fix(security): vulnerability GO-2023-1571 [#3505](https://github.com/gin-gonic/gin/pull/3505)\n\n### ENHANCEMENTS\n\n* feat: add sonic json support [#3184](https://github.com/gin-gonic/gin/pull/3184)\n* chore(file): Creates a directory named path [#3316](https://github.com/gin-gonic/gin/pull/3316)\n* fix: modify interface check way [#3327](https://github.com/gin-gonic/gin/pull/3327)\n* remove deprecated of package io/ioutil [#3395](https://github.com/gin-gonic/gin/pull/3395)\n* refactor: avoid calling strings.ToLower twice [#3343](https://github.com/gin-gonic/gin/pull/3433)\n* console logger HTTP status code bug fixed [#3453](https://github.com/gin-gonic/gin/pull/3453)\n* chore(yaml): upgrade dependency to v3 version [#3456](https://github.com/gin-gonic/gin/pull/3456)\n* chore(router): match method added to routergroup for multiple HTTP methods supporting [#3464](https://github.com/gin-gonic/gin/pull/3464)\n* chore(http): add support for go1.20 http.rwUnwrapper to gin.responseWriter [#3489](https://github.com/gin-gonic/gin/pull/3489)\n\n### DOCS\n\n* docs: update markdown format [#3260](https://github.com/gin-gonic/gin/pull/3260)\n* docs(readme): Add the TOML rendering example [#3400](https://github.com/gin-gonic/gin/pull/3400)\n* docs(readme): move more example to docs/doc.md [#3449](https://github.com/gin-gonic/gin/pull/3449)\n* docs: update markdown format [#3446](https://github.com/gin-gonic/gin/pull/3446)\n\n## Gin v1.8.2\n\n### BUG FIXES\n\n* fix(route): redirectSlash bug ([#3227]((https://github.com/gin-gonic/gin/pull/3227)))\n* fix(engine): missing route params for CreateTestContext ([#2778]((https://github.com/gin-gonic/gin/pull/2778))) ([#2803]((https://github.com/gin-gonic/gin/pull/2803)))\n\n### SECURITY\n\n* Fix the GO-2022-1144 vulnerability ([#3432]((https://github.com/gin-gonic/gin/pull/3432)))\n\n## Gin v1.8.1\n\n### ENHANCEMENTS\n\n* feat(context): add ContextWithFallback feature flag [#3172](https://github.com/gin-gonic/gin/pull/3172)\n\n## Gin v1.8.0\n\n### BREAK CHANGES\n\n* TrustedProxies: Add default IPv6 support and refactor [#2967](https://github.com/gin-gonic/gin/pull/2967). Please replace `RemoteIP() (net.IP, bool)` with `RemoteIP() net.IP`\n* gin.Context with fallback value from gin.Context.Request.Context() [#2751](https://github.com/gin-gonic/gin/pull/2751)\n\n### BUG FIXES\n\n* Fixed SetOutput() panics on go 1.17 [#2861](https://github.com/gin-gonic/gin/pull/2861)\n* Fix: wrong when wildcard follows named param [#2983](https://github.com/gin-gonic/gin/pull/2983)\n* Fix: missing sameSite when do context.reset() [#3123](https://github.com/gin-gonic/gin/pull/3123)\n\n### ENHANCEMENTS\n\n* Use Header() instead of deprecated HeaderMap [#2694](https://github.com/gin-gonic/gin/pull/2694)\n* RouterGroup.Handle regular match optimization of http method [#2685](https://github.com/gin-gonic/gin/pull/2685)\n* Add support go-json, another drop-in json replacement [#2680](https://github.com/gin-gonic/gin/pull/2680)\n* Use errors.New to replace fmt.Errorf will much better [#2707](https://github.com/gin-gonic/gin/pull/2707)\n* Use Duration.Truncate for truncating precision [#2711](https://github.com/gin-gonic/gin/pull/2711)\n* Get client IP when using Cloudflare [#2723](https://github.com/gin-gonic/gin/pull/2723)\n* Optimize code adjust [#2700](https://github.com/gin-gonic/gin/pull/2700/files)\n* Optimize code and reduce code cyclomatic complexity [#2737](https://github.com/gin-gonic/gin/pull/2737)\n* Improve sliceValidateError.Error performance [#2765](https://github.com/gin-gonic/gin/pull/2765)\n* Support custom struct tag [#2720](https://github.com/gin-gonic/gin/pull/2720)\n* Improve router group tests [#2787](https://github.com/gin-gonic/gin/pull/2787)\n* Fallback Context.Deadline() Context.Done() Context.Err() to Context.Request.Context() [#2769](https://github.com/gin-gonic/gin/pull/2769)\n* Some codes optimize [#2830](https://github.com/gin-gonic/gin/pull/2830) [#2834](https://github.com/gin-gonic/gin/pull/2834) [#2838](https://github.com/gin-gonic/gin/pull/2838) [#2837](https://github.com/gin-gonic/gin/pull/2837) [#2788](https://github.com/gin-gonic/gin/pull/2788) [#2848](https://github.com/gin-gonic/gin/pull/2848) [#2851](https://github.com/gin-gonic/gin/pull/2851) [#2701](https://github.com/gin-gonic/gin/pull/2701)\n* TrustedProxies: Add default IPv6 support and refactor [#2967](https://github.com/gin-gonic/gin/pull/2967)\n* Test(route): expose performRequest func [#3012](https://github.com/gin-gonic/gin/pull/3012)\n* Support h2c with prior knowledge [#1398](https://github.com/gin-gonic/gin/pull/1398)\n* Feat attachment filename support utf8 [#3071](https://github.com/gin-gonic/gin/pull/3071)\n* Feat: add StaticFileFS [#2749](https://github.com/gin-gonic/gin/pull/2749)\n* Feat(context): return GIN Context from Value method [#2825](https://github.com/gin-gonic/gin/pull/2825)\n* Feat: automatically SetMode to TestMode when run go test [#3139](https://github.com/gin-gonic/gin/pull/3139)\n* Add TOML bining for gin [#3081](https://github.com/gin-gonic/gin/pull/3081)\n* IPv6 add default trusted proxies [#3033](https://github.com/gin-gonic/gin/pull/3033)\n\n### DOCS\n\n* Add note about nomsgpack tag to the readme [#2703](https://github.com/gin-gonic/gin/pull/2703)\n\n## Gin v1.7.7\n\n### BUG FIXES\n\n* Fixed X-Forwarded-For unsafe handling of CVE-2020-28483 [#2844](https://github.com/gin-gonic/gin/pull/2844), closed issue [#2862](https://github.com/gin-gonic/gin/issues/2862).\n* Tree: updated the code logic for `latestNode` [#2897](https://github.com/gin-gonic/gin/pull/2897), closed issue [#2894](https://github.com/gin-gonic/gin/issues/2894) [#2878](https://github.com/gin-gonic/gin/issues/2878).\n* Tree: fixed the misplacement of adding slashes [#2847](https://github.com/gin-gonic/gin/pull/2847), closed issue [#2843](https://github.com/gin-gonic/gin/issues/2843).\n* Tree: fixed tsr with mixed static and wildcard paths [#2924](https://github.com/gin-gonic/gin/pull/2924), closed issue [#2918](https://github.com/gin-gonic/gin/issues/2918).\n\n### ENHANCEMENTS\n\n* TrustedProxies: make it backward-compatible [#2887](https://github.com/gin-gonic/gin/pull/2887), closed issue [#2819](https://github.com/gin-gonic/gin/issues/2819).\n* TrustedPlatform: provide custom options for another CDN services [#2906](https://github.com/gin-gonic/gin/pull/2906).\n\n### DOCS\n\n* NoMethod: added usage annotation ([#2832](https://github.com/gin-gonic/gin/pull/2832#issuecomment-929954463)).\n\n## Gin v1.7.6\n\n### BUG FIXES\n\n* bump new release to fix v1.7.5 release error by using v1.7.4 codes.\n\n## Gin v1.7.4\n\n### BUG FIXES\n\n* bump new release to fix checksum mismatch\n\n## Gin v1.7.3\n\n### BUG FIXES\n\n* fix level 1 router match [#2767](https://github.com/gin-gonic/gin/issues/2767), [#2796](https://github.com/gin-gonic/gin/issues/2796)\n\n## Gin v1.7.2\n\n### BUG FIXES\n\n* Fix conflict between param and exact path [#2706](https://github.com/gin-gonic/gin/issues/2706). Close issue [#2682](https://github.com/gin-gonic/gin/issues/2682) [#2696](https://github.com/gin-gonic/gin/issues/2696).\n\n## Gin v1.7.1\n\n### BUG FIXES\n\n* fix: data race with trustedCIDRs from [#2674](https://github.com/gin-gonic/gin/issues/2674)([#2675](https://github.com/gin-gonic/gin/pull/2675))\n\n## Gin v1.7.0\n\n### BUG FIXES\n\n* fix compile error from [#2572](https://github.com/gin-gonic/gin/pull/2572) ([#2600](https://github.com/gin-gonic/gin/pull/2600))\n* fix: print headers without Authorization header on broken pipe ([#2528](https://github.com/gin-gonic/gin/pull/2528))\n* fix(tree): reassign fullpath when register new node ([#2366](https://github.com/gin-gonic/gin/pull/2366))\n\n### ENHANCEMENTS\n\n* Support params and exact routes without creating conflicts ([#2663](https://github.com/gin-gonic/gin/pull/2663))\n* chore: improve render string performance ([#2365](https://github.com/gin-gonic/gin/pull/2365))\n* Sync route tree to httprouter latest code ([#2368](https://github.com/gin-gonic/gin/pull/2368))\n* chore: rename getQueryCache/getFormCache to initQueryCache/initFormCa ([#2375](https://github.com/gin-gonic/gin/pull/2375))\n* chore(performance): improve countParams ([#2378](https://github.com/gin-gonic/gin/pull/2378))\n* Remove some functions that have the same effect as the bytes package ([#2387](https://github.com/gin-gonic/gin/pull/2387))\n* update:SetMode function ([#2321](https://github.com/gin-gonic/gin/pull/2321))\n* remove an unused type SecureJSONPrefix ([#2391](https://github.com/gin-gonic/gin/pull/2391))\n* Add a redirect sample for POST method ([#2389](https://github.com/gin-gonic/gin/pull/2389))\n* Add CustomRecovery builtin middleware ([#2322](https://github.com/gin-gonic/gin/pull/2322))\n* binding: avoid 2038 problem on 32-bit architectures ([#2450](https://github.com/gin-gonic/gin/pull/2450))\n* Prevent panic in Context.GetQuery() when there is no Request ([#2412](https://github.com/gin-gonic/gin/pull/2412))\n* Add GetUint and GetUint64 method on gin.context ([#2487](https://github.com/gin-gonic/gin/pull/2487))\n* update content-disposition header to MIME-style ([#2512](https://github.com/gin-gonic/gin/pull/2512))\n* reduce allocs and improve the render `WriteString` ([#2508](https://github.com/gin-gonic/gin/pull/2508))\n* implement \".Unwrap() error\" on Error type ([#2525](https://github.com/gin-gonic/gin/pull/2525)) ([#2526](https://github.com/gin-gonic/gin/pull/2526))\n* Allow bind with a map[string]string ([#2484](https://github.com/gin-gonic/gin/pull/2484))\n* chore: update tree ([#2371](https://github.com/gin-gonic/gin/pull/2371))\n* Support binding for slice/array obj [Rewrite] ([#2302](https://github.com/gin-gonic/gin/pull/2302))\n* basic auth: fix timing oracle ([#2609](https://github.com/gin-gonic/gin/pull/2609))\n* Add mixed param and non-param paths (port of httprouter[#329](https://github.com/gin-gonic/gin/pull/329)) ([#2663](https://github.com/gin-gonic/gin/pull/2663))\n* feat(engine): add trustedproxies and remoteIP ([#2632](https://github.com/gin-gonic/gin/pull/2632))\n\n## Gin v1.6.3\n\n### ENHANCEMENTS\n\n  * Improve performance: Change `*sync.RWMutex` to `sync.RWMutex` in context. [#2351](https://github.com/gin-gonic/gin/pull/2351)\n\n## Gin v1.6.2\n\n### BUG FIXES\n\n  * fix missing initial sync.RWMutex [#2305](https://github.com/gin-gonic/gin/pull/2305)\n\n### ENHANCEMENTS\n\n  * Add set samesite in cookie. [#2306](https://github.com/gin-gonic/gin/pull/2306)\n\n## Gin v1.6.1\n\n### BUG FIXES\n\n  * Revert \"fix accept incoming network connections\" [#2294](https://github.com/gin-gonic/gin/pull/2294)\n\n## Gin v1.6.0\n\n### BREAKING\n\n  * chore(performance): Improve performance for adding RemoveExtraSlash flag [#2159](https://github.com/gin-gonic/gin/pull/2159)\n  * drop support govendor [#2148](https://github.com/gin-gonic/gin/pull/2148)\n  * Added support for SameSite cookie flag [#1615](https://github.com/gin-gonic/gin/pull/1615)\n\n### FEATURES\n\n  * add yaml negotiation [#2220](https://github.com/gin-gonic/gin/pull/2220)\n  * FileFromFS [#2112](https://github.com/gin-gonic/gin/pull/2112)\n\n### BUG FIXES\n\n  * Unix Socket Handling [#2280](https://github.com/gin-gonic/gin/pull/2280)\n  * Use json marshall in context json to fix breaking new line issue. Fixes #2209 [#2228](https://github.com/gin-gonic/gin/pull/2228)\n  * fix accept incoming network connections [#2216](https://github.com/gin-gonic/gin/pull/2216)\n  * Fixed a bug in the calculation of the maximum number of parameters [#2166](https://github.com/gin-gonic/gin/pull/2166)\n  * [FIX] allow empty headers on DataFromReader [#2121](https://github.com/gin-gonic/gin/pull/2121)\n  * Add mutex for protect Context.Keys map [#1391](https://github.com/gin-gonic/gin/pull/1391)\n\n### ENHANCEMENTS\n\n  * Add mitigation for log injection [#2277](https://github.com/gin-gonic/gin/pull/2277)\n  * tree: range over nodes values [#2229](https://github.com/gin-gonic/gin/pull/2229)\n  * tree: remove duplicate assignment [#2222](https://github.com/gin-gonic/gin/pull/2222)\n  * chore: upgrade go-isatty and json-iterator/go [#2215](https://github.com/gin-gonic/gin/pull/2215)\n  * path: sync code with httprouter [#2212](https://github.com/gin-gonic/gin/pull/2212)\n  * Use zero-copy approach to convert types between string and byte slice [#2206](https://github.com/gin-gonic/gin/pull/2206)\n  * Reuse bytes when cleaning the URL paths [#2179](https://github.com/gin-gonic/gin/pull/2179)\n  * tree: remove one else statement [#2177](https://github.com/gin-gonic/gin/pull/2177)\n  * tree: sync httprouter update (#2173) (#2172) [#2171](https://github.com/gin-gonic/gin/pull/2171)\n  * tree: sync part httprouter codes and reduce if/else [#2163](https://github.com/gin-gonic/gin/pull/2163)\n  * use http method constant [#2155](https://github.com/gin-gonic/gin/pull/2155)\n  * upgrade go-validator to v10 [#2149](https://github.com/gin-gonic/gin/pull/2149)\n  * Refactor redirect request in gin.go [#1970](https://github.com/gin-gonic/gin/pull/1970)\n  * Add build tag nomsgpack [#1852](https://github.com/gin-gonic/gin/pull/1852)\n\n### DOCS\n\n  * docs(path): improve comments [#2223](https://github.com/gin-gonic/gin/pull/2223)\n  * Renew README to fit the modification of SetCookie method [#2217](https://github.com/gin-gonic/gin/pull/2217)\n  * Fix spelling [#2202](https://github.com/gin-gonic/gin/pull/2202)\n  * Remove broken link from README. [#2198](https://github.com/gin-gonic/gin/pull/2198)\n  * Update docs on Context.Done(), Context.Deadline() and Context.Err() [#2196](https://github.com/gin-gonic/gin/pull/2196)\n  * Update validator to v10 [#2190](https://github.com/gin-gonic/gin/pull/2190)\n  * upgrade go-validator to v10 for README [#2189](https://github.com/gin-gonic/gin/pull/2189)\n  * Update to currently output [#2188](https://github.com/gin-gonic/gin/pull/2188)\n  * Fix \"Custom Validators\" example [#2186](https://github.com/gin-gonic/gin/pull/2186)\n  * Add project to README [#2165](https://github.com/gin-gonic/gin/pull/2165)\n  * docs(benchmarks): for gin v1.5 [#2153](https://github.com/gin-gonic/gin/pull/2153)\n  * Changed wording for clarity in README.md [#2122](https://github.com/gin-gonic/gin/pull/2122)\n\n### MISC\n\n  * ci support go1.14 [#2262](https://github.com/gin-gonic/gin/pull/2262)\n  * chore: upgrade depend version [#2231](https://github.com/gin-gonic/gin/pull/2231)\n  * Drop support go1.10 [#2147](https://github.com/gin-gonic/gin/pull/2147)\n  * fix comment in `mode.go` [#2129](https://github.com/gin-gonic/gin/pull/2129)\n\n## Gin v1.5.0\n\n- [FIX] Use DefaultWriter and DefaultErrorWriter for debug messages [#1891](https://github.com/gin-gonic/gin/pull/1891)\n- [NEW] Now you can parse the inline lowercase start structure [#1893](https://github.com/gin-gonic/gin/pull/1893)\n- [FIX] Some code improvements [#1909](https://github.com/gin-gonic/gin/pull/1909)\n- [FIX] Use encode replace json marshal increase json encoder speed [#1546](https://github.com/gin-gonic/gin/pull/1546)\n- [NEW] Hold matched route full path in the Context [#1826](https://github.com/gin-gonic/gin/pull/1826)\n- [FIX] Fix context.Params race condition on Copy() [#1841](https://github.com/gin-gonic/gin/pull/1841)\n- [NEW] Add context param query cache [#1450](https://github.com/gin-gonic/gin/pull/1450)\n- [FIX] Improve GetQueryMap performance [#1918](https://github.com/gin-gonic/gin/pull/1918)\n- [FIX] Improve get post data [#1920](https://github.com/gin-gonic/gin/pull/1920)\n- [FIX] Use context instead of x/net/context [#1922](https://github.com/gin-gonic/gin/pull/1922)\n- [FIX] Attempt to fix PostForm cache bug [#1931](https://github.com/gin-gonic/gin/pull/1931)\n- [NEW] Add support of multipart multi files [#1949](https://github.com/gin-gonic/gin/pull/1949)\n- [NEW] Support bind http header param [#1957](https://github.com/gin-gonic/gin/pull/1957)\n- [FIX] Drop support for go1.8 and go1.9 [#1933](https://github.com/gin-gonic/gin/pull/1933)\n- [FIX] Bugfix for the FullPath feature [#1919](https://github.com/gin-gonic/gin/pull/1919)\n- [FIX] Gin1.5 bytes.Buffer to strings.Builder [#1939](https://github.com/gin-gonic/gin/pull/1939)\n- [FIX] Upgrade github.com/ugorji/go/codec [#1969](https://github.com/gin-gonic/gin/pull/1969)\n- [NEW] Support bind unix time [#1980](https://github.com/gin-gonic/gin/pull/1980)\n- [FIX] Simplify code [#2004](https://github.com/gin-gonic/gin/pull/2004)\n- [NEW] Support negative Content-Length in DataFromReader [#1981](https://github.com/gin-gonic/gin/pull/1981)\n- [FIX] Identify terminal on a RISC-V architecture for auto-colored logs [#2019](https://github.com/gin-gonic/gin/pull/2019)\n- [BREAKING] `Context.JSONP()` now expects a semicolon (`;`) at the end [#2007](https://github.com/gin-gonic/gin/pull/2007)\n- [BREAKING] Upgrade default `binding.Validator` to v9 (see [its changelog](https://github.com/go-playground/validator/releases/tag/v9.0.0)) [#1015](https://github.com/gin-gonic/gin/pull/1015)\n- [NEW] Add `DisallowUnknownFields()` in `Context.BindJSON()` [#2028](https://github.com/gin-gonic/gin/pull/2028)\n- [NEW] Use specific `net.Listener` with `Engine.RunListener()` [#2023](https://github.com/gin-gonic/gin/pull/2023)\n- [FIX] Fix some typo [#2079](https://github.com/gin-gonic/gin/pull/2079) [#2080](https://github.com/gin-gonic/gin/pull/2080)\n- [FIX] Relocate binding body tests [#2086](https://github.com/gin-gonic/gin/pull/2086)\n- [FIX] Use Writer in Context.Status [#1606](https://github.com/gin-gonic/gin/pull/1606)\n- [FIX] `Engine.RunUnix()` now returns the error if it can't change the file mode [#2093](https://github.com/gin-gonic/gin/pull/2093)\n- [FIX] `RouterGroup.StaticFS()` leaked files. Now it closes them. [#2118](https://github.com/gin-gonic/gin/pull/2118)\n- [FIX] `Context.Request.FormFile` leaked file. Now it closes it. [#2114](https://github.com/gin-gonic/gin/pull/2114)\n- [FIX] Ignore walking on `form:\"-\"` mapping [#1943](https://github.com/gin-gonic/gin/pull/1943)\n\n### Gin v1.4.0\n\n- [NEW] Support for [Go Modules](https://github.com/golang/go/wiki/Modules)  [#1569](https://github.com/gin-gonic/gin/pull/1569)\n- [NEW] Refactor of form mapping multipart request [#1829](https://github.com/gin-gonic/gin/pull/1829)\n- [FIX] Truncate Latency precision in long running request [#1830](https://github.com/gin-gonic/gin/pull/1830)\n- [FIX] IsTerm flag should not be affected by DisableConsoleColor method. [#1802](https://github.com/gin-gonic/gin/pull/1802)\n- [NEW] Supporting file binding [#1264](https://github.com/gin-gonic/gin/pull/1264)\n- [NEW] Add support for mapping arrays [#1797](https://github.com/gin-gonic/gin/pull/1797)\n- [FIX] Readme updates [#1793](https://github.com/gin-gonic/gin/pull/1793) [#1788](https://github.com/gin-gonic/gin/pull/1788) [1789](https://github.com/gin-gonic/gin/pull/1789)\n- [FIX] StaticFS: Fixed Logging two log lines on 404.  [#1805](https://github.com/gin-gonic/gin/pull/1805), [#1804](https://github.com/gin-gonic/gin/pull/1804)\n- [NEW] Make context.Keys available as LogFormatterParams [#1779](https://github.com/gin-gonic/gin/pull/1779)\n- [NEW] Use internal/json for Marshal/Unmarshal [#1791](https://github.com/gin-gonic/gin/pull/1791)\n- [NEW] Support mapping time.Duration [#1794](https://github.com/gin-gonic/gin/pull/1794)\n- [NEW] Refactor form mappings [#1749](https://github.com/gin-gonic/gin/pull/1749)\n- [NEW] Added flag to context.Stream indicates if client disconnected in middle of stream [#1252](https://github.com/gin-gonic/gin/pull/1252)\n- [FIX] Moved [examples](https://github.com/gin-gonic/examples) to stand alone Repo [#1775](https://github.com/gin-gonic/gin/pull/1775)\n- [NEW] Extend context.File to allow for the content-disposition attachments via a new method context.Attachment [#1260](https://github.com/gin-gonic/gin/pull/1260)\n- [FIX] Support HTTP content negotiation wildcards [#1112](https://github.com/gin-gonic/gin/pull/1112)\n- [NEW] Add prefix from X-Forwarded-Prefix in redirectTrailingSlash [#1238](https://github.com/gin-gonic/gin/pull/1238)\n- [FIX] context.Copy() race condition [#1020](https://github.com/gin-gonic/gin/pull/1020)\n- [NEW] Add context.HandlerNames() [#1729](https://github.com/gin-gonic/gin/pull/1729)\n- [FIX] Change color methods to public in the defaultLogger. [#1771](https://github.com/gin-gonic/gin/pull/1771)\n- [FIX] Update writeHeaders method to use http.Header.Set [#1722](https://github.com/gin-gonic/gin/pull/1722)\n- [NEW] Add response size to LogFormatterParams [#1752](https://github.com/gin-gonic/gin/pull/1752)\n- [NEW] Allow ignoring field on form mapping [#1733](https://github.com/gin-gonic/gin/pull/1733)\n- [NEW] Add a function to force color in console output. [#1724](https://github.com/gin-gonic/gin/pull/1724)\n- [FIX] Context.Next() - recheck len of handlers on every iteration. [#1745](https://github.com/gin-gonic/gin/pull/1745)\n- [FIX] Fix all errcheck warnings [#1739](https://github.com/gin-gonic/gin/pull/1739) [#1653](https://github.com/gin-gonic/gin/pull/1653)\n- [NEW] context: inherits context cancellation and deadline from http.Request context for Go>=1.7 [#1690](https://github.com/gin-gonic/gin/pull/1690)\n- [NEW] Binding for URL Params [#1694](https://github.com/gin-gonic/gin/pull/1694)\n- [NEW] Add LoggerWithFormatter method [#1677](https://github.com/gin-gonic/gin/pull/1677)\n- [FIX] CI testing updates [#1671](https://github.com/gin-gonic/gin/pull/1671) [#1670](https://github.com/gin-gonic/gin/pull/1670) [#1682](https://github.com/gin-gonic/gin/pull/1682) [#1669](https://github.com/gin-gonic/gin/pull/1669)\n- [FIX] StaticFS(): Send 404 when path does not exist [#1663](https://github.com/gin-gonic/gin/pull/1663)\n- [FIX] Handle nil body for JSON binding [#1638](https://github.com/gin-gonic/gin/pull/1638)\n- [FIX] Support bind uri param [#1612](https://github.com/gin-gonic/gin/pull/1612)\n- [FIX] recovery: fix issue with syscall import on google app engine [#1640](https://github.com/gin-gonic/gin/pull/1640)\n- [FIX] Make sure the debug log contains line breaks [#1650](https://github.com/gin-gonic/gin/pull/1650)\n- [FIX] Panic stack trace being printed during recovery of broken pipe [#1089](https://github.com/gin-gonic/gin/pull/1089) [#1259](https://github.com/gin-gonic/gin/pull/1259)\n- [NEW] RunFd method to run http.Server through a file descriptor [#1609](https://github.com/gin-gonic/gin/pull/1609)\n- [NEW] Yaml binding support [#1618](https://github.com/gin-gonic/gin/pull/1618)\n- [FIX] Pass MaxMultipartMemory when FormFile is called [#1600](https://github.com/gin-gonic/gin/pull/1600)\n- [FIX] LoadHTML* tests [#1559](https://github.com/gin-gonic/gin/pull/1559)\n- [FIX] Removed use of sync.pool from HandleContext [#1565](https://github.com/gin-gonic/gin/pull/1565)\n- [FIX] Format output log to os.Stderr [#1571](https://github.com/gin-gonic/gin/pull/1571)\n- [FIX] Make logger use a yellow background and a darkgray text for legibility [#1570](https://github.com/gin-gonic/gin/pull/1570)\n- [FIX] Remove sensitive request information from panic log. [#1370](https://github.com/gin-gonic/gin/pull/1370)\n- [FIX] log.Println() does not print timestamp [#829](https://github.com/gin-gonic/gin/pull/829) [#1560](https://github.com/gin-gonic/gin/pull/1560)\n- [NEW] Add PureJSON renderer [#694](https://github.com/gin-gonic/gin/pull/694)\n- [FIX] Add missing copyright and update if/else [#1497](https://github.com/gin-gonic/gin/pull/1497)\n- [FIX] Update msgpack usage [#1498](https://github.com/gin-gonic/gin/pull/1498)\n- [FIX] Use protobuf on render [#1496](https://github.com/gin-gonic/gin/pull/1496)\n- [FIX] Add support for Protobuf format response [#1479](https://github.com/gin-gonic/gin/pull/1479)\n- [NEW] Set default time format in form binding [#1487](https://github.com/gin-gonic/gin/pull/1487)\n- [FIX] Add BindXML and ShouldBindXML [#1485](https://github.com/gin-gonic/gin/pull/1485)\n- [NEW] Upgrade dependency libraries [#1491](https://github.com/gin-gonic/gin/pull/1491)\n\n\n## Gin v1.3.0\n\n- [NEW] Add [`func (*Context) QueryMap`](https://godoc.org/github.com/gin-gonic/gin#Context.QueryMap), [`func (*Context) GetQueryMap`](https://godoc.org/github.com/gin-gonic/gin#Context.GetQueryMap), [`func (*Context) PostFormMap`](https://godoc.org/github.com/gin-gonic/gin#Context.PostFormMap) and [`func (*Context) GetPostFormMap`](https://godoc.org/github.com/gin-gonic/gin#Context.GetPostFormMap) to support `type map[string]string` as query string or form parameters, see [#1383](https://github.com/gin-gonic/gin/pull/1383)\n- [NEW] Add [`func (*Context) AsciiJSON`](https://godoc.org/github.com/gin-gonic/gin#Context.AsciiJSON), see [#1358](https://github.com/gin-gonic/gin/pull/1358)\n- [NEW] Add `Pusher()` in [`type ResponseWriter`](https://godoc.org/github.com/gin-gonic/gin#ResponseWriter) for supporting http2 push, see [#1273](https://github.com/gin-gonic/gin/pull/1273)\n- [NEW] Add [`func (*Context) DataFromReader`](https://godoc.org/github.com/gin-gonic/gin#Context.DataFromReader) for serving dynamic data, see [#1304](https://github.com/gin-gonic/gin/pull/1304)\n- [NEW] Add [`func (*Context) ShouldBindBodyWith`](https://godoc.org/github.com/gin-gonic/gin#Context.ShouldBindBodyWith) allowing to call binding multiple times, see [#1341](https://github.com/gin-gonic/gin/pull/1341)\n- [NEW] Support pointers in form binding, see [#1336](https://github.com/gin-gonic/gin/pull/1336)\n- [NEW] Add [`func (*Context) JSONP`](https://godoc.org/github.com/gin-gonic/gin#Context.JSONP), see [#1333](https://github.com/gin-gonic/gin/pull/1333)\n- [NEW] Support default value in form binding, see [#1138](https://github.com/gin-gonic/gin/pull/1138)\n- [NEW] Expose validator engine in [`type StructValidator`](https://godoc.org/github.com/gin-gonic/gin/binding#StructValidator), see [#1277](https://github.com/gin-gonic/gin/pull/1277)\n- [NEW] Add [`func (*Context) ShouldBind`](https://godoc.org/github.com/gin-gonic/gin#Context.ShouldBind), [`func (*Context) ShouldBindQuery`](https://godoc.org/github.com/gin-gonic/gin#Context.ShouldBindQuery) and [`func (*Context) ShouldBindJSON`](https://godoc.org/github.com/gin-gonic/gin#Context.ShouldBindJSON), see [#1047](https://github.com/gin-gonic/gin/pull/1047)\n- [NEW] Add support for `time.Time` location in form binding, see [#1117](https://github.com/gin-gonic/gin/pull/1117)\n- [NEW] Add [`func (*Context) BindQuery`](https://godoc.org/github.com/gin-gonic/gin#Context.BindQuery), see [#1029](https://github.com/gin-gonic/gin/pull/1029)\n- [NEW] Make [jsonite](https://github.com/json-iterator/go) optional with build tags, see [#1026](https://github.com/gin-gonic/gin/pull/1026)\n- [NEW] Show query string in logger, see [#999](https://github.com/gin-gonic/gin/pull/999)\n- [NEW] Add [`func (*Context) SecureJSON`](https://godoc.org/github.com/gin-gonic/gin#Context.SecureJSON), see [#987](https://github.com/gin-gonic/gin/pull/987) and [#993](https://github.com/gin-gonic/gin/pull/993)\n- [DEPRECATE] `func (*Context) GetCookie` for [`func (*Context) Cookie`](https://godoc.org/github.com/gin-gonic/gin#Context.Cookie)\n- [FIX] Don't display color tags if [`func DisableConsoleColor`](https://godoc.org/github.com/gin-gonic/gin#DisableConsoleColor) called, see [#1072](https://github.com/gin-gonic/gin/pull/1072)\n- [FIX] Gin Mode `\"\"` when calling [`func Mode`](https://godoc.org/github.com/gin-gonic/gin#Mode) now returns `const DebugMode`, see [#1250](https://github.com/gin-gonic/gin/pull/1250)\n- [FIX] `Flush()` now doesn't overwrite `responseWriter` status code, see [#1460](https://github.com/gin-gonic/gin/pull/1460)\n\n## Gin 1.2.0\n\n- [NEW] Switch from godeps to govendor\n- [NEW] Add support for Let's Encrypt via gin-gonic/autotls\n- [NEW] Improve README examples and add extra at examples folder\n- [NEW] Improved support with App Engine\n- [NEW] Add custom template delimiters, see #860\n- [NEW] Add Template Func Maps, see #962\n- [NEW] Add \\*context.Handler(), see #928\n- [NEW] Add \\*context.GetRawData()\n- [NEW] Add \\*context.GetHeader() (request)\n- [NEW] Add \\*context.AbortWithStatusJSON() (JSON content type)\n- [NEW] Add \\*context.Keys type cast helpers\n- [NEW] Add \\*context.ShouldBindWith()\n- [NEW] Add \\*context.MustBindWith()\n- [NEW] Add \\*engine.SetFuncMap()\n- [DEPRECATE] On next release: \\*context.BindWith(), see #855\n- [FIX] Refactor render\n- [FIX] Reworked tests\n- [FIX] logger now supports cygwin\n- [FIX] Use X-Forwarded-For before X-Real-Ip\n- [FIX] time.Time binding (#904)\n\n## Gin 1.1.4\n\n- [NEW] Support google appengine for IsTerminal func\n\n## Gin 1.1.3\n\n- [FIX] Reverted Logger: skip ANSI color commands\n\n## Gin 1.1\n\n- [NEW] Implement QueryArray and PostArray methods\n- [NEW] Refactor GetQuery and GetPostForm\n- [NEW] Add contribution guide\n- [FIX] Corrected typos in README\n- [FIX] Removed additional Iota\n- [FIX] Changed imports to gopkg instead of github in README (#733)\n- [FIX] Logger: skip ANSI color commands if output is not a tty\n\n## Gin 1.0rc2 (...)\n\n- [PERFORMANCE] Fast path for writing Content-Type.\n- [PERFORMANCE] Much faster 404 routing\n- [PERFORMANCE] Allocation optimizations\n- [PERFORMANCE] Faster root tree lookup\n- [PERFORMANCE] Zero overhead, String() and JSON() rendering.\n- [PERFORMANCE] Faster ClientIP parsing\n- [PERFORMANCE] Much faster SSE implementation\n- [NEW] Benchmarks suite\n- [NEW] Bind validation can be disabled and replaced with custom validators.\n- [NEW] More flexible HTML render\n- [NEW] Multipart and PostForm bindings\n- [NEW] Adds method to return all the registered routes\n- [NEW] Context.HandlerName() returns the main handler's name\n- [NEW] Adds Error.IsType() helper\n- [FIX] Binding multipart form\n- [FIX] Integration tests\n- [FIX] Crash when binding non struct object in Context.\n- [FIX] RunTLS() implementation\n- [FIX] Logger() unit tests\n- [FIX] Adds SetHTMLTemplate() warning\n- [FIX] Context.IsAborted()\n- [FIX] More unit tests\n- [FIX] JSON, XML, HTML renders accept custom content-types\n- [FIX] gin.AbortIndex is unexported\n- [FIX] Better approach to avoid directory listing in StaticFS()\n- [FIX] Context.ClientIP() always returns the IP with trimmed spaces.\n- [FIX] Better warning when running in debug mode.\n- [FIX] Google App Engine integration. debugPrint does not use os.Stdout\n- [FIX] Fixes integer overflow in error type\n- [FIX] Error implements the json.Marshaller interface\n- [FIX] MIT license in every file\n\n\n## Gin 1.0rc1 (May 22, 2015)\n\n- [PERFORMANCE] Zero allocation router\n- [PERFORMANCE] Faster JSON, XML and text rendering\n- [PERFORMANCE] Custom hand optimized HttpRouter for Gin\n- [PERFORMANCE] Misc code optimizations. Inlining, tail call optimizations\n- [NEW] Built-in support for golang.org/x/net/context\n- [NEW] Any(path, handler). Create a route that matches any path\n- [NEW] Refactored rendering pipeline (faster and static typed)\n- [NEW] Refactored errors API\n- [NEW] IndentedJSON() prints pretty JSON\n- [NEW] Added gin.DefaultWriter\n- [NEW] UNIX socket support\n- [NEW] RouterGroup.BasePath is exposed\n- [NEW] JSON validation using go-validate-yourself (very powerful options)\n- [NEW] Completed suite of unit tests\n- [NEW] HTTP streaming with c.Stream()\n- [NEW] StaticFile() creates a router for serving just one file.\n- [NEW] StaticFS() has an option to disable directory listing.\n- [NEW] StaticFS() for serving static files through virtual filesystems\n- [NEW] Server-Sent Events native support\n- [NEW] WrapF() and WrapH() helpers for wrapping http.HandlerFunc and http.Handler\n- [NEW] Added LoggerWithWriter() middleware\n- [NEW] Added RecoveryWithWriter() middleware\n- [NEW] Added DefaultPostFormValue()\n- [NEW] Added DefaultFormValue()\n- [NEW] Added DefaultParamValue()\n- [FIX] BasicAuth() when using custom realm\n- [FIX] Bug when serving static files in nested routing group\n- [FIX] Redirect using built-in http.Redirect()\n- [FIX] Logger when printing the requested path\n- [FIX] Documentation typos\n- [FIX] Context.Engine renamed to Context.engine\n- [FIX] Better debugging messages\n- [FIX] ErrorLogger\n- [FIX] Debug HTTP render\n- [FIX] Refactored binding and render modules\n- [FIX] Refactored Context initialization\n- [FIX] Refactored BasicAuth()\n- [FIX] NoMethod/NoRoute handlers\n- [FIX] Hijacking http\n- [FIX] Better support for Google App Engine (using log instead of fmt)\n\n\n## Gin 0.6 (Mar 9, 2015)\n\n- [NEW] Support multipart/form-data\n- [NEW] NoMethod handler\n- [NEW] Validate sub structures\n- [NEW] Support for HTTP Realm Auth\n- [FIX] Unsigned integers in binding\n- [FIX] Improve color logger\n\n\n## Gin 0.5 (Feb 7, 2015)\n\n- [NEW] Content Negotiation\n- [FIX] Solved security bug that allow a client to spoof ip\n- [FIX] Fix unexported/ignored fields in binding\n\n\n## Gin 0.4 (Aug 21, 2014)\n\n- [NEW] Development mode\n- [NEW] Unit tests\n- [NEW] Add Content.Redirect()\n- [FIX] Deferring WriteHeader()\n- [FIX] Improved documentation for model binding\n\n\n## Gin 0.3 (Jul 18, 2014)\n\n- [PERFORMANCE] Normal log and error log are printed in the same call.\n- [PERFORMANCE] Improve performance of NoRouter()\n- [PERFORMANCE] Improve context's memory locality, reduce CPU cache faults.\n- [NEW] Flexible rendering API\n- [NEW] Add Context.File()\n- [NEW] Add shortcut RunTLS() for http.ListenAndServeTLS\n- [FIX] Rename NotFound404() to NoRoute()\n- [FIX] Errors in context are purged\n- [FIX] Adds HEAD method in Static file serving\n- [FIX] Refactors Static() file serving\n- [FIX] Using keyed initialization to fix app-engine integration\n- [FIX] Can't unmarshal JSON array, #63\n- [FIX] Renaming Context.Req to Context.Request\n- [FIX] Check application/x-www-form-urlencoded when parsing form\n\n\n## Gin 0.2b (Jul 08, 2014)\n- [PERFORMANCE] Using sync.Pool to allocatio/gc overhead\n- [NEW] Travis CI integration\n- [NEW] Completely new logger\n- [NEW] New API for serving static files. gin.Static()\n- [NEW] gin.H() can be serialized into XML\n- [NEW] Typed errors. Errors can be typed. Internet/external/custom.\n- [NEW] Support for Godeps\n- [NEW] Travis/Godocs badges in README\n- [NEW] New Bind() and BindWith() methods for parsing request body.\n- [NEW] Add Content.Copy()\n- [NEW] Add context.LastError()\n- [NEW] Add shortcut for OPTIONS HTTP method\n- [FIX] Tons of README fixes\n- [FIX] Header is written before body\n- [FIX] BasicAuth() and changes API a little bit\n- [FIX] Recovery() middleware only prints panics\n- [FIX] Context.Get() does not panic anymore. Use MustGet() instead.\n- [FIX] Multiple http.WriteHeader() in NotFound handlers\n- [FIX] Engine.Run() panics if http server can't be set up\n- [FIX] Crash when route path doesn't start with '/'\n- [FIX] Do not update header when status code is negative\n- [FIX] Setting response headers before calling WriteHeader in context.String()\n- [FIX] Add MIT license\n- [FIX] Changes behaviour of ErrorLogger() and Logger()\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.1435546875,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at teamgingonic@gmail.com. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org\n[version]: http://contributor-covenant.org/version/1/4/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.6123046875,
          "content": "## Contributing\n\n- With issues:\n  - Use the search tool before opening a new issue.\n  - Please provide source code and commit sha if you found a bug.\n  - Review existing issues and provide feedback or react to them.\n\n- With pull requests:\n  - Open your pull request against `master`\n  - Your pull request should have no more than two commits, if not you should squash them.\n  - It should pass all tests in the available continuous integration systems such as GitHub Actions.\n  - You should add/modify tests to cover your proposed code changes.\n  - If your pull request contains a new feature, please document it on the README.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0654296875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Manuel Mart√≠nez-Almeida\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.806640625,
          "content": "GO ?= go\nGOFMT ?= gofmt \"-s\"\nGO_VERSION=$(shell $(GO) version | cut -c 14- | cut -d' ' -f1 | cut -d'.' -f2)\nPACKAGES ?= $(shell $(GO) list ./...)\nVETPACKAGES ?= $(shell $(GO) list ./... | grep -v /examples/)\nGOFILES := $(shell find . -name \"*.go\")\nTESTFOLDER := $(shell $(GO) list ./... | grep -E 'gin$$|binding$$|render$$' | grep -v examples)\nTESTTAGS ?= \"\"\n\n.PHONY: test\n# Run tests to verify code functionality.\ntest:\n\techo \"mode: count\" > coverage.out\n\tfor d in $(TESTFOLDER); do \\\n\t\t$(GO) test $(TESTTAGS) -v -covermode=count -coverprofile=profile.out $$d > tmp.out; \\\n\t\tcat tmp.out; \\\n\t\tif grep -q \"^--- FAIL\" tmp.out; then \\\n\t\t\trm tmp.out; \\\n\t\t\texit 1; \\\n\t\telif grep -q \"build failed\" tmp.out; then \\\n\t\t\trm tmp.out; \\\n\t\t\texit 1; \\\n\t\telif grep -q \"setup failed\" tmp.out; then \\\n\t\t\trm tmp.out; \\\n\t\t\texit 1; \\\n\t\tfi; \\\n\t\tif [ -f profile.out ]; then \\\n\t\t\tcat profile.out | grep -v \"mode:\" >> coverage.out; \\\n\t\t\trm profile.out; \\\n\t\tfi; \\\n\tdone\n\n.PHONY: fmt\n# Ensure consistent code formatting.\nfmt:\n\t$(GOFMT) -w $(GOFILES)\n\n.PHONY: fmt-check\n# format (check only).\nfmt-check:\n\t@diff=$$($(GOFMT) -d $(GOFILES)); \\\n\tif [ -n \"$$diff\" ]; then \\\n\t\techo \"Please run 'make fmt' and commit the result:\"; \\\n\t\techo \"$${diff}\"; \\\n\t\texit 1; \\\n\tfi;\n\n.PHONY: vet\n# Examine packages and report suspicious constructs if any.\nvet:\n\t$(GO) vet $(VETPACKAGES)\n\n.PHONY: lint\n# Inspect source code for stylistic errors or potential bugs.\nlint:\n\t@hash golint > /dev/null 2>&1; if [ $$? -ne 0 ]; then \\\n\t\t$(GO) get -u golang.org/x/lint/golint; \\\n\tfi\n\tfor PKG in $(PACKAGES); do golint -set_exit_status $$PKG || exit 1; done;\n\n.PHONY: misspell\n# Correct commonly misspelled English words in source code.\nmisspell:\n\t@hash misspell > /dev/null 2>&1; if [ $$? -ne 0 ]; then \\\n\t\t$(GO) get -u github.com/client9/misspell/cmd/misspell; \\\n\tfi\n\tmisspell -w $(GOFILES)\n\n.PHONY: misspell-check\n# misspell (check only).\nmisspell-check:\n\t@hash misspell > /dev/null 2>&1; if [ $$? -ne 0 ]; then \\\n\t\t$(GO) get -u github.com/client9/misspell/cmd/misspell; \\\n\tfi\n\tmisspell -error $(GOFILES)\n\n.PHONY: tools\n# Install tools (golint and misspell).\ntools:\n\t@if [ $(GO_VERSION) -gt 15 ]; then \\\n\t\t$(GO) install golang.org/x/lint/golint@latest; \\\n\t\t$(GO) install github.com/client9/misspell/cmd/misspell@latest; \\\n\telif [ $(GO_VERSION) -lt 16 ]; then \\\n\t\t$(GO) install golang.org/x/lint/golint; \\\n\t\t$(GO) install github.com/client9/misspell/cmd/misspell; \\\n\tfi\n\n.PHONY: help\n# Help.\nhelp:\n\t@echo ''\n\t@echo 'Usage:'\n\t@echo ' make [target]'\n\t@echo ''\n\t@echo 'Targets:'\n\t@awk '/^[a-zA-Z\\-\\0-9]+:/ { \\\n\thelpMessage = match(lastLine, /^# (.*)/); \\\n\t\tif (helpMessage) { \\\n\t\t\thelpCommand = substr($$1, 0, index($$1, \":\")-1); \\\n\t\t\thelpMessage = substr(lastLine, RSTART + 2, RLENGTH); \\\n\t\t\tprintf \" - \\033[36m%-20s\\033[0m %s\\n\", helpCommand, helpMessage; \\\n\t\t} \\\n\t} \\\n\t{ lastLine = $$0 }' $(MAKEFILE_LIST)\n\n.DEFAULT_GOAL := help\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.044921875,
          "content": "# Gin Web Framework\n\n<img align=\"right\" width=\"159px\" src=\"https://raw.githubusercontent.com/gin-gonic/logo/master/color.png\">\n\n[![Build Status](https://github.com/gin-gonic/gin/workflows/Run%20Tests/badge.svg?branch=master)](https://github.com/gin-gonic/gin/actions?query=branch%3Amaster)\n[![codecov](https://codecov.io/gh/gin-gonic/gin/branch/master/graph/badge.svg)](https://codecov.io/gh/gin-gonic/gin)\n[![Go Report Card](https://goreportcard.com/badge/github.com/gin-gonic/gin)](https://goreportcard.com/report/github.com/gin-gonic/gin)\n[![Go Reference](https://pkg.go.dev/badge/github.com/gin-gonic/gin?status.svg)](https://pkg.go.dev/github.com/gin-gonic/gin?tab=doc)\n[![Sourcegraph](https://sourcegraph.com/github.com/gin-gonic/gin/-/badge.svg)](https://sourcegraph.com/github.com/gin-gonic/gin?badge)\n[![Open Source Helpers](https://www.codetriage.com/gin-gonic/gin/badges/users.svg)](https://www.codetriage.com/gin-gonic/gin)\n[![Release](https://img.shields.io/github/release/gin-gonic/gin.svg?style=flat-square)](https://github.com/gin-gonic/gin/releases)\n[![TODOs](https://badgen.net/https/api.tickgit.com/badgen/github.com/gin-gonic/gin)](https://www.tickgit.com/browse?repo=github.com/gin-gonic/gin)\n\nGin is a web framework written in [Go](https://go.dev/). It features a martini-like API with performance that is up to 40 times faster thanks to [httprouter](https://github.com/julienschmidt/httprouter).\nIf you need performance and good productivity, you will love Gin.\n\n**Gin's key features are:**\n\n- Zero allocation router\n- Speed\n- Middleware support\n- Crash-free\n- JSON validation\n- Route grouping\n- Error management\n- Built-in rendering\n- Extensible\n\n## Getting started\n\n### Prerequisites\n\nGin requires [Go](https://go.dev/) version [1.22](https://go.dev/doc/devel/release#go1.22.0) or above.\n\n### Getting Gin\n\nWith [Go's module support](https://go.dev/wiki/Modules#how-to-use-modules), `go [build|run|test]` automatically fetches the necessary dependencies when you add the import in your code:\n\n```sh\nimport \"github.com/gin-gonic/gin\"\n```\n\nAlternatively, use `go get`:\n\n```sh\ngo get -u github.com/gin-gonic/gin\n```\n\n### Running Gin\n\nA basic example:\n\n```go\npackage main\n\nimport (\n  \"net/http\"\n\n  \"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n  r := gin.Default()\n  r.GET(\"/ping\", func(c *gin.Context) {\n    c.JSON(http.StatusOK, gin.H{\n      \"message\": \"pong\",\n    })\n  })\n  r.Run() // listen and serve on 0.0.0.0:8080 (for windows \"localhost:8080\")\n}\n```\n\nTo run the code, use the `go run` command, like:\n\n```sh\n$ go run example.go\n```\n\nThen visit [`0.0.0.0:8080/ping`](http://0.0.0.0:8080/ping) in your browser to see the response!\n\n### See more examples\n\n#### Quick Start\n\nLearn and practice with the [Gin Quick Start](docs/doc.md), which includes API examples and builds tag.\n\n#### Examples\n\nA number of ready-to-run examples demonstrating various use cases of Gin are available in the [Gin examples](https://github.com/gin-gonic/examples) repository.\n\n## Documentation\n\nSee the [API documentation on go.dev](https://pkg.go.dev/github.com/gin-gonic/gin).\n\nThe documentation is also available on [gin-gonic.com](https://gin-gonic.com) in several languages:\n\n- [English](https://gin-gonic.com/docs/)\n- [ÁÆÄ‰Ωì‰∏≠Êñá](https://gin-gonic.com/zh-cn/docs/)\n- [ÁπÅÈ´î‰∏≠Êñá](https://gin-gonic.com/zh-tw/docs/)\n- [Êó•Êú¨Ë™û](https://gin-gonic.com/ja/docs/)\n- [Espa√±ol](https://gin-gonic.com/es/docs/)\n- [ÌïúÍµ≠Ïñ¥](https://gin-gonic.com/ko-kr/docs/)\n- [Turkish](https://gin-gonic.com/tr/docs/)\n- [Persian](https://gin-gonic.com/fa/docs/)\n- [Portugu√™s](https://gin-gonic.com/pt/docs/)\n\n### Articles\n\n- [Tutorial: Developing a RESTful API with Go and Gin](https://go.dev/doc/tutorial/web-service-gin)\n\n## Benchmarks\n\nGin uses a custom version of [HttpRouter](https://github.com/julienschmidt/httprouter), [see all benchmarks](/BENCHMARKS.md).\n\n| Benchmark name                 |       (1) |             (2) |          (3) |             (4) |\n| ------------------------------ | --------: | --------------: | -----------: | --------------: |\n| BenchmarkGin_GithubAll         | **43550** | **27364 ns/op** |   **0 B/op** | **0 allocs/op** |\n| BenchmarkAce_GithubAll         |     40543 |     29670 ns/op |       0 B/op |     0 allocs/op |\n| BenchmarkAero_GithubAll        |     57632 |     20648 ns/op |       0 B/op |     0 allocs/op |\n| BenchmarkBear_GithubAll        |      9234 |    216179 ns/op |   86448 B/op |   943 allocs/op |\n| BenchmarkBeego_GithubAll       |      7407 |    243496 ns/op |   71456 B/op |   609 allocs/op |\n| BenchmarkBone_GithubAll        |       420 |   2922835 ns/op |  720160 B/op |  8620 allocs/op |\n| BenchmarkChi_GithubAll         |      7620 |    238331 ns/op |   87696 B/op |   609 allocs/op |\n| BenchmarkDenco_GithubAll       |     18355 |     64494 ns/op |   20224 B/op |   167 allocs/op |\n| BenchmarkEcho_GithubAll        |     31251 |     38479 ns/op |       0 B/op |     0 allocs/op |\n| BenchmarkGocraftWeb_GithubAll  |      4117 |    300062 ns/op |  131656 B/op |  1686 allocs/op |\n| BenchmarkGoji_GithubAll        |      3274 |    416158 ns/op |   56112 B/op |   334 allocs/op |\n| BenchmarkGojiv2_GithubAll      |      1402 |    870518 ns/op |  352720 B/op |  4321 allocs/op |\n| BenchmarkGoJsonRest_GithubAll  |      2976 |    401507 ns/op |  134371 B/op |  2737 allocs/op |\n| BenchmarkGoRestful_GithubAll   |       410 |   2913158 ns/op |  910144 B/op |  2938 allocs/op |\n| BenchmarkGorillaMux_GithubAll  |       346 |   3384987 ns/op |  251650 B/op |  1994 allocs/op |\n| BenchmarkGowwwRouter_GithubAll |     10000 |    143025 ns/op |   72144 B/op |   501 allocs/op |\n| BenchmarkHttpRouter_GithubAll  |     55938 |     21360 ns/op |       0 B/op |     0 allocs/op |\n| BenchmarkHttpTreeMux_GithubAll |     10000 |    153944 ns/op |   65856 B/op |   671 allocs/op |\n| BenchmarkKocha_GithubAll       |     10000 |    106315 ns/op |   23304 B/op |   843 allocs/op |\n| BenchmarkLARS_GithubAll        |     47779 |     25084 ns/op |       0 B/op |     0 allocs/op |\n| BenchmarkMacaron_GithubAll     |      3266 |    371907 ns/op |  149409 B/op |  1624 allocs/op |\n| BenchmarkMartini_GithubAll     |       331 |   3444706 ns/op |  226551 B/op |  2325 allocs/op |\n| BenchmarkPat_GithubAll         |       273 |   4381818 ns/op | 1483152 B/op | 26963 allocs/op |\n| BenchmarkPossum_GithubAll      |     10000 |    164367 ns/op |   84448 B/op |   609 allocs/op |\n| BenchmarkR2router_GithubAll    |     10000 |    160220 ns/op |   77328 B/op |   979 allocs/op |\n| BenchmarkRivet_GithubAll       |     14625 |     82453 ns/op |   16272 B/op |   167 allocs/op |\n| BenchmarkTango_GithubAll       |      6255 |    279611 ns/op |   63826 B/op |  1618 allocs/op |\n| BenchmarkTigerTonic_GithubAll  |      2008 |    687874 ns/op |  193856 B/op |  4474 allocs/op |\n| BenchmarkTraffic_GithubAll     |       355 |   3478508 ns/op |  820744 B/op | 14114 allocs/op |\n| BenchmarkVulcan_GithubAll      |      6885 |    193333 ns/op |   19894 B/op |   609 allocs/op |\n\n- (1): Total Repetitions achieved in constant time, higher means more confident result\n- (2): Single Repetition Duration (ns/op), lower is better\n- (3): Heap Memory (B/op), lower is better\n- (4): Average Allocations per Repetition (allocs/op), lower is better\n\n## Middleware\n\nYou can find many useful Gin middlewares at [gin-contrib](https://github.com/gin-contrib).\n\n## Uses\n\nHere are some awesome projects that are using the [Gin](https://github.com/gin-gonic/gin) web framework.\n\n- [gorush](https://github.com/appleboy/gorush): A push notification server.\n- [fnproject](https://github.com/fnproject/fn): A container native, cloud agnostic serverless platform.\n- [photoprism](https://github.com/photoprism/photoprism): Personal photo management powered by Google TensorFlow.\n- [lura](https://github.com/luraproject/lura): Ultra performant API Gateway with middleware.\n- [picfit](https://github.com/thoas/picfit): An image resizing server.\n- [dkron](https://github.com/distribworks/dkron): Distributed, fault tolerant job scheduling system.\n\n## Contributing\n\nGin is the work of hundreds of contributors. We appreciate your help!\n\nPlease see [CONTRIBUTING.md](CONTRIBUTING.md) for details on submitting patches and the contribution workflow.\n"
        },
        {
          "name": "auth.go",
          "type": "blob",
          "size": 3.748046875,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gin-gonic/gin/internal/bytesconv\"\n)\n\n// AuthUserKey is the cookie name for user credential in basic auth.\nconst AuthUserKey = \"user\"\n\n// AuthProxyUserKey is the cookie name for proxy_user credential in basic auth for proxy.\nconst AuthProxyUserKey = \"proxy_user\"\n\n// Accounts defines a key/value for user/pass list of authorized logins.\ntype Accounts map[string]string\n\ntype authPair struct {\n\tvalue string\n\tuser  string\n}\n\ntype authPairs []authPair\n\nfunc (a authPairs) searchCredential(authValue string) (string, bool) {\n\tif authValue == \"\" {\n\t\treturn \"\", false\n\t}\n\tfor _, pair := range a {\n\t\tif subtle.ConstantTimeCompare(bytesconv.StringToBytes(pair.value), bytesconv.StringToBytes(authValue)) == 1 {\n\t\t\treturn pair.user, true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n// BasicAuthForRealm returns a Basic HTTP Authorization middleware. It takes as arguments a map[string]string where\n// the key is the user name and the value is the password, as well as the name of the Realm.\n// If the realm is empty, \"Authorization Required\" will be used by default.\n// (see http://tools.ietf.org/html/rfc2617#section-1.2)\nfunc BasicAuthForRealm(accounts Accounts, realm string) HandlerFunc {\n\tif realm == \"\" {\n\t\trealm = \"Authorization Required\"\n\t}\n\trealm = \"Basic realm=\" + strconv.Quote(realm)\n\tpairs := processAccounts(accounts)\n\treturn func(c *Context) {\n\t\t// Search user in the slice of allowed credentials\n\t\tuser, found := pairs.searchCredential(c.requestHeader(\"Authorization\"))\n\t\tif !found {\n\t\t\t// Credentials doesn't match, we return 401 and abort handlers chain.\n\t\t\tc.Header(\"WWW-Authenticate\", realm)\n\t\t\tc.AbortWithStatus(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\t// The user credentials was found, set user's id to key AuthUserKey in this context, the user's id can be read later using\n\t\t// c.MustGet(gin.AuthUserKey).\n\t\tc.Set(AuthUserKey, user)\n\t}\n}\n\n// BasicAuth returns a Basic HTTP Authorization middleware. It takes as argument a map[string]string where\n// the key is the user name and the value is the password.\nfunc BasicAuth(accounts Accounts) HandlerFunc {\n\treturn BasicAuthForRealm(accounts, \"\")\n}\n\nfunc processAccounts(accounts Accounts) authPairs {\n\tlength := len(accounts)\n\tassert1(length > 0, \"Empty list of authorized credentials\")\n\tpairs := make(authPairs, 0, length)\n\tfor user, password := range accounts {\n\t\tassert1(user != \"\", \"User can not be empty\")\n\t\tvalue := authorizationHeader(user, password)\n\t\tpairs = append(pairs, authPair{\n\t\t\tvalue: value,\n\t\t\tuser:  user,\n\t\t})\n\t}\n\treturn pairs\n}\n\nfunc authorizationHeader(user, password string) string {\n\tbase := user + \":\" + password\n\treturn \"Basic \" + base64.StdEncoding.EncodeToString(bytesconv.StringToBytes(base))\n}\n\n// BasicAuthForProxy returns a Basic HTTP Proxy-Authorization middleware.\n// If the realm is empty, \"Proxy Authorization Required\" will be used by default.\nfunc BasicAuthForProxy(accounts Accounts, realm string) HandlerFunc {\n\tif realm == \"\" {\n\t\trealm = \"Proxy Authorization Required\"\n\t}\n\trealm = \"Basic realm=\" + strconv.Quote(realm)\n\tpairs := processAccounts(accounts)\n\treturn func(c *Context) {\n\t\tproxyUser, found := pairs.searchCredential(c.requestHeader(\"Proxy-Authorization\"))\n\t\tif !found {\n\t\t\t// Credentials doesn't match, we return 407 and abort handlers chain.\n\t\t\tc.Header(\"Proxy-Authenticate\", realm)\n\t\t\tc.AbortWithStatus(http.StatusProxyAuthRequired)\n\t\t\treturn\n\t\t}\n\t\t// The proxy_user credentials was found, set proxy_user's id to key AuthProxyUserKey in this context, the proxy_user's id can be read later using\n\t\t// c.MustGet(gin.AuthProxyUserKey).\n\t\tc.Set(AuthProxyUserKey, proxyUser)\n\t}\n}\n"
        },
        {
          "name": "auth_test.go",
          "type": "blob",
          "size": 4.955078125,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"encoding/base64\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestBasicAuth(t *testing.T) {\n\tpairs := processAccounts(Accounts{\n\t\t\"admin\": \"password\",\n\t\t\"foo\":   \"bar\",\n\t\t\"bar\":   \"foo\",\n\t})\n\n\tassert.Len(t, pairs, 3)\n\tassert.Contains(t, pairs, authPair{\n\t\tuser:  \"bar\",\n\t\tvalue: \"Basic YmFyOmZvbw==\",\n\t})\n\tassert.Contains(t, pairs, authPair{\n\t\tuser:  \"foo\",\n\t\tvalue: \"Basic Zm9vOmJhcg==\",\n\t})\n\tassert.Contains(t, pairs, authPair{\n\t\tuser:  \"admin\",\n\t\tvalue: \"Basic YWRtaW46cGFzc3dvcmQ=\",\n\t})\n}\n\nfunc TestBasicAuthFails(t *testing.T) {\n\tassert.Panics(t, func() { processAccounts(nil) })\n\tassert.Panics(t, func() {\n\t\tprocessAccounts(Accounts{\n\t\t\t\"\":    \"password\",\n\t\t\t\"foo\": \"bar\",\n\t\t})\n\t})\n}\n\nfunc TestBasicAuthSearchCredential(t *testing.T) {\n\tpairs := processAccounts(Accounts{\n\t\t\"admin\": \"password\",\n\t\t\"foo\":   \"bar\",\n\t\t\"bar\":   \"foo\",\n\t})\n\n\tuser, found := pairs.searchCredential(authorizationHeader(\"admin\", \"password\"))\n\tassert.Equal(t, \"admin\", user)\n\tassert.True(t, found)\n\n\tuser, found = pairs.searchCredential(authorizationHeader(\"foo\", \"bar\"))\n\tassert.Equal(t, \"foo\", user)\n\tassert.True(t, found)\n\n\tuser, found = pairs.searchCredential(authorizationHeader(\"bar\", \"foo\"))\n\tassert.Equal(t, \"bar\", user)\n\tassert.True(t, found)\n\n\tuser, found = pairs.searchCredential(authorizationHeader(\"admins\", \"password\"))\n\tassert.Empty(t, user)\n\tassert.False(t, found)\n\n\tuser, found = pairs.searchCredential(authorizationHeader(\"foo\", \"bar \"))\n\tassert.Empty(t, user)\n\tassert.False(t, found)\n\n\tuser, found = pairs.searchCredential(\"\")\n\tassert.Empty(t, user)\n\tassert.False(t, found)\n}\n\nfunc TestBasicAuthAuthorizationHeader(t *testing.T) {\n\tassert.Equal(t, \"Basic YWRtaW46cGFzc3dvcmQ=\", authorizationHeader(\"admin\", \"password\"))\n}\n\nfunc TestBasicAuthSucceed(t *testing.T) {\n\taccounts := Accounts{\"admin\": \"password\"}\n\trouter := New()\n\trouter.Use(BasicAuth(accounts))\n\trouter.GET(\"/login\", func(c *Context) {\n\t\tc.String(http.StatusOK, c.MustGet(AuthUserKey).(string))\n\t})\n\n\tw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(http.MethodGet, \"/login\", nil)\n\treq.Header.Set(\"Authorization\", authorizationHeader(\"admin\", \"password\"))\n\trouter.ServeHTTP(w, req)\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"admin\", w.Body.String())\n}\n\nfunc TestBasicAuth401(t *testing.T) {\n\tcalled := false\n\taccounts := Accounts{\"foo\": \"bar\"}\n\trouter := New()\n\trouter.Use(BasicAuth(accounts))\n\trouter.GET(\"/login\", func(c *Context) {\n\t\tcalled = true\n\t\tc.String(http.StatusOK, c.MustGet(AuthUserKey).(string))\n\t})\n\n\tw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(http.MethodGet, \"/login\", nil)\n\treq.Header.Set(\"Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(\"admin:password\")))\n\trouter.ServeHTTP(w, req)\n\n\tassert.False(t, called)\n\tassert.Equal(t, http.StatusUnauthorized, w.Code)\n\tassert.Equal(t, \"Basic realm=\\\"Authorization Required\\\"\", w.Header().Get(\"WWW-Authenticate\"))\n}\n\nfunc TestBasicAuth401WithCustomRealm(t *testing.T) {\n\tcalled := false\n\taccounts := Accounts{\"foo\": \"bar\"}\n\trouter := New()\n\trouter.Use(BasicAuthForRealm(accounts, \"My Custom \\\"Realm\\\"\"))\n\trouter.GET(\"/login\", func(c *Context) {\n\t\tcalled = true\n\t\tc.String(http.StatusOK, c.MustGet(AuthUserKey).(string))\n\t})\n\n\tw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(http.MethodGet, \"/login\", nil)\n\treq.Header.Set(\"Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(\"admin:password\")))\n\trouter.ServeHTTP(w, req)\n\n\tassert.False(t, called)\n\tassert.Equal(t, http.StatusUnauthorized, w.Code)\n\tassert.Equal(t, \"Basic realm=\\\"My Custom \\\\\\\"Realm\\\\\\\"\\\"\", w.Header().Get(\"WWW-Authenticate\"))\n}\n\nfunc TestBasicAuthForProxySucceed(t *testing.T) {\n\taccounts := Accounts{\"admin\": \"password\"}\n\trouter := New()\n\trouter.Use(BasicAuthForProxy(accounts, \"\"))\n\trouter.Any(\"/*proxyPath\", func(c *Context) {\n\t\tc.String(http.StatusOK, c.MustGet(AuthProxyUserKey).(string))\n\t})\n\n\tw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(http.MethodGet, \"/test\", nil)\n\treq.Header.Set(\"Proxy-Authorization\", authorizationHeader(\"admin\", \"password\"))\n\trouter.ServeHTTP(w, req)\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"admin\", w.Body.String())\n}\n\nfunc TestBasicAuthForProxy407(t *testing.T) {\n\tcalled := false\n\taccounts := Accounts{\"foo\": \"bar\"}\n\trouter := New()\n\trouter.Use(BasicAuthForProxy(accounts, \"\"))\n\trouter.Any(\"/*proxyPath\", func(c *Context) {\n\t\tcalled = true\n\t\tc.String(http.StatusOK, c.MustGet(AuthProxyUserKey).(string))\n\t})\n\n\tw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(http.MethodGet, \"/test\", nil)\n\treq.Header.Set(\"Proxy-Authorization\", \"Basic \"+base64.StdEncoding.EncodeToString([]byte(\"admin:password\")))\n\trouter.ServeHTTP(w, req)\n\n\tassert.False(t, called)\n\tassert.Equal(t, http.StatusProxyAuthRequired, w.Code)\n\tassert.Equal(t, \"Basic realm=\\\"Proxy Authorization Required\\\"\", w.Header().Get(\"Proxy-Authenticate\"))\n}\n"
        },
        {
          "name": "benchmarks_test.go",
          "type": "blob",
          "size": 3.8798828125,
          "content": "// Copyright 2017 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc BenchmarkOneRoute(B *testing.B) {\n\trouter := New()\n\trouter.GET(\"/ping\", func(c *Context) {})\n\trunRequest(B, router, http.MethodGet, \"/ping\")\n}\n\nfunc BenchmarkRecoveryMiddleware(B *testing.B) {\n\trouter := New()\n\trouter.Use(Recovery())\n\trouter.GET(\"/\", func(c *Context) {})\n\trunRequest(B, router, http.MethodGet, \"/\")\n}\n\nfunc BenchmarkLoggerMiddleware(B *testing.B) {\n\trouter := New()\n\trouter.Use(LoggerWithWriter(newMockWriter()))\n\trouter.GET(\"/\", func(c *Context) {})\n\trunRequest(B, router, http.MethodGet, \"/\")\n}\n\nfunc BenchmarkManyHandlers(B *testing.B) {\n\trouter := New()\n\trouter.Use(Recovery(), LoggerWithWriter(newMockWriter()))\n\trouter.Use(func(c *Context) {})\n\trouter.Use(func(c *Context) {})\n\trouter.GET(\"/ping\", func(c *Context) {})\n\trunRequest(B, router, http.MethodGet, \"/ping\")\n}\n\nfunc Benchmark5Params(B *testing.B) {\n\tDefaultWriter = os.Stdout\n\trouter := New()\n\trouter.Use(func(c *Context) {})\n\trouter.GET(\"/param/:param1/:params2/:param3/:param4/:param5\", func(c *Context) {})\n\trunRequest(B, router, http.MethodGet, \"/param/path/to/parameter/john/12345\")\n}\n\nfunc BenchmarkOneRouteJSON(B *testing.B) {\n\trouter := New()\n\tdata := struct {\n\t\tStatus string `json:\"status\"`\n\t}{\"ok\"}\n\trouter.GET(\"/json\", func(c *Context) {\n\t\tc.JSON(http.StatusOK, data)\n\t})\n\trunRequest(B, router, http.MethodGet, \"/json\")\n}\n\nfunc BenchmarkOneRouteHTML(B *testing.B) {\n\trouter := New()\n\tt := template.Must(template.New(\"index\").Parse(`\n\t\t<html><body><h1>{{.}}</h1></body></html>`))\n\trouter.SetHTMLTemplate(t)\n\n\trouter.GET(\"/html\", func(c *Context) {\n\t\tc.HTML(http.StatusOK, \"index\", \"hola\")\n\t})\n\trunRequest(B, router, http.MethodGet, \"/html\")\n}\n\nfunc BenchmarkOneRouteSet(B *testing.B) {\n\trouter := New()\n\trouter.GET(\"/ping\", func(c *Context) {\n\t\tc.Set(\"key\", \"value\")\n\t})\n\trunRequest(B, router, http.MethodGet, \"/ping\")\n}\n\nfunc BenchmarkOneRouteString(B *testing.B) {\n\trouter := New()\n\trouter.GET(\"/text\", func(c *Context) {\n\t\tc.String(http.StatusOK, \"this is a plain text\")\n\t})\n\trunRequest(B, router, http.MethodGet, \"/text\")\n}\n\nfunc BenchmarkManyRoutesFist(B *testing.B) {\n\trouter := New()\n\trouter.Any(\"/ping\", func(c *Context) {})\n\trunRequest(B, router, http.MethodGet, \"/ping\")\n}\n\nfunc BenchmarkManyRoutesLast(B *testing.B) {\n\trouter := New()\n\trouter.Any(\"/ping\", func(c *Context) {})\n\trunRequest(B, router, \"OPTIONS\", \"/ping\")\n}\n\nfunc Benchmark404(B *testing.B) {\n\trouter := New()\n\trouter.Any(\"/something\", func(c *Context) {})\n\trouter.NoRoute(func(c *Context) {})\n\trunRequest(B, router, http.MethodGet, \"/ping\")\n}\n\nfunc Benchmark404Many(B *testing.B) {\n\trouter := New()\n\trouter.GET(\"/\", func(c *Context) {})\n\trouter.GET(\"/path/to/something\", func(c *Context) {})\n\trouter.GET(\"/post/:id\", func(c *Context) {})\n\trouter.GET(\"/view/:id\", func(c *Context) {})\n\trouter.GET(\"/favicon.ico\", func(c *Context) {})\n\trouter.GET(\"/robots.txt\", func(c *Context) {})\n\trouter.GET(\"/delete/:id\", func(c *Context) {})\n\trouter.GET(\"/user/:id/:mode\", func(c *Context) {})\n\n\trouter.NoRoute(func(c *Context) {})\n\trunRequest(B, router, http.MethodGet, \"/viewfake\")\n}\n\ntype mockWriter struct {\n\theaders http.Header\n}\n\nfunc newMockWriter() *mockWriter {\n\treturn &mockWriter{\n\t\thttp.Header{},\n\t}\n}\n\nfunc (m *mockWriter) Header() (h http.Header) {\n\treturn m.headers\n}\n\nfunc (m *mockWriter) Write(p []byte) (n int, err error) {\n\treturn len(p), nil\n}\n\nfunc (m *mockWriter) WriteString(s string) (n int, err error) {\n\treturn len(s), nil\n}\n\nfunc (m *mockWriter) WriteHeader(int) {}\n\nfunc runRequest(B *testing.B, r *Engine, method, path string) {\n\t// create fake request\n\treq, err := http.NewRequest(method, path, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tw := newMockWriter()\n\tB.ReportAllocs()\n\tB.ResetTimer()\n\tfor i := 0; i < B.N; i++ {\n\t\tr.ServeHTTP(w, req)\n\t}\n}\n"
        },
        {
          "name": "binding",
          "type": "tree",
          "content": null
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.18359375,
          "content": "coverage:\n  require_ci_to_pass: true\n\n  status:\n    project:\n      default:\n        target: 99%\n        threshold: 99%\n\n    patch:\n      default:\n        target: 99%\n        threshold: 95%"
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 41.78515625,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"io/fs\"\n\t\"log\"\n\t\"math\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gin-contrib/sse\"\n\t\"github.com/gin-gonic/gin/binding\"\n\t\"github.com/gin-gonic/gin/render\"\n)\n\n// Content-Type MIME of the most common data formats.\nconst (\n\tMIMEJSON              = binding.MIMEJSON\n\tMIMEHTML              = binding.MIMEHTML\n\tMIMEXML               = binding.MIMEXML\n\tMIMEXML2              = binding.MIMEXML2\n\tMIMEPlain             = binding.MIMEPlain\n\tMIMEPOSTForm          = binding.MIMEPOSTForm\n\tMIMEMultipartPOSTForm = binding.MIMEMultipartPOSTForm\n\tMIMEYAML              = binding.MIMEYAML\n\tMIMEYAML2             = binding.MIMEYAML2\n\tMIMETOML              = binding.MIMETOML\n)\n\n// BodyBytesKey indicates a default body bytes key.\nconst BodyBytesKey = \"_gin-gonic/gin/bodybyteskey\"\n\n// ContextKey is the key that a Context returns itself for.\nconst ContextKey = \"_gin-gonic/gin/contextkey\"\n\ntype ContextKeyType int\n\nconst ContextRequestKey ContextKeyType = 0\n\n// abortIndex represents a typical value used in abort functions.\nconst abortIndex int8 = math.MaxInt8 >> 1\n\n// Context is the most important part of gin. It allows us to pass variables between middleware,\n// manage the flow, validate the JSON of a request and render a JSON response for example.\ntype Context struct {\n\twritermem responseWriter\n\tRequest   *http.Request\n\tWriter    ResponseWriter\n\n\tParams   Params\n\thandlers HandlersChain\n\tindex    int8\n\tfullPath string\n\n\tengine       *Engine\n\tparams       *Params\n\tskippedNodes *[]skippedNode\n\n\t// This mutex protects Keys map.\n\tmu sync.RWMutex\n\n\t// Keys is a key/value pair exclusively for the context of each request.\n\tKeys map[string]any\n\n\t// Errors is a list of errors attached to all the handlers/middlewares who used this context.\n\tErrors errorMsgs\n\n\t// Accepted defines a list of manually accepted formats for content negotiation.\n\tAccepted []string\n\n\t// queryCache caches the query result from c.Request.URL.Query().\n\tqueryCache url.Values\n\n\t// formCache caches c.Request.PostForm, which contains the parsed form data from POST, PATCH,\n\t// or PUT body parameters.\n\tformCache url.Values\n\n\t// SameSite allows a server to define a cookie attribute making it impossible for\n\t// the browser to send this cookie along with cross-site requests.\n\tsameSite http.SameSite\n}\n\n/************************************/\n/********** CONTEXT CREATION ********/\n/************************************/\n\nfunc (c *Context) reset() {\n\tc.Writer = &c.writermem\n\tc.Params = c.Params[:0]\n\tc.handlers = nil\n\tc.index = -1\n\n\tc.fullPath = \"\"\n\tc.Keys = nil\n\tc.Errors = c.Errors[:0]\n\tc.Accepted = nil\n\tc.queryCache = nil\n\tc.formCache = nil\n\tc.sameSite = 0\n\t*c.params = (*c.params)[:0]\n\t*c.skippedNodes = (*c.skippedNodes)[:0]\n}\n\n// Copy returns a copy of the current context that can be safely used outside the request's scope.\n// This has to be used when the context has to be passed to a goroutine.\nfunc (c *Context) Copy() *Context {\n\tcp := Context{\n\t\twritermem: c.writermem,\n\t\tRequest:   c.Request,\n\t\tengine:    c.engine,\n\t}\n\n\tcp.writermem.ResponseWriter = nil\n\tcp.Writer = &cp.writermem\n\tcp.index = abortIndex\n\tcp.handlers = nil\n\tcp.fullPath = c.fullPath\n\n\tcKeys := c.Keys\n\tcp.Keys = make(map[string]any, len(cKeys))\n\tc.mu.RLock()\n\tfor k, v := range cKeys {\n\t\tcp.Keys[k] = v\n\t}\n\tc.mu.RUnlock()\n\n\tcParams := c.Params\n\tcp.Params = make([]Param, len(cParams))\n\tcopy(cp.Params, cParams)\n\n\treturn &cp\n}\n\n// HandlerName returns the main handler's name. For example if the handler is \"handleGetUsers()\",\n// this function will return \"main.handleGetUsers\".\nfunc (c *Context) HandlerName() string {\n\treturn nameOfFunction(c.handlers.Last())\n}\n\n// HandlerNames returns a list of all registered handlers for this context in descending order,\n// following the semantics of HandlerName()\nfunc (c *Context) HandlerNames() []string {\n\thn := make([]string, 0, len(c.handlers))\n\tfor _, val := range c.handlers {\n\t\tif val == nil {\n\t\t\tcontinue\n\t\t}\n\t\thn = append(hn, nameOfFunction(val))\n\t}\n\treturn hn\n}\n\n// Handler returns the main handler.\nfunc (c *Context) Handler() HandlerFunc {\n\treturn c.handlers.Last()\n}\n\n// FullPath returns a matched route full path. For not found routes\n// returns an empty string.\n//\n//\trouter.GET(\"/user/:id\", func(c *gin.Context) {\n//\t    c.FullPath() == \"/user/:id\" // true\n//\t})\nfunc (c *Context) FullPath() string {\n\treturn c.fullPath\n}\n\n/************************************/\n/*********** FLOW CONTROL ***********/\n/************************************/\n\n// Next should be used only inside middleware.\n// It executes the pending handlers in the chain inside the calling handler.\n// See example in GitHub.\nfunc (c *Context) Next() {\n\tc.index++\n\tfor c.index < int8(len(c.handlers)) {\n\t\tif c.handlers[c.index] != nil {\n\t\t\tc.handlers[c.index](c)\n\t\t}\n\t\tc.index++\n\t}\n}\n\n// IsAborted returns true if the current context was aborted.\nfunc (c *Context) IsAborted() bool {\n\treturn c.index >= abortIndex\n}\n\n// Abort prevents pending handlers from being called. Note that this will not stop the current handler.\n// Let's say you have an authorization middleware that validates that the current request is authorized.\n// If the authorization fails (ex: the password does not match), call Abort to ensure the remaining handlers\n// for this request are not called.\nfunc (c *Context) Abort() {\n\tc.index = abortIndex\n}\n\n// AbortWithStatus calls `Abort()` and writes the headers with the specified status code.\n// For example, a failed attempt to authenticate a request could use: context.AbortWithStatus(401).\nfunc (c *Context) AbortWithStatus(code int) {\n\tc.Status(code)\n\tc.Writer.WriteHeaderNow()\n\tc.Abort()\n}\n\n// AbortWithStatusJSON calls `Abort()` and then `JSON` internally.\n// This method stops the chain, writes the status code and return a JSON body.\n// It also sets the Content-Type as \"application/json\".\nfunc (c *Context) AbortWithStatusJSON(code int, jsonObj any) {\n\tc.Abort()\n\tc.JSON(code, jsonObj)\n}\n\n// AbortWithError calls `AbortWithStatus()` and `Error()` internally.\n// This method stops the chain, writes the status code and pushes the specified error to `c.Errors`.\n// See Context.Error() for more details.\nfunc (c *Context) AbortWithError(code int, err error) *Error {\n\tc.AbortWithStatus(code)\n\treturn c.Error(err)\n}\n\n/************************************/\n/********* ERROR MANAGEMENT *********/\n/************************************/\n\n// Error attaches an error to the current context. The error is pushed to a list of errors.\n// It's a good idea to call Error for each error that occurred during the resolution of a request.\n// A middleware can be used to collect all the errors and push them to a database together,\n// print a log, or append it in the HTTP response.\n// Error will panic if err is nil.\nfunc (c *Context) Error(err error) *Error {\n\tif err == nil {\n\t\tpanic(\"err is nil\")\n\t}\n\n\tvar parsedError *Error\n\tok := errors.As(err, &parsedError)\n\tif !ok {\n\t\tparsedError = &Error{\n\t\t\tErr:  err,\n\t\t\tType: ErrorTypePrivate,\n\t\t}\n\t}\n\n\tc.Errors = append(c.Errors, parsedError)\n\treturn parsedError\n}\n\n/************************************/\n/******** METADATA MANAGEMENT********/\n/************************************/\n\n// Set is used to store a new key/value pair exclusively for this context.\n// It also lazy initializes  c.Keys if it was not used previously.\nfunc (c *Context) Set(key string, value any) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.Keys == nil {\n\t\tc.Keys = make(map[string]any)\n\t}\n\n\tc.Keys[key] = value\n}\n\n// Get returns the value for the given key, ie: (value, true).\n// If the value does not exist it returns (nil, false)\nfunc (c *Context) Get(key string) (value any, exists bool) {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tvalue, exists = c.Keys[key]\n\treturn\n}\n\n// MustGet returns the value for the given key if it exists, otherwise it panics.\nfunc (c *Context) MustGet(key string) any {\n\tif value, exists := c.Get(key); exists {\n\t\treturn value\n\t}\n\tpanic(\"Key \\\"\" + key + \"\\\" does not exist\")\n}\n\nfunc getTyped[T any](c *Context, key string) (res T) {\n\tif val, ok := c.Get(key); ok && val != nil {\n\t\tres, _ = val.(T)\n\t}\n\treturn\n}\n\n// GetString returns the value associated with the key as a string.\nfunc (c *Context) GetString(key string) (s string) {\n\treturn getTyped[string](c, key)\n}\n\n// GetBool returns the value associated with the key as a boolean.\nfunc (c *Context) GetBool(key string) (b bool) {\n\treturn getTyped[bool](c, key)\n}\n\n// GetInt returns the value associated with the key as an integer.\nfunc (c *Context) GetInt(key string) (i int) {\n\treturn getTyped[int](c, key)\n}\n\n// GetInt8 returns the value associated with the key as an integer 8.\nfunc (c *Context) GetInt8(key string) (i8 int8) {\n\treturn getTyped[int8](c, key)\n}\n\n// GetInt16 returns the value associated with the key as an integer 16.\nfunc (c *Context) GetInt16(key string) (i16 int16) {\n\treturn getTyped[int16](c, key)\n}\n\n// GetInt32 returns the value associated with the key as an integer 32.\nfunc (c *Context) GetInt32(key string) (i32 int32) {\n\treturn getTyped[int32](c, key)\n}\n\n// GetInt64 returns the value associated with the key as an integer 64.\nfunc (c *Context) GetInt64(key string) (i64 int64) {\n\treturn getTyped[int64](c, key)\n}\n\n// GetUint returns the value associated with the key as an unsigned integer.\nfunc (c *Context) GetUint(key string) (ui uint) {\n\treturn getTyped[uint](c, key)\n}\n\n// GetUint8 returns the value associated with the key as an unsigned integer 8.\nfunc (c *Context) GetUint8(key string) (ui8 uint8) {\n\treturn getTyped[uint8](c, key)\n}\n\n// GetUint16 returns the value associated with the key as an unsigned integer 16.\nfunc (c *Context) GetUint16(key string) (ui16 uint16) {\n\treturn getTyped[uint16](c, key)\n}\n\n// GetUint32 returns the value associated with the key as an unsigned integer 32.\nfunc (c *Context) GetUint32(key string) (ui32 uint32) {\n\treturn getTyped[uint32](c, key)\n}\n\n// GetUint64 returns the value associated with the key as an unsigned integer 64.\nfunc (c *Context) GetUint64(key string) (ui64 uint64) {\n\treturn getTyped[uint64](c, key)\n}\n\n// GetFloat32 returns the value associated with the key as a float32.\nfunc (c *Context) GetFloat32(key string) (f32 float32) {\n\treturn getTyped[float32](c, key)\n}\n\n// GetFloat64 returns the value associated with the key as a float64.\nfunc (c *Context) GetFloat64(key string) (f64 float64) {\n\treturn getTyped[float64](c, key)\n}\n\n// GetTime returns the value associated with the key as time.\nfunc (c *Context) GetTime(key string) (t time.Time) {\n\treturn getTyped[time.Time](c, key)\n}\n\n// GetDuration returns the value associated with the key as a duration.\nfunc (c *Context) GetDuration(key string) (d time.Duration) {\n\treturn getTyped[time.Duration](c, key)\n}\n\n// GetIntSlice returns the value associated with the key as a slice of integers.\nfunc (c *Context) GetIntSlice(key string) (is []int) {\n\treturn getTyped[[]int](c, key)\n}\n\n// GetInt8Slice returns the value associated with the key as a slice of int8 integers.\nfunc (c *Context) GetInt8Slice(key string) (i8s []int8) {\n\treturn getTyped[[]int8](c, key)\n}\n\n// GetInt16Slice returns the value associated with the key as a slice of int16 integers.\nfunc (c *Context) GetInt16Slice(key string) (i16s []int16) {\n\treturn getTyped[[]int16](c, key)\n}\n\n// GetInt32Slice returns the value associated with the key as a slice of int32 integers.\nfunc (c *Context) GetInt32Slice(key string) (i32s []int32) {\n\treturn getTyped[[]int32](c, key)\n}\n\n// GetInt64Slice returns the value associated with the key as a slice of int64 integers.\nfunc (c *Context) GetInt64Slice(key string) (i64s []int64) {\n\treturn getTyped[[]int64](c, key)\n}\n\n// GetUintSlice returns the value associated with the key as a slice of unsigned integers.\nfunc (c *Context) GetUintSlice(key string) (uis []uint) {\n\treturn getTyped[[]uint](c, key)\n}\n\n// GetUint8Slice returns the value associated with the key as a slice of uint8 integers.\nfunc (c *Context) GetUint8Slice(key string) (ui8s []uint8) {\n\treturn getTyped[[]uint8](c, key)\n}\n\n// GetUint16Slice returns the value associated with the key as a slice of uint16 integers.\nfunc (c *Context) GetUint16Slice(key string) (ui16s []uint16) {\n\treturn getTyped[[]uint16](c, key)\n}\n\n// GetUint32Slice returns the value associated with the key as a slice of uint32 integers.\nfunc (c *Context) GetUint32Slice(key string) (ui32s []uint32) {\n\treturn getTyped[[]uint32](c, key)\n}\n\n// GetUint64Slice returns the value associated with the key as a slice of uint64 integers.\nfunc (c *Context) GetUint64Slice(key string) (ui64s []uint64) {\n\treturn getTyped[[]uint64](c, key)\n}\n\n// GetFloat32Slice returns the value associated with the key as a slice of float32 numbers.\nfunc (c *Context) GetFloat32Slice(key string) (f32s []float32) {\n\treturn getTyped[[]float32](c, key)\n}\n\n// GetFloat64Slice returns the value associated with the key as a slice of float64 numbers.\nfunc (c *Context) GetFloat64Slice(key string) (f64s []float64) {\n\treturn getTyped[[]float64](c, key)\n}\n\n// GetStringSlice returns the value associated with the key as a slice of strings.\nfunc (c *Context) GetStringSlice(key string) (ss []string) {\n\treturn getTyped[[]string](c, key)\n}\n\n// GetStringMap returns the value associated with the key as a map of interfaces.\nfunc (c *Context) GetStringMap(key string) (sm map[string]any) {\n\treturn getTyped[map[string]any](c, key)\n}\n\n// GetStringMapString returns the value associated with the key as a map of strings.\nfunc (c *Context) GetStringMapString(key string) (sms map[string]string) {\n\treturn getTyped[map[string]string](c, key)\n}\n\n// GetStringMapStringSlice returns the value associated with the key as a map to a slice of strings.\nfunc (c *Context) GetStringMapStringSlice(key string) (smss map[string][]string) {\n\treturn getTyped[map[string][]string](c, key)\n}\n\n/************************************/\n/************ INPUT DATA ************/\n/************************************/\n\n// Param returns the value of the URL param.\n// It is a shortcut for c.Params.ByName(key)\n//\n//\trouter.GET(\"/user/:id\", func(c *gin.Context) {\n//\t    // a GET request to /user/john\n//\t    id := c.Param(\"id\") // id == \"john\"\n//\t    // a GET request to /user/john/\n//\t    id := c.Param(\"id\") // id == \"/john/\"\n//\t})\nfunc (c *Context) Param(key string) string {\n\treturn c.Params.ByName(key)\n}\n\n// AddParam adds param to context and\n// replaces path param key with given value for e2e testing purposes\n// Example Route: \"/user/:id\"\n// AddParam(\"id\", 1)\n// Result: \"/user/1\"\nfunc (c *Context) AddParam(key, value string) {\n\tc.Params = append(c.Params, Param{Key: key, Value: value})\n}\n\n// Query returns the keyed url query value if it exists,\n// otherwise it returns an empty string `(\"\")`.\n// It is shortcut for `c.Request.URL.Query().Get(key)`\n//\n//\t    GET /path?id=1234&name=Manu&value=\n//\t\t   c.Query(\"id\") == \"1234\"\n//\t\t   c.Query(\"name\") == \"Manu\"\n//\t\t   c.Query(\"value\") == \"\"\n//\t\t   c.Query(\"wtf\") == \"\"\nfunc (c *Context) Query(key string) (value string) {\n\tvalue, _ = c.GetQuery(key)\n\treturn\n}\n\n// DefaultQuery returns the keyed url query value if it exists,\n// otherwise it returns the specified defaultValue string.\n// See: Query() and GetQuery() for further information.\n//\n//\tGET /?name=Manu&lastname=\n//\tc.DefaultQuery(\"name\", \"unknown\") == \"Manu\"\n//\tc.DefaultQuery(\"id\", \"none\") == \"none\"\n//\tc.DefaultQuery(\"lastname\", \"none\") == \"\"\nfunc (c *Context) DefaultQuery(key, defaultValue string) string {\n\tif value, ok := c.GetQuery(key); ok {\n\t\treturn value\n\t}\n\treturn defaultValue\n}\n\n// GetQuery is like Query(), it returns the keyed url query value\n// if it exists `(value, true)` (even when the value is an empty string),\n// otherwise it returns `(\"\", false)`.\n// It is shortcut for `c.Request.URL.Query().Get(key)`\n//\n//\tGET /?name=Manu&lastname=\n//\t(\"Manu\", true) == c.GetQuery(\"name\")\n//\t(\"\", false) == c.GetQuery(\"id\")\n//\t(\"\", true) == c.GetQuery(\"lastname\")\nfunc (c *Context) GetQuery(key string) (string, bool) {\n\tif values, ok := c.GetQueryArray(key); ok {\n\t\treturn values[0], ok\n\t}\n\treturn \"\", false\n}\n\n// QueryArray returns a slice of strings for a given query key.\n// The length of the slice depends on the number of params with the given key.\nfunc (c *Context) QueryArray(key string) (values []string) {\n\tvalues, _ = c.GetQueryArray(key)\n\treturn\n}\n\nfunc (c *Context) initQueryCache() {\n\tif c.queryCache == nil {\n\t\tif c.Request != nil && c.Request.URL != nil {\n\t\t\tc.queryCache = c.Request.URL.Query()\n\t\t} else {\n\t\t\tc.queryCache = url.Values{}\n\t\t}\n\t}\n}\n\n// GetQueryArray returns a slice of strings for a given query key, plus\n// a boolean value whether at least one value exists for the given key.\nfunc (c *Context) GetQueryArray(key string) (values []string, ok bool) {\n\tc.initQueryCache()\n\tvalues, ok = c.queryCache[key]\n\treturn\n}\n\n// QueryMap returns a map for a given query key.\nfunc (c *Context) QueryMap(key string) (dicts map[string]string) {\n\tdicts, _ = c.GetQueryMap(key)\n\treturn\n}\n\n// GetQueryMap returns a map for a given query key, plus a boolean value\n// whether at least one value exists for the given key.\nfunc (c *Context) GetQueryMap(key string) (map[string]string, bool) {\n\tc.initQueryCache()\n\treturn c.get(c.queryCache, key)\n}\n\n// PostForm returns the specified key from a POST urlencoded form or multipart form\n// when it exists, otherwise it returns an empty string `(\"\")`.\nfunc (c *Context) PostForm(key string) (value string) {\n\tvalue, _ = c.GetPostForm(key)\n\treturn\n}\n\n// DefaultPostForm returns the specified key from a POST urlencoded form or multipart form\n// when it exists, otherwise it returns the specified defaultValue string.\n// See: PostForm() and GetPostForm() for further information.\nfunc (c *Context) DefaultPostForm(key, defaultValue string) string {\n\tif value, ok := c.GetPostForm(key); ok {\n\t\treturn value\n\t}\n\treturn defaultValue\n}\n\n// GetPostForm is like PostForm(key). It returns the specified key from a POST urlencoded\n// form or multipart form when it exists `(value, true)` (even when the value is an empty string),\n// otherwise it returns (\"\", false).\n// For example, during a PATCH request to update the user's email:\n//\n//\t    email=mail@example.com  -->  (\"mail@example.com\", true) := GetPostForm(\"email\") // set email to \"mail@example.com\"\n//\t\t   email=                  -->  (\"\", true) := GetPostForm(\"email\") // set email to \"\"\n//\t                            -->  (\"\", false) := GetPostForm(\"email\") // do nothing with email\nfunc (c *Context) GetPostForm(key string) (string, bool) {\n\tif values, ok := c.GetPostFormArray(key); ok {\n\t\treturn values[0], ok\n\t}\n\treturn \"\", false\n}\n\n// PostFormArray returns a slice of strings for a given form key.\n// The length of the slice depends on the number of params with the given key.\nfunc (c *Context) PostFormArray(key string) (values []string) {\n\tvalues, _ = c.GetPostFormArray(key)\n\treturn\n}\n\nfunc (c *Context) initFormCache() {\n\tif c.formCache == nil {\n\t\tc.formCache = make(url.Values)\n\t\treq := c.Request\n\t\tif err := req.ParseMultipartForm(c.engine.MaxMultipartMemory); err != nil {\n\t\t\tif !errors.Is(err, http.ErrNotMultipart) {\n\t\t\t\tdebugPrint(\"error on parse multipart form array: %v\", err)\n\t\t\t}\n\t\t}\n\t\tc.formCache = req.PostForm\n\t}\n}\n\n// GetPostFormArray returns a slice of strings for a given form key, plus\n// a boolean value whether at least one value exists for the given key.\nfunc (c *Context) GetPostFormArray(key string) (values []string, ok bool) {\n\tc.initFormCache()\n\tvalues, ok = c.formCache[key]\n\treturn\n}\n\n// PostFormMap returns a map for a given form key.\nfunc (c *Context) PostFormMap(key string) (dicts map[string]string) {\n\tdicts, _ = c.GetPostFormMap(key)\n\treturn\n}\n\n// GetPostFormMap returns a map for a given form key, plus a boolean value\n// whether at least one value exists for the given key.\nfunc (c *Context) GetPostFormMap(key string) (map[string]string, bool) {\n\tc.initFormCache()\n\treturn c.get(c.formCache, key)\n}\n\n// get is an internal method and returns a map which satisfies conditions.\nfunc (c *Context) get(m map[string][]string, key string) (map[string]string, bool) {\n\tdicts := make(map[string]string)\n\texist := false\n\tfor k, v := range m {\n\t\tif i := strings.IndexByte(k, '['); i >= 1 && k[0:i] == key {\n\t\t\tif j := strings.IndexByte(k[i+1:], ']'); j >= 1 {\n\t\t\t\texist = true\n\t\t\t\tdicts[k[i+1:][:j]] = v[0]\n\t\t\t}\n\t\t}\n\t}\n\treturn dicts, exist\n}\n\n// FormFile returns the first file for the provided form key.\nfunc (c *Context) FormFile(name string) (*multipart.FileHeader, error) {\n\tif c.Request.MultipartForm == nil {\n\t\tif err := c.Request.ParseMultipartForm(c.engine.MaxMultipartMemory); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tf, fh, err := c.Request.FormFile(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tf.Close()\n\treturn fh, err\n}\n\n// MultipartForm is the parsed multipart form, including file uploads.\nfunc (c *Context) MultipartForm() (*multipart.Form, error) {\n\terr := c.Request.ParseMultipartForm(c.engine.MaxMultipartMemory)\n\treturn c.Request.MultipartForm, err\n}\n\n// SaveUploadedFile uploads the form file to specific dst.\nfunc (c *Context) SaveUploadedFile(file *multipart.FileHeader, dst string, perm ...fs.FileMode) error {\n\tsrc, err := file.Open()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer src.Close()\n\n\tif len(perm) <= 0 {\n\t\tperm = append(perm, 0o750)\n\t}\n\n\tif err = os.MkdirAll(filepath.Dir(dst), perm[0]); err != nil {\n\t\treturn err\n\t}\n\n\tif err = os.Chmod(filepath.Dir(dst), perm[0]); err != nil {\n\t\treturn err\n\t}\n\n\tout, err := os.Create(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\n\t_, err = io.Copy(out, src)\n\treturn err\n}\n\n// Bind checks the Method and Content-Type to select a binding engine automatically,\n// Depending on the \"Content-Type\" header different bindings are used, for example:\n//\n//\t\"application/json\" --> JSON binding\n//\t\"application/xml\"  --> XML binding\n//\n// It parses the request's body as JSON if Content-Type == \"application/json\" using JSON or XML as a JSON input.\n// It decodes the json payload into the struct specified as a pointer.\n// It writes a 400 error and sets Content-Type header \"text/plain\" in the response if input is not valid.\nfunc (c *Context) Bind(obj any) error {\n\tb := binding.Default(c.Request.Method, c.ContentType())\n\treturn c.MustBindWith(obj, b)\n}\n\n// BindJSON is a shortcut for c.MustBindWith(obj, binding.JSON).\nfunc (c *Context) BindJSON(obj any) error {\n\treturn c.MustBindWith(obj, binding.JSON)\n}\n\n// BindXML is a shortcut for c.MustBindWith(obj, binding.BindXML).\nfunc (c *Context) BindXML(obj any) error {\n\treturn c.MustBindWith(obj, binding.XML)\n}\n\n// BindQuery is a shortcut for c.MustBindWith(obj, binding.Query).\nfunc (c *Context) BindQuery(obj any) error {\n\treturn c.MustBindWith(obj, binding.Query)\n}\n\n// BindYAML is a shortcut for c.MustBindWith(obj, binding.YAML).\nfunc (c *Context) BindYAML(obj any) error {\n\treturn c.MustBindWith(obj, binding.YAML)\n}\n\n// BindTOML is a shortcut for c.MustBindWith(obj, binding.TOML).\nfunc (c *Context) BindTOML(obj any) error {\n\treturn c.MustBindWith(obj, binding.TOML)\n}\n\n// BindPlain is a shortcut for c.MustBindWith(obj, binding.Plain).\nfunc (c *Context) BindPlain(obj any) error {\n\treturn c.MustBindWith(obj, binding.Plain)\n}\n\n// BindHeader is a shortcut for c.MustBindWith(obj, binding.Header).\nfunc (c *Context) BindHeader(obj any) error {\n\treturn c.MustBindWith(obj, binding.Header)\n}\n\n// BindUri binds the passed struct pointer using binding.Uri.\n// It will abort the request with HTTP 400 if any error occurs.\nfunc (c *Context) BindUri(obj any) error {\n\tif err := c.ShouldBindUri(obj); err != nil {\n\t\tc.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) //nolint: errcheck\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// MustBindWith binds the passed struct pointer using the specified binding engine.\n// It will abort the request with HTTP 400 if any error occurs.\n// See the binding package.\nfunc (c *Context) MustBindWith(obj any, b binding.Binding) error {\n\tif err := c.ShouldBindWith(obj, b); err != nil {\n\t\tc.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) //nolint: errcheck\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// ShouldBind checks the Method and Content-Type to select a binding engine automatically,\n// Depending on the \"Content-Type\" header different bindings are used, for example:\n//\n//\t\"application/json\" --> JSON binding\n//\t\"application/xml\"  --> XML binding\n//\n// It parses the request's body as JSON if Content-Type == \"application/json\" using JSON or XML as a JSON input.\n// It decodes the json payload into the struct specified as a pointer.\n// Like c.Bind() but this method does not set the response status code to 400 or abort if input is not valid.\nfunc (c *Context) ShouldBind(obj any) error {\n\tb := binding.Default(c.Request.Method, c.ContentType())\n\treturn c.ShouldBindWith(obj, b)\n}\n\n// ShouldBindJSON is a shortcut for c.ShouldBindWith(obj, binding.JSON).\nfunc (c *Context) ShouldBindJSON(obj any) error {\n\treturn c.ShouldBindWith(obj, binding.JSON)\n}\n\n// ShouldBindXML is a shortcut for c.ShouldBindWith(obj, binding.XML).\nfunc (c *Context) ShouldBindXML(obj any) error {\n\treturn c.ShouldBindWith(obj, binding.XML)\n}\n\n// ShouldBindQuery is a shortcut for c.ShouldBindWith(obj, binding.Query).\nfunc (c *Context) ShouldBindQuery(obj any) error {\n\treturn c.ShouldBindWith(obj, binding.Query)\n}\n\n// ShouldBindYAML is a shortcut for c.ShouldBindWith(obj, binding.YAML).\nfunc (c *Context) ShouldBindYAML(obj any) error {\n\treturn c.ShouldBindWith(obj, binding.YAML)\n}\n\n// ShouldBindTOML is a shortcut for c.ShouldBindWith(obj, binding.TOML).\nfunc (c *Context) ShouldBindTOML(obj any) error {\n\treturn c.ShouldBindWith(obj, binding.TOML)\n}\n\n// ShouldBindPlain is a shortcut for c.ShouldBindWith(obj, binding.Plain).\nfunc (c *Context) ShouldBindPlain(obj any) error {\n\treturn c.ShouldBindWith(obj, binding.Plain)\n}\n\n// ShouldBindHeader is a shortcut for c.ShouldBindWith(obj, binding.Header).\nfunc (c *Context) ShouldBindHeader(obj any) error {\n\treturn c.ShouldBindWith(obj, binding.Header)\n}\n\n// ShouldBindUri binds the passed struct pointer using the specified binding engine.\nfunc (c *Context) ShouldBindUri(obj any) error {\n\tm := make(map[string][]string, len(c.Params))\n\tfor _, v := range c.Params {\n\t\tm[v.Key] = []string{v.Value}\n\t}\n\treturn binding.Uri.BindUri(m, obj)\n}\n\n// ShouldBindWith binds the passed struct pointer using the specified binding engine.\n// See the binding package.\nfunc (c *Context) ShouldBindWith(obj any, b binding.Binding) error {\n\treturn b.Bind(c.Request, obj)\n}\n\n// ShouldBindBodyWith is similar with ShouldBindWith, but it stores the request\n// body into the context, and reuse when it is called again.\n//\n// NOTE: This method reads the body before binding. So you should use\n// ShouldBindWith for better performance if you need to call only once.\nfunc (c *Context) ShouldBindBodyWith(obj any, bb binding.BindingBody) (err error) {\n\tvar body []byte\n\tif cb, ok := c.Get(BodyBytesKey); ok {\n\t\tif cbb, ok := cb.([]byte); ok {\n\t\t\tbody = cbb\n\t\t}\n\t}\n\tif body == nil {\n\t\tbody, err = io.ReadAll(c.Request.Body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.Set(BodyBytesKey, body)\n\t}\n\treturn bb.BindBody(body, obj)\n}\n\n// ShouldBindBodyWithJSON is a shortcut for c.ShouldBindBodyWith(obj, binding.JSON).\nfunc (c *Context) ShouldBindBodyWithJSON(obj any) error {\n\treturn c.ShouldBindBodyWith(obj, binding.JSON)\n}\n\n// ShouldBindBodyWithXML is a shortcut for c.ShouldBindBodyWith(obj, binding.XML).\nfunc (c *Context) ShouldBindBodyWithXML(obj any) error {\n\treturn c.ShouldBindBodyWith(obj, binding.XML)\n}\n\n// ShouldBindBodyWithYAML is a shortcut for c.ShouldBindBodyWith(obj, binding.YAML).\nfunc (c *Context) ShouldBindBodyWithYAML(obj any) error {\n\treturn c.ShouldBindBodyWith(obj, binding.YAML)\n}\n\n// ShouldBindBodyWithTOML is a shortcut for c.ShouldBindBodyWith(obj, binding.TOML).\nfunc (c *Context) ShouldBindBodyWithTOML(obj any) error {\n\treturn c.ShouldBindBodyWith(obj, binding.TOML)\n}\n\n// ShouldBindBodyWithPlain is a shortcut for c.ShouldBindBodyWith(obj, binding.Plain).\nfunc (c *Context) ShouldBindBodyWithPlain(obj any) error {\n\treturn c.ShouldBindBodyWith(obj, binding.Plain)\n}\n\n// ClientIP implements one best effort algorithm to return the real client IP.\n// It calls c.RemoteIP() under the hood, to check if the remote IP is a trusted proxy or not.\n// If it is it will then try to parse the headers defined in Engine.RemoteIPHeaders (defaulting to [X-Forwarded-For, X-Real-Ip]).\n// If the headers are not syntactically valid OR the remote IP does not correspond to a trusted proxy,\n// the remote IP (coming from Request.RemoteAddr) is returned.\nfunc (c *Context) ClientIP() string {\n\t// Check if we're running on a trusted platform, continue running backwards if error\n\tif c.engine.TrustedPlatform != \"\" {\n\t\t// Developers can define their own header of Trusted Platform or use predefined constants\n\t\tif addr := c.requestHeader(c.engine.TrustedPlatform); addr != \"\" {\n\t\t\treturn addr\n\t\t}\n\t}\n\n\t// Legacy \"AppEngine\" flag\n\tif c.engine.AppEngine {\n\t\tlog.Println(`The AppEngine flag is going to be deprecated. Please check issues #2723 and #2739 and use 'TrustedPlatform: gin.PlatformGoogleAppEngine' instead.`)\n\t\tif addr := c.requestHeader(\"X-Appengine-Remote-Addr\"); addr != \"\" {\n\t\t\treturn addr\n\t\t}\n\t}\n\n\t// It also checks if the remoteIP is a trusted proxy or not.\n\t// In order to perform this validation, it will see if the IP is contained within at least one of the CIDR blocks\n\t// defined by Engine.SetTrustedProxies()\n\tremoteIP := net.ParseIP(c.RemoteIP())\n\tif remoteIP == nil {\n\t\treturn \"\"\n\t}\n\ttrusted := c.engine.isTrustedProxy(remoteIP)\n\n\tif trusted && c.engine.ForwardedByClientIP && c.engine.RemoteIPHeaders != nil {\n\t\tfor _, headerName := range c.engine.RemoteIPHeaders {\n\t\t\tip, valid := c.engine.validateHeader(c.requestHeader(headerName))\n\t\t\tif valid {\n\t\t\t\treturn ip\n\t\t\t}\n\t\t}\n\t}\n\treturn remoteIP.String()\n}\n\n// RemoteIP parses the IP from Request.RemoteAddr, normalizes and returns the IP (without the port).\nfunc (c *Context) RemoteIP() string {\n\tip, _, err := net.SplitHostPort(strings.TrimSpace(c.Request.RemoteAddr))\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn ip\n}\n\n// ContentType returns the Content-Type header of the request.\nfunc (c *Context) ContentType() string {\n\treturn filterFlags(c.requestHeader(\"Content-Type\"))\n}\n\n// IsWebsocket returns true if the request headers indicate that a websocket\n// handshake is being initiated by the client.\nfunc (c *Context) IsWebsocket() bool {\n\tif strings.Contains(strings.ToLower(c.requestHeader(\"Connection\")), \"upgrade\") &&\n\t\tstrings.EqualFold(c.requestHeader(\"Upgrade\"), \"websocket\") {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (c *Context) requestHeader(key string) string {\n\treturn c.Request.Header.Get(key)\n}\n\n/************************************/\n/******** RESPONSE RENDERING ********/\n/************************************/\n\n// bodyAllowedForStatus is a copy of http.bodyAllowedForStatus non-exported function.\nfunc bodyAllowedForStatus(status int) bool {\n\tswitch {\n\tcase status >= 100 && status <= 199:\n\t\treturn false\n\tcase status == http.StatusNoContent:\n\t\treturn false\n\tcase status == http.StatusNotModified:\n\t\treturn false\n\t}\n\treturn true\n}\n\n// Status sets the HTTP response code.\nfunc (c *Context) Status(code int) {\n\tc.Writer.WriteHeader(code)\n}\n\n// Header is an intelligent shortcut for c.Writer.Header().Set(key, value).\n// It writes a header in the response.\n// If value == \"\", this method removes the header `c.Writer.Header().Del(key)`\nfunc (c *Context) Header(key, value string) {\n\tif value == \"\" {\n\t\tc.Writer.Header().Del(key)\n\t\treturn\n\t}\n\tc.Writer.Header().Set(key, value)\n}\n\n// GetHeader returns value from request headers.\nfunc (c *Context) GetHeader(key string) string {\n\treturn c.requestHeader(key)\n}\n\n// GetRawData returns stream data.\nfunc (c *Context) GetRawData() ([]byte, error) {\n\tif c.Request.Body == nil {\n\t\treturn nil, errors.New(\"cannot read nil body\")\n\t}\n\treturn io.ReadAll(c.Request.Body)\n}\n\n// SetSameSite with cookie\nfunc (c *Context) SetSameSite(samesite http.SameSite) {\n\tc.sameSite = samesite\n}\n\n// SetCookie adds a Set-Cookie header to the ResponseWriter's headers.\n// The provided cookie must have a valid Name. Invalid cookies may be\n// silently dropped.\nfunc (c *Context) SetCookie(name, value string, maxAge int, path, domain string, secure, httpOnly bool) {\n\tif path == \"\" {\n\t\tpath = \"/\"\n\t}\n\thttp.SetCookie(c.Writer, &http.Cookie{\n\t\tName:     name,\n\t\tValue:    url.QueryEscape(value),\n\t\tMaxAge:   maxAge,\n\t\tPath:     path,\n\t\tDomain:   domain,\n\t\tSameSite: c.sameSite,\n\t\tSecure:   secure,\n\t\tHttpOnly: httpOnly,\n\t})\n}\n\n// Cookie returns the named cookie provided in the request or\n// ErrNoCookie if not found. And return the named cookie is unescaped.\n// If multiple cookies match the given name, only one cookie will\n// be returned.\nfunc (c *Context) Cookie(name string) (string, error) {\n\tcookie, err := c.Request.Cookie(name)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tval, _ := url.QueryUnescape(cookie.Value)\n\treturn val, nil\n}\n\n// Render writes the response headers and calls render.Render to render data.\nfunc (c *Context) Render(code int, r render.Render) {\n\tc.Status(code)\n\n\tif !bodyAllowedForStatus(code) {\n\t\tr.WriteContentType(c.Writer)\n\t\tc.Writer.WriteHeaderNow()\n\t\treturn\n\t}\n\n\tif err := r.Render(c.Writer); err != nil {\n\t\t// Pushing error to c.Errors\n\t\t_ = c.Error(err)\n\t\tc.Abort()\n\t}\n}\n\n// HTML renders the HTTP template specified by its file name.\n// It also updates the HTTP code and sets the Content-Type as \"text/html\".\n// See http://golang.org/doc/articles/wiki/\nfunc (c *Context) HTML(code int, name string, obj any) {\n\tinstance := c.engine.HTMLRender.Instance(name, obj)\n\tc.Render(code, instance)\n}\n\n// IndentedJSON serializes the given struct as pretty JSON (indented + endlines) into the response body.\n// It also sets the Content-Type as \"application/json\".\n// WARNING: we recommend using this only for development purposes since printing pretty JSON is\n// more CPU and bandwidth consuming. Use Context.JSON() instead.\nfunc (c *Context) IndentedJSON(code int, obj any) {\n\tc.Render(code, render.IndentedJSON{Data: obj})\n}\n\n// SecureJSON serializes the given struct as Secure JSON into the response body.\n// Default prepends \"while(1),\" to response body if the given struct is array values.\n// It also sets the Content-Type as \"application/json\".\nfunc (c *Context) SecureJSON(code int, obj any) {\n\tc.Render(code, render.SecureJSON{Prefix: c.engine.secureJSONPrefix, Data: obj})\n}\n\n// JSONP serializes the given struct as JSON into the response body.\n// It adds padding to response body to request data from a server residing in a different domain than the client.\n// It also sets the Content-Type as \"application/javascript\".\nfunc (c *Context) JSONP(code int, obj any) {\n\tcallback := c.DefaultQuery(\"callback\", \"\")\n\tif callback == \"\" {\n\t\tc.Render(code, render.JSON{Data: obj})\n\t\treturn\n\t}\n\tc.Render(code, render.JsonpJSON{Callback: callback, Data: obj})\n}\n\n// JSON serializes the given struct as JSON into the response body.\n// It also sets the Content-Type as \"application/json\".\nfunc (c *Context) JSON(code int, obj any) {\n\tc.Render(code, render.JSON{Data: obj})\n}\n\n// AsciiJSON serializes the given struct as JSON into the response body with unicode to ASCII string.\n// It also sets the Content-Type as \"application/json\".\nfunc (c *Context) AsciiJSON(code int, obj any) {\n\tc.Render(code, render.AsciiJSON{Data: obj})\n}\n\n// PureJSON serializes the given struct as JSON into the response body.\n// PureJSON, unlike JSON, does not replace special html characters with their unicode entities.\nfunc (c *Context) PureJSON(code int, obj any) {\n\tc.Render(code, render.PureJSON{Data: obj})\n}\n\n// XML serializes the given struct as XML into the response body.\n// It also sets the Content-Type as \"application/xml\".\nfunc (c *Context) XML(code int, obj any) {\n\tc.Render(code, render.XML{Data: obj})\n}\n\n// YAML serializes the given struct as YAML into the response body.\nfunc (c *Context) YAML(code int, obj any) {\n\tc.Render(code, render.YAML{Data: obj})\n}\n\n// TOML serializes the given struct as TOML into the response body.\nfunc (c *Context) TOML(code int, obj any) {\n\tc.Render(code, render.TOML{Data: obj})\n}\n\n// ProtoBuf serializes the given struct as ProtoBuf into the response body.\nfunc (c *Context) ProtoBuf(code int, obj any) {\n\tc.Render(code, render.ProtoBuf{Data: obj})\n}\n\n// String writes the given string into the response body.\nfunc (c *Context) String(code int, format string, values ...any) {\n\tc.Render(code, render.String{Format: format, Data: values})\n}\n\n// Redirect returns an HTTP redirect to the specific location.\nfunc (c *Context) Redirect(code int, location string) {\n\tc.Render(-1, render.Redirect{\n\t\tCode:     code,\n\t\tLocation: location,\n\t\tRequest:  c.Request,\n\t})\n}\n\n// Data writes some data into the body stream and updates the HTTP code.\nfunc (c *Context) Data(code int, contentType string, data []byte) {\n\tc.Render(code, render.Data{\n\t\tContentType: contentType,\n\t\tData:        data,\n\t})\n}\n\n// DataFromReader writes the specified reader into the body stream and updates the HTTP code.\nfunc (c *Context) DataFromReader(code int, contentLength int64, contentType string, reader io.Reader, extraHeaders map[string]string) {\n\tc.Render(code, render.Reader{\n\t\tHeaders:       extraHeaders,\n\t\tContentType:   contentType,\n\t\tContentLength: contentLength,\n\t\tReader:        reader,\n\t})\n}\n\n// File writes the specified file into the body stream in an efficient way.\nfunc (c *Context) File(filepath string) {\n\thttp.ServeFile(c.Writer, c.Request, filepath)\n}\n\n// FileFromFS writes the specified file from http.FileSystem into the body stream in an efficient way.\nfunc (c *Context) FileFromFS(filepath string, fs http.FileSystem) {\n\tdefer func(old string) {\n\t\tc.Request.URL.Path = old\n\t}(c.Request.URL.Path)\n\n\tc.Request.URL.Path = filepath\n\n\thttp.FileServer(fs).ServeHTTP(c.Writer, c.Request)\n}\n\nvar quoteEscaper = strings.NewReplacer(\"\\\\\", \"\\\\\\\\\", `\"`, \"\\\\\\\"\")\n\nfunc escapeQuotes(s string) string {\n\treturn quoteEscaper.Replace(s)\n}\n\n// FileAttachment writes the specified file into the body stream in an efficient way\n// On the client side, the file will typically be downloaded with the given filename\nfunc (c *Context) FileAttachment(filepath, filename string) {\n\tif isASCII(filename) {\n\t\tc.Writer.Header().Set(\"Content-Disposition\", `attachment; filename=\"`+escapeQuotes(filename)+`\"`)\n\t} else {\n\t\tc.Writer.Header().Set(\"Content-Disposition\", `attachment; filename*=UTF-8''`+url.QueryEscape(filename))\n\t}\n\thttp.ServeFile(c.Writer, c.Request, filepath)\n}\n\n// SSEvent writes a Server-Sent Event into the body stream.\nfunc (c *Context) SSEvent(name string, message any) {\n\tc.Render(-1, sse.Event{\n\t\tEvent: name,\n\t\tData:  message,\n\t})\n}\n\n// Stream sends a streaming response and returns a boolean\n// indicates \"Is client disconnected in middle of stream\"\nfunc (c *Context) Stream(step func(w io.Writer) bool) bool {\n\tw := c.Writer\n\tclientGone := w.CloseNotify()\n\tfor {\n\t\tselect {\n\t\tcase <-clientGone:\n\t\t\treturn true\n\t\tdefault:\n\t\t\tkeepOpen := step(w)\n\t\t\tw.Flush()\n\t\t\tif !keepOpen {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n}\n\n/************************************/\n/******** CONTENT NEGOTIATION *******/\n/************************************/\n\n// Negotiate contains all negotiations data.\ntype Negotiate struct {\n\tOffered  []string\n\tHTMLName string\n\tHTMLData any\n\tJSONData any\n\tXMLData  any\n\tYAMLData any\n\tData     any\n\tTOMLData any\n}\n\n// Negotiate calls different Render according to acceptable Accept format.\nfunc (c *Context) Negotiate(code int, config Negotiate) {\n\tswitch c.NegotiateFormat(config.Offered...) {\n\tcase binding.MIMEJSON:\n\t\tdata := chooseData(config.JSONData, config.Data)\n\t\tc.JSON(code, data)\n\n\tcase binding.MIMEHTML:\n\t\tdata := chooseData(config.HTMLData, config.Data)\n\t\tc.HTML(code, config.HTMLName, data)\n\n\tcase binding.MIMEXML:\n\t\tdata := chooseData(config.XMLData, config.Data)\n\t\tc.XML(code, data)\n\n\tcase binding.MIMEYAML, binding.MIMEYAML2:\n\t\tdata := chooseData(config.YAMLData, config.Data)\n\t\tc.YAML(code, data)\n\n\tcase binding.MIMETOML:\n\t\tdata := chooseData(config.TOMLData, config.Data)\n\t\tc.TOML(code, data)\n\n\tdefault:\n\t\tc.AbortWithError(http.StatusNotAcceptable, errors.New(\"the accepted formats are not offered by the server\")) //nolint: errcheck\n\t}\n}\n\n// NegotiateFormat returns an acceptable Accept format.\nfunc (c *Context) NegotiateFormat(offered ...string) string {\n\tassert1(len(offered) > 0, \"you must provide at least one offer\")\n\n\tif c.Accepted == nil {\n\t\tc.Accepted = parseAccept(c.requestHeader(\"Accept\"))\n\t}\n\tif len(c.Accepted) == 0 {\n\t\treturn offered[0]\n\t}\n\tfor _, accepted := range c.Accepted {\n\t\tfor _, offer := range offered {\n\t\t\t// According to RFC 2616 and RFC 2396, non-ASCII characters are not allowed in headers,\n\t\t\t// therefore we can just iterate over the string without casting it into []rune\n\t\t\ti := 0\n\t\t\tfor ; i < len(accepted) && i < len(offer); i++ {\n\t\t\t\tif accepted[i] == '*' || offer[i] == '*' {\n\t\t\t\t\treturn offer\n\t\t\t\t}\n\t\t\t\tif accepted[i] != offer[i] {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif i == len(accepted) {\n\t\t\t\treturn offer\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// SetAccepted sets Accept header data.\nfunc (c *Context) SetAccepted(formats ...string) {\n\tc.Accepted = formats\n}\n\n/************************************/\n/***** GOLANG.ORG/X/NET/CONTEXT *****/\n/************************************/\n\n// hasRequestContext returns whether c.Request has Context and fallback.\nfunc (c *Context) hasRequestContext() bool {\n\thasFallback := c.engine != nil && c.engine.ContextWithFallback\n\thasRequestContext := c.Request != nil && c.Request.Context() != nil\n\treturn hasFallback && hasRequestContext\n}\n\n// Deadline returns that there is no deadline (ok==false) when c.Request has no Context.\nfunc (c *Context) Deadline() (deadline time.Time, ok bool) {\n\tif !c.hasRequestContext() {\n\t\treturn\n\t}\n\treturn c.Request.Context().Deadline()\n}\n\n// Done returns nil (chan which will wait forever) when c.Request has no Context.\nfunc (c *Context) Done() <-chan struct{} {\n\tif !c.hasRequestContext() {\n\t\treturn nil\n\t}\n\treturn c.Request.Context().Done()\n}\n\n// Err returns nil when c.Request has no Context.\nfunc (c *Context) Err() error {\n\tif !c.hasRequestContext() {\n\t\treturn nil\n\t}\n\treturn c.Request.Context().Err()\n}\n\n// Value returns the value associated with this context for key, or nil\n// if no value is associated with key. Successive calls to Value with\n// the same key returns the same result.\nfunc (c *Context) Value(key any) any {\n\tif key == ContextRequestKey {\n\t\treturn c.Request\n\t}\n\tif key == ContextKey {\n\t\treturn c\n\t}\n\tif keyAsString, ok := key.(string); ok {\n\t\tif val, exists := c.Get(keyAsString); exists {\n\t\t\treturn val\n\t\t}\n\t}\n\tif !c.hasRequestContext() {\n\t\treturn nil\n\t}\n\treturn c.Request.Context().Value(key)\n}\n"
        },
        {
          "name": "context_appengine.go",
          "type": "blob",
          "size": 0.2548828125,
          "content": "// Copyright 2017 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\n//go:build appengine\n\npackage gin\n\nfunc init() {\n\tdefaultPlatform = PlatformGoogleAppEngine\n}\n"
        },
        {
          "name": "context_test.go",
          "type": "blob",
          "size": 91.521484375,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io\"\n\t\"io/fs\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/gin-contrib/sse\"\n\t\"github.com/gin-gonic/gin/binding\"\n\ttestdata \"github.com/gin-gonic/gin/testdata/protoexample\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nvar _ context.Context = (*Context)(nil)\n\nvar errTestRender = errors.New(\"TestRender\")\n\n// Unit tests TODO\n// func (c *Context) File(filepath string) {\n// func (c *Context) Negotiate(code int, config Negotiate) {\n// BAD case: func (c *Context) Render(code int, render render.Render, obj ...any) {\n// test that information is not leaked when reusing Contexts (using the Pool)\n\nfunc createMultipartRequest() *http.Request {\n\tboundary := \"--testboundary\"\n\tbody := new(bytes.Buffer)\n\tmw := multipart.NewWriter(body)\n\tdefer mw.Close()\n\n\tmust(mw.SetBoundary(boundary))\n\tmust(mw.WriteField(\"foo\", \"bar\"))\n\tmust(mw.WriteField(\"bar\", \"10\"))\n\tmust(mw.WriteField(\"bar\", \"foo2\"))\n\tmust(mw.WriteField(\"array\", \"first\"))\n\tmust(mw.WriteField(\"array\", \"second\"))\n\tmust(mw.WriteField(\"id\", \"\"))\n\tmust(mw.WriteField(\"time_local\", \"31/12/2016 14:55\"))\n\tmust(mw.WriteField(\"time_utc\", \"31/12/2016 14:55\"))\n\tmust(mw.WriteField(\"time_location\", \"31/12/2016 14:55\"))\n\tmust(mw.WriteField(\"names[a]\", \"thinkerou\"))\n\tmust(mw.WriteField(\"names[b]\", \"tianou\"))\n\treq, err := http.NewRequest(http.MethodPost, \"/\", body)\n\tmust(err)\n\treq.Header.Set(\"Content-Type\", MIMEMultipartPOSTForm+\"; boundary=\"+boundary)\n\treturn req\n}\n\nfunc must(err error) {\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n}\n\nfunc TestContextFormFile(t *testing.T) {\n\tbuf := new(bytes.Buffer)\n\tmw := multipart.NewWriter(buf)\n\tw, err := mw.CreateFormFile(\"file\", \"test\")\n\trequire.NoError(t, err)\n\t_, err = w.Write([]byte(\"test\"))\n\trequire.NoError(t, err)\n\tmw.Close()\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", buf)\n\tc.Request.Header.Set(\"Content-Type\", mw.FormDataContentType())\n\tf, err := c.FormFile(\"file\")\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"test\", f.Filename)\n\n\trequire.NoError(t, c.SaveUploadedFile(f, \"test\"))\n}\n\nfunc TestContextFormFileFailed(t *testing.T) {\n\tbuf := new(bytes.Buffer)\n\tmw := multipart.NewWriter(buf)\n\tmw.Close()\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", nil)\n\tc.Request.Header.Set(\"Content-Type\", mw.FormDataContentType())\n\tc.engine.MaxMultipartMemory = 8 << 20\n\tf, err := c.FormFile(\"file\")\n\trequire.Error(t, err)\n\tassert.Nil(t, f)\n}\n\nfunc TestContextMultipartForm(t *testing.T) {\n\tbuf := new(bytes.Buffer)\n\tmw := multipart.NewWriter(buf)\n\trequire.NoError(t, mw.WriteField(\"foo\", \"bar\"))\n\tw, err := mw.CreateFormFile(\"file\", \"test\")\n\trequire.NoError(t, err)\n\t_, err = w.Write([]byte(\"test\"))\n\trequire.NoError(t, err)\n\tmw.Close()\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", buf)\n\tc.Request.Header.Set(\"Content-Type\", mw.FormDataContentType())\n\tf, err := c.MultipartForm()\n\trequire.NoError(t, err)\n\tassert.NotNil(t, f)\n\n\trequire.NoError(t, c.SaveUploadedFile(f.File[\"file\"][0], \"test\"))\n}\n\nfunc TestSaveUploadedOpenFailed(t *testing.T) {\n\tbuf := new(bytes.Buffer)\n\tmw := multipart.NewWriter(buf)\n\tmw.Close()\n\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", buf)\n\tc.Request.Header.Set(\"Content-Type\", mw.FormDataContentType())\n\n\tf := &multipart.FileHeader{\n\t\tFilename: \"file\",\n\t}\n\trequire.Error(t, c.SaveUploadedFile(f, \"test\"))\n}\n\nfunc TestSaveUploadedCreateFailed(t *testing.T) {\n\tbuf := new(bytes.Buffer)\n\tmw := multipart.NewWriter(buf)\n\tw, err := mw.CreateFormFile(\"file\", \"test\")\n\trequire.NoError(t, err)\n\t_, err = w.Write([]byte(\"test\"))\n\trequire.NoError(t, err)\n\tmw.Close()\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", buf)\n\tc.Request.Header.Set(\"Content-Type\", mw.FormDataContentType())\n\tf, err := c.FormFile(\"file\")\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"test\", f.Filename)\n\n\trequire.Error(t, c.SaveUploadedFile(f, \"/\"))\n}\n\nfunc TestSaveUploadedFileWithPermission(t *testing.T) {\n\tbuf := new(bytes.Buffer)\n\tmw := multipart.NewWriter(buf)\n\tw, err := mw.CreateFormFile(\"file\", \"permission_test\")\n\trequire.NoError(t, err)\n\t_, err = w.Write([]byte(\"permission_test\"))\n\trequire.NoError(t, err)\n\tmw.Close()\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", buf)\n\tc.Request.Header.Set(\"Content-Type\", mw.FormDataContentType())\n\tf, err := c.FormFile(\"file\")\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"permission_test\", f.Filename)\n\tvar mode fs.FileMode = 0o755\n\trequire.NoError(t, c.SaveUploadedFile(f, \"permission_test\", mode))\n\tinfo, err := os.Stat(filepath.Dir(\"permission_test\"))\n\trequire.NoError(t, err)\n\tassert.Equal(t, info.Mode().Perm(), mode)\n}\n\nfunc TestSaveUploadedFileWithPermissionFailed(t *testing.T) {\n\tbuf := new(bytes.Buffer)\n\tmw := multipart.NewWriter(buf)\n\tw, err := mw.CreateFormFile(\"file\", \"permission_test\")\n\trequire.NoError(t, err)\n\t_, err = w.Write([]byte(\"permission_test\"))\n\trequire.NoError(t, err)\n\tmw.Close()\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", buf)\n\tc.Request.Header.Set(\"Content-Type\", mw.FormDataContentType())\n\tf, err := c.FormFile(\"file\")\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"permission_test\", f.Filename)\n\tvar mode fs.FileMode = 0o644\n\trequire.Error(t, c.SaveUploadedFile(f, \"test/permission_test\", mode))\n}\n\nfunc TestContextReset(t *testing.T) {\n\trouter := New()\n\tc := router.allocateContext(0)\n\tassert.Equal(t, c.engine, router)\n\n\tc.index = 2\n\tc.Writer = &responseWriter{ResponseWriter: httptest.NewRecorder()}\n\tc.Params = Params{Param{}}\n\tc.Error(errors.New(\"test\")) //nolint: errcheck\n\tc.Set(\"foo\", \"bar\")\n\tc.reset()\n\n\tassert.False(t, c.IsAborted())\n\tassert.Nil(t, c.Keys)\n\tassert.Nil(t, c.Accepted)\n\tassert.Empty(t, c.Errors)\n\tassert.Empty(t, c.Errors.Errors())\n\tassert.Empty(t, c.Errors.ByType(ErrorTypeAny))\n\tassert.Empty(t, c.Params)\n\tassert.EqualValues(t, c.index, -1)\n\tassert.Equal(t, c.Writer.(*responseWriter), &c.writermem)\n}\n\nfunc TestContextHandlers(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tassert.Nil(t, c.handlers)\n\tassert.Nil(t, c.handlers.Last())\n\n\tc.handlers = HandlersChain{}\n\tassert.NotNil(t, c.handlers)\n\tassert.Nil(t, c.handlers.Last())\n\n\tf := func(c *Context) {}\n\tg := func(c *Context) {}\n\n\tc.handlers = HandlersChain{f}\n\tcompareFunc(t, f, c.handlers.Last())\n\n\tc.handlers = HandlersChain{f, g}\n\tcompareFunc(t, g, c.handlers.Last())\n}\n\n// TestContextSetGet tests that a parameter is set correctly on the\n// current context and can be retrieved using Get.\nfunc TestContextSetGet(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Set(\"foo\", \"bar\")\n\n\tvalue, err := c.Get(\"foo\")\n\tassert.Equal(t, \"bar\", value)\n\tassert.True(t, err)\n\n\tvalue, err = c.Get(\"foo2\")\n\tassert.Nil(t, value)\n\tassert.False(t, err)\n\n\tassert.Equal(t, \"bar\", c.MustGet(\"foo\"))\n\tassert.Panics(t, func() { c.MustGet(\"no_exist\") })\n}\n\nfunc TestContextSetGetValues(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Set(\"string\", \"this is a string\")\n\tc.Set(\"int32\", int32(-42))\n\tc.Set(\"int64\", int64(42424242424242))\n\tc.Set(\"uint64\", uint64(42))\n\tc.Set(\"float32\", float32(4.2))\n\tc.Set(\"float64\", 4.2)\n\tvar a any = 1\n\tc.Set(\"intInterface\", a)\n\n\tassert.Exactly(t, \"this is a string\", c.MustGet(\"string\").(string))\n\tassert.Exactly(t, c.MustGet(\"int32\").(int32), int32(-42))\n\tassert.Exactly(t, int64(42424242424242), c.MustGet(\"int64\").(int64))\n\tassert.Exactly(t, uint64(42), c.MustGet(\"uint64\").(uint64))\n\tassert.InDelta(t, float32(4.2), c.MustGet(\"float32\").(float32), 0.01)\n\tassert.InDelta(t, 4.2, c.MustGet(\"float64\").(float64), 0.01)\n\tassert.Exactly(t, 1, c.MustGet(\"intInterface\").(int))\n}\n\nfunc TestContextGetString(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Set(\"string\", \"this is a string\")\n\tassert.Equal(t, \"this is a string\", c.GetString(\"string\"))\n}\n\nfunc TestContextSetGetBool(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Set(\"bool\", true)\n\tassert.True(t, c.GetBool(\"bool\"))\n}\n\nfunc TestContextGetInt(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Set(\"int\", 1)\n\tassert.Equal(t, 1, c.GetInt(\"int\"))\n}\n\nfunc TestContextGetInt8(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"int8\"\n\tvalue := int8(0x7F)\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetInt8(key))\n}\n\nfunc TestContextGetInt16(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"int16\"\n\tvalue := int16(0x7FFF)\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetInt16(key))\n}\n\nfunc TestContextGetInt32(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"int32\"\n\tvalue := int32(0x7FFFFFFF)\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetInt32(key))\n}\n\nfunc TestContextGetInt64(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Set(\"int64\", int64(42424242424242))\n\tassert.Equal(t, int64(42424242424242), c.GetInt64(\"int64\"))\n}\n\nfunc TestContextGetUint(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Set(\"uint\", uint(1))\n\tassert.Equal(t, uint(1), c.GetUint(\"uint\"))\n}\n\nfunc TestContextGetUint8(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"uint8\"\n\tvalue := uint8(0xFF)\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetUint8(key))\n}\n\nfunc TestContextGetUint16(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"uint16\"\n\tvalue := uint16(0xFFFF)\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetUint16(key))\n}\n\nfunc TestContextGetUint32(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"uint32\"\n\tvalue := uint32(0xFFFFFFFF)\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetUint32(key))\n}\n\nfunc TestContextGetUint64(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Set(\"uint64\", uint64(18446744073709551615))\n\tassert.Equal(t, uint64(18446744073709551615), c.GetUint64(\"uint64\"))\n}\n\nfunc TestContextGetFloat32(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"float32\"\n\tvalue := float32(3.14)\n\tc.Set(key, value)\n\tassert.InDelta(t, value, c.GetFloat32(key), 0.01)\n}\n\nfunc TestContextGetFloat64(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Set(\"float64\", 4.2)\n\tassert.InDelta(t, 4.2, c.GetFloat64(\"float64\"), 0.01)\n}\n\nfunc TestContextGetTime(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tt1, _ := time.Parse(\"1/2/2006 15:04:05\", \"01/01/2017 12:00:00\")\n\tc.Set(\"time\", t1)\n\tassert.Equal(t, t1, c.GetTime(\"time\"))\n}\n\nfunc TestContextGetDuration(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Set(\"duration\", time.Second)\n\tassert.Equal(t, time.Second, c.GetDuration(\"duration\"))\n}\n\nfunc TestContextGetIntSlice(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"int-slice\"\n\tvalue := []int{1, 2}\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetIntSlice(key))\n}\n\nfunc TestContextGetInt8Slice(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"int8-slice\"\n\tvalue := []int8{1, 2}\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetInt8Slice(key))\n}\n\nfunc TestContextGetInt16Slice(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"int16-slice\"\n\tvalue := []int16{1, 2}\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetInt16Slice(key))\n}\n\nfunc TestContextGetInt32Slice(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"int32-slice\"\n\tvalue := []int32{1, 2}\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetInt32Slice(key))\n}\n\nfunc TestContextGetInt64Slice(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"int64-slice\"\n\tvalue := []int64{1, 2}\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetInt64Slice(key))\n}\n\nfunc TestContextGetUintSlice(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"uint-slice\"\n\tvalue := []uint{1, 2}\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetUintSlice(key))\n}\n\nfunc TestContextGetUint8Slice(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"uint8-slice\"\n\tvalue := []uint8{1, 2}\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetUint8Slice(key))\n}\n\nfunc TestContextGetUint16Slice(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"uint16-slice\"\n\tvalue := []uint16{1, 2}\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetUint16Slice(key))\n}\n\nfunc TestContextGetUint32Slice(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"uint32-slice\"\n\tvalue := []uint32{1, 2}\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetUint32Slice(key))\n}\n\nfunc TestContextGetUint64Slice(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"uint64-slice\"\n\tvalue := []uint64{1, 2}\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetUint64Slice(key))\n}\n\nfunc TestContextGetFloat32Slice(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"float32-slice\"\n\tvalue := []float32{1, 2}\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetFloat32Slice(key))\n}\n\nfunc TestContextGetFloat64Slice(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tkey := \"float64-slice\"\n\tvalue := []float64{1, 2}\n\tc.Set(key, value)\n\tassert.Equal(t, value, c.GetFloat64Slice(key))\n}\n\nfunc TestContextGetStringSlice(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Set(\"slice\", []string{\"foo\"})\n\tassert.Equal(t, []string{\"foo\"}, c.GetStringSlice(\"slice\"))\n}\n\nfunc TestContextGetStringMap(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tm := make(map[string]any)\n\tm[\"foo\"] = 1\n\tc.Set(\"map\", m)\n\n\tassert.Equal(t, m, c.GetStringMap(\"map\"))\n\tassert.Equal(t, 1, c.GetStringMap(\"map\")[\"foo\"])\n}\n\nfunc TestContextGetStringMapString(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tm := make(map[string]string)\n\tm[\"foo\"] = \"bar\"\n\tc.Set(\"map\", m)\n\n\tassert.Equal(t, m, c.GetStringMapString(\"map\"))\n\tassert.Equal(t, \"bar\", c.GetStringMapString(\"map\")[\"foo\"])\n}\n\nfunc TestContextGetStringMapStringSlice(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tm := make(map[string][]string)\n\tm[\"foo\"] = []string{\"foo\"}\n\tc.Set(\"map\", m)\n\n\tassert.Equal(t, m, c.GetStringMapStringSlice(\"map\"))\n\tassert.Equal(t, []string{\"foo\"}, c.GetStringMapStringSlice(\"map\")[\"foo\"])\n}\n\nfunc TestContextCopy(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.index = 2\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/hola\", nil)\n\tc.handlers = HandlersChain{func(c *Context) {}}\n\tc.Params = Params{Param{Key: \"foo\", Value: \"bar\"}}\n\tc.Set(\"foo\", \"bar\")\n\tc.fullPath = \"/hola\"\n\n\tcp := c.Copy()\n\tassert.Nil(t, cp.handlers)\n\tassert.Nil(t, cp.writermem.ResponseWriter)\n\tassert.Equal(t, &cp.writermem, cp.Writer.(*responseWriter))\n\tassert.Equal(t, cp.Request, c.Request)\n\tassert.Equal(t, abortIndex, cp.index)\n\tassert.Equal(t, cp.Keys, c.Keys)\n\tassert.Equal(t, cp.engine, c.engine)\n\tassert.Equal(t, cp.Params, c.Params)\n\tcp.Set(\"foo\", \"notBar\")\n\tassert.NotEqual(t, cp.Keys[\"foo\"], c.Keys[\"foo\"])\n\tassert.Equal(t, cp.fullPath, c.fullPath)\n}\n\nfunc TestContextHandlerName(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.handlers = HandlersChain{func(c *Context) {}, handlerNameTest}\n\n\tassert.Regexp(t, \"^(.*/vendor/)?github.com/gin-gonic/gin.handlerNameTest$\", c.HandlerName())\n}\n\nfunc TestContextHandlerNames(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.handlers = HandlersChain{func(c *Context) {}, nil, handlerNameTest, func(c *Context) {}, handlerNameTest2}\n\n\tnames := c.HandlerNames()\n\n\tassert.Len(t, names, 4)\n\tfor _, name := range names {\n\t\tassert.Regexp(t, `^(.*/vendor/)?(github\\.com/gin-gonic/gin\\.){1}(TestContextHandlerNames\\.func.*){0,1}(handlerNameTest.*){0,1}`, name)\n\t}\n}\n\nfunc handlerNameTest(c *Context) {\n}\n\nfunc handlerNameTest2(c *Context) {\n}\n\nvar handlerTest HandlerFunc = func(c *Context) {\n}\n\nfunc TestContextHandler(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.handlers = HandlersChain{func(c *Context) {}, handlerTest}\n\n\tassert.Equal(t, reflect.ValueOf(handlerTest).Pointer(), reflect.ValueOf(c.Handler()).Pointer())\n}\n\nfunc TestContextQuery(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodGet, \"http://example.com/?foo=bar&page=10&id=\", nil)\n\n\tvalue, ok := c.GetQuery(\"foo\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"bar\", value)\n\tassert.Equal(t, \"bar\", c.DefaultQuery(\"foo\", \"none\"))\n\tassert.Equal(t, \"bar\", c.Query(\"foo\"))\n\n\tvalue, ok = c.GetQuery(\"page\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"10\", value)\n\tassert.Equal(t, \"10\", c.DefaultQuery(\"page\", \"0\"))\n\tassert.Equal(t, \"10\", c.Query(\"page\"))\n\n\tvalue, ok = c.GetQuery(\"id\")\n\tassert.True(t, ok)\n\tassert.Empty(t, value)\n\tassert.Empty(t, c.DefaultQuery(\"id\", \"nada\"))\n\tassert.Empty(t, c.Query(\"id\"))\n\n\tvalue, ok = c.GetQuery(\"NoKey\")\n\tassert.False(t, ok)\n\tassert.Empty(t, value)\n\tassert.Equal(t, \"nada\", c.DefaultQuery(\"NoKey\", \"nada\"))\n\tassert.Empty(t, c.Query(\"NoKey\"))\n\n\t// postform should not mess\n\tvalue, ok = c.GetPostForm(\"page\")\n\tassert.False(t, ok)\n\tassert.Empty(t, value)\n\tassert.Empty(t, c.PostForm(\"foo\"))\n}\n\nfunc TestContextInitQueryCache(t *testing.T) {\n\tvalidURL, err := url.Parse(\"https://github.com/gin-gonic/gin/pull/3969?key=value&otherkey=othervalue\")\n\trequire.NoError(t, err)\n\n\ttests := []struct {\n\t\ttestName           string\n\t\ttestContext        *Context\n\t\texpectedQueryCache url.Values\n\t}{\n\t\t{\n\t\t\ttestName: \"queryCache should remain unchanged if already not nil\",\n\t\t\ttestContext: &Context{\n\t\t\t\tqueryCache: url.Values{\"a\": []string{\"b\"}},\n\t\t\t\tRequest:    &http.Request{URL: validURL}, // valid request for evidence that values weren't extracted\n\t\t\t},\n\t\t\texpectedQueryCache: url.Values{\"a\": []string{\"b\"}},\n\t\t},\n\t\t{\n\t\t\ttestName:           \"queryCache should be empty when Request is nil\",\n\t\t\ttestContext:        &Context{Request: nil}, // explicit nil for readability\n\t\t\texpectedQueryCache: url.Values{},\n\t\t},\n\t\t{\n\t\t\ttestName:           \"queryCache should be empty when Request.URL is nil\",\n\t\t\ttestContext:        &Context{Request: &http.Request{URL: nil}}, // explicit nil for readability\n\t\t\texpectedQueryCache: url.Values{},\n\t\t},\n\t\t{\n\t\t\ttestName:           \"queryCache should be populated when it not yet populated and Request + Request.URL are non nil\",\n\t\t\ttestContext:        &Context{Request: &http.Request{URL: validURL}}, // explicit nil for readability\n\t\t\texpectedQueryCache: url.Values{\"key\": []string{\"value\"}, \"otherkey\": []string{\"othervalue\"}},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.testName, func(t *testing.T) {\n\t\t\ttest.testContext.initQueryCache()\n\t\t\tassert.Equal(t, test.expectedQueryCache, test.testContext.queryCache)\n\t\t})\n\t}\n}\n\nfunc TestContextDefaultQueryOnEmptyRequest(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder()) // here c.Request == nil\n\tassert.NotPanics(t, func() {\n\t\tvalue, ok := c.GetQuery(\"NoKey\")\n\t\tassert.False(t, ok)\n\t\tassert.Empty(t, value)\n\t})\n\tassert.NotPanics(t, func() {\n\t\tassert.Equal(t, \"nada\", c.DefaultQuery(\"NoKey\", \"nada\"))\n\t})\n\tassert.NotPanics(t, func() {\n\t\tassert.Empty(t, c.Query(\"NoKey\"))\n\t})\n}\n\nfunc TestContextQueryAndPostForm(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tbody := bytes.NewBufferString(\"foo=bar&page=11&both=&foo=second\")\n\tc.Request, _ = http.NewRequest(http.MethodPost,\n\t\t\"/?both=GET&id=main&id=omit&array[]=first&array[]=second&ids[a]=hi&ids[b]=3.14\", body)\n\tc.Request.Header.Add(\"Content-Type\", MIMEPOSTForm)\n\n\tassert.Equal(t, \"bar\", c.DefaultPostForm(\"foo\", \"none\"))\n\tassert.Equal(t, \"bar\", c.PostForm(\"foo\"))\n\tassert.Empty(t, c.Query(\"foo\"))\n\n\tvalue, ok := c.GetPostForm(\"page\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"11\", value)\n\tassert.Equal(t, \"11\", c.DefaultPostForm(\"page\", \"0\"))\n\tassert.Equal(t, \"11\", c.PostForm(\"page\"))\n\tassert.Empty(t, c.Query(\"page\"))\n\n\tvalue, ok = c.GetPostForm(\"both\")\n\tassert.True(t, ok)\n\tassert.Empty(t, value)\n\tassert.Empty(t, c.PostForm(\"both\"))\n\tassert.Empty(t, c.DefaultPostForm(\"both\", \"nothing\"))\n\tassert.Equal(t, http.MethodGet, c.Query(\"both\"), http.MethodGet)\n\n\tvalue, ok = c.GetQuery(\"id\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"main\", value)\n\tassert.Equal(t, \"000\", c.DefaultPostForm(\"id\", \"000\"))\n\tassert.Equal(t, \"main\", c.Query(\"id\"))\n\tassert.Empty(t, c.PostForm(\"id\"))\n\n\tvalue, ok = c.GetQuery(\"NoKey\")\n\tassert.False(t, ok)\n\tassert.Empty(t, value)\n\tvalue, ok = c.GetPostForm(\"NoKey\")\n\tassert.False(t, ok)\n\tassert.Empty(t, value)\n\tassert.Equal(t, \"nada\", c.DefaultPostForm(\"NoKey\", \"nada\"))\n\tassert.Equal(t, \"nothing\", c.DefaultQuery(\"NoKey\", \"nothing\"))\n\tassert.Empty(t, c.PostForm(\"NoKey\"))\n\tassert.Empty(t, c.Query(\"NoKey\"))\n\n\tvar obj struct {\n\t\tFoo   string   `form:\"foo\"`\n\t\tID    string   `form:\"id\"`\n\t\tPage  int      `form:\"page\"`\n\t\tBoth  string   `form:\"both\"`\n\t\tArray []string `form:\"array[]\"`\n\t}\n\trequire.NoError(t, c.Bind(&obj))\n\tassert.Equal(t, \"bar\", obj.Foo, \"bar\")\n\tassert.Equal(t, \"main\", obj.ID, \"main\")\n\tassert.Equal(t, 11, obj.Page, 11)\n\tassert.Empty(t, obj.Both)\n\tassert.Equal(t, []string{\"first\", \"second\"}, obj.Array)\n\n\tvalues, ok := c.GetQueryArray(\"array[]\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"first\", values[0])\n\tassert.Equal(t, \"second\", values[1])\n\n\tvalues = c.QueryArray(\"array[]\")\n\tassert.Equal(t, \"first\", values[0])\n\tassert.Equal(t, \"second\", values[1])\n\n\tvalues = c.QueryArray(\"nokey\")\n\tassert.Empty(t, values)\n\n\tvalues = c.QueryArray(\"both\")\n\tassert.Len(t, values, 1)\n\tassert.Equal(t, http.MethodGet, values[0])\n\n\tdicts, ok := c.GetQueryMap(\"ids\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"hi\", dicts[\"a\"])\n\tassert.Equal(t, \"3.14\", dicts[\"b\"])\n\n\tdicts, ok = c.GetQueryMap(\"nokey\")\n\tassert.False(t, ok)\n\tassert.Empty(t, dicts)\n\n\tdicts, ok = c.GetQueryMap(\"both\")\n\tassert.False(t, ok)\n\tassert.Empty(t, dicts)\n\n\tdicts, ok = c.GetQueryMap(\"array\")\n\tassert.False(t, ok)\n\tassert.Empty(t, dicts)\n\n\tdicts = c.QueryMap(\"ids\")\n\tassert.Equal(t, \"hi\", dicts[\"a\"])\n\tassert.Equal(t, \"3.14\", dicts[\"b\"])\n\n\tdicts = c.QueryMap(\"nokey\")\n\tassert.Empty(t, dicts)\n}\n\nfunc TestContextPostFormMultipart(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request = createMultipartRequest()\n\n\tvar obj struct {\n\t\tFoo          string    `form:\"foo\"`\n\t\tBar          string    `form:\"bar\"`\n\t\tBarAsInt     int       `form:\"bar\"`\n\t\tArray        []string  `form:\"array\"`\n\t\tID           string    `form:\"id\"`\n\t\tTimeLocal    time.Time `form:\"time_local\" time_format:\"02/01/2006 15:04\"`\n\t\tTimeUTC      time.Time `form:\"time_utc\" time_format:\"02/01/2006 15:04\" time_utc:\"1\"`\n\t\tTimeLocation time.Time `form:\"time_location\" time_format:\"02/01/2006 15:04\" time_location:\"Asia/Tokyo\"`\n\t\tBlankTime    time.Time `form:\"blank_time\" time_format:\"02/01/2006 15:04\"`\n\t}\n\trequire.NoError(t, c.Bind(&obj))\n\tassert.Equal(t, \"bar\", obj.Foo)\n\tassert.Equal(t, \"10\", obj.Bar)\n\tassert.Equal(t, 10, obj.BarAsInt)\n\tassert.Equal(t, []string{\"first\", \"second\"}, obj.Array)\n\tassert.Empty(t, obj.ID)\n\tassert.Equal(t, \"31/12/2016 14:55\", obj.TimeLocal.Format(\"02/01/2006 15:04\"))\n\tassert.Equal(t, time.Local, obj.TimeLocal.Location())\n\tassert.Equal(t, \"31/12/2016 14:55\", obj.TimeUTC.Format(\"02/01/2006 15:04\"))\n\tassert.Equal(t, time.UTC, obj.TimeUTC.Location())\n\tloc, _ := time.LoadLocation(\"Asia/Tokyo\")\n\tassert.Equal(t, \"31/12/2016 14:55\", obj.TimeLocation.Format(\"02/01/2006 15:04\"))\n\tassert.Equal(t, loc, obj.TimeLocation.Location())\n\tassert.True(t, obj.BlankTime.IsZero())\n\n\tvalue, ok := c.GetQuery(\"foo\")\n\tassert.False(t, ok)\n\tassert.Empty(t, value)\n\tassert.Empty(t, c.Query(\"bar\"))\n\tassert.Equal(t, \"nothing\", c.DefaultQuery(\"id\", \"nothing\"))\n\n\tvalue, ok = c.GetPostForm(\"foo\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"bar\", value)\n\tassert.Equal(t, \"bar\", c.PostForm(\"foo\"))\n\n\tvalue, ok = c.GetPostForm(\"array\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"first\", value)\n\tassert.Equal(t, \"first\", c.PostForm(\"array\"))\n\n\tassert.Equal(t, \"10\", c.DefaultPostForm(\"bar\", \"nothing\"))\n\n\tvalue, ok = c.GetPostForm(\"id\")\n\tassert.True(t, ok)\n\tassert.Empty(t, value)\n\tassert.Empty(t, c.PostForm(\"id\"))\n\tassert.Empty(t, c.DefaultPostForm(\"id\", \"nothing\"))\n\n\tvalue, ok = c.GetPostForm(\"nokey\")\n\tassert.False(t, ok)\n\tassert.Empty(t, value)\n\tassert.Equal(t, \"nothing\", c.DefaultPostForm(\"nokey\", \"nothing\"))\n\n\tvalues, ok := c.GetPostFormArray(\"array\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"first\", values[0])\n\tassert.Equal(t, \"second\", values[1])\n\n\tvalues = c.PostFormArray(\"array\")\n\tassert.Equal(t, \"first\", values[0])\n\tassert.Equal(t, \"second\", values[1])\n\n\tvalues = c.PostFormArray(\"nokey\")\n\tassert.Empty(t, values)\n\n\tvalues = c.PostFormArray(\"foo\")\n\tassert.Len(t, values, 1)\n\tassert.Equal(t, \"bar\", values[0])\n\n\tdicts, ok := c.GetPostFormMap(\"names\")\n\tassert.True(t, ok)\n\tassert.Equal(t, \"thinkerou\", dicts[\"a\"])\n\tassert.Equal(t, \"tianou\", dicts[\"b\"])\n\n\tdicts, ok = c.GetPostFormMap(\"nokey\")\n\tassert.False(t, ok)\n\tassert.Empty(t, dicts)\n\n\tdicts = c.PostFormMap(\"names\")\n\tassert.Equal(t, \"thinkerou\", dicts[\"a\"])\n\tassert.Equal(t, \"tianou\", dicts[\"b\"])\n\n\tdicts = c.PostFormMap(\"nokey\")\n\tassert.Empty(t, dicts)\n}\n\nfunc TestContextSetCookie(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.SetSameSite(http.SameSiteLaxMode)\n\tc.SetCookie(\"user\", \"gin\", 1, \"/\", \"localhost\", true, true)\n\tassert.Equal(t, \"user=gin; Path=/; Domain=localhost; Max-Age=1; HttpOnly; Secure; SameSite=Lax\", c.Writer.Header().Get(\"Set-Cookie\"))\n}\n\nfunc TestContextSetCookiePathEmpty(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.SetSameSite(http.SameSiteLaxMode)\n\tc.SetCookie(\"user\", \"gin\", 1, \"\", \"localhost\", true, true)\n\tassert.Equal(t, \"user=gin; Path=/; Domain=localhost; Max-Age=1; HttpOnly; Secure; SameSite=Lax\", c.Writer.Header().Get(\"Set-Cookie\"))\n}\n\nfunc TestContextGetCookie(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodGet, \"/get\", nil)\n\tc.Request.Header.Set(\"Cookie\", \"user=gin\")\n\tcookie, _ := c.Cookie(\"user\")\n\tassert.Equal(t, \"gin\", cookie)\n\n\t_, err := c.Cookie(\"nokey\")\n\trequire.Error(t, err)\n}\n\nfunc TestContextBodyAllowedForStatus(t *testing.T) {\n\tassert.False(t, false, bodyAllowedForStatus(http.StatusProcessing))\n\tassert.False(t, false, bodyAllowedForStatus(http.StatusNoContent))\n\tassert.False(t, false, bodyAllowedForStatus(http.StatusNotModified))\n\tassert.True(t, true, bodyAllowedForStatus(http.StatusInternalServerError))\n}\n\ntype TestRender struct{}\n\nfunc (*TestRender) Render(http.ResponseWriter) error {\n\treturn errTestRender\n}\n\nfunc (*TestRender) WriteContentType(http.ResponseWriter) {}\n\nfunc TestContextRenderIfErr(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Render(http.StatusOK, &TestRender{})\n\n\tassert.Equal(t, errorMsgs{&Error{Err: errTestRender, Type: 1}}, c.Errors)\n}\n\n// Tests that the response is serialized as JSON\n// and Content-Type is set to application/json\n// and special HTML characters are escaped\nfunc TestContextRenderJSON(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.JSON(http.StatusCreated, H{\"foo\": \"bar\", \"html\": \"<b>\"})\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"{\\\"foo\\\":\\\"bar\\\",\\\"html\\\":\\\"\\\\u003cb\\\\u003e\\\"}\", w.Body.String())\n\tassert.Equal(t, \"application/json; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that the response is serialized as JSONP\n// and Content-Type is set to application/javascript\nfunc TestContextRenderJSONP(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\tc.Request, _ = http.NewRequest(http.MethodGet, \"http://example.com/?callback=x\", nil)\n\n\tc.JSONP(http.StatusCreated, H{\"foo\": \"bar\"})\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"x({\\\"foo\\\":\\\"bar\\\"});\", w.Body.String())\n\tassert.Equal(t, \"application/javascript; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that the response is serialized as JSONP\n// and Content-Type is set to application/json\nfunc TestContextRenderJSONPWithoutCallback(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\tc.Request, _ = http.NewRequest(http.MethodGet, \"http://example.com\", nil)\n\n\tc.JSONP(http.StatusCreated, H{\"foo\": \"bar\"})\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"{\\\"foo\\\":\\\"bar\\\"}\", w.Body.String())\n\tassert.Equal(t, \"application/json; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that no JSON is rendered if code is 204\nfunc TestContextRenderNoContentJSON(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.JSON(http.StatusNoContent, H{\"foo\": \"bar\"})\n\n\tassert.Equal(t, http.StatusNoContent, w.Code)\n\tassert.Empty(t, w.Body.String())\n\tassert.Equal(t, \"application/json; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that the response is serialized as JSON\n// we change the content-type before\nfunc TestContextRenderAPIJSON(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Header(\"Content-Type\", \"application/vnd.api+json\")\n\tc.JSON(http.StatusCreated, H{\"foo\": \"bar\"})\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"{\\\"foo\\\":\\\"bar\\\"}\", w.Body.String())\n\tassert.Equal(t, \"application/vnd.api+json\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that no Custom JSON is rendered if code is 204\nfunc TestContextRenderNoContentAPIJSON(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Header(\"Content-Type\", \"application/vnd.api+json\")\n\tc.JSON(http.StatusNoContent, H{\"foo\": \"bar\"})\n\n\tassert.Equal(t, http.StatusNoContent, w.Code)\n\tassert.Empty(t, w.Body.String())\n\tassert.Equal(t, \"application/vnd.api+json\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that the response is serialized as JSON\n// and Content-Type is set to application/json\nfunc TestContextRenderIndentedJSON(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.IndentedJSON(http.StatusCreated, H{\"foo\": \"bar\", \"bar\": \"foo\", \"nested\": H{\"foo\": \"bar\"}})\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"{\\n    \\\"bar\\\": \\\"foo\\\",\\n    \\\"foo\\\": \\\"bar\\\",\\n    \\\"nested\\\": {\\n        \\\"foo\\\": \\\"bar\\\"\\n    }\\n}\", w.Body.String())\n\tassert.Equal(t, \"application/json; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that no Custom JSON is rendered if code is 204\nfunc TestContextRenderNoContentIndentedJSON(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.IndentedJSON(http.StatusNoContent, H{\"foo\": \"bar\", \"bar\": \"foo\", \"nested\": H{\"foo\": \"bar\"}})\n\n\tassert.Equal(t, http.StatusNoContent, w.Code)\n\tassert.Empty(t, w.Body.String())\n\tassert.Equal(t, \"application/json; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that the response is serialized as Secure JSON\n// and Content-Type is set to application/json\nfunc TestContextRenderSecureJSON(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, router := CreateTestContext(w)\n\n\trouter.SecureJsonPrefix(\"&&&START&&&\")\n\tc.SecureJSON(http.StatusCreated, []string{\"foo\", \"bar\"})\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"&&&START&&&[\\\"foo\\\",\\\"bar\\\"]\", w.Body.String())\n\tassert.Equal(t, \"application/json; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that no Custom JSON is rendered if code is 204\nfunc TestContextRenderNoContentSecureJSON(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.SecureJSON(http.StatusNoContent, []string{\"foo\", \"bar\"})\n\n\tassert.Equal(t, http.StatusNoContent, w.Code)\n\tassert.Empty(t, w.Body.String())\n\tassert.Equal(t, \"application/json; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\nfunc TestContextRenderNoContentAsciiJSON(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.AsciiJSON(http.StatusNoContent, []string{\"lang\", \"GoËØ≠Ë®Ä\"})\n\n\tassert.Equal(t, http.StatusNoContent, w.Code)\n\tassert.Empty(t, w.Body.String())\n\tassert.Equal(t, \"application/json\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that the response is serialized as JSON\n// and Content-Type is set to application/json\n// and special HTML characters are preserved\nfunc TestContextRenderPureJSON(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\tc.PureJSON(http.StatusCreated, H{\"foo\": \"bar\", \"html\": \"<b>\"})\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"{\\\"foo\\\":\\\"bar\\\",\\\"html\\\":\\\"<b>\\\"}\\n\", w.Body.String())\n\tassert.Equal(t, \"application/json; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that the response executes the templates\n// and responds with Content-Type set to text/html\nfunc TestContextRenderHTML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, router := CreateTestContext(w)\n\n\ttempl := template.Must(template.New(\"t\").Parse(`Hello {{.name}}`))\n\trouter.SetHTMLTemplate(templ)\n\n\tc.HTML(http.StatusCreated, \"t\", H{\"name\": \"alexandernyquist\"})\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"Hello alexandernyquist\", w.Body.String())\n\tassert.Equal(t, \"text/html; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\nfunc TestContextRenderHTML2(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, router := CreateTestContext(w)\n\n\t// print debug warning log when Engine.trees > 0\n\trouter.addRoute(http.MethodGet, \"/\", HandlersChain{func(_ *Context) {}})\n\tassert.Len(t, router.trees, 1)\n\n\ttempl := template.Must(template.New(\"t\").Parse(`Hello {{.name}}`))\n\tre := captureOutput(t, func() {\n\t\tSetMode(DebugMode)\n\t\trouter.SetHTMLTemplate(templ)\n\t\tSetMode(TestMode)\n\t})\n\n\tassert.Equal(t, \"[GIN-debug] [WARNING] Since SetHTMLTemplate() is NOT thread-safe. It should only be called\\nat initialization. ie. before any route is registered or the router is listening in a socket:\\n\\n\\trouter := gin.Default()\\n\\trouter.SetHTMLTemplate(template) // << good place\\n\\n\", re)\n\n\tc.HTML(http.StatusCreated, \"t\", H{\"name\": \"alexandernyquist\"})\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"Hello alexandernyquist\", w.Body.String())\n\tassert.Equal(t, \"text/html; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that no HTML is rendered if code is 204\nfunc TestContextRenderNoContentHTML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, router := CreateTestContext(w)\n\ttempl := template.Must(template.New(\"t\").Parse(`Hello {{.name}}`))\n\trouter.SetHTMLTemplate(templ)\n\n\tc.HTML(http.StatusNoContent, \"t\", H{\"name\": \"alexandernyquist\"})\n\n\tassert.Equal(t, http.StatusNoContent, w.Code)\n\tassert.Empty(t, w.Body.String())\n\tassert.Equal(t, \"text/html; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// TestContextXML tests that the response is serialized as XML\n// and Content-Type is set to application/xml\nfunc TestContextRenderXML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.XML(http.StatusCreated, H{\"foo\": \"bar\"})\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"<map><foo>bar</foo></map>\", w.Body.String())\n\tassert.Equal(t, \"application/xml; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that no XML is rendered if code is 204\nfunc TestContextRenderNoContentXML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.XML(http.StatusNoContent, H{\"foo\": \"bar\"})\n\n\tassert.Equal(t, http.StatusNoContent, w.Code)\n\tassert.Empty(t, w.Body.String())\n\tassert.Equal(t, \"application/xml; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// TestContextString tests that the response is returned\n// with Content-Type set to text/plain\nfunc TestContextRenderString(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.String(http.StatusCreated, \"test %s %d\", \"string\", 2)\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"test string 2\", w.Body.String())\n\tassert.Equal(t, \"text/plain; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that no String is rendered if code is 204\nfunc TestContextRenderNoContentString(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.String(http.StatusNoContent, \"test %s %d\", \"string\", 2)\n\n\tassert.Equal(t, http.StatusNoContent, w.Code)\n\tassert.Empty(t, w.Body.String())\n\tassert.Equal(t, \"text/plain; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// TestContextString tests that the response is returned\n// with Content-Type set to text/html\nfunc TestContextRenderHTMLString(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Header(\"Content-Type\", \"text/html; charset=utf-8\")\n\tc.String(http.StatusCreated, \"<html>%s %d</html>\", \"string\", 3)\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"<html>string 3</html>\", w.Body.String())\n\tassert.Equal(t, \"text/html; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that no HTML String is rendered if code is 204\nfunc TestContextRenderNoContentHTMLString(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Header(\"Content-Type\", \"text/html; charset=utf-8\")\n\tc.String(http.StatusNoContent, \"<html>%s %d</html>\", \"string\", 3)\n\n\tassert.Equal(t, http.StatusNoContent, w.Code)\n\tassert.Empty(t, w.Body.String())\n\tassert.Equal(t, \"text/html; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// TestContextRenderData tests that the response can be written from `bytestring`\n// with specified MIME type\nfunc TestContextRenderData(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Data(http.StatusCreated, \"text/csv\", []byte(`foo,bar`))\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"foo,bar\", w.Body.String())\n\tassert.Equal(t, \"text/csv\", w.Header().Get(\"Content-Type\"))\n}\n\n// Tests that no Custom Data is rendered if code is 204\nfunc TestContextRenderNoContentData(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Data(http.StatusNoContent, \"text/csv\", []byte(`foo,bar`))\n\n\tassert.Equal(t, http.StatusNoContent, w.Code)\n\tassert.Empty(t, w.Body.String())\n\tassert.Equal(t, \"text/csv\", w.Header().Get(\"Content-Type\"))\n}\n\nfunc TestContextRenderSSE(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.SSEvent(\"float\", 1.5)\n\tc.Render(-1, sse.Event{\n\t\tId:   \"123\",\n\t\tData: \"text\",\n\t})\n\tc.SSEvent(\"chat\", H{\n\t\t\"foo\": \"bar\",\n\t\t\"bar\": \"foo\",\n\t})\n\n\tassert.Equal(t, strings.Replace(w.Body.String(), \" \", \"\", -1), strings.Replace(\"event:float\\ndata:1.5\\n\\nid:123\\ndata:text\\n\\nevent:chat\\ndata:{\\\"bar\\\":\\\"foo\\\",\\\"foo\\\":\\\"bar\\\"}\\n\\n\", \" \", \"\", -1))\n}\n\nfunc TestContextRenderFile(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodGet, \"/\", nil)\n\tc.File(\"./gin.go\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Contains(t, w.Body.String(), \"func New(opts ...OptionFunc) *Engine {\")\n\t// Content-Type='text/plain; charset=utf-8' when go version <= 1.16,\n\t// else, Content-Type='text/x-go; charset=utf-8'\n\tassert.NotEqual(t, \"\", w.Header().Get(\"Content-Type\"))\n}\n\nfunc TestContextRenderFileFromFS(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodGet, \"/some/path\", nil)\n\tc.FileFromFS(\"./gin.go\", Dir(\".\", false))\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Contains(t, w.Body.String(), \"func New(opts ...OptionFunc) *Engine {\")\n\t// Content-Type='text/plain; charset=utf-8' when go version <= 1.16,\n\t// else, Content-Type='text/x-go; charset=utf-8'\n\tassert.NotEqual(t, \"\", w.Header().Get(\"Content-Type\"))\n\tassert.Equal(t, \"/some/path\", c.Request.URL.Path)\n}\n\nfunc TestContextRenderAttachment(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\tnewFilename := \"new_filename.go\"\n\n\tc.Request, _ = http.NewRequest(http.MethodGet, \"/\", nil)\n\tc.FileAttachment(\"./gin.go\", newFilename)\n\n\tassert.Equal(t, 200, w.Code)\n\tassert.Contains(t, w.Body.String(), \"func New(opts ...OptionFunc) *Engine {\")\n\tassert.Equal(t, fmt.Sprintf(\"attachment; filename=\\\"%s\\\"\", newFilename), w.Header().Get(\"Content-Disposition\"))\n}\n\nfunc TestContextRenderAndEscapeAttachment(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\tmaliciousFilename := \"tampering_field.sh\\\"; \\\\\\\"; dummy=.go\"\n\tactualEscapedResponseFilename := \"tampering_field.sh\\\\\\\"; \\\\\\\\\\\\\\\"; dummy=.go\"\n\n\tc.Request, _ = http.NewRequest(http.MethodGet, \"/\", nil)\n\tc.FileAttachment(\"./gin.go\", maliciousFilename)\n\n\tassert.Equal(t, 200, w.Code)\n\tassert.Contains(t, w.Body.String(), \"func New(opts ...OptionFunc) *Engine {\")\n\tassert.Equal(t, fmt.Sprintf(\"attachment; filename=\\\"%s\\\"\", actualEscapedResponseFilename), w.Header().Get(\"Content-Disposition\"))\n}\n\nfunc TestContextRenderUTF8Attachment(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\tnewFilename := \"newüß°_filename.go\"\n\n\tc.Request, _ = http.NewRequest(http.MethodGet, \"/\", nil)\n\tc.FileAttachment(\"./gin.go\", newFilename)\n\n\tassert.Equal(t, 200, w.Code)\n\tassert.Contains(t, w.Body.String(), \"func New(opts ...OptionFunc) *Engine {\")\n\tassert.Equal(t, `attachment; filename*=UTF-8''`+url.QueryEscape(newFilename), w.Header().Get(\"Content-Disposition\"))\n}\n\n// TestContextRenderYAML tests that the response is serialized as YAML\n// and Content-Type is set to application/yaml\nfunc TestContextRenderYAML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.YAML(http.StatusCreated, H{\"foo\": \"bar\"})\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"foo: bar\\n\", w.Body.String())\n\tassert.Equal(t, \"application/yaml; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// TestContextRenderTOML tests that the response is serialized as TOML\n// and Content-Type is set to application/toml\nfunc TestContextRenderTOML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.TOML(http.StatusCreated, H{\"foo\": \"bar\"})\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"foo = 'bar'\\n\", w.Body.String())\n\tassert.Equal(t, \"application/toml; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// TestContextRenderProtoBuf tests that the response is serialized as ProtoBuf\n// and Content-Type is set to application/x-protobuf\n// and we just use the example protobuf to check if the response is correct\nfunc TestContextRenderProtoBuf(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\treps := []int64{int64(1), int64(2)}\n\tlabel := \"test\"\n\tdata := &testdata.Test{\n\t\tLabel: &label,\n\t\tReps:  reps,\n\t}\n\n\tc.ProtoBuf(http.StatusCreated, data)\n\n\tprotoData, err := proto.Marshal(data)\n\trequire.NoError(t, err)\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, string(protoData), w.Body.String())\n\tassert.Equal(t, \"application/x-protobuf\", w.Header().Get(\"Content-Type\"))\n}\n\nfunc TestContextHeaders(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Header(\"Content-Type\", \"text/plain\")\n\tc.Header(\"X-Custom\", \"value\")\n\n\tassert.Equal(t, \"text/plain\", c.Writer.Header().Get(\"Content-Type\"))\n\tassert.Equal(t, \"value\", c.Writer.Header().Get(\"X-Custom\"))\n\n\tc.Header(\"Content-Type\", \"text/html\")\n\tc.Header(\"X-Custom\", \"\")\n\n\tassert.Equal(t, \"text/html\", c.Writer.Header().Get(\"Content-Type\"))\n\t_, exist := c.Writer.Header()[\"X-Custom\"]\n\tassert.False(t, exist)\n}\n\n// TODO\nfunc TestContextRenderRedirectWithRelativePath(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"http://example.com\", nil)\n\tassert.Panics(t, func() { c.Redirect(299, \"/new_path\") })\n\tassert.Panics(t, func() { c.Redirect(309, \"/new_path\") })\n\n\tc.Redirect(http.StatusMovedPermanently, \"/path\")\n\tc.Writer.WriteHeaderNow()\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\tassert.Equal(t, \"/path\", w.Header().Get(\"Location\"))\n}\n\nfunc TestContextRenderRedirectWithAbsolutePath(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"http://example.com\", nil)\n\tc.Redirect(http.StatusFound, \"http://google.com\")\n\tc.Writer.WriteHeaderNow()\n\n\tassert.Equal(t, http.StatusFound, w.Code)\n\tassert.Equal(t, \"http://google.com\", w.Header().Get(\"Location\"))\n}\n\nfunc TestContextRenderRedirectWith201(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"http://example.com\", nil)\n\tc.Redirect(http.StatusCreated, \"/resource\")\n\tc.Writer.WriteHeaderNow()\n\n\tassert.Equal(t, http.StatusCreated, w.Code)\n\tassert.Equal(t, \"/resource\", w.Header().Get(\"Location\"))\n}\n\nfunc TestContextRenderRedirectAll(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"http://example.com\", nil)\n\tassert.Panics(t, func() { c.Redirect(http.StatusOK, \"/resource\") })\n\tassert.Panics(t, func() { c.Redirect(http.StatusAccepted, \"/resource\") })\n\tassert.Panics(t, func() { c.Redirect(299, \"/resource\") })\n\tassert.Panics(t, func() { c.Redirect(309, \"/resource\") })\n\tassert.NotPanics(t, func() { c.Redirect(http.StatusMultipleChoices, \"/resource\") })\n\tassert.NotPanics(t, func() { c.Redirect(http.StatusPermanentRedirect, \"/resource\") })\n}\n\nfunc TestContextNegotiationWithJSON(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"\", nil)\n\n\tc.Negotiate(http.StatusOK, Negotiate{\n\t\tOffered: []string{MIMEJSON, MIMEXML, MIMEYAML, MIMEYAML2},\n\t\tData:    H{\"foo\": \"bar\"},\n\t})\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"{\\\"foo\\\":\\\"bar\\\"}\", w.Body.String())\n\tassert.Equal(t, \"application/json; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\nfunc TestContextNegotiationWithXML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"\", nil)\n\n\tc.Negotiate(http.StatusOK, Negotiate{\n\t\tOffered: []string{MIMEXML, MIMEJSON, MIMEYAML, MIMEYAML2},\n\t\tData:    H{\"foo\": \"bar\"},\n\t})\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"<map><foo>bar</foo></map>\", w.Body.String())\n\tassert.Equal(t, \"application/xml; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\nfunc TestContextNegotiationWithYAML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"\", nil)\n\n\tc.Negotiate(http.StatusOK, Negotiate{\n\t\tOffered: []string{MIMEYAML, MIMEXML, MIMEJSON, MIMETOML, MIMEYAML2},\n\t\tData:    H{\"foo\": \"bar\"},\n\t})\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"foo: bar\\n\", w.Body.String())\n\tassert.Equal(t, \"application/yaml; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\nfunc TestContextNegotiationWithTOML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"\", nil)\n\n\tc.Negotiate(http.StatusOK, Negotiate{\n\t\tOffered: []string{MIMETOML, MIMEXML, MIMEJSON, MIMEYAML, MIMEYAML2},\n\t\tData:    H{\"foo\": \"bar\"},\n\t})\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"foo = 'bar'\\n\", w.Body.String())\n\tassert.Equal(t, \"application/toml; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\nfunc TestContextNegotiationWithHTML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, router := CreateTestContext(w)\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"\", nil)\n\ttempl := template.Must(template.New(\"t\").Parse(`Hello {{.name}}`))\n\trouter.SetHTMLTemplate(templ)\n\n\tc.Negotiate(http.StatusOK, Negotiate{\n\t\tOffered:  []string{MIMEHTML},\n\t\tData:     H{\"name\": \"gin\"},\n\t\tHTMLName: \"t\",\n\t})\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"Hello gin\", w.Body.String())\n\tassert.Equal(t, \"text/html; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\nfunc TestContextNegotiationNotSupport(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"\", nil)\n\n\tc.Negotiate(http.StatusOK, Negotiate{\n\t\tOffered: []string{MIMEPOSTForm},\n\t})\n\n\tassert.Equal(t, http.StatusNotAcceptable, w.Code)\n\tassert.Equal(t, abortIndex, c.index)\n\tassert.True(t, c.IsAborted())\n}\n\nfunc TestContextNegotiationFormat(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"\", nil)\n\n\tassert.Panics(t, func() { c.NegotiateFormat() })\n\tassert.Equal(t, MIMEJSON, c.NegotiateFormat(MIMEJSON, MIMEXML))\n\tassert.Equal(t, MIMEHTML, c.NegotiateFormat(MIMEHTML, MIMEJSON))\n}\n\nfunc TestContextNegotiationFormatWithAccept(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", nil)\n\tc.Request.Header.Add(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9;q=0.8\")\n\n\tassert.Equal(t, MIMEXML, c.NegotiateFormat(MIMEJSON, MIMEXML))\n\tassert.Equal(t, MIMEHTML, c.NegotiateFormat(MIMEXML, MIMEHTML))\n\tassert.Empty(t, c.NegotiateFormat(MIMEJSON))\n}\n\nfunc TestContextNegotiationFormatWithWildcardAccept(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", nil)\n\tc.Request.Header.Add(\"Accept\", \"*/*\")\n\n\tassert.Equal(t, \"*/*\", c.NegotiateFormat(\"*/*\"))\n\tassert.Equal(t, \"text/*\", c.NegotiateFormat(\"text/*\"))\n\tassert.Equal(t, \"application/*\", c.NegotiateFormat(\"application/*\"))\n\tassert.Equal(t, MIMEJSON, c.NegotiateFormat(MIMEJSON))\n\tassert.Equal(t, MIMEXML, c.NegotiateFormat(MIMEXML))\n\tassert.Equal(t, MIMEHTML, c.NegotiateFormat(MIMEHTML))\n\n\tc, _ = CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", nil)\n\tc.Request.Header.Add(\"Accept\", \"text/*\")\n\n\tassert.Equal(t, \"*/*\", c.NegotiateFormat(\"*/*\"))\n\tassert.Equal(t, \"text/*\", c.NegotiateFormat(\"text/*\"))\n\tassert.Equal(t, \"\", c.NegotiateFormat(\"application/*\"))\n\tassert.Equal(t, \"\", c.NegotiateFormat(MIMEJSON))\n\tassert.Equal(t, \"\", c.NegotiateFormat(MIMEXML))\n\tassert.Equal(t, MIMEHTML, c.NegotiateFormat(MIMEHTML))\n}\n\nfunc TestContextNegotiationFormatCustom(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", nil)\n\tc.Request.Header.Add(\"Accept\", \"text/html,application/xhtml+xml,application/xml;q=0.9;q=0.8\")\n\n\tc.Accepted = nil\n\tc.SetAccepted(MIMEJSON, MIMEXML)\n\n\tassert.Equal(t, MIMEJSON, c.NegotiateFormat(MIMEJSON, MIMEXML))\n\tassert.Equal(t, MIMEXML, c.NegotiateFormat(MIMEXML, MIMEHTML))\n\tassert.Equal(t, MIMEJSON, c.NegotiateFormat(MIMEJSON))\n}\n\nfunc TestContextNegotiationFormat2(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", nil)\n\tc.Request.Header.Add(\"Accept\", \"image/tiff-fx\")\n\n\tassert.Equal(t, \"\", c.NegotiateFormat(\"image/tiff\"))\n}\n\nfunc TestContextIsAborted(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tassert.False(t, c.IsAborted())\n\n\tc.Abort()\n\tassert.True(t, c.IsAborted())\n\n\tc.Next()\n\tassert.True(t, c.IsAborted())\n\n\tc.index++\n\tassert.True(t, c.IsAborted())\n}\n\n// TestContextAbortWithStatus tests that the response can be written from `bytestring`\n// with specified MIME type\nfunc TestContextAbortWithStatus(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.index = 4\n\tc.AbortWithStatus(http.StatusUnauthorized)\n\n\tassert.Equal(t, abortIndex, c.index)\n\tassert.Equal(t, http.StatusUnauthorized, c.Writer.Status())\n\tassert.Equal(t, http.StatusUnauthorized, w.Code)\n\tassert.True(t, c.IsAborted())\n}\n\ntype testJSONAbortMsg struct {\n\tFoo string `json:\"foo\"`\n\tBar string `json:\"bar\"`\n}\n\nfunc TestContextAbortWithStatusJSON(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\tc.index = 4\n\n\tin := new(testJSONAbortMsg)\n\tin.Bar = \"barValue\"\n\tin.Foo = \"fooValue\"\n\n\tc.AbortWithStatusJSON(http.StatusUnsupportedMediaType, in)\n\n\tassert.Equal(t, abortIndex, c.index)\n\tassert.Equal(t, http.StatusUnsupportedMediaType, c.Writer.Status())\n\tassert.Equal(t, http.StatusUnsupportedMediaType, w.Code)\n\tassert.True(t, c.IsAborted())\n\n\tcontentType := w.Header().Get(\"Content-Type\")\n\tassert.Equal(t, \"application/json; charset=utf-8\", contentType)\n\n\tbuf := new(bytes.Buffer)\n\t_, err := buf.ReadFrom(w.Body)\n\trequire.NoError(t, err)\n\tjsonStringBody := buf.String()\n\tassert.Equal(t, \"{\\\"foo\\\":\\\"fooValue\\\",\\\"bar\\\":\\\"barValue\\\"}\", jsonStringBody)\n}\n\nfunc TestContextError(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tassert.Empty(t, c.Errors)\n\n\tfirstErr := errors.New(\"first error\")\n\tc.Error(firstErr) //nolint: errcheck\n\tassert.Len(t, c.Errors, 1)\n\tassert.Equal(t, \"Error #01: first error\\n\", c.Errors.String())\n\n\tsecondErr := errors.New(\"second error\")\n\tc.Error(&Error{ //nolint: errcheck\n\t\tErr:  secondErr,\n\t\tMeta: \"some data 2\",\n\t\tType: ErrorTypePublic,\n\t})\n\tassert.Len(t, c.Errors, 2)\n\n\tassert.Equal(t, firstErr, c.Errors[0].Err)\n\tassert.Nil(t, c.Errors[0].Meta)\n\tassert.Equal(t, ErrorTypePrivate, c.Errors[0].Type)\n\n\tassert.Equal(t, secondErr, c.Errors[1].Err)\n\tassert.Equal(t, \"some data 2\", c.Errors[1].Meta)\n\tassert.Equal(t, ErrorTypePublic, c.Errors[1].Type)\n\n\tassert.Equal(t, c.Errors.Last(), c.Errors[1])\n\n\tdefer func() {\n\t\tif recover() == nil {\n\t\t\tt.Error(\"didn't panic\")\n\t\t}\n\t}()\n\tc.Error(nil) //nolint: errcheck\n}\n\nfunc TestContextTypedError(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Error(errors.New(\"externo 0\")).SetType(ErrorTypePublic)  //nolint: errcheck\n\tc.Error(errors.New(\"interno 0\")).SetType(ErrorTypePrivate) //nolint: errcheck\n\n\tfor _, err := range c.Errors.ByType(ErrorTypePublic) {\n\t\tassert.Equal(t, ErrorTypePublic, err.Type)\n\t}\n\tfor _, err := range c.Errors.ByType(ErrorTypePrivate) {\n\t\tassert.Equal(t, ErrorTypePrivate, err.Type)\n\t}\n\tassert.Equal(t, []string{\"externo 0\", \"interno 0\"}, c.Errors.Errors())\n}\n\nfunc TestContextAbortWithError(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.AbortWithError(http.StatusUnauthorized, errors.New(\"bad input\")).SetMeta(\"some input\") //nolint: errcheck\n\n\tassert.Equal(t, http.StatusUnauthorized, w.Code)\n\tassert.Equal(t, abortIndex, c.index)\n\tassert.True(t, c.IsAborted())\n}\n\nfunc TestContextClientIP(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", nil)\n\tc.engine.trustedCIDRs, _ = c.engine.prepareTrustedCIDRs()\n\tresetContextForClientIPTests(c)\n\n\t// Legacy tests (validating that the defaults don't break the\n\t// (insecure!) old behaviour)\n\tassert.Equal(t, \"20.20.20.20\", c.ClientIP())\n\n\tc.Request.Header.Del(\"X-Forwarded-For\")\n\tassert.Equal(t, \"10.10.10.10\", c.ClientIP())\n\n\tc.Request.Header.Set(\"X-Forwarded-For\", \"30.30.30.30  \")\n\tassert.Equal(t, \"30.30.30.30\", c.ClientIP())\n\n\tc.Request.Header.Del(\"X-Forwarded-For\")\n\tc.Request.Header.Del(\"X-Real-IP\")\n\tc.engine.TrustedPlatform = PlatformGoogleAppEngine\n\tassert.Equal(t, \"50.50.50.50\", c.ClientIP())\n\n\tc.Request.Header.Del(\"X-Appengine-Remote-Addr\")\n\tassert.Equal(t, \"40.40.40.40\", c.ClientIP())\n\n\t// no port\n\tc.Request.RemoteAddr = \"50.50.50.50\"\n\tassert.Empty(t, c.ClientIP())\n\n\t// Tests exercising the TrustedProxies functionality\n\tresetContextForClientIPTests(c)\n\n\t// IPv6 support\n\tc.Request.RemoteAddr = \"[::1]:12345\"\n\tassert.Equal(t, \"20.20.20.20\", c.ClientIP())\n\n\tresetContextForClientIPTests(c)\n\t// No trusted proxies\n\t_ = c.engine.SetTrustedProxies([]string{})\n\tc.engine.RemoteIPHeaders = []string{\"X-Forwarded-For\"}\n\tassert.Equal(t, \"40.40.40.40\", c.ClientIP())\n\n\t// Disabled TrustedProxies feature\n\t_ = c.engine.SetTrustedProxies(nil)\n\tassert.Equal(t, \"40.40.40.40\", c.ClientIP())\n\n\t// Last proxy is trusted, but the RemoteAddr is not\n\t_ = c.engine.SetTrustedProxies([]string{\"30.30.30.30\"})\n\tassert.Equal(t, \"40.40.40.40\", c.ClientIP())\n\n\t// Only trust RemoteAddr\n\t_ = c.engine.SetTrustedProxies([]string{\"40.40.40.40\"})\n\tassert.Equal(t, \"30.30.30.30\", c.ClientIP())\n\n\t// All steps are trusted\n\t_ = c.engine.SetTrustedProxies([]string{\"40.40.40.40\", \"30.30.30.30\", \"20.20.20.20\"})\n\tassert.Equal(t, \"20.20.20.20\", c.ClientIP())\n\n\t// Use CIDR\n\t_ = c.engine.SetTrustedProxies([]string{\"40.40.25.25/16\", \"30.30.30.30\"})\n\tassert.Equal(t, \"20.20.20.20\", c.ClientIP())\n\n\t// Use hostname that resolves to all the proxies\n\t_ = c.engine.SetTrustedProxies([]string{\"foo\"})\n\tassert.Equal(t, \"40.40.40.40\", c.ClientIP())\n\n\t// Use hostname that returns an error\n\t_ = c.engine.SetTrustedProxies([]string{\"bar\"})\n\tassert.Equal(t, \"40.40.40.40\", c.ClientIP())\n\n\t// X-Forwarded-For has a non-IP element\n\t_ = c.engine.SetTrustedProxies([]string{\"40.40.40.40\"})\n\tc.Request.Header.Set(\"X-Forwarded-For\", \" blah \")\n\tassert.Equal(t, \"40.40.40.40\", c.ClientIP())\n\n\t// Result from LookupHost has non-IP element. This should never\n\t// happen, but we should test it to make sure we handle it\n\t// gracefully.\n\t_ = c.engine.SetTrustedProxies([]string{\"baz\"})\n\tc.Request.Header.Set(\"X-Forwarded-For\", \" 30.30.30.30 \")\n\tassert.Equal(t, \"40.40.40.40\", c.ClientIP())\n\n\t_ = c.engine.SetTrustedProxies([]string{\"40.40.40.40\"})\n\tc.Request.Header.Del(\"X-Forwarded-For\")\n\tc.engine.RemoteIPHeaders = []string{\"X-Forwarded-For\", \"X-Real-IP\"}\n\tassert.Equal(t, \"10.10.10.10\", c.ClientIP())\n\n\tc.engine.RemoteIPHeaders = []string{}\n\tc.engine.TrustedPlatform = PlatformGoogleAppEngine\n\tassert.Equal(t, \"50.50.50.50\", c.ClientIP())\n\n\t// Use custom TrustedPlatform header\n\tc.engine.TrustedPlatform = \"X-CDN-IP\"\n\tc.Request.Header.Set(\"X-CDN-IP\", \"80.80.80.80\")\n\tassert.Equal(t, \"80.80.80.80\", c.ClientIP())\n\t// wrong header\n\tc.engine.TrustedPlatform = \"X-Wrong-Header\"\n\tassert.Equal(t, \"40.40.40.40\", c.ClientIP())\n\n\tc.Request.Header.Del(\"X-CDN-IP\")\n\t// TrustedPlatform is empty\n\tc.engine.TrustedPlatform = \"\"\n\tassert.Equal(t, \"40.40.40.40\", c.ClientIP())\n\n\t// Test the legacy flag\n\tc.engine.AppEngine = true\n\tassert.Equal(t, \"50.50.50.50\", c.ClientIP())\n\tc.engine.AppEngine = false\n\tc.engine.TrustedPlatform = PlatformGoogleAppEngine\n\n\tc.Request.Header.Del(\"X-Appengine-Remote-Addr\")\n\tassert.Equal(t, \"40.40.40.40\", c.ClientIP())\n\n\tc.engine.TrustedPlatform = PlatformCloudflare\n\tassert.Equal(t, \"60.60.60.60\", c.ClientIP())\n\n\tc.Request.Header.Del(\"CF-Connecting-IP\")\n\tassert.Equal(t, \"40.40.40.40\", c.ClientIP())\n\n\tc.engine.TrustedPlatform = PlatformFlyIO\n\tassert.Equal(t, \"70.70.70.70\", c.ClientIP())\n\n\tc.Request.Header.Del(\"Fly-Client-IP\")\n\tassert.Equal(t, \"40.40.40.40\", c.ClientIP())\n\n\tc.engine.TrustedPlatform = \"\"\n\n\t// no port\n\tc.Request.RemoteAddr = \"50.50.50.50\"\n\tassert.Empty(t, c.ClientIP())\n}\n\nfunc resetContextForClientIPTests(c *Context) {\n\tc.Request.Header.Set(\"X-Real-IP\", \" 10.10.10.10  \")\n\tc.Request.Header.Set(\"X-Forwarded-For\", \"  20.20.20.20, 30.30.30.30\")\n\tc.Request.Header.Set(\"X-Appengine-Remote-Addr\", \"50.50.50.50\")\n\tc.Request.Header.Set(\"CF-Connecting-IP\", \"60.60.60.60\")\n\tc.Request.Header.Set(\"Fly-Client-IP\", \"70.70.70.70\")\n\tc.Request.RemoteAddr = \"  40.40.40.40:42123 \"\n\tc.engine.TrustedPlatform = \"\"\n\tc.engine.trustedCIDRs = defaultTrustedCIDRs\n\tc.engine.AppEngine = false\n}\n\nfunc TestContextContentType(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", nil)\n\tc.Request.Header.Set(\"Content-Type\", \"application/json; charset=utf-8\")\n\n\tassert.Equal(t, \"application/json\", c.ContentType())\n}\n\nfunc TestContextAutoBindJSON(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(\"{\\\"foo\\\":\\\"bar\\\", \\\"bar\\\":\\\"foo\\\"}\"))\n\tc.Request.Header.Add(\"Content-Type\", MIMEJSON)\n\n\tvar obj struct {\n\t\tFoo string `json:\"foo\"`\n\t\tBar string `json:\"bar\"`\n\t}\n\trequire.NoError(t, c.Bind(&obj))\n\tassert.Equal(t, \"foo\", obj.Bar)\n\tassert.Equal(t, \"bar\", obj.Foo)\n\tassert.Empty(t, c.Errors)\n}\n\nfunc TestContextBindWithJSON(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(\"{\\\"foo\\\":\\\"bar\\\", \\\"bar\\\":\\\"foo\\\"}\"))\n\tc.Request.Header.Add(\"Content-Type\", MIMEXML) // set fake content-type\n\n\tvar obj struct {\n\t\tFoo string `json:\"foo\"`\n\t\tBar string `json:\"bar\"`\n\t}\n\trequire.NoError(t, c.BindJSON(&obj))\n\tassert.Equal(t, \"foo\", obj.Bar)\n\tassert.Equal(t, \"bar\", obj.Foo)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestContextBindWithXML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(`<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t\t<root>\n\t\t\t<foo>FOO</foo>\n\t\t   \t<bar>BAR</bar>\n\t\t</root>`))\n\tc.Request.Header.Add(\"Content-Type\", MIMEXML) // set fake content-type\n\n\tvar obj struct {\n\t\tFoo string `xml:\"foo\"`\n\t\tBar string `xml:\"bar\"`\n\t}\n\trequire.NoError(t, c.BindXML(&obj))\n\tassert.Equal(t, \"FOO\", obj.Foo)\n\tassert.Equal(t, \"BAR\", obj.Bar)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestContextBindPlain(t *testing.T) {\n\t// string\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(`test string`))\n\tc.Request.Header.Add(\"Content-Type\", MIMEPlain)\n\n\tvar s string\n\n\trequire.NoError(t, c.BindPlain(&s))\n\tassert.Equal(t, \"test string\", s)\n\tassert.Equal(t, 0, w.Body.Len())\n\n\t// []byte\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(`test []byte`))\n\tc.Request.Header.Add(\"Content-Type\", MIMEPlain)\n\n\tvar bs []byte\n\n\trequire.NoError(t, c.BindPlain(&bs))\n\tassert.Equal(t, []byte(\"test []byte\"), bs)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestContextBindHeader(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", nil)\n\tc.Request.Header.Add(\"rate\", \"8000\")\n\tc.Request.Header.Add(\"domain\", \"music\")\n\tc.Request.Header.Add(\"limit\", \"1000\")\n\n\tvar testHeader struct {\n\t\tRate   int    `header:\"Rate\"`\n\t\tDomain string `header:\"Domain\"`\n\t\tLimit  int    `header:\"limit\"`\n\t}\n\n\trequire.NoError(t, c.BindHeader(&testHeader))\n\tassert.Equal(t, 8000, testHeader.Rate)\n\tassert.Equal(t, \"music\", testHeader.Domain)\n\tassert.Equal(t, 1000, testHeader.Limit)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestContextBindWithQuery(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/?foo=bar&bar=foo\", bytes.NewBufferString(\"foo=unused\"))\n\n\tvar obj struct {\n\t\tFoo string `form:\"foo\"`\n\t\tBar string `form:\"bar\"`\n\t}\n\trequire.NoError(t, c.BindQuery(&obj))\n\tassert.Equal(t, \"foo\", obj.Bar)\n\tassert.Equal(t, \"bar\", obj.Foo)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestContextBindWithYAML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(\"foo: bar\\nbar: foo\"))\n\tc.Request.Header.Add(\"Content-Type\", MIMEXML) // set fake content-type\n\n\tvar obj struct {\n\t\tFoo string `yaml:\"foo\"`\n\t\tBar string `yaml:\"bar\"`\n\t}\n\trequire.NoError(t, c.BindYAML(&obj))\n\tassert.Equal(t, \"foo\", obj.Bar)\n\tassert.Equal(t, \"bar\", obj.Foo)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestContextBindWithTOML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(\"foo = 'bar'\\nbar = 'foo'\"))\n\tc.Request.Header.Add(\"Content-Type\", MIMEXML) // set fake content-type\n\n\tvar obj struct {\n\t\tFoo string `toml:\"foo\"`\n\t\tBar string `toml:\"bar\"`\n\t}\n\trequire.NoError(t, c.BindTOML(&obj))\n\tassert.Equal(t, \"foo\", obj.Bar)\n\tassert.Equal(t, \"bar\", obj.Foo)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestContextBadAutoBind(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"http://example.com\", bytes.NewBufferString(\"\\\"foo\\\":\\\"bar\\\", \\\"bar\\\":\\\"foo\\\"}\"))\n\tc.Request.Header.Add(\"Content-Type\", MIMEJSON)\n\tvar obj struct {\n\t\tFoo string `json:\"foo\"`\n\t\tBar string `json:\"bar\"`\n\t}\n\n\tassert.False(t, c.IsAborted())\n\trequire.Error(t, c.Bind(&obj))\n\tc.Writer.WriteHeaderNow()\n\n\tassert.Empty(t, obj.Bar)\n\tassert.Empty(t, obj.Foo)\n\tassert.Equal(t, http.StatusBadRequest, w.Code)\n\tassert.True(t, c.IsAborted())\n}\n\nfunc TestContextAutoShouldBindJSON(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(\"{\\\"foo\\\":\\\"bar\\\", \\\"bar\\\":\\\"foo\\\"}\"))\n\tc.Request.Header.Add(\"Content-Type\", MIMEJSON)\n\n\tvar obj struct {\n\t\tFoo string `json:\"foo\"`\n\t\tBar string `json:\"bar\"`\n\t}\n\trequire.NoError(t, c.ShouldBind(&obj))\n\tassert.Equal(t, \"foo\", obj.Bar)\n\tassert.Equal(t, \"bar\", obj.Foo)\n\tassert.Empty(t, c.Errors)\n}\n\nfunc TestContextShouldBindWithJSON(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(\"{\\\"foo\\\":\\\"bar\\\", \\\"bar\\\":\\\"foo\\\"}\"))\n\tc.Request.Header.Add(\"Content-Type\", MIMEXML) // set fake content-type\n\n\tvar obj struct {\n\t\tFoo string `json:\"foo\"`\n\t\tBar string `json:\"bar\"`\n\t}\n\trequire.NoError(t, c.ShouldBindJSON(&obj))\n\tassert.Equal(t, \"foo\", obj.Bar)\n\tassert.Equal(t, \"bar\", obj.Foo)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestContextShouldBindWithXML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(`<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t\t<root>\n\t\t\t<foo>FOO</foo>\n\t\t\t<bar>BAR</bar>\n\t\t</root>`))\n\tc.Request.Header.Add(\"Content-Type\", MIMEXML) // set fake content-type\n\n\tvar obj struct {\n\t\tFoo string `xml:\"foo\"`\n\t\tBar string `xml:\"bar\"`\n\t}\n\trequire.NoError(t, c.ShouldBindXML(&obj))\n\tassert.Equal(t, \"FOO\", obj.Foo)\n\tassert.Equal(t, \"BAR\", obj.Bar)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestContextShouldBindPlain(t *testing.T) {\n\t// string\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(`test string`))\n\tc.Request.Header.Add(\"Content-Type\", MIMEPlain)\n\n\tvar s string\n\n\trequire.NoError(t, c.ShouldBindPlain(&s))\n\tassert.Equal(t, \"test string\", s)\n\tassert.Equal(t, 0, w.Body.Len())\n\t// []byte\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(`test []byte`))\n\tc.Request.Header.Add(\"Content-Type\", MIMEPlain)\n\n\tvar bs []byte\n\n\trequire.NoError(t, c.ShouldBindPlain(&bs))\n\tassert.Equal(t, []byte(\"test []byte\"), bs)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestContextShouldBindHeader(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", nil)\n\tc.Request.Header.Add(\"rate\", \"8000\")\n\tc.Request.Header.Add(\"domain\", \"music\")\n\tc.Request.Header.Add(\"limit\", \"1000\")\n\n\tvar testHeader struct {\n\t\tRate   int    `header:\"Rate\"`\n\t\tDomain string `header:\"Domain\"`\n\t\tLimit  int    `header:\"limit\"`\n\t}\n\n\trequire.NoError(t, c.ShouldBindHeader(&testHeader))\n\tassert.Equal(t, 8000, testHeader.Rate)\n\tassert.Equal(t, \"music\", testHeader.Domain)\n\tassert.Equal(t, 1000, testHeader.Limit)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestContextShouldBindWithQuery(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/?foo=bar&bar=foo&Foo=bar1&Bar=foo1\", bytes.NewBufferString(\"foo=unused\"))\n\n\tvar obj struct {\n\t\tFoo  string `form:\"foo\"`\n\t\tBar  string `form:\"bar\"`\n\t\tFoo1 string `form:\"Foo\"`\n\t\tBar1 string `form:\"Bar\"`\n\t}\n\trequire.NoError(t, c.ShouldBindQuery(&obj))\n\tassert.Equal(t, \"foo\", obj.Bar)\n\tassert.Equal(t, \"bar\", obj.Foo)\n\tassert.Equal(t, \"foo1\", obj.Bar1)\n\tassert.Equal(t, \"bar1\", obj.Foo1)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestContextShouldBindWithYAML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(\"foo: bar\\nbar: foo\"))\n\tc.Request.Header.Add(\"Content-Type\", MIMEXML) // set fake content-type\n\n\tvar obj struct {\n\t\tFoo string `yaml:\"foo\"`\n\t\tBar string `yaml:\"bar\"`\n\t}\n\trequire.NoError(t, c.ShouldBindYAML(&obj))\n\tassert.Equal(t, \"foo\", obj.Bar)\n\tassert.Equal(t, \"bar\", obj.Foo)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestContextShouldBindWithTOML(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(\"foo='bar'\\nbar= 'foo'\"))\n\tc.Request.Header.Add(\"Content-Type\", MIMETOML) // set fake content-type\n\n\tvar obj struct {\n\t\tFoo string `toml:\"foo\"`\n\t\tBar string `toml:\"bar\"`\n\t}\n\trequire.NoError(t, c.ShouldBindTOML(&obj))\n\tassert.Equal(t, \"foo\", obj.Bar)\n\tassert.Equal(t, \"bar\", obj.Foo)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestContextBadAutoShouldBind(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"http://example.com\", bytes.NewBufferString(\"\\\"foo\\\":\\\"bar\\\", \\\"bar\\\":\\\"foo\\\"}\"))\n\tc.Request.Header.Add(\"Content-Type\", MIMEJSON)\n\tvar obj struct {\n\t\tFoo string `json:\"foo\"`\n\t\tBar string `json:\"bar\"`\n\t}\n\n\tassert.False(t, c.IsAborted())\n\trequire.Error(t, c.ShouldBind(&obj))\n\n\tassert.Empty(t, obj.Bar)\n\tassert.Empty(t, obj.Foo)\n\tassert.False(t, c.IsAborted())\n}\n\nfunc TestContextShouldBindBodyWith(t *testing.T) {\n\ttype typeA struct {\n\t\tFoo string `json:\"foo\" xml:\"foo\" binding:\"required\"`\n\t}\n\ttype typeB struct {\n\t\tBar string `json:\"bar\" xml:\"bar\" binding:\"required\"`\n\t}\n\tfor _, tt := range []struct {\n\t\tname               string\n\t\tbindingA, bindingB binding.BindingBody\n\t\tbodyA, bodyB       string\n\t}{\n\t\t{\n\t\t\tname:     \"JSON & JSON\",\n\t\t\tbindingA: binding.JSON,\n\t\t\tbindingB: binding.JSON,\n\t\t\tbodyA:    `{\"foo\":\"FOO\"}`,\n\t\t\tbodyB:    `{\"bar\":\"BAR\"}`,\n\t\t},\n\t\t{\n\t\t\tname:     \"JSON & XML\",\n\t\t\tbindingA: binding.JSON,\n\t\t\tbindingB: binding.XML,\n\t\t\tbodyA:    `{\"foo\":\"FOO\"}`,\n\t\t\tbodyB: `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>\n   <bar>BAR</bar>\n</root>`,\n\t\t},\n\t\t{\n\t\t\tname:     \"XML & XML\",\n\t\t\tbindingA: binding.XML,\n\t\t\tbindingB: binding.XML,\n\t\t\tbodyA: `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>\n   <foo>FOO</foo>\n</root>`,\n\t\t\tbodyB: `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>\n   <bar>BAR</bar>\n</root>`,\n\t\t},\n\t} {\n\t\tt.Logf(\"testing: %s\", tt.name)\n\t\t// bodyA to typeA and typeB\n\t\t{\n\t\t\tw := httptest.NewRecorder()\n\t\t\tc, _ := CreateTestContext(w)\n\t\t\tc.Request, _ = http.NewRequest(\n\t\t\t\thttp.MethodPost, \"http://example.com\", bytes.NewBufferString(tt.bodyA),\n\t\t\t)\n\t\t\t// When it binds to typeA and typeB, it finds the body is\n\t\t\t// not typeB but typeA.\n\t\t\tobjA := typeA{}\n\t\t\trequire.NoError(t, c.ShouldBindBodyWith(&objA, tt.bindingA))\n\t\t\tassert.Equal(t, typeA{\"FOO\"}, objA)\n\t\t\tobjB := typeB{}\n\t\t\trequire.Error(t, c.ShouldBindBodyWith(&objB, tt.bindingB))\n\t\t\tassert.NotEqual(t, typeB{\"BAR\"}, objB)\n\t\t}\n\t\t// bodyB to typeA and typeB\n\t\t{\n\t\t\t// When it binds to typeA and typeB, it finds the body is\n\t\t\t// not typeA but typeB.\n\t\t\tw := httptest.NewRecorder()\n\t\t\tc, _ := CreateTestContext(w)\n\t\t\tc.Request, _ = http.NewRequest(\n\t\t\t\thttp.MethodPost, \"http://example.com\", bytes.NewBufferString(tt.bodyB),\n\t\t\t)\n\t\t\tobjA := typeA{}\n\t\t\trequire.Error(t, c.ShouldBindBodyWith(&objA, tt.bindingA))\n\t\t\tassert.NotEqual(t, typeA{\"FOO\"}, objA)\n\t\t\tobjB := typeB{}\n\t\t\trequire.NoError(t, c.ShouldBindBodyWith(&objB, tt.bindingB))\n\t\t\tassert.Equal(t, typeB{\"BAR\"}, objB)\n\t\t}\n\t}\n}\n\nfunc TestContextShouldBindBodyWithJSON(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tname        string\n\t\tbindingBody binding.BindingBody\n\t\tbody        string\n\t}{\n\t\t{\n\t\t\tname:        \" JSON & JSON-BODY \",\n\t\t\tbindingBody: binding.JSON,\n\t\t\tbody:        `{\"foo\":\"FOO\"}`,\n\t\t},\n\t\t{\n\t\t\tname:        \" JSON & XML-BODY \",\n\t\t\tbindingBody: binding.XML,\n\t\t\tbody: `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>\n<foo>FOO</foo>\n</root>`,\n\t\t},\n\t\t{\n\t\t\tname:        \" JSON & YAML-BODY \",\n\t\t\tbindingBody: binding.YAML,\n\t\t\tbody:        `foo: FOO`,\n\t\t},\n\t\t{\n\t\t\tname:        \" JSON & TOM-BODY \",\n\t\t\tbindingBody: binding.TOML,\n\t\t\tbody:        `foo=FOO`,\n\t\t},\n\t} {\n\t\tt.Logf(\"testing: %s\", tt.name)\n\n\t\tw := httptest.NewRecorder()\n\t\tc, _ := CreateTestContext(w)\n\n\t\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(tt.body))\n\n\t\ttype typeJSON struct {\n\t\t\tFoo string `json:\"foo\" binding:\"required\"`\n\t\t}\n\t\tobjJSON := typeJSON{}\n\n\t\tif tt.bindingBody == binding.JSON {\n\t\t\trequire.NoError(t, c.ShouldBindBodyWithJSON(&objJSON))\n\t\t\tassert.Equal(t, typeJSON{\"FOO\"}, objJSON)\n\t\t}\n\n\t\tif tt.bindingBody == binding.XML {\n\t\t\trequire.Error(t, c.ShouldBindBodyWithJSON(&objJSON))\n\t\t\tassert.Equal(t, typeJSON{}, objJSON)\n\t\t}\n\n\t\tif tt.bindingBody == binding.YAML {\n\t\t\trequire.Error(t, c.ShouldBindBodyWithJSON(&objJSON))\n\t\t\tassert.Equal(t, typeJSON{}, objJSON)\n\t\t}\n\n\t\tif tt.bindingBody == binding.TOML {\n\t\t\trequire.Error(t, c.ShouldBindBodyWithJSON(&objJSON))\n\t\t\tassert.Equal(t, typeJSON{}, objJSON)\n\t\t}\n\t}\n}\n\nfunc TestContextShouldBindBodyWithXML(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tname        string\n\t\tbindingBody binding.BindingBody\n\t\tbody        string\n\t}{\n\t\t{\n\t\t\tname:        \" XML & JSON-BODY \",\n\t\t\tbindingBody: binding.JSON,\n\t\t\tbody:        `{\"foo\":\"FOO\"}`,\n\t\t},\n\t\t{\n\t\t\tname:        \" XML & XML-BODY \",\n\t\t\tbindingBody: binding.XML,\n\t\t\tbody: `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>\n<foo>FOO</foo>\n</root>`,\n\t\t},\n\t\t{\n\t\t\tname:        \" XML & YAML-BODY \",\n\t\t\tbindingBody: binding.YAML,\n\t\t\tbody:        `foo: FOO`,\n\t\t},\n\t\t{\n\t\t\tname:        \" XML & TOM-BODY \",\n\t\t\tbindingBody: binding.TOML,\n\t\t\tbody:        `foo=FOO`,\n\t\t},\n\t} {\n\t\tt.Logf(\"testing: %s\", tt.name)\n\n\t\tw := httptest.NewRecorder()\n\t\tc, _ := CreateTestContext(w)\n\n\t\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(tt.body))\n\n\t\ttype typeXML struct {\n\t\t\tFoo string `xml:\"foo\" binding:\"required\"`\n\t\t}\n\t\tobjXML := typeXML{}\n\n\t\tif tt.bindingBody == binding.JSON {\n\t\t\trequire.Error(t, c.ShouldBindBodyWithXML(&objXML))\n\t\t\tassert.Equal(t, typeXML{}, objXML)\n\t\t}\n\n\t\tif tt.bindingBody == binding.XML {\n\t\t\trequire.NoError(t, c.ShouldBindBodyWithXML(&objXML))\n\t\t\tassert.Equal(t, typeXML{\"FOO\"}, objXML)\n\t\t}\n\n\t\tif tt.bindingBody == binding.YAML {\n\t\t\trequire.Error(t, c.ShouldBindBodyWithXML(&objXML))\n\t\t\tassert.Equal(t, typeXML{}, objXML)\n\t\t}\n\n\t\tif tt.bindingBody == binding.TOML {\n\t\t\trequire.Error(t, c.ShouldBindBodyWithXML(&objXML))\n\t\t\tassert.Equal(t, typeXML{}, objXML)\n\t\t}\n\t}\n}\n\nfunc TestContextShouldBindBodyWithYAML(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tname        string\n\t\tbindingBody binding.BindingBody\n\t\tbody        string\n\t}{\n\t\t{\n\t\t\tname:        \" YAML & JSON-BODY \",\n\t\t\tbindingBody: binding.JSON,\n\t\t\tbody:        `{\"foo\":\"FOO\"}`,\n\t\t},\n\t\t{\n\t\t\tname:        \" YAML & XML-BODY \",\n\t\t\tbindingBody: binding.XML,\n\t\t\tbody: `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>\n<foo>FOO</foo>\n</root>`,\n\t\t},\n\t\t{\n\t\t\tname:        \" YAML & YAML-BODY \",\n\t\t\tbindingBody: binding.YAML,\n\t\t\tbody:        `foo: FOO`,\n\t\t},\n\t\t{\n\t\t\tname:        \" YAML & TOM-BODY \",\n\t\t\tbindingBody: binding.TOML,\n\t\t\tbody:        `foo=FOO`,\n\t\t},\n\t} {\n\t\tt.Logf(\"testing: %s\", tt.name)\n\n\t\tw := httptest.NewRecorder()\n\t\tc, _ := CreateTestContext(w)\n\n\t\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(tt.body))\n\n\t\ttype typeYAML struct {\n\t\t\tFoo string `yaml:\"foo\" binding:\"required\"`\n\t\t}\n\t\tobjYAML := typeYAML{}\n\n\t\t// YAML belongs to a super collection of JSON, so JSON can be parsed by YAML\n\t\tif tt.bindingBody == binding.JSON {\n\t\t\trequire.NoError(t, c.ShouldBindBodyWithYAML(&objYAML))\n\t\t\tassert.Equal(t, typeYAML{\"FOO\"}, objYAML)\n\t\t}\n\n\t\tif tt.bindingBody == binding.XML {\n\t\t\trequire.Error(t, c.ShouldBindBodyWithYAML(&objYAML))\n\t\t\tassert.Equal(t, typeYAML{}, objYAML)\n\t\t}\n\n\t\tif tt.bindingBody == binding.YAML {\n\t\t\trequire.NoError(t, c.ShouldBindBodyWithYAML(&objYAML))\n\t\t\tassert.Equal(t, typeYAML{\"FOO\"}, objYAML)\n\t\t}\n\n\t\tif tt.bindingBody == binding.TOML {\n\t\t\trequire.Error(t, c.ShouldBindBodyWithYAML(&objYAML))\n\t\t\tassert.Equal(t, typeYAML{}, objYAML)\n\t\t}\n\t}\n}\n\nfunc TestContextShouldBindBodyWithTOML(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tname        string\n\t\tbindingBody binding.BindingBody\n\t\tbody        string\n\t}{\n\t\t{\n\t\t\tname:        \" TOML & JSON-BODY \",\n\t\t\tbindingBody: binding.JSON,\n\t\t\tbody:        `{\"foo\":\"FOO\"}`,\n\t\t},\n\t\t{\n\t\t\tname:        \" TOML & XML-BODY \",\n\t\t\tbindingBody: binding.XML,\n\t\t\tbody: `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>\n<foo>FOO</foo>\n</root>`,\n\t\t},\n\t\t{\n\t\t\tname:        \" TOML & YAML-BODY \",\n\t\t\tbindingBody: binding.YAML,\n\t\t\tbody:        `foo: FOO`,\n\t\t},\n\t\t{\n\t\t\tname:        \" TOML & TOM-BODY \",\n\t\t\tbindingBody: binding.TOML,\n\t\t\tbody:        `foo = 'FOO'`,\n\t\t},\n\t} {\n\t\tt.Logf(\"testing: %s\", tt.name)\n\n\t\tw := httptest.NewRecorder()\n\t\tc, _ := CreateTestContext(w)\n\n\t\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(tt.body))\n\n\t\ttype typeTOML struct {\n\t\t\tFoo string `toml:\"foo\" binding:\"required\"`\n\t\t}\n\t\tobjTOML := typeTOML{}\n\n\t\tif tt.bindingBody == binding.JSON {\n\t\t\trequire.Error(t, c.ShouldBindBodyWithTOML(&objTOML))\n\t\t\tassert.Equal(t, typeTOML{}, objTOML)\n\t\t}\n\n\t\tif tt.bindingBody == binding.XML {\n\t\t\trequire.Error(t, c.ShouldBindBodyWithTOML(&objTOML))\n\t\t\tassert.Equal(t, typeTOML{}, objTOML)\n\t\t}\n\n\t\tif tt.bindingBody == binding.YAML {\n\t\t\trequire.Error(t, c.ShouldBindBodyWithTOML(&objTOML))\n\t\t\tassert.Equal(t, typeTOML{}, objTOML)\n\t\t}\n\n\t\tif tt.bindingBody == binding.TOML {\n\t\t\trequire.NoError(t, c.ShouldBindBodyWithTOML(&objTOML))\n\t\t\tassert.Equal(t, typeTOML{\"FOO\"}, objTOML)\n\t\t}\n\t}\n}\n\nfunc TestContextShouldBindBodyWithPlain(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tname        string\n\t\tbindingBody binding.BindingBody\n\t\tbody        string\n\t}{\n\t\t{\n\t\t\tname:        \" JSON & JSON-BODY \",\n\t\t\tbindingBody: binding.JSON,\n\t\t\tbody:        `{\"foo\":\"FOO\"}`,\n\t\t},\n\t\t{\n\t\t\tname:        \" JSON & XML-BODY \",\n\t\t\tbindingBody: binding.XML,\n\t\t\tbody: `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<root>\n<foo>FOO</foo>\n</root>`,\n\t\t},\n\t\t{\n\t\t\tname:        \" JSON & YAML-BODY \",\n\t\t\tbindingBody: binding.YAML,\n\t\t\tbody:        `foo: FOO`,\n\t\t},\n\t\t{\n\t\t\tname:        \" JSON & TOM-BODY \",\n\t\t\tbindingBody: binding.TOML,\n\t\t\tbody:        `foo=FOO`,\n\t\t},\n\t\t{\n\t\t\tname:        \" JSON & Plain-BODY \",\n\t\t\tbindingBody: binding.Plain,\n\t\t\tbody:        `foo=FOO`,\n\t\t},\n\t} {\n\t\tt.Logf(\"testing: %s\", tt.name)\n\n\t\tw := httptest.NewRecorder()\n\t\tc, _ := CreateTestContext(w)\n\n\t\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(tt.body))\n\n\t\ttype typeJSON struct {\n\t\t\tFoo string `json:\"foo\" binding:\"required\"`\n\t\t}\n\t\tobjJSON := typeJSON{}\n\n\t\tif tt.bindingBody == binding.Plain {\n\t\t\tbody := \"\"\n\t\t\trequire.NoError(t, c.ShouldBindBodyWithPlain(&body))\n\t\t\tassert.Equal(t, \"foo=FOO\", body)\n\t\t}\n\n\t\tif tt.bindingBody == binding.JSON {\n\t\t\trequire.NoError(t, c.ShouldBindBodyWithJSON(&objJSON))\n\t\t\tassert.Equal(t, typeJSON{\"FOO\"}, objJSON)\n\t\t}\n\n\t\tif tt.bindingBody == binding.XML {\n\t\t\trequire.Error(t, c.ShouldBindBodyWithJSON(&objJSON))\n\t\t\tassert.Equal(t, typeJSON{}, objJSON)\n\t\t}\n\n\t\tif tt.bindingBody == binding.YAML {\n\t\t\trequire.Error(t, c.ShouldBindBodyWithJSON(&objJSON))\n\t\t\tassert.Equal(t, typeJSON{}, objJSON)\n\t\t}\n\n\t\tif tt.bindingBody == binding.TOML {\n\t\t\trequire.Error(t, c.ShouldBindBodyWithJSON(&objJSON))\n\t\t\tassert.Equal(t, typeJSON{}, objJSON)\n\t\t}\n\t}\n}\n\nfunc TestContextGolangContext(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", bytes.NewBufferString(\"{\\\"foo\\\":\\\"bar\\\", \\\"bar\\\":\\\"foo\\\"}\"))\n\trequire.NoError(t, c.Err())\n\tassert.Nil(t, c.Done())\n\tti, ok := c.Deadline()\n\tassert.Equal(t, time.Time{}, ti)\n\tassert.False(t, ok)\n\tassert.Equal(t, c.Value(ContextRequestKey), c.Request)\n\tassert.Equal(t, c.Value(ContextKey), c)\n\tassert.Nil(t, c.Value(\"foo\"))\n\n\tc.Set(\"foo\", \"bar\")\n\tassert.Equal(t, \"bar\", c.Value(\"foo\"))\n\tassert.Nil(t, c.Value(1))\n}\n\nfunc TestWebsocketsRequired(t *testing.T) {\n\t// Example request from spec: https://tools.ietf.org/html/rfc6455#section-1.2\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodGet, \"/chat\", nil)\n\tc.Request.Header.Set(\"Host\", \"server.example.com\")\n\tc.Request.Header.Set(\"Upgrade\", \"websocket\")\n\tc.Request.Header.Set(\"Connection\", \"Upgrade\")\n\tc.Request.Header.Set(\"Sec-WebSocket-Key\", \"dGhlIHNhbXBsZSBub25jZQ==\")\n\tc.Request.Header.Set(\"Origin\", \"http://example.com\")\n\tc.Request.Header.Set(\"Sec-WebSocket-Protocol\", \"chat, superchat\")\n\tc.Request.Header.Set(\"Sec-WebSocket-Version\", \"13\")\n\n\tassert.True(t, c.IsWebsocket())\n\n\t// Normal request, no websocket required.\n\tc, _ = CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodGet, \"/chat\", nil)\n\tc.Request.Header.Set(\"Host\", \"server.example.com\")\n\n\tassert.False(t, c.IsWebsocket())\n}\n\nfunc TestGetRequestHeaderValue(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodGet, \"/chat\", nil)\n\tc.Request.Header.Set(\"Gin-Version\", \"1.0.0\")\n\n\tassert.Equal(t, \"1.0.0\", c.GetHeader(\"Gin-Version\"))\n\tassert.Empty(t, c.GetHeader(\"Connection\"))\n}\n\nfunc TestContextGetRawData(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tbody := bytes.NewBufferString(\"Fetch binary post data\")\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", body)\n\tc.Request.Header.Add(\"Content-Type\", MIMEPOSTForm)\n\n\tdata, err := c.GetRawData()\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"Fetch binary post data\", string(data))\n}\n\nfunc TestContextRenderDataFromReader(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tbody := \"#!PNG some raw data\"\n\treader := strings.NewReader(body)\n\tcontentLength := int64(len(body))\n\tcontentType := \"image/png\"\n\textraHeaders := map[string]string{\"Content-Disposition\": `attachment; filename=\"gopher.png\"`}\n\n\tc.DataFromReader(http.StatusOK, contentLength, contentType, reader, extraHeaders)\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, body, w.Body.String())\n\tassert.Equal(t, contentType, w.Header().Get(\"Content-Type\"))\n\tassert.Equal(t, strconv.FormatInt(contentLength, 10), w.Header().Get(\"Content-Length\"))\n\tassert.Equal(t, extraHeaders[\"Content-Disposition\"], w.Header().Get(\"Content-Disposition\"))\n}\n\nfunc TestContextRenderDataFromReaderNoHeaders(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tbody := \"#!PNG some raw data\"\n\treader := strings.NewReader(body)\n\tcontentLength := int64(len(body))\n\tcontentType := \"image/png\"\n\n\tc.DataFromReader(http.StatusOK, contentLength, contentType, reader, nil)\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, body, w.Body.String())\n\tassert.Equal(t, contentType, w.Header().Get(\"Content-Type\"))\n\tassert.Equal(t, strconv.FormatInt(contentLength, 10), w.Header().Get(\"Content-Length\"))\n}\n\ntype TestResponseRecorder struct {\n\t*httptest.ResponseRecorder\n\tcloseChannel chan bool\n}\n\nfunc (r *TestResponseRecorder) CloseNotify() <-chan bool {\n\treturn r.closeChannel\n}\n\nfunc (r *TestResponseRecorder) closeClient() {\n\tr.closeChannel <- true\n}\n\nfunc CreateTestResponseRecorder() *TestResponseRecorder {\n\treturn &TestResponseRecorder{\n\t\thttptest.NewRecorder(),\n\t\tmake(chan bool, 1),\n\t}\n}\n\nfunc TestContextStream(t *testing.T) {\n\tw := CreateTestResponseRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tstopStream := true\n\tc.Stream(func(w io.Writer) bool {\n\t\tdefer func() {\n\t\t\tstopStream = false\n\t\t}()\n\n\t\t_, err := w.Write([]byte(\"test\"))\n\t\trequire.NoError(t, err)\n\n\t\treturn stopStream\n\t})\n\n\tassert.Equal(t, \"testtest\", w.Body.String())\n}\n\nfunc TestContextStreamWithClientGone(t *testing.T) {\n\tw := CreateTestResponseRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Stream(func(writer io.Writer) bool {\n\t\tdefer func() {\n\t\t\tw.closeClient()\n\t\t}()\n\n\t\t_, err := writer.Write([]byte(\"test\"))\n\t\trequire.NoError(t, err)\n\n\t\treturn true\n\t})\n\n\tassert.Equal(t, \"test\", w.Body.String())\n}\n\nfunc TestContextResetInHandler(t *testing.T) {\n\tw := CreateTestResponseRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.handlers = []HandlerFunc{\n\t\tfunc(c *Context) { c.reset() },\n\t}\n\tassert.NotPanics(t, func() {\n\t\tc.Next()\n\t})\n}\n\nfunc TestRaceParamsContextCopy(t *testing.T) {\n\tDefaultWriter = os.Stdout\n\trouter := Default()\n\tnameGroup := router.Group(\"/:name\")\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\t{\n\t\tnameGroup.GET(\"/api\", func(c *Context) {\n\t\t\tgo func(c *Context, param string) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\t// First assert must be executed after the second request\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t\tassert.Equal(t, c.Param(\"name\"), param)\n\t\t\t}(c.Copy(), c.Param(\"name\"))\n\t\t})\n\t}\n\tPerformRequest(router, http.MethodGet, \"/name1/api\")\n\tPerformRequest(router, http.MethodGet, \"/name2/api\")\n\twg.Wait()\n}\n\nfunc TestContextWithKeysMutex(t *testing.T) {\n\tc := &Context{}\n\tc.Set(\"foo\", \"bar\")\n\n\tvalue, err := c.Get(\"foo\")\n\tassert.Equal(t, \"bar\", value)\n\tassert.True(t, err)\n\n\tvalue, err = c.Get(\"foo2\")\n\tassert.Nil(t, value)\n\tassert.False(t, err)\n}\n\nfunc TestRemoteIPFail(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", nil)\n\tc.Request.RemoteAddr = \"[:::]:80\"\n\tip := net.ParseIP(c.RemoteIP())\n\ttrust := c.engine.isTrustedProxy(ip)\n\tassert.Nil(t, ip)\n\tassert.False(t, trust)\n}\n\nfunc TestHasRequestContext(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\tassert.False(t, c.hasRequestContext(), \"no request, no fallback\")\n\tc.engine.ContextWithFallback = true\n\tassert.False(t, c.hasRequestContext(), \"no request, has fallback\")\n\tc.Request, _ = http.NewRequest(http.MethodGet, \"/\", nil)\n\tassert.True(t, c.hasRequestContext(), \"has request, has fallback\")\n\tc.Request, _ = http.NewRequestWithContext(nil, \"\", \"\", nil) //nolint:staticcheck\n\tassert.False(t, c.hasRequestContext(), \"has request with nil ctx, has fallback\")\n\tc.engine.ContextWithFallback = false\n\tassert.False(t, c.hasRequestContext(), \"has request, no fallback\")\n\n\tc = &Context{}\n\tassert.False(t, c.hasRequestContext(), \"no request, no engine\")\n\tc.Request, _ = http.NewRequest(http.MethodGet, \"/\", nil)\n\tassert.False(t, c.hasRequestContext(), \"has request, no engine\")\n}\n\nfunc TestContextWithFallbackDeadlineFromRequestContext(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\t// enable ContextWithFallback feature flag\n\tc.engine.ContextWithFallback = true\n\n\tdeadline, ok := c.Deadline()\n\tassert.Zero(t, deadline)\n\tassert.False(t, ok)\n\n\tc2, _ := CreateTestContext(httptest.NewRecorder())\n\t// enable ContextWithFallback feature flag\n\tc2.engine.ContextWithFallback = true\n\n\tc2.Request, _ = http.NewRequest(http.MethodGet, \"/\", nil)\n\td := time.Now().Add(time.Second)\n\tctx, cancel := context.WithDeadline(context.Background(), d)\n\tdefer cancel()\n\tc2.Request = c2.Request.WithContext(ctx)\n\tdeadline, ok = c2.Deadline()\n\tassert.Equal(t, d, deadline)\n\tassert.True(t, ok)\n}\n\nfunc TestContextWithFallbackDoneFromRequestContext(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\t// enable ContextWithFallback feature flag\n\tc.engine.ContextWithFallback = true\n\n\tassert.Nil(t, c.Done())\n\n\tc2, _ := CreateTestContext(httptest.NewRecorder())\n\t// enable ContextWithFallback feature flag\n\tc2.engine.ContextWithFallback = true\n\n\tc2.Request, _ = http.NewRequest(http.MethodGet, \"/\", nil)\n\tctx, cancel := context.WithCancel(context.Background())\n\tc2.Request = c2.Request.WithContext(ctx)\n\tcancel()\n\tassert.NotNil(t, <-c2.Done())\n}\n\nfunc TestContextWithFallbackErrFromRequestContext(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\t// enable ContextWithFallback feature flag\n\tc.engine.ContextWithFallback = true\n\n\trequire.NoError(t, c.Err())\n\n\tc2, _ := CreateTestContext(httptest.NewRecorder())\n\t// enable ContextWithFallback feature flag\n\tc2.engine.ContextWithFallback = true\n\n\tc2.Request, _ = http.NewRequest(http.MethodGet, \"/\", nil)\n\tctx, cancel := context.WithCancel(context.Background())\n\tc2.Request = c2.Request.WithContext(ctx)\n\tcancel()\n\n\tassert.EqualError(t, c2.Err(), context.Canceled.Error())\n}\n\nfunc TestContextWithFallbackValueFromRequestContext(t *testing.T) {\n\ttype contextKey string\n\n\ttests := []struct {\n\t\tname             string\n\t\tgetContextAndKey func() (*Context, any)\n\t\tvalue            any\n\t}{\n\t\t{\n\t\t\tname: \"c with struct context key\",\n\t\t\tgetContextAndKey: func() (*Context, any) {\n\t\t\t\ttype KeyStruct struct{} // https://staticcheck.dev/docs/checks/#SA1029\n\t\t\t\tvar key KeyStruct\n\t\t\t\tc, _ := CreateTestContext(httptest.NewRecorder())\n\t\t\t\t// enable ContextWithFallback feature flag\n\t\t\t\tc.engine.ContextWithFallback = true\n\t\t\t\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", nil)\n\t\t\t\tc.Request = c.Request.WithContext(context.WithValue(context.TODO(), key, \"value\"))\n\t\t\t\treturn c, key\n\t\t\t},\n\t\t\tvalue: \"value\",\n\t\t},\n\t\t{\n\t\t\tname: \"c with string context key\",\n\t\t\tgetContextAndKey: func() (*Context, any) {\n\t\t\t\tc, _ := CreateTestContext(httptest.NewRecorder())\n\t\t\t\t// enable ContextWithFallback feature flag\n\t\t\t\tc.engine.ContextWithFallback = true\n\t\t\t\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", nil)\n\t\t\t\tc.Request = c.Request.WithContext(context.WithValue(context.TODO(), contextKey(\"key\"), \"value\"))\n\t\t\t\treturn c, contextKey(\"key\")\n\t\t\t},\n\t\t\tvalue: \"value\",\n\t\t},\n\t\t{\n\t\t\tname: \"c with nil http.Request\",\n\t\t\tgetContextAndKey: func() (*Context, any) {\n\t\t\t\tc, _ := CreateTestContext(httptest.NewRecorder())\n\t\t\t\t// enable ContextWithFallback feature flag\n\t\t\t\tc.engine.ContextWithFallback = true\n\t\t\t\tc.Request = nil\n\t\t\t\treturn c, \"key\"\n\t\t\t},\n\t\t\tvalue: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"c with nil http.Request.Context()\",\n\t\t\tgetContextAndKey: func() (*Context, any) {\n\t\t\t\tc, _ := CreateTestContext(httptest.NewRecorder())\n\t\t\t\t// enable ContextWithFallback feature flag\n\t\t\t\tc.engine.ContextWithFallback = true\n\t\t\t\tc.Request, _ = http.NewRequest(http.MethodPost, \"/\", nil)\n\t\t\t\treturn c, \"key\"\n\t\t\t},\n\t\t\tvalue: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc, key := tt.getContextAndKey()\n\t\t\tassert.Equal(t, tt.value, c.Value(key))\n\t\t})\n\t}\n}\n\nfunc TestContextCopyShouldNotCancel(t *testing.T) {\n\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t}))\n\tdefer srv.Close()\n\n\tensureRequestIsOver := make(chan struct{})\n\n\twg := &sync.WaitGroup{}\n\n\tr := New()\n\tr.GET(\"/\", func(ginctx *Context) {\n\t\twg.Add(1)\n\n\t\tginctx = ginctx.Copy()\n\n\t\t// start async goroutine for calling srv\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\n\t\t\t<-ensureRequestIsOver // ensure request is done\n\n\t\t\treq, err := http.NewRequestWithContext(ginctx, http.MethodGet, srv.URL, nil)\n\t\t\tmust(err)\n\n\t\t\tres, err := http.DefaultClient.Do(req)\n\t\t\tif err != nil {\n\t\t\t\tt.Error(fmt.Errorf(\"request error: %w\", err))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif res.StatusCode != http.StatusOK {\n\t\t\t\tt.Error(fmt.Errorf(\"unexpected status code: %s\", res.Status))\n\t\t\t}\n\t\t}()\n\t})\n\n\tl, err := net.Listen(\"tcp\", \":0\")\n\tmust(err)\n\tgo func() {\n\t\ts := &http.Server{\n\t\t\tHandler: r,\n\t\t}\n\n\t\tmust(s.Serve(l))\n\t}()\n\n\taddr := strings.Split(l.Addr().String(), \":\")\n\tres, err := http.Get(fmt.Sprintf(\"http://127.0.0.1:%s/\", addr[len(addr)-1]))\n\tif err != nil {\n\t\tt.Error(fmt.Errorf(\"request error: %w\", err))\n\t\treturn\n\t}\n\n\tclose(ensureRequestIsOver)\n\n\tif res.StatusCode != http.StatusOK {\n\t\tt.Error(fmt.Errorf(\"unexpected status code: %s\", res.Status))\n\t\treturn\n\t}\n\n\twg.Wait()\n}\n\nfunc TestContextAddParam(t *testing.T) {\n\tc := &Context{}\n\tid := \"id\"\n\tvalue := \"1\"\n\tc.AddParam(id, value)\n\n\tv, ok := c.Params.Get(id)\n\tassert.True(t, ok)\n\tassert.Equal(t, value, v)\n}\n\nfunc TestCreateTestContextWithRouteParams(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tengine := New()\n\tengine.GET(\"/:action/:name\", func(ctx *Context) {\n\t\tctx.String(http.StatusOK, \"%s %s\", ctx.Param(\"action\"), ctx.Param(\"name\"))\n\t})\n\tc := CreateTestContextOnly(w, engine)\n\tc.Request, _ = http.NewRequest(http.MethodGet, \"/hello/gin\", nil)\n\tengine.HandleContext(c)\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"hello gin\", w.Body.String())\n}\n\ntype interceptedWriter struct {\n\tResponseWriter\n\tb *bytes.Buffer\n}\n\nfunc (i interceptedWriter) WriteHeader(code int) {\n\ti.Header().Del(\"X-Test\")\n\ti.ResponseWriter.WriteHeader(code)\n}\n\nfunc TestInterceptedHeader(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, r := CreateTestContext(w)\n\n\tr.Use(func(c *Context) {\n\t\ti := interceptedWriter{\n\t\t\tResponseWriter: c.Writer,\n\t\t\tb:              bytes.NewBuffer(nil),\n\t\t}\n\t\tc.Writer = i\n\t\tc.Next()\n\t\tc.Header(\"X-Test\", \"overridden\")\n\t\tc.Writer = i.ResponseWriter\n\t})\n\tr.GET(\"/\", func(c *Context) {\n\t\tc.Header(\"X-Test\", \"original\")\n\t\tc.Header(\"X-Test-2\", \"present\")\n\t\tc.String(http.StatusOK, \"hello world\")\n\t})\n\tc.Request = httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tr.HandleContext(c)\n\t// Result() has headers frozen when WriteHeaderNow() has been called\n\t// Compared to this time, this is when the response headers will be flushed\n\t// As response is flushed on c.String, the Header cannot be set by the first\n\t// middleware. Assert this\n\tassert.Equal(t, \"\", w.Result().Header.Get(\"X-Test\"))\n\tassert.Equal(t, \"present\", w.Result().Header.Get(\"X-Test-2\"))\n}\n\nfunc TestContextNext(t *testing.T) {\n\tc, _ := CreateTestContext(httptest.NewRecorder())\n\n\t// Test with no handlers\n\tc.Next()\n\tassert.Equal(t, int8(0), c.index)\n\n\t// Test with one handler\n\tc.index = -1\n\tc.handlers = HandlersChain{func(c *Context) {\n\t\tc.Set(\"key\", \"value\")\n\t}}\n\tc.Next()\n\tassert.Equal(t, int8(1), c.index)\n\tvalue, exists := c.Get(\"key\")\n\tassert.True(t, exists)\n\tassert.Equal(t, \"value\", value)\n\n\t// Test with multiple handlers\n\tc.handlers = HandlersChain{\n\t\tfunc(c *Context) {\n\t\t\tc.Set(\"key1\", \"value1\")\n\t\t\tc.Next()\n\t\t\tc.Set(\"key2\", \"value2\")\n\t\t},\n\t\tnil,\n\t\tfunc(c *Context) {\n\t\t\tc.Set(\"key3\", \"value3\")\n\t\t},\n\t}\n\tc.index = -1\n\tc.Next()\n\tassert.Equal(t, int8(4), c.index)\n\tvalue, exists = c.Get(\"key1\")\n\tassert.True(t, exists)\n\tassert.Equal(t, \"value1\", value)\n\tvalue, exists = c.Get(\"key2\")\n\tassert.True(t, exists)\n\tassert.Equal(t, \"value2\", value)\n\tvalue, exists = c.Get(\"key3\")\n\tassert.True(t, exists)\n\tassert.Equal(t, \"value3\", value)\n}\n"
        },
        {
          "name": "debug.go",
          "type": "blob",
          "size": 2.9013671875,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n)\n\nconst ginSupportMinGoVer = 21\n\n// IsDebugging returns true if the framework is running in debug mode.\n// Use SetMode(gin.ReleaseMode) to disable debug mode.\nfunc IsDebugging() bool {\n\treturn atomic.LoadInt32(&ginMode) == debugCode\n}\n\n// DebugPrintRouteFunc indicates debug log output format.\nvar DebugPrintRouteFunc func(httpMethod, absolutePath, handlerName string, nuHandlers int)\n\n// DebugPrintFunc indicates debug log output format.\nvar DebugPrintFunc func(format string, values ...interface{})\n\nfunc debugPrintRoute(httpMethod, absolutePath string, handlers HandlersChain) {\n\tif IsDebugging() {\n\t\tnuHandlers := len(handlers)\n\t\thandlerName := nameOfFunction(handlers.Last())\n\t\tif DebugPrintRouteFunc == nil {\n\t\t\tdebugPrint(\"%-6s %-25s --> %s (%d handlers)\\n\", httpMethod, absolutePath, handlerName, nuHandlers)\n\t\t} else {\n\t\t\tDebugPrintRouteFunc(httpMethod, absolutePath, handlerName, nuHandlers)\n\t\t}\n\t}\n}\n\nfunc debugPrintLoadTemplate(tmpl *template.Template) {\n\tif IsDebugging() {\n\t\tvar buf strings.Builder\n\t\tfor _, tmpl := range tmpl.Templates() {\n\t\t\tbuf.WriteString(\"\\t- \")\n\t\t\tbuf.WriteString(tmpl.Name())\n\t\t\tbuf.WriteString(\"\\n\")\n\t\t}\n\t\tdebugPrint(\"Loaded HTML Templates (%d): \\n%s\\n\", len(tmpl.Templates()), buf.String())\n\t}\n}\n\nfunc debugPrint(format string, values ...any) {\n\tif !IsDebugging() {\n\t\treturn\n\t}\n\n\tif DebugPrintFunc != nil {\n\t\tDebugPrintFunc(format, values...)\n\t\treturn\n\t}\n\n\tif !strings.HasSuffix(format, \"\\n\") {\n\t\tformat += \"\\n\"\n\t}\n\tfmt.Fprintf(DefaultWriter, \"[GIN-debug] \"+format, values...)\n}\n\nfunc getMinVer(v string) (uint64, error) {\n\tfirst := strings.IndexByte(v, '.')\n\tlast := strings.LastIndexByte(v, '.')\n\tif first == last {\n\t\treturn strconv.ParseUint(v[first+1:], 10, 64)\n\t}\n\treturn strconv.ParseUint(v[first+1:last], 10, 64)\n}\n\nfunc debugPrintWARNINGDefault() {\n\tif v, e := getMinVer(runtime.Version()); e == nil && v < ginSupportMinGoVer {\n\t\tdebugPrint(`[WARNING] Now Gin requires Go 1.22+.\n\n`)\n\t}\n\tdebugPrint(`[WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.\n\n`)\n}\n\nfunc debugPrintWARNINGNew() {\n\tdebugPrint(`[WARNING] Running in \"debug\" mode. Switch to \"release\" mode in production.\n - using env:\texport GIN_MODE=release\n - using code:\tgin.SetMode(gin.ReleaseMode)\n\n`)\n}\n\nfunc debugPrintWARNINGSetHTMLTemplate() {\n\tdebugPrint(`[WARNING] Since SetHTMLTemplate() is NOT thread-safe. It should only be called\nat initialization. ie. before any route is registered or the router is listening in a socket:\n\n\trouter := gin.Default()\n\trouter.SetHTMLTemplate(template) // << good place\n\n`)\n}\n\nfunc debugPrintError(err error) {\n\tif err != nil && IsDebugging() {\n\t\tfmt.Fprintf(DefaultErrorWriter, \"[GIN-debug] [ERROR] %v\\n\", err)\n\t}\n}\n"
        },
        {
          "name": "debug_test.go",
          "type": "blob",
          "size": 4.96875,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n// TODO\n// func debugRoute(httpMethod, absolutePath string, handlers HandlersChain) {\n// func debugPrint(format string, values ...any) {\n\nfunc TestIsDebugging(t *testing.T) {\n\tSetMode(DebugMode)\n\tassert.True(t, IsDebugging())\n\tSetMode(ReleaseMode)\n\tassert.False(t, IsDebugging())\n\tSetMode(TestMode)\n\tassert.False(t, IsDebugging())\n}\n\nfunc TestDebugPrint(t *testing.T) {\n\tre := captureOutput(t, func() {\n\t\tSetMode(DebugMode)\n\t\tSetMode(ReleaseMode)\n\t\tdebugPrint(\"DEBUG this!\")\n\t\tSetMode(TestMode)\n\t\tdebugPrint(\"DEBUG this!\")\n\t\tSetMode(DebugMode)\n\t\tdebugPrint(\"these are %d %s\", 2, \"error messages\")\n\t\tSetMode(TestMode)\n\t})\n\tassert.Equal(t, \"[GIN-debug] these are 2 error messages\\n\", re)\n}\n\nfunc TestDebugPrintError(t *testing.T) {\n\tre := captureOutput(t, func() {\n\t\tSetMode(DebugMode)\n\t\tdebugPrintError(nil)\n\t\tdebugPrintError(errors.New(\"this is an error\"))\n\t\tSetMode(TestMode)\n\t})\n\tassert.Equal(t, \"[GIN-debug] [ERROR] this is an error\\n\", re)\n}\n\nfunc TestDebugPrintRoutes(t *testing.T) {\n\tre := captureOutput(t, func() {\n\t\tSetMode(DebugMode)\n\t\tdebugPrintRoute(http.MethodGet, \"/path/to/route/:param\", HandlersChain{func(c *Context) {}, handlerNameTest})\n\t\tSetMode(TestMode)\n\t})\n\tassert.Regexp(t, `^\\[GIN-debug\\] GET    /path/to/route/:param     --> (.*/vendor/)?github.com/gin-gonic/gin.handlerNameTest \\(2 handlers\\)\\n$`, re)\n}\n\nfunc TestDebugPrintRouteFunc(t *testing.T) {\n\tDebugPrintRouteFunc = func(httpMethod, absolutePath, handlerName string, nuHandlers int) {\n\t\tfmt.Fprintf(DefaultWriter, \"[GIN-debug] %-6s %-40s --> %s (%d handlers)\\n\", httpMethod, absolutePath, handlerName, nuHandlers)\n\t}\n\tre := captureOutput(t, func() {\n\t\tSetMode(DebugMode)\n\t\tdebugPrintRoute(http.MethodGet, \"/path/to/route/:param1/:param2\", HandlersChain{func(c *Context) {}, handlerNameTest})\n\t\tSetMode(TestMode)\n\t})\n\tassert.Regexp(t, `^\\[GIN-debug\\] GET    /path/to/route/:param1/:param2           --> (.*/vendor/)?github.com/gin-gonic/gin.handlerNameTest \\(2 handlers\\)\\n$`, re)\n}\n\nfunc TestDebugPrintLoadTemplate(t *testing.T) {\n\tre := captureOutput(t, func() {\n\t\tSetMode(DebugMode)\n\t\ttempl := template.Must(template.New(\"\").Delims(\"{[{\", \"}]}\").ParseGlob(\"./testdata/template/hello.tmpl\"))\n\t\tdebugPrintLoadTemplate(templ)\n\t\tSetMode(TestMode)\n\t})\n\tassert.Regexp(t, `^\\[GIN-debug\\] Loaded HTML Templates \\(2\\): \\n(\\t- \\n|\\t- hello\\.tmpl\\n){2}\\n`, re)\n}\n\nfunc TestDebugPrintWARNINGSetHTMLTemplate(t *testing.T) {\n\tre := captureOutput(t, func() {\n\t\tSetMode(DebugMode)\n\t\tdebugPrintWARNINGSetHTMLTemplate()\n\t\tSetMode(TestMode)\n\t})\n\tassert.Equal(t, \"[GIN-debug] [WARNING] Since SetHTMLTemplate() is NOT thread-safe. It should only be called\\nat initialization. ie. before any route is registered or the router is listening in a socket:\\n\\n\\trouter := gin.Default()\\n\\trouter.SetHTMLTemplate(template) // << good place\\n\\n\", re)\n}\n\nfunc TestDebugPrintWARNINGDefault(t *testing.T) {\n\tre := captureOutput(t, func() {\n\t\tSetMode(DebugMode)\n\t\tdebugPrintWARNINGDefault()\n\t\tSetMode(TestMode)\n\t})\n\tm, e := getMinVer(runtime.Version())\n\tif e == nil && m < ginSupportMinGoVer {\n\t\tassert.Equal(t, \"[GIN-debug] [WARNING] Now Gin requires Go 1.22+.\\n\\n[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.\\n\\n\", re)\n\t} else {\n\t\tassert.Equal(t, \"[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.\\n\\n\", re)\n\t}\n}\n\nfunc TestDebugPrintWARNINGNew(t *testing.T) {\n\tre := captureOutput(t, func() {\n\t\tSetMode(DebugMode)\n\t\tdebugPrintWARNINGNew()\n\t\tSetMode(TestMode)\n\t})\n\tassert.Equal(t, \"[GIN-debug] [WARNING] Running in \\\"debug\\\" mode. Switch to \\\"release\\\" mode in production.\\n - using env:\\texport GIN_MODE=release\\n - using code:\\tgin.SetMode(gin.ReleaseMode)\\n\\n\", re)\n}\n\nfunc captureOutput(t *testing.T, f func()) string {\n\treader, writer, err := os.Pipe()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefaultWriter := DefaultWriter\n\tdefaultErrorWriter := DefaultErrorWriter\n\tdefer func() {\n\t\tDefaultWriter = defaultWriter\n\t\tDefaultErrorWriter = defaultErrorWriter\n\t\tlog.SetOutput(os.Stderr)\n\t}()\n\tDefaultWriter = writer\n\tDefaultErrorWriter = writer\n\tlog.SetOutput(writer)\n\tout := make(chan string)\n\twg := new(sync.WaitGroup)\n\twg.Add(1)\n\tgo func() {\n\t\tvar buf strings.Builder\n\t\twg.Done()\n\t\t_, err := io.Copy(&buf, reader)\n\t\tassert.NoError(t, err)\n\t\tout <- buf.String()\n\t}()\n\twg.Wait()\n\tf()\n\twriter.Close()\n\treturn <-out\n}\n\nfunc TestGetMinVer(t *testing.T) {\n\tvar m uint64\n\tvar e error\n\t_, e = getMinVer(\"go1\")\n\trequire.Error(t, e)\n\tm, e = getMinVer(\"go1.1\")\n\tassert.Equal(t, uint64(1), m)\n\trequire.NoError(t, e)\n\tm, e = getMinVer(\"go1.1.1\")\n\trequire.NoError(t, e)\n\tassert.Equal(t, uint64(1), m)\n\t_, e = getMinVer(\"go1.1.1.1\")\n\trequire.Error(t, e)\n}\n"
        },
        {
          "name": "deprecated.go",
          "type": "blob",
          "size": 0.744140625,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"log\"\n\n\t\"github.com/gin-gonic/gin/binding\"\n)\n\n// BindWith binds the passed struct pointer using the specified binding engine.\n// See the binding package.\n//\n// Deprecated: Use MustBindWith or ShouldBindWith.\nfunc (c *Context) BindWith(obj any, b binding.Binding) error {\n\tlog.Println(`BindWith(\\\"any, binding.Binding\\\") error is going to\n\tbe deprecated, please check issue #662 and either use MustBindWith() if you\n\twant HTTP 400 to be automatically returned if any error occur, or use\n\tShouldBindWith() if you need to manage the error.`)\n\treturn c.MustBindWith(obj, b)\n}\n"
        },
        {
          "name": "deprecated_test.go",
          "type": "blob",
          "size": 0.76171875,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"bytes\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/gin-gonic/gin/binding\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestBindWith(t *testing.T) {\n\tw := httptest.NewRecorder()\n\tc, _ := CreateTestContext(w)\n\n\tc.Request, _ = http.NewRequest(http.MethodPost, \"/?foo=bar&bar=foo\", bytes.NewBufferString(\"foo=unused\"))\n\n\tvar obj struct {\n\t\tFoo string `form:\"foo\"`\n\t\tBar string `form:\"bar\"`\n\t}\n\tcaptureOutput(t, func() {\n\t\tassert.NoError(t, c.BindWith(&obj, binding.Form))\n\t})\n\tassert.Equal(t, \"foo\", obj.Bar)\n\tassert.Equal(t, \"bar\", obj.Foo)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.1669921875,
          "content": "/*\nPackage gin implements a HTTP web framework called gin.\n\nSee https://gin-gonic.com/ for more information about gin.\n*/\npackage gin // import \"github.com/gin-gonic/gin\"\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 3.90625,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/gin-gonic/gin/internal/json\"\n)\n\n// ErrorType is an unsigned 64-bit error code as defined in the gin spec.\ntype ErrorType uint64\n\nconst (\n\t// ErrorTypeBind is used when Context.Bind() fails.\n\tErrorTypeBind ErrorType = 1 << 63\n\t// ErrorTypeRender is used when Context.Render() fails.\n\tErrorTypeRender ErrorType = 1 << 62\n\t// ErrorTypePrivate indicates a private error.\n\tErrorTypePrivate ErrorType = 1 << 0\n\t// ErrorTypePublic indicates a public error.\n\tErrorTypePublic ErrorType = 1 << 1\n\t// ErrorTypeAny indicates any other error.\n\tErrorTypeAny ErrorType = 1<<64 - 1\n\t// ErrorTypeNu indicates any other error.\n\tErrorTypeNu = 2\n)\n\n// Error represents a error's specification.\ntype Error struct {\n\tErr  error\n\tType ErrorType\n\tMeta any\n}\n\ntype errorMsgs []*Error\n\nvar _ error = (*Error)(nil)\n\n// SetType sets the error's type.\nfunc (msg *Error) SetType(flags ErrorType) *Error {\n\tmsg.Type = flags\n\treturn msg\n}\n\n// SetMeta sets the error's meta data.\nfunc (msg *Error) SetMeta(data any) *Error {\n\tmsg.Meta = data\n\treturn msg\n}\n\n// JSON creates a properly formatted JSON\nfunc (msg *Error) JSON() any {\n\tjsonData := H{}\n\tif msg.Meta != nil {\n\t\tvalue := reflect.ValueOf(msg.Meta)\n\t\tswitch value.Kind() {\n\t\tcase reflect.Struct:\n\t\t\treturn msg.Meta\n\t\tcase reflect.Map:\n\t\t\tfor _, key := range value.MapKeys() {\n\t\t\t\tjsonData[key.String()] = value.MapIndex(key).Interface()\n\t\t\t}\n\t\tdefault:\n\t\t\tjsonData[\"meta\"] = msg.Meta\n\t\t}\n\t}\n\tif _, ok := jsonData[\"error\"]; !ok {\n\t\tjsonData[\"error\"] = msg.Error()\n\t}\n\treturn jsonData\n}\n\n// MarshalJSON implements the json.Marshaller interface.\nfunc (msg *Error) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(msg.JSON())\n}\n\n// Error implements the error interface.\nfunc (msg Error) Error() string {\n\treturn msg.Err.Error()\n}\n\n// IsType judges one error.\nfunc (msg *Error) IsType(flags ErrorType) bool {\n\treturn (msg.Type & flags) > 0\n}\n\n// Unwrap returns the wrapped error, to allow interoperability with errors.Is(), errors.As() and errors.Unwrap()\nfunc (msg *Error) Unwrap() error {\n\treturn msg.Err\n}\n\n// ByType returns a readonly copy filtered the byte.\n// ie ByType(gin.ErrorTypePublic) returns a slice of errors with type=ErrorTypePublic.\nfunc (a errorMsgs) ByType(typ ErrorType) errorMsgs {\n\tif len(a) == 0 {\n\t\treturn nil\n\t}\n\tif typ == ErrorTypeAny {\n\t\treturn a\n\t}\n\tvar result errorMsgs\n\tfor _, msg := range a {\n\t\tif msg.IsType(typ) {\n\t\t\tresult = append(result, msg)\n\t\t}\n\t}\n\treturn result\n}\n\n// Last returns the last error in the slice. It returns nil if the array is empty.\n// Shortcut for errors[len(errors)-1].\nfunc (a errorMsgs) Last() *Error {\n\tif length := len(a); length > 0 {\n\t\treturn a[length-1]\n\t}\n\treturn nil\n}\n\n// Errors returns an array with all the error messages.\n// Example:\n//\n//\tc.Error(errors.New(\"first\"))\n//\tc.Error(errors.New(\"second\"))\n//\tc.Error(errors.New(\"third\"))\n//\tc.Errors.Errors() // == []string{\"first\", \"second\", \"third\"}\nfunc (a errorMsgs) Errors() []string {\n\tif len(a) == 0 {\n\t\treturn nil\n\t}\n\terrorStrings := make([]string, len(a))\n\tfor i, err := range a {\n\t\terrorStrings[i] = err.Error()\n\t}\n\treturn errorStrings\n}\n\nfunc (a errorMsgs) JSON() any {\n\tswitch length := len(a); length {\n\tcase 0:\n\t\treturn nil\n\tcase 1:\n\t\treturn a.Last().JSON()\n\tdefault:\n\t\tjsonData := make([]any, length)\n\t\tfor i, err := range a {\n\t\t\tjsonData[i] = err.JSON()\n\t\t}\n\t\treturn jsonData\n\t}\n}\n\n// MarshalJSON implements the json.Marshaller interface.\nfunc (a errorMsgs) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(a.JSON())\n}\n\nfunc (a errorMsgs) String() string {\n\tif len(a) == 0 {\n\t\treturn \"\"\n\t}\n\tvar buffer strings.Builder\n\tfor i, msg := range a {\n\t\tfmt.Fprintf(&buffer, \"Error #%02d: %s\\n\", i+1, msg.Err)\n\t\tif msg.Meta != nil {\n\t\t\tfmt.Fprintf(&buffer, \"     Meta: %v\\n\", msg.Meta)\n\t\t}\n\t}\n\treturn buffer.String()\n}\n"
        },
        {
          "name": "errors_test.go",
          "type": "blob",
          "size": 3.8154296875,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/gin-gonic/gin/internal/json\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestError(t *testing.T) {\n\tbaseError := errors.New(\"test error\")\n\terr := &Error{\n\t\tErr:  baseError,\n\t\tType: ErrorTypePrivate,\n\t}\n\tassert.Equal(t, err.Error(), baseError.Error())\n\tassert.Equal(t, H{\"error\": baseError.Error()}, err.JSON())\n\n\tassert.Equal(t, err.SetType(ErrorTypePublic), err)\n\tassert.Equal(t, ErrorTypePublic, err.Type)\n\n\tassert.Equal(t, err.SetMeta(\"some data\"), err)\n\tassert.Equal(t, \"some data\", err.Meta)\n\tassert.Equal(t, H{\n\t\t\"error\": baseError.Error(),\n\t\t\"meta\":  \"some data\",\n\t}, err.JSON())\n\n\tjsonBytes, _ := json.Marshal(err)\n\tassert.Equal(t, \"{\\\"error\\\":\\\"test error\\\",\\\"meta\\\":\\\"some data\\\"}\", string(jsonBytes))\n\n\terr.SetMeta(H{ //nolint: errcheck\n\t\t\"status\": \"200\",\n\t\t\"data\":   \"some data\",\n\t})\n\tassert.Equal(t, H{\n\t\t\"error\":  baseError.Error(),\n\t\t\"status\": \"200\",\n\t\t\"data\":   \"some data\",\n\t}, err.JSON())\n\n\terr.SetMeta(H{ //nolint: errcheck\n\t\t\"error\":  \"custom error\",\n\t\t\"status\": \"200\",\n\t\t\"data\":   \"some data\",\n\t})\n\tassert.Equal(t, H{\n\t\t\"error\":  \"custom error\",\n\t\t\"status\": \"200\",\n\t\t\"data\":   \"some data\",\n\t}, err.JSON())\n\n\ttype customError struct {\n\t\tstatus string\n\t\tdata   string\n\t}\n\terr.SetMeta(customError{status: \"200\", data: \"other data\"}) //nolint: errcheck\n\tassert.Equal(t, customError{status: \"200\", data: \"other data\"}, err.JSON())\n}\n\nfunc TestErrorSlice(t *testing.T) {\n\terrs := errorMsgs{\n\t\t{Err: errors.New(\"first\"), Type: ErrorTypePrivate},\n\t\t{Err: errors.New(\"second\"), Type: ErrorTypePrivate, Meta: \"some data\"},\n\t\t{Err: errors.New(\"third\"), Type: ErrorTypePublic, Meta: H{\"status\": \"400\"}},\n\t}\n\n\tassert.Equal(t, errs, errs.ByType(ErrorTypeAny))\n\tassert.Equal(t, \"third\", errs.Last().Error())\n\tassert.Equal(t, []string{\"first\", \"second\", \"third\"}, errs.Errors())\n\tassert.Equal(t, []string{\"third\"}, errs.ByType(ErrorTypePublic).Errors())\n\tassert.Equal(t, []string{\"first\", \"second\"}, errs.ByType(ErrorTypePrivate).Errors())\n\tassert.Equal(t, []string{\"first\", \"second\", \"third\"}, errs.ByType(ErrorTypePublic|ErrorTypePrivate).Errors())\n\tassert.Empty(t, errs.ByType(ErrorTypeBind))\n\tassert.Empty(t, errs.ByType(ErrorTypeBind).String())\n\n\tassert.Equal(t, `Error #01: first\nError #02: second\n     Meta: some data\nError #03: third\n     Meta: map[status:400]\n`, errs.String())\n\tassert.Equal(t, []any{\n\t\tH{\"error\": \"first\"},\n\t\tH{\"error\": \"second\", \"meta\": \"some data\"},\n\t\tH{\"error\": \"third\", \"status\": \"400\"},\n\t}, errs.JSON())\n\tjsonBytes, _ := json.Marshal(errs)\n\tassert.Equal(t, \"[{\\\"error\\\":\\\"first\\\"},{\\\"error\\\":\\\"second\\\",\\\"meta\\\":\\\"some data\\\"},{\\\"error\\\":\\\"third\\\",\\\"status\\\":\\\"400\\\"}]\", string(jsonBytes))\n\terrs = errorMsgs{\n\t\t{Err: errors.New(\"first\"), Type: ErrorTypePrivate},\n\t}\n\tassert.Equal(t, H{\"error\": \"first\"}, errs.JSON())\n\tjsonBytes, _ = json.Marshal(errs)\n\tassert.Equal(t, \"{\\\"error\\\":\\\"first\\\"}\", string(jsonBytes))\n\n\terrs = errorMsgs{}\n\tassert.Nil(t, errs.Last())\n\tassert.Nil(t, errs.JSON())\n\tassert.Empty(t, errs.String())\n}\n\ntype TestErr string\n\nfunc (e TestErr) Error() string { return string(e) }\n\n// TestErrorUnwrap tests the behavior of gin.Error with \"errors.Is()\" and \"errors.As()\".\n// \"errors.Is()\" and \"errors.As()\" have been added to the standard library in go 1.13.\nfunc TestErrorUnwrap(t *testing.T) {\n\tinnerErr := TestErr(\"some error\")\n\n\t// 2 layers of wrapping : use 'fmt.Errorf(\"%w\")' to wrap a gin.Error{}, which itself wraps innerErr\n\terr := fmt.Errorf(\"wrapped: %w\", &Error{\n\t\tErr:  innerErr,\n\t\tType: ErrorTypeAny,\n\t})\n\n\t// check that 'errors.Is()' and 'errors.As()' behave as expected :\n\trequire.ErrorIs(t, err, innerErr)\n\tvar testErr TestErr\n\trequire.ErrorAs(t, err, &testErr)\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "fs.go",
          "type": "blob",
          "size": 1.3642578125,
          "content": "// Copyright 2017 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"net/http\"\n\t\"os\"\n)\n\n// OnlyFilesFS implements an http.FileSystem without `Readdir` functionality.\ntype OnlyFilesFS struct {\n\tFileSystem http.FileSystem\n}\n\n// Open passes `Open` to the upstream implementation without `Readdir` functionality.\nfunc (o OnlyFilesFS) Open(name string) (http.File, error) {\n\tf, err := o.FileSystem.Open(name)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn neutralizedReaddirFile{f}, nil\n}\n\n// neutralizedReaddirFile wraps http.File with a specific implementation of `Readdir`.\ntype neutralizedReaddirFile struct {\n\thttp.File\n}\n\n// Readdir overrides the http.File default implementation and always returns nil.\nfunc (n neutralizedReaddirFile) Readdir(_ int) ([]os.FileInfo, error) {\n\t// this disables directory listing\n\treturn nil, nil\n}\n\n// Dir returns an http.FileSystem that can be used by http.FileServer().\n// It is used internally in router.Static().\n// if listDirectory == true, then it works the same as http.Dir(),\n// otherwise it returns a filesystem that prevents http.FileServer() to list the directory files.\nfunc Dir(root string, listDirectory bool) http.FileSystem {\n\tfs := http.Dir(root)\n\n\tif listDirectory {\n\t\treturn fs\n\t}\n\n\treturn &OnlyFilesFS{FileSystem: fs}\n}\n"
        },
        {
          "name": "fs_test.go",
          "type": "blob",
          "size": 1.3623046875,
          "content": "package gin\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype mockFileSystem struct {\n\topen func(name string) (http.File, error)\n}\n\nfunc (m *mockFileSystem) Open(name string) (http.File, error) {\n\treturn m.open(name)\n}\n\nfunc TestOnlyFilesFS_Open(t *testing.T) {\n\tvar testFile *os.File\n\tmockFS := &mockFileSystem{\n\t\topen: func(name string) (http.File, error) {\n\t\t\treturn testFile, nil\n\t\t},\n\t}\n\tfs := &OnlyFilesFS{FileSystem: mockFS}\n\n\tfile, err := fs.Open(\"foo\")\n\n\trequire.NoError(t, err)\n\tassert.Equal(t, testFile, file.(neutralizedReaddirFile).File)\n}\n\nfunc TestOnlyFilesFS_Open_err(t *testing.T) {\n\ttestError := errors.New(\"mock\")\n\tmockFS := &mockFileSystem{\n\t\topen: func(_ string) (http.File, error) {\n\t\t\treturn nil, testError\n\t\t},\n\t}\n\tfs := &OnlyFilesFS{FileSystem: mockFS}\n\n\tfile, err := fs.Open(\"foo\")\n\n\trequire.ErrorIs(t, err, testError)\n\tassert.Nil(t, file)\n}\n\nfunc Test_neuteredReaddirFile_Readdir(t *testing.T) {\n\tn := neutralizedReaddirFile{}\n\n\tres, err := n.Readdir(0)\n\n\trequire.NoError(t, err)\n\tassert.Nil(t, res)\n}\n\nfunc TestDir_listDirectory(t *testing.T) {\n\ttestRoot := \"foo\"\n\tfs := Dir(testRoot, true)\n\n\tassert.Equal(t, http.Dir(testRoot), fs)\n}\n\nfunc TestDir(t *testing.T) {\n\ttestRoot := \"foo\"\n\tfs := Dir(testRoot, false)\n\n\tassert.Equal(t, &OnlyFilesFS{FileSystem: http.Dir(testRoot)}, fs)\n}\n"
        },
        {
          "name": "gin.go",
          "type": "blob",
          "size": 24.7119140625,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gin-gonic/gin/internal/bytesconv\"\n\t\"github.com/gin-gonic/gin/render\"\n\n\t\"github.com/quic-go/quic-go/http3\"\n\t\"golang.org/x/net/http2\"\n\t\"golang.org/x/net/http2/h2c\"\n)\n\nconst defaultMultipartMemory = 32 << 20 // 32 MB\nconst escapedColon = \"\\\\:\"\nconst colon = \":\"\nconst backslash = \"\\\\\"\n\nvar (\n\tdefault404Body = []byte(\"404 page not found\")\n\tdefault405Body = []byte(\"405 method not allowed\")\n)\n\nvar defaultPlatform string\n\nvar defaultTrustedCIDRs = []*net.IPNet{\n\t{ // 0.0.0.0/0 (IPv4)\n\t\tIP:   net.IP{0x0, 0x0, 0x0, 0x0},\n\t\tMask: net.IPMask{0x0, 0x0, 0x0, 0x0},\n\t},\n\t{ // ::/0 (IPv6)\n\t\tIP:   net.IP{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n\t\tMask: net.IPMask{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},\n\t},\n}\n\nvar regSafePrefix = regexp.MustCompile(\"[^a-zA-Z0-9/-]+\")\nvar regRemoveRepeatedChar = regexp.MustCompile(\"/{2,}\")\n\n// HandlerFunc defines the handler used by gin middleware as return value.\ntype HandlerFunc func(*Context)\n\n// OptionFunc defines the function to change the default configuration\ntype OptionFunc func(*Engine)\n\n// HandlersChain defines a HandlerFunc slice.\ntype HandlersChain []HandlerFunc\n\n// Last returns the last handler in the chain. i.e. the last handler is the main one.\nfunc (c HandlersChain) Last() HandlerFunc {\n\tif length := len(c); length > 0 {\n\t\treturn c[length-1]\n\t}\n\treturn nil\n}\n\n// RouteInfo represents a request route's specification which contains method and path and its handler.\ntype RouteInfo struct {\n\tMethod      string\n\tPath        string\n\tHandler     string\n\tHandlerFunc HandlerFunc\n}\n\n// RoutesInfo defines a RouteInfo slice.\ntype RoutesInfo []RouteInfo\n\n// Trusted platforms\nconst (\n\t// PlatformGoogleAppEngine when running on Google App Engine. Trust X-Appengine-Remote-Addr\n\t// for determining the client's IP\n\tPlatformGoogleAppEngine = \"X-Appengine-Remote-Addr\"\n\t// PlatformCloudflare when using Cloudflare's CDN. Trust CF-Connecting-IP for determining\n\t// the client's IP\n\tPlatformCloudflare = \"CF-Connecting-IP\"\n\t// PlatformFlyIO when running on Fly.io. Trust Fly-Client-IP for determining the client's IP\n\tPlatformFlyIO = \"Fly-Client-IP\"\n)\n\n// Engine is the framework's instance, it contains the muxer, middleware and configuration settings.\n// Create an instance of Engine, by using New() or Default()\ntype Engine struct {\n\tRouterGroup\n\n\t// RedirectTrailingSlash enables automatic redirection if the current route can't be matched but a\n\t// handler for the path with (without) the trailing slash exists.\n\t// For example if /foo/ is requested but a route only exists for /foo, the\n\t// client is redirected to /foo with http status code 301 for GET requests\n\t// and 307 for all other request methods.\n\tRedirectTrailingSlash bool\n\n\t// RedirectFixedPath if enabled, the router tries to fix the current request path, if no\n\t// handle is registered for it.\n\t// First superfluous path elements like ../ or // are removed.\n\t// Afterwards the router does a case-insensitive lookup of the cleaned path.\n\t// If a handle can be found for this route, the router makes a redirection\n\t// to the corrected path with status code 301 for GET requests and 307 for\n\t// all other request methods.\n\t// For example /FOO and /..//Foo could be redirected to /foo.\n\t// RedirectTrailingSlash is independent of this option.\n\tRedirectFixedPath bool\n\n\t// HandleMethodNotAllowed if enabled, the router checks if another method is allowed for the\n\t// current route, if the current request can not be routed.\n\t// If this is the case, the request is answered with 'Method Not Allowed'\n\t// and HTTP status code 405.\n\t// If no other Method is allowed, the request is delegated to the NotFound\n\t// handler.\n\tHandleMethodNotAllowed bool\n\n\t// ForwardedByClientIP if enabled, client IP will be parsed from the request's headers that\n\t// match those stored at `(*gin.Engine).RemoteIPHeaders`. If no IP was\n\t// fetched, it falls back to the IP obtained from\n\t// `(*gin.Context).Request.RemoteAddr`.\n\tForwardedByClientIP bool\n\n\t// AppEngine was deprecated.\n\t// Deprecated: USE `TrustedPlatform` WITH VALUE `gin.PlatformGoogleAppEngine` INSTEAD\n\t// #726 #755 If enabled, it will trust some headers starting with\n\t// 'X-AppEngine...' for better integration with that PaaS.\n\tAppEngine bool\n\n\t// UseRawPath if enabled, the url.RawPath will be used to find parameters.\n\tUseRawPath bool\n\n\t// UnescapePathValues if true, the path value will be unescaped.\n\t// If UseRawPath is false (by default), the UnescapePathValues effectively is true,\n\t// as url.Path gonna be used, which is already unescaped.\n\tUnescapePathValues bool\n\n\t// RemoveExtraSlash a parameter can be parsed from the URL even with extra slashes.\n\t// See the PR #1817 and issue #1644\n\tRemoveExtraSlash bool\n\n\t// RemoteIPHeaders list of headers used to obtain the client IP when\n\t// `(*gin.Engine).ForwardedByClientIP` is `true` and\n\t// `(*gin.Context).Request.RemoteAddr` is matched by at least one of the\n\t// network origins of list defined by `(*gin.Engine).SetTrustedProxies()`.\n\tRemoteIPHeaders []string\n\n\t// TrustedPlatform if set to a constant of value gin.Platform*, trusts the headers set by\n\t// that platform, for example to determine the client IP\n\tTrustedPlatform string\n\n\t// MaxMultipartMemory value of 'maxMemory' param that is given to http.Request's ParseMultipartForm\n\t// method call.\n\tMaxMultipartMemory int64\n\n\t// UseH2C enable h2c support.\n\tUseH2C bool\n\n\t// ContextWithFallback enable fallback Context.Deadline(), Context.Done(), Context.Err() and Context.Value() when Context.Request.Context() is not nil.\n\tContextWithFallback bool\n\n\tdelims           render.Delims\n\tsecureJSONPrefix string\n\tHTMLRender       render.HTMLRender\n\tFuncMap          template.FuncMap\n\tallNoRoute       HandlersChain\n\tallNoMethod      HandlersChain\n\tnoRoute          HandlersChain\n\tnoMethod         HandlersChain\n\tpool             sync.Pool\n\ttrees            methodTrees\n\tmaxParams        uint16\n\tmaxSections      uint16\n\ttrustedProxies   []string\n\ttrustedCIDRs     []*net.IPNet\n}\n\nvar _ IRouter = (*Engine)(nil)\n\n// New returns a new blank Engine instance without any middleware attached.\n// By default, the configuration is:\n// - RedirectTrailingSlash:  true\n// - RedirectFixedPath:      false\n// - HandleMethodNotAllowed: false\n// - ForwardedByClientIP:    true\n// - UseRawPath:             false\n// - UnescapePathValues:     true\nfunc New(opts ...OptionFunc) *Engine {\n\tdebugPrintWARNINGNew()\n\tengine := &Engine{\n\t\tRouterGroup: RouterGroup{\n\t\t\tHandlers: nil,\n\t\t\tbasePath: \"/\",\n\t\t\troot:     true,\n\t\t},\n\t\tFuncMap:                template.FuncMap{},\n\t\tRedirectTrailingSlash:  true,\n\t\tRedirectFixedPath:      false,\n\t\tHandleMethodNotAllowed: false,\n\t\tForwardedByClientIP:    true,\n\t\tRemoteIPHeaders:        []string{\"X-Forwarded-For\", \"X-Real-IP\"},\n\t\tTrustedPlatform:        defaultPlatform,\n\t\tUseRawPath:             false,\n\t\tRemoveExtraSlash:       false,\n\t\tUnescapePathValues:     true,\n\t\tMaxMultipartMemory:     defaultMultipartMemory,\n\t\ttrees:                  make(methodTrees, 0, 9),\n\t\tdelims:                 render.Delims{Left: \"{{\", Right: \"}}\"},\n\t\tsecureJSONPrefix:       \"while(1);\",\n\t\ttrustedProxies:         []string{\"0.0.0.0/0\", \"::/0\"},\n\t\ttrustedCIDRs:           defaultTrustedCIDRs,\n\t}\n\tengine.RouterGroup.engine = engine\n\tengine.pool.New = func() any {\n\t\treturn engine.allocateContext(engine.maxParams)\n\t}\n\treturn engine.With(opts...)\n}\n\n// Default returns an Engine instance with the Logger and Recovery middleware already attached.\nfunc Default(opts ...OptionFunc) *Engine {\n\tdebugPrintWARNINGDefault()\n\tengine := New()\n\tengine.Use(Logger(), Recovery())\n\treturn engine.With(opts...)\n}\n\nfunc (engine *Engine) Handler() http.Handler {\n\tif !engine.UseH2C {\n\t\treturn engine\n\t}\n\n\th2s := &http2.Server{}\n\treturn h2c.NewHandler(engine, h2s)\n}\n\nfunc (engine *Engine) allocateContext(maxParams uint16) *Context {\n\tv := make(Params, 0, maxParams)\n\tskippedNodes := make([]skippedNode, 0, engine.maxSections)\n\treturn &Context{engine: engine, params: &v, skippedNodes: &skippedNodes}\n}\n\n// Delims sets template left and right delims and returns an Engine instance.\nfunc (engine *Engine) Delims(left, right string) *Engine {\n\tengine.delims = render.Delims{Left: left, Right: right}\n\treturn engine\n}\n\n// SecureJsonPrefix sets the secureJSONPrefix used in Context.SecureJSON.\nfunc (engine *Engine) SecureJsonPrefix(prefix string) *Engine {\n\tengine.secureJSONPrefix = prefix\n\treturn engine\n}\n\n// LoadHTMLGlob loads HTML files identified by glob pattern\n// and associates the result with HTML renderer.\nfunc (engine *Engine) LoadHTMLGlob(pattern string) {\n\tleft := engine.delims.Left\n\tright := engine.delims.Right\n\ttempl := template.Must(template.New(\"\").Delims(left, right).Funcs(engine.FuncMap).ParseGlob(pattern))\n\n\tif IsDebugging() {\n\t\tdebugPrintLoadTemplate(templ)\n\t\tengine.HTMLRender = render.HTMLDebug{Glob: pattern, FuncMap: engine.FuncMap, Delims: engine.delims}\n\t\treturn\n\t}\n\n\tengine.SetHTMLTemplate(templ)\n}\n\n// LoadHTMLFiles loads a slice of HTML files\n// and associates the result with HTML renderer.\nfunc (engine *Engine) LoadHTMLFiles(files ...string) {\n\tif IsDebugging() {\n\t\tengine.HTMLRender = render.HTMLDebug{Files: files, FuncMap: engine.FuncMap, Delims: engine.delims}\n\t\treturn\n\t}\n\n\ttempl := template.Must(template.New(\"\").Delims(engine.delims.Left, engine.delims.Right).Funcs(engine.FuncMap).ParseFiles(files...))\n\tengine.SetHTMLTemplate(templ)\n}\n\n// SetHTMLTemplate associate a template with HTML renderer.\nfunc (engine *Engine) SetHTMLTemplate(templ *template.Template) {\n\tif len(engine.trees) > 0 {\n\t\tdebugPrintWARNINGSetHTMLTemplate()\n\t}\n\n\tengine.HTMLRender = render.HTMLProduction{Template: templ.Funcs(engine.FuncMap)}\n}\n\n// SetFuncMap sets the FuncMap used for template.FuncMap.\nfunc (engine *Engine) SetFuncMap(funcMap template.FuncMap) {\n\tengine.FuncMap = funcMap\n}\n\n// NoRoute adds handlers for NoRoute. It returns a 404 code by default.\nfunc (engine *Engine) NoRoute(handlers ...HandlerFunc) {\n\tengine.noRoute = handlers\n\tengine.rebuild404Handlers()\n}\n\n// NoMethod sets the handlers called when Engine.HandleMethodNotAllowed = true.\nfunc (engine *Engine) NoMethod(handlers ...HandlerFunc) {\n\tengine.noMethod = handlers\n\tengine.rebuild405Handlers()\n}\n\n// Use attaches a global middleware to the router. i.e. the middleware attached through Use() will be\n// included in the handlers chain for every single request. Even 404, 405, static files...\n// For example, this is the right place for a logger or error management middleware.\nfunc (engine *Engine) Use(middleware ...HandlerFunc) IRoutes {\n\tengine.RouterGroup.Use(middleware...)\n\tengine.rebuild404Handlers()\n\tengine.rebuild405Handlers()\n\treturn engine\n}\n\n// With returns a Engine with the configuration set in the OptionFunc.\nfunc (engine *Engine) With(opts ...OptionFunc) *Engine {\n\tfor _, opt := range opts {\n\t\topt(engine)\n\t}\n\n\treturn engine\n}\n\nfunc (engine *Engine) rebuild404Handlers() {\n\tengine.allNoRoute = engine.combineHandlers(engine.noRoute)\n}\n\nfunc (engine *Engine) rebuild405Handlers() {\n\tengine.allNoMethod = engine.combineHandlers(engine.noMethod)\n}\n\nfunc (engine *Engine) addRoute(method, path string, handlers HandlersChain) {\n\tassert1(path[0] == '/', \"path must begin with '/'\")\n\tassert1(method != \"\", \"HTTP method can not be empty\")\n\tassert1(len(handlers) > 0, \"there must be at least one handler\")\n\n\tdebugPrintRoute(method, path, handlers)\n\n\troot := engine.trees.get(method)\n\tif root == nil {\n\t\troot = new(node)\n\t\troot.fullPath = \"/\"\n\t\tengine.trees = append(engine.trees, methodTree{method: method, root: root})\n\t}\n\troot.addRoute(path, handlers)\n\n\tif paramsCount := countParams(path); paramsCount > engine.maxParams {\n\t\tengine.maxParams = paramsCount\n\t}\n\n\tif sectionsCount := countSections(path); sectionsCount > engine.maxSections {\n\t\tengine.maxSections = sectionsCount\n\t}\n}\n\n// Routes returns a slice of registered routes, including some useful information, such as:\n// the http method, path and the handler name.\nfunc (engine *Engine) Routes() (routes RoutesInfo) {\n\tfor _, tree := range engine.trees {\n\t\troutes = iterate(\"\", tree.method, routes, tree.root)\n\t}\n\treturn routes\n}\n\nfunc iterate(path, method string, routes RoutesInfo, root *node) RoutesInfo {\n\tpath += root.path\n\tif len(root.handlers) > 0 {\n\t\thandlerFunc := root.handlers.Last()\n\t\troutes = append(routes, RouteInfo{\n\t\t\tMethod:      method,\n\t\t\tPath:        path,\n\t\t\tHandler:     nameOfFunction(handlerFunc),\n\t\t\tHandlerFunc: handlerFunc,\n\t\t})\n\t}\n\tfor _, child := range root.children {\n\t\troutes = iterate(path, method, routes, child)\n\t}\n\treturn routes\n}\n\nfunc (engine *Engine) prepareTrustedCIDRs() ([]*net.IPNet, error) {\n\tif engine.trustedProxies == nil {\n\t\treturn nil, nil\n\t}\n\n\tcidr := make([]*net.IPNet, 0, len(engine.trustedProxies))\n\tfor _, trustedProxy := range engine.trustedProxies {\n\t\tif !strings.Contains(trustedProxy, \"/\") {\n\t\t\tip := parseIP(trustedProxy)\n\t\t\tif ip == nil {\n\t\t\t\treturn cidr, &net.ParseError{Type: \"IP address\", Text: trustedProxy}\n\t\t\t}\n\n\t\t\tswitch len(ip) {\n\t\t\tcase net.IPv4len:\n\t\t\t\ttrustedProxy += \"/32\"\n\t\t\tcase net.IPv6len:\n\t\t\t\ttrustedProxy += \"/128\"\n\t\t\t}\n\t\t}\n\t\t_, cidrNet, err := net.ParseCIDR(trustedProxy)\n\t\tif err != nil {\n\t\t\treturn cidr, err\n\t\t}\n\t\tcidr = append(cidr, cidrNet)\n\t}\n\treturn cidr, nil\n}\n\n// SetTrustedProxies set a list of network origins (IPv4 addresses,\n// IPv4 CIDRs, IPv6 addresses or IPv6 CIDRs) from which to trust\n// request's headers that contain alternative client IP when\n// `(*gin.Engine).ForwardedByClientIP` is `true`. `TrustedProxies`\n// feature is enabled by default, and it also trusts all proxies\n// by default. If you want to disable this feature, use\n// Engine.SetTrustedProxies(nil), then Context.ClientIP() will\n// return the remote address directly.\nfunc (engine *Engine) SetTrustedProxies(trustedProxies []string) error {\n\tengine.trustedProxies = trustedProxies\n\treturn engine.parseTrustedProxies()\n}\n\n// isUnsafeTrustedProxies checks if Engine.trustedCIDRs contains all IPs, it's not safe if it has (returns true)\nfunc (engine *Engine) isUnsafeTrustedProxies() bool {\n\treturn engine.isTrustedProxy(net.ParseIP(\"0.0.0.0\")) || engine.isTrustedProxy(net.ParseIP(\"::\"))\n}\n\n// parseTrustedProxies parse Engine.trustedProxies to Engine.trustedCIDRs\nfunc (engine *Engine) parseTrustedProxies() error {\n\ttrustedCIDRs, err := engine.prepareTrustedCIDRs()\n\tengine.trustedCIDRs = trustedCIDRs\n\treturn err\n}\n\n// isTrustedProxy will check whether the IP address is included in the trusted list according to Engine.trustedCIDRs\nfunc (engine *Engine) isTrustedProxy(ip net.IP) bool {\n\tif engine.trustedCIDRs == nil {\n\t\treturn false\n\t}\n\tfor _, cidr := range engine.trustedCIDRs {\n\t\tif cidr.Contains(ip) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// validateHeader will parse X-Forwarded-For header and return the trusted client IP address\nfunc (engine *Engine) validateHeader(header string) (clientIP string, valid bool) {\n\tif header == \"\" {\n\t\treturn \"\", false\n\t}\n\titems := strings.Split(header, \",\")\n\tfor i := len(items) - 1; i >= 0; i-- {\n\t\tipStr := strings.TrimSpace(items[i])\n\t\tip := net.ParseIP(ipStr)\n\t\tif ip == nil {\n\t\t\tbreak\n\t\t}\n\n\t\t// X-Forwarded-For is appended by proxy\n\t\t// Check IPs in reverse order and stop when find untrusted proxy\n\t\tif (i == 0) || (!engine.isTrustedProxy(ip)) {\n\t\t\treturn ipStr, true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n// updateRouteTree do update to the route tree recursively\nfunc updateRouteTree(n *node) {\n\tn.path = strings.ReplaceAll(n.path, escapedColon, colon)\n\tn.fullPath = strings.ReplaceAll(n.fullPath, escapedColon, colon)\n\tn.indices = strings.ReplaceAll(n.indices, backslash, colon)\n\tif n.children == nil {\n\t\treturn\n\t}\n\tfor _, child := range n.children {\n\t\tupdateRouteTree(child)\n\t}\n}\n\n// updateRouteTrees do update to the route trees\nfunc (engine *Engine) updateRouteTrees() {\n\tfor _, tree := range engine.trees {\n\t\tupdateRouteTree(tree.root)\n\t}\n}\n\n// parseIP parse a string representation of an IP and returns a net.IP with the\n// minimum byte representation or nil if input is invalid.\nfunc parseIP(ip string) net.IP {\n\tparsedIP := net.ParseIP(ip)\n\n\tif ipv4 := parsedIP.To4(); ipv4 != nil {\n\t\t// return ip in a 4-byte representation\n\t\treturn ipv4\n\t}\n\n\t// return ip in a 16-byte representation or nil\n\treturn parsedIP\n}\n\n// Run attaches the router to a http.Server and starts listening and serving HTTP requests.\n// It is a shortcut for http.ListenAndServe(addr, router)\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) Run(addr ...string) (err error) {\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://github.com/gin-gonic/gin/blob/master/docs/doc.md#dont-trust-all-proxies for details.\")\n\t}\n\tengine.updateRouteTrees()\n\taddress := resolveAddress(addr)\n\tdebugPrint(\"Listening and serving HTTP on %s\\n\", address)\n\terr = http.ListenAndServe(address, engine.Handler())\n\treturn\n}\n\n// RunTLS attaches the router to a http.Server and starts listening and serving HTTPS (secure) requests.\n// It is a shortcut for http.ListenAndServeTLS(addr, certFile, keyFile, router)\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) RunTLS(addr, certFile, keyFile string) (err error) {\n\tdebugPrint(\"Listening and serving HTTPS on %s\\n\", addr)\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://github.com/gin-gonic/gin/blob/master/docs/doc.md#dont-trust-all-proxies for details.\")\n\t}\n\n\terr = http.ListenAndServeTLS(addr, certFile, keyFile, engine.Handler())\n\treturn\n}\n\n// RunUnix attaches the router to a http.Server and starts listening and serving HTTP requests\n// through the specified unix socket (i.e. a file).\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) RunUnix(file string) (err error) {\n\tdebugPrint(\"Listening and serving HTTP on unix:/%s\", file)\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://github.com/gin-gonic/gin/blob/master/docs/doc.md#dont-trust-all-proxies for details.\")\n\t}\n\n\tlistener, err := net.Listen(\"unix\", file)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer listener.Close()\n\tdefer os.Remove(file)\n\n\terr = http.Serve(listener, engine.Handler())\n\treturn\n}\n\n// RunFd attaches the router to a http.Server and starts listening and serving HTTP requests\n// through the specified file descriptor.\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) RunFd(fd int) (err error) {\n\tdebugPrint(\"Listening and serving HTTP on fd@%d\", fd)\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://github.com/gin-gonic/gin/blob/master/docs/doc.md#dont-trust-all-proxies for details.\")\n\t}\n\n\tf := os.NewFile(uintptr(fd), fmt.Sprintf(\"fd@%d\", fd))\n\tlistener, err := net.FileListener(f)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer listener.Close()\n\terr = engine.RunListener(listener)\n\treturn\n}\n\n// RunQUIC attaches the router to a http.Server and starts listening and serving QUIC requests.\n// It is a shortcut for http3.ListenAndServeQUIC(addr, certFile, keyFile, router)\n// Note: this method will block the calling goroutine indefinitely unless an error happens.\nfunc (engine *Engine) RunQUIC(addr, certFile, keyFile string) (err error) {\n\tdebugPrint(\"Listening and serving QUIC on %s\\n\", addr)\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://github.com/gin-gonic/gin/blob/master/docs/doc.md#dont-trust-all-proxies for details.\")\n\t}\n\n\terr = http3.ListenAndServeQUIC(addr, certFile, keyFile, engine.Handler())\n\treturn\n}\n\n// RunListener attaches the router to a http.Server and starts listening and serving HTTP requests\n// through the specified net.Listener\nfunc (engine *Engine) RunListener(listener net.Listener) (err error) {\n\tdebugPrint(\"Listening and serving HTTP on listener what's bind with address@%s\", listener.Addr())\n\tdefer func() { debugPrintError(err) }()\n\n\tif engine.isUnsafeTrustedProxies() {\n\t\tdebugPrint(\"[WARNING] You trusted all proxies, this is NOT safe. We recommend you to set a value.\\n\" +\n\t\t\t\"Please check https://github.com/gin-gonic/gin/blob/master/docs/doc.md#dont-trust-all-proxies for details.\")\n\t}\n\n\terr = http.Serve(listener, engine.Handler())\n\treturn\n}\n\n// ServeHTTP conforms to the http.Handler interface.\nfunc (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tc := engine.pool.Get().(*Context)\n\tc.writermem.reset(w)\n\tc.Request = req\n\tc.reset()\n\n\tengine.handleHTTPRequest(c)\n\n\tengine.pool.Put(c)\n}\n\n// HandleContext re-enters a context that has been rewritten.\n// This can be done by setting c.Request.URL.Path to your new target.\n// Disclaimer: You can loop yourself to deal with this, use wisely.\nfunc (engine *Engine) HandleContext(c *Context) {\n\toldIndexValue := c.index\n\tc.reset()\n\tengine.handleHTTPRequest(c)\n\n\tc.index = oldIndexValue\n}\n\nfunc (engine *Engine) handleHTTPRequest(c *Context) {\n\thttpMethod := c.Request.Method\n\trPath := c.Request.URL.Path\n\tunescape := false\n\tif engine.UseRawPath && len(c.Request.URL.RawPath) > 0 {\n\t\trPath = c.Request.URL.RawPath\n\t\tunescape = engine.UnescapePathValues\n\t}\n\n\tif engine.RemoveExtraSlash {\n\t\trPath = cleanPath(rPath)\n\t}\n\n\t// Find root of the tree for the given HTTP method\n\tt := engine.trees\n\tfor i, tl := 0, len(t); i < tl; i++ {\n\t\tif t[i].method != httpMethod {\n\t\t\tcontinue\n\t\t}\n\t\troot := t[i].root\n\t\t// Find route in tree\n\t\tvalue := root.getValue(rPath, c.params, c.skippedNodes, unescape)\n\t\tif value.params != nil {\n\t\t\tc.Params = *value.params\n\t\t}\n\t\tif value.handlers != nil {\n\t\t\tc.handlers = value.handlers\n\t\t\tc.fullPath = value.fullPath\n\t\t\tc.Next()\n\t\t\tc.writermem.WriteHeaderNow()\n\t\t\treturn\n\t\t}\n\t\tif httpMethod != http.MethodConnect && rPath != \"/\" {\n\t\t\tif value.tsr && engine.RedirectTrailingSlash {\n\t\t\t\tredirectTrailingSlash(c)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif engine.RedirectFixedPath && redirectFixedPath(c, root, engine.RedirectFixedPath) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tbreak\n\t}\n\n\tif engine.HandleMethodNotAllowed && len(t) > 0 {\n\t\t// According to RFC 7231 section 6.5.5, MUST generate an Allow header field in response\n\t\t// containing a list of the target resource's currently supported methods.\n\t\tallowed := make([]string, 0, len(t)-1)\n\t\tfor _, tree := range engine.trees {\n\t\t\tif tree.method == httpMethod {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif value := tree.root.getValue(rPath, nil, c.skippedNodes, unescape); value.handlers != nil {\n\t\t\t\tallowed = append(allowed, tree.method)\n\t\t\t}\n\t\t}\n\t\tif len(allowed) > 0 {\n\t\t\tc.handlers = engine.allNoMethod\n\t\t\tc.writermem.Header().Set(\"Allow\", strings.Join(allowed, \", \"))\n\t\t\tserveError(c, http.StatusMethodNotAllowed, default405Body)\n\t\t\treturn\n\t\t}\n\t}\n\n\tc.handlers = engine.allNoRoute\n\tserveError(c, http.StatusNotFound, default404Body)\n}\n\nvar mimePlain = []string{MIMEPlain}\n\nfunc serveError(c *Context, code int, defaultMessage []byte) {\n\tc.writermem.status = code\n\tc.Next()\n\tif c.writermem.Written() {\n\t\treturn\n\t}\n\tif c.writermem.Status() == code {\n\t\tc.writermem.Header()[\"Content-Type\"] = mimePlain\n\t\t_, err := c.Writer.Write(defaultMessage)\n\t\tif err != nil {\n\t\t\tdebugPrint(\"cannot write message to writer during serve error: %v\", err)\n\t\t}\n\t\treturn\n\t}\n\tc.writermem.WriteHeaderNow()\n}\n\nfunc redirectTrailingSlash(c *Context) {\n\treq := c.Request\n\tp := req.URL.Path\n\tif prefix := path.Clean(c.Request.Header.Get(\"X-Forwarded-Prefix\")); prefix != \".\" {\n\t\tprefix = regSafePrefix.ReplaceAllString(prefix, \"\")\n\t\tprefix = regRemoveRepeatedChar.ReplaceAllString(prefix, \"/\")\n\n\t\tp = prefix + \"/\" + req.URL.Path\n\t}\n\treq.URL.Path = p + \"/\"\n\tif length := len(p); length > 1 && p[length-1] == '/' {\n\t\treq.URL.Path = p[:length-1]\n\t}\n\tredirectRequest(c)\n}\n\nfunc redirectFixedPath(c *Context, root *node, trailingSlash bool) bool {\n\treq := c.Request\n\trPath := req.URL.Path\n\n\tif fixedPath, ok := root.findCaseInsensitivePath(cleanPath(rPath), trailingSlash); ok {\n\t\treq.URL.Path = bytesconv.BytesToString(fixedPath)\n\t\tredirectRequest(c)\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc redirectRequest(c *Context) {\n\treq := c.Request\n\trPath := req.URL.Path\n\trURL := req.URL.String()\n\n\tcode := http.StatusMovedPermanently // Permanent redirect, request with GET method\n\tif req.Method != http.MethodGet {\n\t\tcode = http.StatusTemporaryRedirect\n\t}\n\tdebugPrint(\"redirecting request %d: %s --> %s\", code, rPath, rURL)\n\thttp.Redirect(c.Writer, req, rURL, code)\n\tc.writermem.WriteHeaderNow()\n}\n"
        },
        {
          "name": "ginS",
          "type": "tree",
          "content": null
        },
        {
          "name": "gin_integration_test.go",
          "type": "blob",
          "size": 22.66015625,
          "content": "// Copyright 2017 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"bufio\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n// params[0]=url example:http://127.0.0.1:8080/index (cannot be empty)\n// params[1]=response status (custom compare status) default:\"200 OK\"\n// params[2]=response body (custom compare content)  default:\"it worked\"\nfunc testRequest(t *testing.T, params ...string) {\n\n\tif len(params) == 0 {\n\t\tt.Fatal(\"url cannot be empty\")\n\t}\n\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tInsecureSkipVerify: true,\n\t\t},\n\t}\n\tclient := &http.Client{Transport: tr}\n\n\tresp, err := client.Get(params[0])\n\trequire.NoError(t, err)\n\tdefer resp.Body.Close()\n\n\tbody, ioerr := io.ReadAll(resp.Body)\n\trequire.NoError(t, ioerr)\n\n\tvar responseStatus = \"200 OK\"\n\tif len(params) > 1 && params[1] != \"\" {\n\t\tresponseStatus = params[1]\n\t}\n\n\tvar responseBody = \"it worked\"\n\tif len(params) > 2 && params[2] != \"\" {\n\t\tresponseBody = params[2]\n\t}\n\n\tassert.Equal(t, responseStatus, resp.Status, \"should get a \"+responseStatus)\n\tif responseStatus == \"200 OK\" {\n\t\tassert.Equal(t, responseBody, string(body), \"resp body should match\")\n\t}\n}\n\nfunc TestRunEmpty(t *testing.T) {\n\tos.Setenv(\"PORT\", \"\")\n\trouter := New()\n\tgo func() {\n\t\trouter.GET(\"/example\", func(c *Context) { c.String(http.StatusOK, \"it worked\") })\n\t\tassert.NoError(t, router.Run())\n\t}()\n\t// have to wait for the goroutine to start and run the server\n\t// otherwise the main thread will complete\n\ttime.Sleep(5 * time.Millisecond)\n\n\trequire.Error(t, router.Run(\":8080\"))\n\ttestRequest(t, \"http://localhost:8080/example\")\n}\n\nfunc TestBadTrustedCIDRs(t *testing.T) {\n\trouter := New()\n\trequire.Error(t, router.SetTrustedProxies([]string{\"hello/world\"}))\n}\n\n/* legacy tests\nfunc TestBadTrustedCIDRsForRun(t *testing.T) {\n\tos.Setenv(\"PORT\", \"\")\n\trouter := New()\n\trouter.TrustedProxies = []string{\"hello/world\"}\n\trequire.Error(t, router.Run(\":8080\"))\n}\n\nfunc TestBadTrustedCIDRsForRunUnix(t *testing.T) {\n\trouter := New()\n\trouter.TrustedProxies = []string{\"hello/world\"}\n\n\tunixTestSocket := filepath.Join(os.TempDir(), \"unix_unit_test\")\n\n\tdefer os.Remove(unixTestSocket)\n\n\tgo func() {\n\t\trouter.GET(\"/example\", func(c *Context) { c.String(http.StatusOK, \"it worked\") })\n\t\trequire.Error(t, router.RunUnix(unixTestSocket))\n\t}()\n\t// have to wait for the goroutine to start and run the server\n\t// otherwise the main thread will complete\n\ttime.Sleep(5 * time.Millisecond)\n}\n\nfunc TestBadTrustedCIDRsForRunFd(t *testing.T) {\n\trouter := New()\n\trouter.TrustedProxies = []string{\"hello/world\"}\n\n\taddr, err := net.ResolveTCPAddr(\"tcp\", \"localhost:0\")\n\trequire.NoError(t, err)\n\tlistener, err := net.ListenTCP(\"tcp\", addr)\n\trequire.NoError(t, err)\n\tsocketFile, err := listener.File()\n\trequire.NoError(t, err)\n\n\tgo func() {\n\t\trouter.GET(\"/example\", func(c *Context) { c.String(http.StatusOK, \"it worked\") })\n\t\trequire.Error(t, router.RunFd(int(socketFile.Fd())))\n\t}()\n\t// have to wait for the goroutine to start and run the server\n\t// otherwise the main thread will complete\n\ttime.Sleep(5 * time.Millisecond)\n}\n\nfunc TestBadTrustedCIDRsForRunListener(t *testing.T) {\n\trouter := New()\n\trouter.TrustedProxies = []string{\"hello/world\"}\n\n\taddr, err := net.ResolveTCPAddr(\"tcp\", \"localhost:0\")\n\trequire.NoError(t, err)\n\tlistener, err := net.ListenTCP(\"tcp\", addr)\n\trequire.NoError(t, err)\n\tgo func() {\n\t\trouter.GET(\"/example\", func(c *Context) { c.String(http.StatusOK, \"it worked\") })\n\t\trequire.Error(t, router.RunListener(listener))\n\t}()\n\t// have to wait for the goroutine to start and run the server\n\t// otherwise the main thread will complete\n\ttime.Sleep(5 * time.Millisecond)\n}\n\nfunc TestBadTrustedCIDRsForRunTLS(t *testing.T) {\n\tos.Setenv(\"PORT\", \"\")\n\trouter := New()\n\trouter.TrustedProxies = []string{\"hello/world\"}\n\trequire.Error(t, router.RunTLS(\":8080\", \"./testdata/certificate/cert.pem\", \"./testdata/certificate/key.pem\"))\n}\n*/\n\nfunc TestRunTLS(t *testing.T) {\n\trouter := New()\n\tgo func() {\n\t\trouter.GET(\"/example\", func(c *Context) { c.String(http.StatusOK, \"it worked\") })\n\n\t\tassert.NoError(t, router.RunTLS(\":8443\", \"./testdata/certificate/cert.pem\", \"./testdata/certificate/key.pem\"))\n\t}()\n\n\t// have to wait for the goroutine to start and run the server\n\t// otherwise the main thread will complete\n\ttime.Sleep(5 * time.Millisecond)\n\n\trequire.Error(t, router.RunTLS(\":8443\", \"./testdata/certificate/cert.pem\", \"./testdata/certificate/key.pem\"))\n\ttestRequest(t, \"https://localhost:8443/example\")\n}\n\nfunc TestPusher(t *testing.T) {\n\tvar html = template.Must(template.New(\"https\").Parse(`\n<html>\n<head>\n  <title>Https Test</title>\n  <script src=\"/assets/app.js\"></script>\n</head>\n<body>\n  <h1 style=\"color:red;\">Welcome, Ginner!</h1>\n</body>\n</html>\n`))\n\n\trouter := New()\n\trouter.Static(\"./assets\", \"./assets\")\n\trouter.SetHTMLTemplate(html)\n\n\tgo func() {\n\t\trouter.GET(\"/pusher\", func(c *Context) {\n\t\t\tif pusher := c.Writer.Pusher(); pusher != nil {\n\t\t\t\terr := pusher.Push(\"/assets/app.js\", nil)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tc.String(http.StatusOK, \"it worked\")\n\t\t})\n\n\t\tassert.NoError(t, router.RunTLS(\":8449\", \"./testdata/certificate/cert.pem\", \"./testdata/certificate/key.pem\"))\n\t}()\n\n\t// have to wait for the goroutine to start and run the server\n\t// otherwise the main thread will complete\n\ttime.Sleep(5 * time.Millisecond)\n\n\trequire.Error(t, router.RunTLS(\":8449\", \"./testdata/certificate/cert.pem\", \"./testdata/certificate/key.pem\"))\n\ttestRequest(t, \"https://localhost:8449/pusher\")\n}\n\nfunc TestRunEmptyWithEnv(t *testing.T) {\n\tos.Setenv(\"PORT\", \"3123\")\n\trouter := New()\n\tgo func() {\n\t\trouter.GET(\"/example\", func(c *Context) { c.String(http.StatusOK, \"it worked\") })\n\t\tassert.NoError(t, router.Run())\n\t}()\n\t// have to wait for the goroutine to start and run the server\n\t// otherwise the main thread will complete\n\ttime.Sleep(5 * time.Millisecond)\n\n\trequire.Error(t, router.Run(\":3123\"))\n\ttestRequest(t, \"http://localhost:3123/example\")\n}\n\nfunc TestRunTooMuchParams(t *testing.T) {\n\trouter := New()\n\tassert.Panics(t, func() {\n\t\trequire.NoError(t, router.Run(\"2\", \"2\"))\n\t})\n}\n\nfunc TestRunWithPort(t *testing.T) {\n\trouter := New()\n\tgo func() {\n\t\trouter.GET(\"/example\", func(c *Context) { c.String(http.StatusOK, \"it worked\") })\n\t\tassert.NoError(t, router.Run(\":5150\"))\n\t}()\n\t// have to wait for the goroutine to start and run the server\n\t// otherwise the main thread will complete\n\ttime.Sleep(5 * time.Millisecond)\n\n\trequire.Error(t, router.Run(\":5150\"))\n\ttestRequest(t, \"http://localhost:5150/example\")\n}\n\nfunc TestUnixSocket(t *testing.T) {\n\trouter := New()\n\n\tunixTestSocket := filepath.Join(os.TempDir(), \"unix_unit_test\")\n\n\tdefer os.Remove(unixTestSocket)\n\n\tgo func() {\n\t\trouter.GET(\"/example\", func(c *Context) { c.String(http.StatusOK, \"it worked\") })\n\t\tassert.NoError(t, router.RunUnix(unixTestSocket))\n\t}()\n\t// have to wait for the goroutine to start and run the server\n\t// otherwise the main thread will complete\n\ttime.Sleep(5 * time.Millisecond)\n\n\tc, err := net.Dial(\"unix\", unixTestSocket)\n\trequire.NoError(t, err)\n\n\tfmt.Fprint(c, \"GET /example HTTP/1.0\\r\\n\\r\\n\")\n\tscanner := bufio.NewScanner(c)\n\tvar response string\n\tfor scanner.Scan() {\n\t\tresponse += scanner.Text()\n\t}\n\tassert.Contains(t, response, \"HTTP/1.0 200\", \"should get a 200\")\n\tassert.Contains(t, response, \"it worked\", \"resp body should match\")\n}\n\nfunc TestBadUnixSocket(t *testing.T) {\n\trouter := New()\n\trequire.Error(t, router.RunUnix(\"#/tmp/unix_unit_test\"))\n}\n\nfunc TestRunQUIC(t *testing.T) {\n\trouter := New()\n\tgo func() {\n\t\trouter.GET(\"/example\", func(c *Context) { c.String(http.StatusOK, \"it worked\") })\n\n\t\tassert.NoError(t, router.RunQUIC(\":8443\", \"./testdata/certificate/cert.pem\", \"./testdata/certificate/key.pem\"))\n\t}()\n\n\t// have to wait for the goroutine to start and run the server\n\t// otherwise the main thread will complete\n\ttime.Sleep(5 * time.Millisecond)\n\n\trequire.Error(t, router.RunQUIC(\":8443\", \"./testdata/certificate/cert.pem\", \"./testdata/certificate/key.pem\"))\n\ttestRequest(t, \"https://localhost:8443/example\")\n}\n\nfunc TestFileDescriptor(t *testing.T) {\n\trouter := New()\n\n\taddr, err := net.ResolveTCPAddr(\"tcp\", \"localhost:0\")\n\trequire.NoError(t, err)\n\tlistener, err := net.ListenTCP(\"tcp\", addr)\n\trequire.NoError(t, err)\n\tsocketFile, err := listener.File()\n\tif isWindows() {\n\t\t// not supported by windows, it is unimplemented now\n\t\trequire.Error(t, err)\n\t} else {\n\t\trequire.NoError(t, err)\n\t}\n\n\tif socketFile == nil {\n\t\treturn\n\t}\n\n\tgo func() {\n\t\trouter.GET(\"/example\", func(c *Context) { c.String(http.StatusOK, \"it worked\") })\n\t\tassert.NoError(t, router.RunFd(int(socketFile.Fd())))\n\t}()\n\t// have to wait for the goroutine to start and run the server\n\t// otherwise the main thread will complete\n\ttime.Sleep(5 * time.Millisecond)\n\n\tc, err := net.Dial(\"tcp\", listener.Addr().String())\n\trequire.NoError(t, err)\n\n\tfmt.Fprintf(c, \"GET /example HTTP/1.0\\r\\n\\r\\n\")\n\tscanner := bufio.NewScanner(c)\n\tvar response string\n\tfor scanner.Scan() {\n\t\tresponse += scanner.Text()\n\t}\n\tassert.Contains(t, response, \"HTTP/1.0 200\", \"should get a 200\")\n\tassert.Contains(t, response, \"it worked\", \"resp body should match\")\n}\n\nfunc TestBadFileDescriptor(t *testing.T) {\n\trouter := New()\n\trequire.Error(t, router.RunFd(0))\n}\n\nfunc TestListener(t *testing.T) {\n\trouter := New()\n\taddr, err := net.ResolveTCPAddr(\"tcp\", \"localhost:0\")\n\trequire.NoError(t, err)\n\tlistener, err := net.ListenTCP(\"tcp\", addr)\n\trequire.NoError(t, err)\n\tgo func() {\n\t\trouter.GET(\"/example\", func(c *Context) { c.String(http.StatusOK, \"it worked\") })\n\t\tassert.NoError(t, router.RunListener(listener))\n\t}()\n\t// have to wait for the goroutine to start and run the server\n\t// otherwise the main thread will complete\n\ttime.Sleep(5 * time.Millisecond)\n\n\tc, err := net.Dial(\"tcp\", listener.Addr().String())\n\trequire.NoError(t, err)\n\n\tfmt.Fprintf(c, \"GET /example HTTP/1.0\\r\\n\\r\\n\")\n\tscanner := bufio.NewScanner(c)\n\tvar response string\n\tfor scanner.Scan() {\n\t\tresponse += scanner.Text()\n\t}\n\tassert.Contains(t, response, \"HTTP/1.0 200\", \"should get a 200\")\n\tassert.Contains(t, response, \"it worked\", \"resp body should match\")\n}\n\nfunc TestBadListener(t *testing.T) {\n\trouter := New()\n\taddr, err := net.ResolveTCPAddr(\"tcp\", \"localhost:10086\")\n\trequire.NoError(t, err)\n\tlistener, err := net.ListenTCP(\"tcp\", addr)\n\trequire.NoError(t, err)\n\tlistener.Close()\n\trequire.Error(t, router.RunListener(listener))\n}\n\nfunc TestWithHttptestWithAutoSelectedPort(t *testing.T) {\n\trouter := New()\n\trouter.GET(\"/example\", func(c *Context) { c.String(http.StatusOK, \"it worked\") })\n\n\tts := httptest.NewServer(router)\n\tdefer ts.Close()\n\n\ttestRequest(t, ts.URL+\"/example\")\n}\n\nfunc TestConcurrentHandleContext(t *testing.T) {\n\trouter := New()\n\trouter.GET(\"/\", func(c *Context) {\n\t\tc.Request.URL.Path = \"/example\"\n\t\trouter.HandleContext(c)\n\t})\n\trouter.GET(\"/example\", func(c *Context) { c.String(http.StatusOK, \"it worked\") })\n\n\tvar wg sync.WaitGroup\n\titerations := 200\n\twg.Add(iterations)\n\tfor i := 0; i < iterations; i++ {\n\t\tgo func() {\n\t\t\treq, err := http.NewRequest(http.MethodGet, \"/\", nil)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tw := httptest.NewRecorder()\n\t\t\trouter.ServeHTTP(w, req)\n\n\t\t\tassert.Equal(t, \"it worked\", w.Body.String(), \"resp body should match\")\n\t\t\tassert.Equal(t, 200, w.Code, \"should get a 200\")\n\t\t\twg.Done()\n\t\t}()\n\t}\n\twg.Wait()\n}\n\n// func TestWithHttptestWithSpecifiedPort(t *testing.T) {\n// \trouter := New()\n// \trouter.GET(\"/example\", func(c *Context) { c.String(http.StatusOK, \"it worked\") })\n\n// \tl, _ := net.Listen(\"tcp\", \":8033\")\n// \tts := httptest.Server{\n// \t\tListener: l,\n// \t\tConfig:   &http.Server{Handler: router},\n// \t}\n// \tts.Start()\n// \tdefer ts.Close()\n\n// \ttestRequest(t, \"http://localhost:8033/example\")\n// }\n\nfunc TestTreeRunDynamicRouting(t *testing.T) {\n\trouter := New()\n\trouter.GET(\"/aa/*xx\", func(c *Context) { c.String(http.StatusOK, \"/aa/*xx\") })\n\trouter.GET(\"/ab/*xx\", func(c *Context) { c.String(http.StatusOK, \"/ab/*xx\") })\n\trouter.GET(\"/\", func(c *Context) { c.String(http.StatusOK, \"home\") })\n\trouter.GET(\"/:cc\", func(c *Context) { c.String(http.StatusOK, \"/:cc\") })\n\trouter.GET(\"/c1/:dd/e\", func(c *Context) { c.String(http.StatusOK, \"/c1/:dd/e\") })\n\trouter.GET(\"/c1/:dd/e1\", func(c *Context) { c.String(http.StatusOK, \"/c1/:dd/e1\") })\n\trouter.GET(\"/c1/:dd/f1\", func(c *Context) { c.String(http.StatusOK, \"/c1/:dd/f1\") })\n\trouter.GET(\"/c1/:dd/f2\", func(c *Context) { c.String(http.StatusOK, \"/c1/:dd/f2\") })\n\trouter.GET(\"/:cc/cc\", func(c *Context) { c.String(http.StatusOK, \"/:cc/cc\") })\n\trouter.GET(\"/:cc/:dd/ee\", func(c *Context) { c.String(http.StatusOK, \"/:cc/:dd/ee\") })\n\trouter.GET(\"/:cc/:dd/f\", func(c *Context) { c.String(http.StatusOK, \"/:cc/:dd/f\") })\n\trouter.GET(\"/:cc/:dd/:ee/ff\", func(c *Context) { c.String(http.StatusOK, \"/:cc/:dd/:ee/ff\") })\n\trouter.GET(\"/:cc/:dd/:ee/:ff/gg\", func(c *Context) { c.String(http.StatusOK, \"/:cc/:dd/:ee/:ff/gg\") })\n\trouter.GET(\"/:cc/:dd/:ee/:ff/:gg/hh\", func(c *Context) { c.String(http.StatusOK, \"/:cc/:dd/:ee/:ff/:gg/hh\") })\n\trouter.GET(\"/get/test/abc/\", func(c *Context) { c.String(http.StatusOK, \"/get/test/abc/\") })\n\trouter.GET(\"/get/:param/abc/\", func(c *Context) { c.String(http.StatusOK, \"/get/:param/abc/\") })\n\trouter.GET(\"/something/:paramname/thirdthing\", func(c *Context) { c.String(http.StatusOK, \"/something/:paramname/thirdthing\") })\n\trouter.GET(\"/something/secondthing/test\", func(c *Context) { c.String(http.StatusOK, \"/something/secondthing/test\") })\n\trouter.GET(\"/get/abc\", func(c *Context) { c.String(http.StatusOK, \"/get/abc\") })\n\trouter.GET(\"/get/:param\", func(c *Context) { c.String(http.StatusOK, \"/get/:param\") })\n\trouter.GET(\"/get/abc/123abc\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/123abc\") })\n\trouter.GET(\"/get/abc/:param\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/:param\") })\n\trouter.GET(\"/get/abc/123abc/xxx8\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/123abc/xxx8\") })\n\trouter.GET(\"/get/abc/123abc/:param\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/123abc/:param\") })\n\trouter.GET(\"/get/abc/123abc/xxx8/1234\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/123abc/xxx8/1234\") })\n\trouter.GET(\"/get/abc/123abc/xxx8/:param\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/123abc/xxx8/:param\") })\n\trouter.GET(\"/get/abc/123abc/xxx8/1234/ffas\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/123abc/xxx8/1234/ffas\") })\n\trouter.GET(\"/get/abc/123abc/xxx8/1234/:param\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/123abc/xxx8/1234/:param\") })\n\trouter.GET(\"/get/abc/123abc/xxx8/1234/kkdd/12c\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/123abc/xxx8/1234/kkdd/12c\") })\n\trouter.GET(\"/get/abc/123abc/xxx8/1234/kkdd/:param\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/123abc/xxx8/1234/kkdd/:param\") })\n\trouter.GET(\"/get/abc/:param/test\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/:param/test\") })\n\trouter.GET(\"/get/abc/123abd/:param\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/123abd/:param\") })\n\trouter.GET(\"/get/abc/123abddd/:param\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/123abddd/:param\") })\n\trouter.GET(\"/get/abc/123/:param\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/123/:param\") })\n\trouter.GET(\"/get/abc/123abg/:param\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/123abg/:param\") })\n\trouter.GET(\"/get/abc/123abf/:param\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/123abf/:param\") })\n\trouter.GET(\"/get/abc/123abfff/:param\", func(c *Context) { c.String(http.StatusOK, \"/get/abc/123abfff/:param\") })\n\n\tts := httptest.NewServer(router)\n\tdefer ts.Close()\n\n\ttestRequest(t, ts.URL+\"/\", \"\", \"home\")\n\ttestRequest(t, ts.URL+\"/aa/aa\", \"\", \"/aa/*xx\")\n\ttestRequest(t, ts.URL+\"/ab/ab\", \"\", \"/ab/*xx\")\n\ttestRequest(t, ts.URL+\"/all\", \"\", \"/:cc\")\n\ttestRequest(t, ts.URL+\"/all/cc\", \"\", \"/:cc/cc\")\n\ttestRequest(t, ts.URL+\"/a/cc\", \"\", \"/:cc/cc\")\n\ttestRequest(t, ts.URL+\"/c1/d/e\", \"\", \"/c1/:dd/e\")\n\ttestRequest(t, ts.URL+\"/c1/d/e1\", \"\", \"/c1/:dd/e1\")\n\ttestRequest(t, ts.URL+\"/c1/d/ee\", \"\", \"/:cc/:dd/ee\")\n\ttestRequest(t, ts.URL+\"/c1/d/f\", \"\", \"/:cc/:dd/f\")\n\ttestRequest(t, ts.URL+\"/c/d/ee\", \"\", \"/:cc/:dd/ee\")\n\ttestRequest(t, ts.URL+\"/c/d/e/ff\", \"\", \"/:cc/:dd/:ee/ff\")\n\ttestRequest(t, ts.URL+\"/c/d/e/f/gg\", \"\", \"/:cc/:dd/:ee/:ff/gg\")\n\ttestRequest(t, ts.URL+\"/c/d/e/f/g/hh\", \"\", \"/:cc/:dd/:ee/:ff/:gg/hh\")\n\ttestRequest(t, ts.URL+\"/cc/dd/ee/ff/gg/hh\", \"\", \"/:cc/:dd/:ee/:ff/:gg/hh\")\n\ttestRequest(t, ts.URL+\"/a\", \"\", \"/:cc\")\n\ttestRequest(t, ts.URL+\"/d\", \"\", \"/:cc\")\n\ttestRequest(t, ts.URL+\"/ad\", \"\", \"/:cc\")\n\ttestRequest(t, ts.URL+\"/dd\", \"\", \"/:cc\")\n\ttestRequest(t, ts.URL+\"/aa\", \"\", \"/:cc\")\n\ttestRequest(t, ts.URL+\"/aaa\", \"\", \"/:cc\")\n\ttestRequest(t, ts.URL+\"/aaa/cc\", \"\", \"/:cc/cc\")\n\ttestRequest(t, ts.URL+\"/ab\", \"\", \"/:cc\")\n\ttestRequest(t, ts.URL+\"/abb\", \"\", \"/:cc\")\n\ttestRequest(t, ts.URL+\"/abb/cc\", \"\", \"/:cc/cc\")\n\ttestRequest(t, ts.URL+\"/dddaa\", \"\", \"/:cc\")\n\ttestRequest(t, ts.URL+\"/allxxxx\", \"\", \"/:cc\")\n\ttestRequest(t, ts.URL+\"/alldd\", \"\", \"/:cc\")\n\ttestRequest(t, ts.URL+\"/cc/cc\", \"\", \"/:cc/cc\")\n\ttestRequest(t, ts.URL+\"/ccc/cc\", \"\", \"/:cc/cc\")\n\ttestRequest(t, ts.URL+\"/deedwjfs/cc\", \"\", \"/:cc/cc\")\n\ttestRequest(t, ts.URL+\"/acllcc/cc\", \"\", \"/:cc/cc\")\n\ttestRequest(t, ts.URL+\"/get/test/abc/\", \"\", \"/get/test/abc/\")\n\ttestRequest(t, ts.URL+\"/get/testaa/abc/\", \"\", \"/get/:param/abc/\")\n\ttestRequest(t, ts.URL+\"/get/te/abc/\", \"\", \"/get/:param/abc/\")\n\ttestRequest(t, ts.URL+\"/get/xx/abc/\", \"\", \"/get/:param/abc/\")\n\ttestRequest(t, ts.URL+\"/get/tt/abc/\", \"\", \"/get/:param/abc/\")\n\ttestRequest(t, ts.URL+\"/get/a/abc/\", \"\", \"/get/:param/abc/\")\n\ttestRequest(t, ts.URL+\"/get/t/abc/\", \"\", \"/get/:param/abc/\")\n\ttestRequest(t, ts.URL+\"/get/aa/abc/\", \"\", \"/get/:param/abc/\")\n\ttestRequest(t, ts.URL+\"/get/abas/abc/\", \"\", \"/get/:param/abc/\")\n\ttestRequest(t, ts.URL+\"/something/secondthing/test\", \"\", \"/something/secondthing/test\")\n\ttestRequest(t, ts.URL+\"/something/secondthingaaaa/thirdthing\", \"\", \"/something/:paramname/thirdthing\")\n\ttestRequest(t, ts.URL+\"/something/abcdad/thirdthing\", \"\", \"/something/:paramname/thirdthing\")\n\ttestRequest(t, ts.URL+\"/something/se/thirdthing\", \"\", \"/something/:paramname/thirdthing\")\n\ttestRequest(t, ts.URL+\"/something/s/thirdthing\", \"\", \"/something/:paramname/thirdthing\")\n\ttestRequest(t, ts.URL+\"/something/secondthing/thirdthing\", \"\", \"/something/:paramname/thirdthing\")\n\ttestRequest(t, ts.URL+\"/get/abc\", \"\", \"/get/abc\")\n\ttestRequest(t, ts.URL+\"/get/a\", \"\", \"/get/:param\")\n\ttestRequest(t, ts.URL+\"/get/abz\", \"\", \"/get/:param\")\n\ttestRequest(t, ts.URL+\"/get/12a\", \"\", \"/get/:param\")\n\ttestRequest(t, ts.URL+\"/get/abcd\", \"\", \"/get/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc\", \"\", \"/get/abc/123abc\")\n\ttestRequest(t, ts.URL+\"/get/abc/12\", \"\", \"/get/abc/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123ab\", \"\", \"/get/abc/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/xyz\", \"\", \"/get/abc/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abcddxx\", \"\", \"/get/abc/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8\", \"\", \"/get/abc/123abc/xxx8\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/x\", \"\", \"/get/abc/123abc/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx\", \"\", \"/get/abc/123abc/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/abc\", \"\", \"/get/abc/123abc/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8xxas\", \"\", \"/get/abc/123abc/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/1234\", \"\", \"/get/abc/123abc/xxx8/1234\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/1\", \"\", \"/get/abc/123abc/xxx8/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/123\", \"\", \"/get/abc/123abc/xxx8/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/78k\", \"\", \"/get/abc/123abc/xxx8/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/1234xxxd\", \"\", \"/get/abc/123abc/xxx8/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/1234/ffas\", \"\", \"/get/abc/123abc/xxx8/1234/ffas\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/1234/f\", \"\", \"/get/abc/123abc/xxx8/1234/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/1234/ffa\", \"\", \"/get/abc/123abc/xxx8/1234/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/1234/kka\", \"\", \"/get/abc/123abc/xxx8/1234/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/1234/ffas321\", \"\", \"/get/abc/123abc/xxx8/1234/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/1234/kkdd/12c\", \"\", \"/get/abc/123abc/xxx8/1234/kkdd/12c\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/1234/kkdd/1\", \"\", \"/get/abc/123abc/xxx8/1234/kkdd/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/1234/kkdd/12\", \"\", \"/get/abc/123abc/xxx8/1234/kkdd/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/1234/kkdd/12b\", \"\", \"/get/abc/123abc/xxx8/1234/kkdd/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/1234/kkdd/34\", \"\", \"/get/abc/123abc/xxx8/1234/kkdd/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abc/xxx8/1234/kkdd/12c2e3\", \"\", \"/get/abc/123abc/xxx8/1234/kkdd/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/12/test\", \"\", \"/get/abc/:param/test\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abdd/test\", \"\", \"/get/abc/:param/test\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abdddf/test\", \"\", \"/get/abc/:param/test\")\n\ttestRequest(t, ts.URL+\"/get/abc/123ab/test\", \"\", \"/get/abc/:param/test\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abgg/test\", \"\", \"/get/abc/:param/test\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abff/test\", \"\", \"/get/abc/:param/test\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abffff/test\", \"\", \"/get/abc/:param/test\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abd/test\", \"\", \"/get/abc/123abd/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abddd/test\", \"\", \"/get/abc/123abddd/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123/test22\", \"\", \"/get/abc/123/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abg/test\", \"\", \"/get/abc/123abg/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abf/testss\", \"\", \"/get/abc/123abf/:param\")\n\ttestRequest(t, ts.URL+\"/get/abc/123abfff/te\", \"\", \"/get/abc/123abfff/:param\")\n\t// 404 not found\n\ttestRequest(t, ts.URL+\"/c/d/e\", \"404 Not Found\")\n\ttestRequest(t, ts.URL+\"/c/d/e1\", \"404 Not Found\")\n\ttestRequest(t, ts.URL+\"/c/d/eee\", \"404 Not Found\")\n\ttestRequest(t, ts.URL+\"/c1/d/eee\", \"404 Not Found\")\n\ttestRequest(t, ts.URL+\"/c1/d/e2\", \"404 Not Found\")\n\ttestRequest(t, ts.URL+\"/cc/dd/ee/ff/gg/hh1\", \"404 Not Found\")\n\ttestRequest(t, ts.URL+\"/a/dd\", \"404 Not Found\")\n\ttestRequest(t, ts.URL+\"/addr/dd/aa\", \"404 Not Found\")\n\ttestRequest(t, ts.URL+\"/something/secondthing/121\", \"404 Not Found\")\n}\n\nfunc isWindows() bool {\n\treturn runtime.GOOS == \"windows\"\n}\n\nfunc TestEscapedColon(t *testing.T) {\n\trouter := New()\n\tf := func(u string) {\n\t\trouter.GET(u, func(c *Context) { c.String(http.StatusOK, u) })\n\t}\n\tf(\"/r/r\\\\:r\")\n\tf(\"/r/r:r\")\n\tf(\"/r/r/:r\")\n\tf(\"/r/r/\\\\:r\")\n\tf(\"/r/r/r\\\\:r\")\n\tassert.Panics(t, func() {\n\t\tf(\"\\\\foo:\")\n\t})\n\n\trouter.updateRouteTrees()\n\tts := httptest.NewServer(router)\n\tdefer ts.Close()\n\n\ttestRequest(t, ts.URL+\"/r/r123\", \"\", \"/r/r:r\")\n\ttestRequest(t, ts.URL+\"/r/r:r\", \"\", \"/r/r\\\\:r\")\n\ttestRequest(t, ts.URL+\"/r/r/r123\", \"\", \"/r/r/:r\")\n\ttestRequest(t, ts.URL+\"/r/r/:r\", \"\", \"/r/r/\\\\:r\")\n\ttestRequest(t, ts.URL+\"/r/r/r:r\", \"\", \"/r/r/r\\\\:r\")\n}\n"
        },
        {
          "name": "gin_test.go",
          "type": "blob",
          "size": 18.072265625,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/net/http2\"\n)\n\nfunc formatAsDate(t time.Time) string {\n\tyear, month, day := t.Date()\n\treturn fmt.Sprintf(\"%d/%02d/%02d\", year, month, day)\n}\n\nfunc setupHTMLFiles(t *testing.T, mode string, tls bool, loadMethod func(*Engine)) *httptest.Server {\n\tSetMode(mode)\n\tdefer SetMode(TestMode)\n\n\tvar router *Engine\n\tcaptureOutput(t, func() {\n\t\trouter = New()\n\t\trouter.Delims(\"{[{\", \"}]}\")\n\t\trouter.SetFuncMap(template.FuncMap{\n\t\t\t\"formatAsDate\": formatAsDate,\n\t\t})\n\t\tloadMethod(router)\n\t\trouter.GET(\"/test\", func(c *Context) {\n\t\t\tc.HTML(http.StatusOK, \"hello.tmpl\", map[string]string{\"name\": \"world\"})\n\t\t})\n\t\trouter.GET(\"/raw\", func(c *Context) {\n\t\t\tc.HTML(http.StatusOK, \"raw.tmpl\", map[string]any{\n\t\t\t\t\"now\": time.Date(2017, 07, 01, 0, 0, 0, 0, time.UTC),\n\t\t\t})\n\t\t})\n\t})\n\n\tvar ts *httptest.Server\n\n\tif tls {\n\t\tts = httptest.NewTLSServer(router)\n\t} else {\n\t\tts = httptest.NewServer(router)\n\t}\n\n\treturn ts\n}\n\nfunc TestLoadHTMLGlobDebugMode(t *testing.T) {\n\tts := setupHTMLFiles(\n\t\tt,\n\t\tDebugMode,\n\t\tfalse,\n\t\tfunc(router *Engine) {\n\t\t\trouter.LoadHTMLGlob(\"./testdata/template/*\")\n\t\t},\n\t)\n\tdefer ts.Close()\n\n\tres, err := http.Get(ts.URL + \"/test\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tresp, _ := io.ReadAll(res.Body)\n\tassert.Equal(t, \"<h1>Hello world</h1>\", string(resp))\n}\n\nfunc TestH2c(t *testing.T) {\n\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tr := Default()\n\tr.UseH2C = true\n\tr.GET(\"/\", func(c *Context) {\n\t\tc.String(200, \"<h1>Hello world</h1>\")\n\t})\n\tgo func() {\n\t\terr := http.Serve(ln, r.Handler())\n\t\tif err != nil {\n\t\t\tt.Log(err)\n\t\t}\n\t}()\n\tdefer ln.Close()\n\n\turl := \"http://\" + ln.Addr().String() + \"/\"\n\n\thttpClient := http.Client{\n\t\tTransport: &http2.Transport{\n\t\t\tAllowHTTP: true,\n\t\t\tDialTLS: func(netw, addr string, cfg *tls.Config) (net.Conn, error) {\n\t\t\t\treturn net.Dial(netw, addr)\n\t\t\t},\n\t\t},\n\t}\n\n\tres, err := httpClient.Get(url)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tresp, _ := io.ReadAll(res.Body)\n\tassert.Equal(t, \"<h1>Hello world</h1>\", string(resp))\n}\n\nfunc TestLoadHTMLGlobTestMode(t *testing.T) {\n\tts := setupHTMLFiles(\n\t\tt,\n\t\tTestMode,\n\t\tfalse,\n\t\tfunc(router *Engine) {\n\t\t\trouter.LoadHTMLGlob(\"./testdata/template/*\")\n\t\t},\n\t)\n\tdefer ts.Close()\n\n\tres, err := http.Get(ts.URL + \"/test\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tresp, _ := io.ReadAll(res.Body)\n\tassert.Equal(t, \"<h1>Hello world</h1>\", string(resp))\n}\n\nfunc TestLoadHTMLGlobReleaseMode(t *testing.T) {\n\tts := setupHTMLFiles(\n\t\tt,\n\t\tReleaseMode,\n\t\tfalse,\n\t\tfunc(router *Engine) {\n\t\t\trouter.LoadHTMLGlob(\"./testdata/template/*\")\n\t\t},\n\t)\n\tdefer ts.Close()\n\n\tres, err := http.Get(ts.URL + \"/test\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tresp, _ := io.ReadAll(res.Body)\n\tassert.Equal(t, \"<h1>Hello world</h1>\", string(resp))\n}\n\nfunc TestLoadHTMLGlobUsingTLS(t *testing.T) {\n\tts := setupHTMLFiles(\n\t\tt,\n\t\tDebugMode,\n\t\ttrue,\n\t\tfunc(router *Engine) {\n\t\t\trouter.LoadHTMLGlob(\"./testdata/template/*\")\n\t\t},\n\t)\n\tdefer ts.Close()\n\n\t// Use InsecureSkipVerify for avoiding `x509: certificate signed by unknown authority` error\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tInsecureSkipVerify: true,\n\t\t},\n\t}\n\tclient := &http.Client{Transport: tr}\n\tres, err := client.Get(ts.URL + \"/test\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tresp, _ := io.ReadAll(res.Body)\n\tassert.Equal(t, \"<h1>Hello world</h1>\", string(resp))\n}\n\nfunc TestLoadHTMLGlobFromFuncMap(t *testing.T) {\n\tts := setupHTMLFiles(\n\t\tt,\n\t\tDebugMode,\n\t\tfalse,\n\t\tfunc(router *Engine) {\n\t\t\trouter.LoadHTMLGlob(\"./testdata/template/*\")\n\t\t},\n\t)\n\tdefer ts.Close()\n\n\tres, err := http.Get(ts.URL + \"/raw\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tresp, _ := io.ReadAll(res.Body)\n\tassert.Equal(t, \"Date: 2017/07/01\", string(resp))\n}\n\nfunc init() {\n\tSetMode(TestMode)\n}\n\nfunc TestCreateEngine(t *testing.T) {\n\trouter := New()\n\tassert.Equal(t, \"/\", router.basePath)\n\tassert.Equal(t, router.engine, router)\n\tassert.Empty(t, router.Handlers)\n}\n\nfunc TestLoadHTMLFilesTestMode(t *testing.T) {\n\tts := setupHTMLFiles(\n\t\tt,\n\t\tTestMode,\n\t\tfalse,\n\t\tfunc(router *Engine) {\n\t\t\trouter.LoadHTMLFiles(\"./testdata/template/hello.tmpl\", \"./testdata/template/raw.tmpl\")\n\t\t},\n\t)\n\tdefer ts.Close()\n\n\tres, err := http.Get(ts.URL + \"/test\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tresp, _ := io.ReadAll(res.Body)\n\tassert.Equal(t, \"<h1>Hello world</h1>\", string(resp))\n}\n\nfunc TestLoadHTMLFilesDebugMode(t *testing.T) {\n\tts := setupHTMLFiles(\n\t\tt,\n\t\tDebugMode,\n\t\tfalse,\n\t\tfunc(router *Engine) {\n\t\t\trouter.LoadHTMLFiles(\"./testdata/template/hello.tmpl\", \"./testdata/template/raw.tmpl\")\n\t\t},\n\t)\n\tdefer ts.Close()\n\n\tres, err := http.Get(ts.URL + \"/test\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tresp, _ := io.ReadAll(res.Body)\n\tassert.Equal(t, \"<h1>Hello world</h1>\", string(resp))\n}\n\nfunc TestLoadHTMLFilesReleaseMode(t *testing.T) {\n\tts := setupHTMLFiles(\n\t\tt,\n\t\tReleaseMode,\n\t\tfalse,\n\t\tfunc(router *Engine) {\n\t\t\trouter.LoadHTMLFiles(\"./testdata/template/hello.tmpl\", \"./testdata/template/raw.tmpl\")\n\t\t},\n\t)\n\tdefer ts.Close()\n\n\tres, err := http.Get(ts.URL + \"/test\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tresp, _ := io.ReadAll(res.Body)\n\tassert.Equal(t, \"<h1>Hello world</h1>\", string(resp))\n}\n\nfunc TestLoadHTMLFilesUsingTLS(t *testing.T) {\n\tts := setupHTMLFiles(\n\t\tt,\n\t\tTestMode,\n\t\ttrue,\n\t\tfunc(router *Engine) {\n\t\t\trouter.LoadHTMLFiles(\"./testdata/template/hello.tmpl\", \"./testdata/template/raw.tmpl\")\n\t\t},\n\t)\n\tdefer ts.Close()\n\n\t// Use InsecureSkipVerify for avoiding `x509: certificate signed by unknown authority` error\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{\n\t\t\tInsecureSkipVerify: true,\n\t\t},\n\t}\n\tclient := &http.Client{Transport: tr}\n\tres, err := client.Get(ts.URL + \"/test\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tresp, _ := io.ReadAll(res.Body)\n\tassert.Equal(t, \"<h1>Hello world</h1>\", string(resp))\n}\n\nfunc TestLoadHTMLFilesFuncMap(t *testing.T) {\n\tts := setupHTMLFiles(\n\t\tt,\n\t\tTestMode,\n\t\tfalse,\n\t\tfunc(router *Engine) {\n\t\t\trouter.LoadHTMLFiles(\"./testdata/template/hello.tmpl\", \"./testdata/template/raw.tmpl\")\n\t\t},\n\t)\n\tdefer ts.Close()\n\n\tres, err := http.Get(ts.URL + \"/raw\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tresp, _ := io.ReadAll(res.Body)\n\tassert.Equal(t, \"Date: 2017/07/01\", string(resp))\n}\n\nfunc TestAddRoute(t *testing.T) {\n\trouter := New()\n\trouter.addRoute(http.MethodGet, \"/\", HandlersChain{func(_ *Context) {}})\n\n\tassert.Len(t, router.trees, 1)\n\tassert.NotNil(t, router.trees.get(http.MethodGet))\n\tassert.Nil(t, router.trees.get(http.MethodPost))\n\n\trouter.addRoute(http.MethodPost, \"/\", HandlersChain{func(_ *Context) {}})\n\n\tassert.Len(t, router.trees, 2)\n\tassert.NotNil(t, router.trees.get(http.MethodGet))\n\tassert.NotNil(t, router.trees.get(http.MethodPost))\n\n\trouter.addRoute(http.MethodPost, \"/post\", HandlersChain{func(_ *Context) {}})\n\tassert.Len(t, router.trees, 2)\n}\n\nfunc TestAddRouteFails(t *testing.T) {\n\trouter := New()\n\tassert.Panics(t, func() { router.addRoute(\"\", \"/\", HandlersChain{func(_ *Context) {}}) })\n\tassert.Panics(t, func() { router.addRoute(http.MethodGet, \"a\", HandlersChain{func(_ *Context) {}}) })\n\tassert.Panics(t, func() { router.addRoute(http.MethodGet, \"/\", HandlersChain{}) })\n\n\trouter.addRoute(http.MethodPost, \"/post\", HandlersChain{func(_ *Context) {}})\n\tassert.Panics(t, func() {\n\t\trouter.addRoute(http.MethodPost, \"/post\", HandlersChain{func(_ *Context) {}})\n\t})\n}\n\nfunc TestCreateDefaultRouter(t *testing.T) {\n\trouter := Default()\n\tassert.Len(t, router.Handlers, 2)\n}\n\nfunc TestNoRouteWithoutGlobalHandlers(t *testing.T) {\n\tvar middleware0 HandlerFunc = func(c *Context) {}\n\tvar middleware1 HandlerFunc = func(c *Context) {}\n\n\trouter := New()\n\n\trouter.NoRoute(middleware0)\n\tassert.Nil(t, router.Handlers)\n\tassert.Len(t, router.noRoute, 1)\n\tassert.Len(t, router.allNoRoute, 1)\n\tcompareFunc(t, router.noRoute[0], middleware0)\n\tcompareFunc(t, router.allNoRoute[0], middleware0)\n\n\trouter.NoRoute(middleware1, middleware0)\n\tassert.Len(t, router.noRoute, 2)\n\tassert.Len(t, router.allNoRoute, 2)\n\tcompareFunc(t, router.noRoute[0], middleware1)\n\tcompareFunc(t, router.allNoRoute[0], middleware1)\n\tcompareFunc(t, router.noRoute[1], middleware0)\n\tcompareFunc(t, router.allNoRoute[1], middleware0)\n}\n\nfunc TestNoRouteWithGlobalHandlers(t *testing.T) {\n\tvar middleware0 HandlerFunc = func(c *Context) {}\n\tvar middleware1 HandlerFunc = func(c *Context) {}\n\tvar middleware2 HandlerFunc = func(c *Context) {}\n\n\trouter := New()\n\trouter.Use(middleware2)\n\n\trouter.NoRoute(middleware0)\n\tassert.Len(t, router.allNoRoute, 2)\n\tassert.Len(t, router.Handlers, 1)\n\tassert.Len(t, router.noRoute, 1)\n\n\tcompareFunc(t, router.Handlers[0], middleware2)\n\tcompareFunc(t, router.noRoute[0], middleware0)\n\tcompareFunc(t, router.allNoRoute[0], middleware2)\n\tcompareFunc(t, router.allNoRoute[1], middleware0)\n\n\trouter.Use(middleware1)\n\tassert.Len(t, router.allNoRoute, 3)\n\tassert.Len(t, router.Handlers, 2)\n\tassert.Len(t, router.noRoute, 1)\n\n\tcompareFunc(t, router.Handlers[0], middleware2)\n\tcompareFunc(t, router.Handlers[1], middleware1)\n\tcompareFunc(t, router.noRoute[0], middleware0)\n\tcompareFunc(t, router.allNoRoute[0], middleware2)\n\tcompareFunc(t, router.allNoRoute[1], middleware1)\n\tcompareFunc(t, router.allNoRoute[2], middleware0)\n}\n\nfunc TestNoMethodWithoutGlobalHandlers(t *testing.T) {\n\tvar middleware0 HandlerFunc = func(c *Context) {}\n\tvar middleware1 HandlerFunc = func(c *Context) {}\n\n\trouter := New()\n\n\trouter.NoMethod(middleware0)\n\tassert.Empty(t, router.Handlers)\n\tassert.Len(t, router.noMethod, 1)\n\tassert.Len(t, router.allNoMethod, 1)\n\tcompareFunc(t, router.noMethod[0], middleware0)\n\tcompareFunc(t, router.allNoMethod[0], middleware0)\n\n\trouter.NoMethod(middleware1, middleware0)\n\tassert.Len(t, router.noMethod, 2)\n\tassert.Len(t, router.allNoMethod, 2)\n\tcompareFunc(t, router.noMethod[0], middleware1)\n\tcompareFunc(t, router.allNoMethod[0], middleware1)\n\tcompareFunc(t, router.noMethod[1], middleware0)\n\tcompareFunc(t, router.allNoMethod[1], middleware0)\n}\n\nfunc TestRebuild404Handlers(t *testing.T) {\n}\n\nfunc TestNoMethodWithGlobalHandlers(t *testing.T) {\n\tvar middleware0 HandlerFunc = func(c *Context) {}\n\tvar middleware1 HandlerFunc = func(c *Context) {}\n\tvar middleware2 HandlerFunc = func(c *Context) {}\n\n\trouter := New()\n\trouter.Use(middleware2)\n\n\trouter.NoMethod(middleware0)\n\tassert.Len(t, router.allNoMethod, 2)\n\tassert.Len(t, router.Handlers, 1)\n\tassert.Len(t, router.noMethod, 1)\n\n\tcompareFunc(t, router.Handlers[0], middleware2)\n\tcompareFunc(t, router.noMethod[0], middleware0)\n\tcompareFunc(t, router.allNoMethod[0], middleware2)\n\tcompareFunc(t, router.allNoMethod[1], middleware0)\n\n\trouter.Use(middleware1)\n\tassert.Len(t, router.allNoMethod, 3)\n\tassert.Len(t, router.Handlers, 2)\n\tassert.Len(t, router.noMethod, 1)\n\n\tcompareFunc(t, router.Handlers[0], middleware2)\n\tcompareFunc(t, router.Handlers[1], middleware1)\n\tcompareFunc(t, router.noMethod[0], middleware0)\n\tcompareFunc(t, router.allNoMethod[0], middleware2)\n\tcompareFunc(t, router.allNoMethod[1], middleware1)\n\tcompareFunc(t, router.allNoMethod[2], middleware0)\n}\n\nfunc compareFunc(t *testing.T, a, b any) {\n\tsf1 := reflect.ValueOf(a)\n\tsf2 := reflect.ValueOf(b)\n\tif sf1.Pointer() != sf2.Pointer() {\n\t\tt.Error(\"different functions\")\n\t}\n}\n\nfunc TestListOfRoutes(t *testing.T) {\n\trouter := New()\n\trouter.GET(\"/favicon.ico\", handlerTest1)\n\trouter.GET(\"/\", handlerTest1)\n\tgroup := router.Group(\"/users\")\n\t{\n\t\tgroup.GET(\"/\", handlerTest2)\n\t\tgroup.GET(\"/:id\", handlerTest1)\n\t\tgroup.POST(\"/:id\", handlerTest2)\n\t}\n\trouter.Static(\"/static\", \".\")\n\n\tlist := router.Routes()\n\n\tassert.Len(t, list, 7)\n\tassertRoutePresent(t, list, RouteInfo{\n\t\tMethod:  http.MethodGet,\n\t\tPath:    \"/favicon.ico\",\n\t\tHandler: \"^(.*/vendor/)?github.com/gin-gonic/gin.handlerTest1$\",\n\t})\n\tassertRoutePresent(t, list, RouteInfo{\n\t\tMethod:  http.MethodGet,\n\t\tPath:    \"/\",\n\t\tHandler: \"^(.*/vendor/)?github.com/gin-gonic/gin.handlerTest1$\",\n\t})\n\tassertRoutePresent(t, list, RouteInfo{\n\t\tMethod:  http.MethodGet,\n\t\tPath:    \"/users/\",\n\t\tHandler: \"^(.*/vendor/)?github.com/gin-gonic/gin.handlerTest2$\",\n\t})\n\tassertRoutePresent(t, list, RouteInfo{\n\t\tMethod:  http.MethodGet,\n\t\tPath:    \"/users/:id\",\n\t\tHandler: \"^(.*/vendor/)?github.com/gin-gonic/gin.handlerTest1$\",\n\t})\n\tassertRoutePresent(t, list, RouteInfo{\n\t\tMethod:  http.MethodPost,\n\t\tPath:    \"/users/:id\",\n\t\tHandler: \"^(.*/vendor/)?github.com/gin-gonic/gin.handlerTest2$\",\n\t})\n}\n\nfunc TestEngineHandleContext(t *testing.T) {\n\tr := New()\n\tr.GET(\"/\", func(c *Context) {\n\t\tc.Request.URL.Path = \"/v2\"\n\t\tr.HandleContext(c)\n\t})\n\tv2 := r.Group(\"/v2\")\n\t{\n\t\tv2.GET(\"/\", func(c *Context) {})\n\t}\n\n\tassert.NotPanics(t, func() {\n\t\tw := PerformRequest(r, http.MethodGet, \"/\")\n\t\tassert.Equal(t, 301, w.Code)\n\t})\n}\n\nfunc TestEngineHandleContextManyReEntries(t *testing.T) {\n\texpectValue := 10000\n\n\tvar handlerCounter, middlewareCounter int64\n\n\tr := New()\n\tr.Use(func(c *Context) {\n\t\tatomic.AddInt64(&middlewareCounter, 1)\n\t})\n\tr.GET(\"/:count\", func(c *Context) {\n\t\tcountStr := c.Param(\"count\")\n\t\tcount, err := strconv.Atoi(countStr)\n\t\trequire.NoError(t, err)\n\n\t\tn, err := c.Writer.Write([]byte(\".\"))\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, 1, n)\n\n\t\tswitch {\n\t\tcase count > 0:\n\t\t\tc.Request.URL.Path = \"/\" + strconv.Itoa(count-1)\n\t\t\tr.HandleContext(c)\n\t\t}\n\t}, func(c *Context) {\n\t\tatomic.AddInt64(&handlerCounter, 1)\n\t})\n\n\tassert.NotPanics(t, func() {\n\t\tw := PerformRequest(r, http.MethodGet, \"/\"+strconv.Itoa(expectValue-1)) // include 0 value\n\t\tassert.Equal(t, 200, w.Code)\n\t\tassert.Equal(t, expectValue, w.Body.Len())\n\t})\n\n\tassert.Equal(t, int64(expectValue), handlerCounter)\n\tassert.Equal(t, int64(expectValue), middlewareCounter)\n}\n\nfunc TestPrepareTrustedCIRDsWith(t *testing.T) {\n\tr := New()\n\n\t// valid ipv4 cidr\n\t{\n\t\texpectedTrustedCIDRs := []*net.IPNet{parseCIDR(\"0.0.0.0/0\")}\n\t\terr := r.SetTrustedProxies([]string{\"0.0.0.0/0\"})\n\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, expectedTrustedCIDRs, r.trustedCIDRs)\n\t}\n\n\t// invalid ipv4 cidr\n\t{\n\t\terr := r.SetTrustedProxies([]string{\"192.168.1.33/33\"})\n\n\t\trequire.Error(t, err)\n\t}\n\n\t// valid ipv4 address\n\t{\n\t\texpectedTrustedCIDRs := []*net.IPNet{parseCIDR(\"192.168.1.33/32\")}\n\n\t\terr := r.SetTrustedProxies([]string{\"192.168.1.33\"})\n\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, expectedTrustedCIDRs, r.trustedCIDRs)\n\t}\n\n\t// invalid ipv4 address\n\t{\n\t\terr := r.SetTrustedProxies([]string{\"192.168.1.256\"})\n\n\t\trequire.Error(t, err)\n\t}\n\n\t// valid ipv6 address\n\t{\n\t\texpectedTrustedCIDRs := []*net.IPNet{parseCIDR(\"2002:0000:0000:1234:abcd:ffff:c0a8:0101/128\")}\n\t\terr := r.SetTrustedProxies([]string{\"2002:0000:0000:1234:abcd:ffff:c0a8:0101\"})\n\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, expectedTrustedCIDRs, r.trustedCIDRs)\n\t}\n\n\t// invalid ipv6 address\n\t{\n\t\terr := r.SetTrustedProxies([]string{\"gggg:0000:0000:1234:abcd:ffff:c0a8:0101\"})\n\n\t\trequire.Error(t, err)\n\t}\n\n\t// valid ipv6 cidr\n\t{\n\t\texpectedTrustedCIDRs := []*net.IPNet{parseCIDR(\"::/0\")}\n\t\terr := r.SetTrustedProxies([]string{\"::/0\"})\n\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, expectedTrustedCIDRs, r.trustedCIDRs)\n\t}\n\n\t// invalid ipv6 cidr\n\t{\n\t\terr := r.SetTrustedProxies([]string{\"gggg:0000:0000:1234:abcd:ffff:c0a8:0101/129\"})\n\n\t\trequire.Error(t, err)\n\t}\n\n\t// valid combination\n\t{\n\t\texpectedTrustedCIDRs := []*net.IPNet{\n\t\t\tparseCIDR(\"::/0\"),\n\t\t\tparseCIDR(\"192.168.0.0/16\"),\n\t\t\tparseCIDR(\"172.16.0.1/32\"),\n\t\t}\n\t\terr := r.SetTrustedProxies([]string{\n\t\t\t\"::/0\",\n\t\t\t\"192.168.0.0/16\",\n\t\t\t\"172.16.0.1\",\n\t\t})\n\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, expectedTrustedCIDRs, r.trustedCIDRs)\n\t}\n\n\t// invalid combination\n\t{\n\t\terr := r.SetTrustedProxies([]string{\n\t\t\t\"::/0\",\n\t\t\t\"192.168.0.0/16\",\n\t\t\t\"172.16.0.256\",\n\t\t})\n\n\t\trequire.Error(t, err)\n\t}\n\n\t// nil value\n\t{\n\t\terr := r.SetTrustedProxies(nil)\n\n\t\tassert.Nil(t, r.trustedCIDRs)\n\t\trequire.NoError(t, err)\n\t}\n}\n\nfunc parseCIDR(cidr string) *net.IPNet {\n\t_, parsedCIDR, err := net.ParseCIDR(cidr)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\treturn parsedCIDR\n}\n\nfunc assertRoutePresent(t *testing.T, gotRoutes RoutesInfo, wantRoute RouteInfo) {\n\tfor _, gotRoute := range gotRoutes {\n\t\tif gotRoute.Path == wantRoute.Path && gotRoute.Method == wantRoute.Method {\n\t\t\tassert.Regexp(t, wantRoute.Handler, gotRoute.Handler)\n\t\t\treturn\n\t\t}\n\t}\n\tt.Errorf(\"route not found: %v\", wantRoute)\n}\n\nfunc handlerTest1(c *Context) {}\nfunc handlerTest2(c *Context) {}\n\nfunc TestNewOptionFunc(t *testing.T) {\n\tvar fc = func(e *Engine) {\n\t\te.GET(\"/test1\", handlerTest1)\n\t\te.GET(\"/test2\", handlerTest2)\n\n\t\te.Use(func(c *Context) {\n\t\t\tc.Next()\n\t\t})\n\t}\n\n\tr := New(fc)\n\n\troutes := r.Routes()\n\tassertRoutePresent(t, routes, RouteInfo{Path: \"/test1\", Method: http.MethodGet, Handler: \"github.com/gin-gonic/gin.handlerTest1\"})\n\tassertRoutePresent(t, routes, RouteInfo{Path: \"/test2\", Method: http.MethodGet, Handler: \"github.com/gin-gonic/gin.handlerTest2\"})\n}\n\nfunc TestWithOptionFunc(t *testing.T) {\n\tr := New()\n\n\tr.With(func(e *Engine) {\n\t\te.GET(\"/test1\", handlerTest1)\n\t\te.GET(\"/test2\", handlerTest2)\n\n\t\te.Use(func(c *Context) {\n\t\t\tc.Next()\n\t\t})\n\t})\n\n\troutes := r.Routes()\n\tassertRoutePresent(t, routes, RouteInfo{Path: \"/test1\", Method: http.MethodGet, Handler: \"github.com/gin-gonic/gin.handlerTest1\"})\n\tassertRoutePresent(t, routes, RouteInfo{Path: \"/test2\", Method: http.MethodGet, Handler: \"github.com/gin-gonic/gin.handlerTest2\"})\n}\n\ntype Birthday string\n\nfunc (b *Birthday) UnmarshalParam(param string) error {\n\t*b = Birthday(strings.Replace(param, \"-\", \"/\", -1))\n\treturn nil\n}\n\nfunc TestCustomUnmarshalStruct(t *testing.T) {\n\troute := Default()\n\tvar request struct {\n\t\tBirthday Birthday `form:\"birthday\"`\n\t}\n\troute.GET(\"/test\", func(ctx *Context) {\n\t\t_ = ctx.BindQuery(&request)\n\t\tctx.JSON(200, request.Birthday)\n\t})\n\treq := httptest.NewRequest(http.MethodGet, \"/test?birthday=2000-01-01\", nil)\n\tw := httptest.NewRecorder()\n\troute.ServeHTTP(w, req)\n\tassert.Equal(t, 200, w.Code)\n\tassert.Equal(t, `\"2000/01/01\"`, w.Body.String())\n}\n\n// Test the fix for https://github.com/gin-gonic/gin/issues/4002\nfunc TestMethodNotAllowedNoRoute(t *testing.T) {\n\tg := New()\n\tg.HandleMethodNotAllowed = true\n\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tresp := httptest.NewRecorder()\n\tassert.NotPanics(t, func() { g.ServeHTTP(resp, req) })\n\tassert.Equal(t, http.StatusNotFound, resp.Code)\n}\n"
        },
        {
          "name": "githubapi_test.go",
          "type": "blob",
          "size": 16.9912109375,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype route struct {\n\tmethod string\n\tpath   string\n}\n\n// http://developer.github.com/v3/\nvar githubAPI = []route{\n\t// OAuth Authorizations\n\t{http.MethodGet, \"/authorizations\"},\n\t{http.MethodGet, \"/authorizations/:id\"},\n\t{http.MethodPost, \"/authorizations\"},\n\t//{http.MethodPut, \"/authorizations/clients/:client_id\"},\n\t//{http.MethodPatch, \"/authorizations/:id\"},\n\t{http.MethodDelete, \"/authorizations/:id\"},\n\t{http.MethodGet, \"/applications/:client_id/tokens/:access_token\"},\n\t{http.MethodDelete, \"/applications/:client_id/tokens\"},\n\t{http.MethodDelete, \"/applications/:client_id/tokens/:access_token\"},\n\n\t// Activity\n\t{http.MethodGet, \"/events\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/events\"},\n\t{http.MethodGet, \"/networks/:owner/:repo/events\"},\n\t{http.MethodGet, \"/orgs/:org/events\"},\n\t{http.MethodGet, \"/users/:user/received_events\"},\n\t{http.MethodGet, \"/users/:user/received_events/public\"},\n\t{http.MethodGet, \"/users/:user/events\"},\n\t{http.MethodGet, \"/users/:user/events/public\"},\n\t{http.MethodGet, \"/users/:user/events/orgs/:org\"},\n\t{http.MethodGet, \"/feeds\"},\n\t{http.MethodGet, \"/notifications\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/notifications\"},\n\t{http.MethodPut, \"/notifications\"},\n\t{http.MethodPut, \"/repos/:owner/:repo/notifications\"},\n\t{http.MethodGet, \"/notifications/threads/:id\"},\n\t//{http.MethodPatch, \"/notifications/threads/:id\"},\n\t{http.MethodGet, \"/notifications/threads/:id/subscription\"},\n\t{http.MethodPut, \"/notifications/threads/:id/subscription\"},\n\t{http.MethodDelete, \"/notifications/threads/:id/subscription\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/stargazers\"},\n\t{http.MethodGet, \"/users/:user/starred\"},\n\t{http.MethodGet, \"/user/starred\"},\n\t{http.MethodGet, \"/user/starred/:owner/:repo\"},\n\t{http.MethodPut, \"/user/starred/:owner/:repo\"},\n\t{http.MethodDelete, \"/user/starred/:owner/:repo\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/subscribers\"},\n\t{http.MethodGet, \"/users/:user/subscriptions\"},\n\t{http.MethodGet, \"/user/subscriptions\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/subscription\"},\n\t{http.MethodPut, \"/repos/:owner/:repo/subscription\"},\n\t{http.MethodDelete, \"/repos/:owner/:repo/subscription\"},\n\t{http.MethodGet, \"/user/subscriptions/:owner/:repo\"},\n\t{http.MethodPut, \"/user/subscriptions/:owner/:repo\"},\n\t{http.MethodDelete, \"/user/subscriptions/:owner/:repo\"},\n\n\t// Gists\n\t{http.MethodGet, \"/users/:user/gists\"},\n\t{http.MethodGet, \"/gists\"},\n\t//{http.MethodGet, \"/gists/public\"},\n\t//{http.MethodGet, \"/gists/starred\"},\n\t{http.MethodGet, \"/gists/:id\"},\n\t{http.MethodPost, \"/gists\"},\n\t//{http.MethodPatch, \"/gists/:id\"},\n\t{http.MethodPut, \"/gists/:id/star\"},\n\t{http.MethodDelete, \"/gists/:id/star\"},\n\t{http.MethodGet, \"/gists/:id/star\"},\n\t{http.MethodPost, \"/gists/:id/forks\"},\n\t{http.MethodDelete, \"/gists/:id\"},\n\n\t// Git Data\n\t{http.MethodGet, \"/repos/:owner/:repo/git/blobs/:sha\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/git/blobs\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/git/commits/:sha\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/git/commits\"},\n\t//{http.MethodGet, \"/repos/:owner/:repo/git/refs/*ref\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/git/refs\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/git/refs\"},\n\t//{http.MethodPatch, \"/repos/:owner/:repo/git/refs/*ref\"},\n\t//{http.MethodDelete, \"/repos/:owner/:repo/git/refs/*ref\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/git/tags/:sha\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/git/tags\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/git/trees/:sha\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/git/trees\"},\n\n\t// Issues\n\t{http.MethodGet, \"/issues\"},\n\t{http.MethodGet, \"/user/issues\"},\n\t{http.MethodGet, \"/orgs/:org/issues\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/issues\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/issues/:number\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/issues\"},\n\t//{http.MethodPatch, \"/repos/:owner/:repo/issues/:number\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/assignees\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/assignees/:assignee\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/issues/:number/comments\"},\n\t//{http.MethodGet, \"/repos/:owner/:repo/issues/comments\"},\n\t//{http.MethodGet, \"/repos/:owner/:repo/issues/comments/:id\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/issues/:number/comments\"},\n\t//{http.MethodPatch, \"/repos/:owner/:repo/issues/comments/:id\"},\n\t//{http.MethodDelete, \"/repos/:owner/:repo/issues/comments/:id\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/issues/:number/events\"},\n\t//{http.MethodGet, \"/repos/:owner/:repo/issues/events\"},\n\t//{http.MethodGet, \"/repos/:owner/:repo/issues/events/:id\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/labels\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/labels/:name\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/labels\"},\n\t//{http.MethodPatch, \"/repos/:owner/:repo/labels/:name\"},\n\t{http.MethodDelete, \"/repos/:owner/:repo/labels/:name\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/issues/:number/labels\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/issues/:number/labels\"},\n\t{http.MethodDelete, \"/repos/:owner/:repo/issues/:number/labels/:name\"},\n\t{http.MethodPut, \"/repos/:owner/:repo/issues/:number/labels\"},\n\t{http.MethodDelete, \"/repos/:owner/:repo/issues/:number/labels\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/milestones/:number/labels\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/milestones\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/milestones/:number\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/milestones\"},\n\t//{http.MethodPatch, \"/repos/:owner/:repo/milestones/:number\"},\n\t{http.MethodDelete, \"/repos/:owner/:repo/milestones/:number\"},\n\n\t// Miscellaneous\n\t{http.MethodGet, \"/emojis\"},\n\t{http.MethodGet, \"/gitignore/templates\"},\n\t{http.MethodGet, \"/gitignore/templates/:name\"},\n\t{http.MethodPost, \"/markdown\"},\n\t{http.MethodPost, \"/markdown/raw\"},\n\t{http.MethodGet, \"/meta\"},\n\t{http.MethodGet, \"/rate_limit\"},\n\n\t// Organizations\n\t{http.MethodGet, \"/users/:user/orgs\"},\n\t{http.MethodGet, \"/user/orgs\"},\n\t{http.MethodGet, \"/orgs/:org\"},\n\t//{http.MethodPatch, \"/orgs/:org\"},\n\t{http.MethodGet, \"/orgs/:org/members\"},\n\t{http.MethodGet, \"/orgs/:org/members/:user\"},\n\t{http.MethodDelete, \"/orgs/:org/members/:user\"},\n\t{http.MethodGet, \"/orgs/:org/public_members\"},\n\t{http.MethodGet, \"/orgs/:org/public_members/:user\"},\n\t{http.MethodPut, \"/orgs/:org/public_members/:user\"},\n\t{http.MethodDelete, \"/orgs/:org/public_members/:user\"},\n\t{http.MethodGet, \"/orgs/:org/teams\"},\n\t{http.MethodGet, \"/teams/:id\"},\n\t{http.MethodPost, \"/orgs/:org/teams\"},\n\t//{http.MethodPatch, \"/teams/:id\"},\n\t{http.MethodDelete, \"/teams/:id\"},\n\t{http.MethodGet, \"/teams/:id/members\"},\n\t{http.MethodGet, \"/teams/:id/members/:user\"},\n\t{http.MethodPut, \"/teams/:id/members/:user\"},\n\t{http.MethodDelete, \"/teams/:id/members/:user\"},\n\t{http.MethodGet, \"/teams/:id/repos\"},\n\t{http.MethodGet, \"/teams/:id/repos/:owner/:repo\"},\n\t{http.MethodPut, \"/teams/:id/repos/:owner/:repo\"},\n\t{http.MethodDelete, \"/teams/:id/repos/:owner/:repo\"},\n\t{http.MethodGet, \"/user/teams\"},\n\n\t// Pull Requests\n\t{http.MethodGet, \"/repos/:owner/:repo/pulls\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/pulls/:number\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/pulls\"},\n\t//{http.MethodPatch, \"/repos/:owner/:repo/pulls/:number\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/pulls/:number/commits\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/pulls/:number/files\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/pulls/:number/merge\"},\n\t{http.MethodPut, \"/repos/:owner/:repo/pulls/:number/merge\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/pulls/:number/comments\"},\n\t//{http.MethodGet, \"/repos/:owner/:repo/pulls/comments\"},\n\t//{http.MethodGet, \"/repos/:owner/:repo/pulls/comments/:number\"},\n\t{http.MethodPut, \"/repos/:owner/:repo/pulls/:number/comments\"},\n\t//{http.MethodPatch, \"/repos/:owner/:repo/pulls/comments/:number\"},\n\t//{http.MethodDelete, \"/repos/:owner/:repo/pulls/comments/:number\"},\n\n\t// Repositories\n\t{http.MethodGet, \"/user/repos\"},\n\t{http.MethodGet, \"/users/:user/repos\"},\n\t{http.MethodGet, \"/orgs/:org/repos\"},\n\t{http.MethodGet, \"/repositories\"},\n\t{http.MethodPost, \"/user/repos\"},\n\t{http.MethodPost, \"/orgs/:org/repos\"},\n\t{http.MethodGet, \"/repos/:owner/:repo\"},\n\t//{http.MethodPatch, \"/repos/:owner/:repo\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/contributors\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/languages\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/teams\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/tags\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/branches\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/branches/:branch\"},\n\t{http.MethodDelete, \"/repos/:owner/:repo\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/collaborators\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/collaborators/:user\"},\n\t{http.MethodPut, \"/repos/:owner/:repo/collaborators/:user\"},\n\t{http.MethodDelete, \"/repos/:owner/:repo/collaborators/:user\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/comments\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/commits/:sha/comments\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/commits/:sha/comments\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/comments/:id\"},\n\t//{http.MethodPatch, \"/repos/:owner/:repo/comments/:id\"},\n\t{http.MethodDelete, \"/repos/:owner/:repo/comments/:id\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/commits\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/commits/:sha\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/readme\"},\n\t//{http.MethodGet, \"/repos/:owner/:repo/contents/*path\"},\n\t//{http.MethodPut, \"/repos/:owner/:repo/contents/*path\"},\n\t//{http.MethodDelete, \"/repos/:owner/:repo/contents/*path\"},\n\t//{http.MethodGet, \"/repos/:owner/:repo/:archive_format/:ref\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/keys\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/keys/:id\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/keys\"},\n\t//{http.MethodPatch, \"/repos/:owner/:repo/keys/:id\"},\n\t{http.MethodDelete, \"/repos/:owner/:repo/keys/:id\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/downloads\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/downloads/:id\"},\n\t{http.MethodDelete, \"/repos/:owner/:repo/downloads/:id\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/forks\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/forks\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/hooks\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/hooks/:id\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/hooks\"},\n\t//{http.MethodPatch, \"/repos/:owner/:repo/hooks/:id\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/hooks/:id/tests\"},\n\t{http.MethodDelete, \"/repos/:owner/:repo/hooks/:id\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/merges\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/releases\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/releases/:id\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/releases\"},\n\t//{http.MethodPatch, \"/repos/:owner/:repo/releases/:id\"},\n\t{http.MethodDelete, \"/repos/:owner/:repo/releases/:id\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/releases/:id/assets\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/stats/contributors\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/stats/commit_activity\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/stats/code_frequency\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/stats/participation\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/stats/punch_card\"},\n\t{http.MethodGet, \"/repos/:owner/:repo/statuses/:ref\"},\n\t{http.MethodPost, \"/repos/:owner/:repo/statuses/:ref\"},\n\n\t// Search\n\t{http.MethodGet, \"/search/repositories\"},\n\t{http.MethodGet, \"/search/code\"},\n\t{http.MethodGet, \"/search/issues\"},\n\t{http.MethodGet, \"/search/users\"},\n\t{http.MethodGet, \"/legacy/issues/search/:owner/:repository/:state/:keyword\"},\n\t{http.MethodGet, \"/legacy/repos/search/:keyword\"},\n\t{http.MethodGet, \"/legacy/user/search/:keyword\"},\n\t{http.MethodGet, \"/legacy/user/email/:email\"},\n\n\t// Users\n\t{http.MethodGet, \"/users/:user\"},\n\t{http.MethodGet, \"/user\"},\n\t//{http.MethodPatch, \"/user\"},\n\t{http.MethodGet, \"/users\"},\n\t{http.MethodGet, \"/user/emails\"},\n\t{http.MethodPost, \"/user/emails\"},\n\t{http.MethodDelete, \"/user/emails\"},\n\t{http.MethodGet, \"/users/:user/followers\"},\n\t{http.MethodGet, \"/user/followers\"},\n\t{http.MethodGet, \"/users/:user/following\"},\n\t{http.MethodGet, \"/user/following\"},\n\t{http.MethodGet, \"/user/following/:user\"},\n\t{http.MethodGet, \"/users/:user/following/:target_user\"},\n\t{http.MethodPut, \"/user/following/:user\"},\n\t{http.MethodDelete, \"/user/following/:user\"},\n\t{http.MethodGet, \"/users/:user/keys\"},\n\t{http.MethodGet, \"/user/keys\"},\n\t{http.MethodGet, \"/user/keys/:id\"},\n\t{http.MethodPost, \"/user/keys\"},\n\t//{http.MethodPatch, \"/user/keys/:id\"},\n\t{http.MethodDelete, \"/user/keys/:id\"},\n}\n\nfunc TestShouldBindUri(t *testing.T) {\n\tDefaultWriter = os.Stdout\n\trouter := New()\n\n\ttype Person struct {\n\t\tName string `uri:\"name\" binding:\"required\"`\n\t\tID   string `uri:\"id\" binding:\"required\"`\n\t}\n\trouter.Handle(http.MethodGet, \"/rest/:name/:id\", func(c *Context) {\n\t\tvar person Person\n\t\trequire.NoError(t, c.ShouldBindUri(&person))\n\t\tassert.NotEqual(t, \"\", person.Name)\n\t\tassert.NotEqual(t, \"\", person.ID)\n\t\tc.String(http.StatusOK, \"ShouldBindUri test OK\")\n\t})\n\n\tpath, _ := exampleFromPath(\"/rest/:name/:id\")\n\tw := PerformRequest(router, http.MethodGet, path)\n\tassert.Equal(t, \"ShouldBindUri test OK\", w.Body.String())\n\tassert.Equal(t, http.StatusOK, w.Code)\n}\n\nfunc TestBindUri(t *testing.T) {\n\tDefaultWriter = os.Stdout\n\trouter := New()\n\n\ttype Person struct {\n\t\tName string `uri:\"name\" binding:\"required\"`\n\t\tID   string `uri:\"id\" binding:\"required\"`\n\t}\n\trouter.Handle(http.MethodGet, \"/rest/:name/:id\", func(c *Context) {\n\t\tvar person Person\n\t\trequire.NoError(t, c.BindUri(&person))\n\t\tassert.NotEqual(t, \"\", person.Name)\n\t\tassert.NotEqual(t, \"\", person.ID)\n\t\tc.String(http.StatusOK, \"BindUri test OK\")\n\t})\n\n\tpath, _ := exampleFromPath(\"/rest/:name/:id\")\n\tw := PerformRequest(router, http.MethodGet, path)\n\tassert.Equal(t, \"BindUri test OK\", w.Body.String())\n\tassert.Equal(t, http.StatusOK, w.Code)\n}\n\nfunc TestBindUriError(t *testing.T) {\n\tDefaultWriter = os.Stdout\n\trouter := New()\n\n\ttype Member struct {\n\t\tNumber string `uri:\"num\" binding:\"required,uuid\"`\n\t}\n\trouter.Handle(http.MethodGet, \"/new/rest/:num\", func(c *Context) {\n\t\tvar m Member\n\t\trequire.Error(t, c.BindUri(&m))\n\t})\n\n\tpath1, _ := exampleFromPath(\"/new/rest/:num\")\n\tw1 := PerformRequest(router, http.MethodGet, path1)\n\tassert.Equal(t, http.StatusBadRequest, w1.Code)\n}\n\nfunc TestRaceContextCopy(t *testing.T) {\n\tDefaultWriter = os.Stdout\n\trouter := Default()\n\trouter.GET(\"/test/copy/race\", func(c *Context) {\n\t\tc.Set(\"1\", 0)\n\t\tc.Set(\"2\", 0)\n\n\t\t// Sending a copy of the Context to two separate routines\n\t\tgo readWriteKeys(c.Copy())\n\t\tgo readWriteKeys(c.Copy())\n\t\tc.String(http.StatusOK, \"run OK, no panics\")\n\t})\n\tw := PerformRequest(router, http.MethodGet, \"/test/copy/race\")\n\tassert.Equal(t, \"run OK, no panics\", w.Body.String())\n}\n\nfunc readWriteKeys(c *Context) {\n\tfor {\n\t\tc.Set(\"1\", rand.Int())\n\t\tc.Set(\"2\", c.Value(\"1\"))\n\t}\n}\n\nfunc githubConfigRouter(router *Engine) {\n\tfor _, route := range githubAPI {\n\t\trouter.Handle(route.method, route.path, func(c *Context) {\n\t\t\toutput := make(map[string]string, len(c.Params)+1)\n\t\t\toutput[\"status\"] = \"good\"\n\t\t\tfor _, param := range c.Params {\n\t\t\t\toutput[param.Key] = param.Value\n\t\t\t}\n\t\t\tc.JSON(http.StatusOK, output)\n\t\t})\n\t}\n}\n\nfunc TestGithubAPI(t *testing.T) {\n\tDefaultWriter = os.Stdout\n\trouter := New()\n\tgithubConfigRouter(router)\n\n\tfor _, route := range githubAPI {\n\t\tpath, values := exampleFromPath(route.path)\n\t\tw := PerformRequest(router, route.method, path)\n\n\t\t// TEST\n\t\tassert.Contains(t, w.Body.String(), \"\\\"status\\\":\\\"good\\\"\")\n\t\tfor _, value := range values {\n\t\t\tstr := fmt.Sprintf(\"\\\"%s\\\":\\\"%s\\\"\", value.Key, value.Value)\n\t\t\tassert.Contains(t, w.Body.String(), str)\n\t\t}\n\t}\n}\n\nfunc exampleFromPath(path string) (string, Params) {\n\toutput := new(strings.Builder)\n\tparams := make(Params, 0, 6)\n\tstart := -1\n\tfor i, c := range path {\n\t\tif c == ':' {\n\t\t\tstart = i + 1\n\t\t}\n\t\tif start >= 0 {\n\t\t\tif c == '/' {\n\t\t\t\tvalue := strconv.Itoa(rand.Intn(100000))\n\t\t\t\tparams = append(params, Param{\n\t\t\t\t\tKey:   path[start:i],\n\t\t\t\t\tValue: value,\n\t\t\t\t})\n\t\t\t\toutput.WriteString(value)\n\t\t\t\toutput.WriteRune(c)\n\t\t\t\tstart = -1\n\t\t\t}\n\t\t} else {\n\t\t\toutput.WriteRune(c)\n\t\t}\n\t}\n\tif start >= 0 {\n\t\tvalue := strconv.Itoa(rand.Intn(100000))\n\t\tparams = append(params, Param{\n\t\t\tKey:   path[start:],\n\t\t\tValue: value,\n\t\t})\n\t\toutput.WriteString(value)\n\t}\n\n\treturn output.String(), params\n}\n\nfunc BenchmarkGithub(b *testing.B) {\n\trouter := New()\n\tgithubConfigRouter(router)\n\trunRequest(b, router, http.MethodGet, \"/legacy/issues/search/:owner/:repository/:state/:keyword\")\n}\n\nfunc BenchmarkParallelGithub(b *testing.B) {\n\tDefaultWriter = os.Stdout\n\trouter := New()\n\tgithubConfigRouter(router)\n\n\treq, _ := http.NewRequest(http.MethodPost, \"/repos/manucorporat/sse/git/blobs\", nil)\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\t// Each goroutine has its own bytes.Buffer.\n\t\tfor pb.Next() {\n\t\t\tw := httptest.NewRecorder()\n\t\t\trouter.ServeHTTP(w, req)\n\t\t}\n\t})\n}\n\nfunc BenchmarkParallelGithubDefault(b *testing.B) {\n\tDefaultWriter = os.Stdout\n\trouter := New()\n\tgithubConfigRouter(router)\n\n\treq, _ := http.NewRequest(http.MethodPost, \"/repos/manucorporat/sse/git/blobs\", nil)\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\t// Each goroutine has its own bytes.Buffer.\n\t\tfor pb.Next() {\n\t\t\tw := httptest.NewRecorder()\n\t\t\trouter.ServeHTTP(w, req)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.8271484375,
          "content": "module github.com/gin-gonic/gin\n\ngo 1.22\n\nrequire (\n\tgithub.com/bytedance/sonic v1.11.6\n\tgithub.com/gin-contrib/sse v0.1.0\n\tgithub.com/go-playground/validator/v10 v10.20.0\n\tgithub.com/goccy/go-json v0.10.2\n\tgithub.com/json-iterator/go v1.1.12\n\tgithub.com/mattn/go-isatty v0.0.20\n\tgithub.com/pelletier/go-toml/v2 v2.2.2\n\tgithub.com/quic-go/quic-go v0.48.2\n\tgithub.com/stretchr/testify v1.9.0\n\tgithub.com/ugorji/go/codec v1.2.12\n\tgolang.org/x/net v0.33.0\n\tgoogle.golang.org/protobuf v1.34.1\n\tgopkg.in/yaml.v3 v3.0.1\n)\n\nrequire (\n\tgithub.com/bytedance/sonic/loader v0.1.1 // indirect\n\tgithub.com/cloudwego/base64x v0.1.4 // indirect\n\tgithub.com/cloudwego/iasm v0.2.0 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/gabriel-vasile/mimetype v1.4.3 // indirect\n\tgithub.com/go-playground/locales v0.14.1 // indirect\n\tgithub.com/go-playground/universal-translator v0.18.1 // indirect\n\tgithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572 // indirect\n\tgithub.com/google/pprof v0.0.0-20210407192527-94a9f03dee38 // indirect\n\tgithub.com/klauspost/cpuid/v2 v2.0.9 // indirect\n\tgithub.com/leodido/go-urn v1.4.0 // indirect\n\tgithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421 // indirect\n\tgithub.com/modern-go/reflect2 v1.0.2 // indirect\n\tgithub.com/onsi/ginkgo/v2 v2.9.5 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/quic-go/qpack v0.5.1 // indirect\n\tgithub.com/twitchyliquid64/golang-asm v0.15.1 // indirect\n\tgo.uber.org/mock v0.4.0 // indirect\n\tgolang.org/x/arch v0.0.0-20210923205945-b76863e36670 // indirect\n\tgolang.org/x/crypto v0.31.0 // indirect\n\tgolang.org/x/exp v0.0.0-20240506185415-9bf2ced13842 // indirect\n\tgolang.org/x/mod v0.17.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 10.115234375,
          "content": "github.com/bytedance/sonic v1.11.6 h1:oUp34TzMlL+OY1OUWxHqsdkgC/Zfc85zGqw9siXjrc0=\ngithub.com/bytedance/sonic v1.11.6/go.mod h1:LysEHSvpvDySVdC2f87zGWf6CIKJcAvqab1ZaiQtds4=\ngithub.com/bytedance/sonic/loader v0.1.1 h1:c+e5Pt1k/cy5wMveRDyk2X4B9hF4g7an8N3zCYjJFNM=\ngithub.com/bytedance/sonic/loader v0.1.1/go.mod h1:ncP89zfokxS5LZrJxl5z0UJcsk4M4yY2JpfqGeCtNLU=\ngithub.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngithub.com/cloudwego/base64x v0.1.4 h1:jwCgWpFanWmN8xoIUHa2rtzmkd5J2plF/dnLS6Xd/0Y=\ngithub.com/cloudwego/base64x v0.1.4/go.mod h1:0zlkT4Wn5C6NdauXdJRhSKRlJvmclQ1hhJgA0rcu/8w=\ngithub.com/cloudwego/iasm v0.2.0 h1:1KNIy1I1H9hNNFEEH3DVnI4UujN+1zjpuk6gwHLTssg=\ngithub.com/cloudwego/iasm v0.2.0/go.mod h1:8rXZaNYT2n95jn+zTI1sDr+IgcD2GVs0nlbbQPiEFhY=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/gabriel-vasile/mimetype v1.4.3 h1:in2uUcidCuFcDKtdcBxlR0rJ1+fsokWf+uqxgUFjbI0=\ngithub.com/gabriel-vasile/mimetype v1.4.3/go.mod h1:d8uq/6HKRL6CGdk+aubisF/M5GcPfT7nKyLpA0lbSSk=\ngithub.com/gin-contrib/sse v0.1.0 h1:Y/yl/+YNO8GZSjAhjMsSuLt29uWRFHdHYUb5lYOV9qE=\ngithub.com/gin-contrib/sse v0.1.0/go.mod h1:RHrZQHXnP2xjPF+u1gW/2HnVO7nvIa9PG3Gm+fLHvGI=\ngithub.com/go-logr/logr v1.2.4 h1:g01GSCwiDw2xSZfjJ2/T9M+S6pFdcNtFYsp+Y43HYDQ=\ngithub.com/go-logr/logr v1.2.4/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=\ngithub.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=\ngithub.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=\ngithub.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=\ngithub.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=\ngithub.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=\ngithub.com/go-playground/validator/v10 v10.20.0 h1:K9ISHbSaI0lyB2eWMPJo+kOS/FBExVwjEviJTixqxL8=\ngithub.com/go-playground/validator/v10 v10.20.0/go.mod h1:dbuPbCMFw/DrkbEynArYaCwl3amGuJotoKCe95atGMM=\ngithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572 h1:tfuBGBXKqDEevZMzYi5KSi8KkcZtzBcTgAUUtapy0OI=\ngithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572/go.mod h1:9Pwr4B2jHnOSGXyyzV8ROjYa2ojvAY6HCGYYfMoC3Ls=\ngithub.com/goccy/go-json v0.10.2 h1:CrxCmQqYDkv1z7lO7Wbh2HN93uovUHgrECaO5ZrCXAU=\ngithub.com/goccy/go-json v0.10.2/go.mod h1:6MelG93GURQebXPDq3khkgXZkazVtN9CRI+MGFi0w8I=\ngithub.com/golang/protobuf v1.5.3 h1:KhyjKVUg7Usr/dYsdSqoFveMYd5ko72D+zANwlG1mmg=\ngithub.com/golang/protobuf v1.5.3/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/pprof v0.0.0-20210407192527-94a9f03dee38 h1:yAJXTCF9TqKcTiHJAE8dj7HMvPfh66eeA2JYW7eFpSE=\ngithub.com/google/pprof v0.0.0-20210407192527-94a9f03dee38/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/ianlancetaylor/demangle v0.0.0-20200824232613-28f6c0f3b639/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=\ngithub.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=\ngithub.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=\ngithub.com/klauspost/cpuid/v2 v2.0.9 h1:lgaqFMSdTdQYdZ04uHyN2d/eKdOMyi2YLSvlQIBFYa4=\ngithub.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=\ngithub.com/knz/go-libedit v1.10.1/go.mod h1:MZTVkCWyz0oBc7JOWP3wNAzd002ZbM/5hgShxwh4x8M=\ngithub.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=\ngithub.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421 h1:ZqeYNhU3OHLH3mGKHDcjJRFFRrJa6eAM5H+CtDdOsPc=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=\ngithub.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=\ngithub.com/onsi/ginkgo/v2 v2.9.5 h1:+6Hr4uxzP4XIUyAkg61dWBw8lb/gc4/X5luuxN/EC+Q=\ngithub.com/onsi/ginkgo/v2 v2.9.5/go.mod h1:tvAoo1QUJwNEU2ITftXTpR7R1RbCzoZUOs3RonqW57k=\ngithub.com/onsi/gomega v1.27.6 h1:ENqfyGeS5AX/rlXDd/ETokDz93u0YufY1Pgxuy/PvWE=\ngithub.com/onsi/gomega v1.27.6/go.mod h1:PIQNjfQwkP3aQAH7lf7j87O/5FiNr+ZR8+ipb+qQlhg=\ngithub.com/pelletier/go-toml/v2 v2.2.2 h1:aYUidT7k73Pcl9nb2gScu7NSrKCSHIDE89b3+6Wq+LM=\ngithub.com/pelletier/go-toml/v2 v2.2.2/go.mod h1:1t835xjRzz80PqgE6HHgN2JOsmgYu/h4qDAS4n929Rs=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/quic-go/qpack v0.5.1 h1:giqksBPnT/HDtZ6VhtFKgoLOWmlyo9Ei6u9PqzIMbhI=\ngithub.com/quic-go/qpack v0.5.1/go.mod h1:+PC4XFrEskIVkcLzpEkbLqq1uCoxPhQuvK5rH1ZgaEg=\ngithub.com/quic-go/quic-go v0.48.2 h1:wsKXZPeGWpMpCGSWqOcqpW2wZYic/8T3aqiOID0/KWE=\ngithub.com/quic-go/quic-go v0.48.2/go.mod h1:yBgs3rWBOADpga7F+jJsb6Ybg1LSYiQvwWlLX+/6HMs=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/twitchyliquid64/golang-asm v0.15.1 h1:SU5vSMR7hnwNxj24w34ZyCi/FmDZTkS4MhqMhdFk5YI=\ngithub.com/twitchyliquid64/golang-asm v0.15.1/go.mod h1:a1lVb/DtPvCB8fslRZhAngC2+aY1QWCk3Cedj/Gdt08=\ngithub.com/ugorji/go/codec v1.2.12 h1:9LC83zGrHhuUA9l16C9AHXAqEV/2wBQ4nkvumAE65EE=\ngithub.com/ugorji/go/codec v1.2.12/go.mod h1:UNopzCgEMSXjBc6AOMqYvWC1ktqTAfzJZUZgYf6w6lg=\ngo.uber.org/mock v0.4.0 h1:VcM4ZOtdbR4f6VXfiOpwpVJDL6lCReaZ6mw31wqh7KU=\ngo.uber.org/mock v0.4.0/go.mod h1:a6FSlNadKUHUa9IP5Vyt1zh4fC7uAwxMutEAscFbkZc=\ngolang.org/x/arch v0.0.0-20210923205945-b76863e36670 h1:18EFjUmQOcUvxNYSkA6jO9VAiXCnxFY6NyDX0bHDmkU=\ngolang.org/x/arch v0.0.0-20210923205945-b76863e36670/go.mod h1:5om86z9Hs0C8fWVUuoMHwpExlXzs5Tkyp9hOrfG7pp8=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/exp v0.0.0-20240506185415-9bf2ced13842 h1:vr/HnozRka3pE4EsMEg1lgkXJkTFJCVUX+S/ZT6wYzM=\ngolang.org/x/exp v0.0.0-20240506185415-9bf2ced13842/go.mod h1:XtvwrStGgqGPLc4cjQfWqZHG1YFdYs6swckp8vpsjnc=\ngolang.org/x/mod v0.17.0 h1:zY54UmvipHiNd+pm+m0x9KhZ9hl1/7QNMyxXbc6ICqA=\ngolang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20191204072324-ce4227a45e2e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/time v0.5.0 h1:o7cqy6amK/52YcAKIPlM3a+Fpj35zvRj2TP+e1xFSfk=\ngolang.org/x/time v0.5.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\ngolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d h1:vU5i/LfpvrRCpgM/VPfJLg5KjxD3E+hfT1SH+d9zLwg=\ngolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=\ngoogle.golang.org/protobuf v1.34.1 h1:9ddQBjfCyZPOHPUiPxpYESBLc+T8P3E+Vo4IbKZgFWg=\ngoogle.golang.org/protobuf v1.34.1/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nnullprogram.com/x/optparse v1.0.0/go.mod h1:KdyPE+Igbe0jQUrVfMqDMeJQIJZEuyV7pjYmp6pbG50=\nrsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 6.9208984375,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/mattn/go-isatty\"\n)\n\ntype consoleColorModeValue int\n\nconst (\n\tautoColor consoleColorModeValue = iota\n\tdisableColor\n\tforceColor\n)\n\nconst (\n\tgreen   = \"\\033[97;42m\"\n\twhite   = \"\\033[90;47m\"\n\tyellow  = \"\\033[90;43m\"\n\tred     = \"\\033[97;41m\"\n\tblue    = \"\\033[97;44m\"\n\tmagenta = \"\\033[97;45m\"\n\tcyan    = \"\\033[97;46m\"\n\treset   = \"\\033[0m\"\n)\n\nvar consoleColorMode = autoColor\n\n// LoggerConfig defines the config for Logger middleware.\ntype LoggerConfig struct {\n\t// Optional. Default value is gin.defaultLogFormatter\n\tFormatter LogFormatter\n\n\t// Output is a writer where logs are written.\n\t// Optional. Default value is gin.DefaultWriter.\n\tOutput io.Writer\n\n\t// SkipPaths is an url path array which logs are not written.\n\t// Optional.\n\tSkipPaths []string\n\n\t// Skip is a Skipper that indicates which logs should not be written.\n\t// Optional.\n\tSkip Skipper\n}\n\n// Skipper is a function to skip logs based on provided Context\ntype Skipper func(c *Context) bool\n\n// LogFormatter gives the signature of the formatter function passed to LoggerWithFormatter\ntype LogFormatter func(params LogFormatterParams) string\n\n// LogFormatterParams is the structure any formatter will be handed when time to log comes\ntype LogFormatterParams struct {\n\tRequest *http.Request\n\n\t// TimeStamp shows the time after the server returns a response.\n\tTimeStamp time.Time\n\t// StatusCode is HTTP response code.\n\tStatusCode int\n\t// Latency is how much time the server cost to process a certain request.\n\tLatency time.Duration\n\t// ClientIP equals Context's ClientIP method.\n\tClientIP string\n\t// Method is the HTTP method given to the request.\n\tMethod string\n\t// Path is a path the client requests.\n\tPath string\n\t// ErrorMessage is set if error has occurred in processing the request.\n\tErrorMessage string\n\t// isTerm shows whether gin's output descriptor refers to a terminal.\n\tisTerm bool\n\t// BodySize is the size of the Response Body\n\tBodySize int\n\t// Keys are the keys set on the request's context.\n\tKeys map[string]any\n}\n\n// StatusCodeColor is the ANSI color for appropriately logging http status code to a terminal.\nfunc (p *LogFormatterParams) StatusCodeColor() string {\n\tcode := p.StatusCode\n\n\tswitch {\n\tcase code >= http.StatusContinue && code < http.StatusOK:\n\t\treturn white\n\tcase code >= http.StatusOK && code < http.StatusMultipleChoices:\n\t\treturn green\n\tcase code >= http.StatusMultipleChoices && code < http.StatusBadRequest:\n\t\treturn white\n\tcase code >= http.StatusBadRequest && code < http.StatusInternalServerError:\n\t\treturn yellow\n\tdefault:\n\t\treturn red\n\t}\n}\n\n// MethodColor is the ANSI color for appropriately logging http method to a terminal.\nfunc (p *LogFormatterParams) MethodColor() string {\n\tmethod := p.Method\n\n\tswitch method {\n\tcase http.MethodGet:\n\t\treturn blue\n\tcase http.MethodPost:\n\t\treturn cyan\n\tcase http.MethodPut:\n\t\treturn yellow\n\tcase http.MethodDelete:\n\t\treturn red\n\tcase http.MethodPatch:\n\t\treturn green\n\tcase http.MethodHead:\n\t\treturn magenta\n\tcase http.MethodOptions:\n\t\treturn white\n\tdefault:\n\t\treturn reset\n\t}\n}\n\n// ResetColor resets all escape attributes.\nfunc (p *LogFormatterParams) ResetColor() string {\n\treturn reset\n}\n\n// IsOutputColor indicates whether can colors be outputted to the log.\nfunc (p *LogFormatterParams) IsOutputColor() bool {\n\treturn consoleColorMode == forceColor || (consoleColorMode == autoColor && p.isTerm)\n}\n\n// defaultLogFormatter is the default log format function Logger middleware uses.\nvar defaultLogFormatter = func(param LogFormatterParams) string {\n\tvar statusColor, methodColor, resetColor string\n\tif param.IsOutputColor() {\n\t\tstatusColor = param.StatusCodeColor()\n\t\tmethodColor = param.MethodColor()\n\t\tresetColor = param.ResetColor()\n\t}\n\n\tif param.Latency > time.Minute {\n\t\tparam.Latency = param.Latency.Truncate(time.Second)\n\t}\n\treturn fmt.Sprintf(\"[GIN] %v |%s %3d %s| %13v | %15s |%s %-7s %s %#v\\n%s\",\n\t\tparam.TimeStamp.Format(\"2006/01/02 - 15:04:05\"),\n\t\tstatusColor, param.StatusCode, resetColor,\n\t\tparam.Latency,\n\t\tparam.ClientIP,\n\t\tmethodColor, param.Method, resetColor,\n\t\tparam.Path,\n\t\tparam.ErrorMessage,\n\t)\n}\n\n// DisableConsoleColor disables color output in the console.\nfunc DisableConsoleColor() {\n\tconsoleColorMode = disableColor\n}\n\n// ForceConsoleColor force color output in the console.\nfunc ForceConsoleColor() {\n\tconsoleColorMode = forceColor\n}\n\n// ErrorLogger returns a HandlerFunc for any error type.\nfunc ErrorLogger() HandlerFunc {\n\treturn ErrorLoggerT(ErrorTypeAny)\n}\n\n// ErrorLoggerT returns a HandlerFunc for a given error type.\nfunc ErrorLoggerT(typ ErrorType) HandlerFunc {\n\treturn func(c *Context) {\n\t\tc.Next()\n\t\terrors := c.Errors.ByType(typ)\n\t\tif len(errors) > 0 {\n\t\t\tc.JSON(-1, errors)\n\t\t}\n\t}\n}\n\n// Logger instances a Logger middleware that will write the logs to gin.DefaultWriter.\n// By default, gin.DefaultWriter = os.Stdout.\nfunc Logger() HandlerFunc {\n\treturn LoggerWithConfig(LoggerConfig{})\n}\n\n// LoggerWithFormatter instance a Logger middleware with the specified log format function.\nfunc LoggerWithFormatter(f LogFormatter) HandlerFunc {\n\treturn LoggerWithConfig(LoggerConfig{\n\t\tFormatter: f,\n\t})\n}\n\n// LoggerWithWriter instance a Logger middleware with the specified writer buffer.\n// Example: os.Stdout, a file opened in write mode, a socket...\nfunc LoggerWithWriter(out io.Writer, notlogged ...string) HandlerFunc {\n\treturn LoggerWithConfig(LoggerConfig{\n\t\tOutput:    out,\n\t\tSkipPaths: notlogged,\n\t})\n}\n\n// LoggerWithConfig instance a Logger middleware with config.\nfunc LoggerWithConfig(conf LoggerConfig) HandlerFunc {\n\tformatter := conf.Formatter\n\tif formatter == nil {\n\t\tformatter = defaultLogFormatter\n\t}\n\n\tout := conf.Output\n\tif out == nil {\n\t\tout = DefaultWriter\n\t}\n\n\tnotlogged := conf.SkipPaths\n\n\tisTerm := true\n\n\tif w, ok := out.(*os.File); !ok || os.Getenv(\"TERM\") == \"dumb\" ||\n\t\t(!isatty.IsTerminal(w.Fd()) && !isatty.IsCygwinTerminal(w.Fd())) {\n\t\tisTerm = false\n\t}\n\n\tvar skip map[string]struct{}\n\n\tif length := len(notlogged); length > 0 {\n\t\tskip = make(map[string]struct{}, length)\n\n\t\tfor _, path := range notlogged {\n\t\t\tskip[path] = struct{}{}\n\t\t}\n\t}\n\n\treturn func(c *Context) {\n\t\t// Start timer\n\t\tstart := time.Now()\n\t\tpath := c.Request.URL.Path\n\t\traw := c.Request.URL.RawQuery\n\n\t\t// Process request\n\t\tc.Next()\n\n\t\t// Log only when it is not being skipped\n\t\tif _, ok := skip[path]; ok || (conf.Skip != nil && conf.Skip(c)) {\n\t\t\treturn\n\t\t}\n\n\t\tparam := LogFormatterParams{\n\t\t\tRequest: c.Request,\n\t\t\tisTerm:  isTerm,\n\t\t\tKeys:    c.Keys,\n\t\t}\n\n\t\t// Stop timer\n\t\tparam.TimeStamp = time.Now()\n\t\tparam.Latency = param.TimeStamp.Sub(start)\n\n\t\tparam.ClientIP = c.ClientIP()\n\t\tparam.Method = c.Request.Method\n\t\tparam.StatusCode = c.Writer.Status()\n\t\tparam.ErrorMessage = c.Errors.ByType(ErrorTypePrivate).String()\n\n\t\tparam.BodySize = c.Writer.Size()\n\n\t\tif raw != \"\" {\n\t\t\tpath = path + \"?\" + raw\n\t\t}\n\n\t\tparam.Path = path\n\n\t\tfmt.Fprint(out, formatter(param))\n\t}\n}\n"
        },
        {
          "name": "logger_test.go",
          "type": "blob",
          "size": 14.2783203125,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc init() {\n\tSetMode(TestMode)\n}\n\nfunc TestLogger(t *testing.T) {\n\tbuffer := new(strings.Builder)\n\trouter := New()\n\trouter.Use(LoggerWithWriter(buffer))\n\trouter.GET(\"/example\", func(c *Context) {})\n\trouter.POST(\"/example\", func(c *Context) {})\n\trouter.PUT(\"/example\", func(c *Context) {})\n\trouter.DELETE(\"/example\", func(c *Context) {})\n\trouter.PATCH(\"/example\", func(c *Context) {})\n\trouter.HEAD(\"/example\", func(c *Context) {})\n\trouter.OPTIONS(\"/example\", func(c *Context) {})\n\n\tPerformRequest(router, http.MethodGet, \"/example?a=100\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), http.MethodGet)\n\tassert.Contains(t, buffer.String(), \"/example\")\n\tassert.Contains(t, buffer.String(), \"a=100\")\n\n\t// I wrote these first (extending the above) but then realized they are more\n\t// like integration tests because they test the whole logging process rather\n\t// than individual functions.  Im not sure where these should go.\n\tbuffer.Reset()\n\tPerformRequest(router, http.MethodPost, \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), http.MethodPost)\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tPerformRequest(router, http.MethodPut, \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), http.MethodPut)\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tPerformRequest(router, http.MethodDelete, \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), http.MethodDelete)\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tPerformRequest(router, \"PATCH\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"PATCH\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tPerformRequest(router, \"HEAD\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"HEAD\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tPerformRequest(router, \"OPTIONS\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"OPTIONS\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tPerformRequest(router, http.MethodGet, \"/notfound\")\n\tassert.Contains(t, buffer.String(), \"404\")\n\tassert.Contains(t, buffer.String(), http.MethodGet)\n\tassert.Contains(t, buffer.String(), \"/notfound\")\n}\n\nfunc TestLoggerWithConfig(t *testing.T) {\n\tbuffer := new(strings.Builder)\n\trouter := New()\n\trouter.Use(LoggerWithConfig(LoggerConfig{Output: buffer}))\n\trouter.GET(\"/example\", func(c *Context) {})\n\trouter.POST(\"/example\", func(c *Context) {})\n\trouter.PUT(\"/example\", func(c *Context) {})\n\trouter.DELETE(\"/example\", func(c *Context) {})\n\trouter.PATCH(\"/example\", func(c *Context) {})\n\trouter.HEAD(\"/example\", func(c *Context) {})\n\trouter.OPTIONS(\"/example\", func(c *Context) {})\n\n\tPerformRequest(router, http.MethodGet, \"/example?a=100\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), http.MethodGet)\n\tassert.Contains(t, buffer.String(), \"/example\")\n\tassert.Contains(t, buffer.String(), \"a=100\")\n\n\t// I wrote these first (extending the above) but then realized they are more\n\t// like integration tests because they test the whole logging process rather\n\t// than individual functions.  Im not sure where these should go.\n\tbuffer.Reset()\n\tPerformRequest(router, http.MethodPost, \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), http.MethodPost)\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tPerformRequest(router, http.MethodPut, \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), http.MethodPut)\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tPerformRequest(router, http.MethodDelete, \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), http.MethodDelete)\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tPerformRequest(router, \"PATCH\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"PATCH\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tPerformRequest(router, \"HEAD\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"HEAD\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tPerformRequest(router, \"OPTIONS\", \"/example\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), \"OPTIONS\")\n\tassert.Contains(t, buffer.String(), \"/example\")\n\n\tbuffer.Reset()\n\tPerformRequest(router, http.MethodGet, \"/notfound\")\n\tassert.Contains(t, buffer.String(), \"404\")\n\tassert.Contains(t, buffer.String(), http.MethodGet)\n\tassert.Contains(t, buffer.String(), \"/notfound\")\n}\n\nfunc TestLoggerWithFormatter(t *testing.T) {\n\tbuffer := new(strings.Builder)\n\n\td := DefaultWriter\n\tDefaultWriter = buffer\n\tdefer func() {\n\t\tDefaultWriter = d\n\t}()\n\n\trouter := New()\n\trouter.Use(LoggerWithFormatter(func(param LogFormatterParams) string {\n\t\treturn fmt.Sprintf(\"[FORMATTER TEST] %v | %3d | %13v | %15s | %-7s %#v\\n%s\",\n\t\t\tparam.TimeStamp.Format(\"2006/01/02 - 15:04:05\"),\n\t\t\tparam.StatusCode,\n\t\t\tparam.Latency,\n\t\t\tparam.ClientIP,\n\t\t\tparam.Method,\n\t\t\tparam.Path,\n\t\t\tparam.ErrorMessage,\n\t\t)\n\t}))\n\trouter.GET(\"/example\", func(c *Context) {})\n\tPerformRequest(router, http.MethodGet, \"/example?a=100\")\n\n\t// output test\n\tassert.Contains(t, buffer.String(), \"[FORMATTER TEST]\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), http.MethodGet)\n\tassert.Contains(t, buffer.String(), \"/example\")\n\tassert.Contains(t, buffer.String(), \"a=100\")\n}\n\nfunc TestLoggerWithConfigFormatting(t *testing.T) {\n\tvar gotParam LogFormatterParams\n\tvar gotKeys map[string]any\n\tbuffer := new(strings.Builder)\n\n\trouter := New()\n\trouter.engine.trustedCIDRs, _ = router.engine.prepareTrustedCIDRs()\n\n\trouter.Use(LoggerWithConfig(LoggerConfig{\n\t\tOutput: buffer,\n\t\tFormatter: func(param LogFormatterParams) string {\n\t\t\t// for assert test\n\t\t\tgotParam = param\n\n\t\t\treturn fmt.Sprintf(\"[FORMATTER TEST] %v | %3d | %13v | %15s | %-7s %s\\n%s\",\n\t\t\t\tparam.TimeStamp.Format(\"2006/01/02 - 15:04:05\"),\n\t\t\t\tparam.StatusCode,\n\t\t\t\tparam.Latency,\n\t\t\t\tparam.ClientIP,\n\t\t\t\tparam.Method,\n\t\t\t\tparam.Path,\n\t\t\t\tparam.ErrorMessage,\n\t\t\t)\n\t\t},\n\t}))\n\trouter.GET(\"/example\", func(c *Context) {\n\t\t// set dummy ClientIP\n\t\tc.Request.Header.Set(\"X-Forwarded-For\", \"20.20.20.20\")\n\t\tgotKeys = c.Keys\n\t\ttime.Sleep(time.Millisecond)\n\t})\n\tPerformRequest(router, http.MethodGet, \"/example?a=100\")\n\n\t// output test\n\tassert.Contains(t, buffer.String(), \"[FORMATTER TEST]\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\tassert.Contains(t, buffer.String(), http.MethodGet)\n\tassert.Contains(t, buffer.String(), \"/example\")\n\tassert.Contains(t, buffer.String(), \"a=100\")\n\n\t// LogFormatterParams test\n\tassert.NotNil(t, gotParam.Request)\n\tassert.NotEmpty(t, gotParam.TimeStamp)\n\tassert.Equal(t, 200, gotParam.StatusCode)\n\tassert.NotEmpty(t, gotParam.Latency)\n\tassert.Equal(t, \"20.20.20.20\", gotParam.ClientIP)\n\tassert.Equal(t, http.MethodGet, gotParam.Method)\n\tassert.Equal(t, \"/example?a=100\", gotParam.Path)\n\tassert.Empty(t, gotParam.ErrorMessage)\n\tassert.Equal(t, gotKeys, gotParam.Keys)\n}\n\nfunc TestDefaultLogFormatter(t *testing.T) {\n\ttimeStamp := time.Unix(1544173902, 0).UTC()\n\n\ttermFalseParam := LogFormatterParams{\n\t\tTimeStamp:    timeStamp,\n\t\tStatusCode:   200,\n\t\tLatency:      time.Second * 5,\n\t\tClientIP:     \"20.20.20.20\",\n\t\tMethod:       http.MethodGet,\n\t\tPath:         \"/\",\n\t\tErrorMessage: \"\",\n\t\tisTerm:       false,\n\t}\n\n\ttermTrueParam := LogFormatterParams{\n\t\tTimeStamp:    timeStamp,\n\t\tStatusCode:   200,\n\t\tLatency:      time.Second * 5,\n\t\tClientIP:     \"20.20.20.20\",\n\t\tMethod:       http.MethodGet,\n\t\tPath:         \"/\",\n\t\tErrorMessage: \"\",\n\t\tisTerm:       true,\n\t}\n\ttermTrueLongDurationParam := LogFormatterParams{\n\t\tTimeStamp:    timeStamp,\n\t\tStatusCode:   200,\n\t\tLatency:      time.Millisecond * 9876543210,\n\t\tClientIP:     \"20.20.20.20\",\n\t\tMethod:       http.MethodGet,\n\t\tPath:         \"/\",\n\t\tErrorMessage: \"\",\n\t\tisTerm:       true,\n\t}\n\n\ttermFalseLongDurationParam := LogFormatterParams{\n\t\tTimeStamp:    timeStamp,\n\t\tStatusCode:   200,\n\t\tLatency:      time.Millisecond * 9876543210,\n\t\tClientIP:     \"20.20.20.20\",\n\t\tMethod:       http.MethodGet,\n\t\tPath:         \"/\",\n\t\tErrorMessage: \"\",\n\t\tisTerm:       false,\n\t}\n\n\tassert.Equal(t, \"[GIN] 2018/12/07 - 09:11:42 | 200 |            5s |     20.20.20.20 | GET      \\\"/\\\"\\n\", defaultLogFormatter(termFalseParam))\n\tassert.Equal(t, \"[GIN] 2018/12/07 - 09:11:42 | 200 |    2743h29m3s |     20.20.20.20 | GET      \\\"/\\\"\\n\", defaultLogFormatter(termFalseLongDurationParam))\n\n\tassert.Equal(t, \"[GIN] 2018/12/07 - 09:11:42 |\\x1b[97;42m 200 \\x1b[0m|            5s |     20.20.20.20 |\\x1b[97;44m GET     \\x1b[0m \\\"/\\\"\\n\", defaultLogFormatter(termTrueParam))\n\tassert.Equal(t, \"[GIN] 2018/12/07 - 09:11:42 |\\x1b[97;42m 200 \\x1b[0m|    2743h29m3s |     20.20.20.20 |\\x1b[97;44m GET     \\x1b[0m \\\"/\\\"\\n\", defaultLogFormatter(termTrueLongDurationParam))\n}\n\nfunc TestColorForMethod(t *testing.T) {\n\tcolorForMethod := func(method string) string {\n\t\tp := LogFormatterParams{\n\t\t\tMethod: method,\n\t\t}\n\t\treturn p.MethodColor()\n\t}\n\n\tassert.Equal(t, blue, colorForMethod(http.MethodGet), \"get should be blue\")\n\tassert.Equal(t, cyan, colorForMethod(http.MethodPost), \"post should be cyan\")\n\tassert.Equal(t, yellow, colorForMethod(http.MethodPut), \"put should be yellow\")\n\tassert.Equal(t, red, colorForMethod(http.MethodDelete), \"delete should be red\")\n\tassert.Equal(t, green, colorForMethod(\"PATCH\"), \"patch should be green\")\n\tassert.Equal(t, magenta, colorForMethod(\"HEAD\"), \"head should be magenta\")\n\tassert.Equal(t, white, colorForMethod(\"OPTIONS\"), \"options should be white\")\n\tassert.Equal(t, reset, colorForMethod(\"TRACE\"), \"trace is not defined and should be the reset color\")\n}\n\nfunc TestColorForStatus(t *testing.T) {\n\tcolorForStatus := func(code int) string {\n\t\tp := LogFormatterParams{\n\t\t\tStatusCode: code,\n\t\t}\n\t\treturn p.StatusCodeColor()\n\t}\n\n\tassert.Equal(t, white, colorForStatus(http.StatusContinue), \"1xx should be white\")\n\tassert.Equal(t, green, colorForStatus(http.StatusOK), \"2xx should be green\")\n\tassert.Equal(t, white, colorForStatus(http.StatusMovedPermanently), \"3xx should be white\")\n\tassert.Equal(t, yellow, colorForStatus(http.StatusNotFound), \"4xx should be yellow\")\n\tassert.Equal(t, red, colorForStatus(2), \"other things should be red\")\n}\n\nfunc TestResetColor(t *testing.T) {\n\tp := LogFormatterParams{}\n\tassert.Equal(t, string([]byte{27, 91, 48, 109}), p.ResetColor())\n}\n\nfunc TestIsOutputColor(t *testing.T) {\n\t// test with isTerm flag true.\n\tp := LogFormatterParams{\n\t\tisTerm: true,\n\t}\n\n\tconsoleColorMode = autoColor\n\tassert.True(t, p.IsOutputColor())\n\n\tForceConsoleColor()\n\tassert.True(t, p.IsOutputColor())\n\n\tDisableConsoleColor()\n\tassert.False(t, p.IsOutputColor())\n\n\t// test with isTerm flag false.\n\tp = LogFormatterParams{\n\t\tisTerm: false,\n\t}\n\n\tconsoleColorMode = autoColor\n\tassert.False(t, p.IsOutputColor())\n\n\tForceConsoleColor()\n\tassert.True(t, p.IsOutputColor())\n\n\tDisableConsoleColor()\n\tassert.False(t, p.IsOutputColor())\n\n\t// reset console color mode.\n\tconsoleColorMode = autoColor\n}\n\nfunc TestErrorLogger(t *testing.T) {\n\trouter := New()\n\trouter.Use(ErrorLogger())\n\trouter.GET(\"/error\", func(c *Context) {\n\t\tc.Error(errors.New(\"this is an error\")) //nolint: errcheck\n\t})\n\trouter.GET(\"/abort\", func(c *Context) {\n\t\tc.AbortWithError(http.StatusUnauthorized, errors.New(\"no authorized\")) //nolint: errcheck\n\t})\n\trouter.GET(\"/print\", func(c *Context) {\n\t\tc.Error(errors.New(\"this is an error\")) //nolint: errcheck\n\t\tc.String(http.StatusInternalServerError, \"hola!\")\n\t})\n\n\tw := PerformRequest(router, http.MethodGet, \"/error\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"{\\\"error\\\":\\\"this is an error\\\"}\", w.Body.String())\n\n\tw = PerformRequest(router, http.MethodGet, \"/abort\")\n\tassert.Equal(t, http.StatusUnauthorized, w.Code)\n\tassert.Equal(t, \"{\\\"error\\\":\\\"no authorized\\\"}\", w.Body.String())\n\n\tw = PerformRequest(router, http.MethodGet, \"/print\")\n\tassert.Equal(t, http.StatusInternalServerError, w.Code)\n\tassert.Equal(t, \"hola!{\\\"error\\\":\\\"this is an error\\\"}\", w.Body.String())\n}\n\nfunc TestLoggerWithWriterSkippingPaths(t *testing.T) {\n\tbuffer := new(strings.Builder)\n\trouter := New()\n\trouter.Use(LoggerWithWriter(buffer, \"/skipped\"))\n\trouter.GET(\"/logged\", func(c *Context) {})\n\trouter.GET(\"/skipped\", func(c *Context) {})\n\n\tPerformRequest(router, http.MethodGet, \"/logged\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\n\tbuffer.Reset()\n\tPerformRequest(router, http.MethodGet, \"/skipped\")\n\tassert.Contains(t, buffer.String(), \"\")\n}\n\nfunc TestLoggerWithConfigSkippingPaths(t *testing.T) {\n\tbuffer := new(strings.Builder)\n\trouter := New()\n\trouter.Use(LoggerWithConfig(LoggerConfig{\n\t\tOutput:    buffer,\n\t\tSkipPaths: []string{\"/skipped\"},\n\t}))\n\trouter.GET(\"/logged\", func(c *Context) {})\n\trouter.GET(\"/skipped\", func(c *Context) {})\n\n\tPerformRequest(router, http.MethodGet, \"/logged\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\n\tbuffer.Reset()\n\tPerformRequest(router, http.MethodGet, \"/skipped\")\n\tassert.Contains(t, buffer.String(), \"\")\n}\n\nfunc TestLoggerWithConfigSkipper(t *testing.T) {\n\tbuffer := new(strings.Builder)\n\trouter := New()\n\trouter.Use(LoggerWithConfig(LoggerConfig{\n\t\tOutput: buffer,\n\t\tSkip: func(c *Context) bool {\n\t\t\treturn c.Writer.Status() == http.StatusNoContent\n\t\t},\n\t}))\n\trouter.GET(\"/logged\", func(c *Context) { c.Status(http.StatusOK) })\n\trouter.GET(\"/skipped\", func(c *Context) { c.Status(http.StatusNoContent) })\n\n\tPerformRequest(router, http.MethodGet, \"/logged\")\n\tassert.Contains(t, buffer.String(), \"200\")\n\n\tbuffer.Reset()\n\tPerformRequest(router, http.MethodGet, \"/skipped\")\n\tassert.Contains(t, buffer.String(), \"\")\n}\n\nfunc TestDisableConsoleColor(t *testing.T) {\n\tNew()\n\tassert.Equal(t, autoColor, consoleColorMode)\n\tDisableConsoleColor()\n\tassert.Equal(t, disableColor, consoleColorMode)\n\n\t// reset console color mode.\n\tconsoleColorMode = autoColor\n}\n\nfunc TestForceConsoleColor(t *testing.T) {\n\tNew()\n\tassert.Equal(t, autoColor, consoleColorMode)\n\tForceConsoleColor()\n\tassert.Equal(t, forceColor, consoleColorMode)\n\n\t// reset console color mode.\n\tconsoleColorMode = autoColor\n}\n"
        },
        {
          "name": "middleware_test.go",
          "type": "blob",
          "size": 5.2373046875,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/gin-contrib/sse\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMiddlewareGeneralCase(t *testing.T) {\n\tsignature := \"\"\n\trouter := New()\n\trouter.Use(func(c *Context) {\n\t\tsignature += \"A\"\n\t\tc.Next()\n\t\tsignature += \"B\"\n\t})\n\trouter.Use(func(c *Context) {\n\t\tsignature += \"C\"\n\t})\n\trouter.GET(\"/\", func(c *Context) {\n\t\tsignature += \"D\"\n\t})\n\trouter.NoRoute(func(c *Context) {\n\t\tsignature += \" X \"\n\t})\n\trouter.NoMethod(func(c *Context) {\n\t\tsignature += \" XX \"\n\t})\n\t// RUN\n\tw := PerformRequest(router, http.MethodGet, \"/\")\n\n\t// TEST\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"ACDB\", signature)\n}\n\nfunc TestMiddlewareNoRoute(t *testing.T) {\n\tsignature := \"\"\n\trouter := New()\n\trouter.Use(func(c *Context) {\n\t\tsignature += \"A\"\n\t\tc.Next()\n\t\tsignature += \"B\"\n\t})\n\trouter.Use(func(c *Context) {\n\t\tsignature += \"C\"\n\t\tc.Next()\n\t\tc.Next()\n\t\tc.Next()\n\t\tc.Next()\n\t\tsignature += \"D\"\n\t})\n\trouter.NoRoute(func(c *Context) {\n\t\tsignature += \"E\"\n\t\tc.Next()\n\t\tsignature += \"F\"\n\t}, func(c *Context) {\n\t\tsignature += \"G\"\n\t\tc.Next()\n\t\tsignature += \"H\"\n\t})\n\trouter.NoMethod(func(c *Context) {\n\t\tsignature += \" X \"\n\t})\n\t// RUN\n\tw := PerformRequest(router, http.MethodGet, \"/\")\n\n\t// TEST\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tassert.Equal(t, \"ACEGHFDB\", signature)\n}\n\nfunc TestMiddlewareNoMethodEnabled(t *testing.T) {\n\tsignature := \"\"\n\trouter := New()\n\trouter.HandleMethodNotAllowed = true\n\trouter.Use(func(c *Context) {\n\t\tsignature += \"A\"\n\t\tc.Next()\n\t\tsignature += \"B\"\n\t})\n\trouter.Use(func(c *Context) {\n\t\tsignature += \"C\"\n\t\tc.Next()\n\t\tsignature += \"D\"\n\t})\n\trouter.NoMethod(func(c *Context) {\n\t\tsignature += \"E\"\n\t\tc.Next()\n\t\tsignature += \"F\"\n\t}, func(c *Context) {\n\t\tsignature += \"G\"\n\t\tc.Next()\n\t\tsignature += \"H\"\n\t})\n\trouter.NoRoute(func(c *Context) {\n\t\tsignature += \" X \"\n\t})\n\trouter.POST(\"/\", func(c *Context) {\n\t\tsignature += \" XX \"\n\t})\n\t// RUN\n\tw := PerformRequest(router, http.MethodGet, \"/\")\n\n\t// TEST\n\tassert.Equal(t, http.StatusMethodNotAllowed, w.Code)\n\tassert.Equal(t, \"ACEGHFDB\", signature)\n}\n\nfunc TestMiddlewareNoMethodDisabled(t *testing.T) {\n\tsignature := \"\"\n\trouter := New()\n\n\t// NoMethod disabled\n\trouter.HandleMethodNotAllowed = false\n\n\trouter.Use(func(c *Context) {\n\t\tsignature += \"A\"\n\t\tc.Next()\n\t\tsignature += \"B\"\n\t})\n\trouter.Use(func(c *Context) {\n\t\tsignature += \"C\"\n\t\tc.Next()\n\t\tsignature += \"D\"\n\t})\n\trouter.NoMethod(func(c *Context) {\n\t\tsignature += \"E\"\n\t\tc.Next()\n\t\tsignature += \"F\"\n\t}, func(c *Context) {\n\t\tsignature += \"G\"\n\t\tc.Next()\n\t\tsignature += \"H\"\n\t})\n\trouter.NoRoute(func(c *Context) {\n\t\tsignature += \" X \"\n\t})\n\trouter.POST(\"/\", func(c *Context) {\n\t\tsignature += \" XX \"\n\t})\n\n\t// RUN\n\tw := PerformRequest(router, http.MethodGet, \"/\")\n\n\t// TEST\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tassert.Equal(t, \"AC X DB\", signature)\n}\n\nfunc TestMiddlewareAbort(t *testing.T) {\n\tsignature := \"\"\n\trouter := New()\n\trouter.Use(func(c *Context) {\n\t\tsignature += \"A\"\n\t})\n\trouter.Use(func(c *Context) {\n\t\tsignature += \"C\"\n\t\tc.AbortWithStatus(http.StatusUnauthorized)\n\t\tc.Next()\n\t\tsignature += \"D\"\n\t})\n\trouter.GET(\"/\", func(c *Context) {\n\t\tsignature += \" X \"\n\t\tc.Next()\n\t\tsignature += \" XX \"\n\t})\n\n\t// RUN\n\tw := PerformRequest(router, http.MethodGet, \"/\")\n\n\t// TEST\n\tassert.Equal(t, http.StatusUnauthorized, w.Code)\n\tassert.Equal(t, \"ACD\", signature)\n}\n\nfunc TestMiddlewareAbortHandlersChainAndNext(t *testing.T) {\n\tsignature := \"\"\n\trouter := New()\n\trouter.Use(func(c *Context) {\n\t\tsignature += \"A\"\n\t\tc.Next()\n\t\tc.AbortWithStatus(http.StatusGone)\n\t\tsignature += \"B\"\n\t})\n\trouter.GET(\"/\", func(c *Context) {\n\t\tsignature += \"C\"\n\t\tc.Next()\n\t})\n\t// RUN\n\tw := PerformRequest(router, http.MethodGet, \"/\")\n\n\t// TEST\n\tassert.Equal(t, http.StatusGone, w.Code)\n\tassert.Equal(t, \"ACB\", signature)\n}\n\n// TestFailHandlersChain - ensure that Fail interrupt used middleware in fifo order as\n// as well as Abort\nfunc TestMiddlewareFailHandlersChain(t *testing.T) {\n\t// SETUP\n\tsignature := \"\"\n\trouter := New()\n\trouter.Use(func(context *Context) {\n\t\tsignature += \"A\"\n\t\tcontext.AbortWithError(http.StatusInternalServerError, errors.New(\"foo\")) //nolint: errcheck\n\t})\n\trouter.Use(func(context *Context) {\n\t\tsignature += \"B\"\n\t\tcontext.Next()\n\t\tsignature += \"C\"\n\t})\n\t// RUN\n\tw := PerformRequest(router, http.MethodGet, \"/\")\n\n\t// TEST\n\tassert.Equal(t, http.StatusInternalServerError, w.Code)\n\tassert.Equal(t, \"A\", signature)\n}\n\nfunc TestMiddlewareWrite(t *testing.T) {\n\trouter := New()\n\trouter.Use(func(c *Context) {\n\t\tc.String(http.StatusBadRequest, \"hola\\n\")\n\t})\n\trouter.Use(func(c *Context) {\n\t\tc.XML(http.StatusBadRequest, H{\"foo\": \"bar\"})\n\t})\n\trouter.Use(func(c *Context) {\n\t\tc.JSON(http.StatusBadRequest, H{\"foo\": \"bar\"})\n\t})\n\trouter.GET(\"/\", func(c *Context) {\n\t\tc.JSON(http.StatusBadRequest, H{\"foo\": \"bar\"})\n\t}, func(c *Context) {\n\t\tc.Render(http.StatusBadRequest, sse.Event{\n\t\t\tEvent: \"test\",\n\t\t\tData:  \"message\",\n\t\t})\n\t})\n\n\tw := PerformRequest(router, http.MethodGet, \"/\")\n\n\tassert.Equal(t, http.StatusBadRequest, w.Code)\n\tassert.Equal(t, strings.Replace(\"hola\\n<map><foo>bar</foo></map>{\\\"foo\\\":\\\"bar\\\"}{\\\"foo\\\":\\\"bar\\\"}event:test\\ndata:message\\n\\n\", \" \", \"\", -1), strings.Replace(w.Body.String(), \" \", \"\", -1))\n}\n"
        },
        {
          "name": "mode.go",
          "type": "blob",
          "size": 2.3994140625,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"flag\"\n\t\"io\"\n\t\"os\"\n\t\"sync/atomic\"\n\n\t\"github.com/gin-gonic/gin/binding\"\n)\n\n// EnvGinMode indicates environment name for gin mode.\nconst EnvGinMode = \"GIN_MODE\"\n\nconst (\n\t// DebugMode indicates gin mode is debug.\n\tDebugMode = \"debug\"\n\t// ReleaseMode indicates gin mode is release.\n\tReleaseMode = \"release\"\n\t// TestMode indicates gin mode is test.\n\tTestMode = \"test\"\n)\n\nconst (\n\tdebugCode = iota\n\treleaseCode\n\ttestCode\n)\n\n// DefaultWriter is the default io.Writer used by Gin for debug output and\n// middleware output like Logger() or Recovery().\n// Note that both Logger and Recovery provides custom ways to configure their\n// output io.Writer.\n// To support coloring in Windows use:\n//\n//\timport \"github.com/mattn/go-colorable\"\n//\tgin.DefaultWriter = colorable.NewColorableStdout()\nvar DefaultWriter io.Writer = os.Stdout\n\n// DefaultErrorWriter is the default io.Writer used by Gin to debug errors\nvar DefaultErrorWriter io.Writer = os.Stderr\n\nvar ginMode int32 = debugCode\nvar modeName atomic.Value\n\nfunc init() {\n\tmode := os.Getenv(EnvGinMode)\n\tSetMode(mode)\n}\n\n// SetMode sets gin mode according to input string.\nfunc SetMode(value string) {\n\tif value == \"\" {\n\t\tif flag.Lookup(\"test.v\") != nil {\n\t\t\tvalue = TestMode\n\t\t} else {\n\t\t\tvalue = DebugMode\n\t\t}\n\t}\n\n\tswitch value {\n\tcase DebugMode, \"\":\n\t\tatomic.StoreInt32(&ginMode, debugCode)\n\tcase ReleaseMode:\n\t\tatomic.StoreInt32(&ginMode, releaseCode)\n\tcase TestMode:\n\t\tatomic.StoreInt32(&ginMode, testCode)\n\tdefault:\n\t\tpanic(\"gin mode unknown: \" + value + \" (available mode: debug release test)\")\n\t}\n\tmodeName.Store(value)\n}\n\n// DisableBindValidation closes the default validator.\nfunc DisableBindValidation() {\n\tbinding.Validator = nil\n}\n\n// EnableJsonDecoderUseNumber sets true for binding.EnableDecoderUseNumber to\n// call the UseNumber method on the JSON Decoder instance.\nfunc EnableJsonDecoderUseNumber() {\n\tbinding.EnableDecoderUseNumber = true\n}\n\n// EnableJsonDecoderDisallowUnknownFields sets true for binding.EnableDecoderDisallowUnknownFields to\n// call the DisallowUnknownFields method on the JSON Decoder instance.\nfunc EnableJsonDecoderDisallowUnknownFields() {\n\tbinding.EnableDecoderDisallowUnknownFields = true\n}\n\n// Mode returns current gin mode.\nfunc Mode() string {\n\treturn modeName.Load().(string)\n}\n"
        },
        {
          "name": "mode_test.go",
          "type": "blob",
          "size": 1.5966796875,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"os\"\n\t\"sync/atomic\"\n\t\"testing\"\n\n\t\"github.com/gin-gonic/gin/binding\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc init() {\n\tos.Setenv(EnvGinMode, TestMode)\n}\n\nfunc TestSetMode(t *testing.T) {\n\tassert.Equal(t, int32(testCode), atomic.LoadInt32(&ginMode))\n\tassert.Equal(t, TestMode, Mode())\n\tos.Unsetenv(EnvGinMode)\n\n\tSetMode(\"\")\n\tassert.Equal(t, int32(testCode), atomic.LoadInt32(&ginMode))\n\tassert.Equal(t, TestMode, Mode())\n\n\tSetMode(DebugMode)\n\tassert.Equal(t, int32(debugCode), atomic.LoadInt32(&ginMode))\n\tassert.Equal(t, DebugMode, Mode())\n\n\tSetMode(ReleaseMode)\n\tassert.Equal(t, int32(releaseCode), atomic.LoadInt32(&ginMode))\n\tassert.Equal(t, ReleaseMode, Mode())\n\n\tSetMode(TestMode)\n\tassert.Equal(t, int32(testCode), atomic.LoadInt32(&ginMode))\n\tassert.Equal(t, TestMode, Mode())\n\n\tassert.Panics(t, func() { SetMode(\"unknown\") })\n}\n\nfunc TestDisableBindValidation(t *testing.T) {\n\tv := binding.Validator\n\tassert.NotNil(t, binding.Validator)\n\tDisableBindValidation()\n\tassert.Nil(t, binding.Validator)\n\tbinding.Validator = v\n}\n\nfunc TestEnableJsonDecoderUseNumber(t *testing.T) {\n\tassert.False(t, binding.EnableDecoderUseNumber)\n\tEnableJsonDecoderUseNumber()\n\tassert.True(t, binding.EnableDecoderUseNumber)\n}\n\nfunc TestEnableJsonDecoderDisallowUnknownFields(t *testing.T) {\n\tassert.False(t, binding.EnableDecoderDisallowUnknownFields)\n\tEnableJsonDecoderDisallowUnknownFields()\n\tassert.True(t, binding.EnableDecoderDisallowUnknownFields)\n}\n"
        },
        {
          "name": "path.go",
          "type": "blob",
          "size": 3.6044921875,
          "content": "// Copyright 2013 Julien Schmidt. All rights reserved.\n// Based on the path package, Copyright 2009 The Go Authors.\n// Use of this source code is governed by a BSD-style license that can be found\n// at https://github.com/julienschmidt/httprouter/blob/master/LICENSE.\n\npackage gin\n\n// cleanPath is the URL version of path.Clean, it returns a canonical URL path\n// for p, eliminating . and .. elements.\n//\n// The following rules are applied iteratively until no further processing can\n// be done:\n//  1. Replace multiple slashes with a single slash.\n//  2. Eliminate each . path name element (the current directory).\n//  3. Eliminate each inner .. path name element (the parent directory)\n//     along with the non-.. element that precedes it.\n//  4. Eliminate .. elements that begin a rooted path:\n//     that is, replace \"/..\" by \"/\" at the beginning of a path.\n//\n// If the result of this process is an empty string, \"/\" is returned.\nfunc cleanPath(p string) string {\n\tconst stackBufSize = 128\n\t// Turn empty string into \"/\"\n\tif p == \"\" {\n\t\treturn \"/\"\n\t}\n\n\t// Reasonably sized buffer on stack to avoid allocations in the common case.\n\t// If a larger buffer is required, it gets allocated dynamically.\n\tbuf := make([]byte, 0, stackBufSize)\n\n\tn := len(p)\n\n\t// Invariants:\n\t//      reading from path; r is index of next byte to process.\n\t//      writing to buf; w is index of next byte to write.\n\n\t// path must start with '/'\n\tr := 1\n\tw := 1\n\n\tif p[0] != '/' {\n\t\tr = 0\n\n\t\tif n+1 > stackBufSize {\n\t\t\tbuf = make([]byte, n+1)\n\t\t} else {\n\t\t\tbuf = buf[:n+1]\n\t\t}\n\t\tbuf[0] = '/'\n\t}\n\n\ttrailing := n > 1 && p[n-1] == '/'\n\n\t// A bit more clunky without a 'lazybuf' like the path package, but the loop\n\t// gets completely inlined (bufApp calls).\n\t// loop has no expensive function calls (except 1x make)\t\t// So in contrast to the path package this loop has no expensive function\n\t// calls (except make, if needed).\n\n\tfor r < n {\n\t\tswitch {\n\t\tcase p[r] == '/':\n\t\t\t// empty path element, trailing slash is added after the end\n\t\t\tr++\n\n\t\tcase p[r] == '.' && r+1 == n:\n\t\t\ttrailing = true\n\t\t\tr++\n\n\t\tcase p[r] == '.' && p[r+1] == '/':\n\t\t\t// . element\n\t\t\tr += 2\n\n\t\tcase p[r] == '.' && p[r+1] == '.' && (r+2 == n || p[r+2] == '/'):\n\t\t\t// .. element: remove to last /\n\t\t\tr += 3\n\n\t\t\tif w > 1 {\n\t\t\t\t// can backtrack\n\t\t\t\tw--\n\n\t\t\t\tif len(buf) == 0 {\n\t\t\t\t\tfor w > 1 && p[w] != '/' {\n\t\t\t\t\t\tw--\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor w > 1 && buf[w] != '/' {\n\t\t\t\t\t\tw--\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tdefault:\n\t\t\t// Real path element.\n\t\t\t// Add slash if needed\n\t\t\tif w > 1 {\n\t\t\t\tbufApp(&buf, p, w, '/')\n\t\t\t\tw++\n\t\t\t}\n\n\t\t\t// Copy element\n\t\t\tfor r < n && p[r] != '/' {\n\t\t\t\tbufApp(&buf, p, w, p[r])\n\t\t\t\tw++\n\t\t\t\tr++\n\t\t\t}\n\t\t}\n\t}\n\n\t// Re-append trailing slash\n\tif trailing && w > 1 {\n\t\tbufApp(&buf, p, w, '/')\n\t\tw++\n\t}\n\n\t// If the original string was not modified (or only shortened at the end),\n\t// return the respective substring of the original string.\n\t// Otherwise return a new string from the buffer.\n\tif len(buf) == 0 {\n\t\treturn p[:w]\n\t}\n\treturn string(buf[:w])\n}\n\n// Internal helper to lazily create a buffer if necessary.\n// Calls to this function get inlined.\nfunc bufApp(buf *[]byte, s string, w int, c byte) {\n\tb := *buf\n\tif len(b) == 0 {\n\t\t// No modification of the original string so far.\n\t\t// If the next character is the same as in the original string, we do\n\t\t// not yet have to allocate a buffer.\n\t\tif s[w] == c {\n\t\t\treturn\n\t\t}\n\n\t\t// Otherwise use either the stack buffer, if it is large enough, or\n\t\t// allocate a new buffer on the heap, and copy all previous characters.\n\t\tlength := len(s)\n\t\tif length > cap(b) {\n\t\t\t*buf = make([]byte, length)\n\t\t} else {\n\t\t\t*buf = (*buf)[:length]\n\t\t}\n\t\tb = *buf\n\n\t\tcopy(b, s[:w])\n\t}\n\tb[w] = c\n}\n"
        },
        {
          "name": "path_test.go",
          "type": "blob",
          "size": 2.99609375,
          "content": "// Copyright 2013 Julien Schmidt. All rights reserved.\n// Based on the path package, Copyright 2009 The Go Authors.\n// Use of this source code is governed by a BSD-style license that can be found\n// at https://github.com/julienschmidt/httprouter/blob/master/LICENSE\n\npackage gin\n\nimport (\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype cleanPathTest struct {\n\tpath, result string\n}\n\nvar cleanTests = []cleanPathTest{\n\t// Already clean\n\t{\"/\", \"/\"},\n\t{\"/abc\", \"/abc\"},\n\t{\"/a/b/c\", \"/a/b/c\"},\n\t{\"/abc/\", \"/abc/\"},\n\t{\"/a/b/c/\", \"/a/b/c/\"},\n\n\t// missing root\n\t{\"\", \"/\"},\n\t{\"a/\", \"/a/\"},\n\t{\"abc\", \"/abc\"},\n\t{\"abc/def\", \"/abc/def\"},\n\t{\"a/b/c\", \"/a/b/c\"},\n\n\t// Remove doubled slash\n\t{\"//\", \"/\"},\n\t{\"/abc//\", \"/abc/\"},\n\t{\"/abc/def//\", \"/abc/def/\"},\n\t{\"/a/b/c//\", \"/a/b/c/\"},\n\t{\"/abc//def//ghi\", \"/abc/def/ghi\"},\n\t{\"//abc\", \"/abc\"},\n\t{\"///abc\", \"/abc\"},\n\t{\"//abc//\", \"/abc/\"},\n\n\t// Remove . elements\n\t{\".\", \"/\"},\n\t{\"./\", \"/\"},\n\t{\"/abc/./def\", \"/abc/def\"},\n\t{\"/./abc/def\", \"/abc/def\"},\n\t{\"/abc/.\", \"/abc/\"},\n\n\t// Remove .. elements\n\t{\"..\", \"/\"},\n\t{\"../\", \"/\"},\n\t{\"../../\", \"/\"},\n\t{\"../..\", \"/\"},\n\t{\"../../abc\", \"/abc\"},\n\t{\"/abc/def/ghi/../jkl\", \"/abc/def/jkl\"},\n\t{\"/abc/def/../ghi/../jkl\", \"/abc/jkl\"},\n\t{\"/abc/def/..\", \"/abc\"},\n\t{\"/abc/def/../..\", \"/\"},\n\t{\"/abc/def/../../..\", \"/\"},\n\t{\"/abc/def/../../..\", \"/\"},\n\t{\"/abc/def/../../../ghi/jkl/../../../mno\", \"/mno\"},\n\n\t// Combinations\n\t{\"abc/./../def\", \"/def\"},\n\t{\"abc//./../def\", \"/def\"},\n\t{\"abc/../../././../def\", \"/def\"},\n}\n\nfunc TestPathClean(t *testing.T) {\n\tfor _, test := range cleanTests {\n\t\tassert.Equal(t, test.result, cleanPath(test.path))\n\t\tassert.Equal(t, test.result, cleanPath(test.result))\n\t}\n}\n\nfunc TestPathCleanMallocs(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping malloc count in short mode\")\n\t}\n\n\tif runtime.GOMAXPROCS(0) > 1 {\n\t\tt.Skip(\"skipping malloc count; GOMAXPROCS>1\")\n\t}\n\n\tfor _, test := range cleanTests {\n\t\tallocs := testing.AllocsPerRun(100, func() { cleanPath(test.result) })\n\t\tassert.InDelta(t, 0, allocs, 0.01)\n\t}\n}\n\nfunc BenchmarkPathClean(b *testing.B) {\n\tb.ReportAllocs()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, test := range cleanTests {\n\t\t\tcleanPath(test.path)\n\t\t}\n\t}\n}\n\nfunc genLongPaths() (testPaths []cleanPathTest) {\n\tfor i := 1; i <= 1234; i++ {\n\t\tss := strings.Repeat(\"a\", i)\n\n\t\tcorrectPath := \"/\" + ss\n\t\ttestPaths = append(testPaths, cleanPathTest{\n\t\t\tpath:   correctPath,\n\t\t\tresult: correctPath,\n\t\t}, cleanPathTest{\n\t\t\tpath:   ss,\n\t\t\tresult: correctPath,\n\t\t}, cleanPathTest{\n\t\t\tpath:   \"//\" + ss,\n\t\t\tresult: correctPath,\n\t\t}, cleanPathTest{\n\t\t\tpath:   \"/\" + ss + \"/b/..\",\n\t\t\tresult: correctPath,\n\t\t})\n\t}\n\treturn\n}\n\nfunc TestPathCleanLong(t *testing.T) {\n\tcleanTests := genLongPaths()\n\n\tfor _, test := range cleanTests {\n\t\tassert.Equal(t, test.result, cleanPath(test.path))\n\t\tassert.Equal(t, test.result, cleanPath(test.result))\n\t}\n}\n\nfunc BenchmarkPathCleanLong(b *testing.B) {\n\tcleanTests := genLongPaths()\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, test := range cleanTests {\n\t\t\tcleanPath(test.path)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "recovery.go",
          "type": "blob",
          "size": 5.0849609375,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar (\n\tdunno     = []byte(\"???\")\n\tcenterDot = []byte(\"¬∑\")\n\tdot       = []byte(\".\")\n\tslash     = []byte(\"/\")\n)\n\n// RecoveryFunc defines the function passable to CustomRecovery.\ntype RecoveryFunc func(c *Context, err any)\n\n// Recovery returns a middleware that recovers from any panics and writes a 500 if there was one.\nfunc Recovery() HandlerFunc {\n\treturn RecoveryWithWriter(DefaultErrorWriter)\n}\n\n// CustomRecovery returns a middleware that recovers from any panics and calls the provided handle func to handle it.\nfunc CustomRecovery(handle RecoveryFunc) HandlerFunc {\n\treturn RecoveryWithWriter(DefaultErrorWriter, handle)\n}\n\n// RecoveryWithWriter returns a middleware for a given writer that recovers from any panics and writes a 500 if there was one.\nfunc RecoveryWithWriter(out io.Writer, recovery ...RecoveryFunc) HandlerFunc {\n\tif len(recovery) > 0 {\n\t\treturn CustomRecoveryWithWriter(out, recovery[0])\n\t}\n\treturn CustomRecoveryWithWriter(out, defaultHandleRecovery)\n}\n\n// CustomRecoveryWithWriter returns a middleware for a given writer that recovers from any panics and calls the provided handle func to handle it.\nfunc CustomRecoveryWithWriter(out io.Writer, handle RecoveryFunc) HandlerFunc {\n\tvar logger *log.Logger\n\tif out != nil {\n\t\tlogger = log.New(out, \"\\n\\n\\x1b[31m\", log.LstdFlags)\n\t}\n\treturn func(c *Context) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\t// Check for a broken connection, as it is not really a\n\t\t\t\t// condition that warrants a panic stack trace.\n\t\t\t\tvar brokenPipe bool\n\t\t\t\tif ne, ok := err.(*net.OpError); ok {\n\t\t\t\t\tvar se *os.SyscallError\n\t\t\t\t\tif errors.As(ne, &se) {\n\t\t\t\t\t\tseStr := strings.ToLower(se.Error())\n\t\t\t\t\t\tif strings.Contains(seStr, \"broken pipe\") ||\n\t\t\t\t\t\t\tstrings.Contains(seStr, \"connection reset by peer\") {\n\t\t\t\t\t\t\tbrokenPipe = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif logger != nil {\n\t\t\t\t\tstack := stack(3)\n\t\t\t\t\thttpRequest, _ := httputil.DumpRequest(c.Request, false)\n\t\t\t\t\theaders := strings.Split(string(httpRequest), \"\\r\\n\")\n\t\t\t\t\tfor idx, header := range headers {\n\t\t\t\t\t\tcurrent := strings.Split(header, \":\")\n\t\t\t\t\t\tif current[0] == \"Authorization\" {\n\t\t\t\t\t\t\theaders[idx] = current[0] + \": *\"\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\theadersToStr := strings.Join(headers, \"\\r\\n\")\n\t\t\t\t\tif brokenPipe {\n\t\t\t\t\t\tlogger.Printf(\"%s\\n%s%s\", err, headersToStr, reset)\n\t\t\t\t\t} else if IsDebugging() {\n\t\t\t\t\t\tlogger.Printf(\"[Recovery] %s panic recovered:\\n%s\\n%s\\n%s%s\",\n\t\t\t\t\t\t\ttimeFormat(time.Now()), headersToStr, err, stack, reset)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.Printf(\"[Recovery] %s panic recovered:\\n%s\\n%s%s\",\n\t\t\t\t\t\t\ttimeFormat(time.Now()), err, stack, reset)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif brokenPipe {\n\t\t\t\t\t// If the connection is dead, we can't write a status to it.\n\t\t\t\t\tc.Error(err.(error)) //nolint: errcheck\n\t\t\t\t\tc.Abort()\n\t\t\t\t} else {\n\t\t\t\t\thandle(c, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tc.Next()\n\t}\n}\n\nfunc defaultHandleRecovery(c *Context, _ any) {\n\tc.AbortWithStatus(http.StatusInternalServerError)\n}\n\n// stack returns a nicely formatted stack frame, skipping skip frames.\nfunc stack(skip int) []byte {\n\tbuf := new(bytes.Buffer) // the returned data\n\t// As we loop, we open files and read them. These variables record the currently\n\t// loaded file.\n\tvar lines [][]byte\n\tvar lastFile string\n\tfor i := skip; ; i++ { // Skip the expected number of frames\n\t\tpc, file, line, ok := runtime.Caller(i)\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\t// Print this much at least.  If we can't find the source, it won't show.\n\t\tfmt.Fprintf(buf, \"%s:%d (0x%x)\\n\", file, line, pc)\n\t\tif file != lastFile {\n\t\t\tdata, err := os.ReadFile(file)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlines = bytes.Split(data, []byte{'\\n'})\n\t\t\tlastFile = file\n\t\t}\n\t\tfmt.Fprintf(buf, \"\\t%s: %s\\n\", function(pc), source(lines, line))\n\t}\n\treturn buf.Bytes()\n}\n\n// source returns a space-trimmed slice of the n'th line.\nfunc source(lines [][]byte, n int) []byte {\n\tn-- // in stack trace, lines are 1-indexed but our array is 0-indexed\n\tif n < 0 || n >= len(lines) {\n\t\treturn dunno\n\t}\n\treturn bytes.TrimSpace(lines[n])\n}\n\n// function returns, if possible, the name of the function containing the PC.\nfunc function(pc uintptr) []byte {\n\tfn := runtime.FuncForPC(pc)\n\tif fn == nil {\n\t\treturn dunno\n\t}\n\tname := []byte(fn.Name())\n\t// The name includes the path name to the package, which is unnecessary\n\t// since the file name is already included.  Plus, it has center dots.\n\t// That is, we see\n\t//\truntime/debug.*T¬∑ptrmethod\n\t// and want\n\t//\t*T.ptrmethod\n\t// Also the package path might contain dot (e.g. code.google.com/...),\n\t// so first eliminate the path prefix\n\tif lastSlash := bytes.LastIndex(name, slash); lastSlash >= 0 {\n\t\tname = name[lastSlash+1:]\n\t}\n\tif period := bytes.Index(name, dot); period >= 0 {\n\t\tname = name[period+1:]\n\t}\n\tname = bytes.ReplaceAll(name, centerDot, dot)\n\treturn name\n}\n\n// timeFormat returns a customized time string for logger.\nfunc timeFormat(t time.Time) string {\n\treturn t.Format(\"2006/01/02 - 15:04:05\")\n}\n"
        },
        {
          "name": "recovery_test.go",
          "type": "blob",
          "size": 6.9169921875,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\t\"syscall\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestPanicClean(t *testing.T) {\n\tbuffer := new(strings.Builder)\n\trouter := New()\n\tpassword := \"my-super-secret-password\"\n\trouter.Use(RecoveryWithWriter(buffer))\n\trouter.GET(\"/recovery\", func(c *Context) {\n\t\tc.AbortWithStatus(http.StatusBadRequest)\n\t\tpanic(\"Oupps, Houston, we have a problem\")\n\t})\n\t// RUN\n\tw := PerformRequest(router, http.MethodGet, \"/recovery\",\n\t\theader{\n\t\t\tKey:   \"Host\",\n\t\t\tValue: \"www.google.com\",\n\t\t},\n\t\theader{\n\t\t\tKey:   \"Authorization\",\n\t\t\tValue: \"Bearer \" + password,\n\t\t},\n\t\theader{\n\t\t\tKey:   \"Content-Type\",\n\t\t\tValue: \"application/json\",\n\t\t},\n\t)\n\t// TEST\n\tassert.Equal(t, http.StatusBadRequest, w.Code)\n\n\t// Check the buffer does not have the secret key\n\tassert.NotContains(t, buffer.String(), password)\n}\n\n// TestPanicInHandler assert that panic has been recovered.\nfunc TestPanicInHandler(t *testing.T) {\n\tbuffer := new(strings.Builder)\n\trouter := New()\n\trouter.Use(RecoveryWithWriter(buffer))\n\trouter.GET(\"/recovery\", func(_ *Context) {\n\t\tpanic(\"Oupps, Houston, we have a problem\")\n\t})\n\t// RUN\n\tw := PerformRequest(router, http.MethodGet, \"/recovery\")\n\t// TEST\n\tassert.Equal(t, http.StatusInternalServerError, w.Code)\n\tassert.Contains(t, buffer.String(), \"panic recovered\")\n\tassert.Contains(t, buffer.String(), \"Oupps, Houston, we have a problem\")\n\tassert.Contains(t, buffer.String(), t.Name())\n\tassert.NotContains(t, buffer.String(), \"GET /recovery\")\n\n\t// Debug mode prints the request\n\tSetMode(DebugMode)\n\t// RUN\n\tw = PerformRequest(router, http.MethodGet, \"/recovery\")\n\t// TEST\n\tassert.Equal(t, http.StatusInternalServerError, w.Code)\n\tassert.Contains(t, buffer.String(), \"GET /recovery\")\n\n\tSetMode(TestMode)\n}\n\n// TestPanicWithAbort assert that panic has been recovered even if context.Abort was used.\nfunc TestPanicWithAbort(t *testing.T) {\n\trouter := New()\n\trouter.Use(RecoveryWithWriter(nil))\n\trouter.GET(\"/recovery\", func(c *Context) {\n\t\tc.AbortWithStatus(http.StatusBadRequest)\n\t\tpanic(\"Oupps, Houston, we have a problem\")\n\t})\n\t// RUN\n\tw := PerformRequest(router, http.MethodGet, \"/recovery\")\n\t// TEST\n\tassert.Equal(t, http.StatusBadRequest, w.Code)\n}\n\nfunc TestSource(t *testing.T) {\n\tbs := source(nil, 0)\n\tassert.Equal(t, dunno, bs)\n\n\tin := [][]byte{\n\t\t[]byte(\"Hello world.\"),\n\t\t[]byte(\"Hi, gin..\"),\n\t}\n\tbs = source(in, 10)\n\tassert.Equal(t, dunno, bs)\n\n\tbs = source(in, 1)\n\tassert.Equal(t, []byte(\"Hello world.\"), bs)\n}\n\nfunc TestFunction(t *testing.T) {\n\tbs := function(1)\n\tassert.Equal(t, dunno, bs)\n}\n\n// TestPanicWithBrokenPipe asserts that recovery specifically handles\n// writing responses to broken pipes\nfunc TestPanicWithBrokenPipe(t *testing.T) {\n\tconst expectCode = 204\n\n\texpectMsgs := map[syscall.Errno]string{\n\t\tsyscall.EPIPE:      \"broken pipe\",\n\t\tsyscall.ECONNRESET: \"connection reset by peer\",\n\t}\n\n\tfor errno, expectMsg := range expectMsgs {\n\t\tt.Run(expectMsg, func(t *testing.T) {\n\t\t\tvar buf strings.Builder\n\n\t\t\trouter := New()\n\t\t\trouter.Use(RecoveryWithWriter(&buf))\n\t\t\trouter.GET(\"/recovery\", func(c *Context) {\n\t\t\t\t// Start writing response\n\t\t\t\tc.Header(\"X-Test\", \"Value\")\n\t\t\t\tc.Status(expectCode)\n\n\t\t\t\t// Oops. Client connection closed\n\t\t\t\te := &net.OpError{Err: &os.SyscallError{Err: errno}}\n\t\t\t\tpanic(e)\n\t\t\t})\n\t\t\t// RUN\n\t\t\tw := PerformRequest(router, http.MethodGet, \"/recovery\")\n\t\t\t// TEST\n\t\t\tassert.Equal(t, expectCode, w.Code)\n\t\t\tassert.Contains(t, strings.ToLower(buf.String()), expectMsg)\n\t\t})\n\t}\n}\n\nfunc TestCustomRecoveryWithWriter(t *testing.T) {\n\terrBuffer := new(strings.Builder)\n\tbuffer := new(strings.Builder)\n\trouter := New()\n\thandleRecovery := func(c *Context, err any) {\n\t\terrBuffer.WriteString(err.(string))\n\t\tc.AbortWithStatus(http.StatusBadRequest)\n\t}\n\trouter.Use(CustomRecoveryWithWriter(buffer, handleRecovery))\n\trouter.GET(\"/recovery\", func(_ *Context) {\n\t\tpanic(\"Oupps, Houston, we have a problem\")\n\t})\n\t// RUN\n\tw := PerformRequest(router, http.MethodGet, \"/recovery\")\n\t// TEST\n\tassert.Equal(t, http.StatusBadRequest, w.Code)\n\tassert.Contains(t, buffer.String(), \"panic recovered\")\n\tassert.Contains(t, buffer.String(), \"Oupps, Houston, we have a problem\")\n\tassert.Contains(t, buffer.String(), t.Name())\n\tassert.NotContains(t, buffer.String(), \"GET /recovery\")\n\n\t// Debug mode prints the request\n\tSetMode(DebugMode)\n\t// RUN\n\tw = PerformRequest(router, http.MethodGet, \"/recovery\")\n\t// TEST\n\tassert.Equal(t, http.StatusBadRequest, w.Code)\n\tassert.Contains(t, buffer.String(), \"GET /recovery\")\n\n\tassert.Equal(t, strings.Repeat(\"Oupps, Houston, we have a problem\", 2), errBuffer.String())\n\n\tSetMode(TestMode)\n}\n\nfunc TestCustomRecovery(t *testing.T) {\n\terrBuffer := new(strings.Builder)\n\tbuffer := new(strings.Builder)\n\trouter := New()\n\tDefaultErrorWriter = buffer\n\thandleRecovery := func(c *Context, err any) {\n\t\terrBuffer.WriteString(err.(string))\n\t\tc.AbortWithStatus(http.StatusBadRequest)\n\t}\n\trouter.Use(CustomRecovery(handleRecovery))\n\trouter.GET(\"/recovery\", func(_ *Context) {\n\t\tpanic(\"Oupps, Houston, we have a problem\")\n\t})\n\t// RUN\n\tw := PerformRequest(router, http.MethodGet, \"/recovery\")\n\t// TEST\n\tassert.Equal(t, http.StatusBadRequest, w.Code)\n\tassert.Contains(t, buffer.String(), \"panic recovered\")\n\tassert.Contains(t, buffer.String(), \"Oupps, Houston, we have a problem\")\n\tassert.Contains(t, buffer.String(), t.Name())\n\tassert.NotContains(t, buffer.String(), \"GET /recovery\")\n\n\t// Debug mode prints the request\n\tSetMode(DebugMode)\n\t// RUN\n\tw = PerformRequest(router, http.MethodGet, \"/recovery\")\n\t// TEST\n\tassert.Equal(t, http.StatusBadRequest, w.Code)\n\tassert.Contains(t, buffer.String(), \"GET /recovery\")\n\n\tassert.Equal(t, strings.Repeat(\"Oupps, Houston, we have a problem\", 2), errBuffer.String())\n\n\tSetMode(TestMode)\n}\n\nfunc TestRecoveryWithWriterWithCustomRecovery(t *testing.T) {\n\terrBuffer := new(strings.Builder)\n\tbuffer := new(strings.Builder)\n\trouter := New()\n\tDefaultErrorWriter = buffer\n\thandleRecovery := func(c *Context, err any) {\n\t\terrBuffer.WriteString(err.(string))\n\t\tc.AbortWithStatus(http.StatusBadRequest)\n\t}\n\trouter.Use(RecoveryWithWriter(DefaultErrorWriter, handleRecovery))\n\trouter.GET(\"/recovery\", func(_ *Context) {\n\t\tpanic(\"Oupps, Houston, we have a problem\")\n\t})\n\t// RUN\n\tw := PerformRequest(router, http.MethodGet, \"/recovery\")\n\t// TEST\n\tassert.Equal(t, http.StatusBadRequest, w.Code)\n\tassert.Contains(t, buffer.String(), \"panic recovered\")\n\tassert.Contains(t, buffer.String(), \"Oupps, Houston, we have a problem\")\n\tassert.Contains(t, buffer.String(), t.Name())\n\tassert.NotContains(t, buffer.String(), \"GET /recovery\")\n\n\t// Debug mode prints the request\n\tSetMode(DebugMode)\n\t// RUN\n\tw = PerformRequest(router, http.MethodGet, \"/recovery\")\n\t// TEST\n\tassert.Equal(t, http.StatusBadRequest, w.Code)\n\tassert.Contains(t, buffer.String(), \"GET /recovery\")\n\n\tassert.Equal(t, strings.Repeat(\"Oupps, Houston, we have a problem\", 2), errBuffer.String())\n\n\tSetMode(TestMode)\n}\n"
        },
        {
          "name": "render",
          "type": "tree",
          "content": null
        },
        {
          "name": "response_writer.go",
          "type": "blob",
          "size": 2.787109375,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n)\n\nconst (\n\tnoWritten     = -1\n\tdefaultStatus = http.StatusOK\n)\n\n// ResponseWriter ...\ntype ResponseWriter interface {\n\thttp.ResponseWriter\n\thttp.Hijacker\n\thttp.Flusher\n\thttp.CloseNotifier\n\n\t// Status returns the HTTP response status code of the current request.\n\tStatus() int\n\n\t// Size returns the number of bytes already written into the response http body.\n\t// See Written()\n\tSize() int\n\n\t// WriteString writes the string into the response body.\n\tWriteString(string) (int, error)\n\n\t// Written returns true if the response body was already written.\n\tWritten() bool\n\n\t// WriteHeaderNow forces to write the http header (status code + headers).\n\tWriteHeaderNow()\n\n\t// Pusher get the http.Pusher for server push\n\tPusher() http.Pusher\n}\n\ntype responseWriter struct {\n\thttp.ResponseWriter\n\tsize   int\n\tstatus int\n}\n\nvar _ ResponseWriter = (*responseWriter)(nil)\n\nfunc (w *responseWriter) Unwrap() http.ResponseWriter {\n\treturn w.ResponseWriter\n}\n\nfunc (w *responseWriter) reset(writer http.ResponseWriter) {\n\tw.ResponseWriter = writer\n\tw.size = noWritten\n\tw.status = defaultStatus\n}\n\nfunc (w *responseWriter) WriteHeader(code int) {\n\tif code > 0 && w.status != code {\n\t\tif w.Written() {\n\t\t\tdebugPrint(\"[WARNING] Headers were already written. Wanted to override status code %d with %d\", w.status, code)\n\t\t\treturn\n\t\t}\n\t\tw.status = code\n\t}\n}\n\nfunc (w *responseWriter) WriteHeaderNow() {\n\tif !w.Written() {\n\t\tw.size = 0\n\t\tw.ResponseWriter.WriteHeader(w.status)\n\t}\n}\n\nfunc (w *responseWriter) Write(data []byte) (n int, err error) {\n\tw.WriteHeaderNow()\n\tn, err = w.ResponseWriter.Write(data)\n\tw.size += n\n\treturn\n}\n\nfunc (w *responseWriter) WriteString(s string) (n int, err error) {\n\tw.WriteHeaderNow()\n\tn, err = io.WriteString(w.ResponseWriter, s)\n\tw.size += n\n\treturn\n}\n\nfunc (w *responseWriter) Status() int {\n\treturn w.status\n}\n\nfunc (w *responseWriter) Size() int {\n\treturn w.size\n}\n\nfunc (w *responseWriter) Written() bool {\n\treturn w.size != noWritten\n}\n\n// Hijack implements the http.Hijacker interface.\nfunc (w *responseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\tif w.size < 0 {\n\t\tw.size = 0\n\t}\n\treturn w.ResponseWriter.(http.Hijacker).Hijack()\n}\n\n// CloseNotify implements the http.CloseNotifier interface.\nfunc (w *responseWriter) CloseNotify() <-chan bool {\n\treturn w.ResponseWriter.(http.CloseNotifier).CloseNotify()\n}\n\n// Flush implements the http.Flusher interface.\nfunc (w *responseWriter) Flush() {\n\tw.WriteHeaderNow()\n\tw.ResponseWriter.(http.Flusher).Flush()\n}\n\nfunc (w *responseWriter) Pusher() (pusher http.Pusher) {\n\tif pusher, ok := w.ResponseWriter.(http.Pusher); ok {\n\t\treturn pusher\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "response_writer_test.go",
          "type": "blob",
          "size": 4.8642578125,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n// TODO\n// func (w *responseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n// func (w *responseWriter) CloseNotify() <-chan bool {\n// func (w *responseWriter) Flush() {\n\nvar (\n\t_ ResponseWriter      = &responseWriter{}\n\t_ http.ResponseWriter = &responseWriter{}\n\t_ http.ResponseWriter = ResponseWriter(&responseWriter{})\n\t_ http.Hijacker       = ResponseWriter(&responseWriter{})\n\t_ http.Flusher        = ResponseWriter(&responseWriter{})\n\t_ http.CloseNotifier  = ResponseWriter(&responseWriter{})\n)\n\nfunc init() {\n\tSetMode(TestMode)\n}\n\nfunc TestResponseWriterUnwrap(t *testing.T) {\n\ttestWriter := httptest.NewRecorder()\n\twriter := &responseWriter{ResponseWriter: testWriter}\n\tassert.Same(t, testWriter, writer.Unwrap())\n}\n\nfunc TestResponseWriterReset(t *testing.T) {\n\ttestWriter := httptest.NewRecorder()\n\twriter := &responseWriter{}\n\tvar w ResponseWriter = writer\n\n\twriter.reset(testWriter)\n\tassert.Equal(t, -1, writer.size)\n\tassert.Equal(t, http.StatusOK, writer.status)\n\tassert.Equal(t, testWriter, writer.ResponseWriter)\n\tassert.Equal(t, -1, w.Size())\n\tassert.Equal(t, http.StatusOK, w.Status())\n\tassert.False(t, w.Written())\n}\n\nfunc TestResponseWriterWriteHeader(t *testing.T) {\n\ttestWriter := httptest.NewRecorder()\n\twriter := &responseWriter{}\n\twriter.reset(testWriter)\n\tw := ResponseWriter(writer)\n\n\tw.WriteHeader(http.StatusMultipleChoices)\n\tassert.False(t, w.Written())\n\tassert.Equal(t, http.StatusMultipleChoices, w.Status())\n\tassert.NotEqual(t, http.StatusMultipleChoices, testWriter.Code)\n\n\tw.WriteHeader(-1)\n\tassert.Equal(t, http.StatusMultipleChoices, w.Status())\n}\n\nfunc TestResponseWriterWriteHeadersNow(t *testing.T) {\n\ttestWriter := httptest.NewRecorder()\n\twriter := &responseWriter{}\n\twriter.reset(testWriter)\n\tw := ResponseWriter(writer)\n\n\tw.WriteHeader(http.StatusMultipleChoices)\n\tw.WriteHeaderNow()\n\n\tassert.True(t, w.Written())\n\tassert.Equal(t, 0, w.Size())\n\tassert.Equal(t, http.StatusMultipleChoices, testWriter.Code)\n\n\twriter.size = 10\n\tw.WriteHeaderNow()\n\tassert.Equal(t, 10, w.Size())\n}\n\nfunc TestResponseWriterWrite(t *testing.T) {\n\ttestWriter := httptest.NewRecorder()\n\twriter := &responseWriter{}\n\twriter.reset(testWriter)\n\tw := ResponseWriter(writer)\n\n\tn, err := w.Write([]byte(\"hola\"))\n\tassert.Equal(t, 4, n)\n\tassert.Equal(t, 4, w.Size())\n\tassert.Equal(t, http.StatusOK, w.Status())\n\tassert.Equal(t, http.StatusOK, testWriter.Code)\n\tassert.Equal(t, \"hola\", testWriter.Body.String())\n\trequire.NoError(t, err)\n\n\tn, err = w.Write([]byte(\" adios\"))\n\tassert.Equal(t, 6, n)\n\tassert.Equal(t, 10, w.Size())\n\tassert.Equal(t, \"hola adios\", testWriter.Body.String())\n\trequire.NoError(t, err)\n}\n\nfunc TestResponseWriterHijack(t *testing.T) {\n\ttestWriter := httptest.NewRecorder()\n\twriter := &responseWriter{}\n\twriter.reset(testWriter)\n\tw := ResponseWriter(writer)\n\n\tassert.Panics(t, func() {\n\t\t_, _, err := w.Hijack()\n\t\trequire.NoError(t, err)\n\t})\n\tassert.True(t, w.Written())\n\n\tassert.Panics(t, func() {\n\t\tw.CloseNotify()\n\t})\n\n\tw.Flush()\n}\n\nfunc TestResponseWriterFlush(t *testing.T) {\n\ttestServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\twriter := &responseWriter{}\n\t\twriter.reset(w)\n\n\t\twriter.WriteHeader(http.StatusInternalServerError)\n\t\twriter.Flush()\n\t}))\n\tdefer testServer.Close()\n\n\t// should return 500\n\tresp, err := http.Get(testServer.URL)\n\trequire.NoError(t, err)\n\tassert.Equal(t, http.StatusInternalServerError, resp.StatusCode)\n}\n\nfunc TestResponseWriterStatusCode(t *testing.T) {\n\ttestWriter := httptest.NewRecorder()\n\twriter := &responseWriter{}\n\twriter.reset(testWriter)\n\tw := ResponseWriter(writer)\n\n\tw.WriteHeader(http.StatusOK)\n\tw.WriteHeaderNow()\n\n\tassert.Equal(t, http.StatusOK, w.Status())\n\tassert.True(t, w.Written())\n\n\tw.WriteHeader(http.StatusUnauthorized)\n\n\t// status must be 200 although we tried to change it\n\tassert.Equal(t, http.StatusOK, w.Status())\n}\n\n// mockPusherResponseWriter is an http.ResponseWriter that implements http.Pusher.\ntype mockPusherResponseWriter struct {\n\thttp.ResponseWriter\n}\n\nfunc (m *mockPusherResponseWriter) Push(target string, opts *http.PushOptions) error {\n\treturn nil\n}\n\n// nonPusherResponseWriter is an http.ResponseWriter that does not implement http.Pusher.\ntype nonPusherResponseWriter struct {\n\thttp.ResponseWriter\n}\n\nfunc TestPusherWithPusher(t *testing.T) {\n\trw := &mockPusherResponseWriter{}\n\tw := &responseWriter{ResponseWriter: rw}\n\n\tpusher := w.Pusher()\n\tassert.NotNil(t, pusher, \"Expected pusher to be non-nil\")\n}\n\nfunc TestPusherWithoutPusher(t *testing.T) {\n\trw := &nonPusherResponseWriter{}\n\tw := &responseWriter{ResponseWriter: rw}\n\n\tpusher := w.Pusher()\n\tassert.Nil(t, pusher, \"Expected pusher to be nil\")\n}\n"
        },
        {
          "name": "routergroup.go",
          "type": "blob",
          "size": 9.0625,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"net/http\"\n\t\"path\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar (\n\t// regEnLetter matches english letters for http method name\n\tregEnLetter = regexp.MustCompile(\"^[A-Z]+$\")\n\n\t// anyMethods for RouterGroup Any method\n\tanyMethods = []string{\n\t\thttp.MethodGet, http.MethodPost, http.MethodPut, http.MethodPatch,\n\t\thttp.MethodHead, http.MethodOptions, http.MethodDelete, http.MethodConnect,\n\t\thttp.MethodTrace,\n\t}\n)\n\n// IRouter defines all router handle interface includes single and group router.\ntype IRouter interface {\n\tIRoutes\n\tGroup(string, ...HandlerFunc) *RouterGroup\n}\n\n// IRoutes defines all router handle interface.\ntype IRoutes interface {\n\tUse(...HandlerFunc) IRoutes\n\n\tHandle(string, string, ...HandlerFunc) IRoutes\n\tAny(string, ...HandlerFunc) IRoutes\n\tGET(string, ...HandlerFunc) IRoutes\n\tPOST(string, ...HandlerFunc) IRoutes\n\tDELETE(string, ...HandlerFunc) IRoutes\n\tPATCH(string, ...HandlerFunc) IRoutes\n\tPUT(string, ...HandlerFunc) IRoutes\n\tOPTIONS(string, ...HandlerFunc) IRoutes\n\tHEAD(string, ...HandlerFunc) IRoutes\n\tMatch([]string, string, ...HandlerFunc) IRoutes\n\n\tStaticFile(string, string) IRoutes\n\tStaticFileFS(string, string, http.FileSystem) IRoutes\n\tStatic(string, string) IRoutes\n\tStaticFS(string, http.FileSystem) IRoutes\n}\n\n// RouterGroup is used internally to configure router, a RouterGroup is associated with\n// a prefix and an array of handlers (middleware).\ntype RouterGroup struct {\n\tHandlers HandlersChain\n\tbasePath string\n\tengine   *Engine\n\troot     bool\n}\n\nvar _ IRouter = (*RouterGroup)(nil)\n\n// Use adds middleware to the group, see example code in GitHub.\nfunc (group *RouterGroup) Use(middleware ...HandlerFunc) IRoutes {\n\tgroup.Handlers = append(group.Handlers, middleware...)\n\treturn group.returnObj()\n}\n\n// Group creates a new router group. You should add all the routes that have common middlewares or the same path prefix.\n// For example, all the routes that use a common middleware for authorization could be grouped.\nfunc (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup {\n\treturn &RouterGroup{\n\t\tHandlers: group.combineHandlers(handlers),\n\t\tbasePath: group.calculateAbsolutePath(relativePath),\n\t\tengine:   group.engine,\n\t}\n}\n\n// BasePath returns the base path of router group.\n// For example, if v := router.Group(\"/rest/n/v1/api\"), v.BasePath() is \"/rest/n/v1/api\".\nfunc (group *RouterGroup) BasePath() string {\n\treturn group.basePath\n}\n\nfunc (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes {\n\tabsolutePath := group.calculateAbsolutePath(relativePath)\n\thandlers = group.combineHandlers(handlers)\n\tgroup.engine.addRoute(httpMethod, absolutePath, handlers)\n\treturn group.returnObj()\n}\n\n// Handle registers a new request handle and middleware with the given path and method.\n// The last handler should be the real handler, the other ones should be middleware that can and should be shared among different routes.\n// See the example code in GitHub.\n//\n// For GET, POST, PUT, PATCH and DELETE requests the respective shortcut\n// functions can be used.\n//\n// This function is intended for bulk loading and to allow the usage of less\n// frequently used, non-standardized or custom methods (e.g. for internal\n// communication with a proxy).\nfunc (group *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes {\n\tif matched := regEnLetter.MatchString(httpMethod); !matched {\n\t\tpanic(\"http method \" + httpMethod + \" is not valid\")\n\t}\n\treturn group.handle(httpMethod, relativePath, handlers)\n}\n\n// POST is a shortcut for router.Handle(\"POST\", path, handlers).\nfunc (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes {\n\treturn group.handle(http.MethodPost, relativePath, handlers)\n}\n\n// GET is a shortcut for router.Handle(\"GET\", path, handlers).\nfunc (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes {\n\treturn group.handle(http.MethodGet, relativePath, handlers)\n}\n\n// DELETE is a shortcut for router.Handle(\"DELETE\", path, handlers).\nfunc (group *RouterGroup) DELETE(relativePath string, handlers ...HandlerFunc) IRoutes {\n\treturn group.handle(http.MethodDelete, relativePath, handlers)\n}\n\n// PATCH is a shortcut for router.Handle(\"PATCH\", path, handlers).\nfunc (group *RouterGroup) PATCH(relativePath string, handlers ...HandlerFunc) IRoutes {\n\treturn group.handle(http.MethodPatch, relativePath, handlers)\n}\n\n// PUT is a shortcut for router.Handle(\"PUT\", path, handlers).\nfunc (group *RouterGroup) PUT(relativePath string, handlers ...HandlerFunc) IRoutes {\n\treturn group.handle(http.MethodPut, relativePath, handlers)\n}\n\n// OPTIONS is a shortcut for router.Handle(\"OPTIONS\", path, handlers).\nfunc (group *RouterGroup) OPTIONS(relativePath string, handlers ...HandlerFunc) IRoutes {\n\treturn group.handle(http.MethodOptions, relativePath, handlers)\n}\n\n// HEAD is a shortcut for router.Handle(\"HEAD\", path, handlers).\nfunc (group *RouterGroup) HEAD(relativePath string, handlers ...HandlerFunc) IRoutes {\n\treturn group.handle(http.MethodHead, relativePath, handlers)\n}\n\n// Any registers a route that matches all the HTTP methods.\n// GET, POST, PUT, PATCH, HEAD, OPTIONS, DELETE, CONNECT, TRACE.\nfunc (group *RouterGroup) Any(relativePath string, handlers ...HandlerFunc) IRoutes {\n\tfor _, method := range anyMethods {\n\t\tgroup.handle(method, relativePath, handlers)\n\t}\n\n\treturn group.returnObj()\n}\n\n// Match registers a route that matches the specified methods that you declared.\nfunc (group *RouterGroup) Match(methods []string, relativePath string, handlers ...HandlerFunc) IRoutes {\n\tfor _, method := range methods {\n\t\tgroup.handle(method, relativePath, handlers)\n\t}\n\n\treturn group.returnObj()\n}\n\n// StaticFile registers a single route in order to serve a single file of the local filesystem.\n// router.StaticFile(\"favicon.ico\", \"./resources/favicon.ico\")\nfunc (group *RouterGroup) StaticFile(relativePath, filepath string) IRoutes {\n\treturn group.staticFileHandler(relativePath, func(c *Context) {\n\t\tc.File(filepath)\n\t})\n}\n\n// StaticFileFS works just like `StaticFile` but a custom `http.FileSystem` can be used instead..\n// router.StaticFileFS(\"favicon.ico\", \"./resources/favicon.ico\", Dir{\".\", false})\n// Gin by default uses: gin.Dir()\nfunc (group *RouterGroup) StaticFileFS(relativePath, filepath string, fs http.FileSystem) IRoutes {\n\treturn group.staticFileHandler(relativePath, func(c *Context) {\n\t\tc.FileFromFS(filepath, fs)\n\t})\n}\n\nfunc (group *RouterGroup) staticFileHandler(relativePath string, handler HandlerFunc) IRoutes {\n\tif strings.Contains(relativePath, \":\") || strings.Contains(relativePath, \"*\") {\n\t\tpanic(\"URL parameters can not be used when serving a static file\")\n\t}\n\tgroup.GET(relativePath, handler)\n\tgroup.HEAD(relativePath, handler)\n\treturn group.returnObj()\n}\n\n// Static serves files from the given file system root.\n// Internally a http.FileServer is used, therefore http.NotFound is used instead\n// of the Router's NotFound handler.\n// To use the operating system's file system implementation,\n// use :\n//\n//\trouter.Static(\"/static\", \"/var/www\")\nfunc (group *RouterGroup) Static(relativePath, root string) IRoutes {\n\treturn group.StaticFS(relativePath, Dir(root, false))\n}\n\n// StaticFS works just like `Static()` but a custom `http.FileSystem` can be used instead.\n// Gin by default uses: gin.Dir()\nfunc (group *RouterGroup) StaticFS(relativePath string, fs http.FileSystem) IRoutes {\n\tif strings.Contains(relativePath, \":\") || strings.Contains(relativePath, \"*\") {\n\t\tpanic(\"URL parameters can not be used when serving a static folder\")\n\t}\n\thandler := group.createStaticHandler(relativePath, fs)\n\turlPattern := path.Join(relativePath, \"/*filepath\")\n\n\t// Register GET and HEAD handlers\n\tgroup.GET(urlPattern, handler)\n\tgroup.HEAD(urlPattern, handler)\n\treturn group.returnObj()\n}\n\nfunc (group *RouterGroup) createStaticHandler(relativePath string, fs http.FileSystem) HandlerFunc {\n\tabsolutePath := group.calculateAbsolutePath(relativePath)\n\tfileServer := http.StripPrefix(absolutePath, http.FileServer(fs))\n\n\treturn func(c *Context) {\n\t\tif _, noListing := fs.(*OnlyFilesFS); noListing {\n\t\t\tc.Writer.WriteHeader(http.StatusNotFound)\n\t\t}\n\n\t\tfile := c.Param(\"filepath\")\n\t\t// Check if file exists and/or if we have permission to access it\n\t\tf, err := fs.Open(file)\n\t\tif err != nil {\n\t\t\tc.Writer.WriteHeader(http.StatusNotFound)\n\t\t\tc.handlers = group.engine.noRoute\n\t\t\t// Reset index\n\t\t\tc.index = -1\n\t\t\treturn\n\t\t}\n\t\tf.Close()\n\n\t\tfileServer.ServeHTTP(c.Writer, c.Request)\n\t}\n}\n\nfunc (group *RouterGroup) combineHandlers(handlers HandlersChain) HandlersChain {\n\tfinalSize := len(group.Handlers) + len(handlers)\n\tassert1(finalSize < int(abortIndex), \"too many handlers\")\n\tmergedHandlers := make(HandlersChain, finalSize)\n\tcopy(mergedHandlers, group.Handlers)\n\tcopy(mergedHandlers[len(group.Handlers):], handlers)\n\treturn mergedHandlers\n}\n\nfunc (group *RouterGroup) calculateAbsolutePath(relativePath string) string {\n\treturn joinPaths(group.basePath, relativePath)\n}\n\nfunc (group *RouterGroup) returnObj() IRoutes {\n\tif group.root {\n\t\treturn group.engine\n\t}\n\treturn group\n}\n"
        },
        {
          "name": "routergroup_test.go",
          "type": "blob",
          "size": 5.0625,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc init() {\n\tSetMode(TestMode)\n}\n\nfunc TestRouterGroupBasic(t *testing.T) {\n\trouter := New()\n\tgroup := router.Group(\"/hola\", func(c *Context) {})\n\tgroup.Use(func(c *Context) {})\n\n\tassert.Len(t, group.Handlers, 2)\n\tassert.Equal(t, \"/hola\", group.BasePath())\n\tassert.Equal(t, router, group.engine)\n\n\tgroup2 := group.Group(\"manu\")\n\tgroup2.Use(func(c *Context) {}, func(c *Context) {})\n\n\tassert.Len(t, group2.Handlers, 4)\n\tassert.Equal(t, \"/hola/manu\", group2.BasePath())\n\tassert.Equal(t, router, group2.engine)\n}\n\nfunc TestRouterGroupBasicHandle(t *testing.T) {\n\tperformRequestInGroup(t, http.MethodGet)\n\tperformRequestInGroup(t, http.MethodPost)\n\tperformRequestInGroup(t, http.MethodPut)\n\tperformRequestInGroup(t, http.MethodPatch)\n\tperformRequestInGroup(t, http.MethodDelete)\n\tperformRequestInGroup(t, http.MethodHead)\n\tperformRequestInGroup(t, http.MethodOptions)\n}\n\nfunc performRequestInGroup(t *testing.T, method string) {\n\trouter := New()\n\tv1 := router.Group(\"v1\", func(c *Context) {})\n\tassert.Equal(t, \"/v1\", v1.BasePath())\n\n\tlogin := v1.Group(\"/login/\", func(c *Context) {}, func(c *Context) {})\n\tassert.Equal(t, \"/v1/login/\", login.BasePath())\n\n\thandler := func(c *Context) {\n\t\tc.String(http.StatusBadRequest, \"the method was %s and index %d\", c.Request.Method, c.index)\n\t}\n\n\tswitch method {\n\tcase http.MethodGet:\n\t\tv1.GET(\"/test\", handler)\n\t\tlogin.GET(\"/test\", handler)\n\tcase http.MethodPost:\n\t\tv1.POST(\"/test\", handler)\n\t\tlogin.POST(\"/test\", handler)\n\tcase http.MethodPut:\n\t\tv1.PUT(\"/test\", handler)\n\t\tlogin.PUT(\"/test\", handler)\n\tcase http.MethodPatch:\n\t\tv1.PATCH(\"/test\", handler)\n\t\tlogin.PATCH(\"/test\", handler)\n\tcase http.MethodDelete:\n\t\tv1.DELETE(\"/test\", handler)\n\t\tlogin.DELETE(\"/test\", handler)\n\tcase http.MethodHead:\n\t\tv1.HEAD(\"/test\", handler)\n\t\tlogin.HEAD(\"/test\", handler)\n\tcase http.MethodOptions:\n\t\tv1.OPTIONS(\"/test\", handler)\n\t\tlogin.OPTIONS(\"/test\", handler)\n\tdefault:\n\t\tpanic(\"unknown method\")\n\t}\n\n\tw := PerformRequest(router, method, \"/v1/login/test\")\n\tassert.Equal(t, http.StatusBadRequest, w.Code)\n\tassert.Equal(t, \"the method was \"+method+\" and index 3\", w.Body.String())\n\n\tw = PerformRequest(router, method, \"/v1/test\")\n\tassert.Equal(t, http.StatusBadRequest, w.Code)\n\tassert.Equal(t, \"the method was \"+method+\" and index 1\", w.Body.String())\n}\n\nfunc TestRouterGroupInvalidStatic(t *testing.T) {\n\trouter := New()\n\tassert.Panics(t, func() {\n\t\trouter.Static(\"/path/:param\", \"/\")\n\t})\n\n\tassert.Panics(t, func() {\n\t\trouter.Static(\"/path/*param\", \"/\")\n\t})\n}\n\nfunc TestRouterGroupInvalidStaticFile(t *testing.T) {\n\trouter := New()\n\tassert.Panics(t, func() {\n\t\trouter.StaticFile(\"/path/:param\", \"favicon.ico\")\n\t})\n\n\tassert.Panics(t, func() {\n\t\trouter.StaticFile(\"/path/*param\", \"favicon.ico\")\n\t})\n}\n\nfunc TestRouterGroupInvalidStaticFileFS(t *testing.T) {\n\trouter := New()\n\tassert.Panics(t, func() {\n\t\trouter.StaticFileFS(\"/path/:param\", \"favicon.ico\", Dir(\".\", false))\n\t})\n\n\tassert.Panics(t, func() {\n\t\trouter.StaticFileFS(\"/path/*param\", \"favicon.ico\", Dir(\".\", false))\n\t})\n}\n\nfunc TestRouterGroupTooManyHandlers(t *testing.T) {\n\tconst (\n\t\tpanicValue = \"too many handlers\"\n\t\tmaximumCnt = abortIndex\n\t)\n\trouter := New()\n\thandlers1 := make([]HandlerFunc, maximumCnt-1)\n\trouter.Use(handlers1...)\n\n\thandlers2 := make([]HandlerFunc, maximumCnt+1)\n\tassert.PanicsWithValue(t, panicValue, func() {\n\t\trouter.Use(handlers2...)\n\t})\n\tassert.PanicsWithValue(t, panicValue, func() {\n\t\trouter.GET(\"/\", handlers2...)\n\t})\n}\n\nfunc TestRouterGroupBadMethod(t *testing.T) {\n\trouter := New()\n\tassert.Panics(t, func() {\n\t\trouter.Handle(http.MethodGet, \"/\")\n\t})\n\tassert.Panics(t, func() {\n\t\trouter.Handle(\" GET\", \"/\")\n\t})\n\tassert.Panics(t, func() {\n\t\trouter.Handle(\"GET \", \"/\")\n\t})\n\tassert.Panics(t, func() {\n\t\trouter.Handle(\"\", \"/\")\n\t})\n\tassert.Panics(t, func() {\n\t\trouter.Handle(\"PO ST\", \"/\")\n\t})\n\tassert.Panics(t, func() {\n\t\trouter.Handle(\"1GET\", \"/\")\n\t})\n\tassert.Panics(t, func() {\n\t\trouter.Handle(\"PATCh\", \"/\")\n\t})\n}\n\nfunc TestRouterGroupPipeline(t *testing.T) {\n\trouter := New()\n\ttestRoutesInterface(t, router)\n\n\tv1 := router.Group(\"/v1\")\n\ttestRoutesInterface(t, v1)\n}\n\nfunc testRoutesInterface(t *testing.T, r IRoutes) {\n\thandler := func(c *Context) {}\n\tassert.Equal(t, r, r.Use(handler))\n\n\tassert.Equal(t, r, r.Handle(http.MethodGet, \"/handler\", handler))\n\tassert.Equal(t, r, r.Any(\"/any\", handler))\n\tassert.Equal(t, r, r.GET(\"/\", handler))\n\tassert.Equal(t, r, r.POST(\"/\", handler))\n\tassert.Equal(t, r, r.DELETE(\"/\", handler))\n\tassert.Equal(t, r, r.PATCH(\"/\", handler))\n\tassert.Equal(t, r, r.PUT(\"/\", handler))\n\tassert.Equal(t, r, r.OPTIONS(\"/\", handler))\n\tassert.Equal(t, r, r.HEAD(\"/\", handler))\n\tassert.Equal(t, r, r.Match([]string{http.MethodPut, http.MethodPatch}, \"/match\", handler))\n\n\tassert.Equal(t, r, r.StaticFile(\"/file\", \".\"))\n\tassert.Equal(t, r, r.StaticFileFS(\"/static2\", \".\", Dir(\".\", false)))\n\tassert.Equal(t, r, r.Static(\"/static\", \".\"))\n\tassert.Equal(t, r, r.StaticFS(\"/static2\", Dir(\".\", false)))\n}\n"
        },
        {
          "name": "routes_test.go",
          "type": "blob",
          "size": 24.201171875,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype header struct {\n\tKey   string\n\tValue string\n}\n\n// PerformRequest for testing gin router.\nfunc PerformRequest(r http.Handler, method, path string, headers ...header) *httptest.ResponseRecorder {\n\treq := httptest.NewRequest(method, path, nil)\n\tfor _, h := range headers {\n\t\treq.Header.Add(h.Key, h.Value)\n\t}\n\tw := httptest.NewRecorder()\n\tr.ServeHTTP(w, req)\n\treturn w\n}\n\nfunc testRouteOK(method string, t *testing.T) {\n\tpassed := false\n\tpassedAny := false\n\tr := New()\n\tr.Any(\"/test2\", func(c *Context) {\n\t\tpassedAny = true\n\t})\n\tr.Handle(method, \"/test\", func(c *Context) {\n\t\tpassed = true\n\t})\n\n\tw := PerformRequest(r, method, \"/test\")\n\tassert.True(t, passed)\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tPerformRequest(r, method, \"/test2\")\n\tassert.True(t, passedAny)\n}\n\n// TestSingleRouteOK tests that POST route is correctly invoked.\nfunc testRouteNotOK(method string, t *testing.T) {\n\tpassed := false\n\trouter := New()\n\trouter.Handle(method, \"/test_2\", func(c *Context) {\n\t\tpassed = true\n\t})\n\n\tw := PerformRequest(router, method, \"/test\")\n\n\tassert.False(t, passed)\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n}\n\n// TestSingleRouteOK tests that POST route is correctly invoked.\nfunc testRouteNotOK2(method string, t *testing.T) {\n\tpassed := false\n\trouter := New()\n\trouter.HandleMethodNotAllowed = true\n\tvar methodRoute string\n\tif method == http.MethodPost {\n\t\tmethodRoute = http.MethodGet\n\t} else {\n\t\tmethodRoute = http.MethodPost\n\t}\n\trouter.Handle(methodRoute, \"/test\", func(c *Context) {\n\t\tpassed = true\n\t})\n\n\tw := PerformRequest(router, method, \"/test\")\n\n\tassert.False(t, passed)\n\tassert.Equal(t, http.StatusMethodNotAllowed, w.Code)\n}\n\nfunc TestRouterMethod(t *testing.T) {\n\trouter := New()\n\trouter.PUT(\"/hey2\", func(c *Context) {\n\t\tc.String(http.StatusOK, \"sup2\")\n\t})\n\n\trouter.PUT(\"/hey\", func(c *Context) {\n\t\tc.String(http.StatusOK, \"called\")\n\t})\n\n\trouter.PUT(\"/hey3\", func(c *Context) {\n\t\tc.String(http.StatusOK, \"sup3\")\n\t})\n\n\tw := PerformRequest(router, http.MethodPut, \"/hey\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"called\", w.Body.String())\n}\n\nfunc TestRouterGroupRouteOK(t *testing.T) {\n\ttestRouteOK(http.MethodGet, t)\n\ttestRouteOK(http.MethodPost, t)\n\ttestRouteOK(http.MethodPut, t)\n\ttestRouteOK(http.MethodPatch, t)\n\ttestRouteOK(http.MethodHead, t)\n\ttestRouteOK(http.MethodOptions, t)\n\ttestRouteOK(http.MethodDelete, t)\n\ttestRouteOK(http.MethodConnect, t)\n\ttestRouteOK(http.MethodTrace, t)\n}\n\nfunc TestRouteNotOK(t *testing.T) {\n\ttestRouteNotOK(http.MethodGet, t)\n\ttestRouteNotOK(http.MethodPost, t)\n\ttestRouteNotOK(http.MethodPut, t)\n\ttestRouteNotOK(http.MethodPatch, t)\n\ttestRouteNotOK(http.MethodHead, t)\n\ttestRouteNotOK(http.MethodOptions, t)\n\ttestRouteNotOK(http.MethodDelete, t)\n\ttestRouteNotOK(http.MethodConnect, t)\n\ttestRouteNotOK(http.MethodTrace, t)\n}\n\nfunc TestRouteNotOK2(t *testing.T) {\n\ttestRouteNotOK2(http.MethodGet, t)\n\ttestRouteNotOK2(http.MethodPost, t)\n\ttestRouteNotOK2(http.MethodPut, t)\n\ttestRouteNotOK2(http.MethodPatch, t)\n\ttestRouteNotOK2(http.MethodHead, t)\n\ttestRouteNotOK2(http.MethodOptions, t)\n\ttestRouteNotOK2(http.MethodDelete, t)\n\ttestRouteNotOK2(http.MethodConnect, t)\n\ttestRouteNotOK2(http.MethodTrace, t)\n}\n\nfunc TestRouteRedirectTrailingSlash(t *testing.T) {\n\trouter := New()\n\trouter.RedirectFixedPath = false\n\trouter.RedirectTrailingSlash = true\n\trouter.GET(\"/path\", func(c *Context) {})\n\trouter.GET(\"/path2/\", func(c *Context) {})\n\trouter.POST(\"/path3\", func(c *Context) {})\n\trouter.PUT(\"/path4/\", func(c *Context) {})\n\n\tw := PerformRequest(router, http.MethodGet, \"/path/\")\n\tassert.Equal(t, \"/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2\")\n\tassert.Equal(t, \"/path2/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodPost, \"/path3/\")\n\tassert.Equal(t, \"/path3\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n\n\tw = PerformRequest(router, http.MethodPut, \"/path4\")\n\tassert.Equal(t, \"/path4/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2/\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tw = PerformRequest(router, http.MethodPost, \"/path3\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tw = PerformRequest(router, http.MethodPut, \"/path4/\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2\", header{Key: \"X-Forwarded-Prefix\", Value: \"/api\"})\n\tassert.Equal(t, \"/api/path2/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2/\", header{Key: \"X-Forwarded-Prefix\", Value: \"/api/\"})\n\tassert.Equal(t, http.StatusOK, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\", header{Key: \"X-Forwarded-Prefix\", Value: \"../../api#?\"})\n\tassert.Equal(t, \"/api/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\", header{Key: \"X-Forwarded-Prefix\", Value: \"../../api\"})\n\tassert.Equal(t, \"/api/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2\", header{Key: \"X-Forwarded-Prefix\", Value: \"../../api\"})\n\tassert.Equal(t, \"/api/path2/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2\", header{Key: \"X-Forwarded-Prefix\", Value: \"/../../api\"})\n\tassert.Equal(t, \"/api/path2/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\", header{Key: \"X-Forwarded-Prefix\", Value: \"api/../../\"})\n\tassert.Equal(t, \"//path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\", header{Key: \"X-Forwarded-Prefix\", Value: \"api/../../../\"})\n\tassert.Equal(t, \"/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2\", header{Key: \"X-Forwarded-Prefix\", Value: \"../../gin-gonic.com\"})\n\tassert.Equal(t, \"/gin-goniccom/path2/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2\", header{Key: \"X-Forwarded-Prefix\", Value: \"/../../gin-gonic.com\"})\n\tassert.Equal(t, \"/gin-goniccom/path2/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\", header{Key: \"X-Forwarded-Prefix\", Value: \"https://gin-gonic.com/#\"})\n\tassert.Equal(t, \"https/gin-goniccom/https/gin-goniccom/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\", header{Key: \"X-Forwarded-Prefix\", Value: \"#api\"})\n\tassert.Equal(t, \"api/api/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\", header{Key: \"X-Forwarded-Prefix\", Value: \"/nor-mal/#?a=1\"})\n\tassert.Equal(t, \"/nor-mal/a1/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\", header{Key: \"X-Forwarded-Prefix\", Value: \"/nor-mal/%2e%2e/\"})\n\tassert.Equal(t, \"/nor-mal/2e2e/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\trouter.RedirectTrailingSlash = false\n\n\tw = PerformRequest(router, http.MethodGet, \"/path/\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tw = PerformRequest(router, http.MethodGet, \"/path2\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tw = PerformRequest(router, http.MethodPost, \"/path3/\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tw = PerformRequest(router, http.MethodPut, \"/path4\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n}\n\nfunc TestRouteRedirectFixedPath(t *testing.T) {\n\trouter := New()\n\trouter.RedirectFixedPath = true\n\trouter.RedirectTrailingSlash = false\n\n\trouter.GET(\"/path\", func(c *Context) {})\n\trouter.GET(\"/Path2\", func(c *Context) {})\n\trouter.POST(\"/PATH3\", func(c *Context) {})\n\trouter.POST(\"/Path4/\", func(c *Context) {})\n\n\tw := PerformRequest(router, http.MethodGet, \"/PATH\")\n\tassert.Equal(t, \"/path\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2\")\n\tassert.Equal(t, \"/Path2\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusMovedPermanently, w.Code)\n\n\tw = PerformRequest(router, http.MethodPost, \"/path3\")\n\tassert.Equal(t, \"/PATH3\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n\n\tw = PerformRequest(router, http.MethodPost, \"/path4\")\n\tassert.Equal(t, \"/Path4/\", w.Header().Get(\"Location\"))\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n}\n\n// TestContextParamsGet tests that a parameter can be parsed from the URL.\nfunc TestRouteParamsByName(t *testing.T) {\n\tname := \"\"\n\tlastName := \"\"\n\twild := \"\"\n\trouter := New()\n\trouter.GET(\"/test/:name/:last_name/*wild\", func(c *Context) {\n\t\tname = c.Params.ByName(\"name\")\n\t\tlastName = c.Params.ByName(\"last_name\")\n\t\tvar ok bool\n\t\twild, ok = c.Params.Get(\"wild\")\n\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, name, c.Param(\"name\"))\n\t\tassert.Equal(t, lastName, c.Param(\"last_name\"))\n\n\t\tassert.Empty(t, c.Param(\"wtf\"))\n\t\tassert.Empty(t, c.Params.ByName(\"wtf\"))\n\n\t\twtf, ok := c.Params.Get(\"wtf\")\n\t\tassert.Empty(t, wtf)\n\t\tassert.False(t, ok)\n\t})\n\n\tw := PerformRequest(router, http.MethodGet, \"/test/john/smith/is/super/great\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"john\", name)\n\tassert.Equal(t, \"smith\", lastName)\n\tassert.Equal(t, \"/is/super/great\", wild)\n}\n\n// TestContextParamsGet tests that a parameter can be parsed from the URL even with extra slashes.\nfunc TestRouteParamsByNameWithExtraSlash(t *testing.T) {\n\tname := \"\"\n\tlastName := \"\"\n\twild := \"\"\n\trouter := New()\n\trouter.RemoveExtraSlash = true\n\trouter.GET(\"/test/:name/:last_name/*wild\", func(c *Context) {\n\t\tname = c.Params.ByName(\"name\")\n\t\tlastName = c.Params.ByName(\"last_name\")\n\t\tvar ok bool\n\t\twild, ok = c.Params.Get(\"wild\")\n\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, name, c.Param(\"name\"))\n\t\tassert.Equal(t, lastName, c.Param(\"last_name\"))\n\n\t\tassert.Empty(t, c.Param(\"wtf\"))\n\t\tassert.Empty(t, c.Params.ByName(\"wtf\"))\n\n\t\twtf, ok := c.Params.Get(\"wtf\")\n\t\tassert.Empty(t, wtf)\n\t\tassert.False(t, ok)\n\t})\n\n\tw := PerformRequest(router, http.MethodGet, \"//test//john//smith//is//super//great\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"john\", name)\n\tassert.Equal(t, \"smith\", lastName)\n\tassert.Equal(t, \"/is/super/great\", wild)\n}\n\n// TestRouteParamsNotEmpty tests that context parameters will be set\n// even if a route with params/wildcards is registered after the context\n// initialisation (which happened in a previous requests).\nfunc TestRouteParamsNotEmpty(t *testing.T) {\n\tname := \"\"\n\tlastName := \"\"\n\twild := \"\"\n\trouter := New()\n\n\tw := PerformRequest(router, http.MethodGet, \"/test/john/smith/is/super/great\")\n\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\n\trouter.GET(\"/test/:name/:last_name/*wild\", func(c *Context) {\n\t\tname = c.Params.ByName(\"name\")\n\t\tlastName = c.Params.ByName(\"last_name\")\n\t\tvar ok bool\n\t\twild, ok = c.Params.Get(\"wild\")\n\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, name, c.Param(\"name\"))\n\t\tassert.Equal(t, lastName, c.Param(\"last_name\"))\n\n\t\tassert.Empty(t, c.Param(\"wtf\"))\n\t\tassert.Empty(t, c.Params.ByName(\"wtf\"))\n\n\t\twtf, ok := c.Params.Get(\"wtf\")\n\t\tassert.Empty(t, wtf)\n\t\tassert.False(t, ok)\n\t})\n\n\tw = PerformRequest(router, http.MethodGet, \"/test/john/smith/is/super/great\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"john\", name)\n\tassert.Equal(t, \"smith\", lastName)\n\tassert.Equal(t, \"/is/super/great\", wild)\n}\n\n// TestHandleStaticFile - ensure the static file handles properly\nfunc TestRouteStaticFile(t *testing.T) {\n\t// SETUP file\n\ttestRoot, _ := os.Getwd()\n\tf, err := os.CreateTemp(testRoot, \"\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer os.Remove(f.Name())\n\t_, err = f.WriteString(\"Gin Web Framework\")\n\trequire.NoError(t, err)\n\tf.Close()\n\n\tdir, filename := filepath.Split(f.Name())\n\n\t// SETUP gin\n\trouter := New()\n\trouter.Static(\"/using_static\", dir)\n\trouter.StaticFile(\"/result\", f.Name())\n\n\tw := PerformRequest(router, http.MethodGet, \"/using_static/\"+filename)\n\tw2 := PerformRequest(router, http.MethodGet, \"/result\")\n\n\tassert.Equal(t, w, w2)\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"Gin Web Framework\", w.Body.String())\n\tassert.Equal(t, \"text/plain; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n\n\tw3 := PerformRequest(router, http.MethodHead, \"/using_static/\"+filename)\n\tw4 := PerformRequest(router, http.MethodHead, \"/result\")\n\n\tassert.Equal(t, w3, w4)\n\tassert.Equal(t, http.StatusOK, w3.Code)\n}\n\n// TestHandleStaticFile - ensure the static file handles properly\nfunc TestRouteStaticFileFS(t *testing.T) {\n\t// SETUP file\n\ttestRoot, _ := os.Getwd()\n\tf, err := os.CreateTemp(testRoot, \"\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tdefer os.Remove(f.Name())\n\t_, err = f.WriteString(\"Gin Web Framework\")\n\trequire.NoError(t, err)\n\tf.Close()\n\n\tdir, filename := filepath.Split(f.Name())\n\t// SETUP gin\n\trouter := New()\n\trouter.Static(\"/using_static\", dir)\n\trouter.StaticFileFS(\"/result_fs\", filename, Dir(dir, false))\n\n\tw := PerformRequest(router, http.MethodGet, \"/using_static/\"+filename)\n\tw2 := PerformRequest(router, http.MethodGet, \"/result_fs\")\n\n\tassert.Equal(t, w, w2)\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Equal(t, \"Gin Web Framework\", w.Body.String())\n\tassert.Equal(t, \"text/plain; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n\n\tw3 := PerformRequest(router, http.MethodHead, \"/using_static/\"+filename)\n\tw4 := PerformRequest(router, http.MethodHead, \"/result_fs\")\n\n\tassert.Equal(t, w3, w4)\n\tassert.Equal(t, http.StatusOK, w3.Code)\n}\n\n// TestHandleStaticDir - ensure the root/sub dir handles properly\nfunc TestRouteStaticListingDir(t *testing.T) {\n\trouter := New()\n\trouter.StaticFS(\"/\", Dir(\"./\", true))\n\n\tw := PerformRequest(router, http.MethodGet, \"/\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Contains(t, w.Body.String(), \"gin.go\")\n\tassert.Equal(t, \"text/html; charset=utf-8\", w.Header().Get(\"Content-Type\"))\n}\n\n// TestHandleHeadToDir - ensure the root/sub dir handles properly\nfunc TestRouteStaticNoListing(t *testing.T) {\n\trouter := New()\n\trouter.Static(\"/\", \"./\")\n\n\tw := PerformRequest(router, http.MethodGet, \"/\")\n\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tassert.NotContains(t, w.Body.String(), \"gin.go\")\n}\n\nfunc TestRouterMiddlewareAndStatic(t *testing.T) {\n\trouter := New()\n\tstatic := router.Group(\"/\", func(c *Context) {\n\t\tc.Writer.Header().Add(\"Last-Modified\", \"Mon, 02 Jan 2006 15:04:05 MST\")\n\t\tc.Writer.Header().Add(\"Expires\", \"Mon, 02 Jan 2006 15:04:05 MST\")\n\t\tc.Writer.Header().Add(\"X-GIN\", \"Gin Framework\")\n\t})\n\tstatic.Static(\"/\", \"./\")\n\n\tw := PerformRequest(router, http.MethodGet, \"/gin.go\")\n\n\tassert.Equal(t, http.StatusOK, w.Code)\n\tassert.Contains(t, w.Body.String(), \"package gin\")\n\t// Content-Type='text/plain; charset=utf-8' when go version <= 1.16,\n\t// else, Content-Type='text/x-go; charset=utf-8'\n\tassert.NotEqual(t, \"\", w.Header().Get(\"Content-Type\"))\n\tassert.NotEqual(t, \"Mon, 02 Jan 2006 15:04:05 MST\", w.Header().Get(\"Last-Modified\"))\n\tassert.Equal(t, \"Mon, 02 Jan 2006 15:04:05 MST\", w.Header().Get(\"Expires\"))\n\tassert.Equal(t, \"Gin Framework\", w.Header().Get(\"x-GIN\"))\n}\n\nfunc TestRouteNotAllowedEnabled(t *testing.T) {\n\trouter := New()\n\trouter.HandleMethodNotAllowed = true\n\trouter.POST(\"/path\", func(c *Context) {})\n\tw := PerformRequest(router, http.MethodGet, \"/path\")\n\tassert.Equal(t, http.StatusMethodNotAllowed, w.Code)\n\n\trouter.NoMethod(func(c *Context) {\n\t\tc.String(http.StatusTeapot, \"responseText\")\n\t})\n\tw = PerformRequest(router, http.MethodGet, \"/path\")\n\tassert.Equal(t, \"responseText\", w.Body.String())\n\tassert.Equal(t, http.StatusTeapot, w.Code)\n}\n\nfunc TestRouteNotAllowedEnabled2(t *testing.T) {\n\trouter := New()\n\trouter.HandleMethodNotAllowed = true\n\t// add one methodTree to trees\n\trouter.addRoute(http.MethodPost, \"/\", HandlersChain{func(_ *Context) {}})\n\trouter.GET(\"/path2\", func(c *Context) {})\n\tw := PerformRequest(router, http.MethodPost, \"/path2\")\n\tassert.Equal(t, http.StatusMethodNotAllowed, w.Code)\n}\n\nfunc TestRouteNotAllowedEnabled3(t *testing.T) {\n\trouter := New()\n\trouter.HandleMethodNotAllowed = true\n\trouter.GET(\"/path\", func(c *Context) {})\n\trouter.POST(\"/path\", func(c *Context) {})\n\tw := PerformRequest(router, http.MethodPut, \"/path\")\n\tassert.Equal(t, http.StatusMethodNotAllowed, w.Code)\n\tallowed := w.Header().Get(\"Allow\")\n\tassert.Contains(t, allowed, http.MethodGet)\n\tassert.Contains(t, allowed, http.MethodPost)\n}\n\nfunc TestRouteNotAllowedDisabled(t *testing.T) {\n\trouter := New()\n\trouter.HandleMethodNotAllowed = false\n\trouter.POST(\"/path\", func(c *Context) {})\n\tw := PerformRequest(router, http.MethodGet, \"/path\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\n\trouter.NoMethod(func(c *Context) {\n\t\tc.String(http.StatusTeapot, \"responseText\")\n\t})\n\tw = PerformRequest(router, http.MethodGet, \"/path\")\n\tassert.Equal(t, \"404 page not found\", w.Body.String())\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n}\n\nfunc TestRouterNotFoundWithRemoveExtraSlash(t *testing.T) {\n\trouter := New()\n\trouter.RemoveExtraSlash = true\n\trouter.GET(\"/path\", func(c *Context) {})\n\trouter.GET(\"/\", func(c *Context) {})\n\n\ttestRoutes := []struct {\n\t\troute    string\n\t\tcode     int\n\t\tlocation string\n\t}{\n\t\t{\"/../path\", http.StatusOK, \"\"},    // CleanPath\n\t\t{\"/nope\", http.StatusNotFound, \"\"}, // NotFound\n\t}\n\tfor _, tr := range testRoutes {\n\t\tw := PerformRequest(router, http.MethodGet, tr.route)\n\t\tassert.Equal(t, tr.code, w.Code)\n\t\tif w.Code != http.StatusNotFound {\n\t\t\tassert.Equal(t, tr.location, w.Header().Get(\"Location\"))\n\t\t}\n\t}\n}\n\nfunc TestRouterNotFound(t *testing.T) {\n\trouter := New()\n\trouter.RedirectFixedPath = true\n\trouter.GET(\"/path\", func(c *Context) {})\n\trouter.GET(\"/dir/\", func(c *Context) {})\n\trouter.GET(\"/\", func(c *Context) {})\n\n\ttestRoutes := []struct {\n\t\troute    string\n\t\tcode     int\n\t\tlocation string\n\t}{\n\t\t{\"/path/\", http.StatusMovedPermanently, \"/path\"},   // TSR -/\n\t\t{\"/dir\", http.StatusMovedPermanently, \"/dir/\"},     // TSR +/\n\t\t{\"/PATH\", http.StatusMovedPermanently, \"/path\"},    // Fixed Case\n\t\t{\"/DIR/\", http.StatusMovedPermanently, \"/dir/\"},    // Fixed Case\n\t\t{\"/PATH/\", http.StatusMovedPermanently, \"/path\"},   // Fixed Case -/\n\t\t{\"/DIR\", http.StatusMovedPermanently, \"/dir/\"},     // Fixed Case +/\n\t\t{\"/../path\", http.StatusMovedPermanently, \"/path\"}, // Without CleanPath\n\t\t{\"/nope\", http.StatusNotFound, \"\"},                 // NotFound\n\t}\n\tfor _, tr := range testRoutes {\n\t\tw := PerformRequest(router, http.MethodGet, tr.route)\n\t\tassert.Equal(t, tr.code, w.Code)\n\t\tif w.Code != http.StatusNotFound {\n\t\t\tassert.Equal(t, tr.location, w.Header().Get(\"Location\"))\n\t\t}\n\t}\n\n\t// Test custom not found handler\n\tvar notFound bool\n\trouter.NoRoute(func(c *Context) {\n\t\tc.AbortWithStatus(http.StatusNotFound)\n\t\tnotFound = true\n\t})\n\tw := PerformRequest(router, http.MethodGet, \"/nope\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\tassert.True(t, notFound)\n\n\t// Test other method than GET (want 307 instead of 301)\n\trouter.PATCH(\"/path\", func(c *Context) {})\n\tw = PerformRequest(router, http.MethodPatch, \"/path/\")\n\tassert.Equal(t, http.StatusTemporaryRedirect, w.Code)\n\tassert.Equal(t, \"map[Location:[/path]]\", fmt.Sprint(w.Header()))\n\n\t// Test special case where no node for the prefix \"/\" exists\n\trouter = New()\n\trouter.GET(\"/a\", func(c *Context) {})\n\tw = PerformRequest(router, http.MethodGet, \"/\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n\n\t// Reproduction test for the bug of issue #2843\n\trouter = New()\n\trouter.NoRoute(func(c *Context) {\n\t\tif c.Request.RequestURI == \"/login\" {\n\t\t\tc.String(http.StatusOK, \"login\")\n\t\t}\n\t})\n\trouter.GET(\"/logout\", func(c *Context) {\n\t\tc.String(http.StatusOK, \"logout\")\n\t})\n\tw = PerformRequest(router, http.MethodGet, \"/login\")\n\tassert.Equal(t, \"login\", w.Body.String())\n\tw = PerformRequest(router, http.MethodGet, \"/logout\")\n\tassert.Equal(t, \"logout\", w.Body.String())\n}\n\nfunc TestRouterStaticFSNotFound(t *testing.T) {\n\trouter := New()\n\trouter.StaticFS(\"/\", http.FileSystem(http.Dir(\"/thisreallydoesntexist/\")))\n\trouter.NoRoute(func(c *Context) {\n\t\tc.String(http.StatusNotFound, \"non existent\")\n\t})\n\n\tw := PerformRequest(router, http.MethodGet, \"/nonexistent\")\n\tassert.Equal(t, \"non existent\", w.Body.String())\n\n\tw = PerformRequest(router, http.MethodHead, \"/nonexistent\")\n\tassert.Equal(t, \"non existent\", w.Body.String())\n}\n\nfunc TestRouterStaticFSFileNotFound(t *testing.T) {\n\trouter := New()\n\n\trouter.StaticFS(\"/\", http.FileSystem(http.Dir(\".\")))\n\n\tassert.NotPanics(t, func() {\n\t\tPerformRequest(router, http.MethodGet, \"/nonexistent\")\n\t})\n}\n\n// Reproduction test for the bug of issue #1805\nfunc TestMiddlewareCalledOnceByRouterStaticFSNotFound(t *testing.T) {\n\trouter := New()\n\n\t// Middleware must be called just only once by per request.\n\tmiddlewareCalledNum := 0\n\trouter.Use(func(c *Context) {\n\t\tmiddlewareCalledNum++\n\t})\n\n\trouter.StaticFS(\"/\", http.FileSystem(http.Dir(\"/thisreallydoesntexist/\")))\n\n\t// First access\n\tPerformRequest(router, http.MethodGet, \"/nonexistent\")\n\tassert.Equal(t, 1, middlewareCalledNum)\n\n\t// Second access\n\tPerformRequest(router, http.MethodHead, \"/nonexistent\")\n\tassert.Equal(t, 2, middlewareCalledNum)\n}\n\nfunc TestRouteRawPath(t *testing.T) {\n\troute := New()\n\troute.UseRawPath = true\n\n\troute.POST(\"/project/:name/build/:num\", func(c *Context) {\n\t\tname := c.Params.ByName(\"name\")\n\t\tnum := c.Params.ByName(\"num\")\n\n\t\tassert.Equal(t, name, c.Param(\"name\"))\n\t\tassert.Equal(t, num, c.Param(\"num\"))\n\n\t\tassert.Equal(t, \"Some/Other/Project\", name)\n\t\tassert.Equal(t, \"222\", num)\n\t})\n\n\tw := PerformRequest(route, http.MethodPost, \"/project/Some%2FOther%2FProject/build/222\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n}\n\nfunc TestRouteRawPathNoUnescape(t *testing.T) {\n\troute := New()\n\troute.UseRawPath = true\n\troute.UnescapePathValues = false\n\n\troute.POST(\"/project/:name/build/:num\", func(c *Context) {\n\t\tname := c.Params.ByName(\"name\")\n\t\tnum := c.Params.ByName(\"num\")\n\n\t\tassert.Equal(t, name, c.Param(\"name\"))\n\t\tassert.Equal(t, num, c.Param(\"num\"))\n\n\t\tassert.Equal(t, \"Some%2FOther%2FProject\", name)\n\t\tassert.Equal(t, \"333\", num)\n\t})\n\n\tw := PerformRequest(route, http.MethodPost, \"/project/Some%2FOther%2FProject/build/333\")\n\tassert.Equal(t, http.StatusOK, w.Code)\n}\n\nfunc TestRouteServeErrorWithWriteHeader(t *testing.T) {\n\troute := New()\n\troute.Use(func(c *Context) {\n\t\tc.Status(http.StatusMisdirectedRequest)\n\t\tc.Next()\n\t})\n\n\tw := PerformRequest(route, http.MethodGet, \"/NotFound\")\n\tassert.Equal(t, http.StatusMisdirectedRequest, w.Code)\n\tassert.Equal(t, 0, w.Body.Len())\n}\n\nfunc TestRouteContextHoldsFullPath(t *testing.T) {\n\trouter := New()\n\n\t// Test routes\n\troutes := []string{\n\t\t\"/simple\",\n\t\t\"/project/:name\",\n\t\t\"/\",\n\t\t\"/news/home\",\n\t\t\"/news\",\n\t\t\"/simple-two/one\",\n\t\t\"/simple-two/one-two\",\n\t\t\"/project/:name/build/*params\",\n\t\t\"/project/:name/bui\",\n\t\t\"/user/:id/status\",\n\t\t\"/user/:id\",\n\t\t\"/user/:id/profile\",\n\t}\n\n\tfor _, route := range routes {\n\t\tactualRoute := route\n\t\trouter.GET(route, func(c *Context) {\n\t\t\t// For each defined route context should contain its full path\n\t\t\tassert.Equal(t, actualRoute, c.FullPath())\n\t\t\tc.AbortWithStatus(http.StatusOK)\n\t\t})\n\t}\n\n\tfor _, route := range routes {\n\t\tw := PerformRequest(router, http.MethodGet, route)\n\t\tassert.Equal(t, http.StatusOK, w.Code)\n\t}\n\n\t// Test not found\n\trouter.Use(func(c *Context) {\n\t\t// For not found routes full path is empty\n\t\tassert.Equal(t, \"\", c.FullPath())\n\t})\n\n\tw := PerformRequest(router, http.MethodGet, \"/not-found\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n}\n\nfunc TestEngineHandleMethodNotAllowedCornerCase(t *testing.T) {\n\tr := New()\n\tr.HandleMethodNotAllowed = true\n\n\tbase := r.Group(\"base\")\n\tbase.GET(\"/metrics\", handlerTest1)\n\n\tv1 := base.Group(\"v1\")\n\n\tv1.GET(\"/:id/devices\", handlerTest1)\n\tv1.GET(\"/user/:id/groups\", handlerTest1)\n\n\tv1.GET(\"/orgs/:id\", handlerTest1)\n\tv1.DELETE(\"/orgs/:id\", handlerTest1)\n\n\tw := PerformRequest(r, http.MethodGet, \"/base/v1/user/groups\")\n\tassert.Equal(t, http.StatusNotFound, w.Code)\n}\n"
        },
        {
          "name": "test_helpers.go",
          "type": "blob",
          "size": 0.6572265625,
          "content": "// Copyright 2017 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport \"net/http\"\n\n// CreateTestContext returns a fresh engine and context for testing purposes\nfunc CreateTestContext(w http.ResponseWriter) (c *Context, r *Engine) {\n\tr = New()\n\tc = r.allocateContext(0)\n\tc.reset()\n\tc.writermem.reset(w)\n\treturn\n}\n\n// CreateTestContextOnly returns a fresh context base on the engine for testing purposes\nfunc CreateTestContextOnly(w http.ResponseWriter, r *Engine) (c *Context) {\n\tc = r.allocateContext(r.maxParams)\n\tc.reset()\n\tc.writermem.reset(w)\n\treturn\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "tree.go",
          "type": "blob",
          "size": 22.5361328125,
          "content": "// Copyright 2013 Julien Schmidt. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be found\n// at https://github.com/julienschmidt/httprouter/blob/master/LICENSE\n\npackage gin\n\nimport (\n\t\"bytes\"\n\t\"net/url\"\n\t\"strings\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n\n\t\"github.com/gin-gonic/gin/internal/bytesconv\"\n)\n\nvar (\n\tstrColon = []byte(\":\")\n\tstrStar  = []byte(\"*\")\n\tstrSlash = []byte(\"/\")\n)\n\n// Param is a single URL parameter, consisting of a key and a value.\ntype Param struct {\n\tKey   string\n\tValue string\n}\n\n// Params is a Param-slice, as returned by the router.\n// The slice is ordered, the first URL parameter is also the first slice value.\n// It is therefore safe to read values by the index.\ntype Params []Param\n\n// Get returns the value of the first Param which key matches the given name and a boolean true.\n// If no matching Param is found, an empty string is returned and a boolean false .\nfunc (ps Params) Get(name string) (string, bool) {\n\tfor _, entry := range ps {\n\t\tif entry.Key == name {\n\t\t\treturn entry.Value, true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\n// ByName returns the value of the first Param which key matches the given name.\n// If no matching Param is found, an empty string is returned.\nfunc (ps Params) ByName(name string) (va string) {\n\tva, _ = ps.Get(name)\n\treturn\n}\n\ntype methodTree struct {\n\tmethod string\n\troot   *node\n}\n\ntype methodTrees []methodTree\n\nfunc (trees methodTrees) get(method string) *node {\n\tfor _, tree := range trees {\n\t\tif tree.method == method {\n\t\t\treturn tree.root\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc longestCommonPrefix(a, b string) int {\n\ti := 0\n\tmax_ := min(len(a), len(b))\n\tfor i < max_ && a[i] == b[i] {\n\t\ti++\n\t}\n\treturn i\n}\n\n// addChild will add a child node, keeping wildcardChild at the end\nfunc (n *node) addChild(child *node) {\n\tif n.wildChild && len(n.children) > 0 {\n\t\twildcardChild := n.children[len(n.children)-1]\n\t\tn.children = append(n.children[:len(n.children)-1], child, wildcardChild)\n\t} else {\n\t\tn.children = append(n.children, child)\n\t}\n}\n\nfunc countParams(path string) uint16 {\n\tvar n uint16\n\ts := bytesconv.StringToBytes(path)\n\tn += uint16(bytes.Count(s, strColon))\n\tn += uint16(bytes.Count(s, strStar))\n\treturn n\n}\n\nfunc countSections(path string) uint16 {\n\ts := bytesconv.StringToBytes(path)\n\treturn uint16(bytes.Count(s, strSlash))\n}\n\ntype nodeType uint8\n\nconst (\n\tstatic nodeType = iota\n\troot\n\tparam\n\tcatchAll\n)\n\ntype node struct {\n\tpath      string\n\tindices   string\n\twildChild bool\n\tnType     nodeType\n\tpriority  uint32\n\tchildren  []*node // child nodes, at most 1 :param style node at the end of the array\n\thandlers  HandlersChain\n\tfullPath  string\n}\n\n// Increments priority of the given child and reorders if necessary\nfunc (n *node) incrementChildPrio(pos int) int {\n\tcs := n.children\n\tcs[pos].priority++\n\tprio := cs[pos].priority\n\n\t// Adjust position (move to front)\n\tnewPos := pos\n\tfor ; newPos > 0 && cs[newPos-1].priority < prio; newPos-- {\n\t\t// Swap node positions\n\t\tcs[newPos-1], cs[newPos] = cs[newPos], cs[newPos-1]\n\t}\n\n\t// Build new index char string\n\tif newPos != pos {\n\t\tn.indices = n.indices[:newPos] + // Unchanged prefix, might be empty\n\t\t\tn.indices[pos:pos+1] + // The index char we move\n\t\t\tn.indices[newPos:pos] + n.indices[pos+1:] // Rest without char at 'pos'\n\t}\n\n\treturn newPos\n}\n\n// addRoute adds a node with the given handle to the path.\n// Not concurrency-safe!\nfunc (n *node) addRoute(path string, handlers HandlersChain) {\n\tfullPath := path\n\tn.priority++\n\n\t// Empty tree\n\tif len(n.path) == 0 && len(n.children) == 0 {\n\t\tn.insertChild(path, fullPath, handlers)\n\t\tn.nType = root\n\t\treturn\n\t}\n\n\tparentFullPathIndex := 0\n\nwalk:\n\tfor {\n\t\t// Find the longest common prefix.\n\t\t// This also implies that the common prefix contains no ':' or '*'\n\t\t// since the existing key can't contain those chars.\n\t\ti := longestCommonPrefix(path, n.path)\n\n\t\t// Split edge\n\t\tif i < len(n.path) {\n\t\t\tchild := node{\n\t\t\t\tpath:      n.path[i:],\n\t\t\t\twildChild: n.wildChild,\n\t\t\t\tnType:     static,\n\t\t\t\tindices:   n.indices,\n\t\t\t\tchildren:  n.children,\n\t\t\t\thandlers:  n.handlers,\n\t\t\t\tpriority:  n.priority - 1,\n\t\t\t\tfullPath:  n.fullPath,\n\t\t\t}\n\n\t\t\tn.children = []*node{&child}\n\t\t\t// []byte for proper unicode char conversion, see #65\n\t\t\tn.indices = bytesconv.BytesToString([]byte{n.path[i]})\n\t\t\tn.path = path[:i]\n\t\t\tn.handlers = nil\n\t\t\tn.wildChild = false\n\t\t\tn.fullPath = fullPath[:parentFullPathIndex+i]\n\t\t}\n\n\t\t// Make new node a child of this node\n\t\tif i < len(path) {\n\t\t\tpath = path[i:]\n\t\t\tc := path[0]\n\n\t\t\t// '/' after param\n\t\t\tif n.nType == param && c == '/' && len(n.children) == 1 {\n\t\t\t\tparentFullPathIndex += len(n.path)\n\t\t\t\tn = n.children[0]\n\t\t\t\tn.priority++\n\t\t\t\tcontinue walk\n\t\t\t}\n\n\t\t\t// Check if a child with the next path byte exists\n\t\t\tfor i, max_ := 0, len(n.indices); i < max_; i++ {\n\t\t\t\tif c == n.indices[i] {\n\t\t\t\t\tparentFullPathIndex += len(n.path)\n\t\t\t\t\ti = n.incrementChildPrio(i)\n\t\t\t\t\tn = n.children[i]\n\t\t\t\t\tcontinue walk\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Otherwise insert it\n\t\t\tif c != ':' && c != '*' && n.nType != catchAll {\n\t\t\t\t// []byte for proper unicode char conversion, see #65\n\t\t\t\tn.indices += bytesconv.BytesToString([]byte{c})\n\t\t\t\tchild := &node{\n\t\t\t\t\tfullPath: fullPath,\n\t\t\t\t}\n\t\t\t\tn.addChild(child)\n\t\t\t\tn.incrementChildPrio(len(n.indices) - 1)\n\t\t\t\tn = child\n\t\t\t} else if n.wildChild {\n\t\t\t\t// inserting a wildcard node, need to check if it conflicts with the existing wildcard\n\t\t\t\tn = n.children[len(n.children)-1]\n\t\t\t\tn.priority++\n\n\t\t\t\t// Check if the wildcard matches\n\t\t\t\tif len(path) >= len(n.path) && n.path == path[:len(n.path)] &&\n\t\t\t\t\t// Adding a child to a catchAll is not possible\n\t\t\t\t\tn.nType != catchAll &&\n\t\t\t\t\t// Check for longer wildcard, e.g. :name and :names\n\t\t\t\t\t(len(n.path) >= len(path) || path[len(n.path)] == '/') {\n\t\t\t\t\tcontinue walk\n\t\t\t\t}\n\n\t\t\t\t// Wildcard conflict\n\t\t\t\tpathSeg := path\n\t\t\t\tif n.nType != catchAll {\n\t\t\t\t\tpathSeg = strings.SplitN(pathSeg, \"/\", 2)[0]\n\t\t\t\t}\n\t\t\t\tprefix := fullPath[:strings.Index(fullPath, pathSeg)] + n.path\n\t\t\t\tpanic(\"'\" + pathSeg +\n\t\t\t\t\t\"' in new path '\" + fullPath +\n\t\t\t\t\t\"' conflicts with existing wildcard '\" + n.path +\n\t\t\t\t\t\"' in existing prefix '\" + prefix +\n\t\t\t\t\t\"'\")\n\t\t\t}\n\n\t\t\tn.insertChild(path, fullPath, handlers)\n\t\t\treturn\n\t\t}\n\n\t\t// Otherwise add handle to current node\n\t\tif n.handlers != nil {\n\t\t\tpanic(\"handlers are already registered for path '\" + fullPath + \"'\")\n\t\t}\n\t\tn.handlers = handlers\n\t\tn.fullPath = fullPath\n\t\treturn\n\t}\n}\n\n// Search for a wildcard segment and check the name for invalid characters.\n// Returns -1 as index, if no wildcard was found.\nfunc findWildcard(path string) (wildcard string, i int, valid bool) {\n\t// Find start\n\tescapeColon := false\n\tfor start, c := range []byte(path) {\n\t\tif escapeColon {\n\t\t\tescapeColon = false\n\t\t\tif c == ':' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpanic(\"invalid escape string in path '\" + path + \"'\")\n\t\t}\n\t\tif c == '\\\\' {\n\t\t\tescapeColon = true\n\t\t\tcontinue\n\t\t}\n\t\t// A wildcard starts with ':' (param) or '*' (catch-all)\n\t\tif c != ':' && c != '*' {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Find end and check for invalid characters\n\t\tvalid = true\n\t\tfor end, c := range []byte(path[start+1:]) {\n\t\t\tswitch c {\n\t\t\tcase '/':\n\t\t\t\treturn path[start : start+1+end], start, valid\n\t\t\tcase ':', '*':\n\t\t\t\tvalid = false\n\t\t\t}\n\t\t}\n\t\treturn path[start:], start, valid\n\t}\n\treturn \"\", -1, false\n}\n\nfunc (n *node) insertChild(path string, fullPath string, handlers HandlersChain) {\n\tfor {\n\t\t// Find prefix until first wildcard\n\t\twildcard, i, valid := findWildcard(path)\n\t\tif i < 0 { // No wildcard found\n\t\t\tbreak\n\t\t}\n\n\t\t// The wildcard name must only contain one ':' or '*' character\n\t\tif !valid {\n\t\t\tpanic(\"only one wildcard per path segment is allowed, has: '\" +\n\t\t\t\twildcard + \"' in path '\" + fullPath + \"'\")\n\t\t}\n\n\t\t// check if the wildcard has a name\n\t\tif len(wildcard) < 2 {\n\t\t\tpanic(\"wildcards must be named with a non-empty name in path '\" + fullPath + \"'\")\n\t\t}\n\n\t\tif wildcard[0] == ':' { // param\n\t\t\tif i > 0 {\n\t\t\t\t// Insert prefix before the current wildcard\n\t\t\t\tn.path = path[:i]\n\t\t\t\tpath = path[i:]\n\t\t\t}\n\n\t\t\tchild := &node{\n\t\t\t\tnType:    param,\n\t\t\t\tpath:     wildcard,\n\t\t\t\tfullPath: fullPath,\n\t\t\t}\n\t\t\tn.addChild(child)\n\t\t\tn.wildChild = true\n\t\t\tn = child\n\t\t\tn.priority++\n\n\t\t\t// if the path doesn't end with the wildcard, then there\n\t\t\t// will be another subpath starting with '/'\n\t\t\tif len(wildcard) < len(path) {\n\t\t\t\tpath = path[len(wildcard):]\n\n\t\t\t\tchild := &node{\n\t\t\t\t\tpriority: 1,\n\t\t\t\t\tfullPath: fullPath,\n\t\t\t\t}\n\t\t\t\tn.addChild(child)\n\t\t\t\tn = child\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Otherwise we're done. Insert the handle in the new leaf\n\t\t\tn.handlers = handlers\n\t\t\treturn\n\t\t}\n\n\t\t// catchAll\n\t\tif i+len(wildcard) != len(path) {\n\t\t\tpanic(\"catch-all routes are only allowed at the end of the path in path '\" + fullPath + \"'\")\n\t\t}\n\n\t\tif len(n.path) > 0 && n.path[len(n.path)-1] == '/' {\n\t\t\tpathSeg := \"\"\n\t\t\tif len(n.children) != 0 {\n\t\t\t\tpathSeg = strings.SplitN(n.children[0].path, \"/\", 2)[0]\n\t\t\t}\n\t\t\tpanic(\"catch-all wildcard '\" + path +\n\t\t\t\t\"' in new path '\" + fullPath +\n\t\t\t\t\"' conflicts with existing path segment '\" + pathSeg +\n\t\t\t\t\"' in existing prefix '\" + n.path + pathSeg +\n\t\t\t\t\"'\")\n\t\t}\n\n\t\t// currently fixed width 1 for '/'\n\t\ti--\n\t\tif i < 0 || path[i] != '/' {\n\t\t\tpanic(\"no / before catch-all in path '\" + fullPath + \"'\")\n\t\t}\n\n\t\tn.path = path[:i]\n\n\t\t// First node: catchAll node with empty path\n\t\tchild := &node{\n\t\t\twildChild: true,\n\t\t\tnType:     catchAll,\n\t\t\tfullPath:  fullPath,\n\t\t}\n\n\t\tn.addChild(child)\n\t\tn.indices = string('/')\n\t\tn = child\n\t\tn.priority++\n\n\t\t// second node: node holding the variable\n\t\tchild = &node{\n\t\t\tpath:     path[i:],\n\t\t\tnType:    catchAll,\n\t\t\thandlers: handlers,\n\t\t\tpriority: 1,\n\t\t\tfullPath: fullPath,\n\t\t}\n\t\tn.children = []*node{child}\n\n\t\treturn\n\t}\n\n\t// If no wildcard was found, simply insert the path and handle\n\tn.path = path\n\tn.handlers = handlers\n\tn.fullPath = fullPath\n}\n\n// nodeValue holds return values of (*Node).getValue method\ntype nodeValue struct {\n\thandlers HandlersChain\n\tparams   *Params\n\ttsr      bool\n\tfullPath string\n}\n\ntype skippedNode struct {\n\tpath        string\n\tnode        *node\n\tparamsCount int16\n}\n\n// Returns the handle registered with the given path (key). The values of\n// wildcards are saved to a map.\n// If no handle can be found, a TSR (trailing slash redirect) recommendation is\n// made if a handle exists with an extra (without the) trailing slash for the\n// given path.\nfunc (n *node) getValue(path string, params *Params, skippedNodes *[]skippedNode, unescape bool) (value nodeValue) {\n\tvar globalParamsCount int16\n\nwalk: // Outer loop for walking the tree\n\tfor {\n\t\tprefix := n.path\n\t\tif len(path) > len(prefix) {\n\t\t\tif path[:len(prefix)] == prefix {\n\t\t\t\tpath = path[len(prefix):]\n\n\t\t\t\t// Try all the non-wildcard children first by matching the indices\n\t\t\t\tidxc := path[0]\n\t\t\t\tfor i, c := range []byte(n.indices) {\n\t\t\t\t\tif c == idxc {\n\t\t\t\t\t\t//  strings.HasPrefix(n.children[len(n.children)-1].path, \":\") == n.wildChild\n\t\t\t\t\t\tif n.wildChild {\n\t\t\t\t\t\t\tindex := len(*skippedNodes)\n\t\t\t\t\t\t\t*skippedNodes = (*skippedNodes)[:index+1]\n\t\t\t\t\t\t\t(*skippedNodes)[index] = skippedNode{\n\t\t\t\t\t\t\t\tpath: prefix + path,\n\t\t\t\t\t\t\t\tnode: &node{\n\t\t\t\t\t\t\t\t\tpath:      n.path,\n\t\t\t\t\t\t\t\t\twildChild: n.wildChild,\n\t\t\t\t\t\t\t\t\tnType:     n.nType,\n\t\t\t\t\t\t\t\t\tpriority:  n.priority,\n\t\t\t\t\t\t\t\t\tchildren:  n.children,\n\t\t\t\t\t\t\t\t\thandlers:  n.handlers,\n\t\t\t\t\t\t\t\t\tfullPath:  n.fullPath,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tparamsCount: globalParamsCount,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tn = n.children[i]\n\t\t\t\t\t\tcontinue walk\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif !n.wildChild {\n\t\t\t\t\t// If the path at the end of the loop is not equal to '/' and the current node has no child nodes\n\t\t\t\t\t// the current node needs to roll back to last valid skippedNode\n\t\t\t\t\tif path != \"/\" {\n\t\t\t\t\t\tfor length := len(*skippedNodes); length > 0; length-- {\n\t\t\t\t\t\t\tskippedNode := (*skippedNodes)[length-1]\n\t\t\t\t\t\t\t*skippedNodes = (*skippedNodes)[:length-1]\n\t\t\t\t\t\t\tif strings.HasSuffix(skippedNode.path, path) {\n\t\t\t\t\t\t\t\tpath = skippedNode.path\n\t\t\t\t\t\t\t\tn = skippedNode.node\n\t\t\t\t\t\t\t\tif value.params != nil {\n\t\t\t\t\t\t\t\t\t*value.params = (*value.params)[:skippedNode.paramsCount]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tglobalParamsCount = skippedNode.paramsCount\n\t\t\t\t\t\t\t\tcontinue walk\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Nothing found.\n\t\t\t\t\t// We can recommend to redirect to the same URL without a\n\t\t\t\t\t// trailing slash if a leaf exists for that path.\n\t\t\t\t\tvalue.tsr = path == \"/\" && n.handlers != nil\n\t\t\t\t\treturn value\n\t\t\t\t}\n\n\t\t\t\t// Handle wildcard child, which is always at the end of the array\n\t\t\t\tn = n.children[len(n.children)-1]\n\t\t\t\tglobalParamsCount++\n\n\t\t\t\tswitch n.nType {\n\t\t\t\tcase param:\n\t\t\t\t\t// fix truncate the parameter\n\t\t\t\t\t// tree_test.go  line: 204\n\n\t\t\t\t\t// Find param end (either '/' or path end)\n\t\t\t\t\tend := 0\n\t\t\t\t\tfor end < len(path) && path[end] != '/' {\n\t\t\t\t\t\tend++\n\t\t\t\t\t}\n\n\t\t\t\t\t// Save param value\n\t\t\t\t\tif params != nil {\n\t\t\t\t\t\t// Preallocate capacity if necessary\n\t\t\t\t\t\tif cap(*params) < int(globalParamsCount) {\n\t\t\t\t\t\t\tnewParams := make(Params, len(*params), globalParamsCount)\n\t\t\t\t\t\t\tcopy(newParams, *params)\n\t\t\t\t\t\t\t*params = newParams\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif value.params == nil {\n\t\t\t\t\t\t\tvalue.params = params\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Expand slice within preallocated capacity\n\t\t\t\t\t\ti := len(*value.params)\n\t\t\t\t\t\t*value.params = (*value.params)[:i+1]\n\t\t\t\t\t\tval := path[:end]\n\t\t\t\t\t\tif unescape {\n\t\t\t\t\t\t\tif v, err := url.QueryUnescape(val); err == nil {\n\t\t\t\t\t\t\t\tval = v\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(*value.params)[i] = Param{\n\t\t\t\t\t\t\tKey:   n.path[1:],\n\t\t\t\t\t\t\tValue: val,\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// we need to go deeper!\n\t\t\t\t\tif end < len(path) {\n\t\t\t\t\t\tif len(n.children) > 0 {\n\t\t\t\t\t\t\tpath = path[end:]\n\t\t\t\t\t\t\tn = n.children[0]\n\t\t\t\t\t\t\tcontinue walk\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// ... but we can't\n\t\t\t\t\t\tvalue.tsr = len(path) == end+1\n\t\t\t\t\t\treturn value\n\t\t\t\t\t}\n\n\t\t\t\t\tif value.handlers = n.handlers; value.handlers != nil {\n\t\t\t\t\t\tvalue.fullPath = n.fullPath\n\t\t\t\t\t\treturn value\n\t\t\t\t\t}\n\t\t\t\t\tif len(n.children) == 1 {\n\t\t\t\t\t\t// No handle found. Check if a handle for this path + a\n\t\t\t\t\t\t// trailing slash exists for TSR recommendation\n\t\t\t\t\t\tn = n.children[0]\n\t\t\t\t\t\tvalue.tsr = (n.path == \"/\" && n.handlers != nil) || (n.path == \"\" && n.indices == \"/\")\n\t\t\t\t\t}\n\t\t\t\t\treturn value\n\n\t\t\t\tcase catchAll:\n\t\t\t\t\t// Save param value\n\t\t\t\t\tif params != nil {\n\t\t\t\t\t\t// Preallocate capacity if necessary\n\t\t\t\t\t\tif cap(*params) < int(globalParamsCount) {\n\t\t\t\t\t\t\tnewParams := make(Params, len(*params), globalParamsCount)\n\t\t\t\t\t\t\tcopy(newParams, *params)\n\t\t\t\t\t\t\t*params = newParams\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif value.params == nil {\n\t\t\t\t\t\t\tvalue.params = params\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Expand slice within preallocated capacity\n\t\t\t\t\t\ti := len(*value.params)\n\t\t\t\t\t\t*value.params = (*value.params)[:i+1]\n\t\t\t\t\t\tval := path\n\t\t\t\t\t\tif unescape {\n\t\t\t\t\t\t\tif v, err := url.QueryUnescape(path); err == nil {\n\t\t\t\t\t\t\t\tval = v\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t(*value.params)[i] = Param{\n\t\t\t\t\t\t\tKey:   n.path[2:],\n\t\t\t\t\t\t\tValue: val,\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue.handlers = n.handlers\n\t\t\t\t\tvalue.fullPath = n.fullPath\n\t\t\t\t\treturn value\n\n\t\t\t\tdefault:\n\t\t\t\t\tpanic(\"invalid node type\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif path == prefix {\n\t\t\t// If the current path does not equal '/' and the node does not have a registered handle and the most recently matched node has a child node\n\t\t\t// the current node needs to roll back to last valid skippedNode\n\t\t\tif n.handlers == nil && path != \"/\" {\n\t\t\t\tfor length := len(*skippedNodes); length > 0; length-- {\n\t\t\t\t\tskippedNode := (*skippedNodes)[length-1]\n\t\t\t\t\t*skippedNodes = (*skippedNodes)[:length-1]\n\t\t\t\t\tif strings.HasSuffix(skippedNode.path, path) {\n\t\t\t\t\t\tpath = skippedNode.path\n\t\t\t\t\t\tn = skippedNode.node\n\t\t\t\t\t\tif value.params != nil {\n\t\t\t\t\t\t\t*value.params = (*value.params)[:skippedNode.paramsCount]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tglobalParamsCount = skippedNode.paramsCount\n\t\t\t\t\t\tcontinue walk\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\tn = latestNode.children[len(latestNode.children)-1]\n\t\t\t}\n\t\t\t// We should have reached the node containing the handle.\n\t\t\t// Check if this node has a handle registered.\n\t\t\tif value.handlers = n.handlers; value.handlers != nil {\n\t\t\t\tvalue.fullPath = n.fullPath\n\t\t\t\treturn value\n\t\t\t}\n\n\t\t\t// If there is no handle for this route, but this route has a\n\t\t\t// wildcard child, there must be a handle for this path with an\n\t\t\t// additional trailing slash\n\t\t\tif path == \"/\" && n.wildChild && n.nType != root {\n\t\t\t\tvalue.tsr = true\n\t\t\t\treturn value\n\t\t\t}\n\n\t\t\tif path == \"/\" && n.nType == static {\n\t\t\t\tvalue.tsr = true\n\t\t\t\treturn value\n\t\t\t}\n\n\t\t\t// No handle found. Check if a handle for this path + a\n\t\t\t// trailing slash exists for trailing slash recommendation\n\t\t\tfor i, c := range []byte(n.indices) {\n\t\t\t\tif c == '/' {\n\t\t\t\t\tn = n.children[i]\n\t\t\t\t\tvalue.tsr = (len(n.path) == 1 && n.handlers != nil) ||\n\t\t\t\t\t\t(n.nType == catchAll && n.children[0].handlers != nil)\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value\n\t\t}\n\n\t\t// Nothing found. We can recommend to redirect to the same URL with an\n\t\t// extra trailing slash if a leaf exists for that path\n\t\tvalue.tsr = path == \"/\" ||\n\t\t\t(len(prefix) == len(path)+1 && prefix[len(path)] == '/' &&\n\t\t\t\tpath == prefix[:len(prefix)-1] && n.handlers != nil)\n\n\t\t// roll back to last valid skippedNode\n\t\tif !value.tsr && path != \"/\" {\n\t\t\tfor length := len(*skippedNodes); length > 0; length-- {\n\t\t\t\tskippedNode := (*skippedNodes)[length-1]\n\t\t\t\t*skippedNodes = (*skippedNodes)[:length-1]\n\t\t\t\tif strings.HasSuffix(skippedNode.path, path) {\n\t\t\t\t\tpath = skippedNode.path\n\t\t\t\t\tn = skippedNode.node\n\t\t\t\t\tif value.params != nil {\n\t\t\t\t\t\t*value.params = (*value.params)[:skippedNode.paramsCount]\n\t\t\t\t\t}\n\t\t\t\t\tglobalParamsCount = skippedNode.paramsCount\n\t\t\t\t\tcontinue walk\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value\n\t}\n}\n\n// Makes a case-insensitive lookup of the given path and tries to find a handler.\n// It can optionally also fix trailing slashes.\n// It returns the case-corrected path and a bool indicating whether the lookup\n// was successful.\nfunc (n *node) findCaseInsensitivePath(path string, fixTrailingSlash bool) ([]byte, bool) {\n\tconst stackBufSize = 128\n\n\t// Use a static sized buffer on the stack in the common case.\n\t// If the path is too long, allocate a buffer on the heap instead.\n\tbuf := make([]byte, 0, stackBufSize)\n\tif length := len(path) + 1; length > stackBufSize {\n\t\tbuf = make([]byte, 0, length)\n\t}\n\n\tciPath := n.findCaseInsensitivePathRec(\n\t\tpath,\n\t\tbuf,       // Preallocate enough memory for new path\n\t\t[4]byte{}, // Empty rune buffer\n\t\tfixTrailingSlash,\n\t)\n\n\treturn ciPath, ciPath != nil\n}\n\n// Shift bytes in array by n bytes left\nfunc shiftNRuneBytes(rb [4]byte, n int) [4]byte {\n\tswitch n {\n\tcase 0:\n\t\treturn rb\n\tcase 1:\n\t\treturn [4]byte{rb[1], rb[2], rb[3], 0}\n\tcase 2:\n\t\treturn [4]byte{rb[2], rb[3]}\n\tcase 3:\n\t\treturn [4]byte{rb[3]}\n\tdefault:\n\t\treturn [4]byte{}\n\t}\n}\n\n// Recursive case-insensitive lookup function used by n.findCaseInsensitivePath\nfunc (n *node) findCaseInsensitivePathRec(path string, ciPath []byte, rb [4]byte, fixTrailingSlash bool) []byte {\n\tnpLen := len(n.path)\n\nwalk: // Outer loop for walking the tree\n\tfor len(path) >= npLen && (npLen == 0 || strings.EqualFold(path[1:npLen], n.path[1:])) {\n\t\t// Add common prefix to result\n\t\toldPath := path\n\t\tpath = path[npLen:]\n\t\tciPath = append(ciPath, n.path...)\n\n\t\tif len(path) == 0 {\n\t\t\t// We should have reached the node containing the handle.\n\t\t\t// Check if this node has a handle registered.\n\t\t\tif n.handlers != nil {\n\t\t\t\treturn ciPath\n\t\t\t}\n\n\t\t\t// No handle found.\n\t\t\t// Try to fix the path by adding a trailing slash\n\t\t\tif fixTrailingSlash {\n\t\t\t\tfor i, c := range []byte(n.indices) {\n\t\t\t\t\tif c == '/' {\n\t\t\t\t\t\tn = n.children[i]\n\t\t\t\t\t\tif (len(n.path) == 1 && n.handlers != nil) ||\n\t\t\t\t\t\t\t(n.nType == catchAll && n.children[0].handlers != nil) {\n\t\t\t\t\t\t\treturn append(ciPath, '/')\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\t// If this node does not have a wildcard (param or catchAll) child,\n\t\t// we can just look up the next child node and continue to walk down\n\t\t// the tree\n\t\tif !n.wildChild {\n\t\t\t// Skip rune bytes already processed\n\t\t\trb = shiftNRuneBytes(rb, npLen)\n\n\t\t\tif rb[0] != 0 {\n\t\t\t\t// Old rune not finished\n\t\t\t\tidxc := rb[0]\n\t\t\t\tfor i, c := range []byte(n.indices) {\n\t\t\t\t\tif c == idxc {\n\t\t\t\t\t\t// continue with child node\n\t\t\t\t\t\tn = n.children[i]\n\t\t\t\t\t\tnpLen = len(n.path)\n\t\t\t\t\t\tcontinue walk\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Process a new rune\n\t\t\t\tvar rv rune\n\n\t\t\t\t// Find rune start.\n\t\t\t\t// Runes are up to 4 byte long,\n\t\t\t\t// -4 would definitely be another rune.\n\t\t\t\tvar off int\n\t\t\t\tfor max_ := min(npLen, 3); off < max_; off++ {\n\t\t\t\t\tif i := npLen - off; utf8.RuneStart(oldPath[i]) {\n\t\t\t\t\t\t// read rune from cached path\n\t\t\t\t\t\trv, _ = utf8.DecodeRuneInString(oldPath[i:])\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Calculate lowercase bytes of current rune\n\t\t\t\tlo := unicode.ToLower(rv)\n\t\t\t\tutf8.EncodeRune(rb[:], lo)\n\n\t\t\t\t// Skip already processed bytes\n\t\t\t\trb = shiftNRuneBytes(rb, off)\n\n\t\t\t\tidxc := rb[0]\n\t\t\t\tfor i, c := range []byte(n.indices) {\n\t\t\t\t\t// Lowercase matches\n\t\t\t\t\tif c == idxc {\n\t\t\t\t\t\t// must use a recursive approach since both the\n\t\t\t\t\t\t// uppercase byte and the lowercase byte might exist\n\t\t\t\t\t\t// as an index\n\t\t\t\t\t\tif out := n.children[i].findCaseInsensitivePathRec(\n\t\t\t\t\t\t\tpath, ciPath, rb, fixTrailingSlash,\n\t\t\t\t\t\t); out != nil {\n\t\t\t\t\t\t\treturn out\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If we found no match, the same for the uppercase rune,\n\t\t\t\t// if it differs\n\t\t\t\tif up := unicode.ToUpper(rv); up != lo {\n\t\t\t\t\tutf8.EncodeRune(rb[:], up)\n\t\t\t\t\trb = shiftNRuneBytes(rb, off)\n\n\t\t\t\t\tidxc := rb[0]\n\t\t\t\t\tfor i, c := range []byte(n.indices) {\n\t\t\t\t\t\t// Uppercase matches\n\t\t\t\t\t\tif c == idxc {\n\t\t\t\t\t\t\t// Continue with child node\n\t\t\t\t\t\t\tn = n.children[i]\n\t\t\t\t\t\t\tnpLen = len(n.path)\n\t\t\t\t\t\t\tcontinue walk\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Nothing found. We can recommend to redirect to the same URL\n\t\t\t// without a trailing slash if a leaf exists for that path\n\t\t\tif fixTrailingSlash && path == \"/\" && n.handlers != nil {\n\t\t\t\treturn ciPath\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tn = n.children[0]\n\t\tswitch n.nType {\n\t\tcase param:\n\t\t\t// Find param end (either '/' or path end)\n\t\t\tend := 0\n\t\t\tfor end < len(path) && path[end] != '/' {\n\t\t\t\tend++\n\t\t\t}\n\n\t\t\t// Add param value to case insensitive path\n\t\t\tciPath = append(ciPath, path[:end]...)\n\n\t\t\t// We need to go deeper!\n\t\t\tif end < len(path) {\n\t\t\t\tif len(n.children) > 0 {\n\t\t\t\t\t// Continue with child node\n\t\t\t\t\tn = n.children[0]\n\t\t\t\t\tnpLen = len(n.path)\n\t\t\t\t\tpath = path[end:]\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// ... but we can't\n\t\t\t\tif fixTrailingSlash && len(path) == end+1 {\n\t\t\t\t\treturn ciPath\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif n.handlers != nil {\n\t\t\t\treturn ciPath\n\t\t\t}\n\n\t\t\tif fixTrailingSlash && len(n.children) == 1 {\n\t\t\t\t// No handle found. Check if a handle for this path + a\n\t\t\t\t// trailing slash exists\n\t\t\t\tn = n.children[0]\n\t\t\t\tif n.path == \"/\" && n.handlers != nil {\n\t\t\t\t\treturn append(ciPath, '/')\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\n\t\tcase catchAll:\n\t\t\treturn append(ciPath, path...)\n\n\t\tdefault:\n\t\t\tpanic(\"invalid node type\")\n\t\t}\n\t}\n\n\t// Nothing found.\n\t// Try to fix the path by adding / removing a trailing slash\n\tif fixTrailingSlash {\n\t\tif path == \"/\" {\n\t\t\treturn ciPath\n\t\t}\n\t\tif len(path)+1 == npLen && n.path[len(path)] == '/' &&\n\t\t\tstrings.EqualFold(path[1:], n.path[1:len(path)]) && n.handlers != nil {\n\t\t\treturn append(ciPath, n.path...)\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "tree_test.go",
          "type": "blob",
          "size": 32.1484375,
          "content": "// Copyright 2013 Julien Schmidt. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be found\n// at https://github.com/julienschmidt/httprouter/blob/master/LICENSE\n\npackage gin\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n)\n\n// Used as a workaround since we can't compare functions or their addresses\nvar fakeHandlerValue string\n\nfunc fakeHandler(val string) HandlersChain {\n\treturn HandlersChain{func(c *Context) {\n\t\tfakeHandlerValue = val\n\t}}\n}\n\ntype testRequests []struct {\n\tpath       string\n\tnilHandler bool\n\troute      string\n\tps         Params\n}\n\nfunc getParams() *Params {\n\tps := make(Params, 0, 20)\n\treturn &ps\n}\n\nfunc getSkippedNodes() *[]skippedNode {\n\tps := make([]skippedNode, 0, 20)\n\treturn &ps\n}\n\nfunc checkRequests(t *testing.T, tree *node, requests testRequests, unescapes ...bool) {\n\tunescape := false\n\tif len(unescapes) >= 1 {\n\t\tunescape = unescapes[0]\n\t}\n\n\tfor _, request := range requests {\n\t\tvalue := tree.getValue(request.path, getParams(), getSkippedNodes(), unescape)\n\n\t\tif value.handlers == nil {\n\t\t\tif !request.nilHandler {\n\t\t\t\tt.Errorf(\"handle mismatch for route '%s': Expected non-nil handle\", request.path)\n\t\t\t}\n\t\t} else if request.nilHandler {\n\t\t\tt.Errorf(\"handle mismatch for route '%s': Expected nil handle\", request.path)\n\t\t} else {\n\t\t\tvalue.handlers[0](nil)\n\t\t\tif fakeHandlerValue != request.route {\n\t\t\t\tt.Errorf(\"handle mismatch for route '%s': Wrong handle (%s != %s)\", request.path, fakeHandlerValue, request.route)\n\t\t\t}\n\t\t}\n\n\t\tif value.params != nil {\n\t\t\tif !reflect.DeepEqual(*value.params, request.ps) {\n\t\t\t\tt.Errorf(\"Params mismatch for route '%s'\", request.path)\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nfunc checkPriorities(t *testing.T, n *node) uint32 {\n\tvar prio uint32\n\tfor i := range n.children {\n\t\tprio += checkPriorities(t, n.children[i])\n\t}\n\n\tif n.handlers != nil {\n\t\tprio++\n\t}\n\n\tif n.priority != prio {\n\t\tt.Errorf(\n\t\t\t\"priority mismatch for node '%s': is %d, should be %d\",\n\t\t\tn.path, n.priority, prio,\n\t\t)\n\t}\n\n\treturn prio\n}\n\nfunc TestCountParams(t *testing.T) {\n\tif countParams(\"/path/:param1/static/*catch-all\") != 2 {\n\t\tt.Fail()\n\t}\n\tif countParams(strings.Repeat(\"/:param\", 256)) != 256 {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestTreeAddAndGet(t *testing.T) {\n\ttree := &node{}\n\n\troutes := [...]string{\n\t\t\"/hi\",\n\t\t\"/contact\",\n\t\t\"/co\",\n\t\t\"/c\",\n\t\t\"/a\",\n\t\t\"/ab\",\n\t\t\"/doc/\",\n\t\t\"/doc/go_faq.html\",\n\t\t\"/doc/go1.html\",\n\t\t\"/Œ±\",\n\t\t\"/Œ≤\",\n\t}\n\tfor _, route := range routes {\n\t\ttree.addRoute(route, fakeHandler(route))\n\t}\n\n\tcheckRequests(t, tree, testRequests{\n\t\t{\"/a\", false, \"/a\", nil},\n\t\t{\"/\", true, \"\", nil},\n\t\t{\"/hi\", false, \"/hi\", nil},\n\t\t{\"/contact\", false, \"/contact\", nil},\n\t\t{\"/co\", false, \"/co\", nil},\n\t\t{\"/con\", true, \"\", nil},  // key mismatch\n\t\t{\"/cona\", true, \"\", nil}, // key mismatch\n\t\t{\"/no\", true, \"\", nil},   // no matching child\n\t\t{\"/ab\", false, \"/ab\", nil},\n\t\t{\"/Œ±\", false, \"/Œ±\", nil},\n\t\t{\"/Œ≤\", false, \"/Œ≤\", nil},\n\t})\n\n\tcheckPriorities(t, tree)\n}\n\nfunc TestTreeWildcard(t *testing.T) {\n\ttree := &node{}\n\n\troutes := [...]string{\n\t\t\"/\",\n\t\t\"/cmd/:tool/\",\n\t\t\"/cmd/:tool/:sub\",\n\t\t\"/cmd/whoami\",\n\t\t\"/cmd/whoami/root\",\n\t\t\"/cmd/whoami/root/\",\n\t\t\"/src/*filepath\",\n\t\t\"/search/\",\n\t\t\"/search/:query\",\n\t\t\"/search/gin-gonic\",\n\t\t\"/search/google\",\n\t\t\"/user_:name\",\n\t\t\"/user_:name/about\",\n\t\t\"/files/:dir/*filepath\",\n\t\t\"/doc/\",\n\t\t\"/doc/go_faq.html\",\n\t\t\"/doc/go1.html\",\n\t\t\"/info/:user/public\",\n\t\t\"/info/:user/project/:project\",\n\t\t\"/info/:user/project/golang\",\n\t\t\"/aa/*xx\",\n\t\t\"/ab/*xx\",\n\t\t\"/:cc\",\n\t\t\"/c1/:dd/e\",\n\t\t\"/c1/:dd/e1\",\n\t\t\"/:cc/cc\",\n\t\t\"/:cc/:dd/ee\",\n\t\t\"/:cc/:dd/:ee/ff\",\n\t\t\"/:cc/:dd/:ee/:ff/gg\",\n\t\t\"/:cc/:dd/:ee/:ff/:gg/hh\",\n\t\t\"/get/test/abc/\",\n\t\t\"/get/:param/abc/\",\n\t\t\"/something/:paramname/thirdthing\",\n\t\t\"/something/secondthing/test\",\n\t\t\"/get/abc\",\n\t\t\"/get/:param\",\n\t\t\"/get/abc/123abc\",\n\t\t\"/get/abc/:param\",\n\t\t\"/get/abc/123abc/xxx8\",\n\t\t\"/get/abc/123abc/:param\",\n\t\t\"/get/abc/123abc/xxx8/1234\",\n\t\t\"/get/abc/123abc/xxx8/:param\",\n\t\t\"/get/abc/123abc/xxx8/1234/ffas\",\n\t\t\"/get/abc/123abc/xxx8/1234/:param\",\n\t\t\"/get/abc/123abc/xxx8/1234/kkdd/12c\",\n\t\t\"/get/abc/123abc/xxx8/1234/kkdd/:param\",\n\t\t\"/get/abc/:param/test\",\n\t\t\"/get/abc/123abd/:param\",\n\t\t\"/get/abc/123abddd/:param\",\n\t\t\"/get/abc/123/:param\",\n\t\t\"/get/abc/123abg/:param\",\n\t\t\"/get/abc/123abf/:param\",\n\t\t\"/get/abc/123abfff/:param\",\n\t\t\"/get/abc/escaped_colon/test\\\\:param\",\n\t}\n\tfor _, route := range routes {\n\t\ttree.addRoute(route, fakeHandler(route))\n\t}\n\n\tcheckRequests(t, tree, testRequests{\n\t\t{\"/\", false, \"/\", nil},\n\t\t{\"/cmd/test\", true, \"/cmd/:tool/\", Params{Param{\"tool\", \"test\"}}},\n\t\t{\"/cmd/test/\", false, \"/cmd/:tool/\", Params{Param{\"tool\", \"test\"}}},\n\t\t{\"/cmd/test/3\", false, \"/cmd/:tool/:sub\", Params{Param{Key: \"tool\", Value: \"test\"}, Param{Key: \"sub\", Value: \"3\"}}},\n\t\t{\"/cmd/who\", true, \"/cmd/:tool/\", Params{Param{\"tool\", \"who\"}}},\n\t\t{\"/cmd/who/\", false, \"/cmd/:tool/\", Params{Param{\"tool\", \"who\"}}},\n\t\t{\"/cmd/whoami\", false, \"/cmd/whoami\", nil},\n\t\t{\"/cmd/whoami/\", true, \"/cmd/whoami\", nil},\n\t\t{\"/cmd/whoami/r\", false, \"/cmd/:tool/:sub\", Params{Param{Key: \"tool\", Value: \"whoami\"}, Param{Key: \"sub\", Value: \"r\"}}},\n\t\t{\"/cmd/whoami/r/\", true, \"/cmd/:tool/:sub\", Params{Param{Key: \"tool\", Value: \"whoami\"}, Param{Key: \"sub\", Value: \"r\"}}},\n\t\t{\"/cmd/whoami/root\", false, \"/cmd/whoami/root\", nil},\n\t\t{\"/cmd/whoami/root/\", false, \"/cmd/whoami/root/\", nil},\n\t\t{\"/src/\", false, \"/src/*filepath\", Params{Param{Key: \"filepath\", Value: \"/\"}}},\n\t\t{\"/src/some/file.png\", false, \"/src/*filepath\", Params{Param{Key: \"filepath\", Value: \"/some/file.png\"}}},\n\t\t{\"/search/\", false, \"/search/\", nil},\n\t\t{\"/search/someth!ng+in+√ºn√¨cod√©\", false, \"/search/:query\", Params{Param{Key: \"query\", Value: \"someth!ng+in+√ºn√¨cod√©\"}}},\n\t\t{\"/search/someth!ng+in+√ºn√¨cod√©/\", true, \"\", Params{Param{Key: \"query\", Value: \"someth!ng+in+√ºn√¨cod√©\"}}},\n\t\t{\"/search/gin\", false, \"/search/:query\", Params{Param{\"query\", \"gin\"}}},\n\t\t{\"/search/gin-gonic\", false, \"/search/gin-gonic\", nil},\n\t\t{\"/search/google\", false, \"/search/google\", nil},\n\t\t{\"/user_gopher\", false, \"/user_:name\", Params{Param{Key: \"name\", Value: \"gopher\"}}},\n\t\t{\"/user_gopher/about\", false, \"/user_:name/about\", Params{Param{Key: \"name\", Value: \"gopher\"}}},\n\t\t{\"/files/js/inc/framework.js\", false, \"/files/:dir/*filepath\", Params{Param{Key: \"dir\", Value: \"js\"}, Param{Key: \"filepath\", Value: \"/inc/framework.js\"}}},\n\t\t{\"/info/gordon/public\", false, \"/info/:user/public\", Params{Param{Key: \"user\", Value: \"gordon\"}}},\n\t\t{\"/info/gordon/project/go\", false, \"/info/:user/project/:project\", Params{Param{Key: \"user\", Value: \"gordon\"}, Param{Key: \"project\", Value: \"go\"}}},\n\t\t{\"/info/gordon/project/golang\", false, \"/info/:user/project/golang\", Params{Param{Key: \"user\", Value: \"gordon\"}}},\n\t\t{\"/aa/aa\", false, \"/aa/*xx\", Params{Param{Key: \"xx\", Value: \"/aa\"}}},\n\t\t{\"/ab/ab\", false, \"/ab/*xx\", Params{Param{Key: \"xx\", Value: \"/ab\"}}},\n\t\t{\"/a\", false, \"/:cc\", Params{Param{Key: \"cc\", Value: \"a\"}}},\n\t\t// * Error with argument being intercepted\n\t\t// new PR handle (/all /all/cc /a/cc)\n\t\t// fix PR: https://github.com/gin-gonic/gin/pull/2796\n\t\t{\"/all\", false, \"/:cc\", Params{Param{Key: \"cc\", Value: \"all\"}}},\n\t\t{\"/d\", false, \"/:cc\", Params{Param{Key: \"cc\", Value: \"d\"}}},\n\t\t{\"/ad\", false, \"/:cc\", Params{Param{Key: \"cc\", Value: \"ad\"}}},\n\t\t{\"/dd\", false, \"/:cc\", Params{Param{Key: \"cc\", Value: \"dd\"}}},\n\t\t{\"/dddaa\", false, \"/:cc\", Params{Param{Key: \"cc\", Value: \"dddaa\"}}},\n\t\t{\"/aa\", false, \"/:cc\", Params{Param{Key: \"cc\", Value: \"aa\"}}},\n\t\t{\"/aaa\", false, \"/:cc\", Params{Param{Key: \"cc\", Value: \"aaa\"}}},\n\t\t{\"/aaa/cc\", false, \"/:cc/cc\", Params{Param{Key: \"cc\", Value: \"aaa\"}}},\n\t\t{\"/ab\", false, \"/:cc\", Params{Param{Key: \"cc\", Value: \"ab\"}}},\n\t\t{\"/abb\", false, \"/:cc\", Params{Param{Key: \"cc\", Value: \"abb\"}}},\n\t\t{\"/abb/cc\", false, \"/:cc/cc\", Params{Param{Key: \"cc\", Value: \"abb\"}}},\n\t\t{\"/allxxxx\", false, \"/:cc\", Params{Param{Key: \"cc\", Value: \"allxxxx\"}}},\n\t\t{\"/alldd\", false, \"/:cc\", Params{Param{Key: \"cc\", Value: \"alldd\"}}},\n\t\t{\"/all/cc\", false, \"/:cc/cc\", Params{Param{Key: \"cc\", Value: \"all\"}}},\n\t\t{\"/a/cc\", false, \"/:cc/cc\", Params{Param{Key: \"cc\", Value: \"a\"}}},\n\t\t{\"/c1/d/e\", false, \"/c1/:dd/e\", Params{Param{Key: \"dd\", Value: \"d\"}}},\n\t\t{\"/c1/d/e1\", false, \"/c1/:dd/e1\", Params{Param{Key: \"dd\", Value: \"d\"}}},\n\t\t{\"/c1/d/ee\", false, \"/:cc/:dd/ee\", Params{Param{Key: \"cc\", Value: \"c1\"}, Param{Key: \"dd\", Value: \"d\"}}},\n\t\t{\"/cc/cc\", false, \"/:cc/cc\", Params{Param{Key: \"cc\", Value: \"cc\"}}},\n\t\t{\"/ccc/cc\", false, \"/:cc/cc\", Params{Param{Key: \"cc\", Value: \"ccc\"}}},\n\t\t{\"/deedwjfs/cc\", false, \"/:cc/cc\", Params{Param{Key: \"cc\", Value: \"deedwjfs\"}}},\n\t\t{\"/acllcc/cc\", false, \"/:cc/cc\", Params{Param{Key: \"cc\", Value: \"acllcc\"}}},\n\t\t{\"/get/test/abc/\", false, \"/get/test/abc/\", nil},\n\t\t{\"/get/te/abc/\", false, \"/get/:param/abc/\", Params{Param{Key: \"param\", Value: \"te\"}}},\n\t\t{\"/get/testaa/abc/\", false, \"/get/:param/abc/\", Params{Param{Key: \"param\", Value: \"testaa\"}}},\n\t\t{\"/get/xx/abc/\", false, \"/get/:param/abc/\", Params{Param{Key: \"param\", Value: \"xx\"}}},\n\t\t{\"/get/tt/abc/\", false, \"/get/:param/abc/\", Params{Param{Key: \"param\", Value: \"tt\"}}},\n\t\t{\"/get/a/abc/\", false, \"/get/:param/abc/\", Params{Param{Key: \"param\", Value: \"a\"}}},\n\t\t{\"/get/t/abc/\", false, \"/get/:param/abc/\", Params{Param{Key: \"param\", Value: \"t\"}}},\n\t\t{\"/get/aa/abc/\", false, \"/get/:param/abc/\", Params{Param{Key: \"param\", Value: \"aa\"}}},\n\t\t{\"/get/abas/abc/\", false, \"/get/:param/abc/\", Params{Param{Key: \"param\", Value: \"abas\"}}},\n\t\t{\"/something/secondthing/test\", false, \"/something/secondthing/test\", nil},\n\t\t{\"/something/abcdad/thirdthing\", false, \"/something/:paramname/thirdthing\", Params{Param{Key: \"paramname\", Value: \"abcdad\"}}},\n\t\t{\"/something/secondthingaaaa/thirdthing\", false, \"/something/:paramname/thirdthing\", Params{Param{Key: \"paramname\", Value: \"secondthingaaaa\"}}},\n\t\t{\"/something/se/thirdthing\", false, \"/something/:paramname/thirdthing\", Params{Param{Key: \"paramname\", Value: \"se\"}}},\n\t\t{\"/something/s/thirdthing\", false, \"/something/:paramname/thirdthing\", Params{Param{Key: \"paramname\", Value: \"s\"}}},\n\t\t{\"/c/d/ee\", false, \"/:cc/:dd/ee\", Params{Param{Key: \"cc\", Value: \"c\"}, Param{Key: \"dd\", Value: \"d\"}}},\n\t\t{\"/c/d/e/ff\", false, \"/:cc/:dd/:ee/ff\", Params{Param{Key: \"cc\", Value: \"c\"}, Param{Key: \"dd\", Value: \"d\"}, Param{Key: \"ee\", Value: \"e\"}}},\n\t\t{\"/c/d/e/f/gg\", false, \"/:cc/:dd/:ee/:ff/gg\", Params{Param{Key: \"cc\", Value: \"c\"}, Param{Key: \"dd\", Value: \"d\"}, Param{Key: \"ee\", Value: \"e\"}, Param{Key: \"ff\", Value: \"f\"}}},\n\t\t{\"/c/d/e/f/g/hh\", false, \"/:cc/:dd/:ee/:ff/:gg/hh\", Params{Param{Key: \"cc\", Value: \"c\"}, Param{Key: \"dd\", Value: \"d\"}, Param{Key: \"ee\", Value: \"e\"}, Param{Key: \"ff\", Value: \"f\"}, Param{Key: \"gg\", Value: \"g\"}}},\n\t\t{\"/cc/dd/ee/ff/gg/hh\", false, \"/:cc/:dd/:ee/:ff/:gg/hh\", Params{Param{Key: \"cc\", Value: \"cc\"}, Param{Key: \"dd\", Value: \"dd\"}, Param{Key: \"ee\", Value: \"ee\"}, Param{Key: \"ff\", Value: \"ff\"}, Param{Key: \"gg\", Value: \"gg\"}}},\n\t\t{\"/get/abc\", false, \"/get/abc\", nil},\n\t\t{\"/get/a\", false, \"/get/:param\", Params{Param{Key: \"param\", Value: \"a\"}}},\n\t\t{\"/get/abz\", false, \"/get/:param\", Params{Param{Key: \"param\", Value: \"abz\"}}},\n\t\t{\"/get/12a\", false, \"/get/:param\", Params{Param{Key: \"param\", Value: \"12a\"}}},\n\t\t{\"/get/abcd\", false, \"/get/:param\", Params{Param{Key: \"param\", Value: \"abcd\"}}},\n\t\t{\"/get/abc/123abc\", false, \"/get/abc/123abc\", nil},\n\t\t{\"/get/abc/12\", false, \"/get/abc/:param\", Params{Param{Key: \"param\", Value: \"12\"}}},\n\t\t{\"/get/abc/123ab\", false, \"/get/abc/:param\", Params{Param{Key: \"param\", Value: \"123ab\"}}},\n\t\t{\"/get/abc/xyz\", false, \"/get/abc/:param\", Params{Param{Key: \"param\", Value: \"xyz\"}}},\n\t\t{\"/get/abc/123abcddxx\", false, \"/get/abc/:param\", Params{Param{Key: \"param\", Value: \"123abcddxx\"}}},\n\t\t{\"/get/abc/123abc/xxx8\", false, \"/get/abc/123abc/xxx8\", nil},\n\t\t{\"/get/abc/123abc/x\", false, \"/get/abc/123abc/:param\", Params{Param{Key: \"param\", Value: \"x\"}}},\n\t\t{\"/get/abc/123abc/xxx\", false, \"/get/abc/123abc/:param\", Params{Param{Key: \"param\", Value: \"xxx\"}}},\n\t\t{\"/get/abc/123abc/abc\", false, \"/get/abc/123abc/:param\", Params{Param{Key: \"param\", Value: \"abc\"}}},\n\t\t{\"/get/abc/123abc/xxx8xxas\", false, \"/get/abc/123abc/:param\", Params{Param{Key: \"param\", Value: \"xxx8xxas\"}}},\n\t\t{\"/get/abc/123abc/xxx8/1234\", false, \"/get/abc/123abc/xxx8/1234\", nil},\n\t\t{\"/get/abc/123abc/xxx8/1\", false, \"/get/abc/123abc/xxx8/:param\", Params{Param{Key: \"param\", Value: \"1\"}}},\n\t\t{\"/get/abc/123abc/xxx8/123\", false, \"/get/abc/123abc/xxx8/:param\", Params{Param{Key: \"param\", Value: \"123\"}}},\n\t\t{\"/get/abc/123abc/xxx8/78k\", false, \"/get/abc/123abc/xxx8/:param\", Params{Param{Key: \"param\", Value: \"78k\"}}},\n\t\t{\"/get/abc/123abc/xxx8/1234xxxd\", false, \"/get/abc/123abc/xxx8/:param\", Params{Param{Key: \"param\", Value: \"1234xxxd\"}}},\n\t\t{\"/get/abc/123abc/xxx8/1234/ffas\", false, \"/get/abc/123abc/xxx8/1234/ffas\", nil},\n\t\t{\"/get/abc/123abc/xxx8/1234/f\", false, \"/get/abc/123abc/xxx8/1234/:param\", Params{Param{Key: \"param\", Value: \"f\"}}},\n\t\t{\"/get/abc/123abc/xxx8/1234/ffa\", false, \"/get/abc/123abc/xxx8/1234/:param\", Params{Param{Key: \"param\", Value: \"ffa\"}}},\n\t\t{\"/get/abc/123abc/xxx8/1234/kka\", false, \"/get/abc/123abc/xxx8/1234/:param\", Params{Param{Key: \"param\", Value: \"kka\"}}},\n\t\t{\"/get/abc/123abc/xxx8/1234/ffas321\", false, \"/get/abc/123abc/xxx8/1234/:param\", Params{Param{Key: \"param\", Value: \"ffas321\"}}},\n\t\t{\"/get/abc/123abc/xxx8/1234/kkdd/12c\", false, \"/get/abc/123abc/xxx8/1234/kkdd/12c\", nil},\n\t\t{\"/get/abc/123abc/xxx8/1234/kkdd/1\", false, \"/get/abc/123abc/xxx8/1234/kkdd/:param\", Params{Param{Key: \"param\", Value: \"1\"}}},\n\t\t{\"/get/abc/123abc/xxx8/1234/kkdd/12\", false, \"/get/abc/123abc/xxx8/1234/kkdd/:param\", Params{Param{Key: \"param\", Value: \"12\"}}},\n\t\t{\"/get/abc/123abc/xxx8/1234/kkdd/12b\", false, \"/get/abc/123abc/xxx8/1234/kkdd/:param\", Params{Param{Key: \"param\", Value: \"12b\"}}},\n\t\t{\"/get/abc/123abc/xxx8/1234/kkdd/34\", false, \"/get/abc/123abc/xxx8/1234/kkdd/:param\", Params{Param{Key: \"param\", Value: \"34\"}}},\n\t\t{\"/get/abc/123abc/xxx8/1234/kkdd/12c2e3\", false, \"/get/abc/123abc/xxx8/1234/kkdd/:param\", Params{Param{Key: \"param\", Value: \"12c2e3\"}}},\n\t\t{\"/get/abc/12/test\", false, \"/get/abc/:param/test\", Params{Param{Key: \"param\", Value: \"12\"}}},\n\t\t{\"/get/abc/123abdd/test\", false, \"/get/abc/:param/test\", Params{Param{Key: \"param\", Value: \"123abdd\"}}},\n\t\t{\"/get/abc/123abdddf/test\", false, \"/get/abc/:param/test\", Params{Param{Key: \"param\", Value: \"123abdddf\"}}},\n\t\t{\"/get/abc/123ab/test\", false, \"/get/abc/:param/test\", Params{Param{Key: \"param\", Value: \"123ab\"}}},\n\t\t{\"/get/abc/123abgg/test\", false, \"/get/abc/:param/test\", Params{Param{Key: \"param\", Value: \"123abgg\"}}},\n\t\t{\"/get/abc/123abff/test\", false, \"/get/abc/:param/test\", Params{Param{Key: \"param\", Value: \"123abff\"}}},\n\t\t{\"/get/abc/123abffff/test\", false, \"/get/abc/:param/test\", Params{Param{Key: \"param\", Value: \"123abffff\"}}},\n\t\t{\"/get/abc/123abd/test\", false, \"/get/abc/123abd/:param\", Params{Param{Key: \"param\", Value: \"test\"}}},\n\t\t{\"/get/abc/123abddd/test\", false, \"/get/abc/123abddd/:param\", Params{Param{Key: \"param\", Value: \"test\"}}},\n\t\t{\"/get/abc/123/test22\", false, \"/get/abc/123/:param\", Params{Param{Key: \"param\", Value: \"test22\"}}},\n\t\t{\"/get/abc/123abg/test\", false, \"/get/abc/123abg/:param\", Params{Param{Key: \"param\", Value: \"test\"}}},\n\t\t{\"/get/abc/123abf/testss\", false, \"/get/abc/123abf/:param\", Params{Param{Key: \"param\", Value: \"testss\"}}},\n\t\t{\"/get/abc/123abfff/te\", false, \"/get/abc/123abfff/:param\", Params{Param{Key: \"param\", Value: \"te\"}}},\n\t\t{\"/get/abc/escaped_colon/test\\\\:param\", false, \"/get/abc/escaped_colon/test\\\\:param\", nil},\n\t})\n\n\tcheckPriorities(t, tree)\n}\n\nfunc TestUnescapeParameters(t *testing.T) {\n\ttree := &node{}\n\n\troutes := [...]string{\n\t\t\"/\",\n\t\t\"/cmd/:tool/:sub\",\n\t\t\"/cmd/:tool/\",\n\t\t\"/src/*filepath\",\n\t\t\"/search/:query\",\n\t\t\"/files/:dir/*filepath\",\n\t\t\"/info/:user/project/:project\",\n\t\t\"/info/:user\",\n\t}\n\tfor _, route := range routes {\n\t\ttree.addRoute(route, fakeHandler(route))\n\t}\n\n\tunescape := true\n\tcheckRequests(t, tree, testRequests{\n\t\t{\"/\", false, \"/\", nil},\n\t\t{\"/cmd/test/\", false, \"/cmd/:tool/\", Params{Param{Key: \"tool\", Value: \"test\"}}},\n\t\t{\"/cmd/test\", true, \"\", Params{Param{Key: \"tool\", Value: \"test\"}}},\n\t\t{\"/src/some/file.png\", false, \"/src/*filepath\", Params{Param{Key: \"filepath\", Value: \"/some/file.png\"}}},\n\t\t{\"/src/some/file+test.png\", false, \"/src/*filepath\", Params{Param{Key: \"filepath\", Value: \"/some/file test.png\"}}},\n\t\t{\"/src/some/file++++%%%%test.png\", false, \"/src/*filepath\", Params{Param{Key: \"filepath\", Value: \"/some/file++++%%%%test.png\"}}},\n\t\t{\"/src/some/file%2Ftest.png\", false, \"/src/*filepath\", Params{Param{Key: \"filepath\", Value: \"/some/file/test.png\"}}},\n\t\t{\"/search/someth!ng+in+√ºn√¨cod√©\", false, \"/search/:query\", Params{Param{Key: \"query\", Value: \"someth!ng in √ºn√¨cod√©\"}}},\n\t\t{\"/info/gordon/project/go\", false, \"/info/:user/project/:project\", Params{Param{Key: \"user\", Value: \"gordon\"}, Param{Key: \"project\", Value: \"go\"}}},\n\t\t{\"/info/slash%2Fgordon\", false, \"/info/:user\", Params{Param{Key: \"user\", Value: \"slash/gordon\"}}},\n\t\t{\"/info/slash%2Fgordon/project/Project%20%231\", false, \"/info/:user/project/:project\", Params{Param{Key: \"user\", Value: \"slash/gordon\"}, Param{Key: \"project\", Value: \"Project #1\"}}},\n\t\t{\"/info/slash%%%%\", false, \"/info/:user\", Params{Param{Key: \"user\", Value: \"slash%%%%\"}}},\n\t\t{\"/info/slash%%%%2Fgordon/project/Project%%%%20%231\", false, \"/info/:user/project/:project\", Params{Param{Key: \"user\", Value: \"slash%%%%2Fgordon\"}, Param{Key: \"project\", Value: \"Project%%%%20%231\"}}},\n\t}, unescape)\n\n\tcheckPriorities(t, tree)\n}\n\nfunc catchPanic(testFunc func()) (recv any) {\n\tdefer func() {\n\t\trecv = recover()\n\t}()\n\n\ttestFunc()\n\treturn\n}\n\ntype testRoute struct {\n\tpath     string\n\tconflict bool\n}\n\nfunc testRoutes(t *testing.T, routes []testRoute) {\n\ttree := &node{}\n\n\tfor _, route := range routes {\n\t\trecv := catchPanic(func() {\n\t\t\ttree.addRoute(route.path, nil)\n\t\t})\n\n\t\tif route.conflict {\n\t\t\tif recv == nil {\n\t\t\t\tt.Errorf(\"no panic for conflicting route '%s'\", route.path)\n\t\t\t}\n\t\t} else if recv != nil {\n\t\t\tt.Errorf(\"unexpected panic for route '%s': %v\", route.path, recv)\n\t\t}\n\t}\n}\n\nfunc TestTreeWildcardConflict(t *testing.T) {\n\troutes := []testRoute{\n\t\t{\"/cmd/:tool/:sub\", false},\n\t\t{\"/cmd/vet\", false},\n\t\t{\"/foo/bar\", false},\n\t\t{\"/foo/:name\", false},\n\t\t{\"/foo/:names\", true},\n\t\t{\"/cmd/*path\", true},\n\t\t{\"/cmd/:badvar\", true},\n\t\t{\"/cmd/:tool/names\", false},\n\t\t{\"/cmd/:tool/:badsub/details\", true},\n\t\t{\"/src/*filepath\", false},\n\t\t{\"/src/:file\", true},\n\t\t{\"/src/static.json\", true},\n\t\t{\"/src/*filepathx\", true},\n\t\t{\"/src/\", true},\n\t\t{\"/src/foo/bar\", true},\n\t\t{\"/src1/\", false},\n\t\t{\"/src1/*filepath\", true},\n\t\t{\"/src2*filepath\", true},\n\t\t{\"/src2/*filepath\", false},\n\t\t{\"/search/:query\", false},\n\t\t{\"/search/valid\", false},\n\t\t{\"/user_:name\", false},\n\t\t{\"/user_x\", false},\n\t\t{\"/user_:name\", false},\n\t\t{\"/id:id\", false},\n\t\t{\"/id/:id\", false},\n\t\t{\"/static/*file\", false},\n\t\t{\"/static/\", true},\n\t\t{\"/escape/test\\\\:d1\", false},\n\t\t{\"/escape/test\\\\:d2\", false},\n\t\t{\"/escape/test:param\", false},\n\t}\n\ttestRoutes(t, routes)\n}\n\nfunc TestCatchAllAfterSlash(t *testing.T) {\n\troutes := []testRoute{\n\t\t{\"/non-leading-*catchall\", true},\n\t}\n\ttestRoutes(t, routes)\n}\n\nfunc TestTreeChildConflict(t *testing.T) {\n\troutes := []testRoute{\n\t\t{\"/cmd/vet\", false},\n\t\t{\"/cmd/:tool\", false},\n\t\t{\"/cmd/:tool/:sub\", false},\n\t\t{\"/cmd/:tool/misc\", false},\n\t\t{\"/cmd/:tool/:othersub\", true},\n\t\t{\"/src/AUTHORS\", false},\n\t\t{\"/src/*filepath\", true},\n\t\t{\"/user_x\", false},\n\t\t{\"/user_:name\", false},\n\t\t{\"/id/:id\", false},\n\t\t{\"/id:id\", false},\n\t\t{\"/:id\", false},\n\t\t{\"/*filepath\", true},\n\t}\n\ttestRoutes(t, routes)\n}\n\nfunc TestTreeDuplicatePath(t *testing.T) {\n\ttree := &node{}\n\n\troutes := [...]string{\n\t\t\"/\",\n\t\t\"/doc/\",\n\t\t\"/src/*filepath\",\n\t\t\"/search/:query\",\n\t\t\"/user_:name\",\n\t}\n\tfor _, route := range routes {\n\t\trecv := catchPanic(func() {\n\t\t\ttree.addRoute(route, fakeHandler(route))\n\t\t})\n\t\tif recv != nil {\n\t\t\tt.Fatalf(\"panic inserting route '%s': %v\", route, recv)\n\t\t}\n\n\t\t// Add again\n\t\trecv = catchPanic(func() {\n\t\t\ttree.addRoute(route, nil)\n\t\t})\n\t\tif recv == nil {\n\t\t\tt.Fatalf(\"no panic while inserting duplicate route '%s\", route)\n\t\t}\n\t}\n\n\t//printChildren(tree, \"\")\n\n\tcheckRequests(t, tree, testRequests{\n\t\t{\"/\", false, \"/\", nil},\n\t\t{\"/doc/\", false, \"/doc/\", nil},\n\t\t{\"/src/some/file.png\", false, \"/src/*filepath\", Params{Param{\"filepath\", \"/some/file.png\"}}},\n\t\t{\"/search/someth!ng+in+√ºn√¨cod√©\", false, \"/search/:query\", Params{Param{\"query\", \"someth!ng+in+√ºn√¨cod√©\"}}},\n\t\t{\"/user_gopher\", false, \"/user_:name\", Params{Param{\"name\", \"gopher\"}}},\n\t})\n}\n\nfunc TestEmptyWildcardName(t *testing.T) {\n\ttree := &node{}\n\n\troutes := [...]string{\n\t\t\"/user:\",\n\t\t\"/user:/\",\n\t\t\"/cmd/:/\",\n\t\t\"/src/*\",\n\t}\n\tfor _, route := range routes {\n\t\trecv := catchPanic(func() {\n\t\t\ttree.addRoute(route, nil)\n\t\t})\n\t\tif recv == nil {\n\t\t\tt.Fatalf(\"no panic while inserting route with empty wildcard name '%s\", route)\n\t\t}\n\t}\n}\n\nfunc TestTreeCatchAllConflict(t *testing.T) {\n\troutes := []testRoute{\n\t\t{\"/src/*filepath/x\", true},\n\t\t{\"/src2/\", false},\n\t\t{\"/src2/*filepath/x\", true},\n\t\t{\"/src3/*filepath\", false},\n\t\t{\"/src3/*filepath/x\", true},\n\t}\n\ttestRoutes(t, routes)\n}\n\nfunc TestTreeCatchAllConflictRoot(t *testing.T) {\n\troutes := []testRoute{\n\t\t{\"/\", false},\n\t\t{\"/*filepath\", true},\n\t}\n\ttestRoutes(t, routes)\n}\n\nfunc TestTreeCatchMaxParams(t *testing.T) {\n\ttree := &node{}\n\tvar route = \"/cmd/*filepath\"\n\ttree.addRoute(route, fakeHandler(route))\n}\n\nfunc TestTreeDoubleWildcard(t *testing.T) {\n\tconst panicMsg = \"only one wildcard per path segment is allowed\"\n\n\troutes := [...]string{\n\t\t\"/:foo:bar\",\n\t\t\"/:foo:bar/\",\n\t\t\"/:foo*bar\",\n\t}\n\n\tfor _, route := range routes {\n\t\ttree := &node{}\n\t\trecv := catchPanic(func() {\n\t\t\ttree.addRoute(route, nil)\n\t\t})\n\n\t\tif rs, ok := recv.(string); !ok || !strings.HasPrefix(rs, panicMsg) {\n\t\t\tt.Fatalf(`\"Expected panic \"%s\" for route '%s', got \"%v\"`, panicMsg, route, recv)\n\t\t}\n\t}\n}\n\n/*func TestTreeDuplicateWildcard(t *testing.T) {\n\ttree := &node{}\n\troutes := [...]string{\n\t\t\"/:id/:name/:id\",\n\t}\n\tfor _, route := range routes {\n\t\t...\n\t}\n}*/\n\nfunc TestTreeTrailingSlashRedirect(t *testing.T) {\n\ttree := &node{}\n\n\troutes := [...]string{\n\t\t\"/hi\",\n\t\t\"/b/\",\n\t\t\"/search/:query\",\n\t\t\"/cmd/:tool/\",\n\t\t\"/src/*filepath\",\n\t\t\"/x\",\n\t\t\"/x/y\",\n\t\t\"/y/\",\n\t\t\"/y/z\",\n\t\t\"/0/:id\",\n\t\t\"/0/:id/1\",\n\t\t\"/1/:id/\",\n\t\t\"/1/:id/2\",\n\t\t\"/aa\",\n\t\t\"/a/\",\n\t\t\"/admin\",\n\t\t\"/admin/:category\",\n\t\t\"/admin/:category/:page\",\n\t\t\"/doc\",\n\t\t\"/doc/go_faq.html\",\n\t\t\"/doc/go1.html\",\n\t\t\"/no/a\",\n\t\t\"/no/b\",\n\t\t\"/api/:page/:name\",\n\t\t\"/api/hello/:name/bar/\",\n\t\t\"/api/bar/:name\",\n\t\t\"/api/baz/foo\",\n\t\t\"/api/baz/foo/bar\",\n\t\t\"/blog/:p\",\n\t\t\"/posts/:b/:c\",\n\t\t\"/posts/b/:c/d/\",\n\t\t\"/vendor/:x/*y\",\n\t}\n\tfor _, route := range routes {\n\t\trecv := catchPanic(func() {\n\t\t\ttree.addRoute(route, fakeHandler(route))\n\t\t})\n\t\tif recv != nil {\n\t\t\tt.Fatalf(\"panic inserting route '%s': %v\", route, recv)\n\t\t}\n\t}\n\n\ttsrRoutes := [...]string{\n\t\t\"/hi/\",\n\t\t\"/b\",\n\t\t\"/search/gopher/\",\n\t\t\"/cmd/vet\",\n\t\t\"/src\",\n\t\t\"/x/\",\n\t\t\"/y\",\n\t\t\"/0/go/\",\n\t\t\"/1/go\",\n\t\t\"/a\",\n\t\t\"/admin/\",\n\t\t\"/admin/config/\",\n\t\t\"/admin/config/permissions/\",\n\t\t\"/doc/\",\n\t\t\"/admin/static/\",\n\t\t\"/admin/cfg/\",\n\t\t\"/admin/cfg/users/\",\n\t\t\"/api/hello/x/bar\",\n\t\t\"/api/baz/foo/\",\n\t\t\"/api/baz/bax/\",\n\t\t\"/api/bar/huh/\",\n\t\t\"/api/baz/foo/bar/\",\n\t\t\"/api/world/abc/\",\n\t\t\"/blog/pp/\",\n\t\t\"/posts/b/c/d\",\n\t\t\"/vendor/x\",\n\t}\n\n\tfor _, route := range tsrRoutes {\n\t\tvalue := tree.getValue(route, nil, getSkippedNodes(), false)\n\t\tif value.handlers != nil {\n\t\t\tt.Fatalf(\"non-nil handler for TSR route '%s\", route)\n\t\t} else if !value.tsr {\n\t\t\tt.Errorf(\"expected TSR recommendation for route '%s'\", route)\n\t\t}\n\t}\n\n\tnoTsrRoutes := [...]string{\n\t\t\"/\",\n\t\t\"/no\",\n\t\t\"/no/\",\n\t\t\"/_\",\n\t\t\"/_/\",\n\t\t\"/api\",\n\t\t\"/api/\",\n\t\t\"/api/hello/x/foo\",\n\t\t\"/api/baz/foo/bad\",\n\t\t\"/foo/p/p\",\n\t}\n\tfor _, route := range noTsrRoutes {\n\t\tvalue := tree.getValue(route, nil, getSkippedNodes(), false)\n\t\tif value.handlers != nil {\n\t\t\tt.Fatalf(\"non-nil handler for No-TSR route '%s\", route)\n\t\t} else if value.tsr {\n\t\t\tt.Errorf(\"expected no TSR recommendation for route '%s'\", route)\n\t\t}\n\t}\n}\n\nfunc TestTreeRootTrailingSlashRedirect(t *testing.T) {\n\ttree := &node{}\n\n\trecv := catchPanic(func() {\n\t\ttree.addRoute(\"/:test\", fakeHandler(\"/:test\"))\n\t})\n\tif recv != nil {\n\t\tt.Fatalf(\"panic inserting test route: %v\", recv)\n\t}\n\n\tvalue := tree.getValue(\"/\", nil, getSkippedNodes(), false)\n\tif value.handlers != nil {\n\t\tt.Fatalf(\"non-nil handler\")\n\t} else if value.tsr {\n\t\tt.Errorf(\"expected no TSR recommendation\")\n\t}\n}\n\nfunc TestRedirectTrailingSlash(t *testing.T) {\n\tvar data = []struct {\n\t\tpath string\n\t}{\n\t\t{\"/hello/:name\"},\n\t\t{\"/hello/:name/123\"},\n\t\t{\"/hello/:name/234\"},\n\t}\n\n\tnode := &node{}\n\tfor _, item := range data {\n\t\tnode.addRoute(item.path, fakeHandler(\"test\"))\n\t}\n\n\tvalue := node.getValue(\"/hello/abx/\", nil, getSkippedNodes(), false)\n\tif value.tsr != true {\n\t\tt.Fatalf(\"want true, is false\")\n\t}\n}\n\nfunc TestTreeFindCaseInsensitivePath(t *testing.T) {\n\ttree := &node{}\n\n\tlongPath := \"/l\" + strings.Repeat(\"o\", 128) + \"ng\"\n\tlOngPath := \"/l\" + strings.Repeat(\"O\", 128) + \"ng/\"\n\n\troutes := [...]string{\n\t\t\"/hi\",\n\t\t\"/b/\",\n\t\t\"/ABC/\",\n\t\t\"/search/:query\",\n\t\t\"/cmd/:tool/\",\n\t\t\"/src/*filepath\",\n\t\t\"/x\",\n\t\t\"/x/y\",\n\t\t\"/y/\",\n\t\t\"/y/z\",\n\t\t\"/0/:id\",\n\t\t\"/0/:id/1\",\n\t\t\"/1/:id/\",\n\t\t\"/1/:id/2\",\n\t\t\"/aa\",\n\t\t\"/a/\",\n\t\t\"/doc\",\n\t\t\"/doc/go_faq.html\",\n\t\t\"/doc/go1.html\",\n\t\t\"/doc/go/away\",\n\t\t\"/no/a\",\n\t\t\"/no/b\",\n\t\t\"/Œ†\",\n\t\t\"/u/apf√™l/\",\n\t\t\"/u/√§pf√™l/\",\n\t\t\"/u/√∂pf√™l\",\n\t\t\"/v/√Ñpf√™l/\",\n\t\t\"/v/√ñpf√™l\",\n\t\t\"/w/‚ô¨\",  // 3 byte\n\t\t\"/w/‚ô≠/\", // 3 byte, last byte differs\n\t\t\"/w/†úé\",  // 4 byte\n\t\t\"/w/†úè/\", // 4 byte\n\t\tlongPath,\n\t}\n\n\tfor _, route := range routes {\n\t\trecv := catchPanic(func() {\n\t\t\ttree.addRoute(route, fakeHandler(route))\n\t\t})\n\t\tif recv != nil {\n\t\t\tt.Fatalf(\"panic inserting route '%s': %v\", route, recv)\n\t\t}\n\t}\n\n\t// Check out == in for all registered routes\n\t// With fixTrailingSlash = true\n\tfor _, route := range routes {\n\t\tout, found := tree.findCaseInsensitivePath(route, true)\n\t\tif !found {\n\t\t\tt.Errorf(\"Route '%s' not found!\", route)\n\t\t} else if string(out) != route {\n\t\t\tt.Errorf(\"Wrong result for route '%s': %s\", route, string(out))\n\t\t}\n\t}\n\t// With fixTrailingSlash = false\n\tfor _, route := range routes {\n\t\tout, found := tree.findCaseInsensitivePath(route, false)\n\t\tif !found {\n\t\t\tt.Errorf(\"Route '%s' not found!\", route)\n\t\t} else if string(out) != route {\n\t\t\tt.Errorf(\"Wrong result for route '%s': %s\", route, string(out))\n\t\t}\n\t}\n\n\ttests := []struct {\n\t\tin    string\n\t\tout   string\n\t\tfound bool\n\t\tslash bool\n\t}{\n\t\t{\"/HI\", \"/hi\", true, false},\n\t\t{\"/HI/\", \"/hi\", true, true},\n\t\t{\"/B\", \"/b/\", true, true},\n\t\t{\"/B/\", \"/b/\", true, false},\n\t\t{\"/abc\", \"/ABC/\", true, true},\n\t\t{\"/abc/\", \"/ABC/\", true, false},\n\t\t{\"/aBc\", \"/ABC/\", true, true},\n\t\t{\"/aBc/\", \"/ABC/\", true, false},\n\t\t{\"/abC\", \"/ABC/\", true, true},\n\t\t{\"/abC/\", \"/ABC/\", true, false},\n\t\t{\"/SEARCH/QUERY\", \"/search/QUERY\", true, false},\n\t\t{\"/SEARCH/QUERY/\", \"/search/QUERY\", true, true},\n\t\t{\"/CMD/TOOL/\", \"/cmd/TOOL/\", true, false},\n\t\t{\"/CMD/TOOL\", \"/cmd/TOOL/\", true, true},\n\t\t{\"/SRC/FILE/PATH\", \"/src/FILE/PATH\", true, false},\n\t\t{\"/x/Y\", \"/x/y\", true, false},\n\t\t{\"/x/Y/\", \"/x/y\", true, true},\n\t\t{\"/X/y\", \"/x/y\", true, false},\n\t\t{\"/X/y/\", \"/x/y\", true, true},\n\t\t{\"/X/Y\", \"/x/y\", true, false},\n\t\t{\"/X/Y/\", \"/x/y\", true, true},\n\t\t{\"/Y/\", \"/y/\", true, false},\n\t\t{\"/Y\", \"/y/\", true, true},\n\t\t{\"/Y/z\", \"/y/z\", true, false},\n\t\t{\"/Y/z/\", \"/y/z\", true, true},\n\t\t{\"/Y/Z\", \"/y/z\", true, false},\n\t\t{\"/Y/Z/\", \"/y/z\", true, true},\n\t\t{\"/y/Z\", \"/y/z\", true, false},\n\t\t{\"/y/Z/\", \"/y/z\", true, true},\n\t\t{\"/Aa\", \"/aa\", true, false},\n\t\t{\"/Aa/\", \"/aa\", true, true},\n\t\t{\"/AA\", \"/aa\", true, false},\n\t\t{\"/AA/\", \"/aa\", true, true},\n\t\t{\"/aA\", \"/aa\", true, false},\n\t\t{\"/aA/\", \"/aa\", true, true},\n\t\t{\"/A/\", \"/a/\", true, false},\n\t\t{\"/A\", \"/a/\", true, true},\n\t\t{\"/DOC\", \"/doc\", true, false},\n\t\t{\"/DOC/\", \"/doc\", true, true},\n\t\t{\"/NO\", \"\", false, true},\n\t\t{\"/DOC/GO\", \"\", false, true},\n\t\t{\"/œÄ\", \"/Œ†\", true, false},\n\t\t{\"/œÄ/\", \"/Œ†\", true, true},\n\t\t{\"/u/√ÑPF√äL/\", \"/u/√§pf√™l/\", true, false},\n\t\t{\"/u/√ÑPF√äL\", \"/u/√§pf√™l/\", true, true},\n\t\t{\"/u/√ñPF√äL/\", \"/u/√∂pf√™l\", true, true},\n\t\t{\"/u/√ñPF√äL\", \"/u/√∂pf√™l\", true, false},\n\t\t{\"/v/√§pf√™L/\", \"/v/√Ñpf√™l/\", true, false},\n\t\t{\"/v/√§pf√™L\", \"/v/√Ñpf√™l/\", true, true},\n\t\t{\"/v/√∂pf√™L/\", \"/v/√ñpf√™l\", true, true},\n\t\t{\"/v/√∂pf√™L\", \"/v/√ñpf√™l\", true, false},\n\t\t{\"/w/‚ô¨/\", \"/w/‚ô¨\", true, true},\n\t\t{\"/w/‚ô≠\", \"/w/‚ô≠/\", true, true},\n\t\t{\"/w/†úé/\", \"/w/†úé\", true, true},\n\t\t{\"/w/†úè\", \"/w/†úè/\", true, true},\n\t\t{lOngPath, longPath, true, true},\n\t}\n\t// With fixTrailingSlash = true\n\tfor _, test := range tests {\n\t\tout, found := tree.findCaseInsensitivePath(test.in, true)\n\t\tif found != test.found || (found && (string(out) != test.out)) {\n\t\t\tt.Errorf(\"Wrong result for '%s': got %s, %t; want %s, %t\",\n\t\t\t\ttest.in, string(out), found, test.out, test.found)\n\t\t\treturn\n\t\t}\n\t}\n\t// With fixTrailingSlash = false\n\tfor _, test := range tests {\n\t\tout, found := tree.findCaseInsensitivePath(test.in, false)\n\t\tif test.slash {\n\t\t\tif found { // test needs a trailingSlash fix. It must not be found!\n\t\t\t\tt.Errorf(\"Found without fixTrailingSlash: %s; got %s\", test.in, string(out))\n\t\t\t}\n\t\t} else {\n\t\t\tif found != test.found || (found && (string(out) != test.out)) {\n\t\t\t\tt.Errorf(\"Wrong result for '%s': got %s, %t; want %s, %t\",\n\t\t\t\t\ttest.in, string(out), found, test.out, test.found)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestTreeInvalidNodeType(t *testing.T) {\n\tconst panicMsg = \"invalid node type\"\n\n\ttree := &node{}\n\ttree.addRoute(\"/\", fakeHandler(\"/\"))\n\ttree.addRoute(\"/:page\", fakeHandler(\"/:page\"))\n\n\t// set invalid node type\n\ttree.children[0].nType = 42\n\n\t// normal lookup\n\trecv := catchPanic(func() {\n\t\ttree.getValue(\"/test\", nil, getSkippedNodes(), false)\n\t})\n\tif rs, ok := recv.(string); !ok || rs != panicMsg {\n\t\tt.Fatalf(\"Expected panic '\"+panicMsg+\"', got '%v'\", recv)\n\t}\n\n\t// case-insensitive lookup\n\trecv = catchPanic(func() {\n\t\ttree.findCaseInsensitivePath(\"/test\", true)\n\t})\n\tif rs, ok := recv.(string); !ok || rs != panicMsg {\n\t\tt.Fatalf(\"Expected panic '\"+panicMsg+\"', got '%v'\", recv)\n\t}\n}\n\nfunc TestTreeInvalidParamsType(t *testing.T) {\n\ttree := &node{}\n\t// add a child with wildcard\n\troute := \"/:path\"\n\ttree.addRoute(route, fakeHandler(route))\n\n\t// set invalid Params type\n\tparams := make(Params, 0)\n\n\t// try to trigger slice bounds out of range with capacity 0\n\ttree.getValue(\"/test\", &params, getSkippedNodes(), false)\n}\n\nfunc TestTreeExpandParamsCapacity(t *testing.T) {\n\tdata := []struct {\n\t\tpath string\n\t}{\n\t\t{\"/:path\"},\n\t\t{\"/*path\"},\n\t}\n\n\tfor _, item := range data {\n\t\ttree := &node{}\n\t\ttree.addRoute(item.path, fakeHandler(item.path))\n\t\tparams := make(Params, 0)\n\n\t\tvalue := tree.getValue(\"/test\", &params, getSkippedNodes(), false)\n\n\t\tif value.params == nil {\n\t\t\tt.Errorf(\"Expected %s params to be set, but they weren't\", item.path)\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(*value.params) != 1 {\n\t\t\tt.Errorf(\"Wrong number of %s params: got %d, want %d\",\n\t\t\t\titem.path, len(*value.params), 1)\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\nfunc TestTreeWildcardConflictEx(t *testing.T) {\n\tconflicts := [...]struct {\n\t\troute        string\n\t\tsegPath      string\n\t\texistPath    string\n\t\texistSegPath string\n\t}{\n\t\t{\"/who/are/foo\", \"/foo\", `/who/are/\\*you`, `/\\*you`},\n\t\t{\"/who/are/foo/\", \"/foo/\", `/who/are/\\*you`, `/\\*you`},\n\t\t{\"/who/are/foo/bar\", \"/foo/bar\", `/who/are/\\*you`, `/\\*you`},\n\t\t{\"/con:nection\", \":nection\", `/con:tact`, `:tact`},\n\t}\n\n\tfor _, conflict := range conflicts {\n\t\t// I have to re-create a 'tree', because the 'tree' will be\n\t\t// in an inconsistent state when the loop recovers from the\n\t\t// panic which threw by 'addRoute' function.\n\t\ttree := &node{}\n\t\troutes := [...]string{\n\t\t\t\"/con:tact\",\n\t\t\t\"/who/are/*you\",\n\t\t\t\"/who/foo/hello\",\n\t\t}\n\n\t\tfor _, route := range routes {\n\t\t\ttree.addRoute(route, fakeHandler(route))\n\t\t}\n\n\t\trecv := catchPanic(func() {\n\t\t\ttree.addRoute(conflict.route, fakeHandler(conflict.route))\n\t\t})\n\n\t\tif !regexp.MustCompile(fmt.Sprintf(\"'%s' in new path .* conflicts with existing wildcard '%s' in existing prefix '%s'\", conflict.segPath, conflict.existSegPath, conflict.existPath)).MatchString(fmt.Sprint(recv)) {\n\t\t\tt.Fatalf(\"invalid wildcard conflict error (%v)\", recv)\n\t\t}\n\t}\n}\n\nfunc TestTreeInvalidEscape(t *testing.T) {\n\troutes := map[string]bool{\n\t\t\"/r1/r\":    true,\n\t\t\"/r2/:r\":   true,\n\t\t\"/r3/\\\\:r\": true,\n\t}\n\ttree := &node{}\n\tfor route, valid := range routes {\n\t\trecv := catchPanic(func() {\n\t\t\ttree.addRoute(route, fakeHandler(route))\n\t\t})\n\t\tif recv == nil != valid {\n\t\t\tt.Fatalf(\"%s should be %t but got %v\", route, valid, recv)\n\t\t}\n\t}\n}\n\nfunc TestWildcardInvalidSlash(t *testing.T) {\n\tconst panicMsgPrefix = \"no / before catch-all in path\"\n\n\troutes := map[string]bool{\n\t\t\"/foo/bar\":  true,\n\t\t\"/foo/x*zy\": false,\n\t\t\"/foo/b*r\":  false,\n\t}\n\n\tfor route, valid := range routes {\n\t\ttree := &node{}\n\t\trecv := catchPanic(func() {\n\t\t\ttree.addRoute(route, nil)\n\t\t})\n\n\t\tif recv == nil != valid {\n\t\t\tt.Fatalf(\"%s should be %t but got %v\", route, valid, recv)\n\t\t}\n\n\t\tif rs, ok := recv.(string); recv != nil && (!ok || !strings.HasPrefix(rs, panicMsgPrefix)) {\n\t\t\tt.Fatalf(`\"Expected panic \"%s\" for route '%s', got \"%v\"`, panicMsgPrefix, route, recv)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 3.5107421875,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"encoding/xml\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"unicode\"\n)\n\n// BindKey indicates a default bind key.\nconst BindKey = \"_gin-gonic/gin/bindkey\"\n\n// Bind is a helper function for given interface object and returns a Gin middleware.\nfunc Bind(val any) HandlerFunc {\n\tvalue := reflect.ValueOf(val)\n\tif value.Kind() == reflect.Ptr {\n\t\tpanic(`Bind struct can not be a pointer. Example:\n\tUse: gin.Bind(Struct{}) instead of gin.Bind(&Struct{})\n`)\n\t}\n\ttyp := value.Type()\n\n\treturn func(c *Context) {\n\t\tobj := reflect.New(typ).Interface()\n\t\tif c.Bind(obj) == nil {\n\t\t\tc.Set(BindKey, obj)\n\t\t}\n\t}\n}\n\n// WrapF is a helper function for wrapping http.HandlerFunc and returns a Gin middleware.\nfunc WrapF(f http.HandlerFunc) HandlerFunc {\n\treturn func(c *Context) {\n\t\tf(c.Writer, c.Request)\n\t}\n}\n\n// WrapH is a helper function for wrapping http.Handler and returns a Gin middleware.\nfunc WrapH(h http.Handler) HandlerFunc {\n\treturn func(c *Context) {\n\t\th.ServeHTTP(c.Writer, c.Request)\n\t}\n}\n\n// H is a shortcut for map[string]any\ntype H map[string]any\n\n// MarshalXML allows type H to be used with xml.Marshal.\nfunc (h H) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n\tstart.Name = xml.Name{\n\t\tSpace: \"\",\n\t\tLocal: \"map\",\n\t}\n\tif err := e.EncodeToken(start); err != nil {\n\t\treturn err\n\t}\n\tfor key, value := range h {\n\t\telem := xml.StartElement{\n\t\t\tName: xml.Name{Space: \"\", Local: key},\n\t\t\tAttr: []xml.Attr{},\n\t\t}\n\t\tif err := e.EncodeElement(value, elem); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn e.EncodeToken(xml.EndElement{Name: start.Name})\n}\n\nfunc assert1(guard bool, text string) {\n\tif !guard {\n\t\tpanic(text)\n\t}\n}\n\nfunc filterFlags(content string) string {\n\tfor i, char := range content {\n\t\tif char == ' ' || char == ';' {\n\t\t\treturn content[:i]\n\t\t}\n\t}\n\treturn content\n}\n\nfunc chooseData(custom, wildcard any) any {\n\tif custom != nil {\n\t\treturn custom\n\t}\n\tif wildcard != nil {\n\t\treturn wildcard\n\t}\n\tpanic(\"negotiation config is invalid\")\n}\n\nfunc parseAccept(acceptHeader string) []string {\n\tparts := strings.Split(acceptHeader, \",\")\n\tout := make([]string, 0, len(parts))\n\tfor _, part := range parts {\n\t\tif i := strings.IndexByte(part, ';'); i > 0 {\n\t\t\tpart = part[:i]\n\t\t}\n\t\tif part = strings.TrimSpace(part); part != \"\" {\n\t\t\tout = append(out, part)\n\t\t}\n\t}\n\treturn out\n}\n\nfunc lastChar(str string) uint8 {\n\tif str == \"\" {\n\t\tpanic(\"The length of the string can't be 0\")\n\t}\n\treturn str[len(str)-1]\n}\n\nfunc nameOfFunction(f any) string {\n\treturn runtime.FuncForPC(reflect.ValueOf(f).Pointer()).Name()\n}\n\nfunc joinPaths(absolutePath, relativePath string) string {\n\tif relativePath == \"\" {\n\t\treturn absolutePath\n\t}\n\n\tfinalPath := path.Join(absolutePath, relativePath)\n\tif lastChar(relativePath) == '/' && lastChar(finalPath) != '/' {\n\t\treturn finalPath + \"/\"\n\t}\n\treturn finalPath\n}\n\nfunc resolveAddress(addr []string) string {\n\tswitch len(addr) {\n\tcase 0:\n\t\tif port := os.Getenv(\"PORT\"); port != \"\" {\n\t\t\tdebugPrint(\"Environment variable PORT=\\\"%s\\\"\", port)\n\t\t\treturn \":\" + port\n\t\t}\n\t\tdebugPrint(\"Environment variable PORT is undefined. Using port :8080 by default\")\n\t\treturn \":8080\"\n\tcase 1:\n\t\treturn addr[0]\n\tdefault:\n\t\tpanic(\"too many parameters\")\n\t}\n}\n\n// https://stackoverflow.com/questions/53069040/checking-a-string-contains-only-ascii-characters\nfunc isASCII(s string) bool {\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] > unicode.MaxASCII {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"
        },
        {
          "name": "utils_test.go",
          "type": "blob",
          "size": 3.9033203125,
          "content": "// Copyright 2014 Manu Martinez-Almeida. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\nimport (\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc init() {\n\tSetMode(TestMode)\n}\n\nfunc BenchmarkParseAccept(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tparseAccept(\"text/html , application/xhtml+xml,application/xml;q=0.9,  */* ;q=0.8\")\n\t}\n}\n\ntype testStruct struct {\n\tT *testing.T\n}\n\nfunc (t *testStruct) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n\tassert.Equal(t.T, http.MethodPost, req.Method)\n\tassert.Equal(t.T, \"/path\", req.URL.Path)\n\tw.WriteHeader(http.StatusInternalServerError)\n\tfmt.Fprint(w, \"hello\")\n}\n\nfunc TestWrap(t *testing.T) {\n\trouter := New()\n\trouter.POST(\"/path\", WrapH(&testStruct{t}))\n\trouter.GET(\"/path2\", WrapF(func(w http.ResponseWriter, req *http.Request) {\n\t\tassert.Equal(t, http.MethodGet, req.Method)\n\t\tassert.Equal(t, \"/path2\", req.URL.Path)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(w, \"hola!\")\n\t}))\n\n\tw := PerformRequest(router, http.MethodPost, \"/path\")\n\tassert.Equal(t, http.StatusInternalServerError, w.Code)\n\tassert.Equal(t, \"hello\", w.Body.String())\n\n\tw = PerformRequest(router, http.MethodGet, \"/path2\")\n\tassert.Equal(t, http.StatusBadRequest, w.Code)\n\tassert.Equal(t, \"hola!\", w.Body.String())\n}\n\nfunc TestLastChar(t *testing.T) {\n\tassert.Equal(t, uint8('a'), lastChar(\"hola\"))\n\tassert.Equal(t, uint8('s'), lastChar(\"adios\"))\n\tassert.Panics(t, func() { lastChar(\"\") })\n}\n\nfunc TestParseAccept(t *testing.T) {\n\tparts := parseAccept(\"text/html , application/xhtml+xml,application/xml;q=0.9,  */* ;q=0.8\")\n\tassert.Len(t, parts, 4)\n\tassert.Equal(t, \"text/html\", parts[0])\n\tassert.Equal(t, \"application/xhtml+xml\", parts[1])\n\tassert.Equal(t, \"application/xml\", parts[2])\n\tassert.Equal(t, \"*/*\", parts[3])\n}\n\nfunc TestChooseData(t *testing.T) {\n\tA := \"a\"\n\tB := \"b\"\n\tassert.Equal(t, A, chooseData(A, B))\n\tassert.Equal(t, B, chooseData(nil, B))\n\tassert.Panics(t, func() { chooseData(nil, nil) })\n}\n\nfunc TestFilterFlags(t *testing.T) {\n\tresult := filterFlags(\"text/html \")\n\tassert.Equal(t, \"text/html\", result)\n\n\tresult = filterFlags(\"text/html;\")\n\tassert.Equal(t, \"text/html\", result)\n}\n\nfunc TestFunctionName(t *testing.T) {\n\tassert.Regexp(t, `^(.*/vendor/)?github.com/gin-gonic/gin.somefunction$`, nameOfFunction(somefunction))\n}\n\nfunc somefunction() {\n\t// this empty function is used by TestFunctionName()\n}\n\nfunc TestJoinPaths(t *testing.T) {\n\tassert.Equal(t, \"\", joinPaths(\"\", \"\"))\n\tassert.Equal(t, \"/\", joinPaths(\"\", \"/\"))\n\tassert.Equal(t, \"/a\", joinPaths(\"/a\", \"\"))\n\tassert.Equal(t, \"/a/\", joinPaths(\"/a/\", \"\"))\n\tassert.Equal(t, \"/a/\", joinPaths(\"/a/\", \"/\"))\n\tassert.Equal(t, \"/a/\", joinPaths(\"/a\", \"/\"))\n\tassert.Equal(t, \"/a/hola\", joinPaths(\"/a\", \"/hola\"))\n\tassert.Equal(t, \"/a/hola\", joinPaths(\"/a/\", \"/hola\"))\n\tassert.Equal(t, \"/a/hola/\", joinPaths(\"/a/\", \"/hola/\"))\n\tassert.Equal(t, \"/a/hola/\", joinPaths(\"/a/\", \"/hola//\"))\n}\n\ntype bindTestStruct struct {\n\tFoo string `form:\"foo\" binding:\"required\"`\n\tBar int    `form:\"bar\" binding:\"min=4\"`\n}\n\nfunc TestBindMiddleware(t *testing.T) {\n\tvar value *bindTestStruct\n\tvar called bool\n\trouter := New()\n\trouter.GET(\"/\", Bind(bindTestStruct{}), func(c *Context) {\n\t\tcalled = true\n\t\tvalue = c.MustGet(BindKey).(*bindTestStruct)\n\t})\n\tPerformRequest(router, http.MethodGet, \"/?foo=hola&bar=10\")\n\tassert.True(t, called)\n\tassert.Equal(t, \"hola\", value.Foo)\n\tassert.Equal(t, 10, value.Bar)\n\n\tcalled = false\n\tPerformRequest(router, http.MethodGet, \"/?foo=hola&bar=1\")\n\tassert.False(t, called)\n\n\tassert.Panics(t, func() {\n\t\tBind(&bindTestStruct{})\n\t})\n}\n\nfunc TestMarshalXMLforH(t *testing.T) {\n\th := H{\n\t\t\"\": \"test\",\n\t}\n\tvar b bytes.Buffer\n\tenc := xml.NewEncoder(&b)\n\tvar x xml.StartElement\n\te := h.MarshalXML(enc, x)\n\tassert.Error(t, e)\n}\n\nfunc TestIsASCII(t *testing.T) {\n\tassert.True(t, isASCII(\"test\"))\n\tassert.False(t, isASCII(\"üß°üíõüíöüíôüíú\"))\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.2431640625,
          "content": "// Copyright 2018 Gin Core Team. All rights reserved.\n// Use of this source code is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage gin\n\n// Version is the current gin framework's version.\nconst Version = \"v1.10.0\"\n"
        }
      ]
    }
  ]
}