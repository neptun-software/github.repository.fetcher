{
  "metadata": {
    "timestamp": 1736568126703,
    "page": 19,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go-gorm/gorm",
      "stars": 37284,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0546875,
          "content": "TODO*\ndocuments\ncoverage.txt\n_book\n.idea\nvendor\n.vscode\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.2841796875,
          "content": "linters:\n  enable:\n    - cyclop\n    - exportloopref\n    - gocritic\n    - gosec\n    - ineffassign\n    - misspell\n    - prealloc\n    - unconvert\n    - unparam\n    - goimports\n    - whitespace\n\nlinters-settings:\n  whitespace:\n    multi-func: true\n  goimports:\n    local-prefixes: gorm.io/gorm\n\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 5.04296875,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to participate in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity includes:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\n.\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period. This\nincludes avoiding interactions in community spaces and external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any interaction or public\ncommunication with the community for a specified period. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct\nenforcement ladder](https://github.com/mozilla/diversity).\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0712890625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013-NOW  Jinzhu <wosmvp@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.81640625,
          "content": "# GORM\n\nThe fantastic ORM library for Golang, aims to be developer friendly.\n\n[![go report card](https://goreportcard.com/badge/github.com/go-gorm/gorm \"go report card\")](https://goreportcard.com/report/github.com/go-gorm/gorm)\n[![test status](https://github.com/go-gorm/gorm/workflows/tests/badge.svg?branch=master \"test status\")](https://github.com/go-gorm/gorm/actions)\n[![MIT license](https://img.shields.io/badge/license-MIT-brightgreen.svg)](https://opensource.org/licenses/MIT)\n[![Go.Dev reference](https://img.shields.io/badge/go.dev-reference-blue?logo=go&logoColor=white)](https://pkg.go.dev/gorm.io/gorm?tab=doc)\n\n## Overview\n\n* Full-Featured ORM\n* Associations (Has One, Has Many, Belongs To, Many To Many, Polymorphism, Single-table inheritance)\n* Hooks (Before/After Create/Save/Update/Delete/Find)\n* Eager loading with `Preload`, `Joins`\n* Transactions, Nested Transactions, Save Point, RollbackTo to Saved Point\n* Context, Prepared Statement Mode, DryRun Mode\n* Batch Insert, FindInBatches, Find To Map\n* SQL Builder, Upsert, Locking, Optimizer/Index/Comment Hints, NamedArg, Search/Update/Create with SQL Expr\n* Composite Primary Key\n* Auto Migrations\n* Logger\n* Extendable, flexible plugin API: Database Resolver (Multiple Databases, Read/Write Splitting) / Prometheus…\n* Every feature comes with tests\n* Developer Friendly\n\n## Getting Started\n\n* GORM Guides [https://gorm.io](https://gorm.io)\n* Gen Guides [https://gorm.io/gen/index.html](https://gorm.io/gen/index.html)\n\n## Contributing\n\n[You can help to deliver a better GORM, check out things you can do](https://gorm.io/contribute.html)\n\n## Contributors\n\n[Thank you](https://github.com/go-gorm/gorm/graphs/contributors) for contributing to the GORM framework!\n\n## License\n\n© Jinzhu, 2013~time.Now\n\nReleased under the [MIT License](https://github.com/go-gorm/gorm/blob/master/LICENSE)\n"
        },
        {
          "name": "association.go",
          "type": "blob",
          "size": 21.5048828125,
          "content": "package gorm\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"gorm.io/gorm/clause\"\n\t\"gorm.io/gorm/schema\"\n\t\"gorm.io/gorm/utils\"\n)\n\n// Association Mode contains some helper methods to handle relationship things easily.\ntype Association struct {\n\tDB           *DB\n\tRelationship *schema.Relationship\n\tUnscope      bool\n\tError        error\n}\n\nfunc (db *DB) Association(column string) *Association {\n\tassociation := &Association{DB: db}\n\ttable := db.Statement.Table\n\n\tif err := db.Statement.Parse(db.Statement.Model); err == nil {\n\t\tdb.Statement.Table = table\n\t\tassociation.Relationship = db.Statement.Schema.Relationships.Relations[column]\n\n\t\tif association.Relationship == nil {\n\t\t\tassociation.Error = fmt.Errorf(\"%w: %s\", ErrUnsupportedRelation, column)\n\t\t}\n\n\t\tdb.Statement.ReflectValue = reflect.ValueOf(db.Statement.Model)\n\t\tfor db.Statement.ReflectValue.Kind() == reflect.Ptr {\n\t\t\tdb.Statement.ReflectValue = db.Statement.ReflectValue.Elem()\n\t\t}\n\t} else {\n\t\tassociation.Error = err\n\t}\n\n\treturn association\n}\n\nfunc (association *Association) Unscoped() *Association {\n\treturn &Association{\n\t\tDB:           association.DB,\n\t\tRelationship: association.Relationship,\n\t\tError:        association.Error,\n\t\tUnscope:      true,\n\t}\n}\n\nfunc (association *Association) Find(out interface{}, conds ...interface{}) error {\n\tif association.Error == nil {\n\t\tassociation.Error = association.buildCondition().Find(out, conds...).Error\n\t}\n\treturn association.Error\n}\n\nfunc (association *Association) Append(values ...interface{}) error {\n\tif association.Error == nil {\n\t\tswitch association.Relationship.Type {\n\t\tcase schema.HasOne, schema.BelongsTo:\n\t\t\tif len(values) > 0 {\n\t\t\t\tassociation.Error = association.Replace(values...)\n\t\t\t}\n\t\tdefault:\n\t\t\tassociation.saveAssociation( /*clear*/ false, values...)\n\t\t}\n\t}\n\n\treturn association.Error\n}\n\nfunc (association *Association) Replace(values ...interface{}) error {\n\tif association.Error == nil {\n\t\treflectValue := association.DB.Statement.ReflectValue\n\t\trel := association.Relationship\n\n\t\tvar oldBelongsToExpr clause.Expression\n\t\t// we have to record the old BelongsTo value\n\t\tif association.Unscope && rel.Type == schema.BelongsTo {\n\t\t\tvar foreignFields []*schema.Field\n\t\t\tfor _, ref := range rel.References {\n\t\t\t\tif !ref.OwnPrimaryKey {\n\t\t\t\t\tforeignFields = append(foreignFields, ref.ForeignKey)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, fvs := schema.GetIdentityFieldValuesMap(association.DB.Statement.Context, reflectValue, foreignFields); len(fvs) > 0 {\n\t\t\t\tcolumn, values := schema.ToQueryValues(rel.FieldSchema.Table, rel.FieldSchema.PrimaryFieldDBNames, fvs)\n\t\t\t\toldBelongsToExpr = clause.IN{Column: column, Values: values}\n\t\t\t}\n\t\t}\n\n\t\t// save associations\n\t\tif association.saveAssociation( /*clear*/ true, values...); association.Error != nil {\n\t\t\treturn association.Error\n\t\t}\n\n\t\t// set old associations's foreign key to null\n\t\tswitch rel.Type {\n\t\tcase schema.BelongsTo:\n\t\t\tif len(values) == 0 {\n\t\t\t\tupdateMap := map[string]interface{}{}\n\t\t\t\tswitch reflectValue.Kind() {\n\t\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\t\tfor i := 0; i < reflectValue.Len(); i++ {\n\t\t\t\t\t\tassociation.Error = rel.Field.Set(association.DB.Statement.Context, reflectValue.Index(i), reflect.Zero(rel.Field.FieldType).Interface())\n\t\t\t\t\t}\n\t\t\t\tcase reflect.Struct:\n\t\t\t\t\tassociation.Error = rel.Field.Set(association.DB.Statement.Context, reflectValue, reflect.Zero(rel.Field.FieldType).Interface())\n\t\t\t\t}\n\n\t\t\t\tfor _, ref := range rel.References {\n\t\t\t\t\tupdateMap[ref.ForeignKey.DBName] = nil\n\t\t\t\t}\n\n\t\t\t\tassociation.Error = association.DB.UpdateColumns(updateMap).Error\n\t\t\t}\n\t\t\tif association.Unscope && oldBelongsToExpr != nil {\n\t\t\t\tassociation.Error = association.DB.Model(nil).Where(oldBelongsToExpr).Delete(reflect.New(rel.FieldSchema.ModelType).Interface()).Error\n\t\t\t}\n\t\tcase schema.HasOne, schema.HasMany:\n\t\t\tvar (\n\t\t\t\tprimaryFields []*schema.Field\n\t\t\t\tforeignKeys   []string\n\t\t\t\tupdateMap     = map[string]interface{}{}\n\t\t\t\trelValues     = schema.GetRelationsValues(association.DB.Statement.Context, reflectValue, []*schema.Relationship{rel})\n\t\t\t\tmodelValue    = reflect.New(rel.FieldSchema.ModelType).Interface()\n\t\t\t\ttx            = association.DB.Model(modelValue)\n\t\t\t)\n\n\t\t\tif _, rvs := schema.GetIdentityFieldValuesMap(association.DB.Statement.Context, relValues, rel.FieldSchema.PrimaryFields); len(rvs) > 0 {\n\t\t\t\tif column, values := schema.ToQueryValues(rel.FieldSchema.Table, rel.FieldSchema.PrimaryFieldDBNames, rvs); len(values) > 0 {\n\t\t\t\t\ttx.Not(clause.IN{Column: column, Values: values})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor _, ref := range rel.References {\n\t\t\t\tif ref.OwnPrimaryKey {\n\t\t\t\t\tprimaryFields = append(primaryFields, ref.PrimaryKey)\n\t\t\t\t\tforeignKeys = append(foreignKeys, ref.ForeignKey.DBName)\n\t\t\t\t\tupdateMap[ref.ForeignKey.DBName] = nil\n\t\t\t\t} else if ref.PrimaryValue != \"\" {\n\t\t\t\t\ttx.Where(clause.Eq{Column: ref.ForeignKey.DBName, Value: ref.PrimaryValue})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif _, pvs := schema.GetIdentityFieldValuesMap(association.DB.Statement.Context, reflectValue, primaryFields); len(pvs) > 0 {\n\t\t\t\tcolumn, values := schema.ToQueryValues(rel.FieldSchema.Table, foreignKeys, pvs)\n\t\t\t\tif association.Unscope {\n\t\t\t\t\tassociation.Error = tx.Where(clause.IN{Column: column, Values: values}).Delete(modelValue).Error\n\t\t\t\t} else {\n\t\t\t\t\tassociation.Error = tx.Where(clause.IN{Column: column, Values: values}).UpdateColumns(updateMap).Error\n\t\t\t\t}\n\t\t\t}\n\t\tcase schema.Many2Many:\n\t\t\tvar (\n\t\t\t\tprimaryFields, relPrimaryFields     []*schema.Field\n\t\t\t\tjoinPrimaryKeys, joinRelPrimaryKeys []string\n\t\t\t\tmodelValue                          = reflect.New(rel.JoinTable.ModelType).Interface()\n\t\t\t\ttx                                  = association.DB.Model(modelValue)\n\t\t\t)\n\n\t\t\tfor _, ref := range rel.References {\n\t\t\t\tif ref.PrimaryValue == \"\" {\n\t\t\t\t\tif ref.OwnPrimaryKey {\n\t\t\t\t\t\tprimaryFields = append(primaryFields, ref.PrimaryKey)\n\t\t\t\t\t\tjoinPrimaryKeys = append(joinPrimaryKeys, ref.ForeignKey.DBName)\n\t\t\t\t\t} else {\n\t\t\t\t\t\trelPrimaryFields = append(relPrimaryFields, ref.PrimaryKey)\n\t\t\t\t\t\tjoinRelPrimaryKeys = append(joinRelPrimaryKeys, ref.ForeignKey.DBName)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttx.Clauses(clause.Eq{Column: ref.ForeignKey.DBName, Value: ref.PrimaryValue})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_, pvs := schema.GetIdentityFieldValuesMap(association.DB.Statement.Context, reflectValue, primaryFields)\n\t\t\tif column, values := schema.ToQueryValues(rel.JoinTable.Table, joinPrimaryKeys, pvs); len(values) > 0 {\n\t\t\t\ttx.Where(clause.IN{Column: column, Values: values})\n\t\t\t} else {\n\t\t\t\treturn ErrPrimaryKeyRequired\n\t\t\t}\n\n\t\t\t_, rvs := schema.GetIdentityFieldValuesMapFromValues(association.DB.Statement.Context, values, relPrimaryFields)\n\t\t\tif relColumn, relValues := schema.ToQueryValues(rel.JoinTable.Table, joinRelPrimaryKeys, rvs); len(relValues) > 0 {\n\t\t\t\ttx.Where(clause.Not(clause.IN{Column: relColumn, Values: relValues}))\n\t\t\t}\n\n\t\t\tassociation.Error = tx.Delete(modelValue).Error\n\t\t}\n\t}\n\treturn association.Error\n}\n\nfunc (association *Association) Delete(values ...interface{}) error {\n\tif association.Error == nil {\n\t\tvar (\n\t\t\treflectValue  = association.DB.Statement.ReflectValue\n\t\t\trel           = association.Relationship\n\t\t\tprimaryFields []*schema.Field\n\t\t\tforeignKeys   []string\n\t\t\tupdateAttrs   = map[string]interface{}{}\n\t\t\tconds         []clause.Expression\n\t\t)\n\n\t\tfor _, ref := range rel.References {\n\t\t\tif ref.PrimaryValue == \"\" {\n\t\t\t\tprimaryFields = append(primaryFields, ref.PrimaryKey)\n\t\t\t\tforeignKeys = append(foreignKeys, ref.ForeignKey.DBName)\n\t\t\t\tupdateAttrs[ref.ForeignKey.DBName] = nil\n\t\t\t} else {\n\t\t\t\tconds = append(conds, clause.Eq{Column: ref.ForeignKey.DBName, Value: ref.PrimaryValue})\n\t\t\t}\n\t\t}\n\n\t\tswitch rel.Type {\n\t\tcase schema.BelongsTo:\n\t\t\tassociationDB := association.DB.Session(&Session{})\n\t\t\ttx := associationDB.Model(reflect.New(rel.Schema.ModelType).Interface())\n\n\t\t\t_, pvs := schema.GetIdentityFieldValuesMap(association.DB.Statement.Context, reflectValue, rel.Schema.PrimaryFields)\n\t\t\tif pcolumn, pvalues := schema.ToQueryValues(rel.Schema.Table, rel.Schema.PrimaryFieldDBNames, pvs); len(pvalues) > 0 {\n\t\t\t\tconds = append(conds, clause.IN{Column: pcolumn, Values: pvalues})\n\t\t\t} else {\n\t\t\t\treturn ErrPrimaryKeyRequired\n\t\t\t}\n\n\t\t\t_, rvs := schema.GetIdentityFieldValuesMapFromValues(association.DB.Statement.Context, values, primaryFields)\n\t\t\trelColumn, relValues := schema.ToQueryValues(rel.Schema.Table, foreignKeys, rvs)\n\t\t\tconds = append(conds, clause.IN{Column: relColumn, Values: relValues})\n\n\t\t\tassociation.Error = tx.Clauses(conds...).UpdateColumns(updateAttrs).Error\n\t\t\tif association.Unscope {\n\t\t\t\tvar foreignFields []*schema.Field\n\t\t\t\tfor _, ref := range rel.References {\n\t\t\t\t\tif !ref.OwnPrimaryKey {\n\t\t\t\t\t\tforeignFields = append(foreignFields, ref.ForeignKey)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif _, fvs := schema.GetIdentityFieldValuesMap(association.DB.Statement.Context, reflectValue, foreignFields); len(fvs) > 0 {\n\t\t\t\t\tcolumn, values := schema.ToQueryValues(rel.FieldSchema.Table, rel.FieldSchema.PrimaryFieldDBNames, fvs)\n\t\t\t\t\tassociation.Error = associationDB.Model(nil).Where(clause.IN{Column: column, Values: values}).Delete(reflect.New(rel.FieldSchema.ModelType).Interface()).Error\n\t\t\t\t}\n\t\t\t}\n\t\tcase schema.HasOne, schema.HasMany:\n\t\t\tmodel := reflect.New(rel.FieldSchema.ModelType).Interface()\n\t\t\ttx := association.DB.Model(model)\n\n\t\t\t_, pvs := schema.GetIdentityFieldValuesMap(association.DB.Statement.Context, reflectValue, primaryFields)\n\t\t\tif pcolumn, pvalues := schema.ToQueryValues(rel.FieldSchema.Table, foreignKeys, pvs); len(pvalues) > 0 {\n\t\t\t\tconds = append(conds, clause.IN{Column: pcolumn, Values: pvalues})\n\t\t\t} else {\n\t\t\t\treturn ErrPrimaryKeyRequired\n\t\t\t}\n\n\t\t\t_, rvs := schema.GetIdentityFieldValuesMapFromValues(association.DB.Statement.Context, values, rel.FieldSchema.PrimaryFields)\n\t\t\trelColumn, relValues := schema.ToQueryValues(rel.FieldSchema.Table, rel.FieldSchema.PrimaryFieldDBNames, rvs)\n\t\t\tconds = append(conds, clause.IN{Column: relColumn, Values: relValues})\n\n\t\t\tif association.Unscope {\n\t\t\t\tassociation.Error = tx.Clauses(conds...).Delete(model).Error\n\t\t\t} else {\n\t\t\t\tassociation.Error = tx.Clauses(conds...).UpdateColumns(updateAttrs).Error\n\t\t\t}\n\t\tcase schema.Many2Many:\n\t\t\tvar (\n\t\t\t\tprimaryFields, relPrimaryFields     []*schema.Field\n\t\t\t\tjoinPrimaryKeys, joinRelPrimaryKeys []string\n\t\t\t\tjoinValue                           = reflect.New(rel.JoinTable.ModelType).Interface()\n\t\t\t)\n\n\t\t\tfor _, ref := range rel.References {\n\t\t\t\tif ref.PrimaryValue == \"\" {\n\t\t\t\t\tif ref.OwnPrimaryKey {\n\t\t\t\t\t\tprimaryFields = append(primaryFields, ref.PrimaryKey)\n\t\t\t\t\t\tjoinPrimaryKeys = append(joinPrimaryKeys, ref.ForeignKey.DBName)\n\t\t\t\t\t} else {\n\t\t\t\t\t\trelPrimaryFields = append(relPrimaryFields, ref.PrimaryKey)\n\t\t\t\t\t\tjoinRelPrimaryKeys = append(joinRelPrimaryKeys, ref.ForeignKey.DBName)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconds = append(conds, clause.Eq{Column: ref.ForeignKey.DBName, Value: ref.PrimaryValue})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_, pvs := schema.GetIdentityFieldValuesMap(association.DB.Statement.Context, reflectValue, primaryFields)\n\t\t\tif pcolumn, pvalues := schema.ToQueryValues(rel.JoinTable.Table, joinPrimaryKeys, pvs); len(pvalues) > 0 {\n\t\t\t\tconds = append(conds, clause.IN{Column: pcolumn, Values: pvalues})\n\t\t\t} else {\n\t\t\t\treturn ErrPrimaryKeyRequired\n\t\t\t}\n\n\t\t\t_, rvs := schema.GetIdentityFieldValuesMapFromValues(association.DB.Statement.Context, values, relPrimaryFields)\n\t\t\trelColumn, relValues := schema.ToQueryValues(rel.JoinTable.Table, joinRelPrimaryKeys, rvs)\n\t\t\tconds = append(conds, clause.IN{Column: relColumn, Values: relValues})\n\n\t\t\tassociation.Error = association.DB.Where(clause.Where{Exprs: conds}).Model(nil).Delete(joinValue).Error\n\t\t}\n\n\t\tif association.Error == nil {\n\t\t\t// clean up deleted values's foreign key\n\t\t\trelValuesMap, _ := schema.GetIdentityFieldValuesMapFromValues(association.DB.Statement.Context, values, rel.FieldSchema.PrimaryFields)\n\n\t\t\tcleanUpDeletedRelations := func(data reflect.Value) {\n\t\t\t\tif _, zero := rel.Field.ValueOf(association.DB.Statement.Context, data); !zero {\n\t\t\t\t\tfieldValue := reflect.Indirect(rel.Field.ReflectValueOf(association.DB.Statement.Context, data))\n\t\t\t\t\tprimaryValues := make([]interface{}, len(rel.FieldSchema.PrimaryFields))\n\n\t\t\t\t\tswitch fieldValue.Kind() {\n\t\t\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\t\t\tvalidFieldValues := reflect.Zero(rel.Field.IndirectFieldType)\n\t\t\t\t\t\tfor i := 0; i < fieldValue.Len(); i++ {\n\t\t\t\t\t\t\tfor idx, field := range rel.FieldSchema.PrimaryFields {\n\t\t\t\t\t\t\t\tprimaryValues[idx], _ = field.ValueOf(association.DB.Statement.Context, fieldValue.Index(i))\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif _, ok := relValuesMap[utils.ToStringKey(primaryValues...)]; !ok {\n\t\t\t\t\t\t\t\tvalidFieldValues = reflect.Append(validFieldValues, fieldValue.Index(i))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tassociation.Error = rel.Field.Set(association.DB.Statement.Context, data, validFieldValues.Interface())\n\t\t\t\t\tcase reflect.Struct:\n\t\t\t\t\t\tfor idx, field := range rel.FieldSchema.PrimaryFields {\n\t\t\t\t\t\t\tprimaryValues[idx], _ = field.ValueOf(association.DB.Statement.Context, fieldValue)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif _, ok := relValuesMap[utils.ToStringKey(primaryValues...)]; ok {\n\t\t\t\t\t\t\tif association.Error = rel.Field.Set(association.DB.Statement.Context, data, reflect.Zero(rel.FieldSchema.ModelType).Interface()); association.Error != nil {\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif rel.JoinTable == nil {\n\t\t\t\t\t\t\t\tfor _, ref := range rel.References {\n\t\t\t\t\t\t\t\t\tif ref.OwnPrimaryKey || ref.PrimaryValue != \"\" {\n\t\t\t\t\t\t\t\t\t\tassociation.Error = ref.ForeignKey.Set(association.DB.Statement.Context, fieldValue, reflect.Zero(ref.ForeignKey.FieldType).Interface())\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tassociation.Error = ref.ForeignKey.Set(association.DB.Statement.Context, data, reflect.Zero(ref.ForeignKey.FieldType).Interface())\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch reflectValue.Kind() {\n\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\tfor i := 0; i < reflectValue.Len(); i++ {\n\t\t\t\t\tcleanUpDeletedRelations(reflect.Indirect(reflectValue.Index(i)))\n\t\t\t\t}\n\t\t\tcase reflect.Struct:\n\t\t\t\tcleanUpDeletedRelations(reflectValue)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn association.Error\n}\n\nfunc (association *Association) Clear() error {\n\treturn association.Replace()\n}\n\nfunc (association *Association) Count() (count int64) {\n\tif association.Error == nil {\n\t\tassociation.Error = association.buildCondition().Count(&count).Error\n\t}\n\treturn\n}\n\ntype assignBack struct {\n\tSource reflect.Value\n\tIndex  int\n\tDest   reflect.Value\n}\n\nfunc (association *Association) saveAssociation(clear bool, values ...interface{}) {\n\tvar (\n\t\treflectValue = association.DB.Statement.ReflectValue\n\t\tassignBacks  []assignBack // assign association values back to arguments after save\n\t)\n\n\tappendToRelations := func(source, rv reflect.Value, clear bool) {\n\t\tswitch association.Relationship.Type {\n\t\tcase schema.HasOne, schema.BelongsTo:\n\t\t\tswitch rv.Kind() {\n\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\tif rv.Len() > 0 {\n\t\t\t\t\tassociation.Error = association.Relationship.Field.Set(association.DB.Statement.Context, source, rv.Index(0).Addr().Interface())\n\n\t\t\t\t\tif association.Relationship.Field.FieldType.Kind() == reflect.Struct {\n\t\t\t\t\t\tassignBacks = append(assignBacks, assignBack{Source: source, Dest: rv.Index(0)})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase reflect.Struct:\n\t\t\t\tif !rv.CanAddr() {\n\t\t\t\t\tassociation.Error = ErrInvalidValue\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tassociation.Error = association.Relationship.Field.Set(association.DB.Statement.Context, source, rv.Addr().Interface())\n\n\t\t\t\tif association.Relationship.Field.FieldType.Kind() == reflect.Struct {\n\t\t\t\t\tassignBacks = append(assignBacks, assignBack{Source: source, Dest: rv})\n\t\t\t\t}\n\t\t\t}\n\t\tcase schema.HasMany, schema.Many2Many:\n\t\t\telemType := association.Relationship.Field.IndirectFieldType.Elem()\n\t\t\toldFieldValue := reflect.Indirect(association.Relationship.Field.ReflectValueOf(association.DB.Statement.Context, source))\n\t\t\tvar fieldValue reflect.Value\n\t\t\tif clear {\n\t\t\t\tfieldValue = reflect.MakeSlice(oldFieldValue.Type(), 0, oldFieldValue.Cap())\n\t\t\t} else {\n\t\t\t\tfieldValue = reflect.MakeSlice(oldFieldValue.Type(), oldFieldValue.Len(), oldFieldValue.Cap())\n\t\t\t\treflect.Copy(fieldValue, oldFieldValue)\n\t\t\t}\n\n\t\t\tappendToFieldValues := func(ev reflect.Value) {\n\t\t\t\tif ev.Type().AssignableTo(elemType) {\n\t\t\t\t\tfieldValue = reflect.Append(fieldValue, ev)\n\t\t\t\t} else if ev.Type().Elem().AssignableTo(elemType) {\n\t\t\t\t\tfieldValue = reflect.Append(fieldValue, ev.Elem())\n\t\t\t\t} else {\n\t\t\t\t\tassociation.Error = fmt.Errorf(\"unsupported data type: %v for relation %s\", ev.Type(), association.Relationship.Name)\n\t\t\t\t}\n\n\t\t\t\tif elemType.Kind() == reflect.Struct {\n\t\t\t\t\tassignBacks = append(assignBacks, assignBack{Source: source, Dest: ev, Index: fieldValue.Len()})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch rv.Kind() {\n\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\tfor i := 0; i < rv.Len(); i++ {\n\t\t\t\t\tappendToFieldValues(reflect.Indirect(rv.Index(i)).Addr())\n\t\t\t\t}\n\t\t\tcase reflect.Struct:\n\t\t\t\tif !rv.CanAddr() {\n\t\t\t\t\tassociation.Error = ErrInvalidValue\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tappendToFieldValues(rv.Addr())\n\t\t\t}\n\n\t\t\tif association.Error == nil {\n\t\t\t\tassociation.Error = association.Relationship.Field.Set(association.DB.Statement.Context, source, fieldValue.Interface())\n\t\t\t}\n\t\t}\n\t}\n\n\tselectedSaveColumns := []string{association.Relationship.Name}\n\tomitColumns := []string{}\n\tselectColumns, _ := association.DB.Statement.SelectAndOmitColumns(true, false)\n\tfor name, ok := range selectColumns {\n\t\tcolumnName := \"\"\n\t\tif strings.HasPrefix(name, association.Relationship.Name) {\n\t\t\tif columnName = strings.TrimPrefix(name, association.Relationship.Name); columnName == \".*\" {\n\t\t\t\tcolumnName = name\n\t\t\t}\n\t\t} else if strings.HasPrefix(name, clause.Associations) {\n\t\t\tcolumnName = name\n\t\t}\n\n\t\tif columnName != \"\" {\n\t\t\tif ok {\n\t\t\t\tselectedSaveColumns = append(selectedSaveColumns, columnName)\n\t\t\t} else {\n\t\t\t\tomitColumns = append(omitColumns, columnName)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, ref := range association.Relationship.References {\n\t\tif !ref.OwnPrimaryKey {\n\t\t\tselectedSaveColumns = append(selectedSaveColumns, ref.ForeignKey.Name)\n\t\t}\n\t}\n\n\tassociationDB := association.DB.Session(&Session{}).Model(nil)\n\tif !association.DB.FullSaveAssociations {\n\t\tassociationDB.Select(selectedSaveColumns)\n\t}\n\tif len(omitColumns) > 0 {\n\t\tassociationDB.Omit(omitColumns...)\n\t}\n\tassociationDB = associationDB.Session(&Session{})\n\n\tswitch reflectValue.Kind() {\n\tcase reflect.Slice, reflect.Array:\n\t\tif len(values) != reflectValue.Len() {\n\t\t\t// clear old data\n\t\t\tif clear && len(values) == 0 {\n\t\t\t\tfor i := 0; i < reflectValue.Len(); i++ {\n\t\t\t\t\tif err := association.Relationship.Field.Set(association.DB.Statement.Context, reflectValue.Index(i), reflect.New(association.Relationship.Field.IndirectFieldType).Interface()); err != nil {\n\t\t\t\t\t\tassociation.Error = err\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\tif association.Relationship.JoinTable == nil {\n\t\t\t\t\t\tfor _, ref := range association.Relationship.References {\n\t\t\t\t\t\t\tif !ref.OwnPrimaryKey && ref.PrimaryValue == \"\" {\n\t\t\t\t\t\t\t\tif err := ref.ForeignKey.Set(association.DB.Statement.Context, reflectValue.Index(i), reflect.Zero(ref.ForeignKey.FieldType).Interface()); err != nil {\n\t\t\t\t\t\t\t\t\tassociation.Error = err\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tassociation.Error = ErrInvalidValueOfLength\n\t\t\treturn\n\t\t}\n\n\t\tfor i := 0; i < reflectValue.Len(); i++ {\n\t\t\tappendToRelations(reflectValue.Index(i), reflect.Indirect(reflect.ValueOf(values[i])), clear)\n\t\t\tif association.Error != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// TODO support save slice data, sql with case?\n\t\t\tassociation.Error = associationDB.Updates(reflectValue.Index(i).Addr().Interface()).Error\n\t\t}\n\tcase reflect.Struct:\n\t\t// clear old data\n\t\tif clear && len(values) == 0 {\n\t\t\tassociation.Error = association.Relationship.Field.Set(association.DB.Statement.Context, reflectValue, reflect.New(association.Relationship.Field.IndirectFieldType).Interface())\n\n\t\t\tif association.Relationship.JoinTable == nil && association.Error == nil {\n\t\t\t\tfor _, ref := range association.Relationship.References {\n\t\t\t\t\tif !ref.OwnPrimaryKey && ref.PrimaryValue == \"\" {\n\t\t\t\t\t\tassociation.Error = ref.ForeignKey.Set(association.DB.Statement.Context, reflectValue, reflect.Zero(ref.ForeignKey.FieldType).Interface())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor idx, value := range values {\n\t\t\trv := reflect.Indirect(reflect.ValueOf(value))\n\t\t\tappendToRelations(reflectValue, rv, clear && idx == 0)\n\t\t\tif association.Error != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif len(values) > 0 {\n\t\t\tassociation.Error = associationDB.Updates(reflectValue.Addr().Interface()).Error\n\t\t}\n\t}\n\n\tfor _, assignBack := range assignBacks {\n\t\tfieldValue := reflect.Indirect(association.Relationship.Field.ReflectValueOf(association.DB.Statement.Context, assignBack.Source))\n\t\tif assignBack.Index > 0 {\n\t\t\treflect.Indirect(assignBack.Dest).Set(fieldValue.Index(assignBack.Index - 1))\n\t\t} else {\n\t\t\treflect.Indirect(assignBack.Dest).Set(fieldValue)\n\t\t}\n\t}\n}\n\nfunc (association *Association) buildCondition() *DB {\n\tvar (\n\t\tqueryConds = association.Relationship.ToQueryConditions(association.DB.Statement.Context, association.DB.Statement.ReflectValue)\n\t\tmodelValue = reflect.New(association.Relationship.FieldSchema.ModelType).Interface()\n\t\ttx         = association.DB.Model(modelValue)\n\t)\n\n\tif association.Relationship.JoinTable != nil {\n\t\tif !tx.Statement.Unscoped && len(association.Relationship.JoinTable.QueryClauses) > 0 {\n\t\t\tjoinStmt := Statement{DB: tx, Context: tx.Statement.Context, Schema: association.Relationship.JoinTable, Table: association.Relationship.JoinTable.Table, Clauses: map[string]clause.Clause{}}\n\t\t\tfor _, queryClause := range association.Relationship.JoinTable.QueryClauses {\n\t\t\t\tjoinStmt.AddClause(queryClause)\n\t\t\t}\n\t\t\tjoinStmt.Build(\"WHERE\")\n\t\t\tif len(joinStmt.SQL.String()) > 0 {\n\t\t\t\ttx.Clauses(clause.Expr{SQL: strings.Replace(joinStmt.SQL.String(), \"WHERE \", \"\", 1), Vars: joinStmt.Vars})\n\t\t\t}\n\t\t}\n\n\t\ttx = tx.Session(&Session{QueryFields: true}).Clauses(clause.From{Joins: []clause.Join{{\n\t\t\tTable: clause.Table{Name: association.Relationship.JoinTable.Table},\n\t\t\tON:    clause.Where{Exprs: queryConds},\n\t\t}}})\n\t} else {\n\t\ttx.Clauses(clause.Where{Exprs: queryConds})\n\t}\n\n\treturn tx\n}\n"
        },
        {
          "name": "callbacks.go",
          "type": "blob",
          "size": 8.64453125,
          "content": "package gorm\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\t\"time\"\n\n\t\"gorm.io/gorm/schema\"\n\t\"gorm.io/gorm/utils\"\n)\n\nfunc initializeCallbacks(db *DB) *callbacks {\n\treturn &callbacks{\n\t\tprocessors: map[string]*processor{\n\t\t\t\"create\": {db: db},\n\t\t\t\"query\":  {db: db},\n\t\t\t\"update\": {db: db},\n\t\t\t\"delete\": {db: db},\n\t\t\t\"row\":    {db: db},\n\t\t\t\"raw\":    {db: db},\n\t\t},\n\t}\n}\n\n// callbacks gorm callbacks manager\ntype callbacks struct {\n\tprocessors map[string]*processor\n}\n\ntype processor struct {\n\tdb        *DB\n\tClauses   []string\n\tfns       []func(*DB)\n\tcallbacks []*callback\n}\n\ntype callback struct {\n\tname      string\n\tbefore    string\n\tafter     string\n\tremove    bool\n\treplace   bool\n\tmatch     func(*DB) bool\n\thandler   func(*DB)\n\tprocessor *processor\n}\n\nfunc (cs *callbacks) Create() *processor {\n\treturn cs.processors[\"create\"]\n}\n\nfunc (cs *callbacks) Query() *processor {\n\treturn cs.processors[\"query\"]\n}\n\nfunc (cs *callbacks) Update() *processor {\n\treturn cs.processors[\"update\"]\n}\n\nfunc (cs *callbacks) Delete() *processor {\n\treturn cs.processors[\"delete\"]\n}\n\nfunc (cs *callbacks) Row() *processor {\n\treturn cs.processors[\"row\"]\n}\n\nfunc (cs *callbacks) Raw() *processor {\n\treturn cs.processors[\"raw\"]\n}\n\nfunc (p *processor) Execute(db *DB) *DB {\n\t// call scopes\n\tfor len(db.Statement.scopes) > 0 {\n\t\tdb = db.executeScopes()\n\t}\n\n\tvar (\n\t\tcurTime           = time.Now()\n\t\tstmt              = db.Statement\n\t\tresetBuildClauses bool\n\t)\n\n\tif len(stmt.BuildClauses) == 0 {\n\t\tstmt.BuildClauses = p.Clauses\n\t\tresetBuildClauses = true\n\t}\n\n\tif optimizer, ok := db.Statement.Dest.(StatementModifier); ok {\n\t\toptimizer.ModifyStatement(stmt)\n\t}\n\n\t// assign model values\n\tif stmt.Model == nil {\n\t\tstmt.Model = stmt.Dest\n\t} else if stmt.Dest == nil {\n\t\tstmt.Dest = stmt.Model\n\t}\n\n\t// parse model values\n\tif stmt.Model != nil {\n\t\tif err := stmt.Parse(stmt.Model); err != nil && (!errors.Is(err, schema.ErrUnsupportedDataType) || (stmt.Table == \"\" && stmt.TableExpr == nil && stmt.SQL.Len() == 0)) {\n\t\t\tif errors.Is(err, schema.ErrUnsupportedDataType) && stmt.Table == \"\" && stmt.TableExpr == nil {\n\t\t\t\tdb.AddError(fmt.Errorf(\"%w: Table not set, please set it like: db.Model(&user) or db.Table(\\\"users\\\")\", err))\n\t\t\t} else {\n\t\t\t\tdb.AddError(err)\n\t\t\t}\n\t\t}\n\t}\n\n\t// assign stmt.ReflectValue\n\tif stmt.Dest != nil {\n\t\tstmt.ReflectValue = reflect.ValueOf(stmt.Dest)\n\t\tfor stmt.ReflectValue.Kind() == reflect.Ptr {\n\t\t\tif stmt.ReflectValue.IsNil() && stmt.ReflectValue.CanAddr() {\n\t\t\t\tstmt.ReflectValue.Set(reflect.New(stmt.ReflectValue.Type().Elem()))\n\t\t\t}\n\n\t\t\tstmt.ReflectValue = stmt.ReflectValue.Elem()\n\t\t}\n\t\tif !stmt.ReflectValue.IsValid() {\n\t\t\tdb.AddError(ErrInvalidValue)\n\t\t}\n\t}\n\n\tfor _, f := range p.fns {\n\t\tf(db)\n\t}\n\n\tif stmt.SQL.Len() > 0 {\n\t\tdb.Logger.Trace(stmt.Context, curTime, func() (string, int64) {\n\t\t\tsql, vars := stmt.SQL.String(), stmt.Vars\n\t\t\tif filter, ok := db.Logger.(ParamsFilter); ok {\n\t\t\t\tsql, vars = filter.ParamsFilter(stmt.Context, stmt.SQL.String(), stmt.Vars...)\n\t\t\t}\n\t\t\treturn db.Dialector.Explain(sql, vars...), db.RowsAffected\n\t\t}, db.Error)\n\t}\n\n\tif !stmt.DB.DryRun {\n\t\tstmt.SQL.Reset()\n\t\tstmt.Vars = nil\n\t}\n\n\tif resetBuildClauses {\n\t\tstmt.BuildClauses = nil\n\t}\n\n\treturn db\n}\n\nfunc (p *processor) Get(name string) func(*DB) {\n\tfor i := len(p.callbacks) - 1; i >= 0; i-- {\n\t\tif v := p.callbacks[i]; v.name == name && !v.remove {\n\t\t\treturn v.handler\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *processor) Before(name string) *callback {\n\treturn &callback{before: name, processor: p}\n}\n\nfunc (p *processor) After(name string) *callback {\n\treturn &callback{after: name, processor: p}\n}\n\nfunc (p *processor) Match(fc func(*DB) bool) *callback {\n\treturn &callback{match: fc, processor: p}\n}\n\nfunc (p *processor) Register(name string, fn func(*DB)) error {\n\treturn (&callback{processor: p}).Register(name, fn)\n}\n\nfunc (p *processor) Remove(name string) error {\n\treturn (&callback{processor: p}).Remove(name)\n}\n\nfunc (p *processor) Replace(name string, fn func(*DB)) error {\n\treturn (&callback{processor: p}).Replace(name, fn)\n}\n\nfunc (p *processor) compile() (err error) {\n\tvar callbacks []*callback\n\tremovedMap := map[string]bool{}\n\tfor _, callback := range p.callbacks {\n\t\tif callback.match == nil || callback.match(p.db) {\n\t\t\tcallbacks = append(callbacks, callback)\n\t\t}\n\t\tif callback.remove {\n\t\t\tremovedMap[callback.name] = true\n\t\t}\n\t}\n\n\tif len(removedMap) > 0 {\n\t\tcallbacks = removeCallbacks(callbacks, removedMap)\n\t}\n\tp.callbacks = callbacks\n\n\tif p.fns, err = sortCallbacks(p.callbacks); err != nil {\n\t\tp.db.Logger.Error(context.Background(), \"Got error when compile callbacks, got %v\", err)\n\t}\n\treturn\n}\n\nfunc (c *callback) Before(name string) *callback {\n\tc.before = name\n\treturn c\n}\n\nfunc (c *callback) After(name string) *callback {\n\tc.after = name\n\treturn c\n}\n\nfunc (c *callback) Register(name string, fn func(*DB)) error {\n\tc.name = name\n\tc.handler = fn\n\tc.processor.callbacks = append(c.processor.callbacks, c)\n\treturn c.processor.compile()\n}\n\nfunc (c *callback) Remove(name string) error {\n\tc.processor.db.Logger.Warn(context.Background(), \"removing callback `%s` from %s\\n\", name, utils.FileWithLineNum())\n\tc.name = name\n\tc.remove = true\n\tc.processor.callbacks = append(c.processor.callbacks, c)\n\treturn c.processor.compile()\n}\n\nfunc (c *callback) Replace(name string, fn func(*DB)) error {\n\tc.processor.db.Logger.Info(context.Background(), \"replacing callback `%s` from %s\\n\", name, utils.FileWithLineNum())\n\tc.name = name\n\tc.handler = fn\n\tc.replace = true\n\tc.processor.callbacks = append(c.processor.callbacks, c)\n\treturn c.processor.compile()\n}\n\n// getRIndex get right index from string slice\nfunc getRIndex(strs []string, str string) int {\n\tfor i := len(strs) - 1; i >= 0; i-- {\n\t\tif strs[i] == str {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc sortCallbacks(cs []*callback) (fns []func(*DB), err error) {\n\tvar (\n\t\tnames, sorted []string\n\t\tsortCallback  func(*callback) error\n\t)\n\tsort.SliceStable(cs, func(i, j int) bool {\n\t\tif cs[j].before == \"*\" && cs[i].before != \"*\" {\n\t\t\treturn true\n\t\t}\n\t\tif cs[j].after == \"*\" && cs[i].after != \"*\" {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\n\tfor _, c := range cs {\n\t\t// show warning message the callback name already exists\n\t\tif idx := getRIndex(names, c.name); idx > -1 && !c.replace && !c.remove && !cs[idx].remove {\n\t\t\tc.processor.db.Logger.Warn(context.Background(), \"duplicated callback `%s` from %s\\n\", c.name, utils.FileWithLineNum())\n\t\t}\n\t\tnames = append(names, c.name)\n\t}\n\n\tsortCallback = func(c *callback) error {\n\t\tif c.before != \"\" { // if defined before callback\n\t\t\tif c.before == \"*\" && len(sorted) > 0 {\n\t\t\t\tif curIdx := getRIndex(sorted, c.name); curIdx == -1 {\n\t\t\t\t\tsorted = append([]string{c.name}, sorted...)\n\t\t\t\t}\n\t\t\t} else if sortedIdx := getRIndex(sorted, c.before); sortedIdx != -1 {\n\t\t\t\tif curIdx := getRIndex(sorted, c.name); curIdx == -1 {\n\t\t\t\t\t// if before callback already sorted, append current callback just after it\n\t\t\t\t\tsorted = append(sorted[:sortedIdx], append([]string{c.name}, sorted[sortedIdx:]...)...)\n\t\t\t\t} else if curIdx > sortedIdx {\n\t\t\t\t\treturn fmt.Errorf(\"conflicting callback %s with before %s\", c.name, c.before)\n\t\t\t\t}\n\t\t\t} else if idx := getRIndex(names, c.before); idx != -1 {\n\t\t\t\t// if before callback exists\n\t\t\t\tcs[idx].after = c.name\n\t\t\t}\n\t\t}\n\n\t\tif c.after != \"\" { // if defined after callback\n\t\t\tif c.after == \"*\" && len(sorted) > 0 {\n\t\t\t\tif curIdx := getRIndex(sorted, c.name); curIdx == -1 {\n\t\t\t\t\tsorted = append(sorted, c.name)\n\t\t\t\t}\n\t\t\t} else if sortedIdx := getRIndex(sorted, c.after); sortedIdx != -1 {\n\t\t\t\tif curIdx := getRIndex(sorted, c.name); curIdx == -1 {\n\t\t\t\t\t// if after callback sorted, append current callback to last\n\t\t\t\t\tsorted = append(sorted, c.name)\n\t\t\t\t} else if curIdx < sortedIdx {\n\t\t\t\t\treturn fmt.Errorf(\"conflicting callback %s with before %s\", c.name, c.after)\n\t\t\t\t}\n\t\t\t} else if idx := getRIndex(names, c.after); idx != -1 {\n\t\t\t\t// if after callback exists but haven't sorted\n\t\t\t\t// set after callback's before callback to current callback\n\t\t\t\tafter := cs[idx]\n\n\t\t\t\tif after.before == \"\" {\n\t\t\t\t\tafter.before = c.name\n\t\t\t\t}\n\n\t\t\t\tif err := sortCallback(after); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tif err := sortCallback(c); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if current callback haven't been sorted, append it to last\n\t\tif getRIndex(sorted, c.name) == -1 {\n\t\t\tsorted = append(sorted, c.name)\n\t\t}\n\n\t\treturn nil\n\t}\n\n\tfor _, c := range cs {\n\t\tif err = sortCallback(c); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tfor _, name := range sorted {\n\t\tif idx := getRIndex(names, name); !cs[idx].remove {\n\t\t\tfns = append(fns, cs[idx].handler)\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc removeCallbacks(cs []*callback, nameMap map[string]bool) []*callback {\n\tcallbacks := make([]*callback, 0, len(cs))\n\tfor _, callback := range cs {\n\t\tif nameMap[callback.name] {\n\t\t\tcontinue\n\t\t}\n\t\tcallbacks = append(callbacks, callback)\n\t}\n\treturn callbacks\n}\n"
        },
        {
          "name": "callbacks",
          "type": "tree",
          "content": null
        },
        {
          "name": "chainable_api.go",
          "type": "blob",
          "size": 14.7802734375,
          "content": "package gorm\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"gorm.io/gorm/clause\"\n\t\"gorm.io/gorm/utils\"\n)\n\n// Model specify the model you would like to run db operations\n//\n//\t// update all users's name to `hello`\n//\tdb.Model(&User{}).Update(\"name\", \"hello\")\n//\t// if user's primary key is non-blank, will use it as condition, then will only update that user's name to `hello`\n//\tdb.Model(&user).Update(\"name\", \"hello\")\nfunc (db *DB) Model(value interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.Model = value\n\treturn\n}\n\n// Clauses Add clauses\n//\n// This supports both standard clauses (clause.OrderBy, clause.Limit, clause.Where) and more\n// advanced techniques like specifying lock strength and optimizer hints. See the\n// [docs] for more depth.\n//\n//\t// add a simple limit clause\n//\tdb.Clauses(clause.Limit{Limit: 1}).Find(&User{})\n//\t// tell the optimizer to use the `idx_user_name` index\n//\tdb.Clauses(hints.UseIndex(\"idx_user_name\")).Find(&User{})\n//\t// specify the lock strength to UPDATE\n//\tdb.Clauses(clause.Locking{Strength: \"UPDATE\"}).Find(&users)\n//\n// [docs]: https://gorm.io/docs/sql_builder.html#Clauses\nfunc (db *DB) Clauses(conds ...clause.Expression) (tx *DB) {\n\ttx = db.getInstance()\n\tvar whereConds []interface{}\n\n\tfor _, cond := range conds {\n\t\tif c, ok := cond.(clause.Interface); ok {\n\t\t\ttx.Statement.AddClause(c)\n\t\t} else if optimizer, ok := cond.(StatementModifier); ok {\n\t\t\toptimizer.ModifyStatement(tx.Statement)\n\t\t} else {\n\t\t\twhereConds = append(whereConds, cond)\n\t\t}\n\t}\n\n\tif len(whereConds) > 0 {\n\t\ttx.Statement.AddClause(clause.Where{Exprs: tx.Statement.BuildCondition(whereConds[0], whereConds[1:]...)})\n\t}\n\treturn\n}\n\nvar tableRegexp = regexp.MustCompile(`(?i)(?:.+? AS (\\w+)\\s*(?:$|,)|^\\w+\\s+(\\w+)$)`)\n\n// Table specify the table you would like to run db operations\n//\n//\t// Get a user\n//\tdb.Table(\"users\").Take(&result)\nfunc (db *DB) Table(name string, args ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\tif strings.Contains(name, \" \") || strings.Contains(name, \"`\") || len(args) > 0 {\n\t\ttx.Statement.TableExpr = &clause.Expr{SQL: name, Vars: args}\n\t\tif results := tableRegexp.FindStringSubmatch(name); len(results) == 3 {\n\t\t\tif results[1] != \"\" {\n\t\t\t\ttx.Statement.Table = results[1]\n\t\t\t} else {\n\t\t\t\ttx.Statement.Table = results[2]\n\t\t\t}\n\t\t}\n\t} else if tables := strings.Split(name, \".\"); len(tables) == 2 {\n\t\ttx.Statement.TableExpr = &clause.Expr{SQL: tx.Statement.Quote(name)}\n\t\ttx.Statement.Table = tables[1]\n\t} else if name != \"\" {\n\t\ttx.Statement.TableExpr = &clause.Expr{SQL: tx.Statement.Quote(name)}\n\t\ttx.Statement.Table = name\n\t} else {\n\t\ttx.Statement.TableExpr = nil\n\t\ttx.Statement.Table = \"\"\n\t}\n\treturn\n}\n\n// Distinct specify distinct fields that you want querying\n//\n//\t// Select distinct names of users\n//\tdb.Distinct(\"name\").Find(&results)\n//\t// Select distinct name/age pairs from users\n//\tdb.Distinct(\"name\", \"age\").Find(&results)\nfunc (db *DB) Distinct(args ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.Distinct = true\n\tif len(args) > 0 {\n\t\ttx = tx.Select(args[0], args[1:]...)\n\t}\n\treturn\n}\n\n// Select specify fields that you want when querying, creating, updating\n//\n// Use Select when you only want a subset of the fields. By default, GORM will select all fields.\n// Select accepts both string arguments and arrays.\n//\n//\t// Select name and age of user using multiple arguments\n//\tdb.Select(\"name\", \"age\").Find(&users)\n//\t// Select name and age of user using an array\n//\tdb.Select([]string{\"name\", \"age\"}).Find(&users)\nfunc (db *DB) Select(query interface{}, args ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\n\tswitch v := query.(type) {\n\tcase []string:\n\t\ttx.Statement.Selects = v\n\n\t\tfor _, arg := range args {\n\t\t\tswitch arg := arg.(type) {\n\t\t\tcase string:\n\t\t\t\ttx.Statement.Selects = append(tx.Statement.Selects, arg)\n\t\t\tcase []string:\n\t\t\t\ttx.Statement.Selects = append(tx.Statement.Selects, arg...)\n\t\t\tdefault:\n\t\t\t\ttx.AddError(fmt.Errorf(\"unsupported select args %v %v\", query, args))\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif clause, ok := tx.Statement.Clauses[\"SELECT\"]; ok {\n\t\t\tclause.Expression = nil\n\t\t\ttx.Statement.Clauses[\"SELECT\"] = clause\n\t\t}\n\tcase string:\n\t\tif strings.Count(v, \"?\") >= len(args) && len(args) > 0 {\n\t\t\ttx.Statement.AddClause(clause.Select{\n\t\t\t\tDistinct:   db.Statement.Distinct,\n\t\t\t\tExpression: clause.Expr{SQL: v, Vars: args},\n\t\t\t})\n\t\t} else if strings.Count(v, \"@\") > 0 && len(args) > 0 {\n\t\t\ttx.Statement.AddClause(clause.Select{\n\t\t\t\tDistinct:   db.Statement.Distinct,\n\t\t\t\tExpression: clause.NamedExpr{SQL: v, Vars: args},\n\t\t\t})\n\t\t} else {\n\t\t\ttx.Statement.Selects = []string{v}\n\n\t\t\tfor _, arg := range args {\n\t\t\t\tswitch arg := arg.(type) {\n\t\t\t\tcase string:\n\t\t\t\t\ttx.Statement.Selects = append(tx.Statement.Selects, arg)\n\t\t\t\tcase []string:\n\t\t\t\t\ttx.Statement.Selects = append(tx.Statement.Selects, arg...)\n\t\t\t\tdefault:\n\t\t\t\t\ttx.Statement.AddClause(clause.Select{\n\t\t\t\t\t\tDistinct:   db.Statement.Distinct,\n\t\t\t\t\t\tExpression: clause.Expr{SQL: v, Vars: args},\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif clause, ok := tx.Statement.Clauses[\"SELECT\"]; ok {\n\t\t\t\tclause.Expression = nil\n\t\t\t\ttx.Statement.Clauses[\"SELECT\"] = clause\n\t\t\t}\n\t\t}\n\tdefault:\n\t\ttx.AddError(fmt.Errorf(\"unsupported select args %v %v\", query, args))\n\t}\n\n\treturn\n}\n\n// Omit specify fields that you want to ignore when creating, updating and querying\nfunc (db *DB) Omit(columns ...string) (tx *DB) {\n\ttx = db.getInstance()\n\n\tif len(columns) == 1 && strings.ContainsRune(columns[0], ',') {\n\t\ttx.Statement.Omits = strings.FieldsFunc(columns[0], utils.IsValidDBNameChar)\n\t} else {\n\t\ttx.Statement.Omits = columns\n\t}\n\treturn\n}\n\n// MapColumns modify the column names in the query results to facilitate align to the corresponding structural fields\nfunc (db *DB) MapColumns(m map[string]string) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.ColumnMapping = m\n\treturn\n}\n\n// Where add conditions\n//\n// See the [docs] for details on the various formats that where clauses can take. By default, where clauses chain with AND.\n//\n//\t// Find the first user with name jinzhu\n//\tdb.Where(\"name = ?\", \"jinzhu\").First(&user)\n//\t// Find the first user with name jinzhu and age 20\n//\tdb.Where(&User{Name: \"jinzhu\", Age: 20}).First(&user)\n//\t// Find the first user with name jinzhu and age not equal to 20\n//\tdb.Where(\"name = ?\", \"jinzhu\").Where(\"age <> ?\", \"20\").First(&user)\n//\n// [docs]: https://gorm.io/docs/query.html#Conditions\nfunc (db *DB) Where(query interface{}, args ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\tif conds := tx.Statement.BuildCondition(query, args...); len(conds) > 0 {\n\t\ttx.Statement.AddClause(clause.Where{Exprs: conds})\n\t}\n\treturn\n}\n\n// Not add NOT conditions\n//\n// Not works similarly to where, and has the same syntax.\n//\n//\t// Find the first user with name not equal to jinzhu\n//\tdb.Not(\"name = ?\", \"jinzhu\").First(&user)\nfunc (db *DB) Not(query interface{}, args ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\tif conds := tx.Statement.BuildCondition(query, args...); len(conds) > 0 {\n\t\ttx.Statement.AddClause(clause.Where{Exprs: []clause.Expression{clause.Not(conds...)}})\n\t}\n\treturn\n}\n\n// Or add OR conditions\n//\n// Or is used to chain together queries with an OR.\n//\n//\t// Find the first user with name equal to jinzhu or john\n//\tdb.Where(\"name = ?\", \"jinzhu\").Or(\"name = ?\", \"john\").First(&user)\nfunc (db *DB) Or(query interface{}, args ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\tif conds := tx.Statement.BuildCondition(query, args...); len(conds) > 0 {\n\t\ttx.Statement.AddClause(clause.Where{Exprs: []clause.Expression{clause.Or(clause.And(conds...))}})\n\t}\n\treturn\n}\n\n// Joins specify Joins conditions\n//\n//\tdb.Joins(\"Account\").Find(&user)\n//\tdb.Joins(\"JOIN emails ON emails.user_id = users.id AND emails.email = ?\", \"jinzhu@example.org\").Find(&user)\n//\tdb.Joins(\"Account\", DB.Select(\"id\").Where(\"user_id = users.id AND name = ?\", \"someName\").Model(&Account{}))\nfunc (db *DB) Joins(query string, args ...interface{}) (tx *DB) {\n\treturn joins(db, clause.LeftJoin, query, args...)\n}\n\n// InnerJoins specify inner joins conditions\n// db.InnerJoins(\"Account\").Find(&user)\nfunc (db *DB) InnerJoins(query string, args ...interface{}) (tx *DB) {\n\treturn joins(db, clause.InnerJoin, query, args...)\n}\n\nfunc joins(db *DB, joinType clause.JoinType, query string, args ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\n\tif len(args) == 1 {\n\t\tif db, ok := args[0].(*DB); ok {\n\t\t\tj := join{\n\t\t\t\tName: query, Conds: args, Selects: db.Statement.Selects,\n\t\t\t\tOmits: db.Statement.Omits, JoinType: joinType,\n\t\t\t}\n\t\t\tif where, ok := db.Statement.Clauses[\"WHERE\"].Expression.(clause.Where); ok {\n\t\t\t\tj.On = &where\n\t\t\t}\n\t\t\ttx.Statement.Joins = append(tx.Statement.Joins, j)\n\t\t\treturn\n\t\t}\n\t}\n\n\ttx.Statement.Joins = append(tx.Statement.Joins, join{Name: query, Conds: args, JoinType: joinType})\n\treturn\n}\n\n// Group specify the group method on the find\n//\n//\t// Select the sum age of users with given names\n//\tdb.Model(&User{}).Select(\"name, sum(age) as total\").Group(\"name\").Find(&results)\nfunc (db *DB) Group(name string) (tx *DB) {\n\ttx = db.getInstance()\n\n\tfields := strings.FieldsFunc(name, utils.IsValidDBNameChar)\n\ttx.Statement.AddClause(clause.GroupBy{\n\t\tColumns: []clause.Column{{Name: name, Raw: len(fields) != 1}},\n\t})\n\treturn\n}\n\n// Having specify HAVING conditions for GROUP BY\n//\n//\t// Select the sum age of users with name jinzhu\n//\tdb.Model(&User{}).Select(\"name, sum(age) as total\").Group(\"name\").Having(\"name = ?\", \"jinzhu\").Find(&result)\nfunc (db *DB) Having(query interface{}, args ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.AddClause(clause.GroupBy{\n\t\tHaving: tx.Statement.BuildCondition(query, args...),\n\t})\n\treturn\n}\n\n// Order specify order when retrieving records from database\n//\n//\tdb.Order(\"name DESC\")\n//\tdb.Order(clause.OrderByColumn{Column: clause.Column{Name: \"name\"}, Desc: true})\n//\tdb.Order(clause.OrderBy{Columns: []clause.OrderByColumn{\n//\t\t{Column: clause.Column{Name: \"name\"}, Desc: true},\n//\t\t{Column: clause.Column{Name: \"age\"}, Desc: true},\n//\t}})\nfunc (db *DB) Order(value interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\n\tswitch v := value.(type) {\n\tcase clause.OrderBy:\n\t\ttx.Statement.AddClause(v)\n\tcase clause.OrderByColumn:\n\t\ttx.Statement.AddClause(clause.OrderBy{\n\t\t\tColumns: []clause.OrderByColumn{v},\n\t\t})\n\tcase string:\n\t\tif v != \"\" {\n\t\t\ttx.Statement.AddClause(clause.OrderBy{\n\t\t\t\tColumns: []clause.OrderByColumn{{\n\t\t\t\t\tColumn: clause.Column{Name: v, Raw: true},\n\t\t\t\t}},\n\t\t\t})\n\t\t}\n\t}\n\treturn\n}\n\n// Limit specify the number of records to be retrieved\n//\n// Limit conditions can be cancelled by using `Limit(-1)`.\n//\n//\t// retrieve 3 users\n//\tdb.Limit(3).Find(&users)\n//\t// retrieve 3 users into users1, and all users into users2\n//\tdb.Limit(3).Find(&users1).Limit(-1).Find(&users2)\nfunc (db *DB) Limit(limit int) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.AddClause(clause.Limit{Limit: &limit})\n\treturn\n}\n\n// Offset specify the number of records to skip before starting to return the records\n//\n// Offset conditions can be cancelled by using `Offset(-1)`.\n//\n//\t// select the third user\n//\tdb.Offset(2).First(&user)\n//\t// select the first user by cancelling an earlier chained offset\n//\tdb.Offset(5).Offset(-1).First(&user)\nfunc (db *DB) Offset(offset int) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.AddClause(clause.Limit{Offset: offset})\n\treturn\n}\n\n// Scopes pass current database connection to arguments `func(DB) DB`, which could be used to add conditions dynamically\n//\n//\tfunc AmountGreaterThan1000(db *gorm.DB) *gorm.DB {\n//\t    return db.Where(\"amount > ?\", 1000)\n//\t}\n//\n//\tfunc OrderStatus(status []string) func (db *gorm.DB) *gorm.DB {\n//\t    return func (db *gorm.DB) *gorm.DB {\n//\t        return db.Scopes(AmountGreaterThan1000).Where(\"status in (?)\", status)\n//\t    }\n//\t}\n//\n//\tdb.Scopes(AmountGreaterThan1000, OrderStatus([]string{\"paid\", \"shipped\"})).Find(&orders)\nfunc (db *DB) Scopes(funcs ...func(*DB) *DB) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.scopes = append(tx.Statement.scopes, funcs...)\n\treturn tx\n}\n\nfunc (db *DB) executeScopes() (tx *DB) {\n\tscopes := db.Statement.scopes\n\tdb.Statement.scopes = nil\n\tfor _, scope := range scopes {\n\t\tdb = scope(db)\n\t}\n\treturn db\n}\n\n// Preload preload associations with given conditions\n//\n//\t// get all users, and preload all non-cancelled orders\n//\tdb.Preload(\"Orders\", \"state NOT IN (?)\", \"cancelled\").Find(&users)\nfunc (db *DB) Preload(query string, args ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\tif tx.Statement.Preloads == nil {\n\t\ttx.Statement.Preloads = map[string][]interface{}{}\n\t}\n\ttx.Statement.Preloads[query] = args\n\treturn\n}\n\n// Attrs provide attributes used in [FirstOrCreate] or [FirstOrInit]\n//\n// Attrs only adds attributes if the record is not found.\n//\n//\t// assign an email if the record is not found\n//\tdb.Where(User{Name: \"non_existing\"}).Attrs(User{Email: \"fake@fake.org\"}).FirstOrInit(&user)\n//\t// user -> User{Name: \"non_existing\", Email: \"fake@fake.org\"}\n//\n//\t// assign an email if the record is not found, otherwise ignore provided email\n//\tdb.Where(User{Name: \"jinzhu\"}).Attrs(User{Email: \"fake@fake.org\"}).FirstOrInit(&user)\n//\t// user -> User{Name: \"jinzhu\", Age: 20}\n//\n// [FirstOrCreate]: https://gorm.io/docs/advanced_query.html#FirstOrCreate\n// [FirstOrInit]: https://gorm.io/docs/advanced_query.html#FirstOrInit\nfunc (db *DB) Attrs(attrs ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.attrs = attrs\n\treturn\n}\n\n// Assign provide attributes used in [FirstOrCreate] or [FirstOrInit]\n//\n// Assign adds attributes even if the record is found. If using FirstOrCreate, this means that\n// records will be updated even if they are found.\n//\n//\t// assign an email regardless of if the record is not found\n//\tdb.Where(User{Name: \"non_existing\"}).Assign(User{Email: \"fake@fake.org\"}).FirstOrInit(&user)\n//\t// user -> User{Name: \"non_existing\", Email: \"fake@fake.org\"}\n//\n//\t// assign email regardless of if record is found\n//\tdb.Where(User{Name: \"jinzhu\"}).Assign(User{Email: \"fake@fake.org\"}).FirstOrInit(&user)\n//\t// user -> User{Name: \"jinzhu\", Age: 20, Email: \"fake@fake.org\"}\n//\n// [FirstOrCreate]: https://gorm.io/docs/advanced_query.html#FirstOrCreate\n// [FirstOrInit]: https://gorm.io/docs/advanced_query.html#FirstOrInit\nfunc (db *DB) Assign(attrs ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.assigns = attrs\n\treturn\n}\n\n// Unscoped disables the global scope of soft deletion in a query.\n// By default, GORM uses soft deletion, marking records as \"deleted\"\n// by setting a timestamp on a specific field (e.g., `deleted_at`).\n// Unscoped allows queries to include records marked as deleted,\n// overriding the soft deletion behavior.\n// Example:\n//    var users []User\n//    db.Unscoped().Find(&users)\n//    // Retrieves all users, including deleted ones.\nfunc (db *DB) Unscoped() (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.Unscoped = true\n\treturn\n}\n\nfunc (db *DB) Raw(sql string, values ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.SQL = strings.Builder{}\n\n\tif strings.Contains(sql, \"@\") {\n\t\tclause.NamedExpr{SQL: sql, Vars: values}.Build(tx.Statement)\n\t} else {\n\t\tclause.Expr{SQL: sql, Vars: values}.Build(tx.Statement)\n\t}\n\treturn\n}\n"
        },
        {
          "name": "clause",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 2.501953125,
          "content": "package gorm\n\nimport (\n\t\"errors\"\n\n\t\"gorm.io/gorm/logger\"\n)\n\nvar (\n\t// ErrRecordNotFound record not found error\n\tErrRecordNotFound = logger.ErrRecordNotFound\n\t// ErrInvalidTransaction invalid transaction when you are trying to `Commit` or `Rollback`\n\tErrInvalidTransaction = errors.New(\"invalid transaction\")\n\t// ErrNotImplemented not implemented\n\tErrNotImplemented = errors.New(\"not implemented\")\n\t// ErrMissingWhereClause missing where clause\n\tErrMissingWhereClause = errors.New(\"WHERE conditions required\")\n\t// ErrUnsupportedRelation unsupported relations\n\tErrUnsupportedRelation = errors.New(\"unsupported relations\")\n\t// ErrPrimaryKeyRequired primary keys required\n\tErrPrimaryKeyRequired = errors.New(\"primary key required\")\n\t// ErrModelValueRequired model value required\n\tErrModelValueRequired = errors.New(\"model value required\")\n\t// ErrModelAccessibleFieldsRequired model accessible fields required\n\tErrModelAccessibleFieldsRequired = errors.New(\"model accessible fields required\")\n\t// ErrSubQueryRequired sub query required\n\tErrSubQueryRequired = errors.New(\"sub query required\")\n\t// ErrInvalidData unsupported data\n\tErrInvalidData = errors.New(\"unsupported data\")\n\t// ErrUnsupportedDriver unsupported driver\n\tErrUnsupportedDriver = errors.New(\"unsupported driver\")\n\t// ErrRegistered registered\n\tErrRegistered = errors.New(\"registered\")\n\t// ErrInvalidField invalid field\n\tErrInvalidField = errors.New(\"invalid field\")\n\t// ErrEmptySlice empty slice found\n\tErrEmptySlice = errors.New(\"empty slice found\")\n\t// ErrDryRunModeUnsupported dry run mode unsupported\n\tErrDryRunModeUnsupported = errors.New(\"dry run mode unsupported\")\n\t// ErrInvalidDB invalid db\n\tErrInvalidDB = errors.New(\"invalid db\")\n\t// ErrInvalidValue invalid value\n\tErrInvalidValue = errors.New(\"invalid value, should be pointer to struct or slice\")\n\t// ErrInvalidValueOfLength invalid values do not match length\n\tErrInvalidValueOfLength = errors.New(\"invalid association values, length doesn't match\")\n\t// ErrPreloadNotAllowed preload is not allowed when count is used\n\tErrPreloadNotAllowed = errors.New(\"preload is not allowed when count is used\")\n\t// ErrDuplicatedKey occurs when there is a unique key constraint violation\n\tErrDuplicatedKey = errors.New(\"duplicated key not allowed\")\n\t// ErrForeignKeyViolated occurs when there is a foreign key constraint violation\n\tErrForeignKeyViolated = errors.New(\"violates foreign key constraint\")\n\t// ErrCheckConstraintViolated occurs when there is a check constraint violation\n\tErrCheckConstraintViolated = errors.New(\"violates check constraint\")\n)\n"
        },
        {
          "name": "finisher_api.go",
          "type": "blob",
          "size": 22.7548828125,
          "content": "package gorm\n\nimport (\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash/maphash\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"gorm.io/gorm/clause\"\n\t\"gorm.io/gorm/logger\"\n\t\"gorm.io/gorm/schema\"\n\t\"gorm.io/gorm/utils\"\n)\n\n// Create inserts value, returning the inserted data's primary key in value's id\nfunc (db *DB) Create(value interface{}) (tx *DB) {\n\tif db.CreateBatchSize > 0 {\n\t\treturn db.CreateInBatches(value, db.CreateBatchSize)\n\t}\n\n\ttx = db.getInstance()\n\ttx.Statement.Dest = value\n\treturn tx.callbacks.Create().Execute(tx)\n}\n\n// CreateInBatches inserts value in batches of batchSize\nfunc (db *DB) CreateInBatches(value interface{}, batchSize int) (tx *DB) {\n\treflectValue := reflect.Indirect(reflect.ValueOf(value))\n\n\tswitch reflectValue.Kind() {\n\tcase reflect.Slice, reflect.Array:\n\t\tvar rowsAffected int64\n\t\ttx = db.getInstance()\n\n\t\t// the reflection length judgment of the optimized value\n\t\treflectLen := reflectValue.Len()\n\n\t\tcallFc := func(tx *DB) error {\n\t\t\tfor i := 0; i < reflectLen; i += batchSize {\n\t\t\t\tends := i + batchSize\n\t\t\t\tif ends > reflectLen {\n\t\t\t\t\tends = reflectLen\n\t\t\t\t}\n\n\t\t\t\tsubtx := tx.getInstance()\n\t\t\t\tsubtx.Statement.Dest = reflectValue.Slice(i, ends).Interface()\n\t\t\t\tsubtx.callbacks.Create().Execute(subtx)\n\t\t\t\tif subtx.Error != nil {\n\t\t\t\t\treturn subtx.Error\n\t\t\t\t}\n\t\t\t\trowsAffected += subtx.RowsAffected\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tif tx.SkipDefaultTransaction || reflectLen <= batchSize {\n\t\t\ttx.AddError(callFc(tx.Session(&Session{})))\n\t\t} else {\n\t\t\ttx.AddError(tx.Transaction(callFc))\n\t\t}\n\n\t\ttx.RowsAffected = rowsAffected\n\tdefault:\n\t\ttx = db.getInstance()\n\t\ttx.Statement.Dest = value\n\t\ttx = tx.callbacks.Create().Execute(tx)\n\t}\n\treturn\n}\n\n// Save updates value in database. If value doesn't contain a matching primary key, value is inserted.\nfunc (db *DB) Save(value interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.Dest = value\n\n\treflectValue := reflect.Indirect(reflect.ValueOf(value))\n\tfor reflectValue.Kind() == reflect.Ptr || reflectValue.Kind() == reflect.Interface {\n\t\treflectValue = reflect.Indirect(reflectValue)\n\t}\n\n\tswitch reflectValue.Kind() {\n\tcase reflect.Slice, reflect.Array:\n\t\tif _, ok := tx.Statement.Clauses[\"ON CONFLICT\"]; !ok {\n\t\t\ttx = tx.Clauses(clause.OnConflict{UpdateAll: true})\n\t\t}\n\t\ttx = tx.callbacks.Create().Execute(tx.Set(\"gorm:update_track_time\", true))\n\tcase reflect.Struct:\n\t\tif err := tx.Statement.Parse(value); err == nil && tx.Statement.Schema != nil {\n\t\t\tfor _, pf := range tx.Statement.Schema.PrimaryFields {\n\t\t\t\tif _, isZero := pf.ValueOf(tx.Statement.Context, reflectValue); isZero {\n\t\t\t\t\treturn tx.callbacks.Create().Execute(tx)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfallthrough\n\tdefault:\n\t\tselectedUpdate := len(tx.Statement.Selects) != 0\n\t\t// when updating, use all fields including those zero-value fields\n\t\tif !selectedUpdate {\n\t\t\ttx.Statement.Selects = append(tx.Statement.Selects, \"*\")\n\t\t}\n\n\t\tupdateTx := tx.callbacks.Update().Execute(tx.Session(&Session{Initialized: true}))\n\n\t\tif updateTx.Error == nil && updateTx.RowsAffected == 0 && !updateTx.DryRun && !selectedUpdate {\n\t\t\treturn tx.Session(&Session{SkipHooks: true}).Clauses(clause.OnConflict{UpdateAll: true}).Create(value)\n\t\t}\n\n\t\treturn updateTx\n\t}\n\n\treturn\n}\n\n// First finds the first record ordered by primary key, matching given conditions conds\nfunc (db *DB) First(dest interface{}, conds ...interface{}) (tx *DB) {\n\ttx = db.Limit(1).Order(clause.OrderByColumn{\n\t\tColumn: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey},\n\t})\n\tif len(conds) > 0 {\n\t\tif exprs := tx.Statement.BuildCondition(conds[0], conds[1:]...); len(exprs) > 0 {\n\t\t\ttx.Statement.AddClause(clause.Where{Exprs: exprs})\n\t\t}\n\t}\n\ttx.Statement.RaiseErrorOnNotFound = true\n\ttx.Statement.Dest = dest\n\treturn tx.callbacks.Query().Execute(tx)\n}\n\n// Take finds the first record returned by the database in no specified order, matching given conditions conds\nfunc (db *DB) Take(dest interface{}, conds ...interface{}) (tx *DB) {\n\ttx = db.Limit(1)\n\tif len(conds) > 0 {\n\t\tif exprs := tx.Statement.BuildCondition(conds[0], conds[1:]...); len(exprs) > 0 {\n\t\t\ttx.Statement.AddClause(clause.Where{Exprs: exprs})\n\t\t}\n\t}\n\ttx.Statement.RaiseErrorOnNotFound = true\n\ttx.Statement.Dest = dest\n\treturn tx.callbacks.Query().Execute(tx)\n}\n\n// Last finds the last record ordered by primary key, matching given conditions conds\nfunc (db *DB) Last(dest interface{}, conds ...interface{}) (tx *DB) {\n\ttx = db.Limit(1).Order(clause.OrderByColumn{\n\t\tColumn: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey},\n\t\tDesc:   true,\n\t})\n\tif len(conds) > 0 {\n\t\tif exprs := tx.Statement.BuildCondition(conds[0], conds[1:]...); len(exprs) > 0 {\n\t\t\ttx.Statement.AddClause(clause.Where{Exprs: exprs})\n\t\t}\n\t}\n\ttx.Statement.RaiseErrorOnNotFound = true\n\ttx.Statement.Dest = dest\n\treturn tx.callbacks.Query().Execute(tx)\n}\n\n// Find finds all records matching given conditions conds\nfunc (db *DB) Find(dest interface{}, conds ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\tif len(conds) > 0 {\n\t\tif exprs := tx.Statement.BuildCondition(conds[0], conds[1:]...); len(exprs) > 0 {\n\t\t\ttx.Statement.AddClause(clause.Where{Exprs: exprs})\n\t\t}\n\t}\n\ttx.Statement.Dest = dest\n\treturn tx.callbacks.Query().Execute(tx)\n}\n\n// FindInBatches finds all records in batches of batchSize\nfunc (db *DB) FindInBatches(dest interface{}, batchSize int, fc func(tx *DB, batch int) error) *DB {\n\tvar (\n\t\ttx = db.Order(clause.OrderByColumn{\n\t\t\tColumn: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey},\n\t\t}).Session(&Session{})\n\t\tqueryDB      = tx\n\t\trowsAffected int64\n\t\tbatch        int\n\t)\n\n\t// user specified offset or limit\n\tvar totalSize int\n\tif c, ok := tx.Statement.Clauses[\"LIMIT\"]; ok {\n\t\tif limit, ok := c.Expression.(clause.Limit); ok {\n\t\t\tif limit.Limit != nil {\n\t\t\t\ttotalSize = *limit.Limit\n\t\t\t}\n\n\t\t\tif totalSize > 0 && batchSize > totalSize {\n\t\t\t\tbatchSize = totalSize\n\t\t\t}\n\n\t\t\t// reset to offset to 0 in next batch\n\t\t\ttx = tx.Offset(-1).Session(&Session{})\n\t\t}\n\t}\n\n\tfor {\n\t\tresult := queryDB.Limit(batchSize).Find(dest)\n\t\trowsAffected += result.RowsAffected\n\t\tbatch++\n\n\t\tif result.Error == nil && result.RowsAffected != 0 {\n\t\t\tfcTx := result.Session(&Session{NewDB: true})\n\t\t\tfcTx.RowsAffected = result.RowsAffected\n\t\t\ttx.AddError(fc(fcTx, batch))\n\t\t} else if result.Error != nil {\n\t\t\ttx.AddError(result.Error)\n\t\t}\n\n\t\tif tx.Error != nil || int(result.RowsAffected) < batchSize {\n\t\t\tbreak\n\t\t}\n\n\t\tif totalSize > 0 {\n\t\t\tif totalSize <= int(rowsAffected) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif totalSize/batchSize == batch {\n\t\t\t\tbatchSize = totalSize % batchSize\n\t\t\t}\n\t\t}\n\n\t\t// Optimize for-break\n\t\tresultsValue := reflect.Indirect(reflect.ValueOf(dest))\n\t\tif result.Statement.Schema.PrioritizedPrimaryField == nil {\n\t\t\ttx.AddError(ErrPrimaryKeyRequired)\n\t\t\tbreak\n\t\t}\n\n\t\tprimaryValue, zero := result.Statement.Schema.PrioritizedPrimaryField.ValueOf(tx.Statement.Context, resultsValue.Index(resultsValue.Len()-1))\n\t\tif zero {\n\t\t\ttx.AddError(ErrPrimaryKeyRequired)\n\t\t\tbreak\n\t\t}\n\t\tqueryDB = tx.Clauses(clause.Gt{Column: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey}, Value: primaryValue})\n\t}\n\n\ttx.RowsAffected = rowsAffected\n\treturn tx\n}\n\nfunc (db *DB) assignInterfacesToValue(values ...interface{}) {\n\tfor _, value := range values {\n\t\tswitch v := value.(type) {\n\t\tcase []clause.Expression:\n\t\t\tfor _, expr := range v {\n\t\t\t\tif eq, ok := expr.(clause.Eq); ok {\n\t\t\t\t\tswitch column := eq.Column.(type) {\n\t\t\t\t\tcase string:\n\t\t\t\t\t\tif field := db.Statement.Schema.LookUpField(column); field != nil {\n\t\t\t\t\t\t\tdb.AddError(field.Set(db.Statement.Context, db.Statement.ReflectValue, eq.Value))\n\t\t\t\t\t\t}\n\t\t\t\t\tcase clause.Column:\n\t\t\t\t\t\tif field := db.Statement.Schema.LookUpField(column.Name); field != nil {\n\t\t\t\t\t\t\tdb.AddError(field.Set(db.Statement.Context, db.Statement.ReflectValue, eq.Value))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if andCond, ok := expr.(clause.AndConditions); ok {\n\t\t\t\t\tdb.assignInterfacesToValue(andCond.Exprs)\n\t\t\t\t}\n\t\t\t}\n\t\tcase clause.Expression, map[string]string, map[interface{}]interface{}, map[string]interface{}:\n\t\t\tif exprs := db.Statement.BuildCondition(value); len(exprs) > 0 {\n\t\t\t\tdb.assignInterfacesToValue(exprs)\n\t\t\t}\n\t\tdefault:\n\t\t\tif s, err := schema.Parse(value, db.cacheStore, db.NamingStrategy); err == nil {\n\t\t\t\treflectValue := reflect.Indirect(reflect.ValueOf(value))\n\t\t\t\tswitch reflectValue.Kind() {\n\t\t\t\tcase reflect.Struct:\n\t\t\t\t\tfor _, f := range s.Fields {\n\t\t\t\t\t\tif f.Readable {\n\t\t\t\t\t\t\tif v, isZero := f.ValueOf(db.Statement.Context, reflectValue); !isZero {\n\t\t\t\t\t\t\t\tif field := db.Statement.Schema.LookUpField(f.Name); field != nil {\n\t\t\t\t\t\t\t\t\tdb.AddError(field.Set(db.Statement.Context, db.Statement.ReflectValue, v))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if len(values) > 0 {\n\t\t\t\tif exprs := db.Statement.BuildCondition(values[0], values[1:]...); len(exprs) > 0 {\n\t\t\t\t\tdb.assignInterfacesToValue(exprs)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// FirstOrInit finds the first matching record, otherwise if not found initializes a new instance with given conds.\n// Each conds must be a struct or map.\n//\n// FirstOrInit never modifies the database. It is often used with Assign and Attrs.\n//\n//\t// assign an email if the record is not found\n//\tdb.Where(User{Name: \"non_existing\"}).Attrs(User{Email: \"fake@fake.org\"}).FirstOrInit(&user)\n//\t// user -> User{Name: \"non_existing\", Email: \"fake@fake.org\"}\n//\n//\t// assign email regardless of if record is found\n//\tdb.Where(User{Name: \"jinzhu\"}).Assign(User{Email: \"fake@fake.org\"}).FirstOrInit(&user)\n//\t// user -> User{Name: \"jinzhu\", Age: 20, Email: \"fake@fake.org\"}\nfunc (db *DB) FirstOrInit(dest interface{}, conds ...interface{}) (tx *DB) {\n\tqueryTx := db.Limit(1).Order(clause.OrderByColumn{\n\t\tColumn: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey},\n\t})\n\n\tif tx = queryTx.Find(dest, conds...); tx.RowsAffected == 0 {\n\t\tif c, ok := tx.Statement.Clauses[\"WHERE\"]; ok {\n\t\t\tif where, ok := c.Expression.(clause.Where); ok {\n\t\t\t\ttx.assignInterfacesToValue(where.Exprs)\n\t\t\t}\n\t\t}\n\n\t\t// initialize with attrs, conds\n\t\tif len(tx.Statement.attrs) > 0 {\n\t\t\ttx.assignInterfacesToValue(tx.Statement.attrs...)\n\t\t}\n\t}\n\n\t// initialize with attrs, conds\n\tif len(tx.Statement.assigns) > 0 {\n\t\ttx.assignInterfacesToValue(tx.Statement.assigns...)\n\t}\n\treturn\n}\n\n// FirstOrCreate finds the first matching record, otherwise if not found creates a new instance with given conds.\n// Each conds must be a struct or map.\n//\n// Using FirstOrCreate in conjunction with Assign will result in an update to the database even if the record exists.\n//\n//\t// assign an email if the record is not found\n//\tresult := db.Where(User{Name: \"non_existing\"}).Attrs(User{Email: \"fake@fake.org\"}).FirstOrCreate(&user)\n//\t// user -> User{Name: \"non_existing\", Email: \"fake@fake.org\"}\n//\t// result.RowsAffected -> 1\n//\n//\t// assign email regardless of if record is found\n//\tresult := db.Where(User{Name: \"jinzhu\"}).Assign(User{Email: \"fake@fake.org\"}).FirstOrCreate(&user)\n//\t// user -> User{Name: \"jinzhu\", Age: 20, Email: \"fake@fake.org\"}\n//\t// result.RowsAffected -> 1\nfunc (db *DB) FirstOrCreate(dest interface{}, conds ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\tqueryTx := db.Session(&Session{}).Limit(1).Order(clause.OrderByColumn{\n\t\tColumn: clause.Column{Table: clause.CurrentTable, Name: clause.PrimaryKey},\n\t})\n\n\tresult := queryTx.Find(dest, conds...)\n\tif result.Error != nil {\n\t\ttx.Error = result.Error\n\t\treturn tx\n\t}\n\n\tif result.RowsAffected == 0 {\n\t\tif c, ok := result.Statement.Clauses[\"WHERE\"]; ok {\n\t\t\tif where, ok := c.Expression.(clause.Where); ok {\n\t\t\t\tresult.assignInterfacesToValue(where.Exprs)\n\t\t\t}\n\t\t}\n\n\t\t// initialize with attrs, conds\n\t\tif len(db.Statement.attrs) > 0 {\n\t\t\tresult.assignInterfacesToValue(db.Statement.attrs...)\n\t\t}\n\n\t\t// initialize with attrs, conds\n\t\tif len(db.Statement.assigns) > 0 {\n\t\t\tresult.assignInterfacesToValue(db.Statement.assigns...)\n\t\t}\n\n\t\treturn tx.Create(dest)\n\t} else if len(db.Statement.assigns) > 0 {\n\t\texprs := tx.Statement.BuildCondition(db.Statement.assigns[0], db.Statement.assigns[1:]...)\n\t\tassigns := map[string]interface{}{}\n\t\tfor i := 0; i < len(exprs); i++ {\n\t\t\texpr := exprs[i]\n\n\t\t\tif eq, ok := expr.(clause.AndConditions); ok {\n\t\t\t\texprs = append(exprs, eq.Exprs...)\n\t\t\t} else if eq, ok := expr.(clause.Eq); ok {\n\t\t\t\tswitch column := eq.Column.(type) {\n\t\t\t\tcase string:\n\t\t\t\t\tassigns[column] = eq.Value\n\t\t\t\tcase clause.Column:\n\t\t\t\t\tassigns[column.Name] = eq.Value\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tx.Model(dest).Updates(assigns)\n\t}\n\n\treturn tx\n}\n\n// Update updates column with value using callbacks. Reference: https://gorm.io/docs/update.html#Update-Changed-Fields\nfunc (db *DB) Update(column string, value interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.Dest = map[string]interface{}{column: value}\n\treturn tx.callbacks.Update().Execute(tx)\n}\n\n// Updates updates attributes using callbacks. values must be a struct or map. Reference: https://gorm.io/docs/update.html#Update-Changed-Fields\nfunc (db *DB) Updates(values interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.Dest = values\n\treturn tx.callbacks.Update().Execute(tx)\n}\n\nfunc (db *DB) UpdateColumn(column string, value interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.Dest = map[string]interface{}{column: value}\n\ttx.Statement.SkipHooks = true\n\treturn tx.callbacks.Update().Execute(tx)\n}\n\nfunc (db *DB) UpdateColumns(values interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.Dest = values\n\ttx.Statement.SkipHooks = true\n\treturn tx.callbacks.Update().Execute(tx)\n}\n\n// Delete deletes value matching given conditions. If value contains primary key it is included in the conditions. If\n// value includes a deleted_at field, then Delete performs a soft delete instead by setting deleted_at with the current\n// time if null.\nfunc (db *DB) Delete(value interface{}, conds ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\tif len(conds) > 0 {\n\t\tif exprs := tx.Statement.BuildCondition(conds[0], conds[1:]...); len(exprs) > 0 {\n\t\t\ttx.Statement.AddClause(clause.Where{Exprs: exprs})\n\t\t}\n\t}\n\ttx.Statement.Dest = value\n\treturn tx.callbacks.Delete().Execute(tx)\n}\n\nfunc (db *DB) Count(count *int64) (tx *DB) {\n\ttx = db.getInstance()\n\tif tx.Statement.Model == nil {\n\t\ttx.Statement.Model = tx.Statement.Dest\n\t\tdefer func() {\n\t\t\ttx.Statement.Model = nil\n\t\t}()\n\t}\n\n\tif selectClause, ok := db.Statement.Clauses[\"SELECT\"]; ok {\n\t\tdefer func() {\n\t\t\ttx.Statement.Clauses[\"SELECT\"] = selectClause\n\t\t}()\n\t} else {\n\t\tdefer delete(tx.Statement.Clauses, \"SELECT\")\n\t}\n\n\tif len(tx.Statement.Selects) == 0 {\n\t\ttx.Statement.AddClause(clause.Select{Expression: clause.Expr{SQL: \"count(*)\"}})\n\t} else if !strings.HasPrefix(strings.TrimSpace(strings.ToLower(tx.Statement.Selects[0])), \"count(\") {\n\t\texpr := clause.Expr{SQL: \"count(*)\"}\n\n\t\tif len(tx.Statement.Selects) == 1 {\n\t\t\tdbName := tx.Statement.Selects[0]\n\t\t\tfields := strings.FieldsFunc(dbName, utils.IsValidDBNameChar)\n\t\t\tif len(fields) == 1 || (len(fields) == 3 && (strings.ToUpper(fields[1]) == \"AS\" || fields[1] == \".\")) {\n\t\t\t\tif tx.Statement.Parse(tx.Statement.Model) == nil {\n\t\t\t\t\tif f := tx.Statement.Schema.LookUpField(dbName); f != nil {\n\t\t\t\t\t\tdbName = f.DBName\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif tx.Statement.Distinct {\n\t\t\t\t\texpr = clause.Expr{SQL: \"COUNT(DISTINCT(?))\", Vars: []interface{}{clause.Column{Name: dbName}}}\n\t\t\t\t} else if dbName != \"*\" {\n\t\t\t\t\texpr = clause.Expr{SQL: \"COUNT(?)\", Vars: []interface{}{clause.Column{Name: dbName}}}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttx.Statement.AddClause(clause.Select{Expression: expr})\n\t}\n\n\tif orderByClause, ok := db.Statement.Clauses[\"ORDER BY\"]; ok {\n\t\tif _, ok := db.Statement.Clauses[\"GROUP BY\"]; !ok {\n\t\t\tdelete(tx.Statement.Clauses, \"ORDER BY\")\n\t\t\tdefer func() {\n\t\t\t\ttx.Statement.Clauses[\"ORDER BY\"] = orderByClause\n\t\t\t}()\n\t\t}\n\t}\n\n\ttx.Statement.Dest = count\n\ttx = tx.callbacks.Query().Execute(tx)\n\n\tif _, ok := db.Statement.Clauses[\"GROUP BY\"]; ok || tx.RowsAffected != 1 {\n\t\t*count = tx.RowsAffected\n\t}\n\n\treturn\n}\n\nfunc (db *DB) Row() *sql.Row {\n\ttx := db.getInstance().Set(\"rows\", false)\n\ttx = tx.callbacks.Row().Execute(tx)\n\trow, ok := tx.Statement.Dest.(*sql.Row)\n\tif !ok && tx.DryRun {\n\t\tdb.Logger.Error(tx.Statement.Context, ErrDryRunModeUnsupported.Error())\n\t}\n\treturn row\n}\n\nfunc (db *DB) Rows() (*sql.Rows, error) {\n\ttx := db.getInstance().Set(\"rows\", true)\n\ttx = tx.callbacks.Row().Execute(tx)\n\trows, ok := tx.Statement.Dest.(*sql.Rows)\n\tif !ok && tx.DryRun && tx.Error == nil {\n\t\ttx.Error = ErrDryRunModeUnsupported\n\t}\n\treturn rows, tx.Error\n}\n\n// Scan scans selected value to the struct dest\nfunc (db *DB) Scan(dest interface{}) (tx *DB) {\n\tconfig := *db.Config\n\tcurrentLogger, newLogger := config.Logger, logger.Recorder.New()\n\tconfig.Logger = newLogger\n\n\ttx = db.getInstance()\n\ttx.Config = &config\n\n\tif rows, err := tx.Rows(); err == nil {\n\t\tif rows.Next() {\n\t\t\ttx.ScanRows(rows, dest)\n\t\t} else {\n\t\t\ttx.RowsAffected = 0\n\t\t\ttx.AddError(rows.Err())\n\t\t}\n\t\ttx.AddError(rows.Close())\n\t}\n\n\tcurrentLogger.Trace(tx.Statement.Context, newLogger.BeginAt, func() (string, int64) {\n\t\treturn newLogger.SQL, tx.RowsAffected\n\t}, tx.Error)\n\ttx.Logger = currentLogger\n\treturn\n}\n\n// Pluck queries a single column from a model, returning in the slice dest. E.g.:\n//\n//\tvar ages []int64\n//\tdb.Model(&users).Pluck(\"age\", &ages)\nfunc (db *DB) Pluck(column string, dest interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\tif tx.Statement.Model != nil {\n\t\tif tx.Statement.Parse(tx.Statement.Model) == nil {\n\t\t\tif f := tx.Statement.Schema.LookUpField(column); f != nil {\n\t\t\t\tcolumn = f.DBName\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(tx.Statement.Selects) != 1 {\n\t\tfields := strings.FieldsFunc(column, utils.IsValidDBNameChar)\n\t\ttx.Statement.AddClauseIfNotExists(clause.Select{\n\t\t\tDistinct: tx.Statement.Distinct,\n\t\t\tColumns:  []clause.Column{{Name: column, Raw: len(fields) != 1}},\n\t\t})\n\t}\n\ttx.Statement.Dest = dest\n\treturn tx.callbacks.Query().Execute(tx)\n}\n\nfunc (db *DB) ScanRows(rows *sql.Rows, dest interface{}) error {\n\ttx := db.getInstance()\n\tif err := tx.Statement.Parse(dest); !errors.Is(err, schema.ErrUnsupportedDataType) {\n\t\ttx.AddError(err)\n\t}\n\ttx.Statement.Dest = dest\n\ttx.Statement.ReflectValue = reflect.ValueOf(dest)\n\tfor tx.Statement.ReflectValue.Kind() == reflect.Ptr {\n\t\telem := tx.Statement.ReflectValue.Elem()\n\t\tif !elem.IsValid() {\n\t\t\telem = reflect.New(tx.Statement.ReflectValue.Type().Elem())\n\t\t\ttx.Statement.ReflectValue.Set(elem)\n\t\t}\n\t\ttx.Statement.ReflectValue = elem\n\t}\n\tScan(rows, tx, ScanInitialized)\n\treturn tx.Error\n}\n\n// Connection uses a db connection to execute an arbitrary number of commands in fc. When finished, the connection is\n// returned to the connection pool.\nfunc (db *DB) Connection(fc func(tx *DB) error) (err error) {\n\tif db.Error != nil {\n\t\treturn db.Error\n\t}\n\n\ttx := db.getInstance()\n\tsqlDB, err := tx.DB()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tconn, err := sqlDB.Conn(tx.Statement.Context)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tdefer conn.Close()\n\ttx.Statement.ConnPool = conn\n\treturn fc(tx)\n}\n\n// Transaction start a transaction as a block, return error will rollback, otherwise to commit. Transaction executes an\n// arbitrary number of commands in fc within a transaction. On success the changes are committed; if an error occurs\n// they are rolled back.\nfunc (db *DB) Transaction(fc func(tx *DB) error, opts ...*sql.TxOptions) (err error) {\n\tpanicked := true\n\n\tif committer, ok := db.Statement.ConnPool.(TxCommitter); ok && committer != nil {\n\t\t// nested transaction\n\t\tif !db.DisableNestedTransaction {\n\t\t\tspID := new(maphash.Hash).Sum64()\n\t\t\terr = db.SavePoint(fmt.Sprintf(\"sp%d\", spID)).Error\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\t// Make sure to rollback when panic, Block error or Commit error\n\t\t\t\tif panicked || err != nil {\n\t\t\t\t\tdb.RollbackTo(fmt.Sprintf(\"sp%d\", spID))\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\t\terr = fc(db.Session(&Session{NewDB: db.clone == 1}))\n\t} else {\n\t\ttx := db.Begin(opts...)\n\t\tif tx.Error != nil {\n\t\t\treturn tx.Error\n\t\t}\n\n\t\tdefer func() {\n\t\t\t// Make sure to rollback when panic, Block error or Commit error\n\t\t\tif panicked || err != nil {\n\t\t\t\ttx.Rollback()\n\t\t\t}\n\t\t}()\n\n\t\tif err = fc(tx); err == nil {\n\t\t\tpanicked = false\n\t\t\treturn tx.Commit().Error\n\t\t}\n\t}\n\n\tpanicked = false\n\treturn\n}\n\n// Begin begins a transaction with any transaction options opts\nfunc (db *DB) Begin(opts ...*sql.TxOptions) *DB {\n\tvar (\n\t\t// clone statement\n\t\ttx  = db.getInstance().Session(&Session{Context: db.Statement.Context, NewDB: db.clone == 1})\n\t\topt *sql.TxOptions\n\t\terr error\n\t)\n\n\tif len(opts) > 0 {\n\t\topt = opts[0]\n\t}\n\n\tswitch beginner := tx.Statement.ConnPool.(type) {\n\tcase TxBeginner:\n\t\ttx.Statement.ConnPool, err = beginner.BeginTx(tx.Statement.Context, opt)\n\tcase ConnPoolBeginner:\n\t\ttx.Statement.ConnPool, err = beginner.BeginTx(tx.Statement.Context, opt)\n\tdefault:\n\t\terr = ErrInvalidTransaction\n\t}\n\n\tif err != nil {\n\t\ttx.AddError(err)\n\t}\n\n\treturn tx\n}\n\n// Commit commits the changes in a transaction\nfunc (db *DB) Commit() *DB {\n\tif committer, ok := db.Statement.ConnPool.(TxCommitter); ok && committer != nil && !reflect.ValueOf(committer).IsNil() {\n\t\tdb.AddError(committer.Commit())\n\t} else {\n\t\tdb.AddError(ErrInvalidTransaction)\n\t}\n\treturn db\n}\n\n// Rollback rollbacks the changes in a transaction\nfunc (db *DB) Rollback() *DB {\n\tif committer, ok := db.Statement.ConnPool.(TxCommitter); ok && committer != nil {\n\t\tif !reflect.ValueOf(committer).IsNil() {\n\t\t\tdb.AddError(committer.Rollback())\n\t\t}\n\t} else {\n\t\tdb.AddError(ErrInvalidTransaction)\n\t}\n\treturn db\n}\n\nfunc (db *DB) SavePoint(name string) *DB {\n\tif savePointer, ok := db.Dialector.(SavePointerDialectorInterface); ok {\n\t\t// close prepared statement, because SavePoint not support prepared statement.\n\t\t// e.g. mysql8.0 doc: https://dev.mysql.com/doc/refman/8.0/en/sql-prepared-statements.html\n\t\tvar (\n\t\t\tpreparedStmtTx   *PreparedStmtTX\n\t\t\tisPreparedStmtTx bool\n\t\t)\n\t\t// close prepared statement, because SavePoint not support prepared statement.\n\t\tif preparedStmtTx, isPreparedStmtTx = db.Statement.ConnPool.(*PreparedStmtTX); isPreparedStmtTx {\n\t\t\tdb.Statement.ConnPool = preparedStmtTx.Tx\n\t\t}\n\t\tdb.AddError(savePointer.SavePoint(db, name))\n\t\t// restore prepared statement\n\t\tif isPreparedStmtTx {\n\t\t\tdb.Statement.ConnPool = preparedStmtTx\n\t\t}\n\t} else {\n\t\tdb.AddError(ErrUnsupportedDriver)\n\t}\n\treturn db\n}\n\nfunc (db *DB) RollbackTo(name string) *DB {\n\tif savePointer, ok := db.Dialector.(SavePointerDialectorInterface); ok {\n\t\t// close prepared statement, because RollbackTo not support prepared statement.\n\t\t// e.g. mysql8.0 doc: https://dev.mysql.com/doc/refman/8.0/en/sql-prepared-statements.html\n\t\tvar (\n\t\t\tpreparedStmtTx   *PreparedStmtTX\n\t\t\tisPreparedStmtTx bool\n\t\t)\n\t\t// close prepared statement, because SavePoint not support prepared statement.\n\t\tif preparedStmtTx, isPreparedStmtTx = db.Statement.ConnPool.(*PreparedStmtTX); isPreparedStmtTx {\n\t\t\tdb.Statement.ConnPool = preparedStmtTx.Tx\n\t\t}\n\t\tdb.AddError(savePointer.RollbackTo(db, name))\n\t\t// restore prepared statement\n\t\tif isPreparedStmtTx {\n\t\t\tdb.Statement.ConnPool = preparedStmtTx\n\t\t}\n\t} else {\n\t\tdb.AddError(ErrUnsupportedDriver)\n\t}\n\treturn db\n}\n\n// Exec executes raw sql\nfunc (db *DB) Exec(sql string, values ...interface{}) (tx *DB) {\n\ttx = db.getInstance()\n\ttx.Statement.SQL = strings.Builder{}\n\n\tif strings.Contains(sql, \"@\") {\n\t\tclause.NamedExpr{SQL: sql, Vars: values}.Build(tx.Statement)\n\t} else {\n\t\tclause.Expr{SQL: sql, Vars: values}.Build(tx.Statement)\n\t}\n\n\treturn tx.callbacks.Raw().Execute(tx)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1328125,
          "content": "module gorm.io/gorm\n\ngo 1.18\n\nrequire (\n\tgithub.com/jinzhu/inflection v1.0.0\n\tgithub.com/jinzhu/now v1.1.5\n\tgolang.org/x/text v0.20.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.4794921875,
          "content": "github.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=\ngithub.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=\ngithub.com/jinzhu/now v1.1.5 h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=\ngithub.com/jinzhu/now v1.1.5/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=\ngolang.org/x/text v0.20.0 h1:gK/Kv2otX8gz+wn7Rmb3vT96ZwuoxnQlY+HlJVj7Qug=\ngolang.org/x/text v0.20.0/go.mod h1:D4IsuqiFMhST5bX19pQ9ikHC2GsaKyk/oF+pn3ducp4=\n"
        },
        {
          "name": "gorm.go",
          "type": "blob",
          "size": 12.1484375,
          "content": "package gorm\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\t\"sync\"\n\t\"time\"\n\n\t\"gorm.io/gorm/clause\"\n\t\"gorm.io/gorm/logger\"\n\t\"gorm.io/gorm/schema\"\n)\n\n// for Config.cacheStore store PreparedStmtDB key\nconst preparedStmtDBKey = \"preparedStmt\"\n\n// Config GORM config\ntype Config struct {\n\t// GORM perform single create, update, delete operations in transactions by default to ensure database data integrity\n\t// You can disable it by setting `SkipDefaultTransaction` to true\n\tSkipDefaultTransaction bool\n\t// NamingStrategy tables, columns naming strategy\n\tNamingStrategy schema.Namer\n\t// FullSaveAssociations full save associations\n\tFullSaveAssociations bool\n\t// Logger\n\tLogger logger.Interface\n\t// NowFunc the function to be used when creating a new timestamp\n\tNowFunc func() time.Time\n\t// DryRun generate sql without execute\n\tDryRun bool\n\t// PrepareStmt executes the given query in cached statement\n\tPrepareStmt bool\n\t// DisableAutomaticPing\n\tDisableAutomaticPing bool\n\t// DisableForeignKeyConstraintWhenMigrating\n\tDisableForeignKeyConstraintWhenMigrating bool\n\t// IgnoreRelationshipsWhenMigrating\n\tIgnoreRelationshipsWhenMigrating bool\n\t// DisableNestedTransaction disable nested transaction\n\tDisableNestedTransaction bool\n\t// AllowGlobalUpdate allow global update\n\tAllowGlobalUpdate bool\n\t// QueryFields executes the SQL query with all fields of the table\n\tQueryFields bool\n\t// CreateBatchSize default create batch size\n\tCreateBatchSize int\n\t// TranslateError enabling error translation\n\tTranslateError bool\n\t// PropagateUnscoped propagate Unscoped to every other nested statement\n\tPropagateUnscoped bool\n\n\t// ClauseBuilders clause builder\n\tClauseBuilders map[string]clause.ClauseBuilder\n\t// ConnPool db conn pool\n\tConnPool ConnPool\n\t// Dialector database dialector\n\tDialector\n\t// Plugins registered plugins\n\tPlugins map[string]Plugin\n\n\tcallbacks  *callbacks\n\tcacheStore *sync.Map\n}\n\n// Apply update config to new config\nfunc (c *Config) Apply(config *Config) error {\n\tif config != c {\n\t\t*config = *c\n\t}\n\treturn nil\n}\n\n// AfterInitialize initialize plugins after db connected\nfunc (c *Config) AfterInitialize(db *DB) error {\n\tif db != nil {\n\t\tfor _, plugin := range c.Plugins {\n\t\t\tif err := plugin.Initialize(db); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Option gorm option interface\ntype Option interface {\n\tApply(*Config) error\n\tAfterInitialize(*DB) error\n}\n\n// DB GORM DB definition\ntype DB struct {\n\t*Config\n\tError        error\n\tRowsAffected int64\n\tStatement    *Statement\n\tclone        int\n}\n\n// Session session config when create session with Session() method\ntype Session struct {\n\tDryRun                   bool\n\tPrepareStmt              bool\n\tNewDB                    bool\n\tInitialized              bool\n\tSkipHooks                bool\n\tSkipDefaultTransaction   bool\n\tDisableNestedTransaction bool\n\tAllowGlobalUpdate        bool\n\tFullSaveAssociations     bool\n\tPropagateUnscoped        bool\n\tQueryFields              bool\n\tContext                  context.Context\n\tLogger                   logger.Interface\n\tNowFunc                  func() time.Time\n\tCreateBatchSize          int\n}\n\n// Open initialize db session based on dialector\nfunc Open(dialector Dialector, opts ...Option) (db *DB, err error) {\n\tconfig := &Config{}\n\n\tsort.Slice(opts, func(i, j int) bool {\n\t\t_, isConfig := opts[i].(*Config)\n\t\t_, isConfig2 := opts[j].(*Config)\n\t\treturn isConfig && !isConfig2\n\t})\n\n\tfor _, opt := range opts {\n\t\tif opt != nil {\n\t\t\tif applyErr := opt.Apply(config); applyErr != nil {\n\t\t\t\treturn nil, applyErr\n\t\t\t}\n\t\t\tdefer func(opt Option) {\n\t\t\t\tif errr := opt.AfterInitialize(db); errr != nil {\n\t\t\t\t\terr = errr\n\t\t\t\t}\n\t\t\t}(opt)\n\t\t}\n\t}\n\n\tif d, ok := dialector.(interface{ Apply(*Config) error }); ok {\n\t\tif err = d.Apply(config); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif config.NamingStrategy == nil {\n\t\tconfig.NamingStrategy = schema.NamingStrategy{IdentifierMaxLength: 64} // Default Identifier length is 64\n\t}\n\n\tif config.Logger == nil {\n\t\tconfig.Logger = logger.Default\n\t}\n\n\tif config.NowFunc == nil {\n\t\tconfig.NowFunc = func() time.Time { return time.Now().Local() }\n\t}\n\n\tif dialector != nil {\n\t\tconfig.Dialector = dialector\n\t}\n\n\tif config.Plugins == nil {\n\t\tconfig.Plugins = map[string]Plugin{}\n\t}\n\n\tif config.cacheStore == nil {\n\t\tconfig.cacheStore = &sync.Map{}\n\t}\n\n\tdb = &DB{Config: config, clone: 1}\n\n\tdb.callbacks = initializeCallbacks(db)\n\n\tif config.ClauseBuilders == nil {\n\t\tconfig.ClauseBuilders = map[string]clause.ClauseBuilder{}\n\t}\n\n\tif config.Dialector != nil {\n\t\terr = config.Dialector.Initialize(db)\n\t\tif err != nil {\n\t\t\tif db, _ := db.DB(); db != nil {\n\t\t\t\t_ = db.Close()\n\t\t\t}\n\t\t}\n\n\t\tif config.TranslateError {\n\t\t\tif _, ok := db.Dialector.(ErrorTranslator); !ok {\n\t\t\t\tconfig.Logger.Warn(context.Background(), \"The TranslateError option is enabled, but the Dialector %s does not implement ErrorTranslator.\", db.Dialector.Name())\n\t\t\t}\n\t\t}\n\t}\n\n\tif config.PrepareStmt {\n\t\tpreparedStmt := NewPreparedStmtDB(db.ConnPool)\n\t\tdb.cacheStore.Store(preparedStmtDBKey, preparedStmt)\n\t\tdb.ConnPool = preparedStmt\n\t}\n\n\tdb.Statement = &Statement{\n\t\tDB:       db,\n\t\tConnPool: db.ConnPool,\n\t\tContext:  context.Background(),\n\t\tClauses:  map[string]clause.Clause{},\n\t}\n\n\tif err == nil && !config.DisableAutomaticPing {\n\t\tif pinger, ok := db.ConnPool.(interface{ Ping() error }); ok {\n\t\t\terr = pinger.Ping()\n\t\t}\n\t}\n\n\tif err != nil {\n\t\tconfig.Logger.Error(context.Background(), \"failed to initialize database, got error %v\", err)\n\t}\n\n\treturn\n}\n\n// Session create new db session\nfunc (db *DB) Session(config *Session) *DB {\n\tvar (\n\t\ttxConfig = *db.Config\n\t\ttx       = &DB{\n\t\t\tConfig:    &txConfig,\n\t\t\tStatement: db.Statement,\n\t\t\tError:     db.Error,\n\t\t\tclone:     1,\n\t\t}\n\t)\n\tif config.CreateBatchSize > 0 {\n\t\ttx.Config.CreateBatchSize = config.CreateBatchSize\n\t}\n\n\tif config.SkipDefaultTransaction {\n\t\ttx.Config.SkipDefaultTransaction = true\n\t}\n\n\tif config.AllowGlobalUpdate {\n\t\ttxConfig.AllowGlobalUpdate = true\n\t}\n\n\tif config.FullSaveAssociations {\n\t\ttxConfig.FullSaveAssociations = true\n\t}\n\n\tif config.PropagateUnscoped {\n\t\ttxConfig.PropagateUnscoped = true\n\t}\n\n\tif config.Context != nil || config.PrepareStmt || config.SkipHooks {\n\t\ttx.Statement = tx.Statement.clone()\n\t\ttx.Statement.DB = tx\n\t}\n\n\tif config.Context != nil {\n\t\ttx.Statement.Context = config.Context\n\t}\n\n\tif config.PrepareStmt {\n\t\tvar preparedStmt *PreparedStmtDB\n\n\t\tif v, ok := db.cacheStore.Load(preparedStmtDBKey); ok {\n\t\t\tpreparedStmt = v.(*PreparedStmtDB)\n\t\t} else {\n\t\t\tpreparedStmt = NewPreparedStmtDB(db.ConnPool)\n\t\t\tdb.cacheStore.Store(preparedStmtDBKey, preparedStmt)\n\t\t}\n\n\t\tswitch t := tx.Statement.ConnPool.(type) {\n\t\tcase Tx:\n\t\t\ttx.Statement.ConnPool = &PreparedStmtTX{\n\t\t\t\tTx:             t,\n\t\t\t\tPreparedStmtDB: preparedStmt,\n\t\t\t}\n\t\tdefault:\n\t\t\ttx.Statement.ConnPool = &PreparedStmtDB{\n\t\t\t\tConnPool: db.Config.ConnPool,\n\t\t\t\tMux:      preparedStmt.Mux,\n\t\t\t\tStmts:    preparedStmt.Stmts,\n\t\t\t}\n\t\t}\n\t\ttxConfig.ConnPool = tx.Statement.ConnPool\n\t\ttxConfig.PrepareStmt = true\n\t}\n\n\tif config.SkipHooks {\n\t\ttx.Statement.SkipHooks = true\n\t}\n\n\tif config.DisableNestedTransaction {\n\t\ttxConfig.DisableNestedTransaction = true\n\t}\n\n\tif !config.NewDB {\n\t\ttx.clone = 2\n\t}\n\n\tif config.DryRun {\n\t\ttx.Config.DryRun = true\n\t}\n\n\tif config.QueryFields {\n\t\ttx.Config.QueryFields = true\n\t}\n\n\tif config.Logger != nil {\n\t\ttx.Config.Logger = config.Logger\n\t}\n\n\tif config.NowFunc != nil {\n\t\ttx.Config.NowFunc = config.NowFunc\n\t}\n\n\tif config.Initialized {\n\t\ttx = tx.getInstance()\n\t}\n\n\treturn tx\n}\n\n// WithContext change current instance db's context to ctx\nfunc (db *DB) WithContext(ctx context.Context) *DB {\n\treturn db.Session(&Session{Context: ctx})\n}\n\n// Debug start debug mode\nfunc (db *DB) Debug() (tx *DB) {\n\ttx = db.getInstance()\n\treturn tx.Session(&Session{\n\t\tLogger: db.Logger.LogMode(logger.Info),\n\t})\n}\n\n// Set store value with key into current db instance's context\nfunc (db *DB) Set(key string, value interface{}) *DB {\n\ttx := db.getInstance()\n\ttx.Statement.Settings.Store(key, value)\n\treturn tx\n}\n\n// Get get value with key from current db instance's context\nfunc (db *DB) Get(key string) (interface{}, bool) {\n\treturn db.Statement.Settings.Load(key)\n}\n\n// InstanceSet store value with key into current db instance's context\nfunc (db *DB) InstanceSet(key string, value interface{}) *DB {\n\ttx := db.getInstance()\n\ttx.Statement.Settings.Store(fmt.Sprintf(\"%p\", tx.Statement)+key, value)\n\treturn tx\n}\n\n// InstanceGet get value with key from current db instance's context\nfunc (db *DB) InstanceGet(key string) (interface{}, bool) {\n\treturn db.Statement.Settings.Load(fmt.Sprintf(\"%p\", db.Statement) + key)\n}\n\n// Callback returns callback manager\nfunc (db *DB) Callback() *callbacks {\n\treturn db.callbacks\n}\n\n// AddError add error to db\nfunc (db *DB) AddError(err error) error {\n\tif err != nil {\n\t\tif db.Config.TranslateError {\n\t\t\tif errTranslator, ok := db.Dialector.(ErrorTranslator); ok {\n\t\t\t\terr = errTranslator.Translate(err)\n\t\t\t}\n\t\t}\n\n\t\tif db.Error == nil {\n\t\t\tdb.Error = err\n\t\t} else {\n\t\t\tdb.Error = fmt.Errorf(\"%v; %w\", db.Error, err)\n\t\t}\n\t}\n\treturn db.Error\n}\n\n// DB returns `*sql.DB`\nfunc (db *DB) DB() (*sql.DB, error) {\n\tconnPool := db.ConnPool\n\tif db.Statement != nil && db.Statement.ConnPool != nil {\n\t\tconnPool = db.Statement.ConnPool\n\t}\n\tif tx, ok := connPool.(*sql.Tx); ok && tx != nil {\n\t\treturn (*sql.DB)(reflect.ValueOf(tx).Elem().FieldByName(\"db\").UnsafePointer()), nil\n\t}\n\n\tif dbConnector, ok := connPool.(GetDBConnector); ok && dbConnector != nil {\n\t\tif sqldb, err := dbConnector.GetDBConn(); sqldb != nil || err != nil {\n\t\t\treturn sqldb, err\n\t\t}\n\t}\n\n\tif sqldb, ok := connPool.(*sql.DB); ok && sqldb != nil {\n\t\treturn sqldb, nil\n\t}\n\n\treturn nil, ErrInvalidDB\n}\n\nfunc (db *DB) getInstance() *DB {\n\tif db.clone > 0 {\n\t\ttx := &DB{Config: db.Config, Error: db.Error}\n\n\t\tif db.clone == 1 {\n\t\t\t// clone with new statement\n\t\t\ttx.Statement = &Statement{\n\t\t\t\tDB:        tx,\n\t\t\t\tConnPool:  db.Statement.ConnPool,\n\t\t\t\tContext:   db.Statement.Context,\n\t\t\t\tClauses:   map[string]clause.Clause{},\n\t\t\t\tVars:      make([]interface{}, 0, 8),\n\t\t\t\tSkipHooks: db.Statement.SkipHooks,\n\t\t\t}\n\t\t\tif db.Config.PropagateUnscoped {\n\t\t\t\ttx.Statement.Unscoped = db.Statement.Unscoped\n\t\t\t}\n\t\t} else {\n\t\t\t// with clone statement\n\t\t\ttx.Statement = db.Statement.clone()\n\t\t\ttx.Statement.DB = tx\n\t\t}\n\n\t\treturn tx\n\t}\n\n\treturn db\n}\n\n// Expr returns clause.Expr, which can be used to pass SQL expression as params\nfunc Expr(expr string, args ...interface{}) clause.Expr {\n\treturn clause.Expr{SQL: expr, Vars: args}\n}\n\n// SetupJoinTable setup join table schema\nfunc (db *DB) SetupJoinTable(model interface{}, field string, joinTable interface{}) error {\n\tvar (\n\t\ttx                      = db.getInstance()\n\t\tstmt                    = tx.Statement\n\t\tmodelSchema, joinSchema *schema.Schema\n\t)\n\n\terr := stmt.Parse(model)\n\tif err != nil {\n\t\treturn err\n\t}\n\tmodelSchema = stmt.Schema\n\n\terr = stmt.Parse(joinTable)\n\tif err != nil {\n\t\treturn err\n\t}\n\tjoinSchema = stmt.Schema\n\n\trelation, ok := modelSchema.Relationships.Relations[field]\n\tisRelation := ok && relation.JoinTable != nil\n\tif !isRelation {\n\t\treturn fmt.Errorf(\"failed to find relation: %s\", field)\n\t}\n\n\tfor _, ref := range relation.References {\n\t\tf := joinSchema.LookUpField(ref.ForeignKey.DBName)\n\t\tif f == nil {\n\t\t\treturn fmt.Errorf(\"missing field %s for join table\", ref.ForeignKey.DBName)\n\t\t}\n\n\t\tf.DataType = ref.ForeignKey.DataType\n\t\tf.GORMDataType = ref.ForeignKey.GORMDataType\n\t\tif f.Size == 0 {\n\t\t\tf.Size = ref.ForeignKey.Size\n\t\t}\n\t\tref.ForeignKey = f\n\t}\n\n\tfor name, rel := range relation.JoinTable.Relationships.Relations {\n\t\tif _, ok := joinSchema.Relationships.Relations[name]; !ok {\n\t\t\trel.Schema = joinSchema\n\t\t\tjoinSchema.Relationships.Relations[name] = rel\n\t\t}\n\t}\n\trelation.JoinTable = joinSchema\n\n\treturn nil\n}\n\n// Use use plugin\nfunc (db *DB) Use(plugin Plugin) error {\n\tname := plugin.Name()\n\tif _, ok := db.Plugins[name]; ok {\n\t\treturn ErrRegistered\n\t}\n\tif err := plugin.Initialize(db); err != nil {\n\t\treturn err\n\t}\n\tdb.Plugins[name] = plugin\n\treturn nil\n}\n\n// ToSQL for generate SQL string.\n//\n//\tdb.ToSQL(func(tx *gorm.DB) *gorm.DB {\n//\t\t\treturn tx.Model(&User{}).Where(&User{Name: \"foo\", Age: 20})\n//\t\t\t\t.Limit(10).Offset(5)\n//\t\t\t\t.Order(\"name ASC\")\n//\t\t\t\t.First(&User{})\n//\t})\nfunc (db *DB) ToSQL(queryFn func(tx *DB) *DB) string {\n\ttx := queryFn(db.Session(&Session{DryRun: true, SkipDefaultTransaction: true}))\n\tstmt := tx.Statement\n\n\treturn db.Dialector.Explain(stmt.SQL.String(), stmt.Vars...)\n}\n"
        },
        {
          "name": "interfaces.go",
          "type": "blob",
          "size": 2.1640625,
          "content": "package gorm\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\n\t\"gorm.io/gorm/clause\"\n\t\"gorm.io/gorm/schema\"\n)\n\n// Dialector GORM database dialector\ntype Dialector interface {\n\tName() string\n\tInitialize(*DB) error\n\tMigrator(db *DB) Migrator\n\tDataTypeOf(*schema.Field) string\n\tDefaultValueOf(*schema.Field) clause.Expression\n\tBindVarTo(writer clause.Writer, stmt *Statement, v interface{})\n\tQuoteTo(clause.Writer, string)\n\tExplain(sql string, vars ...interface{}) string\n}\n\n// Plugin GORM plugin interface\ntype Plugin interface {\n\tName() string\n\tInitialize(*DB) error\n}\n\ntype ParamsFilter interface {\n\tParamsFilter(ctx context.Context, sql string, params ...interface{}) (string, []interface{})\n}\n\n// ConnPool db conns pool interface\ntype ConnPool interface {\n\tPrepareContext(ctx context.Context, query string) (*sql.Stmt, error)\n\tExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)\n\tQueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)\n\tQueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row\n}\n\n// SavePointerDialectorInterface save pointer interface\ntype SavePointerDialectorInterface interface {\n\tSavePoint(tx *DB, name string) error\n\tRollbackTo(tx *DB, name string) error\n}\n\n// TxBeginner tx beginner\ntype TxBeginner interface {\n\tBeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error)\n}\n\n// ConnPoolBeginner conn pool beginner\ntype ConnPoolBeginner interface {\n\tBeginTx(ctx context.Context, opts *sql.TxOptions) (ConnPool, error)\n}\n\n// TxCommitter tx committer\ntype TxCommitter interface {\n\tCommit() error\n\tRollback() error\n}\n\n// Tx sql.Tx interface\ntype Tx interface {\n\tConnPool\n\tTxCommitter\n\tStmtContext(ctx context.Context, stmt *sql.Stmt) *sql.Stmt\n}\n\n// Valuer gorm valuer interface\ntype Valuer interface {\n\tGormValue(context.Context, *DB) clause.Expr\n}\n\n// GetDBConnector SQL db connector\ntype GetDBConnector interface {\n\tGetDBConn() (*sql.DB, error)\n}\n\n// Rows rows interface\ntype Rows interface {\n\tColumns() ([]string, error)\n\tColumnTypes() ([]*sql.ColumnType, error)\n\tNext() bool\n\tScan(dest ...interface{}) error\n\tErr() error\n\tClose() error\n}\n\ntype ErrorTranslator interface {\n\tTranslate(err error) error\n}\n"
        },
        {
          "name": "logger",
          "type": "tree",
          "content": null
        },
        {
          "name": "migrator.go",
          "type": "blob",
          "size": 3.1298828125,
          "content": "package gorm\n\nimport (\n\t\"reflect\"\n\n\t\"gorm.io/gorm/clause\"\n\t\"gorm.io/gorm/schema\"\n)\n\n// Migrator returns migrator\nfunc (db *DB) Migrator() Migrator {\n\ttx := db.getInstance()\n\n\t// apply scopes to migrator\n\tfor len(tx.Statement.scopes) > 0 {\n\t\ttx = tx.executeScopes()\n\t}\n\n\treturn tx.Dialector.Migrator(tx.Session(&Session{}))\n}\n\n// AutoMigrate run auto migration for given models\nfunc (db *DB) AutoMigrate(dst ...interface{}) error {\n\treturn db.Migrator().AutoMigrate(dst...)\n}\n\n// ViewOption view option\ntype ViewOption struct {\n\tReplace     bool   // If true, exec `CREATE`. If false, exec `CREATE OR REPLACE`\n\tCheckOption string // optional. e.g. `WITH [ CASCADED | LOCAL ] CHECK OPTION`\n\tQuery       *DB    // required subquery.\n}\n\n// ColumnType column type interface\ntype ColumnType interface {\n\tName() string\n\tDatabaseTypeName() string                 // varchar\n\tColumnType() (columnType string, ok bool) // varchar(64)\n\tPrimaryKey() (isPrimaryKey bool, ok bool)\n\tAutoIncrement() (isAutoIncrement bool, ok bool)\n\tLength() (length int64, ok bool)\n\tDecimalSize() (precision int64, scale int64, ok bool)\n\tNullable() (nullable bool, ok bool)\n\tUnique() (unique bool, ok bool)\n\tScanType() reflect.Type\n\tComment() (value string, ok bool)\n\tDefaultValue() (value string, ok bool)\n}\n\ntype Index interface {\n\tTable() string\n\tName() string\n\tColumns() []string\n\tPrimaryKey() (isPrimaryKey bool, ok bool)\n\tUnique() (unique bool, ok bool)\n\tOption() string\n}\n\n// TableType table type interface\ntype TableType interface {\n\tSchema() string\n\tName() string\n\tType() string\n\tComment() (comment string, ok bool)\n}\n\n// Migrator migrator interface\ntype Migrator interface {\n\t// AutoMigrate\n\tAutoMigrate(dst ...interface{}) error\n\n\t// Database\n\tCurrentDatabase() string\n\tFullDataTypeOf(*schema.Field) clause.Expr\n\tGetTypeAliases(databaseTypeName string) []string\n\n\t// Tables\n\tCreateTable(dst ...interface{}) error\n\tDropTable(dst ...interface{}) error\n\tHasTable(dst interface{}) bool\n\tRenameTable(oldName, newName interface{}) error\n\tGetTables() (tableList []string, err error)\n\tTableType(dst interface{}) (TableType, error)\n\n\t// Columns\n\tAddColumn(dst interface{}, field string) error\n\tDropColumn(dst interface{}, field string) error\n\tAlterColumn(dst interface{}, field string) error\n\tMigrateColumn(dst interface{}, field *schema.Field, columnType ColumnType) error\n\t// MigrateColumnUnique migrate column's UNIQUE constraint, it's part of MigrateColumn.\n\tMigrateColumnUnique(dst interface{}, field *schema.Field, columnType ColumnType) error\n\tHasColumn(dst interface{}, field string) bool\n\tRenameColumn(dst interface{}, oldName, field string) error\n\tColumnTypes(dst interface{}) ([]ColumnType, error)\n\n\t// Views\n\tCreateView(name string, option ViewOption) error\n\tDropView(name string) error\n\n\t// Constraints\n\tCreateConstraint(dst interface{}, name string) error\n\tDropConstraint(dst interface{}, name string) error\n\tHasConstraint(dst interface{}, name string) bool\n\n\t// Indexes\n\tCreateIndex(dst interface{}, name string) error\n\tDropIndex(dst interface{}, name string) error\n\tHasIndex(dst interface{}, name string) bool\n\tRenameIndex(dst interface{}, oldName, newName string) error\n\tGetIndexes(dst interface{}) ([]Index, error)\n}\n"
        },
        {
          "name": "migrator",
          "type": "tree",
          "content": null
        },
        {
          "name": "model.go",
          "type": "blob",
          "size": 0.38671875,
          "content": "package gorm\n\nimport \"time\"\n\n// Model a basic GoLang struct which includes the following fields: ID, CreatedAt, UpdatedAt, DeletedAt\n// It may be embedded into your model or you may build your own model without it\n//\n//\ttype User struct {\n//\t  gorm.Model\n//\t}\ntype Model struct {\n\tID        uint `gorm:\"primarykey\"`\n\tCreatedAt time.Time\n\tUpdatedAt time.Time\n\tDeletedAt DeletedAt `gorm:\"index\"`\n}\n"
        },
        {
          "name": "prepare_stmt.go",
          "type": "blob",
          "size": 6.642578125,
          "content": "package gorm\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"errors\"\n\t\"reflect\"\n\t\"sync\"\n)\n\ntype Stmt struct {\n\t*sql.Stmt\n\tTransaction bool\n\tprepared    chan struct{}\n\tprepareErr  error\n}\n\ntype PreparedStmtDB struct {\n\tStmts map[string]*Stmt\n\tMux   *sync.RWMutex\n\tConnPool\n}\n\nfunc NewPreparedStmtDB(connPool ConnPool) *PreparedStmtDB {\n\treturn &PreparedStmtDB{\n\t\tConnPool: connPool,\n\t\tStmts:    make(map[string]*Stmt),\n\t\tMux:      &sync.RWMutex{},\n\t}\n}\n\nfunc (db *PreparedStmtDB) GetDBConn() (*sql.DB, error) {\n\tif sqldb, ok := db.ConnPool.(*sql.DB); ok {\n\t\treturn sqldb, nil\n\t}\n\n\tif dbConnector, ok := db.ConnPool.(GetDBConnector); ok && dbConnector != nil {\n\t\treturn dbConnector.GetDBConn()\n\t}\n\n\treturn nil, ErrInvalidDB\n}\n\nfunc (db *PreparedStmtDB) Close() {\n\tdb.Mux.Lock()\n\tdefer db.Mux.Unlock()\n\n\tfor _, stmt := range db.Stmts {\n\t\tgo func(s *Stmt) {\n\t\t\t// make sure the stmt must finish preparation first\n\t\t\t<-s.prepared\n\t\t\tif s.Stmt != nil {\n\t\t\t\t_ = s.Close()\n\t\t\t}\n\t\t}(stmt)\n\t}\n\t// setting db.Stmts to nil to avoid further using\n\tdb.Stmts = nil\n}\n\nfunc (sdb *PreparedStmtDB) Reset() {\n\tsdb.Mux.Lock()\n\tdefer sdb.Mux.Unlock()\n\n\tfor _, stmt := range sdb.Stmts {\n\t\tgo func(s *Stmt) {\n\t\t\t// make sure the stmt must finish preparation first\n\t\t\t<-s.prepared\n\t\t\tif s.Stmt != nil {\n\t\t\t\t_ = s.Close()\n\t\t\t}\n\t\t}(stmt)\n\t}\n\tsdb.Stmts = make(map[string]*Stmt)\n}\n\nfunc (db *PreparedStmtDB) prepare(ctx context.Context, conn ConnPool, isTransaction bool, query string) (Stmt, error) {\n\tdb.Mux.RLock()\n\tif stmt, ok := db.Stmts[query]; ok && (!stmt.Transaction || isTransaction) {\n\t\tdb.Mux.RUnlock()\n\t\t// wait for other goroutines prepared\n\t\t<-stmt.prepared\n\t\tif stmt.prepareErr != nil {\n\t\t\treturn Stmt{}, stmt.prepareErr\n\t\t}\n\n\t\treturn *stmt, nil\n\t}\n\tdb.Mux.RUnlock()\n\n\tdb.Mux.Lock()\n\t// double check\n\tif stmt, ok := db.Stmts[query]; ok && (!stmt.Transaction || isTransaction) {\n\t\tdb.Mux.Unlock()\n\t\t// wait for other goroutines prepared\n\t\t<-stmt.prepared\n\t\tif stmt.prepareErr != nil {\n\t\t\treturn Stmt{}, stmt.prepareErr\n\t\t}\n\n\t\treturn *stmt, nil\n\t}\n\t// check db.Stmts first to avoid Segmentation Fault(setting value to nil map)\n\t// which cause by calling Close and executing SQL concurrently\n\tif db.Stmts == nil {\n\t\tdb.Mux.Unlock()\n\t\treturn Stmt{}, ErrInvalidDB\n\t}\n\t// cache preparing stmt first\n\tcacheStmt := Stmt{Transaction: isTransaction, prepared: make(chan struct{})}\n\tdb.Stmts[query] = &cacheStmt\n\tdb.Mux.Unlock()\n\n\t// prepare completed\n\tdefer close(cacheStmt.prepared)\n\n\t// Reason why cannot lock conn.PrepareContext\n\t// suppose the maxopen is 1, g1 is creating record and g2 is querying record.\n\t// 1. g1 begin tx, g1 is requeue because of waiting for the system call, now `db.ConnPool` db.numOpen == 1.\n\t// 2. g2 select lock `conn.PrepareContext(ctx, query)`, now db.numOpen == db.maxOpen , wait for release.\n\t// 3. g1 tx exec insert, wait for unlock `conn.PrepareContext(ctx, query)` to finish tx and release.\n\tstmt, err := conn.PrepareContext(ctx, query)\n\tif err != nil {\n\t\tcacheStmt.prepareErr = err\n\t\tdb.Mux.Lock()\n\t\tdelete(db.Stmts, query)\n\t\tdb.Mux.Unlock()\n\t\treturn Stmt{}, err\n\t}\n\n\tdb.Mux.Lock()\n\tcacheStmt.Stmt = stmt\n\tdb.Mux.Unlock()\n\n\treturn cacheStmt, nil\n}\n\nfunc (db *PreparedStmtDB) BeginTx(ctx context.Context, opt *sql.TxOptions) (ConnPool, error) {\n\tif beginner, ok := db.ConnPool.(TxBeginner); ok {\n\t\ttx, err := beginner.BeginTx(ctx, opt)\n\t\treturn &PreparedStmtTX{PreparedStmtDB: db, Tx: tx}, err\n\t}\n\n\tbeginner, ok := db.ConnPool.(ConnPoolBeginner)\n\tif !ok {\n\t\treturn nil, ErrInvalidTransaction\n\t}\n\n\tconnPool, err := beginner.BeginTx(ctx, opt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif tx, ok := connPool.(Tx); ok {\n\t\treturn &PreparedStmtTX{PreparedStmtDB: db, Tx: tx}, nil\n\t}\n\treturn nil, ErrInvalidTransaction\n}\n\nfunc (db *PreparedStmtDB) ExecContext(ctx context.Context, query string, args ...interface{}) (result sql.Result, err error) {\n\tstmt, err := db.prepare(ctx, db.ConnPool, false, query)\n\tif err == nil {\n\t\tresult, err = stmt.ExecContext(ctx, args...)\n\t\tif errors.Is(err, driver.ErrBadConn) {\n\t\t\tdb.Mux.Lock()\n\t\t\tdefer db.Mux.Unlock()\n\t\t\tgo stmt.Close()\n\t\t\tdelete(db.Stmts, query)\n\t\t}\n\t}\n\treturn result, err\n}\n\nfunc (db *PreparedStmtDB) QueryContext(ctx context.Context, query string, args ...interface{}) (rows *sql.Rows, err error) {\n\tstmt, err := db.prepare(ctx, db.ConnPool, false, query)\n\tif err == nil {\n\t\trows, err = stmt.QueryContext(ctx, args...)\n\t\tif errors.Is(err, driver.ErrBadConn) {\n\t\t\tdb.Mux.Lock()\n\t\t\tdefer db.Mux.Unlock()\n\n\t\t\tgo stmt.Close()\n\t\t\tdelete(db.Stmts, query)\n\t\t}\n\t}\n\treturn rows, err\n}\n\nfunc (db *PreparedStmtDB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row {\n\tstmt, err := db.prepare(ctx, db.ConnPool, false, query)\n\tif err == nil {\n\t\treturn stmt.QueryRowContext(ctx, args...)\n\t}\n\treturn &sql.Row{}\n}\n\nfunc (db *PreparedStmtDB) Ping() error {\n\tconn, err := db.GetDBConn()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn conn.Ping()\n}\n\ntype PreparedStmtTX struct {\n\tTx\n\tPreparedStmtDB *PreparedStmtDB\n}\n\nfunc (db *PreparedStmtTX) GetDBConn() (*sql.DB, error) {\n\treturn db.PreparedStmtDB.GetDBConn()\n}\n\nfunc (tx *PreparedStmtTX) Commit() error {\n\tif tx.Tx != nil && !reflect.ValueOf(tx.Tx).IsNil() {\n\t\treturn tx.Tx.Commit()\n\t}\n\treturn ErrInvalidTransaction\n}\n\nfunc (tx *PreparedStmtTX) Rollback() error {\n\tif tx.Tx != nil && !reflect.ValueOf(tx.Tx).IsNil() {\n\t\treturn tx.Tx.Rollback()\n\t}\n\treturn ErrInvalidTransaction\n}\n\nfunc (tx *PreparedStmtTX) ExecContext(ctx context.Context, query string, args ...interface{}) (result sql.Result, err error) {\n\tstmt, err := tx.PreparedStmtDB.prepare(ctx, tx.Tx, true, query)\n\tif err == nil {\n\t\tresult, err = tx.Tx.StmtContext(ctx, stmt.Stmt).ExecContext(ctx, args...)\n\t\tif errors.Is(err, driver.ErrBadConn) {\n\t\t\ttx.PreparedStmtDB.Mux.Lock()\n\t\t\tdefer tx.PreparedStmtDB.Mux.Unlock()\n\n\t\t\tgo stmt.Close()\n\t\t\tdelete(tx.PreparedStmtDB.Stmts, query)\n\t\t}\n\t}\n\treturn result, err\n}\n\nfunc (tx *PreparedStmtTX) QueryContext(ctx context.Context, query string, args ...interface{}) (rows *sql.Rows, err error) {\n\tstmt, err := tx.PreparedStmtDB.prepare(ctx, tx.Tx, true, query)\n\tif err == nil {\n\t\trows, err = tx.Tx.StmtContext(ctx, stmt.Stmt).QueryContext(ctx, args...)\n\t\tif errors.Is(err, driver.ErrBadConn) {\n\t\t\ttx.PreparedStmtDB.Mux.Lock()\n\t\t\tdefer tx.PreparedStmtDB.Mux.Unlock()\n\n\t\t\tgo stmt.Close()\n\t\t\tdelete(tx.PreparedStmtDB.Stmts, query)\n\t\t}\n\t}\n\treturn rows, err\n}\n\nfunc (tx *PreparedStmtTX) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row {\n\tstmt, err := tx.PreparedStmtDB.prepare(ctx, tx.Tx, true, query)\n\tif err == nil {\n\t\treturn tx.Tx.StmtContext(ctx, stmt.Stmt).QueryRowContext(ctx, args...)\n\t}\n\treturn &sql.Row{}\n}\n\nfunc (tx *PreparedStmtTX) Ping() error {\n\tconn, err := tx.GetDBConn()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn conn.Ping()\n}\n"
        },
        {
          "name": "scan.go",
          "type": "blob",
          "size": 10.123046875,
          "content": "package gorm\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"gorm.io/gorm/schema\"\n\t\"gorm.io/gorm/utils\"\n)\n\n// prepareValues prepare values slice\nfunc prepareValues(values []interface{}, db *DB, columnTypes []*sql.ColumnType, columns []string) {\n\tif db.Statement.Schema != nil {\n\t\tfor idx, name := range columns {\n\t\t\tif field := db.Statement.Schema.LookUpField(name); field != nil {\n\t\t\t\tvalues[idx] = reflect.New(reflect.PtrTo(field.FieldType)).Interface()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvalues[idx] = new(interface{})\n\t\t}\n\t} else if len(columnTypes) > 0 {\n\t\tfor idx, columnType := range columnTypes {\n\t\t\tif columnType.ScanType() != nil {\n\t\t\t\tvalues[idx] = reflect.New(reflect.PtrTo(columnType.ScanType())).Interface()\n\t\t\t} else {\n\t\t\t\tvalues[idx] = new(interface{})\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor idx := range columns {\n\t\t\tvalues[idx] = new(interface{})\n\t\t}\n\t}\n}\n\nfunc scanIntoMap(mapValue map[string]interface{}, values []interface{}, columns []string) {\n\tfor idx, column := range columns {\n\t\tif reflectValue := reflect.Indirect(reflect.Indirect(reflect.ValueOf(values[idx]))); reflectValue.IsValid() {\n\t\t\tmapValue[column] = reflectValue.Interface()\n\t\t\tif valuer, ok := mapValue[column].(driver.Valuer); ok {\n\t\t\t\tmapValue[column], _ = valuer.Value()\n\t\t\t} else if b, ok := mapValue[column].(sql.RawBytes); ok {\n\t\t\t\tmapValue[column] = string(b)\n\t\t\t}\n\t\t} else {\n\t\t\tmapValue[column] = nil\n\t\t}\n\t}\n}\n\nfunc (db *DB) scanIntoStruct(rows Rows, reflectValue reflect.Value, values []interface{}, fields []*schema.Field, joinFields [][]*schema.Field) {\n\tfor idx, field := range fields {\n\t\tif field != nil {\n\t\t\tvalues[idx] = field.NewValuePool.Get()\n\t\t} else if len(fields) == 1 {\n\t\t\tif reflectValue.CanAddr() {\n\t\t\t\tvalues[idx] = reflectValue.Addr().Interface()\n\t\t\t} else {\n\t\t\t\tvalues[idx] = reflectValue.Interface()\n\t\t\t}\n\t\t}\n\t}\n\n\tdb.RowsAffected++\n\tdb.AddError(rows.Scan(values...))\n\tjoinedNestedSchemaMap := make(map[string]interface{})\n\tfor idx, field := range fields {\n\t\tif field == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(joinFields) == 0 || len(joinFields[idx]) == 0 {\n\t\t\tdb.AddError(field.Set(db.Statement.Context, reflectValue, values[idx]))\n\t\t} else { // joinFields count is larger than 2 when using join\n\t\t\tvar isNilPtrValue bool\n\t\t\tvar relValue reflect.Value\n\t\t\t// does not contain raw dbname\n\t\t\tnestedJoinSchemas := joinFields[idx][:len(joinFields[idx])-1]\n\t\t\t// current reflect value\n\t\t\tcurrentReflectValue := reflectValue\n\t\t\tfullRels := make([]string, 0, len(nestedJoinSchemas))\n\t\t\tfor _, joinSchema := range nestedJoinSchemas {\n\t\t\t\tfullRels = append(fullRels, joinSchema.Name)\n\t\t\t\trelValue = joinSchema.ReflectValueOf(db.Statement.Context, currentReflectValue)\n\t\t\t\tif relValue.Kind() == reflect.Ptr {\n\t\t\t\t\tfullRelsName := utils.JoinNestedRelationNames(fullRels)\n\t\t\t\t\t// same nested structure\n\t\t\t\t\tif _, ok := joinedNestedSchemaMap[fullRelsName]; !ok {\n\t\t\t\t\t\tif value := reflect.ValueOf(values[idx]).Elem(); value.Kind() == reflect.Ptr && value.IsNil() {\n\t\t\t\t\t\t\tisNilPtrValue = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trelValue.Set(reflect.New(relValue.Type().Elem()))\n\t\t\t\t\t\tjoinedNestedSchemaMap[fullRelsName] = nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurrentReflectValue = relValue\n\t\t\t}\n\n\t\t\tif !isNilPtrValue { // ignore if value is nil\n\t\t\t\tf := joinFields[idx][len(joinFields[idx])-1]\n\t\t\t\tdb.AddError(f.Set(db.Statement.Context, relValue, values[idx]))\n\t\t\t}\n\t\t}\n\n\t\t// release data to pool\n\t\tfield.NewValuePool.Put(values[idx])\n\t}\n}\n\n// ScanMode scan data mode\ntype ScanMode uint8\n\n// scan modes\nconst (\n\tScanInitialized         ScanMode = 1 << 0 // 1\n\tScanUpdate              ScanMode = 1 << 1 // 2\n\tScanOnConflictDoNothing ScanMode = 1 << 2 // 4\n)\n\n// Scan scan rows into db statement\nfunc Scan(rows Rows, db *DB, mode ScanMode) {\n\tvar (\n\t\tcolumns, _          = rows.Columns()\n\t\tvalues              = make([]interface{}, len(columns))\n\t\tinitialized         = mode&ScanInitialized != 0\n\t\tupdate              = mode&ScanUpdate != 0\n\t\tonConflictDonothing = mode&ScanOnConflictDoNothing != 0\n\t)\n\n\tif len(db.Statement.ColumnMapping) > 0 {\n\t\tfor i, column := range columns {\n\t\t\tv, ok := db.Statement.ColumnMapping[column]\n\t\t\tif ok {\n\t\t\t\tcolumns[i] = v\n\t\t\t}\n\t\t}\n\t}\n\n\tdb.RowsAffected = 0\n\n\tswitch dest := db.Statement.Dest.(type) {\n\tcase map[string]interface{}, *map[string]interface{}:\n\t\tif initialized || rows.Next() {\n\t\t\tcolumnTypes, _ := rows.ColumnTypes()\n\t\t\tprepareValues(values, db, columnTypes, columns)\n\n\t\t\tdb.RowsAffected++\n\t\t\tdb.AddError(rows.Scan(values...))\n\n\t\t\tmapValue, ok := dest.(map[string]interface{})\n\t\t\tif !ok {\n\t\t\t\tif v, ok := dest.(*map[string]interface{}); ok {\n\t\t\t\t\tif *v == nil {\n\t\t\t\t\t\t*v = map[string]interface{}{}\n\t\t\t\t\t}\n\t\t\t\t\tmapValue = *v\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanIntoMap(mapValue, values, columns)\n\t\t}\n\tcase *[]map[string]interface{}:\n\t\tcolumnTypes, _ := rows.ColumnTypes()\n\t\tfor initialized || rows.Next() {\n\t\t\tprepareValues(values, db, columnTypes, columns)\n\n\t\t\tinitialized = false\n\t\t\tdb.RowsAffected++\n\t\t\tdb.AddError(rows.Scan(values...))\n\n\t\t\tmapValue := map[string]interface{}{}\n\t\t\tscanIntoMap(mapValue, values, columns)\n\t\t\t*dest = append(*dest, mapValue)\n\t\t}\n\tcase *int, *int8, *int16, *int32, *int64,\n\t\t*uint, *uint8, *uint16, *uint32, *uint64, *uintptr,\n\t\t*float32, *float64,\n\t\t*bool, *string, *time.Time,\n\t\t*sql.NullInt32, *sql.NullInt64, *sql.NullFloat64,\n\t\t*sql.NullBool, *sql.NullString, *sql.NullTime:\n\t\tfor initialized || rows.Next() {\n\t\t\tinitialized = false\n\t\t\tdb.RowsAffected++\n\t\t\tdb.AddError(rows.Scan(dest))\n\t\t}\n\tdefault:\n\t\tvar (\n\t\t\tfields       = make([]*schema.Field, len(columns))\n\t\t\tjoinFields   [][]*schema.Field\n\t\t\tsch          = db.Statement.Schema\n\t\t\treflectValue = db.Statement.ReflectValue\n\t\t)\n\n\t\tif reflectValue.Kind() == reflect.Interface {\n\t\t\treflectValue = reflectValue.Elem()\n\t\t}\n\n\t\treflectValueType := reflectValue.Type()\n\t\tswitch reflectValueType.Kind() {\n\t\tcase reflect.Array, reflect.Slice:\n\t\t\treflectValueType = reflectValueType.Elem()\n\t\t}\n\t\tisPtr := reflectValueType.Kind() == reflect.Ptr\n\t\tif isPtr {\n\t\t\treflectValueType = reflectValueType.Elem()\n\t\t}\n\n\t\tif sch != nil {\n\t\t\tif reflectValueType != sch.ModelType && reflectValueType.Kind() == reflect.Struct {\n\t\t\t\tsch, _ = schema.Parse(db.Statement.Dest, db.cacheStore, db.NamingStrategy)\n\t\t\t}\n\n\t\t\tif len(columns) == 1 {\n\t\t\t\t// Is Pluck\n\t\t\t\tif _, ok := reflect.New(reflectValueType).Interface().(sql.Scanner); (reflectValueType != sch.ModelType && ok) || // is scanner\n\t\t\t\t\treflectValueType.Kind() != reflect.Struct || // is not struct\n\t\t\t\t\tsch.ModelType.ConvertibleTo(schema.TimeReflectType) { // is time\n\t\t\t\t\tsch = nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Not Pluck\n\t\t\tif sch != nil {\n\t\t\t\tmatchedFieldCount := make(map[string]int, len(columns))\n\t\t\t\tfor idx, column := range columns {\n\t\t\t\t\tif field := sch.LookUpField(column); field != nil && field.Readable {\n\t\t\t\t\t\tfields[idx] = field\n\t\t\t\t\t\tif count, ok := matchedFieldCount[column]; ok {\n\t\t\t\t\t\t\t// handle duplicate fields\n\t\t\t\t\t\t\tfor _, selectField := range sch.Fields {\n\t\t\t\t\t\t\t\tif selectField.DBName == column && selectField.Readable {\n\t\t\t\t\t\t\t\t\tif count == 0 {\n\t\t\t\t\t\t\t\t\t\tmatchedFieldCount[column]++\n\t\t\t\t\t\t\t\t\t\tfields[idx] = selectField\n\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcount--\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmatchedFieldCount[column] = 1\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if names := utils.SplitNestedRelationName(column); len(names) > 1 { // has nested relation\n\t\t\t\t\t\tif rel, ok := sch.Relationships.Relations[names[0]]; ok {\n\t\t\t\t\t\t\tsubNameCount := len(names)\n\t\t\t\t\t\t\t// nested relation fields\n\t\t\t\t\t\t\trelFields := make([]*schema.Field, 0, subNameCount-1)\n\t\t\t\t\t\t\trelFields = append(relFields, rel.Field)\n\t\t\t\t\t\t\tfor _, name := range names[1 : subNameCount-1] {\n\t\t\t\t\t\t\t\trel = rel.FieldSchema.Relationships.Relations[name]\n\t\t\t\t\t\t\t\trelFields = append(relFields, rel.Field)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// latest name is raw dbname\n\t\t\t\t\t\t\tdbName := names[subNameCount-1]\n\t\t\t\t\t\t\tif field := rel.FieldSchema.LookUpField(dbName); field != nil && field.Readable {\n\t\t\t\t\t\t\t\tfields[idx] = field\n\n\t\t\t\t\t\t\t\tif len(joinFields) == 0 {\n\t\t\t\t\t\t\t\t\tjoinFields = make([][]*schema.Field, len(columns))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trelFields = append(relFields, field)\n\t\t\t\t\t\t\t\tjoinFields[idx] = relFields\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar val interface{}\n\t\t\t\t\t\tvalues[idx] = &val\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar val interface{}\n\t\t\t\t\t\tvalues[idx] = &val\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch reflectValue.Kind() {\n\t\tcase reflect.Slice, reflect.Array:\n\t\t\tvar (\n\t\t\t\telem        reflect.Value\n\t\t\t\tisArrayKind = reflectValue.Kind() == reflect.Array\n\t\t\t)\n\n\t\t\tif !update || reflectValue.Len() == 0 {\n\t\t\t\tupdate = false\n\t\t\t\tif isArrayKind {\n\t\t\t\t\tdb.Statement.ReflectValue.Set(reflect.Zero(reflectValue.Type()))\n\t\t\t\t} else {\n\t\t\t\t\t// if the slice cap is externally initialized, the externally initialized slice is directly used here\n\t\t\t\t\tif reflectValue.Cap() == 0 {\n\t\t\t\t\t\tdb.Statement.ReflectValue.Set(reflect.MakeSlice(reflectValue.Type(), 0, 20))\n\t\t\t\t\t} else {\n\t\t\t\t\t\treflectValue.SetLen(0)\n\t\t\t\t\t\tdb.Statement.ReflectValue.Set(reflectValue)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor initialized || rows.Next() {\n\t\t\tBEGIN:\n\t\t\t\tinitialized = false\n\n\t\t\t\tif update {\n\t\t\t\t\tif int(db.RowsAffected) >= reflectValue.Len() {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\telem = reflectValue.Index(int(db.RowsAffected))\n\t\t\t\t\tif onConflictDonothing {\n\t\t\t\t\t\tfor _, field := range fields {\n\t\t\t\t\t\t\tif _, ok := field.ValueOf(db.Statement.Context, elem); !ok {\n\t\t\t\t\t\t\t\tdb.RowsAffected++\n\t\t\t\t\t\t\t\tgoto BEGIN\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telem = reflect.New(reflectValueType)\n\t\t\t\t}\n\n\t\t\t\tdb.scanIntoStruct(rows, elem, values, fields, joinFields)\n\n\t\t\t\tif !update {\n\t\t\t\t\tif !isPtr {\n\t\t\t\t\t\telem = elem.Elem()\n\t\t\t\t\t}\n\t\t\t\t\tif isArrayKind {\n\t\t\t\t\t\tif reflectValue.Len() >= int(db.RowsAffected) {\n\t\t\t\t\t\t\treflectValue.Index(int(db.RowsAffected - 1)).Set(elem)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treflectValue = reflect.Append(reflectValue, elem)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !update {\n\t\t\t\tdb.Statement.ReflectValue.Set(reflectValue)\n\t\t\t}\n\t\tcase reflect.Struct, reflect.Ptr:\n\t\t\tif initialized || rows.Next() {\n\t\t\t\tif mode == ScanInitialized && reflectValue.Kind() == reflect.Struct {\n\t\t\t\t\tdb.Statement.ReflectValue.Set(reflect.Zero(reflectValue.Type()))\n\t\t\t\t}\n\t\t\t\tdb.scanIntoStruct(rows, reflectValue, values, fields, joinFields)\n\t\t\t}\n\t\tdefault:\n\t\t\tdb.AddError(rows.Scan(dest))\n\t\t}\n\t}\n\n\tif err := rows.Err(); err != nil && err != db.Error {\n\t\tdb.AddError(err)\n\t}\n\n\tif db.RowsAffected == 0 && db.Statement.RaiseErrorOnNotFound && db.Error == nil {\n\t\tdb.AddError(ErrRecordNotFound)\n\t}\n}\n"
        },
        {
          "name": "schema",
          "type": "tree",
          "content": null
        },
        {
          "name": "soft_delete.go",
          "type": "blob",
          "size": 4.5244140625,
          "content": "package gorm\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"encoding/json\"\n\t\"reflect\"\n\n\t\"github.com/jinzhu/now\"\n\t\"gorm.io/gorm/clause\"\n\t\"gorm.io/gorm/schema\"\n)\n\ntype DeletedAt sql.NullTime\n\n// Scan implements the Scanner interface.\nfunc (n *DeletedAt) Scan(value interface{}) error {\n\treturn (*sql.NullTime)(n).Scan(value)\n}\n\n// Value implements the driver Valuer interface.\nfunc (n DeletedAt) Value() (driver.Value, error) {\n\tif !n.Valid {\n\t\treturn nil, nil\n\t}\n\treturn n.Time, nil\n}\n\nfunc (n DeletedAt) MarshalJSON() ([]byte, error) {\n\tif n.Valid {\n\t\treturn json.Marshal(n.Time)\n\t}\n\treturn json.Marshal(nil)\n}\n\nfunc (n *DeletedAt) UnmarshalJSON(b []byte) error {\n\tif string(b) == \"null\" {\n\t\tn.Valid = false\n\t\treturn nil\n\t}\n\terr := json.Unmarshal(b, &n.Time)\n\tif err == nil {\n\t\tn.Valid = true\n\t}\n\treturn err\n}\n\nfunc (DeletedAt) QueryClauses(f *schema.Field) []clause.Interface {\n\treturn []clause.Interface{SoftDeleteQueryClause{Field: f, ZeroValue: parseZeroValueTag(f)}}\n}\n\nfunc parseZeroValueTag(f *schema.Field) sql.NullString {\n\tif v, ok := f.TagSettings[\"ZEROVALUE\"]; ok {\n\t\tif _, err := now.Parse(v); err == nil {\n\t\t\treturn sql.NullString{String: v, Valid: true}\n\t\t}\n\t}\n\treturn sql.NullString{Valid: false}\n}\n\ntype SoftDeleteQueryClause struct {\n\tZeroValue sql.NullString\n\tField     *schema.Field\n}\n\nfunc (sd SoftDeleteQueryClause) Name() string {\n\treturn \"\"\n}\n\nfunc (sd SoftDeleteQueryClause) Build(clause.Builder) {\n}\n\nfunc (sd SoftDeleteQueryClause) MergeClause(*clause.Clause) {\n}\n\nfunc (sd SoftDeleteQueryClause) ModifyStatement(stmt *Statement) {\n\tif _, ok := stmt.Clauses[\"soft_delete_enabled\"]; !ok && !stmt.Statement.Unscoped {\n\t\tif c, ok := stmt.Clauses[\"WHERE\"]; ok {\n\t\t\tif where, ok := c.Expression.(clause.Where); ok && len(where.Exprs) >= 1 {\n\t\t\t\tfor _, expr := range where.Exprs {\n\t\t\t\t\tif orCond, ok := expr.(clause.OrConditions); ok && len(orCond.Exprs) == 1 {\n\t\t\t\t\t\twhere.Exprs = []clause.Expression{clause.And(where.Exprs...)}\n\t\t\t\t\t\tc.Expression = where\n\t\t\t\t\t\tstmt.Clauses[\"WHERE\"] = c\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstmt.AddClause(clause.Where{Exprs: []clause.Expression{\n\t\t\tclause.Eq{Column: clause.Column{Table: clause.CurrentTable, Name: sd.Field.DBName}, Value: sd.ZeroValue},\n\t\t}})\n\t\tstmt.Clauses[\"soft_delete_enabled\"] = clause.Clause{}\n\t}\n}\n\nfunc (DeletedAt) UpdateClauses(f *schema.Field) []clause.Interface {\n\treturn []clause.Interface{SoftDeleteUpdateClause{Field: f, ZeroValue: parseZeroValueTag(f)}}\n}\n\ntype SoftDeleteUpdateClause struct {\n\tZeroValue sql.NullString\n\tField     *schema.Field\n}\n\nfunc (sd SoftDeleteUpdateClause) Name() string {\n\treturn \"\"\n}\n\nfunc (sd SoftDeleteUpdateClause) Build(clause.Builder) {\n}\n\nfunc (sd SoftDeleteUpdateClause) MergeClause(*clause.Clause) {\n}\n\nfunc (sd SoftDeleteUpdateClause) ModifyStatement(stmt *Statement) {\n\tif stmt.SQL.Len() == 0 && !stmt.Statement.Unscoped {\n\t\tSoftDeleteQueryClause(sd).ModifyStatement(stmt)\n\t}\n}\n\nfunc (DeletedAt) DeleteClauses(f *schema.Field) []clause.Interface {\n\treturn []clause.Interface{SoftDeleteDeleteClause{Field: f, ZeroValue: parseZeroValueTag(f)}}\n}\n\ntype SoftDeleteDeleteClause struct {\n\tZeroValue sql.NullString\n\tField     *schema.Field\n}\n\nfunc (sd SoftDeleteDeleteClause) Name() string {\n\treturn \"\"\n}\n\nfunc (sd SoftDeleteDeleteClause) Build(clause.Builder) {\n}\n\nfunc (sd SoftDeleteDeleteClause) MergeClause(*clause.Clause) {\n}\n\nfunc (sd SoftDeleteDeleteClause) ModifyStatement(stmt *Statement) {\n\tif stmt.SQL.Len() == 0 && !stmt.Statement.Unscoped {\n\t\tcurTime := stmt.DB.NowFunc()\n\t\tstmt.AddClause(clause.Set{{Column: clause.Column{Name: sd.Field.DBName}, Value: curTime}})\n\t\tstmt.SetColumn(sd.Field.DBName, curTime, true)\n\n\t\tif stmt.Schema != nil {\n\t\t\t_, queryValues := schema.GetIdentityFieldValuesMap(stmt.Context, stmt.ReflectValue, stmt.Schema.PrimaryFields)\n\t\t\tcolumn, values := schema.ToQueryValues(stmt.Table, stmt.Schema.PrimaryFieldDBNames, queryValues)\n\n\t\t\tif len(values) > 0 {\n\t\t\t\tstmt.AddClause(clause.Where{Exprs: []clause.Expression{clause.IN{Column: column, Values: values}}})\n\t\t\t}\n\n\t\t\tif stmt.ReflectValue.CanAddr() && stmt.Dest != stmt.Model && stmt.Model != nil {\n\t\t\t\t_, queryValues = schema.GetIdentityFieldValuesMap(stmt.Context, reflect.ValueOf(stmt.Model), stmt.Schema.PrimaryFields)\n\t\t\t\tcolumn, values = schema.ToQueryValues(stmt.Table, stmt.Schema.PrimaryFieldDBNames, queryValues)\n\n\t\t\t\tif len(values) > 0 {\n\t\t\t\t\tstmt.AddClause(clause.Where{Exprs: []clause.Expression{clause.IN{Column: column, Values: values}}})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSoftDeleteQueryClause(sd).ModifyStatement(stmt)\n\t\tstmt.AddClauseIfNotExists(clause.Update{})\n\t\tstmt.Build(stmt.DB.Callback().Update().Clauses...)\n\t}\n}\n"
        },
        {
          "name": "statement.go",
          "type": "blob",
          "size": 19.904296875,
          "content": "package gorm\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"gorm.io/gorm/clause\"\n\t\"gorm.io/gorm/logger\"\n\t\"gorm.io/gorm/schema\"\n\t\"gorm.io/gorm/utils\"\n)\n\n// Statement statement\ntype Statement struct {\n\t*DB\n\tTableExpr            *clause.Expr\n\tTable                string\n\tModel                interface{}\n\tUnscoped             bool\n\tDest                 interface{}\n\tReflectValue         reflect.Value\n\tClauses              map[string]clause.Clause\n\tBuildClauses         []string\n\tDistinct             bool\n\tSelects              []string          // selected columns\n\tOmits                []string          // omit columns\n\tColumnMapping        map[string]string // map columns\n\tJoins                []join\n\tPreloads             map[string][]interface{}\n\tSettings             sync.Map\n\tConnPool             ConnPool\n\tSchema               *schema.Schema\n\tContext              context.Context\n\tRaiseErrorOnNotFound bool\n\tSkipHooks            bool\n\tSQL                  strings.Builder\n\tVars                 []interface{}\n\tCurDestIndex         int\n\tattrs                []interface{}\n\tassigns              []interface{}\n\tscopes               []func(*DB) *DB\n}\n\ntype join struct {\n\tName     string\n\tConds    []interface{}\n\tOn       *clause.Where\n\tSelects  []string\n\tOmits    []string\n\tJoinType clause.JoinType\n}\n\n// StatementModifier statement modifier interface\ntype StatementModifier interface {\n\tModifyStatement(*Statement)\n}\n\n// WriteString write string\nfunc (stmt *Statement) WriteString(str string) (int, error) {\n\treturn stmt.SQL.WriteString(str)\n}\n\n// WriteByte write byte\nfunc (stmt *Statement) WriteByte(c byte) error {\n\treturn stmt.SQL.WriteByte(c)\n}\n\n// WriteQuoted write quoted value\nfunc (stmt *Statement) WriteQuoted(value interface{}) {\n\tstmt.QuoteTo(&stmt.SQL, value)\n}\n\n// QuoteTo write quoted value to writer\nfunc (stmt *Statement) QuoteTo(writer clause.Writer, field interface{}) {\n\twrite := func(raw bool, str string) {\n\t\tif raw {\n\t\t\twriter.WriteString(str)\n\t\t} else {\n\t\t\tstmt.DB.Dialector.QuoteTo(writer, str)\n\t\t}\n\t}\n\n\tswitch v := field.(type) {\n\tcase clause.Table:\n\t\tif v.Name == clause.CurrentTable {\n\t\t\tif stmt.TableExpr != nil {\n\t\t\t\tstmt.TableExpr.Build(stmt)\n\t\t\t} else {\n\t\t\t\twrite(v.Raw, stmt.Table)\n\t\t\t}\n\t\t} else {\n\t\t\twrite(v.Raw, v.Name)\n\t\t}\n\n\t\tif v.Alias != \"\" {\n\t\t\twriter.WriteByte(' ')\n\t\t\twrite(v.Raw, v.Alias)\n\t\t}\n\tcase clause.Column:\n\t\tif v.Table != \"\" {\n\t\t\tif v.Table == clause.CurrentTable {\n\t\t\t\twrite(v.Raw, stmt.Table)\n\t\t\t} else {\n\t\t\t\twrite(v.Raw, v.Table)\n\t\t\t}\n\t\t\twriter.WriteByte('.')\n\t\t}\n\n\t\tif v.Name == clause.PrimaryKey {\n\t\t\tif stmt.Schema == nil {\n\t\t\t\tstmt.DB.AddError(ErrModelValueRequired)\n\t\t\t} else if stmt.Schema.PrioritizedPrimaryField != nil {\n\t\t\t\twrite(v.Raw, stmt.Schema.PrioritizedPrimaryField.DBName)\n\t\t\t} else if len(stmt.Schema.DBNames) > 0 {\n\t\t\t\twrite(v.Raw, stmt.Schema.DBNames[0])\n\t\t\t} else {\n\t\t\t\tstmt.DB.AddError(ErrModelAccessibleFieldsRequired) //nolint:typecheck,errcheck\n\t\t\t}\n\t\t} else {\n\t\t\twrite(v.Raw, v.Name)\n\t\t}\n\n\t\tif v.Alias != \"\" {\n\t\t\twriter.WriteString(\" AS \")\n\t\t\twrite(v.Raw, v.Alias)\n\t\t}\n\tcase []clause.Column:\n\t\twriter.WriteByte('(')\n\t\tfor idx, d := range v {\n\t\t\tif idx > 0 {\n\t\t\t\twriter.WriteByte(',')\n\t\t\t}\n\t\t\tstmt.QuoteTo(writer, d)\n\t\t}\n\t\twriter.WriteByte(')')\n\tcase clause.Expr:\n\t\tv.Build(stmt)\n\tcase string:\n\t\tstmt.DB.Dialector.QuoteTo(writer, v)\n\tcase []string:\n\t\twriter.WriteByte('(')\n\t\tfor idx, d := range v {\n\t\t\tif idx > 0 {\n\t\t\t\twriter.WriteByte(',')\n\t\t\t}\n\t\t\tstmt.DB.Dialector.QuoteTo(writer, d)\n\t\t}\n\t\twriter.WriteByte(')')\n\tdefault:\n\t\tstmt.DB.Dialector.QuoteTo(writer, fmt.Sprint(field))\n\t}\n}\n\n// Quote returns quoted value\nfunc (stmt *Statement) Quote(field interface{}) string {\n\tvar builder strings.Builder\n\tstmt.QuoteTo(&builder, field)\n\treturn builder.String()\n}\n\n// AddVar add var\nfunc (stmt *Statement) AddVar(writer clause.Writer, vars ...interface{}) {\n\tfor idx, v := range vars {\n\t\tif idx > 0 {\n\t\t\twriter.WriteByte(',')\n\t\t}\n\n\t\tswitch v := v.(type) {\n\t\tcase sql.NamedArg:\n\t\t\tstmt.Vars = append(stmt.Vars, v.Value)\n\t\tcase clause.Column, clause.Table:\n\t\t\tstmt.QuoteTo(writer, v)\n\t\tcase Valuer:\n\t\t\treflectValue := reflect.ValueOf(v)\n\t\t\tif reflectValue.Kind() == reflect.Ptr && reflectValue.IsNil() {\n\t\t\t\tstmt.AddVar(writer, nil)\n\t\t\t} else {\n\t\t\t\tstmt.AddVar(writer, v.GormValue(stmt.Context, stmt.DB))\n\t\t\t}\n\t\tcase clause.Interface:\n\t\t\tc := clause.Clause{Name: v.Name()}\n\t\t\tv.MergeClause(&c)\n\t\t\tc.Build(stmt)\n\t\tcase clause.Expression:\n\t\t\tv.Build(stmt)\n\t\tcase driver.Valuer:\n\t\t\tstmt.Vars = append(stmt.Vars, v)\n\t\t\tstmt.DB.Dialector.BindVarTo(writer, stmt, v)\n\t\tcase []byte:\n\t\t\tstmt.Vars = append(stmt.Vars, v)\n\t\t\tstmt.DB.Dialector.BindVarTo(writer, stmt, v)\n\t\tcase []interface{}:\n\t\t\tif len(v) > 0 {\n\t\t\t\twriter.WriteByte('(')\n\t\t\t\tstmt.AddVar(writer, v...)\n\t\t\t\twriter.WriteByte(')')\n\t\t\t} else {\n\t\t\t\twriter.WriteString(\"(NULL)\")\n\t\t\t}\n\t\tcase *DB:\n\t\t\tsubdb := v.Session(&Session{Logger: logger.Discard, DryRun: true}).getInstance()\n\t\t\tif v.Statement.SQL.Len() > 0 {\n\t\t\t\tvar (\n\t\t\t\t\tvars = subdb.Statement.Vars\n\t\t\t\t\tsql  = v.Statement.SQL.String()\n\t\t\t\t)\n\n\t\t\t\tsubdb.Statement.Vars = make([]interface{}, 0, len(vars))\n\t\t\t\tfor _, vv := range vars {\n\t\t\t\t\tsubdb.Statement.Vars = append(subdb.Statement.Vars, vv)\n\t\t\t\t\tbindvar := strings.Builder{}\n\t\t\t\t\tv.Dialector.BindVarTo(&bindvar, subdb.Statement, vv)\n\t\t\t\t\tsql = strings.Replace(sql, bindvar.String(), \"?\", 1)\n\t\t\t\t}\n\n\t\t\t\tsubdb.Statement.SQL.Reset()\n\t\t\t\tsubdb.Statement.Vars = stmt.Vars\n\t\t\t\tif strings.Contains(sql, \"@\") {\n\t\t\t\t\tclause.NamedExpr{SQL: sql, Vars: vars}.Build(subdb.Statement)\n\t\t\t\t} else {\n\t\t\t\t\tclause.Expr{SQL: sql, Vars: vars}.Build(subdb.Statement)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsubdb.Statement.Vars = append(stmt.Vars, subdb.Statement.Vars...)\n\t\t\t\tsubdb.callbacks.Query().Execute(subdb)\n\t\t\t}\n\n\t\t\twriter.WriteString(subdb.Statement.SQL.String())\n\t\t\tstmt.Vars = subdb.Statement.Vars\n\t\tdefault:\n\t\t\tswitch rv := reflect.ValueOf(v); rv.Kind() {\n\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\tif rv.Len() == 0 {\n\t\t\t\t\twriter.WriteString(\"(NULL)\")\n\t\t\t\t} else if rv.Type().Elem() == reflect.TypeOf(uint8(0)) {\n\t\t\t\t\tstmt.Vars = append(stmt.Vars, v)\n\t\t\t\t\tstmt.DB.Dialector.BindVarTo(writer, stmt, v)\n\t\t\t\t} else {\n\t\t\t\t\twriter.WriteByte('(')\n\t\t\t\t\tfor i := 0; i < rv.Len(); i++ {\n\t\t\t\t\t\tif i > 0 {\n\t\t\t\t\t\t\twriter.WriteByte(',')\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstmt.AddVar(writer, rv.Index(i).Interface())\n\t\t\t\t\t}\n\t\t\t\t\twriter.WriteByte(')')\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tstmt.Vars = append(stmt.Vars, v)\n\t\t\t\tstmt.DB.Dialector.BindVarTo(writer, stmt, v)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// AddClause add clause\nfunc (stmt *Statement) AddClause(v clause.Interface) {\n\tif optimizer, ok := v.(StatementModifier); ok {\n\t\toptimizer.ModifyStatement(stmt)\n\t} else {\n\t\tname := v.Name()\n\t\tc := stmt.Clauses[name]\n\t\tc.Name = name\n\t\tv.MergeClause(&c)\n\t\tstmt.Clauses[name] = c\n\t}\n}\n\n// AddClauseIfNotExists add clause if not exists\nfunc (stmt *Statement) AddClauseIfNotExists(v clause.Interface) {\n\tif c, ok := stmt.Clauses[v.Name()]; !ok || c.Expression == nil {\n\t\tstmt.AddClause(v)\n\t}\n}\n\n// BuildCondition build condition\nfunc (stmt *Statement) BuildCondition(query interface{}, args ...interface{}) []clause.Expression {\n\tif s, ok := query.(string); ok {\n\t\t// if it is a number, then treats it as primary key\n\t\tif _, err := strconv.Atoi(s); err != nil {\n\t\t\tif s == \"\" && len(args) == 0 {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif len(args) == 0 || (len(args) > 0 && strings.Contains(s, \"?\")) {\n\t\t\t\t// looks like a where condition\n\t\t\t\treturn []clause.Expression{clause.Expr{SQL: s, Vars: args}}\n\t\t\t}\n\n\t\t\tif len(args) > 0 && strings.Contains(s, \"@\") {\n\t\t\t\t// looks like a named query\n\t\t\t\treturn []clause.Expression{clause.NamedExpr{SQL: s, Vars: args}}\n\t\t\t}\n\n\t\t\tif strings.Contains(strings.TrimSpace(s), \" \") {\n\t\t\t\t// looks like a where condition\n\t\t\t\treturn []clause.Expression{clause.Expr{SQL: s, Vars: args}}\n\t\t\t}\n\n\t\t\tif len(args) == 1 {\n\t\t\t\treturn []clause.Expression{clause.Eq{Column: s, Value: args[0]}}\n\t\t\t}\n\t\t}\n\t}\n\n\tconds := make([]clause.Expression, 0, 4)\n\targs = append([]interface{}{query}, args...)\n\tfor idx, arg := range args {\n\t\tif arg == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif valuer, ok := arg.(driver.Valuer); ok {\n\t\t\targ, _ = valuer.Value()\n\t\t}\n\n\t\tswitch v := arg.(type) {\n\t\tcase clause.Expression:\n\t\t\tconds = append(conds, v)\n\t\tcase *DB:\n\t\t\tv.executeScopes()\n\n\t\t\tif cs, ok := v.Statement.Clauses[\"WHERE\"]; ok {\n\t\t\t\tif where, ok := cs.Expression.(clause.Where); ok {\n\t\t\t\t\tif len(where.Exprs) == 1 {\n\t\t\t\t\t\tif orConds, ok := where.Exprs[0].(clause.OrConditions); ok {\n\t\t\t\t\t\t\twhere.Exprs[0] = clause.AndConditions(orConds)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconds = append(conds, clause.And(where.Exprs...))\n\t\t\t\t} else if cs.Expression != nil {\n\t\t\t\t\tconds = append(conds, cs.Expression)\n\t\t\t\t}\n\t\t\t}\n\t\tcase map[interface{}]interface{}:\n\t\t\tfor i, j := range v {\n\t\t\t\tconds = append(conds, clause.Eq{Column: i, Value: j})\n\t\t\t}\n\t\tcase map[string]string:\n\t\t\tkeys := make([]string, 0, len(v))\n\t\t\tfor i := range v {\n\t\t\t\tkeys = append(keys, i)\n\t\t\t}\n\t\t\tsort.Strings(keys)\n\n\t\t\tfor _, key := range keys {\n\t\t\t\tconds = append(conds, clause.Eq{Column: key, Value: v[key]})\n\t\t\t}\n\t\tcase map[string]interface{}:\n\t\t\tkeys := make([]string, 0, len(v))\n\t\t\tfor i := range v {\n\t\t\t\tkeys = append(keys, i)\n\t\t\t}\n\t\t\tsort.Strings(keys)\n\n\t\t\tfor _, key := range keys {\n\t\t\t\treflectValue := reflect.Indirect(reflect.ValueOf(v[key]))\n\t\t\t\tswitch reflectValue.Kind() {\n\t\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\t\tif _, ok := v[key].(driver.Valuer); ok {\n\t\t\t\t\t\tconds = append(conds, clause.Eq{Column: key, Value: v[key]})\n\t\t\t\t\t} else if _, ok := v[key].(Valuer); ok {\n\t\t\t\t\t\tconds = append(conds, clause.Eq{Column: key, Value: v[key]})\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// optimize reflect value length\n\t\t\t\t\t\tvalueLen := reflectValue.Len()\n\t\t\t\t\t\tvalues := make([]interface{}, valueLen)\n\t\t\t\t\t\tfor i := 0; i < valueLen; i++ {\n\t\t\t\t\t\t\tvalues[i] = reflectValue.Index(i).Interface()\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconds = append(conds, clause.IN{Column: key, Values: values})\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tconds = append(conds, clause.Eq{Column: key, Value: v[key]})\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\treflectValue := reflect.Indirect(reflect.ValueOf(arg))\n\t\t\tfor reflectValue.Kind() == reflect.Ptr {\n\t\t\t\treflectValue = reflectValue.Elem()\n\t\t\t}\n\n\t\t\tif s, err := schema.Parse(arg, stmt.DB.cacheStore, stmt.DB.NamingStrategy); err == nil {\n\t\t\t\tselectedColumns := map[string]bool{}\n\t\t\t\tif idx == 0 {\n\t\t\t\t\tfor _, v := range args[1:] {\n\t\t\t\t\t\tif vs, ok := v.(string); ok {\n\t\t\t\t\t\t\tselectedColumns[vs] = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trestricted := len(selectedColumns) != 0\n\n\t\t\t\tswitch reflectValue.Kind() {\n\t\t\t\tcase reflect.Struct:\n\t\t\t\t\tfor _, field := range s.Fields {\n\t\t\t\t\t\tselected := selectedColumns[field.DBName] || selectedColumns[field.Name]\n\t\t\t\t\t\tif selected || (!restricted && field.Readable) {\n\t\t\t\t\t\t\tif v, isZero := field.ValueOf(stmt.Context, reflectValue); !isZero || selected {\n\t\t\t\t\t\t\t\tif field.DBName != \"\" {\n\t\t\t\t\t\t\t\t\tconds = append(conds, clause.Eq{Column: clause.Column{Table: clause.CurrentTable, Name: field.DBName}, Value: v})\n\t\t\t\t\t\t\t\t} else if field.DataType != \"\" {\n\t\t\t\t\t\t\t\t\tconds = append(conds, clause.Eq{Column: clause.Column{Table: clause.CurrentTable, Name: field.Name}, Value: v})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\t\tfor i := 0; i < reflectValue.Len(); i++ {\n\t\t\t\t\t\tfor _, field := range s.Fields {\n\t\t\t\t\t\t\tselected := selectedColumns[field.DBName] || selectedColumns[field.Name]\n\t\t\t\t\t\t\tif selected || (!restricted && field.Readable) {\n\t\t\t\t\t\t\t\tif v, isZero := field.ValueOf(stmt.Context, reflectValue.Index(i)); !isZero || selected {\n\t\t\t\t\t\t\t\t\tif field.DBName != \"\" {\n\t\t\t\t\t\t\t\t\t\tconds = append(conds, clause.Eq{Column: clause.Column{Table: clause.CurrentTable, Name: field.DBName}, Value: v})\n\t\t\t\t\t\t\t\t\t} else if field.DataType != \"\" {\n\t\t\t\t\t\t\t\t\t\tconds = append(conds, clause.Eq{Column: clause.Column{Table: clause.CurrentTable, Name: field.Name}, Value: v})\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif restricted {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else if !reflectValue.IsValid() {\n\t\t\t\tstmt.AddError(ErrInvalidData)\n\t\t\t} else if len(conds) == 0 {\n\t\t\t\tif len(args) == 1 {\n\t\t\t\t\tswitch reflectValue.Kind() {\n\t\t\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\t\t\t// optimize reflect value length\n\t\t\t\t\t\tvalueLen := reflectValue.Len()\n\t\t\t\t\t\tvalues := make([]interface{}, valueLen)\n\t\t\t\t\t\tfor i := 0; i < valueLen; i++ {\n\t\t\t\t\t\t\tvalues[i] = reflectValue.Index(i).Interface()\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif len(values) > 0 {\n\t\t\t\t\t\t\tconds = append(conds, clause.IN{Column: clause.PrimaryColumn, Values: values})\n\t\t\t\t\t\t\treturn []clause.Expression{clause.And(conds...)}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconds = append(conds, clause.IN{Column: clause.PrimaryColumn, Values: args})\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(conds) > 0 {\n\t\treturn []clause.Expression{clause.And(conds...)}\n\t}\n\treturn nil\n}\n\n// Build build sql with clauses names\nfunc (stmt *Statement) Build(clauses ...string) {\n\tvar firstClauseWritten bool\n\n\tfor _, name := range clauses {\n\t\tif c, ok := stmt.Clauses[name]; ok {\n\t\t\tif firstClauseWritten {\n\t\t\t\tstmt.WriteByte(' ')\n\t\t\t}\n\n\t\t\tfirstClauseWritten = true\n\t\t\tif b, ok := stmt.DB.ClauseBuilders[name]; ok {\n\t\t\t\tb(c, stmt)\n\t\t\t} else {\n\t\t\t\tc.Build(stmt)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (stmt *Statement) Parse(value interface{}) (err error) {\n\treturn stmt.ParseWithSpecialTableName(value, \"\")\n}\n\nfunc (stmt *Statement) ParseWithSpecialTableName(value interface{}, specialTableName string) (err error) {\n\tif stmt.Schema, err = schema.ParseWithSpecialTableName(value, stmt.DB.cacheStore, stmt.DB.NamingStrategy, specialTableName); err == nil && stmt.Table == \"\" {\n\t\tif tables := strings.Split(stmt.Schema.Table, \".\"); len(tables) == 2 {\n\t\t\tstmt.TableExpr = &clause.Expr{SQL: stmt.Quote(stmt.Schema.Table)}\n\t\t\tstmt.Table = tables[1]\n\t\t\treturn\n\t\t}\n\n\t\tstmt.Table = stmt.Schema.Table\n\t}\n\treturn err\n}\n\nfunc (stmt *Statement) clone() *Statement {\n\tnewStmt := &Statement{\n\t\tTableExpr:            stmt.TableExpr,\n\t\tTable:                stmt.Table,\n\t\tModel:                stmt.Model,\n\t\tUnscoped:             stmt.Unscoped,\n\t\tDest:                 stmt.Dest,\n\t\tReflectValue:         stmt.ReflectValue,\n\t\tClauses:              map[string]clause.Clause{},\n\t\tDistinct:             stmt.Distinct,\n\t\tSelects:              stmt.Selects,\n\t\tOmits:                stmt.Omits,\n\t\tColumnMapping:        stmt.ColumnMapping,\n\t\tPreloads:             map[string][]interface{}{},\n\t\tConnPool:             stmt.ConnPool,\n\t\tSchema:               stmt.Schema,\n\t\tContext:              stmt.Context,\n\t\tRaiseErrorOnNotFound: stmt.RaiseErrorOnNotFound,\n\t\tSkipHooks:            stmt.SkipHooks,\n\t}\n\n\tif stmt.SQL.Len() > 0 {\n\t\tnewStmt.SQL.WriteString(stmt.SQL.String())\n\t\tnewStmt.Vars = make([]interface{}, 0, len(stmt.Vars))\n\t\tnewStmt.Vars = append(newStmt.Vars, stmt.Vars...)\n\t}\n\n\tfor k, c := range stmt.Clauses {\n\t\tnewStmt.Clauses[k] = c\n\t}\n\n\tfor k, p := range stmt.Preloads {\n\t\tnewStmt.Preloads[k] = p\n\t}\n\n\tif len(stmt.Joins) > 0 {\n\t\tnewStmt.Joins = make([]join, len(stmt.Joins))\n\t\tcopy(newStmt.Joins, stmt.Joins)\n\t}\n\n\tif len(stmt.scopes) > 0 {\n\t\tnewStmt.scopes = make([]func(*DB) *DB, len(stmt.scopes))\n\t\tcopy(newStmt.scopes, stmt.scopes)\n\t}\n\n\tstmt.Settings.Range(func(k, v interface{}) bool {\n\t\tnewStmt.Settings.Store(k, v)\n\t\treturn true\n\t})\n\n\treturn newStmt\n}\n\n// SetColumn set column's value\n//\n//\tstmt.SetColumn(\"Name\", \"jinzhu\") // Hooks Method\n//\tstmt.SetColumn(\"Name\", \"jinzhu\", true) // Callbacks Method\nfunc (stmt *Statement) SetColumn(name string, value interface{}, fromCallbacks ...bool) {\n\tif v, ok := stmt.Dest.(map[string]interface{}); ok {\n\t\tv[name] = value\n\t} else if v, ok := stmt.Dest.([]map[string]interface{}); ok {\n\t\tfor _, m := range v {\n\t\t\tm[name] = value\n\t\t}\n\t} else if stmt.Schema != nil {\n\t\tif field := stmt.Schema.LookUpField(name); field != nil {\n\t\t\tdestValue := reflect.ValueOf(stmt.Dest)\n\t\t\tfor destValue.Kind() == reflect.Ptr {\n\t\t\t\tdestValue = destValue.Elem()\n\t\t\t}\n\n\t\t\tif stmt.ReflectValue != destValue {\n\t\t\t\tif !destValue.CanAddr() {\n\t\t\t\t\tdestValueCanAddr := reflect.New(destValue.Type())\n\t\t\t\t\tdestValueCanAddr.Elem().Set(destValue)\n\t\t\t\t\tstmt.Dest = destValueCanAddr.Interface()\n\t\t\t\t\tdestValue = destValueCanAddr.Elem()\n\t\t\t\t}\n\n\t\t\t\tswitch destValue.Kind() {\n\t\t\t\tcase reflect.Struct:\n\t\t\t\t\tstmt.AddError(field.Set(stmt.Context, destValue, value))\n\t\t\t\tdefault:\n\t\t\t\t\tstmt.AddError(ErrInvalidData)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch stmt.ReflectValue.Kind() {\n\t\t\tcase reflect.Slice, reflect.Array:\n\t\t\t\tif len(fromCallbacks) > 0 {\n\t\t\t\t\tfor i := 0; i < stmt.ReflectValue.Len(); i++ {\n\t\t\t\t\t\tstmt.AddError(field.Set(stmt.Context, stmt.ReflectValue.Index(i), value))\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstmt.AddError(field.Set(stmt.Context, stmt.ReflectValue.Index(stmt.CurDestIndex), value))\n\t\t\t\t}\n\t\t\tcase reflect.Struct:\n\t\t\t\tif !stmt.ReflectValue.CanAddr() {\n\t\t\t\t\tstmt.AddError(ErrInvalidValue)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tstmt.AddError(field.Set(stmt.Context, stmt.ReflectValue, value))\n\t\t\t}\n\t\t} else {\n\t\t\tstmt.AddError(ErrInvalidField)\n\t\t}\n\t} else {\n\t\tstmt.AddError(ErrInvalidField)\n\t}\n}\n\n// Changed check model changed or not when updating\nfunc (stmt *Statement) Changed(fields ...string) bool {\n\tmodelValue := stmt.ReflectValue\n\tswitch modelValue.Kind() {\n\tcase reflect.Slice, reflect.Array:\n\t\tmodelValue = stmt.ReflectValue.Index(stmt.CurDestIndex)\n\t}\n\n\tselectColumns, restricted := stmt.SelectAndOmitColumns(false, true)\n\tchanged := func(field *schema.Field) bool {\n\t\tfieldValue, _ := field.ValueOf(stmt.Context, modelValue)\n\t\tif v, ok := selectColumns[field.DBName]; (ok && v) || (!ok && !restricted) {\n\t\t\tif mv, mok := stmt.Dest.(map[string]interface{}); mok {\n\t\t\t\tif fv, ok := mv[field.Name]; ok {\n\t\t\t\t\treturn !utils.AssertEqual(fv, fieldValue)\n\t\t\t\t} else if fv, ok := mv[field.DBName]; ok {\n\t\t\t\t\treturn !utils.AssertEqual(fv, fieldValue)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdestValue := reflect.ValueOf(stmt.Dest)\n\t\t\t\tfor destValue.Kind() == reflect.Ptr {\n\t\t\t\t\tdestValue = destValue.Elem()\n\t\t\t\t}\n\n\t\t\t\tchangedValue, zero := field.ValueOf(stmt.Context, destValue)\n\t\t\t\tif v {\n\t\t\t\t\treturn !utils.AssertEqual(changedValue, fieldValue)\n\t\t\t\t}\n\t\t\t\treturn !zero && !utils.AssertEqual(changedValue, fieldValue)\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tif len(fields) == 0 {\n\t\tfor _, field := range stmt.Schema.FieldsByDBName {\n\t\t\tif changed(field) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor _, name := range fields {\n\t\t\tif field := stmt.Schema.LookUpField(name); field != nil {\n\t\t\t\tif changed(field) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false\n}\n\nvar matchName = func() func(tableColumn string) (table, column string) {\n\tnameMatcher := regexp.MustCompile(`^(?:\\W?(\\w+?)\\W?\\.)?(?:(\\*)|\\W?(\\w+?)\\W?)$`)\n\treturn func(tableColumn string) (table, column string) {\n\t\tif matches := nameMatcher.FindStringSubmatch(tableColumn); len(matches) == 4 {\n\t\t\ttable = matches[1]\n\t\t\tstar := matches[2]\n\t\t\tcolumnName := matches[3]\n\t\t\tif star != \"\" {\n\t\t\t\treturn table, star\n\t\t\t}\n\t\t\treturn table, columnName\n\t\t}\n\t\treturn \"\", \"\"\n\t}\n}()\n\n// SelectAndOmitColumns get select and omit columns, select -> true, omit -> false\nfunc (stmt *Statement) SelectAndOmitColumns(requireCreate, requireUpdate bool) (map[string]bool, bool) {\n\tresults := map[string]bool{}\n\tnotRestricted := false\n\n\tprocessColumn := func(column string, result bool) {\n\t\tif stmt.Schema == nil {\n\t\t\tresults[column] = result\n\t\t} else if column == \"*\" {\n\t\t\tnotRestricted = result\n\t\t\tfor _, dbName := range stmt.Schema.DBNames {\n\t\t\t\tresults[dbName] = result\n\t\t\t}\n\t\t} else if column == clause.Associations {\n\t\t\tfor _, rel := range stmt.Schema.Relationships.Relations {\n\t\t\t\tresults[rel.Name] = result\n\t\t\t}\n\t\t} else if field := stmt.Schema.LookUpField(column); field != nil && field.DBName != \"\" {\n\t\t\tresults[field.DBName] = result\n\t\t} else if table, col := matchName(column); col != \"\" && (table == stmt.Table || table == \"\") {\n\t\t\tif col == \"*\" {\n\t\t\t\tfor _, dbName := range stmt.Schema.DBNames {\n\t\t\t\t\tresults[dbName] = result\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresults[col] = result\n\t\t\t}\n\t\t} else {\n\t\t\tresults[column] = result\n\t\t}\n\t}\n\n\t// select columns\n\tfor _, column := range stmt.Selects {\n\t\tprocessColumn(column, true)\n\t}\n\n\t// omit columns\n\tfor _, column := range stmt.Omits {\n\t\tprocessColumn(column, false)\n\t}\n\n\tif stmt.Schema != nil {\n\t\tfor _, field := range stmt.Schema.FieldsByName {\n\t\t\tname := field.DBName\n\t\t\tif name == \"\" {\n\t\t\t\tname = field.Name\n\t\t\t}\n\n\t\t\tif requireCreate && !field.Creatable {\n\t\t\t\tresults[name] = false\n\t\t\t} else if requireUpdate && !field.Updatable {\n\t\t\t\tresults[name] = false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn results, !notRestricted && len(stmt.Selects) > 0\n}\n"
        },
        {
          "name": "statement_test.go",
          "type": "blob",
          "size": 1.884765625,
          "content": "package gorm\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"gorm.io/gorm/clause\"\n)\n\nfunc TestWhereCloneCorruption(t *testing.T) {\n\tfor whereCount := 1; whereCount <= 8; whereCount++ {\n\t\tt.Run(fmt.Sprintf(\"w=%d\", whereCount), func(t *testing.T) {\n\t\t\ts := new(Statement)\n\t\t\tfor w := 0; w < whereCount; w++ {\n\t\t\t\ts = s.clone()\n\t\t\t\ts.AddClause(clause.Where{\n\t\t\t\t\tExprs: s.BuildCondition(fmt.Sprintf(\"where%d\", w)),\n\t\t\t\t})\n\t\t\t}\n\n\t\t\ts1 := s.clone()\n\t\t\ts1.AddClause(clause.Where{\n\t\t\t\tExprs: s.BuildCondition(\"FINAL1\"),\n\t\t\t})\n\t\t\ts2 := s.clone()\n\t\t\ts2.AddClause(clause.Where{\n\t\t\t\tExprs: s.BuildCondition(\"FINAL2\"),\n\t\t\t})\n\n\t\t\tif reflect.DeepEqual(s1.Clauses[\"WHERE\"], s2.Clauses[\"WHERE\"]) {\n\t\t\t\tt.Errorf(\"Where conditions should be different\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNilCondition(t *testing.T) {\n\ts := new(Statement)\n\tif len(s.BuildCondition(nil)) != 0 {\n\t\tt.Errorf(\"Nil condition should be empty\")\n\t}\n}\n\nfunc TestNameMatcher(t *testing.T) {\n\tfor k, v := range map[string][]string{\n\t\t\"table.name\":         {\"table\", \"name\"},\n\t\t\"`table`.`name`\":     {\"table\", \"name\"},\n\t\t\"'table'.'name'\":     {\"table\", \"name\"},\n\t\t\"'table'.name\":       {\"table\", \"name\"},\n\t\t\"table1.name_23\":     {\"table1\", \"name_23\"},\n\t\t\"`table_1`.`name23`\": {\"table_1\", \"name23\"},\n\t\t\"'table23'.'name_1'\": {\"table23\", \"name_1\"},\n\t\t\"'table23'.name1\":    {\"table23\", \"name1\"},\n\t\t\"'name1'\":            {\"\", \"name1\"},\n\t\t\"`name_1`\":           {\"\", \"name_1\"},\n\t\t\"`Name_1`\":           {\"\", \"Name_1\"},\n\t\t\"`Table`.`nAme`\":     {\"Table\", \"nAme\"},\n\t\t\"my_table.*\":         {\"my_table\", \"*\"},\n\t\t\"`my_table`.*\":       {\"my_table\", \"*\"},\n\t\t\"User__Company.*\":    {\"User__Company\", \"*\"},\n\t\t\"`User__Company`.*\":  {\"User__Company\", \"*\"},\n\t\t`\"User__Company\".*`:  {\"User__Company\", \"*\"},\n\t\t`\"table\".\"*\"`:        {\"\", \"\"},\n\t} {\n\t\tif table, column := matchName(k); table != v[0] || column != v[1] {\n\t\t\tt.Errorf(\"failed to match value: %v, got %v, expect: %v\", k, []string{table, column}, v)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}