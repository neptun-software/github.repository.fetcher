{
  "metadata": {
    "timestamp": 1736568139595,
    "page": 33,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "labstack/echo",
      "stars": 30255,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.4560546875,
          "content": "# EditorConfig coding styles definitions. For more information about the\n# properties used in this file, please see the EditorConfig documentation:\n# http://editorconfig.org/\n\n# indicate this is the root of the project\nroot = true\n\n[*]\ncharset = utf-8\n\nend_of_line = LF\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\nindent_style = space\nindent_size = 2\n\n[Makefile]\nindent_style = tab\n\n[*.md]\ntrim_trailing_whitespace = false\n\n[*.go]\nindent_style = tab\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.6748046875,
          "content": "# Automatically normalize line endings for all text-based files\n# http://git-scm.com/docs/gitattributes#_end_of_line_conversion\n* text=auto\n\n# For the following file types, normalize line endings to LF on checking and\n# prevent conversion to CRLF when they are checked out (this is required in\n# order to prevent newline related issues)\n.*      text eol=lf\n*.go    text eol=lf\n*.yml   text eol=lf\n*.html  text eol=lf\n*.css   text eol=lf\n*.js    text eol=lf\n*.json  text eol=lf\nLICENSE text eol=lf\n\n# Exclude `website` and `cookbook` from GitHub's language statistics\n# https://github.com/github/linguist#using-gitattributes\ncookbook/* linguist-documentation\nwebsite/* linguist-documentation\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.060546875,
          "content": ".DS_Store\ncoverage.txt\n_test\nvendor\n.idea\n*.iml\n*.out\n.vscode\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 28.5400390625,
          "content": "# Changelog\n\n## v4.13.3 - 2024-12-19\n\n**Security**\n\n* Update golang.org/x/net dependency [GO-2024-3333](https://pkg.go.dev/vuln/GO-2024-3333) in https://github.com/labstack/echo/pull/2722\n\n\n## v4.13.2 - 2024-12-12\n\n**Security**\n\n* Update dependencies (dependabot reports [GO-2024-3321](https://pkg.go.dev/vuln/GO-2024-3321)) in https://github.com/labstack/echo/pull/2721\n\n\n## v4.13.1 - 2024-12-11\n\n**Fixes**\n\n* Fix BindBody ignoring `Transfer-Encoding: chunked` requests by @178inaba in https://github.com/labstack/echo/pull/2717\n\n\n\n## v4.13.0 - 2024-12-04\n\n**BREAKING CHANGE** JWT Middleware Removed from Core use [labstack/echo-jwt](https://github.com/labstack/echo-jwt) instead\n\nThe JWT middleware has been **removed from Echo core** due to another security vulnerability, [CVE-2024-51744](https://nvd.nist.gov/vuln/detail/CVE-2024-51744). For more details, refer to issue [#2699](https://github.com/labstack/echo/issues/2699). A drop-in replacement is available in the [labstack/echo-jwt](https://github.com/labstack/echo-jwt) repository.\n\n**Important**: Direct assignments like `token := c.Get(\"user\").(*jwt.Token)` will now cause a panic due to an invalid cast. Update your code accordingly. Replace the current imports from `\"github.com/golang-jwt/jwt\"` in your handlers to the new middleware version using `\"github.com/golang-jwt/jwt/v5\"`.\n\n\nBackground: \n\nThe version of `golang-jwt/jwt` (v3.2.2) previously used in Echo core has been in an unmaintained state for some time. This is not the first vulnerability affecting this library; earlier issues were addressed in [PR #1946](https://github.com/labstack/echo/pull/1946).\nJWT middleware was marked as deprecated in Echo core as of [v4.10.0](https://github.com/labstack/echo/releases/tag/v4.10.0) on 2022-12-27. If you did not notice that, consider leveraging tools like [Staticcheck](https://staticcheck.dev/) to catch such deprecations earlier in you dev/CI flow.  For bonus points - check out [gosec](https://github.com/securego/gosec).\n\nWe sincerely apologize for any inconvenience caused by this change. While we strive to maintain backward compatibility within Echo core, recurring security issues with third-party dependencies have forced this decision.\n\n**Enhancements**\n\n* remove jwt middleware by @stevenwhitehead in https://github.com/labstack/echo/pull/2701\n* optimization: struct alignment by @behnambm in https://github.com/labstack/echo/pull/2636\n* bind: Maintain backwards compatibility for map[string]interface{} binding by @thesaltree in https://github.com/labstack/echo/pull/2656\n* Add Go 1.23 to CI by @aldas in https://github.com/labstack/echo/pull/2675\n* improve `MultipartForm` test by @martinyonatann in https://github.com/labstack/echo/pull/2682\n* `bind` : add support of multipart multi files by @martinyonatann in https://github.com/labstack/echo/pull/2684\n* Add TemplateRenderer struct to ease creating renderers for `html/template` and `text/template` packages. by @aldas in https://github.com/labstack/echo/pull/2690\n* Refactor TestBasicAuth to utilize table-driven test format by @ErikOlson in https://github.com/labstack/echo/pull/2688\n* Remove broken header by @aldas in https://github.com/labstack/echo/pull/2705\n* fix(bind body): content-length can be -1 by @phamvinhdat in https://github.com/labstack/echo/pull/2710\n* CORS middleware should compile allowOrigin regexp at creation by @aldas in https://github.com/labstack/echo/pull/2709\n* Shorten Github issue template and add test example by @aldas in https://github.com/labstack/echo/pull/2711\n\n\n## v4.12.0 - 2024-04-15\n\n**Security**\n\n* Update golang.org/x/net dep because of [GO-2024-2687](https://pkg.go.dev/vuln/GO-2024-2687) by @aldas in https://github.com/labstack/echo/pull/2625\n\n\n**Enhancements**\n\n* binder: make binding to Map work better with string destinations by @aldas in https://github.com/labstack/echo/pull/2554\n* README.md: add Encore as sponsor by @marcuskohlberg in https://github.com/labstack/echo/pull/2579\n* Reorder paragraphs in README.md by @aldas in https://github.com/labstack/echo/pull/2581\n* CI: upgrade actions/checkout to v4 by @aldas in https://github.com/labstack/echo/pull/2584\n* Remove default charset from 'application/json' Content-Type header by @doortts in https://github.com/labstack/echo/pull/2568\n* CI: Use Go 1.22 by @aldas in https://github.com/labstack/echo/pull/2588\n* binder: allow binding to a nil map by @georgmu in https://github.com/labstack/echo/pull/2574\n* Add Skipper Unit Test In BasicBasicAuthConfig and Add More Detail Explanation regarding BasicAuthValidator by @RyoKusnadi in https://github.com/labstack/echo/pull/2461\n* fix some typos by @teslaedison in https://github.com/labstack/echo/pull/2603\n* fix: some typos by @pomadev in https://github.com/labstack/echo/pull/2596\n* Allow ResponseWriters to unwrap writers when flushing/hijacking by @aldas in https://github.com/labstack/echo/pull/2595\n* Add SPDX licence comments to files.  by @aldas in https://github.com/labstack/echo/pull/2604\n* Upgrade deps by @aldas in https://github.com/labstack/echo/pull/2605\n* Change type definition blocks to single declarations. This helps copy… by @aldas in https://github.com/labstack/echo/pull/2606\n* Fix Real IP logic by @cl-bvl in https://github.com/labstack/echo/pull/2550\n* Default binder can use `UnmarshalParams(params []string) error` inter… by @aldas in https://github.com/labstack/echo/pull/2607\n* Default binder can bind pointer to slice as struct field. For example  `*[]string` by @aldas in https://github.com/labstack/echo/pull/2608\n* Remove maxparam dependence from Context by @aldas in https://github.com/labstack/echo/pull/2611\n* When route is registered with empty path it is normalized to `/`.  by @aldas in https://github.com/labstack/echo/pull/2616\n* proxy middleware should use httputil.ReverseProxy for SSE requests by @aldas in https://github.com/labstack/echo/pull/2624\n\n\n## v4.11.4 - 2023-12-20\n\n**Security**\n\n* Upgrade golang.org/x/crypto to v0.17.0 to fix vulnerability [issue](https://pkg.go.dev/vuln/GO-2023-2402) [#2562](https://github.com/labstack/echo/pull/2562)\n\n**Enhancements**\n\n* Update deps and mark Go version to 1.18 as this is what golang.org/x/* use [#2563](https://github.com/labstack/echo/pull/2563)\n* Request logger: add example for Slog https://pkg.go.dev/log/slog [#2543](https://github.com/labstack/echo/pull/2543)\n\n\n## v4.11.3 - 2023-11-07\n\n**Security**\n\n* 'c.Attachment' and 'c.Inline' should escape filename in 'Content-Disposition' header to avoid 'Reflect File Download' vulnerability. [#2541](https://github.com/labstack/echo/pull/2541)\n\n**Enhancements**\n\n* Tests: refactor context tests to be separate functions [#2540](https://github.com/labstack/echo/pull/2540)\n* Proxy middleware: reuse echo request context [#2537](https://github.com/labstack/echo/pull/2537)\n* Mark unmarshallable yaml struct tags as ignored [#2536](https://github.com/labstack/echo/pull/2536)\n\n\n## v4.11.2 - 2023-10-11\n\n**Security**\n\n* Bump golang.org/x/net to prevent CVE-2023-39325 / CVE-2023-44487 HTTP/2 Rapid Reset Attack [#2527](https://github.com/labstack/echo/pull/2527)\n* fix(sec): randomString bias introduced by #2490 [#2492](https://github.com/labstack/echo/pull/2492)\n* CSRF/RequestID mw: switch math/random usage to crypto/random [#2490](https://github.com/labstack/echo/pull/2490)\n\n**Enhancements**\n\n* Delete unused context in body_limit.go [#2483](https://github.com/labstack/echo/pull/2483)\n* Use Go 1.21 in CI [#2505](https://github.com/labstack/echo/pull/2505)\n* Fix some typos [#2511](https://github.com/labstack/echo/pull/2511)\n* Allow CORS middleware to send Access-Control-Max-Age: 0 [#2518](https://github.com/labstack/echo/pull/2518)\n* Bump dependancies [#2522](https://github.com/labstack/echo/pull/2522)\n\n## v4.11.1 - 2023-07-16\n\n**Fixes**\n\n* Fix `Gzip` middleware not sending response code for no content responses (404, 301/302 redirects etc) [#2481](https://github.com/labstack/echo/pull/2481)\n\n\n## v4.11.0 - 2023-07-14\n\n\n**Fixes**\n\n* Fixes the proxy middleware concurrency issue of calling the Next() proxy target on Round Robin Balancer [#2409](https://github.com/labstack/echo/pull/2409)\n* Fix `group.RouteNotFound` not working when group has attached middlewares [#2411](https://github.com/labstack/echo/pull/2411)\n* Fix global error handler return error message when message is an error [#2456](https://github.com/labstack/echo/pull/2456)\n* Do not use global timeNow variables [#2477](https://github.com/labstack/echo/pull/2477)\n\n\n**Enhancements**\n\n* Added a optional config variable to disable centralized error handler in recovery middleware [#2410](https://github.com/labstack/echo/pull/2410)\n* refactor: use `strings.ReplaceAll` directly [#2424](https://github.com/labstack/echo/pull/2424)\n* Add support for Go1.20 `http.rwUnwrapper` to Response struct [#2425](https://github.com/labstack/echo/pull/2425)\n* Check whether is nil before invoking centralized error handling [#2429](https://github.com/labstack/echo/pull/2429)\n* Proper colon support in `echo.Reverse` method [#2416](https://github.com/labstack/echo/pull/2416)\n* Fix misuses of a vs an in documentation comments [#2436](https://github.com/labstack/echo/pull/2436)\n* Add link to slog.Handler library for Echo logging into README.md [#2444](https://github.com/labstack/echo/pull/2444)\n* In proxy middleware Support retries of failed proxy requests [#2414](https://github.com/labstack/echo/pull/2414)\n* gofmt fixes to comments [#2452](https://github.com/labstack/echo/pull/2452)\n* gzip response only if it exceeds a minimal length [#2267](https://github.com/labstack/echo/pull/2267)\n* Upgrade packages [#2475](https://github.com/labstack/echo/pull/2475)\n\n\n## v4.10.2 - 2023-02-22\n\n**Security**\n\n* `filepath.Clean` behaviour has changed in Go 1.20 - adapt to it [#2406](https://github.com/labstack/echo/pull/2406)\n* Add `middleware.CORSConfig.UnsafeWildcardOriginWithAllowCredentials` to make UNSAFE usages of wildcard origin + allow cretentials less likely [#2405](https://github.com/labstack/echo/pull/2405)\n\n**Enhancements**\n\n* Add more HTTP error values [#2277](https://github.com/labstack/echo/pull/2277)\n\n\n## v4.10.1 - 2023-02-19\n\n**Security**\n\n* Upgrade deps due to the latest golang.org/x/net vulnerability [#2402](https://github.com/labstack/echo/pull/2402)\n\n\n**Enhancements**\n\n* Add new JWT repository to the README [#2377](https://github.com/labstack/echo/pull/2377)\n* Return an empty string for ctx.path if there is no registered path [#2385](https://github.com/labstack/echo/pull/2385)\n* Add context timeout middleware [#2380](https://github.com/labstack/echo/pull/2380)\n* Update link to jaegertracing [#2394](https://github.com/labstack/echo/pull/2394)\n\n\n## v4.10.0 - 2022-12-27\n\n**Security**\n\n* We are deprecating JWT middleware in this repository. Please use https://github.com/labstack/echo-jwt instead. \n\n  JWT middleware is moved to separate repository to allow us to bump/upgrade version of JWT implementation (`github.com/golang-jwt/jwt`) we are using\nwhich we can not do in Echo core because this would break backwards compatibility guarantees we try to maintain.\n\n* This minor version bumps minimum Go version to 1.17 (from 1.16) due `golang.org/x/` packages we depend on. There are\n  several vulnerabilities fixed in these libraries.\n\n  Echo still tries to support last 4 Go versions but there are occasions we can not guarantee this promise.\n\n\n**Enhancements**\n\n* Bump x/text to 0.3.8 [#2305](https://github.com/labstack/echo/pull/2305)\n* Bump dependencies and add notes about Go releases we support [#2336](https://github.com/labstack/echo/pull/2336)\n* Add helper interface for ProxyBalancer interface [#2316](https://github.com/labstack/echo/pull/2316)\n* Expose `middleware.CreateExtractors` function so we can use it from echo-contrib repository [#2338](https://github.com/labstack/echo/pull/2338)\n* Refactor func(Context) error to HandlerFunc [#2315](https://github.com/labstack/echo/pull/2315)\n* Improve function comments [#2329](https://github.com/labstack/echo/pull/2329)\n* Add new method HTTPError.WithInternal [#2340](https://github.com/labstack/echo/pull/2340)\n* Replace io/ioutil package usages [#2342](https://github.com/labstack/echo/pull/2342)\n* Add staticcheck to CI flow [#2343](https://github.com/labstack/echo/pull/2343)\n* Replace relative path determination from proprietary to std [#2345](https://github.com/labstack/echo/pull/2345)\n* Remove square brackets from ipv6 addresses in XFF (X-Forwarded-For header) [#2182](https://github.com/labstack/echo/pull/2182)\n* Add testcases for some BodyLimit middleware configuration options [#2350](https://github.com/labstack/echo/pull/2350)\n* Additional configuration options for RequestLogger and Logger middleware [#2341](https://github.com/labstack/echo/pull/2341)\n* Add route to request log [#2162](https://github.com/labstack/echo/pull/2162)\n* GitHub Workflows security hardening [#2358](https://github.com/labstack/echo/pull/2358)\n* Add govulncheck to CI and bump dependencies [#2362](https://github.com/labstack/echo/pull/2362)\n* Fix rate limiter docs [#2366](https://github.com/labstack/echo/pull/2366)\n* Refactor how `e.Routes()` work and introduce `e.OnAddRouteHandler` callback [#2337](https://github.com/labstack/echo/pull/2337)\n\n\n## v4.9.1 - 2022-10-12\n\n**Fixes**\n\n* Fix logger panicing (when template is set to empty) by bumping dependency version [#2295](https://github.com/labstack/echo/issues/2295)\n\n**Enhancements**\n\n* Improve CORS documentation [#2272](https://github.com/labstack/echo/pull/2272)\n* Update readme about supported Go versions [#2291](https://github.com/labstack/echo/pull/2291)\n* Tests: improve error handling on closing body [#2254](https://github.com/labstack/echo/pull/2254)\n* Tests: refactor some of the assertions in tests [#2275](https://github.com/labstack/echo/pull/2275)\n* Tests: refactor assertions [#2301](https://github.com/labstack/echo/pull/2301)\n\n## v4.9.0 - 2022-09-04\n\n**Security**\n\n* Fix open redirect vulnerability in handlers serving static directories (e.Static, e.StaticFs, echo.StaticDirectoryHandler) [#2260](https://github.com/labstack/echo/pull/2260)\n\n**Enhancements**\n\n* Allow configuring ErrorHandler in CSRF middleware [#2257](https://github.com/labstack/echo/pull/2257)\n* Replace HTTP method constants in tests with stdlib constants [#2247](https://github.com/labstack/echo/pull/2247)\n\n\n## v4.8.0 - 2022-08-10\n\n**Most notable things**\n\nYou can now add any arbitrary HTTP method type as a route [#2237](https://github.com/labstack/echo/pull/2237)\n```go\ne.Add(\"COPY\", \"/*\", func(c echo.Context) error \n  return c.String(http.StatusOK, \"OK COPY\")\n})\n```\n\nYou can add custom 404 handler for specific paths [#2217](https://github.com/labstack/echo/pull/2217)\n```go\ne.RouteNotFound(\"/*\", func(c echo.Context) error { return c.NoContent(http.StatusNotFound) })\n\ng := e.Group(\"/images\")\ng.RouteNotFound(\"/*\", func(c echo.Context) error { return c.NoContent(http.StatusNotFound) })\n```\n\n**Enhancements**\n\n* Add new value binding methods (UnixTimeMilli,TextUnmarshaler,JSONUnmarshaler) to Valuebinder [#2127](https://github.com/labstack/echo/pull/2127)\n* Refactor: body_limit middleware unit test [#2145](https://github.com/labstack/echo/pull/2145)\n* Refactor: Timeout mw: rework how test waits for timeout. [#2187](https://github.com/labstack/echo/pull/2187)\n* BasicAuth middleware returns 500 InternalServerError on invalid base64 strings but should return 400 [#2191](https://github.com/labstack/echo/pull/2191)\n* Refactor: duplicated findStaticChild process at findChildWithLabel [#2176](https://github.com/labstack/echo/pull/2176)\n* Allow different param names in different methods with same path scheme [#2209](https://github.com/labstack/echo/pull/2209)\n* Add support for registering handlers for different 404 routes [#2217](https://github.com/labstack/echo/pull/2217)\n* Middlewares should use errors.As() instead of type assertion on HTTPError [#2227](https://github.com/labstack/echo/pull/2227)\n* Allow arbitrary HTTP method types to be added as routes [#2237](https://github.com/labstack/echo/pull/2237)\n\n## v4.7.2 - 2022-03-16\n\n**Fixes**\n\n* Fix nil pointer exception when calling Start again after address binding error [#2131](https://github.com/labstack/echo/pull/2131)\n* Fix CSRF middleware not being able to extract token from multipart/form-data form [#2136](https://github.com/labstack/echo/pull/2136)\n* Fix Timeout middleware write race [#2126](https://github.com/labstack/echo/pull/2126)\n\n**Enhancements**\n\n* Recover middleware should not log panic for aborted handler [#2134](https://github.com/labstack/echo/pull/2134)\n\n\n## v4.7.1 - 2022-03-13\n\n**Fixes**\n\n* Fix `e.Static`, `.File()`, `c.Attachment()` being picky with paths starting with `./`, `../` and `/` after 4.7.0 introduced echo.Filesystem support (Go1.16+) [#2123](https://github.com/labstack/echo/pull/2123)\n\n**Enhancements**\n\n* Remove some unused code [#2116](https://github.com/labstack/echo/pull/2116)\n\n\n## v4.7.0 - 2022-03-01\n\n**Enhancements**\n\n* Add JWT, KeyAuth, CSRF multivalue extractors [#2060](https://github.com/labstack/echo/pull/2060)\n* Add LogErrorFunc to recover middleware [#2072](https://github.com/labstack/echo/pull/2072)\n* Add support for HEAD method query params binding [#2027](https://github.com/labstack/echo/pull/2027)\n* Improve filesystem support with echo.FileFS, echo.StaticFS, group.FileFS, group.StaticFS [#2064](https://github.com/labstack/echo/pull/2064)\n\n**Fixes**\n\n* Fix X-Real-IP bug, improve tests [#2007](https://github.com/labstack/echo/pull/2007)\n* Minor syntax fixes [#1994](https://github.com/labstack/echo/pull/1994), [#2102](https://github.com/labstack/echo/pull/2102), [#2102](https://github.com/labstack/echo/pull/2102)\n\n**General**\n\n* Add cache-control and connection headers [#2103](https://github.com/labstack/echo/pull/2103)\n* Add Retry-After header constant [#2078](https://github.com/labstack/echo/pull/2078)\n* Upgrade `go` directive in `go.mod` to 1.17 [#2049](https://github.com/labstack/echo/pull/2049)\n* Add Pagoda [#2077](https://github.com/labstack/echo/pull/2077) and Souin [#2069](https://github.com/labstack/echo/pull/2069) to 3rd-party middlewares in README\n\n## v4.6.3 - 2022-01-10\n\n**Fixes**\n\n* Fixed Echo version number in greeting message which was not incremented to `4.6.2` [#2066](https://github.com/labstack/echo/issues/2066)\n\n\n## v4.6.2 - 2022-01-08\n\n**Fixes**\n\n* Fixed route containing escaped colon should be matchable but is not matched to request path [#2047](https://github.com/labstack/echo/pull/2047)\n* Fixed a problem that returned wrong content-encoding when the gzip compressed content was empty. [#1921](https://github.com/labstack/echo/pull/1921)\n* Update (test) dependencies [#2021](https://github.com/labstack/echo/pull/2021)\n\n\n**Enhancements**\n\n* Add support for configurable target header for the request_id middleware [#2040](https://github.com/labstack/echo/pull/2040)\n* Change decompress middleware to use stream decompression instead of buffering [#2018](https://github.com/labstack/echo/pull/2018)\n* Documentation updates\n\n\n## v4.6.1 - 2021-09-26\n\n**Enhancements**\n\n* Add start time to request logger middleware values [#1991](https://github.com/labstack/echo/pull/1991)\n\n## v4.6.0 - 2021-09-20\n\nIntroduced a new [request logger](https://github.com/labstack/echo/blob/master/middleware/request_logger.go) middleware \nto help with cases when you want to use some other logging library in your application.\n\n**Fixes**\n\n* fix timeout middleware warning: superfluous response.WriteHeader [#1905](https://github.com/labstack/echo/issues/1905)\n\n**Enhancements**\n\n* Add Cookie to KeyAuth middleware's KeyLookup [#1929](https://github.com/labstack/echo/pull/1929)\n* JWT middleware should ignore case of auth scheme in request header [#1951](https://github.com/labstack/echo/pull/1951)\n* Refactor default error handler to return first if response is already committed [#1956](https://github.com/labstack/echo/pull/1956)\n* Added request logger middleware which helps to use custom logger library for logging requests. [#1980](https://github.com/labstack/echo/pull/1980)\n* Allow escaping of colon in route path so Google Cloud API \"custom methods\" could be implemented [#1988](https://github.com/labstack/echo/pull/1988)\n\n## v4.5.0 - 2021-08-01\n\n**Important notes**\n\nA **BREAKING CHANGE** is introduced for JWT middleware users.\nThe JWT library used for the JWT middleware had to be changed from [github.com/dgrijalva/jwt-go](https://github.com/dgrijalva/jwt-go) to\n[github.com/golang-jwt/jwt](https://github.com/golang-jwt/jwt) due former library being unmaintained and affected by security\nissues.\nThe [github.com/golang-jwt/jwt](https://github.com/golang-jwt/jwt) project is a drop-in replacement, but supports only the latest 2 Go versions.\nSo for JWT middleware users Go 1.15+ is required. For detailed information please read [#1940](https://github.com/labstack/echo/discussions/)\n\nTo change the library imports in all .go files in your project replace all occurrences of `dgrijalva/jwt-go` with `golang-jwt/jwt`.\n\nFor Linux CLI you can use:\n```bash\nfind -type f -name \"*.go\" -exec sed -i \"s/dgrijalva\\/jwt-go/golang-jwt\\/jwt/g\" {} \\;\ngo mod tidy\n```\n\n**Fixes**\n\n* Change JWT library to `github.com/golang-jwt/jwt` [#1946](https://github.com/labstack/echo/pull/1946)\n\n## v4.4.0 - 2021-07-12\n\n**Fixes**\n\n* Split HeaderXForwardedFor header only by comma [#1878](https://github.com/labstack/echo/pull/1878)\n* Fix Timeout middleware Context propagation [#1910](https://github.com/labstack/echo/pull/1910)\n \n**Enhancements**\n\n* Bind data using headers as source [#1866](https://github.com/labstack/echo/pull/1866)\n* Adds JWTConfig.ParseTokenFunc to JWT middleware to allow different libraries implementing JWT parsing. [#1887](https://github.com/labstack/echo/pull/1887)\n* Adding tests for Echo#Host [#1895](https://github.com/labstack/echo/pull/1895)\n* Adds RequestIDHandler function to RequestID middleware [#1898](https://github.com/labstack/echo/pull/1898)\n* Allow for custom JSON encoding implementations [#1880](https://github.com/labstack/echo/pull/1880)\n\n## v4.3.0 - 2021-05-08\n\n**Important notes**\n\n* Route matching has improvements for following cases:\n  1. Correctly match routes with parameter part as last part of route (with trailing backslash)\n  2. Considering handlers when resolving routes and search for matching http method handler\n* Echo minimal Go version is now 1.13. \n\n**Fixes**\n\n* When url ends with slash first param route is the match [#1804](https://github.com/labstack/echo/pull/1812)\n* Router should check if node is suitable as matching route by path+method and if not then continue search in tree [#1808](https://github.com/labstack/echo/issues/1808)\n* Fix timeout middleware not writing response correctly when handler panics [#1864](https://github.com/labstack/echo/pull/1864)\n* Fix binder not working with embedded pointer structs [#1861](https://github.com/labstack/echo/pull/1861)\n* Add Go 1.16 to CI and drop 1.12 specific code [#1850](https://github.com/labstack/echo/pull/1850)\n\n**Enhancements**\n\n* Make KeyFunc public in JWT middleware [#1756](https://github.com/labstack/echo/pull/1756)\n* Add support for optional filesystem to the static middleware [#1797](https://github.com/labstack/echo/pull/1797)\n* Add a custom error handler to key-auth middleware [#1847](https://github.com/labstack/echo/pull/1847)\n* Allow JWT token to be looked up from multiple sources [#1845](https://github.com/labstack/echo/pull/1845)\n\n## v4.2.2 - 2021-04-07\n\n**Fixes**\n\n* Allow proxy middleware to use query part in rewrite (#1802)\n* Fix timeout middleware not sending status code when handler returns an error (#1805)\n* Fix Bind() when target is array/slice and path/query params complains bind target not being struct (#1835)\n* Fix panic in redirect middleware on short host name (#1813)\n* Fix timeout middleware docs (#1836)\n\n## v4.2.1 - 2021-03-08\n\n**Important notes**\n\nDue to a datarace the config parameters for the newly added timeout middleware required a change.\nSee the [docs](https://echo.labstack.com/middleware/timeout).\nA performance regression has been fixed, even bringing better performance than before for some routing scenarios.\n\n**Fixes**\n\n* Fix performance regression caused by path escaping (#1777, #1798, #1799, aldas)\n* Avoid context canceled errors (#1789, clwluvw)\n* Improve router to use on stack backtracking (#1791, aldas, stffabi)\n* Fix panic in timeout middleware not being not recovered and cause application crash (#1794, aldas)\n* Fix Echo.Serve() not serving on HTTP port correctly when TLSListener is used (#1785, #1793, aldas)\n* Apply go fmt (#1788, Le0tk0k)\n* Uses strings.Equalfold (#1790, rkilingr)\n* Improve code quality (#1792, withshubh)\n\nThis release was made possible by our **contributors**:\naldas, clwluvw, lammel, Le0tk0k, maciej-jezierski, rkilingr, stffabi, withshubh\n\n## v4.2.0 - 2021-02-11\n\n**Important notes**\n\nThe behaviour for binding data has been reworked for compatibility with echo before v4.1.11 by\nenforcing `explicit tagging` for processing parameters. This **may break** your code if you \nexpect combined handling of query/path/form params.\nPlease see the updated documentation for [request](https://echo.labstack.com/guide/request) and [binding](https://echo.labstack.com/guide/request)\n\nThe handling for rewrite rules has been slightly adjusted to expand `*` to a non-greedy `(.*?)` capture group. This is only relevant if multiple asterisks are used in your rules.\nPlease see [rewrite](https://echo.labstack.com/middleware/rewrite) and [proxy](https://echo.labstack.com/middleware/proxy) for details.\n\n**Security**\n\n* Fix directory traversal vulnerability for Windows (#1718, little-cui)\n* Fix open redirect vulnerability with trailing slash (#1771,#1775 aldas,GeoffreyFrogeye)\n\n**Enhancements**\n\n* Add Echo#ListenerNetwork as configuration (#1667, pafuent)\n* Add ability to change the status code using response beforeFuncs (#1706, RashadAnsari)\n* Echo server startup to allow data race free access to listener address\n* Binder: Restore pre v4.1.11 behaviour for c.Bind() to use query params only for GET or DELETE methods (#1727, aldas)\n* Binder: Add separate methods to bind only query params, path params or request body (#1681, aldas)\n* Binder: New fluent binder for query/path/form parameter binding (#1717, #1736, aldas)\n* Router: Performance improvements for missed routes (#1689, pafuent)\n* Router: Improve performance for Real-IP detection using IndexByte instead of Split (#1640, imxyb)\n* Middleware: Support real regex rules for rewrite and proxy middleware (#1767)\n* Middleware: New rate limiting middleware (#1724, iambenkay)\n* Middleware: New timeout middleware implementation for go1.13+ (#1743, )\n* Middleware: Allow regex pattern for CORS middleware (#1623, KlotzAndrew)\n* Middleware: Add IgnoreBase parameter to static middleware (#1701, lnenad, iambenkay)\n* Middleware: Add an optional custom function to CORS middleware to validate origin (#1651, curvegrid)\n* Middleware: Support form fields in JWT middleware (#1704, rkfg)\n* Middleware: Use sync.Pool for (de)compress middleware to improve performance (#1699, #1672, pafuent)\n* Middleware: Add decompress middleware to support gzip compressed requests (#1687, arun0009)\n* Middleware: Add ErrJWTInvalid for JWT middleware (#1627, juanbelieni)\n* Middleware: Add SameSite mode for CSRF cookies to support iframes (#1524, pr0head)\n\n**Fixes**\n\n* Fix handling of special trailing slash case for partial prefix (#1741, stffabi)\n* Fix handling of static routes with trailing slash (#1747)\n* Fix Static files route not working (#1671, pwli0755, lammel)\n* Fix use of caret(^) in regex for rewrite middleware (#1588, chotow)\n* Fix Echo#Reverse for Any type routes (#1695, pafuent)\n* Fix Router#Find panic with infinite loop (#1661, pafuent)\n* Fix Router#Find panic fails on Param paths (#1659, pafuent)\n* Fix DefaultHTTPErrorHandler with Debug=true (#1477, lammel)\n* Fix incorrect CORS headers (#1669, ulasakdeniz)\n* Fix proxy middleware rewritePath to use url with updated tests (#1630, arun0009)\n* Fix rewritePath for proxy middleware to use escaped path in (#1628, arun0009)\n* Remove unless defer (#1656, imxyb)\n\n**General**\n\n* New maintainers for Echo: Roland Lammel (@lammel) and Pablo Andres Fuente (@pafuent)\n* Add GitHub action to compare benchmarks (#1702, pafuent)\n* Binding query/path params and form fields to struct only works for explicit tags (#1729,#1734, aldas)\n* Add support for Go 1.15 in CI (#1683, asahasrabuddhe)\n* Add test for request id to remain unchanged if provided (#1719, iambenkay)\n* Refactor echo instance listener access and startup to speed up testing (#1735, aldas)\n* Refactor and improve various tests for binding and routing\n* Run test workflow only for relevant changes (#1637, #1636, pofl)\n* Update .travis.yml (#1662, santosh653)\n* Update README.md with an recents framework benchmark (#1679, pafuent)\n\nThis release was made possible by **over 100 commits** from more than **20 contributors**:\nasahasrabuddhe, aldas, AndrewKlotz, arun0009, chotow, curvegrid, iambenkay, imxyb, \njuanbelieni,  lammel, little-cui, lnenad, pafuent, pofl, pr0head, pwli, RashadAnsari, \nrkfg, santosh653, segfiner, stffabi, ulasakdeniz\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0498046875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2021 LabStack\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.0703125,
          "content": "PKG := \"github.com/labstack/echo\"\nPKG_LIST := $(shell go list ${PKG}/...)\n\ntag:\n\t@git tag `grep -P '^\\tversion = ' echo.go|cut -f2 -d'\"'`\n\t@git tag|grep -v ^v\n\n.DEFAULT_GOAL := check\ncheck: lint vet race ## Check project\n\ninit:\n\t@go install golang.org/x/lint/golint@latest\n\t@go install honnef.co/go/tools/cmd/staticcheck@latest\n\nlint: ## Lint the files\n\t@staticcheck ${PKG_LIST}\n\t@golint -set_exit_status ${PKG_LIST}\n\nvet: ## Vet the files\n\t@go vet ${PKG_LIST}\n\ntest: ## Run tests\n\t@go test -short ${PKG_LIST}\n\nrace: ## Run tests with data race detector\n\t@go test -race ${PKG_LIST}\n\nbenchmark: ## Run benchmarks\n\t@go test -run=\"-\" -bench=\".*\" ${PKG_LIST}\n\nhelp: ## Display this help screen\n\t@grep -h -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = \":.*?## \"}; {printf \"\\033[36m%-30s\\033[0m %s\\n\", $$1, $$2}'\n\ngoversion ?= \"1.20\"\ntest_version: ## Run tests inside Docker with given version (defaults to 1.20 oldest supported). Example: make test_version goversion=1.20\n\t@docker run --rm -it -v $(shell pwd):/project golang:$(goversion) /bin/sh -c \"cd /project && make init check\"\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.1943359375,
          "content": "[![Sourcegraph](https://sourcegraph.com/github.com/labstack/echo/-/badge.svg?style=flat-square)](https://sourcegraph.com/github.com/labstack/echo?badge)\n[![GoDoc](http://img.shields.io/badge/go-documentation-blue.svg?style=flat-square)](https://pkg.go.dev/github.com/labstack/echo/v4)\n[![Go Report Card](https://goreportcard.com/badge/github.com/labstack/echo?style=flat-square)](https://goreportcard.com/report/github.com/labstack/echo)\n[![GitHub Workflow Status (with event)](https://img.shields.io/github/actions/workflow/status/labstack/echo/echo.yml?style=flat-square)](https://github.com/labstack/echo/actions)\n[![Codecov](https://img.shields.io/codecov/c/github/labstack/echo.svg?style=flat-square)](https://codecov.io/gh/labstack/echo)\n[![Forum](https://img.shields.io/badge/community-forum-00afd1.svg?style=flat-square)](https://github.com/labstack/echo/discussions)\n[![Twitter](https://img.shields.io/badge/twitter-@labstack-55acee.svg?style=flat-square)](https://twitter.com/labstack)\n[![License](http://img.shields.io/badge/license-mit-blue.svg?style=flat-square)](https://raw.githubusercontent.com/labstack/echo/master/LICENSE)\n\n## Echo\n\nHigh performance, extensible, minimalist Go web framework.\n\n* [Official website](https://echo.labstack.com)\n* [Quick start](https://echo.labstack.com/docs/quick-start)\n* [Middlewares](https://echo.labstack.com/docs/category/middleware)\n\nHelp and questions: [Github Discussions](https://github.com/labstack/echo/discussions)\n\n\n### Feature Overview\n\n- Optimized HTTP router which smartly prioritize routes\n- Build robust and scalable RESTful APIs\n- Group APIs\n- Extensible middleware framework\n- Define middleware at root, group or route level\n- Data binding for JSON, XML and form payload\n- Handy functions to send variety of HTTP responses\n- Centralized HTTP error handling\n- Template rendering with any template engine\n- Define your format for the logger\n- Highly customizable\n- Automatic TLS via Let’s Encrypt\n- HTTP/2 support\n\n## Sponsors\n\n<div>\n  <a href=\"https://encore.dev\" style=\"display: inline-flex; align-items: center; gap: 10px\">\n    <img src=\"https://user-images.githubusercontent.com/78424526/214602214-52e0483a-b5fc-4d4c-b03e-0b7b23e012df.svg\" height=\"28px\" alt=\"encore icon\"></img>\n  <b>Encore – the platform for building Go-based cloud backends</b>\n    </a>\n</div>\n<br/>\n\nClick [here](https://github.com/sponsors/labstack) for more information on sponsorship.\n\n## Benchmarks\n\nDate: 2020/11/11<br>\nSource: https://github.com/vishr/web-framework-benchmark<br>\nLower is better!\n\n<img src=\"https://i.imgur.com/qwPNQbl.png\">\n<img src=\"https://i.imgur.com/s8yKQjx.png\">\n\nThe benchmarks above were run on an Intel(R) Core(TM) i7-6820HQ CPU @ 2.70GHz\n\n## [Guide](https://echo.labstack.com/guide)\n\n### Installation\n\n```sh\n// go get github.com/labstack/echo/{version}\ngo get github.com/labstack/echo/v4\n```\nLatest version of Echo supports last four Go major [releases](https://go.dev/doc/devel/release) and might work with older versions.\n\n### Example\n\n```go\npackage main\n\nimport (\n  \"github.com/labstack/echo/v4\"\n  \"github.com/labstack/echo/v4/middleware\"\n  \"log/slog\"\n  \"net/http\"\n)\n\nfunc main() {\n  // Echo instance\n  e := echo.New()\n\n  // Middleware\n  e.Use(middleware.Logger())\n  e.Use(middleware.Recover())\n\n  // Routes\n  e.GET(\"/\", hello)\n\n  // Start server\n  if err := e.Start(\":8080\"); err != nil && !errors.Is(err, http.ErrServerClosed) {\n    slog.Error(\"failed to start server\", \"error\", err)\n  }\n}\n\n// Handler\nfunc hello(c echo.Context) error {\n  return c.String(http.StatusOK, \"Hello, World!\")\n}\n```\n\n# Official middleware repositories\n\nFollowing list of middleware is maintained by Echo team.\n\n| Repository                                                                   | Description                                                                                                                                                                                                                                                                                                                   |\n|------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| [github.com/labstack/echo-jwt](https://github.com/labstack/echo-jwt)         | [JWT](https://github.com/golang-jwt/jwt) middleware                                                                                                                                                                                                                                                                           | \n| [github.com/labstack/echo-contrib](https://github.com/labstack/echo-contrib) | [casbin](https://github.com/casbin/casbin), [gorilla/sessions](https://github.com/gorilla/sessions), [jaegertracing](https://github.com/uber/jaeger-client-go), [prometheus](https://github.com/prometheus/client_golang/), [pprof](https://pkg.go.dev/net/http/pprof), [zipkin](https://github.com/openzipkin/zipkin-go) middlewares | \n\n# Third-party middleware repositories\n\nBe careful when adding 3rd party middleware. Echo teams does not have time or manpower to guarantee safety and quality\nof middlewares in this list.\n\n| Repository                                                                                           | Description                                                                                                                                                                                              |\n|------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| [deepmap/oapi-codegen](https://github.com/deepmap/oapi-codegen)                                      | Automatically generate RESTful API documentation with [OpenAPI](https://swagger.io/specification/) Client and Server Code Generator                                                                      |\n| [github.com/swaggo/echo-swagger](https://github.com/swaggo/echo-swagger)                             | Automatically generate RESTful API documentation with [Swagger](https://swagger.io/) 2.0.                                                                                                                |\n| [github.com/ziflex/lecho](https://github.com/ziflex/lecho)                                           | [Zerolog](https://github.com/rs/zerolog) logging library wrapper for Echo logger interface.                                                                                                              |\n| [github.com/brpaz/echozap](https://github.com/brpaz/echozap)                                         | Uber´s [Zap](https://github.com/uber-go/zap) logging library wrapper for Echo logger interface.                                                                                                          |\n| [github.com/samber/slog-echo](https://github.com/samber/slog-echo)                                         | Go [slog](https://pkg.go.dev/golang.org/x/exp/slog) logging library wrapper for Echo logger interface.                                                                                                          |\n| [github.com/darkweak/souin/plugins/echo](https://github.com/darkweak/souin/tree/master/plugins/echo) | HTTP cache system based on [Souin](https://github.com/darkweak/souin) to automatically get your endpoints cached. It supports some distributed and non-distributed storage systems depending your needs. |\n| [github.com/mikestefanello/pagoda](https://github.com/mikestefanello/pagoda)                         | Rapid, easy full-stack web development starter kit built with Echo.                                                                                                                                      |\n| [github.com/go-woo/protoc-gen-echo](https://github.com/go-woo/protoc-gen-echo)                       | ProtoBuf generate Echo server side code                                                                                                                                                                  |\n\nPlease send a PR to add your own library here.\n\n## Contribute\n\n**Use issues for everything**\n\n- For a small change, just send a PR.\n- For bigger changes open an issue for discussion before sending a PR.\n- PR should have:\n  - Test case\n  - Documentation\n  - Example (If it makes sense)\n- You can also contribute by:\n  - Reporting issues\n  - Suggesting new features or enhancements\n  - Improve/fix documentation\n\n## Credits\n\n- [Vishal Rana](https://github.com/vishr) (Author)\n- [Nitin Rana](https://github.com/nr17) (Consultant)\n- [Roland Lammel](https://github.com/lammel) (Maintainer)\n- [Martti T.](https://github.com/aldas) (Maintainer)\n- [Pablo Andres Fuente](https://github.com/pafuent) (Maintainer)\n- [Contributors](https://github.com/labstack/echo/graphs/contributors)\n\n## License\n\n[MIT](https://github.com/labstack/echo/blob/master/LICENSE)\n"
        },
        {
          "name": "_fixture",
          "type": "tree",
          "content": null
        },
        {
          "name": "bind.go",
          "type": "blob",
          "size": 14.99609375,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"encoding\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Binder is the interface that wraps the Bind method.\ntype Binder interface {\n\tBind(i interface{}, c Context) error\n}\n\n// DefaultBinder is the default implementation of the Binder interface.\ntype DefaultBinder struct{}\n\n// BindUnmarshaler is the interface used to wrap the UnmarshalParam method.\n// Types that don't implement this, but do implement encoding.TextUnmarshaler\n// will use that interface instead.\ntype BindUnmarshaler interface {\n\t// UnmarshalParam decodes and assigns a value from an form or query param.\n\tUnmarshalParam(param string) error\n}\n\n// bindMultipleUnmarshaler is used by binder to unmarshal multiple values from request at once to\n// type implementing this interface. For example request could have multiple query fields `?a=1&a=2&b=test` in that case\n// for `a` following slice `[\"1\", \"2\"] will be passed to unmarshaller.\ntype bindMultipleUnmarshaler interface {\n\tUnmarshalParams(params []string) error\n}\n\n// BindPathParams binds path params to bindable object\nfunc (b *DefaultBinder) BindPathParams(c Context, i interface{}) error {\n\tnames := c.ParamNames()\n\tvalues := c.ParamValues()\n\tparams := map[string][]string{}\n\tfor i, name := range names {\n\t\tparams[name] = []string{values[i]}\n\t}\n\tif err := b.bindData(i, params, \"param\", nil); err != nil {\n\t\treturn NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)\n\t}\n\treturn nil\n}\n\n// BindQueryParams binds query params to bindable object\nfunc (b *DefaultBinder) BindQueryParams(c Context, i interface{}) error {\n\tif err := b.bindData(i, c.QueryParams(), \"query\", nil); err != nil {\n\t\treturn NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)\n\t}\n\treturn nil\n}\n\n// BindBody binds request body contents to bindable object\n// NB: then binding forms take note that this implementation uses standard library form parsing\n// which parses form data from BOTH URL and BODY if content type is not MIMEMultipartForm\n// See non-MIMEMultipartForm: https://golang.org/pkg/net/http/#Request.ParseForm\n// See MIMEMultipartForm: https://golang.org/pkg/net/http/#Request.ParseMultipartForm\nfunc (b *DefaultBinder) BindBody(c Context, i interface{}) (err error) {\n\treq := c.Request()\n\tif req.ContentLength == 0 {\n\t\treturn\n\t}\n\n\t// mediatype is found like `mime.ParseMediaType()` does it\n\tbase, _, _ := strings.Cut(req.Header.Get(HeaderContentType), \";\")\n\tmediatype := strings.TrimSpace(base)\n\n\tswitch mediatype {\n\tcase MIMEApplicationJSON:\n\t\tif err = c.Echo().JSONSerializer.Deserialize(c, i); err != nil {\n\t\t\tswitch err.(type) {\n\t\t\tcase *HTTPError:\n\t\t\t\treturn err\n\t\t\tdefault:\n\t\t\t\treturn NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)\n\t\t\t}\n\t\t}\n\tcase MIMEApplicationXML, MIMETextXML:\n\t\tif err = xml.NewDecoder(req.Body).Decode(i); err != nil {\n\t\t\tif ute, ok := err.(*xml.UnsupportedTypeError); ok {\n\t\t\t\treturn NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Unsupported type error: type=%v, error=%v\", ute.Type, ute.Error())).SetInternal(err)\n\t\t\t} else if se, ok := err.(*xml.SyntaxError); ok {\n\t\t\t\treturn NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Syntax error: line=%v, error=%v\", se.Line, se.Error())).SetInternal(err)\n\t\t\t}\n\t\t\treturn NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)\n\t\t}\n\tcase MIMEApplicationForm:\n\t\tparams, err := c.FormParams()\n\t\tif err != nil {\n\t\t\treturn NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)\n\t\t}\n\t\tif err = b.bindData(i, params, \"form\", nil); err != nil {\n\t\t\treturn NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)\n\t\t}\n\tcase MIMEMultipartForm:\n\t\tparams, err := c.MultipartForm()\n\t\tif err != nil {\n\t\t\treturn NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)\n\t\t}\n\t\tif err = b.bindData(i, params.Value, \"form\", params.File); err != nil {\n\t\t\treturn NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)\n\t\t}\n\tdefault:\n\t\treturn ErrUnsupportedMediaType\n\t}\n\treturn nil\n}\n\n// BindHeaders binds HTTP headers to a bindable object\nfunc (b *DefaultBinder) BindHeaders(c Context, i interface{}) error {\n\tif err := b.bindData(i, c.Request().Header, \"header\", nil); err != nil {\n\t\treturn NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)\n\t}\n\treturn nil\n}\n\n// Bind implements the `Binder#Bind` function.\n// Binding is done in following order: 1) path params; 2) query params; 3) request body. Each step COULD override previous\n// step binded values. For single source binding use their own methods BindBody, BindQueryParams, BindPathParams.\nfunc (b *DefaultBinder) Bind(i interface{}, c Context) (err error) {\n\tif err := b.BindPathParams(c, i); err != nil {\n\t\treturn err\n\t}\n\t// Only bind query parameters for GET/DELETE/HEAD to avoid unexpected behavior with destination struct binding from body.\n\t// For example a request URL `&id=1&lang=en` with body `{\"id\":100,\"lang\":\"de\"}` would lead to precedence issues.\n\t// The HTTP method check restores pre-v4.1.11 behavior to avoid these problems (see issue #1670)\n\tmethod := c.Request().Method\n\tif method == http.MethodGet || method == http.MethodDelete || method == http.MethodHead {\n\t\tif err = b.BindQueryParams(c, i); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn b.BindBody(c, i)\n}\n\n// bindData will bind data ONLY fields in destination struct that have EXPLICIT tag\nfunc (b *DefaultBinder) bindData(destination interface{}, data map[string][]string, tag string, dataFiles map[string][]*multipart.FileHeader) error {\n\tif destination == nil || (len(data) == 0 && len(dataFiles) == 0) {\n\t\treturn nil\n\t}\n\thasFiles := len(dataFiles) > 0\n\ttyp := reflect.TypeOf(destination).Elem()\n\tval := reflect.ValueOf(destination).Elem()\n\n\t// Support binding to limited Map destinations:\n\t// - map[string][]string,\n\t// - map[string]string <-- (binds first value from data slice)\n\t// - map[string]interface{}\n\t// You are better off binding to struct but there are user who want this map feature. Source of data for these cases are:\n\t// params,query,header,form as these sources produce string values, most of the time slice of strings, actually.\n\tif typ.Kind() == reflect.Map && typ.Key().Kind() == reflect.String {\n\t\tk := typ.Elem().Kind()\n\t\tisElemInterface := k == reflect.Interface\n\t\tisElemString := k == reflect.String\n\t\tisElemSliceOfStrings := k == reflect.Slice && typ.Elem().Elem().Kind() == reflect.String\n\t\tif !(isElemSliceOfStrings || isElemString || isElemInterface) {\n\t\t\treturn nil\n\t\t}\n\t\tif val.IsNil() {\n\t\t\tval.Set(reflect.MakeMap(typ))\n\t\t}\n\t\tfor k, v := range data {\n\t\t\tif isElemString {\n\t\t\t\tval.SetMapIndex(reflect.ValueOf(k), reflect.ValueOf(v[0]))\n\t\t\t} else if isElemInterface {\n\t\t\t\t// To maintain backward compatibility, we always bind to the first string value\n\t\t\t\t// and not the slice of strings when dealing with map[string]interface{}{}\n\t\t\t\tval.SetMapIndex(reflect.ValueOf(k), reflect.ValueOf(v[0]))\n\t\t\t} else {\n\t\t\t\tval.SetMapIndex(reflect.ValueOf(k), reflect.ValueOf(v))\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\t// !struct\n\tif typ.Kind() != reflect.Struct {\n\t\tif tag == \"param\" || tag == \"query\" || tag == \"header\" {\n\t\t\t// incompatible type, data is probably to be found in the body\n\t\t\treturn nil\n\t\t}\n\t\treturn errors.New(\"binding element must be a struct\")\n\t}\n\n\tfor i := 0; i < typ.NumField(); i++ { // iterate over all destination fields\n\t\ttypeField := typ.Field(i)\n\t\tstructField := val.Field(i)\n\t\tif typeField.Anonymous {\n\t\t\tif structField.Kind() == reflect.Ptr {\n\t\t\t\tstructField = structField.Elem()\n\t\t\t}\n\t\t}\n\t\tif !structField.CanSet() {\n\t\t\tcontinue\n\t\t}\n\t\tstructFieldKind := structField.Kind()\n\t\tinputFieldName := typeField.Tag.Get(tag)\n\t\tif typeField.Anonymous && structFieldKind == reflect.Struct && inputFieldName != \"\" {\n\t\t\t// if anonymous struct with query/param/form tags, report an error\n\t\t\treturn errors.New(\"query/param/form tags are not allowed with anonymous struct field\")\n\t\t}\n\n\t\tif inputFieldName == \"\" {\n\t\t\t// If tag is nil, we inspect if the field is a not BindUnmarshaler struct and try to bind data into it (might contain fields with tags).\n\t\t\t// structs that implement BindUnmarshaler are bound only when they have explicit tag\n\t\t\tif _, ok := structField.Addr().Interface().(BindUnmarshaler); !ok && structFieldKind == reflect.Struct {\n\t\t\t\tif err := b.bindData(structField.Addr().Interface(), data, tag, dataFiles); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\t// does not have explicit tag and is not an ordinary struct - so move to next field\n\t\t\tcontinue\n\t\t}\n\n\t\tif hasFiles {\n\t\t\tif ok, err := isFieldMultipartFile(structField.Type()); err != nil {\n\t\t\t\treturn err\n\t\t\t} else if ok {\n\t\t\t\tif ok := setMultipartFileHeaderTypes(structField, inputFieldName, dataFiles); ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinputValue, exists := data[inputFieldName]\n\t\tif !exists {\n\t\t\t// Go json.Unmarshal supports case-insensitive binding.  However the\n\t\t\t// url params are bound case-sensitive which is inconsistent.  To\n\t\t\t// fix this we must check all of the map values in a\n\t\t\t// case-insensitive search.\n\t\t\tfor k, v := range data {\n\t\t\t\tif strings.EqualFold(k, inputFieldName) {\n\t\t\t\t\tinputValue = v\n\t\t\t\t\texists = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !exists {\n\t\t\tcontinue\n\t\t}\n\n\t\t// NOTE: algorithm here is not particularly sophisticated. It probably does not work with absurd types like `**[]*int`\n\t\t// but it is smart enough to handle niche cases like `*int`,`*[]string`,`[]*int` .\n\n\t\t// try unmarshalling first, in case we're dealing with an alias to an array type\n\t\tif ok, err := unmarshalInputsToField(typeField.Type.Kind(), inputValue, structField); ok {\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif ok, err := unmarshalInputToField(typeField.Type.Kind(), inputValue[0], structField); ok {\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// we could be dealing with pointer to slice `*[]string` so dereference it. There are wierd OpenAPI generators\n\t\t// that could create struct fields like that.\n\t\tif structFieldKind == reflect.Pointer {\n\t\t\tstructFieldKind = structField.Elem().Kind()\n\t\t\tstructField = structField.Elem()\n\t\t}\n\n\t\tif structFieldKind == reflect.Slice {\n\t\t\tsliceOf := structField.Type().Elem().Kind()\n\t\t\tnumElems := len(inputValue)\n\t\t\tslice := reflect.MakeSlice(structField.Type(), numElems, numElems)\n\t\t\tfor j := 0; j < numElems; j++ {\n\t\t\t\tif err := setWithProperType(sliceOf, inputValue[j], slice.Index(j)); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\tstructField.Set(slice)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := setWithProperType(structFieldKind, inputValue[0], structField); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setWithProperType(valueKind reflect.Kind, val string, structField reflect.Value) error {\n\t// But also call it here, in case we're dealing with an array of BindUnmarshalers\n\tif ok, err := unmarshalInputToField(valueKind, val, structField); ok {\n\t\treturn err\n\t}\n\n\tswitch valueKind {\n\tcase reflect.Ptr:\n\t\treturn setWithProperType(structField.Elem().Kind(), val, structField.Elem())\n\tcase reflect.Int:\n\t\treturn setIntField(val, 0, structField)\n\tcase reflect.Int8:\n\t\treturn setIntField(val, 8, structField)\n\tcase reflect.Int16:\n\t\treturn setIntField(val, 16, structField)\n\tcase reflect.Int32:\n\t\treturn setIntField(val, 32, structField)\n\tcase reflect.Int64:\n\t\treturn setIntField(val, 64, structField)\n\tcase reflect.Uint:\n\t\treturn setUintField(val, 0, structField)\n\tcase reflect.Uint8:\n\t\treturn setUintField(val, 8, structField)\n\tcase reflect.Uint16:\n\t\treturn setUintField(val, 16, structField)\n\tcase reflect.Uint32:\n\t\treturn setUintField(val, 32, structField)\n\tcase reflect.Uint64:\n\t\treturn setUintField(val, 64, structField)\n\tcase reflect.Bool:\n\t\treturn setBoolField(val, structField)\n\tcase reflect.Float32:\n\t\treturn setFloatField(val, 32, structField)\n\tcase reflect.Float64:\n\t\treturn setFloatField(val, 64, structField)\n\tcase reflect.String:\n\t\tstructField.SetString(val)\n\tdefault:\n\t\treturn errors.New(\"unknown type\")\n\t}\n\treturn nil\n}\n\nfunc unmarshalInputsToField(valueKind reflect.Kind, values []string, field reflect.Value) (bool, error) {\n\tif valueKind == reflect.Ptr {\n\t\tif field.IsNil() {\n\t\t\tfield.Set(reflect.New(field.Type().Elem()))\n\t\t}\n\t\tfield = field.Elem()\n\t}\n\n\tfieldIValue := field.Addr().Interface()\n\tunmarshaler, ok := fieldIValue.(bindMultipleUnmarshaler)\n\tif !ok {\n\t\treturn false, nil\n\t}\n\treturn true, unmarshaler.UnmarshalParams(values)\n}\n\nfunc unmarshalInputToField(valueKind reflect.Kind, val string, field reflect.Value) (bool, error) {\n\tif valueKind == reflect.Ptr {\n\t\tif field.IsNil() {\n\t\t\tfield.Set(reflect.New(field.Type().Elem()))\n\t\t}\n\t\tfield = field.Elem()\n\t}\n\n\tfieldIValue := field.Addr().Interface()\n\tswitch unmarshaler := fieldIValue.(type) {\n\tcase BindUnmarshaler:\n\t\treturn true, unmarshaler.UnmarshalParam(val)\n\tcase encoding.TextUnmarshaler:\n\t\treturn true, unmarshaler.UnmarshalText([]byte(val))\n\t}\n\n\treturn false, nil\n}\n\nfunc setIntField(value string, bitSize int, field reflect.Value) error {\n\tif value == \"\" {\n\t\tvalue = \"0\"\n\t}\n\tintVal, err := strconv.ParseInt(value, 10, bitSize)\n\tif err == nil {\n\t\tfield.SetInt(intVal)\n\t}\n\treturn err\n}\n\nfunc setUintField(value string, bitSize int, field reflect.Value) error {\n\tif value == \"\" {\n\t\tvalue = \"0\"\n\t}\n\tuintVal, err := strconv.ParseUint(value, 10, bitSize)\n\tif err == nil {\n\t\tfield.SetUint(uintVal)\n\t}\n\treturn err\n}\n\nfunc setBoolField(value string, field reflect.Value) error {\n\tif value == \"\" {\n\t\tvalue = \"false\"\n\t}\n\tboolVal, err := strconv.ParseBool(value)\n\tif err == nil {\n\t\tfield.SetBool(boolVal)\n\t}\n\treturn err\n}\n\nfunc setFloatField(value string, bitSize int, field reflect.Value) error {\n\tif value == \"\" {\n\t\tvalue = \"0.0\"\n\t}\n\tfloatVal, err := strconv.ParseFloat(value, bitSize)\n\tif err == nil {\n\t\tfield.SetFloat(floatVal)\n\t}\n\treturn err\n}\n\nvar (\n\t// NOT supported by bind as you can NOT check easily empty struct being actual file or not\n\tmultipartFileHeaderType = reflect.TypeOf(multipart.FileHeader{})\n\t// supported by bind as you can check by nil value if file existed or not\n\tmultipartFileHeaderPointerType      = reflect.TypeOf(&multipart.FileHeader{})\n\tmultipartFileHeaderSliceType        = reflect.TypeOf([]multipart.FileHeader(nil))\n\tmultipartFileHeaderPointerSliceType = reflect.TypeOf([]*multipart.FileHeader(nil))\n)\n\nfunc isFieldMultipartFile(field reflect.Type) (bool, error) {\n\tswitch field {\n\tcase multipartFileHeaderPointerType,\n\t\tmultipartFileHeaderSliceType,\n\t\tmultipartFileHeaderPointerSliceType:\n\t\treturn true, nil\n\tcase multipartFileHeaderType:\n\t\treturn true, errors.New(\"binding to multipart.FileHeader struct is not supported, use pointer to struct\")\n\tdefault:\n\t\treturn false, nil\n\t}\n}\n\nfunc setMultipartFileHeaderTypes(structField reflect.Value, inputFieldName string, files map[string][]*multipart.FileHeader) bool {\n\tfileHeaders := files[inputFieldName]\n\tif len(fileHeaders) == 0 {\n\t\treturn false\n\t}\n\n\tresult := true\n\tswitch structField.Type() {\n\tcase multipartFileHeaderPointerSliceType:\n\t\tstructField.Set(reflect.ValueOf(fileHeaders))\n\tcase multipartFileHeaderSliceType:\n\t\theaders := make([]multipart.FileHeader, len(fileHeaders))\n\t\tfor i, fileHeader := range fileHeaders {\n\t\t\theaders[i] = *fileHeader\n\t\t}\n\t\tstructField.Set(reflect.ValueOf(headers))\n\tcase multipartFileHeaderPointerType:\n\t\tstructField.Set(reflect.ValueOf(fileHeaders[0]))\n\tdefault:\n\t\tresult = false\n\t}\n\n\treturn result\n}\n"
        },
        {
          "name": "bind_test.go",
          "type": "blob",
          "size": 48.478515625,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype bindTestStruct struct {\n\tI           int\n\tPtrI        *int\n\tI8          int8\n\tPtrI8       *int8\n\tI16         int16\n\tPtrI16      *int16\n\tI32         int32\n\tPtrI32      *int32\n\tI64         int64\n\tPtrI64      *int64\n\tUI          uint\n\tPtrUI       *uint\n\tUI8         uint8\n\tPtrUI8      *uint8\n\tUI16        uint16\n\tPtrUI16     *uint16\n\tUI32        uint32\n\tPtrUI32     *uint32\n\tUI64        uint64\n\tPtrUI64     *uint64\n\tB           bool\n\tPtrB        *bool\n\tF32         float32\n\tPtrF32      *float32\n\tF64         float64\n\tPtrF64      *float64\n\tS           string\n\tPtrS        *string\n\tcantSet     string\n\tDoesntExist string\n\tGoT         time.Time\n\tGoTptr      *time.Time\n\tT           Timestamp\n\tTptr        *Timestamp\n\tSA          StringArray\n}\n\ntype bindTestStructWithTags struct {\n\tI           int      `json:\"I\" form:\"I\"`\n\tPtrI        *int     `json:\"PtrI\" form:\"PtrI\"`\n\tI8          int8     `json:\"I8\" form:\"I8\"`\n\tPtrI8       *int8    `json:\"PtrI8\" form:\"PtrI8\"`\n\tI16         int16    `json:\"I16\" form:\"I16\"`\n\tPtrI16      *int16   `json:\"PtrI16\" form:\"PtrI16\"`\n\tI32         int32    `json:\"I32\" form:\"I32\"`\n\tPtrI32      *int32   `json:\"PtrI32\" form:\"PtrI32\"`\n\tI64         int64    `json:\"I64\" form:\"I64\"`\n\tPtrI64      *int64   `json:\"PtrI64\" form:\"PtrI64\"`\n\tUI          uint     `json:\"UI\" form:\"UI\"`\n\tPtrUI       *uint    `json:\"PtrUI\" form:\"PtrUI\"`\n\tUI8         uint8    `json:\"UI8\" form:\"UI8\"`\n\tPtrUI8      *uint8   `json:\"PtrUI8\" form:\"PtrUI8\"`\n\tUI16        uint16   `json:\"UI16\" form:\"UI16\"`\n\tPtrUI16     *uint16  `json:\"PtrUI16\" form:\"PtrUI16\"`\n\tUI32        uint32   `json:\"UI32\" form:\"UI32\"`\n\tPtrUI32     *uint32  `json:\"PtrUI32\" form:\"PtrUI32\"`\n\tUI64        uint64   `json:\"UI64\" form:\"UI64\"`\n\tPtrUI64     *uint64  `json:\"PtrUI64\" form:\"PtrUI64\"`\n\tB           bool     `json:\"B\" form:\"B\"`\n\tPtrB        *bool    `json:\"PtrB\" form:\"PtrB\"`\n\tF32         float32  `json:\"F32\" form:\"F32\"`\n\tPtrF32      *float32 `json:\"PtrF32\" form:\"PtrF32\"`\n\tF64         float64  `json:\"F64\" form:\"F64\"`\n\tPtrF64      *float64 `json:\"PtrF64\" form:\"PtrF64\"`\n\tS           string   `json:\"S\" form:\"S\"`\n\tPtrS        *string  `json:\"PtrS\" form:\"PtrS\"`\n\tcantSet     string\n\tDoesntExist string      `json:\"DoesntExist\" form:\"DoesntExist\"`\n\tGoT         time.Time   `json:\"GoT\" form:\"GoT\"`\n\tGoTptr      *time.Time  `json:\"GoTptr\" form:\"GoTptr\"`\n\tT           Timestamp   `json:\"T\" form:\"T\"`\n\tTptr        *Timestamp  `json:\"Tptr\" form:\"Tptr\"`\n\tSA          StringArray `json:\"SA\" form:\"SA\"`\n}\n\ntype Timestamp time.Time\ntype TA []Timestamp\ntype StringArray []string\ntype Struct struct {\n\tFoo string\n}\ntype Bar struct {\n\tBaz int `json:\"baz\" query:\"baz\"`\n}\n\nfunc (t *Timestamp) UnmarshalParam(src string) error {\n\tts, err := time.Parse(time.RFC3339, src)\n\t*t = Timestamp(ts)\n\treturn err\n}\n\nfunc (a *StringArray) UnmarshalParam(src string) error {\n\t*a = StringArray(strings.Split(src, \",\"))\n\treturn nil\n}\n\nfunc (s *Struct) UnmarshalParam(src string) error {\n\t*s = Struct{\n\t\tFoo: src,\n\t}\n\treturn nil\n}\n\nfunc (t bindTestStruct) GetCantSet() string {\n\treturn t.cantSet\n}\n\nvar values = map[string][]string{\n\t\"I\":       {\"0\"},\n\t\"PtrI\":    {\"0\"},\n\t\"I8\":      {\"8\"},\n\t\"PtrI8\":   {\"8\"},\n\t\"I16\":     {\"16\"},\n\t\"PtrI16\":  {\"16\"},\n\t\"I32\":     {\"32\"},\n\t\"PtrI32\":  {\"32\"},\n\t\"I64\":     {\"64\"},\n\t\"PtrI64\":  {\"64\"},\n\t\"UI\":      {\"0\"},\n\t\"PtrUI\":   {\"0\"},\n\t\"UI8\":     {\"8\"},\n\t\"PtrUI8\":  {\"8\"},\n\t\"UI16\":    {\"16\"},\n\t\"PtrUI16\": {\"16\"},\n\t\"UI32\":    {\"32\"},\n\t\"PtrUI32\": {\"32\"},\n\t\"UI64\":    {\"64\"},\n\t\"PtrUI64\": {\"64\"},\n\t\"B\":       {\"true\"},\n\t\"PtrB\":    {\"true\"},\n\t\"F32\":     {\"32.5\"},\n\t\"PtrF32\":  {\"32.5\"},\n\t\"F64\":     {\"64.5\"},\n\t\"PtrF64\":  {\"64.5\"},\n\t\"S\":       {\"test\"},\n\t\"PtrS\":    {\"test\"},\n\t\"cantSet\": {\"test\"},\n\t\"T\":       {\"2016-12-06T19:09:05+01:00\"},\n\t\"Tptr\":    {\"2016-12-06T19:09:05+01:00\"},\n\t\"GoT\":     {\"2016-12-06T19:09:05+01:00\"},\n\t\"GoTptr\":  {\"2016-12-06T19:09:05+01:00\"},\n\t\"ST\":      {\"bar\"},\n}\n\n// ptr return pointer to value. This is useful as `v := []*int8{&int8(1)}` will not compile\nfunc ptr[T any](value T) *T {\n\treturn &value\n}\n\nfunc TestToMultipleFields(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/?id=1&ID=2\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\n\ttype Root struct {\n\t\tID     int64 `query:\"id\"`\n\t\tChild2 struct {\n\t\t\tID int64\n\t\t}\n\t\tChild1 struct {\n\t\t\tID int64 `query:\"id\"`\n\t\t}\n\t}\n\n\tu := new(Root)\n\terr := c.Bind(u)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, int64(1), u.ID)        // perfectly reasonable\n\t\tassert.Equal(t, int64(1), u.Child1.ID) // untagged struct containing tagged field gets filled (by tag)\n\t\tassert.Equal(t, int64(0), u.Child2.ID) // untagged struct containing untagged field should not be bind\n\t}\n}\n\nfunc TestBindJSON(t *testing.T) {\n\ttestBindOkay(t, strings.NewReader(userJSON), nil, MIMEApplicationJSON)\n\ttestBindOkay(t, strings.NewReader(userJSON), dummyQuery, MIMEApplicationJSON)\n\ttestBindArrayOkay(t, strings.NewReader(usersJSON), nil, MIMEApplicationJSON)\n\ttestBindArrayOkay(t, strings.NewReader(usersJSON), dummyQuery, MIMEApplicationJSON)\n\ttestBindError(t, strings.NewReader(invalidContent), MIMEApplicationJSON, &json.SyntaxError{})\n\ttestBindError(t, strings.NewReader(userJSONInvalidType), MIMEApplicationJSON, &json.UnmarshalTypeError{})\n}\n\nfunc TestBindXML(t *testing.T) {\n\ttestBindOkay(t, strings.NewReader(userXML), nil, MIMEApplicationXML)\n\ttestBindOkay(t, strings.NewReader(userXML), dummyQuery, MIMEApplicationXML)\n\ttestBindArrayOkay(t, strings.NewReader(userXML), nil, MIMEApplicationXML)\n\ttestBindArrayOkay(t, strings.NewReader(userXML), dummyQuery, MIMEApplicationXML)\n\ttestBindError(t, strings.NewReader(invalidContent), MIMEApplicationXML, errors.New(\"\"))\n\ttestBindError(t, strings.NewReader(userXMLConvertNumberError), MIMEApplicationXML, &strconv.NumError{})\n\ttestBindError(t, strings.NewReader(userXMLUnsupportedTypeError), MIMEApplicationXML, &xml.SyntaxError{})\n\ttestBindOkay(t, strings.NewReader(userXML), nil, MIMETextXML)\n\ttestBindOkay(t, strings.NewReader(userXML), dummyQuery, MIMETextXML)\n\ttestBindError(t, strings.NewReader(invalidContent), MIMETextXML, errors.New(\"\"))\n\ttestBindError(t, strings.NewReader(userXMLConvertNumberError), MIMETextXML, &strconv.NumError{})\n\ttestBindError(t, strings.NewReader(userXMLUnsupportedTypeError), MIMETextXML, &xml.SyntaxError{})\n}\n\nfunc TestBindForm(t *testing.T) {\n\n\ttestBindOkay(t, strings.NewReader(userForm), nil, MIMEApplicationForm)\n\ttestBindOkay(t, strings.NewReader(userForm), dummyQuery, MIMEApplicationForm)\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(userForm))\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\treq.Header.Set(HeaderContentType, MIMEApplicationForm)\n\terr := c.Bind(&[]struct{ Field string }{})\n\tassert.Error(t, err)\n}\n\nfunc TestBindQueryParams(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/?id=1&name=Jon+Snow\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tu := new(user)\n\terr := c.Bind(u)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, 1, u.ID)\n\t\tassert.Equal(t, \"Jon Snow\", u.Name)\n\t}\n}\n\nfunc TestBindQueryParamsCaseInsensitive(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/?ID=1&NAME=Jon+Snow\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tu := new(user)\n\terr := c.Bind(u)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, 1, u.ID)\n\t\tassert.Equal(t, \"Jon Snow\", u.Name)\n\t}\n}\n\nfunc TestBindQueryParamsCaseSensitivePrioritized(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/?id=1&ID=2&NAME=Jon+Snow&name=Jon+Doe\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tu := new(user)\n\terr := c.Bind(u)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, 1, u.ID)\n\t\tassert.Equal(t, \"Jon Doe\", u.Name)\n\t}\n}\n\nfunc TestBindHeaderParam(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\treq.Header.Set(\"Name\", \"Jon Doe\")\n\treq.Header.Set(\"Id\", \"2\")\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tu := new(user)\n\terr := (&DefaultBinder{}).BindHeaders(c, u)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, 2, u.ID)\n\t\tassert.Equal(t, \"Jon Doe\", u.Name)\n\t}\n}\n\nfunc TestBindHeaderParamBadType(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\treq.Header.Set(\"Id\", \"salamander\")\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tu := new(user)\n\terr := (&DefaultBinder{}).BindHeaders(c, u)\n\tassert.Error(t, err)\n\n\thttpErr, ok := err.(*HTTPError)\n\tif assert.True(t, ok) {\n\t\tassert.Equal(t, http.StatusBadRequest, httpErr.Code)\n\t}\n}\n\nfunc TestBindUnmarshalParam(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/?ts=2016-12-06T19:09:05Z&sa=one,two,three&ta=2016-12-06T19:09:05Z&ta=2016-12-06T19:09:05Z&ST=baz\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tresult := struct {\n\t\tT         Timestamp   `query:\"ts\"`\n\t\tTA        []Timestamp `query:\"ta\"`\n\t\tSA        StringArray `query:\"sa\"`\n\t\tST        Struct\n\t\tStWithTag struct {\n\t\t\tFoo string `query:\"st\"`\n\t\t}\n\t}{}\n\terr := c.Bind(&result)\n\tts := Timestamp(time.Date(2016, 12, 6, 19, 9, 5, 0, time.UTC))\n\n\tif assert.NoError(t, err) {\n\t\t//\t\tassert.Equal( Timestamp(reflect.TypeOf(&Timestamp{}), time.Date(2016, 12, 6, 19, 9, 5, 0, time.UTC)), result.T)\n\t\tassert.Equal(t, ts, result.T)\n\t\tassert.Equal(t, StringArray([]string{\"one\", \"two\", \"three\"}), result.SA)\n\t\tassert.Equal(t, []Timestamp{ts, ts}, result.TA)\n\t\tassert.Equal(t, Struct{\"\"}, result.ST)       // child struct does not have a field with matching tag\n\t\tassert.Equal(t, \"baz\", result.StWithTag.Foo) // child struct has field with matching tag\n\t}\n}\n\nfunc TestBindUnmarshalText(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/?ts=2016-12-06T19:09:05Z&sa=one,two,three&ta=2016-12-06T19:09:05Z&ta=2016-12-06T19:09:05Z&ST=baz\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tresult := struct {\n\t\tT  time.Time   `query:\"ts\"`\n\t\tTA []time.Time `query:\"ta\"`\n\t\tSA StringArray `query:\"sa\"`\n\t\tST Struct\n\t}{}\n\terr := c.Bind(&result)\n\tts := time.Date(2016, 12, 6, 19, 9, 5, 0, time.UTC)\n\tif assert.NoError(t, err) {\n\t\t//\t\tassert.Equal(t, Timestamp(reflect.TypeOf(&Timestamp{}), time.Date(2016, 12, 6, 19, 9, 5, 0, time.UTC)), result.T)\n\t\tassert.Equal(t, ts, result.T)\n\t\tassert.Equal(t, StringArray([]string{\"one\", \"two\", \"three\"}), result.SA)\n\t\tassert.Equal(t, []time.Time{ts, ts}, result.TA)\n\t\tassert.Equal(t, Struct{\"\"}, result.ST) // field in child struct does not have tag\n\t}\n}\n\nfunc TestBindUnmarshalParamPtr(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/?ts=2016-12-06T19:09:05Z\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tresult := struct {\n\t\tTptr *Timestamp `query:\"ts\"`\n\t}{}\n\terr := c.Bind(&result)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, Timestamp(time.Date(2016, 12, 6, 19, 9, 5, 0, time.UTC)), *result.Tptr)\n\t}\n}\n\nfunc TestBindUnmarshalParamAnonymousFieldPtr(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/?baz=1\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tresult := struct {\n\t\t*Bar\n\t}{&Bar{}}\n\terr := c.Bind(&result)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, 1, result.Baz)\n\t}\n}\n\nfunc TestBindUnmarshalParamAnonymousFieldPtrNil(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/?baz=1\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tresult := struct {\n\t\t*Bar\n\t}{}\n\terr := c.Bind(&result)\n\tif assert.NoError(t, err) {\n\t\tassert.Nil(t, result.Bar)\n\t}\n}\n\nfunc TestBindUnmarshalParamAnonymousFieldPtrCustomTag(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, `/?bar={\"baz\":100}&baz=1`, nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tresult := struct {\n\t\t*Bar `json:\"bar\" query:\"bar\"`\n\t}{&Bar{}}\n\terr := c.Bind(&result)\n\tassert.Contains(t, err.Error(), \"query/param/form tags are not allowed with anonymous struct field\")\n}\n\nfunc TestBindUnmarshalTextPtr(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/?ts=2016-12-06T19:09:05Z\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tresult := struct {\n\t\tTptr *time.Time `query:\"ts\"`\n\t}{}\n\terr := c.Bind(&result)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, time.Date(2016, 12, 6, 19, 9, 5, 0, time.UTC), *result.Tptr)\n\t}\n}\n\nfunc TestBindMultipartForm(t *testing.T) {\n\tbodyBuffer := new(bytes.Buffer)\n\tmw := multipart.NewWriter(bodyBuffer)\n\tmw.WriteField(\"id\", \"1\")\n\tmw.WriteField(\"name\", \"Jon Snow\")\n\tmw.Close()\n\tbody := bodyBuffer.Bytes()\n\n\ttestBindOkay(t, bytes.NewReader(body), nil, mw.FormDataContentType())\n\ttestBindOkay(t, bytes.NewReader(body), dummyQuery, mw.FormDataContentType())\n}\n\nfunc TestBindUnsupportedMediaType(t *testing.T) {\n\ttestBindError(t, strings.NewReader(invalidContent), MIMEApplicationJSON, &json.SyntaxError{})\n}\n\nfunc TestDefaultBinder_bindDataToMap(t *testing.T) {\n\texampleData := map[string][]string{\n\t\t\"multiple\": {\"1\", \"2\"},\n\t\t\"single\":   {\"3\"},\n\t}\n\n\tt.Run(\"ok, bind to map[string]string\", func(t *testing.T) {\n\t\tdest := map[string]string{}\n\t\tassert.NoError(t, new(DefaultBinder).bindData(&dest, exampleData, \"param\", nil))\n\t\tassert.Equal(t,\n\t\t\tmap[string]string{\n\t\t\t\t\"multiple\": \"1\",\n\t\t\t\t\"single\":   \"3\",\n\t\t\t},\n\t\t\tdest,\n\t\t)\n\t})\n\n\tt.Run(\"ok, bind to map[string]string with nil map\", func(t *testing.T) {\n\t\tvar dest map[string]string\n\t\tassert.NoError(t, new(DefaultBinder).bindData(&dest, exampleData, \"param\", nil))\n\t\tassert.Equal(t,\n\t\t\tmap[string]string{\n\t\t\t\t\"multiple\": \"1\",\n\t\t\t\t\"single\":   \"3\",\n\t\t\t},\n\t\t\tdest,\n\t\t)\n\t})\n\n\tt.Run(\"ok, bind to map[string][]string\", func(t *testing.T) {\n\t\tdest := map[string][]string{}\n\t\tassert.NoError(t, new(DefaultBinder).bindData(&dest, exampleData, \"param\", nil))\n\t\tassert.Equal(t,\n\t\t\tmap[string][]string{\n\t\t\t\t\"multiple\": {\"1\", \"2\"},\n\t\t\t\t\"single\":   {\"3\"},\n\t\t\t},\n\t\t\tdest,\n\t\t)\n\t})\n\n\tt.Run(\"ok, bind to map[string][]string with nil map\", func(t *testing.T) {\n\t\tvar dest map[string][]string\n\t\tassert.NoError(t, new(DefaultBinder).bindData(&dest, exampleData, \"param\", nil))\n\t\tassert.Equal(t,\n\t\t\tmap[string][]string{\n\t\t\t\t\"multiple\": {\"1\", \"2\"},\n\t\t\t\t\"single\":   {\"3\"},\n\t\t\t},\n\t\t\tdest,\n\t\t)\n\t})\n\n\tt.Run(\"ok, bind to map[string]interface\", func(t *testing.T) {\n\t\tdest := map[string]interface{}{}\n\t\tassert.NoError(t, new(DefaultBinder).bindData(&dest, exampleData, \"param\", nil))\n\t\tassert.Equal(t,\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"multiple\": \"1\",\n\t\t\t\t\"single\":   \"3\",\n\t\t\t},\n\t\t\tdest,\n\t\t)\n\t})\n\n\tt.Run(\"ok, bind to map[string]interface with nil map\", func(t *testing.T) {\n\t\tvar dest map[string]interface{}\n\t\tassert.NoError(t, new(DefaultBinder).bindData(&dest, exampleData, \"param\", nil))\n\t\tassert.Equal(t,\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"multiple\": \"1\",\n\t\t\t\t\"single\":   \"3\",\n\t\t\t},\n\t\t\tdest,\n\t\t)\n\t})\n\n\tt.Run(\"ok, bind to map[string]int skips\", func(t *testing.T) {\n\t\tdest := map[string]int{}\n\t\tassert.NoError(t, new(DefaultBinder).bindData(&dest, exampleData, \"param\", nil))\n\t\tassert.Equal(t, map[string]int{}, dest)\n\t})\n\n\tt.Run(\"ok, bind to map[string]int skips with nil map\", func(t *testing.T) {\n\t\tvar dest map[string]int\n\t\tassert.NoError(t, new(DefaultBinder).bindData(&dest, exampleData, \"param\", nil))\n\t\tassert.Equal(t, map[string]int(nil), dest)\n\t})\n\n\tt.Run(\"ok, bind to map[string][]int skips\", func(t *testing.T) {\n\t\tdest := map[string][]int{}\n\t\tassert.NoError(t, new(DefaultBinder).bindData(&dest, exampleData, \"param\", nil))\n\t\tassert.Equal(t, map[string][]int{}, dest)\n\t})\n\n\tt.Run(\"ok, bind to map[string][]int skips with nil map\", func(t *testing.T) {\n\t\tvar dest map[string][]int\n\t\tassert.NoError(t, new(DefaultBinder).bindData(&dest, exampleData, \"param\", nil))\n\t\tassert.Equal(t, map[string][]int(nil), dest)\n\t})\n}\n\nfunc TestBindbindData(t *testing.T) {\n\tts := new(bindTestStruct)\n\tb := new(DefaultBinder)\n\terr := b.bindData(ts, values, \"form\", nil)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, 0, ts.I)\n\tassert.Equal(t, int8(0), ts.I8)\n\tassert.Equal(t, int16(0), ts.I16)\n\tassert.Equal(t, int32(0), ts.I32)\n\tassert.Equal(t, int64(0), ts.I64)\n\tassert.Equal(t, uint(0), ts.UI)\n\tassert.Equal(t, uint8(0), ts.UI8)\n\tassert.Equal(t, uint16(0), ts.UI16)\n\tassert.Equal(t, uint32(0), ts.UI32)\n\tassert.Equal(t, uint64(0), ts.UI64)\n\tassert.Equal(t, false, ts.B)\n\tassert.Equal(t, float32(0), ts.F32)\n\tassert.Equal(t, float64(0), ts.F64)\n\tassert.Equal(t, \"\", ts.S)\n\tassert.Equal(t, \"\", ts.cantSet)\n}\n\nfunc TestBindParam(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tc.SetPath(\"/users/:id/:name\")\n\tc.SetParamNames(\"id\", \"name\")\n\tc.SetParamValues(\"1\", \"Jon Snow\")\n\n\tu := new(user)\n\terr := c.Bind(u)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, 1, u.ID)\n\t\tassert.Equal(t, \"Jon Snow\", u.Name)\n\t}\n\n\t// Second test for the absence of a param\n\tc2 := e.NewContext(req, rec)\n\tc2.SetPath(\"/users/:id\")\n\tc2.SetParamNames(\"id\")\n\tc2.SetParamValues(\"1\")\n\n\tu = new(user)\n\terr = c2.Bind(u)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, 1, u.ID)\n\t\tassert.Equal(t, \"\", u.Name)\n\t}\n\n\t// Bind something with param and post data payload\n\tbody := bytes.NewBufferString(`{ \"name\": \"Jon Snow\" }`)\n\te2 := New()\n\treq2 := httptest.NewRequest(http.MethodPost, \"/\", body)\n\treq2.Header.Set(HeaderContentType, MIMEApplicationJSON)\n\n\trec2 := httptest.NewRecorder()\n\n\tc3 := e2.NewContext(req2, rec2)\n\tc3.SetPath(\"/users/:id\")\n\tc3.SetParamNames(\"id\")\n\tc3.SetParamValues(\"1\")\n\n\tu = new(user)\n\terr = c3.Bind(u)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, 1, u.ID)\n\t\tassert.Equal(t, \"Jon Snow\", u.Name)\n\t}\n}\n\nfunc TestBindUnmarshalTypeError(t *testing.T) {\n\tbody := bytes.NewBufferString(`{ \"id\": \"text\" }`)\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", body)\n\treq.Header.Set(HeaderContentType, MIMEApplicationJSON)\n\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tu := new(user)\n\n\terr := c.Bind(u)\n\n\the := &HTTPError{Code: http.StatusBadRequest, Message: \"Unmarshal type error: expected=int, got=string, field=id, offset=14\", Internal: err.(*HTTPError).Internal}\n\n\tassert.Equal(t, he, err)\n}\n\nfunc TestBindSetWithProperType(t *testing.T) {\n\tts := new(bindTestStruct)\n\ttyp := reflect.TypeOf(ts).Elem()\n\tval := reflect.ValueOf(ts).Elem()\n\tfor i := 0; i < typ.NumField(); i++ {\n\t\ttypeField := typ.Field(i)\n\t\tstructField := val.Field(i)\n\t\tif !structField.CanSet() {\n\t\t\tcontinue\n\t\t}\n\t\tif len(values[typeField.Name]) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tval := values[typeField.Name][0]\n\t\terr := setWithProperType(typeField.Type.Kind(), val, structField)\n\t\tassert.NoError(t, err)\n\t}\n\tassertBindTestStruct(t, ts)\n\n\ttype foo struct {\n\t\tBar bytes.Buffer\n\t}\n\tv := &foo{}\n\ttyp = reflect.TypeOf(v).Elem()\n\tval = reflect.ValueOf(v).Elem()\n\tassert.Error(t, setWithProperType(typ.Field(0).Type.Kind(), \"5\", val.Field(0)))\n}\n\nfunc BenchmarkBindbindDataWithTags(b *testing.B) {\n\tb.ReportAllocs()\n\tts := new(bindTestStructWithTags)\n\tbinder := new(DefaultBinder)\n\tvar err error\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\terr = binder.bindData(ts, values, \"form\", nil)\n\t}\n\tassert.NoError(b, err)\n\tassertBindTestStruct(b, (*bindTestStruct)(ts))\n}\n\nfunc assertBindTestStruct(tb testing.TB, ts *bindTestStruct) {\n\tassert.Equal(tb, 0, ts.I)\n\tassert.Equal(tb, int8(8), ts.I8)\n\tassert.Equal(tb, int16(16), ts.I16)\n\tassert.Equal(tb, int32(32), ts.I32)\n\tassert.Equal(tb, int64(64), ts.I64)\n\tassert.Equal(tb, uint(0), ts.UI)\n\tassert.Equal(tb, uint8(8), ts.UI8)\n\tassert.Equal(tb, uint16(16), ts.UI16)\n\tassert.Equal(tb, uint32(32), ts.UI32)\n\tassert.Equal(tb, uint64(64), ts.UI64)\n\tassert.Equal(tb, true, ts.B)\n\tassert.Equal(tb, float32(32.5), ts.F32)\n\tassert.Equal(tb, float64(64.5), ts.F64)\n\tassert.Equal(tb, \"test\", ts.S)\n\tassert.Equal(tb, \"\", ts.GetCantSet())\n}\n\nfunc testBindOkay(t *testing.T, r io.Reader, query url.Values, ctype string) {\n\te := New()\n\tpath := \"/\"\n\tif len(query) > 0 {\n\t\tpath += \"?\" + query.Encode()\n\t}\n\treq := httptest.NewRequest(http.MethodPost, path, r)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\treq.Header.Set(HeaderContentType, ctype)\n\tu := new(user)\n\terr := c.Bind(u)\n\tif assert.Equal(t, nil, err) {\n\t\tassert.Equal(t, 1, u.ID)\n\t\tassert.Equal(t, \"Jon Snow\", u.Name)\n\t}\n}\n\nfunc testBindArrayOkay(t *testing.T, r io.Reader, query url.Values, ctype string) {\n\te := New()\n\tpath := \"/\"\n\tif len(query) > 0 {\n\t\tpath += \"?\" + query.Encode()\n\t}\n\treq := httptest.NewRequest(http.MethodPost, path, r)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\treq.Header.Set(HeaderContentType, ctype)\n\tu := []user{}\n\terr := c.Bind(&u)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, 1, len(u))\n\t\tassert.Equal(t, 1, u[0].ID)\n\t\tassert.Equal(t, \"Jon Snow\", u[0].Name)\n\t}\n}\n\nfunc testBindError(t *testing.T, r io.Reader, ctype string, expectedInternal error) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", r)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\treq.Header.Set(HeaderContentType, ctype)\n\tu := new(user)\n\terr := c.Bind(u)\n\n\tswitch {\n\tcase strings.HasPrefix(ctype, MIMEApplicationJSON), strings.HasPrefix(ctype, MIMEApplicationXML), strings.HasPrefix(ctype, MIMETextXML),\n\t\tstrings.HasPrefix(ctype, MIMEApplicationForm), strings.HasPrefix(ctype, MIMEMultipartForm):\n\t\tif assert.IsType(t, new(HTTPError), err) {\n\t\t\tassert.Equal(t, http.StatusBadRequest, err.(*HTTPError).Code)\n\t\t\tassert.IsType(t, expectedInternal, err.(*HTTPError).Internal)\n\t\t}\n\tdefault:\n\t\tif assert.IsType(t, new(HTTPError), err) {\n\t\t\tassert.Equal(t, ErrUnsupportedMediaType, err)\n\t\t\tassert.IsType(t, expectedInternal, err.(*HTTPError).Internal)\n\t\t}\n\t}\n}\n\nfunc TestDefaultBinder_BindToStructFromMixedSources(t *testing.T) {\n\t// tests to check binding behaviour when multiple sources (path params, query params and request body) are in use\n\t// binding is done in steps and one source could overwrite previous source binded data\n\t// these tests are to document this behaviour and detect further possible regressions when bind implementation is changed\n\n\ttype Opts struct {\n\t\tID   int    `json:\"id\" form:\"id\" query:\"id\"`\n\t\tNode string `json:\"node\" form:\"node\" query:\"node\" param:\"node\"`\n\t\tLang string\n\t}\n\n\tvar testCases = []struct {\n\t\tname             string\n\t\tgivenURL         string\n\t\tgivenContent     io.Reader\n\t\tgivenMethod      string\n\t\twhenBindTarget   interface{}\n\t\twhenNoPathParams bool\n\t\texpect           interface{}\n\t\texpectError      string\n\t}{\n\t\t{\n\t\t\tname:         \"ok, POST bind to struct with: path param + query param + body\",\n\t\t\tgivenMethod:  http.MethodPost,\n\t\t\tgivenURL:     \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenContent: strings.NewReader(`{\"id\": 1}`),\n\t\t\texpect:       &Opts{ID: 1, Node: \"node_from_path\"}, // query params are not used, node is filled from path\n\t\t},\n\t\t{\n\t\t\tname:         \"ok, PUT bind to struct with: path param + query param + body\",\n\t\t\tgivenMethod:  http.MethodPut,\n\t\t\tgivenURL:     \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenContent: strings.NewReader(`{\"id\": 1}`),\n\t\t\texpect:       &Opts{ID: 1, Node: \"node_from_path\"}, // query params are not used\n\t\t},\n\t\t{\n\t\t\tname:         \"ok, GET bind to struct with: path param + query param + body\",\n\t\t\tgivenMethod:  http.MethodGet,\n\t\t\tgivenURL:     \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenContent: strings.NewReader(`{\"id\": 1}`),\n\t\t\texpect:       &Opts{ID: 1, Node: \"xxx\"}, // query overwrites previous path value\n\t\t},\n\t\t{\n\t\t\tname:         \"ok, GET bind to struct with: path param + query param + body\",\n\t\t\tgivenMethod:  http.MethodGet,\n\t\t\tgivenURL:     \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenContent: strings.NewReader(`{\"id\": 1, \"node\": \"zzz\"}`),\n\t\t\texpect:       &Opts{ID: 1, Node: \"zzz\"}, // body is binded last and overwrites previous (path,query) values\n\t\t},\n\t\t{\n\t\t\tname:         \"ok, DELETE bind to struct with: path param + query param + body\",\n\t\t\tgivenMethod:  http.MethodDelete,\n\t\t\tgivenURL:     \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenContent: strings.NewReader(`{\"id\": 1, \"node\": \"zzz\"}`),\n\t\t\texpect:       &Opts{ID: 1, Node: \"zzz\"}, // for DELETE body is binded after query params\n\t\t},\n\t\t{\n\t\t\tname:         \"ok, POST bind to struct with: path param + body\",\n\t\t\tgivenMethod:  http.MethodPost,\n\t\t\tgivenURL:     \"/api/real_node/endpoint\",\n\t\t\tgivenContent: strings.NewReader(`{\"id\": 1}`),\n\t\t\texpect:       &Opts{ID: 1, Node: \"node_from_path\"},\n\t\t},\n\t\t{\n\t\t\tname:         \"ok, POST bind to struct with path + query + body = body has priority\",\n\t\t\tgivenMethod:  http.MethodPost,\n\t\t\tgivenURL:     \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenContent: strings.NewReader(`{\"id\": 1, \"node\": \"zzz\"}`),\n\t\t\texpect:       &Opts{ID: 1, Node: \"zzz\"}, // field value from content has higher priority\n\t\t},\n\t\t{\n\t\t\tname:         \"nok, POST body bind failure\",\n\t\t\tgivenMethod:  http.MethodPost,\n\t\t\tgivenURL:     \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenContent: strings.NewReader(`{`),\n\t\t\texpect:       &Opts{ID: 0, Node: \"node_from_path\"}, // query binding has already modified bind target\n\t\t\texpectError:  \"code=400, message=unexpected EOF, internal=unexpected EOF\",\n\t\t},\n\t\t{\n\t\t\tname:         \"nok, GET with body bind failure when types are not convertible\",\n\t\t\tgivenMethod:  http.MethodGet,\n\t\t\tgivenURL:     \"/api/real_node/endpoint?id=nope\",\n\t\t\tgivenContent: strings.NewReader(`{\"id\": 1, \"node\": \"zzz\"}`),\n\t\t\texpect:       &Opts{ID: 0, Node: \"node_from_path\"}, // path params binding has already modified bind target\n\t\t\texpectError:  \"code=400, message=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax, internal=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax\",\n\t\t},\n\t\t{\n\t\t\tname:         \"nok, GET body bind failure - trying to bind json array to struct\",\n\t\t\tgivenMethod:  http.MethodGet,\n\t\t\tgivenURL:     \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenContent: strings.NewReader(`[{\"id\": 1}]`),\n\t\t\texpect:       &Opts{ID: 0, Node: \"xxx\"}, // query binding has already modified bind target\n\t\t\texpectError:  \"code=400, message=Unmarshal type error: expected=echo.Opts, got=array, field=, offset=1, internal=json: cannot unmarshal array into Go value of type echo.Opts\",\n\t\t},\n\t\t{ // query param is ignored as we do not know where exactly to bind it in slice\n\t\t\tname:             \"ok, GET bind to struct slice, ignore query param\",\n\t\t\tgivenMethod:      http.MethodGet,\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenContent:     strings.NewReader(`[{\"id\": 1}]`),\n\t\t\twhenNoPathParams: true,\n\t\t\twhenBindTarget:   &[]Opts{},\n\t\t\texpect: &[]Opts{\n\t\t\t\t{ID: 1, Node: \"\"},\n\t\t\t},\n\t\t},\n\t\t{ // binding query params interferes with body. b.BindBody() should be used to bind only body to slice\n\t\t\tname:             \"ok, POST binding to slice should not be affected query params types\",\n\t\t\tgivenMethod:      http.MethodPost,\n\t\t\tgivenURL:         \"/api/real_node/endpoint?id=nope&node=xxx\",\n\t\t\tgivenContent:     strings.NewReader(`[{\"id\": 1}]`),\n\t\t\twhenNoPathParams: true,\n\t\t\twhenBindTarget:   &[]Opts{},\n\t\t\texpect:           &[]Opts{{ID: 1}},\n\t\t\texpectError:      \"\",\n\t\t},\n\t\t{ // path param is ignored as we do not know where exactly to bind it in slice\n\t\t\tname:           \"ok, GET bind to struct slice, ignore path param\",\n\t\t\tgivenMethod:    http.MethodGet,\n\t\t\tgivenURL:       \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenContent:   strings.NewReader(`[{\"id\": 1}]`),\n\t\t\twhenBindTarget: &[]Opts{},\n\t\t\texpect: &[]Opts{\n\t\t\t\t{ID: 1, Node: \"\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:             \"ok, GET body bind json array to slice\",\n\t\t\tgivenMethod:      http.MethodGet,\n\t\t\tgivenURL:         \"/api/real_node/endpoint\",\n\t\t\tgivenContent:     strings.NewReader(`[{\"id\": 1}]`),\n\t\t\twhenNoPathParams: true,\n\t\t\twhenBindTarget:   &[]Opts{},\n\t\t\texpect:           &[]Opts{{ID: 1, Node: \"\"}},\n\t\t\texpectError:      \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\t// assume route we are testing is \"/api/:node/endpoint?some_query_params=here\"\n\t\t\treq := httptest.NewRequest(tc.givenMethod, tc.givenURL, tc.givenContent)\n\t\t\treq.Header.Set(HeaderContentType, MIMEApplicationJSON)\n\t\t\trec := httptest.NewRecorder()\n\t\t\tc := e.NewContext(req, rec)\n\n\t\t\tif !tc.whenNoPathParams {\n\t\t\t\tc.SetParamNames(\"node\")\n\t\t\t\tc.SetParamValues(\"node_from_path\")\n\t\t\t}\n\n\t\t\tvar bindTarget interface{}\n\t\t\tif tc.whenBindTarget != nil {\n\t\t\t\tbindTarget = tc.whenBindTarget\n\t\t\t} else {\n\t\t\t\tbindTarget = &Opts{}\n\t\t\t}\n\t\t\tb := new(DefaultBinder)\n\n\t\t\terr := b.Bind(bindTarget, c)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expect, bindTarget)\n\t\t})\n\t}\n}\n\nfunc TestDefaultBinder_BindBody(t *testing.T) {\n\t// tests to check binding behaviour when multiple sources (path params, query params and request body) are in use\n\t// generally when binding from request body - URL and path params are ignored - unless form is being binded.\n\t// these tests are to document this behaviour and detect further possible regressions when bind implementation is changed\n\n\ttype Node struct {\n\t\tID   int    `json:\"id\" xml:\"id\" form:\"id\" query:\"id\"`\n\t\tNode string `json:\"node\" xml:\"node\" form:\"node\" query:\"node\" param:\"node\"`\n\t}\n\ttype Nodes struct {\n\t\tNodes []Node `xml:\"node\" form:\"node\"`\n\t}\n\n\tvar testCases = []struct {\n\t\tname             string\n\t\tgivenURL         string\n\t\tgivenContent     io.Reader\n\t\tgivenMethod      string\n\t\tgivenContentType string\n\t\twhenNoPathParams bool\n\t\twhenChunkedBody  bool\n\t\twhenBindTarget   interface{}\n\t\texpect           interface{}\n\t\texpectError      string\n\t}{\n\t\t{\n\t\t\tname:             \"ok, JSON POST bind to struct with: path + query + empty field in body\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodPost,\n\t\t\tgivenContentType: MIMEApplicationJSON,\n\t\t\tgivenContent:     strings.NewReader(`{\"id\": 1}`),\n\t\t\texpect:           &Node{ID: 1, Node: \"\"}, // path params or query params should not interfere with body\n\t\t},\n\t\t{\n\t\t\tname:             \"ok, JSON POST bind to struct with: path + query + body\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodPost,\n\t\t\tgivenContentType: MIMEApplicationJSON,\n\t\t\tgivenContent:     strings.NewReader(`{\"id\": 1, \"node\": \"zzz\"}`),\n\t\t\texpect:           &Node{ID: 1, Node: \"zzz\"}, // field value from content has higher priority\n\t\t},\n\t\t{\n\t\t\tname:             \"ok, JSON POST body bind json array to slice (has matching path/query params)\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodPost,\n\t\t\tgivenContentType: MIMEApplicationJSON,\n\t\t\tgivenContent:     strings.NewReader(`[{\"id\": 1}]`),\n\t\t\twhenNoPathParams: true,\n\t\t\twhenBindTarget:   &[]Node{},\n\t\t\texpect:           &[]Node{{ID: 1, Node: \"\"}},\n\t\t\texpectError:      \"\",\n\t\t},\n\t\t{ // rare case as GET is not usually used to send request body\n\t\t\tname:             \"ok, JSON GET bind to struct with: path + query + empty field in body\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodGet,\n\t\t\tgivenContentType: MIMEApplicationJSON,\n\t\t\tgivenContent:     strings.NewReader(`{\"id\": 1}`),\n\t\t\texpect:           &Node{ID: 1, Node: \"\"}, // path params or query params should not interfere with body\n\t\t},\n\t\t{ // rare case as GET is not usually used to send request body\n\t\t\tname:             \"ok, JSON GET bind to struct with: path + query + body\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodGet,\n\t\t\tgivenContentType: MIMEApplicationJSON,\n\t\t\tgivenContent:     strings.NewReader(`{\"id\": 1, \"node\": \"zzz\"}`),\n\t\t\texpect:           &Node{ID: 1, Node: \"zzz\"}, // field value from content has higher priority\n\t\t},\n\t\t{\n\t\t\tname:             \"nok, JSON POST body bind failure\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodPost,\n\t\t\tgivenContentType: MIMEApplicationJSON,\n\t\t\tgivenContent:     strings.NewReader(`{`),\n\t\t\texpect:           &Node{ID: 0, Node: \"\"},\n\t\t\texpectError:      \"code=400, message=unexpected EOF, internal=unexpected EOF\",\n\t\t},\n\t\t{\n\t\t\tname:             \"ok, XML POST bind to struct with: path + query + empty body\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodPost,\n\t\t\tgivenContentType: MIMEApplicationXML,\n\t\t\tgivenContent:     strings.NewReader(`<node><id>1</id><node>yyy</node></node>`),\n\t\t\texpect:           &Node{ID: 1, Node: \"yyy\"},\n\t\t},\n\t\t{\n\t\t\tname:             \"ok, XML POST bind array to slice with: path + query + body\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodPost,\n\t\t\tgivenContentType: MIMEApplicationXML,\n\t\t\tgivenContent:     strings.NewReader(`<nodes><node><id>1</id><node>yyy</node></node></nodes>`),\n\t\t\twhenBindTarget:   &Nodes{},\n\t\t\texpect:           &Nodes{Nodes: []Node{{ID: 1, Node: \"yyy\"}}},\n\t\t},\n\t\t{\n\t\t\tname:             \"nok, XML POST bind failure\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodPost,\n\t\t\tgivenContentType: MIMEApplicationXML,\n\t\t\tgivenContent:     strings.NewReader(`<node><`),\n\t\t\texpect:           &Node{ID: 0, Node: \"\"},\n\t\t\texpectError:      \"code=400, message=Syntax error: line=1, error=XML syntax error on line 1: unexpected EOF, internal=XML syntax error on line 1: unexpected EOF\",\n\t\t},\n\t\t{\n\t\t\tname:             \"ok, FORM POST bind to struct with: path + query + body\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodPost,\n\t\t\tgivenContentType: MIMEApplicationForm,\n\t\t\tgivenContent:     strings.NewReader(`id=1&node=yyy`),\n\t\t\texpect:           &Node{ID: 1, Node: \"yyy\"},\n\t\t},\n\t\t{\n\t\t\t// NB: form values are taken from BOTH body and query for POST/PUT/PATCH by standard library implementation\n\t\t\t// See: https://golang.org/pkg/net/http/#Request.ParseForm\n\t\t\tname:             \"ok, FORM POST bind to struct with: path + query + empty field in body\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodPost,\n\t\t\tgivenContentType: MIMEApplicationForm,\n\t\t\tgivenContent:     strings.NewReader(`id=1`),\n\t\t\texpect:           &Node{ID: 1, Node: \"xxx\"},\n\t\t},\n\t\t{\n\t\t\t// NB: form values are taken from query by standard library implementation\n\t\t\t// See: https://golang.org/pkg/net/http/#Request.ParseForm\n\t\t\tname:             \"ok, FORM GET bind to struct with: path + query + empty field in body\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodGet,\n\t\t\tgivenContentType: MIMEApplicationForm,\n\t\t\tgivenContent:     strings.NewReader(`id=1`),\n\t\t\texpect:           &Node{ID: 0, Node: \"xxx\"}, // 'xxx' is taken from URL and body is not used with GET by implementation\n\t\t},\n\t\t{\n\t\t\tname:             \"nok, unsupported content type\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodPost,\n\t\t\tgivenContentType: MIMETextPlain,\n\t\t\tgivenContent:     strings.NewReader(`<html></html>`),\n\t\t\texpect:           &Node{ID: 0, Node: \"\"},\n\t\t\texpectError:      \"code=415, message=Unsupported Media Type\",\n\t\t},\n\t\t{\n\t\t\tname:             \"nok, JSON POST with http.NoBody\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodPost,\n\t\t\tgivenContentType: MIMEApplicationJSON,\n\t\t\tgivenContent:     http.NoBody,\n\t\t\texpect:           &Node{ID: 0, Node: \"\"},\n\t\t\texpectError:      \"code=400, message=EOF, internal=EOF\",\n\t\t},\n\t\t{\n\t\t\tname:             \"ok, JSON POST with empty body\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodPost,\n\t\t\tgivenContentType: MIMEApplicationJSON,\n\t\t\tgivenContent:     strings.NewReader(\"\"),\n\t\t\texpect:           &Node{ID: 0, Node: \"\"},\n\t\t},\n\t\t{\n\t\t\tname:             \"ok, JSON POST bind to struct with: path + query + chunked body\",\n\t\t\tgivenURL:         \"/api/real_node/endpoint?node=xxx\",\n\t\t\tgivenMethod:      http.MethodPost,\n\t\t\tgivenContentType: MIMEApplicationJSON,\n\t\t\tgivenContent:     httputil.NewChunkedReader(strings.NewReader(\"18\\r\\n\" + `{\"id\": 1, \"node\": \"zzz\"}` + \"\\r\\n0\\r\\n\")),\n\t\t\twhenChunkedBody:  true,\n\t\t\texpect:           &Node{ID: 1, Node: \"zzz\"},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\t// assume route we are testing is \"/api/:node/endpoint?some_query_params=here\"\n\t\t\treq := httptest.NewRequest(tc.givenMethod, tc.givenURL, tc.givenContent)\n\t\t\tswitch tc.givenContentType {\n\t\t\tcase MIMEApplicationXML:\n\t\t\t\treq.Header.Set(HeaderContentType, MIMEApplicationXML)\n\t\t\tcase MIMEApplicationForm:\n\t\t\t\treq.Header.Set(HeaderContentType, MIMEApplicationForm)\n\t\t\tcase MIMEApplicationJSON:\n\t\t\t\treq.Header.Set(HeaderContentType, MIMEApplicationJSON)\n\t\t\t}\n\t\t\tif tc.whenChunkedBody {\n\t\t\t\treq.ContentLength = -1\n\t\t\t\treq.TransferEncoding = append(req.TransferEncoding, \"chunked\")\n\t\t\t}\n\t\t\trec := httptest.NewRecorder()\n\t\t\tc := e.NewContext(req, rec)\n\n\t\t\tif !tc.whenNoPathParams {\n\t\t\t\tc.SetParamNames(\"node\")\n\t\t\t\tc.SetParamValues(\"real_node\")\n\t\t\t}\n\n\t\t\tvar bindTarget interface{}\n\t\t\tif tc.whenBindTarget != nil {\n\t\t\t\tbindTarget = tc.whenBindTarget\n\t\t\t} else {\n\t\t\t\tbindTarget = &Node{}\n\t\t\t}\n\t\t\tb := new(DefaultBinder)\n\n\t\t\terr := b.BindBody(c, bindTarget)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expect, bindTarget)\n\t\t})\n\t}\n}\n\nfunc testBindURL(queryString string, target any) error {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, queryString, nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\treturn c.Bind(target)\n}\n\ntype unixTimestamp struct {\n\tTime time.Time\n}\n\nfunc (t *unixTimestamp) UnmarshalParam(param string) error {\n\tn, err := strconv.ParseInt(param, 10, 64)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"'%s' is not an integer\", param)\n\t}\n\t*t = unixTimestamp{Time: time.Unix(n, 0)}\n\treturn err\n}\n\ntype IntArrayA []int\n\n// UnmarshalParam converts value to *Int64Slice.  This allows the API to accept\n// a comma-separated list of integers as a query parameter.\nfunc (i *IntArrayA) UnmarshalParam(value string) error {\n\tvar values = strings.Split(value, \",\")\n\tvar numbers = make([]int, 0, len(values))\n\n\tfor _, v := range values {\n\t\tn, err := strconv.ParseInt(v, 10, 64)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"'%s' is not an integer\", v)\n\t\t}\n\n\t\tnumbers = append(numbers, int(n))\n\t}\n\n\t*i = append(*i, numbers...)\n\treturn nil\n}\n\nfunc TestBindUnmarshalParamExtras(t *testing.T) {\n\t// this test documents how bind handles `BindUnmarshaler` interface:\n\t// NOTE: BindUnmarshaler chooses first input value to be bound.\n\n\tt.Run(\"nok, unmarshalling fails\", func(t *testing.T) {\n\t\tresult := struct {\n\t\t\tV unixTimestamp `query:\"t\"`\n\t\t}{}\n\t\terr := testBindURL(\"/?t=xxxx\", &result)\n\n\t\tassert.EqualError(t, err, \"code=400, message='xxxx' is not an integer, internal='xxxx' is not an integer\")\n\t})\n\n\tt.Run(\"ok, target is struct\", func(t *testing.T) {\n\t\tresult := struct {\n\t\t\tV unixTimestamp `query:\"t\"`\n\t\t}{}\n\t\terr := testBindURL(\"/?t=1710095540&t=1710095541\", &result)\n\n\t\tassert.NoError(t, err)\n\t\texpect := unixTimestamp{\n\t\t\tTime: time.Unix(1710095540, 0),\n\t\t}\n\t\tassert.Equal(t, expect, result.V)\n\t})\n\n\tt.Run(\"ok, target is an alias to slice and is nil, append only values from first\", func(t *testing.T) {\n\t\tresult := struct {\n\t\t\tV IntArrayA `query:\"a\"`\n\t\t}{}\n\t\terr := testBindURL(\"/?a=1,2,3&a=4,5,6\", &result)\n\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, IntArrayA([]int{1, 2, 3}), result.V)\n\t})\n\n\tt.Run(\"ok, target is an alias to slice and is nil, single input\", func(t *testing.T) {\n\t\tresult := struct {\n\t\t\tV IntArrayA `query:\"a\"`\n\t\t}{}\n\t\terr := testBindURL(\"/?a=1,2\", &result)\n\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, IntArrayA([]int{1, 2}), result.V)\n\t})\n\n\tt.Run(\"ok, target is pointer an alias to slice and is nil\", func(t *testing.T) {\n\t\tresult := struct {\n\t\t\tV *IntArrayA `query:\"a\"`\n\t\t}{}\n\t\terr := testBindURL(\"/?a=1&a=4,5,6\", &result)\n\n\t\tassert.NoError(t, err)\n\t\tvar expected = IntArrayA([]int{1})\n\t\tassert.Equal(t, &expected, result.V)\n\t})\n\n\tt.Run(\"ok, target is pointer an alias to slice and is NOT nil\", func(t *testing.T) {\n\t\tresult := struct {\n\t\t\tV *IntArrayA `query:\"a\"`\n\t\t}{}\n\t\tresult.V = new(IntArrayA) // NOT nil\n\n\t\terr := testBindURL(\"/?a=1&a=4,5,6\", &result)\n\n\t\tassert.NoError(t, err)\n\t\tvar expected = IntArrayA([]int{1})\n\t\tassert.Equal(t, &expected, result.V)\n\t})\n}\n\ntype unixTimestampLast struct {\n\tTime time.Time\n}\n\n// this is silly example for `bindMultipleUnmarshaler` for type that uses last input value for unmarshalling\nfunc (t *unixTimestampLast) UnmarshalParams(params []string) error {\n\tlastInput := params[len(params)-1]\n\tn, err := strconv.ParseInt(lastInput, 10, 64)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"'%s' is not an integer\", lastInput)\n\t}\n\t*t = unixTimestampLast{Time: time.Unix(n, 0)}\n\treturn err\n}\n\ntype IntArrayB []int\n\nfunc (i *IntArrayB) UnmarshalParams(params []string) error {\n\tvar numbers = make([]int, 0, len(params))\n\n\tfor _, param := range params {\n\t\tvar values = strings.Split(param, \",\")\n\t\tfor _, v := range values {\n\t\t\tn, err := strconv.ParseInt(v, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"'%s' is not an integer\", v)\n\t\t\t}\n\t\t\tnumbers = append(numbers, int(n))\n\t\t}\n\t}\n\n\t*i = append(*i, numbers...)\n\treturn nil\n}\n\nfunc TestBindUnmarshalParams(t *testing.T) {\n\t// this test documents how bind handles `bindMultipleUnmarshaler` interface:\n\n\tt.Run(\"nok, unmarshalling fails\", func(t *testing.T) {\n\t\tresult := struct {\n\t\t\tV unixTimestampLast `query:\"t\"`\n\t\t}{}\n\t\terr := testBindURL(\"/?t=xxxx\", &result)\n\n\t\tassert.EqualError(t, err, \"code=400, message='xxxx' is not an integer, internal='xxxx' is not an integer\")\n\t})\n\n\tt.Run(\"ok, target is struct\", func(t *testing.T) {\n\t\tresult := struct {\n\t\t\tV unixTimestampLast `query:\"t\"`\n\t\t}{}\n\t\terr := testBindURL(\"/?t=1710095540&t=1710095541\", &result)\n\n\t\tassert.NoError(t, err)\n\t\texpect := unixTimestampLast{\n\t\t\tTime: time.Unix(1710095541, 0),\n\t\t}\n\t\tassert.Equal(t, expect, result.V)\n\t})\n\n\tt.Run(\"ok, target is an alias to slice and is nil, append multiple inputs\", func(t *testing.T) {\n\t\tresult := struct {\n\t\t\tV IntArrayB `query:\"a\"`\n\t\t}{}\n\t\terr := testBindURL(\"/?a=1,2,3&a=4,5,6\", &result)\n\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, IntArrayB([]int{1, 2, 3, 4, 5, 6}), result.V)\n\t})\n\n\tt.Run(\"ok, target is an alias to slice and is nil, single input\", func(t *testing.T) {\n\t\tresult := struct {\n\t\t\tV IntArrayB `query:\"a\"`\n\t\t}{}\n\t\terr := testBindURL(\"/?a=1,2\", &result)\n\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, IntArrayB([]int{1, 2}), result.V)\n\t})\n\n\tt.Run(\"ok, target is pointer an alias to slice and is nil\", func(t *testing.T) {\n\t\tresult := struct {\n\t\t\tV *IntArrayB `query:\"a\"`\n\t\t}{}\n\t\terr := testBindURL(\"/?a=1&a=4,5,6\", &result)\n\n\t\tassert.NoError(t, err)\n\t\tvar expected = IntArrayB([]int{1, 4, 5, 6})\n\t\tassert.Equal(t, &expected, result.V)\n\t})\n\n\tt.Run(\"ok, target is pointer an alias to slice and is NOT nil\", func(t *testing.T) {\n\t\tresult := struct {\n\t\t\tV *IntArrayB `query:\"a\"`\n\t\t}{}\n\t\tresult.V = new(IntArrayB) // NOT nil\n\n\t\terr := testBindURL(\"/?a=1&a=4,5,6\", &result)\n\t\tassert.NoError(t, err)\n\t\tvar expected = IntArrayB([]int{1, 4, 5, 6})\n\t\tassert.Equal(t, &expected, result.V)\n\t})\n}\n\nfunc TestBindInt8(t *testing.T) {\n\tt.Run(\"nok, binding fails\", func(t *testing.T) {\n\t\ttype target struct {\n\t\t\tV int8 `query:\"v\"`\n\t\t}\n\t\tp := target{}\n\t\terr := testBindURL(\"/?v=x&v=2\", &p)\n\t\tassert.EqualError(t, err, \"code=400, message=strconv.ParseInt: parsing \\\"x\\\": invalid syntax, internal=strconv.ParseInt: parsing \\\"x\\\": invalid syntax\")\n\t})\n\n\tt.Run(\"nok, int8 embedded in struct\", func(t *testing.T) {\n\t\ttype target struct {\n\t\t\tint8 `query:\"v\"` // embedded field is `Anonymous`. We can only set public fields\n\t\t}\n\t\tp := target{}\n\t\terr := testBindURL(\"/?v=1&v=2\", &p)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, target{0}, p)\n\t})\n\n\tt.Run(\"nok, pointer to int8 embedded in struct\", func(t *testing.T) {\n\t\ttype target struct {\n\t\t\t*int8 `query:\"v\"` // embedded field is `Anonymous`. We can only set public fields\n\t\t}\n\t\tp := target{}\n\t\terr := testBindURL(\"/?v=1&v=2\", &p)\n\t\tassert.NoError(t, err)\n\n\t\tassert.Equal(t, target{int8: nil}, p)\n\t})\n\n\tt.Run(\"ok, bind int8 as struct field\", func(t *testing.T) {\n\t\ttype target struct {\n\t\t\tV int8 `query:\"v\"`\n\t\t}\n\t\tp := target{V: 127}\n\t\terr := testBindURL(\"/?v=1&v=2\", &p)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, target{V: 1}, p)\n\t})\n\n\tt.Run(\"ok, bind pointer to int8 as struct field, value is nil\", func(t *testing.T) {\n\t\ttype target struct {\n\t\t\tV *int8 `query:\"v\"`\n\t\t}\n\t\tp := target{}\n\t\terr := testBindURL(\"/?v=1&v=2\", &p)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, target{V: ptr(int8(1))}, p)\n\t})\n\n\tt.Run(\"ok, bind pointer to int8 as struct field, value is set\", func(t *testing.T) {\n\t\ttype target struct {\n\t\t\tV *int8 `query:\"v\"`\n\t\t}\n\t\tp := target{V: ptr(int8(127))}\n\t\terr := testBindURL(\"/?v=1&v=2\", &p)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, target{V: ptr(int8(1))}, p)\n\t})\n\n\tt.Run(\"ok, bind int8 slice as struct field, value is nil\", func(t *testing.T) {\n\t\ttype target struct {\n\t\t\tV []int8 `query:\"v\"`\n\t\t}\n\t\tp := target{}\n\t\terr := testBindURL(\"/?v=1&v=2\", &p)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, target{V: []int8{1, 2}}, p)\n\t})\n\n\tt.Run(\"ok, bind slice of int8 as struct field, value is set\", func(t *testing.T) {\n\t\ttype target struct {\n\t\t\tV []int8 `query:\"v\"`\n\t\t}\n\t\tp := target{V: []int8{111}}\n\t\terr := testBindURL(\"/?v=1&v=2\", &p)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, target{V: []int8{1, 2}}, p)\n\t})\n\n\tt.Run(\"ok, bind slice of pointer to int8 as struct field, value is set\", func(t *testing.T) {\n\t\ttype target struct {\n\t\t\tV []*int8 `query:\"v\"`\n\t\t}\n\t\tp := target{V: []*int8{ptr(int8(127))}}\n\t\terr := testBindURL(\"/?v=1&v=2\", &p)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, target{V: []*int8{ptr(int8(1)), ptr(int8(2))}}, p)\n\t})\n\n\tt.Run(\"ok, bind pointer to slice of int8 as struct field, value is set\", func(t *testing.T) {\n\t\ttype target struct {\n\t\t\tV *[]int8 `query:\"v\"`\n\t\t}\n\t\tp := target{V: &[]int8{111}}\n\t\terr := testBindURL(\"/?v=1&v=2\", &p)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, target{V: &[]int8{1, 2}}, p)\n\t})\n}\n\nfunc TestBindMultipartFormFiles(t *testing.T) {\n\tfile1 := createTestFormFile(\"file\", \"file1.txt\")\n\tfile11 := createTestFormFile(\"file\", \"file11.txt\")\n\tfile2 := createTestFormFile(\"file2\", \"file2.txt\")\n\tfilesA := createTestFormFile(\"files\", \"filesA.txt\")\n\tfilesB := createTestFormFile(\"files\", \"filesB.txt\")\n\n\tt.Run(\"nok, can not bind to multipart file struct\", func(t *testing.T) {\n\t\tvar target struct {\n\t\t\tFile multipart.FileHeader `form:\"file\"`\n\t\t}\n\t\terr := bindMultipartFiles(t, &target, file1, file2) // file2 should be ignored\n\n\t\tassert.EqualError(t, err, \"code=400, message=binding to multipart.FileHeader struct is not supported, use pointer to struct, internal=binding to multipart.FileHeader struct is not supported, use pointer to struct\")\n\t})\n\n\tt.Run(\"ok, bind single multipart file to pointer to multipart file\", func(t *testing.T) {\n\t\tvar target struct {\n\t\t\tFile *multipart.FileHeader `form:\"file\"`\n\t\t}\n\t\terr := bindMultipartFiles(t, &target, file1, file2) // file2 should be ignored\n\n\t\tassert.NoError(t, err)\n\t\tassertMultipartFileHeader(t, target.File, file1)\n\t})\n\n\tt.Run(\"ok, bind multiple multipart files to pointer to multipart file\", func(t *testing.T) {\n\t\tvar target struct {\n\t\t\tFile *multipart.FileHeader `form:\"file\"`\n\t\t}\n\t\terr := bindMultipartFiles(t, &target, file1, file11)\n\n\t\tassert.NoError(t, err)\n\t\tassertMultipartFileHeader(t, target.File, file1) // should choose first one\n\t})\n\n\tt.Run(\"ok, bind multiple multipart files to slice of multipart file\", func(t *testing.T) {\n\t\tvar target struct {\n\t\t\tFiles []multipart.FileHeader `form:\"files\"`\n\t\t}\n\t\terr := bindMultipartFiles(t, &target, filesA, filesB, file1)\n\n\t\tassert.NoError(t, err)\n\n\t\tassert.Len(t, target.Files, 2)\n\t\tassertMultipartFileHeader(t, &target.Files[0], filesA)\n\t\tassertMultipartFileHeader(t, &target.Files[1], filesB)\n\t})\n\n\tt.Run(\"ok, bind multiple multipart files to slice of pointer to multipart file\", func(t *testing.T) {\n\t\tvar target struct {\n\t\t\tFiles []*multipart.FileHeader `form:\"files\"`\n\t\t}\n\t\terr := bindMultipartFiles(t, &target, filesA, filesB, file1)\n\n\t\tassert.NoError(t, err)\n\n\t\tassert.Len(t, target.Files, 2)\n\t\tassertMultipartFileHeader(t, target.Files[0], filesA)\n\t\tassertMultipartFileHeader(t, target.Files[1], filesB)\n\t})\n}\n\ntype testFormFile struct {\n\tFieldname string\n\tFilename  string\n\tContent   []byte\n}\n\nfunc createTestFormFile(formFieldName string, filename string) testFormFile {\n\treturn testFormFile{\n\t\tFieldname: formFieldName,\n\t\tFilename:  filename,\n\t\tContent:   []byte(strings.Repeat(filename, 10)),\n\t}\n}\n\nfunc bindMultipartFiles(t *testing.T, target any, files ...testFormFile) error {\n\tvar body bytes.Buffer\n\tmw := multipart.NewWriter(&body)\n\n\tfor _, file := range files {\n\t\tfw, err := mw.CreateFormFile(file.Fieldname, file.Filename)\n\t\tassert.NoError(t, err)\n\n\t\tn, err := fw.Write(file.Content)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, len(file.Content), n)\n\t}\n\n\terr := mw.Close()\n\tassert.NoError(t, err)\n\n\treq, err := http.NewRequest(http.MethodPost, \"/\", &body)\n\tassert.NoError(t, err)\n\treq.Header.Set(\"Content-Type\", mw.FormDataContentType())\n\n\trec := httptest.NewRecorder()\n\n\te := New()\n\tc := e.NewContext(req, rec)\n\treturn c.Bind(target)\n}\n\nfunc assertMultipartFileHeader(t *testing.T, fh *multipart.FileHeader, file testFormFile) {\n\tassert.Equal(t, file.Filename, fh.Filename)\n\tassert.Equal(t, int64(len(file.Content)), fh.Size)\n\tfl, err := fh.Open()\n\tassert.NoError(t, err)\n\tbody, err := io.ReadAll(fl)\n\tassert.NoError(t, err)\n\tassert.Equal(t, string(file.Content), string(body))\n\terr = fl.Close()\n\tassert.NoError(t, err)\n}\n"
        },
        {
          "name": "binder.go",
          "type": "blob",
          "size": 42.8251953125,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"encoding\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n/**\n\tFollowing functions provide handful of methods for binding to Go native types from request query or path parameters.\n    * QueryParamsBinder(c) - binds query parameters (source URL)\n    * PathParamsBinder(c) - binds path parameters (source URL)\n    * FormFieldBinder(c) - binds form fields (source URL + body)\n\n\tExample:\n  ```go\n  var length int64\n  err := echo.QueryParamsBinder(c).Int64(\"length\", &length).BindError()\n  ```\n\n\tFor every supported type there are following methods:\n\t\t* <Type>(\"param\", &destination) - if parameter value exists then binds it to given destination of that type i.e Int64(...).\n\t\t* Must<Type>(\"param\", &destination) - parameter value is required to exist, binds it to given destination of that type i.e MustInt64(...).\n\t\t* <Type>s(\"param\", &destination) - (for slices) if parameter values exists then binds it to given destination of that type i.e Int64s(...).\n\t\t* Must<Type>s(\"param\", &destination) - (for slices) parameter value is required to exist, binds it to given destination of that type i.e MustInt64s(...).\n\n  for some slice types `BindWithDelimiter(\"param\", &dest, \",\")` supports splitting parameter values before type conversion is done\n  i.e. URL `/api/search?id=1,2,3&id=1` can be bind to `[]int64{1,2,3,1}`\n\n\t`FailFast` flags binder to stop binding after first bind error during binder call chain. Enabled by default.\n  `BindError()` returns first bind error from binder and resets errors in binder. Useful along with `FailFast()` method\n\t\tto do binding and returns on first problem\n  `BindErrors()` returns all bind errors from binder and resets errors in binder.\n\n\tTypes that are supported:\n\t\t* bool\n\t\t* float32\n\t\t* float64\n\t\t* int\n\t\t* int8\n\t\t* int16\n\t\t* int32\n\t\t* int64\n\t\t* uint\n\t\t* uint8/byte (does not support `bytes()`. Use BindUnmarshaler/CustomFunc to convert value from base64 etc to []byte{})\n\t\t* uint16\n\t\t* uint32\n\t\t* uint64\n\t\t* string\n\t\t* time\n\t\t* duration\n\t\t* BindUnmarshaler() interface\n\t\t* TextUnmarshaler() interface\n\t\t* JSONUnmarshaler() interface\n\t\t* UnixTime() - converts unix time (integer) to time.Time\n\t\t* UnixTimeMilli() - converts unix time with millisecond precision (integer) to time.Time\n\t\t* UnixTimeNano() - converts unix time with nanosecond precision (integer) to time.Time\n\t\t* CustomFunc() - callback function for your custom conversion logic. Signature `func(values []string) []error`\n*/\n\n// BindingError represents an error that occurred while binding request data.\ntype BindingError struct {\n\t// Field is the field name where value binding failed\n\tField string `json:\"field\"`\n\t*HTTPError\n\t// Values of parameter that failed to bind.\n\tValues []string `json:\"-\"`\n}\n\n// NewBindingError creates new instance of binding error\nfunc NewBindingError(sourceParam string, values []string, message interface{}, internalError error) error {\n\treturn &BindingError{\n\t\tField:  sourceParam,\n\t\tValues: values,\n\t\tHTTPError: &HTTPError{\n\t\t\tCode:     http.StatusBadRequest,\n\t\t\tMessage:  message,\n\t\t\tInternal: internalError,\n\t\t},\n\t}\n}\n\n// Error returns error message\nfunc (be *BindingError) Error() string {\n\treturn fmt.Sprintf(\"%s, field=%s\", be.HTTPError.Error(), be.Field)\n}\n\n// ValueBinder provides utility methods for binding query or path parameter to various Go built-in types\ntype ValueBinder struct {\n\t// ValueFunc is used to get single parameter (first) value from request\n\tValueFunc func(sourceParam string) string\n\t// ValuesFunc is used to get all values for parameter from request. i.e. `/api/search?ids=1&ids=2`\n\tValuesFunc func(sourceParam string) []string\n\t// ErrorFunc is used to create errors. Allows you to use your own error type, that for example marshals to your specific json response\n\tErrorFunc func(sourceParam string, values []string, message interface{}, internalError error) error\n\terrors    []error\n\t// failFast is flag for binding methods to return without attempting to bind when previous binding already failed\n\tfailFast bool\n}\n\n// QueryParamsBinder creates query parameter value binder\nfunc QueryParamsBinder(c Context) *ValueBinder {\n\treturn &ValueBinder{\n\t\tfailFast:  true,\n\t\tValueFunc: c.QueryParam,\n\t\tValuesFunc: func(sourceParam string) []string {\n\t\t\tvalues, ok := c.QueryParams()[sourceParam]\n\t\t\tif !ok {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn values\n\t\t},\n\t\tErrorFunc: NewBindingError,\n\t}\n}\n\n// PathParamsBinder creates path parameter value binder\nfunc PathParamsBinder(c Context) *ValueBinder {\n\treturn &ValueBinder{\n\t\tfailFast:  true,\n\t\tValueFunc: c.Param,\n\t\tValuesFunc: func(sourceParam string) []string {\n\t\t\t// path parameter should not have multiple values so getting values does not make sense but lets not error out here\n\t\t\tvalue := c.Param(sourceParam)\n\t\t\tif value == \"\" {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn []string{value}\n\t\t},\n\t\tErrorFunc: NewBindingError,\n\t}\n}\n\n// FormFieldBinder creates form field value binder\n// For all requests, FormFieldBinder parses the raw query from the URL and uses query params as form fields\n//\n// For POST, PUT, and PATCH requests, it also reads the request body, parses it\n// as a form and uses query params as form fields. Request body parameters take precedence over URL query\n// string values in r.Form.\n//\n// NB: when binding forms take note that this implementation uses standard library form parsing\n// which parses form data from BOTH URL and BODY if content type is not MIMEMultipartForm\n// See https://golang.org/pkg/net/http/#Request.ParseForm\nfunc FormFieldBinder(c Context) *ValueBinder {\n\tvb := &ValueBinder{\n\t\tfailFast: true,\n\t\tValueFunc: func(sourceParam string) string {\n\t\t\treturn c.Request().FormValue(sourceParam)\n\t\t},\n\t\tErrorFunc: NewBindingError,\n\t}\n\tvb.ValuesFunc = func(sourceParam string) []string {\n\t\tif c.Request().Form == nil {\n\t\t\t// this is same as `Request().FormValue()` does internally\n\t\t\t_ = c.Request().ParseMultipartForm(32 << 20)\n\t\t}\n\t\tvalues, ok := c.Request().Form[sourceParam]\n\t\tif !ok {\n\t\t\treturn nil\n\t\t}\n\t\treturn values\n\t}\n\n\treturn vb\n}\n\n// FailFast set internal flag to indicate if binding methods will return early (without binding) when previous bind failed\n// NB: call this method before any other binding methods as it modifies binding methods behaviour\nfunc (b *ValueBinder) FailFast(value bool) *ValueBinder {\n\tb.failFast = value\n\treturn b\n}\n\nfunc (b *ValueBinder) setError(err error) {\n\tif b.errors == nil {\n\t\tb.errors = []error{err}\n\t\treturn\n\t}\n\tb.errors = append(b.errors, err)\n}\n\n// BindError returns first seen bind error and resets/empties binder errors for further calls\nfunc (b *ValueBinder) BindError() error {\n\tif b.errors == nil {\n\t\treturn nil\n\t}\n\terr := b.errors[0]\n\tb.errors = nil // reset errors so next chain will start from zero\n\treturn err\n}\n\n// BindErrors returns all bind errors and resets/empties binder errors for further calls\nfunc (b *ValueBinder) BindErrors() []error {\n\tif b.errors == nil {\n\t\treturn nil\n\t}\n\terrors := b.errors\n\tb.errors = nil // reset errors so next chain will start from zero\n\treturn errors\n}\n\n// CustomFunc binds parameter values with Func. Func is called only when parameter values exist.\nfunc (b *ValueBinder) CustomFunc(sourceParam string, customFunc func(values []string) []error) *ValueBinder {\n\treturn b.customFunc(sourceParam, customFunc, false)\n}\n\n// MustCustomFunc requires parameter values to exist to bind with Func. Returns error when value does not exist.\nfunc (b *ValueBinder) MustCustomFunc(sourceParam string, customFunc func(values []string) []error) *ValueBinder {\n\treturn b.customFunc(sourceParam, customFunc, true)\n}\n\nfunc (b *ValueBinder) customFunc(sourceParam string, customFunc func(values []string) []error, valueMustExist bool) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalues := b.ValuesFunc(sourceParam)\n\tif len(values) == 0 {\n\t\tif valueMustExist {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{}, \"required field value is empty\", nil))\n\t\t}\n\t\treturn b\n\t}\n\tif errs := customFunc(values); errs != nil {\n\t\tb.errors = append(b.errors, errs...)\n\t}\n\treturn b\n}\n\n// String binds parameter to string variable\nfunc (b *ValueBinder) String(sourceParam string, dest *string) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalue := b.ValueFunc(sourceParam)\n\tif value == \"\" {\n\t\treturn b\n\t}\n\t*dest = value\n\treturn b\n}\n\n// MustString requires parameter value to exist to bind to string variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustString(sourceParam string, dest *string) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalue := b.ValueFunc(sourceParam)\n\tif value == \"\" {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{value}, \"required field value is empty\", nil))\n\t\treturn b\n\t}\n\t*dest = value\n\treturn b\n}\n\n// Strings binds parameter values to slice of string\nfunc (b *ValueBinder) Strings(sourceParam string, dest *[]string) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalue := b.ValuesFunc(sourceParam)\n\tif value == nil {\n\t\treturn b\n\t}\n\t*dest = value\n\treturn b\n}\n\n// MustStrings requires parameter values to exist to bind to slice of string variables. Returns error when value does not exist\nfunc (b *ValueBinder) MustStrings(sourceParam string, dest *[]string) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalue := b.ValuesFunc(sourceParam)\n\tif value == nil {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{}, \"required field value is empty\", nil))\n\t\treturn b\n\t}\n\t*dest = value\n\treturn b\n}\n\n// BindUnmarshaler binds parameter to destination implementing BindUnmarshaler interface\nfunc (b *ValueBinder) BindUnmarshaler(sourceParam string, dest BindUnmarshaler) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\ttmp := b.ValueFunc(sourceParam)\n\tif tmp == \"\" {\n\t\treturn b\n\t}\n\n\tif err := dest.UnmarshalParam(tmp); err != nil {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{tmp}, \"failed to bind field value to BindUnmarshaler interface\", err))\n\t}\n\treturn b\n}\n\n// MustBindUnmarshaler requires parameter value to exist to bind to destination implementing BindUnmarshaler interface.\n// Returns error when value does not exist\nfunc (b *ValueBinder) MustBindUnmarshaler(sourceParam string, dest BindUnmarshaler) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalue := b.ValueFunc(sourceParam)\n\tif value == \"\" {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{value}, \"required field value is empty\", nil))\n\t\treturn b\n\t}\n\n\tif err := dest.UnmarshalParam(value); err != nil {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{value}, \"failed to bind field value to BindUnmarshaler interface\", err))\n\t}\n\treturn b\n}\n\n// JSONUnmarshaler binds parameter to destination implementing json.Unmarshaler interface\nfunc (b *ValueBinder) JSONUnmarshaler(sourceParam string, dest json.Unmarshaler) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\ttmp := b.ValueFunc(sourceParam)\n\tif tmp == \"\" {\n\t\treturn b\n\t}\n\n\tif err := dest.UnmarshalJSON([]byte(tmp)); err != nil {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{tmp}, \"failed to bind field value to json.Unmarshaler interface\", err))\n\t}\n\treturn b\n}\n\n// MustJSONUnmarshaler requires parameter value to exist to bind to destination implementing json.Unmarshaler interface.\n// Returns error when value does not exist\nfunc (b *ValueBinder) MustJSONUnmarshaler(sourceParam string, dest json.Unmarshaler) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\ttmp := b.ValueFunc(sourceParam)\n\tif tmp == \"\" {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{tmp}, \"required field value is empty\", nil))\n\t\treturn b\n\t}\n\n\tif err := dest.UnmarshalJSON([]byte(tmp)); err != nil {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{tmp}, \"failed to bind field value to json.Unmarshaler interface\", err))\n\t}\n\treturn b\n}\n\n// TextUnmarshaler binds parameter to destination implementing encoding.TextUnmarshaler interface\nfunc (b *ValueBinder) TextUnmarshaler(sourceParam string, dest encoding.TextUnmarshaler) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\ttmp := b.ValueFunc(sourceParam)\n\tif tmp == \"\" {\n\t\treturn b\n\t}\n\n\tif err := dest.UnmarshalText([]byte(tmp)); err != nil {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{tmp}, \"failed to bind field value to encoding.TextUnmarshaler interface\", err))\n\t}\n\treturn b\n}\n\n// MustTextUnmarshaler requires parameter value to exist to bind to destination implementing encoding.TextUnmarshaler interface.\n// Returns error when value does not exist\nfunc (b *ValueBinder) MustTextUnmarshaler(sourceParam string, dest encoding.TextUnmarshaler) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\ttmp := b.ValueFunc(sourceParam)\n\tif tmp == \"\" {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{tmp}, \"required field value is empty\", nil))\n\t\treturn b\n\t}\n\n\tif err := dest.UnmarshalText([]byte(tmp)); err != nil {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{tmp}, \"failed to bind field value to encoding.TextUnmarshaler interface\", err))\n\t}\n\treturn b\n}\n\n// BindWithDelimiter binds parameter to destination by suitable conversion function.\n// Delimiter is used before conversion to split parameter value to separate values\nfunc (b *ValueBinder) BindWithDelimiter(sourceParam string, dest interface{}, delimiter string) *ValueBinder {\n\treturn b.bindWithDelimiter(sourceParam, dest, delimiter, false)\n}\n\n// MustBindWithDelimiter requires parameter value to exist to bind destination by suitable conversion function.\n// Delimiter is used before conversion to split parameter value to separate values\nfunc (b *ValueBinder) MustBindWithDelimiter(sourceParam string, dest interface{}, delimiter string) *ValueBinder {\n\treturn b.bindWithDelimiter(sourceParam, dest, delimiter, true)\n}\n\nfunc (b *ValueBinder) bindWithDelimiter(sourceParam string, dest interface{}, delimiter string, valueMustExist bool) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\tvalues := b.ValuesFunc(sourceParam)\n\tif len(values) == 0 {\n\t\tif valueMustExist {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{}, \"required field value is empty\", nil))\n\t\t}\n\t\treturn b\n\t}\n\ttmpValues := make([]string, 0, len(values))\n\tfor _, v := range values {\n\t\ttmpValues = append(tmpValues, strings.Split(v, delimiter)...)\n\t}\n\n\tswitch d := dest.(type) {\n\tcase *[]string:\n\t\t*d = tmpValues\n\t\treturn b\n\tcase *[]bool:\n\t\treturn b.bools(sourceParam, tmpValues, d)\n\tcase *[]int64, *[]int32, *[]int16, *[]int8, *[]int:\n\t\treturn b.ints(sourceParam, tmpValues, d)\n\tcase *[]uint64, *[]uint32, *[]uint16, *[]uint8, *[]uint: // *[]byte is same as *[]uint8\n\t\treturn b.uints(sourceParam, tmpValues, d)\n\tcase *[]float64, *[]float32:\n\t\treturn b.floats(sourceParam, tmpValues, d)\n\tcase *[]time.Duration:\n\t\treturn b.durations(sourceParam, tmpValues, d)\n\tdefault:\n\t\t// support only cases when destination is slice\n\t\t// does not support time.Time as it needs argument (layout) for parsing or BindUnmarshaler\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{}, \"unsupported bind type\", nil))\n\t\treturn b\n\t}\n}\n\n// Int64 binds parameter to int64 variable\nfunc (b *ValueBinder) Int64(sourceParam string, dest *int64) *ValueBinder {\n\treturn b.intValue(sourceParam, dest, 64, false)\n}\n\n// MustInt64 requires parameter value to exist to bind to int64 variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustInt64(sourceParam string, dest *int64) *ValueBinder {\n\treturn b.intValue(sourceParam, dest, 64, true)\n}\n\n// Int32 binds parameter to int32 variable\nfunc (b *ValueBinder) Int32(sourceParam string, dest *int32) *ValueBinder {\n\treturn b.intValue(sourceParam, dest, 32, false)\n}\n\n// MustInt32 requires parameter value to exist to bind to int32 variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustInt32(sourceParam string, dest *int32) *ValueBinder {\n\treturn b.intValue(sourceParam, dest, 32, true)\n}\n\n// Int16 binds parameter to int16 variable\nfunc (b *ValueBinder) Int16(sourceParam string, dest *int16) *ValueBinder {\n\treturn b.intValue(sourceParam, dest, 16, false)\n}\n\n// MustInt16 requires parameter value to exist to bind to int16 variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustInt16(sourceParam string, dest *int16) *ValueBinder {\n\treturn b.intValue(sourceParam, dest, 16, true)\n}\n\n// Int8 binds parameter to int8 variable\nfunc (b *ValueBinder) Int8(sourceParam string, dest *int8) *ValueBinder {\n\treturn b.intValue(sourceParam, dest, 8, false)\n}\n\n// MustInt8 requires parameter value to exist to bind to int8 variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustInt8(sourceParam string, dest *int8) *ValueBinder {\n\treturn b.intValue(sourceParam, dest, 8, true)\n}\n\n// Int binds parameter to int variable\nfunc (b *ValueBinder) Int(sourceParam string, dest *int) *ValueBinder {\n\treturn b.intValue(sourceParam, dest, 0, false)\n}\n\n// MustInt requires parameter value to exist to bind to int variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustInt(sourceParam string, dest *int) *ValueBinder {\n\treturn b.intValue(sourceParam, dest, 0, true)\n}\n\nfunc (b *ValueBinder) intValue(sourceParam string, dest interface{}, bitSize int, valueMustExist bool) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalue := b.ValueFunc(sourceParam)\n\tif value == \"\" {\n\t\tif valueMustExist {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{}, \"required field value is empty\", nil))\n\t\t}\n\t\treturn b\n\t}\n\n\treturn b.int(sourceParam, value, dest, bitSize)\n}\n\nfunc (b *ValueBinder) int(sourceParam string, value string, dest interface{}, bitSize int) *ValueBinder {\n\tn, err := strconv.ParseInt(value, 10, bitSize)\n\tif err != nil {\n\t\tif bitSize == 0 {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{value}, \"failed to bind field value to int\", err))\n\t\t} else {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{value}, fmt.Sprintf(\"failed to bind field value to int%v\", bitSize), err))\n\t\t}\n\t\treturn b\n\t}\n\n\tswitch d := dest.(type) {\n\tcase *int64:\n\t\t*d = n\n\tcase *int32:\n\t\t*d = int32(n)\n\tcase *int16:\n\t\t*d = int16(n)\n\tcase *int8:\n\t\t*d = int8(n)\n\tcase *int:\n\t\t*d = int(n)\n\t}\n\treturn b\n}\n\nfunc (b *ValueBinder) intsValue(sourceParam string, dest interface{}, valueMustExist bool) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalues := b.ValuesFunc(sourceParam)\n\tif len(values) == 0 {\n\t\tif valueMustExist {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, values, \"required field value is empty\", nil))\n\t\t}\n\t\treturn b\n\t}\n\treturn b.ints(sourceParam, values, dest)\n}\n\nfunc (b *ValueBinder) ints(sourceParam string, values []string, dest interface{}) *ValueBinder {\n\tswitch d := dest.(type) {\n\tcase *[]int64:\n\t\ttmp := make([]int64, len(values))\n\t\tfor i, v := range values {\n\t\t\tb.int(sourceParam, v, &tmp[i], 64)\n\t\t\tif b.failFast && b.errors != nil {\n\t\t\t\treturn b\n\t\t\t}\n\t\t}\n\t\tif b.errors == nil {\n\t\t\t*d = tmp\n\t\t}\n\tcase *[]int32:\n\t\ttmp := make([]int32, len(values))\n\t\tfor i, v := range values {\n\t\t\tb.int(sourceParam, v, &tmp[i], 32)\n\t\t\tif b.failFast && b.errors != nil {\n\t\t\t\treturn b\n\t\t\t}\n\t\t}\n\t\tif b.errors == nil {\n\t\t\t*d = tmp\n\t\t}\n\tcase *[]int16:\n\t\ttmp := make([]int16, len(values))\n\t\tfor i, v := range values {\n\t\t\tb.int(sourceParam, v, &tmp[i], 16)\n\t\t\tif b.failFast && b.errors != nil {\n\t\t\t\treturn b\n\t\t\t}\n\t\t}\n\t\tif b.errors == nil {\n\t\t\t*d = tmp\n\t\t}\n\tcase *[]int8:\n\t\ttmp := make([]int8, len(values))\n\t\tfor i, v := range values {\n\t\t\tb.int(sourceParam, v, &tmp[i], 8)\n\t\t\tif b.failFast && b.errors != nil {\n\t\t\t\treturn b\n\t\t\t}\n\t\t}\n\t\tif b.errors == nil {\n\t\t\t*d = tmp\n\t\t}\n\tcase *[]int:\n\t\ttmp := make([]int, len(values))\n\t\tfor i, v := range values {\n\t\t\tb.int(sourceParam, v, &tmp[i], 0)\n\t\t\tif b.failFast && b.errors != nil {\n\t\t\t\treturn b\n\t\t\t}\n\t\t}\n\t\tif b.errors == nil {\n\t\t\t*d = tmp\n\t\t}\n\t}\n\treturn b\n}\n\n// Int64s binds parameter to slice of int64\nfunc (b *ValueBinder) Int64s(sourceParam string, dest *[]int64) *ValueBinder {\n\treturn b.intsValue(sourceParam, dest, false)\n}\n\n// MustInt64s requires parameter value to exist to bind to int64 slice variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustInt64s(sourceParam string, dest *[]int64) *ValueBinder {\n\treturn b.intsValue(sourceParam, dest, true)\n}\n\n// Int32s binds parameter to slice of int32\nfunc (b *ValueBinder) Int32s(sourceParam string, dest *[]int32) *ValueBinder {\n\treturn b.intsValue(sourceParam, dest, false)\n}\n\n// MustInt32s requires parameter value to exist to bind to int32 slice variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustInt32s(sourceParam string, dest *[]int32) *ValueBinder {\n\treturn b.intsValue(sourceParam, dest, true)\n}\n\n// Int16s binds parameter to slice of int16\nfunc (b *ValueBinder) Int16s(sourceParam string, dest *[]int16) *ValueBinder {\n\treturn b.intsValue(sourceParam, dest, false)\n}\n\n// MustInt16s requires parameter value to exist to bind to int16 slice variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustInt16s(sourceParam string, dest *[]int16) *ValueBinder {\n\treturn b.intsValue(sourceParam, dest, true)\n}\n\n// Int8s binds parameter to slice of int8\nfunc (b *ValueBinder) Int8s(sourceParam string, dest *[]int8) *ValueBinder {\n\treturn b.intsValue(sourceParam, dest, false)\n}\n\n// MustInt8s requires parameter value to exist to bind to int8 slice variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustInt8s(sourceParam string, dest *[]int8) *ValueBinder {\n\treturn b.intsValue(sourceParam, dest, true)\n}\n\n// Ints binds parameter to slice of int\nfunc (b *ValueBinder) Ints(sourceParam string, dest *[]int) *ValueBinder {\n\treturn b.intsValue(sourceParam, dest, false)\n}\n\n// MustInts requires parameter value to exist to bind to int slice variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustInts(sourceParam string, dest *[]int) *ValueBinder {\n\treturn b.intsValue(sourceParam, dest, true)\n}\n\n// Uint64 binds parameter to uint64 variable\nfunc (b *ValueBinder) Uint64(sourceParam string, dest *uint64) *ValueBinder {\n\treturn b.uintValue(sourceParam, dest, 64, false)\n}\n\n// MustUint64 requires parameter value to exist to bind to uint64 variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustUint64(sourceParam string, dest *uint64) *ValueBinder {\n\treturn b.uintValue(sourceParam, dest, 64, true)\n}\n\n// Uint32 binds parameter to uint32 variable\nfunc (b *ValueBinder) Uint32(sourceParam string, dest *uint32) *ValueBinder {\n\treturn b.uintValue(sourceParam, dest, 32, false)\n}\n\n// MustUint32 requires parameter value to exist to bind to uint32 variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustUint32(sourceParam string, dest *uint32) *ValueBinder {\n\treturn b.uintValue(sourceParam, dest, 32, true)\n}\n\n// Uint16 binds parameter to uint16 variable\nfunc (b *ValueBinder) Uint16(sourceParam string, dest *uint16) *ValueBinder {\n\treturn b.uintValue(sourceParam, dest, 16, false)\n}\n\n// MustUint16 requires parameter value to exist to bind to uint16 variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustUint16(sourceParam string, dest *uint16) *ValueBinder {\n\treturn b.uintValue(sourceParam, dest, 16, true)\n}\n\n// Uint8 binds parameter to uint8 variable\nfunc (b *ValueBinder) Uint8(sourceParam string, dest *uint8) *ValueBinder {\n\treturn b.uintValue(sourceParam, dest, 8, false)\n}\n\n// MustUint8 requires parameter value to exist to bind to uint8 variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustUint8(sourceParam string, dest *uint8) *ValueBinder {\n\treturn b.uintValue(sourceParam, dest, 8, true)\n}\n\n// Byte binds parameter to byte variable\nfunc (b *ValueBinder) Byte(sourceParam string, dest *byte) *ValueBinder {\n\treturn b.uintValue(sourceParam, dest, 8, false)\n}\n\n// MustByte requires parameter value to exist to bind to byte variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustByte(sourceParam string, dest *byte) *ValueBinder {\n\treturn b.uintValue(sourceParam, dest, 8, true)\n}\n\n// Uint binds parameter to uint variable\nfunc (b *ValueBinder) Uint(sourceParam string, dest *uint) *ValueBinder {\n\treturn b.uintValue(sourceParam, dest, 0, false)\n}\n\n// MustUint requires parameter value to exist to bind to uint variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustUint(sourceParam string, dest *uint) *ValueBinder {\n\treturn b.uintValue(sourceParam, dest, 0, true)\n}\n\nfunc (b *ValueBinder) uintValue(sourceParam string, dest interface{}, bitSize int, valueMustExist bool) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalue := b.ValueFunc(sourceParam)\n\tif value == \"\" {\n\t\tif valueMustExist {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{}, \"required field value is empty\", nil))\n\t\t}\n\t\treturn b\n\t}\n\n\treturn b.uint(sourceParam, value, dest, bitSize)\n}\n\nfunc (b *ValueBinder) uint(sourceParam string, value string, dest interface{}, bitSize int) *ValueBinder {\n\tn, err := strconv.ParseUint(value, 10, bitSize)\n\tif err != nil {\n\t\tif bitSize == 0 {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{value}, \"failed to bind field value to uint\", err))\n\t\t} else {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{value}, fmt.Sprintf(\"failed to bind field value to uint%v\", bitSize), err))\n\t\t}\n\t\treturn b\n\t}\n\n\tswitch d := dest.(type) {\n\tcase *uint64:\n\t\t*d = n\n\tcase *uint32:\n\t\t*d = uint32(n)\n\tcase *uint16:\n\t\t*d = uint16(n)\n\tcase *uint8: // byte is alias to uint8\n\t\t*d = uint8(n)\n\tcase *uint:\n\t\t*d = uint(n)\n\t}\n\treturn b\n}\n\nfunc (b *ValueBinder) uintsValue(sourceParam string, dest interface{}, valueMustExist bool) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalues := b.ValuesFunc(sourceParam)\n\tif len(values) == 0 {\n\t\tif valueMustExist {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, values, \"required field value is empty\", nil))\n\t\t}\n\t\treturn b\n\t}\n\treturn b.uints(sourceParam, values, dest)\n}\n\nfunc (b *ValueBinder) uints(sourceParam string, values []string, dest interface{}) *ValueBinder {\n\tswitch d := dest.(type) {\n\tcase *[]uint64:\n\t\ttmp := make([]uint64, len(values))\n\t\tfor i, v := range values {\n\t\t\tb.uint(sourceParam, v, &tmp[i], 64)\n\t\t\tif b.failFast && b.errors != nil {\n\t\t\t\treturn b\n\t\t\t}\n\t\t}\n\t\tif b.errors == nil {\n\t\t\t*d = tmp\n\t\t}\n\tcase *[]uint32:\n\t\ttmp := make([]uint32, len(values))\n\t\tfor i, v := range values {\n\t\t\tb.uint(sourceParam, v, &tmp[i], 32)\n\t\t\tif b.failFast && b.errors != nil {\n\t\t\t\treturn b\n\t\t\t}\n\t\t}\n\t\tif b.errors == nil {\n\t\t\t*d = tmp\n\t\t}\n\tcase *[]uint16:\n\t\ttmp := make([]uint16, len(values))\n\t\tfor i, v := range values {\n\t\t\tb.uint(sourceParam, v, &tmp[i], 16)\n\t\t\tif b.failFast && b.errors != nil {\n\t\t\t\treturn b\n\t\t\t}\n\t\t}\n\t\tif b.errors == nil {\n\t\t\t*d = tmp\n\t\t}\n\tcase *[]uint8: // byte is alias to uint8\n\t\ttmp := make([]uint8, len(values))\n\t\tfor i, v := range values {\n\t\t\tb.uint(sourceParam, v, &tmp[i], 8)\n\t\t\tif b.failFast && b.errors != nil {\n\t\t\t\treturn b\n\t\t\t}\n\t\t}\n\t\tif b.errors == nil {\n\t\t\t*d = tmp\n\t\t}\n\tcase *[]uint:\n\t\ttmp := make([]uint, len(values))\n\t\tfor i, v := range values {\n\t\t\tb.uint(sourceParam, v, &tmp[i], 0)\n\t\t\tif b.failFast && b.errors != nil {\n\t\t\t\treturn b\n\t\t\t}\n\t\t}\n\t\tif b.errors == nil {\n\t\t\t*d = tmp\n\t\t}\n\t}\n\treturn b\n}\n\n// Uint64s binds parameter to slice of uint64\nfunc (b *ValueBinder) Uint64s(sourceParam string, dest *[]uint64) *ValueBinder {\n\treturn b.uintsValue(sourceParam, dest, false)\n}\n\n// MustUint64s requires parameter value to exist to bind to uint64 slice variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustUint64s(sourceParam string, dest *[]uint64) *ValueBinder {\n\treturn b.uintsValue(sourceParam, dest, true)\n}\n\n// Uint32s binds parameter to slice of uint32\nfunc (b *ValueBinder) Uint32s(sourceParam string, dest *[]uint32) *ValueBinder {\n\treturn b.uintsValue(sourceParam, dest, false)\n}\n\n// MustUint32s requires parameter value to exist to bind to uint32 slice variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustUint32s(sourceParam string, dest *[]uint32) *ValueBinder {\n\treturn b.uintsValue(sourceParam, dest, true)\n}\n\n// Uint16s binds parameter to slice of uint16\nfunc (b *ValueBinder) Uint16s(sourceParam string, dest *[]uint16) *ValueBinder {\n\treturn b.uintsValue(sourceParam, dest, false)\n}\n\n// MustUint16s requires parameter value to exist to bind to uint16 slice variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustUint16s(sourceParam string, dest *[]uint16) *ValueBinder {\n\treturn b.uintsValue(sourceParam, dest, true)\n}\n\n// Uint8s binds parameter to slice of uint8\nfunc (b *ValueBinder) Uint8s(sourceParam string, dest *[]uint8) *ValueBinder {\n\treturn b.uintsValue(sourceParam, dest, false)\n}\n\n// MustUint8s requires parameter value to exist to bind to uint8 slice variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustUint8s(sourceParam string, dest *[]uint8) *ValueBinder {\n\treturn b.uintsValue(sourceParam, dest, true)\n}\n\n// Uints binds parameter to slice of uint\nfunc (b *ValueBinder) Uints(sourceParam string, dest *[]uint) *ValueBinder {\n\treturn b.uintsValue(sourceParam, dest, false)\n}\n\n// MustUints requires parameter value to exist to bind to uint slice variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustUints(sourceParam string, dest *[]uint) *ValueBinder {\n\treturn b.uintsValue(sourceParam, dest, true)\n}\n\n// Bool binds parameter to bool variable\nfunc (b *ValueBinder) Bool(sourceParam string, dest *bool) *ValueBinder {\n\treturn b.boolValue(sourceParam, dest, false)\n}\n\n// MustBool requires parameter value to exist to bind to bool variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustBool(sourceParam string, dest *bool) *ValueBinder {\n\treturn b.boolValue(sourceParam, dest, true)\n}\n\nfunc (b *ValueBinder) boolValue(sourceParam string, dest *bool, valueMustExist bool) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalue := b.ValueFunc(sourceParam)\n\tif value == \"\" {\n\t\tif valueMustExist {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{}, \"required field value is empty\", nil))\n\t\t}\n\t\treturn b\n\t}\n\treturn b.bool(sourceParam, value, dest)\n}\n\nfunc (b *ValueBinder) bool(sourceParam string, value string, dest *bool) *ValueBinder {\n\tn, err := strconv.ParseBool(value)\n\tif err != nil {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{value}, \"failed to bind field value to bool\", err))\n\t\treturn b\n\t}\n\n\t*dest = n\n\treturn b\n}\n\nfunc (b *ValueBinder) boolsValue(sourceParam string, dest *[]bool, valueMustExist bool) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalues := b.ValuesFunc(sourceParam)\n\tif len(values) == 0 {\n\t\tif valueMustExist {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{}, \"required field value is empty\", nil))\n\t\t}\n\t\treturn b\n\t}\n\treturn b.bools(sourceParam, values, dest)\n}\n\nfunc (b *ValueBinder) bools(sourceParam string, values []string, dest *[]bool) *ValueBinder {\n\ttmp := make([]bool, len(values))\n\tfor i, v := range values {\n\t\tb.bool(sourceParam, v, &tmp[i])\n\t\tif b.failFast && b.errors != nil {\n\t\t\treturn b\n\t\t}\n\t}\n\tif b.errors == nil {\n\t\t*dest = tmp\n\t}\n\treturn b\n}\n\n// Bools binds parameter values to slice of bool variables\nfunc (b *ValueBinder) Bools(sourceParam string, dest *[]bool) *ValueBinder {\n\treturn b.boolsValue(sourceParam, dest, false)\n}\n\n// MustBools requires parameter values to exist to bind to slice of bool variables. Returns error when values does not exist\nfunc (b *ValueBinder) MustBools(sourceParam string, dest *[]bool) *ValueBinder {\n\treturn b.boolsValue(sourceParam, dest, true)\n}\n\n// Float64 binds parameter to float64 variable\nfunc (b *ValueBinder) Float64(sourceParam string, dest *float64) *ValueBinder {\n\treturn b.floatValue(sourceParam, dest, 64, false)\n}\n\n// MustFloat64 requires parameter value to exist to bind to float64 variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustFloat64(sourceParam string, dest *float64) *ValueBinder {\n\treturn b.floatValue(sourceParam, dest, 64, true)\n}\n\n// Float32 binds parameter to float32 variable\nfunc (b *ValueBinder) Float32(sourceParam string, dest *float32) *ValueBinder {\n\treturn b.floatValue(sourceParam, dest, 32, false)\n}\n\n// MustFloat32 requires parameter value to exist to bind to float32 variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustFloat32(sourceParam string, dest *float32) *ValueBinder {\n\treturn b.floatValue(sourceParam, dest, 32, true)\n}\n\nfunc (b *ValueBinder) floatValue(sourceParam string, dest interface{}, bitSize int, valueMustExist bool) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalue := b.ValueFunc(sourceParam)\n\tif value == \"\" {\n\t\tif valueMustExist {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{}, \"required field value is empty\", nil))\n\t\t}\n\t\treturn b\n\t}\n\n\treturn b.float(sourceParam, value, dest, bitSize)\n}\n\nfunc (b *ValueBinder) float(sourceParam string, value string, dest interface{}, bitSize int) *ValueBinder {\n\tn, err := strconv.ParseFloat(value, bitSize)\n\tif err != nil {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{value}, fmt.Sprintf(\"failed to bind field value to float%v\", bitSize), err))\n\t\treturn b\n\t}\n\n\tswitch d := dest.(type) {\n\tcase *float64:\n\t\t*d = n\n\tcase *float32:\n\t\t*d = float32(n)\n\t}\n\treturn b\n}\n\nfunc (b *ValueBinder) floatsValue(sourceParam string, dest interface{}, valueMustExist bool) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalues := b.ValuesFunc(sourceParam)\n\tif len(values) == 0 {\n\t\tif valueMustExist {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{}, \"required field value is empty\", nil))\n\t\t}\n\t\treturn b\n\t}\n\treturn b.floats(sourceParam, values, dest)\n}\n\nfunc (b *ValueBinder) floats(sourceParam string, values []string, dest interface{}) *ValueBinder {\n\tswitch d := dest.(type) {\n\tcase *[]float64:\n\t\ttmp := make([]float64, len(values))\n\t\tfor i, v := range values {\n\t\t\tb.float(sourceParam, v, &tmp[i], 64)\n\t\t\tif b.failFast && b.errors != nil {\n\t\t\t\treturn b\n\t\t\t}\n\t\t}\n\t\tif b.errors == nil {\n\t\t\t*d = tmp\n\t\t}\n\tcase *[]float32:\n\t\ttmp := make([]float32, len(values))\n\t\tfor i, v := range values {\n\t\t\tb.float(sourceParam, v, &tmp[i], 32)\n\t\t\tif b.failFast && b.errors != nil {\n\t\t\t\treturn b\n\t\t\t}\n\t\t}\n\t\tif b.errors == nil {\n\t\t\t*d = tmp\n\t\t}\n\t}\n\treturn b\n}\n\n// Float64s binds parameter values to slice of float64 variables\nfunc (b *ValueBinder) Float64s(sourceParam string, dest *[]float64) *ValueBinder {\n\treturn b.floatsValue(sourceParam, dest, false)\n}\n\n// MustFloat64s requires parameter values to exist to bind to slice of float64 variables. Returns error when values does not exist\nfunc (b *ValueBinder) MustFloat64s(sourceParam string, dest *[]float64) *ValueBinder {\n\treturn b.floatsValue(sourceParam, dest, true)\n}\n\n// Float32s binds parameter values to slice of float32 variables\nfunc (b *ValueBinder) Float32s(sourceParam string, dest *[]float32) *ValueBinder {\n\treturn b.floatsValue(sourceParam, dest, false)\n}\n\n// MustFloat32s requires parameter values to exist to bind to slice of float32 variables. Returns error when values does not exist\nfunc (b *ValueBinder) MustFloat32s(sourceParam string, dest *[]float32) *ValueBinder {\n\treturn b.floatsValue(sourceParam, dest, true)\n}\n\n// Time binds parameter to time.Time variable\nfunc (b *ValueBinder) Time(sourceParam string, dest *time.Time, layout string) *ValueBinder {\n\treturn b.time(sourceParam, dest, layout, false)\n}\n\n// MustTime requires parameter value to exist to bind to time.Time variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustTime(sourceParam string, dest *time.Time, layout string) *ValueBinder {\n\treturn b.time(sourceParam, dest, layout, true)\n}\n\nfunc (b *ValueBinder) time(sourceParam string, dest *time.Time, layout string, valueMustExist bool) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalue := b.ValueFunc(sourceParam)\n\tif value == \"\" {\n\t\tif valueMustExist {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{value}, \"required field value is empty\", nil))\n\t\t}\n\t\treturn b\n\t}\n\tt, err := time.Parse(layout, value)\n\tif err != nil {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{value}, \"failed to bind field value to Time\", err))\n\t\treturn b\n\t}\n\t*dest = t\n\treturn b\n}\n\n// Times binds parameter values to slice of time.Time variables\nfunc (b *ValueBinder) Times(sourceParam string, dest *[]time.Time, layout string) *ValueBinder {\n\treturn b.times(sourceParam, dest, layout, false)\n}\n\n// MustTimes requires parameter values to exist to bind to slice of time.Time variables. Returns error when values does not exist\nfunc (b *ValueBinder) MustTimes(sourceParam string, dest *[]time.Time, layout string) *ValueBinder {\n\treturn b.times(sourceParam, dest, layout, true)\n}\n\nfunc (b *ValueBinder) times(sourceParam string, dest *[]time.Time, layout string, valueMustExist bool) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalues := b.ValuesFunc(sourceParam)\n\tif len(values) == 0 {\n\t\tif valueMustExist {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{}, \"required field value is empty\", nil))\n\t\t}\n\t\treturn b\n\t}\n\n\ttmp := make([]time.Time, len(values))\n\tfor i, v := range values {\n\t\tt, err := time.Parse(layout, v)\n\t\tif err != nil {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{v}, \"failed to bind field value to Time\", err))\n\t\t\tif b.failFast {\n\t\t\t\treturn b\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\ttmp[i] = t\n\t}\n\tif b.errors == nil {\n\t\t*dest = tmp\n\t}\n\treturn b\n}\n\n// Duration binds parameter to time.Duration variable\nfunc (b *ValueBinder) Duration(sourceParam string, dest *time.Duration) *ValueBinder {\n\treturn b.duration(sourceParam, dest, false)\n}\n\n// MustDuration requires parameter value to exist to bind to time.Duration variable. Returns error when value does not exist\nfunc (b *ValueBinder) MustDuration(sourceParam string, dest *time.Duration) *ValueBinder {\n\treturn b.duration(sourceParam, dest, true)\n}\n\nfunc (b *ValueBinder) duration(sourceParam string, dest *time.Duration, valueMustExist bool) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalue := b.ValueFunc(sourceParam)\n\tif value == \"\" {\n\t\tif valueMustExist {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{value}, \"required field value is empty\", nil))\n\t\t}\n\t\treturn b\n\t}\n\tt, err := time.ParseDuration(value)\n\tif err != nil {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{value}, \"failed to bind field value to Duration\", err))\n\t\treturn b\n\t}\n\t*dest = t\n\treturn b\n}\n\n// Durations binds parameter values to slice of time.Duration variables\nfunc (b *ValueBinder) Durations(sourceParam string, dest *[]time.Duration) *ValueBinder {\n\treturn b.durationsValue(sourceParam, dest, false)\n}\n\n// MustDurations requires parameter values to exist to bind to slice of time.Duration variables. Returns error when values does not exist\nfunc (b *ValueBinder) MustDurations(sourceParam string, dest *[]time.Duration) *ValueBinder {\n\treturn b.durationsValue(sourceParam, dest, true)\n}\n\nfunc (b *ValueBinder) durationsValue(sourceParam string, dest *[]time.Duration, valueMustExist bool) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalues := b.ValuesFunc(sourceParam)\n\tif len(values) == 0 {\n\t\tif valueMustExist {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{}, \"required field value is empty\", nil))\n\t\t}\n\t\treturn b\n\t}\n\treturn b.durations(sourceParam, values, dest)\n}\n\nfunc (b *ValueBinder) durations(sourceParam string, values []string, dest *[]time.Duration) *ValueBinder {\n\ttmp := make([]time.Duration, len(values))\n\tfor i, v := range values {\n\t\tt, err := time.ParseDuration(v)\n\t\tif err != nil {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{v}, \"failed to bind field value to Duration\", err))\n\t\t\tif b.failFast {\n\t\t\t\treturn b\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\ttmp[i] = t\n\t}\n\tif b.errors == nil {\n\t\t*dest = tmp\n\t}\n\treturn b\n}\n\n// UnixTime binds parameter to time.Time variable (in local Time corresponding to the given Unix time).\n//\n// Example: 1609180603 bind to 2020-12-28T18:36:43.000000000+00:00\n//\n// Note:\n//   - time.Time{} (param is empty) and time.Unix(0,0) (param = \"0\") are not equal\nfunc (b *ValueBinder) UnixTime(sourceParam string, dest *time.Time) *ValueBinder {\n\treturn b.unixTime(sourceParam, dest, false, time.Second)\n}\n\n// MustUnixTime requires parameter value to exist to bind to time.Duration variable (in local time corresponding\n// to the given Unix time). Returns error when value does not exist.\n//\n// Example: 1609180603 bind to 2020-12-28T18:36:43.000000000+00:00\n//\n// Note:\n//   - time.Time{} (param is empty) and time.Unix(0,0) (param = \"0\") are not equal\nfunc (b *ValueBinder) MustUnixTime(sourceParam string, dest *time.Time) *ValueBinder {\n\treturn b.unixTime(sourceParam, dest, true, time.Second)\n}\n\n// UnixTimeMilli binds parameter to time.Time variable (in local time corresponding to the given Unix time in millisecond precision).\n//\n// Example: 1647184410140 bind to 2022-03-13T15:13:30.140000000+00:00\n//\n// Note:\n//   - time.Time{} (param is empty) and time.Unix(0,0) (param = \"0\") are not equal\nfunc (b *ValueBinder) UnixTimeMilli(sourceParam string, dest *time.Time) *ValueBinder {\n\treturn b.unixTime(sourceParam, dest, false, time.Millisecond)\n}\n\n// MustUnixTimeMilli requires parameter value to exist to bind to time.Duration variable  (in local time corresponding\n// to the given Unix time in millisecond precision). Returns error when value does not exist.\n//\n// Example: 1647184410140 bind to 2022-03-13T15:13:30.140000000+00:00\n//\n// Note:\n//   - time.Time{} (param is empty) and time.Unix(0,0) (param = \"0\") are not equal\nfunc (b *ValueBinder) MustUnixTimeMilli(sourceParam string, dest *time.Time) *ValueBinder {\n\treturn b.unixTime(sourceParam, dest, true, time.Millisecond)\n}\n\n// UnixTimeNano binds parameter to time.Time variable (in local time corresponding to the given Unix time in nanosecond precision).\n//\n// Example: 1609180603123456789 binds to 2020-12-28T18:36:43.123456789+00:00\n// Example:          1000000000 binds to 1970-01-01T00:00:01.000000000+00:00\n// Example:           999999999 binds to 1970-01-01T00:00:00.999999999+00:00\n//\n// Note:\n//   - time.Time{} (param is empty) and time.Unix(0,0) (param = \"0\") are not equal\n//   - Javascript's Number type only has about 53 bits of precision (Number.MAX_SAFE_INTEGER = 9007199254740991). Compare it to 1609180603123456789 in example.\nfunc (b *ValueBinder) UnixTimeNano(sourceParam string, dest *time.Time) *ValueBinder {\n\treturn b.unixTime(sourceParam, dest, false, time.Nanosecond)\n}\n\n// MustUnixTimeNano requires parameter value to exist to bind to time.Duration variable  (in local Time corresponding\n// to the given Unix time value in nano second precision). Returns error when value does not exist.\n//\n// Example: 1609180603123456789 binds to 2020-12-28T18:36:43.123456789+00:00\n// Example:          1000000000 binds to 1970-01-01T00:00:01.000000000+00:00\n// Example:           999999999 binds to 1970-01-01T00:00:00.999999999+00:00\n//\n// Note:\n//   - time.Time{} (param is empty) and time.Unix(0,0) (param = \"0\") are not equal\n//   - Javascript's Number type only has about 53 bits of precision (Number.MAX_SAFE_INTEGER = 9007199254740991). Compare it to 1609180603123456789 in example.\nfunc (b *ValueBinder) MustUnixTimeNano(sourceParam string, dest *time.Time) *ValueBinder {\n\treturn b.unixTime(sourceParam, dest, true, time.Nanosecond)\n}\n\nfunc (b *ValueBinder) unixTime(sourceParam string, dest *time.Time, valueMustExist bool, precision time.Duration) *ValueBinder {\n\tif b.failFast && b.errors != nil {\n\t\treturn b\n\t}\n\n\tvalue := b.ValueFunc(sourceParam)\n\tif value == \"\" {\n\t\tif valueMustExist {\n\t\t\tb.setError(b.ErrorFunc(sourceParam, []string{value}, \"required field value is empty\", nil))\n\t\t}\n\t\treturn b\n\t}\n\n\tn, err := strconv.ParseInt(value, 10, 64)\n\tif err != nil {\n\t\tb.setError(b.ErrorFunc(sourceParam, []string{value}, \"failed to bind field value to Time\", err))\n\t\treturn b\n\t}\n\n\tswitch precision {\n\tcase time.Second:\n\t\t*dest = time.Unix(n, 0)\n\tcase time.Millisecond:\n\t\t*dest = time.UnixMilli(n)\n\tcase time.Nanosecond:\n\t\t*dest = time.Unix(0, n)\n\t}\n\treturn b\n}\n"
        },
        {
          "name": "binder_external_test.go",
          "type": "blob",
          "size": 3.7939453125,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\n// run tests as external package to get real feel for API\npackage echo_test\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"github.com/labstack/echo/v4\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n)\n\nfunc ExampleValueBinder_BindErrors() {\n\t// example route function that binds query params to different destinations and returns all bind errors in one go\n\trouteFunc := func(c echo.Context) error {\n\t\tvar opts struct {\n\t\t\tActive bool\n\t\t\tIDs    []int64\n\t\t}\n\t\tlength := int64(50) // default length is 50\n\n\t\tb := echo.QueryParamsBinder(c)\n\n\t\terrs := b.Int64(\"length\", &length).\n\t\t\tInt64s(\"ids\", &opts.IDs).\n\t\t\tBool(\"active\", &opts.Active).\n\t\t\tBindErrors() // returns all errors\n\t\tif errs != nil {\n\t\t\tfor _, err := range errs {\n\t\t\t\tbErr := err.(*echo.BindingError)\n\t\t\t\tlog.Printf(\"in case you want to access what field: %s values: %v failed\", bErr.Field, bErr.Values)\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"%v fields failed to bind\", len(errs))\n\t\t}\n\t\tfmt.Printf(\"active = %v, length = %v, ids = %v\", opts.Active, length, opts.IDs)\n\n\t\treturn c.JSON(http.StatusOK, opts)\n\t}\n\n\te := echo.New()\n\tc := e.NewContext(\n\t\thttptest.NewRequest(http.MethodGet, \"/api/endpoint?active=true&length=25&ids=1&ids=2&ids=3\", nil),\n\t\thttptest.NewRecorder(),\n\t)\n\n\t_ = routeFunc(c)\n\n\t// Output: active = true, length = 25, ids = [1 2 3]\n}\n\nfunc ExampleValueBinder_BindError() {\n\t// example route function that binds query params to different destinations and stops binding on first bind error\n\tfailFastRouteFunc := func(c echo.Context) error {\n\t\tvar opts struct {\n\t\t\tActive bool\n\t\t\tIDs    []int64\n\t\t}\n\t\tlength := int64(50) // default length is 50\n\n\t\t// create binder that stops binding at first error\n\t\tb := echo.QueryParamsBinder(c)\n\n\t\terr := b.Int64(\"length\", &length).\n\t\t\tInt64s(\"ids\", &opts.IDs).\n\t\t\tBool(\"active\", &opts.Active).\n\t\t\tBindError() // returns first binding error\n\t\tif err != nil {\n\t\t\tbErr := err.(*echo.BindingError)\n\t\t\treturn fmt.Errorf(\"my own custom error for field: %s values: %v\", bErr.Field, bErr.Values)\n\t\t}\n\t\tfmt.Printf(\"active = %v, length = %v, ids = %v\\n\", opts.Active, length, opts.IDs)\n\n\t\treturn c.JSON(http.StatusOK, opts)\n\t}\n\n\te := echo.New()\n\tc := e.NewContext(\n\t\thttptest.NewRequest(http.MethodGet, \"/api/endpoint?active=true&length=25&ids=1&ids=2&ids=3\", nil),\n\t\thttptest.NewRecorder(),\n\t)\n\n\t_ = failFastRouteFunc(c)\n\n\t// Output: active = true, length = 25, ids = [1 2 3]\n}\n\nfunc ExampleValueBinder_CustomFunc() {\n\t// example route function that binds query params using custom function closure\n\trouteFunc := func(c echo.Context) error {\n\t\tlength := int64(50) // default length is 50\n\t\tvar binary []byte\n\n\t\tb := echo.QueryParamsBinder(c)\n\t\terrs := b.Int64(\"length\", &length).\n\t\t\tCustomFunc(\"base64\", func(values []string) []error {\n\t\t\t\tif len(values) == 0 {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\tdecoded, err := base64.URLEncoding.DecodeString(values[0])\n\t\t\t\tif err != nil {\n\t\t\t\t\t// in this example we use only first param value but url could contain multiple params in reality and\n\t\t\t\t\t// therefore in theory produce multiple binding errors\n\t\t\t\t\treturn []error{echo.NewBindingError(\"base64\", values[0:1], \"failed to decode base64\", err)}\n\t\t\t\t}\n\t\t\t\tbinary = decoded\n\t\t\t\treturn nil\n\t\t\t}).\n\t\t\tBindErrors() // returns all errors\n\n\t\tif errs != nil {\n\t\t\tfor _, err := range errs {\n\t\t\t\tbErr := err.(*echo.BindingError)\n\t\t\t\tlog.Printf(\"in case you want to access what field: %s values: %v failed\", bErr.Field, bErr.Values)\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"%v fields failed to bind\", len(errs))\n\t\t}\n\t\tfmt.Printf(\"length = %v, base64 = %s\", length, binary)\n\n\t\treturn c.JSON(http.StatusOK, \"ok\")\n\t}\n\n\te := echo.New()\n\tc := e.NewContext(\n\t\thttptest.NewRequest(http.MethodGet, \"/api/endpoint?length=25&base64=SGVsbG8gV29ybGQ%3D\", nil),\n\t\thttptest.NewRecorder(),\n\t)\n\t_ = routeFunc(c)\n\n\t// Output: length = 25, base64 = Hello World\n}\n"
        },
        {
          "name": "binder_test.go",
          "type": "blob",
          "size": 93.2578125,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"io\"\n\t\"math/big\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc createTestContext(URL string, body io.Reader, pathParams map[string]string) Context {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, URL, body)\n\tif body != nil {\n\t\treq.Header.Set(HeaderContentType, MIMEApplicationJSON)\n\t}\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\n\tif len(pathParams) > 0 {\n\t\tnames := make([]string, 0)\n\t\tvalues := make([]string, 0)\n\t\tfor name, value := range pathParams {\n\t\t\tnames = append(names, name)\n\t\t\tvalues = append(values, value)\n\t\t}\n\t\tc.SetParamNames(names...)\n\t\tc.SetParamValues(values...)\n\t}\n\n\treturn c\n}\n\nfunc TestBindingError_Error(t *testing.T) {\n\terr := NewBindingError(\"id\", []string{\"1\", \"nope\"}, \"bind failed\", errors.New(\"internal error\"))\n\tassert.EqualError(t, err, `code=400, message=bind failed, internal=internal error, field=id`)\n\n\tbErr := err.(*BindingError)\n\tassert.Equal(t, 400, bErr.Code)\n\tassert.Equal(t, \"bind failed\", bErr.Message)\n\tassert.Equal(t, errors.New(\"internal error\"), bErr.Internal)\n\n\tassert.Equal(t, \"id\", bErr.Field)\n\tassert.Equal(t, []string{\"1\", \"nope\"}, bErr.Values)\n}\n\nfunc TestBindingError_ErrorJSON(t *testing.T) {\n\terr := NewBindingError(\"id\", []string{\"1\", \"nope\"}, \"bind failed\", errors.New(\"internal error\"))\n\n\tresp, _ := json.Marshal(err)\n\n\tassert.Equal(t, `{\"field\":\"id\",\"message\":\"bind failed\"}`, string(resp))\n}\n\nfunc TestPathParamsBinder(t *testing.T) {\n\tc := createTestContext(\"/api/user/999\", nil, map[string]string{\n\t\t\"id\":    \"1\",\n\t\t\"nr\":    \"2\",\n\t\t\"slice\": \"3\",\n\t})\n\tb := PathParamsBinder(c)\n\n\tid := int64(99)\n\tnr := int64(88)\n\tvar slice = make([]int64, 0)\n\tvar notExisting = make([]int64, 0)\n\terr := b.Int64(\"id\", &id).\n\t\tInt64(\"nr\", &nr).\n\t\tInt64s(\"slice\", &slice).\n\t\tInt64s(\"not_existing\", &notExisting).\n\t\tBindError()\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, int64(1), id)\n\tassert.Equal(t, int64(2), nr)\n\tassert.Equal(t, []int64{3}, slice)      // binding params to slice does not make sense but it should not panic either\n\tassert.Equal(t, []int64{}, notExisting) // binding params to slice does not make sense but it should not panic either\n}\n\nfunc TestQueryParamsBinder_FailFast(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname          string\n\t\twhenURL       string\n\t\tgivenFailFast bool\n\t\texpectError   []string\n\t}{\n\t\t{\n\t\t\tname:          \"ok, FailFast=true stops at first error\",\n\t\t\twhenURL:       \"/api/user/999?nr=en&id=nope\",\n\t\t\tgivenFailFast: true,\n\t\t\texpectError: []string{\n\t\t\t\t`code=400, message=failed to bind field value to int64, internal=strconv.ParseInt: parsing \"nope\": invalid syntax, field=id`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:          \"ok, FailFast=false encounters all errors\",\n\t\t\twhenURL:       \"/api/user/999?nr=en&id=nope\",\n\t\t\tgivenFailFast: false,\n\t\t\texpectError: []string{\n\t\t\t\t`code=400, message=failed to bind field value to int64, internal=strconv.ParseInt: parsing \"nope\": invalid syntax, field=id`,\n\t\t\t\t`code=400, message=failed to bind field value to int64, internal=strconv.ParseInt: parsing \"en\": invalid syntax, field=nr`,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, map[string]string{\"id\": \"999\"})\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tid := int64(99)\n\t\t\tnr := int64(88)\n\t\t\terrs := b.Int64(\"id\", &id).\n\t\t\t\tInt64(\"nr\", &nr).\n\t\t\t\tBindErrors()\n\n\t\t\tassert.Len(t, errs, len(tc.expectError))\n\t\t\tfor _, err := range errs {\n\t\t\t\tassert.Contains(t, tc.expectError, err.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestFormFieldBinder(t *testing.T) {\n\te := New()\n\tbody := `texta=foo&slice=5`\n\treq := httptest.NewRequest(http.MethodPost, \"/api/search?id=1&nr=2&slice=3&slice=4\", strings.NewReader(body))\n\treq.Header.Set(HeaderContentLength, strconv.Itoa(len(body)))\n\treq.Header.Set(HeaderContentType, MIMEApplicationForm)\n\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\n\tb := FormFieldBinder(c)\n\n\tvar texta string\n\tid := int64(99)\n\tnr := int64(88)\n\tvar slice = make([]int64, 0)\n\tvar notExisting = make([]int64, 0)\n\terr := b.\n\t\tInt64s(\"slice\", &slice).\n\t\tInt64(\"id\", &id).\n\t\tInt64(\"nr\", &nr).\n\t\tString(\"texta\", &texta).\n\t\tInt64s(\"notExisting\", &notExisting).\n\t\tBindError()\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"foo\", texta)\n\tassert.Equal(t, int64(1), id)\n\tassert.Equal(t, int64(2), nr)\n\tassert.Equal(t, []int64{5, 3, 4}, slice)\n\tassert.Equal(t, []int64{}, notExisting)\n}\n\nfunc TestValueBinder_errorStopsBinding(t *testing.T) {\n\t// this test documents \"feature\" that binding multiple params can change destination if it was binded before\n\t// failing parameter binding\n\n\tc := createTestContext(\"/api/user/999?id=1&nr=nope\", nil, nil)\n\tb := QueryParamsBinder(c)\n\n\tid := int64(99) // will be changed before nr binding fails\n\tnr := int64(88) // will not be changed\n\terr := b.Int64(\"id\", &id).\n\t\tInt64(\"nr\", &nr).\n\t\tBindError()\n\n\tassert.EqualError(t, err, \"code=400, message=failed to bind field value to int64, internal=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax, field=nr\")\n\tassert.Equal(t, int64(1), id)\n\tassert.Equal(t, int64(88), nr)\n}\n\nfunc TestValueBinder_BindError(t *testing.T) {\n\tc := createTestContext(\"/api/user/999?nr=en&id=nope\", nil, nil)\n\tb := QueryParamsBinder(c)\n\n\tid := int64(99)\n\tnr := int64(88)\n\terr := b.Int64(\"id\", &id).\n\t\tInt64(\"nr\", &nr).\n\t\tBindError()\n\n\tassert.EqualError(t, err, \"code=400, message=failed to bind field value to int64, internal=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax, field=id\")\n\tassert.Nil(t, b.errors)\n\tassert.Nil(t, b.BindError())\n}\n\nfunc TestValueBinder_GetValues(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname           string\n\t\twhenValuesFunc func(sourceParam string) []string\n\t\texpect         []int64\n\t\texpectError    string\n\t}{\n\t\t{\n\t\t\tname:   \"ok, default implementation\",\n\t\t\texpect: []int64{1, 101},\n\t\t},\n\t\t{\n\t\t\tname: \"ok, values returns nil\",\n\t\t\twhenValuesFunc: func(sourceParam string) []string {\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\texpect: []int64(nil),\n\t\t},\n\t\t{\n\t\t\tname: \"ok, values returns empty slice\",\n\t\t\twhenValuesFunc: func(sourceParam string) []string {\n\t\t\t\treturn []string{}\n\t\t\t},\n\t\t\texpect: []int64(nil),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(\"/search?nr=en&id=1&id=101\", nil, nil)\n\t\t\tb := QueryParamsBinder(c)\n\t\t\tif tc.whenValuesFunc != nil {\n\t\t\t\tb.ValuesFunc = tc.whenValuesFunc\n\t\t\t}\n\n\t\t\tvar IDs []int64\n\t\t\terr := b.Int64s(\"id\", &IDs).BindError()\n\n\t\t\tassert.Equal(t, tc.expect, IDs)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_CustomFuncWithError(t *testing.T) {\n\tc := createTestContext(\"/search?nr=en&id=1&id=101\", nil, nil)\n\tb := QueryParamsBinder(c)\n\n\tid := int64(99)\n\tgivenCustomFunc := func(values []string) []error {\n\t\tassert.Equal(t, []string{\"1\", \"101\"}, values)\n\n\t\treturn []error{\n\t\t\terrors.New(\"first error\"),\n\t\t\terrors.New(\"second error\"),\n\t\t}\n\t}\n\terr := b.CustomFunc(\"id\", givenCustomFunc).BindError()\n\n\tassert.Equal(t, int64(99), id)\n\tassert.EqualError(t, err, \"first error\")\n}\n\nfunc TestValueBinder_CustomFunc(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname              string\n\t\tgivenFailFast     bool\n\t\tgivenFuncErrors   []error\n\t\twhenURL           string\n\t\texpectParamValues []string\n\t\texpectValue       interface{}\n\t\texpectErrors      []string\n\t}{\n\t\t{\n\t\t\tname:              \"ok, binds value\",\n\t\t\twhenURL:           \"/search?nr=en&id=1&id=100\",\n\t\t\texpectParamValues: []string{\"1\", \"100\"},\n\t\t\texpectValue:       int64(1000),\n\t\t},\n\t\t{\n\t\t\tname:              \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:           \"/search?nr=en\",\n\t\t\texpectParamValues: []string{},\n\t\t\texpectValue:       int64(99),\n\t\t},\n\t\t{\n\t\t\tname:              \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast:     true,\n\t\t\twhenURL:           \"/search?nr=en&id=1&id=100\",\n\t\t\texpectParamValues: []string{\"1\", \"100\"},\n\t\t\texpectValue:       int64(99),\n\t\t\texpectErrors:      []string{\"previous error\"},\n\t\t},\n\t\t{\n\t\t\tname: \"nok, func returns errors\",\n\t\t\tgivenFuncErrors: []error{\n\t\t\t\terrors.New(\"first error\"),\n\t\t\t\terrors.New(\"second error\"),\n\t\t\t},\n\t\t\twhenURL:           \"/search?nr=en&id=1&id=100\",\n\t\t\texpectParamValues: []string{\"1\", \"100\"},\n\t\t\texpectValue:       int64(99),\n\t\t\texpectErrors:      []string{\"first error\", \"second error\"},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tid := int64(99)\n\t\t\tgivenCustomFunc := func(values []string) []error {\n\t\t\t\tassert.Equal(t, tc.expectParamValues, values)\n\t\t\t\tif tc.givenFuncErrors == nil {\n\t\t\t\t\tid = 1000 // emulated conversion and setting value\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn tc.givenFuncErrors\n\t\t\t}\n\t\t\terrs := b.CustomFunc(\"id\", givenCustomFunc).BindErrors()\n\n\t\t\tassert.Equal(t, tc.expectValue, id)\n\t\t\tif tc.expectErrors != nil {\n\t\t\t\tassert.Len(t, errs, len(tc.expectErrors))\n\t\t\t\tfor _, err := range errs {\n\t\t\t\t\tassert.Contains(t, tc.expectErrors, err.Error())\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, errs)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_MustCustomFunc(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname              string\n\t\tgivenFailFast     bool\n\t\tgivenFuncErrors   []error\n\t\twhenURL           string\n\t\texpectParamValues []string\n\t\texpectValue       interface{}\n\t\texpectErrors      []string\n\t}{\n\t\t{\n\t\t\tname:              \"ok, binds value\",\n\t\t\twhenURL:           \"/search?nr=en&id=1&id=100\",\n\t\t\texpectParamValues: []string{\"1\", \"100\"},\n\t\t\texpectValue:       int64(1000),\n\t\t},\n\t\t{\n\t\t\tname:              \"nok, params values empty, returns error, value is not changed\",\n\t\t\twhenURL:           \"/search?nr=en\",\n\t\t\texpectParamValues: []string{},\n\t\t\texpectValue:       int64(99),\n\t\t\texpectErrors:      []string{\"code=400, message=required field value is empty, field=id\"},\n\t\t},\n\t\t{\n\t\t\tname:              \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast:     true,\n\t\t\twhenURL:           \"/search?nr=en&id=1&id=100\",\n\t\t\texpectParamValues: []string{\"1\", \"100\"},\n\t\t\texpectValue:       int64(99),\n\t\t\texpectErrors:      []string{\"previous error\"},\n\t\t},\n\t\t{\n\t\t\tname: \"nok, func returns errors\",\n\t\t\tgivenFuncErrors: []error{\n\t\t\t\terrors.New(\"first error\"),\n\t\t\t\terrors.New(\"second error\"),\n\t\t\t},\n\t\t\twhenURL:           \"/search?nr=en&id=1&id=100\",\n\t\t\texpectParamValues: []string{\"1\", \"100\"},\n\t\t\texpectValue:       int64(99),\n\t\t\texpectErrors:      []string{\"first error\", \"second error\"},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tid := int64(99)\n\t\t\tgivenCustomFunc := func(values []string) []error {\n\t\t\t\tassert.Equal(t, tc.expectParamValues, values)\n\t\t\t\tif tc.givenFuncErrors == nil {\n\t\t\t\t\tid = 1000 // emulated conversion and setting value\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn tc.givenFuncErrors\n\t\t\t}\n\t\t\terrs := b.MustCustomFunc(\"id\", givenCustomFunc).BindErrors()\n\n\t\t\tassert.Equal(t, tc.expectValue, id)\n\t\t\tif tc.expectErrors != nil {\n\t\t\t\tassert.Len(t, errs, len(tc.expectErrors))\n\t\t\t\tfor _, err := range errs {\n\t\t\t\t\tassert.Contains(t, tc.expectErrors, err.Error())\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, errs)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_String(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     string\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=en&param=de\",\n\t\t\texpectValue: \"en\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nr=en\",\n\t\t\texpectValue: \"default\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?nr=en&id=1&id=100\",\n\t\t\texpectValue:   \"default\",\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=en&param=de\",\n\t\t\texpectValue: \"en\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nr=en\",\n\t\t\texpectValue: \"default\",\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?nr=en&id=1&id=100\",\n\t\t\texpectValue:   \"default\",\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tdest := \"default\"\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustString(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.String(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_Strings(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     []string\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=en&param=de\",\n\t\t\texpectValue: []string{\"en\", \"de\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nr=en\",\n\t\t\texpectValue: []string{\"default\"},\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?nr=en&id=1&id=100\",\n\t\t\texpectValue:   []string{\"default\"},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=en&param=de\",\n\t\t\texpectValue: []string{\"en\", \"de\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nr=en\",\n\t\t\texpectValue: []string{\"default\"},\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?nr=en&id=1&id=100\",\n\t\t\texpectValue:   []string{\"default\"},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tdest := []string{\"default\"}\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustStrings(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Strings(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_Int64_intValue(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     int64\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=1&param=100\",\n\t\t\texpectValue: 1,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: 99,\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   99,\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: 99,\n\t\t\texpectError: \"code=400, message=failed to bind field value to int64, internal=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=1&param=100\",\n\t\t\texpectValue: 1,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: 99,\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   99,\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: 99,\n\t\t\texpectError: \"code=400, message=failed to bind field value to int64, internal=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tdest := int64(99)\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustInt64(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Int64(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_Int_errorMessage(t *testing.T) {\n\t// int/uint (without byte size) has a little bit different error message so test these separately\n\tc := createTestContext(\"/search?param=nope\", nil, nil)\n\tb := QueryParamsBinder(c).FailFast(false)\n\n\tdestInt := 99\n\tdestUint := uint(98)\n\terrs := b.Int(\"param\", &destInt).Uint(\"param\", &destUint).BindErrors()\n\n\tassert.Equal(t, 99, destInt)\n\tassert.Equal(t, uint(98), destUint)\n\tassert.EqualError(t, errs[0], `code=400, message=failed to bind field value to int, internal=strconv.ParseInt: parsing \"nope\": invalid syntax, field=param`)\n\tassert.EqualError(t, errs[1], `code=400, message=failed to bind field value to uint, internal=strconv.ParseUint: parsing \"nope\": invalid syntax, field=param`)\n}\n\nfunc TestValueBinder_Uint64_uintValue(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     uint64\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=1&param=100\",\n\t\t\texpectValue: 1,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: 99,\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   99,\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: 99,\n\t\t\texpectError: \"code=400, message=failed to bind field value to uint64, internal=strconv.ParseUint: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=1&param=100\",\n\t\t\texpectValue: 1,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: 99,\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   99,\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: 99,\n\t\t\texpectError: \"code=400, message=failed to bind field value to uint64, internal=strconv.ParseUint: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tdest := uint64(99)\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustUint64(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Uint64(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_Int_Types(t *testing.T) {\n\ttype target struct {\n\t\tint64      int64\n\t\tmustInt64  int64\n\t\tuint64     uint64\n\t\tmustUint64 uint64\n\n\t\tint32      int32\n\t\tmustInt32  int32\n\t\tuint32     uint32\n\t\tmustUint32 uint32\n\n\t\tint16      int16\n\t\tmustInt16  int16\n\t\tuint16     uint16\n\t\tmustUint16 uint16\n\n\t\tint8      int8\n\t\tmustInt8  int8\n\t\tuint8     uint8\n\t\tmustUint8 uint8\n\n\t\tbyte     byte\n\t\tmustByte byte\n\n\t\tint      int\n\t\tmustInt  int\n\t\tuint     uint\n\t\tmustUint uint\n\t}\n\ttypes := []string{\n\t\t\"int64=1\",\n\t\t\"mustInt64=2\",\n\t\t\"uint64=3\",\n\t\t\"mustUint64=4\",\n\n\t\t\"int32=5\",\n\t\t\"mustInt32=6\",\n\t\t\"uint32=7\",\n\t\t\"mustUint32=8\",\n\n\t\t\"int16=9\",\n\t\t\"mustInt16=10\",\n\t\t\"uint16=11\",\n\t\t\"mustUint16=12\",\n\n\t\t\"int8=13\",\n\t\t\"mustInt8=14\",\n\t\t\"uint8=15\",\n\t\t\"mustUint8=16\",\n\n\t\t\"byte=17\",\n\t\t\"mustByte=18\",\n\n\t\t\"int=19\",\n\t\t\"mustInt=20\",\n\t\t\"uint=21\",\n\t\t\"mustUint=22\",\n\t}\n\tc := createTestContext(\"/search?\"+strings.Join(types, \"&\"), nil, nil)\n\tb := QueryParamsBinder(c)\n\n\tdest := target{}\n\terr := b.\n\t\tInt64(\"int64\", &dest.int64).\n\t\tMustInt64(\"mustInt64\", &dest.mustInt64).\n\t\tUint64(\"uint64\", &dest.uint64).\n\t\tMustUint64(\"mustUint64\", &dest.mustUint64).\n\t\tInt32(\"int32\", &dest.int32).\n\t\tMustInt32(\"mustInt32\", &dest.mustInt32).\n\t\tUint32(\"uint32\", &dest.uint32).\n\t\tMustUint32(\"mustUint32\", &dest.mustUint32).\n\t\tInt16(\"int16\", &dest.int16).\n\t\tMustInt16(\"mustInt16\", &dest.mustInt16).\n\t\tUint16(\"uint16\", &dest.uint16).\n\t\tMustUint16(\"mustUint16\", &dest.mustUint16).\n\t\tInt8(\"int8\", &dest.int8).\n\t\tMustInt8(\"mustInt8\", &dest.mustInt8).\n\t\tUint8(\"uint8\", &dest.uint8).\n\t\tMustUint8(\"mustUint8\", &dest.mustUint8).\n\t\tByte(\"byte\", &dest.byte).\n\t\tMustByte(\"mustByte\", &dest.mustByte).\n\t\tInt(\"int\", &dest.int).\n\t\tMustInt(\"mustInt\", &dest.mustInt).\n\t\tUint(\"uint\", &dest.uint).\n\t\tMustUint(\"mustUint\", &dest.mustUint).\n\t\tBindError()\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, int64(1), dest.int64)\n\tassert.Equal(t, int64(2), dest.mustInt64)\n\tassert.Equal(t, uint64(3), dest.uint64)\n\tassert.Equal(t, uint64(4), dest.mustUint64)\n\n\tassert.Equal(t, int32(5), dest.int32)\n\tassert.Equal(t, int32(6), dest.mustInt32)\n\tassert.Equal(t, uint32(7), dest.uint32)\n\tassert.Equal(t, uint32(8), dest.mustUint32)\n\n\tassert.Equal(t, int16(9), dest.int16)\n\tassert.Equal(t, int16(10), dest.mustInt16)\n\tassert.Equal(t, uint16(11), dest.uint16)\n\tassert.Equal(t, uint16(12), dest.mustUint16)\n\n\tassert.Equal(t, int8(13), dest.int8)\n\tassert.Equal(t, int8(14), dest.mustInt8)\n\tassert.Equal(t, uint8(15), dest.uint8)\n\tassert.Equal(t, uint8(16), dest.mustUint8)\n\n\tassert.Equal(t, uint8(17), dest.byte)\n\tassert.Equal(t, uint8(18), dest.mustByte)\n\n\tassert.Equal(t, 19, dest.int)\n\tassert.Equal(t, 20, dest.mustInt)\n\tassert.Equal(t, uint(21), dest.uint)\n\tassert.Equal(t, uint(22), dest.mustUint)\n}\n\nfunc TestValueBinder_Int64s_intsValue(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     []int64\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=1&param=2&param=1\",\n\t\t\texpectValue: []int64{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []int64{99},\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   []int64{99},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: []int64{99},\n\t\t\texpectError: \"code=400, message=failed to bind field value to int64, internal=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=1&param=2&param=1\",\n\t\t\texpectValue: []int64{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []int64{99},\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   []int64{99},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: []int64{99},\n\t\t\texpectError: \"code=400, message=failed to bind field value to int64, internal=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tdest := []int64{99} // when values are set with bind - contents before bind is gone\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustInt64s(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Int64s(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_Uint64s_uintsValue(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     []uint64\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=1&param=2&param=1\",\n\t\t\texpectValue: []uint64{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []uint64{99},\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   []uint64{99},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: []uint64{99},\n\t\t\texpectError: \"code=400, message=failed to bind field value to uint64, internal=strconv.ParseUint: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=1&param=2&param=1\",\n\t\t\texpectValue: []uint64{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []uint64{99},\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   []uint64{99},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: []uint64{99},\n\t\t\texpectError: \"code=400, message=failed to bind field value to uint64, internal=strconv.ParseUint: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tdest := []uint64{99} // when values are set with bind - contents before bind is gone\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustUint64s(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Uint64s(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_Ints_Types(t *testing.T) {\n\ttype target struct {\n\t\tint64      []int64\n\t\tmustInt64  []int64\n\t\tuint64     []uint64\n\t\tmustUint64 []uint64\n\n\t\tint32      []int32\n\t\tmustInt32  []int32\n\t\tuint32     []uint32\n\t\tmustUint32 []uint32\n\n\t\tint16      []int16\n\t\tmustInt16  []int16\n\t\tuint16     []uint16\n\t\tmustUint16 []uint16\n\n\t\tint8      []int8\n\t\tmustInt8  []int8\n\t\tuint8     []uint8\n\t\tmustUint8 []uint8\n\n\t\tint      []int\n\t\tmustInt  []int\n\t\tuint     []uint\n\t\tmustUint []uint\n\t}\n\ttypes := []string{\n\t\t\"int64=1\",\n\t\t\"mustInt64=2\",\n\t\t\"uint64=3\",\n\t\t\"mustUint64=4\",\n\n\t\t\"int32=5\",\n\t\t\"mustInt32=6\",\n\t\t\"uint32=7\",\n\t\t\"mustUint32=8\",\n\n\t\t\"int16=9\",\n\t\t\"mustInt16=10\",\n\t\t\"uint16=11\",\n\t\t\"mustUint16=12\",\n\n\t\t\"int8=13\",\n\t\t\"mustInt8=14\",\n\t\t\"uint8=15\",\n\t\t\"mustUint8=16\",\n\n\t\t\"int=19\",\n\t\t\"mustInt=20\",\n\t\t\"uint=21\",\n\t\t\"mustUint=22\",\n\t}\n\turl := \"/search?\"\n\tfor _, v := range types {\n\t\turl = url + \"&\" + v + \"&\" + v\n\t}\n\tc := createTestContext(url, nil, nil)\n\tb := QueryParamsBinder(c)\n\n\tdest := target{}\n\terr := b.\n\t\tInt64s(\"int64\", &dest.int64).\n\t\tMustInt64s(\"mustInt64\", &dest.mustInt64).\n\t\tUint64s(\"uint64\", &dest.uint64).\n\t\tMustUint64s(\"mustUint64\", &dest.mustUint64).\n\t\tInt32s(\"int32\", &dest.int32).\n\t\tMustInt32s(\"mustInt32\", &dest.mustInt32).\n\t\tUint32s(\"uint32\", &dest.uint32).\n\t\tMustUint32s(\"mustUint32\", &dest.mustUint32).\n\t\tInt16s(\"int16\", &dest.int16).\n\t\tMustInt16s(\"mustInt16\", &dest.mustInt16).\n\t\tUint16s(\"uint16\", &dest.uint16).\n\t\tMustUint16s(\"mustUint16\", &dest.mustUint16).\n\t\tInt8s(\"int8\", &dest.int8).\n\t\tMustInt8s(\"mustInt8\", &dest.mustInt8).\n\t\tUint8s(\"uint8\", &dest.uint8).\n\t\tMustUint8s(\"mustUint8\", &dest.mustUint8).\n\t\tInts(\"int\", &dest.int).\n\t\tMustInts(\"mustInt\", &dest.mustInt).\n\t\tUints(\"uint\", &dest.uint).\n\t\tMustUints(\"mustUint\", &dest.mustUint).\n\t\tBindError()\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, []int64{1, 1}, dest.int64)\n\tassert.Equal(t, []int64{2, 2}, dest.mustInt64)\n\tassert.Equal(t, []uint64{3, 3}, dest.uint64)\n\tassert.Equal(t, []uint64{4, 4}, dest.mustUint64)\n\n\tassert.Equal(t, []int32{5, 5}, dest.int32)\n\tassert.Equal(t, []int32{6, 6}, dest.mustInt32)\n\tassert.Equal(t, []uint32{7, 7}, dest.uint32)\n\tassert.Equal(t, []uint32{8, 8}, dest.mustUint32)\n\n\tassert.Equal(t, []int16{9, 9}, dest.int16)\n\tassert.Equal(t, []int16{10, 10}, dest.mustInt16)\n\tassert.Equal(t, []uint16{11, 11}, dest.uint16)\n\tassert.Equal(t, []uint16{12, 12}, dest.mustUint16)\n\n\tassert.Equal(t, []int8{13, 13}, dest.int8)\n\tassert.Equal(t, []int8{14, 14}, dest.mustInt8)\n\tassert.Equal(t, []uint8{15, 15}, dest.uint8)\n\tassert.Equal(t, []uint8{16, 16}, dest.mustUint8)\n\n\tassert.Equal(t, []int{19, 19}, dest.int)\n\tassert.Equal(t, []int{20, 20}, dest.mustInt)\n\tassert.Equal(t, []uint{21, 21}, dest.uint)\n\tassert.Equal(t, []uint{22, 22}, dest.mustUint)\n}\n\nfunc TestValueBinder_Ints_Types_FailFast(t *testing.T) {\n\t// FailFast() should stop parsing and return early\n\terrTmpl := \"code=400, message=failed to bind field value to %v, internal=strconv.Parse%v: parsing \\\"nope\\\": invalid syntax, field=param\"\n\tc := createTestContext(\"/search?param=1&param=nope&param=2\", nil, nil)\n\n\tvar dest64 []int64\n\terr := QueryParamsBinder(c).FailFast(true).Int64s(\"param\", &dest64).BindError()\n\tassert.Equal(t, []int64(nil), dest64)\n\tassert.EqualError(t, err, fmt.Sprintf(errTmpl, \"int64\", \"Int\"))\n\n\tvar dest32 []int32\n\terr = QueryParamsBinder(c).FailFast(true).Int32s(\"param\", &dest32).BindError()\n\tassert.Equal(t, []int32(nil), dest32)\n\tassert.EqualError(t, err, fmt.Sprintf(errTmpl, \"int32\", \"Int\"))\n\n\tvar dest16 []int16\n\terr = QueryParamsBinder(c).FailFast(true).Int16s(\"param\", &dest16).BindError()\n\tassert.Equal(t, []int16(nil), dest16)\n\tassert.EqualError(t, err, fmt.Sprintf(errTmpl, \"int16\", \"Int\"))\n\n\tvar dest8 []int8\n\terr = QueryParamsBinder(c).FailFast(true).Int8s(\"param\", &dest8).BindError()\n\tassert.Equal(t, []int8(nil), dest8)\n\tassert.EqualError(t, err, fmt.Sprintf(errTmpl, \"int8\", \"Int\"))\n\n\tvar dest []int\n\terr = QueryParamsBinder(c).FailFast(true).Ints(\"param\", &dest).BindError()\n\tassert.Equal(t, []int(nil), dest)\n\tassert.EqualError(t, err, fmt.Sprintf(errTmpl, \"int\", \"Int\"))\n\n\tvar destu64 []uint64\n\terr = QueryParamsBinder(c).FailFast(true).Uint64s(\"param\", &destu64).BindError()\n\tassert.Equal(t, []uint64(nil), destu64)\n\tassert.EqualError(t, err, fmt.Sprintf(errTmpl, \"uint64\", \"Uint\"))\n\n\tvar destu32 []uint32\n\terr = QueryParamsBinder(c).FailFast(true).Uint32s(\"param\", &destu32).BindError()\n\tassert.Equal(t, []uint32(nil), destu32)\n\tassert.EqualError(t, err, fmt.Sprintf(errTmpl, \"uint32\", \"Uint\"))\n\n\tvar destu16 []uint16\n\terr = QueryParamsBinder(c).FailFast(true).Uint16s(\"param\", &destu16).BindError()\n\tassert.Equal(t, []uint16(nil), destu16)\n\tassert.EqualError(t, err, fmt.Sprintf(errTmpl, \"uint16\", \"Uint\"))\n\n\tvar destu8 []uint8\n\terr = QueryParamsBinder(c).FailFast(true).Uint8s(\"param\", &destu8).BindError()\n\tassert.Equal(t, []uint8(nil), destu8)\n\tassert.EqualError(t, err, fmt.Sprintf(errTmpl, \"uint8\", \"Uint\"))\n\n\tvar destu []uint\n\terr = QueryParamsBinder(c).FailFast(true).Uints(\"param\", &destu).BindError()\n\tassert.Equal(t, []uint(nil), destu)\n\tassert.EqualError(t, err, fmt.Sprintf(errTmpl, \"uint\", \"Uint\"))\n}\n\nfunc TestValueBinder_Bool(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     bool\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=true&param=1\",\n\t\t\texpectValue: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: false,\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   false,\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: false,\n\t\t\texpectError: \"code=400, message=failed to bind field value to bool, internal=strconv.ParseBool: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=1&param=100\",\n\t\t\texpectValue: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: false,\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   false,\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: false,\n\t\t\texpectError: \"code=400, message=failed to bind field value to bool, internal=strconv.ParseBool: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tdest := false\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustBool(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Bool(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_Bools(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     []bool\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=true&param=false&param=1&param=0\",\n\t\t\texpectValue: []bool{true, false, true, false},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []bool(nil),\n\t\t},\n\t\t{\n\t\t\tname:            \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast:   true,\n\t\t\tgivenBindErrors: []error{errors.New(\"previous error\")},\n\t\t\twhenURL:         \"/search?param=1&param=100\",\n\t\t\texpectValue:     []bool(nil),\n\t\t\texpectError:     \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=true&param=nope&param=100\",\n\t\t\texpectValue: []bool(nil),\n\t\t\texpectError: \"code=400, message=failed to bind field value to bool, internal=strconv.ParseBool: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, conversion fails fast, value is not changed\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=true&param=nope&param=100\",\n\t\t\texpectValue:   []bool(nil),\n\t\t\texpectError:   \"code=400, message=failed to bind field value to bool, internal=strconv.ParseBool: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=true&param=false&param=1&param=0\",\n\t\t\texpectValue: []bool{true, false, true, false},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []bool(nil),\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:            \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast:   true,\n\t\t\tgivenBindErrors: []error{errors.New(\"previous error\")},\n\t\t\twhenMust:        true,\n\t\t\twhenURL:         \"/search?param=1&param=100\",\n\t\t\texpectValue:     []bool(nil),\n\t\t\texpectError:     \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: []bool(nil),\n\t\t\texpectError: \"code=400, message=failed to bind field value to bool, internal=strconv.ParseBool: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tb.errors = tc.givenBindErrors\n\n\t\t\tvar dest []bool\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustBools(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Bools(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_Float64(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     float64\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=4.3&param=1\",\n\t\t\texpectValue: 4.3,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: 1.123,\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   1.123,\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: 1.123,\n\t\t\texpectError: \"code=400, message=failed to bind field value to float64, internal=strconv.ParseFloat: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=4.3&param=100\",\n\t\t\texpectValue: 4.3,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: 1.123,\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   1.123,\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: 1.123,\n\t\t\texpectError: \"code=400, message=failed to bind field value to float64, internal=strconv.ParseFloat: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tdest := 1.123\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustFloat64(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Float64(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_Float64s(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     []float64\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=4.3&param=0\",\n\t\t\texpectValue: []float64{4.3, 0},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []float64(nil),\n\t\t},\n\t\t{\n\t\t\tname:            \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast:   true,\n\t\t\tgivenBindErrors: []error{errors.New(\"previous error\")},\n\t\t\twhenURL:         \"/search?param=1&param=100\",\n\t\t\texpectValue:     []float64(nil),\n\t\t\texpectError:     \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: []float64(nil),\n\t\t\texpectError: \"code=400, message=failed to bind field value to float64, internal=strconv.ParseFloat: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, conversion fails fast, value is not changed\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=0&param=nope&param=100\",\n\t\t\texpectValue:   []float64(nil),\n\t\t\texpectError:   \"code=400, message=failed to bind field value to float64, internal=strconv.ParseFloat: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=4.3&param=0\",\n\t\t\texpectValue: []float64{4.3, 0},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []float64(nil),\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:            \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast:   true,\n\t\t\tgivenBindErrors: []error{errors.New(\"previous error\")},\n\t\t\twhenMust:        true,\n\t\t\twhenURL:         \"/search?param=1&param=100\",\n\t\t\texpectValue:     []float64(nil),\n\t\t\texpectError:     \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: []float64(nil),\n\t\t\texpectError: \"code=400, message=failed to bind field value to float64, internal=strconv.ParseFloat: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tb.errors = tc.givenBindErrors\n\n\t\t\tvar dest []float64\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustFloat64s(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Float64s(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_Float32(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenNoFailFast bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     float32\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=4.3&param=1\",\n\t\t\texpectValue: 4.3,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: 1.123,\n\t\t},\n\t\t{\n\t\t\tname:            \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenNoFailFast: true,\n\t\t\twhenURL:         \"/search?param=1&param=100\",\n\t\t\texpectValue:     1.123,\n\t\t\texpectError:     \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: 1.123,\n\t\t\texpectError: \"code=400, message=failed to bind field value to float32, internal=strconv.ParseFloat: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=4.3&param=100\",\n\t\t\texpectValue: 4.3,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: 1.123,\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:            \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenNoFailFast: true,\n\t\t\twhenMust:        true,\n\t\t\twhenURL:         \"/search?param=1&param=100\",\n\t\t\texpectValue:     1.123,\n\t\t\texpectError:     \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: 1.123,\n\t\t\texpectError: \"code=400, message=failed to bind field value to float32, internal=strconv.ParseFloat: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenNoFailFast)\n\t\t\tif tc.givenNoFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tdest := float32(1.123)\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustFloat32(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Float32(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_Float32s(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     []float32\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=4.3&param=0\",\n\t\t\texpectValue: []float32{4.3, 0},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []float32(nil),\n\t\t},\n\t\t{\n\t\t\tname:            \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast:   true,\n\t\t\tgivenBindErrors: []error{errors.New(\"previous error\")},\n\t\t\twhenURL:         \"/search?param=1&param=100\",\n\t\t\texpectValue:     []float32(nil),\n\t\t\texpectError:     \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: []float32(nil),\n\t\t\texpectError: \"code=400, message=failed to bind field value to float32, internal=strconv.ParseFloat: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, conversion fails fast, value is not changed\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=0&param=nope&param=100\",\n\t\t\texpectValue:   []float32(nil),\n\t\t\texpectError:   \"code=400, message=failed to bind field value to float32, internal=strconv.ParseFloat: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=4.3&param=0\",\n\t\t\texpectValue: []float32{4.3, 0},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []float32(nil),\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:            \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast:   true,\n\t\t\tgivenBindErrors: []error{errors.New(\"previous error\")},\n\t\t\twhenMust:        true,\n\t\t\twhenURL:         \"/search?param=1&param=100\",\n\t\t\texpectValue:     []float32(nil),\n\t\t\texpectError:     \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: []float32(nil),\n\t\t\texpectError: \"code=400, message=failed to bind field value to float32, internal=strconv.ParseFloat: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tb.errors = tc.givenBindErrors\n\n\t\t\tvar dest []float32\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustFloat32s(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Float32s(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_Time(t *testing.T) {\n\texampleTime, _ := time.Parse(time.RFC3339, \"2020-12-23T09:45:31+02:00\")\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\twhenLayout      string\n\t\texpectValue     time.Time\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=2020-12-23T09:45:31%2B02:00&param=2000-01-02T09:45:31%2B00:00\",\n\t\t\twhenLayout:  time.RFC3339,\n\t\t\texpectValue: exampleTime,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: time.Time{},\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   time.Time{},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=2020-12-23T09:45:31%2B02:00&param=2000-01-02T09:45:31%2B00:00\",\n\t\t\twhenLayout:  time.RFC3339,\n\t\t\texpectValue: exampleTime,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: time.Time{},\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   time.Time{},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tdest := time.Time{}\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustTime(\"param\", &dest, tc.whenLayout).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Time(\"param\", &dest, tc.whenLayout).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_Times(t *testing.T) {\n\texampleTime, _ := time.Parse(time.RFC3339, \"2020-12-23T09:45:31+02:00\")\n\texampleTime2, _ := time.Parse(time.RFC3339, \"2000-01-02T09:45:31+00:00\")\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\twhenLayout      string\n\t\texpectValue     []time.Time\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=2020-12-23T09:45:31%2B02:00&param=2000-01-02T09:45:31%2B00:00\",\n\t\t\twhenLayout:  time.RFC3339,\n\t\t\texpectValue: []time.Time{exampleTime, exampleTime2},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []time.Time(nil),\n\t\t},\n\t\t{\n\t\t\tname:            \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast:   true,\n\t\t\tgivenBindErrors: []error{errors.New(\"previous error\")},\n\t\t\twhenURL:         \"/search?param=1&param=100\",\n\t\t\texpectValue:     []time.Time(nil),\n\t\t\texpectError:     \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=2020-12-23T09:45:31%2B02:00&param=2000-01-02T09:45:31%2B00:00\",\n\t\t\twhenLayout:  time.RFC3339,\n\t\t\texpectValue: []time.Time{exampleTime, exampleTime2},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []time.Time(nil),\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:            \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast:   true,\n\t\t\tgivenBindErrors: []error{errors.New(\"previous error\")},\n\t\t\twhenMust:        true,\n\t\t\twhenURL:         \"/search?param=1&param=100\",\n\t\t\texpectValue:     []time.Time(nil),\n\t\t\texpectError:     \"previous error\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tb.errors = tc.givenBindErrors\n\n\t\t\tlayout := time.RFC3339\n\t\t\tif tc.whenLayout != \"\" {\n\t\t\t\tlayout = tc.whenLayout\n\t\t\t}\n\n\t\t\tvar dest []time.Time\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustTimes(\"param\", &dest, layout).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Times(\"param\", &dest, layout).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_Duration(t *testing.T) {\n\texample := 42 * time.Second\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     time.Duration\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=42s&param=1ms\",\n\t\t\texpectValue: example,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: 0,\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   0,\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=42s&param=1ms\",\n\t\t\texpectValue: example,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: 0,\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   0,\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tvar dest time.Duration\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustDuration(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Duration(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_Durations(t *testing.T) {\n\texampleDuration := 42 * time.Second\n\texampleDuration2 := 1 * time.Millisecond\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     []time.Duration\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=42s&param=1ms\",\n\t\t\texpectValue: []time.Duration{exampleDuration, exampleDuration2},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []time.Duration(nil),\n\t\t},\n\t\t{\n\t\t\tname:            \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast:   true,\n\t\t\tgivenBindErrors: []error{errors.New(\"previous error\")},\n\t\t\twhenURL:         \"/search?param=1&param=100\",\n\t\t\texpectValue:     []time.Duration(nil),\n\t\t\texpectError:     \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=42s&param=1ms\",\n\t\t\texpectValue: []time.Duration{exampleDuration, exampleDuration2},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []time.Duration(nil),\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:            \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast:   true,\n\t\t\tgivenBindErrors: []error{errors.New(\"previous error\")},\n\t\t\twhenMust:        true,\n\t\t\twhenURL:         \"/search?param=1&param=100\",\n\t\t\texpectValue:     []time.Duration(nil),\n\t\t\texpectError:     \"previous error\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tb.errors = tc.givenBindErrors\n\n\t\t\tvar dest []time.Duration\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustDurations(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Durations(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_BindUnmarshaler(t *testing.T) {\n\texampleTime, _ := time.Parse(time.RFC3339, \"2020-12-23T09:45:31+02:00\")\n\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     Timestamp\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=2020-12-23T09:45:31%2B02:00&param=2000-01-02T09:45:31%2B00:00\",\n\t\t\texpectValue: Timestamp(exampleTime),\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: Timestamp{},\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   Timestamp{},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: Timestamp{},\n\t\t\texpectError: \"code=400, message=failed to bind field value to BindUnmarshaler interface, internal=parsing time \\\"nope\\\" as \\\"2006-01-02T15:04:05Z07:00\\\": cannot parse \\\"nope\\\" as \\\"2006\\\", field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=2020-12-23T09:45:31%2B02:00&param=2000-01-02T09:45:31%2B00:00\",\n\t\t\texpectValue: Timestamp(exampleTime),\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: Timestamp{},\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   Timestamp{},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: Timestamp{},\n\t\t\texpectError: \"code=400, message=failed to bind field value to BindUnmarshaler interface, internal=parsing time \\\"nope\\\" as \\\"2006-01-02T15:04:05Z07:00\\\": cannot parse \\\"nope\\\" as \\\"2006\\\", field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tvar dest Timestamp\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustBindUnmarshaler(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.BindUnmarshaler(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_JSONUnmarshaler(t *testing.T) {\n\texample := big.NewInt(999)\n\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     big.Int\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=999&param=998\",\n\t\t\texpectValue: *example,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: big.Int{},\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   big.Int{},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=xxx\",\n\t\t\texpectValue: big.Int{},\n\t\t\texpectError: \"code=400, message=failed to bind field value to json.Unmarshaler interface, internal=math/big: cannot unmarshal \\\"nope\\\" into a *big.Int, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=999&param=998\",\n\t\t\texpectValue: *example,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: big.Int{},\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?param=1&param=xxx\",\n\t\t\texpectValue:   big.Int{},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=xxx\",\n\t\t\texpectValue: big.Int{},\n\t\t\texpectError: \"code=400, message=failed to bind field value to json.Unmarshaler interface, internal=math/big: cannot unmarshal \\\"nope\\\" into a *big.Int, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tvar dest big.Int\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustJSONUnmarshaler(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.JSONUnmarshaler(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_TextUnmarshaler(t *testing.T) {\n\texample := big.NewInt(999)\n\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     big.Int\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=999&param=998\",\n\t\t\texpectValue: *example,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: big.Int{},\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   big.Int{},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=xxx\",\n\t\t\texpectValue: big.Int{},\n\t\t\texpectError: \"code=400, message=failed to bind field value to encoding.TextUnmarshaler interface, internal=math/big: cannot unmarshal \\\"nope\\\" into a *big.Int, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=999&param=998\",\n\t\t\texpectValue: *example,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: big.Int{},\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?param=1&param=xxx\",\n\t\t\texpectValue:   big.Int{},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=xxx\",\n\t\t\texpectValue: big.Int{},\n\t\t\texpectError: \"code=400, message=failed to bind field value to encoding.TextUnmarshaler interface, internal=math/big: cannot unmarshal \\\"nope\\\" into a *big.Int, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tvar dest big.Int\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustTextUnmarshaler(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.TextUnmarshaler(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_BindWithDelimiter_types(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname    string\n\t\twhenURL string\n\t\texpect  interface{}\n\t}{\n\t\t{\n\t\t\tname:   \"ok, strings\",\n\t\t\texpect: []string{\"1\", \"2\", \"1\"},\n\t\t},\n\t\t{\n\t\t\tname:   \"ok, int64\",\n\t\t\texpect: []int64{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:   \"ok, int32\",\n\t\t\texpect: []int32{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:   \"ok, int16\",\n\t\t\texpect: []int16{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:   \"ok, int8\",\n\t\t\texpect: []int8{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:   \"ok, int\",\n\t\t\texpect: []int{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:   \"ok, uint64\",\n\t\t\texpect: []uint64{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:   \"ok, uint32\",\n\t\t\texpect: []uint32{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:   \"ok, uint16\",\n\t\t\texpect: []uint16{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:   \"ok, uint8\",\n\t\t\texpect: []uint8{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:   \"ok, uint\",\n\t\t\texpect: []uint{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:   \"ok, float64\",\n\t\t\texpect: []float64{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:   \"ok, float32\",\n\t\t\texpect: []float32{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:    \"ok, bool\",\n\t\t\twhenURL: \"/search?param=1,false&param=true\",\n\t\t\texpect:  []bool{true, false, true},\n\t\t},\n\t\t{\n\t\t\tname:    \"ok, Duration\",\n\t\t\twhenURL: \"/search?param=1s,42s&param=1ms\",\n\t\t\texpect:  []time.Duration{1 * time.Second, 42 * time.Second, 1 * time.Millisecond},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tURL := \"/search?param=1,2&param=1\"\n\t\t\tif tc.whenURL != \"\" {\n\t\t\t\tURL = tc.whenURL\n\t\t\t}\n\t\t\tc := createTestContext(URL, nil, nil)\n\t\t\tb := QueryParamsBinder(c)\n\n\t\t\tswitch tc.expect.(type) {\n\t\t\tcase []string:\n\t\t\t\tvar dest []string\n\t\t\t\tassert.NoError(t, b.BindWithDelimiter(\"param\", &dest, \",\").BindError())\n\t\t\t\tassert.Equal(t, tc.expect, dest)\n\t\t\tcase []int64:\n\t\t\t\tvar dest []int64\n\t\t\t\tassert.NoError(t, b.BindWithDelimiter(\"param\", &dest, \",\").BindError())\n\t\t\t\tassert.Equal(t, tc.expect, dest)\n\t\t\tcase []int32:\n\t\t\t\tvar dest []int32\n\t\t\t\tassert.NoError(t, b.BindWithDelimiter(\"param\", &dest, \",\").BindError())\n\t\t\t\tassert.Equal(t, tc.expect, dest)\n\t\t\tcase []int16:\n\t\t\t\tvar dest []int16\n\t\t\t\tassert.NoError(t, b.BindWithDelimiter(\"param\", &dest, \",\").BindError())\n\t\t\t\tassert.Equal(t, tc.expect, dest)\n\t\t\tcase []int8:\n\t\t\t\tvar dest []int8\n\t\t\t\tassert.NoError(t, b.BindWithDelimiter(\"param\", &dest, \",\").BindError())\n\t\t\t\tassert.Equal(t, tc.expect, dest)\n\t\t\tcase []int:\n\t\t\t\tvar dest []int\n\t\t\t\tassert.NoError(t, b.BindWithDelimiter(\"param\", &dest, \",\").BindError())\n\t\t\t\tassert.Equal(t, tc.expect, dest)\n\t\t\tcase []uint64:\n\t\t\t\tvar dest []uint64\n\t\t\t\tassert.NoError(t, b.BindWithDelimiter(\"param\", &dest, \",\").BindError())\n\t\t\t\tassert.Equal(t, tc.expect, dest)\n\t\t\tcase []uint32:\n\t\t\t\tvar dest []uint32\n\t\t\t\tassert.NoError(t, b.BindWithDelimiter(\"param\", &dest, \",\").BindError())\n\t\t\t\tassert.Equal(t, tc.expect, dest)\n\t\t\tcase []uint16:\n\t\t\t\tvar dest []uint16\n\t\t\t\tassert.NoError(t, b.BindWithDelimiter(\"param\", &dest, \",\").BindError())\n\t\t\t\tassert.Equal(t, tc.expect, dest)\n\t\t\tcase []uint8:\n\t\t\t\tvar dest []uint8\n\t\t\t\tassert.NoError(t, b.BindWithDelimiter(\"param\", &dest, \",\").BindError())\n\t\t\t\tassert.Equal(t, tc.expect, dest)\n\t\t\tcase []uint:\n\t\t\t\tvar dest []uint\n\t\t\t\tassert.NoError(t, b.BindWithDelimiter(\"param\", &dest, \",\").BindError())\n\t\t\t\tassert.Equal(t, tc.expect, dest)\n\t\t\tcase []float64:\n\t\t\t\tvar dest []float64\n\t\t\t\tassert.NoError(t, b.BindWithDelimiter(\"param\", &dest, \",\").BindError())\n\t\t\t\tassert.Equal(t, tc.expect, dest)\n\t\t\tcase []float32:\n\t\t\t\tvar dest []float32\n\t\t\t\tassert.NoError(t, b.BindWithDelimiter(\"param\", &dest, \",\").BindError())\n\t\t\t\tassert.Equal(t, tc.expect, dest)\n\t\t\tcase []bool:\n\t\t\t\tvar dest []bool\n\t\t\t\tassert.NoError(t, b.BindWithDelimiter(\"param\", &dest, \",\").BindError())\n\t\t\t\tassert.Equal(t, tc.expect, dest)\n\t\t\tcase []time.Duration:\n\t\t\t\tvar dest []time.Duration\n\t\t\t\tassert.NoError(t, b.BindWithDelimiter(\"param\", &dest, \",\").BindError())\n\t\t\t\tassert.Equal(t, tc.expect, dest)\n\t\t\tdefault:\n\t\t\t\tassert.Fail(t, \"invalid type\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_BindWithDelimiter(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     []int64\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value\",\n\t\t\twhenURL:     \"/search?param=1,2&param=1\",\n\t\t\texpectValue: []int64{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []int64(nil),\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   []int64(nil),\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: []int64(nil),\n\t\t\texpectError: \"code=400, message=failed to bind field value to int64, internal=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=1,2&param=1\",\n\t\t\texpectValue: []int64{1, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: []int64(nil),\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   []int64(nil),\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: []int64(nil),\n\t\t\texpectError: \"code=400, message=failed to bind field value to int64, internal=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tvar dest []int64\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustBindWithDelimiter(\"param\", &dest, \",\").BindError()\n\t\t\t} else {\n\t\t\t\terr = b.BindWithDelimiter(\"param\", &dest, \",\").BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBindWithDelimiter_invalidType(t *testing.T) {\n\tc := createTestContext(\"/search?param=1&param=100\", nil, nil)\n\tb := QueryParamsBinder(c)\n\n\tvar dest []BindUnmarshaler\n\terr := b.BindWithDelimiter(\"param\", &dest, \",\").BindError()\n\tassert.Equal(t, []BindUnmarshaler(nil), dest)\n\tassert.EqualError(t, err, \"code=400, message=unsupported bind type, field=param\")\n}\n\nfunc TestValueBinder_UnixTime(t *testing.T) {\n\texampleTime, _ := time.Parse(time.RFC3339, \"2020-12-28T18:36:43+00:00\") // => 1609180603\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     time.Time\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value, unix time in seconds\",\n\t\t\twhenURL:     \"/search?param=1609180603&param=1609180604\",\n\t\t\texpectValue: exampleTime,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, binds value, unix time over int32 value\",\n\t\t\twhenURL:     \"/search?param=2147483648&param=1609180604\",\n\t\t\texpectValue: time.Unix(2147483648, 0),\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: time.Time{},\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   time.Time{},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: time.Time{},\n\t\t\texpectError: \"code=400, message=failed to bind field value to Time, internal=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=1609180603&param=1609180604\",\n\t\t\texpectValue: exampleTime,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: time.Time{},\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   time.Time{},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: time.Time{},\n\t\t\texpectError: \"code=400, message=failed to bind field value to Time, internal=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tdest := time.Time{}\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustUnixTime(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.UnixTime(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue.UnixNano(), dest.UnixNano())\n\t\t\tassert.Equal(t, tc.expectValue.In(time.UTC), dest.In(time.UTC))\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_UnixTimeMilli(t *testing.T) {\n\texampleTime, _ := time.Parse(time.RFC3339Nano, \"2022-03-13T15:13:30.140000000+00:00\") // => 1647184410140\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     time.Time\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value, unix time in milliseconds\",\n\t\t\twhenURL:     \"/search?param=1647184410140&param=1647184410199\",\n\t\t\texpectValue: exampleTime,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: time.Time{},\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   time.Time{},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: time.Time{},\n\t\t\texpectError: \"code=400, message=failed to bind field value to Time, internal=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=1647184410140&param=1647184410199\",\n\t\t\texpectValue: exampleTime,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: time.Time{},\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   time.Time{},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: time.Time{},\n\t\t\texpectError: \"code=400, message=failed to bind field value to Time, internal=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tdest := time.Time{}\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustUnixTimeMilli(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.UnixTimeMilli(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue.UnixNano(), dest.UnixNano())\n\t\t\tassert.Equal(t, tc.expectValue.In(time.UTC), dest.In(time.UTC))\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_UnixTimeNano(t *testing.T) {\n\texampleTime, _ := time.Parse(time.RFC3339, \"2020-12-28T18:36:43.000000000+00:00\")         // => 1609180603\n\texampleTimeNano, _ := time.Parse(time.RFC3339Nano, \"2020-12-28T18:36:43.123456789+00:00\") // => 1609180603123456789\n\texampleTimeNanoBelowSec, _ := time.Parse(time.RFC3339Nano, \"1970-01-01T00:00:00.999999999+00:00\")\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     time.Time\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"ok, binds value, unix time in nano seconds (sec precision)\",\n\t\t\twhenURL:     \"/search?param=1609180603000000000&param=1609180604\",\n\t\t\texpectValue: exampleTime,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, binds value, unix time in nano seconds\",\n\t\t\twhenURL:     \"/search?param=1609180603123456789&param=1609180604\",\n\t\t\texpectValue: exampleTimeNano,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, binds value, unix time in nano seconds (below 1 sec)\",\n\t\t\twhenURL:     \"/search?param=999999999&param=1609180604\",\n\t\t\texpectValue: exampleTimeNanoBelowSec,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, params values empty, value is not changed\",\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: time.Time{},\n\t\t},\n\t\t{\n\t\t\tname:          \"nok, previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   time.Time{},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: time.Time{},\n\t\t\texpectError: \"code=400, message=failed to bind field value to Time, internal=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), binds value\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=1609180603000000000&param=1609180604\",\n\t\t\texpectValue: exampleTime,\n\t\t},\n\t\t{\n\t\t\tname:        \"ok (must), params values empty, returns error, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?nope=1\",\n\t\t\texpectValue: time.Time{},\n\t\t\texpectError: \"code=400, message=required field value is empty, field=param\",\n\t\t},\n\t\t{\n\t\t\tname:          \"nok (must), previous errors fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenMust:      true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   time.Time{},\n\t\t\texpectError:   \"previous error\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: time.Time{},\n\t\t\texpectError: \"code=400, message=failed to bind field value to Time, internal=strconv.ParseInt: parsing \\\"nope\\\": invalid syntax, field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tdest := time.Time{}\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustUnixTimeNano(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.UnixTimeNano(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue.UnixNano(), dest.UnixNano())\n\t\t\tassert.Equal(t, tc.expectValue.In(time.UTC), dest.In(time.UTC))\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkDefaultBinder_BindInt64_single(b *testing.B) {\n\ttype Opts struct {\n\t\tParam int64 `query:\"param\"`\n\t}\n\tc := createTestContext(\"/search?param=1&param=100\", nil, nil)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tbinder := new(DefaultBinder)\n\tfor i := 0; i < b.N; i++ {\n\t\tvar dest Opts\n\t\t_ = binder.Bind(&dest, c)\n\t}\n}\n\nfunc BenchmarkValueBinder_BindInt64_single(b *testing.B) {\n\tc := createTestContext(\"/search?param=1&param=100\", nil, nil)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\ttype Opts struct {\n\t\tParam int64\n\t}\n\tbinder := QueryParamsBinder(c)\n\tfor i := 0; i < b.N; i++ {\n\t\tvar dest Opts\n\t\t_ = binder.Int64(\"param\", &dest.Param).BindError()\n\t}\n}\n\nfunc BenchmarkRawFunc_Int64_single(b *testing.B) {\n\tc := createTestContext(\"/search?param=1&param=100\", nil, nil)\n\n\trawFunc := func(input string, defaultValue int64) (int64, bool) {\n\t\tif input == \"\" {\n\t\t\treturn defaultValue, true\n\t\t}\n\t\tn, err := strconv.Atoi(input)\n\t\tif err != nil {\n\t\t\treturn 0, false\n\t\t}\n\t\treturn int64(n), true\n\t}\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\ttype Opts struct {\n\t\tParam int64\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\tvar dest Opts\n\t\tif n, ok := rawFunc(c.QueryParam(\"param\"), 1); ok {\n\t\t\tdest.Param = n\n\t\t}\n\t}\n}\n\nfunc BenchmarkDefaultBinder_BindInt64_10_fields(b *testing.B) {\n\ttype Opts struct {\n\t\tInt64  int64  `query:\"int64\"`\n\t\tInt32  int32  `query:\"int32\"`\n\t\tInt16  int16  `query:\"int16\"`\n\t\tInt8   int8   `query:\"int8\"`\n\t\tString string `query:\"string\"`\n\n\t\tUint64  uint64   `query:\"uint64\"`\n\t\tUint32  uint32   `query:\"uint32\"`\n\t\tUint16  uint16   `query:\"uint16\"`\n\t\tUint8   uint8    `query:\"uint8\"`\n\t\tStrings []string `query:\"strings\"`\n\t}\n\tc := createTestContext(\"/search?int64=1&int32=2&int16=3&int8=4&string=test&uint64=5&uint32=6&uint16=7&uint8=8&strings=first&strings=second\", nil, nil)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tbinder := new(DefaultBinder)\n\tfor i := 0; i < b.N; i++ {\n\t\tvar dest Opts\n\t\t_ = binder.Bind(&dest, c)\n\t\tif dest.Int64 != 1 {\n\t\t\tb.Fatalf(\"int64!=1\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkValueBinder_BindInt64_10_fields(b *testing.B) {\n\ttype Opts struct {\n\t\tInt64  int64  `query:\"int64\"`\n\t\tInt32  int32  `query:\"int32\"`\n\t\tInt16  int16  `query:\"int16\"`\n\t\tInt8   int8   `query:\"int8\"`\n\t\tString string `query:\"string\"`\n\n\t\tUint64  uint64   `query:\"uint64\"`\n\t\tUint32  uint32   `query:\"uint32\"`\n\t\tUint16  uint16   `query:\"uint16\"`\n\t\tUint8   uint8    `query:\"uint8\"`\n\t\tStrings []string `query:\"strings\"`\n\t}\n\tc := createTestContext(\"/search?int64=1&int32=2&int16=3&int8=4&string=test&uint64=5&uint32=6&uint16=7&uint8=8&strings=first&strings=second\", nil, nil)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tbinder := QueryParamsBinder(c)\n\tfor i := 0; i < b.N; i++ {\n\t\tvar dest Opts\n\t\t_ = binder.\n\t\t\tInt64(\"int64\", &dest.Int64).\n\t\t\tInt32(\"int32\", &dest.Int32).\n\t\t\tInt16(\"int16\", &dest.Int16).\n\t\t\tInt8(\"int8\", &dest.Int8).\n\t\t\tString(\"string\", &dest.String).\n\t\t\tUint64(\"int64\", &dest.Uint64).\n\t\t\tUint32(\"int32\", &dest.Uint32).\n\t\t\tUint16(\"int16\", &dest.Uint16).\n\t\t\tUint8(\"int8\", &dest.Uint8).\n\t\t\tStrings(\"strings\", &dest.Strings).\n\t\t\tBindError()\n\t\tif dest.Int64 != 1 {\n\t\t\tb.Fatalf(\"int64!=1\")\n\t\t}\n\t}\n}\n\nfunc TestValueBinder_TimeError(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\twhenLayout      string\n\t\texpectValue     time.Time\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: time.Time{},\n\t\t\texpectError: \"code=400, message=failed to bind field value to Time, internal=parsing time \\\"nope\\\": extra text: \\\"nope\\\", field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: time.Time{},\n\t\t\texpectError: \"code=400, message=failed to bind field value to Time, internal=parsing time \\\"nope\\\": extra text: \\\"nope\\\", field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tdest := time.Time{}\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustTime(\"param\", &dest, tc.whenLayout).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Time(\"param\", &dest, tc.whenLayout).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_TimesError(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\twhenLayout      string\n\t\texpectValue     []time.Time\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:          \"nok, fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   []time.Time(nil),\n\t\t\texpectError:   \"code=400, message=failed to bind field value to Time, internal=parsing time \\\"1\\\" as \\\"2006-01-02T15:04:05Z07:00\\\": cannot parse \\\"1\\\" as \\\"2006\\\", field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: []time.Time(nil),\n\t\t\texpectError: \"code=400, message=failed to bind field value to Time, internal=parsing time \\\"nope\\\" as \\\"2006-01-02T15:04:05Z07:00\\\": cannot parse \\\"nope\\\" as \\\"2006\\\", field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: []time.Time(nil),\n\t\t\texpectError: \"code=400, message=failed to bind field value to Time, internal=parsing time \\\"nope\\\" as \\\"2006-01-02T15:04:05Z07:00\\\": cannot parse \\\"nope\\\" as \\\"2006\\\", field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tb.errors = tc.givenBindErrors\n\n\t\t\tlayout := time.RFC3339\n\t\t\tif tc.whenLayout != \"\" {\n\t\t\t\tlayout = tc.whenLayout\n\t\t\t}\n\n\t\t\tvar dest []time.Time\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustTimes(\"param\", &dest, layout).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Times(\"param\", &dest, layout).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_DurationError(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     time.Duration\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: 0,\n\t\t\texpectError: \"code=400, message=failed to bind field value to Duration, internal=time: invalid duration \\\"nope\\\", field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: 0,\n\t\t\texpectError: \"code=400, message=failed to bind field value to Duration, internal=time: invalid duration \\\"nope\\\", field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tif tc.givenFailFast {\n\t\t\t\tb.errors = []error{errors.New(\"previous error\")}\n\t\t\t}\n\n\t\t\tvar dest time.Duration\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustDuration(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Duration(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValueBinder_DurationsError(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenFailFast   bool\n\t\tgivenBindErrors []error\n\t\twhenURL         string\n\t\twhenMust        bool\n\t\texpectValue     []time.Duration\n\t\texpectError     string\n\t}{\n\t\t{\n\t\t\tname:          \"nok, fail fast without binding value\",\n\t\t\tgivenFailFast: true,\n\t\t\twhenURL:       \"/search?param=1&param=100\",\n\t\t\texpectValue:   []time.Duration(nil),\n\t\t\texpectError:   \"code=400, message=failed to bind field value to Duration, internal=time: missing unit in duration \\\"1\\\", field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, conversion fails, value is not changed\",\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: []time.Duration(nil),\n\t\t\texpectError: \"code=400, message=failed to bind field value to Duration, internal=time: invalid duration \\\"nope\\\", field=param\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok (must), conversion fails, value is not changed\",\n\t\t\twhenMust:    true,\n\t\t\twhenURL:     \"/search?param=nope&param=100\",\n\t\t\texpectValue: []time.Duration(nil),\n\t\t\texpectError: \"code=400, message=failed to bind field value to Duration, internal=time: invalid duration \\\"nope\\\", field=param\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := createTestContext(tc.whenURL, nil, nil)\n\t\t\tb := QueryParamsBinder(c).FailFast(tc.givenFailFast)\n\t\t\tb.errors = tc.givenBindErrors\n\n\t\t\tvar dest []time.Duration\n\t\t\tvar err error\n\t\t\tif tc.whenMust {\n\t\t\t\terr = b.MustDurations(\"param\", &dest).BindError()\n\t\t\t} else {\n\t\t\t\terr = b.Durations(\"param\", &dest).BindError()\n\t\t\t}\n\n\t\t\tassert.Equal(t, tc.expectValue, dest)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.1474609375,
          "content": "coverage:\n  status:\n    project:\n      default:\n        threshold: 1%\n    patch:\n      default:\n        threshold: 1%\n\ncomment:\n  require_changes: true"
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 17.1748046875,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// Context represents the context of the current HTTP request. It holds request and\n// response objects, path, path parameters, data and registered handler.\ntype Context interface {\n\t// Request returns `*http.Request`.\n\tRequest() *http.Request\n\n\t// SetRequest sets `*http.Request`.\n\tSetRequest(r *http.Request)\n\n\t// SetResponse sets `*Response`.\n\tSetResponse(r *Response)\n\n\t// Response returns `*Response`.\n\tResponse() *Response\n\n\t// IsTLS returns true if HTTP connection is TLS otherwise false.\n\tIsTLS() bool\n\n\t// IsWebSocket returns true if HTTP connection is WebSocket otherwise false.\n\tIsWebSocket() bool\n\n\t// Scheme returns the HTTP protocol scheme, `http` or `https`.\n\tScheme() string\n\n\t// RealIP returns the client's network address based on `X-Forwarded-For`\n\t// or `X-Real-IP` request header.\n\t// The behavior can be configured using `Echo#IPExtractor`.\n\tRealIP() string\n\n\t// Path returns the registered path for the handler.\n\tPath() string\n\n\t// SetPath sets the registered path for the handler.\n\tSetPath(p string)\n\n\t// Param returns path parameter by name.\n\tParam(name string) string\n\n\t// ParamNames returns path parameter names.\n\tParamNames() []string\n\n\t// SetParamNames sets path parameter names.\n\tSetParamNames(names ...string)\n\n\t// ParamValues returns path parameter values.\n\tParamValues() []string\n\n\t// SetParamValues sets path parameter values.\n\tSetParamValues(values ...string)\n\n\t// QueryParam returns the query param for the provided name.\n\tQueryParam(name string) string\n\n\t// QueryParams returns the query parameters as `url.Values`.\n\tQueryParams() url.Values\n\n\t// QueryString returns the URL query string.\n\tQueryString() string\n\n\t// FormValue returns the form field value for the provided name.\n\tFormValue(name string) string\n\n\t// FormParams returns the form parameters as `url.Values`.\n\tFormParams() (url.Values, error)\n\n\t// FormFile returns the multipart form file for the provided name.\n\tFormFile(name string) (*multipart.FileHeader, error)\n\n\t// MultipartForm returns the multipart form.\n\tMultipartForm() (*multipart.Form, error)\n\n\t// Cookie returns the named cookie provided in the request.\n\tCookie(name string) (*http.Cookie, error)\n\n\t// SetCookie adds a `Set-Cookie` header in HTTP response.\n\tSetCookie(cookie *http.Cookie)\n\n\t// Cookies returns the HTTP cookies sent with the request.\n\tCookies() []*http.Cookie\n\n\t// Get retrieves data from the context.\n\tGet(key string) interface{}\n\n\t// Set saves data in the context.\n\tSet(key string, val interface{})\n\n\t// Bind binds path params, query params and the request body into provided type `i`. The default binder\n\t// binds body based on Content-Type header.\n\tBind(i interface{}) error\n\n\t// Validate validates provided `i`. It is usually called after `Context#Bind()`.\n\t// Validator must be registered using `Echo#Validator`.\n\tValidate(i interface{}) error\n\n\t// Render renders a template with data and sends a text/html response with status\n\t// code. Renderer must be registered using `Echo.Renderer`.\n\tRender(code int, name string, data interface{}) error\n\n\t// HTML sends an HTTP response with status code.\n\tHTML(code int, html string) error\n\n\t// HTMLBlob sends an HTTP blob response with status code.\n\tHTMLBlob(code int, b []byte) error\n\n\t// String sends a string response with status code.\n\tString(code int, s string) error\n\n\t// JSON sends a JSON response with status code.\n\tJSON(code int, i interface{}) error\n\n\t// JSONPretty sends a pretty-print JSON with status code.\n\tJSONPretty(code int, i interface{}, indent string) error\n\n\t// JSONBlob sends a JSON blob response with status code.\n\tJSONBlob(code int, b []byte) error\n\n\t// JSONP sends a JSONP response with status code. It uses `callback` to construct\n\t// the JSONP payload.\n\tJSONP(code int, callback string, i interface{}) error\n\n\t// JSONPBlob sends a JSONP blob response with status code. It uses `callback`\n\t// to construct the JSONP payload.\n\tJSONPBlob(code int, callback string, b []byte) error\n\n\t// XML sends an XML response with status code.\n\tXML(code int, i interface{}) error\n\n\t// XMLPretty sends a pretty-print XML with status code.\n\tXMLPretty(code int, i interface{}, indent string) error\n\n\t// XMLBlob sends an XML blob response with status code.\n\tXMLBlob(code int, b []byte) error\n\n\t// Blob sends a blob response with status code and content type.\n\tBlob(code int, contentType string, b []byte) error\n\n\t// Stream sends a streaming response with status code and content type.\n\tStream(code int, contentType string, r io.Reader) error\n\n\t// File sends a response with the content of the file.\n\tFile(file string) error\n\n\t// Attachment sends a response as attachment, prompting client to save the\n\t// file.\n\tAttachment(file string, name string) error\n\n\t// Inline sends a response as inline, opening the file in the browser.\n\tInline(file string, name string) error\n\n\t// NoContent sends a response with no body and a status code.\n\tNoContent(code int) error\n\n\t// Redirect redirects the request to a provided URL with status code.\n\tRedirect(code int, url string) error\n\n\t// Error invokes the registered global HTTP error handler. Generally used by middleware.\n\t// A side-effect of calling global error handler is that now Response has been committed (sent to the client) and\n\t// middlewares up in chain can not change Response status code or Response body anymore.\n\t//\n\t// Avoid using this method in handlers as no middleware will be able to effectively handle errors after that.\n\tError(err error)\n\n\t// Handler returns the matched handler by router.\n\tHandler() HandlerFunc\n\n\t// SetHandler sets the matched handler by router.\n\tSetHandler(h HandlerFunc)\n\n\t// Logger returns the `Logger` instance.\n\tLogger() Logger\n\n\t// SetLogger Set the logger\n\tSetLogger(l Logger)\n\n\t// Echo returns the `Echo` instance.\n\tEcho() *Echo\n\n\t// Reset resets the context after request completes. It must be called along\n\t// with `Echo#AcquireContext()` and `Echo#ReleaseContext()`.\n\t// See `Echo#ServeHTTP()`\n\tReset(r *http.Request, w http.ResponseWriter)\n}\n\ntype context struct {\n\tlogger   Logger\n\trequest  *http.Request\n\tresponse *Response\n\tquery    url.Values\n\techo     *Echo\n\n\tstore Map\n\tlock  sync.RWMutex\n\n\t// following fields are set by Router\n\thandler HandlerFunc\n\n\t// path is route path that Router matched. It is empty string where there is no route match.\n\t// Route registered with RouteNotFound is considered as a match and path therefore is not empty.\n\tpath string\n\n\t// Usually echo.Echo is sizing pvalues but there could be user created middlewares that decide to\n\t// overwrite parameter by calling SetParamNames + SetParamValues.\n\t// When echo.Echo allocated that slice it length/capacity is tied to echo.Echo.maxParam value.\n\t//\n\t// It is important that pvalues size is always equal or bigger to pnames length.\n\tpvalues []string\n\n\t// pnames length is tied to param count for the matched route\n\tpnames []string\n}\n\nconst (\n\t// ContextKeyHeaderAllow is set by Router for getting value for `Allow` header in later stages of handler call chain.\n\t// Allow header is mandatory for status 405 (method not found) and useful for OPTIONS method requests.\n\t// It is added to context only when Router does not find matching method handler for request.\n\tContextKeyHeaderAllow = \"echo_header_allow\"\n)\n\nconst (\n\tdefaultMemory = 32 << 20 // 32 MB\n\tindexPage     = \"index.html\"\n\tdefaultIndent = \"  \"\n)\n\nfunc (c *context) writeContentType(value string) {\n\theader := c.Response().Header()\n\tif header.Get(HeaderContentType) == \"\" {\n\t\theader.Set(HeaderContentType, value)\n\t}\n}\n\nfunc (c *context) Request() *http.Request {\n\treturn c.request\n}\n\nfunc (c *context) SetRequest(r *http.Request) {\n\tc.request = r\n}\n\nfunc (c *context) Response() *Response {\n\treturn c.response\n}\n\nfunc (c *context) SetResponse(r *Response) {\n\tc.response = r\n}\n\nfunc (c *context) IsTLS() bool {\n\treturn c.request.TLS != nil\n}\n\nfunc (c *context) IsWebSocket() bool {\n\tupgrade := c.request.Header.Get(HeaderUpgrade)\n\treturn strings.EqualFold(upgrade, \"websocket\")\n}\n\nfunc (c *context) Scheme() string {\n\t// Can't use `r.Request.URL.Scheme`\n\t// See: https://groups.google.com/forum/#!topic/golang-nuts/pMUkBlQBDF0\n\tif c.IsTLS() {\n\t\treturn \"https\"\n\t}\n\tif scheme := c.request.Header.Get(HeaderXForwardedProto); scheme != \"\" {\n\t\treturn scheme\n\t}\n\tif scheme := c.request.Header.Get(HeaderXForwardedProtocol); scheme != \"\" {\n\t\treturn scheme\n\t}\n\tif ssl := c.request.Header.Get(HeaderXForwardedSsl); ssl == \"on\" {\n\t\treturn \"https\"\n\t}\n\tif scheme := c.request.Header.Get(HeaderXUrlScheme); scheme != \"\" {\n\t\treturn scheme\n\t}\n\treturn \"http\"\n}\n\nfunc (c *context) RealIP() string {\n\tif c.echo != nil && c.echo.IPExtractor != nil {\n\t\treturn c.echo.IPExtractor(c.request)\n\t}\n\t// Fall back to legacy behavior\n\tif ip := c.request.Header.Get(HeaderXForwardedFor); ip != \"\" {\n\t\ti := strings.IndexAny(ip, \",\")\n\t\tif i > 0 {\n\t\t\txffip := strings.TrimSpace(ip[:i])\n\t\t\txffip = strings.TrimPrefix(xffip, \"[\")\n\t\t\txffip = strings.TrimSuffix(xffip, \"]\")\n\t\t\treturn xffip\n\t\t}\n\t\treturn ip\n\t}\n\tif ip := c.request.Header.Get(HeaderXRealIP); ip != \"\" {\n\t\tip = strings.TrimPrefix(ip, \"[\")\n\t\tip = strings.TrimSuffix(ip, \"]\")\n\t\treturn ip\n\t}\n\tra, _, _ := net.SplitHostPort(c.request.RemoteAddr)\n\treturn ra\n}\n\nfunc (c *context) Path() string {\n\treturn c.path\n}\n\nfunc (c *context) SetPath(p string) {\n\tc.path = p\n}\n\nfunc (c *context) Param(name string) string {\n\tfor i, n := range c.pnames {\n\t\tif i < len(c.pvalues) {\n\t\t\tif n == name {\n\t\t\t\treturn c.pvalues[i]\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc (c *context) ParamNames() []string {\n\treturn c.pnames\n}\n\nfunc (c *context) SetParamNames(names ...string) {\n\tc.pnames = names\n\n\tl := len(names)\n\tif len(c.pvalues) < l {\n\t\t// Keeping the old pvalues just for backward compatibility, but it sounds that doesn't make sense to keep them,\n\t\t// probably those values will be overridden in a Context#SetParamValues\n\t\tnewPvalues := make([]string, l)\n\t\tcopy(newPvalues, c.pvalues)\n\t\tc.pvalues = newPvalues\n\t}\n}\n\nfunc (c *context) ParamValues() []string {\n\treturn c.pvalues[:len(c.pnames)]\n}\n\nfunc (c *context) SetParamValues(values ...string) {\n\t// NOTE: Don't just set c.pvalues = values, because it has to have length c.echo.maxParam (or bigger) at all times\n\t// It will brake the Router#Find code\n\tlimit := len(values)\n\tif limit > len(c.pvalues) {\n\t\tc.pvalues = make([]string, limit)\n\t}\n\tfor i := 0; i < limit; i++ {\n\t\tc.pvalues[i] = values[i]\n\t}\n}\n\nfunc (c *context) QueryParam(name string) string {\n\tif c.query == nil {\n\t\tc.query = c.request.URL.Query()\n\t}\n\treturn c.query.Get(name)\n}\n\nfunc (c *context) QueryParams() url.Values {\n\tif c.query == nil {\n\t\tc.query = c.request.URL.Query()\n\t}\n\treturn c.query\n}\n\nfunc (c *context) QueryString() string {\n\treturn c.request.URL.RawQuery\n}\n\nfunc (c *context) FormValue(name string) string {\n\treturn c.request.FormValue(name)\n}\n\nfunc (c *context) FormParams() (url.Values, error) {\n\tif strings.HasPrefix(c.request.Header.Get(HeaderContentType), MIMEMultipartForm) {\n\t\tif err := c.request.ParseMultipartForm(defaultMemory); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tif err := c.request.ParseForm(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn c.request.Form, nil\n}\n\nfunc (c *context) FormFile(name string) (*multipart.FileHeader, error) {\n\tf, fh, err := c.request.FormFile(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tf.Close()\n\treturn fh, nil\n}\n\nfunc (c *context) MultipartForm() (*multipart.Form, error) {\n\terr := c.request.ParseMultipartForm(defaultMemory)\n\treturn c.request.MultipartForm, err\n}\n\nfunc (c *context) Cookie(name string) (*http.Cookie, error) {\n\treturn c.request.Cookie(name)\n}\n\nfunc (c *context) SetCookie(cookie *http.Cookie) {\n\thttp.SetCookie(c.Response(), cookie)\n}\n\nfunc (c *context) Cookies() []*http.Cookie {\n\treturn c.request.Cookies()\n}\n\nfunc (c *context) Get(key string) interface{} {\n\tc.lock.RLock()\n\tdefer c.lock.RUnlock()\n\treturn c.store[key]\n}\n\nfunc (c *context) Set(key string, val interface{}) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tif c.store == nil {\n\t\tc.store = make(Map)\n\t}\n\tc.store[key] = val\n}\n\nfunc (c *context) Bind(i interface{}) error {\n\treturn c.echo.Binder.Bind(i, c)\n}\n\nfunc (c *context) Validate(i interface{}) error {\n\tif c.echo.Validator == nil {\n\t\treturn ErrValidatorNotRegistered\n\t}\n\treturn c.echo.Validator.Validate(i)\n}\n\nfunc (c *context) Render(code int, name string, data interface{}) (err error) {\n\tif c.echo.Renderer == nil {\n\t\treturn ErrRendererNotRegistered\n\t}\n\tbuf := new(bytes.Buffer)\n\tif err = c.echo.Renderer.Render(buf, name, data, c); err != nil {\n\t\treturn\n\t}\n\treturn c.HTMLBlob(code, buf.Bytes())\n}\n\nfunc (c *context) HTML(code int, html string) (err error) {\n\treturn c.HTMLBlob(code, []byte(html))\n}\n\nfunc (c *context) HTMLBlob(code int, b []byte) (err error) {\n\treturn c.Blob(code, MIMETextHTMLCharsetUTF8, b)\n}\n\nfunc (c *context) String(code int, s string) (err error) {\n\treturn c.Blob(code, MIMETextPlainCharsetUTF8, []byte(s))\n}\n\nfunc (c *context) jsonPBlob(code int, callback string, i interface{}) (err error) {\n\tindent := \"\"\n\tif _, pretty := c.QueryParams()[\"pretty\"]; c.echo.Debug || pretty {\n\t\tindent = defaultIndent\n\t}\n\tc.writeContentType(MIMEApplicationJavaScriptCharsetUTF8)\n\tc.response.WriteHeader(code)\n\tif _, err = c.response.Write([]byte(callback + \"(\")); err != nil {\n\t\treturn\n\t}\n\tif err = c.echo.JSONSerializer.Serialize(c, i, indent); err != nil {\n\t\treturn\n\t}\n\tif _, err = c.response.Write([]byte(\");\")); err != nil {\n\t\treturn\n\t}\n\treturn\n}\n\nfunc (c *context) json(code int, i interface{}, indent string) error {\n\tc.writeContentType(MIMEApplicationJSON)\n\tc.response.Status = code\n\treturn c.echo.JSONSerializer.Serialize(c, i, indent)\n}\n\nfunc (c *context) JSON(code int, i interface{}) (err error) {\n\tindent := \"\"\n\tif _, pretty := c.QueryParams()[\"pretty\"]; c.echo.Debug || pretty {\n\t\tindent = defaultIndent\n\t}\n\treturn c.json(code, i, indent)\n}\n\nfunc (c *context) JSONPretty(code int, i interface{}, indent string) (err error) {\n\treturn c.json(code, i, indent)\n}\n\nfunc (c *context) JSONBlob(code int, b []byte) (err error) {\n\treturn c.Blob(code, MIMEApplicationJSON, b)\n}\n\nfunc (c *context) JSONP(code int, callback string, i interface{}) (err error) {\n\treturn c.jsonPBlob(code, callback, i)\n}\n\nfunc (c *context) JSONPBlob(code int, callback string, b []byte) (err error) {\n\tc.writeContentType(MIMEApplicationJavaScriptCharsetUTF8)\n\tc.response.WriteHeader(code)\n\tif _, err = c.response.Write([]byte(callback + \"(\")); err != nil {\n\t\treturn\n\t}\n\tif _, err = c.response.Write(b); err != nil {\n\t\treturn\n\t}\n\t_, err = c.response.Write([]byte(\");\"))\n\treturn\n}\n\nfunc (c *context) xml(code int, i interface{}, indent string) (err error) {\n\tc.writeContentType(MIMEApplicationXMLCharsetUTF8)\n\tc.response.WriteHeader(code)\n\tenc := xml.NewEncoder(c.response)\n\tif indent != \"\" {\n\t\tenc.Indent(\"\", indent)\n\t}\n\tif _, err = c.response.Write([]byte(xml.Header)); err != nil {\n\t\treturn\n\t}\n\treturn enc.Encode(i)\n}\n\nfunc (c *context) XML(code int, i interface{}) (err error) {\n\tindent := \"\"\n\tif _, pretty := c.QueryParams()[\"pretty\"]; c.echo.Debug || pretty {\n\t\tindent = defaultIndent\n\t}\n\treturn c.xml(code, i, indent)\n}\n\nfunc (c *context) XMLPretty(code int, i interface{}, indent string) (err error) {\n\treturn c.xml(code, i, indent)\n}\n\nfunc (c *context) XMLBlob(code int, b []byte) (err error) {\n\tc.writeContentType(MIMEApplicationXMLCharsetUTF8)\n\tc.response.WriteHeader(code)\n\tif _, err = c.response.Write([]byte(xml.Header)); err != nil {\n\t\treturn\n\t}\n\t_, err = c.response.Write(b)\n\treturn\n}\n\nfunc (c *context) Blob(code int, contentType string, b []byte) (err error) {\n\tc.writeContentType(contentType)\n\tc.response.WriteHeader(code)\n\t_, err = c.response.Write(b)\n\treturn\n}\n\nfunc (c *context) Stream(code int, contentType string, r io.Reader) (err error) {\n\tc.writeContentType(contentType)\n\tc.response.WriteHeader(code)\n\t_, err = io.Copy(c.response, r)\n\treturn\n}\n\nfunc (c *context) Attachment(file, name string) error {\n\treturn c.contentDisposition(file, name, \"attachment\")\n}\n\nfunc (c *context) Inline(file, name string) error {\n\treturn c.contentDisposition(file, name, \"inline\")\n}\n\nvar quoteEscaper = strings.NewReplacer(\"\\\\\", \"\\\\\\\\\", `\"`, \"\\\\\\\"\")\n\nfunc (c *context) contentDisposition(file, name, dispositionType string) error {\n\tc.response.Header().Set(HeaderContentDisposition, fmt.Sprintf(`%s; filename=\"%s\"`, dispositionType, quoteEscaper.Replace(name)))\n\treturn c.File(file)\n}\n\nfunc (c *context) NoContent(code int) error {\n\tc.response.WriteHeader(code)\n\treturn nil\n}\n\nfunc (c *context) Redirect(code int, url string) error {\n\tif code < 300 || code > 308 {\n\t\treturn ErrInvalidRedirectCode\n\t}\n\tc.response.Header().Set(HeaderLocation, url)\n\tc.response.WriteHeader(code)\n\treturn nil\n}\n\nfunc (c *context) Error(err error) {\n\tc.echo.HTTPErrorHandler(err, c)\n}\n\nfunc (c *context) Echo() *Echo {\n\treturn c.echo\n}\n\nfunc (c *context) Handler() HandlerFunc {\n\treturn c.handler\n}\n\nfunc (c *context) SetHandler(h HandlerFunc) {\n\tc.handler = h\n}\n\nfunc (c *context) Logger() Logger {\n\tres := c.logger\n\tif res != nil {\n\t\treturn res\n\t}\n\treturn c.echo.Logger\n}\n\nfunc (c *context) SetLogger(l Logger) {\n\tc.logger = l\n}\n\nfunc (c *context) Reset(r *http.Request, w http.ResponseWriter) {\n\tc.request = r\n\tc.response.reset(w)\n\tc.query = nil\n\tc.handler = NotFoundHandler\n\tc.store = nil\n\tc.path = \"\"\n\tc.pnames = nil\n\tc.logger = nil\n\t// NOTE: Don't reset because it has to have length c.echo.maxParam (or bigger) at all times\n\tfor i := 0; i < len(c.pvalues); i++ {\n\t\tc.pvalues[i] = \"\"\n\t}\n}\n"
        },
        {
          "name": "context_fs.go",
          "type": "blob",
          "size": 1.3388671875,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"io/fs\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc (c *context) File(file string) error {\n\treturn fsFile(c, file, c.echo.Filesystem)\n}\n\n// FileFS serves file from given file system.\n//\n// When dealing with `embed.FS` use `fs := echo.MustSubFS(fs, \"rootDirectory\") to create sub fs which uses necessary\n// prefix for directory path. This is necessary as `//go:embed assets/images` embeds files with paths\n// including `assets/images` as their prefix.\nfunc (c *context) FileFS(file string, filesystem fs.FS) error {\n\treturn fsFile(c, file, filesystem)\n}\n\nfunc fsFile(c Context, file string, filesystem fs.FS) error {\n\tf, err := filesystem.Open(file)\n\tif err != nil {\n\t\treturn ErrNotFound\n\t}\n\tdefer f.Close()\n\n\tfi, _ := f.Stat()\n\tif fi.IsDir() {\n\t\tfile = filepath.ToSlash(filepath.Join(file, indexPage)) // ToSlash is necessary for Windows. fs.Open and os.Open are different in that aspect.\n\t\tf, err = filesystem.Open(file)\n\t\tif err != nil {\n\t\t\treturn ErrNotFound\n\t\t}\n\t\tdefer f.Close()\n\t\tif fi, err = f.Stat(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tff, ok := f.(io.ReadSeeker)\n\tif !ok {\n\t\treturn errors.New(\"file does not implement io.ReadSeeker\")\n\t}\n\thttp.ServeContent(c.Response(), c.Request(), fi.Name(), fi.ModTime(), ff)\n\treturn nil\n}\n"
        },
        {
          "name": "context_fs_test.go",
          "type": "blob",
          "size": 3.1689453125,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"github.com/stretchr/testify/assert\"\n\t\"io/fs\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestContext_File(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname             string\n\t\twhenFile         string\n\t\twhenFS           fs.FS\n\t\texpectStatus     int\n\t\texpectStartsWith []byte\n\t\texpectError      string\n\t}{\n\t\t{\n\t\t\tname:             \"ok, from default file system\",\n\t\t\twhenFile:         \"_fixture/images/walle.png\",\n\t\t\twhenFS:           nil,\n\t\t\texpectStatus:     http.StatusOK,\n\t\t\texpectStartsWith: []byte{0x89, 0x50, 0x4e},\n\t\t},\n\t\t{\n\t\t\tname:             \"ok, from custom file system\",\n\t\t\twhenFile:         \"walle.png\",\n\t\t\twhenFS:           os.DirFS(\"_fixture/images\"),\n\t\t\texpectStatus:     http.StatusOK,\n\t\t\texpectStartsWith: []byte{0x89, 0x50, 0x4e},\n\t\t},\n\t\t{\n\t\t\tname:             \"nok, not existent file\",\n\t\t\twhenFile:         \"not.png\",\n\t\t\twhenFS:           os.DirFS(\"_fixture/images\"),\n\t\t\texpectStatus:     http.StatusOK,\n\t\t\texpectStartsWith: nil,\n\t\t\texpectError:      \"code=404, message=Not Found\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\tif tc.whenFS != nil {\n\t\t\t\te.Filesystem = tc.whenFS\n\t\t\t}\n\n\t\t\thandler := func(ec Context) error {\n\t\t\t\treturn ec.(*context).File(tc.whenFile)\n\t\t\t}\n\n\t\t\treq := httptest.NewRequest(http.MethodGet, \"/match.png\", nil)\n\t\t\trec := httptest.NewRecorder()\n\t\t\tc := e.NewContext(req, rec)\n\n\t\t\terr := handler(c)\n\n\t\t\tassert.Equal(t, tc.expectStatus, rec.Code)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\n\t\t\tbody := rec.Body.Bytes()\n\t\t\tif len(body) > len(tc.expectStartsWith) {\n\t\t\t\tbody = body[:len(tc.expectStartsWith)]\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectStartsWith, body)\n\t\t})\n\t}\n}\n\nfunc TestContext_FileFS(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname             string\n\t\twhenFile         string\n\t\twhenFS           fs.FS\n\t\texpectStatus     int\n\t\texpectStartsWith []byte\n\t\texpectError      string\n\t}{\n\t\t{\n\t\t\tname:             \"ok\",\n\t\t\twhenFile:         \"walle.png\",\n\t\t\twhenFS:           os.DirFS(\"_fixture/images\"),\n\t\t\texpectStatus:     http.StatusOK,\n\t\t\texpectStartsWith: []byte{0x89, 0x50, 0x4e},\n\t\t},\n\t\t{\n\t\t\tname:             \"nok, not existent file\",\n\t\t\twhenFile:         \"not.png\",\n\t\t\twhenFS:           os.DirFS(\"_fixture/images\"),\n\t\t\texpectStatus:     http.StatusOK,\n\t\t\texpectStartsWith: nil,\n\t\t\texpectError:      \"code=404, message=Not Found\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\n\t\t\thandler := func(ec Context) error {\n\t\t\t\treturn ec.(*context).FileFS(tc.whenFile, tc.whenFS)\n\t\t\t}\n\n\t\t\treq := httptest.NewRequest(http.MethodGet, \"/match.png\", nil)\n\t\t\trec := httptest.NewRecorder()\n\t\t\tc := e.NewContext(req, rec)\n\n\t\t\terr := handler(c)\n\n\t\t\tassert.Equal(t, tc.expectStatus, rec.Code)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\n\t\t\tbody := rec.Body.Bytes()\n\t\t\tif len(body) > len(tc.expectStartsWith) {\n\t\t\t\tbody = body[:len(tc.expectStartsWith)]\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectStartsWith, body)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "context_test.go",
          "type": "blob",
          "size": 27.9697265625,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n\t\"text/template\"\n\t\"time\"\n\n\t\"github.com/labstack/gommon/log\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype Template struct {\n\ttemplates *template.Template\n}\n\nvar testUser = user{1, \"Jon Snow\"}\n\nfunc BenchmarkAllocJSONP(b *testing.B) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(userJSON))\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec).(*context)\n\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tc.JSONP(http.StatusOK, \"callback\", testUser)\n\t}\n}\n\nfunc BenchmarkAllocJSON(b *testing.B) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(userJSON))\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec).(*context)\n\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tc.JSON(http.StatusOK, testUser)\n\t}\n}\n\nfunc BenchmarkAllocXML(b *testing.B) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(userJSON))\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec).(*context)\n\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tc.XML(http.StatusOK, testUser)\n\t}\n}\n\nfunc BenchmarkRealIPForHeaderXForwardFor(b *testing.B) {\n\tc := context{request: &http.Request{\n\t\tHeader: http.Header{HeaderXForwardedFor: []string{\"127.0.0.1, 127.0.1.1, \"}},\n\t}}\n\tfor i := 0; i < b.N; i++ {\n\t\tc.RealIP()\n\t}\n}\n\nfunc (t *Template) Render(w io.Writer, name string, data interface{}, c Context) error {\n\treturn t.templates.ExecuteTemplate(w, name, data)\n}\n\nfunc TestContextEcho(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(userJSON))\n\trec := httptest.NewRecorder()\n\n\tc := e.NewContext(req, rec).(*context)\n\n\tassert.Equal(t, e, c.Echo())\n}\n\nfunc TestContextRequest(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(userJSON))\n\trec := httptest.NewRecorder()\n\n\tc := e.NewContext(req, rec).(*context)\n\n\tassert.NotNil(t, c.Request())\n\tassert.Equal(t, req, c.Request())\n}\n\nfunc TestContextResponse(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(userJSON))\n\trec := httptest.NewRecorder()\n\n\tc := e.NewContext(req, rec).(*context)\n\n\tassert.NotNil(t, c.Response())\n}\n\nfunc TestContextRenderTemplate(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(userJSON))\n\trec := httptest.NewRecorder()\n\n\tc := e.NewContext(req, rec).(*context)\n\n\ttmpl := &Template{\n\t\ttemplates: template.Must(template.New(\"hello\").Parse(\"Hello, {{.}}!\")),\n\t}\n\tc.echo.Renderer = tmpl\n\terr := c.Render(http.StatusOK, \"hello\", \"Jon Snow\")\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, \"Hello, Jon Snow!\", rec.Body.String())\n\t}\n}\n\nfunc TestContextRenderErrorsOnNoRenderer(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(userJSON))\n\trec := httptest.NewRecorder()\n\n\tc := e.NewContext(req, rec).(*context)\n\n\tc.echo.Renderer = nil\n\tassert.Error(t, c.Render(http.StatusOK, \"hello\", \"Jon Snow\"))\n}\n\nfunc TestContextJSON(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(userJSON))\n\tc := e.NewContext(req, rec).(*context)\n\n\terr := c.JSON(http.StatusOK, user{1, \"Jon Snow\"})\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, MIMEApplicationJSON, rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, userJSON+\"\\n\", rec.Body.String())\n\t}\n}\n\nfunc TestContextJSONErrorsOut(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(userJSON))\n\tc := e.NewContext(req, rec).(*context)\n\n\terr := c.JSON(http.StatusOK, make(chan bool))\n\tassert.EqualError(t, err, \"json: unsupported type: chan bool\")\n}\n\nfunc TestContextJSONPrettyURL(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/?pretty\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\terr := c.JSON(http.StatusOK, user{1, \"Jon Snow\"})\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, MIMEApplicationJSON, rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, userJSONPretty+\"\\n\", rec.Body.String())\n\t}\n}\n\nfunc TestContextJSONPretty(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\terr := c.JSONPretty(http.StatusOK, user{1, \"Jon Snow\"}, \"  \")\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, MIMEApplicationJSON, rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, userJSONPretty+\"\\n\", rec.Body.String())\n\t}\n}\n\nfunc TestContextJSONWithEmptyIntent(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\tu := user{1, \"Jon Snow\"}\n\temptyIndent := \"\"\n\tbuf := new(bytes.Buffer)\n\n\tenc := json.NewEncoder(buf)\n\tenc.SetIndent(emptyIndent, emptyIndent)\n\t_ = enc.Encode(u)\n\terr := c.json(http.StatusOK, user{1, \"Jon Snow\"}, emptyIndent)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, MIMEApplicationJSON, rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, buf.String(), rec.Body.String())\n\t}\n}\n\nfunc TestContextJSONP(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\tcallback := \"callback\"\n\terr := c.JSONP(http.StatusOK, callback, user{1, \"Jon Snow\"})\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, MIMEApplicationJavaScriptCharsetUTF8, rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, callback+\"(\"+userJSON+\"\\n);\", rec.Body.String())\n\t}\n}\n\nfunc TestContextJSONBlob(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\tdata, err := json.Marshal(user{1, \"Jon Snow\"})\n\tassert.NoError(t, err)\n\terr = c.JSONBlob(http.StatusOK, data)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, MIMEApplicationJSON, rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, userJSON, rec.Body.String())\n\t}\n}\n\nfunc TestContextJSONPBlob(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\tcallback := \"callback\"\n\tdata, err := json.Marshal(user{1, \"Jon Snow\"})\n\tassert.NoError(t, err)\n\terr = c.JSONPBlob(http.StatusOK, callback, data)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, MIMEApplicationJavaScriptCharsetUTF8, rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, callback+\"(\"+userJSON+\");\", rec.Body.String())\n\t}\n}\n\nfunc TestContextXML(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\terr := c.XML(http.StatusOK, user{1, \"Jon Snow\"})\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, MIMEApplicationXMLCharsetUTF8, rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, xml.Header+userXML, rec.Body.String())\n\t}\n}\n\nfunc TestContextXMLPrettyURL(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/?pretty\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\terr := c.XML(http.StatusOK, user{1, \"Jon Snow\"})\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, MIMEApplicationXMLCharsetUTF8, rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, xml.Header+userXMLPretty, rec.Body.String())\n\t}\n}\n\nfunc TestContextXMLPretty(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\terr := c.XMLPretty(http.StatusOK, user{1, \"Jon Snow\"}, \"  \")\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, MIMEApplicationXMLCharsetUTF8, rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, xml.Header+userXMLPretty, rec.Body.String())\n\t}\n}\n\nfunc TestContextXMLBlob(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\tdata, err := xml.Marshal(user{1, \"Jon Snow\"})\n\tassert.NoError(t, err)\n\terr = c.XMLBlob(http.StatusOK, data)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, MIMEApplicationXMLCharsetUTF8, rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, xml.Header+userXML, rec.Body.String())\n\t}\n}\n\nfunc TestContextXMLWithEmptyIntent(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\tu := user{1, \"Jon Snow\"}\n\temptyIndent := \"\"\n\tbuf := new(bytes.Buffer)\n\n\tenc := xml.NewEncoder(buf)\n\tenc.Indent(emptyIndent, emptyIndent)\n\t_ = enc.Encode(u)\n\terr := c.xml(http.StatusOK, user{1, \"Jon Snow\"}, emptyIndent)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, MIMEApplicationXMLCharsetUTF8, rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, xml.Header+buf.String(), rec.Body.String())\n\t}\n}\n\ntype responseWriterErr struct {\n}\n\nfunc (responseWriterErr) Header() http.Header {\n\treturn http.Header{}\n}\n\nfunc (responseWriterErr) Write([]byte) (int, error) {\n\treturn 0, errors.New(\"responseWriterErr\")\n}\n\nfunc (responseWriterErr) WriteHeader(statusCode int) {\n}\n\nfunc TestContextXMLError(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/?pretty\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\tc.response.Writer = responseWriterErr{}\n\n\terr := c.XML(http.StatusOK, make(chan bool))\n\tassert.EqualError(t, err, \"responseWriterErr\")\n}\n\nfunc TestContextString(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/?pretty\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\terr := c.String(http.StatusOK, \"Hello, World!\")\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, MIMETextPlainCharsetUTF8, rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, \"Hello, World!\", rec.Body.String())\n\t}\n}\n\nfunc TestContextHTML(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/?pretty\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\terr := c.HTML(http.StatusOK, \"Hello, <strong>World!</strong>\")\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, MIMETextHTMLCharsetUTF8, rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, \"Hello, <strong>World!</strong>\", rec.Body.String())\n\t}\n}\n\nfunc TestContextStream(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/?pretty\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\tr := strings.NewReader(\"response from a stream\")\n\terr := c.Stream(http.StatusOK, \"application/octet-stream\", r)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, \"application/octet-stream\", rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, \"response from a stream\", rec.Body.String())\n\t}\n}\n\nfunc TestContextAttachment(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\twhenName     string\n\t\texpectHeader string\n\t}{\n\t\t{\n\t\t\tname:         \"ok\",\n\t\t\twhenName:     \"walle.png\",\n\t\t\texpectHeader: `attachment; filename=\"walle.png\"`,\n\t\t},\n\t\t{\n\t\t\tname:         \"ok, escape quotes in malicious filename\",\n\t\t\twhenName:     `malicious.sh\"; \\\"; dummy=.txt`,\n\t\t\texpectHeader: `attachment; filename=\"malicious.sh\\\"; \\\\\\\"; dummy=.txt\"`,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\trec := httptest.NewRecorder()\n\t\t\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\t\t\tc := e.NewContext(req, rec).(*context)\n\n\t\t\terr := c.Attachment(\"_fixture/images/walle.png\", tc.whenName)\n\t\t\tif assert.NoError(t, err) {\n\t\t\t\tassert.Equal(t, tc.expectHeader, rec.Header().Get(HeaderContentDisposition))\n\n\t\t\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\t\t\tassert.Equal(t, 219885, rec.Body.Len())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestContextInline(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\twhenName     string\n\t\texpectHeader string\n\t}{\n\t\t{\n\t\t\tname:         \"ok\",\n\t\t\twhenName:     \"walle.png\",\n\t\t\texpectHeader: `inline; filename=\"walle.png\"`,\n\t\t},\n\t\t{\n\t\t\tname:         \"ok, escape quotes in malicious filename\",\n\t\t\twhenName:     `malicious.sh\"; \\\"; dummy=.txt`,\n\t\t\texpectHeader: `inline; filename=\"malicious.sh\\\"; \\\\\\\"; dummy=.txt\"`,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\trec := httptest.NewRecorder()\n\t\t\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\t\t\tc := e.NewContext(req, rec).(*context)\n\n\t\t\terr := c.Inline(\"_fixture/images/walle.png\", tc.whenName)\n\t\t\tif assert.NoError(t, err) {\n\t\t\t\tassert.Equal(t, tc.expectHeader, rec.Header().Get(HeaderContentDisposition))\n\n\t\t\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\t\t\tassert.Equal(t, 219885, rec.Body.Len())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestContextNoContent(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/?pretty\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\tc.NoContent(http.StatusOK)\n\tassert.Equal(t, http.StatusOK, rec.Code)\n}\n\nfunc TestContextError(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/?pretty\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\tc.Error(errors.New(\"error\"))\n\tassert.Equal(t, http.StatusInternalServerError, rec.Code)\n\tassert.True(t, c.Response().Committed)\n}\n\nfunc TestContextReset(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tc := e.NewContext(req, rec).(*context)\n\n\tc.SetParamNames(\"foo\")\n\tc.SetParamValues(\"bar\")\n\tc.Set(\"foe\", \"ban\")\n\tc.query = url.Values(map[string][]string{\"fon\": {\"baz\"}})\n\n\tc.Reset(req, httptest.NewRecorder())\n\n\tassert.Len(t, c.ParamValues(), 0)\n\tassert.Len(t, c.ParamNames(), 0)\n\tassert.Len(t, c.Path(), 0)\n\tassert.Len(t, c.QueryParams(), 0)\n\tassert.Len(t, c.store, 0)\n}\n\nfunc TestContext_JSON_CommitsCustomResponseCode(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec).(*context)\n\terr := c.JSON(http.StatusCreated, user{1, \"Jon Snow\"})\n\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusCreated, rec.Code)\n\t\tassert.Equal(t, MIMEApplicationJSON, rec.Header().Get(HeaderContentType))\n\t\tassert.Equal(t, userJSON+\"\\n\", rec.Body.String())\n\t}\n}\n\nfunc TestContext_JSON_DoesntCommitResponseCodePrematurely(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec).(*context)\n\terr := c.JSON(http.StatusCreated, map[string]float64{\"a\": math.NaN()})\n\n\tif assert.Error(t, err) {\n\t\tassert.False(t, c.response.Committed)\n\t}\n}\n\nfunc TestContextCookie(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\ttheme := \"theme=light\"\n\tuser := \"user=Jon Snow\"\n\treq.Header.Add(HeaderCookie, theme)\n\treq.Header.Add(HeaderCookie, user)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec).(*context)\n\n\t// Read single\n\tcookie, err := c.Cookie(\"theme\")\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, \"theme\", cookie.Name)\n\t\tassert.Equal(t, \"light\", cookie.Value)\n\t}\n\n\t// Read multiple\n\tfor _, cookie := range c.Cookies() {\n\t\tswitch cookie.Name {\n\t\tcase \"theme\":\n\t\t\tassert.Equal(t, \"light\", cookie.Value)\n\t\tcase \"user\":\n\t\t\tassert.Equal(t, \"Jon Snow\", cookie.Value)\n\t\t}\n\t}\n\n\t// Write\n\tcookie = &http.Cookie{\n\t\tName:     \"SSID\",\n\t\tValue:    \"Ap4PGTEq\",\n\t\tDomain:   \"labstack.com\",\n\t\tPath:     \"/\",\n\t\tExpires:  time.Now(),\n\t\tSecure:   true,\n\t\tHttpOnly: true,\n\t}\n\tc.SetCookie(cookie)\n\tassert.Contains(t, rec.Header().Get(HeaderSetCookie), \"SSID\")\n\tassert.Contains(t, rec.Header().Get(HeaderSetCookie), \"Ap4PGTEq\")\n\tassert.Contains(t, rec.Header().Get(HeaderSetCookie), \"labstack.com\")\n\tassert.Contains(t, rec.Header().Get(HeaderSetCookie), \"Secure\")\n\tassert.Contains(t, rec.Header().Get(HeaderSetCookie), \"HttpOnly\")\n}\n\nfunc TestContextPath(t *testing.T) {\n\te := New()\n\tr := e.Router()\n\n\thandler := func(c Context) error { return c.String(http.StatusOK, \"OK\") }\n\n\tr.Add(http.MethodGet, \"/users/:id\", handler)\n\tc := e.NewContext(nil, nil)\n\tr.Find(http.MethodGet, \"/users/1\", c)\n\n\tassert.Equal(t, \"/users/:id\", c.Path())\n\n\tr.Add(http.MethodGet, \"/users/:uid/files/:fid\", handler)\n\tc = e.NewContext(nil, nil)\n\tr.Find(http.MethodGet, \"/users/1/files/1\", c)\n\tassert.Equal(t, \"/users/:uid/files/:fid\", c.Path())\n}\n\nfunc TestContextPathParam(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tc := e.NewContext(req, nil)\n\n\t// ParamNames\n\tc.SetParamNames(\"uid\", \"fid\")\n\tassert.EqualValues(t, []string{\"uid\", \"fid\"}, c.ParamNames())\n\n\t// ParamValues\n\tc.SetParamValues(\"101\", \"501\")\n\tassert.EqualValues(t, []string{\"101\", \"501\"}, c.ParamValues())\n\n\t// Param\n\tassert.Equal(t, \"501\", c.Param(\"fid\"))\n\tassert.Equal(t, \"\", c.Param(\"undefined\"))\n}\n\nfunc TestContextGetAndSetParam(t *testing.T) {\n\te := New()\n\tr := e.Router()\n\tr.Add(http.MethodGet, \"/:foo\", func(Context) error { return nil })\n\treq := httptest.NewRequest(http.MethodGet, \"/:foo\", nil)\n\tc := e.NewContext(req, nil)\n\tc.SetParamNames(\"foo\")\n\n\t// round-trip param values with modification\n\tparamVals := c.ParamValues()\n\tassert.EqualValues(t, []string{\"\"}, c.ParamValues())\n\tparamVals[0] = \"bar\"\n\tc.SetParamValues(paramVals...)\n\tassert.EqualValues(t, []string{\"bar\"}, c.ParamValues())\n\n\t// shouldn't explode during Reset() afterwards!\n\tassert.NotPanics(t, func() {\n\t\tc.Reset(nil, nil)\n\t})\n}\n\nfunc TestContextSetParamNamesEchoMaxParam(t *testing.T) {\n\te := New()\n\tassert.Equal(t, 0, *e.maxParam)\n\n\texpectedOneParam := []string{\"one\"}\n\texpectedTwoParams := []string{\"one\", \"two\"}\n\texpectedThreeParams := []string{\"one\", \"two\", \"\"}\n\n\t{\n\t\tc := e.AcquireContext()\n\t\tc.SetParamNames(\"1\", \"2\")\n\t\tc.SetParamValues(expectedTwoParams...)\n\t\tassert.Equal(t, 0, *e.maxParam) // has not been changed\n\t\tassert.EqualValues(t, expectedTwoParams, c.ParamValues())\n\t\te.ReleaseContext(c)\n\t}\n\n\t{\n\t\tc := e.AcquireContext()\n\t\tc.SetParamNames(\"1\", \"2\", \"3\")\n\t\tc.SetParamValues(expectedThreeParams...)\n\t\tassert.Equal(t, 0, *e.maxParam) // has not been changed\n\t\tassert.EqualValues(t, expectedThreeParams, c.ParamValues())\n\t\te.ReleaseContext(c)\n\t}\n\n\t{ // values is always same size as names length\n\t\tc := e.NewContext(nil, nil)\n\t\tc.SetParamValues([]string{\"one\", \"two\"}...) // more values than names should be ok\n\t\tc.SetParamNames(\"1\")\n\t\tassert.Equal(t, 0, *e.maxParam) // has not been changed\n\t\tassert.EqualValues(t, expectedOneParam, c.ParamValues())\n\t}\n\n\te.GET(\"/:id\", handlerFunc)\n\tassert.Equal(t, 1, *e.maxParam) // has not been changed\n\n\t{\n\t\tc := e.NewContext(nil, nil)\n\t\tc.SetParamValues([]string{\"one\", \"two\"}...)\n\t\tc.SetParamNames(\"1\")\n\t\tassert.Equal(t, 1, *e.maxParam) // has not been changed\n\t\tassert.EqualValues(t, expectedOneParam, c.ParamValues())\n\t}\n}\n\nfunc TestContextFormValue(t *testing.T) {\n\tf := make(url.Values)\n\tf.Set(\"name\", \"Jon Snow\")\n\tf.Set(\"email\", \"jon@labstack.com\")\n\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(f.Encode()))\n\treq.Header.Add(HeaderContentType, MIMEApplicationForm)\n\tc := e.NewContext(req, nil)\n\n\t// FormValue\n\tassert.Equal(t, \"Jon Snow\", c.FormValue(\"name\"))\n\tassert.Equal(t, \"jon@labstack.com\", c.FormValue(\"email\"))\n\n\t// FormParams\n\tparams, err := c.FormParams()\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, url.Values{\n\t\t\t\"name\":  []string{\"Jon Snow\"},\n\t\t\t\"email\": []string{\"jon@labstack.com\"},\n\t\t}, params)\n\t}\n\n\t// Multipart FormParams error\n\treq = httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(f.Encode()))\n\treq.Header.Add(HeaderContentType, MIMEMultipartForm)\n\tc = e.NewContext(req, nil)\n\tparams, err = c.FormParams()\n\tassert.Nil(t, params)\n\tassert.Error(t, err)\n}\n\nfunc TestContextQueryParam(t *testing.T) {\n\tq := make(url.Values)\n\tq.Set(\"name\", \"Jon Snow\")\n\tq.Set(\"email\", \"jon@labstack.com\")\n\treq := httptest.NewRequest(http.MethodGet, \"/?\"+q.Encode(), nil)\n\te := New()\n\tc := e.NewContext(req, nil)\n\n\t// QueryParam\n\tassert.Equal(t, \"Jon Snow\", c.QueryParam(\"name\"))\n\tassert.Equal(t, \"jon@labstack.com\", c.QueryParam(\"email\"))\n\n\t// QueryParams\n\tassert.Equal(t, url.Values{\n\t\t\"name\":  []string{\"Jon Snow\"},\n\t\t\"email\": []string{\"jon@labstack.com\"},\n\t}, c.QueryParams())\n}\n\nfunc TestContextFormFile(t *testing.T) {\n\te := New()\n\tbuf := new(bytes.Buffer)\n\tmr := multipart.NewWriter(buf)\n\tw, err := mr.CreateFormFile(\"file\", \"test\")\n\tif assert.NoError(t, err) {\n\t\tw.Write([]byte(\"test\"))\n\t}\n\tmr.Close()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", buf)\n\treq.Header.Set(HeaderContentType, mr.FormDataContentType())\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tf, err := c.FormFile(\"file\")\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, \"test\", f.Filename)\n\t}\n}\n\nfunc TestContextMultipartForm(t *testing.T) {\n\te := New()\n\tbuf := new(bytes.Buffer)\n\tmw := multipart.NewWriter(buf)\n\tmw.WriteField(\"name\", \"Jon Snow\")\n\tfileContent := \"This is a test file\"\n\tw, err := mw.CreateFormFile(\"file\", \"test.txt\")\n\tif assert.NoError(t, err) {\n\t\tw.Write([]byte(fileContent))\n\t}\n\tmw.Close()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", buf)\n\treq.Header.Set(HeaderContentType, mw.FormDataContentType())\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tf, err := c.MultipartForm()\n\tif assert.NoError(t, err) {\n\t\tassert.NotNil(t, f)\n\n\t\tfiles := f.File[\"file\"]\n\t\tif assert.Len(t, files, 1) {\n\t\t\tfile := files[0]\n\t\t\tassert.Equal(t, \"test.txt\", file.Filename)\n\t\t\tassert.Equal(t, int64(len(fileContent)), file.Size)\n\t\t}\n\t}\n}\n\nfunc TestContextRedirect(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tassert.Equal(t, nil, c.Redirect(http.StatusMovedPermanently, \"http://labstack.github.io/echo\"))\n\tassert.Equal(t, http.StatusMovedPermanently, rec.Code)\n\tassert.Equal(t, \"http://labstack.github.io/echo\", rec.Header().Get(HeaderLocation))\n\tassert.Error(t, c.Redirect(310, \"http://labstack.github.io/echo\"))\n}\n\nfunc TestContextStore(t *testing.T) {\n\tvar c Context = new(context)\n\tc.Set(\"name\", \"Jon Snow\")\n\tassert.Equal(t, \"Jon Snow\", c.Get(\"name\"))\n}\n\nfunc BenchmarkContext_Store(b *testing.B) {\n\te := &Echo{}\n\n\tc := &context{\n\t\techo: e,\n\t}\n\n\tfor n := 0; n < b.N; n++ {\n\t\tc.Set(\"name\", \"Jon Snow\")\n\t\tif c.Get(\"name\") != \"Jon Snow\" {\n\t\t\tb.Fail()\n\t\t}\n\t}\n}\n\nfunc TestContextHandler(t *testing.T) {\n\te := New()\n\tr := e.Router()\n\tb := new(bytes.Buffer)\n\n\tr.Add(http.MethodGet, \"/handler\", func(Context) error {\n\t\t_, err := b.Write([]byte(\"handler\"))\n\t\treturn err\n\t})\n\tc := e.NewContext(nil, nil)\n\tr.Find(http.MethodGet, \"/handler\", c)\n\terr := c.Handler()(c)\n\tassert.Equal(t, \"handler\", b.String())\n\tassert.NoError(t, err)\n}\n\nfunc TestContext_SetHandler(t *testing.T) {\n\tvar c Context = new(context)\n\n\tassert.Nil(t, c.Handler())\n\n\tc.SetHandler(func(c Context) error {\n\t\treturn nil\n\t})\n\tassert.NotNil(t, c.Handler())\n}\n\nfunc TestContext_Path(t *testing.T) {\n\tpath := \"/pa/th\"\n\n\tvar c Context = new(context)\n\n\tc.SetPath(path)\n\tassert.Equal(t, path, c.Path())\n}\n\ntype validator struct{}\n\nfunc (*validator) Validate(i interface{}) error {\n\treturn nil\n}\n\nfunc TestContext_Validate(t *testing.T) {\n\te := New()\n\tc := e.NewContext(nil, nil)\n\n\tassert.Error(t, c.Validate(struct{}{}))\n\n\te.Validator = &validator{}\n\tassert.NoError(t, c.Validate(struct{}{}))\n}\n\nfunc TestContext_QueryString(t *testing.T) {\n\te := New()\n\n\tqueryString := \"query=string&var=val\"\n\n\treq := httptest.NewRequest(http.MethodGet, \"/?\"+queryString, nil)\n\tc := e.NewContext(req, nil)\n\n\tassert.Equal(t, queryString, c.QueryString())\n}\n\nfunc TestContext_Request(t *testing.T) {\n\tvar c Context = new(context)\n\n\tassert.Nil(t, c.Request())\n\n\treq := httptest.NewRequest(http.MethodGet, \"/path\", nil)\n\tc.SetRequest(req)\n\n\tassert.Equal(t, req, c.Request())\n}\n\nfunc TestContext_Scheme(t *testing.T) {\n\ttests := []struct {\n\t\tc Context\n\t\ts string\n\t}{\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tTLS: &tls.ConnectionState{},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"https\",\n\t\t},\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tHeader: http.Header{HeaderXForwardedProto: []string{\"https\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"https\",\n\t\t},\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tHeader: http.Header{HeaderXForwardedProtocol: []string{\"http\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"http\",\n\t\t},\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tHeader: http.Header{HeaderXForwardedSsl: []string{\"on\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"https\",\n\t\t},\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tHeader: http.Header{HeaderXUrlScheme: []string{\"https\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"https\",\n\t\t},\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{},\n\t\t\t},\n\t\t\t\"http\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tassert.Equal(t, tt.s, tt.c.Scheme())\n\t}\n}\n\nfunc TestContext_IsWebSocket(t *testing.T) {\n\ttests := []struct {\n\t\tc  Context\n\t\tws assert.BoolAssertionFunc\n\t}{\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tHeader: http.Header{HeaderUpgrade: []string{\"websocket\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tassert.True,\n\t\t},\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tHeader: http.Header{HeaderUpgrade: []string{\"Websocket\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tassert.True,\n\t\t},\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{},\n\t\t\t},\n\t\t\tassert.False,\n\t\t},\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tHeader: http.Header{HeaderUpgrade: []string{\"other\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\tassert.False,\n\t\t},\n\t}\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"test %d\", i+1), func(t *testing.T) {\n\t\t\ttt.ws(t, tt.c.IsWebSocket())\n\t\t})\n\t}\n}\n\nfunc TestContext_Bind(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(userJSON))\n\tc := e.NewContext(req, nil)\n\tu := new(user)\n\n\treq.Header.Add(HeaderContentType, MIMEApplicationJSON)\n\terr := c.Bind(u)\n\tassert.NoError(t, err)\n\tassert.Equal(t, &user{1, \"Jon Snow\"}, u)\n}\n\nfunc TestContext_Logger(t *testing.T) {\n\te := New()\n\tc := e.NewContext(nil, nil)\n\n\tlog1 := c.Logger()\n\tassert.NotNil(t, log1)\n\n\tlog2 := log.New(\"echo2\")\n\tc.SetLogger(log2)\n\tassert.Equal(t, log2, c.Logger())\n\n\t// Resetting the context returns the initial logger\n\tc.Reset(nil, nil)\n\tassert.Equal(t, log1, c.Logger())\n}\n\nfunc TestContext_RealIP(t *testing.T) {\n\ttests := []struct {\n\t\tc Context\n\t\ts string\n\t}{\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tHeader: http.Header{HeaderXForwardedFor: []string{\"127.0.0.1, 127.0.1.1, \"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"127.0.0.1\",\n\t\t},\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tHeader: http.Header{HeaderXForwardedFor: []string{\"127.0.0.1,127.0.1.1\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"127.0.0.1\",\n\t\t},\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tHeader: http.Header{HeaderXForwardedFor: []string{\"127.0.0.1\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"127.0.0.1\",\n\t\t},\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tHeader: http.Header{HeaderXForwardedFor: []string{\"[2001:db8:85a3:8d3:1319:8a2e:370:7348], 2001:db8::1, \"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"2001:db8:85a3:8d3:1319:8a2e:370:7348\",\n\t\t},\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tHeader: http.Header{HeaderXForwardedFor: []string{\"[2001:db8:85a3:8d3:1319:8a2e:370:7348],[2001:db8::1]\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"2001:db8:85a3:8d3:1319:8a2e:370:7348\",\n\t\t},\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tHeader: http.Header{HeaderXForwardedFor: []string{\"2001:db8:85a3:8d3:1319:8a2e:370:7348\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"2001:db8:85a3:8d3:1319:8a2e:370:7348\",\n\t\t},\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\t\"X-Real-Ip\": []string{\"192.168.0.1\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"192.168.0.1\",\n\t\t},\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tHeader: http.Header{\n\t\t\t\t\t\t\"X-Real-Ip\": []string{\"[2001:db8::1]\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"2001:db8::1\",\n\t\t},\n\n\t\t{\n\t\t\t&context{\n\t\t\t\trequest: &http.Request{\n\t\t\t\t\tRemoteAddr: \"89.89.89.89:1654\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"89.89.89.89\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tassert.Equal(t, tt.s, tt.c.RealIP())\n\t}\n}\n"
        },
        {
          "name": "echo.go",
          "type": "blob",
          "size": 34.4677734375,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\n/*\nPackage echo implements high performance, minimalist Go web framework.\n\nExample:\n\n\tpackage main\n\n\timport (\n\t  \"net/http\"\n\n\t  \"github.com/labstack/echo/v4\"\n\t  \"github.com/labstack/echo/v4/middleware\"\n\t)\n\n\t// Handler\n\tfunc hello(c echo.Context) error {\n\t  return c.String(http.StatusOK, \"Hello, World!\")\n\t}\n\n\tfunc main() {\n\t  // Echo instance\n\t  e := echo.New()\n\n\t  // Middleware\n\t  e.Use(middleware.Logger())\n\t  e.Use(middleware.Recover())\n\n\t  // Routes\n\t  e.GET(\"/\", hello)\n\n\t  // Start server\n\t  e.Logger.Fatal(e.Start(\":1323\"))\n\t}\n\nLearn more at https://echo.labstack.com\n*/\npackage echo\n\nimport (\n\tstdContext \"context\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\tstdLog \"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/labstack/gommon/color\"\n\t\"github.com/labstack/gommon/log\"\n\t\"golang.org/x/crypto/acme\"\n\t\"golang.org/x/crypto/acme/autocert\"\n\t\"golang.org/x/net/http2\"\n\t\"golang.org/x/net/http2/h2c\"\n)\n\n// Echo is the top-level framework instance.\n//\n// Goroutine safety: Do not mutate Echo instance fields after server has started. Accessing these\n// fields from handlers/middlewares and changing field values at the same time leads to data-races.\n// Adding new routes after the server has been started is also not safe!\ntype Echo struct {\n\tfilesystem\n\tcommon\n\t// startupMutex is mutex to lock Echo instance access during server configuration and startup. Useful for to get\n\t// listener address info (on which interface/port was listener bound) without having data races.\n\tstartupMutex sync.RWMutex\n\tcolorer      *color.Color\n\n\t// premiddleware are middlewares that are run before routing is done. In case a pre-middleware returns\n\t// an error the router is not executed and the request will end up in the global error handler.\n\tpremiddleware []MiddlewareFunc\n\tmiddleware    []MiddlewareFunc\n\tmaxParam      *int\n\trouter        *Router\n\trouters       map[string]*Router\n\tpool          sync.Pool\n\n\tStdLogger        *stdLog.Logger\n\tServer           *http.Server\n\tTLSServer        *http.Server\n\tListener         net.Listener\n\tTLSListener      net.Listener\n\tAutoTLSManager   autocert.Manager\n\tHTTPErrorHandler HTTPErrorHandler\n\tBinder           Binder\n\tJSONSerializer   JSONSerializer\n\tValidator        Validator\n\tRenderer         Renderer\n\tLogger           Logger\n\tIPExtractor      IPExtractor\n\tListenerNetwork  string\n\n\t// OnAddRouteHandler is called when Echo adds new route to specific host router.\n\tOnAddRouteHandler func(host string, route Route, handler HandlerFunc, middleware []MiddlewareFunc)\n\tDisableHTTP2      bool\n\tDebug             bool\n\tHideBanner        bool\n\tHidePort          bool\n}\n\n// Route contains a handler and information for matching against requests.\ntype Route struct {\n\tMethod string `json:\"method\"`\n\tPath   string `json:\"path\"`\n\tName   string `json:\"name\"`\n}\n\n// HTTPError represents an error that occurred while handling a request.\ntype HTTPError struct {\n\tInternal error       `json:\"-\"` // Stores the error returned by an external dependency\n\tMessage  interface{} `json:\"message\"`\n\tCode     int         `json:\"-\"`\n}\n\n// MiddlewareFunc defines a function to process middleware.\ntype MiddlewareFunc func(next HandlerFunc) HandlerFunc\n\n// HandlerFunc defines a function to serve HTTP requests.\ntype HandlerFunc func(c Context) error\n\n// HTTPErrorHandler is a centralized HTTP error handler.\ntype HTTPErrorHandler func(err error, c Context)\n\n// Validator is the interface that wraps the Validate function.\ntype Validator interface {\n\tValidate(i interface{}) error\n}\n\n// JSONSerializer is the interface that encodes and decodes JSON to and from interfaces.\ntype JSONSerializer interface {\n\tSerialize(c Context, i interface{}, indent string) error\n\tDeserialize(c Context, i interface{}) error\n}\n\n// Map defines a generic map of type `map[string]interface{}`.\ntype Map map[string]interface{}\n\n// Common struct for Echo & Group.\ntype common struct{}\n\n// HTTP methods\n// NOTE: Deprecated, please use the stdlib constants directly instead.\nconst (\n\tCONNECT = http.MethodConnect\n\tDELETE  = http.MethodDelete\n\tGET     = http.MethodGet\n\tHEAD    = http.MethodHead\n\tOPTIONS = http.MethodOptions\n\tPATCH   = http.MethodPatch\n\tPOST    = http.MethodPost\n\t// PROPFIND = \"PROPFIND\"\n\tPUT   = http.MethodPut\n\tTRACE = http.MethodTrace\n)\n\n// MIME types\nconst (\n\t// MIMEApplicationJSON JavaScript Object Notation (JSON) https://www.rfc-editor.org/rfc/rfc8259\n\tMIMEApplicationJSON = \"application/json\"\n\t// Deprecated: Please use MIMEApplicationJSON instead. JSON should be encoded using UTF-8 by default.\n\t// No \"charset\" parameter is defined for this registration.\n\t// Adding one really has no effect on compliant recipients.\n\t// See RFC 8259, section 8.1. https://datatracker.ietf.org/doc/html/rfc8259#section-8.1\n\tMIMEApplicationJSONCharsetUTF8       = MIMEApplicationJSON + \"; \" + charsetUTF8\n\tMIMEApplicationJavaScript            = \"application/javascript\"\n\tMIMEApplicationJavaScriptCharsetUTF8 = MIMEApplicationJavaScript + \"; \" + charsetUTF8\n\tMIMEApplicationXML                   = \"application/xml\"\n\tMIMEApplicationXMLCharsetUTF8        = MIMEApplicationXML + \"; \" + charsetUTF8\n\tMIMETextXML                          = \"text/xml\"\n\tMIMETextXMLCharsetUTF8               = MIMETextXML + \"; \" + charsetUTF8\n\tMIMEApplicationForm                  = \"application/x-www-form-urlencoded\"\n\tMIMEApplicationProtobuf              = \"application/protobuf\"\n\tMIMEApplicationMsgpack               = \"application/msgpack\"\n\tMIMETextHTML                         = \"text/html\"\n\tMIMETextHTMLCharsetUTF8              = MIMETextHTML + \"; \" + charsetUTF8\n\tMIMETextPlain                        = \"text/plain\"\n\tMIMETextPlainCharsetUTF8             = MIMETextPlain + \"; \" + charsetUTF8\n\tMIMEMultipartForm                    = \"multipart/form-data\"\n\tMIMEOctetStream                      = \"application/octet-stream\"\n)\n\nconst (\n\tcharsetUTF8 = \"charset=UTF-8\"\n\t// PROPFIND Method can be used on collection and property resources.\n\tPROPFIND = \"PROPFIND\"\n\t// REPORT Method can be used to get information about a resource, see rfc 3253\n\tREPORT = \"REPORT\"\n\t// RouteNotFound is special method type for routes handling \"route not found\" (404) cases\n\tRouteNotFound = \"echo_route_not_found\"\n)\n\n// Headers\nconst (\n\tHeaderAccept         = \"Accept\"\n\tHeaderAcceptEncoding = \"Accept-Encoding\"\n\t// HeaderAllow is the name of the \"Allow\" header field used to list the set of methods\n\t// advertised as supported by the target resource. Returning an Allow header is mandatory\n\t// for status 405 (method not found) and useful for the OPTIONS method in responses.\n\t// See RFC 7231: https://datatracker.ietf.org/doc/html/rfc7231#section-7.4.1\n\tHeaderAllow               = \"Allow\"\n\tHeaderAuthorization       = \"Authorization\"\n\tHeaderContentDisposition  = \"Content-Disposition\"\n\tHeaderContentEncoding     = \"Content-Encoding\"\n\tHeaderContentLength       = \"Content-Length\"\n\tHeaderContentType         = \"Content-Type\"\n\tHeaderCookie              = \"Cookie\"\n\tHeaderSetCookie           = \"Set-Cookie\"\n\tHeaderIfModifiedSince     = \"If-Modified-Since\"\n\tHeaderLastModified        = \"Last-Modified\"\n\tHeaderLocation            = \"Location\"\n\tHeaderRetryAfter          = \"Retry-After\"\n\tHeaderUpgrade             = \"Upgrade\"\n\tHeaderVary                = \"Vary\"\n\tHeaderWWWAuthenticate     = \"WWW-Authenticate\"\n\tHeaderXForwardedFor       = \"X-Forwarded-For\"\n\tHeaderXForwardedProto     = \"X-Forwarded-Proto\"\n\tHeaderXForwardedProtocol  = \"X-Forwarded-Protocol\"\n\tHeaderXForwardedSsl       = \"X-Forwarded-Ssl\"\n\tHeaderXUrlScheme          = \"X-Url-Scheme\"\n\tHeaderXHTTPMethodOverride = \"X-HTTP-Method-Override\"\n\tHeaderXRealIP             = \"X-Real-Ip\"\n\tHeaderXRequestID          = \"X-Request-Id\"\n\tHeaderXCorrelationID      = \"X-Correlation-Id\"\n\tHeaderXRequestedWith      = \"X-Requested-With\"\n\tHeaderServer              = \"Server\"\n\tHeaderOrigin              = \"Origin\"\n\tHeaderCacheControl        = \"Cache-Control\"\n\tHeaderConnection          = \"Connection\"\n\n\t// Access control\n\tHeaderAccessControlRequestMethod    = \"Access-Control-Request-Method\"\n\tHeaderAccessControlRequestHeaders   = \"Access-Control-Request-Headers\"\n\tHeaderAccessControlAllowOrigin      = \"Access-Control-Allow-Origin\"\n\tHeaderAccessControlAllowMethods     = \"Access-Control-Allow-Methods\"\n\tHeaderAccessControlAllowHeaders     = \"Access-Control-Allow-Headers\"\n\tHeaderAccessControlAllowCredentials = \"Access-Control-Allow-Credentials\"\n\tHeaderAccessControlExposeHeaders    = \"Access-Control-Expose-Headers\"\n\tHeaderAccessControlMaxAge           = \"Access-Control-Max-Age\"\n\n\t// Security\n\tHeaderStrictTransportSecurity         = \"Strict-Transport-Security\"\n\tHeaderXContentTypeOptions             = \"X-Content-Type-Options\"\n\tHeaderXXSSProtection                  = \"X-XSS-Protection\"\n\tHeaderXFrameOptions                   = \"X-Frame-Options\"\n\tHeaderContentSecurityPolicy           = \"Content-Security-Policy\"\n\tHeaderContentSecurityPolicyReportOnly = \"Content-Security-Policy-Report-Only\"\n\tHeaderXCSRFToken                      = \"X-CSRF-Token\"\n\tHeaderReferrerPolicy                  = \"Referrer-Policy\"\n)\n\nconst (\n\t// Version of Echo\n\tVersion = \"4.13.3\"\n\twebsite = \"https://echo.labstack.com\"\n\t// http://patorjk.com/software/taag/#p=display&f=Small%20Slant&t=Echo\n\tbanner = `\n   ____    __\n  / __/___/ /  ___\n / _// __/ _ \\/ _ \\\n/___/\\__/_//_/\\___/ %s\nHigh performance, minimalist Go web framework\n%s\n____________________________________O/_______\n                                    O\\\n`\n)\n\nvar methods = [...]string{\n\thttp.MethodConnect,\n\thttp.MethodDelete,\n\thttp.MethodGet,\n\thttp.MethodHead,\n\thttp.MethodOptions,\n\thttp.MethodPatch,\n\thttp.MethodPost,\n\tPROPFIND,\n\thttp.MethodPut,\n\thttp.MethodTrace,\n\tREPORT,\n}\n\n// Errors\nvar (\n\tErrBadRequest                    = NewHTTPError(http.StatusBadRequest)                    // HTTP 400 Bad Request\n\tErrUnauthorized                  = NewHTTPError(http.StatusUnauthorized)                  // HTTP 401 Unauthorized\n\tErrPaymentRequired               = NewHTTPError(http.StatusPaymentRequired)               // HTTP 402 Payment Required\n\tErrForbidden                     = NewHTTPError(http.StatusForbidden)                     // HTTP 403 Forbidden\n\tErrNotFound                      = NewHTTPError(http.StatusNotFound)                      // HTTP 404 Not Found\n\tErrMethodNotAllowed              = NewHTTPError(http.StatusMethodNotAllowed)              // HTTP 405 Method Not Allowed\n\tErrNotAcceptable                 = NewHTTPError(http.StatusNotAcceptable)                 // HTTP 406 Not Acceptable\n\tErrProxyAuthRequired             = NewHTTPError(http.StatusProxyAuthRequired)             // HTTP 407 Proxy AuthRequired\n\tErrRequestTimeout                = NewHTTPError(http.StatusRequestTimeout)                // HTTP 408 Request Timeout\n\tErrConflict                      = NewHTTPError(http.StatusConflict)                      // HTTP 409 Conflict\n\tErrGone                          = NewHTTPError(http.StatusGone)                          // HTTP 410 Gone\n\tErrLengthRequired                = NewHTTPError(http.StatusLengthRequired)                // HTTP 411 Length Required\n\tErrPreconditionFailed            = NewHTTPError(http.StatusPreconditionFailed)            // HTTP 412 Precondition Failed\n\tErrStatusRequestEntityTooLarge   = NewHTTPError(http.StatusRequestEntityTooLarge)         // HTTP 413 Payload Too Large\n\tErrRequestURITooLong             = NewHTTPError(http.StatusRequestURITooLong)             // HTTP 414 URI Too Long\n\tErrUnsupportedMediaType          = NewHTTPError(http.StatusUnsupportedMediaType)          // HTTP 415 Unsupported Media Type\n\tErrRequestedRangeNotSatisfiable  = NewHTTPError(http.StatusRequestedRangeNotSatisfiable)  // HTTP 416 Range Not Satisfiable\n\tErrExpectationFailed             = NewHTTPError(http.StatusExpectationFailed)             // HTTP 417 Expectation Failed\n\tErrTeapot                        = NewHTTPError(http.StatusTeapot)                        // HTTP 418 I'm a teapot\n\tErrMisdirectedRequest            = NewHTTPError(http.StatusMisdirectedRequest)            // HTTP 421 Misdirected Request\n\tErrUnprocessableEntity           = NewHTTPError(http.StatusUnprocessableEntity)           // HTTP 422 Unprocessable Entity\n\tErrLocked                        = NewHTTPError(http.StatusLocked)                        // HTTP 423 Locked\n\tErrFailedDependency              = NewHTTPError(http.StatusFailedDependency)              // HTTP 424 Failed Dependency\n\tErrTooEarly                      = NewHTTPError(http.StatusTooEarly)                      // HTTP 425 Too Early\n\tErrUpgradeRequired               = NewHTTPError(http.StatusUpgradeRequired)               // HTTP 426 Upgrade Required\n\tErrPreconditionRequired          = NewHTTPError(http.StatusPreconditionRequired)          // HTTP 428 Precondition Required\n\tErrTooManyRequests               = NewHTTPError(http.StatusTooManyRequests)               // HTTP 429 Too Many Requests\n\tErrRequestHeaderFieldsTooLarge   = NewHTTPError(http.StatusRequestHeaderFieldsTooLarge)   // HTTP 431 Request Header Fields Too Large\n\tErrUnavailableForLegalReasons    = NewHTTPError(http.StatusUnavailableForLegalReasons)    // HTTP 451 Unavailable For Legal Reasons\n\tErrInternalServerError           = NewHTTPError(http.StatusInternalServerError)           // HTTP 500 Internal Server Error\n\tErrNotImplemented                = NewHTTPError(http.StatusNotImplemented)                // HTTP 501 Not Implemented\n\tErrBadGateway                    = NewHTTPError(http.StatusBadGateway)                    // HTTP 502 Bad Gateway\n\tErrServiceUnavailable            = NewHTTPError(http.StatusServiceUnavailable)            // HTTP 503 Service Unavailable\n\tErrGatewayTimeout                = NewHTTPError(http.StatusGatewayTimeout)                // HTTP 504 Gateway Timeout\n\tErrHTTPVersionNotSupported       = NewHTTPError(http.StatusHTTPVersionNotSupported)       // HTTP 505 HTTP Version Not Supported\n\tErrVariantAlsoNegotiates         = NewHTTPError(http.StatusVariantAlsoNegotiates)         // HTTP 506 Variant Also Negotiates\n\tErrInsufficientStorage           = NewHTTPError(http.StatusInsufficientStorage)           // HTTP 507 Insufficient Storage\n\tErrLoopDetected                  = NewHTTPError(http.StatusLoopDetected)                  // HTTP 508 Loop Detected\n\tErrNotExtended                   = NewHTTPError(http.StatusNotExtended)                   // HTTP 510 Not Extended\n\tErrNetworkAuthenticationRequired = NewHTTPError(http.StatusNetworkAuthenticationRequired) // HTTP 511 Network Authentication Required\n\n\tErrValidatorNotRegistered = errors.New(\"validator not registered\")\n\tErrRendererNotRegistered  = errors.New(\"renderer not registered\")\n\tErrInvalidRedirectCode    = errors.New(\"invalid redirect status code\")\n\tErrCookieNotFound         = errors.New(\"cookie not found\")\n\tErrInvalidCertOrKeyType   = errors.New(\"invalid cert or key type, must be string or []byte\")\n\tErrInvalidListenerNetwork = errors.New(\"invalid listener network\")\n)\n\n// NotFoundHandler is the handler that router uses in case there was no matching route found. Returns an error that results\n// HTTP 404 status code.\nvar NotFoundHandler = func(c Context) error {\n\treturn ErrNotFound\n}\n\n// MethodNotAllowedHandler is the handler thar router uses in case there was no matching route found but there was\n// another matching routes for that requested URL. Returns an error that results HTTP 405 Method Not Allowed status code.\nvar MethodNotAllowedHandler = func(c Context) error {\n\t// See RFC 7231 section 7.4.1: An origin server MUST generate an Allow field in a 405 (Method Not Allowed)\n\t// response and MAY do so in any other response. For disabled resources an empty Allow header may be returned\n\trouterAllowMethods, ok := c.Get(ContextKeyHeaderAllow).(string)\n\tif ok && routerAllowMethods != \"\" {\n\t\tc.Response().Header().Set(HeaderAllow, routerAllowMethods)\n\t}\n\treturn ErrMethodNotAllowed\n}\n\n// New creates an instance of Echo.\nfunc New() (e *Echo) {\n\te = &Echo{\n\t\tfilesystem: createFilesystem(),\n\t\tServer:     new(http.Server),\n\t\tTLSServer:  new(http.Server),\n\t\tAutoTLSManager: autocert.Manager{\n\t\t\tPrompt: autocert.AcceptTOS,\n\t\t},\n\t\tLogger:          log.New(\"echo\"),\n\t\tcolorer:         color.New(),\n\t\tmaxParam:        new(int),\n\t\tListenerNetwork: \"tcp\",\n\t}\n\te.Server.Handler = e\n\te.TLSServer.Handler = e\n\te.HTTPErrorHandler = e.DefaultHTTPErrorHandler\n\te.Binder = &DefaultBinder{}\n\te.JSONSerializer = &DefaultJSONSerializer{}\n\te.Logger.SetLevel(log.ERROR)\n\te.StdLogger = stdLog.New(e.Logger.Output(), e.Logger.Prefix()+\": \", 0)\n\te.pool.New = func() interface{} {\n\t\treturn e.NewContext(nil, nil)\n\t}\n\te.router = NewRouter(e)\n\te.routers = map[string]*Router{}\n\treturn\n}\n\n// NewContext returns a Context instance.\nfunc (e *Echo) NewContext(r *http.Request, w http.ResponseWriter) Context {\n\treturn &context{\n\t\trequest:  r,\n\t\tresponse: NewResponse(w, e),\n\t\tstore:    make(Map),\n\t\techo:     e,\n\t\tpvalues:  make([]string, *e.maxParam),\n\t\thandler:  NotFoundHandler,\n\t}\n}\n\n// Router returns the default router.\nfunc (e *Echo) Router() *Router {\n\treturn e.router\n}\n\n// Routers returns the map of host => router.\nfunc (e *Echo) Routers() map[string]*Router {\n\treturn e.routers\n}\n\n// DefaultHTTPErrorHandler is the default HTTP error handler. It sends a JSON response\n// with status code.\n//\n// NOTE: In case errors happens in middleware call-chain that is returning from handler (which did not return an error).\n// When handler has already sent response (ala c.JSON()) and there is error in middleware that is returning from\n// handler. Then the error that global error handler received will be ignored because we have already \"committed\" the\n// response and status code header has been sent to the client.\nfunc (e *Echo) DefaultHTTPErrorHandler(err error, c Context) {\n\n\tif c.Response().Committed {\n\t\treturn\n\t}\n\n\the, ok := err.(*HTTPError)\n\tif ok {\n\t\tif he.Internal != nil {\n\t\t\tif herr, ok := he.Internal.(*HTTPError); ok {\n\t\t\t\the = herr\n\t\t\t}\n\t\t}\n\t} else {\n\t\the = &HTTPError{\n\t\t\tCode:    http.StatusInternalServerError,\n\t\t\tMessage: http.StatusText(http.StatusInternalServerError),\n\t\t}\n\t}\n\n\t// Issue #1426\n\tcode := he.Code\n\tmessage := he.Message\n\n\tswitch m := he.Message.(type) {\n\tcase string:\n\t\tif e.Debug {\n\t\t\tmessage = Map{\"message\": m, \"error\": err.Error()}\n\t\t} else {\n\t\t\tmessage = Map{\"message\": m}\n\t\t}\n\tcase json.Marshaler:\n\t\t// do nothing - this type knows how to format itself to JSON\n\tcase error:\n\t\tmessage = Map{\"message\": m.Error()}\n\t}\n\n\t// Send response\n\tif c.Request().Method == http.MethodHead { // Issue #608\n\t\terr = c.NoContent(he.Code)\n\t} else {\n\t\terr = c.JSON(code, message)\n\t}\n\tif err != nil {\n\t\te.Logger.Error(err)\n\t}\n}\n\n// Pre adds middleware to the chain which is run before router.\nfunc (e *Echo) Pre(middleware ...MiddlewareFunc) {\n\te.premiddleware = append(e.premiddleware, middleware...)\n}\n\n// Use adds middleware to the chain which is run after router.\nfunc (e *Echo) Use(middleware ...MiddlewareFunc) {\n\te.middleware = append(e.middleware, middleware...)\n}\n\n// CONNECT registers a new CONNECT route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) CONNECT(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodConnect, path, h, m...)\n}\n\n// DELETE registers a new DELETE route for a path with matching handler in the router\n// with optional route-level middleware.\nfunc (e *Echo) DELETE(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodDelete, path, h, m...)\n}\n\n// GET registers a new GET route for a path with matching handler in the router\n// with optional route-level middleware.\nfunc (e *Echo) GET(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodGet, path, h, m...)\n}\n\n// HEAD registers a new HEAD route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) HEAD(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodHead, path, h, m...)\n}\n\n// OPTIONS registers a new OPTIONS route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) OPTIONS(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodOptions, path, h, m...)\n}\n\n// PATCH registers a new PATCH route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) PATCH(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodPatch, path, h, m...)\n}\n\n// POST registers a new POST route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) POST(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodPost, path, h, m...)\n}\n\n// PUT registers a new PUT route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) PUT(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodPut, path, h, m...)\n}\n\n// TRACE registers a new TRACE route for a path with matching handler in the\n// router with optional route-level middleware.\nfunc (e *Echo) TRACE(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(http.MethodTrace, path, h, m...)\n}\n\n// RouteNotFound registers a special-case route which is executed when no other route is found (i.e. HTTP 404 cases)\n// for current request URL.\n// Path supports static and named/any parameters just like other http method is defined. Generally path is ended with\n// wildcard/match-any character (`/*`, `/download/*` etc).\n//\n// Example: `e.RouteNotFound(\"/*\", func(c echo.Context) error { return c.NoContent(http.StatusNotFound) })`\nfunc (e *Echo) RouteNotFound(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn e.Add(RouteNotFound, path, h, m...)\n}\n\n// Any registers a new route for all HTTP methods (supported by Echo) and path with matching handler\n// in the router with optional route-level middleware.\n//\n// Note: this method only adds specific set of supported HTTP methods as handler and is not true\n// \"catch-any-arbitrary-method\" way of matching requests.\nfunc (e *Echo) Any(path string, handler HandlerFunc, middleware ...MiddlewareFunc) []*Route {\n\troutes := make([]*Route, len(methods))\n\tfor i, m := range methods {\n\t\troutes[i] = e.Add(m, path, handler, middleware...)\n\t}\n\treturn routes\n}\n\n// Match registers a new route for multiple HTTP methods and path with matching\n// handler in the router with optional route-level middleware.\nfunc (e *Echo) Match(methods []string, path string, handler HandlerFunc, middleware ...MiddlewareFunc) []*Route {\n\troutes := make([]*Route, len(methods))\n\tfor i, m := range methods {\n\t\troutes[i] = e.Add(m, path, handler, middleware...)\n\t}\n\treturn routes\n}\n\nfunc (common) file(path, file string, get func(string, HandlerFunc, ...MiddlewareFunc) *Route,\n\tm ...MiddlewareFunc) *Route {\n\treturn get(path, func(c Context) error {\n\t\treturn c.File(file)\n\t}, m...)\n}\n\n// File registers a new route with path to serve a static file with optional route-level middleware.\nfunc (e *Echo) File(path, file string, m ...MiddlewareFunc) *Route {\n\treturn e.file(path, file, e.GET, m...)\n}\n\nfunc (e *Echo) add(host, method, path string, handler HandlerFunc, middlewares ...MiddlewareFunc) *Route {\n\trouter := e.findRouter(host)\n\t//FIXME: when handler+middleware are both nil ... make it behave like handler removal\n\tname := handlerName(handler)\n\troute := router.add(method, path, name, func(c Context) error {\n\t\th := applyMiddleware(handler, middlewares...)\n\t\treturn h(c)\n\t})\n\n\tif e.OnAddRouteHandler != nil {\n\t\te.OnAddRouteHandler(host, *route, handler, middlewares)\n\t}\n\n\treturn route\n}\n\n// Add registers a new route for an HTTP method and path with matching handler\n// in the router with optional route-level middleware.\nfunc (e *Echo) Add(method, path string, handler HandlerFunc, middleware ...MiddlewareFunc) *Route {\n\treturn e.add(\"\", method, path, handler, middleware...)\n}\n\n// Host creates a new router group for the provided host and optional host-level middleware.\nfunc (e *Echo) Host(name string, m ...MiddlewareFunc) (g *Group) {\n\te.routers[name] = NewRouter(e)\n\tg = &Group{host: name, echo: e}\n\tg.Use(m...)\n\treturn\n}\n\n// Group creates a new router group with prefix and optional group-level middleware.\nfunc (e *Echo) Group(prefix string, m ...MiddlewareFunc) (g *Group) {\n\tg = &Group{prefix: prefix, echo: e}\n\tg.Use(m...)\n\treturn\n}\n\n// URI generates an URI from handler.\nfunc (e *Echo) URI(handler HandlerFunc, params ...interface{}) string {\n\tname := handlerName(handler)\n\treturn e.Reverse(name, params...)\n}\n\n// URL is an alias for `URI` function.\nfunc (e *Echo) URL(h HandlerFunc, params ...interface{}) string {\n\treturn e.URI(h, params...)\n}\n\n// Reverse generates a URL from route name and provided parameters.\nfunc (e *Echo) Reverse(name string, params ...interface{}) string {\n\treturn e.router.Reverse(name, params...)\n}\n\n// Routes returns the registered routes for default router.\n// In case when Echo serves multiple hosts/domains use `e.Routers()[\"domain2.site\"].Routes()` to get specific host routes.\nfunc (e *Echo) Routes() []*Route {\n\treturn e.router.Routes()\n}\n\n// AcquireContext returns an empty `Context` instance from the pool.\n// You must return the context by calling `ReleaseContext()`.\nfunc (e *Echo) AcquireContext() Context {\n\treturn e.pool.Get().(Context)\n}\n\n// ReleaseContext returns the `Context` instance back to the pool.\n// You must call it after `AcquireContext()`.\nfunc (e *Echo) ReleaseContext(c Context) {\n\te.pool.Put(c)\n}\n\n// ServeHTTP implements `http.Handler` interface, which serves HTTP requests.\nfunc (e *Echo) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Acquire context\n\tc := e.pool.Get().(*context)\n\tc.Reset(r, w)\n\tvar h HandlerFunc\n\n\tif e.premiddleware == nil {\n\t\te.findRouter(r.Host).Find(r.Method, GetPath(r), c)\n\t\th = c.Handler()\n\t\th = applyMiddleware(h, e.middleware...)\n\t} else {\n\t\th = func(c Context) error {\n\t\t\te.findRouter(r.Host).Find(r.Method, GetPath(r), c)\n\t\t\th := c.Handler()\n\t\t\th = applyMiddleware(h, e.middleware...)\n\t\t\treturn h(c)\n\t\t}\n\t\th = applyMiddleware(h, e.premiddleware...)\n\t}\n\n\t// Execute chain\n\tif err := h(c); err != nil {\n\t\te.HTTPErrorHandler(err, c)\n\t}\n\n\t// Release context\n\te.pool.Put(c)\n}\n\n// Start starts an HTTP server.\nfunc (e *Echo) Start(address string) error {\n\te.startupMutex.Lock()\n\te.Server.Addr = address\n\tif err := e.configureServer(e.Server); err != nil {\n\t\te.startupMutex.Unlock()\n\t\treturn err\n\t}\n\te.startupMutex.Unlock()\n\treturn e.Server.Serve(e.Listener)\n}\n\n// StartTLS starts an HTTPS server.\n// If `certFile` or `keyFile` is `string` the values are treated as file paths.\n// If `certFile` or `keyFile` is `[]byte` the values are treated as the certificate or key as-is.\nfunc (e *Echo) StartTLS(address string, certFile, keyFile interface{}) (err error) {\n\te.startupMutex.Lock()\n\tvar cert []byte\n\tif cert, err = filepathOrContent(certFile); err != nil {\n\t\te.startupMutex.Unlock()\n\t\treturn\n\t}\n\n\tvar key []byte\n\tif key, err = filepathOrContent(keyFile); err != nil {\n\t\te.startupMutex.Unlock()\n\t\treturn\n\t}\n\n\ts := e.TLSServer\n\ts.TLSConfig = new(tls.Config)\n\ts.TLSConfig.Certificates = make([]tls.Certificate, 1)\n\tif s.TLSConfig.Certificates[0], err = tls.X509KeyPair(cert, key); err != nil {\n\t\te.startupMutex.Unlock()\n\t\treturn\n\t}\n\n\te.configureTLS(address)\n\tif err := e.configureServer(s); err != nil {\n\t\te.startupMutex.Unlock()\n\t\treturn err\n\t}\n\te.startupMutex.Unlock()\n\treturn s.Serve(e.TLSListener)\n}\n\nfunc filepathOrContent(fileOrContent interface{}) (content []byte, err error) {\n\tswitch v := fileOrContent.(type) {\n\tcase string:\n\t\treturn os.ReadFile(v)\n\tcase []byte:\n\t\treturn v, nil\n\tdefault:\n\t\treturn nil, ErrInvalidCertOrKeyType\n\t}\n}\n\n// StartAutoTLS starts an HTTPS server using certificates automatically installed from https://letsencrypt.org.\nfunc (e *Echo) StartAutoTLS(address string) error {\n\te.startupMutex.Lock()\n\ts := e.TLSServer\n\ts.TLSConfig = new(tls.Config)\n\ts.TLSConfig.GetCertificate = e.AutoTLSManager.GetCertificate\n\ts.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, acme.ALPNProto)\n\n\te.configureTLS(address)\n\tif err := e.configureServer(s); err != nil {\n\t\te.startupMutex.Unlock()\n\t\treturn err\n\t}\n\te.startupMutex.Unlock()\n\treturn s.Serve(e.TLSListener)\n}\n\nfunc (e *Echo) configureTLS(address string) {\n\ts := e.TLSServer\n\ts.Addr = address\n\tif !e.DisableHTTP2 {\n\t\ts.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, \"h2\")\n\t}\n}\n\n// StartServer starts a custom http server.\nfunc (e *Echo) StartServer(s *http.Server) (err error) {\n\te.startupMutex.Lock()\n\tif err := e.configureServer(s); err != nil {\n\t\te.startupMutex.Unlock()\n\t\treturn err\n\t}\n\tif s.TLSConfig != nil {\n\t\te.startupMutex.Unlock()\n\t\treturn s.Serve(e.TLSListener)\n\t}\n\te.startupMutex.Unlock()\n\treturn s.Serve(e.Listener)\n}\n\nfunc (e *Echo) configureServer(s *http.Server) error {\n\t// Setup\n\te.colorer.SetOutput(e.Logger.Output())\n\ts.ErrorLog = e.StdLogger\n\ts.Handler = e\n\tif e.Debug {\n\t\te.Logger.SetLevel(log.DEBUG)\n\t}\n\n\tif !e.HideBanner {\n\t\te.colorer.Printf(banner, e.colorer.Red(\"v\"+Version), e.colorer.Blue(website))\n\t}\n\n\tif s.TLSConfig == nil {\n\t\tif e.Listener == nil {\n\t\t\tl, err := newListener(s.Addr, e.ListenerNetwork)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\te.Listener = l\n\t\t}\n\t\tif !e.HidePort {\n\t\t\te.colorer.Printf(\"⇨ http server started on %s\\n\", e.colorer.Green(e.Listener.Addr()))\n\t\t}\n\t\treturn nil\n\t}\n\tif e.TLSListener == nil {\n\t\tl, err := newListener(s.Addr, e.ListenerNetwork)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\te.TLSListener = tls.NewListener(l, s.TLSConfig)\n\t}\n\tif !e.HidePort {\n\t\te.colorer.Printf(\"⇨ https server started on %s\\n\", e.colorer.Green(e.TLSListener.Addr()))\n\t}\n\treturn nil\n}\n\n// ListenerAddr returns net.Addr for Listener\nfunc (e *Echo) ListenerAddr() net.Addr {\n\te.startupMutex.RLock()\n\tdefer e.startupMutex.RUnlock()\n\tif e.Listener == nil {\n\t\treturn nil\n\t}\n\treturn e.Listener.Addr()\n}\n\n// TLSListenerAddr returns net.Addr for TLSListener\nfunc (e *Echo) TLSListenerAddr() net.Addr {\n\te.startupMutex.RLock()\n\tdefer e.startupMutex.RUnlock()\n\tif e.TLSListener == nil {\n\t\treturn nil\n\t}\n\treturn e.TLSListener.Addr()\n}\n\n// StartH2CServer starts a custom http/2 server with h2c (HTTP/2 Cleartext).\nfunc (e *Echo) StartH2CServer(address string, h2s *http2.Server) error {\n\te.startupMutex.Lock()\n\t// Setup\n\ts := e.Server\n\ts.Addr = address\n\te.colorer.SetOutput(e.Logger.Output())\n\ts.ErrorLog = e.StdLogger\n\ts.Handler = h2c.NewHandler(e, h2s)\n\tif e.Debug {\n\t\te.Logger.SetLevel(log.DEBUG)\n\t}\n\n\tif !e.HideBanner {\n\t\te.colorer.Printf(banner, e.colorer.Red(\"v\"+Version), e.colorer.Blue(website))\n\t}\n\n\tif e.Listener == nil {\n\t\tl, err := newListener(s.Addr, e.ListenerNetwork)\n\t\tif err != nil {\n\t\t\te.startupMutex.Unlock()\n\t\t\treturn err\n\t\t}\n\t\te.Listener = l\n\t}\n\tif !e.HidePort {\n\t\te.colorer.Printf(\"⇨ http server started on %s\\n\", e.colorer.Green(e.Listener.Addr()))\n\t}\n\te.startupMutex.Unlock()\n\treturn s.Serve(e.Listener)\n}\n\n// Close immediately stops the server.\n// It internally calls `http.Server#Close()`.\nfunc (e *Echo) Close() error {\n\te.startupMutex.Lock()\n\tdefer e.startupMutex.Unlock()\n\tif err := e.TLSServer.Close(); err != nil {\n\t\treturn err\n\t}\n\treturn e.Server.Close()\n}\n\n// Shutdown stops the server gracefully.\n// It internally calls `http.Server#Shutdown()`.\nfunc (e *Echo) Shutdown(ctx stdContext.Context) error {\n\te.startupMutex.Lock()\n\tdefer e.startupMutex.Unlock()\n\tif err := e.TLSServer.Shutdown(ctx); err != nil {\n\t\treturn err\n\t}\n\treturn e.Server.Shutdown(ctx)\n}\n\n// NewHTTPError creates a new HTTPError instance.\nfunc NewHTTPError(code int, message ...interface{}) *HTTPError {\n\the := &HTTPError{Code: code, Message: http.StatusText(code)}\n\tif len(message) > 0 {\n\t\the.Message = message[0]\n\t}\n\treturn he\n}\n\n// Error makes it compatible with `error` interface.\nfunc (he *HTTPError) Error() string {\n\tif he.Internal == nil {\n\t\treturn fmt.Sprintf(\"code=%d, message=%v\", he.Code, he.Message)\n\t}\n\treturn fmt.Sprintf(\"code=%d, message=%v, internal=%v\", he.Code, he.Message, he.Internal)\n}\n\n// SetInternal sets error to HTTPError.Internal\nfunc (he *HTTPError) SetInternal(err error) *HTTPError {\n\the.Internal = err\n\treturn he\n}\n\n// WithInternal returns clone of HTTPError with err set to HTTPError.Internal field\nfunc (he *HTTPError) WithInternal(err error) *HTTPError {\n\treturn &HTTPError{\n\t\tCode:     he.Code,\n\t\tMessage:  he.Message,\n\t\tInternal: err,\n\t}\n}\n\n// Unwrap satisfies the Go 1.13 error wrapper interface.\nfunc (he *HTTPError) Unwrap() error {\n\treturn he.Internal\n}\n\n// WrapHandler wraps `http.Handler` into `echo.HandlerFunc`.\nfunc WrapHandler(h http.Handler) HandlerFunc {\n\treturn func(c Context) error {\n\t\th.ServeHTTP(c.Response(), c.Request())\n\t\treturn nil\n\t}\n}\n\n// WrapMiddleware wraps `func(http.Handler) http.Handler` into `echo.MiddlewareFunc`\nfunc WrapMiddleware(m func(http.Handler) http.Handler) MiddlewareFunc {\n\treturn func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) (err error) {\n\t\t\tm(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tc.SetRequest(r)\n\t\t\t\tc.SetResponse(NewResponse(w, c.Echo()))\n\t\t\t\terr = next(c)\n\t\t\t})).ServeHTTP(c.Response(), c.Request())\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// GetPath returns RawPath, if it's empty returns Path from URL\n// Difference between RawPath and Path is:\n//   - Path is where request path is stored. Value is stored in decoded form: /%47%6f%2f becomes /Go/.\n//   - RawPath is an optional field which only gets set if the default encoding is different from Path.\nfunc GetPath(r *http.Request) string {\n\tpath := r.URL.RawPath\n\tif path == \"\" {\n\t\tpath = r.URL.Path\n\t}\n\treturn path\n}\n\nfunc (e *Echo) findRouter(host string) *Router {\n\tif len(e.routers) > 0 {\n\t\tif r, ok := e.routers[host]; ok {\n\t\t\treturn r\n\t\t}\n\t}\n\treturn e.router\n}\n\nfunc handlerName(h HandlerFunc) string {\n\tt := reflect.ValueOf(h).Type()\n\tif t.Kind() == reflect.Func {\n\t\treturn runtime.FuncForPC(reflect.ValueOf(h).Pointer()).Name()\n\t}\n\treturn t.String()\n}\n\n// // PathUnescape is wraps `url.PathUnescape`\n// func PathUnescape(s string) (string, error) {\n// \treturn url.PathUnescape(s)\n// }\n\n// tcpKeepAliveListener sets TCP keep-alive timeouts on accepted\n// connections. It's used by ListenAndServe and ListenAndServeTLS so\n// dead TCP connections (e.g. closing laptop mid-download) eventually\n// go away.\ntype tcpKeepAliveListener struct {\n\t*net.TCPListener\n}\n\nfunc (ln tcpKeepAliveListener) Accept() (c net.Conn, err error) {\n\tif c, err = ln.AcceptTCP(); err != nil {\n\t\treturn\n\t} else if err = c.(*net.TCPConn).SetKeepAlive(true); err != nil {\n\t\treturn\n\t}\n\t// Ignore error from setting the KeepAlivePeriod as some systems, such as\n\t// OpenBSD, do not support setting TCP_USER_TIMEOUT on IPPROTO_TCP\n\t_ = c.(*net.TCPConn).SetKeepAlivePeriod(3 * time.Minute)\n\treturn\n}\n\nfunc newListener(address, network string) (*tcpKeepAliveListener, error) {\n\tif network != \"tcp\" && network != \"tcp4\" && network != \"tcp6\" {\n\t\treturn nil, ErrInvalidListenerNetwork\n\t}\n\tl, err := net.Listen(network, address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &tcpKeepAliveListener{l.(*net.TCPListener)}, nil\n}\n\nfunc applyMiddleware(h HandlerFunc, middleware ...MiddlewareFunc) HandlerFunc {\n\tfor i := len(middleware) - 1; i >= 0; i-- {\n\t\th = middleware[i](h)\n\t}\n\treturn h\n}\n"
        },
        {
          "name": "echo_fs.go",
          "type": "blob",
          "size": 5.8544921875,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"fmt\"\n\t\"io/fs\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\ntype filesystem struct {\n\t// Filesystem is file system used by Static and File handlers to access files.\n\t// Defaults to os.DirFS(\".\")\n\t//\n\t// When dealing with `embed.FS` use `fs := echo.MustSubFS(fs, \"rootDirectory\") to create sub fs which uses necessary\n\t// prefix for directory path. This is necessary as `//go:embed assets/images` embeds files with paths\n\t// including `assets/images` as their prefix.\n\tFilesystem fs.FS\n}\n\nfunc createFilesystem() filesystem {\n\treturn filesystem{\n\t\tFilesystem: newDefaultFS(),\n\t}\n}\n\n// Static registers a new route with path prefix to serve static files from the provided root directory.\nfunc (e *Echo) Static(pathPrefix, fsRoot string) *Route {\n\tsubFs := MustSubFS(e.Filesystem, fsRoot)\n\treturn e.Add(\n\t\thttp.MethodGet,\n\t\tpathPrefix+\"*\",\n\t\tStaticDirectoryHandler(subFs, false),\n\t)\n}\n\n// StaticFS registers a new route with path prefix to serve static files from the provided file system.\n//\n// When dealing with `embed.FS` use `fs := echo.MustSubFS(fs, \"rootDirectory\") to create sub fs which uses necessary\n// prefix for directory path. This is necessary as `//go:embed assets/images` embeds files with paths\n// including `assets/images` as their prefix.\nfunc (e *Echo) StaticFS(pathPrefix string, filesystem fs.FS) *Route {\n\treturn e.Add(\n\t\thttp.MethodGet,\n\t\tpathPrefix+\"*\",\n\t\tStaticDirectoryHandler(filesystem, false),\n\t)\n}\n\n// StaticDirectoryHandler creates handler function to serve files from provided file system\n// When disablePathUnescaping is set then file name from path is not unescaped and is served as is.\nfunc StaticDirectoryHandler(fileSystem fs.FS, disablePathUnescaping bool) HandlerFunc {\n\treturn func(c Context) error {\n\t\tp := c.Param(\"*\")\n\t\tif !disablePathUnescaping { // when router is already unescaping we do not want to do is twice\n\t\t\ttmpPath, err := url.PathUnescape(p)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to unescape path variable: %w\", err)\n\t\t\t}\n\t\t\tp = tmpPath\n\t\t}\n\n\t\t// fs.FS.Open() already assumes that file names are relative to FS root path and considers name with prefix `/` as invalid\n\t\tname := filepath.ToSlash(filepath.Clean(strings.TrimPrefix(p, \"/\")))\n\t\tfi, err := fs.Stat(fileSystem, name)\n\t\tif err != nil {\n\t\t\treturn ErrNotFound\n\t\t}\n\n\t\t// If the request is for a directory and does not end with \"/\"\n\t\tp = c.Request().URL.Path // path must not be empty.\n\t\tif fi.IsDir() && len(p) > 0 && p[len(p)-1] != '/' {\n\t\t\t// Redirect to ends with \"/\"\n\t\t\treturn c.Redirect(http.StatusMovedPermanently, sanitizeURI(p+\"/\"))\n\t\t}\n\t\treturn fsFile(c, name, fileSystem)\n\t}\n}\n\n// FileFS registers a new route with path to serve file from the provided file system.\nfunc (e *Echo) FileFS(path, file string, filesystem fs.FS, m ...MiddlewareFunc) *Route {\n\treturn e.GET(path, StaticFileHandler(file, filesystem), m...)\n}\n\n// StaticFileHandler creates handler function to serve file from provided file system\nfunc StaticFileHandler(file string, filesystem fs.FS) HandlerFunc {\n\treturn func(c Context) error {\n\t\treturn fsFile(c, file, filesystem)\n\t}\n}\n\n// defaultFS exists to preserve pre v4.7.0 behaviour where files were open by `os.Open`.\n// v4.7 introduced `echo.Filesystem` field which is Go1.16+ `fs.Fs` interface.\n// Difference between `os.Open` and `fs.Open` is that FS does not allow opening path that start with `.`, `..` or `/`\n// etc. For example previously you could have `../images` in your application but `fs := os.DirFS(\"./\")` would not\n// allow you to use `fs.Open(\"../images\")` and this would break all old applications that rely on being able to\n// traverse up from current executable run path.\n// NB: private because you really should use fs.FS implementation instances\ntype defaultFS struct {\n\tfs     fs.FS\n\tprefix string\n}\n\nfunc newDefaultFS() *defaultFS {\n\tdir, _ := os.Getwd()\n\treturn &defaultFS{\n\t\tprefix: dir,\n\t\tfs:     nil,\n\t}\n}\n\nfunc (fs defaultFS) Open(name string) (fs.File, error) {\n\tif fs.fs == nil {\n\t\treturn os.Open(name)\n\t}\n\treturn fs.fs.Open(name)\n}\n\nfunc subFS(currentFs fs.FS, root string) (fs.FS, error) {\n\troot = filepath.ToSlash(filepath.Clean(root)) // note: fs.FS operates only with slashes. `ToSlash` is necessary for Windows\n\tif dFS, ok := currentFs.(*defaultFS); ok {\n\t\t// we need to make exception for `defaultFS` instances as it interprets root prefix differently from fs.FS.\n\t\t// fs.Fs.Open does not like relative paths (\"./\", \"../\") and absolute paths at all but prior echo.Filesystem we\n\t\t// were able to use paths like `./myfile.log`, `/etc/hosts` and these would work fine with `os.Open` but not with fs.Fs\n\t\tif !filepath.IsAbs(root) {\n\t\t\troot = filepath.Join(dFS.prefix, root)\n\t\t}\n\t\treturn &defaultFS{\n\t\t\tprefix: root,\n\t\t\tfs:     os.DirFS(root),\n\t\t}, nil\n\t}\n\treturn fs.Sub(currentFs, root)\n}\n\n// MustSubFS creates sub FS from current filesystem or panic on failure.\n// Panic happens when `fsRoot` contains invalid path according to `fs.ValidPath` rules.\n//\n// MustSubFS is helpful when dealing with `embed.FS` because for example `//go:embed assets/images` embeds files with\n// paths including `assets/images` as their prefix. In that case use `fs := echo.MustSubFS(fs, \"rootDirectory\") to\n// create sub fs which uses necessary prefix for directory path.\nfunc MustSubFS(currentFs fs.FS, fsRoot string) fs.FS {\n\tsubFs, err := subFS(currentFs, fsRoot)\n\tif err != nil {\n\t\tpanic(fmt.Errorf(\"can not create sub FS, invalid root given, err: %w\", err))\n\t}\n\treturn subFs\n}\n\nfunc sanitizeURI(uri string) string {\n\t// double slash `\\\\`, `//` or even `\\/` is absolute uri for browsers and by redirecting request to that uri\n\t// we are vulnerable to open redirect attack. so replace all slashes from the beginning with single slash\n\tif len(uri) > 1 && (uri[0] == '\\\\' || uri[0] == '/') && (uri[1] == '\\\\' || uri[1] == '/') {\n\t\turi = \"/\" + strings.TrimLeft(uri, `/\\`)\n\t}\n\treturn uri\n}\n"
        },
        {
          "name": "echo_fs_test.go",
          "type": "blob",
          "size": 8.0029296875,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"github.com/stretchr/testify/assert\"\n\t\"io/fs\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestEcho_StaticFS(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname                 string\n\t\tgivenPrefix          string\n\t\tgivenFs              fs.FS\n\t\tgivenFsRoot          string\n\t\twhenURL              string\n\t\texpectStatus         int\n\t\texpectHeaderLocation string\n\t\texpectBodyStartsWith string\n\t}{\n\t\t{\n\t\t\tname:                 \"ok\",\n\t\t\tgivenPrefix:          \"/images\",\n\t\t\tgivenFs:              os.DirFS(\"./_fixture/images\"),\n\t\t\twhenURL:              \"/images/walle.png\",\n\t\t\texpectStatus:         http.StatusOK,\n\t\t\texpectBodyStartsWith: string([]byte{0x89, 0x50, 0x4e, 0x47}),\n\t\t},\n\t\t{\n\t\t\tname:                 \"ok, from sub fs\",\n\t\t\tgivenPrefix:          \"/images\",\n\t\t\tgivenFs:              MustSubFS(os.DirFS(\"./_fixture/\"), \"images\"),\n\t\t\twhenURL:              \"/images/walle.png\",\n\t\t\texpectStatus:         http.StatusOK,\n\t\t\texpectBodyStartsWith: string([]byte{0x89, 0x50, 0x4e, 0x47}),\n\t\t},\n\t\t{\n\t\t\tname:                 \"No file\",\n\t\t\tgivenPrefix:          \"/images\",\n\t\t\tgivenFs:              os.DirFS(\"_fixture/scripts\"),\n\t\t\twhenURL:              \"/images/bolt.png\",\n\t\t\texpectStatus:         http.StatusNotFound,\n\t\t\texpectBodyStartsWith: \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Directory\",\n\t\t\tgivenPrefix:          \"/images\",\n\t\t\tgivenFs:              os.DirFS(\"_fixture/images\"),\n\t\t\twhenURL:              \"/images/\",\n\t\t\texpectStatus:         http.StatusNotFound,\n\t\t\texpectBodyStartsWith: \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Directory Redirect\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenFs:              os.DirFS(\"_fixture/\"),\n\t\t\twhenURL:              \"/folder\",\n\t\t\texpectStatus:         http.StatusMovedPermanently,\n\t\t\texpectHeaderLocation: \"/folder/\",\n\t\t\texpectBodyStartsWith: \"\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Directory Redirect with non-root path\",\n\t\t\tgivenPrefix:          \"/static\",\n\t\t\tgivenFs:              os.DirFS(\"_fixture\"),\n\t\t\twhenURL:              \"/static\",\n\t\t\texpectStatus:         http.StatusMovedPermanently,\n\t\t\texpectHeaderLocation: \"/static/\",\n\t\t\texpectBodyStartsWith: \"\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Prefixed directory 404 (request URL without slash)\",\n\t\t\tgivenPrefix:          \"/folder/\", // trailing slash will intentionally not match \"/folder\"\n\t\t\tgivenFs:              os.DirFS(\"_fixture\"),\n\t\t\twhenURL:              \"/folder\", // no trailing slash\n\t\t\texpectStatus:         http.StatusNotFound,\n\t\t\texpectBodyStartsWith: \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Prefixed directory redirect (without slash redirect to slash)\",\n\t\t\tgivenPrefix:          \"/folder\", // no trailing slash shall match /folder and /folder/*\n\t\t\tgivenFs:              os.DirFS(\"_fixture\"),\n\t\t\twhenURL:              \"/folder\", // no trailing slash\n\t\t\texpectStatus:         http.StatusMovedPermanently,\n\t\t\texpectHeaderLocation: \"/folder/\",\n\t\t\texpectBodyStartsWith: \"\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Directory with index.html\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenFs:              os.DirFS(\"_fixture\"),\n\t\t\twhenURL:              \"/\",\n\t\t\texpectStatus:         http.StatusOK,\n\t\t\texpectBodyStartsWith: \"<!doctype html>\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Prefixed directory with index.html (prefix ending with slash)\",\n\t\t\tgivenPrefix:          \"/assets/\",\n\t\t\tgivenFs:              os.DirFS(\"_fixture\"),\n\t\t\twhenURL:              \"/assets/\",\n\t\t\texpectStatus:         http.StatusOK,\n\t\t\texpectBodyStartsWith: \"<!doctype html>\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Prefixed directory with index.html (prefix ending without slash)\",\n\t\t\tgivenPrefix:          \"/assets\",\n\t\t\tgivenFs:              os.DirFS(\"_fixture\"),\n\t\t\twhenURL:              \"/assets/\",\n\t\t\texpectStatus:         http.StatusOK,\n\t\t\texpectBodyStartsWith: \"<!doctype html>\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Sub-directory with index.html\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenFs:              os.DirFS(\"_fixture\"),\n\t\t\twhenURL:              \"/folder/\",\n\t\t\texpectStatus:         http.StatusOK,\n\t\t\texpectBodyStartsWith: \"<!doctype html>\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"do not allow directory traversal (backslash - windows separator)\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenFs:              os.DirFS(\"_fixture/\"),\n\t\t\twhenURL:              `/..\\\\middleware/basic_auth.go`,\n\t\t\texpectStatus:         http.StatusNotFound,\n\t\t\texpectBodyStartsWith: \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"do not allow directory traversal (slash - unix separator)\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenFs:              os.DirFS(\"_fixture/\"),\n\t\t\twhenURL:              `/../middleware/basic_auth.go`,\n\t\t\texpectStatus:         http.StatusNotFound,\n\t\t\texpectBodyStartsWith: \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"open redirect vulnerability\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenFs:              os.DirFS(\"_fixture/\"),\n\t\t\twhenURL:              \"/open.redirect.hackercom%2f..\",\n\t\t\texpectStatus:         http.StatusMovedPermanently,\n\t\t\texpectHeaderLocation: \"/open.redirect.hackercom/../\", // location starting with `//open` would be very bad\n\t\t\texpectBodyStartsWith: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\n\t\t\ttmpFs := tc.givenFs\n\t\t\tif tc.givenFsRoot != \"\" {\n\t\t\t\ttmpFs = MustSubFS(tmpFs, tc.givenFsRoot)\n\t\t\t}\n\t\t\te.StaticFS(tc.givenPrefix, tmpFs)\n\n\t\t\treq := httptest.NewRequest(http.MethodGet, tc.whenURL, nil)\n\t\t\trec := httptest.NewRecorder()\n\n\t\t\te.ServeHTTP(rec, req)\n\n\t\t\tassert.Equal(t, tc.expectStatus, rec.Code)\n\t\t\tbody := rec.Body.String()\n\t\t\tif tc.expectBodyStartsWith != \"\" {\n\t\t\t\tassert.True(t, strings.HasPrefix(body, tc.expectBodyStartsWith))\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, \"\", body)\n\t\t\t}\n\n\t\t\tif tc.expectHeaderLocation != \"\" {\n\t\t\t\tassert.Equal(t, tc.expectHeaderLocation, rec.Result().Header[\"Location\"][0])\n\t\t\t} else {\n\t\t\t\t_, ok := rec.Result().Header[\"Location\"]\n\t\t\t\tassert.False(t, ok)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestEcho_FileFS(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname             string\n\t\twhenPath         string\n\t\twhenFile         string\n\t\twhenFS           fs.FS\n\t\tgivenURL         string\n\t\texpectCode       int\n\t\texpectStartsWith []byte\n\t}{\n\t\t{\n\t\t\tname:             \"ok\",\n\t\t\twhenPath:         \"/walle\",\n\t\t\twhenFS:           os.DirFS(\"_fixture/images\"),\n\t\t\twhenFile:         \"walle.png\",\n\t\t\tgivenURL:         \"/walle\",\n\t\t\texpectCode:       http.StatusOK,\n\t\t\texpectStartsWith: []byte{0x89, 0x50, 0x4e},\n\t\t},\n\t\t{\n\t\t\tname:             \"nok, requesting invalid path\",\n\t\t\twhenPath:         \"/walle\",\n\t\t\twhenFS:           os.DirFS(\"_fixture/images\"),\n\t\t\twhenFile:         \"walle.png\",\n\t\t\tgivenURL:         \"/walle.png\",\n\t\t\texpectCode:       http.StatusNotFound,\n\t\t\texpectStartsWith: []byte(`{\"message\":\"Not Found\"}`),\n\t\t},\n\t\t{\n\t\t\tname:             \"nok, serving not existent file from filesystem\",\n\t\t\twhenPath:         \"/walle\",\n\t\t\twhenFS:           os.DirFS(\"_fixture/images\"),\n\t\t\twhenFile:         \"not-existent.png\",\n\t\t\tgivenURL:         \"/walle\",\n\t\t\texpectCode:       http.StatusNotFound,\n\t\t\texpectStartsWith: []byte(`{\"message\":\"Not Found\"}`),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\te.FileFS(tc.whenPath, tc.whenFile, tc.whenFS)\n\n\t\t\treq := httptest.NewRequest(http.MethodGet, tc.givenURL, nil)\n\t\t\trec := httptest.NewRecorder()\n\n\t\t\te.ServeHTTP(rec, req)\n\n\t\t\tassert.Equal(t, tc.expectCode, rec.Code)\n\n\t\t\tbody := rec.Body.Bytes()\n\t\t\tif len(body) > len(tc.expectStartsWith) {\n\t\t\t\tbody = body[:len(tc.expectStartsWith)]\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectStartsWith, body)\n\t\t})\n\t}\n}\n\nfunc TestEcho_StaticPanic(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname      string\n\t\tgivenRoot string\n\t}{\n\t\t{\n\t\t\tname:      \"panics for ../\",\n\t\t\tgivenRoot: \"../assets\",\n\t\t},\n\t\t{\n\t\t\tname:      \"panics for /\",\n\t\t\tgivenRoot: \"/assets\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\te.Filesystem = os.DirFS(\"./\")\n\n\t\t\tassert.Panics(t, func() {\n\t\t\t\te.Static(\"../assets\", tc.givenRoot)\n\t\t\t})\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "echo_test.go",
          "type": "blob",
          "size": 47.19921875,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"bytes\"\n\tstdContext \"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"golang.org/x/net/http2\"\n)\n\ntype user struct {\n\tID   int    `json:\"id\" xml:\"id\" form:\"id\" query:\"id\" param:\"id\" header:\"id\"`\n\tName string `json:\"name\" xml:\"name\" form:\"name\" query:\"name\" param:\"name\" header:\"name\"`\n}\n\nconst (\n\tuserJSON                    = `{\"id\":1,\"name\":\"Jon Snow\"}`\n\tusersJSON                   = `[{\"id\":1,\"name\":\"Jon Snow\"}]`\n\tuserXML                     = `<user><id>1</id><name>Jon Snow</name></user>`\n\tuserForm                    = `id=1&name=Jon Snow`\n\tinvalidContent              = \"invalid content\"\n\tuserJSONInvalidType         = `{\"id\":\"1\",\"name\":\"Jon Snow\"}`\n\tuserXMLConvertNumberError   = `<user><id>Number one</id><name>Jon Snow</name></user>`\n\tuserXMLUnsupportedTypeError = `<user><>Number one</><name>Jon Snow</name></user>`\n)\n\nconst userJSONPretty = `{\n  \"id\": 1,\n  \"name\": \"Jon Snow\"\n}`\n\nconst userXMLPretty = `<user>\n  <id>1</id>\n  <name>Jon Snow</name>\n</user>`\n\nvar dummyQuery = url.Values{\"dummy\": []string{\"useless\"}}\n\nfunc TestEcho(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\n\t// Router\n\tassert.NotNil(t, e.Router())\n\n\t// DefaultHTTPErrorHandler\n\te.DefaultHTTPErrorHandler(errors.New(\"error\"), c)\n\tassert.Equal(t, http.StatusInternalServerError, rec.Code)\n}\n\nfunc TestEchoStatic(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname                 string\n\t\tgivenPrefix          string\n\t\tgivenRoot            string\n\t\twhenURL              string\n\t\texpectStatus         int\n\t\texpectHeaderLocation string\n\t\texpectBodyStartsWith string\n\t}{\n\t\t{\n\t\t\tname:                 \"ok\",\n\t\t\tgivenPrefix:          \"/images\",\n\t\t\tgivenRoot:            \"_fixture/images\",\n\t\t\twhenURL:              \"/images/walle.png\",\n\t\t\texpectStatus:         http.StatusOK,\n\t\t\texpectBodyStartsWith: string([]byte{0x89, 0x50, 0x4e, 0x47}),\n\t\t},\n\t\t{\n\t\t\tname:                 \"ok with relative path for root points to directory\",\n\t\t\tgivenPrefix:          \"/images\",\n\t\t\tgivenRoot:            \"./_fixture/images\",\n\t\t\twhenURL:              \"/images/walle.png\",\n\t\t\texpectStatus:         http.StatusOK,\n\t\t\texpectBodyStartsWith: string([]byte{0x89, 0x50, 0x4e, 0x47}),\n\t\t},\n\t\t{\n\t\t\tname:                 \"No file\",\n\t\t\tgivenPrefix:          \"/images\",\n\t\t\tgivenRoot:            \"_fixture/scripts\",\n\t\t\twhenURL:              \"/images/bolt.png\",\n\t\t\texpectStatus:         http.StatusNotFound,\n\t\t\texpectBodyStartsWith: \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Directory\",\n\t\t\tgivenPrefix:          \"/images\",\n\t\t\tgivenRoot:            \"_fixture/images\",\n\t\t\twhenURL:              \"/images/\",\n\t\t\texpectStatus:         http.StatusNotFound,\n\t\t\texpectBodyStartsWith: \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Directory Redirect\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenRoot:            \"_fixture\",\n\t\t\twhenURL:              \"/folder\",\n\t\t\texpectStatus:         http.StatusMovedPermanently,\n\t\t\texpectHeaderLocation: \"/folder/\",\n\t\t\texpectBodyStartsWith: \"\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Directory Redirect with non-root path\",\n\t\t\tgivenPrefix:          \"/static\",\n\t\t\tgivenRoot:            \"_fixture\",\n\t\t\twhenURL:              \"/static\",\n\t\t\texpectStatus:         http.StatusMovedPermanently,\n\t\t\texpectHeaderLocation: \"/static/\",\n\t\t\texpectBodyStartsWith: \"\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Prefixed directory 404 (request URL without slash)\",\n\t\t\tgivenPrefix:          \"/folder/\", // trailing slash will intentionally not match \"/folder\"\n\t\t\tgivenRoot:            \"_fixture\",\n\t\t\twhenURL:              \"/folder\", // no trailing slash\n\t\t\texpectStatus:         http.StatusNotFound,\n\t\t\texpectBodyStartsWith: \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Prefixed directory redirect (without slash redirect to slash)\",\n\t\t\tgivenPrefix:          \"/folder\", // no trailing slash shall match /folder and /folder/*\n\t\t\tgivenRoot:            \"_fixture\",\n\t\t\twhenURL:              \"/folder\", // no trailing slash\n\t\t\texpectStatus:         http.StatusMovedPermanently,\n\t\t\texpectHeaderLocation: \"/folder/\",\n\t\t\texpectBodyStartsWith: \"\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Directory with index.html\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenRoot:            \"_fixture\",\n\t\t\twhenURL:              \"/\",\n\t\t\texpectStatus:         http.StatusOK,\n\t\t\texpectBodyStartsWith: \"<!doctype html>\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Prefixed directory with index.html (prefix ending with slash)\",\n\t\t\tgivenPrefix:          \"/assets/\",\n\t\t\tgivenRoot:            \"_fixture\",\n\t\t\twhenURL:              \"/assets/\",\n\t\t\texpectStatus:         http.StatusOK,\n\t\t\texpectBodyStartsWith: \"<!doctype html>\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Prefixed directory with index.html (prefix ending without slash)\",\n\t\t\tgivenPrefix:          \"/assets\",\n\t\t\tgivenRoot:            \"_fixture\",\n\t\t\twhenURL:              \"/assets/\",\n\t\t\texpectStatus:         http.StatusOK,\n\t\t\texpectBodyStartsWith: \"<!doctype html>\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"Sub-directory with index.html\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenRoot:            \"_fixture\",\n\t\t\twhenURL:              \"/folder/\",\n\t\t\texpectStatus:         http.StatusOK,\n\t\t\texpectBodyStartsWith: \"<!doctype html>\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"do not allow directory traversal (backslash - windows separator)\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenRoot:            \"_fixture/\",\n\t\t\twhenURL:              `/..\\\\middleware/basic_auth.go`,\n\t\t\texpectStatus:         http.StatusNotFound,\n\t\t\texpectBodyStartsWith: \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:                 \"do not allow directory traversal (slash - unix separator)\",\n\t\t\tgivenPrefix:          \"/\",\n\t\t\tgivenRoot:            \"_fixture/\",\n\t\t\twhenURL:              `/../middleware/basic_auth.go`,\n\t\t\texpectStatus:         http.StatusNotFound,\n\t\t\texpectBodyStartsWith: \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\te.Static(tc.givenPrefix, tc.givenRoot)\n\t\t\treq := httptest.NewRequest(http.MethodGet, tc.whenURL, nil)\n\t\t\trec := httptest.NewRecorder()\n\t\t\te.ServeHTTP(rec, req)\n\t\t\tassert.Equal(t, tc.expectStatus, rec.Code)\n\t\t\tbody := rec.Body.String()\n\t\t\tif tc.expectBodyStartsWith != \"\" {\n\t\t\t\tassert.True(t, strings.HasPrefix(body, tc.expectBodyStartsWith))\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, \"\", body)\n\t\t\t}\n\n\t\t\tif tc.expectHeaderLocation != \"\" {\n\t\t\t\tassert.Equal(t, tc.expectHeaderLocation, rec.Result().Header[\"Location\"][0])\n\t\t\t} else {\n\t\t\t\t_, ok := rec.Result().Header[\"Location\"]\n\t\t\t\tassert.False(t, ok)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestEchoStaticRedirectIndex(t *testing.T) {\n\te := New()\n\n\t// HandlerFunc\n\te.Static(\"/static\", \"_fixture\")\n\n\terrCh := make(chan error)\n\n\tgo func() {\n\t\terrCh <- e.Start(\":0\")\n\t}()\n\n\terr := waitForServerStart(e, errCh, false)\n\tassert.NoError(t, err)\n\n\taddr := e.ListenerAddr().String()\n\tif resp, err := http.Get(\"http://\" + addr + \"/static\"); err == nil { // http.Get follows redirects by default\n\t\tdefer func(Body io.ReadCloser) {\n\t\t\terr := Body.Close()\n\t\t\tif err != nil {\n\t\t\t\tassert.Fail(t, err.Error())\n\t\t\t}\n\t\t}(resp.Body)\n\t\tassert.Equal(t, http.StatusOK, resp.StatusCode)\n\n\t\tif body, err := io.ReadAll(resp.Body); err == nil {\n\t\t\tassert.Equal(t, true, strings.HasPrefix(string(body), \"<!doctype html>\"))\n\t\t} else {\n\t\t\tassert.Fail(t, err.Error())\n\t\t}\n\n\t} else {\n\t\tassert.NoError(t, err)\n\t}\n\n\tif err := e.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestEchoFile(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname             string\n\t\tgivenPath        string\n\t\tgivenFile        string\n\t\twhenPath         string\n\t\texpectCode       int\n\t\texpectStartsWith string\n\t}{\n\t\t{\n\t\t\tname:             \"ok\",\n\t\t\tgivenPath:        \"/walle\",\n\t\t\tgivenFile:        \"_fixture/images/walle.png\",\n\t\t\twhenPath:         \"/walle\",\n\t\t\texpectCode:       http.StatusOK,\n\t\t\texpectStartsWith: string([]byte{0x89, 0x50, 0x4e}),\n\t\t},\n\t\t{\n\t\t\tname:             \"ok with relative path\",\n\t\t\tgivenPath:        \"/\",\n\t\t\tgivenFile:        \"./go.mod\",\n\t\t\twhenPath:         \"/\",\n\t\t\texpectCode:       http.StatusOK,\n\t\t\texpectStartsWith: \"module github.com/labstack/echo/v\",\n\t\t},\n\t\t{\n\t\t\tname:             \"nok file does not exist\",\n\t\t\tgivenPath:        \"/\",\n\t\t\tgivenFile:        \"./this-file-does-not-exist\",\n\t\t\twhenPath:         \"/\",\n\t\t\texpectCode:       http.StatusNotFound,\n\t\t\texpectStartsWith: \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New() // we are using echo.defaultFS instance\n\t\t\te.File(tc.givenPath, tc.givenFile)\n\n\t\t\tc, b := request(http.MethodGet, tc.whenPath, e)\n\t\t\tassert.Equal(t, tc.expectCode, c)\n\n\t\t\tif len(b) > len(tc.expectStartsWith) {\n\t\t\t\tb = b[:len(tc.expectStartsWith)]\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectStartsWith, b)\n\t\t})\n\t}\n}\n\nfunc TestEchoMiddleware(t *testing.T) {\n\te := New()\n\tbuf := new(bytes.Buffer)\n\n\te.Pre(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tassert.Empty(t, c.Path())\n\t\t\tbuf.WriteString(\"-1\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\te.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"1\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\te.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"2\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\te.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"3\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\t// Route\n\te.GET(\"/\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"OK\")\n\t})\n\n\tc, b := request(http.MethodGet, \"/\", e)\n\tassert.Equal(t, \"-1123\", buf.String())\n\tassert.Equal(t, http.StatusOK, c)\n\tassert.Equal(t, \"OK\", b)\n}\n\nfunc TestEchoMiddlewareError(t *testing.T) {\n\te := New()\n\te.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\treturn errors.New(\"error\")\n\t\t}\n\t})\n\te.GET(\"/\", NotFoundHandler)\n\tc, _ := request(http.MethodGet, \"/\", e)\n\tassert.Equal(t, http.StatusInternalServerError, c)\n}\n\nfunc TestEchoHandler(t *testing.T) {\n\te := New()\n\n\t// HandlerFunc\n\te.GET(\"/ok\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"OK\")\n\t})\n\n\tc, b := request(http.MethodGet, \"/ok\", e)\n\tassert.Equal(t, http.StatusOK, c)\n\tassert.Equal(t, \"OK\", b)\n}\n\nfunc TestEchoWrapHandler(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\th := WrapHandler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusOK)\n\t\t_, err := w.Write([]byte(\"test\"))\n\t\tif err != nil {\n\t\t\tassert.Fail(t, err.Error())\n\t\t}\n\t}))\n\tif assert.NoError(t, h(c)) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, \"test\", rec.Body.String())\n\t}\n}\n\nfunc TestEchoWrapMiddleware(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tbuf := new(bytes.Buffer)\n\tmw := WrapMiddleware(func(h http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tbuf.Write([]byte(\"mw\"))\n\t\t\th.ServeHTTP(w, r)\n\t\t})\n\t})\n\th := mw(func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"OK\")\n\t})\n\tif assert.NoError(t, h(c)) {\n\t\tassert.Equal(t, \"mw\", buf.String())\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, \"OK\", rec.Body.String())\n\t}\n}\n\nfunc TestEchoConnect(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodConnect, \"/\", e)\n}\n\nfunc TestEchoDelete(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodDelete, \"/\", e)\n}\n\nfunc TestEchoGet(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodGet, \"/\", e)\n}\n\nfunc TestEchoHead(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodHead, \"/\", e)\n}\n\nfunc TestEchoOptions(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodOptions, \"/\", e)\n}\n\nfunc TestEchoPatch(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodPatch, \"/\", e)\n}\n\nfunc TestEchoPost(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodPost, \"/\", e)\n}\n\nfunc TestEchoPut(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodPut, \"/\", e)\n}\n\nfunc TestEchoTrace(t *testing.T) {\n\te := New()\n\ttestMethod(t, http.MethodTrace, \"/\", e)\n}\n\nfunc TestEchoAny(t *testing.T) { // JFC\n\te := New()\n\te.Any(\"/\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"Any\")\n\t})\n}\n\nfunc TestEchoMatch(t *testing.T) { // JFC\n\te := New()\n\te.Match([]string{http.MethodGet, http.MethodPost}, \"/\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"Match\")\n\t})\n}\n\nfunc TestEchoURL(t *testing.T) {\n\te := New()\n\tstatic := func(Context) error { return nil }\n\tgetUser := func(Context) error { return nil }\n\tgetAny := func(Context) error { return nil }\n\tgetFile := func(Context) error { return nil }\n\n\te.GET(\"/static/file\", static)\n\te.GET(\"/users/:id\", getUser)\n\te.GET(\"/documents/*\", getAny)\n\tg := e.Group(\"/group\")\n\tg.GET(\"/users/:uid/files/:fid\", getFile)\n\n\tassert.Equal(t, \"/static/file\", e.URL(static))\n\tassert.Equal(t, \"/users/:id\", e.URL(getUser))\n\tassert.Equal(t, \"/users/1\", e.URL(getUser, \"1\"))\n\tassert.Equal(t, \"/users/1\", e.URL(getUser, \"1\"))\n\tassert.Equal(t, \"/documents/foo.txt\", e.URL(getAny, \"foo.txt\"))\n\tassert.Equal(t, \"/documents/*\", e.URL(getAny))\n\tassert.Equal(t, \"/group/users/1/files/:fid\", e.URL(getFile, \"1\"))\n\tassert.Equal(t, \"/group/users/1/files/1\", e.URL(getFile, \"1\", \"1\"))\n}\n\nfunc TestEchoRoutes(t *testing.T) {\n\te := New()\n\troutes := []*Route{\n\t\t{http.MethodGet, \"/users/:user/events\", \"\"},\n\t\t{http.MethodGet, \"/users/:user/events/public\", \"\"},\n\t\t{http.MethodPost, \"/repos/:owner/:repo/git/refs\", \"\"},\n\t\t{http.MethodPost, \"/repos/:owner/:repo/git/tags\", \"\"},\n\t}\n\tfor _, r := range routes {\n\t\te.Add(r.Method, r.Path, func(c Context) error {\n\t\t\treturn c.String(http.StatusOK, \"OK\")\n\t\t})\n\t}\n\n\tif assert.Equal(t, len(routes), len(e.Routes())) {\n\t\tfor _, r := range e.Routes() {\n\t\t\tfound := false\n\t\t\tfor _, rr := range routes {\n\t\t\t\tif r.Method == rr.Method && r.Path == rr.Path {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\tt.Errorf(\"Route %s %s not found\", r.Method, r.Path)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestEchoRoutesHandleAdditionalHosts(t *testing.T) {\n\te := New()\n\tdomain2Router := e.Host(\"domain2.router.com\")\n\troutes := []*Route{\n\t\t{http.MethodGet, \"/users/:user/events\", \"\"},\n\t\t{http.MethodGet, \"/users/:user/events/public\", \"\"},\n\t\t{http.MethodPost, \"/repos/:owner/:repo/git/refs\", \"\"},\n\t\t{http.MethodPost, \"/repos/:owner/:repo/git/tags\", \"\"},\n\t}\n\tfor _, r := range routes {\n\t\tdomain2Router.Add(r.Method, r.Path, func(c Context) error {\n\t\t\treturn c.String(http.StatusOK, \"OK\")\n\t\t})\n\t}\n\te.Add(http.MethodGet, \"/api\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"OK\")\n\t})\n\n\tdomain2Routes := e.Routers()[\"domain2.router.com\"].Routes()\n\n\tassert.Len(t, domain2Routes, len(routes))\n\tfor _, r := range domain2Routes {\n\t\tfound := false\n\t\tfor _, rr := range routes {\n\t\t\tif r.Method == rr.Method && r.Path == rr.Path {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tt.Errorf(\"Route %s %s not found\", r.Method, r.Path)\n\t\t}\n\t}\n}\n\nfunc TestEchoRoutesHandleDefaultHost(t *testing.T) {\n\te := New()\n\troutes := []*Route{\n\t\t{http.MethodGet, \"/users/:user/events\", \"\"},\n\t\t{http.MethodGet, \"/users/:user/events/public\", \"\"},\n\t\t{http.MethodPost, \"/repos/:owner/:repo/git/refs\", \"\"},\n\t\t{http.MethodPost, \"/repos/:owner/:repo/git/tags\", \"\"},\n\t}\n\tfor _, r := range routes {\n\t\te.Add(r.Method, r.Path, func(c Context) error {\n\t\t\treturn c.String(http.StatusOK, \"OK\")\n\t\t})\n\t}\n\te.Host(\"subdomain.mysite.site\").Add(http.MethodGet, \"/api\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"OK\")\n\t})\n\n\tdefaultRouterRoutes := e.Routes()\n\tassert.Len(t, defaultRouterRoutes, len(routes))\n\tfor _, r := range defaultRouterRoutes {\n\t\tfound := false\n\t\tfor _, rr := range routes {\n\t\t\tif r.Method == rr.Method && r.Path == rr.Path {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tt.Errorf(\"Route %s %s not found\", r.Method, r.Path)\n\t\t}\n\t}\n}\n\nfunc TestEchoServeHTTPPathEncoding(t *testing.T) {\n\te := New()\n\te.GET(\"/with/slash\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"/with/slash\")\n\t})\n\te.GET(\"/:id\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, c.Param(\"id\"))\n\t})\n\n\tvar testCases = []struct {\n\t\tname         string\n\t\twhenURL      string\n\t\texpectURL    string\n\t\texpectStatus int\n\t}{\n\t\t{\n\t\t\tname:         \"url with encoding is not decoded for routing\",\n\t\t\twhenURL:      \"/with%2Fslash\",\n\t\t\texpectURL:    \"with%2Fslash\", // `%2F` is not decoded to `/` for routing\n\t\t\texpectStatus: http.StatusOK,\n\t\t},\n\t\t{\n\t\t\tname:         \"url without encoding is used as is\",\n\t\t\twhenURL:      \"/with/slash\",\n\t\t\texpectURL:    \"/with/slash\",\n\t\t\texpectStatus: http.StatusOK,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodGet, tc.whenURL, nil)\n\t\t\trec := httptest.NewRecorder()\n\n\t\t\te.ServeHTTP(rec, req)\n\n\t\t\tassert.Equal(t, tc.expectStatus, rec.Code)\n\t\t\tassert.Equal(t, tc.expectURL, rec.Body.String())\n\t\t})\n\t}\n}\n\nfunc TestEchoHost(t *testing.T) {\n\tokHandler := func(c Context) error { return c.String(http.StatusOK, http.StatusText(http.StatusOK)) }\n\tteapotHandler := func(c Context) error { return c.String(http.StatusTeapot, http.StatusText(http.StatusTeapot)) }\n\tacceptHandler := func(c Context) error { return c.String(http.StatusAccepted, http.StatusText(http.StatusAccepted)) }\n\tteapotMiddleware := MiddlewareFunc(func(next HandlerFunc) HandlerFunc { return teapotHandler })\n\n\te := New()\n\te.GET(\"/\", acceptHandler)\n\te.GET(\"/foo\", acceptHandler)\n\n\tok := e.Host(\"ok.com\")\n\tok.GET(\"/\", okHandler)\n\tok.GET(\"/foo\", okHandler)\n\n\tteapot := e.Host(\"teapot.com\")\n\tteapot.GET(\"/\", teapotHandler)\n\tteapot.GET(\"/foo\", teapotHandler)\n\n\tmiddle := e.Host(\"middleware.com\", teapotMiddleware)\n\tmiddle.GET(\"/\", okHandler)\n\tmiddle.GET(\"/foo\", okHandler)\n\n\tvar testCases = []struct {\n\t\tname         string\n\t\twhenHost     string\n\t\twhenPath     string\n\t\texpectBody   string\n\t\texpectStatus int\n\t}{\n\t\t{\n\t\t\tname:         \"No Host Root\",\n\t\t\twhenHost:     \"\",\n\t\t\twhenPath:     \"/\",\n\t\t\texpectBody:   http.StatusText(http.StatusAccepted),\n\t\t\texpectStatus: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:         \"No Host Foo\",\n\t\t\twhenHost:     \"\",\n\t\t\twhenPath:     \"/foo\",\n\t\t\texpectBody:   http.StatusText(http.StatusAccepted),\n\t\t\texpectStatus: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:         \"OK Host Root\",\n\t\t\twhenHost:     \"ok.com\",\n\t\t\twhenPath:     \"/\",\n\t\t\texpectBody:   http.StatusText(http.StatusOK),\n\t\t\texpectStatus: http.StatusOK,\n\t\t},\n\t\t{\n\t\t\tname:         \"OK Host Foo\",\n\t\t\twhenHost:     \"ok.com\",\n\t\t\twhenPath:     \"/foo\",\n\t\t\texpectBody:   http.StatusText(http.StatusOK),\n\t\t\texpectStatus: http.StatusOK,\n\t\t},\n\t\t{\n\t\t\tname:         \"Teapot Host Root\",\n\t\t\twhenHost:     \"teapot.com\",\n\t\t\twhenPath:     \"/\",\n\t\t\texpectBody:   http.StatusText(http.StatusTeapot),\n\t\t\texpectStatus: http.StatusTeapot,\n\t\t},\n\t\t{\n\t\t\tname:         \"Teapot Host Foo\",\n\t\t\twhenHost:     \"teapot.com\",\n\t\t\twhenPath:     \"/foo\",\n\t\t\texpectBody:   http.StatusText(http.StatusTeapot),\n\t\t\texpectStatus: http.StatusTeapot,\n\t\t},\n\t\t{\n\t\t\tname:         \"Middleware Host\",\n\t\t\twhenHost:     \"middleware.com\",\n\t\t\twhenPath:     \"/\",\n\t\t\texpectBody:   http.StatusText(http.StatusTeapot),\n\t\t\texpectStatus: http.StatusTeapot,\n\t\t},\n\t\t{\n\t\t\tname:         \"Middleware Host Foo\",\n\t\t\twhenHost:     \"middleware.com\",\n\t\t\twhenPath:     \"/foo\",\n\t\t\texpectBody:   http.StatusText(http.StatusTeapot),\n\t\t\texpectStatus: http.StatusTeapot,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(http.MethodGet, tc.whenPath, nil)\n\t\t\treq.Host = tc.whenHost\n\t\t\trec := httptest.NewRecorder()\n\n\t\t\te.ServeHTTP(rec, req)\n\n\t\t\tassert.Equal(t, tc.expectStatus, rec.Code)\n\t\t\tassert.Equal(t, tc.expectBody, rec.Body.String())\n\t\t})\n\t}\n}\n\nfunc TestEchoGroup(t *testing.T) {\n\te := New()\n\tbuf := new(bytes.Buffer)\n\te.Use(MiddlewareFunc(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"0\")\n\t\t\treturn next(c)\n\t\t}\n\t}))\n\th := func(c Context) error {\n\t\treturn c.NoContent(http.StatusOK)\n\t}\n\n\t//--------\n\t// Routes\n\t//--------\n\n\te.GET(\"/users\", h)\n\n\t// Group\n\tg1 := e.Group(\"/group1\")\n\tg1.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"1\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\tg1.GET(\"\", h)\n\n\t// Nested groups with middleware\n\tg2 := e.Group(\"/group2\")\n\tg2.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"2\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\tg3 := g2.Group(\"/group3\")\n\tg3.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\tbuf.WriteString(\"3\")\n\t\t\treturn next(c)\n\t\t}\n\t})\n\tg3.GET(\"\", h)\n\n\trequest(http.MethodGet, \"/users\", e)\n\tassert.Equal(t, \"0\", buf.String())\n\n\tbuf.Reset()\n\trequest(http.MethodGet, \"/group1\", e)\n\tassert.Equal(t, \"01\", buf.String())\n\n\tbuf.Reset()\n\trequest(http.MethodGet, \"/group2/group3\", e)\n\tassert.Equal(t, \"023\", buf.String())\n}\n\nfunc TestEchoNotFound(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/files\", nil)\n\trec := httptest.NewRecorder()\n\te.ServeHTTP(rec, req)\n\tassert.Equal(t, http.StatusNotFound, rec.Code)\n}\n\nfunc TestEcho_RouteNotFound(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname        string\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectCode  int\n\t}{\n\t\t{\n\t\t\tname:        \"404, route to static not found handler /a/c/xx\",\n\t\t\twhenURL:     \"/a/c/xx\",\n\t\t\texpectRoute: \"GET /a/c/xx\",\n\t\t\texpectCode:  http.StatusNotFound,\n\t\t},\n\t\t{\n\t\t\tname:        \"404, route to path param not found handler /a/:file\",\n\t\t\twhenURL:     \"/a/echo.exe\",\n\t\t\texpectRoute: \"GET /a/:file\",\n\t\t\texpectCode:  http.StatusNotFound,\n\t\t},\n\t\t{\n\t\t\tname:        \"404, route to any not found handler /*\",\n\t\t\twhenURL:     \"/b/echo.exe\",\n\t\t\texpectRoute: \"GET /*\",\n\t\t\texpectCode:  http.StatusNotFound,\n\t\t},\n\t\t{\n\t\t\tname:        \"200, route /a/c/df to /a/c/df\",\n\t\t\twhenURL:     \"/a/c/df\",\n\t\t\texpectRoute: \"GET /a/c/df\",\n\t\t\texpectCode:  http.StatusOK,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\n\t\t\tokHandler := func(c Context) error {\n\t\t\t\treturn c.String(http.StatusOK, c.Request().Method+\" \"+c.Path())\n\t\t\t}\n\t\t\tnotFoundHandler := func(c Context) error {\n\t\t\t\treturn c.String(http.StatusNotFound, c.Request().Method+\" \"+c.Path())\n\t\t\t}\n\n\t\t\te.GET(\"/\", okHandler)\n\t\t\te.GET(\"/a/c/df\", okHandler)\n\t\t\te.GET(\"/a/b*\", okHandler)\n\t\t\te.PUT(\"/*\", okHandler)\n\n\t\t\te.RouteNotFound(\"/a/c/xx\", notFoundHandler)  // static\n\t\t\te.RouteNotFound(\"/a/:file\", notFoundHandler) // param\n\t\t\te.RouteNotFound(\"/*\", notFoundHandler)       // any\n\n\t\t\treq := httptest.NewRequest(http.MethodGet, tc.whenURL, nil)\n\t\t\trec := httptest.NewRecorder()\n\n\t\t\te.ServeHTTP(rec, req)\n\n\t\t\tassert.Equal(t, tc.expectCode, rec.Code)\n\t\t\tassert.Equal(t, tc.expectRoute, rec.Body.String())\n\t\t})\n\t}\n}\n\nfunc TestEchoMethodNotAllowed(t *testing.T) {\n\te := New()\n\n\te.GET(\"/\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"Echo!\")\n\t})\n\treq := httptest.NewRequest(http.MethodPost, \"/\", nil)\n\trec := httptest.NewRecorder()\n\te.ServeHTTP(rec, req)\n\n\tassert.Equal(t, http.StatusMethodNotAllowed, rec.Code)\n\tassert.Equal(t, \"OPTIONS, GET\", rec.Header().Get(HeaderAllow))\n}\n\nfunc TestEchoContext(t *testing.T) {\n\te := New()\n\tc := e.AcquireContext()\n\tassert.IsType(t, new(context), c)\n\te.ReleaseContext(c)\n}\n\nfunc waitForServerStart(e *Echo, errChan <-chan error, isTLS bool) error {\n\tctx, cancel := stdContext.WithTimeout(stdContext.Background(), 200*time.Millisecond)\n\tdefer cancel()\n\n\tticker := time.NewTicker(5 * time.Millisecond)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\tcase <-ticker.C:\n\t\t\tvar addr net.Addr\n\t\t\tif isTLS {\n\t\t\t\taddr = e.TLSListenerAddr()\n\t\t\t} else {\n\t\t\t\taddr = e.ListenerAddr()\n\t\t\t}\n\t\t\tif addr != nil && strings.Contains(addr.String(), \":\") {\n\t\t\t\treturn nil // was started\n\t\t\t}\n\t\tcase err := <-errChan:\n\t\t\tif err == http.ErrServerClosed {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc TestEchoStart(t *testing.T) {\n\te := New()\n\terrChan := make(chan error)\n\n\tgo func() {\n\t\terr := e.Start(\":0\")\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t}\n\t}()\n\n\terr := waitForServerStart(e, errChan, false)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, e.Close())\n}\n\nfunc TestEcho_StartTLS(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname        string\n\t\taddr        string\n\t\tcertFile    string\n\t\tkeyFile     string\n\t\texpectError string\n\t}{\n\t\t{\n\t\t\tname: \"ok\",\n\t\t\taddr: \":0\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, invalid certFile\",\n\t\t\taddr:        \":0\",\n\t\t\tcertFile:    \"not existing\",\n\t\t\texpectError: \"open not existing: no such file or directory\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, invalid keyFile\",\n\t\t\taddr:        \":0\",\n\t\t\tkeyFile:     \"not existing\",\n\t\t\texpectError: \"open not existing: no such file or directory\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, failed to create cert out of certFile and keyFile\",\n\t\t\taddr:        \":0\",\n\t\t\tkeyFile:     \"_fixture/certs/cert.pem\", // we are passing cert instead of key\n\t\t\texpectError: \"tls: found a certificate rather than a key in the PEM for the private key\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, invalid tls address\",\n\t\t\taddr:        \"nope\",\n\t\t\texpectError: \"listen tcp: address nope: missing port in address\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\terrChan := make(chan error)\n\n\t\t\tgo func() {\n\t\t\t\tcertFile := \"_fixture/certs/cert.pem\"\n\t\t\t\tif tc.certFile != \"\" {\n\t\t\t\t\tcertFile = tc.certFile\n\t\t\t\t}\n\t\t\t\tkeyFile := \"_fixture/certs/key.pem\"\n\t\t\t\tif tc.keyFile != \"\" {\n\t\t\t\t\tkeyFile = tc.keyFile\n\t\t\t\t}\n\n\t\t\t\terr := e.StartTLS(tc.addr, certFile, keyFile)\n\t\t\t\tif err != nil {\n\t\t\t\t\terrChan <- err\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\terr := waitForServerStart(e, errChan, true)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tif _, ok := err.(*os.PathError); ok {\n\t\t\t\t\tassert.Error(t, err) // error messages for unix and windows are different. so test only error type here\n\t\t\t\t} else {\n\t\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\n\t\t\tassert.NoError(t, e.Close())\n\t\t})\n\t}\n}\n\nfunc TestEchoStartTLSAndStart(t *testing.T) {\n\t// We test if Echo and listeners work correctly when Echo is simultaneously attached to HTTP and HTTPS server\n\te := New()\n\te.GET(\"/\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"OK\")\n\t})\n\n\terrTLSChan := make(chan error)\n\tgo func() {\n\t\tcertFile := \"_fixture/certs/cert.pem\"\n\t\tkeyFile := \"_fixture/certs/key.pem\"\n\t\terr := e.StartTLS(\"localhost:\", certFile, keyFile)\n\t\tif err != nil {\n\t\t\terrTLSChan <- err\n\t\t}\n\t}()\n\n\terr := waitForServerStart(e, errTLSChan, true)\n\tassert.NoError(t, err)\n\tdefer func() {\n\t\tif err := e.Shutdown(stdContext.Background()); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}()\n\n\t// check if HTTPS works (note: we are using self signed certs so InsecureSkipVerify=true)\n\tclient := &http.Client{Transport: &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}}\n\tres, err := client.Get(\"https://\" + e.TLSListenerAddr().String())\n\tassert.NoError(t, err)\n\tassert.Equal(t, http.StatusOK, res.StatusCode)\n\n\terrChan := make(chan error)\n\tgo func() {\n\t\terr := e.Start(\"localhost:\")\n\t\tif err != nil {\n\t\t\terrChan <- err\n\t\t}\n\t}()\n\terr = waitForServerStart(e, errChan, false)\n\tassert.NoError(t, err)\n\n\t// now we are serving both HTTPS and HTTP listeners. see if HTTP works in addition to HTTPS\n\tres, err = http.Get(\"http://\" + e.ListenerAddr().String())\n\tassert.NoError(t, err)\n\tassert.Equal(t, http.StatusOK, res.StatusCode)\n\n\t// see if HTTPS works after HTTP listener is also added\n\tres, err = client.Get(\"https://\" + e.TLSListenerAddr().String())\n\tassert.NoError(t, err)\n\tassert.Equal(t, http.StatusOK, res.StatusCode)\n}\n\nfunc TestEchoStartTLSByteString(t *testing.T) {\n\tcert, err := os.ReadFile(\"_fixture/certs/cert.pem\")\n\trequire.NoError(t, err)\n\tkey, err := os.ReadFile(\"_fixture/certs/key.pem\")\n\trequire.NoError(t, err)\n\n\ttestCases := []struct {\n\t\tcert        interface{}\n\t\tkey         interface{}\n\t\texpectedErr error\n\t\tname        string\n\t}{\n\t\t{\n\t\t\tcert:        \"_fixture/certs/cert.pem\",\n\t\t\tkey:         \"_fixture/certs/key.pem\",\n\t\t\texpectedErr: nil,\n\t\t\tname:        `ValidCertAndKeyFilePath`,\n\t\t},\n\t\t{\n\t\t\tcert:        cert,\n\t\t\tkey:         key,\n\t\t\texpectedErr: nil,\n\t\t\tname:        `ValidCertAndKeyByteString`,\n\t\t},\n\t\t{\n\t\t\tcert:        cert,\n\t\t\tkey:         1,\n\t\t\texpectedErr: ErrInvalidCertOrKeyType,\n\t\t\tname:        `InvalidKeyType`,\n\t\t},\n\t\t{\n\t\t\tcert:        0,\n\t\t\tkey:         key,\n\t\t\texpectedErr: ErrInvalidCertOrKeyType,\n\t\t\tname:        `InvalidCertType`,\n\t\t},\n\t\t{\n\t\t\tcert:        0,\n\t\t\tkey:         1,\n\t\t\texpectedErr: ErrInvalidCertOrKeyType,\n\t\t\tname:        `InvalidCertAndKeyTypes`,\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\te.HideBanner = true\n\n\t\t\terrChan := make(chan error)\n\n\t\t\tgo func() {\n\t\t\t\terrChan <- e.StartTLS(\":0\", test.cert, test.key)\n\t\t\t}()\n\n\t\t\terr := waitForServerStart(e, errChan, true)\n\t\t\tif test.expectedErr != nil {\n\t\t\t\tassert.EqualError(t, err, test.expectedErr.Error())\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\n\t\t\tassert.NoError(t, e.Close())\n\t\t})\n\t}\n}\n\nfunc TestEcho_StartAutoTLS(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname        string\n\t\taddr        string\n\t\texpectError string\n\t}{\n\t\t{\n\t\t\tname: \"ok\",\n\t\t\taddr: \":0\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, invalid address\",\n\t\t\taddr:        \"nope\",\n\t\t\texpectError: \"listen tcp: address nope: missing port in address\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\terrChan := make(chan error)\n\n\t\t\tgo func() {\n\t\t\t\terrChan <- e.StartAutoTLS(tc.addr)\n\t\t\t}()\n\n\t\t\terr := waitForServerStart(e, errChan, true)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\n\t\t\tassert.NoError(t, e.Close())\n\t\t})\n\t}\n}\n\nfunc TestEcho_StartH2CServer(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname        string\n\t\taddr        string\n\t\texpectError string\n\t}{\n\t\t{\n\t\t\tname: \"ok\",\n\t\t\taddr: \":0\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, invalid address\",\n\t\t\taddr:        \"nope\",\n\t\t\texpectError: \"listen tcp: address nope: missing port in address\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\te.Debug = true\n\t\t\th2s := &http2.Server{}\n\n\t\t\terrChan := make(chan error)\n\t\t\tgo func() {\n\t\t\t\terr := e.StartH2CServer(tc.addr, h2s)\n\t\t\t\tif err != nil {\n\t\t\t\t\terrChan <- err\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\terr := waitForServerStart(e, errChan, false)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\n\t\t\tassert.NoError(t, e.Close())\n\t\t})\n\t}\n}\n\nfunc testMethod(t *testing.T, method, path string, e *Echo) {\n\tp := reflect.ValueOf(path)\n\th := reflect.ValueOf(func(c Context) error {\n\t\treturn c.String(http.StatusOK, method)\n\t})\n\ti := interface{}(e)\n\treflect.ValueOf(i).MethodByName(method).Call([]reflect.Value{p, h})\n\t_, body := request(method, path, e)\n\tassert.Equal(t, method, body)\n}\n\nfunc request(method, path string, e *Echo) (int, string) {\n\treq := httptest.NewRequest(method, path, nil)\n\trec := httptest.NewRecorder()\n\te.ServeHTTP(rec, req)\n\treturn rec.Code, rec.Body.String()\n}\n\nfunc TestHTTPError(t *testing.T) {\n\tt.Run(\"non-internal\", func(t *testing.T) {\n\t\terr := NewHTTPError(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"code\": 12,\n\t\t})\n\n\t\tassert.Equal(t, \"code=400, message=map[code:12]\", err.Error())\n\t})\n\n\tt.Run(\"internal and SetInternal\", func(t *testing.T) {\n\t\terr := NewHTTPError(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"code\": 12,\n\t\t})\n\t\terr.SetInternal(errors.New(\"internal error\"))\n\t\tassert.Equal(t, \"code=400, message=map[code:12], internal=internal error\", err.Error())\n\t})\n\n\tt.Run(\"internal and WithInternal\", func(t *testing.T) {\n\t\terr := NewHTTPError(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"code\": 12,\n\t\t})\n\t\terr = err.WithInternal(errors.New(\"internal error\"))\n\t\tassert.Equal(t, \"code=400, message=map[code:12], internal=internal error\", err.Error())\n\t})\n}\n\nfunc TestHTTPError_Unwrap(t *testing.T) {\n\tt.Run(\"non-internal\", func(t *testing.T) {\n\t\terr := NewHTTPError(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"code\": 12,\n\t\t})\n\n\t\tassert.Nil(t, errors.Unwrap(err))\n\t})\n\n\tt.Run(\"unwrap internal and SetInternal\", func(t *testing.T) {\n\t\terr := NewHTTPError(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"code\": 12,\n\t\t})\n\t\terr.SetInternal(errors.New(\"internal error\"))\n\t\tassert.Equal(t, \"internal error\", errors.Unwrap(err).Error())\n\t})\n\n\tt.Run(\"unwrap internal and WithInternal\", func(t *testing.T) {\n\t\terr := NewHTTPError(http.StatusBadRequest, map[string]interface{}{\n\t\t\t\"code\": 12,\n\t\t})\n\t\terr = err.WithInternal(errors.New(\"internal error\"))\n\t\tassert.Equal(t, \"internal error\", errors.Unwrap(err).Error())\n\t})\n}\n\ntype customError struct {\n\ts string\n}\n\nfunc (ce *customError) MarshalJSON() ([]byte, error) {\n\treturn []byte(fmt.Sprintf(`{\"x\":\"%v\"}`, ce.s)), nil\n}\n\nfunc (ce *customError) Error() string {\n\treturn ce.s\n}\n\nfunc TestDefaultHTTPErrorHandler(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname       string\n\t\tgivenDebug bool\n\t\twhenPath   string\n\t\texpectCode int\n\t\texpectBody string\n\t}{\n\t\t{\n\t\t\tname:       \"with Debug=true plain response contains error message\",\n\t\t\tgivenDebug: true,\n\t\t\twhenPath:   \"/plain\",\n\t\t\texpectCode: http.StatusInternalServerError,\n\t\t\texpectBody: \"{\\n  \\\"error\\\": \\\"an error occurred\\\",\\n  \\\"message\\\": \\\"Internal Server Error\\\"\\n}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:       \"with Debug=true special handling for HTTPError\",\n\t\t\tgivenDebug: true,\n\t\t\twhenPath:   \"/badrequest\",\n\t\t\texpectCode: http.StatusBadRequest,\n\t\t\texpectBody: \"{\\n  \\\"error\\\": \\\"code=400, message=Invalid request\\\",\\n  \\\"message\\\": \\\"Invalid request\\\"\\n}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:       \"with Debug=true complex errors are serialized to pretty JSON\",\n\t\t\tgivenDebug: true,\n\t\t\twhenPath:   \"/servererror\",\n\t\t\texpectCode: http.StatusInternalServerError,\n\t\t\texpectBody: \"{\\n  \\\"code\\\": 33,\\n  \\\"error\\\": \\\"stackinfo\\\",\\n  \\\"message\\\": \\\"Something bad happened\\\"\\n}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:       \"with Debug=true if the body is already set HTTPErrorHandler should not add anything to response body\",\n\t\t\tgivenDebug: true,\n\t\t\twhenPath:   \"/early-return\",\n\t\t\texpectCode: http.StatusOK,\n\t\t\texpectBody: \"OK\",\n\t\t},\n\t\t{\n\t\t\tname:       \"with Debug=true internal error should be reflected in the message\",\n\t\t\tgivenDebug: true,\n\t\t\twhenPath:   \"/internal-error\",\n\t\t\texpectCode: http.StatusBadRequest,\n\t\t\texpectBody: \"{\\n  \\\"error\\\": \\\"code=400, message=Bad Request, internal=internal error message body\\\",\\n  \\\"message\\\": \\\"Bad Request\\\"\\n}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:       \"with Debug=false the error response is shortened\",\n\t\t\twhenPath:   \"/plain\",\n\t\t\texpectCode: http.StatusInternalServerError,\n\t\t\texpectBody: \"{\\\"message\\\":\\\"Internal Server Error\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:       \"with Debug=false the error response is shortened\",\n\t\t\twhenPath:   \"/badrequest\",\n\t\t\texpectCode: http.StatusBadRequest,\n\t\t\texpectBody: \"{\\\"message\\\":\\\"Invalid request\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:       \"with Debug=false No difference for error response with non plain string errors\",\n\t\t\twhenPath:   \"/servererror\",\n\t\t\texpectCode: http.StatusInternalServerError,\n\t\t\texpectBody: \"{\\\"code\\\":33,\\\"error\\\":\\\"stackinfo\\\",\\\"message\\\":\\\"Something bad happened\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:       \"with Debug=false when httpError contains an error\",\n\t\t\twhenPath:   \"/error-in-httperror\",\n\t\t\texpectCode: http.StatusBadRequest,\n\t\t\texpectBody: \"{\\\"message\\\":\\\"error in httperror\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname:       \"with Debug=false when httpError contains an error\",\n\t\t\twhenPath:   \"/customerror-in-httperror\",\n\t\t\texpectCode: http.StatusBadRequest,\n\t\t\texpectBody: \"{\\\"x\\\":\\\"custom error msg\\\"}\\n\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\te.Debug = tc.givenDebug // With Debug=true plain response contains error message\n\n\t\t\te.Any(\"/plain\", func(c Context) error {\n\t\t\t\treturn errors.New(\"an error occurred\")\n\t\t\t})\n\n\t\t\te.Any(\"/badrequest\", func(c Context) error { // and special handling for HTTPError\n\t\t\t\treturn NewHTTPError(http.StatusBadRequest, \"Invalid request\")\n\t\t\t})\n\n\t\t\te.Any(\"/servererror\", func(c Context) error { // complex errors are serialized to pretty JSON\n\t\t\t\treturn NewHTTPError(http.StatusInternalServerError, map[string]interface{}{\n\t\t\t\t\t\"code\":    33,\n\t\t\t\t\t\"message\": \"Something bad happened\",\n\t\t\t\t\t\"error\":   \"stackinfo\",\n\t\t\t\t})\n\t\t\t})\n\n\t\t\t// if the body is already set HTTPErrorHandler should not add anything to response body\n\t\t\te.Any(\"/early-return\", func(c Context) error {\n\t\t\t\terr := c.String(http.StatusOK, \"OK\")\n\t\t\t\tif err != nil {\n\t\t\t\t\tassert.Fail(t, err.Error())\n\t\t\t\t}\n\t\t\t\treturn errors.New(\"ERROR\")\n\t\t\t})\n\n\t\t\t// internal error should be reflected in the message\n\t\t\te.GET(\"/internal-error\", func(c Context) error {\n\t\t\t\terr := errors.New(\"internal error message body\")\n\t\t\t\treturn NewHTTPError(http.StatusBadRequest).SetInternal(err)\n\t\t\t})\n\n\t\t\te.GET(\"/error-in-httperror\", func(c Context) error {\n\t\t\t\treturn NewHTTPError(http.StatusBadRequest, errors.New(\"error in httperror\"))\n\t\t\t})\n\n\t\t\te.GET(\"/customerror-in-httperror\", func(c Context) error {\n\t\t\t\treturn NewHTTPError(http.StatusBadRequest, &customError{s: \"custom error msg\"})\n\t\t\t})\n\n\t\t\tc, b := request(http.MethodGet, tc.whenPath, e)\n\t\t\tassert.Equal(t, tc.expectCode, c)\n\t\t\tassert.Equal(t, tc.expectBody, b)\n\t\t})\n\t}\n}\n\nfunc TestEchoClose(t *testing.T) {\n\te := New()\n\terrCh := make(chan error)\n\n\tgo func() {\n\t\terrCh <- e.Start(\":0\")\n\t}()\n\n\terr := waitForServerStart(e, errCh, false)\n\tassert.NoError(t, err)\n\n\tif err := e.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassert.NoError(t, e.Close())\n\n\terr = <-errCh\n\tassert.Equal(t, err.Error(), \"http: Server closed\")\n}\n\nfunc TestEchoShutdown(t *testing.T) {\n\te := New()\n\terrCh := make(chan error)\n\n\tgo func() {\n\t\terrCh <- e.Start(\":0\")\n\t}()\n\n\terr := waitForServerStart(e, errCh, false)\n\tassert.NoError(t, err)\n\n\tif err := e.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx, cancel := stdContext.WithTimeout(stdContext.Background(), 10*time.Second)\n\tdefer cancel()\n\tassert.NoError(t, e.Shutdown(ctx))\n\n\terr = <-errCh\n\tassert.Equal(t, err.Error(), \"http: Server closed\")\n}\n\nvar listenerNetworkTests = []struct {\n\ttest    string\n\tnetwork string\n\taddress string\n}{\n\t{\"tcp ipv4 address\", \"tcp\", \"127.0.0.1:1323\"},\n\t{\"tcp ipv6 address\", \"tcp\", \"[::1]:1323\"},\n\t{\"tcp4 ipv4 address\", \"tcp4\", \"127.0.0.1:1323\"},\n\t{\"tcp6 ipv6 address\", \"tcp6\", \"[::1]:1323\"},\n}\n\nfunc supportsIPv6() bool {\n\taddrs, _ := net.InterfaceAddrs()\n\tfor _, addr := range addrs {\n\t\t// Check if any interface has local IPv6 assigned\n\t\tif strings.Contains(addr.String(), \"::1\") {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc TestEchoListenerNetwork(t *testing.T) {\n\thasIPv6 := supportsIPv6()\n\tfor _, tt := range listenerNetworkTests {\n\t\tif !hasIPv6 && strings.Contains(tt.address, \"::\") {\n\t\t\tt.Skip(\"Skipping testing IPv6 for \" + tt.address + \", not available\")\n\t\t\tcontinue\n\t\t}\n\t\tt.Run(tt.test, func(t *testing.T) {\n\t\t\te := New()\n\t\t\te.ListenerNetwork = tt.network\n\n\t\t\t// HandlerFunc\n\t\t\te.GET(\"/ok\", func(c Context) error {\n\t\t\t\treturn c.String(http.StatusOK, \"OK\")\n\t\t\t})\n\n\t\t\terrCh := make(chan error)\n\n\t\t\tgo func() {\n\t\t\t\terrCh <- e.Start(tt.address)\n\t\t\t}()\n\n\t\t\terr := waitForServerStart(e, errCh, false)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tif resp, err := http.Get(fmt.Sprintf(\"http://%s/ok\", tt.address)); err == nil {\n\t\t\t\tdefer func(Body io.ReadCloser) {\n\t\t\t\t\terr := Body.Close()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tassert.Fail(t, err.Error())\n\t\t\t\t\t}\n\t\t\t\t}(resp.Body)\n\t\t\t\tassert.Equal(t, http.StatusOK, resp.StatusCode)\n\n\t\t\t\tif body, err := io.ReadAll(resp.Body); err == nil {\n\t\t\t\t\tassert.Equal(t, \"OK\", string(body))\n\t\t\t\t} else {\n\t\t\t\t\tassert.Fail(t, err.Error())\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tassert.Fail(t, err.Error())\n\t\t\t}\n\n\t\t\tif err := e.Close(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestEchoListenerNetworkInvalid(t *testing.T) {\n\te := New()\n\te.ListenerNetwork = \"unix\"\n\n\t// HandlerFunc\n\te.GET(\"/ok\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"OK\")\n\t})\n\n\tassert.Equal(t, ErrInvalidListenerNetwork, e.Start(\":1323\"))\n}\n\nfunc TestEcho_OnAddRouteHandler(t *testing.T) {\n\ttype rr struct {\n\t\thost       string\n\t\troute      Route\n\t\thandler    HandlerFunc\n\t\tmiddleware []MiddlewareFunc\n\t}\n\tdummyHandler := func(Context) error { return nil }\n\te := New()\n\n\tadded := make([]rr, 0)\n\te.OnAddRouteHandler = func(host string, route Route, handler HandlerFunc, middleware []MiddlewareFunc) {\n\t\tadded = append(added, rr{\n\t\t\thost:       host,\n\t\t\troute:      route,\n\t\t\thandler:    handler,\n\t\t\tmiddleware: middleware,\n\t\t})\n\t}\n\n\te.GET(\"/static\", dummyHandler)\n\te.Host(\"domain.site\").GET(\"/static/*\", dummyHandler, func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\treturn next(c)\n\t\t}\n\t})\n\n\tassert.Len(t, added, 2)\n\n\tassert.Equal(t, \"\", added[0].host)\n\tassert.Equal(t, Route{Method: http.MethodGet, Path: \"/static\", Name: \"github.com/labstack/echo/v4.TestEcho_OnAddRouteHandler.func1\"}, added[0].route)\n\tassert.Len(t, added[0].middleware, 0)\n\n\tassert.Equal(t, \"domain.site\", added[1].host)\n\tassert.Equal(t, Route{Method: http.MethodGet, Path: \"/static/*\", Name: \"github.com/labstack/echo/v4.TestEcho_OnAddRouteHandler.func1\"}, added[1].route)\n\tassert.Len(t, added[1].middleware, 1)\n}\n\nfunc TestEchoReverse(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname          string\n\t\twhenRouteName string\n\t\twhenParams    []interface{}\n\t\texpect        string\n\t}{\n\t\t{\n\t\t\tname:          \"ok, not existing path returns empty url\",\n\t\t\twhenRouteName: \"not-existing\",\n\t\t\texpect:        \"\",\n\t\t},\n\t\t{\n\t\t\tname:          \"ok,static with no params\",\n\t\t\twhenRouteName: \"/static\",\n\t\t\texpect:        \"/static\",\n\t\t},\n\t\t{\n\t\t\tname:          \"ok,static with non existent param\",\n\t\t\twhenRouteName: \"/static\",\n\t\t\twhenParams:    []interface{}{\"missing param\"},\n\t\t\texpect:        \"/static\",\n\t\t},\n\t\t{\n\t\t\tname:          \"ok, wildcard with no params\",\n\t\t\twhenRouteName: \"/static/*\",\n\t\t\texpect:        \"/static/*\",\n\t\t},\n\t\t{\n\t\t\tname:          \"ok, wildcard with params\",\n\t\t\twhenRouteName: \"/static/*\",\n\t\t\twhenParams:    []interface{}{\"foo.txt\"},\n\t\t\texpect:        \"/static/foo.txt\",\n\t\t},\n\t\t{\n\t\t\tname:          \"ok, single param without param\",\n\t\t\twhenRouteName: \"/params/:foo\",\n\t\t\texpect:        \"/params/:foo\",\n\t\t},\n\t\t{\n\t\t\tname:          \"ok, single param with param\",\n\t\t\twhenRouteName: \"/params/:foo\",\n\t\t\twhenParams:    []interface{}{\"one\"},\n\t\t\texpect:        \"/params/one\",\n\t\t},\n\t\t{\n\t\t\tname:          \"ok, multi param without params\",\n\t\t\twhenRouteName: \"/params/:foo/bar/:qux\",\n\t\t\texpect:        \"/params/:foo/bar/:qux\",\n\t\t},\n\t\t{\n\t\t\tname:          \"ok, multi param with one param\",\n\t\t\twhenRouteName: \"/params/:foo/bar/:qux\",\n\t\t\twhenParams:    []interface{}{\"one\"},\n\t\t\texpect:        \"/params/one/bar/:qux\",\n\t\t},\n\t\t{\n\t\t\tname:          \"ok, multi param with all params\",\n\t\t\twhenRouteName: \"/params/:foo/bar/:qux\",\n\t\t\twhenParams:    []interface{}{\"one\", \"two\"},\n\t\t\texpect:        \"/params/one/bar/two\",\n\t\t},\n\t\t{\n\t\t\tname:          \"ok, multi param + wildcard with all params\",\n\t\t\twhenRouteName: \"/params/:foo/bar/:qux/*\",\n\t\t\twhenParams:    []interface{}{\"one\", \"two\", \"three\"},\n\t\t\texpect:        \"/params/one/bar/two/three\",\n\t\t},\n\t\t{\n\t\t\tname:          \"ok, backslash is not escaped\",\n\t\t\twhenRouteName: \"/backslash\",\n\t\t\twhenParams:    []interface{}{\"test\"},\n\t\t\texpect:        `/a\\b/test`,\n\t\t},\n\t\t{\n\t\t\tname:          \"ok, escaped colon verbs\",\n\t\t\twhenRouteName: \"/params:customVerb\",\n\t\t\twhenParams:    []interface{}{\"PATCH\"},\n\t\t\texpect:        `/params:PATCH`,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\tdummyHandler := func(Context) error { return nil }\n\n\t\t\te.GET(\"/static\", dummyHandler).Name = \"/static\"\n\t\t\te.GET(\"/static/*\", dummyHandler).Name = \"/static/*\"\n\t\t\te.GET(\"/params/:foo\", dummyHandler).Name = \"/params/:foo\"\n\t\t\te.GET(\"/params/:foo/bar/:qux\", dummyHandler).Name = \"/params/:foo/bar/:qux\"\n\t\t\te.GET(\"/params/:foo/bar/:qux/*\", dummyHandler).Name = \"/params/:foo/bar/:qux/*\"\n\t\t\te.GET(\"/a\\\\b/:x\", dummyHandler).Name = \"/backslash\"\n\t\t\te.GET(\"/params\\\\::customVerb\", dummyHandler).Name = \"/params:customVerb\"\n\n\t\t\tassert.Equal(t, tc.expect, e.Reverse(tc.whenRouteName, tc.whenParams...))\n\t\t})\n\t}\n}\n\nfunc TestEchoReverseHandleHostProperly(t *testing.T) {\n\tdummyHandler := func(Context) error { return nil }\n\n\te := New()\n\n\t// routes added to the default router are different form different hosts\n\te.GET(\"/static\", dummyHandler).Name = \"default-host /static\"\n\te.GET(\"/static/*\", dummyHandler).Name = \"xxx\"\n\n\t// different host\n\th := e.Host(\"the_host\")\n\th.GET(\"/static\", dummyHandler).Name = \"host2 /static\"\n\th.GET(\"/static/v2/*\", dummyHandler).Name = \"xxx\"\n\n\tassert.Equal(t, \"/static\", e.Reverse(\"default-host /static\"))\n\t// when actual route does not have params and we provide some to Reverse we should get that route url back\n\tassert.Equal(t, \"/static\", e.Reverse(\"default-host /static\", \"missing param\"))\n\n\thost2Router := e.Routers()[\"the_host\"]\n\tassert.Equal(t, \"/static\", host2Router.Reverse(\"host2 /static\"))\n\tassert.Equal(t, \"/static\", host2Router.Reverse(\"host2 /static\", \"missing param\"))\n\n\tassert.Equal(t, \"/static/v2/*\", host2Router.Reverse(\"xxx\"))\n\tassert.Equal(t, \"/static/v2/foo.txt\", host2Router.Reverse(\"xxx\", \"foo.txt\"))\n\n}\n\nfunc TestEcho_ListenerAddr(t *testing.T) {\n\te := New()\n\n\taddr := e.ListenerAddr()\n\tassert.Nil(t, addr)\n\n\terrCh := make(chan error)\n\tgo func() {\n\t\terrCh <- e.Start(\":0\")\n\t}()\n\n\terr := waitForServerStart(e, errCh, false)\n\tassert.NoError(t, err)\n}\n\nfunc TestEcho_TLSListenerAddr(t *testing.T) {\n\tcert, err := os.ReadFile(\"_fixture/certs/cert.pem\")\n\trequire.NoError(t, err)\n\tkey, err := os.ReadFile(\"_fixture/certs/key.pem\")\n\trequire.NoError(t, err)\n\n\te := New()\n\n\taddr := e.TLSListenerAddr()\n\tassert.Nil(t, addr)\n\n\terrCh := make(chan error)\n\tgo func() {\n\t\terrCh <- e.StartTLS(\":0\", cert, key)\n\t}()\n\n\terr = waitForServerStart(e, errCh, true)\n\tassert.NoError(t, err)\n}\n\nfunc TestEcho_StartServer(t *testing.T) {\n\tcert, err := os.ReadFile(\"_fixture/certs/cert.pem\")\n\trequire.NoError(t, err)\n\tkey, err := os.ReadFile(\"_fixture/certs/key.pem\")\n\trequire.NoError(t, err)\n\tcerts, err := tls.X509KeyPair(cert, key)\n\trequire.NoError(t, err)\n\n\tvar testCases = []struct {\n\t\tname        string\n\t\taddr        string\n\t\tTLSConfig   *tls.Config\n\t\texpectError string\n\t}{\n\t\t{\n\t\t\tname: \"ok\",\n\t\t\taddr: \":0\",\n\t\t},\n\t\t{\n\t\t\tname:      \"ok, start with TLS\",\n\t\t\taddr:      \":0\",\n\t\t\tTLSConfig: &tls.Config{Certificates: []tls.Certificate{certs}},\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, invalid address\",\n\t\t\taddr:        \"nope\",\n\t\t\texpectError: \"listen tcp: address nope: missing port in address\",\n\t\t},\n\t\t{\n\t\t\tname:        \"nok, invalid tls address\",\n\t\t\taddr:        \"nope\",\n\t\t\tTLSConfig:   &tls.Config{InsecureSkipVerify: true},\n\t\t\texpectError: \"listen tcp: address nope: missing port in address\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\te.Debug = true\n\n\t\t\tserver := new(http.Server)\n\t\t\tserver.Addr = tc.addr\n\t\t\tif tc.TLSConfig != nil {\n\t\t\t\tserver.TLSConfig = tc.TLSConfig\n\t\t\t}\n\n\t\t\terrCh := make(chan error)\n\t\t\tgo func() {\n\t\t\t\terrCh <- e.StartServer(server)\n\t\t\t}()\n\n\t\t\terr := waitForServerStart(e, errCh, tc.TLSConfig != nil)\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tassert.NoError(t, e.Close())\n\t\t})\n\t}\n}\n\nfunc benchmarkEchoRoutes(b *testing.B, routes []*Route) {\n\te := New()\n\treq := httptest.NewRequest(\"GET\", \"/\", nil)\n\tu := req.URL\n\tw := httptest.NewRecorder()\n\n\tb.ReportAllocs()\n\n\t// Add routes\n\tfor _, route := range routes {\n\t\te.Add(route.Method, route.Path, func(c Context) error {\n\t\t\treturn nil\n\t\t})\n\t}\n\n\t// Find routes\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, route := range routes {\n\t\t\treq.Method = route.Method\n\t\t\tu.Path = route.Path\n\t\t\te.ServeHTTP(w, req)\n\t\t}\n\t}\n}\n\nfunc BenchmarkEchoStaticRoutes(b *testing.B) {\n\tbenchmarkEchoRoutes(b, staticRoutes)\n}\n\nfunc BenchmarkEchoStaticRoutesMisses(b *testing.B) {\n\tbenchmarkEchoRoutes(b, staticRoutes)\n}\n\nfunc BenchmarkEchoGitHubAPI(b *testing.B) {\n\tbenchmarkEchoRoutes(b, gitHubAPI)\n}\n\nfunc BenchmarkEchoGitHubAPIMisses(b *testing.B) {\n\tbenchmarkEchoRoutes(b, gitHubAPI)\n}\n\nfunc BenchmarkEchoParseAPI(b *testing.B) {\n\tbenchmarkEchoRoutes(b, parseAPI)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.6123046875,
          "content": "module github.com/labstack/echo/v4\n\ngo 1.20\n\nrequire (\n\tgithub.com/labstack/gommon v0.4.2\n\tgithub.com/stretchr/testify v1.10.0\n\tgithub.com/valyala/fasttemplate v1.2.2\n\tgolang.org/x/crypto v0.31.0\n\tgolang.org/x/net v0.33.0\n\tgolang.org/x/time v0.8.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/valyala/bytebufferpool v1.0.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.7548828125,
          "content": "github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/labstack/gommon v0.4.2 h1:F8qTUNXgG1+6WQmqoUWnz8WiEU60mXVVw0P4ht1WRA0=\ngithub.com/labstack/gommon v0.4.2/go.mod h1:QlUFxVM+SNXhDL/Z7YhocGIBYOiwB0mXm1+1bAPHPyU=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=\ngithub.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=\ngithub.com/valyala/fasttemplate v1.2.2 h1:lxLXG0uE3Qnshl9QyaK6XJxMXlQZELvChBOCmQD0Loo=\ngithub.com/valyala/fasttemplate v1.2.2/go.mod h1:KHLXt3tVN2HBp8eijSv/kGJopbvo7S+qRAEEKiv+SiQ=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/time v0.8.0 h1:9i3RxcPv3PZnitoVGMPDKZSq1xW1gK1Xy3ArNOGZfEg=\ngolang.org/x/time v0.8.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "group.go",
          "type": "blob",
          "size": 4.8720703125,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"net/http\"\n)\n\n// Group is a set of sub-routes for a specified route. It can be used for inner\n// routes that share a common middleware or functionality that should be separate\n// from the parent echo instance while still inheriting from it.\ntype Group struct {\n\tcommon\n\thost       string\n\tprefix     string\n\techo       *Echo\n\tmiddleware []MiddlewareFunc\n}\n\n// Use implements `Echo#Use()` for sub-routes within the Group.\nfunc (g *Group) Use(middleware ...MiddlewareFunc) {\n\tg.middleware = append(g.middleware, middleware...)\n\tif len(g.middleware) == 0 {\n\t\treturn\n\t}\n\t// group level middlewares are different from Echo `Pre` and `Use` middlewares (those are global). Group level middlewares\n\t// are only executed if they are added to the Router with route.\n\t// So we register catch all route (404 is a safe way to emulate route match) for this group and now during routing the\n\t// Router would find route to match our request path and therefore guarantee the middleware(s) will get executed.\n\tg.RouteNotFound(\"\", NotFoundHandler)\n\tg.RouteNotFound(\"/*\", NotFoundHandler)\n}\n\n// CONNECT implements `Echo#CONNECT()` for sub-routes within the Group.\nfunc (g *Group) CONNECT(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn g.Add(http.MethodConnect, path, h, m...)\n}\n\n// DELETE implements `Echo#DELETE()` for sub-routes within the Group.\nfunc (g *Group) DELETE(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn g.Add(http.MethodDelete, path, h, m...)\n}\n\n// GET implements `Echo#GET()` for sub-routes within the Group.\nfunc (g *Group) GET(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn g.Add(http.MethodGet, path, h, m...)\n}\n\n// HEAD implements `Echo#HEAD()` for sub-routes within the Group.\nfunc (g *Group) HEAD(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn g.Add(http.MethodHead, path, h, m...)\n}\n\n// OPTIONS implements `Echo#OPTIONS()` for sub-routes within the Group.\nfunc (g *Group) OPTIONS(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn g.Add(http.MethodOptions, path, h, m...)\n}\n\n// PATCH implements `Echo#PATCH()` for sub-routes within the Group.\nfunc (g *Group) PATCH(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn g.Add(http.MethodPatch, path, h, m...)\n}\n\n// POST implements `Echo#POST()` for sub-routes within the Group.\nfunc (g *Group) POST(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn g.Add(http.MethodPost, path, h, m...)\n}\n\n// PUT implements `Echo#PUT()` for sub-routes within the Group.\nfunc (g *Group) PUT(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn g.Add(http.MethodPut, path, h, m...)\n}\n\n// TRACE implements `Echo#TRACE()` for sub-routes within the Group.\nfunc (g *Group) TRACE(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn g.Add(http.MethodTrace, path, h, m...)\n}\n\n// Any implements `Echo#Any()` for sub-routes within the Group.\nfunc (g *Group) Any(path string, handler HandlerFunc, middleware ...MiddlewareFunc) []*Route {\n\troutes := make([]*Route, len(methods))\n\tfor i, m := range methods {\n\t\troutes[i] = g.Add(m, path, handler, middleware...)\n\t}\n\treturn routes\n}\n\n// Match implements `Echo#Match()` for sub-routes within the Group.\nfunc (g *Group) Match(methods []string, path string, handler HandlerFunc, middleware ...MiddlewareFunc) []*Route {\n\troutes := make([]*Route, len(methods))\n\tfor i, m := range methods {\n\t\troutes[i] = g.Add(m, path, handler, middleware...)\n\t}\n\treturn routes\n}\n\n// Group creates a new sub-group with prefix and optional sub-group-level middleware.\nfunc (g *Group) Group(prefix string, middleware ...MiddlewareFunc) (sg *Group) {\n\tm := make([]MiddlewareFunc, 0, len(g.middleware)+len(middleware))\n\tm = append(m, g.middleware...)\n\tm = append(m, middleware...)\n\tsg = g.echo.Group(g.prefix+prefix, m...)\n\tsg.host = g.host\n\treturn\n}\n\n// File implements `Echo#File()` for sub-routes within the Group.\nfunc (g *Group) File(path, file string) {\n\tg.file(path, file, g.GET)\n}\n\n// RouteNotFound implements `Echo#RouteNotFound()` for sub-routes within the Group.\n//\n// Example: `g.RouteNotFound(\"/*\", func(c echo.Context) error { return c.NoContent(http.StatusNotFound) })`\nfunc (g *Group) RouteNotFound(path string, h HandlerFunc, m ...MiddlewareFunc) *Route {\n\treturn g.Add(RouteNotFound, path, h, m...)\n}\n\n// Add implements `Echo#Add()` for sub-routes within the Group.\nfunc (g *Group) Add(method, path string, handler HandlerFunc, middleware ...MiddlewareFunc) *Route {\n\t// Combine into a new slice to avoid accidentally passing the same slice for\n\t// multiple routes, which would lead to later add() calls overwriting the\n\t// middleware from earlier calls.\n\tm := make([]MiddlewareFunc, 0, len(g.middleware)+len(middleware))\n\tm = append(m, g.middleware...)\n\tm = append(m, middleware...)\n\treturn g.echo.add(g.host, method, g.prefix+path, handler, m...)\n}\n"
        },
        {
          "name": "group_fs.go",
          "type": "blob",
          "size": 1.0537109375,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"io/fs\"\n\t\"net/http\"\n)\n\n// Static implements `Echo#Static()` for sub-routes within the Group.\nfunc (g *Group) Static(pathPrefix, fsRoot string) {\n\tsubFs := MustSubFS(g.echo.Filesystem, fsRoot)\n\tg.StaticFS(pathPrefix, subFs)\n}\n\n// StaticFS implements `Echo#StaticFS()` for sub-routes within the Group.\n//\n// When dealing with `embed.FS` use `fs := echo.MustSubFS(fs, \"rootDirectory\") to create sub fs which uses necessary\n// prefix for directory path. This is necessary as `//go:embed assets/images` embeds files with paths\n// including `assets/images` as their prefix.\nfunc (g *Group) StaticFS(pathPrefix string, filesystem fs.FS) {\n\tg.Add(\n\t\thttp.MethodGet,\n\t\tpathPrefix+\"*\",\n\t\tStaticDirectoryHandler(filesystem, false),\n\t)\n}\n\n// FileFS implements `Echo#FileFS()` for sub-routes within the Group.\nfunc (g *Group) FileFS(path, file string, filesystem fs.FS, m ...MiddlewareFunc) *Route {\n\treturn g.GET(path, StaticFileHandler(file, filesystem), m...)\n}\n"
        },
        {
          "name": "group_fs_test.go",
          "type": "blob",
          "size": 2.3349609375,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"github.com/stretchr/testify/assert\"\n\t\"io/fs\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"testing\"\n)\n\nfunc TestGroup_FileFS(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname             string\n\t\twhenPath         string\n\t\twhenFile         string\n\t\twhenFS           fs.FS\n\t\tgivenURL         string\n\t\texpectCode       int\n\t\texpectStartsWith []byte\n\t}{\n\t\t{\n\t\t\tname:             \"ok\",\n\t\t\twhenPath:         \"/walle\",\n\t\t\twhenFS:           os.DirFS(\"_fixture/images\"),\n\t\t\twhenFile:         \"walle.png\",\n\t\t\tgivenURL:         \"/assets/walle\",\n\t\t\texpectCode:       http.StatusOK,\n\t\t\texpectStartsWith: []byte{0x89, 0x50, 0x4e},\n\t\t},\n\t\t{\n\t\t\tname:             \"nok, requesting invalid path\",\n\t\t\twhenPath:         \"/walle\",\n\t\t\twhenFS:           os.DirFS(\"_fixture/images\"),\n\t\t\twhenFile:         \"walle.png\",\n\t\t\tgivenURL:         \"/assets/walle.png\",\n\t\t\texpectCode:       http.StatusNotFound,\n\t\t\texpectStartsWith: []byte(`{\"message\":\"Not Found\"}`),\n\t\t},\n\t\t{\n\t\t\tname:             \"nok, serving not existent file from filesystem\",\n\t\t\twhenPath:         \"/walle\",\n\t\t\twhenFS:           os.DirFS(\"_fixture/images\"),\n\t\t\twhenFile:         \"not-existent.png\",\n\t\t\tgivenURL:         \"/assets/walle\",\n\t\t\texpectCode:       http.StatusNotFound,\n\t\t\texpectStartsWith: []byte(`{\"message\":\"Not Found\"}`),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\tg := e.Group(\"/assets\")\n\t\t\tg.FileFS(tc.whenPath, tc.whenFile, tc.whenFS)\n\n\t\t\treq := httptest.NewRequest(http.MethodGet, tc.givenURL, nil)\n\t\t\trec := httptest.NewRecorder()\n\n\t\t\te.ServeHTTP(rec, req)\n\n\t\t\tassert.Equal(t, tc.expectCode, rec.Code)\n\n\t\t\tbody := rec.Body.Bytes()\n\t\t\tif len(body) > len(tc.expectStartsWith) {\n\t\t\t\tbody = body[:len(tc.expectStartsWith)]\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectStartsWith, body)\n\t\t})\n\t}\n}\n\nfunc TestGroup_StaticPanic(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname      string\n\t\tgivenRoot string\n\t}{\n\t\t{\n\t\t\tname:      \"panics for ../\",\n\t\t\tgivenRoot: \"../images\",\n\t\t},\n\t\t{\n\t\t\tname:      \"panics for /\",\n\t\t\tgivenRoot: \"/images\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\te.Filesystem = os.DirFS(\"./\")\n\n\t\t\tg := e.Group(\"/assets\")\n\n\t\t\tassert.Panics(t, func() {\n\t\t\t\tg.Static(\"/images\", tc.givenRoot)\n\t\t\t})\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "group_test.go",
          "type": "blob",
          "size": 6.5078125,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// TODO: Fix me\nfunc TestGroup(t *testing.T) {\n\tg := New().Group(\"/group\")\n\th := func(Context) error { return nil }\n\tg.CONNECT(\"/\", h)\n\tg.DELETE(\"/\", h)\n\tg.GET(\"/\", h)\n\tg.HEAD(\"/\", h)\n\tg.OPTIONS(\"/\", h)\n\tg.PATCH(\"/\", h)\n\tg.POST(\"/\", h)\n\tg.PUT(\"/\", h)\n\tg.TRACE(\"/\", h)\n\tg.Any(\"/\", h)\n\tg.Match([]string{http.MethodGet, http.MethodPost}, \"/\", h)\n\tg.Static(\"/static\", \"/tmp\")\n\tg.File(\"/walle\", \"_fixture/images//walle.png\")\n}\n\nfunc TestGroupFile(t *testing.T) {\n\te := New()\n\tg := e.Group(\"/group\")\n\tg.File(\"/walle\", \"_fixture/images/walle.png\")\n\texpectedData, err := os.ReadFile(\"_fixture/images/walle.png\")\n\tassert.Nil(t, err)\n\treq := httptest.NewRequest(http.MethodGet, \"/group/walle\", nil)\n\trec := httptest.NewRecorder()\n\te.ServeHTTP(rec, req)\n\tassert.Equal(t, http.StatusOK, rec.Code)\n\tassert.Equal(t, expectedData, rec.Body.Bytes())\n}\n\nfunc TestGroupRouteMiddleware(t *testing.T) {\n\t// Ensure middleware slices are not re-used\n\te := New()\n\tg := e.Group(\"/group\")\n\th := func(Context) error { return nil }\n\tm1 := func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\treturn next(c)\n\t\t}\n\t}\n\tm2 := func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\treturn next(c)\n\t\t}\n\t}\n\tm3 := func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\treturn next(c)\n\t\t}\n\t}\n\tm4 := func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\treturn c.NoContent(404)\n\t\t}\n\t}\n\tm5 := func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\treturn c.NoContent(405)\n\t\t}\n\t}\n\tg.Use(m1, m2, m3)\n\tg.GET(\"/404\", h, m4)\n\tg.GET(\"/405\", h, m5)\n\n\tc, _ := request(http.MethodGet, \"/group/404\", e)\n\tassert.Equal(t, 404, c)\n\tc, _ = request(http.MethodGet, \"/group/405\", e)\n\tassert.Equal(t, 405, c)\n}\n\nfunc TestGroupRouteMiddlewareWithMatchAny(t *testing.T) {\n\t// Ensure middleware and match any routes do not conflict\n\te := New()\n\tg := e.Group(\"/group\")\n\tm1 := func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\treturn next(c)\n\t\t}\n\t}\n\tm2 := func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\treturn c.String(http.StatusOK, c.Path())\n\t\t}\n\t}\n\th := func(c Context) error {\n\t\treturn c.String(http.StatusOK, c.Path())\n\t}\n\tg.Use(m1)\n\tg.GET(\"/help\", h, m2)\n\tg.GET(\"/*\", h, m2)\n\tg.GET(\"\", h, m2)\n\te.GET(\"unrelated\", h, m2)\n\te.GET(\"*\", h, m2)\n\n\t_, m := request(http.MethodGet, \"/group/help\", e)\n\tassert.Equal(t, \"/group/help\", m)\n\t_, m = request(http.MethodGet, \"/group/help/other\", e)\n\tassert.Equal(t, \"/group/*\", m)\n\t_, m = request(http.MethodGet, \"/group/404\", e)\n\tassert.Equal(t, \"/group/*\", m)\n\t_, m = request(http.MethodGet, \"/group\", e)\n\tassert.Equal(t, \"/group\", m)\n\t_, m = request(http.MethodGet, \"/other\", e)\n\tassert.Equal(t, \"/*\", m)\n\t_, m = request(http.MethodGet, \"/\", e)\n\tassert.Equal(t, \"/*\", m)\n\n}\n\nfunc TestGroup_RouteNotFound(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname        string\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectCode  int\n\t}{\n\t\t{\n\t\t\tname:        \"404, route to static not found handler /group/a/c/xx\",\n\t\t\twhenURL:     \"/group/a/c/xx\",\n\t\t\texpectRoute: \"GET /group/a/c/xx\",\n\t\t\texpectCode:  http.StatusNotFound,\n\t\t},\n\t\t{\n\t\t\tname:        \"404, route to path param not found handler /group/a/:file\",\n\t\t\twhenURL:     \"/group/a/echo.exe\",\n\t\t\texpectRoute: \"GET /group/a/:file\",\n\t\t\texpectCode:  http.StatusNotFound,\n\t\t},\n\t\t{\n\t\t\tname:        \"404, route to any not found handler /group/*\",\n\t\t\twhenURL:     \"/group/b/echo.exe\",\n\t\t\texpectRoute: \"GET /group/*\",\n\t\t\texpectCode:  http.StatusNotFound,\n\t\t},\n\t\t{\n\t\t\tname:        \"200, route /group/a/c/df to /group/a/c/df\",\n\t\t\twhenURL:     \"/group/a/c/df\",\n\t\t\texpectRoute: \"GET /group/a/c/df\",\n\t\t\texpectCode:  http.StatusOK,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\tg := e.Group(\"/group\")\n\n\t\t\tokHandler := func(c Context) error {\n\t\t\t\treturn c.String(http.StatusOK, c.Request().Method+\" \"+c.Path())\n\t\t\t}\n\t\t\tnotFoundHandler := func(c Context) error {\n\t\t\t\treturn c.String(http.StatusNotFound, c.Request().Method+\" \"+c.Path())\n\t\t\t}\n\n\t\t\tg.GET(\"/\", okHandler)\n\t\t\tg.GET(\"/a/c/df\", okHandler)\n\t\t\tg.GET(\"/a/b*\", okHandler)\n\t\t\tg.PUT(\"/*\", okHandler)\n\n\t\t\tg.RouteNotFound(\"/a/c/xx\", notFoundHandler)  // static\n\t\t\tg.RouteNotFound(\"/a/:file\", notFoundHandler) // param\n\t\t\tg.RouteNotFound(\"/*\", notFoundHandler)       // any\n\n\t\t\treq := httptest.NewRequest(http.MethodGet, tc.whenURL, nil)\n\t\t\trec := httptest.NewRecorder()\n\n\t\t\te.ServeHTTP(rec, req)\n\n\t\t\tassert.Equal(t, tc.expectCode, rec.Code)\n\t\t\tassert.Equal(t, tc.expectRoute, rec.Body.String())\n\t\t})\n\t}\n}\n\nfunc TestGroup_RouteNotFoundWithMiddleware(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname           string\n\t\tgivenCustom404 bool\n\t\twhenURL        string\n\t\texpectBody     interface{}\n\t\texpectCode     int\n\t}{\n\t\t{\n\t\t\tname:           \"ok, custom 404 handler is called with middleware\",\n\t\t\tgivenCustom404: true,\n\t\t\twhenURL:        \"/group/test3\",\n\t\t\texpectBody:     \"GET /group/*\",\n\t\t\texpectCode:     http.StatusNotFound,\n\t\t},\n\t\t{\n\t\t\tname:           \"ok, default group 404 handler is called with middleware\",\n\t\t\tgivenCustom404: false,\n\t\t\twhenURL:        \"/group/test3\",\n\t\t\texpectBody:     \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t\texpectCode:     http.StatusNotFound,\n\t\t},\n\t\t{\n\t\t\tname:           \"ok, (no slash) default group 404 handler is called with middleware\",\n\t\t\tgivenCustom404: false,\n\t\t\twhenURL:        \"/group\",\n\t\t\texpectBody:     \"{\\\"message\\\":\\\"Not Found\\\"}\\n\",\n\t\t\texpectCode:     http.StatusNotFound,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\n\t\t\tokHandler := func(c Context) error {\n\t\t\t\treturn c.String(http.StatusOK, c.Request().Method+\" \"+c.Path())\n\t\t\t}\n\t\t\tnotFoundHandler := func(c Context) error {\n\t\t\t\treturn c.String(http.StatusNotFound, c.Request().Method+\" \"+c.Path())\n\t\t\t}\n\n\t\t\te := New()\n\t\t\te.GET(\"/test1\", okHandler)\n\t\t\te.RouteNotFound(\"/*\", notFoundHandler)\n\n\t\t\tg := e.Group(\"/group\")\n\t\t\tg.GET(\"/test1\", okHandler)\n\n\t\t\tmiddlewareCalled := false\n\t\t\tg.Use(func(next HandlerFunc) HandlerFunc {\n\t\t\t\treturn func(c Context) error {\n\t\t\t\t\tmiddlewareCalled = true\n\t\t\t\t\treturn next(c)\n\t\t\t\t}\n\t\t\t})\n\t\t\tif tc.givenCustom404 {\n\t\t\t\tg.RouteNotFound(\"/*\", notFoundHandler)\n\t\t\t}\n\n\t\t\treq := httptest.NewRequest(http.MethodGet, tc.whenURL, nil)\n\t\t\trec := httptest.NewRecorder()\n\n\t\t\te.ServeHTTP(rec, req)\n\n\t\t\tassert.True(t, middlewareCalled)\n\t\t\tassert.Equal(t, tc.expectCode, rec.Code)\n\t\t\tassert.Equal(t, tc.expectBody, rec.Body.String())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "ip.go",
          "type": "blob",
          "size": 9.712890625,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n)\n\n/**\nBy: https://github.com/tmshn (See: https://github.com/labstack/echo/pull/1478 , https://github.com/labstack/echox/pull/134 )\nSource: https://echo.labstack.com/guide/ip-address/\n\nIP address plays fundamental role in HTTP; it's used for access control, auditing, geo-based access analysis and more.\nEcho provides handy method [`Context#RealIP()`](https://godoc.org/github.com/labstack/echo#Context) for that.\n\nHowever, it is not trivial to retrieve the _real_ IP address from requests especially when you put L7 proxies before the application.\nIn such situation, _real_ IP needs to be relayed on HTTP layer from proxies to your app, but you must not trust HTTP headers unconditionally.\nOtherwise, you might give someone a chance of deceiving you. **A security risk!**\n\nTo retrieve IP address reliably/securely, you must let your application be aware of the entire architecture of your infrastructure.\nIn Echo, this can be done by configuring `Echo#IPExtractor` appropriately.\nThis guides show you why and how.\n\n> Note: if you dont' set `Echo#IPExtractor` explicitly, Echo fallback to legacy behavior, which is not a good choice.\n\nLet's start from two questions to know the right direction:\n\n1. Do you put any HTTP (L7) proxy in front of the application?\n    - It includes both cloud solutions (such as AWS ALB or GCP HTTP LB) and OSS ones (such as Nginx, Envoy or Istio ingress gateway).\n2. If yes, what HTTP header do your proxies use to pass client IP to the application?\n\n## Case 1. With no proxy\n\nIf you put no proxy (e.g.: directory facing to the internet), all you need to (and have to) see is IP address from network layer.\nAny HTTP header is untrustable because the clients have full control what headers to be set.\n\nIn this case, use `echo.ExtractIPDirect()`.\n\n```go\ne.IPExtractor = echo.ExtractIPDirect()\n```\n\n## Case 2. With proxies using `X-Forwarded-For` header\n\n[`X-Forwared-For` (XFF)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For) is the popular header\nto relay clients' IP addresses.\nAt each hop on the proxies, they append the request IP address at the end of the header.\n\nFollowing example diagram illustrates this behavior.\n\n```text\n┌──────────┐            ┌──────────┐            ┌──────────┐            ┌──────────┐\n│ \"Origin\" │───────────>│ Proxy 1  │───────────>│ Proxy 2  │───────────>│ Your app │\n│ (IP: a)  │            │ (IP: b)  │            │ (IP: c)  │            │          │\n└──────────┘            └──────────┘            └──────────┘            └──────────┘\n\nCase 1.\nXFF:  \"\"                    \"a\"                     \"a, b\"\n                                                    ~~~~~~\nCase 2.\nXFF:  \"x\"                   \"x, a\"                  \"x, a, b\"\n                                                    ~~~~~~~~~\n                                                    ↑ What your app will see\n```\n\nIn this case, use **first _untrustable_ IP reading from right**. Never use first one reading from left, as it is\nconfigurable by client. Here \"trustable\" means \"you are sure the IP address belongs to your infrastructure\".\nIn above example, if `b` and `c` are trustable, the IP address of the client is `a` for both cases, never be `x`.\n\nIn Echo, use `ExtractIPFromXFFHeader(...TrustOption)`.\n\n```go\ne.IPExtractor = echo.ExtractIPFromXFFHeader()\n```\n\nBy default, it trusts internal IP addresses (loopback, link-local unicast, private-use and unique local address\nfrom [RFC6890](https://tools.ietf.org/html/rfc6890), [RFC4291](https://tools.ietf.org/html/rfc4291) and\n[RFC4193](https://tools.ietf.org/html/rfc4193)).\nTo control this behavior, use [`TrustOption`](https://godoc.org/github.com/labstack/echo#TrustOption)s.\n\nE.g.:\n\n```go\ne.IPExtractor = echo.ExtractIPFromXFFHeader(\n\tTrustLinkLocal(false),\n\tTrustIPRanges(lbIPRange),\n)\n```\n\n- Ref: https://godoc.org/github.com/labstack/echo#TrustOption\n\n## Case 3. With proxies using `X-Real-IP` header\n\n`X-Real-IP` is another HTTP header to relay clients' IP addresses, but it carries only one address unlike XFF.\n\nIf your proxies set this header, use `ExtractIPFromRealIPHeader(...TrustOption)`.\n\n```go\ne.IPExtractor = echo.ExtractIPFromRealIPHeader()\n```\n\nAgain, it trusts internal IP addresses by default (loopback, link-local unicast, private-use and unique local address\nfrom [RFC6890](https://tools.ietf.org/html/rfc6890), [RFC4291](https://tools.ietf.org/html/rfc4291) and\n[RFC4193](https://tools.ietf.org/html/rfc4193)).\nTo control this behavior, use [`TrustOption`](https://godoc.org/github.com/labstack/echo#TrustOption)s.\n\n- Ref: https://godoc.org/github.com/labstack/echo#TrustOption\n\n> **Never forget** to configure the outermost proxy (i.e.; at the edge of your infrastructure) **not to pass through incoming headers**.\n> Otherwise there is a chance of fraud, as it is what clients can control.\n\n## About default behavior\n\nIn default behavior, Echo sees all of first XFF header, X-Real-IP header and IP from network layer.\n\nAs you might already notice, after reading this article, this is not good.\nSole reason this is default is just backward compatibility.\n\n## Private IP ranges\n\nSee: https://en.wikipedia.org/wiki/Private_network\n\nPrivate IPv4 address ranges (RFC 1918):\n* 10.0.0.0 – 10.255.255.255 (24-bit block)\n* 172.16.0.0 – 172.31.255.255 (20-bit block)\n* 192.168.0.0 – 192.168.255.255 (16-bit block)\n\nPrivate IPv6 address ranges:\n* fc00::/7 address block = RFC 4193 Unique Local Addresses (ULA)\n\n*/\n\ntype ipChecker struct {\n\ttrustExtraRanges []*net.IPNet\n\ttrustLoopback    bool\n\ttrustLinkLocal   bool\n\ttrustPrivateNet  bool\n}\n\n// TrustOption is config for which IP address to trust\ntype TrustOption func(*ipChecker)\n\n// TrustLoopback configures if you trust loopback address (default: true).\nfunc TrustLoopback(v bool) TrustOption {\n\treturn func(c *ipChecker) {\n\t\tc.trustLoopback = v\n\t}\n}\n\n// TrustLinkLocal configures if you trust link-local address (default: true).\nfunc TrustLinkLocal(v bool) TrustOption {\n\treturn func(c *ipChecker) {\n\t\tc.trustLinkLocal = v\n\t}\n}\n\n// TrustPrivateNet configures if you trust private network address (default: true).\nfunc TrustPrivateNet(v bool) TrustOption {\n\treturn func(c *ipChecker) {\n\t\tc.trustPrivateNet = v\n\t}\n}\n\n// TrustIPRange add trustable IP ranges using CIDR notation.\nfunc TrustIPRange(ipRange *net.IPNet) TrustOption {\n\treturn func(c *ipChecker) {\n\t\tc.trustExtraRanges = append(c.trustExtraRanges, ipRange)\n\t}\n}\n\nfunc newIPChecker(configs []TrustOption) *ipChecker {\n\tchecker := &ipChecker{trustLoopback: true, trustLinkLocal: true, trustPrivateNet: true}\n\tfor _, configure := range configs {\n\t\tconfigure(checker)\n\t}\n\treturn checker\n}\n\n// Go1.16+ added `ip.IsPrivate()` but until that use this implementation\nfunc isPrivateIPRange(ip net.IP) bool {\n\tif ip4 := ip.To4(); ip4 != nil {\n\t\treturn ip4[0] == 10 ||\n\t\t\tip4[0] == 172 && ip4[1]&0xf0 == 16 ||\n\t\t\tip4[0] == 192 && ip4[1] == 168\n\t}\n\treturn len(ip) == net.IPv6len && ip[0]&0xfe == 0xfc\n}\n\nfunc (c *ipChecker) trust(ip net.IP) bool {\n\tif c.trustLoopback && ip.IsLoopback() {\n\t\treturn true\n\t}\n\tif c.trustLinkLocal && ip.IsLinkLocalUnicast() {\n\t\treturn true\n\t}\n\tif c.trustPrivateNet && isPrivateIPRange(ip) {\n\t\treturn true\n\t}\n\tfor _, trustedRange := range c.trustExtraRanges {\n\t\tif trustedRange.Contains(ip) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IPExtractor is a function to extract IP addr from http.Request.\n// Set appropriate one to Echo#IPExtractor.\n// See https://echo.labstack.com/guide/ip-address for more details.\ntype IPExtractor func(*http.Request) string\n\n// ExtractIPDirect extracts IP address using actual IP address.\n// Use this if your server faces to internet directory (i.e.: uses no proxy).\nfunc ExtractIPDirect() IPExtractor {\n\treturn extractIP\n}\n\nfunc extractIP(req *http.Request) string {\n\tra, _, _ := net.SplitHostPort(req.RemoteAddr)\n\treturn ra\n}\n\n// ExtractIPFromRealIPHeader extracts IP address using x-real-ip header.\n// Use this if you put proxy which uses this header.\nfunc ExtractIPFromRealIPHeader(options ...TrustOption) IPExtractor {\n\tchecker := newIPChecker(options)\n\treturn func(req *http.Request) string {\n\t\tdirectIP := extractIP(req)\n\t\trealIP := req.Header.Get(HeaderXRealIP)\n\t\tif realIP == \"\" {\n\t\t\treturn directIP\n\t\t}\n\n\t\tif checker.trust(net.ParseIP(directIP)) {\n\t\t\trealIP = strings.TrimPrefix(realIP, \"[\")\n\t\t\trealIP = strings.TrimSuffix(realIP, \"]\")\n\t\t\tif rIP := net.ParseIP(realIP); rIP != nil {\n\t\t\t\treturn realIP\n\t\t\t}\n\t\t}\n\n\t\treturn directIP\n\t}\n}\n\n// ExtractIPFromXFFHeader extracts IP address using x-forwarded-for header.\n// Use this if you put proxy which uses this header.\n// This returns nearest untrustable IP. If all IPs are trustable, returns furthest one (i.e.: XFF[0]).\nfunc ExtractIPFromXFFHeader(options ...TrustOption) IPExtractor {\n\tchecker := newIPChecker(options)\n\treturn func(req *http.Request) string {\n\t\tdirectIP := extractIP(req)\n\t\txffs := req.Header[HeaderXForwardedFor]\n\t\tif len(xffs) == 0 {\n\t\t\treturn directIP\n\t\t}\n\t\tips := append(strings.Split(strings.Join(xffs, \",\"), \",\"), directIP)\n\t\tfor i := len(ips) - 1; i >= 0; i-- {\n\t\t\tips[i] = strings.TrimSpace(ips[i])\n\t\t\tips[i] = strings.TrimPrefix(ips[i], \"[\")\n\t\t\tips[i] = strings.TrimSuffix(ips[i], \"]\")\n\t\t\tip := net.ParseIP(ips[i])\n\t\t\tif ip == nil {\n\t\t\t\t// Unable to parse IP; cannot trust entire records\n\t\t\t\treturn directIP\n\t\t\t}\n\t\t\tif !checker.trust(ip) {\n\t\t\t\treturn ip.String()\n\t\t\t}\n\t\t}\n\t\t// All of the IPs are trusted; return first element because it is furthest from server (best effort strategy).\n\t\treturn strings.TrimSpace(ips[0])\n\t}\n}\n"
        },
        {
          "name": "ip_test.go",
          "type": "blob",
          "size": 20.68359375,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc mustParseCIDR(s string) *net.IPNet {\n\t_, IPNet, err := net.ParseCIDR(s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn IPNet\n}\n\nfunc TestIPChecker_TrustOption(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname         string\n\t\tgivenOptions []TrustOption\n\t\twhenIP       string\n\t\texpect       bool\n\t}{\n\t\t{\n\t\t\tname: \"ip is within trust range, trusts additional private IPV6 network\",\n\t\t\tgivenOptions: []TrustOption{\n\t\t\t\tTrustLoopback(false),\n\t\t\t\tTrustLinkLocal(false),\n\t\t\t\tTrustPrivateNet(false),\n\t\t\t\t// this is private IPv6 ip\n\t\t\t\t// CIDR Notation: \t2001:0db8:0000:0000:0000:0000:0000:0000/48\n\t\t\t\t// Address: \t\t\t\t2001:0db8:0000:0000:0000:0000:0000:0103\n\t\t\t\t// Range start: \t\t2001:0db8:0000:0000:0000:0000:0000:0000\n\t\t\t\t// Range end: \t\t\t2001:0db8:0000:ffff:ffff:ffff:ffff:ffff\n\t\t\t\tTrustIPRange(mustParseCIDR(\"2001:db8::103/48\")),\n\t\t\t},\n\t\t\twhenIP: \"2001:0db8:0000:0000:0000:0000:0000:0103\",\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname: \"ip is within trust range, trusts additional private IPV6 network\",\n\t\t\tgivenOptions: []TrustOption{\n\t\t\t\tTrustIPRange(mustParseCIDR(\"2001:db8::103/48\")),\n\t\t\t},\n\t\t\twhenIP: \"2001:0db8:0000:0000:0000:0000:0000:0103\",\n\t\t\texpect: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tchecker := newIPChecker(tc.givenOptions)\n\n\t\t\tresult := checker.trust(net.ParseIP(tc.whenIP))\n\t\t\tassert.Equal(t, tc.expect, result)\n\t\t})\n\t}\n}\n\nfunc TestTrustIPRange(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname       string\n\t\tgivenRange string\n\t\twhenIP     string\n\t\texpect     bool\n\t}{\n\t\t{\n\t\t\tname: \"ip is within trust range, IPV6 network range\",\n\t\t\t// CIDR Notation: 2001:0db8:0000:0000:0000:0000:0000:0000/48\n\t\t\t// Address:       2001:0db8:0000:0000:0000:0000:0000:0103\n\t\t\t// Range start:   2001:0db8:0000:0000:0000:0000:0000:0000\n\t\t\t// Range end:     2001:0db8:0000:ffff:ffff:ffff:ffff:ffff\n\t\t\tgivenRange: \"2001:db8::103/48\",\n\t\t\twhenIP:     \"2001:0db8:0000:0000:0000:0000:0000:0103\",\n\t\t\texpect:     true,\n\t\t},\n\t\t{\n\t\t\tname:       \"ip is outside (upper bounds) of trust range, IPV6 network range\",\n\t\t\tgivenRange: \"2001:db8::103/48\",\n\t\t\twhenIP:     \"2001:0db8:0001:0000:0000:0000:0000:0000\",\n\t\t\texpect:     false,\n\t\t},\n\t\t{\n\t\t\tname:       \"ip is outside (lower bounds) of trust range, IPV6 network range\",\n\t\t\tgivenRange: \"2001:db8::103/48\",\n\t\t\twhenIP:     \"2001:0db7:ffff:ffff:ffff:ffff:ffff:ffff\",\n\t\t\texpect:     false,\n\t\t},\n\t\t{\n\t\t\tname: \"ip is within trust range, IPV4 network range\",\n\t\t\t// CIDR Notation: 8.8.8.8/24\n\t\t\t// Address:       8.8.8.8\n\t\t\t// Range start:   8.8.8.0\n\t\t\t// Range end:     8.8.8.255\n\t\t\tgivenRange: \"8.8.8.0/24\",\n\t\t\twhenIP:     \"8.8.8.8\",\n\t\t\texpect:     true,\n\t\t},\n\t\t{\n\t\t\tname: \"ip is within trust range, IPV4 network range\",\n\t\t\t// CIDR Notation: 8.8.8.8/24\n\t\t\t// Address:       8.8.8.8\n\t\t\t// Range start:   8.8.8.0\n\t\t\t// Range end:     8.8.8.255\n\t\t\tgivenRange: \"8.8.8.0/24\",\n\t\t\twhenIP:     \"8.8.8.8\",\n\t\t\texpect:     true,\n\t\t},\n\t\t{\n\t\t\tname:       \"ip is outside (upper bounds) of trust range, IPV4 network range\",\n\t\t\tgivenRange: \"8.8.8.0/24\",\n\t\t\twhenIP:     \"8.8.9.0\",\n\t\t\texpect:     false,\n\t\t},\n\t\t{\n\t\t\tname:       \"ip is outside (lower bounds) of trust range, IPV4 network range\",\n\t\t\tgivenRange: \"8.8.8.0/24\",\n\t\t\twhenIP:     \"8.8.7.255\",\n\t\t\texpect:     false,\n\t\t},\n\t\t{\n\t\t\tname:       \"public ip, trust everything in IPV4 network range\",\n\t\t\tgivenRange: \"0.0.0.0/0\",\n\t\t\twhenIP:     \"8.8.8.8\",\n\t\t\texpect:     true,\n\t\t},\n\t\t{\n\t\t\tname:       \"internal ip, trust everything in IPV4 network range\",\n\t\t\tgivenRange: \"0.0.0.0/0\",\n\t\t\twhenIP:     \"127.0.10.1\",\n\t\t\texpect:     true,\n\t\t},\n\t\t{\n\t\t\tname:       \"public ip, trust everything in IPV6 network range\",\n\t\t\tgivenRange: \"::/0\",\n\t\t\twhenIP:     \"2a00:1450:4026:805::200e\",\n\t\t\texpect:     true,\n\t\t},\n\t\t{\n\t\t\tname:       \"internal ip, trust everything in IPV6 network range\",\n\t\t\tgivenRange: \"::/0\",\n\t\t\twhenIP:     \"0:0:0:0:0:0:0:1\",\n\t\t\texpect:     true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tcidr := mustParseCIDR(tc.givenRange)\n\t\t\tchecker := newIPChecker([]TrustOption{\n\t\t\t\tTrustLoopback(false),   // disable to avoid interference\n\t\t\t\tTrustLinkLocal(false),  // disable to avoid interference\n\t\t\t\tTrustPrivateNet(false), // disable to avoid interference\n\n\t\t\t\tTrustIPRange(cidr),\n\t\t\t})\n\n\t\t\tresult := checker.trust(net.ParseIP(tc.whenIP))\n\t\t\tassert.Equal(t, tc.expect, result)\n\t\t})\n\t}\n}\n\nfunc TestTrustPrivateNet(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname   string\n\t\twhenIP string\n\t\texpect bool\n\t}{\n\t\t{\n\t\t\tname:   \"do not trust public IPv4 address\",\n\t\t\twhenIP: \"8.8.8.8\",\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"do not trust public IPv6 address\",\n\t\t\twhenIP: \"2a00:1450:4026:805::200e\",\n\t\t\texpect: false,\n\t\t},\n\n\t\t{ // Class A: 10.0.0.0 — 10.255.255.255\n\t\t\tname:   \"do not trust IPv4 just outside of class A (lower bounds)\",\n\t\t\twhenIP: \"9.255.255.255\",\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"do not trust IPv4 just outside of class A (upper bounds)\",\n\t\t\twhenIP: \"11.0.0.0\",\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"trust IPv4 of class A (lower bounds)\",\n\t\t\twhenIP: \"10.0.0.0\",\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"trust IPv4 of class A (upper bounds)\",\n\t\t\twhenIP: \"10.255.255.255\",\n\t\t\texpect: true,\n\t\t},\n\n\t\t{ // Class B: 172.16.0.0 — 172.31.255.255\n\t\t\tname:   \"do not trust IPv4 just outside of class B (lower bounds)\",\n\t\t\twhenIP: \"172.15.255.255\",\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"do not trust IPv4 just outside of class B (upper bounds)\",\n\t\t\twhenIP: \"172.32.0.0\",\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"trust IPv4 of class B (lower bounds)\",\n\t\t\twhenIP: \"172.16.0.0\",\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"trust IPv4 of class B (upper bounds)\",\n\t\t\twhenIP: \"172.31.255.255\",\n\t\t\texpect: true,\n\t\t},\n\n\t\t{ // Class C: 192.168.0.0 — 192.168.255.255\n\t\t\tname:   \"do not trust IPv4 just outside of class C (lower bounds)\",\n\t\t\twhenIP: \"192.167.255.255\",\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"do not trust IPv4 just outside of class C (upper bounds)\",\n\t\t\twhenIP: \"192.169.0.0\",\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"trust IPv4 of class C (lower bounds)\",\n\t\t\twhenIP: \"192.168.0.0\",\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"trust IPv4 of class C (upper bounds)\",\n\t\t\twhenIP: \"192.168.255.255\",\n\t\t\texpect: true,\n\t\t},\n\n\t\t{ // fc00::/7 address block = RFC 4193 Unique Local Addresses (ULA)\n\t\t\t// splits the address block in two equally sized halves, fc00::/8 and fd00::/8.\n\t\t\t// https://en.wikipedia.org/wiki/Unique_local_address\n\t\t\tname:   \"trust IPv6 private address\",\n\t\t\twhenIP: \"fdfc:3514:2cb3:4bd5::\",\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"do not trust IPv6 just out of /fd (upper bounds)\",\n\t\t\twhenIP: \"/fe00:0000:0000:0000:0000\",\n\t\t\texpect: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tchecker := newIPChecker([]TrustOption{\n\t\t\t\tTrustLoopback(false),  // disable to avoid interference\n\t\t\t\tTrustLinkLocal(false), // disable to avoid interference\n\n\t\t\t\tTrustPrivateNet(true),\n\t\t\t})\n\n\t\t\tresult := checker.trust(net.ParseIP(tc.whenIP))\n\t\t\tassert.Equal(t, tc.expect, result)\n\t\t})\n\t}\n}\n\nfunc TestTrustLinkLocal(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname   string\n\t\twhenIP string\n\t\texpect bool\n\t}{\n\t\t{\n\t\t\tname:   \"trust link local IPv4 address (lower bounds)\",\n\t\t\twhenIP: \"169.254.0.0\",\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"trust link local  IPv4 address (upper bounds)\",\n\t\t\twhenIP: \"169.254.255.255\",\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"do not trust link local IPv4 address (outside of lower bounds)\",\n\t\t\twhenIP: \"169.253.255.255\",\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"do not trust link local  IPv4 address (outside of upper bounds)\",\n\t\t\twhenIP: \"169.255.0.0\",\n\t\t\texpect: false,\n\t\t},\n\t\t{\n\t\t\tname:   \"trust link local IPv6 address \",\n\t\t\twhenIP: \"fe80::1\",\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"do not trust link local IPv6 address \",\n\t\t\twhenIP: \"fec0::1\",\n\t\t\texpect: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tchecker := newIPChecker([]TrustOption{\n\t\t\t\tTrustLoopback(false),   // disable to avoid interference\n\t\t\t\tTrustPrivateNet(false), // disable to avoid interference\n\n\t\t\t\tTrustLinkLocal(true),\n\t\t\t})\n\n\t\t\tresult := checker.trust(net.ParseIP(tc.whenIP))\n\t\t\tassert.Equal(t, tc.expect, result)\n\t\t})\n\t}\n}\n\nfunc TestTrustLoopback(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname   string\n\t\twhenIP string\n\t\texpect bool\n\t}{\n\t\t{\n\t\t\tname:   \"trust IPv4 as localhost\",\n\t\t\twhenIP: \"127.0.0.1\",\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"trust IPv6 as localhost\",\n\t\t\twhenIP: \"::1\",\n\t\t\texpect: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"do not trust public ip as localhost\",\n\t\t\twhenIP: \"8.8.8.8\",\n\t\t\texpect: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tchecker := newIPChecker([]TrustOption{\n\t\t\t\tTrustLinkLocal(false),  // disable to avoid interference\n\t\t\t\tTrustPrivateNet(false), // disable to avoid interference\n\n\t\t\t\tTrustLoopback(true),\n\t\t\t})\n\n\t\t\tresult := checker.trust(net.ParseIP(tc.whenIP))\n\t\t\tassert.Equal(t, tc.expect, result)\n\t\t})\n\t}\n}\n\nfunc TestExtractIPDirect(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname        string\n\t\twhenRequest http.Request\n\t\texpectIP    string\n\t}{\n\t\t{\n\t\t\tname: \"request has no headers, extracts IP from request remote addr\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tRemoteAddr: \"203.0.113.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"203.0.113.1\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from external IP has X-Real-Ip header, extractor still extracts IP from request remote addr\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXRealIP: []string{\"203.0.113.10\"},\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"203.0.113.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"203.0.113.1\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from internal IP and has Real-IP header, extractor still extracts internal IP from request remote addr\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXRealIP: []string{\"203.0.113.10\"},\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"127.0.0.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"127.0.0.1\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from external IP and has XFF + Real-IP header, extractor still extracts external IP from request remote addr\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXRealIP:       []string{\"203.0.113.10\"},\n\t\t\t\t\tHeaderXForwardedFor: []string{\"192.0.2.106, 198.51.100.105, fc00::104, 2001:db8::103, 192.168.0.102, 169.254.0.101\"},\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"203.0.113.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"203.0.113.1\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from internal IP and has XFF + Real-IP header, extractor still extracts internal IP from request remote addr\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXRealIP:       []string{\"127.0.0.1\"},\n\t\t\t\t\tHeaderXForwardedFor: []string{\"192.0.2.106, 198.51.100.105, fc00::104, 2001:db8::103, 192.168.0.102, 169.254.0.101\"},\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"127.0.0.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"127.0.0.1\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from external IP and has XFF header, extractor still extracts external IP from request remote addr\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXForwardedFor: []string{\"192.0.2.106, 198.51.100.105, fc00::104, 2001:db8::103, 192.168.0.102, 169.254.0.101\"},\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"203.0.113.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"203.0.113.1\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from internal IP and has XFF header, extractor still extracts internal IP from request remote addr\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXForwardedFor: []string{\"192.0.2.106, 198.51.100.105, fc00::104, 2001:db8::103, 192.168.0.102, 169.254.0.101\"},\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"127.0.0.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"127.0.0.1\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from internal IP and has INVALID XFF header, extractor still extracts internal IP from request remote addr\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXForwardedFor: []string{\"this.is.broken.lol, 169.254.0.101\"},\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"127.0.0.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"127.0.0.1\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\textractedIP := ExtractIPDirect()(&tc.whenRequest)\n\t\t\tassert.Equal(t, tc.expectIP, extractedIP)\n\t\t})\n\t}\n}\n\nfunc TestExtractIPFromRealIPHeader(t *testing.T) {\n\t_, ipForRemoteAddrExternalRange, _ := net.ParseCIDR(\"203.0.113.0/24\")\n\t_, ipv6ForRemoteAddrExternalRange, _ := net.ParseCIDR(\"2001:db8::/64\")\n\n\tvar testCases = []struct {\n\t\tname              string\n\t\tgivenTrustOptions []TrustOption\n\t\twhenRequest       http.Request\n\t\texpectIP          string\n\t}{\n\t\t{\n\t\t\tname: \"request has no headers, extracts IP from request remote addr\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tRemoteAddr: \"203.0.113.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"203.0.113.1\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from external IP has INVALID external X-Real-Ip header, extract IP from remote addr\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXRealIP: []string{\"xxx.yyy.zzz.ccc\"}, // <-- this is invalid\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"203.0.113.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"203.0.113.1\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from external IP has valid + UNTRUSTED external X-Real-Ip header, extract IP from remote addr\",\n\t\t\tgivenTrustOptions: []TrustOption{ // case for \"trust direct-facing proxy\"\n\t\t\t\tTrustIPRange(ipForRemoteAddrExternalRange), // we trust external IP range \"203.0.113.199/24\"\n\t\t\t},\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXRealIP: []string{\"203.0.113.199\"},\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"8.8.8.8:8080\", // <-- this is untrusted\n\t\t\t},\n\t\t\texpectIP: \"8.8.8.8\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from external IP has valid + UNTRUSTED external X-Real-Ip header, extract IP from remote addr\",\n\t\t\tgivenTrustOptions: []TrustOption{ // case for \"trust direct-facing proxy\"\n\t\t\t\tTrustIPRange(ipv6ForRemoteAddrExternalRange), // we trust external IP range \"203.0.113.199/24\"\n\t\t\t},\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXRealIP: []string{\"[bc01:1010::9090:1888]\"},\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"[fe64:aa10::1]:8080\", // <-- this is untrusted\n\t\t\t},\n\t\t\texpectIP: \"fe64:aa10::1\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from external IP has valid + TRUSTED X-Real-Ip header, extract IP from X-Real-Ip header\",\n\t\t\tgivenTrustOptions: []TrustOption{ // case for \"trust direct-facing proxy\"\n\t\t\t\tTrustIPRange(ipForRemoteAddrExternalRange), // we trust external IP range \"203.0.113.0/24\"\n\t\t\t},\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXRealIP: []string{\"8.8.8.8\"},\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"203.0.113.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"8.8.8.8\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from external IP has valid + TRUSTED X-Real-Ip header, extract IP from X-Real-Ip header\",\n\t\t\tgivenTrustOptions: []TrustOption{ // case for \"trust direct-facing proxy\"\n\t\t\t\tTrustIPRange(ipv6ForRemoteAddrExternalRange), // we trust external IP range \"2001:db8::/64\"\n\t\t\t},\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXRealIP: []string{\"[fe64:db8::113:199]\"},\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"[2001:db8::113:1]:8080\",\n\t\t\t},\n\t\t\texpectIP: \"fe64:db8::113:199\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from external IP has XFF and valid + TRUSTED X-Real-Ip header, extract IP from X-Real-Ip header\",\n\t\t\tgivenTrustOptions: []TrustOption{ // case for \"trust direct-facing proxy\"\n\t\t\t\tTrustIPRange(ipForRemoteAddrExternalRange), // we trust external IP range \"203.0.113.199/24\"\n\t\t\t},\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXRealIP:       []string{\"8.8.8.8\"},\n\t\t\t\t\tHeaderXForwardedFor: []string{\"1.1.1.1 ,8.8.8.8\"}, // <-- should not affect anything\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"203.0.113.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"8.8.8.8\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from external IP has XFF and valid + TRUSTED X-Real-Ip header, extract IP from X-Real-Ip header\",\n\t\t\tgivenTrustOptions: []TrustOption{ // case for \"trust direct-facing proxy\"\n\t\t\t\tTrustIPRange(ipv6ForRemoteAddrExternalRange), // we trust external IP range \"2001:db8::/64\"\n\t\t\t},\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXRealIP:       []string{\"[fe64:db8::113:199]\"},\n\t\t\t\t\tHeaderXForwardedFor: []string{\"[feab:cde9::113:198], [fe64:db8::113:199]\"}, // <-- should not affect anything\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"[2001:db8::113:1]:8080\",\n\t\t\t},\n\t\t\texpectIP: \"fe64:db8::113:199\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\textractedIP := ExtractIPFromRealIPHeader(tc.givenTrustOptions...)(&tc.whenRequest)\n\t\t\tassert.Equal(t, tc.expectIP, extractedIP)\n\t\t})\n\t}\n}\n\nfunc TestExtractIPFromXFFHeader(t *testing.T) {\n\t_, ipForRemoteAddrExternalRange, _ := net.ParseCIDR(\"203.0.113.199/24\")\n\t_, ipv6ForRemoteAddrExternalRange, _ := net.ParseCIDR(\"2001:db8::/64\")\n\n\tvar testCases = []struct {\n\t\tname              string\n\t\tgivenTrustOptions []TrustOption\n\t\twhenRequest       http.Request\n\t\texpectIP          string\n\t}{\n\t\t{\n\t\t\tname: \"request has no headers, extracts IP from request remote addr\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tRemoteAddr: \"203.0.113.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"203.0.113.1\",\n\t\t},\n\t\t{\n\t\t\tname: \"request has INVALID external XFF header, extract IP from remote addr\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXForwardedFor: []string{\"xxx.yyy.zzz.ccc, 127.0.0.2\"}, // <-- this is invalid\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"127.0.0.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"127.0.0.1\",\n\t\t},\n\t\t{\n\t\t\tname: \"request trusts all IPs in XFF header, extract IP from furthest in XFF chain\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXForwardedFor: []string{\"127.0.0.3, 127.0.0.2, 127.0.0.1\"},\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"127.0.0.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"127.0.0.3\",\n\t\t},\n\t\t{\n\t\t\tname: \"request trusts all IPs in XFF header, extract IP from furthest in XFF chain\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXForwardedFor: []string{\"[fe80::3], [fe80::2], [fe80::1]\"},\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"[fe80::1]:8080\",\n\t\t\t},\n\t\t\texpectIP: \"fe80::3\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from external IP has valid + UNTRUSTED external XFF header, extract IP from remote addr\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXForwardedFor: []string{\"203.0.113.199\"}, // <-- this is untrusted\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"203.0.113.1:8080\",\n\t\t\t},\n\t\t\texpectIP: \"203.0.113.1\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from external IP has valid + UNTRUSTED external XFF header, extract IP from remote addr\",\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXForwardedFor: []string{\"[2001:db8::1]\"}, // <-- this is untrusted\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"[2001:db8::2]:8080\",\n\t\t\t},\n\t\t\texpectIP: \"2001:db8::2\",\n\t\t},\n\t\t{\n\t\t\tname: \"request is from external IP is valid and has some IPs TRUSTED XFF header, extract IP from XFF header\",\n\t\t\tgivenTrustOptions: []TrustOption{\n\t\t\t\tTrustIPRange(ipForRemoteAddrExternalRange), // we trust external IP range \"203.0.113.199/24\"\n\t\t\t},\n\t\t\t// from request its seems that request has been proxied through 6 servers.\n\t\t\t// 1) 203.0.1.100 (this is external IP set by 203.0.100.100 which we do not trust - could be spoofed)\n\t\t\t// 2) 203.0.100.100 (this is outside of our network but set by 203.0.113.199 which we trust to set correct IPs)\n\t\t\t// 3) 203.0.113.199 (we trust, for example maybe our proxy from some other office)\n\t\t\t// 4) 192.168.1.100 (internal IP, some internal upstream loadbalancer ala SSL offloading with F5 products)\n\t\t\t// 5) 127.0.0.1 (is proxy on localhost. maybe we have Nginx in front of our Echo instance doing some routing)\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXForwardedFor: []string{\"203.0.1.100, 203.0.100.100, 203.0.113.199, 192.168.1.100\"},\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"127.0.0.1:8080\", // IP of proxy upstream of our APP\n\t\t\t},\n\t\t\texpectIP: \"203.0.100.100\", // this is first trusted IP in XFF chain\n\t\t},\n\t\t{\n\t\t\tname: \"request is from external IP is valid and has some IPs TRUSTED XFF header, extract IP from XFF header\",\n\t\t\tgivenTrustOptions: []TrustOption{\n\t\t\t\tTrustIPRange(ipv6ForRemoteAddrExternalRange), // we trust external IP range \"2001:db8::/64\"\n\t\t\t},\n\t\t\t// from request its seems that request has been proxied through 6 servers.\n\t\t\t// 1) 2001:db8:1::1:100 (this is external IP set by 2001:db8:2::100:100 which we do not trust - could be spoofed)\n\t\t\t// 2) 2001:db8:2::100:100  (this is outside of our network but set by 2001:db8::113:199 which we trust to set correct IPs)\n\t\t\t// 3) 2001:db8::113:199 (we trust, for example maybe our proxy from some other office)\n\t\t\t// 4) fd12:3456:789a:1::1 (internal IP, some internal upstream loadbalancer ala SSL offloading with F5 products)\n\t\t\t// 5) fe80::1 (is proxy on localhost. maybe we have Nginx in front of our Echo instance doing some routing)\n\t\t\twhenRequest: http.Request{\n\t\t\t\tHeader: http.Header{\n\t\t\t\t\tHeaderXForwardedFor: []string{\"[2001:db8:1::1:100], [2001:db8:2::100:100], [2001:db8::113:199], [fd12:3456:789a:1::1]\"},\n\t\t\t\t},\n\t\t\t\tRemoteAddr: \"[fe80::1]:8080\", // IP of proxy upstream of our APP\n\t\t\t},\n\t\t\texpectIP: \"2001:db8:2::100:100\", // this is first trusted IP in XFF chain\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\textractedIP := ExtractIPFromXFFHeader(tc.givenTrustOptions...)(&tc.whenRequest)\n\t\t\tassert.Equal(t, tc.expectIP, extractedIP)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "json.go",
          "type": "blob",
          "size": 1.248046875,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// DefaultJSONSerializer implements JSON encoding using encoding/json.\ntype DefaultJSONSerializer struct{}\n\n// Serialize converts an interface into a json and writes it to the response.\n// You can optionally use the indent parameter to produce pretty JSONs.\nfunc (d DefaultJSONSerializer) Serialize(c Context, i interface{}, indent string) error {\n\tenc := json.NewEncoder(c.Response())\n\tif indent != \"\" {\n\t\tenc.SetIndent(\"\", indent)\n\t}\n\treturn enc.Encode(i)\n}\n\n// Deserialize reads a JSON from a request body and converts it into an interface.\nfunc (d DefaultJSONSerializer) Deserialize(c Context, i interface{}) error {\n\terr := json.NewDecoder(c.Request().Body).Decode(i)\n\tif ute, ok := err.(*json.UnmarshalTypeError); ok {\n\t\treturn NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Unmarshal type error: expected=%v, got=%v, field=%v, offset=%v\", ute.Type, ute.Value, ute.Field, ute.Offset)).SetInternal(err)\n\t} else if se, ok := err.(*json.SyntaxError); ok {\n\t\treturn NewHTTPError(http.StatusBadRequest, fmt.Sprintf(\"Syntax error: offset=%v, error=%v\", se.Offset, se.Error())).SetInternal(err)\n\t}\n\treturn err\n}\n"
        },
        {
          "name": "json_test.go",
          "type": "blob",
          "size": 2.84765625,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"github.com/stretchr/testify/assert\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n)\n\n// Note this test is deliberately simple as there's not a lot to test.\n// Just need to ensure it writes JSONs. The heavy work is done by the context methods.\nfunc TestDefaultJSONCodec_Encode(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec).(*context)\n\n\t// Echo\n\tassert.Equal(t, e, c.Echo())\n\n\t// Request\n\tassert.NotNil(t, c.Request())\n\n\t// Response\n\tassert.NotNil(t, c.Response())\n\n\t//--------\n\t// Default JSON encoder\n\t//--------\n\n\tenc := new(DefaultJSONSerializer)\n\n\terr := enc.Serialize(c, user{1, \"Jon Snow\"}, \"\")\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, userJSON+\"\\n\", rec.Body.String())\n\t}\n\n\treq = httptest.NewRequest(http.MethodPost, \"/\", nil)\n\trec = httptest.NewRecorder()\n\tc = e.NewContext(req, rec).(*context)\n\terr = enc.Serialize(c, user{1, \"Jon Snow\"}, \"  \")\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, userJSONPretty+\"\\n\", rec.Body.String())\n\t}\n}\n\n// Note this test is deliberately simple as there's not a lot to test.\n// Just need to ensure it writes JSONs. The heavy work is done by the context methods.\nfunc TestDefaultJSONCodec_Decode(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(userJSON))\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec).(*context)\n\n\t// Echo\n\tassert.Equal(t, e, c.Echo())\n\n\t// Request\n\tassert.NotNil(t, c.Request())\n\n\t// Response\n\tassert.NotNil(t, c.Response())\n\n\t//--------\n\t// Default JSON encoder\n\t//--------\n\n\tenc := new(DefaultJSONSerializer)\n\n\tvar u = user{}\n\terr := enc.Deserialize(c, &u)\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, u, user{ID: 1, Name: \"Jon Snow\"})\n\t}\n\n\tvar userUnmarshalSyntaxError = user{}\n\treq = httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(invalidContent))\n\trec = httptest.NewRecorder()\n\tc = e.NewContext(req, rec).(*context)\n\terr = enc.Deserialize(c, &userUnmarshalSyntaxError)\n\tassert.IsType(t, &HTTPError{}, err)\n\tassert.EqualError(t, err, \"code=400, message=Syntax error: offset=1, error=invalid character 'i' looking for beginning of value, internal=invalid character 'i' looking for beginning of value\")\n\n\tvar userUnmarshalTypeError = struct {\n\t\tID   string `json:\"id\"`\n\t\tName string `json:\"name\"`\n\t}{}\n\n\treq = httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(userJSON))\n\trec = httptest.NewRecorder()\n\tc = e.NewContext(req, rec).(*context)\n\terr = enc.Deserialize(c, &userUnmarshalTypeError)\n\tassert.IsType(t, &HTTPError{}, err)\n\tassert.EqualError(t, err, \"code=400, message=Unmarshal type error: expected=string, got=number, field=id, offset=7, internal=json: cannot unmarshal number into Go struct field .id of type string\")\n\n}\n"
        },
        {
          "name": "log.go",
          "type": "blob",
          "size": 0.970703125,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"github.com/labstack/gommon/log\"\n\t\"io\"\n)\n\n// Logger defines the logging interface.\ntype Logger interface {\n\tOutput() io.Writer\n\tSetOutput(w io.Writer)\n\tPrefix() string\n\tSetPrefix(p string)\n\tLevel() log.Lvl\n\tSetLevel(v log.Lvl)\n\tSetHeader(h string)\n\tPrint(i ...interface{})\n\tPrintf(format string, args ...interface{})\n\tPrintj(j log.JSON)\n\tDebug(i ...interface{})\n\tDebugf(format string, args ...interface{})\n\tDebugj(j log.JSON)\n\tInfo(i ...interface{})\n\tInfof(format string, args ...interface{})\n\tInfoj(j log.JSON)\n\tWarn(i ...interface{})\n\tWarnf(format string, args ...interface{})\n\tWarnj(j log.JSON)\n\tError(i ...interface{})\n\tErrorf(format string, args ...interface{})\n\tErrorj(j log.JSON)\n\tFatal(i ...interface{})\n\tFatalj(j log.JSON)\n\tFatalf(format string, args ...interface{})\n\tPanic(i ...interface{})\n\tPanicj(j log.JSON)\n\tPanicf(format string, args ...interface{})\n}\n"
        },
        {
          "name": "middleware",
          "type": "tree",
          "content": null
        },
        {
          "name": "renderer.go",
          "type": "blob",
          "size": 0.8408203125,
          "content": "package echo\n\nimport \"io\"\n\n// Renderer is the interface that wraps the Render function.\ntype Renderer interface {\n\tRender(io.Writer, string, interface{}, Context) error\n}\n\n// TemplateRenderer is helper to ease creating renderers for `html/template` and `text/template` packages.\n// Example usage:\n//\n//\t\te.Renderer = &echo.TemplateRenderer{\n//\t\t\tTemplate: template.Must(template.ParseGlob(\"templates/*.html\")),\n//\t\t}\n//\n//\t  e.Renderer = &echo.TemplateRenderer{\n//\t\t\tTemplate: template.Must(template.New(\"hello\").Parse(\"Hello, {{.}}!\")),\n//\t\t}\ntype TemplateRenderer struct {\n\tTemplate interface {\n\t\tExecuteTemplate(wr io.Writer, name string, data any) error\n\t}\n}\n\n// Render renders the template with given data.\nfunc (t *TemplateRenderer) Render(w io.Writer, name string, data interface{}, c Context) error {\n\treturn t.Template.ExecuteTemplate(w, name, data)\n}\n"
        },
        {
          "name": "renderer_test.go",
          "type": "blob",
          "size": 0.623046875,
          "content": "package echo\n\nimport (\n\t\"github.com/stretchr/testify/assert\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestRenderWithTemplateRenderer(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodPost, \"/\", strings.NewReader(userJSON))\n\trec := httptest.NewRecorder()\n\n\tc := e.NewContext(req, rec)\n\n\te.Renderer = &TemplateRenderer{\n\t\tTemplate: template.Must(template.New(\"hello\").Parse(\"Hello, {{.}}!\")),\n\t}\n\n\terr := c.Render(http.StatusOK, \"hello\", \"Jon Snow\")\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, \"Hello, Jon Snow!\", rec.Body.String())\n\t}\n}\n"
        },
        {
          "name": "response.go",
          "type": "blob",
          "size": 3.447265625,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"net\"\n\t\"net/http\"\n)\n\n// Response wraps an http.ResponseWriter and implements its interface to be used\n// by an HTTP handler to construct an HTTP response.\n// See: https://golang.org/pkg/net/http/#ResponseWriter\ntype Response struct {\n\tWriter      http.ResponseWriter\n\techo        *Echo\n\tbeforeFuncs []func()\n\tafterFuncs  []func()\n\tStatus      int\n\tSize        int64\n\tCommitted   bool\n}\n\n// NewResponse creates a new instance of Response.\nfunc NewResponse(w http.ResponseWriter, e *Echo) (r *Response) {\n\treturn &Response{Writer: w, echo: e}\n}\n\n// Header returns the header map for the writer that will be sent by\n// WriteHeader. Changing the header after a call to WriteHeader (or Write) has\n// no effect unless the modified headers were declared as trailers by setting\n// the \"Trailer\" header before the call to WriteHeader (see example)\n// To suppress implicit response headers, set their value to nil.\n// Example: https://golang.org/pkg/net/http/#example_ResponseWriter_trailers\nfunc (r *Response) Header() http.Header {\n\treturn r.Writer.Header()\n}\n\n// Before registers a function which is called just before the response is written.\nfunc (r *Response) Before(fn func()) {\n\tr.beforeFuncs = append(r.beforeFuncs, fn)\n}\n\n// After registers a function which is called just after the response is written.\n// If the `Content-Length` is unknown, none of the after function is executed.\nfunc (r *Response) After(fn func()) {\n\tr.afterFuncs = append(r.afterFuncs, fn)\n}\n\n// WriteHeader sends an HTTP response header with status code. If WriteHeader is\n// not called explicitly, the first call to Write will trigger an implicit\n// WriteHeader(http.StatusOK). Thus explicit calls to WriteHeader are mainly\n// used to send error codes.\nfunc (r *Response) WriteHeader(code int) {\n\tif r.Committed {\n\t\tr.echo.Logger.Warn(\"response already committed\")\n\t\treturn\n\t}\n\tr.Status = code\n\tfor _, fn := range r.beforeFuncs {\n\t\tfn()\n\t}\n\tr.Writer.WriteHeader(r.Status)\n\tr.Committed = true\n}\n\n// Write writes the data to the connection as part of an HTTP reply.\nfunc (r *Response) Write(b []byte) (n int, err error) {\n\tif !r.Committed {\n\t\tif r.Status == 0 {\n\t\t\tr.Status = http.StatusOK\n\t\t}\n\t\tr.WriteHeader(r.Status)\n\t}\n\tn, err = r.Writer.Write(b)\n\tr.Size += int64(n)\n\tfor _, fn := range r.afterFuncs {\n\t\tfn()\n\t}\n\treturn\n}\n\n// Flush implements the http.Flusher interface to allow an HTTP handler to flush\n// buffered data to the client.\n// See [http.Flusher](https://golang.org/pkg/net/http/#Flusher)\nfunc (r *Response) Flush() {\n\terr := http.NewResponseController(r.Writer).Flush()\n\tif err != nil && errors.Is(err, http.ErrNotSupported) {\n\t\tpanic(errors.New(\"response writer flushing is not supported\"))\n\t}\n}\n\n// Hijack implements the http.Hijacker interface to allow an HTTP handler to\n// take over the connection.\n// See [http.Hijacker](https://golang.org/pkg/net/http/#Hijacker)\nfunc (r *Response) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\treturn http.NewResponseController(r.Writer).Hijack()\n}\n\n// Unwrap returns the original http.ResponseWriter.\n// ResponseController can be used to access the original http.ResponseWriter.\n// See [https://go.dev/blog/go1.20]\nfunc (r *Response) Unwrap() http.ResponseWriter {\n\treturn r.Writer\n}\n\nfunc (r *Response) reset(w http.ResponseWriter) {\n\tr.beforeFuncs = nil\n\tr.afterFuncs = nil\n\tr.Writer = w\n\tr.Size = 0\n\tr.Status = http.StatusOK\n\tr.Committed = false\n}\n"
        },
        {
          "name": "response_test.go",
          "type": "blob",
          "size": 2.416015625,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestResponse(t *testing.T) {\n\te := New()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec)\n\tres := &Response{echo: e, Writer: rec}\n\n\t// Before\n\tres.Before(func() {\n\t\tc.Response().Header().Set(HeaderServer, \"echo\")\n\t})\n\t// After\n\tres.After(func() {\n\t\tc.Response().Header().Set(HeaderXFrameOptions, \"DENY\")\n\t})\n\tres.Write([]byte(\"test\"))\n\tassert.Equal(t, \"echo\", rec.Header().Get(HeaderServer))\n\tassert.Equal(t, \"DENY\", rec.Header().Get(HeaderXFrameOptions))\n}\n\nfunc TestResponse_Write_FallsBackToDefaultStatus(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\tres := &Response{echo: e, Writer: rec}\n\n\tres.Write([]byte(\"test\"))\n\tassert.Equal(t, http.StatusOK, rec.Code)\n}\n\nfunc TestResponse_Write_UsesSetResponseCode(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\tres := &Response{echo: e, Writer: rec}\n\n\tres.Status = http.StatusBadRequest\n\tres.Write([]byte(\"test\"))\n\tassert.Equal(t, http.StatusBadRequest, rec.Code)\n}\n\nfunc TestResponse_Flush(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\tres := &Response{echo: e, Writer: rec}\n\n\tres.Write([]byte(\"test\"))\n\tres.Flush()\n\tassert.True(t, rec.Flushed)\n}\n\ntype testResponseWriter struct {\n}\n\nfunc (w *testResponseWriter) WriteHeader(statusCode int) {\n}\n\nfunc (w *testResponseWriter) Write([]byte) (int, error) {\n\treturn 0, nil\n}\n\nfunc (w *testResponseWriter) Header() http.Header {\n\treturn nil\n}\n\nfunc TestResponse_FlushPanics(t *testing.T) {\n\te := New()\n\trw := new(testResponseWriter)\n\tres := &Response{echo: e, Writer: rw}\n\n\t// we test that we behave as before unwrapping flushers - flushing writer that does not support it causes panic\n\tassert.PanicsWithError(t, \"response writer flushing is not supported\", func() {\n\t\tres.Flush()\n\t})\n}\n\nfunc TestResponse_ChangeStatusCodeBeforeWrite(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\tres := &Response{echo: e, Writer: rec}\n\n\tres.Before(func() {\n\t\tif 200 < res.Status && res.Status < 300 {\n\t\t\tres.Status = 200\n\t\t}\n\t})\n\n\tres.WriteHeader(209)\n\n\tassert.Equal(t, http.StatusOK, rec.Code)\n}\n\nfunc TestResponse_Unwrap(t *testing.T) {\n\te := New()\n\trec := httptest.NewRecorder()\n\tres := &Response{echo: e, Writer: rec}\n\n\tassert.Equal(t, rec, res.Unwrap())\n}\n"
        },
        {
          "name": "router.go",
          "type": "blob",
          "size": 21.21875,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// Router is the registry of all registered routes for an `Echo` instance for\n// request matching and URL path parameter parsing.\ntype Router struct {\n\ttree   *node\n\troutes map[string]*Route\n\techo   *Echo\n}\n\ntype node struct {\n\tmethods    *routeMethods\n\tparent     *node\n\tparamChild *node\n\tanyChild   *node\n\t// notFoundHandler is handler registered with RouteNotFound method and is executed for 404 cases\n\tnotFoundHandler *routeMethod\n\tprefix          string\n\toriginalPath    string\n\tstaticChildren  children\n\tparamsCount     int\n\tlabel           byte\n\tkind            kind\n\t// isLeaf indicates that node does not have child routes\n\tisLeaf bool\n\t// isHandler indicates that node has at least one handler registered to it\n\tisHandler bool\n}\n\ntype kind uint8\ntype children []*node\n\ntype routeMethod struct {\n\thandler HandlerFunc\n\tppath   string\n\tpnames  []string\n}\n\ntype routeMethods struct {\n\tconnect     *routeMethod\n\tdelete      *routeMethod\n\tget         *routeMethod\n\thead        *routeMethod\n\toptions     *routeMethod\n\tpatch       *routeMethod\n\tpost        *routeMethod\n\tpropfind    *routeMethod\n\tput         *routeMethod\n\ttrace       *routeMethod\n\treport      *routeMethod\n\tanyOther    map[string]*routeMethod\n\tallowHeader string\n}\n\nconst (\n\tstaticKind kind = iota\n\tparamKind\n\tanyKind\n\n\tparamLabel = byte(':')\n\tanyLabel   = byte('*')\n)\n\nfunc (m *routeMethods) isHandler() bool {\n\treturn m.connect != nil ||\n\t\tm.delete != nil ||\n\t\tm.get != nil ||\n\t\tm.head != nil ||\n\t\tm.options != nil ||\n\t\tm.patch != nil ||\n\t\tm.post != nil ||\n\t\tm.propfind != nil ||\n\t\tm.put != nil ||\n\t\tm.trace != nil ||\n\t\tm.report != nil ||\n\t\tlen(m.anyOther) != 0\n\t// RouteNotFound/404 is not considered as a handler\n}\n\nfunc (m *routeMethods) updateAllowHeader() {\n\tbuf := new(bytes.Buffer)\n\tbuf.WriteString(http.MethodOptions)\n\n\tif m.connect != nil {\n\t\tbuf.WriteString(\", \")\n\t\tbuf.WriteString(http.MethodConnect)\n\t}\n\tif m.delete != nil {\n\t\tbuf.WriteString(\", \")\n\t\tbuf.WriteString(http.MethodDelete)\n\t}\n\tif m.get != nil {\n\t\tbuf.WriteString(\", \")\n\t\tbuf.WriteString(http.MethodGet)\n\t}\n\tif m.head != nil {\n\t\tbuf.WriteString(\", \")\n\t\tbuf.WriteString(http.MethodHead)\n\t}\n\tif m.patch != nil {\n\t\tbuf.WriteString(\", \")\n\t\tbuf.WriteString(http.MethodPatch)\n\t}\n\tif m.post != nil {\n\t\tbuf.WriteString(\", \")\n\t\tbuf.WriteString(http.MethodPost)\n\t}\n\tif m.propfind != nil {\n\t\tbuf.WriteString(\", PROPFIND\")\n\t}\n\tif m.put != nil {\n\t\tbuf.WriteString(\", \")\n\t\tbuf.WriteString(http.MethodPut)\n\t}\n\tif m.trace != nil {\n\t\tbuf.WriteString(\", \")\n\t\tbuf.WriteString(http.MethodTrace)\n\t}\n\tif m.report != nil {\n\t\tbuf.WriteString(\", REPORT\")\n\t}\n\tfor method := range m.anyOther { // for simplicity, we use map and therefore order is not deterministic here\n\t\tbuf.WriteString(\", \")\n\t\tbuf.WriteString(method)\n\t}\n\tm.allowHeader = buf.String()\n}\n\n// NewRouter returns a new Router instance.\nfunc NewRouter(e *Echo) *Router {\n\treturn &Router{\n\t\ttree: &node{\n\t\t\tmethods: new(routeMethods),\n\t\t},\n\t\troutes: map[string]*Route{},\n\t\techo:   e,\n\t}\n}\n\n// Routes returns the registered routes.\nfunc (r *Router) Routes() []*Route {\n\troutes := make([]*Route, 0, len(r.routes))\n\tfor _, v := range r.routes {\n\t\troutes = append(routes, v)\n\t}\n\treturn routes\n}\n\n// Reverse generates a URL from route name and provided parameters.\nfunc (r *Router) Reverse(name string, params ...interface{}) string {\n\turi := new(bytes.Buffer)\n\tln := len(params)\n\tn := 0\n\tfor _, route := range r.routes {\n\t\tif route.Name == name {\n\t\t\tfor i, l := 0, len(route.Path); i < l; i++ {\n\t\t\t\thasBackslash := route.Path[i] == '\\\\'\n\t\t\t\tif hasBackslash && i+1 < l && route.Path[i+1] == ':' {\n\t\t\t\t\ti++ // backslash before colon escapes that colon. in that case skip backslash\n\t\t\t\t}\n\t\t\t\tif n < ln && (route.Path[i] == '*' || (!hasBackslash && route.Path[i] == ':')) {\n\t\t\t\t\t// in case of `*` wildcard or `:` (unescaped colon) param we replace everything till next slash or end of path\n\t\t\t\t\tfor ; i < l && route.Path[i] != '/'; i++ {\n\t\t\t\t\t}\n\t\t\t\t\turi.WriteString(fmt.Sprintf(\"%v\", params[n]))\n\t\t\t\t\tn++\n\t\t\t\t}\n\t\t\t\tif i < l {\n\t\t\t\t\turi.WriteByte(route.Path[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\treturn uri.String()\n}\n\nfunc normalizePathSlash(path string) string {\n\tif path == \"\" {\n\t\tpath = \"/\"\n\t} else if path[0] != '/' {\n\t\tpath = \"/\" + path\n\t}\n\treturn path\n}\n\nfunc (r *Router) add(method, path, name string, h HandlerFunc) *Route {\n\tpath = normalizePathSlash(path)\n\tr.insert(method, path, h)\n\n\troute := &Route{\n\t\tMethod: method,\n\t\tPath:   path,\n\t\tName:   name,\n\t}\n\tr.routes[method+path] = route\n\treturn route\n}\n\n// Add registers a new route for method and path with matching handler.\nfunc (r *Router) Add(method, path string, h HandlerFunc) {\n\tr.insert(method, normalizePathSlash(path), h)\n}\n\nfunc (r *Router) insert(method, path string, h HandlerFunc) {\n\tpath = normalizePathSlash(path)\n\tpnames := []string{} // Param names\n\tppath := path        // Pristine path\n\n\tif h == nil && r.echo.Logger != nil {\n\t\t// FIXME: in future we should return error\n\t\tr.echo.Logger.Errorf(\"Adding route without handler function: %v:%v\", method, path)\n\t}\n\n\tfor i, lcpIndex := 0, len(path); i < lcpIndex; i++ {\n\t\tif path[i] == ':' {\n\t\t\tif i > 0 && path[i-1] == '\\\\' {\n\t\t\t\tpath = path[:i-1] + path[i:]\n\t\t\t\ti--\n\t\t\t\tlcpIndex--\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tj := i + 1\n\n\t\t\tr.insertNode(method, path[:i], staticKind, routeMethod{})\n\t\t\tfor ; i < lcpIndex && path[i] != '/'; i++ {\n\t\t\t}\n\n\t\t\tpnames = append(pnames, path[j:i])\n\t\t\tpath = path[:j] + path[i:]\n\t\t\ti, lcpIndex = j, len(path)\n\n\t\t\tif i == lcpIndex {\n\t\t\t\t// path node is last fragment of route path. ie. `/users/:id`\n\t\t\t\tr.insertNode(method, path[:i], paramKind, routeMethod{ppath: ppath, pnames: pnames, handler: h})\n\t\t\t} else {\n\t\t\t\tr.insertNode(method, path[:i], paramKind, routeMethod{})\n\t\t\t}\n\t\t} else if path[i] == '*' {\n\t\t\tr.insertNode(method, path[:i], staticKind, routeMethod{})\n\t\t\tpnames = append(pnames, \"*\")\n\t\t\tr.insertNode(method, path[:i+1], anyKind, routeMethod{ppath: ppath, pnames: pnames, handler: h})\n\t\t}\n\t}\n\n\tr.insertNode(method, path, staticKind, routeMethod{ppath: ppath, pnames: pnames, handler: h})\n}\n\nfunc (r *Router) insertNode(method, path string, t kind, rm routeMethod) {\n\t// Adjust max param\n\tparamLen := len(rm.pnames)\n\tif *r.echo.maxParam < paramLen {\n\t\t*r.echo.maxParam = paramLen\n\t}\n\n\tcurrentNode := r.tree // Current node as root\n\tif currentNode == nil {\n\t\tpanic(\"echo: invalid method\")\n\t}\n\tsearch := path\n\n\tfor {\n\t\tsearchLen := len(search)\n\t\tprefixLen := len(currentNode.prefix)\n\t\tlcpLen := 0\n\n\t\t// LCP - Longest Common Prefix (https://en.wikipedia.org/wiki/LCP_array)\n\t\tmax := prefixLen\n\t\tif searchLen < max {\n\t\t\tmax = searchLen\n\t\t}\n\t\tfor ; lcpLen < max && search[lcpLen] == currentNode.prefix[lcpLen]; lcpLen++ {\n\t\t}\n\n\t\tif lcpLen == 0 {\n\t\t\t// At root node\n\t\t\tcurrentNode.label = search[0]\n\t\t\tcurrentNode.prefix = search\n\t\t\tif rm.handler != nil {\n\t\t\t\tcurrentNode.kind = t\n\t\t\t\tcurrentNode.addMethod(method, &rm)\n\t\t\t\tcurrentNode.paramsCount = len(rm.pnames)\n\t\t\t\tcurrentNode.originalPath = rm.ppath\n\t\t\t}\n\t\t\tcurrentNode.isLeaf = currentNode.staticChildren == nil && currentNode.paramChild == nil && currentNode.anyChild == nil\n\t\t} else if lcpLen < prefixLen {\n\t\t\t// Split node into two before we insert new node.\n\t\t\t// This happens when we are inserting path that is submatch of any existing inserted paths.\n\t\t\t// For example, we have node `/test` and now are about to insert `/te/*`. In that case\n\t\t\t// 1. overlapping part is `/te` that is used as parent node\n\t\t\t// 2. `st` is part from existing node that is not matching - it gets its own node (child to `/te`)\n\t\t\t// 3. `/*` is the new part we are about to insert (child to `/te`)\n\t\t\tn := newNode(\n\t\t\t\tcurrentNode.kind,\n\t\t\t\tcurrentNode.prefix[lcpLen:],\n\t\t\t\tcurrentNode,\n\t\t\t\tcurrentNode.staticChildren,\n\t\t\t\tcurrentNode.originalPath,\n\t\t\t\tcurrentNode.methods,\n\t\t\t\tcurrentNode.paramsCount,\n\t\t\t\tcurrentNode.paramChild,\n\t\t\t\tcurrentNode.anyChild,\n\t\t\t\tcurrentNode.notFoundHandler,\n\t\t\t)\n\t\t\t// Update parent path for all children to new node\n\t\t\tfor _, child := range currentNode.staticChildren {\n\t\t\t\tchild.parent = n\n\t\t\t}\n\t\t\tif currentNode.paramChild != nil {\n\t\t\t\tcurrentNode.paramChild.parent = n\n\t\t\t}\n\t\t\tif currentNode.anyChild != nil {\n\t\t\t\tcurrentNode.anyChild.parent = n\n\t\t\t}\n\n\t\t\t// Reset parent node\n\t\t\tcurrentNode.kind = staticKind\n\t\t\tcurrentNode.label = currentNode.prefix[0]\n\t\t\tcurrentNode.prefix = currentNode.prefix[:lcpLen]\n\t\t\tcurrentNode.staticChildren = nil\n\t\t\tcurrentNode.originalPath = \"\"\n\t\t\tcurrentNode.methods = new(routeMethods)\n\t\t\tcurrentNode.paramsCount = 0\n\t\t\tcurrentNode.paramChild = nil\n\t\t\tcurrentNode.anyChild = nil\n\t\t\tcurrentNode.isLeaf = false\n\t\t\tcurrentNode.isHandler = false\n\t\t\tcurrentNode.notFoundHandler = nil\n\n\t\t\t// Only Static children could reach here\n\t\t\tcurrentNode.addStaticChild(n)\n\n\t\t\tif lcpLen == searchLen {\n\t\t\t\t// At parent node\n\t\t\t\tcurrentNode.kind = t\n\t\t\t\tif rm.handler != nil {\n\t\t\t\t\tcurrentNode.addMethod(method, &rm)\n\t\t\t\t\tcurrentNode.paramsCount = len(rm.pnames)\n\t\t\t\t\tcurrentNode.originalPath = rm.ppath\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Create child node\n\t\t\t\tn = newNode(t, search[lcpLen:], currentNode, nil, \"\", new(routeMethods), 0, nil, nil, nil)\n\t\t\t\tif rm.handler != nil {\n\t\t\t\t\tn.addMethod(method, &rm)\n\t\t\t\t\tn.paramsCount = len(rm.pnames)\n\t\t\t\t\tn.originalPath = rm.ppath\n\t\t\t\t}\n\t\t\t\t// Only Static children could reach here\n\t\t\t\tcurrentNode.addStaticChild(n)\n\t\t\t}\n\t\t\tcurrentNode.isLeaf = currentNode.staticChildren == nil && currentNode.paramChild == nil && currentNode.anyChild == nil\n\t\t} else if lcpLen < searchLen {\n\t\t\tsearch = search[lcpLen:]\n\t\t\tc := currentNode.findChildWithLabel(search[0])\n\t\t\tif c != nil {\n\t\t\t\t// Go deeper\n\t\t\t\tcurrentNode = c\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Create child node\n\t\t\tn := newNode(t, search, currentNode, nil, rm.ppath, new(routeMethods), 0, nil, nil, nil)\n\t\t\tif rm.handler != nil {\n\t\t\t\tn.addMethod(method, &rm)\n\t\t\t\tn.paramsCount = len(rm.pnames)\n\t\t\t}\n\n\t\t\tswitch t {\n\t\t\tcase staticKind:\n\t\t\t\tcurrentNode.addStaticChild(n)\n\t\t\tcase paramKind:\n\t\t\t\tcurrentNode.paramChild = n\n\t\t\tcase anyKind:\n\t\t\t\tcurrentNode.anyChild = n\n\t\t\t}\n\t\t\tcurrentNode.isLeaf = currentNode.staticChildren == nil && currentNode.paramChild == nil && currentNode.anyChild == nil\n\t\t} else {\n\t\t\t// Node already exists\n\t\t\tif rm.handler != nil {\n\t\t\t\tcurrentNode.addMethod(method, &rm)\n\t\t\t\tcurrentNode.paramsCount = len(rm.pnames)\n\t\t\t\tcurrentNode.originalPath = rm.ppath\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n}\n\nfunc newNode(\n\tt kind,\n\tpre string,\n\tp *node,\n\tsc children,\n\toriginalPath string,\n\tmethods *routeMethods,\n\tparamsCount int,\n\tparamChildren,\n\tanyChildren *node,\n\tnotFoundHandler *routeMethod,\n) *node {\n\treturn &node{\n\t\tkind:            t,\n\t\tlabel:           pre[0],\n\t\tprefix:          pre,\n\t\tparent:          p,\n\t\tstaticChildren:  sc,\n\t\toriginalPath:    originalPath,\n\t\tmethods:         methods,\n\t\tparamsCount:     paramsCount,\n\t\tparamChild:      paramChildren,\n\t\tanyChild:        anyChildren,\n\t\tisLeaf:          sc == nil && paramChildren == nil && anyChildren == nil,\n\t\tisHandler:       methods.isHandler(),\n\t\tnotFoundHandler: notFoundHandler,\n\t}\n}\n\nfunc (n *node) addStaticChild(c *node) {\n\tn.staticChildren = append(n.staticChildren, c)\n}\n\nfunc (n *node) findStaticChild(l byte) *node {\n\tfor _, c := range n.staticChildren {\n\t\tif c.label == l {\n\t\t\treturn c\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (n *node) findChildWithLabel(l byte) *node {\n\tif c := n.findStaticChild(l); c != nil {\n\t\treturn c\n\t}\n\tif l == paramLabel {\n\t\treturn n.paramChild\n\t}\n\tif l == anyLabel {\n\t\treturn n.anyChild\n\t}\n\treturn nil\n}\n\nfunc (n *node) addMethod(method string, h *routeMethod) {\n\tswitch method {\n\tcase http.MethodConnect:\n\t\tn.methods.connect = h\n\tcase http.MethodDelete:\n\t\tn.methods.delete = h\n\tcase http.MethodGet:\n\t\tn.methods.get = h\n\tcase http.MethodHead:\n\t\tn.methods.head = h\n\tcase http.MethodOptions:\n\t\tn.methods.options = h\n\tcase http.MethodPatch:\n\t\tn.methods.patch = h\n\tcase http.MethodPost:\n\t\tn.methods.post = h\n\tcase PROPFIND:\n\t\tn.methods.propfind = h\n\tcase http.MethodPut:\n\t\tn.methods.put = h\n\tcase http.MethodTrace:\n\t\tn.methods.trace = h\n\tcase REPORT:\n\t\tn.methods.report = h\n\tcase RouteNotFound:\n\t\tn.notFoundHandler = h\n\t\treturn // RouteNotFound/404 is not considered as a handler so no further logic needs to be executed\n\tdefault:\n\t\tif n.methods.anyOther == nil {\n\t\t\tn.methods.anyOther = make(map[string]*routeMethod)\n\t\t}\n\t\tif h.handler == nil {\n\t\t\tdelete(n.methods.anyOther, method)\n\t\t} else {\n\t\t\tn.methods.anyOther[method] = h\n\t\t}\n\t}\n\n\tn.methods.updateAllowHeader()\n\tn.isHandler = true\n}\n\nfunc (n *node) findMethod(method string) *routeMethod {\n\tswitch method {\n\tcase http.MethodConnect:\n\t\treturn n.methods.connect\n\tcase http.MethodDelete:\n\t\treturn n.methods.delete\n\tcase http.MethodGet:\n\t\treturn n.methods.get\n\tcase http.MethodHead:\n\t\treturn n.methods.head\n\tcase http.MethodOptions:\n\t\treturn n.methods.options\n\tcase http.MethodPatch:\n\t\treturn n.methods.patch\n\tcase http.MethodPost:\n\t\treturn n.methods.post\n\tcase PROPFIND:\n\t\treturn n.methods.propfind\n\tcase http.MethodPut:\n\t\treturn n.methods.put\n\tcase http.MethodTrace:\n\t\treturn n.methods.trace\n\tcase REPORT:\n\t\treturn n.methods.report\n\tdefault: // RouteNotFound/404 is not considered as a handler\n\t\treturn n.methods.anyOther[method]\n\t}\n}\n\nfunc optionsMethodHandler(allowMethods string) func(c Context) error {\n\treturn func(c Context) error {\n\t\t// Note: we are not handling most of the CORS headers here. CORS is handled by CORS middleware\n\t\t// 'OPTIONS' method RFC: https://httpwg.org/specs/rfc7231.html#OPTIONS\n\t\t// 'Allow' header RFC: https://datatracker.ietf.org/doc/html/rfc7231#section-7.4.1\n\t\tc.Response().Header().Add(HeaderAllow, allowMethods)\n\t\treturn c.NoContent(http.StatusNoContent)\n\t}\n}\n\n// Find lookup a handler registered for method and path. It also parses URL for path\n// parameters and load them into context.\n//\n// For performance:\n//\n// - Get context from `Echo#AcquireContext()`\n// - Reset it `Context#Reset()`\n// - Return it `Echo#ReleaseContext()`.\nfunc (r *Router) Find(method, path string, c Context) {\n\tctx := c.(*context)\n\tcurrentNode := r.tree // Current node as root\n\n\tvar (\n\t\tpreviousBestMatchNode *node\n\t\tmatchedRouteMethod    *routeMethod\n\t\t// search stores the remaining path to check for match. By each iteration we move from start of path to end of the path\n\t\t// and search value gets shorter and shorter.\n\t\tsearch      = path\n\t\tsearchIndex = 0\n\t\tparamIndex  int           // Param counter\n\t\tparamValues = ctx.pvalues // Use the internal slice so the interface can keep the illusion of a dynamic slice\n\t)\n\n\t// Backtracking is needed when a dead end (leaf node) is reached in the router tree.\n\t// To backtrack the current node will be changed to the parent node and the next kind for the\n\t// router logic will be returned based on fromKind or kind of the dead end node (static > param > any).\n\t// For example if there is no static node match we should check parent next sibling by kind (param).\n\t// Backtracking itself does not check if there is a next sibling, this is done by the router logic.\n\tbacktrackToNextNodeKind := func(fromKind kind) (nextNodeKind kind, valid bool) {\n\t\tprevious := currentNode\n\t\tcurrentNode = previous.parent\n\t\tvalid = currentNode != nil\n\n\t\t// Next node type by priority\n\t\tif previous.kind == anyKind {\n\t\t\tnextNodeKind = staticKind\n\t\t} else {\n\t\t\tnextNodeKind = previous.kind + 1\n\t\t}\n\n\t\tif fromKind == staticKind {\n\t\t\t// when backtracking is done from static kind block we did not change search so nothing to restore\n\t\t\treturn\n\t\t}\n\n\t\t// restore search to value it was before we move to current node we are backtracking from.\n\t\tif previous.kind == staticKind {\n\t\t\tsearchIndex -= len(previous.prefix)\n\t\t} else {\n\t\t\tparamIndex--\n\t\t\t// for param/any node.prefix value is always `:` so we can not deduce searchIndex from that and must use pValue\n\t\t\t// for that index as it would also contain part of path we cut off before moving into node we are backtracking from\n\t\t\tsearchIndex -= len(paramValues[paramIndex])\n\t\t\tparamValues[paramIndex] = \"\"\n\t\t}\n\t\tsearch = path[searchIndex:]\n\t\treturn\n\t}\n\n\t// Router tree is implemented by longest common prefix array (LCP array) https://en.wikipedia.org/wiki/LCP_array\n\t// Tree search is implemented as for loop where one loop iteration is divided into 3 separate blocks\n\t// Each of these blocks checks specific kind of node (static/param/any). Order of blocks reflex their priority in routing.\n\t// Search order/priority is: static > param > any.\n\t//\n\t// Note: backtracking in tree is implemented by replacing/switching currentNode to previous node\n\t// and hoping to (goto statement) next block by priority to check if it is the match.\n\tfor {\n\t\tprefixLen := 0 // Prefix length\n\t\tlcpLen := 0    // LCP (longest common prefix) length\n\n\t\tif currentNode.kind == staticKind {\n\t\t\tsearchLen := len(search)\n\t\t\tprefixLen = len(currentNode.prefix)\n\n\t\t\t// LCP - Longest Common Prefix (https://en.wikipedia.org/wiki/LCP_array)\n\t\t\tmax := prefixLen\n\t\t\tif searchLen < max {\n\t\t\t\tmax = searchLen\n\t\t\t}\n\t\t\tfor ; lcpLen < max && search[lcpLen] == currentNode.prefix[lcpLen]; lcpLen++ {\n\t\t\t}\n\t\t}\n\n\t\tif lcpLen != prefixLen {\n\t\t\t// No matching prefix, let's backtrack to the first possible alternative node of the decision path\n\t\t\tnk, ok := backtrackToNextNodeKind(staticKind)\n\t\t\tif !ok {\n\t\t\t\treturn // No other possibilities on the decision path, handler will be whatever context is reset to.\n\t\t\t} else if nk == paramKind {\n\t\t\t\tgoto Param\n\t\t\t\t// NOTE: this case (backtracking from static node to previous any node) can not happen by current any matching logic. Any node is end of search currently\n\t\t\t\t//} else if nk == anyKind {\n\t\t\t\t//\tgoto Any\n\t\t\t} else {\n\t\t\t\t// Not found (this should never be possible for static node we are looking currently)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// The full prefix has matched, remove the prefix from the remaining search\n\t\tsearch = search[lcpLen:]\n\t\tsearchIndex = searchIndex + lcpLen\n\n\t\t// Finish routing if is no request path remaining to search\n\t\tif search == \"\" {\n\t\t\t// in case of node that is handler we have exact method type match or something for 405 to use\n\t\t\tif currentNode.isHandler {\n\t\t\t\t// check if current node has handler registered for http method we are looking for. we store currentNode as\n\t\t\t\t// best matching in case we do no find no more routes matching this path+method\n\t\t\t\tif previousBestMatchNode == nil {\n\t\t\t\t\tpreviousBestMatchNode = currentNode\n\t\t\t\t}\n\t\t\t\tif h := currentNode.findMethod(method); h != nil {\n\t\t\t\t\tmatchedRouteMethod = h\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else if currentNode.notFoundHandler != nil {\n\t\t\t\tmatchedRouteMethod = currentNode.notFoundHandler\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Static node\n\t\tif search != \"\" {\n\t\t\tif child := currentNode.findStaticChild(search[0]); child != nil {\n\t\t\t\tcurrentNode = child\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\tParam:\n\t\t// Param node\n\t\tif child := currentNode.paramChild; search != \"\" && child != nil {\n\t\t\tcurrentNode = child\n\t\t\ti := 0\n\t\t\tl := len(search)\n\t\t\tif currentNode.isLeaf {\n\t\t\t\t// when param node does not have any children (path param is last piece of route path) then param node should\n\t\t\t\t// act similarly to any node - consider all remaining search as match\n\t\t\t\ti = l\n\t\t\t} else {\n\t\t\t\tfor ; i < l && search[i] != '/'; i++ {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparamValues[paramIndex] = search[:i]\n\t\t\tparamIndex++\n\t\t\tsearch = search[i:]\n\t\t\tsearchIndex = searchIndex + i\n\t\t\tcontinue\n\t\t}\n\n\tAny:\n\t\t// Any node\n\t\tif child := currentNode.anyChild; child != nil {\n\t\t\t// If any node is found, use remaining path for paramValues\n\t\t\tcurrentNode = child\n\t\t\tparamValues[currentNode.paramsCount-1] = search\n\n\t\t\t// update indexes/search in case we need to backtrack when no handler match is found\n\t\t\tparamIndex++\n\t\t\tsearchIndex += +len(search)\n\t\t\tsearch = \"\"\n\n\t\t\tif h := currentNode.findMethod(method); h != nil {\n\t\t\t\tmatchedRouteMethod = h\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// we store currentNode as best matching in case we do not find more routes matching this path+method. Needed for 405\n\t\t\tif previousBestMatchNode == nil {\n\t\t\t\tpreviousBestMatchNode = currentNode\n\t\t\t}\n\t\t\tif currentNode.notFoundHandler != nil {\n\t\t\t\tmatchedRouteMethod = currentNode.notFoundHandler\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Let's backtrack to the first possible alternative node of the decision path\n\t\tnk, ok := backtrackToNextNodeKind(anyKind)\n\t\tif !ok {\n\t\t\tbreak // No other possibilities on the decision path\n\t\t} else if nk == paramKind {\n\t\t\tgoto Param\n\t\t} else if nk == anyKind {\n\t\t\tgoto Any\n\t\t} else {\n\t\t\t// Not found\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif currentNode == nil && previousBestMatchNode == nil {\n\t\treturn // nothing matched at all\n\t}\n\n\t// matchedHandler could be method+path handler that we matched or notFoundHandler from node with matching path\n\t// user provided not found (404) handler has priority over generic method not found (405) handler or global 404 handler\n\tvar rPath string\n\tvar rPNames []string\n\tif matchedRouteMethod != nil {\n\t\trPath = matchedRouteMethod.ppath\n\t\trPNames = matchedRouteMethod.pnames\n\t\tctx.handler = matchedRouteMethod.handler\n\t} else {\n\t\t// use previous match as basis. although we have no matching handler we have path match.\n\t\t// so we can send http.StatusMethodNotAllowed (405) instead of http.StatusNotFound (404)\n\t\tcurrentNode = previousBestMatchNode\n\n\t\trPath = currentNode.originalPath\n\t\trPNames = nil // no params here\n\t\tctx.handler = NotFoundHandler\n\t\tif currentNode.notFoundHandler != nil {\n\t\t\trPath = currentNode.notFoundHandler.ppath\n\t\t\trPNames = currentNode.notFoundHandler.pnames\n\t\t\tctx.handler = currentNode.notFoundHandler.handler\n\t\t} else if currentNode.isHandler {\n\t\t\tctx.Set(ContextKeyHeaderAllow, currentNode.methods.allowHeader)\n\t\t\tctx.handler = MethodNotAllowedHandler\n\t\t\tif method == http.MethodOptions {\n\t\t\t\tctx.handler = optionsMethodHandler(currentNode.methods.allowHeader)\n\t\t\t}\n\t\t}\n\t}\n\tctx.path = rPath\n\tctx.pnames = rPNames\n}\n"
        },
        {
          "name": "router_test.go",
          "type": "blob",
          "size": 81.4638671875,
          "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: © 2015 LabStack LLC and Echo contributors\n\npackage echo\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar (\n\tstaticRoutes = []*Route{\n\t\t{\"GET\", \"/\", \"\"},\n\t\t{\"GET\", \"/cmd.html\", \"\"},\n\t\t{\"GET\", \"/code.html\", \"\"},\n\t\t{\"GET\", \"/contrib.html\", \"\"},\n\t\t{\"GET\", \"/contribute.html\", \"\"},\n\t\t{\"GET\", \"/debugging_with_gdb.html\", \"\"},\n\t\t{\"GET\", \"/docs.html\", \"\"},\n\t\t{\"GET\", \"/effective_go.html\", \"\"},\n\t\t{\"GET\", \"/files.log\", \"\"},\n\t\t{\"GET\", \"/gccgo_contribute.html\", \"\"},\n\t\t{\"GET\", \"/gccgo_install.html\", \"\"},\n\t\t{\"GET\", \"/go-logo-black.png\", \"\"},\n\t\t{\"GET\", \"/go-logo-blue.png\", \"\"},\n\t\t{\"GET\", \"/go-logo-white.png\", \"\"},\n\t\t{\"GET\", \"/go1.1.html\", \"\"},\n\t\t{\"GET\", \"/go1.2.html\", \"\"},\n\t\t{\"GET\", \"/go1.html\", \"\"},\n\t\t{\"GET\", \"/go1compat.html\", \"\"},\n\t\t{\"GET\", \"/go_faq.html\", \"\"},\n\t\t{\"GET\", \"/go_mem.html\", \"\"},\n\t\t{\"GET\", \"/go_spec.html\", \"\"},\n\t\t{\"GET\", \"/help.html\", \"\"},\n\t\t{\"GET\", \"/ie.css\", \"\"},\n\t\t{\"GET\", \"/install-source.html\", \"\"},\n\t\t{\"GET\", \"/install.html\", \"\"},\n\t\t{\"GET\", \"/logo-153x55.png\", \"\"},\n\t\t{\"GET\", \"/Makefile\", \"\"},\n\t\t{\"GET\", \"/root.html\", \"\"},\n\t\t{\"GET\", \"/share.png\", \"\"},\n\t\t{\"GET\", \"/sieve.gif\", \"\"},\n\t\t{\"GET\", \"/tos.html\", \"\"},\n\t\t{\"GET\", \"/articles/\", \"\"},\n\t\t{\"GET\", \"/articles/go_command.html\", \"\"},\n\t\t{\"GET\", \"/articles/index.html\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/edit.html\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/final-noclosure.go\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/final-noerror.go\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/final-parsetemplate.go\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/final-template.go\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/final.go\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/get.go\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/http-sample.go\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/index.html\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/Makefile\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/notemplate.go\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/part1-noerror.go\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/part1.go\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/part2.go\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/part3-errorhandling.go\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/part3.go\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/test.bash\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/test_edit.good\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/test_Test.txt.good\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/test_view.good\", \"\"},\n\t\t{\"GET\", \"/articles/wiki/view.html\", \"\"},\n\t\t{\"GET\", \"/codewalk/\", \"\"},\n\t\t{\"GET\", \"/codewalk/codewalk.css\", \"\"},\n\t\t{\"GET\", \"/codewalk/codewalk.js\", \"\"},\n\t\t{\"GET\", \"/codewalk/codewalk.xml\", \"\"},\n\t\t{\"GET\", \"/codewalk/functions.xml\", \"\"},\n\t\t{\"GET\", \"/codewalk/markov.go\", \"\"},\n\t\t{\"GET\", \"/codewalk/markov.xml\", \"\"},\n\t\t{\"GET\", \"/codewalk/pig.go\", \"\"},\n\t\t{\"GET\", \"/codewalk/popout.png\", \"\"},\n\t\t{\"GET\", \"/codewalk/run\", \"\"},\n\t\t{\"GET\", \"/codewalk/sharemem.xml\", \"\"},\n\t\t{\"GET\", \"/codewalk/urlpoll.go\", \"\"},\n\t\t{\"GET\", \"/devel/\", \"\"},\n\t\t{\"GET\", \"/devel/release.html\", \"\"},\n\t\t{\"GET\", \"/devel/weekly.html\", \"\"},\n\t\t{\"GET\", \"/gopher/\", \"\"},\n\t\t{\"GET\", \"/gopher/appenginegopher.jpg\", \"\"},\n\t\t{\"GET\", \"/gopher/appenginegophercolor.jpg\", \"\"},\n\t\t{\"GET\", \"/gopher/appenginelogo.gif\", \"\"},\n\t\t{\"GET\", \"/gopher/bumper.png\", \"\"},\n\t\t{\"GET\", \"/gopher/bumper192x108.png\", \"\"},\n\t\t{\"GET\", \"/gopher/bumper320x180.png\", \"\"},\n\t\t{\"GET\", \"/gopher/bumper480x270.png\", \"\"},\n\t\t{\"GET\", \"/gopher/bumper640x360.png\", \"\"},\n\t\t{\"GET\", \"/gopher/doc.png\", \"\"},\n\t\t{\"GET\", \"/gopher/frontpage.png\", \"\"},\n\t\t{\"GET\", \"/gopher/gopherbw.png\", \"\"},\n\t\t{\"GET\", \"/gopher/gophercolor.png\", \"\"},\n\t\t{\"GET\", \"/gopher/gophercolor16x16.png\", \"\"},\n\t\t{\"GET\", \"/gopher/help.png\", \"\"},\n\t\t{\"GET\", \"/gopher/pkg.png\", \"\"},\n\t\t{\"GET\", \"/gopher/project.png\", \"\"},\n\t\t{\"GET\", \"/gopher/ref.png\", \"\"},\n\t\t{\"GET\", \"/gopher/run.png\", \"\"},\n\t\t{\"GET\", \"/gopher/talks.png\", \"\"},\n\t\t{\"GET\", \"/gopher/pencil/\", \"\"},\n\t\t{\"GET\", \"/gopher/pencil/gopherhat.jpg\", \"\"},\n\t\t{\"GET\", \"/gopher/pencil/gopherhelmet.jpg\", \"\"},\n\t\t{\"GET\", \"/gopher/pencil/gophermega.jpg\", \"\"},\n\t\t{\"GET\", \"/gopher/pencil/gopherrunning.jpg\", \"\"},\n\t\t{\"GET\", \"/gopher/pencil/gopherswim.jpg\", \"\"},\n\t\t{\"GET\", \"/gopher/pencil/gopherswrench.jpg\", \"\"},\n\t\t{\"GET\", \"/play/\", \"\"},\n\t\t{\"GET\", \"/play/fib.go\", \"\"},\n\t\t{\"GET\", \"/play/hello.go\", \"\"},\n\t\t{\"GET\", \"/play/life.go\", \"\"},\n\t\t{\"GET\", \"/play/peano.go\", \"\"},\n\t\t{\"GET\", \"/play/pi.go\", \"\"},\n\t\t{\"GET\", \"/play/sieve.go\", \"\"},\n\t\t{\"GET\", \"/play/solitaire.go\", \"\"},\n\t\t{\"GET\", \"/play/tree.go\", \"\"},\n\t\t{\"GET\", \"/progs/\", \"\"},\n\t\t{\"GET\", \"/progs/cgo1.go\", \"\"},\n\t\t{\"GET\", \"/progs/cgo2.go\", \"\"},\n\t\t{\"GET\", \"/progs/cgo3.go\", \"\"},\n\t\t{\"GET\", \"/progs/cgo4.go\", \"\"},\n\t\t{\"GET\", \"/progs/defer.go\", \"\"},\n\t\t{\"GET\", \"/progs/defer.out\", \"\"},\n\t\t{\"GET\", \"/progs/defer2.go\", \"\"},\n\t\t{\"GET\", \"/progs/defer2.out\", \"\"},\n\t\t{\"GET\", \"/progs/eff_bytesize.go\", \"\"},\n\t\t{\"GET\", \"/progs/eff_bytesize.out\", \"\"},\n\t\t{\"GET\", \"/progs/eff_qr.go\", \"\"},\n\t\t{\"GET\", \"/progs/eff_sequence.go\", \"\"},\n\t\t{\"GET\", \"/progs/eff_sequence.out\", \"\"},\n\t\t{\"GET\", \"/progs/eff_unused1.go\", \"\"},\n\t\t{\"GET\", \"/progs/eff_unused2.go\", \"\"},\n\t\t{\"GET\", \"/progs/error.go\", \"\"},\n\t\t{\"GET\", \"/progs/error2.go\", \"\"},\n\t\t{\"GET\", \"/progs/error3.go\", \"\"},\n\t\t{\"GET\", \"/progs/error4.go\", \"\"},\n\t\t{\"GET\", \"/progs/go1.go\", \"\"},\n\t\t{\"GET\", \"/progs/gobs1.go\", \"\"},\n\t\t{\"GET\", \"/progs/gobs2.go\", \"\"},\n\t\t{\"GET\", \"/progs/image_draw.go\", \"\"},\n\t\t{\"GET\", \"/progs/image_package1.go\", \"\"},\n\t\t{\"GET\", \"/progs/image_package1.out\", \"\"},\n\t\t{\"GET\", \"/progs/image_package2.go\", \"\"},\n\t\t{\"GET\", \"/progs/image_package2.out\", \"\"},\n\t\t{\"GET\", \"/progs/image_package3.go\", \"\"},\n\t\t{\"GET\", \"/progs/image_package3.out\", \"\"},\n\t\t{\"GET\", \"/progs/image_package4.go\", \"\"},\n\t\t{\"GET\", \"/progs/image_package4.out\", \"\"},\n\t\t{\"GET\", \"/progs/image_package5.go\", \"\"},\n\t\t{\"GET\", \"/progs/image_package5.out\", \"\"},\n\t\t{\"GET\", \"/progs/image_package6.go\", \"\"},\n\t\t{\"GET\", \"/progs/image_package6.out\", \"\"},\n\t\t{\"GET\", \"/progs/interface.go\", \"\"},\n\t\t{\"GET\", \"/progs/interface2.go\", \"\"},\n\t\t{\"GET\", \"/progs/interface2.out\", \"\"},\n\t\t{\"GET\", \"/progs/json1.go\", \"\"},\n\t\t{\"GET\", \"/progs/json2.go\", \"\"},\n\t\t{\"GET\", \"/progs/json2.out\", \"\"},\n\t\t{\"GET\", \"/progs/json3.go\", \"\"},\n\t\t{\"GET\", \"/progs/json4.go\", \"\"},\n\t\t{\"GET\", \"/progs/json5.go\", \"\"},\n\t\t{\"GET\", \"/progs/run\", \"\"},\n\t\t{\"GET\", \"/progs/slices.go\", \"\"},\n\t\t{\"GET\", \"/progs/timeout1.go\", \"\"},\n\t\t{\"GET\", \"/progs/timeout2.go\", \"\"},\n\t\t{\"GET\", \"/progs/update.bash\", \"\"},\n\t}\n\n\tgitHubAPI = []*Route{\n\t\t// OAuth Authorizations\n\t\t{\"GET\", \"/authorizations\", \"\"},\n\t\t{\"GET\", \"/authorizations/:id\", \"\"},\n\t\t{\"POST\", \"/authorizations\", \"\"},\n\n\t\t{\"PUT\", \"/authorizations/clients/:client_id\", \"\"},\n\t\t{\"PATCH\", \"/authorizations/:id\", \"\"},\n\n\t\t{\"DELETE\", \"/authorizations/:id\", \"\"},\n\t\t{\"GET\", \"/applications/:client_id/tokens/:access_token\", \"\"},\n\t\t{\"DELETE\", \"/applications/:client_id/tokens\", \"\"},\n\t\t{\"DELETE\", \"/applications/:client_id/tokens/:access_token\", \"\"},\n\n\t\t// Activity\n\t\t{\"GET\", \"/events\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/events\", \"\"},\n\t\t{\"GET\", \"/networks/:owner/:repo/events\", \"\"},\n\t\t{\"GET\", \"/orgs/:org/events\", \"\"},\n\t\t{\"GET\", \"/users/:user/received_events\", \"\"},\n\t\t{\"GET\", \"/users/:user/received_events/public\", \"\"},\n\t\t{\"GET\", \"/users/:user/events\", \"\"},\n\t\t{\"GET\", \"/users/:user/events/public\", \"\"},\n\t\t{\"GET\", \"/users/:user/events/orgs/:org\", \"\"},\n\t\t{\"GET\", \"/feeds\", \"\"},\n\t\t{\"GET\", \"/notifications\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/notifications\", \"\"},\n\t\t{\"PUT\", \"/notifications\", \"\"},\n\t\t{\"PUT\", \"/repos/:owner/:repo/notifications\", \"\"},\n\t\t{\"GET\", \"/notifications/threads/:id\", \"\"},\n\n\t\t{\"PATCH\", \"/notifications/threads/:id\", \"\"},\n\n\t\t{\"GET\", \"/notifications/threads/:id/subscription\", \"\"},\n\t\t{\"PUT\", \"/notifications/threads/:id/subscription\", \"\"},\n\t\t{\"DELETE\", \"/notifications/threads/:id/subscription\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/stargazers\", \"\"},\n\t\t{\"GET\", \"/users/:user/starred\", \"\"},\n\t\t{\"GET\", \"/user/starred\", \"\"},\n\t\t{\"GET\", \"/user/starred/:owner/:repo\", \"\"},\n\t\t{\"PUT\", \"/user/starred/:owner/:repo\", \"\"},\n\t\t{\"DELETE\", \"/user/starred/:owner/:repo\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/subscribers\", \"\"},\n\t\t{\"GET\", \"/users/:user/subscriptions\", \"\"},\n\t\t{\"GET\", \"/user/subscriptions\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/subscription\", \"\"},\n\t\t{\"PUT\", \"/repos/:owner/:repo/subscription\", \"\"},\n\t\t{\"DELETE\", \"/repos/:owner/:repo/subscription\", \"\"},\n\t\t{\"GET\", \"/user/subscriptions/:owner/:repo\", \"\"},\n\t\t{\"PUT\", \"/user/subscriptions/:owner/:repo\", \"\"},\n\t\t{\"DELETE\", \"/user/subscriptions/:owner/:repo\", \"\"},\n\n\t\t// Gists\n\t\t{\"GET\", \"/users/:user/gists\", \"\"},\n\t\t{\"GET\", \"/gists\", \"\"},\n\n\t\t{\"GET\", \"/gists/public\", \"\"},\n\t\t{\"GET\", \"/gists/starred\", \"\"},\n\n\t\t{\"GET\", \"/gists/:id\", \"\"},\n\t\t{\"POST\", \"/gists\", \"\"},\n\n\t\t{\"PATCH\", \"/gists/:id\", \"\"},\n\n\t\t{\"PUT\", \"/gists/:id/star\", \"\"},\n\t\t{\"DELETE\", \"/gists/:id/star\", \"\"},\n\t\t{\"GET\", \"/gists/:id/star\", \"\"},\n\t\t{\"POST\", \"/gists/:id/forks\", \"\"},\n\t\t{\"DELETE\", \"/gists/:id\", \"\"},\n\n\t\t// Git Data\n\t\t{\"GET\", \"/repos/:owner/:repo/git/blobs/:sha\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/git/blobs\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/git/commits/:sha\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/git/commits\", \"\"},\n\n\t\t{\"GET\", \"/repos/:owner/:repo/git/refs/*ref\", \"\"},\n\n\t\t{\"GET\", \"/repos/:owner/:repo/git/refs\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/git/refs\", \"\"},\n\n\t\t{\"PATCH\", \"/repos/:owner/:repo/git/refs/*ref\", \"\"},\n\t\t{\"DELETE\", \"/repos/:owner/:repo/git/refs/*ref\", \"\"},\n\n\t\t{\"GET\", \"/repos/:owner/:repo/git/tags/:sha\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/git/tags\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/git/trees/:sha\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/git/trees\", \"\"},\n\n\t\t// Issues\n\t\t{\"GET\", \"/issues\", \"\"},\n\t\t{\"GET\", \"/user/issues\", \"\"},\n\t\t{\"GET\", \"/orgs/:org/issues\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/issues\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/issues/:number\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/issues\", \"\"},\n\n\t\t{\"PATCH\", \"/repos/:owner/:repo/issues/:number\", \"\"},\n\n\t\t{\"GET\", \"/repos/:owner/:repo/assignees\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/assignees/:assignee\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/issues/:number/comments\", \"\"},\n\n\t\t{\"GET\", \"/repos/:owner/:repo/issues/comments\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/issues/comments/:id\", \"\"},\n\n\t\t{\"POST\", \"/repos/:owner/:repo/issues/:number/comments\", \"\"},\n\n\t\t{\"PATCH\", \"/repos/:owner/:repo/issues/comments/:id\", \"\"},\n\t\t{\"DELETE\", \"/repos/:owner/:repo/issues/comments/:id\", \"\"},\n\n\t\t{\"GET\", \"/repos/:owner/:repo/issues/:number/events\", \"\"},\n\n\t\t{\"GET\", \"/repos/:owner/:repo/issues/events\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/issues/events/:id\", \"\"},\n\n\t\t{\"GET\", \"/repos/:owner/:repo/labels\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/labels/:name\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/labels\", \"\"},\n\n\t\t{\"PATCH\", \"/repos/:owner/:repo/labels/:name\", \"\"},\n\n\t\t{\"DELETE\", \"/repos/:owner/:repo/labels/:name\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/issues/:number/labels\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/issues/:number/labels\", \"\"},\n\t\t{\"DELETE\", \"/repos/:owner/:repo/issues/:number/labels/:name\", \"\"},\n\t\t{\"PUT\", \"/repos/:owner/:repo/issues/:number/labels\", \"\"},\n\t\t{\"DELETE\", \"/repos/:owner/:repo/issues/:number/labels\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/milestones/:number/labels\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/milestones\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/milestones/:number\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/milestones\", \"\"},\n\n\t\t{\"PATCH\", \"/repos/:owner/:repo/milestones/:number\", \"\"},\n\n\t\t{\"DELETE\", \"/repos/:owner/:repo/milestones/:number\", \"\"},\n\n\t\t// Miscellaneous\n\t\t{\"GET\", \"/emojis\", \"\"},\n\t\t{\"GET\", \"/gitignore/templates\", \"\"},\n\t\t{\"GET\", \"/gitignore/templates/:name\", \"\"},\n\t\t{\"POST\", \"/markdown\", \"\"},\n\t\t{\"POST\", \"/markdown/raw\", \"\"},\n\t\t{\"GET\", \"/meta\", \"\"},\n\t\t{\"GET\", \"/rate_limit\", \"\"},\n\n\t\t// Organizations\n\t\t{\"GET\", \"/users/:user/orgs\", \"\"},\n\t\t{\"GET\", \"/user/orgs\", \"\"},\n\t\t{\"GET\", \"/orgs/:org\", \"\"},\n\n\t\t{\"PATCH\", \"/orgs/:org\", \"\"},\n\n\t\t{\"GET\", \"/orgs/:org/members\", \"\"},\n\t\t{\"GET\", \"/orgs/:org/members/:user\", \"\"},\n\t\t{\"DELETE\", \"/orgs/:org/members/:user\", \"\"},\n\t\t{\"GET\", \"/orgs/:org/public_members\", \"\"},\n\t\t{\"GET\", \"/orgs/:org/public_members/:user\", \"\"},\n\t\t{\"PUT\", \"/orgs/:org/public_members/:user\", \"\"},\n\t\t{\"DELETE\", \"/orgs/:org/public_members/:user\", \"\"},\n\t\t{\"GET\", \"/orgs/:org/teams\", \"\"},\n\t\t{\"GET\", \"/teams/:id\", \"\"},\n\t\t{\"POST\", \"/orgs/:org/teams\", \"\"},\n\n\t\t{\"PATCH\", \"/teams/:id\", \"\"},\n\n\t\t{\"DELETE\", \"/teams/:id\", \"\"},\n\t\t{\"GET\", \"/teams/:id/members\", \"\"},\n\t\t{\"GET\", \"/teams/:id/members/:user\", \"\"},\n\t\t{\"PUT\", \"/teams/:id/members/:user\", \"\"},\n\t\t{\"DELETE\", \"/teams/:id/members/:user\", \"\"},\n\t\t{\"GET\", \"/teams/:id/repos\", \"\"},\n\t\t{\"GET\", \"/teams/:id/repos/:owner/:repo\", \"\"},\n\t\t{\"PUT\", \"/teams/:id/repos/:owner/:repo\", \"\"},\n\t\t{\"DELETE\", \"/teams/:id/repos/:owner/:repo\", \"\"},\n\t\t{\"GET\", \"/user/teams\", \"\"},\n\n\t\t// Pull Requests\n\t\t{\"GET\", \"/repos/:owner/:repo/pulls\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/pulls/:number\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/pulls\", \"\"},\n\n\t\t{\"PATCH\", \"/repos/:owner/:repo/pulls/:number\", \"\"},\n\n\t\t{\"GET\", \"/repos/:owner/:repo/pulls/:number/commits\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/pulls/:number/files\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/pulls/:number/merge\", \"\"},\n\t\t{\"PUT\", \"/repos/:owner/:repo/pulls/:number/merge\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/pulls/:number/comments\", \"\"},\n\n\t\t{\"GET\", \"/repos/:owner/:repo/pulls/comments\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/pulls/comments/:number\", \"\"},\n\n\t\t{\"PUT\", \"/repos/:owner/:repo/pulls/:number/comments\", \"\"},\n\n\t\t{\"PATCH\", \"/repos/:owner/:repo/pulls/comments/:number\", \"\"},\n\t\t{\"DELETE\", \"/repos/:owner/:repo/pulls/comments/:number\", \"\"},\n\n\t\t// Repositories\n\t\t{\"GET\", \"/user/repos\", \"\"},\n\t\t{\"GET\", \"/users/:user/repos\", \"\"},\n\t\t{\"GET\", \"/orgs/:org/repos\", \"\"},\n\t\t{\"GET\", \"/repositories\", \"\"},\n\t\t{\"POST\", \"/user/repos\", \"\"},\n\t\t{\"POST\", \"/orgs/:org/repos\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo\", \"\"},\n\n\t\t{\"PATCH\", \"/repos/:owner/:repo\", \"\"},\n\n\t\t{\"GET\", \"/repos/:owner/:repo/contributors\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/languages\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/teams\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/tags\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/branches\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/branches/:branch\", \"\"},\n\t\t{\"DELETE\", \"/repos/:owner/:repo\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/collaborators\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/collaborators/:user\", \"\"},\n\t\t{\"PUT\", \"/repos/:owner/:repo/collaborators/:user\", \"\"},\n\t\t{\"DELETE\", \"/repos/:owner/:repo/collaborators/:user\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/comments\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/commits/:sha/comments\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/commits/:sha/comments\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/comments/:id\", \"\"},\n\n\t\t{\"PATCH\", \"/repos/:owner/:repo/comments/:id\", \"\"},\n\n\t\t{\"DELETE\", \"/repos/:owner/:repo/comments/:id\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/commits\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/commits/:sha\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/readme\", \"\"},\n\n\t\t//{\"GET\", \"/repos/:owner/:repo/contents/*path\", \"\"},\n\t\t//{\"PUT\", \"/repos/:owner/:repo/contents/*path\", \"\"},\n\t\t//{\"DELETE\", \"/repos/:owner/:repo/contents/*path\", \"\"},\n\n\t\t{\"GET\", \"/repos/:owner/:repo/:archive_format/:ref\", \"\"},\n\n\t\t{\"GET\", \"/repos/:owner/:repo/keys\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/keys/:id\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/keys\", \"\"},\n\n\t\t{\"PATCH\", \"/repos/:owner/:repo/keys/:id\", \"\"},\n\n\t\t{\"DELETE\", \"/repos/:owner/:repo/keys/:id\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/downloads\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/downloads/:id\", \"\"},\n\t\t{\"DELETE\", \"/repos/:owner/:repo/downloads/:id\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/forks\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/forks\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/hooks\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/hooks/:id\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/hooks\", \"\"},\n\n\t\t{\"PATCH\", \"/repos/:owner/:repo/hooks/:id\", \"\"},\n\n\t\t{\"POST\", \"/repos/:owner/:repo/hooks/:id/tests\", \"\"},\n\t\t{\"DELETE\", \"/repos/:owner/:repo/hooks/:id\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/merges\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/releases\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/releases/:id\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/releases\", \"\"},\n\n\t\t{\"PATCH\", \"/repos/:owner/:repo/releases/:id\", \"\"},\n\n\t\t{\"DELETE\", \"/repos/:owner/:repo/releases/:id\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/releases/:id/assets\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/stats/contributors\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/stats/commit_activity\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/stats/code_frequency\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/stats/participation\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/stats/punch_card\", \"\"},\n\t\t{\"GET\", \"/repos/:owner/:repo/statuses/:ref\", \"\"},\n\t\t{\"POST\", \"/repos/:owner/:repo/statuses/:ref\", \"\"},\n\n\t\t// Search\n\t\t{\"GET\", \"/search/repositories\", \"\"},\n\t\t{\"GET\", \"/search/code\", \"\"},\n\t\t{\"GET\", \"/search/issues\", \"\"},\n\t\t{\"GET\", \"/search/users\", \"\"},\n\t\t{\"GET\", \"/legacy/issues/search/:owner/:repository/:state/:keyword\", \"\"},\n\t\t{\"GET\", \"/legacy/repos/search/:keyword\", \"\"},\n\t\t{\"GET\", \"/legacy/user/search/:keyword\", \"\"},\n\t\t{\"GET\", \"/legacy/user/email/:email\", \"\"},\n\n\t\t// Users\n\t\t{\"GET\", \"/users/:user\", \"\"},\n\t\t{\"GET\", \"/user\", \"\"},\n\n\t\t{\"PATCH\", \"/user\", \"\"},\n\n\t\t{\"GET\", \"/users\", \"\"},\n\t\t{\"GET\", \"/user/emails\", \"\"},\n\t\t{\"POST\", \"/user/emails\", \"\"},\n\t\t{\"DELETE\", \"/user/emails\", \"\"},\n\t\t{\"GET\", \"/users/:user/followers\", \"\"},\n\t\t{\"GET\", \"/user/followers\", \"\"},\n\t\t{\"GET\", \"/users/:user/following\", \"\"},\n\t\t{\"GET\", \"/user/following\", \"\"},\n\t\t{\"GET\", \"/user/following/:user\", \"\"},\n\t\t{\"GET\", \"/users/:user/following/:target_user\", \"\"},\n\t\t{\"PUT\", \"/user/following/:user\", \"\"},\n\t\t{\"DELETE\", \"/user/following/:user\", \"\"},\n\t\t{\"GET\", \"/users/:user/keys\", \"\"},\n\t\t{\"GET\", \"/user/keys\", \"\"},\n\t\t{\"GET\", \"/user/keys/:id\", \"\"},\n\t\t{\"POST\", \"/user/keys\", \"\"},\n\n\t\t{\"PATCH\", \"/user/keys/:id\", \"\"},\n\n\t\t{\"DELETE\", \"/user/keys/:id\", \"\"},\n\t}\n\n\tparseAPI = []*Route{\n\t\t// Objects\n\t\t{\"POST\", \"/1/classes/:className\", \"\"},\n\t\t{\"GET\", \"/1/classes/:className/:objectId\", \"\"},\n\t\t{\"PUT\", \"/1/classes/:className/:objectId\", \"\"},\n\t\t{\"GET\", \"/1/classes/:className\", \"\"},\n\t\t{\"DELETE\", \"/1/classes/:className/:objectId\", \"\"},\n\n\t\t// Users\n\t\t{\"POST\", \"/1/users\", \"\"},\n\t\t{\"GET\", \"/1/login\", \"\"},\n\t\t{\"GET\", \"/1/users/:objectId\", \"\"},\n\t\t{\"PUT\", \"/1/users/:objectId\", \"\"},\n\t\t{\"GET\", \"/1/users\", \"\"},\n\t\t{\"DELETE\", \"/1/users/:objectId\", \"\"},\n\t\t{\"POST\", \"/1/requestPasswordReset\", \"\"},\n\n\t\t// Roles\n\t\t{\"POST\", \"/1/roles\", \"\"},\n\t\t{\"GET\", \"/1/roles/:objectId\", \"\"},\n\t\t{\"PUT\", \"/1/roles/:objectId\", \"\"},\n\t\t{\"GET\", \"/1/roles\", \"\"},\n\t\t{\"DELETE\", \"/1/roles/:objectId\", \"\"},\n\n\t\t// Files\n\t\t{\"POST\", \"/1/files/:fileName\", \"\"},\n\n\t\t// Analytics\n\t\t{\"POST\", \"/1/events/:eventName\", \"\"},\n\n\t\t// Push Notifications\n\t\t{\"POST\", \"/1/push\", \"\"},\n\n\t\t// Installations\n\t\t{\"POST\", \"/1/installations\", \"\"},\n\t\t{\"GET\", \"/1/installations/:objectId\", \"\"},\n\t\t{\"PUT\", \"/1/installations/:objectId\", \"\"},\n\t\t{\"GET\", \"/1/installations\", \"\"},\n\t\t{\"DELETE\", \"/1/installations/:objectId\", \"\"},\n\n\t\t// Cloud Functions\n\t\t{\"POST\", \"/1/functions\", \"\"},\n\t}\n\n\tgooglePlusAPI = []*Route{\n\t\t// People\n\t\t{\"GET\", \"/people/:userId\", \"\"},\n\t\t{\"GET\", \"/people\", \"\"},\n\t\t{\"GET\", \"/activities/:activityId/people/:collection\", \"\"},\n\t\t{\"GET\", \"/people/:userId/people/:collection\", \"\"},\n\t\t{\"GET\", \"/people/:userId/openIdConnect\", \"\"},\n\n\t\t// Activities\n\t\t{\"GET\", \"/people/:userId/activities/:collection\", \"\"},\n\t\t{\"GET\", \"/activities/:activityId\", \"\"},\n\t\t{\"GET\", \"/activities\", \"\"},\n\n\t\t// Comments\n\t\t{\"GET\", \"/activities/:activityId/comments\", \"\"},\n\t\t{\"GET\", \"/comments/:commentId\", \"\"},\n\n\t\t// Moments\n\t\t{\"POST\", \"/people/:userId/moments/:collection\", \"\"},\n\t\t{\"GET\", \"/people/:userId/moments/:collection\", \"\"},\n\t\t{\"DELETE\", \"/moments/:id\", \"\"},\n\t}\n\n\tparamAndAnyAPI = []*Route{\n\t\t{\"GET\", \"/root/:first/foo/*\", \"\"},\n\t\t{\"GET\", \"/root/:first/:second/*\", \"\"},\n\t\t{\"GET\", \"/root/:first/bar/:second/*\", \"\"},\n\t\t{\"GET\", \"/root/:first/qux/:second/:third/:fourth\", \"\"},\n\t\t{\"GET\", \"/root/:first/qux/:second/:third/:fourth/*\", \"\"},\n\t\t{\"GET\", \"/root/*\", \"\"},\n\n\t\t{\"POST\", \"/root/:first/foo/*\", \"\"},\n\t\t{\"POST\", \"/root/:first/:second/*\", \"\"},\n\t\t{\"POST\", \"/root/:first/bar/:second/*\", \"\"},\n\t\t{\"POST\", \"/root/:first/qux/:second/:third/:fourth\", \"\"},\n\t\t{\"POST\", \"/root/:first/qux/:second/:third/:fourth/*\", \"\"},\n\t\t{\"POST\", \"/root/*\", \"\"},\n\n\t\t{\"PUT\", \"/root/:first/foo/*\", \"\"},\n\t\t{\"PUT\", \"/root/:first/:second/*\", \"\"},\n\t\t{\"PUT\", \"/root/:first/bar/:second/*\", \"\"},\n\t\t{\"PUT\", \"/root/:first/qux/:second/:third/:fourth\", \"\"},\n\t\t{\"PUT\", \"/root/:first/qux/:second/:third/:fourth/*\", \"\"},\n\t\t{\"PUT\", \"/root/*\", \"\"},\n\n\t\t{\"DELETE\", \"/root/:first/foo/*\", \"\"},\n\t\t{\"DELETE\", \"/root/:first/:second/*\", \"\"},\n\t\t{\"DELETE\", \"/root/:first/bar/:second/*\", \"\"},\n\t\t{\"DELETE\", \"/root/:first/qux/:second/:third/:fourth\", \"\"},\n\t\t{\"DELETE\", \"/root/:first/qux/:second/:third/:fourth/*\", \"\"},\n\t\t{\"DELETE\", \"/root/*\", \"\"},\n\t}\n\n\tparamAndAnyAPIToFind = []*Route{\n\t\t{\"GET\", \"/root/one/foo/after/the/asterisk\", \"\"},\n\t\t{\"GET\", \"/root/one/foo/path/after/the/asterisk\", \"\"},\n\t\t{\"GET\", \"/root/one/two/path/after/the/asterisk\", \"\"},\n\t\t{\"GET\", \"/root/one/bar/two/after/the/asterisk\", \"\"},\n\t\t{\"GET\", \"/root/one/qux/two/three/four\", \"\"},\n\t\t{\"GET\", \"/root/one/qux/two/three/four/after/the/asterisk\", \"\"},\n\n\t\t{\"POST\", \"/root/one/foo/after/the/asterisk\", \"\"},\n\t\t{\"POST\", \"/root/one/foo/path/after/the/asterisk\", \"\"},\n\t\t{\"POST\", \"/root/one/two/path/after/the/asterisk\", \"\"},\n\t\t{\"POST\", \"/root/one/bar/two/after/the/asterisk\", \"\"},\n\t\t{\"POST\", \"/root/one/qux/two/three/four\", \"\"},\n\t\t{\"POST\", \"/root/one/qux/two/three/four/after/the/asterisk\", \"\"},\n\n\t\t{\"PUT\", \"/root/one/foo/after/the/asterisk\", \"\"},\n\t\t{\"PUT\", \"/root/one/foo/path/after/the/asterisk\", \"\"},\n\t\t{\"PUT\", \"/root/one/two/path/after/the/asterisk\", \"\"},\n\t\t{\"PUT\", \"/root/one/bar/two/after/the/asterisk\", \"\"},\n\t\t{\"PUT\", \"/root/one/qux/two/three/four\", \"\"},\n\t\t{\"PUT\", \"/root/one/qux/two/three/four/after/the/asterisk\", \"\"},\n\n\t\t{\"DELETE\", \"/root/one/foo/after/the/asterisk\", \"\"},\n\t\t{\"DELETE\", \"/root/one/foo/path/after/the/asterisk\", \"\"},\n\t\t{\"DELETE\", \"/root/one/two/path/after/the/asterisk\", \"\"},\n\t\t{\"DELETE\", \"/root/one/bar/two/after/the/asterisk\", \"\"},\n\t\t{\"DELETE\", \"/root/one/qux/two/three/four\", \"\"},\n\t\t{\"DELETE\", \"/root/one/qux/two/three/four/after/the/asterisk\", \"\"},\n\t}\n\n\tmissesAPI = []*Route{\n\t\t{\"GET\", \"/missOne\", \"\"},\n\t\t{\"GET\", \"/miss/two\", \"\"},\n\t\t{\"GET\", \"/miss/three/levels\", \"\"},\n\t\t{\"GET\", \"/miss/four/levels/nooo\", \"\"},\n\n\t\t{\"POST\", \"/missOne\", \"\"},\n\t\t{\"POST\", \"/miss/two\", \"\"},\n\t\t{\"POST\", \"/miss/three/levels\", \"\"},\n\t\t{\"POST\", \"/miss/four/levels/nooo\", \"\"},\n\n\t\t{\"PUT\", \"/missOne\", \"\"},\n\t\t{\"PUT\", \"/miss/two\", \"\"},\n\t\t{\"PUT\", \"/miss/three/levels\", \"\"},\n\t\t{\"PUT\", \"/miss/four/levels/nooo\", \"\"},\n\n\t\t{\"DELETE\", \"/missOne\", \"\"},\n\t\t{\"DELETE\", \"/miss/two\", \"\"},\n\t\t{\"DELETE\", \"/miss/three/levels\", \"\"},\n\t\t{\"DELETE\", \"/miss/four/levels/nooo\", \"\"},\n\t}\n\n\t// handlerHelper created a function that will set a context key for assertion\n\thandlerHelper = func(key string, value int) func(c Context) error {\n\t\treturn func(c Context) error {\n\t\t\tc.Set(key, value)\n\t\t\tc.Set(\"path\", c.Path())\n\t\t\treturn nil\n\t\t}\n\t}\n\thandlerFunc = func(c Context) error {\n\t\tc.Set(\"path\", c.Path())\n\t\treturn nil\n\t}\n)\n\nfunc checkUnusedParamValues(t *testing.T, c *context, expectParam map[string]string) {\n\tfor i, p := range c.pnames {\n\t\tvalue := c.pvalues[i]\n\t\tif value != \"\" {\n\t\t\tif expectParam == nil {\n\t\t\t\tt.Errorf(\"pValue '%v' is set for param name '%v' but we are not expecting it with expectParam\", value, p)\n\t\t\t} else {\n\t\t\t\tif _, ok := expectParam[p]; !ok {\n\t\t\t\t\tt.Errorf(\"pValue '%v' is set for param name '%v' but we are not expecting it with expectParam\", value, p)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRouterStatic(t *testing.T) {\n\te := New()\n\tr := e.router\n\tpath := \"/folders/a/files/echo.gif\"\n\tr.Add(http.MethodGet, path, handlerFunc)\n\tc := e.NewContext(nil, nil).(*context)\n\n\tr.Find(http.MethodGet, path, c)\n\tc.handler(c)\n\n\tassert.Equal(t, path, c.Get(\"path\"))\n}\n\nfunc TestRouterNoRoutablePath(t *testing.T) {\n\te := New()\n\tr := e.router\n\tc := e.NewContext(nil, nil).(*context)\n\n\tr.Find(http.MethodGet, \"/notfound\", c)\n\tc.handler(c)\n\n\t// No routable path, don't set Path.\n\tassert.Equal(t, \"\", c.Path())\n}\n\nfunc TestRouterParam(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\tr.Add(http.MethodGet, \"/users/:id\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\tname        string\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t}{\n\t\t{\n\t\t\tname:        \"route /users/1 to /users/:id\",\n\t\t\twhenURL:     \"/users/1\",\n\t\t\texpectRoute: \"/users/:id\",\n\t\t\texpectParam: map[string]string{\"id\": \"1\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /users/1/ to /users/:id\",\n\t\t\twhenURL:     \"/users/1/\",\n\t\t\texpectRoute: \"/users/:id\",\n\t\t\texpectParam: map[string]string{\"id\": \"1/\"},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\t\t\tr.Find(http.MethodGet, tc.whenURL, c)\n\n\t\t\tc.handler(c)\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\nfunc TestRouter_addAndMatchAllSupportedMethods(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname            string\n\t\tgivenNoAddRoute bool\n\t\twhenMethod      string\n\t\texpectPath      string\n\t\texpectError     string\n\t}{\n\t\t{name: \"ok, CONNECT\", whenMethod: http.MethodConnect},\n\t\t{name: \"ok, DELETE\", whenMethod: http.MethodDelete},\n\t\t{name: \"ok, GET\", whenMethod: http.MethodGet},\n\t\t{name: \"ok, HEAD\", whenMethod: http.MethodHead},\n\t\t{name: \"ok, OPTIONS\", whenMethod: http.MethodOptions},\n\t\t{name: \"ok, PATCH\", whenMethod: http.MethodPatch},\n\t\t{name: \"ok, POST\", whenMethod: http.MethodPost},\n\t\t{name: \"ok, PROPFIND\", whenMethod: PROPFIND},\n\t\t{name: \"ok, PUT\", whenMethod: http.MethodPut},\n\t\t{name: \"ok, TRACE\", whenMethod: http.MethodTrace},\n\t\t{name: \"ok, REPORT\", whenMethod: REPORT},\n\t\t{name: \"ok, NON_TRADITIONAL_METHOD\", whenMethod: \"NON_TRADITIONAL_METHOD\"},\n\t\t{\n\t\t\tname:            \"ok, NOT_EXISTING_METHOD\",\n\t\t\twhenMethod:      \"NOT_EXISTING_METHOD\",\n\t\t\tgivenNoAddRoute: true,\n\t\t\texpectPath:      \"/*\",\n\t\t\texpectError:     \"code=405, message=Method Not Allowed\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\n\t\t\te.GET(\"/*\", handlerFunc)\n\n\t\t\tif !tc.givenNoAddRoute {\n\t\t\t\te.Add(tc.whenMethod, \"/my/*\", handlerFunc)\n\t\t\t}\n\n\t\t\treq := httptest.NewRequest(tc.whenMethod, \"/my/some-url\", nil)\n\t\t\trec := httptest.NewRecorder()\n\t\t\tc := e.NewContext(req, rec).(*context)\n\n\t\t\te.router.Find(tc.whenMethod, \"/my/some-url\", c)\n\t\t\terr := c.handler(c)\n\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\n\t\t\texpectPath := \"/my/*\"\n\t\t\tif tc.expectPath != \"\" {\n\t\t\t\texpectPath = tc.expectPath\n\t\t\t}\n\t\t\tassert.Equal(t, expectPath, c.Path())\n\t\t})\n\t}\n}\n\nfunc TestMethodNotAllowedAndNotFound(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\t// Routes\n\tr.Add(http.MethodGet, \"/*\", handlerFunc)\n\tr.Add(http.MethodPost, \"/users/:id\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\tname              string\n\t\twhenMethod        string\n\t\twhenURL           string\n\t\texpectRoute       interface{}\n\t\texpectParam       map[string]string\n\t\texpectError       error\n\t\texpectAllowHeader string\n\t}{\n\t\t{\n\t\t\tname:        \"exact match for route+method\",\n\t\t\twhenMethod:  http.MethodPost,\n\t\t\twhenURL:     \"/users/1\",\n\t\t\texpectRoute: \"/users/:id\",\n\t\t\texpectParam: map[string]string{\"id\": \"1\"},\n\t\t},\n\t\t{\n\t\t\tname:              \"matches node but not method. sends 405 from best match node\",\n\t\t\twhenMethod:        http.MethodPut,\n\t\t\twhenURL:           \"/users/1\",\n\t\t\texpectRoute:       nil,\n\t\t\texpectError:       ErrMethodNotAllowed,\n\t\t\texpectAllowHeader: \"OPTIONS, POST\",\n\t\t},\n\t\t{\n\t\t\tname:        \"best match is any route up in tree\",\n\t\t\twhenMethod:  http.MethodGet,\n\t\t\twhenURL:     \"/users/1\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"users/1\"},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(tc.whenMethod, tc.whenURL, nil)\n\t\t\trec := httptest.NewRecorder()\n\t\t\tc := e.NewContext(req, rec).(*context)\n\n\t\t\tmethod := http.MethodGet\n\t\t\tif tc.whenMethod != \"\" {\n\t\t\t\tmethod = tc.whenMethod\n\t\t\t}\n\t\t\tr.Find(method, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tif tc.expectError != nil {\n\t\t\t\tassert.Equal(t, tc.expectError, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\n\t\t\tassert.Equal(t, tc.expectAllowHeader, c.Response().Header().Get(HeaderAllow))\n\t\t})\n\t}\n}\n\nfunc TestRouterOptionsMethodHandler(t *testing.T) {\n\te := New()\n\n\tvar keyInContext interface{}\n\te.Use(func(next HandlerFunc) HandlerFunc {\n\t\treturn func(c Context) error {\n\t\t\terr := next(c)\n\t\t\tkeyInContext = c.Get(ContextKeyHeaderAllow)\n\t\t\treturn err\n\t\t}\n\t})\n\te.GET(\"/test\", func(c Context) error {\n\t\treturn c.String(http.StatusOK, \"Echo!\")\n\t})\n\n\treq := httptest.NewRequest(http.MethodOptions, \"/test\", nil)\n\trec := httptest.NewRecorder()\n\te.ServeHTTP(rec, req)\n\n\tassert.Equal(t, http.StatusNoContent, rec.Code)\n\tassert.Equal(t, \"OPTIONS, GET\", rec.Header().Get(HeaderAllow))\n\tassert.Equal(t, \"OPTIONS, GET\", keyInContext)\n}\n\nfunc TestRouterTwoParam(t *testing.T) {\n\te := New()\n\tr := e.router\n\tr.Add(http.MethodGet, \"/users/:uid/files/:fid\", handlerFunc)\n\tc := e.NewContext(nil, nil).(*context)\n\n\tr.Find(http.MethodGet, \"/users/1/files/1\", c)\n\n\tassert.Equal(t, \"1\", c.Param(\"uid\"))\n\tassert.Equal(t, \"1\", c.Param(\"fid\"))\n}\n\n// Issue #378\nfunc TestRouterParamWithSlash(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\tr.Add(http.MethodGet, \"/a/:b/c/d/:e\", handlerFunc)\n\tr.Add(http.MethodGet, \"/a/:b/c/:d/:f\", handlerFunc)\n\n\tc := e.NewContext(nil, nil).(*context)\n\tr.Find(http.MethodGet, \"/a/1/c/d/2/3\", c) // `2/3` should mapped to path `/a/:b/c/d/:e` and into `:e`\n\n\terr := c.handler(c)\n\tassert.Equal(t, \"/a/:b/c/d/:e\", c.Get(\"path\"))\n\tassert.NoError(t, err)\n}\n\n// Issue #1754 - router needs to backtrack multiple levels upwards in tree to find the matching route\n// route evaluation order\n//\n// Routes:\n// 1) /a/:b/c\n// 2) /a/c/d\n// 3) /a/c/df\n//\n// 4) /a/*/f\n// 5) /:e/c/f\n//\n// 6) /*\n//\n// Searching route for \"/a/c/f\" should match \"/a/*/f\"\n// When route `4) /a/*/f` is not added then request for \"/a/c/f\" should match \"/:e/c/f\"\n//\n//\t              +----------+\n//\t        +-----+ \"/\" root +--------------------+--------------------------+\n//\t        |     +----------+                    |                          |\n//\t        |                                     |                          |\n//\t+-------v-------+                         +---v---------+        +-------v---+\n//\t| \"a/\" (static) +---------------+         | \":\" (param) |        | \"*\" (any) |\n//\t+-+----------+--+               |         +-----------+-+        +-----------+\n//\t  |          |                  |                     |\n//\n// +---------------v+  +-- ---v------+    +------v----+          +-----v-----------+\n// | \"c/d\" (static) |  | \":\" (param) |    | \"*\" (any) |          | \"/c/f\" (static) |\n// +---------+------+  +--------+----+    +----------++          +-----------------+\n//\n//\t|                  |                    |\n//\t|                  |                    |\n//\n// +---------v----+      +------v--------+    +------v--------+\n// | \"f\" (static) |      | \"/c\" (static) |    | \"/f\" (static) |\n// +--------------+      +---------------+    +---------------+\nfunc TestRouteMultiLevelBacktracking(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname        string\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t}{\n\t\t{\n\t\t\tname:        \"route /a/c/df to /a/c/df\",\n\t\t\twhenURL:     \"/a/c/df\",\n\t\t\texpectRoute: \"/a/c/df\",\n\t\t},\n\t\t{\n\t\t\tname:        \"route /a/x/df to /a/:b/c\",\n\t\t\twhenURL:     \"/a/x/c\",\n\t\t\texpectRoute: \"/a/:b/c\",\n\t\t\texpectParam: map[string]string{\"b\": \"x\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /a/x/f to /a/*/f\",\n\t\t\twhenURL:     \"/a/x/f\",\n\t\t\texpectRoute: \"/a/*/f\",\n\t\t\texpectParam: map[string]string{\"*\": \"x/f\"}, // NOTE: `x` would be probably more suitable\n\t\t},\n\t\t{\n\t\t\tname:        \"route /b/c/f to /:e/c/f\",\n\t\t\twhenURL:     \"/b/c/f\",\n\t\t\texpectRoute: \"/:e/c/f\",\n\t\t\texpectParam: map[string]string{\"e\": \"b\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /b/c/c to /*\",\n\t\t\twhenURL:     \"/b/c/c\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"b/c/c\"},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\tr := e.router\n\n\t\t\tr.Add(http.MethodGet, \"/a/:b/c\", handlerHelper(\"case\", 1))\n\t\t\tr.Add(http.MethodGet, \"/a/c/d\", handlerHelper(\"case\", 2))\n\t\t\tr.Add(http.MethodGet, \"/a/c/df\", handlerHelper(\"case\", 3))\n\t\t\tr.Add(http.MethodGet, \"/a/*/f\", handlerHelper(\"case\", 4))\n\t\t\tr.Add(http.MethodGet, \"/:e/c/f\", handlerHelper(\"case\", 5))\n\t\t\tr.Add(http.MethodGet, \"/*\", handlerHelper(\"case\", 6))\n\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\t\t\tr.Find(http.MethodGet, tc.whenURL, c)\n\n\t\t\tc.handler(c)\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\n// Issue #1754 - router needs to backtrack multiple levels upwards in tree to find the matching route\n// route evaluation order\n//\n// Request for \"/a/c/f\" should match \"/:e/c/f\"\n//\n//\t                       +-0,7--------+\n//\t                       | \"/\" (root) |----------------------------------+\n//\t                       +------------+                                  |\n//\t                            |      |                                   |\n//\t                            |      |                                   |\n//\t        +-1,6-----------+   |      |          +-8-----------+   +------v----+\n//\t        | \"a/\" (static) +<--+      +--------->+ \":\" (param) |   | \"*\" (any) |\n//\t        +---------------+                     +-------------+   +-----------+\n//\t           |          |                             |\n//\t+-2--------v-----+   +v-3,5--------+       +-9------v--------+\n//\t| \"c/d\" (static) |   | \":\" (param) |       | \"/c/f\" (static) |\n//\t+----------------+   +-------------+       +-----------------+\n//\t                      |\n//\t                 +-4--v----------+\n//\t                 | \"/c\" (static) |\n//\t                 +---------------+\nfunc TestRouteMultiLevelBacktracking2(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\tr.Add(http.MethodGet, \"/a/:b/c\", handlerFunc)\n\tr.Add(http.MethodGet, \"/a/c/d\", handlerFunc)\n\tr.Add(http.MethodGet, \"/a/c/df\", handlerFunc)\n\tr.Add(http.MethodGet, \"/:e/c/f\", handlerFunc)\n\tr.Add(http.MethodGet, \"/*\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\tname        string\n\t\twhenURL     string\n\t\texpectRoute string\n\t\texpectParam map[string]string\n\t}{\n\t\t{\n\t\t\tname:        \"route /a/c/df to /a/c/df\",\n\t\t\twhenURL:     \"/a/c/df\",\n\t\t\texpectRoute: \"/a/c/df\",\n\t\t},\n\t\t{\n\t\t\tname:        \"route /a/x/df to /a/:b/c\",\n\t\t\twhenURL:     \"/a/x/c\",\n\t\t\texpectRoute: \"/a/:b/c\",\n\t\t\texpectParam: map[string]string{\"b\": \"x\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /a/c/f to /:e/c/f\",\n\t\t\twhenURL:     \"/a/c/f\",\n\t\t\texpectRoute: \"/:e/c/f\",\n\t\t\texpectParam: map[string]string{\"e\": \"a\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /b/c/f to /:e/c/f\",\n\t\t\twhenURL:     \"/b/c/f\",\n\t\t\texpectRoute: \"/:e/c/f\",\n\t\t\texpectParam: map[string]string{\"e\": \"b\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /b/c/c to /*\",\n\t\t\twhenURL:     \"/b/c/c\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"b/c/c\"},\n\t\t},\n\t\t{ // this traverses `/a/:b/c` and `/:e/c/f` branches and eventually backtracks to `/*`\n\t\t\tname:        \"route /a/c/cf to /*\",\n\t\t\twhenURL:     \"/a/c/cf\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"a/c/cf\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /anyMatch to /*\",\n\t\t\twhenURL:     \"/anyMatch\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"anyMatch\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /anyMatch/withSlash to /*\",\n\t\t\twhenURL:     \"/anyMatch/withSlash\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"anyMatch/withSlash\"},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\tr.Find(http.MethodGet, tc.whenURL, c)\n\n\t\t\tc.handler(c)\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\nfunc TestRouterBacktrackingFromMultipleParamKinds(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\tr.Add(http.MethodGet, \"/*\", handlerFunc) // this can match only path that does not have slash in it\n\tr.Add(http.MethodGet, \"/:1/second\", handlerFunc)\n\tr.Add(http.MethodGet, \"/:1/:2\", handlerFunc) // this acts as match ANY for all routes that have at least one slash\n\tr.Add(http.MethodGet, \"/:1/:2/third\", handlerFunc)\n\tr.Add(http.MethodGet, \"/:1/:2/:3/fourth\", handlerFunc)\n\tr.Add(http.MethodGet, \"/:1/:2/:3/:4/fifth\", handlerFunc)\n\n\tc := e.NewContext(nil, nil).(*context)\n\tvar testCases = []struct {\n\t\tname        string\n\t\twhenURL     string\n\t\texpectRoute string\n\t\texpectParam map[string]string\n\t}{\n\t\t{\n\t\t\tname:        \"route /first to /*\",\n\t\t\twhenURL:     \"/first\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"first\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /first/second to /:1/second\",\n\t\t\twhenURL:     \"/first/second\",\n\t\t\texpectRoute: \"/:1/second\",\n\t\t\texpectParam: map[string]string{\"1\": \"first\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /first/second-new to /:1/:2\",\n\t\t\twhenURL:     \"/first/second-new\",\n\t\t\texpectRoute: \"/:1/:2\",\n\t\t\texpectParam: map[string]string{\n\t\t\t\t\"1\": \"first\",\n\t\t\t\t\"2\": \"second-new\",\n\t\t\t},\n\t\t},\n\t\t{ // FIXME: should match `/:1/:2` when backtracking in tree. this 1 level backtracking fails even with old implementation\n\t\t\tname:        \"route /first/second/ to /:1/:2\",\n\t\t\twhenURL:     \"/first/second/\",\n\t\t\texpectRoute: \"/*\",                                    // \"/:1/:2\",\n\t\t\texpectParam: map[string]string{\"*\": \"first/second/\"}, // map[string]string{\"1\": \"first\", \"2\": \"second/\"},\n\t\t},\n\t\t{ // FIXME: should match `/:1/:2`. same backtracking problem. when backtracking is at `/:1/:2` during backtracking this node should be match as it has executable handler\n\t\t\tname:        \"route /first/second/third/fourth/fifth/nope to /:1/:2\",\n\t\t\twhenURL:     \"/first/second/third/fourth/fifth/nope\",\n\t\t\texpectRoute: \"/*\",                                                           // \"/:1/:2\",\n\t\t\texpectParam: map[string]string{\"*\": \"first/second/third/fourth/fifth/nope\"}, // map[string]string{\"1\": \"first\", \"2\": \"second/third/fourth/fifth/nope\"},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tr.Find(http.MethodGet, tc.whenURL, c)\n\n\t\t\tc.handler(c)\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\nfunc TestNotFoundRouteAnyKind(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname        string\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectID    int\n\t\texpectParam map[string]string\n\t}{\n\t\t{\n\t\t\tname:        \"route not existent /xx to not found handler /*\",\n\t\t\twhenURL:     \"/xx\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectID:    4,\n\t\t\texpectParam: map[string]string{\"*\": \"xx\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route not existent /a/xx to not found handler /a/*\",\n\t\t\twhenURL:     \"/a/xx\",\n\t\t\texpectRoute: \"/a/*\",\n\t\t\texpectID:    5,\n\t\t\texpectParam: map[string]string{\"*\": \"xx\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route not existent /a/c/dxxx to not found handler /a/c/d*\",\n\t\t\twhenURL:     \"/a/c/dxxx\",\n\t\t\texpectRoute: \"/a/c/d*\",\n\t\t\texpectID:    6,\n\t\t\texpectParam: map[string]string{\"*\": \"xxx\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /a/c/df to /a/c/df\",\n\t\t\twhenURL:     \"/a/c/df\",\n\t\t\texpectRoute: \"/a/c/df\",\n\t\t\texpectID:    1,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\tr := e.router\n\n\t\t\tr.Add(http.MethodGet, \"/\", handlerHelper(\"ID\", 0))\n\t\t\tr.Add(http.MethodGet, \"/a/c/df\", handlerHelper(\"ID\", 1))\n\t\t\tr.Add(http.MethodGet, \"/a/b*\", handlerHelper(\"ID\", 2))\n\t\t\tr.Add(http.MethodPut, \"/*\", handlerHelper(\"ID\", 3))\n\n\t\t\tr.Add(RouteNotFound, \"/a/c/d*\", handlerHelper(\"ID\", 6))\n\t\t\tr.Add(RouteNotFound, \"/a/*\", handlerHelper(\"ID\", 5))\n\t\t\tr.Add(RouteNotFound, \"/*\", handlerHelper(\"ID\", 4))\n\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\t\t\tr.Find(http.MethodGet, tc.whenURL, c)\n\n\t\t\tc.handler(c)\n\n\t\t\ttestValue, _ := c.Get(\"ID\").(int)\n\t\t\tassert.Equal(t, tc.expectID, testValue)\n\t\t\tassert.Equal(t, tc.expectRoute, c.Path())\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\nfunc TestNotFoundRouteParamKind(t *testing.T) {\n\tvar testCases = []struct {\n\t\tname        string\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectID    int\n\t\texpectParam map[string]string\n\t}{\n\t\t{\n\t\t\tname:        \"route not existent /xx to not found handler /:file\",\n\t\t\twhenURL:     \"/xx\",\n\t\t\texpectRoute: \"/:file\",\n\t\t\texpectID:    4,\n\t\t\texpectParam: map[string]string{\"file\": \"xx\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route not existent /a/xx to not found handler /a/:file\",\n\t\t\twhenURL:     \"/a/xx\",\n\t\t\texpectRoute: \"/a/:file\",\n\t\t\texpectID:    5,\n\t\t\texpectParam: map[string]string{\"file\": \"xx\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route not existent /a/c/dxxx to not found handler /a/c/d:file\",\n\t\t\twhenURL:     \"/a/c/dxxx\",\n\t\t\texpectRoute: \"/a/c/d:file\",\n\t\t\texpectID:    6,\n\t\t\texpectParam: map[string]string{\"file\": \"xxx\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /a/c/df to /a/c/df\",\n\t\t\twhenURL:     \"/a/c/df\",\n\t\t\texpectRoute: \"/a/c/df\",\n\t\t\texpectID:    1,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\tr := e.router\n\n\t\t\tr.Add(http.MethodGet, \"/\", handlerHelper(\"ID\", 0))\n\t\t\tr.Add(http.MethodGet, \"/a/c/df\", handlerHelper(\"ID\", 1))\n\t\t\tr.Add(http.MethodGet, \"/a/b*\", handlerHelper(\"ID\", 2))\n\t\t\tr.Add(http.MethodPut, \"/*\", handlerHelper(\"ID\", 3))\n\n\t\t\tr.Add(RouteNotFound, \"/a/c/d:file\", handlerHelper(\"ID\", 6))\n\t\t\tr.Add(RouteNotFound, \"/a/:file\", handlerHelper(\"ID\", 5))\n\t\t\tr.Add(RouteNotFound, \"/:file\", handlerHelper(\"ID\", 4))\n\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\t\t\tr.Find(http.MethodGet, tc.whenURL, c)\n\n\t\t\tc.handler(c)\n\n\t\t\ttestValue, _ := c.Get(\"ID\").(int)\n\t\t\tassert.Equal(t, tc.expectID, testValue)\n\t\t\tassert.Equal(t, tc.expectRoute, c.Path())\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\nfunc TestNotFoundRouteStaticKind(t *testing.T) {\n\t// note: static not found handler is quite silly thing to have but we still support it\n\tvar testCases = []struct {\n\t\tname        string\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectID    int\n\t\texpectParam map[string]string\n\t}{\n\t\t{\n\t\t\tname:        \"route not existent / to not found handler /\",\n\t\t\twhenURL:     \"/\",\n\t\t\texpectRoute: \"/\",\n\t\t\texpectID:    3,\n\t\t\texpectParam: map[string]string{},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /a to /a\",\n\t\t\twhenURL:     \"/a\",\n\t\t\texpectRoute: \"/a\",\n\t\t\texpectID:    1,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\te := New()\n\t\t\tr := e.router\n\n\t\t\tr.Add(http.MethodPut, \"/\", handlerHelper(\"ID\", 0))\n\t\t\tr.Add(http.MethodGet, \"/a\", handlerHelper(\"ID\", 1))\n\t\t\tr.Add(http.MethodPut, \"/*\", handlerHelper(\"ID\", 2))\n\n\t\t\tr.Add(RouteNotFound, \"/\", handlerHelper(\"ID\", 3))\n\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\t\t\tr.Find(http.MethodGet, tc.whenURL, c)\n\n\t\t\tc.handler(c)\n\n\t\t\ttestValue, _ := c.Get(\"ID\").(int)\n\t\t\tassert.Equal(t, tc.expectID, testValue)\n\t\t\tassert.Equal(t, tc.expectRoute, c.Path())\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\nfunc TestRouter_notFoundRouteWithNodeSplitting(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\tr.Add(http.MethodGet, \"/test*\", handlerHelper(\"ID\", 0))\n\tr.Add(RouteNotFound, \"/*\", handlerHelper(\"ID\", 1))\n\tr.Add(RouteNotFound, \"/test\", handlerHelper(\"ID\", 2))\n\n\t// Tree before:\n\t// 1    `/`\n\t// 1.1      `*` (any) ID=1\n\t// 1.2      `test` (static) ID=2\n\t// 1.2.1        `*` (any) ID=0\n\n\t// node with path `test` has routeNotFound handler from previous Add call. Now when we insert `/te/st*` into router tree\n\t// This means that node `test` is split into `te` and `st` nodes and new node `/st*` is inserted.\n\t// On that split `/test` routeNotFound handler must not be lost.\n\tr.Add(http.MethodGet, \"/te/st*\", handlerHelper(\"ID\", 3))\n\t// Tree after:\n\t// 1    `/`\n\t// 1.1      `*` (any) ID=1\n\t// 1.2      `te` (static)\n\t// 1.2.1        `st` (static) ID=2\n\t// 1.2.1.1          `*` (any) ID=0\n\t// 1.2.2        `/st` (static)\n\t// 1.2.2.1          `*` (any) ID=3\n\n\tc := e.NewContext(nil, nil).(*context)\n\tr.Find(http.MethodPut, \"/test\", c)\n\n\tc.handler(c)\n\n\ttestValue, _ := c.Get(\"ID\").(int)\n\tassert.Equal(t, 2, testValue)\n\tassert.Equal(t, \"/test\", c.Path())\n}\n\n// Issue #1509\nfunc TestRouterParamStaticConflict(t *testing.T) {\n\te := New()\n\tr := e.router\n\thandler := func(c Context) error {\n\t\tc.Set(\"path\", c.Path())\n\t\treturn nil\n\t}\n\n\tg := e.Group(\"/g\")\n\tg.GET(\"/skills\", handler)\n\tg.GET(\"/status\", handler)\n\tg.GET(\"/:name\", handler)\n\n\tvar testCases = []struct {\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t}{\n\t\t{\n\t\t\twhenURL:     \"/g/s\",\n\t\t\texpectRoute: \"/g/:name\",\n\t\t\texpectParam: map[string]string{\"name\": \"s\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/g/status\",\n\t\t\texpectRoute: \"/g/status\",\n\t\t\texpectParam: map[string]string{\"name\": \"\"},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.whenURL, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\tr.Find(http.MethodGet, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\nfunc TestRouterParam_escapeColon(t *testing.T) {\n\t// to allow Google cloud API like route paths with colon in them\n\t// i.e. https://service.name/v1/some/resource/name:customVerb <- that `:customVerb` is not path param. It is just a string\n\te := New()\n\n\te.POST(\"/files/a/long/file\\\\:undelete\", handlerFunc)\n\te.POST(\"/multilevel\\\\:undelete/second\\\\:something\", handlerFunc)\n\te.POST(\"/mixed/:id/second\\\\:something\", handlerFunc)\n\te.POST(\"/v1/some/resource/name:customVerb\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t\texpectError string\n\t}{\n\t\t{\n\t\t\twhenURL:     \"/files/a/long/file:undelete\",\n\t\t\texpectRoute: \"/files/a/long/file\\\\:undelete\",\n\t\t\texpectParam: map[string]string{},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/multilevel:undelete/second:something\",\n\t\t\texpectRoute: \"/multilevel\\\\:undelete/second\\\\:something\",\n\t\t\texpectParam: map[string]string{},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/mixed/123/second:something\",\n\t\t\texpectRoute: \"/mixed/:id/second\\\\:something\",\n\t\t\texpectParam: map[string]string{\"id\": \"123\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/files/a/long/file:notMatching\",\n\t\t\texpectRoute: nil,\n\t\t\texpectError: \"code=404, message=Not Found\",\n\t\t\texpectParam: nil,\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/v1/some/resource/name:PATCH\",\n\t\t\texpectRoute: \"/v1/some/resource/name:customVerb\",\n\t\t\texpectParam: map[string]string{\"customVerb\": \":PATCH\"},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.whenURL, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\te.router.Find(http.MethodPost, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tif tc.expectError != \"\" {\n\t\t\t\tassert.EqualError(t, err, tc.expectError)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\nfunc TestRouterMatchAny(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\t// Routes\n\tr.Add(http.MethodGet, \"/\", handlerFunc)\n\tr.Add(http.MethodGet, \"/*\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/*\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t}{\n\t\t{\n\t\t\twhenURL:     \"/\",\n\t\t\texpectRoute: \"/\",\n\t\t\texpectParam: map[string]string{\"*\": \"\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/download\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"download\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/joe\",\n\t\t\texpectRoute: \"/users/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"joe\"},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.whenURL, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\tr.Find(http.MethodGet, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\n// NOTE: this is to document current implementation. Last added route with `*` asterisk is always the match and no\n// backtracking or more precise matching is done to find more suitable match.\n//\n// Current behaviour might not be correct or expected.\n// But this is where we are without well defined requirements/rules how (multiple) asterisks work in route\nfunc TestRouterAnyMatchesLastAddedAnyRoute(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\tr.Add(http.MethodGet, \"/users/*\", handlerHelper(\"case\", 1))\n\tr.Add(http.MethodGet, \"/users/*/action*\", handlerHelper(\"case\", 2))\n\n\tc := e.NewContext(nil, nil).(*context)\n\n\tr.Find(http.MethodGet, \"/users/xxx/action/sea\", c)\n\tc.handler(c)\n\tassert.Equal(t, \"/users/*/action*\", c.Get(\"path\"))\n\tassert.Equal(t, \"xxx/action/sea\", c.Param(\"*\"))\n\n\t// if we add another route then it is the last added and so it is matched\n\tr.Add(http.MethodGet, \"/users/*/action/search\", handlerHelper(\"case\", 3))\n\n\tr.Find(http.MethodGet, \"/users/xxx/action/sea\", c)\n\tc.handler(c)\n\tassert.Equal(t, \"/users/*/action/search\", c.Get(\"path\"))\n\tassert.Equal(t, \"xxx/action/sea\", c.Param(\"*\"))\n}\n\n// Issue #1739\nfunc TestRouterMatchAnyPrefixIssue(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\t// Routes\n\tr.Add(http.MethodGet, \"/*\", func(c Context) error {\n\t\tc.Set(\"path\", c.Path())\n\t\treturn nil\n\t})\n\tr.Add(http.MethodGet, \"/users/*\", func(c Context) error {\n\t\tc.Set(\"path\", c.Path())\n\t\treturn nil\n\t})\n\n\tvar testCases = []struct {\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t}{\n\t\t{\n\t\t\twhenURL:     \"/\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"users\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/\",\n\t\t\texpectRoute: \"/users/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users_prefix\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"users_prefix\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users_prefix/\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"users_prefix/\"},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.whenURL, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\tr.Find(http.MethodGet, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\n// TestRouterMatchAnySlash shall verify finding the best route\n// for any routes with trailing slash requests\nfunc TestRouterMatchAnySlash(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\t// Routes\n\tr.Add(http.MethodGet, \"/users\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/*\", handlerFunc)\n\tr.Add(http.MethodGet, \"/img/*\", handlerFunc)\n\tr.Add(http.MethodGet, \"/img/load\", handlerFunc)\n\tr.Add(http.MethodGet, \"/img/load/*\", handlerFunc)\n\tr.Add(http.MethodGet, \"/assets/*\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t\texpectError error\n\t}{\n\t\t{\n\t\t\twhenURL:     \"/\",\n\t\t\texpectRoute: nil,\n\t\t\texpectParam: map[string]string{\"*\": \"\"},\n\t\t\texpectError: ErrNotFound,\n\t\t},\n\t\t{ // Test trailing slash request for simple any route (see #1526)\n\t\t\twhenURL:     \"/users/\",\n\t\t\texpectRoute: \"/users/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/joe\",\n\t\t\texpectRoute: \"/users/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"joe\"},\n\t\t},\n\t\t// Test trailing slash request for nested any route (see #1526)\n\t\t{\n\t\t\twhenURL:     \"/img/load\",\n\t\t\texpectRoute: \"/img/load\",\n\t\t\texpectParam: map[string]string{\"*\": \"\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/img/load/\",\n\t\t\texpectRoute: \"/img/load/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/img/load/ben\",\n\t\t\texpectRoute: \"/img/load/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"ben\"},\n\t\t},\n\t\t// Test /assets/* any route\n\t\t{ // ... without trailing slash must not match\n\t\t\twhenURL:     \"/assets\",\n\t\t\texpectRoute: nil,\n\t\t\texpectParam: map[string]string{\"*\": \"\"},\n\t\t\texpectError: ErrNotFound,\n\t\t},\n\n\t\t{ // ... with trailing slash must match\n\t\t\twhenURL:     \"/assets/\",\n\t\t\texpectRoute: \"/assets/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"\"},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.whenURL, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\tr.Find(http.MethodGet, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tif tc.expectError != nil {\n\t\t\t\tassert.Equal(t, tc.expectError, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\nfunc TestRouterMatchAnyMultiLevel(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\t// Routes\n\tr.Add(http.MethodGet, \"/api/users/jack\", handlerFunc)\n\tr.Add(http.MethodGet, \"/api/users/jill\", handlerFunc)\n\tr.Add(http.MethodGet, \"/api/users/*\", handlerFunc)\n\tr.Add(http.MethodGet, \"/api/*\", handlerFunc)\n\tr.Add(http.MethodGet, \"/other/*\", handlerFunc)\n\tr.Add(http.MethodGet, \"/*\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t\texpectError error\n\t}{\n\t\t{\n\t\t\twhenURL:     \"/api/users/jack\",\n\t\t\texpectRoute: \"/api/users/jack\",\n\t\t\texpectParam: map[string]string{\"*\": \"\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/api/users/jill\",\n\t\t\texpectRoute: \"/api/users/jill\",\n\t\t\texpectParam: map[string]string{\"*\": \"\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/api/users/joe\",\n\t\t\texpectRoute: \"/api/users/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"joe\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/api/nousers/joe\",\n\t\t\texpectRoute: \"/api/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"nousers/joe\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/api/none\",\n\t\t\texpectRoute: \"/api/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"none\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/api/none\",\n\t\t\texpectRoute: \"/api/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"none\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/noapi/users/jim\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"noapi/users/jim\"},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.whenURL, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\tr.Find(http.MethodGet, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tif tc.expectError != nil {\n\t\t\t\tassert.Equal(t, tc.expectError, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\nfunc TestRouterMatchAnyMultiLevelWithPost(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\t// Routes\n\te.POST(\"/api/auth/login\", handlerFunc)\n\te.POST(\"/api/auth/forgotPassword\", handlerFunc)\n\te.Any(\"/api/*\", handlerFunc)\n\te.Any(\"/*\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\twhenMethod  string\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t\texpectError error\n\t}{\n\t\t{ // POST /api/auth/login shall choose login method\n\t\t\twhenURL:     \"/api/auth/login\",\n\t\t\twhenMethod:  http.MethodPost,\n\t\t\texpectRoute: \"/api/auth/login\",\n\t\t\texpectParam: map[string]string{\"*\": \"\"},\n\t\t},\n\t\t{ // POST /api/auth/logout shall choose nearest any route\n\t\t\twhenURL:     \"/api/auth/logout\",\n\t\t\twhenMethod:  http.MethodPost,\n\t\t\texpectRoute: \"/api/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"auth/logout\"},\n\t\t},\n\t\t{ // POST to /api/other/test shall choose nearest any route\n\t\t\twhenURL:     \"/api/other/test\",\n\t\t\twhenMethod:  http.MethodPost,\n\t\t\texpectRoute: \"/api/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"other/test\"},\n\t\t},\n\t\t{ // GET to /api/other/test shall choose nearest any route\n\t\t\twhenURL:     \"/api/other/test\",\n\t\t\twhenMethod:  http.MethodGet,\n\t\t\texpectRoute: \"/api/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"other/test\"},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.whenURL, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\tmethod := http.MethodGet\n\t\t\tif tc.whenMethod != \"\" {\n\t\t\t\tmethod = tc.whenMethod\n\t\t\t}\n\t\t\tr.Find(method, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tif tc.expectError != nil {\n\t\t\t\tassert.Equal(t, tc.expectError, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\nfunc TestRouterMicroParam(t *testing.T) {\n\te := New()\n\tr := e.router\n\tr.Add(http.MethodGet, \"/:a/:b/:c\", func(c Context) error {\n\t\treturn nil\n\t})\n\tc := e.NewContext(nil, nil).(*context)\n\tr.Find(http.MethodGet, \"/1/2/3\", c)\n\tassert.Equal(t, \"1\", c.Param(\"a\"))\n\tassert.Equal(t, \"2\", c.Param(\"b\"))\n\tassert.Equal(t, \"3\", c.Param(\"c\"))\n}\n\nfunc TestRouterMixParamMatchAny(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\t// Route\n\tr.Add(http.MethodGet, \"/users/:id/*\", func(c Context) error {\n\t\treturn nil\n\t})\n\tc := e.NewContext(nil, nil).(*context)\n\n\tr.Find(http.MethodGet, \"/users/joe/comments\", c)\n\tc.handler(c)\n\tassert.Equal(t, \"joe\", c.Param(\"id\"))\n}\n\nfunc TestRouterMultiRoute(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\t// Routes\n\tr.Add(http.MethodGet, \"/users\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/:id\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\twhenMethod  string\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t\texpectError error\n\t}{\n\t\t{\n\t\t\twhenURL:     \"/users\",\n\t\t\texpectRoute: \"/users\",\n\t\t\texpectParam: map[string]string{\"*\": \"\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/1\",\n\t\t\texpectRoute: \"/users/:id\",\n\t\t\texpectParam: map[string]string{\"id\": \"1\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/user\",\n\t\t\texpectRoute: nil,\n\t\t\texpectParam: map[string]string{\"*\": \"\"},\n\t\t\texpectError: ErrNotFound,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.whenURL, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\tmethod := http.MethodGet\n\t\t\tif tc.whenMethod != \"\" {\n\t\t\t\tmethod = tc.whenMethod\n\t\t\t}\n\t\t\tr.Find(method, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tif tc.expectError != nil {\n\t\t\t\tassert.Equal(t, tc.expectError, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\nfunc TestRouterPriority(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\t// Routes\n\tr.Add(http.MethodGet, \"/users\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/new\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/:id\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/dew\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/:id/files\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/newsee\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/*\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/new/*\", handlerFunc)\n\tr.Add(http.MethodGet, \"/*\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\twhenMethod  string\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t\texpectError error\n\t}{\n\t\t{\n\t\t\twhenURL:     \"/users\",\n\t\t\texpectRoute: \"/users\",\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/new\",\n\t\t\texpectRoute: \"/users/new\",\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/1\",\n\t\t\texpectRoute: \"/users/:id\",\n\t\t\texpectParam: map[string]string{\"id\": \"1\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/dew\",\n\t\t\texpectRoute: \"/users/dew\",\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/1/files\",\n\t\t\texpectRoute: \"/users/:id/files\",\n\t\t\texpectParam: map[string]string{\"id\": \"1\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/new\",\n\t\t\texpectRoute: \"/users/new\",\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/news\",\n\t\t\texpectRoute: \"/users/:id\",\n\t\t\texpectParam: map[string]string{\"id\": \"news\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/newsee\",\n\t\t\texpectRoute: \"/users/newsee\",\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/joe/books\",\n\t\t\texpectRoute: \"/users/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"joe/books\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/new/someone\",\n\t\t\texpectRoute: \"/users/new/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"someone\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/dew/someone\",\n\t\t\texpectRoute: \"/users/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"dew/someone\"},\n\t\t},\n\t\t{ // Route > /users/* should be matched although /users/dew exists\n\t\t\twhenURL:     \"/users/notexists/someone\",\n\t\t\texpectRoute: \"/users/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"notexists/someone\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/nousers\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"nousers\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/nousers/new\",\n\t\t\texpectRoute: \"/*\",\n\t\t\texpectParam: map[string]string{\"*\": \"nousers/new\"},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.whenURL, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\tmethod := http.MethodGet\n\t\t\tif tc.whenMethod != \"\" {\n\t\t\t\tmethod = tc.whenMethod\n\t\t\t}\n\t\t\tr.Find(method, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tif tc.expectError != nil {\n\t\t\t\tassert.Equal(t, tc.expectError, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\nfunc TestRouterIssue1348(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\tr.Add(http.MethodGet, \"/:lang/\", func(c Context) error {\n\t\treturn nil\n\t})\n\tr.Add(http.MethodGet, \"/:lang/dupa\", func(c Context) error {\n\t\treturn nil\n\t})\n}\n\n// Issue #372\nfunc TestRouterPriorityNotFound(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\t// Add\n\tr.Add(http.MethodGet, \"/a/foo\", handlerFunc)\n\tr.Add(http.MethodGet, \"/a/bar\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\twhenMethod  string\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t\texpectError error\n\t}{\n\t\t{\n\t\t\twhenURL:     \"/a/foo\",\n\t\t\texpectRoute: \"/a/foo\",\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/a/bar\",\n\t\t\texpectRoute: \"/a/bar\",\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/abc/def\",\n\t\t\texpectRoute: nil,\n\t\t\texpectError: ErrNotFound,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.whenURL, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\tmethod := http.MethodGet\n\t\t\tif tc.whenMethod != \"\" {\n\t\t\t\tmethod = tc.whenMethod\n\t\t\t}\n\t\t\tr.Find(method, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tif tc.expectError != nil {\n\t\t\t\tassert.Equal(t, tc.expectError, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\nfunc TestRouterParamNames(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\t// Routes\n\tr.Add(http.MethodGet, \"/users\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/:id\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/:uid/files/:fid\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\twhenMethod  string\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t\texpectError error\n\t}{\n\t\t{\n\t\t\twhenURL:     \"/users\",\n\t\t\texpectRoute: \"/users\",\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/1\",\n\t\t\texpectRoute: \"/users/:id\",\n\t\t\texpectParam: map[string]string{\"id\": \"1\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/1/files/1\",\n\t\t\texpectRoute: \"/users/:uid/files/:fid\",\n\t\t\texpectParam: map[string]string{\n\t\t\t\t\"uid\": \"1\",\n\t\t\t\t\"fid\": \"1\",\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.whenURL, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\tmethod := http.MethodGet\n\t\t\tif tc.whenMethod != \"\" {\n\t\t\t\tmethod = tc.whenMethod\n\t\t\t}\n\t\t\tr.Find(method, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tif tc.expectError != nil {\n\t\t\t\tassert.Equal(t, tc.expectError, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\n// Issue #623 and #1406\nfunc TestRouterStaticDynamicConflict(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\tr.Add(http.MethodGet, \"/dictionary/skills\", handlerHelper(\"a\", 1))\n\tr.Add(http.MethodGet, \"/dictionary/:name\", handlerHelper(\"b\", 2))\n\tr.Add(http.MethodGet, \"/users/new\", handlerHelper(\"d\", 4))\n\tr.Add(http.MethodGet, \"/users/:name\", handlerHelper(\"e\", 5))\n\tr.Add(http.MethodGet, \"/server\", handlerHelper(\"c\", 3))\n\tr.Add(http.MethodGet, \"/\", handlerHelper(\"f\", 6))\n\n\tvar testCases = []struct {\n\t\twhenMethod  string\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t\texpectError error\n\t}{\n\t\t{\n\t\t\twhenURL:     \"/dictionary/skills\",\n\t\t\texpectRoute: \"/dictionary/skills\",\n\t\t\texpectParam: map[string]string{\"*\": \"\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/dictionary/skillsnot\",\n\t\t\texpectRoute: \"/dictionary/:name\",\n\t\t\texpectParam: map[string]string{\"name\": \"skillsnot\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/dictionary/type\",\n\t\t\texpectRoute: \"/dictionary/:name\",\n\t\t\texpectParam: map[string]string{\"name\": \"type\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/server\",\n\t\t\texpectRoute: \"/server\",\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/new\",\n\t\t\texpectRoute: \"/users/new\",\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/new2\",\n\t\t\texpectRoute: \"/users/:name\",\n\t\t\texpectParam: map[string]string{\"name\": \"new2\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/\",\n\t\t\texpectRoute: \"/\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.whenURL, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\tmethod := http.MethodGet\n\t\t\tif tc.whenMethod != \"\" {\n\t\t\t\tmethod = tc.whenMethod\n\t\t\t}\n\t\t\tr.Find(method, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tif tc.expectError != nil {\n\t\t\t\tassert.Equal(t, tc.expectError, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\n// Issue #1348\nfunc TestRouterParamBacktraceNotFound(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\t// Add\n\tr.Add(http.MethodGet, \"/:param1\", handlerFunc)\n\tr.Add(http.MethodGet, \"/:param1/foo\", handlerFunc)\n\tr.Add(http.MethodGet, \"/:param1/bar\", handlerFunc)\n\tr.Add(http.MethodGet, \"/:param1/bar/:param2\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\tname        string\n\t\twhenMethod  string\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t\texpectError error\n\t}{\n\t\t{\n\t\t\tname:        \"route /a to /:param1\",\n\t\t\twhenURL:     \"/a\",\n\t\t\texpectRoute: \"/:param1\",\n\t\t\texpectParam: map[string]string{\"param1\": \"a\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /a/foo to /:param1/foo\",\n\t\t\twhenURL:     \"/a/foo\",\n\t\t\texpectRoute: \"/:param1/foo\",\n\t\t\texpectParam: map[string]string{\"param1\": \"a\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /a/bar to /:param1/bar\",\n\t\t\twhenURL:     \"/a/bar\",\n\t\t\texpectRoute: \"/:param1/bar\",\n\t\t\texpectParam: map[string]string{\"param1\": \"a\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /a/bar/b to /:param1/bar/:param2\",\n\t\t\twhenURL:     \"/a/bar/b\",\n\t\t\texpectRoute: \"/:param1/bar/:param2\",\n\t\t\texpectParam: map[string]string{\n\t\t\t\t\"param1\": \"a\",\n\t\t\t\t\"param2\": \"b\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"route /a/bbbbb should return 404\",\n\t\t\twhenURL:     \"/a/bbbbb\",\n\t\t\texpectRoute: nil,\n\t\t\texpectError: ErrNotFound,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\tmethod := http.MethodGet\n\t\t\tif tc.whenMethod != \"\" {\n\t\t\t\tmethod = tc.whenMethod\n\t\t\t}\n\t\t\tr.Find(method, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tif tc.expectError != nil {\n\t\t\t\tassert.Equal(t, tc.expectError, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\nfunc testRouterAPI(t *testing.T, api []*Route) {\n\te := New()\n\tr := e.router\n\n\tfor _, route := range api {\n\t\tr.Add(route.Method, route.Path, func(c Context) error {\n\t\t\treturn nil\n\t\t})\n\t}\n\tc := e.NewContext(nil, nil).(*context)\n\tfor _, route := range api {\n\t\tt.Run(route.Path, func(t *testing.T) {\n\t\t\tr.Find(route.Method, route.Path, c)\n\t\t\ttokens := strings.Split(route.Path[1:], \"/\")\n\t\t\tfor _, token := range tokens {\n\t\t\t\tif token[0] == ':' {\n\t\t\t\t\tassert.Equal(t, c.Param(token[1:]), token)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRouterGitHubAPI(t *testing.T) {\n\ttestRouterAPI(t, gitHubAPI)\n}\n\n// Issue #729\nfunc TestRouterParamAlias(t *testing.T) {\n\tapi := []*Route{\n\t\t{http.MethodGet, \"/users/:userID/following\", \"\"},\n\t\t{http.MethodGet, \"/users/:userID/followedBy\", \"\"},\n\t\t{http.MethodGet, \"/users/:userID/follow\", \"\"},\n\t}\n\ttestRouterAPI(t, api)\n}\n\n// Issue #1052\nfunc TestRouterParamOrdering(t *testing.T) {\n\tapi := []*Route{\n\t\t{http.MethodGet, \"/:a/:b/:c/:id\", \"\"},\n\t\t{http.MethodGet, \"/:a/:id\", \"\"},\n\t\t{http.MethodGet, \"/:a/:e/:id\", \"\"},\n\t}\n\ttestRouterAPI(t, api)\n\tapi2 := []*Route{\n\t\t{http.MethodGet, \"/:a/:id\", \"\"},\n\t\t{http.MethodGet, \"/:a/:e/:id\", \"\"},\n\t\t{http.MethodGet, \"/:a/:b/:c/:id\", \"\"},\n\t}\n\ttestRouterAPI(t, api2)\n\tapi3 := []*Route{\n\t\t{http.MethodGet, \"/:a/:b/:c/:id\", \"\"},\n\t\t{http.MethodGet, \"/:a/:e/:id\", \"\"},\n\t\t{http.MethodGet, \"/:a/:id\", \"\"},\n\t}\n\ttestRouterAPI(t, api3)\n}\n\n// Issue #1139\nfunc TestRouterMixedParams(t *testing.T) {\n\tapi := []*Route{\n\t\t{http.MethodGet, \"/teacher/:tid/room/suggestions\", \"\"},\n\t\t{http.MethodGet, \"/teacher/:id\", \"\"},\n\t}\n\ttestRouterAPI(t, api)\n\tapi2 := []*Route{\n\t\t{http.MethodGet, \"/teacher/:id\", \"\"},\n\t\t{http.MethodGet, \"/teacher/:tid/room/suggestions\", \"\"},\n\t}\n\ttestRouterAPI(t, api2)\n}\n\n// Issue #1466\nfunc TestRouterParam1466(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\tr.Add(http.MethodPost, \"/users/signup\", handlerFunc)\n\tr.Add(http.MethodPost, \"/users/signup/bulk\", handlerFunc)\n\tr.Add(http.MethodPost, \"/users/survey\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/:username\", handlerFunc)\n\tr.Add(http.MethodGet, \"/interests/:name/users\", handlerFunc)\n\tr.Add(http.MethodGet, \"/skills/:name/users\", handlerFunc)\n\t// Additional routes for Issue 1479\n\tr.Add(http.MethodGet, \"/users/:username/likes/projects/ids\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/:username/profile\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/:username/uploads/:type\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\twhenURL     string\n\t\texpectRoute interface{}\n\t\texpectParam map[string]string\n\t}{\n\t\t{\n\t\t\twhenURL:     \"/users/ajitem\",\n\t\t\texpectRoute: \"/users/:username\",\n\t\t\texpectParam: map[string]string{\"username\": \"ajitem\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/sharewithme\",\n\t\t\texpectRoute: \"/users/:username\",\n\t\t\texpectParam: map[string]string{\"username\": \"sharewithme\"},\n\t\t},\n\t\t{ // route `/users/signup` is registered for POST. so param route `/users/:username` (lesser priority) is matched as it has GET handler\n\t\t\twhenURL:     \"/users/signup\",\n\t\t\texpectRoute: \"/users/:username\",\n\t\t\texpectParam: map[string]string{\"username\": \"signup\"},\n\t\t},\n\t\t// Additional assertions for #1479\n\t\t{\n\t\t\twhenURL:     \"/users/sharewithme/likes/projects/ids\",\n\t\t\texpectRoute: \"/users/:username/likes/projects/ids\",\n\t\t\texpectParam: map[string]string{\"username\": \"sharewithme\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/ajitem/likes/projects/ids\",\n\t\t\texpectRoute: \"/users/:username/likes/projects/ids\",\n\t\t\texpectParam: map[string]string{\"username\": \"ajitem\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/sharewithme/profile\",\n\t\t\texpectRoute: \"/users/:username/profile\",\n\t\t\texpectParam: map[string]string{\"username\": \"sharewithme\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/ajitem/profile\",\n\t\t\texpectRoute: \"/users/:username/profile\",\n\t\t\texpectParam: map[string]string{\"username\": \"ajitem\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/sharewithme/uploads/self\",\n\t\t\texpectRoute: \"/users/:username/uploads/:type\",\n\t\t\texpectParam: map[string]string{\n\t\t\t\t\"username\": \"sharewithme\",\n\t\t\t\t\"type\":     \"self\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/ajitem/uploads/self\",\n\t\t\texpectRoute: \"/users/:username/uploads/:type\",\n\t\t\texpectParam: map[string]string{\n\t\t\t\t\"username\": \"ajitem\",\n\t\t\t\t\"type\":     \"self\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/tree/free\",\n\t\t\texpectRoute: nil, // not found\n\t\t\texpectParam: map[string]string{\"id\": \"\"},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.whenURL, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\tr.Find(http.MethodGet, tc.whenURL, c)\n\t\t\tc.handler(c)\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\n// Issue #1655\nfunc TestRouterFindNotPanicOrLoopsWhenContextSetParamValuesIsCalledWithLessValuesThanEchoMaxParam(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\tv0 := e.Group(\"/:version\")\n\tv0.GET(\"/admin\", func(c Context) error {\n\t\tc.SetParamNames(\"version\")\n\t\tc.SetParamValues(\"v1\")\n\t\treturn nil\n\t})\n\n\tv0.GET(\"/images/view/:id\", handlerHelper(\"iv\", 1))\n\tv0.GET(\"/images/:id\", handlerHelper(\"i\", 1))\n\tv0.GET(\"/view/*\", handlerHelper(\"v\", 1))\n\n\t//If this API is called before the next two one panic the other loops ( of course without my fix ;) )\n\tc := e.NewContext(nil, nil)\n\tr.Find(http.MethodGet, \"/v1/admin\", c)\n\tc.Handler()(c)\n\tassert.Equal(t, \"v1\", c.Param(\"version\"))\n\n\t//panic\n\tc = e.NewContext(nil, nil)\n\tr.Find(http.MethodGet, \"/v1/view/same-data\", c)\n\tc.Handler()(c)\n\tassert.Equal(t, \"same-data\", c.Param(\"*\"))\n\tassert.Equal(t, 1, c.Get(\"v\"))\n\n\t//looping\n\tc = e.NewContext(nil, nil)\n\tr.Find(http.MethodGet, \"/v1/images/view\", c)\n\tc.Handler()(c)\n\tassert.Equal(t, \"view\", c.Param(\"id\"))\n\tassert.Equal(t, 1, c.Get(\"i\"))\n}\n\n// Issue #1653\nfunc TestRouterPanicWhenParamNoRootOnlyChildsFailsFind(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\tr.Add(http.MethodGet, \"/users/create\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/:id/edit\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/:id/active\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\twhenURL      string\n\t\texpectRoute  interface{}\n\t\texpectParam  map[string]string\n\t\texpectStatus int\n\t}{\n\t\t{\n\t\t\twhenURL:     \"/users/alice/edit\",\n\t\t\texpectRoute: \"/users/:id/edit\",\n\t\t\texpectParam: map[string]string{\"id\": \"alice\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/bob/active\",\n\t\t\texpectRoute: \"/users/:id/active\",\n\t\t\texpectParam: map[string]string{\"id\": \"bob\"},\n\t\t},\n\t\t{\n\t\t\twhenURL:     \"/users/create\",\n\t\t\texpectRoute: \"/users/create\",\n\t\t\texpectParam: nil,\n\t\t},\n\t\t//This panic before the fix for Issue #1653\n\t\t{\n\t\t\twhenURL:      \"/users/createNotFound\",\n\t\t\texpectStatus: http.StatusNotFound,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.whenURL, func(t *testing.T) {\n\t\t\tc := e.NewContext(nil, nil).(*context)\n\n\t\t\tr.Find(http.MethodGet, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tif tc.expectStatus != 0 {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\the := err.(*HTTPError)\n\t\t\t\tassert.Equal(t, tc.expectStatus, he.Code)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectRoute, c.Get(\"path\"))\n\t\t\tfor param, expectedValue := range tc.expectParam {\n\t\t\t\tassert.Equal(t, expectedValue, c.Param(param))\n\t\t\t}\n\t\t\tcheckUnusedParamValues(t, c, tc.expectParam)\n\t\t})\n\t}\n}\n\n// Issue #1726\nfunc TestRouterDifferentParamsInPath(t *testing.T) {\n\te := New()\n\tr := e.router\n\tr.Add(http.MethodPut, \"/*\", func(Context) error {\n\t\treturn nil\n\t})\n\tr.Add(http.MethodPut, \"/users/:vid/files/:gid\", func(Context) error {\n\t\treturn nil\n\t})\n\tr.Add(http.MethodGet, \"/users/:uid/files/:fid\", func(Context) error {\n\t\treturn nil\n\t})\n\tc := e.NewContext(nil, nil).(*context)\n\n\tr.Find(http.MethodGet, \"/users/1/files/2\", c)\n\tassert.Equal(t, \"1\", c.Param(\"uid\"))\n\tassert.Equal(t, \"2\", c.Param(\"fid\"))\n\n\tr.Find(http.MethodGet, \"/users/1/shouldBacktrackToFirstAnyRouteAnd405\", c)\n\tassert.Equal(t, \"/*\", c.Path())\n\n\tr.Find(http.MethodPut, \"/users/3/files/4\", c)\n\tassert.Equal(t, \"3\", c.Param(\"vid\"))\n\tassert.Equal(t, \"4\", c.Param(\"gid\"))\n}\n\nfunc TestRouterHandleMethodOptions(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\tr.Add(http.MethodGet, \"/users\", handlerFunc)\n\tr.Add(http.MethodPost, \"/users\", handlerFunc)\n\tr.Add(http.MethodPut, \"/users/:id\", handlerFunc)\n\tr.Add(http.MethodGet, \"/users/:id\", handlerFunc)\n\n\tvar testCases = []struct {\n\t\tname              string\n\t\twhenMethod        string\n\t\twhenURL           string\n\t\texpectAllowHeader string\n\t\texpectStatus      int\n\t}{\n\t\t{\n\t\t\tname:              \"allows GET and POST handlers\",\n\t\t\twhenMethod:        http.MethodOptions,\n\t\t\twhenURL:           \"/users\",\n\t\t\texpectAllowHeader: \"OPTIONS, GET, POST\",\n\t\t\texpectStatus:      http.StatusNoContent,\n\t\t},\n\t\t{\n\t\t\tname:              \"allows GET and PUT handlers\",\n\t\t\twhenMethod:        http.MethodOptions,\n\t\t\twhenURL:           \"/users/1\",\n\t\t\texpectAllowHeader: \"OPTIONS, GET, PUT\",\n\t\t\texpectStatus:      http.StatusNoContent,\n\t\t},\n\t\t{\n\t\t\tname:              \"GET does not have allows header\",\n\t\t\twhenMethod:        http.MethodGet,\n\t\t\twhenURL:           \"/users\",\n\t\t\texpectAllowHeader: \"\",\n\t\t\texpectStatus:      http.StatusOK,\n\t\t},\n\t\t{\n\t\t\tname:              \"path with no handlers does not set Allows header\",\n\t\t\twhenMethod:        http.MethodOptions,\n\t\t\twhenURL:           \"/notFound\",\n\t\t\texpectAllowHeader: \"\",\n\t\t\texpectStatus:      http.StatusNotFound,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treq := httptest.NewRequest(tc.whenMethod, tc.whenURL, nil)\n\t\t\trec := httptest.NewRecorder()\n\t\t\tc := e.NewContext(req, rec).(*context)\n\n\t\t\tr.Find(tc.whenMethod, tc.whenURL, c)\n\t\t\terr := c.handler(c)\n\n\t\t\tif tc.expectStatus >= 400 {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\the := err.(*HTTPError)\n\t\t\t\tassert.Equal(t, tc.expectStatus, he.Code)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, tc.expectStatus, rec.Code)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.expectAllowHeader, c.Response().Header().Get(HeaderAllow))\n\t\t})\n\t}\n}\n\nfunc TestRouter_Routes(t *testing.T) {\n\ttype rr struct {\n\t\tmethod string\n\t\tpath   string\n\t\tname   string\n\t}\n\tvar testCases = []struct {\n\t\tname        string\n\t\tgivenRoutes []rr\n\t\texpect      []rr\n\t}{\n\t\t{\n\t\t\tname: \"ok, multiple\",\n\t\t\tgivenRoutes: []rr{\n\t\t\t\t{method: http.MethodGet, path: \"/static\", name: \"/static\"},\n\t\t\t\t{method: http.MethodGet, path: \"/static/*\", name: \"/static/*\"},\n\t\t\t},\n\t\t\texpect: []rr{\n\t\t\t\t{method: http.MethodGet, path: \"/static\", name: \"/static\"},\n\t\t\t\t{method: http.MethodGet, path: \"/static/*\", name: \"/static/*\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"ok, no routes\",\n\t\t\tgivenRoutes: []rr{},\n\t\t\texpect:      []rr{},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdummyHandler := func(Context) error { return nil }\n\n\t\t\te := New()\n\t\t\troute := e.router\n\n\t\t\tfor _, tmp := range tc.givenRoutes {\n\t\t\t\troute.add(tmp.method, tmp.path, tmp.name, dummyHandler)\n\t\t\t}\n\n\t\t\t// Add does not add route. because of backwards compatibility we can not change this method signature\n\t\t\troute.Add(\"LOCK\", \"/users\", handlerFunc)\n\n\t\t\tresult := route.Routes()\n\t\t\tassert.Len(t, result, len(tc.expect))\n\t\t\tfor _, r := range result {\n\t\t\t\tfor _, tmp := range tc.expect {\n\t\t\t\t\tif tmp.name == r.Name {\n\t\t\t\t\t\tassert.Equal(t, tmp.method, r.Method)\n\t\t\t\t\t\tassert.Equal(t, tmp.path, r.Path)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRouter_addEmptyPathToSlashReverse(t *testing.T) {\n\te := New()\n\tr := e.router\n\tr.add(http.MethodGet, \"\", \"empty\", handlerFunc) // emtpy path is normalized to `/`\n\n\tassert.Equal(t, \"/\", r.Reverse(\"empty\"))\n}\n\nfunc TestRouter_ReverseNotFound(t *testing.T) {\n\te := New()\n\tr := e.router\n\tr.add(http.MethodGet, \"\", \"empty\", handlerFunc)\n\n\tassert.Equal(t, \"\", r.Reverse(\"not-existing\"))\n}\n\nfunc TestRouter_Reverse(t *testing.T) {\n\te := New()\n\tr := e.router\n\tdummyHandler := func(Context) error { return nil }\n\n\tr.add(http.MethodGet, \"/static\", \"/static\", dummyHandler)\n\tr.add(http.MethodGet, \"/static/*\", \"/static/*\", dummyHandler)\n\tr.add(http.MethodGet, \"/params/:foo\", \"/params/:foo\", dummyHandler)\n\tr.add(http.MethodGet, \"/params/:foo/bar/:qux\", \"/params/:foo/bar/:qux\", dummyHandler)\n\tr.add(http.MethodGet, \"/params/:foo/bar/:qux/*\", \"/params/:foo/bar/:qux/*\", dummyHandler)\n\n\tassert.Equal(t, \"/static\", r.Reverse(\"/static\"))\n\tassert.Equal(t, \"/static\", r.Reverse(\"/static\", \"missing param\"))\n\tassert.Equal(t, \"/static/*\", r.Reverse(\"/static/*\"))\n\tassert.Equal(t, \"/static/foo.txt\", r.Reverse(\"/static/*\", \"foo.txt\"))\n\n\tassert.Equal(t, \"/params/:foo\", r.Reverse(\"/params/:foo\"))\n\tassert.Equal(t, \"/params/one\", r.Reverse(\"/params/:foo\", \"one\"))\n\tassert.Equal(t, \"/params/:foo/bar/:qux\", r.Reverse(\"/params/:foo/bar/:qux\"))\n\tassert.Equal(t, \"/params/one/bar/:qux\", r.Reverse(\"/params/:foo/bar/:qux\", \"one\"))\n\tassert.Equal(t, \"/params/one/bar/two\", r.Reverse(\"/params/:foo/bar/:qux\", \"one\", \"two\"))\n\tassert.Equal(t, \"/params/one/bar/two/three\", r.Reverse(\"/params/:foo/bar/:qux/*\", \"one\", \"two\", \"three\"))\n}\n\nfunc TestRouterAllowHeaderForAnyOtherMethodType(t *testing.T) {\n\te := New()\n\tr := e.router\n\n\tr.Add(http.MethodGet, \"/users\", handlerFunc)\n\tr.Add(\"COPY\", \"/users\", handlerFunc)\n\tr.Add(\"LOCK\", \"/users\", handlerFunc)\n\n\treq := httptest.NewRequest(\"TEST\", \"/users\", nil)\n\trec := httptest.NewRecorder()\n\tc := e.NewContext(req, rec).(*context)\n\n\tr.Find(\"TEST\", \"/users\", c)\n\terr := c.handler(c)\n\n\tassert.EqualError(t, err, \"code=405, message=Method Not Allowed\")\n\tassert.ElementsMatch(t, []string{\"COPY\", \"GET\", \"LOCK\", \"OPTIONS\"}, strings.Split(c.Response().Header().Get(HeaderAllow), \", \"))\n}\n\nfunc benchmarkRouterRoutes(b *testing.B, routes []*Route, routesToFind []*Route) {\n\te := New()\n\tr := e.router\n\tb.ReportAllocs()\n\n\t// Add routes\n\tfor _, route := range routes {\n\t\tr.Add(route.Method, route.Path, func(c Context) error {\n\t\t\treturn nil\n\t\t})\n\t}\n\n\t// Routes adding are performed just once, so it doesn't make sense to see that in the benchmark\n\tb.ResetTimer()\n\n\t// Find routes\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, route := range routesToFind {\n\t\t\tc := e.pool.Get().(*context)\n\t\t\tr.Find(route.Method, route.Path, c)\n\t\t\te.pool.Put(c)\n\t\t}\n\t}\n}\n\nfunc BenchmarkRouterStaticRoutes(b *testing.B) {\n\tbenchmarkRouterRoutes(b, staticRoutes, staticRoutes)\n}\n\nfunc BenchmarkRouterStaticRoutesMisses(b *testing.B) {\n\tbenchmarkRouterRoutes(b, staticRoutes, missesAPI)\n}\n\nfunc BenchmarkRouterGitHubAPI(b *testing.B) {\n\tbenchmarkRouterRoutes(b, gitHubAPI, gitHubAPI)\n}\n\nfunc BenchmarkRouterGitHubAPIMisses(b *testing.B) {\n\tbenchmarkRouterRoutes(b, gitHubAPI, missesAPI)\n}\n\nfunc BenchmarkRouterParseAPI(b *testing.B) {\n\tbenchmarkRouterRoutes(b, parseAPI, parseAPI)\n}\n\nfunc BenchmarkRouterParseAPIMisses(b *testing.B) {\n\tbenchmarkRouterRoutes(b, parseAPI, missesAPI)\n}\n\nfunc BenchmarkRouterGooglePlusAPI(b *testing.B) {\n\tbenchmarkRouterRoutes(b, googlePlusAPI, googlePlusAPI)\n}\n\nfunc BenchmarkRouterGooglePlusAPIMisses(b *testing.B) {\n\tbenchmarkRouterRoutes(b, googlePlusAPI, missesAPI)\n}\n\nfunc BenchmarkRouterParamsAndAnyAPI(b *testing.B) {\n\tbenchmarkRouterRoutes(b, paramAndAnyAPI, paramAndAnyAPIToFind)\n}\n"
        }
      ]
    }
  ]
}