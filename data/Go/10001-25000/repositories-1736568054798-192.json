{
  "metadata": {
    "timestamp": 1736568054798,
    "page": 192,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go-martini/martini",
      "stars": 11626,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.845703125,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n\n/.godeps\n/.envrc\n\n# Godeps\nGodeps/_workspace\nGodeps/Readme\n\n### JetBrains template\n# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio and Webstorm\n# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839\n\n.idea/\n\n## File-based project format:\n*.iws\n\n## Plugin-specific files:\n\n# IntelliJ\n/out/\n\n# mpeltonen/sbt-idea plugin\n.idea_modules/\n\n# JIRA plugin\natlassian-ide-plugin.xml\n\n# Crashlytics plugin (for Android Studio and IntelliJ)\ncom_crashlytics_export_strings.xml\ncrashlytics.properties\ncrashlytics-build.properties\nfabric.properties\n"
        },
        {
          "name": "Godeps",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0537109375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Jeremy Saenz\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.5595703125,
          "content": "# Martini  [![wercker status](https://app.wercker.com/status/9b7dbc6e2654b604cd694d191c3d5487/s/master \"wercker status\")](https://app.wercker.com/project/bykey/9b7dbc6e2654b604cd694d191c3d5487)[![GoDoc](https://godoc.org/github.com/go-martini/martini?status.png)](http://godoc.org/github.com/go-martini/martini)\n\n### **NOTE:** The martini framework is no longer maintained.\n\nMartini is a powerful package for quickly writing modular web applications/services in Golang.\n\nLanguage Translations:\n* [繁體中文](translations/README_zh_tw.md)\n* [简体中文](translations/README_zh_cn.md)\n* [Português Brasileiro (pt_BR)](translations/README_pt_br.md)\n* [Español](translations/README_es_ES.md)\n* [한국어 번역](translations/README_ko_kr.md)\n* [Русский](translations/README_ru_RU.md)\n* [日本語](translations/README_ja_JP.md)\n* [French](translations/README_fr_FR.md)\n* [Turkish](translations/README_tr_TR.md)\n* [German](translations/README_de_DE.md)\n* [Polski](translations/README_pl_PL.md)\n\n## Getting Started\n\nAfter installing Go and setting up your [GOPATH](http://golang.org/doc/code.html#GOPATH), create your first `.go` file. We'll call it `server.go`.\n\n~~~ go\npackage main\n\nimport \"github.com/go-martini/martini\"\n\nfunc main() {\n  m := martini.Classic()\n  m.Get(\"/\", func() string {\n    return \"Hello world!\"\n  })\n  m.Run()\n}\n~~~\n\nThen install the Martini package (**go 1.1** or greater is required):\n~~~\ngo get github.com/go-martini/martini\n~~~\n\nThen run your server:\n~~~\ngo run server.go\n~~~\n\nYou will now have a Martini webserver running on `localhost:3000`.\n\n## Getting Help\n\nJoin the [Mailing list](https://groups.google.com/forum/#!forum/martini-go)\n\nWatch the [Demo Video](http://martini.codegangsta.io/#demo)\n\nAsk questions on Stackoverflow using the [martini tag](http://stackoverflow.com/questions/tagged/martini)\n\nGoDoc [documentation](http://godoc.org/github.com/go-martini/martini)\n\n\n## Features\n* Extremely simple to use.\n* Non-intrusive design.\n* Plays nice with other Golang packages.\n* Awesome path matching and routing.\n* Modular design - Easy to add functionality, easy to rip stuff out.\n* Lots of good handlers/middlewares to use.\n* Great 'out of the box' feature set.\n* **Fully compatible with the [http.HandlerFunc](http://godoc.org/net/http#HandlerFunc) interface.**\n* Default document serving (e.g., for serving AngularJS apps in HTML5 mode).\n\n## More Middleware\nFor more middleware and functionality, check out the repositories in the  [martini-contrib](https://github.com/martini-contrib) organization.\n\n## Table of Contents\n* [Classic Martini](#classic-martini)\n  * [Handlers](#handlers)\n  * [Routing](#routing)\n  * [Services](#services)\n  * [Serving Static Files](#serving-static-files)\n* [Middleware Handlers](#middleware-handlers)\n  * [Next()](#next)\n* [Martini Env](#martini-env)\n* [FAQ](#faq)\n\n## Classic Martini\nTo get up and running quickly, [martini.Classic()](http://godoc.org/github.com/go-martini/martini#Classic) provides some reasonable defaults that work well for most web applications:\n~~~ go\n  m := martini.Classic()\n  // ... middleware and routing goes here\n  m.Run()\n~~~\n\nBelow is some of the functionality [martini.Classic()](http://godoc.org/github.com/go-martini/martini#Classic) pulls in automatically:\n  * Request/Response Logging - [martini.Logger](http://godoc.org/github.com/go-martini/martini#Logger)\n  * Panic Recovery - [martini.Recovery](http://godoc.org/github.com/go-martini/martini#Recovery)\n  * Static File serving - [martini.Static](http://godoc.org/github.com/go-martini/martini#Static)\n  * Routing - [martini.Router](http://godoc.org/github.com/go-martini/martini#Router)\n\n### Handlers\nHandlers are the heart and soul of Martini. A handler is basically any kind of callable function:\n~~~ go\nm.Get(\"/\", func() {\n  println(\"hello world\")\n})\n~~~\n\n#### Return Values\nIf a handler returns something, Martini will write the result to the current [http.ResponseWriter](http://godoc.org/net/http#ResponseWriter) as a string:\n~~~ go\nm.Get(\"/\", func() string {\n  return \"hello world\" // HTTP 200 : \"hello world\"\n})\n~~~\n\nYou can also optionally return a status code:\n~~~ go\nm.Get(\"/\", func() (int, string) {\n  return 418, \"i'm a teapot\" // HTTP 418 : \"i'm a teapot\"\n})\n~~~\n\n#### Service Injection\nHandlers are invoked via reflection. Martini makes use of *Dependency Injection* to resolve dependencies in a Handlers argument list. **This makes Martini completely  compatible with golang's `http.HandlerFunc` interface.**\n\nIf you add an argument to your Handler, Martini will search its list of services and attempt to resolve the dependency via type assertion:\n~~~ go\nm.Get(\"/\", func(res http.ResponseWriter, req *http.Request) { // res and req are injected by Martini\n  res.WriteHeader(200) // HTTP 200\n})\n~~~\n\nThe following services are included with [martini.Classic()](http://godoc.org/github.com/go-martini/martini#Classic):\n  * [*log.Logger](http://godoc.org/log#Logger) - Global logger for Martini.\n  * [martini.Context](http://godoc.org/github.com/go-martini/martini#Context) - http request context.\n  * [martini.Params](http://godoc.org/github.com/go-martini/martini#Params) - `map[string]string` of named params found by route matching.\n  * [martini.Routes](http://godoc.org/github.com/go-martini/martini#Routes) - Route helper service.\n  * [martini.Route](http://godoc.org/github.com/go-martini/martini#Route) - Current active route.\n  * [http.ResponseWriter](http://godoc.org/net/http/#ResponseWriter) - http Response writer interface.\n  * [*http.Request](http://godoc.org/net/http/#Request) - http Request.\n\n### Routing\nIn Martini, a route is an HTTP method paired with a URL-matching pattern.\nEach route can take one or more handler methods:\n~~~ go\nm.Get(\"/\", func() {\n  // show something\n})\n\nm.Patch(\"/\", func() {\n  // update something\n})\n\nm.Post(\"/\", func() {\n  // create something\n})\n\nm.Put(\"/\", func() {\n  // replace something\n})\n\nm.Delete(\"/\", func() {\n  // destroy something\n})\n\nm.Options(\"/\", func() {\n  // http options\n})\n\nm.NotFound(func() {\n  // handle 404\n})\n~~~\n\nRoutes are matched in the order they are defined. The first route that\nmatches the request is invoked.\n\nRoute patterns may include named parameters, accessible via the [martini.Params](http://godoc.org/github.com/go-martini/martini#Params) service:\n~~~ go\nm.Get(\"/hello/:name\", func(params martini.Params) string {\n  return \"Hello \" + params[\"name\"]\n})\n~~~\n\nRoutes can be matched with globs:\n~~~ go\nm.Get(\"/hello/**\", func(params martini.Params) string {\n  return \"Hello \" + params[\"_1\"]\n})\n~~~\n\nRegular expressions can be used as well:\n~~~go\nm.Get(\"/hello/(?P<name>[a-zA-Z]+)\", func(params martini.Params) string {\n  return fmt.Sprintf (\"Hello %s\", params[\"name\"])\n})\n~~~\nTake a look at the [Go documentation](http://golang.org/pkg/regexp/syntax/) for more info about regular expressions syntax .\n\nRoute handlers can be stacked on top of each other, which is useful for things like authentication and authorization:\n~~~ go\nm.Get(\"/secret\", authorize, func() {\n  // this will execute as long as authorize doesn't write a response\n})\n~~~\n\nRoute groups can be added too using the Group method.\n~~~ go\nm.Group(\"/books\", func(r martini.Router) {\n    r.Get(\"/:id\", GetBooks)\n    r.Post(\"/new\", NewBook)\n    r.Put(\"/update/:id\", UpdateBook)\n    r.Delete(\"/delete/:id\", DeleteBook)\n})\n~~~\n\nJust like you can pass middlewares to a handler you can pass middlewares to groups.\n~~~ go\nm.Group(\"/books\", func(r martini.Router) {\n    r.Get(\"/:id\", GetBooks)\n    r.Post(\"/new\", NewBook)\n    r.Put(\"/update/:id\", UpdateBook)\n    r.Delete(\"/delete/:id\", DeleteBook)\n}, MyMiddleware1, MyMiddleware2)\n~~~\n\n### Services\nServices are objects that are available to be injected into a Handler's argument list. You can map a service on a *Global* or *Request* level.\n\n#### Global Mapping\nA Martini instance implements the inject.Injector interface, so mapping a service is easy:\n~~~ go\ndb := &MyDatabase{}\nm := martini.Classic()\nm.Map(db) // the service will be available to all handlers as *MyDatabase\n// ...\nm.Run()\n~~~\n\n#### Request-Level Mapping\nMapping on the request level can be done in a handler via [martini.Context](http://godoc.org/github.com/go-martini/martini#Context):\n~~~ go\nfunc MyCustomLoggerHandler(c martini.Context, req *http.Request) {\n  logger := &MyCustomLogger{req}\n  c.Map(logger) // mapped as *MyCustomLogger\n}\n~~~\n\n#### Mapping values to Interfaces\nOne of the most powerful parts about services is the ability to map a service to an interface. For instance, if you wanted to override the [http.ResponseWriter](http://godoc.org/net/http#ResponseWriter) with an object that wrapped it and performed extra operations, you can write the following handler:\n~~~ go\nfunc WrapResponseWriter(res http.ResponseWriter, c martini.Context) {\n  rw := NewSpecialResponseWriter(res)\n  c.MapTo(rw, (*http.ResponseWriter)(nil)) // override ResponseWriter with our wrapper ResponseWriter\n}\n~~~\n\n### Serving Static Files\nA [martini.Classic()](http://godoc.org/github.com/go-martini/martini#Classic) instance automatically serves static files from the \"public\" directory in the root of your server.\nYou can serve from more directories by adding more [martini.Static](http://godoc.org/github.com/go-martini/martini#Static) handlers.\n~~~ go\nm.Use(martini.Static(\"assets\")) // serve from the \"assets\" directory as well\n~~~\n\n#### Serving a Default Document\nYou can specify the URL of a local file to serve when the requested URL is not\nfound. You can also specify an exclusion prefix so that certain URLs are ignored.\nThis is useful for servers that serve both static files and have additional\nhandlers defined (e.g., REST API). When doing so, it's useful to define the\nstatic handler as a part of the NotFound chain.\n\nThe following example serves the `/index.html` file whenever any URL is\nrequested that does not match any local file and does not start with `/api/v`:\n~~~ go\nstatic := martini.Static(\"assets\", martini.StaticOptions{Fallback: \"/index.html\", Exclude: \"/api/v\"})\nm.NotFound(static, http.NotFound)\n~~~\n\n## Middleware Handlers\nMiddleware Handlers sit between the incoming http request and the router. In essence they are no different than any other Handler in Martini. You can add a middleware handler to the stack like so:\n~~~ go\nm.Use(func() {\n  // do some middleware stuff\n})\n~~~\n\nYou can have full control over the middleware stack with the `Handlers` function. This will replace any handlers that have been previously set:\n~~~ go\nm.Handlers(\n  Middleware1,\n  Middleware2,\n  Middleware3,\n)\n~~~\n\nMiddleware Handlers work really well for things like logging, authorization, authentication, sessions, gzipping, error pages and any other operations that must happen before or after an http request:\n~~~ go\n// validate an api key\nm.Use(func(res http.ResponseWriter, req *http.Request) {\n  if req.Header.Get(\"X-API-KEY\") != \"secret123\" {\n    res.WriteHeader(http.StatusUnauthorized)\n  }\n})\n~~~\n\n### Next()\n[Context.Next()](http://godoc.org/github.com/go-martini/martini#Context) is an optional function that Middleware Handlers can call to yield the until after the other Handlers have been executed. This works really well for any operations that must happen after an http request:\n~~~ go\n// log before and after a request\nm.Use(func(c martini.Context, log *log.Logger){\n  log.Println(\"before a request\")\n\n  c.Next()\n\n  log.Println(\"after a request\")\n})\n~~~\n\n## Martini Env\n\nSome Martini handlers make use of the `martini.Env` global variable to provide special functionality for development environments vs production environments. It is recommended that the `MARTINI_ENV=production` environment variable to be set when deploying a Martini server into a production environment.\n\n## FAQ\n\n### Where do I find middleware X?\n\nStart by looking in the [martini-contrib](https://github.com/martini-contrib) projects. If it is not there feel free to contact a martini-contrib team member about adding a new repo to the organization.\n\n* [acceptlang](https://github.com/martini-contrib/acceptlang) - Handler for parsing the `Accept-Language` HTTP header.\n* [accessflags](https://github.com/martini-contrib/accessflags) - Handler to enable Access Control.\n* [auth](https://github.com/martini-contrib/auth) - Handlers for authentication.\n* [binding](https://github.com/martini-contrib/binding) - Handler for mapping/validating a raw request into a structure.\n* [cors](https://github.com/martini-contrib/cors) - Handler that enables CORS support.\n* [csrf](https://github.com/martini-contrib/csrf) - CSRF protection for applications\n* [encoder](https://github.com/martini-contrib/encoder) - Encoder service for rendering data in several formats and content negotiation.\n* [gzip](https://github.com/martini-contrib/gzip) - Handler for adding gzip compress to requests\n* [gorelic](https://github.com/martini-contrib/gorelic) - NewRelic middleware\n* [logstasher](https://github.com/martini-contrib/logstasher) - Middleware that prints logstash-compatible JSON \n* [method](https://github.com/martini-contrib/method) - HTTP method overriding via Header or form fields.\n* [oauth2](https://github.com/martini-contrib/oauth2) - Handler that provides OAuth 2.0 login for Martini apps. Google Sign-in, Facebook Connect and Github login is supported.\n* [permissions2](https://github.com/xyproto/permissions2) - Handler for keeping track of users, login states and permissions.\n* [render](https://github.com/martini-contrib/render) - Handler that provides a service for easily rendering JSON and HTML templates.\n* [secure](https://github.com/martini-contrib/secure) - Implements a few quick security wins.\n* [sessions](https://github.com/martini-contrib/sessions) - Handler that provides a Session service.\n* [sessionauth](https://github.com/martini-contrib/sessionauth) - Handler that provides a simple way to make routes require a login, and to handle user logins in the session\n* [strict](https://github.com/martini-contrib/strict) - Strict Mode \n* [strip](https://github.com/martini-contrib/strip) - URL Prefix stripping.\n* [staticbin](https://github.com/martini-contrib/staticbin) - Handler for serving static files from binary data\n* [throttle](https://github.com/martini-contrib/throttle) - Request rate throttling middleware.\n* [vauth](https://github.com/rafecolton/vauth) - Handlers for vender webhook authentication (currently GitHub and TravisCI)\n* [web](https://github.com/martini-contrib/web) - hoisie web.go's Context\n\n### How do I integrate with existing servers?\n\nA Martini instance implements `http.Handler`, so it can easily be used to serve subtrees\non existing Go servers. For example this is a working Martini app for Google App Engine:\n\n~~~ go\npackage hello\n\nimport (\n  \"net/http\"\n  \"github.com/go-martini/martini\"\n)\n\nfunc init() {\n  m := martini.Classic()\n  m.Get(\"/\", func() string {\n    return \"Hello world!\"\n  })\n  http.Handle(\"/\", m)\n}\n~~~\n\n### How do I change the port/host?\n\nMartini's `Run` function looks for the PORT and HOST environment variables and uses those. Otherwise Martini will default to localhost:3000.\nTo have more flexibility over port and host, use the `martini.RunOnAddr` function instead.\n\n~~~ go\n  m := martini.Classic()\n  // ...\n  m.RunOnAddr(\":8080\")\n~~~\n\n### Live code reload?\n\n[gin](https://github.com/codegangsta/gin) and [fresh](https://github.com/pilu/fresh) both live reload martini apps.\n\n## Contributing\nMartini is meant to be kept tiny and clean. Most contributions should end up in a repository in the [martini-contrib](https://github.com/martini-contrib) organization. If you do have a contribution for the core of Martini feel free to put up a Pull Request.\n\n## License\nMartini is distributed by The MIT License, see LICENSE\n\n## About\n\nInspired by [express](https://github.com/visionmedia/express) and [sinatra](https://github.com/sinatra/sinatra)\n\nMartini is obsessively designed by none other than the [Code Gangsta](http://codegangsta.io/)\n"
        },
        {
          "name": "env.go",
          "type": "blob",
          "size": 0.4521484375,
          "content": "package martini\n\nimport (\n\t\"os\"\n)\n\n// Envs\nconst (\n\tDev  string = \"development\"\n\tProd string = \"production\"\n\tTest string = \"test\"\n)\n\n// Env is the environment that Martini is executing in. The MARTINI_ENV is read on initialization to set this variable.\nvar Env = Dev\nvar Root string\n\nfunc setENV(e string) {\n\tif len(e) > 0 {\n\t\tEnv = e\n\t}\n}\n\nfunc init() {\n\tsetENV(os.Getenv(\"MARTINI_ENV\"))\n\tvar err error\n\tRoot, err = os.Getwd()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"
        },
        {
          "name": "env_test.go",
          "type": "blob",
          "size": 0.39453125,
          "content": "package martini\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_SetENV(t *testing.T) {\n\ttests := []struct {\n\t\tin  string\n\t\tout string\n\t}{\n\t\t{\"\", \"development\"},\n\t\t{\"not_development\", \"not_development\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tsetENV(test.in)\n\t\tif Env != test.out {\n\t\t\texpect(t, Env, test.out)\n\t\t}\n\t}\n}\n\nfunc Test_Root(t *testing.T) {\n\tif len(Root) == 0 {\n\t\tt.Errorf(\"Expected root path will be set\")\n\t}\n}\n"
        },
        {
          "name": "go_version.go",
          "type": "blob",
          "size": 0.11328125,
          "content": "// +build !go1.1\n\npackage martini\n\nfunc MartiniDoesNotSupportGo1Point0() {\n\t\"Martini requires Go 1.1 or greater.\"\n}\n"
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 0.6552734375,
          "content": "package martini\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// Logger returns a middleware handler that logs the request as it goes in and the response as it goes out.\nfunc Logger() Handler {\n\treturn func(res http.ResponseWriter, req *http.Request, c Context, log *log.Logger) {\n\t\tstart := time.Now()\n\n\t\taddr := req.Header.Get(\"X-Real-IP\")\n\t\tif addr == \"\" {\n\t\t\taddr = req.Header.Get(\"X-Forwarded-For\")\n\t\t\tif addr == \"\" {\n\t\t\t\taddr = req.RemoteAddr\n\t\t\t}\n\t\t}\n\n\t\tlog.Printf(\"Started %s %s for %s\", req.Method, req.URL.Path, addr)\n\n\t\trw := res.(ResponseWriter)\n\t\tc.Next()\n\n\t\tlog.Printf(\"Completed %v %s in %v\\n\", rw.Status(), http.StatusText(rw.Status()), time.Since(start))\n\t}\n}\n"
        },
        {
          "name": "logger_test.go",
          "type": "blob",
          "size": 0.5791015625,
          "content": "package martini\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nfunc Test_Logger(t *testing.T) {\n\tbuff := bytes.NewBufferString(\"\")\n\trecorder := httptest.NewRecorder()\n\n\tm := New()\n\t// replace log for testing\n\tm.Map(log.New(buff, \"[martini] \", 0))\n\tm.Use(Logger())\n\tm.Use(func(res http.ResponseWriter) {\n\t\tres.WriteHeader(http.StatusNotFound)\n\t})\n\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/foobar\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tm.ServeHTTP(recorder, req)\n\texpect(t, recorder.Code, http.StatusNotFound)\n\trefute(t, len(buff.String()), 0)\n}\n"
        },
        {
          "name": "martini.go",
          "type": "blob",
          "size": 5.1611328125,
          "content": "// Package martini is a powerful package for quickly writing modular web applications/services in Golang.\n//\n// For a full guide visit http://github.com/go-martini/martini\n//\n//  package main\n//\n//  import \"github.com/go-martini/martini\"\n//\n//  func main() {\n//    m := martini.Classic()\n//\n//    m.Get(\"/\", func() string {\n//      return \"Hello world!\"\n//    })\n//\n//    m.Run()\n//  }\npackage martini\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"reflect\"\n\n\t\"github.com/codegangsta/inject\"\n)\n\n// Martini represents the top level web application. inject.Injector methods can be invoked to map services on a global level.\ntype Martini struct {\n\tinject.Injector\n\thandlers []Handler\n\taction   Handler\n\tlogger   *log.Logger\n}\n\n// New creates a bare bones Martini instance. Use this method if you want to have full control over the middleware that is used.\nfunc New() *Martini {\n\tm := &Martini{Injector: inject.New(), action: func() {}, logger: log.New(os.Stdout, \"[martini] \", 0)}\n\tm.Map(m.logger)\n\tm.Map(defaultReturnHandler())\n\treturn m\n}\n\n// Handlers sets the entire middleware stack with the given Handlers. This will clear any current middleware handlers.\n// Will panic if any of the handlers is not a callable function\nfunc (m *Martini) Handlers(handlers ...Handler) {\n\tm.handlers = make([]Handler, 0)\n\tfor _, handler := range handlers {\n\t\tm.Use(handler)\n\t}\n}\n\n// Action sets the handler that will be called after all the middleware has been invoked. This is set to martini.Router in a martini.Classic().\nfunc (m *Martini) Action(handler Handler) {\n\tvalidateHandler(handler)\n\tm.action = handler\n}\n\n// Logger sets the logger\nfunc (m *Martini) Logger(logger *log.Logger) {\n\tm.logger = logger\n\tm.Map(m.logger)\n}\n\n// Use adds a middleware Handler to the stack. Will panic if the handler is not a callable func. Middleware Handlers are invoked in the order that they are added.\nfunc (m *Martini) Use(handler Handler) {\n\tvalidateHandler(handler)\n\n\tm.handlers = append(m.handlers, handler)\n}\n\n// ServeHTTP is the HTTP Entry point for a Martini instance. Useful if you want to control your own HTTP server.\nfunc (m *Martini) ServeHTTP(res http.ResponseWriter, req *http.Request) {\n\tm.createContext(res, req).run()\n}\n\n// Run the http server on a given host and port.\nfunc (m *Martini) RunOnAddr(addr string) {\n\t// TODO: Should probably be implemented using a new instance of http.Server in place of\n\t// calling http.ListenAndServer directly, so that it could be stored in the martini struct for later use.\n\t// This would also allow to improve testing when a custom host and port are passed.\n\n\tlogger := m.Injector.Get(reflect.TypeOf(m.logger)).Interface().(*log.Logger)\n\tlogger.Printf(\"listening on %s (%s)\\n\", addr, Env)\n\tlogger.Fatalln(http.ListenAndServe(addr, m))\n}\n\n// Run the http server. Listening on os.GetEnv(\"PORT\") or 3000 by default.\nfunc (m *Martini) Run() {\n\tport := os.Getenv(\"PORT\")\n\tif len(port) == 0 {\n\t\tport = \"3000\"\n\t}\n\n\thost := os.Getenv(\"HOST\")\n\n\tm.RunOnAddr(host + \":\" + port)\n}\n\nfunc (m *Martini) createContext(res http.ResponseWriter, req *http.Request) *context {\n\tc := &context{inject.New(), m.handlers, m.action, NewResponseWriter(res), 0}\n\tc.SetParent(m)\n\tc.MapTo(c, (*Context)(nil))\n\tc.MapTo(c.rw, (*http.ResponseWriter)(nil))\n\tc.Map(req)\n\treturn c\n}\n\n// ClassicMartini represents a Martini with some reasonable defaults. Embeds the router functions for convenience.\ntype ClassicMartini struct {\n\t*Martini\n\tRouter\n}\n\n// Classic creates a classic Martini with some basic default middleware - martini.Logger, martini.Recovery and martini.Static.\n// Classic also maps martini.Routes as a service.\nfunc Classic() *ClassicMartini {\n\tr := NewRouter()\n\tm := New()\n\tm.Use(Logger())\n\tm.Use(Recovery())\n\tm.Use(Static(\"public\"))\n\tm.MapTo(r, (*Routes)(nil))\n\tm.Action(r.Handle)\n\treturn &ClassicMartini{m, r}\n}\n\n// Handler can be any callable function. Martini attempts to inject services into the handler's argument list.\n// Martini will panic if an argument could not be fullfilled via dependency injection.\ntype Handler interface{}\n\nfunc validateHandler(handler Handler) {\n\tif reflect.TypeOf(handler).Kind() != reflect.Func {\n\t\tpanic(\"martini handler must be a callable func\")\n\t}\n}\n\n// Context represents a request context. Services can be mapped on the request level from this interface.\ntype Context interface {\n\tinject.Injector\n\t// Next is an optional function that Middleware Handlers can call to yield the until after\n\t// the other Handlers have been executed. This works really well for any operations that must\n\t// happen after an http request\n\tNext()\n\t// Written returns whether or not the response for this context has been written.\n\tWritten() bool\n}\n\ntype context struct {\n\tinject.Injector\n\thandlers []Handler\n\taction   Handler\n\trw       ResponseWriter\n\tindex    int\n}\n\nfunc (c *context) handler() Handler {\n\tif c.index < len(c.handlers) {\n\t\treturn c.handlers[c.index]\n\t}\n\tif c.index == len(c.handlers) {\n\t\treturn c.action\n\t}\n\tpanic(\"invalid index for context handler\")\n}\n\nfunc (c *context) Next() {\n\tc.index += 1\n\tc.run()\n}\n\nfunc (c *context) Written() bool {\n\treturn c.rw.Written()\n}\n\nfunc (c *context) run() {\n\tfor c.index <= len(c.handlers) {\n\t\t_, err := c.Invoke(c.handler())\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tc.index += 1\n\n\t\tif c.Written() {\n\t\t\treturn\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "martini_test.go",
          "type": "blob",
          "size": 2.888671875,
          "content": "package martini\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"testing\"\n)\n\n/* Test Helpers */\nfunc expect(t *testing.T, a interface{}, b interface{}) {\n\tif a != b {\n\t\tt.Errorf(\"Expected %v (type %v) - Got %v (type %v)\", b, reflect.TypeOf(b), a, reflect.TypeOf(a))\n\t}\n}\n\nfunc refute(t *testing.T, a interface{}, b interface{}) {\n\tif a == b {\n\t\tt.Errorf(\"Did not expect %v (type %v) - Got %v (type %v)\", b, reflect.TypeOf(b), a, reflect.TypeOf(a))\n\t}\n}\n\nfunc Test_New(t *testing.T) {\n\tm := New()\n\tif m == nil {\n\t\tt.Error(\"martini.New() cannot return nil\")\n\t}\n}\n\nfunc Test_Martini_RunOnAddr(t *testing.T) {\n\t// just test that Run doesn't bomb\n\tgo New().RunOnAddr(\"127.0.0.1:8080\")\n}\n\nfunc Test_Martini_Run(t *testing.T) {\n\tgo New().Run()\n}\n\nfunc Test_Martini_ServeHTTP(t *testing.T) {\n\tresult := \"\"\n\tresponse := httptest.NewRecorder()\n\n\tm := New()\n\tm.Use(func(c Context) {\n\t\tresult += \"foo\"\n\t\tc.Next()\n\t\tresult += \"ban\"\n\t})\n\tm.Use(func(c Context) {\n\t\tresult += \"bar\"\n\t\tc.Next()\n\t\tresult += \"baz\"\n\t})\n\tm.Action(func(res http.ResponseWriter, req *http.Request) {\n\t\tresult += \"bat\"\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t})\n\n\tm.ServeHTTP(response, (*http.Request)(nil))\n\n\texpect(t, result, \"foobarbatbazban\")\n\texpect(t, response.Code, http.StatusBadRequest)\n}\n\nfunc Test_Martini_Handlers(t *testing.T) {\n\tresult := \"\"\n\tresponse := httptest.NewRecorder()\n\n\tbatman := func(c Context) {\n\t\tresult += \"batman!\"\n\t}\n\n\tm := New()\n\tm.Use(func(c Context) {\n\t\tresult += \"foo\"\n\t\tc.Next()\n\t\tresult += \"ban\"\n\t})\n\tm.Handlers(\n\t\tbatman,\n\t\tbatman,\n\t\tbatman,\n\t)\n\tm.Action(func(res http.ResponseWriter, req *http.Request) {\n\t\tresult += \"bat\"\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t})\n\n\tm.ServeHTTP(response, (*http.Request)(nil))\n\n\texpect(t, result, \"batman!batman!batman!bat\")\n\texpect(t, response.Code, http.StatusBadRequest)\n}\n\nfunc Test_Martini_EarlyWrite(t *testing.T) {\n\tresult := \"\"\n\tresponse := httptest.NewRecorder()\n\n\tm := New()\n\tm.Use(func(res http.ResponseWriter) {\n\t\tresult += \"foobar\"\n\t\tres.Write([]byte(\"Hello world\"))\n\t})\n\tm.Use(func() {\n\t\tresult += \"bat\"\n\t})\n\tm.Action(func(res http.ResponseWriter) {\n\t\tresult += \"baz\"\n\t\tres.WriteHeader(http.StatusBadRequest)\n\t})\n\n\tm.ServeHTTP(response, (*http.Request)(nil))\n\n\texpect(t, result, \"foobar\")\n\texpect(t, response.Code, http.StatusOK)\n}\n\nfunc Test_Martini_Written(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\n\tm := New()\n\tm.Handlers(func(res http.ResponseWriter) {\n\t\tres.WriteHeader(http.StatusOK)\n\t})\n\n\tctx := m.createContext(response, (*http.Request)(nil))\n\texpect(t, ctx.Written(), false)\n\n\tctx.run()\n\texpect(t, ctx.Written(), true)\n}\n\nfunc Test_Martini_Basic_NoRace(t *testing.T) {\n\tm := New()\n\thandlers := []Handler{func() {}, func() {}}\n\t// Ensure append will not realloc to trigger the race condition\n\tm.handlers = handlers[:1]\n\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\tfor i := 0; i < 2; i++ {\n\t\tgo func() {\n\t\t\tresponse := httptest.NewRecorder()\n\t\t\tm.ServeHTTP(response, req)\n\t\t}()\n\t}\n}\n"
        },
        {
          "name": "recovery.go",
          "type": "blob",
          "size": 3.4375,
          "content": "package martini\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"runtime\"\n\n\t\"github.com/codegangsta/inject\"\n)\n\nconst (\n\tpanicHtml = `<html>\n<head><title>PANIC: %s</title>\n<style type=\"text/css\">\nhtml, body {\n\tfont-family: \"Roboto\", sans-serif;\n\tcolor: #333333;\n\tbackground-color: #ea5343;\n\tmargin: 0px;\n}\nh1 {\n\tcolor: #d04526;\n\tbackground-color: #ffffff;\n\tpadding: 20px;\n\tborder-bottom: 1px dashed #2b3848;\n}\npre {\n\tmargin: 20px;\n\tpadding: 20px;\n\tborder: 2px solid #2b3848;\n\tbackground-color: #ffffff;\n}\n</style>\n</head><body>\n<h1>PANIC</h1>\n<pre style=\"font-weight: bold;\">%s</pre>\n<pre>%s</pre>\n</body>\n</html>`\n)\n\nvar (\n\tdunno     = []byte(\"???\")\n\tcenterDot = []byte(\"·\")\n\tdot       = []byte(\".\")\n\tslash     = []byte(\"/\")\n)\n\n// stack returns a nicely formated stack frame, skipping skip frames\nfunc stack(skip int) []byte {\n\tbuf := new(bytes.Buffer) // the returned data\n\t// As we loop, we open files and read them. These variables record the currently\n\t// loaded file.\n\tvar lines [][]byte\n\tvar lastFile string\n\tfor i := skip; ; i++ { // Skip the expected number of frames\n\t\tpc, file, line, ok := runtime.Caller(i)\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\t// Print this much at least.  If we can't find the source, it won't show.\n\t\tfmt.Fprintf(buf, \"%s:%d (0x%x)\\n\", file, line, pc)\n\t\tif file != lastFile {\n\t\t\tdata, err := ioutil.ReadFile(file)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlines = bytes.Split(data, []byte{'\\n'})\n\t\t\tlastFile = file\n\t\t}\n\t\tfmt.Fprintf(buf, \"\\t%s: %s\\n\", function(pc), source(lines, line))\n\t}\n\treturn buf.Bytes()\n}\n\n// source returns a space-trimmed slice of the n'th line.\nfunc source(lines [][]byte, n int) []byte {\n\tn-- // in stack trace, lines are 1-indexed but our array is 0-indexed\n\tif n < 0 || n >= len(lines) {\n\t\treturn dunno\n\t}\n\treturn bytes.TrimSpace(lines[n])\n}\n\n// function returns, if possible, the name of the function containing the PC.\nfunc function(pc uintptr) []byte {\n\tfn := runtime.FuncForPC(pc)\n\tif fn == nil {\n\t\treturn dunno\n\t}\n\tname := []byte(fn.Name())\n\t// The name includes the path name to the package, which is unnecessary\n\t// since the file name is already included.  Plus, it has center dots.\n\t// That is, we see\n\t//\truntime/debug.*T·ptrmethod\n\t// and want\n\t//\t*T.ptrmethod\n\t// Also the package path might contains dot (e.g. code.google.com/...),\n\t// so first eliminate the path prefix\n\tif lastslash := bytes.LastIndex(name, slash); lastslash >= 0 {\n\t\tname = name[lastslash+1:]\n\t}\n\tif period := bytes.Index(name, dot); period >= 0 {\n\t\tname = name[period+1:]\n\t}\n\tname = bytes.Replace(name, centerDot, dot, -1)\n\treturn name\n}\n\n// Recovery returns a middleware that recovers from any panics and writes a 500 if there was one.\n// While Martini is in development mode, Recovery will also output the panic as HTML.\nfunc Recovery() Handler {\n\treturn func(c Context, log *log.Logger) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tstack := stack(3)\n\t\t\t\tlog.Printf(\"PANIC: %s\\n%s\", err, stack)\n\n\t\t\t\t// Lookup the current responsewriter\n\t\t\t\tval := c.Get(inject.InterfaceOf((*http.ResponseWriter)(nil)))\n\t\t\t\tres := val.Interface().(http.ResponseWriter)\n\n\t\t\t\t// respond with panic message while in development mode\n\t\t\t\tvar body []byte\n\t\t\t\tif Env == Dev {\n\t\t\t\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t\t\t\t\tbody = []byte(fmt.Sprintf(panicHtml, err, err, stack))\n\t\t\t\t} else {\n\t\t\t\t\tbody = []byte(\"500 Internal Server Error\")\n\t\t\t\t}\n\n\t\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\t\tif nil != body {\n\t\t\t\t\tres.Write(body)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tc.Next()\n\t}\n}\n"
        },
        {
          "name": "recovery_test.go",
          "type": "blob",
          "size": 1.2041015625,
          "content": "package martini\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\nfunc Test_Recovery(t *testing.T) {\n\tbuff := bytes.NewBufferString(\"\")\n\trecorder := httptest.NewRecorder()\n\n\tsetENV(Dev)\n\tm := New()\n\t// replace log for testing\n\tm.Map(log.New(buff, \"[martini] \", 0))\n\tm.Use(func(res http.ResponseWriter, req *http.Request) {\n\t\tres.Header().Set(\"Content-Type\", \"unpredictable\")\n\t})\n\tm.Use(Recovery())\n\tm.Use(func(res http.ResponseWriter, req *http.Request) {\n\t\tpanic(\"here is a panic!\")\n\t})\n\tm.ServeHTTP(recorder, (*http.Request)(nil))\n\texpect(t, recorder.Code, http.StatusInternalServerError)\n\texpect(t, recorder.HeaderMap.Get(\"Content-Type\"), \"text/html\")\n\trefute(t, recorder.Body.Len(), 0)\n\trefute(t, len(buff.String()), 0)\n}\n\nfunc Test_Recovery_ResponseWriter(t *testing.T) {\n\trecorder := httptest.NewRecorder()\n\trecorder2 := httptest.NewRecorder()\n\n\tsetENV(Dev)\n\tm := New()\n\tm.Use(Recovery())\n\tm.Use(func(c Context) {\n\t\tc.MapTo(recorder2, (*http.ResponseWriter)(nil))\n\t\tpanic(\"here is a panic!\")\n\t})\n\tm.ServeHTTP(recorder, (*http.Request)(nil))\n\n\texpect(t, recorder2.Code, http.StatusInternalServerError)\n\texpect(t, recorder2.HeaderMap.Get(\"Content-Type\"), \"text/html\")\n\trefute(t, recorder2.Body.Len(), 0)\n}\n"
        },
        {
          "name": "response_writer.go",
          "type": "blob",
          "size": 2.712890625,
          "content": "package martini\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n)\n\n// ResponseWriter is a wrapper around http.ResponseWriter that provides extra information about\n// the response. It is recommended that middleware handlers use this construct to wrap a responsewriter\n// if the functionality calls for it.\ntype ResponseWriter interface {\n\thttp.ResponseWriter\n\thttp.Flusher\n\thttp.Hijacker\n\t// Status returns the status code of the response or 0 if the response has not been written.\n\tStatus() int\n\t// Written returns whether or not the ResponseWriter has been written.\n\tWritten() bool\n\t// Size returns the size of the response body.\n\tSize() int\n\t// Before allows for a function to be called before the ResponseWriter has been written to. This is\n\t// useful for setting headers or any other operations that must happen before a response has been written.\n\tBefore(BeforeFunc)\n}\n\n// BeforeFunc is a function that is called before the ResponseWriter has been written to.\ntype BeforeFunc func(ResponseWriter)\n\n// NewResponseWriter creates a ResponseWriter that wraps an http.ResponseWriter\nfunc NewResponseWriter(rw http.ResponseWriter) ResponseWriter {\n\tnewRw := responseWriter{rw, 0, 0, nil}\n\tif cn, ok := rw.(http.CloseNotifier); ok {\n\t\treturn &closeNotifyResponseWriter{newRw, cn}\n\t}\n\treturn &newRw\n}\n\ntype responseWriter struct {\n\thttp.ResponseWriter\n\tstatus      int\n\tsize        int\n\tbeforeFuncs []BeforeFunc\n}\n\nfunc (rw *responseWriter) WriteHeader(s int) {\n\trw.callBefore()\n\trw.ResponseWriter.WriteHeader(s)\n\trw.status = s\n}\n\nfunc (rw *responseWriter) Write(b []byte) (int, error) {\n\tif !rw.Written() {\n\t\t// The status will be StatusOK if WriteHeader has not been called yet\n\t\trw.WriteHeader(http.StatusOK)\n\t}\n\tsize, err := rw.ResponseWriter.Write(b)\n\trw.size += size\n\treturn size, err\n}\n\nfunc (rw *responseWriter) Status() int {\n\treturn rw.status\n}\n\nfunc (rw *responseWriter) Size() int {\n\treturn rw.size\n}\n\nfunc (rw *responseWriter) Written() bool {\n\treturn rw.status != 0\n}\n\nfunc (rw *responseWriter) Before(before BeforeFunc) {\n\trw.beforeFuncs = append(rw.beforeFuncs, before)\n}\n\nfunc (rw *responseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\thijacker, ok := rw.ResponseWriter.(http.Hijacker)\n\tif !ok {\n\t\treturn nil, nil, fmt.Errorf(\"the ResponseWriter doesn't support the Hijacker interface\")\n\t}\n\treturn hijacker.Hijack()\n}\n\nfunc (rw *responseWriter) callBefore() {\n\tfor i := len(rw.beforeFuncs) - 1; i >= 0; i-- {\n\t\trw.beforeFuncs[i](rw)\n\t}\n}\n\nfunc (rw *responseWriter) Flush() {\n\tflusher, ok := rw.ResponseWriter.(http.Flusher)\n\tif ok {\n\t\tflusher.Flush()\n\t}\n}\n\ntype closeNotifyResponseWriter struct {\n\tresponseWriter\n\tcloseNotifier http.CloseNotifier\n}\n\nfunc (rw *closeNotifyResponseWriter) CloseNotify() <-chan bool {\n\treturn rw.closeNotifier.CloseNotify()\n}\n"
        },
        {
          "name": "response_writer_test.go",
          "type": "blob",
          "size": 4.1455078125,
          "content": "package martini\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype closeNotifyingRecorder struct {\n\t*httptest.ResponseRecorder\n\tclosed chan bool\n}\n\nfunc newCloseNotifyingRecorder() *closeNotifyingRecorder {\n\treturn &closeNotifyingRecorder{\n\t\thttptest.NewRecorder(),\n\t\tmake(chan bool, 1),\n\t}\n}\n\nfunc (c *closeNotifyingRecorder) close() {\n\tc.closed <- true\n}\n\nfunc (c *closeNotifyingRecorder) CloseNotify() <-chan bool {\n\treturn c.closed\n}\n\ntype hijackableResponse struct {\n\tHijacked bool\n}\n\nfunc newHijackableResponse() *hijackableResponse {\n\treturn &hijackableResponse{}\n}\n\nfunc (h *hijackableResponse) Header() http.Header           { return nil }\nfunc (h *hijackableResponse) Write(buf []byte) (int, error) { return 0, nil }\nfunc (h *hijackableResponse) WriteHeader(code int)          {}\nfunc (h *hijackableResponse) Flush()                        {}\nfunc (h *hijackableResponse) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\th.Hijacked = true\n\treturn nil, nil, nil\n}\n\nfunc Test_ResponseWriter_WritingString(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\trw.Write([]byte(\"Hello world\"))\n\n\texpect(t, rec.Code, rw.Status())\n\texpect(t, rec.Body.String(), \"Hello world\")\n\texpect(t, rw.Status(), http.StatusOK)\n\texpect(t, rw.Size(), 11)\n\texpect(t, rw.Written(), true)\n}\n\nfunc Test_ResponseWriter_WritingStrings(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\trw.Write([]byte(\"Hello world\"))\n\trw.Write([]byte(\"foo bar bat baz\"))\n\n\texpect(t, rec.Code, rw.Status())\n\texpect(t, rec.Body.String(), \"Hello worldfoo bar bat baz\")\n\texpect(t, rw.Status(), http.StatusOK)\n\texpect(t, rw.Size(), 26)\n}\n\nfunc Test_ResponseWriter_WritingHeader(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\trw.WriteHeader(http.StatusNotFound)\n\n\texpect(t, rec.Code, rw.Status())\n\texpect(t, rec.Body.String(), \"\")\n\texpect(t, rw.Status(), http.StatusNotFound)\n\texpect(t, rw.Size(), 0)\n}\n\nfunc Test_ResponseWriter_Before(t *testing.T) {\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\tresult := \"\"\n\n\trw.Before(func(ResponseWriter) {\n\t\tresult += \"foo\"\n\t})\n\trw.Before(func(ResponseWriter) {\n\t\tresult += \"bar\"\n\t})\n\n\trw.WriteHeader(http.StatusNotFound)\n\n\texpect(t, rec.Code, rw.Status())\n\texpect(t, rec.Body.String(), \"\")\n\texpect(t, rw.Status(), http.StatusNotFound)\n\texpect(t, rw.Size(), 0)\n\texpect(t, result, \"barfoo\")\n}\n\nfunc Test_ResponseWriter_Hijack(t *testing.T) {\n\thijackable := newHijackableResponse()\n\trw := NewResponseWriter(hijackable)\n\thijacker, ok := rw.(http.Hijacker)\n\texpect(t, ok, true)\n\t_, _, err := hijacker.Hijack()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\texpect(t, hijackable.Hijacked, true)\n}\n\nfunc Test_ResponseWrite_Hijack_NotOK(t *testing.T) {\n\thijackable := new(http.ResponseWriter)\n\trw := NewResponseWriter(*hijackable)\n\thijacker, ok := rw.(http.Hijacker)\n\texpect(t, ok, true)\n\t_, _, err := hijacker.Hijack()\n\n\trefute(t, err, nil)\n}\n\nfunc Test_ResponseWriter_CloseNotify(t *testing.T) {\n\trec := newCloseNotifyingRecorder()\n\trw := NewResponseWriter(rec)\n\tclosed := false\n\tnotifier := rw.(http.CloseNotifier).CloseNotify()\n\trec.close()\n\tselect {\n\tcase <-notifier:\n\t\tclosed = true\n\tcase <-time.After(time.Second):\n\t}\n\texpect(t, closed, true)\n}\n\nfunc Test_ResponseWriter_Flusher(t *testing.T) {\n\n\trec := httptest.NewRecorder()\n\trw := NewResponseWriter(rec)\n\n\t_, ok := rw.(http.Flusher)\n\texpect(t, ok, true)\n}\n\nfunc Test_ResponseWriter_FlusherHandler(t *testing.T) {\n\n\t// New martini instance\n\tm := Classic()\n\n\tm.Get(\"/events\", func(w http.ResponseWriter, r *http.Request) {\n\n\t\tf, ok := w.(http.Flusher)\n\t\texpect(t, ok, true)\n\n\t\tw.Header().Set(\"Content-Type\", \"text/event-stream\")\n\t\tw.Header().Set(\"Cache-Control\", \"no-cache\")\n\t\tw.Header().Set(\"Connection\", \"keep-alive\")\n\n\t\tfor i := 0; i < 2; i++ {\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\tio.WriteString(w, \"data: Hello\\n\\n\")\n\t\t\tf.Flush()\n\t\t}\n\n\t})\n\n\trecorder := httptest.NewRecorder()\n\tr, _ := http.NewRequest(\"GET\", \"/events\", nil)\n\tm.ServeHTTP(recorder, r)\n\n\tif recorder.Code != 200 {\n\t\tt.Error(\"Response not 200\")\n\t}\n\n\tif recorder.Body.String() != \"data: Hello\\n\\ndata: Hello\\n\\n\" {\n\t\tt.Error(\"Didn't receive correct body, got:\", recorder.Body.String())\n\t}\n\n}\n"
        },
        {
          "name": "return_handler.go",
          "type": "blob",
          "size": 1.1953125,
          "content": "package martini\n\nimport (\n\t\"github.com/codegangsta/inject\"\n\t\"net/http\"\n\t\"reflect\"\n)\n\n// ReturnHandler is a service that Martini provides that is called\n// when a route handler returns something. The ReturnHandler is\n// responsible for writing to the ResponseWriter based on the values\n// that are passed into this function.\ntype ReturnHandler func(Context, []reflect.Value)\n\nfunc defaultReturnHandler() ReturnHandler {\n\treturn func(ctx Context, vals []reflect.Value) {\n\t\trv := ctx.Get(inject.InterfaceOf((*http.ResponseWriter)(nil)))\n\t\tres := rv.Interface().(http.ResponseWriter)\n\t\tvar responseVal reflect.Value\n\t\tif len(vals) > 1 && vals[0].Kind() == reflect.Int {\n\t\t\tres.WriteHeader(int(vals[0].Int()))\n\t\t\tresponseVal = vals[1]\n\t\t} else if len(vals) > 0 {\n\t\t\tresponseVal = vals[0]\n\t\t}\n\t\tif canDeref(responseVal) {\n\t\t\tresponseVal = responseVal.Elem()\n\t\t}\n\t\tif isByteSlice(responseVal) {\n\t\t\tres.Write(responseVal.Bytes())\n\t\t} else {\n\t\t\tres.Write([]byte(responseVal.String()))\n\t\t}\n\t}\n}\n\nfunc isByteSlice(val reflect.Value) bool {\n\treturn val.Kind() == reflect.Slice && val.Type().Elem().Kind() == reflect.Uint8\n}\n\nfunc canDeref(val reflect.Value) bool {\n\treturn val.Kind() == reflect.Interface || val.Kind() == reflect.Ptr\n}\n"
        },
        {
          "name": "router.go",
          "type": "blob",
          "size": 10.1083984375,
          "content": "package martini\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"sync\"\n)\n\n// Params is a map of name/value pairs for named routes. An instance of martini.Params is available to be injected into any route handler.\ntype Params map[string]string\n\n// Router is Martini's de-facto routing interface. Supports HTTP verbs, stacked handlers, and dependency injection.\ntype Router interface {\n\tRoutes\n\n\t// Group adds a group where related routes can be added.\n\tGroup(string, func(Router), ...Handler)\n\t// Get adds a route for a HTTP GET request to the specified matching pattern.\n\tGet(string, ...Handler) Route\n\t// Patch adds a route for a HTTP PATCH request to the specified matching pattern.\n\tPatch(string, ...Handler) Route\n\t// Post adds a route for a HTTP POST request to the specified matching pattern.\n\tPost(string, ...Handler) Route\n\t// Put adds a route for a HTTP PUT request to the specified matching pattern.\n\tPut(string, ...Handler) Route\n\t// Delete adds a route for a HTTP DELETE request to the specified matching pattern.\n\tDelete(string, ...Handler) Route\n\t// Options adds a route for a HTTP OPTIONS request to the specified matching pattern.\n\tOptions(string, ...Handler) Route\n\t// Head adds a route for a HTTP HEAD request to the specified matching pattern.\n\tHead(string, ...Handler) Route\n\t// Any adds a route for any HTTP method request to the specified matching pattern.\n\tAny(string, ...Handler) Route\n\t// AddRoute adds a route for a given HTTP method request to the specified matching pattern.\n\tAddRoute(string, string, ...Handler) Route\n\n\t// NotFound sets the handlers that are called when a no route matches a request. Throws a basic 404 by default.\n\tNotFound(...Handler)\n\n\t// Handle is the entry point for routing. This is used as a martini.Handler\n\tHandle(http.ResponseWriter, *http.Request, Context)\n}\n\ntype router struct {\n\troutes     []*route\n\tnotFounds  []Handler\n\tgroups     []group\n\troutesLock sync.RWMutex\n}\n\ntype group struct {\n\tpattern  string\n\thandlers []Handler\n}\n\n// NewRouter creates a new Router instance.\n// If you aren't using ClassicMartini, then you can add Routes as a\n// service with:\n//\n//\tm := martini.New()\n//\tr := martini.NewRouter()\n//\tm.MapTo(r, (*martini.Routes)(nil))\n//\n// If you are using ClassicMartini, then this is done for you.\nfunc NewRouter() Router {\n\treturn &router{notFounds: []Handler{http.NotFound}, groups: make([]group, 0)}\n}\n\nfunc (r *router) Group(pattern string, fn func(Router), h ...Handler) {\n\tr.groups = append(r.groups, group{pattern, h})\n\tfn(r)\n\tr.groups = r.groups[:len(r.groups)-1]\n}\n\nfunc (r *router) Get(pattern string, h ...Handler) Route {\n\treturn r.addRoute(\"GET\", pattern, h)\n}\n\nfunc (r *router) Patch(pattern string, h ...Handler) Route {\n\treturn r.addRoute(\"PATCH\", pattern, h)\n}\n\nfunc (r *router) Post(pattern string, h ...Handler) Route {\n\treturn r.addRoute(\"POST\", pattern, h)\n}\n\nfunc (r *router) Put(pattern string, h ...Handler) Route {\n\treturn r.addRoute(\"PUT\", pattern, h)\n}\n\nfunc (r *router) Delete(pattern string, h ...Handler) Route {\n\treturn r.addRoute(\"DELETE\", pattern, h)\n}\n\nfunc (r *router) Options(pattern string, h ...Handler) Route {\n\treturn r.addRoute(\"OPTIONS\", pattern, h)\n}\n\nfunc (r *router) Head(pattern string, h ...Handler) Route {\n\treturn r.addRoute(\"HEAD\", pattern, h)\n}\n\nfunc (r *router) Any(pattern string, h ...Handler) Route {\n\treturn r.addRoute(\"*\", pattern, h)\n}\n\nfunc (r *router) AddRoute(method, pattern string, h ...Handler) Route {\n\treturn r.addRoute(method, pattern, h)\n}\n\nfunc (r *router) Handle(res http.ResponseWriter, req *http.Request, context Context) {\n\tbestMatch := NoMatch\n\tvar bestVals map[string]string\n\tvar bestRoute *route\n\tfor _, route := range r.getRoutes() {\n\t\tmatch, vals := route.Match(req.Method, req.URL.Path)\n\t\tif match.BetterThan(bestMatch) {\n\t\t\tbestMatch = match\n\t\t\tbestVals = vals\n\t\t\tbestRoute = route\n\t\t\tif match == ExactMatch {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tif bestMatch != NoMatch {\n\t\tparams := Params(bestVals)\n\t\tcontext.Map(params)\n\t\tbestRoute.Handle(context, res)\n\t\treturn\n\t}\n\n\t// no routes exist, 404\n\tc := &routeContext{context, 0, r.notFounds}\n\tcontext.MapTo(c, (*Context)(nil))\n\tc.run()\n}\n\nfunc (r *router) NotFound(handler ...Handler) {\n\tr.notFounds = handler\n}\n\nfunc (r *router) addRoute(method string, pattern string, handlers []Handler) *route {\n\tif len(r.groups) > 0 {\n\t\tgroupPattern := \"\"\n\t\th := make([]Handler, 0)\n\t\tfor _, g := range r.groups {\n\t\t\tgroupPattern += g.pattern\n\t\t\th = append(h, g.handlers...)\n\t\t}\n\n\t\tpattern = groupPattern + pattern\n\t\th = append(h, handlers...)\n\t\thandlers = h\n\t}\n\n\troute := newRoute(method, pattern, handlers)\n\troute.Validate()\n\tr.appendRoute(route)\n\treturn route\n}\n\nfunc (r *router) appendRoute(rt *route) {\n\tr.routesLock.Lock()\n\tdefer r.routesLock.Unlock()\n\tr.routes = append(r.routes, rt)\n}\n\nfunc (r *router) getRoutes() []*route {\n\tr.routesLock.RLock()\n\tdefer r.routesLock.RUnlock()\n\treturn r.routes[:]\n}\n\nfunc (r *router) findRoute(name string) *route {\n\tfor _, route := range r.getRoutes() {\n\t\tif route.name == name {\n\t\t\treturn route\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Route is an interface representing a Route in Martini's routing layer.\ntype Route interface {\n\t// URLWith returns a rendering of the Route's url with the given string params.\n\tURLWith([]string) string\n\t// Name sets a name for the route.\n\tName(string)\n\t// GetName returns the name of the route.\n\tGetName() string\n\t// Pattern returns the pattern of the route.\n\tPattern() string\n\t// Method returns the method of the route.\n\tMethod() string\n}\n\ntype route struct {\n\tmethod   string\n\tregex    *regexp.Regexp\n\thandlers []Handler\n\tpattern  string\n\tname     string\n}\n\nvar routeReg1 = regexp.MustCompile(`:[^/#?()\\.\\\\]+`)\nvar routeReg2 = regexp.MustCompile(`\\*\\*`)\n\nfunc newRoute(method string, pattern string, handlers []Handler) *route {\n\troute := route{method, nil, handlers, pattern, \"\"}\n\tpattern = routeReg1.ReplaceAllStringFunc(pattern, func(m string) string {\n\t\treturn fmt.Sprintf(`(?P<%s>[^/#?]+)`, m[1:])\n\t})\n\tvar index int\n\tpattern = routeReg2.ReplaceAllStringFunc(pattern, func(m string) string {\n\t\tindex++\n\t\treturn fmt.Sprintf(`(?P<_%d>[^#?]*)`, index)\n\t})\n\tpattern += `\\/?`\n\troute.regex = regexp.MustCompile(pattern)\n\treturn &route\n}\n\ntype RouteMatch int\n\nconst (\n\tNoMatch RouteMatch = iota\n\tStarMatch\n\tOverloadMatch\n\tExactMatch\n)\n\n//Higher number = better match\nfunc (r RouteMatch) BetterThan(o RouteMatch) bool {\n\treturn r > o\n}\n\nfunc (r route) MatchMethod(method string) RouteMatch {\n\tswitch {\n\tcase method == r.method:\n\t\treturn ExactMatch\n\tcase method == \"HEAD\" && r.method == \"GET\":\n\t\treturn OverloadMatch\n\tcase r.method == \"*\":\n\t\treturn StarMatch\n\tdefault:\n\t\treturn NoMatch\n\t}\n}\n\nfunc (r route) Match(method string, path string) (RouteMatch, map[string]string) {\n\t// add Any method matching support\n\tmatch := r.MatchMethod(method)\n\tif match == NoMatch {\n\t\treturn match, nil\n\t}\n\n\tmatches := r.regex.FindStringSubmatch(path)\n\tif len(matches) > 0 && matches[0] == path {\n\t\tparams := make(map[string]string)\n\t\tfor i, name := range r.regex.SubexpNames() {\n\t\t\tif len(name) > 0 {\n\t\t\t\tparams[name] = matches[i]\n\t\t\t}\n\t\t}\n\t\treturn match, params\n\t}\n\treturn NoMatch, nil\n}\n\nfunc (r *route) Validate() {\n\tfor _, handler := range r.handlers {\n\t\tvalidateHandler(handler)\n\t}\n}\n\nfunc (r *route) Handle(c Context, res http.ResponseWriter) {\n\tcontext := &routeContext{c, 0, r.handlers}\n\tc.MapTo(context, (*Context)(nil))\n\tc.MapTo(r, (*Route)(nil))\n\tcontext.run()\n}\n\nvar urlReg = regexp.MustCompile(`:[^/#?()\\.\\\\]+|\\(\\?P<[a-zA-Z0-9]+>.*\\)`)\n\n// URLWith returns the url pattern replacing the parameters for its values\nfunc (r *route) URLWith(args []string) string {\n\tif len(args) > 0 {\n\t\targCount := len(args)\n\t\ti := 0\n\t\turl := urlReg.ReplaceAllStringFunc(r.pattern, func(m string) string {\n\t\t\tvar val interface{}\n\t\t\tif i < argCount {\n\t\t\t\tval = args[i]\n\t\t\t} else {\n\t\t\t\tval = m\n\t\t\t}\n\t\t\ti += 1\n\t\t\treturn fmt.Sprintf(`%v`, val)\n\t\t})\n\n\t\treturn url\n\t}\n\treturn r.pattern\n}\n\nfunc (r *route) Name(name string) {\n\tr.name = name\n}\n\nfunc (r *route) GetName() string {\n\treturn r.name\n}\n\nfunc (r *route) Pattern() string {\n\treturn r.pattern\n}\n\nfunc (r *route) Method() string {\n\treturn r.method\n}\n\n// Routes is a helper service for Martini's routing layer.\ntype Routes interface {\n\t// URLFor returns a rendered URL for the given route. Optional params can be passed to fulfill named parameters in the route.\n\tURLFor(name string, params ...interface{}) string\n\t// MethodsFor returns an array of methods available for the path\n\tMethodsFor(path string) []string\n\t// All returns an array with all the routes in the router.\n\tAll() []Route\n}\n\n// URLFor returns the url for the given route name.\nfunc (r *router) URLFor(name string, params ...interface{}) string {\n\troute := r.findRoute(name)\n\n\tif route == nil {\n\t\tpanic(\"route not found\")\n\t}\n\n\tvar args []string\n\tfor _, param := range params {\n\t\tswitch v := param.(type) {\n\t\tcase int:\n\t\t\targs = append(args, strconv.FormatInt(int64(v), 10))\n\t\tcase string:\n\t\t\targs = append(args, v)\n\t\tdefault:\n\t\t\tif v != nil {\n\t\t\t\tpanic(\"Arguments passed to URLFor must be integers or strings\")\n\t\t\t}\n\t\t}\n\t}\n\n\treturn route.URLWith(args)\n}\n\nfunc (r *router) All() []Route {\n\troutes := r.getRoutes()\n\tvar ri = make([]Route, len(routes))\n\n\tfor i, route := range routes {\n\t\tri[i] = Route(route)\n\t}\n\n\treturn ri\n}\n\nfunc hasMethod(methods []string, method string) bool {\n\tfor _, v := range methods {\n\t\tif v == method {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// MethodsFor returns all methods available for path\nfunc (r *router) MethodsFor(path string) []string {\n\tmethods := []string{}\n\tfor _, route := range r.getRoutes() {\n\t\tmatches := route.regex.FindStringSubmatch(path)\n\t\tif len(matches) > 0 && matches[0] == path && !hasMethod(methods, route.method) {\n\t\t\tmethods = append(methods, route.method)\n\t\t}\n\t}\n\treturn methods\n}\n\ntype routeContext struct {\n\tContext\n\tindex    int\n\thandlers []Handler\n}\n\nfunc (r *routeContext) Next() {\n\tr.index += 1\n\tr.run()\n}\n\nfunc (r *routeContext) run() {\n\tfor r.index < len(r.handlers) {\n\t\thandler := r.handlers[r.index]\n\t\tvals, err := r.Invoke(handler)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tr.index += 1\n\n\t\t// if the handler returned something, write it to the http response\n\t\tif len(vals) > 0 {\n\t\t\tev := r.Get(reflect.TypeOf(ReturnHandler(nil)))\n\t\t\thandleReturn := ev.Interface().(ReturnHandler)\n\t\t\thandleReturn(r, vals)\n\t\t}\n\n\t\tif r.Written() {\n\t\t\treturn\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "router_test.go",
          "type": "blob",
          "size": 13.080078125,
          "content": "package martini\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc Test_Routing(t *testing.T) {\n\trouter := NewRouter()\n\trecorder := httptest.NewRecorder()\n\n\treq, _ := http.NewRequest(\"GET\", \"http://localhost:3000/foo\", nil)\n\tcontext := New().createContext(recorder, req)\n\n\treq2, _ := http.NewRequest(\"POST\", \"http://localhost:3000/bar/bat\", nil)\n\tcontext2 := New().createContext(recorder, req2)\n\n\treq3, _ := http.NewRequest(\"DELETE\", \"http://localhost:3000/baz\", nil)\n\tcontext3 := New().createContext(recorder, req3)\n\n\treq4, _ := http.NewRequest(\"PATCH\", \"http://localhost:3000/bar/foo\", nil)\n\tcontext4 := New().createContext(recorder, req4)\n\n\treq5, _ := http.NewRequest(\"GET\", \"http://localhost:3000/fez/this/should/match\", nil)\n\tcontext5 := New().createContext(recorder, req5)\n\n\treq6, _ := http.NewRequest(\"PUT\", \"http://localhost:3000/pop/blah/blah/blah/bap/foo/\", nil)\n\tcontext6 := New().createContext(recorder, req6)\n\n\treq7, _ := http.NewRequest(\"DELETE\", \"http://localhost:3000/wap//pow\", nil)\n\tcontext7 := New().createContext(recorder, req7)\n\n\treq8, _ := http.NewRequest(\"HEAD\", \"http://localhost:3000/wap//pow\", nil)\n\tcontext8 := New().createContext(recorder, req8)\n\n\treq9, _ := http.NewRequest(\"OPTIONS\", \"http://localhost:3000/opts\", nil)\n\tcontext9 := New().createContext(recorder, req9)\n\n\treq10, _ := http.NewRequest(\"HEAD\", \"http://localhost:3000/foo\", nil)\n\tcontext10 := New().createContext(recorder, req10)\n\n\treq11, _ := http.NewRequest(\"GET\", \"http://localhost:3000/bazz/inga\", nil)\n\tcontext11 := New().createContext(recorder, req11)\n\n\treq12, _ := http.NewRequest(\"POST\", \"http://localhost:3000/bazz/inga\", nil)\n\tcontext12 := New().createContext(recorder, req12)\n\n\treq13, _ := http.NewRequest(\"GET\", \"http://localhost:3000/bazz/in/ga\", nil)\n\tcontext13 := New().createContext(recorder, req13)\n\n\treq14, _ := http.NewRequest(\"GET\", \"http://localhost:3000/bzz\", nil)\n\tcontext14 := New().createContext(recorder, req14)\n\n\tresult := \"\"\n\trouter.Get(\"/foo\", func(req *http.Request) {\n\t\tresult += \"foo\"\n\t})\n\trouter.Patch(\"/bar/:id\", func(params Params) {\n\t\texpect(t, params[\"id\"], \"foo\")\n\t\tresult += \"barfoo\"\n\t})\n\trouter.Post(\"/bar/:id\", func(params Params) {\n\t\texpect(t, params[\"id\"], \"bat\")\n\t\tresult += \"barbat\"\n\t})\n\trouter.Put(\"/fizzbuzz\", func() {\n\t\tresult += \"fizzbuzz\"\n\t})\n\trouter.Delete(\"/bazzer\", func(c Context) {\n\t\tresult += \"baz\"\n\t})\n\trouter.Get(\"/fez/**\", func(params Params) {\n\t\texpect(t, params[\"_1\"], \"this/should/match\")\n\t\tresult += \"fez\"\n\t})\n\trouter.Put(\"/pop/**/bap/:id/**\", func(params Params) {\n\t\texpect(t, params[\"id\"], \"foo\")\n\t\texpect(t, params[\"_1\"], \"blah/blah/blah\")\n\t\texpect(t, params[\"_2\"], \"\")\n\t\tresult += \"popbap\"\n\t})\n\trouter.Delete(\"/wap/**/pow\", func(params Params) {\n\t\texpect(t, params[\"_1\"], \"\")\n\t\tresult += \"wappow\"\n\t})\n\trouter.Options(\"/opts\", func() {\n\t\tresult += \"opts\"\n\t})\n\trouter.Head(\"/wap/**/pow\", func(params Params) {\n\t\texpect(t, params[\"_1\"], \"\")\n\t\tresult += \"wappow\"\n\t})\n\trouter.Group(\"/bazz\", func(r Router) {\n\t\tr.Get(\"/inga\", func() {\n\t\t\tresult += \"get\"\n\t\t})\n\n\t\tr.Post(\"/inga\", func() {\n\t\t\tresult += \"post\"\n\t\t})\n\n\t\tr.Group(\"/in\", func(r Router) {\n\t\t\tr.Get(\"/ga\", func() {\n\t\t\t\tresult += \"ception\"\n\t\t\t})\n\t\t}, func() {\n\t\t\tresult += \"group\"\n\t\t})\n\t}, func() {\n\t\tresult += \"bazz\"\n\t}, func() {\n\t\tresult += \"inga\"\n\t})\n\trouter.AddRoute(\"GET\", \"/bzz\", func(c Context) {\n\t\tresult += \"bzz\"\n\t})\n\n\trouter.Handle(recorder, req, context)\n\trouter.Handle(recorder, req2, context2)\n\trouter.Handle(recorder, req3, context3)\n\trouter.Handle(recorder, req4, context4)\n\trouter.Handle(recorder, req5, context5)\n\trouter.Handle(recorder, req6, context6)\n\trouter.Handle(recorder, req7, context7)\n\trouter.Handle(recorder, req8, context8)\n\trouter.Handle(recorder, req9, context9)\n\trouter.Handle(recorder, req10, context10)\n\trouter.Handle(recorder, req11, context11)\n\trouter.Handle(recorder, req12, context12)\n\trouter.Handle(recorder, req13, context13)\n\trouter.Handle(recorder, req14, context14)\n\texpect(t, result, \"foobarbatbarfoofezpopbapwappowwappowoptsfoobazzingagetbazzingapostbazzingagroupceptionbzz\")\n\texpect(t, recorder.Code, http.StatusNotFound)\n\texpect(t, recorder.Body.String(), \"404 page not found\\n\")\n}\n\nfunc Test_RouterHandlerStatusCode(t *testing.T) {\n\trouter := NewRouter()\n\trouter.Get(\"/foo\", func() string {\n\t\treturn \"foo\"\n\t})\n\trouter.Get(\"/bar\", func() (int, string) {\n\t\treturn http.StatusForbidden, \"bar\"\n\t})\n\trouter.Get(\"/baz\", func() (string, string) {\n\t\treturn \"baz\", \"BAZ!\"\n\t})\n\trouter.Get(\"/bytes\", func() []byte {\n\t\treturn []byte(\"Bytes!\")\n\t})\n\trouter.Get(\"/interface\", func() interface{} {\n\t\treturn \"Interface!\"\n\t})\n\n\t// code should be 200 if none is returned from the handler\n\trecorder := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"http://localhost:3000/foo\", nil)\n\tcontext := New().createContext(recorder, req)\n\trouter.Handle(recorder, req, context)\n\texpect(t, recorder.Code, http.StatusOK)\n\texpect(t, recorder.Body.String(), \"foo\")\n\n\t// if a status code is returned, it should be used\n\trecorder = httptest.NewRecorder()\n\treq, _ = http.NewRequest(\"GET\", \"http://localhost:3000/bar\", nil)\n\tcontext = New().createContext(recorder, req)\n\trouter.Handle(recorder, req, context)\n\texpect(t, recorder.Code, http.StatusForbidden)\n\texpect(t, recorder.Body.String(), \"bar\")\n\n\t// shouldn't use the first returned value as a status code if not an integer\n\trecorder = httptest.NewRecorder()\n\treq, _ = http.NewRequest(\"GET\", \"http://localhost:3000/baz\", nil)\n\tcontext = New().createContext(recorder, req)\n\trouter.Handle(recorder, req, context)\n\texpect(t, recorder.Code, http.StatusOK)\n\texpect(t, recorder.Body.String(), \"baz\")\n\n\t// Should render bytes as a return value as well.\n\trecorder = httptest.NewRecorder()\n\treq, _ = http.NewRequest(\"GET\", \"http://localhost:3000/bytes\", nil)\n\tcontext = New().createContext(recorder, req)\n\trouter.Handle(recorder, req, context)\n\texpect(t, recorder.Code, http.StatusOK)\n\texpect(t, recorder.Body.String(), \"Bytes!\")\n\n\t// Should render interface{} values.\n\trecorder = httptest.NewRecorder()\n\treq, _ = http.NewRequest(\"GET\", \"http://localhost:3000/interface\", nil)\n\tcontext = New().createContext(recorder, req)\n\trouter.Handle(recorder, req, context)\n\texpect(t, recorder.Code, http.StatusOK)\n\texpect(t, recorder.Body.String(), \"Interface!\")\n}\n\nfunc Test_RouterHandlerStacking(t *testing.T) {\n\trouter := NewRouter()\n\trecorder := httptest.NewRecorder()\n\n\treq, _ := http.NewRequest(\"GET\", \"http://localhost:3000/foo\", nil)\n\tcontext := New().createContext(recorder, req)\n\n\tresult := \"\"\n\n\tf1 := func() {\n\t\tresult += \"foo\"\n\t}\n\n\tf2 := func(c Context) {\n\t\tresult += \"bar\"\n\t\tc.Next()\n\t\tresult += \"bing\"\n\t}\n\n\tf3 := func() string {\n\t\tresult += \"bat\"\n\t\treturn \"Hello world\"\n\t}\n\n\tf4 := func() {\n\t\tresult += \"baz\"\n\t}\n\n\trouter.Get(\"/foo\", f1, f2, f3, f4)\n\n\trouter.Handle(recorder, req, context)\n\texpect(t, result, \"foobarbatbing\")\n\texpect(t, recorder.Body.String(), \"Hello world\")\n}\n\nvar routeTests = []struct {\n\t// in\n\tmethod string\n\tpath   string\n\n\t// out\n\tmatch  RouteMatch\n\tparams map[string]string\n}{\n\t{\"GET\", \"/foo/123/bat/321\", ExactMatch, map[string]string{\"bar\": \"123\", \"baz\": \"321\"}},\n\t{\"POST\", \"/foo/123/bat/321\", NoMatch, map[string]string{}},\n\t{\"GET\", \"/foo/hello/bat/world\", ExactMatch, map[string]string{\"bar\": \"hello\", \"baz\": \"world\"}},\n\t{\"GET\", \"foo/hello/bat/world\", NoMatch, map[string]string{}},\n\t{\"GET\", \"/foo/123/bat/321/\", ExactMatch, map[string]string{\"bar\": \"123\", \"baz\": \"321\"}},\n\t{\"GET\", \"/foo/123/bat/321//\", NoMatch, map[string]string{}},\n\t{\"GET\", \"/foo/123//bat/321/\", NoMatch, map[string]string{}},\n\t{\"HEAD\", \"/foo/123/bat/321/\", OverloadMatch, map[string]string{\"bar\": \"123\", \"baz\": \"321\"}},\n}\n\nfunc Test_RouteMatching(t *testing.T) {\n\troute := newRoute(\"GET\", \"/foo/:bar/bat/:baz\", nil)\n\tfor _, tt := range routeTests {\n\t\tmatch, params := route.Match(tt.method, tt.path)\n\t\tif match != tt.match || params[\"bar\"] != tt.params[\"bar\"] || params[\"baz\"] != tt.params[\"baz\"] {\n\t\t\tt.Errorf(\"expected: (%v, %v) got: (%v, %v)\", tt.match, tt.params, match, params)\n\t\t}\n\t}\n}\n\nfunc Test_MethodsFor(t *testing.T) {\n\trouter := NewRouter()\n\trecorder := httptest.NewRecorder()\n\n\treq, _ := http.NewRequest(\"POST\", \"http://localhost:3000/foo\", nil)\n\tcontext := New().createContext(recorder, req)\n\tcontext.MapTo(router, (*Routes)(nil))\n\trouter.Post(\"/foo/bar\", func() {\n\t})\n\n\trouter.Post(\"/fo\", func() {\n\t})\n\n\trouter.Get(\"/foo\", func() {\n\t})\n\n\trouter.Put(\"/foo\", func() {\n\t})\n\n\trouter.NotFound(func(routes Routes, w http.ResponseWriter, r *http.Request) {\n\t\tmethods := routes.MethodsFor(r.URL.Path)\n\t\tif len(methods) != 0 {\n\t\t\tw.Header().Set(\"Allow\", strings.Join(methods, \",\"))\n\t\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\t}\n\t})\n\trouter.Handle(recorder, req, context)\n\texpect(t, recorder.Code, http.StatusMethodNotAllowed)\n\texpect(t, recorder.Header().Get(\"Allow\"), \"GET,PUT\")\n}\n\nfunc Test_NotFound(t *testing.T) {\n\trouter := NewRouter()\n\trecorder := httptest.NewRecorder()\n\n\treq, _ := http.NewRequest(\"GET\", \"http://localhost:3000/foo\", nil)\n\tcontext := New().createContext(recorder, req)\n\n\trouter.NotFound(func(res http.ResponseWriter) {\n\t\thttp.Error(res, \"Nope\", http.StatusNotFound)\n\t})\n\n\trouter.Handle(recorder, req, context)\n\texpect(t, recorder.Code, http.StatusNotFound)\n\texpect(t, recorder.Body.String(), \"Nope\\n\")\n}\n\nfunc Test_NotFoundAsHandler(t *testing.T) {\n\trouter := NewRouter()\n\trecorder := httptest.NewRecorder()\n\n\treq, _ := http.NewRequest(\"GET\", \"http://localhost:3000/foo\", nil)\n\tcontext := New().createContext(recorder, req)\n\n\trouter.NotFound(func() string {\n\t\treturn \"not found\"\n\t})\n\n\trouter.Handle(recorder, req, context)\n\texpect(t, recorder.Code, http.StatusOK)\n\texpect(t, recorder.Body.String(), \"not found\")\n\n\trecorder = httptest.NewRecorder()\n\n\tcontext = New().createContext(recorder, req)\n\n\trouter.NotFound(func() (int, string) {\n\t\treturn 404, \"not found\"\n\t})\n\n\trouter.Handle(recorder, req, context)\n\texpect(t, recorder.Code, http.StatusNotFound)\n\texpect(t, recorder.Body.String(), \"not found\")\n\n\trecorder = httptest.NewRecorder()\n\n\tcontext = New().createContext(recorder, req)\n\n\trouter.NotFound(func() (int, string) {\n\t\treturn 200, \"\"\n\t})\n\n\trouter.Handle(recorder, req, context)\n\texpect(t, recorder.Code, http.StatusOK)\n\texpect(t, recorder.Body.String(), \"\")\n}\n\nfunc Test_NotFoundStacking(t *testing.T) {\n\trouter := NewRouter()\n\trecorder := httptest.NewRecorder()\n\n\treq, _ := http.NewRequest(\"GET\", \"http://localhost:3000/foo\", nil)\n\tcontext := New().createContext(recorder, req)\n\n\tresult := \"\"\n\n\tf1 := func() {\n\t\tresult += \"foo\"\n\t}\n\n\tf2 := func(c Context) {\n\t\tresult += \"bar\"\n\t\tc.Next()\n\t\tresult += \"bing\"\n\t}\n\n\tf3 := func() string {\n\t\tresult += \"bat\"\n\t\treturn \"Not Found\"\n\t}\n\n\tf4 := func() {\n\t\tresult += \"baz\"\n\t}\n\n\trouter.NotFound(f1, f2, f3, f4)\n\n\trouter.Handle(recorder, req, context)\n\texpect(t, result, \"foobarbatbing\")\n\texpect(t, recorder.Body.String(), \"Not Found\")\n}\n\nfunc Test_Any(t *testing.T) {\n\trouter := NewRouter()\n\trouter.Any(\"/foo\", func(res http.ResponseWriter) {\n\t\thttp.Error(res, \"Nope\", http.StatusNotFound)\n\t})\n\n\trecorder := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"http://localhost:3000/foo\", nil)\n\tcontext := New().createContext(recorder, req)\n\trouter.Handle(recorder, req, context)\n\n\texpect(t, recorder.Code, http.StatusNotFound)\n\texpect(t, recorder.Body.String(), \"Nope\\n\")\n\n\trecorder = httptest.NewRecorder()\n\treq, _ = http.NewRequest(\"PUT\", \"http://localhost:3000/foo\", nil)\n\tcontext = New().createContext(recorder, req)\n\trouter.Handle(recorder, req, context)\n\n\texpect(t, recorder.Code, http.StatusNotFound)\n\texpect(t, recorder.Body.String(), \"Nope\\n\")\n}\n\nfunc Test_URLFor(t *testing.T) {\n\trouter := NewRouter()\n\n\trouter.Get(\"/foo\", func() {\n\t\t// Nothing\n\t}).Name(\"foo\")\n\n\trouter.Post(\"/bar/:id\", func(params Params) {\n\t\t// Nothing\n\t}).Name(\"bar\")\n\n\trouter.Get(\"/baz/:id/(?P<name>[a-z]*)\", func(params Params, routes Routes) {\n\t\t// Nothing\n\t}).Name(\"baz_id\")\n\n\trouter.Get(\"/bar/:id/:name\", func(params Params, routes Routes) {\n\t\texpect(t, routes.URLFor(\"foo\", nil), \"/foo\")\n\t\texpect(t, routes.URLFor(\"bar\", 5), \"/bar/5\")\n\t\texpect(t, routes.URLFor(\"baz_id\", 5, \"john\"), \"/baz/5/john\")\n\t\texpect(t, routes.URLFor(\"bar_id\", 5, \"john\"), \"/bar/5/john\")\n\t}).Name(\"bar_id\")\n\n\t// code should be 200 if none is returned from the handler\n\trecorder := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"http://localhost:3000/bar/foo/bar\", nil)\n\tcontext := New().createContext(recorder, req)\n\tcontext.MapTo(router, (*Routes)(nil))\n\trouter.Handle(recorder, req, context)\n}\n\nfunc Test_AllRoutes(t *testing.T) {\n\trouter := NewRouter()\n\n\tpatterns := []string{\"/foo\", \"/fee\", \"/fii\"}\n\tmethods := []string{\"GET\", \"POST\", \"DELETE\"}\n\tnames := []string{\"foo\", \"fee\", \"fii\"}\n\n\trouter.Get(\"/foo\", func() {}).Name(\"foo\")\n\trouter.Post(\"/fee\", func() {}).Name(\"fee\")\n\trouter.Delete(\"/fii\", func() {}).Name(\"fii\")\n\n\tfor i, r := range router.All() {\n\t\texpect(t, r.Pattern(), patterns[i])\n\t\texpect(t, r.Method(), methods[i])\n\t\texpect(t, r.GetName(), names[i])\n\t}\n}\n\nfunc Test_ActiveRoute(t *testing.T) {\n\trouter := NewRouter()\n\n\trouter.Get(\"/foo\", func(r Route) {\n\t\texpect(t, r.Pattern(), \"/foo\")\n\t\texpect(t, r.GetName(), \"foo\")\n\t}).Name(\"foo\")\n\n\t// code should be 200 if none is returned from the handler\n\trecorder := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"http://localhost:3000/foo\", nil)\n\tcontext := New().createContext(recorder, req)\n\tcontext.MapTo(router, (*Routes)(nil))\n\trouter.Handle(recorder, req, context)\n}\n"
        },
        {
          "name": "static.go",
          "type": "blob",
          "size": 3.2216796875,
          "content": "package martini\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// StaticOptions is a struct for specifying configuration options for the martini.Static middleware.\ntype StaticOptions struct {\n\t// Prefix is the optional prefix used to serve the static directory content\n\tPrefix string\n\t// SkipLogging will disable [Static] log messages when a static file is served.\n\tSkipLogging bool\n\t// IndexFile defines which file to serve as index if it exists.\n\tIndexFile string\n\t// Expires defines which user-defined function to use for producing a HTTP Expires Header\n\t// https://developers.google.com/speed/docs/insights/LeverageBrowserCaching\n\tExpires func() string\n\t// Fallback defines a default URL to serve when the requested resource was\n\t// not found.\n\tFallback string\n\t// Exclude defines a pattern for URLs this handler should never process.\n\tExclude string\n}\n\nfunc prepareStaticOptions(options []StaticOptions) StaticOptions {\n\tvar opt StaticOptions\n\tif len(options) > 0 {\n\t\topt = options[0]\n\t}\n\n\t// Defaults\n\tif len(opt.IndexFile) == 0 {\n\t\topt.IndexFile = \"index.html\"\n\t}\n\t// Normalize the prefix if provided\n\tif opt.Prefix != \"\" {\n\t\t// Ensure we have a leading '/'\n\t\tif opt.Prefix[0] != '/' {\n\t\t\topt.Prefix = \"/\" + opt.Prefix\n\t\t}\n\t\t// Remove any trailing '/'\n\t\topt.Prefix = strings.TrimRight(opt.Prefix, \"/\")\n\t}\n\treturn opt\n}\n\n// Static returns a middleware handler that serves static files in the given directory.\nfunc Static(directory string, staticOpt ...StaticOptions) Handler {\n\tif !filepath.IsAbs(directory) {\n\t\tdirectory = filepath.Join(Root, directory)\n\t}\n\tdir := http.Dir(directory)\n\topt := prepareStaticOptions(staticOpt)\n\n\treturn func(res http.ResponseWriter, req *http.Request, log *log.Logger) {\n\t\tif req.Method != \"GET\" && req.Method != \"HEAD\" {\n\t\t\treturn\n\t\t}\n\t\tif opt.Exclude != \"\" && strings.HasPrefix(req.URL.Path, opt.Exclude) {\n\t\t\treturn\n\t\t}\n\t\tfile := req.URL.Path\n\t\t// if we have a prefix, filter requests by stripping the prefix\n\t\tif opt.Prefix != \"\" {\n\t\t\tif !strings.HasPrefix(file, opt.Prefix) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfile = file[len(opt.Prefix):]\n\t\t\tif file != \"\" && file[0] != '/' {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tf, err := dir.Open(file)\n\t\tif err != nil {\n\t\t\t// try any fallback before giving up\n\t\t\tif opt.Fallback != \"\" {\n\t\t\t\tfile = opt.Fallback // so that logging stays true\n\t\t\t\tf, err = dir.Open(opt.Fallback)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\t// discard the error?\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tdefer f.Close()\n\n\t\tfi, err := f.Stat()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\t// try to serve index file\n\t\tif fi.IsDir() {\n\t\t\t// redirect if missing trailing slash\n\t\t\tif !strings.HasSuffix(req.URL.Path, \"/\") {\n\t\t\t\tdest := url.URL{\n\t\t\t\t\tPath:     req.URL.Path + \"/\",\n\t\t\t\t\tRawQuery: req.URL.RawQuery,\n\t\t\t\t\tFragment: req.URL.Fragment,\n\t\t\t\t}\n\t\t\t\thttp.Redirect(res, req, dest.String(), http.StatusFound)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfile = path.Join(file, opt.IndexFile)\n\t\t\tf, err = dir.Open(file)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer f.Close()\n\n\t\t\tfi, err = f.Stat()\n\t\t\tif err != nil || fi.IsDir() {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif !opt.SkipLogging {\n\t\t\tlog.Println(\"[Static] Serving \" + file)\n\t\t}\n\n\t\t// Add an Expires header to the static content\n\t\tif opt.Expires != nil {\n\t\t\tres.Header().Set(\"Expires\", opt.Expires())\n\t\t}\n\n\t\thttp.ServeContent(res, req, file, fi.ModTime(), f)\n\t}\n}\n"
        },
        {
          "name": "static_test.go",
          "type": "blob",
          "size": 6.0751953125,
          "content": "package martini\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path\"\n\t\"testing\"\n\n\t\"github.com/codegangsta/inject\"\n)\n\nvar currentRoot, _ = os.Getwd()\n\nfunc Test_Static(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\tresponse.Body = new(bytes.Buffer)\n\n\tm := New()\n\tr := NewRouter()\n\n\tm.Use(Static(currentRoot))\n\tm.Action(r.Handle)\n\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/martini.go\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tm.ServeHTTP(response, req)\n\texpect(t, response.Code, http.StatusOK)\n\texpect(t, response.Header().Get(\"Expires\"), \"\")\n\tif response.Body.Len() == 0 {\n\t\tt.Errorf(\"Got empty body for GET request\")\n\t}\n}\n\nfunc Test_Static_Local_Path(t *testing.T) {\n\tRoot = os.TempDir()\n\tresponse := httptest.NewRecorder()\n\tresponse.Body = new(bytes.Buffer)\n\n\tm := New()\n\tr := NewRouter()\n\n\tm.Use(Static(\".\"))\n\tf, err := ioutil.TempFile(Root, \"static_content\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tf.WriteString(\"Expected Content\")\n\tf.Close()\n\tm.Action(r.Handle)\n\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/\"+path.Base(f.Name()), nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tm.ServeHTTP(response, req)\n\texpect(t, response.Code, http.StatusOK)\n\texpect(t, response.Header().Get(\"Expires\"), \"\")\n\texpect(t, response.Body.String(), \"Expected Content\")\n}\n\nfunc Test_Static_Head(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\tresponse.Body = new(bytes.Buffer)\n\n\tm := New()\n\tr := NewRouter()\n\n\tm.Use(Static(currentRoot))\n\tm.Action(r.Handle)\n\n\treq, err := http.NewRequest(\"HEAD\", \"http://localhost:3000/martini.go\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tm.ServeHTTP(response, req)\n\texpect(t, response.Code, http.StatusOK)\n\tif response.Body.Len() != 0 {\n\t\tt.Errorf(\"Got non-empty body for HEAD request\")\n\t}\n}\n\nfunc Test_Static_As_Post(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\n\tm := New()\n\tr := NewRouter()\n\n\tm.Use(Static(currentRoot))\n\tm.Action(r.Handle)\n\n\treq, err := http.NewRequest(\"POST\", \"http://localhost:3000/martini.go\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tm.ServeHTTP(response, req)\n\texpect(t, response.Code, http.StatusNotFound)\n}\n\nfunc Test_Static_BadDir(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\n\tm := Classic()\n\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/martini.go\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tm.ServeHTTP(response, req)\n\trefute(t, response.Code, http.StatusOK)\n}\n\nfunc Test_Static_Options_Logging(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\n\tvar buffer bytes.Buffer\n\tm := &Martini{Injector: inject.New(), action: func() {}, logger: log.New(&buffer, \"[martini] \", 0)}\n\tm.Map(m.logger)\n\tm.Map(defaultReturnHandler())\n\n\topt := StaticOptions{}\n\tm.Use(Static(currentRoot, opt))\n\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/martini.go\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tm.ServeHTTP(response, req)\n\texpect(t, response.Code, http.StatusOK)\n\texpect(t, buffer.String(), \"[martini] [Static] Serving /martini.go\\n\")\n\n\t// Now without logging\n\tm.Handlers()\n\tbuffer.Reset()\n\n\t// This should disable logging\n\topt.SkipLogging = true\n\tm.Use(Static(currentRoot, opt))\n\n\tm.ServeHTTP(response, req)\n\texpect(t, response.Code, http.StatusOK)\n\texpect(t, buffer.String(), \"\")\n}\n\nfunc Test_Static_Options_ServeIndex(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\n\tvar buffer bytes.Buffer\n\tm := &Martini{Injector: inject.New(), action: func() {}, logger: log.New(&buffer, \"[martini] \", 0)}\n\tm.Map(m.logger)\n\tm.Map(defaultReturnHandler())\n\n\topt := StaticOptions{IndexFile: \"martini.go\"} // Define martini.go as index file\n\tm.Use(Static(currentRoot, opt))\n\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tm.ServeHTTP(response, req)\n\texpect(t, response.Code, http.StatusOK)\n\texpect(t, buffer.String(), \"[martini] [Static] Serving /martini.go\\n\")\n}\n\nfunc Test_Static_Options_Prefix(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\n\tvar buffer bytes.Buffer\n\tm := &Martini{Injector: inject.New(), action: func() {}, logger: log.New(&buffer, \"[martini] \", 0)}\n\tm.Map(m.logger)\n\tm.Map(defaultReturnHandler())\n\n\t// Serve current directory under /public\n\tm.Use(Static(currentRoot, StaticOptions{Prefix: \"/public\"}))\n\n\t// Check file content behaviour\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/public/martini.go\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tm.ServeHTTP(response, req)\n\texpect(t, response.Code, http.StatusOK)\n\texpect(t, buffer.String(), \"[martini] [Static] Serving /martini.go\\n\")\n}\n\nfunc Test_Static_Options_Expires(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\n\tvar buffer bytes.Buffer\n\tm := &Martini{Injector: inject.New(), action: func() {}, logger: log.New(&buffer, \"[martini] \", 0)}\n\tm.Map(m.logger)\n\tm.Map(defaultReturnHandler())\n\n\t// Serve current directory under /public\n\tm.Use(Static(currentRoot, StaticOptions{Expires: func() string { return \"46\" }}))\n\n\t// Check file content behaviour\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/martini.go\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tm.ServeHTTP(response, req)\n\texpect(t, response.Header().Get(\"Expires\"), \"46\")\n}\n\nfunc Test_Static_Options_Fallback(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\n\tvar buffer bytes.Buffer\n\tm := &Martini{Injector: inject.New(), action: func() {}, logger: log.New(&buffer, \"[martini] \", 0)}\n\tm.Map(m.logger)\n\tm.Map(defaultReturnHandler())\n\n\t// Serve current directory under /public\n\tm.Use(Static(currentRoot, StaticOptions{Fallback: \"/martini.go\"}))\n\n\t// Check file content behaviour\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/initram.go\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tm.ServeHTTP(response, req)\n\texpect(t, response.Code, http.StatusOK)\n\texpect(t, buffer.String(), \"[martini] [Static] Serving /martini.go\\n\")\n}\n\nfunc Test_Static_Redirect(t *testing.T) {\n\tresponse := httptest.NewRecorder()\n\n\tm := New()\n\tm.Use(Static(currentRoot, StaticOptions{Prefix: \"/public\"}))\n\n\treq, err := http.NewRequest(\"GET\", \"http://localhost:3000/public?param=foo#bar\", nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tm.ServeHTTP(response, req)\n\texpect(t, response.Code, http.StatusFound)\n\texpect(t, response.Header().Get(\"Location\"), \"/public/?param=foo#bar\")\n}\n"
        },
        {
          "name": "translations",
          "type": "tree",
          "content": null
        },
        {
          "name": "wercker.yml",
          "type": "blob",
          "size": 0.0244140625,
          "content": "box: wercker/golang@1.1.1"
        }
      ]
    }
  ]
}