{
  "metadata": {
    "timestamp": 1736567918176,
    "page": 63,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "casbin/casbin",
      "stars": 18030,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2958984375,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\n.idea/\n*.iml\n\n# vendor files\nvendor\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 16.447265625,
          "content": "# Based on https://gist.github.com/maratori/47a4d00457a92aa426dbd48a18776322\n# This code is licensed under the terms of the MIT license https://opensource.org/license/mit\n# Copyright (c) 2021 Marat Reymers\n\n## Golden config for golangci-lint v1.56.2\n#\n# This is the best config for golangci-lint based on my experience and opinion.\n# It is very strict, but not extremely strict.\n# Feel free to adapt and change it for your needs.\n\nrun:\n  # Timeout for analysis, e.g. 30s, 5m.\n  # Default: 1m\n  timeout: 3m\n\n\n# This file contains only configs which differ from defaults.\n# All possible options can be found here https://github.com/golangci/golangci-lint/blob/master/.golangci.reference.yml\nlinters-settings:\n  cyclop:\n    # The maximal code complexity to report.\n    # Default: 10\n    max-complexity: 30\n    # The maximal average package complexity.\n    # If it's higher than 0.0 (float) the check is enabled\n    # Default: 0.0\n    package-average: 10.0\n\n  errcheck:\n    # Report about not checking of errors in type assertions: `a := b.(MyStruct)`.\n    # Such cases aren't reported by default.\n    # Default: false\n    check-type-assertions: true\n\n  exhaustive:\n    # Program elements to check for exhaustiveness.\n    # Default: [ switch ]\n    check:\n      - switch\n      - map\n\n  exhaustruct:\n    # List of regular expressions to exclude struct packages and their names from checks.\n    # Regular expressions must match complete canonical struct package/name/structname.\n    # Default: []\n    exclude:\n      # std libs\n      - \"^net/http.Client$\"\n      - \"^net/http.Cookie$\"\n      - \"^net/http.Request$\"\n      - \"^net/http.Response$\"\n      - \"^net/http.Server$\"\n      - \"^net/http.Transport$\"\n      - \"^net/url.URL$\"\n      - \"^os/exec.Cmd$\"\n      - \"^reflect.StructField$\"\n      # public libs\n      - \"^github.com/Shopify/sarama.Config$\"\n      - \"^github.com/Shopify/sarama.ProducerMessage$\"\n      - \"^github.com/mitchellh/mapstructure.DecoderConfig$\"\n      - \"^github.com/prometheus/client_golang/.+Opts$\"\n      - \"^github.com/spf13/cobra.Command$\"\n      - \"^github.com/spf13/cobra.CompletionOptions$\"\n      - \"^github.com/stretchr/testify/mock.Mock$\"\n      - \"^github.com/testcontainers/testcontainers-go.+Request$\"\n      - \"^github.com/testcontainers/testcontainers-go.FromDockerfile$\"\n      - \"^golang.org/x/tools/go/analysis.Analyzer$\"\n      - \"^google.golang.org/protobuf/.+Options$\"\n      - \"^gopkg.in/yaml.v3.Node$\"\n\n  funlen:\n    # Checks the number of lines in a function.\n    # If lower than 0, disable the check.\n    # Default: 60\n    lines: 100\n    # Checks the number of statements in a function.\n    # If lower than 0, disable the check.\n    # Default: 40\n    statements: 50\n    # Ignore comments when counting lines.\n    # Default false\n    ignore-comments: true\n\n  gocognit:\n    # Minimal code complexity to report.\n    # Default: 30 (but we recommend 10-20)\n    min-complexity: 20\n\n  gocritic:\n    # Settings passed to gocritic.\n    # The settings key is the name of a supported gocritic checker.\n    # The list of supported checkers can be find in https://go-critic.github.io/overview.\n    settings:\n      captLocal:\n        # Whether to restrict checker to params only.\n        # Default: true\n        paramsOnly: false\n      underef:\n        # Whether to skip (*x).method() calls where x is a pointer receiver.\n        # Default: true\n        skipRecvDeref: false\n\n  gomnd:\n    # List of function patterns to exclude from analysis.\n    # Values always ignored: `time.Date`,\n    # `strconv.FormatInt`, `strconv.FormatUint`, `strconv.FormatFloat`,\n    # `strconv.ParseInt`, `strconv.ParseUint`, `strconv.ParseFloat`.\n    # Default: []\n    ignored-functions:\n      - flag.Arg\n      - flag.Duration.*\n      - flag.Float.*\n      - flag.Int.*\n      - flag.Uint.*\n      - os.Chmod\n      - os.Mkdir.*\n      - os.OpenFile\n      - os.WriteFile\n      - prometheus.ExponentialBuckets.*\n      - prometheus.LinearBuckets\n\n  gomodguard:\n    blocked:\n      # List of blocked modules.\n      # Default: []\n      modules:\n        - github.com/golang/protobuf:\n            recommendations:\n              - google.golang.org/protobuf\n            reason: \"see https://developers.google.com/protocol-buffers/docs/reference/go/faq#modules\"\n        - github.com/satori/go.uuid:\n            recommendations:\n              - github.com/google/uuid\n            reason: \"satori's package is not maintained\"\n        - github.com/gofrs/uuid:\n            recommendations:\n              - github.com/gofrs/uuid/v5\n            reason: \"gofrs' package was not go module before v5\"\n\n  govet:\n    # Enable all analyzers.\n    # Default: false\n    enable-all: true\n    # Disable analyzers by name.\n    # Run `go tool vet help` to see all analyzers.\n    # Default: []\n    disable:\n      - fieldalignment # too strict\n    # Settings per analyzer.\n    settings:\n      shadow:\n        # Whether to be strict about shadowing; can be noisy.\n        # Default: false\n        #strict: true\n\n  inamedparam:\n    # Skips check for interface methods with only a single parameter.\n    # Default: false\n    skip-single-param: true\n\n  nakedret:\n    # Make an issue if func has more lines of code than this setting, and it has naked returns.\n    # Default: 30\n    max-func-lines: 0\n\n  nolintlint:\n    # Exclude following linters from requiring an explanation.\n    # Default: []\n    allow-no-explanation: [ funlen, gocognit, lll ]\n    # Enable to require an explanation of nonzero length after each nolint directive.\n    # Default: false\n    require-explanation: true\n    # Enable to require nolint directives to mention the specific linter being suppressed.\n    # Default: false\n    require-specific: true\n\n  perfsprint:\n    # Optimizes into strings concatenation.\n    # Default: true\n    strconcat: false\n\n  rowserrcheck:\n    # database/sql is always checked\n    # Default: []\n    packages:\n      - github.com/jmoiron/sqlx\n\n  tenv:\n    # The option `all` will run against whole test files (`_test.go`) regardless of method/function signatures.\n    # Otherwise, only methods that take `*testing.T`, `*testing.B`, and `testing.TB` as arguments are checked.\n    # Default: false\n    all: true\n\n  stylecheck:\n    # STxxxx checks in https://staticcheck.io/docs/configuration/options/#checks\n    # Default: [\"*\"]\n    checks: [\"all\", \"-ST1003\"]\n\n  revive:\n    rules:\n      # https://github.com/mgechev/revive/blob/master/RULES_DESCRIPTIONS.md#unused-parameter\n      - name: unused-parameter\n        disabled: true\n\nlinters:\n  disable-all: true\n  enable:\n    ## enabled by default\n    #- errcheck # checking for unchecked errors, these unchecked errors can be critical bugs in some cases\n    - gosimple # specializes in simplifying a code\n    - govet # reports suspicious constructs, such as Printf calls whose arguments do not align with the format string\n    - ineffassign # detects when assignments to existing variables are not used\n    - staticcheck # is a go vet on steroids, applying a ton of static analysis checks\n    - typecheck # like the front-end of a Go compiler, parses and type-checks Go code\n    - unused # checks for unused constants, variables, functions and types\n    ## disabled by default\n    - asasalint # checks for pass []any as any in variadic func(...any)\n    - asciicheck # checks that your code does not contain non-ASCII identifiers\n    - bidichk # checks for dangerous unicode character sequences\n    - bodyclose # checks whether HTTP response body is closed successfully\n    - cyclop # checks function and package cyclomatic complexity\n    - dupl # tool for code clone detection\n    - durationcheck # checks for two durations multiplied together\n    - errname # checks that sentinel errors are prefixed with the Err and error types are suffixed with the Error\n    #- errorlint # finds code that will cause problems with the error wrapping scheme introduced in Go 1.13\n    - execinquery # checks query string in Query function which reads your Go src files and warning it finds\n    - exhaustive # checks exhaustiveness of enum switch statements\n    - exportloopref # checks for pointers to enclosing loop variables\n    #- forbidigo # forbids identifiers\n    - funlen # tool for detection of long functions\n    - gocheckcompilerdirectives # validates go compiler directive comments (//go:)\n    #- gochecknoglobals # checks that no global variables exist\n    - gochecknoinits # checks that no init functions are present in Go code\n    - gochecksumtype # checks exhaustiveness on Go \"sum types\"\n    #- gocognit # computes and checks the cognitive complexity of functions\n    #- goconst # finds repeated strings that could be replaced by a constant\n    #- gocritic # provides diagnostics that check for bugs, performance and style issues\n    - gocyclo # computes and checks the cyclomatic complexity of functions\n    - godot # checks if comments end in a period\n    - goimports # in addition to fixing imports, goimports also formats your code in the same style as gofmt\n    #- gomnd # detects magic numbers\n    - gomoddirectives # manages the use of 'replace', 'retract', and 'excludes' directives in go.mod\n    - gomodguard # allow and block lists linter for direct Go module dependencies. This is different from depguard where there are different block types for example version constraints and module recommendations\n    - goprintffuncname # checks that printf-like functions are named with f at the end\n    - gosec # inspects source code for security problems\n    #- lll # reports long lines\n    - loggercheck # checks key value pairs for common logger libraries (kitlog,klog,logr,zap)\n    - makezero # finds slice declarations with non-zero initial length\n    - mirror # reports wrong mirror patterns of bytes/strings usage\n    - musttag # enforces field tags in (un)marshaled structs\n    - nakedret # finds naked returns in functions greater than a specified function length\n    - nestif # reports deeply nested if statements\n    - nilerr # finds the code that returns nil even if it checks that the error is not nil\n    #- nilnil # checks that there is no simultaneous return of nil error and an invalid value\n    - noctx # finds sending http request without context.Context\n    - nolintlint # reports ill-formed or insufficient nolint directives\n    #- nonamedreturns # reports all named returns\n    - nosprintfhostport # checks for misuse of Sprintf to construct a host with port in a URL\n    #- perfsprint # checks that fmt.Sprintf can be replaced with a faster alternative\n    - predeclared # finds code that shadows one of Go's predeclared identifiers\n    - promlinter # checks Prometheus metrics naming via promlint\n    - protogetter # reports direct reads from proto message fields when getters should be used\n    - reassign # checks that package variables are not reassigned\n    - revive # fast, configurable, extensible, flexible, and beautiful linter for Go, drop-in replacement of golint\n    - rowserrcheck # checks whether Err of rows is checked successfully\n    - sloglint # ensure consistent code style when using log/slog\n    - spancheck # checks for mistakes with OpenTelemetry/Census spans\n    - sqlclosecheck # checks that sql.Rows and sql.Stmt are closed\n    - stylecheck # is a replacement for golint\n    - tenv # detects using os.Setenv instead of t.Setenv since Go1.17\n    - testableexamples # checks if examples are testable (have an expected output)\n    - testifylint # checks usage of github.com/stretchr/testify\n    #- testpackage # makes you use a separate _test package\n    - tparallel # detects inappropriate usage of t.Parallel() method in your Go test codes\n    - unconvert # removes unnecessary type conversions\n    #- unparam # reports unused function parameters\n    - usestdlibvars # detects the possibility to use variables/constants from the Go standard library\n    - wastedassign # finds wasted assignment statements\n    - whitespace # detects leading and trailing whitespace\n\n    ## you may want to enable\n    #- decorder # checks declaration order and count of types, constants, variables and functions\n    #- exhaustruct # [highly recommend to enable] checks if all structure fields are initialized\n    #- gci # controls golang package import order and makes it always deterministic\n    #- ginkgolinter # [if you use ginkgo/gomega] enforces standards of using ginkgo and gomega\n    #- godox # detects FIXME, TODO and other comment keywords\n    #- goheader # checks is file header matches to pattern\n    #- inamedparam # [great idea, but too strict, need to ignore a lot of cases by default] reports interfaces with unnamed method parameters\n    #- interfacebloat # checks the number of methods inside an interface\n    #- ireturn # accept interfaces, return concrete types\n    #- prealloc # [premature optimization, but can be used in some cases] finds slice declarations that could potentially be preallocated\n    #- tagalign # checks that struct tags are well aligned\n    #- varnamelen # [great idea, but too many false positives] checks that the length of a variable's name matches its scope\n    #- wrapcheck # checks that errors returned from external packages are wrapped\n    #- zerologlint # detects the wrong usage of zerolog that a user forgets to dispatch zerolog.Event\n\n    ## disabled\n    #- containedctx # detects struct contained context.Context field\n    #- contextcheck # [too many false positives] checks the function whether use a non-inherited context\n    #- depguard # [replaced by gomodguard] checks if package imports are in a list of acceptable packages\n    #- dogsled # checks assignments with too many blank identifiers (e.g. x, _, _, _, := f())\n    #- dupword # [useless without config] checks for duplicate words in the source code\n    #- errchkjson # [don't see profit + I'm against of omitting errors like in the first example https://github.com/breml/errchkjson] checks types passed to the json encoding functions. Reports unsupported types and optionally reports occasions, where the check for the returned error can be omitted\n    #- forcetypeassert # [replaced by errcheck] finds forced type assertions\n    #- goerr113 # [too strict] checks the errors handling expressions\n    #- gofmt # [replaced by goimports] checks whether code was gofmt-ed\n    #- gofumpt # [replaced by goimports, gofumports is not available yet] checks whether code was gofumpt-ed\n    #- gosmopolitan # reports certain i18n/l10n anti-patterns in your Go codebase\n    #- grouper # analyzes expression groups\n    #- importas # enforces consistent import aliases\n    #- maintidx # measures the maintainability index of each function\n    #- misspell # [useless] finds commonly misspelled English words in comments\n    #- nlreturn # [too strict and mostly code is not more readable] checks for a new line before return and branch statements to increase code clarity\n    #- paralleltest # [too many false positives] detects missing usage of t.Parallel() method in your Go test\n    #- tagliatelle # checks the struct tags\n    #- thelper # detects golang test helpers without t.Helper() call and checks the consistency of test helpers\n    #- wsl # [too strict and mostly code is not more readable] whitespace linter forces you to use empty lines\n\n    ## deprecated\n    #- deadcode # [deprecated, replaced by unused] finds unused code\n    #- exhaustivestruct # [deprecated, replaced by exhaustruct] checks if all struct's fields are initialized\n    #- golint # [deprecated, replaced by revive] golint differs from gofmt. Gofmt reformats Go source code, whereas golint prints out style mistakes\n    #- ifshort # [deprecated] checks that your code uses short syntax for if-statements whenever possible\n    #- interfacer # [deprecated] suggests narrower interface types\n    #- maligned # [deprecated, replaced by govet fieldalignment] detects Go structs that would take less memory if their fields were sorted\n    #- nosnakecase # [deprecated, replaced by revive var-naming] detects snake case of variable naming and function name\n    #- scopelint # [deprecated, replaced by exportloopref] checks for unpinned variables in go programs\n    #- structcheck # [deprecated, replaced by unused] finds unused struct fields\n    #- varcheck # [deprecated, replaced by unused] finds unused global variables and constants\n\n\nissues:\n  # Maximum count of issues with the same text.\n  # Set to 0 to disable.\n  # Default: 3\n  max-same-issues: 50\n\n  exclude-rules:\n    - source: \"(noinspection|TODO)\"\n      linters: [ godot ]\n    - source: \"//noinspection\"\n      linters: [ gocritic ]\n    - path: \"_test\\\\.go\"\n      linters:\n        - bodyclose\n        - dupl\n        - funlen\n        - goconst\n        - gosec\n        - noctx\n        - wrapcheck\n    # TODO: remove after PR is released https://github.com/golangci/golangci-lint/pull/4386\n    - text: \"fmt.Sprintf can be replaced with string addition\"\n      linters: [ perfsprint ]"
        },
        {
          "name": ".releaserc.json",
          "type": "blob",
          "size": 0.2822265625,
          "content": "{\n  \"debug\": true,\n  \"branches\": [\n    \"+([0-9])?(.{+([0-9]),x}).x\",\n    \"master\",\n    {\n      \"name\": \"beta\",\n      \"prerelease\": true\n    }\n  ],\n  \"plugins\": [\n    \"@semantic-release/commit-analyzer\",\n    \"@semantic-release/release-notes-generator\",\n    \"@semantic-release/github\"\n  ]\n}\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.1376953125,
          "content": "language: go\r\n\r\nsudo: false\r\n\r\nenv:\r\n  - GO111MODULE=on\r\n\r\ngo:\r\n  - \"1.11.13\"\r\n  - \"1.12\"\r\n  - \"1.13\"\r\n  - \"1.14\"\r\n\r\nscript:\r\n  - make test\r\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.2705078125,
          "content": "# How to contribute\n\nThe following is a set of guidelines for contributing to casbin and its libraries, which are hosted at [casbin organization at Github](https://github.com/casbin).\n\nThis project adheres to the [Contributor Covenant 1.2.](https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html) By participating, you are expected to uphold this code. Please report unacceptable behavior to info@casbin.com.\n\n## Questions\n\n- We do our best to have an [up-to-date documentation](https://casbin.org/docs/overview)\n- [Stack Overflow](https://stackoverflow.com) is the best place to start if you have a question. Please use the [casbin tag](https://stackoverflow.com/tags/casbin/info) we are actively monitoring. We encourage you to use Stack Overflow specially for Modeling Access Control Problems, in order to build a shared knowledge base.\n- You can also join our [Discord](https://discord.gg/S5UjpzGZjN).\n\n## Reporting issues\n\nReporting issues are a great way to contribute to the project. We are perpetually grateful about a well-written, through bug report.\n\nBefore raising a new issue, check our [issue list](https://github.com/casbin/casbin/issues) to determine if it already contains the problem that you are facing.\n\nA good bug report shouldn't leave others needing to chase you for more information. Please be as detailed as possible. The following questions might serve as a template for writing a detailed report:\n\nWhat were you trying to achieve?\nWhat are the expected results?\nWhat are the received results?\nWhat are the steps to reproduce the issue?\nIn what environment did you encounter the issue?\n\nFeature requests can also be submitted as issues.\n\n## Pull requests\n\nGood pull requests (e.g. patches, improvements, new features) are a fantastic help. They should remain focused in scope and avoid unrelated commits.\n\nPlease ask first before embarking on any significant pull request (e.g. implementing new features, refactoring code etc.), otherwise you risk spending a lot of time working on something that the maintainers might not want to merge into the project.\n\nFirst add an issue to the project to discuss the improvement. Please adhere to the coding conventions used throughout the project. If in doubt, consult the [Effective Go style guide](https://golang.org/doc/effective_go.html).\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.2177734375,
          "content": "SHELL = /bin/bash\nexport PATH := $(shell yarn global bin):$(PATH)\n\ndefault: lint test\n\ntest:\n\tgo test -race -v ./...\n\nbenchmark:\n\tgo test -bench=.\n\nlint:\n\tgolangci-lint run --verbose\n\nrelease:\n\tnpx semantic-release@v19.0.2\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 18.349609375,
          "content": "Casbin\n====\n\n[![Go Report Card](https://goreportcard.com/badge/github.com/casbin/casbin)](https://goreportcard.com/report/github.com/casbin/casbin)\n[![Build](https://github.com/casbin/casbin/actions/workflows/default.yml/badge.svg)](https://github.com/casbin/casbin/actions/workflows/default.yml)\n[![Coverage Status](https://coveralls.io/repos/github/casbin/casbin/badge.svg?branch=master)](https://coveralls.io/github/casbin/casbin?branch=master)\n[![Godoc](https://godoc.org/github.com/casbin/casbin?status.svg)](https://pkg.go.dev/github.com/casbin/casbin/v2)\n[![Release](https://img.shields.io/github/release/casbin/casbin.svg)](https://github.com/casbin/casbin/releases/latest)\n[![Discord](https://img.shields.io/discord/1022748306096537660?logo=discord&label=discord&color=5865F2)](https://discord.gg/S5UjpzGZjN)\n[![Sourcegraph](https://sourcegraph.com/github.com/casbin/casbin/-/badge.svg)](https://sourcegraph.com/github.com/casbin/casbin?badge)\n\n**News**: still worry about how to write the correct Casbin policy? ``Casbin online editor`` is coming to help! Try it at: https://casbin.org/editor/\n\n![casbin Logo](casbin-logo.png)\n\nCasbin is a powerful and efficient open-source access control library for Golang projects. It provides support for enforcing authorization based on various [access control models](https://en.wikipedia.org/wiki/Computer_security_model).\n\n<p align=\"center\">\n  <sup>Sponsored by</sup>\n  <br>\n  <a href=\"https://stytch.com/docs?utm_source=oss-sponsorship&utm_medium=paid_sponsorship&utm_campaign=casbin\">\n    <picture>\n      <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://cdn.casbin.org/img/stytch-white.png\">\n      <source media=\"(prefers-color-scheme: light)\" srcset=\"https://cdn.casbin.org/img/stytch-charcoal.png\">\n      <img src=\"https://cdn.casbin.org/img/stytch-charcoal.png\" width=\"275\">\n    </picture>\n  </a><br/>\n  <a href=\"https://stytch.com/docs?utm_source=oss-sponsorship&utm_medium=paid_sponsorship&utm_campaign=casbin\"><b>Build auth with fraud prevention, faster.</b><br/> Try Stytch for API-first authentication, user & org management, multi-tenant SSO, MFA, device fingerprinting, and more.</a>\n  <br>\n</p>\n\n## All the languages supported by Casbin:\n\n| [![golang](https://casbin.org/img/langs/golang.png)](https://github.com/casbin/casbin) | [![java](https://casbin.org/img/langs/java.png)](https://github.com/casbin/jcasbin) | [![nodejs](https://casbin.org/img/langs/nodejs.png)](https://github.com/casbin/node-casbin) | [![php](https://casbin.org/img/langs/php.png)](https://github.com/php-casbin/php-casbin) |\n|----------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|\n| [Casbin](https://github.com/casbin/casbin)                                             | [jCasbin](https://github.com/casbin/jcasbin)                                        | [node-Casbin](https://github.com/casbin/node-casbin)                                        | [PHP-Casbin](https://github.com/php-casbin/php-casbin)                                   |\n| production-ready                                                                       | production-ready                                                                    | production-ready                                                                            | production-ready                                                                         |\n\n| [![python](https://casbin.org/img/langs/python.png)](https://github.com/casbin/pycasbin) | [![dotnet](https://casbin.org/img/langs/dotnet.png)](https://github.com/casbin-net/Casbin.NET) | [![c++](https://casbin.org/img/langs/cpp.png)](https://github.com/casbin/casbin-cpp) | [![rust](https://casbin.org/img/langs/rust.png)](https://github.com/casbin/casbin-rs) |\n|------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|\n| [PyCasbin](https://github.com/casbin/pycasbin)                                           | [Casbin.NET](https://github.com/casbin-net/Casbin.NET)                                         | [Casbin-CPP](https://github.com/casbin/casbin-cpp)                                   | [Casbin-RS](https://github.com/casbin/casbin-rs)                                      |\n| production-ready                                                                         | production-ready                                                                               | production-ready                                                                     | production-ready                                                                      |\n\n## Table of contents\n\n- [Supported models](#supported-models)\n- [How it works?](#how-it-works)\n- [Features](#features)\n- [Installation](#installation)\n- [Documentation](#documentation)\n- [Online editor](#online-editor)\n- [Tutorials](#tutorials)\n- [Get started](#get-started)\n- [Policy management](#policy-management)\n- [Policy persistence](#policy-persistence)\n- [Policy consistence between multiple nodes](#policy-consistence-between-multiple-nodes)\n- [Role manager](#role-manager)\n- [Benchmarks](#benchmarks)\n- [Examples](#examples)\n- [Middlewares](#middlewares)\n- [Our adopters](#our-adopters)\n\n## Supported models\n\n1. [**ACL (Access Control List)**](https://en.wikipedia.org/wiki/Access_control_list)\n2. **ACL with [superuser](https://en.wikipedia.org/wiki/Superuser)**\n3. **ACL without users**: especially useful for systems that don't have authentication or user log-ins.\n3. **ACL without resources**: some scenarios may target for a type of resources instead of an individual resource by using permissions like ``write-article``, ``read-log``. It doesn't control the access to a specific article or log.\n4. **[RBAC (Role-Based Access Control)](https://en.wikipedia.org/wiki/Role-based_access_control)**\n5. **RBAC with resource roles**: both users and resources can have roles (or groups) at the same time.\n6. **RBAC with domains/tenants**: users can have different role sets for different domains/tenants.\n7. **[ABAC (Attribute-Based Access Control)](https://en.wikipedia.org/wiki/Attribute-Based_Access_Control)**: syntax sugar like ``resource.Owner`` can be used to get the attribute for a resource.\n8. **[RESTful](https://en.wikipedia.org/wiki/Representational_state_transfer)**: supports paths like ``/res/*``, ``/res/:id`` and HTTP methods like ``GET``, ``POST``, ``PUT``, ``DELETE``.\n9. **Deny-override**: both allow and deny authorizations are supported, deny overrides the allow.\n10. **Priority**: the policy rules can be prioritized like firewall rules.\n\n## How it works?\n\nIn Casbin, an access control model is abstracted into a CONF file based on the **PERM metamodel (Policy, Effect, Request, Matchers)**. So switching or upgrading the authorization mechanism for a project is just as simple as modifying a configuration. You can customize your own access control model by combining the available models. For example, you can get RBAC roles and ABAC attributes together inside one model and share one set of policy rules.\n\nThe most basic and simplest model in Casbin is ACL. ACL's model CONF is:\n\n```ini\n# Request definition\n[request_definition]\nr = sub, obj, act\n\n# Policy definition\n[policy_definition]\np = sub, obj, act\n\n# Policy effect\n[policy_effect]\ne = some(where (p.eft == allow))\n\n# Matchers\n[matchers]\nm = r.sub == p.sub && r.obj == p.obj && r.act == p.act\n\n```\n\nAn example policy for ACL model is like:\n\n```\np, alice, data1, read\np, bob, data2, write\n```\n\nIt means:\n\n- alice can read data1\n- bob can write data2\n\nWe also support multi-line mode by appending '\\\\'  in the end:\n\n```ini\n# Matchers\n[matchers]\nm = r.sub == p.sub && r.obj == p.obj \\\n  && r.act == p.act\n```\n\nFurther more, if you are using ABAC,  you can try operator `in` like following in Casbin **golang** edition (jCasbin and Node-Casbin are not supported yet):\n\n```ini\n# Matchers\n[matchers]\nm = r.obj == p.obj && r.act == p.act || r.obj in ('data2', 'data3')\n```\n\nBut you **SHOULD** make sure that the length of the array is **MORE** than **1**, otherwise there will cause it to panic.\n\nFor more operators, you may take a look at [govaluate](https://github.com/casbin/govaluate)\n\n## Features\n\nWhat Casbin does:\n\n1. enforce the policy in the classic ``{subject, object, action}`` form or a customized form as you defined, both allow and deny authorizations are supported.\n2. handle the storage of the access control model and its policy.\n3. manage the role-user mappings and role-role mappings (aka role hierarchy in RBAC).\n4. support built-in superuser like ``root`` or ``administrator``. A superuser can do anything without explicit permissions.\n5. multiple built-in operators to support the rule matching. For example, ``keyMatch`` can map a resource key ``/foo/bar`` to the pattern ``/foo*``.\n\nWhat Casbin does NOT do:\n\n1. authentication (aka verify ``username`` and ``password`` when a user logs in)\n2. manage the list of users or roles. I believe it's more convenient for the project itself to manage these entities. Users usually have their passwords, and Casbin is not designed as a password container. However, Casbin stores the user-role mapping for the RBAC scenario.\n\n## Installation\n\n```\ngo get github.com/casbin/casbin/v2\n```\n\n## Documentation\n\nhttps://casbin.org/docs/overview\n\n## Online editor\n\nYou can also use the online editor (https://casbin.org/editor/) to write your Casbin model and policy in your web browser. It provides functionality such as ``syntax highlighting`` and ``code completion``, just like an IDE for a programming language.\n\n## Tutorials\n\nhttps://casbin.org/docs/tutorials\n\n## Get started\n\n1. New a Casbin enforcer with a model file and a policy file:\n\n    ```go\n    e, _ := casbin.NewEnforcer(\"path/to/model.conf\", \"path/to/policy.csv\")\n    ```\n\nNote: you can also initialize an enforcer with policy in DB instead of file, see [Policy-persistence](#policy-persistence) section for details.\n\n2. Add an enforcement hook into your code right before the access happens:\n\n    ```go\n    sub := \"alice\" // the user that wants to access a resource.\n    obj := \"data1\" // the resource that is going to be accessed.\n    act := \"read\" // the operation that the user performs on the resource.\n\n    if res, _ := e.Enforce(sub, obj, act); res {\n        // permit alice to read data1\n    } else {\n        // deny the request, show an error\n    }\n    ```\n\n3. Besides the static policy file, Casbin also provides API for permission management at run-time. For example, You can get all the roles assigned to a user as below:\n\n    ```go\n    roles, _ := e.GetImplicitRolesForUser(sub)\n    ```\n\nSee [Policy management APIs](#policy-management) for more usage.\n\n## Policy management\n\nCasbin provides two sets of APIs to manage permissions:\n\n- [Management API](https://casbin.org/docs/management-api): the primitive API that provides full support for Casbin policy management.\n- [RBAC API](https://casbin.org/docs/rbac-api): a more friendly API for RBAC. This API is a subset of Management API. The RBAC users could use this API to simplify the code.\n\nWe also provide a [web-based UI](https://casbin.org/docs/admin-portal) for model management and policy management:\n\n![model editor](https://hsluoyz.github.io/casbin/ui_model_editor.png)\n\n![policy editor](https://hsluoyz.github.io/casbin/ui_policy_editor.png)\n\n## Policy persistence\n\nhttps://casbin.org/docs/adapters\n\n## Policy consistence between multiple nodes\n\nhttps://casbin.org/docs/watchers\n\n## Role manager\n\nhttps://casbin.org/docs/role-managers\n\n## Benchmarks\n\nhttps://casbin.org/docs/benchmark\n\n## Examples\n\n| Model                     | Model file                                                                                                                       | Policy file                                                                                                                      |\n|---------------------------|----------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------|\n| ACL                       | [basic_model.conf](https://github.com/casbin/casbin/blob/master/examples/basic_model.conf)                                       | [basic_policy.csv](https://github.com/casbin/casbin/blob/master/examples/basic_policy.csv)                                       |\n| ACL with superuser        | [basic_model_with_root.conf](https://github.com/casbin/casbin/blob/master/examples/basic_with_root_model.conf)                   | [basic_policy.csv](https://github.com/casbin/casbin/blob/master/examples/basic_policy.csv)                                       |\n| ACL without users         | [basic_model_without_users.conf](https://github.com/casbin/casbin/blob/master/examples/basic_without_users_model.conf)           | [basic_policy_without_users.csv](https://github.com/casbin/casbin/blob/master/examples/basic_without_users_policy.csv)           |\n| ACL without resources     | [basic_model_without_resources.conf](https://github.com/casbin/casbin/blob/master/examples/basic_without_resources_model.conf)   | [basic_policy_without_resources.csv](https://github.com/casbin/casbin/blob/master/examples/basic_without_resources_policy.csv)   |\n| RBAC                      | [rbac_model.conf](https://github.com/casbin/casbin/blob/master/examples/rbac_model.conf)                                         | [rbac_policy.csv](https://github.com/casbin/casbin/blob/master/examples/rbac_policy.csv)                                         |\n| RBAC with resource roles  | [rbac_model_with_resource_roles.conf](https://github.com/casbin/casbin/blob/master/examples/rbac_with_resource_roles_model.conf) | [rbac_policy_with_resource_roles.csv](https://github.com/casbin/casbin/blob/master/examples/rbac_with_resource_roles_policy.csv) |\n| RBAC with domains/tenants | [rbac_model_with_domains.conf](https://github.com/casbin/casbin/blob/master/examples/rbac_with_domains_model.conf)               | [rbac_policy_with_domains.csv](https://github.com/casbin/casbin/blob/master/examples/rbac_with_domains_policy.csv)               |\n| ABAC                      | [abac_model.conf](https://github.com/casbin/casbin/blob/master/examples/abac_model.conf)                                         | N/A                                                                                                                              |\n| RESTful                   | [keymatch_model.conf](https://github.com/casbin/casbin/blob/master/examples/keymatch_model.conf)                                 | [keymatch_policy.csv](https://github.com/casbin/casbin/blob/master/examples/keymatch_policy.csv)                                 |\n| Deny-override             | [rbac_model_with_deny.conf](https://github.com/casbin/casbin/blob/master/examples/rbac_with_deny_model.conf)                     | [rbac_policy_with_deny.csv](https://github.com/casbin/casbin/blob/master/examples/rbac_with_deny_policy.csv)                     |\n| Priority                  | [priority_model.conf](https://github.com/casbin/casbin/blob/master/examples/priority_model.conf)                                 | [priority_policy.csv](https://github.com/casbin/casbin/blob/master/examples/priority_policy.csv)                                 |\n\n## Middlewares\n\nAuthz middlewares for web frameworks: https://casbin.org/docs/middlewares\n\n## Our adopters\n\nhttps://casbin.org/docs/adopters\n\n## How to Contribute\n\nPlease read the [contributing guide](CONTRIBUTING.md).\n\n## Contributors\n\nThis project exists thanks to all the people who contribute.\n<a href=\"https://github.com/casbin/casbin/graphs/contributors\"><img src=\"https://opencollective.com/casbin/contributors.svg?width=890&button=false\" /></a>\n\n## Backers\n\nThank you to all our backers!  [[Become a backer](https://opencollective.com/casbin#backer)]\n\n<a href=\"https://opencollective.com/casbin#backers\" target=\"_blank\"><img src=\"https://opencollective.com/casbin/backers.svg?width=890\"></a>\n\n## Sponsors\n\nSupport this project by becoming a sponsor. Your logo will show up here with a link to your website. [[Become a sponsor](https://opencollective.com/casbin#sponsor)]\n\n<a href=\"https://opencollective.com/casbin/sponsor/0/website\" target=\"_blank\"><img src=\"https://opencollective.com/casbin/sponsor/0/avatar.svg\"></a>\n<a href=\"https://opencollective.com/casbin/sponsor/1/website\" target=\"_blank\"><img src=\"https://opencollective.com/casbin/sponsor/1/avatar.svg\"></a>\n<a href=\"https://opencollective.com/casbin/sponsor/2/website\" target=\"_blank\"><img src=\"https://opencollective.com/casbin/sponsor/2/avatar.svg\"></a>\n<a href=\"https://opencollective.com/casbin/sponsor/3/website\" target=\"_blank\"><img src=\"https://opencollective.com/casbin/sponsor/3/avatar.svg\"></a>\n<a href=\"https://opencollective.com/casbin/sponsor/4/website\" target=\"_blank\"><img src=\"https://opencollective.com/casbin/sponsor/4/avatar.svg\"></a>\n<a href=\"https://opencollective.com/casbin/sponsor/5/website\" target=\"_blank\"><img src=\"https://opencollective.com/casbin/sponsor/5/avatar.svg\"></a>\n<a href=\"https://opencollective.com/casbin/sponsor/6/website\" target=\"_blank\"><img src=\"https://opencollective.com/casbin/sponsor/6/avatar.svg\"></a>\n<a href=\"https://opencollective.com/casbin/sponsor/7/website\" target=\"_blank\"><img src=\"https://opencollective.com/casbin/sponsor/7/avatar.svg\"></a>\n<a href=\"https://opencollective.com/casbin/sponsor/8/website\" target=\"_blank\"><img src=\"https://opencollective.com/casbin/sponsor/8/avatar.svg\"></a>\n<a href=\"https://opencollective.com/casbin/sponsor/9/website\" target=\"_blank\"><img src=\"https://opencollective.com/casbin/sponsor/9/avatar.svg\"></a>\n\n## Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=casbin/casbin&type=Date)](https://star-history.com/#casbin/casbin&Date)\n\n## License\n\nThis project is licensed under the [Apache 2.0 license](LICENSE).\n\n## Contact\n\nIf you have any issues or feature requests, please contact us. PR is welcomed.\n- https://github.com/casbin/casbin/issues\n- hsluoyz@gmail.com\n- Tencent QQ group: [546057381](//shang.qq.com/wpa/qunwpa?idkey=8ac8b91fc97ace3d383d0035f7aa06f7d670fd8e8d4837347354a31c18fac885)\n"
        },
        {
          "name": "casbin-logo.png",
          "type": "blob",
          "size": 33.4638671875,
          "content": null
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "constant",
          "type": "tree",
          "content": null
        },
        {
          "name": "effector",
          "type": "tree",
          "content": null
        },
        {
          "name": "enforcer.go",
          "type": "blob",
          "size": 26.875,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"runtime/debug\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/casbin/casbin/v2/effector\"\n\t\"github.com/casbin/casbin/v2/log\"\n\t\"github.com/casbin/casbin/v2/model\"\n\t\"github.com/casbin/casbin/v2/persist\"\n\tfileadapter \"github.com/casbin/casbin/v2/persist/file-adapter\"\n\t\"github.com/casbin/casbin/v2/rbac\"\n\tdefaultrolemanager \"github.com/casbin/casbin/v2/rbac/default-role-manager\"\n\t\"github.com/casbin/casbin/v2/util\"\n\n\t\"github.com/casbin/govaluate\"\n)\n\n// Enforcer is the main interface for authorization enforcement and policy management.\ntype Enforcer struct {\n\tmodelPath string\n\tmodel     model.Model\n\tfm        model.FunctionMap\n\teft       effector.Effector\n\n\tadapter    persist.Adapter\n\twatcher    persist.Watcher\n\tdispatcher persist.Dispatcher\n\trmMap      map[string]rbac.RoleManager\n\tcondRmMap  map[string]rbac.ConditionalRoleManager\n\tmatcherMap sync.Map\n\n\tenabled              bool\n\tautoSave             bool\n\tautoBuildRoleLinks   bool\n\tautoNotifyWatcher    bool\n\tautoNotifyDispatcher bool\n\tacceptJsonRequest    bool\n\n\tlogger log.Logger\n}\n\n// EnforceContext is used as the first element of the parameter \"rvals\" in method \"enforce\".\ntype EnforceContext struct {\n\tRType string\n\tPType string\n\tEType string\n\tMType string\n}\n\nfunc (e EnforceContext) GetCacheKey() string {\n\treturn \"EnforceContext{\" + e.RType + \"-\" + e.PType + \"-\" + e.EType + \"-\" + e.MType + \"}\"\n}\n\n// NewEnforcer creates an enforcer via file or DB.\n//\n// File:\n//\n//\te := casbin.NewEnforcer(\"path/to/basic_model.conf\", \"path/to/basic_policy.csv\")\n//\n// MySQL DB:\n//\n//\ta := mysqladapter.NewDBAdapter(\"mysql\", \"mysql_username:mysql_password@tcp(127.0.0.1:3306)/\")\n//\te := casbin.NewEnforcer(\"path/to/basic_model.conf\", a)\nfunc NewEnforcer(params ...interface{}) (*Enforcer, error) {\n\te := &Enforcer{logger: &log.DefaultLogger{}}\n\n\tparsedParamLen := 0\n\tparamLen := len(params)\n\tif paramLen >= 1 {\n\t\tenableLog, ok := params[paramLen-1].(bool)\n\t\tif ok {\n\t\t\te.EnableLog(enableLog)\n\t\t\tparsedParamLen++\n\t\t}\n\t}\n\n\tif paramLen-parsedParamLen >= 1 {\n\t\tlogger, ok := params[paramLen-parsedParamLen-1].(log.Logger)\n\t\tif ok {\n\t\t\te.logger = logger\n\t\t\tparsedParamLen++\n\t\t}\n\t}\n\n\tswitch paramLen - parsedParamLen {\n\tcase 2:\n\t\tswitch p0 := params[0].(type) {\n\t\tcase string:\n\t\t\tswitch p1 := params[1].(type) {\n\t\t\tcase string:\n\t\t\t\terr := e.InitWithFile(p0, p1)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\terr := e.InitWithAdapter(p0, p1.(persist.Adapter))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tswitch params[1].(type) {\n\t\t\tcase string:\n\t\t\t\treturn nil, errors.New(\"invalid parameters for enforcer\")\n\t\t\tdefault:\n\t\t\t\terr := e.InitWithModelAndAdapter(p0.(model.Model), params[1].(persist.Adapter))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcase 1:\n\t\tswitch p0 := params[0].(type) {\n\t\tcase string:\n\t\t\terr := e.InitWithFile(p0, \"\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tdefault:\n\t\t\terr := e.InitWithModelAndAdapter(p0.(model.Model), nil)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\tcase 0:\n\t\treturn e, nil\n\tdefault:\n\t\treturn nil, errors.New(\"invalid parameters for enforcer\")\n\t}\n\n\treturn e, nil\n}\n\n// InitWithFile initializes an enforcer with a model file and a policy file.\nfunc (e *Enforcer) InitWithFile(modelPath string, policyPath string) error {\n\ta := fileadapter.NewAdapter(policyPath)\n\treturn e.InitWithAdapter(modelPath, a)\n}\n\n// InitWithAdapter initializes an enforcer with a database adapter.\nfunc (e *Enforcer) InitWithAdapter(modelPath string, adapter persist.Adapter) error {\n\tm, err := model.NewModelFromFile(modelPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = e.InitWithModelAndAdapter(m, adapter)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\te.modelPath = modelPath\n\treturn nil\n}\n\n// InitWithModelAndAdapter initializes an enforcer with a model and a database adapter.\nfunc (e *Enforcer) InitWithModelAndAdapter(m model.Model, adapter persist.Adapter) error {\n\te.adapter = adapter\n\n\te.model = m\n\tm.SetLogger(e.logger)\n\te.model.PrintModel()\n\te.fm = model.LoadFunctionMap()\n\n\te.initialize()\n\n\t// Do not initialize the full policy when using a filtered adapter\n\tfa, ok := e.adapter.(persist.FilteredAdapter)\n\tif e.adapter != nil && (!ok || ok && !fa.IsFiltered()) {\n\t\terr := e.LoadPolicy()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// SetLogger changes the current enforcer's logger.\nfunc (e *Enforcer) SetLogger(logger log.Logger) {\n\te.logger = logger\n\te.model.SetLogger(e.logger)\n\tfor k := range e.rmMap {\n\t\te.rmMap[k].SetLogger(e.logger)\n\t}\n\tfor k := range e.condRmMap {\n\t\te.condRmMap[k].SetLogger(e.logger)\n\t}\n}\n\nfunc (e *Enforcer) initialize() {\n\te.rmMap = map[string]rbac.RoleManager{}\n\te.condRmMap = map[string]rbac.ConditionalRoleManager{}\n\te.eft = effector.NewDefaultEffector()\n\te.watcher = nil\n\te.matcherMap = sync.Map{}\n\n\te.enabled = true\n\te.autoSave = true\n\te.autoBuildRoleLinks = true\n\te.autoNotifyWatcher = true\n\te.autoNotifyDispatcher = true\n\te.initRmMap()\n}\n\n// LoadModel reloads the model from the model CONF file.\n// Because the policy is attached to a model, so the policy is invalidated and needs to be reloaded by calling LoadPolicy().\nfunc (e *Enforcer) LoadModel() error {\n\tvar err error\n\te.model, err = model.NewModelFromFile(e.modelPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\te.model.SetLogger(e.logger)\n\n\te.model.PrintModel()\n\te.fm = model.LoadFunctionMap()\n\n\te.initialize()\n\n\treturn nil\n}\n\n// GetModel gets the current model.\nfunc (e *Enforcer) GetModel() model.Model {\n\treturn e.model\n}\n\n// SetModel sets the current model.\nfunc (e *Enforcer) SetModel(m model.Model) {\n\te.model = m\n\te.fm = model.LoadFunctionMap()\n\n\te.model.SetLogger(e.logger)\n\te.initialize()\n}\n\n// GetAdapter gets the current adapter.\nfunc (e *Enforcer) GetAdapter() persist.Adapter {\n\treturn e.adapter\n}\n\n// SetAdapter sets the current adapter.\nfunc (e *Enforcer) SetAdapter(adapter persist.Adapter) {\n\te.adapter = adapter\n}\n\n// SetWatcher sets the current watcher.\nfunc (e *Enforcer) SetWatcher(watcher persist.Watcher) error {\n\te.watcher = watcher\n\tif _, ok := e.watcher.(persist.WatcherEx); ok {\n\t\t// The callback of WatcherEx has no generic implementation.\n\t\treturn nil\n\t} else {\n\t\t// In case the Watcher wants to use a customized callback function, call `SetUpdateCallback` after `SetWatcher`.\n\t\treturn watcher.SetUpdateCallback(func(string) { _ = e.LoadPolicy() })\n\t}\n}\n\n// GetRoleManager gets the current role manager.\nfunc (e *Enforcer) GetRoleManager() rbac.RoleManager {\n\tif e.rmMap != nil && e.rmMap[\"g\"] != nil {\n\t\treturn e.rmMap[\"g\"]\n\t} else {\n\t\treturn nil\n\t}\n}\n\n// GetNamedRoleManager gets the role manager for the named policy.\nfunc (e *Enforcer) GetNamedRoleManager(ptype string) rbac.RoleManager {\n\tif e.rmMap != nil && e.rmMap[ptype] != nil {\n\t\treturn e.rmMap[ptype]\n\t} else {\n\t\treturn nil\n\t}\n}\n\n// SetRoleManager sets the current role manager.\nfunc (e *Enforcer) SetRoleManager(rm rbac.RoleManager) {\n\te.invalidateMatcherMap()\n\te.rmMap[\"g\"] = rm\n}\n\n// SetNamedRoleManager sets the role manager for the named policy.\nfunc (e *Enforcer) SetNamedRoleManager(ptype string, rm rbac.RoleManager) {\n\te.invalidateMatcherMap()\n\te.rmMap[ptype] = rm\n}\n\n// SetEffector sets the current effector.\nfunc (e *Enforcer) SetEffector(eft effector.Effector) {\n\te.eft = eft\n}\n\n// ClearPolicy clears all policy.\nfunc (e *Enforcer) ClearPolicy() {\n\te.invalidateMatcherMap()\n\n\tif e.dispatcher != nil && e.autoNotifyDispatcher {\n\t\t_ = e.dispatcher.ClearPolicy()\n\t\treturn\n\t}\n\te.model.ClearPolicy()\n}\n\n// LoadPolicy reloads the policy from file/database.\nfunc (e *Enforcer) LoadPolicy() error {\n\tnewModel, err := e.loadPolicyFromAdapter(e.model)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = e.applyModifiedModel(newModel)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (e *Enforcer) loadPolicyFromAdapter(baseModel model.Model) (model.Model, error) {\n\tnewModel := baseModel.Copy()\n\tnewModel.ClearPolicy()\n\n\tif err := e.adapter.LoadPolicy(newModel); err != nil && err.Error() != \"invalid file path, file path cannot be empty\" {\n\t\treturn nil, err\n\t}\n\n\tif err := newModel.SortPoliciesBySubjectHierarchy(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := newModel.SortPoliciesByPriority(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn newModel, nil\n}\n\nfunc (e *Enforcer) applyModifiedModel(newModel model.Model) error {\n\tvar err error\n\tneedToRebuild := false\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tif e.autoBuildRoleLinks && needToRebuild {\n\t\t\t\t_ = e.BuildRoleLinks()\n\t\t\t}\n\t\t}\n\t}()\n\n\tif e.autoBuildRoleLinks {\n\t\tneedToRebuild = true\n\n\t\tif err := e.rebuildRoleLinks(newModel); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := e.rebuildConditionalRoleLinks(newModel); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\te.model = newModel\n\te.invalidateMatcherMap()\n\treturn nil\n}\n\nfunc (e *Enforcer) rebuildRoleLinks(newModel model.Model) error {\n\tif len(e.rmMap) != 0 {\n\t\tfor _, rm := range e.rmMap {\n\t\t\terr := rm.Clear()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\terr := newModel.BuildRoleLinks(e.rmMap)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (e *Enforcer) rebuildConditionalRoleLinks(newModel model.Model) error {\n\tif len(e.condRmMap) != 0 {\n\t\tfor _, crm := range e.condRmMap {\n\t\t\terr := crm.Clear()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\terr := newModel.BuildConditionalRoleLinks(e.condRmMap)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (e *Enforcer) loadFilteredPolicy(filter interface{}) error {\n\te.invalidateMatcherMap()\n\n\tvar filteredAdapter persist.FilteredAdapter\n\n\t// Attempt to cast the Adapter as a FilteredAdapter\n\tswitch adapter := e.adapter.(type) {\n\tcase persist.FilteredAdapter:\n\t\tfilteredAdapter = adapter\n\tdefault:\n\t\treturn errors.New(\"filtered policies are not supported by this adapter\")\n\t}\n\tif err := filteredAdapter.LoadFilteredPolicy(e.model, filter); err != nil && err.Error() != \"invalid file path, file path cannot be empty\" {\n\t\treturn err\n\t}\n\n\tif err := e.model.SortPoliciesBySubjectHierarchy(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := e.model.SortPoliciesByPriority(); err != nil {\n\t\treturn err\n\t}\n\n\te.initRmMap()\n\te.model.PrintPolicy()\n\tif e.autoBuildRoleLinks {\n\t\terr := e.BuildRoleLinks()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// LoadFilteredPolicy reloads a filtered policy from file/database.\nfunc (e *Enforcer) LoadFilteredPolicy(filter interface{}) error {\n\te.model.ClearPolicy()\n\n\treturn e.loadFilteredPolicy(filter)\n}\n\n// LoadIncrementalFilteredPolicy append a filtered policy from file/database.\nfunc (e *Enforcer) LoadIncrementalFilteredPolicy(filter interface{}) error {\n\treturn e.loadFilteredPolicy(filter)\n}\n\n// IsFiltered returns true if the loaded policy has been filtered.\nfunc (e *Enforcer) IsFiltered() bool {\n\tfilteredAdapter, ok := e.adapter.(persist.FilteredAdapter)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn filteredAdapter.IsFiltered()\n}\n\n// SavePolicy saves the current policy (usually after changed with Casbin API) back to file/database.\nfunc (e *Enforcer) SavePolicy() error {\n\tif e.IsFiltered() {\n\t\treturn errors.New(\"cannot save a filtered policy\")\n\t}\n\tif err := e.adapter.SavePolicy(e.model); err != nil {\n\t\treturn err\n\t}\n\tif e.watcher != nil {\n\t\tvar err error\n\t\tif watcher, ok := e.watcher.(persist.WatcherEx); ok {\n\t\t\terr = watcher.UpdateForSavePolicy(e.model)\n\t\t} else {\n\t\t\terr = e.watcher.Update()\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (e *Enforcer) initRmMap() {\n\tfor ptype, assertion := range e.model[\"g\"] {\n\t\tif rm, ok := e.rmMap[ptype]; ok {\n\t\t\t_ = rm.Clear()\n\t\t\tcontinue\n\t\t}\n\t\tif len(assertion.Tokens) <= 2 && len(assertion.ParamsTokens) == 0 {\n\t\t\tassertion.RM = defaultrolemanager.NewRoleManagerImpl(10)\n\t\t\te.rmMap[ptype] = assertion.RM\n\t\t}\n\t\tif len(assertion.Tokens) <= 2 && len(assertion.ParamsTokens) != 0 {\n\t\t\tassertion.CondRM = defaultrolemanager.NewConditionalRoleManager(10)\n\t\t\te.condRmMap[ptype] = assertion.CondRM\n\t\t}\n\t\tif len(assertion.Tokens) > 2 {\n\t\t\tif len(assertion.ParamsTokens) == 0 {\n\t\t\t\tassertion.RM = defaultrolemanager.NewRoleManager(10)\n\t\t\t\te.rmMap[ptype] = assertion.RM\n\t\t\t} else {\n\t\t\t\tassertion.CondRM = defaultrolemanager.NewConditionalDomainManager(10)\n\t\t\t\te.condRmMap[ptype] = assertion.CondRM\n\t\t\t}\n\t\t\tmatchFun := \"keyMatch(r_dom, p_dom)\"\n\t\t\tif strings.Contains(e.model[\"m\"][\"m\"].Value, matchFun) {\n\t\t\t\te.AddNamedDomainMatchingFunc(ptype, \"g\", util.KeyMatch)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// EnableEnforce changes the enforcing state of Casbin, when Casbin is disabled, all access will be allowed by the Enforce() function.\nfunc (e *Enforcer) EnableEnforce(enable bool) {\n\te.enabled = enable\n}\n\n// EnableLog changes whether Casbin will log messages to the Logger.\nfunc (e *Enforcer) EnableLog(enable bool) {\n\te.logger.EnableLog(enable)\n}\n\n// IsLogEnabled returns the current logger's enabled status.\nfunc (e *Enforcer) IsLogEnabled() bool {\n\treturn e.logger.IsEnabled()\n}\n\n// EnableAutoNotifyWatcher controls whether to save a policy rule automatically notify the Watcher when it is added or removed.\nfunc (e *Enforcer) EnableAutoNotifyWatcher(enable bool) {\n\te.autoNotifyWatcher = enable\n}\n\n// EnableAutoNotifyDispatcher controls whether to save a policy rule automatically notify the Dispatcher when it is added or removed.\nfunc (e *Enforcer) EnableAutoNotifyDispatcher(enable bool) {\n\te.autoNotifyDispatcher = enable\n}\n\n// EnableAutoSave controls whether to save a policy rule automatically to the adapter when it is added or removed.\nfunc (e *Enforcer) EnableAutoSave(autoSave bool) {\n\te.autoSave = autoSave\n}\n\n// EnableAutoBuildRoleLinks controls whether to rebuild the role inheritance relations when a role is added or deleted.\nfunc (e *Enforcer) EnableAutoBuildRoleLinks(autoBuildRoleLinks bool) {\n\te.autoBuildRoleLinks = autoBuildRoleLinks\n}\n\n// EnableAcceptJsonRequest controls whether to accept json as a request parameter.\nfunc (e *Enforcer) EnableAcceptJsonRequest(acceptJsonRequest bool) {\n\te.acceptJsonRequest = acceptJsonRequest\n}\n\n// BuildRoleLinks manually rebuild the role inheritance relations.\nfunc (e *Enforcer) BuildRoleLinks() error {\n\tif e.rmMap == nil {\n\t\treturn errors.New(\"rmMap is nil\")\n\t}\n\tfor _, rm := range e.rmMap {\n\t\terr := rm.Clear()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn e.model.BuildRoleLinks(e.rmMap)\n}\n\n// BuildIncrementalRoleLinks provides incremental build the role inheritance relations.\nfunc (e *Enforcer) BuildIncrementalRoleLinks(op model.PolicyOp, ptype string, rules [][]string) error {\n\te.invalidateMatcherMap()\n\treturn e.model.BuildIncrementalRoleLinks(e.rmMap, op, \"g\", ptype, rules)\n}\n\n// BuildIncrementalConditionalRoleLinks provides incremental build the role inheritance relations with conditions.\nfunc (e *Enforcer) BuildIncrementalConditionalRoleLinks(op model.PolicyOp, ptype string, rules [][]string) error {\n\te.invalidateMatcherMap()\n\treturn e.model.BuildIncrementalConditionalRoleLinks(e.condRmMap, op, \"g\", ptype, rules)\n}\n\n// NewEnforceContext Create a default structure based on the suffix.\nfunc NewEnforceContext(suffix string) EnforceContext {\n\treturn EnforceContext{\n\t\tRType: \"r\" + suffix,\n\t\tPType: \"p\" + suffix,\n\t\tEType: \"e\" + suffix,\n\t\tMType: \"m\" + suffix,\n\t}\n}\n\nfunc (e *Enforcer) invalidateMatcherMap() {\n\te.matcherMap = sync.Map{}\n}\n\n// enforce use a custom matcher to decides whether a \"subject\" can access a \"object\" with the operation \"action\", input parameters are usually: (matcher, sub, obj, act), use model matcher by default when matcher is \"\".\nfunc (e *Enforcer) enforce(matcher string, explains *[]string, rvals ...interface{}) (ok bool, err error) { //nolint:funlen,cyclop,gocyclo // TODO: reduce function complexity\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\terr = fmt.Errorf(\"panic: %v\\n%s\", r, debug.Stack())\n\t\t}\n\t}()\n\n\tif !e.enabled {\n\t\treturn true, nil\n\t}\n\n\tfunctions := e.fm.GetFunctions()\n\tif _, ok := e.model[\"g\"]; ok {\n\t\tfor key, ast := range e.model[\"g\"] {\n\t\t\t// g must be a normal role definition (ast.RM != nil)\n\t\t\t//   or a conditional role definition (ast.CondRM != nil)\n\t\t\t// ast.RM and ast.CondRM shouldn't be nil at the same time\n\t\t\tif ast.RM != nil {\n\t\t\t\tfunctions[key] = util.GenerateGFunction(ast.RM)\n\t\t\t}\n\t\t\tif ast.CondRM != nil {\n\t\t\t\tfunctions[key] = util.GenerateConditionalGFunction(ast.CondRM)\n\t\t\t}\n\t\t}\n\t}\n\n\tvar (\n\t\trType = \"r\"\n\t\tpType = \"p\"\n\t\teType = \"e\"\n\t\tmType = \"m\"\n\t)\n\tif len(rvals) != 0 {\n\t\tswitch rvals[0].(type) {\n\t\tcase EnforceContext:\n\t\t\tenforceContext := rvals[0].(EnforceContext)\n\t\t\trType = enforceContext.RType\n\t\t\tpType = enforceContext.PType\n\t\t\teType = enforceContext.EType\n\t\t\tmType = enforceContext.MType\n\t\t\trvals = rvals[1:]\n\t\tdefault:\n\t\t\tbreak\n\t\t}\n\t}\n\n\tvar expString string\n\tif matcher == \"\" {\n\t\texpString = e.model[\"m\"][mType].Value\n\t} else {\n\t\texpString = util.RemoveComments(util.EscapeAssertion(matcher))\n\t}\n\n\trTokens := make(map[string]int, len(e.model[\"r\"][rType].Tokens))\n\tfor i, token := range e.model[\"r\"][rType].Tokens {\n\t\trTokens[token] = i\n\t}\n\tpTokens := make(map[string]int, len(e.model[\"p\"][pType].Tokens))\n\tfor i, token := range e.model[\"p\"][pType].Tokens {\n\t\tpTokens[token] = i\n\t}\n\n\tif e.acceptJsonRequest {\n\t\t// try to parse all request values from json to map[string]interface{}\n\t\t// skip if there is an error\n\t\tfor i, rval := range rvals {\n\t\t\tswitch rval := rval.(type) {\n\t\t\tcase string:\n\t\t\t\tvar mapValue map[string]interface{}\n\t\t\t\tmapValue, err = util.JsonToMap(rval)\n\t\t\t\tif err == nil {\n\t\t\t\t\trvals[i] = mapValue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tparameters := enforceParameters{\n\t\trTokens: rTokens,\n\t\trVals:   rvals,\n\n\t\tpTokens: pTokens,\n\t}\n\n\thasEval := util.HasEval(expString)\n\tif hasEval {\n\t\tfunctions[\"eval\"] = generateEvalFunction(functions, &parameters)\n\t}\n\tvar expression *govaluate.EvaluableExpression\n\texpression, err = e.getAndStoreMatcherExpression(hasEval, expString, functions)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif len(e.model[\"r\"][rType].Tokens) != len(rvals) {\n\t\treturn false, fmt.Errorf(\n\t\t\t\"invalid request size: expected %d, got %d, rvals: %v\",\n\t\t\tlen(e.model[\"r\"][rType].Tokens),\n\t\t\tlen(rvals),\n\t\t\trvals)\n\t}\n\n\tvar policyEffects []effector.Effect\n\tvar matcherResults []float64\n\n\tvar effect effector.Effect\n\tvar explainIndex int\n\n\tif policyLen := len(e.model[\"p\"][pType].Policy); policyLen != 0 && strings.Contains(expString, pType+\"_\") { //nolint:nestif // TODO: reduce function complexity\n\t\tpolicyEffects = make([]effector.Effect, policyLen)\n\t\tmatcherResults = make([]float64, policyLen)\n\n\t\tfor policyIndex, pvals := range e.model[\"p\"][pType].Policy {\n\t\t\t// log.LogPrint(\"Policy Rule: \", pvals)\n\t\t\tif len(e.model[\"p\"][pType].Tokens) != len(pvals) {\n\t\t\t\treturn false, fmt.Errorf(\n\t\t\t\t\t\"invalid policy size: expected %d, got %d, pvals: %v\",\n\t\t\t\t\tlen(e.model[\"p\"][pType].Tokens),\n\t\t\t\t\tlen(pvals),\n\t\t\t\t\tpvals)\n\t\t\t}\n\n\t\t\tparameters.pVals = pvals\n\n\t\t\tresult, err := expression.Eval(parameters)\n\t\t\t// log.LogPrint(\"Result: \", result)\n\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\n\t\t\t// set to no-match at first\n\t\t\tmatcherResults[policyIndex] = 0\n\t\t\tswitch result := result.(type) {\n\t\t\tcase bool:\n\t\t\t\tif result {\n\t\t\t\t\tmatcherResults[policyIndex] = 1\n\t\t\t\t}\n\t\t\tcase float64:\n\t\t\t\tif result != 0 {\n\t\t\t\t\tmatcherResults[policyIndex] = 1\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn false, errors.New(\"matcher result should be bool, int or float\")\n\t\t\t}\n\n\t\t\tif j, ok := parameters.pTokens[pType+\"_eft\"]; ok {\n\t\t\t\teft := parameters.pVals[j]\n\t\t\t\tif eft == \"allow\" {\n\t\t\t\t\tpolicyEffects[policyIndex] = effector.Allow\n\t\t\t\t} else if eft == \"deny\" {\n\t\t\t\t\tpolicyEffects[policyIndex] = effector.Deny\n\t\t\t\t} else {\n\t\t\t\t\tpolicyEffects[policyIndex] = effector.Indeterminate\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpolicyEffects[policyIndex] = effector.Allow\n\t\t\t}\n\n\t\t\t// if e.model[\"e\"][\"e\"].Value == \"priority(p_eft) || deny\" {\n\t\t\t//\tbreak\n\t\t\t// }\n\n\t\t\teffect, explainIndex, err = e.eft.MergeEffects(e.model[\"e\"][eType].Value, policyEffects, matcherResults, policyIndex, policyLen)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t\tif effect != effector.Indeterminate {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif hasEval && len(e.model[\"p\"][pType].Policy) == 0 {\n\t\t\treturn false, errors.New(\"please make sure rule exists in policy when using eval() in matcher\")\n\t\t}\n\n\t\tpolicyEffects = make([]effector.Effect, 1)\n\t\tmatcherResults = make([]float64, 1)\n\t\tmatcherResults[0] = 1\n\n\t\tparameters.pVals = make([]string, len(parameters.pTokens))\n\n\t\tresult, err := expression.Eval(parameters)\n\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tif result.(bool) {\n\t\t\tpolicyEffects[0] = effector.Allow\n\t\t} else {\n\t\t\tpolicyEffects[0] = effector.Indeterminate\n\t\t}\n\n\t\teffect, explainIndex, err = e.eft.MergeEffects(e.model[\"e\"][eType].Value, policyEffects, matcherResults, 0, 1)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\tvar logExplains [][]string\n\n\tif explains != nil {\n\t\tif len(*explains) > 0 {\n\t\t\tlogExplains = append(logExplains, *explains)\n\t\t}\n\n\t\tif explainIndex != -1 && len(e.model[\"p\"][pType].Policy) > explainIndex {\n\t\t\t*explains = e.model[\"p\"][pType].Policy[explainIndex]\n\t\t\tlogExplains = append(logExplains, *explains)\n\t\t}\n\t}\n\n\t// effect -> result\n\tresult := false\n\tif effect == effector.Allow {\n\t\tresult = true\n\t}\n\te.logger.LogEnforce(expString, rvals, result, logExplains)\n\n\treturn result, nil\n}\n\nfunc (e *Enforcer) getAndStoreMatcherExpression(hasEval bool, expString string, functions map[string]govaluate.ExpressionFunction) (*govaluate.EvaluableExpression, error) {\n\tvar expression *govaluate.EvaluableExpression\n\tvar err error\n\tvar cachedExpression, isPresent = e.matcherMap.Load(expString)\n\n\tif !hasEval && isPresent {\n\t\texpression = cachedExpression.(*govaluate.EvaluableExpression)\n\t} else {\n\t\texpression, err = govaluate.NewEvaluableExpressionWithFunctions(expString, functions)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\te.matcherMap.Store(expString, expression)\n\t}\n\treturn expression, nil\n}\n\n// Enforce decides whether a \"subject\" can access a \"object\" with the operation \"action\", input parameters are usually: (sub, obj, act).\nfunc (e *Enforcer) Enforce(rvals ...interface{}) (bool, error) {\n\treturn e.enforce(\"\", nil, rvals...)\n}\n\n// EnforceWithMatcher use a custom matcher to decides whether a \"subject\" can access a \"object\" with the operation \"action\", input parameters are usually: (matcher, sub, obj, act), use model matcher by default when matcher is \"\".\nfunc (e *Enforcer) EnforceWithMatcher(matcher string, rvals ...interface{}) (bool, error) {\n\treturn e.enforce(matcher, nil, rvals...)\n}\n\n// EnforceEx explain enforcement by informing matched rules.\nfunc (e *Enforcer) EnforceEx(rvals ...interface{}) (bool, []string, error) {\n\texplain := []string{}\n\tresult, err := e.enforce(\"\", &explain, rvals...)\n\treturn result, explain, err\n}\n\n// EnforceExWithMatcher use a custom matcher and explain enforcement by informing matched rules.\nfunc (e *Enforcer) EnforceExWithMatcher(matcher string, rvals ...interface{}) (bool, []string, error) {\n\texplain := []string{}\n\tresult, err := e.enforce(matcher, &explain, rvals...)\n\treturn result, explain, err\n}\n\n// BatchEnforce enforce in batches.\nfunc (e *Enforcer) BatchEnforce(requests [][]interface{}) ([]bool, error) {\n\tvar results []bool\n\tfor _, request := range requests {\n\t\tresult, err := e.enforce(\"\", nil, request...)\n\t\tif err != nil {\n\t\t\treturn results, err\n\t\t}\n\t\tresults = append(results, result)\n\t}\n\treturn results, nil\n}\n\n// BatchEnforceWithMatcher enforce with matcher in batches.\nfunc (e *Enforcer) BatchEnforceWithMatcher(matcher string, requests [][]interface{}) ([]bool, error) {\n\tvar results []bool\n\tfor _, request := range requests {\n\t\tresult, err := e.enforce(matcher, nil, request...)\n\t\tif err != nil {\n\t\t\treturn results, err\n\t\t}\n\t\tresults = append(results, result)\n\t}\n\treturn results, nil\n}\n\n// AddNamedMatchingFunc add MatchingFunc by ptype RoleManager.\nfunc (e *Enforcer) AddNamedMatchingFunc(ptype, name string, fn rbac.MatchingFunc) bool {\n\tif rm, ok := e.rmMap[ptype]; ok {\n\t\trm.AddMatchingFunc(name, fn)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// AddNamedDomainMatchingFunc add MatchingFunc by ptype to RoleManager.\nfunc (e *Enforcer) AddNamedDomainMatchingFunc(ptype, name string, fn rbac.MatchingFunc) bool {\n\tif rm, ok := e.rmMap[ptype]; ok {\n\t\trm.AddDomainMatchingFunc(name, fn)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// AddNamedLinkConditionFunc Add condition function fn for Link userName->roleName,\n// when fn returns true, Link is valid, otherwise invalid.\nfunc (e *Enforcer) AddNamedLinkConditionFunc(ptype, user, role string, fn rbac.LinkConditionFunc) bool {\n\tif rm, ok := e.condRmMap[ptype]; ok {\n\t\trm.AddLinkConditionFunc(user, role, fn)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// AddNamedDomainLinkConditionFunc Add condition function fn for Link userName-> {roleName, domain},\n// when fn returns true, Link is valid, otherwise invalid.\nfunc (e *Enforcer) AddNamedDomainLinkConditionFunc(ptype, user, role string, domain string, fn rbac.LinkConditionFunc) bool {\n\tif rm, ok := e.condRmMap[ptype]; ok {\n\t\trm.AddDomainLinkConditionFunc(user, role, domain, fn)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// SetNamedLinkConditionFuncParams Sets the parameters of the condition function fn for Link userName->roleName.\nfunc (e *Enforcer) SetNamedLinkConditionFuncParams(ptype, user, role string, params ...string) bool {\n\tif rm, ok := e.condRmMap[ptype]; ok {\n\t\trm.SetLinkConditionFuncParams(user, role, params...)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// SetNamedDomainLinkConditionFuncParams Sets the parameters of the condition function fn\n// for Link userName->{roleName, domain}.\nfunc (e *Enforcer) SetNamedDomainLinkConditionFuncParams(ptype, user, role, domain string, params ...string) bool {\n\tif rm, ok := e.condRmMap[ptype]; ok {\n\t\trm.SetDomainLinkConditionFuncParams(user, role, domain, params...)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// assumes bounds have already been checked.\ntype enforceParameters struct {\n\trTokens map[string]int\n\trVals   []interface{}\n\n\tpTokens map[string]int\n\tpVals   []string\n}\n\n// implements govaluate.Parameters.\nfunc (p enforceParameters) Get(name string) (interface{}, error) {\n\tif name == \"\" {\n\t\treturn nil, nil\n\t}\n\n\tswitch name[0] {\n\tcase 'p':\n\t\ti, ok := p.pTokens[name]\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"No parameter '\" + name + \"' found.\")\n\t\t}\n\t\treturn p.pVals[i], nil\n\tcase 'r':\n\t\ti, ok := p.rTokens[name]\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"No parameter '\" + name + \"' found.\")\n\t\t}\n\t\treturn p.rVals[i], nil\n\tdefault:\n\t\treturn nil, errors.New(\"No parameter '\" + name + \"' found.\")\n\t}\n}\n\nfunc generateEvalFunction(functions map[string]govaluate.ExpressionFunction, parameters *enforceParameters) govaluate.ExpressionFunction {\n\treturn func(args ...interface{}) (interface{}, error) {\n\t\tif len(args) != 1 {\n\t\t\treturn nil, fmt.Errorf(\"function eval(subrule string) expected %d arguments, but got %d\", 1, len(args))\n\t\t}\n\n\t\texpression, ok := args[0].(string)\n\t\tif !ok {\n\t\t\treturn nil, errors.New(\"argument of eval(subrule string) must be a string\")\n\t\t}\n\t\texpression = util.EscapeAssertion(expression)\n\t\texpr, err := govaluate.NewEvaluableExpressionWithFunctions(expression, functions)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error while parsing eval parameter: %s, %s\", expression, err.Error())\n\t\t}\n\t\treturn expr.Eval(parameters)\n\t}\n}\n"
        },
        {
          "name": "enforcer_cached.go",
          "type": "blob",
          "size": 4.646484375,
          "content": "// Copyright 2018 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/casbin/casbin/v2/persist/cache\"\n)\n\n// CachedEnforcer wraps Enforcer and provides decision cache.\ntype CachedEnforcer struct {\n\t*Enforcer\n\texpireTime  time.Duration\n\tcache       cache.Cache\n\tenableCache int32\n\tlocker      *sync.RWMutex\n}\n\ntype CacheableParam interface {\n\tGetCacheKey() string\n}\n\n// NewCachedEnforcer creates a cached enforcer via file or DB.\nfunc NewCachedEnforcer(params ...interface{}) (*CachedEnforcer, error) {\n\te := &CachedEnforcer{}\n\tvar err error\n\te.Enforcer, err = NewEnforcer(params...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\te.enableCache = 1\n\te.cache, _ = cache.NewDefaultCache()\n\te.locker = new(sync.RWMutex)\n\treturn e, nil\n}\n\n// EnableCache determines whether to enable cache on Enforce(). When enableCache is enabled, cached result (true | false) will be returned for previous decisions.\nfunc (e *CachedEnforcer) EnableCache(enableCache bool) {\n\tvar enabled int32\n\tif enableCache {\n\t\tenabled = 1\n\t}\n\tatomic.StoreInt32(&e.enableCache, enabled)\n}\n\n// Enforce decides whether a \"subject\" can access a \"object\" with the operation \"action\", input parameters are usually: (sub, obj, act).\n// if rvals is not string , ignore the cache.\nfunc (e *CachedEnforcer) Enforce(rvals ...interface{}) (bool, error) {\n\tif atomic.LoadInt32(&e.enableCache) == 0 {\n\t\treturn e.Enforcer.Enforce(rvals...)\n\t}\n\n\tkey, ok := e.getKey(rvals...)\n\tif !ok {\n\t\treturn e.Enforcer.Enforce(rvals...)\n\t}\n\n\tif res, err := e.getCachedResult(key); err == nil {\n\t\treturn res, nil\n\t} else if err != cache.ErrNoSuchKey {\n\t\treturn res, err\n\t}\n\n\tres, err := e.Enforcer.Enforce(rvals...)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\terr = e.setCachedResult(key, res, e.expireTime)\n\treturn res, err\n}\n\nfunc (e *CachedEnforcer) LoadPolicy() error {\n\tif atomic.LoadInt32(&e.enableCache) != 0 {\n\t\tif err := e.cache.Clear(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn e.Enforcer.LoadPolicy()\n}\n\nfunc (e *CachedEnforcer) RemovePolicy(params ...interface{}) (bool, error) {\n\tif atomic.LoadInt32(&e.enableCache) != 0 {\n\t\tkey, ok := e.getKey(params...)\n\t\tif ok {\n\t\t\tif err := e.cache.Delete(key); err != nil && err != cache.ErrNoSuchKey {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t}\n\t}\n\treturn e.Enforcer.RemovePolicy(params...)\n}\n\nfunc (e *CachedEnforcer) RemovePolicies(rules [][]string) (bool, error) {\n\tif len(rules) != 0 {\n\t\tif atomic.LoadInt32(&e.enableCache) != 0 {\n\t\t\tirule := make([]interface{}, len(rules[0]))\n\t\t\tfor _, rule := range rules {\n\t\t\t\tfor i, param := range rule {\n\t\t\t\t\tirule[i] = param\n\t\t\t\t}\n\t\t\t\tkey, _ := e.getKey(irule...)\n\t\t\t\tif err := e.cache.Delete(key); err != nil && err != cache.ErrNoSuchKey {\n\t\t\t\t\treturn false, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn e.Enforcer.RemovePolicies(rules)\n}\n\nfunc (e *CachedEnforcer) getCachedResult(key string) (res bool, err error) {\n\te.locker.Lock()\n\tdefer e.locker.Unlock()\n\treturn e.cache.Get(key)\n}\n\nfunc (e *CachedEnforcer) SetExpireTime(expireTime time.Duration) {\n\te.expireTime = expireTime\n}\n\nfunc (e *CachedEnforcer) SetCache(c cache.Cache) {\n\te.cache = c\n}\n\nfunc (e *CachedEnforcer) setCachedResult(key string, res bool, extra ...interface{}) error {\n\te.locker.Lock()\n\tdefer e.locker.Unlock()\n\treturn e.cache.Set(key, res, extra...)\n}\n\nfunc (e *CachedEnforcer) getKey(params ...interface{}) (string, bool) {\n\treturn GetCacheKey(params...)\n}\n\n// InvalidateCache deletes all the existing cached decisions.\nfunc (e *CachedEnforcer) InvalidateCache() error {\n\te.locker.Lock()\n\tdefer e.locker.Unlock()\n\treturn e.cache.Clear()\n}\n\nfunc GetCacheKey(params ...interface{}) (string, bool) {\n\tkey := strings.Builder{}\n\tfor _, param := range params {\n\t\tswitch typedParam := param.(type) {\n\t\tcase string:\n\t\t\tkey.WriteString(typedParam)\n\t\tcase CacheableParam:\n\t\t\tkey.WriteString(typedParam.GetCacheKey())\n\t\tdefault:\n\t\t\treturn \"\", false\n\t\t}\n\t\tkey.WriteString(\"$$\")\n\t}\n\treturn key.String(), true\n}\n\n// ClearPolicy clears all policy.\nfunc (e *CachedEnforcer) ClearPolicy() {\n\tif atomic.LoadInt32(&e.enableCache) != 0 {\n\t\tif err := e.cache.Clear(); err != nil {\n\t\t\te.logger.LogError(err, \"clear cache failed\")\n\t\t\treturn\n\t\t}\n\t}\n\te.Enforcer.ClearPolicy()\n}\n"
        },
        {
          "name": "enforcer_cached_b_test.go",
          "type": "blob",
          "size": 5.8974609375,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc BenchmarkCachedRaw(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\trawEnforce(\"alice\", \"data1\", \"read\")\n\t}\n}\n\nfunc BenchmarkCachedBasicModel(b *testing.B) {\n\te, _ := NewCachedEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\", false)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", \"data1\", \"read\")\n\t}\n}\n\nfunc BenchmarkCachedRBACModel(b *testing.B) {\n\te, _ := NewCachedEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\", false)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", \"data2\", \"read\")\n\t}\n}\n\nfunc BenchmarkCachedRBACModelSmall(b *testing.B) {\n\te, _ := NewCachedEnforcer(\"examples/rbac_model.conf\", false)\n\t// 100 roles, 10 resources.\n\tfor i := 0; i < 100; i++ {\n\t\t_, err := e.AddPolicy(fmt.Sprintf(\"group%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\")\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n\t// 1000 users.\n\tfor i := 0; i < 1000; i++ {\n\t\t_, err := e.AddGroupingPolicy(fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"group%d\", i/10))\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"user501\", \"data9\", \"read\")\n\t}\n}\n\nfunc BenchmarkCachedRBACModelMedium(b *testing.B) {\n\te, _ := NewCachedEnforcer(\"examples/rbac_model.conf\", false)\n\t// 1000 roles, 100 resources.\n\tpPolicies := make([][]string, 0)\n\tfor i := 0; i < 1000; i++ {\n\t\tpPolicies = append(pPolicies, []string{fmt.Sprintf(\"group%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\"})\n\t}\n\n\t_, err := e.AddPolicies(pPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\t// 10000 users.\n\tgPolicies := make([][]string, 0)\n\tfor i := 0; i < 10000; i++ {\n\t\tgPolicies = append(gPolicies, []string{fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"group%d\", i/10)})\n\t}\n\n\t_, err = e.AddGroupingPolicies(gPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"user5001\", \"data150\", \"read\")\n\t}\n}\n\nfunc BenchmarkCachedRBACModelLarge(b *testing.B) {\n\te, _ := NewCachedEnforcer(\"examples/rbac_model.conf\", false)\n\n\t// 10000 roles, 1000 resources.\n\tpPolicies := make([][]string, 0)\n\tfor i := 0; i < 10000; i++ {\n\t\tpPolicies = append(pPolicies, []string{fmt.Sprintf(\"group%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\"})\n\t}\n\t_, err := e.AddPolicies(pPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\t// 100000 users.\n\tgPolicies := make([][]string, 0)\n\tfor i := 0; i < 100000; i++ {\n\t\tgPolicies = append(gPolicies, []string{fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"group%d\", i/10)})\n\t}\n\t_, err = e.AddGroupingPolicies(gPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"user50001\", \"data1500\", \"read\")\n\t}\n}\n\nfunc BenchmarkCachedRBACModelWithResourceRoles(b *testing.B) {\n\te, _ := NewCachedEnforcer(\"examples/rbac_with_resource_roles_model.conf\", \"examples/rbac_with_resource_roles_policy.csv\", false)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", \"data1\", \"read\")\n\t}\n}\n\nfunc BenchmarkCachedRBACModelWithDomains(b *testing.B) {\n\te, _ := NewCachedEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy.csv\", false)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", \"domain1\", \"data1\", \"read\")\n\t}\n}\n\nfunc BenchmarkCachedABACModel(b *testing.B) {\n\te, _ := NewCachedEnforcer(\"examples/abac_model.conf\", false)\n\tdata1 := newTestResource(\"data1\", \"alice\")\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", data1, \"read\")\n\t}\n}\n\nfunc BenchmarkCachedKeyMatchModel(b *testing.B) {\n\te, _ := NewCachedEnforcer(\"examples/keymatch_model.conf\", \"examples/keymatch_policy.csv\", false)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", \"/alice_data/resource1\", \"GET\")\n\t}\n}\n\nfunc BenchmarkCachedRBACModelWithDeny(b *testing.B) {\n\te, _ := NewCachedEnforcer(\"examples/rbac_with_deny_model.conf\", \"examples/rbac_with_deny_policy.csv\", false)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", \"data1\", \"read\")\n\t}\n}\n\nfunc BenchmarkCachedPriorityModel(b *testing.B) {\n\te, _ := NewCachedEnforcer(\"examples/priority_model.conf\", \"examples/priority_policy.csv\", false)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", \"data1\", \"read\")\n\t}\n}\n\nfunc BenchmarkCachedWithEnforceContext(b *testing.B) {\n\te, _ := NewCachedEnforcer(\"examples/priority_model_enforce_context.conf\", \"examples/priority_policy_enforce_context.csv\", false)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(EnforceContext{RType: \"r2\", PType: \"p\", EType: \"e\", MType: \"m2\"}, \"alice\", \"data1\")\n\t}\n}\n\nfunc BenchmarkCachedRBACModelMediumParallel(b *testing.B) {\n\te, _ := NewCachedEnforcer(\"examples/rbac_model.conf\", false)\n\n\t// 10000 roles, 1000 resources.\n\tpPolicies := make([][]string, 0)\n\tfor i := 0; i < 10000; i++ {\n\t\tpPolicies = append(pPolicies, []string{fmt.Sprintf(\"group%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\"})\n\t}\n\t_, err := e.AddPolicies(pPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\t// 100000 users.\n\tgPolicies := make([][]string, 0)\n\tfor i := 0; i < 100000; i++ {\n\t\tgPolicies = append(gPolicies, []string{fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"group%d\", i/10)})\n\t}\n\t_, err = e.AddGroupingPolicies(gPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_, _ = e.Enforce(\"user5001\", \"data150\", \"read\")\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "enforcer_cached_synced.go",
          "type": "blob",
          "size": 4.8974609375,
          "content": "// Copyright 2018 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/casbin/casbin/v2/persist/cache\"\n)\n\n// SyncedCachedEnforcer wraps Enforcer and provides decision sync cache.\ntype SyncedCachedEnforcer struct {\n\t*SyncedEnforcer\n\texpireTime  time.Duration\n\tcache       cache.Cache\n\tenableCache int32\n\tlocker      *sync.RWMutex\n}\n\n// NewSyncedCachedEnforcer creates a sync cached enforcer via file or DB.\nfunc NewSyncedCachedEnforcer(params ...interface{}) (*SyncedCachedEnforcer, error) {\n\te := &SyncedCachedEnforcer{}\n\tvar err error\n\te.SyncedEnforcer, err = NewSyncedEnforcer(params...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\te.enableCache = 1\n\te.cache, _ = cache.NewSyncCache()\n\te.locker = new(sync.RWMutex)\n\treturn e, nil\n}\n\n// EnableCache determines whether to enable cache on Enforce(). When enableCache is enabled, cached result (true | false) will be returned for previous decisions.\nfunc (e *SyncedCachedEnforcer) EnableCache(enableCache bool) {\n\tvar enabled int32\n\tif enableCache {\n\t\tenabled = 1\n\t}\n\tatomic.StoreInt32(&e.enableCache, enabled)\n}\n\n// Enforce decides whether a \"subject\" can access a \"object\" with the operation \"action\", input parameters are usually: (sub, obj, act).\n// if rvals is not string , ignore the cache.\nfunc (e *SyncedCachedEnforcer) Enforce(rvals ...interface{}) (bool, error) {\n\tif atomic.LoadInt32(&e.enableCache) == 0 {\n\t\treturn e.SyncedEnforcer.Enforce(rvals...)\n\t}\n\n\tkey, ok := e.getKey(rvals...)\n\tif !ok {\n\t\treturn e.SyncedEnforcer.Enforce(rvals...)\n\t}\n\n\tif res, err := e.getCachedResult(key); err == nil {\n\t\treturn res, nil\n\t} else if err != cache.ErrNoSuchKey {\n\t\treturn res, err\n\t}\n\n\tres, err := e.SyncedEnforcer.Enforce(rvals...)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\terr = e.setCachedResult(key, res, e.expireTime)\n\treturn res, err\n}\n\nfunc (e *SyncedCachedEnforcer) LoadPolicy() error {\n\tif atomic.LoadInt32(&e.enableCache) != 0 {\n\t\tif err := e.cache.Clear(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn e.SyncedEnforcer.LoadPolicy()\n}\n\nfunc (e *SyncedCachedEnforcer) AddPolicy(params ...interface{}) (bool, error) {\n\tif ok, err := e.checkOneAndRemoveCache(params...); !ok {\n\t\treturn ok, err\n\t}\n\treturn e.SyncedEnforcer.AddPolicy(params...)\n}\n\nfunc (e *SyncedCachedEnforcer) AddPolicies(rules [][]string) (bool, error) {\n\tif ok, err := e.checkManyAndRemoveCache(rules); !ok {\n\t\treturn ok, err\n\t}\n\treturn e.SyncedEnforcer.AddPolicies(rules)\n}\n\nfunc (e *SyncedCachedEnforcer) RemovePolicy(params ...interface{}) (bool, error) {\n\tif ok, err := e.checkOneAndRemoveCache(params...); !ok {\n\t\treturn ok, err\n\t}\n\treturn e.SyncedEnforcer.RemovePolicy(params...)\n}\n\nfunc (e *SyncedCachedEnforcer) RemovePolicies(rules [][]string) (bool, error) {\n\tif ok, err := e.checkManyAndRemoveCache(rules); !ok {\n\t\treturn ok, err\n\t}\n\treturn e.SyncedEnforcer.RemovePolicies(rules)\n}\n\nfunc (e *SyncedCachedEnforcer) getCachedResult(key string) (res bool, err error) {\n\treturn e.cache.Get(key)\n}\n\nfunc (e *SyncedCachedEnforcer) SetExpireTime(expireTime time.Duration) {\n\te.locker.Lock()\n\tdefer e.locker.Unlock()\n\te.expireTime = expireTime\n}\n\n// SetCache need to be sync cache.\nfunc (e *SyncedCachedEnforcer) SetCache(c cache.Cache) {\n\te.locker.Lock()\n\tdefer e.locker.Unlock()\n\te.cache = c\n}\n\nfunc (e *SyncedCachedEnforcer) setCachedResult(key string, res bool, extra ...interface{}) error {\n\treturn e.cache.Set(key, res, extra...)\n}\n\nfunc (e *SyncedCachedEnforcer) getKey(params ...interface{}) (string, bool) {\n\treturn GetCacheKey(params...)\n}\n\n// InvalidateCache deletes all the existing cached decisions.\nfunc (e *SyncedCachedEnforcer) InvalidateCache() error {\n\treturn e.cache.Clear()\n}\n\nfunc (e *SyncedCachedEnforcer) checkOneAndRemoveCache(params ...interface{}) (bool, error) {\n\tif atomic.LoadInt32(&e.enableCache) != 0 {\n\t\tkey, ok := e.getKey(params...)\n\t\tif ok {\n\t\t\tif err := e.cache.Delete(key); err != nil && err != cache.ErrNoSuchKey {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t}\n\t}\n\treturn true, nil\n}\n\nfunc (e *SyncedCachedEnforcer) checkManyAndRemoveCache(rules [][]string) (bool, error) {\n\tif len(rules) != 0 {\n\t\tif atomic.LoadInt32(&e.enableCache) != 0 {\n\t\t\tirule := make([]interface{}, len(rules[0]))\n\t\t\tfor _, rule := range rules {\n\t\t\t\tfor i, param := range rule {\n\t\t\t\t\tirule[i] = param\n\t\t\t\t}\n\t\t\t\tkey, _ := e.getKey(irule...)\n\t\t\t\tif err := e.cache.Delete(key); err != nil && err != cache.ErrNoSuchKey {\n\t\t\t\t\treturn false, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true, nil\n}\n"
        },
        {
          "name": "enforcer_cached_synced_test.go",
          "type": "blob",
          "size": 2.9013671875,
          "content": "// Copyright 2018 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc testSyncEnforceCache(t *testing.T, e *SyncedCachedEnforcer, sub string, obj interface{}, act string, res bool) {\n\tt.Helper()\n\tif myRes, _ := e.Enforce(sub, obj, act); myRes != res {\n\t\tt.Errorf(\"%s, %v, %s: %t, supposed to be %t\", sub, obj, act, myRes, res)\n\t}\n}\n\nfunc TestSyncCache(t *testing.T) {\n\te, _ := NewSyncedCachedEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\te.expireTime = time.Millisecond\n\t// The cache is enabled by default for NewCachedEnforcer.\n\tg := sync.WaitGroup{}\n\tgoThread := 1000\n\tg.Add(goThread)\n\tfor i := 0; i < goThread; i++ {\n\t\tgo func() {\n\t\t\t_, _ = e.AddPolicy(\"alice\", \"data2\", \"read\")\n\t\t\ttestSyncEnforceCache(t, e, \"alice\", \"data2\", \"read\", true)\n\t\t\tif e.InvalidateCache() != nil {\n\t\t\t\tpanic(\"never reached\")\n\t\t\t}\n\t\t\tg.Done()\n\t\t}()\n\t}\n\tg.Wait()\n\t_, _ = e.RemovePolicy(\"alice\", \"data2\", \"read\")\n\n\ttestSyncEnforceCache(t, e, \"alice\", \"data1\", \"read\", true)\n\ttime.Sleep(time.Millisecond * 2) // coverage for expire\n\ttestSyncEnforceCache(t, e, \"alice\", \"data1\", \"read\", true)\n\n\ttestSyncEnforceCache(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestSyncEnforceCache(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestSyncEnforceCache(t, e, \"alice\", \"data2\", \"write\", false)\n\t// The cache is enabled, calling RemovePolicy, LoadPolicy or RemovePolicies will\n\t// also operate cached items.\n\t_, _ = e.RemovePolicy(\"alice\", \"data1\", \"read\")\n\n\ttestSyncEnforceCache(t, e, \"alice\", \"data1\", \"read\", false)\n\ttestSyncEnforceCache(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestSyncEnforceCache(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestSyncEnforceCache(t, e, \"alice\", \"data2\", \"write\", false)\n\n\te, _ = NewSyncedCachedEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\ttestSyncEnforceCache(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestSyncEnforceCache(t, e, \"bob\", \"data2\", \"write\", true)\n\ttestSyncEnforceCache(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestSyncEnforceCache(t, e, \"alice\", \"data2\", \"write\", true)\n\n\t_, _ = e.RemovePolicies([][]string{\n\t\t{\"alice\", \"data1\", \"read\"},\n\t\t{\"bob\", \"data2\", \"write\"},\n\t})\n\n\ttestSyncEnforceCache(t, e, \"alice\", \"data1\", \"read\", false)\n\ttestSyncEnforceCache(t, e, \"bob\", \"data2\", \"write\", false)\n\ttestSyncEnforceCache(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestSyncEnforceCache(t, e, \"alice\", \"data2\", \"write\", true)\n}\n"
        },
        {
          "name": "enforcer_cached_test.go",
          "type": "blob",
          "size": 2.833984375,
          "content": "// Copyright 2018 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport \"testing\"\n\nfunc testEnforceCache(t *testing.T, e *CachedEnforcer, sub string, obj interface{}, act string, res bool) {\n\tt.Helper()\n\tif myRes, _ := e.Enforce(sub, obj, act); myRes != res {\n\t\tt.Errorf(\"%s, %v, %s: %t, supposed to be %t\", sub, obj, act, myRes, res)\n\t}\n}\n\nfunc TestCache(t *testing.T) {\n\te, _ := NewCachedEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\t// The cache is enabled by default for NewCachedEnforcer.\n\n\ttestEnforceCache(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforceCache(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforceCache(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforceCache(t, e, \"alice\", \"data2\", \"write\", false)\n\n\t// The cache is enabled, calling RemovePolicy, LoadPolicy or RemovePolicies will\n\t// also operate cached items.\n\t_, _ = e.RemovePolicy(\"alice\", \"data1\", \"read\")\n\n\ttestEnforceCache(t, e, \"alice\", \"data1\", \"read\", false)\n\ttestEnforceCache(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforceCache(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforceCache(t, e, \"alice\", \"data2\", \"write\", false)\n\n\te, _ = NewCachedEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\ttestEnforceCache(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforceCache(t, e, \"bob\", \"data2\", \"write\", true)\n\ttestEnforceCache(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforceCache(t, e, \"alice\", \"data2\", \"write\", true)\n\n\t_, _ = e.RemovePolicies([][]string{\n\t\t{\"alice\", \"data1\", \"read\"},\n\t\t{\"bob\", \"data2\", \"write\"},\n\t})\n\n\ttestEnforceCache(t, e, \"alice\", \"data1\", \"read\", false)\n\ttestEnforceCache(t, e, \"bob\", \"data2\", \"write\", false)\n\ttestEnforceCache(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforceCache(t, e, \"alice\", \"data2\", \"write\", true)\n\n\te, _ = NewCachedEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\ttestEnforceCache(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforceCache(t, e, \"bob\", \"data2\", \"write\", true)\n\ttestEnforceCache(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforceCache(t, e, \"alice\", \"data2\", \"write\", true)\n\n\te.ClearPolicy()\n\n\ttestEnforceCache(t, e, \"alice\", \"data1\", \"read\", false)\n\ttestEnforceCache(t, e, \"bob\", \"data2\", \"write\", false)\n\ttestEnforceCache(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforceCache(t, e, \"alice\", \"data2\", \"write\", false)\n}\n"
        },
        {
          "name": "enforcer_distributed.go",
          "type": "blob",
          "size": 6.8447265625,
          "content": "package casbin\n\nimport (\n\t\"github.com/casbin/casbin/v2/model\"\n\t\"github.com/casbin/casbin/v2/persist\"\n)\n\n// DistributedEnforcer wraps SyncedEnforcer for dispatcher.\ntype DistributedEnforcer struct {\n\t*SyncedEnforcer\n}\n\nfunc NewDistributedEnforcer(params ...interface{}) (*DistributedEnforcer, error) {\n\te := &DistributedEnforcer{}\n\tvar err error\n\te.SyncedEnforcer, err = NewSyncedEnforcer(params...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn e, nil\n}\n\n// SetDispatcher sets the current dispatcher.\nfunc (d *DistributedEnforcer) SetDispatcher(dispatcher persist.Dispatcher) {\n\td.dispatcher = dispatcher\n}\n\n// AddPoliciesSelf provides a method for dispatcher to add authorization rules to the current policy.\n// The function returns the rules affected and error.\nfunc (d *DistributedEnforcer) AddPoliciesSelf(shouldPersist func() bool, sec string, ptype string, rules [][]string) (affected [][]string, err error) {\n\td.m.Lock()\n\tdefer d.m.Unlock()\n\tif shouldPersist != nil && shouldPersist() {\n\t\tvar noExistsPolicy [][]string\n\t\tfor _, rule := range rules {\n\t\t\tvar hasPolicy bool\n\t\t\thasPolicy, err = d.model.HasPolicy(sec, ptype, rule)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif !hasPolicy {\n\t\t\t\tnoExistsPolicy = append(noExistsPolicy, rule)\n\t\t\t}\n\t\t}\n\n\t\tif err = d.adapter.(persist.BatchAdapter).AddPolicies(sec, ptype, noExistsPolicy); err != nil && err.Error() != notImplemented {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\taffected, err = d.model.AddPoliciesWithAffected(sec, ptype, rules)\n\tif err != nil {\n\t\treturn affected, err\n\t}\n\n\tif sec == \"g\" {\n\t\terr := d.BuildIncrementalRoleLinks(model.PolicyAdd, ptype, affected)\n\t\tif err != nil {\n\t\t\treturn affected, err\n\t\t}\n\t}\n\n\treturn affected, nil\n}\n\n// RemovePoliciesSelf provides a method for dispatcher to remove a set of rules from current policy.\n// The function returns the rules affected and error.\nfunc (d *DistributedEnforcer) RemovePoliciesSelf(shouldPersist func() bool, sec string, ptype string, rules [][]string) (affected [][]string, err error) {\n\td.m.Lock()\n\tdefer d.m.Unlock()\n\tif shouldPersist != nil && shouldPersist() {\n\t\tif err = d.adapter.(persist.BatchAdapter).RemovePolicies(sec, ptype, rules); err != nil {\n\t\t\tif err.Error() != notImplemented {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\taffected, err = d.model.RemovePoliciesWithAffected(sec, ptype, rules)\n\tif err != nil {\n\t\treturn affected, err\n\t}\n\n\tif sec == \"g\" {\n\t\terr = d.BuildIncrementalRoleLinks(model.PolicyRemove, ptype, affected)\n\t\tif err != nil {\n\t\t\treturn affected, err\n\t\t}\n\t}\n\n\treturn affected, err\n}\n\n// RemoveFilteredPolicySelf provides a method for dispatcher to remove an authorization rule from the current policy, field filters can be specified.\n// The function returns the rules affected and error.\nfunc (d *DistributedEnforcer) RemoveFilteredPolicySelf(shouldPersist func() bool, sec string, ptype string, fieldIndex int, fieldValues ...string) (affected [][]string, err error) {\n\td.m.Lock()\n\tdefer d.m.Unlock()\n\tif shouldPersist != nil && shouldPersist() {\n\t\tif err = d.adapter.RemoveFilteredPolicy(sec, ptype, fieldIndex, fieldValues...); err != nil {\n\t\t\tif err.Error() != notImplemented {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\t_, affected, err = d.model.RemoveFilteredPolicy(sec, ptype, fieldIndex, fieldValues...)\n\tif err != nil {\n\t\treturn affected, err\n\t}\n\n\tif sec == \"g\" {\n\t\terr := d.BuildIncrementalRoleLinks(model.PolicyRemove, ptype, affected)\n\t\tif err != nil {\n\t\t\treturn affected, err\n\t\t}\n\t}\n\n\treturn affected, nil\n}\n\n// ClearPolicySelf provides a method for dispatcher to clear all rules from the current policy.\nfunc (d *DistributedEnforcer) ClearPolicySelf(shouldPersist func() bool) error {\n\td.m.Lock()\n\tdefer d.m.Unlock()\n\tif shouldPersist != nil && shouldPersist() {\n\t\terr := d.adapter.SavePolicy(nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\td.model.ClearPolicy()\n\n\treturn nil\n}\n\n// UpdatePolicySelf provides a method for dispatcher to update an authorization rule from the current policy.\nfunc (d *DistributedEnforcer) UpdatePolicySelf(shouldPersist func() bool, sec string, ptype string, oldRule, newRule []string) (affected bool, err error) {\n\td.m.Lock()\n\tdefer d.m.Unlock()\n\tif shouldPersist != nil && shouldPersist() {\n\t\terr = d.adapter.(persist.UpdatableAdapter).UpdatePolicy(sec, ptype, oldRule, newRule)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\truleUpdated, err := d.model.UpdatePolicy(sec, ptype, oldRule, newRule)\n\tif !ruleUpdated || err != nil {\n\t\treturn ruleUpdated, err\n\t}\n\n\tif sec == \"g\" {\n\t\terr := d.BuildIncrementalRoleLinks(model.PolicyRemove, ptype, [][]string{oldRule}) // remove the old rule\n\t\tif err != nil {\n\t\t\treturn ruleUpdated, err\n\t\t}\n\t\terr = d.BuildIncrementalRoleLinks(model.PolicyAdd, ptype, [][]string{newRule}) // add the new rule\n\t\tif err != nil {\n\t\t\treturn ruleUpdated, err\n\t\t}\n\t}\n\n\treturn ruleUpdated, nil\n}\n\n// UpdatePoliciesSelf provides a method for dispatcher to update a set of authorization rules from the current policy.\nfunc (d *DistributedEnforcer) UpdatePoliciesSelf(shouldPersist func() bool, sec string, ptype string, oldRules, newRules [][]string) (affected bool, err error) {\n\td.m.Lock()\n\tdefer d.m.Unlock()\n\tif shouldPersist != nil && shouldPersist() {\n\t\terr = d.adapter.(persist.UpdatableAdapter).UpdatePolicies(sec, ptype, oldRules, newRules)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\truleUpdated, err := d.model.UpdatePolicies(sec, ptype, oldRules, newRules)\n\tif !ruleUpdated || err != nil {\n\t\treturn ruleUpdated, err\n\t}\n\n\tif sec == \"g\" {\n\t\terr := d.BuildIncrementalRoleLinks(model.PolicyRemove, ptype, oldRules) // remove the old rule\n\t\tif err != nil {\n\t\t\treturn ruleUpdated, err\n\t\t}\n\t\terr = d.BuildIncrementalRoleLinks(model.PolicyAdd, ptype, newRules) // add the new rule\n\t\tif err != nil {\n\t\t\treturn ruleUpdated, err\n\t\t}\n\t}\n\n\treturn ruleUpdated, nil\n}\n\n// UpdateFilteredPoliciesSelf provides a method for dispatcher to update a set of authorization rules from the current policy.\nfunc (d *DistributedEnforcer) UpdateFilteredPoliciesSelf(shouldPersist func() bool, sec string, ptype string, newRules [][]string, fieldIndex int, fieldValues ...string) (bool, error) {\n\td.m.Lock()\n\tdefer d.m.Unlock()\n\tvar (\n\t\toldRules [][]string\n\t\terr      error\n\t)\n\tif shouldPersist != nil && shouldPersist() {\n\t\toldRules, err = d.adapter.(persist.UpdatableAdapter).UpdateFilteredPolicies(sec, ptype, newRules, fieldIndex, fieldValues...)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\truleChanged, err := d.model.RemovePolicies(sec, ptype, oldRules)\n\tif err != nil {\n\t\treturn ruleChanged, err\n\t}\n\terr = d.model.AddPolicies(sec, ptype, newRules)\n\tif err != nil {\n\t\treturn ruleChanged, err\n\t}\n\truleChanged = ruleChanged && len(newRules) != 0\n\tif !ruleChanged {\n\t\treturn ruleChanged, nil\n\t}\n\n\tif sec == \"g\" {\n\t\terr := d.BuildIncrementalRoleLinks(model.PolicyRemove, ptype, oldRules) // remove the old rule\n\t\tif err != nil {\n\t\t\treturn ruleChanged, err\n\t\t}\n\t\terr = d.BuildIncrementalRoleLinks(model.PolicyAdd, ptype, newRules) // add the new rule\n\t\tif err != nil {\n\t\t\treturn ruleChanged, err\n\t\t}\n\t}\n\n\treturn true, nil\n}\n"
        },
        {
          "name": "enforcer_interface.go",
          "type": "blob",
          "size": 9.1865234375,
          "content": "// Copyright 2019 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"github.com/casbin/casbin/v2/effector\"\n\t\"github.com/casbin/casbin/v2/model\"\n\t\"github.com/casbin/casbin/v2/persist\"\n\t\"github.com/casbin/casbin/v2/rbac\"\n\t\"github.com/casbin/govaluate\"\n)\n\nvar _ IEnforcer = &Enforcer{}\nvar _ IEnforcer = &SyncedEnforcer{}\nvar _ IEnforcer = &CachedEnforcer{}\n\n// IEnforcer is the API interface of Enforcer.\ntype IEnforcer interface {\n\t/* Enforcer API */\n\tInitWithFile(modelPath string, policyPath string) error\n\tInitWithAdapter(modelPath string, adapter persist.Adapter) error\n\tInitWithModelAndAdapter(m model.Model, adapter persist.Adapter) error\n\tLoadModel() error\n\tGetModel() model.Model\n\tSetModel(m model.Model)\n\tGetAdapter() persist.Adapter\n\tSetAdapter(adapter persist.Adapter)\n\tSetWatcher(watcher persist.Watcher) error\n\tGetRoleManager() rbac.RoleManager\n\tSetRoleManager(rm rbac.RoleManager)\n\tSetEffector(eft effector.Effector)\n\tClearPolicy()\n\tLoadPolicy() error\n\tLoadFilteredPolicy(filter interface{}) error\n\tLoadIncrementalFilteredPolicy(filter interface{}) error\n\tIsFiltered() bool\n\tSavePolicy() error\n\tEnableEnforce(enable bool)\n\tEnableLog(enable bool)\n\tEnableAutoNotifyWatcher(enable bool)\n\tEnableAutoSave(autoSave bool)\n\tEnableAutoBuildRoleLinks(autoBuildRoleLinks bool)\n\tBuildRoleLinks() error\n\tEnforce(rvals ...interface{}) (bool, error)\n\tEnforceWithMatcher(matcher string, rvals ...interface{}) (bool, error)\n\tEnforceEx(rvals ...interface{}) (bool, []string, error)\n\tEnforceExWithMatcher(matcher string, rvals ...interface{}) (bool, []string, error)\n\tBatchEnforce(requests [][]interface{}) ([]bool, error)\n\tBatchEnforceWithMatcher(matcher string, requests [][]interface{}) ([]bool, error)\n\n\t/* RBAC API */\n\tGetRolesForUser(name string, domain ...string) ([]string, error)\n\tGetUsersForRole(name string, domain ...string) ([]string, error)\n\tHasRoleForUser(name string, role string, domain ...string) (bool, error)\n\tAddRoleForUser(user string, role string, domain ...string) (bool, error)\n\tAddPermissionForUser(user string, permission ...string) (bool, error)\n\tAddPermissionsForUser(user string, permissions ...[]string) (bool, error)\n\tDeletePermissionForUser(user string, permission ...string) (bool, error)\n\tDeletePermissionsForUser(user string) (bool, error)\n\tGetPermissionsForUser(user string, domain ...string) ([][]string, error)\n\tHasPermissionForUser(user string, permission ...string) (bool, error)\n\tGetImplicitRolesForUser(name string, domain ...string) ([]string, error)\n\tGetImplicitPermissionsForUser(user string, domain ...string) ([][]string, error)\n\tGetImplicitUsersForPermission(permission ...string) ([]string, error)\n\tDeleteRoleForUser(user string, role string, domain ...string) (bool, error)\n\tDeleteRolesForUser(user string, domain ...string) (bool, error)\n\tDeleteUser(user string) (bool, error)\n\tDeleteRole(role string) (bool, error)\n\tDeletePermission(permission ...string) (bool, error)\n\n\t/* RBAC API with domains*/\n\tGetUsersForRoleInDomain(name string, domain string) []string\n\tGetRolesForUserInDomain(name string, domain string) []string\n\tGetPermissionsForUserInDomain(user string, domain string) [][]string\n\tAddRoleForUserInDomain(user string, role string, domain string) (bool, error)\n\tDeleteRoleForUserInDomain(user string, role string, domain string) (bool, error)\n\tGetAllUsersByDomain(domain string) ([]string, error)\n\tDeleteRolesForUserInDomain(user string, domain string) (bool, error)\n\tDeleteAllUsersByDomain(domain string) (bool, error)\n\tDeleteDomains(domains ...string) (bool, error)\n\tGetAllDomains() ([]string, error)\n\tGetAllRolesByDomain(domain string) ([]string, error)\n\n\t/* Management API */\n\tGetAllSubjects() ([]string, error)\n\tGetAllNamedSubjects(ptype string) ([]string, error)\n\tGetAllObjects() ([]string, error)\n\tGetAllNamedObjects(ptype string) ([]string, error)\n\tGetAllActions() ([]string, error)\n\tGetAllNamedActions(ptype string) ([]string, error)\n\tGetAllRoles() ([]string, error)\n\tGetAllNamedRoles(ptype string) ([]string, error)\n\tGetPolicy() ([][]string, error)\n\tGetFilteredPolicy(fieldIndex int, fieldValues ...string) ([][]string, error)\n\tGetNamedPolicy(ptype string) ([][]string, error)\n\tGetFilteredNamedPolicy(ptype string, fieldIndex int, fieldValues ...string) ([][]string, error)\n\tGetGroupingPolicy() ([][]string, error)\n\tGetFilteredGroupingPolicy(fieldIndex int, fieldValues ...string) ([][]string, error)\n\tGetNamedGroupingPolicy(ptype string) ([][]string, error)\n\tGetFilteredNamedGroupingPolicy(ptype string, fieldIndex int, fieldValues ...string) ([][]string, error)\n\tHasPolicy(params ...interface{}) (bool, error)\n\tHasNamedPolicy(ptype string, params ...interface{}) (bool, error)\n\tAddPolicy(params ...interface{}) (bool, error)\n\tAddPolicies(rules [][]string) (bool, error)\n\tAddNamedPolicy(ptype string, params ...interface{}) (bool, error)\n\tAddNamedPolicies(ptype string, rules [][]string) (bool, error)\n\tAddPoliciesEx(rules [][]string) (bool, error)\n\tAddNamedPoliciesEx(ptype string, rules [][]string) (bool, error)\n\tRemovePolicy(params ...interface{}) (bool, error)\n\tRemovePolicies(rules [][]string) (bool, error)\n\tRemoveFilteredPolicy(fieldIndex int, fieldValues ...string) (bool, error)\n\tRemoveNamedPolicy(ptype string, params ...interface{}) (bool, error)\n\tRemoveNamedPolicies(ptype string, rules [][]string) (bool, error)\n\tRemoveFilteredNamedPolicy(ptype string, fieldIndex int, fieldValues ...string) (bool, error)\n\tHasGroupingPolicy(params ...interface{}) (bool, error)\n\tHasNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error)\n\tAddGroupingPolicy(params ...interface{}) (bool, error)\n\tAddGroupingPolicies(rules [][]string) (bool, error)\n\tAddGroupingPoliciesEx(rules [][]string) (bool, error)\n\tAddNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error)\n\tAddNamedGroupingPolicies(ptype string, rules [][]string) (bool, error)\n\tAddNamedGroupingPoliciesEx(ptype string, rules [][]string) (bool, error)\n\tRemoveGroupingPolicy(params ...interface{}) (bool, error)\n\tRemoveGroupingPolicies(rules [][]string) (bool, error)\n\tRemoveFilteredGroupingPolicy(fieldIndex int, fieldValues ...string) (bool, error)\n\tRemoveNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error)\n\tRemoveNamedGroupingPolicies(ptype string, rules [][]string) (bool, error)\n\tRemoveFilteredNamedGroupingPolicy(ptype string, fieldIndex int, fieldValues ...string) (bool, error)\n\tAddFunction(name string, function govaluate.ExpressionFunction)\n\n\tUpdatePolicy(oldPolicy []string, newPolicy []string) (bool, error)\n\tUpdatePolicies(oldPolicies [][]string, newPolicies [][]string) (bool, error)\n\tUpdateFilteredPolicies(newPolicies [][]string, fieldIndex int, fieldValues ...string) (bool, error)\n\n\tUpdateGroupingPolicy(oldRule []string, newRule []string) (bool, error)\n\tUpdateGroupingPolicies(oldRules [][]string, newRules [][]string) (bool, error)\n\tUpdateNamedGroupingPolicy(ptype string, oldRule []string, newRule []string) (bool, error)\n\tUpdateNamedGroupingPolicies(ptype string, oldRules [][]string, newRules [][]string) (bool, error)\n\n\t/* Management API with autoNotifyWatcher disabled */\n\tSelfAddPolicy(sec string, ptype string, rule []string) (bool, error)\n\tSelfAddPolicies(sec string, ptype string, rules [][]string) (bool, error)\n\tSelfAddPoliciesEx(sec string, ptype string, rules [][]string) (bool, error)\n\tSelfRemovePolicy(sec string, ptype string, rule []string) (bool, error)\n\tSelfRemovePolicies(sec string, ptype string, rules [][]string) (bool, error)\n\tSelfRemoveFilteredPolicy(sec string, ptype string, fieldIndex int, fieldValues ...string) (bool, error)\n\tSelfUpdatePolicy(sec string, ptype string, oldRule, newRule []string) (bool, error)\n\tSelfUpdatePolicies(sec string, ptype string, oldRules, newRules [][]string) (bool, error)\n}\n\nvar _ IDistributedEnforcer = &DistributedEnforcer{}\n\n// IDistributedEnforcer defines dispatcher enforcer.\ntype IDistributedEnforcer interface {\n\tIEnforcer\n\tSetDispatcher(dispatcher persist.Dispatcher)\n\t/* Management API for DistributedEnforcer*/\n\tAddPoliciesSelf(shouldPersist func() bool, sec string, ptype string, rules [][]string) (affected [][]string, err error)\n\tRemovePoliciesSelf(shouldPersist func() bool, sec string, ptype string, rules [][]string) (affected [][]string, err error)\n\tRemoveFilteredPolicySelf(shouldPersist func() bool, sec string, ptype string, fieldIndex int, fieldValues ...string) (affected [][]string, err error)\n\tClearPolicySelf(shouldPersist func() bool) error\n\tUpdatePolicySelf(shouldPersist func() bool, sec string, ptype string, oldRule, newRule []string) (affected bool, err error)\n\tUpdatePoliciesSelf(shouldPersist func() bool, sec string, ptype string, oldRules, newRules [][]string) (affected bool, err error)\n\tUpdateFilteredPoliciesSelf(shouldPersist func() bool, sec string, ptype string, newRules [][]string, fieldIndex int, fieldValues ...string) (bool, error)\n}\n"
        },
        {
          "name": "enforcer_synced.go",
          "type": "blob",
          "size": 22.98046875,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/casbin/govaluate\"\n\n\t\"github.com/casbin/casbin/v2/persist\"\n)\n\n// SyncedEnforcer wraps Enforcer and provides synchronized access.\ntype SyncedEnforcer struct {\n\t*Enforcer\n\tm               sync.RWMutex\n\tstopAutoLoad    chan struct{}\n\tautoLoadRunning int32\n}\n\n// NewSyncedEnforcer creates a synchronized enforcer via file or DB.\nfunc NewSyncedEnforcer(params ...interface{}) (*SyncedEnforcer, error) {\n\te := &SyncedEnforcer{}\n\tvar err error\n\te.Enforcer, err = NewEnforcer(params...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\te.stopAutoLoad = make(chan struct{}, 1)\n\te.autoLoadRunning = 0\n\treturn e, nil\n}\n\n// GetLock return the private RWMutex lock.\nfunc (e *SyncedEnforcer) GetLock() *sync.RWMutex {\n\treturn &e.m\n}\n\n// IsAutoLoadingRunning check if SyncedEnforcer is auto loading policies.\nfunc (e *SyncedEnforcer) IsAutoLoadingRunning() bool {\n\treturn atomic.LoadInt32(&(e.autoLoadRunning)) != 0\n}\n\n// StartAutoLoadPolicy starts a go routine that will every specified duration call LoadPolicy.\nfunc (e *SyncedEnforcer) StartAutoLoadPolicy(d time.Duration) {\n\t// Don't start another goroutine if there is already one running\n\tif !atomic.CompareAndSwapInt32(&e.autoLoadRunning, 0, 1) {\n\t\treturn\n\t}\n\n\tticker := time.NewTicker(d)\n\tgo func() {\n\t\tdefer func() {\n\t\t\tticker.Stop()\n\t\t\tatomic.StoreInt32(&(e.autoLoadRunning), int32(0))\n\t\t}()\n\t\tn := 1\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\t// error intentionally ignored\n\t\t\t\t_ = e.LoadPolicy()\n\t\t\t\t// Uncomment this line to see when the policy is loaded.\n\t\t\t\t// log.Print(\"Load policy for time: \", n)\n\t\t\t\tn++\n\t\t\tcase <-e.stopAutoLoad:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n}\n\n// StopAutoLoadPolicy causes the go routine to exit.\nfunc (e *SyncedEnforcer) StopAutoLoadPolicy() {\n\tif e.IsAutoLoadingRunning() {\n\t\te.stopAutoLoad <- struct{}{}\n\t}\n}\n\n// SetWatcher sets the current watcher.\nfunc (e *SyncedEnforcer) SetWatcher(watcher persist.Watcher) error {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.SetWatcher(watcher)\n}\n\n// LoadModel reloads the model from the model CONF file.\nfunc (e *SyncedEnforcer) LoadModel() error {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.LoadModel()\n}\n\n// ClearPolicy clears all policy.\nfunc (e *SyncedEnforcer) ClearPolicy() {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\te.Enforcer.ClearPolicy()\n}\n\n// LoadPolicy reloads the policy from file/database.\nfunc (e *SyncedEnforcer) LoadPolicy() error {\n\te.m.RLock()\n\tnewModel, err := e.loadPolicyFromAdapter(e.model)\n\te.m.RUnlock()\n\tif err != nil {\n\t\treturn err\n\t}\n\te.m.Lock()\n\terr = e.applyModifiedModel(newModel)\n\te.m.Unlock()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// LoadFilteredPolicy reloads a filtered policy from file/database.\nfunc (e *SyncedEnforcer) LoadFilteredPolicy(filter interface{}) error {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.LoadFilteredPolicy(filter)\n}\n\n// LoadIncrementalFilteredPolicy reloads a filtered policy from file/database.\nfunc (e *SyncedEnforcer) LoadIncrementalFilteredPolicy(filter interface{}) error {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.LoadIncrementalFilteredPolicy(filter)\n}\n\n// SavePolicy saves the current policy (usually after changed with Casbin API) back to file/database.\nfunc (e *SyncedEnforcer) SavePolicy() error {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.SavePolicy()\n}\n\n// BuildRoleLinks manually rebuild the role inheritance relations.\nfunc (e *SyncedEnforcer) BuildRoleLinks() error {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.BuildRoleLinks()\n}\n\n// Enforce decides whether a \"subject\" can access a \"object\" with the operation \"action\", input parameters are usually: (sub, obj, act).\nfunc (e *SyncedEnforcer) Enforce(rvals ...interface{}) (bool, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.Enforce(rvals...)\n}\n\n// EnforceWithMatcher use a custom matcher to decides whether a \"subject\" can access a \"object\" with the operation \"action\", input parameters are usually: (matcher, sub, obj, act), use model matcher by default when matcher is \"\".\nfunc (e *SyncedEnforcer) EnforceWithMatcher(matcher string, rvals ...interface{}) (bool, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.EnforceWithMatcher(matcher, rvals...)\n}\n\n// EnforceEx explain enforcement by informing matched rules.\nfunc (e *SyncedEnforcer) EnforceEx(rvals ...interface{}) (bool, []string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.EnforceEx(rvals...)\n}\n\n// EnforceExWithMatcher use a custom matcher and explain enforcement by informing matched rules.\nfunc (e *SyncedEnforcer) EnforceExWithMatcher(matcher string, rvals ...interface{}) (bool, []string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.EnforceExWithMatcher(matcher, rvals...)\n}\n\n// BatchEnforce enforce in batches.\nfunc (e *SyncedEnforcer) BatchEnforce(requests [][]interface{}) ([]bool, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.BatchEnforce(requests)\n}\n\n// BatchEnforceWithMatcher enforce with matcher in batches.\nfunc (e *SyncedEnforcer) BatchEnforceWithMatcher(matcher string, requests [][]interface{}) ([]bool, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.BatchEnforceWithMatcher(matcher, requests)\n}\n\n// GetAllSubjects gets the list of subjects that show up in the current policy.\nfunc (e *SyncedEnforcer) GetAllSubjects() ([]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetAllSubjects()\n}\n\n// GetAllNamedSubjects gets the list of subjects that show up in the current named policy.\nfunc (e *SyncedEnforcer) GetAllNamedSubjects(ptype string) ([]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetAllNamedSubjects(ptype)\n}\n\n// GetAllObjects gets the list of objects that show up in the current policy.\nfunc (e *SyncedEnforcer) GetAllObjects() ([]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetAllObjects()\n}\n\n// GetAllNamedObjects gets the list of objects that show up in the current named policy.\nfunc (e *SyncedEnforcer) GetAllNamedObjects(ptype string) ([]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetAllNamedObjects(ptype)\n}\n\n// GetAllActions gets the list of actions that show up in the current policy.\nfunc (e *SyncedEnforcer) GetAllActions() ([]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetAllActions()\n}\n\n// GetAllNamedActions gets the list of actions that show up in the current named policy.\nfunc (e *SyncedEnforcer) GetAllNamedActions(ptype string) ([]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetAllNamedActions(ptype)\n}\n\n// GetAllRoles gets the list of roles that show up in the current policy.\nfunc (e *SyncedEnforcer) GetAllRoles() ([]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetAllRoles()\n}\n\n// GetAllNamedRoles gets the list of roles that show up in the current named policy.\nfunc (e *SyncedEnforcer) GetAllNamedRoles(ptype string) ([]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetAllNamedRoles(ptype)\n}\n\n// GetPolicy gets all the authorization rules in the policy.\nfunc (e *SyncedEnforcer) GetPolicy() ([][]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetPolicy()\n}\n\n// GetFilteredPolicy gets all the authorization rules in the policy, field filters can be specified.\nfunc (e *SyncedEnforcer) GetFilteredPolicy(fieldIndex int, fieldValues ...string) ([][]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetFilteredPolicy(fieldIndex, fieldValues...)\n}\n\n// GetNamedPolicy gets all the authorization rules in the named policy.\nfunc (e *SyncedEnforcer) GetNamedPolicy(ptype string) ([][]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetNamedPolicy(ptype)\n}\n\n// GetFilteredNamedPolicy gets all the authorization rules in the named policy, field filters can be specified.\nfunc (e *SyncedEnforcer) GetFilteredNamedPolicy(ptype string, fieldIndex int, fieldValues ...string) ([][]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetFilteredNamedPolicy(ptype, fieldIndex, fieldValues...)\n}\n\n// GetGroupingPolicy gets all the role inheritance rules in the policy.\nfunc (e *SyncedEnforcer) GetGroupingPolicy() ([][]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetGroupingPolicy()\n}\n\n// GetFilteredGroupingPolicy gets all the role inheritance rules in the policy, field filters can be specified.\nfunc (e *SyncedEnforcer) GetFilteredGroupingPolicy(fieldIndex int, fieldValues ...string) ([][]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetFilteredGroupingPolicy(fieldIndex, fieldValues...)\n}\n\n// GetNamedGroupingPolicy gets all the role inheritance rules in the policy.\nfunc (e *SyncedEnforcer) GetNamedGroupingPolicy(ptype string) ([][]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetNamedGroupingPolicy(ptype)\n}\n\n// GetFilteredNamedGroupingPolicy gets all the role inheritance rules in the policy, field filters can be specified.\nfunc (e *SyncedEnforcer) GetFilteredNamedGroupingPolicy(ptype string, fieldIndex int, fieldValues ...string) ([][]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetFilteredNamedGroupingPolicy(ptype, fieldIndex, fieldValues...)\n}\n\n// HasPolicy determines whether an authorization rule exists.\nfunc (e *SyncedEnforcer) HasPolicy(params ...interface{}) (bool, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.HasPolicy(params...)\n}\n\n// HasNamedPolicy determines whether a named authorization rule exists.\nfunc (e *SyncedEnforcer) HasNamedPolicy(ptype string, params ...interface{}) (bool, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.HasNamedPolicy(ptype, params...)\n}\n\n// AddPolicy adds an authorization rule to the current policy.\n// If the rule already exists, the function returns false and the rule will not be added.\n// Otherwise the function returns true by adding the new rule.\nfunc (e *SyncedEnforcer) AddPolicy(params ...interface{}) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddPolicy(params...)\n}\n\n// AddPolicies adds authorization rules to the current policy.\n// If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n// Otherwise the function returns true for the corresponding rule by adding the new rule.\nfunc (e *SyncedEnforcer) AddPolicies(rules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddPolicies(rules)\n}\n\n// AddPoliciesEx adds authorization rules to the current policy.\n// If the rule already exists, the rule will not be added.\n// But unlike AddPolicies, other non-existent rules are added instead of returning false directly.\nfunc (e *SyncedEnforcer) AddPoliciesEx(rules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddPoliciesEx(rules)\n}\n\n// AddNamedPolicy adds an authorization rule to the current named policy.\n// If the rule already exists, the function returns false and the rule will not be added.\n// Otherwise the function returns true by adding the new rule.\nfunc (e *SyncedEnforcer) AddNamedPolicy(ptype string, params ...interface{}) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddNamedPolicy(ptype, params...)\n}\n\n// AddNamedPolicies adds authorization rules to the current named policy.\n// If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n// Otherwise the function returns true for the corresponding by adding the new rule.\nfunc (e *SyncedEnforcer) AddNamedPolicies(ptype string, rules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddNamedPolicies(ptype, rules)\n}\n\n// AddNamedPoliciesEx adds authorization rules to the current named policy.\n// If the rule already exists, the rule will not be added.\n// But unlike AddNamedPolicies, other non-existent rules are added instead of returning false directly.\nfunc (e *SyncedEnforcer) AddNamedPoliciesEx(ptype string, rules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddNamedPoliciesEx(ptype, rules)\n}\n\n// RemovePolicy removes an authorization rule from the current policy.\nfunc (e *SyncedEnforcer) RemovePolicy(params ...interface{}) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.RemovePolicy(params...)\n}\n\n// UpdatePolicy updates an authorization rule from the current policy.\nfunc (e *SyncedEnforcer) UpdatePolicy(oldPolicy []string, newPolicy []string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.UpdatePolicy(oldPolicy, newPolicy)\n}\n\nfunc (e *SyncedEnforcer) UpdateNamedPolicy(ptype string, p1 []string, p2 []string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.UpdateNamedPolicy(ptype, p1, p2)\n}\n\n// UpdatePolicies updates authorization rules from the current policies.\nfunc (e *SyncedEnforcer) UpdatePolicies(oldPolices [][]string, newPolicies [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.UpdatePolicies(oldPolices, newPolicies)\n}\n\nfunc (e *SyncedEnforcer) UpdateNamedPolicies(ptype string, p1 [][]string, p2 [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.UpdateNamedPolicies(ptype, p1, p2)\n}\n\nfunc (e *SyncedEnforcer) UpdateFilteredPolicies(newPolicies [][]string, fieldIndex int, fieldValues ...string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.UpdateFilteredPolicies(newPolicies, fieldIndex, fieldValues...)\n}\n\nfunc (e *SyncedEnforcer) UpdateFilteredNamedPolicies(ptype string, newPolicies [][]string, fieldIndex int, fieldValues ...string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.UpdateFilteredNamedPolicies(ptype, newPolicies, fieldIndex, fieldValues...)\n}\n\n// RemovePolicies removes authorization rules from the current policy.\nfunc (e *SyncedEnforcer) RemovePolicies(rules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.RemovePolicies(rules)\n}\n\n// RemoveFilteredPolicy removes an authorization rule from the current policy, field filters can be specified.\nfunc (e *SyncedEnforcer) RemoveFilteredPolicy(fieldIndex int, fieldValues ...string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.RemoveFilteredPolicy(fieldIndex, fieldValues...)\n}\n\n// RemoveNamedPolicy removes an authorization rule from the current named policy.\nfunc (e *SyncedEnforcer) RemoveNamedPolicy(ptype string, params ...interface{}) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.RemoveNamedPolicy(ptype, params...)\n}\n\n// RemoveNamedPolicies removes authorization rules from the current named policy.\nfunc (e *SyncedEnforcer) RemoveNamedPolicies(ptype string, rules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.RemoveNamedPolicies(ptype, rules)\n}\n\n// RemoveFilteredNamedPolicy removes an authorization rule from the current named policy, field filters can be specified.\nfunc (e *SyncedEnforcer) RemoveFilteredNamedPolicy(ptype string, fieldIndex int, fieldValues ...string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.RemoveFilteredNamedPolicy(ptype, fieldIndex, fieldValues...)\n}\n\n// HasGroupingPolicy determines whether a role inheritance rule exists.\nfunc (e *SyncedEnforcer) HasGroupingPolicy(params ...interface{}) (bool, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.HasGroupingPolicy(params...)\n}\n\n// HasNamedGroupingPolicy determines whether a named role inheritance rule exists.\nfunc (e *SyncedEnforcer) HasNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.HasNamedGroupingPolicy(ptype, params...)\n}\n\n// AddGroupingPolicy adds a role inheritance rule to the current policy.\n// If the rule already exists, the function returns false and the rule will not be added.\n// Otherwise the function returns true by adding the new rule.\nfunc (e *SyncedEnforcer) AddGroupingPolicy(params ...interface{}) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddGroupingPolicy(params...)\n}\n\n// AddGroupingPolicies adds role inheritance rulea to the current policy.\n// If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n// Otherwise the function returns true for the corresponding policy rule by adding the new rule.\nfunc (e *SyncedEnforcer) AddGroupingPolicies(rules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddGroupingPolicies(rules)\n}\n\n// AddGroupingPoliciesEx adds role inheritance rules to the current policy.\n// If the rule already exists, the rule will not be added.\n// But unlike AddGroupingPolicies, other non-existent rules are added instead of returning false directly.\nfunc (e *SyncedEnforcer) AddGroupingPoliciesEx(rules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddGroupingPoliciesEx(rules)\n}\n\n// AddNamedGroupingPolicy adds a named role inheritance rule to the current policy.\n// If the rule already exists, the function returns false and the rule will not be added.\n// Otherwise the function returns true by adding the new rule.\nfunc (e *SyncedEnforcer) AddNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddNamedGroupingPolicy(ptype, params...)\n}\n\n// AddNamedGroupingPolicies adds named role inheritance rules to the current policy.\n// If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n// Otherwise the function returns true for the corresponding policy rule by adding the new rule.\nfunc (e *SyncedEnforcer) AddNamedGroupingPolicies(ptype string, rules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddNamedGroupingPolicies(ptype, rules)\n}\n\n// AddNamedGroupingPoliciesEx adds named role inheritance rules to the current policy.\n// If the rule already exists, the rule will not be added.\n// But unlike AddNamedGroupingPolicies, other non-existent rules are added instead of returning false directly.\nfunc (e *SyncedEnforcer) AddNamedGroupingPoliciesEx(ptype string, rules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddNamedGroupingPoliciesEx(ptype, rules)\n}\n\n// RemoveGroupingPolicy removes a role inheritance rule from the current policy.\nfunc (e *SyncedEnforcer) RemoveGroupingPolicy(params ...interface{}) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.RemoveGroupingPolicy(params...)\n}\n\n// RemoveGroupingPolicies removes role inheritance rules from the current policy.\nfunc (e *SyncedEnforcer) RemoveGroupingPolicies(rules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.RemoveGroupingPolicies(rules)\n}\n\n// RemoveFilteredGroupingPolicy removes a role inheritance rule from the current policy, field filters can be specified.\nfunc (e *SyncedEnforcer) RemoveFilteredGroupingPolicy(fieldIndex int, fieldValues ...string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.RemoveFilteredGroupingPolicy(fieldIndex, fieldValues...)\n}\n\n// RemoveNamedGroupingPolicy removes a role inheritance rule from the current named policy.\nfunc (e *SyncedEnforcer) RemoveNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.RemoveNamedGroupingPolicy(ptype, params...)\n}\n\n// RemoveNamedGroupingPolicies removes role inheritance rules from the current named policy.\nfunc (e *SyncedEnforcer) RemoveNamedGroupingPolicies(ptype string, rules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.RemoveNamedGroupingPolicies(ptype, rules)\n}\n\nfunc (e *SyncedEnforcer) UpdateGroupingPolicy(oldRule []string, newRule []string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.UpdateGroupingPolicy(oldRule, newRule)\n}\n\nfunc (e *SyncedEnforcer) UpdateGroupingPolicies(oldRules [][]string, newRules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.UpdateGroupingPolicies(oldRules, newRules)\n}\n\nfunc (e *SyncedEnforcer) UpdateNamedGroupingPolicy(ptype string, oldRule []string, newRule []string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.UpdateNamedGroupingPolicy(ptype, oldRule, newRule)\n}\n\nfunc (e *SyncedEnforcer) UpdateNamedGroupingPolicies(ptype string, oldRules [][]string, newRules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.UpdateNamedGroupingPolicies(ptype, oldRules, newRules)\n}\n\n// RemoveFilteredNamedGroupingPolicy removes a role inheritance rule from the current named policy, field filters can be specified.\nfunc (e *SyncedEnforcer) RemoveFilteredNamedGroupingPolicy(ptype string, fieldIndex int, fieldValues ...string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.RemoveFilteredNamedGroupingPolicy(ptype, fieldIndex, fieldValues...)\n}\n\n// AddFunction adds a customized function.\nfunc (e *SyncedEnforcer) AddFunction(name string, function govaluate.ExpressionFunction) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\te.Enforcer.AddFunction(name, function)\n}\n\nfunc (e *SyncedEnforcer) SelfAddPolicy(sec string, ptype string, rule []string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.SelfAddPolicy(sec, ptype, rule)\n}\n\nfunc (e *SyncedEnforcer) SelfAddPolicies(sec string, ptype string, rules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.SelfAddPolicies(sec, ptype, rules)\n}\n\nfunc (e *SyncedEnforcer) SelfAddPoliciesEx(sec string, ptype string, rules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.SelfAddPoliciesEx(sec, ptype, rules)\n}\n\nfunc (e *SyncedEnforcer) SelfRemovePolicy(sec string, ptype string, rule []string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.SelfRemovePolicy(sec, ptype, rule)\n}\n\nfunc (e *SyncedEnforcer) SelfRemovePolicies(sec string, ptype string, rules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.SelfRemovePolicies(sec, ptype, rules)\n}\n\nfunc (e *SyncedEnforcer) SelfRemoveFilteredPolicy(sec string, ptype string, fieldIndex int, fieldValues ...string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.SelfRemoveFilteredPolicy(sec, ptype, fieldIndex, fieldValues...)\n}\n\nfunc (e *SyncedEnforcer) SelfUpdatePolicy(sec string, ptype string, oldRule, newRule []string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.SelfUpdatePolicy(sec, ptype, oldRule, newRule)\n}\n\nfunc (e *SyncedEnforcer) SelfUpdatePolicies(sec string, ptype string, oldRules, newRules [][]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.SelfUpdatePolicies(sec, ptype, oldRules, newRules)\n}\n"
        },
        {
          "name": "enforcer_synced_test.go",
          "type": "blob",
          "size": 20.703125,
          "content": "// Copyright 2018 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/casbin/casbin/v2/errors\"\n\t\"github.com/casbin/casbin/v2/util\"\n)\n\nfunc testEnforceSync(t *testing.T, e *SyncedEnforcer, sub string, obj interface{}, act string, res bool) {\n\tt.Helper()\n\tif myRes, _ := e.Enforce(sub, obj, act); myRes != res {\n\t\tt.Errorf(\"%s, %v, %s: %t, supposed to be %t\", sub, obj, act, myRes, res)\n\t}\n}\n\nfunc TestSync(t *testing.T) {\n\te, _ := NewSyncedEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\t// Start reloading the policy every 200 ms.\n\te.StartAutoLoadPolicy(time.Millisecond * 200)\n\n\ttestEnforceSync(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforceSync(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforceSync(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforceSync(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforceSync(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforceSync(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforceSync(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforceSync(t, e, \"bob\", \"data2\", \"write\", true)\n\n\t// Simulate a policy change\n\te.ClearPolicy()\n\ttestEnforceSync(t, e, \"bob\", \"data2\", \"write\", false)\n\n\t// Wait for at least one sync\n\ttime.Sleep(time.Millisecond * 300)\n\n\ttestEnforceSync(t, e, \"bob\", \"data2\", \"write\", true)\n\n\t// Stop the reloading policy periodically.\n\te.StopAutoLoadPolicy()\n}\n\nfunc TestStopAutoLoadPolicy(t *testing.T) {\n\te, _ := NewSyncedEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\te.StartAutoLoadPolicy(5 * time.Millisecond)\n\tif !e.IsAutoLoadingRunning() {\n\t\tt.Error(\"auto load is not running\")\n\t}\n\te.StopAutoLoadPolicy()\n\t// Need a moment, to exit goroutine\n\ttime.Sleep(10 * time.Millisecond)\n\tif e.IsAutoLoadingRunning() {\n\t\tt.Error(\"auto load is still running\")\n\t}\n}\n\nfunc testSyncedEnforcerGetPolicy(t *testing.T, e *SyncedEnforcer, res [][]string) {\n\tt.Helper()\n\tmyRes, err := e.GetPolicy()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif !util.SortedArray2DEquals(res, myRes) {\n\t\tt.Error(\"Policy: \", myRes, \", supposed to be \", res)\n\t} else {\n\t\tt.Log(\"Policy: \", myRes)\n\t}\n}\n\nfunc TestSyncedEnforcerSelfAddPolicy(t *testing.T) {\n\tfor i := 0; i < 10; i++ {\n\t\te, _ := NewSyncedEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user1\", \"data1\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user2\", \"data2\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user3\", \"data3\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user4\", \"data4\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user5\", \"data5\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user6\", \"data6\", \"read\"}) }()\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\ttestSyncedEnforcerGetPolicy(t, e, [][]string{\n\t\t\t{\"alice\", \"data1\", \"read\"},\n\t\t\t{\"bob\", \"data2\", \"write\"},\n\t\t\t{\"user1\", \"data1\", \"read\"},\n\t\t\t{\"user2\", \"data2\", \"read\"},\n\t\t\t{\"user3\", \"data3\", \"read\"},\n\t\t\t{\"user4\", \"data4\", \"read\"},\n\t\t\t{\"user5\", \"data5\", \"read\"},\n\t\t\t{\"user6\", \"data6\", \"read\"},\n\t\t})\n\t}\n}\n\nfunc TestSyncedEnforcerSelfAddPolicies(t *testing.T) {\n\tfor i := 0; i < 10; i++ {\n\t\te, _ := NewSyncedEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\t\tgo func() {\n\t\t\t_, _ = e.SelfAddPolicies(\"p\", \"p\", [][]string{{\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.SelfAddPolicies(\"p\", \"p\", [][]string{{\"user3\", \"data3\", \"read\"}, {\"user4\", \"data4\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.SelfAddPolicies(\"p\", \"p\", [][]string{{\"user5\", \"data5\", \"read\"}, {\"user6\", \"data6\", \"read\"}})\n\t\t}()\n\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\ttestSyncedEnforcerGetPolicy(t, e, [][]string{\n\t\t\t{\"alice\", \"data1\", \"read\"},\n\t\t\t{\"bob\", \"data2\", \"write\"},\n\t\t\t{\"user1\", \"data1\", \"read\"},\n\t\t\t{\"user2\", \"data2\", \"read\"},\n\t\t\t{\"user3\", \"data3\", \"read\"},\n\t\t\t{\"user4\", \"data4\", \"read\"},\n\t\t\t{\"user5\", \"data5\", \"read\"},\n\t\t\t{\"user6\", \"data6\", \"read\"},\n\t\t})\n\t}\n}\n\nfunc TestSyncedEnforcerSelfAddPoliciesEx(t *testing.T) {\n\tfor i := 0; i < 10; i++ {\n\t\te, _ := NewSyncedEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\t\tgo func() {\n\t\t\t_, _ = e.SelfAddPoliciesEx(\"p\", \"p\", [][]string{{\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.SelfAddPoliciesEx(\"p\", \"p\", [][]string{{\"user2\", \"data2\", \"read\"}, {\"user3\", \"data3\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.SelfAddPoliciesEx(\"p\", \"p\", [][]string{{\"user3\", \"data3\", \"read\"}, {\"user4\", \"data4\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.SelfAddPoliciesEx(\"p\", \"p\", [][]string{{\"user4\", \"data4\", \"read\"}, {\"user5\", \"data5\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.SelfAddPoliciesEx(\"p\", \"p\", [][]string{{\"user5\", \"data5\", \"read\"}, {\"user6\", \"data6\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.SelfAddPoliciesEx(\"p\", \"p\", [][]string{{\"user6\", \"data6\", \"read\"}, {\"user1\", \"data1\", \"read\"}})\n\t\t}()\n\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\ttestSyncedEnforcerGetPolicy(t, e, [][]string{\n\t\t\t{\"alice\", \"data1\", \"read\"},\n\t\t\t{\"bob\", \"data2\", \"write\"},\n\t\t\t{\"user1\", \"data1\", \"read\"},\n\t\t\t{\"user2\", \"data2\", \"read\"},\n\t\t\t{\"user3\", \"data3\", \"read\"},\n\t\t\t{\"user4\", \"data4\", \"read\"},\n\t\t\t{\"user5\", \"data5\", \"read\"},\n\t\t\t{\"user6\", \"data6\", \"read\"},\n\t\t})\n\t}\n}\n\nfunc TestSyncedEnforcerSelfRemovePolicy(t *testing.T) {\n\tfor i := 0; i < 10; i++ {\n\t\te, _ := NewSyncedEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user1\", \"data1\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user2\", \"data2\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user3\", \"data3\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user4\", \"data4\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user5\", \"data5\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user6\", \"data6\", \"read\"}) }()\n\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\ttestSyncedEnforcerGetPolicy(t, e, [][]string{\n\t\t\t{\"alice\", \"data1\", \"read\"},\n\t\t\t{\"bob\", \"data2\", \"write\"},\n\t\t\t{\"user1\", \"data1\", \"read\"},\n\t\t\t{\"user2\", \"data2\", \"read\"},\n\t\t\t{\"user3\", \"data3\", \"read\"},\n\t\t\t{\"user4\", \"data4\", \"read\"},\n\t\t\t{\"user5\", \"data5\", \"read\"},\n\t\t\t{\"user6\", \"data6\", \"read\"},\n\t\t})\n\n\t\tgo func() { _, _ = e.SelfRemovePolicy(\"p\", \"p\", []string{\"user1\", \"data1\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfRemovePolicy(\"p\", \"p\", []string{\"user2\", \"data2\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfRemovePolicy(\"p\", \"p\", []string{\"user3\", \"data3\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfRemovePolicy(\"p\", \"p\", []string{\"user4\", \"data4\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfRemovePolicy(\"p\", \"p\", []string{\"user5\", \"data5\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfRemovePolicy(\"p\", \"p\", []string{\"user6\", \"data6\", \"read\"}) }()\n\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\ttestSyncedEnforcerGetPolicy(t, e, [][]string{\n\t\t\t{\"alice\", \"data1\", \"read\"},\n\t\t\t{\"bob\", \"data2\", \"write\"},\n\t\t})\n\t}\n}\n\nfunc TestSyncedEnforcerSelfRemovePolicies(t *testing.T) {\n\tfor i := 0; i < 10; i++ {\n\t\te, _ := NewSyncedEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user1\", \"data1\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user2\", \"data2\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user3\", \"data3\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user4\", \"data4\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user5\", \"data5\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user6\", \"data6\", \"read\"}) }()\n\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\ttestSyncedEnforcerGetPolicy(t, e, [][]string{\n\t\t\t{\"alice\", \"data1\", \"read\"},\n\t\t\t{\"bob\", \"data2\", \"write\"},\n\t\t\t{\"user1\", \"data1\", \"read\"},\n\t\t\t{\"user2\", \"data2\", \"read\"},\n\t\t\t{\"user3\", \"data3\", \"read\"},\n\t\t\t{\"user4\", \"data4\", \"read\"},\n\t\t\t{\"user5\", \"data5\", \"read\"},\n\t\t\t{\"user6\", \"data6\", \"read\"},\n\t\t})\n\n\t\tgo func() {\n\t\t\t_, _ = e.SelfRemovePolicies(\"p\", \"p\", [][]string{{\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.SelfRemovePolicies(\"p\", \"p\", [][]string{{\"user3\", \"data3\", \"read\"}, {\"user4\", \"data4\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.SelfRemovePolicies(\"p\", \"p\", [][]string{{\"user5\", \"data5\", \"read\"}, {\"user6\", \"data6\", \"read\"}})\n\t\t}()\n\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\ttestSyncedEnforcerGetPolicy(t, e, [][]string{\n\t\t\t{\"alice\", \"data1\", \"read\"},\n\t\t\t{\"bob\", \"data2\", \"write\"},\n\t\t})\n\t}\n}\n\nfunc TestSyncedEnforcerSelfRemoveFilteredPolicy(t *testing.T) {\n\tfor i := 0; i < 10; i++ {\n\t\te, _ := NewSyncedEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user1\", \"data1\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user2\", \"data2\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user3\", \"data3\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user4\", \"data4\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user5\", \"data5\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user6\", \"data6\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user7\", \"data7\", \"write\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user8\", \"data8\", \"write\"}) }()\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\ttestSyncedEnforcerGetPolicy(t, e, [][]string{\n\t\t\t{\"alice\", \"data1\", \"read\"},\n\t\t\t{\"bob\", \"data2\", \"write\"},\n\t\t\t{\"user1\", \"data1\", \"read\"},\n\t\t\t{\"user2\", \"data2\", \"read\"},\n\t\t\t{\"user3\", \"data3\", \"read\"},\n\t\t\t{\"user4\", \"data4\", \"read\"},\n\t\t\t{\"user5\", \"data5\", \"read\"},\n\t\t\t{\"user6\", \"data6\", \"read\"},\n\t\t\t{\"user7\", \"data7\", \"write\"},\n\t\t\t{\"user8\", \"data8\", \"write\"},\n\t\t})\n\n\t\tgo func() { _, _ = e.SelfRemoveFilteredPolicy(\"p\", \"p\", 0, \"user1\") }()\n\t\tgo func() { _, _ = e.SelfRemoveFilteredPolicy(\"p\", \"p\", 0, \"user2\") }()\n\t\tgo func() { _, _ = e.SelfRemoveFilteredPolicy(\"p\", \"p\", 1, \"data3\") }()\n\t\tgo func() { _, _ = e.SelfRemoveFilteredPolicy(\"p\", \"p\", 1, \"data4\") }()\n\t\tgo func() { _, _ = e.SelfRemoveFilteredPolicy(\"p\", \"p\", 0, \"user5\") }()\n\t\tgo func() { _, _ = e.SelfRemoveFilteredPolicy(\"p\", \"p\", 0, \"user6\") }()\n\t\tgo func() { _, _ = e.SelfRemoveFilteredPolicy(\"p\", \"p\", 2, \"write\") }()\n\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\ttestSyncedEnforcerGetPolicy(t, e, [][]string{\n\t\t\t{\"alice\", \"data1\", \"read\"},\n\t\t})\n\t}\n}\n\nfunc TestSyncedEnforcerSelfUpdatePolicy(t *testing.T) {\n\tfor i := 0; i < 10; i++ {\n\t\te, _ := NewSyncedEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user1\", \"data1\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user2\", \"data2\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user3\", \"data3\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user4\", \"data4\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user5\", \"data5\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user6\", \"data6\", \"read\"}) }()\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\ttestSyncedEnforcerGetPolicy(t, e, [][]string{\n\t\t\t{\"alice\", \"data1\", \"read\"},\n\t\t\t{\"bob\", \"data2\", \"write\"},\n\t\t\t{\"user1\", \"data1\", \"read\"},\n\t\t\t{\"user2\", \"data2\", \"read\"},\n\t\t\t{\"user3\", \"data3\", \"read\"},\n\t\t\t{\"user4\", \"data4\", \"read\"},\n\t\t\t{\"user5\", \"data5\", \"read\"},\n\t\t\t{\"user6\", \"data6\", \"read\"},\n\t\t})\n\n\t\tgo func() {\n\t\t\t_, _ = e.SelfUpdatePolicy(\"p\", \"p\", []string{\"user1\", \"data1\", \"read\"}, []string{\"user1\", \"data1\", \"write\"})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.SelfUpdatePolicy(\"p\", \"p\", []string{\"user2\", \"data2\", \"read\"}, []string{\"user2\", \"data2\", \"write\"})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.SelfUpdatePolicy(\"p\", \"p\", []string{\"user3\", \"data3\", \"read\"}, []string{\"user3\", \"data3\", \"write\"})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.SelfUpdatePolicy(\"p\", \"p\", []string{\"user4\", \"data4\", \"read\"}, []string{\"user4\", \"data4\", \"write\"})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.SelfUpdatePolicy(\"p\", \"p\", []string{\"user5\", \"data5\", \"read\"}, []string{\"user5\", \"data5\", \"write\"})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.SelfUpdatePolicy(\"p\", \"p\", []string{\"user6\", \"data6\", \"read\"}, []string{\"user6\", \"data6\", \"write\"})\n\t\t}()\n\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\ttestSyncedEnforcerGetPolicy(t, e, [][]string{\n\t\t\t{\"alice\", \"data1\", \"read\"},\n\t\t\t{\"bob\", \"data2\", \"write\"},\n\t\t\t{\"user1\", \"data1\", \"write\"},\n\t\t\t{\"user2\", \"data2\", \"write\"},\n\t\t\t{\"user3\", \"data3\", \"write\"},\n\t\t\t{\"user4\", \"data4\", \"write\"},\n\t\t\t{\"user5\", \"data5\", \"write\"},\n\t\t\t{\"user6\", \"data6\", \"write\"},\n\t\t})\n\t}\n}\n\nfunc TestSyncedEnforcerSelfUpdatePolicies(t *testing.T) {\n\tfor i := 0; i < 10; i++ {\n\t\te, _ := NewSyncedEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user1\", \"data1\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user2\", \"data2\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user3\", \"data3\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user4\", \"data4\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user5\", \"data5\", \"read\"}) }()\n\t\tgo func() { _, _ = e.SelfAddPolicy(\"p\", \"p\", []string{\"user6\", \"data6\", \"read\"}) }()\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\ttestSyncedEnforcerGetPolicy(t, e, [][]string{\n\t\t\t{\"alice\", \"data1\", \"read\"},\n\t\t\t{\"bob\", \"data2\", \"write\"},\n\t\t\t{\"user1\", \"data1\", \"read\"},\n\t\t\t{\"user2\", \"data2\", \"read\"},\n\t\t\t{\"user3\", \"data3\", \"read\"},\n\t\t\t{\"user4\", \"data4\", \"read\"},\n\t\t\t{\"user5\", \"data5\", \"read\"},\n\t\t\t{\"user6\", \"data6\", \"read\"},\n\t\t})\n\n\t\tgo func() {\n\t\t\t_, _ = e.SelfUpdatePolicies(\"p\", \"p\",\n\t\t\t\t[][]string{{\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"}},\n\t\t\t\t[][]string{{\"user1\", \"data1\", \"write\"}, {\"user2\", \"data2\", \"write\"}})\n\t\t}()\n\n\t\tgo func() {\n\t\t\t_, _ = e.SelfUpdatePolicies(\"p\", \"p\",\n\t\t\t\t[][]string{{\"user3\", \"data3\", \"read\"}, {\"user4\", \"data4\", \"read\"}},\n\t\t\t\t[][]string{{\"user3\", \"data3\", \"write\"}, {\"user4\", \"data4\", \"write\"}})\n\t\t}()\n\n\t\tgo func() {\n\t\t\t_, _ = e.SelfUpdatePolicies(\"p\", \"p\",\n\t\t\t\t[][]string{{\"user5\", \"data5\", \"read\"}, {\"user6\", \"data6\", \"read\"}},\n\t\t\t\t[][]string{{\"user5\", \"data5\", \"write\"}, {\"user6\", \"data6\", \"write\"}})\n\t\t}()\n\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\ttestSyncedEnforcerGetPolicy(t, e, [][]string{\n\t\t\t{\"alice\", \"data1\", \"read\"},\n\t\t\t{\"bob\", \"data2\", \"write\"},\n\t\t\t{\"user1\", \"data1\", \"write\"},\n\t\t\t{\"user2\", \"data2\", \"write\"},\n\t\t\t{\"user3\", \"data3\", \"write\"},\n\t\t\t{\"user4\", \"data4\", \"write\"},\n\t\t\t{\"user5\", \"data5\", \"write\"},\n\t\t\t{\"user6\", \"data6\", \"write\"},\n\t\t})\n\t}\n}\n\nfunc TestSyncedEnforcerAddPoliciesEx(t *testing.T) {\n\tfor i := 0; i < 10; i++ {\n\t\te, _ := NewSyncedEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\t\tgo func() { _, _ = e.AddPoliciesEx([][]string{{\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"}}) }()\n\t\tgo func() { _, _ = e.AddPoliciesEx([][]string{{\"user2\", \"data2\", \"read\"}, {\"user3\", \"data3\", \"read\"}}) }()\n\t\tgo func() { _, _ = e.AddPoliciesEx([][]string{{\"user4\", \"data4\", \"read\"}, {\"user5\", \"data5\", \"read\"}}) }()\n\t\tgo func() { _, _ = e.AddPoliciesEx([][]string{{\"user5\", \"data5\", \"read\"}, {\"user6\", \"data6\", \"read\"}}) }()\n\t\tgo func() { _, _ = e.AddPoliciesEx([][]string{{\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"}}) }()\n\t\tgo func() { _, _ = e.AddPoliciesEx([][]string{{\"user2\", \"data2\", \"read\"}, {\"user3\", \"data3\", \"read\"}}) }()\n\t\tgo func() { _, _ = e.AddPoliciesEx([][]string{{\"user4\", \"data4\", \"read\"}, {\"user5\", \"data5\", \"read\"}}) }()\n\t\tgo func() { _, _ = e.AddPoliciesEx([][]string{{\"user5\", \"data5\", \"read\"}, {\"user6\", \"data6\", \"read\"}}) }()\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\ttestSyncedEnforcerGetPolicy(t, e, [][]string{\n\t\t\t{\"alice\", \"data1\", \"read\"},\n\t\t\t{\"bob\", \"data2\", \"write\"},\n\t\t\t{\"user1\", \"data1\", \"read\"},\n\t\t\t{\"user2\", \"data2\", \"read\"},\n\t\t\t{\"user3\", \"data3\", \"read\"},\n\t\t\t{\"user4\", \"data4\", \"read\"},\n\t\t\t{\"user5\", \"data5\", \"read\"},\n\t\t\t{\"user6\", \"data6\", \"read\"},\n\t\t})\n\t}\n}\n\nfunc TestSyncedEnforcerAddNamedPoliciesEx(t *testing.T) {\n\tfor i := 0; i < 10; i++ {\n\t\te, _ := NewSyncedEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\t\tgo func() {\n\t\t\t_, _ = e.AddNamedPoliciesEx(\"p\", [][]string{{\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.AddNamedPoliciesEx(\"p\", [][]string{{\"user2\", \"data2\", \"read\"}, {\"user3\", \"data3\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.AddNamedPoliciesEx(\"p\", [][]string{{\"user4\", \"data4\", \"read\"}, {\"user5\", \"data5\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.AddNamedPoliciesEx(\"p\", [][]string{{\"user5\", \"data5\", \"read\"}, {\"user6\", \"data6\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.AddNamedPoliciesEx(\"p\", [][]string{{\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.AddNamedPoliciesEx(\"p\", [][]string{{\"user2\", \"data2\", \"read\"}, {\"user3\", \"data3\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.AddNamedPoliciesEx(\"p\", [][]string{{\"user4\", \"data4\", \"read\"}, {\"user5\", \"data5\", \"read\"}})\n\t\t}()\n\t\tgo func() {\n\t\t\t_, _ = e.AddNamedPoliciesEx(\"p\", [][]string{{\"user5\", \"data5\", \"read\"}, {\"user6\", \"data6\", \"read\"}})\n\t\t}()\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\ttestSyncedEnforcerGetPolicy(t, e, [][]string{\n\t\t\t{\"alice\", \"data1\", \"read\"},\n\t\t\t{\"bob\", \"data2\", \"write\"},\n\t\t\t{\"user1\", \"data1\", \"read\"},\n\t\t\t{\"user2\", \"data2\", \"read\"},\n\t\t\t{\"user3\", \"data3\", \"read\"},\n\t\t\t{\"user4\", \"data4\", \"read\"},\n\t\t\t{\"user5\", \"data5\", \"read\"},\n\t\t\t{\"user6\", \"data6\", \"read\"},\n\t\t})\n\t}\n}\n\nfunc testSyncedEnforcerGetUsers(t *testing.T, e *SyncedEnforcer, res []string, name string, domain ...string) {\n\tt.Helper()\n\tmyRes, err := e.GetUsersForRole(name, domain...)\n\tmyResCopy := make([]string, len(myRes))\n\tcopy(myResCopy, myRes)\n\tsort.Strings(myRes)\n\tsort.Strings(res)\n\tswitch err {\n\tcase nil:\n\t\tbreak\n\tcase errors.ErrNameNotFound:\n\t\tt.Log(\"No name found\")\n\tdefault:\n\t\tt.Error(\"Users for \", name, \" could not be fetched: \", err.Error())\n\t}\n\tt.Log(\"Users for \", name, \": \", myRes)\n\n\tif !util.SetEquals(res, myRes) {\n\t\tt.Error(\"Users for \", name, \": \", myRes, \", supposed to be \", res)\n\t}\n}\nfunc TestSyncedEnforcerAddGroupingPoliciesEx(t *testing.T) {\n\tfor i := 0; i < 10; i++ {\n\t\te, _ := NewSyncedEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\t\te.ClearPolicy()\n\n\t\tgo func() { _, _ = e.AddGroupingPoliciesEx([][]string{{\"user1\", \"member\"}, {\"user2\", \"member\"}}) }()\n\t\tgo func() { _, _ = e.AddGroupingPoliciesEx([][]string{{\"user2\", \"member\"}, {\"user3\", \"member\"}}) }()\n\t\tgo func() { _, _ = e.AddGroupingPoliciesEx([][]string{{\"user4\", \"member\"}, {\"user5\", \"member\"}}) }()\n\t\tgo func() { _, _ = e.AddGroupingPoliciesEx([][]string{{\"user5\", \"member\"}, {\"user6\", \"member\"}}) }()\n\t\tgo func() { _, _ = e.AddGroupingPoliciesEx([][]string{{\"user1\", \"member\"}, {\"user2\", \"member\"}}) }()\n\t\tgo func() { _, _ = e.AddGroupingPoliciesEx([][]string{{\"user2\", \"member\"}, {\"user3\", \"member\"}}) }()\n\t\tgo func() { _, _ = e.AddGroupingPoliciesEx([][]string{{\"user4\", \"member\"}, {\"user5\", \"member\"}}) }()\n\t\tgo func() { _, _ = e.AddGroupingPoliciesEx([][]string{{\"user5\", \"member\"}, {\"user6\", \"member\"}}) }()\n\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\ttestSyncedEnforcerGetUsers(t, e, []string{\"user1\", \"user2\", \"user3\", \"user4\", \"user5\", \"user6\"}, \"member\")\n\t}\n}\n\nfunc TestSyncedEnforcerAddNamedGroupingPoliciesEx(t *testing.T) {\n\tfor i := 0; i < 10; i++ {\n\t\te, _ := NewSyncedEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\t\te.ClearPolicy()\n\n\t\tgo func() { _, _ = e.AddNamedGroupingPoliciesEx(\"g\", [][]string{{\"user1\", \"member\"}, {\"user2\", \"member\"}}) }()\n\t\tgo func() { _, _ = e.AddNamedGroupingPoliciesEx(\"g\", [][]string{{\"user2\", \"member\"}, {\"user3\", \"member\"}}) }()\n\t\tgo func() { _, _ = e.AddNamedGroupingPoliciesEx(\"g\", [][]string{{\"user4\", \"member\"}, {\"user5\", \"member\"}}) }()\n\t\tgo func() { _, _ = e.AddNamedGroupingPoliciesEx(\"g\", [][]string{{\"user5\", \"member\"}, {\"user6\", \"member\"}}) }()\n\t\tgo func() { _, _ = e.AddNamedGroupingPoliciesEx(\"g\", [][]string{{\"user1\", \"member\"}, {\"user2\", \"member\"}}) }()\n\t\tgo func() { _, _ = e.AddNamedGroupingPoliciesEx(\"g\", [][]string{{\"user2\", \"member\"}, {\"user3\", \"member\"}}) }()\n\t\tgo func() { _, _ = e.AddNamedGroupingPoliciesEx(\"g\", [][]string{{\"user4\", \"member\"}, {\"user5\", \"member\"}}) }()\n\t\tgo func() { _, _ = e.AddNamedGroupingPoliciesEx(\"g\", [][]string{{\"user5\", \"member\"}, {\"user6\", \"member\"}}) }()\n\n\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\ttestSyncedEnforcerGetUsers(t, e, []string{\"user1\", \"user2\", \"user3\", \"user4\", \"user5\", \"user6\"}, \"member\")\n\t}\n}\n"
        },
        {
          "name": "enforcer_test.go",
          "type": "blob",
          "size": 27.3505859375,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/casbin/casbin/v2/model\"\n\tfileadapter \"github.com/casbin/casbin/v2/persist/file-adapter\"\n\t\"github.com/casbin/casbin/v2/util\"\n)\n\nfunc TestKeyMatchModelInMemory(t *testing.T) {\n\tm := model.NewModel()\n\tm.AddDef(\"r\", \"r\", \"sub, obj, act\")\n\tm.AddDef(\"p\", \"p\", \"sub, obj, act\")\n\tm.AddDef(\"e\", \"e\", \"some(where (p.eft == allow))\")\n\tm.AddDef(\"m\", \"m\", \"r.sub == p.sub && keyMatch(r.obj, p.obj) && regexMatch(r.act, p.act)\")\n\n\ta := fileadapter.NewAdapter(\"examples/keymatch_policy.csv\")\n\n\te, _ := NewEnforcer(m, a)\n\n\ttestEnforce(t, e, \"alice\", \"/alice_data/resource1\", \"GET\", true)\n\ttestEnforce(t, e, \"alice\", \"/alice_data/resource1\", \"POST\", true)\n\ttestEnforce(t, e, \"alice\", \"/alice_data/resource2\", \"GET\", true)\n\ttestEnforce(t, e, \"alice\", \"/alice_data/resource2\", \"POST\", false)\n\ttestEnforce(t, e, \"alice\", \"/bob_data/resource1\", \"GET\", false)\n\ttestEnforce(t, e, \"alice\", \"/bob_data/resource1\", \"POST\", false)\n\ttestEnforce(t, e, \"alice\", \"/bob_data/resource2\", \"GET\", false)\n\ttestEnforce(t, e, \"alice\", \"/bob_data/resource2\", \"POST\", false)\n\n\ttestEnforce(t, e, \"bob\", \"/alice_data/resource1\", \"GET\", false)\n\ttestEnforce(t, e, \"bob\", \"/alice_data/resource1\", \"POST\", false)\n\ttestEnforce(t, e, \"bob\", \"/alice_data/resource2\", \"GET\", true)\n\ttestEnforce(t, e, \"bob\", \"/alice_data/resource2\", \"POST\", false)\n\ttestEnforce(t, e, \"bob\", \"/bob_data/resource1\", \"GET\", false)\n\ttestEnforce(t, e, \"bob\", \"/bob_data/resource1\", \"POST\", true)\n\ttestEnforce(t, e, \"bob\", \"/bob_data/resource2\", \"GET\", false)\n\ttestEnforce(t, e, \"bob\", \"/bob_data/resource2\", \"POST\", true)\n\n\ttestEnforce(t, e, \"cathy\", \"/cathy_data\", \"GET\", true)\n\ttestEnforce(t, e, \"cathy\", \"/cathy_data\", \"POST\", true)\n\ttestEnforce(t, e, \"cathy\", \"/cathy_data\", \"DELETE\", false)\n\n\te, _ = NewEnforcer(m)\n\t_ = a.LoadPolicy(e.GetModel())\n\n\ttestEnforce(t, e, \"alice\", \"/alice_data/resource1\", \"GET\", true)\n\ttestEnforce(t, e, \"alice\", \"/alice_data/resource1\", \"POST\", true)\n\ttestEnforce(t, e, \"alice\", \"/alice_data/resource2\", \"GET\", true)\n\ttestEnforce(t, e, \"alice\", \"/alice_data/resource2\", \"POST\", false)\n\ttestEnforce(t, e, \"alice\", \"/bob_data/resource1\", \"GET\", false)\n\ttestEnforce(t, e, \"alice\", \"/bob_data/resource1\", \"POST\", false)\n\ttestEnforce(t, e, \"alice\", \"/bob_data/resource2\", \"GET\", false)\n\ttestEnforce(t, e, \"alice\", \"/bob_data/resource2\", \"POST\", false)\n\n\ttestEnforce(t, e, \"bob\", \"/alice_data/resource1\", \"GET\", false)\n\ttestEnforce(t, e, \"bob\", \"/alice_data/resource1\", \"POST\", false)\n\ttestEnforce(t, e, \"bob\", \"/alice_data/resource2\", \"GET\", true)\n\ttestEnforce(t, e, \"bob\", \"/alice_data/resource2\", \"POST\", false)\n\ttestEnforce(t, e, \"bob\", \"/bob_data/resource1\", \"GET\", false)\n\ttestEnforce(t, e, \"bob\", \"/bob_data/resource1\", \"POST\", true)\n\ttestEnforce(t, e, \"bob\", \"/bob_data/resource2\", \"GET\", false)\n\ttestEnforce(t, e, \"bob\", \"/bob_data/resource2\", \"POST\", true)\n\n\ttestEnforce(t, e, \"cathy\", \"/cathy_data\", \"GET\", true)\n\ttestEnforce(t, e, \"cathy\", \"/cathy_data\", \"POST\", true)\n\ttestEnforce(t, e, \"cathy\", \"/cathy_data\", \"DELETE\", false)\n}\n\nfunc TestKeyMatchWithRBACInDomain(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/keymatch_with_rbac_in_domain.conf\", \"examples/keymatch_with_rbac_in_domain.csv\")\n\ttestDomainEnforce(t, e, \"Username==test2\", \"engines/engine1\", \"*\", \"attach\", true)\n}\n\nfunc TestKeyMatchModelInMemoryDeny(t *testing.T) {\n\tm := model.NewModel()\n\tm.AddDef(\"r\", \"r\", \"sub, obj, act\")\n\tm.AddDef(\"p\", \"p\", \"sub, obj, act\")\n\tm.AddDef(\"e\", \"e\", \"!some(where (p.eft == deny))\")\n\tm.AddDef(\"m\", \"m\", \"r.sub == p.sub && keyMatch(r.obj, p.obj) && regexMatch(r.act, p.act)\")\n\n\ta := fileadapter.NewAdapter(\"examples/keymatch_policy.csv\")\n\n\te, _ := NewEnforcer(m, a)\n\n\ttestEnforce(t, e, \"alice\", \"/alice_data/resource2\", \"POST\", true)\n}\n\nfunc TestRBACModelInMemoryIndeterminate(t *testing.T) {\n\tm := model.NewModel()\n\tm.AddDef(\"r\", \"r\", \"sub, obj, act\")\n\tm.AddDef(\"p\", \"p\", \"sub, obj, act\")\n\tm.AddDef(\"g\", \"g\", \"_, _\")\n\tm.AddDef(\"e\", \"e\", \"some(where (p.eft == allow))\")\n\tm.AddDef(\"m\", \"m\", \"g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act\")\n\n\te, _ := NewEnforcer(m)\n\n\t_, _ = e.AddPermissionForUser(\"alice\", \"data1\", \"invalid\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", false)\n}\n\nfunc TestRBACModelInMemory(t *testing.T) {\n\tm := model.NewModel()\n\tm.AddDef(\"r\", \"r\", \"sub, obj, act\")\n\tm.AddDef(\"p\", \"p\", \"sub, obj, act\")\n\tm.AddDef(\"g\", \"g\", \"_, _\")\n\tm.AddDef(\"e\", \"e\", \"some(where (p.eft == allow))\")\n\tm.AddDef(\"m\", \"m\", \"g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act\")\n\n\te, _ := NewEnforcer(m)\n\n\t_, _ = e.AddPermissionForUser(\"alice\", \"data1\", \"read\")\n\t_, _ = e.AddPermissionForUser(\"bob\", \"data2\", \"write\")\n\t_, _ = e.AddPermissionForUser(\"data2_admin\", \"data2\", \"read\")\n\t_, _ = e.AddPermissionForUser(\"data2_admin\", \"data2\", \"write\")\n\t_, _ = e.AddRoleForUser(\"alice\", \"data2_admin\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", true)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\nfunc TestRBACModelInMemory2(t *testing.T) {\n\ttext :=\n\t\t`\n[request_definition]\nr = sub, obj, act\n\n[policy_definition]\np = sub, obj, act\n\n[role_definition]\ng = _, _\n\n[policy_effect]\ne = some(where (p.eft == allow))\n\n[matchers]\nm = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act\n`\n\tm, _ := model.NewModelFromString(text)\n\t// The above is the same as:\n\t// m := NewModel()\n\t// m.LoadModelFromText(text)\n\n\te, _ := NewEnforcer(m)\n\n\t_, _ = e.AddPermissionForUser(\"alice\", \"data1\", \"read\")\n\t_, _ = e.AddPermissionForUser(\"bob\", \"data2\", \"write\")\n\t_, _ = e.AddPermissionForUser(\"data2_admin\", \"data2\", \"read\")\n\t_, _ = e.AddPermissionForUser(\"data2_admin\", \"data2\", \"write\")\n\t_, _ = e.AddRoleForUser(\"alice\", \"data2_admin\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", true)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\nfunc TestNotUsedRBACModelInMemory(t *testing.T) {\n\tm := model.NewModel()\n\tm.AddDef(\"r\", \"r\", \"sub, obj, act\")\n\tm.AddDef(\"p\", \"p\", \"sub, obj, act\")\n\tm.AddDef(\"g\", \"g\", \"_, _\")\n\tm.AddDef(\"e\", \"e\", \"some(where (p.eft == allow))\")\n\tm.AddDef(\"m\", \"m\", \"g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act\")\n\n\te, _ := NewEnforcer(m)\n\n\t_, _ = e.AddPermissionForUser(\"alice\", \"data1\", \"read\")\n\t_, _ = e.AddPermissionForUser(\"bob\", \"data2\", \"write\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\nfunc TestMatcherUsingInOperator(t *testing.T) {\n\t// From file config\n\te, _ := NewEnforcer(\"examples/rbac_model_matcher_using_in_op.conf\")\n\t_, _ = e.AddPermissionForUser(\"alice\", \"data1\", \"read\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data3\", \"read\", true)\n\ttestEnforce(t, e, \"anyone\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"anyone\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"anyone\", \"data3\", \"read\", true)\n}\n\nfunc TestMatcherUsingInOperatorBracket(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model_matcher_using_in_op_bracket.conf\")\n\t_, _ = e.AddPermissionForUser(\"alice\", \"data1\", \"read\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data3\", \"read\", true)\n\ttestEnforce(t, e, \"anyone\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"anyone\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"anyone\", \"data3\", \"read\", true)\n}\n\nfunc TestReloadPolicy(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\t_ = e.LoadPolicy()\n\ttestGetPolicy(t, e, [][]string{{\"alice\", \"data1\", \"read\"}, {\"bob\", \"data2\", \"write\"}, {\"data2_admin\", \"data2\", \"read\"}, {\"data2_admin\", \"data2\", \"write\"}})\n}\n\nfunc TestSavePolicy(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\t_ = e.SavePolicy()\n}\n\nfunc TestClearPolicy(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\te.ClearPolicy()\n}\n\nfunc TestEnableEnforce(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\n\te.EnableEnforce(false)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", true)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", true)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n\n\te.EnableEnforce(true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\nfunc TestEnableLog(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\", true)\n\t// The log is enabled by default, so the above is the same with:\n\t// e := NewEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n\n\t// The log can also be enabled or disabled at run-time.\n\te.EnableLog(false)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\nfunc TestEnableAutoSave(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\n\te.EnableAutoSave(false)\n\t// Because AutoSave is disabled, the policy change only affects the policy in Casbin enforcer,\n\t// it doesn't affect the policy in the storage.\n\t_, _ = e.RemovePolicy(\"alice\", \"data1\", \"read\")\n\t// Reload the policy from the storage to see the effect.\n\t_ = e.LoadPolicy()\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n\n\te.EnableAutoSave(true)\n\t// Because AutoSave is enabled, the policy change not only affects the policy in Casbin enforcer,\n\t// but also affects the policy in the storage.\n\t_, _ = e.RemovePolicy(\"alice\", \"data1\", \"read\")\n\n\t// However, the file adapter doesn't implement the AutoSave feature, so enabling it has no effect at all here.\n\n\t// Reload the policy from the storage to see the effect.\n\t_ = e.LoadPolicy()\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true) // Will not be false here.\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\nfunc TestInitWithAdapter(t *testing.T) {\n\tadapter := fileadapter.NewAdapter(\"examples/basic_policy.csv\")\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", adapter)\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\nfunc TestRoleLinks(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\")\n\te.EnableAutoBuildRoleLinks(false)\n\t_ = e.BuildRoleLinks()\n\t_, _ = e.Enforce(\"user501\", \"data9\", \"read\")\n}\n\nfunc TestEnforceConcurrency(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tt.Errorf(\"Enforce is not concurrent\")\n\t\t}\n\t}()\n\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\")\n\t_ = e.LoadModel()\n\n\tvar wg sync.WaitGroup\n\n\t// Simulate concurrency (maybe use a timer?)\n\tfor i := 1; i <= 10000; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\t_, _ = e.Enforce(\"user501\", \"data9\", \"read\")\n\t\t\twg.Done()\n\t\t}()\n\t}\n\n\twg.Wait()\n}\n\nfunc TestGetAndSetModel(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\te2, _ := NewEnforcer(\"examples/basic_with_root_model.conf\", \"examples/basic_policy.csv\")\n\n\ttestEnforce(t, e, \"root\", \"data1\", \"read\", false)\n\n\te.SetModel(e2.GetModel())\n\n\ttestEnforce(t, e, \"root\", \"data1\", \"read\", true)\n}\n\nfunc TestGetAndSetAdapterInMem(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\te2, _ := NewEnforcer(\"examples/basic_model.conf\", \"examples/basic_inverse_policy.csv\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\n\ta2 := e2.GetAdapter()\n\te.SetAdapter(a2)\n\t_ = e.LoadPolicy()\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", true)\n}\n\nfunc TestSetAdapterFromFile(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", false)\n\n\ta := fileadapter.NewAdapter(\"examples/basic_policy.csv\")\n\te.SetAdapter(a)\n\t_ = e.LoadPolicy()\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n}\n\nfunc TestInitEmpty(t *testing.T) {\n\te, _ := NewEnforcer()\n\n\tm := model.NewModel()\n\tm.AddDef(\"r\", \"r\", \"sub, obj, act\")\n\tm.AddDef(\"p\", \"p\", \"sub, obj, act\")\n\tm.AddDef(\"e\", \"e\", \"some(where (p.eft == allow))\")\n\tm.AddDef(\"m\", \"m\", \"r.sub == p.sub && keyMatch(r.obj, p.obj) && regexMatch(r.act, p.act)\")\n\n\ta := fileadapter.NewAdapter(\"examples/keymatch_policy.csv\")\n\n\te.SetModel(m)\n\te.SetAdapter(a)\n\t_ = e.LoadPolicy()\n\n\ttestEnforce(t, e, \"alice\", \"/alice_data/resource1\", \"GET\", true)\n}\nfunc testEnforceEx(t *testing.T, e *Enforcer, sub, obj, act interface{}, res []string) {\n\tt.Helper()\n\t_, myRes, _ := e.EnforceEx(sub, obj, act)\n\n\tif ok := util.ArrayEquals(res, myRes); !ok {\n\t\tt.Error(\"Key: \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc TestEnforceEx(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\n\ttestEnforceEx(t, e, \"alice\", \"data1\", \"read\", []string{\"alice\", \"data1\", \"read\"})\n\ttestEnforceEx(t, e, \"alice\", \"data1\", \"write\", []string{})\n\ttestEnforceEx(t, e, \"alice\", \"data2\", \"read\", []string{})\n\ttestEnforceEx(t, e, \"alice\", \"data2\", \"write\", []string{})\n\ttestEnforceEx(t, e, \"bob\", \"data1\", \"read\", []string{})\n\ttestEnforceEx(t, e, \"bob\", \"data1\", \"write\", []string{})\n\ttestEnforceEx(t, e, \"bob\", \"data2\", \"read\", []string{})\n\ttestEnforceEx(t, e, \"bob\", \"data2\", \"write\", []string{\"bob\", \"data2\", \"write\"})\n\n\te, _ = NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\ttestEnforceEx(t, e, \"alice\", \"data1\", \"read\", []string{\"alice\", \"data1\", \"read\"})\n\ttestEnforceEx(t, e, \"alice\", \"data1\", \"write\", []string{})\n\ttestEnforceEx(t, e, \"alice\", \"data2\", \"read\", []string{\"data2_admin\", \"data2\", \"read\"})\n\ttestEnforceEx(t, e, \"alice\", \"data2\", \"write\", []string{\"data2_admin\", \"data2\", \"write\"})\n\ttestEnforceEx(t, e, \"bob\", \"data1\", \"read\", []string{})\n\ttestEnforceEx(t, e, \"bob\", \"data1\", \"write\", []string{})\n\ttestEnforceEx(t, e, \"bob\", \"data2\", \"read\", []string{})\n\ttestEnforceEx(t, e, \"bob\", \"data2\", \"write\", []string{\"bob\", \"data2\", \"write\"})\n\n\te, _ = NewEnforcer(\"examples/priority_model.conf\", \"examples/priority_policy.csv\")\n\n\ttestEnforceEx(t, e, \"alice\", \"data1\", \"read\", []string{\"alice\", \"data1\", \"read\", \"allow\"})\n\ttestEnforceEx(t, e, \"alice\", \"data1\", \"write\", []string{\"data1_deny_group\", \"data1\", \"write\", \"deny\"})\n\ttestEnforceEx(t, e, \"alice\", \"data2\", \"read\", []string{})\n\ttestEnforceEx(t, e, \"alice\", \"data2\", \"write\", []string{})\n\ttestEnforceEx(t, e, \"bob\", \"data1\", \"write\", []string{})\n\ttestEnforceEx(t, e, \"bob\", \"data2\", \"read\", []string{\"data2_allow_group\", \"data2\", \"read\", \"allow\"})\n\ttestEnforceEx(t, e, \"bob\", \"data2\", \"write\", []string{\"bob\", \"data2\", \"write\", \"deny\"})\n\n\te, _ = NewEnforcer(\"examples/abac_model.conf\")\n\tobj := struct{ Owner string }{Owner: \"alice\"}\n\ttestEnforceEx(t, e, \"alice\", obj, \"write\", []string{})\n}\n\nfunc TestEnforceExLog(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\", true)\n\n\ttestEnforceEx(t, e, \"alice\", \"data1\", \"read\", []string{\"alice\", \"data1\", \"read\"})\n\ttestEnforceEx(t, e, \"alice\", \"data1\", \"write\", []string{})\n\ttestEnforceEx(t, e, \"alice\", \"data2\", \"read\", []string{})\n\ttestEnforceEx(t, e, \"alice\", \"data2\", \"write\", []string{})\n\ttestEnforceEx(t, e, \"bob\", \"data1\", \"read\", []string{})\n\ttestEnforceEx(t, e, \"bob\", \"data1\", \"write\", []string{})\n\ttestEnforceEx(t, e, \"bob\", \"data2\", \"read\", []string{})\n\ttestEnforceEx(t, e, \"bob\", \"data2\", \"write\", []string{\"bob\", \"data2\", \"write\"})\n}\n\nfunc testBatchEnforce(t *testing.T, e *Enforcer, requests [][]interface{}, results []bool) {\n\tt.Helper()\n\tmyRes, _ := e.BatchEnforce(requests)\n\tif len(myRes) != len(results) {\n\t\tt.Errorf(\"%v supposed to be %v\", myRes, results)\n\t}\n\tfor i, v := range myRes {\n\t\tif v != results[i] {\n\t\t\tt.Errorf(\"%v supposed to be %v\", myRes, results)\n\t\t}\n\t}\n}\n\nfunc TestBatchEnforce(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\tresults := []bool{true, true, false}\n\ttestBatchEnforce(t, e, [][]interface{}{{\"alice\", \"data1\", \"read\"}, {\"bob\", \"data2\", \"write\"}, {\"jack\", \"data3\", \"read\"}}, results)\n}\n\nfunc TestSubjectPriority(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/subject_priority_model.conf\", \"examples/subject_priority_policy.csv\")\n\ttestBatchEnforce(t, e, [][]interface{}{\n\t\t{\"jane\", \"data1\", \"read\"},\n\t\t{\"alice\", \"data1\", \"read\"},\n\t}, []bool{\n\t\ttrue, true,\n\t})\n}\n\nfunc TestSubjectPriorityWithDomain(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/subject_priority_model_with_domain.conf\", \"examples/subject_priority_policy_with_domain.csv\")\n\ttestBatchEnforce(t, e, [][]interface{}{\n\t\t{\"alice\", \"data1\", \"domain1\", \"write\"},\n\t\t{\"bob\", \"data2\", \"domain2\", \"write\"},\n\t}, []bool{\n\t\ttrue, true,\n\t})\n}\n\nfunc TestSubjectPriorityInFilter(t *testing.T) {\n\te, _ := NewEnforcer()\n\n\tadapter := fileadapter.NewFilteredAdapter(\"examples/subject_priority_policy_with_domain.csv\")\n\t_ = e.InitWithAdapter(\"examples/subject_priority_model_with_domain.conf\", adapter)\n\tif err := e.loadFilteredPolicy(&fileadapter.Filter{\n\t\tP: []string{\"\", \"\", \"domain1\"},\n\t}); err != nil {\n\t\tt.Errorf(\"unexpected error in LoadFilteredPolicy: %v\", err)\n\t}\n\n\ttestBatchEnforce(t, e, [][]interface{}{\n\t\t{\"alice\", \"data1\", \"domain1\", \"write\"},\n\t\t{\"admin\", \"data1\", \"domain1\", \"write\"},\n\t}, []bool{\n\t\ttrue, false,\n\t})\n}\n\nfunc TestMultiplePolicyDefinitions(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/multiple_policy_definitions_model.conf\", \"examples/multiple_policy_definitions_policy.csv\")\n\tenforceContext := NewEnforceContext(\"2\")\n\tenforceContext.EType = \"e\"\n\ttestBatchEnforce(t, e, [][]interface{}{\n\t\t{\"alice\", \"data2\", \"read\"},\n\t\t{enforceContext, struct{ Age int }{Age: 70}, \"/data1\", \"read\"},\n\t\t{enforceContext, struct{ Age int }{Age: 30}, \"/data1\", \"read\"},\n\t}, []bool{\n\t\ttrue, false, true,\n\t})\n}\n\nfunc TestPriorityExplicit(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/priority_model_explicit.conf\", \"examples/priority_policy_explicit.csv\")\n\ttestBatchEnforce(t, e, [][]interface{}{\n\t\t{\"alice\", \"data1\", \"write\"},\n\t\t{\"alice\", \"data1\", \"read\"},\n\t\t{\"bob\", \"data2\", \"read\"},\n\t\t{\"bob\", \"data2\", \"write\"},\n\t\t{\"data1_deny_group\", \"data1\", \"read\"},\n\t\t{\"data1_deny_group\", \"data1\", \"write\"},\n\t\t{\"data2_allow_group\", \"data2\", \"read\"},\n\t\t{\"data2_allow_group\", \"data2\", \"write\"},\n\t}, []bool{\n\t\ttrue, true, false, true, false, false, true, true,\n\t})\n\n\t_, err := e.AddPolicy(\"1\", \"bob\", \"data2\", \"write\", \"deny\")\n\tif err != nil {\n\t\tt.Fatalf(\"Add Policy: %v\", err)\n\t}\n\n\ttestBatchEnforce(t, e, [][]interface{}{\n\t\t{\"alice\", \"data1\", \"write\"},\n\t\t{\"alice\", \"data1\", \"read\"},\n\t\t{\"bob\", \"data2\", \"read\"},\n\t\t{\"bob\", \"data2\", \"write\"},\n\t\t{\"data1_deny_group\", \"data1\", \"read\"},\n\t\t{\"data1_deny_group\", \"data1\", \"write\"},\n\t\t{\"data2_allow_group\", \"data2\", \"read\"},\n\t\t{\"data2_allow_group\", \"data2\", \"write\"},\n\t}, []bool{\n\t\ttrue, true, false, false, false, false, true, true,\n\t})\n}\n\nfunc TestFailedToLoadPolicy(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_pattern_model.conf\", \"examples/rbac_with_pattern_policy.csv\")\n\te.AddNamedMatchingFunc(\"g2\", \"matchingFunc\", util.KeyMatch2)\n\ttestEnforce(t, e, \"alice\", \"/book/1\", \"GET\", true)\n\ttestEnforce(t, e, \"bob\", \"/pen/3\", \"GET\", true)\n\te.SetAdapter(fileadapter.NewAdapter(\"not found\"))\n\t_ = e.LoadPolicy()\n\ttestEnforce(t, e, \"alice\", \"/book/1\", \"GET\", true)\n\ttestEnforce(t, e, \"bob\", \"/pen/3\", \"GET\", true)\n}\n\nfunc TestReloadPolicyWithFunc(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_pattern_model.conf\", \"examples/rbac_with_pattern_policy.csv\")\n\te.AddNamedMatchingFunc(\"g2\", \"matchingFunc\", util.KeyMatch2)\n\ttestEnforce(t, e, \"alice\", \"/book/1\", \"GET\", true)\n\ttestEnforce(t, e, \"bob\", \"/pen/3\", \"GET\", true)\n\t_ = e.LoadPolicy()\n\ttestEnforce(t, e, \"alice\", \"/book/1\", \"GET\", true)\n\ttestEnforce(t, e, \"bob\", \"/pen/3\", \"GET\", true)\n}\n\nfunc TestEvalPriority(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/eval_operator_model.conf\", \"examples/eval_operator_policy.csv\")\n\ttestEnforce(t, e, \"admin\", \"users\", \"write\", true)\n\ttestEnforce(t, e, \"admin\", \"none\", \"write\", false)\n\ttestEnforce(t, e, \"user\", \"users\", \"write\", false)\n}\n\nfunc TestLinkConditionFunc(t *testing.T) {\n\tTrueFunc := func(args ...string) (bool, error) {\n\t\tif len(args) != 0 {\n\t\t\treturn args[0] == \"_\" || args[0] == \"true\", nil\n\t\t}\n\t\treturn false, nil\n\t}\n\n\tFalseFunc := func(args ...string) (bool, error) {\n\t\tif len(args) != 0 {\n\t\t\treturn args[0] == \"_\" || args[0] == \"false\", nil\n\t\t}\n\t\treturn false, nil\n\t}\n\n\tm, _ := model.NewModelFromFile(\"examples/rbac_with_temporal_roles_model.conf\")\n\te, _ := NewEnforcer(m)\n\n\t_, _ = e.AddPolicies([][]string{\n\t\t{\"alice\", \"data1\", \"read\"},\n\t\t{\"alice\", \"data1\", \"write\"},\n\t\t{\"data2_admin\", \"data2\", \"read\"},\n\t\t{\"data2_admin\", \"data2\", \"write\"},\n\t\t{\"data3_admin\", \"data3\", \"read\"},\n\t\t{\"data3_admin\", \"data3\", \"write\"},\n\t\t{\"data4_admin\", \"data4\", \"read\"},\n\t\t{\"data4_admin\", \"data4\", \"write\"},\n\t\t{\"data5_admin\", \"data5\", \"read\"},\n\t\t{\"data5_admin\", \"data5\", \"write\"},\n\t})\n\n\t_, _ = e.AddGroupingPolicies([][]string{\n\t\t{\"alice\", \"data2_admin\", \"_\", \"_\"},\n\t\t{\"alice\", \"data3_admin\", \"_\", \"_\"},\n\t\t{\"alice\", \"data4_admin\", \"_\", \"_\"},\n\t\t{\"alice\", \"data5_admin\", \"_\", \"_\"},\n\t})\n\n\te.AddNamedLinkConditionFunc(\"g\", \"alice\", \"data2_admin\", TrueFunc)\n\te.AddNamedLinkConditionFunc(\"g\", \"alice\", \"data3_admin\", TrueFunc)\n\te.AddNamedLinkConditionFunc(\"g\", \"alice\", \"data4_admin\", FalseFunc)\n\te.AddNamedLinkConditionFunc(\"g\", \"alice\", \"data5_admin\", FalseFunc)\n\n\te.SetNamedLinkConditionFuncParams(\"g\", \"alice\", \"data2_admin\", \"true\")\n\te.SetNamedLinkConditionFuncParams(\"g\", \"alice\", \"data3_admin\", \"not true\")\n\te.SetNamedLinkConditionFuncParams(\"g\", \"alice\", \"data4_admin\", \"false\")\n\te.SetNamedLinkConditionFuncParams(\"g\", \"alice\", \"data5_admin\", \"not false\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", true)\n\ttestEnforce(t, e, \"alice\", \"data3\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data3\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data4\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data4\", \"write\", true)\n\ttestEnforce(t, e, \"alice\", \"data5\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data5\", \"write\", false)\n\n\tm, _ = model.NewModelFromFile(\"examples/rbac_with_domain_temporal_roles_model.conf\")\n\te, _ = NewEnforcer(m)\n\n\t_, _ = e.AddPolicies([][]string{\n\t\t{\"alice\", \"domain1\", \"data1\", \"read\"},\n\t\t{\"alice\", \"domain1\", \"data1\", \"write\"},\n\t\t{\"data2_admin\", \"domain2\", \"data2\", \"read\"},\n\t\t{\"data2_admin\", \"domain2\", \"data2\", \"write\"},\n\t\t{\"data3_admin\", \"domain3\", \"data3\", \"read\"},\n\t\t{\"data3_admin\", \"domain3\", \"data3\", \"write\"},\n\t\t{\"data4_admin\", \"domain4\", \"data4\", \"read\"},\n\t\t{\"data4_admin\", \"domain4\", \"data4\", \"write\"},\n\t\t{\"data5_admin\", \"domain5\", \"data5\", \"read\"},\n\t\t{\"data5_admin\", \"domain5\", \"data5\", \"write\"},\n\t})\n\n\t_, _ = e.AddGroupingPolicies([][]string{\n\t\t{\"alice\", \"data2_admin\", \"domain2\", \"_\", \"_\"},\n\t\t{\"alice\", \"data3_admin\", \"domain3\", \"_\", \"_\"},\n\t\t{\"alice\", \"data4_admin\", \"domain4\", \"_\", \"_\"},\n\t\t{\"alice\", \"data5_admin\", \"domain5\", \"_\", \"_\"},\n\t})\n\n\te.AddNamedDomainLinkConditionFunc(\"g\", \"alice\", \"data2_admin\", \"domain2\", TrueFunc)\n\te.AddNamedDomainLinkConditionFunc(\"g\", \"alice\", \"data3_admin\", \"domain3\", TrueFunc)\n\te.AddNamedDomainLinkConditionFunc(\"g\", \"alice\", \"data4_admin\", \"domain4\", FalseFunc)\n\te.AddNamedDomainLinkConditionFunc(\"g\", \"alice\", \"data5_admin\", \"domain5\", FalseFunc)\n\n\te.SetNamedDomainLinkConditionFuncParams(\"g\", \"alice\", \"data2_admin\", \"domain2\", \"true\")\n\te.SetNamedDomainLinkConditionFuncParams(\"g\", \"alice\", \"data3_admin\", \"domain3\", \"not true\")\n\te.SetNamedDomainLinkConditionFuncParams(\"g\", \"alice\", \"data4_admin\", \"domain4\", \"false\")\n\te.SetNamedDomainLinkConditionFuncParams(\"g\", \"alice\", \"data5_admin\", \"domain5\", \"not false\")\n\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"read\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"write\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain2\", \"data2\", \"read\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain2\", \"data2\", \"write\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain3\", \"data3\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain3\", \"data3\", \"write\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain4\", \"data4\", \"read\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain4\", \"data4\", \"write\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain5\", \"data5\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain5\", \"data5\", \"write\", false)\n}\n"
        },
        {
          "name": "error_test.go",
          "type": "blob",
          "size": 6.1630859375,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"testing\"\n\n\tfileadapter \"github.com/casbin/casbin/v2/persist/file-adapter\"\n)\n\nfunc TestPathError(t *testing.T) {\n\t_, err := NewEnforcer(\"hope_this_path_wont_exist\", \"\")\n\tif err == nil {\n\t\tt.Errorf(\"Should be error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err.Error())\n\t}\n}\n\nfunc TestEnforcerParamError(t *testing.T) {\n\t_, err := NewEnforcer(1, 2, 3)\n\tif err == nil {\n\t\tt.Errorf(\"Should not be error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err.Error())\n\t}\n\n\t_, err2 := NewEnforcer(1, \"2\")\n\tif err2 == nil {\n\t\tt.Errorf(\"Should not be error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err2.Error())\n\t}\n}\n\nfunc TestModelError(t *testing.T) {\n\t_, err := NewEnforcer(\"examples/error/error_model.conf\", \"examples/error/error_policy.csv\")\n\tif err == nil {\n\t\tt.Errorf(\"Should be error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err.Error())\n\t}\n}\n\n// func TestPolicyError(t *testing.T) {\n//\t_, err := NewEnforcer(\"examples/basic_model.conf\", \"examples/error/error_policy.csv\")\n//\tif err == nil {\n//\t\tt.Errorf(\"Should be error here.\")\n//\t} else {\n//\t\tt.Log(\"Test on error: \")\n//\t\tt.Log(err.Error())\n//\t}\n//}\n\nfunc TestEnforceError(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\t_, err := e.Enforce(\"wrong\", \"wrong\")\n\tif err == nil {\n\t\tt.Errorf(\"Should be error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err.Error())\n\t}\n\n\te, _ = NewEnforcer(\"examples/abac_rule_model.conf\")\n\t_, err = e.Enforce(\"wang\", \"wang\", \"wang\")\n\tif err == nil {\n\t\tt.Errorf(\"Should be error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err.Error())\n\t}\n}\n\nfunc TestNoError(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\n\terr := e.LoadModel()\n\tif err != nil {\n\t\tt.Errorf(\"Should be no error here.\")\n\t\tt.Log(\"Unexpected error: \")\n\t\tt.Log(err.Error())\n\t}\n\n\terr = e.LoadPolicy()\n\tif err != nil {\n\t\tt.Errorf(\"Should be no error here.\")\n\t\tt.Log(\"Unexpected error: \")\n\t\tt.Log(err.Error())\n\t}\n\n\terr = e.SavePolicy()\n\tif err != nil {\n\t\tt.Errorf(\"Should be no error here.\")\n\t\tt.Log(\"Unexpected error: \")\n\t\tt.Log(err.Error())\n\t}\n}\n\nfunc TestModelNoError(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\n\te.modelPath = \"hope_this_path_wont_exist\"\n\terr := e.LoadModel()\n\n\tif err == nil {\n\t\tt.Errorf(\"Should be error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err.Error())\n\t}\n}\n\nfunc TestMockAdapterErrors(t *testing.T) {\n\tadapter := fileadapter.NewAdapterMock(\"examples/rbac_with_domains_policy.csv\")\n\tadapter.SetMockErr(\"mock error\")\n\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", adapter)\n\n\tadded, err := e.AddPolicy(\"admin\", \"domain3\", \"data1\", \"read\")\n\tif added {\n\t\tt.Errorf(\"added should be false\")\n\t}\n\n\tif err == nil {\n\t\tt.Errorf(\"Should be an error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err.Error())\n\t}\n\n\trules := [][]string{\n\t\t{\"admin\", \"domain4\", \"data1\", \"read\"},\n\t}\n\tadded, err = e.AddPolicies(rules)\n\tif added {\n\t\tt.Errorf(\"added should be false\")\n\t}\n\n\tif err == nil {\n\t\tt.Errorf(\"Should be an error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err.Error())\n\t}\n\n\tremoved, err2 := e.RemoveFilteredPolicy(1, \"domain1\", \"data1\")\n\tif removed {\n\t\tt.Errorf(\"removed should be false\")\n\t}\n\n\tif err2 == nil {\n\t\tt.Errorf(\"Should be an error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err2.Error())\n\t}\n\n\tremoved, err3 := e.RemovePolicy(\"admin\", \"domain2\", \"data2\", \"read\")\n\tif removed {\n\t\tt.Errorf(\"removed should be false\")\n\t}\n\n\tif err3 == nil {\n\t\tt.Errorf(\"Should be an error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err3.Error())\n\t}\n\n\trules = [][]string{\n\t\t{\"admin\", \"domain1\", \"data1\", \"read\"},\n\t}\n\tremoved, err = e.RemovePolicies(rules)\n\tif removed {\n\t\tt.Errorf(\"removed should be false\")\n\t}\n\n\tif err == nil {\n\t\tt.Errorf(\"Should be an error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err.Error())\n\t}\n\n\tadded, err4 := e.AddGroupingPolicy(\"bob\", \"admin2\")\n\tif added {\n\t\tt.Errorf(\"added should be false\")\n\t}\n\n\tif err4 == nil {\n\t\tt.Errorf(\"Should be an error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err4.Error())\n\t}\n\n\tadded, err5 := e.AddNamedGroupingPolicy(\"g\", []string{\"eve\", \"admin2\", \"domain1\"})\n\tif added {\n\t\tt.Errorf(\"added should be false\")\n\t}\n\n\tif err5 == nil {\n\t\tt.Errorf(\"Should be an error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err5.Error())\n\t}\n\n\tadded, err6 := e.AddNamedPolicy(\"p\", []string{\"admin2\", \"domain2\", \"data2\", \"write\"})\n\tif added {\n\t\tt.Errorf(\"added should be false\")\n\t}\n\n\tif err6 == nil {\n\t\tt.Errorf(\"Should be an error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err6.Error())\n\t}\n\n\tremoved, err7 := e.RemoveGroupingPolicy(\"bob\", \"admin2\")\n\tif removed {\n\t\tt.Errorf(\"removed should be false\")\n\t}\n\n\tif err7 == nil {\n\t\tt.Errorf(\"Should be an error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err7.Error())\n\t}\n\n\tremoved, err8 := e.RemoveFilteredGroupingPolicy(0, \"bob\")\n\tif removed {\n\t\tt.Errorf(\"removed should be false\")\n\t}\n\n\tif err8 == nil {\n\t\tt.Errorf(\"Should be an error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err8.Error())\n\t}\n\n\tremoved, err9 := e.RemoveNamedGroupingPolicy(\"g\", []string{\"alice\", \"admin\", \"domain1\"})\n\tif removed {\n\t\tt.Errorf(\"removed should be false\")\n\t}\n\n\tif err9 == nil {\n\t\tt.Errorf(\"Should be an error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err9.Error())\n\t}\n\n\tremoved, err10 := e.RemoveFilteredNamedGroupingPolicy(\"g\", 0, \"eve\")\n\tif removed {\n\t\tt.Errorf(\"removed should be false\")\n\t}\n\n\tif err10 == nil {\n\t\tt.Errorf(\"Should be an error here.\")\n\t} else {\n\t\tt.Log(\"Test on error: \")\n\t\tt.Log(err10.Error())\n\t}\n}\n"
        },
        {
          "name": "errors",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "filter_test.go",
          "type": "blob",
          "size": 7.0908203125,
          "content": "// Copyright 2018 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"testing\"\n\n\tfileadapter \"github.com/casbin/casbin/v2/persist/file-adapter\"\n\t\"github.com/casbin/casbin/v2/util\"\n)\n\nfunc TestInitFilteredAdapter(t *testing.T) {\n\te, _ := NewEnforcer()\n\n\tadapter := fileadapter.NewFilteredAdapter(\"examples/rbac_with_domains_policy.csv\")\n\t_ = e.InitWithAdapter(\"examples/rbac_with_domains_model.conf\", adapter)\n\n\t// policy should not be loaded yet\n\ttestHasPolicy(t, e, []string{\"admin\", \"domain1\", \"data1\", \"read\"}, false)\n}\n\nfunc TestLoadFilteredPolicy(t *testing.T) {\n\te, _ := NewEnforcer()\n\n\tadapter := fileadapter.NewFilteredAdapter(\"examples/rbac_with_domains_policy.csv\")\n\t_ = e.InitWithAdapter(\"examples/rbac_with_domains_model.conf\", adapter)\n\tif err := e.LoadPolicy(); err != nil {\n\t\tt.Errorf(\"unexpected error in LoadPolicy: %v\", err)\n\t}\n\n\t// validate initial conditions\n\ttestHasPolicy(t, e, []string{\"admin\", \"domain1\", \"data1\", \"read\"}, true)\n\ttestHasPolicy(t, e, []string{\"admin\", \"domain2\", \"data2\", \"read\"}, true)\n\n\tif err := e.LoadFilteredPolicy(&fileadapter.Filter{\n\t\tP: []string{\"\", \"domain1\"},\n\t\tG: []string{\"\", \"\", \"domain1\"},\n\t}); err != nil {\n\t\tt.Errorf(\"unexpected error in LoadFilteredPolicy: %v\", err)\n\t}\n\tif !e.IsFiltered() {\n\t\tt.Errorf(\"adapter did not set the filtered flag correctly\")\n\t}\n\n\t// only policies for domain1 should be loaded\n\ttestHasPolicy(t, e, []string{\"admin\", \"domain1\", \"data1\", \"read\"}, true)\n\ttestHasPolicy(t, e, []string{\"admin\", \"domain2\", \"data2\", \"read\"}, false)\n\n\tif err := e.SavePolicy(); err == nil {\n\t\tt.Errorf(\"enforcer did not prevent saving filtered policy\")\n\t}\n\tif err := e.GetAdapter().SavePolicy(e.GetModel()); err == nil {\n\t\tt.Errorf(\"adapter did not prevent saving filtered policy\")\n\t}\n}\n\nfunc TestLoadMoreTypeFilteredPolicy(t *testing.T) {\n\te, _ := NewEnforcer()\n\n\tadapter := fileadapter.NewFilteredAdapter(\"examples/rbac_with_pattern_policy.csv\")\n\t_ = e.InitWithAdapter(\"examples/rbac_with_pattern_model.conf\", adapter)\n\tif err := e.LoadPolicy(); err != nil {\n\t\tt.Errorf(\"unexpected error in LoadPolicy: %v\", err)\n\t}\n\te.AddNamedMatchingFunc(\"g2\", \"matching func\", util.KeyMatch2)\n\t_ = e.BuildRoleLinks()\n\n\ttestEnforce(t, e, \"alice\", \"/book/1\", \"GET\", true)\n\n\t// validate initial conditions\n\ttestHasPolicy(t, e, []string{\"book_admin\", \"book_group\", \"GET\"}, true)\n\ttestHasPolicy(t, e, []string{\"pen_admin\", \"pen_group\", \"GET\"}, true)\n\n\tif err := e.LoadFilteredPolicy(&fileadapter.Filter{\n\t\tP:  []string{\"book_admin\"},\n\t\tG:  []string{\"alice\"},\n\t\tG2: []string{\"\", \"book_group\"},\n\t}); err != nil {\n\t\tt.Errorf(\"unexpected error in LoadFilteredPolicy: %v\", err)\n\t}\n\tif !e.IsFiltered() {\n\t\tt.Errorf(\"adapter did not set the filtered flag correctly\")\n\t}\n\n\ttestHasPolicy(t, e, []string{\"alice\", \"/pen/1\", \"GET\"}, false)\n\ttestHasPolicy(t, e, []string{\"alice\", \"/pen2/1\", \"GET\"}, false)\n\ttestHasPolicy(t, e, []string{\"pen_admin\", \"pen_group\", \"GET\"}, false)\n\ttestHasGroupingPolicy(t, e, []string{\"alice\", \"book_admin\"}, true)\n\ttestHasGroupingPolicy(t, e, []string{\"bob\", \"pen_admin\"}, false)\n\ttestHasGroupingPolicy(t, e, []string{\"cathy\", \"pen_admin\"}, false)\n\ttestHasGroupingPolicy(t, e, []string{\"cathy\", \"/book/1/2/3/4/5\"}, false)\n\n\ttestEnforce(t, e, \"alice\", \"/book/1\", \"GET\", true)\n\ttestEnforce(t, e, \"alice\", \"/pen/1\", \"GET\", false)\n}\n\nfunc TestAppendFilteredPolicy(t *testing.T) {\n\te, _ := NewEnforcer()\n\n\tadapter := fileadapter.NewFilteredAdapter(\"examples/rbac_with_domains_policy.csv\")\n\t_ = e.InitWithAdapter(\"examples/rbac_with_domains_model.conf\", adapter)\n\tif err := e.LoadPolicy(); err != nil {\n\t\tt.Errorf(\"unexpected error in LoadPolicy: %v\", err)\n\t}\n\n\t// validate initial conditions\n\ttestHasPolicy(t, e, []string{\"admin\", \"domain1\", \"data1\", \"read\"}, true)\n\ttestHasPolicy(t, e, []string{\"admin\", \"domain2\", \"data2\", \"read\"}, true)\n\n\tif err := e.LoadFilteredPolicy(&fileadapter.Filter{\n\t\tP: []string{\"\", \"domain1\"},\n\t\tG: []string{\"\", \"\", \"domain1\"},\n\t}); err != nil {\n\t\tt.Errorf(\"unexpected error in LoadFilteredPolicy: %v\", err)\n\t}\n\tif !e.IsFiltered() {\n\t\tt.Errorf(\"adapter did not set the filtered flag correctly\")\n\t}\n\n\t// only policies for domain1 should be loaded\n\ttestHasPolicy(t, e, []string{\"admin\", \"domain1\", \"data1\", \"read\"}, true)\n\ttestHasPolicy(t, e, []string{\"admin\", \"domain2\", \"data2\", \"read\"}, false)\n\n\t// disable clear policy and load second domain\n\tif err := e.LoadIncrementalFilteredPolicy(&fileadapter.Filter{\n\t\tP: []string{\"\", \"domain2\"},\n\t\tG: []string{\"\", \"\", \"domain2\"},\n\t}); err != nil {\n\t\tt.Errorf(\"unexpected error in LoadFilteredPolicy: %v\", err)\n\t}\n\n\t// both domain policies should be loaded\n\ttestHasPolicy(t, e, []string{\"admin\", \"domain1\", \"data1\", \"read\"}, true)\n\ttestHasPolicy(t, e, []string{\"admin\", \"domain2\", \"data2\", \"read\"}, true)\n}\n\nfunc TestFilteredPolicyInvalidFilter(t *testing.T) {\n\te, _ := NewEnforcer()\n\n\tadapter := fileadapter.NewFilteredAdapter(\"examples/rbac_with_domains_policy.csv\")\n\t_ = e.InitWithAdapter(\"examples/rbac_with_domains_model.conf\", adapter)\n\n\tif err := e.LoadFilteredPolicy([]string{\"\", \"domain1\"}); err == nil {\n\t\tt.Errorf(\"expected error in LoadFilteredPolicy, but got nil\")\n\t}\n}\n\nfunc TestFilteredPolicyEmptyFilter(t *testing.T) {\n\te, _ := NewEnforcer()\n\n\tadapter := fileadapter.NewFilteredAdapter(\"examples/rbac_with_domains_policy.csv\")\n\t_ = e.InitWithAdapter(\"examples/rbac_with_domains_model.conf\", adapter)\n\n\tif err := e.LoadFilteredPolicy(nil); err != nil {\n\t\tt.Errorf(\"unexpected error in LoadFilteredPolicy: %v\", err)\n\t}\n\tif e.IsFiltered() {\n\t\tt.Errorf(\"adapter did not reset the filtered flag correctly\")\n\t}\n\tif err := e.SavePolicy(); err != nil {\n\t\tt.Errorf(\"unexpected error in SavePolicy: %v\", err)\n\t}\n}\n\nfunc TestUnsupportedFilteredPolicy(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy.csv\")\n\n\terr := e.LoadFilteredPolicy(&fileadapter.Filter{\n\t\tP: []string{\"\", \"domain1\"},\n\t\tG: []string{\"\", \"\", \"domain1\"},\n\t})\n\tif err == nil {\n\t\tt.Errorf(\"encorcer should have reported incompatibility error\")\n\t}\n}\n\nfunc TestFilteredAdapterEmptyFilepath(t *testing.T) {\n\te, _ := NewEnforcer()\n\n\tadapter := fileadapter.NewFilteredAdapter(\"\")\n\t_ = e.InitWithAdapter(\"examples/rbac_with_domains_model.conf\", adapter)\n\n\tif err := e.LoadFilteredPolicy(nil); err != nil {\n\t\tt.Errorf(\"unexpected error in LoadFilteredPolicy: %v\", err)\n\t}\n}\n\nfunc TestFilteredAdapterInvalidFilepath(t *testing.T) {\n\te, _ := NewEnforcer()\n\n\tadapter := fileadapter.NewFilteredAdapter(\"examples/does_not_exist_policy.csv\")\n\t_ = e.InitWithAdapter(\"examples/rbac_with_domains_model.conf\", adapter)\n\n\tif err := e.LoadFilteredPolicy(nil); err == nil {\n\t\tt.Errorf(\"expected error in LoadFilteredPolicy, but got nil\")\n\t}\n}\n"
        },
        {
          "name": "frontend.go",
          "type": "blob",
          "size": 1.48828125,
          "content": "// Copyright 2020 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n)\n\nfunc CasbinJsGetPermissionForUser(e IEnforcer, user string) (string, error) {\n\tmodel := e.GetModel()\n\tm := map[string]interface{}{}\n\n\tm[\"m\"] = model.ToText()\n\n\tpRules := [][]string{}\n\tfor ptype := range model[\"p\"] {\n\t\tpolicies, err := model.GetPolicy(\"p\", ptype)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tfor _, rules := range policies {\n\t\t\tpRules = append(pRules, append([]string{ptype}, rules...))\n\t\t}\n\t}\n\tm[\"p\"] = pRules\n\n\tgRules := [][]string{}\n\tfor ptype := range model[\"g\"] {\n\t\tpolicies, err := model.GetPolicy(\"g\", ptype)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tfor _, rules := range policies {\n\t\t\tgRules = append(gRules, append([]string{ptype}, rules...))\n\t\t}\n\t}\n\tm[\"g\"] = gRules\n\n\tresult := bytes.NewBuffer([]byte{})\n\tencoder := json.NewEncoder(result)\n\tencoder.SetEscapeHTML(false)\n\terr := encoder.Encode(m)\n\treturn result.String(), err\n}\n"
        },
        {
          "name": "frontend_old.go",
          "type": "blob",
          "size": 1.0146484375,
          "content": "// Copyright 2021 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport \"encoding/json\"\n\nfunc CasbinJsGetPermissionForUserOld(e IEnforcer, user string) ([]byte, error) {\n\tpolicy, err := e.GetImplicitPermissionsForUser(user)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpermission := make(map[string][]string)\n\tfor i := 0; i < len(policy); i++ {\n\t\tpermission[policy[i][2]] = append(permission[policy[i][2]], policy[i][1])\n\t}\n\tb, _ := json.Marshal(permission)\n\treturn b, nil\n}\n"
        },
        {
          "name": "frontend_old_test.go",
          "type": "blob",
          "size": 2.5400390625,
          "content": "// Copyright 2021 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n)\n\nfunc contains(arr []string, target string) bool {\n\tfor _, item := range arr {\n\t\tif item == target {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc TestCasbinJsGetPermissionForUserOld(t *testing.T) {\n\te, err := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ttargetStr, _ := CasbinJsGetPermissionForUserOld(e, \"alice\")\n\tt.Log(\"GetPermissionForUser Alice\", string(targetStr))\n\taliceTarget := make(map[string][]string)\n\terr = json.Unmarshal(targetStr, &aliceTarget)\n\tif err != nil {\n\t\tt.Errorf(\"Test error: %s\", err)\n\t}\n\tperm, ok := aliceTarget[\"read\"]\n\tif !ok {\n\t\tt.Errorf(\"Test error: Alice doesn't have read permission\")\n\t}\n\tif !contains(perm, \"data1\") {\n\t\tt.Errorf(\"Test error: Alice cannot read data1\")\n\t}\n\tif !contains(perm, \"data2\") {\n\t\tt.Errorf(\"Test error: Alice cannot read data2\")\n\t}\n\tperm, ok = aliceTarget[\"write\"]\n\tif !ok {\n\t\tt.Errorf(\"Test error: Alice doesn't have write permission\")\n\t}\n\tif contains(perm, \"data1\") {\n\t\tt.Errorf(\"Test error: Alice can write data1\")\n\t}\n\tif !contains(perm, \"data2\") {\n\t\tt.Errorf(\"Test error: Alice cannot write data2\")\n\t}\n\n\ttargetStr, _ = CasbinJsGetPermissionForUserOld(e, \"bob\")\n\tt.Log(\"GetPermissionForUser Bob\", string(targetStr))\n\tbobTarget := make(map[string][]string)\n\terr = json.Unmarshal(targetStr, &bobTarget)\n\tif err != nil {\n\t\tt.Errorf(\"Test error: %s\", err)\n\t}\n\t_, ok = bobTarget[\"read\"]\n\tif ok {\n\t\tt.Errorf(\"Test error: Bob has read permission\")\n\t}\n\tperm, ok = bobTarget[\"write\"]\n\tif !ok {\n\t\tt.Errorf(\"Test error: Bob doesn't have permission\")\n\t}\n\tif !contains(perm, \"data2\") {\n\t\tt.Errorf(\"Test error: Bob cannot write data2\")\n\t}\n\tif contains(perm, \"data1\") {\n\t\tt.Errorf(\"Test error: Bob can write data1\")\n\t}\n\tif contains(perm, \"data_not_exist\") {\n\t\tt.Errorf(\"Test error: Bob can access a non-existing data\")\n\t}\n\n\t_, ok = bobTarget[\"rm_rf\"]\n\tif ok {\n\t\tt.Errorf(\"Someone can have a non-existing action (rm -rf)\")\n\t}\n}\n"
        },
        {
          "name": "frontend_test.go",
          "type": "blob",
          "size": 2.12109375,
          "content": "// Copyright 2020 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestCasbinJsGetPermissionForUser(t *testing.T) {\n\te, err := NewSyncedEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_with_hierarchy_policy.csv\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treceivedString, err := CasbinJsGetPermissionForUser(e, \"alice\") // make sure CasbinJsGetPermissionForUser can be used with a SyncedEnforcer.\n\tif err != nil {\n\t\tt.Errorf(\"Test error: %s\", err)\n\t}\n\treceived := map[string]interface{}{}\n\terr = json.Unmarshal([]byte(receivedString), &received)\n\tif err != nil {\n\t\tt.Errorf(\"Test error: %s\", err)\n\t}\n\texpectedModel, err := ioutil.ReadFile(\"examples/rbac_model.conf\")\n\tif err != nil {\n\t\tt.Errorf(\"Test error: %s\", err)\n\t}\n\texpectedModelStr := regexp.MustCompile(\"\\n+\").ReplaceAllString(string(expectedModel), \"\\n\")\n\tif strings.TrimSpace(received[\"m\"].(string)) != expectedModelStr {\n\t\tt.Errorf(\"%s supposed to be %s\", strings.TrimSpace(received[\"m\"].(string)), expectedModelStr)\n\t}\n\n\texpectedPolicies, err := ioutil.ReadFile(\"examples/rbac_with_hierarchy_policy.csv\")\n\tif err != nil {\n\t\tt.Errorf(\"Test error: %s\", err)\n\t}\n\texpectedPoliciesItem := regexp.MustCompile(\",|\\n\").Split(string(expectedPolicies), -1)\n\ti := 0\n\tfor _, sArr := range received[\"p\"].([]interface{}) {\n\t\tfor _, s := range sArr.([]interface{}) {\n\t\t\tif strings.TrimSpace(s.(string)) != strings.TrimSpace(expectedPoliciesItem[i]) {\n\t\t\t\tt.Errorf(\"%s supposed to be %s\", strings.TrimSpace(s.(string)), strings.TrimSpace(expectedPoliciesItem[i]))\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1611328125,
          "content": "module github.com/casbin/casbin/v2\n\nrequire (\n\tgithub.com/bmatcuk/doublestar/v4 v4.6.1\n\tgithub.com/casbin/govaluate v1.3.0\n\tgithub.com/golang/mock v1.4.4\n)\n\ngo 1.13\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.11328125,
          "content": "github.com/bmatcuk/doublestar/v4 v4.6.1 h1:FH9SifrbvJhnlQpztAx++wlkk70QBf0iBWDwNy7PA4I=\ngithub.com/bmatcuk/doublestar/v4 v4.6.1/go.mod h1:xBQ8jztBU6kakFMg+8WGxn0c6z1fTSPVIjEY1Wr7jzc=\ngithub.com/casbin/govaluate v1.3.0 h1:VA0eSY0M2lA86dYd5kPPuNZMUD9QkWnOCnavGrw9myc=\ngithub.com/casbin/govaluate v1.3.0/go.mod h1:G/UnbIjZk/0uMNaLwZZmFQrR72tYRZWQkO70si/iR7A=\ngithub.com/golang/mock v1.4.4 h1:l75CXGRSwbaYNpl/Z2X1XIIAMSCquvXgpVZDhwEIJsc=\ngithub.com/golang/mock v1.4.4/go.mod h1:l3mdAwkq5BuhzHwde/uurv3sEJeZMXNpwsxVWU71h+4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\n"
        },
        {
          "name": "internal_api.go",
          "type": "blob",
          "size": 13.4755859375,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"fmt\"\n\n\tErr \"github.com/casbin/casbin/v2/errors\"\n\t\"github.com/casbin/casbin/v2/model\"\n\t\"github.com/casbin/casbin/v2/persist\"\n)\n\nconst (\n\tnotImplemented = \"not implemented\"\n)\n\nfunc (e *Enforcer) shouldPersist() bool {\n\treturn e.adapter != nil && e.autoSave\n}\n\nfunc (e *Enforcer) shouldNotify() bool {\n\treturn e.watcher != nil && e.autoNotifyWatcher\n}\n\n// addPolicy adds a rule to the current policy.\nfunc (e *Enforcer) addPolicyWithoutNotify(sec string, ptype string, rule []string) (bool, error) {\n\tif e.dispatcher != nil && e.autoNotifyDispatcher {\n\t\treturn true, e.dispatcher.AddPolicies(sec, ptype, [][]string{rule})\n\t}\n\n\thasPolicy, err := e.model.HasPolicy(sec, ptype, rule)\n\tif hasPolicy || err != nil {\n\t\treturn hasPolicy, err\n\t}\n\n\tif e.shouldPersist() {\n\t\tif err = e.adapter.AddPolicy(sec, ptype, rule); err != nil {\n\t\t\tif err.Error() != notImplemented {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t}\n\t}\n\n\terr = e.model.AddPolicy(sec, ptype, rule)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif sec == \"g\" {\n\t\terr := e.BuildIncrementalRoleLinks(model.PolicyAdd, ptype, [][]string{rule})\n\t\tif err != nil {\n\t\t\treturn true, err\n\t\t}\n\t}\n\n\treturn true, nil\n}\n\n// addPoliciesWithoutNotify adds rules to the current policy without notify\n// If autoRemoveRepeat == true, existing rules are automatically filtered\n// Otherwise, false is returned directly.\nfunc (e *Enforcer) addPoliciesWithoutNotify(sec string, ptype string, rules [][]string, autoRemoveRepeat bool) (bool, error) {\n\tif e.dispatcher != nil && e.autoNotifyDispatcher {\n\t\treturn true, e.dispatcher.AddPolicies(sec, ptype, rules)\n\t}\n\n\tif !autoRemoveRepeat {\n\t\thasPolicies, err := e.model.HasPolicies(sec, ptype, rules)\n\t\tif hasPolicies || err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\tif e.shouldPersist() {\n\t\tif err := e.adapter.(persist.BatchAdapter).AddPolicies(sec, ptype, rules); err != nil {\n\t\t\tif err.Error() != notImplemented {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t}\n\t}\n\n\terr := e.model.AddPolicies(sec, ptype, rules)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif sec == \"g\" {\n\t\terr := e.BuildIncrementalRoleLinks(model.PolicyAdd, ptype, rules)\n\t\tif err != nil {\n\t\t\treturn true, err\n\t\t}\n\n\t\terr = e.BuildIncrementalConditionalRoleLinks(model.PolicyAdd, ptype, rules)\n\t\tif err != nil {\n\t\t\treturn true, err\n\t\t}\n\t}\n\n\treturn true, nil\n}\n\n// removePolicy removes a rule from the current policy.\nfunc (e *Enforcer) removePolicyWithoutNotify(sec string, ptype string, rule []string) (bool, error) {\n\tif e.dispatcher != nil && e.autoNotifyDispatcher {\n\t\treturn true, e.dispatcher.RemovePolicies(sec, ptype, [][]string{rule})\n\t}\n\n\tif e.shouldPersist() {\n\t\tif err := e.adapter.RemovePolicy(sec, ptype, rule); err != nil {\n\t\t\tif err.Error() != notImplemented {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t}\n\t}\n\n\truleRemoved, err := e.model.RemovePolicy(sec, ptype, rule)\n\tif !ruleRemoved || err != nil {\n\t\treturn ruleRemoved, err\n\t}\n\n\tif sec == \"g\" {\n\t\terr := e.BuildIncrementalRoleLinks(model.PolicyRemove, ptype, [][]string{rule})\n\t\tif err != nil {\n\t\t\treturn ruleRemoved, err\n\t\t}\n\t}\n\n\treturn ruleRemoved, nil\n}\n\nfunc (e *Enforcer) updatePolicyWithoutNotify(sec string, ptype string, oldRule []string, newRule []string) (bool, error) {\n\tif e.dispatcher != nil && e.autoNotifyDispatcher {\n\t\treturn true, e.dispatcher.UpdatePolicy(sec, ptype, oldRule, newRule)\n\t}\n\n\tif e.shouldPersist() {\n\t\tif err := e.adapter.(persist.UpdatableAdapter).UpdatePolicy(sec, ptype, oldRule, newRule); err != nil {\n\t\t\tif err.Error() != notImplemented {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t}\n\t}\n\truleUpdated, err := e.model.UpdatePolicy(sec, ptype, oldRule, newRule)\n\tif !ruleUpdated || err != nil {\n\t\treturn ruleUpdated, err\n\t}\n\n\tif sec == \"g\" {\n\t\terr := e.BuildIncrementalRoleLinks(model.PolicyRemove, ptype, [][]string{oldRule}) // remove the old rule\n\t\tif err != nil {\n\t\t\treturn ruleUpdated, err\n\t\t}\n\t\terr = e.BuildIncrementalRoleLinks(model.PolicyAdd, ptype, [][]string{newRule}) // add the new rule\n\t\tif err != nil {\n\t\t\treturn ruleUpdated, err\n\t\t}\n\t}\n\n\treturn ruleUpdated, nil\n}\n\nfunc (e *Enforcer) updatePoliciesWithoutNotify(sec string, ptype string, oldRules [][]string, newRules [][]string) (bool, error) {\n\tif len(newRules) != len(oldRules) {\n\t\treturn false, fmt.Errorf(\"the length of oldRules should be equal to the length of newRules, but got the length of oldRules is %d, the length of newRules is %d\", len(oldRules), len(newRules))\n\t}\n\n\tif e.dispatcher != nil && e.autoNotifyDispatcher {\n\t\treturn true, e.dispatcher.UpdatePolicies(sec, ptype, oldRules, newRules)\n\t}\n\n\tif e.shouldPersist() {\n\t\tif err := e.adapter.(persist.UpdatableAdapter).UpdatePolicies(sec, ptype, oldRules, newRules); err != nil {\n\t\t\tif err.Error() != notImplemented {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t}\n\t}\n\n\truleUpdated, err := e.model.UpdatePolicies(sec, ptype, oldRules, newRules)\n\tif !ruleUpdated || err != nil {\n\t\treturn ruleUpdated, err\n\t}\n\n\tif sec == \"g\" {\n\t\terr := e.BuildIncrementalRoleLinks(model.PolicyRemove, ptype, oldRules) // remove the old rules\n\t\tif err != nil {\n\t\t\treturn ruleUpdated, err\n\t\t}\n\t\terr = e.BuildIncrementalRoleLinks(model.PolicyAdd, ptype, newRules) // add the new rules\n\t\tif err != nil {\n\t\t\treturn ruleUpdated, err\n\t\t}\n\t}\n\n\treturn ruleUpdated, nil\n}\n\n// removePolicies removes rules from the current policy.\nfunc (e *Enforcer) removePoliciesWithoutNotify(sec string, ptype string, rules [][]string) (bool, error) {\n\tif hasPolicies, err := e.model.HasPolicies(sec, ptype, rules); !hasPolicies || err != nil {\n\t\treturn hasPolicies, err\n\t}\n\n\tif e.dispatcher != nil && e.autoNotifyDispatcher {\n\t\treturn true, e.dispatcher.RemovePolicies(sec, ptype, rules)\n\t}\n\n\tif e.shouldPersist() {\n\t\tif err := e.adapter.(persist.BatchAdapter).RemovePolicies(sec, ptype, rules); err != nil {\n\t\t\tif err.Error() != notImplemented {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t}\n\t}\n\n\trulesRemoved, err := e.model.RemovePolicies(sec, ptype, rules)\n\tif !rulesRemoved || err != nil {\n\t\treturn rulesRemoved, err\n\t}\n\n\tif sec == \"g\" {\n\t\terr := e.BuildIncrementalRoleLinks(model.PolicyRemove, ptype, rules)\n\t\tif err != nil {\n\t\t\treturn rulesRemoved, err\n\t\t}\n\t}\n\treturn rulesRemoved, nil\n}\n\n// removeFilteredPolicy removes rules based on field filters from the current policy.\nfunc (e *Enforcer) removeFilteredPolicyWithoutNotify(sec string, ptype string, fieldIndex int, fieldValues []string) (bool, error) {\n\tif len(fieldValues) == 0 {\n\t\treturn false, Err.ErrInvalidFieldValuesParameter\n\t}\n\n\tif e.dispatcher != nil && e.autoNotifyDispatcher {\n\t\treturn true, e.dispatcher.RemoveFilteredPolicy(sec, ptype, fieldIndex, fieldValues...)\n\t}\n\n\tif e.shouldPersist() {\n\t\tif err := e.adapter.RemoveFilteredPolicy(sec, ptype, fieldIndex, fieldValues...); err != nil {\n\t\t\tif err.Error() != notImplemented {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t}\n\t}\n\n\truleRemoved, effects, err := e.model.RemoveFilteredPolicy(sec, ptype, fieldIndex, fieldValues...)\n\tif !ruleRemoved || err != nil {\n\t\treturn ruleRemoved, err\n\t}\n\n\tif sec == \"g\" {\n\t\terr := e.BuildIncrementalRoleLinks(model.PolicyRemove, ptype, effects)\n\t\tif err != nil {\n\t\t\treturn ruleRemoved, err\n\t\t}\n\t}\n\n\treturn ruleRemoved, nil\n}\n\nfunc (e *Enforcer) updateFilteredPoliciesWithoutNotify(sec string, ptype string, newRules [][]string, fieldIndex int, fieldValues ...string) ([][]string, error) {\n\tvar (\n\t\toldRules [][]string\n\t\terr      error\n\t)\n\n\tif _, err = e.model.GetAssertion(sec, ptype); err != nil {\n\t\treturn oldRules, err\n\t}\n\n\tif e.shouldPersist() {\n\t\tif oldRules, err = e.adapter.(persist.UpdatableAdapter).UpdateFilteredPolicies(sec, ptype, newRules, fieldIndex, fieldValues...); err != nil {\n\t\t\tif err.Error() != notImplemented {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\t// For compatibility, because some adapters return oldRules containing ptype, see https://github.com/casbin/xorm-adapter/issues/49\n\t\tfor i, oldRule := range oldRules {\n\t\t\tif len(oldRules[i]) == len(e.model[sec][ptype].Tokens)+1 {\n\t\t\t\toldRules[i] = oldRule[1:]\n\t\t\t}\n\t\t}\n\t}\n\n\tif e.dispatcher != nil && e.autoNotifyDispatcher {\n\t\treturn oldRules, e.dispatcher.UpdateFilteredPolicies(sec, ptype, oldRules, newRules)\n\t}\n\n\truleChanged, err := e.model.RemovePolicies(sec, ptype, oldRules)\n\tif err != nil {\n\t\treturn oldRules, err\n\t}\n\terr = e.model.AddPolicies(sec, ptype, newRules)\n\tif err != nil {\n\t\treturn oldRules, err\n\t}\n\truleChanged = ruleChanged && len(newRules) != 0\n\tif !ruleChanged {\n\t\treturn make([][]string, 0), nil\n\t}\n\n\tif sec == \"g\" {\n\t\terr := e.BuildIncrementalRoleLinks(model.PolicyRemove, ptype, oldRules) // remove the old rules\n\t\tif err != nil {\n\t\t\treturn oldRules, err\n\t\t}\n\t\terr = e.BuildIncrementalRoleLinks(model.PolicyAdd, ptype, newRules) // add the new rules\n\t\tif err != nil {\n\t\t\treturn oldRules, err\n\t\t}\n\t}\n\n\treturn oldRules, nil\n}\n\n// addPolicy adds a rule to the current policy.\nfunc (e *Enforcer) addPolicy(sec string, ptype string, rule []string) (bool, error) {\n\tok, err := e.addPolicyWithoutNotify(sec, ptype, rule)\n\tif !ok || err != nil {\n\t\treturn ok, err\n\t}\n\n\tif e.shouldNotify() {\n\t\tvar err error\n\t\tif watcher, ok := e.watcher.(persist.WatcherEx); ok {\n\t\t\terr = watcher.UpdateForAddPolicy(sec, ptype, rule...)\n\t\t} else {\n\t\t\terr = e.watcher.Update()\n\t\t}\n\t\treturn true, err\n\t}\n\n\treturn true, nil\n}\n\n// addPolicies adds rules to the current policy.\n// If autoRemoveRepeat == true, existing rules are automatically filtered\n// Otherwise, false is returned directly.\nfunc (e *Enforcer) addPolicies(sec string, ptype string, rules [][]string, autoRemoveRepeat bool) (bool, error) {\n\tok, err := e.addPoliciesWithoutNotify(sec, ptype, rules, autoRemoveRepeat)\n\tif !ok || err != nil {\n\t\treturn ok, err\n\t}\n\n\tif e.shouldNotify() {\n\t\tvar err error\n\t\tif watcher, ok := e.watcher.(persist.WatcherEx); ok {\n\t\t\terr = watcher.UpdateForAddPolicies(sec, ptype, rules...)\n\t\t} else {\n\t\t\terr = e.watcher.Update()\n\t\t}\n\t\treturn true, err\n\t}\n\n\treturn true, nil\n}\n\n// removePolicy removes a rule from the current policy.\nfunc (e *Enforcer) removePolicy(sec string, ptype string, rule []string) (bool, error) {\n\tok, err := e.removePolicyWithoutNotify(sec, ptype, rule)\n\tif !ok || err != nil {\n\t\treturn ok, err\n\t}\n\n\tif e.shouldNotify() {\n\t\tvar err error\n\t\tif watcher, ok := e.watcher.(persist.WatcherEx); ok {\n\t\t\terr = watcher.UpdateForRemovePolicy(sec, ptype, rule...)\n\t\t} else {\n\t\t\terr = e.watcher.Update()\n\t\t}\n\t\treturn true, err\n\t}\n\n\treturn true, nil\n}\n\nfunc (e *Enforcer) updatePolicy(sec string, ptype string, oldRule []string, newRule []string) (bool, error) {\n\tok, err := e.updatePolicyWithoutNotify(sec, ptype, oldRule, newRule)\n\tif !ok || err != nil {\n\t\treturn ok, err\n\t}\n\n\tif e.shouldNotify() {\n\t\tvar err error\n\t\tif watcher, ok := e.watcher.(persist.UpdatableWatcher); ok {\n\t\t\terr = watcher.UpdateForUpdatePolicy(sec, ptype, oldRule, newRule)\n\t\t} else {\n\t\t\terr = e.watcher.Update()\n\t\t}\n\t\treturn true, err\n\t}\n\n\treturn true, nil\n}\n\nfunc (e *Enforcer) updatePolicies(sec string, ptype string, oldRules [][]string, newRules [][]string) (bool, error) {\n\tok, err := e.updatePoliciesWithoutNotify(sec, ptype, oldRules, newRules)\n\tif !ok || err != nil {\n\t\treturn ok, err\n\t}\n\n\tif e.shouldNotify() {\n\t\tvar err error\n\t\tif watcher, ok := e.watcher.(persist.UpdatableWatcher); ok {\n\t\t\terr = watcher.UpdateForUpdatePolicies(sec, ptype, oldRules, newRules)\n\t\t} else {\n\t\t\terr = e.watcher.Update()\n\t\t}\n\t\treturn true, err\n\t}\n\n\treturn true, nil\n}\n\n// removePolicies removes rules from the current policy.\nfunc (e *Enforcer) removePolicies(sec string, ptype string, rules [][]string) (bool, error) {\n\tok, err := e.removePoliciesWithoutNotify(sec, ptype, rules)\n\tif !ok || err != nil {\n\t\treturn ok, err\n\t}\n\n\tif e.shouldNotify() {\n\t\tvar err error\n\t\tif watcher, ok := e.watcher.(persist.WatcherEx); ok {\n\t\t\terr = watcher.UpdateForRemovePolicies(sec, ptype, rules...)\n\t\t} else {\n\t\t\terr = e.watcher.Update()\n\t\t}\n\t\treturn true, err\n\t}\n\n\treturn true, nil\n}\n\n// removeFilteredPolicy removes rules based on field filters from the current policy.\nfunc (e *Enforcer) removeFilteredPolicy(sec string, ptype string, fieldIndex int, fieldValues []string) (bool, error) {\n\tok, err := e.removeFilteredPolicyWithoutNotify(sec, ptype, fieldIndex, fieldValues)\n\tif !ok || err != nil {\n\t\treturn ok, err\n\t}\n\n\tif e.shouldNotify() {\n\t\tvar err error\n\t\tif watcher, ok := e.watcher.(persist.WatcherEx); ok {\n\t\t\terr = watcher.UpdateForRemoveFilteredPolicy(sec, ptype, fieldIndex, fieldValues...)\n\t\t} else {\n\t\t\terr = e.watcher.Update()\n\t\t}\n\t\treturn true, err\n\t}\n\n\treturn true, nil\n}\n\nfunc (e *Enforcer) updateFilteredPolicies(sec string, ptype string, newRules [][]string, fieldIndex int, fieldValues ...string) (bool, error) {\n\toldRules, err := e.updateFilteredPoliciesWithoutNotify(sec, ptype, newRules, fieldIndex, fieldValues...)\n\tok := len(oldRules) != 0\n\tif !ok || err != nil {\n\t\treturn ok, err\n\t}\n\n\tif e.shouldNotify() {\n\t\tvar err error\n\t\tif watcher, ok := e.watcher.(persist.UpdatableWatcher); ok {\n\t\t\terr = watcher.UpdateForUpdatePolicies(sec, ptype, oldRules, newRules)\n\t\t} else {\n\t\t\terr = e.watcher.Update()\n\t\t}\n\t\treturn true, err\n\t}\n\n\treturn true, nil\n}\n\nfunc (e *Enforcer) GetFieldIndex(ptype string, field string) (int, error) {\n\treturn e.model.GetFieldIndex(ptype, field)\n}\n\nfunc (e *Enforcer) SetFieldIndex(ptype string, field string, index int) {\n\tassertion := e.model[\"p\"][ptype]\n\tassertion.FieldIndexMap[field] = index\n}\n"
        },
        {
          "name": "log",
          "type": "tree",
          "content": null
        },
        {
          "name": "management_api.go",
          "type": "blob",
          "size": 19.6123046875,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/casbin/casbin/v2/constant\"\n\t\"github.com/casbin/casbin/v2/util\"\n\t\"github.com/casbin/govaluate\"\n)\n\n// GetAllSubjects gets the list of subjects that show up in the current policy.\nfunc (e *Enforcer) GetAllSubjects() ([]string, error) {\n\treturn e.model.GetValuesForFieldInPolicyAllTypesByName(\"p\", constant.SubjectIndex)\n}\n\n// GetAllNamedSubjects gets the list of subjects that show up in the current named policy.\nfunc (e *Enforcer) GetAllNamedSubjects(ptype string) ([]string, error) {\n\tfieldIndex, err := e.model.GetFieldIndex(ptype, constant.SubjectIndex)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn e.model.GetValuesForFieldInPolicy(\"p\", ptype, fieldIndex)\n}\n\n// GetAllObjects gets the list of objects that show up in the current policy.\nfunc (e *Enforcer) GetAllObjects() ([]string, error) {\n\treturn e.model.GetValuesForFieldInPolicyAllTypesByName(\"p\", constant.ObjectIndex)\n}\n\n// GetAllNamedObjects gets the list of objects that show up in the current named policy.\nfunc (e *Enforcer) GetAllNamedObjects(ptype string) ([]string, error) {\n\tfieldIndex, err := e.model.GetFieldIndex(ptype, constant.ObjectIndex)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn e.model.GetValuesForFieldInPolicy(\"p\", ptype, fieldIndex)\n}\n\n// GetAllActions gets the list of actions that show up in the current policy.\nfunc (e *Enforcer) GetAllActions() ([]string, error) {\n\treturn e.model.GetValuesForFieldInPolicyAllTypesByName(\"p\", constant.ActionIndex)\n}\n\n// GetAllNamedActions gets the list of actions that show up in the current named policy.\nfunc (e *Enforcer) GetAllNamedActions(ptype string) ([]string, error) {\n\tfieldIndex, err := e.model.GetFieldIndex(ptype, constant.ActionIndex)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn e.model.GetValuesForFieldInPolicy(\"p\", ptype, fieldIndex)\n}\n\n// GetAllRoles gets the list of roles that show up in the current policy.\nfunc (e *Enforcer) GetAllRoles() ([]string, error) {\n\treturn e.model.GetValuesForFieldInPolicyAllTypes(\"g\", 1)\n}\n\n// GetAllNamedRoles gets the list of roles that show up in the current named policy.\nfunc (e *Enforcer) GetAllNamedRoles(ptype string) ([]string, error) {\n\treturn e.model.GetValuesForFieldInPolicy(\"g\", ptype, 1)\n}\n\n// GetPolicy gets all the authorization rules in the policy.\nfunc (e *Enforcer) GetPolicy() ([][]string, error) {\n\treturn e.GetNamedPolicy(\"p\")\n}\n\n// GetFilteredPolicy gets all the authorization rules in the policy, field filters can be specified.\nfunc (e *Enforcer) GetFilteredPolicy(fieldIndex int, fieldValues ...string) ([][]string, error) {\n\treturn e.GetFilteredNamedPolicy(\"p\", fieldIndex, fieldValues...)\n}\n\n// GetNamedPolicy gets all the authorization rules in the named policy.\nfunc (e *Enforcer) GetNamedPolicy(ptype string) ([][]string, error) {\n\treturn e.model.GetPolicy(\"p\", ptype)\n}\n\n// GetFilteredNamedPolicy gets all the authorization rules in the named policy, field filters can be specified.\nfunc (e *Enforcer) GetFilteredNamedPolicy(ptype string, fieldIndex int, fieldValues ...string) ([][]string, error) {\n\treturn e.model.GetFilteredPolicy(\"p\", ptype, fieldIndex, fieldValues...)\n}\n\n// GetGroupingPolicy gets all the role inheritance rules in the policy.\nfunc (e *Enforcer) GetGroupingPolicy() ([][]string, error) {\n\treturn e.GetNamedGroupingPolicy(\"g\")\n}\n\n// GetFilteredGroupingPolicy gets all the role inheritance rules in the policy, field filters can be specified.\nfunc (e *Enforcer) GetFilteredGroupingPolicy(fieldIndex int, fieldValues ...string) ([][]string, error) {\n\treturn e.GetFilteredNamedGroupingPolicy(\"g\", fieldIndex, fieldValues...)\n}\n\n// GetNamedGroupingPolicy gets all the role inheritance rules in the policy.\nfunc (e *Enforcer) GetNamedGroupingPolicy(ptype string) ([][]string, error) {\n\treturn e.model.GetPolicy(\"g\", ptype)\n}\n\n// GetFilteredNamedGroupingPolicy gets all the role inheritance rules in the policy, field filters can be specified.\nfunc (e *Enforcer) GetFilteredNamedGroupingPolicy(ptype string, fieldIndex int, fieldValues ...string) ([][]string, error) {\n\treturn e.model.GetFilteredPolicy(\"g\", ptype, fieldIndex, fieldValues...)\n}\n\n// GetFilteredNamedPolicyWithMatcher gets rules based on matcher from the policy.\nfunc (e *Enforcer) GetFilteredNamedPolicyWithMatcher(ptype string, matcher string) ([][]string, error) {\n\tvar res [][]string\n\tvar err error\n\n\tfunctions := e.fm.GetFunctions()\n\tif _, ok := e.model[\"g\"]; ok {\n\t\tfor key, ast := range e.model[\"g\"] {\n\t\t\t// g must be a normal role definition (ast.RM != nil)\n\t\t\t//   or a conditional role definition (ast.CondRM != nil)\n\t\t\t// ast.RM and ast.CondRM shouldn't be nil at the same time\n\t\t\tif ast.RM != nil {\n\t\t\t\tfunctions[key] = util.GenerateGFunction(ast.RM)\n\t\t\t}\n\t\t\tif ast.CondRM != nil {\n\t\t\t\tfunctions[key] = util.GenerateConditionalGFunction(ast.CondRM)\n\t\t\t}\n\t\t}\n\t}\n\n\tvar expString string\n\tif matcher == \"\" {\n\t\treturn res, fmt.Errorf(\"matcher is empty\")\n\t} else {\n\t\texpString = util.RemoveComments(util.EscapeAssertion(matcher))\n\t}\n\n\tvar expression *govaluate.EvaluableExpression\n\n\texpression, err = govaluate.NewEvaluableExpressionWithFunctions(expString, functions)\n\tif err != nil {\n\t\treturn res, err\n\t}\n\n\tpTokens := make(map[string]int, len(e.model[\"p\"][ptype].Tokens))\n\tfor i, token := range e.model[\"p\"][ptype].Tokens {\n\t\tpTokens[token] = i\n\t}\n\n\tparameters := enforceParameters{\n\t\tpTokens: pTokens,\n\t}\n\n\tif policyLen := len(e.model[\"p\"][ptype].Policy); policyLen != 0 && strings.Contains(expString, ptype+\"_\") {\n\t\tfor _, pvals := range e.model[\"p\"][ptype].Policy {\n\t\t\tif len(e.model[\"p\"][ptype].Tokens) != len(pvals) {\n\t\t\t\treturn res, fmt.Errorf(\n\t\t\t\t\t\"invalid policy size: expected %d, got %d, pvals: %v\",\n\t\t\t\t\tlen(e.model[\"p\"][ptype].Tokens),\n\t\t\t\t\tlen(pvals),\n\t\t\t\t\tpvals)\n\t\t\t}\n\n\t\t\tparameters.pVals = pvals\n\n\t\t\tresult, err := expression.Eval(parameters)\n\n\t\t\tif err != nil {\n\t\t\t\treturn res, err\n\t\t\t}\n\n\t\t\tswitch result := result.(type) {\n\t\t\tcase bool:\n\t\t\t\tif result {\n\t\t\t\t\tres = append(res, pvals)\n\t\t\t\t}\n\t\t\tcase float64:\n\t\t\t\tif result != 0 {\n\t\t\t\t\tres = append(res, pvals)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn res, errors.New(\"matcher result should be bool, int or float\")\n\t\t\t}\n\t\t}\n\t}\n\treturn res, nil\n}\n\n// HasPolicy determines whether an authorization rule exists.\nfunc (e *Enforcer) HasPolicy(params ...interface{}) (bool, error) {\n\treturn e.HasNamedPolicy(\"p\", params...)\n}\n\n// HasNamedPolicy determines whether a named authorization rule exists.\nfunc (e *Enforcer) HasNamedPolicy(ptype string, params ...interface{}) (bool, error) {\n\tif strSlice, ok := params[0].([]string); len(params) == 1 && ok {\n\t\treturn e.model.HasPolicy(\"p\", ptype, strSlice)\n\t}\n\n\tpolicy := make([]string, 0)\n\tfor _, param := range params {\n\t\tpolicy = append(policy, param.(string))\n\t}\n\n\treturn e.model.HasPolicy(\"p\", ptype, policy)\n}\n\n// AddPolicy adds an authorization rule to the current policy.\n// If the rule already exists, the function returns false and the rule will not be added.\n// Otherwise the function returns true by adding the new rule.\nfunc (e *Enforcer) AddPolicy(params ...interface{}) (bool, error) {\n\treturn e.AddNamedPolicy(\"p\", params...)\n}\n\n// AddPolicies adds authorization rules to the current policy.\n// If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n// Otherwise the function returns true for the corresponding rule by adding the new rule.\nfunc (e *Enforcer) AddPolicies(rules [][]string) (bool, error) {\n\treturn e.AddNamedPolicies(\"p\", rules)\n}\n\n// AddPoliciesEx adds authorization rules to the current policy.\n// If the rule already exists, the rule will not be added.\n// But unlike AddPolicies, other non-existent rules are added instead of returning false directly.\nfunc (e *Enforcer) AddPoliciesEx(rules [][]string) (bool, error) {\n\treturn e.AddNamedPoliciesEx(\"p\", rules)\n}\n\n// AddNamedPolicy adds an authorization rule to the current named policy.\n// If the rule already exists, the function returns false and the rule will not be added.\n// Otherwise the function returns true by adding the new rule.\nfunc (e *Enforcer) AddNamedPolicy(ptype string, params ...interface{}) (bool, error) {\n\tif strSlice, ok := params[0].([]string); len(params) == 1 && ok {\n\t\tstrSlice = append(make([]string, 0, len(strSlice)), strSlice...)\n\t\treturn e.addPolicy(\"p\", ptype, strSlice)\n\t}\n\tpolicy := make([]string, 0)\n\tfor _, param := range params {\n\t\tpolicy = append(policy, param.(string))\n\t}\n\n\treturn e.addPolicy(\"p\", ptype, policy)\n}\n\n// AddNamedPolicies adds authorization rules to the current named policy.\n// If the rule already exists, the function returns false for the corresponding rule and the rule will not be added.\n// Otherwise the function returns true for the corresponding by adding the new rule.\nfunc (e *Enforcer) AddNamedPolicies(ptype string, rules [][]string) (bool, error) {\n\treturn e.addPolicies(\"p\", ptype, rules, false)\n}\n\n// AddNamedPoliciesEx adds authorization rules to the current named policy.\n// If the rule already exists, the rule will not be added.\n// But unlike AddNamedPolicies, other non-existent rules are added instead of returning false directly.\nfunc (e *Enforcer) AddNamedPoliciesEx(ptype string, rules [][]string) (bool, error) {\n\treturn e.addPolicies(\"p\", ptype, rules, true)\n}\n\n// RemovePolicy removes an authorization rule from the current policy.\nfunc (e *Enforcer) RemovePolicy(params ...interface{}) (bool, error) {\n\treturn e.RemoveNamedPolicy(\"p\", params...)\n}\n\n// UpdatePolicy updates an authorization rule from the current policy.\nfunc (e *Enforcer) UpdatePolicy(oldPolicy []string, newPolicy []string) (bool, error) {\n\treturn e.UpdateNamedPolicy(\"p\", oldPolicy, newPolicy)\n}\n\nfunc (e *Enforcer) UpdateNamedPolicy(ptype string, p1 []string, p2 []string) (bool, error) {\n\treturn e.updatePolicy(\"p\", ptype, p1, p2)\n}\n\n// UpdatePolicies updates authorization rules from the current policies.\nfunc (e *Enforcer) UpdatePolicies(oldPolices [][]string, newPolicies [][]string) (bool, error) {\n\treturn e.UpdateNamedPolicies(\"p\", oldPolices, newPolicies)\n}\n\nfunc (e *Enforcer) UpdateNamedPolicies(ptype string, p1 [][]string, p2 [][]string) (bool, error) {\n\treturn e.updatePolicies(\"p\", ptype, p1, p2)\n}\n\nfunc (e *Enforcer) UpdateFilteredPolicies(newPolicies [][]string, fieldIndex int, fieldValues ...string) (bool, error) {\n\treturn e.UpdateFilteredNamedPolicies(\"p\", newPolicies, fieldIndex, fieldValues...)\n}\n\nfunc (e *Enforcer) UpdateFilteredNamedPolicies(ptype string, newPolicies [][]string, fieldIndex int, fieldValues ...string) (bool, error) {\n\treturn e.updateFilteredPolicies(\"p\", ptype, newPolicies, fieldIndex, fieldValues...)\n}\n\n// RemovePolicies removes authorization rules from the current policy.\nfunc (e *Enforcer) RemovePolicies(rules [][]string) (bool, error) {\n\treturn e.RemoveNamedPolicies(\"p\", rules)\n}\n\n// RemoveFilteredPolicy removes an authorization rule from the current policy, field filters can be specified.\nfunc (e *Enforcer) RemoveFilteredPolicy(fieldIndex int, fieldValues ...string) (bool, error) {\n\treturn e.RemoveFilteredNamedPolicy(\"p\", fieldIndex, fieldValues...)\n}\n\n// RemoveNamedPolicy removes an authorization rule from the current named policy.\nfunc (e *Enforcer) RemoveNamedPolicy(ptype string, params ...interface{}) (bool, error) {\n\tif strSlice, ok := params[0].([]string); len(params) == 1 && ok {\n\t\treturn e.removePolicy(\"p\", ptype, strSlice)\n\t}\n\tpolicy := make([]string, 0)\n\tfor _, param := range params {\n\t\tpolicy = append(policy, param.(string))\n\t}\n\n\treturn e.removePolicy(\"p\", ptype, policy)\n}\n\n// RemoveNamedPolicies removes authorization rules from the current named policy.\nfunc (e *Enforcer) RemoveNamedPolicies(ptype string, rules [][]string) (bool, error) {\n\treturn e.removePolicies(\"p\", ptype, rules)\n}\n\n// RemoveFilteredNamedPolicy removes an authorization rule from the current named policy, field filters can be specified.\nfunc (e *Enforcer) RemoveFilteredNamedPolicy(ptype string, fieldIndex int, fieldValues ...string) (bool, error) {\n\treturn e.removeFilteredPolicy(\"p\", ptype, fieldIndex, fieldValues)\n}\n\n// HasGroupingPolicy determines whether a role inheritance rule exists.\nfunc (e *Enforcer) HasGroupingPolicy(params ...interface{}) (bool, error) {\n\treturn e.HasNamedGroupingPolicy(\"g\", params...)\n}\n\n// HasNamedGroupingPolicy determines whether a named role inheritance rule exists.\nfunc (e *Enforcer) HasNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error) {\n\tif strSlice, ok := params[0].([]string); len(params) == 1 && ok {\n\t\treturn e.model.HasPolicy(\"g\", ptype, strSlice)\n\t}\n\n\tpolicy := make([]string, 0)\n\tfor _, param := range params {\n\t\tpolicy = append(policy, param.(string))\n\t}\n\n\treturn e.model.HasPolicy(\"g\", ptype, policy)\n}\n\n// AddGroupingPolicy adds a role inheritance rule to the current policy.\n// If the rule already exists, the function returns false and the rule will not be added.\n// Otherwise the function returns true by adding the new rule.\nfunc (e *Enforcer) AddGroupingPolicy(params ...interface{}) (bool, error) {\n\treturn e.AddNamedGroupingPolicy(\"g\", params...)\n}\n\n// AddGroupingPolicies adds role inheritance rules to the current policy.\n// If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n// Otherwise the function returns true for the corresponding policy rule by adding the new rule.\nfunc (e *Enforcer) AddGroupingPolicies(rules [][]string) (bool, error) {\n\treturn e.AddNamedGroupingPolicies(\"g\", rules)\n}\n\n// AddGroupingPoliciesEx adds role inheritance rules to the current policy.\n// If the rule already exists, the rule will not be added.\n// But unlike AddGroupingPolicies, other non-existent rules are added instead of returning false directly.\nfunc (e *Enforcer) AddGroupingPoliciesEx(rules [][]string) (bool, error) {\n\treturn e.AddNamedGroupingPoliciesEx(\"g\", rules)\n}\n\n// AddNamedGroupingPolicy adds a named role inheritance rule to the current policy.\n// If the rule already exists, the function returns false and the rule will not be added.\n// Otherwise the function returns true by adding the new rule.\nfunc (e *Enforcer) AddNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error) {\n\tvar ruleAdded bool\n\tvar err error\n\tif strSlice, ok := params[0].([]string); len(params) == 1 && ok {\n\t\truleAdded, err = e.addPolicy(\"g\", ptype, strSlice)\n\t} else {\n\t\tpolicy := make([]string, 0)\n\t\tfor _, param := range params {\n\t\t\tpolicy = append(policy, param.(string))\n\t\t}\n\n\t\truleAdded, err = e.addPolicy(\"g\", ptype, policy)\n\t}\n\n\treturn ruleAdded, err\n}\n\n// AddNamedGroupingPolicies adds named role inheritance rules to the current policy.\n// If the rule already exists, the function returns false for the corresponding policy rule and the rule will not be added.\n// Otherwise the function returns true for the corresponding policy rule by adding the new rule.\nfunc (e *Enforcer) AddNamedGroupingPolicies(ptype string, rules [][]string) (bool, error) {\n\treturn e.addPolicies(\"g\", ptype, rules, false)\n}\n\n// AddNamedGroupingPoliciesEx adds named role inheritance rules to the current policy.\n// If the rule already exists, the rule will not be added.\n// But unlike AddNamedGroupingPolicies, other non-existent rules are added instead of returning false directly.\nfunc (e *Enforcer) AddNamedGroupingPoliciesEx(ptype string, rules [][]string) (bool, error) {\n\treturn e.addPolicies(\"g\", ptype, rules, true)\n}\n\n// RemoveGroupingPolicy removes a role inheritance rule from the current policy.\nfunc (e *Enforcer) RemoveGroupingPolicy(params ...interface{}) (bool, error) {\n\treturn e.RemoveNamedGroupingPolicy(\"g\", params...)\n}\n\n// RemoveGroupingPolicies removes role inheritance rules from the current policy.\nfunc (e *Enforcer) RemoveGroupingPolicies(rules [][]string) (bool, error) {\n\treturn e.RemoveNamedGroupingPolicies(\"g\", rules)\n}\n\n// RemoveFilteredGroupingPolicy removes a role inheritance rule from the current policy, field filters can be specified.\nfunc (e *Enforcer) RemoveFilteredGroupingPolicy(fieldIndex int, fieldValues ...string) (bool, error) {\n\treturn e.RemoveFilteredNamedGroupingPolicy(\"g\", fieldIndex, fieldValues...)\n}\n\n// RemoveNamedGroupingPolicy removes a role inheritance rule from the current named policy.\nfunc (e *Enforcer) RemoveNamedGroupingPolicy(ptype string, params ...interface{}) (bool, error) {\n\tvar ruleRemoved bool\n\tvar err error\n\tif strSlice, ok := params[0].([]string); len(params) == 1 && ok {\n\t\truleRemoved, err = e.removePolicy(\"g\", ptype, strSlice)\n\t} else {\n\t\tpolicy := make([]string, 0)\n\t\tfor _, param := range params {\n\t\t\tpolicy = append(policy, param.(string))\n\t\t}\n\n\t\truleRemoved, err = e.removePolicy(\"g\", ptype, policy)\n\t}\n\n\treturn ruleRemoved, err\n}\n\n// RemoveNamedGroupingPolicies removes role inheritance rules from the current named policy.\nfunc (e *Enforcer) RemoveNamedGroupingPolicies(ptype string, rules [][]string) (bool, error) {\n\treturn e.removePolicies(\"g\", ptype, rules)\n}\n\nfunc (e *Enforcer) UpdateGroupingPolicy(oldRule []string, newRule []string) (bool, error) {\n\treturn e.UpdateNamedGroupingPolicy(\"g\", oldRule, newRule)\n}\n\n// UpdateGroupingPolicies updates authorization rules from the current policies.\nfunc (e *Enforcer) UpdateGroupingPolicies(oldRules [][]string, newRules [][]string) (bool, error) {\n\treturn e.UpdateNamedGroupingPolicies(\"g\", oldRules, newRules)\n}\n\nfunc (e *Enforcer) UpdateNamedGroupingPolicy(ptype string, oldRule []string, newRule []string) (bool, error) {\n\treturn e.updatePolicy(\"g\", ptype, oldRule, newRule)\n}\n\nfunc (e *Enforcer) UpdateNamedGroupingPolicies(ptype string, oldRules [][]string, newRules [][]string) (bool, error) {\n\treturn e.updatePolicies(\"g\", ptype, oldRules, newRules)\n}\n\n// RemoveFilteredNamedGroupingPolicy removes a role inheritance rule from the current named policy, field filters can be specified.\nfunc (e *Enforcer) RemoveFilteredNamedGroupingPolicy(ptype string, fieldIndex int, fieldValues ...string) (bool, error) {\n\treturn e.removeFilteredPolicy(\"g\", ptype, fieldIndex, fieldValues)\n}\n\n// AddFunction adds a customized function.\nfunc (e *Enforcer) AddFunction(name string, function govaluate.ExpressionFunction) {\n\te.fm.AddFunction(name, function)\n}\n\nfunc (e *Enforcer) SelfAddPolicy(sec string, ptype string, rule []string) (bool, error) {\n\treturn e.addPolicyWithoutNotify(sec, ptype, rule)\n}\n\nfunc (e *Enforcer) SelfAddPolicies(sec string, ptype string, rules [][]string) (bool, error) {\n\treturn e.addPoliciesWithoutNotify(sec, ptype, rules, false)\n}\n\nfunc (e *Enforcer) SelfAddPoliciesEx(sec string, ptype string, rules [][]string) (bool, error) {\n\treturn e.addPoliciesWithoutNotify(sec, ptype, rules, true)\n}\n\nfunc (e *Enforcer) SelfRemovePolicy(sec string, ptype string, rule []string) (bool, error) {\n\treturn e.removePolicyWithoutNotify(sec, ptype, rule)\n}\n\nfunc (e *Enforcer) SelfRemovePolicies(sec string, ptype string, rules [][]string) (bool, error) {\n\treturn e.removePoliciesWithoutNotify(sec, ptype, rules)\n}\n\nfunc (e *Enforcer) SelfRemoveFilteredPolicy(sec string, ptype string, fieldIndex int, fieldValues ...string) (bool, error) {\n\treturn e.removeFilteredPolicyWithoutNotify(sec, ptype, fieldIndex, fieldValues)\n}\n\nfunc (e *Enforcer) SelfUpdatePolicy(sec string, ptype string, oldRule, newRule []string) (bool, error) {\n\treturn e.updatePolicyWithoutNotify(sec, ptype, oldRule, newRule)\n}\n\nfunc (e *Enforcer) SelfUpdatePolicies(sec string, ptype string, oldRules, newRules [][]string) (bool, error) {\n\treturn e.updatePoliciesWithoutNotify(sec, ptype, oldRules, newRules)\n}\n"
        },
        {
          "name": "management_api_test.go",
          "type": "blob",
          "size": 13.869140625,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"testing\"\n\n\t\"github.com/casbin/casbin/v2/util\"\n)\n\nfunc testStringList(t *testing.T, title string, f func() ([]string, error), res []string) {\n\tt.Helper()\n\tmyRes, err := f()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tt.Log(title+\": \", myRes)\n\n\tif !util.ArrayEquals(res, myRes) {\n\t\tt.Error(title+\": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc TestGetList(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\ttestStringList(t, \"Subjects\", e.GetAllSubjects, []string{\"alice\", \"bob\", \"data2_admin\"})\n\ttestStringList(t, \"Objects\", e.GetAllObjects, []string{\"data1\", \"data2\"})\n\ttestStringList(t, \"Actions\", e.GetAllActions, []string{\"read\", \"write\"})\n\ttestStringList(t, \"Roles\", e.GetAllRoles, []string{\"data2_admin\"})\n}\n\nfunc TestGetListWithDomains(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy.csv\")\n\n\ttestStringList(t, \"Subjects\", e.GetAllSubjects, []string{\"admin\"})\n\ttestStringList(t, \"Objects\", e.GetAllObjects, []string{\"data1\", \"data2\"})\n\ttestStringList(t, \"Actions\", e.GetAllActions, []string{\"read\", \"write\"})\n\ttestStringList(t, \"Roles\", e.GetAllRoles, []string{\"admin\"})\n}\n\nfunc testGetPolicy(t *testing.T, e *Enforcer, res [][]string) {\n\tt.Helper()\n\tmyRes, err := e.GetPolicy()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tt.Log(\"Policy: \", myRes)\n\n\tif !util.Array2DEquals(res, myRes) {\n\t\tt.Error(\"Policy: \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc testGetFilteredPolicy(t *testing.T, e *Enforcer, fieldIndex int, res [][]string, fieldValues ...string) {\n\tt.Helper()\n\tmyRes, err := e.GetFilteredPolicy(fieldIndex, fieldValues...)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tt.Log(\"Policy for \", util.ParamsToString(fieldValues...), \": \", myRes)\n\n\tif !util.Array2DEquals(res, myRes) {\n\t\tt.Error(\"Policy for \", util.ParamsToString(fieldValues...), \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc testGetFilteredNamedPolicyWithMatcher(t *testing.T, e *Enforcer, ptype string, matcher string, res [][]string) {\n\tt.Helper()\n\tmyRes, err := e.GetFilteredNamedPolicyWithMatcher(ptype, matcher)\n\tt.Log(\"Policy for\", matcher, \": \", myRes)\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif !util.Array2DEquals(res, myRes) {\n\t\tt.Error(\"Policy for \", matcher, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc testGetGroupingPolicy(t *testing.T, e *Enforcer, res [][]string) {\n\tt.Helper()\n\tmyRes, err := e.GetGroupingPolicy()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tt.Log(\"Grouping policy: \", myRes)\n\n\tif !util.Array2DEquals(res, myRes) {\n\t\tt.Error(\"Grouping policy: \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc testGetFilteredGroupingPolicy(t *testing.T, e *Enforcer, fieldIndex int, res [][]string, fieldValues ...string) {\n\tt.Helper()\n\tmyRes, err := e.GetFilteredGroupingPolicy(fieldIndex, fieldValues...)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tt.Log(\"Grouping policy for \", util.ParamsToString(fieldValues...), \": \", myRes)\n\n\tif !util.Array2DEquals(res, myRes) {\n\t\tt.Error(\"Grouping policy for \", util.ParamsToString(fieldValues...), \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc testHasPolicy(t *testing.T, e *Enforcer, policy []string, res bool) {\n\tt.Helper()\n\tmyRes, err := e.HasPolicy(policy)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tt.Log(\"Has policy \", util.ArrayToString(policy), \": \", myRes)\n\n\tif res != myRes {\n\t\tt.Error(\"Has policy \", util.ArrayToString(policy), \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc testHasGroupingPolicy(t *testing.T, e *Enforcer, policy []string, res bool) {\n\tt.Helper()\n\tmyRes, err := e.HasGroupingPolicy(policy)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tt.Log(\"Has grouping policy \", util.ArrayToString(policy), \": \", myRes)\n\n\tif res != myRes {\n\t\tt.Error(\"Has grouping policy \", util.ArrayToString(policy), \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc TestGetPolicyAPI(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\ttestGetPolicy(t, e, [][]string{\n\t\t{\"alice\", \"data1\", \"read\"},\n\t\t{\"bob\", \"data2\", \"write\"},\n\t\t{\"data2_admin\", \"data2\", \"read\"},\n\t\t{\"data2_admin\", \"data2\", \"write\"}})\n\n\ttestGetFilteredPolicy(t, e, 0, [][]string{{\"alice\", \"data1\", \"read\"}}, \"alice\")\n\ttestGetFilteredPolicy(t, e, 0, [][]string{{\"bob\", \"data2\", \"write\"}}, \"bob\")\n\ttestGetFilteredPolicy(t, e, 0, [][]string{{\"data2_admin\", \"data2\", \"read\"}, {\"data2_admin\", \"data2\", \"write\"}}, \"data2_admin\")\n\ttestGetFilteredPolicy(t, e, 1, [][]string{{\"alice\", \"data1\", \"read\"}}, \"data1\")\n\ttestGetFilteredPolicy(t, e, 1, [][]string{{\"bob\", \"data2\", \"write\"}, {\"data2_admin\", \"data2\", \"read\"}, {\"data2_admin\", \"data2\", \"write\"}}, \"data2\")\n\ttestGetFilteredPolicy(t, e, 2, [][]string{{\"alice\", \"data1\", \"read\"}, {\"data2_admin\", \"data2\", \"read\"}}, \"read\")\n\ttestGetFilteredPolicy(t, e, 2, [][]string{{\"bob\", \"data2\", \"write\"}, {\"data2_admin\", \"data2\", \"write\"}}, \"write\")\n\n\ttestGetFilteredNamedPolicyWithMatcher(t, e, \"p\", \"'alice' == p.sub\", [][]string{{\"alice\", \"data1\", \"read\"}})\n\ttestGetFilteredNamedPolicyWithMatcher(t, e, \"p\", \"keyMatch2(p.sub, '*')\", [][]string{\n\t\t{\"alice\", \"data1\", \"read\"},\n\t\t{\"bob\", \"data2\", \"write\"},\n\t\t{\"data2_admin\", \"data2\", \"read\"},\n\t\t{\"data2_admin\", \"data2\", \"write\"}})\n\n\ttestGetFilteredPolicy(t, e, 0, [][]string{{\"data2_admin\", \"data2\", \"read\"}, {\"data2_admin\", \"data2\", \"write\"}}, \"data2_admin\", \"data2\")\n\t// Note: \"\" (empty string) in fieldValues means matching all values.\n\ttestGetFilteredPolicy(t, e, 0, [][]string{{\"data2_admin\", \"data2\", \"read\"}}, \"data2_admin\", \"\", \"read\")\n\ttestGetFilteredPolicy(t, e, 1, [][]string{{\"bob\", \"data2\", \"write\"}, {\"data2_admin\", \"data2\", \"write\"}}, \"data2\", \"write\")\n\n\ttestHasPolicy(t, e, []string{\"alice\", \"data1\", \"read\"}, true)\n\ttestHasPolicy(t, e, []string{\"bob\", \"data2\", \"write\"}, true)\n\ttestHasPolicy(t, e, []string{\"alice\", \"data2\", \"read\"}, false)\n\ttestHasPolicy(t, e, []string{\"bob\", \"data3\", \"write\"}, false)\n\n\ttestGetGroupingPolicy(t, e, [][]string{{\"alice\", \"data2_admin\"}})\n\n\ttestGetFilteredGroupingPolicy(t, e, 0, [][]string{{\"alice\", \"data2_admin\"}}, \"alice\")\n\ttestGetFilteredGroupingPolicy(t, e, 0, [][]string{}, \"bob\")\n\ttestGetFilteredGroupingPolicy(t, e, 1, [][]string{}, \"data1_admin\")\n\ttestGetFilteredGroupingPolicy(t, e, 1, [][]string{{\"alice\", \"data2_admin\"}}, \"data2_admin\")\n\t// Note: \"\" (empty string) in fieldValues means matching all values.\n\ttestGetFilteredGroupingPolicy(t, e, 0, [][]string{{\"alice\", \"data2_admin\"}}, \"\", \"data2_admin\")\n\n\ttestHasGroupingPolicy(t, e, []string{\"alice\", \"data2_admin\"}, true)\n\ttestHasGroupingPolicy(t, e, []string{\"bob\", \"data2_admin\"}, false)\n}\n\nfunc TestModifyPolicyAPI(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\ttestGetPolicy(t, e, [][]string{\n\t\t{\"alice\", \"data1\", \"read\"},\n\t\t{\"bob\", \"data2\", \"write\"},\n\t\t{\"data2_admin\", \"data2\", \"read\"},\n\t\t{\"data2_admin\", \"data2\", \"write\"}})\n\n\t_, _ = e.RemovePolicy(\"alice\", \"data1\", \"read\")\n\t_, _ = e.RemovePolicy(\"bob\", \"data2\", \"write\")\n\t_, _ = e.RemovePolicy(\"alice\", \"data1\", \"read\")\n\t_, _ = e.AddPolicy(\"eve\", \"data3\", \"read\")\n\t_, _ = e.AddPolicy(\"eve\", \"data3\", \"read\")\n\n\trules := [][]string{\n\t\t{\"jack\", \"data4\", \"read\"},\n\t\t{\"jack\", \"data4\", \"read\"},\n\t\t{\"jack\", \"data4\", \"read\"},\n\t\t{\"katy\", \"data4\", \"write\"},\n\t\t{\"leyo\", \"data4\", \"read\"},\n\t\t{\"katy\", \"data4\", \"write\"},\n\t\t{\"katy\", \"data4\", \"write\"},\n\t\t{\"ham\", \"data4\", \"write\"},\n\t}\n\n\t_, _ = e.AddPolicies(rules)\n\t_, _ = e.AddPolicies(rules)\n\n\ttestGetPolicy(t, e, [][]string{\n\t\t{\"data2_admin\", \"data2\", \"read\"},\n\t\t{\"data2_admin\", \"data2\", \"write\"},\n\t\t{\"eve\", \"data3\", \"read\"},\n\t\t{\"jack\", \"data4\", \"read\"},\n\t\t{\"katy\", \"data4\", \"write\"},\n\t\t{\"leyo\", \"data4\", \"read\"},\n\t\t{\"ham\", \"data4\", \"write\"}})\n\n\t_, _ = e.RemovePolicies(rules)\n\t_, _ = e.RemovePolicies(rules)\n\n\tnamedPolicy := []string{\"eve\", \"data3\", \"read\"}\n\t_, _ = e.RemoveNamedPolicy(\"p\", namedPolicy)\n\t_, _ = e.AddNamedPolicy(\"p\", namedPolicy)\n\n\ttestGetPolicy(t, e, [][]string{\n\t\t{\"data2_admin\", \"data2\", \"read\"},\n\t\t{\"data2_admin\", \"data2\", \"write\"},\n\t\t{\"eve\", \"data3\", \"read\"}})\n\n\t_, _ = e.RemoveFilteredPolicy(1, \"data2\")\n\n\ttestGetPolicy(t, e, [][]string{{\"eve\", \"data3\", \"read\"}})\n\n\t_, _ = e.UpdatePolicy([]string{\"eve\", \"data3\", \"read\"}, []string{\"eve\", \"data3\", \"write\"})\n\n\ttestGetPolicy(t, e, [][]string{{\"eve\", \"data3\", \"write\"}})\n\n\t// This test shows a rollback effect.\n\t// _, _ = e.UpdatePolicies([][]string{{\"eve\", \"data3\", \"write\"}, {\"jack\", \"data4\", \"read\"}}, [][]string{{\"eve\", \"data3\", \"read\"}, {\"jack\", \"data4\", \"write\"}})\n\t// testGetPolicy(t, e, [][]string{{\"eve\", \"data3\", \"read\"}, {\"jack\", \"data4\", \"write\"}})\n\n\t_, _ = e.AddPolicies(rules)\n\t_, _ = e.UpdatePolicies([][]string{{\"eve\", \"data3\", \"write\"}, {\"leyo\", \"data4\", \"read\"}, {\"katy\", \"data4\", \"write\"}},\n\t\t[][]string{{\"eve\", \"data3\", \"read\"}, {\"leyo\", \"data4\", \"write\"}, {\"katy\", \"data1\", \"write\"}})\n\ttestGetPolicy(t, e, [][]string{{\"eve\", \"data3\", \"read\"}, {\"jack\", \"data4\", \"read\"}, {\"katy\", \"data1\", \"write\"}, {\"leyo\", \"data4\", \"write\"}, {\"ham\", \"data4\", \"write\"}})\n\n\te.ClearPolicy()\n\t_, _ = e.AddPoliciesEx([][]string{{\"user1\", \"data1\", \"read\"}, {\"user1\", \"data1\", \"read\"}})\n\ttestGetPolicy(t, e, [][]string{{\"user1\", \"data1\", \"read\"}})\n\t// {\"user1\", \"data1\", \"read\"} repeated\n\t_, _ = e.AddPoliciesEx([][]string{{\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"}})\n\ttestGetPolicy(t, e, [][]string{{\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"}})\n\t// {\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"} repeated\n\t_, _ = e.AddNamedPoliciesEx(\"p\", [][]string{{\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"}, {\"user3\", \"data3\", \"read\"}})\n\ttestGetPolicy(t, e, [][]string{{\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"}, {\"user3\", \"data3\", \"read\"}})\n\t// {\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"}, , {\"user3\", \"data3\", \"read\"} repeated\n\t_, _ = e.SelfAddPoliciesEx(\"p\", \"p\", [][]string{{\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"}, {\"user3\", \"data3\", \"read\"}, {\"user4\", \"data4\", \"read\"}})\n\ttestGetPolicy(t, e, [][]string{{\"user1\", \"data1\", \"read\"}, {\"user2\", \"data2\", \"read\"}, {\"user3\", \"data3\", \"read\"}, {\"user4\", \"data4\", \"read\"}})\n}\n\nfunc TestModifyGroupingPolicyAPI(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\ttestGetRoles(t, e, []string{\"data2_admin\"}, \"alice\")\n\ttestGetRoles(t, e, []string{}, \"bob\")\n\ttestGetRoles(t, e, []string{}, \"eve\")\n\ttestGetRoles(t, e, []string{}, \"non_exist\")\n\n\t_, _ = e.RemoveGroupingPolicy(\"alice\", \"data2_admin\")\n\t_, _ = e.AddGroupingPolicy(\"bob\", \"data1_admin\")\n\t_, _ = e.AddGroupingPolicy(\"eve\", \"data3_admin\")\n\n\tgroupingRules := [][]string{\n\t\t{\"ham\", \"data4_admin\"},\n\t\t{\"jack\", \"data5_admin\"},\n\t}\n\n\t_, _ = e.AddGroupingPolicies(groupingRules)\n\ttestGetRoles(t, e, []string{\"data4_admin\"}, \"ham\")\n\ttestGetRoles(t, e, []string{\"data5_admin\"}, \"jack\")\n\t_, _ = e.RemoveGroupingPolicies(groupingRules)\n\n\ttestGetRoles(t, e, []string{}, \"alice\")\n\tnamedGroupingPolicy := []string{\"alice\", \"data2_admin\"}\n\ttestGetRoles(t, e, []string{}, \"alice\")\n\t_, _ = e.AddNamedGroupingPolicy(\"g\", namedGroupingPolicy)\n\ttestGetRoles(t, e, []string{\"data2_admin\"}, \"alice\")\n\t_, _ = e.RemoveNamedGroupingPolicy(\"g\", namedGroupingPolicy)\n\n\t_, _ = e.AddNamedGroupingPolicies(\"g\", groupingRules)\n\t_, _ = e.AddNamedGroupingPolicies(\"g\", groupingRules)\n\ttestGetRoles(t, e, []string{\"data4_admin\"}, \"ham\")\n\ttestGetRoles(t, e, []string{\"data5_admin\"}, \"jack\")\n\t_, _ = e.RemoveNamedGroupingPolicies(\"g\", groupingRules)\n\t_, _ = e.RemoveNamedGroupingPolicies(\"g\", groupingRules)\n\n\ttestGetRoles(t, e, []string{}, \"alice\")\n\ttestGetRoles(t, e, []string{\"data1_admin\"}, \"bob\")\n\ttestGetRoles(t, e, []string{\"data3_admin\"}, \"eve\")\n\ttestGetRoles(t, e, []string{}, \"non_exist\")\n\n\ttestGetUsers(t, e, []string{\"bob\"}, \"data1_admin\")\n\ttestGetUsers(t, e, []string{}, \"data2_admin\")\n\ttestGetUsers(t, e, []string{\"eve\"}, \"data3_admin\")\n\n\t_, _ = e.RemoveFilteredGroupingPolicy(0, \"bob\")\n\n\ttestGetRoles(t, e, []string{}, \"alice\")\n\ttestGetRoles(t, e, []string{}, \"bob\")\n\ttestGetRoles(t, e, []string{\"data3_admin\"}, \"eve\")\n\ttestGetRoles(t, e, []string{}, \"non_exist\")\n\n\ttestGetUsers(t, e, []string{}, \"data1_admin\")\n\ttestGetUsers(t, e, []string{}, \"data2_admin\")\n\ttestGetUsers(t, e, []string{\"eve\"}, \"data3_admin\")\n\t_, _ = e.AddGroupingPolicy(\"data3_admin\", \"data4_admin\")\n\t_, _ = e.UpdateGroupingPolicy([]string{\"eve\", \"data3_admin\"}, []string{\"eve\", \"admin\"})\n\t_, _ = e.UpdateGroupingPolicy([]string{\"data3_admin\", \"data4_admin\"}, []string{\"admin\", \"data4_admin\"})\n\ttestGetUsers(t, e, []string{\"admin\"}, \"data4_admin\")\n\ttestGetUsers(t, e, []string{\"eve\"}, \"admin\")\n\n\ttestGetRoles(t, e, []string{\"admin\"}, \"eve\")\n\ttestGetRoles(t, e, []string{\"data4_admin\"}, \"admin\")\n\n\t_, _ = e.UpdateGroupingPolicies([][]string{{\"eve\", \"admin\"}}, [][]string{{\"eve\", \"admin_groups\"}})\n\t_, _ = e.UpdateGroupingPolicies([][]string{{\"admin\", \"data4_admin\"}}, [][]string{{\"admin\", \"data5_admin\"}})\n\ttestGetUsers(t, e, []string{\"admin\"}, \"data5_admin\")\n\ttestGetUsers(t, e, []string{\"eve\"}, \"admin_groups\")\n\n\ttestGetRoles(t, e, []string{\"data5_admin\"}, \"admin\")\n\ttestGetRoles(t, e, []string{\"admin_groups\"}, \"eve\")\n\n\te.ClearPolicy()\n\t_, _ = e.AddGroupingPoliciesEx([][]string{{\"user1\", \"member\"}})\n\ttestGetUsers(t, e, []string{\"user1\"}, \"member\")\n\t// {\"user1\", \"member\"} repeated\n\t_, _ = e.AddGroupingPoliciesEx([][]string{{\"user1\", \"member\"}, {\"user2\", \"member\"}})\n\ttestGetUsers(t, e, []string{\"user1\", \"user2\"}, \"member\")\n\t// {\"user1\", \"member\"}, {\"user2\", \"member\"} repeated\n\t_, _ = e.AddNamedGroupingPoliciesEx(\"g\", [][]string{{\"user1\", \"member\"}, {\"user2\", \"member\"}, {\"user3\", \"member\"}})\n\ttestGetUsers(t, e, []string{\"user1\", \"user2\", \"user3\"}, \"member\")\n}\n"
        },
        {
          "name": "managerment_api_b_test.go",
          "type": "blob",
          "size": 5.056640625,
          "content": "// Copyright 2020 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//\thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage casbin\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"testing\"\n)\n\nfunc BenchmarkHasPolicySmall(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", false)\n\n\t// 100 roles, 10 resources.\n\tfor i := 0; i < 100; i++ {\n\t\t_, _ = e.AddPolicy(fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\")\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\te.HasPolicy(fmt.Sprintf(\"user%d\", rand.Intn(100)), fmt.Sprintf(\"data%d\", rand.Intn(100)/10), \"read\")\n\t}\n}\n\nfunc BenchmarkHasPolicyMedium(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", false)\n\n\t// 1000 roles, 100 resources.\n\tpPolicies := make([][]string, 0)\n\tfor i := 0; i < 1000; i++ {\n\t\tpPolicies = append(pPolicies, []string{fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\"})\n\t}\n\t_, err := e.AddPolicies(pPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\te.HasPolicy(fmt.Sprintf(\"user%d\", rand.Intn(1000)), fmt.Sprintf(\"data%d\", rand.Intn(1000)/10), \"read\")\n\t}\n}\n\nfunc BenchmarkHasPolicyLarge(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", false)\n\n\t// 10000 roles, 1000 resources.\n\tpPolicies := make([][]string, 0)\n\tfor i := 0; i < 10000; i++ {\n\t\tpPolicies = append(pPolicies, []string{fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\"})\n\t}\n\t_, err := e.AddPolicies(pPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\te.HasPolicy(fmt.Sprintf(\"user%d\", rand.Intn(10000)), fmt.Sprintf(\"data%d\", rand.Intn(10000)/10), \"read\")\n\t}\n}\n\nfunc BenchmarkAddPolicySmall(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", false)\n\n\t// 100 roles, 10 resources.\n\tfor i := 0; i < 100; i++ {\n\t\t_, _ = e.AddPolicy(fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\")\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.AddPolicy(fmt.Sprintf(\"user%d\", rand.Intn(100)+100), fmt.Sprintf(\"data%d\", (rand.Intn(100)+100)/10), \"read\")\n\t}\n}\n\nfunc BenchmarkAddPolicyMedium(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", false)\n\n\t// 1000 roles, 100 resources.\n\tpPolicies := make([][]string, 0)\n\tfor i := 0; i < 1000; i++ {\n\t\tpPolicies = append(pPolicies, []string{fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\"})\n\t}\n\t_, err := e.AddPolicies(pPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.AddPolicy(fmt.Sprintf(\"user%d\", rand.Intn(1000)+1000), fmt.Sprintf(\"data%d\", (rand.Intn(1000)+1000)/10), \"read\")\n\t}\n}\n\nfunc BenchmarkAddPolicyLarge(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", false)\n\n\t// 10000 roles, 1000 resources.\n\tpPolicies := make([][]string, 0)\n\tfor i := 0; i < 10000; i++ {\n\t\tpPolicies = append(pPolicies, []string{fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\"})\n\t}\n\t_, err := e.AddPolicies(pPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.AddPolicy(fmt.Sprintf(\"user%d\", rand.Intn(10000)+10000), fmt.Sprintf(\"data%d\", (rand.Intn(10000)+10000)/10), \"read\")\n\t}\n}\n\nfunc BenchmarkRemovePolicySmall(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", false)\n\n\t// 100 roles, 10 resources.\n\tfor i := 0; i < 100; i++ {\n\t\t_, _ = e.AddPolicy(fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\")\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.RemovePolicy(fmt.Sprintf(\"user%d\", rand.Intn(100)), fmt.Sprintf(\"data%d\", rand.Intn(100)/10), \"read\")\n\t}\n}\n\nfunc BenchmarkRemovePolicyMedium(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", false)\n\n\t// 1000 roles, 100 resources.\n\tpPolicies := make([][]string, 0)\n\tfor i := 0; i < 1000; i++ {\n\t\tpPolicies = append(pPolicies, []string{fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\"})\n\t}\n\t_, err := e.AddPolicies(pPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.RemovePolicy(fmt.Sprintf(\"user%d\", rand.Intn(1000)), fmt.Sprintf(\"data%d\", rand.Intn(1000)/10), \"read\")\n\t}\n}\n\nfunc BenchmarkRemovePolicyLarge(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", false)\n\n\t// 10000 roles, 1000 resources.\n\tpPolicies := make([][]string, 0)\n\tfor i := 0; i < 10000; i++ {\n\t\tpPolicies = append(pPolicies, []string{fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\"})\n\t}\n\t_, err := e.AddPolicies(pPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.RemovePolicy(fmt.Sprintf(\"user%d\", rand.Intn(10000)), fmt.Sprintf(\"data%d\", rand.Intn(10000)/10), \"read\")\n\t}\n}\n"
        },
        {
          "name": "model",
          "type": "tree",
          "content": null
        },
        {
          "name": "model_b_test.go",
          "type": "blob",
          "size": 7.537109375,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/casbin/casbin/v2/util\"\n)\n\nfunc rawEnforce(sub string, obj string, act string) bool {\n\tpolicy := [2][3]string{{\"alice\", \"data1\", \"read\"}, {\"bob\", \"data2\", \"write\"}}\n\tfor _, rule := range policy {\n\t\tif sub == rule[0] && obj == rule[1] && act == rule[2] {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc BenchmarkRaw(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\trawEnforce(\"alice\", \"data1\", \"read\")\n\t}\n}\n\nfunc BenchmarkBasicModel(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\", false)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", \"data1\", \"read\")\n\t}\n}\n\nfunc BenchmarkRBACModel(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\", false)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", \"data2\", \"read\")\n\t}\n}\n\nfunc BenchmarkRBACModelSizes(b *testing.B) {\n\tcases := []struct {\n\t\tname      string\n\t\troles     int\n\t\tresources int\n\t\tusers     int\n\t}{\n\t\t{name: \"small\", roles: 100, resources: 10, users: 1000},\n\t\t{name: \"medium\", roles: 1000, resources: 100, users: 10000},\n\t\t{name: \"large\", roles: 10000, resources: 1000, users: 100000},\n\t}\n\tfor _, c := range cases {\n\t\tc := c\n\n\t\te, err := NewEnforcer(\"examples/rbac_model.conf\", false)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\n\t\tpPolicies := make([][]string, c.roles)\n\t\tfor i := range pPolicies {\n\t\t\tpPolicies[i] = []string{\n\t\t\t\tfmt.Sprintf(\"group-has-a-very-long-name-%d\", i),\n\t\t\t\tfmt.Sprintf(\"data-has-a-very-long-name-%d\", i%c.resources),\n\t\t\t\t\"read\",\n\t\t\t}\n\t\t}\n\t\tif _, err := e.AddPolicies(pPolicies); err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\n\t\tgPolicies := make([][]string, c.users)\n\t\tfor i := range gPolicies {\n\t\t\tgPolicies[i] = []string{\n\t\t\t\tfmt.Sprintf(\"user-has-a-very-long-name-%d\", i),\n\t\t\t\tfmt.Sprintf(\"group-has-a-very-long-name-%d\", i%c.roles),\n\t\t\t}\n\t\t}\n\t\tif _, err := e.AddGroupingPolicies(gPolicies); err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\n\t\t// Set up enforcements, alternating between things a user can access\n\t\t// and things they cannot. Use 17 tests so that we get a variety of users\n\t\t// and roles rather than always landing on a multiple of 2/10/whatever.\n\t\tenforcements := make([][]interface{}, 17)\n\t\tfor i := range enforcements {\n\t\t\tuserNum := (c.users / len(enforcements)) * i\n\t\t\troleNum := userNum % c.roles\n\t\t\tresourceNum := roleNum % c.resources\n\t\t\tif i%2 == 0 {\n\t\t\t\tresourceNum += 1\n\t\t\t\tresourceNum %= c.resources\n\t\t\t}\n\t\t\tenforcements[i] = []interface{}{\n\t\t\t\tfmt.Sprintf(\"user-has-a-very-long-name-%d\", userNum),\n\t\t\t\tfmt.Sprintf(\"data-has-a-very-long-name-%d\", resourceNum),\n\t\t\t\t\"read\",\n\t\t\t}\n\t\t}\n\n\t\tb.Run(c.name, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_, _ = e.Enforce(enforcements[i%len(enforcements)]...)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkRBACModelSmall(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", false)\n\n\t// 100 roles, 10 resources.\n\tfor i := 0; i < 100; i++ {\n\t\t_, err := e.AddPolicy(fmt.Sprintf(\"group%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\")\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n\n\t// 1000 users.\n\tfor i := 0; i < 1000; i++ {\n\t\t_, err := e.AddGroupingPolicy(fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"group%d\", i/10))\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"user501\", \"data9\", \"read\")\n\t}\n}\n\nfunc BenchmarkRBACModelMedium(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", false)\n\n\t// 1000 roles, 100 resources.\n\tpPolicies := make([][]string, 0)\n\tfor i := 0; i < 1000; i++ {\n\t\tpPolicies = append(pPolicies, []string{fmt.Sprintf(\"group%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\"})\n\t}\n\n\t_, err := e.AddPolicies(pPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\t// 10000 users.\n\tgPolicies := make([][]string, 0)\n\tfor i := 0; i < 10000; i++ {\n\t\tgPolicies = append(gPolicies, []string{fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"group%d\", i/10)})\n\t}\n\n\t_, err = e.AddGroupingPolicies(gPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"user5001\", \"data99\", \"read\")\n\t}\n}\n\nfunc BenchmarkRBACModelLarge(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", false)\n\n\t// 10000 roles, 1000 resources.\n\tpPolicies := make([][]string, 0)\n\tfor i := 0; i < 10000; i++ {\n\t\tpPolicies = append(pPolicies, []string{fmt.Sprintf(\"group%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\"})\n\t}\n\n\t_, err := e.AddPolicies(pPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\t// 100000 users.\n\tgPolicies := make([][]string, 0)\n\tfor i := 0; i < 100000; i++ {\n\t\tgPolicies = append(gPolicies, []string{fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"group%d\", i/10)})\n\t}\n\n\t_, err = e.AddGroupingPolicies(gPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"user50001\", \"data999\", \"read\")\n\t}\n}\n\nfunc BenchmarkRBACModelWithResourceRoles(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/rbac_with_resource_roles_model.conf\", \"examples/rbac_with_resource_roles_policy.csv\", false)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", \"data1\", \"read\")\n\t}\n}\n\nfunc BenchmarkRBACModelWithDomains(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy.csv\", false)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", \"domain1\", \"data1\", \"read\")\n\t}\n}\n\nfunc BenchmarkABACModel(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/abac_model.conf\", false)\n\tdata1 := newTestResource(\"data1\", \"alice\")\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", data1, \"read\")\n\t}\n}\n\nfunc BenchmarkABACRuleModel(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/abac_rule_model.conf\", false)\n\tsub := newTestSubject(\"alice\", 18)\n\n\tfor i := 0; i < 1000; i++ {\n\t\t_, _ = e.AddPolicy(\"r.sub.Age > 20\", fmt.Sprintf(\"data%d\", i), \"read\")\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(sub, \"data100\", \"read\")\n\t}\n}\n\nfunc BenchmarkKeyMatchModel(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/keymatch_model.conf\", \"examples/keymatch_policy.csv\", false)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", \"/alice_data/resource1\", \"GET\")\n\t}\n}\n\nfunc BenchmarkRBACModelWithDeny(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/rbac_with_deny_model.conf\", \"examples/rbac_with_deny_policy.csv\")\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", \"data1\", \"read\")\n\t}\n}\n\nfunc BenchmarkPriorityModel(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/priority_model.conf\", \"examples/priority_policy.csv\")\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"alice\", \"data1\", \"read\")\n\t}\n}\n\nfunc BenchmarkRBACModelWithDomainPatternLarge(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/performance/rbac_with_pattern_large_scale_model.conf\", \"examples/performance/rbac_with_pattern_large_scale_policy.csv\")\n\te.AddNamedDomainMatchingFunc(\"g\", \"\", util.KeyMatch4)\n\t_ = e.BuildRoleLinks()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = e.Enforce(\"staffUser1001\", \"/orgs/1/sites/site001\", \"App001.Module001.Action1001\")\n\t}\n}\n"
        },
        {
          "name": "model_test.go",
          "type": "blob",
          "size": 36,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/casbin/casbin/v2/log\"\n\tfileadapter \"github.com/casbin/casbin/v2/persist/file-adapter\"\n\t\"github.com/casbin/casbin/v2/rbac\"\n\t\"github.com/casbin/casbin/v2/util\"\n)\n\nfunc testEnforce(t *testing.T, e *Enforcer, sub interface{}, obj interface{}, act string, res bool) {\n\tt.Helper()\n\tif myRes, err := e.Enforce(sub, obj, act); err != nil {\n\t\tt.Errorf(\"Enforce Error: %s\", err)\n\t} else if myRes != res {\n\t\tt.Errorf(\"%s, %v, %s: %t, supposed to be %t\", sub, obj, act, myRes, res)\n\t}\n}\n\nfunc testEnforceWithoutUsers(t *testing.T, e *Enforcer, obj string, act string, res bool) {\n\tt.Helper()\n\tif myRes, _ := e.Enforce(obj, act); myRes != res {\n\t\tt.Errorf(\"%s, %s: %t, supposed to be %t\", obj, act, myRes, res)\n\t}\n}\n\nfunc testDomainEnforce(t *testing.T, e *Enforcer, sub string, dom string, obj string, act string, res bool) {\n\tt.Helper()\n\tif myRes, err := e.Enforce(sub, dom, obj, act); err != nil {\n\t\tt.Errorf(\"Enforce Error: %s\", err)\n\t} else if myRes != res {\n\t\tt.Errorf(\"%s, %s, %s, %s: %t, supposed to be %t\", sub, dom, obj, act, myRes, res)\n\t}\n}\n\nfunc TestBasicModel(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\", \"examples/basic_policy.csv\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\nfunc TestBasicModelWithoutSpaces(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_model_without_spaces.conf\", \"examples/basic_policy.csv\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\nfunc TestBasicModelNoPolicy(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_model.conf\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", false)\n}\n\nfunc TestBasicModelWithRoot(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_with_root_model.conf\", \"examples/basic_policy.csv\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n\ttestEnforce(t, e, \"root\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"root\", \"data1\", \"write\", true)\n\ttestEnforce(t, e, \"root\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"root\", \"data2\", \"write\", true)\n}\n\nfunc TestBasicModelWithRootNoPolicy(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_with_root_model.conf\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"root\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"root\", \"data1\", \"write\", true)\n\ttestEnforce(t, e, \"root\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"root\", \"data2\", \"write\", true)\n}\n\nfunc TestBasicModelWithoutUsers(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_without_users_model.conf\", \"examples/basic_without_users_policy.csv\")\n\n\ttestEnforceWithoutUsers(t, e, \"data1\", \"read\", true)\n\ttestEnforceWithoutUsers(t, e, \"data1\", \"write\", false)\n\ttestEnforceWithoutUsers(t, e, \"data2\", \"read\", false)\n\ttestEnforceWithoutUsers(t, e, \"data2\", \"write\", true)\n}\n\nfunc TestBasicModelWithoutResources(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_without_resources_model.conf\", \"examples/basic_without_resources_policy.csv\")\n\n\ttestEnforceWithoutUsers(t, e, \"alice\", \"read\", true)\n\ttestEnforceWithoutUsers(t, e, \"alice\", \"write\", false)\n\ttestEnforceWithoutUsers(t, e, \"bob\", \"read\", false)\n\ttestEnforceWithoutUsers(t, e, \"bob\", \"write\", true)\n}\n\nfunc TestRBACModel(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", true)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\nfunc TestRBACModelWithResourceRoles(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_resource_roles_model.conf\", \"examples/rbac_with_resource_roles_policy.csv\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", true)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\nfunc TestRBACModelWithDomains(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy.csv\")\n\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"read\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"write\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data2\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data2\", \"write\", false)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data1\", \"read\", false)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data1\", \"write\", false)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data2\", \"read\", true)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data2\", \"write\", true)\n}\n\nfunc TestRBACModelWithDomainsAtRuntime(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\")\n\n\t_, _ = e.AddPolicy(\"admin\", \"domain1\", \"data1\", \"read\")\n\t_, _ = e.AddPolicy(\"admin\", \"domain1\", \"data1\", \"write\")\n\t_, _ = e.AddPolicy(\"admin\", \"domain2\", \"data2\", \"read\")\n\t_, _ = e.AddPolicy(\"admin\", \"domain2\", \"data2\", \"write\")\n\n\t_, _ = e.AddGroupingPolicy(\"alice\", \"admin\", \"domain1\")\n\t_, _ = e.AddGroupingPolicy(\"bob\", \"admin\", \"domain2\")\n\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"read\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"write\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data2\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data2\", \"write\", false)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data1\", \"read\", false)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data1\", \"write\", false)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data2\", \"read\", true)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data2\", \"write\", true)\n\n\t// Remove all policy rules related to domain1 and data1.\n\t_, _ = e.RemoveFilteredPolicy(1, \"domain1\", \"data1\")\n\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"write\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data2\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data2\", \"write\", false)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data1\", \"read\", false)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data1\", \"write\", false)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data2\", \"read\", true)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data2\", \"write\", true)\n\n\t// Remove the specified policy rule.\n\t_, _ = e.RemovePolicy(\"admin\", \"domain2\", \"data2\", \"read\")\n\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"write\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data2\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data2\", \"write\", false)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data1\", \"read\", false)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data1\", \"write\", false)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data2\", \"read\", false)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data2\", \"write\", true)\n}\n\nfunc TestRBACModelWithDomainsAtRuntimeMockAdapter(t *testing.T) {\n\tadapter := fileadapter.NewAdapterMock(\"examples/rbac_with_domains_policy.csv\")\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", adapter)\n\n\t_, _ = e.AddPolicy(\"admin\", \"domain3\", \"data1\", \"read\")\n\t_, _ = e.AddGroupingPolicy(\"alice\", \"admin\", \"domain3\")\n\n\ttestDomainEnforce(t, e, \"alice\", \"domain3\", \"data1\", \"read\", true)\n\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"read\", true)\n\t_, _ = e.RemoveFilteredPolicy(1, \"domain1\", \"data1\")\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"read\", false)\n\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data2\", \"read\", true)\n\t_, _ = e.RemovePolicy(\"admin\", \"domain2\", \"data2\", \"read\")\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data2\", \"read\", false)\n}\n\nfunc TestRBACModelWithDeny(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_deny_model.conf\", \"examples/rbac_with_deny_policy.csv\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\nfunc TestRBACModelWithOnlyDeny(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_not_deny_model.conf\", \"examples/rbac_with_deny_policy.csv\")\n\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n}\n\nfunc TestRBACModelWithCustomData(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\t// You can add custom data to a grouping policy, Casbin will ignore it. It is only meaningful to the caller.\n\t// This feature can be used to store information like whether \"bob\" is an end user (so no subject will inherit \"bob\")\n\t// For Casbin, it is equivalent to: e.AddGroupingPolicy(\"bob\", \"data2_admin\")\n\t_, _ = e.AddGroupingPolicy(\"bob\", \"data2_admin\", \"custom_data\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", true)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n\n\t// You should also take the custom data as a parameter when deleting a grouping policy.\n\t// e.RemoveGroupingPolicy(\"bob\", \"data2_admin\") won't work.\n\t// Or you can remove it by using RemoveFilteredGroupingPolicy().\n\t_, _ = e.RemoveGroupingPolicy(\"bob\", \"data2_admin\", \"custom_data\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", true)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\nfunc TestRBACModelWithPattern(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_pattern_model.conf\", \"examples/rbac_with_pattern_policy.csv\")\n\n\t// Here's a little confusing: the matching function here is not the custom function used in matcher.\n\t// It is the matching function used by \"g\" (and \"g2\", \"g3\" if any..)\n\t// You can see in policy that: \"g2, /book/:id, book_group\", so in \"g2()\" function in the matcher, instead\n\t// of checking whether \"/book/:id\" equals the obj: \"/book/1\", it checks whether the pattern matches.\n\t// You can see it as normal RBAC: \"/book/:id\" == \"/book/1\" becomes KeyMatch2(\"/book/:id\", \"/book/1\")\n\te.AddNamedMatchingFunc(\"g2\", \"KeyMatch2\", util.KeyMatch2)\n\te.AddNamedMatchingFunc(\"g\", \"KeyMatch2\", util.KeyMatch2)\n\ttestEnforce(t, e, \"any_user\", \"/pen3/1\", \"GET\", true)\n\ttestEnforce(t, e, \"/book/user/1\", \"/pen4/1\", \"GET\", true)\n\n\ttestEnforce(t, e, \"/book/user/1\", \"/pen4/1\", \"POST\", true)\n\n\ttestEnforce(t, e, \"alice\", \"/book/1\", \"GET\", true)\n\ttestEnforce(t, e, \"alice\", \"/book/2\", \"GET\", true)\n\ttestEnforce(t, e, \"alice\", \"/pen/1\", \"GET\", true)\n\ttestEnforce(t, e, \"alice\", \"/pen/2\", \"GET\", false)\n\ttestEnforce(t, e, \"bob\", \"/book/1\", \"GET\", false)\n\ttestEnforce(t, e, \"bob\", \"/book/2\", \"GET\", false)\n\ttestEnforce(t, e, \"bob\", \"/pen/1\", \"GET\", true)\n\ttestEnforce(t, e, \"bob\", \"/pen/2\", \"GET\", true)\n\n\t// AddMatchingFunc() is actually setting a function because only one function is allowed,\n\t// so when we set \"KeyMatch3\", we are actually replacing \"KeyMatch2\" with \"KeyMatch3\".\n\te.AddNamedMatchingFunc(\"g2\", \"KeyMatch2\", util.KeyMatch3)\n\ttestEnforce(t, e, \"alice\", \"/book2/1\", \"GET\", true)\n\ttestEnforce(t, e, \"alice\", \"/book2/2\", \"GET\", true)\n\ttestEnforce(t, e, \"alice\", \"/pen2/1\", \"GET\", true)\n\ttestEnforce(t, e, \"alice\", \"/pen2/2\", \"GET\", false)\n\ttestEnforce(t, e, \"bob\", \"/book2/1\", \"GET\", false)\n\ttestEnforce(t, e, \"bob\", \"/book2/2\", \"GET\", false)\n\ttestEnforce(t, e, \"bob\", \"/pen2/1\", \"GET\", true)\n\ttestEnforce(t, e, \"bob\", \"/pen2/2\", \"GET\", true)\n}\n\nfunc TestRBACModelWithDifferentTypesOfRoles(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_different_types_of_roles_model.conf\", \"examples/rbac_with_different_types_of_roles_policy.csv\")\n\n\tg, err := e.GetNamedGroupingPolicy(\"g\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tfor _, gp := range g {\n\t\tif len(gp) != 5 {\n\t\t\tt.Error(\"g parameters' num isn't 5\")\n\t\t\treturn\n\t\t}\n\t\te.AddNamedDomainLinkConditionFunc(\"g\", gp[0], gp[1], gp[2], util.TimeMatchFunc)\n\t}\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"carol\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"carol\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"carol\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"carol\", \"data2\", \"write\", false)\n}\n\ntype testCustomRoleManager struct{}\n\nfunc NewRoleManager() rbac.RoleManager {\n\treturn &testCustomRoleManager{}\n}\nfunc (rm *testCustomRoleManager) Clear() error { return nil }\nfunc (rm *testCustomRoleManager) AddLink(name1 string, name2 string, domain ...string) error {\n\treturn nil\n}\nfunc (rm *testCustomRoleManager) BuildRelationship(name1 string, name2 string, domain ...string) error {\n\treturn nil\n}\nfunc (rm *testCustomRoleManager) DeleteLink(name1 string, name2 string, domain ...string) error {\n\treturn nil\n}\nfunc (rm *testCustomRoleManager) HasLink(name1 string, name2 string, domain ...string) (bool, error) {\n\tif name1 == \"alice\" && name2 == \"alice\" {\n\t\treturn true, nil\n\t} else if name1 == \"alice\" && name2 == \"data2_admin\" {\n\t\treturn true, nil\n\t} else if name1 == \"bob\" && name2 == \"bob\" {\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}\nfunc (rm *testCustomRoleManager) GetRoles(name string, domain ...string) ([]string, error) {\n\treturn []string{}, nil\n}\nfunc (rm *testCustomRoleManager) GetUsers(name string, domain ...string) ([]string, error) {\n\treturn []string{}, nil\n}\nfunc (rm *testCustomRoleManager) GetDomains(name string) ([]string, error) {\n\treturn []string{}, nil\n}\nfunc (rm *testCustomRoleManager) GetAllDomains() ([]string, error) {\n\treturn []string{}, nil\n}\nfunc (rm *testCustomRoleManager) PrintRoles() error           { return nil }\nfunc (rm *testCustomRoleManager) SetLogger(logger log.Logger) {}\n\nfunc (rm *testCustomRoleManager) Match(str string, pattern string) bool                   { return true }\nfunc (rm *testCustomRoleManager) AddMatchingFunc(name string, fn rbac.MatchingFunc)       {}\nfunc (rm *testCustomRoleManager) AddDomainMatchingFunc(name string, fn rbac.MatchingFunc) {}\n\nfunc (rm *testCustomRoleManager) AddLinkConditionFunc(userName, roleName string, fn rbac.LinkConditionFunc) {\n}\nfunc (rm *testCustomRoleManager) SetLinkConditionFuncParams(userName, roleName string, params ...string) {\n}\nfunc (rm *testCustomRoleManager) AddDomainLinkConditionFunc(user string, role string, domain string, fn rbac.LinkConditionFunc) {\n}\nfunc (rm *testCustomRoleManager) SetDomainLinkConditionFuncParams(user string, role string, domain string, params ...string) {\n}\n\nfunc TestRBACModelWithCustomRoleManager(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\te.SetRoleManager(NewRoleManager())\n\t_ = e.LoadModel()\n\t_ = e.LoadPolicy()\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", true)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\ntype testResource struct {\n\tName  string\n\tOwner string\n}\n\nfunc newTestResource(name string, owner string) testResource {\n\tr := testResource{}\n\tr.Name = name\n\tr.Owner = owner\n\treturn r\n}\n\nfunc TestABACModel(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/abac_model.conf\")\n\n\tdata1 := newTestResource(\"data1\", \"alice\")\n\tdata2 := newTestResource(\"data2\", \"bob\")\n\n\ttestEnforce(t, e, \"alice\", data1, \"read\", true)\n\ttestEnforce(t, e, \"alice\", data1, \"write\", true)\n\ttestEnforce(t, e, \"alice\", data2, \"read\", false)\n\ttestEnforce(t, e, \"alice\", data2, \"write\", false)\n\ttestEnforce(t, e, \"bob\", data1, \"read\", false)\n\ttestEnforce(t, e, \"bob\", data1, \"write\", false)\n\ttestEnforce(t, e, \"bob\", data2, \"read\", true)\n\ttestEnforce(t, e, \"bob\", data2, \"write\", true)\n}\n\nfunc TestABACMapRequest(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/abac_model.conf\")\n\n\tdata1 := map[string]interface{}{\n\t\t\"Name\":  \"data1\",\n\t\t\"Owner\": \"alice\",\n\t}\n\tdata2 := map[string]interface{}{\n\t\t\"Name\":  \"data2\",\n\t\t\"Owner\": \"bob\",\n\t}\n\n\ttestEnforce(t, e, \"alice\", data1, \"read\", true)\n\ttestEnforce(t, e, \"alice\", data1, \"write\", true)\n\ttestEnforce(t, e, \"alice\", data2, \"read\", false)\n\ttestEnforce(t, e, \"alice\", data2, \"write\", false)\n\ttestEnforce(t, e, \"bob\", data1, \"read\", false)\n\ttestEnforce(t, e, \"bob\", data1, \"write\", false)\n\ttestEnforce(t, e, \"bob\", data2, \"read\", true)\n\ttestEnforce(t, e, \"bob\", data2, \"write\", true)\n}\n\nfunc TestABACTypes(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/abac_model.conf\")\n\tmatcher := `\"moderator\" IN r.sub.Roles && r.sub.Enabled == true && r.sub.Age >= 21 && r.sub.Name != \"foo\"`\n\te.GetModel()[\"m\"][\"m\"].Value = util.RemoveComments(util.EscapeAssertion(matcher))\n\n\tstructRequest := struct {\n\t\tRoles   []interface{}\n\t\tEnabled bool\n\t\tAge     int\n\t\tName    string\n\t}{\n\t\tRoles:   []interface{}{\"user\", \"moderator\"},\n\t\tEnabled: true,\n\t\tAge:     30,\n\t\tName:    \"alice\",\n\t}\n\ttestEnforce(t, e, structRequest, \"\", \"\", true)\n\n\tmapRequest := map[string]interface{}{\n\t\t\"Roles\":   []interface{}{\"user\", \"moderator\"},\n\t\t\"Enabled\": true,\n\t\t\"Age\":     30,\n\t\t\"Name\":    \"alice\",\n\t}\n\ttestEnforce(t, e, mapRequest, nil, \"\", true)\n\n\te.EnableAcceptJsonRequest(true)\n\tjsonRequest, _ := json.Marshal(mapRequest)\n\ttestEnforce(t, e, string(jsonRequest), \"\", \"\", true)\n}\n\nfunc TestABACJsonRequest(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/abac_model.conf\")\n\te.EnableAcceptJsonRequest(true)\n\n\tdata1Json := `{ \"Name\": \"data1\", \"Owner\": \"alice\"}`\n\tdata2Json := `{ \"Name\": \"data2\", \"Owner\": \"bob\"}`\n\n\ttestEnforce(t, e, \"alice\", data1Json, \"read\", true)\n\ttestEnforce(t, e, \"alice\", data1Json, \"write\", true)\n\ttestEnforce(t, e, \"alice\", data2Json, \"read\", false)\n\ttestEnforce(t, e, \"alice\", data2Json, \"write\", false)\n\ttestEnforce(t, e, \"bob\", data1Json, \"read\", false)\n\ttestEnforce(t, e, \"bob\", data1Json, \"write\", false)\n\ttestEnforce(t, e, \"bob\", data2Json, \"read\", true)\n\ttestEnforce(t, e, \"bob\", data2Json, \"write\", true)\n\n\te, _ = NewEnforcer(\"examples/abac_not_using_policy_model.conf\", \"examples/abac_rule_effect_policy.csv\")\n\te.EnableAcceptJsonRequest(true)\n\n\ttestEnforce(t, e, \"alice\", data1Json, \"read\", true)\n\ttestEnforce(t, e, \"alice\", data1Json, \"write\", true)\n\ttestEnforce(t, e, \"alice\", data2Json, \"read\", false)\n\ttestEnforce(t, e, \"alice\", data2Json, \"write\", false)\n\n\te, _ = NewEnforcer(\"examples/abac_rule_model.conf\", \"examples/abac_rule_policy.csv\")\n\te.EnableAcceptJsonRequest(true)\n\tsub1Json := `{\"Name\": \"alice\", \"Age\": 16}`\n\tsub2Json := `{\"Name\": \"alice\", \"Age\": 20}`\n\tsub3Json := `{\"Name\": \"alice\", \"Age\": 65}`\n\n\ttestEnforce(t, e, sub1Json, \"/data1\", \"read\", false)\n\ttestEnforce(t, e, sub1Json, \"/data2\", \"read\", false)\n\ttestEnforce(t, e, sub1Json, \"/data1\", \"write\", false)\n\ttestEnforce(t, e, sub1Json, \"/data2\", \"write\", true)\n\ttestEnforce(t, e, sub2Json, \"/data1\", \"read\", true)\n\ttestEnforce(t, e, sub2Json, \"/data2\", \"read\", false)\n\ttestEnforce(t, e, sub2Json, \"/data1\", \"write\", false)\n\ttestEnforce(t, e, sub2Json, \"/data2\", \"write\", true)\n\ttestEnforce(t, e, sub3Json, \"/data1\", \"read\", true)\n\ttestEnforce(t, e, sub3Json, \"/data2\", \"read\", false)\n\ttestEnforce(t, e, sub3Json, \"/data1\", \"write\", false)\n\ttestEnforce(t, e, sub3Json, \"/data2\", \"write\", false)\n}\n\nfunc TestKeyMatchModel(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/keymatch_model.conf\", \"examples/keymatch_policy.csv\")\n\n\ttestEnforce(t, e, \"alice\", \"/alice_data/resource1\", \"GET\", true)\n\ttestEnforce(t, e, \"alice\", \"/alice_data/resource1\", \"POST\", true)\n\ttestEnforce(t, e, \"alice\", \"/alice_data/resource2\", \"GET\", true)\n\ttestEnforce(t, e, \"alice\", \"/alice_data/resource2\", \"POST\", false)\n\ttestEnforce(t, e, \"alice\", \"/bob_data/resource1\", \"GET\", false)\n\ttestEnforce(t, e, \"alice\", \"/bob_data/resource1\", \"POST\", false)\n\ttestEnforce(t, e, \"alice\", \"/bob_data/resource2\", \"GET\", false)\n\ttestEnforce(t, e, \"alice\", \"/bob_data/resource2\", \"POST\", false)\n\n\ttestEnforce(t, e, \"bob\", \"/alice_data/resource1\", \"GET\", false)\n\ttestEnforce(t, e, \"bob\", \"/alice_data/resource1\", \"POST\", false)\n\ttestEnforce(t, e, \"bob\", \"/alice_data/resource2\", \"GET\", true)\n\ttestEnforce(t, e, \"bob\", \"/alice_data/resource2\", \"POST\", false)\n\ttestEnforce(t, e, \"bob\", \"/bob_data/resource1\", \"GET\", false)\n\ttestEnforce(t, e, \"bob\", \"/bob_data/resource1\", \"POST\", true)\n\ttestEnforce(t, e, \"bob\", \"/bob_data/resource2\", \"GET\", false)\n\ttestEnforce(t, e, \"bob\", \"/bob_data/resource2\", \"POST\", true)\n\n\ttestEnforce(t, e, \"cathy\", \"/cathy_data\", \"GET\", true)\n\ttestEnforce(t, e, \"cathy\", \"/cathy_data\", \"POST\", true)\n\ttestEnforce(t, e, \"cathy\", \"/cathy_data\", \"DELETE\", false)\n}\n\nfunc TestKeyMatch2Model(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/keymatch2_model.conf\", \"examples/keymatch2_policy.csv\")\n\n\ttestEnforce(t, e, \"alice\", \"/alice_data\", \"GET\", false)\n\ttestEnforce(t, e, \"alice\", \"/alice_data/resource1\", \"GET\", true)\n\ttestEnforce(t, e, \"alice\", \"/alice_data2/myid\", \"GET\", false)\n\ttestEnforce(t, e, \"alice\", \"/alice_data2/myid/using/res_id\", \"GET\", true)\n}\n\nfunc CustomFunction(key1 string, key2 string) bool {\n\tif key1 == \"/alice_data2/myid/using/res_id\" && key2 == \"/alice_data/:resource\" {\n\t\treturn true\n\t} else if key1 == \"/alice_data2/myid/using/res_id\" && key2 == \"/alice_data2/:id/using/:resId\" {\n\t\treturn true\n\t} else {\n\t\treturn false\n\t}\n}\n\nfunc CustomFunctionWrapper(args ...interface{}) (interface{}, error) {\n\tkey1 := args[0].(string)\n\tkey2 := args[1].(string)\n\n\treturn CustomFunction(key1, key2), nil\n}\n\nfunc TestKeyMatchCustomModel(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/keymatch_custom_model.conf\", \"examples/keymatch2_policy.csv\")\n\n\te.AddFunction(\"keyMatchCustom\", CustomFunctionWrapper)\n\n\ttestEnforce(t, e, \"alice\", \"/alice_data2/myid\", \"GET\", false)\n\ttestEnforce(t, e, \"alice\", \"/alice_data2/myid/using/res_id\", \"GET\", true)\n}\n\nfunc TestIPMatchModel(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/ipmatch_model.conf\", \"examples/ipmatch_policy.csv\")\n\n\ttestEnforce(t, e, \"192.168.2.123\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"192.168.2.123\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"192.168.2.123\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"192.168.2.123\", \"data2\", \"write\", false)\n\n\ttestEnforce(t, e, \"192.168.0.123\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"192.168.0.123\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"192.168.0.123\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"192.168.0.123\", \"data2\", \"write\", false)\n\n\ttestEnforce(t, e, \"10.0.0.5\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"10.0.0.5\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"10.0.0.5\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"10.0.0.5\", \"data2\", \"write\", true)\n\n\ttestEnforce(t, e, \"192.168.0.1\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"192.168.0.1\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"192.168.0.1\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"192.168.0.1\", \"data2\", \"write\", false)\n}\n\nfunc TestGlobMatchModel(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/glob_model.conf\", \"examples/glob_policy.csv\")\n\ttestEnforce(t, e, \"u1\", \"/foo/\", \"read\", true)\n\ttestEnforce(t, e, \"u1\", \"/foo\", \"read\", false)\n\ttestEnforce(t, e, \"u1\", \"/foo/subprefix\", \"read\", true)\n\ttestEnforce(t, e, \"u1\", \"foo\", \"read\", false)\n\n\ttestEnforce(t, e, \"u2\", \"/foosubprefix\", \"read\", true)\n\ttestEnforce(t, e, \"u2\", \"/foo/subprefix\", \"read\", false)\n\ttestEnforce(t, e, \"u2\", \"foo\", \"read\", false)\n\n\ttestEnforce(t, e, \"u3\", \"/prefix/foo/subprefix\", \"read\", true)\n\ttestEnforce(t, e, \"u3\", \"/prefix/foo/\", \"read\", true)\n\ttestEnforce(t, e, \"u3\", \"/prefix/foo\", \"read\", false)\n\n\ttestEnforce(t, e, \"u4\", \"/foo\", \"read\", false)\n\ttestEnforce(t, e, \"u4\", \"foo\", \"read\", true)\n}\n\nfunc TestPriorityModel(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/priority_model.conf\", \"examples/priority_policy.csv\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", false)\n}\n\nfunc TestPriorityModelIndeterminate(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/priority_model.conf\", \"examples/priority_indeterminate_policy.csv\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", false)\n}\n\nfunc TestRBACModelInMultiLines(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model_in_multi_line.conf\", \"examples/rbac_policy.csv\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", true)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\ntype testSub struct {\n\tName string\n\tAge  int\n}\n\nfunc newTestSubject(name string, age int) testSub {\n\ts := testSub{}\n\ts.Name = name\n\ts.Age = age\n\treturn s\n}\n\nfunc TestABACNotUsingPolicy(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/abac_not_using_policy_model.conf\", \"examples/abac_rule_effect_policy.csv\")\n\tdata1 := newTestResource(\"data1\", \"alice\")\n\tdata2 := newTestResource(\"data2\", \"bob\")\n\n\ttestEnforce(t, e, \"alice\", data1, \"read\", true)\n\ttestEnforce(t, e, \"alice\", data1, \"write\", true)\n\ttestEnforce(t, e, \"alice\", data2, \"read\", false)\n\ttestEnforce(t, e, \"alice\", data2, \"write\", false)\n}\n\nfunc TestABACPolicy(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/abac_rule_model.conf\", \"examples/abac_rule_policy.csv\")\n\tm := e.GetModel()\n\tfor sec, ast := range m {\n\t\tfmt.Println(sec)\n\t\tfor ptype, p := range ast {\n\t\t\tfmt.Println(ptype, p)\n\t\t}\n\t}\n\tsub1 := newTestSubject(\"alice\", 16)\n\tsub2 := newTestSubject(\"alice\", 20)\n\tsub3 := newTestSubject(\"alice\", 65)\n\n\ttestEnforce(t, e, sub1, \"/data1\", \"read\", false)\n\ttestEnforce(t, e, sub1, \"/data2\", \"read\", false)\n\ttestEnforce(t, e, sub1, \"/data1\", \"write\", false)\n\ttestEnforce(t, e, sub1, \"/data2\", \"write\", true)\n\ttestEnforce(t, e, sub2, \"/data1\", \"read\", true)\n\ttestEnforce(t, e, sub2, \"/data2\", \"read\", false)\n\ttestEnforce(t, e, sub2, \"/data1\", \"write\", false)\n\ttestEnforce(t, e, sub2, \"/data2\", \"write\", true)\n\ttestEnforce(t, e, sub3, \"/data1\", \"read\", true)\n\ttestEnforce(t, e, sub3, \"/data2\", \"read\", false)\n\ttestEnforce(t, e, sub3, \"/data1\", \"write\", false)\n\ttestEnforce(t, e, sub3, \"/data2\", \"write\", false)\n}\n\nfunc TestCommentModel(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/comment_model.conf\", \"examples/basic_policy.csv\")\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\nfunc TestDomainMatchModel(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domain_pattern_model.conf\", \"examples/rbac_with_domain_pattern_policy.csv\")\n\te.AddNamedDomainMatchingFunc(\"g\", \"keyMatch2\", util.KeyMatch2)\n\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"read\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"write\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data2\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data2\", \"write\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain2\", \"data2\", \"read\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain2\", \"data2\", \"write\", true)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data1\", \"read\", false)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data1\", \"write\", false)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data2\", \"read\", true)\n\ttestDomainEnforce(t, e, \"bob\", \"domain2\", \"data2\", \"write\", true)\n}\n\nfunc TestAllMatchModel(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_all_pattern_model.conf\", \"examples/rbac_with_all_pattern_policy.csv\")\n\te.AddNamedMatchingFunc(\"g\", \"keyMatch2\", util.KeyMatch2)\n\te.AddNamedDomainMatchingFunc(\"g\", \"keyMatch2\", util.KeyMatch2)\n\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"/book/1\", \"read\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"/book/1\", \"write\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain2\", \"/book/1\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain2\", \"/book/1\", \"write\", true)\n}\n\nfunc TestTemporalRolesModel(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_temporal_roles_model.conf\", \"examples/rbac_with_temporal_roles_policy.csv\")\n\n\te.AddNamedLinkConditionFunc(\"g\", \"alice\", \"data2_admin\", util.TimeMatchFunc)\n\te.AddNamedLinkConditionFunc(\"g\", \"alice\", \"data3_admin\", util.TimeMatchFunc)\n\te.AddNamedLinkConditionFunc(\"g\", \"alice\", \"data4_admin\", util.TimeMatchFunc)\n\te.AddNamedLinkConditionFunc(\"g\", \"alice\", \"data5_admin\", util.TimeMatchFunc)\n\te.AddNamedLinkConditionFunc(\"g\", \"alice\", \"data6_admin\", util.TimeMatchFunc)\n\te.AddNamedLinkConditionFunc(\"g\", \"alice\", \"data7_admin\", util.TimeMatchFunc)\n\te.AddNamedLinkConditionFunc(\"g\", \"alice\", \"data8_admin\", util.TimeMatchFunc)\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data3\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data3\", \"write\", true)\n\ttestEnforce(t, e, \"alice\", \"data4\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data4\", \"write\", true)\n\ttestEnforce(t, e, \"alice\", \"data5\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data5\", \"write\", true)\n\ttestEnforce(t, e, \"alice\", \"data6\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data6\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data7\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data7\", \"write\", true)\n\ttestEnforce(t, e, \"alice\", \"data8\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data8\", \"write\", false)\n}\n\nfunc TestTemporalRolesModelWithDomain(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domain_temporal_roles_model.conf\", \"examples/rbac_with_domain_temporal_roles_policy.csv\")\n\n\te.AddNamedDomainLinkConditionFunc(\"g\", \"alice\", \"data2_admin\", \"domain2\", util.TimeMatchFunc)\n\te.AddNamedDomainLinkConditionFunc(\"g\", \"alice\", \"data3_admin\", \"domain3\", util.TimeMatchFunc)\n\te.AddNamedDomainLinkConditionFunc(\"g\", \"alice\", \"data4_admin\", \"domain4\", util.TimeMatchFunc)\n\te.AddNamedDomainLinkConditionFunc(\"g\", \"alice\", \"data5_admin\", \"domain5\", util.TimeMatchFunc)\n\te.AddNamedDomainLinkConditionFunc(\"g\", \"alice\", \"data6_admin\", \"domain6\", util.TimeMatchFunc)\n\te.AddNamedDomainLinkConditionFunc(\"g\", \"alice\", \"data7_admin\", \"domain7\", util.TimeMatchFunc)\n\te.AddNamedDomainLinkConditionFunc(\"g\", \"alice\", \"data8_admin\", \"domain8\", util.TimeMatchFunc)\n\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"read\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain1\", \"data1\", \"write\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain2\", \"data2\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain2\", \"data2\", \"write\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain3\", \"data3\", \"read\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain3\", \"data3\", \"write\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain4\", \"data4\", \"read\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain4\", \"data4\", \"write\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain5\", \"data5\", \"read\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain5\", \"data5\", \"write\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain6\", \"data6\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain6\", \"data6\", \"write\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain7\", \"data7\", \"read\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain7\", \"data7\", \"write\", true)\n\ttestDomainEnforce(t, e, \"alice\", \"domain8\", \"data8\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain8\", \"data8\", \"write\", false)\n\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data1\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data1\", \"write\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data2\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data2\", \"write\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data3\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data3\", \"write\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data4\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data4\", \"write\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data5\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data5\", \"write\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data6\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data6\", \"write\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data7\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data7\", \"write\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data8\", \"read\", false)\n\ttestDomainEnforce(t, e, \"alice\", \"domain_not_exist\", \"data8\", \"write\", false)\n}\n"
        },
        {
          "name": "persist",
          "type": "tree",
          "content": null
        },
        {
          "name": "rbac",
          "type": "tree",
          "content": null
        },
        {
          "name": "rbac_api.go",
          "type": "blob",
          "size": 19.033203125,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/casbin/casbin/v2/constant\"\n\t\"github.com/casbin/casbin/v2/errors\"\n\t\"github.com/casbin/casbin/v2/util\"\n)\n\n// GetRolesForUser gets the roles that a user has.\nfunc (e *Enforcer) GetRolesForUser(name string, domain ...string) ([]string, error) {\n\trm := e.GetRoleManager()\n\tif rm == nil {\n\t\treturn nil, fmt.Errorf(\"role manager is not initialized\")\n\t}\n\tres, err := rm.GetRoles(name, domain...)\n\treturn res, err\n}\n\n// GetUsersForRole gets the users that has a role.\nfunc (e *Enforcer) GetUsersForRole(name string, domain ...string) ([]string, error) {\n\trm := e.GetRoleManager()\n\tif rm == nil {\n\t\treturn nil, fmt.Errorf(\"role manager is not initialized\")\n\t}\n\tres, err := rm.GetUsers(name, domain...)\n\treturn res, err\n}\n\n// HasRoleForUser determines whether a user has a role.\nfunc (e *Enforcer) HasRoleForUser(name string, role string, domain ...string) (bool, error) {\n\troles, err := e.GetRolesForUser(name, domain...)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\thasRole := false\n\tfor _, r := range roles {\n\t\tif r == role {\n\t\t\thasRole = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn hasRole, nil\n}\n\n// AddRoleForUser adds a role for a user.\n// Returns false if the user already has the role (aka not affected).\nfunc (e *Enforcer) AddRoleForUser(user string, role string, domain ...string) (bool, error) {\n\targs := []string{user, role}\n\targs = append(args, domain...)\n\treturn e.AddGroupingPolicy(args)\n}\n\n// AddRolesForUser adds roles for a user.\n// Returns false if the user already has the roles (aka not affected).\nfunc (e *Enforcer) AddRolesForUser(user string, roles []string, domain ...string) (bool, error) {\n\tvar rules [][]string\n\tfor _, role := range roles {\n\t\trule := []string{user, role}\n\t\trule = append(rule, domain...)\n\t\trules = append(rules, rule)\n\t}\n\treturn e.AddGroupingPolicies(rules)\n}\n\n// DeleteRoleForUser deletes a role for a user.\n// Returns false if the user does not have the role (aka not affected).\nfunc (e *Enforcer) DeleteRoleForUser(user string, role string, domain ...string) (bool, error) {\n\targs := []string{user, role}\n\targs = append(args, domain...)\n\treturn e.RemoveGroupingPolicy(args)\n}\n\n// DeleteRolesForUser deletes all roles for a user.\n// Returns false if the user does not have any roles (aka not affected).\nfunc (e *Enforcer) DeleteRolesForUser(user string, domain ...string) (bool, error) {\n\tvar args []string\n\tif len(domain) == 0 {\n\t\targs = []string{user}\n\t} else if len(domain) > 1 {\n\t\treturn false, errors.ErrDomainParameter\n\t} else {\n\t\targs = []string{user, \"\", domain[0]}\n\t}\n\treturn e.RemoveFilteredGroupingPolicy(0, args...)\n}\n\n// DeleteUser deletes a user.\n// Returns false if the user does not exist (aka not affected).\nfunc (e *Enforcer) DeleteUser(user string) (bool, error) {\n\tvar err error\n\tres1, err := e.RemoveFilteredGroupingPolicy(0, user)\n\tif err != nil {\n\t\treturn res1, err\n\t}\n\n\tsubIndex, err := e.GetFieldIndex(\"p\", constant.SubjectIndex)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tres2, err := e.RemoveFilteredPolicy(subIndex, user)\n\treturn res1 || res2, err\n}\n\n// DeleteRole deletes a role.\n// Returns false if the role does not exist (aka not affected).\nfunc (e *Enforcer) DeleteRole(role string) (bool, error) {\n\tvar err error\n\tres1, err := e.RemoveFilteredGroupingPolicy(0, role)\n\tif err != nil {\n\t\treturn res1, err\n\t}\n\n\tres2, err := e.RemoveFilteredGroupingPolicy(1, role)\n\tif err != nil {\n\t\treturn res1, err\n\t}\n\n\tsubIndex, err := e.GetFieldIndex(\"p\", constant.SubjectIndex)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tres3, err := e.RemoveFilteredPolicy(subIndex, role)\n\treturn res1 || res2 || res3, err\n}\n\n// DeletePermission deletes a permission.\n// Returns false if the permission does not exist (aka not affected).\nfunc (e *Enforcer) DeletePermission(permission ...string) (bool, error) {\n\treturn e.RemoveFilteredPolicy(1, permission...)\n}\n\n// AddPermissionForUser adds a permission for a user or role.\n// Returns false if the user or role already has the permission (aka not affected).\nfunc (e *Enforcer) AddPermissionForUser(user string, permission ...string) (bool, error) {\n\treturn e.AddPolicy(util.JoinSlice(user, permission...))\n}\n\n// AddPermissionsForUser adds multiple permissions for a user or role.\n// Returns false if the user or role already has one of the permissions (aka not affected).\nfunc (e *Enforcer) AddPermissionsForUser(user string, permissions ...[]string) (bool, error) {\n\tvar rules [][]string\n\tfor _, permission := range permissions {\n\t\trules = append(rules, util.JoinSlice(user, permission...))\n\t}\n\treturn e.AddPolicies(rules)\n}\n\n// DeletePermissionForUser deletes a permission for a user or role.\n// Returns false if the user or role does not have the permission (aka not affected).\nfunc (e *Enforcer) DeletePermissionForUser(user string, permission ...string) (bool, error) {\n\treturn e.RemovePolicy(util.JoinSlice(user, permission...))\n}\n\n// DeletePermissionsForUser deletes permissions for a user or role.\n// Returns false if the user or role does not have any permissions (aka not affected).\nfunc (e *Enforcer) DeletePermissionsForUser(user string) (bool, error) {\n\tsubIndex, err := e.GetFieldIndex(\"p\", constant.SubjectIndex)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn e.RemoveFilteredPolicy(subIndex, user)\n}\n\n// GetPermissionsForUser gets permissions for a user or role.\nfunc (e *Enforcer) GetPermissionsForUser(user string, domain ...string) ([][]string, error) {\n\treturn e.GetNamedPermissionsForUser(\"p\", user, domain...)\n}\n\n// GetNamedPermissionsForUser gets permissions for a user or role by named policy.\nfunc (e *Enforcer) GetNamedPermissionsForUser(ptype string, user string, domain ...string) ([][]string, error) {\n\tpermission := make([][]string, 0)\n\tfor pType, assertion := range e.model[\"p\"] {\n\t\tif pType != ptype {\n\t\t\tcontinue\n\t\t}\n\t\targs := make([]string, len(assertion.Tokens))\n\t\tsubIndex, err := e.GetFieldIndex(\"p\", constant.SubjectIndex)\n\t\tif err != nil {\n\t\t\tsubIndex = 0\n\t\t}\n\t\targs[subIndex] = user\n\n\t\tif len(domain) > 0 {\n\t\t\tvar index int\n\t\t\tindex, err = e.GetFieldIndex(ptype, constant.DomainIndex)\n\t\t\tif err != nil {\n\t\t\t\treturn permission, err\n\t\t\t}\n\t\t\targs[index] = domain[0]\n\t\t}\n\t\tperm, err := e.GetFilteredNamedPolicy(ptype, 0, args...)\n\t\tif err != nil {\n\t\t\treturn permission, err\n\t\t}\n\t\tpermission = append(permission, perm...)\n\t}\n\treturn permission, nil\n}\n\n// HasPermissionForUser determines whether a user has a permission.\nfunc (e *Enforcer) HasPermissionForUser(user string, permission ...string) (bool, error) {\n\treturn e.HasPolicy(util.JoinSlice(user, permission...))\n}\n\n// GetImplicitRolesForUser gets implicit roles that a user has.\n// Compared to GetRolesForUser(), this function retrieves indirect roles besides direct roles.\n// For example:\n// g, alice, role:admin\n// g, role:admin, role:user\n//\n// GetRolesForUser(\"alice\") can only get: [\"role:admin\"].\n// But GetImplicitRolesForUser(\"alice\") will get: [\"role:admin\", \"role:user\"].\nfunc (e *Enforcer) GetImplicitRolesForUser(name string, domain ...string) ([]string, error) {\n\tvar res []string\n\n\tfor v := range e.rmMap {\n\t\troles, err := e.GetNamedImplicitRolesForUser(v, name, domain...)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres = append(res, roles...)\n\t}\n\n\treturn res, nil\n}\n\n// GetNamedImplicitRolesForUser gets implicit roles that a user has by named role definition.\n// Compared to GetImplicitRolesForUser(), this function retrieves indirect roles besides direct roles.\n// For example:\n// g, alice, role:admin\n// g, role:admin, role:user\n// g2, alice, role:admin2\n//\n// GetImplicitRolesForUser(\"alice\") can only get: [\"role:admin\", \"role:user\"].\n// But GetNamedImplicitRolesForUser(\"g2\", \"alice\") will get: [\"role:admin2\"].\nfunc (e *Enforcer) GetNamedImplicitRolesForUser(ptype string, name string, domain ...string) ([]string, error) {\n\tvar res []string\n\n\trm := e.GetNamedRoleManager(ptype)\n\tif rm == nil {\n\t\treturn nil, fmt.Errorf(\"role manager %s is not initialized\", ptype)\n\t}\n\troleSet := make(map[string]bool)\n\troleSet[name] = true\n\tq := make([]string, 0)\n\tq = append(q, name)\n\n\tfor len(q) > 0 {\n\t\tname := q[0]\n\t\tq = q[1:]\n\n\t\troles, err := rm.GetRoles(name, domain...)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor _, r := range roles {\n\t\t\tif _, ok := roleSet[r]; !ok {\n\t\t\t\tres = append(res, r)\n\t\t\t\tq = append(q, r)\n\t\t\t\troleSet[r] = true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\n// GetImplicitUsersForRole gets implicit users for a role.\nfunc (e *Enforcer) GetImplicitUsersForRole(name string, domain ...string) ([]string, error) {\n\tres := []string{}\n\n\tfor _, rm := range e.rmMap {\n\t\troleSet := make(map[string]bool)\n\t\troleSet[name] = true\n\t\tq := make([]string, 0)\n\t\tq = append(q, name)\n\n\t\tfor len(q) > 0 {\n\t\t\tname := q[0]\n\t\t\tq = q[1:]\n\n\t\t\troles, err := rm.GetUsers(name, domain...)\n\t\t\tif err != nil && err.Error() != \"error: name does not exist\" {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tfor _, r := range roles {\n\t\t\t\tif _, ok := roleSet[r]; !ok {\n\t\t\t\t\tres = append(res, r)\n\t\t\t\t\tq = append(q, r)\n\t\t\t\t\troleSet[r] = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\n// GetImplicitPermissionsForUser gets implicit permissions for a user or role.\n// Compared to GetPermissionsForUser(), this function retrieves permissions for inherited roles.\n// For example:\n// p, admin, data1, read\n// p, alice, data2, read\n// g, alice, admin\n//\n// GetPermissionsForUser(\"alice\") can only get: [[\"alice\", \"data2\", \"read\"]].\n// But GetImplicitPermissionsForUser(\"alice\") will get: [[\"admin\", \"data1\", \"read\"], [\"alice\", \"data2\", \"read\"]].\nfunc (e *Enforcer) GetImplicitPermissionsForUser(user string, domain ...string) ([][]string, error) {\n\treturn e.GetNamedImplicitPermissionsForUser(\"p\", \"g\", user, domain...)\n}\n\n// GetNamedImplicitPermissionsForUser gets implicit permissions for a user or role by named policy.\n// Compared to GetNamedPermissionsForUser(), this function retrieves permissions for inherited roles.\n// For example:\n// p, admin, data1, read\n// p2, admin, create\n// g, alice, admin\n//\n// GetImplicitPermissionsForUser(\"alice\") can only get: [[\"admin\", \"data1\", \"read\"]], whose policy is default policy \"p\"\n// But you can specify the named policy \"p2\" to get: [[\"admin\", \"create\"]] by    GetNamedImplicitPermissionsForUser(\"p2\",\"alice\").\nfunc (e *Enforcer) GetNamedImplicitPermissionsForUser(ptype string, gtype string, user string, domain ...string) ([][]string, error) {\n\tpermission := make([][]string, 0)\n\trm := e.GetNamedRoleManager(gtype)\n\tif rm == nil {\n\t\treturn nil, fmt.Errorf(\"role manager %s is not initialized\", gtype)\n\t}\n\n\troles, err := e.GetNamedImplicitRolesForUser(gtype, user, domain...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpolicyRoles := make(map[string]struct{}, len(roles)+1)\n\tpolicyRoles[user] = struct{}{}\n\tfor _, r := range roles {\n\t\tpolicyRoles[r] = struct{}{}\n\t}\n\n\tdomainIndex, err := e.GetFieldIndex(ptype, constant.DomainIndex)\n\tfor _, rule := range e.model[\"p\"][ptype].Policy {\n\t\tif len(domain) == 0 {\n\t\t\tif _, ok := policyRoles[rule[0]]; ok {\n\t\t\t\tpermission = append(permission, deepCopyPolicy(rule))\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif len(domain) > 1 {\n\t\t\treturn nil, errors.ErrDomainParameter\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\td := domain[0]\n\t\tmatched := rm.Match(d, rule[domainIndex])\n\t\tif !matched {\n\t\t\tcontinue\n\t\t}\n\t\tif _, ok := policyRoles[rule[0]]; ok {\n\t\t\tnewRule := deepCopyPolicy(rule)\n\t\t\tnewRule[domainIndex] = d\n\t\t\tpermission = append(permission, newRule)\n\t\t}\n\t}\n\treturn permission, nil\n}\n\n// GetImplicitUsersForPermission gets implicit users for a permission.\n// For example:\n// p, admin, data1, read\n// p, bob, data1, read\n// g, alice, admin\n//\n// GetImplicitUsersForPermission(\"data1\", \"read\") will get: [\"alice\", \"bob\"].\n// Note: only users will be returned, roles (2nd arg in \"g\") will be excluded.\nfunc (e *Enforcer) GetImplicitUsersForPermission(permission ...string) ([]string, error) {\n\tpSubjects, err := e.GetAllSubjects()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgInherit, err := e.model.GetValuesForFieldInPolicyAllTypes(\"g\", 1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgSubjects, err := e.model.GetValuesForFieldInPolicyAllTypes(\"g\", 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsubjects := append(pSubjects, gSubjects...)\n\tutil.ArrayRemoveDuplicates(&subjects)\n\n\tsubjects = util.SetSubtract(subjects, gInherit)\n\n\tres := []string{}\n\tfor _, user := range subjects {\n\t\treq := util.JoinSliceAny(user, permission...)\n\t\tallowed, err := e.Enforce(req...)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif allowed {\n\t\t\tres = append(res, user)\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\n// GetDomainsForUser gets all domains.\nfunc (e *Enforcer) GetDomainsForUser(user string) ([]string, error) {\n\tvar domains []string\n\tfor _, rm := range e.rmMap {\n\t\tdomain, err := rm.GetDomains(user)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdomains = append(domains, domain...)\n\t}\n\treturn domains, nil\n}\n\n// GetImplicitResourcesForUser returns all policies that user obtaining in domain.\nfunc (e *Enforcer) GetImplicitResourcesForUser(user string, domain ...string) ([][]string, error) {\n\tpermissions, err := e.GetImplicitPermissionsForUser(user, domain...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tres := make([][]string, 0)\n\tfor _, permission := range permissions {\n\t\tif permission[0] == user {\n\t\t\tres = append(res, permission)\n\t\t\tcontinue\n\t\t}\n\t\tresLocal := [][]string{{user}}\n\t\ttokensLength := len(permission)\n\t\tt := make([][]string, 1, tokensLength)\n\t\tfor _, token := range permission[1:] {\n\t\t\ttokens, err := e.GetImplicitUsersForRole(token, domain...)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\ttokens = append(tokens, token)\n\t\t\tt = append(t, tokens)\n\t\t}\n\t\tfor i := 1; i < tokensLength; i++ {\n\t\t\tn := make([][]string, 0)\n\t\t\tfor _, tokens := range t[i] {\n\t\t\t\tfor _, policy := range resLocal {\n\t\t\t\t\tt := append([]string(nil), policy...)\n\t\t\t\t\tt = append(t, tokens)\n\t\t\t\t\tn = append(n, t)\n\t\t\t\t}\n\t\t\t}\n\t\t\tresLocal = n\n\t\t}\n\t\tres = append(res, resLocal...)\n\t}\n\treturn res, nil\n}\n\n// deepCopyPolicy returns a deepcopy version of the policy to prevent changing policies through returned slice.\nfunc deepCopyPolicy(src []string) []string {\n\tnewRule := make([]string, len(src))\n\tcopy(newRule, src)\n\treturn newRule\n}\n\n// GetAllowedObjectConditions returns a string array of object conditions that the user can access.\n// For example: conditions, err := e.GetAllowedObjectConditions(\"alice\", \"read\", \"r.obj.\")\n// Note:\n//\n// 0. prefix: You can customize the prefix of the object conditions, and \"r.obj.\" is commonly used as a prefix.\n// After removing the prefix, the remaining part is the condition of the object.\n// If there is an obj policy that does not meet the prefix requirement, an errors.ERR_OBJ_CONDITION will be returned.\n//\n// 1. If the 'objectConditions' array is empty, return errors.ERR_EMPTY_CONDITION\n// This error is returned because some data adapters' ORM return full table data by default\n// when they receive an empty condition, which tends to behave contrary to expectations.(e.g. GORM)\n// If you are using an adapter that does not behave like this, you can choose to ignore this error.\nfunc (e *Enforcer) GetAllowedObjectConditions(user string, action string, prefix string) ([]string, error) {\n\tpermissions, err := e.GetImplicitPermissionsForUser(user)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar objectConditions []string\n\tfor _, policy := range permissions {\n\t\t// policy {sub, obj, act}\n\t\tif policy[2] == action {\n\t\t\tif !strings.HasPrefix(policy[1], prefix) {\n\t\t\t\treturn nil, errors.ErrObjCondition\n\t\t\t}\n\t\t\tobjectConditions = append(objectConditions, strings.TrimPrefix(policy[1], prefix))\n\t\t}\n\t}\n\n\tif len(objectConditions) == 0 {\n\t\treturn nil, errors.ErrEmptyCondition\n\t}\n\n\treturn objectConditions, nil\n}\n\n// removeDuplicatePermissions Convert permissions to string as a hash to deduplicate.\nfunc removeDuplicatePermissions(permissions [][]string) [][]string {\n\tpermissionsSet := make(map[string]bool)\n\tres := make([][]string, 0)\n\tfor _, permission := range permissions {\n\t\tpermissionStr := util.ArrayToString(permission)\n\t\tif permissionsSet[permissionStr] {\n\t\t\tcontinue\n\t\t}\n\t\tpermissionsSet[permissionStr] = true\n\t\tres = append(res, permission)\n\t}\n\treturn res\n}\n\n// GetImplicitUsersForResource return implicit user based on resource.\n// for example:\n// p, alice, data1, read\n// p, bob, data2, write\n// p, data2_admin, data2, read\n// p, data2_admin, data2, write\n// g, alice, data2_admin\n// GetImplicitUsersForResource(\"data2\") will return [[bob data2 write] [alice data2 read] [alice data2 write]]\n// GetImplicitUsersForResource(\"data1\") will return [[alice data1 read]]\n// Note: only users will be returned, roles (2nd arg in \"g\") will be excluded.\nfunc (e *Enforcer) GetImplicitUsersForResource(resource string) ([][]string, error) {\n\tpermissions := make([][]string, 0)\n\tsubjectIndex, _ := e.GetFieldIndex(\"p\", \"sub\")\n\tobjectIndex, _ := e.GetFieldIndex(\"p\", \"obj\")\n\trm := e.GetRoleManager()\n\tif rm == nil {\n\t\treturn nil, fmt.Errorf(\"role manager is not initialized\")\n\t}\n\n\tisRole := make(map[string]bool)\n\troles, err := e.GetAllRoles()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor _, role := range roles {\n\t\tisRole[role] = true\n\t}\n\n\tfor _, rule := range e.model[\"p\"][\"p\"].Policy {\n\t\tobj := rule[objectIndex]\n\t\tif obj != resource {\n\t\t\tcontinue\n\t\t}\n\n\t\tsub := rule[subjectIndex]\n\n\t\tif !isRole[sub] {\n\t\t\tpermissions = append(permissions, rule)\n\t\t} else {\n\t\t\tusers, err := rm.GetUsers(sub)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tfor _, user := range users {\n\t\t\t\timplicitUserRule := deepCopyPolicy(rule)\n\t\t\t\timplicitUserRule[subjectIndex] = user\n\t\t\t\tpermissions = append(permissions, implicitUserRule)\n\t\t\t}\n\t\t}\n\t}\n\n\tres := removeDuplicatePermissions(permissions)\n\treturn res, nil\n}\n\n// GetImplicitUsersForResourceByDomain return implicit user based on resource and domain.\n// Compared to GetImplicitUsersForResource, domain is supported.\nfunc (e *Enforcer) GetImplicitUsersForResourceByDomain(resource string, domain string) ([][]string, error) {\n\tpermissions := make([][]string, 0)\n\tsubjectIndex, _ := e.GetFieldIndex(\"p\", \"sub\")\n\tobjectIndex, _ := e.GetFieldIndex(\"p\", \"obj\")\n\tdomIndex, _ := e.GetFieldIndex(\"p\", \"dom\")\n\trm := e.GetRoleManager()\n\tif rm == nil {\n\t\treturn nil, fmt.Errorf(\"role manager is not initialized\")\n\t}\n\n\tisRole := make(map[string]bool)\n\n\tif roles, err := e.GetAllRolesByDomain(domain); err != nil {\n\t\treturn nil, err\n\t} else {\n\t\tfor _, role := range roles {\n\t\t\tisRole[role] = true\n\t\t}\n\t}\n\n\tfor _, rule := range e.model[\"p\"][\"p\"].Policy {\n\t\tobj := rule[objectIndex]\n\t\tif obj != resource {\n\t\t\tcontinue\n\t\t}\n\n\t\tsub := rule[subjectIndex]\n\n\t\tif !isRole[sub] {\n\t\t\tpermissions = append(permissions, rule)\n\t\t} else {\n\t\t\tif domain != rule[domIndex] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tusers, err := rm.GetUsers(sub, domain)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tfor _, user := range users {\n\t\t\t\timplicitUserRule := deepCopyPolicy(rule)\n\t\t\t\timplicitUserRule[subjectIndex] = user\n\t\t\t\tpermissions = append(permissions, implicitUserRule)\n\t\t\t}\n\t\t}\n\t}\n\n\tres := removeDuplicatePermissions(permissions)\n\treturn res, nil\n}\n"
        },
        {
          "name": "rbac_api_synced.go",
          "type": "blob",
          "size": 7.8642578125,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\n// GetRolesForUser gets the roles that a user has.\nfunc (e *SyncedEnforcer) GetRolesForUser(name string, domain ...string) ([]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetRolesForUser(name, domain...)\n}\n\n// GetUsersForRole gets the users that has a role.\nfunc (e *SyncedEnforcer) GetUsersForRole(name string, domain ...string) ([]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetUsersForRole(name, domain...)\n}\n\n// HasRoleForUser determines whether a user has a role.\nfunc (e *SyncedEnforcer) HasRoleForUser(name string, role string, domain ...string) (bool, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.HasRoleForUser(name, role, domain...)\n}\n\n// AddRoleForUser adds a role for a user.\n// Returns false if the user already has the role (aka not affected).\nfunc (e *SyncedEnforcer) AddRoleForUser(user string, role string, domain ...string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddRoleForUser(user, role, domain...)\n}\n\n// AddRolesForUser adds roles for a user.\n// Returns false if the user already has the roles (aka not affected).\nfunc (e *SyncedEnforcer) AddRolesForUser(user string, roles []string, domain ...string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddRolesForUser(user, roles, domain...)\n}\n\n// DeleteRoleForUser deletes a role for a user.\n// Returns false if the user does not have the role (aka not affected).\nfunc (e *SyncedEnforcer) DeleteRoleForUser(user string, role string, domain ...string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.DeleteRoleForUser(user, role, domain...)\n}\n\n// DeleteRolesForUser deletes all roles for a user.\n// Returns false if the user does not have any roles (aka not affected).\nfunc (e *SyncedEnforcer) DeleteRolesForUser(user string, domain ...string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.DeleteRolesForUser(user, domain...)\n}\n\n// DeleteUser deletes a user.\n// Returns false if the user does not exist (aka not affected).\nfunc (e *SyncedEnforcer) DeleteUser(user string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.DeleteUser(user)\n}\n\n// DeleteRole deletes a role.\n// Returns false if the role does not exist (aka not affected).\nfunc (e *SyncedEnforcer) DeleteRole(role string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.DeleteRole(role)\n}\n\n// DeletePermission deletes a permission.\n// Returns false if the permission does not exist (aka not affected).\nfunc (e *SyncedEnforcer) DeletePermission(permission ...string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.DeletePermission(permission...)\n}\n\n// AddPermissionForUser adds a permission for a user or role.\n// Returns false if the user or role already has the permission (aka not affected).\nfunc (e *SyncedEnforcer) AddPermissionForUser(user string, permission ...string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddPermissionForUser(user, permission...)\n}\n\n// AddPermissionsForUser adds permissions for a user or role.\n// Returns false if the user or role already has the permissions (aka not affected).\nfunc (e *SyncedEnforcer) AddPermissionsForUser(user string, permissions ...[]string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddPermissionsForUser(user, permissions...)\n}\n\n// DeletePermissionForUser deletes a permission for a user or role.\n// Returns false if the user or role does not have the permission (aka not affected).\nfunc (e *SyncedEnforcer) DeletePermissionForUser(user string, permission ...string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.DeletePermissionForUser(user, permission...)\n}\n\n// DeletePermissionsForUser deletes permissions for a user or role.\n// Returns false if the user or role does not have any permissions (aka not affected).\nfunc (e *SyncedEnforcer) DeletePermissionsForUser(user string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.DeletePermissionsForUser(user)\n}\n\n// GetPermissionsForUser gets permissions for a user or role.\nfunc (e *SyncedEnforcer) GetPermissionsForUser(user string, domain ...string) ([][]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetPermissionsForUser(user, domain...)\n}\n\n// GetNamedPermissionsForUser gets permissions for a user or role by named policy.\nfunc (e *SyncedEnforcer) GetNamedPermissionsForUser(ptype string, user string, domain ...string) ([][]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetNamedPermissionsForUser(ptype, user, domain...)\n}\n\n// HasPermissionForUser determines whether a user has a permission.\nfunc (e *SyncedEnforcer) HasPermissionForUser(user string, permission ...string) (bool, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.HasPermissionForUser(user, permission...)\n}\n\n// GetImplicitRolesForUser gets implicit roles that a user has.\n// Compared to GetRolesForUser(), this function retrieves indirect roles besides direct roles.\n// For example:\n// g, alice, role:admin\n// g, role:admin, role:user\n//\n// GetRolesForUser(\"alice\") can only get: [\"role:admin\"].\n// But GetImplicitRolesForUser(\"alice\") will get: [\"role:admin\", \"role:user\"].\nfunc (e *SyncedEnforcer) GetImplicitRolesForUser(name string, domain ...string) ([]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetImplicitRolesForUser(name, domain...)\n}\n\n// GetImplicitPermissionsForUser gets implicit permissions for a user or role.\n// Compared to GetPermissionsForUser(), this function retrieves permissions for inherited roles.\n// For example:\n// p, admin, data1, read\n// p, alice, data2, read\n// g, alice, admin\n//\n// GetPermissionsForUser(\"alice\") can only get: [[\"alice\", \"data2\", \"read\"]].\n// But GetImplicitPermissionsForUser(\"alice\") will get: [[\"admin\", \"data1\", \"read\"], [\"alice\", \"data2\", \"read\"]].\nfunc (e *SyncedEnforcer) GetImplicitPermissionsForUser(user string, domain ...string) ([][]string, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.GetImplicitPermissionsForUser(user, domain...)\n}\n\n// GetNamedImplicitPermissionsForUser gets implicit permissions for a user or role by named policy.\n// Compared to GetNamedPermissionsForUser(), this function retrieves permissions for inherited roles.\n// For example:\n// p, admin, data1, read\n// p2, admin, create\n// g, alice, admin\n//\n// GetImplicitPermissionsForUser(\"alice\") can only get: [[\"admin\", \"data1\", \"read\"]], whose policy is default policy \"p\"\n// But you can specify the named policy \"p2\" to get: [[\"admin\", \"create\"]] by    GetNamedImplicitPermissionsForUser(\"p2\",\"alice\").\nfunc (e *SyncedEnforcer) GetNamedImplicitPermissionsForUser(ptype string, gtype string, user string, domain ...string) ([][]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetNamedImplicitPermissionsForUser(ptype, gtype, user, domain...)\n}\n\n// GetImplicitUsersForPermission gets implicit users for a permission.\n// For example:\n// p, admin, data1, read\n// p, bob, data1, read\n// g, alice, admin\n//\n// GetImplicitUsersForPermission(\"data1\", \"read\") will get: [\"alice\", \"bob\"].\n// Note: only users will be returned, roles (2nd arg in \"g\") will be excluded.\nfunc (e *SyncedEnforcer) GetImplicitUsersForPermission(permission ...string) ([]string, error) {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetImplicitUsersForPermission(permission...)\n}\n"
        },
        {
          "name": "rbac_api_test.go",
          "type": "blob",
          "size": 24.546875,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"log\"\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/casbin/casbin/v2/constant\"\n\t\"github.com/casbin/casbin/v2/errors\"\n\t\"github.com/casbin/casbin/v2/util\"\n)\n\nfunc testGetRoles(t *testing.T, e *Enforcer, res []string, name string, domain ...string) {\n\tt.Helper()\n\tmyRes, err := e.GetRolesForUser(name, domain...)\n\tif err != nil {\n\t\tt.Error(\"Roles for \", name, \" could not be fetched: \", err.Error())\n\t}\n\tt.Log(\"Roles for \", name, \": \", myRes)\n\n\tif !util.SetEquals(res, myRes) {\n\t\tt.Error(\"Roles for \", name, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc testGetUsers(t *testing.T, e *Enforcer, res []string, name string, domain ...string) {\n\tt.Helper()\n\tmyRes, err := e.GetUsersForRole(name, domain...)\n\tswitch err {\n\tcase nil:\n\t\tbreak\n\tcase errors.ErrNameNotFound:\n\t\tt.Log(\"No name found\")\n\tdefault:\n\t\tt.Error(\"Users for \", name, \" could not be fetched: \", err.Error())\n\t}\n\tt.Log(\"Users for \", name, \": \", myRes)\n\n\tif !util.SetEquals(res, myRes) {\n\t\tt.Error(\"Users for \", name, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc testHasRole(t *testing.T, e *Enforcer, name string, role string, res bool, domain ...string) {\n\tt.Helper()\n\tmyRes, err := e.HasRoleForUser(name, role, domain...)\n\tif err != nil {\n\t\tt.Error(\"HasRoleForUser returned an error: \", err.Error())\n\t}\n\tt.Log(name, \" has role \", role, \": \", myRes)\n\n\tif res != myRes {\n\t\tt.Error(name, \" has role \", role, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc TestRoleAPI(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\ttestGetRoles(t, e, []string{\"data2_admin\"}, \"alice\")\n\ttestGetRoles(t, e, []string{}, \"bob\")\n\ttestGetRoles(t, e, []string{}, \"data2_admin\")\n\ttestGetRoles(t, e, []string{}, \"non_exist\")\n\n\ttestHasRole(t, e, \"alice\", \"data1_admin\", false)\n\ttestHasRole(t, e, \"alice\", \"data2_admin\", true)\n\n\t_, _ = e.AddRoleForUser(\"alice\", \"data1_admin\")\n\n\ttestGetRoles(t, e, []string{\"data1_admin\", \"data2_admin\"}, \"alice\")\n\ttestGetRoles(t, e, []string{}, \"bob\")\n\ttestGetRoles(t, e, []string{}, \"data2_admin\")\n\n\t_, _ = e.DeleteRoleForUser(\"alice\", \"data1_admin\")\n\n\ttestGetRoles(t, e, []string{\"data2_admin\"}, \"alice\")\n\ttestGetRoles(t, e, []string{}, \"bob\")\n\ttestGetRoles(t, e, []string{}, \"data2_admin\")\n\n\t_, _ = e.DeleteRolesForUser(\"alice\")\n\n\ttestGetRoles(t, e, []string{}, \"alice\")\n\ttestGetRoles(t, e, []string{}, \"bob\")\n\ttestGetRoles(t, e, []string{}, \"data2_admin\")\n\n\t_, _ = e.AddRoleForUser(\"alice\", \"data1_admin\")\n\t_, _ = e.DeleteUser(\"alice\")\n\n\ttestGetRoles(t, e, []string{}, \"alice\")\n\ttestGetRoles(t, e, []string{}, \"bob\")\n\ttestGetRoles(t, e, []string{}, \"data2_admin\")\n\n\t_, _ = e.AddRoleForUser(\"alice\", \"data2_admin\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", true)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n\n\t_, _ = e.DeleteRole(\"data2_admin\")\n\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data1\", \"write\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n}\n\nfunc TestRoleAPI_Domains(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy.csv\")\n\n\ttestHasRole(t, e, \"alice\", \"admin\", true, \"domain1\")\n\ttestHasRole(t, e, \"alice\", \"admin\", false, \"domain2\")\n\ttestGetRoles(t, e, []string{\"admin\"}, \"alice\", \"domain1\")\n\ttestGetRoles(t, e, []string{}, \"bob\", \"domain1\")\n\ttestGetRoles(t, e, []string{}, \"admin\", \"domain1\")\n\ttestGetRoles(t, e, []string{}, \"non_exist\", \"domain1\")\n\ttestGetRoles(t, e, []string{}, \"alice\", \"domain2\")\n\ttestGetRoles(t, e, []string{\"admin\"}, \"bob\", \"domain2\")\n\ttestGetRoles(t, e, []string{}, \"admin\", \"domain2\")\n\ttestGetRoles(t, e, []string{}, \"non_exist\", \"domain2\")\n\n\t_, _ = e.DeleteRoleForUser(\"alice\", \"admin\", \"domain1\")\n\t_, _ = e.AddRoleForUser(\"bob\", \"admin\", \"domain1\")\n\n\ttestGetRoles(t, e, []string{}, \"alice\", \"domain1\")\n\ttestGetRoles(t, e, []string{\"admin\"}, \"bob\", \"domain1\")\n\ttestGetRoles(t, e, []string{}, \"admin\", \"domain1\")\n\ttestGetRoles(t, e, []string{}, \"non_exist\", \"domain1\")\n\ttestGetRoles(t, e, []string{}, \"alice\", \"domain2\")\n\ttestGetRoles(t, e, []string{\"admin\"}, \"bob\", \"domain2\")\n\ttestGetRoles(t, e, []string{}, \"admin\", \"domain2\")\n\ttestGetRoles(t, e, []string{}, \"non_exist\", \"domain2\")\n\n\t_, _ = e.AddRoleForUser(\"alice\", \"admin\", \"domain1\")\n\t_, _ = e.DeleteRolesForUser(\"bob\", \"domain1\")\n\n\ttestGetRoles(t, e, []string{\"admin\"}, \"alice\", \"domain1\")\n\ttestGetRoles(t, e, []string{}, \"bob\", \"domain1\")\n\ttestGetRoles(t, e, []string{}, \"admin\", \"domain1\")\n\ttestGetRoles(t, e, []string{}, \"non_exist\", \"domain1\")\n\ttestGetRoles(t, e, []string{}, \"alice\", \"domain2\")\n\ttestGetRoles(t, e, []string{\"admin\"}, \"bob\", \"domain2\")\n\ttestGetRoles(t, e, []string{}, \"admin\", \"domain2\")\n\ttestGetRoles(t, e, []string{}, \"non_exist\", \"domain2\")\n\n\t_, _ = e.AddRolesForUser(\"bob\", []string{\"admin\", \"admin1\", \"admin2\"}, \"domain1\")\n\n\ttestGetRoles(t, e, []string{\"admin\", \"admin1\", \"admin2\"}, \"bob\", \"domain1\")\n\n\ttestGetPermissions(t, e, \"admin\", [][]string{{\"admin\", \"domain1\", \"data1\", \"read\"}, {\"admin\", \"domain1\", \"data1\", \"write\"}}, \"domain1\")\n\ttestGetPermissions(t, e, \"admin\", [][]string{{\"admin\", \"domain2\", \"data2\", \"read\"}, {\"admin\", \"domain2\", \"data2\", \"write\"}}, \"domain2\")\n}\n\nfunc TestEnforcer_AddRolesForUser(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\t_, _ = e.AddRolesForUser(\"alice\", []string{\"data1_admin\", \"data2_admin\", \"data3_admin\"})\n\t// The \"alice\" already has \"data2_admin\" , it will be return false. So \"alice\" just has \"data2_admin\".\n\ttestGetRoles(t, e, []string{\"data2_admin\"}, \"alice\")\n\t// delete role\n\t_, _ = e.DeleteRoleForUser(\"alice\", \"data2_admin\")\n\n\t_, _ = e.AddRolesForUser(\"alice\", []string{\"data1_admin\", \"data2_admin\", \"data3_admin\"})\n\ttestGetRoles(t, e, []string{\"data1_admin\", \"data2_admin\", \"data3_admin\"}, \"alice\")\n\ttestEnforce(t, e, \"alice\", \"data1\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"read\", true)\n\ttestEnforce(t, e, \"alice\", \"data2\", \"write\", true)\n}\n\nfunc testGetPermissions(t *testing.T, e *Enforcer, name string, res [][]string, domain ...string) {\n\tt.Helper()\n\tmyRes, err := e.GetPermissionsForUser(name, domain...)\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tt.Log(\"Permissions for \", name, \": \", myRes)\n\n\tif !util.Array2DEquals(res, myRes) {\n\t\tt.Error(\"Permissions for \", name, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc testHasPermission(t *testing.T, e *Enforcer, name string, permission []string, res bool) {\n\tt.Helper()\n\tmyRes, err := e.HasPermissionForUser(name, permission...)\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tt.Log(name, \" has permission \", util.ArrayToString(permission), \": \", myRes)\n\n\tif res != myRes {\n\t\tt.Error(name, \" has permission \", util.ArrayToString(permission), \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc testGetNamedPermissionsForUser(t *testing.T, e *Enforcer, ptype string, name string, res [][]string, domain ...string) {\n\tt.Helper()\n\tmyRes, err := e.GetNamedPermissionsForUser(ptype, name, domain...)\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\tt.Log(\"Named permissions for \", name, \": \", myRes)\n\n\tif !util.Array2DEquals(res, myRes) {\n\t\tt.Error(\"Named permissions for \", name, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc TestPermissionAPI(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/basic_without_resources_model.conf\", \"examples/basic_without_resources_policy.csv\")\n\n\ttestEnforceWithoutUsers(t, e, \"alice\", \"read\", true)\n\ttestEnforceWithoutUsers(t, e, \"alice\", \"write\", false)\n\ttestEnforceWithoutUsers(t, e, \"bob\", \"read\", false)\n\ttestEnforceWithoutUsers(t, e, \"bob\", \"write\", true)\n\n\ttestGetPermissions(t, e, \"alice\", [][]string{{\"alice\", \"read\"}})\n\ttestGetPermissions(t, e, \"bob\", [][]string{{\"bob\", \"write\"}})\n\n\ttestHasPermission(t, e, \"alice\", []string{\"read\"}, true)\n\ttestHasPermission(t, e, \"alice\", []string{\"write\"}, false)\n\ttestHasPermission(t, e, \"bob\", []string{\"read\"}, false)\n\ttestHasPermission(t, e, \"bob\", []string{\"write\"}, true)\n\n\t_, _ = e.DeletePermission(\"read\")\n\n\ttestEnforceWithoutUsers(t, e, \"alice\", \"read\", false)\n\ttestEnforceWithoutUsers(t, e, \"alice\", \"write\", false)\n\ttestEnforceWithoutUsers(t, e, \"bob\", \"read\", false)\n\ttestEnforceWithoutUsers(t, e, \"bob\", \"write\", true)\n\n\t_, _ = e.AddPermissionForUser(\"bob\", \"read\")\n\n\ttestEnforceWithoutUsers(t, e, \"alice\", \"read\", false)\n\ttestEnforceWithoutUsers(t, e, \"alice\", \"write\", false)\n\ttestEnforceWithoutUsers(t, e, \"bob\", \"read\", true)\n\ttestEnforceWithoutUsers(t, e, \"bob\", \"write\", true)\n\n\t_, _ = e.AddPermissionsForUser(\"jack\",\n\t\t[]string{\"read\"},\n\t\t[]string{\"write\"})\n\n\ttestEnforceWithoutUsers(t, e, \"jack\", \"read\", true)\n\ttestEnforceWithoutUsers(t, e, \"bob\", \"write\", true)\n\n\t_, _ = e.DeletePermissionForUser(\"bob\", \"read\")\n\n\ttestEnforceWithoutUsers(t, e, \"alice\", \"read\", false)\n\ttestEnforceWithoutUsers(t, e, \"alice\", \"write\", false)\n\ttestEnforceWithoutUsers(t, e, \"bob\", \"read\", false)\n\ttestEnforceWithoutUsers(t, e, \"bob\", \"write\", true)\n\n\t_, _ = e.DeletePermissionsForUser(\"bob\")\n\n\ttestEnforceWithoutUsers(t, e, \"alice\", \"read\", false)\n\ttestEnforceWithoutUsers(t, e, \"alice\", \"write\", false)\n\ttestEnforceWithoutUsers(t, e, \"bob\", \"read\", false)\n\ttestEnforceWithoutUsers(t, e, \"bob\", \"write\", false)\n\n\te, _ = NewEnforcer(\"examples/rbac_with_multiple_policy_model.conf\", \"examples/rbac_with_multiple_policy_policy.csv\")\n\ttestGetNamedPermissionsForUser(t, e, \"p\", \"user\", [][]string{{\"user\", \"/data\", \"GET\"}})\n\ttestGetNamedPermissionsForUser(t, e, \"p2\", \"user\", [][]string{{\"user\", \"view\"}})\n}\n\nfunc testGetImplicitRoles(t *testing.T, e *Enforcer, name string, res []string) {\n\tt.Helper()\n\tmyRes, _ := e.GetImplicitRolesForUser(name)\n\tt.Log(\"Implicit roles for \", name, \": \", myRes)\n\n\tif !util.SetEquals(res, myRes) {\n\t\tt.Error(\"Implicit roles for \", name, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc testGetImplicitRolesInDomain(t *testing.T, e *Enforcer, name string, domain string, res []string) {\n\tt.Helper()\n\tmyRes, _ := e.GetImplicitRolesForUser(name, domain)\n\tt.Log(\"Implicit roles in domain \", domain, \" for \", name, \": \", myRes)\n\n\tif !util.SetEquals(res, myRes) {\n\t\tt.Error(\"Implicit roles in domain \", domain, \" for \", name, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc TestImplicitRoleAPI(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_with_hierarchy_policy.csv\")\n\n\ttestGetPermissions(t, e, \"alice\", [][]string{{\"alice\", \"data1\", \"read\"}})\n\ttestGetPermissions(t, e, \"bob\", [][]string{{\"bob\", \"data2\", \"write\"}})\n\n\ttestGetImplicitRoles(t, e, \"alice\", []string{\"admin\", \"data1_admin\", \"data2_admin\"})\n\ttestGetImplicitRoles(t, e, \"bob\", []string{})\n\n\te, _ = NewEnforcer(\"examples/rbac_with_pattern_model.conf\", \"examples/rbac_with_pattern_policy.csv\")\n\n\te.GetRoleManager().AddMatchingFunc(\"matcher\", util.KeyMatch)\n\te.AddNamedMatchingFunc(\"g2\", \"matcher\", util.KeyMatch)\n\n\t// testGetImplicitRoles(t, e, \"cathy\", []string{\"/book/1/2/3/4/5\", \"pen_admin\", \"/book/*\", \"book_group\"})\n\ttestGetImplicitRoles(t, e, \"cathy\", []string{\"/book/1/2/3/4/5\", \"pen_admin\"})\n\ttestGetRoles(t, e, []string{\"/book/1/2/3/4/5\", \"pen_admin\"}, \"cathy\")\n}\n\nfunc testGetImplicitPermissions(t *testing.T, e *Enforcer, name string, res [][]string, domain ...string) {\n\tt.Helper()\n\tmyRes, _ := e.GetImplicitPermissionsForUser(name, domain...)\n\tt.Log(\"Implicit permissions for \", name, \": \", myRes)\n\n\tif !util.Set2DEquals(res, myRes) {\n\t\tt.Error(\"Implicit permissions for \", name, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc testGetImplicitPermissionsWithDomain(t *testing.T, e *Enforcer, name string, domain string, res [][]string) {\n\tt.Helper()\n\tmyRes, _ := e.GetImplicitPermissionsForUser(name, domain)\n\tt.Log(\"Implicit permissions for\", name, \"under\", domain, \":\", myRes)\n\n\tif !util.Set2DEquals(res, myRes) {\n\t\tt.Error(\"Implicit permissions for\", name, \"under\", domain, \":\", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc testGetNamedImplicitPermissions(t *testing.T, e *Enforcer, ptype string, gtype string, name string, res [][]string) {\n\tt.Helper()\n\tmyRes, _ := e.GetNamedImplicitPermissionsForUser(ptype, gtype, name)\n\tt.Log(\"Named implicit permissions for \", name, \": \", myRes)\n\n\tif !util.Set2DEquals(res, myRes) {\n\t\tt.Error(\"Named implicit permissions for \", name, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc TestImplicitPermissionAPI(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_with_hierarchy_policy.csv\")\n\n\ttestGetPermissions(t, e, \"alice\", [][]string{{\"alice\", \"data1\", \"read\"}})\n\ttestGetPermissions(t, e, \"bob\", [][]string{{\"bob\", \"data2\", \"write\"}})\n\n\ttestGetImplicitPermissions(t, e, \"alice\", [][]string{{\"alice\", \"data1\", \"read\"}, {\"data1_admin\", \"data1\", \"read\"}, {\"data1_admin\", \"data1\", \"write\"}, {\"data2_admin\", \"data2\", \"read\"}, {\"data2_admin\", \"data2\", \"write\"}})\n\ttestGetImplicitPermissions(t, e, \"bob\", [][]string{{\"bob\", \"data2\", \"write\"}})\n\n\te, _ = NewEnforcer(\"examples/rbac_with_domain_pattern_model.conf\", \"examples/rbac_with_domain_pattern_policy.csv\")\n\te.AddNamedDomainMatchingFunc(\"g\", \"KeyMatch\", util.KeyMatch)\n\n\ttestGetImplicitPermissions(t, e, \"admin\", [][]string{{\"admin\", \"domain1\", \"data1\", \"read\"}, {\"admin\", \"domain1\", \"data1\", \"write\"}, {\"admin\", \"domain1\", \"data3\", \"read\"}}, \"domain1\")\n\n\t_, err := e.GetImplicitPermissionsForUser(\"admin\", \"domain1\", \"domain2\")\n\tif err == nil {\n\t\tt.Error(\"GetImplicitPermissionsForUser should not support multiple domains\")\n\t}\n\n\ttestGetImplicitPermissions(t, e, \"alice\",\n\t\t[][]string{{\"admin\", \"domain2\", \"data2\", \"read\"}, {\"admin\", \"domain2\", \"data2\", \"write\"}, {\"admin\", \"domain2\", \"data3\", \"read\"}},\n\t\t\"domain2\")\n\n\te, _ = NewEnforcer(\"examples/rbac_with_multiple_policy_model.conf\", \"examples/rbac_with_multiple_policy_policy.csv\")\n\n\ttestGetNamedImplicitPermissions(t, e, \"p\", \"g\", \"alice\", [][]string{{\"user\", \"/data\", \"GET\"}, {\"admin\", \"/data\", \"POST\"}})\n\ttestGetNamedImplicitPermissions(t, e, \"p2\", \"g\", \"alice\", [][]string{{\"user\", \"view\"}, {\"admin\", \"create\"}})\n\n\ttestGetNamedImplicitPermissions(t, e, \"p\", \"g2\", \"alice\", [][]string{{\"user\", \"/data\", \"GET\"}})\n\ttestGetNamedImplicitPermissions(t, e, \"p2\", \"g2\", \"alice\", [][]string{{\"user\", \"view\"}})\n}\n\nfunc TestImplicitPermissionAPIWithDomain(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_hierarchy_with_domains_policy.csv\")\n\ttestGetImplicitPermissionsWithDomain(t, e, \"alice\", \"domain1\", [][]string{{\"alice\", \"domain1\", \"data2\", \"read\"}, {\"role:reader\", \"domain1\", \"data1\", \"read\"}, {\"role:writer\", \"domain1\", \"data1\", \"write\"}})\n}\n\nfunc testGetImplicitUsers(t *testing.T, e *Enforcer, res []string, permission ...string) {\n\tt.Helper()\n\tmyRes, _ := e.GetImplicitUsersForPermission(permission...)\n\tt.Log(\"Implicit users for permission: \", permission, \": \", myRes)\n\n\tsort.Strings(res)\n\tsort.Strings(myRes)\n\n\tif !util.ArrayEquals(res, myRes) {\n\t\tt.Error(\"Implicit users for permission: \", permission, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc TestImplicitUserAPI(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_with_hierarchy_policy.csv\")\n\n\ttestGetImplicitUsers(t, e, []string{\"alice\"}, \"data1\", \"read\")\n\ttestGetImplicitUsers(t, e, []string{\"alice\"}, \"data1\", \"write\")\n\ttestGetImplicitUsers(t, e, []string{\"alice\"}, \"data2\", \"read\")\n\ttestGetImplicitUsers(t, e, []string{\"alice\", \"bob\"}, \"data2\", \"write\")\n\n\te.ClearPolicy()\n\t_, _ = e.AddPolicy(\"admin\", \"data1\", \"read\")\n\t_, _ = e.AddPolicy(\"bob\", \"data1\", \"read\")\n\t_, _ = e.AddGroupingPolicy(\"alice\", \"admin\")\n\ttestGetImplicitUsers(t, e, []string{\"alice\", \"bob\"}, \"data1\", \"read\")\n}\n\nfunc testGetImplicitResourcesForUser(t *testing.T, e *Enforcer, res [][]string, user string, domain ...string) {\n\tt.Helper()\n\tmyRes, _ := e.GetImplicitResourcesForUser(user, domain...)\n\tt.Log(\"Implicit resources for user: \", user, \": \", myRes)\n\n\tlessFunc := func(arr [][]string) func(int, int) bool {\n\t\treturn func(i, j int) bool {\n\t\t\tpolicy1, policy2 := arr[i], arr[j]\n\t\t\tfor k := range policy1 {\n\t\t\t\tif policy1[k] == policy2[k] {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn policy1[k] < policy2[k]\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t}\n\n\tsort.Slice(res, lessFunc(res))\n\tsort.Slice(myRes, lessFunc(myRes))\n\n\tif !util.Array2DEquals(res, myRes) {\n\t\tt.Error(\"Implicit resources for user: \", user, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc TestGetImplicitResourcesForUser(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_pattern_model.conf\", \"examples/rbac_with_pattern_policy.csv\")\n\ttestGetImplicitResourcesForUser(t, e, [][]string{\n\t\t{\"alice\", \"/pen/1\", \"GET\"},\n\t\t{\"alice\", \"/pen2/1\", \"GET\"},\n\t\t{\"alice\", \"/book/:id\", \"GET\"},\n\t\t{\"alice\", \"/book2/{id}\", \"GET\"},\n\t\t{\"alice\", \"/book/*\", \"GET\"},\n\t\t{\"alice\", \"book_group\", \"GET\"},\n\t}, \"alice\")\n\ttestGetImplicitResourcesForUser(t, e, [][]string{\n\t\t{\"bob\", \"pen_group\", \"GET\"},\n\t\t{\"bob\", \"/pen/:id\", \"GET\"},\n\t\t{\"bob\", \"/pen2/{id}\", \"GET\"},\n\t}, \"bob\")\n\ttestGetImplicitResourcesForUser(t, e, [][]string{\n\t\t{\"cathy\", \"pen_group\", \"GET\"},\n\t\t{\"cathy\", \"/pen/:id\", \"GET\"},\n\t\t{\"cathy\", \"/pen2/{id}\", \"GET\"},\n\t}, \"cathy\")\n}\n\nfunc TestImplicitUsersForRole(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_pattern_model.conf\", \"examples/rbac_with_pattern_policy.csv\")\n\n\ttestGetImplicitUsersForRole(t, e, \"book_admin\", []string{\"alice\"})\n\ttestGetImplicitUsersForRole(t, e, \"pen_admin\", []string{\"cathy\", \"bob\"})\n\n\ttestGetImplicitUsersForRole(t, e, \"book_group\", []string{\"/book/*\", \"/book/:id\", \"/book2/{id}\"})\n\ttestGetImplicitUsersForRole(t, e, \"pen_group\", []string{\"/pen/:id\", \"/pen2/{id}\"})\n}\n\nfunc testGetImplicitUsersForRole(t *testing.T, e *Enforcer, name string, res []string) {\n\tt.Helper()\n\tmyRes, _ := e.GetImplicitUsersForRole(name)\n\tt.Log(\"Implicit users for \", name, \": \", myRes)\n\tsort.Strings(res)\n\tsort.Strings(myRes)\n\n\tif !util.SetEquals(res, myRes) {\n\t\tt.Error(\"Implicit users for \", name, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc TestExplicitPriorityModify(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/priority_model_explicit.conf\", \"examples/priority_policy_explicit.csv\")\n\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n\t_, err := e.AddPolicy(\"1\", \"bob\", \"data2\", \"write\", \"deny\")\n\tif err != nil {\n\t\tt.Fatalf(\"AddPolicy: %v\", err)\n\t}\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", false)\n\n\t_, err = e.DeletePermissionsForUser(\"bob\")\n\tif err != nil {\n\t\tt.Fatalf(\"DeletePermissionForUser: %v\", err)\n\t}\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n\n\t_, err = e.DeleteRole(\"data2_allow_group\")\n\tif err != nil {\n\t\tt.Fatalf(\"DeleteRole: %v\", err)\n\t}\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", false)\n}\n\nfunc TestCustomizedFieldIndex(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/priority_model_explicit_customized.conf\",\n\t\t\"examples/priority_policy_explicit_customized.csv\")\n\n\t// Due to the customized priority token, the enforcer failed to handle the priority.\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", true)\n\n\t// set PriorityIndex and reload\n\te.SetFieldIndex(\"p\", constant.PriorityIndex, 0)\n\terr := e.LoadPolicy()\n\tif err != nil {\n\t\tt.Fatalf(\"LoadPolicy: %v\", err)\n\t}\n\ttestEnforce(t, e, \"bob\", \"data2\", \"read\", false)\n\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n\t_, err = e.AddPolicy(\"1\", \"data2\", \"write\", \"deny\", \"bob\")\n\tif err != nil {\n\t\tt.Fatalf(\"AddPolicy: %v\", err)\n\t}\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", false)\n\n\t// Due to the customized subject token, the enforcer will raise an error before SetFieldIndex.\n\t_, err = e.DeletePermissionsForUser(\"bob\")\n\tif err == nil {\n\t\tt.Fatalf(\"Failed to warning SetFieldIndex\")\n\t}\n\n\te.SetFieldIndex(\"p\", constant.SubjectIndex, 4)\n\n\t_, err = e.DeletePermissionsForUser(\"bob\")\n\tif err != nil {\n\t\tt.Fatalf(\"DeletePermissionForUser: %v\", err)\n\t}\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", true)\n\n\t_, err = e.DeleteRole(\"data2_allow_group\")\n\tif err != nil {\n\t\tt.Fatalf(\"DeleteRole: %v\", err)\n\t}\n\ttestEnforce(t, e, \"bob\", \"data2\", \"write\", false)\n}\n\nfunc testGetAllowedObjectConditions(t *testing.T, e *Enforcer, user string, act string, prefix string, res []string, expectedErr error) {\n\tmyRes, actualErr := e.GetAllowedObjectConditions(user, act, prefix)\n\n\tif actualErr != expectedErr {\n\t\tt.Error(\"actual Err: \", actualErr, \", supposed to be \", expectedErr)\n\t}\n\tif actualErr == nil {\n\t\tlog.Print(\"Policy: \", myRes)\n\t\tif !util.ArrayEquals(res, myRes) {\n\t\t\tt.Error(\"Policy: \", myRes, \", supposed to be \", res)\n\t\t}\n\t}\n}\n\nfunc TestGetAllowedObjectConditions(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/object_conditions_model.conf\", \"examples/object_conditions_policy.csv\")\n\ttestGetAllowedObjectConditions(t, e, \"alice\", \"read\", \"r.obj.\", []string{\"price < 25\", \"category_id = 2\"}, nil)\n\ttestGetAllowedObjectConditions(t, e, \"admin\", \"read\", \"r.obj.\", []string{\"category_id = 2\"}, nil)\n\ttestGetAllowedObjectConditions(t, e, \"bob\", \"write\", \"r.obj.\", []string{\"author = bob\"}, nil)\n\n\t// test ErrEmptyCondition\n\ttestGetAllowedObjectConditions(t, e, \"alice\", \"write\", \"r.obj.\", []string{}, errors.ErrEmptyCondition)\n\ttestGetAllowedObjectConditions(t, e, \"bob\", \"read\", \"r.obj.\", []string{}, errors.ErrEmptyCondition)\n\n\t// test ErrObjCondition\n\t// should : e.AddPolicy(\"alice\", \"r.obj.price > 50\", \"read\")\n\tok, _ := e.AddPolicy(\"alice\", \"price > 50\", \"read\")\n\tif ok {\n\t\ttestGetAllowedObjectConditions(t, e, \"alice\", \"read\", \"r.obj.\", []string{}, errors.ErrObjCondition)\n\t}\n\n\t// test prefix\n\te.ClearPolicy()\n\terr := e.GetRoleManager().DeleteLink(\"alice\", \"admin\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tok, _ = e.AddPolicies([][]string{\n\t\t{\"alice\", \"r.book.price < 25\", \"read\"},\n\t\t{\"admin\", \"r.book.category_id = 2\", \"read\"},\n\t\t{\"bob\", \"r.book.author = bob\", \"write\"},\n\t})\n\tif ok {\n\t\ttestGetAllowedObjectConditions(t, e, \"alice\", \"read\", \"r.book.\", []string{\"price < 25\"}, nil)\n\t\ttestGetAllowedObjectConditions(t, e, \"admin\", \"read\", \"r.book.\", []string{\"category_id = 2\"}, nil)\n\t\ttestGetAllowedObjectConditions(t, e, \"bob\", \"write\", \"r.book.\", []string{\"author = bob\"}, nil)\n\t}\n}\n\nfunc testGetImplicitUsersForResource(t *testing.T, e *Enforcer, res [][]string, resource string, domain ...string) {\n\tt.Helper()\n\tmyRes, err := e.GetImplicitUsersForResource(resource)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif !util.Set2DEquals(res, myRes) {\n\t\tt.Error(\"Implicit users for \", resource, \"in domain \", domain, \" : \", myRes, \", supposed to be \", res)\n\t} else {\n\t\tt.Log(\"Implicit users for \", resource, \"in domain \", domain, \" : \", myRes)\n\t}\n}\n\nfunc TestGetImplicitUsersForResource(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\ttestGetImplicitUsersForResource(t, e, [][]string{{\"alice\", \"data1\", \"read\"}}, \"data1\")\n\ttestGetImplicitUsersForResource(t, e, [][]string{{\"bob\", \"data2\", \"write\"},\n\t\t{\"alice\", \"data2\", \"read\"},\n\t\t{\"alice\", \"data2\", \"write\"}}, \"data2\")\n\n\t// test duplicate permissions\n\t_, _ = e.AddGroupingPolicy(\"alice\", \"data2_admin_2\")\n\t_, _ = e.AddPolicies([][]string{{\"data2_admin_2\", \"data2\", \"read\"}, {\"data2_admin_2\", \"data2\", \"write\"}})\n\ttestGetImplicitUsersForResource(t, e, [][]string{{\"bob\", \"data2\", \"write\"},\n\t\t{\"alice\", \"data2\", \"read\"},\n\t\t{\"alice\", \"data2\", \"write\"}}, \"data2\")\n}\n\nfunc testGetImplicitUsersForResourceByDomain(t *testing.T, e *Enforcer, res [][]string, resource string, domain string) {\n\tt.Helper()\n\tmyRes, err := e.GetImplicitUsersForResourceByDomain(resource, domain)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif !util.Set2DEquals(res, myRes) {\n\t\tt.Error(\"Implicit users for \", resource, \"in domain \", domain, \" : \", myRes, \", supposed to be \", res)\n\t} else {\n\t\tt.Log(\"Implicit users for \", resource, \"in domain \", domain, \" : \", myRes)\n\t}\n}\n\nfunc TestGetImplicitUsersForResourceByDomain(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy.csv\")\n\ttestGetImplicitUsersForResourceByDomain(t, e, [][]string{{\"alice\", \"domain1\", \"data1\", \"read\"},\n\t\t{\"alice\", \"domain1\", \"data1\", \"write\"}}, \"data1\", \"domain1\")\n\n\ttestGetImplicitUsersForResourceByDomain(t, e, [][]string{}, \"data2\", \"domain1\")\n\n\ttestGetImplicitUsersForResourceByDomain(t, e, [][]string{{\"bob\", \"domain2\", \"data2\", \"read\"},\n\t\t{\"bob\", \"domain2\", \"data2\", \"write\"}}, \"data2\", \"domain2\")\n}\n"
        },
        {
          "name": "rbac_api_with_domains.go",
          "type": "blob",
          "size": 5.71484375,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/casbin/casbin/v2/constant\"\n)\n\n// GetUsersForRoleInDomain gets the users that has a role inside a domain. Add by Gordon.\nfunc (e *Enforcer) GetUsersForRoleInDomain(name string, domain string) []string {\n\tif e.GetRoleManager() == nil {\n\t\treturn nil\n\t}\n\tres, _ := e.GetRoleManager().GetUsers(name, domain)\n\treturn res\n}\n\n// GetRolesForUserInDomain gets the roles that a user has inside a domain.\nfunc (e *Enforcer) GetRolesForUserInDomain(name string, domain string) []string {\n\tif e.GetRoleManager() == nil {\n\t\treturn nil\n\t}\n\tres, _ := e.GetRoleManager().GetRoles(name, domain)\n\treturn res\n}\n\n// GetPermissionsForUserInDomain gets permissions for a user or role inside a domain.\nfunc (e *Enforcer) GetPermissionsForUserInDomain(user string, domain string) [][]string {\n\tres, _ := e.GetImplicitPermissionsForUser(user, domain)\n\treturn res\n}\n\n// AddRoleForUserInDomain adds a role for a user inside a domain.\n// Returns false if the user already has the role (aka not affected).\nfunc (e *Enforcer) AddRoleForUserInDomain(user string, role string, domain string) (bool, error) {\n\treturn e.AddGroupingPolicy(user, role, domain)\n}\n\n// DeleteRoleForUserInDomain deletes a role for a user inside a domain.\n// Returns false if the user does not have the role (aka not affected).\nfunc (e *Enforcer) DeleteRoleForUserInDomain(user string, role string, domain string) (bool, error) {\n\treturn e.RemoveGroupingPolicy(user, role, domain)\n}\n\n// DeleteRolesForUserInDomain deletes all roles for a user inside a domain.\n// Returns false if the user does not have any roles (aka not affected).\nfunc (e *Enforcer) DeleteRolesForUserInDomain(user string, domain string) (bool, error) {\n\tif e.GetRoleManager() == nil {\n\t\treturn false, fmt.Errorf(\"role manager is not initialized\")\n\t}\n\troles, err := e.GetRoleManager().GetRoles(user, domain)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tvar rules [][]string\n\tfor _, role := range roles {\n\t\trules = append(rules, []string{user, role, domain})\n\t}\n\n\treturn e.RemoveGroupingPolicies(rules)\n}\n\n// GetAllUsersByDomain would get all users associated with the domain.\nfunc (e *Enforcer) GetAllUsersByDomain(domain string) ([]string, error) {\n\tm := make(map[string]struct{})\n\tg, err := e.model.GetAssertion(\"g\", \"g\")\n\tif err != nil {\n\t\treturn []string{}, err\n\t}\n\tp := e.model[\"p\"][\"p\"]\n\tusers := make([]string, 0)\n\tindex, err := e.GetFieldIndex(\"p\", constant.DomainIndex)\n\tif err != nil {\n\t\treturn []string{}, err\n\t}\n\n\tgetUser := func(index int, policies [][]string, domain string, m map[string]struct{}) []string {\n\t\tif len(policies) == 0 || len(policies[0]) <= index {\n\t\t\treturn []string{}\n\t\t}\n\t\tres := make([]string, 0)\n\t\tfor _, policy := range policies {\n\t\t\tif _, ok := m[policy[0]]; policy[index] == domain && !ok {\n\t\t\t\tres = append(res, policy[0])\n\t\t\t\tm[policy[0]] = struct{}{}\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tusers = append(users, getUser(2, g.Policy, domain, m)...)\n\tusers = append(users, getUser(index, p.Policy, domain, m)...)\n\treturn users, nil\n}\n\n// DeleteAllUsersByDomain would delete all users associated with the domain.\nfunc (e *Enforcer) DeleteAllUsersByDomain(domain string) (bool, error) {\n\tg, err := e.model.GetAssertion(\"g\", \"g\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tp := e.model[\"p\"][\"p\"]\n\tindex, err := e.GetFieldIndex(\"p\", constant.DomainIndex)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tgetUser := func(index int, policies [][]string, domain string) [][]string {\n\t\tif len(policies) == 0 || len(policies[0]) <= index {\n\t\t\treturn [][]string{}\n\t\t}\n\t\tres := make([][]string, 0)\n\t\tfor _, policy := range policies {\n\t\t\tif policy[index] == domain {\n\t\t\t\tres = append(res, policy)\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tusers := getUser(2, g.Policy, domain)\n\tif _, err = e.RemoveGroupingPolicies(users); err != nil {\n\t\treturn false, err\n\t}\n\tusers = getUser(index, p.Policy, domain)\n\tif _, err = e.RemovePolicies(users); err != nil {\n\t\treturn false, err\n\t}\n\treturn true, nil\n}\n\n// DeleteDomains would delete all associated users and roles.\n// It would delete all domains if parameter is not provided.\nfunc (e *Enforcer) DeleteDomains(domains ...string) (bool, error) {\n\tif len(domains) == 0 {\n\t\te.ClearPolicy()\n\t\treturn true, nil\n\t}\n\tfor _, domain := range domains {\n\t\tif _, err := e.DeleteAllUsersByDomain(domain); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\treturn true, nil\n}\n\n// GetAllDomains would get all domains.\nfunc (e *Enforcer) GetAllDomains() ([]string, error) {\n\tif e.GetRoleManager() == nil {\n\t\treturn nil, fmt.Errorf(\"role manager is not initialized\")\n\t}\n\treturn e.GetRoleManager().GetAllDomains()\n}\n\n// GetAllRolesByDomain would get all roles associated with the domain.\n// note: Not applicable to Domains with inheritance relationship  (implicit roles)\nfunc (e *Enforcer) GetAllRolesByDomain(domain string) ([]string, error) {\n\tg, err := e.model.GetAssertion(\"g\", \"g\")\n\tif err != nil {\n\t\treturn []string{}, err\n\t}\n\tpolicies := g.Policy\n\troles := make([]string, 0)\n\texistMap := make(map[string]bool) // remove duplicates\n\n\tfor _, policy := range policies {\n\t\tif policy[len(policy)-1] == domain {\n\t\t\trole := policy[len(policy)-2]\n\t\t\tif _, ok := existMap[role]; !ok {\n\t\t\t\troles = append(roles, role)\n\t\t\t\texistMap[role] = true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn roles, nil\n}\n"
        },
        {
          "name": "rbac_api_with_domains_synced.go",
          "type": "blob",
          "size": 2.4169921875,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\n// GetUsersForRoleInDomain gets the users that has a role inside a domain. Add by Gordon.\nfunc (e *SyncedEnforcer) GetUsersForRoleInDomain(name string, domain string) []string {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetUsersForRoleInDomain(name, domain)\n}\n\n// GetRolesForUserInDomain gets the roles that a user has inside a domain.\nfunc (e *SyncedEnforcer) GetRolesForUserInDomain(name string, domain string) []string {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetRolesForUserInDomain(name, domain)\n}\n\n// GetPermissionsForUserInDomain gets permissions for a user or role inside a domain.\nfunc (e *SyncedEnforcer) GetPermissionsForUserInDomain(user string, domain string) [][]string {\n\te.m.RLock()\n\tdefer e.m.RUnlock()\n\treturn e.Enforcer.GetPermissionsForUserInDomain(user, domain)\n}\n\n// AddRoleForUserInDomain adds a role for a user inside a domain.\n// Returns false if the user already has the role (aka not affected).\nfunc (e *SyncedEnforcer) AddRoleForUserInDomain(user string, role string, domain string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.AddRoleForUserInDomain(user, role, domain)\n}\n\n// DeleteRoleForUserInDomain deletes a role for a user inside a domain.\n// Returns false if the user does not have the role (aka not affected).\nfunc (e *SyncedEnforcer) DeleteRoleForUserInDomain(user string, role string, domain string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.DeleteRoleForUserInDomain(user, role, domain)\n}\n\n// DeleteRolesForUserInDomain deletes all roles for a user inside a domain.\n// Returns false if the user does not have any roles (aka not affected).\nfunc (e *SyncedEnforcer) DeleteRolesForUserInDomain(user string, domain string) (bool, error) {\n\te.m.Lock()\n\tdefer e.m.Unlock()\n\treturn e.Enforcer.DeleteRolesForUserInDomain(user, domain)\n}\n"
        },
        {
          "name": "rbac_api_with_domains_test.go",
          "type": "blob",
          "size": 11.1953125,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/casbin/casbin/v2/util\"\n)\n\n// testGetUsersInDomain: Add by Gordon.\nfunc testGetUsersInDomain(t *testing.T, e *Enforcer, name string, domain string, res []string) {\n\tt.Helper()\n\tmyRes := e.GetUsersForRoleInDomain(name, domain)\n\tt.Log(\"Users for \", name, \" under \", domain, \": \", myRes)\n\n\tif !util.SetEquals(res, myRes) {\n\t\tt.Error(\"Users for \", name, \" under \", domain, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc testGetRolesInDomain(t *testing.T, e *Enforcer, name string, domain string, res []string) {\n\tt.Helper()\n\tmyRes := e.GetRolesForUserInDomain(name, domain)\n\tt.Log(\"Roles for \", name, \" under \", domain, \": \", myRes)\n\n\tif !util.SetEquals(res, myRes) {\n\t\tt.Error(\"Roles for \", name, \" under \", domain, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc TestGetImplicitRolesForDomainUser(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_hierarchy_with_domains_policy.csv\")\n\n\t// This is only able to retrieve the first level of roles.\n\ttestGetRolesInDomain(t, e, \"alice\", \"domain1\", []string{\"role:global_admin\"})\n\n\t// Retrieve all inherit roles. It supports domains as well.\n\ttestGetImplicitRolesInDomain(t, e, \"alice\", \"domain1\", []string{\"role:global_admin\", \"role:reader\", \"role:writer\"})\n}\n\n// TestUserAPIWithDomains: Add by Gordon.\nfunc TestUserAPIWithDomains(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy.csv\")\n\n\ttestGetUsers(t, e, []string{\"alice\"}, \"admin\", \"domain1\")\n\ttestGetUsersInDomain(t, e, \"admin\", \"domain1\", []string{\"alice\"})\n\n\ttestGetUsers(t, e, []string{}, \"non_exist\", \"domain1\")\n\ttestGetUsersInDomain(t, e, \"non_exist\", \"domain1\", []string{})\n\n\ttestGetUsers(t, e, []string{\"bob\"}, \"admin\", \"domain2\")\n\ttestGetUsersInDomain(t, e, \"admin\", \"domain2\", []string{\"bob\"})\n\n\ttestGetUsers(t, e, []string{}, \"non_exist\", \"domain2\")\n\ttestGetUsersInDomain(t, e, \"non_exist\", \"domain2\", []string{})\n\n\t_, _ = e.DeleteRoleForUserInDomain(\"alice\", \"admin\", \"domain1\")\n\t_, _ = e.AddRoleForUserInDomain(\"bob\", \"admin\", \"domain1\")\n\n\ttestGetUsers(t, e, []string{\"bob\"}, \"admin\", \"domain1\")\n\ttestGetUsersInDomain(t, e, \"admin\", \"domain1\", []string{\"bob\"})\n\n\ttestGetUsers(t, e, []string{}, \"non_exist\", \"domain1\")\n\ttestGetUsersInDomain(t, e, \"non_exist\", \"domain1\", []string{})\n\n\ttestGetUsers(t, e, []string{\"bob\"}, \"admin\", \"domain2\")\n\ttestGetUsersInDomain(t, e, \"admin\", \"domain2\", []string{\"bob\"})\n\n\ttestGetUsers(t, e, []string{}, \"non_exist\", \"domain2\")\n\ttestGetUsersInDomain(t, e, \"non_exist\", \"domain2\", []string{})\n}\n\nfunc TestRoleAPIWithDomains(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy.csv\")\n\n\ttestGetRoles(t, e, []string{\"admin\"}, \"alice\", \"domain1\")\n\ttestGetRolesInDomain(t, e, \"alice\", \"domain1\", []string{\"admin\"})\n\n\ttestGetRoles(t, e, []string{}, \"bob\", \"domain1\")\n\ttestGetRolesInDomain(t, e, \"bob\", \"domain1\", []string{})\n\n\ttestGetRoles(t, e, []string{}, \"admin\", \"domain1\")\n\ttestGetRolesInDomain(t, e, \"admin\", \"domain1\", []string{})\n\n\ttestGetRoles(t, e, []string{}, \"non_exist\", \"domain1\")\n\ttestGetRolesInDomain(t, e, \"non_exist\", \"domain1\", []string{})\n\n\ttestGetRoles(t, e, []string{}, \"alice\", \"domain2\")\n\ttestGetRolesInDomain(t, e, \"alice\", \"domain2\", []string{})\n\n\ttestGetRoles(t, e, []string{\"admin\"}, \"bob\", \"domain2\")\n\ttestGetRolesInDomain(t, e, \"bob\", \"domain2\", []string{\"admin\"})\n\n\ttestGetRoles(t, e, []string{}, \"admin\", \"domain2\")\n\ttestGetRolesInDomain(t, e, \"admin\", \"domain2\", []string{})\n\n\ttestGetRoles(t, e, []string{}, \"non_exist\", \"domain2\")\n\ttestGetRolesInDomain(t, e, \"non_exist\", \"domain2\", []string{})\n\n\t_, _ = e.DeleteRoleForUserInDomain(\"alice\", \"admin\", \"domain1\")\n\t_, _ = e.AddRoleForUserInDomain(\"bob\", \"admin\", \"domain1\")\n\n\ttestGetRoles(t, e, []string{}, \"alice\", \"domain1\")\n\ttestGetRolesInDomain(t, e, \"alice\", \"domain1\", []string{})\n\n\ttestGetRoles(t, e, []string{\"admin\"}, \"bob\", \"domain1\")\n\ttestGetRolesInDomain(t, e, \"bob\", \"domain1\", []string{\"admin\"})\n\n\ttestGetRoles(t, e, []string{}, \"admin\", \"domain1\")\n\ttestGetRolesInDomain(t, e, \"admin\", \"domain1\", []string{})\n\n\ttestGetRoles(t, e, []string{}, \"non_exist\", \"domain1\")\n\ttestGetRolesInDomain(t, e, \"non_exist\", \"domain1\", []string{})\n\n\ttestGetRoles(t, e, []string{}, \"alice\", \"domain2\")\n\ttestGetRolesInDomain(t, e, \"alice\", \"domain2\", []string{})\n\n\ttestGetRoles(t, e, []string{\"admin\"}, \"bob\", \"domain2\")\n\ttestGetRolesInDomain(t, e, \"bob\", \"domain2\", []string{\"admin\"})\n\n\ttestGetRoles(t, e, []string{}, \"admin\", \"domain2\")\n\ttestGetRolesInDomain(t, e, \"admin\", \"domain2\", []string{})\n\n\ttestGetRoles(t, e, []string{}, \"non_exist\", \"domain2\")\n\ttestGetRolesInDomain(t, e, \"non_exist\", \"domain2\", []string{})\n\n\t_, _ = e.AddRoleForUserInDomain(\"alice\", \"admin\", \"domain1\")\n\t_, _ = e.DeleteRolesForUserInDomain(\"bob\", \"domain1\")\n\n\ttestGetRoles(t, e, []string{\"admin\"}, \"alice\", \"domain1\")\n\ttestGetRolesInDomain(t, e, \"alice\", \"domain1\", []string{\"admin\"})\n\n\ttestGetRoles(t, e, []string{}, \"bob\", \"domain1\")\n\ttestGetRolesInDomain(t, e, \"bob\", \"domain1\", []string{})\n\n\ttestGetRoles(t, e, []string{}, \"admin\", \"domain1\")\n\ttestGetRolesInDomain(t, e, \"admin\", \"domain1\", []string{})\n\n\ttestGetRoles(t, e, []string{}, \"non_exist\", \"domain1\")\n\ttestGetRolesInDomain(t, e, \"non_exist\", \"domain1\", []string{})\n\n\ttestGetRoles(t, e, []string{}, \"alice\", \"domain2\")\n\ttestGetRolesInDomain(t, e, \"alice\", \"domain2\", []string{})\n\n\ttestGetRoles(t, e, []string{\"admin\"}, \"bob\", \"domain2\")\n\ttestGetRolesInDomain(t, e, \"bob\", \"domain2\", []string{\"admin\"})\n\n\ttestGetRoles(t, e, []string{}, \"admin\", \"domain2\")\n\ttestGetRolesInDomain(t, e, \"admin\", \"domain2\", []string{})\n\n\ttestGetRoles(t, e, []string{}, \"non_exist\", \"domain2\")\n\ttestGetRolesInDomain(t, e, \"non_exist\", \"domain2\", []string{})\n}\n\nfunc testGetPermissionsInDomain(t *testing.T, e *Enforcer, name string, domain string, res [][]string) {\n\tt.Helper()\n\tmyRes := e.GetPermissionsForUserInDomain(name, domain)\n\tt.Log(\"Permissions for \", name, \" under \", domain, \": \", myRes)\n\n\tif !util.Array2DEquals(res, myRes) {\n\t\tt.Error(\"Permissions for \", name, \" under \", domain, \": \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc TestPermissionAPIInDomain(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy.csv\")\n\n\ttestGetPermissionsInDomain(t, e, \"alice\", \"domain1\", [][]string{{\"admin\", \"domain1\", \"data1\", \"read\"}, {\"admin\", \"domain1\", \"data1\", \"write\"}})\n\ttestGetPermissionsInDomain(t, e, \"bob\", \"domain1\", [][]string{})\n\ttestGetPermissionsInDomain(t, e, \"admin\", \"domain1\", [][]string{{\"admin\", \"domain1\", \"data1\", \"read\"}, {\"admin\", \"domain1\", \"data1\", \"write\"}})\n\ttestGetPermissionsInDomain(t, e, \"non_exist\", \"domain1\", [][]string{})\n\n\ttestGetPermissionsInDomain(t, e, \"alice\", \"domain2\", [][]string{})\n\ttestGetPermissionsInDomain(t, e, \"bob\", \"domain2\", [][]string{{\"admin\", \"domain2\", \"data2\", \"read\"}, {\"admin\", \"domain2\", \"data2\", \"write\"}})\n\ttestGetPermissionsInDomain(t, e, \"admin\", \"domain2\", [][]string{{\"admin\", \"domain2\", \"data2\", \"read\"}, {\"admin\", \"domain2\", \"data2\", \"write\"}})\n\ttestGetPermissionsInDomain(t, e, \"non_exist\", \"domain2\", [][]string{})\n}\n\nfunc testGetDomainsForUser(t *testing.T, e *Enforcer, res []string, user string) {\n\tt.Helper()\n\tmyRes, _ := e.GetDomainsForUser(user)\n\n\tsort.Strings(myRes)\n\tsort.Strings(res)\n\n\tif !util.SetEquals(res, myRes) {\n\t\tt.Error(\"domains for user: \", user, \": \", myRes, \",  supposed to be \", res)\n\t}\n}\n\nfunc TestGetDomainsForUser(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy2.csv\")\n\n\ttestGetDomainsForUser(t, e, []string{\"domain1\", \"domain2\"}, \"alice\")\n\ttestGetDomainsForUser(t, e, []string{\"domain2\", \"domain3\"}, \"bob\")\n\ttestGetDomainsForUser(t, e, []string{\"domain3\"}, \"user\")\n}\n\nfunc testGetAllUsersByDomain(t *testing.T, e *Enforcer, domain string, expected []string) {\n\tusers, _ := e.GetAllUsersByDomain(domain)\n\tif !util.SetEquals(users, expected) {\n\t\tt.Errorf(\"users in %s: %v, supposed to be %v\\n\", domain, users, expected)\n\t}\n}\n\nfunc TestGetAllUsersByDomain(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy.csv\")\n\n\ttestGetAllUsersByDomain(t, e, \"domain1\", []string{\"alice\", \"admin\"})\n\ttestGetAllUsersByDomain(t, e, \"domain2\", []string{\"bob\", \"admin\"})\n}\n\nfunc testDeleteAllUsersByDomain(t *testing.T, domain string, expectedPolicy, expectedGroupingPolicy [][]string) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy.csv\")\n\n\t_, _ = e.DeleteAllUsersByDomain(domain)\n\tpolicy, err := e.GetPolicy()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !util.Array2DEquals(policy, expectedPolicy) {\n\t\tt.Errorf(\"policy in %s: %v, supposed to be %v\\n\", domain, policy, expectedPolicy)\n\t}\n\n\tpolicies, err := e.GetGroupingPolicy()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif !util.Array2DEquals(policies, expectedGroupingPolicy) {\n\t\tt.Errorf(\"grouping policy in %s: %v, supposed to be %v\\n\", domain, policies, expectedGroupingPolicy)\n\t}\n}\n\nfunc TestDeleteAllUsersByDomain(t *testing.T) {\n\ttestDeleteAllUsersByDomain(t, \"domain1\", [][]string{\n\t\t{\"admin\", \"domain2\", \"data2\", \"read\"},\n\t\t{\"admin\", \"domain2\", \"data2\", \"write\"},\n\t}, [][]string{\n\t\t{\"bob\", \"admin\", \"domain2\"},\n\t})\n\ttestDeleteAllUsersByDomain(t, \"domain2\", [][]string{\n\t\t{\"admin\", \"domain1\", \"data1\", \"read\"},\n\t\t{\"admin\", \"domain1\", \"data1\", \"write\"},\n\t}, [][]string{\n\t\t{\"alice\", \"admin\", \"domain1\"},\n\t})\n}\n\n// testGetAllDomains tests GetAllDomains().\nfunc testGetAllDomains(t *testing.T, e *Enforcer, res []string) {\n\tt.Helper()\n\tmyRes, _ := e.GetAllDomains()\n\tsort.Strings(myRes)\n\tsort.Strings(res)\n\tif !util.ArrayEquals(res, myRes) {\n\t\tt.Error(\"domains: \", myRes, \", supposed to be \", res)\n\t}\n}\n\nfunc TestGetAllDomains(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy.csv\")\n\n\ttestGetAllDomains(t, e, []string{\"domain1\", \"domain2\"})\n}\n\nfunc testGetAllRolesByDomain(t *testing.T, e *Enforcer, domain string, expected []string) {\n\troles, _ := e.GetAllRolesByDomain(domain)\n\tif !util.SetEquals(roles, expected) {\n\t\tt.Errorf(\"roles in %s: %v, supposed to be %v\\n\", domain, roles, expected)\n\t}\n}\n\nfunc TestGetAllRolesByDomain(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy.csv\")\n\n\ttestGetAllRolesByDomain(t, e, \"domain1\", []string{\"admin\"})\n\ttestGetAllRolesByDomain(t, e, \"domain2\", []string{\"admin\"})\n\n\te, _ = NewEnforcer(\"examples/rbac_with_domains_model.conf\", \"examples/rbac_with_domains_policy2.csv\")\n\n\ttestGetAllRolesByDomain(t, e, \"domain1\", []string{\"admin\"})\n\ttestGetAllRolesByDomain(t, e, \"domain2\", []string{\"admin\"})\n\ttestGetAllRolesByDomain(t, e, \"domain3\", []string{\"user\"})\n}\n"
        },
        {
          "name": "role_manager_b_test.go",
          "type": "blob",
          "size": 5.068359375,
          "content": "package casbin\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/casbin/casbin/v2/util\"\n)\n\nfunc BenchmarkRoleManagerSmall(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", false)\n\t// Do not rebuild the role inheritance relations for every AddGroupingPolicy() call.\n\te.EnableAutoBuildRoleLinks(false)\n\n\t// 100 roles, 10 resources.\n\tpPolicies := make([][]string, 0)\n\tfor i := 0; i < 100; i++ {\n\t\tpPolicies = append(pPolicies, []string{fmt.Sprintf(\"group%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\"})\n\t}\n\n\t_, err := e.AddPolicies(pPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\t// 1000 users.\n\tgPolicies := make([][]string, 0)\n\tfor i := 0; i < 1000; i++ {\n\t\tgPolicies = append(gPolicies, []string{fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"group%d\", i/10)})\n\t}\n\n\t_, err = e.AddGroupingPolicies(gPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\trm := e.GetRoleManager()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tfor j := 0; j < 100; j++ {\n\t\t\t_, _ = rm.HasLink(\"user501\", fmt.Sprintf(\"group%d\", j))\n\t\t}\n\t}\n}\n\nfunc BenchmarkRoleManagerMedium(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", false)\n\t// Do not rebuild the role inheritance relations for every AddGroupingPolicy() call.\n\te.EnableAutoBuildRoleLinks(false)\n\n\t// 1000 roles, 100 resources.\n\tpPolicies := make([][]string, 0)\n\tfor i := 0; i < 1000; i++ {\n\t\tpPolicies = append(pPolicies, []string{fmt.Sprintf(\"group%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\"})\n\t}\n\t_, err := e.AddPolicies(pPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\t// 10000 users.\n\tgPolicies := make([][]string, 0)\n\tfor i := 0; i < 10000; i++ {\n\t\tgPolicies = append(gPolicies, []string{fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"group%d\", i/10)})\n\t}\n\n\t_, err = e.AddGroupingPolicies(gPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\terr = e.BuildRoleLinks()\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\trm := e.GetRoleManager()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tfor j := 0; j < 1000; j++ {\n\t\t\t_, _ = rm.HasLink(\"user501\", fmt.Sprintf(\"group%d\", j))\n\t\t}\n\t}\n}\n\nfunc BenchmarkRoleManagerLarge(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", false)\n\n\t// 10000 roles, 1000 resources.\n\tpPolicies := make([][]string, 0)\n\tfor i := 0; i < 10000; i++ {\n\t\tpPolicies = append(pPolicies, []string{fmt.Sprintf(\"group%d\", i), fmt.Sprintf(\"data%d\", i/10), \"read\"})\n\t}\n\n\t_, err := e.AddPolicies(pPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\t// 100000 users.\n\tgPolicies := make([][]string, 0)\n\tfor i := 0; i < 100000; i++ {\n\t\tgPolicies = append(gPolicies, []string{fmt.Sprintf(\"user%d\", i), fmt.Sprintf(\"group%d\", i/10)})\n\t}\n\n\t_, err = e.AddGroupingPolicies(gPolicies)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\trm := e.GetRoleManager()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tfor j := 0; j < 10000; j++ {\n\t\t\t_, _ = rm.HasLink(\"user501\", fmt.Sprintf(\"group%d\", j))\n\t\t}\n\t}\n}\n\nfunc BenchmarkBuildRoleLinksWithPatternLarge(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/performance/rbac_with_pattern_large_scale_model.conf\", \"examples/performance/rbac_with_pattern_large_scale_policy.csv\")\n\te.AddNamedMatchingFunc(\"g\", \"\", util.KeyMatch4)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = e.BuildRoleLinks()\n\t}\n}\n\nfunc BenchmarkBuildRoleLinksWithDomainPatternLarge(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/performance/rbac_with_pattern_large_scale_model.conf\", \"examples/performance/rbac_with_pattern_large_scale_policy.csv\")\n\te.AddNamedDomainMatchingFunc(\"g\", \"\", util.KeyMatch4)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = e.BuildRoleLinks()\n\t}\n}\n\nfunc BenchmarkBuildRoleLinksWithPatternAndDomainPatternLarge(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/performance/rbac_with_pattern_large_scale_model.conf\", \"examples/performance/rbac_with_pattern_large_scale_policy.csv\")\n\te.AddNamedMatchingFunc(\"g\", \"\", util.KeyMatch4)\n\te.AddNamedDomainMatchingFunc(\"g\", \"\", util.KeyMatch4)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = e.BuildRoleLinks()\n\t}\n}\n\nfunc BenchmarkHasLinkWithPatternLarge(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/performance/rbac_with_pattern_large_scale_model.conf\", \"examples/performance/rbac_with_pattern_large_scale_policy.csv\")\n\te.AddNamedMatchingFunc(\"g\", \"\", util.KeyMatch4)\n\trm := e.rmMap[\"g\"]\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = rm.HasLink(\"staffUser1001\", \"staff001\", \"/orgs/1/sites/site001\")\n\t}\n}\n\nfunc BenchmarkHasLinkWithDomainPatternLarge(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/performance/rbac_with_pattern_large_scale_model.conf\", \"examples/performance/rbac_with_pattern_large_scale_policy.csv\")\n\te.AddNamedDomainMatchingFunc(\"g\", \"\", util.KeyMatch4)\n\trm := e.rmMap[\"g\"]\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = rm.HasLink(\"staffUser1001\", \"staff001\", \"/orgs/1/sites/site001\")\n\t}\n}\n\nfunc BenchmarkHasLinkWithPatternAndDomainPatternLarge(b *testing.B) {\n\te, _ := NewEnforcer(\"examples/performance/rbac_with_pattern_large_scale_model.conf\", \"examples/performance/rbac_with_pattern_large_scale_policy.csv\")\n\te.AddNamedMatchingFunc(\"g\", \"\", util.KeyMatch4)\n\te.AddNamedDomainMatchingFunc(\"g\", \"\", util.KeyMatch4)\n\trm := e.rmMap[\"g\"]\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = rm.HasLink(\"staffUser1001\", \"staff001\", \"/orgs/1/sites/site001\")\n\t}\n}\n"
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        },
        {
          "name": "watcher_ex_test.go",
          "type": "blob",
          "size": 2.5126953125,
          "content": "// Copyright 2020 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"testing\"\n\n\t\"github.com/casbin/casbin/v2/model\"\n)\n\ntype SampleWatcherEx struct {\n\tSampleWatcher\n}\n\nfunc (w SampleWatcherEx) UpdateForAddPolicy(sec, ptype string, params ...string) error {\n\treturn nil\n}\nfunc (w SampleWatcherEx) UpdateForRemovePolicy(sec, ptype string, params ...string) error {\n\treturn nil\n}\n\nfunc (w SampleWatcherEx) UpdateForRemoveFilteredPolicy(sec, ptype string, fieldIndex int, fieldValues ...string) error {\n\treturn nil\n}\n\nfunc (w SampleWatcherEx) UpdateForSavePolicy(model model.Model) error {\n\treturn nil\n}\n\nfunc (w SampleWatcherEx) UpdateForAddPolicies(sec string, ptype string, rules ...[]string) error {\n\treturn nil\n}\n\nfunc (w SampleWatcherEx) UpdateForRemovePolicies(sec string, ptype string, rules ...[]string) error {\n\treturn nil\n}\n\nfunc TestSetWatcherEx(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\tsampleWatcherEx := &SampleWatcherEx{}\n\terr := e.SetWatcher(sampleWatcherEx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_ = e.SavePolicy()                              // calls watcherEx.UpdateForSavePolicy()\n\t_, _ = e.AddPolicy(\"admin\", \"data1\", \"read\")    // calls watcherEx.UpdateForAddPolicy()\n\t_, _ = e.RemovePolicy(\"admin\", \"data1\", \"read\") // calls watcherEx.UpdateForRemovePolicy()\n\t_, _ = e.RemoveFilteredPolicy(1, \"data1\")       // calls watcherEx.UpdateForRemoveFilteredPolicy()\n\t_, _ = e.RemovePolicy(\"admin\", \"data1\", \"read\") // calls watcherEx.UpdateForRemovePolicy()\n\t_, _ = e.AddGroupingPolicy(\"g:admin\", \"data1\")\n\t_, _ = e.RemoveGroupingPolicy(\"g:admin\", \"data1\")\n\t_, _ = e.AddGroupingPolicy(\"g:admin\", \"data1\")\n\t_, _ = e.RemoveFilteredGroupingPolicy(1, \"data1\")\n\t_, _ = e.AddPolicies([][]string{{\"admin\", \"data1\", \"read\"}, {\"admin\", \"data2\", \"read\"}})    // calls watcherEx.UpdateForAddPolicies()\n\t_, _ = e.RemovePolicies([][]string{{\"admin\", \"data1\", \"read\"}, {\"admin\", \"data2\", \"read\"}}) // calls watcherEx.UpdateForRemovePolicies()\n}\n"
        },
        {
          "name": "watcher_test.go",
          "type": "blob",
          "size": 2.0458984375,
          "content": "// Copyright 2017 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport \"testing\"\n\ntype SampleWatcher struct {\n\tcallback func(string)\n}\n\nfunc (w *SampleWatcher) Close() {\n}\n\nfunc (w *SampleWatcher) SetUpdateCallback(callback func(string)) error {\n\tw.callback = callback\n\treturn nil\n}\n\nfunc (w *SampleWatcher) Update() error {\n\tif w.callback != nil {\n\t\tw.callback(\"\")\n\t}\n\treturn nil\n}\n\nfunc TestSetWatcher(t *testing.T) {\n\te, err := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsampleWatcher := &SampleWatcher{}\n\terr = e.SetWatcher(sampleWatcher)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = e.SavePolicy() // calls watcher.Update()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestSelfModify(t *testing.T) {\n\te, err := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsampleWatcher := &SampleWatcher{}\n\terr = e.SetWatcher(sampleWatcher)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar called int\n\n\tcalled = -1\n\t_ = e.watcher.SetUpdateCallback(func(s string) {\n\t\tcalled = 1\n\t})\n\t_, err = e.AddPolicy(\"eva\", \"data\", \"read\") // calls watcher.Update()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif called != 1 {\n\t\tt.Fatal(\"callback should be called\")\n\t}\n\n\tcalled = -1\n\t_ = e.watcher.SetUpdateCallback(func(s string) {\n\t\tcalled = 1\n\t})\n\t_, err = e.SelfAddPolicy(\"p\", \"p\", []string{\"eva\", \"data\", \"write\"}) // calls watcher.Update()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif called != -1 {\n\t\tt.Fatal(\"callback should not be called\")\n\t}\n}\n"
        },
        {
          "name": "watcher_update_test.go",
          "type": "blob",
          "size": 1.2958984375,
          "content": "// Copyright 2020 The casbin Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage casbin\n\nimport (\n\t\"testing\"\n)\n\ntype SampleWatcherUpdatable struct {\n\tSampleWatcher\n}\n\nfunc (w SampleWatcherUpdatable) UpdateForUpdatePolicy(params ...string) error {\n\treturn nil\n}\n\nfunc TestSetWatcherUpdatable(t *testing.T) {\n\te, _ := NewEnforcer(\"examples/rbac_model.conf\", \"examples/rbac_policy.csv\")\n\n\tsampleWatcherEx := &SampleWatcherUpdatable{}\n\terr := e.SetWatcher(sampleWatcherEx)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_ = e.SavePolicy()                                                                            // calls watcherEx.UpdateForSavePolicy()\n\t_, _ = e.UpdatePolicy([]string{\"admin\", \"data1\", \"read\"}, []string{\"admin\", \"data2\", \"read\"}) // calls watcherEx.UpdateForUpdatePolicy()\n}\n"
        }
      ]
    }
  ]
}