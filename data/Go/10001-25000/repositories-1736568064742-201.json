{
  "metadata": {
    "timestamp": 1736568064742,
    "page": 201,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hajimehoshi/ebiten",
      "stars": 11321,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".builds",
          "type": "tree",
          "content": null
        },
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.0283203125,
          "content": "CommentPragmas: '^go:build'\r\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1103515625,
          "content": ".DS_Store\n*~\n*.aar\n*.apk\n*.tar.gz\n.idea\n.vscode\ngo.work\ngo.work.sum\n\n*.fxc\n!dummy.fxc\n*.metallib\n!dummy.metallib\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 0.08984375,
          "content": "# Code of Conduct\n\nWe adhere to the [Go Community Code of Conduct](https://go.dev/conduct).\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.0791015625,
          "content": "# Contributing to Ebitengine\n\nEbitengine is an open source project and we appreciate your contributions!\n\nThere are some rules for Ebitengine contribution.\n\n## Filing an issue in the GitHub issue\n\nFile an issue in the GitHub issues, if you find a problem or have a feature request but this is not filed.\n\nExcept for very trivial fixes like fixing misspelling, it is a must to have an issue.\n\n## Asking us when you are not sure\n\nIn Ebitengine, problems might not be documented very well in GitHub issues. Please ask us before you work on such issue.\n\nYou can ask us at these communities:\n\n * [Ebitengine Discord Server](https://discord.gg/3tVdM5H8cC)\n * `#ebitengine` channel in [Gophers Slack](https://invite.slack.golangbridge.org/)\n * [GitHub Discussion](https://github.com/hajimehoshi/ebiten/discussions)\n\n## Following the Go convention\n\nPlease follow the Go convention like [Effective Go](https://golang.org/doc/effective_go.html).\nFor example, formatting by `go fmt` is required.\n\n## Adding copyright comments to each file\n\n```go\n// Copyright [YYYY] The Ebitengine Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n```\n\nYou don't have to update existing files' license comments.\n\n## Implementation details\n\nSee the [documents](https://ebitengine.org/en/documents/implementation.html) about internal implementation.\n\n## Fixing the documentation\n\nEbitengine's documentations are managed at [ebitengine/ebitengine.org](https://github.com/ebitengine/ebitengine.org).\n\nBefore submitting a documentation PR, read through the [README](https://github.com/ebitengine/ebitengine.org/blob/main/README.md) in that repo.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.4306640625,
          "content": "# Ebitengine (v2)\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/hajimehoshi/ebiten/v2.svg)](https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2)\n[![Build Status](https://github.com/hajimehoshi/ebiten/actions/workflows/test.yml/badge.svg)](https://github.com/hajimehoshi/ebiten/actions?query=workflow%3Atest)\n\n**A dead simple 2D game engine for Go**\n\nEbitengine (formerly known as Ebiten) is an open source game engine for the Go programming language. Ebitengine's simple API allows you to quickly and easily develop 2D games that can be deployed across multiple platforms.\n\n* [Website (ebitengine.org)](https://ebitengine.org)\n* [API Reference](https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2)\n* [Cheat Sheet](https://ebitengine.org/en/documents/cheatsheet.html)\n* [Awesome Ebitengine](https://github.com/sedyh/awesome-ebitengine)\n\n![Overview](https://ebitengine.org/images/overview2.png)\n\n## Platforms\n\n* [Windows](https://ebitengine.org/en/documents/install.html?os=windows) (No Cgo required!)\n* [macOS](https://ebitengine.org/en/documents/install.html?os=darwin)\n* [Linux](https://ebitengine.org/en/documents/install.html?os=linux)\n* [FreeBSD](https://ebitengine.org/en/documents/install.html?os=freebsd)\n* [Android](https://ebitengine.org/en/documents/mobile.html)\n* [iOS](https://ebitengine.org/en/documents/mobile.html)\n* [WebAssembly](https://ebitengine.org/en/documents/webassembly.html)\n* Nintendo Switch\n* Xbox (Xbox support is limited and not available to everyone. Negotiations are currently underway to make it accessible to all.)\n\nFor installation on desktops, see [the installation instruction](https://ebitengine.org/en/documents/install.html).\n\n## Features\n\n* 2D Graphics (Geometry and color transformation by matrices, Various composition modes, Offscreen rendering, Text rendering, Automatic batches, Automatic texture atlas, Custom shaders)\n* Input (Mouse, Keyboard, Gamepads, Touches)\n* Audio (Ogg/Vorbis, MP3, WAV, PCM)\n\n## Packages\n\n* [ebiten](https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2)\n  * [audio](https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2/audio)\n    * [mp3](https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2/audio/mp3)\n    * [vorbis](https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2/audio/vorbis)\n    * [wav](https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2/audio/wav)\n  * [colorm](https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2/colorm)\n  * [ebitenutil](https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2/ebitenutil)\n  * [inpututil](https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2/inpututil)\n  * [mobile](https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2/mobile)\n  * [text/v2](https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2/text/v2)\n  * [vector](https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2/vector)\n  * [exp/textinput](https://pkg.go.dev/github.com/hajimehoshi/ebiten/v2/exp/textinput)\n\n## Community\n\n- [Discord](https://discord.gg/3tVdM5H8cC)\n- `#ebitengine` channel in [Gophers Slack](https://blog.gopheracademy.com/gophers-slack-community/)\n- [GitHub Discussion](https://github.com/hajimehoshi/ebiten/discussions)\n- [`r/ebitengine` in Reddit](https://www.reddit.com/r/ebitengine/)\n\n## License\n\nEbitengine is licensed under Apache license version 2.0. See [LICENSE](LICENSE) file.\n\n[The Ebitengine logo](https://ebitengine.org/images/logo.png) by Hajime Hoshi is licensed under [the Creative Commons Attribution-NoDerivatives 4.0](https://creativecommons.org/licenses/by-nd/4.0/).\n\n### GLFW\n\nhttps://github.com/glfw/glfw\n\n\n```\nCopyright (c) 2002-2006 Marcus Geelnard\n\nCopyright (c) 2006-2019 Camilla Löwy\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must not\n   claim that you wrote the original software. If you use this software\n   in a product, an acknowledgment in the product documentation would\n   be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and must not\n   be misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source\n   distribution.\n```\n\n### Go\n\nhttps://cs.opensource.google/go/go\n\n\n```\nCopyright (c) 2009 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n```\n\n### go-gl/gl\n\nhttps://github.com/go-gl/gl\n\n\n```\nThe MIT License (MIT)\n\nCopyright (c) 2014 Eric Woroshow\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```\n\n### go-gl/glfw\n\nhttps://github.com/go-gl/glfw\n\n\n```\nCopyright (c) 2012 The glfw3-go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n```\n"
        },
        {
          "name": "audio",
          "type": "tree",
          "content": null
        },
        {
          "name": "blend.go",
          "type": "blob",
          "size": 13.3369140625,
          "content": "// Copyright 2022 The Ebitengine Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/hajimehoshi/ebiten/v2/internal/graphicsdriver\"\n)\n\n// Blend is a blending way of the source color and the destination color.\n//\n// The final color is calculated like this:\n//\n//\tc_src: source RGB values\n//\tc_dst: destination RGB values\n//\tc_out: result RGB values\n//\tα_src: source alpha values\n//\tα_dst: destination alpha values\n//\tα_out: result alpha values\n//\n//\tc_out = BlendOperationRGB((BlendFactorSourceRGB) × c_src, (BlendFactorDestinationRGB) × c_dst)\n//\tα_out = BlendOperationAlpha((BlendFactorSourceAlpha) × α_src, (BlendFactorDestinationAlpha) × α_dst)\n//\n// A blend factor is a factor for source and color destination color values.\n// The default is source-over (regular alpha blending).\n//\n// A blend operation is a binary operator of a source color and a destination color.\n// The default is adding.\ntype Blend struct {\n\t// BlendFactorSourceRGB is a factor for source RGB values.\n\tBlendFactorSourceRGB BlendFactor\n\n\t// BlendFactorSourceAlpha is a factor for source alpha values.\n\tBlendFactorSourceAlpha BlendFactor\n\n\t// BlendFactorDestinationRGB is a factor for destination RGB values.\n\tBlendFactorDestinationRGB BlendFactor\n\n\t// BlendFactorDestinationAlpha is a factor for destination alpha values.\n\tBlendFactorDestinationAlpha BlendFactor\n\n\t// BlendOperationRGB is an operation for source and destination RGB values.\n\tBlendOperationRGB BlendOperation\n\n\t// BlendOperationAlpha is an operation for source and destination alpha values.\n\tBlendOperationAlpha BlendOperation\n}\n\nvar (\n\tdefaultBlendInternalBlend = graphicsdriver.Blend{\n\t\tBlendFactorSourceRGB:        BlendFactorDefault.internalBlendFactor(true),\n\t\tBlendFactorSourceAlpha:      BlendFactorDefault.internalBlendFactor(true),\n\t\tBlendFactorDestinationRGB:   BlendFactorDefault.internalBlendFactor(false),\n\t\tBlendFactorDestinationAlpha: BlendFactorDefault.internalBlendFactor(false),\n\t\tBlendOperationRGB:           BlendOperationAdd.internalBlendOperation(),\n\t\tBlendOperationAlpha:         BlendOperationAdd.internalBlendOperation(),\n\t}\n)\n\nfunc (b Blend) internalBlend() graphicsdriver.Blend {\n\t// A shortcut for the most common blend.\n\tif b == (Blend{}) {\n\t\treturn defaultBlendInternalBlend\n\t}\n\treturn graphicsdriver.Blend{\n\t\tBlendFactorSourceRGB:        b.BlendFactorSourceRGB.internalBlendFactor(true),\n\t\tBlendFactorSourceAlpha:      b.BlendFactorSourceAlpha.internalBlendFactor(true),\n\t\tBlendFactorDestinationRGB:   b.BlendFactorDestinationRGB.internalBlendFactor(false),\n\t\tBlendFactorDestinationAlpha: b.BlendFactorDestinationAlpha.internalBlendFactor(false),\n\t\tBlendOperationRGB:           b.BlendOperationRGB.internalBlendOperation(),\n\t\tBlendOperationAlpha:         b.BlendOperationAlpha.internalBlendOperation(),\n\t}\n}\n\n// BlendFactor is a factor for source and destination color values.\ntype BlendFactor byte\n\nconst (\n\t// BlendFactorDefault is the default factor value.\n\t// The actual value depends on which source or destination this value is used.\n\tBlendFactorDefault BlendFactor = iota\n\n\t// BlendFactorZero is a factor:\n\t//\n\t//     0\n\tBlendFactorZero\n\n\t// BlendFactorOne is a factor:\n\t//\n\t//     1\n\tBlendFactorOne\n\n\t// BlendFactorSourceColor is a factor:\n\t//\n\t//     (source RGBA)\n\tBlendFactorSourceColor\n\n\t// BlendFactorOneMinusSourceColor is a factor:\n\t//\n\t//     1 - (source color)\n\tBlendFactorOneMinusSourceColor\n\n\t// BlendFactorSourceAlpha is a factor:\n\t//\n\t//     (source alpha)\n\tBlendFactorSourceAlpha\n\n\t// BlendFactorOneMinusSourceAlpha is a factor:\n\t//\n\t//     1 - (source alpha)\n\tBlendFactorOneMinusSourceAlpha\n\n\t// BlendFactorDestinationColor is a factor:\n\t//\n\t//     (destination RGBA)\n\tBlendFactorDestinationColor\n\n\t// BlendFactorOneMinusDestinationColor is a factor:\n\t//\n\t//     1 - (destination RGBA)\n\tBlendFactorOneMinusDestinationColor\n\n\t// BlendFactorDestinationAlpha is a factor:\n\t//\n\t//     (destination alpha)\n\tBlendFactorDestinationAlpha\n\n\t// BlendFactorOneMinusDestinationAlpha is a factor:\n\t//\n\t//     1 - (destination alpha)\n\tBlendFactorOneMinusDestinationAlpha\n\n\t// TODO: Add BlendFactorSourceAlphaSaturated. This might not work well on some platforms like Steam SDK (#2382).\n)\n\nfunc (b BlendFactor) internalBlendFactor(source bool) graphicsdriver.BlendFactor {\n\tswitch b {\n\tcase BlendFactorDefault:\n\t\t// The default is the source-over composition (regular alpha blending).\n\t\tif source {\n\t\t\treturn graphicsdriver.BlendFactorOne\n\t\t}\n\t\treturn graphicsdriver.BlendFactorOneMinusSourceAlpha\n\tcase BlendFactorZero:\n\t\treturn graphicsdriver.BlendFactorZero\n\tcase BlendFactorOne:\n\t\treturn graphicsdriver.BlendFactorOne\n\tcase BlendFactorSourceColor:\n\t\treturn graphicsdriver.BlendFactorSourceColor\n\tcase BlendFactorOneMinusSourceColor:\n\t\treturn graphicsdriver.BlendFactorOneMinusSourceColor\n\tcase BlendFactorSourceAlpha:\n\t\treturn graphicsdriver.BlendFactorSourceAlpha\n\tcase BlendFactorOneMinusSourceAlpha:\n\t\treturn graphicsdriver.BlendFactorOneMinusSourceAlpha\n\tcase BlendFactorDestinationColor:\n\t\treturn graphicsdriver.BlendFactorDestinationColor\n\tcase BlendFactorOneMinusDestinationColor:\n\t\treturn graphicsdriver.BlendFactorOneMinusDestinationColor\n\tcase BlendFactorDestinationAlpha:\n\t\treturn graphicsdriver.BlendFactorDestinationAlpha\n\tcase BlendFactorOneMinusDestinationAlpha:\n\t\treturn graphicsdriver.BlendFactorOneMinusDestinationAlpha\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"ebiten: invalid blend factor: %d\", b))\n\t}\n}\n\nfunc internalBlendFactorToBlendFactor(blendFactor graphicsdriver.BlendFactor) BlendFactor {\n\tswitch blendFactor {\n\tcase graphicsdriver.BlendFactorZero:\n\t\treturn BlendFactorZero\n\tcase graphicsdriver.BlendFactorOne:\n\t\treturn BlendFactorOne\n\tcase graphicsdriver.BlendFactorSourceColor:\n\t\treturn BlendFactorSourceColor\n\tcase graphicsdriver.BlendFactorOneMinusSourceColor:\n\t\treturn BlendFactorOneMinusSourceColor\n\tcase graphicsdriver.BlendFactorSourceAlpha:\n\t\treturn BlendFactorSourceAlpha\n\tcase graphicsdriver.BlendFactorOneMinusSourceAlpha:\n\t\treturn BlendFactorOneMinusSourceAlpha\n\tcase graphicsdriver.BlendFactorDestinationColor:\n\t\treturn BlendFactorDestinationColor\n\tcase graphicsdriver.BlendFactorOneMinusDestinationColor:\n\t\treturn BlendFactorOneMinusDestinationColor\n\tcase graphicsdriver.BlendFactorDestinationAlpha:\n\t\treturn BlendFactorDestinationAlpha\n\tcase graphicsdriver.BlendFactorOneMinusDestinationAlpha:\n\t\treturn BlendFactorOneMinusDestinationAlpha\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"ebiten: invalid blend factor: %d\", blendFactor))\n\t}\n}\n\n// BlendOperation is an operation for source and destination color values.\ntype BlendOperation byte\n\nconst (\n\t// BlendOperationAdd represents adding the source and destination color.\n\t//\n\t//     c_out = (BlendFactorSourceRGB) × c_src + (BlendFactorDestinationRGB) × c_dst\n\t//     α_out = (BlendFactorSourceAlpha) × α_src + (BlendFactorDestinationAlpha) × α_dst\n\tBlendOperationAdd BlendOperation = iota\n\n\t// BlendOperationSubtract represents subtracting the source and destination color.\n\t//\n\t//     c_out = (BlendFactorSourceRGB) × c_src - (BlendFactorDestinationRGB) × c_dst\n\t//     α_out = (BlendFactorSourceAlpha) × α_src - (BlendFactorDestinationAlpha) × α_dst\n\tBlendOperationSubtract\n\n\t// BlendOperationReverseSubtract represents subtracting the source and destination color in a reversed order.\n\t//\n\t//     c_out = (BlendFactorDestinationRGB) × c_dst - (BlendFactorSourceRGB) × c_src\n\t//     α_out = (BlendFactorDestinationAlpha) × α_dst - (BlendFactorSourceAlpha) × α_src\n\tBlendOperationReverseSubtract\n\n\t// BlendOperationMin represents a minimum function for the source and destination color.\n\t// If BlendOperationMin is specified, blend factors are not used.\n\t//\n\t//     c_out = min(c_dst, c_src)\n\t//     α_out = min(α_dst, α_src)\n\tBlendOperationMin\n\n\t// BlendOperationMax represents a maximum function for the source and destination color.\n\t// If BlendOperationMax is specified, blend factors are not used.\n\t//\n\t//     c_out = max(c_dst, c_src)\n\t//     α_out = max(α_dst, α_src)\n\tBlendOperationMax\n)\n\nfunc (b BlendOperation) internalBlendOperation() graphicsdriver.BlendOperation {\n\tswitch b {\n\tcase BlendOperationAdd:\n\t\treturn graphicsdriver.BlendOperationAdd\n\tcase BlendOperationSubtract:\n\t\treturn graphicsdriver.BlendOperationSubtract\n\tcase BlendOperationReverseSubtract:\n\t\treturn graphicsdriver.BlendOperationReverseSubtract\n\tcase BlendOperationMin:\n\t\treturn graphicsdriver.BlendOperationMin\n\tcase BlendOperationMax:\n\t\treturn graphicsdriver.BlendOperationMax\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"ebiten: invalid blend operation: %d\", b))\n\t}\n}\n\nfunc internalBlendOperationToBlendOperation(blendOperation graphicsdriver.BlendOperation) BlendOperation {\n\tswitch blendOperation {\n\tcase graphicsdriver.BlendOperationAdd:\n\t\treturn BlendOperationAdd\n\tcase graphicsdriver.BlendOperationSubtract:\n\t\treturn BlendOperationSubtract\n\tcase graphicsdriver.BlendOperationReverseSubtract:\n\t\treturn BlendOperationReverseSubtract\n\tcase graphicsdriver.BlendOperationMin:\n\t\treturn BlendOperationMin\n\tcase graphicsdriver.BlendOperationMax:\n\t\treturn BlendOperationMax\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"ebiten: invalid blend operation: %d\", blendOperation))\n\t}\n}\n\nfunc internalBlendToBlend(blend graphicsdriver.Blend) Blend {\n\treturn Blend{\n\t\tBlendFactorSourceRGB:        internalBlendFactorToBlendFactor(blend.BlendFactorSourceRGB),\n\t\tBlendFactorSourceAlpha:      internalBlendFactorToBlendFactor(blend.BlendFactorSourceAlpha),\n\t\tBlendFactorDestinationRGB:   internalBlendFactorToBlendFactor(blend.BlendFactorDestinationRGB),\n\t\tBlendFactorDestinationAlpha: internalBlendFactorToBlendFactor(blend.BlendFactorDestinationAlpha),\n\t\tBlendOperationRGB:           internalBlendOperationToBlendOperation(blend.BlendOperationRGB),\n\t\tBlendOperationAlpha:         internalBlendOperationToBlendOperation(blend.BlendOperationAlpha),\n\t}\n}\n\n// This name convention follows CSS compositing: https://drafts.fxtf.org/compositing-2/.\n//\n// In the comments,\n// c_src, c_dst and c_out represent alpha-premultiplied RGB values of source, destination and output respectively. α_src and α_dst represent alpha values of source and destination respectively.\nvar (\n\t// BlendSourceOver is a preset Blend for the regular alpha blending.\n\t//\n\t//     c_out = c_src + c_dst × (1 - α_src)\n\t//     α_out = α_src + α_dst × (1 - α_src)\n\tBlendSourceOver = internalBlendToBlend(graphicsdriver.BlendSourceOver)\n\n\t// BlendClear is a preset Blend for Porter Duff's 'clear'.\n\t//\n\t//     c_out = 0\n\t//     α_out = 0\n\tBlendClear = internalBlendToBlend(graphicsdriver.BlendClear)\n\n\t// BlendCopy is a preset Blend for Porter Duff's 'copy'.\n\t//\n\t//     c_out = c_src\n\t//     α_out = α_src\n\tBlendCopy = internalBlendToBlend(graphicsdriver.BlendCopy)\n\n\t// BlendDestination is a preset Blend for Porter Duff's 'destination'.\n\t//\n\t//     c_out = c_dst\n\t//     α_out = α_dst\n\tBlendDestination = internalBlendToBlend(graphicsdriver.BlendDestination)\n\n\t// BlendDestinationOver is a preset Blend for Porter Duff's 'destination-over'.\n\t//\n\t//     c_out = c_src × (1 - α_dst) + c_dst\n\t//     α_out = α_src × (1 - α_dst) + α_dst\n\tBlendDestinationOver = internalBlendToBlend(graphicsdriver.BlendDestinationOver)\n\n\t// BlendSourceIn is a preset Blend for Porter Duff's 'source-in'.\n\t//\n\t//     c_out = c_src × α_dst\n\t//     α_out = α_src × α_dst\n\tBlendSourceIn = internalBlendToBlend(graphicsdriver.BlendSourceIn)\n\n\t// BlendDestinationIn is a preset Blend for Porter Duff's 'destination-in'.\n\t//\n\t//     c_out = c_dst × α_src\n\t//     α_out = α_dst × α_src\n\tBlendDestinationIn = internalBlendToBlend(graphicsdriver.BlendDestinationIn)\n\n\t// BlendSourceOut is a preset Blend for Porter Duff's 'source-out'.\n\t//\n\t//     c_out = c_src × (1 - α_dst)\n\t//     α_out = α_src × (1 - α_dst)\n\tBlendSourceOut = internalBlendToBlend(graphicsdriver.BlendSourceOut)\n\n\t// BlendDestinationOut is a preset Blend for Porter Duff's 'destination-out'.\n\t//\n\t//     c_out = c_dst × (1 - α_src)\n\t//     α_out = α_dst × (1 - α_src)\n\tBlendDestinationOut = internalBlendToBlend(graphicsdriver.BlendDestinationOut)\n\n\t// BlendSourceAtop is a preset Blend for Porter Duff's 'source-atop'.\n\t//\n\t//     c_out = c_src × α_dst + c_dst × (1 - α_src)\n\t//     α_out = α_src × α_dst + α_dst × (1 - α_src)\n\tBlendSourceAtop = internalBlendToBlend(graphicsdriver.BlendSourceAtop)\n\n\t// BlendDestinationAtop is a preset Blend for Porter Duff's 'destination-atop'.\n\t//\n\t//     c_out = c_src × (1 - α_dst) + c_dst × α_src\n\t//     α_out = α_src × (1 - α_dst) + α_dst × α_src\n\tBlendDestinationAtop = internalBlendToBlend(graphicsdriver.BlendDestinationAtop)\n\n\t// BlendXor is a preset Blend for Porter Duff's 'xor'.\n\t//\n\t//     c_out = c_src × (1 - α_dst) + c_dst × (1 - α_src)\n\t//     α_out = α_src × (1 - α_dst) + α_dst × (1 - α_src)\n\tBlendXor = internalBlendToBlend(graphicsdriver.BlendXor)\n\n\t// BlendLighter is a preset Blend for Porter Duff's 'lighter'.\n\t// This is sum of source and destination (a.k.a. 'plus' or 'additive')\n\t//\n\t//     c_out = c_src + c_dst\n\t//     α_out = α_src + α_dst\n\tBlendLighter = internalBlendToBlend(graphicsdriver.BlendLighter)\n)\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "colorm.go",
          "type": "blob",
          "size": 4.841796875,
          "content": "// Copyright 2014 Hajime Hoshi\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"image/color\"\n\n\t\"github.com/hajimehoshi/ebiten/v2/internal/affine\"\n)\n\n// ColorMDim is the dimension of a ColorM.\n//\n// Deprecated: as of v2.5. Use the colorm package instead.\nconst ColorMDim = affine.ColorMDim\n\n// A ColorM represents a matrix to transform coloring when rendering an image.\n//\n// A ColorM is applied to the straight alpha color\n// while an Image's pixels' format is alpha premultiplied.\n// Before applying a matrix, a color is un-multiplied, and after applying the matrix,\n// the color is multiplied again.\n//\n// The initial value is identity.\n//\n// Deprecated: as of v2.5. Use the colorm package instead.\ntype ColorM struct {\n\timpl affine.ColorM\n\n\t_ [0]func() // Marks as non-comparable.\n}\n\nfunc (c *ColorM) affineColorM() affine.ColorM {\n\tif c.impl != nil {\n\t\treturn c.impl\n\t}\n\treturn affine.ColorMIdentity{}\n}\n\n// String returns a string representation of ColorM.\n//\n// Deprecated: as of v2.5. Use the colorm package instead.\nfunc (c *ColorM) String() string {\n\treturn c.affineColorM().String()\n}\n\n// Reset resets the ColorM as identity.\n//\n// Deprecated: as of v2.5. Use the colorm package instead.\nfunc (c *ColorM) Reset() {\n\tc.impl = affine.ColorMIdentity{}\n}\n\n// Apply pre-multiplies a vector (r, g, b, a, 1) by the matrix\n// where r, g, b, and a are clr's values in straight-alpha format.\n// In other words, Apply calculates ColorM * (r, g, b, a, 1)^T.\n//\n// Deprecated: as of v2.5. Use the colorm package instead.\nfunc (c *ColorM) Apply(clr color.Color) color.Color {\n\treturn c.affineColorM().Apply(clr)\n}\n\n// Concat multiplies a color matrix with the other color matrix.\n// This is same as multiplying the matrix other and the matrix c in this order.\n//\n// Deprecated: as of v2.5. Use the colorm package instead.\nfunc (c *ColorM) Concat(other ColorM) {\n\to := other.impl\n\tif o == nil {\n\t\treturn\n\t}\n\tc.impl = c.affineColorM().Concat(o)\n}\n\n// Scale scales the matrix by (r, g, b, a).\n//\n// Deprecated: as of v2.5. Use ColorScale or the colorm package instead.\nfunc (c *ColorM) Scale(r, g, b, a float64) {\n\tc.impl = c.affineColorM().Scale(float32(r), float32(g), float32(b), float32(a))\n}\n\n// ScaleWithColor scales the matrix by clr.\n//\n// Deprecated: as of v2.5. Use ColorScale or the colorm package instead.\nfunc (c *ColorM) ScaleWithColor(clr color.Color) {\n\tcr, cg, cb, ca := clr.RGBA()\n\tif ca == 0 {\n\t\tc.Scale(0, 0, 0, 0)\n\t\treturn\n\t}\n\tc.Scale(float64(cr)/float64(ca), float64(cg)/float64(ca), float64(cb)/float64(ca), float64(ca)/0xffff)\n}\n\n// Translate translates the matrix by (r, g, b, a).\n//\n// Deprecated: as of v2.5. Use the colorm package instead.\nfunc (c *ColorM) Translate(r, g, b, a float64) {\n\tc.impl = c.affineColorM().Translate(float32(r), float32(g), float32(b), float32(a))\n}\n\n// RotateHue rotates the hue.\n// theta represents rotating angle in radian.\n//\n// Deprecated: as of v2.5. Use the colorm package instead.\nfunc (c *ColorM) RotateHue(theta float64) {\n\tc.ChangeHSV(theta, 1, 1)\n}\n\n// ChangeHSV changes HSV (Hue-Saturation-Value) values.\n// hueTheta is a radian value to rotate hue.\n// saturationScale is a value to scale saturation.\n// valueScale is a value to scale value (a.k.a. brightness).\n//\n// This conversion uses RGB to/from YCrCb conversion.\n//\n// Deprecated: as of v2.5. Use the colorm package instead.\nfunc (c *ColorM) ChangeHSV(hueTheta float64, saturationScale float64, valueScale float64) {\n\tc.impl = affine.ChangeHSV(c.affineColorM(), hueTheta, float32(saturationScale), float32(valueScale))\n}\n\n// Element returns a value of a matrix at (i, j).\n//\n// Deprecated: as of v2.5. Use the colorm package instead.\nfunc (c *ColorM) Element(i, j int) float64 {\n\treturn float64(c.affineColorM().At(i, j))\n}\n\n// SetElement sets an element at (i, j).\n//\n// Deprecated: as of v2.5. Use the colorm package instead.\nfunc (c *ColorM) SetElement(i, j int, element float64) {\n\tc.impl = affine.ColorMSetElement(c.affineColorM(), i, j, float32(element))\n}\n\n// IsInvertible returns a boolean value indicating\n// whether the matrix c is invertible or not.\n//\n// Deprecated: as of v2.5. Use the colorm package instead.\nfunc (c *ColorM) IsInvertible() bool {\n\treturn c.affineColorM().IsInvertible()\n}\n\n// Invert inverts the matrix.\n// If c is not invertible, Invert panics.\n//\n// Deprecated: as of v2.5. Use the colorm package instead.\nfunc (c *ColorM) Invert() {\n\tc.impl = c.affineColorM().Invert()\n}\n"
        },
        {
          "name": "colorm",
          "type": "tree",
          "content": null
        },
        {
          "name": "colorscale.go",
          "type": "blob",
          "size": 3.57421875,
          "content": "// Copyright 2022 The Ebitengine Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"fmt\"\n\t\"image/color\"\n)\n\n// ColorScale represents a scale of RGBA color.\n// ColorScale is intended to be applied to a premultiplied-alpha color value.\n//\n// The initial (zero) value of ColorScale is an identity scale (1, 1, 1, 1).\ntype ColorScale struct {\n\t// These values are adjusted by -1 from the actual values.\n\t// It's because the initial value should be 1 instead of 0.\n\tr_1, g_1, b_1, a_1 float32\n}\n\n// String returns a string representing the color scale.\nfunc (c *ColorScale) String() string {\n\treturn fmt.Sprintf(\"(%f,%f,%f,%f)\", c.r_1+1, c.g_1+1, c.b_1+1, c.a_1+1)\n}\n\n// Reset resets the ColorScale as identity.\nfunc (c *ColorScale) Reset() {\n\tc.r_1 = 0\n\tc.g_1 = 0\n\tc.b_1 = 0\n\tc.a_1 = 0\n}\n\n// R returns the red scale.\nfunc (c *ColorScale) R() float32 {\n\treturn c.r_1 + 1\n}\n\n// G returns the green scale.\nfunc (c *ColorScale) G() float32 {\n\treturn c.g_1 + 1\n}\n\n// B returns the blue scale.\nfunc (c *ColorScale) B() float32 {\n\treturn c.b_1 + 1\n}\n\n// A returns the alpha scale.\nfunc (c *ColorScale) A() float32 {\n\treturn c.a_1 + 1\n}\n\nfunc (c *ColorScale) elements() (float32, float32, float32, float32) {\n\treturn c.r_1 + 1, c.g_1 + 1, c.b_1 + 1, c.a_1 + 1\n}\n\n// SetR overwrites the current red value with r.\nfunc (c *ColorScale) SetR(r float32) {\n\tc.r_1 = r - 1\n}\n\n// SetG overwrites the current green value with g.\nfunc (c *ColorScale) SetG(g float32) {\n\tc.g_1 = g - 1\n}\n\n// SetB overwrites the current blue value with b.\nfunc (c *ColorScale) SetB(b float32) {\n\tc.b_1 = b - 1\n}\n\n// SetA overwrites the current alpha value with a.\nfunc (c *ColorScale) SetA(a float32) {\n\tc.a_1 = a - 1\n}\n\n// Scale multiplies the given values to the current scale.\n//\n// Scale is slightly different from colorm.ColorM's Scale in terms of alphas.\n// ColorScale is applied to premultiplied-alpha colors, while colorm.ColorM is applied to straight-alpha colors.\n// Thus, ColorM.Scale(r, g, b, a) equals to ColorScale.Scale(r*a, g*a, b*a, a).\nfunc (c *ColorScale) Scale(r, g, b, a float32) {\n\tc.r_1 = (c.r_1+1)*r - 1\n\tc.g_1 = (c.g_1+1)*g - 1\n\tc.b_1 = (c.b_1+1)*b - 1\n\tc.a_1 = (c.a_1+1)*a - 1\n}\n\n// ScaleAlpha multiplies the given alpha value to the current scale.\nfunc (c *ColorScale) ScaleAlpha(a float32) {\n\tc.r_1 = (c.r_1+1)*a - 1\n\tc.g_1 = (c.g_1+1)*a - 1\n\tc.b_1 = (c.b_1+1)*a - 1\n\tc.a_1 = (c.a_1+1)*a - 1\n}\n\n// ScaleWithColor multiplies the given color values to the current scale.\nfunc (c *ColorScale) ScaleWithColor(clr color.Color) {\n\tcr, cg, cb, ca := clr.RGBA()\n\tc.Scale(float32(cr)/0xffff, float32(cg)/0xffff, float32(cb)/0xffff, float32(ca)/0xffff)\n}\n\n// ScaleWithColorScale multiplies the given color scale values to the current scale.\nfunc (c *ColorScale) ScaleWithColorScale(colorScale ColorScale) {\n\tc.r_1 = (c.r_1+1)*(colorScale.r_1+1) - 1\n\tc.g_1 = (c.g_1+1)*(colorScale.g_1+1) - 1\n\tc.b_1 = (c.b_1+1)*(colorScale.b_1+1) - 1\n\tc.a_1 = (c.a_1+1)*(colorScale.a_1+1) - 1\n}\n\nfunc (c *ColorScale) apply(r, g, b, a float32) (float32, float32, float32, float32) {\n\treturn (c.r_1 + 1) * r, (c.g_1 + 1) * g, (c.b_1 + 1) * b, (c.a_1 + 1) * a\n}\n"
        },
        {
          "name": "compositemode.go",
          "type": "blob",
          "size": 3.1982421875,
          "content": "// Copyright 2023 The Ebitengine Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"fmt\"\n)\n\n// CompositeMode represents Porter-Duff composition mode.\n//\n// Deprecated: as of v2.5. Use Blend instead.\ntype CompositeMode int\n\nconst (\n\t// CompositeModeCustom indicates to refer Blend.\n\tCompositeModeCustom CompositeMode = iota\n\n\t// Deprecated: as of v2.5. Use BlendSourceOver instead.\n\tCompositeModeSourceOver\n\n\t// Deprecated: as of v2.5. Use BlendClear instead.\n\tCompositeModeClear\n\n\t// Deprecated: as of v2.5. Use BlendCopy instead.\n\tCompositeModeCopy\n\n\t// Deprecated: as of v2.5. Use BlendDestination instead.\n\tCompositeModeDestination\n\n\t// Deprecated: as of v2.5. Use BlendDestinationOver instead.\n\tCompositeModeDestinationOver\n\n\t// Deprecated: as of v2.5. Use BlendSourceIn instead.\n\tCompositeModeSourceIn\n\n\t// Deprecated: as of v2.5. Use BlendDestinationIn instead.\n\tCompositeModeDestinationIn\n\n\t// Deprecated: as of v2.5. Use BlendSourceOut instead.\n\tCompositeModeSourceOut\n\n\t// Deprecated: as of v2.5. Use BlendDestinationOut instead.\n\tCompositeModeDestinationOut\n\n\t// Deprecated: as of v2.5. Use BlendSourceAtop instead.\n\tCompositeModeSourceAtop\n\n\t// Deprecated: as of v2.5. Use BlendDestinationAtop instead.\n\tCompositeModeDestinationAtop\n\n\t// Deprecated: as of v2.5. Use BlendXor instead.\n\tCompositeModeXor\n\n\t// Deprecated: as of v2.5. Use BlendLighter instead.\n\tCompositeModeLighter\n\n\t// Deprecated: as of v2.5. Use Blend with BlendFactorDestinationColor and BlendFactorZero instead.\n\tCompositeModeMultiply\n)\n\nfunc (c CompositeMode) blend() Blend {\n\tswitch c {\n\tcase CompositeModeSourceOver:\n\t\treturn BlendSourceOver\n\tcase CompositeModeClear:\n\t\treturn BlendClear\n\tcase CompositeModeCopy:\n\t\treturn BlendCopy\n\tcase CompositeModeDestination:\n\t\treturn BlendDestination\n\tcase CompositeModeDestinationOver:\n\t\treturn BlendDestinationOver\n\tcase CompositeModeSourceIn:\n\t\treturn BlendSourceIn\n\tcase CompositeModeDestinationIn:\n\t\treturn BlendDestinationIn\n\tcase CompositeModeSourceOut:\n\t\treturn BlendSourceOut\n\tcase CompositeModeDestinationOut:\n\t\treturn BlendDestinationOut\n\tcase CompositeModeSourceAtop:\n\t\treturn BlendSourceAtop\n\tcase CompositeModeDestinationAtop:\n\t\treturn BlendDestinationAtop\n\tcase CompositeModeXor:\n\t\treturn BlendXor\n\tcase CompositeModeLighter:\n\t\treturn BlendLighter\n\tcase CompositeModeMultiply:\n\t\treturn Blend{\n\t\t\tBlendFactorSourceRGB:        BlendFactorDestinationColor,\n\t\t\tBlendFactorSourceAlpha:      BlendFactorDestinationColor,\n\t\t\tBlendFactorDestinationRGB:   BlendFactorZero,\n\t\t\tBlendFactorDestinationAlpha: BlendFactorZero,\n\t\t\tBlendOperationRGB:           BlendOperationAdd,\n\t\t\tBlendOperationAlpha:         BlendOperationAdd,\n\t\t}\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"ebiten: invalid composite mode: %d\", c))\n\t}\n}\n"
        },
        {
          "name": "cursor.go",
          "type": "blob",
          "size": 2.3896484375,
          "content": "// Copyright 2019 The Ebiten Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\n// CursorModeType represents a render and coordinate mode of a mouse cursor.\ntype CursorModeType int\n\n// CursorModeTypes\nconst (\n\tCursorModeVisible  CursorModeType = CursorModeType(ui.CursorModeVisible)\n\tCursorModeHidden   CursorModeType = CursorModeType(ui.CursorModeHidden)\n\tCursorModeCaptured CursorModeType = CursorModeType(ui.CursorModeCaptured)\n)\n\n// CursorShapeType represents a shape of a mouse cursor.\ntype CursorShapeType int\n\n// CursorShapeTypes\nconst (\n\tCursorShapeDefault    CursorShapeType = CursorShapeType(ui.CursorShapeDefault)\n\tCursorShapeText       CursorShapeType = CursorShapeType(ui.CursorShapeText)\n\tCursorShapeCrosshair  CursorShapeType = CursorShapeType(ui.CursorShapeCrosshair)\n\tCursorShapePointer    CursorShapeType = CursorShapeType(ui.CursorShapePointer)\n\tCursorShapeEWResize   CursorShapeType = CursorShapeType(ui.CursorShapeEWResize)\n\tCursorShapeNSResize   CursorShapeType = CursorShapeType(ui.CursorShapeNSResize)\n\tCursorShapeNESWResize CursorShapeType = CursorShapeType(ui.CursorShapeNESWResize)\n\tCursorShapeNWSEResize CursorShapeType = CursorShapeType(ui.CursorShapeNWSEResize)\n\tCursorShapeMove       CursorShapeType = CursorShapeType(ui.CursorShapeMove)\n\tCursorShapeNotAllowed CursorShapeType = CursorShapeType(ui.CursorShapeNotAllowed)\n)\n\n// CursorShape returns the current cursor shape.\n//\n// CursorShape returns CursorShapeDefault on mobiles.\n//\n// CursorShape is concurrent-safe.\nfunc CursorShape() CursorShapeType {\n\treturn CursorShapeType(ui.Get().CursorShape())\n}\n\n// SetCursorShape sets the cursor shape.\n//\n// If the platform doesn't implement the given shape, the default cursor shape is used.\n//\n// SetCursorShape is concurrent-safe.\nfunc SetCursorShape(shape CursorShapeType) {\n\tui.Get().SetCursorShape(ui.CursorShape(shape))\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 5.4306640625,
          "content": "// Copyright 2014 Hajime Hoshi\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Package ebiten provides graphics and input API to develop a 2D game.\n//\n// You can start the game by calling the function RunGame.\n//\n//\t// Game implements ebiten.Game interface.\n//\ttype Game struct{}\n//\n//\t// Update proceeds the game state.\n//\t// Update is called every tick (1/60 [s] by default).\n//\tfunc (g *Game) Update() error {\n//\t    // Write your game's logical update.\n//\t    return nil\n//\t}\n//\n//\t// Draw draws the game screen.\n//\t// Draw is called every frame (typically 1/60[s] for 60Hz display).\n//\tfunc (g *Game) Draw(screen *ebiten.Image) {\n//\t    // Write your game's rendering.\n//\t}\n//\n//\t// Layout takes the outside size (e.g., the window size) and returns the (logical) screen size.\n//\t// If you don't have to adjust the screen size with the outside size, just return a fixed size.\n//\tfunc (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {\n//\t    return 320, 240\n//\t}\n//\n//\tfunc main() {\n//\t    game := &Game{}\n//\t    // Specify the window size as you like. Here, a doubled size is specified.\n//\t    ebiten.SetWindowSize(640, 480)\n//\t    ebiten.SetWindowTitle(\"Your game's title\")\n//\t    // Call ebiten.RunGame to start your game loop.\n//\t    if err := ebiten.RunGame(game); err != nil {\n//\t        log.Fatal(err)\n//\t    }\n//\t}\n//\n// In the API document, 'the main thread' means the goroutine in init(), main() and their callees without 'go'\n// statement. It is assured that 'the main thread' runs on the OS main thread. There are some Ebitengine functions (e.g.,\n// DeviceScaleFactor) that must be called on the main thread under some conditions (typically, before ebiten.RunGame\n// is called).\n//\n// # Environment variables\n//\n// `EBITENGINE_SCREENSHOT_KEY` environment variable specifies the key\n// to take a screenshot. For example, if you run your game with\n// `EBITENGINE_SCREENSHOT_KEY=q`, you can take a game screen's screenshot\n// by pressing Q key. This works only on desktops and browsers.\n//\n// `EBITENGINE_INTERNAL_IMAGES_KEY` environment variable specifies the key\n// to dump all the internal images. This is valid only when the build tag\n// 'ebitenginedebug' is specified. This works only on desktops and browsers.\n//\n// `EBITENGINE_GRAPHICS_LIBRARY` environment variable specifies the graphics library.\n// If the specified graphics library is not available, RunGame returns an error.\n// This environment variable works when RunGame is called or RunGameWithOptions is called with GraphicsLibraryAuto.\n// This can take one of the following value:\n//\n//\t\"auto\":         Ebitengine chooses the graphics library automatically. This is the default value.\n//\t\"opengl\":       OpenGL, OpenGL ES, or WebGL.\n//\t\"directx\":      DirectX. This works only on Windows.\n//\t\"metal\":        Metal. This works only on macOS or iOS.\n//\t\"playstation5\": PlayStation 5. This works only on PlayStation 5.\n//\n// `EBITENGINE_DIRECTX` environment variable specifies various parameters for DirectX.\n// You can specify multiple values separated by a comma. The default value is empty (i.e. no parameters).\n//\n//\t\"debug\":                      Use a debug layer.\n//\t\"warp\":                       Use WARP (i.e. software rendering).\n//\t\"version=VERSION\":            Specify a DirectX version (e.g. 11).\n//\t\"featurelevel=FEATURE_LEVEL\": Specify a feature level (e.g. 11_0). This is for DirectX 12.\n//\n// The options taking arguments are exclusive, and if multiples are specified, the lastly specified value is adopted.\n//\n// The possible values for the option \"version\" are \"11\" and \"12\".\n// If the version is not specified, the default version 11 is adopted.\n// On Xbox, the \"version\" option is ignored and DirectX 12 is always adopted.\n//\n// The option \"featurelevel\" is valid only for DirectX 12.\n// The possible values are \"11_0\", \"11_1\", \"12_0\", \"12_1\", and \"12_2\". The default value is \"11_0\".\n//\n// # Build tags\n//\n// `ebitenginedebug` outputs a log of graphics commands. This is useful to know what happens in Ebitengine. In general, the\n// number of graphics commands affects the performance of your game.\n//\n// `ebitenginegldebug` enables a debug mode for OpenGL. This is valid only when the graphics library is OpenGL.\n// This affects performance very much.\n//\n// `ebitenginesinglethread` disables Ebitengine's thread safety to unlock maximum performance. If you use this you will have\n// to manage threads yourself. Functions like `SetWindowSize` will no longer be concurrent-safe with this build tag.\n// They must be called from the main thread or the same goroutine as the given game's callback functions like Update\n// `ebitenginesinglethread` works only with desktops and consoles.\n// `ebitenginesinglethread` was deprecated as of v2.7. Use RunGameOptions.SingleThread instead.\n//\n// `microsoftgdk` is for Microsoft GDK (e.g. Xbox).\n//\n// `nintendosdk` is for NintendoSDK (e.g. Nintendo Switch).\n//\n// `nintendosdkprofile` enables a profiler for NintendoSDK.\n//\n// `playstation5` is for PlayStation 5.\npackage ebiten\n"
        },
        {
          "name": "ebiten_test.go",
          "type": "blob",
          "size": 0.9580078125,
          "content": "// Copyright 2024 The Ebitengine Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/hajimehoshi/ebiten/v2\"\n)\n\nfunc TestScreenSizeInFullscreen(t *testing.T) {\n\t// Just call ScreenSizeInFullscreen. There was a crash bug on browsers (#2975).\n\tw, h := ebiten.ScreenSizeInFullscreen()\n\tif w <= 0 {\n\t\tt.Errorf(\"w must be positive but not: %d\", w)\n\t}\n\tif h <= 0 {\n\t\tt.Errorf(\"h must be positive but not: %d\", h)\n\t}\n}\n"
        },
        {
          "name": "ebitenutil",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "exp",
          "type": "tree",
          "content": null
        },
        {
          "name": "export_test.go",
          "type": "blob",
          "size": 0.8525390625,
          "content": "// Copyright 2019 The Ebiten Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport \"github.com/hajimehoshi/ebiten/v2/internal/builtinshader\"\n\nvar (\n\tImageToBytes = imageToBytes\n)\n\nfunc BuiltinShader(filter builtinshader.Filter, address builtinshader.Address, useColorM bool) *Shader {\n\treturn builtinShader(filter, address, useColorM)\n}\n"
        },
        {
          "name": "gameforui.go",
          "type": "blob",
          "size": 4.662109375,
          "content": "// Copyright 2014 Hajime Hoshi\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"math\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/hajimehoshi/ebiten/v2/internal/atlas\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/builtinshader\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\nvar screenFilterEnabled atomic.Bool\n\nfunc init() {\n\tscreenFilterEnabled.Store(true)\n}\n\ntype gameForUI struct {\n\tgame        Game\n\toffscreen   *Image\n\tscreen      *Image\n\timageDumper imageDumper\n\ttransparent bool\n}\n\nfunc newGameForUI(game Game, transparent bool) *gameForUI {\n\tg := &gameForUI{\n\t\tgame:        game,\n\t\ttransparent: transparent,\n\t}\n\treturn g\n}\n\nfunc (g *gameForUI) NewOffscreenImage(width, height int) *ui.Image {\n\tif g.offscreen != nil {\n\t\tg.offscreen.Deallocate()\n\t\tg.offscreen = nil\n\t}\n\n\t// Keep the offscreen an unmanaged image that is always isolated from an atlas (#1938).\n\t// The shader program for the screen is special and doesn't work well with an image on an atlas.\n\t// An image on an atlas is surrounded by a transparent edge,\n\t// and the shader program unexpectedly picks the pixel on the edges.\n\timageType := atlas.ImageTypeUnmanaged\n\tif ui.Get().IsScreenClearedEveryFrame() {\n\t\t// A volatile image is also always isolated.\n\t\timageType = atlas.ImageTypeVolatile\n\t}\n\tg.offscreen = newImage(image.Rect(0, 0, width, height), imageType)\n\treturn g.offscreen.image\n}\n\nfunc (g *gameForUI) NewScreenImage(width, height int) *ui.Image {\n\tif g.screen != nil {\n\t\tg.screen.Deallocate()\n\t\tg.screen = nil\n\t}\n\n\tg.screen = newImage(image.Rect(0, 0, width, height), atlas.ImageTypeScreen)\n\treturn g.screen.image\n}\n\nfunc (g *gameForUI) Layout(outsideWidth, outsideHeight float64) (float64, float64) {\n\tif l, ok := g.game.(LayoutFer); ok {\n\t\treturn l.LayoutF(outsideWidth, outsideHeight)\n\t}\n\n\t// Even if the original value is less than 1, the value must be a positive integer (#2340).\n\t// This is for a simple implementation of Layout, which returns the argument values without modifications.\n\t// TODO: Remove this hack when Game.Layout takes floats instead of integers.\n\tif outsideWidth < 1 {\n\t\toutsideWidth = 1\n\t}\n\tif outsideHeight < 1 {\n\t\toutsideHeight = 1\n\t}\n\n\tsw, sh := g.game.Layout(int(outsideWidth), int(outsideHeight))\n\treturn float64(sw), float64(sh)\n}\n\nfunc (g *gameForUI) UpdateInputState(fn func(*ui.InputState)) {\n\ttheInputState.update(fn)\n}\n\nfunc (g *gameForUI) Update() error {\n\tif err := g.game.Update(); err != nil {\n\t\treturn err\n\t}\n\tif err := g.imageDumper.update(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (g *gameForUI) DrawOffscreen() error {\n\tg.game.Draw(g.offscreen)\n\tif err := g.imageDumper.dump(g.offscreen, g.transparent); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (g *gameForUI) DrawFinalScreen(scale, offsetX, offsetY float64) {\n\tvar geoM GeoM\n\tgeoM.Scale(scale, scale)\n\tgeoM.Translate(offsetX, offsetY)\n\n\tif d, ok := g.game.(FinalScreenDrawer); ok {\n\t\td.DrawFinalScreen(g.screen, g.offscreen, geoM)\n\t\treturn\n\t}\n\n\tDefaultDrawFinalScreen(g.screen, g.offscreen, geoM)\n}\n\nvar (\n\ttheScreenShader     *Shader\n\ttheScreenShaderOnce sync.Once\n)\n\n// DefaultDrawFinalScreen is the default implementation of [FinalScreenDrawer.DrawFinalScreen],\n// used when a [Game] doesn't implement [FinalScreenDrawer].\n//\n// You can use DefaultDrawFinalScreen when you need the default implementation of [FinalScreenDrawer.DrawFinalScreen]\n// in your implementation of [FinalScreenDrawer], for example.\nfunc DefaultDrawFinalScreen(screen FinalScreen, offscreen *Image, geoM GeoM) {\n\ttheScreenShaderOnce.Do(func() {\n\t\ts, err := newShader([]byte(builtinshader.ScreenShaderSource), \"screen\")\n\t\tif err != nil {\n\t\t\tpanic(fmt.Sprintf(\"ebiten: compiling the screen shader failed: %v\", err))\n\t\t}\n\t\ttheScreenShader = s\n\t})\n\n\tscale := geoM.Element(0, 0)\n\tswitch {\n\tcase !screenFilterEnabled.Load(), math.Floor(scale) == scale:\n\t\top := &DrawImageOptions{}\n\t\top.GeoM = geoM\n\t\tscreen.DrawImage(offscreen, op)\n\tcase scale < 1:\n\t\top := &DrawImageOptions{}\n\t\top.GeoM = geoM\n\t\top.Filter = FilterLinear\n\t\tscreen.DrawImage(offscreen, op)\n\tdefault:\n\t\top := &DrawRectShaderOptions{}\n\t\top.Images[0] = offscreen\n\t\top.GeoM = geoM\n\t\tw, h := offscreen.Bounds().Dx(), offscreen.Bounds().Dy()\n\t\tscreen.DrawRectShader(w, h, theScreenShader, op)\n\t}\n}\n"
        },
        {
          "name": "gamepad.go",
          "type": "blob",
          "size": 5.3720703125,
          "content": "// Copyright 2015 Hajime Hoshi\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"github.com/hajimehoshi/ebiten/v2/internal/gamepad\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/gamepaddb\"\n)\n\n// GamepadButton represents a gamepad button.\ntype GamepadButton = gamepad.Button\n\n// GamepadButtons\nconst (\n\tGamepadButton0   GamepadButton = gamepad.Button0\n\tGamepadButton1   GamepadButton = gamepad.Button1\n\tGamepadButton2   GamepadButton = gamepad.Button2\n\tGamepadButton3   GamepadButton = gamepad.Button3\n\tGamepadButton4   GamepadButton = gamepad.Button4\n\tGamepadButton5   GamepadButton = gamepad.Button5\n\tGamepadButton6   GamepadButton = gamepad.Button6\n\tGamepadButton7   GamepadButton = gamepad.Button7\n\tGamepadButton8   GamepadButton = gamepad.Button8\n\tGamepadButton9   GamepadButton = gamepad.Button9\n\tGamepadButton10  GamepadButton = gamepad.Button10\n\tGamepadButton11  GamepadButton = gamepad.Button11\n\tGamepadButton12  GamepadButton = gamepad.Button12\n\tGamepadButton13  GamepadButton = gamepad.Button13\n\tGamepadButton14  GamepadButton = gamepad.Button14\n\tGamepadButton15  GamepadButton = gamepad.Button15\n\tGamepadButton16  GamepadButton = gamepad.Button16\n\tGamepadButton17  GamepadButton = gamepad.Button17\n\tGamepadButton18  GamepadButton = gamepad.Button18\n\tGamepadButton19  GamepadButton = gamepad.Button19\n\tGamepadButton20  GamepadButton = gamepad.Button20\n\tGamepadButton21  GamepadButton = gamepad.Button21\n\tGamepadButton22  GamepadButton = gamepad.Button22\n\tGamepadButton23  GamepadButton = gamepad.Button23\n\tGamepadButton24  GamepadButton = gamepad.Button24\n\tGamepadButton25  GamepadButton = gamepad.Button25\n\tGamepadButton26  GamepadButton = gamepad.Button26\n\tGamepadButton27  GamepadButton = gamepad.Button27\n\tGamepadButton28  GamepadButton = gamepad.Button28\n\tGamepadButton29  GamepadButton = gamepad.Button29\n\tGamepadButton30  GamepadButton = gamepad.Button30\n\tGamepadButton31  GamepadButton = gamepad.Button31\n\tGamepadButtonMax GamepadButton = GamepadButton31\n)\n\n// GamepadAxisType represents a gamepad axis.\n// This is the same as int for backward compatibility in v2.\ntype GamepadAxisType = int\n\n// StandardGamepadButton represents a gamepad button in the standard layout.\n//\n// The layout and the button values are based on the web standard.\n// See https://www.w3.org/TR/gamepad/#remapping.\ntype StandardGamepadButton = gamepaddb.StandardButton\n\n// StandardGamepadButtons\nconst (\n\tStandardGamepadButtonRightBottom      StandardGamepadButton = gamepaddb.StandardButtonRightBottom\n\tStandardGamepadButtonRightRight       StandardGamepadButton = gamepaddb.StandardButtonRightRight\n\tStandardGamepadButtonRightLeft        StandardGamepadButton = gamepaddb.StandardButtonRightLeft\n\tStandardGamepadButtonRightTop         StandardGamepadButton = gamepaddb.StandardButtonRightTop\n\tStandardGamepadButtonFrontTopLeft     StandardGamepadButton = gamepaddb.StandardButtonFrontTopLeft\n\tStandardGamepadButtonFrontTopRight    StandardGamepadButton = gamepaddb.StandardButtonFrontTopRight\n\tStandardGamepadButtonFrontBottomLeft  StandardGamepadButton = gamepaddb.StandardButtonFrontBottomLeft\n\tStandardGamepadButtonFrontBottomRight StandardGamepadButton = gamepaddb.StandardButtonFrontBottomRight\n\tStandardGamepadButtonCenterLeft       StandardGamepadButton = gamepaddb.StandardButtonCenterLeft\n\tStandardGamepadButtonCenterRight      StandardGamepadButton = gamepaddb.StandardButtonCenterRight\n\tStandardGamepadButtonLeftStick        StandardGamepadButton = gamepaddb.StandardButtonLeftStick\n\tStandardGamepadButtonRightStick       StandardGamepadButton = gamepaddb.StandardButtonRightStick\n\tStandardGamepadButtonLeftTop          StandardGamepadButton = gamepaddb.StandardButtonLeftTop\n\tStandardGamepadButtonLeftBottom       StandardGamepadButton = gamepaddb.StandardButtonLeftBottom\n\tStandardGamepadButtonLeftLeft         StandardGamepadButton = gamepaddb.StandardButtonLeftLeft\n\tStandardGamepadButtonLeftRight        StandardGamepadButton = gamepaddb.StandardButtonLeftRight\n\tStandardGamepadButtonCenterCenter     StandardGamepadButton = gamepaddb.StandardButtonCenterCenter\n\tStandardGamepadButtonMax              StandardGamepadButton = StandardGamepadButtonCenterCenter\n)\n\n// StandardGamepadAxis represents a gamepad axis in the standard layout.\n//\n// The layout and the button values are based on the web standard.\n// See https://www.w3.org/TR/gamepad/#remapping.\ntype StandardGamepadAxis = gamepaddb.StandardAxis\n\n// StandardGamepadAxes\nconst (\n\tStandardGamepadAxisLeftStickHorizontal  StandardGamepadAxis = gamepaddb.StandardAxisLeftStickHorizontal\n\tStandardGamepadAxisLeftStickVertical    StandardGamepadAxis = gamepaddb.StandardAxisLeftStickVertical\n\tStandardGamepadAxisRightStickHorizontal StandardGamepadAxis = gamepaddb.StandardAxisRightStickHorizontal\n\tStandardGamepadAxisRightStickVertical   StandardGamepadAxis = gamepaddb.StandardAxisRightStickVertical\n\tStandardGamepadAxisMax                  StandardGamepadAxis = StandardGamepadAxisRightStickVertical\n)\n"
        },
        {
          "name": "generate.go",
          "type": "blob",
          "size": 0.7509765625,
          "content": "// Copyright 2015 Hajime Hoshi\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\n//go:generate go run genkeys.go\n//go:generate gofmt -s -w .\n\n// TODO: Add this after event package is added again (#926).\n//\n//    go:generate go run genevents.go\n"
        },
        {
          "name": "genkeys.go",
          "type": "blob",
          "size": 22.33203125,
          "content": "// Copyright 2015 Hajime Hoshi\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build ignore\n\n// The key name convention follows the Web standard: https://www.w3.org/TR/uievents-code/#code-value-tables\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"text/template\"\n)\n\nvar (\n\tglfwKeyNameToGLFWKey            map[string]int\n\tuiKeyNameToGLFWKeyName          map[string]string\n\tandroidKeyToUIKeyName           map[int]string\n\tiosKeyToUIKeyName               map[int]string\n\tuiKeyNameToJSCode               map[string]string\n\toldEbitengineKeyNameToUIKeyName map[string]string\n)\n\nfunc init() {\n\tglfwKeyNameToGLFWKey = map[string]int{\n\t\t\"Unknown\":      -1,\n\t\t\"Space\":        32,\n\t\t\"Apostrophe\":   39,\n\t\t\"Comma\":        44,\n\t\t\"Minus\":        45,\n\t\t\"Period\":       46,\n\t\t\"Slash\":        47,\n\t\t\"Semicolon\":    59,\n\t\t\"Equal\":        61,\n\t\t\"LeftBracket\":  91,\n\t\t\"Backslash\":    92,\n\t\t\"RightBracket\": 93,\n\t\t\"GraveAccent\":  96,\n\t\t\"World1\":       161,\n\t\t\"World2\":       162,\n\t\t\"Escape\":       256,\n\t\t\"Enter\":        257,\n\t\t\"Tab\":          258,\n\t\t\"Backspace\":    259,\n\t\t\"Insert\":       260,\n\t\t\"Delete\":       261,\n\t\t\"Right\":        262,\n\t\t\"Left\":         263,\n\t\t\"Down\":         264,\n\t\t\"Up\":           265,\n\t\t\"PageUp\":       266,\n\t\t\"PageDown\":     267,\n\t\t\"Home\":         268,\n\t\t\"End\":          269,\n\t\t\"CapsLock\":     280,\n\t\t\"ScrollLock\":   281,\n\t\t\"NumLock\":      282,\n\t\t\"PrintScreen\":  283,\n\t\t\"Pause\":        284,\n\t\t\"LeftShift\":    340,\n\t\t\"LeftControl\":  341,\n\t\t\"LeftAlt\":      342,\n\t\t\"LeftSuper\":    343,\n\t\t\"RightShift\":   344,\n\t\t\"RightControl\": 345,\n\t\t\"RightAlt\":     346,\n\t\t\"RightSuper\":   347,\n\t\t\"Menu\":         348,\n\t\t\"KPDecimal\":    330,\n\t\t\"KPDivide\":     331,\n\t\t\"KPMultiply\":   332,\n\t\t\"KPSubtract\":   333,\n\t\t\"KPAdd\":        334,\n\t\t\"KPEnter\":      335,\n\t\t\"KPEqual\":      336,\n\t\t\"Last\":         348,\n\t}\n\n\tuiKeyNameToGLFWKeyName = map[string]string{\n\t\t\"Space\":          \"Space\",\n\t\t\"Quote\":          \"Apostrophe\",\n\t\t\"Comma\":          \"Comma\",\n\t\t\"Minus\":          \"Minus\",\n\t\t\"Period\":         \"Period\",\n\t\t\"Slash\":          \"Slash\",\n\t\t\"Semicolon\":      \"Semicolon\",\n\t\t\"Equal\":          \"Equal\",\n\t\t\"BracketLeft\":    \"LeftBracket\",\n\t\t\"Backslash\":      \"Backslash\",\n\t\t\"BracketRight\":   \"RightBracket\",\n\t\t\"Backquote\":      \"GraveAccent\",\n\t\t\"Escape\":         \"Escape\",\n\t\t\"Enter\":          \"Enter\",\n\t\t\"Tab\":            \"Tab\",\n\t\t\"Backspace\":      \"Backspace\",\n\t\t\"Insert\":         \"Insert\",\n\t\t\"Delete\":         \"Delete\",\n\t\t\"ArrowRight\":     \"Right\",\n\t\t\"ArrowLeft\":      \"Left\",\n\t\t\"ArrowDown\":      \"Down\",\n\t\t\"ArrowUp\":        \"Up\",\n\t\t\"PageUp\":         \"PageUp\",\n\t\t\"PageDown\":       \"PageDown\",\n\t\t\"Home\":           \"Home\",\n\t\t\"End\":            \"End\",\n\t\t\"CapsLock\":       \"CapsLock\",\n\t\t\"ScrollLock\":     \"ScrollLock\",\n\t\t\"NumLock\":        \"NumLock\",\n\t\t\"PrintScreen\":    \"PrintScreen\",\n\t\t\"Pause\":          \"Pause\",\n\t\t\"ShiftLeft\":      \"LeftShift\",\n\t\t\"ControlLeft\":    \"LeftControl\",\n\t\t\"AltLeft\":        \"LeftAlt\",\n\t\t\"MetaLeft\":       \"LeftSuper\",\n\t\t\"ShiftRight\":     \"RightShift\",\n\t\t\"ControlRight\":   \"RightControl\",\n\t\t\"AltRight\":       \"RightAlt\",\n\t\t\"MetaRight\":      \"RightSuper\",\n\t\t\"ContextMenu\":    \"Menu\",\n\t\t\"NumpadAdd\":      \"KPAdd\",\n\t\t\"NumpadDecimal\":  \"KPDecimal\",\n\t\t\"NumpadDivide\":   \"KPDivide\",\n\t\t\"NumpadMultiply\": \"KPMultiply\",\n\t\t\"NumpadSubtract\": \"KPSubtract\",\n\t\t\"NumpadEnter\":    \"KPEnter\",\n\t\t\"NumpadEqual\":    \"KPEqual\",\n\t\t\"IntlBackslash\":  \"World1\",\n\t}\n\n\t// https://developer.android.com/reference/android/view/KeyEvent\n\t//\n\t// Android doesn't distinguish these keys:\n\t// - a US backslash key (HID: 0x31),\n\t// - an international pound/tilde key (HID: 0x32), and\n\t// - an international backslash key (HID: 0x64).\n\t// These are mapped to the same key code KEYCODE_BACKSLASH (73).\n\t// See https://source.android.com/docs/core/interaction/input/keyboard-devices\n\tandroidKeyToUIKeyName = map[int]string{\n\t\t55:  \"Comma\",\n\t\t56:  \"Period\",\n\t\t57:  \"AltLeft\",\n\t\t58:  \"AltRight\",\n\t\t115: \"CapsLock\",\n\t\t113: \"ControlLeft\",\n\t\t114: \"ControlRight\",\n\t\t59:  \"ShiftLeft\",\n\t\t60:  \"ShiftRight\",\n\t\t66:  \"Enter\",\n\t\t62:  \"Space\",\n\t\t61:  \"Tab\",\n\t\t112: \"Delete\", // KEYCODE_FORWARD_DEL\n\t\t123: \"End\",\n\t\t122: \"Home\",\n\t\t124: \"Insert\",\n\t\t93:  \"PageDown\",\n\t\t92:  \"PageUp\",\n\t\t20:  \"ArrowDown\",\n\t\t21:  \"ArrowLeft\",\n\t\t22:  \"ArrowRight\",\n\t\t19:  \"ArrowUp\",\n\t\t111: \"Escape\",\n\t\t67:  \"Backspace\", // KEYCODE_DEL\n\t\t75:  \"Quote\",\n\t\t69:  \"Minus\",\n\t\t76:  \"Slash\",\n\t\t74:  \"Semicolon\",\n\t\t70:  \"Equal\",\n\t\t71:  \"BracketLeft\",\n\t\t73:  \"Backslash\",\n\t\t72:  \"BracketRight\",\n\t\t68:  \"Backquote\",\n\t\t143: \"NumLock\",\n\t\t121: \"Pause\",       // KEYCODE_BREAK\n\t\t120: \"PrintScreen\", // KEYCODE_SYSRQ\n\t\t116: \"ScrollLock\",\n\t\t82:  \"ContextMenu\",\n\t\t157: \"NumpadAdd\",\n\t\t158: \"NumpadDecimal\",\n\t\t154: \"NumpadDivide\",\n\t\t155: \"NumpadMultiply\",\n\t\t156: \"NumpadSubtract\",\n\t\t160: \"NumpadEnter\",\n\t\t161: \"NumpadEqual\",\n\t\t117: \"MetaLeft\",\n\t\t118: \"MetaRight\",\n\t}\n\n\t// https://developer.apple.com/documentation/uikit/uikeyboardhidusage?language=objc\n\tiosKeyToUIKeyName = map[int]string{\n\t\t0xE2: \"AltLeft\",\n\t\t0xE6: \"AltRight\",\n\t\t0x51: \"ArrowDown\",\n\t\t0x50: \"ArrowLeft\",\n\t\t0x4F: \"ArrowRight\",\n\t\t0x52: \"ArrowUp\",\n\t\t0x35: \"Backquote\",\n\n\t\t// These three keys are:\n\t\t// - US backslash-pipe key, and\n\t\t// - non-US hashmark key (bottom left of return; on German layout, this is the #' key).\n\t\t// On US layout configurations, they all map to the same characters - the backslash.\n\t\t//\n\t\t// See also: https://www.w3.org/TR/uievents-code/#keyboard-102\n\t\t0x31: \"Backslash\", // UIKeyboardHIDUsageKeyboardBackslash\n\t\t0x32: \"Backslash\", // UIKeyboardHIDUsageKeyboardNonUSPound\n\n\t\t0x64: \"IntlBackslash\", // UIKeyboardHIDUsageKeyboardNonUSBackslash\n\n\t\t0x2A: \"Backspace\",\n\t\t0x2F: \"BracketLeft\",\n\t\t0x30: \"BracketRight\",\n\n\t\t// Caps Lock can either be a normal key or a hardware toggle.\n\t\t0x39: \"CapsLock\", // UIKeyboardHIDUsageKeyboardCapsLock\n\t\t0x82: \"CapsLock\", // UIKeyboardHIDUsageKeyboardLockingCapsLock\n\n\t\t0x36: \"Comma\",\n\t\t0xE0: \"ControlLeft\",\n\t\t0xE4: \"ControlRight\",\n\t\t0x4C: \"Delete\",\n\t\t0x4D: \"End\",\n\t\t0x28: \"Enter\",\n\t\t0x2E: \"Equal\",\n\t\t0x29: \"Escape\",\n\t\t0x4A: \"Home\",\n\t\t0x49: \"Insert\",\n\t\t0x76: \"ContextMenu\",\n\t\t0xE3: \"MetaLeft\",\n\t\t0xE7: \"MetaRight\",\n\t\t0x2D: \"Minus\",\n\n\t\t// Num Lock can either be a normal key or a hardware toggle.\n\t\t0x53: \"NumLock\", // UIKeyboardHIDUsageKeyboardNumLock\n\t\t0x83: \"NumLock\", // UIKeyboardHIDUsageKeyboardLockingNumLock\n\n\t\t0x57: \"NumpadAdd\",\n\n\t\t// Some keyboard layouts have a comma, some a period on the numeric pad.\n\t\t// They are the same key, though.\n\t\t0x63: \"NumpadDecimal\", // UIKeyboardHIDUsageKeypadPeriod\n\t\t0x85: \"NumpadDecimal\", // UIKeyboardHIDUsageKeypadComma\n\n\t\t0x54: \"NumpadDivide\",\n\t\t0x58: \"NumpadEnter\",\n\n\t\t// Some numeric keypads also have an equals sign.\n\t\t// There appear to be two separate keycodes for that.\n\t\t0x67: \"NumpadEqual\", // UIKeyboardHIDUsageKeypadEqualSign\n\t\t0x86: \"NumpadEqual\", // UIKeyboardHIDUsageKeypadEqualSignAS400\n\n\t\t0x55: \"NumpadMultiply\",\n\t\t0x56: \"NumpadSubtract\",\n\t\t0x4E: \"PageDown\",\n\t\t0x4B: \"PageUp\",\n\t\t0x48: \"Pause\",\n\t\t0x37: \"Period\",\n\t\t0x46: \"PrintScreen\",\n\t\t0x34: \"Quote\",\n\n\t\t// Scroll Lock can either be a normal key or a hardware toggle.\n\t\t0x47: \"ScrollLock\", // UIKeyboardHIDUsageKeyboardScrollLock\n\t\t0x84: \"ScrollLock\", // UIKeyboardHIDUsageKeyboardLockingScrollLock\n\n\t\t0x33: \"Semicolon\",\n\t\t0xE1: \"ShiftLeft\",\n\t\t0xE5: \"ShiftRight\",\n\t\t0x38: \"Slash\",\n\t\t0x2C: \"Space\",\n\t\t0x2B: \"Tab\",\n\t}\n\n\t// The UI key and JS key are almost same but very slightly different (e.g., 'A' vs 'KeyA').\n\tuiKeyNameToJSCode = map[string]string{\n\t\t\"Comma\":          \"Comma\",\n\t\t\"Period\":         \"Period\",\n\t\t\"AltLeft\":        \"AltLeft\",\n\t\t\"AltRight\":       \"AltRight\",\n\t\t\"CapsLock\":       \"CapsLock\",\n\t\t\"ControlLeft\":    \"ControlLeft\",\n\t\t\"ControlRight\":   \"ControlRight\",\n\t\t\"ShiftLeft\":      \"ShiftLeft\",\n\t\t\"ShiftRight\":     \"ShiftRight\",\n\t\t\"Enter\":          \"Enter\",\n\t\t\"Space\":          \"Space\",\n\t\t\"Tab\":            \"Tab\",\n\t\t\"Delete\":         \"Delete\",\n\t\t\"End\":            \"End\",\n\t\t\"Home\":           \"Home\",\n\t\t\"Insert\":         \"Insert\",\n\t\t\"PageDown\":       \"PageDown\",\n\t\t\"PageUp\":         \"PageUp\",\n\t\t\"ArrowDown\":      \"ArrowDown\",\n\t\t\"ArrowLeft\":      \"ArrowLeft\",\n\t\t\"ArrowRight\":     \"ArrowRight\",\n\t\t\"ArrowUp\":        \"ArrowUp\",\n\t\t\"Escape\":         \"Escape\",\n\t\t\"Backspace\":      \"Backspace\",\n\t\t\"Quote\":          \"Quote\",\n\t\t\"Minus\":          \"Minus\",\n\t\t\"Slash\":          \"Slash\",\n\t\t\"Semicolon\":      \"Semicolon\",\n\t\t\"Equal\":          \"Equal\",\n\t\t\"BracketLeft\":    \"BracketLeft\",\n\t\t\"Backslash\":      \"Backslash\",\n\t\t\"BracketRight\":   \"BracketRight\",\n\t\t\"Backquote\":      \"Backquote\",\n\t\t\"NumLock\":        \"NumLock\",\n\t\t\"Pause\":          \"Pause\",\n\t\t\"PrintScreen\":    \"PrintScreen\",\n\t\t\"ScrollLock\":     \"ScrollLock\",\n\t\t\"ContextMenu\":    \"ContextMenu\",\n\t\t\"NumpadAdd\":      \"NumpadAdd\",\n\t\t\"NumpadDecimal\":  \"NumpadDecimal\",\n\t\t\"NumpadDivide\":   \"NumpadDivide\",\n\t\t\"NumpadMultiply\": \"NumpadMultiply\",\n\t\t\"NumpadSubtract\": \"NumpadSubtract\",\n\t\t\"NumpadEnter\":    \"NumpadEnter\",\n\t\t\"NumpadEqual\":    \"NumpadEqual\",\n\t\t\"MetaLeft\":       \"MetaLeft\",\n\t\t\"MetaRight\":      \"MetaRight\",\n\t\t\"IntlBackslash\":  \"IntlBackslash\",\n\t}\n\n\tconst (\n\t\tglfwKey0   = 48\n\t\tglfwKeyA   = 65\n\t\tglfwKeyF1  = 290\n\t\tglfwKeyKP0 = 320\n\t)\n\n\t// ASCII: 0 - 9\n\tfor c := '0'; c <= '9'; c++ {\n\t\tglfwKeyNameToGLFWKey[string(c)] = int(glfwKey0 + c - '0')\n\t\tname := \"Digit\" + string(c)\n\t\tuiKeyNameToGLFWKeyName[name] = string(c)\n\t\tandroidKeyToUIKeyName[7+int(c)-'0'] = name\n\t\t// Gomobile's key code (= USB HID key codes) has successive key codes for 1, 2, ..., 9, 0\n\t\t// in this order. Same for iOS.\n\t\tif c == '0' {\n\t\t\tiosKeyToUIKeyName[0x27] = name\n\t\t} else {\n\t\t\tiosKeyToUIKeyName[0x1E+int(c)-'1'] = name\n\t\t}\n\t\tuiKeyNameToJSCode[name] = name\n\n\t}\n\t// ASCII: A - Z\n\tfor c := 'A'; c <= 'Z'; c++ {\n\t\tglfwKeyNameToGLFWKey[string(c)] = int(glfwKeyA + c - 'A')\n\t\tuiKeyNameToGLFWKeyName[string(c)] = string(c)\n\t\tandroidKeyToUIKeyName[29+int(c)-'A'] = string(c)\n\t\tiosKeyToUIKeyName[0x04+int(c)-'A'] = string(c)\n\t\tuiKeyNameToJSCode[string(c)] = \"Key\" + string(c)\n\t}\n\t// Function keys\n\tfor i := 1; i <= 24; i++ {\n\t\tname := \"F\" + strconv.Itoa(i)\n\t\tglfwKeyNameToGLFWKey[name] = glfwKeyF1 + i - 1\n\t\tuiKeyNameToGLFWKeyName[name] = name\n\t\t// Android doesn't support F13 and more as constants of KeyEvent:\n\t\t// https://developer.android.com/reference/android/view/KeyEvent\n\t\t//\n\t\t// Note that F13 might be avilable if HID devices are available directly:\n\t\t// https://source.android.com/docs/core/interaction/input/keyboard-devices\n\t\tif i <= 12 {\n\t\t\tandroidKeyToUIKeyName[131+i-1] = name\n\t\t}\n\t\tif i <= 12 {\n\t\t\tiosKeyToUIKeyName[0x3A+i-1] = name\n\t\t} else {\n\t\t\tiosKeyToUIKeyName[0x68+i-13] = name\n\t\t}\n\t\tuiKeyNameToJSCode[name] = name\n\t}\n\t// Numpad\n\t// https://www.w3.org/TR/uievents-code/#key-numpad-section\n\tfor c := '0'; c <= '9'; c++ {\n\t\tname := \"Numpad\" + string(c)\n\t\tglfwKeyNameToGLFWKey[\"KP\"+string(c)] = int(glfwKeyKP0 + c - '0')\n\t\tuiKeyNameToGLFWKeyName[name] = \"KP\" + string(c)\n\t\tandroidKeyToUIKeyName[144+int(c)-'0'] = name\n\t\t// Gomobile's key code (= USB HID key codes) has successive key codes for 1, 2, ..., 9, 0\n\t\t// in this order. Same for iOS.\n\t\tif c == '0' {\n\t\t\tiosKeyToUIKeyName[0x62] = name\n\t\t} else {\n\t\t\tiosKeyToUIKeyName[0x59+int(c)-'1'] = name\n\t\t}\n\t\tuiKeyNameToJSCode[name] = name\n\t}\n\n\t// Keys for backward compatibility\n\toldEbitengineKeyNameToUIKeyName = map[string]string{\n\t\t\"0\":            \"Digit0\",\n\t\t\"1\":            \"Digit1\",\n\t\t\"2\":            \"Digit2\",\n\t\t\"3\":            \"Digit3\",\n\t\t\"4\":            \"Digit4\",\n\t\t\"5\":            \"Digit5\",\n\t\t\"6\":            \"Digit6\",\n\t\t\"7\":            \"Digit7\",\n\t\t\"8\":            \"Digit8\",\n\t\t\"9\":            \"Digit9\",\n\t\t\"Apostrophe\":   \"Quote\",\n\t\t\"Down\":         \"ArrowDown\",\n\t\t\"GraveAccent\":  \"Backquote\",\n\t\t\"KP0\":          \"Numpad0\",\n\t\t\"KP1\":          \"Numpad1\",\n\t\t\"KP2\":          \"Numpad2\",\n\t\t\"KP3\":          \"Numpad3\",\n\t\t\"KP4\":          \"Numpad4\",\n\t\t\"KP5\":          \"Numpad5\",\n\t\t\"KP6\":          \"Numpad6\",\n\t\t\"KP7\":          \"Numpad7\",\n\t\t\"KP8\":          \"Numpad8\",\n\t\t\"KP9\":          \"Numpad9\",\n\t\t\"KPAdd\":        \"NumpadAdd\",\n\t\t\"KPDecimal\":    \"NumpadDecimal\",\n\t\t\"KPDivide\":     \"NumpadDivide\",\n\t\t\"KPMultiply\":   \"NumpadMultiply\",\n\t\t\"KPSubtract\":   \"NumpadSubtract\",\n\t\t\"KPEnter\":      \"NumpadEnter\",\n\t\t\"KPEqual\":      \"NumpadEqual\",\n\t\t\"Left\":         \"ArrowLeft\",\n\t\t\"LeftBracket\":  \"BracketLeft\",\n\t\t\"Menu\":         \"ContextMenu\",\n\t\t\"Right\":        \"ArrowRight\",\n\t\t\"RightBracket\": \"BracketRight\",\n\t\t\"Up\":           \"ArrowUp\",\n\t}\n}\n\nconst ebitengineKeysTmpl = `{{.License}}\n\n{{.DoNotEdit}}\n\npackage ebiten\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\n// A Key represents a keyboard key.\n// These keys represent physical keys of US keyboard.\n// For example, KeyQ represents Q key on US keyboards and ' (quote) key on Dvorak keyboards.\ntype Key int\n\n// Keys.\nconst (\n{{range $index, $name := .EbitengineKeyNamesWithoutMods}}Key{{$name}} Key = Key(ui.Key{{$name}})\n{{end}}\tKeyAlt     Key = Key(ui.KeyReserved0)\n\tKeyControl Key = Key(ui.KeyReserved1)\n\tKeyShift   Key = Key(ui.KeyReserved2)\n\tKeyMeta    Key = Key(ui.KeyReserved3)\n\tKeyMax     Key = KeyMeta\n\n\t// Keys for backward compatibility.\n\t// Deprecated: as of v2.1.\n{{range $old, $new := .OldEbitengineKeyNameToUIKeyName}}Key{{$old}} Key = Key(ui.Key{{$new}})\n{{end}}\n)\n\nfunc (k Key) isValid() bool {\n\tswitch k {\n\t{{range $name := .EbitengineKeyNamesWithoutOld}}case Key{{$name}}:\n\t\treturn true\n\t{{end}}\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// String returns a string representing the key.\n//\n// If k is an undefined key, String returns an empty string.\nfunc (k Key) String() string {\n\tswitch k {\n\t{{range $name := .EbitengineKeyNamesWithoutOld}}case Key{{$name}}:\n\t\treturn {{$name | printf \"%q\"}}\n\t{{end}}}\n\treturn \"\"\n}\n\nfunc keyNameToKeyCode(name string) (Key, bool) {\n\tswitch strings.ToLower(name) {\n\t{{range $name := .EbitengineKeyNames}}case {{$name | printf \"%q\" | ToLower}}:\n\t\treturn Key{{$name}}, true\n\t{{end}}}\n\treturn 0, false\n}\n\n// MarshalText implements encoding.TextMarshaler.\nfunc (k Key) MarshalText() ([]byte, error) {\n\treturn []byte(k.String()), nil\n}\n\n// UnmarshalText implements encoding.TextUnmarshaler\nfunc (k *Key) UnmarshalText(text []byte) error {\n\tkey, ok := keyNameToKeyCode(string(text))\n\tif !ok {\n\t\treturn fmt.Errorf(\"ebiten: unexpected key name: %s\", string(text))\n\t}\n\t*k = key\n\treturn nil\n}\n`\n\nconst uiKeysTmpl = `{{.License}}\n\n{{.DoNotEdit}}\n\npackage ui\n\nimport (\n\t\"fmt\"\n)\n\ntype Key int\n\nconst (\n{{range $index, $name := .UIKeyNames}}Key{{$name}}{{if eq $index 0}} Key = iota{{end}}\n{{end}}\tKeyReserved0\n\tKeyReserved1\n\tKeyReserved2\n\tKeyReserved3\n\tKeyMax = KeyReserved3\n)\n\nfunc (k Key) String() string {\n\tswitch k {\n\t{{range $index, $name := .UIKeyNames}}case Key{{$name}}:\n\t\treturn {{$name | printf \"Key%s\" | printf \"%q\"}}\n\t{{end}}}\n\treturn fmt.Sprintf(\"Key(%d)\", k)\n}\n`\n\nconst eventKeysTmpl = `{{.License}}\n\n{{.DoNotEdit}}\n\npackage event\n\nimport (\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\ntype Key = ui.Key\n\nconst (\n{{range $index, $name := .UIKeyNames}}Key{{$name}} = ui.Key{{$name}}\n{{end}}\n)\n`\n\nconst uiGLFWKeysTmpl = `{{.License}}\n\n{{.DoNotEdit}}\n\n{{.BuildConstraints}}\n\npackage ui\n\nimport (\n\t\"github.com/hajimehoshi/ebiten/v2/internal/glfw\"\n)\n\nvar uiKeyToGLFWKey = map[Key]glfw.Key{\n{{range $dname, $gname := .UIKeyNameToGLFWKeyName}}Key{{$dname}}: glfw.Key{{$gname}},\n{{end}}\n}\n`\n\nconst uiJSKeysTmpl = `{{.License}}\n\n{{.DoNotEdit}}\n\n{{.BuildConstraints}}\n\npackage ui\n\nimport (\n\t\"syscall/js\"\n)\n\nvar uiKeyToJSCode = map[Key]js.Value{\n{{range $name, $code := .UIKeyNameToJSCode}}Key{{$name}}: js.ValueOf({{$code | printf \"%q\"}}),\n{{end}}\n}\n`\n\nconst glfwKeysTmpl = `{{.License}}\n\n{{.DoNotEdit}}\n\n{{.BuildConstraints}}\n\npackage glfw\n\nconst (\n{{range $name, $key := .GLFWKeyNameToGLFWKey}}Key{{$name}} = Key({{$key}})\n{{end}}\n)\n`\n\nconst mobileAndroidKeysTmpl = `{{.License}}\n\n{{.DoNotEdit}}\n\n{{.BuildConstraints}}\n\npackage ebitenmobileview\n\nimport (\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\nvar androidKeyToUIKey = map[int]ui.Key{\n{{range $key, $name := .AndroidKeyToUIKeyName}}{{$key}}: ui.Key{{$name}},\n{{end}}\n}\n`\n\nconst mobileIOSKeysTmpl = `{{.License}}\n\n{{.DoNotEdit}}\n\n{{.BuildConstraints}}\n\npackage ebitenmobileview\n\nimport (\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\nvar iosKeyToUIKey = map[int]ui.Key{\n{{range $key, $name := .IOSKeyToUIKeyName}}{{$key}}: ui.Key{{$name}},\n{{end}}\n}\n`\n\nfunc digitKey(name string) int {\n\tif len(name) != 1 {\n\t\treturn -1\n\t}\n\tc := name[0]\n\tif c < '0' || '9' < c {\n\t\treturn -1\n\t}\n\treturn int(c - '0')\n}\n\nfunc alphabetKey(name string) rune {\n\tif len(name) != 1 {\n\t\treturn -1\n\t}\n\tc := rune(name[0])\n\tif c < 'A' || 'Z' < c {\n\t\treturn -1\n\t}\n\treturn c\n}\n\nfunc functionKey(name string) int {\n\tif len(name) < 2 {\n\t\treturn -1\n\t}\n\tif name[0] != 'F' {\n\t\treturn -1\n\t}\n\ti, err := strconv.Atoi(name[1:])\n\tif err != nil {\n\t\treturn -1\n\t}\n\treturn i\n}\n\nfunc keyNamesLess(k []string) func(i, j int) bool {\n\treturn func(i, j int) bool {\n\t\tk0, k1 := k[i], k[j]\n\t\td0, d1 := digitKey(k0), digitKey(k1)\n\t\ta0, a1 := alphabetKey(k0), alphabetKey(k1)\n\t\tf0, f1 := functionKey(k0), functionKey(k1)\n\t\tif d0 != -1 {\n\t\t\tif d1 != -1 {\n\t\t\t\treturn d0 < d1\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t\tif a0 != -1 {\n\t\t\tif d1 != -1 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif a1 != -1 {\n\t\t\t\treturn a0 < a1\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t\tif d1 != -1 {\n\t\t\treturn false\n\t\t}\n\t\tif a1 != -1 {\n\t\t\treturn false\n\t\t}\n\t\tif f0 != -1 && f1 != -1 {\n\t\t\treturn f0 < f1\n\t\t}\n\t\treturn k0 < k1\n\t}\n}\n\nconst license = `// Copyright 2013 The Ebitengine Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n`\n\nfunc main() {\n\t// Follow the standard comment rule (https://pkg.go.dev/cmd/go#hdr-Generate_Go_files_by_processing_source).\n\tdoNotEdit := \"// Code generated by genkeys.go using 'go generate'. DO NOT EDIT.\"\n\n\tebitengineKeyNames := []string{}\n\tebitengineKeyNamesWithoutOld := []string{}\n\tebitengineKeyNamesWithoutMods := []string{}\n\tuiKeyNames := []string{}\n\n\tfor name := range uiKeyNameToJSCode {\n\t\tuiKeyNames = append(uiKeyNames, name)\n\t\tebitengineKeyNames = append(ebitengineKeyNames, name)\n\t\tebitengineKeyNamesWithoutOld = append(ebitengineKeyNamesWithoutOld, name)\n\t\tebitengineKeyNamesWithoutMods = append(ebitengineKeyNamesWithoutMods, name)\n\t}\n\tfor old := range oldEbitengineKeyNameToUIKeyName {\n\t\tebitengineKeyNames = append(ebitengineKeyNames, old)\n\t}\n\t// Keys for modifiers\n\tebitengineKeyNames = append(ebitengineKeyNames, \"Alt\", \"Control\", \"Shift\", \"Meta\")\n\tebitengineKeyNamesWithoutOld = append(ebitengineKeyNamesWithoutOld, \"Alt\", \"Control\", \"Shift\", \"Meta\")\n\n\tsort.Slice(ebitengineKeyNames, keyNamesLess(ebitengineKeyNames))\n\tsort.Slice(ebitengineKeyNamesWithoutOld, keyNamesLess(ebitengineKeyNamesWithoutOld))\n\tsort.Slice(ebitengineKeyNamesWithoutMods, keyNamesLess(ebitengineKeyNamesWithoutMods))\n\tsort.Slice(uiKeyNames, keyNamesLess(uiKeyNames))\n\n\t// TODO: Add this line for event package (#926).\n\t//\n\t//     filepath.Join(\"event\", \"keys.go\"):                              eventKeysTmpl,\n\n\tfor path, tmpl := range map[string]string{\n\t\tfilepath.Join(\"internal\", \"glfw\", \"keys.go\"):                   glfwKeysTmpl,\n\t\tfilepath.Join(\"internal\", \"ui\", \"keys.go\"):                     uiKeysTmpl,\n\t\tfilepath.Join(\"internal\", \"ui\", \"keys_glfw.go\"):                uiGLFWKeysTmpl,\n\t\tfilepath.Join(\"internal\", \"ui\", \"keys_js.go\"):                  uiJSKeysTmpl,\n\t\tfilepath.Join(\"keys.go\"):                                       ebitengineKeysTmpl,\n\t\tfilepath.Join(\"mobile\", \"ebitenmobileview\", \"keys_android.go\"): mobileAndroidKeysTmpl,\n\t\tfilepath.Join(\"mobile\", \"ebitenmobileview\", \"keys_ios.go\"):     mobileIOSKeysTmpl,\n\t} {\n\t\tf, err := os.Create(path)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdefer f.Close()\n\n\t\tfuncs := template.FuncMap{\n\t\t\t\"ToLower\": strings.ToLower,\n\t\t}\n\t\ttmpl, err := template.New(path).Funcs(funcs).Parse(tmpl)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\t// The build tag can't be included in the templates because of `go vet`.\n\t\t// Pass the build tag and extract this in the template to make `go vet` happy.\n\t\tbuildConstraints := \"\"\n\t\tswitch path {\n\t\tcase filepath.Join(\"internal\", \"glfw\", \"keys.go\"):\n\t\t\tbuildConstraints = \"//go:build darwin || freebsd || linux || netbsd || openbsd || windows\"\n\t\tcase filepath.Join(\"internal\", \"ui\", \"keys_mobile.go\"):\n\t\t\tbuildConstraints = \"//go:build android || ios\"\n\t\tcase filepath.Join(\"internal\", \"ui\", \"keys_glfw.go\"):\n\t\t\tbuildConstraints = \"//go:build !android && !ios && !js && !nintendosdk && !playstation5\"\n\t\t}\n\t\t// NOTE: According to godoc, maps are automatically sorted by key.\n\t\tw := bufio.NewWriter(f)\n\t\tif err := tmpl.Execute(w, struct {\n\t\t\tLicense                         string\n\t\t\tDoNotEdit                       string\n\t\t\tBuildConstraints                string\n\t\t\tUIKeyNameToJSCode               map[string]string\n\t\t\tEbitengineKeyNames              []string\n\t\t\tEbitengineKeyNamesWithoutOld    []string\n\t\t\tEbitengineKeyNamesWithoutMods   []string\n\t\t\tGLFWKeyNameToGLFWKey            map[string]int\n\t\t\tUIKeyNames                      []string\n\t\t\tUIKeyNameToGLFWKeyName          map[string]string\n\t\t\tAndroidKeyToUIKeyName           map[int]string\n\t\t\tIOSKeyToUIKeyName               map[int]string\n\t\t\tOldEbitengineKeyNameToUIKeyName map[string]string\n\t\t}{\n\t\t\tLicense:                         license,\n\t\t\tDoNotEdit:                       doNotEdit,\n\t\t\tBuildConstraints:                buildConstraints,\n\t\t\tUIKeyNameToJSCode:               uiKeyNameToJSCode,\n\t\t\tEbitengineKeyNames:              ebitengineKeyNames,\n\t\t\tEbitengineKeyNamesWithoutOld:    ebitengineKeyNamesWithoutOld,\n\t\t\tEbitengineKeyNamesWithoutMods:   ebitengineKeyNamesWithoutMods,\n\t\t\tGLFWKeyNameToGLFWKey:            glfwKeyNameToGLFWKey,\n\t\t\tUIKeyNames:                      uiKeyNames,\n\t\t\tUIKeyNameToGLFWKeyName:          uiKeyNameToGLFWKeyName,\n\t\t\tAndroidKeyToUIKeyName:           androidKeyToUIKeyName,\n\t\t\tIOSKeyToUIKeyName:               iosKeyToUIKeyName,\n\t\t\tOldEbitengineKeyNameToUIKeyName: oldEbitengineKeyNameToUIKeyName,\n\t\t}); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tif err := w.Flush(); err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "geom.go",
          "type": "blob",
          "size": 4.7744140625,
          "content": "// Copyright 2014 Hajime Hoshi\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// GeoMDim is a dimension of a GeoM.\nconst GeoMDim = 3\n\n// A GeoM represents a matrix to transform geometry when rendering an image.\n//\n// The initial value is identity.\ntype GeoM struct {\n\ta_1 float64 // The actual 'a' value minus 1\n\tb   float64\n\tc   float64\n\td_1 float64 // The actual 'd' value minus 1\n\ttx  float64\n\tty  float64\n}\n\n// String returns a string representation of GeoM.\nfunc (g *GeoM) String() string {\n\treturn fmt.Sprintf(\"[[%f, %f, %f], [%f, %f, %f]]\", g.a_1+1, g.b, g.tx, g.c, g.d_1+1, g.ty)\n}\n\n// Reset resets the GeoM as identity.\nfunc (g *GeoM) Reset() {\n\tg.a_1 = 0\n\tg.b = 0\n\tg.c = 0\n\tg.d_1 = 0\n\tg.tx = 0\n\tg.ty = 0\n}\n\n// Apply pre-multiplies a vector (x, y, 1) by the matrix.\n// In other words, Apply calculates GeoM * (x, y, 1)^T.\n// The return value is x and y values of the result vector.\nfunc (g *GeoM) Apply(x, y float64) (float64, float64) {\n\treturn (g.a_1+1)*x + g.b*y + g.tx, g.c*x + (g.d_1+1)*y + g.ty\n}\n\nfunc (g *GeoM) elements32() (a, b, c, d, tx, ty float32) {\n\treturn float32(g.a_1) + 1, float32(g.b), float32(g.c), float32(g.d_1) + 1, float32(g.tx), float32(g.ty)\n}\n\n// Element returns a value of a matrix at (i, j).\nfunc (g *GeoM) Element(i, j int) float64 {\n\tswitch {\n\tcase i == 0 && j == 0:\n\t\treturn g.a_1 + 1\n\tcase i == 0 && j == 1:\n\t\treturn g.b\n\tcase i == 0 && j == 2:\n\t\treturn g.tx\n\tcase i == 1 && j == 0:\n\t\treturn g.c\n\tcase i == 1 && j == 1:\n\t\treturn g.d_1 + 1\n\tcase i == 1 && j == 2:\n\t\treturn g.ty\n\tdefault:\n\t\tpanic(\"ebiten: i or j is out of index\")\n\t}\n}\n\n// Concat multiplies a geometry matrix with the other geometry matrix.\n// This is same as multiplying the matrix other and the matrix g in this order.\nfunc (g *GeoM) Concat(other GeoM) {\n\ta := (other.a_1+1)*(g.a_1+1) + other.b*g.c\n\tb := (other.a_1+1)*g.b + other.b*(g.d_1+1)\n\ttx := (other.a_1+1)*g.tx + other.b*g.ty + other.tx\n\tc := other.c*(g.a_1+1) + (other.d_1+1)*g.c\n\td := other.c*g.b + (other.d_1+1)*(g.d_1+1)\n\tty := other.c*g.tx + (other.d_1+1)*g.ty + other.ty\n\n\tg.a_1 = a - 1\n\tg.b = b\n\tg.c = c\n\tg.d_1 = d - 1\n\tg.tx = tx\n\tg.ty = ty\n}\n\n// Scale scales the matrix by (x, y).\nfunc (g *GeoM) Scale(x, y float64) {\n\ta := (g.a_1 + 1) * x\n\tb := g.b * x\n\ttx := g.tx * x\n\tc := g.c * y\n\td := (g.d_1 + 1) * y\n\tty := g.ty * y\n\n\tg.a_1 = a - 1\n\tg.b = b\n\tg.c = c\n\tg.d_1 = d - 1\n\tg.tx = tx\n\tg.ty = ty\n}\n\n// Translate translates the matrix by (tx, ty).\nfunc (g *GeoM) Translate(tx, ty float64) {\n\tg.tx += tx\n\tg.ty += ty\n}\n\n// Rotate rotates the matrix clockwise by theta.\n// The unit is radian.\nfunc (g *GeoM) Rotate(theta float64) {\n\tif theta == 0 {\n\t\treturn\n\t}\n\n\tsin, cos := math.Sincos(theta)\n\n\ta := cos*(g.a_1+1) - sin*g.c\n\tb := cos*g.b - sin*(g.d_1+1)\n\ttx := cos*g.tx - sin*g.ty\n\tc := sin*(g.a_1+1) + cos*g.c\n\td := sin*g.b + cos*(g.d_1+1)\n\tty := sin*g.tx + cos*g.ty\n\n\tg.a_1 = a - 1\n\tg.b = b\n\tg.c = c\n\tg.d_1 = d - 1\n\tg.tx = tx\n\tg.ty = ty\n}\n\n// Skew skews the matrix by (skewX, skewY). The unit is radian.\nfunc (g *GeoM) Skew(skewX, skewY float64) {\n\tsx := math.Tan(skewX)\n\tsy := math.Tan(skewY)\n\n\ta := (g.a_1 + 1) + g.c*sx\n\tb := g.b + (g.d_1+1)*sx\n\tc := (g.a_1+1)*sy + g.c\n\td := g.b*sy + (g.d_1 + 1)\n\ttx := g.tx + g.ty*sx\n\tty := g.ty + g.tx*sy\n\n\tg.a_1 = a - 1\n\tg.b = b\n\tg.c = c\n\tg.d_1 = d - 1\n\tg.tx = tx\n\tg.ty = ty\n}\n\nfunc (g *GeoM) det2x2() float64 {\n\treturn (g.a_1+1)*(g.d_1+1) - g.b*g.c\n}\n\n// IsInvertible returns a boolean value indicating\n// whether the matrix g is invertible or not.\nfunc (g *GeoM) IsInvertible() bool {\n\treturn g.det2x2() != 0\n}\n\n// Invert inverts the matrix.\n// If g is not invertible, Invert panics.\nfunc (g *GeoM) Invert() {\n\tdet := g.det2x2()\n\tif det == 0 {\n\t\tpanic(\"ebiten: g is not invertible\")\n\t}\n\n\ta := (g.d_1 + 1) / det\n\tb := -g.b / det\n\tc := -g.c / det\n\td := (g.a_1 + 1) / det\n\ttx := (-(g.d_1+1)*g.tx + g.b*g.ty) / det\n\tty := (g.c*g.tx + -(g.a_1+1)*g.ty) / det\n\n\tg.a_1 = a - 1\n\tg.b = b\n\tg.c = c\n\tg.d_1 = d - 1\n\tg.tx = tx\n\tg.ty = ty\n}\n\n// SetElement sets an element at (i, j).\nfunc (g *GeoM) SetElement(i, j int, element float64) {\n\te := element\n\tswitch {\n\tcase i == 0 && j == 0:\n\t\tg.a_1 = e - 1\n\tcase i == 0 && j == 1:\n\t\tg.b = e\n\tcase i == 0 && j == 2:\n\t\tg.tx = e\n\tcase i == 1 && j == 0:\n\t\tg.c = e\n\tcase i == 1 && j == 1:\n\t\tg.d_1 = e - 1\n\tcase i == 1 && j == 2:\n\t\tg.ty = e\n\tdefault:\n\t\tpanic(\"ebiten: i or j is out of index\")\n\t}\n}\n"
        },
        {
          "name": "geom_test.go",
          "type": "blob",
          "size": 7.462890625,
          "content": "// Copyright 2014 Hajime Hoshi\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten_test\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/hajimehoshi/ebiten/v2\"\n)\n\nfunc TestGeoMInit(t *testing.T) {\n\tvar m ebiten.GeoM\n\tfor i := 0; i < ebiten.GeoMDim-1; i++ {\n\t\tfor j := 0; j < ebiten.GeoMDim; j++ {\n\t\t\tgot := m.Element(i, j)\n\t\t\twant := 0.0\n\t\t\tif i == j {\n\t\t\t\twant = 1\n\t\t\t}\n\t\t\tif want != got {\n\t\t\t\tt.Errorf(\"m.Element(%d, %d) = %f, want %f\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestGeoMAssign(t *testing.T) {\n\tm := ebiten.GeoM{}\n\tm.SetElement(0, 0, 1)\n\tm2 := m\n\tm.SetElement(0, 0, 0)\n\tgot := m2.Element(0, 0)\n\twant := 1.0\n\tif want != got {\n\t\tt.Errorf(\"m2.Element(%d, %d) = %f, want %f\", 0, 0, got, want)\n\t}\n}\n\nfunc TestGeoMConcat(t *testing.T) {\n\tmatrix1 := ebiten.GeoM{}\n\tmatrix1.Scale(2, 2)\n\tmatrix2 := ebiten.GeoM{}\n\tmatrix2.Translate(1, 1)\n\n\tmatrix3 := matrix1\n\tmatrix3.Concat(matrix2)\n\texpected := [][]float64{\n\t\t{2, 0, 1},\n\t\t{0, 2, 1},\n\t}\n\tfor i := 0; i < 2; i++ {\n\t\tfor j := 0; j < 3; j++ {\n\t\t\tgot := matrix3.Element(i, j)\n\t\t\twant := expected[i][j]\n\t\t\tif want != got {\n\t\t\t\tt.Errorf(\"matrix3.Element(%d, %d) = %f,\"+\n\t\t\t\t\t\" want %f\",\n\t\t\t\t\ti, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\tmatrix4 := matrix2\n\tmatrix4.Concat(matrix1)\n\texpected = [][]float64{\n\t\t{2, 0, 2},\n\t\t{0, 2, 2},\n\t}\n\tfor i := 0; i < 2; i++ {\n\t\tfor j := 0; j < 3; j++ {\n\t\t\tgot := matrix4.Element(i, j)\n\t\t\twant := expected[i][j]\n\t\t\tif want != got {\n\t\t\t\tt.Errorf(\"matrix4.Element(%d, %d) = %f, want %f\",\n\t\t\t\t\ti, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestGeoMConcatSelf(t *testing.T) {\n\tm := ebiten.GeoM{}\n\tm.SetElement(0, 0, 1)\n\tm.SetElement(0, 1, 2)\n\tm.SetElement(0, 2, 3)\n\tm.SetElement(1, 0, 4)\n\tm.SetElement(1, 1, 5)\n\tm.SetElement(1, 2, 6)\n\tm.Concat(m)\n\texpected := [][]float64{\n\t\t{9, 12, 18},\n\t\t{24, 33, 48},\n\t}\n\tfor i := 0; i < 2; i++ {\n\t\tfor j := 0; j < 3; j++ {\n\t\t\tgot := m.Element(i, j)\n\t\t\twant := expected[i][j]\n\t\t\tif want != got {\n\t\t\t\tt.Errorf(\"m.Element(%d, %d) = %f, want %f\",\n\t\t\t\t\ti, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc geoMToString(g ebiten.GeoM) string {\n\ta := g.Element(0, 0)\n\tb := g.Element(0, 1)\n\tc := g.Element(1, 0)\n\td := g.Element(1, 1)\n\ttx := g.Element(0, 2)\n\tty := g.Element(1, 2)\n\treturn fmt.Sprintf(\"{a: %f, b: %f, c: %f, d: %f, tx: %f, ty: %f}\", a, b, c, d, tx, ty)\n}\n\nfunc TestGeoMApply(t *testing.T) {\n\ttrans := ebiten.GeoM{}\n\ttrans.Translate(1, 2)\n\n\tscale := ebiten.GeoM{}\n\tscale.Scale(1.5, 2.5)\n\n\tcpx := ebiten.GeoM{}\n\tcpx.Rotate(math.Pi)\n\tcpx.Scale(1.5, 2.5)\n\tcpx.Translate(-2, -3)\n\n\tcases := []struct {\n\t\tGeoM ebiten.GeoM\n\t\tInX  float64\n\t\tInY  float64\n\t\tOutX float64\n\t\tOutY float64\n\t}{\n\t\t{\n\t\t\tGeoM: ebiten.GeoM{},\n\t\t\tInX:  3.14159,\n\t\t\tInY:  2.81828,\n\t\t\tOutX: 3.14159,\n\t\t\tOutY: 2.81828,\n\t\t},\n\t\t{\n\t\t\tGeoM: trans,\n\t\t\tInX:  3.14159,\n\t\t\tInY:  2.81828,\n\t\t\tOutX: 4.14159,\n\t\t\tOutY: 4.81828,\n\t\t},\n\t\t{\n\t\t\tGeoM: scale,\n\t\t\tInX:  3.14159,\n\t\t\tInY:  2.81828,\n\t\t\tOutX: 4.71239,\n\t\t\tOutY: 7.04570,\n\t\t},\n\t\t{\n\t\t\tGeoM: cpx,\n\t\t\tInX:  3.14159,\n\t\t\tInY:  2.81828,\n\t\t\tOutX: -6.71239,\n\t\t\tOutY: -10.04570,\n\t\t},\n\t}\n\n\tconst delta = 0.00001\n\n\tfor _, c := range cases {\n\t\trx, ry := c.GeoM.Apply(c.InX, c.InY)\n\t\tif math.Abs(rx-c.OutX) > delta || math.Abs(ry-c.OutY) > delta {\n\t\t\tt.Errorf(\"%s.Apply(%f, %f) = (%f, %f), want (%f, %f)\", geoMToString(c.GeoM), c.InX, c.InY, rx, ry, c.OutX, c.OutY)\n\t\t}\n\t}\n}\n\nfunc TestGeoMIsInvert(t *testing.T) {\n\tzero := ebiten.GeoM{}\n\tzero.Scale(0, 0)\n\n\ttrans := ebiten.GeoM{}\n\ttrans.Translate(1, 2)\n\n\tscale := ebiten.GeoM{}\n\tscale.Scale(1.5, 2.5)\n\n\tcpx := ebiten.GeoM{}\n\tcpx.Rotate(math.Pi)\n\tcpx.Scale(1.5, 2.5)\n\tcpx.Translate(-2, -3)\n\n\tcpx2 := ebiten.GeoM{}\n\tcpx2.Scale(2, 3)\n\tcpx2.Rotate(0.234)\n\tcpx2.Translate(100, 100)\n\n\tskew := ebiten.GeoM{}\n\tskew.Skew(1, 1)\n\n\tcases := []struct {\n\t\tGeoM       ebiten.GeoM\n\t\tInvertible bool\n\t}{\n\t\t{\n\t\t\tGeoM:       zero,\n\t\t\tInvertible: false,\n\t\t},\n\t\t{\n\t\t\tGeoM:       ebiten.GeoM{},\n\t\t\tInvertible: true,\n\t\t},\n\t\t{\n\t\t\tGeoM:       trans,\n\t\t\tInvertible: true,\n\t\t},\n\t\t{\n\t\t\tGeoM:       scale,\n\t\t\tInvertible: true,\n\t\t},\n\t\t{\n\t\t\tGeoM:       cpx,\n\t\t\tInvertible: true,\n\t\t},\n\t\t{\n\t\t\tGeoM:       cpx2,\n\t\t\tInvertible: true,\n\t\t},\n\t\t{\n\t\t\tGeoM:       skew,\n\t\t\tInvertible: true,\n\t\t},\n\t}\n\n\tpts := []struct {\n\t\tX float64\n\t\tY float64\n\t}{\n\t\t{\n\t\t\tX: 0,\n\t\t\tY: 0,\n\t\t},\n\t\t{\n\t\t\tX: 1,\n\t\t\tY: 1,\n\t\t},\n\t\t{\n\t\t\tX: 3.14159,\n\t\t\tY: 2.81828,\n\t\t},\n\t\t{\n\t\t\tX: -1000,\n\t\t\tY: 1000,\n\t\t},\n\t}\n\n\tconst delta = 0.001\n\n\tfor _, c := range cases {\n\t\tif c.GeoM.IsInvertible() != c.Invertible {\n\t\t\tt.Errorf(\"%s.IsInvertible(): got: %t, want: %t\", geoMToString(c.GeoM), c.GeoM.IsInvertible(), c.Invertible)\n\t\t}\n\t\tif !c.GeoM.IsInvertible() {\n\t\t\tcontinue\n\t\t}\n\t\tinvGeoM := c.GeoM\n\t\tinvGeoM.Invert()\n\t\tfor _, p := range pts {\n\t\t\tx, y := p.X, p.Y\n\t\t\tgotX, gotY := invGeoM.Apply(c.GeoM.Apply(x, y))\n\t\t\tif math.Abs(gotX-x) > delta || math.Abs(gotY-y) > delta {\n\t\t\t\tt.Errorf(\"%s.Apply(%s.Apply(%f, %f)): got: (%f, %f), want: (%f, %f)\", geoMToString(invGeoM), geoMToString(c.GeoM), x, y, gotX, gotY, x, y)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc newGeoM(a, b, c, d, tx, ty float64) ebiten.GeoM {\n\toutp := ebiten.GeoM{}\n\toutp.SetElement(0, 0, a)\n\toutp.SetElement(0, 1, b)\n\toutp.SetElement(0, 2, tx)\n\toutp.SetElement(1, 0, c)\n\toutp.SetElement(1, 1, d)\n\toutp.SetElement(1, 2, ty)\n\treturn outp\n}\n\nfunc TestGeomSkew(t *testing.T) {\n\ttestSkew := func(skewX, skewY float64, input, expected ebiten.GeoM) {\n\t\tinput.Skew(skewX, skewY)\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tfor j := 0; j < 3; j++ {\n\t\t\t\tgot := input.Element(i, j)\n\t\t\t\twant := expected.Element(i, j)\n\t\t\t\tif want != got {\n\t\t\t\t\tt.Errorf(\"Skew(%f, %f): got %s, want: %s\", skewX, skewY, input.String(), expected.String())\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// skewX = 0.25\n\texpectedX := newGeoM(1, math.Tan(0.25), math.Tan(0), 1, 0, 0)\n\ttestSkew(0.25, 0, ebiten.GeoM{}, expectedX)\n\n\t// skewY = 0.25\n\texpectedY := newGeoM(1, math.Tan(0), math.Tan(0.5), 1, 0, 0)\n\ttestSkew(0, 0.5, ebiten.GeoM{}, expectedY)\n\n\t// skewX, skewY = 0.3, 0.8\n\texpectedXY := newGeoM(1, math.Tan(0.3), math.Tan(0.8), 1, 0, 0)\n\ttestSkew(0.3, 0.8, ebiten.GeoM{}, expectedXY)\n\n\t// skewX, skewY = 0.4, -1.8 ; b, c = 2, 3\n\texpectedOffDiag := newGeoM(1+3*math.Tan(0.4), 2+math.Tan(0.4), 3+math.Tan(-1.8), 1+2*math.Tan(-1.8), 0, 0)\n\tinputOffDiag := newGeoM(1, 2, 3, 1, 0, 0)\n\ttestSkew(0.4, -1.8, inputOffDiag, expectedOffDiag)\n\n\t// skewX, skewY = -1.5, 1.5 ; tx, ty = 5, 6\n\texpectedTrn := newGeoM(1, math.Tan(-1.5), math.Tan(1.5), 1, 5+math.Tan(-1.5)*6, 6+5*math.Tan(1.5))\n\tinputTrn := newGeoM(1, 0, 0, 1, 5, 6)\n\ttestSkew(-1.5, 1.5, inputTrn, expectedTrn)\n}\n\nfunc TestGeoMEquals(t *testing.T) {\n\ttests := []struct {\n\t\ta    ebiten.GeoM\n\t\tb    ebiten.GeoM\n\t\twant bool\n\t}{\n\t\t{\n\t\t\ta:    ebiten.GeoM{},\n\t\t\tb:    ebiten.GeoM{},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\ta:    newGeoM(3, 1, 4, 1, 5, 9),\n\t\t\tb:    newGeoM(3, 1, 4, 1, 5, 9),\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\ta:    newGeoM(3, 1, 4, 1, 5, 9),\n\t\t\tb:    newGeoM(3, 1, 4, 1, 5, 10),\n\t\t\twant: false,\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tgot := (test.a == test.b)\n\t\twant := test.want\n\t\tif got != want {\n\t\t\tt.Errorf(\"%#v == %#v: got %t, want: %t\", test.a, test.b, got, want)\n\t\t}\n\t}\n}\n\nfunc BenchmarkGeoM(b *testing.B) {\n\tvar m ebiten.GeoM\n\tfor i := 0; i < b.N; i++ {\n\t\tm = ebiten.GeoM{}\n\t\tm.Translate(10, 20)\n\t\tm.Scale(2, 3)\n\t\tm.Rotate(math.Pi / 2)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.859375,
          "content": "module github.com/hajimehoshi/ebiten/v2\n\ngo 1.22.0\n\nrequire (\n\tgithub.com/ebitengine/gomobile v0.0.0-20241016134836-cc2e38a7c0ee\n\tgithub.com/ebitengine/hideconsole v1.0.0\n\tgithub.com/ebitengine/oto/v3 v3.4.0-alpha.3\n\tgithub.com/ebitengine/purego v0.9.0-alpha.2\n\tgithub.com/gen2brain/mpeg v0.3.2-0.20240412154320-a2ac4fc8a46f\n\tgithub.com/go-text/typesetting v0.2.1\n\tgithub.com/hajimehoshi/bitmapfont/v3 v3.3.0-alpha.3\n\tgithub.com/hajimehoshi/go-mp3 v0.3.4\n\tgithub.com/jakecoffman/cp/v2 v2.1.0\n\tgithub.com/jezek/xgb v1.1.1\n\tgithub.com/jfreymuth/oggvorbis v1.0.5\n\tgithub.com/kisielk/errcheck v1.8.0\n\tgolang.org/x/image v0.23.0\n\tgolang.org/x/sync v0.10.0\n\tgolang.org/x/sys v0.28.0\n\tgolang.org/x/text v0.21.0\n\tgolang.org/x/tools v0.28.0\n)\n\nrequire (\n\tgithub.com/jfreymuth/vorbis v1.0.2 // indirect\n\tgithub.com/pierrec/lz4/v4 v4.1.21 // indirect\n\tgolang.org/x/mod v0.22.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 9.6103515625,
          "content": "github.com/ebitengine/gomobile v0.0.0-20241016134836-cc2e38a7c0ee h1:YoNt0DHeZ92kjR78SfyUn1yEf7KnBypOFlFZO14cJ6w=\ngithub.com/ebitengine/gomobile v0.0.0-20241016134836-cc2e38a7c0ee/go.mod h1:ZDIonJlTRW7gahIn5dEXZtN4cM8Qwtlduob8cOCflmg=\ngithub.com/ebitengine/hideconsole v1.0.0 h1:5J4U0kXF+pv/DhiXt5/lTz0eO5ogJ1iXb8Yj1yReDqE=\ngithub.com/ebitengine/hideconsole v1.0.0/go.mod h1:hTTBTvVYWKBuxPr7peweneWdkUwEuHuB3C1R/ielR1A=\ngithub.com/ebitengine/oto/v3 v3.4.0-alpha.3 h1:YLGviaYemmn7ERSHxWUbSbLu8eHq6S8zK+MiyRR5JtU=\ngithub.com/ebitengine/oto/v3 v3.4.0-alpha.3/go.mod h1:lCbB4e7VuXj9RDu/K4Kz5jY4NRVV5L/QRar+CcVKKlc=\ngithub.com/ebitengine/purego v0.9.0-alpha.2 h1:xYomvayNWeTy1RInkqKOqKdO+5afaejWQ4+RCN+B7do=\ngithub.com/ebitengine/purego v0.9.0-alpha.2/go.mod h1:iIjxzd6CiRiOG0UyXP+V1+jWqUXVjPKLAI0mRfJZTmQ=\ngithub.com/gen2brain/mpeg v0.3.2-0.20240412154320-a2ac4fc8a46f h1:ysqRe+lvUiL0dH5XzkH0Bz68bFMPJ4f5Si4L/HD9SGk=\ngithub.com/gen2brain/mpeg v0.3.2-0.20240412154320-a2ac4fc8a46f/go.mod h1:i/ebyRRv/IoHixuZ9bElZnXbmfoUVPGQpdsJ4sVuX38=\ngithub.com/go-text/typesetting v0.2.1 h1:x0jMOGyO3d1qFAPI0j4GSsh7M0Q3Ypjzr4+CEVg82V8=\ngithub.com/go-text/typesetting v0.2.1/go.mod h1:mTOxEwasOFpAMBjEQDhdWRckoLLeI/+qrQeBCTGEt6M=\ngithub.com/go-text/typesetting-utils v0.0.0-20241103174707-87a29e9e6066 h1:qCuYC+94v2xrb1PoS4NIDe7DGYtLnU2wWiQe9a1B1c0=\ngithub.com/go-text/typesetting-utils v0.0.0-20241103174707-87a29e9e6066/go.mod h1:DDxDdQEnB70R8owOx3LVpEFvpMK9eeH1o2r0yZhFI9o=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/hajimehoshi/bitmapfont/v3 v3.3.0-alpha.3 h1:i6ZtnDWFfEo0oPou30PA5Uh7KpwG6i1raPVM8uMelSI=\ngithub.com/hajimehoshi/bitmapfont/v3 v3.3.0-alpha.3/go.mod h1:GsEgTraq3r5Z8JuWS3gjeCnC81cVeJd4Cojw3OSJkrg=\ngithub.com/hajimehoshi/go-mp3 v0.3.4 h1:NUP7pBYH8OguP4diaTZ9wJbUbk3tC0KlfzsEpWmYj68=\ngithub.com/hajimehoshi/go-mp3 v0.3.4/go.mod h1:fRtZraRFcWb0pu7ok0LqyFhCUrPeMsGRSVop0eemFmo=\ngithub.com/hajimehoshi/oto/v2 v2.3.1/go.mod h1:seWLbgHH7AyUMYKfKYT9pg7PhUu9/SisyJvNTT+ASQo=\ngithub.com/jakecoffman/cp/v2 v2.1.0 h1:s0almZ7zDZs9JY35ciUgCoVKTMmdPkokF1dxHg226Wo=\ngithub.com/jakecoffman/cp/v2 v2.1.0/go.mod h1:Q0hFU7Kk6PMw4dwgFtvBC6O4KTm7ewiLuHrXtHMicyU=\ngithub.com/jezek/xgb v1.1.1 h1:bE/r8ZZtSv7l9gk6nU0mYx51aXrvnyb44892TwSaqS4=\ngithub.com/jezek/xgb v1.1.1/go.mod h1:nrhwO0FX/enq75I7Y7G8iN1ubpSGZEiA3v9e9GyRFlk=\ngithub.com/jfreymuth/oggvorbis v1.0.5 h1:u+Ck+R0eLSRhgq8WTmffYnrVtSztJcYrl588DM4e3kQ=\ngithub.com/jfreymuth/oggvorbis v1.0.5/go.mod h1:1U4pqWmghcoVsCJJ4fRBKv9peUJMBHixthRlBeD6uII=\ngithub.com/jfreymuth/vorbis v1.0.2 h1:m1xH6+ZI4thH927pgKD8JOH4eaGRm18rEE9/0WKjvNE=\ngithub.com/jfreymuth/vorbis v1.0.2/go.mod h1:DoftRo4AznKnShRl1GxiTFCseHr4zR9BN3TWXyuzrqQ=\ngithub.com/kisielk/errcheck v1.8.0 h1:ZX/URYa7ilESY19ik/vBmCn6zdGQLxACwjAcWbHlYlg=\ngithub.com/kisielk/errcheck v1.8.0/go.mod h1:1kLL+jV4e+CFfueBmI1dSK2ADDyQnlrnrY/FqKluHJQ=\ngithub.com/pierrec/lz4/v4 v4.1.21 h1:yOVMLb6qSIDP67pl/5F7RepeKYu/VmTyEXvuMI5d9mQ=\ngithub.com/pierrec/lz4/v4 v4.1.21/go.mod h1:gZWDp/Ze/IJXGXf23ltt2EXimqmTUXEy0GFuRQyBid4=\ngithub.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c/go.mod h1:7rwL4CYBLnjLxUqIJNnCWiEdr3bn6IUYi15bNlnbCCU=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=\ngolang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=\ngolang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=\ngolang.org/x/image v0.22.0/go.mod h1:9hPFhljd4zZ1GNSIZJ49sqbp45GKK9t6w+iXvGqZUz4=\ngolang.org/x/image v0.23.0 h1:HseQ7c2OpPKTPVzNjG5fwJsOTCiiwS4QdsYi5XU6H68=\ngolang.org/x/image v0.23.0/go.mod h1:wJJBTdLfCCf3tiHa1fNxpZmUI4mmoZvwMCPP0ddoNKY=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.15.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/mod v0.22.0 h1:D4nJWe9zXqHOmWqj4VMOJhvzj7bEZg4wEYa759z1pH4=\ngolang.org/x/mod v0.22.0/go.mod h1:6SkKJ3Xj0I0BrPOZoBy3bdMptDDU9oJrpohJ3eWZ1fY=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=\ngolang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=\ngolang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=\ngolang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.9.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220712014510-0a85c31ab51e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/telemetry v0.0.0-20240228155512-f48c80bd79b2/go.mod h1:TeRTkGYfJXctD9OcfyVLyj2J3IxLnKwHJR8f4D8a3YE=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\ngolang.org/x/term v0.12.0/go.mod h1:owVbMEjm3cBLCHdkQu9b1opXd4ETQWc3BhuQGKgXgvU=\ngolang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\ngolang.org/x/term v0.20.0/go.mod h1:8UkIAJTvZgivsXaD6/pH6U9ecQzZ45awqEOzuCvwpFY=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.20.0/go.mod h1:D4IsuqiFMhST5bX19pQ9ikHC2GsaKyk/oF+pn3ducp4=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=\ngolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=\ngolang.org/x/tools v0.28.0 h1:WuB6qZ4RPCQo5aP3WdKZS7i595EdWqWR8vqJTlwTVK8=\ngolang.org/x/tools v0.28.0/go.mod h1:dcIOrVd3mfQKTgrDVQHqCPMWy6lnhfhtX3hLXYVLfRw=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n"
        },
        {
          "name": "graphics.go",
          "type": "blob",
          "size": 3.2109375,
          "content": "// Copyright 2014 Hajime Hoshi\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"github.com/hajimehoshi/ebiten/v2/internal/builtinshader\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\n// Filter represents the type of texture filter to be used when an image is magnified or minified.\ntype Filter int\n\nconst (\n\t// FilterNearest represents nearest (crisp-edged) filter\n\tFilterNearest Filter = Filter(builtinshader.FilterNearest)\n\n\t// FilterLinear represents linear filter\n\tFilterLinear Filter = Filter(builtinshader.FilterLinear)\n)\n\n// GraphicsLibrary represents graphics libraries supported by the engine.\ntype GraphicsLibrary int\n\nconst (\n\t// GraphicsLibraryAuto represents the automatic choose of graphics library by Ebitengine.\n\tGraphicsLibraryAuto GraphicsLibrary = GraphicsLibrary(ui.GraphicsLibraryAuto)\n\n\t// GraphicsLibraryUnknown represents the state at which graphics library cannot be determined,\n\t// e.g. hasn't loaded yet or failed to initialize.\n\tGraphicsLibraryUnknown GraphicsLibrary = GraphicsLibrary(ui.GraphicsLibraryUnknown)\n\n\t// GraphicsLibraryOpenGL represents the graphics library OpenGL.\n\tGraphicsLibraryOpenGL GraphicsLibrary = GraphicsLibrary(ui.GraphicsLibraryOpenGL)\n\n\t// GraphicsLibraryDirectX represents the graphics library Microsoft DirectX.\n\tGraphicsLibraryDirectX GraphicsLibrary = GraphicsLibrary(ui.GraphicsLibraryDirectX)\n\n\t// GraphicsLibraryMetal represents the graphics library Apple's Metal.\n\tGraphicsLibraryMetal GraphicsLibrary = GraphicsLibrary(ui.GraphicsLibraryMetal)\n\n\t// GraphicsLibraryMetal represents the graphics library PlayStation 5.\n\tGraphicsLibraryPlayStation5 GraphicsLibrary = GraphicsLibrary(ui.GraphicsLibraryPlayStation5)\n)\n\n// String returns a string representing the graphics library.\nfunc (g GraphicsLibrary) String() string {\n\treturn ui.GraphicsLibrary(g).String()\n}\n\n// Ensures GraphicsLibraryAuto is zero (the default value for RunOptions).\nvar _ [GraphicsLibraryAuto]int = [0]int{}\n\n// DebugInfo is a struct to store debug info about the graphics.\ntype DebugInfo struct {\n\t// GraphicsLibrary represents the graphics library currently in use.\n\tGraphicsLibrary GraphicsLibrary\n}\n\n// ReadDebugInfo writes debug info (e.g. current graphics library) into a provided struct.\nfunc ReadDebugInfo(d *DebugInfo) {\n\td.GraphicsLibrary = GraphicsLibrary(ui.Get().GraphicsLibrary())\n}\n\n// ColorSpace represents the color space of the screen.\ntype ColorSpace int\n\nconst (\n\t// ColorSpaceDefault represents the default color space.\n\tColorSpaceDefault ColorSpace = iota\n\n\t// ColorSpaceSRGB represents the sRGB color space (https://en.wikipedia.org/wiki/SRGB).\n\tColorSpaceSRGB\n\n\t// ColorSpaceDisplayP3 represents the Display P3 color space (https://en.wikipedia.org/wiki/DCI-P3).\n\tColorSpaceDisplayP3\n)\n"
        },
        {
          "name": "image.go",
          "type": "blob",
          "size": 48.109375,
          "content": "// Copyright 2014 Hajime Hoshi\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\t\"math\"\n\t\"unsafe\"\n\n\t\"github.com/hajimehoshi/ebiten/v2/internal/affine\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/atlas\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/builtinshader\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/graphics\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/graphicscommand\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/graphicsdriver\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/restorable\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/shaderir\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\n// Image represents a rectangle set of pixels.\n// The pixel format is alpha-premultiplied RGBA.\n// Image implements the standard image.Image and draw.Image interfaces.\ntype Image struct {\n\t// addr holds self to check copying.\n\t// See strings.Builder for similar examples.\n\taddr     *Image\n\timage    *ui.Image\n\toriginal *Image\n\tbounds   image.Rectangle\n\n\t// tmpVertices must not be reused until ui.Image.Draw* is called.\n\ttmpVertices []float32\n\n\t// tmpIndices must not be reused until ui.Image.Draw* is called.\n\ttmpIndices []uint32\n\n\t// tmpUniforms must not be reused until ui.Image.Draw* is called.\n\ttmpUniforms []uint32\n\n\t// Do not add a 'buffering' member that are resolved lazily.\n\t// This tends to forget resolving the buffer easily (#2362).\n}\n\nfunc (i *Image) copyCheck() {\n\tif i.addr != i {\n\t\tpanic(\"ebiten: illegal use of non-zero Image copied by value\")\n\t}\n}\n\n// Size returns the size of the image.\n//\n// Deprecated: as of v2.5. Use Bounds().Dx() and Bounds().Dy() or Bounds().Size() instead.\nfunc (i *Image) Size() (width, height int) {\n\ts := i.Bounds().Size()\n\treturn s.X, s.Y\n}\n\nfunc (i *Image) isDisposed() bool {\n\treturn i.image == nil\n}\n\nfunc (i *Image) isSubImage() bool {\n\treturn i.original != nil\n}\n\n// Clear resets the pixels of the image into 0.\n//\n// When the image is disposed, Clear does nothing.\nfunc (i *Image) Clear() {\n\ti.Fill(color.Transparent)\n}\n\n// Fill fills the image with a solid color.\n//\n// When the image is disposed, Fill does nothing.\nfunc (i *Image) Fill(clr color.Color) {\n\ti.copyCheck()\n\tif i.isDisposed() {\n\t\treturn\n\t}\n\n\tvar crf, cgf, cbf, caf float32\n\tcr, cg, cb, ca := clr.RGBA()\n\tcrf = float32(cr) / 0xffff\n\tcgf = float32(cg) / 0xffff\n\tcbf = float32(cb) / 0xffff\n\tcaf = float32(ca) / 0xffff\n\ti.image.Fill(crf, cgf, cbf, caf, i.adjustedBounds())\n}\n\nfunc canSkipMipmap(det float32, filter builtinshader.Filter) bool {\n\tif filter != builtinshader.FilterLinear {\n\t\treturn true\n\t}\n\treturn math.Abs(float64(det)) >= 0.999\n}\n\n// DrawImageOptions represents options for DrawImage.\ntype DrawImageOptions struct {\n\t// GeoM is a geometry matrix to draw.\n\t// The default (zero) value is identity, which draws the image at (0, 0).\n\tGeoM GeoM\n\n\t// ColorScale is a scale of color.\n\t//\n\t// ColorScale is slightly different from colorm.ColorM's Scale in terms of alphas.\n\t// ColorScale is applied to premultiplied-alpha colors, while colorm.ColorM is applied to straight-alpha colors.\n\t// Thus, ColorM.Scale(r, g, b, a) equals to ColorScale.Scale(r*a, g*a, b*a, a).\n\t//\n\t// The default (zero) value is identity, which is (1, 1, 1, 1).\n\tColorScale ColorScale\n\n\t// ColorM is a color matrix to draw.\n\t// The default (zero) value is identity, which doesn't change any color.\n\t//\n\t// Deprecated: as of v2.5. Use ColorScale or the package colorm instead.\n\tColorM ColorM\n\n\t// CompositeMode is a composite mode to draw.\n\t// The default (zero) value is CompositeModeCustom (Blend is used).\n\t//\n\t// Deprecated: as of v2.5. Use Blend instead.\n\tCompositeMode CompositeMode\n\n\t// Blend is a blending way of the source color and the destination color.\n\t// Blend is used only when CompositeMode is CompositeModeCustom.\n\t// The default (zero) value is the regular alpha blending.\n\tBlend Blend\n\n\t// Filter is a type of texture filter.\n\t// The default (zero) value is FilterNearest.\n\tFilter Filter\n\n\t// DisableMipmaps disables mipmaps.\n\t// When Filter is FilterLinear and GeoM shrinks the image, mipmaps are used by default.\n\t// Mipmap is useful to render a shrunk image with high quality.\n\t// However, mipmaps can be expensive, especially on mobiles.\n\t// When DisableMipmaps is true, mipmap is not used.\n\t// When Filter is not FilterLinear, DisableMipmaps is ignored.\n\t//\n\t// The default (zero) value is false.\n\tDisableMipmaps bool\n}\n\n// adjustPosition converts the position in the *ebiten.Image coordinate to the *ui.Image coordinate.\nfunc (i *Image) adjustPosition(x, y int) (int, int) {\n\tif i.isSubImage() {\n\t\tor := i.original.Bounds()\n\t\tx -= or.Min.X\n\t\ty -= or.Min.Y\n\t\treturn x, y\n\t}\n\n\tr := i.Bounds()\n\tx -= r.Min.X\n\ty -= r.Min.Y\n\treturn x, y\n}\n\n// adjustPositionF32 converts the position in the *ebiten.Image coordinate to the *ui.Image coordinate.\nfunc (i *Image) adjustPositionF32(x, y float32) (float32, float32) {\n\tif i.isSubImage() {\n\t\tor := i.original.Bounds()\n\t\tx -= float32(or.Min.X)\n\t\ty -= float32(or.Min.Y)\n\t\treturn x, y\n\t}\n\n\tr := i.Bounds()\n\tx -= float32(r.Min.X)\n\ty -= float32(r.Min.Y)\n\treturn x, y\n}\n\nfunc (i *Image) adjustedBounds() image.Rectangle {\n\tb := i.Bounds()\n\tx, y := i.adjustPosition(b.Min.X, b.Min.Y)\n\treturn image.Rect(x, y, x+b.Dx(), y+b.Dy())\n}\n\n// DrawImage draws the given image on the image i.\n//\n// DrawImage accepts the options. For details, see the document of\n// DrawImageOptions.\n//\n// For drawing, the pixels of the argument image at the time of this call is\n// adopted. Even if the argument image is mutated after this call, the drawing\n// result is never affected.\n//\n// When the image i is disposed, DrawImage does nothing.\n// When the given image img is disposed, DrawImage panics.\n//\n// When the given image is as same as i, DrawImage panics.\n//\n// DrawImage works more efficiently as batches\n// when the successive calls of DrawImages satisfy the below conditions:\n//\n//   - All render targets are the same (A in A.DrawImage(B, op))\n//   - All Blend values are the same\n//   - All Filter values are the same\n//\n// A whole image and its sub-image are considered to be the same, but some\n// environments like browsers might not work efficiently (#2471).\n//\n// Even when all the above conditions are satisfied, multiple draw commands can\n// be used in really rare cases. Ebitengine images usually share an internal\n// automatic texture atlas, but when you consume the atlas, or you create a huge\n// image, those images cannot be on the same texture atlas. In this case, draw\n// commands are separated.\n// Another case is when you use an offscreen as a render source. An offscreen\n// doesn't share the texture atlas with high probability.\n//\n// For more performance tips, see https://ebitengine.org/en/documents/performancetips.html\nfunc (i *Image) DrawImage(img *Image, options *DrawImageOptions) {\n\ti.copyCheck()\n\n\tif img.isDisposed() {\n\t\tpanic(\"ebiten: the given image to DrawImage must not be disposed\")\n\t}\n\tif i.isDisposed() {\n\t\treturn\n\t}\n\n\tif options == nil {\n\t\toptions = &DrawImageOptions{}\n\t}\n\n\tvar blend graphicsdriver.Blend\n\tif options.CompositeMode == CompositeModeCustom {\n\t\tblend = options.Blend.internalBlend()\n\t} else {\n\t\tblend = options.CompositeMode.blend().internalBlend()\n\t}\n\tfilter := builtinshader.Filter(options.Filter)\n\n\tgeoM := options.GeoM\n\tif offsetX, offsetY := i.adjustPosition(0, 0); offsetX != 0 || offsetY != 0 {\n\t\tgeoM.Translate(float64(offsetX), float64(offsetY))\n\t}\n\ta, b, c, d, tx, ty := geoM.elements32()\n\tdet := a*d - b*c\n\tif det == 0 {\n\t\treturn\n\t}\n\n\tbounds := img.Bounds()\n\tsx0, sy0 := img.adjustPosition(bounds.Min.X, bounds.Min.Y)\n\tsx1, sy1 := img.adjustPosition(bounds.Max.X, bounds.Max.Y)\n\tcolorm, cr, cg, cb, ca := colorMToScale(options.ColorM.affineColorM())\n\tcr, cg, cb, ca = options.ColorScale.apply(cr, cg, cb, ca)\n\tvs := i.ensureTmpVertices(4 * graphics.VertexFloatCount)\n\tgraphics.QuadVerticesFromSrcAndMatrix(vs, float32(sx0), float32(sy0), float32(sx1), float32(sy1), a, b, c, d, tx, ty, cr, cg, cb, ca)\n\tis := graphics.QuadIndices()\n\n\tsrcs := [graphics.ShaderSrcImageCount]*ui.Image{img.image}\n\n\tuseColorM := !colorm.IsIdentity()\n\tshader := builtinShader(filter, builtinshader.AddressUnsafe, useColorM)\n\ti.tmpUniforms = i.tmpUniforms[:0]\n\tif useColorM {\n\t\tvar body [16]float32\n\t\tvar translation [4]float32\n\t\tcolorm.Elements(body[:], translation[:])\n\t\ti.tmpUniforms = shader.appendUniforms(i.tmpUniforms, map[string]any{\n\t\t\tbuiltinshader.UniformColorMBody:        body[:],\n\t\t\tbuiltinshader.UniformColorMTranslation: translation[:],\n\t\t})\n\t}\n\n\tdr := i.adjustedBounds()\n\thint := restorable.HintNone\n\tif overwritesDstRegion(options.Blend, dr, geoM, sx0, sy0, sx1, sy1) {\n\t\thint = restorable.HintOverwriteDstRegion\n\t}\n\n\tskipMipmap := options.DisableMipmaps\n\tif !skipMipmap {\n\t\tskipMipmap = canSkipMipmap(det, filter)\n\t}\n\ti.image.DrawTriangles(srcs, vs, is, blend, dr, [graphics.ShaderSrcImageCount]image.Rectangle{img.adjustedBounds()}, shader.shader, i.tmpUniforms, graphicsdriver.FillRuleFillAll, skipMipmap, false, hint)\n}\n\n// overwritesDstRegion reports whether the given parameters overwrite the destination region completely.\nfunc overwritesDstRegion(blend Blend, dstRegion image.Rectangle, geoM GeoM, sx0, sy0, sx1, sy1 int) bool {\n\t// TODO: More precisely, BlendFactorDestinationRGB, BlendFactorDestinationAlpha, and operations should be checked.\n\tif blend != BlendCopy && blend != BlendClear {\n\t\treturn false\n\t}\n\t// Check the result vertices is not a rotated rectangle.\n\tif geoM.b != 0 || geoM.c != 0 {\n\t\treturn false\n\t}\n\t// Check the result vertices completely covers dstRegion.\n\tx0, y0 := geoM.Apply(float64(sx0), float64(sy0))\n\tx1, y1 := geoM.Apply(float64(sx1), float64(sy1))\n\tif float64(dstRegion.Min.X) < x0 || float64(dstRegion.Min.Y) < y0 || float64(dstRegion.Max.X) > x1 || float64(dstRegion.Max.Y) > y1 {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// Vertex represents a vertex passed to DrawTriangles.\ntype Vertex struct {\n\t// DstX and DstY represents a point on a destination image.\n\tDstX float32\n\tDstY float32\n\n\t// SrcX and SrcY represents a point on a source image.\n\t// Be careful that SrcX/SrcY coordinates are on the image's bounds.\n\t// This means that an upper-left point of a sub-image might not be (0, 0).\n\tSrcX float32\n\tSrcY float32\n\n\t// ColorR/ColorG/ColorB/ColorA represents color scaling values.\n\t// Their interpretation depends on the concrete draw call used:\n\t// - DrawTriangles: straight-alpha or premultiplied-alpha encoded color multiplier.\n\t//   The format is determined by ColorScaleMode in DrawTrianglesOptions.\n\t//   If ColorA is 0, the vertex is fully transparent and color is ignored.\n\t//   If ColorA is 1, the vertex has the color (ColorR, ColorG, ColorB).\n\t//   Vertex colors are converted to premultiplied-alpha internally and\n\t//   interpolated linearly respecting alpha.\n\t// - DrawTrianglesShader: arbitrary floating point values sent to the shader.\n\t//   These are interpolated linearly and independently of each other.\n\tColorR float32\n\tColorG float32\n\tColorB float32\n\tColorA float32\n\n\t// Custom0/Custom1/Custom2/Custom3 represents general-purpose values passed to the shader.\n\t// In order to use them, Fragment must have an additional vec4 argument.\n\t//\n\t// These values are valid only when DrawTrianglesShader is used.\n\t// In other cases, these values are ignored.\n\tCustom0 float32\n\tCustom1 float32\n\tCustom2 float32\n\tCustom3 float32\n}\n\nvar _ [0]byte = [unsafe.Sizeof(Vertex{}) - unsafe.Sizeof(float32(0))*graphics.VertexFloatCount]byte{}\n\n// Address represents a sampler address mode.\ntype Address int\n\nconst (\n\t// AddressUnsafe means there is no guarantee when the texture coordinates are out of range.\n\tAddressUnsafe Address = Address(builtinshader.AddressUnsafe)\n\n\t// AddressClampToZero means that out-of-range texture coordinates return 0 (transparent).\n\tAddressClampToZero Address = Address(builtinshader.AddressClampToZero)\n\n\t// AddressRepeat means that texture coordinates wrap to the other side of the texture.\n\tAddressRepeat Address = Address(builtinshader.AddressRepeat)\n)\n\n// FillRule is the rule whether an overlapped region is rendered with DrawTriangles(Shader).\ntype FillRule int\n\nconst (\n\t// FillRuleFillAll indicates all the triangles are rendered regardless of overlaps.\n\tFillRuleFillAll FillRule = FillRule(graphicsdriver.FillRuleFillAll)\n\n\t// FillRuleNonZero means that triangles are rendered based on the non-zero rule.\n\t// If and only if the number of overlaps is not 0, the region is rendered.\n\tFillRuleNonZero FillRule = FillRule(graphicsdriver.FillRuleNonZero)\n\n\t// FillRuleEvenOdd means that triangles are rendered based on the even-odd rule.\n\t// If and only if the number of overlaps is odd, the region is rendered.\n\tFillRuleEvenOdd FillRule = FillRule(graphicsdriver.FillRuleEvenOdd)\n)\n\nconst (\n\t// FillAll indicates all the triangles are rendered regardless of overlaps.\n\t//\n\t// Deprecated: as of v2.8. Use FillRuleFillAll instead.\n\tFillAll = FillRuleFillAll\n\n\t// NonZero means that triangles are rendered based on the non-zero rule.\n\t// If and only if the number of overlaps is not 0, the region is rendered.\n\t//\n\t// Deprecated: as of v2.8. Use FillRuleNonZero instead.\n\tNonZero = FillRuleNonZero\n\n\t// EvenOdd means that triangles are rendered based on the even-odd rule.\n\t// If and only if the number of overlaps is odd, the region is rendered.\n\t//\n\t// Deprecated: as of v2.8. Use FillRuleEvenOdd instead.\n\tEvenOdd = FillRuleEvenOdd\n)\n\n// ColorScaleMode is the mode of color scales in vertices.\ntype ColorScaleMode int\n\nconst (\n\t// ColorScaleModeStraightAlpha indicates color scales in vertices are\n\t// straight-alpha encoded color multiplier.\n\tColorScaleModeStraightAlpha ColorScaleMode = iota\n\n\t// ColorScaleModePremultipliedAlpha indicates color scales in vertices are\n\t// premultiplied-alpha encoded color multiplier.\n\tColorScaleModePremultipliedAlpha\n)\n\n// DrawTrianglesOptions represents options for DrawTriangles.\ntype DrawTrianglesOptions struct {\n\t// ColorM is a color matrix to draw.\n\t// The default (zero) value is identity, which doesn't change any color.\n\t// ColorM is applied before vertex color scale is applied.\n\t//\n\t// Deprecated: as of v2.5. Use the package colorm instead.\n\tColorM ColorM\n\n\t// ColorScaleMode is the mode of color scales in vertices.\n\t// ColorScaleMode affects the color calculation with vertex colors, but doesn't affect with a color matrix.\n\t// The default (zero) value is ColorScaleModeStraightAlpha.\n\tColorScaleMode ColorScaleMode\n\n\t// CompositeMode is a composite mode to draw.\n\t// The default (zero) value is CompositeModeCustom (Blend is used).\n\t//\n\t// Deprecated: as of v2.5. Use Blend instead.\n\tCompositeMode CompositeMode\n\n\t// Blend is a blending way of the source color and the destination color.\n\t// Blend is used only when CompositeMode is CompositeModeCustom.\n\t// The default (zero) value is the regular alpha blending.\n\tBlend Blend\n\n\t// Filter is a type of texture filter.\n\t// The default (zero) value is FilterNearest.\n\tFilter Filter\n\n\t// Address is a sampler address mode.\n\t// The default (zero) value is AddressUnsafe.\n\tAddress Address\n\n\t// FillRule indicates the rule how an overlapped region is rendered.\n\t//\n\t// The rules FillRuleNonZero and FillRuleEvenOdd are useful when you want to render a complex polygon.\n\t// A complex polygon is a non-convex polygon like a concave polygon, a polygon with holes, or a self-intersecting polygon.\n\t// See examples/vector for actual usages.\n\t//\n\t// The default (zero) value is FillRuleFillAll.\n\tFillRule FillRule\n\n\t// AntiAlias indicates whether the rendering uses anti-alias or not.\n\t// AntiAlias is useful especially when you pass vertices from the vector package.\n\t//\n\t// AntiAlias increases internal draw calls and might affect performance.\n\t// Use the build tag `ebitenginedebug` to check the number of draw calls if you care.\n\t//\n\t// The default (zero) value is false.\n\tAntiAlias bool\n\n\t// DisableMipmaps disables mipmaps.\n\t// When Filter is FilterLinear and GeoM shrinks the image, mipmaps are used by default.\n\t// Mipmap is useful to render a shrunk image with high quality.\n\t// However, mipmaps can be expensive, especially on mobiles.\n\t// When DisableMipmaps is true, mipmap is not used.\n\t// When Filter is not FilterLinear, DisableMipmaps is ignored.\n\t//\n\t// The default (zero) value is false.\n\tDisableMipmaps bool\n}\n\n// MaxIndicesCount is the maximum number of indices for DrawTriangles and DrawTrianglesShader.\n//\n// Deprecated: as of v2.6. This constant is no longer used.\nconst MaxIndicesCount = (1 << 16) / 3 * 3\n\n// MaxIndicesNum is the maximum number of indices for DrawTriangles and DrawTrianglesShader.\n//\n// Deprecated: as of v2.4. This constant is no longer used.\nconst MaxIndicesNum = MaxIndicesCount\n\n// MaxVerticesCount is the maximum number of vertices for DrawTriangles and DrawTrianglesShader.\n//\n// Deprecated: as of v2.7. Use MaxVertexCount instead.\nconst MaxVerticesCount = graphicscommand.MaxVertexCount\n\n// MaxVertexCount is the maximum number of vertices for DrawTriangles and DrawTrianglesShader.\nconst MaxVertexCount = graphicscommand.MaxVertexCount\n\n// DrawTriangles draws triangles with the specified vertices and their indices.\n//\n// img is used as a source image. img cannot be nil.\n// If you want to draw triangles with a solid color, use a small white image\n// and adjust the color elements in the vertices. For an actual implementation,\n// see the example 'vector'.\n//\n// Vertex contains color values, which are interpreted as straight-alpha colors by default.\n// This depends on the option's ColorScaleMode.\n//\n// If len(vertices) is more than MaxVertexCount, the exceeding part is ignored.\n//\n// If len(indices) is not multiple of 3, DrawTriangles panics.\n//\n// If a value in indices is out of range of vertices, or not less than MaxVertexCount, DrawTriangles panics.\n//\n// The rule in which DrawTriangles works effectively is same as DrawImage's.\n//\n// When the given image is disposed, DrawTriangles panics.\n//\n// When the image i is disposed, DrawTriangles does nothing.\nfunc (i *Image) DrawTriangles(vertices []Vertex, indices []uint16, img *Image, options *DrawTrianglesOptions) {\n\ti.copyCheck()\n\n\tif img != nil && img.isDisposed() {\n\t\tpanic(\"ebiten: the given image to DrawTriangles must not be disposed\")\n\t}\n\tif i.isDisposed() {\n\t\treturn\n\t}\n\n\tif len(vertices) > graphicscommand.MaxVertexCount {\n\t\t// The last part cannot be specified by indices. Just omit them.\n\t\tvertices = vertices[:graphicscommand.MaxVertexCount]\n\t}\n\tif len(indices)%3 != 0 {\n\t\tpanic(\"ebiten: len(indices) % 3 must be 0\")\n\t}\n\tfor i, idx := range indices {\n\t\tif int(idx) >= len(vertices) {\n\t\t\tpanic(fmt.Sprintf(\"ebiten: indices[%d] must be less than len(vertices) (%d) but was %d\", i, len(vertices), idx))\n\t\t}\n\t}\n\n\tif options == nil {\n\t\toptions = &DrawTrianglesOptions{}\n\t}\n\n\tvar blend graphicsdriver.Blend\n\tif options.CompositeMode == CompositeModeCustom {\n\t\tblend = options.Blend.internalBlend()\n\t} else {\n\t\tblend = options.CompositeMode.blend().internalBlend()\n\t}\n\n\taddress := builtinshader.Address(options.Address)\n\tfilter := builtinshader.Filter(options.Filter)\n\n\tcolorm, cr, cg, cb, ca := colorMToScale(options.ColorM.affineColorM())\n\n\tvs := i.ensureTmpVertices(len(vertices) * graphics.VertexFloatCount)\n\tdst := i\n\tif options.ColorScaleMode == ColorScaleModeStraightAlpha {\n\t\t// Avoid using `for i, v := range vertices` as adding `v` creates a copy from `vertices` unnecessarily on each loop (#3103).\n\t\tfor i := range vertices {\n\t\t\tdx, dy := dst.adjustPositionF32(vertices[i].DstX, vertices[i].DstY)\n\t\t\tvs[i*graphics.VertexFloatCount] = dx\n\t\t\tvs[i*graphics.VertexFloatCount+1] = dy\n\t\t\tsx, sy := img.adjustPositionF32(vertices[i].SrcX, vertices[i].SrcY)\n\t\t\tvs[i*graphics.VertexFloatCount+2] = sx\n\t\t\tvs[i*graphics.VertexFloatCount+3] = sy\n\t\t\tvs[i*graphics.VertexFloatCount+4] = vertices[i].ColorR * vertices[i].ColorA * cr\n\t\t\tvs[i*graphics.VertexFloatCount+5] = vertices[i].ColorG * vertices[i].ColorA * cg\n\t\t\tvs[i*graphics.VertexFloatCount+6] = vertices[i].ColorB * vertices[i].ColorA * cb\n\t\t\tvs[i*graphics.VertexFloatCount+7] = vertices[i].ColorA * ca\n\t\t}\n\t} else {\n\t\t// See comment above (#3103).\n\t\tfor i := range vertices {\n\t\t\tdx, dy := dst.adjustPositionF32(vertices[i].DstX, vertices[i].DstY)\n\t\t\tvs[i*graphics.VertexFloatCount] = dx\n\t\t\tvs[i*graphics.VertexFloatCount+1] = dy\n\t\t\tsx, sy := img.adjustPositionF32(vertices[i].SrcX, vertices[i].SrcY)\n\t\t\tvs[i*graphics.VertexFloatCount+2] = sx\n\t\t\tvs[i*graphics.VertexFloatCount+3] = sy\n\t\t\tvs[i*graphics.VertexFloatCount+4] = vertices[i].ColorR * cr\n\t\t\tvs[i*graphics.VertexFloatCount+5] = vertices[i].ColorG * cg\n\t\t\tvs[i*graphics.VertexFloatCount+6] = vertices[i].ColorB * cb\n\t\t\tvs[i*graphics.VertexFloatCount+7] = vertices[i].ColorA * ca\n\t\t}\n\t}\n\tis := i.ensureTmpIndices(len(indices))\n\tfor i := range is {\n\t\tis[i] = uint32(indices[i])\n\t}\n\n\tsrcs := [graphics.ShaderSrcImageCount]*ui.Image{img.image}\n\n\tuseColorM := !colorm.IsIdentity()\n\tshader := builtinShader(filter, address, useColorM)\n\ti.tmpUniforms = i.tmpUniforms[:0]\n\tif useColorM {\n\t\tvar body [16]float32\n\t\tvar translation [4]float32\n\t\tcolorm.Elements(body[:], translation[:])\n\t\ti.tmpUniforms = shader.appendUniforms(i.tmpUniforms, map[string]any{\n\t\t\tbuiltinshader.UniformColorMBody:        body[:],\n\t\t\tbuiltinshader.UniformColorMTranslation: translation[:],\n\t\t})\n\t}\n\n\tskipMipmap := options.DisableMipmaps\n\tif !skipMipmap {\n\t\tskipMipmap = filter != builtinshader.FilterLinear\n\t}\n\ti.image.DrawTriangles(srcs, vs, is, blend, i.adjustedBounds(), [graphics.ShaderSrcImageCount]image.Rectangle{img.adjustedBounds()}, shader.shader, i.tmpUniforms, graphicsdriver.FillRule(options.FillRule), skipMipmap, options.AntiAlias, restorable.HintNone)\n}\n\n// DrawTrianglesShaderOptions represents options for DrawTrianglesShader.\ntype DrawTrianglesShaderOptions struct {\n\t// CompositeMode is a composite mode to draw.\n\t// The default (zero) value is CompositeModeCustom (Blend is used).\n\t//\n\t// Deprecated: as of v2.5. Use Blend instead.\n\tCompositeMode CompositeMode\n\n\t// Blend is a blending way of the source color and the destination color.\n\t// Blend is used only when CompositeMode is CompositeModeCustom.\n\t// The default (zero) value is the regular alpha blending.\n\tBlend Blend\n\n\t// Uniforms is a set of uniform variables for the shader.\n\t// The keys are the names of the uniform variables.\n\t// The values must be a numeric type, or a slice or an array of a numeric type.\n\t// If the uniform variable type is an array, a vector or a matrix,\n\t// you have to specify linearly flattened values as a slice or an array.\n\t// For example, if the uniform variable type is [4]vec4, the length will be 16.\n\t//\n\t// If a uniform variable's name doesn't exist in Uniforms, this is treated as if zero values are specified.\n\tUniforms map[string]any\n\n\t// Images is a set of the source images.\n\t// All the images' sizes must be the same.\n\tImages [4]*Image\n\n\t// FillRule indicates the rule how an overlapped region is rendered.\n\t//\n\t// The rules FillRuleNonZero and FillRuleEvenOdd are useful when you want to render a complex polygon.\n\t// A complex polygon is a non-convex polygon like a concave polygon, a polygon with holes, or a self-intersecting polygon.\n\t// See examples/vector for actual usages.\n\t//\n\t// The default (zero) value is FillRuleFillAll.\n\tFillRule FillRule\n\n\t// AntiAlias indicates whether the rendering uses anti-alias or not.\n\t// AntiAlias is useful especially when you pass vertices from the vector package.\n\t//\n\t// AntiAlias increases internal draw calls and might affect performance.\n\t// Use the build tag `ebitenginedebug` to check the number of draw calls if you care.\n\t//\n\t// The default (zero) value is false.\n\tAntiAlias bool\n}\n\n// Check the number of images.\nvar _ [len(DrawTrianglesShaderOptions{}.Images) - graphics.ShaderSrcImageCount]struct{} = [0]struct{}{}\n\n// DrawTrianglesShader draws triangles with the specified vertices and their indices with the specified shader.\n//\n// Vertex contains color values, which can be interpreted for any purpose by the shader.\n//\n// For the details about the shader, see https://ebitengine.org/en/documents/shader.html.\n//\n// If the shader unit is texels, one of the specified image is non-nil and its size is different from (width, height),\n// DrawTrianglesShader panics.\n// If one of the specified image is non-nil and is disposed, DrawTrianglesShader panics.\n//\n// If len(vertices) is more than MaxVertexCount, the exceeding part is ignored.\n//\n// If len(indices) is not multiple of 3, DrawTrianglesShader panics.\n//\n// If a value in indices is out of range of vertices, or not less than MaxVertexCount, DrawTrianglesShader panics.\n//\n// When a specified image is non-nil and is disposed, DrawTrianglesShader panics.\n//\n// If a specified uniform variable's length or type doesn't match with an expected one, DrawTrianglesShader panics.\n//\n// Even if a result is an invalid color as a premultiplied-alpha color, i.e. an alpha value exceeds other color values,\n// the value is kept and is not clamped.\n//\n// When the image i is disposed, DrawTrianglesShader does nothing.\nfunc (i *Image) DrawTrianglesShader(vertices []Vertex, indices []uint16, shader *Shader, options *DrawTrianglesShaderOptions) {\n\ti.copyCheck()\n\n\tif i.isDisposed() {\n\t\treturn\n\t}\n\n\tif shader.isDisposed() {\n\t\tpanic(\"ebiten: the given shader to DrawTrianglesShader must not be disposed\")\n\t}\n\n\tif len(vertices) > graphicscommand.MaxVertexCount {\n\t\t// The last part cannot be specified by indices. Just omit them.\n\t\tvertices = vertices[:graphicscommand.MaxVertexCount]\n\t}\n\tif len(indices)%3 != 0 {\n\t\tpanic(\"ebiten: len(indices) % 3 must be 0\")\n\t}\n\tfor i, idx := range indices {\n\t\tif int(idx) >= len(vertices) {\n\t\t\tpanic(fmt.Sprintf(\"ebiten: indices[%d] must be less than len(vertices) (%d) but was %d\", i, len(vertices), idx))\n\t\t}\n\t}\n\n\tif options == nil {\n\t\toptions = &DrawTrianglesShaderOptions{}\n\t}\n\n\tvar blend graphicsdriver.Blend\n\tif options.CompositeMode == CompositeModeCustom {\n\t\tblend = options.Blend.internalBlend()\n\t} else {\n\t\tblend = options.CompositeMode.blend().internalBlend()\n\t}\n\n\tvs := i.ensureTmpVertices(len(vertices) * graphics.VertexFloatCount)\n\tdst := i\n\tsrc := options.Images[0]\n\t// Avoid using `for i, v := range vertices` as adding `v` creates a copy from `vertices` unnecessarily on each loop (#3103).\n\tfor i := range vertices {\n\t\tdx, dy := dst.adjustPositionF32(vertices[i].DstX, vertices[i].DstY)\n\t\tvs[i*graphics.VertexFloatCount] = dx\n\t\tvs[i*graphics.VertexFloatCount+1] = dy\n\t\tsx, sy := vertices[i].SrcX, vertices[i].SrcY\n\t\tif src != nil {\n\t\t\tsx, sy = src.adjustPositionF32(sx, sy)\n\t\t}\n\t\tvs[i*graphics.VertexFloatCount+2] = sx\n\t\tvs[i*graphics.VertexFloatCount+3] = sy\n\t\tvs[i*graphics.VertexFloatCount+4] = vertices[i].ColorR\n\t\tvs[i*graphics.VertexFloatCount+5] = vertices[i].ColorG\n\t\tvs[i*graphics.VertexFloatCount+6] = vertices[i].ColorB\n\t\tvs[i*graphics.VertexFloatCount+7] = vertices[i].ColorA\n\t\tvs[i*graphics.VertexFloatCount+8] = vertices[i].Custom0\n\t\tvs[i*graphics.VertexFloatCount+9] = vertices[i].Custom1\n\t\tvs[i*graphics.VertexFloatCount+10] = vertices[i].Custom2\n\t\tvs[i*graphics.VertexFloatCount+11] = vertices[i].Custom3\n\t}\n\n\tis := i.ensureTmpIndices(len(indices))\n\tfor i := range is {\n\t\tis[i] = uint32(indices[i])\n\t}\n\n\tvar imgs [graphics.ShaderSrcImageCount]*ui.Image\n\tvar imgSize image.Point\n\tfor i, img := range options.Images {\n\t\tif img == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif img.isDisposed() {\n\t\t\tpanic(\"ebiten: the given image to DrawTrianglesShader must not be disposed\")\n\t\t}\n\t\tif shader.unit == shaderir.Texels {\n\t\t\tif i == 0 {\n\t\t\t\timgSize = img.Bounds().Size()\n\t\t\t} else {\n\t\t\t\t// TODO: Check imgw > 0 && imgh > 0\n\t\t\t\tif img.Bounds().Size() != imgSize {\n\t\t\t\t\tpanic(\"ebiten: all the source images must be the same size with the rectangle\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\timgs[i] = img.image\n\t}\n\n\tvar srcRegions [graphics.ShaderSrcImageCount]image.Rectangle\n\tfor i, img := range options.Images {\n\t\tif img == nil {\n\t\t\tcontinue\n\t\t}\n\t\tsrcRegions[i] = img.adjustedBounds()\n\t}\n\n\ti.tmpUniforms = i.tmpUniforms[:0]\n\ti.tmpUniforms = shader.appendUniforms(i.tmpUniforms, options.Uniforms)\n\n\ti.image.DrawTriangles(imgs, vs, is, blend, i.adjustedBounds(), srcRegions, shader.shader, i.tmpUniforms, graphicsdriver.FillRule(options.FillRule), true, options.AntiAlias, restorable.HintNone)\n}\n\n// DrawRectShaderOptions represents options for DrawRectShader.\ntype DrawRectShaderOptions struct {\n\t// GeoM is a geometry matrix to draw.\n\t// The default (zero) value is identity, which draws the rectangle at (0, 0).\n\tGeoM GeoM\n\n\t// ColorScale is a scale of color.\n\t// This scaling values are passed to the `color vec4` argument of the Fragment function in a Kage program.\n\t// The default (zero) value is identity, which is (1, 1, 1, 1).\n\tColorScale ColorScale\n\n\t// CompositeMode is a composite mode to draw.\n\t// The default (zero) value is CompositeModeCustom (Blend is used).\n\t//\n\t// Deprecated: as of v2.5. Use Blend instead.\n\tCompositeMode CompositeMode\n\n\t// Blend is a blending way of the source color and the destination color.\n\t// Blend is used only when CompositeMode is CompositeModeCustom.\n\t// The default (zero) value is the regular alpha blending.\n\tBlend Blend\n\n\t// Uniforms is a set of uniform variables for the shader.\n\t// The keys are the names of the uniform variables.\n\t// The values must be a numeric type, or a slice or an array of a numeric type.\n\t// If the uniform variable type is an array, a vector or a matrix,\n\t// you have to specify linearly flattened values as a slice or an array.\n\t// For example, if the uniform variable type is [4]vec4, the length will be 16.\n\t//\n\t// If a uniform variable's name doesn't exist in Uniforms, this is treated as if zero values are specified.\n\tUniforms map[string]any\n\n\t// Images is a set of the source images.\n\t// All the images' sizes must be the same.\n\tImages [4]*Image\n}\n\n// Check the number of images.\nvar _ [len(DrawRectShaderOptions{}.Images)]struct{} = [graphics.ShaderSrcImageCount]struct{}{}\n\n// DrawRectShader draws a rectangle with the specified width and height with the specified shader.\n//\n// For the details about the shader, see https://ebitengine.org/en/documents/shader.html.\n//\n// When one of the specified image is non-nil and its size is different from (width, height), DrawRectShader panics.\n// When one of the specified image is non-nil and is disposed, DrawRectShader panics.\n//\n// If a specified uniform variable's length or type doesn't match with an expected one, DrawRectShader panics.\n//\n// In a shader, srcPos in Fragment represents a position in a source image.\n// If no source images are specified, srcPos represents the position from (0, 0) to (width, height) in pixels.\n// If the unit is pixels by a compiler directive `//kage:unit pixelss`, srcPos values are valid.\n// If the unit is texels (default), srcPos values still take from (0, 0) to (width, height),\n// but these are invalid since srcPos is expected to be in texels in the texel-unit mode.\n// This behavior is preserved for backward compatibility. It is recommended to use the pixel-unit mode to avoid confusion.\n//\n// If no source images are specified, imageSrc0Size returns a valid size only when the unit is pixels,\n// but always returns 0 when the unit is texels (default).\n//\n// Even if a result is an invalid color as a premultiplied-alpha color, i.e. an alpha value exceeds other color values,\n// the value is kept and is not clamped.\n//\n// When the image i is disposed, DrawRectShader does nothing.\nfunc (i *Image) DrawRectShader(width, height int, shader *Shader, options *DrawRectShaderOptions) {\n\ti.copyCheck()\n\n\tif i.isDisposed() {\n\t\treturn\n\t}\n\n\tif shader.isDisposed() {\n\t\tpanic(\"ebiten: the given shader to DrawRectShader must not be disposed\")\n\t}\n\n\tif options == nil {\n\t\toptions = &DrawRectShaderOptions{}\n\t}\n\n\tvar blend graphicsdriver.Blend\n\tif options.CompositeMode == CompositeModeCustom {\n\t\tblend = options.Blend.internalBlend()\n\t} else {\n\t\tblend = options.CompositeMode.blend().internalBlend()\n\t}\n\n\tvar imgs [graphics.ShaderSrcImageCount]*ui.Image\n\tfor i, img := range options.Images {\n\t\tif img == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif img.isDisposed() {\n\t\t\tpanic(\"ebiten: the given image to DrawRectShader must not be disposed\")\n\t\t}\n\t\tif img.Bounds().Size() != image.Pt(width, height) {\n\t\t\tpanic(\"ebiten: all the source images must be the same size with the rectangle\")\n\t\t}\n\t\timgs[i] = img.image\n\t}\n\n\tvar srcRegions [graphics.ShaderSrcImageCount]image.Rectangle\n\tfor i, img := range options.Images {\n\t\tif img == nil {\n\t\t\tif shader.unit == shaderir.Pixels && i == 0 {\n\t\t\t\t// Give the source size as pixels only when the unit is pixels so that users can get the source size via imageSrc0Size (#2166).\n\t\t\t\t// With the texel mode, the imageSrc0Origin and imageSrc0Size values should be in texels so the source position in pixels would not match.\n\t\t\t\tsrcRegions[i] = image.Rect(0, 0, width, height)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tsrcRegions[i] = img.adjustedBounds()\n\t}\n\n\tgeoM := options.GeoM\n\tif offsetX, offsetY := i.adjustPosition(0, 0); offsetX != 0 || offsetY != 0 {\n\t\tgeoM.Translate(float64(offsetX), float64(offsetY))\n\t}\n\ta, b, c, d, tx, ty := geoM.elements32()\n\tif det := a*d - b*c; det == 0 {\n\t\treturn\n\t}\n\tcr, cg, cb, ca := options.ColorScale.elements()\n\tvs := i.ensureTmpVertices(4 * graphics.VertexFloatCount)\n\n\t// Do not use srcRegions[0].Dx() and srcRegions[0].Dy() as these might be empty.\n\tgraphics.QuadVerticesFromSrcAndMatrix(vs,\n\t\tfloat32(srcRegions[0].Min.X), float32(srcRegions[0].Min.Y),\n\t\tfloat32(srcRegions[0].Min.X+width), float32(srcRegions[0].Min.Y+height),\n\t\ta, b, c, d, tx, ty, cr, cg, cb, ca)\n\tis := graphics.QuadIndices()\n\n\ti.tmpUniforms = i.tmpUniforms[:0]\n\ti.tmpUniforms = shader.appendUniforms(i.tmpUniforms, options.Uniforms)\n\n\tdr := i.adjustedBounds()\n\thint := restorable.HintNone\n\t// Do not use srcRegions[0].Dx() and srcRegions[0].Dy() as these might be empty.\n\tif overwritesDstRegion(options.Blend, dr, geoM, srcRegions[0].Min.X, srcRegions[0].Min.Y, srcRegions[0].Min.X+width, srcRegions[0].Min.Y+height) {\n\t\thint = restorable.HintOverwriteDstRegion\n\t}\n\n\ti.image.DrawTriangles(imgs, vs, is, blend, dr, srcRegions, shader.shader, i.tmpUniforms, graphicsdriver.FillRuleFillAll, true, false, hint)\n}\n\n// SubImage returns an image representing the portion of the image p visible through r.\n// The returned value shares pixels with the original image.\n//\n// The returned value is always *ebiten.Image.\n//\n// If the image is disposed, SubImage returns nil.\n//\n// A sub-image returned by SubImage can be used as a rendering source and a rendering destination.\n// If a sub-image is used as a rendering source, the image is used as if it is a small image.\n// If a sub-image is used as a rendering destination, the region being rendered is clipped.\n//\n// Successive uses of multiple various regions as rendering destination is still efficient\n// when all the underlying images are the same, but some platforms like browsers might not work efficiently.\nfunc (i *Image) SubImage(r image.Rectangle) image.Image {\n\ti.copyCheck()\n\tif i.isDisposed() {\n\t\treturn nil\n\t}\n\n\tr = r.Intersect(i.Bounds())\n\t// Need to check Empty explicitly. See the standard image package implementations.\n\tif r.Empty() {\n\t\tr = image.ZR\n\t}\n\n\tvar orig = i\n\tif i.isSubImage() {\n\t\torig = i.original\n\t}\n\n\timg := &Image{\n\t\timage:    i.image,\n\t\tbounds:   r,\n\t\toriginal: orig,\n\t}\n\timg.addr = img\n\n\treturn img\n}\n\n// Bounds returns the bounds of the image.\n//\n// Bounds implements the standard image.Image's Bounds.\nfunc (i *Image) Bounds() image.Rectangle {\n\tif i.isDisposed() {\n\t\tpanic(\"ebiten: the image is already disposed\")\n\t}\n\treturn i.bounds\n}\n\n// ColorModel returns the color model of the image.\n//\n// ColorModel implements the standard image.Image's ColorModel.\nfunc (i *Image) ColorModel() color.Model {\n\treturn color.RGBAModel\n}\n\n// ReadPixels reads the image's pixels from the image.\n//\n// The given pixels represent RGBA pre-multiplied alpha values.\n//\n// ReadPixels loads pixels from GPU to system memory if necessary, which means that ReadPixels can be slow.\n//\n// ReadPixels always sets a transparent color if the image is disposed.\n//\n// len(pixels) must be 4 * (bounds width) * (bounds height).\n// If len(pixels) is not correct, ReadPixels panics.\n//\n// ReadPixels also works on a sub-image.\n//\n// Note that an important logic should not rely on values returned by ReadPixels, since\n// the returned values can include very slight differences between some machines.\n//\n// ReadPixels can't be called outside the main loop (ebiten.Run's updating function) starts.\nfunc (i *Image) ReadPixels(pixels []byte) {\n\tb := i.Bounds()\n\tif got, want := len(pixels), 4*b.Dx()*b.Dy(); got != want {\n\t\tpanic(fmt.Sprintf(\"ebiten: len(pixels) must be %d but %d at ReadPixels\", want, got))\n\t}\n\n\tif i.isDisposed() {\n\t\tfor i := range pixels {\n\t\t\tpixels[i] = 0\n\t\t}\n\t\treturn\n\t}\n\n\ti.image.ReadPixels(pixels, i.adjustedBounds())\n}\n\n// At returns the color of the image at (x, y).\n//\n// At implements the standard image.Image's At.\n//\n// At loads pixels from GPU to system memory if necessary, which means that At can be slow.\n//\n// At always returns a transparent color if the image is disposed.\n//\n// Note that an important logic should not rely on values returned by At, since\n// the returned values can include very slight differences between some machines.\n//\n// At can't be called outside the main loop (ebiten.Run's updating function) starts.\nfunc (i *Image) At(x, y int) color.Color {\n\tr, g, b, a := i.at(x, y)\n\treturn color.RGBA{R: r, G: g, B: b, A: a}\n}\n\n// RGBA64At implements the standard image.RGBA64Image's RGBA64At.\n//\n// RGBA64At loads pixels from GPU to system memory if necessary, which means\n// that RGBA64At can be slow.\n//\n// RGBA64At always returns a transparent color if the image is disposed.\n//\n// Note that an important logic should not rely on values returned by RGBA64At,\n// since the returned values can include very slight differences between some machines.\n//\n// RGBA64At can't be called outside the main loop (ebiten.Run's updating function) starts.\nfunc (i *Image) RGBA64At(x, y int) color.RGBA64 {\n\tr, g, b, a := i.at(x, y)\n\treturn color.RGBA64{R: uint16(r) * 0x101, G: uint16(g) * 0x101, B: uint16(b) * 0x101, A: uint16(a) * 0x101}\n}\n\nfunc (i *Image) at(x, y int) (r, g, b, a byte) {\n\tif i.isDisposed() {\n\t\treturn 0, 0, 0, 0\n\t}\n\tif !image.Pt(x, y).In(i.Bounds()) {\n\t\treturn 0, 0, 0, 0\n\t}\n\n\tx, y = i.adjustPosition(x, y)\n\tvar pix [4]byte\n\ti.image.ReadPixels(pix[:], image.Rect(x, y, x+1, y+1))\n\treturn pix[0], pix[1], pix[2], pix[3]\n}\n\n// Set sets the color at (x, y).\n//\n// Set implements the standard draw.Image's Set.\n//\n// Even if a result is an invalid color as a premultiplied-alpha color, i.e. an alpha value exceeds other color values,\n// the value is kept and is not clamped.\n//\n// If the image is disposed, Set does nothing.\nfunc (i *Image) Set(x, y int, clr color.Color) {\n\ti.copyCheck()\n\tif i.isDisposed() {\n\t\treturn\n\t}\n\tif !image.Pt(x, y).In(i.Bounds()) {\n\t\treturn\n\t}\n\tif i.isSubImage() {\n\t\ti = i.original\n\t}\n\n\tdx, dy := i.adjustPosition(x, y)\n\tcr, cg, cb, ca := clr.RGBA()\n\ti.image.WritePixels([]byte{byte(cr >> 8), byte(cg >> 8), byte(cb >> 8), byte(ca >> 8)}, image.Rect(dx, dy, dx+1, dy+1))\n}\n\n// Dispose disposes the image data.\n// After disposing, most of the image functions do nothing and returns meaningless values.\n//\n// Calling Dispose is not mandatory. GC automatically collects internal resources that no objects refer to.\n// However, calling Dispose explicitly is helpful if memory usage matters.\n//\n// If the image is a sub-image, Dispose does nothing.\n//\n// If the image is disposed, Dispose does nothing.\n//\n// Deprecated: as of v2.7. Use Deallocate instead.\nfunc (i *Image) Dispose() {\n\ti.copyCheck()\n\n\tif i.isDisposed() {\n\t\treturn\n\t}\n\tif i.isSubImage() {\n\t\treturn\n\t}\n\ti.image.Deallocate()\n\ti.image = nil\n}\n\n// Deallocate clears the image and deallocates the internal state of the image.\n// Even after Deallocate is called, the image is still available.\n// In this case, the image's internal state is allocated again.\n//\n// Usually, you don't have to call Deallocate since the internal state is automatically released by GC.\n// However, if you are sure that the image is no longer used but not sure how this image object is referred,\n// you can call Deallocate to make sure that the internal state is deallocated.\n//\n// If the image is a sub-image, Deallocate does nothing.\n//\n// If the image is disposed, Deallocate does nothing.\nfunc (i *Image) Deallocate() {\n\ti.copyCheck()\n\n\tif i.isDisposed() {\n\t\treturn\n\t}\n\tif i.isSubImage() {\n\t\treturn\n\t}\n\ti.image.Deallocate()\n}\n\n// WritePixels replaces the pixels of the image.\n//\n// The given pixels are treated as RGBA pre-multiplied alpha values.\n//\n// len(pix) must be 4 * (bounds width) * (bounds height).\n// If len(pix) is not correct, WritePixels panics.\n//\n// WritePixels also works on a sub-image.\n//\n// Even if a result is an invalid color as a premultiplied-alpha color, i.e. an alpha value exceeds other color values,\n// the value is kept and is not clamped.\n//\n// When the image is disposed, WritePixels does nothing.\nfunc (i *Image) WritePixels(pixels []byte) {\n\ti.copyCheck()\n\n\tif i.isDisposed() {\n\t\treturn\n\t}\n\n\t// Do not need to copy pixels here.\n\t// * In internal/mipmap, pixels are copied when necessary.\n\t// * In internal/atlas, pixels are copied to make its paddings.\n\ti.image.WritePixels(pixels, i.adjustedBounds())\n}\n\n// ReplacePixels replaces the pixels of the image.\n//\n// Deprecated: as of v2.4. Use WritePixels instead.\nfunc (i *Image) ReplacePixels(pixels []byte) {\n\ti.WritePixels(pixels)\n}\n\n// NewImage returns an empty image.\n//\n// If width or height is less than 1 or more than device-dependent maximum size, NewImage panics.\n//\n// NewImage should be called only when necessary.\n// For example, you should avoid to call NewImage every Update or Draw call.\n// Reusing the same image by Clear is much more efficient than creating a new image.\n//\n// NewImage panics if RunGame already finishes.\nfunc NewImage(width, height int) *Image {\n\treturn newImage(image.Rect(0, 0, width, height), atlas.ImageTypeRegular)\n}\n\n// NewImageOptions represents options for NewImage.\ntype NewImageOptions struct {\n\t// Unmanaged represents whether the image is unmanaged or not.\n\t// The default (zero) value is false, that means the image is managed.\n\t//\n\t// An unmanaged image is never on an internal automatic texture atlas.\n\t// A regular image is a part of an internal texture atlas, and locating them is done automatically in Ebitengine.\n\t// Unmanaged is useful when you want finer controls over the image for performance and memory reasons.\n\tUnmanaged bool\n}\n\n// NewImageWithOptions returns an empty image with the given bounds and the options.\n//\n// If width or height is less than 1 or more than device-dependent maximum size, NewImageWithOptions panics.\n//\n// The rendering origin position is (0, 0) of the given bounds.\n// If DrawImage is called on a new image created by NewImageOptions,\n// for example, the center of scaling and rotating is (0, 0), that might not be an upper-left position.\n//\n// If options is nil, the default setting is used.\n//\n// NewImageWithOptions should be called only when necessary.\n// For example, you should avoid to call NewImageWithOptions every Update or Draw call.\n// Reusing the same image by Clear is much more efficient than creating a new image.\n//\n// NewImageWithOptions panics if RunGame already finishes.\nfunc NewImageWithOptions(bounds image.Rectangle, options *NewImageOptions) *Image {\n\timageType := atlas.ImageTypeRegular\n\tif options != nil && options.Unmanaged {\n\t\timageType = atlas.ImageTypeUnmanaged\n\t}\n\treturn newImage(bounds, imageType)\n}\n\nfunc newImage(bounds image.Rectangle, imageType atlas.ImageType) *Image {\n\tif isRunGameEnded() {\n\t\tpanic(fmt.Sprintf(\"ebiten: NewImage cannot be called after RunGame finishes\"))\n\t}\n\n\twidth, height := bounds.Dx(), bounds.Dy()\n\tif width <= 0 {\n\t\tpanic(fmt.Sprintf(\"ebiten: width at NewImage must be positive but %d\", width))\n\t}\n\tif height <= 0 {\n\t\tpanic(fmt.Sprintf(\"ebiten: height at NewImage must be positive but %d\", height))\n\t}\n\n\ti := &Image{\n\t\timage:  ui.Get().NewImage(width, height, imageType),\n\t\tbounds: bounds,\n\t}\n\ti.addr = i\n\treturn i\n}\n\n// NewImageFromImage creates a new image with the given image (source).\n//\n// If source's width or height is less than 1 or more than device-dependent maximum size, NewImageFromImage panics.\n//\n// NewImageFromImage should be called only when necessary.\n// For example, you should avoid to call NewImageFromImage every Update or Draw call.\n// Reusing the same image by Clear and WritePixels is much more efficient than creating a new image.\n//\n// NewImageFromImage panics if RunGame already finishes.\n//\n// The returned image's upper-left position is always (0, 0). The source's bounds are not respected.\nfunc NewImageFromImage(source image.Image) *Image {\n\treturn NewImageFromImageWithOptions(source, nil)\n}\n\n// NewImageFromImageOptions represents options for NewImageFromImage.\ntype NewImageFromImageOptions struct {\n\t// Unmanaged represents whether the image is unmanaged or not.\n\t// The default (zero) value is false, that means the image is managed.\n\t//\n\t// An unmanaged image is never on an internal automatic texture atlas.\n\t// A regular image is a part of an internal texture atlas, and locating them is done automatically in Ebitengine.\n\t// Unmanaged is useful when you want finer controls over the image for performance and memory reasons.\n\tUnmanaged bool\n\n\t// PreserveBounds represents whether the new image's bounds are the same as the given image.\n\t// The default (zero) value is false, that means the new image's upper-left position is adjusted to (0, 0).\n\tPreserveBounds bool\n}\n\n// NewImageFromImageWithOptions creates a new image with the given image (source) with the given options.\n//\n// If source's width or height is less than 1 or more than device-dependent maximum size, NewImageFromImageWithOptions panics.\n//\n// If options is nil, the default setting is used.\n//\n// NewImageFromImageWithOptions should be called only when necessary.\n// For example, you should avoid to call NewImageFromImageWithOptions every Update or Draw call.\n// Reusing the same image by Clear and WritePixels is much more efficient than creating a new image.\n//\n// NewImageFromImageWithOptions panics if RunGame already finishes.\nfunc NewImageFromImageWithOptions(source image.Image, options *NewImageFromImageOptions) *Image {\n\tif options == nil {\n\t\toptions = &NewImageFromImageOptions{}\n\t}\n\n\tvar r image.Rectangle\n\tif options.PreserveBounds {\n\t\tr = source.Bounds()\n\t} else {\n\t\tsize := source.Bounds().Size()\n\t\tr = image.Rect(0, 0, size.X, size.Y)\n\t}\n\ti := NewImageWithOptions(r, &NewImageOptions{\n\t\tUnmanaged: options.Unmanaged,\n\t})\n\n\t// If the given image is an Ebitengine image, use DrawImage instead of reading pixels from the source.\n\t// This works even before the game loop runs.\n\tif source, ok := source.(*Image); ok {\n\t\top := &DrawImageOptions{}\n\t\tif options.PreserveBounds {\n\t\t\tb := source.Bounds()\n\t\t\top.GeoM.Translate(float64(b.Min.X), float64(b.Min.Y))\n\t\t}\n\t\ti.DrawImage(source, op)\n\t\treturn i\n\t}\n\n\ti.WritePixels(imageToBytes(source))\n\treturn i\n}\n\n// colorMToScale returns a new color matrix and color scales that equal to the given matrix in terms of the effect.\n//\n// If the given matrix is merely a scaling matrix, colorMToScale returns\n// an identity matrix and its scaling factors in premultiplied-alpha format.\n// This is useful to optimize the rendering speed by avoiding the use of the\n// color matrix and instead multiplying all vertex colors by the scale.\nfunc colorMToScale(colorm affine.ColorM) (newColorM affine.ColorM, r, g, b, a float32) {\n\tif colorm.IsIdentity() {\n\t\treturn colorm, 1, 1, 1, 1\n\t}\n\n\tif !colorm.ScaleOnly() {\n\t\treturn colorm, 1, 1, 1, 1\n\t}\n\n\tr = colorm.At(0, 0)\n\tg = colorm.At(1, 1)\n\tb = colorm.At(2, 2)\n\ta = colorm.At(3, 3)\n\n\t// Color matrices work on non-premultiplied colors.\n\t// This color matrix can only make colors darker or equal,\n\t// and thus can never invoke color clamping.\n\t// Thus the simpler vertex color scale based shader can be used.\n\t//\n\t// Negative color values can become positive and out-of-range\n\t// after applying to vertex colors below, which can make the min() in the shader kick in.\n\t//\n\t// Alpha values smaller than 0, combined with negative vertex colors,\n\t// can also make the min() kick in, so that shall be ruled out too.\n\tif r < 0 || g < 0 || b < 0 || a < 0 || r > 1 || g > 1 || b > 1 {\n\t\treturn colorm, 1, 1, 1, 1\n\t}\n\n\treturn affine.ColorMIdentity{}, r * a, g * a, b * a, a\n}\n\nfunc (i *Image) ensureTmpVertices(n int) []float32 {\n\tif cap(i.tmpVertices) < n {\n\t\ti.tmpVertices = make([]float32, n)\n\t}\n\treturn i.tmpVertices[:n]\n}\n\nfunc (i *Image) ensureTmpIndices(n int) []uint32 {\n\tif cap(i.tmpIndices) < n {\n\t\ti.tmpIndices = make([]uint32, n)\n\t}\n\treturn i.tmpIndices[:n]\n}\n\n// private implements FinalScreen.\nfunc (*Image) private() {\n}\n"
        },
        {
          "name": "image_test.go",
          "type": "blob",
          "size": 105.4541015625,
          "content": "// Copyright 2016 Hajime Hoshi\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\t\"image/draw\"\n\t_ \"image/png\"\n\t\"math\"\n\t\"math/rand/v2\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/hajimehoshi/ebiten/v2\"\n\t\"github.com/hajimehoshi/ebiten/v2/examples/resources/images\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/graphics\"\n\tt \"github.com/hajimehoshi/ebiten/v2/internal/testing\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\n// maxImageSize is a maximum image size that should work in almost every environment.\nconst maxImageSize = 4096 - 2\n\nfunc skipTooSlowTests(t *testing.T) bool {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode\")\n\t\treturn true\n\t}\n\tif runtime.GOOS == \"js\" {\n\t\tt.Skip(\"too slow or fragile on Wasm\")\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc TestMain(m *testing.M) {\n\tui.SetPanicOnErrorOnReadingPixelsForTesting(true)\n\tt.MainWithRunLoop(m)\n}\n\nfunc openEbitenImage() (*ebiten.Image, image.Image, error) {\n\timg, _, err := image.Decode(bytes.NewReader(images.Ebiten_png))\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\teimg := ebiten.NewImageFromImage(img)\n\treturn eimg, img, nil\n}\n\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n\n// sameColors compares c1 and c2 and returns a boolean value indicating\n// if the two colors are (almost) same.\n//\n// Pixels read from GPU might include errors (#492), and\n// sameColors considers such errors as delta.\nfunc sameColors(c1, c2 color.RGBA, delta int) bool {\n\treturn abs(int(c1.R)-int(c2.R)) <= delta &&\n\t\tabs(int(c1.G)-int(c2.G)) <= delta &&\n\t\tabs(int(c1.B)-int(c2.B)) <= delta &&\n\t\tabs(int(c1.A)-int(c2.A)) <= delta\n}\n\nfunc TestImagePixels(t *testing.T) {\n\timg0, img, err := openEbitenImage()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn\n\t}\n\n\tif got := img0.Bounds().Size(); got != img.Bounds().Size() {\n\t\tt.Fatalf(\"img size: got %d; want %d\", got, img.Bounds().Size())\n\t}\n\n\tw, h := img0.Bounds().Dx(), img0.Bounds().Dy()\n\t// Check out of range part\n\tw2, h2 := graphics.InternalImageSize(w), graphics.InternalImageSize(h)\n\tfor j := -100; j < h2+100; j++ {\n\t\tfor i := -100; i < w2+100; i++ {\n\t\t\tgot := img0.At(i, j)\n\t\t\twant := color.RGBAModel.Convert(img.At(i, j))\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img0 At(%d, %d): got %v; want %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\tpix := make([]byte, 4*w*h)\n\timg0.ReadPixels(pix)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tidx := 4 * (j*w + i)\n\t\t\tgot := color.RGBA{R: pix[idx], G: pix[idx+1], B: pix[idx+2], A: pix[idx+3]}\n\t\t\twant := color.RGBAModel.Convert(img.At(i, j))\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"(%d, %d): got %v; want %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageComposition(t *testing.T) {\n\timg2Color := color.NRGBA{R: 0x24, G: 0x3f, B: 0x6a, A: 0x88}\n\timg3Color := color.NRGBA{R: 0x85, G: 0xa3, B: 0x08, A: 0xd3}\n\n\t// TODO: Rename this to img0\n\timg1, _, err := openEbitenImage()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn\n\t}\n\n\tw, h := img1.Bounds().Dx(), img1.Bounds().Dy()\n\n\timg2 := ebiten.NewImage(w, h)\n\timg3 := ebiten.NewImage(w, h)\n\n\timg2.Fill(img2Color)\n\timg3.Fill(img3Color)\n\timg_12_3 := ebiten.NewImage(w, h)\n\timg2.DrawImage(img1, nil)\n\timg3.DrawImage(img2, nil)\n\timg_12_3.DrawImage(img3, nil)\n\n\timg2.Fill(img2Color)\n\timg3.Fill(img3Color)\n\timg_1_23 := ebiten.NewImage(w, h)\n\timg3.DrawImage(img2, nil)\n\timg3.DrawImage(img1, nil)\n\timg_1_23.DrawImage(img3, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tc1 := img_12_3.At(i, j).(color.RGBA)\n\t\t\tc2 := img_1_23.At(i, j).(color.RGBA)\n\t\t\tif !sameColors(c1, c2, 1) {\n\t\t\t\tt.Errorf(\"img_12_3.At(%d, %d) = %v; img_1_23.At(%[1]d, %[2]d) = %#[4]v\", i, j, c1, c2)\n\t\t\t}\n\t\t\tif c1.A == 0 {\n\t\t\t\tt.Fatalf(\"img_12_3.At(%d, %d).A = 0; nothing is rendered?\", i, j)\n\t\t\t}\n\t\t\tif c2.A == 0 {\n\t\t\t\tt.Fatalf(\"img_1_23.At(%d, %d).A = 0; nothing is rendered?\", i, j)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageSelf(t *testing.T) {\n\t// Note that mutex usages: without defer, unlocking is not called when panicking.\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"DrawImage must panic but not\")\n\t\t}\n\t}()\n\timg, _, err := openEbitenImage()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn\n\t}\n\timg.DrawImage(img, nil)\n}\n\nfunc TestImageScale(t *testing.T) {\n\tfor _, scale := range []int{2, 3, 4} {\n\t\timg0, _, err := openEbitenImage()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t\treturn\n\t\t}\n\t\tw, h := img0.Bounds().Dx(), img0.Bounds().Dy()\n\t\timg1 := ebiten.NewImage(w*scale, h*scale)\n\t\top := &ebiten.DrawImageOptions{}\n\t\top.GeoM.Scale(float64(scale), float64(scale))\n\n\t\timg1.DrawImage(img0, op)\n\n\t\tfor j := 0; j < h*scale; j++ {\n\t\t\tfor i := 0; i < w*scale; i++ {\n\t\t\t\tc0 := img0.At(i/scale, j/scale).(color.RGBA)\n\t\t\t\tc1 := img1.At(i, j).(color.RGBA)\n\t\t\t\tif c0 != c1 {\n\t\t\t\t\tt.Fatalf(\"img0.At(%[1]d, %[2]d) should equal to img1.At(%[3]d, %[4]d) (with scale %[5]d) but not: %[6]v vs %[7]v\", i/2, j/2, i, j, scale, c0, c1)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImage90DegreeRotate(t *testing.T) {\n\timg0, _, err := openEbitenImage()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn\n\t}\n\tw, h := img0.Bounds().Dx(), img0.Bounds().Dy()\n\timg1 := ebiten.NewImage(h, w)\n\top := &ebiten.DrawImageOptions{}\n\top.GeoM.Rotate(math.Pi / 2)\n\top.GeoM.Translate(float64(h), 0)\n\timg1.DrawImage(img0, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tc0 := img0.At(i, j).(color.RGBA)\n\t\t\tc1 := img1.At(h-j-1, i).(color.RGBA)\n\t\t\tif c0 != c1 {\n\t\t\t\tt.Errorf(\"img0.At(%[1]d, %[2]d) should equal to img1.At(%[3]d, %[4]d) but not: %[5]v vs %[6]v\", i, j, h-j-1, i, c0, c1)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageDotByDotInversion(t *testing.T) {\n\timg0, _, err := openEbitenImage()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn\n\t}\n\tw, h := img0.Bounds().Dx(), img0.Bounds().Dy()\n\timg1 := ebiten.NewImage(w, h)\n\top := &ebiten.DrawImageOptions{}\n\top.GeoM.Rotate(math.Pi)\n\top.GeoM.Translate(float64(w), float64(h))\n\timg1.DrawImage(img0, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tc0 := img0.At(i, j).(color.RGBA)\n\t\t\tc1 := img1.At(w-i-1, h-j-1).(color.RGBA)\n\t\t\tif c0 != c1 {\n\t\t\t\tt.Errorf(\"img0.At(%[1]d, %[2]d) should equal to img1.At(%[3]d, %[4]d) but not: %[5]v vs %[6]v\", i, j, w-i-1, h-j-1, c0, c1)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageWritePixels(t *testing.T) {\n\t// Create a dummy image so that the shared texture is used and origImg's position is shifted.\n\tdummyImg := ebiten.NewImageFromImage(image.NewRGBA(image.Rect(0, 0, 16, 16)))\n\tdefer dummyImg.Deallocate()\n\n\t_, origImg, err := openEbitenImage()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn\n\t}\n\t// Convert to *image.RGBA just in case.\n\timg := image.NewRGBA(origImg.Bounds())\n\tdraw.Draw(img, img.Bounds(), origImg, image.ZP, draw.Src)\n\n\tsize := img.Bounds().Size()\n\timg0 := ebiten.NewImage(size.X, size.Y)\n\n\timg0.WritePixels(img.Pix)\n\tfor j := 0; j < img0.Bounds().Dy(); j++ {\n\t\tfor i := 0; i < img0.Bounds().Dx(); i++ {\n\t\t\tgot := img0.At(i, j)\n\t\t\twant := img.At(i, j)\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img0 At(%d, %d): got %v; want %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\tp := make([]uint8, 4*size.X*size.Y)\n\tfor i := range p {\n\t\tp[i] = 0x80\n\t}\n\timg0.WritePixels(p)\n\t// Even if p is changed after calling ReplacePixel, img0 uses the original values.\n\tfor i := range p {\n\t\tp[i] = 0\n\t}\n\tfor j := 0; j < img0.Bounds().Dy(); j++ {\n\t\tfor i := 0; i < img0.Bounds().Dx(); i++ {\n\t\t\tgot := img0.At(i, j)\n\t\t\twant := color.RGBA{R: 0x80, G: 0x80, B: 0x80, A: 0x80}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img0 At(%d, %d): got %v; want %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageWritePixelsNil(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"WritePixels(nil) must panic\")\n\t\t}\n\t}()\n\n\timg := ebiten.NewImage(16, 16)\n\timg.Fill(color.White)\n\timg.WritePixels(nil)\n}\n\nfunc TestImageDispose(t *testing.T) {\n\timg := ebiten.NewImage(16, 16)\n\timg.Fill(color.White)\n\timg.Dispose()\n\n\t// The color is transparent (color.RGBA{}).\n\t// Note that the value's type must be color.RGBA.\n\tgot := img.At(0, 0)\n\twant := color.RGBA{}\n\tif got != want {\n\t\tt.Errorf(\"img.At(0, 0) got: %v, want: %v\", got, want)\n\t}\n}\n\nfunc TestImageDeallocate(t *testing.T) {\n\timg := ebiten.NewImage(16, 16)\n\timg.Fill(color.White)\n\timg.Deallocate()\n\n\t// The color is transparent (color.RGBA{}).\n\tgot := img.At(0, 0)\n\twant := color.RGBA{}\n\tif got != want {\n\t\tt.Errorf(\"img.At(0, 0) got: %v, want: %v\", got, want)\n\t}\n}\n\nfunc TestImageBlendLighter(t *testing.T) {\n\timg0, _, err := openEbitenImage()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn\n\t}\n\n\tw, h := img0.Bounds().Dx(), img0.Bounds().Dy()\n\timg1 := ebiten.NewImage(w, h)\n\timg1.Fill(color.RGBA{R: 0x01, G: 0x02, B: 0x03, A: 0x04})\n\top := &ebiten.DrawImageOptions{}\n\top.Blend = ebiten.BlendLighter\n\timg1.DrawImage(img0, op)\n\tfor j := 0; j < img1.Bounds().Dy(); j++ {\n\t\tfor i := 0; i < img1.Bounds().Dx(); i++ {\n\t\t\tgot := img1.At(i, j).(color.RGBA)\n\t\t\twant := img0.At(i, j).(color.RGBA)\n\t\t\twant.R = uint8(min(0xff, int(want.R)+1))\n\t\t\twant.G = uint8(min(0xff, int(want.G)+2))\n\t\t\twant.B = uint8(min(0xff, int(want.B)+3))\n\t\t\twant.A = uint8(min(0xff, int(want.A)+4))\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img1 At(%d, %d): got %v; want %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNewImageFromEbitenImage(t *testing.T) {\n\timg, _, err := openEbitenImage()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn\n\t}\n\t_ = ebiten.NewImageFromImage(img)\n}\n\nfunc TestNewImageFromSubImage(t *testing.T) {\n\t_, img, err := openEbitenImage()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn\n\t}\n\tw, h := img.Bounds().Dx(), img.Bounds().Dy()\n\tsubImg := img.(*image.NRGBA).SubImage(image.Rect(1, 1, w-1, h-1))\n\teimg := ebiten.NewImageFromImage(subImg)\n\tsw, sh := subImg.Bounds().Dx(), subImg.Bounds().Dy()\n\tw2, h2 := eimg.Bounds().Dx(), eimg.Bounds().Dy()\n\tif w2 != sw {\n\t\tt.Errorf(\"eimg Width: got %v; want %v\", w2, sw)\n\t}\n\tif h2 != sh {\n\t\tt.Errorf(\"eimg Width: got %v; want %v\", h2, sh)\n\t}\n\tfor j := 0; j < h2; j++ {\n\t\tfor i := 0; i < w2; i++ {\n\t\t\tgot := eimg.At(i, j)\n\t\t\twant := color.RGBAModel.Convert(img.At(i+1, j+1))\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img0 At(%d, %d): got %v; want %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype mutableRGBA struct {\n\tr, g, b, a uint8\n}\n\nfunc (c *mutableRGBA) RGBA() (r, g, b, a uint32) {\n\treturn uint32(c.r) * 0x101, uint32(c.g) * 0x101, uint32(c.b) * 0x101, uint32(c.a) * 0x101\n}\n\nfunc TestImageFill(t *testing.T) {\n\tw, h := 10, 10\n\timg := ebiten.NewImage(w, h)\n\tclr := &mutableRGBA{0x80, 0x80, 0x80, 0x80}\n\timg.Fill(clr)\n\tclr.r = 0\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := img.At(i, j)\n\t\t\twant := color.RGBA{R: 0x80, G: 0x80, B: 0x80, A: 0x80}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img At(%d, %d): got %v; want %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #740\nfunc TestImageClear(t *testing.T) {\n\tconst w, h = 128, 256\n\timg := ebiten.NewImage(w, h)\n\timg.Fill(color.White)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := img.At(i, j)\n\t\t\twant := color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img At(%d, %d): got %v; want %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\timg.Clear()\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := img.At(i, j)\n\t\t\twant := color.RGBA{}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img At(%d, %d): got %v; want %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #317, #558, #724\nfunc TestImageEdge(t *testing.T) {\n\t// TODO: This test is not so meaningful after #1218. Do we remove this?\n\n\tif skipTooSlowTests(t) {\n\t\treturn\n\t}\n\n\tconst (\n\t\timg0Width       = 10\n\t\timg0Height      = 10\n\t\timg0InnerWidth  = 10\n\t\timg0InnerHeight = 10\n\n\t\timg1Width  = 32\n\t\timg1Height = 32\n\t)\n\timg0 := ebiten.NewImage(img0Width, img0Height)\n\tpixels := make([]uint8, 4*img0Width*img0Height)\n\tfor j := 0; j < img0Height; j++ {\n\t\tfor i := 0; i < img0Width; i++ {\n\t\t\tidx := 4 * (i + j*img0Width)\n\t\t\tpixels[idx] = 0xff\n\t\t\tpixels[idx+1] = 0\n\t\t\tpixels[idx+2] = 0\n\t\t\tpixels[idx+3] = 0xff\n\t\t}\n\t}\n\timg0.WritePixels(pixels)\n\timg1 := ebiten.NewImage(img1Width, img1Height)\n\tred := color.RGBA{R: 0xff, A: 0xff}\n\ttransparent := color.RGBA{}\n\n\tangles := []float64{}\n\tfor a := 0; a < 1440; a++ {\n\t\tangles = append(angles, float64(a)/1440*2*math.Pi)\n\t}\n\tfor a := 0; a < 4096; a += 3 {\n\t\t// a++ should be fine, but it takes long to test.\n\t\tangles = append(angles, float64(a)/4096*2*math.Pi)\n\t}\n\n\tfor _, s := range []float64{1, 0.5, 0.25} {\n\t\tfor _, f := range []ebiten.Filter{ebiten.FilterNearest, ebiten.FilterLinear} {\n\t\t\tfor _, a := range angles {\n\t\t\t\tfor _, testDrawTriangles := range []bool{false, true} {\n\t\t\t\t\timg1.Clear()\n\t\t\t\t\tw, h := img0.Bounds().Dx(), img0.Bounds().Dy()\n\t\t\t\t\tb := img0.Bounds()\n\t\t\t\t\tvar geo ebiten.GeoM\n\t\t\t\t\tgeo.Translate(-float64(w)/2, -float64(h)/2)\n\t\t\t\t\tgeo.Scale(s, s)\n\t\t\t\t\tgeo.Rotate(a)\n\t\t\t\t\tgeo.Translate(img1Width/2, img1Height/2)\n\t\t\t\t\tif !testDrawTriangles {\n\t\t\t\t\t\top := &ebiten.DrawImageOptions{}\n\t\t\t\t\t\top.GeoM = geo\n\t\t\t\t\t\top.Filter = f\n\t\t\t\t\t\timg1.DrawImage(img0, op)\n\t\t\t\t\t} else {\n\t\t\t\t\t\top := &ebiten.DrawTrianglesOptions{}\n\t\t\t\t\t\tdx0, dy0 := geo.Apply(0, 0)\n\t\t\t\t\t\tdx1, dy1 := geo.Apply(float64(w), 0)\n\t\t\t\t\t\tdx2, dy2 := geo.Apply(0, float64(h))\n\t\t\t\t\t\tdx3, dy3 := geo.Apply(float64(w), float64(h))\n\t\t\t\t\t\tvs := []ebiten.Vertex{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDstX:   float32(dx0),\n\t\t\t\t\t\t\t\tDstY:   float32(dy0),\n\t\t\t\t\t\t\t\tSrcX:   float32(b.Min.X),\n\t\t\t\t\t\t\t\tSrcY:   float32(b.Min.Y),\n\t\t\t\t\t\t\t\tColorR: 1,\n\t\t\t\t\t\t\t\tColorG: 1,\n\t\t\t\t\t\t\t\tColorB: 1,\n\t\t\t\t\t\t\t\tColorA: 1,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDstX:   float32(dx1),\n\t\t\t\t\t\t\t\tDstY:   float32(dy1),\n\t\t\t\t\t\t\t\tSrcX:   float32(b.Max.X),\n\t\t\t\t\t\t\t\tSrcY:   float32(b.Min.Y),\n\t\t\t\t\t\t\t\tColorR: 1,\n\t\t\t\t\t\t\t\tColorG: 1,\n\t\t\t\t\t\t\t\tColorB: 1,\n\t\t\t\t\t\t\t\tColorA: 1,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDstX:   float32(dx2),\n\t\t\t\t\t\t\t\tDstY:   float32(dy2),\n\t\t\t\t\t\t\t\tSrcX:   float32(b.Min.X),\n\t\t\t\t\t\t\t\tSrcY:   float32(b.Max.Y),\n\t\t\t\t\t\t\t\tColorR: 1,\n\t\t\t\t\t\t\t\tColorG: 1,\n\t\t\t\t\t\t\t\tColorB: 1,\n\t\t\t\t\t\t\t\tColorA: 1,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDstX:   float32(dx3),\n\t\t\t\t\t\t\t\tDstY:   float32(dy3),\n\t\t\t\t\t\t\t\tSrcX:   float32(b.Max.X),\n\t\t\t\t\t\t\t\tSrcY:   float32(b.Max.Y),\n\t\t\t\t\t\t\t\tColorR: 1,\n\t\t\t\t\t\t\t\tColorG: 1,\n\t\t\t\t\t\t\t\tColorB: 1,\n\t\t\t\t\t\t\t\tColorA: 1,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}\n\t\t\t\t\t\tis := []uint16{0, 1, 2, 1, 2, 3}\n\t\t\t\t\t\top.Filter = f\n\t\t\t\t\t\timg1.DrawTriangles(vs, is, img0, op)\n\t\t\t\t\t}\n\t\t\t\t\tallTransparent := true\n\t\t\t\t\tfor j := 0; j < img1Height; j++ {\n\t\t\t\t\t\tfor i := 0; i < img1Width; i++ {\n\t\t\t\t\t\t\tc := img1.At(i, j)\n\t\t\t\t\t\t\tif c == transparent {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tallTransparent = false\n\t\t\t\t\t\t\tswitch f {\n\t\t\t\t\t\t\tcase ebiten.FilterNearest:\n\t\t\t\t\t\t\t\tif c == red {\n\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase ebiten.FilterLinear:\n\t\t\t\t\t\t\t\tif _, g, b, _ := c.RGBA(); g == 0 && b == 0 {\n\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tt.Fatalf(\"img1.At(%d, %d) (filter: %d, scale: %f, angle: %f, draw-triangles?: %t) want: red or transparent, got: %v\", i, j, f, s, a, testDrawTriangles, c)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif allTransparent {\n\t\t\t\t\t\tt.Fatalf(\"img1 (filter: %d, scale: %f, angle: %f, draw-triangles?: %t) is transparent but should not\", f, s, a, testDrawTriangles)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #419\nfunc TestImageTooManyFill(t *testing.T) {\n\tconst width = 1024\n\n\tindexToColor := func(index int) uint8 {\n\t\treturn uint8((17*index + 0x40) % 256)\n\t}\n\n\tsrc := ebiten.NewImage(1, 1)\n\tdst := ebiten.NewImage(width, 1)\n\tfor i := 0; i < width; i++ {\n\t\tc := indexToColor(i)\n\t\tsrc.Fill(color.RGBA{R: c, G: c, B: c, A: 0xff})\n\t\top := &ebiten.DrawImageOptions{}\n\t\top.GeoM.Translate(float64(i), 0)\n\t\tdst.DrawImage(src, op)\n\t}\n\n\tfor i := 0; i < width; i++ {\n\t\tc := indexToColor(i)\n\t\tgot := dst.At(i, 0).(color.RGBA)\n\t\twant := color.RGBA{R: c, G: c, B: c, A: 0xff}\n\t\tif !sameColors(got, want, 1) {\n\t\t\tt.Errorf(\"dst.At(%d, %d): got %v, want: %v\", i, 0, got, want)\n\t\t}\n\t}\n}\n\nfunc BenchmarkDrawImage(b *testing.B) {\n\timg0 := ebiten.NewImage(16, 16)\n\timg1 := ebiten.NewImage(16, 16)\n\top := &ebiten.DrawImageOptions{}\n\tfor i := 0; i < b.N; i++ {\n\t\timg0.DrawImage(img1, op)\n\t}\n}\n\nfunc BenchmarkDrawTriangles(b *testing.B) {\n\tconst w, h = 16, 16\n\timg0 := ebiten.NewImage(w, h)\n\timg1 := ebiten.NewImage(w, h)\n\top := &ebiten.DrawTrianglesOptions{}\n\tvs := []ebiten.Vertex{\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t}\n\tis := []uint16{0, 1, 2, 1, 2, 3}\n\tfor i := 0; i < b.N; i++ {\n\t\timg0.DrawTriangles(vs, is, img1, op)\n\t}\n}\n\nfunc TestImageLinearGraduation(t *testing.T) {\n\timg0 := ebiten.NewImage(2, 2)\n\timg0.WritePixels([]byte{\n\t\t0xff, 0x00, 0x00, 0xff,\n\t\t0x00, 0xff, 0x00, 0xff,\n\t\t0x00, 0x00, 0xff, 0xff,\n\t\t0xff, 0xff, 0xff, 0xff,\n\t})\n\n\tconst w, h = 32, 32\n\timg1 := ebiten.NewImage(w, h)\n\top := &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(w, h)\n\top.GeoM.Translate(-w/4, -h/4)\n\top.Filter = ebiten.FilterLinear\n\timg1.DrawImage(img0, op)\n\n\tfor j := 1; j < h-1; j++ {\n\t\tfor i := 1; i < w-1; i++ {\n\t\t\tc := img1.At(i, j).(color.RGBA)\n\t\t\tif c.R == 0 || c.R == 0xff {\n\t\t\t\tt.Errorf(\"img1.At(%d, %d).R must be in between 0x01 and 0xfe but %v\", i, j, c)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageOutside(t *testing.T) {\n\tsrc := ebiten.NewImage(5, 10) // internal texture size is 8x16.\n\tdst := ebiten.NewImage(4, 4)\n\tsrc.Fill(color.RGBA{R: 0xff, A: 0xff})\n\n\tcases := []struct {\n\t\tX, Y, Width, Height int\n\t}{\n\t\t{-4, -4, 4, 4},\n\t\t{5, 0, 4, 4},\n\t\t{0, 10, 4, 4},\n\t\t{5, 10, 4, 4},\n\t\t{8, 0, 4, 4},\n\t\t{0, 16, 4, 4},\n\t\t{8, 16, 4, 4},\n\t\t{8, -4, 4, 4},\n\t\t{-4, 16, 4, 4},\n\t\t{5, 10, 0, 0},\n\t\t{5, 10, -2, -2}, // non-well-formed rectangle\n\t}\n\tfor _, c := range cases {\n\t\tdst.Clear()\n\n\t\top := &ebiten.DrawImageOptions{}\n\t\top.GeoM.Translate(0, 0)\n\t\tdst.DrawImage(src.SubImage(image.Rectangle{\n\t\t\tMin: image.Pt(c.X, c.Y),\n\t\t\tMax: image.Pt(c.X+c.Width, c.Y+c.Height),\n\t\t}).(*ebiten.Image), op)\n\n\t\tfor j := 0; j < 4; j++ {\n\t\t\tfor i := 0; i < 4; i++ {\n\t\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\t\twant := color.RGBA{}\n\t\t\t\tif got != want {\n\t\t\t\t\tt.Errorf(\"src(x: %d, y: %d, w: %d, h: %d), dst At(%d, %d): got %v, want: %v\", c.X, c.Y, c.Width, c.Height, i, j, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageOutsideUpperLeft(t *testing.T) {\n\tsrc := ebiten.NewImage(4, 4)\n\tdst1 := ebiten.NewImage(16, 16)\n\tdst2 := ebiten.NewImage(16, 16)\n\tsrc.Fill(color.RGBA{R: 0xff, A: 0xff})\n\n\top := &ebiten.DrawImageOptions{}\n\top.GeoM.Rotate(math.Pi / 4)\n\tdst1.DrawImage(src.SubImage(image.Rect(-4, -4, 8, 8)).(*ebiten.Image), op)\n\n\top = &ebiten.DrawImageOptions{}\n\top.GeoM.Rotate(math.Pi / 4)\n\tdst2.DrawImage(src, op)\n\n\tfor j := 0; j < 16; j++ {\n\t\tfor i := 0; i < 16; i++ {\n\t\t\tgot := dst1.At(i, j).(color.RGBA)\n\t\t\twant := dst2.At(i, j).(color.RGBA)\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"got: dst1.At(%d, %d): %v, want: dst2.At(%d, %d): %v\", i, j, got, i, j, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageSize(t *testing.T) {\n\tconst (\n\t\tw = 17\n\t\th = 31\n\t)\n\timg := ebiten.NewImage(w, h)\n\tgotW, gotH := img.Bounds().Dx(), img.Bounds().Dy()\n\tif gotW != w {\n\t\tt.Errorf(\"got: %d, want: %d\", gotW, w)\n\t}\n\tif gotH != h {\n\t\tt.Errorf(\"got: %d, want: %d\", gotH, h)\n\t}\n}\n\nfunc TestImageSize1(t *testing.T) {\n\tsrc := ebiten.NewImage(1, 1)\n\tdst := ebiten.NewImage(1, 1)\n\tsrc.Fill(color.White)\n\tdst.DrawImage(src, nil)\n\tgot := src.At(0, 0).(color.RGBA)\n\twant := color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\tif !sameColors(got, want, 1) {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n}\n\n// TODO: Enable this test again. This test fails after #1217 is fixed.\nfunc Skip_TestImageSize4096(t *testing.T) {\n\tsrc := ebiten.NewImage(4096, 4096)\n\tdst := ebiten.NewImage(4096, 4096)\n\tpix := make([]byte, 4096*4096*4)\n\tfor i := 0; i < 4096; i++ {\n\t\tj := 4095\n\t\tidx := 4 * (i + j*4096)\n\t\tpix[idx] = uint8(i + j)\n\t\tpix[idx+1] = uint8((i + j) >> 8)\n\t\tpix[idx+2] = uint8((i + j) >> 16)\n\t\tpix[idx+3] = 0xff\n\t}\n\tfor j := 0; j < 4096; j++ {\n\t\ti := 4095\n\t\tidx := 4 * (i + j*4096)\n\t\tpix[idx] = uint8(i + j)\n\t\tpix[idx+1] = uint8((i + j) >> 8)\n\t\tpix[idx+2] = uint8((i + j) >> 16)\n\t\tpix[idx+3] = 0xff\n\t}\n\tsrc.WritePixels(pix)\n\tdst.DrawImage(src, nil)\n\tfor i := 4095; i < 4096; i++ {\n\t\tj := 4095\n\t\tgot := dst.At(i, j).(color.RGBA)\n\t\twant := color.RGBA{R: uint8(i + j), G: uint8((i + j) >> 8), B: uint8((i + j) >> 16), A: 0xff}\n\t\tif got != want {\n\t\t\tt.Errorf(\"At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t}\n\t}\n\tfor j := 4095; j < 4096; j++ {\n\t\ti := 4095\n\t\tgot := dst.At(i, j).(color.RGBA)\n\t\twant := color.RGBA{R: uint8(i + j), G: uint8((i + j) >> 8), B: uint8((i + j) >> 16), A: 0xff}\n\t\tif got != want {\n\t\t\tt.Errorf(\"At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t}\n\t}\n}\n\nfunc TestImageCopy(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"copying image and using it must panic\")\n\t\t}\n\t}()\n\n\timg0 := ebiten.NewImage(256, 256)\n\timg1 := *img0\n\timg1.Fill(color.Transparent)\n}\n\n// Issue #611, #907\nfunc TestImageStretch(t *testing.T) {\n\tif skipTooSlowTests(t) {\n\t\treturn\n\t}\n\n\tconst w = 16\n\n\tdst := ebiten.NewImage(w, maxImageSize)\nloop:\n\tfor h := 1; h <= 32; h++ {\n\t\tsrc := ebiten.NewImage(w+2, h+2)\n\n\t\tpix := make([]byte, 4*(w+2)*(h+2))\n\t\tfor i := 0; i < (w+2)*(h+2); i++ {\n\t\t\tpix[4*i] = 0xff\n\t\t\tpix[4*i+3] = 0xff\n\t\t}\n\t\tsrc.WritePixels(pix)\n\n\t\tdh := dst.Bounds().Dy()\n\t\tfor i := 0; i < dh; {\n\t\t\tdst.Clear()\n\t\t\top := &ebiten.DrawImageOptions{}\n\t\t\top.GeoM.Scale(1, float64(i)/float64(h))\n\t\t\tdst.DrawImage(src.SubImage(image.Rect(1, 1, w+1, h+1)).(*ebiten.Image), op)\n\t\t\tfor j := -1; j <= 1; j++ {\n\t\t\t\tif i+j < 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tgot := dst.At(0, i+j).(color.RGBA)\n\t\t\t\twant := color.RGBA{}\n\t\t\t\tif j < 0 {\n\t\t\t\t\twant = color.RGBA{R: 0xff, A: 0xff}\n\t\t\t\t}\n\t\t\t\tif got != want {\n\t\t\t\t\tt.Errorf(\"At(%d, %d) (height=%d, scale=%d/%d): got: %v, want: %v\", 0, i+j, h, i, h, got, want)\n\t\t\t\t\tcontinue loop\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch i % 32 {\n\t\t\tcase 31, 0:\n\t\t\t\ti++\n\t\t\tcase 1:\n\t\t\t\ti += 32 - 2\n\t\t\tdefault:\n\t\t\t\tpanic(\"not reached\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageSprites(t *testing.T) {\n\tconst (\n\t\twidth  = 512\n\t\theight = 512\n\t)\n\n\tsrc := ebiten.NewImage(4, 4)\n\tsrc.Fill(color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff})\n\tdst := ebiten.NewImage(width, height)\n\tfor j := 0; j < height/4; j++ {\n\t\tfor i := 0; i < width/4; i++ {\n\t\t\top := &ebiten.DrawImageOptions{}\n\t\t\top.GeoM.Translate(float64(i*4), float64(j*4))\n\t\t\tdst.DrawImage(src, op)\n\t\t}\n\t}\n\n\tfor j := 0; j < height/4; j++ {\n\t\tfor i := 0; i < width/4; i++ {\n\t\t\tgot := dst.At(i*4, j*4).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\t\t\tif !sameColors(got, want, 1) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got %v, want: %v\", i*4, j*4, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Disabled: it does not make sense to expect deterministic mipmap results (#909).\nfunc Disabled_TestImageMipmap(t *testing.T) {\n\tsrc, _, err := openEbitenImage()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn\n\t}\n\tw, h := src.Bounds().Dx(), src.Bounds().Dy()\n\n\tl1 := ebiten.NewImage(w/2, h/2)\n\top := &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(1/2.0, 1/2.0)\n\top.Filter = ebiten.FilterLinear\n\tl1.DrawImage(src, op)\n\n\tl1w, l1h := l1.Bounds().Dx(), l1.Bounds().Dy()\n\tl2 := ebiten.NewImage(l1w/2, l1h/2)\n\top = &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(1/2.0, 1/2.0)\n\top.Filter = ebiten.FilterLinear\n\tl2.DrawImage(l1, op)\n\n\tgotDst := ebiten.NewImage(w, h)\n\top = &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(1/5.0, 1/5.0)\n\top.Filter = ebiten.FilterLinear\n\tgotDst.DrawImage(src, op)\n\n\twantDst := ebiten.NewImage(w, h)\n\top = &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(4.0/5.0, 4.0/5.0)\n\top.Filter = ebiten.FilterLinear\n\twantDst.DrawImage(l2, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := gotDst.At(i, j).(color.RGBA)\n\t\t\twant := wantDst.At(i, j).(color.RGBA)\n\t\t\tif !sameColors(got, want, 1) {\n\t\t\t\tt.Errorf(\"At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Disabled: it does not make sense to expect deterministic mipmap results (#909).\nfunc Disabled_TestImageMipmapNegativeDet(t *testing.T) {\n\tsrc, _, err := openEbitenImage()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn\n\t}\n\tw, h := src.Bounds().Dx(), src.Bounds().Dy()\n\n\tl1 := ebiten.NewImage(w/2, h/2)\n\top := &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(1/2.0, 1/2.0)\n\top.Filter = ebiten.FilterLinear\n\tl1.DrawImage(src, op)\n\n\tl1w, l1h := l1.Bounds().Dx(), l1.Bounds().Dy()\n\tl2 := ebiten.NewImage(l1w/2, l1h/2)\n\top = &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(1/2.0, 1/2.0)\n\top.Filter = ebiten.FilterLinear\n\tl2.DrawImage(l1, op)\n\n\tgotDst := ebiten.NewImage(w, h)\n\top = &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(-1/5.0, -1/5.0)\n\top.GeoM.Translate(float64(w), float64(h))\n\top.Filter = ebiten.FilterLinear\n\tgotDst.DrawImage(src, op)\n\n\twantDst := ebiten.NewImage(w, h)\n\top = &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(-4.0/5.0, -4.0/5.0)\n\top.GeoM.Translate(float64(w), float64(h))\n\top.Filter = ebiten.FilterLinear\n\twantDst.DrawImage(l2, op)\n\n\tallZero := true\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := gotDst.At(i, j).(color.RGBA)\n\t\t\twant := wantDst.At(i, j).(color.RGBA)\n\t\t\tif !sameColors(got, want, 1) {\n\t\t\t\tt.Errorf(\"At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t\tif got.A > 0 {\n\t\t\t\tallZero = false\n\t\t\t}\n\t\t}\n\t}\n\n\tif allZero {\n\t\tt.Errorf(\"the image must include non-zero values but not\")\n\t}\n}\n\n// Issue #710\nfunc TestImageMipmapColor(t *testing.T) {\n\timg0 := ebiten.NewImage(256, 256)\n\timg1 := ebiten.NewImage(128, 128)\n\timg1.Fill(color.White)\n\n\tfor i := 0; i < 8; i++ {\n\t\timg0.Clear()\n\n\t\ts := 1 - float64(i)/8\n\n\t\top := &ebiten.DrawImageOptions{}\n\t\top.Filter = ebiten.FilterLinear\n\t\top.GeoM.Scale(s, s)\n\t\top.ColorScale.Scale(1, 1, 0, 1)\n\t\timg0.DrawImage(img1, op)\n\n\t\top.GeoM.Translate(128, 0)\n\t\top.ColorScale.Reset()\n\t\top.ColorScale.Scale(0, 1, 1, 1)\n\t\timg0.DrawImage(img1, op)\n\n\t\twant := color.RGBA{G: 0xff, B: 0xff, A: 0xff}\n\t\tgot := img0.At(128, 0)\n\t\tif got != want {\n\t\t\tt.Errorf(\"want: %v, got: %v\", want, got)\n\t\t}\n\t}\n}\n\n// Issue #725\nfunc TestImageMiamapAndDrawTriangle(t *testing.T) {\n\timg0 := ebiten.NewImage(32, 32)\n\timg1 := ebiten.NewImage(128, 128)\n\timg2 := ebiten.NewImage(128, 128)\n\n\t// Fill img1 red and create img1's mipmap\n\timg1.Fill(color.RGBA{R: 0xff, A: 0xff})\n\top := &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(0.25, 0.25)\n\top.Filter = ebiten.FilterLinear\n\timg0.DrawImage(img1, op)\n\n\t// Call DrawTriangle on img1 and fill it with green\n\timg2.Fill(color.RGBA{G: 0xff, A: 0xff})\n\tvs := []ebiten.Vertex{\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   128,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   128,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   128,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   128,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   128,\n\t\t\tDstY:   128,\n\t\t\tSrcX:   128,\n\t\t\tSrcY:   128,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t}\n\timg1.DrawTriangles(vs, []uint16{0, 1, 2, 1, 2, 3}, img2, nil)\n\n\t// Draw img1 (green) again. Confirm mipmap is correctly updated.\n\timg0.Clear()\n\top = &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(0.25, 0.25)\n\top.Filter = ebiten.FilterLinear\n\timg0.DrawImage(img1, op)\n\n\tw, h := img0.Bounds().Dx(), img0.Bounds().Dy()\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tc := img0.At(i, j).(color.RGBA)\n\t\t\tif c.R != 0 {\n\t\t\t\tt.Errorf(\"img0.At(%d, %d): red want %d got %d\", i, j, 0, c.R)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageSubImageAt(t *testing.T) {\n\timg := ebiten.NewImage(16, 16)\n\timg.Fill(color.RGBA{R: 0xff, A: 0xff})\n\n\tgot := img.SubImage(image.Rect(1, 1, 16, 16)).At(0, 0).(color.RGBA)\n\twant := color.RGBA{}\n\tif got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n\n\tgot = img.SubImage(image.Rect(1, 1, 16, 16)).At(1, 1).(color.RGBA)\n\twant = color.RGBA{R: 0xff, A: 0xff}\n\tif got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n}\n\nfunc TestImageSubImageSize(t *testing.T) {\n\timg := ebiten.NewImage(16, 16)\n\timg.Fill(color.RGBA{R: 0xff, A: 0xff})\n\n\tgot := img.SubImage(image.Rect(1, 1, 16, 16)).Bounds().Dx()\n\twant := 15\n\tif got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n}\n\nfunc TestImageDrawImmediately(t *testing.T) {\n\tconst w, h = 16, 16\n\timg0 := ebiten.NewImage(w, h)\n\timg1 := ebiten.NewImage(w, h)\n\t// Do not manipulate img0 here.\n\n\timg0.Fill(color.RGBA{R: 0xff, A: 0xff})\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := img0.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0xff, A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img0.At(%d, %d): got %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\timg0.DrawImage(img1, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := img0.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0xff, A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img0.At(%d, %d): got %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #669, #759\nfunc TestImageLinearFilterGlitch(t *testing.T) {\n\tconst w, h = 200, 12\n\tconst scale = 1.2\n\tsrc := ebiten.NewImage(w, h)\n\tdst := ebiten.NewImage(int(math.Floor(w*scale)), h)\n\n\tpix := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tidx := i + w*j\n\t\t\tif j < 3 {\n\t\t\t\tpix[4*idx] = 0xff\n\t\t\t\tpix[4*idx+1] = 0xff\n\t\t\t\tpix[4*idx+2] = 0xff\n\t\t\t\tpix[4*idx+3] = 0xff\n\t\t\t} else {\n\t\t\t\tpix[4*idx] = 0\n\t\t\t\tpix[4*idx+1] = 0\n\t\t\t\tpix[4*idx+2] = 0\n\t\t\t\tpix[4*idx+3] = 0xff\n\t\t\t}\n\t\t}\n\t}\n\tsrc.WritePixels(pix)\n\n\tfor _, f := range []ebiten.Filter{ebiten.FilterNearest, ebiten.FilterLinear} {\n\t\top := &ebiten.DrawImageOptions{}\n\t\top.GeoM.Scale(scale, 1)\n\t\top.Filter = f\n\t\tdst.DrawImage(src, op)\n\n\t\tfor j := 1; j < h-1; j++ {\n\t\t\toffset := int(math.Ceil(scale))\n\t\t\tfor i := offset; i < int(math.Floor(w*scale))-offset; i++ {\n\t\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\t\tvar want color.RGBA\n\t\t\t\tif j < 3 {\n\t\t\t\t\twant = color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\t\t\t\t} else {\n\t\t\t\t\twant = color.RGBA{A: 0xff}\n\t\t\t\t}\n\t\t\t\tif got != want {\n\t\t\t\t\tt.Errorf(\"dst.At(%d, %d): filter: %d, got: %v, want: %v\", i, j, f, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #1212\nfunc TestImageLinearFilterGlitch2(t *testing.T) {\n\tconst w, h = 100, 100\n\tsrc := ebiten.NewImage(w, h)\n\tdst := ebiten.NewImage(w, h)\n\n\tidx := 0\n\tpix := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tif i+j < 100 {\n\t\t\t\tpix[4*idx] = 0\n\t\t\t\tpix[4*idx+1] = 0\n\t\t\t\tpix[4*idx+2] = 0\n\t\t\t\tpix[4*idx+3] = 0xff\n\t\t\t} else {\n\t\t\t\tpix[4*idx] = 0xff\n\t\t\t\tpix[4*idx+1] = 0xff\n\t\t\t\tpix[4*idx+2] = 0xff\n\t\t\t\tpix[4*idx+3] = 0xff\n\t\t\t}\n\t\t\tidx++\n\t\t}\n\t}\n\tsrc.WritePixels(pix)\n\n\top := &ebiten.DrawImageOptions{}\n\top.Filter = ebiten.FilterLinear\n\tdst.DrawImage(src, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\tvar want color.RGBA\n\t\t\tif i+j < 100 {\n\t\t\t\twant = color.RGBA{A: 0xff}\n\t\t\t} else {\n\t\t\t\twant = color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\t\t\t}\n\t\t\tif !sameColors(got, want, 1) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageAddressRepeat(t *testing.T) {\n\tconst w, h = 16, 16\n\tsrc := ebiten.NewImage(w, h)\n\tdst := ebiten.NewImage(w, h)\n\tpix := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tidx := 4 * (i + j*w)\n\t\t\tif 4 <= i && i < 8 && 4 <= j && j < 8 {\n\t\t\t\tpix[idx] = byte(i-4) * 0x10\n\t\t\t\tpix[idx+1] = byte(j-4) * 0x10\n\t\t\t\tpix[idx+2] = 0\n\t\t\t\tpix[idx+3] = 0xff\n\t\t\t} else {\n\t\t\t\tpix[idx] = 0\n\t\t\t\tpix[idx+1] = 0\n\t\t\t\tpix[idx+2] = 0xff\n\t\t\t\tpix[idx+3] = 0xff\n\t\t\t}\n\t\t}\n\t}\n\tsrc.WritePixels(pix)\n\n\tvs := []ebiten.Vertex{\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t}\n\tis := []uint16{0, 1, 2, 1, 2, 3}\n\top := &ebiten.DrawTrianglesOptions{}\n\top.Address = ebiten.AddressRepeat\n\tdst.DrawTriangles(vs, is, src.SubImage(image.Rect(4, 4, 8, 8)).(*ebiten.Image), op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: byte(i%4) * 0x10, G: byte(j%4) * 0x10, A: 0xff}\n\t\t\tif !sameColors(got, want, 1) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageAddressRepeatNegativePosition(t *testing.T) {\n\tconst w, h = 16, 16\n\tsrc := ebiten.NewImage(w, h)\n\tdst := ebiten.NewImage(w, h)\n\tpix := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tidx := 4 * (i + j*w)\n\t\t\tif 4 <= i && i < 8 && 4 <= j && j < 8 {\n\t\t\t\tpix[idx] = byte(i-4) * 0x10\n\t\t\t\tpix[idx+1] = byte(j-4) * 0x10\n\t\t\t\tpix[idx+2] = 0\n\t\t\t\tpix[idx+3] = 0xff\n\t\t\t} else {\n\t\t\t\tpix[idx] = 0\n\t\t\t\tpix[idx+1] = 0\n\t\t\t\tpix[idx+2] = 0xff\n\t\t\t\tpix[idx+3] = 0xff\n\t\t\t}\n\t\t}\n\t}\n\tsrc.WritePixels(pix)\n\n\tvs := []ebiten.Vertex{\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   -w,\n\t\t\tSrcY:   -h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   -h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   -w,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t}\n\tis := []uint16{0, 1, 2, 1, 2, 3}\n\top := &ebiten.DrawTrianglesOptions{}\n\top.Address = ebiten.AddressRepeat\n\tdst.DrawTriangles(vs, is, src.SubImage(image.Rect(4, 4, 8, 8)).(*ebiten.Image), op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: byte(i%4) * 0x10, G: byte(j%4) * 0x10, A: 0xff}\n\t\t\tif !sameColors(got, want, 1) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageWritePixelsAfterClear(t *testing.T) {\n\tconst w, h = 256, 256\n\timg := ebiten.NewImage(w, h)\n\timg.WritePixels(make([]byte, 4*w*h))\n\t// Clear used to call DrawImage to clear the image, which was the cause of crash. It is because after\n\t// DrawImage is called, WritePixels for a region is forbidden.\n\t//\n\t// Now WritePixels was always called at Clear instead.\n\timg.Clear()\n\timg.WritePixels(make([]byte, 4*w*h))\n\n\t// The test passes if this doesn't crash.\n}\n\nfunc TestImageSet(t *testing.T) {\n\ttype Pt struct {\n\t\tX, Y int\n\t}\n\n\tconst w, h = 16, 16\n\timg := ebiten.NewImage(w, h)\n\tcolors := map[Pt]color.RGBA{\n\t\t{1, 2}:   {3, 4, 5, 6},\n\t\t{7, 8}:   {9, 10, 11, 12},\n\t\t{13, 14}: {15, 16, 17, 18},\n\t\t{-1, -1}: {19, 20, 21, 22},\n\t}\n\n\tfor p, c := range colors {\n\t\timg.Set(p.X, p.Y, c)\n\t}\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := img.At(i, j).(color.RGBA)\n\t\t\tvar want color.RGBA\n\t\t\tif c, ok := colors[Pt{i, j}]; ok {\n\t\t\t\twant = c\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageSetAndDraw(t *testing.T) {\n\ttype Pt struct {\n\t\tX, Y int\n\t}\n\n\tconst w, h = 16, 16\n\tsrc := ebiten.NewImage(w, h)\n\tdst := ebiten.NewImage(w, h)\n\tcolors := map[Pt]color.RGBA{\n\t\t{1, 2}:   {3, 4, 5, 6},\n\t\t{7, 8}:   {9, 10, 11, 12},\n\t\t{13, 14}: {15, 16, 17, 18},\n\t}\n\tfor p, c := range colors {\n\t\tsrc.Set(p.X, p.Y, c)\n\t\tdst.Set(p.X+1, p.Y+1, c)\n\t}\n\n\tdst.DrawImage(src, nil)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\tvar want color.RGBA\n\t\t\tif c, ok := colors[Pt{i, j}]; ok {\n\t\t\t\twant = c\n\t\t\t}\n\t\t\tif c, ok := colors[Pt{i - 1, j - 1}]; ok {\n\t\t\t\twant = c\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\tsrc.Clear()\n\tdst.Clear()\n\tfor p, c := range colors {\n\t\tsrc.Set(p.X, p.Y, c)\n\t\tdst.Set(p.X+1, p.Y+1, c)\n\t}\n\top := &ebiten.DrawImageOptions{}\n\top.GeoM.Translate(2, 2)\n\tdst.DrawImage(src.SubImage(image.Rect(2, 2, w-2, h-2)).(*ebiten.Image), op)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\tvar want color.RGBA\n\t\t\tif 2 <= i && 2 <= j && i < w-2 && j < h-2 {\n\t\t\t\tif c, ok := colors[Pt{i, j}]; ok {\n\t\t\t\t\twant = c\n\t\t\t\t}\n\t\t\t}\n\t\t\tif c, ok := colors[Pt{i - 1, j - 1}]; ok {\n\t\t\t\twant = c\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageAlphaOnBlack(t *testing.T) {\n\tconst w, h = 16, 16\n\tsrc0 := ebiten.NewImage(w, h)\n\tsrc1 := ebiten.NewImage(w, h)\n\tdst0 := ebiten.NewImage(w, h)\n\tdst1 := ebiten.NewImage(w, h)\n\n\tpix0 := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tif (i/3)%2 == (j/3)%2 {\n\t\t\t\tpix0[4*(i+j*w)] = 0xff\n\t\t\t\tpix0[4*(i+j*w)+1] = 0xff\n\t\t\t\tpix0[4*(i+j*w)+2] = 0xff\n\t\t\t\tpix0[4*(i+j*w)+3] = 0xff\n\t\t\t}\n\t\t}\n\t}\n\tsrc0.WritePixels(pix0)\n\n\tpix1 := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tif (i/3)%2 == (j/3)%2 {\n\t\t\t\tpix1[4*(i+j*w)] = 0xff\n\t\t\t\tpix1[4*(i+j*w)+1] = 0xff\n\t\t\t\tpix1[4*(i+j*w)+2] = 0xff\n\t\t\t\tpix1[4*(i+j*w)+3] = 0xff\n\t\t\t} else {\n\t\t\t\tpix1[4*(i+j*w)] = 0\n\t\t\t\tpix1[4*(i+j*w)+1] = 0\n\t\t\t\tpix1[4*(i+j*w)+2] = 0\n\t\t\t\tpix1[4*(i+j*w)+3] = 0xff\n\t\t\t}\n\t\t}\n\t}\n\tsrc1.WritePixels(pix1)\n\n\tdst0.Fill(color.Black)\n\tdst1.Fill(color.Black)\n\n\top := &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(0.5, 0.5)\n\top.Filter = ebiten.FilterLinear\n\tdst0.DrawImage(src0, op)\n\tdst1.DrawImage(src1, op)\n\n\tgray := false\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst0.At(i, j)\n\t\t\twant := dst1.At(i, j)\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t\tif r := got.(color.RGBA).R; 0 < r && r < 255 {\n\t\t\t\tgray = true\n\t\t\t}\n\t\t}\n\t}\n\tif !gray {\n\t\tt.Errorf(\"gray must be included in the results but not\")\n\t}\n}\n\nfunc TestImageDrawTrianglesWithSubImage(t *testing.T) {\n\tconst w, h = 16, 16\n\tsrc := ebiten.NewImage(w, h)\n\tdst := ebiten.NewImage(w, h)\n\n\tpix := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tif 4 <= i && i < 8 && 4 <= j && j < 8 {\n\t\t\t\tpix[4*(i+j*w)] = 0xff\n\t\t\t\tpix[4*(i+j*w)+1] = 0\n\t\t\t\tpix[4*(i+j*w)+2] = 0\n\t\t\t\tpix[4*(i+j*w)+3] = 0xff\n\t\t\t} else {\n\t\t\t\tpix[4*(i+j*w)] = 0\n\t\t\t\tpix[4*(i+j*w)+1] = 0xff\n\t\t\t\tpix[4*(i+j*w)+2] = 0\n\t\t\t\tpix[4*(i+j*w)+3] = 0xff\n\t\t\t}\n\t\t}\n\t}\n\tsrc.WritePixels(pix)\n\n\tvs := []ebiten.Vertex{\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t}\n\tis := []uint16{0, 1, 2, 1, 2, 3}\n\top := &ebiten.DrawTrianglesOptions{}\n\top.Address = ebiten.AddressClampToZero\n\tdst.DrawTriangles(vs, is, src.SubImage(image.Rect(4, 4, 8, 8)).(*ebiten.Image), op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\tvar want color.RGBA\n\t\t\tif 4 <= i && i < 8 && 4 <= j && j < 8 {\n\t\t\t\twant = src.At(i, j).(color.RGBA)\n\t\t\t}\n\t\t\tif !sameColors(got, want, 1) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #823\nfunc TestImageAtAfterDisposingSubImage(t *testing.T) {\n\timg := ebiten.NewImage(16, 16)\n\timg.Set(0, 0, color.White)\n\timg.SubImage(image.Rect(0, 0, 16, 16))\n\truntime.GC()\n\n\twant := color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\twant64 := color.RGBA64{R: 0xffff, G: 0xffff, B: 0xffff, A: 0xffff}\n\tgot := img.At(0, 0)\n\tif got != want {\n\t\tt.Errorf(\"At(0,0) got: %v, want: %v\", got, want)\n\t}\n\tgot = img.RGBA64At(0, 0)\n\tif got != want64 {\n\t\tt.Errorf(\"RGBA64At(0,0) got: %v, want: %v\", got, want)\n\t}\n\n\timg.Set(0, 1, color.White)\n\tsub := img.SubImage(image.Rect(0, 0, 16, 16)).(*ebiten.Image)\n\tsub.Dispose()\n\n\tgot = img.At(0, 1)\n\tif got != want {\n\t\tt.Errorf(\"At(0,1) got: %v, want: %v\", got, want64)\n\t}\n\tgot = img.RGBA64At(0, 1)\n\tif got != want64 {\n\t\tt.Errorf(\"RGBA64At(0,1) got: %v, want: %v\", got, want64)\n\t}\n}\n\nfunc TestImageAtAfterDeallocateSubImage(t *testing.T) {\n\timg := ebiten.NewImage(16, 16)\n\timg.Set(0, 0, color.White)\n\timg.SubImage(image.Rect(0, 0, 16, 16))\n\truntime.GC()\n\n\twant := color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\twant64 := color.RGBA64{R: 0xffff, G: 0xffff, B: 0xffff, A: 0xffff}\n\tgot := img.At(0, 0)\n\tif got != want {\n\t\tt.Errorf(\"At(0,0) got: %v, want: %v\", got, want)\n\t}\n\tgot = img.RGBA64At(0, 0)\n\tif got != want64 {\n\t\tt.Errorf(\"RGBA64At(0,0) got: %v, want: %v\", got, want)\n\t}\n\n\timg.Set(0, 1, color.White)\n\tsub := img.SubImage(image.Rect(0, 0, 16, 16)).(*ebiten.Image)\n\tsub.Deallocate()\n\n\tgot = img.At(0, 1)\n\tif got != want {\n\t\tt.Errorf(\"At(0,1) got: %v, want: %v\", got, want64)\n\t}\n\tgot = img.RGBA64At(0, 1)\n\tif got != want64 {\n\t\tt.Errorf(\"RGBA64At(0,1) got: %v, want: %v\", got, want64)\n\t}\n}\n\nfunc TestImageSubImageSubImage(t *testing.T) {\n\timg := ebiten.NewImage(16, 16)\n\timg.Fill(color.White)\n\tsub0 := img.SubImage(image.Rect(0, 0, 12, 12)).(*ebiten.Image)\n\tsub1 := sub0.SubImage(image.Rect(4, 4, 16, 16)).(*ebiten.Image)\n\tcases := []struct {\n\t\tX     int\n\t\tY     int\n\t\tColor color.RGBA\n\t}{\n\t\t{\n\t\t\tX:     0,\n\t\t\tY:     0,\n\t\t\tColor: color.RGBA{},\n\t\t},\n\t\t{\n\t\t\tX:     4,\n\t\t\tY:     4,\n\t\t\tColor: color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff},\n\t\t},\n\t\t{\n\t\t\tX:     15,\n\t\t\tY:     15,\n\t\t\tColor: color.RGBA{},\n\t\t},\n\t}\n\tfor _, c := range cases {\n\t\tgot := sub1.At(c.X, c.Y)\n\t\twant := c.Color\n\t\tif got != want {\n\t\t\tt.Errorf(\"At(%d, %d): got: %v, want: %v\", c.X, c.Y, got, want)\n\t\t}\n\t}\n}\n\n// Issue #839\nfunc TestImageTooSmallMipmap(t *testing.T) {\n\tconst w, h = 16, 16\n\tsrc := ebiten.NewImage(w, h)\n\tdst := ebiten.NewImage(w, h)\n\n\tsrc.Fill(color.White)\n\top := &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(1, 0.24)\n\top.Filter = ebiten.FilterLinear\n\tdst.DrawImage(src.SubImage(image.Rect(5, 0, 6, 16)).(*ebiten.Image), op)\n\tgot := dst.At(0, 0).(color.RGBA)\n\twant := color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\tif got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n}\n\nfunc TestImageZeroSizedMipmap(t *testing.T) {\n\tconst w, h = 16, 16\n\tsrc := ebiten.NewImage(w, h)\n\tdst := ebiten.NewImage(w, h)\n\n\top := &ebiten.DrawImageOptions{}\n\top.Filter = ebiten.FilterLinear\n\tdst.DrawImage(src.SubImage(image.ZR).(*ebiten.Image), op)\n}\n\n// Issue #898\nfunc TestImageFillingAndEdges(t *testing.T) {\n\tconst (\n\t\tsrcw, srch = 16, 16\n\t\tdstw, dsth = 256, 16\n\t)\n\n\tsrc := ebiten.NewImage(srcw, srch)\n\tdst := ebiten.NewImage(dstw, dsth)\n\n\tsrc.Fill(color.White)\n\tdst.Fill(color.Black)\n\n\top := &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(float64(dstw-2)/float64(srcw), float64(dsth-2)/float64(srch))\n\top.GeoM.Translate(1, 1)\n\tdst.DrawImage(src, op)\n\n\tfor j := 0; j < dsth; j++ {\n\t\tfor i := 0; i < dstw; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\t\t\tif i == 0 || i == dstw-1 || j == 0 || j == dsth-1 {\n\t\t\t\twant = color.RGBA{A: 0xff}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageDrawTrianglesAndMutateArgs(t *testing.T) {\n\tconst w, h = 16, 16\n\tdst := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\tclr := color.RGBA{R: 0xff, A: 0xff}\n\tsrc.Fill(clr)\n\n\tvs := []ebiten.Vertex{\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t}\n\tis := []uint16{0, 1, 2, 1, 2, 3}\n\tdst.DrawTriangles(vs, is, src, nil)\n\tvs[0].SrcX = w\n\tvs[0].SrcY = h\n\tis[5] = 0\n\n\tfor j := 0; j < w; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j)\n\t\t\twant := clr\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got %v, want %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageWritePixelsOnSubImage(t *testing.T) {\n\tdst := ebiten.NewImage(17, 31)\n\tdst.Fill(color.RGBA{R: 0xff, A: 0xff})\n\n\tpix0 := make([]byte, 4*5*3)\n\tidx := 0\n\tfor j := 0; j < 3; j++ {\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tpix0[4*idx] = 0\n\t\t\tpix0[4*idx+1] = 0xff\n\t\t\tpix0[4*idx+2] = 0\n\t\t\tpix0[4*idx+3] = 0xff\n\t\t\tidx++\n\t\t}\n\t}\n\tr0 := image.Rect(4, 5, 9, 8)\n\tdst.SubImage(r0).(*ebiten.Image).WritePixels(pix0)\n\n\tpix1 := make([]byte, 4*5*3)\n\tidx = 0\n\tfor j := 0; j < 3; j++ {\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tpix1[4*idx] = 0\n\t\t\tpix1[4*idx+1] = 0\n\t\t\tpix1[4*idx+2] = 0xff\n\t\t\tpix1[4*idx+3] = 0xff\n\t\t\tidx++\n\t\t}\n\t}\n\tr1 := image.Rect(11, 10, 16, 13)\n\tdst.SubImage(r1).(*ebiten.Image).WritePixels(pix1)\n\n\t// Clear the pixels. This should not affect the result.\n\tidx = 0\n\tfor j := 0; j < 3; j++ {\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tpix1[4*idx] = 0\n\t\t\tpix1[4*idx+1] = 0\n\t\t\tpix1[4*idx+2] = 0\n\t\t\tpix1[4*idx+3] = 0\n\t\t\tidx++\n\t\t}\n\t}\n\n\tfor j := 0; j < 31; j++ {\n\t\tfor i := 0; i < 17; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0xff, A: 0xff}\n\t\t\tp := image.Pt(i, j)\n\t\t\tswitch {\n\t\t\tcase p.In(r0):\n\t\t\t\twant = color.RGBA{G: 0xff, A: 0xff}\n\t\t\tcase p.In(r1):\n\t\t\t\twant = color.RGBA{B: 0xff, A: 0xff}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageDrawTrianglesWithColorM(t *testing.T) {\n\tconst w, h = 16, 16\n\tdst0 := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\tsrc.Fill(color.White)\n\n\tvs0 := []ebiten.Vertex{\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t}\n\top := &ebiten.DrawTrianglesOptions{}\n\top.ColorM.Scale(0.2, 0.4, 0.6, 0.8)\n\tis := []uint16{0, 1, 2, 1, 2, 3}\n\tdst0.DrawTriangles(vs0, is, src, op)\n\n\tfor _, format := range []ebiten.ColorScaleMode{\n\t\tebiten.ColorScaleModeStraightAlpha,\n\t\tebiten.ColorScaleModePremultipliedAlpha,\n\t} {\n\t\tformat := format\n\t\tt.Run(fmt.Sprintf(\"format%d\", format), func(t *testing.T) {\n\t\t\tvar cr, cg, cb, ca float32\n\t\t\tswitch format {\n\t\t\tcase ebiten.ColorScaleModeStraightAlpha:\n\t\t\t\t// The values are the same as ColorM.Scale\n\t\t\t\tcr = 0.2\n\t\t\t\tcg = 0.4\n\t\t\t\tcb = 0.6\n\t\t\t\tca = 0.8\n\t\t\tcase ebiten.ColorScaleModePremultipliedAlpha:\n\t\t\t\tcr = 0.2 * 0.8\n\t\t\t\tcg = 0.4 * 0.8\n\t\t\t\tcb = 0.6 * 0.8\n\t\t\t\tca = 0.8\n\t\t\t}\n\t\t\tvs1 := []ebiten.Vertex{\n\t\t\t\t{\n\t\t\t\t\tDstX:   0,\n\t\t\t\t\tDstY:   0,\n\t\t\t\t\tSrcX:   0,\n\t\t\t\t\tSrcY:   0,\n\t\t\t\t\tColorR: cr,\n\t\t\t\t\tColorG: cg,\n\t\t\t\t\tColorB: cb,\n\t\t\t\t\tColorA: ca,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tDstX:   w,\n\t\t\t\t\tDstY:   0,\n\t\t\t\t\tSrcX:   w,\n\t\t\t\t\tSrcY:   0,\n\t\t\t\t\tColorR: cr,\n\t\t\t\t\tColorG: cg,\n\t\t\t\t\tColorB: cb,\n\t\t\t\t\tColorA: ca,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tDstX:   0,\n\t\t\t\t\tDstY:   h,\n\t\t\t\t\tSrcX:   0,\n\t\t\t\t\tSrcY:   h,\n\t\t\t\t\tColorR: cr,\n\t\t\t\t\tColorG: cg,\n\t\t\t\t\tColorB: cb,\n\t\t\t\t\tColorA: ca,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tDstX:   w,\n\t\t\t\t\tDstY:   h,\n\t\t\t\t\tSrcX:   w,\n\t\t\t\t\tSrcY:   h,\n\t\t\t\t\tColorR: cr,\n\t\t\t\t\tColorG: cg,\n\t\t\t\t\tColorB: cb,\n\t\t\t\t\tColorA: ca,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tdst1 := ebiten.NewImage(w, h)\n\t\t\top := &ebiten.DrawTrianglesOptions{}\n\t\t\top.ColorScaleMode = format\n\t\t\tdst1.DrawTriangles(vs1, is, src, op)\n\n\t\t\tfor j := 0; j < h; j++ {\n\t\t\t\tfor i := 0; i < w; i++ {\n\t\t\t\t\tgot := dst0.At(i, j)\n\t\t\t\t\twant := dst1.At(i, j)\n\t\t\t\t\tif got != want {\n\t\t\t\t\t\tt.Errorf(\"At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestImageDrawTrianglesInterpolatesColors(t *testing.T) {\n\tconst w, h = 3, 1\n\tsrc := ebiten.NewImage(w, h)\n\tsrc.Fill(color.White)\n\n\tvs := []ebiten.Vertex{\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 0,\n\t\t\tColorB: 0,\n\t\t\tColorA: 0,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 0,\n\t\t\tColorG: 1,\n\t\t\tColorB: 0,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 0,\n\t\t\tColorB: 0,\n\t\t\tColorA: 0,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 0,\n\t\t\tColorG: 1,\n\t\t\tColorB: 0,\n\t\t\tColorA: 1,\n\t\t},\n\t}\n\n\tfor _, format := range []ebiten.ColorScaleMode{\n\t\tebiten.ColorScaleModeStraightAlpha,\n\t\tebiten.ColorScaleModePremultipliedAlpha,\n\t} {\n\t\tformat := format\n\t\tt.Run(fmt.Sprintf(\"format%d\", format), func(t *testing.T) {\n\t\t\tdst := ebiten.NewImage(w, h)\n\t\t\tdst.Fill(color.RGBA{B: 0xff, A: 0xff})\n\n\t\t\top := &ebiten.DrawTrianglesOptions{}\n\t\t\top.ColorScaleMode = format\n\n\t\t\tis := []uint16{0, 1, 2, 1, 2, 3}\n\t\t\tdst.DrawTriangles(vs, is, src, op)\n\n\t\t\tgot := dst.At(1, 0).(color.RGBA)\n\n\t\t\t// Correct color interpolation uses the alpha channel\n\t\t\t// and notices that colors on the left side of the texture are fully transparent.\n\t\t\tvar want color.RGBA\n\t\t\tswitch format {\n\t\t\tcase ebiten.ColorScaleModeStraightAlpha:\n\t\t\t\twant = color.RGBA{G: 0x80, B: 0x80, A: 0xff}\n\t\t\tcase ebiten.ColorScaleModePremultipliedAlpha:\n\t\t\t\twant = color.RGBA{R: 0x80, G: 0x80, B: 0x80, A: 0xff}\n\t\t\t}\n\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"At(1, 0): got: %v, want: %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestImageDrawTrianglesShaderInterpolatesValues(t *testing.T) {\n\tconst w, h = 3, 1\n\tsrc := ebiten.NewImage(w, h)\n\tdst := ebiten.NewImage(w, h)\n\tsrc.Fill(color.White)\n\n\tvs := []ebiten.Vertex{\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 0,\n\t\t\tColorB: 0,\n\t\t\tColorA: 0,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 0,\n\t\t\tColorG: 1,\n\t\t\tColorB: 0,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 0,\n\t\t\tColorB: 0,\n\t\t\tColorA: 0,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 0,\n\t\t\tColorG: 1,\n\t\t\tColorB: 0,\n\t\t\tColorA: 1,\n\t\t},\n\t}\n\tdst.Fill(color.RGBA{B: 0xff, A: 0xff})\n\top := &ebiten.DrawTrianglesShaderOptions{\n\t\tImages: [4]*ebiten.Image{src, nil, nil, nil},\n\t}\n\tis := []uint16{0, 1, 2, 1, 2, 3}\n\tshader, err := ebiten.NewShader([]byte(`\n\t\tpackage main\n\t\tfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\t\t\treturn color\n\t\t}\n\t`))\n\tif err != nil {\n\t\tt.Fatalf(\"could not compile shader: %v\", err)\n\t}\n\tdst.DrawTrianglesShader(vs, is, shader, op)\n\n\tgot := dst.At(1, 0).(color.RGBA)\n\n\t// Shaders get each color value interpolated independently.\n\twant := color.RGBA{R: 0x80, G: 0x80, B: 0x80, A: 0xff}\n\n\tif !sameColors(got, want, 2) {\n\t\tt.Errorf(\"At(1, 0): got: %v, want: %v\", got, want)\n\t}\n}\n\n// Issue #1137\nfunc TestImageDrawOver(t *testing.T) {\n\tconst (\n\t\tw = 320\n\t\th = 240\n\t)\n\tdst := ebiten.NewImage(w, h)\n\tsrc := image.NewUniform(color.RGBA{R: 0xff, A: 0xff})\n\t// This must not cause infinite-loop.\n\tdraw.Draw(dst, dst.Bounds(), src, image.ZP, draw.Over)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j)\n\t\t\twant := color.RGBA{R: 0xff, A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageDrawDisposedImage(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"DrawImage must panic but not\")\n\t\t}\n\t}()\n\n\tdst := ebiten.NewImage(16, 16)\n\tsrc := ebiten.NewImage(16, 16)\n\tsrc.Dispose()\n\tdst.DrawImage(src, nil)\n}\n\nfunc TestImageDrawDeallocatedImage(t *testing.T) {\n\tdst := ebiten.NewImage(16, 16)\n\tsrc := ebiten.NewImage(16, 16)\n\tsrc.Deallocate()\n\t// DrawImage must not panic.\n\tdst.DrawImage(src, nil)\n}\n\nfunc TestImageDrawTrianglesDisposedImage(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"DrawTriangles must panic but not\")\n\t\t}\n\t}()\n\n\tdst := ebiten.NewImage(16, 16)\n\tsrc := ebiten.NewImage(16, 16)\n\tsrc.Dispose()\n\tvs := make([]ebiten.Vertex, 4)\n\tis := []uint16{0, 1, 2, 1, 2, 3}\n\tdst.DrawTriangles(vs, is, src, nil)\n}\n\nfunc TestImageDrawTrianglesDeallocateImage(t *testing.T) {\n\tdst := ebiten.NewImage(16, 16)\n\tsrc := ebiten.NewImage(16, 16)\n\tsrc.Deallocate()\n\tvs := make([]ebiten.Vertex, 4)\n\tis := []uint16{0, 1, 2, 1, 2, 3}\n\t// DrawTriangles must not panic.\n\tdst.DrawTriangles(vs, is, src, nil)\n}\n\n// #1137\nfunc BenchmarkImageDrawOver(b *testing.B) {\n\tdst := ebiten.NewImage(16, 16)\n\tsrc := image.NewUniform(color.Black)\n\tfor n := 0; n < b.N; n++ {\n\t\tdraw.Draw(dst, dst.Bounds(), src, image.ZP, draw.Over)\n\t}\n}\n\n// Issue #1171\nfunc TestImageFloatTranslate(t *testing.T) {\n\tconst w, h = 32, 32\n\n\tfor s := 2; s <= 8; s++ {\n\t\ts := s\n\t\tt.Run(fmt.Sprintf(\"scale%d\", s), func(t *testing.T) {\n\t\t\tcheck := func(src *ebiten.Image) {\n\t\t\t\tdst := ebiten.NewImage(w*(s+1), h*(s+1))\n\t\t\t\tdst.Fill(color.RGBA{R: 0xff, A: 0xff})\n\n\t\t\t\top := &ebiten.DrawImageOptions{}\n\t\t\t\top.GeoM.Scale(float64(s), float64(s))\n\t\t\t\top.GeoM.Translate(0, 0.501)\n\t\t\t\tdst.DrawImage(src, op)\n\n\t\t\t\tfor j := 0; j < h*s+1; j++ {\n\t\t\t\t\tfor i := 0; i < w*s; i++ {\n\t\t\t\t\t\tgot := dst.At(i, j)\n\t\t\t\t\t\tx := byte(0xff)\n\t\t\t\t\t\tif j > 0 {\n\t\t\t\t\t\t\tx = (byte(j) - 1) / byte(s)\n\t\t\t\t\t\t}\n\t\t\t\t\t\twant := color.RGBA{R: x, A: 0xff}\n\t\t\t\t\t\tif got != want {\n\t\t\t\t\t\t\tt.Errorf(\"At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tt.Run(\"image\", func(t *testing.T) {\n\t\t\t\tsrc := ebiten.NewImage(w, h)\n\t\t\t\tpix := make([]byte, 4*w*h)\n\t\t\t\tfor j := 0; j < h; j++ {\n\t\t\t\t\tfor i := 0; i < w; i++ {\n\t\t\t\t\t\tpix[4*(j*w+i)] = byte(j)\n\t\t\t\t\t\tpix[4*(j*w+i)+3] = 0xff\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrc.WritePixels(pix)\n\t\t\t\tcheck(src)\n\t\t\t})\n\n\t\t\tt.Run(\"subimage\", func(t *testing.T) {\n\t\t\t\tsrc := ebiten.NewImage(w*s, h*s)\n\t\t\t\tpix := make([]byte, 4*(w*s)*(h*s))\n\t\t\t\tfor j := 0; j < h*s; j++ {\n\t\t\t\t\tfor i := 0; i < w*s; i++ {\n\t\t\t\t\t\tpix[4*(j*(w*s)+i)] = byte(j)\n\t\t\t\t\t\tpix[4*(j*(w*s)+i)+3] = 0xff\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsrc.WritePixels(pix)\n\t\t\t\tcheck(src.SubImage(image.Rect(0, 0, w, h)).(*ebiten.Image))\n\t\t\t})\n\t\t})\n\t}\n}\n\n// Issue #1213\nfunc TestImageColorMCopy(t *testing.T) {\n\tconst w, h = 16, 16\n\tdst := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\n\tfor k := 0; k < 256; k++ {\n\t\top := &ebiten.DrawImageOptions{}\n\t\top.ColorM.Translate(1, 1, 1, float64(k)/0xff)\n\t\top.Blend = ebiten.BlendCopy\n\t\tdst.DrawImage(src, op)\n\n\t\tfor j := 0; j < h; j++ {\n\t\t\tfor i := 0; i < w; i++ {\n\t\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\t\twant := color.RGBA{R: byte(k), G: byte(k), B: byte(k), A: byte(k)}\n\t\t\t\tif !sameColors(got, want, 1) {\n\t\t\t\t\tt.Fatalf(\"dst.At(%d, %d), k: %d: got %v, want %v\", i, j, k, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// TODO: Do we have to guarantee this behavior? See #1222\nfunc TestImageWritePixelsAndModifyPixels(t *testing.T) {\n\tconst w, h = 16, 16\n\tdst := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\n\tpix := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tidx := 4 * (i + j*w)\n\t\t\tpix[idx] = 0xff\n\t\t\tpix[idx+1] = 0\n\t\t\tpix[idx+2] = 0\n\t\t\tpix[idx+3] = 0xff\n\t\t}\n\t}\n\n\tsrc.WritePixels(pix)\n\n\t// Modify pix after WritePixels\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tidx := 4 * (i + j*w)\n\t\t\tpix[idx] = 0\n\t\t\tpix[idx+1] = 0xff\n\t\t\tpix[idx+2] = 0\n\t\t\tpix[idx+3] = 0xff\n\t\t}\n\t}\n\n\t// Ensure that src's pixels are actually used\n\tdst.DrawImage(src, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := src.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0xff, A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"src.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageCompositeModeMultiply(t *testing.T) {\n\tconst w, h = 16, 16\n\tdst := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\n\tdst.Fill(color.RGBA{R: 0x10, G: 0x20, B: 0x30, A: 0x40})\n\tsrc.Fill(color.RGBA{R: 0x50, G: 0x60, B: 0x70, A: 0x80})\n\n\top := &ebiten.DrawImageOptions{}\n\top.CompositeMode = ebiten.CompositeModeMultiply\n\tdst.DrawImage(src, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{\n\t\t\t\tR: byte(math.Floor((0x10 / 255.0) * (0x50 / 255.0) * 255)),\n\t\t\t\tG: byte(math.Floor((0x20 / 255.0) * (0x60 / 255.0) * 255)),\n\t\t\t\tB: byte(math.Floor((0x30 / 255.0) * (0x70 / 255.0) * 255)),\n\t\t\t\tA: byte(math.Floor((0x40 / 255.0) * (0x80 / 255.0) * 255)),\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #1269\nfunc TestImageZeroTriangle(t *testing.T) {\n\tconst w, h = 16, 16\n\tdst := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(1, 1)\n\n\tvs := []ebiten.Vertex{}\n\tis := []uint16{}\n\tdst.DrawTriangles(vs, is, src, nil)\n}\n\n// Issue #1398\nfunc TestImageDrawImageTooBigScale(t *testing.T) {\n\tdst := ebiten.NewImage(1, 1)\n\tsrc := ebiten.NewImage(1, 1)\n\n\top := &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(1e20, 1e20)\n\tdst.DrawImage(src, op)\n}\n\n// Issue #1398\nfunc TestImageDrawImageTooSmallScale(t *testing.T) {\n\tdst := ebiten.NewImage(1, 1)\n\tsrc := ebiten.NewImage(1, 1)\n\n\top := &ebiten.DrawImageOptions{}\n\top.Filter = ebiten.FilterLinear\n\top.GeoM.Scale(1e-10, 1e-10)\n\tdst.DrawImage(src, op)\n}\n\n// Issue #1399\nfunc TestImageDrawImageCannotAllocateImageForMipmap(t *testing.T) {\n\tdst := ebiten.NewImage(1, 1)\n\tsrc := ebiten.NewImage(maxImageSize, maxImageSize)\n\n\top := &ebiten.DrawImageOptions{}\n\top.GeoM.Scale(64, 64)\n\tdst.DrawImage(src, op)\n\tdst.At(0, 0)\n}\n\nfunc TestImageNewImageWithZeroSize(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"DrawImage must panic but not\")\n\t\t}\n\t}()\n\n\t_ = ebiten.NewImage(0, 1)\n}\n\nfunc TestImageNewImageFromImageWithZeroSize(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"DrawImage must panic but not\")\n\t\t}\n\t}()\n\n\timg := image.NewRGBA(image.Rect(0, 0, 0, 1))\n\t_ = ebiten.NewImageFromImage(img)\n}\n\nfunc TestImageClip(t *testing.T) {\n\tconst (\n\t\tw = 16\n\t\th = 16\n\t)\n\tdst := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\n\tdst.Fill(color.RGBA{R: 0xff, A: 0xff})\n\tsrc.Fill(color.RGBA{G: 0xff, A: 0xff})\n\n\tdst.SubImage(image.Rect(4, 5, 12, 14)).(*ebiten.Image).DrawImage(src, nil)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0xff, A: 0xff}\n\t\t\tif 4 <= i && i < 12 && 5 <= j && j < 14 {\n\t\t\t\twant = color.RGBA{G: 0xff, A: 0xff}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #1691\nfunc TestImageSubImageFill(t *testing.T) {\n\tdst := ebiten.NewImage(3, 3).SubImage(image.Rect(1, 1, 2, 2)).(*ebiten.Image)\n\tdst.Fill(color.White)\n\tfor j := 0; j < 3; j++ {\n\t\tfor i := 0; i < 3; i++ {\n\t\t\tgot := dst.At(i, j)\n\t\t\tvar want color.RGBA\n\t\t\tif i == 1 && j == 1 {\n\t\t\t\twant = color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\tdst = ebiten.NewImage(17, 31).SubImage(image.Rect(3, 4, 8, 10)).(*ebiten.Image)\n\tdst.Fill(color.White)\n\tfor j := 0; j < 31; j++ {\n\t\tfor i := 0; i < 17; i++ {\n\t\t\tgot := dst.At(i, j)\n\t\t\tvar want color.RGBA\n\t\t\tif 3 <= i && i < 8 && 4 <= j && j < 10 {\n\t\t\t\twant = color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageEvenOdd(t *testing.T) {\n\twhiteImage := ebiten.NewImage(3, 3)\n\twhiteImage.Fill(color.White)\n\temptySubImage := whiteImage.SubImage(image.Rect(1, 1, 2, 2)).(*ebiten.Image)\n\n\tvs0 := []ebiten.Vertex{\n\t\t{\n\t\t\tDstX: 1, DstY: 1, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 1, ColorG: 0, ColorB: 0, ColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX: 15, DstY: 1, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 1, ColorG: 0, ColorB: 0, ColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX: 1, DstY: 15, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 1, ColorG: 0, ColorB: 0, ColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX: 15, DstY: 15, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 1, ColorG: 0, ColorB: 0, ColorA: 1,\n\t\t},\n\t}\n\tis0 := []uint16{0, 1, 2, 1, 2, 3}\n\n\tvs1 := []ebiten.Vertex{\n\t\t{\n\t\t\tDstX: 2, DstY: 2, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 0, ColorG: 1, ColorB: 0, ColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX: 14, DstY: 2, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 0, ColorG: 1, ColorB: 0, ColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX: 2, DstY: 14, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 0, ColorG: 1, ColorB: 0, ColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX: 14, DstY: 14, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 0, ColorG: 1, ColorB: 0, ColorA: 1,\n\t\t},\n\t}\n\tis1 := []uint16{4, 5, 6, 5, 6, 7}\n\n\tvs2 := []ebiten.Vertex{\n\t\t{\n\t\t\tDstX: 3, DstY: 3, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 0, ColorG: 0, ColorB: 1, ColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX: 13, DstY: 3, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 0, ColorG: 0, ColorB: 1, ColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX: 3, DstY: 13, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 0, ColorG: 0, ColorB: 1, ColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX: 13, DstY: 13, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 0, ColorG: 0, ColorB: 1, ColorA: 1,\n\t\t},\n\t}\n\tis2 := []uint16{8, 9, 10, 9, 10, 11}\n\n\t// Draw all the vertices once. The even-odd rule is applied for all the vertices once.\n\tdst := ebiten.NewImage(16, 16)\n\top := &ebiten.DrawTrianglesOptions{\n\t\tFillRule: ebiten.FillRuleEvenOdd,\n\t}\n\tdst.DrawTriangles(append(append(vs0, vs1...), vs2...), append(append(is0, is1...), is2...), emptySubImage, op)\n\tfor j := 0; j < 16; j++ {\n\t\tfor i := 0; i < 16; i++ {\n\t\t\tgot := dst.At(i, j)\n\t\t\tvar want color.RGBA\n\t\t\tswitch {\n\t\t\tcase 3 <= i && i < 13 && 3 <= j && j < 13:\n\t\t\t\twant = color.RGBA{B: 0xff, A: 0xff}\n\t\t\tcase 2 <= i && i < 14 && 2 <= j && j < 14:\n\t\t\t\twant = color.RGBA{}\n\t\t\tcase 1 <= i && i < 15 && 1 <= j && j < 15:\n\t\t\t\twant = color.RGBA{R: 0xff, A: 0xff}\n\t\t\tdefault:\n\t\t\t\twant = color.RGBA{}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Do the same thing but with a little shift. This confirms that the underlying stencil buffer is cleared correctly.\n\tfor i := range vs0 {\n\t\tvs0[i].DstX++\n\t\tvs0[i].DstY++\n\t}\n\tfor i := range vs1 {\n\t\tvs1[i].DstX++\n\t\tvs1[i].DstY++\n\t}\n\tfor i := range vs2 {\n\t\tvs2[i].DstX++\n\t\tvs2[i].DstY++\n\t}\n\tdst.Clear()\n\tdst.DrawTriangles(append(append(vs0, vs1...), vs2...), append(append(is0, is1...), is2...), emptySubImage, op)\n\tfor j := 0; j < 16; j++ {\n\t\tfor i := 0; i < 16; i++ {\n\t\t\tgot := dst.At(i, j)\n\t\t\tvar want color.RGBA\n\t\t\tswitch {\n\t\t\tcase 4 <= i && i < 14 && 4 <= j && j < 14:\n\t\t\t\twant = color.RGBA{B: 0xff, A: 0xff}\n\t\t\tcase 3 <= i && i < 15 && 3 <= j && j < 15:\n\t\t\t\twant = color.RGBA{}\n\t\t\tcase 2 <= i && i < 16 && 2 <= j && j < 16:\n\t\t\t\twant = color.RGBA{R: 0xff, A: 0xff}\n\t\t\tdefault:\n\t\t\t\twant = color.RGBA{}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Do the same thing but with split DrawTriangle calls. This confirms that the even-odd rule is applied for one call.\n\tfor i := range vs0 {\n\t\tvs0[i].DstX--\n\t\tvs0[i].DstY--\n\t}\n\tfor i := range vs1 {\n\t\tvs1[i].DstX--\n\t\tvs1[i].DstY--\n\t}\n\tfor i := range vs2 {\n\t\tvs2[i].DstX--\n\t\tvs2[i].DstY--\n\t}\n\tdst.Clear()\n\t// Use the first indices set.\n\tdst.DrawTriangles(vs0, is0, emptySubImage, op)\n\tdst.DrawTriangles(vs1, is0, emptySubImage, op)\n\tdst.DrawTriangles(vs2, is0, emptySubImage, op)\n\tfor j := 0; j < 16; j++ {\n\t\tfor i := 0; i < 16; i++ {\n\t\t\tgot := dst.At(i, j)\n\t\t\tvar want color.RGBA\n\t\t\tswitch {\n\t\t\tcase 3 <= i && i < 13 && 3 <= j && j < 13:\n\t\t\t\twant = color.RGBA{B: 0xff, A: 0xff}\n\t\t\tcase 2 <= i && i < 14 && 2 <= j && j < 14:\n\t\t\t\twant = color.RGBA{G: 0xff, A: 0xff}\n\t\t\tcase 1 <= i && i < 15 && 1 <= j && j < 15:\n\t\t\t\twant = color.RGBA{R: 0xff, A: 0xff}\n\t\t\tdefault:\n\t\t\t\twant = color.RGBA{}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageFillRule(t *testing.T) {\n\tfor _, fillRule := range []ebiten.FillRule{ebiten.FillRuleFillAll, ebiten.FillRuleNonZero, ebiten.FillRuleEvenOdd} {\n\t\tfillRule := fillRule\n\t\tvar name string\n\t\tswitch fillRule {\n\t\tcase ebiten.FillRuleFillAll:\n\t\t\tname = \"FillAll\"\n\t\tcase ebiten.FillRuleNonZero:\n\t\t\tname = \"NonZero\"\n\t\tcase ebiten.FillRuleEvenOdd:\n\t\t\tname = \"EvenOdd\"\n\t\t}\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\twhiteImage := ebiten.NewImage(3, 3)\n\t\t\twhiteImage.Fill(color.White)\n\t\t\temptySubImage := whiteImage.SubImage(image.Rect(1, 1, 2, 2)).(*ebiten.Image)\n\n\t\t\t// The outside rectangle (clockwise)\n\t\t\tvs0 := []ebiten.Vertex{\n\t\t\t\t{\n\t\t\t\t\tDstX: 1, DstY: 1, SrcX: 1, SrcY: 1,\n\t\t\t\t\tColorR: 1, ColorG: 0, ColorB: 0, ColorA: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tDstX: 15, DstY: 1, SrcX: 1, SrcY: 1,\n\t\t\t\t\tColorR: 1, ColorG: 0, ColorB: 0, ColorA: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tDstX: 15, DstY: 15, SrcX: 1, SrcY: 1,\n\t\t\t\t\tColorR: 1, ColorG: 0, ColorB: 0, ColorA: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tDstX: 1, DstY: 15, SrcX: 1, SrcY: 1,\n\t\t\t\t\tColorR: 1, ColorG: 0, ColorB: 0, ColorA: 1,\n\t\t\t\t},\n\t\t\t}\n\t\t\tis0 := []uint16{0, 1, 2, 2, 3, 0}\n\n\t\t\t// An inside rectangle (clockwise)\n\t\t\tvs1 := []ebiten.Vertex{\n\t\t\t\t{\n\t\t\t\t\tDstX: 2, DstY: 2, SrcX: 1, SrcY: 1,\n\t\t\t\t\tColorR: 0, ColorG: 1, ColorB: 0, ColorA: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tDstX: 7, DstY: 2, SrcX: 1, SrcY: 1,\n\t\t\t\t\tColorR: 0, ColorG: 1, ColorB: 0, ColorA: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tDstX: 7, DstY: 7, SrcX: 1, SrcY: 1,\n\t\t\t\t\tColorR: 0, ColorG: 1, ColorB: 0, ColorA: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tDstX: 2, DstY: 7, SrcX: 1, SrcY: 1,\n\t\t\t\t\tColorR: 0, ColorG: 1, ColorB: 0, ColorA: 1,\n\t\t\t\t},\n\t\t\t}\n\t\t\tis1 := []uint16{4, 5, 6, 6, 7, 4}\n\n\t\t\t// An inside rectangle (counter-clockwise)\n\t\t\tvs2 := []ebiten.Vertex{\n\t\t\t\t{\n\t\t\t\t\tDstX: 9, DstY: 9, SrcX: 1, SrcY: 1,\n\t\t\t\t\tColorR: 0, ColorG: 0, ColorB: 1, ColorA: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tDstX: 14, DstY: 9, SrcX: 1, SrcY: 1,\n\t\t\t\t\tColorR: 0, ColorG: 0, ColorB: 1, ColorA: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tDstX: 14, DstY: 14, SrcX: 1, SrcY: 1,\n\t\t\t\t\tColorR: 0, ColorG: 0, ColorB: 1, ColorA: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tDstX: 9, DstY: 14, SrcX: 1, SrcY: 1,\n\t\t\t\t\tColorR: 0, ColorG: 0, ColorB: 1, ColorA: 1,\n\t\t\t\t},\n\t\t\t}\n\t\t\tis2 := []uint16{8, 11, 10, 10, 9, 8}\n\n\t\t\t// Draw all the vertices once. The even-odd rule is applied for all the vertices once.\n\t\t\tdst := ebiten.NewImage(16, 16)\n\t\t\top := &ebiten.DrawTrianglesOptions{\n\t\t\t\tFillRule: fillRule,\n\t\t\t}\n\t\t\tdst.DrawTriangles(append(append(vs0, vs1...), vs2...), append(append(is0, is1...), is2...), emptySubImage, op)\n\t\t\tfor j := 0; j < 16; j++ {\n\t\t\t\tfor i := 0; i < 16; i++ {\n\t\t\t\t\tgot := dst.At(i, j)\n\t\t\t\t\tvar want color.RGBA\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase 2 <= i && i < 7 && 2 <= j && j < 7:\n\t\t\t\t\t\tif fillRule != ebiten.FillRuleEvenOdd {\n\t\t\t\t\t\t\twant = color.RGBA{G: 0xff, A: 0xff}\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 9 <= i && i < 14 && 9 <= j && j < 14:\n\t\t\t\t\t\tif fillRule == ebiten.FillRuleFillAll {\n\t\t\t\t\t\t\twant = color.RGBA{B: 0xff, A: 0xff}\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 1 <= i && i < 15 && 1 <= j && j < 15:\n\t\t\t\t\t\twant = color.RGBA{R: 0xff, A: 0xff}\n\t\t\t\t\t}\n\t\t\t\t\tif got != want {\n\t\t\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do the same thing but with a little shift. This confirms that the underlying stencil buffer is cleared correctly.\n\t\t\tfor i := range vs0 {\n\t\t\t\tvs0[i].DstX++\n\t\t\t\tvs0[i].DstY++\n\t\t\t}\n\t\t\tfor i := range vs1 {\n\t\t\t\tvs1[i].DstX++\n\t\t\t\tvs1[i].DstY++\n\t\t\t}\n\t\t\tfor i := range vs2 {\n\t\t\t\tvs2[i].DstX++\n\t\t\t\tvs2[i].DstY++\n\t\t\t}\n\t\t\tdst.Clear()\n\t\t\tdst.DrawTriangles(append(append(vs0, vs1...), vs2...), append(append(is0, is1...), is2...), emptySubImage, op)\n\t\t\tfor j := 0; j < 16; j++ {\n\t\t\t\tfor i := 0; i < 16; i++ {\n\t\t\t\t\tgot := dst.At(i, j)\n\t\t\t\t\tvar want color.RGBA\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase 3 <= i && i < 8 && 3 <= j && j < 8:\n\t\t\t\t\t\tif fillRule != ebiten.FillRuleEvenOdd {\n\t\t\t\t\t\t\twant = color.RGBA{G: 0xff, A: 0xff}\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 10 <= i && i < 15 && 10 <= j && j < 15:\n\t\t\t\t\t\tif fillRule == ebiten.FillRuleFillAll {\n\t\t\t\t\t\t\twant = color.RGBA{B: 0xff, A: 0xff}\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 2 <= i && i < 16 && 2 <= j && j < 16:\n\t\t\t\t\t\twant = color.RGBA{R: 0xff, A: 0xff}\n\t\t\t\t\t}\n\t\t\t\t\tif got != want {\n\t\t\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Do the same thing but with split DrawTriangle calls. This confirms that fill rules are applied for one call.\n\t\t\tfor i := range vs0 {\n\t\t\t\tvs0[i].DstX--\n\t\t\t\tvs0[i].DstY--\n\t\t\t}\n\t\t\tfor i := range vs1 {\n\t\t\t\tvs1[i].DstX--\n\t\t\t\tvs1[i].DstY--\n\t\t\t}\n\t\t\tfor i := range vs2 {\n\t\t\t\tvs2[i].DstX--\n\t\t\t\tvs2[i].DstY--\n\t\t\t}\n\t\t\tdst.Clear()\n\t\t\tdst.DrawTriangles(vs0, []uint16{0, 1, 2, 2, 3, 0}, emptySubImage, op)\n\t\t\tdst.DrawTriangles(vs1, []uint16{0, 1, 2, 2, 3, 0}, emptySubImage, op)\n\t\t\tdst.DrawTriangles(vs2, []uint16{0, 3, 2, 2, 1, 0}, emptySubImage, op)\n\t\t\tfor j := 0; j < 16; j++ {\n\t\t\t\tfor i := 0; i < 16; i++ {\n\t\t\t\t\tgot := dst.At(i, j)\n\t\t\t\t\tvar want color.RGBA\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase 2 <= i && i < 7 && 2 <= j && j < 7:\n\t\t\t\t\t\twant = color.RGBA{G: 0xff, A: 0xff}\n\t\t\t\t\tcase 9 <= i && i < 14 && 9 <= j && j < 14:\n\t\t\t\t\t\twant = color.RGBA{B: 0xff, A: 0xff}\n\t\t\t\t\tcase 1 <= i && i < 15 && 1 <= j && j < 15:\n\t\t\t\t\t\twant = color.RGBA{R: 0xff, A: 0xff}\n\t\t\t\t\t}\n\t\t\t\t\tif got != want {\n\t\t\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// #1658\nfunc BenchmarkColorMScale(b *testing.B) {\n\tr := rand.Float64\n\tdst := ebiten.NewImage(16, 16)\n\tsrc := ebiten.NewImage(16, 16)\n\tfor n := 0; n < b.N; n++ {\n\t\top := &ebiten.DrawImageOptions{}\n\t\top.ColorM.Scale(r(), r(), r(), r())\n\t\tdst.DrawImage(src, op)\n\t}\n}\n\nfunc TestImageMoreIndicesThanMaxUint16(t *testing.T) {\n\tconst (\n\t\tw = 16\n\t\th = 16\n\t)\n\n\tdst := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\tsrc.Fill(color.White)\n\n\top := &ebiten.DrawTrianglesOptions{}\n\tvs := make([]ebiten.Vertex, 3)\n\tis := make([]uint16, 65538)\n\tdst.DrawTriangles(vs, is, src, op)\n\n\t// The next draw call should work well (and this is likely batched).\n\tvs = []ebiten.Vertex{\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t}\n\tis = []uint16{0, 1, 2, 1, 2, 3}\n\tdst.DrawTriangles(vs, is, src, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j)\n\t\t\twant := color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageMoreVerticesThanMaxUint16(t *testing.T) {\n\tconst (\n\t\tw = 16\n\t\th = 16\n\t)\n\n\tdst := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\tsrc.Fill(color.White)\n\n\top := &ebiten.DrawTrianglesOptions{}\n\tvs := make([]ebiten.Vertex, math.MaxUint16+1)\n\tis := make([]uint16, 3)\n\tdst.DrawTriangles(vs, is, src, op)\n\n\t// The next draw call should work well (and this is likely batched).\n\tvs = []ebiten.Vertex{\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   h,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t}\n\tis = []uint16{0, 1, 2, 1, 2, 3}\n\tdst.DrawTriangles(vs, is, src, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j)\n\t\t\twant := color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageNewImageFromEbitenImage(t *testing.T) {\n\tconst (\n\t\tw = 16\n\t\th = 16\n\t)\n\n\tpix := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tidx := 4 * (i + j*w)\n\t\t\tpix[idx] = byte(i)\n\t\t\tpix[idx+1] = byte(j)\n\t\t\tpix[idx+2] = 0\n\t\t\tpix[idx+3] = 0xff\n\t\t}\n\t}\n\n\timg0 := ebiten.NewImage(w, h)\n\timg0.WritePixels(pix)\n\timg1 := ebiten.NewImageFromImage(img0)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := img1.At(i, j)\n\t\t\twant := color.RGBA{R: byte(i), G: byte(j), A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img1.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\timg2 := ebiten.NewImageFromImage(img0.SubImage(image.Rect(4, 4, 12, 12)))\n\tfor j := 0; j < h/2; j++ {\n\t\tfor i := 0; i < w/2; i++ {\n\t\t\tgot := img2.At(i, j)\n\t\t\twant := color.RGBA{R: byte(i + 4), G: byte(j + 4), A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img1.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageOptionsUnmanaged(t *testing.T) {\n\tconst (\n\t\tw = 16\n\t\th = 16\n\t)\n\n\tpix := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tidx := 4 * (i + j*w)\n\t\t\tpix[idx] = byte(i)\n\t\t\tpix[idx+1] = byte(j)\n\t\t\tpix[idx+2] = 0\n\t\t\tpix[idx+3] = 0xff\n\t\t}\n\t}\n\n\top := &ebiten.NewImageOptions{\n\t\tUnmanaged: true,\n\t}\n\timg := ebiten.NewImageWithOptions(image.Rect(0, 0, w, h), op)\n\timg.WritePixels(pix)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := img.At(i, j)\n\t\t\twant := color.RGBA{R: byte(i), G: byte(j), A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageOptionsNegativeBoundsWritePixels(t *testing.T) {\n\tconst (\n\t\tw = 16\n\t\th = 16\n\t)\n\n\tpix0 := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tidx := 4 * (i + j*w)\n\t\t\tpix0[idx] = byte(i)\n\t\t\tpix0[idx+1] = byte(j)\n\t\t\tpix0[idx+2] = 0\n\t\t\tpix0[idx+3] = 0xff\n\t\t}\n\t}\n\n\tconst offset = -8\n\timg := ebiten.NewImageWithOptions(image.Rect(offset, offset, w+offset, h+offset), nil)\n\timg.WritePixels(pix0)\n\n\tfor j := offset; j < h+offset; j++ {\n\t\tfor i := offset; i < w+offset; i++ {\n\t\t\tgot := img.At(i, j)\n\t\t\twant := color.RGBA{R: byte(i - offset), G: byte(j - offset), A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\tpix1 := make([]byte, 4*(w/2)*(h/2))\n\tfor j := 0; j < h/2; j++ {\n\t\tfor i := 0; i < w/2; i++ {\n\t\t\tidx := 4 * (i + j*w/2)\n\t\t\tpix1[idx] = 0\n\t\t\tpix1[idx+1] = 0\n\t\t\tpix1[idx+2] = 0xff\n\t\t\tpix1[idx+3] = 0xff\n\t\t}\n\t}\n\n\tconst offset2 = -4\n\tsub := image.Rect(offset2, offset2, w/2+offset2, h/2+offset2)\n\timg.SubImage(sub).(*ebiten.Image).WritePixels(pix1)\n\tfor j := offset; j < h+offset; j++ {\n\t\tfor i := offset; i < w+offset; i++ {\n\t\t\tgot := img.At(i, j)\n\t\t\twant := color.RGBA{R: byte(i - offset), G: byte(j - offset), A: 0xff}\n\t\t\tif image.Pt(i, j).In(sub) {\n\t\t\t\twant = color.RGBA{B: 0xff, A: 0xff}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageOptionsNegativeBoundsSet(t *testing.T) {\n\tconst (\n\t\tw = 16\n\t\th = 16\n\t)\n\n\tpix0 := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tidx := 4 * (i + j*w)\n\t\t\tpix0[idx] = byte(i)\n\t\t\tpix0[idx+1] = byte(j)\n\t\t\tpix0[idx+2] = 0\n\t\t\tpix0[idx+3] = 0xff\n\t\t}\n\t}\n\n\tconst offset = -8\n\timg := ebiten.NewImageWithOptions(image.Rect(offset, offset, w+offset, h+offset), nil)\n\timg.WritePixels(pix0)\n\timg.Set(-1, -2, color.RGBA{})\n\n\tfor j := offset; j < h+offset; j++ {\n\t\tfor i := offset; i < w+offset; i++ {\n\t\t\tgot := img.At(i, j)\n\t\t\twant := color.RGBA{R: byte(i - offset), G: byte(j - offset), A: 0xff}\n\t\t\tif i == -1 && j == -2 {\n\t\t\t\twant = color.RGBA{}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageOptionsNegativeBoundsDrawImage(t *testing.T) {\n\tconst (\n\t\tw      = 16\n\t\th      = 16\n\t\toffset = -8\n\t)\n\tdst := ebiten.NewImageWithOptions(image.Rect(offset, offset, w+offset, h+offset), nil)\n\tsrc := ebiten.NewImageWithOptions(image.Rect(-1, -1, 1, 1), nil)\n\tpix := make([]byte, 4*2*2)\n\tfor i := range pix {\n\t\tpix[i] = 0xff\n\t}\n\tsrc.WritePixels(pix)\n\n\top := &ebiten.DrawImageOptions{}\n\top.GeoM.Translate(-1, -1)\n\top.GeoM.Scale(2, 3)\n\tdst.DrawImage(src, op)\n\tfor j := offset; j < h+offset; j++ {\n\t\tfor i := offset; i < w+offset; i++ {\n\t\t\tgot := dst.At(i, j)\n\t\t\tvar want color.RGBA\n\t\t\tif -2 <= i && i < 2 && -3 <= j && j < 3 {\n\t\t\t\twant = color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageOptionsNegativeBoundsDrawTriangles(t *testing.T) {\n\tconst (\n\t\tw      = 16\n\t\th      = 16\n\t\toffset = -8\n\t)\n\tdst := ebiten.NewImageWithOptions(image.Rect(offset, offset, w+offset, h+offset), nil)\n\tsrc := ebiten.NewImageWithOptions(image.Rect(-1, -1, 1, 1), nil)\n\tpix := make([]byte, 4*2*2)\n\tfor i := range pix {\n\t\tpix[i] = 0xff\n\t}\n\tsrc.WritePixels(pix)\n\tvs := []ebiten.Vertex{\n\t\t{\n\t\t\tDstX:   -2,\n\t\t\tDstY:   -3,\n\t\t\tSrcX:   -1,\n\t\t\tSrcY:   -1,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   2,\n\t\t\tDstY:   -3,\n\t\t\tSrcX:   1,\n\t\t\tSrcY:   -1,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   -2,\n\t\t\tDstY:   3,\n\t\t\tSrcX:   -1,\n\t\t\tSrcY:   1,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   2,\n\t\t\tDstY:   3,\n\t\t\tSrcX:   1,\n\t\t\tSrcY:   1,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t}\n\tis := []uint16{0, 1, 2, 1, 2, 3}\n\tdst.DrawTriangles(vs, is, src, nil)\n\tfor j := offset; j < h+offset; j++ {\n\t\tfor i := offset; i < w+offset; i++ {\n\t\t\tgot := dst.At(i, j)\n\t\t\tvar want color.RGBA\n\t\t\tif -2 <= i && i < 2 && -3 <= j && j < 3 {\n\t\t\t\twant = color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageFromImageOptions(t *testing.T) {\n\tr := image.Rect(-2, -3, 4, 5)\n\tpix := make([]byte, 4*r.Dx()*r.Dy())\n\tfor i := range pix {\n\t\tpix[i] = 0xff\n\t}\n\tsrc := &image.RGBA{\n\t\tPix:    pix,\n\t\tStride: 4 * 2,\n\t\tRect:   r,\n\t}\n\n\top := &ebiten.NewImageFromImageOptions{\n\t\tPreserveBounds: true,\n\t}\n\timg := ebiten.NewImageFromImageWithOptions(src, op)\n\tif got, want := img.Bounds(), r; got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n\n\tfor j := r.Min.Y; j < r.Max.Y; j++ {\n\t\tfor i := r.Min.X; i < r.Max.X; i++ {\n\t\t\tgot := img.At(i, j)\n\t\t\twant := color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageFromEbitenImageOptions(t *testing.T) {\n\tr := image.Rect(-2, -3, 4, 5)\n\tsrc := ebiten.NewImageWithOptions(r, nil)\n\tpix := make([]byte, 4*r.Dx()*r.Dy())\n\tfor i := range pix {\n\t\tpix[i] = 0xff\n\t}\n\tsrc.WritePixels(pix)\n\n\top := &ebiten.NewImageFromImageOptions{\n\t\tPreserveBounds: true,\n\t}\n\timg := ebiten.NewImageFromImageWithOptions(src, op)\n\tif got, want := img.Bounds(), r; got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n\n\tfor j := r.Min.Y; j < r.Max.Y; j++ {\n\t\tfor i := r.Min.X; i < r.Max.X; i++ {\n\t\t\tgot := img.At(i, j)\n\t\t\twant := color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #2159\nfunc TestImageOptionsFill(t *testing.T) {\n\tr0 := image.Rect(-2, -3, 4, 5)\n\timg := ebiten.NewImageWithOptions(r0, nil)\n\timg.Fill(color.RGBA{R: 0xff, A: 0xff})\n\tfor j := r0.Min.Y; j < r0.Max.Y; j++ {\n\t\tfor i := r0.Min.X; i < r0.Max.X; i++ {\n\t\t\tgot := img.At(i, j)\n\t\t\twant := color.RGBA{R: 0xff, A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\tr1 := image.Rect(-1, -2, 3, 4)\n\timg.SubImage(r1).(*ebiten.Image).Fill(color.RGBA{G: 0xff, A: 0xff})\n\tfor j := r0.Min.Y; j < r0.Max.Y; j++ {\n\t\tfor i := r0.Min.X; i < r0.Max.X; i++ {\n\t\t\tgot := img.At(i, j)\n\t\t\twant := color.RGBA{R: 0xff, A: 0xff}\n\t\t\tif image.Pt(i, j).In(r1) {\n\t\t\t\twant = color.RGBA{G: 0xff, A: 0xff}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #2159\nfunc TestImageOptionsClear(t *testing.T) {\n\tr0 := image.Rect(-2, -3, 4, 5)\n\timg := ebiten.NewImageWithOptions(r0, nil)\n\timg.Fill(color.RGBA{R: 0xff, A: 0xff})\n\timg.Clear()\n\tfor j := r0.Min.Y; j < r0.Max.Y; j++ {\n\t\tfor i := r0.Min.X; i < r0.Max.X; i++ {\n\t\t\tgot := img.At(i, j)\n\t\t\twant := color.RGBA{}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\timg.Fill(color.RGBA{R: 0xff, A: 0xff})\n\tr1 := image.Rect(-1, -2, 3, 4)\n\timg.SubImage(r1).(*ebiten.Image).Clear()\n\tfor j := r0.Min.Y; j < r0.Max.Y; j++ {\n\t\tfor i := r0.Min.X; i < r0.Max.X; i++ {\n\t\t\tgot := img.At(i, j)\n\t\t\twant := color.RGBA{R: 0xff, A: 0xff}\n\t\t\tif image.Pt(i, j).In(r1) {\n\t\t\t\twant = color.RGBA{}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"img.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #2178\nfunc TestImageTooManyDrawImage(t *testing.T) {\n\tsrc := ebiten.NewImage(1, 1)\n\tsrc.Fill(color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff})\n\n\tconst (\n\t\tw = 256\n\t\th = 256\n\t)\n\tdst := ebiten.NewImage(w, h)\n\n\top := &ebiten.DrawImageOptions{}\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\top.GeoM.Reset()\n\t\t\top.GeoM.Translate(float64(i), float64(j))\n\t\t\tdst.DrawImage(src, op)\n\t\t}\n\t}\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tif got, want := dst.At(i, j), (color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}); got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageTooManyDrawImage2(t *testing.T) {\n\tsrc := ebiten.NewImage(1, 1)\n\tsrc.Fill(color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff})\n\n\tconst (\n\t\tw = 512\n\t\th = 512\n\t)\n\tdst := ebiten.NewImage(w, h)\n\n\tposToColor := func(i, j int) color.RGBA {\n\t\treturn color.RGBA{\n\t\t\tR: byte(i),\n\t\t\tG: byte(j),\n\t\t\tB: 0xff,\n\t\t\tA: 0xff,\n\t\t}\n\t}\n\n\top := &ebiten.DrawImageOptions{}\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\top.GeoM.Reset()\n\t\t\top.GeoM.Translate(float64(i), float64(j))\n\t\t\top.ColorScale.Reset()\n\t\t\top.ColorScale.ScaleWithColor(posToColor(i, j))\n\t\t\tdst.DrawImage(src, op)\n\t\t}\n\t}\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tif got, want := dst.At(i, j).(color.RGBA), posToColor(i, j); !sameColors(got, want, 1) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #2178\nfunc TestImageTooManyDrawTriangles(t *testing.T) {\n\timg := ebiten.NewImage(3, 3)\n\timg.Fill(color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff})\n\tsrc := img.SubImage(image.Rect(1, 1, 2, 2)).(*ebiten.Image)\n\n\tconst (\n\t\tw = 128\n\t\th = 64\n\t)\n\tdst := ebiten.NewImage(w, h)\n\n\tvar vertices []ebiten.Vertex\n\tvar indices []uint16\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tn := uint16(len(vertices))\n\t\t\tvertices = append(vertices,\n\t\t\t\tebiten.Vertex{\n\t\t\t\t\tDstX:   float32(i),\n\t\t\t\t\tDstY:   float32(j),\n\t\t\t\t\tSrcX:   1,\n\t\t\t\t\tSrcY:   1,\n\t\t\t\t\tColorR: 1,\n\t\t\t\t\tColorG: 1,\n\t\t\t\t\tColorB: 1,\n\t\t\t\t\tColorA: 1,\n\t\t\t\t},\n\t\t\t\tebiten.Vertex{\n\t\t\t\t\tDstX:   float32(i) + 1,\n\t\t\t\t\tDstY:   float32(j),\n\t\t\t\t\tSrcX:   2,\n\t\t\t\t\tSrcY:   1,\n\t\t\t\t\tColorR: 1,\n\t\t\t\t\tColorG: 1,\n\t\t\t\t\tColorB: 1,\n\t\t\t\t\tColorA: 1,\n\t\t\t\t},\n\t\t\t\tebiten.Vertex{\n\t\t\t\t\tDstX:   float32(i),\n\t\t\t\t\tDstY:   float32(j) + 1,\n\t\t\t\t\tSrcX:   1,\n\t\t\t\t\tSrcY:   2,\n\t\t\t\t\tColorR: 1,\n\t\t\t\t\tColorG: 1,\n\t\t\t\t\tColorB: 1,\n\t\t\t\t\tColorA: 1,\n\t\t\t\t},\n\t\t\t\tebiten.Vertex{\n\t\t\t\t\tDstX:   float32(i) + 1,\n\t\t\t\t\tDstY:   float32(j) + 1,\n\t\t\t\t\tSrcX:   2,\n\t\t\t\t\tSrcY:   2,\n\t\t\t\t\tColorR: 1,\n\t\t\t\t\tColorG: 1,\n\t\t\t\t\tColorB: 1,\n\t\t\t\t\tColorA: 1,\n\t\t\t\t},\n\t\t\t)\n\t\t\tindices = append(indices, n, n+1, n+2, n+1, n+2, n+3)\n\t\t}\n\t}\n\tdst.DrawTriangles(vertices, indices, src, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tif got, want := dst.At(i, j), (color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}); got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageSetOverSet(t *testing.T) {\n\timg := ebiten.NewImage(1, 1)\n\timg.Set(0, 0, color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff})\n\tif got, want := img.At(0, 0), (color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}); got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n\n\t// Apply the change by 'Set' by calling DrawImage.\n\tdummy := ebiten.NewImage(1, 1)\n\timg.DrawImage(dummy, nil)\n\tif got, want := img.At(0, 0), (color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}); got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n\n\timg.Set(0, 0, color.RGBA{R: 0x80, G: 0x80, B: 0x80, A: 0x80})\n\tif got, want := img.At(0, 0), (color.RGBA{R: 0x80, G: 0x80, B: 0x80, A: 0x80}); got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n\n\t// Apply the change by 'Set' again.\n\timg.DrawImage(dummy, nil)\n\tif got, want := img.At(0, 0), (color.RGBA{R: 0x80, G: 0x80, B: 0x80, A: 0x80}); got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n}\n\n// Issue #2204\nfunc TestImageTooManyConstantBuffersInDirectX(t *testing.T) {\n\tsrc := ebiten.NewImage(3, 3)\n\tsrc.Fill(color.White)\n\tsrc = src.SubImage(image.Rect(1, 1, 2, 2)).(*ebiten.Image)\n\n\tvs := []ebiten.Vertex{\n\t\t{\n\t\t\tDstX: 0, DstY: 0, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 1, ColorG: 1, ColorB: 1, ColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX: 16, DstY: 0, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 1, ColorG: 1, ColorB: 1, ColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX: 0, DstY: 16, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 1, ColorG: 1, ColorB: 1, ColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX: 16, DstY: 16, SrcX: 1, SrcY: 1,\n\t\t\tColorR: 1, ColorG: 1, ColorB: 1, ColorA: 1,\n\t\t},\n\t}\n\tis := []uint16{0, 1, 2, 1, 2, 3}\n\n\tdst0 := ebiten.NewImage(16, 16)\n\tdst1 := ebiten.NewImage(16, 16)\n\top := &ebiten.DrawTrianglesOptions{\n\t\tFillRule: ebiten.FillRuleEvenOdd,\n\t}\n\tfor i := 0; i < 100; i++ {\n\t\tdst0.DrawTriangles(vs, is, src, op)\n\t\tdst1.DrawTriangles(vs, is, src, op)\n\t}\n\n\tif got, want := dst0.At(0, 0), (color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}); got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n\tif got, want := dst1.At(0, 0), (color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}); got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n}\n\nfunc TestImageColorMAndScale(t *testing.T) {\n\tconst w, h = 16, 16\n\tsrc := ebiten.NewImage(w, h)\n\n\tsrc.Fill(color.RGBA{R: 0x80, G: 0x80, B: 0x80, A: 0x80})\n\tvs := []ebiten.Vertex{\n\t\t{\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   0,\n\t\t\tDstX:   0,\n\t\t\tDstY:   0,\n\t\t\tColorR: 0.5,\n\t\t\tColorG: 0.25,\n\t\t\tColorB: 0.5,\n\t\t\tColorA: 0.75,\n\t\t},\n\t\t{\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   0,\n\t\t\tDstX:   w,\n\t\t\tDstY:   0,\n\t\t\tColorR: 0.5,\n\t\t\tColorG: 0.25,\n\t\t\tColorB: 0.5,\n\t\t\tColorA: 0.75,\n\t\t},\n\t\t{\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   h,\n\t\t\tDstX:   0,\n\t\t\tDstY:   h,\n\t\t\tColorR: 0.5,\n\t\t\tColorG: 0.25,\n\t\t\tColorB: 0.5,\n\t\t\tColorA: 0.75,\n\t\t},\n\t\t{\n\t\t\tSrcX:   w,\n\t\t\tSrcY:   h,\n\t\t\tDstX:   w,\n\t\t\tDstY:   h,\n\t\t\tColorR: 0.5,\n\t\t\tColorG: 0.25,\n\t\t\tColorB: 0.5,\n\t\t\tColorA: 0.75,\n\t\t},\n\t}\n\tis := []uint16{0, 1, 2, 1, 2, 3}\n\n\tfor _, format := range []ebiten.ColorScaleMode{\n\t\tebiten.ColorScaleModeStraightAlpha,\n\t\tebiten.ColorScaleModePremultipliedAlpha,\n\t} {\n\t\tformat := format\n\t\tt.Run(fmt.Sprintf(\"format%d\", format), func(t *testing.T) {\n\t\t\tdst := ebiten.NewImage(w, h)\n\n\t\t\top := &ebiten.DrawTrianglesOptions{}\n\t\t\top.ColorM.Translate(0.25, 0.25, 0.25, 0)\n\t\t\top.ColorScaleMode = format\n\t\t\tdst.DrawTriangles(vs, is, src, op)\n\n\t\t\tgot := dst.At(0, 0).(color.RGBA)\n\t\t\talphaBeforeScale := 0.5\n\t\t\tvar want color.RGBA\n\t\t\tswitch format {\n\t\t\tcase ebiten.ColorScaleModeStraightAlpha:\n\t\t\t\twant = color.RGBA{\n\t\t\t\t\tR: byte(math.Floor(0xff * (0.5/alphaBeforeScale + 0.25) * alphaBeforeScale * 0.5 * 0.75)),\n\t\t\t\t\tG: byte(math.Floor(0xff * (0.5/alphaBeforeScale + 0.25) * alphaBeforeScale * 0.25 * 0.75)),\n\t\t\t\t\tB: byte(math.Floor(0xff * (0.5/alphaBeforeScale + 0.25) * alphaBeforeScale * 0.5 * 0.75)),\n\t\t\t\t\tA: byte(math.Floor(0xff * alphaBeforeScale * 0.75)),\n\t\t\t\t}\n\t\t\tcase ebiten.ColorScaleModePremultipliedAlpha:\n\t\t\t\twant = color.RGBA{\n\t\t\t\t\tR: byte(math.Floor(0xff * (0.5/alphaBeforeScale + 0.25) * alphaBeforeScale * 0.5)),\n\t\t\t\t\tG: byte(math.Floor(0xff * (0.5/alphaBeforeScale + 0.25) * alphaBeforeScale * 0.25)),\n\t\t\t\t\tB: byte(math.Floor(0xff * (0.5/alphaBeforeScale + 0.25) * alphaBeforeScale * 0.5)),\n\t\t\t\t\tA: byte(math.Floor(0xff * alphaBeforeScale * 0.75)),\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestImageBlendOperation(t *testing.T) {\n\tconst w, h = 16, 1\n\tdst := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\n\tdstColor := func(i int) (byte, byte, byte, byte) {\n\t\treturn byte(4 * i * 17), byte(4*i*17 + 1), byte(4*i*17 + 2), byte(4*i*17 + 3)\n\t}\n\tsrcColor := func(i int) (byte, byte, byte, byte) {\n\t\treturn byte(4 * i * 13), byte(4*i*13 + 1), byte(4*i*13 + 2), byte(4*i*13 + 3)\n\t}\n\tclamp := func(x int) byte {\n\t\tif x > 255 {\n\t\t\treturn 255\n\t\t}\n\t\tif x < 0 {\n\t\t\treturn 0\n\t\t}\n\t\treturn byte(x)\n\t}\n\n\tdstPix := make([]byte, 4*w*h)\n\tfor i := 0; i < w; i++ {\n\t\tr, g, b, a := dstColor(i)\n\t\tdstPix[4*i] = r\n\t\tdstPix[4*i+1] = g\n\t\tdstPix[4*i+2] = b\n\t\tdstPix[4*i+3] = a\n\t}\n\tsrcPix := make([]byte, 4*w*h)\n\tfor i := 0; i < w; i++ {\n\t\tr, g, b, a := srcColor(i)\n\t\tsrcPix[4*i] = r\n\t\tsrcPix[4*i+1] = g\n\t\tsrcPix[4*i+2] = b\n\t\tsrcPix[4*i+3] = a\n\t}\n\tsrc.WritePixels(srcPix)\n\n\toperations := []ebiten.BlendOperation{\n\t\tebiten.BlendOperationAdd,\n\t\tebiten.BlendOperationSubtract,\n\t\tebiten.BlendOperationReverseSubtract,\n\t}\n\tfor _, rgbOp := range operations {\n\t\tfor _, alphaOp := range operations {\n\t\t\t// Reset the destination state.\n\t\t\tdst.WritePixels(dstPix)\n\t\t\top := &ebiten.DrawImageOptions{}\n\t\t\top.Blend = ebiten.Blend{\n\t\t\t\tBlendFactorSourceRGB:        ebiten.BlendFactorOne,\n\t\t\t\tBlendFactorSourceAlpha:      ebiten.BlendFactorOne,\n\t\t\t\tBlendFactorDestinationRGB:   ebiten.BlendFactorOne,\n\t\t\t\tBlendFactorDestinationAlpha: ebiten.BlendFactorOne,\n\t\t\t\tBlendOperationRGB:           rgbOp,\n\t\t\t\tBlendOperationAlpha:         alphaOp,\n\t\t\t}\n\t\t\tdst.DrawImage(src, op)\n\t\t\tfor i := 0; i < w; i++ {\n\t\t\t\tgot := dst.At(i, 0).(color.RGBA)\n\n\t\t\t\tsr, sg, sb, sa := srcColor(i)\n\t\t\t\tdr, dg, db, da := dstColor(i)\n\n\t\t\t\tvar want color.RGBA\n\t\t\t\tswitch rgbOp {\n\t\t\t\tcase ebiten.BlendOperationAdd:\n\t\t\t\t\twant.R = clamp(int(sr) + int(dr))\n\t\t\t\t\twant.G = clamp(int(sg) + int(dg))\n\t\t\t\t\twant.B = clamp(int(sb) + int(db))\n\t\t\t\tcase ebiten.BlendOperationSubtract:\n\t\t\t\t\twant.R = clamp(int(sr) - int(dr))\n\t\t\t\t\twant.G = clamp(int(sg) - int(dg))\n\t\t\t\t\twant.B = clamp(int(sb) - int(db))\n\t\t\t\tcase ebiten.BlendOperationReverseSubtract:\n\t\t\t\t\twant.R = clamp(int(dr) - int(sr))\n\t\t\t\t\twant.G = clamp(int(dg) - int(sg))\n\t\t\t\t\twant.B = clamp(int(db) - int(sb))\n\t\t\t\t}\n\t\t\t\tswitch alphaOp {\n\t\t\t\tcase ebiten.BlendOperationAdd:\n\t\t\t\t\twant.A = clamp(int(sa) + int(da))\n\t\t\t\tcase ebiten.BlendOperationSubtract:\n\t\t\t\t\twant.A = clamp(int(sa) - int(da))\n\t\t\t\tcase ebiten.BlendOperationReverseSubtract:\n\t\t\t\t\twant.A = clamp(int(da) - int(sa))\n\t\t\t\t}\n\n\t\t\t\tif !sameColors(got, want, 1) {\n\t\t\t\t\tt.Errorf(\"dst.At(%d, 0): operations: %d, %d: got: %v, want: %v\", i, rgbOp, alphaOp, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageBlendOperationMinAndMax(t *testing.T) {\n\tconst w, h = 16, 1\n\tdst := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\n\tdstColor := func(i int) (byte, byte, byte, byte) {\n\t\treturn byte(4 * i * 17), byte(4*i*17 + 1), byte(4*i*17 + 2), byte(4*i*17 + 3)\n\t}\n\tsrcColor := func(i int) (byte, byte, byte, byte) {\n\t\treturn byte(4 * i * 13), byte(4*i*13 + 1), byte(4*i*13 + 2), byte(4*i*13 + 3)\n\t}\n\n\tdstPix := make([]byte, 4*w*h)\n\tfor i := 0; i < w; i++ {\n\t\tr, g, b, a := dstColor(i)\n\t\tdstPix[4*i] = r\n\t\tdstPix[4*i+1] = g\n\t\tdstPix[4*i+2] = b\n\t\tdstPix[4*i+3] = a\n\t}\n\tsrcPix := make([]byte, 4*w*h)\n\tfor i := 0; i < w; i++ {\n\t\tr, g, b, a := srcColor(i)\n\t\tsrcPix[4*i] = r\n\t\tsrcPix[4*i+1] = g\n\t\tsrcPix[4*i+2] = b\n\t\tsrcPix[4*i+3] = a\n\t}\n\tsrc.WritePixels(srcPix)\n\n\toperations := []ebiten.BlendOperation{\n\t\tebiten.BlendOperationMin,\n\t\tebiten.BlendOperationMax,\n\t}\n\tfor _, rgbOp := range operations {\n\t\tfor _, alphaOp := range operations {\n\t\t\t// Reset the destination state.\n\t\t\tdst.WritePixels(dstPix)\n\t\t\top := &ebiten.DrawImageOptions{}\n\t\t\t// Use the default blend factors, and confirm that the factors are ignored.\n\t\t\top.Blend = ebiten.Blend{\n\t\t\t\tBlendFactorSourceRGB:        ebiten.BlendFactorDefault,\n\t\t\t\tBlendFactorSourceAlpha:      ebiten.BlendFactorDefault,\n\t\t\t\tBlendFactorDestinationRGB:   ebiten.BlendFactorDefault,\n\t\t\t\tBlendFactorDestinationAlpha: ebiten.BlendFactorDefault,\n\t\t\t\tBlendOperationRGB:           rgbOp,\n\t\t\t\tBlendOperationAlpha:         alphaOp,\n\t\t\t}\n\t\t\tdst.DrawImage(src, op)\n\t\t\tfor i := 0; i < w; i++ {\n\t\t\t\tgot := dst.At(i, 0).(color.RGBA)\n\n\t\t\t\tsr, sg, sb, sa := srcColor(i)\n\t\t\t\tdr, dg, db, da := dstColor(i)\n\n\t\t\t\tvar want color.RGBA\n\t\t\t\tswitch rgbOp {\n\t\t\t\tcase ebiten.BlendOperationMin:\n\t\t\t\t\twant.R = min(sr, dr)\n\t\t\t\t\twant.G = min(sg, dg)\n\t\t\t\t\twant.B = min(sb, db)\n\t\t\t\tcase ebiten.BlendOperationMax:\n\t\t\t\t\twant.R = max(sr, dr)\n\t\t\t\t\twant.G = max(sg, dg)\n\t\t\t\t\twant.B = max(sb, db)\n\t\t\t\t}\n\t\t\t\tswitch alphaOp {\n\t\t\t\tcase ebiten.BlendOperationMin:\n\t\t\t\t\twant.A = min(sa, da)\n\t\t\t\tcase ebiten.BlendOperationMax:\n\t\t\t\t\twant.A = max(sa, da)\n\t\t\t\t}\n\n\t\t\t\tif !sameColors(got, want, 1) {\n\t\t\t\t\tt.Errorf(\"dst.At(%d, 0): operations: %d, %d: got: %v, want: %v\", i, rgbOp, alphaOp, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageBlendFactor(t *testing.T) {\n\tif skipTooSlowTests(t) {\n\t\treturn\n\t}\n\n\tconst w, h = 16, 1\n\tdst := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\n\tdstColor := func(i int) (byte, byte, byte, byte) {\n\t\treturn byte(4 * i * 17), byte(4*i*17 + 1), byte(4*i*17 + 2), byte(4*i*17 + 3)\n\t}\n\tsrcColor := func(i int) (byte, byte, byte, byte) {\n\t\treturn byte(4 * i * 13), byte(4*i*13 + 1), byte(4*i*13 + 2), byte(4*i*13 + 3)\n\t}\n\tcolorToFloats := func(r, g, b, a byte) (float64, float64, float64, float64) {\n\t\treturn float64(r) / 0xff, float64(g) / 0xff, float64(b) / 0xff, float64(a) / 0xff\n\t}\n\tclamp := func(x int) byte {\n\t\tif x > 255 {\n\t\t\treturn 255\n\t\t}\n\t\tif x < 0 {\n\t\t\treturn 0\n\t\t}\n\t\treturn byte(x)\n\t}\n\n\tdstPix := make([]byte, 4*w*h)\n\tfor i := 0; i < w; i++ {\n\t\tr, g, b, a := dstColor(i)\n\t\tdstPix[4*i] = r\n\t\tdstPix[4*i+1] = g\n\t\tdstPix[4*i+2] = b\n\t\tdstPix[4*i+3] = a\n\t}\n\tsrcPix := make([]byte, 4*w*h)\n\tfor i := 0; i < w; i++ {\n\t\tr, g, b, a := srcColor(i)\n\t\tsrcPix[4*i] = r\n\t\tsrcPix[4*i+1] = g\n\t\tsrcPix[4*i+2] = b\n\t\tsrcPix[4*i+3] = a\n\t}\n\tsrc.WritePixels(srcPix)\n\n\tfactors := []ebiten.BlendFactor{\n\t\tebiten.BlendFactorZero,\n\t\tebiten.BlendFactorOne,\n\t\tebiten.BlendFactorSourceColor,\n\t\tebiten.BlendFactorOneMinusSourceColor,\n\t\tebiten.BlendFactorSourceAlpha,\n\t\tebiten.BlendFactorOneMinusSourceAlpha,\n\t\tebiten.BlendFactorDestinationColor,\n\t\tebiten.BlendFactorOneMinusDestinationColor,\n\t\tebiten.BlendFactorDestinationAlpha,\n\t\tebiten.BlendFactorOneMinusDestinationAlpha,\n\t}\n\tfor _, srcRGBFactor := range factors {\n\t\tfor _, srcAlphaFactor := range factors {\n\t\t\tfor _, dstRGBFactor := range factors {\n\t\t\t\tfor _, dstAlphaFactor := range factors {\n\t\t\t\t\t// Reset the destination state.\n\t\t\t\t\tdst.WritePixels(dstPix)\n\t\t\t\t\top := &ebiten.DrawImageOptions{}\n\t\t\t\t\top.Blend = ebiten.Blend{\n\t\t\t\t\t\tBlendFactorSourceRGB:        srcRGBFactor,\n\t\t\t\t\t\tBlendFactorSourceAlpha:      srcAlphaFactor,\n\t\t\t\t\t\tBlendFactorDestinationRGB:   dstRGBFactor,\n\t\t\t\t\t\tBlendFactorDestinationAlpha: dstAlphaFactor,\n\t\t\t\t\t\tBlendOperationRGB:           ebiten.BlendOperationAdd,\n\t\t\t\t\t\tBlendOperationAlpha:         ebiten.BlendOperationAdd,\n\t\t\t\t\t}\n\t\t\t\t\tdst.DrawImage(src, op)\n\t\t\t\t\tfor i := 0; i < w; i++ {\n\t\t\t\t\t\tgot := dst.At(i, 0).(color.RGBA)\n\n\t\t\t\t\t\tsr, sg, sb, sa := colorToFloats(srcColor(i))\n\t\t\t\t\t\tdr, dg, db, da := colorToFloats(dstColor(i))\n\n\t\t\t\t\t\tvar r, g, b, a float64\n\n\t\t\t\t\t\tswitch srcRGBFactor {\n\t\t\t\t\t\tcase ebiten.BlendFactorZero:\n\t\t\t\t\t\t\tr += 0 * sr\n\t\t\t\t\t\t\tg += 0 * sg\n\t\t\t\t\t\t\tb += 0 * sb\n\t\t\t\t\t\tcase ebiten.BlendFactorOne:\n\t\t\t\t\t\t\tr += 1 * sr\n\t\t\t\t\t\t\tg += 1 * sg\n\t\t\t\t\t\t\tb += 1 * sb\n\t\t\t\t\t\tcase ebiten.BlendFactorSourceColor:\n\t\t\t\t\t\t\tr += sr * sr\n\t\t\t\t\t\t\tg += sg * sg\n\t\t\t\t\t\t\tb += sb * sb\n\t\t\t\t\t\tcase ebiten.BlendFactorOneMinusSourceColor:\n\t\t\t\t\t\t\tr += (1 - sr) * sr\n\t\t\t\t\t\t\tg += (1 - sg) * sg\n\t\t\t\t\t\t\tb += (1 - sb) * sb\n\t\t\t\t\t\tcase ebiten.BlendFactorSourceAlpha:\n\t\t\t\t\t\t\tr += sa * sr\n\t\t\t\t\t\t\tg += sa * sg\n\t\t\t\t\t\t\tb += sa * sb\n\t\t\t\t\t\tcase ebiten.BlendFactorOneMinusSourceAlpha:\n\t\t\t\t\t\t\tr += (1 - sa) * sr\n\t\t\t\t\t\t\tg += (1 - sa) * sg\n\t\t\t\t\t\t\tb += (1 - sa) * sb\n\t\t\t\t\t\tcase ebiten.BlendFactorDestinationColor:\n\t\t\t\t\t\t\tr += dr * sr\n\t\t\t\t\t\t\tg += dg * sg\n\t\t\t\t\t\t\tb += db * sb\n\t\t\t\t\t\tcase ebiten.BlendFactorOneMinusDestinationColor:\n\t\t\t\t\t\t\tr += (1 - dr) * sr\n\t\t\t\t\t\t\tg += (1 - dg) * sg\n\t\t\t\t\t\t\tb += (1 - db) * sb\n\t\t\t\t\t\tcase ebiten.BlendFactorDestinationAlpha:\n\t\t\t\t\t\t\tr += da * sr\n\t\t\t\t\t\t\tg += da * sg\n\t\t\t\t\t\t\tb += da * sb\n\t\t\t\t\t\tcase ebiten.BlendFactorOneMinusDestinationAlpha:\n\t\t\t\t\t\t\tr += (1 - da) * sr\n\t\t\t\t\t\t\tg += (1 - da) * sg\n\t\t\t\t\t\t\tb += (1 - da) * sb\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch srcAlphaFactor {\n\t\t\t\t\t\tcase ebiten.BlendFactorZero:\n\t\t\t\t\t\t\ta += 0 * sa\n\t\t\t\t\t\tcase ebiten.BlendFactorOne:\n\t\t\t\t\t\t\ta += 1 * sa\n\t\t\t\t\t\tcase ebiten.BlendFactorSourceColor, ebiten.BlendFactorSourceAlpha:\n\t\t\t\t\t\t\ta += sa * sa\n\t\t\t\t\t\tcase ebiten.BlendFactorOneMinusSourceColor, ebiten.BlendFactorOneMinusSourceAlpha:\n\t\t\t\t\t\t\ta += (1 - sa) * sa\n\t\t\t\t\t\tcase ebiten.BlendFactorDestinationColor, ebiten.BlendFactorDestinationAlpha:\n\t\t\t\t\t\t\ta += da * sa\n\t\t\t\t\t\tcase ebiten.BlendFactorOneMinusDestinationColor, ebiten.BlendFactorOneMinusDestinationAlpha:\n\t\t\t\t\t\t\ta += (1 - da) * sa\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch dstRGBFactor {\n\t\t\t\t\t\tcase ebiten.BlendFactorZero:\n\t\t\t\t\t\t\tr += 0 * dr\n\t\t\t\t\t\t\tg += 0 * dg\n\t\t\t\t\t\t\tb += 0 * db\n\t\t\t\t\t\tcase ebiten.BlendFactorOne:\n\t\t\t\t\t\t\tr += 1 * dr\n\t\t\t\t\t\t\tg += 1 * dg\n\t\t\t\t\t\t\tb += 1 * db\n\t\t\t\t\t\tcase ebiten.BlendFactorSourceColor:\n\t\t\t\t\t\t\tr += sr * dr\n\t\t\t\t\t\t\tg += sg * dg\n\t\t\t\t\t\t\tb += sb * db\n\t\t\t\t\t\tcase ebiten.BlendFactorOneMinusSourceColor:\n\t\t\t\t\t\t\tr += (1 - sr) * dr\n\t\t\t\t\t\t\tg += (1 - sg) * dg\n\t\t\t\t\t\t\tb += (1 - sb) * db\n\t\t\t\t\t\tcase ebiten.BlendFactorSourceAlpha:\n\t\t\t\t\t\t\tr += sa * dr\n\t\t\t\t\t\t\tg += sa * dg\n\t\t\t\t\t\t\tb += sa * db\n\t\t\t\t\t\tcase ebiten.BlendFactorOneMinusSourceAlpha:\n\t\t\t\t\t\t\tr += (1 - sa) * dr\n\t\t\t\t\t\t\tg += (1 - sa) * dg\n\t\t\t\t\t\t\tb += (1 - sa) * db\n\t\t\t\t\t\tcase ebiten.BlendFactorDestinationColor:\n\t\t\t\t\t\t\tr += dr * dr\n\t\t\t\t\t\t\tg += dg * dg\n\t\t\t\t\t\t\tb += db * db\n\t\t\t\t\t\tcase ebiten.BlendFactorOneMinusDestinationColor:\n\t\t\t\t\t\t\tr += (1 - dr) * dr\n\t\t\t\t\t\t\tg += (1 - dg) * dg\n\t\t\t\t\t\t\tb += (1 - db) * db\n\t\t\t\t\t\tcase ebiten.BlendFactorDestinationAlpha:\n\t\t\t\t\t\t\tr += da * dr\n\t\t\t\t\t\t\tg += da * dg\n\t\t\t\t\t\t\tb += da * db\n\t\t\t\t\t\tcase ebiten.BlendFactorOneMinusDestinationAlpha:\n\t\t\t\t\t\t\tr += (1 - da) * dr\n\t\t\t\t\t\t\tg += (1 - da) * dg\n\t\t\t\t\t\t\tb += (1 - da) * db\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch dstAlphaFactor {\n\t\t\t\t\t\tcase ebiten.BlendFactorZero:\n\t\t\t\t\t\t\ta += 0 * da\n\t\t\t\t\t\tcase ebiten.BlendFactorOne:\n\t\t\t\t\t\t\ta += 1 * da\n\t\t\t\t\t\tcase ebiten.BlendFactorSourceColor, ebiten.BlendFactorSourceAlpha:\n\t\t\t\t\t\t\ta += sa * da\n\t\t\t\t\t\tcase ebiten.BlendFactorOneMinusSourceColor, ebiten.BlendFactorOneMinusSourceAlpha:\n\t\t\t\t\t\t\ta += (1 - sa) * da\n\t\t\t\t\t\tcase ebiten.BlendFactorDestinationColor, ebiten.BlendFactorDestinationAlpha:\n\t\t\t\t\t\t\ta += da * da\n\t\t\t\t\t\tcase ebiten.BlendFactorOneMinusDestinationColor, ebiten.BlendFactorOneMinusDestinationAlpha:\n\t\t\t\t\t\t\ta += (1 - da) * da\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twant := color.RGBA{\n\t\t\t\t\t\t\tR: clamp(int(r * 0xff)),\n\t\t\t\t\t\t\tG: clamp(int(g * 0xff)),\n\t\t\t\t\t\t\tB: clamp(int(b * 0xff)),\n\t\t\t\t\t\t\tA: clamp(int(a * 0xff)),\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif !sameColors(got, want, 1) {\n\t\t\t\t\t\t\tt.Errorf(\"dst.At(%d, 0): factors: %d, %d, %d, %d: got: %v, want: %v\", i, srcRGBFactor, srcAlphaFactor, dstRGBFactor, dstAlphaFactor, got, want)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageAntiAlias(t *testing.T) {\n\t// This value depends on internal/ui.bigOffscreenScale. Sync this.\n\tconst bigOffscreenScale = 2\n\n\tconst w, h = 272, 208\n\n\tdst0 := ebiten.NewImage(w, h)\n\tdst1 := ebiten.NewImage(w, h)\n\ttmp := ebiten.NewImage(w*bigOffscreenScale, h*bigOffscreenScale)\n\tsrc := ebiten.NewImage(3, 3)\n\tsrc.Fill(color.RGBA{R: 0x24, G: 0x3f, B: 0x6a, A: 0x88})\n\n\tfor _, blend := range []ebiten.Blend{\n\t\t{}, // Default\n\t\tebiten.BlendClear,\n\t\tebiten.BlendCopy,\n\t\tebiten.BlendSourceOver,\n\t\tebiten.BlendDestinationOver,\n\t\tebiten.BlendXor,\n\t\tebiten.BlendLighter,\n\t} {\n\t\trnd := rand.New(rand.NewPCG(0, 0))\n\t\tmax := func(x, y, z byte) byte {\n\t\t\tif x >= y && x >= z {\n\t\t\t\treturn x\n\t\t\t}\n\t\t\tif y >= x && y >= z {\n\t\t\t\treturn y\n\t\t\t}\n\t\t\treturn z\n\t\t}\n\n\t\tdstPix := make([]byte, 4*w*h)\n\t\tfor i := 0; i < w*h; i++ {\n\t\t\tn := rnd.Int()\n\t\t\tr, g, b := byte(n), byte(n>>8), byte(n>>16)\n\t\t\ta := max(r, g, b)\n\t\t\tdstPix[4*i] = r\n\t\t\tdstPix[4*i+1] = g\n\t\t\tdstPix[4*i+2] = b\n\t\t\tdstPix[4*i+3] = a\n\t\t}\n\t\tdst0.WritePixels(dstPix)\n\t\tdst1.WritePixels(dstPix)\n\n\t\ttmp.Clear()\n\n\t\t// Create an actual result.\n\t\top := &ebiten.DrawTrianglesOptions{}\n\t\top.Blend = blend\n\t\top.AntiAlias = true\n\t\tvs0 := []ebiten.Vertex{\n\t\t\t{\n\t\t\t\tDstX:   w / 4,\n\t\t\t\tDstY:   h / 4,\n\t\t\t\tSrcX:   1,\n\t\t\t\tSrcY:   1,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tDstX:   2 * w / 4,\n\t\t\t\tDstY:   h / 4,\n\t\t\t\tSrcX:   2,\n\t\t\t\tSrcY:   1,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tDstX:   w / 4,\n\t\t\t\tDstY:   2 * h / 4,\n\t\t\t\tSrcX:   1,\n\t\t\t\tSrcY:   2,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t}\n\t\tis := []uint16{0, 1, 2}\n\t\tdst0.DrawTriangles(vs0, is, src, op)\n\n\t\tvs1 := []ebiten.Vertex{\n\t\t\t{\n\t\t\t\tDstX:   2 * w / 4,\n\t\t\t\tDstY:   3 * h / 4,\n\t\t\t\tSrcX:   1,\n\t\t\t\tSrcY:   2,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tDstX:   3 * w / 4,\n\t\t\t\tDstY:   2 * h / 4,\n\t\t\t\tSrcX:   2,\n\t\t\t\tSrcY:   1,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tDstX:   3 * w / 4,\n\t\t\t\tDstY:   3 * h / 4,\n\t\t\t\tSrcX:   2,\n\t\t\t\tSrcY:   2,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t}\n\t\tdst0.DrawTriangles(vs1, is, src, op)\n\n\t\t// Create an expected result.\n\t\t// Copy an enlarged destination image to the offscreen.\n\t\topCopy := &ebiten.DrawImageOptions{}\n\t\topCopy.GeoM.Scale(bigOffscreenScale, bigOffscreenScale)\n\t\topCopy.Blend = ebiten.BlendCopy\n\t\ttmp.DrawImage(dst1, opCopy)\n\n\t\t// Render the vertices onto the offscreen.\n\t\tfor i := range vs0 {\n\t\t\tvs0[i].DstX *= 2\n\t\t\tvs0[i].DstY *= 2\n\t\t}\n\t\tfor i := range vs1 {\n\t\t\tvs1[i].DstX *= 2\n\t\t\tvs1[i].DstY *= 2\n\t\t}\n\t\top = &ebiten.DrawTrianglesOptions{}\n\t\top.Blend = blend\n\t\ttmp.DrawTriangles(vs0, is, src, op)\n\t\ttmp.DrawTriangles(vs1, is, src, op)\n\n\t\t// Render a shrunk offscreen image onto the destination.\n\t\topShrink := &ebiten.DrawImageOptions{}\n\t\topShrink.GeoM.Scale(1.0/bigOffscreenScale, 1.0/bigOffscreenScale)\n\t\topShrink.Filter = ebiten.FilterLinear\n\t\topShrink.Blend = ebiten.BlendCopy\n\t\tdst1.DrawImage(tmp, opShrink)\n\n\t\tfor j := 0; j < h; j++ {\n\t\t\tfor i := 0; i < w; i++ {\n\t\t\t\tgot := dst0.At(i, j).(color.RGBA)\n\t\t\t\twant := dst1.At(i, j).(color.RGBA)\n\t\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\t\tt.Errorf(\"At(%d, %d), blend: %v, got: %v, want: %v\", i, j, blend, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestImageColorMScale(t *testing.T) {\n\tconst w, h = 16, 16\n\tdst0 := ebiten.NewImage(w, h)\n\tdst1 := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\tsrc.Fill(color.RGBA{R: 0x24, G: 0x3f, B: 0x6a, A: 0x88})\n\n\t// As the ColorM is a diagonal matrix, a built-in shader for a color matrix is NOT used.\n\top := &ebiten.DrawImageOptions{}\n\top.ColorM.Scale(0.3, 0.4, 0.5, 0.6)\n\tdst0.DrawImage(src, op)\n\n\t// As the ColorM is not a diagonal matrix, a built-in shader for a color matrix is used.\n\top = &ebiten.DrawImageOptions{}\n\top.ColorM.Scale(0.3, 0.4, 0.5, 0.6)\n\top.ColorM.Translate(0, 0, 0, 1e-4)\n\tdst1.DrawImage(src, op)\n\n\tgot := dst0.At(0, 0)\n\twant := dst1.At(0, 0)\n\tif got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n}\n\nfunc TestImageColorScaleAndColorM(t *testing.T) {\n\tconst w, h = 16, 16\n\tdst0 := ebiten.NewImage(w, h)\n\tdst1 := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\tsrc.Fill(color.RGBA{R: 0x24, G: 0x3f, B: 0x6a, A: 0x88})\n\n\t// ColorScale is applied to premultiplied-alpha colors.\n\top := &ebiten.DrawImageOptions{}\n\top.ColorScale.Scale(0.3*0.6, 0.4*0.6, 0.5*0.6, 0.6)\n\tdst0.DrawImage(src, op)\n\n\t// ColorM.Scale is applied to straight-alpha colors.\n\top = &ebiten.DrawImageOptions{}\n\top.ColorM.Scale(0.3, 0.4, 0.5, 0.6)\n\tdst1.DrawImage(src, op)\n\n\tgot := dst0.At(0, 0)\n\twant := dst1.At(0, 0)\n\tif got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n}\n\n// Issue #2428\nfunc TestImageSetAndSubImage(t *testing.T) {\n\tconst w, h = 16, 16\n\timg := ebiten.NewImage(w, h)\n\timg.Set(1, 1, color.RGBA{R: 0xff, A: 0xff})\n\tgot := img.SubImage(image.Rect(0, 0, w, h)).At(1, 1).(color.RGBA)\n\twant := color.RGBA{R: 0xff, A: 0xff}\n\tif got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n}\n\n// Issue #2611\nfunc TestImageDrawTrianglesWithGreaterIndexThanVerticesCount(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"DrawTriangles must panic but not\")\n\t\t}\n\t}()\n\n\tconst w, h = 16, 16\n\tdst := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\n\tvs := make([]ebiten.Vertex, 4)\n\tis := []uint16{0, 1, 2, 1, 2, 4}\n\tdst.DrawTriangles(vs, is, src, nil)\n}\n\n// Issue #2611\nfunc TestImageDrawTrianglesShaderWithGreaterIndexThanVerticesCount(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"DrawTrianglesShader must panic but not\")\n\t\t}\n\t}()\n\n\tconst w, h = 16, 16\n\tdst := ebiten.NewImage(w, h)\n\n\tvs := make([]ebiten.Vertex, 4)\n\tis := []uint16{0, 1, 2, 1, 2, 4}\n\tshader, err := ebiten.NewShader([]byte(`\n\t\tpackage main\n\t\tfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\t\t\treturn color\n\t\t}\n\t`))\n\tif err != nil {\n\t\tt.Fatalf(\"could not compile shader: %v\", err)\n\t}\n\tdst.DrawTrianglesShader(vs, is, shader, nil)\n}\n\n// Issue #2733\nfunc TestImageGeoMAfterDraw(t *testing.T) {\n\tsrc := ebiten.NewImage(1, 1)\n\tdst := ebiten.NewImageWithOptions(image.Rect(-1, -1, 0, 0), nil)\n\top0 := &ebiten.DrawImageOptions{}\n\tdst.DrawImage(src, op0)\n\tif x, y := op0.GeoM.Apply(0, 0); x != 0 || y != 0 {\n\t\tt.Errorf(\"got: (%0.2f, %0.2f), want: (0, 0)\", x, y)\n\t}\n\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\top1 := &ebiten.DrawRectShaderOptions{}\n\tdst.DrawRectShader(1, 1, s, op1)\n\tif x, y := op1.GeoM.Apply(0, 0); x != 0 || y != 0 {\n\t\tt.Errorf(\"got: (%0.2f, %0.2f), want: (0, 0)\", x, y)\n\t}\n}\n\nfunc TestImageWritePixelAndDispose(t *testing.T) {\n\tconst (\n\t\tw = 16\n\t\th = 16\n\t)\n\timg := ebiten.NewImage(w, h)\n\tpix := make([]byte, 4*w*h)\n\tfor i := range pix {\n\t\tpix[i] = 0xff\n\t}\n\timg.WritePixels(pix)\n\timg.Dispose()\n\n\t// Confirm that any pixel information is invalidated after Dispose is called.\n\tif got, want := img.At(0, 0), (color.RGBA{}); got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n}\n\nfunc TestImageWritePixelAndDeallocate(t *testing.T) {\n\tconst (\n\t\tw = 16\n\t\th = 16\n\t)\n\timg := ebiten.NewImage(w, h)\n\tpix := make([]byte, 4*w*h)\n\tfor i := range pix {\n\t\tpix[i] = 0xff\n\t}\n\timg.WritePixels(pix)\n\timg.Deallocate()\n\n\t// Confirm that any pixel information is cleared after Deallocate is called.\n\tif got, want := img.At(0, 0), (color.RGBA{}); got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n}\n\nfunc TestImageDrawImageAfterDeallocation(t *testing.T) {\n\tsrc, _, err := openEbitenImage()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t\treturn\n\t}\n\n\tw, h := src.Bounds().Dx(), src.Bounds().Dy()\n\tdst := ebiten.NewImage(w, h)\n\n\tdst.DrawImage(src, nil)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j)\n\t\t\twant := src.At(i, j)\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Even after deallocating the image, the image is still available.\n\tdst.Deallocate()\n\n\tdst.DrawImage(src, nil)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j)\n\t\t\twant := src.At(i, j)\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #2798\nfunc TestImageInvalidPremultipliedAlphaColor(t *testing.T) {\n\t// This test checks the rendering result when Set and WritePixels use an invalid premultiplied alpha color.\n\t// The result values are kept and not clamped.\n\n\tconst (\n\t\tw = 16\n\t\th = 16\n\t)\n\n\tdst := ebiten.NewImage(w, h)\n\tdst.Set(0, 0, color.RGBA{R: 0xff, G: 0xc0, B: 0x80, A: 0x40})\n\tdst.Set(0, 1, color.RGBA{R: 0xff, G: 0xc0, B: 0x80, A: 0x00})\n\tif got, want := dst.At(0, 0).(color.RGBA), (color.RGBA{R: 0xff, G: 0xc0, B: 0x80, A: 0x40}); got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n\tif got, want := dst.At(0, 1).(color.RGBA), (color.RGBA{R: 0xff, G: 0xc0, B: 0x80, A: 0x00}); got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n\n\tpix := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tpix[4*(j*16+i)] = byte(i)\n\t\t\tpix[4*(j*16+i)+1] = byte(j)\n\t\t\tpix[4*(j*16+i)+2] = 0x80\n\t\t\tpix[4*(j*16+i)+3] = byte(i - j)\n\t\t}\n\t}\n\tdst.WritePixels(pix)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j)\n\t\t\twant := color.RGBA{R: byte(i), G: byte(j), B: 0x80, A: byte(i - j)}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "imagedumper.go",
          "type": "blob",
          "size": 4.1806640625,
          "content": "// Copyright 2018 The Ebiten Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"time\"\n\n\t\"github.com/hajimehoshi/ebiten/v2/internal/debug\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\nfunc datetimeForFilename() string {\n\tconst datetimeFormat = \"20060102150405\"\n\tnow := time.Now()\n\treturn now.Format(datetimeFormat)\n}\n\nfunc takeScreenshot(screen *Image, transparent bool) error {\n\tname := \"screenshot_\" + datetimeForFilename() + \".png\"\n\t// Use the home directory for mobiles as a provisional implementation.\n\tif runtime.GOOS == \"android\" || runtime.GOOS == \"ios\" {\n\t\thome, err := os.UserHomeDir()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tname = filepath.Join(home, name)\n\t}\n\tdumpedName, err := screen.image.DumpScreenshot(name, !transparent)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif _, err := fmt.Fprintf(os.Stderr, \"Saved screenshot: %s\\n\", dumpedName); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc dumpInternalImages() error {\n\tdumpedDir, err := ui.Get().DumpImages(\"internalimages_\" + datetimeForFilename())\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Use the home directory for mobiles as a provisional implementation.\n\tif runtime.GOOS == \"android\" || runtime.GOOS == \"ios\" {\n\t\thome, err := os.UserHomeDir()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdumpedDir = filepath.Join(home, dumpedDir)\n\t}\n\tif _, err := fmt.Fprintf(os.Stderr, \"Dumped the internal images at: %s\\n\", dumpedDir); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\ntype imageDumper struct {\n\tkeyState map[Key]int\n\n\thasScreenshotKey bool\n\tscreenshotKey    Key\n\ttoTakeScreenshot bool\n\n\thasDumpInternalImagesKey bool\n\tdumpInternalImagesKey    Key\n\ttoDumpInternalImages     bool\n\n\terr error\n}\n\nfunc envScreenshotKey() string {\n\tif env := os.Getenv(\"EBITENGINE_SCREENSHOT_KEY\"); env != \"\" {\n\t\treturn env\n\t}\n\t// For backward compatibility, read the EBITEN_ version.\n\treturn os.Getenv(\"EBITEN_SCREENSHOT_KEY\")\n}\n\nfunc envInternalImagesKey() string {\n\tif env := os.Getenv(\"EBITENGINE_INTERNAL_IMAGES_KEY\"); env != \"\" {\n\t\treturn env\n\t}\n\t// For backward compatibility, read the EBITEN_ version.\n\treturn os.Getenv(\"EBITEN_INTERNAL_IMAGES_KEY\")\n}\n\nfunc (i *imageDumper) update() error {\n\tif i.err != nil {\n\t\treturn i.err\n\t}\n\n\t// If keyState is nil, all values are not initialized.\n\tif i.keyState == nil {\n\t\ti.keyState = map[Key]int{}\n\n\t\tif keyname := envScreenshotKey(); keyname != \"\" {\n\t\t\tif key, ok := keyNameToKeyCode(keyname); ok {\n\t\t\t\ti.hasScreenshotKey = true\n\t\t\t\ti.screenshotKey = key\n\t\t\t}\n\t\t}\n\n\t\tif keyname := envInternalImagesKey(); keyname != \"\" {\n\t\t\tif debug.IsDebug {\n\t\t\t\tif key, ok := keyNameToKeyCode(keyname); ok {\n\t\t\t\t\ti.hasDumpInternalImagesKey = true\n\t\t\t\t\ti.dumpInternalImagesKey = key\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"EBITENGINE_INTERNAL_IMAGES_KEY is disabled. Specify a build tag 'ebitenginedebug' to enable it.\\n\")\n\t\t\t}\n\t\t}\n\t}\n\n\tkeys := map[Key]struct{}{}\n\tif i.hasScreenshotKey {\n\t\tkeys[i.screenshotKey] = struct{}{}\n\t}\n\tif i.hasDumpInternalImagesKey {\n\t\tkeys[i.dumpInternalImagesKey] = struct{}{}\n\t}\n\n\tfor key := range keys {\n\t\tif IsKeyPressed(key) {\n\t\t\ti.keyState[key]++\n\t\t\tif i.keyState[key] == 1 {\n\t\t\t\tif i.hasScreenshotKey && key == i.screenshotKey {\n\t\t\t\t\ti.toTakeScreenshot = true\n\t\t\t\t}\n\t\t\t\tif i.hasDumpInternalImagesKey && key == i.dumpInternalImagesKey {\n\t\t\t\t\ti.toDumpInternalImages = true\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ti.keyState[key] = 0\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (i *imageDumper) dump(screen *Image, transparent bool) error {\n\tif i.toTakeScreenshot {\n\t\ti.toTakeScreenshot = false\n\t\tif err := takeScreenshot(screen, transparent); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif i.toDumpInternalImages {\n\t\ti.toDumpInternalImages = false\n\t\tif err := dumpInternalImages(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "imagetobytes.go",
          "type": "blob",
          "size": 2.234375,
          "content": "// Copyright 2017 The Ebiten Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"image/draw\"\n)\n\n// imageToBytes gets RGBA bytes from img.\n//\n// Basically imageToBytes just calls draw.Draw.\n// If img is a paletted image, an optimized copying method is used.\n//\n// If img is *image.RGBA and its length is same as 4*width*height, imageToBytes returns its Pix.\nfunc imageToBytes(img image.Image) []byte {\n\tsize := img.Bounds().Size()\n\tw, h := size.X, size.Y\n\n\tswitch img := img.(type) {\n\tcase *image.Paletted:\n\t\tbs := make([]byte, 4*w*h)\n\n\t\tb := img.Bounds()\n\t\tx0 := b.Min.X\n\t\ty0 := b.Min.Y\n\t\tx1 := b.Max.X\n\t\ty1 := b.Max.Y\n\n\t\tpalette := make([]uint8, len(img.Palette)*4)\n\t\tfor i, c := range img.Palette {\n\t\t\trgba := color.RGBAModel.Convert(c).(color.RGBA)\n\t\t\tpalette[4*i] = rgba.R\n\t\t\tpalette[4*i+1] = rgba.G\n\t\t\tpalette[4*i+2] = rgba.B\n\t\t\tpalette[4*i+3] = rgba.A\n\t\t}\n\t\t// Even img is a subimage of another image, Pix starts with 0-th index.\n\t\tidx0 := 0\n\t\tidx1 := 0\n\t\td := img.Stride - (x1 - x0)\n\t\tfor j := 0; j < y1-y0; j++ {\n\t\t\tfor i := 0; i < x1-x0; i++ {\n\t\t\t\tp := int(img.Pix[idx0])\n\t\t\t\tbs[idx1] = palette[4*p]\n\t\t\t\tbs[idx1+1] = palette[4*p+1]\n\t\t\t\tbs[idx1+2] = palette[4*p+2]\n\t\t\t\tbs[idx1+3] = palette[4*p+3]\n\t\t\t\tidx0++\n\t\t\t\tidx1 += 4\n\t\t\t}\n\t\t\tidx0 += d\n\t\t}\n\t\treturn bs\n\tcase *image.RGBA:\n\t\tif len(img.Pix) == 4*w*h {\n\t\t\treturn img.Pix\n\t\t}\n\t\treturn imageToBytesSlow(img)\n\tdefault:\n\t\treturn imageToBytesSlow(img)\n\t}\n}\n\nfunc imageToBytesSlow(img image.Image) []byte {\n\tsize := img.Bounds().Size()\n\tw, h := size.X, size.Y\n\tbs := make([]byte, 4*w*h)\n\n\tdstImg := &image.RGBA{\n\t\tPix:    bs,\n\t\tStride: 4 * w,\n\t\tRect:   image.Rect(0, 0, w, h),\n\t}\n\tdraw.Draw(dstImg, image.Rect(0, 0, w, h), img, img.Bounds().Min, draw.Src)\n\treturn bs\n}\n"
        },
        {
          "name": "imagetobytes_test.go",
          "type": "blob",
          "size": 3.2431640625,
          "content": "// Copyright 2016 The Ebiten Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten_test\n\nimport (\n\t\"bytes\"\n\t\"image\"\n\t\"image/color\"\n\t\"image/color/palette\"\n\t\"testing\"\n\n\t\"github.com/hajimehoshi/ebiten/v2\"\n)\n\nfunc TestImageToBytes(t *testing.T) {\n\tpal := make(color.Palette, 256)\n\tfor i := range pal {\n\t\tpal[i] = color.White\n\t}\n\tp := make([]color.Color, 255)\n\tfor i := range p {\n\t\tif i == 64 {\n\t\t\tp[i] = color.White\n\t\t} else {\n\t\t\tp[i] = color.Transparent\n\t\t}\n\t}\n\tbigPalette := color.Palette(p)\n\tcases := []struct {\n\t\tIn  image.Image\n\t\tOut []uint8\n\t}{\n\t\t{\n\t\t\tIn: &image.Paletted{\n\t\t\t\tPix:    []uint8{0, 1, 1, 0},\n\t\t\t\tStride: 2,\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t\tPalette: color.Palette([]color.Color{\n\t\t\t\t\tcolor.Transparent, color.White,\n\t\t\t\t}),\n\t\t\t},\n\t\t\tOut: []uint8{0, 0, 0, 0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0, 0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tIn:  image.NewPaletted(image.Rect(0, 0, 240, 160), pal).SubImage(image.Rect(238, 158, 240, 160)),\n\t\t\tOut: []uint8{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t},\n\t\t{\n\t\t\tIn: &image.RGBA{\n\t\t\t\tPix:    []uint8{0, 0, 0, 0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0, 0, 0, 0},\n\t\t\t\tStride: 8,\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t},\n\t\t\tOut: []uint8{0, 0, 0, 0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0, 0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tIn: &image.NRGBA{\n\t\t\t\tPix:    []uint8{0, 0, 0, 0, 0xff, 0xff, 0xff, 0x80, 0x80, 0x80, 0x80, 0x80, 0, 0, 0, 0},\n\t\t\t\tStride: 8,\n\t\t\t\tRect:   image.Rect(0, 0, 2, 2),\n\t\t\t},\n\t\t\tOut: []uint8{0, 0, 0, 0, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x80, 0, 0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tIn: &image.Paletted{\n\t\t\t\tPix:     []uint8{0, 64, 0, 0},\n\t\t\t\tStride:  2,\n\t\t\t\tRect:    image.Rect(0, 0, 2, 2),\n\t\t\t\tPalette: bigPalette,\n\t\t\t},\n\t\t\tOut: []uint8{0, 0, 0, 0, 0xff, 0xff, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0},\n\t\t},\n\t\t{\n\t\t\tIn: (&image.Paletted{\n\t\t\t\tPix:     []uint8{0, 64, 0, 0},\n\t\t\t\tStride:  2,\n\t\t\t\tRect:    image.Rect(0, 0, 2, 2),\n\t\t\t\tPalette: bigPalette,\n\t\t\t}).SubImage(image.Rect(1, 0, 2, 1)),\n\t\t\tOut: []uint8{0xff, 0xff, 0xff, 0xff},\n\t\t},\n\t}\n\tfor i, c := range cases {\n\t\tgot := ebiten.ImageToBytes(c.In)\n\t\twant := c.Out\n\t\tif !bytes.Equal(got, want) {\n\t\t\tt.Errorf(\"Test %d: got: %v, want: %v\", i, got, want)\n\t\t}\n\t}\n}\n\nfunc BenchmarkImageToBytesRGBA(b *testing.B) {\n\timg := image.NewRGBA(image.Rect(0, 0, 4096, 4096))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tebiten.ImageToBytes(img)\n\t}\n}\n\nfunc BenchmarkImageToBytesNRGBA(b *testing.B) {\n\timg := image.NewNRGBA(image.Rect(0, 0, 4096, 4096))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tebiten.ImageToBytes(img)\n\t}\n}\n\nfunc BenchmarkImageToBytesPaletted(b *testing.B) {\n\timg := image.NewPaletted(image.Rect(0, 0, 4096, 4096), palette.Plan9)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tebiten.ImageToBytes(img)\n\t}\n}\n"
        },
        {
          "name": "input.go",
          "type": "blob",
          "size": 14.6904296875,
          "content": "// Copyright 2015 Hajime Hoshi\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"io/fs\"\n\t\"sync\"\n\n\t\"github.com/hajimehoshi/ebiten/v2/internal/gamepad\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/gamepaddb\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\n// AppendInputChars appends \"printable\" runes, read from the keyboard at the time Update is called, to runes,\n// and returns the extended buffer.\n// Giving a slice that already has enough capacity works efficiently.\n//\n// AppendInputChars represents the environment's locale-dependent translation of keyboard\n// input to Unicode characters. On the other hand, Key represents a physical key of US keyboard layout\n//\n// \"Control\" and modifier keys should be handled with IsKeyPressed.\n//\n// AppendInputChars is concurrent-safe.\n//\n// On Android (ebitenmobile), EbitenView must be focusable to enable to handle keyboard keys.\nfunc AppendInputChars(runes []rune) []rune {\n\treturn theInputState.appendInputChars(runes)\n}\n\n// InputChars return \"printable\" runes read from the keyboard at the time Update is called.\n//\n// Deprecated: as of v2.2. Use AppendInputChars instead.\nfunc InputChars() []rune {\n\treturn AppendInputChars(nil)\n}\n\n// IsKeyPressed returns a boolean indicating whether key is pressed.\n//\n// If you want to know whether the key started being pressed in the current tick,\n// use inpututil.IsKeyJustPressed\n//\n// Note that a Key represents a physical key of US keyboard layout.\n// For example, KeyQ represents Q key on US keyboards and ' (quote) key on Dvorak keyboards.\n//\n// IsKeyPressed is concurrent-safe.\n//\n// On Android (ebitenmobile), EbitenView must be focusable to enable to handle keyboard keys.\nfunc IsKeyPressed(key Key) bool {\n\treturn theInputState.isKeyPressed(key)\n}\n\n// KeyName returns a key name for the current keyboard layout.\n// For example, KeyName(KeyQ) returns 'q' for a QWERTY keyboard, and returns 'a' for an AZERTY keyboard.\n//\n// KeyName returns an empty string if 1) the key doesn't have a physical key name, 2) the platform doesn't support KeyName,\n// or 3) the main loop doesn't start yet.\n//\n// KeyName is supported by desktops and browsers.\n//\n// KeyName is concurrent-safe.\nfunc KeyName(key Key) string {\n\treturn ui.Get().KeyName(ui.Key(key))\n}\n\n// CursorPosition returns a position of a mouse cursor relative to the game screen (window). The cursor position is\n// 'logical' position and this considers the scale of the screen.\n//\n// CursorPosition returns (0, 0) before the main loop on desktops and browsers.\n//\n// CursorPosition always returns (0, 0) on mobile native applications.\n//\n// CursorPosition is concurrent-safe.\nfunc CursorPosition() (x, y int) {\n\tcx, cy := theInputState.cursorPosition()\n\treturn int(cx), int(cy)\n}\n\n// Wheel returns x and y offsets of the mouse wheel or touchpad scroll.\n// It returns 0 if the wheel isn't being rolled.\n//\n// Wheel is concurrent-safe.\nfunc Wheel() (xoff, yoff float64) {\n\treturn theInputState.wheel()\n}\n\n// IsMouseButtonPressed returns a boolean indicating whether mouseButton is pressed.\n//\n// If you want to know whether the mouseButton started being pressed in the current tick,\n// use inpututil.IsMouseButtonJustPressed\n//\n// IsMouseButtonPressed is concurrent-safe.\nfunc IsMouseButtonPressed(mouseButton MouseButton) bool {\n\treturn theInputState.isMouseButtonPressed(mouseButton)\n}\n\n// GamepadID represents a gamepad identifier.\ntype GamepadID = gamepad.ID\n\n// GamepadSDLID returns a string with the GUID generated in the same way as SDL.\n// To detect devices, see also the community project of gamepad devices database: https://github.com/gabomdq/SDL_GameControllerDB\n//\n// GamepadSDLID always returns an empty string on browsers and mobiles.\n//\n// GamepadSDLID is concurrent-safe.\nfunc GamepadSDLID(id GamepadID) string {\n\tg := gamepad.Get(id)\n\tif g == nil {\n\t\treturn \"\"\n\t}\n\treturn g.SDLID()\n}\n\n// GamepadName returns a string with the name.\n// This function may vary in how it returns descriptions for the same device across platforms.\n// for example the following drivers/platforms see an Xbox One controller as the following:\n//\n//   - Windows: \"Xbox Controller\"\n//   - Chrome: \"Xbox 360 Controller (XInput STANDARD GAMEPAD)\"\n//   - Firefox: \"xinput\"\n//\n// GamepadName is concurrent-safe.\nfunc GamepadName(id GamepadID) string {\n\tg := gamepad.Get(id)\n\tif g == nil {\n\t\treturn \"\"\n\t}\n\treturn g.Name()\n}\n\n// AppendGamepadIDs appends available gamepad IDs to gamepadIDs, and returns the extended buffer.\n// Giving a slice that already has enough capacity works efficiently.\n//\n// AppendGamepadIDs is concurrent-safe.\nfunc AppendGamepadIDs(gamepadIDs []GamepadID) []GamepadID {\n\treturn gamepad.AppendGamepadIDs(gamepadIDs)\n}\n\n// GamepadIDs returns a slice indicating available gamepad IDs.\n//\n// Deprecated: as of v2.2. Use AppendGamepadIDs instead.\nfunc GamepadIDs() []GamepadID {\n\treturn AppendGamepadIDs(nil)\n}\n\n// GamepadAxisCount returns the number of axes of the gamepad (id).\n//\n// GamepadAxisCount is concurrent-safe.\nfunc GamepadAxisCount(id GamepadID) int {\n\tg := gamepad.Get(id)\n\tif g == nil {\n\t\treturn 0\n\t}\n\treturn g.AxisCount()\n}\n\n// GamepadAxisNum returns the number of axes of the gamepad (id).\n//\n// Deprecated: as of v2.4. Use GamepadAxisCount instead.\nfunc GamepadAxisNum(id GamepadID) int {\n\treturn GamepadAxisCount(id)\n}\n\n// GamepadAxisValue returns a float value [-1.0 - 1.0] of the given gamepad (id)'s axis (axis).\n//\n// GamepadAxisValue is concurrent-safe.\nfunc GamepadAxisValue(id GamepadID, axis GamepadAxisType) float64 {\n\tg := gamepad.Get(id)\n\tif g == nil {\n\t\treturn 0\n\t}\n\treturn g.Axis(int(axis))\n}\n\n// GamepadAxis returns a float value [-1.0 - 1.0] of the given gamepad (id)'s axis (axis).\n//\n// Deprecated: as of v2.2. Use GamepadAxisValue instead.\nfunc GamepadAxis(id GamepadID, axis GamepadAxisType) float64 {\n\treturn GamepadAxisValue(id, axis)\n}\n\n// GamepadButtonCount returns the number of the buttons of the given gamepad (id).\n//\n// GamepadButtonCount is concurrent-safe.\nfunc GamepadButtonCount(id GamepadID) int {\n\tg := gamepad.Get(id)\n\tif g == nil {\n\t\treturn 0\n\t}\n\n\t// For backward compatibility, hats are treated as buttons in GLFW.\n\treturn g.ButtonCount() + g.HatCount()*4\n}\n\n// GamepadButtonNum returns the number of the buttons of the given gamepad (id).\n//\n// Deprecated: as of v2.4. Use GamepadButtonCount instead.\nfunc GamepadButtonNum(id GamepadID) int {\n\treturn GamepadButtonCount(id)\n}\n\n// IsGamepadButtonPressed reports whether the given button of the gamepad (id) is pressed or not.\n//\n// If you want to know whether the given button of gamepad (id) started being pressed in the current tick,\n// use inpututil.IsGamepadButtonJustPressed\n//\n// IsGamepadButtonPressed is concurrent-safe.\n//\n// The relationships between physical buttons and button IDs depend on environments.\n// There can be differences even between Chrome and Firefox.\nfunc IsGamepadButtonPressed(id GamepadID, button GamepadButton) bool {\n\tg := gamepad.Get(id)\n\tif g == nil {\n\t\treturn false\n\t}\n\n\tnbuttons := g.ButtonCount()\n\tif int(button) < nbuttons {\n\t\treturn g.Button(int(button))\n\t}\n\n\t// For backward compatibility, hats are treated as buttons in GLFW.\n\tif hat := (int(button) - nbuttons) / 4; hat < g.HatCount() {\n\t\tdir := (int(button) - nbuttons) % 4\n\t\treturn g.Hat(hat)&(1<<dir) != 0\n\t}\n\n\treturn false\n}\n\n// StandardGamepadAxisValue returns a float value [-1.0 - 1.0] of the given gamepad (id)'s standard axis (axis).\n//\n// StandardGamepadAxisValue returns 0 when the gamepad doesn't have a standard gamepad layout mapping.\n//\n// StandardGamepadAxisValue is concurrent safe.\nfunc StandardGamepadAxisValue(id GamepadID, axis StandardGamepadAxis) float64 {\n\tg := gamepad.Get(id)\n\tif g == nil {\n\t\treturn 0\n\t}\n\treturn g.StandardAxisValue(axis)\n}\n\n// StandardGamepadButtonValue returns a float value [0.0 - 1.0] of the given gamepad (id)'s standard button (button).\n//\n// StandardGamepadButtonValue returns 0 when the gamepad doesn't have a standard gamepad layout mapping.\n//\n// StandardGamepadButtonValue is concurrent safe.\nfunc StandardGamepadButtonValue(id GamepadID, button StandardGamepadButton) float64 {\n\tg := gamepad.Get(id)\n\tif g == nil {\n\t\treturn 0\n\t}\n\treturn g.StandardButtonValue(button)\n}\n\n// IsStandardGamepadButtonPressed reports whether the given gamepad (id)'s standard gamepad button (button) is pressed.\n//\n// IsStandardGamepadButtonPressed returns false when the gamepad doesn't have a standard gamepad layout mapping.\n//\n// IsStandardGamepadButtonPressed is concurrent safe.\nfunc IsStandardGamepadButtonPressed(id GamepadID, button StandardGamepadButton) bool {\n\tg := gamepad.Get(id)\n\tif g == nil {\n\t\treturn false\n\t}\n\treturn g.IsStandardButtonPressed(button)\n}\n\n// IsStandardGamepadLayoutAvailable reports whether the gamepad (id) has a standard gamepad layout mapping.\n//\n// IsStandardGamepadLayoutAvailable is concurrent-safe.\nfunc IsStandardGamepadLayoutAvailable(id GamepadID) bool {\n\tg := gamepad.Get(id)\n\tif g == nil {\n\t\treturn false\n\t}\n\treturn g.IsStandardLayoutAvailable()\n}\n\n// IsStandardGamepadAxisAvailable reports whether the standard gamepad axis is available on the gamepad (id).\n//\n// IsStandardGamepadAxisAvailable is concurrent-safe.\nfunc IsStandardGamepadAxisAvailable(id GamepadID, axis StandardGamepadAxis) bool {\n\tg := gamepad.Get(id)\n\tif g == nil {\n\t\treturn false\n\t}\n\treturn g.IsStandardAxisAvailable(axis)\n}\n\n// IsStandardGamepadButtonAvailable reports whether the standard gamepad button is available on the gamepad (id).\n//\n// IsStandardGamepadButtonAvailable is concurrent-safe.\nfunc IsStandardGamepadButtonAvailable(id GamepadID, button StandardGamepadButton) bool {\n\tg := gamepad.Get(id)\n\tif g == nil {\n\t\treturn false\n\t}\n\treturn g.IsStandardButtonAvailable(button)\n}\n\n// UpdateStandardGamepadLayoutMappings parses the specified string mappings in SDL_GameControllerDB format and\n// updates the gamepad layout definitions.\n//\n// UpdateStandardGamepadLayoutMappings reports whether the mappings were applied,\n// and returns an error in case any occurred while parsing the mappings.\n//\n// One or more input definitions can be provided separated by newlines.\n// In particular, it is valid to pass an entire gamecontrollerdb.txt file.\n// Note though that Ebitengine already includes its own copy of this file,\n// so this call should only be necessary to add mappings for hardware not supported yet;\n// ideally games using the StandardGamepad* functions should allow the user to provide mappings and\n// then call this function if provided.\n// When using this facility to support new hardware, please also send a pull request to\n// https://github.com/gabomdq/SDL_GameControllerDB to make your mapping available to everyone else.\n//\n// A platform field in a line corresponds with a GOOS like the following:\n//\n//\t\"Windows\":  GOOS=windows\n//\t\"Mac OS X\": GOOS=darwin (not ios)\n//\t\"Linux\":    GOOS=linux (not android)\n//\t\"Android\":  GOOS=android\n//\t\"iOS\":      GOOS=ios\n//\t\"\":         Any GOOS\n//\n// On platforms where gamepad mappings are not managed by Ebitengine, this always returns false and nil.\n//\n// UpdateStandardGamepadLayoutMappings is concurrent-safe.\n//\n// UpdateStandardGamepadLayoutMappings mappings take effect immediately even for already connected gamepads.\n//\n// UpdateStandardGamepadLayoutMappings works atomically. If an error happens, nothing is updated.\nfunc UpdateStandardGamepadLayoutMappings(mappings string) (bool, error) {\n\tif err := gamepaddb.Update([]byte(mappings)); err != nil {\n\t\treturn false, err\n\t}\n\treturn true, nil\n}\n\n// TouchID represents a touch's identifier.\ntype TouchID int\n\n// AppendTouchIDs appends the current touch states to touches, and returns the extended buffer.\n// Giving a slice that already has enough capacity works efficiently.\n//\n// If you want to know whether a touch started being pressed in the current tick,\n// use inpututil.JustPressedTouchIDs\n//\n// AppendTouchIDs doesn't append anything when there are no touches.\n// AppendTouchIDs always does nothing on desktops.\n//\n// AppendTouchIDs is concurrent-safe.\nfunc AppendTouchIDs(touches []TouchID) []TouchID {\n\treturn theInputState.appendTouchIDs(touches)\n}\n\n// TouchIDs returns the current touch states.\n//\n// Deprecated: as of v2.2. Use AppendTouchIDs instead.\nfunc TouchIDs() []TouchID {\n\treturn AppendTouchIDs(nil)\n}\n\n// TouchPosition returns the position for the touch of the specified ID.\n//\n// If the touch of the specified ID is not present, TouchPosition returns (0, 0).\n//\n// TouchPosition is concurrent-safe.\nfunc TouchPosition(id TouchID) (int, int) {\n\treturn theInputState.touchPosition(id)\n}\n\nvar theInputState inputState\n\ntype inputState struct {\n\tstate ui.InputState\n\tm     sync.Mutex\n}\n\nfunc (i *inputState) update(fn func(*ui.InputState)) {\n\ti.m.Lock()\n\tdefer i.m.Unlock()\n\tfn(&i.state)\n}\n\nfunc (i *inputState) appendInputChars(runes []rune) []rune {\n\ti.m.Lock()\n\tdefer i.m.Unlock()\n\treturn append(runes, i.state.Runes...)\n}\n\nfunc (i *inputState) isKeyPressed(key Key) bool {\n\tif !key.isValid() {\n\t\treturn false\n\t}\n\n\ti.m.Lock()\n\tdefer i.m.Unlock()\n\n\tswitch key {\n\tcase KeyAlt:\n\t\treturn i.state.KeyPressed[ui.KeyAltLeft] || i.state.KeyPressed[ui.KeyAltRight]\n\tcase KeyControl:\n\t\treturn i.state.KeyPressed[ui.KeyControlLeft] || i.state.KeyPressed[ui.KeyControlRight]\n\tcase KeyShift:\n\t\treturn i.state.KeyPressed[ui.KeyShiftLeft] || i.state.KeyPressed[ui.KeyShiftRight]\n\tcase KeyMeta:\n\t\treturn i.state.KeyPressed[ui.KeyMetaLeft] || i.state.KeyPressed[ui.KeyMetaRight]\n\tdefault:\n\t\treturn i.state.KeyPressed[key]\n\t}\n}\n\nfunc (i *inputState) cursorPosition() (float64, float64) {\n\ti.m.Lock()\n\tdefer i.m.Unlock()\n\treturn i.state.CursorX, i.state.CursorY\n}\n\nfunc (i *inputState) wheel() (float64, float64) {\n\ti.m.Lock()\n\tdefer i.m.Unlock()\n\treturn i.state.WheelX, i.state.WheelY\n}\n\nfunc (i *inputState) isMouseButtonPressed(mouseButton MouseButton) bool {\n\ti.m.Lock()\n\tdefer i.m.Unlock()\n\treturn i.state.MouseButtonPressed[mouseButton]\n}\n\nfunc (i *inputState) appendTouchIDs(touches []TouchID) []TouchID {\n\ti.m.Lock()\n\tdefer i.m.Unlock()\n\n\tfor _, t := range i.state.Touches {\n\t\ttouches = append(touches, TouchID(t.ID))\n\t}\n\treturn touches\n}\n\nfunc (i *inputState) touchPosition(id TouchID) (int, int) {\n\ti.m.Lock()\n\tdefer i.m.Unlock()\n\n\tfor _, t := range i.state.Touches {\n\t\tif id != TouchID(t.ID) {\n\t\t\tcontinue\n\t\t}\n\t\treturn t.X, t.Y\n\t}\n\treturn 0, 0\n}\n\nfunc (i *inputState) windowBeingClosed() bool {\n\ti.m.Lock()\n\tdefer i.m.Unlock()\n\treturn i.state.WindowBeingClosed\n}\n\nfunc (i *inputState) droppedFiles() fs.FS {\n\ti.m.Lock()\n\tdefer i.m.Unlock()\n\treturn i.state.DroppedFiles\n}\n"
        },
        {
          "name": "inpututil",
          "type": "tree",
          "content": null
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "keys.go",
          "type": "blob",
          "size": 21.955078125,
          "content": "// Copyright 2013 The Ebitengine Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Code generated by genkeys.go using 'go generate'. DO NOT EDIT.\n\npackage ebiten\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\n// A Key represents a keyboard key.\n// These keys represent physical keys of US keyboard.\n// For example, KeyQ represents Q key on US keyboards and ' (quote) key on Dvorak keyboards.\ntype Key int\n\n// Keys.\nconst (\n\tKeyA              Key = Key(ui.KeyA)\n\tKeyB              Key = Key(ui.KeyB)\n\tKeyC              Key = Key(ui.KeyC)\n\tKeyD              Key = Key(ui.KeyD)\n\tKeyE              Key = Key(ui.KeyE)\n\tKeyF              Key = Key(ui.KeyF)\n\tKeyG              Key = Key(ui.KeyG)\n\tKeyH              Key = Key(ui.KeyH)\n\tKeyI              Key = Key(ui.KeyI)\n\tKeyJ              Key = Key(ui.KeyJ)\n\tKeyK              Key = Key(ui.KeyK)\n\tKeyL              Key = Key(ui.KeyL)\n\tKeyM              Key = Key(ui.KeyM)\n\tKeyN              Key = Key(ui.KeyN)\n\tKeyO              Key = Key(ui.KeyO)\n\tKeyP              Key = Key(ui.KeyP)\n\tKeyQ              Key = Key(ui.KeyQ)\n\tKeyR              Key = Key(ui.KeyR)\n\tKeyS              Key = Key(ui.KeyS)\n\tKeyT              Key = Key(ui.KeyT)\n\tKeyU              Key = Key(ui.KeyU)\n\tKeyV              Key = Key(ui.KeyV)\n\tKeyW              Key = Key(ui.KeyW)\n\tKeyX              Key = Key(ui.KeyX)\n\tKeyY              Key = Key(ui.KeyY)\n\tKeyZ              Key = Key(ui.KeyZ)\n\tKeyAltLeft        Key = Key(ui.KeyAltLeft)\n\tKeyAltRight       Key = Key(ui.KeyAltRight)\n\tKeyArrowDown      Key = Key(ui.KeyArrowDown)\n\tKeyArrowLeft      Key = Key(ui.KeyArrowLeft)\n\tKeyArrowRight     Key = Key(ui.KeyArrowRight)\n\tKeyArrowUp        Key = Key(ui.KeyArrowUp)\n\tKeyBackquote      Key = Key(ui.KeyBackquote)\n\tKeyBackslash      Key = Key(ui.KeyBackslash)\n\tKeyBackspace      Key = Key(ui.KeyBackspace)\n\tKeyBracketLeft    Key = Key(ui.KeyBracketLeft)\n\tKeyBracketRight   Key = Key(ui.KeyBracketRight)\n\tKeyCapsLock       Key = Key(ui.KeyCapsLock)\n\tKeyComma          Key = Key(ui.KeyComma)\n\tKeyContextMenu    Key = Key(ui.KeyContextMenu)\n\tKeyControlLeft    Key = Key(ui.KeyControlLeft)\n\tKeyControlRight   Key = Key(ui.KeyControlRight)\n\tKeyDelete         Key = Key(ui.KeyDelete)\n\tKeyDigit0         Key = Key(ui.KeyDigit0)\n\tKeyDigit1         Key = Key(ui.KeyDigit1)\n\tKeyDigit2         Key = Key(ui.KeyDigit2)\n\tKeyDigit3         Key = Key(ui.KeyDigit3)\n\tKeyDigit4         Key = Key(ui.KeyDigit4)\n\tKeyDigit5         Key = Key(ui.KeyDigit5)\n\tKeyDigit6         Key = Key(ui.KeyDigit6)\n\tKeyDigit7         Key = Key(ui.KeyDigit7)\n\tKeyDigit8         Key = Key(ui.KeyDigit8)\n\tKeyDigit9         Key = Key(ui.KeyDigit9)\n\tKeyEnd            Key = Key(ui.KeyEnd)\n\tKeyEnter          Key = Key(ui.KeyEnter)\n\tKeyEqual          Key = Key(ui.KeyEqual)\n\tKeyEscape         Key = Key(ui.KeyEscape)\n\tKeyF1             Key = Key(ui.KeyF1)\n\tKeyF2             Key = Key(ui.KeyF2)\n\tKeyF3             Key = Key(ui.KeyF3)\n\tKeyF4             Key = Key(ui.KeyF4)\n\tKeyF5             Key = Key(ui.KeyF5)\n\tKeyF6             Key = Key(ui.KeyF6)\n\tKeyF7             Key = Key(ui.KeyF7)\n\tKeyF8             Key = Key(ui.KeyF8)\n\tKeyF9             Key = Key(ui.KeyF9)\n\tKeyF10            Key = Key(ui.KeyF10)\n\tKeyF11            Key = Key(ui.KeyF11)\n\tKeyF12            Key = Key(ui.KeyF12)\n\tKeyF13            Key = Key(ui.KeyF13)\n\tKeyF14            Key = Key(ui.KeyF14)\n\tKeyF15            Key = Key(ui.KeyF15)\n\tKeyF16            Key = Key(ui.KeyF16)\n\tKeyF17            Key = Key(ui.KeyF17)\n\tKeyF18            Key = Key(ui.KeyF18)\n\tKeyF19            Key = Key(ui.KeyF19)\n\tKeyF20            Key = Key(ui.KeyF20)\n\tKeyF21            Key = Key(ui.KeyF21)\n\tKeyF22            Key = Key(ui.KeyF22)\n\tKeyF23            Key = Key(ui.KeyF23)\n\tKeyF24            Key = Key(ui.KeyF24)\n\tKeyHome           Key = Key(ui.KeyHome)\n\tKeyInsert         Key = Key(ui.KeyInsert)\n\tKeyIntlBackslash  Key = Key(ui.KeyIntlBackslash)\n\tKeyMetaLeft       Key = Key(ui.KeyMetaLeft)\n\tKeyMetaRight      Key = Key(ui.KeyMetaRight)\n\tKeyMinus          Key = Key(ui.KeyMinus)\n\tKeyNumLock        Key = Key(ui.KeyNumLock)\n\tKeyNumpad0        Key = Key(ui.KeyNumpad0)\n\tKeyNumpad1        Key = Key(ui.KeyNumpad1)\n\tKeyNumpad2        Key = Key(ui.KeyNumpad2)\n\tKeyNumpad3        Key = Key(ui.KeyNumpad3)\n\tKeyNumpad4        Key = Key(ui.KeyNumpad4)\n\tKeyNumpad5        Key = Key(ui.KeyNumpad5)\n\tKeyNumpad6        Key = Key(ui.KeyNumpad6)\n\tKeyNumpad7        Key = Key(ui.KeyNumpad7)\n\tKeyNumpad8        Key = Key(ui.KeyNumpad8)\n\tKeyNumpad9        Key = Key(ui.KeyNumpad9)\n\tKeyNumpadAdd      Key = Key(ui.KeyNumpadAdd)\n\tKeyNumpadDecimal  Key = Key(ui.KeyNumpadDecimal)\n\tKeyNumpadDivide   Key = Key(ui.KeyNumpadDivide)\n\tKeyNumpadEnter    Key = Key(ui.KeyNumpadEnter)\n\tKeyNumpadEqual    Key = Key(ui.KeyNumpadEqual)\n\tKeyNumpadMultiply Key = Key(ui.KeyNumpadMultiply)\n\tKeyNumpadSubtract Key = Key(ui.KeyNumpadSubtract)\n\tKeyPageDown       Key = Key(ui.KeyPageDown)\n\tKeyPageUp         Key = Key(ui.KeyPageUp)\n\tKeyPause          Key = Key(ui.KeyPause)\n\tKeyPeriod         Key = Key(ui.KeyPeriod)\n\tKeyPrintScreen    Key = Key(ui.KeyPrintScreen)\n\tKeyQuote          Key = Key(ui.KeyQuote)\n\tKeyScrollLock     Key = Key(ui.KeyScrollLock)\n\tKeySemicolon      Key = Key(ui.KeySemicolon)\n\tKeyShiftLeft      Key = Key(ui.KeyShiftLeft)\n\tKeyShiftRight     Key = Key(ui.KeyShiftRight)\n\tKeySlash          Key = Key(ui.KeySlash)\n\tKeySpace          Key = Key(ui.KeySpace)\n\tKeyTab            Key = Key(ui.KeyTab)\n\tKeyAlt            Key = Key(ui.KeyReserved0)\n\tKeyControl        Key = Key(ui.KeyReserved1)\n\tKeyShift          Key = Key(ui.KeyReserved2)\n\tKeyMeta           Key = Key(ui.KeyReserved3)\n\tKeyMax            Key = KeyMeta\n\n\t// Keys for backward compatibility.\n\t// Deprecated: as of v2.1.\n\tKey0            Key = Key(ui.KeyDigit0)\n\tKey1            Key = Key(ui.KeyDigit1)\n\tKey2            Key = Key(ui.KeyDigit2)\n\tKey3            Key = Key(ui.KeyDigit3)\n\tKey4            Key = Key(ui.KeyDigit4)\n\tKey5            Key = Key(ui.KeyDigit5)\n\tKey6            Key = Key(ui.KeyDigit6)\n\tKey7            Key = Key(ui.KeyDigit7)\n\tKey8            Key = Key(ui.KeyDigit8)\n\tKey9            Key = Key(ui.KeyDigit9)\n\tKeyApostrophe   Key = Key(ui.KeyQuote)\n\tKeyDown         Key = Key(ui.KeyArrowDown)\n\tKeyGraveAccent  Key = Key(ui.KeyBackquote)\n\tKeyKP0          Key = Key(ui.KeyNumpad0)\n\tKeyKP1          Key = Key(ui.KeyNumpad1)\n\tKeyKP2          Key = Key(ui.KeyNumpad2)\n\tKeyKP3          Key = Key(ui.KeyNumpad3)\n\tKeyKP4          Key = Key(ui.KeyNumpad4)\n\tKeyKP5          Key = Key(ui.KeyNumpad5)\n\tKeyKP6          Key = Key(ui.KeyNumpad6)\n\tKeyKP7          Key = Key(ui.KeyNumpad7)\n\tKeyKP8          Key = Key(ui.KeyNumpad8)\n\tKeyKP9          Key = Key(ui.KeyNumpad9)\n\tKeyKPAdd        Key = Key(ui.KeyNumpadAdd)\n\tKeyKPDecimal    Key = Key(ui.KeyNumpadDecimal)\n\tKeyKPDivide     Key = Key(ui.KeyNumpadDivide)\n\tKeyKPEnter      Key = Key(ui.KeyNumpadEnter)\n\tKeyKPEqual      Key = Key(ui.KeyNumpadEqual)\n\tKeyKPMultiply   Key = Key(ui.KeyNumpadMultiply)\n\tKeyKPSubtract   Key = Key(ui.KeyNumpadSubtract)\n\tKeyLeft         Key = Key(ui.KeyArrowLeft)\n\tKeyLeftBracket  Key = Key(ui.KeyBracketLeft)\n\tKeyMenu         Key = Key(ui.KeyContextMenu)\n\tKeyRight        Key = Key(ui.KeyArrowRight)\n\tKeyRightBracket Key = Key(ui.KeyBracketRight)\n\tKeyUp           Key = Key(ui.KeyArrowUp)\n)\n\nfunc (k Key) isValid() bool {\n\tswitch k {\n\tcase KeyA:\n\t\treturn true\n\tcase KeyB:\n\t\treturn true\n\tcase KeyC:\n\t\treturn true\n\tcase KeyD:\n\t\treturn true\n\tcase KeyE:\n\t\treturn true\n\tcase KeyF:\n\t\treturn true\n\tcase KeyG:\n\t\treturn true\n\tcase KeyH:\n\t\treturn true\n\tcase KeyI:\n\t\treturn true\n\tcase KeyJ:\n\t\treturn true\n\tcase KeyK:\n\t\treturn true\n\tcase KeyL:\n\t\treturn true\n\tcase KeyM:\n\t\treturn true\n\tcase KeyN:\n\t\treturn true\n\tcase KeyO:\n\t\treturn true\n\tcase KeyP:\n\t\treturn true\n\tcase KeyQ:\n\t\treturn true\n\tcase KeyR:\n\t\treturn true\n\tcase KeyS:\n\t\treturn true\n\tcase KeyT:\n\t\treturn true\n\tcase KeyU:\n\t\treturn true\n\tcase KeyV:\n\t\treturn true\n\tcase KeyW:\n\t\treturn true\n\tcase KeyX:\n\t\treturn true\n\tcase KeyY:\n\t\treturn true\n\tcase KeyZ:\n\t\treturn true\n\tcase KeyAlt:\n\t\treturn true\n\tcase KeyAltLeft:\n\t\treturn true\n\tcase KeyAltRight:\n\t\treturn true\n\tcase KeyArrowDown:\n\t\treturn true\n\tcase KeyArrowLeft:\n\t\treturn true\n\tcase KeyArrowRight:\n\t\treturn true\n\tcase KeyArrowUp:\n\t\treturn true\n\tcase KeyBackquote:\n\t\treturn true\n\tcase KeyBackslash:\n\t\treturn true\n\tcase KeyBackspace:\n\t\treturn true\n\tcase KeyBracketLeft:\n\t\treturn true\n\tcase KeyBracketRight:\n\t\treturn true\n\tcase KeyCapsLock:\n\t\treturn true\n\tcase KeyComma:\n\t\treturn true\n\tcase KeyContextMenu:\n\t\treturn true\n\tcase KeyControl:\n\t\treturn true\n\tcase KeyControlLeft:\n\t\treturn true\n\tcase KeyControlRight:\n\t\treturn true\n\tcase KeyDelete:\n\t\treturn true\n\tcase KeyDigit0:\n\t\treturn true\n\tcase KeyDigit1:\n\t\treturn true\n\tcase KeyDigit2:\n\t\treturn true\n\tcase KeyDigit3:\n\t\treturn true\n\tcase KeyDigit4:\n\t\treturn true\n\tcase KeyDigit5:\n\t\treturn true\n\tcase KeyDigit6:\n\t\treturn true\n\tcase KeyDigit7:\n\t\treturn true\n\tcase KeyDigit8:\n\t\treturn true\n\tcase KeyDigit9:\n\t\treturn true\n\tcase KeyEnd:\n\t\treturn true\n\tcase KeyEnter:\n\t\treturn true\n\tcase KeyEqual:\n\t\treturn true\n\tcase KeyEscape:\n\t\treturn true\n\tcase KeyF1:\n\t\treturn true\n\tcase KeyF2:\n\t\treturn true\n\tcase KeyF3:\n\t\treturn true\n\tcase KeyF4:\n\t\treturn true\n\tcase KeyF5:\n\t\treturn true\n\tcase KeyF6:\n\t\treturn true\n\tcase KeyF7:\n\t\treturn true\n\tcase KeyF8:\n\t\treturn true\n\tcase KeyF9:\n\t\treturn true\n\tcase KeyF10:\n\t\treturn true\n\tcase KeyF11:\n\t\treturn true\n\tcase KeyF12:\n\t\treturn true\n\tcase KeyF13:\n\t\treturn true\n\tcase KeyF14:\n\t\treturn true\n\tcase KeyF15:\n\t\treturn true\n\tcase KeyF16:\n\t\treturn true\n\tcase KeyF17:\n\t\treturn true\n\tcase KeyF18:\n\t\treturn true\n\tcase KeyF19:\n\t\treturn true\n\tcase KeyF20:\n\t\treturn true\n\tcase KeyF21:\n\t\treturn true\n\tcase KeyF22:\n\t\treturn true\n\tcase KeyF23:\n\t\treturn true\n\tcase KeyF24:\n\t\treturn true\n\tcase KeyHome:\n\t\treturn true\n\tcase KeyInsert:\n\t\treturn true\n\tcase KeyIntlBackslash:\n\t\treturn true\n\tcase KeyMeta:\n\t\treturn true\n\tcase KeyMetaLeft:\n\t\treturn true\n\tcase KeyMetaRight:\n\t\treturn true\n\tcase KeyMinus:\n\t\treturn true\n\tcase KeyNumLock:\n\t\treturn true\n\tcase KeyNumpad0:\n\t\treturn true\n\tcase KeyNumpad1:\n\t\treturn true\n\tcase KeyNumpad2:\n\t\treturn true\n\tcase KeyNumpad3:\n\t\treturn true\n\tcase KeyNumpad4:\n\t\treturn true\n\tcase KeyNumpad5:\n\t\treturn true\n\tcase KeyNumpad6:\n\t\treturn true\n\tcase KeyNumpad7:\n\t\treturn true\n\tcase KeyNumpad8:\n\t\treturn true\n\tcase KeyNumpad9:\n\t\treturn true\n\tcase KeyNumpadAdd:\n\t\treturn true\n\tcase KeyNumpadDecimal:\n\t\treturn true\n\tcase KeyNumpadDivide:\n\t\treturn true\n\tcase KeyNumpadEnter:\n\t\treturn true\n\tcase KeyNumpadEqual:\n\t\treturn true\n\tcase KeyNumpadMultiply:\n\t\treturn true\n\tcase KeyNumpadSubtract:\n\t\treturn true\n\tcase KeyPageDown:\n\t\treturn true\n\tcase KeyPageUp:\n\t\treturn true\n\tcase KeyPause:\n\t\treturn true\n\tcase KeyPeriod:\n\t\treturn true\n\tcase KeyPrintScreen:\n\t\treturn true\n\tcase KeyQuote:\n\t\treturn true\n\tcase KeyScrollLock:\n\t\treturn true\n\tcase KeySemicolon:\n\t\treturn true\n\tcase KeyShift:\n\t\treturn true\n\tcase KeyShiftLeft:\n\t\treturn true\n\tcase KeyShiftRight:\n\t\treturn true\n\tcase KeySlash:\n\t\treturn true\n\tcase KeySpace:\n\t\treturn true\n\tcase KeyTab:\n\t\treturn true\n\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// String returns a string representing the key.\n//\n// If k is an undefined key, String returns an empty string.\nfunc (k Key) String() string {\n\tswitch k {\n\tcase KeyA:\n\t\treturn \"A\"\n\tcase KeyB:\n\t\treturn \"B\"\n\tcase KeyC:\n\t\treturn \"C\"\n\tcase KeyD:\n\t\treturn \"D\"\n\tcase KeyE:\n\t\treturn \"E\"\n\tcase KeyF:\n\t\treturn \"F\"\n\tcase KeyG:\n\t\treturn \"G\"\n\tcase KeyH:\n\t\treturn \"H\"\n\tcase KeyI:\n\t\treturn \"I\"\n\tcase KeyJ:\n\t\treturn \"J\"\n\tcase KeyK:\n\t\treturn \"K\"\n\tcase KeyL:\n\t\treturn \"L\"\n\tcase KeyM:\n\t\treturn \"M\"\n\tcase KeyN:\n\t\treturn \"N\"\n\tcase KeyO:\n\t\treturn \"O\"\n\tcase KeyP:\n\t\treturn \"P\"\n\tcase KeyQ:\n\t\treturn \"Q\"\n\tcase KeyR:\n\t\treturn \"R\"\n\tcase KeyS:\n\t\treturn \"S\"\n\tcase KeyT:\n\t\treturn \"T\"\n\tcase KeyU:\n\t\treturn \"U\"\n\tcase KeyV:\n\t\treturn \"V\"\n\tcase KeyW:\n\t\treturn \"W\"\n\tcase KeyX:\n\t\treturn \"X\"\n\tcase KeyY:\n\t\treturn \"Y\"\n\tcase KeyZ:\n\t\treturn \"Z\"\n\tcase KeyAlt:\n\t\treturn \"Alt\"\n\tcase KeyAltLeft:\n\t\treturn \"AltLeft\"\n\tcase KeyAltRight:\n\t\treturn \"AltRight\"\n\tcase KeyArrowDown:\n\t\treturn \"ArrowDown\"\n\tcase KeyArrowLeft:\n\t\treturn \"ArrowLeft\"\n\tcase KeyArrowRight:\n\t\treturn \"ArrowRight\"\n\tcase KeyArrowUp:\n\t\treturn \"ArrowUp\"\n\tcase KeyBackquote:\n\t\treturn \"Backquote\"\n\tcase KeyBackslash:\n\t\treturn \"Backslash\"\n\tcase KeyBackspace:\n\t\treturn \"Backspace\"\n\tcase KeyBracketLeft:\n\t\treturn \"BracketLeft\"\n\tcase KeyBracketRight:\n\t\treturn \"BracketRight\"\n\tcase KeyCapsLock:\n\t\treturn \"CapsLock\"\n\tcase KeyComma:\n\t\treturn \"Comma\"\n\tcase KeyContextMenu:\n\t\treturn \"ContextMenu\"\n\tcase KeyControl:\n\t\treturn \"Control\"\n\tcase KeyControlLeft:\n\t\treturn \"ControlLeft\"\n\tcase KeyControlRight:\n\t\treturn \"ControlRight\"\n\tcase KeyDelete:\n\t\treturn \"Delete\"\n\tcase KeyDigit0:\n\t\treturn \"Digit0\"\n\tcase KeyDigit1:\n\t\treturn \"Digit1\"\n\tcase KeyDigit2:\n\t\treturn \"Digit2\"\n\tcase KeyDigit3:\n\t\treturn \"Digit3\"\n\tcase KeyDigit4:\n\t\treturn \"Digit4\"\n\tcase KeyDigit5:\n\t\treturn \"Digit5\"\n\tcase KeyDigit6:\n\t\treturn \"Digit6\"\n\tcase KeyDigit7:\n\t\treturn \"Digit7\"\n\tcase KeyDigit8:\n\t\treturn \"Digit8\"\n\tcase KeyDigit9:\n\t\treturn \"Digit9\"\n\tcase KeyEnd:\n\t\treturn \"End\"\n\tcase KeyEnter:\n\t\treturn \"Enter\"\n\tcase KeyEqual:\n\t\treturn \"Equal\"\n\tcase KeyEscape:\n\t\treturn \"Escape\"\n\tcase KeyF1:\n\t\treturn \"F1\"\n\tcase KeyF2:\n\t\treturn \"F2\"\n\tcase KeyF3:\n\t\treturn \"F3\"\n\tcase KeyF4:\n\t\treturn \"F4\"\n\tcase KeyF5:\n\t\treturn \"F5\"\n\tcase KeyF6:\n\t\treturn \"F6\"\n\tcase KeyF7:\n\t\treturn \"F7\"\n\tcase KeyF8:\n\t\treturn \"F8\"\n\tcase KeyF9:\n\t\treturn \"F9\"\n\tcase KeyF10:\n\t\treturn \"F10\"\n\tcase KeyF11:\n\t\treturn \"F11\"\n\tcase KeyF12:\n\t\treturn \"F12\"\n\tcase KeyF13:\n\t\treturn \"F13\"\n\tcase KeyF14:\n\t\treturn \"F14\"\n\tcase KeyF15:\n\t\treturn \"F15\"\n\tcase KeyF16:\n\t\treturn \"F16\"\n\tcase KeyF17:\n\t\treturn \"F17\"\n\tcase KeyF18:\n\t\treturn \"F18\"\n\tcase KeyF19:\n\t\treturn \"F19\"\n\tcase KeyF20:\n\t\treturn \"F20\"\n\tcase KeyF21:\n\t\treturn \"F21\"\n\tcase KeyF22:\n\t\treturn \"F22\"\n\tcase KeyF23:\n\t\treturn \"F23\"\n\tcase KeyF24:\n\t\treturn \"F24\"\n\tcase KeyHome:\n\t\treturn \"Home\"\n\tcase KeyInsert:\n\t\treturn \"Insert\"\n\tcase KeyIntlBackslash:\n\t\treturn \"IntlBackslash\"\n\tcase KeyMeta:\n\t\treturn \"Meta\"\n\tcase KeyMetaLeft:\n\t\treturn \"MetaLeft\"\n\tcase KeyMetaRight:\n\t\treturn \"MetaRight\"\n\tcase KeyMinus:\n\t\treturn \"Minus\"\n\tcase KeyNumLock:\n\t\treturn \"NumLock\"\n\tcase KeyNumpad0:\n\t\treturn \"Numpad0\"\n\tcase KeyNumpad1:\n\t\treturn \"Numpad1\"\n\tcase KeyNumpad2:\n\t\treturn \"Numpad2\"\n\tcase KeyNumpad3:\n\t\treturn \"Numpad3\"\n\tcase KeyNumpad4:\n\t\treturn \"Numpad4\"\n\tcase KeyNumpad5:\n\t\treturn \"Numpad5\"\n\tcase KeyNumpad6:\n\t\treturn \"Numpad6\"\n\tcase KeyNumpad7:\n\t\treturn \"Numpad7\"\n\tcase KeyNumpad8:\n\t\treturn \"Numpad8\"\n\tcase KeyNumpad9:\n\t\treturn \"Numpad9\"\n\tcase KeyNumpadAdd:\n\t\treturn \"NumpadAdd\"\n\tcase KeyNumpadDecimal:\n\t\treturn \"NumpadDecimal\"\n\tcase KeyNumpadDivide:\n\t\treturn \"NumpadDivide\"\n\tcase KeyNumpadEnter:\n\t\treturn \"NumpadEnter\"\n\tcase KeyNumpadEqual:\n\t\treturn \"NumpadEqual\"\n\tcase KeyNumpadMultiply:\n\t\treturn \"NumpadMultiply\"\n\tcase KeyNumpadSubtract:\n\t\treturn \"NumpadSubtract\"\n\tcase KeyPageDown:\n\t\treturn \"PageDown\"\n\tcase KeyPageUp:\n\t\treturn \"PageUp\"\n\tcase KeyPause:\n\t\treturn \"Pause\"\n\tcase KeyPeriod:\n\t\treturn \"Period\"\n\tcase KeyPrintScreen:\n\t\treturn \"PrintScreen\"\n\tcase KeyQuote:\n\t\treturn \"Quote\"\n\tcase KeyScrollLock:\n\t\treturn \"ScrollLock\"\n\tcase KeySemicolon:\n\t\treturn \"Semicolon\"\n\tcase KeyShift:\n\t\treturn \"Shift\"\n\tcase KeyShiftLeft:\n\t\treturn \"ShiftLeft\"\n\tcase KeyShiftRight:\n\t\treturn \"ShiftRight\"\n\tcase KeySlash:\n\t\treturn \"Slash\"\n\tcase KeySpace:\n\t\treturn \"Space\"\n\tcase KeyTab:\n\t\treturn \"Tab\"\n\t}\n\treturn \"\"\n}\n\nfunc keyNameToKeyCode(name string) (Key, bool) {\n\tswitch strings.ToLower(name) {\n\tcase \"0\":\n\t\treturn Key0, true\n\tcase \"1\":\n\t\treturn Key1, true\n\tcase \"2\":\n\t\treturn Key2, true\n\tcase \"3\":\n\t\treturn Key3, true\n\tcase \"4\":\n\t\treturn Key4, true\n\tcase \"5\":\n\t\treturn Key5, true\n\tcase \"6\":\n\t\treturn Key6, true\n\tcase \"7\":\n\t\treturn Key7, true\n\tcase \"8\":\n\t\treturn Key8, true\n\tcase \"9\":\n\t\treturn Key9, true\n\tcase \"a\":\n\t\treturn KeyA, true\n\tcase \"b\":\n\t\treturn KeyB, true\n\tcase \"c\":\n\t\treturn KeyC, true\n\tcase \"d\":\n\t\treturn KeyD, true\n\tcase \"e\":\n\t\treturn KeyE, true\n\tcase \"f\":\n\t\treturn KeyF, true\n\tcase \"g\":\n\t\treturn KeyG, true\n\tcase \"h\":\n\t\treturn KeyH, true\n\tcase \"i\":\n\t\treturn KeyI, true\n\tcase \"j\":\n\t\treturn KeyJ, true\n\tcase \"k\":\n\t\treturn KeyK, true\n\tcase \"l\":\n\t\treturn KeyL, true\n\tcase \"m\":\n\t\treturn KeyM, true\n\tcase \"n\":\n\t\treturn KeyN, true\n\tcase \"o\":\n\t\treturn KeyO, true\n\tcase \"p\":\n\t\treturn KeyP, true\n\tcase \"q\":\n\t\treturn KeyQ, true\n\tcase \"r\":\n\t\treturn KeyR, true\n\tcase \"s\":\n\t\treturn KeyS, true\n\tcase \"t\":\n\t\treturn KeyT, true\n\tcase \"u\":\n\t\treturn KeyU, true\n\tcase \"v\":\n\t\treturn KeyV, true\n\tcase \"w\":\n\t\treturn KeyW, true\n\tcase \"x\":\n\t\treturn KeyX, true\n\tcase \"y\":\n\t\treturn KeyY, true\n\tcase \"z\":\n\t\treturn KeyZ, true\n\tcase \"alt\":\n\t\treturn KeyAlt, true\n\tcase \"altleft\":\n\t\treturn KeyAltLeft, true\n\tcase \"altright\":\n\t\treturn KeyAltRight, true\n\tcase \"apostrophe\":\n\t\treturn KeyApostrophe, true\n\tcase \"arrowdown\":\n\t\treturn KeyArrowDown, true\n\tcase \"arrowleft\":\n\t\treturn KeyArrowLeft, true\n\tcase \"arrowright\":\n\t\treturn KeyArrowRight, true\n\tcase \"arrowup\":\n\t\treturn KeyArrowUp, true\n\tcase \"backquote\":\n\t\treturn KeyBackquote, true\n\tcase \"backslash\":\n\t\treturn KeyBackslash, true\n\tcase \"backspace\":\n\t\treturn KeyBackspace, true\n\tcase \"bracketleft\":\n\t\treturn KeyBracketLeft, true\n\tcase \"bracketright\":\n\t\treturn KeyBracketRight, true\n\tcase \"capslock\":\n\t\treturn KeyCapsLock, true\n\tcase \"comma\":\n\t\treturn KeyComma, true\n\tcase \"contextmenu\":\n\t\treturn KeyContextMenu, true\n\tcase \"control\":\n\t\treturn KeyControl, true\n\tcase \"controlleft\":\n\t\treturn KeyControlLeft, true\n\tcase \"controlright\":\n\t\treturn KeyControlRight, true\n\tcase \"delete\":\n\t\treturn KeyDelete, true\n\tcase \"digit0\":\n\t\treturn KeyDigit0, true\n\tcase \"digit1\":\n\t\treturn KeyDigit1, true\n\tcase \"digit2\":\n\t\treturn KeyDigit2, true\n\tcase \"digit3\":\n\t\treturn KeyDigit3, true\n\tcase \"digit4\":\n\t\treturn KeyDigit4, true\n\tcase \"digit5\":\n\t\treturn KeyDigit5, true\n\tcase \"digit6\":\n\t\treturn KeyDigit6, true\n\tcase \"digit7\":\n\t\treturn KeyDigit7, true\n\tcase \"digit8\":\n\t\treturn KeyDigit8, true\n\tcase \"digit9\":\n\t\treturn KeyDigit9, true\n\tcase \"down\":\n\t\treturn KeyDown, true\n\tcase \"end\":\n\t\treturn KeyEnd, true\n\tcase \"enter\":\n\t\treturn KeyEnter, true\n\tcase \"equal\":\n\t\treturn KeyEqual, true\n\tcase \"escape\":\n\t\treturn KeyEscape, true\n\tcase \"f1\":\n\t\treturn KeyF1, true\n\tcase \"f2\":\n\t\treturn KeyF2, true\n\tcase \"f3\":\n\t\treturn KeyF3, true\n\tcase \"f4\":\n\t\treturn KeyF4, true\n\tcase \"f5\":\n\t\treturn KeyF5, true\n\tcase \"f6\":\n\t\treturn KeyF6, true\n\tcase \"f7\":\n\t\treturn KeyF7, true\n\tcase \"f8\":\n\t\treturn KeyF8, true\n\tcase \"f9\":\n\t\treturn KeyF9, true\n\tcase \"f10\":\n\t\treturn KeyF10, true\n\tcase \"f11\":\n\t\treturn KeyF11, true\n\tcase \"f12\":\n\t\treturn KeyF12, true\n\tcase \"f13\":\n\t\treturn KeyF13, true\n\tcase \"f14\":\n\t\treturn KeyF14, true\n\tcase \"f15\":\n\t\treturn KeyF15, true\n\tcase \"f16\":\n\t\treturn KeyF16, true\n\tcase \"f17\":\n\t\treturn KeyF17, true\n\tcase \"f18\":\n\t\treturn KeyF18, true\n\tcase \"f19\":\n\t\treturn KeyF19, true\n\tcase \"f20\":\n\t\treturn KeyF20, true\n\tcase \"f21\":\n\t\treturn KeyF21, true\n\tcase \"f22\":\n\t\treturn KeyF22, true\n\tcase \"f23\":\n\t\treturn KeyF23, true\n\tcase \"f24\":\n\t\treturn KeyF24, true\n\tcase \"graveaccent\":\n\t\treturn KeyGraveAccent, true\n\tcase \"home\":\n\t\treturn KeyHome, true\n\tcase \"insert\":\n\t\treturn KeyInsert, true\n\tcase \"intlbackslash\":\n\t\treturn KeyIntlBackslash, true\n\tcase \"kp0\":\n\t\treturn KeyKP0, true\n\tcase \"kp1\":\n\t\treturn KeyKP1, true\n\tcase \"kp2\":\n\t\treturn KeyKP2, true\n\tcase \"kp3\":\n\t\treturn KeyKP3, true\n\tcase \"kp4\":\n\t\treturn KeyKP4, true\n\tcase \"kp5\":\n\t\treturn KeyKP5, true\n\tcase \"kp6\":\n\t\treturn KeyKP6, true\n\tcase \"kp7\":\n\t\treturn KeyKP7, true\n\tcase \"kp8\":\n\t\treturn KeyKP8, true\n\tcase \"kp9\":\n\t\treturn KeyKP9, true\n\tcase \"kpadd\":\n\t\treturn KeyKPAdd, true\n\tcase \"kpdecimal\":\n\t\treturn KeyKPDecimal, true\n\tcase \"kpdivide\":\n\t\treturn KeyKPDivide, true\n\tcase \"kpenter\":\n\t\treturn KeyKPEnter, true\n\tcase \"kpequal\":\n\t\treturn KeyKPEqual, true\n\tcase \"kpmultiply\":\n\t\treturn KeyKPMultiply, true\n\tcase \"kpsubtract\":\n\t\treturn KeyKPSubtract, true\n\tcase \"left\":\n\t\treturn KeyLeft, true\n\tcase \"leftbracket\":\n\t\treturn KeyLeftBracket, true\n\tcase \"menu\":\n\t\treturn KeyMenu, true\n\tcase \"meta\":\n\t\treturn KeyMeta, true\n\tcase \"metaleft\":\n\t\treturn KeyMetaLeft, true\n\tcase \"metaright\":\n\t\treturn KeyMetaRight, true\n\tcase \"minus\":\n\t\treturn KeyMinus, true\n\tcase \"numlock\":\n\t\treturn KeyNumLock, true\n\tcase \"numpad0\":\n\t\treturn KeyNumpad0, true\n\tcase \"numpad1\":\n\t\treturn KeyNumpad1, true\n\tcase \"numpad2\":\n\t\treturn KeyNumpad2, true\n\tcase \"numpad3\":\n\t\treturn KeyNumpad3, true\n\tcase \"numpad4\":\n\t\treturn KeyNumpad4, true\n\tcase \"numpad5\":\n\t\treturn KeyNumpad5, true\n\tcase \"numpad6\":\n\t\treturn KeyNumpad6, true\n\tcase \"numpad7\":\n\t\treturn KeyNumpad7, true\n\tcase \"numpad8\":\n\t\treturn KeyNumpad8, true\n\tcase \"numpad9\":\n\t\treturn KeyNumpad9, true\n\tcase \"numpadadd\":\n\t\treturn KeyNumpadAdd, true\n\tcase \"numpaddecimal\":\n\t\treturn KeyNumpadDecimal, true\n\tcase \"numpaddivide\":\n\t\treturn KeyNumpadDivide, true\n\tcase \"numpadenter\":\n\t\treturn KeyNumpadEnter, true\n\tcase \"numpadequal\":\n\t\treturn KeyNumpadEqual, true\n\tcase \"numpadmultiply\":\n\t\treturn KeyNumpadMultiply, true\n\tcase \"numpadsubtract\":\n\t\treturn KeyNumpadSubtract, true\n\tcase \"pagedown\":\n\t\treturn KeyPageDown, true\n\tcase \"pageup\":\n\t\treturn KeyPageUp, true\n\tcase \"pause\":\n\t\treturn KeyPause, true\n\tcase \"period\":\n\t\treturn KeyPeriod, true\n\tcase \"printscreen\":\n\t\treturn KeyPrintScreen, true\n\tcase \"quote\":\n\t\treturn KeyQuote, true\n\tcase \"right\":\n\t\treturn KeyRight, true\n\tcase \"rightbracket\":\n\t\treturn KeyRightBracket, true\n\tcase \"scrolllock\":\n\t\treturn KeyScrollLock, true\n\tcase \"semicolon\":\n\t\treturn KeySemicolon, true\n\tcase \"shift\":\n\t\treturn KeyShift, true\n\tcase \"shiftleft\":\n\t\treturn KeyShiftLeft, true\n\tcase \"shiftright\":\n\t\treturn KeyShiftRight, true\n\tcase \"slash\":\n\t\treturn KeySlash, true\n\tcase \"space\":\n\t\treturn KeySpace, true\n\tcase \"tab\":\n\t\treturn KeyTab, true\n\tcase \"up\":\n\t\treturn KeyUp, true\n\t}\n\treturn 0, false\n}\n\n// MarshalText implements encoding.TextMarshaler.\nfunc (k Key) MarshalText() ([]byte, error) {\n\treturn []byte(k.String()), nil\n}\n\n// UnmarshalText implements encoding.TextUnmarshaler\nfunc (k *Key) UnmarshalText(text []byte) error {\n\tkey, ok := keyNameToKeyCode(string(text))\n\tif !ok {\n\t\treturn fmt.Errorf(\"ebiten: unexpected key name: %s\", string(text))\n\t}\n\t*k = key\n\treturn nil\n}\n"
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "mobile",
          "type": "tree",
          "content": null
        },
        {
          "name": "monitor.go",
          "type": "blob",
          "size": 2.9404296875,
          "content": "// Copyright 2023 The Ebitengine Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\n// MonitorType represents a monitor available to the system.\ntype MonitorType ui.Monitor\n\n// Name returns the monitor's name. On Linux, this reports the monitors in xrandr format.\n// On Windows, this reports \"Generic PnP Monitor\" for all monitors.\nfunc (m *MonitorType) Name() string {\n\treturn (*ui.Monitor)(m).Name()\n}\n\n// DeviceScaleFactor returns the device scale factor of the monitor.\n//\n// DeviceScaleFactor returns a meaningful value on high-DPI display environment,\n// otherwise DeviceScaleFactor returns 1.\n//\n// On mobiles, DeviceScaleFactor returns 1 before the game starts e.g. in init functions.\nfunc (m *MonitorType) DeviceScaleFactor() float64 {\n\treturn (*ui.Monitor)(m).DeviceScaleFactor()\n}\n\n// Size returns the size of the monitor in device-independent pixels.\n// This is the same as the screen size in fullscreen mode.\n// The returned value can be given to SetSize function if the perfectly fit fullscreen is needed.\n//\n// On mobiles, Size returns (0, 0) before the game starts e.g. in init functions.\n//\n// Size's use cases are limited. If you are making a fullscreen application, you can use RunGame and\n// the Game interface's Layout function instead. If you are making a not-fullscreen application but the application's\n// behavior depends on the monitor size, Size is useful.\nfunc (m *MonitorType) Size() (int, int) {\n\treturn (*ui.Monitor)(m).Size()\n}\n\n// Monitor returns the current monitor.\nfunc Monitor() *MonitorType {\n\tm := ui.Get().Monitor()\n\tif m == nil {\n\t\treturn nil\n\t}\n\treturn (*MonitorType)(m)\n}\n\n// SetMonitor sets the monitor that the window should be on. This can be called before or after Run.\nfunc SetMonitor(monitor *MonitorType) {\n\tui.Get().Window().SetMonitor((*ui.Monitor)(monitor))\n}\n\n// AppendMonitors returns the monitors reported by the system.\n// On desktop platforms, there will always be at least one monitor appended and the first monitor in the slice will be the primary monitor.\n// Any monitors added or removed will show up with subsequent calls to this function.\nfunc AppendMonitors(monitors []*MonitorType) []*MonitorType {\n\t// TODO: This is not an efficient operation. It would be best if we could directly pass monitors directly into `ui.AppendMonitors`.\n\tfor _, m := range ui.Get().AppendMonitors(nil) {\n\t\tmonitors = append(monitors, (*MonitorType)(m))\n\t}\n\treturn monitors\n}\n"
        },
        {
          "name": "mousebuttons.go",
          "type": "blob",
          "size": 1.2060546875,
          "content": "// Copyright 2015 Hajime Hoshi\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\n// A MouseButton represents a mouse button.\ntype MouseButton int\n\n// MouseButtons\nconst (\n\tMouseButtonLeft   MouseButton = MouseButton0\n\tMouseButtonMiddle MouseButton = MouseButton1\n\tMouseButtonRight  MouseButton = MouseButton2\n\n\tMouseButton0   MouseButton = MouseButton(ui.MouseButton0)\n\tMouseButton1   MouseButton = MouseButton(ui.MouseButton1)\n\tMouseButton2   MouseButton = MouseButton(ui.MouseButton2)\n\tMouseButton3   MouseButton = MouseButton(ui.MouseButton3)\n\tMouseButton4   MouseButton = MouseButton(ui.MouseButton4)\n\tMouseButtonMax MouseButton = MouseButton4\n)\n"
        },
        {
          "name": "playstation5",
          "type": "tree",
          "content": null
        },
        {
          "name": "run.go",
          "type": "blob",
          "size": 28.7783203125,
          "content": "// Copyright 2014 Hajime Hoshi\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"errors\"\n\t\"image\"\n\t\"image/color\"\n\t\"io/fs\"\n\t\"sync/atomic\"\n\n\t\"github.com/hajimehoshi/ebiten/v2/internal/clock\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/graphicsdriver\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\n// Game defines necessary functions for a game.\ntype Game interface {\n\t// Update updates a game by one tick. The given argument represents a screen image.\n\t//\n\t// Update updates only the game logic and Draw draws the screen.\n\t//\n\t// You can assume that Update is always called TPS-times per second (60 by default), and you can assume\n\t// that the time delta between two Updates is always 1 / TPS [s] (1/60[s] by default). As Ebitengine already\n\t// adjusts the number of Update calls, you don't have to measure time deltas in Update by e.g. OS timers.\n\t//\n\t// An actual TPS is available by ActualTPS(), and the result might slightly differ from your expected TPS,\n\t// but still, your game logic should stick to the fixed time delta and should not rely on ActualTPS() value.\n\t// This API is for just measurement and/or debugging. In the long run, the number of Update calls should be\n\t// adjusted based on the set TPS on average.\n\t//\n\t// An actual time delta between two Updates might be bigger than expected. In this case, your game's\n\t// Update or Draw takes longer than they should. In this case, there is nothing other than optimizing\n\t// your game implementation.\n\t//\n\t// In the first frame, it is ensured that Update is called at least once before Draw. You can use Update\n\t// to initialize the game state.\n\t//\n\t// After the first frame, Update might not be called or might be called once\n\t// or more for one frame. The frequency is determined by the current TPS (tick-per-second).\n\t//\n\t// If the error returned is nil, game execution proceeds normally.\n\t// If the error returned is Termination, game execution halts, but does not return an error from RunGame.\n\t// If the error returned is any other non-nil value, game execution halts and the error is returned from RunGame.\n\tUpdate() error\n\n\t// Draw draws the game screen by one frame.\n\t//\n\t// The give argument represents a screen image. The updated content is adopted as the game screen.\n\t//\n\t// The frequency of Draw calls depends on the user's environment, especially the monitors refresh rate.\n\t// For portability, you should not put your game logic in Draw in general.\n\tDraw(screen *Image)\n\n\t// Layout accepts a native outside size in device-independent pixels and returns the game's logical screen\n\t// size in pixels. The logical size is used for 1) the screen size given at Draw and 2) calculation of the\n\t// scale from the screen to the final screen size.\n\t//\n\t// On desktops, the outside is a window or a monitor (fullscreen mode). On browsers, the outside is a body\n\t// element. On mobiles, the outside is the view's size.\n\t//\n\t// Even though the outside size and the screen size differ, the rendering scale is automatically adjusted to\n\t// fit with the outside.\n\t//\n\t// Layout is called almost every frame.\n\t//\n\t// It is ensured that Layout is invoked before Update is called in the first frame.\n\t//\n\t// If Layout returns non-positive numbers, the caller can panic.\n\t//\n\t// You can return a fixed screen size if you don't care, or you can also return a calculated screen size\n\t// adjusted with the given outside size.\n\t//\n\t// If the game implements the interface LayoutFer, Layout is never called and LayoutF is called instead.\n\tLayout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int)\n}\n\n// LayoutFer is an interface for the float version of Game.Layout.\ntype LayoutFer interface {\n\t// LayoutF is the float version of Game.Layout.\n\t//\n\t// If the game implements this interface, Layout is never called and LayoutF is called instead.\n\t//\n\t// LayoutF accepts a native outside size in device-independent pixels and returns the game's logical screen\n\t// size in pixels. The logical size is used for 1) the screen size given at Draw and 2) calculation of the\n\t// scale from the screen to the final screen size. For 1), the actual screen size is a rounded up of the\n\t// logical size.\n\tLayoutF(outsideWidth, outsideHeight float64) (screenWidth, screenHeight float64)\n}\n\n// FinalScreen represents the final screen image.\n// FinalScreen implements a part of Image functions.\ntype FinalScreen interface {\n\tBounds() image.Rectangle\n\n\tDrawImage(img *Image, options *DrawImageOptions)\n\tDrawTriangles(vertices []Vertex, indices []uint16, img *Image, options *DrawTrianglesOptions)\n\tDrawRectShader(width, height int, shader *Shader, options *DrawRectShaderOptions)\n\tDrawTrianglesShader(vertices []Vertex, indices []uint16, shader *Shader, options *DrawTrianglesShaderOptions)\n\tClear()\n\tFill(clr color.Color)\n\n\t// private prevents other packages from implementing this interface.\n\t// A new function might be added to this interface in the future\n\t// even if the Ebitengine major version is not updated.\n\tprivate()\n}\n\n// FinalScreenDrawer is an interface for a custom function to render the final screen.\n// For an actual usage, see examples/flappy.\ntype FinalScreenDrawer interface {\n\t// DrawFinalScreen draws the final screen.\n\t// If a game implementing FinalScreenDrawer is passed to RunGame, DrawFinalScreen is called after Draw.\n\t// screen is the final screen. offscreen is the offscreen modified at Draw.\n\t//\n\t// geoM is the default geometry matrix to render the offscreen onto the final screen.\n\t// geoM scales the offscreen to fit the final screen without changing the aspect ratio, and\n\t// translates the offscreen to put it in the center of the final screen.\n\tDrawFinalScreen(screen FinalScreen, offscreen *Image, geoM GeoM)\n}\n\n// DefaultTPS represents a default ticks per second, that represents how many times game updating happens in a second.\nconst DefaultTPS = clock.DefaultTPS\n\n// ActualFPS returns the current number of FPS (frames per second), that represents\n// how many swapping buffer happens per second.\n//\n// On some environments, ActualFPS doesn't return a reliable value since vsync doesn't work well there.\n// If you want to measure the application's speed, Use ActualTPS.\n//\n// This value is for measurement and/or debug, and your game logic should not rely on this value.\n//\n// ActualFPS is concurrent-safe.\nfunc ActualFPS() float64 {\n\treturn clock.ActualFPS()\n}\n\n// CurrentFPS returns the current number of FPS (frames per second), that represents\n// how many swapping buffer happens per second.\n//\n// Deprecated: as of v2.4. Use ActualFPS instead.\nfunc CurrentFPS() float64 {\n\treturn ActualFPS()\n}\n\nvar (\n\tisRunGameEnded_ atomic.Bool\n)\n\n// SetScreenClearedEveryFrame enables or disables the clearing of the screen at the beginning of each frame.\n// The default value is true and the screen is cleared each frame by default.\n//\n// SetScreenClearedEveryFrame is concurrent-safe.\nfunc SetScreenClearedEveryFrame(cleared bool) {\n\tui.Get().SetScreenClearedEveryFrame(cleared)\n}\n\n// IsScreenClearedEveryFrame returns true if the frame isn't cleared at the beginning.\n//\n// IsScreenClearedEveryFrame is concurrent-safe.\nfunc IsScreenClearedEveryFrame() bool {\n\treturn ui.Get().IsScreenClearedEveryFrame()\n}\n\n// SetScreenFilterEnabled enables/disables the use of the \"screen\" filter Ebitengine uses.\n//\n// The \"screen\" filter is a box filter from game to display resolution.\n//\n// If disabled, nearest-neighbor filtering will be used for scaling instead.\n//\n// The default state is true.\n//\n// SetScreenFilterEnabled is concurrent-safe, but takes effect only at the next Draw call.\n//\n// Deprecated: as of v2.5. Use FinalScreenDrawer instead.\nfunc SetScreenFilterEnabled(enabled bool) {\n\tscreenFilterEnabled.Store(enabled)\n}\n\n// IsScreenFilterEnabled returns true if Ebitengine's \"screen\" filter is enabled.\n//\n// IsScreenFilterEnabled is concurrent-safe.\n//\n// Deprecated: as of v2.5.\nfunc IsScreenFilterEnabled() bool {\n\treturn screenFilterEnabled.Load()\n}\n\n// Termination is a special error which indicates Game termination without error.\nvar Termination = ui.RegularTermination\n\n// RunGame starts the main loop and runs the game.\n// game's Update function is called every tick to update the game logic.\n// game's Draw function is called every frame to draw the screen.\n// game's Layout function is called when necessary, and you can specify the logical screen size by the function.\n//\n// If game implements FinalScreenDrawer, its DrawFinalScreen is called after Draw.\n// The argument screen represents the final screen. The argument offscreen is an offscreen modified at Draw.\n// If game does not implement FinalScreenDrawer, the default rendering for the final screen is used.\n//\n// game's functions are called on the same goroutine.\n//\n// On browsers, it is strongly recommended to use iframe if you embed an Ebitengine application in your website.\n//\n// RunGame must be called on the main thread.\n// Note that Ebitengine bounds the main goroutine to the main OS thread by runtime.LockOSThread.\n//\n// Ebitengine tries to call game's Update function 60 times a second by default. In other words,\n// TPS (ticks per second) is 60 by default.\n// This is not related to framerate (display's refresh rate).\n//\n// RunGame returns error when 1) an error happens in the underlying graphics driver, 2) an audio error happens\n// or 3) Update returns an error. In the case of 3), RunGame returns the same error so far, but it is recommended to\n// use errors.Is when you check the returned error is the error you want, rather than comparing the values\n// with == or != directly.\n//\n// If you want to terminate a game on desktops, it is recommended to return Termination at Update, which will halt\n// execution without returning an error value from RunGame.\n//\n// The size unit is device-independent pixel.\n//\n// Don't call RunGame or RunGameWithOptions twice or more in one process.\nfunc RunGame(game Game) error {\n\treturn RunGameWithOptions(game, nil)\n}\n\n// RunGameOptions represents options for RunGameWithOptions.\ntype RunGameOptions struct {\n\t// GraphicsLibrary is a graphics library Ebitengine will use.\n\t//\n\t// The default (zero) value is GraphicsLibraryAuto, which lets Ebitengine choose the graphics library.\n\tGraphicsLibrary GraphicsLibrary\n\n\t// InitUnfocused indicates whether the window is unfocused or not on launching.\n\t// InitUnfocused is valid on desktops and browsers.\n\t//\n\t// The default (zero) value is false, which means that the window is focused.\n\tInitUnfocused bool\n\n\t// ScreenTransparent indicates whether the window is transparent or not.\n\t// ScreenTransparent is valid on desktops and browsers.\n\t//\n\t// The default (zero) value is false, which means that the window is not transparent.\n\tScreenTransparent bool\n\n\t// SkipTaskbar indicates whether an application icon is shown on a taskbar or not.\n\t// SkipTaskbar is valid only on Windows.\n\t//\n\t// The default (zero) value is false, which means that an icon is shown on a taskbar.\n\tSkipTaskbar bool\n\n\t// SingleThread indicates whether the single thread mode is used explicitly or not.\n\t// The single thread mode disables Ebitengine's thread safety to unlock maximum performance.\n\t// If you use this you will have to manage threads yourself.\n\t// Functions like `SetWindowSize` will no longer be concurrent-safe with this build tag.\n\t// They must be called from the main thread or the same goroutine as the given game's callback functions like Update.\n\t//\n\t// SingleThread works only with desktops and consoles.\n\t//\n\t// If SingleThread is false, and if the build tag `ebitenginesinglethread` is specified,\n\t// the single thread mode is used.\n\t//\n\t// The default (zero) value is false, which means that the single thread mode is disabled.\n\tSingleThread bool\n\n\t// DisableHiDPI indicates whether the rendering for HiDPI is disabled or not.\n\t// If HiDPI is disabled, the device scale factor is always 1 i.e. Monitor's DeviceScaleFactor always returns 1.\n\t// This is useful to get a better performance on HiDPI displays, in the expense of rendering quality.\n\t//\n\t// DisableHiDPI is available only on browsers.\n\t//\n\t// The default (zero) value is false, which means that HiDPI is enabled.\n\tDisableHiDPI bool\n\n\t// ColorSpace indicates the color space of the screen.\n\t//\n\t// ColorSpace is available only with some graphics libraries (macOS Metal and WebGL so far).\n\t// Otherwise, ColorSpace is ignored.\n\t//\n\t// The default (zero) value is ColorSpaceDefault, which means that color space depends on the environment.\n\tColorSpace ColorSpace\n\n\t// X11DisplayName is a class name in the ICCCM WM_CLASS window property.\n\tX11ClassName string\n\n\t// X11InstanceName is an instance name in the ICCCM WM_CLASS window property.\n\tX11InstanceName string\n}\n\n// RunGameWithOptions starts the main loop and runs the game with the specified options.\n// game's Update function is called every tick to update the game logic.\n// game's Draw function is called every frame to draw the screen.\n// game's Layout function is called when necessary, and you can specify the logical screen size by the function.\n//\n// options can be nil. In this case, the default options are used.\n//\n// If game implements FinalScreenDrawer, its DrawFinalScreen is called after Draw.\n// The argument screen represents the final screen. The argument offscreen is an offscreen modified at Draw.\n// If game does not implement FinalScreenDrawer, the default rendering for the final screen is used.\n//\n// game's functions are called on the same goroutine.\n//\n// On browsers, it is strongly recommended to use iframe if you embed an Ebitengine application in your website.\n//\n// RunGameWithOptions must be called on the main thread.\n// Note that Ebitengine bounds the main goroutine to the main OS thread by runtime.LockOSThread.\n//\n// Ebitengine tries to call game's Update function 60 times a second by default. In other words,\n// TPS (ticks per second) is 60 by default.\n// This is not related to framerate (display's refresh rate).\n//\n// RunGameWithOptions returns error when 1) an error happens in the underlying graphics driver, 2) an audio error happens\n// or 3) Update returns an error. In the case of 3), RunGameWithOptions returns the same error so far, but it is recommended to\n// use errors.Is when you check the returned error is the error you want, rather than comparing the values\n// with == or != directly.\n//\n// If you want to terminate a game on desktops, it is recommended to return Termination at Update, which will halt\n// execution without returning an error value from RunGameWithOptions.\n//\n// The size unit is device-independent pixel.\n//\n// Don't call RunGame or RunGameWithOptions twice or more in one process.\nfunc RunGameWithOptions(game Game, options *RunGameOptions) error {\n\tdefer isRunGameEnded_.Store(true)\n\n\tinitializeWindowPositionIfNeeded(WindowSize())\n\n\top := toUIRunOptions(options)\n\t// This is necessary to change the result of IsScreenTransparent.\n\tscreenTransparent.Store(op.ScreenTransparent)\n\tg := newGameForUI(game, op.ScreenTransparent)\n\n\tif err := ui.Get().Run(g, op); err != nil {\n\t\tif errors.Is(err, Termination) {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc isRunGameEnded() bool {\n\treturn isRunGameEnded_.Load()\n}\n\n// ScreenSizeInFullscreen returns the size in device-independent pixels when the game is fullscreen.\n// The adopted monitor is the 'current' monitor which the window belongs to.\n// The returned value can be given to SetSize function if the perfectly fit fullscreen is needed.\n//\n// On browsers, ScreenSizeInFullscreen returns the 'window' (global object) size, not 'screen' size.\n// ScreenSizeInFullscreen's returning value is different from the actual screen size and this is a known issue (#2145).\n// For browsers, it is recommended to use Screen API (https://developer.mozilla.org/en-US/docs/Web/API/Screen) if needed.\n//\n// On mobiles, ScreenSizeInFullscreen returns (0, 0) so far.\n//\n// ScreenSizeInFullscreen's use cases are limited. If you are making a fullscreen application, you can use RunGame and\n// the Game interface's Layout function instead. If you are making a not-fullscreen application but the application's\n// behavior depends on the monitor size, ScreenSizeInFullscreen is useful.\n//\n// ScreenSizeInFullscreen must be called on the main thread before ebiten.RunGame, and is concurrent-safe after\n// ebiten.RunGame.\n//\n// Deprecated: as of v2.6. Use Monitor().Size() instead.\nfunc ScreenSizeInFullscreen() (int, int) {\n\treturn ui.Get().ScreenSizeInFullscreen()\n}\n\n// CursorMode returns the current cursor mode.\n//\n// CursorMode returns CursorModeHidden on mobiles.\n//\n// CursorMode is concurrent-safe.\nfunc CursorMode() CursorModeType {\n\treturn CursorModeType(ui.Get().CursorMode())\n}\n\n// SetCursorMode sets the render and capture mode of the mouse cursor.\n// CursorModeVisible sets the cursor to always be visible.\n// CursorModeHidden hides the system cursor when over the window.\n// CursorModeCaptured hides the system cursor and locks it to the window.\n//\n// CursorModeCaptured also works on browsers.\n// When the user exits the captured mode not by SetCursorMode but by the UI (e.g., pressing ESC),\n// the previous cursor mode is set automatically.\n//\n// On browsers, setting CursorModeCaptured might be delayed especially just after escaping from a capture.\n//\n// On browsers, capturing a cursor requires a user gesture, otherwise SetCursorMode does nothing but leave an error message in console.\n// This behavior varies across browser implementations.\n// Check a user interaction before calling capturing a cursor e.g. by IsMouseButtonPressed or IsKeyPressed.\n//\n// SetCursorMode does nothing on mobiles.\n//\n// SetCursorMode is concurrent-safe.\nfunc SetCursorMode(mode CursorModeType) {\n\tui.Get().SetCursorMode(ui.CursorMode(mode))\n}\n\n// IsFullscreen reports whether the current mode is fullscreen or not.\n//\n// IsFullscreen always returns false on mobiles.\n//\n// IsFullscreen is concurrent-safe.\nfunc IsFullscreen() bool {\n\treturn ui.Get().IsFullscreen()\n}\n\n// SetFullscreen changes the current mode to fullscreen or not on desktops and browsers.\n//\n// In fullscreen mode, the game screen is automatically enlarged\n// to fit with the monitor. The current scale value is ignored.\n//\n// On desktops, Ebitengine uses 'windowed' fullscreen mode, which doesn't change\n// your monitor's resolution.\n//\n// On browsers, triggering fullscreen requires a user gesture, otherwise SetFullscreen does nothing but leave an error message in console.\n// This behavior varies across browser implementations.\n// Check a user interaction before triggering fullscreen e.g. by IsMouseButtonPressed or IsKeyPressed.\n//\n// SetFullscreen does nothing on mobiles.\n//\n// SetFullscreen does nothing on macOS when the window is fullscreened natively by the macOS desktop\n// instead of SetFullscreen(true).\n//\n// SetFullscreen is concurrent-safe.\nfunc SetFullscreen(fullscreen bool) {\n\tui.Get().SetFullscreen(fullscreen)\n}\n\n// IsFocused returns a boolean value indicating whether\n// the game is in focus or in the foreground.\n//\n// IsFocused will only return true if IsRunnableOnUnfocused is false.\n//\n// IsFocused is concurrent-safe.\nfunc IsFocused() bool {\n\treturn ui.Get().IsFocused()\n}\n\n// IsRunnableOnUnfocused returns a boolean value indicating whether\n// the game runs even in background.\n//\n// IsRunnableOnUnfocused is concurrent-safe.\nfunc IsRunnableOnUnfocused() bool {\n\treturn ui.Get().IsRunnableOnUnfocused()\n}\n\n// SetRunnableOnUnfocused sets the state if the game runs even in background.\n//\n// If the given value is true, the game runs even in background e.g. when losing focus.\n// The initial state is true.\n//\n// Known issue: On browsers, even if the state is on, the game doesn't run in background tabs.\n// This is because browsers throttles background tabs not to often update.\n//\n// SetRunnableOnUnfocused does nothing on mobiles so far.\n//\n// SetRunnableOnUnfocused is concurrent-safe.\nfunc SetRunnableOnUnfocused(runnableOnUnfocused bool) {\n\tui.Get().SetRunnableOnUnfocused(runnableOnUnfocused)\n}\n\n// DeviceScaleFactor returns a device scale factor value of the current monitor which the window belongs to.\n//\n// DeviceScaleFactor returns a meaningful value on high-DPI display environment,\n// otherwise DeviceScaleFactor returns 1.\n//\n// DeviceScaleFactor might panic on init function on some devices like Android.\n// Then, it is not recommended to call DeviceScaleFactor from init functions.\n//\n// DeviceScaleFactor must be called on the main thread before the main loop, and is concurrent-safe after the main\n// loop.\n//\n// BUG: DeviceScaleFactor value is not affected by SetWindowPosition before RunGame (#1575).\n//\n// Deprecated: as of v2.6. Use Monitor().DeviceScaleFactor() instead.\nfunc DeviceScaleFactor() float64 {\n\treturn Monitor().DeviceScaleFactor()\n}\n\n// IsVsyncEnabled returns a boolean value indicating whether\n// the game uses the display's vsync.\nfunc IsVsyncEnabled() bool {\n\treturn ui.Get().FPSMode() == ui.FPSModeVsyncOn\n}\n\n// SetVsyncEnabled sets a boolean value indicating whether\n// the game uses the display's vsync.\nfunc SetVsyncEnabled(enabled bool) {\n\tif enabled {\n\t\tui.Get().SetFPSMode(ui.FPSModeVsyncOn)\n\t} else {\n\t\tui.Get().SetFPSMode(ui.FPSModeVsyncOffMaximum)\n\t}\n}\n\n// FPSModeType is a type of FPS modes.\n//\n// Deprecated: as of v2.5. Use SetVsyncEnabled instead.\ntype FPSModeType int\n\nconst (\n\t// FPSModeVsyncOn indicates that the game tries to sync the display's refresh rate.\n\t// FPSModeVsyncOn is the default mode.\n\t//\n\t// Deprecated: as of v2.5. Use SetVsyncEnabled(true) instead.\n\tFPSModeVsyncOn FPSModeType = FPSModeType(ui.FPSModeVsyncOn)\n\n\t// FPSModeVsyncOffMaximum indicates that the game doesn't sync with vsync, and\n\t// the game is updated whenever possible.\n\t//\n\t// Be careful that FPSModeVsyncOffMaximum might consume a lot of battery power.\n\t//\n\t// In FPSModeVsyncOffMaximum, the game's Draw is called almost without sleeping.\n\t// The game's Update is called based on the specified TPS.\n\t//\n\t// Deprecated: as of v2.5. Use SetVsyncEnabled(false) instead.\n\tFPSModeVsyncOffMaximum FPSModeType = FPSModeType(ui.FPSModeVsyncOffMaximum)\n\n\t// FPSModeVsyncOffMinimum indicates that the game doesn't sync with vsync, and\n\t// the game is updated only when necessary.\n\t//\n\t// FPSModeVsyncOffMinimum is useful for relatively static applications to save battery power.\n\t//\n\t// In FPSModeVsyncOffMinimum, the game's Update and Draw are called only when\n\t// 1) new inputting except for gamepads is detected, or 2) ScheduleFrame is called.\n\t// In FPSModeVsyncOffMinimum, TPS is SyncWithFPS no matter what TPS is specified at SetTPS.\n\t//\n\t// Deprecated: as of v2.5. Use SetScreenClearedEveryFrame(false) instead.\n\t// See examples/skipdraw for GPU optimization with SetScreenClearedEveryFrame(false).\n\tFPSModeVsyncOffMinimum FPSModeType = FPSModeType(ui.FPSModeVsyncOffMinimum)\n)\n\n// FPSMode returns the current FPS mode.\n//\n// FPSMode is concurrent-safe.\n//\n// Deprecated: as of v2.5. Use SetVsyncEnabled instead.\nfunc FPSMode() FPSModeType {\n\treturn FPSModeType(ui.Get().FPSMode())\n}\n\n// SetFPSMode sets the FPS mode.\n// The default FPS mode is FPSModeVsyncOn.\n//\n// SetFPSMode is concurrent-safe.\n//\n// Deprecated: as of v2.5. Use SetVsyncEnabled instead.\nfunc SetFPSMode(mode FPSModeType) {\n\tui.Get().SetFPSMode(ui.FPSModeType(mode))\n}\n\n// ScheduleFrame schedules a next frame when the current FPS mode is FPSModeVsyncOffMinimum.\n//\n// ScheduleFrame is concurrent-safe.\n//\n// Deprecated: as of v2.5. Use SetScreenClearedEveryFrame(false) instead.\n// See examples/skipdraw for GPU optimization with SetScreenClearedEveryFrame(false).\nfunc ScheduleFrame() {\n\tui.Get().ScheduleFrame()\n}\n\n// TPS returns the current maximum TPS.\n//\n// TPS is concurrent-safe.\nfunc TPS() int {\n\treturn clock.TPS()\n}\n\n// MaxTPS returns the current maximum TPS.\n//\n// Deprecated: as of v2.4. Use TPS instead.\nfunc MaxTPS() int {\n\treturn TPS()\n}\n\n// ActualTPS returns the current TPS (ticks per second),\n// that represents how many times Update function is called in a second.\n//\n// This value is for measurement and/or debug, and your game logic should not rely on this value.\n//\n// ActualTPS is concurrent-safe.\nfunc ActualTPS() float64 {\n\treturn clock.ActualTPS()\n}\n\n// CurrentTPS returns the current TPS (ticks per second),\n// that represents how many times Update function is called in a second.\n//\n// Deprecated: as of v2.4. Use ActualTPS instead.\nfunc CurrentTPS() float64 {\n\treturn ActualTPS()\n}\n\n// SyncWithFPS is a special TPS value that means TPS syncs with FPS.\nconst SyncWithFPS = clock.SyncWithFPS\n\n// UncappedTPS is a special TPS value that means TPS syncs with FPS.\n//\n// Deprecated: as of v2.2. Use SyncWithFPS instead.\nconst UncappedTPS = SyncWithFPS\n\n// SetTPS sets the maximum TPS (ticks per second),\n// that represents how many times updating function is called per second.\n// The initial value is 60.\n//\n// If tps is SyncWithFPS, TPS is uncapped and the game is updated per frame.\n// If tps is negative but not SyncWithFPS, SetTPS panics.\n//\n// SetTPS is concurrent-safe.\nfunc SetTPS(tps int) {\n\tclock.SetTPS(tps)\n}\n\n// SetMaxTPS sets the maximum TPS (ticks per second),\n// that represents how many times updating function is called per second.\n//\n// Deprecated: as of v2.4. Use SetTPS instead.\nfunc SetMaxTPS(tps int) {\n\tSetTPS(tps)\n}\n\n// IsScreenTransparent reports whether the window is transparent.\n//\n// IsScreenTransparent is concurrent-safe.\n//\n// Deprecated: as of v2.5.\nfunc IsScreenTransparent() bool {\n\tif !ui.IsScreenTransparentAvailable() {\n\t\treturn false\n\t}\n\treturn screenTransparent.Load()\n}\n\n// SetScreenTransparent sets the state if the window is transparent.\n//\n// SetScreenTransparent panics if SetScreenTransparent is called after the main loop.\n//\n// SetScreenTransparent does nothing on mobiles.\n//\n// SetScreenTransparent is concurrent-safe.\n//\n// Deprecated: as of v2.5. Use RunGameWithOptions instead.\nfunc SetScreenTransparent(transparent bool) {\n\tscreenTransparent.Store(transparent)\n}\n\nvar screenTransparent atomic.Bool\n\n// SetInitFocused sets whether the application is focused on show.\n// The default value is true, i.e., the application is focused.\n//\n// SetInitFocused does nothing on mobile.\n//\n// SetInitFocused panics if this is called after the main loop.\n//\n// SetInitFocused is concurrent-safe.\n//\n// Deprecated: as of v2.5. Use RunGameWithOptions instead.\nfunc SetInitFocused(focused bool) {\n\tinitUnfocused.Store(!focused)\n}\n\nvar initUnfocused atomic.Bool\n\nfunc toUIRunOptions(options *RunGameOptions) *ui.RunOptions {\n\tconst (\n\t\tdefaultX11ClassName    = \"Ebitengine-Application\"\n\t\tdefaultX11InstanceName = \"ebitengine-application\"\n\t)\n\n\tif options == nil {\n\t\treturn &ui.RunOptions{\n\t\t\tInitUnfocused:     initUnfocused.Load(),\n\t\t\tScreenTransparent: screenTransparent.Load(),\n\t\t\tX11ClassName:      defaultX11ClassName,\n\t\t\tX11InstanceName:   defaultX11InstanceName,\n\t\t}\n\t}\n\n\tif options.X11ClassName == \"\" {\n\t\toptions.X11ClassName = defaultX11ClassName\n\t}\n\tif options.X11InstanceName == \"\" {\n\t\toptions.X11InstanceName = defaultX11InstanceName\n\t}\n\n\t// ui.RunOptions.StrictContextRestoration is not used so far (#3098).\n\t// This might be reused in the future.\n\t// The original comment for StrictContextRestration is as follows:\n\t//\n\t// StrictContextRestration indicates whether the context lost should be restored strictly by Ebitengine or not.\n\t//\n\t// StrictContextRestration is available only on Android. Otherwise, StrictContextRestration is ignored.\n\t// Thus, StrictContextRestration should be used with mobile.SetGameWithOptions, rather than RunGameWithOptions.\n\t//\n\t// In Android, Ebitengien uses `GLSurfaceView`'s `setPreserveEGLContextOnPause(true)`.\n\t// This works in most cases, but it is still possible that the context is lost in some minor cases.\n\t//\n\t// When StrictContextRestration is true, Ebitengine tries to restore the context more strictly\n\t// for such minor cases.\n\t// However, this might cause a performance issue since Ebitengine tries to keep all the information\n\t// to restore the context.\n\t//\n\t// When StrictContextRestration is false, Ebitengine does nothing special to restore the context and\n\t// relies on the OS's behavior.\n\t//\n\t// The default (zero) value is false.\n\n\treturn &ui.RunOptions{\n\t\tGraphicsLibrary:   ui.GraphicsLibrary(options.GraphicsLibrary),\n\t\tInitUnfocused:     options.InitUnfocused,\n\t\tScreenTransparent: options.ScreenTransparent,\n\t\tSkipTaskbar:       options.SkipTaskbar,\n\t\tSingleThread:      options.SingleThread,\n\t\tDisableHiDPI:      options.DisableHiDPI,\n\t\tColorSpace:        graphicsdriver.ColorSpace(options.ColorSpace),\n\t\tX11ClassName:      options.X11ClassName,\n\t\tX11InstanceName:   options.X11InstanceName,\n\t}\n}\n\n// DroppedFiles returns a virtual file system that includes only dropped files and/or directories\n// at its root directory, at the time Update is called.\n//\n// DroppedFiles works on desktops and browsers.\n//\n// DroppedFiles is concurrent-safe.\nfunc DroppedFiles() fs.FS {\n\treturn theInputState.droppedFiles()\n}\n"
        },
        {
          "name": "run_mobile.go",
          "type": "blob",
          "size": 1.2353515625,
          "content": "// Copyright 2021 The Ebiten Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//go:build android || ios\n\npackage ebiten\n\nimport (\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\n// RunGameWithoutMainLoop runs the game, but doesn't call the loop on the main (UI) thread.\n// RunGameWithoutMainLoop returns immediately unlike Run.\n//\n// Ebitengine users should NOT call RunGameWithoutMainLoop.\n// Instead, functions in github.com/hajimehoshi/ebiten/v2/mobile package calls this.\n//\n// TODO: Remove this. In order to remove this, the gameForUI should be in another package.\nfunc RunGameWithoutMainLoop(game Game, options *RunGameOptions) {\n\top := toUIRunOptions(options)\n\tui.Get().RunWithoutMainLoop(newGameForUI(game, op.ScreenTransparent), op)\n}\n"
        },
        {
          "name": "shader.go",
          "type": "blob",
          "size": 4.3251953125,
          "content": "// Copyright 2020 The Ebiten Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/hajimehoshi/ebiten/v2/internal/builtinshader\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/graphics\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/shaderir\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\n// Shader represents a compiled shader program.\n//\n// For the details about the shader, see https://ebitengine.org/en/documents/shader.html.\ntype Shader struct {\n\tshader *ui.Shader\n\tunit   shaderir.Unit\n}\n\n// NewShader compiles a shader program in the shading language Kage, and returns the result.\n//\n// If the compilation fails, NewShader returns an error.\n//\n// For the details about the shader, see https://ebitengine.org/en/documents/shader.html.\nfunc NewShader(src []byte) (*Shader, error) {\n\treturn newShader(src, \"\")\n}\n\nfunc newShader(src []byte, name string) (*Shader, error) {\n\tir, err := graphics.CompileShader(src)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Shader{\n\t\tshader: ui.NewShader(ir, name),\n\t\tunit:   ir.Unit,\n\t}, nil\n}\n\n// Dispose disposes the shader program.\n// After disposing, the shader is no longer available.\n//\n// Deprecated: as of v2.7. Use Deallocate instead.\nfunc (s *Shader) Dispose() {\n\ts.shader.Deallocate()\n\ts.shader = nil\n}\n\nfunc (s *Shader) isDisposed() bool {\n\treturn s.shader == nil\n}\n\n// Deallocate deallocates the internal state of the shader.\n// Even after Deallocate is called, the shader is still available.\n// In this case, the shader's internal state is allocated again.\n//\n// Usually, you don't have to call Deallocate since the internal state is automatically released by GC.\n// However, if you are sure that the shader is no longer used but not sure how this shader object is referred,\n// you can call Deallocate to make sure that the internal state is deallocated.\n//\n// If the shader is disposed, Deallocate does nothing.\nfunc (s *Shader) Deallocate() {\n\tif s.shader == nil {\n\t\treturn\n\t}\n\ts.shader.Deallocate()\n}\n\nfunc (s *Shader) appendUniforms(dst []uint32, uniforms map[string]any) []uint32 {\n\treturn s.shader.AppendUniforms(dst, uniforms)\n}\n\nvar (\n\tbuiltinShadersForRead atomic.Pointer[[builtinshader.FilterCount][builtinshader.AddressCount][2]*Shader]\n\tbuiltinShadersM       sync.Mutex\n)\n\nfunc builtinShader(filter builtinshader.Filter, address builtinshader.Address, useColorM bool) *Shader {\n\tvar c int\n\tif useColorM {\n\t\tc = 1\n\t}\n\tif read := builtinShadersForRead.Load(); read != nil {\n\t\tif s := (*read)[filter][address][c]; s != nil {\n\t\t\treturn s\n\t\t}\n\t}\n\n\tbuiltinShadersM.Lock()\n\tdefer builtinShadersM.Unlock()\n\n\t// Double check in case another goroutine already created a shader.\n\tif read := builtinShadersForRead.Load(); read != nil {\n\t\tif s := (*read)[filter][address][c]; s != nil {\n\t\t\treturn s\n\t\t}\n\t}\n\n\tvar shader *Shader\n\tif address == builtinshader.AddressUnsafe && !useColorM {\n\t\tswitch filter {\n\t\tcase builtinshader.FilterNearest:\n\t\t\tshader = &Shader{shader: ui.NearestFilterShader}\n\t\tcase builtinshader.FilterLinear:\n\t\t\tshader = &Shader{shader: ui.LinearFilterShader}\n\t\t}\n\t} else {\n\t\tsrc := builtinshader.ShaderSource(filter, address, useColorM)\n\t\tvar name string\n\t\tswitch filter {\n\t\tcase builtinshader.FilterNearest:\n\t\t\tname = \"nearest\"\n\t\tcase builtinshader.FilterLinear:\n\t\t\tname = \"linear\"\n\t\t}\n\t\tswitch address {\n\t\tcase builtinshader.AddressClampToZero:\n\t\t\tname += \"-clamptozero\"\n\t\tcase builtinshader.AddressRepeat:\n\t\t\tname += \"-repeat\"\n\t\t}\n\t\tif useColorM {\n\t\t\tname += \"-colorm\"\n\t\t}\n\t\ts, err := newShader(src, name)\n\t\tif err != nil {\n\t\t\tpanic(fmt.Sprintf(\"ebiten: NewShader for a built-in shader failed: %v\", err))\n\t\t}\n\t\tshader = s\n\t}\n\n\tvar shaders [builtinshader.FilterCount][builtinshader.AddressCount][2]*Shader\n\tif ptr := builtinShadersForRead.Load(); ptr != nil {\n\t\tshaders = *ptr\n\t}\n\tshaders[filter][address][c] = shader\n\tbuiltinShadersForRead.Store(&shaders)\n\treturn shader\n}\n"
        },
        {
          "name": "shader_test.go",
          "type": "blob",
          "size": 59.7216796875,
          "content": "// Copyright 2020 The Ebiten Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten_test\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/hajimehoshi/ebiten/v2\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/builtinshader\"\n)\n\nfunc TestShaderFill(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(1, 0, 0, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst.DrawRectShader(w/2, h/2, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\tvar want color.RGBA\n\t\t\tif i < w/2 && j < h/2 {\n\t\t\t\twant = color.RGBA{R: 0xff, A: 0xff}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderFillWithDrawImage(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(1, 0, 0, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsrc := ebiten.NewImage(w/2, h/2)\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Images[0] = src\n\tdst.DrawRectShader(w/2, h/2, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\tvar want color.RGBA\n\t\t\tif i < w/2 && j < h/2 {\n\t\t\t\twant = color.RGBA{R: 0xff, A: 0xff}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #2525\nfunc TestShaderWithDrawImageDoesNotWreckTextureUnits(t *testing.T) {\n\tconst w, h = 16, 16\n\trect := image.Rectangle{Max: image.Point{X: w, Y: h}}\n\n\tdst := ebiten.NewImageWithOptions(rect, &ebiten.NewImageOptions{Unmanaged: true})\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn imageSrc0At(srcPos)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsrc0 := ebiten.NewImageWithOptions(rect, &ebiten.NewImageOptions{Unmanaged: true})\n\tsrc0.Fill(color.RGBA{R: 25, G: 0xff, B: 25, A: 0xff})\n\tsrc1 := ebiten.NewImageWithOptions(rect, &ebiten.NewImageOptions{Unmanaged: true})\n\tsrc1.Fill(color.RGBA{R: 0xff, A: 0xff})\n\top := &ebiten.DrawRectShaderOptions{}\n\top.CompositeMode = ebiten.CompositeModeCopy\n\top.Images[0] = src0\n\top.Images[1] = src1\n\tdst.DrawRectShader(w, h, s, op)\n\top.Images[0] = src1\n\top.Images[1] = nil\n\tdst.DrawRectShader(w, h, s, op) // dst should now be identical to src1.\n\n\t// With issue #2525, instead, GL_TEXTURE0 is active but with src0 bound\n\t// while binding src1 gets skipped!\n\t// This means that src0, not src1, got copied to dst.\n\n\t// Demonstrate the bug with a write to src1, which will actually end up on src0.\n\t// Validated later.\n\tvar buf []byte\n\tfor i := 0; i < w*h; i++ {\n\t\tbuf = append(buf, 2, 5, 2, 5)\n\t}\n\tsrc1.WritePixels(buf)\n\n\t// Verify that src1 was copied to dst.\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0xff, A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fix up texture unit assignment by binding a different texture.\n\top.Images[0] = src1\n\tdst.DrawRectShader(w, h, s, op)\n\top.Images[0] = src0\n\tdst.DrawRectShader(w, h, s, op)\n\n\t// Verify that src0 was copied to dst and not overwritten above.\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 25, G: 0xff, B: 25, A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderFillWithDrawTriangles(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(1, 0, 0, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsrc := ebiten.NewImage(w/2, h/2)\n\top := &ebiten.DrawTrianglesShaderOptions{}\n\top.Images[0] = src\n\n\tvs := []ebiten.Vertex{\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   0,\n\t\t\tSrcX:   w / 2,\n\t\t\tSrcY:   0,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   0,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   0,\n\t\t\tSrcY:   h / 2,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t\t{\n\t\t\tDstX:   w,\n\t\t\tDstY:   h,\n\t\t\tSrcX:   w / 2,\n\t\t\tSrcY:   h / 2,\n\t\t\tColorR: 1,\n\t\t\tColorG: 1,\n\t\t\tColorB: 1,\n\t\t\tColorA: 1,\n\t\t},\n\t}\n\tis := []uint16{0, 1, 2, 1, 2, 3}\n\n\tdst.DrawTrianglesShader(vs, is, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0xff, A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderFunction(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc clr(red float) (float, float, float, float) {\n\treturn red, 0, 0, 1\n}\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(clr(1))\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst.DrawRectShader(w, h, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0xff, A: 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderUninitializedUniformVariables(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nvar U vec4\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn U\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst.DrawRectShader(w, h, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\tvar want color.RGBA\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderMatrix(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\tvar a, b mat4\n\ta[0] = vec4(0.125, 0.0625, 0.0625, 0.0625)\n\ta[1] = vec4(0.25, 0.25, 0.0625, 0.1875)\n\ta[2] = vec4(0.1875, 0.125, 0.25, 0.25)\n\ta[3] = vec4(0.0625, 0.1875, 0.125, 0.25)\n\tb[0] = vec4(0.0625, 0.125, 0.0625, 0.125)\n\tb[1] = vec4(0.125, 0.1875, 0.25, 0.0625)\n\tb[2] = vec4(0.125, 0.125, 0.1875, 0.1875)\n\tb[3] = vec4(0.25, 0.0625, 0.125, 0.0625)\n\treturn vec4((a * b * vec4(1, 1, 1, 1)).xyz, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsrc := ebiten.NewImage(w, h)\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Images[0] = src\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 87, G: 82, B: 71, A: 255}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderSubImage(t *testing.T) {\n\tconst w, h = 16, 16\n\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\tr := imageSrc0At(srcPos).r\n\tg := imageSrc1At(srcPos).g\n\treturn vec4(r, g, 0, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsrc0 := ebiten.NewImage(w, h)\n\tpix0 := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tif 2 <= i && i < 10 && 3 <= j && j < 11 {\n\t\t\t\tpix0[4*(j*w+i)] = 0xff\n\t\t\t\tpix0[4*(j*w+i)+1] = 0\n\t\t\t\tpix0[4*(j*w+i)+2] = 0\n\t\t\t\tpix0[4*(j*w+i)+3] = 0xff\n\t\t\t}\n\t\t}\n\t}\n\tsrc0.WritePixels(pix0)\n\tsrc0 = src0.SubImage(image.Rect(2, 3, 10, 11)).(*ebiten.Image)\n\n\tsrc1 := ebiten.NewImage(w, h)\n\tpix1 := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tif 6 <= i && i < 14 && 8 <= j && j < 16 {\n\t\t\t\tpix1[4*(j*w+i)] = 0\n\t\t\t\tpix1[4*(j*w+i)+1] = 0xff\n\t\t\t\tpix1[4*(j*w+i)+2] = 0\n\t\t\t\tpix1[4*(j*w+i)+3] = 0xff\n\t\t\t}\n\t\t}\n\t}\n\tsrc1.WritePixels(pix1)\n\tsrc1 = src1.SubImage(image.Rect(6, 8, 14, 16)).(*ebiten.Image)\n\n\ttestPixels := func(testname string, dst *ebiten.Image) {\n\t\tfor j := 0; j < h; j++ {\n\t\t\tfor i := 0; i < w; i++ {\n\t\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\t\tvar want color.RGBA\n\t\t\t\tif i < w/2 && j < h/2 {\n\t\t\t\t\twant = color.RGBA{R: 0xff, G: 0xff, A: 0xff}\n\t\t\t\t}\n\t\t\t\tif got != want {\n\t\t\t\t\tt.Errorf(\"%s dst.At(%d, %d): got: %v, want: %v\", testname, i, j, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tt.Run(\"DrawRectShader\", func(t *testing.T) {\n\t\tdst := ebiten.NewImage(w, h)\n\t\top := &ebiten.DrawRectShaderOptions{}\n\t\top.Images[0] = src0\n\t\top.Images[1] = src1\n\t\tdst.DrawRectShader(w/2, h/2, s, op)\n\t\ttestPixels(\"DrawRectShader\", dst)\n\t})\n\n\tt.Run(\"DrawTrianglesShader\", func(t *testing.T) {\n\t\tdst := ebiten.NewImage(w, h)\n\t\tvs := []ebiten.Vertex{\n\t\t\t{\n\t\t\t\tDstX:   0,\n\t\t\t\tDstY:   0,\n\t\t\t\tSrcX:   2,\n\t\t\t\tSrcY:   3,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tDstX:   w / 2,\n\t\t\t\tDstY:   0,\n\t\t\t\tSrcX:   10,\n\t\t\t\tSrcY:   3,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tDstX:   0,\n\t\t\t\tDstY:   h / 2,\n\t\t\t\tSrcX:   2,\n\t\t\t\tSrcY:   11,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tDstX:   w / 2,\n\t\t\t\tDstY:   h / 2,\n\t\t\t\tSrcX:   10,\n\t\t\t\tSrcY:   11,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t}\n\t\tis := []uint16{0, 1, 2, 1, 2, 3}\n\n\t\top := &ebiten.DrawTrianglesShaderOptions{}\n\t\top.Images[0] = src0\n\t\top.Images[1] = src1\n\t\tdst.DrawTrianglesShader(vs, is, s, op)\n\t\ttestPixels(\"DrawTrianglesShader\", dst)\n\t})\n}\n\n// Issue #1404\nfunc TestShaderDerivatives(t *testing.T) {\n\tt.Skip(\"the results of dfdx, dfdy, and fwidth are indeterministic (#2583)\")\n\n\tconst w, h = 16, 16\n\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\tp := imageSrc0At(srcPos)\n\treturn vec4(abs(dfdx(p.r)), abs(dfdy(p.g)), 0, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\tpix := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tif i < w/2 {\n\t\t\t\tpix[4*(j*w+i)] = 0xff\n\t\t\t}\n\t\t\tif j < h/2 {\n\t\t\t\tpix[4*(j*w+i)+1] = 0xff\n\t\t\t}\n\t\t\tpix[4*(j*w+i)+3] = 0xff\n\t\t}\n\t}\n\tsrc.WritePixels(pix)\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Images[0] = src\n\tdst.DrawRectShader(w, h, s, op)\n\n\t// The results of the edges might be unreliable. Skip the edges.\n\tfor j := 1; j < h-1; j++ {\n\t\tfor i := 1; i < w-1; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{A: 0xff}\n\t\t\tif i == w/2-1 || i == w/2 {\n\t\t\t\twant.R = 0xff\n\t\t\t}\n\t\t\tif j == h/2-1 || j == h/2 {\n\t\t\t\twant.G = 0xff\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #1701\nfunc TestShaderDerivatives2(t *testing.T) {\n\tt.Skip(\"the results of dfdx, dfdy, and fwidth are indeterministic (#2583)\")\n\n\tconst w, h = 16, 16\n\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\n// This function uses dfdx and then should not be in GLSL's vertex shader (#1701).\nfunc Foo(p vec4) vec4 {\n\treturn vec4(abs(dfdx(p.r)), abs(dfdy(p.g)), 0, 1)\n}\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\tp := imageSrc0At(srcPos)\n\treturn Foo(p)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\tpix := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tif i < w/2 {\n\t\t\t\tpix[4*(j*w+i)] = 0xff\n\t\t\t}\n\t\t\tif j < h/2 {\n\t\t\t\tpix[4*(j*w+i)+1] = 0xff\n\t\t\t}\n\t\t\tpix[4*(j*w+i)+3] = 0xff\n\t\t}\n\t}\n\tsrc.WritePixels(pix)\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Images[0] = src\n\tdst.DrawRectShader(w, h, s, op)\n\n\t// The results of the edges might be unreliable. Skip the edges.\n\tfor j := 1; j < h-1; j++ {\n\t\tfor i := 1; i < w-1; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{A: 0xff}\n\t\t\tif i == w/2-1 || i == w/2 {\n\t\t\t\twant.R = 0xff\n\t\t\t}\n\t\t\tif j == h/2-1 || j == h/2 {\n\t\t\t\twant.G = 0xff\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #1754\nfunc TestShaderUniformFirstElement(t *testing.T) {\n\tshaders := []struct {\n\t\tName     string\n\t\tShader   string\n\t\tUniforms map[string]any\n\t}{\n\t\t{\n\t\t\tName: \"float array\",\n\t\t\tShader: `//kage:unit pixels\n\npackage main\n\nvar C [2]float\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(C[0], 1, 1, 1)\n}`,\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"C\": []float32{1, 1},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"float one-element array\",\n\t\t\tShader: `//kage:unit pixels\n\npackage main\n\nvar C [1]float\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(C[0], 1, 1, 1)\n}`,\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"C\": []float32{1},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"matrix array\",\n\t\t\tShader: `//kage:unit pixels\n\npackage main\n\nvar C [2]mat2\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(C[0][0][0], 1, 1, 1)\n}`,\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"C\": []float32{1, 0, 0, 0, 0, 0, 0, 0},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, shader := range shaders {\n\t\tshader := shader\n\t\tt.Run(shader.Name, func(t *testing.T) {\n\t\t\tconst w, h = 1, 1\n\n\t\t\tdst := ebiten.NewImage(w, h)\n\t\t\tdefer dst.Deallocate()\n\n\t\t\ts, err := ebiten.NewShader([]byte(shader.Shader))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdefer s.Deallocate()\n\n\t\t\top := &ebiten.DrawRectShaderOptions{}\n\t\t\top.Uniforms = shader.Uniforms\n\t\t\tdst.DrawRectShader(w, h, s, op)\n\t\t\tif got, want := dst.At(0, 0), (color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}); got != want {\n\t\t\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Issue #2006\nfunc TestShaderFuncMod(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\tr := mod(-0.25, 1.0)\n\treturn vec4(r, 0, 0, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst.DrawRectShader(w/2, h/2, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\tvar want color.RGBA\n\t\t\tif i < w/2 && j < h/2 {\n\t\t\t\twant = color.RGBA{R: 0xc0, A: 0xff}\n\t\t\t}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderMatrixInitialize(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tsrc := ebiten.NewImage(w, h)\n\tsrc.Fill(color.RGBA{R: 0x10, G: 0x20, B: 0x30, A: 0xff})\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn mat4(2) * imageSrc0At(srcPos);\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Images[0] = src\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0x20, G: 0x40, B: 0x60, A: 0xff}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #2029\nfunc TestShaderModVectorAndFloat(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\tr := mod(vec3(0.25, 0.5, 0.75), 0.5)\n\treturn vec4(r, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst.DrawRectShader(w, h, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0x40, B: 0x40, A: 0xff}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderTextureAt(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tsrc := ebiten.NewImage(w, h)\n\tsrc.Fill(color.RGBA{R: 0x10, G: 0x20, B: 0x30, A: 0xff})\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc textureAt(uv vec2) vec4 {\n\treturn imageSrc0UnsafeAt(uv)\n}\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn textureAt(srcPos)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Images[0] = src\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0x10, G: 0x20, B: 0x30, A: 0xff}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderAtan2(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tsrc := ebiten.NewImage(w, h)\n\tsrc.Fill(color.RGBA{R: 0x10, G: 0x20, B: 0x30, A: 0xff})\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\ty := vec4(1, 1, 1, 1)\n\tx := vec4(1, 1, 1, 1)\n\treturn atan2(y, x)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Images[0] = src\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\tv := byte(math.Floor(0xff * math.Pi / 4))\n\t\t\twant := color.RGBA{R: v, G: v, B: v, A: v}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderUniformMatrix2(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nvar Mat2 mat2\nvar F float\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(F * Mat2 * vec2(1), 1, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Uniforms = map[string]any{\n\t\t\"Mat2\": []float32{\n\t\t\t1.0 / 256.0, 2.0 / 256.0,\n\t\t\t3.0 / 256.0, 4.0 / 256.0,\n\t\t},\n\t\t\"F\": float32(2),\n\t}\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 8, G: 12, B: 0xff, A: 0xff}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderUniformMatrix2Array(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nvar Mat2 [2]mat2\nvar F float\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(F * Mat2[0] * Mat2[1] * vec2(1), 1, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Uniforms = map[string]any{\n\t\t\"Mat2\": []float32{\n\t\t\t1.0 / 256.0, 2.0 / 256.0,\n\t\t\t3.0 / 256.0, 4.0 / 256.0,\n\t\t\t5.0 / 256.0, 6.0 / 256.0,\n\t\t\t7.0 / 256.0, 8.0 / 256.0,\n\t\t},\n\t\t\"F\": float32(256),\n\t}\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 54, G: 80, B: 0xff, A: 0xff}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderUniformMatrix3(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nvar Mat3 mat3\nvar F float\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(F * Mat3 * vec3(1), 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Uniforms = map[string]any{\n\t\t\"Mat3\": []float32{\n\t\t\t1.0 / 256.0, 2.0 / 256.0, 3.0 / 256.0,\n\t\t\t4.0 / 256.0, 5.0 / 256.0, 6.0 / 256.0,\n\t\t\t7.0 / 256.0, 8.0 / 256.0, 9.0 / 256.0,\n\t\t},\n\t\t\"F\": float32(2),\n\t}\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 24, G: 30, B: 36, A: 0xff}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderUniformMatrix3Array(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nvar Mat3 [2]mat3\nvar F float\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(F * Mat3[0] * Mat3[1] * vec3(1), 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Uniforms = map[string]any{\n\t\t\"Mat3\": []float32{\n\t\t\t1.0 / 256.0, 2.0 / 256.0, 3.0 / 256.0,\n\t\t\t4.0 / 256.0, 5.0 / 256.0, 6.0 / 256.0,\n\t\t\t7.0 / 256.0, 8.0 / 256.0, 9.0 / 256.0,\n\t\t\t10.0 / 256.0, 11.0 / 256.0, 12.0 / 256.0,\n\t\t\t13.0 / 256.0, 14.0 / 256.0, 15.0 / 256.0,\n\t\t\t16.0 / 256.0, 17.0 / 256.0, 18.0 / 256.0,\n\t\t},\n\t\t\"F\": float32(3),\n\t}\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 6, G: 8, B: 9, A: 0xff}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderUniformMatrix4(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nvar Mat4 mat4\nvar F float\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn F * Mat4 * vec4(1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Uniforms = map[string]any{\n\t\t\"Mat4\": []float32{\n\t\t\t1.0 / 256.0, 2.0 / 256.0, 3.0 / 256.0, 4.0 / 256.0,\n\t\t\t5.0 / 256.0, 6.0 / 256.0, 7.0 / 256.0, 8.0 / 256.0,\n\t\t\t9.0 / 256.0, 10.0 / 256.0, 11.0 / 256.0, 12.0 / 256.0,\n\t\t\t13.0 / 256.0, 14.0 / 256.0, 15.0 / 256.0, 16.0 / 256.0,\n\t\t},\n\t\t\"F\": float32(4),\n\t}\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 112, G: 128, B: 143, A: 159}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderUniformMatrix4Array(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nvar Mat4 [2]mat4\nvar F float\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn F * Mat4[0] * Mat4[1] * vec4(1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Uniforms = map[string]any{\n\t\t\"Mat4\": []float32{\n\t\t\t1.0 / 256.0, 2.0 / 256.0, 3.0 / 256.0, 4.0 / 256.0,\n\t\t\t5.0 / 256.0, 6.0 / 256.0, 7.0 / 256.0, 8.0 / 256.0,\n\t\t\t9.0 / 256.0, 10.0 / 256.0, 11.0 / 256.0, 12.0 / 256.0,\n\t\t\t13.0 / 256.0, 14.0 / 256.0, 15.0 / 256.0, 16.0 / 256.0,\n\t\t\t17.0 / 256.0, 18.0 / 256.0, 19.0 / 256.0, 20.0 / 256.0,\n\t\t\t21.0 / 256.0, 22.0 / 256.0, 23.0 / 256.0, 24.0 / 256.0,\n\t\t\t25.0 / 256.0, 26.0 / 256.0, 27.0 / 256.0, 28.0 / 256.0,\n\t\t\t29.0 / 256.0, 30.0 / 256.0, 31.0 / 256.0, 32.0 / 256.0,\n\t\t},\n\t\t\"F\": float32(4),\n\t}\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 44, G: 50, B: 56, A: 62}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderUniformMatrixIndexer(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nvar Mat4 mat4\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn Mat4[1][2] * vec4(1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Uniforms = map[string]any{\n\t\t\"Mat4\": []float32{\n\t\t\t1.0 / 256.0, 2.0 / 256.0, 3.0 / 256.0, 4.0 / 256.0,\n\t\t\t5.0 / 256.0, 6.0 / 256.0, 7.0 / 256.0, 8.0 / 256.0,\n\t\t\t9.0 / 256.0, 10.0 / 256.0, 11.0 / 256.0, 12.0 / 256.0,\n\t\t\t13.0 / 256.0, 14.0 / 256.0, 15.0 / 256.0, 16.0 / 256.0,\n\t\t},\n\t}\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 7, G: 7, B: 7, A: 7}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderOptionsNegativeBounds(t *testing.T) {\n\tconst w, h = 16, 16\n\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\tr := imageSrc0At(srcPos).r\n\tg := imageSrc1At(srcPos).g\n\treturn vec4(r, g, 0, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tconst offset0 = -4\n\tsrc0 := ebiten.NewImageWithOptions(image.Rect(offset0, offset0, w+offset0, h+offset0), nil)\n\tpix0 := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tif 2 <= i && i < 10 && 3 <= j && j < 11 {\n\t\t\t\tpix0[4*(j*w+i)] = 0xff\n\t\t\t\tpix0[4*(j*w+i)+1] = 0\n\t\t\t\tpix0[4*(j*w+i)+2] = 0\n\t\t\t\tpix0[4*(j*w+i)+3] = 0xff\n\t\t\t}\n\t\t}\n\t}\n\tsrc0.WritePixels(pix0)\n\tsrc0 = src0.SubImage(image.Rect(2+offset0, 3+offset0, 10+offset0, 11+offset0)).(*ebiten.Image)\n\n\tconst offset1 = -6\n\tsrc1 := ebiten.NewImageWithOptions(image.Rect(offset1, offset1, w+offset1, h+offset1), nil)\n\tpix1 := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tif 6 <= i && i < 14 && 8 <= j && j < 16 {\n\t\t\t\tpix1[4*(j*w+i)] = 0\n\t\t\t\tpix1[4*(j*w+i)+1] = 0xff\n\t\t\t\tpix1[4*(j*w+i)+2] = 0\n\t\t\t\tpix1[4*(j*w+i)+3] = 0xff\n\t\t\t}\n\t\t}\n\t}\n\tsrc1.WritePixels(pix1)\n\tsrc1 = src1.SubImage(image.Rect(6+offset1, 8+offset1, 14+offset1, 16+offset1)).(*ebiten.Image)\n\n\tconst offset2 = -2\n\ttestPixels := func(testname string, dst *ebiten.Image) {\n\t\tfor j := offset2; j < h+offset2; j++ {\n\t\t\tfor i := offset2; i < w+offset2; i++ {\n\t\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\t\tvar want color.RGBA\n\t\t\t\tif 0 <= i && i < w/2 && 0 <= j && j < h/2 {\n\t\t\t\t\twant = color.RGBA{R: 0xff, G: 0xff, A: 0xff}\n\t\t\t\t}\n\t\t\t\tif got != want {\n\t\t\t\t\tt.Errorf(\"%s dst.At(%d, %d): got: %v, want: %v\", testname, i, j, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tt.Run(\"DrawRectShader\", func(t *testing.T) {\n\t\tdst := ebiten.NewImageWithOptions(image.Rect(offset2, offset2, w+offset2, h+offset2), nil)\n\t\top := &ebiten.DrawRectShaderOptions{}\n\t\top.Images[0] = src0\n\t\top.Images[1] = src1\n\t\tdst.DrawRectShader(w/2, h/2, s, op)\n\t\ttestPixels(\"DrawRectShader\", dst)\n\t})\n\n\tt.Run(\"DrawTrianglesShader\", func(t *testing.T) {\n\t\tdst := ebiten.NewImageWithOptions(image.Rect(offset2, offset2, w+offset2, h+offset2), nil)\n\t\tvs := []ebiten.Vertex{\n\t\t\t{\n\t\t\t\tDstX:   0,\n\t\t\t\tDstY:   0,\n\t\t\t\tSrcX:   2 + offset0,\n\t\t\t\tSrcY:   3 + offset0,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tDstX:   w / 2,\n\t\t\t\tDstY:   0,\n\t\t\t\tSrcX:   10 + offset0,\n\t\t\t\tSrcY:   3 + offset0,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tDstX:   0,\n\t\t\t\tDstY:   h / 2,\n\t\t\t\tSrcX:   2 + offset0,\n\t\t\t\tSrcY:   11 + offset0,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tDstX:   w / 2,\n\t\t\t\tDstY:   h / 2,\n\t\t\t\tSrcX:   10 + offset0,\n\t\t\t\tSrcY:   11 + offset0,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t}\n\t\tis := []uint16{0, 1, 2, 1, 2, 3}\n\n\t\top := &ebiten.DrawTrianglesShaderOptions{}\n\t\top.Images[0] = src0\n\t\top.Images[1] = src1\n\t\tdst.DrawTrianglesShader(vs, is, s, op)\n\t\ttestPixels(\"DrawTrianglesShader\", dst)\n\t})\n}\n\n// Issue #2186\nfunc TestShaderVectorEqual(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\ta := vec3(1)\n\tb := vec3(1)\n\tif a == b {\n\t\treturn vec4(1, 0, 0, 1)\n\t} else {\n\t\treturn vec4(0, 1, 0, 1)\n\t}\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst.DrawRectShader(w, h, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0xff, A: 0xff}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #1969\nfunc TestShaderDiscard(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\tdst.Fill(color.RGBA{R: 0xff, A: 0xff})\n\n\tsrc := ebiten.NewImage(w, h)\n\tpix := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tif i >= w/2 || j >= h/2 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpix[4*(j*w+i)+3] = 0xff\n\t\t}\n\t}\n\tsrc.WritePixels(pix)\n\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\tp := imageSrc0At(srcPos)\n\tif p.a == 0 {\n\t\tdiscard()\n\t} else {\n\t\treturn vec4(0, 1, 0, 1)\n\t}\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Images[0] = src\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{G: 0xff, A: 0xff}\n\t\t\tif i >= w/2 || j >= h/2 {\n\t\t\t\twant = color.RGBA{R: 0xff, A: 0xff}\n\t\t\t}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #2245, #2247\nfunc TestShaderDrawRect(t *testing.T) {\n\tconst (\n\t\tdstW = 16\n\t\tdstH = 16\n\t\tsrcW = 8\n\t\tsrcH = 8\n\t)\n\n\tdst := ebiten.NewImage(dstW, dstH)\n\tsrc := ebiten.NewImage(srcW, srcH)\n\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\t// Adjust srcPos into [0, 1].\n\tsrcPos -= imageSrc0Origin()\n\tsrcPos /= imageSrc0Size()\n\tif srcPos.x >= 0.5 && srcPos.y >= 0.5 {\n\t\treturn vec4(1, 0, 0, 1)\n\t}\n\treturn vec4(0, 1, 0, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tconst (\n\t\toffsetX = (dstW - srcW) / 2\n\t\toffsetY = (dstH - srcH) / 2\n\t)\n\top := &ebiten.DrawRectShaderOptions{}\n\top.GeoM.Translate(offsetX, offsetY)\n\top.Images[0] = src\n\tdst.DrawRectShader(srcW, srcH, s, op)\n\tfor j := 0; j < dstH; j++ {\n\t\tfor i := 0; i < dstW; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\tvar want color.RGBA\n\t\t\tif offsetX <= i && i < offsetX+srcW && offsetY <= j && j < offsetY+srcH {\n\t\t\t\tif offsetX+srcW/2 <= i && offsetY+srcH/2 <= j {\n\t\t\t\t\twant = color.RGBA{R: 0xff, A: 0xff}\n\t\t\t\t} else {\n\t\t\t\t\twant = color.RGBA{G: 0xff, A: 0xff}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderDrawRectColorScale(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn color\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.ColorScale.SetR(4.0 / 8.0)\n\top.ColorScale.SetG(5.0 / 8.0)\n\top.ColorScale.SetB(6.0 / 8.0)\n\top.ColorScale.SetA(7.0 / 8.0)\n\top.ColorScale.ScaleWithColor(color.RGBA{R: 0x40, G: 0x80, B: 0xc0, A: 0xff})\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0x20, G: 0x50, B: 0x90, A: 0xe0}\n\t\t\tif !sameColors(got, want, 1) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderUniformInt(t *testing.T) {\n\tconst ints = `//kage:unit pixels\n\npackage main\n\nvar U0 int\nvar U1 int\nvar U2 int\nvar U3 int\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(float(U0)/255.0, float(U1)/255.0, float(U2)/255.0, float(U3)/255.0)\n}\n`\n\n\tconst intArray = `//kage:unit pixels\n\npackage main\n\nvar U [4]int\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(float(U[0])/255.0, float(U[1])/255.0, float(U[2])/255.0, float(U[3])/255.0)\n}\n`\n\n\tconst intVec = `//kage:unit pixels\n\npackage main\n\nvar U0 ivec4\nvar U1 [2]ivec3\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(float(U0.x)/255.0, float(U0.y)/255.0, float(U1[0].z)/255.0, float(U1[1].x)/255.0)\n}\n`\n\n\ttestCases := []struct {\n\t\tName     string\n\t\tUniforms map[string]any\n\t\tShader   string\n\t\tWant     color.RGBA\n\t}{\n\t\t{\n\t\t\tName: \"0xff\",\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"U0\": 0xff,\n\t\t\t\t\"U1\": 0xff,\n\t\t\t\t\"U2\": 0xff,\n\t\t\t\t\"U3\": 0xff,\n\t\t\t},\n\t\t\tShader: ints,\n\t\t\tWant:   color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff},\n\t\t},\n\t\t{\n\t\t\tName: \"int\",\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"U0\": int8(0x24),\n\t\t\t\t\"U1\": int16(0x3f),\n\t\t\t\t\"U2\": int32(0x6a),\n\t\t\t\t\"U3\": int64(0x88),\n\t\t\t},\n\t\t\tShader: ints,\n\t\t\tWant:   color.RGBA{R: 0x24, G: 0x3f, B: 0x6a, A: 0x88},\n\t\t},\n\t\t{\n\t\t\tName: \"uint\",\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"U0\": uint8(0x85),\n\t\t\t\t\"U1\": uint16(0xa3),\n\t\t\t\t\"U2\": uint32(0x08),\n\t\t\t\t\"U3\": uint64(0xd3),\n\t\t\t},\n\t\t\tShader: ints,\n\t\t\tWant:   color.RGBA{R: 0x85, G: 0xa3, B: 0x08, A: 0xd3},\n\t\t},\n\t\t{\n\t\t\tName: \"0xff,slice\",\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"U\": []int{0xff, 0xff, 0xff, 0xff},\n\t\t\t},\n\t\t\tShader: intArray,\n\t\t\tWant:   color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff},\n\t\t},\n\t\t{\n\t\t\tName: \"int,slice\",\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"U\": []int16{0x24, 0x3f, 0x6a, 0x88},\n\t\t\t},\n\t\t\tShader: intArray,\n\t\t\tWant:   color.RGBA{R: 0x24, G: 0x3f, B: 0x6a, A: 0x88},\n\t\t},\n\t\t{\n\t\t\tName: \"uint,slice\",\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"U\": []uint8{0x85, 0xa3, 0x08, 0xd3},\n\t\t\t},\n\t\t\tShader: intArray,\n\t\t\tWant:   color.RGBA{R: 0x85, G: 0xa3, B: 0x08, A: 0xd3},\n\t\t},\n\t\t{\n\t\t\tName: \"0xff,array\",\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"U\": [...]int{0xff, 0xff, 0xff, 0xff},\n\t\t\t},\n\t\t\tShader: intArray,\n\t\t\tWant:   color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff},\n\t\t},\n\t\t{\n\t\t\tName: \"int,array\",\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"U\": [...]int16{0x24, 0x3f, 0x6a, 0x88},\n\t\t\t},\n\t\t\tShader: intArray,\n\t\t\tWant:   color.RGBA{R: 0x24, G: 0x3f, B: 0x6a, A: 0x88},\n\t\t},\n\t\t{\n\t\t\tName: \"uint,array\",\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"U\": [...]uint8{0x85, 0xa3, 0x08, 0xd3},\n\t\t\t},\n\t\t\tShader: intArray,\n\t\t\tWant:   color.RGBA{R: 0x85, G: 0xa3, B: 0x08, A: 0xd3},\n\t\t},\n\t\t{\n\t\t\tName: \"0xff,array\",\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"U\": [...]int{0xff, 0xff, 0xff, 0xff},\n\t\t\t},\n\t\t\tShader: intArray,\n\t\t\tWant:   color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff},\n\t\t},\n\t\t{\n\t\t\tName: \"int,array\",\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"U\": [...]int16{0x24, 0x3f, 0x6a, 0x88},\n\t\t\t},\n\t\t\tShader: intArray,\n\t\t\tWant:   color.RGBA{R: 0x24, G: 0x3f, B: 0x6a, A: 0x88},\n\t\t},\n\t\t{\n\t\t\tName: \"uint,array\",\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"U\": [...]uint8{0x85, 0xa3, 0x08, 0xd3},\n\t\t\t},\n\t\t\tShader: intArray,\n\t\t\tWant:   color.RGBA{R: 0x85, G: 0xa3, B: 0x08, A: 0xd3},\n\t\t},\n\t\t{\n\t\t\tName: \"0xff,ivec\",\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"U0\": [...]int{0xff, 0xff, 0xff, 0xff},\n\t\t\t\t\"U1\": [...]int{0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n\t\t\t},\n\t\t\tShader: intVec,\n\t\t\tWant:   color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff},\n\t\t},\n\t\t{\n\t\t\tName: \"int,ivec\",\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"U0\": [...]int16{0x24, 0x3f, 0x6a, 0x88},\n\t\t\t\t\"U1\": [...]int16{0x85, 0xa3, 0x08, 0xd3, 0x13, 0x19},\n\t\t\t},\n\t\t\tShader: intVec,\n\t\t\tWant:   color.RGBA{R: 0x24, G: 0x3f, B: 0x08, A: 0xd3},\n\t\t},\n\t\t{\n\t\t\tName: \"uint,ivec\",\n\t\t\tUniforms: map[string]any{\n\t\t\t\t\"U0\": [...]uint8{0x24, 0x3f, 0x6a, 0x88},\n\t\t\t\t\"U1\": [...]uint8{0x85, 0xa3, 0x08, 0xd3, 0x13, 0x19},\n\t\t\t},\n\t\t\tShader: intVec,\n\t\t\tWant:   color.RGBA{R: 0x24, G: 0x3f, B: 0x08, A: 0xd3},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\tconst w, h = 1, 1\n\n\t\t\tdst := ebiten.NewImage(w, h)\n\t\t\tdefer dst.Deallocate()\n\n\t\t\ts, err := ebiten.NewShader([]byte(tc.Shader))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdefer s.Deallocate()\n\n\t\t\top := &ebiten.DrawRectShaderOptions{}\n\t\t\top.Uniforms = tc.Uniforms\n\t\t\tdst.DrawRectShader(w, h, s, op)\n\t\t\tif got, want := dst.At(0, 0).(color.RGBA), tc.Want; !sameColors(got, want, 1) {\n\t\t\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Issue #2463\nfunc TestShaderUniformVec3Array(t *testing.T) {\n\tconst shader = `//kage:unit pixels\n\npackage main\n\nvar U [4]vec3\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(U[0].x/255.0, U[1].y/255.0, U[2].z/255.0, U[3].x/255.0)\n}\n`\n\tconst w, h = 1, 1\n\n\tdst := ebiten.NewImage(w, h)\n\tdefer dst.Deallocate()\n\n\ts, err := ebiten.NewShader([]byte(shader))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer s.Deallocate()\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Uniforms = map[string]any{\n\t\t\"U\": []float32{\n\t\t\t0x24, 0x3f, 0x6a,\n\t\t\t0x88, 0x85, 0xa3,\n\t\t\t0x08, 0xd3, 0x13,\n\t\t\t0x19, 0x8a, 0x2e,\n\t\t},\n\t}\n\tdst.DrawRectShader(w, h, s, op)\n\tif got, want := dst.At(0, 0).(color.RGBA), (color.RGBA{R: 0x24, G: 0x85, B: 0x13, A: 0x19}); !sameColors(got, want, 1) {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n}\n\nfunc TestShaderIVecMod(t *testing.T) {\n\tcases := []struct {\n\t\tsource string\n\t\twant   color.RGBA\n\t}{\n\t\t{\n\t\t\tsource: `a := ivec4(0x24, 0x3f, 0x6a, 0x88)\nreturn vec4(a)/255`,\n\t\t\twant: color.RGBA{R: 0x24, G: 0x3f, B: 0x6a, A: 0x88},\n\t\t},\n\t\t{\n\t\t\tsource: `a := ivec4(0x24, 0x3f, 0x6a, 0x88)\na %= 0x85\nreturn vec4(a)/255`,\n\t\t\twant: color.RGBA{R: 0x24, G: 0x3f, B: 0x6a, A: 0x03},\n\t\t},\n\t\t{\n\t\t\tsource: `a := ivec4(0x24, 0x3f, 0x6a, 0x88)\na %= ivec4(0x85, 0xa3, 0x08, 0xd3)\nreturn vec4(a)/255`,\n\t\t\twant: color.RGBA{R: 0x24, G: 0x3f, B: 0x02, A: 0x88},\n\t\t},\n\t\t{\n\t\t\tsource: `a := ivec4(0x24, 0x3f, 0x6a, 0x88)\nb := a % 0x85\nreturn vec4(b)/255`,\n\t\t\twant: color.RGBA{R: 0x24, G: 0x3f, B: 0x6a, A: 0x03},\n\t\t},\n\t\t{\n\t\t\tsource: `a := ivec4(0x24, 0x3f, 0x6a, 0x88)\nb := a % ivec4(0x85, 0xa3, 0x08, 0xd3)\nreturn vec4(b)/255`,\n\t\t\twant: color.RGBA{R: 0x24, G: 0x3f, B: 0x02, A: 0x88},\n\t\t},\n\t}\n\n\tfor _, tc := range cases {\n\t\tshader := fmt.Sprintf(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\t%s\n}\n`, tc.source)\n\t\tconst w, h = 1, 1\n\n\t\tdst := ebiten.NewImage(w, h)\n\t\tdefer dst.Deallocate()\n\n\t\ts, err := ebiten.NewShader([]byte(shader))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer s.Deallocate()\n\n\t\top := &ebiten.DrawRectShaderOptions{}\n\t\tdst.DrawRectShader(w, h, s, op)\n\t\tif got, want := dst.At(0, 0).(color.RGBA), tc.want; !sameColors(got, want, 1) {\n\t\t\tt.Errorf(\"%s: got: %v, want: %v\", tc.source, got, want)\n\t\t}\n\t}\n}\n\nfunc TestShaderTexelAndPixel(t *testing.T) {\n\tconst dstW, dstH = 13, 17\n\tconst srcW, srcH = 19, 23\n\tdstTexel := ebiten.NewImage(dstW, dstH)\n\tdstPixel := ebiten.NewImage(dstW, dstH)\n\tsrc := ebiten.NewImage(srcW, srcH)\n\n\tshaderTexel, err := ebiten.NewShader([]byte(fmt.Sprintf(`//kage:unit texels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\tpos := (srcPos - imageSrc0Origin()) / imageSrc0Size()\n\tpos *= vec2(%d, %d)\n\tpos /= 255\n\treturn vec4(pos.x, pos.y, 0, 1)\n}\n`, srcW, srcH)))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tshaderPixel, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\tpos := srcPos - imageSrc0Origin()\n\tpos /= 255\n\treturn vec4(pos.x, pos.y, 0, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Images[0] = src\n\tdstTexel.DrawRectShader(src.Bounds().Dx(), src.Bounds().Dy(), shaderTexel, op)\n\tdstPixel.DrawRectShader(src.Bounds().Dx(), src.Bounds().Dy(), shaderPixel, op)\n\n\tfor j := 0; j < dstH; j++ {\n\t\tfor i := 0; i < dstW; i++ {\n\t\t\tc0 := dstTexel.At(i, j).(color.RGBA)\n\t\t\tc1 := dstPixel.At(i, j).(color.RGBA)\n\t\t\tif !sameColors(c0, c1, 1) {\n\t\t\t\tt.Errorf(\"dstTexel.At(%d, %d) %v != dstPixel.At(%d, %d) %v\", i, j, c0, i, j, c1)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderDifferentTextureSizes(t *testing.T) {\n\tsrc0 := ebiten.NewImageWithOptions(image.Rect(0, 0, 20, 4000), &ebiten.NewImageOptions{\n\t\tUnmanaged: true,\n\t}).SubImage(image.Rect(4, 1025, 6, 1028)).(*ebiten.Image)\n\tdefer src0.Deallocate()\n\n\tsrc1 := ebiten.NewImageWithOptions(image.Rect(0, 0, 4000, 20), &ebiten.NewImageOptions{\n\t\tUnmanaged: true,\n\t}).SubImage(image.Rect(2047, 7, 2049, 10)).(*ebiten.Image)\n\tdefer src1.Deallocate()\n\n\tsrc0.Fill(color.RGBA{0x10, 0x20, 0x30, 0xff})\n\tsrc1.Fill(color.RGBA{0x30, 0x20, 0x10, 0xff})\n\n\tfor _, unit := range []string{\"texels\", \"pixels\"} {\n\t\tunit := unit\n\t\tt.Run(fmt.Sprintf(\"unit %s\", unit), func(t *testing.T) {\n\t\t\tshader, err := ebiten.NewShader([]byte(fmt.Sprintf(`//kage:unit %s\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn imageSrc0At(srcPos) + imageSrc1At(srcPos)\n}\n`, unit)))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdefer shader.Deallocate()\n\n\t\t\tdst := ebiten.NewImage(2, 3)\n\t\t\tdefer dst.Deallocate()\n\n\t\t\top := &ebiten.DrawRectShaderOptions{}\n\t\t\top.Images[0] = src0\n\t\t\top.Images[1] = src1\n\t\t\tdst.DrawRectShader(2, 3, shader, op)\n\n\t\t\tfor j := 0; j < 3; j++ {\n\t\t\t\tfor i := 0; i < 2; i++ {\n\t\t\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\t\t\twant := color.RGBA{0x40, 0x40, 0x40, 0xff}\n\t\t\t\t\tif !sameColors(got, want, 1) {\n\t\t\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestShaderIVec(t *testing.T) {\n\tconst w, h = 16, 16\n\tdst := ebiten.NewImage(w, h)\n\tsrc := ebiten.NewImage(w, h)\n\n\tpix := make([]byte, 4*w*h)\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tpix[4*(j*w+i)] = byte(i)\n\t\t\tpix[4*(j*w+i)+1] = byte(j)\n\t\t\tpix[4*(j*w+i)+3] = 0xff\n\t\t}\n\t}\n\tsrc.WritePixels(pix)\n\n\t// Test that ivec2 can take any float values that can be casted to integers.\n\t// This seems the common behavior in shading languages like GLSL, Metal, and HLSL.\n\tshader, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\tpos := ivec2(3, 4)\n\treturn imageSrc0At(vec2(pos) + imageSrc0Origin())\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Images[0] = src\n\tdst.DrawRectShader(w, h, shader, op)\n\n\tgot := dst.At(0, 0).(color.RGBA)\n\twant := color.RGBA{3, 4, 0, 0xff}\n\tif got != want {\n\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t}\n}\n\nfunc TestShaderUniformSizes(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nvar U vec4\nvar V [3]float\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(0)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttests := []struct {\n\t\tuniforms map[string]any\n\t\terr      bool\n\t}{\n\t\t{\n\t\t\tuniforms: nil,\n\t\t\terr:      false,\n\t\t},\n\t\t{\n\t\t\tuniforms: map[string]any{\n\t\t\t\t\"U\": 1,\n\t\t\t},\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tuniforms: map[string]any{\n\t\t\t\t\"U\": \"1\",\n\t\t\t},\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tuniforms: map[string]any{\n\t\t\t\t\"U\": []int32{1, 2, 3},\n\t\t\t},\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tuniforms: map[string]any{\n\t\t\t\t\"U\": []int32{1, 2, 3, 4},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tuniforms: map[string]any{\n\t\t\t\t\"U\": []int32{1, 2, 3, 4, 5},\n\t\t\t},\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tuniforms: map[string]any{\n\t\t\t\t\"V\": 1,\n\t\t\t},\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tuniforms: map[string]any{\n\t\t\t\t\"V\": \"1\",\n\t\t\t},\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tuniforms: map[string]any{\n\t\t\t\t\"V\": []int32{1, 2},\n\t\t\t},\n\t\t\terr: true,\n\t\t},\n\t\t{\n\t\t\tuniforms: map[string]any{\n\t\t\t\t\"V\": []int32{1, 2, 3},\n\t\t\t},\n\t\t\terr: false,\n\t\t},\n\t\t{\n\t\t\tuniforms: map[string]any{\n\t\t\t\t\"V\": []int32{1, 2, 3, 4},\n\t\t\t},\n\t\t\terr: true,\n\t\t},\n\t}\n\tfor _, tc := range tests {\n\t\ttc := tc\n\t\tt.Run(fmt.Sprintf(\"%v\", tc.uniforms), func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tr := recover()\n\t\t\t\tif r != nil && !tc.err {\n\t\t\t\t\tt.Errorf(\"DrawRectShader must not panic but did\")\n\t\t\t\t} else if r == nil && tc.err {\n\t\t\t\t\tt.Errorf(\"DrawRectShader must panic but does not\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\top := &ebiten.DrawRectShaderOptions{}\n\t\t\top.Uniforms = tc.uniforms\n\t\t\tdst.DrawRectShader(w, h, s, op)\n\t\t})\n\t}\n}\n\n// Issue #2709\nfunc TestShaderUniformDefaultValue(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nvar U vec4\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn U\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Draw with a uniform variable value.\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Uniforms = map[string]any{\n\t\t\"U\": [...]float32{1, 1, 1, 1},\n\t}\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{0xff, 0xff, 0xff, 0xff}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Draw without a uniform variable value. In this case, the uniform variable value should be 0.\n\tdst.Clear()\n\top.Uniforms = nil\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{0, 0, 0, 0}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #2166\nfunc TestShaderDrawRectWithoutSource(t *testing.T) {\n\tconst (\n\t\tdstW = 16\n\t\tdstH = 16\n\t\tsrcW = 8\n\t\tsrcH = 8\n\t)\n\n\tsrc := ebiten.NewImage(srcW, srcH)\n\n\tfor _, unit := range []string{\"pixels\", \"texels\"} {\n\t\ts, err := ebiten.NewShader([]byte(fmt.Sprintf(`//kage:unit %s\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\tt := srcPos\n\n\tsize := imageSrc0Size()\n\n\t// If the unit is texels and no source images are specified, size is always 0.\n\tif size == vec2(0) {\n\t\t// Even in this case, t is in pixels (0, 0) to (8, 8).\n\t\tif t.x >= 4 && t.y >= 4 {\n\t\t\treturn vec4(1, 0, 1, 1)\n\t\t}\n\t\treturn vec4(0, 1, 1, 1)\n\t}\n\n\t// Adjust srcPos into [0, 1].\n\tt -= imageSrc0Origin()\n\tif size != vec2(0) {\n\t\tt /= size\n\t}\n\tif t.x >= 0.5 && t.y >= 0.5 {\n\t\treturn vec4(1, 0, 0, 1)\n\t}\n\treturn vec4(0, 1, 0, 1)\n}\n`, unit)))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tfor _, withSrc := range []bool{false, true} {\n\t\t\twithSrc := withSrc\n\t\t\ttitle := \"WithSrc,unit=\" + unit\n\t\t\tif !withSrc {\n\t\t\t\ttitle = \"WithoutSrc,unit=\" + unit\n\t\t\t}\n\t\t\tt.Run(title, func(t *testing.T) {\n\t\t\t\tdst := ebiten.NewImage(dstW, dstH)\n\t\t\t\tconst (\n\t\t\t\t\toffsetX = (dstW - srcW) / 2\n\t\t\t\t\toffsetY = (dstH - srcH) / 2\n\t\t\t\t)\n\t\t\t\top := &ebiten.DrawRectShaderOptions{}\n\t\t\t\top.GeoM.Translate(offsetX, offsetY)\n\t\t\t\tif withSrc {\n\t\t\t\t\top.Images[0] = src\n\t\t\t\t}\n\t\t\t\tdst.DrawRectShader(srcW, srcH, s, op)\n\t\t\t\tfor j := 0; j < dstH; j++ {\n\t\t\t\t\tfor i := 0; i < dstW; i++ {\n\t\t\t\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\t\t\t\tvar want color.RGBA\n\t\t\t\t\t\tif offsetX <= i && i < offsetX+srcW && offsetY <= j && j < offsetY+srcH {\n\t\t\t\t\t\t\tvar blue byte\n\t\t\t\t\t\t\tif !withSrc && unit == \"texels\" {\n\t\t\t\t\t\t\t\tblue = 0xff\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif offsetX+srcW/2 <= i && offsetY+srcH/2 <= j {\n\t\t\t\t\t\t\t\twant = color.RGBA{0xff, 0, blue, 0xff}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twant = color.RGBA{0, 0xff, blue, 0xff}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif got != want {\n\t\t\t\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n}\n\n// Issue #2719\nfunc TestShaderMatrixDivFloat(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tsrc := ebiten.NewImage(w, h)\n\tsrc.Fill(color.RGBA{R: 0x10, G: 0x20, B: 0x30, A: 0xff})\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\tvar x = 2.0\n\treturn mat4(3) / x * imageSrc0At(srcPos);\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\top := &ebiten.DrawRectShaderOptions{}\n\top.Images[0] = src\n\tdst.DrawRectShader(w, h, s, op)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0x18, G: 0x30, B: 0x48, A: 0xff}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderDifferentSourceSizes(t *testing.T) {\n\tsrc0 := ebiten.NewImageWithOptions(image.Rect(0, 0, 20, 4000), &ebiten.NewImageOptions{\n\t\tUnmanaged: true,\n\t}).SubImage(image.Rect(4, 1025, 7, 1029)).(*ebiten.Image) // 3x4\n\tdefer src0.Deallocate()\n\n\tsrc1 := ebiten.NewImageWithOptions(image.Rect(0, 0, 4000, 20), &ebiten.NewImageOptions{\n\t\tUnmanaged: true,\n\t}).SubImage(image.Rect(2047, 7, 2049, 10)).(*ebiten.Image) // 2x3\n\tdefer src1.Deallocate()\n\n\tsrc0.Fill(color.RGBA{0x10, 0x20, 0x30, 0xff})\n\tsrc1.Fill(color.RGBA{0x30, 0x20, 0x10, 0xff})\n\n\tfor _, unit := range []string{\"texels\", \"pixels\"} {\n\t\tunit := unit\n\t\tt.Run(fmt.Sprintf(\"unit %s\", unit), func(t *testing.T) {\n\t\t\tif unit == \"texels\" {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"DrawTrianglesShader must panic with different sizes but not (unit=%s)\", unit)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\t\t\tshader, err := ebiten.NewShader([]byte(fmt.Sprintf(`//kage:unit %s\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn imageSrc0At(srcPos) + imageSrc1At(srcPos)\n}\n`, unit)))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdefer shader.Deallocate()\n\n\t\t\tdst := ebiten.NewImage(3, 4)\n\t\t\tdefer dst.Deallocate()\n\n\t\t\top := &ebiten.DrawTrianglesShaderOptions{}\n\t\t\top.Images[0] = src0\n\t\t\top.Images[1] = src1\n\t\t\tvs := []ebiten.Vertex{\n\t\t\t\t{\n\t\t\t\t\tDstX:   0,\n\t\t\t\t\tDstY:   0,\n\t\t\t\t\tSrcX:   4,\n\t\t\t\t\tSrcY:   1025,\n\t\t\t\t\tColorR: 1,\n\t\t\t\t\tColorG: 1,\n\t\t\t\t\tColorB: 1,\n\t\t\t\t\tColorA: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tDstX:   3,\n\t\t\t\t\tDstY:   0,\n\t\t\t\t\tSrcX:   7,\n\t\t\t\t\tSrcY:   1025,\n\t\t\t\t\tColorR: 1,\n\t\t\t\t\tColorG: 1,\n\t\t\t\t\tColorB: 1,\n\t\t\t\t\tColorA: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tDstX:   0,\n\t\t\t\t\tDstY:   4,\n\t\t\t\t\tSrcX:   4,\n\t\t\t\t\tSrcY:   1029,\n\t\t\t\t\tColorR: 1,\n\t\t\t\t\tColorG: 1,\n\t\t\t\t\tColorB: 1,\n\t\t\t\t\tColorA: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tDstX:   3,\n\t\t\t\t\tDstY:   4,\n\t\t\t\t\tSrcX:   7,\n\t\t\t\t\tSrcY:   1029,\n\t\t\t\t\tColorR: 1,\n\t\t\t\t\tColorG: 1,\n\t\t\t\t\tColorB: 1,\n\t\t\t\t\tColorA: 1,\n\t\t\t\t},\n\t\t\t}\n\t\t\tis := []uint16{0, 1, 2, 1, 2, 3}\n\t\t\tdst.DrawTrianglesShader(vs, is, shader, op)\n\n\t\t\tif unit == \"texel\" {\n\t\t\t\tt.Fatal(\"not reached\")\n\t\t\t}\n\n\t\t\tfor j := 0; j < 4; j++ {\n\t\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\t\t\tvar want color.RGBA\n\t\t\t\t\tif i < 2 && j < 3 {\n\t\t\t\t\t\twant = color.RGBA{0x40, 0x40, 0x40, 0xff}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twant = color.RGBA{0x10, 0x20, 0x30, 0xff}\n\t\t\t\t\t}\n\t\t\t\t\tif !sameColors(got, want, 1) {\n\t\t\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Issue #2752\nfunc TestShaderBitwiseOperator(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tsrc := ebiten.NewImage(w, h)\n\tsrc.Fill(color.RGBA{R: 0x24, G: 0x3f, B: 0x6a, A: 0xff})\n\n\tfor _, assign := range []bool{false, true} {\n\t\tassign := assign\n\t\tname := \"op\"\n\t\tif assign {\n\t\t\tname = \"op+assign\"\n\t\t}\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tvar code string\n\t\t\tif assign {\n\t\t\t\tcode = `\tv.rgb &= 0x5a\n\tv.rgb |= 0x30\n\tv.rgb ^= 0x8d`\n\t\t\t} else {\n\t\t\t\tcode = `\tv.rgb = v.rgb & 0x5a\n\tv.rgb = v.rgb | 0x30\n\tv.rgb = v.rgb ^ 0x8d`\n\t\t\t}\n\n\t\t\ts, err := ebiten.NewShader([]byte(fmt.Sprintf(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\tv := ivec4(imageSrc0At(srcPos) * 0xff)\n%s\n\treturn vec4(v) / 0xff;\n}\n`, code)))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tdst := ebiten.NewImage(w, h)\n\t\t\top := &ebiten.DrawRectShaderOptions{}\n\t\t\top.Images[0] = src\n\t\t\tdst.DrawRectShader(w, h, s, op)\n\n\t\t\tfor j := 0; j < h; j++ {\n\t\t\t\tfor i := 0; i < w; i++ {\n\t\t\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\t\t\twant := color.RGBA{R: 0xbd, G: 0xb7, B: 0xf7, A: 0xff}\n\t\t\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestShaderDispose(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(1, 0, 0, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst.DrawRectShader(w/2, h/2, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\tvar want color.RGBA\n\t\t\tif i < w/2 && j < h/2 {\n\t\t\t\twant = color.RGBA{R: 0xff, A: 0xff}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\ts.Dispose()\n\n\tdst.Clear()\n\n\tdefer func() {\n\t\tif e := recover(); e == nil {\n\t\t\tpanic(\"DrawRectShader with a disposed shader must panic but not\")\n\t\t}\n\t}()\n\n\tdst.DrawRectShader(w/2, h/2, s, nil)\n}\n\nfunc TestShaderDeallocate(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(1, 0, 0, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst.DrawRectShader(w/2, h/2, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\tvar want color.RGBA\n\t\t\tif i < w/2 && j < h/2 {\n\t\t\t\twant = color.RGBA{R: 0xff, A: 0xff}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Even after Deallocate is called, the shader is still available.\n\ts.Deallocate()\n\n\tdst.Clear()\n\tdst.DrawRectShader(w/2, h/2, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\tvar want color.RGBA\n\t\t\tif i < w/2 && j < h/2 {\n\t\t\t\twant = color.RGBA{R: 0xff, A: 0xff}\n\t\t\t}\n\t\t\tif got != want {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #2923\nfunc TestShaderReturnArray(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc foo() [4]float {\n\treturn [4]float{0.25, 0.5, 0.75, 1}\n}\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\ta := foo()\n\treturn vec4(a[0], a[1], a[2], a[3])\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst.DrawRectShader(w, h, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0x40, G: 0x80, B: 0xc0, A: 0xff}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #2798\nfunc TestShaderInvalidPremultipliedAlphaColor(t *testing.T) {\n\t// This test checks the rendering result when the shader returns an invalid premultiplied alpha color.\n\t// The result values are kept and not clamped.\n\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(1, 0.75, 0.5, 0.25)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst.DrawRectShader(w, h, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0xff, G: 0xc0, B: 0x80, A: 0x40}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\tdst.Clear()\n\ts, err = ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\treturn vec4(1, 0.75, 0.5, 0)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst.DrawRectShader(w, h, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0xff, G: 0xc0, B: 0x80, A: 0}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #2933\nfunc TestShaderIncDecStmt(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\ta := 0\n\ta++\n\tb := -0.5\n\tb++\n\tc := ivec2(0)\n\tc++\n\td := vec2(-0.25)\n\td++\n\treturn vec4(float(a), b, float(c.x), d.y)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst.DrawRectShader(w, h, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0xff, G: 0x80, B: 0xff, A: 0xc0}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n\n\tdst.Clear()\n\n\ts, err = ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\ta := 1\n\ta--\n\tb := 1.5\n\tb--\n\tc := ivec2(1)\n\tc--\n\td := vec2(1.25)\n\td--\n\treturn vec4(float(a), b, float(c.x), d.y)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst.DrawRectShader(w, h, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0x00, G: 0x80, B: 0x00, A: 0x40}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Issue #2934\nfunc TestShaderAssignConst(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\ta := 0.0\n\ta = 1\n\tb, c := 0.0, 0.0\n\tb, c = 1, 1\n\td := 0.0\n\td += 1\n\treturn vec4(a, b, c, d)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst.DrawRectShader(w, h, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0xff, G: 0xff, B: 0xff, A: 0xff}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderCustomValues(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4, custom vec4) vec4 {\n\treturn custom\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tclr := color.RGBA{R: 0x10, G: 0x20, B: 0x30, A: 0x40}\n\tdst.DrawTrianglesShader([]ebiten.Vertex{\n\t\t{\n\t\t\tDstX:    0,\n\t\t\tDstY:    0,\n\t\t\tSrcX:    0,\n\t\t\tSrcY:    0,\n\t\t\tColorR:  1,\n\t\t\tColorG:  1,\n\t\t\tColorB:  1,\n\t\t\tColorA:  1,\n\t\t\tCustom0: float32(clr.R) / 0xff,\n\t\t\tCustom1: float32(clr.G) / 0xff,\n\t\t\tCustom2: float32(clr.B) / 0xff,\n\t\t\tCustom3: float32(clr.A) / 0xff,\n\t\t},\n\t\t{\n\t\t\tDstX:    w,\n\t\t\tDstY:    0,\n\t\t\tSrcX:    w,\n\t\t\tSrcY:    0,\n\t\t\tColorR:  1,\n\t\t\tColorG:  1,\n\t\t\tColorB:  1,\n\t\t\tColorA:  1,\n\t\t\tCustom0: float32(clr.R) / 0xff,\n\t\t\tCustom1: float32(clr.G) / 0xff,\n\t\t\tCustom2: float32(clr.B) / 0xff,\n\t\t\tCustom3: float32(clr.A) / 0xff,\n\t\t},\n\t\t{\n\t\t\tDstX:    0,\n\t\t\tDstY:    h,\n\t\t\tSrcX:    0,\n\t\t\tSrcY:    h,\n\t\t\tColorR:  1,\n\t\t\tColorG:  1,\n\t\t\tColorB:  1,\n\t\t\tColorA:  1,\n\t\t\tCustom0: float32(clr.R) / 0xff,\n\t\t\tCustom1: float32(clr.G) / 0xff,\n\t\t\tCustom2: float32(clr.B) / 0xff,\n\t\t\tCustom3: float32(clr.A) / 0xff,\n\t\t},\n\t\t{\n\t\t\tDstX:    w,\n\t\t\tDstY:    h,\n\t\t\tSrcX:    w,\n\t\t\tSrcY:    h,\n\t\t\tColorR:  1,\n\t\t\tColorG:  1,\n\t\t\tColorB:  1,\n\t\t\tColorA:  1,\n\t\t\tCustom0: float32(clr.R) / 0xff,\n\t\t\tCustom1: float32(clr.G) / 0xff,\n\t\t\tCustom2: float32(clr.B) / 0xff,\n\t\t\tCustom3: float32(clr.A) / 0xff,\n\t\t},\n\t}, []uint16{0, 1, 2, 1, 2, 3}, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := clr\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderFragmentLessArguments(t *testing.T) {\n\tconst w, h = 16, 16\n\n\ts0, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment() vec4 {\n\treturn vec4(1, 0, 0, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts1, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4) vec4 {\n\treturn vec4(0, 1, 0, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts2, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2) vec4 {\n\treturn vec4(0, 0, 1, 1)\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst := ebiten.NewImage(w, h)\n\tfor idx, s := range []*ebiten.Shader{s0, s1, s2} {\n\t\tdst.Clear()\n\t\tdst.DrawTrianglesShader([]ebiten.Vertex{\n\t\t\t{\n\t\t\t\tDstX:   0,\n\t\t\t\tDstY:   0,\n\t\t\t\tSrcX:   0,\n\t\t\t\tSrcY:   0,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tDstX:   w,\n\t\t\t\tDstY:   0,\n\t\t\t\tSrcX:   w,\n\t\t\t\tSrcY:   0,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tDstX:   0,\n\t\t\t\tDstY:   h,\n\t\t\t\tSrcX:   0,\n\t\t\t\tSrcY:   h,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tDstX:   w,\n\t\t\t\tDstY:   h,\n\t\t\t\tSrcX:   w,\n\t\t\t\tSrcY:   h,\n\t\t\t\tColorR: 1,\n\t\t\t\tColorG: 1,\n\t\t\t\tColorB: 1,\n\t\t\t\tColorA: 1,\n\t\t\t},\n\t\t}, []uint16{0, 1, 2, 1, 2, 3}, s, nil)\n\n\t\tfor j := 0; j < h; j++ {\n\t\t\tfor i := 0; i < w; i++ {\n\t\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\t\tvar want color.RGBA\n\t\t\t\tswitch idx {\n\t\t\t\tcase 0:\n\t\t\t\t\twant = color.RGBA{R: 0xff, A: 0xff}\n\t\t\t\tcase 1:\n\t\t\t\t\twant = color.RGBA{G: 0xff, A: 0xff}\n\t\t\t\tcase 2:\n\t\t\t\t\twant = color.RGBA{B: 0xff, A: 0xff}\n\t\t\t\t}\n\t\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShaderArray(t *testing.T) {\n\tconst w, h = 16, 16\n\n\tdst := ebiten.NewImage(w, h)\n\ts, err := ebiten.NewShader([]byte(`//kage:unit pixels\n\npackage main\n\nfunc Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {\n\ta := [4]float{1}\n\tb := [4]float{1, 1}\n\tc := [4]float{1, 1, 1}\n\td := [4]float{1, 1, 1, 1}\n\treturn vec4(a[3], b[3], c[3], d[3])\n}\n`))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdst.DrawRectShader(w, h, s, nil)\n\n\tfor j := 0; j < h; j++ {\n\t\tfor i := 0; i < w; i++ {\n\t\t\tgot := dst.At(i, j).(color.RGBA)\n\t\t\twant := color.RGBA{R: 0x00, G: 0x00, B: 0x00, A: 0xff}\n\t\t\tif !sameColors(got, want, 2) {\n\t\t\t\tt.Errorf(\"dst.At(%d, %d): got: %v, want: %v\", i, j, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkBuiltinShader(b *testing.B) {\n\t// Create a shader to cache the shader compilation result.\n\t_ = ebiten.BuiltinShader(builtinshader.FilterNearest, builtinshader.AddressUnsafe, false)\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = ebiten.BuiltinShader(builtinshader.FilterNearest, builtinshader.AddressUnsafe, false)\n\t}\n}\n"
        },
        {
          "name": "text",
          "type": "tree",
          "content": null
        },
        {
          "name": "vector",
          "type": "tree",
          "content": null
        },
        {
          "name": "vibrate.go",
          "type": "blob",
          "size": 2.556640625,
          "content": "// Copyright 2021 The Ebiten Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"time\"\n\n\t\"github.com/hajimehoshi/ebiten/v2/internal/gamepad\"\n\t\"github.com/hajimehoshi/ebiten/v2/internal/vibrate\"\n)\n\n// VibrateOptions represents the options for device vibration.\ntype VibrateOptions struct {\n\t// Duration is the time duration of the effect.\n\tDuration time.Duration\n\n\t// Magnitude is the strength of the device vibration.\n\t// The value is in between 0 and 1.\n\tMagnitude float64\n}\n\n// Vibrate vibrates the device with the specified options.\n//\n// Vibrate works on mobiles and browsers.\n//\n// On browsers, Magnitude in the options is ignored.\n//\n// On Android, this line is required in the manifest setting to use Vibrate:\n//\n//\t<uses-permission android:name=\"android.permission.VIBRATE\"/>\n//\n// On Android, Magnitude in the options is recognized only when the API Level is 26 or newer.\n// Otherwise, Magnitude is ignored.\n//\n// On iOS, CoreHaptics.framework is required to use Vibrate.\n//\n// On iOS, Vibrate works only when iOS version is 13.0 or newer.\n// Otherwise, Vibrate does nothing.\n//\n// Vibrate is concurrent-safe.\nfunc Vibrate(options *VibrateOptions) {\n\tvibrate.Vibrate(options.Duration, options.Magnitude)\n}\n\n// VibrateGamepadOptions represents the options for gamepad vibration.\ntype VibrateGamepadOptions struct {\n\t// Duration is the time duration of the effect.\n\tDuration time.Duration\n\n\t// StrongMagnitude is the rumble intensity of a low-frequency rumble motor.\n\t// The value is in between 0 and 1.\n\tStrongMagnitude float64\n\n\t// WeakMagnitude is the rumble intensity of a high-frequency rumble motor.\n\t// The value is in between 0 and 1.\n\tWeakMagnitude float64\n}\n\n// VibrateGamepad vibrates the specified gamepad with the specified options.\n//\n// VibrateGamepad works only on browsers and Nintendo Switch so far.\n//\n// VibrateGamepad is concurrent-safe.\nfunc VibrateGamepad(gamepadID GamepadID, options *VibrateGamepadOptions) {\n\tg := gamepad.Get(gamepadID)\n\tif g == nil {\n\t\treturn\n\t}\n\tg.Vibrate(options.Duration, options.StrongMagnitude, options.WeakMagnitude)\n}\n"
        },
        {
          "name": "window.go",
          "type": "blob",
          "size": 12.0234375,
          "content": "// Copyright 2019 The Ebiten Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ebiten\n\nimport (\n\t\"image\"\n\t\"sync/atomic\"\n\n\t\"github.com/hajimehoshi/ebiten/v2/internal/ui\"\n)\n\n// WindowResizingModeType represents a mode in which a user resizes the window.\n//\n// Regardless of the resizing mode, an Ebitengine application can still change the window size or make\n// the window fullscreen by calling Ebitengine functions.\ntype WindowResizingModeType int\n\n// WindowResizingModeTypes\nconst (\n\t// WindowResizingModeDisabled indicates the mode to disallow resizing the window by a user.\n\tWindowResizingModeDisabled WindowResizingModeType = WindowResizingModeType(ui.WindowResizingModeDisabled)\n\n\t// WindowResizingModeOnlyFullscreenEnabled indicates the mode to disallow resizing the window,\n\t// but allow to make the window fullscreen by a user.\n\t// This works only on macOS so far.\n\t// On the other platforms, this is the same as WindowResizingModeDisabled.\n\tWindowResizingModeOnlyFullscreenEnabled WindowResizingModeType = WindowResizingModeType(ui.WindowResizingModeOnlyFullscreenEnabled)\n\n\t// WindowResizingModeEnabled indicates the mode to allow resizing the window by a user.\n\tWindowResizingModeEnabled WindowResizingModeType = WindowResizingModeType(ui.WindowResizingModeEnabled)\n)\n\n// IsWindowDecorated reports whether the window is decorated.\n//\n// IsWindowDecorated is concurrent-safe.\nfunc IsWindowDecorated() bool {\n\treturn ui.Get().Window().IsDecorated()\n}\n\n// SetWindowDecorated sets the state if the window is decorated.\n//\n// The window is decorated by default.\n//\n// SetWindowDecorated works only on desktops.\n// SetWindowDecorated does nothing if the platform is not a desktop.\n//\n// SetWindowDecorated is concurrent-safe.\nfunc SetWindowDecorated(decorated bool) {\n\tui.Get().Window().SetDecorated(decorated)\n}\n\n// WindowResizingMode returns the current mode in which a user resizes the window.\n//\n// The default mode is WindowResizingModeDisabled.\n//\n// WindowResizingMode is concurrent-safe.\nfunc WindowResizingMode() WindowResizingModeType {\n\treturn WindowResizingModeType(ui.Get().Window().ResizingMode())\n}\n\n// SetWindowResizingMode sets the mode in which a user resizes the window.\n//\n// SetWindowResizingMode is concurrent-safe.\nfunc SetWindowResizingMode(mode WindowResizingModeType) {\n\tui.Get().Window().SetResizingMode(ui.WindowResizingMode(mode))\n}\n\n// IsWindowResizable reports whether the window is resizable by the user's dragging on desktops.\n// On the other environments, IsWindowResizable always returns false.\n//\n// Deprecated: as of v2.3. Use WindowResizingMode instead.\nfunc IsWindowResizable() bool {\n\treturn ui.Get().Window().ResizingMode() == ui.WindowResizingModeEnabled\n}\n\n// SetWindowResizable sets whether the window is resizable by the user's dragging on desktops.\n// On the other environments, SetWindowResizable does nothing.\n//\n// Deprecated: as of v2.3, Use SetWindowResizingMode instead.\nfunc SetWindowResizable(resizable bool) {\n\tmode := ui.WindowResizingModeDisabled\n\tif resizable {\n\t\tmode = ui.WindowResizingModeEnabled\n\t}\n\tui.Get().Window().SetResizingMode(mode)\n}\n\n// SetWindowTitle sets the title of the window.\n//\n// SetWindowTitle does nothing if the platform is not a desktop.\n//\n// SetWindowTitle is concurrent-safe.\nfunc SetWindowTitle(title string) {\n\tui.Get().Window().SetTitle(title)\n}\n\n// SetWindowIcon sets the icon of the game window.\n//\n// If len(iconImages) is 0, SetWindowIcon reverts the icon to the default one.\n//\n// For desktops, see the document of glfwSetWindowIcon of GLFW 3.2:\n//\n//\tThis function sets the icon of the specified window.\n//\tIf passed an array of candidate images, those of or closest to the sizes\n//\tdesired by the system are selected.\n//\tIf no images are specified, the window reverts to its default icon.\n//\n//\tThe desired image sizes varies depending on platform and system settings.\n//\tThe selected images will be rescaled as needed.\n//\tGood sizes include 16x16, 32x32 and 48x48.\n//\n// As macOS windows don't have icons, SetWindowIcon doesn't work on macOS.\n//\n// SetWindowIcon doesn't work if the platform is not a desktop.\n//\n// SetWindowIcon is concurrent-safe.\nfunc SetWindowIcon(iconImages []image.Image) {\n\tui.Get().Window().SetIcon(iconImages)\n}\n\n// WindowPosition returns the window position.\n// The origin position is the upper-left corner of the current monitor.\n// The unit is device-independent pixels.\n//\n// WindowPosition panics if the main loop does not start yet.\n//\n// WindowPosition returns the original window position in fullscreen mode.\n//\n// WindowPosition returns (0, 0) if the platform is not a desktop.\n//\n// WindowPosition is concurrent-safe.\nfunc WindowPosition() (x, y int) {\n\treturn ui.Get().Window().Position()\n}\n\n// SetWindowPosition sets the window position.\n// The origin position is the upper-left corner of the current monitor.\n// The unit is device-independent pixels.\n//\n// SetWindowPosition sets the original window position in fullscreen mode.\n//\n// SetWindowPosition does nothing if the platform is not a desktop.\n//\n// SetWindowPosition is concurrent-safe.\nfunc SetWindowPosition(x, y int) {\n\twindowPositionSetExplicitly.Store(true)\n\tui.Get().Window().SetPosition(x, y)\n}\n\nvar (\n\twindowPositionSetExplicitly atomic.Bool\n)\n\nfunc initializeWindowPositionIfNeeded(width, height int) {\n\tif !windowPositionSetExplicitly.Load() {\n\t\tsw, sh := ui.Get().Monitor().Size()\n\t\tx, y := ui.InitialWindowPosition(sw, sh, width, height)\n\t\tui.Get().Window().SetPosition(x, y)\n\t}\n}\n\n// WindowSize returns the window size on desktops.\n// WindowSize returns (0, 0) on other environments.\n//\n// Even if the application is in fullscreen mode, WindowSize returns the original window size\n// If you need the fullscreen dimensions, see Monitor().Size() instead.\n//\n// WindowSize is concurrent-safe.\nfunc WindowSize() (int, int) {\n\treturn ui.Get().Window().Size()\n}\n\n// SetWindowSize sets the window size on desktops.\n// SetWindowSize does nothing on other environments.\n//\n// Even if the application is in fullscreen mode, SetWindowSize sets the original window size.\n//\n// SetWindowSize panics if width or height is not a positive number.\n//\n// SetWindowSize is concurrent-safe.\nfunc SetWindowSize(width, height int) {\n\tif width <= 0 || height <= 0 {\n\t\tpanic(\"ebiten: width and height must be positive\")\n\t}\n\tui.Get().Window().SetSize(width, height)\n}\n\n// WindowSizeLimits returns the limitation of the window size on desktops.\n// A negative value indicates the size is not limited.\n//\n// WindowSizeLimits is concurrent-safe.\nfunc WindowSizeLimits() (minw, minh, maxw, maxh int) {\n\treturn ui.Get().Window().SizeLimits()\n}\n\n// SetWindowSizeLimits sets the limitation of the window size on desktops.\n// A negative value indicates the size is not limited.\n//\n// SetWindowSizeLimits is concurrent-safe.\nfunc SetWindowSizeLimits(minw, minh, maxw, maxh int) {\n\tui.Get().Window().SetSizeLimits(minw, minh, maxw, maxh)\n}\n\n// IsWindowFloating reports whether the window is always shown above all the other windows.\n//\n// IsWindowFloating returns false if the platform is not a desktop.\n//\n// IsWindowFloating is concurrent-safe.\nfunc IsWindowFloating() bool {\n\treturn ui.Get().Window().IsFloating()\n}\n\n// SetWindowFloating sets the state whether the window is always shown above all the other windows.\n//\n// SetWindowFloating does nothing if the platform is not a desktop.\n//\n// SetWindowFloating is concurrent-safe.\nfunc SetWindowFloating(float bool) {\n\tui.Get().Window().SetFloating(float)\n}\n\n// MaximizeWindow maximizes the window.\n//\n// MaximizeWindow does nothing when the window is not resizable (WindowResizingModeEnabled).\n//\n// MaximizeWindow does nothing if the platform is not a desktop.\n//\n// MaximizeWindow is concurrent-safe.\nfunc MaximizeWindow() {\n\tui.Get().Window().Maximize()\n}\n\n// IsWindowMaximized reports whether the window is maximized or not.\n//\n// IsWindowMaximized returns false when the window is not resizable (WindowResizingModeEnabled).\n//\n// IsWindowMaximized always returns false if the platform is not a desktop.\n//\n// IsWindowMaximized is concurrent-safe.\nfunc IsWindowMaximized() bool {\n\treturn ui.Get().Window().IsMaximized()\n}\n\n// MinimizeWindow minimizes the window.\n//\n// If the main loop does not start yet, MinimizeWindow does nothing.\n//\n// MinimizeWindow does nothing if the platform is not a desktop.\n//\n// MinimizeWindow is concurrent-safe.\nfunc MinimizeWindow() {\n\tui.Get().Window().Minimize()\n}\n\n// IsWindowMinimized reports whether the window is minimized or not.\n//\n// IsWindowMinimized always returns false if the platform is not a desktop.\n//\n// IsWindowMinimized is concurrent-safe.\nfunc IsWindowMinimized() bool {\n\treturn ui.Get().Window().IsMinimized()\n}\n\n// RestoreWindow restores the window from its maximized or minimized state.\n//\n// RestoreWindow panics when the window is not maximized nor minimized.\n//\n// RestoreWindow is concurrent-safe.\nfunc RestoreWindow() {\n\tif !IsWindowMaximized() && !IsWindowMinimized() {\n\t\tpanic(\"ebiten: RestoreWindow must be called on a maximized or a minimized window\")\n\t}\n\tui.Get().Window().Restore()\n}\n\n// IsWindowBeingClosed returns true when the user is trying to close the window on desktops.\n// As the window is closed immediately by default,\n// you might want to call SetWindowClosingHandled(true) to prevent the window is automatically closed.\n//\n// IsWindowBeingClosed always returns false if the platform is not a desktop.\n//\n// IsWindowBeingClosed is concurrent-safe.\nfunc IsWindowBeingClosed() bool {\n\treturn theInputState.windowBeingClosed()\n}\n\n// SetWindowClosingHandled sets whether the window closing is handled or not on desktops. The default state is false.\n//\n// If the window closing is handled, the window is not closed immediately and\n// the game can know whether the window is being closed or not by IsWindowBeingClosed.\n// In this case, the window is not closed automatically.\n// To end the game, you have to return an error value at the Game's Update function.\n//\n// SetWindowClosingHandled works only on desktops.\n// SetWindowClosingHandled does nothing if the platform is not a desktop.\n//\n// SetWindowClosingHandled is concurrent-safe.\nfunc SetWindowClosingHandled(handled bool) {\n\tui.Get().Window().SetClosingHandled(handled)\n}\n\n// IsWindowClosingHandled reports whether the window closing is handled or not on desktops by SetWindowClosingHandled.\n//\n// IsWindowClosingHandled always returns false if the platform is not a desktop.\n//\n// IsWindowClosingHandled is concurrent-safe.\nfunc IsWindowClosingHandled() bool {\n\treturn ui.Get().Window().IsClosingHandled()\n}\n\n// SetWindowMousePassthrough sets whether a mouse cursor passthroughs the window or not on desktops. The default state is false.\n//\n// Even if this is set true, some platforms might require a window to be undecorated\n// in order to make the mouse cursor passthrough the window.\n//\n// SetWindowMousePassthrough works only on desktops.\n// SetWindowMousePassthrough does nothing if the platform is not a desktop.\n//\n// SetWindowMousePassthrough is concurrent-safe.\nfunc SetWindowMousePassthrough(enabled bool) {\n\tui.Get().Window().SetMousePassthrough(enabled)\n}\n\n// IsWindowMousePassthrough reports whether a mouse cursor passthroughs the window or not on desktops.\n//\n// IsWindowMousePassthrough always returns false if the platform is not a desktop.\n//\n// IsWindowMousePassthrough is concurrent-safe.\nfunc IsWindowMousePassthrough() bool {\n\treturn ui.Get().Window().IsMousePassthrough()\n}\n\n// RequestAttention requests user attention to the current window and/or the current application.\n//\n// RequestAttention works only on desktops.\n// RequestAttention does nothing if the platform is not a desktop.\n//\n// RequestAttention is concurrent-safe.\nfunc RequestAttention() {\n\tui.Get().Window().RequestAttention()\n}\n"
        }
      ]
    }
  ]
}