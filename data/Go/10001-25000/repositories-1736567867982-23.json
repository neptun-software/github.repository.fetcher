{
  "metadata": {
    "timestamp": 1736567867982,
    "page": 23,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "uber-go/zap",
      "stars": 22380,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".codecov.yml",
          "type": "blob",
          "size": 0.7822265625,
          "content": "coverage:\n  range: 80..100\n  round: down\n  precision: 2\n\n  status:\n    project:                   # measuring the overall project coverage\n      default:                 # context, you can create multiple ones with custom titles\n        enabled: yes           # must be yes|true to enable this status\n        target: 95%            # specify the target coverage for each commit status\n                               #   option: \"auto\" (must increase from parent commit or pull request base)\n                               #   option: \"X%\" a static target percentage to hit\n        if_not_found: success  # if parent is not found report status as success, error, or failure\n        if_ci_failed: error    # if ci fails report status as success, error, or failure\nignore:\n  - internal/readme/readme.go\n\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3125,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\nvendor\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n*.pprof\n*.out\n*.log\n\n/bin\ncover.out\ncover.html\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 2.330078125,
          "content": "output:\n  # Make output more digestible with quickfix in vim/emacs/etc.\n  sort-results: true\n  print-issued-lines: false\n\nlinters:\n  # We'll track the golangci-lint default linters manually\n  # instead of letting them change without our control.\n  disable-all: true\n  enable:\n    # golangci-lint defaults:\n    - errcheck\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - unused\n\n    # Our own extras:\n    - gofumpt\n    - nolintlint # lints nolint directives\n    - revive\n\nlinters-settings:\n  govet:\n    # These govet checks are disabled by default, but they're useful.\n    enable:\n      - niliness\n      - reflectvaluecompare\n      - sortslice\n      - unusedwrite\n\n  errcheck:\n    exclude-functions:\n      # These methods can not fail.\n      # They operate on an in-memory buffer.\n      - (*go.uber.org/zap/buffer.Buffer).Write\n      - (*go.uber.org/zap/buffer.Buffer).WriteByte\n      - (*go.uber.org/zap/buffer.Buffer).WriteString\n\n      - (*go.uber.org/zap/zapio.Writer).Close\n      - (*go.uber.org/zap/zapio.Writer).Sync\n      - (*go.uber.org/zap/zapio.Writer).Write\n      # Write to zapio.Writer cannot fail,\n      # so io.WriteString on it cannot fail.\n      - io.WriteString(*go.uber.org/zap/zapio.Writer)\n\n      # Writing a plain string to a fmt.State cannot fail.\n      - io.WriteString(fmt.State)\n\nissues:\n  # Print all issues reported by all linters.\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\n  # Don't ignore some of the issues that golangci-lint considers okay.\n  # This includes documenting all exported entities.\n  exclude-use-default: false\n\n  exclude-rules:\n    # Don't warn on unused parameters.\n    # Parameter names are useful; replacing them with '_' is undesirable.\n    - linters: [revive]\n      text: 'unused-parameter: parameter \\S+ seems to be unused, consider removing or renaming it as _'\n\n    # staticcheck already has smarter checks for empty blocks.\n    # revive's empty-block linter has false positives.\n    # For example, as of writing this, the following is not allowed.\n    #   for foo() { }\n    - linters: [revive]\n      text: 'empty-block: this block is empty, you can remove it'\n\n    # Ignore logger.Sync() errcheck failures in example_test.go\n    # since those are intended to be uncomplicated examples.\n    - linters: [errcheck]\n      path: example_test.go\n      text: 'Error return value of `logger.Sync` is not checked'\n"
        },
        {
          "name": ".readme.tmpl",
          "type": "blob",
          "size": 4.03515625,
          "content": "# :zap: zap [![GoDoc][doc-img]][doc] [![Build Status][ci-img]][ci] [![Coverage Status][cov-img]][cov]\n\n<div align=\"center\">\n\nBlazing fast, structured, leveled logging in Go.\n\n![Zap logo](assets/logo.png)\n\n[![GoDoc][doc-img]][doc] [![Build Status][ci-img]][ci] [![Coverage Status][cov-img]][cov]\n\n</div>\n\n## Installation\n\n`go get -u go.uber.org/zap`\n\nNote that zap only supports the two most recent minor versions of Go.\n\n## Quick Start\n\nIn contexts where performance is nice, but not critical, use the\n`SugaredLogger`. It's 4-10x faster than other structured logging\npackages and includes both structured and `printf`-style APIs.\n\n```go\nlogger, _ := zap.NewProduction()\ndefer logger.Sync() // flushes buffer, if any\nsugar := logger.Sugar()\nsugar.Infow(\"failed to fetch URL\",\n  // Structured context as loosely typed key-value pairs.\n  \"url\", url,\n  \"attempt\", 3,\n  \"backoff\", time.Second,\n)\nsugar.Infof(\"Failed to fetch URL: %s\", url)\n```\n\nWhen performance and type safety are critical, use the `Logger`. It's even\nfaster than the `SugaredLogger` and allocates far less, but it only supports\nstructured logging.\n\n```go\nlogger, _ := zap.NewProduction()\ndefer logger.Sync()\nlogger.Info(\"failed to fetch URL\",\n  // Structured context as strongly typed Field values.\n  zap.String(\"url\", url),\n  zap.Int(\"attempt\", 3),\n  zap.Duration(\"backoff\", time.Second),\n)\n```\n\nSee the [documentation][doc] and [FAQ](FAQ.md) for more details.\n\n## Performance\n\nFor applications that log in the hot path, reflection-based serialization and\nstring formatting are prohibitively expensive &mdash; they're CPU-intensive\nand make many small allocations. Put differently, using `encoding/json` and\n`fmt.Fprintf` to log tons of `interface{}`s makes your application slow.\n\nZap takes a different approach. It includes a reflection-free, zero-allocation\nJSON encoder, and the base `Logger` strives to avoid serialization overhead\nand allocations wherever possible. By building the high-level `SugaredLogger`\non that foundation, zap lets users *choose* when they need to count every\nallocation and when they'd prefer a more familiar, loosely typed API.\n\nAs measured by its own [benchmarking suite][], not only is zap more performant\nthan comparable structured logging packages &mdash; it's also faster than the\nstandard library. Like all benchmarks, take these with a grain of salt.<sup\nid=\"anchor-versions\">[1](#footnote-versions)</sup>\n\nLog a message and 10 fields:\n\n{{.BenchmarkAddingFields}}\n\nLog a message with a logger that already has 10 fields of context:\n\n{{.BenchmarkAccumulatedContext}}\n\nLog a static string, without any context or `printf`-style templating:\n\n{{.BenchmarkWithoutFields}}\n\n## Development Status: Stable\n\nAll APIs are finalized, and no breaking changes will be made in the 1.x series\nof releases. Users of semver-aware dependency management systems should pin\nzap to `^1`.\n\n## Contributing\n\nWe encourage and support an active, healthy community of contributors &mdash;\nincluding you! Details are in the [contribution guide](CONTRIBUTING.md) and\nthe [code of conduct](CODE_OF_CONDUCT.md). The zap maintainers keep an eye on\nissues and pull requests, but you can also report any negative conduct to\noss-conduct@uber.com. That email list is a private, safe space; even the zap\nmaintainers don't have access, so don't hesitate to hold us to a high\nstandard.\n\n<hr>\n\nReleased under the [MIT License](LICENSE).\n\n<sup id=\"footnote-versions\">1</sup> In particular, keep in mind that we may be\nbenchmarking against slightly older versions of other packages. Versions are\npinned in the [benchmarks/go.mod][] file. [â†©](#anchor-versions)\n\n[doc-img]: https://pkg.go.dev/badge/go.uber.org/zap\n[doc]: https://pkg.go.dev/go.uber.org/zap\n[ci-img]: https://github.com/uber-go/zap/actions/workflows/go.yml/badge.svg\n[ci]: https://github.com/uber-go/zap/actions/workflows/go.yml\n[cov-img]: https://codecov.io/gh/uber-go/zap/branch/master/graph/badge.svg\n[cov]: https://codecov.io/gh/uber-go/zap\n[benchmarking suite]: https://github.com/uber-go/zap/tree/master/benchmarks\n[benchmarks/go.mod]: https://github.com/uber-go/zap/blob/master/benchmarks/go.mod\n\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 24.6865234375,
          "content": "# Changelog\nAll notable changes to this project will be documented in this file.\n\nThis project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## 1.27.0 (20 Feb 2024)\nEnhancements:\n* [#1378][]: Add `WithLazy` method for `SugaredLogger`.\n* [#1399][]: zaptest: Add `NewTestingWriter` for customizing TestingWriter with more flexibility than `NewLogger`.\n* [#1406][]: Add `Log`, `Logw`, `Logln` methods for `SugaredLogger`.\n* [#1416][]: Add `WithPanicHook` option for testing panic logs.\n\nThanks to @defval, @dimmo, @arxeiss, and @MKrupauskas for their contributions to this release.\n\n[#1378]: https://github.com/uber-go/zap/pull/1378\n[#1399]: https://github.com/uber-go/zap/pull/1399\n[#1406]: https://github.com/uber-go/zap/pull/1406\n[#1416]: https://github.com/uber-go/zap/pull/1416\n\n## 1.26.0 (14 Sep 2023)\nEnhancements:\n* [#1297][]: Add Dict as a Field.\n* [#1319][]: Add `WithLazy` method to `Logger` which lazily evaluates the structured\ncontext.\n* [#1350][]: String encoding is much (~50%) faster now.\n\nThanks to @hhk7734, @jquirke, and @cdvr1993 for their contributions to this release.\n\n[#1297]: https://github.com/uber-go/zap/pull/1297\n[#1319]: https://github.com/uber-go/zap/pull/1319\n[#1350]: https://github.com/uber-go/zap/pull/1350\n\n## 1.25.0 (1 Aug 2023)\n\nThis release contains several improvements including performance, API additions,\nand two new experimental packages whose APIs are unstable and may change in the\nfuture.\n\nEnhancements:\n* [#1246][]: Add `zap/exp/zapslog` package for integration with slog.\n* [#1273][]: Add `Name` to `Logger` which returns the Logger's name if one is set.\n* [#1281][]: Add `zap/exp/expfield` package which contains helper methods\n`Str` and `Strs` for constructing String-like zap.Fields.\n* [#1310][]: Reduce stack size on `Any`.\n\nThanks to @knight42, @dzakaammar, @bcspragu, and @rexywork for their contributions\nto this release.\n\n[#1246]: https://github.com/uber-go/zap/pull/1246\n[#1273]: https://github.com/uber-go/zap/pull/1273\n[#1281]: https://github.com/uber-go/zap/pull/1281\n[#1310]: https://github.com/uber-go/zap/pull/1310\n\n## 1.24.0 (30 Nov 2022)\n\nEnhancements:\n* [#1148][]: Add `Level` to both `Logger` and `SugaredLogger` that reports the\n  current minimum enabled log level.\n* [#1185][]: `SugaredLogger` turns errors to zap.Error automatically.\n\nThanks to @Abirdcfly, @craigpastro, @nnnkkk7, and @sashamelentyev for their\ncontributions to this release.\n\n[#1148]: https://github.coml/uber-go/zap/pull/1148\n[#1185]: https://github.coml/uber-go/zap/pull/1185\n\n## 1.23.0 (24 Aug 2022)\n\nEnhancements:\n* [#1147][]: Add a `zapcore.LevelOf` function to determine the level of a\n  `LevelEnabler` or `Core`.\n* [#1155][]: Add `zap.Stringers` field constructor to log arrays of objects\n  that implement `String() string`.\n\n[#1147]: https://github.com/uber-go/zap/pull/1147\n[#1155]: https://github.com/uber-go/zap/pull/1155\n\n## 1.22.0 (8 Aug 2022)\n\nEnhancements:\n* [#1071][]: Add `zap.Objects` and `zap.ObjectValues` field constructors to log\n  arrays of objects. With these two constructors, you don't need to implement\n  `zapcore.ArrayMarshaler` for use with `zap.Array` if those objects implement\n  `zapcore.ObjectMarshaler`.\n* [#1079][]: Add `SugaredLogger.WithOptions` to build a copy of an existing\n  `SugaredLogger` with the provided options applied.\n* [#1080][]: Add `*ln` variants to `SugaredLogger` for each log level.\n  These functions provide a string joining behavior similar to `fmt.Println`.\n* [#1088][]: Add `zap.WithFatalHook` option to control the behavior of the\n  logger for `Fatal`-level log entries. This defaults to exiting the program.\n* [#1108][]: Add a `zap.Must` function that you can use with `NewProduction` or\n  `NewDevelopment` to panic if the system was unable to build the logger.\n* [#1118][]: Add a `Logger.Log` method that allows specifying the log level for\n  a statement dynamically.\n\nThanks to @cardil, @craigpastro, @sashamelentyev, @shota3506, and @zhupeijun\nfor their contributions to this release.\n\n[#1071]: https://github.com/uber-go/zap/pull/1071\n[#1079]: https://github.com/uber-go/zap/pull/1079\n[#1080]: https://github.com/uber-go/zap/pull/1080\n[#1088]: https://github.com/uber-go/zap/pull/1088\n[#1108]: https://github.com/uber-go/zap/pull/1108\n[#1118]: https://github.com/uber-go/zap/pull/1118\n\n## 1.21.0 (7 Feb 2022)\n\nEnhancements:\n*  [#1047][]: Add `zapcore.ParseLevel` to parse a `Level` from a string.\n*  [#1048][]: Add `zap.ParseAtomicLevel` to parse an `AtomicLevel` from a\n   string.\n\nBugfixes:\n* [#1058][]: Fix panic in JSON encoder when `EncodeLevel` is unset.\n\nOther changes:\n* [#1052][]: Improve encoding performance when the `AddCaller` and\n  `AddStacktrace` options are used together.\n\n[#1047]: https://github.com/uber-go/zap/pull/1047\n[#1048]: https://github.com/uber-go/zap/pull/1048\n[#1052]: https://github.com/uber-go/zap/pull/1052\n[#1058]: https://github.com/uber-go/zap/pull/1058\n\nThanks to @aerosol and @Techassi for their contributions to this release.\n\n## 1.20.0 (4 Jan 2022)\n\nEnhancements:\n* [#989][]: Add `EncoderConfig.SkipLineEnding` flag to disable adding newline\n  characters between log statements.\n* [#1039][]: Add `EncoderConfig.NewReflectedEncoder` field to customize JSON\n  encoding of reflected log fields.\n\nBugfixes:\n* [#1011][]: Fix inaccurate precision when encoding complex64 as JSON.\n* [#554][], [#1017][]: Close JSON namespaces opened in `MarshalLogObject`\n  methods when the methods return.\n* [#1033][]: Avoid panicking in Sampler core if `thereafter` is zero.\n\nOther changes:\n* [#1028][]: Drop support for Go < 1.15.\n\n[#554]: https://github.com/uber-go/zap/pull/554\n[#989]: https://github.com/uber-go/zap/pull/989\n[#1011]: https://github.com/uber-go/zap/pull/1011\n[#1017]: https://github.com/uber-go/zap/pull/1017\n[#1028]: https://github.com/uber-go/zap/pull/1028\n[#1033]: https://github.com/uber-go/zap/pull/1033\n[#1039]: https://github.com/uber-go/zap/pull/1039\n\nThanks to @psrajat, @lruggieri, @sammyrnycreal for their contributions to this release.\n\n## 1.19.1 (8 Sep 2021)\n\nBugfixes:\n* [#1001][]: JSON: Fix complex number encoding with negative imaginary part. Thanks to @hemantjadon.\n* [#1003][]: JSON: Fix inaccurate precision when encoding float32.\n\n[#1001]: https://github.com/uber-go/zap/pull/1001\n[#1003]: https://github.com/uber-go/zap/pull/1003\n\n## 1.19.0 (9 Aug 2021)\n\nEnhancements:\n* [#975][]: Avoid panicking in Sampler core if the level is out of bounds.\n* [#984][]: Reduce the size of BufferedWriteSyncer by aligning the fields\n  better.\n\n[#975]: https://github.com/uber-go/zap/pull/975\n[#984]: https://github.com/uber-go/zap/pull/984\n\nThanks to @lancoLiu and @thockin for their contributions to this release.\n\n## 1.18.1 (28 Jun 2021)\n\nBugfixes:\n* [#974][]: Fix nil dereference in logger constructed by `zap.NewNop`.\n\n[#974]: https://github.com/uber-go/zap/pull/974\n\n## 1.18.0 (28 Jun 2021)\n\nEnhancements:\n* [#961][]: Add `zapcore.BufferedWriteSyncer`, a new `WriteSyncer` that buffers\n  messages in-memory and flushes them periodically.\n* [#971][]: Add `zapio.Writer` to use a Zap logger as an `io.Writer`.\n* [#897][]: Add `zap.WithClock` option to control the source of time via the\n  new `zapcore.Clock` interface.\n* [#949][]: Avoid panicking in `zap.SugaredLogger` when arguments of `*w`\n  methods don't match expectations.\n* [#943][]: Add support for filtering by level or arbitrary matcher function to\n  `zaptest/observer`.\n* [#691][]: Comply with `io.StringWriter` and `io.ByteWriter` in Zap's\n  `buffer.Buffer`.\n\nThanks to @atrn0, @ernado, @heyanfu, @hnlq715, @zchee\nfor their contributions to this release.\n\n[#691]: https://github.com/uber-go/zap/pull/691\n[#897]: https://github.com/uber-go/zap/pull/897\n[#943]: https://github.com/uber-go/zap/pull/943\n[#949]: https://github.com/uber-go/zap/pull/949\n[#961]: https://github.com/uber-go/zap/pull/961\n[#971]: https://github.com/uber-go/zap/pull/971\n\n## 1.17.0 (25 May 2021)\n\nBugfixes:\n* [#867][]: Encode `<nil>` for nil `error` instead of a panic.\n* [#931][], [#936][]: Update minimum version constraints to address\n  vulnerabilities in dependencies.\n\nEnhancements:\n* [#865][]: Improve alignment of fields of the Logger struct, reducing its\n  size from 96 to 80 bytes.\n* [#881][]: Support `grpclog.LoggerV2` in zapgrpc.\n* [#903][]: Support URL-encoded POST requests to the AtomicLevel HTTP handler\n  with the `application/x-www-form-urlencoded` content type.\n* [#912][]: Support multi-field encoding with `zap.Inline`.\n* [#913][]: Speed up SugaredLogger for calls with a single string.\n* [#928][]: Add support for filtering by field name to `zaptest/observer`.\n\nThanks to @ash2k, @FMLS, @jimmystewpot, @Oncilla, @tsoslow, @tylitianrui, @withshubh, and @wziww for their contributions to this release.\n\n[#865]: https://github.com/uber-go/zap/pull/865\n[#867]: https://github.com/uber-go/zap/pull/867\n[#881]: https://github.com/uber-go/zap/pull/881\n[#903]: https://github.com/uber-go/zap/pull/903\n[#912]: https://github.com/uber-go/zap/pull/912\n[#913]: https://github.com/uber-go/zap/pull/913\n[#928]: https://github.com/uber-go/zap/pull/928\n[#931]: https://github.com/uber-go/zap/pull/931\n[#936]: https://github.com/uber-go/zap/pull/936\n\n## 1.16.0 (1 Sep 2020)\n\nBugfixes:\n* [#828][]: Fix missing newline in IncreaseLevel error messages.\n* [#835][]: Fix panic in JSON encoder when encoding times or durations\n  without specifying a time or duration encoder.\n* [#843][]: Honor CallerSkip when taking stack traces.\n* [#862][]: Fix the default file permissions to use `0666` and rely on the umask instead.\n* [#854][]: Encode `<nil>` for nil `Stringer` instead of a panic error log.\n\nEnhancements:\n* [#629][]: Added `zapcore.TimeEncoderOfLayout` to easily create time encoders\n  for custom layouts.\n* [#697][]: Added support for a configurable delimiter in the console encoder.\n* [#852][]: Optimize console encoder by pooling the underlying JSON encoder.\n* [#844][]: Add ability to include the calling function as part of logs.\n* [#843][]: Add `StackSkip` for including truncated stacks as a field.\n* [#861][]: Add options to customize Fatal behaviour for better testability.\n\nThanks to @SteelPhase, @tmshn, @lixingwang, @wyxloading, @moul, @segevfiner, @andy-retailnext and @jcorbin for their contributions to this release.\n\n[#629]: https://github.com/uber-go/zap/pull/629\n[#697]: https://github.com/uber-go/zap/pull/697\n[#828]: https://github.com/uber-go/zap/pull/828\n[#835]: https://github.com/uber-go/zap/pull/835\n[#843]: https://github.com/uber-go/zap/pull/843\n[#844]: https://github.com/uber-go/zap/pull/844\n[#852]: https://github.com/uber-go/zap/pull/852\n[#854]: https://github.com/uber-go/zap/pull/854\n[#861]: https://github.com/uber-go/zap/pull/861\n[#862]: https://github.com/uber-go/zap/pull/862\n\n## 1.15.0 (23 Apr 2020)\n\nBugfixes:\n* [#804][]: Fix handling of `Time` values out of `UnixNano` range.\n* [#812][]: Fix `IncreaseLevel` being reset after a call to `With`.\n\nEnhancements:\n* [#806][]: Add `WithCaller` option to supersede the `AddCaller` option. This\n  allows disabling annotation of log entries with caller information if\n  previously enabled with `AddCaller`.\n* [#813][]: Deprecate `NewSampler` constructor in favor of\n  `NewSamplerWithOptions` which supports a `SamplerHook` option. This option\n   adds support for monitoring sampling decisions through a hook.\n\nThanks to @danielbprice for their contributions to this release.\n\n[#804]: https://github.com/uber-go/zap/pull/804\n[#812]: https://github.com/uber-go/zap/pull/812\n[#806]: https://github.com/uber-go/zap/pull/806\n[#813]: https://github.com/uber-go/zap/pull/813\n\n## 1.14.1 (14 Mar 2020)\n\nBugfixes:\n* [#791][]: Fix panic on attempting to build a logger with an invalid Config.\n* [#795][]: Vendoring Zap with `go mod vendor` no longer includes Zap's\n  development-time dependencies.\n* [#799][]: Fix issue introduced in 1.14.0 that caused invalid JSON output to\n  be generated for arrays of `time.Time` objects when using string-based time\n  formats.\n\nThanks to @YashishDua for their contributions to this release.\n\n[#791]: https://github.com/uber-go/zap/pull/791\n[#795]: https://github.com/uber-go/zap/pull/795\n[#799]: https://github.com/uber-go/zap/pull/799\n\n## 1.14.0 (20 Feb 2020)\n\nEnhancements:\n* [#771][]: Optimize calls for disabled log levels.\n* [#773][]: Add millisecond duration encoder.\n* [#775][]: Add option to increase the level of a logger.\n* [#786][]: Optimize time formatters using `Time.AppendFormat` where possible.\n\nThanks to @caibirdme for their contributions to this release.\n\n[#771]: https://github.com/uber-go/zap/pull/771\n[#773]: https://github.com/uber-go/zap/pull/773\n[#775]: https://github.com/uber-go/zap/pull/775\n[#786]: https://github.com/uber-go/zap/pull/786\n\n## 1.13.0 (13 Nov 2019)\n\nEnhancements:\n* [#758][]: Add `Intp`, `Stringp`, and other similar `*p` field constructors\n  to log pointers to primitives with support for `nil` values.\n\nThanks to @jbizzle for their contributions to this release.\n\n[#758]: https://github.com/uber-go/zap/pull/758\n\n## 1.12.0 (29 Oct 2019)\n\nEnhancements:\n* [#751][]: Migrate to Go modules.\n\n[#751]: https://github.com/uber-go/zap/pull/751\n\n## 1.11.0 (21 Oct 2019)\n\nEnhancements:\n* [#725][]: Add `zapcore.OmitKey` to omit keys in an `EncoderConfig`.\n* [#736][]: Add `RFC3339` and `RFC3339Nano` time encoders.\n\nThanks to @juicemia, @uhthomas for their contributions to this release.\n\n[#725]: https://github.com/uber-go/zap/pull/725\n[#736]: https://github.com/uber-go/zap/pull/736\n\n## 1.10.0 (29 Apr 2019)\n\nBugfixes:\n* [#657][]: Fix `MapObjectEncoder.AppendByteString` not adding value as a\n  string.\n* [#706][]: Fix incorrect call depth to determine caller in Go 1.12.\n\nEnhancements:\n* [#610][]: Add `zaptest.WrapOptions` to wrap `zap.Option` for creating test\n  loggers.\n* [#675][]: Don't panic when encoding a String field.\n* [#704][]: Disable HTML escaping for JSON objects encoded using the\n  reflect-based encoder.\n\nThanks to @iaroslav-ciupin, @lelenanam, @joa, @NWilson for their contributions\nto this release.\n\n[#657]: https://github.com/uber-go/zap/pull/657\n[#706]: https://github.com/uber-go/zap/pull/706\n[#610]: https://github.com/uber-go/zap/pull/610\n[#675]: https://github.com/uber-go/zap/pull/675\n[#704]: https://github.com/uber-go/zap/pull/704\n\n## 1.9.1 (06 Aug 2018)\n\nBugfixes:\n\n* [#614][]: MapObjectEncoder should not ignore empty slices.\n\n[#614]: https://github.com/uber-go/zap/pull/614\n\n## 1.9.0 (19 Jul 2018)\n\nEnhancements:\n* [#602][]: Reduce number of allocations when logging with reflection.\n* [#572][], [#606][]: Expose a registry for third-party logging sinks.\n\nThanks to @nfarah86, @AlekSi, @JeanMertz, @philippgille, @etsangsplk, and\n@dimroc for their contributions to this release.\n\n[#602]: https://github.com/uber-go/zap/pull/602\n[#572]: https://github.com/uber-go/zap/pull/572\n[#606]: https://github.com/uber-go/zap/pull/606\n\n## 1.8.0 (13 Apr 2018)\n\nEnhancements:\n* [#508][]: Make log level configurable when redirecting the standard\n  library's logger.\n* [#518][]: Add a logger that writes to a `*testing.TB`.\n* [#577][]: Add a top-level alias for `zapcore.Field` to clean up GoDoc.\n\nBugfixes:\n* [#574][]: Add a missing import comment to `go.uber.org/zap/buffer`.\n\nThanks to @DiSiqueira and @djui for their contributions to this release.\n\n[#508]: https://github.com/uber-go/zap/pull/508\n[#518]: https://github.com/uber-go/zap/pull/518\n[#577]: https://github.com/uber-go/zap/pull/577\n[#574]: https://github.com/uber-go/zap/pull/574\n\n## 1.7.1 (25 Sep 2017)\n\nBugfixes:\n* [#504][]: Store strings when using AddByteString with the map encoder.\n\n[#504]: https://github.com/uber-go/zap/pull/504\n\n## 1.7.0 (21 Sep 2017)\n\nEnhancements:\n\n* [#487][]: Add `NewStdLogAt`, which extends `NewStdLog` by allowing the user\n  to specify the level of the logged messages.\n\n[#487]: https://github.com/uber-go/zap/pull/487\n\n## 1.6.0 (30 Aug 2017)\n\nEnhancements:\n\n* [#491][]: Omit zap stack frames from stacktraces.\n* [#490][]: Add a `ContextMap` method to observer logs for simpler\n  field validation in tests.\n\n[#490]: https://github.com/uber-go/zap/pull/490\n[#491]: https://github.com/uber-go/zap/pull/491\n\n## 1.5.0 (22 Jul 2017)\n\nEnhancements:\n\n* [#460][] and [#470][]: Support errors produced by `go.uber.org/multierr`.\n* [#465][]: Support user-supplied encoders for logger names.\n\nBugfixes:\n\n* [#477][]: Fix a bug that incorrectly truncated deep stacktraces.\n\nThanks to @richard-tunein and @pavius for their contributions to this release.\n\n[#477]: https://github.com/uber-go/zap/pull/477\n[#465]: https://github.com/uber-go/zap/pull/465\n[#460]: https://github.com/uber-go/zap/pull/460\n[#470]: https://github.com/uber-go/zap/pull/470\n\n## 1.4.1 (08 Jun 2017)\n\nThis release fixes two bugs.\n\nBugfixes:\n\n* [#435][]: Support a variety of case conventions when unmarshaling levels.\n* [#444][]: Fix a panic in the observer.\n\n[#435]: https://github.com/uber-go/zap/pull/435\n[#444]: https://github.com/uber-go/zap/pull/444\n\n## 1.4.0 (12 May 2017)\n\nThis release adds a few small features and is fully backward-compatible.\n\nEnhancements:\n\n* [#424][]: Add a `LineEnding` field to `EncoderConfig`, allowing users to\n  override the Unix-style default.\n* [#425][]: Preserve time zones when logging times.\n* [#431][]: Make `zap.AtomicLevel` implement `fmt.Stringer`, which makes a\n  variety of operations a bit simpler.\n\n[#424]: https://github.com/uber-go/zap/pull/424\n[#425]: https://github.com/uber-go/zap/pull/425\n[#431]: https://github.com/uber-go/zap/pull/431\n\n## 1.3.0 (25 Apr 2017)\n\nThis release adds an enhancement to zap's testing helpers as well as the\nability to marshal an AtomicLevel. It is fully backward-compatible.\n\nEnhancements:\n\n* [#415][]: Add a substring-filtering helper to zap's observer. This is\n  particularly useful when testing the `SugaredLogger`.\n* [#416][]: Make `AtomicLevel` implement `encoding.TextMarshaler`.\n\n[#415]: https://github.com/uber-go/zap/pull/415\n[#416]: https://github.com/uber-go/zap/pull/416\n\n## 1.2.0 (13 Apr 2017)\n\nThis release adds a gRPC compatibility wrapper. It is fully backward-compatible.\n\nEnhancements:\n\n* [#402][]: Add a `zapgrpc` package that wraps zap's Logger and implements\n  `grpclog.Logger`.\n\n[#402]: https://github.com/uber-go/zap/pull/402\n\n## 1.1.0 (31 Mar 2017)\n\nThis release fixes two bugs and adds some enhancements to zap's testing helpers.\nIt is fully backward-compatible.\n\nBugfixes:\n\n* [#385][]: Fix caller path trimming on Windows.\n* [#396][]: Fix a panic when attempting to use non-existent directories with\n  zap's configuration struct.\n\nEnhancements:\n\n* [#386][]: Add filtering helpers to zaptest's observing logger.\n\nThanks to @moitias for contributing to this release.\n\n[#385]: https://github.com/uber-go/zap/pull/385\n[#396]: https://github.com/uber-go/zap/pull/396\n[#386]: https://github.com/uber-go/zap/pull/386\n\n## 1.0.0 (14 Mar 2017)\n\nThis is zap's first stable release. All exported APIs are now final, and no\nfurther breaking changes will be made in the 1.x release series. Anyone using a\nsemver-aware dependency manager should now pin to `^1`.\n\nBreaking changes:\n\n* [#366][]: Add byte-oriented APIs to encoders to log UTF-8 encoded text without\n  casting from `[]byte` to `string`.\n* [#364][]: To support buffering outputs, add `Sync` methods to `zapcore.Core`,\n  `zap.Logger`, and `zap.SugaredLogger`.\n* [#371][]: Rename the `testutils` package to `zaptest`, which is less likely to\n  clash with other testing helpers.\n\nBugfixes:\n\n* [#362][]: Make the ISO8601 time formatters fixed-width, which is friendlier\n  for tab-separated console output.\n* [#369][]: Remove the automatic locks in `zapcore.NewCore`, which allows zap to\n  work with concurrency-safe `WriteSyncer` implementations.\n* [#347][]: Stop reporting errors when trying to `fsync` standard out on Linux\n  systems.\n* [#373][]: Report the correct caller from zap's standard library\n  interoperability wrappers.\n\nEnhancements:\n\n* [#348][]: Add a registry allowing third-party encodings to work with zap's\n  built-in `Config`.\n* [#327][]: Make the representation of logger callers configurable (like times,\n  levels, and durations).\n* [#376][]: Allow third-party encoders to use their own buffer pools, which\n  removes the last performance advantage that zap's encoders have over plugins.\n* [#346][]: Add `CombineWriteSyncers`, a convenience function to tee multiple\n  `WriteSyncer`s and lock the result.\n* [#365][]: Make zap's stacktraces compatible with mid-stack inlining (coming in\n  Go 1.9).\n* [#372][]: Export zap's observing logger as `zaptest/observer`. This makes it\n  easier for particularly punctilious users to unit test their application's\n  logging.\n\nThanks to @suyash, @htrendev, @flisky, @Ulexus, and @skipor for their\ncontributions to this release.\n\n[#366]: https://github.com/uber-go/zap/pull/366\n[#364]: https://github.com/uber-go/zap/pull/364\n[#371]: https://github.com/uber-go/zap/pull/371\n[#362]: https://github.com/uber-go/zap/pull/362\n[#369]: https://github.com/uber-go/zap/pull/369\n[#347]: https://github.com/uber-go/zap/pull/347\n[#373]: https://github.com/uber-go/zap/pull/373\n[#348]: https://github.com/uber-go/zap/pull/348\n[#327]: https://github.com/uber-go/zap/pull/327\n[#376]: https://github.com/uber-go/zap/pull/376\n[#346]: https://github.com/uber-go/zap/pull/346\n[#365]: https://github.com/uber-go/zap/pull/365\n[#372]: https://github.com/uber-go/zap/pull/372\n\n## 1.0.0-rc.3 (7 Mar 2017)\n\nThis is the third release candidate for zap's stable release. There are no\nbreaking changes.\n\nBugfixes:\n\n* [#339][]: Byte slices passed to `zap.Any` are now correctly treated as binary blobs\n  rather than `[]uint8`.\n\nEnhancements:\n\n* [#307][]: Users can opt into colored output for log levels.\n* [#353][]: In addition to hijacking the output of the standard library's\n  package-global logging functions, users can now construct a zap-backed\n  `log.Logger` instance.\n* [#311][]: Frames from common runtime functions and some of zap's internal\n  machinery are now omitted from stacktraces.\n\nThanks to @ansel1 and @suyash for their contributions to this release.\n\n[#339]: https://github.com/uber-go/zap/pull/339\n[#307]: https://github.com/uber-go/zap/pull/307\n[#353]: https://github.com/uber-go/zap/pull/353\n[#311]: https://github.com/uber-go/zap/pull/311\n\n## 1.0.0-rc.2 (21 Feb 2017)\n\nThis is the second release candidate for zap's stable release. It includes two\nbreaking changes.\n\nBreaking changes:\n\n* [#316][]: Zap's global loggers are now fully concurrency-safe\n  (previously, users had to ensure that `ReplaceGlobals` was called before the\n  loggers were in use). However, they must now be accessed via the `L()` and\n  `S()` functions. Users can update their projects with\n\n  ```\n  gofmt -r \"zap.L -> zap.L()\" -w .\n  gofmt -r \"zap.S -> zap.S()\" -w .\n  ```\n* [#309][] and [#317][]: RC1 was mistakenly shipped with invalid\n  JSON and YAML struct tags on all config structs. This release fixes the tags\n  and adds static analysis to prevent similar bugs in the future.\n\nBugfixes:\n\n* [#321][]: Redirecting the standard library's `log` output now\n  correctly reports the logger's caller.\n\nEnhancements:\n\n* [#325][] and [#333][]: Zap now transparently supports non-standard, rich\n  errors like those produced by `github.com/pkg/errors`.\n* [#326][]: Though `New(nil)` continues to return a no-op logger, `NewNop()` is\n  now preferred. Users can update their projects with `gofmt -r 'zap.New(nil) ->\n  zap.NewNop()' -w .`.\n* [#300][]: Incorrectly importing zap as `github.com/uber-go/zap` now returns a\n  more informative error.\n\nThanks to @skipor and @chapsuk for their contributions to this release.\n\n[#316]: https://github.com/uber-go/zap/pull/316\n[#309]: https://github.com/uber-go/zap/pull/309\n[#317]: https://github.com/uber-go/zap/pull/317\n[#321]: https://github.com/uber-go/zap/pull/321\n[#325]: https://github.com/uber-go/zap/pull/325\n[#333]: https://github.com/uber-go/zap/pull/333\n[#326]: https://github.com/uber-go/zap/pull/326\n[#300]: https://github.com/uber-go/zap/pull/300\n\n## 1.0.0-rc.1 (14 Feb 2017)\n\nThis is the first release candidate for zap's stable release. There are multiple\nbreaking changes and improvements from the pre-release version. Most notably:\n\n* **Zap's import path is now \"go.uber.org/zap\"** &mdash; all users will\n  need to update their code.\n* User-facing types and functions remain in the `zap` package. Code relevant\n  largely to extension authors is now in the `zapcore` package.\n* The `zapcore.Core` type makes it easy for third-party packages to use zap's\n  internals but provide a different user-facing API.\n* `Logger` is now a concrete type instead of an interface.\n* A less verbose (though slower) logging API is included by default.\n* Package-global loggers `L` and `S` are included.\n* A human-friendly console encoder is included.\n* A declarative config struct allows common logger configurations to be managed\n  as configuration instead of code.\n* Sampling is more accurate, and doesn't depend on the standard library's shared\n  timer heap.\n\n## 0.1.0-beta.1 (6 Feb 2017)\n\nThis is a minor version, tagged to allow users to pin to the pre-1.0 APIs and\nupgrade at their leisure. Since this is the first tagged release, there are no\nbackward compatibility concerns and all functionality is new.\n\nEarly zap adopters should pin to the 0.1.x minor version until they're ready to\nupgrade to the upcoming stable release.\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.150390625,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age,\nbody size, disability, ethnicity, gender identity and expression, level of\nexperience, nationality, personal appearance, race, religion, or sexual\nidentity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n  advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an\nappointed representative at an online or offline event. Representation of a\nproject may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at oss-conduct@uber.com. The project\nteam will review and investigate all complaints, and will respond in a way\nthat it deems appropriate to the circumstances. The project team is obligated\nto maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 1.4, available at\n[http://contributor-covenant.org/version/1/4][version].\n\n[homepage]: https://contributor-covenant.org\n[version]: https://contributor-covenant.org/version/1/4/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.095703125,
          "content": "# Contributing\n\nWe'd love your help making zap the very best structured logging library in Go!\n\nIf you'd like to add new exported APIs, please [open an issue][open-issue]\ndescribing your proposal &mdash; discussing API changes ahead of time makes\npull request review much smoother. In your issue, pull request, and any other\ncommunications, please remember to treat your fellow contributors with\nrespect! We take our [code of conduct](CODE_OF_CONDUCT.md) seriously.\n\nNote that you'll need to sign [Uber's Contributor License Agreement][cla]\nbefore we can accept any of your contributions. If necessary, a bot will remind\nyou to accept the CLA when you open your pull request.\n\n## Setup\n\n[Fork][fork], then clone the repository:\n\n```bash\nmkdir -p $GOPATH/src/go.uber.org\ncd $GOPATH/src/go.uber.org\ngit clone git@github.com:your_github_username/zap.git\ncd zap\ngit remote add upstream https://github.com/uber-go/zap.git\ngit fetch upstream\n```\n\nMake sure that the tests and the linters pass:\n\n```bash\nmake test\nmake lint\n```\n\n## Making Changes\n\nStart by creating a new branch for your changes:\n\n```bash\ncd $GOPATH/src/go.uber.org/zap\ngit checkout master\ngit fetch upstream\ngit rebase upstream/master\ngit checkout -b cool_new_feature\n```\n\nMake your changes, then ensure that `make lint` and `make test` still pass. If\nyou're satisfied with your changes, push them to your fork.\n\n```bash\ngit push origin cool_new_feature\n```\n\nThen use the GitHub UI to open a pull request.\n\nAt this point, you're waiting on us to review your changes. We _try_ to respond\nto issues and pull requests within a few business days, and we may suggest some\nimprovements or alternatives. Once your changes are approved, one of the\nproject maintainers will merge them.\n\nWe're much more likely to approve your changes if you:\n\n- Add tests for new functionality.\n- Write a [good commit message][commit-message].\n- Maintain backward compatibility.\n\n[fork]: https://github.com/uber-go/zap/fork\n[open-issue]: https://github.com/uber-go/zap/issues/new\n[cla]: https://cla-assistant.io/uber-go/zap\n[commit-message]: http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html\n"
        },
        {
          "name": "FAQ.md",
          "type": "blob",
          "size": 6.4697265625,
          "content": "# Frequently Asked Questions\n\n## Design\n\n### Why spend so much effort on logger performance?\n\nOf course, most applications won't notice the impact of a slow logger: they\nalready take tens or hundreds of milliseconds for each operation, so an extra\nmillisecond doesn't matter.\n\nOn the other hand, why *not* make structured logging fast? The `SugaredLogger`\nisn't any harder to use than other logging packages, and the `Logger` makes\nstructured logging possible in performance-sensitive contexts. Across a fleet\nof Go microservices, making each application even slightly more efficient adds\nup quickly.\n\n### Why aren't `Logger` and `SugaredLogger` interfaces?\n\nUnlike the familiar `io.Writer` and `http.Handler`, `Logger` and\n`SugaredLogger` interfaces would include *many* methods. As [Rob Pike points\nout][go-proverbs], \"The bigger the interface, the weaker the abstraction.\"\nInterfaces are also rigid &mdash; *any* change requires releasing a new major\nversion, since it breaks all third-party implementations.\n\nMaking the `Logger` and `SugaredLogger` concrete types doesn't sacrifice much\nabstraction, and it lets us add methods without introducing breaking changes.\nYour applications should define and depend upon an interface that includes\njust the methods you use.\n\n### Why are some of my logs missing?\n\nLogs are dropped intentionally by zap when sampling is enabled. The production\nconfiguration (as returned by `NewProductionConfig()` enables sampling which will\ncause repeated logs within a second to be sampled. See more details on why sampling\nis enabled in [Why sample application logs](https://github.com/uber-go/zap/blob/master/FAQ.md#why-sample-application-logs).\n\n### Why sample application logs?\n\nApplications often experience runs of errors, either because of a bug or\nbecause of a misbehaving user. Logging errors is usually a good idea, but it\ncan easily make this bad situation worse: not only is your application coping\nwith a flood of errors, it's also spending extra CPU cycles and I/O logging\nthose errors. Since writes are typically serialized, logging limits throughput\nwhen you need it most.\n\nSampling fixes this problem by dropping repetitive log entries. Under normal\nconditions, your application writes out every entry. When similar entries are\nlogged hundreds or thousands of times each second, though, zap begins dropping\nduplicates to preserve throughput.\n\n### Why do the structured logging APIs take a message in addition to fields?\n\nSubjectively, we find it helpful to accompany structured context with a brief\ndescription. This isn't critical during development, but it makes debugging\nand operating unfamiliar systems much easier.\n\nMore concretely, zap's sampling algorithm uses the message to identify\nduplicate entries. In our experience, this is a practical middle ground\nbetween random sampling (which often drops the exact entry that you need while\ndebugging) and hashing the complete entry (which is prohibitively expensive).\n\n### Why include package-global loggers?\n\nSince so many other logging packages include a global logger, many\napplications aren't designed to accept loggers as explicit parameters.\nChanging function signatures is often a breaking change, so zap includes\nglobal loggers to simplify migration.\n\nAvoid them where possible.\n\n### Why include dedicated Panic and Fatal log levels?\n\nIn general, application code should handle errors gracefully instead of using\n`panic` or `os.Exit`. However, every rule has exceptions, and it's common to\ncrash when an error is truly unrecoverable. To avoid losing any information\n&mdash; especially the reason for the crash &mdash; the logger must flush any\nbuffered entries before the process exits.\n\nZap makes this easy by offering `Panic` and `Fatal` logging methods that\nautomatically flush before exiting. Of course, this doesn't guarantee that\nlogs will never be lost, but it eliminates a common error.\n\nSee the discussion in uber-go/zap#207 for more details.\n\n### What's `DPanic`?\n\n`DPanic` stands for \"panic in development.\" In development, it logs at\n`PanicLevel`; otherwise, it logs at `ErrorLevel`. `DPanic` makes it easier to\ncatch errors that are theoretically possible, but shouldn't actually happen,\n*without* crashing in production.\n\nIf you've ever written code like this, you need `DPanic`:\n\n```go\nif err != nil {\n  panic(fmt.Sprintf(\"shouldn't ever get here: %v\", err))\n}\n```\n\n## Installation\n\n### What does the error `expects import \"go.uber.org/zap\"` mean?\n\nEither zap was installed incorrectly or you're referencing the wrong package\nname in your code.\n\nZap's source code happens to be hosted on GitHub, but the [import\npath][import-path] is `go.uber.org/zap`. This gives us, the project\nmaintainers, the freedom to move the source code if necessary. However, it\nmeans that you need to take a little care when installing and using the\npackage.\n\nIf you follow two simple rules, everything should work: install zap with `go\nget -u go.uber.org/zap`, and always import it in your code with `import\n\"go.uber.org/zap\"`. Your code shouldn't contain *any* references to\n`github.com/uber-go/zap`.\n\n## Usage\n\n### Does zap support log rotation?\n\nZap doesn't natively support rotating log files, since we prefer to leave this\nto an external program like `logrotate`.\n\nHowever, it's easy to integrate a log rotation package like\n[`gopkg.in/natefinch/lumberjack.v2`][lumberjack] as a `zapcore.WriteSyncer`.\n\n```go\n// lumberjack.Logger is already safe for concurrent use, so we don't need to\n// lock it.\nw := zapcore.AddSync(&lumberjack.Logger{\n  Filename:   \"/var/log/myapp/foo.log\",\n  MaxSize:    500, // megabytes\n  MaxBackups: 3,\n  MaxAge:     28, // days\n})\ncore := zapcore.NewCore(\n  zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()),\n  w,\n  zap.InfoLevel,\n)\nlogger := zap.New(core)\n```\n\n## Extensions\n\nWe'd love to support every logging need within zap itself, but we're only\nfamiliar with a handful of log ingestion systems, flag-parsing packages, and\nthe like. Rather than merging code that we can't effectively debug and\nsupport, we'd rather grow an ecosystem of zap extensions.\n\nWe're aware of the following extensions, but haven't used them ourselves:\n\n| Package | Integration |\n| --- | --- |\n| `github.com/tchap/zapext` | Sentry, syslog |\n| `github.com/fgrosse/zaptest` | Ginkgo |\n| `github.com/blendle/zapdriver` | Stackdriver |\n| `github.com/moul/zapgorm` | Gorm |\n| `github.com/moul/zapfilter` | Advanced filtering rules |\n\n[go-proverbs]: https://go-proverbs.github.io/\n[import-path]: https://golang.org/cmd/go/#hdr-Remote_import_paths\n[lumberjack]: https://godoc.org/gopkg.in/natefinch/lumberjack.v2\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "Copyright (c) 2016-2024 Uber Technologies, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.75,
          "content": "# Directory containing the Makefile.\nPROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))\n\nexport GOBIN ?= $(PROJECT_ROOT)/bin\nexport PATH := $(GOBIN):$(PATH)\n\nGOVULNCHECK = $(GOBIN)/govulncheck\nBENCH_FLAGS ?= -cpuprofile=cpu.pprof -memprofile=mem.pprof -benchmem\n\n# Directories containing independent Go modules.\nMODULE_DIRS = . ./exp ./benchmarks ./zapgrpc/internal/test\n\n# Directories that we want to track coverage for.\nCOVER_DIRS = . ./exp\n\n.PHONY: all\nall: lint test\n\n.PHONY: lint\nlint: golangci-lint tidy-lint license-lint\n\n.PHONY: golangci-lint\ngolangci-lint:\n\t@$(foreach mod,$(MODULE_DIRS), \\\n\t\t(cd $(mod) && \\\n\t\techo \"[lint] golangci-lint: $(mod)\" && \\\n\t\tgolangci-lint run --path-prefix $(mod) ./...) &&) true\n\n.PHONY: tidy\ntidy:\n\t@$(foreach dir,$(MODULE_DIRS), \\\n\t\t(cd $(dir) && go mod tidy) &&) true\n\n.PHONY: tidy-lint\ntidy-lint:\n\t@$(foreach mod,$(MODULE_DIRS), \\\n\t\t(cd $(mod) && \\\n\t\techo \"[lint] tidy: $(mod)\" && \\\n\t\tgo mod tidy && \\\n\t\tgit diff --exit-code -- go.mod go.sum) &&) true\n\n\n.PHONY: license-lint\nlicense-lint:\n\t./checklicense.sh\n\n$(GOVULNCHECK):\n\tcd tools && go install golang.org/x/vuln/cmd/govulncheck\n\n.PHONY: test\ntest:\n\t@$(foreach dir,$(MODULE_DIRS),(cd $(dir) && go test -race ./...) &&) true\n\n.PHONY: cover\ncover:\n\t@$(foreach dir,$(COVER_DIRS), ( \\\n\t\tcd $(dir) && \\\n\t\tgo test -race -coverprofile=cover.out -coverpkg=./... ./... \\\n\t\t&& go tool cover -html=cover.out -o cover.html) &&) true\n\n.PHONY: bench\nBENCH ?= .\nbench:\n\t@$(foreach dir,$(MODULE_DIRS), ( \\\n\t\tcd $(dir) && \\\n\t\tgo list ./... | xargs -n1 go test -bench=$(BENCH) -run=\"^$$\" $(BENCH_FLAGS) \\\n\t) &&) true\n\n.PHONY: updatereadme\nupdatereadme:\n\trm -f README.md\n\tcat .readme.tmpl | go run internal/readme/readme.go > README.md\n\n.PHONY: vulncheck\nvulncheck: $(GOVULNCHECK)\n\t$(GOVULNCHECK) ./...\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.46484375,
          "content": "# :zap: zap\n\n\n<div align=\"center\">\n\nBlazing fast, structured, leveled logging in Go.\n\n![Zap logo](assets/logo.png)\n\n[![GoDoc][doc-img]][doc] [![Build Status][ci-img]][ci] [![Coverage Status][cov-img]][cov]\n\n</div>\n\n## Installation\n\n`go get -u go.uber.org/zap`\n\nNote that zap only supports the two most recent minor versions of Go.\n\n## Quick Start\n\nIn contexts where performance is nice, but not critical, use the\n`SugaredLogger`. It's 4-10x faster than other structured logging\npackages and includes both structured and `printf`-style APIs.\n\n```go\nlogger, _ := zap.NewProduction()\ndefer logger.Sync() // flushes buffer, if any\nsugar := logger.Sugar()\nsugar.Infow(\"failed to fetch URL\",\n  // Structured context as loosely typed key-value pairs.\n  \"url\", url,\n  \"attempt\", 3,\n  \"backoff\", time.Second,\n)\nsugar.Infof(\"Failed to fetch URL: %s\", url)\n```\n\nWhen performance and type safety are critical, use the `Logger`. It's even\nfaster than the `SugaredLogger` and allocates far less, but it only supports\nstructured logging.\n\n```go\nlogger, _ := zap.NewProduction()\ndefer logger.Sync()\nlogger.Info(\"failed to fetch URL\",\n  // Structured context as strongly typed Field values.\n  zap.String(\"url\", url),\n  zap.Int(\"attempt\", 3),\n  zap.Duration(\"backoff\", time.Second),\n)\n```\n\nSee the [documentation][doc] and [FAQ](FAQ.md) for more details.\n\n## Performance\n\nFor applications that log in the hot path, reflection-based serialization and\nstring formatting are prohibitively expensive &mdash; they're CPU-intensive\nand make many small allocations. Put differently, using `encoding/json` and\n`fmt.Fprintf` to log tons of `interface{}`s makes your application slow.\n\nZap takes a different approach. It includes a reflection-free, zero-allocation\nJSON encoder, and the base `Logger` strives to avoid serialization overhead\nand allocations wherever possible. By building the high-level `SugaredLogger`\non that foundation, zap lets users *choose* when they need to count every\nallocation and when they'd prefer a more familiar, loosely typed API.\n\nAs measured by its own [benchmarking suite][], not only is zap more performant\nthan comparable structured logging packages &mdash; it's also faster than the\nstandard library. Like all benchmarks, take these with a grain of salt.<sup\nid=\"anchor-versions\">[1](#footnote-versions)</sup>\n\nLog a message and 10 fields:\n\n| Package | Time | Time % to zap | Objects Allocated |\n| :------ | :--: | :-----------: | :---------------: |\n| :zap: zap | 656 ns/op | +0% | 5 allocs/op\n| :zap: zap (sugared) | 935 ns/op | +43% | 10 allocs/op\n| zerolog | 380 ns/op | -42% | 1 allocs/op\n| go-kit | 2249 ns/op | +243% | 57 allocs/op\n| slog (LogAttrs) | 2479 ns/op | +278% | 40 allocs/op\n| slog | 2481 ns/op | +278% | 42 allocs/op\n| apex/log | 9591 ns/op | +1362% | 63 allocs/op\n| log15 | 11393 ns/op | +1637% | 75 allocs/op\n| logrus | 11654 ns/op | +1677% | 79 allocs/op\n\nLog a message with a logger that already has 10 fields of context:\n\n| Package | Time | Time % to zap | Objects Allocated |\n| :------ | :--: | :-----------: | :---------------: |\n| :zap: zap | 67 ns/op | +0% | 0 allocs/op\n| :zap: zap (sugared) | 84 ns/op | +25% | 1 allocs/op\n| zerolog | 35 ns/op | -48% | 0 allocs/op\n| slog | 193 ns/op | +188% | 0 allocs/op\n| slog (LogAttrs) | 200 ns/op | +199% | 0 allocs/op\n| go-kit | 2460 ns/op | +3572% | 56 allocs/op\n| log15 | 9038 ns/op | +13390% | 70 allocs/op\n| apex/log | 9068 ns/op | +13434% | 53 allocs/op\n| logrus | 10521 ns/op | +15603% | 68 allocs/op\n\nLog a static string, without any context or `printf`-style templating:\n\n| Package | Time | Time % to zap | Objects Allocated |\n| :------ | :--: | :-----------: | :---------------: |\n| :zap: zap | 63 ns/op | +0% | 0 allocs/op\n| :zap: zap (sugared) | 81 ns/op | +29% | 1 allocs/op\n| zerolog | 32 ns/op | -49% | 0 allocs/op\n| standard library | 124 ns/op | +97% | 1 allocs/op\n| slog | 196 ns/op | +211% | 0 allocs/op\n| slog (LogAttrs) | 200 ns/op | +217% | 0 allocs/op\n| go-kit | 213 ns/op | +238% | 9 allocs/op\n| apex/log | 771 ns/op | +1124% | 5 allocs/op\n| logrus | 1439 ns/op | +2184% | 23 allocs/op\n| log15 | 2069 ns/op | +3184% | 20 allocs/op\n\n## Development Status: Stable\n\nAll APIs are finalized, and no breaking changes will be made in the 1.x series\nof releases. Users of semver-aware dependency management systems should pin\nzap to `^1`.\n\n## Contributing\n\nWe encourage and support an active, healthy community of contributors &mdash;\nincluding you! Details are in the [contribution guide](CONTRIBUTING.md) and\nthe [code of conduct](CODE_OF_CONDUCT.md). The zap maintainers keep an eye on\nissues and pull requests, but you can also report any negative conduct to\noss-conduct@uber.com. That email list is a private, safe space; even the zap\nmaintainers don't have access, so don't hesitate to hold us to a high\nstandard.\n\n<hr>\n\nReleased under the [MIT License](LICENSE).\n\n<sup id=\"footnote-versions\">1</sup> In particular, keep in mind that we may be\nbenchmarking against slightly older versions of other packages. Versions are\npinned in the [benchmarks/go.mod][] file. [â†©](#anchor-versions)\n\n[doc-img]: https://pkg.go.dev/badge/go.uber.org/zap\n[doc]: https://pkg.go.dev/go.uber.org/zap\n[ci-img]: https://github.com/uber-go/zap/actions/workflows/go.yml/badge.svg\n[ci]: https://github.com/uber-go/zap/actions/workflows/go.yml\n[cov-img]: https://codecov.io/gh/uber-go/zap/branch/master/graph/badge.svg\n[cov]: https://codecov.io/gh/uber-go/zap\n[benchmarking suite]: https://github.com/uber-go/zap/tree/master/benchmarks\n[benchmarks/go.mod]: https://github.com/uber-go/zap/blob/master/benchmarks/go.mod\n\n"
        },
        {
          "name": "array.go",
          "type": "blob",
          "size": 12.2431640625,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// Array constructs a field with the given key and ArrayMarshaler. It provides\n// a flexible, but still type-safe and efficient, way to add array-like types\n// to the logging context. The struct's MarshalLogArray method is called lazily.\nfunc Array(key string, val zapcore.ArrayMarshaler) Field {\n\treturn Field{Key: key, Type: zapcore.ArrayMarshalerType, Interface: val}\n}\n\n// Bools constructs a field that carries a slice of bools.\nfunc Bools(key string, bs []bool) Field {\n\treturn Array(key, bools(bs))\n}\n\n// ByteStrings constructs a field that carries a slice of []byte, each of which\n// must be UTF-8 encoded text.\nfunc ByteStrings(key string, bss [][]byte) Field {\n\treturn Array(key, byteStringsArray(bss))\n}\n\n// Complex128s constructs a field that carries a slice of complex numbers.\nfunc Complex128s(key string, nums []complex128) Field {\n\treturn Array(key, complex128s(nums))\n}\n\n// Complex64s constructs a field that carries a slice of complex numbers.\nfunc Complex64s(key string, nums []complex64) Field {\n\treturn Array(key, complex64s(nums))\n}\n\n// Durations constructs a field that carries a slice of time.Durations.\nfunc Durations(key string, ds []time.Duration) Field {\n\treturn Array(key, durations(ds))\n}\n\n// Float64s constructs a field that carries a slice of floats.\nfunc Float64s(key string, nums []float64) Field {\n\treturn Array(key, float64s(nums))\n}\n\n// Float32s constructs a field that carries a slice of floats.\nfunc Float32s(key string, nums []float32) Field {\n\treturn Array(key, float32s(nums))\n}\n\n// Ints constructs a field that carries a slice of integers.\nfunc Ints(key string, nums []int) Field {\n\treturn Array(key, ints(nums))\n}\n\n// Int64s constructs a field that carries a slice of integers.\nfunc Int64s(key string, nums []int64) Field {\n\treturn Array(key, int64s(nums))\n}\n\n// Int32s constructs a field that carries a slice of integers.\nfunc Int32s(key string, nums []int32) Field {\n\treturn Array(key, int32s(nums))\n}\n\n// Int16s constructs a field that carries a slice of integers.\nfunc Int16s(key string, nums []int16) Field {\n\treturn Array(key, int16s(nums))\n}\n\n// Int8s constructs a field that carries a slice of integers.\nfunc Int8s(key string, nums []int8) Field {\n\treturn Array(key, int8s(nums))\n}\n\n// Objects constructs a field with the given key, holding a list of the\n// provided objects that can be marshaled by Zap.\n//\n// Note that these objects must implement zapcore.ObjectMarshaler directly.\n// That is, if you're trying to marshal a []Request, the MarshalLogObject\n// method must be declared on the Request type, not its pointer (*Request).\n// If it's on the pointer, use ObjectValues.\n//\n// Given an object that implements MarshalLogObject on the value receiver, you\n// can log a slice of those objects with Objects like so:\n//\n//\ttype Author struct{ ... }\n//\tfunc (a Author) MarshalLogObject(enc zapcore.ObjectEncoder) error\n//\n//\tvar authors []Author = ...\n//\tlogger.Info(\"loading article\", zap.Objects(\"authors\", authors))\n//\n// Similarly, given a type that implements MarshalLogObject on its pointer\n// receiver, you can log a slice of pointers to that object with Objects like\n// so:\n//\n//\ttype Request struct{ ... }\n//\tfunc (r *Request) MarshalLogObject(enc zapcore.ObjectEncoder) error\n//\n//\tvar requests []*Request = ...\n//\tlogger.Info(\"sending requests\", zap.Objects(\"requests\", requests))\n//\n// If instead, you have a slice of values of such an object, use the\n// ObjectValues constructor.\n//\n//\tvar requests []Request = ...\n//\tlogger.Info(\"sending requests\", zap.ObjectValues(\"requests\", requests))\nfunc Objects[T zapcore.ObjectMarshaler](key string, values []T) Field {\n\treturn Array(key, objects[T](values))\n}\n\ntype objects[T zapcore.ObjectMarshaler] []T\n\nfunc (os objects[T]) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor _, o := range os {\n\t\tif err := arr.AppendObject(o); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// ObjectMarshalerPtr is a constraint that specifies that the given type\n// implements zapcore.ObjectMarshaler on a pointer receiver.\ntype ObjectMarshalerPtr[T any] interface {\n\t*T\n\tzapcore.ObjectMarshaler\n}\n\n// ObjectValues constructs a field with the given key, holding a list of the\n// provided objects, where pointers to these objects can be marshaled by Zap.\n//\n// Note that pointers to these objects must implement zapcore.ObjectMarshaler.\n// That is, if you're trying to marshal a []Request, the MarshalLogObject\n// method must be declared on the *Request type, not the value (Request).\n// If it's on the value, use Objects.\n//\n// Given an object that implements MarshalLogObject on the pointer receiver,\n// you can log a slice of those objects with ObjectValues like so:\n//\n//\ttype Request struct{ ... }\n//\tfunc (r *Request) MarshalLogObject(enc zapcore.ObjectEncoder) error\n//\n//\tvar requests []Request = ...\n//\tlogger.Info(\"sending requests\", zap.ObjectValues(\"requests\", requests))\n//\n// If instead, you have a slice of pointers of such an object, use the Objects\n// field constructor.\n//\n//\tvar requests []*Request = ...\n//\tlogger.Info(\"sending requests\", zap.Objects(\"requests\", requests))\nfunc ObjectValues[T any, P ObjectMarshalerPtr[T]](key string, values []T) Field {\n\treturn Array(key, objectValues[T, P](values))\n}\n\ntype objectValues[T any, P ObjectMarshalerPtr[T]] []T\n\nfunc (os objectValues[T, P]) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range os {\n\t\t// It is necessary for us to explicitly reference the \"P\" type.\n\t\t// We cannot simply pass \"&os[i]\" to AppendObject because its type\n\t\t// is \"*T\", which the type system does not consider as\n\t\t// implementing ObjectMarshaler.\n\t\t// Only the type \"P\" satisfies ObjectMarshaler, which we have\n\t\t// to convert \"*T\" to explicitly.\n\t\tvar p P = &os[i]\n\t\tif err := arr.AppendObject(p); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Strings constructs a field that carries a slice of strings.\nfunc Strings(key string, ss []string) Field {\n\treturn Array(key, stringArray(ss))\n}\n\n// Stringers constructs a field with the given key, holding a list of the\n// output provided by the value's String method\n//\n// Given an object that implements String on the value receiver, you\n// can log a slice of those objects with Objects like so:\n//\n//\ttype Request struct{ ... }\n//\tfunc (a Request) String() string\n//\n//\tvar requests []Request = ...\n//\tlogger.Info(\"sending requests\", zap.Stringers(\"requests\", requests))\n//\n// Note that these objects must implement fmt.Stringer directly.\n// That is, if you're trying to marshal a []Request, the String method\n// must be declared on the Request type, not its pointer (*Request).\nfunc Stringers[T fmt.Stringer](key string, values []T) Field {\n\treturn Array(key, stringers[T](values))\n}\n\ntype stringers[T fmt.Stringer] []T\n\nfunc (os stringers[T]) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor _, o := range os {\n\t\tarr.AppendString(o.String())\n\t}\n\treturn nil\n}\n\n// Times constructs a field that carries a slice of time.Times.\nfunc Times(key string, ts []time.Time) Field {\n\treturn Array(key, times(ts))\n}\n\n// Uints constructs a field that carries a slice of unsigned integers.\nfunc Uints(key string, nums []uint) Field {\n\treturn Array(key, uints(nums))\n}\n\n// Uint64s constructs a field that carries a slice of unsigned integers.\nfunc Uint64s(key string, nums []uint64) Field {\n\treturn Array(key, uint64s(nums))\n}\n\n// Uint32s constructs a field that carries a slice of unsigned integers.\nfunc Uint32s(key string, nums []uint32) Field {\n\treturn Array(key, uint32s(nums))\n}\n\n// Uint16s constructs a field that carries a slice of unsigned integers.\nfunc Uint16s(key string, nums []uint16) Field {\n\treturn Array(key, uint16s(nums))\n}\n\n// Uint8s constructs a field that carries a slice of unsigned integers.\nfunc Uint8s(key string, nums []uint8) Field {\n\treturn Array(key, uint8s(nums))\n}\n\n// Uintptrs constructs a field that carries a slice of pointer addresses.\nfunc Uintptrs(key string, us []uintptr) Field {\n\treturn Array(key, uintptrs(us))\n}\n\n// Errors constructs a field that carries a slice of errors.\nfunc Errors(key string, errs []error) Field {\n\treturn Array(key, errArray(errs))\n}\n\ntype bools []bool\n\nfunc (bs bools) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range bs {\n\t\tarr.AppendBool(bs[i])\n\t}\n\treturn nil\n}\n\ntype byteStringsArray [][]byte\n\nfunc (bss byteStringsArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range bss {\n\t\tarr.AppendByteString(bss[i])\n\t}\n\treturn nil\n}\n\ntype complex128s []complex128\n\nfunc (nums complex128s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendComplex128(nums[i])\n\t}\n\treturn nil\n}\n\ntype complex64s []complex64\n\nfunc (nums complex64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendComplex64(nums[i])\n\t}\n\treturn nil\n}\n\ntype durations []time.Duration\n\nfunc (ds durations) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range ds {\n\t\tarr.AppendDuration(ds[i])\n\t}\n\treturn nil\n}\n\ntype float64s []float64\n\nfunc (nums float64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendFloat64(nums[i])\n\t}\n\treturn nil\n}\n\ntype float32s []float32\n\nfunc (nums float32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendFloat32(nums[i])\n\t}\n\treturn nil\n}\n\ntype ints []int\n\nfunc (nums ints) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt(nums[i])\n\t}\n\treturn nil\n}\n\ntype int64s []int64\n\nfunc (nums int64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt64(nums[i])\n\t}\n\treturn nil\n}\n\ntype int32s []int32\n\nfunc (nums int32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt32(nums[i])\n\t}\n\treturn nil\n}\n\ntype int16s []int16\n\nfunc (nums int16s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt16(nums[i])\n\t}\n\treturn nil\n}\n\ntype int8s []int8\n\nfunc (nums int8s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendInt8(nums[i])\n\t}\n\treturn nil\n}\n\ntype stringArray []string\n\nfunc (ss stringArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range ss {\n\t\tarr.AppendString(ss[i])\n\t}\n\treturn nil\n}\n\ntype times []time.Time\n\nfunc (ts times) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range ts {\n\t\tarr.AppendTime(ts[i])\n\t}\n\treturn nil\n}\n\ntype uints []uint\n\nfunc (nums uints) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint64s []uint64\n\nfunc (nums uint64s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint64(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint32s []uint32\n\nfunc (nums uint32s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint32(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint16s []uint16\n\nfunc (nums uint16s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint16(nums[i])\n\t}\n\treturn nil\n}\n\ntype uint8s []uint8\n\nfunc (nums uint8s) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUint8(nums[i])\n\t}\n\treturn nil\n}\n\ntype uintptrs []uintptr\n\nfunc (nums uintptrs) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range nums {\n\t\tarr.AppendUintptr(nums[i])\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "array_test.go",
          "type": "blob",
          "size": 8.9052734375,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"go.uber.org/zap/zapcore\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc BenchmarkBoolsArrayMarshaler(b *testing.B) {\n\t// Keep this benchmark here to capture the overhead of the ArrayMarshaler\n\t// wrapper.\n\tbs := make([]bool, 50)\n\tenc := zapcore.NewJSONEncoder(zapcore.EncoderConfig{})\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tBools(\"array\", bs).AddTo(enc.Clone())\n\t}\n}\n\nfunc BenchmarkBoolsReflect(b *testing.B) {\n\tbs := make([]bool, 50)\n\tenc := zapcore.NewJSONEncoder(zapcore.EncoderConfig{})\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tReflect(\"array\", bs).AddTo(enc.Clone())\n\t}\n}\n\nfunc TestArrayWrappers(t *testing.T) {\n\ttests := []struct {\n\t\tdesc     string\n\t\tfield    Field\n\t\texpected []interface{}\n\t}{\n\t\t{\"empty bools\", Bools(\"\", []bool{}), []interface{}{}},\n\t\t{\"empty byte strings\", ByteStrings(\"\", [][]byte{}), []interface{}{}},\n\t\t{\"empty complex128s\", Complex128s(\"\", []complex128{}), []interface{}{}},\n\t\t{\"empty complex64s\", Complex64s(\"\", []complex64{}), []interface{}{}},\n\t\t{\"empty durations\", Durations(\"\", []time.Duration{}), []interface{}{}},\n\t\t{\"empty float64s\", Float64s(\"\", []float64{}), []interface{}{}},\n\t\t{\"empty float32s\", Float32s(\"\", []float32{}), []interface{}{}},\n\t\t{\"empty ints\", Ints(\"\", []int{}), []interface{}{}},\n\t\t{\"empty int64s\", Int64s(\"\", []int64{}), []interface{}{}},\n\t\t{\"empty int32s\", Int32s(\"\", []int32{}), []interface{}{}},\n\t\t{\"empty int16s\", Int16s(\"\", []int16{}), []interface{}{}},\n\t\t{\"empty int8s\", Int8s(\"\", []int8{}), []interface{}{}},\n\t\t{\"empty strings\", Strings(\"\", []string{}), []interface{}{}},\n\t\t{\"empty times\", Times(\"\", []time.Time{}), []interface{}{}},\n\t\t{\"empty uints\", Uints(\"\", []uint{}), []interface{}{}},\n\t\t{\"empty uint64s\", Uint64s(\"\", []uint64{}), []interface{}{}},\n\t\t{\"empty uint32s\", Uint32s(\"\", []uint32{}), []interface{}{}},\n\t\t{\"empty uint16s\", Uint16s(\"\", []uint16{}), []interface{}{}},\n\t\t{\"empty uint8s\", Uint8s(\"\", []uint8{}), []interface{}{}},\n\t\t{\"empty uintptrs\", Uintptrs(\"\", []uintptr{}), []interface{}{}},\n\t\t{\"bools\", Bools(\"\", []bool{true, false}), []interface{}{true, false}},\n\t\t{\"byte strings\", ByteStrings(\"\", [][]byte{{1, 2}, {3, 4}}), []interface{}{\"\\x01\\x02\", \"\\x03\\x04\"}},\n\t\t{\"complex128s\", Complex128s(\"\", []complex128{1 + 2i, 3 + 4i}), []interface{}{1 + 2i, 3 + 4i}},\n\t\t{\"complex64s\", Complex64s(\"\", []complex64{1 + 2i, 3 + 4i}), []interface{}{complex64(1 + 2i), complex64(3 + 4i)}},\n\t\t{\"durations\", Durations(\"\", []time.Duration{1, 2}), []interface{}{time.Nanosecond, 2 * time.Nanosecond}},\n\t\t{\"float64s\", Float64s(\"\", []float64{1.2, 3.4}), []interface{}{1.2, 3.4}},\n\t\t{\"float32s\", Float32s(\"\", []float32{1.2, 3.4}), []interface{}{float32(1.2), float32(3.4)}},\n\t\t{\"ints\", Ints(\"\", []int{1, 2}), []interface{}{1, 2}},\n\t\t{\"int64s\", Int64s(\"\", []int64{1, 2}), []interface{}{int64(1), int64(2)}},\n\t\t{\"int32s\", Int32s(\"\", []int32{1, 2}), []interface{}{int32(1), int32(2)}},\n\t\t{\"int16s\", Int16s(\"\", []int16{1, 2}), []interface{}{int16(1), int16(2)}},\n\t\t{\"int8s\", Int8s(\"\", []int8{1, 2}), []interface{}{int8(1), int8(2)}},\n\t\t{\"strings\", Strings(\"\", []string{\"foo\", \"bar\"}), []interface{}{\"foo\", \"bar\"}},\n\t\t{\"times\", Times(\"\", []time.Time{time.Unix(0, 0), time.Unix(0, 0)}), []interface{}{time.Unix(0, 0), time.Unix(0, 0)}},\n\t\t{\"uints\", Uints(\"\", []uint{1, 2}), []interface{}{uint(1), uint(2)}},\n\t\t{\"uint64s\", Uint64s(\"\", []uint64{1, 2}), []interface{}{uint64(1), uint64(2)}},\n\t\t{\"uint32s\", Uint32s(\"\", []uint32{1, 2}), []interface{}{uint32(1), uint32(2)}},\n\t\t{\"uint16s\", Uint16s(\"\", []uint16{1, 2}), []interface{}{uint16(1), uint16(2)}},\n\t\t{\"uint8s\", Uint8s(\"\", []uint8{1, 2}), []interface{}{uint8(1), uint8(2)}},\n\t\t{\"uintptrs\", Uintptrs(\"\", []uintptr{1, 2}), []interface{}{uintptr(1), uintptr(2)}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tenc := zapcore.NewMapObjectEncoder()\n\t\ttt.field.Key = \"k\"\n\t\ttt.field.AddTo(enc)\n\t\tassert.Equal(t, tt.expected, enc.Fields[\"k\"], \"%s: unexpected map contents.\", tt.desc)\n\t\tassert.Equal(t, 1, len(enc.Fields), \"%s: found extra keys in map: %v\", tt.desc, enc.Fields)\n\t}\n}\n\nfunc TestObjectsAndObjectValues(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tdesc string\n\t\tgive Field\n\t\twant []any\n\t}{\n\t\t{\n\t\t\tdesc: \"Objects/nil slice\",\n\t\t\tgive: Objects[*emptyObject](\"\", nil),\n\t\t\twant: []any{},\n\t\t},\n\t\t{\n\t\t\tdesc: \"ObjectValues/nil slice\",\n\t\t\tgive: ObjectValues[emptyObject](\"\", nil),\n\t\t\twant: []any{},\n\t\t},\n\t\t{\n\t\t\tdesc: \"ObjectValues/empty slice\",\n\t\t\tgive: ObjectValues(\"\", []emptyObject{}),\n\t\t\twant: []any{},\n\t\t},\n\t\t{\n\t\t\tdesc: \"ObjectValues/single item\",\n\t\t\tgive: ObjectValues(\"\", []emptyObject{\n\t\t\t\t{},\n\t\t\t}),\n\t\t\twant: []any{\n\t\t\t\tmap[string]any{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"Objects/multiple different objects\",\n\t\t\tgive: Objects(\"\", []*fakeObject{\n\t\t\t\t{value: \"foo\"},\n\t\t\t\t{value: \"bar\"},\n\t\t\t\t{value: \"baz\"},\n\t\t\t}),\n\t\t\twant: []any{\n\t\t\t\tmap[string]any{\"value\": \"foo\"},\n\t\t\t\tmap[string]any{\"value\": \"bar\"},\n\t\t\t\tmap[string]any{\"value\": \"baz\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"ObjectValues/multiple different objects\",\n\t\t\tgive: ObjectValues(\"\", []fakeObject{\n\t\t\t\t{value: \"foo\"},\n\t\t\t\t{value: \"bar\"},\n\t\t\t\t{value: \"baz\"},\n\t\t\t}),\n\t\t\twant: []any{\n\t\t\t\tmap[string]any{\"value\": \"foo\"},\n\t\t\t\tmap[string]any{\"value\": \"bar\"},\n\t\t\t\tmap[string]any{\"value\": \"baz\"},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\ttt.give.Key = \"k\"\n\n\t\t\tenc := zapcore.NewMapObjectEncoder()\n\t\t\ttt.give.AddTo(enc)\n\t\t\tassert.Equal(t, tt.want, enc.Fields[\"k\"])\n\t\t})\n\t}\n}\n\ntype emptyObject struct{}\n\nfunc (*emptyObject) MarshalLogObject(zapcore.ObjectEncoder) error {\n\treturn nil\n}\n\ntype fakeObject struct {\n\tvalue string\n\terr   error // marshaling error, if any\n}\n\nfunc (o *fakeObject) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\tenc.AddString(\"value\", o.value)\n\treturn o.err\n}\n\nfunc TestObjectsAndObjectValues_marshalError(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tdesc    string\n\t\tgive    Field\n\t\twant    []any\n\t\twantErr string\n\t}{\n\t\t{\n\t\t\tdesc: \"Objects\",\n\t\t\tgive: Objects(\"\", []*fakeObject{\n\t\t\t\t{value: \"foo\"},\n\t\t\t\t{value: \"bar\", err: errors.New(\"great sadness\")},\n\t\t\t\t{value: \"baz\"}, // does not get marshaled\n\t\t\t}),\n\t\t\twant: []any{\n\t\t\t\tmap[string]any{\"value\": \"foo\"},\n\t\t\t\tmap[string]any{\"value\": \"bar\"},\n\t\t\t},\n\t\t\twantErr: \"great sadness\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"ObjectValues\",\n\t\t\tgive: ObjectValues(\"\", []fakeObject{\n\t\t\t\t{value: \"foo\"},\n\t\t\t\t{value: \"bar\", err: errors.New(\"stuff failed\")},\n\t\t\t\t{value: \"baz\"}, // does not get marshaled\n\t\t\t}),\n\t\t\twant: []any{\n\t\t\t\tmap[string]any{\"value\": \"foo\"},\n\t\t\t\tmap[string]any{\"value\": \"bar\"},\n\t\t\t},\n\t\t\twantErr: \"stuff failed\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\ttt.give.Key = \"k\"\n\n\t\t\tenc := zapcore.NewMapObjectEncoder()\n\t\t\ttt.give.AddTo(enc)\n\n\t\t\trequire.Contains(t, enc.Fields, \"k\")\n\t\t\tassert.Equal(t, tt.want, enc.Fields[\"k\"])\n\n\t\t\t// AddTo puts the error in a \"%vError\" field based on the name of the\n\t\t\t// original field.\n\t\t\trequire.Contains(t, enc.Fields, \"kError\")\n\t\t\tassert.Equal(t, tt.wantErr, enc.Fields[\"kError\"])\n\t\t})\n\t}\n}\n\ntype stringerObject struct {\n\tvalue string\n}\n\nfunc (s stringerObject) String() string {\n\treturn s.value\n}\n\nfunc TestStringers(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tdesc string\n\t\tgive Field\n\t\twant []any\n\t}{\n\t\t{\n\t\t\tdesc: \"Stringers\",\n\t\t\tgive: Stringers(\"\", []stringerObject{\n\t\t\t\t{value: \"foo\"},\n\t\t\t\t{value: \"bar\"},\n\t\t\t\t{value: \"baz\"},\n\t\t\t}),\n\t\t\twant: []any{\n\t\t\t\t\"foo\",\n\t\t\t\t\"bar\",\n\t\t\t\t\"baz\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc: \"Stringers with []fmt.Stringer\",\n\t\t\tgive: Stringers(\"\", []fmt.Stringer{\n\t\t\t\tstringerObject{value: \"foo\"},\n\t\t\t\tstringerObject{value: \"bar\"},\n\t\t\t\tstringerObject{value: \"baz\"},\n\t\t\t}),\n\t\t\twant: []any{\n\t\t\t\t\"foo\",\n\t\t\t\t\"bar\",\n\t\t\t\t\"baz\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\ttt.give.Key = \"k\"\n\n\t\t\tenc := zapcore.NewMapObjectEncoder()\n\t\t\ttt.give.AddTo(enc)\n\t\t\tassert.Equal(t, tt.want, enc.Fields[\"k\"])\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "benchmarks",
          "type": "tree",
          "content": null
        },
        {
          "name": "buffer",
          "type": "tree",
          "content": null
        },
        {
          "name": "checklicense.sh",
          "type": "blob",
          "size": 0.287109375,
          "content": "#!/bin/bash -e\n\nERROR_COUNT=0\nwhile read -r file\ndo\n\tcase \"$(head -1 \"${file}\")\" in\n\t\t*\"Copyright (c) \"*\" Uber Technologies, Inc.\")\n\t\t\t# everything's cool\n\t\t\t;;\n\t\t*)\n\t\t\techo \"$file is missing license header.\"\n\t\t\t(( ERROR_COUNT++ ))\n\t\t\t;;\n\tesac\ndone < <(git ls-files \"*\\.go\")\n\nexit $ERROR_COUNT\n"
        },
        {
          "name": "clock_test.go",
          "type": "blob",
          "size": 1.8193359375,
          "content": "// Copyright (c) 2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/zap/zaptest/observer\"\n)\n\ntype constantClock time.Time\n\nfunc (c constantClock) Now() time.Time { return time.Time(c) }\nfunc (c constantClock) NewTicker(d time.Duration) *time.Ticker {\n\treturn &time.Ticker{}\n}\n\nfunc TestWithClock(t *testing.T) {\n\tdate := time.Date(2077, 1, 23, 10, 15, 13, 441, time.UTC)\n\tclock := constantClock(date)\n\twithLogger(t, DebugLevel, []Option{WithClock(clock)}, func(log *Logger, logs *observer.ObservedLogs) {\n\t\tlog.Info(\"\")\n\t\trequire.Equal(t, 1, logs.Len(), \"Expected only one log entry to be written.\")\n\t\tassert.Equal(t, date, logs.All()[0].Time, \"Unexpected entry time.\")\n\t})\n}\n"
        },
        {
          "name": "common_test.go",
          "type": "blob",
          "size": 1.9853515625,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"sync\"\n\t\"testing\"\n\n\t\"go.uber.org/zap/zapcore\"\n\t\"go.uber.org/zap/zaptest/observer\"\n)\n\nfunc opts(opts ...Option) []Option {\n\treturn opts\n}\n\n// Here specifically to introduce an easily-identifiable filename for testing\n// stacktraces and caller skips.\nfunc withLogger(t testing.TB, e zapcore.LevelEnabler, opts []Option, f func(*Logger, *observer.ObservedLogs)) {\n\tfac, logs := observer.New(e)\n\tlog := New(fac, opts...)\n\tf(log, logs)\n}\n\nfunc withSugar(t testing.TB, e zapcore.LevelEnabler, opts []Option, f func(*SugaredLogger, *observer.ObservedLogs)) {\n\twithLogger(t, e, opts, func(logger *Logger, logs *observer.ObservedLogs) { f(logger.Sugar(), logs) })\n}\n\nfunc runConcurrently(goroutines, iterations int, wg *sync.WaitGroup, f func()) {\n\twg.Add(goroutines)\n\tfor g := 0; g < goroutines; g++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor i := 0; i < iterations; i++ {\n\t\t\t\tf()\n\t\t\t}\n\t\t}()\n\t}\n}\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 11.9501953125,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"errors\"\n\t\"sort\"\n\t\"time\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// SamplingConfig sets a sampling strategy for the logger. Sampling caps the\n// global CPU and I/O load that logging puts on your process while attempting\n// to preserve a representative subset of your logs.\n//\n// If specified, the Sampler will invoke the Hook after each decision.\n//\n// Values configured here are per-second. See zapcore.NewSamplerWithOptions for\n// details.\ntype SamplingConfig struct {\n\tInitial    int                                           `json:\"initial\" yaml:\"initial\"`\n\tThereafter int                                           `json:\"thereafter\" yaml:\"thereafter\"`\n\tHook       func(zapcore.Entry, zapcore.SamplingDecision) `json:\"-\" yaml:\"-\"`\n}\n\n// Config offers a declarative way to construct a logger. It doesn't do\n// anything that can't be done with New, Options, and the various\n// zapcore.WriteSyncer and zapcore.Core wrappers, but it's a simpler way to\n// toggle common options.\n//\n// Note that Config intentionally supports only the most common options. More\n// unusual logging setups (logging to network connections or message queues,\n// splitting output between multiple files, etc.) are possible, but require\n// direct use of the zapcore package. For sample code, see the package-level\n// BasicConfiguration and AdvancedConfiguration examples.\n//\n// For an example showing runtime log level changes, see the documentation for\n// AtomicLevel.\ntype Config struct {\n\t// Level is the minimum enabled logging level. Note that this is a dynamic\n\t// level, so calling Config.Level.SetLevel will atomically change the log\n\t// level of all loggers descended from this config.\n\tLevel AtomicLevel `json:\"level\" yaml:\"level\"`\n\t// Development puts the logger in development mode, which changes the\n\t// behavior of DPanicLevel and takes stacktraces more liberally.\n\tDevelopment bool `json:\"development\" yaml:\"development\"`\n\t// DisableCaller stops annotating logs with the calling function's file\n\t// name and line number. By default, all logs are annotated.\n\tDisableCaller bool `json:\"disableCaller\" yaml:\"disableCaller\"`\n\t// DisableStacktrace completely disables automatic stacktrace capturing. By\n\t// default, stacktraces are captured for WarnLevel and above logs in\n\t// development and ErrorLevel and above in production.\n\tDisableStacktrace bool `json:\"disableStacktrace\" yaml:\"disableStacktrace\"`\n\t// Sampling sets a sampling policy. A nil SamplingConfig disables sampling.\n\tSampling *SamplingConfig `json:\"sampling\" yaml:\"sampling\"`\n\t// Encoding sets the logger's encoding. Valid values are \"json\" and\n\t// \"console\", as well as any third-party encodings registered via\n\t// RegisterEncoder.\n\tEncoding string `json:\"encoding\" yaml:\"encoding\"`\n\t// EncoderConfig sets options for the chosen encoder. See\n\t// zapcore.EncoderConfig for details.\n\tEncoderConfig zapcore.EncoderConfig `json:\"encoderConfig\" yaml:\"encoderConfig\"`\n\t// OutputPaths is a list of URLs or file paths to write logging output to.\n\t// See Open for details.\n\tOutputPaths []string `json:\"outputPaths\" yaml:\"outputPaths\"`\n\t// ErrorOutputPaths is a list of URLs to write internal logger errors to.\n\t// The default is standard error.\n\t//\n\t// Note that this setting only affects internal errors; for sample code that\n\t// sends error-level logs to a different location from info- and debug-level\n\t// logs, see the package-level AdvancedConfiguration example.\n\tErrorOutputPaths []string `json:\"errorOutputPaths\" yaml:\"errorOutputPaths\"`\n\t// InitialFields is a collection of fields to add to the root logger.\n\tInitialFields map[string]interface{} `json:\"initialFields\" yaml:\"initialFields\"`\n}\n\n// NewProductionEncoderConfig returns an opinionated EncoderConfig for\n// production environments.\n//\n// Messages encoded with this configuration will be JSON-formatted\n// and will have the following keys by default:\n//\n//   - \"level\": The logging level (e.g. \"info\", \"error\").\n//   - \"ts\": The current time in number of seconds since the Unix epoch.\n//   - \"msg\": The message passed to the log statement.\n//   - \"caller\": If available, a short path to the file and line number\n//     where the log statement was issued.\n//     The logger configuration determines whether this field is captured.\n//   - \"stacktrace\": If available, a stack trace from the line\n//     where the log statement was issued.\n//     The logger configuration determines whether this field is captured.\n//\n// By default, the following formats are used for different types:\n//\n//   - Time is formatted as floating-point number of seconds since the Unix\n//     epoch.\n//   - Duration is formatted as floating-point number of seconds.\n//\n// You may change these by setting the appropriate fields in the returned\n// object.\n// For example, use the following to change the time encoding format:\n//\n//\tcfg := zap.NewProductionEncoderConfig()\n//\tcfg.EncodeTime = zapcore.ISO8601TimeEncoder\nfunc NewProductionEncoderConfig() zapcore.EncoderConfig {\n\treturn zapcore.EncoderConfig{\n\t\tTimeKey:        \"ts\",\n\t\tLevelKey:       \"level\",\n\t\tNameKey:        \"logger\",\n\t\tCallerKey:      \"caller\",\n\t\tFunctionKey:    zapcore.OmitKey,\n\t\tMessageKey:     \"msg\",\n\t\tStacktraceKey:  \"stacktrace\",\n\t\tLineEnding:     zapcore.DefaultLineEnding,\n\t\tEncodeLevel:    zapcore.LowercaseLevelEncoder,\n\t\tEncodeTime:     zapcore.EpochTimeEncoder,\n\t\tEncodeDuration: zapcore.SecondsDurationEncoder,\n\t\tEncodeCaller:   zapcore.ShortCallerEncoder,\n\t}\n}\n\n// NewProductionConfig builds a reasonable default production logging\n// configuration.\n// Logging is enabled at InfoLevel and above, and uses a JSON encoder.\n// Logs are written to standard error.\n// Stacktraces are included on logs of ErrorLevel and above.\n// DPanicLevel logs will not panic, but will write a stacktrace.\n//\n// Sampling is enabled at 100:100 by default,\n// meaning that after the first 100 log entries\n// with the same level and message in the same second,\n// it will log every 100th entry\n// with the same level and message in the same second.\n// You may disable this behavior by setting Sampling to nil.\n//\n// See [NewProductionEncoderConfig] for information\n// on the default encoder configuration.\nfunc NewProductionConfig() Config {\n\treturn Config{\n\t\tLevel:       NewAtomicLevelAt(InfoLevel),\n\t\tDevelopment: false,\n\t\tSampling: &SamplingConfig{\n\t\t\tInitial:    100,\n\t\t\tThereafter: 100,\n\t\t},\n\t\tEncoding:         \"json\",\n\t\tEncoderConfig:    NewProductionEncoderConfig(),\n\t\tOutputPaths:      []string{\"stderr\"},\n\t\tErrorOutputPaths: []string{\"stderr\"},\n\t}\n}\n\n// NewDevelopmentEncoderConfig returns an opinionated EncoderConfig for\n// development environments.\n//\n// Messages encoded with this configuration will use Zap's console encoder\n// intended to print human-readable output.\n// It will print log messages with the following information:\n//\n//   - The log level (e.g. \"INFO\", \"ERROR\").\n//   - The time in ISO8601 format (e.g. \"2017-01-01T12:00:00Z\").\n//   - The message passed to the log statement.\n//   - If available, a short path to the file and line number\n//     where the log statement was issued.\n//     The logger configuration determines whether this field is captured.\n//   - If available, a stacktrace from the line\n//     where the log statement was issued.\n//     The logger configuration determines whether this field is captured.\n//\n// By default, the following formats are used for different types:\n//\n//   - Time is formatted in ISO8601 format (e.g. \"2017-01-01T12:00:00Z\").\n//   - Duration is formatted as a string (e.g. \"1.234s\").\n//\n// You may change these by setting the appropriate fields in the returned\n// object.\n// For example, use the following to change the time encoding format:\n//\n//\tcfg := zap.NewDevelopmentEncoderConfig()\n//\tcfg.EncodeTime = zapcore.ISO8601TimeEncoder\nfunc NewDevelopmentEncoderConfig() zapcore.EncoderConfig {\n\treturn zapcore.EncoderConfig{\n\t\t// Keys can be anything except the empty string.\n\t\tTimeKey:        \"T\",\n\t\tLevelKey:       \"L\",\n\t\tNameKey:        \"N\",\n\t\tCallerKey:      \"C\",\n\t\tFunctionKey:    zapcore.OmitKey,\n\t\tMessageKey:     \"M\",\n\t\tStacktraceKey:  \"S\",\n\t\tLineEnding:     zapcore.DefaultLineEnding,\n\t\tEncodeLevel:    zapcore.CapitalLevelEncoder,\n\t\tEncodeTime:     zapcore.ISO8601TimeEncoder,\n\t\tEncodeDuration: zapcore.StringDurationEncoder,\n\t\tEncodeCaller:   zapcore.ShortCallerEncoder,\n\t}\n}\n\n// NewDevelopmentConfig builds a reasonable default development logging\n// configuration.\n// Logging is enabled at DebugLevel and above, and uses a console encoder.\n// Logs are written to standard error.\n// Stacktraces are included on logs of WarnLevel and above.\n// DPanicLevel logs will panic.\n//\n// See [NewDevelopmentEncoderConfig] for information\n// on the default encoder configuration.\nfunc NewDevelopmentConfig() Config {\n\treturn Config{\n\t\tLevel:            NewAtomicLevelAt(DebugLevel),\n\t\tDevelopment:      true,\n\t\tEncoding:         \"console\",\n\t\tEncoderConfig:    NewDevelopmentEncoderConfig(),\n\t\tOutputPaths:      []string{\"stderr\"},\n\t\tErrorOutputPaths: []string{\"stderr\"},\n\t}\n}\n\n// Build constructs a logger from the Config and Options.\nfunc (cfg Config) Build(opts ...Option) (*Logger, error) {\n\tenc, err := cfg.buildEncoder()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsink, errSink, err := cfg.openSinks()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cfg.Level == (AtomicLevel{}) {\n\t\treturn nil, errors.New(\"missing Level\")\n\t}\n\n\tlog := New(\n\t\tzapcore.NewCore(enc, sink, cfg.Level),\n\t\tcfg.buildOptions(errSink)...,\n\t)\n\tif len(opts) > 0 {\n\t\tlog = log.WithOptions(opts...)\n\t}\n\treturn log, nil\n}\n\nfunc (cfg Config) buildOptions(errSink zapcore.WriteSyncer) []Option {\n\topts := []Option{ErrorOutput(errSink)}\n\n\tif cfg.Development {\n\t\topts = append(opts, Development())\n\t}\n\n\tif !cfg.DisableCaller {\n\t\topts = append(opts, AddCaller())\n\t}\n\n\tstackLevel := ErrorLevel\n\tif cfg.Development {\n\t\tstackLevel = WarnLevel\n\t}\n\tif !cfg.DisableStacktrace {\n\t\topts = append(opts, AddStacktrace(stackLevel))\n\t}\n\n\tif scfg := cfg.Sampling; scfg != nil {\n\t\topts = append(opts, WrapCore(func(core zapcore.Core) zapcore.Core {\n\t\t\tvar samplerOpts []zapcore.SamplerOption\n\t\t\tif scfg.Hook != nil {\n\t\t\t\tsamplerOpts = append(samplerOpts, zapcore.SamplerHook(scfg.Hook))\n\t\t\t}\n\t\t\treturn zapcore.NewSamplerWithOptions(\n\t\t\t\tcore,\n\t\t\t\ttime.Second,\n\t\t\t\tcfg.Sampling.Initial,\n\t\t\t\tcfg.Sampling.Thereafter,\n\t\t\t\tsamplerOpts...,\n\t\t\t)\n\t\t}))\n\t}\n\n\tif len(cfg.InitialFields) > 0 {\n\t\tfs := make([]Field, 0, len(cfg.InitialFields))\n\t\tkeys := make([]string, 0, len(cfg.InitialFields))\n\t\tfor k := range cfg.InitialFields {\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t\tsort.Strings(keys)\n\t\tfor _, k := range keys {\n\t\t\tfs = append(fs, Any(k, cfg.InitialFields[k]))\n\t\t}\n\t\topts = append(opts, Fields(fs...))\n\t}\n\n\treturn opts\n}\n\nfunc (cfg Config) openSinks() (zapcore.WriteSyncer, zapcore.WriteSyncer, error) {\n\tsink, closeOut, err := Open(cfg.OutputPaths...)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\terrSink, _, err := Open(cfg.ErrorOutputPaths...)\n\tif err != nil {\n\t\tcloseOut()\n\t\treturn nil, nil, err\n\t}\n\treturn sink, errSink, nil\n}\n\nfunc (cfg Config) buildEncoder() (zapcore.Encoder, error) {\n\treturn newEncoder(cfg.Encoding, cfg.EncoderConfig)\n}\n"
        },
        {
          "name": "config_test.go",
          "type": "blob",
          "size": 6.3486328125,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync/atomic\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\nfunc TestConfig(t *testing.T) {\n\ttests := []struct {\n\t\tdesc     string\n\t\tcfg      Config\n\t\texpectN  int64\n\t\texpectRe string\n\t}{\n\t\t{\n\t\t\tdesc:    \"production\",\n\t\t\tcfg:     NewProductionConfig(),\n\t\t\texpectN: 2 + 100 + 1, // 2 from initial logs, 100 initial sampled logs, 1 from off-by-one in sampler\n\t\t\texpectRe: `{\"level\":\"info\",\"caller\":\"[a-z0-9_-]+/config_test.go:\\d+\",\"msg\":\"info\",\"k\":\"v\",\"z\":\"zz\"}` + \"\\n\" +\n\t\t\t\t`{\"level\":\"warn\",\"caller\":\"[a-z0-9_-]+/config_test.go:\\d+\",\"msg\":\"warn\",\"k\":\"v\",\"z\":\"zz\"}` + \"\\n\",\n\t\t},\n\t\t{\n\t\t\tdesc:    \"development\",\n\t\t\tcfg:     NewDevelopmentConfig(),\n\t\t\texpectN: 3 + 200, // 3 initial logs, all 200 subsequent logs\n\t\t\texpectRe: \"DEBUG\\t[a-z0-9_-]+/config_test.go:\" + `\\d+` + \"\\tdebug\\t\" + `{\"k\": \"v\", \"z\": \"zz\"}` + \"\\n\" +\n\t\t\t\t\"INFO\\t[a-z0-9_-]+/config_test.go:\" + `\\d+` + \"\\tinfo\\t\" + `{\"k\": \"v\", \"z\": \"zz\"}` + \"\\n\" +\n\t\t\t\t\"WARN\\t[a-z0-9_-]+/config_test.go:\" + `\\d+` + \"\\twarn\\t\" + `{\"k\": \"v\", \"z\": \"zz\"}` + \"\\n\" +\n\t\t\t\t`go.uber.org/zap.TestConfig.\\w+`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tlogOut := filepath.Join(t.TempDir(), \"test.log\")\n\n\t\t\ttt.cfg.OutputPaths = []string{logOut}\n\t\t\ttt.cfg.EncoderConfig.TimeKey = \"\" // no timestamps in tests\n\t\t\ttt.cfg.InitialFields = map[string]interface{}{\"z\": \"zz\", \"k\": \"v\"}\n\n\t\t\thook, count := makeCountingHook()\n\t\t\tlogger, err := tt.cfg.Build(Hooks(hook))\n\t\t\trequire.NoError(t, err, \"Unexpected error constructing logger.\")\n\n\t\t\tlogger.Debug(\"debug\")\n\t\t\tlogger.Info(\"info\")\n\t\t\tlogger.Warn(\"warn\")\n\n\t\t\tbyteContents, err := os.ReadFile(logOut)\n\t\t\trequire.NoError(t, err, \"Couldn't read log contents from temp file.\")\n\t\t\tlogs := string(byteContents)\n\t\t\tassert.Regexp(t, tt.expectRe, logs, \"Unexpected log output.\")\n\n\t\t\tfor i := 0; i < 200; i++ {\n\t\t\t\tlogger.Info(\"sampling\")\n\t\t\t}\n\t\t\tassert.Equal(t, tt.expectN, count.Load(), \"Hook called an unexpected number of times.\")\n\t\t})\n\t}\n}\n\nfunc TestConfigWithInvalidPaths(t *testing.T) {\n\ttests := []struct {\n\t\tdesc      string\n\t\toutput    string\n\t\terrOutput string\n\t}{\n\t\t{\"output directory doesn't exist\", \"/tmp/not-there/foo.log\", \"stderr\"},\n\t\t{\"error output directory doesn't exist\", \"stdout\", \"/tmp/not-there/foo-errors.log\"},\n\t\t{\"neither output directory exists\", \"/tmp/not-there/foo.log\", \"/tmp/not-there/foo-errors.log\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tcfg := NewProductionConfig()\n\t\t\tcfg.OutputPaths = []string{tt.output}\n\t\t\tcfg.ErrorOutputPaths = []string{tt.errOutput}\n\t\t\t_, err := cfg.Build()\n\t\t\tassert.Error(t, err, \"Expected an error opening a non-existent directory.\")\n\t\t})\n\t}\n}\n\nfunc TestConfigWithMissingAttributes(t *testing.T) {\n\ttests := []struct {\n\t\tdesc      string\n\t\tcfg       Config\n\t\texpectErr string\n\t}{\n\t\t{\n\t\t\tdesc: \"missing level\",\n\t\t\tcfg: Config{\n\t\t\t\tEncoding: \"json\",\n\t\t\t},\n\t\t\texpectErr: \"missing Level\",\n\t\t},\n\t\t{\n\t\t\tdesc: \"missing encoder time in encoder config\",\n\t\t\tcfg: Config{\n\t\t\t\tLevel:    NewAtomicLevelAt(zapcore.InfoLevel),\n\t\t\t\tEncoding: \"json\",\n\t\t\t\tEncoderConfig: zapcore.EncoderConfig{\n\t\t\t\t\tMessageKey: \"msg\",\n\t\t\t\t\tTimeKey:    \"ts\",\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectErr: \"missing EncodeTime in EncoderConfig\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tcfg := tt.cfg\n\t\t\t_, err := cfg.Build()\n\t\t\tassert.EqualError(t, err, tt.expectErr)\n\t\t})\n\t}\n}\n\nfunc makeSamplerCountingHook() (h func(zapcore.Entry, zapcore.SamplingDecision),\n\tdropped, sampled *atomic.Int64,\n) {\n\tdropped = new(atomic.Int64)\n\tsampled = new(atomic.Int64)\n\th = func(_ zapcore.Entry, dec zapcore.SamplingDecision) {\n\t\tif dec&zapcore.LogDropped > 0 {\n\t\t\tdropped.Add(1)\n\t\t} else if dec&zapcore.LogSampled > 0 {\n\t\t\tsampled.Add(1)\n\t\t}\n\t}\n\treturn h, dropped, sampled\n}\n\nfunc TestConfigWithSamplingHook(t *testing.T) {\n\tshook, dcount, scount := makeSamplerCountingHook()\n\tcfg := Config{\n\t\tLevel:       NewAtomicLevelAt(InfoLevel),\n\t\tDevelopment: false,\n\t\tSampling: &SamplingConfig{\n\t\t\tInitial:    100,\n\t\t\tThereafter: 100,\n\t\t\tHook:       shook,\n\t\t},\n\t\tEncoding:         \"json\",\n\t\tEncoderConfig:    NewProductionEncoderConfig(),\n\t\tOutputPaths:      []string{\"stderr\"},\n\t\tErrorOutputPaths: []string{\"stderr\"},\n\t}\n\texpectRe := `{\"level\":\"info\",\"caller\":\"[a-z0-9_-]+/config_test.go:\\d+\",\"msg\":\"info\",\"k\":\"v\",\"z\":\"zz\"}` + \"\\n\" +\n\t\t`{\"level\":\"warn\",\"caller\":\"[a-z0-9_-]+/config_test.go:\\d+\",\"msg\":\"warn\",\"k\":\"v\",\"z\":\"zz\"}` + \"\\n\"\n\texpectDropped := 99  // 200 - 100 initial - 1 thereafter\n\texpectSampled := 103 // 2 from initial + 100 + 1 thereafter\n\n\tlogOut := filepath.Join(t.TempDir(), \"test.log\")\n\tcfg.OutputPaths = []string{logOut}\n\tcfg.EncoderConfig.TimeKey = \"\" // no timestamps in tests\n\tcfg.InitialFields = map[string]interface{}{\"z\": \"zz\", \"k\": \"v\"}\n\n\tlogger, err := cfg.Build()\n\trequire.NoError(t, err, \"Unexpected error constructing logger.\")\n\n\tlogger.Debug(\"debug\")\n\tlogger.Info(\"info\")\n\tlogger.Warn(\"warn\")\n\n\tbyteContents, err := os.ReadFile(logOut)\n\trequire.NoError(t, err, \"Couldn't read log contents from temp file.\")\n\tlogs := string(byteContents)\n\tassert.Regexp(t, expectRe, logs, \"Unexpected log output.\")\n\n\tfor i := 0; i < 200; i++ {\n\t\tlogger.Info(\"sampling\")\n\t}\n\tassert.Equal(t, int64(expectDropped), dcount.Load())\n\tassert.Equal(t, int64(expectSampled), scount.Load())\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 5.125,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Package zap provides fast, structured, leveled logging.\n//\n// For applications that log in the hot path, reflection-based serialization\n// and string formatting are prohibitively expensive - they're CPU-intensive\n// and make many small allocations. Put differently, using json.Marshal and\n// fmt.Fprintf to log tons of interface{} makes your application slow.\n//\n// Zap takes a different approach. It includes a reflection-free,\n// zero-allocation JSON encoder, and the base Logger strives to avoid\n// serialization overhead and allocations wherever possible. By building the\n// high-level SugaredLogger on that foundation, zap lets users choose when\n// they need to count every allocation and when they'd prefer a more familiar,\n// loosely typed API.\n//\n// # Choosing a Logger\n//\n// In contexts where performance is nice, but not critical, use the\n// SugaredLogger. It's 4-10x faster than other structured logging packages and\n// supports both structured and printf-style logging. Like log15 and go-kit,\n// the SugaredLogger's structured logging APIs are loosely typed and accept a\n// variadic number of key-value pairs. (For more advanced use cases, they also\n// accept strongly typed fields - see the SugaredLogger.With documentation for\n// details.)\n//\n//\tsugar := zap.NewExample().Sugar()\n//\tdefer sugar.Sync()\n//\tsugar.Infow(\"failed to fetch URL\",\n//\t  \"url\", \"http://example.com\",\n//\t  \"attempt\", 3,\n//\t  \"backoff\", time.Second,\n//\t)\n//\tsugar.Infof(\"failed to fetch URL: %s\", \"http://example.com\")\n//\n// By default, loggers are unbuffered. However, since zap's low-level APIs\n// allow buffering, calling Sync before letting your process exit is a good\n// habit.\n//\n// In the rare contexts where every microsecond and every allocation matter,\n// use the Logger. It's even faster than the SugaredLogger and allocates far\n// less, but it only supports strongly-typed, structured logging.\n//\n//\tlogger := zap.NewExample()\n//\tdefer logger.Sync()\n//\tlogger.Info(\"failed to fetch URL\",\n//\t  zap.String(\"url\", \"http://example.com\"),\n//\t  zap.Int(\"attempt\", 3),\n//\t  zap.Duration(\"backoff\", time.Second),\n//\t)\n//\n// Choosing between the Logger and SugaredLogger doesn't need to be an\n// application-wide decision: converting between the two is simple and\n// inexpensive.\n//\n//\tlogger := zap.NewExample()\n//\tdefer logger.Sync()\n//\tsugar := logger.Sugar()\n//\tplain := sugar.Desugar()\n//\n// # Configuring Zap\n//\n// The simplest way to build a Logger is to use zap's opinionated presets:\n// NewExample, NewProduction, and NewDevelopment. These presets build a logger\n// with a single function call:\n//\n//\tlogger, err := zap.NewProduction()\n//\tif err != nil {\n//\t  log.Fatalf(\"can't initialize zap logger: %v\", err)\n//\t}\n//\tdefer logger.Sync()\n//\n// Presets are fine for small projects, but larger projects and organizations\n// naturally require a bit more customization. For most users, zap's Config\n// struct strikes the right balance between flexibility and convenience. See\n// the package-level BasicConfiguration example for sample code.\n//\n// More unusual configurations (splitting output between files, sending logs\n// to a message queue, etc.) are possible, but require direct use of\n// go.uber.org/zap/zapcore. See the package-level AdvancedConfiguration\n// example for sample code.\n//\n// # Extending Zap\n//\n// The zap package itself is a relatively thin wrapper around the interfaces\n// in go.uber.org/zap/zapcore. Extending zap to support a new encoding (e.g.,\n// BSON), a new log sink (e.g., Kafka), or something more exotic (perhaps an\n// exception aggregation service, like Sentry or Rollbar) typically requires\n// implementing the zapcore.Encoder, zapcore.WriteSyncer, or zapcore.Core\n// interfaces. See the zapcore documentation for details.\n//\n// Similarly, package authors can use the high-performance Encoder and Core\n// implementations in the zapcore package to build their own loggers.\n//\n// # Frequently Asked Questions\n//\n// An FAQ covering everything from installation errors to design decisions is\n// available at https://github.com/uber-go/zap/blob/master/FAQ.md.\npackage zap // import \"go.uber.org/zap\"\n"
        },
        {
          "name": "encoder.go",
          "type": "blob",
          "size": 2.7841796875,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\nvar (\n\terrNoEncoderNameSpecified = errors.New(\"no encoder name specified\")\n\n\t_encoderNameToConstructor = map[string]func(zapcore.EncoderConfig) (zapcore.Encoder, error){\n\t\t\"console\": func(encoderConfig zapcore.EncoderConfig) (zapcore.Encoder, error) {\n\t\t\treturn zapcore.NewConsoleEncoder(encoderConfig), nil\n\t\t},\n\t\t\"json\": func(encoderConfig zapcore.EncoderConfig) (zapcore.Encoder, error) {\n\t\t\treturn zapcore.NewJSONEncoder(encoderConfig), nil\n\t\t},\n\t}\n\t_encoderMutex sync.RWMutex\n)\n\n// RegisterEncoder registers an encoder constructor, which the Config struct\n// can then reference. By default, the \"json\" and \"console\" encoders are\n// registered.\n//\n// Attempting to register an encoder whose name is already taken returns an\n// error.\nfunc RegisterEncoder(name string, constructor func(zapcore.EncoderConfig) (zapcore.Encoder, error)) error {\n\t_encoderMutex.Lock()\n\tdefer _encoderMutex.Unlock()\n\tif name == \"\" {\n\t\treturn errNoEncoderNameSpecified\n\t}\n\tif _, ok := _encoderNameToConstructor[name]; ok {\n\t\treturn fmt.Errorf(\"encoder already registered for name %q\", name)\n\t}\n\t_encoderNameToConstructor[name] = constructor\n\treturn nil\n}\n\nfunc newEncoder(name string, encoderConfig zapcore.EncoderConfig) (zapcore.Encoder, error) {\n\tif encoderConfig.TimeKey != \"\" && encoderConfig.EncodeTime == nil {\n\t\treturn nil, errors.New(\"missing EncodeTime in EncoderConfig\")\n\t}\n\n\t_encoderMutex.RLock()\n\tdefer _encoderMutex.RUnlock()\n\tif name == \"\" {\n\t\treturn nil, errNoEncoderNameSpecified\n\t}\n\tconstructor, ok := _encoderNameToConstructor[name]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"no encoder registered for name %q\", name)\n\t}\n\treturn constructor(encoderConfig)\n}\n"
        },
        {
          "name": "encoder_test.go",
          "type": "blob",
          "size": 3.421875,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"testing\"\n\n\t\"go.uber.org/zap/zapcore\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestRegisterDefaultEncoders(t *testing.T) {\n\ttestEncodersRegistered(t, \"console\", \"json\")\n}\n\nfunc TestRegisterEncoder(t *testing.T) {\n\ttestEncoders(func() {\n\t\tassert.NoError(t, RegisterEncoder(\"foo\", newNilEncoder), \"expected to be able to register the encoder foo\")\n\t\ttestEncodersRegistered(t, \"foo\")\n\t})\n}\n\nfunc TestDuplicateRegisterEncoder(t *testing.T) {\n\ttestEncoders(func() {\n\t\tassert.NoError(t, RegisterEncoder(\"foo\", newNilEncoder), \"expected to be able to register the encoder foo\")\n\t\tassert.Error(t, RegisterEncoder(\"foo\", newNilEncoder), \"expected an error when registering an encoder with the same name twice\")\n\t})\n}\n\nfunc TestRegisterEncoderNoName(t *testing.T) {\n\tassert.Equal(t, errNoEncoderNameSpecified, RegisterEncoder(\"\", newNilEncoder), \"expected an error when registering an encoder with no name\")\n}\n\nfunc TestNewEncoder(t *testing.T) {\n\ttestEncoders(func() {\n\t\tassert.NoError(t, RegisterEncoder(\"foo\", newNilEncoder), \"expected to be able to register the encoder foo\")\n\t\tencoder, err := newEncoder(\"foo\", zapcore.EncoderConfig{})\n\t\tassert.NoError(t, err, \"could not create an encoder for the registered name foo\")\n\t\tassert.Nil(t, encoder, \"the encoder from newNilEncoder is not nil\")\n\t})\n}\n\nfunc TestNewEncoderNotRegistered(t *testing.T) {\n\t_, err := newEncoder(\"foo\", zapcore.EncoderConfig{})\n\tassert.Error(t, err, \"expected an error when trying to create an encoder of an unregistered name\")\n}\n\nfunc TestNewEncoderNoName(t *testing.T) {\n\t_, err := newEncoder(\"\", zapcore.EncoderConfig{})\n\tassert.Equal(t, errNoEncoderNameSpecified, err, \"expected an error when creating an encoder with no name\")\n}\n\nfunc testEncoders(f func()) {\n\texisting := _encoderNameToConstructor\n\t_encoderNameToConstructor = make(map[string]func(zapcore.EncoderConfig) (zapcore.Encoder, error))\n\tdefer func() { _encoderNameToConstructor = existing }()\n\tf()\n}\n\nfunc testEncodersRegistered(t *testing.T, names ...string) {\n\tassert.Len(t, _encoderNameToConstructor, len(names), \"the expected number of registered encoders does not match the actual number\")\n\tfor _, name := range names {\n\t\tassert.NotNil(t, _encoderNameToConstructor[name], \"no encoder is registered for name %s\", name)\n\t}\n}\n\nfunc newNilEncoder(_ zapcore.EncoderConfig) (zapcore.Encoder, error) {\n\treturn nil, nil\n}\n"
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 2.755859375,
          "content": "// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"go.uber.org/zap/internal/pool\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\nvar _errArrayElemPool = pool.New(func() *errArrayElem {\n\treturn &errArrayElem{}\n})\n\n// Error is shorthand for the common idiom NamedError(\"error\", err).\nfunc Error(err error) Field {\n\treturn NamedError(\"error\", err)\n}\n\n// NamedError constructs a field that lazily stores err.Error() under the\n// provided key. Errors which also implement fmt.Formatter (like those produced\n// by github.com/pkg/errors) will also have their verbose representation stored\n// under key+\"Verbose\". If passed a nil error, the field is a no-op.\n//\n// For the common case in which the key is simply \"error\", the Error function\n// is shorter and less repetitive.\nfunc NamedError(key string, err error) Field {\n\tif err == nil {\n\t\treturn Skip()\n\t}\n\treturn Field{Key: key, Type: zapcore.ErrorType, Interface: err}\n}\n\ntype errArray []error\n\nfunc (errs errArray) MarshalLogArray(arr zapcore.ArrayEncoder) error {\n\tfor i := range errs {\n\t\tif errs[i] == nil {\n\t\t\tcontinue\n\t\t}\n\t\t// To represent each error as an object with an \"error\" attribute and\n\t\t// potentially an \"errorVerbose\" attribute, we need to wrap it in a\n\t\t// type that implements LogObjectMarshaler. To prevent this from\n\t\t// allocating, pool the wrapper type.\n\t\telem := _errArrayElemPool.Get()\n\t\telem.error = errs[i]\n\t\terr := arr.AppendObject(elem)\n\t\telem.error = nil\n\t\t_errArrayElemPool.Put(elem)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\ntype errArrayElem struct {\n\terror\n}\n\nfunc (e *errArrayElem) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\t// Re-use the error field's logic, which supports non-standard error types.\n\tError(e.error).AddTo(enc)\n\treturn nil\n}\n"
        },
        {
          "name": "error_test.go",
          "type": "blob",
          "size": 4.38671875,
          "content": "// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"go.uber.org/zap/zapcore\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestErrorConstructors(t *testing.T) {\n\tfail := errors.New(\"fail\")\n\n\ttests := []struct {\n\t\tname   string\n\t\tfield  Field\n\t\texpect Field\n\t}{\n\t\t{\"Error\", Skip(), Error(nil)},\n\t\t{\"Error\", Field{Key: \"error\", Type: zapcore.ErrorType, Interface: fail}, Error(fail)},\n\t\t{\"NamedError\", Skip(), NamedError(\"foo\", nil)},\n\t\t{\"NamedError\", Field{Key: \"foo\", Type: zapcore.ErrorType, Interface: fail}, NamedError(\"foo\", fail)},\n\t\t{\"Any:Error\", Any(\"k\", errors.New(\"v\")), NamedError(\"k\", errors.New(\"v\"))},\n\t\t{\"Any:Errors\", Any(\"k\", []error{errors.New(\"v\")}), Errors(\"k\", []error{errors.New(\"v\")})},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif !assert.Equal(t, tt.expect, tt.field, \"Unexpected output from convenience field constructor %s.\", tt.name) {\n\t\t\tt.Logf(\"type expected: %T\\nGot: %T\", tt.expect.Interface, tt.field.Interface)\n\t\t}\n\t\tassertCanBeReused(t, tt.field)\n\t}\n}\n\nfunc TestErrorArrayConstructor(t *testing.T) {\n\ttests := []struct {\n\t\tdesc     string\n\t\tfield    Field\n\t\texpected []interface{}\n\t}{\n\t\t{\"empty errors\", Errors(\"\", []error{}), []interface{}{}},\n\t\t{\n\t\t\t\"errors\",\n\t\t\tErrors(\"\", []error{nil, errors.New(\"foo\"), nil, errors.New(\"bar\")}),\n\t\t\t[]interface{}{map[string]interface{}{\"error\": \"foo\"}, map[string]interface{}{\"error\": \"bar\"}},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tenc := zapcore.NewMapObjectEncoder()\n\t\ttt.field.Key = \"k\"\n\t\ttt.field.AddTo(enc)\n\t\tassert.Equal(t, tt.expected, enc.Fields[\"k\"], \"%s: unexpected map contents.\", tt.desc)\n\t\tassert.Equal(t, 1, len(enc.Fields), \"%s: found extra keys in map: %v\", tt.desc, enc.Fields)\n\t}\n}\n\nfunc TestErrorsArraysHandleRichErrors(t *testing.T) {\n\terrs := []error{fmt.Errorf(\"egad\")}\n\n\tenc := zapcore.NewMapObjectEncoder()\n\tErrors(\"k\", errs).AddTo(enc)\n\tassert.Equal(t, 1, len(enc.Fields), \"Expected only top-level field.\")\n\n\tval := enc.Fields[\"k\"]\n\tarr, ok := val.([]interface{})\n\trequire.True(t, ok, \"Expected top-level field to be an array.\")\n\trequire.Equal(t, 1, len(arr), \"Expected only one error object in array.\")\n\n\tserialized := arr[0]\n\terrMap, ok := serialized.(map[string]interface{})\n\trequire.True(t, ok, \"Expected serialized error to be a map, got %T.\", serialized)\n\tassert.Equal(t, \"egad\", errMap[\"error\"], \"Unexpected standard error string.\")\n}\n\nfunc TestErrArrayBrokenEncoder(t *testing.T) {\n\tt.Parallel()\n\n\tfailWith := errors.New(\"great sadness\")\n\terr := (brokenArrayObjectEncoder{\n\t\tErr:           failWith,\n\t\tObjectEncoder: zapcore.NewMapObjectEncoder(),\n\t}).AddArray(\"errors\", errArray{\n\t\terrors.New(\"foo\"),\n\t\terrors.New(\"bar\"),\n\t})\n\trequire.Error(t, err, \"Expected error from broken encoder.\")\n\tassert.ErrorIs(t, err, failWith, \"Unexpected error.\")\n}\n\n// brokenArrayObjectEncoder is an ObjectEncoder\n// that builds a broken ArrayEncoder.\ntype brokenArrayObjectEncoder struct {\n\tzapcore.ObjectEncoder\n\tzapcore.ArrayEncoder\n\n\tErr error // error to return\n}\n\nfunc (enc brokenArrayObjectEncoder) AddArray(key string, marshaler zapcore.ArrayMarshaler) error {\n\treturn enc.ObjectEncoder.AddArray(key,\n\t\tzapcore.ArrayMarshalerFunc(func(ae zapcore.ArrayEncoder) error {\n\t\t\tenc.ArrayEncoder = ae\n\t\t\treturn marshaler.MarshalLogArray(enc)\n\t\t}))\n}\n\nfunc (enc brokenArrayObjectEncoder) AppendObject(zapcore.ObjectMarshaler) error {\n\treturn enc.Err\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 13.66015625,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap_test\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\nfunc Example_presets() {\n\t// Using zap's preset constructors is the simplest way to get a feel for the\n\t// package, but they don't allow much customization.\n\tlogger := zap.NewExample() // or NewProduction, or NewDevelopment\n\tdefer logger.Sync()\n\n\tconst url = \"http://example.com\"\n\n\t// In most circumstances, use the SugaredLogger. It's 4-10x faster than most\n\t// other structured logging packages and has a familiar, loosely-typed API.\n\tsugar := logger.Sugar()\n\tsugar.Infow(\"Failed to fetch URL.\",\n\t\t// Structured context as loosely typed key-value pairs.\n\t\t\"url\", url,\n\t\t\"attempt\", 3,\n\t\t\"backoff\", time.Second,\n\t)\n\tsugar.Infof(\"Failed to fetch URL: %s\", url)\n\n\t// In the unusual situations where every microsecond matters, use the\n\t// Logger. It's even faster than the SugaredLogger, but only supports\n\t// structured logging.\n\tlogger.Info(\"Failed to fetch URL.\",\n\t\t// Structured context as strongly typed fields.\n\t\tzap.String(\"url\", url),\n\t\tzap.Int(\"attempt\", 3),\n\t\tzap.Duration(\"backoff\", time.Second),\n\t)\n\t// Output:\n\t// {\"level\":\"info\",\"msg\":\"Failed to fetch URL.\",\"url\":\"http://example.com\",\"attempt\":3,\"backoff\":\"1s\"}\n\t// {\"level\":\"info\",\"msg\":\"Failed to fetch URL: http://example.com\"}\n\t// {\"level\":\"info\",\"msg\":\"Failed to fetch URL.\",\"url\":\"http://example.com\",\"attempt\":3,\"backoff\":\"1s\"}\n}\n\nfunc Example_basicConfiguration() {\n\t// For some users, the presets offered by the NewProduction, NewDevelopment,\n\t// and NewExample constructors won't be appropriate. For most of those\n\t// users, the bundled Config struct offers the right balance of flexibility\n\t// and convenience. (For more complex needs, see the AdvancedConfiguration\n\t// example.)\n\t//\n\t// See the documentation for Config and zapcore.EncoderConfig for all the\n\t// available options.\n\trawJSON := []byte(`{\n\t  \"level\": \"debug\",\n\t  \"encoding\": \"json\",\n\t  \"outputPaths\": [\"stdout\", \"/tmp/logs\"],\n\t  \"errorOutputPaths\": [\"stderr\"],\n\t  \"initialFields\": {\"foo\": \"bar\"},\n\t  \"encoderConfig\": {\n\t    \"messageKey\": \"message\",\n\t    \"levelKey\": \"level\",\n\t    \"levelEncoder\": \"lowercase\"\n\t  }\n\t}`)\n\n\tvar cfg zap.Config\n\tif err := json.Unmarshal(rawJSON, &cfg); err != nil {\n\t\tpanic(err)\n\t}\n\tlogger := zap.Must(cfg.Build())\n\tdefer logger.Sync()\n\n\tlogger.Info(\"logger construction succeeded\")\n\t// Output:\n\t// {\"level\":\"info\",\"message\":\"logger construction succeeded\",\"foo\":\"bar\"}\n}\n\nfunc Example_advancedConfiguration() {\n\t// The bundled Config struct only supports the most common configuration\n\t// options. More complex needs, like splitting logs between multiple files\n\t// or writing to non-file outputs, require use of the zapcore package.\n\t//\n\t// In this example, imagine we're both sending our logs to Kafka and writing\n\t// them to the console. We'd like to encode the console output and the Kafka\n\t// topics differently, and we'd also like special treatment for\n\t// high-priority logs.\n\n\t// First, define our level-handling logic.\n\thighPriority := zap.LevelEnablerFunc(func(lvl zapcore.Level) bool {\n\t\treturn lvl >= zapcore.ErrorLevel\n\t})\n\tlowPriority := zap.LevelEnablerFunc(func(lvl zapcore.Level) bool {\n\t\treturn lvl < zapcore.ErrorLevel\n\t})\n\n\t// Assume that we have clients for two Kafka topics. The clients implement\n\t// zapcore.WriteSyncer and are safe for concurrent use. (If they only\n\t// implement io.Writer, we can use zapcore.AddSync to add a no-op Sync\n\t// method. If they're not safe for concurrent use, we can add a protecting\n\t// mutex with zapcore.Lock.)\n\ttopicDebugging := zapcore.AddSync(io.Discard)\n\ttopicErrors := zapcore.AddSync(io.Discard)\n\n\t// High-priority output should also go to standard error, and low-priority\n\t// output should also go to standard out.\n\tconsoleDebugging := zapcore.Lock(os.Stdout)\n\tconsoleErrors := zapcore.Lock(os.Stderr)\n\n\t// Optimize the Kafka output for machine consumption and the console output\n\t// for human operators.\n\tkafkaEncoder := zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig())\n\tconsoleEncoder := zapcore.NewConsoleEncoder(zap.NewDevelopmentEncoderConfig())\n\n\t// Join the outputs, encoders, and level-handling functions into\n\t// zapcore.Cores, then tee the four cores together.\n\tcore := zapcore.NewTee(\n\t\tzapcore.NewCore(kafkaEncoder, topicErrors, highPriority),\n\t\tzapcore.NewCore(consoleEncoder, consoleErrors, highPriority),\n\t\tzapcore.NewCore(kafkaEncoder, topicDebugging, lowPriority),\n\t\tzapcore.NewCore(consoleEncoder, consoleDebugging, lowPriority),\n\t)\n\n\t// From a zapcore.Core, it's easy to construct a Logger.\n\tlogger := zap.New(core)\n\tdefer logger.Sync()\n\tlogger.Info(\"constructed a logger\")\n}\n\nfunc ExampleNamespace() {\n\tlogger := zap.NewExample()\n\tdefer logger.Sync()\n\n\tlogger.With(\n\t\tzap.Namespace(\"metrics\"),\n\t\tzap.Int(\"counter\", 1),\n\t).Info(\"tracked some metrics\")\n\t// Output:\n\t// {\"level\":\"info\",\"msg\":\"tracked some metrics\",\"metrics\":{\"counter\":1}}\n}\n\ntype addr struct {\n\tIP   string\n\tPort int\n}\n\ntype request struct {\n\tURL    string\n\tListen addr\n\tRemote addr\n}\n\nfunc (a addr) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\tenc.AddString(\"ip\", a.IP)\n\tenc.AddInt(\"port\", a.Port)\n\treturn nil\n}\n\nfunc (r *request) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\tenc.AddString(\"url\", r.URL)\n\tzap.Inline(r.Listen).AddTo(enc)\n\treturn enc.AddObject(\"remote\", r.Remote)\n}\n\nfunc ExampleObject() {\n\tlogger := zap.NewExample()\n\tdefer logger.Sync()\n\n\treq := &request{\n\t\tURL:    \"/test\",\n\t\tListen: addr{\"127.0.0.1\", 8080},\n\t\tRemote: addr{\"127.0.0.1\", 31200},\n\t}\n\tlogger.Info(\"new request, in nested object\", zap.Object(\"req\", req))\n\tlogger.Info(\"new request, inline\", zap.Inline(req))\n\t// Output:\n\t// {\"level\":\"info\",\"msg\":\"new request, in nested object\",\"req\":{\"url\":\"/test\",\"ip\":\"127.0.0.1\",\"port\":8080,\"remote\":{\"ip\":\"127.0.0.1\",\"port\":31200}}}\n\t// {\"level\":\"info\",\"msg\":\"new request, inline\",\"url\":\"/test\",\"ip\":\"127.0.0.1\",\"port\":8080,\"remote\":{\"ip\":\"127.0.0.1\",\"port\":31200}}\n}\n\nfunc ExampleNewStdLog() {\n\tlogger := zap.NewExample()\n\tdefer logger.Sync()\n\n\tstd := zap.NewStdLog(logger)\n\tstd.Print(\"standard logger wrapper\")\n\t// Output:\n\t// {\"level\":\"info\",\"msg\":\"standard logger wrapper\"}\n}\n\nfunc ExampleRedirectStdLog() {\n\tlogger := zap.NewExample()\n\tdefer logger.Sync()\n\n\tundo := zap.RedirectStdLog(logger)\n\tdefer undo()\n\n\tlog.Print(\"redirected standard library\")\n\t// Output:\n\t// {\"level\":\"info\",\"msg\":\"redirected standard library\"}\n}\n\nfunc ExampleReplaceGlobals() {\n\tlogger := zap.NewExample()\n\tdefer logger.Sync()\n\n\tundo := zap.ReplaceGlobals(logger)\n\tdefer undo()\n\n\tzap.L().Info(\"replaced zap's global loggers\")\n\t// Output:\n\t// {\"level\":\"info\",\"msg\":\"replaced zap's global loggers\"}\n}\n\nfunc ExampleAtomicLevel() {\n\tatom := zap.NewAtomicLevel()\n\n\t// To keep the example deterministic, disable timestamps in the output.\n\tencoderCfg := zap.NewProductionEncoderConfig()\n\tencoderCfg.TimeKey = \"\"\n\n\tlogger := zap.New(zapcore.NewCore(\n\t\tzapcore.NewJSONEncoder(encoderCfg),\n\t\tzapcore.Lock(os.Stdout),\n\t\tatom,\n\t))\n\tdefer logger.Sync()\n\n\tlogger.Info(\"info logging enabled\")\n\n\tatom.SetLevel(zap.ErrorLevel)\n\tlogger.Info(\"info logging disabled\")\n\t// Output:\n\t// {\"level\":\"info\",\"msg\":\"info logging enabled\"}\n}\n\nfunc ExampleAtomicLevel_config() {\n\t// The zap.Config struct includes an AtomicLevel. To use it, keep a\n\t// reference to the Config.\n\trawJSON := []byte(`{\n\t\t\"level\": \"info\",\n\t\t\"outputPaths\": [\"stdout\"],\n\t\t\"errorOutputPaths\": [\"stderr\"],\n\t\t\"encoding\": \"json\",\n\t\t\"encoderConfig\": {\n\t\t\t\"messageKey\": \"message\",\n\t\t\t\"levelKey\": \"level\",\n\t\t\t\"levelEncoder\": \"lowercase\"\n\t\t}\n\t}`)\n\tvar cfg zap.Config\n\tif err := json.Unmarshal(rawJSON, &cfg); err != nil {\n\t\tpanic(err)\n\t}\n\tlogger := zap.Must(cfg.Build())\n\tdefer logger.Sync()\n\n\tlogger.Info(\"info logging enabled\")\n\n\tcfg.Level.SetLevel(zap.ErrorLevel)\n\tlogger.Info(\"info logging disabled\")\n\t// Output:\n\t// {\"level\":\"info\",\"message\":\"info logging enabled\"}\n}\n\nfunc ExampleLogger_Check() {\n\tlogger := zap.NewExample()\n\tdefer logger.Sync()\n\n\tif ce := logger.Check(zap.DebugLevel, \"debugging\"); ce != nil {\n\t\t// If debug-level log output isn't enabled or if zap's sampling would have\n\t\t// dropped this log entry, we don't allocate the slice that holds these\n\t\t// fields.\n\t\tce.Write(\n\t\t\tzap.String(\"foo\", \"bar\"),\n\t\t\tzap.String(\"baz\", \"quux\"),\n\t\t)\n\t}\n\n\t// Output:\n\t// {\"level\":\"debug\",\"msg\":\"debugging\",\"foo\":\"bar\",\"baz\":\"quux\"}\n}\n\nfunc ExampleLogger_Named() {\n\tlogger := zap.NewExample()\n\tdefer logger.Sync()\n\n\t// By default, Loggers are unnamed.\n\tlogger.Info(\"no name\")\n\n\t// The first call to Named sets the Logger name.\n\tmain := logger.Named(\"main\")\n\tmain.Info(\"main logger\")\n\n\t// Additional calls to Named create a period-separated path.\n\tmain.Named(\"subpackage\").Info(\"sub-logger\")\n\t// Output:\n\t// {\"level\":\"info\",\"msg\":\"no name\"}\n\t// {\"level\":\"info\",\"logger\":\"main\",\"msg\":\"main logger\"}\n\t// {\"level\":\"info\",\"logger\":\"main.subpackage\",\"msg\":\"sub-logger\"}\n}\n\nfunc ExampleWrapCore_replace() {\n\t// Replacing a Logger's core can alter fundamental behaviors.\n\t// For example, it can convert a Logger to a no-op.\n\tnop := zap.WrapCore(func(zapcore.Core) zapcore.Core {\n\t\treturn zapcore.NewNopCore()\n\t})\n\n\tlogger := zap.NewExample()\n\tdefer logger.Sync()\n\n\tlogger.Info(\"working\")\n\tlogger.WithOptions(nop).Info(\"no-op\")\n\tlogger.Info(\"original logger still works\")\n\t// Output:\n\t// {\"level\":\"info\",\"msg\":\"working\"}\n\t// {\"level\":\"info\",\"msg\":\"original logger still works\"}\n}\n\nfunc ExampleWrapCore_wrap() {\n\t// Wrapping a Logger's core can extend its functionality. As a trivial\n\t// example, it can double-write all logs.\n\tdoubled := zap.WrapCore(func(c zapcore.Core) zapcore.Core {\n\t\treturn zapcore.NewTee(c, c)\n\t})\n\n\tlogger := zap.NewExample()\n\tdefer logger.Sync()\n\n\tlogger.Info(\"single\")\n\tlogger.WithOptions(doubled).Info(\"doubled\")\n\t// Output:\n\t// {\"level\":\"info\",\"msg\":\"single\"}\n\t// {\"level\":\"info\",\"msg\":\"doubled\"}\n\t// {\"level\":\"info\",\"msg\":\"doubled\"}\n}\n\nfunc ExampleDict() {\n\tlogger := zap.NewExample()\n\tdefer logger.Sync()\n\n\tlogger.Info(\"login event\",\n\t\tzap.Dict(\"event\",\n\t\t\tzap.Int(\"id\", 123),\n\t\t\tzap.String(\"name\", \"jane\"),\n\t\t\tzap.String(\"status\", \"pending\")))\n\t// Output:\n\t// {\"level\":\"info\",\"msg\":\"login event\",\"event\":{\"id\":123,\"name\":\"jane\",\"status\":\"pending\"}}\n}\n\nfunc ExampleObjects() {\n\tlogger := zap.NewExample()\n\tdefer logger.Sync()\n\n\t// Use the Objects field constructor when you have a list of objects,\n\t// all of which implement zapcore.ObjectMarshaler.\n\tlogger.Debug(\"opening connections\",\n\t\tzap.Objects(\"addrs\", []addr{\n\t\t\t{IP: \"123.45.67.89\", Port: 4040},\n\t\t\t{IP: \"127.0.0.1\", Port: 4041},\n\t\t\t{IP: \"192.168.0.1\", Port: 4042},\n\t\t}))\n\t// Output:\n\t// {\"level\":\"debug\",\"msg\":\"opening connections\",\"addrs\":[{\"ip\":\"123.45.67.89\",\"port\":4040},{\"ip\":\"127.0.0.1\",\"port\":4041},{\"ip\":\"192.168.0.1\",\"port\":4042}]}\n}\n\nfunc ExampleDictObject() {\n\tlogger := zap.NewExample()\n\tdefer logger.Sync()\n\n\t// Use DictObject to create zapcore.ObjectMarshaler implementations from Field arrays,\n\t// then use the Object and Objects field constructors to turn them back into a Field.\n\n\tlogger.Debug(\"worker received job\",\n\t\tzap.Object(\"w1\",\n\t\t\tzap.DictObject(\n\t\t\t\tzap.Int(\"id\", 402000),\n\t\t\t\tzap.String(\"description\", \"compress image data\"),\n\t\t\t\tzap.Int(\"priority\", 3),\n\t\t\t),\n\t\t))\n\n\td1 := 68 * time.Millisecond\n\td2 := 79 * time.Millisecond\n\td3 := 57 * time.Millisecond\n\n\tlogger.Info(\"worker status checks\",\n\t\tzap.Objects(\"job batch enqueued\",\n\t\t\t[]zapcore.ObjectMarshaler{\n\t\t\t\tzap.DictObject(\n\t\t\t\t\tzap.String(\"worker\", \"w1\"),\n\t\t\t\t\tzap.Int(\"load\", 419),\n\t\t\t\t\tzap.Duration(\"latency\", d1),\n\t\t\t\t),\n\t\t\t\tzap.DictObject(\n\t\t\t\t\tzap.String(\"worker\", \"w2\"),\n\t\t\t\t\tzap.Int(\"load\", 520),\n\t\t\t\t\tzap.Duration(\"latency\", d2),\n\t\t\t\t),\n\t\t\t\tzap.DictObject(\n\t\t\t\t\tzap.String(\"worker\", \"w3\"),\n\t\t\t\t\tzap.Int(\"load\", 310),\n\t\t\t\t\tzap.Duration(\"latency\", d3),\n\t\t\t\t),\n\t\t\t},\n\t\t))\n\t// Output:\n\t// {\"level\":\"debug\",\"msg\":\"worker received job\",\"w1\":{\"id\":402000,\"description\":\"compress image data\",\"priority\":3}}\n\t// {\"level\":\"info\",\"msg\":\"worker status checks\",\"job batch enqueued\":[{\"worker\":\"w1\",\"load\":419,\"latency\":\"68ms\"},{\"worker\":\"w2\",\"load\":520,\"latency\":\"79ms\"},{\"worker\":\"w3\",\"load\":310,\"latency\":\"57ms\"}]}\n}\n\nfunc ExampleObjectValues() {\n\tlogger := zap.NewExample()\n\tdefer logger.Sync()\n\n\t// Use the ObjectValues field constructor when you have a list of\n\t// objects that do not implement zapcore.ObjectMarshaler directly,\n\t// but on their pointer receivers.\n\tlogger.Debug(\"starting tunnels\",\n\t\tzap.ObjectValues(\"addrs\", []request{\n\t\t\t{\n\t\t\t\tURL:    \"/foo\",\n\t\t\t\tListen: addr{\"127.0.0.1\", 8080},\n\t\t\t\tRemote: addr{\"123.45.67.89\", 4040},\n\t\t\t},\n\t\t\t{\n\t\t\t\tURL:    \"/bar\",\n\t\t\t\tListen: addr{\"127.0.0.1\", 8080},\n\t\t\t\tRemote: addr{\"127.0.0.1\", 31200},\n\t\t\t},\n\t\t}))\n\t// Output:\n\t// {\"level\":\"debug\",\"msg\":\"starting tunnels\",\"addrs\":[{\"url\":\"/foo\",\"ip\":\"127.0.0.1\",\"port\":8080,\"remote\":{\"ip\":\"123.45.67.89\",\"port\":4040}},{\"url\":\"/bar\",\"ip\":\"127.0.0.1\",\"port\":8080,\"remote\":{\"ip\":\"127.0.0.1\",\"port\":31200}}]}\n}\n"
        },
        {
          "name": "exp",
          "type": "tree",
          "content": null
        },
        {
          "name": "field.go",
          "type": "blob",
          "size": 19.5458984375,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"time\"\n\n\t\"go.uber.org/zap/internal/stacktrace\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// Field is an alias for Field. Aliasing this type dramatically\n// improves the navigability of this package's API documentation.\ntype Field = zapcore.Field\n\nvar (\n\t_minTimeInt64 = time.Unix(0, math.MinInt64)\n\t_maxTimeInt64 = time.Unix(0, math.MaxInt64)\n)\n\n// Skip constructs a no-op field, which is often useful when handling invalid\n// inputs in other Field constructors.\nfunc Skip() Field {\n\treturn Field{Type: zapcore.SkipType}\n}\n\n// nilField returns a field which will marshal explicitly as nil. See motivation\n// in https://github.com/uber-go/zap/issues/753 . If we ever make breaking\n// changes and add zapcore.NilType and zapcore.ObjectEncoder.AddNil, the\n// implementation here should be changed to reflect that.\nfunc nilField(key string) Field { return Reflect(key, nil) }\n\n// Binary constructs a field that carries an opaque binary blob.\n//\n// Binary data is serialized in an encoding-appropriate format. For example,\n// zap's JSON encoder base64-encodes binary blobs. To log UTF-8 encoded text,\n// use ByteString.\nfunc Binary(key string, val []byte) Field {\n\treturn Field{Key: key, Type: zapcore.BinaryType, Interface: val}\n}\n\n// Bool constructs a field that carries a bool.\nfunc Bool(key string, val bool) Field {\n\tvar ival int64\n\tif val {\n\t\tival = 1\n\t}\n\treturn Field{Key: key, Type: zapcore.BoolType, Integer: ival}\n}\n\n// Boolp constructs a field that carries a *bool. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Boolp(key string, val *bool) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Bool(key, *val)\n}\n\n// ByteString constructs a field that carries UTF-8 encoded text as a []byte.\n// To log opaque binary blobs (which aren't necessarily valid UTF-8), use\n// Binary.\nfunc ByteString(key string, val []byte) Field {\n\treturn Field{Key: key, Type: zapcore.ByteStringType, Interface: val}\n}\n\n// Complex128 constructs a field that carries a complex number. Unlike most\n// numeric fields, this costs an allocation (to convert the complex128 to\n// interface{}).\nfunc Complex128(key string, val complex128) Field {\n\treturn Field{Key: key, Type: zapcore.Complex128Type, Interface: val}\n}\n\n// Complex128p constructs a field that carries a *complex128. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Complex128p(key string, val *complex128) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Complex128(key, *val)\n}\n\n// Complex64 constructs a field that carries a complex number. Unlike most\n// numeric fields, this costs an allocation (to convert the complex64 to\n// interface{}).\nfunc Complex64(key string, val complex64) Field {\n\treturn Field{Key: key, Type: zapcore.Complex64Type, Interface: val}\n}\n\n// Complex64p constructs a field that carries a *complex64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Complex64p(key string, val *complex64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Complex64(key, *val)\n}\n\n// Float64 constructs a field that carries a float64. The way the\n// floating-point value is represented is encoder-dependent, so marshaling is\n// necessarily lazy.\nfunc Float64(key string, val float64) Field {\n\treturn Field{Key: key, Type: zapcore.Float64Type, Integer: int64(math.Float64bits(val))}\n}\n\n// Float64p constructs a field that carries a *float64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Float64p(key string, val *float64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Float64(key, *val)\n}\n\n// Float32 constructs a field that carries a float32. The way the\n// floating-point value is represented is encoder-dependent, so marshaling is\n// necessarily lazy.\nfunc Float32(key string, val float32) Field {\n\treturn Field{Key: key, Type: zapcore.Float32Type, Integer: int64(math.Float32bits(val))}\n}\n\n// Float32p constructs a field that carries a *float32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Float32p(key string, val *float32) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Float32(key, *val)\n}\n\n// Int constructs a field with the given key and value.\nfunc Int(key string, val int) Field {\n\treturn Int64(key, int64(val))\n}\n\n// Intp constructs a field that carries a *int. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Intp(key string, val *int) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int(key, *val)\n}\n\n// Int64 constructs a field with the given key and value.\nfunc Int64(key string, val int64) Field {\n\treturn Field{Key: key, Type: zapcore.Int64Type, Integer: val}\n}\n\n// Int64p constructs a field that carries a *int64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int64p(key string, val *int64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int64(key, *val)\n}\n\n// Int32 constructs a field with the given key and value.\nfunc Int32(key string, val int32) Field {\n\treturn Field{Key: key, Type: zapcore.Int32Type, Integer: int64(val)}\n}\n\n// Int32p constructs a field that carries a *int32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int32p(key string, val *int32) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int32(key, *val)\n}\n\n// Int16 constructs a field with the given key and value.\nfunc Int16(key string, val int16) Field {\n\treturn Field{Key: key, Type: zapcore.Int16Type, Integer: int64(val)}\n}\n\n// Int16p constructs a field that carries a *int16. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int16p(key string, val *int16) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int16(key, *val)\n}\n\n// Int8 constructs a field with the given key and value.\nfunc Int8(key string, val int8) Field {\n\treturn Field{Key: key, Type: zapcore.Int8Type, Integer: int64(val)}\n}\n\n// Int8p constructs a field that carries a *int8. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Int8p(key string, val *int8) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Int8(key, *val)\n}\n\n// String constructs a field with the given key and value.\nfunc String(key string, val string) Field {\n\treturn Field{Key: key, Type: zapcore.StringType, String: val}\n}\n\n// Stringp constructs a field that carries a *string. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Stringp(key string, val *string) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn String(key, *val)\n}\n\n// Uint constructs a field with the given key and value.\nfunc Uint(key string, val uint) Field {\n\treturn Uint64(key, uint64(val))\n}\n\n// Uintp constructs a field that carries a *uint. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uintp(key string, val *uint) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint(key, *val)\n}\n\n// Uint64 constructs a field with the given key and value.\nfunc Uint64(key string, val uint64) Field {\n\treturn Field{Key: key, Type: zapcore.Uint64Type, Integer: int64(val)}\n}\n\n// Uint64p constructs a field that carries a *uint64. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint64p(key string, val *uint64) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint64(key, *val)\n}\n\n// Uint32 constructs a field with the given key and value.\nfunc Uint32(key string, val uint32) Field {\n\treturn Field{Key: key, Type: zapcore.Uint32Type, Integer: int64(val)}\n}\n\n// Uint32p constructs a field that carries a *uint32. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint32p(key string, val *uint32) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint32(key, *val)\n}\n\n// Uint16 constructs a field with the given key and value.\nfunc Uint16(key string, val uint16) Field {\n\treturn Field{Key: key, Type: zapcore.Uint16Type, Integer: int64(val)}\n}\n\n// Uint16p constructs a field that carries a *uint16. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint16p(key string, val *uint16) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint16(key, *val)\n}\n\n// Uint8 constructs a field with the given key and value.\nfunc Uint8(key string, val uint8) Field {\n\treturn Field{Key: key, Type: zapcore.Uint8Type, Integer: int64(val)}\n}\n\n// Uint8p constructs a field that carries a *uint8. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uint8p(key string, val *uint8) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uint8(key, *val)\n}\n\n// Uintptr constructs a field with the given key and value.\nfunc Uintptr(key string, val uintptr) Field {\n\treturn Field{Key: key, Type: zapcore.UintptrType, Integer: int64(val)}\n}\n\n// Uintptrp constructs a field that carries a *uintptr. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Uintptrp(key string, val *uintptr) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Uintptr(key, *val)\n}\n\n// Reflect constructs a field with the given key and an arbitrary object. It uses\n// an encoding-appropriate, reflection-based function to lazily serialize nearly\n// any object into the logging context, but it's relatively slow and\n// allocation-heavy. Outside tests, Any is always a better choice.\n//\n// If encoding fails (e.g., trying to serialize a map[int]string to JSON), Reflect\n// includes the error message in the final log output.\nfunc Reflect(key string, val interface{}) Field {\n\treturn Field{Key: key, Type: zapcore.ReflectType, Interface: val}\n}\n\n// Namespace creates a named, isolated scope within the logger's context. All\n// subsequent fields will be added to the new namespace.\n//\n// This helps prevent key collisions when injecting loggers into sub-components\n// or third-party libraries.\nfunc Namespace(key string) Field {\n\treturn Field{Key: key, Type: zapcore.NamespaceType}\n}\n\n// Stringer constructs a field with the given key and the output of the value's\n// String method. The Stringer's String method is called lazily.\nfunc Stringer(key string, val fmt.Stringer) Field {\n\treturn Field{Key: key, Type: zapcore.StringerType, Interface: val}\n}\n\n// Time constructs a Field with the given key and value. The encoder\n// controls how the time is serialized.\nfunc Time(key string, val time.Time) Field {\n\tif val.Before(_minTimeInt64) || val.After(_maxTimeInt64) {\n\t\treturn Field{Key: key, Type: zapcore.TimeFullType, Interface: val}\n\t}\n\treturn Field{Key: key, Type: zapcore.TimeType, Integer: val.UnixNano(), Interface: val.Location()}\n}\n\n// Timep constructs a field that carries a *time.Time. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Timep(key string, val *time.Time) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Time(key, *val)\n}\n\n// Stack constructs a field that stores a stacktrace of the current goroutine\n// under provided key. Keep in mind that taking a stacktrace is eager and\n// expensive (relatively speaking); this function both makes an allocation and\n// takes about two microseconds.\nfunc Stack(key string) Field {\n\treturn StackSkip(key, 1) // skip Stack\n}\n\n// StackSkip constructs a field similarly to Stack, but also skips the given\n// number of frames from the top of the stacktrace.\nfunc StackSkip(key string, skip int) Field {\n\t// Returning the stacktrace as a string costs an allocation, but saves us\n\t// from expanding the zapcore.Field union struct to include a byte slice. Since\n\t// taking a stacktrace is already so expensive (~10us), the extra allocation\n\t// is okay.\n\treturn String(key, stacktrace.Take(skip+1)) // skip StackSkip\n}\n\n// Duration constructs a field with the given key and value. The encoder\n// controls how the duration is serialized.\nfunc Duration(key string, val time.Duration) Field {\n\treturn Field{Key: key, Type: zapcore.DurationType, Integer: int64(val)}\n}\n\n// Durationp constructs a field that carries a *time.Duration. The returned Field will safely\n// and explicitly represent `nil` when appropriate.\nfunc Durationp(key string, val *time.Duration) Field {\n\tif val == nil {\n\t\treturn nilField(key)\n\t}\n\treturn Duration(key, *val)\n}\n\n// Object constructs a field with the given key and ObjectMarshaler. It\n// provides a flexible, but still type-safe and efficient, way to add map- or\n// struct-like user-defined types to the logging context. The struct's\n// MarshalLogObject method is called lazily.\nfunc Object(key string, val zapcore.ObjectMarshaler) Field {\n\treturn Field{Key: key, Type: zapcore.ObjectMarshalerType, Interface: val}\n}\n\n// Inline constructs a Field that is similar to Object, but it\n// will add the elements of the provided ObjectMarshaler to the\n// current namespace.\nfunc Inline(val zapcore.ObjectMarshaler) Field {\n\treturn zapcore.Field{\n\t\tType:      zapcore.InlineMarshalerType,\n\t\tInterface: val,\n\t}\n}\n\n// Dict constructs a field containing the provided key-value pairs.\n// It acts similar to [Object], but with the fields specified as arguments.\nfunc Dict(key string, val ...Field) Field {\n\treturn dictField(key, val)\n}\n\n// We need a function with the signature (string, T) for zap.Any.\nfunc dictField(key string, val []Field) Field {\n\treturn Object(key, dictObject(val))\n}\n\ntype dictObject []Field\n\nfunc (d dictObject) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\tfor _, f := range d {\n\t\tf.AddTo(enc)\n\t}\n\treturn nil\n}\n\n// DictObject constructs a [zapcore.ObjectMarshaler] with the given list of fields.\n// The resulting object marshaler can be used as input to [Object], [Objects], or\n// any other functions that expect an object marshaler.\nfunc DictObject(val ...Field) zapcore.ObjectMarshaler {\n\treturn dictObject(val)\n}\n\n// We discovered an issue where zap.Any can cause a performance degradation\n// when used in new goroutines.\n//\n// This happens because the compiler assigns 4.8kb (one zap.Field per arm of\n// switch statement) of stack space for zap.Any when it takes the form:\n//\n//\tswitch v := v.(type) {\n//\tcase string:\n//\t\treturn String(key, v)\n//\tcase int:\n//\t\treturn Int(key, v)\n//\t\t// ...\n//\tdefault:\n//\t\treturn Reflect(key, v)\n//\t}\n//\n// To avoid this, we use the type switch to assign a value to a single local variable\n// and then call a function on it.\n// The local variable is just a function reference so it doesn't allocate\n// when converted to an interface{}.\n//\n// A fair bit of experimentation went into this.\n// See also:\n//\n// - https://github.com/uber-go/zap/pull/1301\n// - https://github.com/uber-go/zap/pull/1303\n// - https://github.com/uber-go/zap/pull/1304\n// - https://github.com/uber-go/zap/pull/1305\n// - https://github.com/uber-go/zap/pull/1308\n//\n// See https://github.com/golang/go/issues/62077 for upstream issue.\ntype anyFieldC[T any] func(string, T) Field\n\nfunc (f anyFieldC[T]) Any(key string, val any) Field {\n\tv, _ := val.(T)\n\t// val is guaranteed to be a T, except when it's nil.\n\treturn f(key, v)\n}\n\n// Any takes a key and an arbitrary value and chooses the best way to represent\n// them as a field, falling back to a reflection-based approach only if\n// necessary.\n//\n// Since byte/uint8 and rune/int32 are aliases, Any can't differentiate between\n// them. To minimize surprises, []byte values are treated as binary blobs, byte\n// values are treated as uint8, and runes are always treated as integers.\nfunc Any(key string, value interface{}) Field {\n\tvar c interface{ Any(string, any) Field }\n\n\tswitch value.(type) {\n\tcase zapcore.ObjectMarshaler:\n\t\tc = anyFieldC[zapcore.ObjectMarshaler](Object)\n\tcase zapcore.ArrayMarshaler:\n\t\tc = anyFieldC[zapcore.ArrayMarshaler](Array)\n\tcase []Field:\n\t\tc = anyFieldC[[]Field](dictField)\n\tcase bool:\n\t\tc = anyFieldC[bool](Bool)\n\tcase *bool:\n\t\tc = anyFieldC[*bool](Boolp)\n\tcase []bool:\n\t\tc = anyFieldC[[]bool](Bools)\n\tcase complex128:\n\t\tc = anyFieldC[complex128](Complex128)\n\tcase *complex128:\n\t\tc = anyFieldC[*complex128](Complex128p)\n\tcase []complex128:\n\t\tc = anyFieldC[[]complex128](Complex128s)\n\tcase complex64:\n\t\tc = anyFieldC[complex64](Complex64)\n\tcase *complex64:\n\t\tc = anyFieldC[*complex64](Complex64p)\n\tcase []complex64:\n\t\tc = anyFieldC[[]complex64](Complex64s)\n\tcase float64:\n\t\tc = anyFieldC[float64](Float64)\n\tcase *float64:\n\t\tc = anyFieldC[*float64](Float64p)\n\tcase []float64:\n\t\tc = anyFieldC[[]float64](Float64s)\n\tcase float32:\n\t\tc = anyFieldC[float32](Float32)\n\tcase *float32:\n\t\tc = anyFieldC[*float32](Float32p)\n\tcase []float32:\n\t\tc = anyFieldC[[]float32](Float32s)\n\tcase int:\n\t\tc = anyFieldC[int](Int)\n\tcase *int:\n\t\tc = anyFieldC[*int](Intp)\n\tcase []int:\n\t\tc = anyFieldC[[]int](Ints)\n\tcase int64:\n\t\tc = anyFieldC[int64](Int64)\n\tcase *int64:\n\t\tc = anyFieldC[*int64](Int64p)\n\tcase []int64:\n\t\tc = anyFieldC[[]int64](Int64s)\n\tcase int32:\n\t\tc = anyFieldC[int32](Int32)\n\tcase *int32:\n\t\tc = anyFieldC[*int32](Int32p)\n\tcase []int32:\n\t\tc = anyFieldC[[]int32](Int32s)\n\tcase int16:\n\t\tc = anyFieldC[int16](Int16)\n\tcase *int16:\n\t\tc = anyFieldC[*int16](Int16p)\n\tcase []int16:\n\t\tc = anyFieldC[[]int16](Int16s)\n\tcase int8:\n\t\tc = anyFieldC[int8](Int8)\n\tcase *int8:\n\t\tc = anyFieldC[*int8](Int8p)\n\tcase []int8:\n\t\tc = anyFieldC[[]int8](Int8s)\n\tcase string:\n\t\tc = anyFieldC[string](String)\n\tcase *string:\n\t\tc = anyFieldC[*string](Stringp)\n\tcase []string:\n\t\tc = anyFieldC[[]string](Strings)\n\tcase uint:\n\t\tc = anyFieldC[uint](Uint)\n\tcase *uint:\n\t\tc = anyFieldC[*uint](Uintp)\n\tcase []uint:\n\t\tc = anyFieldC[[]uint](Uints)\n\tcase uint64:\n\t\tc = anyFieldC[uint64](Uint64)\n\tcase *uint64:\n\t\tc = anyFieldC[*uint64](Uint64p)\n\tcase []uint64:\n\t\tc = anyFieldC[[]uint64](Uint64s)\n\tcase uint32:\n\t\tc = anyFieldC[uint32](Uint32)\n\tcase *uint32:\n\t\tc = anyFieldC[*uint32](Uint32p)\n\tcase []uint32:\n\t\tc = anyFieldC[[]uint32](Uint32s)\n\tcase uint16:\n\t\tc = anyFieldC[uint16](Uint16)\n\tcase *uint16:\n\t\tc = anyFieldC[*uint16](Uint16p)\n\tcase []uint16:\n\t\tc = anyFieldC[[]uint16](Uint16s)\n\tcase uint8:\n\t\tc = anyFieldC[uint8](Uint8)\n\tcase *uint8:\n\t\tc = anyFieldC[*uint8](Uint8p)\n\tcase []byte:\n\t\tc = anyFieldC[[]byte](Binary)\n\tcase uintptr:\n\t\tc = anyFieldC[uintptr](Uintptr)\n\tcase *uintptr:\n\t\tc = anyFieldC[*uintptr](Uintptrp)\n\tcase []uintptr:\n\t\tc = anyFieldC[[]uintptr](Uintptrs)\n\tcase time.Time:\n\t\tc = anyFieldC[time.Time](Time)\n\tcase *time.Time:\n\t\tc = anyFieldC[*time.Time](Timep)\n\tcase []time.Time:\n\t\tc = anyFieldC[[]time.Time](Times)\n\tcase time.Duration:\n\t\tc = anyFieldC[time.Duration](Duration)\n\tcase *time.Duration:\n\t\tc = anyFieldC[*time.Duration](Durationp)\n\tcase []time.Duration:\n\t\tc = anyFieldC[[]time.Duration](Durations)\n\tcase error:\n\t\tc = anyFieldC[error](NamedError)\n\tcase []error:\n\t\tc = anyFieldC[[]error](Errors)\n\tcase fmt.Stringer:\n\t\tc = anyFieldC[fmt.Stringer](Stringer)\n\tdefault:\n\t\tc = anyFieldC[any](Reflect)\n\t}\n\n\treturn c.Any(key, value)\n}\n"
        },
        {
          "name": "field_test.go",
          "type": "blob",
          "size": 16.46484375,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"math\"\n\t\"net\"\n\t\"regexp\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/zap/internal/stacktrace\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\ntype username string\n\nfunc (n username) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\tenc.AddString(\"username\", string(n))\n\treturn nil\n}\n\nfunc assertCanBeReused(t testing.TB, field Field) {\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 100; i++ {\n\t\tenc := zapcore.NewMapObjectEncoder()\n\n\t\t// Ensure using the field in multiple encoders in separate goroutines\n\t\t// does not cause any races or panics.\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tassert.NotPanics(t, func() {\n\t\t\t\tfield.AddTo(enc)\n\t\t\t}, \"Reusing a field should not cause issues\")\n\t\t}()\n\t}\n\n\twg.Wait()\n}\n\nfunc TestFieldConstructors(t *testing.T) {\n\t// Interface types.\n\taddr := net.ParseIP(\"1.2.3.4\")\n\tname := username(\"phil\")\n\tints := []int{5, 6}\n\n\t// Helpful values for use in constructing pointers to primitives below.\n\tvar (\n\t\tboolVal       = bool(true)\n\t\tcomplex128Val = complex128(complex(0, 0))\n\t\tcomplex64Val  = complex64(complex(0, 0))\n\t\tdurationVal   = time.Duration(time.Second)\n\t\tfloat64Val    = float64(1.0)\n\t\tfloat32Val    = float32(1.0)\n\t\tintVal        = int(1)\n\t\tint64Val      = int64(1)\n\t\tint32Val      = int32(1)\n\t\tint16Val      = int16(1)\n\t\tint8Val       = int8(1)\n\t\tstringVal     = string(\"hello\")\n\t\ttimeVal       = time.Unix(100000, 0)\n\t\tuintVal       = uint(1)\n\t\tuint64Val     = uint64(1)\n\t\tuint32Val     = uint32(1)\n\t\tuint16Val     = uint16(1)\n\t\tuint8Val      = uint8(1)\n\t\tuintptrVal    = uintptr(1)\n\t\tnilErr        error\n\t)\n\n\ttests := []struct {\n\t\tname   string\n\t\tfield  Field\n\t\texpect Field\n\t}{\n\t\t{\"Skip\", Field{Type: zapcore.SkipType}, Skip()},\n\t\t{\"Binary\", Field{Key: \"k\", Type: zapcore.BinaryType, Interface: []byte(\"ab12\")}, Binary(\"k\", []byte(\"ab12\"))},\n\t\t{\"Bool\", Field{Key: \"k\", Type: zapcore.BoolType, Integer: 1}, Bool(\"k\", true)},\n\t\t{\"Bool\", Field{Key: \"k\", Type: zapcore.BoolType, Integer: 0}, Bool(\"k\", false)},\n\t\t{\"ByteString\", Field{Key: \"k\", Type: zapcore.ByteStringType, Interface: []byte(\"ab12\")}, ByteString(\"k\", []byte(\"ab12\"))},\n\t\t{\"Complex128\", Field{Key: \"k\", Type: zapcore.Complex128Type, Interface: 1 + 2i}, Complex128(\"k\", 1+2i)},\n\t\t{\"Complex64\", Field{Key: \"k\", Type: zapcore.Complex64Type, Interface: complex64(1 + 2i)}, Complex64(\"k\", 1+2i)},\n\t\t{\"Duration\", Field{Key: \"k\", Type: zapcore.DurationType, Integer: 1}, Duration(\"k\", 1)},\n\t\t{\"Int\", Field{Key: \"k\", Type: zapcore.Int64Type, Integer: 1}, Int(\"k\", 1)},\n\t\t{\"Int64\", Field{Key: \"k\", Type: zapcore.Int64Type, Integer: 1}, Int64(\"k\", 1)},\n\t\t{\"Int32\", Field{Key: \"k\", Type: zapcore.Int32Type, Integer: 1}, Int32(\"k\", 1)},\n\t\t{\"Int16\", Field{Key: \"k\", Type: zapcore.Int16Type, Integer: 1}, Int16(\"k\", 1)},\n\t\t{\"Int8\", Field{Key: \"k\", Type: zapcore.Int8Type, Integer: 1}, Int8(\"k\", 1)},\n\t\t{\"String\", Field{Key: \"k\", Type: zapcore.StringType, String: \"foo\"}, String(\"k\", \"foo\")},\n\t\t{\"Time\", Field{Key: \"k\", Type: zapcore.TimeType, Integer: 0, Interface: time.UTC}, Time(\"k\", time.Unix(0, 0).In(time.UTC))},\n\t\t{\"Time\", Field{Key: \"k\", Type: zapcore.TimeType, Integer: 1000, Interface: time.UTC}, Time(\"k\", time.Unix(0, 1000).In(time.UTC))},\n\t\t{\"Time\", Field{Key: \"k\", Type: zapcore.TimeType, Integer: math.MinInt64, Interface: time.UTC}, Time(\"k\", time.Unix(0, math.MinInt64).In(time.UTC))},\n\t\t{\"Time\", Field{Key: \"k\", Type: zapcore.TimeType, Integer: math.MaxInt64, Interface: time.UTC}, Time(\"k\", time.Unix(0, math.MaxInt64).In(time.UTC))},\n\t\t{\"Time\", Field{Key: \"k\", Type: zapcore.TimeFullType, Interface: time.Time{}}, Time(\"k\", time.Time{})},\n\t\t{\"Time\", Field{Key: \"k\", Type: zapcore.TimeFullType, Interface: time.Unix(math.MaxInt64, 0)}, Time(\"k\", time.Unix(math.MaxInt64, 0))},\n\t\t{\"Uint\", Field{Key: \"k\", Type: zapcore.Uint64Type, Integer: 1}, Uint(\"k\", 1)},\n\t\t{\"Uint64\", Field{Key: \"k\", Type: zapcore.Uint64Type, Integer: 1}, Uint64(\"k\", 1)},\n\t\t{\"Uint32\", Field{Key: \"k\", Type: zapcore.Uint32Type, Integer: 1}, Uint32(\"k\", 1)},\n\t\t{\"Uint16\", Field{Key: \"k\", Type: zapcore.Uint16Type, Integer: 1}, Uint16(\"k\", 1)},\n\t\t{\"Uint8\", Field{Key: \"k\", Type: zapcore.Uint8Type, Integer: 1}, Uint8(\"k\", 1)},\n\t\t{\"Uintptr\", Field{Key: \"k\", Type: zapcore.UintptrType, Integer: 10}, Uintptr(\"k\", 0xa)},\n\t\t{\"Reflect\", Field{Key: \"k\", Type: zapcore.ReflectType, Interface: ints}, Reflect(\"k\", ints)},\n\t\t{\"Reflect\", Field{Key: \"k\", Type: zapcore.ReflectType}, Reflect(\"k\", nil)},\n\t\t{\"Stringer\", Field{Key: \"k\", Type: zapcore.StringerType, Interface: addr}, Stringer(\"k\", addr)},\n\t\t{\"Object\", Field{Key: \"k\", Type: zapcore.ObjectMarshalerType, Interface: name}, Object(\"k\", name)},\n\t\t{\"Inline\", Field{Type: zapcore.InlineMarshalerType, Interface: name}, Inline(name)},\n\t\t{\"Any:ObjectMarshaler\", Any(\"k\", name), Object(\"k\", name)},\n\t\t{\"Any:ArrayMarshaler\", Any(\"k\", bools([]bool{true})), Array(\"k\", bools([]bool{true}))},\n\t\t{\"Any:Dict\", Any(\"k\", []Field{String(\"k\", \"v\")}), Dict(\"k\", String(\"k\", \"v\"))},\n\t\t{\"Any:Stringer\", Any(\"k\", addr), Stringer(\"k\", addr)},\n\t\t{\"Any:Bool\", Any(\"k\", true), Bool(\"k\", true)},\n\t\t{\"Any:Bools\", Any(\"k\", []bool{true}), Bools(\"k\", []bool{true})},\n\t\t{\"Any:Byte\", Any(\"k\", byte(1)), Uint8(\"k\", 1)},\n\t\t{\"Any:Bytes\", Any(\"k\", []byte{1}), Binary(\"k\", []byte{1})},\n\t\t{\"Any:Complex128\", Any(\"k\", 1+2i), Complex128(\"k\", 1+2i)},\n\t\t{\"Any:Complex128s\", Any(\"k\", []complex128{1 + 2i}), Complex128s(\"k\", []complex128{1 + 2i})},\n\t\t{\"Any:Complex64\", Any(\"k\", complex64(1+2i)), Complex64(\"k\", 1+2i)},\n\t\t{\"Any:Complex64s\", Any(\"k\", []complex64{1 + 2i}), Complex64s(\"k\", []complex64{1 + 2i})},\n\t\t{\"Any:Float64\", Any(\"k\", 3.14), Float64(\"k\", 3.14)},\n\t\t{\"Any:Float64s\", Any(\"k\", []float64{3.14}), Float64s(\"k\", []float64{3.14})},\n\t\t{\"Any:Float32\", Any(\"k\", float32(3.14)), Float32(\"k\", 3.14)},\n\t\t{\"Any:Float32s\", Any(\"k\", []float32{3.14}), Float32s(\"k\", []float32{3.14})},\n\t\t{\"Any:Int\", Any(\"k\", 1), Int(\"k\", 1)},\n\t\t{\"Any:Ints\", Any(\"k\", []int{1}), Ints(\"k\", []int{1})},\n\t\t{\"Any:Int64\", Any(\"k\", int64(1)), Int64(\"k\", 1)},\n\t\t{\"Any:Int64s\", Any(\"k\", []int64{1}), Int64s(\"k\", []int64{1})},\n\t\t{\"Any:Int32\", Any(\"k\", int32(1)), Int32(\"k\", 1)},\n\t\t{\"Any:Int32s\", Any(\"k\", []int32{1}), Int32s(\"k\", []int32{1})},\n\t\t{\"Any:Int16\", Any(\"k\", int16(1)), Int16(\"k\", 1)},\n\t\t{\"Any:Int16s\", Any(\"k\", []int16{1}), Int16s(\"k\", []int16{1})},\n\t\t{\"Any:Int8\", Any(\"k\", int8(1)), Int8(\"k\", 1)},\n\t\t{\"Any:Int8s\", Any(\"k\", []int8{1}), Int8s(\"k\", []int8{1})},\n\t\t{\"Any:Rune\", Any(\"k\", rune(1)), Int32(\"k\", 1)},\n\t\t{\"Any:Runes\", Any(\"k\", []rune{1}), Int32s(\"k\", []int32{1})},\n\t\t{\"Any:String\", Any(\"k\", \"v\"), String(\"k\", \"v\")},\n\t\t{\"Any:Strings\", Any(\"k\", []string{\"v\"}), Strings(\"k\", []string{\"v\"})},\n\t\t{\"Any:Uint\", Any(\"k\", uint(1)), Uint(\"k\", 1)},\n\t\t{\"Any:Uints\", Any(\"k\", []uint{1}), Uints(\"k\", []uint{1})},\n\t\t{\"Any:Uint64\", Any(\"k\", uint64(1)), Uint64(\"k\", 1)},\n\t\t{\"Any:Uint64s\", Any(\"k\", []uint64{1}), Uint64s(\"k\", []uint64{1})},\n\t\t{\"Any:Uint32\", Any(\"k\", uint32(1)), Uint32(\"k\", 1)},\n\t\t{\"Any:Uint32s\", Any(\"k\", []uint32{1}), Uint32s(\"k\", []uint32{1})},\n\t\t{\"Any:Uint16\", Any(\"k\", uint16(1)), Uint16(\"k\", 1)},\n\t\t{\"Any:Uint16s\", Any(\"k\", []uint16{1}), Uint16s(\"k\", []uint16{1})},\n\t\t{\"Any:Uint8\", Any(\"k\", uint8(1)), Uint8(\"k\", 1)},\n\t\t{\"Any:Uint8s\", Any(\"k\", []uint8{1}), Binary(\"k\", []uint8{1})},\n\t\t{\"Any:Uintptr\", Any(\"k\", uintptr(1)), Uintptr(\"k\", 1)},\n\t\t{\"Any:Uintptrs\", Any(\"k\", []uintptr{1}), Uintptrs(\"k\", []uintptr{1})},\n\t\t{\"Any:Time\", Any(\"k\", time.Unix(0, 0)), Time(\"k\", time.Unix(0, 0))},\n\t\t{\"Any:TimeFullType\", Any(\"k\", time.Time{}), Time(\"k\", time.Time{})},\n\t\t{\"Any:Times\", Any(\"k\", []time.Time{time.Unix(0, 0)}), Times(\"k\", []time.Time{time.Unix(0, 0)})},\n\t\t{\"Any:Duration\", Any(\"k\", time.Second), Duration(\"k\", time.Second)},\n\t\t{\"Any:Durations\", Any(\"k\", []time.Duration{time.Second}), Durations(\"k\", []time.Duration{time.Second})},\n\t\t{\"Any:Fallback\", Any(\"k\", struct{}{}), Reflect(\"k\", struct{}{})},\n\t\t{\"Ptr:Bool\", Boolp(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Bool\", Boolp(\"k\", &boolVal), Bool(\"k\", boolVal)},\n\t\t{\"Any:PtrBool\", Any(\"k\", (*bool)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrBool\", Any(\"k\", &boolVal), Bool(\"k\", boolVal)},\n\t\t{\"Ptr:Complex128\", Complex128p(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Complex128\", Complex128p(\"k\", &complex128Val), Complex128(\"k\", complex128Val)},\n\t\t{\"Any:PtrComplex128\", Any(\"k\", (*complex128)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrComplex128\", Any(\"k\", &complex128Val), Complex128(\"k\", complex128Val)},\n\t\t{\"Ptr:Complex64\", Complex64p(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Complex64\", Complex64p(\"k\", &complex64Val), Complex64(\"k\", complex64Val)},\n\t\t{\"Any:PtrComplex64\", Any(\"k\", (*complex64)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrComplex64\", Any(\"k\", &complex64Val), Complex64(\"k\", complex64Val)},\n\t\t{\"Ptr:Duration\", Durationp(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Duration\", Durationp(\"k\", &durationVal), Duration(\"k\", durationVal)},\n\t\t{\"Any:PtrDuration\", Any(\"k\", (*time.Duration)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrDuration\", Any(\"k\", &durationVal), Duration(\"k\", durationVal)},\n\t\t{\"Ptr:Float64\", Float64p(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Float64\", Float64p(\"k\", &float64Val), Float64(\"k\", float64Val)},\n\t\t{\"Any:PtrFloat64\", Any(\"k\", (*float64)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrFloat64\", Any(\"k\", &float64Val), Float64(\"k\", float64Val)},\n\t\t{\"Ptr:Float32\", Float32p(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Float32\", Float32p(\"k\", &float32Val), Float32(\"k\", float32Val)},\n\t\t{\"Any:PtrFloat32\", Any(\"k\", (*float32)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrFloat32\", Any(\"k\", &float32Val), Float32(\"k\", float32Val)},\n\t\t{\"Ptr:Int\", Intp(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Int\", Intp(\"k\", &intVal), Int(\"k\", intVal)},\n\t\t{\"Any:PtrInt\", Any(\"k\", (*int)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrInt\", Any(\"k\", &intVal), Int(\"k\", intVal)},\n\t\t{\"Ptr:Int64\", Int64p(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Int64\", Int64p(\"k\", &int64Val), Int64(\"k\", int64Val)},\n\t\t{\"Any:PtrInt64\", Any(\"k\", (*int64)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrInt64\", Any(\"k\", &int64Val), Int64(\"k\", int64Val)},\n\t\t{\"Ptr:Int32\", Int32p(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Int32\", Int32p(\"k\", &int32Val), Int32(\"k\", int32Val)},\n\t\t{\"Any:PtrInt32\", Any(\"k\", (*int32)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrInt32\", Any(\"k\", &int32Val), Int32(\"k\", int32Val)},\n\t\t{\"Ptr:Int16\", Int16p(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Int16\", Int16p(\"k\", &int16Val), Int16(\"k\", int16Val)},\n\t\t{\"Any:PtrInt16\", Any(\"k\", (*int16)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrInt16\", Any(\"k\", &int16Val), Int16(\"k\", int16Val)},\n\t\t{\"Ptr:Int8\", Int8p(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Int8\", Int8p(\"k\", &int8Val), Int8(\"k\", int8Val)},\n\t\t{\"Any:PtrInt8\", Any(\"k\", (*int8)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrInt8\", Any(\"k\", &int8Val), Int8(\"k\", int8Val)},\n\t\t{\"Ptr:String\", Stringp(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:String\", Stringp(\"k\", &stringVal), String(\"k\", stringVal)},\n\t\t{\"Any:PtrString\", Any(\"k\", (*string)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrString\", Any(\"k\", &stringVal), String(\"k\", stringVal)},\n\t\t{\"Ptr:Time\", Timep(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Time\", Timep(\"k\", &timeVal), Time(\"k\", timeVal)},\n\t\t{\"Any:PtrTime\", Any(\"k\", (*time.Time)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrTime\", Any(\"k\", &timeVal), Time(\"k\", timeVal)},\n\t\t{\"Any:PtrTimeFullType\", Any(\"k\", &time.Time{}), Time(\"k\", time.Time{})},\n\t\t{\"Ptr:Uint\", Uintp(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Uint\", Uintp(\"k\", &uintVal), Uint(\"k\", uintVal)},\n\t\t{\"Any:PtrUint\", Any(\"k\", (*uint)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrUint\", Any(\"k\", &uintVal), Uint(\"k\", uintVal)},\n\t\t{\"Ptr:Uint64\", Uint64p(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Uint64\", Uint64p(\"k\", &uint64Val), Uint64(\"k\", uint64Val)},\n\t\t{\"Any:PtrUint64\", Any(\"k\", (*uint64)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrUint64\", Any(\"k\", &uint64Val), Uint64(\"k\", uint64Val)},\n\t\t{\"Ptr:Uint32\", Uint32p(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Uint32\", Uint32p(\"k\", &uint32Val), Uint32(\"k\", uint32Val)},\n\t\t{\"Any:PtrUint32\", Any(\"k\", (*uint32)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrUint32\", Any(\"k\", &uint32Val), Uint32(\"k\", uint32Val)},\n\t\t{\"Ptr:Uint16\", Uint16p(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Uint16\", Uint16p(\"k\", &uint16Val), Uint16(\"k\", uint16Val)},\n\t\t{\"Any:PtrUint16\", Any(\"k\", (*uint16)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrUint16\", Any(\"k\", &uint16Val), Uint16(\"k\", uint16Val)},\n\t\t{\"Ptr:Uint8\", Uint8p(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Uint8\", Uint8p(\"k\", &uint8Val), Uint8(\"k\", uint8Val)},\n\t\t{\"Any:PtrUint8\", Any(\"k\", (*uint8)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrUint8\", Any(\"k\", &uint8Val), Uint8(\"k\", uint8Val)},\n\t\t{\"Ptr:Uintptr\", Uintptrp(\"k\", nil), nilField(\"k\")},\n\t\t{\"Ptr:Uintptr\", Uintptrp(\"k\", &uintptrVal), Uintptr(\"k\", uintptrVal)},\n\t\t{\"Any:PtrUintptr\", Any(\"k\", (*uintptr)(nil)), nilField(\"k\")},\n\t\t{\"Any:PtrUintptr\", Any(\"k\", &uintptrVal), Uintptr(\"k\", uintptrVal)},\n\t\t{\"Any:ErrorNil\", Any(\"k\", nilErr), nilField(\"k\")},\n\t\t{\"Namespace\", Namespace(\"k\"), Field{Key: \"k\", Type: zapcore.NamespaceType}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif !assert.Equal(t, tt.expect, tt.field, \"Unexpected output from convenience field constructor\") {\n\t\t\t\tt.Logf(\"type expected: %T\\nGot: %T\", tt.expect.Interface, tt.field.Interface)\n\t\t\t}\n\t\t\tassertCanBeReused(t, tt.field)\n\t\t})\n\t}\n}\n\nfunc TestStackField(t *testing.T) {\n\tf := Stack(\"stacktrace\")\n\tassert.Equal(t, \"stacktrace\", f.Key, \"Unexpected field key.\")\n\tassert.Equal(t, zapcore.StringType, f.Type, \"Unexpected field type.\")\n\tr := regexp.MustCompile(`field_test.go:(\\d+)`)\n\tassert.Equal(t, r.ReplaceAllString(stacktrace.Take(0), \"field_test.go\"), r.ReplaceAllString(f.String, \"field_test.go\"), \"Unexpected stack trace\")\n\tassertCanBeReused(t, f)\n}\n\nfunc TestStackSkipField(t *testing.T) {\n\tf := StackSkip(\"stacktrace\", 0)\n\tassert.Equal(t, \"stacktrace\", f.Key, \"Unexpected field key.\")\n\tassert.Equal(t, zapcore.StringType, f.Type, \"Unexpected field type.\")\n\tr := regexp.MustCompile(`field_test.go:(\\d+)`)\n\tassert.Equal(t, r.ReplaceAllString(stacktrace.Take(0), \"field_test.go\"), r.ReplaceAllString(f.String, \"field_test.go\"), f.String, \"Unexpected stack trace\")\n\tassertCanBeReused(t, f)\n}\n\nfunc TestStackSkipFieldWithSkip(t *testing.T) {\n\tf := StackSkip(\"stacktrace\", 1)\n\tassert.Equal(t, \"stacktrace\", f.Key, \"Unexpected field key.\")\n\tassert.Equal(t, zapcore.StringType, f.Type, \"Unexpected field type.\")\n\tassert.Equal(t, stacktrace.Take(1), f.String, \"Unexpected stack trace\")\n\tassertCanBeReused(t, f)\n}\n\nfunc TestDict(t *testing.T) {\n\ttests := []struct {\n\t\tdesc     string\n\t\tfield    Field\n\t\texpected any\n\t}{\n\t\t{\"empty\", Dict(\"\"), map[string]any{}},\n\t\t{\"single\", Dict(\"\", String(\"k\", \"v\")), map[string]any{\"k\": \"v\"}},\n\t\t{\"multiple\", Dict(\"\", String(\"k\", \"v\"), String(\"k2\", \"v2\")), map[string]any{\"k\": \"v\", \"k2\": \"v2\"}},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tenc := zapcore.NewMapObjectEncoder()\n\t\t\ttt.field.Key = \"k\"\n\t\t\ttt.field.AddTo(enc)\n\t\t\tassert.Equal(t, tt.expected, enc.Fields[\"k\"], \"unexpected map contents\")\n\t\t\tassert.Len(t, enc.Fields, 1, \"found extra keys in map: %v\", enc.Fields)\n\n\t\t\tassertCanBeReused(t, tt.field)\n\t\t})\n\t}\n}\n\nfunc TestDictObject(t *testing.T) {\n\ttests := []struct {\n\t\tdesc     string\n\t\tfield    Field\n\t\texpected any\n\t}{\n\t\t{\n\t\t\t\"empty\",\n\t\t\tObject(\"\", DictObject()),\n\t\t\tmap[string]any{},\n\t\t},\n\t\t{\n\t\t\t\"object\",\n\t\t\tObject(\"\", DictObject(String(\"k\", \"v\"))),\n\t\t\tmap[string]any{\"k\": \"v\"},\n\t\t},\n\t\t{\n\t\t\t\"objects\",\n\t\t\tObjects(\"\", []zapcore.ObjectMarshaler{\n\t\t\t\tDictObject(String(\"k\", \"v\")),\n\t\t\t\tDictObject(String(\"k2\", \"v2\")),\n\t\t\t}),\n\t\t\t[]any{\n\t\t\t\tmap[string]any{\"k\": \"v\"},\n\t\t\t\tmap[string]any{\"k2\": \"v2\"},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tenc := zapcore.NewMapObjectEncoder()\n\t\t\ttt.field.Key = \"k\"\n\t\t\ttt.field.AddTo(enc)\n\t\t\tassert.Equal(t, tt.expected, enc.Fields[\"k\"], \"unexpected map contents\")\n\t\t\tassert.Len(t, enc.Fields, 1, \"found extra keys in map: %v\", enc.Fields)\n\n\t\t\tassertCanBeReused(t, tt.field)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "flag.go",
          "type": "blob",
          "size": 1.6318359375,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"flag\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// LevelFlag uses the standard library's flag.Var to declare a global flag\n// with the specified name, default, and usage guidance. The returned value is\n// a pointer to the value of the flag.\n//\n// If you don't want to use the flag package's global state, you can use any\n// non-nil *Level as a flag.Value with your own *flag.FlagSet.\nfunc LevelFlag(name string, defaultLevel zapcore.Level, usage string) *zapcore.Level {\n\tlvl := defaultLevel\n\tflag.Var(&lvl, name, usage)\n\treturn &lvl\n}\n"
        },
        {
          "name": "flag_test.go",
          "type": "blob",
          "size": 3.23828125,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"flag\"\n\t\"io\"\n\t\"testing\"\n\n\t\"go.uber.org/zap/zapcore\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype flagTestCase struct {\n\targs      []string\n\twantLevel zapcore.Level\n\twantErr   bool\n}\n\nfunc (tc flagTestCase) runImplicitSet(t testing.TB) {\n\torigCommandLine := flag.CommandLine\n\tflag.CommandLine = flag.NewFlagSet(\"test\", flag.ContinueOnError)\n\tflag.CommandLine.SetOutput(io.Discard)\n\tdefer func() { flag.CommandLine = origCommandLine }()\n\n\tlevel := LevelFlag(\"level\", InfoLevel, \"\")\n\ttc.run(t, flag.CommandLine, level)\n}\n\nfunc (tc flagTestCase) runExplicitSet(t testing.TB) {\n\tvar lvl zapcore.Level\n\tset := flag.NewFlagSet(\"test\", flag.ContinueOnError)\n\tset.SetOutput(io.Discard)\n\tset.Var(&lvl, \"level\", \"minimum enabled logging level\")\n\ttc.run(t, set, &lvl)\n}\n\nfunc (tc flagTestCase) run(t testing.TB, set *flag.FlagSet, actual *zapcore.Level) {\n\terr := set.Parse(tc.args)\n\tif tc.wantErr {\n\t\tassert.Error(t, err, \"Parse(%v) should fail.\", tc.args)\n\t\treturn\n\t}\n\tif assert.NoError(t, err, \"Parse(%v) should succeed.\", tc.args) {\n\t\tassert.Equal(t, tc.wantLevel, *actual, \"Level mismatch.\")\n\t}\n}\n\nfunc TestLevelFlag(t *testing.T) {\n\ttests := []flagTestCase{\n\t\t{\n\t\t\targs:      nil,\n\t\t\twantLevel: zapcore.InfoLevel,\n\t\t},\n\t\t{\n\t\t\targs:    []string{\"--level\", \"unknown\"},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\targs:      []string{\"--level\", \"error\"},\n\t\t\twantLevel: zapcore.ErrorLevel,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt.runExplicitSet(t)\n\t\ttt.runImplicitSet(t)\n\t}\n}\n\nfunc TestLevelFlagsAreIndependent(t *testing.T) {\n\torigCommandLine := flag.CommandLine\n\tflag.CommandLine = flag.NewFlagSet(\"test\", flag.ContinueOnError)\n\tflag.CommandLine.SetOutput(io.Discard)\n\tdefer func() { flag.CommandLine = origCommandLine }()\n\n\t// Make sure that these two flags are independent.\n\tfileLevel := LevelFlag(\"file-level\", InfoLevel, \"\")\n\tconsoleLevel := LevelFlag(\"console-level\", InfoLevel, \"\")\n\n\tassert.NoError(t, flag.CommandLine.Parse([]string{\"-file-level\", \"debug\"}), \"Unexpected flag-parsing error.\")\n\tassert.Equal(t, InfoLevel, *consoleLevel, \"Expected file logging level to remain unchanged.\")\n\tassert.Equal(t, DebugLevel, *fileLevel, \"Expected console logging level to have changed.\")\n}\n"
        },
        {
          "name": "glide.yaml",
          "type": "blob",
          "size": 0.7529296875,
          "content": "package: go.uber.org/zap\nlicense: MIT\nimport:\n- package: go.uber.org/atomic\n  version: ^1\n- package: go.uber.org/multierr\n  version: ^1\ntestImport:\n- package: github.com/satori/go.uuid\n- package: github.com/sirupsen/logrus\n- package: github.com/apex/log\n  subpackages:\n  - handlers/json\n- package: github.com/go-kit/kit\n  subpackages:\n  - log\n- package: github.com/stretchr/testify\n  subpackages:\n  - assert\n  - require\n- package: gopkg.in/inconshreveable/log15.v2\n- package: github.com/mattn/goveralls\n- package: github.com/pborman/uuid\n- package: github.com/pkg/errors\n- package: github.com/rs/zerolog\n- package: golang.org/x/tools\n  subpackages:\n  - cover\n- package: golang.org/x/lint\n  subpackages:\n  - golint\n- package: github.com/axw/gocov\n  subpackages:\n  - gocov\n"
        },
        {
          "name": "global.go",
          "type": "blob",
          "size": 5.255859375,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"sync\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\nconst (\n\t_stdLogDefaultDepth      = 1\n\t_loggerWriterDepth       = 2\n\t_programmerErrorTemplate = \"You've found a bug in zap! Please file a bug at \" +\n\t\t\"https://github.com/uber-go/zap/issues/new and reference this error: %v\"\n)\n\nvar (\n\t_globalMu sync.RWMutex\n\t_globalL  = NewNop()\n\t_globalS  = _globalL.Sugar()\n)\n\n// L returns the global Logger, which can be reconfigured with ReplaceGlobals.\n// It's safe for concurrent use.\nfunc L() *Logger {\n\t_globalMu.RLock()\n\tl := _globalL\n\t_globalMu.RUnlock()\n\treturn l\n}\n\n// S returns the global SugaredLogger, which can be reconfigured with\n// ReplaceGlobals. It's safe for concurrent use.\nfunc S() *SugaredLogger {\n\t_globalMu.RLock()\n\ts := _globalS\n\t_globalMu.RUnlock()\n\treturn s\n}\n\n// ReplaceGlobals replaces the global Logger and SugaredLogger, and returns a\n// function to restore the original values. It's safe for concurrent use.\nfunc ReplaceGlobals(logger *Logger) func() {\n\t_globalMu.Lock()\n\tprev := _globalL\n\t_globalL = logger\n\t_globalS = logger.Sugar()\n\t_globalMu.Unlock()\n\treturn func() { ReplaceGlobals(prev) }\n}\n\n// NewStdLog returns a *log.Logger which writes to the supplied zap Logger at\n// InfoLevel. To redirect the standard library's package-global logging\n// functions, use RedirectStdLog instead.\nfunc NewStdLog(l *Logger) *log.Logger {\n\tlogger := l.WithOptions(AddCallerSkip(_stdLogDefaultDepth + _loggerWriterDepth))\n\tf := logger.Info\n\treturn log.New(&loggerWriter{f}, \"\" /* prefix */, 0 /* flags */)\n}\n\n// NewStdLogAt returns *log.Logger which writes to supplied zap logger at\n// required level.\nfunc NewStdLogAt(l *Logger, level zapcore.Level) (*log.Logger, error) {\n\tlogger := l.WithOptions(AddCallerSkip(_stdLogDefaultDepth + _loggerWriterDepth))\n\tlogFunc, err := levelToFunc(logger, level)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn log.New(&loggerWriter{logFunc}, \"\" /* prefix */, 0 /* flags */), nil\n}\n\n// RedirectStdLog redirects output from the standard library's package-global\n// logger to the supplied logger at InfoLevel. Since zap already handles caller\n// annotations, timestamps, etc., it automatically disables the standard\n// library's annotations and prefixing.\n//\n// It returns a function to restore the original prefix and flags and reset the\n// standard library's output to os.Stderr.\nfunc RedirectStdLog(l *Logger) func() {\n\tf, err := redirectStdLogAt(l, InfoLevel)\n\tif err != nil {\n\t\t// Can't get here, since passing InfoLevel to redirectStdLogAt always\n\t\t// works.\n\t\tpanic(fmt.Sprintf(_programmerErrorTemplate, err))\n\t}\n\treturn f\n}\n\n// RedirectStdLogAt redirects output from the standard library's package-global\n// logger to the supplied logger at the specified level. Since zap already\n// handles caller annotations, timestamps, etc., it automatically disables the\n// standard library's annotations and prefixing.\n//\n// It returns a function to restore the original prefix and flags and reset the\n// standard library's output to os.Stderr.\nfunc RedirectStdLogAt(l *Logger, level zapcore.Level) (func(), error) {\n\treturn redirectStdLogAt(l, level)\n}\n\nfunc redirectStdLogAt(l *Logger, level zapcore.Level) (func(), error) {\n\tflags := log.Flags()\n\tprefix := log.Prefix()\n\tlog.SetFlags(0)\n\tlog.SetPrefix(\"\")\n\tlogger := l.WithOptions(AddCallerSkip(_stdLogDefaultDepth + _loggerWriterDepth))\n\tlogFunc, err := levelToFunc(logger, level)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlog.SetOutput(&loggerWriter{logFunc})\n\treturn func() {\n\t\tlog.SetFlags(flags)\n\t\tlog.SetPrefix(prefix)\n\t\tlog.SetOutput(os.Stderr)\n\t}, nil\n}\n\nfunc levelToFunc(logger *Logger, lvl zapcore.Level) (func(string, ...Field), error) {\n\tswitch lvl {\n\tcase DebugLevel:\n\t\treturn logger.Debug, nil\n\tcase InfoLevel:\n\t\treturn logger.Info, nil\n\tcase WarnLevel:\n\t\treturn logger.Warn, nil\n\tcase ErrorLevel:\n\t\treturn logger.Error, nil\n\tcase DPanicLevel:\n\t\treturn logger.DPanic, nil\n\tcase PanicLevel:\n\t\treturn logger.Panic, nil\n\tcase FatalLevel:\n\t\treturn logger.Fatal, nil\n\t}\n\treturn nil, fmt.Errorf(\"unrecognized level: %q\", lvl)\n}\n\ntype loggerWriter struct {\n\tlogFunc func(msg string, fields ...Field)\n}\n\nfunc (l *loggerWriter) Write(p []byte) (int, error) {\n\tp = bytes.TrimSpace(p)\n\tl.logFunc(string(p))\n\treturn len(p), nil\n}\n"
        },
        {
          "name": "global_test.go",
          "type": "blob",
          "size": 9.1396484375,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"log\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"go.uber.org/zap/internal/exit\"\n\t\"go.uber.org/zap/internal/ztest\"\n\n\t\"go.uber.org/zap/zapcore\"\n\t\"go.uber.org/zap/zaptest/observer\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestReplaceGlobals(t *testing.T) {\n\tinitialL := *L()\n\tinitialS := *S()\n\n\twithLogger(t, DebugLevel, nil, func(l *Logger, logs *observer.ObservedLogs) {\n\t\tL().Info(\"no-op\")\n\t\tS().Info(\"no-op\")\n\t\tassert.Equal(t, 0, logs.Len(), \"Expected initial logs to go to default no-op global.\")\n\n\t\tdefer ReplaceGlobals(l)()\n\n\t\tL().Info(\"captured\")\n\t\tS().Info(\"captured\")\n\t\texpected := observer.LoggedEntry{\n\t\t\tEntry:   zapcore.Entry{Message: \"captured\"},\n\t\t\tContext: []Field{},\n\t\t}\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t[]observer.LoggedEntry{expected, expected},\n\t\t\tlogs.AllUntimed(),\n\t\t\t\"Unexpected global log output.\",\n\t\t)\n\t})\n\n\tassert.Equal(t, initialL, *L(), \"Expected func returned from ReplaceGlobals to restore initial L.\")\n\tassert.Equal(t, initialS, *S(), \"Expected func returned from ReplaceGlobals to restore initial S.\")\n}\n\nfunc TestGlobalsConcurrentUse(t *testing.T) {\n\tvar (\n\t\tstop atomic.Bool\n\t\twg   sync.WaitGroup\n\t)\n\n\tfor i := 0; i < 100; i++ {\n\t\twg.Add(2)\n\t\tgo func() {\n\t\t\tfor !stop.Load() {\n\t\t\t\tReplaceGlobals(NewNop())\n\t\t\t}\n\t\t\twg.Done()\n\t\t}()\n\t\tgo func() {\n\t\t\tfor !stop.Load() {\n\t\t\t\tL().With(Int(\"foo\", 42)).Named(\"main\").WithOptions(Development()).Info(\"\")\n\t\t\t\tS().Info(\"\")\n\t\t\t}\n\t\t\twg.Done()\n\t\t}()\n\t}\n\n\tztest.Sleep(100 * time.Millisecond)\n\t// CAS loop to toggle the current value.\n\tfor old := stop.Load(); !stop.CompareAndSwap(old, !old); {\n\t\told = stop.Load()\n\t}\n\twg.Wait()\n}\n\nfunc TestNewStdLog(t *testing.T) {\n\twithLogger(t, DebugLevel, []Option{AddCaller()}, func(l *Logger, logs *observer.ObservedLogs) {\n\t\tstd := NewStdLog(l)\n\t\tstd.Print(\"redirected\")\n\t\tcheckStdLogMessage(t, \"redirected\", logs)\n\t})\n}\n\nfunc TestNewStdLogAt(t *testing.T) {\n\t// include DPanicLevel here, but do not include Development in options\n\tlevels := []zapcore.Level{DebugLevel, InfoLevel, WarnLevel, ErrorLevel, DPanicLevel}\n\tfor _, level := range levels {\n\t\twithLogger(t, DebugLevel, []Option{AddCaller()}, func(l *Logger, logs *observer.ObservedLogs) {\n\t\t\tstd, err := NewStdLogAt(l, level)\n\t\t\trequire.NoError(t, err, \"Unexpected error.\")\n\t\t\tstd.Print(\"redirected\")\n\t\t\tcheckStdLogMessage(t, \"redirected\", logs)\n\t\t})\n\t}\n}\n\nfunc TestNewStdLogAtPanics(t *testing.T) {\n\t// include DPanicLevel here and enable Development in options\n\tlevels := []zapcore.Level{DPanicLevel, PanicLevel}\n\tfor _, level := range levels {\n\t\twithLogger(t, DebugLevel, []Option{AddCaller(), Development()}, func(l *Logger, logs *observer.ObservedLogs) {\n\t\t\tstd, err := NewStdLogAt(l, level)\n\t\t\trequire.NoError(t, err, \"Unexpected error\")\n\t\t\tassert.Panics(t, func() { std.Print(\"redirected\") }, \"Expected log to panic.\")\n\t\t\tcheckStdLogMessage(t, \"redirected\", logs)\n\t\t})\n\t}\n}\n\nfunc TestNewStdLogAtFatal(t *testing.T) {\n\twithLogger(t, DebugLevel, []Option{AddCaller()}, func(l *Logger, logs *observer.ObservedLogs) {\n\t\tstub := exit.WithStub(func() {\n\t\t\tstd, err := NewStdLogAt(l, FatalLevel)\n\t\t\trequire.NoError(t, err, \"Unexpected error.\")\n\t\t\tstd.Print(\"redirected\")\n\t\t\tcheckStdLogMessage(t, \"redirected\", logs)\n\t\t})\n\t\tassert.True(t, true, stub.Exited, \"Expected Fatal logger call to terminate process.\")\n\t\tstub.Unstub()\n\t})\n}\n\nfunc TestNewStdLogAtInvalid(t *testing.T) {\n\t_, err := NewStdLogAt(NewNop(), zapcore.Level(99))\n\tassert.ErrorContains(t, err, \"99\", \"Expected level code in error message\")\n}\n\nfunc TestRedirectStdLog(t *testing.T) {\n\tinitialFlags := log.Flags()\n\tinitialPrefix := log.Prefix()\n\n\twithLogger(t, DebugLevel, nil, func(l *Logger, logs *observer.ObservedLogs) {\n\t\tdefer RedirectStdLog(l)()\n\t\tlog.Print(\"redirected\")\n\n\t\tassert.Equal(t, []observer.LoggedEntry{{\n\t\t\tEntry:   zapcore.Entry{Message: \"redirected\"},\n\t\t\tContext: []Field{},\n\t\t}}, logs.AllUntimed(), \"Unexpected global log output.\")\n\t})\n\n\tassert.Equal(t, initialFlags, log.Flags(), \"Expected to reset initial flags.\")\n\tassert.Equal(t, initialPrefix, log.Prefix(), \"Expected to reset initial prefix.\")\n}\n\nfunc TestRedirectStdLogCaller(t *testing.T) {\n\twithLogger(t, DebugLevel, []Option{AddCaller()}, func(l *Logger, logs *observer.ObservedLogs) {\n\t\tdefer RedirectStdLog(l)()\n\t\tlog.Print(\"redirected\")\n\t\tentries := logs.All()\n\t\trequire.Len(t, entries, 1, \"Unexpected number of logs.\")\n\t\tassert.Contains(t, entries[0].Caller.File, \"global_test.go\", \"Unexpected caller annotation.\")\n\t})\n}\n\nfunc TestRedirectStdLogAt(t *testing.T) {\n\tinitialFlags := log.Flags()\n\tinitialPrefix := log.Prefix()\n\n\t// include DPanicLevel here, but do not include Development in options\n\tlevels := []zapcore.Level{DebugLevel, InfoLevel, WarnLevel, ErrorLevel, DPanicLevel}\n\tfor _, level := range levels {\n\t\twithLogger(t, DebugLevel, nil, func(l *Logger, logs *observer.ObservedLogs) {\n\t\t\trestore, err := RedirectStdLogAt(l, level)\n\t\t\trequire.NoError(t, err, \"Unexpected error.\")\n\t\t\tdefer restore()\n\t\t\tlog.Print(\"redirected\")\n\n\t\t\tassert.Equal(t, []observer.LoggedEntry{{\n\t\t\t\tEntry:   zapcore.Entry{Level: level, Message: \"redirected\"},\n\t\t\t\tContext: []Field{},\n\t\t\t}}, logs.AllUntimed(), \"Unexpected global log output.\")\n\t\t})\n\t}\n\n\tassert.Equal(t, initialFlags, log.Flags(), \"Expected to reset initial flags.\")\n\tassert.Equal(t, initialPrefix, log.Prefix(), \"Expected to reset initial prefix.\")\n}\n\nfunc TestRedirectStdLogAtCaller(t *testing.T) {\n\t// include DPanicLevel here, but do not include Development in options\n\tlevels := []zapcore.Level{DebugLevel, InfoLevel, WarnLevel, ErrorLevel, DPanicLevel}\n\tfor _, level := range levels {\n\t\twithLogger(t, DebugLevel, []Option{AddCaller()}, func(l *Logger, logs *observer.ObservedLogs) {\n\t\t\trestore, err := RedirectStdLogAt(l, level)\n\t\t\trequire.NoError(t, err, \"Unexpected error.\")\n\t\t\tdefer restore()\n\t\t\tlog.Print(\"redirected\")\n\t\t\tentries := logs.All()\n\t\t\trequire.Len(t, entries, 1, \"Unexpected number of logs.\")\n\t\t\tassert.Contains(t, entries[0].Caller.File, \"global_test.go\", \"Unexpected caller annotation.\")\n\t\t})\n\t}\n}\n\nfunc TestRedirectStdLogAtPanics(t *testing.T) {\n\tinitialFlags := log.Flags()\n\tinitialPrefix := log.Prefix()\n\n\t// include DPanicLevel here and enable Development in options\n\tlevels := []zapcore.Level{DPanicLevel, PanicLevel}\n\tfor _, level := range levels {\n\t\twithLogger(t, DebugLevel, []Option{AddCaller(), Development()}, func(l *Logger, logs *observer.ObservedLogs) {\n\t\t\trestore, err := RedirectStdLogAt(l, level)\n\t\t\trequire.NoError(t, err, \"Unexpected error.\")\n\t\t\tdefer restore()\n\t\t\tassert.Panics(t, func() { log.Print(\"redirected\") }, \"Expected log to panic.\")\n\t\t\tcheckStdLogMessage(t, \"redirected\", logs)\n\t\t})\n\t}\n\n\tassert.Equal(t, initialFlags, log.Flags(), \"Expected to reset initial flags.\")\n\tassert.Equal(t, initialPrefix, log.Prefix(), \"Expected to reset initial prefix.\")\n}\n\nfunc TestRedirectStdLogAtFatal(t *testing.T) {\n\tinitialFlags := log.Flags()\n\tinitialPrefix := log.Prefix()\n\n\twithLogger(t, DebugLevel, []Option{AddCaller()}, func(l *Logger, logs *observer.ObservedLogs) {\n\t\tstub := exit.WithStub(func() {\n\t\t\trestore, err := RedirectStdLogAt(l, FatalLevel)\n\t\t\trequire.NoError(t, err, \"Unexpected error.\")\n\t\t\tdefer restore()\n\t\t\tlog.Print(\"redirected\")\n\t\t\tcheckStdLogMessage(t, \"redirected\", logs)\n\t\t})\n\t\tassert.True(t, true, stub.Exited, \"Expected Fatal logger call to terminate process.\")\n\t\tstub.Unstub()\n\t})\n\n\tassert.Equal(t, initialFlags, log.Flags(), \"Expected to reset initial flags.\")\n\tassert.Equal(t, initialPrefix, log.Prefix(), \"Expected to reset initial prefix.\")\n}\n\nfunc TestRedirectStdLogAtInvalid(t *testing.T) {\n\trestore, err := RedirectStdLogAt(NewNop(), zapcore.Level(99))\n\tdefer func() {\n\t\tif restore != nil {\n\t\t\trestore()\n\t\t}\n\t}()\n\tassert.ErrorContains(t, err, \"99\", \"Expected level code in error message\")\n}\n\nfunc checkStdLogMessage(t *testing.T, msg string, logs *observer.ObservedLogs) {\n\trequire.Equal(t, 1, logs.Len(), \"Expected exactly one entry to be logged\")\n\tentry := logs.AllUntimed()[0]\n\tassert.Equal(t, []Field{}, entry.Context, \"Unexpected entry context.\")\n\tassert.Equal(t, \"redirected\", entry.Message, \"Unexpected entry message.\")\n\tassert.Regexp(\n\t\tt,\n\t\t`/global_test.go:\\d+$`,\n\t\tentry.Caller.String(),\n\t\t\"Unexpected caller annotation.\",\n\t)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.3046875,
          "content": "module go.uber.org/zap\n\ngo 1.19\n\nrequire (\n\tgithub.com/stretchr/testify v1.8.1\n\tgo.uber.org/goleak v1.3.0\n\tgo.uber.org/multierr v1.10.0\n\tgopkg.in/yaml.v3 v3.0.1\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/kr/text v0.2.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.0986328125,
          "content": "github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngo.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=\ngo.uber.org/goleak v1.3.0/go.mod h1:CoHD4mav9JJNrW/WLlf7HGZPjdw8EucARQHekz1X6bE=\ngo.uber.org/multierr v1.10.0 h1:S0h4aNzvfcFsC3dRF1jLoaov7oRaKqRGC/pUEJ2yvPQ=\ngo.uber.org/multierr v1.10.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "http_handler.go",
          "type": "blob",
          "size": 4.234375,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// ServeHTTP is a simple JSON endpoint that can report on or change the current\n// logging level.\n//\n// # GET\n//\n// The GET request returns a JSON description of the current logging level like:\n//\n//\t{\"level\":\"info\"}\n//\n// # PUT\n//\n// The PUT request changes the logging level. It is perfectly safe to change the\n// logging level while a program is running. Two content types are supported:\n//\n//\tContent-Type: application/x-www-form-urlencoded\n//\n// With this content type, the level can be provided through the request body or\n// a query parameter. The log level is URL encoded like:\n//\n//\tlevel=debug\n//\n// The request body takes precedence over the query parameter, if both are\n// specified.\n//\n// This content type is the default for a curl PUT request. Following are two\n// example curl requests that both set the logging level to debug.\n//\n//\tcurl -X PUT localhost:8080/log/level?level=debug\n//\tcurl -X PUT localhost:8080/log/level -d level=debug\n//\n// For any other content type, the payload is expected to be JSON encoded and\n// look like:\n//\n//\t{\"level\":\"info\"}\n//\n// An example curl request could look like this:\n//\n//\tcurl -X PUT localhost:8080/log/level -H \"Content-Type: application/json\" -d '{\"level\":\"debug\"}'\nfunc (lvl AtomicLevel) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif err := lvl.serveHTTP(w, r); err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t_, _ = fmt.Fprintf(w, \"internal error: %v\", err)\n\t}\n}\n\nfunc (lvl AtomicLevel) serveHTTP(w http.ResponseWriter, r *http.Request) error {\n\ttype errorResponse struct {\n\t\tError string `json:\"error\"`\n\t}\n\ttype payload struct {\n\t\tLevel zapcore.Level `json:\"level\"`\n\t}\n\n\tenc := json.NewEncoder(w)\n\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\treturn enc.Encode(payload{Level: lvl.Level()})\n\n\tcase http.MethodPut:\n\t\trequestedLvl, err := decodePutRequest(r.Header.Get(\"Content-Type\"), r)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\treturn enc.Encode(errorResponse{Error: err.Error()})\n\t\t}\n\t\tlvl.SetLevel(requestedLvl)\n\t\treturn enc.Encode(payload{Level: lvl.Level()})\n\n\tdefault:\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn enc.Encode(errorResponse{\n\t\t\tError: \"Only GET and PUT are supported.\",\n\t\t})\n\t}\n}\n\n// Decodes incoming PUT requests and returns the requested logging level.\nfunc decodePutRequest(contentType string, r *http.Request) (zapcore.Level, error) {\n\tif contentType == \"application/x-www-form-urlencoded\" {\n\t\treturn decodePutURL(r)\n\t}\n\treturn decodePutJSON(r.Body)\n}\n\nfunc decodePutURL(r *http.Request) (zapcore.Level, error) {\n\tlvl := r.FormValue(\"level\")\n\tif lvl == \"\" {\n\t\treturn 0, errors.New(\"must specify logging level\")\n\t}\n\tvar l zapcore.Level\n\tif err := l.UnmarshalText([]byte(lvl)); err != nil {\n\t\treturn 0, err\n\t}\n\treturn l, nil\n}\n\nfunc decodePutJSON(body io.Reader) (zapcore.Level, error) {\n\tvar pld struct {\n\t\tLevel *zapcore.Level `json:\"level\"`\n\t}\n\tif err := json.NewDecoder(body).Decode(&pld); err != nil {\n\t\treturn 0, fmt.Errorf(\"malformed request body: %v\", err)\n\t}\n\tif pld.Level == nil {\n\t\treturn 0, errors.New(\"must specify logging level\")\n\t}\n\treturn *pld.Level, nil\n}\n"
        },
        {
          "name": "http_handler_test.go",
          "type": "blob",
          "size": 7.8837890625,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap_test\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/zapcore\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestAtomicLevelServeHTTP(t *testing.T) {\n\ttests := []struct {\n\t\tdesc          string\n\t\tmethod        string\n\t\tquery         string\n\t\tcontentType   string\n\t\tbody          string\n\t\texpectedCode  int\n\t\texpectedLevel zapcore.Level\n\t}{\n\t\t{\n\t\t\tdesc:          \"GET\",\n\t\t\tmethod:        http.MethodGet,\n\t\t\texpectedCode:  http.StatusOK,\n\t\t\texpectedLevel: zap.InfoLevel,\n\t\t},\n\t\t{\n\t\t\tdesc:          \"PUT JSON\",\n\t\t\tmethod:        http.MethodPut,\n\t\t\texpectedCode:  http.StatusOK,\n\t\t\texpectedLevel: zap.WarnLevel,\n\t\t\tbody:          `{\"level\":\"warn\"}`,\n\t\t},\n\t\t{\n\t\t\tdesc:          \"PUT URL encoded\",\n\t\t\tmethod:        http.MethodPut,\n\t\t\texpectedCode:  http.StatusOK,\n\t\t\texpectedLevel: zap.WarnLevel,\n\t\t\tcontentType:   \"application/x-www-form-urlencoded\",\n\t\t\tbody:          \"level=warn\",\n\t\t},\n\t\t{\n\t\t\tdesc:          \"PUT query parameters\",\n\t\t\tmethod:        http.MethodPut,\n\t\t\tquery:         \"?level=warn\",\n\t\t\texpectedCode:  http.StatusOK,\n\t\t\texpectedLevel: zap.WarnLevel,\n\t\t\tcontentType:   \"application/x-www-form-urlencoded\",\n\t\t},\n\t\t{\n\t\t\tdesc:          \"body takes precedence over query\",\n\t\t\tmethod:        http.MethodPut,\n\t\t\tquery:         \"?level=info\",\n\t\t\texpectedCode:  http.StatusOK,\n\t\t\texpectedLevel: zap.WarnLevel,\n\t\t\tcontentType:   \"application/x-www-form-urlencoded\",\n\t\t\tbody:          \"level=warn\",\n\t\t},\n\t\t{\n\t\t\tdesc:          \"JSON ignores query\",\n\t\t\tmethod:        http.MethodPut,\n\t\t\tquery:         \"?level=info\",\n\t\t\texpectedCode:  http.StatusOK,\n\t\t\texpectedLevel: zap.WarnLevel,\n\t\t\tbody:          `{\"level\":\"warn\"}`,\n\t\t},\n\t\t{\n\t\t\tdesc:         \"PUT JSON unrecognized\",\n\t\t\tmethod:       http.MethodPut,\n\t\t\texpectedCode: http.StatusBadRequest,\n\t\t\tbody:         `{\"level\":\"unrecognized\"}`,\n\t\t},\n\t\t{\n\t\t\tdesc:         \"PUT URL encoded unrecognized\",\n\t\t\tmethod:       http.MethodPut,\n\t\t\texpectedCode: http.StatusBadRequest,\n\t\t\tcontentType:  \"application/x-www-form-urlencoded\",\n\t\t\tbody:         \"level=unrecognized\",\n\t\t},\n\t\t{\n\t\t\tdesc:         \"PUT JSON malformed\",\n\t\t\tmethod:       http.MethodPut,\n\t\t\texpectedCode: http.StatusBadRequest,\n\t\t\tbody:         `{\"level\":\"warn`,\n\t\t},\n\t\t{\n\t\t\tdesc:         \"PUT URL encoded malformed\",\n\t\t\tmethod:       http.MethodPut,\n\t\t\tquery:        \"?level=%\",\n\t\t\texpectedCode: http.StatusBadRequest,\n\t\t\tcontentType:  \"application/x-www-form-urlencoded\",\n\t\t},\n\t\t{\n\t\t\tdesc:         \"PUT Query parameters malformed\",\n\t\t\tmethod:       http.MethodPut,\n\t\t\texpectedCode: http.StatusBadRequest,\n\t\t\tcontentType:  \"application/x-www-form-urlencoded\",\n\t\t\tbody:         \"level=%\",\n\t\t},\n\t\t{\n\t\t\tdesc:         \"PUT JSON unspecified\",\n\t\t\tmethod:       http.MethodPut,\n\t\t\texpectedCode: http.StatusBadRequest,\n\t\t\tbody:         `{}`,\n\t\t},\n\t\t{\n\t\t\tdesc:         \"PUT URL encoded unspecified\",\n\t\t\tmethod:       http.MethodPut,\n\t\t\texpectedCode: http.StatusBadRequest,\n\t\t\tcontentType:  \"application/x-www-form-urlencoded\",\n\t\t\tbody:         \"\",\n\t\t},\n\t\t{\n\t\t\tdesc:         \"POST JSON\",\n\t\t\tmethod:       http.MethodPost,\n\t\t\texpectedCode: http.StatusMethodNotAllowed,\n\t\t\tbody:         `{\"level\":\"warn\"}`,\n\t\t},\n\t\t{\n\t\t\tdesc:         \"POST URL\",\n\t\t\tmethod:       http.MethodPost,\n\t\t\texpectedCode: http.StatusMethodNotAllowed,\n\t\t\tcontentType:  \"application/x-www-form-urlencoded\",\n\t\t\tbody:         \"level=warn\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tlvl := zap.NewAtomicLevel()\n\t\t\tlvl.SetLevel(zapcore.InfoLevel)\n\n\t\t\tserver := httptest.NewServer(lvl)\n\t\t\tdefer server.Close()\n\n\t\t\treq, err := http.NewRequest(tt.method, server.URL+tt.query, strings.NewReader(tt.body))\n\t\t\trequire.NoError(t, err, \"Error constructing %s request.\", req.Method)\n\t\t\tif tt.contentType != \"\" {\n\t\t\t\treq.Header.Set(\"Content-Type\", tt.contentType)\n\t\t\t}\n\n\t\t\tres, err := http.DefaultClient.Do(req)\n\t\t\trequire.NoError(t, err, \"Error making %s request.\", req.Method)\n\t\t\tdefer func() {\n\t\t\t\tassert.NoError(t, res.Body.Close(), \"Error closing response body.\")\n\t\t\t}()\n\n\t\t\trequire.Equal(t, tt.expectedCode, res.StatusCode, \"Unexpected status code.\")\n\t\t\tif tt.expectedCode != http.StatusOK {\n\t\t\t\t// Don't need to test exact error message, but one should be present.\n\t\t\t\tvar pld struct {\n\t\t\t\t\tError string `json:\"error\"`\n\t\t\t\t}\n\t\t\t\trequire.NoError(t, json.NewDecoder(res.Body).Decode(&pld), \"Decoding response body\")\n\t\t\t\tassert.NotEmpty(t, pld.Error, \"Expected an error message\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar pld struct {\n\t\t\t\tLevel zapcore.Level `json:\"level\"`\n\t\t\t}\n\t\t\trequire.NoError(t, json.NewDecoder(res.Body).Decode(&pld), \"Decoding response body\")\n\t\t\tassert.Equal(t, tt.expectedLevel, pld.Level, \"Unexpected logging level returned\")\n\t\t})\n\t}\n}\n\nfunc TestAtomicLevelServeHTTPBrokenWriter(t *testing.T) {\n\tt.Parallel()\n\n\tlvl := zap.NewAtomicLevel()\n\n\trequest, err := http.NewRequest(http.MethodGet, \"http://localhost:1234/log/level\", nil)\n\trequire.NoError(t, err, \"Error constructing request.\")\n\n\trecorder := httptest.NewRecorder()\n\tlvl.ServeHTTP(&brokenHTTPResponseWriter{\n\t\tResponseWriter: recorder,\n\t}, request)\n\n\tassert.Equal(t, http.StatusInternalServerError, recorder.Code, \"Unexpected status code.\")\n}\n\ntype brokenHTTPResponseWriter struct {\n\thttp.ResponseWriter\n}\n\nfunc (w *brokenHTTPResponseWriter) Write([]byte) (int, error) {\n\treturn 0, errors.New(\"great sadness\")\n}\n\nfunc TestAtomicLevelServeHTTPBadLevel(t *testing.T) {\n\tsrv := httptest.NewServer(zap.NewAtomicLevel())\n\tdefer srv.Close()\n\n\treq, err := http.NewRequest(http.MethodPut, srv.URL, strings.NewReader(`{\"level\":\"<script>alert(\\\"malicious\\\")</script>\"}`))\n\trequire.NoError(t, err, \"Error constructing request.\")\n\n\tres, err := http.DefaultClient.Do(req)\n\trequire.NoError(t, err, \"Error making request.\")\n\tdefer func() {\n\t\tassert.NoError(t, res.Body.Close(), \"Error closing response body.\")\n\t}()\n\n\tassert.Equal(t, http.StatusBadRequest, res.StatusCode, \"Unexpected status code.\")\n\tresBody, err := io.ReadAll(res.Body)\n\trequire.NoError(t, err, \"Error reading response body.\")\n\n\tassert.Contains(t, string(resBody), \"unrecognized level\", \"Unexpected error message.\")\n\tassert.NotContains(t, string(resBody), \"<script>\", \"Unexpected error message.\")\n}\n\nfunc FuzzAtomicLevelServeHTTP(f *testing.F) {\n\tf.Add(`{\"level\":\"info\"}`)\n\tf.Add(`{\"level\":\"warn\"}`)\n\tf.Add(`{\"level\":\"<script>alert(\\\"malicious\\\")</script>\"}`)\n\tf.Fuzz(func(t *testing.T, input string) {\n\t\tlvl := zap.NewAtomicLevel()\n\n\t\tresw := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(http.MethodPut, \"http://localhost:9999/log/level\", strings.NewReader(input))\n\t\trequire.NoError(t, err, \"Error constructing request.\")\n\n\t\tlvl.ServeHTTP(resw, req)\n\n\t\trequire.NotEqual(t, http.StatusInternalServerError, resw.Code, \"Unexpected status code.\")\n\n\t\t// Response body must never contain HTML tags.\n\t\tassert.NotRegexp(t, `<[^>]+>`, resw.Body.String(), \"Unexpected HTML tag in response body.\")\n\t})\n}\n"
        },
        {
          "name": "increase_level_test.go",
          "type": "blob",
          "size": 3.3896484375,
          "content": "// Copyright (c) 2020 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.uber.org/zap/zapcore\"\n\t\"go.uber.org/zap/zaptest/observer\"\n)\n\nfunc newLoggedEntry(level zapcore.Level, msg string, fields ...zapcore.Field) observer.LoggedEntry {\n\tif len(fields) == 0 {\n\t\tfields = []zapcore.Field{}\n\t}\n\treturn observer.LoggedEntry{\n\t\tEntry:   zapcore.Entry{Level: level, Message: msg},\n\t\tContext: fields,\n\t}\n}\n\nfunc TestIncreaseLevelTryDecrease(t *testing.T) {\n\terrorOut := &bytes.Buffer{}\n\topts := []Option{\n\t\tErrorOutput(zapcore.AddSync(errorOut)),\n\t}\n\twithLogger(t, WarnLevel, opts, func(logger *Logger, logs *observer.ObservedLogs) {\n\t\tlogger.Warn(\"original warn log\")\n\n\t\tdebugLogger := logger.WithOptions(IncreaseLevel(DebugLevel))\n\t\tdebugLogger.Debug(\"ignored debug log\")\n\t\tdebugLogger.Warn(\"increase level warn log\")\n\t\tdebugLogger.Error(\"increase level error log\")\n\n\t\tassert.Equal(t, []observer.LoggedEntry{\n\t\t\tnewLoggedEntry(WarnLevel, \"original warn log\"),\n\t\t\tnewLoggedEntry(WarnLevel, \"increase level warn log\"),\n\t\t\tnewLoggedEntry(ErrorLevel, \"increase level error log\"),\n\t\t}, logs.AllUntimed(), \"unexpected logs\")\n\t\tassert.Equal(t,\n\t\t\t\"failed to IncreaseLevel: invalid increase level, as level \\\"info\\\" is allowed by increased level, but not by existing core\\n\",\n\t\t\terrorOut.String(),\n\t\t\t\"unexpected error output\",\n\t\t)\n\t})\n}\n\nfunc TestIncreaseLevel(t *testing.T) {\n\terrorOut := &bytes.Buffer{}\n\topts := []Option{\n\t\tErrorOutput(zapcore.AddSync(errorOut)),\n\t}\n\twithLogger(t, WarnLevel, opts, func(logger *Logger, logs *observer.ObservedLogs) {\n\t\tlogger.Warn(\"original warn log\")\n\n\t\terrorLogger := logger.WithOptions(IncreaseLevel(ErrorLevel))\n\t\terrorLogger.Debug(\"ignored debug log\")\n\t\terrorLogger.Warn(\"ignored warn log\")\n\t\terrorLogger.Error(\"increase level error log\")\n\n\t\twithFields := errorLogger.With(String(\"k\", \"v\"))\n\t\twithFields.Debug(\"ignored debug log with fields\")\n\t\twithFields.Warn(\"ignored warn log with fields\")\n\t\twithFields.Error(\"increase level error log with fields\")\n\n\t\tassert.Equal(t, []observer.LoggedEntry{\n\t\t\tnewLoggedEntry(WarnLevel, \"original warn log\"),\n\t\t\tnewLoggedEntry(ErrorLevel, \"increase level error log\"),\n\t\t\tnewLoggedEntry(ErrorLevel, \"increase level error log with fields\", String(\"k\", \"v\")),\n\t\t}, logs.AllUntimed(), \"unexpected logs\")\n\n\t\tassert.Empty(t, errorOut.String(), \"expect no error output\")\n\t})\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "leak_test.go",
          "type": "blob",
          "size": 1.2099609375,
          "content": "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"testing\"\n\n\t\"go.uber.org/goleak\"\n)\n\nfunc TestMain(m *testing.M) {\n\tgoleak.VerifyTestMain(m)\n}\n"
        },
        {
          "name": "level.go",
          "type": "blob",
          "size": 5.146484375,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"sync/atomic\"\n\n\t\"go.uber.org/zap/internal\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\nconst (\n\t// DebugLevel logs are typically voluminous, and are usually disabled in\n\t// production.\n\tDebugLevel = zapcore.DebugLevel\n\t// InfoLevel is the default logging priority.\n\tInfoLevel = zapcore.InfoLevel\n\t// WarnLevel logs are more important than Info, but don't need individual\n\t// human review.\n\tWarnLevel = zapcore.WarnLevel\n\t// ErrorLevel logs are high-priority. If an application is running smoothly,\n\t// it shouldn't generate any error-level logs.\n\tErrorLevel = zapcore.ErrorLevel\n\t// DPanicLevel logs are particularly important errors. In development the\n\t// logger panics after writing the message.\n\tDPanicLevel = zapcore.DPanicLevel\n\t// PanicLevel logs a message, then panics.\n\tPanicLevel = zapcore.PanicLevel\n\t// FatalLevel logs a message, then calls os.Exit(1).\n\tFatalLevel = zapcore.FatalLevel\n)\n\n// LevelEnablerFunc is a convenient way to implement zapcore.LevelEnabler with\n// an anonymous function.\n//\n// It's particularly useful when splitting log output between different\n// outputs (e.g., standard error and standard out). For sample code, see the\n// package-level AdvancedConfiguration example.\ntype LevelEnablerFunc func(zapcore.Level) bool\n\n// Enabled calls the wrapped function.\nfunc (f LevelEnablerFunc) Enabled(lvl zapcore.Level) bool { return f(lvl) }\n\n// An AtomicLevel is an atomically changeable, dynamic logging level. It lets\n// you safely change the log level of a tree of loggers (the root logger and\n// any children created by adding context) at runtime.\n//\n// The AtomicLevel itself is an http.Handler that serves a JSON endpoint to\n// alter its level.\n//\n// AtomicLevels must be created with the NewAtomicLevel constructor to allocate\n// their internal atomic pointer.\ntype AtomicLevel struct {\n\tl *atomic.Int32\n}\n\nvar _ internal.LeveledEnabler = AtomicLevel{}\n\n// NewAtomicLevel creates an AtomicLevel with InfoLevel and above logging\n// enabled.\nfunc NewAtomicLevel() AtomicLevel {\n\tlvl := AtomicLevel{l: new(atomic.Int32)}\n\tlvl.l.Store(int32(InfoLevel))\n\treturn lvl\n}\n\n// NewAtomicLevelAt is a convenience function that creates an AtomicLevel\n// and then calls SetLevel with the given level.\nfunc NewAtomicLevelAt(l zapcore.Level) AtomicLevel {\n\ta := NewAtomicLevel()\n\ta.SetLevel(l)\n\treturn a\n}\n\n// ParseAtomicLevel parses an AtomicLevel based on a lowercase or all-caps ASCII\n// representation of the log level. If the provided ASCII representation is\n// invalid an error is returned.\n//\n// This is particularly useful when dealing with text input to configure log\n// levels.\nfunc ParseAtomicLevel(text string) (AtomicLevel, error) {\n\ta := NewAtomicLevel()\n\tl, err := zapcore.ParseLevel(text)\n\tif err != nil {\n\t\treturn a, err\n\t}\n\n\ta.SetLevel(l)\n\treturn a, nil\n}\n\n// Enabled implements the zapcore.LevelEnabler interface, which allows the\n// AtomicLevel to be used in place of traditional static levels.\nfunc (lvl AtomicLevel) Enabled(l zapcore.Level) bool {\n\treturn lvl.Level().Enabled(l)\n}\n\n// Level returns the minimum enabled log level.\nfunc (lvl AtomicLevel) Level() zapcore.Level {\n\treturn zapcore.Level(int8(lvl.l.Load()))\n}\n\n// SetLevel alters the logging level.\nfunc (lvl AtomicLevel) SetLevel(l zapcore.Level) {\n\tlvl.l.Store(int32(l))\n}\n\n// String returns the string representation of the underlying Level.\nfunc (lvl AtomicLevel) String() string {\n\treturn lvl.Level().String()\n}\n\n// UnmarshalText unmarshals the text to an AtomicLevel. It uses the same text\n// representations as the static zapcore.Levels (\"debug\", \"info\", \"warn\",\n// \"error\", \"dpanic\", \"panic\", and \"fatal\").\nfunc (lvl *AtomicLevel) UnmarshalText(text []byte) error {\n\tif lvl.l == nil {\n\t\tlvl.l = &atomic.Int32{}\n\t}\n\n\tvar l zapcore.Level\n\tif err := l.UnmarshalText(text); err != nil {\n\t\treturn err\n\t}\n\n\tlvl.SetLevel(l)\n\treturn nil\n}\n\n// MarshalText marshals the AtomicLevel to a byte slice. It uses the same\n// text representation as the static zapcore.Levels (\"debug\", \"info\", \"warn\",\n// \"error\", \"dpanic\", \"panic\", and \"fatal\").\nfunc (lvl AtomicLevel) MarshalText() (text []byte, err error) {\n\treturn lvl.Level().MarshalText()\n}\n"
        },
        {
          "name": "level_test.go",
          "type": "blob",
          "size": 4.224609375,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"sync\"\n\t\"testing\"\n\n\t\"go.uber.org/zap/zapcore\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestLevelEnablerFunc(t *testing.T) {\n\tenab := LevelEnablerFunc(func(l zapcore.Level) bool { return l == zapcore.InfoLevel })\n\ttests := []struct {\n\t\tlevel   zapcore.Level\n\t\tenabled bool\n\t}{\n\t\t{DebugLevel, false},\n\t\t{InfoLevel, true},\n\t\t{WarnLevel, false},\n\t\t{ErrorLevel, false},\n\t\t{DPanicLevel, false},\n\t\t{PanicLevel, false},\n\t\t{FatalLevel, false},\n\t}\n\tfor _, tt := range tests {\n\t\tassert.Equal(t, tt.enabled, enab.Enabled(tt.level), \"Unexpected result applying LevelEnablerFunc to %s\", tt.level)\n\t}\n}\n\nfunc TestNewAtomicLevel(t *testing.T) {\n\tlvl := NewAtomicLevel()\n\tassert.Equal(t, InfoLevel, lvl.Level(), \"Unexpected initial level.\")\n\tlvl.SetLevel(ErrorLevel)\n\tassert.Equal(t, ErrorLevel, lvl.Level(), \"Unexpected level after SetLevel.\")\n\tlvl = NewAtomicLevelAt(WarnLevel)\n\tassert.Equal(t, WarnLevel, lvl.Level(), \"Unexpected level after SetLevel.\")\n}\n\nfunc TestParseAtomicLevel(t *testing.T) {\n\ttests := []struct {\n\t\ttext  string\n\t\tlevel AtomicLevel\n\t\terr   string\n\t}{\n\t\t{\"info\", NewAtomicLevel(), \"\"},\n\t\t{\"DEBUG\", NewAtomicLevelAt(DebugLevel), \"\"},\n\t\t{\"FOO\", NewAtomicLevel(), `unrecognized level: \"FOO\"`},\n\t}\n\n\tfor _, tt := range tests {\n\t\tparsedAtomicLevel, err := ParseAtomicLevel(tt.text)\n\t\tif len(tt.err) == 0 {\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, tt.level, parsedAtomicLevel)\n\t\t} else {\n\t\t\tassert.ErrorContains(t, err, tt.err)\n\t\t}\n\t}\n}\n\nfunc TestAtomicLevelMutation(t *testing.T) {\n\tlvl := NewAtomicLevel()\n\tlvl.SetLevel(WarnLevel)\n\t// Trigger races for non-atomic level mutations.\n\tproceed := make(chan struct{})\n\twg := &sync.WaitGroup{}\n\trunConcurrently(10, 100, wg, func() {\n\t\t<-proceed\n\t\tassert.Equal(t, WarnLevel, lvl.Level())\n\t})\n\trunConcurrently(10, 100, wg, func() {\n\t\t<-proceed\n\t\tlvl.SetLevel(WarnLevel)\n\t})\n\tclose(proceed)\n\twg.Wait()\n}\n\nfunc TestAtomicLevelText(t *testing.T) {\n\ttests := []struct {\n\t\ttext   string\n\t\texpect zapcore.Level\n\t\terr    bool\n\t}{\n\t\t{\"debug\", DebugLevel, false},\n\t\t{\"info\", InfoLevel, false},\n\t\t{\"\", InfoLevel, false},\n\t\t{\"warn\", WarnLevel, false},\n\t\t{\"error\", ErrorLevel, false},\n\t\t{\"dpanic\", DPanicLevel, false},\n\t\t{\"panic\", PanicLevel, false},\n\t\t{\"fatal\", FatalLevel, false},\n\t\t{\"foobar\", InfoLevel, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tvar lvl AtomicLevel\n\t\t// Test both initial unmarshaling and overwriting existing value.\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tif tt.err {\n\t\t\t\tassert.Error(t, lvl.UnmarshalText([]byte(tt.text)), \"Expected unmarshaling %q to fail.\", tt.text)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, lvl.UnmarshalText([]byte(tt.text)), \"Expected unmarshaling %q to succeed.\", tt.text)\n\t\t\t}\n\t\t\tassert.Equal(t, tt.expect, lvl.Level(), \"Unexpected level after unmarshaling.\")\n\t\t\tlvl.SetLevel(InfoLevel)\n\t\t}\n\n\t\t// Test marshalling\n\t\tif tt.text != \"\" && !tt.err {\n\t\t\tlvl.SetLevel(tt.expect)\n\t\t\tmarshaled, err := lvl.MarshalText()\n\t\t\tassert.NoError(t, err, `Unexpected error marshalling level \"%v\" to text.`, tt.expect)\n\t\t\tassert.Equal(t, tt.text, string(marshaled), \"Expected marshaled text to match\")\n\t\t\tassert.Equal(t, tt.text, lvl.String(), \"Expected Stringer call to match\")\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 13.8349609375,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\n\t\"go.uber.org/zap/internal/bufferpool\"\n\t\"go.uber.org/zap/internal/stacktrace\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// A Logger provides fast, leveled, structured logging. All methods are safe\n// for concurrent use.\n//\n// The Logger is designed for contexts in which every microsecond and every\n// allocation matters, so its API intentionally favors performance and type\n// safety over brevity. For most applications, the SugaredLogger strikes a\n// better balance between performance and ergonomics.\ntype Logger struct {\n\tcore zapcore.Core\n\n\tdevelopment bool\n\taddCaller   bool\n\tonPanic     zapcore.CheckWriteHook // default is WriteThenPanic\n\tonFatal     zapcore.CheckWriteHook // default is WriteThenFatal\n\n\tname        string\n\terrorOutput zapcore.WriteSyncer\n\n\taddStack zapcore.LevelEnabler\n\n\tcallerSkip int\n\n\tclock zapcore.Clock\n}\n\n// New constructs a new Logger from the provided zapcore.Core and Options. If\n// the passed zapcore.Core is nil, it falls back to using a no-op\n// implementation.\n//\n// This is the most flexible way to construct a Logger, but also the most\n// verbose. For typical use cases, the highly-opinionated presets\n// (NewProduction, NewDevelopment, and NewExample) or the Config struct are\n// more convenient.\n//\n// For sample code, see the package-level AdvancedConfiguration example.\nfunc New(core zapcore.Core, options ...Option) *Logger {\n\tif core == nil {\n\t\treturn NewNop()\n\t}\n\tlog := &Logger{\n\t\tcore:        core,\n\t\terrorOutput: zapcore.Lock(os.Stderr),\n\t\taddStack:    zapcore.FatalLevel + 1,\n\t\tclock:       zapcore.DefaultClock,\n\t}\n\treturn log.WithOptions(options...)\n}\n\n// NewNop returns a no-op Logger. It never writes out logs or internal errors,\n// and it never runs user-defined hooks.\n//\n// Using WithOptions to replace the Core or error output of a no-op Logger can\n// re-enable logging.\nfunc NewNop() *Logger {\n\treturn &Logger{\n\t\tcore:        zapcore.NewNopCore(),\n\t\terrorOutput: zapcore.AddSync(io.Discard),\n\t\taddStack:    zapcore.FatalLevel + 1,\n\t\tclock:       zapcore.DefaultClock,\n\t}\n}\n\n// NewProduction builds a sensible production Logger that writes InfoLevel and\n// above logs to standard error as JSON.\n//\n// It's a shortcut for NewProductionConfig().Build(...Option).\nfunc NewProduction(options ...Option) (*Logger, error) {\n\treturn NewProductionConfig().Build(options...)\n}\n\n// NewDevelopment builds a development Logger that writes DebugLevel and above\n// logs to standard error in a human-friendly format.\n//\n// It's a shortcut for NewDevelopmentConfig().Build(...Option).\nfunc NewDevelopment(options ...Option) (*Logger, error) {\n\treturn NewDevelopmentConfig().Build(options...)\n}\n\n// Must is a helper that wraps a call to a function returning (*Logger, error)\n// and panics if the error is non-nil. It is intended for use in variable\n// initialization such as:\n//\n//\tvar logger = zap.Must(zap.NewProduction())\nfunc Must(logger *Logger, err error) *Logger {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn logger\n}\n\n// NewExample builds a Logger that's designed for use in zap's testable\n// examples. It writes DebugLevel and above logs to standard out as JSON, but\n// omits the timestamp and calling function to keep example output\n// short and deterministic.\nfunc NewExample(options ...Option) *Logger {\n\tencoderCfg := zapcore.EncoderConfig{\n\t\tMessageKey:     \"msg\",\n\t\tLevelKey:       \"level\",\n\t\tNameKey:        \"logger\",\n\t\tEncodeLevel:    zapcore.LowercaseLevelEncoder,\n\t\tEncodeTime:     zapcore.ISO8601TimeEncoder,\n\t\tEncodeDuration: zapcore.StringDurationEncoder,\n\t}\n\tcore := zapcore.NewCore(zapcore.NewJSONEncoder(encoderCfg), os.Stdout, DebugLevel)\n\treturn New(core).WithOptions(options...)\n}\n\n// Sugar wraps the Logger to provide a more ergonomic, but slightly slower,\n// API. Sugaring a Logger is quite inexpensive, so it's reasonable for a\n// single application to use both Loggers and SugaredLoggers, converting\n// between them on the boundaries of performance-sensitive code.\nfunc (log *Logger) Sugar() *SugaredLogger {\n\tcore := log.clone()\n\tcore.callerSkip += 2\n\treturn &SugaredLogger{core}\n}\n\n// Named adds a new path segment to the logger's name. Segments are joined by\n// periods. By default, Loggers are unnamed.\nfunc (log *Logger) Named(s string) *Logger {\n\tif s == \"\" {\n\t\treturn log\n\t}\n\tl := log.clone()\n\tif log.name == \"\" {\n\t\tl.name = s\n\t} else {\n\t\tl.name = strings.Join([]string{l.name, s}, \".\")\n\t}\n\treturn l\n}\n\n// WithOptions clones the current Logger, applies the supplied Options, and\n// returns the resulting Logger. It's safe to use concurrently.\nfunc (log *Logger) WithOptions(opts ...Option) *Logger {\n\tc := log.clone()\n\tfor _, opt := range opts {\n\t\topt.apply(c)\n\t}\n\treturn c\n}\n\n// With creates a child logger and adds structured context to it. Fields added\n// to the child don't affect the parent, and vice versa. Any fields that\n// require evaluation (such as Objects) are evaluated upon invocation of With.\nfunc (log *Logger) With(fields ...Field) *Logger {\n\tif len(fields) == 0 {\n\t\treturn log\n\t}\n\tl := log.clone()\n\tl.core = l.core.With(fields)\n\treturn l\n}\n\n// WithLazy creates a child logger and adds structured context to it lazily.\n//\n// The fields are evaluated only if the logger is further chained with [With]\n// or is written to with any of the log level methods.\n// Until that occurs, the logger may retain references to objects inside the fields,\n// and logging will reflect the state of an object at the time of logging,\n// not the time of WithLazy().\n//\n// WithLazy provides a worthwhile performance optimization for contextual loggers\n// when the likelihood of using the child logger is low,\n// such as error paths and rarely taken branches.\n//\n// Similar to [With], fields added to the child don't affect the parent, and vice versa.\nfunc (log *Logger) WithLazy(fields ...Field) *Logger {\n\tif len(fields) == 0 {\n\t\treturn log\n\t}\n\treturn log.WithOptions(WrapCore(func(core zapcore.Core) zapcore.Core {\n\t\treturn zapcore.NewLazyWith(core, fields)\n\t}))\n}\n\n// Level reports the minimum enabled level for this logger.\n//\n// For NopLoggers, this is [zapcore.InvalidLevel].\nfunc (log *Logger) Level() zapcore.Level {\n\treturn zapcore.LevelOf(log.core)\n}\n\n// Check returns a CheckedEntry if logging a message at the specified level\n// is enabled. It's a completely optional optimization; in high-performance\n// applications, Check can help avoid allocating a slice to hold fields.\nfunc (log *Logger) Check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry {\n\treturn log.check(lvl, msg)\n}\n\n// Log logs a message at the specified level. The message includes any fields\n// passed at the log site, as well as any fields accumulated on the logger.\n// Any Fields that require  evaluation (such as Objects) are evaluated upon\n// invocation of Log.\nfunc (log *Logger) Log(lvl zapcore.Level, msg string, fields ...Field) {\n\tif ce := log.check(lvl, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Debug logs a message at DebugLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Debug(msg string, fields ...Field) {\n\tif ce := log.check(DebugLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Info logs a message at InfoLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Info(msg string, fields ...Field) {\n\tif ce := log.check(InfoLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Warn logs a message at WarnLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Warn(msg string, fields ...Field) {\n\tif ce := log.check(WarnLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Error logs a message at ErrorLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\nfunc (log *Logger) Error(msg string, fields ...Field) {\n\tif ce := log.check(ErrorLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// DPanic logs a message at DPanicLevel. The message includes any fields\n// passed at the log site, as well as any fields accumulated on the logger.\n//\n// If the logger is in development mode, it then panics (DPanic means\n// \"development panic\"). This is useful for catching errors that are\n// recoverable, but shouldn't ever happen.\nfunc (log *Logger) DPanic(msg string, fields ...Field) {\n\tif ce := log.check(DPanicLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Panic logs a message at PanicLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\n//\n// The logger then panics, even if logging at PanicLevel is disabled.\nfunc (log *Logger) Panic(msg string, fields ...Field) {\n\tif ce := log.check(PanicLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Fatal logs a message at FatalLevel. The message includes any fields passed\n// at the log site, as well as any fields accumulated on the logger.\n//\n// The logger then calls os.Exit(1), even if logging at FatalLevel is\n// disabled.\nfunc (log *Logger) Fatal(msg string, fields ...Field) {\n\tif ce := log.check(FatalLevel, msg); ce != nil {\n\t\tce.Write(fields...)\n\t}\n}\n\n// Sync calls the underlying Core's Sync method, flushing any buffered log\n// entries. Applications should take care to call Sync before exiting.\nfunc (log *Logger) Sync() error {\n\treturn log.core.Sync()\n}\n\n// Core returns the Logger's underlying zapcore.Core.\nfunc (log *Logger) Core() zapcore.Core {\n\treturn log.core\n}\n\n// Name returns the Logger's underlying name,\n// or an empty string if the logger is unnamed.\nfunc (log *Logger) Name() string {\n\treturn log.name\n}\n\nfunc (log *Logger) clone() *Logger {\n\tclone := *log\n\treturn &clone\n}\n\nfunc (log *Logger) check(lvl zapcore.Level, msg string) *zapcore.CheckedEntry {\n\t// Logger.check must always be called directly by a method in the\n\t// Logger interface (e.g., Check, Info, Fatal).\n\t// This skips Logger.check and the Info/Fatal/Check/etc. method that\n\t// called it.\n\tconst callerSkipOffset = 2\n\n\t// Check the level first to reduce the cost of disabled log calls.\n\t// Since Panic and higher may exit, we skip the optimization for those levels.\n\tif lvl < zapcore.DPanicLevel && !log.core.Enabled(lvl) {\n\t\treturn nil\n\t}\n\n\t// Create basic checked entry thru the core; this will be non-nil if the\n\t// log message will actually be written somewhere.\n\tent := zapcore.Entry{\n\t\tLoggerName: log.name,\n\t\tTime:       log.clock.Now(),\n\t\tLevel:      lvl,\n\t\tMessage:    msg,\n\t}\n\tce := log.core.Check(ent, nil)\n\twillWrite := ce != nil\n\n\t// Set up any required terminal behavior.\n\tswitch ent.Level {\n\tcase zapcore.PanicLevel:\n\t\tce = ce.After(ent, terminalHookOverride(zapcore.WriteThenPanic, log.onPanic))\n\tcase zapcore.FatalLevel:\n\t\tce = ce.After(ent, terminalHookOverride(zapcore.WriteThenFatal, log.onFatal))\n\tcase zapcore.DPanicLevel:\n\t\tif log.development {\n\t\t\tce = ce.After(ent, terminalHookOverride(zapcore.WriteThenPanic, log.onPanic))\n\t\t}\n\t}\n\n\t// Only do further annotation if we're going to write this message; checked\n\t// entries that exist only for terminal behavior don't benefit from\n\t// annotation.\n\tif !willWrite {\n\t\treturn ce\n\t}\n\n\t// Thread the error output through to the CheckedEntry.\n\tce.ErrorOutput = log.errorOutput\n\n\taddStack := log.addStack.Enabled(ce.Level)\n\tif !log.addCaller && !addStack {\n\t\treturn ce\n\t}\n\n\t// Adding the caller or stack trace requires capturing the callers of\n\t// this function. We'll share information between these two.\n\tstackDepth := stacktrace.First\n\tif addStack {\n\t\tstackDepth = stacktrace.Full\n\t}\n\tstack := stacktrace.Capture(log.callerSkip+callerSkipOffset, stackDepth)\n\tdefer stack.Free()\n\n\tif stack.Count() == 0 {\n\t\tif log.addCaller {\n\t\t\t_, _ = fmt.Fprintf(\n\t\t\t\tlog.errorOutput,\n\t\t\t\t\"%v Logger.check error: failed to get caller\\n\",\n\t\t\t\tent.Time.UTC(),\n\t\t\t)\n\t\t\t_ = log.errorOutput.Sync()\n\t\t}\n\t\treturn ce\n\t}\n\n\tframe, more := stack.Next()\n\n\tif log.addCaller {\n\t\tce.Caller = zapcore.EntryCaller{\n\t\t\tDefined:  frame.PC != 0,\n\t\t\tPC:       frame.PC,\n\t\t\tFile:     frame.File,\n\t\t\tLine:     frame.Line,\n\t\t\tFunction: frame.Function,\n\t\t}\n\t}\n\n\tif addStack {\n\t\tbuffer := bufferpool.Get()\n\t\tdefer buffer.Free()\n\n\t\tstackfmt := stacktrace.NewFormatter(buffer)\n\n\t\t// We've already extracted the first frame, so format that\n\t\t// separately and defer to stackfmt for the rest.\n\t\tstackfmt.FormatFrame(frame)\n\t\tif more {\n\t\t\tstackfmt.FormatStack(stack)\n\t\t}\n\t\tce.Stack = buffer.String()\n\t}\n\n\treturn ce\n}\n\nfunc terminalHookOverride(defaultHook, override zapcore.CheckWriteHook) zapcore.CheckWriteHook {\n\t// A nil or WriteThenNoop hook will lead to continued execution after\n\t// a Panic or Fatal log entry, which is unexpected. For example,\n\t//\n\t//   f, err := os.Open(..)\n\t//   if err != nil {\n\t//     log.Fatal(\"cannot open\", zap.Error(err))\n\t//   }\n\t//   fmt.Println(f.Name())\n\t//\n\t// The f.Name() will panic if we continue execution after the log.Fatal.\n\tif override == nil || override == zapcore.WriteThenNoop {\n\t\treturn defaultHook\n\t}\n\treturn override\n}\n"
        },
        {
          "name": "logger_bench_test.go",
          "type": "blob",
          "size": 8.458984375,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"errors\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"go.uber.org/zap/internal/ztest\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\ntype user struct {\n\tName      string\n\tEmail     string\n\tCreatedAt time.Time\n}\n\nfunc (u *user) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\tenc.AddString(\"name\", u.Name)\n\tenc.AddString(\"email\", u.Email)\n\tenc.AddInt64(\"created_at\", u.CreatedAt.UnixNano())\n\treturn nil\n}\n\nvar _jane = &user{\n\tName:      \"Jane Doe\",\n\tEmail:     \"jane@test.com\",\n\tCreatedAt: time.Date(1980, 1, 1, 12, 0, 0, 0, time.UTC),\n}\n\nfunc withBenchedLogger(b *testing.B, f func(*Logger)) {\n\tlogger := New(\n\t\tzapcore.NewCore(\n\t\t\tzapcore.NewJSONEncoder(NewProductionConfig().EncoderConfig),\n\t\t\t&ztest.Discarder{},\n\t\t\tDebugLevel,\n\t\t))\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tf(logger)\n\t\t}\n\t})\n}\n\nfunc BenchmarkNoContext(b *testing.B) {\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"No context.\")\n\t})\n}\n\nfunc BenchmarkBoolField(b *testing.B) {\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"Boolean.\", Bool(\"foo\", true))\n\t})\n}\n\nfunc BenchmarkByteStringField(b *testing.B) {\n\tval := []byte(\"bar\")\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"ByteString.\", ByteString(\"foo\", val))\n\t})\n}\n\nfunc BenchmarkFloat64Field(b *testing.B) {\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"Floating point.\", Float64(\"foo\", 3.14))\n\t})\n}\n\nfunc BenchmarkIntField(b *testing.B) {\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"Integer.\", Int(\"foo\", 42))\n\t})\n}\n\nfunc BenchmarkInt64Field(b *testing.B) {\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"64-bit integer.\", Int64(\"foo\", 42))\n\t})\n}\n\nfunc BenchmarkStringField(b *testing.B) {\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"Strings.\", String(\"foo\", \"bar\"))\n\t})\n}\n\nfunc BenchmarkStringerField(b *testing.B) {\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"Level.\", Stringer(\"foo\", InfoLevel))\n\t})\n}\n\nfunc BenchmarkTimeField(b *testing.B) {\n\tt := time.Unix(0, 0)\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"Time.\", Time(\"foo\", t))\n\t})\n}\n\nfunc BenchmarkDurationField(b *testing.B) {\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"Duration\", Duration(\"foo\", time.Second))\n\t})\n}\n\nfunc BenchmarkErrorField(b *testing.B) {\n\terr := errors.New(\"egad\")\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"Error.\", Error(err))\n\t})\n}\n\nfunc BenchmarkErrorsField(b *testing.B) {\n\terrs := []error{\n\t\terrors.New(\"egad\"),\n\t\terrors.New(\"oh no\"),\n\t\terrors.New(\"dear me\"),\n\t\terrors.New(\"such fail\"),\n\t}\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"Errors.\", Errors(\"errors\", errs))\n\t})\n}\n\nfunc BenchmarkStackField(b *testing.B) {\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"Error.\", Stack(\"stacktrace\"))\n\t})\n}\n\nfunc BenchmarkObjectField(b *testing.B) {\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"Arbitrary ObjectMarshaler.\", Object(\"user\", _jane))\n\t})\n}\n\nfunc BenchmarkReflectField(b *testing.B) {\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"Reflection-based serialization.\", Reflect(\"user\", _jane))\n\t})\n}\n\nfunc BenchmarkAddCallerHook(b *testing.B) {\n\tlogger := New(\n\t\tzapcore.NewCore(\n\t\t\tzapcore.NewJSONEncoder(NewProductionConfig().EncoderConfig),\n\t\t\t&ztest.Discarder{},\n\t\t\tInfoLevel,\n\t\t),\n\t\tAddCaller(),\n\t)\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tlogger.Info(\"Caller.\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkAddCallerAndStacktrace(b *testing.B) {\n\tlogger := New(\n\t\tzapcore.NewCore(\n\t\t\tzapcore.NewJSONEncoder(NewProductionConfig().EncoderConfig),\n\t\t\t&ztest.Discarder{},\n\t\t\tInfoLevel,\n\t\t),\n\t\tAddCaller(),\n\t\tAddStacktrace(WarnLevel),\n\t)\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tlogger.Warn(\"Caller and stacktrace.\")\n\t\t}\n\t})\n}\n\nfunc Benchmark5WithsUsed(b *testing.B) {\n\tbenchmarkWithUsed(b, (*Logger).With, 5, true)\n}\n\n// This benchmark will be used in future as a\n// baseline for improving\nfunc Benchmark5WithsNotUsed(b *testing.B) {\n\tbenchmarkWithUsed(b, (*Logger).With, 5, false)\n}\n\nfunc Benchmark5WithLazysUsed(b *testing.B) {\n\tbenchmarkWithUsed(b, (*Logger).WithLazy, 5, true)\n}\n\n// This benchmark will be used in future as a\n// baseline for improving\nfunc Benchmark5WithLazysNotUsed(b *testing.B) {\n\tbenchmarkWithUsed(b, (*Logger).WithLazy, 5, false)\n}\n\nfunc benchmarkWithUsed(b *testing.B, withMethod func(*Logger, ...zapcore.Field) *Logger, N int, use bool) {\n\tkeys := make([]string, N)\n\tvalues := make([]string, N)\n\tfor i := 0; i < N; i++ {\n\t\tkeys[i] = \"k\" + strconv.Itoa(i)\n\t\tvalues[i] = \"v\" + strconv.Itoa(i)\n\t}\n\n\tb.ResetTimer()\n\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tfor i := 0; i < N; i++ {\n\t\t\tlog = withMethod(log, String(keys[i], values[i]))\n\t\t}\n\t\tif use {\n\t\t\tlog.Info(\"used\")\n\t\t\treturn\n\t\t}\n\t\truntime.KeepAlive(log)\n\t})\n}\n\nfunc Benchmark10Fields(b *testing.B) {\n\twithBenchedLogger(b, func(log *Logger) {\n\t\tlog.Info(\"Ten fields, passed at the log site.\",\n\t\t\tInt(\"one\", 1),\n\t\t\tInt(\"two\", 2),\n\t\t\tInt(\"three\", 3),\n\t\t\tInt(\"four\", 4),\n\t\t\tInt(\"five\", 5),\n\t\t\tInt(\"six\", 6),\n\t\t\tInt(\"seven\", 7),\n\t\t\tInt(\"eight\", 8),\n\t\t\tInt(\"nine\", 9),\n\t\t\tInt(\"ten\", 10),\n\t\t)\n\t})\n}\n\nfunc Benchmark100Fields(b *testing.B) {\n\tconst batchSize = 50\n\tlogger := New(zapcore.NewCore(\n\t\tzapcore.NewJSONEncoder(NewProductionConfig().EncoderConfig),\n\t\t&ztest.Discarder{},\n\t\tDebugLevel,\n\t))\n\n\t// Don't include allocating these helper slices in the benchmark. Since\n\t// access to them isn't synchronized, we can't run the benchmark in\n\t// parallel.\n\tfirst := make([]Field, batchSize)\n\tsecond := make([]Field, batchSize)\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tfor i := 0; i < batchSize; i++ {\n\t\t\t// We're duplicating keys, but that doesn't affect performance.\n\t\t\tfirst[i] = Int(\"foo\", i)\n\t\t\tsecond[i] = Int(\"foo\", i+batchSize)\n\t\t}\n\t\tlogger.With(first...).Info(\"Child loggers with lots of context.\", second...)\n\t}\n}\n\nfunc BenchmarkAny(b *testing.B) {\n\tkey := \"some-long-string-longer-than-16\"\n\n\ttests := []struct {\n\t\tname   string\n\t\ttyped  func() Field\n\t\tanyArg any\n\t}{\n\t\t{\n\t\t\tname:   \"string\",\n\t\t\ttyped:  func() Field { return String(key, \"yet-another-long-string\") },\n\t\t\tanyArg: \"yet-another-long-string\",\n\t\t},\n\t\t{\n\t\t\tname:   \"stringer\",\n\t\t\ttyped:  func() Field { return Stringer(key, InfoLevel) },\n\t\t\tanyArg: InfoLevel,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tb.Run(tt.name, func(b *testing.B) {\n\t\t\tb.Run(\"field-only\", func(b *testing.B) {\n\t\t\t\tb.Run(\"typed\", func(b *testing.B) {\n\t\t\t\t\twithBenchedLogger(b, func(log *Logger) {\n\t\t\t\t\t\tf := tt.typed()\n\t\t\t\t\t\truntime.KeepAlive(f)\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t\tb.Run(\"any\", func(b *testing.B) {\n\t\t\t\t\twithBenchedLogger(b, func(log *Logger) {\n\t\t\t\t\t\tf := Any(key, tt.anyArg)\n\t\t\t\t\t\truntime.KeepAlive(f)\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})\n\t\t\tb.Run(\"log\", func(b *testing.B) {\n\t\t\t\tb.Run(\"typed\", func(b *testing.B) {\n\t\t\t\t\twithBenchedLogger(b, func(log *Logger) {\n\t\t\t\t\t\tlog.Info(\"\", tt.typed())\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t\tb.Run(\"any\", func(b *testing.B) {\n\t\t\t\t\twithBenchedLogger(b, func(log *Logger) {\n\t\t\t\t\t\tlog.Info(\"\", Any(key, tt.anyArg))\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})\n\t\t\tb.Run(\"log-go\", func(b *testing.B) {\n\t\t\t\tb.Run(\"typed\", func(b *testing.B) {\n\t\t\t\t\twithBenchedLogger(b, func(log *Logger) {\n\t\t\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\t\t\twg.Add(1)\n\t\t\t\t\t\tgo func() {\n\t\t\t\t\t\t\tlog.Info(\"\", tt.typed())\n\t\t\t\t\t\t\twg.Done()\n\t\t\t\t\t\t}()\n\t\t\t\t\t\twg.Wait()\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t\tb.Run(\"any\", func(b *testing.B) {\n\t\t\t\t\twithBenchedLogger(b, func(log *Logger) {\n\t\t\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\t\t\twg.Add(1)\n\t\t\t\t\t\tgo func() {\n\t\t\t\t\t\t\tlog.Info(\"\", Any(key, tt.anyArg))\n\t\t\t\t\t\t\twg.Done()\n\t\t\t\t\t\t}()\n\t\t\t\t\t\twg.Wait()\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "logger_test.go",
          "type": "blob",
          "size": 28.4609375,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\n\t\"go.uber.org/zap/internal/exit\"\n\t\"go.uber.org/zap/internal/ztest\"\n\t\"go.uber.org/zap/zapcore\"\n\t\"go.uber.org/zap/zaptest/observer\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc makeCountingHook() (func(zapcore.Entry) error, *atomic.Int64) {\n\tcount := &atomic.Int64{}\n\th := func(zapcore.Entry) error {\n\t\tcount.Add(1)\n\t\treturn nil\n\t}\n\treturn h, count\n}\n\nfunc TestLoggerAtomicLevel(t *testing.T) {\n\t// Test that the dynamic level applies to all ancestors and descendants.\n\tdl := NewAtomicLevel()\n\n\twithLogger(t, dl, nil, func(grandparent *Logger, _ *observer.ObservedLogs) {\n\t\tparent := grandparent.With(Int(\"generation\", 1))\n\t\tchild := parent.With(Int(\"generation\", 2))\n\n\t\ttests := []struct {\n\t\t\tsetLevel  zapcore.Level\n\t\t\ttestLevel zapcore.Level\n\t\t\tenabled   bool\n\t\t}{\n\t\t\t{DebugLevel, DebugLevel, true},\n\t\t\t{InfoLevel, DebugLevel, false},\n\t\t\t{WarnLevel, PanicLevel, true},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tdl.SetLevel(tt.setLevel)\n\t\t\tfor _, logger := range []*Logger{grandparent, parent, child} {\n\t\t\t\tif tt.enabled {\n\t\t\t\t\tassert.NotNil(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\tlogger.Check(tt.testLevel, \"\"),\n\t\t\t\t\t\t\"Expected level %s to be enabled after setting level %s.\", tt.testLevel, tt.setLevel,\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tassert.Nil(\n\t\t\t\t\t\tt,\n\t\t\t\t\t\tlogger.Check(tt.testLevel, \"\"),\n\t\t\t\t\t\t\"Expected level %s to be enabled after setting level %s.\", tt.testLevel, tt.setLevel,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc TestLoggerLevel(t *testing.T) {\n\tlevels := []zapcore.Level{\n\t\tDebugLevel,\n\t\tInfoLevel,\n\t\tWarnLevel,\n\t\tErrorLevel,\n\t\tDPanicLevel,\n\t\tPanicLevel,\n\t\tFatalLevel,\n\t}\n\n\tfor _, lvl := range levels {\n\t\tlvl := lvl\n\t\tt.Run(lvl.String(), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tcore, _ := observer.New(lvl)\n\t\t\tlog := New(core)\n\t\t\tassert.Equal(t, lvl, log.Level())\n\t\t})\n\t}\n\n\tt.Run(\"Nop\", func(t *testing.T) {\n\t\tassert.Equal(t, zapcore.InvalidLevel, NewNop().Level())\n\t})\n}\n\nfunc TestLoggerInitialFields(t *testing.T) {\n\tfieldOpts := opts(Fields(Int(\"foo\", 42), String(\"bar\", \"baz\")))\n\twithLogger(t, DebugLevel, fieldOpts, func(logger *Logger, logs *observer.ObservedLogs) {\n\t\tlogger.Info(\"\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\tobserver.LoggedEntry{Context: []Field{Int(\"foo\", 42), String(\"bar\", \"baz\")}},\n\t\t\tlogs.AllUntimed()[0],\n\t\t\t\"Unexpected output with initial fields set.\",\n\t\t)\n\t})\n}\n\nfunc TestLoggerWith(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\tinitialFields []Field\n\t\twithMethod    func(*Logger, ...Field) *Logger\n\t}{\n\t\t{\n\t\t\t\"regular non lazy logger\",\n\t\t\t[]Field{Int(\"foo\", 42)},\n\t\t\t(*Logger).With,\n\t\t},\n\t\t{\n\t\t\t\"regular non lazy logger no initial fields\",\n\t\t\t[]Field{},\n\t\t\t(*Logger).With,\n\t\t},\n\t\t{\n\t\t\t\"lazy with logger\",\n\t\t\t[]Field{Int(\"foo\", 42)},\n\t\t\t(*Logger).WithLazy,\n\t\t},\n\t\t{\n\t\t\t\"lazy with logger no initial fields\",\n\t\t\t[]Field{},\n\t\t\t(*Logger).WithLazy,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\twithLogger(t, DebugLevel, opts(Fields(tt.initialFields...)), func(logger *Logger, logs *observer.ObservedLogs) {\n\t\t\t\t// Child loggers should have copy-on-write semantics, so two children\n\t\t\t\t// shouldn't stomp on each other's fields or affect the parent's fields.\n\t\t\t\ttt.withMethod(logger).Info(\"\")\n\t\t\t\ttt.withMethod(logger, String(\"one\", \"two\")).Info(\"\")\n\t\t\t\ttt.withMethod(logger, String(\"three\", \"four\")).Info(\"\")\n\t\t\t\ttt.withMethod(logger, String(\"five\", \"six\")).With(String(\"seven\", \"eight\")).Info(\"\")\n\t\t\t\tlogger.Info(\"\")\n\n\t\t\t\tassert.Equal(t, []observer.LoggedEntry{\n\t\t\t\t\t{Context: tt.initialFields},\n\t\t\t\t\t{Context: append(tt.initialFields, String(\"one\", \"two\"))},\n\t\t\t\t\t{Context: append(tt.initialFields, String(\"three\", \"four\"))},\n\t\t\t\t\t{Context: append(tt.initialFields, String(\"five\", \"six\"), String(\"seven\", \"eight\"))},\n\t\t\t\t\t{Context: tt.initialFields},\n\t\t\t\t}, logs.AllUntimed(), \"Unexpected cross-talk between child loggers.\")\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestLoggerWithCaptures(t *testing.T) {\n\ttype withF func(*Logger, ...Field) *Logger\n\ttests := []struct {\n\t\tname        string\n\t\twithMethods []withF\n\t\twantJSON    []string\n\t}{\n\t\t{\n\t\t\tname:        \"regular with captures arguments at time of With\",\n\t\t\twithMethods: []withF{(*Logger).With},\n\t\t\twantJSON: []string{\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"hello 0\",\n\t\t\t\t\t\"a0\": [0],\n\t\t\t\t\t\"b0\": [1]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"world 0\",\n\t\t\t\t\t\"a0\": [0],\n\t\t\t\t\t\"c0\": [2]\n\t\t\t\t}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"lazy with captures arguments at time of With or Logging\",\n\t\t\twithMethods: []withF{(*Logger).WithLazy},\n\t\t\twantJSON: []string{\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"hello 0\",\n\t\t\t\t\t\"a0\": [1],\n\t\t\t\t\t\"b0\": [1]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"world 0\",\n\t\t\t\t\t\"a0\": [1],\n\t\t\t\t\t\"c0\": [2]\n\t\t\t\t}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"2x With captures arguments at time of each With\",\n\t\t\twithMethods: []withF{(*Logger).With, (*Logger).With},\n\t\t\twantJSON: []string{\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"hello 0\",\n\t\t\t\t\t\"a0\": [0],\n\t\t\t\t\t\"b0\": [1]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"world 0\",\n\t\t\t\t\t\"a0\": [0],\n\t\t\t\t\t\"c0\": [2]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"hello 1\",\n\t\t\t\t\t\"a0\": [0],\n\t\t\t\t\t\"c0\": [2],\n\t\t\t\t\t\"a1\": [10],\n\t\t\t\t\t\"b1\": [11]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"world 1\",\n\t\t\t\t\t\"a0\": [0],\n\t\t\t\t\t\"c0\": [2],\n\t\t\t\t\t\"a1\": [10],\n\t\t\t\t\t\"c1\": [12]\n\t\t\t\t}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"2x WithLazy. Captures arguments only at logging time.\",\n\t\t\twithMethods: []withF{(*Logger).WithLazy, (*Logger).WithLazy},\n\t\t\twantJSON: []string{\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"hello 0\",\n\t\t\t\t\t\"a0\": [1],\n\t\t\t\t\t\"b0\": [1]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"world 0\",\n\t\t\t\t\t\"a0\": [1],\n\t\t\t\t\t\"c0\": [2]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"hello 1\",\n\t\t\t\t\t\"a0\": [1],\n\t\t\t\t\t\"c0\": [2],\n\t\t\t\t\t\"a1\": [11],\n\t\t\t\t\t\"b1\": [11]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"world 1\",\n\t\t\t\t\t\"a0\": [1],\n\t\t\t\t\t\"c0\": [2],\n\t\t\t\t\t\"a1\": [11],\n\t\t\t\t\t\"c1\": [12]\n\t\t\t\t}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"WithLazy then With\",\n\t\t\twithMethods: []withF{(*Logger).WithLazy, (*Logger).With},\n\t\t\twantJSON: []string{\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"hello 0\",\n\t\t\t\t\t\"a0\": [1],\n\t\t\t\t\t\"b0\": [1]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"world 0\",\n\t\t\t\t\t\"a0\": [1],\n\t\t\t\t\t\"c0\": [2]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"hello 1\",\n\t\t\t\t\t\"a0\": [1],\n\t\t\t\t\t\"c0\": [2],\n\t\t\t\t\t\"a1\": [10],\n\t\t\t\t\t\"b1\": [11]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"world 1\",\n\t\t\t\t\t\"a0\": [1],\n\t\t\t\t\t\"c0\": [2],\n\t\t\t\t\t\"a1\": [10],\n\t\t\t\t\t\"c1\": [12]\n\t\t\t\t}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"With then WithLazy\",\n\t\t\twithMethods: []withF{(*Logger).With, (*Logger).WithLazy},\n\t\t\twantJSON: []string{\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"hello 0\",\n\t\t\t\t\t\"a0\": [0],\n\t\t\t\t\t\"b0\": [1]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"world 0\",\n\t\t\t\t\t\"a0\": [0],\n\t\t\t\t\t\"c0\": [2]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"hello 1\",\n\t\t\t\t\t\"a0\": [0],\n\t\t\t\t\t\"c0\": [2],\n\t\t\t\t\t\"a1\": [11],\n\t\t\t\t\t\"b1\": [11]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"world 1\",\n\t\t\t\t\t\"a0\": [0],\n\t\t\t\t\t\"c0\": [2],\n\t\t\t\t\t\"a1\": [11],\n\t\t\t\t\t\"c1\": [12]\n\t\t\t\t}`,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tenc := zapcore.NewJSONEncoder(zapcore.EncoderConfig{\n\t\t\t\tMessageKey: \"m\",\n\t\t\t})\n\n\t\t\tvar bs ztest.Buffer\n\t\t\tlogger := New(zapcore.NewCore(enc, &bs, DebugLevel))\n\n\t\t\tfor i, withMethod := range tt.withMethods {\n\n\t\t\t\tiStr := strconv.Itoa(i)\n\t\t\t\tx := 10 * i\n\t\t\t\tarr := zapcore.ArrayMarshalerFunc(func(enc zapcore.ArrayEncoder) error {\n\t\t\t\t\tenc.AppendInt(x)\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\n\t\t\t\t// Demonstrate the arguments are captured when With() and Info() are invoked.\n\t\t\t\tlogger = withMethod(logger, Array(\"a\"+iStr, arr))\n\t\t\t\tx++\n\t\t\t\tlogger.Info(fmt.Sprintf(\"hello %d\", i), Array(\"b\"+iStr, arr))\n\t\t\t\tx++\n\t\t\t\tlogger = withMethod(logger, Array(\"c\"+iStr, arr))\n\t\t\t\tlogger.Info(fmt.Sprintf(\"world %d\", i))\n\t\t\t}\n\n\t\t\tif lines := bs.Lines(); assert.Len(t, lines, len(tt.wantJSON)) {\n\t\t\t\tfor i, want := range tt.wantJSON {\n\t\t\t\t\tassert.JSONEq(t, want, lines[i], \"Unexpected output from the %d'th log.\", i)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLoggerLogPanic(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tdo       func(*Logger)\n\t\tshould   bool\n\t\texpected string\n\t}{\n\t\t{func(logger *Logger) { logger.Check(PanicLevel, \"foo\").Write() }, true, \"foo\"},\n\t\t{func(logger *Logger) { logger.Log(PanicLevel, \"bar\") }, true, \"bar\"},\n\t\t{func(logger *Logger) { logger.Panic(\"baz\") }, true, \"baz\"},\n\t} {\n\t\twithLogger(t, DebugLevel, nil, func(logger *Logger, logs *observer.ObservedLogs) {\n\t\t\tif tt.should {\n\t\t\t\tassert.Panics(t, func() { tt.do(logger) }, \"Expected panic\")\n\t\t\t} else {\n\t\t\t\tassert.NotPanics(t, func() { tt.do(logger) }, \"Expected no panic\")\n\t\t\t}\n\n\t\t\toutput := logs.AllUntimed()\n\t\t\tassert.Equal(t, 1, len(output), \"Unexpected number of logs.\")\n\t\t\tassert.Equal(t, 0, len(output[0].Context), \"Unexpected context on first log.\")\n\t\t\tassert.Equal(\n\t\t\t\tt,\n\t\t\t\tzapcore.Entry{Message: tt.expected, Level: PanicLevel},\n\t\t\t\toutput[0].Entry,\n\t\t\t\t\"Unexpected output from panic-level Log.\",\n\t\t\t)\n\t\t})\n\t}\n}\n\nfunc TestLoggerLogFatal(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tdo       func(*Logger)\n\t\texpected string\n\t}{\n\t\t{func(logger *Logger) { logger.Check(FatalLevel, \"foo\").Write() }, \"foo\"},\n\t\t{func(logger *Logger) { logger.Log(FatalLevel, \"bar\") }, \"bar\"},\n\t\t{func(logger *Logger) { logger.Fatal(\"baz\") }, \"baz\"},\n\t} {\n\t\twithLogger(t, DebugLevel, nil, func(logger *Logger, logs *observer.ObservedLogs) {\n\t\t\tstub := exit.WithStub(func() {\n\t\t\t\ttt.do(logger)\n\t\t\t})\n\t\t\tassert.True(t, stub.Exited, \"Expected Fatal logger call to terminate process.\")\n\t\t\toutput := logs.AllUntimed()\n\t\t\tassert.Equal(t, 1, len(output), \"Unexpected number of logs.\")\n\t\t\tassert.Equal(t, 0, len(output[0].Context), \"Unexpected context on first log.\")\n\t\t\tassert.Equal(\n\t\t\t\tt,\n\t\t\t\tzapcore.Entry{Message: tt.expected, Level: FatalLevel},\n\t\t\t\toutput[0].Entry,\n\t\t\t\t\"Unexpected output from fatal-level Log.\",\n\t\t\t)\n\t\t})\n\t}\n}\n\nfunc TestLoggerLeveledMethods(t *testing.T) {\n\twithLogger(t, DebugLevel, nil, func(logger *Logger, logs *observer.ObservedLogs) {\n\t\ttests := []struct {\n\t\t\tmethod        func(string, ...Field)\n\t\t\texpectedLevel zapcore.Level\n\t\t}{\n\t\t\t{logger.Debug, DebugLevel},\n\t\t\t{logger.Info, InfoLevel},\n\t\t\t{logger.Warn, WarnLevel},\n\t\t\t{logger.Error, ErrorLevel},\n\t\t\t{logger.DPanic, DPanicLevel},\n\t\t}\n\t\tfor i, tt := range tests {\n\t\t\ttt.method(\"\")\n\t\t\toutput := logs.AllUntimed()\n\t\t\tassert.Equal(t, i+1, len(output), \"Unexpected number of logs.\")\n\t\t\tassert.Equal(t, 0, len(output[i].Context), \"Unexpected context on first log.\")\n\t\t\tassert.Equal(\n\t\t\t\tt,\n\t\t\t\tzapcore.Entry{Level: tt.expectedLevel},\n\t\t\t\toutput[i].Entry,\n\t\t\t\t\"Unexpected output from %s-level logger method.\", tt.expectedLevel)\n\t\t}\n\t})\n}\n\nfunc TestLoggerLogLevels(t *testing.T) {\n\twithLogger(t, DebugLevel, nil, func(logger *Logger, logs *observer.ObservedLogs) {\n\t\tlevels := []zapcore.Level{\n\t\t\tDebugLevel,\n\t\t\tInfoLevel,\n\t\t\tWarnLevel,\n\t\t\tErrorLevel,\n\t\t\tDPanicLevel,\n\t\t}\n\t\tfor i, level := range levels {\n\t\t\tlogger.Log(level, \"\")\n\t\t\toutput := logs.AllUntimed()\n\t\t\tassert.Equal(t, i+1, len(output), \"Unexpected number of logs.\")\n\t\t\tassert.Equal(t, 0, len(output[i].Context), \"Unexpected context on first log.\")\n\t\t\tassert.Equal(\n\t\t\t\tt,\n\t\t\t\tzapcore.Entry{Level: level},\n\t\t\t\toutput[i].Entry,\n\t\t\t\t\"Unexpected output from %s-level logger method.\", level)\n\t\t}\n\t})\n}\n\nfunc TestLoggerAlwaysPanics(t *testing.T) {\n\t// Users can disable writing out panic-level logs, but calls to logger.Panic()\n\t// should still call panic().\n\twithLogger(t, FatalLevel, nil, func(logger *Logger, logs *observer.ObservedLogs) {\n\t\tmsg := \"Even if output is disabled, logger.Panic should always panic.\"\n\t\tassert.Panics(t, func() { logger.Panic(\"foo\") }, msg)\n\t\tassert.Panics(t, func() { logger.Log(PanicLevel, \"foo\") }, msg)\n\t\tassert.Panics(t, func() {\n\t\t\tif ce := logger.Check(PanicLevel, \"foo\"); ce != nil {\n\t\t\t\tce.Write()\n\t\t\t}\n\t\t}, msg)\n\t\tassert.Equal(t, 0, logs.Len(), \"Panics shouldn't be written out if PanicLevel is disabled.\")\n\t})\n}\n\nfunc TestLoggerAlwaysFatals(t *testing.T) {\n\t// Users can disable writing out fatal-level logs, but calls to logger.Fatal()\n\t// should still terminate the process.\n\twithLogger(t, FatalLevel+1, nil, func(logger *Logger, logs *observer.ObservedLogs) {\n\t\tstub := exit.WithStub(func() { logger.Fatal(\"\") })\n\t\tassert.True(t, stub.Exited, \"Expected calls to logger.Fatal to terminate process.\")\n\n\t\tstub = exit.WithStub(func() { logger.Log(FatalLevel, \"\") })\n\t\tassert.True(t, stub.Exited, \"Expected calls to logger.Fatal to terminate process.\")\n\n\t\tstub = exit.WithStub(func() {\n\t\t\tif ce := logger.Check(FatalLevel, \"\"); ce != nil {\n\t\t\t\tce.Write()\n\t\t\t}\n\t\t})\n\t\tassert.True(t, stub.Exited, \"Expected calls to logger.Check(FatalLevel, ...) to terminate process.\")\n\n\t\tassert.Equal(t, 0, logs.Len(), \"Shouldn't write out logs when fatal-level logging is disabled.\")\n\t})\n}\n\nfunc TestLoggerDPanic(t *testing.T) {\n\twithLogger(t, DebugLevel, nil, func(logger *Logger, logs *observer.ObservedLogs) {\n\t\tassert.NotPanics(t, func() { logger.DPanic(\"\") })\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t[]observer.LoggedEntry{{Entry: zapcore.Entry{Level: DPanicLevel}, Context: []Field{}}},\n\t\t\tlogs.AllUntimed(),\n\t\t\t\"Unexpected log output from DPanic in production mode.\",\n\t\t)\n\t})\n\twithLogger(t, DebugLevel, opts(Development()), func(logger *Logger, logs *observer.ObservedLogs) {\n\t\tassert.Panics(t, func() { logger.DPanic(\"\") })\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t[]observer.LoggedEntry{{Entry: zapcore.Entry{Level: DPanicLevel}, Context: []Field{}}},\n\t\t\tlogs.AllUntimed(),\n\t\t\t\"Unexpected log output from DPanic in development mode.\",\n\t\t)\n\t})\n}\n\nfunc TestLoggerNoOpsDisabledLevels(t *testing.T) {\n\twithLogger(t, WarnLevel, nil, func(logger *Logger, logs *observer.ObservedLogs) {\n\t\tlogger.Info(\"silence!\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\t[]observer.LoggedEntry{},\n\t\t\tlogs.AllUntimed(),\n\t\t\t\"Expected logging at a disabled level to produce no output.\",\n\t\t)\n\t})\n}\n\nfunc TestLoggerNames(t *testing.T) {\n\ttests := []struct {\n\t\tnames    []string\n\t\texpected string\n\t}{\n\t\t{nil, \"\"},\n\t\t{[]string{\"\"}, \"\"},\n\t\t{[]string{\"foo\"}, \"foo\"},\n\t\t{[]string{\"foo\", \"\"}, \"foo\"},\n\t\t{[]string{\"foo\", \"bar\"}, \"foo.bar\"},\n\t\t{[]string{\"foo.bar\", \"baz\"}, \"foo.bar.baz\"},\n\t\t// Garbage in, garbage out.\n\t\t{[]string{\"foo.\", \"bar\"}, \"foo..bar\"},\n\t\t{[]string{\"foo\", \".bar\"}, \"foo..bar\"},\n\t\t{[]string{\"foo.\", \".bar\"}, \"foo...bar\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\twithLogger(t, DebugLevel, nil, func(log *Logger, logs *observer.ObservedLogs) {\n\t\t\tfor _, n := range tt.names {\n\t\t\t\tlog = log.Named(n)\n\t\t\t}\n\t\t\tlog.Info(\"\")\n\t\t\trequire.Equal(t, 1, logs.Len(), \"Expected only one log entry to be written.\")\n\t\t\tassert.Equal(t, tt.expected, logs.AllUntimed()[0].LoggerName, \"Unexpected logger name from entry.\")\n\t\t\tassert.Equal(t, tt.expected, log.Name(), \"Unexpected logger name.\")\n\t\t})\n\t\twithSugar(t, DebugLevel, nil, func(log *SugaredLogger, logs *observer.ObservedLogs) {\n\t\t\tfor _, n := range tt.names {\n\t\t\t\tlog = log.Named(n)\n\t\t\t}\n\t\t\tlog.Infow(\"\")\n\t\t\trequire.Equal(t, 1, logs.Len(), \"Expected only one log entry to be written.\")\n\t\t\tassert.Equal(t, tt.expected, logs.AllUntimed()[0].LoggerName, \"Unexpected logger name from entry.\")\n\t\t\tassert.Equal(t, tt.expected, log.base.Name(), \"Unexpected logger name.\")\n\t\t})\n\t}\n}\n\nfunc TestLoggerWriteFailure(t *testing.T) {\n\terrSink := &ztest.Buffer{}\n\tlogger := New(\n\t\tzapcore.NewCore(\n\t\t\tzapcore.NewJSONEncoder(NewProductionConfig().EncoderConfig),\n\t\t\tzapcore.Lock(zapcore.AddSync(ztest.FailWriter{})),\n\t\t\tDebugLevel,\n\t\t),\n\t\tErrorOutput(errSink),\n\t)\n\n\tlogger.Info(\"foo\")\n\t// Should log the error.\n\tassert.Regexp(t, `write error: failed`, errSink.Stripped(), \"Expected to log the error to the error output.\")\n\tassert.True(t, errSink.Called(), \"Expected logging an internal error to call Sync the error sink.\")\n}\n\nfunc TestLoggerSync(t *testing.T) {\n\twithLogger(t, DebugLevel, nil, func(logger *Logger, _ *observer.ObservedLogs) {\n\t\tassert.NoError(t, logger.Sync(), \"Expected syncing a test logger to succeed.\")\n\t\tassert.NoError(t, logger.Sugar().Sync(), \"Expected syncing a sugared logger to succeed.\")\n\t})\n}\n\nfunc TestLoggerSyncFail(t *testing.T) {\n\tnoSync := &ztest.Buffer{}\n\terr := errors.New(\"fail\")\n\tnoSync.SetError(err)\n\tlogger := New(zapcore.NewCore(\n\t\tzapcore.NewJSONEncoder(zapcore.EncoderConfig{}),\n\t\tnoSync,\n\t\tDebugLevel,\n\t))\n\tassert.Equal(t, err, logger.Sync(), \"Expected Logger.Sync to propagate errors.\")\n\tassert.Equal(t, err, logger.Sugar().Sync(), \"Expected SugaredLogger.Sync to propagate errors.\")\n}\n\nfunc TestLoggerAddCaller(t *testing.T) {\n\ttests := []struct {\n\t\toptions []Option\n\t\tpat     string\n\t}{\n\t\t{opts(), `^undefined$`},\n\t\t{opts(WithCaller(false)), `^undefined$`},\n\t\t{opts(AddCaller()), `.+/logger_test.go:[\\d]+$`},\n\t\t{opts(AddCaller(), WithCaller(false)), `^undefined$`},\n\t\t{opts(WithCaller(true)), `.+/logger_test.go:[\\d]+$`},\n\t\t{opts(WithCaller(true), WithCaller(false)), `^undefined$`},\n\t\t{opts(AddCaller(), AddCallerSkip(1), AddCallerSkip(-1)), `.+/logger_test.go:[\\d]+$`},\n\t\t{opts(AddCaller(), AddCallerSkip(1)), `.+/common_test.go:[\\d]+$`},\n\t\t{opts(AddCaller(), AddCallerSkip(1), AddCallerSkip(3)), `.+/src/runtime/.*:[\\d]+$`},\n\t}\n\tfor _, tt := range tests {\n\t\twithLogger(t, DebugLevel, tt.options, func(logger *Logger, logs *observer.ObservedLogs) {\n\t\t\t// Make sure that sugaring and desugaring resets caller skip properly.\n\t\t\tlogger = logger.Sugar().Desugar()\n\t\t\tlogger.Info(\"\")\n\t\t\toutput := logs.AllUntimed()\n\t\t\tassert.Equal(t, 1, len(output), \"Unexpected number of logs written out.\")\n\t\t\tassert.Regexp(\n\t\t\t\tt,\n\t\t\t\ttt.pat,\n\t\t\t\toutput[0].Caller,\n\t\t\t\t\"Expected to find package name and file name in output.\",\n\t\t\t)\n\t\t})\n\t}\n}\n\nfunc TestLoggerAddCallerFunction(t *testing.T) {\n\ttests := []struct {\n\t\toptions         []Option\n\t\tloggerFunction  string\n\t\tsugaredFunction string\n\t}{\n\t\t{\n\t\t\toptions:         opts(),\n\t\t\tloggerFunction:  \"\",\n\t\t\tsugaredFunction: \"\",\n\t\t},\n\t\t{\n\t\t\toptions:         opts(WithCaller(false)),\n\t\t\tloggerFunction:  \"\",\n\t\t\tsugaredFunction: \"\",\n\t\t},\n\t\t{\n\t\t\toptions:         opts(AddCaller()),\n\t\t\tloggerFunction:  \"go.uber.org/zap.infoLog\",\n\t\t\tsugaredFunction: \"go.uber.org/zap.infoLogSugared\",\n\t\t},\n\t\t{\n\t\t\toptions:         opts(AddCaller(), WithCaller(false)),\n\t\t\tloggerFunction:  \"\",\n\t\t\tsugaredFunction: \"\",\n\t\t},\n\t\t{\n\t\t\toptions:         opts(WithCaller(true)),\n\t\t\tloggerFunction:  \"go.uber.org/zap.infoLog\",\n\t\t\tsugaredFunction: \"go.uber.org/zap.infoLogSugared\",\n\t\t},\n\t\t{\n\t\t\toptions:         opts(WithCaller(true), WithCaller(false)),\n\t\t\tloggerFunction:  \"\",\n\t\t\tsugaredFunction: \"\",\n\t\t},\n\t\t{\n\t\t\toptions:         opts(AddCaller(), AddCallerSkip(1), AddCallerSkip(-1)),\n\t\t\tloggerFunction:  \"go.uber.org/zap.infoLog\",\n\t\t\tsugaredFunction: \"go.uber.org/zap.infoLogSugared\",\n\t\t},\n\t\t{\n\t\t\toptions:         opts(AddCaller(), AddCallerSkip(2)),\n\t\t\tloggerFunction:  \"go.uber.org/zap.withLogger\",\n\t\t\tsugaredFunction: \"go.uber.org/zap.withLogger\",\n\t\t},\n\t\t{\n\t\t\toptions:         opts(AddCaller(), AddCallerSkip(2), AddCallerSkip(3)),\n\t\t\tloggerFunction:  \"runtime.goexit\",\n\t\t\tsugaredFunction: \"runtime.goexit\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\twithLogger(t, DebugLevel, tt.options, func(logger *Logger, logs *observer.ObservedLogs) {\n\t\t\t// Make sure that sugaring and desugaring resets caller skip properly.\n\t\t\tlogger = logger.Sugar().Desugar()\n\t\t\tinfoLog(logger, \"\")\n\t\t\tinfoLogSugared(logger.Sugar(), \"\")\n\t\t\tinfoLog(logger.Sugar().Desugar(), \"\")\n\n\t\t\tentries := logs.AllUntimed()\n\t\t\tassert.Equal(t, 3, len(entries), \"Unexpected number of logs written out.\")\n\t\t\tfor _, entry := range []observer.LoggedEntry{entries[0], entries[2]} {\n\t\t\t\tassert.Regexp(\n\t\t\t\t\tt,\n\t\t\t\t\ttt.loggerFunction,\n\t\t\t\t\tentry.Caller.Function,\n\t\t\t\t\t\"Expected to find function name in output.\",\n\t\t\t\t)\n\t\t\t}\n\t\t\tassert.Regexp(\n\t\t\t\tt,\n\t\t\t\ttt.sugaredFunction,\n\t\t\t\tentries[1].Caller.Function,\n\t\t\t\t\"Expected to find function name in output.\",\n\t\t\t)\n\t\t})\n\t}\n}\n\nfunc TestLoggerAddCallerFail(t *testing.T) {\n\terrBuf := &ztest.Buffer{}\n\twithLogger(t, DebugLevel, opts(AddCaller(), AddCallerSkip(1e3), ErrorOutput(errBuf)), func(log *Logger, logs *observer.ObservedLogs) {\n\t\tlog.Info(\"Failure.\")\n\t\tassert.Regexp(\n\t\t\tt,\n\t\t\t`Logger.check error: failed to get caller`,\n\t\t\terrBuf.String(),\n\t\t\t\"Didn't find expected failure message.\",\n\t\t)\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\tlogs.AllUntimed()[0].Message,\n\t\t\t\"Failure.\",\n\t\t\t\"Expected original message to survive failures in runtime.Caller.\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\tlogs.AllUntimed()[0].Caller.Function,\n\t\t\t\"\",\n\t\t\t\"Expected function name to be empty string.\")\n\t})\n}\n\nfunc TestLoggerReplaceCore(t *testing.T) {\n\treplace := WrapCore(func(zapcore.Core) zapcore.Core {\n\t\treturn zapcore.NewNopCore()\n\t})\n\twithLogger(t, DebugLevel, opts(replace), func(logger *Logger, logs *observer.ObservedLogs) {\n\t\tlogger.Debug(\"\")\n\t\tlogger.Info(\"\")\n\t\tlogger.Warn(\"\")\n\t\tassert.Equal(t, 0, logs.Len(), \"Expected no-op core to write no logs.\")\n\t})\n}\n\nfunc TestLoggerIncreaseLevel(t *testing.T) {\n\twithLogger(t, DebugLevel, opts(IncreaseLevel(WarnLevel)), func(logger *Logger, logs *observer.ObservedLogs) {\n\t\tlogger.Info(\"logger.Info\")\n\t\tlogger.Warn(\"logger.Warn\")\n\t\tlogger.Error(\"logger.Error\")\n\t\trequire.Equal(t, 2, logs.Len(), \"expected only warn + error logs due to IncreaseLevel.\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\tlogs.AllUntimed()[0].Message,\n\t\t\t\"logger.Warn\",\n\t\t\t\"Expected first logged message to be warn level message\",\n\t\t)\n\t})\n}\n\nfunc TestLoggerHooks(t *testing.T) {\n\thook, seen := makeCountingHook()\n\twithLogger(t, DebugLevel, opts(Hooks(hook)), func(logger *Logger, logs *observer.ObservedLogs) {\n\t\tlogger.Debug(\"\")\n\t\tlogger.Info(\"\")\n\t})\n\tassert.Equal(t, int64(2), seen.Load(), \"Hook saw an unexpected number of logs.\")\n}\n\nfunc TestLoggerConcurrent(t *testing.T) {\n\twithLogger(t, DebugLevel, nil, func(logger *Logger, logs *observer.ObservedLogs) {\n\t\tchild := logger.With(String(\"foo\", \"bar\"))\n\n\t\twg := &sync.WaitGroup{}\n\t\trunConcurrently(5, 10, wg, func() {\n\t\t\tlogger.Info(\"\", String(\"foo\", \"bar\"))\n\t\t})\n\t\trunConcurrently(5, 10, wg, func() {\n\t\t\tchild.Info(\"\")\n\t\t})\n\n\t\twg.Wait()\n\n\t\t// Make sure the output doesn't contain interspersed entries.\n\t\tassert.Equal(t, 100, logs.Len(), \"Unexpected number of logs written out.\")\n\t\tfor _, obs := range logs.AllUntimed() {\n\t\t\tassert.Equal(\n\t\t\t\tt,\n\t\t\t\tobserver.LoggedEntry{\n\t\t\t\t\tEntry:   zapcore.Entry{Level: InfoLevel},\n\t\t\t\t\tContext: []Field{String(\"foo\", \"bar\")},\n\t\t\t\t},\n\t\t\t\tobs,\n\t\t\t\t\"Unexpected log output.\",\n\t\t\t)\n\t\t}\n\t})\n}\n\nfunc TestLoggerFatalOnNoop(t *testing.T) {\n\texitStub := exit.Stub()\n\tdefer exitStub.Unstub()\n\tcore, _ := observer.New(InfoLevel)\n\n\t// We don't allow a no-op fatal hook.\n\tNew(core, WithFatalHook(zapcore.WriteThenNoop)).Fatal(\"great sadness\")\n\tassert.True(t, exitStub.Exited, \"must exit for WriteThenNoop\")\n\tassert.Equal(t, 1, exitStub.Code, \"must exit with status 1 for WriteThenNoop\")\n}\n\nfunc TestLoggerCustomOnPanic(t *testing.T) {\n\ttests := []struct {\n\t\tmsg          string\n\t\tlevel        zapcore.Level\n\t\topts         []Option\n\t\tfinished     bool\n\t\twant         []observer.LoggedEntry\n\t\trecoverValue any\n\t}{\n\t\t{\n\t\t\tmsg:      \"panic with nil hook\",\n\t\t\tlevel:    PanicLevel,\n\t\t\topts:     opts(WithPanicHook(nil)),\n\t\t\tfinished: false,\n\t\t\twant: []observer.LoggedEntry{\n\t\t\t\t{\n\t\t\t\t\tEntry:   zapcore.Entry{Level: PanicLevel, Message: \"foobar\"},\n\t\t\t\t\tContext: []Field{},\n\t\t\t\t},\n\t\t\t},\n\t\t\trecoverValue: \"foobar\",\n\t\t},\n\t\t{\n\t\t\tmsg:      \"panic with noop hook\",\n\t\t\tlevel:    PanicLevel,\n\t\t\topts:     opts(WithPanicHook(zapcore.WriteThenNoop)),\n\t\t\tfinished: false,\n\t\t\twant: []observer.LoggedEntry{\n\t\t\t\t{\n\t\t\t\t\tEntry:   zapcore.Entry{Level: PanicLevel, Message: \"foobar\"},\n\t\t\t\t\tContext: []Field{},\n\t\t\t\t},\n\t\t\t},\n\t\t\trecoverValue: \"foobar\",\n\t\t},\n\t\t{\n\t\t\tmsg:      \"no panic with goexit hook\",\n\t\t\tlevel:    PanicLevel,\n\t\t\topts:     opts(WithPanicHook(zapcore.WriteThenGoexit)),\n\t\t\tfinished: false,\n\t\t\twant: []observer.LoggedEntry{\n\t\t\t\t{\n\t\t\t\t\tEntry:   zapcore.Entry{Level: PanicLevel, Message: \"foobar\"},\n\t\t\t\t\tContext: []Field{},\n\t\t\t\t},\n\t\t\t},\n\t\t\trecoverValue: nil,\n\t\t},\n\t\t{\n\t\t\tmsg:      \"dpanic no panic in development mode with goexit hook\",\n\t\t\tlevel:    DPanicLevel,\n\t\t\topts:     opts(WithPanicHook(zapcore.WriteThenGoexit), Development()),\n\t\t\tfinished: false,\n\t\t\twant: []observer.LoggedEntry{\n\t\t\t\t{\n\t\t\t\t\tEntry:   zapcore.Entry{Level: DPanicLevel, Message: \"foobar\"},\n\t\t\t\t\tContext: []Field{},\n\t\t\t\t},\n\t\t\t},\n\t\t\trecoverValue: nil,\n\t\t},\n\t\t{\n\t\t\tmsg:      \"dpanic panic in development mode with noop hook\",\n\t\t\tlevel:    DPanicLevel,\n\t\t\topts:     opts(WithPanicHook(zapcore.WriteThenNoop), Development()),\n\t\t\tfinished: false,\n\t\t\twant: []observer.LoggedEntry{\n\t\t\t\t{\n\t\t\t\t\tEntry:   zapcore.Entry{Level: DPanicLevel, Message: \"foobar\"},\n\t\t\t\t\tContext: []Field{},\n\t\t\t\t},\n\t\t\t},\n\t\t\trecoverValue: \"foobar\",\n\t\t},\n\t\t{\n\t\t\tmsg:      \"dpanic no exit in production mode with goexit hook\",\n\t\t\tlevel:    DPanicLevel,\n\t\t\topts:     opts(WithPanicHook(zapcore.WriteThenPanic)),\n\t\t\tfinished: true,\n\t\t\twant: []observer.LoggedEntry{\n\t\t\t\t{\n\t\t\t\t\tEntry:   zapcore.Entry{Level: DPanicLevel, Message: \"foobar\"},\n\t\t\t\t\tContext: []Field{},\n\t\t\t\t},\n\t\t\t},\n\t\t\trecoverValue: nil,\n\t\t},\n\t\t{\n\t\t\tmsg:      \"dpanic no panic in production mode with panic hook\",\n\t\t\tlevel:    DPanicLevel,\n\t\t\topts:     opts(WithPanicHook(zapcore.WriteThenPanic)),\n\t\t\tfinished: true,\n\t\t\twant: []observer.LoggedEntry{\n\t\t\t\t{\n\t\t\t\t\tEntry:   zapcore.Entry{Level: DPanicLevel, Message: \"foobar\"},\n\t\t\t\t\tContext: []Field{},\n\t\t\t\t},\n\t\t\t},\n\t\t\trecoverValue: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.msg, func(t *testing.T) {\n\t\t\twithLogger(t, InfoLevel, tt.opts, func(logger *Logger, logs *observer.ObservedLogs) {\n\t\t\t\tvar finished bool\n\t\t\t\trecovered := make(chan any)\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer func() {\n\t\t\t\t\t\trecovered <- recover()\n\t\t\t\t\t}()\n\n\t\t\t\t\tlogger.Log(tt.level, \"foobar\")\n\t\t\t\t\tfinished = true\n\t\t\t\t}()\n\n\t\t\t\tassert.Equal(t, tt.recoverValue, <-recovered, \"unexpected value from recover()\")\n\t\t\t\tassert.Equal(t, tt.finished, finished, \"expect goroutine finished state doesn't match\")\n\t\t\t\tassert.Equal(t, tt.want, logs.AllUntimed(), \"unexpected logs\")\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestLoggerCustomOnFatal(t *testing.T) {\n\ttests := []struct {\n\t\tmsg          string\n\t\tonFatal      zapcore.CheckWriteAction\n\t\trecoverValue interface{}\n\t}{\n\t\t{\n\t\t\tmsg:          \"panic\",\n\t\t\tonFatal:      zapcore.WriteThenPanic,\n\t\t\trecoverValue: \"fatal\",\n\t\t},\n\t\t{\n\t\t\tmsg:          \"goexit\",\n\t\t\tonFatal:      zapcore.WriteThenGoexit,\n\t\t\trecoverValue: nil,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.msg, func(t *testing.T) {\n\t\t\twithLogger(t, InfoLevel, opts(OnFatal(tt.onFatal)), func(logger *Logger, logs *observer.ObservedLogs) {\n\t\t\t\tvar finished bool\n\t\t\t\trecovered := make(chan interface{})\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer func() {\n\t\t\t\t\t\trecovered <- recover()\n\t\t\t\t\t}()\n\n\t\t\t\t\tlogger.Fatal(\"fatal\")\n\t\t\t\t\tfinished = true\n\t\t\t\t}()\n\n\t\t\t\tassert.Equal(t, tt.recoverValue, <-recovered, \"unexpected value from recover()\")\n\t\t\t\tassert.False(t, finished, \"expect goroutine to not finish after Fatal\")\n\n\t\t\t\tassert.Equal(t, []observer.LoggedEntry{{\n\t\t\t\t\tEntry:   zapcore.Entry{Level: FatalLevel, Message: \"fatal\"},\n\t\t\t\t\tContext: []Field{},\n\t\t\t\t}}, logs.AllUntimed(), \"unexpected logs\")\n\t\t\t})\n\t\t})\n\t}\n}\n\ntype customWriteHook struct {\n\tcalled bool\n}\n\nfunc (h *customWriteHook) OnWrite(_ *zapcore.CheckedEntry, _ []Field) {\n\th.called = true\n}\n\nfunc TestLoggerWithFatalHook(t *testing.T) {\n\tvar h customWriteHook\n\twithLogger(t, InfoLevel, opts(WithFatalHook(&h)), func(logger *Logger, logs *observer.ObservedLogs) {\n\t\tlogger.Fatal(\"great sadness\")\n\t\tassert.True(t, h.called)\n\t\tassert.Equal(t, 1, logs.FilterLevelExact(FatalLevel).Len())\n\t})\n}\n\nfunc TestNopLogger(t *testing.T) {\n\tlogger := NewNop()\n\n\tt.Run(\"basic levels\", func(t *testing.T) {\n\t\tlogger.Debug(\"foo\", String(\"k\", \"v\"))\n\t\tlogger.Info(\"bar\", Int(\"x\", 42))\n\t\tlogger.Warn(\"baz\", Strings(\"ks\", []string{\"a\", \"b\"}))\n\t\tlogger.Error(\"qux\", Error(errors.New(\"great sadness\")))\n\t})\n\n\tt.Run(\"DPanic\", func(t *testing.T) {\n\t\tlogger.With(String(\"component\", \"whatever\")).DPanic(\"stuff\")\n\t})\n\n\tt.Run(\"Panic\", func(t *testing.T) {\n\t\tassert.Panics(t, func() {\n\t\t\tlogger.Panic(\"great sadness\")\n\t\t}, \"Nop logger should still cause panics.\")\n\t})\n}\n\nfunc TestMust(t *testing.T) {\n\tt.Run(\"must without an error does not panic\", func(t *testing.T) {\n\t\tassert.NotPanics(t, func() { Must(NewNop(), nil) }, \"must paniced with no error\")\n\t})\n\n\tt.Run(\"must with an error panics\", func(t *testing.T) {\n\t\tassert.Panics(t, func() { Must(nil, errors.New(\"an error\")) }, \"must did not panic with an error\")\n\t})\n}\n\nfunc infoLog(logger *Logger, msg string, fields ...Field) {\n\tlogger.Info(msg, fields...)\n}\n\nfunc infoLogSugared(logger *SugaredLogger, args ...interface{}) {\n\tlogger.Info(args...)\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 6.294921875,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"fmt\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\n// An Option configures a Logger.\ntype Option interface {\n\tapply(*Logger)\n}\n\n// optionFunc wraps a func so it satisfies the Option interface.\ntype optionFunc func(*Logger)\n\nfunc (f optionFunc) apply(log *Logger) {\n\tf(log)\n}\n\n// WrapCore wraps or replaces the Logger's underlying zapcore.Core.\nfunc WrapCore(f func(zapcore.Core) zapcore.Core) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = f(log.core)\n\t})\n}\n\n// Hooks registers functions which will be called each time the Logger writes\n// out an Entry. Repeated use of Hooks is additive.\n//\n// Hooks are useful for simple side effects, like capturing metrics for the\n// number of emitted logs. More complex side effects, including anything that\n// requires access to the Entry's structured fields, should be implemented as\n// a zapcore.Core instead. See zapcore.RegisterHooks for details.\nfunc Hooks(hooks ...func(zapcore.Entry) error) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = zapcore.RegisterHooks(log.core, hooks...)\n\t})\n}\n\n// Fields adds fields to the Logger.\nfunc Fields(fs ...Field) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.core = log.core.With(fs)\n\t})\n}\n\n// ErrorOutput sets the destination for errors generated by the Logger. Note\n// that this option only affects internal errors; for sample code that sends\n// error-level logs to a different location from info- and debug-level logs,\n// see the package-level AdvancedConfiguration example.\n//\n// The supplied WriteSyncer must be safe for concurrent use. The Open and\n// zapcore.Lock functions are the simplest ways to protect files with a mutex.\nfunc ErrorOutput(w zapcore.WriteSyncer) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.errorOutput = w\n\t})\n}\n\n// Development puts the logger in development mode, which makes DPanic-level\n// logs panic instead of simply logging an error.\nfunc Development() Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.development = true\n\t})\n}\n\n// AddCaller configures the Logger to annotate each message with the filename,\n// line number, and function name of zap's caller. See also WithCaller.\nfunc AddCaller() Option {\n\treturn WithCaller(true)\n}\n\n// WithCaller configures the Logger to annotate each message with the filename,\n// line number, and function name of zap's caller, or not, depending on the\n// value of enabled. This is a generalized form of AddCaller.\nfunc WithCaller(enabled bool) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.addCaller = enabled\n\t})\n}\n\n// AddCallerSkip increases the number of callers skipped by caller annotation\n// (as enabled by the AddCaller option). When building wrappers around the\n// Logger and SugaredLogger, supplying this Option prevents zap from always\n// reporting the wrapper code as the caller.\nfunc AddCallerSkip(skip int) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.callerSkip += skip\n\t})\n}\n\n// AddStacktrace configures the Logger to record a stack trace for all messages at\n// or above a given level.\nfunc AddStacktrace(lvl zapcore.LevelEnabler) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.addStack = lvl\n\t})\n}\n\n// IncreaseLevel increase the level of the logger. It has no effect if\n// the passed in level tries to decrease the level of the logger.\nfunc IncreaseLevel(lvl zapcore.LevelEnabler) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tcore, err := zapcore.NewIncreaseLevelCore(log.core, lvl)\n\t\tif err != nil {\n\t\t\t_, _ = fmt.Fprintf(\n\t\t\t\tlog.errorOutput,\n\t\t\t\t\"failed to IncreaseLevel: %v\\n\",\n\t\t\t\terr,\n\t\t\t)\n\t\t} else {\n\t\t\tlog.core = core\n\t\t}\n\t})\n}\n\n// WithPanicHook sets a CheckWriteHook to run on Panic/DPanic logs.\n// Zap will call this hook after writing a log statement with a Panic/DPanic level.\n//\n// For example, the following builds a logger that will exit the current\n// goroutine after writing a Panic/DPanic log message, but it will not start a panic.\n//\n//\tzap.New(core, zap.WithPanicHook(zapcore.WriteThenGoexit))\n//\n// This is useful for testing Panic/DPanic log output.\nfunc WithPanicHook(hook zapcore.CheckWriteHook) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.onPanic = hook\n\t})\n}\n\n// OnFatal sets the action to take on fatal logs.\n//\n// Deprecated: Use [WithFatalHook] instead.\nfunc OnFatal(action zapcore.CheckWriteAction) Option {\n\treturn WithFatalHook(action)\n}\n\n// WithFatalHook sets a CheckWriteHook to run on fatal logs.\n// Zap will call this hook after writing a log statement with a Fatal level.\n//\n// For example, the following builds a logger that will exit the current\n// goroutine after writing a fatal log message, but it will not exit the\n// program.\n//\n//\tzap.New(core, zap.WithFatalHook(zapcore.WriteThenGoexit))\n//\n// It is important that the provided CheckWriteHook stops the control flow at\n// the current statement to meet expectations of callers of the logger.\n// We recommend calling os.Exit or runtime.Goexit inside custom hooks at\n// minimum.\nfunc WithFatalHook(hook zapcore.CheckWriteHook) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.onFatal = hook\n\t})\n}\n\n// WithClock specifies the clock used by the logger to determine the current\n// time for logged entries. Defaults to the system clock with time.Now.\nfunc WithClock(clock zapcore.Clock) Option {\n\treturn optionFunc(func(log *Logger) {\n\t\tlog.clock = clock\n\t})\n}\n"
        },
        {
          "name": "sink.go",
          "type": "blob",
          "size": 5.4833984375,
          "content": "// Copyright (c) 2016-2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\nconst schemeFile = \"file\"\n\nvar _sinkRegistry = newSinkRegistry()\n\n// Sink defines the interface to write to and close logger destinations.\ntype Sink interface {\n\tzapcore.WriteSyncer\n\tio.Closer\n}\n\ntype errSinkNotFound struct {\n\tscheme string\n}\n\nfunc (e *errSinkNotFound) Error() string {\n\treturn fmt.Sprintf(\"no sink found for scheme %q\", e.scheme)\n}\n\ntype nopCloserSink struct{ zapcore.WriteSyncer }\n\nfunc (nopCloserSink) Close() error { return nil }\n\ntype sinkRegistry struct {\n\tmu        sync.Mutex\n\tfactories map[string]func(*url.URL) (Sink, error)          // keyed by scheme\n\topenFile  func(string, int, os.FileMode) (*os.File, error) // type matches os.OpenFile\n}\n\nfunc newSinkRegistry() *sinkRegistry {\n\tsr := &sinkRegistry{\n\t\tfactories: make(map[string]func(*url.URL) (Sink, error)),\n\t\topenFile:  os.OpenFile,\n\t}\n\t// Infallible operation: the registry is empty, so we can't have a conflict.\n\t_ = sr.RegisterSink(schemeFile, sr.newFileSinkFromURL)\n\treturn sr\n}\n\n// RegisterSink registers the given factory for the specific scheme.\nfunc (sr *sinkRegistry) RegisterSink(scheme string, factory func(*url.URL) (Sink, error)) error {\n\tsr.mu.Lock()\n\tdefer sr.mu.Unlock()\n\n\tif scheme == \"\" {\n\t\treturn errors.New(\"can't register a sink factory for empty string\")\n\t}\n\tnormalized, err := normalizeScheme(scheme)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%q is not a valid scheme: %v\", scheme, err)\n\t}\n\tif _, ok := sr.factories[normalized]; ok {\n\t\treturn fmt.Errorf(\"sink factory already registered for scheme %q\", normalized)\n\t}\n\tsr.factories[normalized] = factory\n\treturn nil\n}\n\nfunc (sr *sinkRegistry) newSink(rawURL string) (Sink, error) {\n\t// URL parsing doesn't work well for Windows paths such as `c:\\log.txt`, as scheme is set to\n\t// the drive, and path is unset unless `c:/log.txt` is used.\n\t// To avoid Windows-specific URL handling, we instead check IsAbs to open as a file.\n\t// filepath.IsAbs is OS-specific, so IsAbs('c:/log.txt') is false outside of Windows.\n\tif filepath.IsAbs(rawURL) {\n\t\treturn sr.newFileSinkFromPath(rawURL)\n\t}\n\n\tu, err := url.Parse(rawURL)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"can't parse %q as a URL: %v\", rawURL, err)\n\t}\n\tif u.Scheme == \"\" {\n\t\tu.Scheme = schemeFile\n\t}\n\n\tsr.mu.Lock()\n\tfactory, ok := sr.factories[u.Scheme]\n\tsr.mu.Unlock()\n\tif !ok {\n\t\treturn nil, &errSinkNotFound{u.Scheme}\n\t}\n\treturn factory(u)\n}\n\n// RegisterSink registers a user-supplied factory for all sinks with a\n// particular scheme.\n//\n// All schemes must be ASCII, valid under section 0.1 of RFC 3986\n// (https://tools.ietf.org/html/rfc3983#section-3.1), and must not already\n// have a factory registered. Zap automatically registers a factory for the\n// \"file\" scheme.\nfunc RegisterSink(scheme string, factory func(*url.URL) (Sink, error)) error {\n\treturn _sinkRegistry.RegisterSink(scheme, factory)\n}\n\nfunc (sr *sinkRegistry) newFileSinkFromURL(u *url.URL) (Sink, error) {\n\tif u.User != nil {\n\t\treturn nil, fmt.Errorf(\"user and password not allowed with file URLs: got %v\", u)\n\t}\n\tif u.Fragment != \"\" {\n\t\treturn nil, fmt.Errorf(\"fragments not allowed with file URLs: got %v\", u)\n\t}\n\tif u.RawQuery != \"\" {\n\t\treturn nil, fmt.Errorf(\"query parameters not allowed with file URLs: got %v\", u)\n\t}\n\t// Error messages are better if we check hostname and port separately.\n\tif u.Port() != \"\" {\n\t\treturn nil, fmt.Errorf(\"ports not allowed with file URLs: got %v\", u)\n\t}\n\tif hn := u.Hostname(); hn != \"\" && hn != \"localhost\" {\n\t\treturn nil, fmt.Errorf(\"file URLs must leave host empty or use localhost: got %v\", u)\n\t}\n\n\treturn sr.newFileSinkFromPath(u.Path)\n}\n\nfunc (sr *sinkRegistry) newFileSinkFromPath(path string) (Sink, error) {\n\tswitch path {\n\tcase \"stdout\":\n\t\treturn nopCloserSink{os.Stdout}, nil\n\tcase \"stderr\":\n\t\treturn nopCloserSink{os.Stderr}, nil\n\t}\n\treturn sr.openFile(path, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0o666)\n}\n\nfunc normalizeScheme(s string) (string, error) {\n\t// https://tools.ietf.org/html/rfc3986#section-3.1\n\ts = strings.ToLower(s)\n\tif first := s[0]; 'a' > first || 'z' < first {\n\t\treturn \"\", errors.New(\"must start with a letter\")\n\t}\n\tfor i := 1; i < len(s); i++ { // iterate over bytes, not runes\n\t\tc := s[i]\n\t\tswitch {\n\t\tcase 'a' <= c && c <= 'z':\n\t\t\tcontinue\n\t\tcase '0' <= c && c <= '9':\n\t\t\tcontinue\n\t\tcase c == '.' || c == '+' || c == '-':\n\t\t\tcontinue\n\t\t}\n\t\treturn \"\", fmt.Errorf(\"may not contain %q\", c)\n\t}\n\treturn s, nil\n}\n"
        },
        {
          "name": "sink_test.go",
          "type": "blob",
          "size": 3.2822265625,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"go.uber.org/zap/zapcore\"\n)\n\nfunc stubSinkRegistry(t testing.TB) *sinkRegistry {\n\torigSinkRegistry := _sinkRegistry\n\tt.Cleanup(func() {\n\t\t_sinkRegistry = origSinkRegistry\n\t})\n\n\tr := newSinkRegistry()\n\t_sinkRegistry = r\n\treturn r\n}\n\nfunc TestRegisterSink(t *testing.T) {\n\tstubSinkRegistry(t)\n\n\tconst (\n\t\tmemScheme = \"mem\"\n\t\tnopScheme = \"no-op.1234\"\n\t)\n\tvar memCalls, nopCalls int\n\n\tbuf := bytes.NewBuffer(nil)\n\tmemFactory := func(u *url.URL) (Sink, error) {\n\t\tassert.Equal(t, u.Scheme, memScheme, \"Scheme didn't match registration.\")\n\t\tmemCalls++\n\t\treturn nopCloserSink{zapcore.AddSync(buf)}, nil\n\t}\n\tnopFactory := func(u *url.URL) (Sink, error) {\n\t\tassert.Equal(t, u.Scheme, nopScheme, \"Scheme didn't match registration.\")\n\t\tnopCalls++\n\t\treturn nopCloserSink{zapcore.AddSync(io.Discard)}, nil\n\t}\n\n\trequire.NoError(t, RegisterSink(strings.ToUpper(memScheme), memFactory), \"Failed to register scheme %q.\", memScheme)\n\trequire.NoError(t, RegisterSink(nopScheme, nopFactory), \"Failed to register scheme %q.\", nopScheme)\n\n\tsink, closeSink, err := Open(\n\t\tmemScheme+\"://somewhere\",\n\t\tnopScheme+\"://somewhere-else\",\n\t)\n\trequire.NoError(t, err, \"Unexpected error opening URLs with registered schemes.\")\n\tdefer closeSink()\n\n\tassert.Equal(t, 1, memCalls, \"Unexpected number of calls to memory factory.\")\n\tassert.Equal(t, 1, nopCalls, \"Unexpected number of calls to no-op factory.\")\n\n\t_, err = sink.Write([]byte(\"foo\"))\n\tassert.NoError(t, err, \"Failed to write to combined WriteSyncer.\")\n\tassert.Equal(t, \"foo\", buf.String(), \"Unexpected buffer contents.\")\n}\n\nfunc TestRegisterSinkErrors(t *testing.T) {\n\tnopFactory := func(_ *url.URL) (Sink, error) {\n\t\treturn nopCloserSink{zapcore.AddSync(io.Discard)}, nil\n\t}\n\ttests := []struct {\n\t\tscheme string\n\t\terr    string\n\t}{\n\t\t{\"\", \"empty string\"},\n\t\t{\"FILE\", \"already registered\"},\n\t\t{\"42\", \"not a valid scheme\"},\n\t\t{\"http*\", \"not a valid scheme\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(\"scheme-\"+tt.scheme, func(t *testing.T) {\n\t\t\tr := newSinkRegistry()\n\t\t\terr := r.RegisterSink(tt.scheme, nopFactory)\n\t\t\tassert.ErrorContains(t, err, tt.err)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "sink_windows_test.go",
          "type": "blob",
          "size": 2.09765625,
          "content": "// Copyright (c) 2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n//go:build windows\n\npackage zap\n\nimport (\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestWindowsPaths(t *testing.T) {\n\t// See https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats\n\ttests := []struct {\n\t\tmsg  string\n\t\tpath string\n\t}{\n\t\t{\n\t\t\tmsg:  \"local path with drive\",\n\t\t\tpath: `c:\\log.json`,\n\t\t},\n\t\t{\n\t\t\tmsg:  \"local path with drive using forward slash\",\n\t\t\tpath: `c:/log.json`,\n\t\t},\n\t\t{\n\t\t\tmsg:  \"local path without drive\",\n\t\t\tpath: `\\Temp\\log.json`,\n\t\t},\n\t\t{\n\t\t\tmsg:  \"unc path\",\n\t\t\tpath: `\\\\Server2\\Logs\\log.json`,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.msg, func(t *testing.T) {\n\t\t\tsr := newSinkRegistry()\n\n\t\t\topenFilename := \"<not called>\"\n\t\t\tsr.openFile = func(filename string, _ int, _ os.FileMode) (*os.File, error) {\n\t\t\t\topenFilename = filename\n\t\t\t\treturn nil, assert.AnError\n\t\t\t}\n\n\t\t\t_, err := sr.newSink(tt.path)\n\t\t\tassert.Equal(t, assert.AnError, err, \"expect stub error from OpenFile\")\n\t\t\tassert.Equal(t, tt.path, openFilename, \"unexpected path opened\")\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "stacktrace_ext_test.go",
          "type": "blob",
          "size": 7.228515625,
          "content": "// Copyright (c) 2016, 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"go.uber.org/zap\"\n\t\"go.uber.org/zap/zapcore\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n// _zapPackages are packages that we search for in the logging output to match a\n// zap stack frame. It is different from _zapStacktracePrefixes which  is only\n// intended to match on the function name, while this is on the full output\n// which includes filenames.\nvar _zapPackages = []string{\n\t\"go.uber.org/zap.\",\n\t\"go.uber.org/zap/zapcore.\",\n}\n\nfunc TestStacktraceFiltersZapLog(t *testing.T) {\n\twithLogger(t, func(logger *zap.Logger, out *bytes.Buffer) {\n\t\tlogger.Error(\"test log\")\n\t\tlogger.Sugar().Error(\"sugar test log\")\n\n\t\trequire.Contains(t, out.String(), \"TestStacktraceFiltersZapLog\", \"Should not strip out non-zap import\")\n\t\tverifyNoZap(t, out.String())\n\t})\n}\n\nfunc TestStacktraceFiltersZapMarshal(t *testing.T) {\n\twithLogger(t, func(logger *zap.Logger, out *bytes.Buffer) {\n\t\tmarshal := func(enc zapcore.ObjectEncoder) error {\n\t\t\tlogger.Warn(\"marshal caused warn\")\n\t\t\tenc.AddString(\"f\", \"v\")\n\t\t\treturn nil\n\t\t}\n\t\tlogger.Error(\"test log\", zap.Object(\"obj\", zapcore.ObjectMarshalerFunc(marshal)))\n\n\t\tlogs := out.String()\n\n\t\t// The marshal function (which will be under the test function) should not be stripped.\n\t\tconst marshalFnPrefix = \"TestStacktraceFiltersZapMarshal.\"\n\t\trequire.Contains(t, logs, marshalFnPrefix, \"Should not strip out marshal call\")\n\n\t\t// There should be no zap stack traces before that point.\n\t\tmarshalIndex := strings.Index(logs, marshalFnPrefix)\n\t\tverifyNoZap(t, logs[:marshalIndex])\n\n\t\t// After that point, there should be zap stack traces - we don't want to strip out\n\t\t// the Marshal caller information.\n\t\tfor _, fnPrefix := range _zapPackages {\n\t\t\trequire.Contains(t, logs[marshalIndex:], fnPrefix, \"Missing zap caller stack for Marshal\")\n\t\t}\n\t})\n}\n\nfunc TestStacktraceFiltersVendorZap(t *testing.T) {\n\t// We already have the dependencies downloaded so this should be\n\t// instant.\n\tdeps := downloadDependencies(t)\n\n\t// We need to simulate a zap as a vendor library, so we're going to\n\t// create a fake GOPATH and run the above test which will contain zap\n\t// in the vendor directory.\n\twithGoPath(t, func(goPath string) {\n\t\tzapDir, err := os.Getwd()\n\t\trequire.NoError(t, err, \"Failed to get current directory\")\n\n\t\ttestDir := filepath.Join(goPath, \"src/go.uber.org/zap_test/\")\n\t\tvendorDir := filepath.Join(testDir, \"vendor\")\n\t\trequire.NoError(t, os.MkdirAll(testDir, 0o777), \"Failed to create source director\")\n\n\t\tcurFile := getSelfFilename(t)\n\t\tsetupSymlink(t, curFile, filepath.Join(testDir, curFile))\n\n\t\t// Set up symlinks for zap, and for any test dependencies.\n\t\tsetupSymlink(t, zapDir, filepath.Join(vendorDir, \"go.uber.org/zap\"))\n\t\tfor _, dep := range deps {\n\t\t\tsetupSymlink(t, dep.Dir, filepath.Join(vendorDir, dep.ImportPath))\n\t\t}\n\n\t\t// Now run the above test which ensures we filter out zap\n\t\t// stacktraces, but this time zap is in a vendor\n\t\tcmd := exec.Command(\"go\", \"test\", \"-v\", \"-run\", \"TestStacktraceFiltersZap\")\n\t\tcmd.Dir = testDir\n\t\tcmd.Env = append(os.Environ(), \"GO111MODULE=off\")\n\t\tout, err := cmd.CombinedOutput()\n\t\trequire.NoError(t, err, \"Failed to run test in vendor directory, output: %s\", out)\n\t\tassert.Contains(t, string(out), \"PASS\")\n\t})\n}\n\nfunc TestStacktraceWithoutCallerSkip(t *testing.T) {\n\twithLogger(t, func(logger *zap.Logger, out *bytes.Buffer) {\n\t\tfunc() {\n\t\t\tlogger.Error(\"test log\")\n\t\t}()\n\n\t\trequire.Contains(t, out.String(), \"TestStacktraceWithoutCallerSkip.\", \"Should not skip too much\")\n\t\tverifyNoZap(t, out.String())\n\t})\n}\n\nfunc TestStacktraceWithCallerSkip(t *testing.T) {\n\twithLogger(t, func(logger *zap.Logger, out *bytes.Buffer) {\n\t\tlogger = logger.WithOptions(zap.AddCallerSkip(2))\n\t\tfunc() {\n\t\t\tlogger.Error(\"test log\")\n\t\t}()\n\n\t\trequire.NotContains(t, out.String(), \"TestStacktraceWithCallerSkip.\", \"Should skip as requested by caller skip\")\n\t\trequire.Contains(t, out.String(), \"TestStacktraceWithCallerSkip\", \"Should not skip too much\")\n\t\tverifyNoZap(t, out.String())\n\t})\n}\n\n// withLogger sets up a logger with a real encoder set up, so that any marshal functions are called.\n// The inbuilt observer does not call Marshal for objects/arrays, which we need for some tests.\nfunc withLogger(t *testing.T, fn func(logger *zap.Logger, out *bytes.Buffer)) {\n\tbuf := &bytes.Buffer{}\n\tencoder := zapcore.NewConsoleEncoder(zap.NewDevelopmentEncoderConfig())\n\tcore := zapcore.NewCore(encoder, zapcore.AddSync(buf), zapcore.DebugLevel)\n\tlogger := zap.New(core, zap.AddStacktrace(zap.DebugLevel))\n\tfn(logger, buf)\n}\n\nfunc verifyNoZap(t *testing.T, logs string) {\n\tfor _, fnPrefix := range _zapPackages {\n\t\trequire.NotContains(t, logs, fnPrefix, \"Should not strip out marshal call\")\n\t}\n}\n\nfunc withGoPath(t *testing.T, f func(goPath string)) {\n\tgoPath := filepath.Join(t.TempDir(), \"gopath\")\n\tt.Setenv(\"GOPATH\", goPath)\n\n\tf(goPath)\n}\n\nfunc getSelfFilename(t *testing.T) string {\n\t_, file, _, ok := runtime.Caller(0)\n\trequire.True(t, ok, \"Failed to get caller information to identify local file\")\n\n\treturn filepath.Base(file)\n}\n\nfunc setupSymlink(t *testing.T, src, dst string) {\n\t// Make sure the destination directory exists.\n\trequire.NoError(t, os.MkdirAll(filepath.Dir(dst), 0o777))\n\n\t// Get absolute path of the source for the symlink, otherwise we can create a symlink\n\t// that uses relative paths.\n\tsrcAbs, err := filepath.Abs(src)\n\trequire.NoError(t, err, \"Failed to get absolute path\")\n\n\trequire.NoError(t, os.Symlink(srcAbs, dst), \"Failed to set up symlink\")\n}\n\ntype dependency struct {\n\tImportPath string `json:\"Path\"` // import path of the dependency\n\tDir        string `json:\"Dir\"`  // location on disk\n}\n\n// Downloads all dependencies for the current Go module and reports their\n// module paths and locations on disk.\nfunc downloadDependencies(t *testing.T) []dependency {\n\tcmd := exec.Command(\"go\", \"mod\", \"download\", \"-json\")\n\n\tstdout, err := cmd.Output()\n\trequire.NoError(t, err, \"Failed to run 'go mod download'\")\n\n\tvar deps []dependency\n\tdec := json.NewDecoder(bytes.NewBuffer(stdout))\n\tfor dec.More() {\n\t\tvar d dependency\n\t\trequire.NoError(t, dec.Decode(&d), \"Failed to decode dependency\")\n\t\tdeps = append(deps, d)\n\t}\n\n\treturn deps\n}\n"
        },
        {
          "name": "sugar.go",
          "type": "blob",
          "size": 15.6279296875,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"fmt\"\n\n\t\"go.uber.org/zap/zapcore\"\n\n\t\"go.uber.org/multierr\"\n)\n\nconst (\n\t_oddNumberErrMsg    = \"Ignored key without a value.\"\n\t_nonStringKeyErrMsg = \"Ignored key-value pairs with non-string keys.\"\n\t_multipleErrMsg     = \"Multiple errors without a key.\"\n)\n\n// A SugaredLogger wraps the base Logger functionality in a slower, but less\n// verbose, API. Any Logger can be converted to a SugaredLogger with its Sugar\n// method.\n//\n// Unlike the Logger, the SugaredLogger doesn't insist on structured logging.\n// For each log level, it exposes four methods:\n//\n//   - methods named after the log level for log.Print-style logging\n//   - methods ending in \"w\" for loosely-typed structured logging\n//   - methods ending in \"f\" for log.Printf-style logging\n//   - methods ending in \"ln\" for log.Println-style logging\n//\n// For example, the methods for InfoLevel are:\n//\n//\tInfo(...any)           Print-style logging\n//\tInfow(...any)          Structured logging (read as \"info with\")\n//\tInfof(string, ...any)  Printf-style logging\n//\tInfoln(...any)         Println-style logging\ntype SugaredLogger struct {\n\tbase *Logger\n}\n\n// Desugar unwraps a SugaredLogger, exposing the original Logger. Desugaring\n// is quite inexpensive, so it's reasonable for a single application to use\n// both Loggers and SugaredLoggers, converting between them on the boundaries\n// of performance-sensitive code.\nfunc (s *SugaredLogger) Desugar() *Logger {\n\tbase := s.base.clone()\n\tbase.callerSkip -= 2\n\treturn base\n}\n\n// Named adds a sub-scope to the logger's name. See Logger.Named for details.\nfunc (s *SugaredLogger) Named(name string) *SugaredLogger {\n\treturn &SugaredLogger{base: s.base.Named(name)}\n}\n\n// WithOptions clones the current SugaredLogger, applies the supplied Options,\n// and returns the result. It's safe to use concurrently.\nfunc (s *SugaredLogger) WithOptions(opts ...Option) *SugaredLogger {\n\tbase := s.base.clone()\n\tfor _, opt := range opts {\n\t\topt.apply(base)\n\t}\n\treturn &SugaredLogger{base: base}\n}\n\n// With adds a variadic number of fields to the logging context. It accepts a\n// mix of strongly-typed Field objects and loosely-typed key-value pairs. When\n// processing pairs, the first element of the pair is used as the field key\n// and the second as the field value.\n//\n// For example,\n//\n//\t sugaredLogger.With(\n//\t   \"hello\", \"world\",\n//\t   \"failure\", errors.New(\"oh no\"),\n//\t   Stack(),\n//\t   \"count\", 42,\n//\t   \"user\", User{Name: \"alice\"},\n//\t)\n//\n// is the equivalent of\n//\n//\tunsugared.With(\n//\t  String(\"hello\", \"world\"),\n//\t  String(\"failure\", \"oh no\"),\n//\t  Stack(),\n//\t  Int(\"count\", 42),\n//\t  Object(\"user\", User{Name: \"alice\"}),\n//\t)\n//\n// Note that the keys in key-value pairs should be strings. In development,\n// passing a non-string key panics. In production, the logger is more\n// forgiving: a separate error is logged, but the key-value pair is skipped\n// and execution continues. Passing an orphaned key triggers similar behavior:\n// panics in development and errors in production.\nfunc (s *SugaredLogger) With(args ...interface{}) *SugaredLogger {\n\treturn &SugaredLogger{base: s.base.With(s.sweetenFields(args)...)}\n}\n\n// WithLazy adds a variadic number of fields to the logging context lazily.\n// The fields are evaluated only if the logger is further chained with [With]\n// or is written to with any of the log level methods.\n// Until that occurs, the logger may retain references to objects inside the fields,\n// and logging will reflect the state of an object at the time of logging,\n// not the time of WithLazy().\n//\n// Similar to [With], fields added to the child don't affect the parent,\n// and vice versa. Also, the keys in key-value pairs should be strings. In development,\n// passing a non-string key panics, while in production it logs an error and skips the pair.\n// Passing an orphaned key has the same behavior.\nfunc (s *SugaredLogger) WithLazy(args ...interface{}) *SugaredLogger {\n\treturn &SugaredLogger{base: s.base.WithLazy(s.sweetenFields(args)...)}\n}\n\n// Level reports the minimum enabled level for this logger.\n//\n// For NopLoggers, this is [zapcore.InvalidLevel].\nfunc (s *SugaredLogger) Level() zapcore.Level {\n\treturn zapcore.LevelOf(s.base.core)\n}\n\n// Log logs the provided arguments at provided level.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Log(lvl zapcore.Level, args ...interface{}) {\n\ts.log(lvl, \"\", args, nil)\n}\n\n// Debug logs the provided arguments at [DebugLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Debug(args ...interface{}) {\n\ts.log(DebugLevel, \"\", args, nil)\n}\n\n// Info logs the provided arguments at [InfoLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Info(args ...interface{}) {\n\ts.log(InfoLevel, \"\", args, nil)\n}\n\n// Warn logs the provided arguments at [WarnLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Warn(args ...interface{}) {\n\ts.log(WarnLevel, \"\", args, nil)\n}\n\n// Error logs the provided arguments at [ErrorLevel].\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Error(args ...interface{}) {\n\ts.log(ErrorLevel, \"\", args, nil)\n}\n\n// DPanic logs the provided arguments at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) DPanic(args ...interface{}) {\n\ts.log(DPanicLevel, \"\", args, nil)\n}\n\n// Panic constructs a message with the provided arguments and panics.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Panic(args ...interface{}) {\n\ts.log(PanicLevel, \"\", args, nil)\n}\n\n// Fatal constructs a message with the provided arguments and calls os.Exit.\n// Spaces are added between arguments when neither is a string.\nfunc (s *SugaredLogger) Fatal(args ...interface{}) {\n\ts.log(FatalLevel, \"\", args, nil)\n}\n\n// Logf formats the message according to the format specifier\n// and logs it at provided level.\nfunc (s *SugaredLogger) Logf(lvl zapcore.Level, template string, args ...interface{}) {\n\ts.log(lvl, template, args, nil)\n}\n\n// Debugf formats the message according to the format specifier\n// and logs it at [DebugLevel].\nfunc (s *SugaredLogger) Debugf(template string, args ...interface{}) {\n\ts.log(DebugLevel, template, args, nil)\n}\n\n// Infof formats the message according to the format specifier\n// and logs it at [InfoLevel].\nfunc (s *SugaredLogger) Infof(template string, args ...interface{}) {\n\ts.log(InfoLevel, template, args, nil)\n}\n\n// Warnf formats the message according to the format specifier\n// and logs it at [WarnLevel].\nfunc (s *SugaredLogger) Warnf(template string, args ...interface{}) {\n\ts.log(WarnLevel, template, args, nil)\n}\n\n// Errorf formats the message according to the format specifier\n// and logs it at [ErrorLevel].\nfunc (s *SugaredLogger) Errorf(template string, args ...interface{}) {\n\ts.log(ErrorLevel, template, args, nil)\n}\n\n// DPanicf formats the message according to the format specifier\n// and logs it at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\nfunc (s *SugaredLogger) DPanicf(template string, args ...interface{}) {\n\ts.log(DPanicLevel, template, args, nil)\n}\n\n// Panicf formats the message according to the format specifier\n// and panics.\nfunc (s *SugaredLogger) Panicf(template string, args ...interface{}) {\n\ts.log(PanicLevel, template, args, nil)\n}\n\n// Fatalf formats the message according to the format specifier\n// and calls os.Exit.\nfunc (s *SugaredLogger) Fatalf(template string, args ...interface{}) {\n\ts.log(FatalLevel, template, args, nil)\n}\n\n// Logw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Logw(lvl zapcore.Level, msg string, keysAndValues ...interface{}) {\n\ts.log(lvl, msg, nil, keysAndValues)\n}\n\n// Debugw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\n//\n// When debug-level logging is disabled, this is much faster than\n//\n//\ts.With(keysAndValues).Debug(msg)\nfunc (s *SugaredLogger) Debugw(msg string, keysAndValues ...interface{}) {\n\ts.log(DebugLevel, msg, nil, keysAndValues)\n}\n\n// Infow logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Infow(msg string, keysAndValues ...interface{}) {\n\ts.log(InfoLevel, msg, nil, keysAndValues)\n}\n\n// Warnw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Warnw(msg string, keysAndValues ...interface{}) {\n\ts.log(WarnLevel, msg, nil, keysAndValues)\n}\n\n// Errorw logs a message with some additional context. The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) Errorw(msg string, keysAndValues ...interface{}) {\n\ts.log(ErrorLevel, msg, nil, keysAndValues)\n}\n\n// DPanicw logs a message with some additional context. In development, the\n// logger then panics. (See DPanicLevel for details.) The variadic key-value\n// pairs are treated as they are in With.\nfunc (s *SugaredLogger) DPanicw(msg string, keysAndValues ...interface{}) {\n\ts.log(DPanicLevel, msg, nil, keysAndValues)\n}\n\n// Panicw logs a message with some additional context, then panics. The\n// variadic key-value pairs are treated as they are in With.\nfunc (s *SugaredLogger) Panicw(msg string, keysAndValues ...interface{}) {\n\ts.log(PanicLevel, msg, nil, keysAndValues)\n}\n\n// Fatalw logs a message with some additional context, then calls os.Exit. The\n// variadic key-value pairs are treated as they are in With.\nfunc (s *SugaredLogger) Fatalw(msg string, keysAndValues ...interface{}) {\n\ts.log(FatalLevel, msg, nil, keysAndValues)\n}\n\n// Logln logs a message at provided level.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Logln(lvl zapcore.Level, args ...interface{}) {\n\ts.logln(lvl, args, nil)\n}\n\n// Debugln logs a message at [DebugLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Debugln(args ...interface{}) {\n\ts.logln(DebugLevel, args, nil)\n}\n\n// Infoln logs a message at [InfoLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Infoln(args ...interface{}) {\n\ts.logln(InfoLevel, args, nil)\n}\n\n// Warnln logs a message at [WarnLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Warnln(args ...interface{}) {\n\ts.logln(WarnLevel, args, nil)\n}\n\n// Errorln logs a message at [ErrorLevel].\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Errorln(args ...interface{}) {\n\ts.logln(ErrorLevel, args, nil)\n}\n\n// DPanicln logs a message at [DPanicLevel].\n// In development, the logger then panics. (See [DPanicLevel] for details.)\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) DPanicln(args ...interface{}) {\n\ts.logln(DPanicLevel, args, nil)\n}\n\n// Panicln logs a message at [PanicLevel] and panics.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Panicln(args ...interface{}) {\n\ts.logln(PanicLevel, args, nil)\n}\n\n// Fatalln logs a message at [FatalLevel] and calls os.Exit.\n// Spaces are always added between arguments.\nfunc (s *SugaredLogger) Fatalln(args ...interface{}) {\n\ts.logln(FatalLevel, args, nil)\n}\n\n// Sync flushes any buffered log entries.\nfunc (s *SugaredLogger) Sync() error {\n\treturn s.base.Sync()\n}\n\n// log message with Sprint, Sprintf, or neither.\nfunc (s *SugaredLogger) log(lvl zapcore.Level, template string, fmtArgs []interface{}, context []interface{}) {\n\t// If logging at this level is completely disabled, skip the overhead of\n\t// string formatting.\n\tif lvl < DPanicLevel && !s.base.Core().Enabled(lvl) {\n\t\treturn\n\t}\n\n\tmsg := getMessage(template, fmtArgs)\n\tif ce := s.base.Check(lvl, msg); ce != nil {\n\t\tce.Write(s.sweetenFields(context)...)\n\t}\n}\n\n// logln message with Sprintln\nfunc (s *SugaredLogger) logln(lvl zapcore.Level, fmtArgs []interface{}, context []interface{}) {\n\tif lvl < DPanicLevel && !s.base.Core().Enabled(lvl) {\n\t\treturn\n\t}\n\n\tmsg := getMessageln(fmtArgs)\n\tif ce := s.base.Check(lvl, msg); ce != nil {\n\t\tce.Write(s.sweetenFields(context)...)\n\t}\n}\n\n// getMessage format with Sprint, Sprintf, or neither.\nfunc getMessage(template string, fmtArgs []interface{}) string {\n\tif len(fmtArgs) == 0 {\n\t\treturn template\n\t}\n\n\tif template != \"\" {\n\t\treturn fmt.Sprintf(template, fmtArgs...)\n\t}\n\n\tif len(fmtArgs) == 1 {\n\t\tif str, ok := fmtArgs[0].(string); ok {\n\t\t\treturn str\n\t\t}\n\t}\n\treturn fmt.Sprint(fmtArgs...)\n}\n\n// getMessageln format with Sprintln.\nfunc getMessageln(fmtArgs []interface{}) string {\n\tmsg := fmt.Sprintln(fmtArgs...)\n\treturn msg[:len(msg)-1]\n}\n\nfunc (s *SugaredLogger) sweetenFields(args []interface{}) []Field {\n\tif len(args) == 0 {\n\t\treturn nil\n\t}\n\n\tvar (\n\t\t// Allocate enough space for the worst case; if users pass only structured\n\t\t// fields, we shouldn't penalize them with extra allocations.\n\t\tfields    = make([]Field, 0, len(args))\n\t\tinvalid   invalidPairs\n\t\tseenError bool\n\t)\n\n\tfor i := 0; i < len(args); {\n\t\t// This is a strongly-typed field. Consume it and move on.\n\t\tif f, ok := args[i].(Field); ok {\n\t\t\tfields = append(fields, f)\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\n\t\t// If it is an error, consume it and move on.\n\t\tif err, ok := args[i].(error); ok {\n\t\t\tif !seenError {\n\t\t\t\tseenError = true\n\t\t\t\tfields = append(fields, Error(err))\n\t\t\t} else {\n\t\t\t\ts.base.Error(_multipleErrMsg, Error(err))\n\t\t\t}\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\n\t\t// Make sure this element isn't a dangling key.\n\t\tif i == len(args)-1 {\n\t\t\ts.base.Error(_oddNumberErrMsg, Any(\"ignored\", args[i]))\n\t\t\tbreak\n\t\t}\n\n\t\t// Consume this value and the next, treating them as a key-value pair. If the\n\t\t// key isn't a string, add this pair to the slice of invalid pairs.\n\t\tkey, val := args[i], args[i+1]\n\t\tif keyStr, ok := key.(string); !ok {\n\t\t\t// Subsequent errors are likely, so allocate once up front.\n\t\t\tif cap(invalid) == 0 {\n\t\t\t\tinvalid = make(invalidPairs, 0, len(args)/2)\n\t\t\t}\n\t\t\tinvalid = append(invalid, invalidPair{i, key, val})\n\t\t} else {\n\t\t\tfields = append(fields, Any(keyStr, val))\n\t\t}\n\t\ti += 2\n\t}\n\n\t// If we encountered any invalid key-value pairs, log an error.\n\tif len(invalid) > 0 {\n\t\ts.base.Error(_nonStringKeyErrMsg, Array(\"invalid\", invalid))\n\t}\n\treturn fields\n}\n\ntype invalidPair struct {\n\tposition   int\n\tkey, value interface{}\n}\n\nfunc (p invalidPair) MarshalLogObject(enc zapcore.ObjectEncoder) error {\n\tenc.AddInt64(\"position\", int64(p.position))\n\tAny(\"key\", p.key).AddTo(enc)\n\tAny(\"value\", p.value).AddTo(enc)\n\treturn nil\n}\n\ntype invalidPairs []invalidPair\n\nfunc (ps invalidPairs) MarshalLogArray(enc zapcore.ArrayEncoder) error {\n\tvar err error\n\tfor i := range ps {\n\t\terr = multierr.Append(err, enc.AppendObject(ps[i]))\n\t}\n\treturn err\n}\n"
        },
        {
          "name": "sugar_test.go",
          "type": "blob",
          "size": 19.244140625,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"go.uber.org/zap/internal/exit\"\n\t\"go.uber.org/zap/internal/ztest\"\n\t\"go.uber.org/zap/zapcore\"\n\t\"go.uber.org/zap/zaptest/observer\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestSugarWith(t *testing.T) {\n\t// Convenience functions to create expected error logs.\n\tignored := func(msg interface{}) observer.LoggedEntry {\n\t\treturn observer.LoggedEntry{\n\t\t\tEntry:   zapcore.Entry{Level: ErrorLevel, Message: _oddNumberErrMsg},\n\t\t\tContext: []Field{Any(\"ignored\", msg)},\n\t\t}\n\t}\n\tnonString := func(pairs ...invalidPair) observer.LoggedEntry {\n\t\treturn observer.LoggedEntry{\n\t\t\tEntry:   zapcore.Entry{Level: ErrorLevel, Message: _nonStringKeyErrMsg},\n\t\t\tContext: []Field{Array(\"invalid\", invalidPairs(pairs))},\n\t\t}\n\t}\n\tignoredError := func(err error) observer.LoggedEntry {\n\t\treturn observer.LoggedEntry{\n\t\t\tEntry:   zapcore.Entry{Level: ErrorLevel, Message: _multipleErrMsg},\n\t\t\tContext: []Field{Error(err)},\n\t\t}\n\t}\n\n\ttype withAny func(*SugaredLogger, ...interface{}) *SugaredLogger\n\twithMethods := []withAny{(*SugaredLogger).With, (*SugaredLogger).WithLazy}\n\n\ttests := []struct {\n\t\tdesc     string\n\t\targs     []interface{}\n\t\texpected []Field\n\t\terrLogs  []observer.LoggedEntry\n\t}{\n\t\t{\n\t\t\tdesc:     \"nil args\",\n\t\t\targs:     nil,\n\t\t\texpected: []Field{},\n\t\t\terrLogs:  nil,\n\t\t},\n\t\t{\n\t\t\tdesc:     \"empty slice of args\",\n\t\t\targs:     []interface{}{},\n\t\t\texpected: []Field{},\n\t\t\terrLogs:  nil,\n\t\t},\n\t\t{\n\t\t\tdesc:     \"just a dangling key\",\n\t\t\targs:     []interface{}{\"should ignore\"},\n\t\t\texpected: []Field{},\n\t\t\terrLogs:  []observer.LoggedEntry{ignored(\"should ignore\")},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"well-formed key-value pairs\",\n\t\t\targs:     []interface{}{\"foo\", 42, \"true\", \"bar\"},\n\t\t\texpected: []Field{Int(\"foo\", 42), String(\"true\", \"bar\")},\n\t\t\terrLogs:  nil,\n\t\t},\n\t\t{\n\t\t\tdesc:     \"just a structured field\",\n\t\t\targs:     []interface{}{Int(\"foo\", 42)},\n\t\t\texpected: []Field{Int(\"foo\", 42)},\n\t\t\terrLogs:  nil,\n\t\t},\n\t\t{\n\t\t\tdesc:     \"structured field and a dangling key\",\n\t\t\targs:     []interface{}{Int(\"foo\", 42), \"dangling\"},\n\t\t\texpected: []Field{Int(\"foo\", 42)},\n\t\t\terrLogs:  []observer.LoggedEntry{ignored(\"dangling\")},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"structured field and a dangling non-string key\",\n\t\t\targs:     []interface{}{Int(\"foo\", 42), 13},\n\t\t\texpected: []Field{Int(\"foo\", 42)},\n\t\t\terrLogs:  []observer.LoggedEntry{ignored(13)},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"key-value pair and a dangling key\",\n\t\t\targs:     []interface{}{\"foo\", 42, \"dangling\"},\n\t\t\texpected: []Field{Int(\"foo\", 42)},\n\t\t\terrLogs:  []observer.LoggedEntry{ignored(\"dangling\")},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"pairs, a structured field, and a dangling key\",\n\t\t\targs:     []interface{}{\"first\", \"field\", Int(\"foo\", 42), \"baz\", \"quux\", \"dangling\"},\n\t\t\texpected: []Field{String(\"first\", \"field\"), Int(\"foo\", 42), String(\"baz\", \"quux\")},\n\t\t\terrLogs:  []observer.LoggedEntry{ignored(\"dangling\")},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"one non-string key\",\n\t\t\targs:     []interface{}{\"foo\", 42, true, \"bar\"},\n\t\t\texpected: []Field{Int(\"foo\", 42)},\n\t\t\terrLogs:  []observer.LoggedEntry{nonString(invalidPair{2, true, \"bar\"})},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"pairs, structured fields, non-string keys, and a dangling key\",\n\t\t\targs:     []interface{}{\"foo\", 42, true, \"bar\", Int(\"structure\", 11), 42, \"reversed\", \"baz\", \"quux\", \"dangling\"},\n\t\t\texpected: []Field{Int(\"foo\", 42), Int(\"structure\", 11), String(\"baz\", \"quux\")},\n\t\t\terrLogs: []observer.LoggedEntry{\n\t\t\t\tignored(\"dangling\"),\n\t\t\t\tnonString(invalidPair{2, true, \"bar\"}, invalidPair{5, 42, \"reversed\"}),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdesc:     \"multiple errors\",\n\t\t\targs:     []interface{}{errors.New(\"first\"), errors.New(\"second\"), errors.New(\"third\")},\n\t\t\texpected: []Field{Error(errors.New(\"first\"))},\n\t\t\terrLogs: []observer.LoggedEntry{\n\t\t\t\tignoredError(errors.New(\"second\")),\n\t\t\t\tignoredError(errors.New(\"third\")),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tfor _, withMethod := range withMethods {\n\t\t\twithSugar(t, DebugLevel, nil, func(logger *SugaredLogger, logs *observer.ObservedLogs) {\n\t\t\t\twithMethod(logger, tt.args...).Info(\"\")\n\t\t\t\toutput := logs.AllUntimed()\n\t\t\t\tif len(tt.errLogs) > 0 {\n\t\t\t\t\tfor i := range tt.errLogs {\n\t\t\t\t\t\tassert.Equal(t, tt.errLogs[i], output[i], \"Unexpected error log at position %d for scenario %s.\", i, tt.desc)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert.Equal(t, len(tt.errLogs)+1, len(output), \"Expected only one non-error message to be logged in scenario %s.\", tt.desc)\n\t\t\t\tassert.Equal(t, tt.expected, output[len(tt.errLogs)].Context, \"Unexpected message context in scenario %s.\", tt.desc)\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc TestSugarWithCaptures(t *testing.T) {\n\ttype withAny func(*SugaredLogger, ...interface{}) *SugaredLogger\n\n\ttests := []struct {\n\t\tname        string\n\t\twithMethods []withAny\n\t\twantJSON    []string\n\t}{\n\t\t{\n\t\t\tname:        \"with captures arguments at time of With\",\n\t\t\twithMethods: []withAny{(*SugaredLogger).With},\n\t\t\twantJSON: []string{\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"hello 0\",\n\t\t\t\t\t\"a0\": [0],\n\t\t\t\t\t\"b0\": [1]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"world 0\",\n\t\t\t\t\t\"a0\": [0],\n\t\t\t\t\t\"c0\": [2]\n\t\t\t\t}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:        \"lazy with captures arguments at time of Logging\",\n\t\t\twithMethods: []withAny{(*SugaredLogger).WithLazy},\n\t\t\twantJSON: []string{\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"hello 0\",\n\t\t\t\t\t\"a0\": [1],\n\t\t\t\t\t\"b0\": [1]\n\t\t\t\t}`,\n\t\t\t\t`{\n\t\t\t\t\t\"m\": \"world 0\",\n\t\t\t\t\t\"a0\": [1],\n\t\t\t\t\t\"c0\": [2]\n\t\t\t\t}`,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tenc := zapcore.NewJSONEncoder(zapcore.EncoderConfig{\n\t\t\t\tMessageKey: \"m\",\n\t\t\t})\n\n\t\t\tvar bs ztest.Buffer\n\t\t\tlogger := New(zapcore.NewCore(enc, &bs, DebugLevel)).Sugar()\n\n\t\t\tfor i, withMethod := range tt.withMethods {\n\t\t\t\tiStr := strconv.Itoa(i)\n\t\t\t\tx := 10 * i\n\t\t\t\tarr := zapcore.ArrayMarshalerFunc(func(enc zapcore.ArrayEncoder) error {\n\t\t\t\t\tenc.AppendInt(x)\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\n\t\t\t\tlogger = withMethod(logger, Array(\"a\"+iStr, arr))\n\t\t\t\tx++\n\t\t\t\tlogger.Infow(fmt.Sprintf(\"hello %d\", i), Array(\"b\"+iStr, arr))\n\t\t\t\tx++\n\t\t\t\tlogger = withMethod(logger, Array(\"c\"+iStr, arr))\n\t\t\t\tlogger.Infow(fmt.Sprintf(\"world %d\", i))\n\t\t\t}\n\n\t\t\tif lines := bs.Lines(); assert.Len(t, lines, len(tt.wantJSON)) {\n\t\t\t\tfor i, want := range tt.wantJSON {\n\t\t\t\t\tassert.JSONEq(t, want, lines[i], \"Unexpected output from the %d'th log.\", i)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSugaredLoggerLevel(t *testing.T) {\n\tlevels := []zapcore.Level{\n\t\tDebugLevel,\n\t\tInfoLevel,\n\t\tWarnLevel,\n\t\tErrorLevel,\n\t\tDPanicLevel,\n\t\tPanicLevel,\n\t\tFatalLevel,\n\t}\n\n\tfor _, lvl := range levels {\n\t\tlvl := lvl\n\t\tt.Run(lvl.String(), func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tcore, _ := observer.New(lvl)\n\t\t\tlog := New(core).Sugar()\n\t\t\tassert.Equal(t, lvl, log.Level())\n\t\t})\n\t}\n\n\tt.Run(\"Nop\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\tassert.Equal(t, zapcore.InvalidLevel, NewNop().Sugar().Level())\n\t})\n}\n\nfunc TestSugarFieldsInvalidPairs(t *testing.T) {\n\twithSugar(t, DebugLevel, nil, func(logger *SugaredLogger, logs *observer.ObservedLogs) {\n\t\tlogger.With(42, \"foo\", []string{\"bar\"}, \"baz\").Info(\"\")\n\t\toutput := logs.AllUntimed()\n\n\t\t// Double-check that the actual message was logged.\n\t\trequire.Equal(t, 2, len(output), \"Unexpected number of entries logged.\")\n\t\trequire.Equal(t, observer.LoggedEntry{Context: []Field{}}, output[1], \"Unexpected non-error log entry.\")\n\n\t\t// Assert that the error message's structured fields serialize properly.\n\t\trequire.Equal(t, 1, len(output[0].Context), \"Expected one field in error entry context.\")\n\t\tenc := zapcore.NewMapObjectEncoder()\n\t\toutput[0].Context[0].AddTo(enc)\n\t\tassert.Equal(t, []interface{}{\n\t\t\tmap[string]interface{}{\"position\": int64(0), \"key\": int64(42), \"value\": \"foo\"},\n\t\t\tmap[string]interface{}{\"position\": int64(2), \"key\": []interface{}{\"bar\"}, \"value\": \"baz\"},\n\t\t}, enc.Fields[\"invalid\"], \"Unexpected output when logging invalid key-value pairs.\")\n\t})\n}\n\nfunc TestSugarStructuredLogging(t *testing.T) {\n\ttests := []struct {\n\t\tmsg       string\n\t\texpectMsg string\n\t}{\n\t\t{\"foo\", \"foo\"},\n\t\t{\"\", \"\"},\n\t}\n\n\t// Common to all test cases.\n\tvar (\n\t\terr            = errors.New(\"qux\")\n\t\tcontext        = []interface{}{\"foo\", \"bar\"}\n\t\textra          = []interface{}{err, \"baz\", false}\n\t\texpectedFields = []Field{String(\"foo\", \"bar\"), Error(err), Bool(\"baz\", false)}\n\t)\n\n\tfor _, tt := range tests {\n\t\twithSugar(t, DebugLevel, nil, func(logger *SugaredLogger, logs *observer.ObservedLogs) {\n\t\t\tlogger.With(context...).Debugw(tt.msg, extra...)\n\t\t\tlogger.With(context...).Infow(tt.msg, extra...)\n\t\t\tlogger.With(context...).Warnw(tt.msg, extra...)\n\t\t\tlogger.With(context...).Errorw(tt.msg, extra...)\n\t\t\tlogger.With(context...).DPanicw(tt.msg, extra...)\n\t\t\tlogger.With(context...).Logw(WarnLevel, tt.msg, extra...)\n\n\t\t\texpected := make([]observer.LoggedEntry, 6)\n\t\t\tfor i, lvl := range []zapcore.Level{DebugLevel, InfoLevel, WarnLevel, ErrorLevel, DPanicLevel, WarnLevel} {\n\t\t\t\texpected[i] = observer.LoggedEntry{\n\t\t\t\t\tEntry:   zapcore.Entry{Message: tt.expectMsg, Level: lvl},\n\t\t\t\t\tContext: expectedFields,\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert.Equal(t, expected, logs.AllUntimed(), \"Unexpected log output.\")\n\t\t})\n\t}\n}\n\nfunc TestSugarConcatenatingLogging(t *testing.T) {\n\ttests := []struct {\n\t\targs   []interface{}\n\t\texpect string\n\t}{\n\t\t{[]interface{}{nil}, \"<nil>\"},\n\t}\n\n\t// Common to all test cases.\n\tcontext := []interface{}{\"foo\", \"bar\"}\n\texpectedFields := []Field{String(\"foo\", \"bar\")}\n\n\tfor _, tt := range tests {\n\t\twithSugar(t, DebugLevel, nil, func(logger *SugaredLogger, logs *observer.ObservedLogs) {\n\t\t\tlogger.With(context...).Debug(tt.args...)\n\t\t\tlogger.With(context...).Info(tt.args...)\n\t\t\tlogger.With(context...).Warn(tt.args...)\n\t\t\tlogger.With(context...).Error(tt.args...)\n\t\t\tlogger.With(context...).DPanic(tt.args...)\n\t\t\tlogger.With(context...).Log(InfoLevel, tt.args...)\n\n\t\t\texpected := make([]observer.LoggedEntry, 6)\n\t\t\tfor i, lvl := range []zapcore.Level{DebugLevel, InfoLevel, WarnLevel, ErrorLevel, DPanicLevel, InfoLevel} {\n\t\t\t\texpected[i] = observer.LoggedEntry{\n\t\t\t\t\tEntry:   zapcore.Entry{Message: tt.expect, Level: lvl},\n\t\t\t\t\tContext: expectedFields,\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert.Equal(t, expected, logs.AllUntimed(), \"Unexpected log output.\")\n\t\t})\n\t}\n}\n\nfunc TestSugarTemplatedLogging(t *testing.T) {\n\ttests := []struct {\n\t\tformat string\n\t\targs   []interface{}\n\t\texpect string\n\t}{\n\t\t{\"\", nil, \"\"},\n\t\t{\"foo\", nil, \"foo\"},\n\t\t// If the user fails to pass a template, degrade to fmt.Sprint.\n\t\t{\"\", []interface{}{\"foo\"}, \"foo\"},\n\t}\n\n\t// Common to all test cases.\n\tcontext := []interface{}{\"foo\", \"bar\"}\n\texpectedFields := []Field{String(\"foo\", \"bar\")}\n\n\tfor _, tt := range tests {\n\t\twithSugar(t, DebugLevel, nil, func(logger *SugaredLogger, logs *observer.ObservedLogs) {\n\t\t\tlogger.With(context...).Debugf(tt.format, tt.args...)\n\t\t\tlogger.With(context...).Infof(tt.format, tt.args...)\n\t\t\tlogger.With(context...).Warnf(tt.format, tt.args...)\n\t\t\tlogger.With(context...).Errorf(tt.format, tt.args...)\n\t\t\tlogger.With(context...).DPanicf(tt.format, tt.args...)\n\t\t\tlogger.With(context...).Logf(ErrorLevel, tt.format, tt.args...)\n\n\t\t\texpected := make([]observer.LoggedEntry, 6)\n\t\t\tfor i, lvl := range []zapcore.Level{DebugLevel, InfoLevel, WarnLevel, ErrorLevel, DPanicLevel, ErrorLevel} {\n\t\t\t\texpected[i] = observer.LoggedEntry{\n\t\t\t\t\tEntry:   zapcore.Entry{Message: tt.expect, Level: lvl},\n\t\t\t\t\tContext: expectedFields,\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert.Equal(t, expected, logs.AllUntimed(), \"Unexpected log output.\")\n\t\t})\n\t}\n}\n\nfunc TestSugarLnLogging(t *testing.T) {\n\ttests := []struct {\n\t\targs   []interface{}\n\t\texpect string\n\t}{\n\t\t{nil, \"\"},\n\t\t{[]interface{}{}, \"\"},\n\t\t{[]interface{}{\"\"}, \"\"},\n\t\t{[]interface{}{\"foo\"}, \"foo\"},\n\t\t{[]interface{}{\"foo\", \"bar\"}, \"foo bar\"},\n\t}\n\n\t// Common to all test cases.\n\tcontext := []interface{}{\"foo\", \"bar\"}\n\texpectedFields := []Field{String(\"foo\", \"bar\")}\n\n\tfor _, tt := range tests {\n\t\twithSugar(t, DebugLevel, nil, func(logger *SugaredLogger, logs *observer.ObservedLogs) {\n\t\t\tlogger.With(context...).Debugln(tt.args...)\n\t\t\tlogger.With(context...).Infoln(tt.args...)\n\t\t\tlogger.With(context...).Warnln(tt.args...)\n\t\t\tlogger.With(context...).Errorln(tt.args...)\n\t\t\tlogger.With(context...).DPanicln(tt.args...)\n\t\t\tlogger.With(context...).Logln(InfoLevel, tt.args...)\n\n\t\t\texpected := make([]observer.LoggedEntry, 6)\n\t\t\tfor i, lvl := range []zapcore.Level{DebugLevel, InfoLevel, WarnLevel, ErrorLevel, DPanicLevel, InfoLevel} {\n\t\t\t\texpected[i] = observer.LoggedEntry{\n\t\t\t\t\tEntry:   zapcore.Entry{Message: tt.expect, Level: lvl},\n\t\t\t\t\tContext: expectedFields,\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert.Equal(t, expected, logs.AllUntimed(), \"Unexpected log output.\")\n\t\t})\n\t}\n}\n\nfunc TestSugarLnLoggingIgnored(t *testing.T) {\n\twithSugar(t, WarnLevel, nil, func(logger *SugaredLogger, logs *observer.ObservedLogs) {\n\t\tlogger.Infoln(\"hello\")\n\t\tassert.Zero(t, logs.Len(), \"Expected zero log statements.\")\n\t})\n}\n\nfunc TestSugarPanicLogging(t *testing.T) {\n\ttests := []struct {\n\t\tloggerLevel zapcore.Level\n\t\tf           func(*SugaredLogger)\n\t\texpectedMsg string\n\t}{\n\t\t{FatalLevel, func(s *SugaredLogger) { s.Panic(\"foo\") }, \"\"},\n\t\t{PanicLevel, func(s *SugaredLogger) { s.Panic(\"foo\") }, \"foo\"},\n\t\t{DebugLevel, func(s *SugaredLogger) { s.Panic(\"foo\") }, \"foo\"},\n\t\t{FatalLevel, func(s *SugaredLogger) { s.Panicf(\"%s\", \"foo\") }, \"\"},\n\t\t{PanicLevel, func(s *SugaredLogger) { s.Panicf(\"%s\", \"foo\") }, \"foo\"},\n\t\t{DebugLevel, func(s *SugaredLogger) { s.Panicf(\"%s\", \"foo\") }, \"foo\"},\n\t\t{FatalLevel, func(s *SugaredLogger) { s.Panicw(\"foo\") }, \"\"},\n\t\t{PanicLevel, func(s *SugaredLogger) { s.Panicw(\"foo\") }, \"foo\"},\n\t\t{DebugLevel, func(s *SugaredLogger) { s.Panicw(\"foo\") }, \"foo\"},\n\t\t{FatalLevel, func(s *SugaredLogger) { s.Panicln(\"foo\") }, \"\"},\n\t\t{PanicLevel, func(s *SugaredLogger) { s.Panicln(\"foo\") }, \"foo\"},\n\t\t{DebugLevel, func(s *SugaredLogger) { s.Panicln(\"foo\") }, \"foo\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\twithSugar(t, tt.loggerLevel, nil, func(sugar *SugaredLogger, logs *observer.ObservedLogs) {\n\t\t\tassert.Panics(t, func() { tt.f(sugar) }, \"Expected panic-level logger calls to panic.\")\n\t\t\tif tt.expectedMsg != \"\" {\n\t\t\t\tassert.Equal(t, []observer.LoggedEntry{{\n\t\t\t\t\tContext: []Field{},\n\t\t\t\t\tEntry:   zapcore.Entry{Message: tt.expectedMsg, Level: PanicLevel},\n\t\t\t\t}}, logs.AllUntimed(), \"Unexpected log output.\")\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, 0, logs.Len(), \"Didn't expect any log output.\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSugarFatalLogging(t *testing.T) {\n\ttests := []struct {\n\t\tloggerLevel zapcore.Level\n\t\tf           func(*SugaredLogger)\n\t\texpectedMsg string\n\t}{\n\t\t{FatalLevel + 1, func(s *SugaredLogger) { s.Fatal(\"foo\") }, \"\"},\n\t\t{FatalLevel, func(s *SugaredLogger) { s.Fatal(\"foo\") }, \"foo\"},\n\t\t{DebugLevel, func(s *SugaredLogger) { s.Fatal(\"foo\") }, \"foo\"},\n\t\t{FatalLevel + 1, func(s *SugaredLogger) { s.Fatalf(\"%s\", \"foo\") }, \"\"},\n\t\t{FatalLevel, func(s *SugaredLogger) { s.Fatalf(\"%s\", \"foo\") }, \"foo\"},\n\t\t{DebugLevel, func(s *SugaredLogger) { s.Fatalf(\"%s\", \"foo\") }, \"foo\"},\n\t\t{FatalLevel + 1, func(s *SugaredLogger) { s.Fatalw(\"foo\") }, \"\"},\n\t\t{FatalLevel, func(s *SugaredLogger) { s.Fatalw(\"foo\") }, \"foo\"},\n\t\t{DebugLevel, func(s *SugaredLogger) { s.Fatalw(\"foo\") }, \"foo\"},\n\t\t{FatalLevel + 1, func(s *SugaredLogger) { s.Fatalln(\"foo\") }, \"\"},\n\t\t{FatalLevel, func(s *SugaredLogger) { s.Fatalln(\"foo\") }, \"foo\"},\n\t\t{DebugLevel, func(s *SugaredLogger) { s.Fatalln(\"foo\") }, \"foo\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\twithSugar(t, tt.loggerLevel, nil, func(sugar *SugaredLogger, logs *observer.ObservedLogs) {\n\t\t\tstub := exit.WithStub(func() { tt.f(sugar) })\n\t\t\tassert.True(t, stub.Exited, \"Expected all calls to fatal logger methods to exit process.\")\n\t\t\tif tt.expectedMsg != \"\" {\n\t\t\t\tassert.Equal(t, []observer.LoggedEntry{{\n\t\t\t\t\tContext: []Field{},\n\t\t\t\t\tEntry:   zapcore.Entry{Message: tt.expectedMsg, Level: FatalLevel},\n\t\t\t\t}}, logs.AllUntimed(), \"Unexpected log output.\")\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, 0, logs.Len(), \"Didn't expect any log output.\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSugarAddCaller(t *testing.T) {\n\ttests := []struct {\n\t\toptions []Option\n\t\tpat     string\n\t}{\n\t\t{opts(AddCaller()), `.+/sugar_test.go:[\\d]+$`},\n\t\t{opts(AddCaller(), AddCallerSkip(1), AddCallerSkip(-1)), `.+/sugar_test.go:[\\d]+$`},\n\t\t{opts(AddCaller(), AddCallerSkip(1)), `.+/common_test.go:[\\d]+$`},\n\t\t{opts(AddCaller(), AddCallerSkip(1), AddCallerSkip(5)), `.+/src/runtime/.*:[\\d]+$`},\n\t}\n\tfor _, tt := range tests {\n\t\twithSugar(t, DebugLevel, tt.options, func(logger *SugaredLogger, logs *observer.ObservedLogs) {\n\t\t\tlogger.Info(\"\")\n\t\t\toutput := logs.AllUntimed()\n\t\t\tassert.Equal(t, 1, len(output), \"Unexpected number of logs written out.\")\n\t\t\tassert.Regexp(\n\t\t\t\tt,\n\t\t\t\ttt.pat,\n\t\t\t\toutput[0].Caller,\n\t\t\t\t\"Expected to find package name and file name in output.\",\n\t\t\t)\n\t\t})\n\t}\n}\n\nfunc TestSugarAddCallerFail(t *testing.T) {\n\terrBuf := &ztest.Buffer{}\n\twithSugar(t, DebugLevel, opts(AddCaller(), AddCallerSkip(1e3), ErrorOutput(errBuf)), func(log *SugaredLogger, logs *observer.ObservedLogs) {\n\t\tlog.Info(\"Failure.\")\n\t\tassert.Regexp(\n\t\t\tt,\n\t\t\t`Logger.check error: failed to get caller`,\n\t\t\terrBuf.String(),\n\t\t\t\"Didn't find expected failure message.\",\n\t\t)\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\tlogs.AllUntimed()[0].Message,\n\t\t\t\"Failure.\",\n\t\t\t\"Expected original message to survive failures in runtime.Caller.\")\n\t})\n}\n\nfunc TestSugarWithOptionsIncreaseLevel(t *testing.T) {\n\twithSugar(t, DebugLevel, nil, func(logger *SugaredLogger, logs *observer.ObservedLogs) {\n\t\tlogger = logger.WithOptions(IncreaseLevel(WarnLevel))\n\t\tlogger.Info(\"logger.Info\")\n\t\tlogger.Warn(\"logger.Warn\")\n\t\tlogger.Error(\"logger.Error\")\n\t\trequire.Equal(t, 2, logs.Len(), \"expected only warn + error logs due to IncreaseLevel.\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\tlogs.AllUntimed()[0].Message,\n\t\t\t\"logger.Warn\",\n\t\t\t\"Expected first logged message to be warn level message\",\n\t\t)\n\t})\n}\n\nfunc TestSugarLnWithOptionsIncreaseLevel(t *testing.T) {\n\twithSugar(t, DebugLevel, nil, func(logger *SugaredLogger, logs *observer.ObservedLogs) {\n\t\tlogger = logger.WithOptions(IncreaseLevel(WarnLevel))\n\t\tlogger.Infoln(\"logger.Infoln\")\n\t\tlogger.Warnln(\"logger.Warnln\")\n\t\tlogger.Errorln(\"logger.Errorln\")\n\t\trequire.Equal(t, 2, logs.Len(), \"expected only warn + error logs due to IncreaseLevel.\")\n\t\tassert.Equal(\n\t\t\tt,\n\t\t\tlogs.AllUntimed()[0].Message,\n\t\t\t\"logger.Warnln\",\n\t\t\t\"Expected first logged message to be warn level message\",\n\t\t)\n\t})\n}\n\nfunc BenchmarkSugarSingleStrArg(b *testing.B) {\n\twithSugar(b, InfoLevel, nil /* opts* */, func(log *SugaredLogger, logs *observer.ObservedLogs) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tlog.Info(\"hello world\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkLnSugarSingleStrArg(b *testing.B) {\n\twithSugar(b, InfoLevel, nil /* opts* */, func(log *SugaredLogger, logs *observer.ObservedLogs) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tlog.Infoln(\"hello world\")\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "time.go",
          "type": "blob",
          "size": 1.208984375,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport \"time\"\n\nfunc timeToMillis(t time.Time) int64 {\n\treturn t.UnixNano() / int64(time.Millisecond)\n}\n"
        },
        {
          "name": "time_test.go",
          "type": "blob",
          "size": 1.5244140625,
          "content": "// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestTimeToMillis(t *testing.T) {\n\ttests := []struct {\n\t\tt     time.Time\n\t\tstamp int64\n\t}{\n\t\t{t: time.Unix(0, 0), stamp: 0},\n\t\t{t: time.Unix(1, 0), stamp: 1000},\n\t\t{t: time.Unix(1, int64(500*time.Millisecond)), stamp: 1500},\n\t}\n\tfor _, tt := range tests {\n\t\tassert.Equal(t, tt.stamp, timeToMillis(tt.t), \"Unexpected timestamp for time %v.\", tt.t)\n\t}\n}\n"
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "writer.go",
          "type": "blob",
          "size": 3.48828125,
          "content": "// Copyright (c) 2016-2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\n\t\"go.uber.org/zap/zapcore\"\n\n\t\"go.uber.org/multierr\"\n)\n\n// Open is a high-level wrapper that takes a variadic number of URLs, opens or\n// creates each of the specified resources, and combines them into a locked\n// WriteSyncer. It also returns any error encountered and a function to close\n// any opened files.\n//\n// Passing no URLs returns a no-op WriteSyncer. Zap handles URLs without a\n// scheme and URLs with the \"file\" scheme. Third-party code may register\n// factories for other schemes using RegisterSink.\n//\n// URLs with the \"file\" scheme must use absolute paths on the local\n// filesystem. No user, password, port, fragments, or query parameters are\n// allowed, and the hostname must be empty or \"localhost\".\n//\n// Since it's common to write logs to the local filesystem, URLs without a\n// scheme (e.g., \"/var/log/foo.log\") are treated as local file paths. Without\n// a scheme, the special paths \"stdout\" and \"stderr\" are interpreted as\n// os.Stdout and os.Stderr. When specified without a scheme, relative file\n// paths also work.\nfunc Open(paths ...string) (zapcore.WriteSyncer, func(), error) {\n\twriters, closeAll, err := open(paths)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\twriter := CombineWriteSyncers(writers...)\n\treturn writer, closeAll, nil\n}\n\nfunc open(paths []string) ([]zapcore.WriteSyncer, func(), error) {\n\twriters := make([]zapcore.WriteSyncer, 0, len(paths))\n\tclosers := make([]io.Closer, 0, len(paths))\n\tcloseAll := func() {\n\t\tfor _, c := range closers {\n\t\t\t_ = c.Close()\n\t\t}\n\t}\n\n\tvar openErr error\n\tfor _, path := range paths {\n\t\tsink, err := _sinkRegistry.newSink(path)\n\t\tif err != nil {\n\t\t\topenErr = multierr.Append(openErr, fmt.Errorf(\"open sink %q: %w\", path, err))\n\t\t\tcontinue\n\t\t}\n\t\twriters = append(writers, sink)\n\t\tclosers = append(closers, sink)\n\t}\n\tif openErr != nil {\n\t\tcloseAll()\n\t\treturn nil, nil, openErr\n\t}\n\n\treturn writers, closeAll, nil\n}\n\n// CombineWriteSyncers is a utility that combines multiple WriteSyncers into a\n// single, locked WriteSyncer. If no inputs are supplied, it returns a no-op\n// WriteSyncer.\n//\n// It's provided purely as a convenience; the result is no different from\n// using zapcore.NewMultiWriteSyncer and zapcore.Lock individually.\nfunc CombineWriteSyncers(writers ...zapcore.WriteSyncer) zapcore.WriteSyncer {\n\tif len(writers) == 0 {\n\t\treturn zapcore.AddSync(io.Discard)\n\t}\n\treturn zapcore.Lock(zapcore.NewMultiWriteSyncer(writers...))\n}\n"
        },
        {
          "name": "writer_test.go",
          "type": "blob",
          "size": 6.91796875,
          "content": "// Copyright (c) 2016-2022 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage zap\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"io/fs\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/multierr\"\n\t\"go.uber.org/zap/zapcore\"\n)\n\nfunc TestOpenNoPaths(t *testing.T) {\n\tws, cleanup, err := Open()\n\tdefer cleanup()\n\n\tassert.NoError(t, err, \"Expected opening no paths to succeed.\")\n\tassert.Equal(\n\t\tt,\n\t\tzapcore.AddSync(io.Discard),\n\t\tws,\n\t\t\"Expected opening no paths to return a no-op WriteSyncer.\",\n\t)\n}\n\nfunc TestOpen(t *testing.T) {\n\ttempName := filepath.Join(t.TempDir(), \"test.log\")\n\tassert.False(t, fileExists(tempName))\n\trequire.True(t, filepath.IsAbs(tempName), \"Expected absolute temp file path.\")\n\n\ttests := []struct {\n\t\tmsg   string\n\t\tpaths []string\n\t}{\n\t\t{\n\t\t\tmsg:   \"stdout\",\n\t\t\tpaths: []string{\"stdout\"},\n\t\t},\n\t\t{\n\t\t\tmsg:   \"stderr\",\n\t\t\tpaths: []string{\"stderr\"},\n\t\t},\n\t\t{\n\t\t\tmsg:   \"temp file path only\",\n\t\t\tpaths: []string{tempName},\n\t\t},\n\t\t{\n\t\t\tmsg:   \"temp file file scheme\",\n\t\t\tpaths: []string{\"file://\" + tempName},\n\t\t},\n\t\t{\n\t\t\tmsg:   \"temp file with file scheme and host localhost\",\n\t\t\tpaths: []string{\"file://localhost\" + tempName},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.msg, func(t *testing.T) {\n\t\t\t_, cleanup, err := Open(tt.paths...)\n\t\t\tif err == nil {\n\t\t\t\tdefer cleanup()\n\t\t\t}\n\n\t\t\tassert.NoError(t, err, \"Unexpected error opening paths %v.\", tt.paths)\n\t\t})\n\t}\n\n\tassert.True(t, fileExists(tempName))\n}\n\nfunc TestOpenPathsNotFound(t *testing.T) {\n\ttempName := filepath.Join(t.TempDir(), \"test.log\")\n\n\ttests := []struct {\n\t\tmsg               string\n\t\tpaths             []string\n\t\twantNotFoundPaths []string\n\t}{\n\t\t{\n\t\t\tmsg:               \"missing path\",\n\t\t\tpaths:             []string{\"/foo/bar/baz\"},\n\t\t\twantNotFoundPaths: []string{\"/foo/bar/baz\"},\n\t\t},\n\t\t{\n\t\t\tmsg:               \"missing file scheme url with host localhost\",\n\t\t\tpaths:             []string{\"file://localhost/foo/bar/baz\"},\n\t\t\twantNotFoundPaths: []string{\"/foo/bar/baz\"},\n\t\t},\n\t\t{\n\t\t\tmsg:   \"multiple paths\",\n\t\t\tpaths: []string{\"stdout\", \"/foo/bar/baz\", tempName, \"file:///baz/quux\"},\n\t\t\twantNotFoundPaths: []string{\n\t\t\t\t\"/foo/bar/baz\",\n\t\t\t\t\"/baz/quux\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.msg, func(t *testing.T) {\n\t\t\t_, cleanup, err := Open(tt.paths...)\n\t\t\tif !assert.Error(t, err, \"Open must fail.\") {\n\t\t\t\tcleanup()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terrs := multierr.Errors(err)\n\t\t\trequire.Len(t, errs, len(tt.wantNotFoundPaths))\n\t\t\tfor i, err := range errs {\n\t\t\t\tassert.ErrorIs(t, err, fs.ErrNotExist)\n\t\t\t\tassert.ErrorContains(t, err, tt.wantNotFoundPaths[i], \"missing path in error\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestOpenRelativePath(t *testing.T) {\n\tconst name = \"test-relative-path.txt\"\n\n\trequire.False(t, fileExists(name), \"Test file already exists.\")\n\ts, cleanup, err := Open(name)\n\trequire.NoError(t, err, \"Open failed.\")\n\tdefer func() {\n\t\terr := os.Remove(name)\n\t\tif !t.Failed() {\n\t\t\t// If the test has already failed, we probably didn't create this file.\n\t\t\trequire.NoError(t, err, \"Deleting test file failed.\")\n\t\t}\n\t}()\n\tdefer cleanup()\n\n\t_, err = s.Write([]byte(\"test\"))\n\tassert.NoError(t, err, \"Write failed.\")\n\tassert.True(t, fileExists(name), \"Didn't create file for relative path.\")\n}\n\nfunc TestOpenFails(t *testing.T) {\n\ttests := []struct {\n\t\tpaths []string\n\t}{\n\t\t{paths: []string{\"./non-existent-dir/file\"}},           // directory doesn't exist\n\t\t{paths: []string{\"stdout\", \"./non-existent-dir/file\"}}, // directory doesn't exist\n\t\t{paths: []string{\"://foo.log\"}},                        // invalid URL, scheme can't begin with colon\n\t\t{paths: []string{\"mem://somewhere\"}},                   // scheme not registered\n\t}\n\n\tfor _, tt := range tests {\n\t\t_, cleanup, err := Open(tt.paths...)\n\t\trequire.Nil(t, cleanup, \"Cleanup function should be nil\")\n\t\tassert.Error(t, err, \"Open with invalid URL should fail.\")\n\t}\n}\n\nfunc TestOpenOtherErrors(t *testing.T) {\n\ttempName := filepath.Join(t.TempDir(), \"test.log\")\n\n\ttests := []struct {\n\t\tmsg     string\n\t\tpaths   []string\n\t\twantErr string\n\t}{\n\t\t{\n\t\t\tmsg:     \"file with unexpected host\",\n\t\t\tpaths:   []string{\"file://host01.test.com\" + tempName},\n\t\t\twantErr: \"empty or use localhost\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"file with user on localhost\",\n\t\t\tpaths:   []string{\"file://rms@localhost\" + tempName},\n\t\t\twantErr: \"user and password not allowed\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"file url with fragment\",\n\t\t\tpaths:   []string{\"file://localhost\" + tempName + \"#foo\"},\n\t\t\twantErr: \"fragments not allowed\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"file url with query\",\n\t\t\tpaths:   []string{\"file://localhost\" + tempName + \"?foo=bar\"},\n\t\t\twantErr: \"query parameters not allowed\",\n\t\t},\n\t\t{\n\t\t\tmsg:     \"file with port\",\n\t\t\tpaths:   []string{\"file://localhost:8080\" + tempName},\n\t\t\twantErr: \"ports not allowed\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.msg, func(t *testing.T) {\n\t\t\t_, cleanup, err := Open(tt.paths...)\n\t\t\tif !assert.Error(t, err, \"Open must fail.\") {\n\t\t\t\tcleanup()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tassert.ErrorContains(t, err, tt.wantErr, \"Unexpected error opening paths %v.\", tt.paths)\n\t\t})\n\t}\n}\n\ntype testWriter struct {\n\texpected string\n\tt        testing.TB\n}\n\nfunc (w *testWriter) Write(actual []byte) (int, error) {\n\tassert.Equal(w.t, []byte(w.expected), actual, \"Unexpected write error.\")\n\treturn len(actual), nil\n}\n\nfunc (w *testWriter) Sync() error {\n\treturn nil\n}\n\nfunc TestOpenWithErroringSinkFactory(t *testing.T) {\n\tstubSinkRegistry(t)\n\n\tmsg := \"expected factory error\"\n\tfactory := func(_ *url.URL) (Sink, error) {\n\t\treturn nil, errors.New(msg)\n\t}\n\n\tassert.NoError(t, RegisterSink(\"test\", factory), \"Failed to register sink factory.\")\n\t_, _, err := Open(\"test://some/path\")\n\tassert.ErrorContains(t, err, msg)\n}\n\nfunc TestCombineWriteSyncers(t *testing.T) {\n\ttw := &testWriter{\"test\", t}\n\tw := CombineWriteSyncers(tw)\n\t_, err := w.Write([]byte(\"test\"))\n\tassert.NoError(t, err, \"Unexpected write error.\")\n}\n\nfunc fileExists(name string) bool {\n\tif _, err := os.Stat(name); os.IsNotExist(err) {\n\t\treturn false\n\t}\n\treturn true\n}\n"
        },
        {
          "name": "zapcore",
          "type": "tree",
          "content": null
        },
        {
          "name": "zapgrpc",
          "type": "tree",
          "content": null
        },
        {
          "name": "zapio",
          "type": "tree",
          "content": null
        },
        {
          "name": "zaptest",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}